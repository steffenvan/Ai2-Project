<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000005">
<title confidence="0.992908">
Generating XTAG Parsers from Algebraic Specifications∗
</title>
<author confidence="0.991519">
Carlos G´omez-Rodriguez and Miguel A. Alonso Manuel Vilares
</author>
<affiliation confidence="0.730181">
Departamento de Computaci´on E. S. de Ingenieria Inform´atica
Universidade da Coru˜na Universidad de Vigo
Campus de Elvi˜na, s/n Campus As Lagoas, s/n
15071 A Coru˜na, Spain 32004 Ourense, Spain
</affiliation>
<email confidence="0.997669">
{cgomezr, alonso}@udc.es vilares@uvigo.es
</email>
<sectionHeader confidence="0.993831" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999946">
In this paper, a generic system that gener-
ates parsers from parsing schemata is ap-
plied to the particular case of the XTAG
English grammar. In order to be able to
generate XTAG parsers, some transforma-
tions are made to the grammar, and TAG
parsing schemata are extended with fea-
ture structure unification support and a
simple tree filtering mechanism. The gen-
erated implementations allow us to study
the performance of different TAG parsers
when working with a large-scale, wide-
coverage grammar.
</bodyText>
<sectionHeader confidence="0.998964" genericHeader="keywords">
1 Introduction
</sectionHeader>
<bodyText confidence="0.985267796296296">
Since Tree Adjoining Grammars (TAG) were in-
troduced, several different parsing algorithms for
these grammars have been developed, each with
its peculiar characteristics. Identifying the advan-
tages and disadvantages of each of them is not
trivial, and there are no comparative studies be-
tween them in the literature that work with real-
life, wide coverage grammars. In this paper, we
use a generic tool based on parsing schemata to
generate implementations of several TAG parsers
and compare them by parsing with the XTAG En-
glish Grammar (XTAG, 2001).
The parsing schemata formalism (Sikkel, 1997)
is a framework that allows us to describe parsers in
a simple and declarative way. A parsing schema
∗ Partially supported by Ministerio de Educaci´on y Cien-
cia and FEDER (TIN2004-07246-C03-01, TIN2004-07246-
C03-02), Xunta de Galicia (PGIDIT05PXIC30501PN,
PGIDIT05PXIC10501PN, PGIDIT05SIN044E and
PGIDIT05SIN059E), and Programa de becas FPU (Mi-
nisterio de Educaci´on y Ciencia). We are grateful to Eric
Villemonte de la Clergerie and Franc¸ois Barthelemy for their
help in converting the XTAG grammar to XML.
is a representation of a parsing algorithm as a
set of inference rules which are used to perform
deductions on intermediate results called items.
These items represent sets of incomplete parse
trees which the algorithm can generate. An input
sentence to be analyzed produces an initial set of
items. Additionally, a parsing schema must de-
fine a criterion to determine which items are final,
i.e. which items correspond to complete parses of
the input sentence. If it is possible to obtain a fi-
nal item from the set of initial items by using the
schema’s inference rules (called deductive steps),
then the input sentence belongs to the language de-
fined by the grammar. The parse forest can then be
retrieved from the intermediate items used to infer
the final items, as in (Billot and Lang, 1989).
As an example, we introduce a CYK-based
algorithm (Vijay-Shanker and Joshi, 1985) for
TAG. Given a tree adjoining grammar G =
(VT, VN, S, I, A)1 and a sentence of length n
which we denote by a1 a2 ... an2, we de-
note by P(G) the set of productions {N&apos;Y →
N&apos;Y1 N&apos;Y2 ... N&apos;Y� } such that N&apos;Y is an inner node of
a tree ry E (I U A), and N&apos;Y1 N&apos;Y2 ... N&apos;Y� is the or-
dered sequence of direct children of N&apos;Y.
The parsing schema for the TAG CYK-based
algorithm (Alonso et al., 1999) is a function that
maps such a grammar G to a deduction system
whose domain is the set of items
{[N&apos;Y, i, j, p, q, adj]}
verifying that N&apos;Y is a tree node in an elementary
</bodyText>
<footnote confidence="0.99673075">
1Where VT denotes the set of terminal symbols, Vv the
set of nonterminal symbols, S the axiom, I the set of initial
trees and A the set of auxiliary trees.
2From now on, we will follow the usual conventions by
which nonterminal symbols are represented by uppercase let-
ters (A, B ...), and terminals by lowercase letters (a, b ...).
Greek letters (α, β...) will be used to represent trees, Nry a
node in the tree -y, and Rry the root node of the tree -y.
</footnote>
<page confidence="0.990003">
103
</page>
<bodyText confidence="0.954728592592593">
Proceedings of the 8th International Workshop on Tree Adjoining Grammar and Related Formalisms, pages 103–108,
Sydney, July 2006. c�2006 Association for Computational Linguistics
tree y E (I U A), i and j (0 &lt; i &lt; j) are string
positions, p and q may be undefined or instanti-
ated to positions i &lt; p &lt; q &lt; j (the latter only
when y E A), and adj E {true, false} indi-
cates whether an adjunction has been performed
on node N&apos;&apos;.
The positions i and j indicate that a substring
az+1 ... aj of the string is being recognized, and
positions p and q denote the substring dominated
by y’s foot node. The final item set would be
{[Rα, 0, n, −, −, adj]  |α E I}
for the presence of such an item would indicate
that there exists a valid parse tree with yield a1 a2
... an and rooted at Rα, the root of an initial tree;
and therefore there exists a complete parse tree for
the sentence.
A deductive step η1...η&amp;quot;t ξb allows us to infer
the item specified by its consequent ξ from those
in its antecedents B1 ... Bryn. Side conditions (b)
specify the valid values for the variables appearing
in the antecedents and consequent, and may refer
to grammar rules or specify other constraints that
must be verified in order to infer the consequent.
The deductive steps for our CYK-based parser are
shown in figure 1. The steps DScan
</bodyText>
<sectionHeader confidence="0.601027" genericHeader="introduction">
CYK and DECYK are
</sectionHeader>
<bodyText confidence="0.961017666666667">
used to start the bottom-up parsing process by rec-
ognizing a terminal symbol for the input string, or
none if we are using a tree with an epsilon node.
</bodyText>
<subsectionHeader confidence="0.634886">
The DBinary
</subsectionHeader>
<bodyText confidence="0.9736925">
CYK step (where the operation p U p&apos; re-
turns p if p is defined, and p&apos; otherwise) represents
the bottom-up parsing operation which joins two
subtrees into one, and is analogous to one of the
deductive steps of the CYK parser for CFG. The
DUnary
CYK step is used to handle unary branching pro-
ductions. DFoot
</bodyText>
<subsectionHeader confidence="0.438161">
CYK and DAdj
</subsectionHeader>
<bodyText confidence="0.999795">
CYK implement the adjunc-
tion operation, where a tree Q is adjoined into a
node N&apos;&apos;; their side condition Q E adj(N&apos;&apos;) means
that Q must be adjoinable into the node N&apos;&apos; (which
involves checking that N&apos;&apos; is an adjunction node,
comparing its label to RO’s and verifying that no
adjunction constraint disallows the operation). Fi-
nally, the DSubs
CYK step implements the substitution
operation in grammars supporting it.
As can be seen from the example, parsing
schemata are simple, high-level descriptions that
convey the fundamental semantics of parsing algo-
rithms while abstracting implementation details:
they define a set of possible intermediate results
and allowed operations on them, but they don’t
specify data structures for storing the results or an
order for the operations to be executed. This high
abstraction level makes schemata useful for defin-
ing, comparing and analyzing parsers in pencil and
paper without worrying about implementation de-
tails. However, if we want to actually execute
the parsers and analyze their results and perfor-
mance in a computer, they must be implemented
in a programming language, making it necessary
to lose the high level of abstraction in order to ob-
tain functional and efficient implementations.
In order to bridge this gap between theory and
practice, we have designed and implemented a
system able to automatically transform parsing
schemata into efficient Java implementations of
their corresponding algorithms. The input to this
system is a simple and declarative representation
of a parsing schema, which is practically equal to
the formal notation that we used previously. For
example, this is the DBinary
CYK deductive step shown
in figure 1 in a format readable by our compiler:
</bodyText>
<equation confidence="0.659279">
@step CYKBinary
[ Node1 , i , k , p , q , adj1 ]
[ Node2 , k , j , p’ , q’ , adj2 ]
-------------------------------- Node3 -&gt; Node1 Node2
[ Node3 , i , j , Union(p;p’) , Union(q;q’) , false ]
</equation>
<bodyText confidence="0.998324666666667">
The parsing schemata compilation technique
used by our system is based on the following fun-
damental ideas (G´omez-Rodriguez et al., 2006a):
</bodyText>
<listItem confidence="0.77439808">
• Each deductive step is compiled to a Java class
containing code to match and search for an-
tecedent items and generate the corresponding
conclusions from the consequent.
• The step classes are coordinated by a deduc-
tive parsing engine, as the one described in
(Shieber et al., 1995). This algorithm ensures
a sound and complete deduction process, guar-
anteeing that all items that can be generated
from the initial items will be obtained.
• To attain efficiency, an automatic analysis of
the schema is performed in order to create in-
dexes allowing fast access to items. As each
different parsing schema needs to perform dif-
ferent searches for antecedent items, the index
structures we generate are schema-specific. In
this way, we guarantee constant-time access to
items so that the computational complexity of
our generated implementations is never above
the theoretical complexity of the parsers.
• Since parsing schemata have an open notation,
for any mathematical object can potentially
appear inside items, the system includes an ex-
tensibility mechanism which can be used to
define new kinds of objects to use in schemata.
</listItem>
<page confidence="0.919003">
104
</page>
<equation confidence="0.988397933333333">
DCYK = [a, i, i + 1] a = label(N&apos;&apos;) DCYK = 2 = label(N&apos;&apos;)
[N&apos;&apos;, i, i + 1  |−, −  |false] [N-Y, i, i  |−, −  |false]
I ad j1],
unary — [M&apos;&apos;, i, j  |p, q  |adj] y y P&apos;&apos; , ik, k P, q � ,
ad&apos;2
D [MI,
— [N&apos;&apos;, i, j  |p, q]  |false] N — M E P(7) DCYK Y —_ [ , , j  |p, q  |] N&apos;&amp;quot; →M&apos;&apos;P&apos;&apos; ∈ P(γ)
[N&apos;&apos;, i, j  |p ∪ p0, q ∪ qd 7 I false]
Foot = [N&apos;&apos;, i, j  |p, q  |false] [Ra, i0, j0  |i, j  |adj],
DCYK [Fa i i false β ∈ adj(N&apos;&apos;) DAdj [N&apos;&apos;, i, j  |p, q  |false] β ∈ adj(N&apos;&apos;)
j I j I ] cYK = [N&apos;&apos;, i0, j0  |p, q  |true]
DCYSu —
b. _ [R«, i, j  |−, −  |adj]
K α ∈ subs(N&apos;&apos;)
[N&apos;&apos;, i, j  |−, −  |false]
</equation>
<figureCaption confidence="0.999563">
Figure 1: A CYK-based parser for TAG.
</figureCaption>
<bodyText confidence="0.98588137037037">
2 Generating parsers for the XTAG
grammar
By using parsing schemata as the ones in (Alonso
et al., 1999; Nederhof, 1999) as input to our sys-
tem, we can easily obtain efficient implementa-
tions of several TAG parsing algorithms. In this
section, we describe how we have dealt with the
particular characteristics of the XTAG grammar
in order to make it compatible with our generic
compilation technique; and we also provide em-
pirical results which allow us to compare the per-
formance of several different TAG parsing algo-
rithms in the practical case of the XTAG gram-
mar. It shall be noted that similar comparisons
have been made with smaller grammars, such as
simplified subsets of the XTAG grammar, but not
with the whole XTAG grammar with all its trees
and feature structures. Therefore, our compari-
son provides valuable information about the be-
havior of various parsers on a complete, large-
scale natural language grammar. This behavior
is very different from the one that can be ob-
served on small grammars, since grammar size be-
comes a dominant factor in computational com-
plexity when large grammars like the XTAG are
used to parse relatively small natural language sen-
tences (G´omez-Rodriguez et al., 2006b).
</bodyText>
<subsectionHeader confidence="0.931364">
2.1 Grammar conversion
</subsectionHeader>
<bodyText confidence="0.999319">
The first step we undertook in order to generate
parsers for the XTAG grammar was a full conver-
sion of the grammar to an XML-based format, a
variant of the TAG markup language (TAGML).
In this way we had the grammar in a well-defined
format, easy to parse and modify. During this con-
version, the trees’ anchor nodes were duplicated in
order to make our generic TAG parsers allow ad-
junctions on anchor nodes, which is allowed in the
XTAG grammar.
</bodyText>
<subsectionHeader confidence="0.998793">
2.2 Feature structure unification
</subsectionHeader>
<bodyText confidence="0.999972230769231">
Two strategies may be used in order to take uni-
fication into account in parsing: feature structures
can be unified after parsing or during parsing. We
have compared the two approaches for the XTAG
grammar (see table 1), and the general conclusion
is that unification during parsing performs better
for most of the sentences, although its runtimes
have a larger variance and it performs much worse
for some particular cases.
In order to implement unification during parsing
in our parsing schemata based system, we must ex-
tend our schemata in order to perform unification.
This can be done in the following way:
</bodyText>
<listItem confidence="0.991515">
• Items are extended so that they will hold a fea-
ture structure in addition to the rest of the infor-
mation they include.
• We need to define two operations on feature
structures: the unification operation and the
“keep variables” operation. The “keep vari-
ables” operation is a transformation on feature
structures that takes a feature structure as an
argument, which may contain features, values,
symbolic variables and associations between
them, and returns a feature structure contain-
ing only the variable-value associations related
to a given elementary tree, ignoring the vari-
ables and values not associated through these
relations, and completely ignoring features.
• During the process of parsing, feature structures
that refer to the same node, or to nodes that are
taking part in a substitution or adjunction and
</listItem>
<page confidence="0.993523">
105
</page>
<table confidence="0.984987333333333">
Strategy Mean T. Mean 10% T. Mean 20% 1st Quart. Median 3rd Quart. Std. Dev. Wilcoxon
During 108,270 12,164 7,812 1,585 4,424 9,671 388,010 0.4545
After 412,793 10,710 10,019 2,123 9,043 19,073 14,235
</table>
<tableCaption confidence="0.998158">
Table 1: Runtimes in ms of an Earley-based parser using two different unification strategies: unification
</tableCaption>
<bodyText confidence="0.895872071428572">
during and after parsing. The following data are shown: mean, trimmed means (10 and 20%), quartiles,
standard deviation, and p-value for the Wilcoxon paired signed rank test (the p-value of 0.4545 indicates
that no statistically significant difference was found between the medians).
are going to collapse to a single node in the final
parse tree, must be unified. For this to be done,
the test that these nodes must unify is added as
a side condition to the steps that must handle
them, and the unification results are included
in the item generated by the consequent. Of
course, considerations about the different role
of the top and bottom feature structures in ad-
junction and substitution must be taken into ac-
count when determining which feature struc-
tures must be unified.
</bodyText>
<listItem confidence="0.952513275">
• Feature structures in items must only hold
variable-value associations for the symbolic
variables appearing in the tree to which the
structures refer, for these relationships hold the
information that we need in order to propa-
gate values according to the rules specified in
the unification equations. Variable-value asso-
ciations referring to different elementary trees
are irrelevant when parsing a given tree, and
feature-value and feature-variable associations
are local to a node and can’t be extrapolated to
other nodes, so we won’t propagate any of this
information in items. However, it must be used
locally for unification. Therefore, steps perform
unification by using the information in their an-
tecedent items and recovering complete feature
structures associated to nodes directly from the
grammar, and then use the “keep-variables” op-
eration to remove the information that we don’t
need in the consequent item.
• In some algorithms, such as CYK, a single de-
ductive step deals with several different elemen-
tary tree nodes that don’t collapse into one in the
final parse tree. In this case, several “keep vari-
ables” operations must be performed on each
step execution, one for each of these nodes. If
we just unified the information on all the nodes
and called “keep variables” at the end, we could
propagate information incorrectly.
• In Earley-type algorithms, we must take a de-
cision about how predictor steps handle fea-
ture structures. Two options are possible: one
is propagating the feature structure in the an-
tecedent item to the consequent, and the other is
discarding the feature structure and generating
a consequent whose associated feature structure
is empty. The first option has the advantage that
violations of unification constraints are detected
earlier, thus avoiding the generation of some
items. However, in scenarios where a predic-
</listItem>
<bodyText confidence="0.96582825">
tor is applied to several items differing only in
their associated feature structures, this approach
generates several different items while the dis-
carding approach collapses them into a single
consequent item. Moreover, the propagating
approach favors the appearance of items with
more complex feature structures, thus making
unification operations slower. In practice, for
XTAG we have found that these drawbacks of
propagating the structures overcome the advan-
tages, especially in complex sentences, where
the discarding approach performs much better.
</bodyText>
<subsectionHeader confidence="0.999373">
2.3 Tree filtering
</subsectionHeader>
<bodyText confidence="0.999612733333333">
The full XTAG English grammar contains thou-
sands of elementary trees, so performance is not
good if we use the whole grammar to parse each
sentence. Tree selection filters (Schabes and Joshi,
1991) are used to select a subset of the grammar,
discarding the trees which are known not to be
useful given the words in the input sentence.
To emulate this functionality in our parsing
schema-based system, we have used its exten-
sibility mechanism to define a function Selects-
tree(a,T) that returns true if the terminal symbol a
selects the tree T. The implementation of this func-
tion is a Java method that looks for this informa-
tion in XTAG’s syntactic database. Then the func-
tion is inserted in a filtering step on our schemata:
</bodyText>
<page confidence="0.980891">
106
</page>
<equation confidence="0.255146">
alpha ∈ Trees/SELECTS-TREE(A;α)
</equation>
<bodyText confidence="0.999960333333333">
The presence of an item of the form
[Selected, α] indicates that the tree α has
been selected by the filter and can be used for
parsing. In order for the filter to take effect, we
add [Selected, α] as an antecedent to every step
in our schemata introducing a new tree α into the
parse (such as initters, substitution and adjoining
steps). In this way we guarantee that no trees that
don’t pass the filter will be used for parsing.
</bodyText>
<sectionHeader confidence="0.974903" genericHeader="method">
3 Comparing several parsers for the
XTAG grammar
</sectionHeader>
<bodyText confidence="0.999988564516129">
In this section, we make a comparison of several
different TAG parsing algorithms — the CYK-
based algorithm described at (Vijay-Shanker
and Joshi, 1985), Earley-based algorithms with
(Alonso et al., 1999) and without (Schabes, 1994)
the valid prefix property (VPP), and Nederhof’s
algorithm (Nederhof, 1999) — on the XTAG En-
glish grammar (release 2.24.2001), by using our
system and the ideas we have explained. The
schemata for these algorithms without unification
support can be found at (Alonso et al., 1999).
These schemata were extended as described in the
previous sections, and used as input to our sys-
tem which generated their corresponding parsers.
These parsers were then run on the test sentences
shown in table 2, obtaining the performance mea-
sures (in terms of runtime and amount of items
generated) that can be seen in table 3. Note that
the sentences are ordered by minimal runtime.
As we can see, the execution times are not as
good as the ones we would obtain if we used
Sarkar’s XTAG distribution parser written in C
(Sarkar, 2000). This is not surprising, since our
parsers have been generated by a generic tool
without knowledge of the grammar, while the
XTAG parser has been designed specifically for
optimal performance in this grammar and uses ad-
ditional information (such as tree usage frequency
data from several corpora, see (XTAG, 2001)).
However, our comparison allows us to draw
conclusions about which parsing algorithms are
better suited for the XTAG grammar. In terms
of memory usage, CYK is the clear winner, since
it clearly generates less items than the other al-
gorithms, and a CYK item doesn’t take up more
memory than an Earley item.
On the other hand, if we compare execution
times, there is not a single best algorithm, since the
performance results depend on the size and com-
plexity of the sentences. The Earley-based algo-
rithm with the VPP is the fastest for the first, “eas-
ier” sentences, but CYK gives the best results for
the more complex sentences. In the middle of the
two, there are some sentences where the best per-
formance is achieved by the variant of Earley that
doesn’t verify the valid prefix property. Therefore,
in practical cases, we should take into account the
most likely kind of sentences that will be passed
to the parser in order to select the best algorithm.
Nederhof’s algorithm is always the one with the
slowest execution time, in spite of being an im-
provement of the VPP Earley parser that reduces
worst-case time complexity. This is probably be-
cause, when extending the Nederhof schema in
order to support feature structure unification, we
get a schema that needs more unification opera-
tions than Earley’s and has to use items that store
several feature structures. Nederhof’s algorithm
would probably perform better in relation to the
others if we had used the strategy of parsing with-
out feature structures and then performing unifica-
tion on the output parse forest.
</bodyText>
<sectionHeader confidence="0.999685" genericHeader="conclusions">
4 Conclusions
</sectionHeader>
<bodyText confidence="0.9999855">
A generic system that generates parsers from al-
gebraic specifications (parsing schemata) has been
applied to the particular case of the XTAG gram-
mar. In order to be able to generate XTAG parsers,
some transformations were made to the grammar,
and TAG parsing schemata were extended with
feature structure unification support and a simple
tree filtering mechanism.
The generated implementations allow us to
compare the performance of different TAG parsers
when working with a large-scale grammar, the
XTAG English grammar. In this paper, we have
shown the results for four algorithms: a CYK-
based algorithm, Earley-based algorithms with
and without the VPP, and Nederhof’s algorithm.
The result shows that the CYK-based parser is the
least memory-consuming algorithm. By measur-
ing execution time, we find that CYK is the fastest
algorithm for the most complex sentences, but the
Earley-based algorithm with the VPP is the fastest
for simpler cases. Therefore, when choosing a
parser for a practical application, we should take
</bodyText>
<equation confidence="0.501681">
[a, i, j]
[Selected, α]
</equation>
<page confidence="0.991575">
107
</page>
<listItem confidence="0.972593625">
1. He was a cow 9. He wanted to go to the city
2. He loved himself 10. That woman in the city contributed to this article
3. Go to your room 11. That people are not really amateurs at intelectual duelling
4. He is a real man 12. The index is intended to measure future economic performance
5. He was a real man 13. They expect him to cut costs throughout the organization
6. Who was at the door 14. He will continue to place a huge burden on the city workers
7. He loved all cows 15. He could have been simply being a jerk
8. He called up her 16. A few fast food outlets are giving it a try
</listItem>
<tableCaption confidence="0.996048">
Table 2: Test sentences.
</tableCaption>
<table confidence="0.765722">
Sentence Runtimes in milliseconds Items generated
Parser Parser
CYK Ear. no VPP Ear. VPP Neder. CYK Ear. no VPP Ear. VPP Neder.
1 2985 750 750 2719 1341 1463 1162 1249
2 3109 1562 1219 6421 1834 2917 2183 2183
</table>
<figure confidence="0.976636571428571">
3 4078 1547 1406 6828 2149 2893 2298 2304
4 4266 1563 1407 4703 1864 1979 1534 2085
5 4234 1921 1421 4766 1855 1979 1534 2085
6 4485 1813 1562 7782 2581 3587 2734 2742
7 5469 2359 2344 11469 2658 3937 3311 3409
8 7828 4906 3563 15532 4128 8058 4711 4716
9 10047 4422 4016 18969 4931 6968 5259 5279
10 13641 6515 7172 31828 6087 8828 7734 8344
11 16500 7781 15235 56265 7246 12068 13221 13376
12 16875 17109 9985 39132 7123 10428 9810 10019
13 25859 12000 20828 63641 10408 12852 15417 15094
14 54578 35829 57422 178875 20760 31278 40248 47570
15 62157 113532 109062 133515 22115 37377 38824 59603
16 269187 3122860 3315359 68778 152430 173128
</figure>
<tableCaption confidence="0.83033">
Table 3: Runtimes and amount of items generated by different XTAG parsers on several sentences. The
</tableCaption>
<bodyText confidence="0.908928">
machine used for all the tests was an Intel Pentium 4 / 3.40 GHz, with 1 GB RAM and Sun Java Hotspot
virtual machine (version 1.4.2 01-b06) running on Windows XP. Best results for each sentence are shown
in boldface.
into account the kinds of sentences most likely to
be used as input in order to select the most suitable
algorithm.
</bodyText>
<sectionHeader confidence="0.99926" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.997563375">
M. A. Alonso, D. Cabrero, E. de la Clergerie, and M.
Vilares. 1999. Tabular algorithms for TAG parsing.
Proc. of EACL’99, pp. 150–157, Bergen, Norway.
S. Billot and B. Lang. 1989. The structure of shared
forest in ambiguous parsing. Proc. of ACL’89, pp.
143–151, Vancouver, Canada.
C. G´omez-Rodriguez, J. Vilares and M. A.
Alonso. 2006. Automatic Generation of
Natural Language Parsers from Declarative
Specifications. Proc. of STAIRS 2006, Riva
del Garda, Italy. Long version available at
http://www.grupocole.org/GomVilAlo2006a long.pdf
C. G´omez-Rodriguez, M. A. Alonso and M. Vilares.
2006. On Theoretical and Practical Complexity of
TAG Parsers. Proc. of Formal Grammars 2006,
Malaga, Spain.
M.-J. Nederhof. 1999. The computational complexity
of the correct-prefix property for TAGs. Computa-
tional Linguistics, 25(3):345–360.
A. Sarkar. 2000. Practical experiments in parsing us-
ing tree adjoining grammars. Proc. of TAG+5, Paris.
Y. Schabes and A. K. Joshi. 1991. Parsing with lexi-
calized tree adjoining grammar. In Masaru Tomita,
editor, Current Issues in Parsing Technologies, pp.
25–47. Kluwer Academic Publishers, Norwell.
Y. Schabes. 1994. Left to right parsing of lexical-
ized tree-adjoining grammars. ComputationalIntel-
ligence, 10(4):506–515.
S. M. Shieber, Y. Schabes, and F. C. N. Pereira. 1995.
Principles and implementation of deductive parsing.
Journal ofLogic Programming, 24(1–2):3–36.
K. Sikkel. 1997. Parsing Schemata — A Frame-
work for Speci�cation and Analysis of Parsing Al-
gorithms. Springer-Verlag, Berlin.
K. Vijay-Shanker and A. K. Joshi. 1985. Some com-
putational properties of tree adjoining grammars.
Proc. ofACL’85, pp. 82–93, Chicago, USA.
XTAG Research Group. 2001. A lexicalized tree
adjoining grammar for english. Technical Report
IRCS-01-03, IRCS, University of Pennsylvania.
</reference>
<page confidence="0.998245">
108
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.103346">
<title confidence="0.998176">XTAG Parsers from Algebraic</title>
<author confidence="0.876305">G´omez-Rodriguez A Alonso Manuel Vilares</author>
<affiliation confidence="0.493112333333333">Departamento de Computaci´on E. S. de Ingenieria Inform´atica da Universidad de Vigo de s/n Campus As Lagoas, s/n</affiliation>
<address confidence="0.450395">A Spain 32004 Ourense, Spain</address>
<email confidence="0.879621">vilares@uvigo.es</email>
<abstract confidence="0.994720785714286">In this paper, a generic system that generates parsers from parsing schemata is applied to the particular case of the XTAG English grammar. In order to be able to generate XTAG parsers, some transformations are made to the grammar, and TAG parsing schemata are extended with feature structure unification support and a simple tree filtering mechanism. The generated implementations allow us to study the performance of different TAG parsers when working with a large-scale, widecoverage grammar.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>M A Alonso</author>
<author>D Cabrero</author>
<author>E de la Clergerie</author>
<author>M Vilares</author>
</authors>
<title>Tabular algorithms for TAG parsing.</title>
<date>1999</date>
<booktitle>Proc. of EACL’99,</booktitle>
<pages>150--157</pages>
<location>Bergen,</location>
<contexts>
<context position="3250" citStr="Alonso et al., 1999" startWordPosition="529" endWordPosition="532">y the grammar. The parse forest can then be retrieved from the intermediate items used to infer the final items, as in (Billot and Lang, 1989). As an example, we introduce a CYK-based algorithm (Vijay-Shanker and Joshi, 1985) for TAG. Given a tree adjoining grammar G = (VT, VN, S, I, A)1 and a sentence of length n which we denote by a1 a2 ... an2, we denote by P(G) the set of productions {N&apos;Y → N&apos;Y1 N&apos;Y2 ... N&apos;Y� } such that N&apos;Y is an inner node of a tree ry E (I U A), and N&apos;Y1 N&apos;Y2 ... N&apos;Y� is the ordered sequence of direct children of N&apos;Y. The parsing schema for the TAG CYK-based algorithm (Alonso et al., 1999) is a function that maps such a grammar G to a deduction system whose domain is the set of items {[N&apos;Y, i, j, p, q, adj]} verifying that N&apos;Y is a tree node in an elementary 1Where VT denotes the set of terminal symbols, Vv the set of nonterminal symbols, S the axiom, I the set of initial trees and A the set of auxiliary trees. 2From now on, we will follow the usual conventions by which nonterminal symbols are represented by uppercase letters (A, B ...), and terminals by lowercase letters (a, b ...). Greek letters (α, β...) will be used to represent trees, Nry a node in the tree -y, and Rry the</context>
<context position="9595" citStr="Alonso et al., 1999" startWordPosition="1700" endWordPosition="1703">[N-Y, i, i |−, − |false] I ad j1], unary — [M&apos;&apos;, i, j |p, q |adj] y y P&apos;&apos; , ik, k P, q � , ad&apos;2 D [MI, — [N&apos;&apos;, i, j |p, q] |false] N — M E P(7) DCYK Y —_ [ , , j |p, q |] N&apos;&amp;quot; →M&apos;&apos;P&apos;&apos; ∈ P(γ) [N&apos;&apos;, i, j |p ∪ p0, q ∪ qd 7 I false] Foot = [N&apos;&apos;, i, j |p, q |false] [Ra, i0, j0 |i, j |adj], DCYK [Fa i i false β ∈ adj(N&apos;&apos;) DAdj [N&apos;&apos;, i, j |p, q |false] β ∈ adj(N&apos;&apos;) j I j I ] cYK = [N&apos;&apos;, i0, j0 |p, q |true] DCYSu — b. _ [R«, i, j |−, − |adj] K α ∈ subs(N&apos;&apos;) [N&apos;&apos;, i, j |−, − |false] Figure 1: A CYK-based parser for TAG. 2 Generating parsers for the XTAG grammar By using parsing schemata as the ones in (Alonso et al., 1999; Nederhof, 1999) as input to our system, we can easily obtain efficient implementations of several TAG parsing algorithms. In this section, we describe how we have dealt with the particular characteristics of the XTAG grammar in order to make it compatible with our generic compilation technique; and we also provide empirical results which allow us to compare the performance of several different TAG parsing algorithms in the practical case of the XTAG grammar. It shall be noted that similar comparisons have been made with smaller grammars, such as simplified subsets of the XTAG grammar, but no</context>
<context position="17608" citStr="Alonso et al., 1999" startWordPosition="3011" endWordPosition="3014">t the tree α has been selected by the filter and can be used for parsing. In order for the filter to take effect, we add [Selected, α] as an antecedent to every step in our schemata introducing a new tree α into the parse (such as initters, substitution and adjoining steps). In this way we guarantee that no trees that don’t pass the filter will be used for parsing. 3 Comparing several parsers for the XTAG grammar In this section, we make a comparison of several different TAG parsing algorithms — the CYKbased algorithm described at (Vijay-Shanker and Joshi, 1985), Earley-based algorithms with (Alonso et al., 1999) and without (Schabes, 1994) the valid prefix property (VPP), and Nederhof’s algorithm (Nederhof, 1999) — on the XTAG English grammar (release 2.24.2001), by using our system and the ideas we have explained. The schemata for these algorithms without unification support can be found at (Alonso et al., 1999). These schemata were extended as described in the previous sections, and used as input to our system which generated their corresponding parsers. These parsers were then run on the test sentences shown in table 2, obtaining the performance measures (in terms of runtime and amount of items ge</context>
</contexts>
<marker>Alonso, Cabrero, Clergerie, Vilares, 1999</marker>
<rawString>M. A. Alonso, D. Cabrero, E. de la Clergerie, and M. Vilares. 1999. Tabular algorithms for TAG parsing. Proc. of EACL’99, pp. 150–157, Bergen, Norway.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S Billot</author>
<author>B Lang</author>
</authors>
<title>The structure of shared forest in ambiguous parsing.</title>
<date>1989</date>
<booktitle>Proc. of ACL’89,</booktitle>
<pages>143--151</pages>
<location>Vancouver, Canada.</location>
<contexts>
<context position="2772" citStr="Billot and Lang, 1989" startWordPosition="431" endWordPosition="434">of incomplete parse trees which the algorithm can generate. An input sentence to be analyzed produces an initial set of items. Additionally, a parsing schema must define a criterion to determine which items are final, i.e. which items correspond to complete parses of the input sentence. If it is possible to obtain a final item from the set of initial items by using the schema’s inference rules (called deductive steps), then the input sentence belongs to the language defined by the grammar. The parse forest can then be retrieved from the intermediate items used to infer the final items, as in (Billot and Lang, 1989). As an example, we introduce a CYK-based algorithm (Vijay-Shanker and Joshi, 1985) for TAG. Given a tree adjoining grammar G = (VT, VN, S, I, A)1 and a sentence of length n which we denote by a1 a2 ... an2, we denote by P(G) the set of productions {N&apos;Y → N&apos;Y1 N&apos;Y2 ... N&apos;Y� } such that N&apos;Y is an inner node of a tree ry E (I U A), and N&apos;Y1 N&apos;Y2 ... N&apos;Y� is the ordered sequence of direct children of N&apos;Y. The parsing schema for the TAG CYK-based algorithm (Alonso et al., 1999) is a function that maps such a grammar G to a deduction system whose domain is the set of items {[N&apos;Y, i, j, p, q, adj]} </context>
</contexts>
<marker>Billot, Lang, 1989</marker>
<rawString>S. Billot and B. Lang. 1989. The structure of shared forest in ambiguous parsing. Proc. of ACL’89, pp. 143–151, Vancouver, Canada.</rawString>
</citation>
<citation valid="true">
<authors>
<author>C G´omez-Rodriguez</author>
<author>J Vilares</author>
<author>M A Alonso</author>
</authors>
<title>Automatic Generation of Natural Language Parsers from Declarative Specifications.</title>
<date>2006</date>
<booktitle>Proc. of STAIRS 2006,</booktitle>
<location>Riva</location>
<marker>G´omez-Rodriguez, Vilares, Alonso, 2006</marker>
<rawString>C. G´omez-Rodriguez, J. Vilares and M. A. Alonso. 2006. Automatic Generation of Natural Language Parsers from Declarative Specifications. Proc. of STAIRS 2006, Riva del Garda, Italy. Long version available at http://www.grupocole.org/GomVilAlo2006a long.pdf</rawString>
</citation>
<citation valid="true">
<authors>
<author>C G´omez-Rodriguez</author>
<author>M A Alonso</author>
<author>M Vilares</author>
</authors>
<date>2006</date>
<booktitle>On Theoretical and Practical Complexity of TAG Parsers. Proc. of Formal Grammars</booktitle>
<location>Malaga,</location>
<marker>G´omez-Rodriguez, Alonso, Vilares, 2006</marker>
<rawString>C. G´omez-Rodriguez, M. A. Alonso and M. Vilares. 2006. On Theoretical and Practical Complexity of TAG Parsers. Proc. of Formal Grammars 2006, Malaga, Spain.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M-J Nederhof</author>
</authors>
<title>The computational complexity of the correct-prefix property for TAGs.</title>
<date>1999</date>
<journal>Computational Linguistics,</journal>
<volume>25</volume>
<issue>3</issue>
<contexts>
<context position="9612" citStr="Nederhof, 1999" startWordPosition="1704" endWordPosition="1705">se] I ad j1], unary — [M&apos;&apos;, i, j |p, q |adj] y y P&apos;&apos; , ik, k P, q � , ad&apos;2 D [MI, — [N&apos;&apos;, i, j |p, q] |false] N — M E P(7) DCYK Y —_ [ , , j |p, q |] N&apos;&amp;quot; →M&apos;&apos;P&apos;&apos; ∈ P(γ) [N&apos;&apos;, i, j |p ∪ p0, q ∪ qd 7 I false] Foot = [N&apos;&apos;, i, j |p, q |false] [Ra, i0, j0 |i, j |adj], DCYK [Fa i i false β ∈ adj(N&apos;&apos;) DAdj [N&apos;&apos;, i, j |p, q |false] β ∈ adj(N&apos;&apos;) j I j I ] cYK = [N&apos;&apos;, i0, j0 |p, q |true] DCYSu — b. _ [R«, i, j |−, − |adj] K α ∈ subs(N&apos;&apos;) [N&apos;&apos;, i, j |−, − |false] Figure 1: A CYK-based parser for TAG. 2 Generating parsers for the XTAG grammar By using parsing schemata as the ones in (Alonso et al., 1999; Nederhof, 1999) as input to our system, we can easily obtain efficient implementations of several TAG parsing algorithms. In this section, we describe how we have dealt with the particular characteristics of the XTAG grammar in order to make it compatible with our generic compilation technique; and we also provide empirical results which allow us to compare the performance of several different TAG parsing algorithms in the practical case of the XTAG grammar. It shall be noted that similar comparisons have been made with smaller grammars, such as simplified subsets of the XTAG grammar, but not with the whole </context>
<context position="17711" citStr="Nederhof, 1999" startWordPosition="3027" endWordPosition="3028">fect, we add [Selected, α] as an antecedent to every step in our schemata introducing a new tree α into the parse (such as initters, substitution and adjoining steps). In this way we guarantee that no trees that don’t pass the filter will be used for parsing. 3 Comparing several parsers for the XTAG grammar In this section, we make a comparison of several different TAG parsing algorithms — the CYKbased algorithm described at (Vijay-Shanker and Joshi, 1985), Earley-based algorithms with (Alonso et al., 1999) and without (Schabes, 1994) the valid prefix property (VPP), and Nederhof’s algorithm (Nederhof, 1999) — on the XTAG English grammar (release 2.24.2001), by using our system and the ideas we have explained. The schemata for these algorithms without unification support can be found at (Alonso et al., 1999). These schemata were extended as described in the previous sections, and used as input to our system which generated their corresponding parsers. These parsers were then run on the test sentences shown in table 2, obtaining the performance measures (in terms of runtime and amount of items generated) that can be seen in table 3. Note that the sentences are ordered by minimal runtime. As we can</context>
</contexts>
<marker>Nederhof, 1999</marker>
<rawString>M.-J. Nederhof. 1999. The computational complexity of the correct-prefix property for TAGs. Computational Linguistics, 25(3):345–360.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Sarkar</author>
</authors>
<title>Practical experiments in parsing using tree adjoining grammars.</title>
<date>2000</date>
<booktitle>Proc. of TAG+5,</booktitle>
<location>Paris.</location>
<contexts>
<context position="18453" citStr="Sarkar, 2000" startWordPosition="3157" endWordPosition="3158">lgorithms without unification support can be found at (Alonso et al., 1999). These schemata were extended as described in the previous sections, and used as input to our system which generated their corresponding parsers. These parsers were then run on the test sentences shown in table 2, obtaining the performance measures (in terms of runtime and amount of items generated) that can be seen in table 3. Note that the sentences are ordered by minimal runtime. As we can see, the execution times are not as good as the ones we would obtain if we used Sarkar’s XTAG distribution parser written in C (Sarkar, 2000). This is not surprising, since our parsers have been generated by a generic tool without knowledge of the grammar, while the XTAG parser has been designed specifically for optimal performance in this grammar and uses additional information (such as tree usage frequency data from several corpora, see (XTAG, 2001)). However, our comparison allows us to draw conclusions about which parsing algorithms are better suited for the XTAG grammar. In terms of memory usage, CYK is the clear winner, since it clearly generates less items than the other algorithms, and a CYK item doesn’t take up more memory</context>
</contexts>
<marker>Sarkar, 2000</marker>
<rawString>A. Sarkar. 2000. Practical experiments in parsing using tree adjoining grammars. Proc. of TAG+5, Paris.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Y Schabes</author>
<author>A K Joshi</author>
</authors>
<title>Parsing with lexicalized tree adjoining grammar.</title>
<date>1991</date>
<booktitle>In Masaru Tomita, editor, Current Issues in Parsing Technologies,</booktitle>
<pages>25--47</pages>
<publisher>Kluwer Academic Publishers,</publisher>
<location>Norwell.</location>
<contexts>
<context position="16361" citStr="Schabes and Joshi, 1991" startWordPosition="2794" endWordPosition="2797">scarding approach collapses them into a single consequent item. Moreover, the propagating approach favors the appearance of items with more complex feature structures, thus making unification operations slower. In practice, for XTAG we have found that these drawbacks of propagating the structures overcome the advantages, especially in complex sentences, where the discarding approach performs much better. 2.3 Tree filtering The full XTAG English grammar contains thousands of elementary trees, so performance is not good if we use the whole grammar to parse each sentence. Tree selection filters (Schabes and Joshi, 1991) are used to select a subset of the grammar, discarding the trees which are known not to be useful given the words in the input sentence. To emulate this functionality in our parsing schema-based system, we have used its extensibility mechanism to define a function Selectstree(a,T) that returns true if the terminal symbol a selects the tree T. The implementation of this function is a Java method that looks for this information in XTAG’s syntactic database. Then the function is inserted in a filtering step on our schemata: 106 alpha ∈ Trees/SELECTS-TREE(A;α) The presence of an item of the form </context>
</contexts>
<marker>Schabes, Joshi, 1991</marker>
<rawString>Y. Schabes and A. K. Joshi. 1991. Parsing with lexicalized tree adjoining grammar. In Masaru Tomita, editor, Current Issues in Parsing Technologies, pp. 25–47. Kluwer Academic Publishers, Norwell.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Y Schabes</author>
</authors>
<title>Left to right parsing of lexicalized tree-adjoining grammars.</title>
<date>1994</date>
<journal>ComputationalIntelligence,</journal>
<volume>10</volume>
<issue>4</issue>
<contexts>
<context position="17636" citStr="Schabes, 1994" startWordPosition="3017" endWordPosition="3018">the filter and can be used for parsing. In order for the filter to take effect, we add [Selected, α] as an antecedent to every step in our schemata introducing a new tree α into the parse (such as initters, substitution and adjoining steps). In this way we guarantee that no trees that don’t pass the filter will be used for parsing. 3 Comparing several parsers for the XTAG grammar In this section, we make a comparison of several different TAG parsing algorithms — the CYKbased algorithm described at (Vijay-Shanker and Joshi, 1985), Earley-based algorithms with (Alonso et al., 1999) and without (Schabes, 1994) the valid prefix property (VPP), and Nederhof’s algorithm (Nederhof, 1999) — on the XTAG English grammar (release 2.24.2001), by using our system and the ideas we have explained. The schemata for these algorithms without unification support can be found at (Alonso et al., 1999). These schemata were extended as described in the previous sections, and used as input to our system which generated their corresponding parsers. These parsers were then run on the test sentences shown in table 2, obtaining the performance measures (in terms of runtime and amount of items generated) that can be seen in</context>
</contexts>
<marker>Schabes, 1994</marker>
<rawString>Y. Schabes. 1994. Left to right parsing of lexicalized tree-adjoining grammars. ComputationalIntelligence, 10(4):506–515.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S M Shieber</author>
<author>Y Schabes</author>
<author>F C N Pereira</author>
</authors>
<title>Principles and implementation of deductive parsing.</title>
<date>1995</date>
<booktitle>Journal ofLogic Programming,</booktitle>
<pages>24--1</pages>
<contexts>
<context position="8040" citStr="Shieber et al., 1995" startWordPosition="1383" endWordPosition="1386">iler: @step CYKBinary [ Node1 , i , k , p , q , adj1 ] [ Node2 , k , j , p’ , q’ , adj2 ] -------------------------------- Node3 -&gt; Node1 Node2 [ Node3 , i , j , Union(p;p’) , Union(q;q’) , false ] The parsing schemata compilation technique used by our system is based on the following fundamental ideas (G´omez-Rodriguez et al., 2006a): • Each deductive step is compiled to a Java class containing code to match and search for antecedent items and generate the corresponding conclusions from the consequent. • The step classes are coordinated by a deductive parsing engine, as the one described in (Shieber et al., 1995). This algorithm ensures a sound and complete deduction process, guaranteeing that all items that can be generated from the initial items will be obtained. • To attain efficiency, an automatic analysis of the schema is performed in order to create indexes allowing fast access to items. As each different parsing schema needs to perform different searches for antecedent items, the index structures we generate are schema-specific. In this way, we guarantee constant-time access to items so that the computational complexity of our generated implementations is never above the theoretical complexity </context>
</contexts>
<marker>Shieber, Schabes, Pereira, 1995</marker>
<rawString>S. M. Shieber, Y. Schabes, and F. C. N. Pereira. 1995. Principles and implementation of deductive parsing. Journal ofLogic Programming, 24(1–2):3–36.</rawString>
</citation>
<citation valid="true">
<authors>
<author>K Sikkel</author>
</authors>
<title>Parsing Schemata — A Framework for Speci�cation and Analysis of Parsing Algorithms.</title>
<date>1997</date>
<publisher>Springer-Verlag,</publisher>
<location>Berlin.</location>
<contexts>
<context position="1467" citStr="Sikkel, 1997" startWordPosition="223" endWordPosition="224">r. 1 Introduction Since Tree Adjoining Grammars (TAG) were introduced, several different parsing algorithms for these grammars have been developed, each with its peculiar characteristics. Identifying the advantages and disadvantages of each of them is not trivial, and there are no comparative studies between them in the literature that work with reallife, wide coverage grammars. In this paper, we use a generic tool based on parsing schemata to generate implementations of several TAG parsers and compare them by parsing with the XTAG English Grammar (XTAG, 2001). The parsing schemata formalism (Sikkel, 1997) is a framework that allows us to describe parsers in a simple and declarative way. A parsing schema ∗ Partially supported by Ministerio de Educaci´on y Ciencia and FEDER (TIN2004-07246-C03-01, TIN2004-07246- C03-02), Xunta de Galicia (PGIDIT05PXIC30501PN, PGIDIT05PXIC10501PN, PGIDIT05SIN044E and PGIDIT05SIN059E), and Programa de becas FPU (Ministerio de Educaci´on y Ciencia). We are grateful to Eric Villemonte de la Clergerie and Franc¸ois Barthelemy for their help in converting the XTAG grammar to XML. is a representation of a parsing algorithm as a set of inference rules which are used to p</context>
</contexts>
<marker>Sikkel, 1997</marker>
<rawString>K. Sikkel. 1997. Parsing Schemata — A Framework for Speci�cation and Analysis of Parsing Algorithms. Springer-Verlag, Berlin.</rawString>
</citation>
<citation valid="true">
<authors>
<author>K Vijay-Shanker</author>
<author>A K Joshi</author>
</authors>
<title>Some computational properties of tree adjoining grammars.</title>
<date>1985</date>
<booktitle>Proc. ofACL’85,</booktitle>
<pages>82--93</pages>
<location>Chicago, USA.</location>
<contexts>
<context position="2855" citStr="Vijay-Shanker and Joshi, 1985" startWordPosition="443" endWordPosition="446">ce to be analyzed produces an initial set of items. Additionally, a parsing schema must define a criterion to determine which items are final, i.e. which items correspond to complete parses of the input sentence. If it is possible to obtain a final item from the set of initial items by using the schema’s inference rules (called deductive steps), then the input sentence belongs to the language defined by the grammar. The parse forest can then be retrieved from the intermediate items used to infer the final items, as in (Billot and Lang, 1989). As an example, we introduce a CYK-based algorithm (Vijay-Shanker and Joshi, 1985) for TAG. Given a tree adjoining grammar G = (VT, VN, S, I, A)1 and a sentence of length n which we denote by a1 a2 ... an2, we denote by P(G) the set of productions {N&apos;Y → N&apos;Y1 N&apos;Y2 ... N&apos;Y� } such that N&apos;Y is an inner node of a tree ry E (I U A), and N&apos;Y1 N&apos;Y2 ... N&apos;Y� is the ordered sequence of direct children of N&apos;Y. The parsing schema for the TAG CYK-based algorithm (Alonso et al., 1999) is a function that maps such a grammar G to a deduction system whose domain is the set of items {[N&apos;Y, i, j, p, q, adj]} verifying that N&apos;Y is a tree node in an elementary 1Where VT denotes the set of ter</context>
<context position="17556" citStr="Vijay-Shanker and Joshi, 1985" startWordPosition="3004" endWordPosition="3007">he presence of an item of the form [Selected, α] indicates that the tree α has been selected by the filter and can be used for parsing. In order for the filter to take effect, we add [Selected, α] as an antecedent to every step in our schemata introducing a new tree α into the parse (such as initters, substitution and adjoining steps). In this way we guarantee that no trees that don’t pass the filter will be used for parsing. 3 Comparing several parsers for the XTAG grammar In this section, we make a comparison of several different TAG parsing algorithms — the CYKbased algorithm described at (Vijay-Shanker and Joshi, 1985), Earley-based algorithms with (Alonso et al., 1999) and without (Schabes, 1994) the valid prefix property (VPP), and Nederhof’s algorithm (Nederhof, 1999) — on the XTAG English grammar (release 2.24.2001), by using our system and the ideas we have explained. The schemata for these algorithms without unification support can be found at (Alonso et al., 1999). These schemata were extended as described in the previous sections, and used as input to our system which generated their corresponding parsers. These parsers were then run on the test sentences shown in table 2, obtaining the performance </context>
</contexts>
<marker>Vijay-Shanker, Joshi, 1985</marker>
<rawString>K. Vijay-Shanker and A. K. Joshi. 1985. Some computational properties of tree adjoining grammars. Proc. ofACL’85, pp. 82–93, Chicago, USA.</rawString>
</citation>
<citation valid="true">
<authors>
<author>XTAG Research Group</author>
</authors>
<title>A lexicalized tree adjoining grammar for english.</title>
<date>2001</date>
<tech>Technical Report IRCS-01-03,</tech>
<institution>IRCS, University of Pennsylvania.</institution>
<marker>Group, 2001</marker>
<rawString>XTAG Research Group. 2001. A lexicalized tree adjoining grammar for english. Technical Report IRCS-01-03, IRCS, University of Pennsylvania.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>