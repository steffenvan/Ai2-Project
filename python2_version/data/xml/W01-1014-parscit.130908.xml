<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000009">
<title confidence="0.999212">
Automatic Augmentation of Translation Dictionary with
Database Terminologies in Multilingual Query Interpretation
</title>
<author confidence="0.997868">
Hodong Lee and Jong C. Park
</author>
<affiliation confidence="0.997769">
Computer Science Division and AITrc
Korea Advanced Institute of Science and Technology
</affiliation>
<address confidence="0.963399">
373-1 Gusung-dong, Yusong-gu, Daejon 305-701, South KOREA
</address>
<email confidence="0.999356">
{hdlee,park}@nlp.kaist.ac.kr
</email>
<sectionHeader confidence="0.995648" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999800875">
In interpreting multilingual queries
to databases whose domain informa-
tion is described in a particular lan-
guage, we must address the problem
of word sense disambiguation. Since
full-fledged semantic classification in-
formation is difficult to construct ei-
ther automatically or manually for this
purpose, we propose to disambiguate
the senses of the source lexical items
by automatically augmenting a simple
translation dictionary with database
terminologies and describe an imple-
mented multilingual query interpreta-
tion system in a combinatory catego-
rial grammar framework.1
</bodyText>
<sectionHeader confidence="0.999134" genericHeader="introduction">
1 Introduction
</sectionHeader>
<bodyText confidence="0.999807909090909">
In interpreting multilingual queries to databases
with domain information such as objects, table
names, and attribute names that are described in
a particular language, we must address the prob-
lem of word sense disambiguation. For exam-
ple, if we wish to interpret a query in English
to a database with domain information described
in Korean, lexical items in English must be dis-
ambiguated to the matching senses in Korean.
This problem is similar to that of lexical selec-
tion in machine translation domain (Lee et al.,
</bodyText>
<footnote confidence="0.896218">
1This work was supported by the Korea Science and En-
gineering Foundation (KOSEF) through AITrc.
</footnote>
<table confidence="0.998117454545455">
ip-ta person body color ...
Mary oy-twu kal-sayk ...
... ... ... ...
sin-ta person foot status ...
John sin-bal nalk-ta ...
... ... ... ...
sa-ta person object status ...
John ca-tong-cha nalk-ta ...
Mary sin-bal nalk-ta ...
Manny ko-yang-i nulk-ta ...
... ... ... ...
</table>
<tableCaption confidence="0.99904">
Table 1: Sample Database
</tableCaption>
<bodyText confidence="0.9949533">
1999; Palmer et al., 1999), except that the target
is different in the sense that one is a formal query
language and the other is another natural lan-
guage. This difference prompts us to make use of
database information, such as domain database
objects, table names, and attribute names, instead
of the general semantic classifications (Palmer et
al., 1999) for disambiguating the senses of lex-
ical items in the query. Example queries are
shown below:
</bodyText>
<listItem confidence="0.998638333333333">
(1) (a) Which shoes does Mary buy?
(b) Who wears a brown coat?
(c) Who wears old shoes and buys an old car?
</listItem>
<bodyText confidence="0.986819612244898">
Query 1a shows a query made up of unambigu-
ous words having a unique target interpretation.
But in 1b, wears may have several interpretations
in Korean such as ‘ip-ta’, ‘ssu-ta’, ‘sin-ta’, and
‘tti-ta’ (cf. Table 3). And old in query 1c also
contains several senses2. If we assume a simple
database made up of tables such as ‘ip-ta’ (to put
on the body), ‘sin-ta’ (to put on the foot), and
2We notate Korean alphabets in Yale form.
‘sa-ta’ (buy) in Table 1, wears in 1b can be dis-
ambiguated by a lexical item ‘coat’ and its tar-
get ‘oy-twu’, since ‘oy-twu’ only appears in the
table as related to ‘ip-ta’. And wears in 1c is
also restricted by ‘shoes’, but ‘shoes’ appears in
the table as related to ‘sin-ta’ and ‘sa-ta’. As
shown, these senses can be disambiguated with
the translation dictionary. Since ‘sa-ta’, or ‘buy’,
is not registered in the translation dictionary, it
is simply discarded. old in a query 1c can be
interpreted into ‘nalk-ta’ (not new) and ‘nulk-ta’
(not young) because it appears in the same table
entries for ‘sa-ta’. Since it is difficult to disam-
biguate the senses only with database informa-
tion, we may utilize co-occurrence information
between the collocated words such as (old,shoes)
and (old,car) (Park and Cho, 2000; Lee et al.,
1999).
In this paper, we propose a disambiguation
method with the database information and co-
occurrence information (Park and Cho, 2000;
Palmer et al., 1999) for the interpretation of nat-
ural language queries (Lee and Park, 2001) in
multilingual query interpretation. Although we
propose to construct the system without an inter-
mediate representation language, we show that
our Combinatory Categorial Grammar (CCG)
framework is compatible with the approaches
with an intermediate representation (Nelken and
Francez, 2000; Androutsopoulos et al., 1998;
Klein et al., 1998). We also discuss the advan-
tages and disadvantages of these two approaches.
The rest of the paper is organized as fol-
lows. A brief introduction to CCGs and natu-
ral language database interfaces (NLDBs) will
be shown in Section 2. We show the translation
process with and without an intermediate repre-
sentation using CCG in Section 3. The proposed
system with multilingual translation is described
in Sections 4 and 5.
</bodyText>
<sectionHeader confidence="0.99416" genericHeader="related work">
2 Related Work
</sectionHeader>
<bodyText confidence="0.751747">
In this paper, we propose to interpret natural lan-
guage queries in English and Korean with CCGs
and argue that word selection problem must be
resolved for multilingual query interpretation.
</bodyText>
<table confidence="0.984334">
Rule Rule Name (Symbol)
X/Y Y —s X F/W Application (&gt;)
Y X\Y —s X B/W Application (&lt;)
X conj X —s X Coordination (&lt; 0n &gt;)
X/Y Y/Z —s X/Z F/W Composition (&gt; B)
Y \Z X\Y —s X\Z B/W Composition (&lt; B)
X/Y Y \Z —s X\Z F/W Crossed Comp. (&gt; Bx)
X —s T/(T \X) F/W Type Raising (&gt; T)
X —s T \(T/X) B/W Type Raising (&lt; T)
</table>
<tableCaption confidence="0.997808">
Table 2: CCG Rules for Korean
</tableCaption>
<subsectionHeader confidence="0.975174">
2.1 Combinatory Categorial Grammar
</subsectionHeader>
<bodyText confidence="0.999572333333334">
Combinatory Categorial Grammars (CCGs) are
combinatory extensions to the categorial gram-
mars (Steedman, 2000). CCGs are among the
lexicalized grammars, such as linear indexed
grammars and tree adjoining grammars, and are
generally known to provide a wide linguistic
coverage and a way of processing sentences in-
crementally.
Table 2 shows the CCG reduction rules pro-
posed for Korean (Park and Cho, 2000). (Steed-
man, 2000) suggested the reduction rules for En-
glish which include backward crossed composi-
tion and backward substitution. We adopt this
rule set for the processing of the queries in En-
glish.
</bodyText>
<listItem confidence="0.6284925">
(2) Who wears old shoes?
np (s\np)/np np/np np
</listItem>
<equation confidence="0.466152333333333">
np
s\np
&lt;
</equation>
<bodyText confidence="0.999472333333333">
Example 2 shows a syntactic derivation for an
example query using CCG. Transitive verbs like
‘wears’ are assigned the category (s\np)/np,
which receives a phrase of category np on its
right (the second np and the directionality is indi-
cated by the slash /, that is, to the right) and then
receives another np on its left (the first np and
the directionality is indicated by the backslash \,
that is, to the left), to give rise to the phrase of
category s. Such a computation is done by sim-
ple function application. Example 3 shows the
CCG derivation for a query with coordination.
</bodyText>
<listItem confidence="0.519354">
(3) Who wears old shoes and a brown coat?
</listItem>
<figure confidence="0.7749324">
np (s\np)/np np conj np
np
&gt;
s\np
&lt;
s
&gt;
&gt;
s
&lt;,Dn&gt;
</figure>
<bodyText confidence="0.999382">
In addition to function application utilized in ex-
amples 2 and 3, CCGs use rules for a limited
set of combinators such as B (function compo-
sition), T (type raising), and S (function substi-
tution) to model natural language. The reader is
referred to (Steedman, 2000) for further details.
</bodyText>
<subsectionHeader confidence="0.999669">
2.2 Multilingual Database Interfaces
</subsectionHeader>
<bodyText confidence="0.9998175">
There have been many proposals for NLDBs
since the 1960’s3. In this section, we review
some of the more recent ones. (Androutsopou-
los et al., 1998; Nelken and Francez, 2000) focus
on queries in English with temporal expressions,
with a specialized semantic representation lan-
guage that can handle temporality. Examples are
shown below.
</bodyText>
<listItem confidence="0.999517333333333">
(4) (a) Did any flight circle while runway 2 was open?
(b) Which companies serviced BA737 in 1990?
(c) During which years did Mary work in marketing?
</listItem>
<bodyText confidence="0.99747068">
The system in (Klein et al., 1998) interprets noun
phrase queries such as 5 in German:
(5) Ersatzzeiten wegen Kindererziehung
(Exemption times because of child raising)
While the system can analyze noun phrases with
various adverbial phrases, it is not reported to
handle more complex noun phrase queries such
as those with subordinate or coordinate construc-
tions.
None of these work deals with multilingual
issues. Nor is there much related work in the
field of NLDBs. (Thompson and Mooney, 1999)
presents a system that automatically constructs
the lexicon for NLDBs, in various languages
such as English, Spanish, Japanese, and Turkish,
which represents the lexical entries with a pair of
the phrases and the corresponding semantic rep-
resentation in first-order logic. Since the seman-
tic representation for lexical items is determined
using the frequency of the general terms of the
semantic representation in the corpus made up
of the query sentences annotated by their logical
representation, the system makes it difficult to
incorporate various linguistic considerations on
natural language.
</bodyText>
<footnote confidence="0.95443">
3The reader is referred to (Androutsopoulos et al., 1995)
for a survey.
</footnote>
<sectionHeader confidence="0.740206" genericHeader="method">
3 Translation with CCG
</sectionHeader>
<bodyText confidence="0.9998465">
In this section, we discuss the translation with
and without an intermediate language. The
translation based on CCG can derive the tar-
get database language expressions/queries such
as SQL, TSQL, and QUBE, as well as expres-
sions in intermediate representation languages.
We show the translation into both languages with
examples (Nelken and Francez, 2000).
</bodyText>
<subsectionHeader confidence="0.997131">
3.1 Indirect vs. Direct Translation
</subsectionHeader>
<bodyText confidence="0.999934933333333">
Most NLDBs use an intermediate representa-
tion which does not make use of expressions
that correspond directly to real database objects.
The intermediate representations are usually no-
tated as logic expressions such as a quasi-logical
form (Klein et al., 1998) and a customized lan-
guage (Androutsopoulos et al., 1998; Nelken and
Francez, 2000). These representations provide a
way to translate indirectly to the target database
languages.
For example, query 6a is translated into
6b with the intermediate representation LAtten
(Nelken and Francez, 1999; Toman, 1996),
and into 6c with the SQL/Temporal expressions
(Nelken and Francez, 2000).
</bodyText>
<listItem confidence="0.988569">
(6) (a) During which years did Mary work in marketing?
(b) year(I) A 71J(work(marg, marketing; J) A J C
past A J C I
(c) NONSEQUENCED VALIDTIME
</listItem>
<table confidence="0.640257333333333">
SELECT DISTINCT a0.c1 AS c1
FROM work’ AS a1,year’ AS a0
WHERE VALIDTIME(a0) contains VALIDTIME(a1)
AND a1.c1 = ‘mary’ AND a1.c2 = ‘marketing’
AND PERIOD(TIMESTAMP ‘beginning’, TIMESTAMP
‘now’) contains VALIDTIME(a1)
</table>
<bodyText confidence="0.997649071428571">
The translation using an intermediate represen-
tation has several advantages, including (a) the
availability of an independent linguistic front-
end, (b) the separation of domain dependent
knowledge from the system engine, and (c)
the relative easiness of augmenting the sys-
tem with an extra inference module for disam-
biguation (cf. Androutsopoulos et al., 1995).
The points (a) and (b) indicate the separation
of domain-dependent resources such as lexicon,
database mapping information, and other knowl-
edge bases. (c) arises from the modularity of the
translation process.
During which year; did mary work in marketing?
</bodyText>
<equation confidence="0.989721833333333">
(s=s)=np : np : year(I) s=s : np : mary0 snnp : (snnp)n(snnp) :
o(x; I)o(y; J):x ^ y ^ J C I o(x; J):x ^ J C_ past Axay:9Jwork(x; y; J) marketing0
� s=s : o(y; J):year(I) ^ y ^ J C I snnp : Ay:9Jwork(y; marketing0; J)
�
s : 9Jwork(mary0; marketing; J) ^ J C past
s : year(I) ^ 9Jwork(mary0; marketing; J) ^ J C past ^ J C I
</equation>
<figureCaption confidence="0.913388">
Figure 1: A Derivation of Example 6a to an Intermediate Representation
</figureCaption>
<equation confidence="0.951286">
s : 9Jwork(mary0; marketing0; J)
</equation>
<bodyText confidence="0.999980363636364">
When we use an intermediate language, we do
not need to concern ourselves with the syntac-
tic details of the target query language during the
mapping process, so that we can pay more at-
tention to the differences in syntax between the
two source languages (i.e. English and Korean),
making the resulting interpretation more reliable.
In addition, the use of an intermediate language
gives rise to a more flexible query interpretation
system as the queries can be translated into mul-
tiple target query languages without further pro-
cessing at the stage of the source query interpre-
tation. However, the use of the same intermedi-
ate language for source query languages such as
English and Korean that are known to have very
different linguistic characteristics makes it dif-
ficult to capture subtle differences between the
queries of the different source languages unless
the intermediate language is quite expressive.
And much of the expressiveness of the interme-
diate language for the translation of the queries
in one language may not be what is needed in the
translation of the queries in the other.
The translation without an intermediate repre-
sentation has a simpler and more straightforward
process. And there is no extra effort on devel-
opment of a formal intermediate representation
which is difficult to ensure the full coverage on
linguistic expressiveness and the soundness of
the proposed formalism. Nevertheless, the three
points mentioned above are thought to be dif-
ficult to overcome in this approach. However,
the points (a) and (b) can be equally achieved by
separating domain-dependent elements from the
query processing module using lexicalized gram-
mars such as CCG. In this case, the construction
of a domain-dependent lexicon can be a prob-
lem, but it can be resolved to some extent with
an automatic construction method. The point
(c) is difficult to address, since the translation
without an intermediate representation usually is
done in a single module. The inference mod-
ule, however, can be complemented by disam-
biguation using co-occurrence information (Park
and Cho, 2000) and disambiguation of domain-
dependent word senses with consideration for the
context-dependent information such as informa-
tion structure (Steedman, 2000). (Nelken and
Francez, 2000) use an intermediate representa-
tion because the compositional construction of
formulae during parsing becomes easier. How-
ever, we show that database queries can be in-
terpreted compositionally during parsing without
such an intermediate representation through di-
rect translation.
</bodyText>
<subsectionHeader confidence="0.9115025">
3.2 Translation to an Intermediate
Representation
</subsectionHeader>
<bodyText confidence="0.999967142857143">
While our approach does not make use of an in-
termediate representation, the CCG framework
itself allows queries to be interpreted into an in-
termediate representation. Figure 1 shows the
translation process from the query 6a to the form
6b which is in LAW,,. Since we are only showing
the possibility of translation, we use an exam-
ple from (Nelken and Francez, 2000). In Figure
1, we slightly modified the semantics in (Nelken
and Francez, 2000; Nelken and Francez, 1999)
for the convenience of translation. And for the
same reason, we devised the operator o-(x, I)
where x is an argument and I represents a time
interval variable.
</bodyText>
<subsectionHeader confidence="0.934589">
3.3 Translation to a Target Language
</subsectionHeader>
<bodyText confidence="0.833074333333333">
Figure 2 shows the translation process from the
query 6a to SQL/Temporal expression 6c, also
indicating the need for post-processing. For in-
</bodyText>
<table confidence="0.974348">
Word Relation Collocation Word sense Target words
wear object coat,glasses put on q]=4(ip-ta), h`=4(ssu-ta), 2l=4(sin-ta), i�1=4(cha-ta)
expression express 1=4(tti-ta), 1,=4(cis-ta)
old modifiee man,book not young =4(nulk-ta), inoq(nonyen-uy)
shoe,car not new �4=4(nalk-ta), z=4(hel-ta)
</table>
<tableCaption confidence="0.997809">
Table 3: Part of Word Disambiguation Knowledge for ‘wear’ and ‘old’
</tableCaption>
<figure confidence="0.940044777777778">
During which year did mary work in marketing ? $
&gt; &lt;
s:[_,work’,
work’.c2=‘marketing’&amp;work’.c1=‘mary’]
s:[year’.c1&amp;B,year’&amp;D,_&amp;F&amp;VALIDTIME(year’)
contains VALIDTIME(D)]/s:[B,D,F]
s:[A,B,C&amp;PERIOD(TIMESTAMP ‘beginning’, TIMESTAMP ‘now’) contains VALIDTIME(B)]/s:[A,B,C]
&gt;
s:[_,work’,work’.c2=‘marketing’&amp;work’.c1=‘mary’&amp;
PERIOD(TIMESTAMP ‘beginning’, TIMESTAMP ‘now’) contains VALIDTIME(work’)]
&gt;
s:[year’.c1&amp;_,year’&amp;work’,_&amp;work’.c2=‘marketing’&amp;work’.c1=‘mary’&amp;PERIOD(TIMESTAMP ‘beginning’,
TIMESTAMP ‘now’) contains VALIDTIME(work’)&amp;VALIDTIME(year’) contains VALIDTIME(work’)]
sql_temporal:[[SELECT,A],[FROM,B],[WHERE,C]]\s:[A,B,C]
&lt;
sql_temporal:[[SELECT,year’.c1&amp;_],[FROM,year’&amp;work’],
[WHERE,_&amp;work’.c2=‘marketing’&amp;work’.c1=‘mary’&amp;PERIOD(TIMESTAMP ‘beginning’,TIMESTAMP ‘now’)
contains VALIDTIME(work’)&amp;VALIDTIME(year’) contains VALIDTIME(work’)]]
</figure>
<figureCaption confidence="0.952874">
Figure 2: A Derivation of Example 6a to a Target
Language
</figureCaption>
<bodyText confidence="0.998476428571428">
stance, in Figure 2, multiply occurring constants
and the uninstantiated variable ‘ ’ must be dis-
carded. Additionally, ‘&amp;’ in the result of Figure
2 must be mapped to ‘AND’ and additional in-
formation such as ‘NONSEQUENCED VALID-
TIME’ and ‘DISTINCT’ must be added for the
generation of complete target results as in 6c.
</bodyText>
<sectionHeader confidence="0.995135" genericHeader="method">
4 Multilingual Translation
</sectionHeader>
<bodyText confidence="0.999972857142857">
Source word disambiguation is an important
problem in both of the approaches mentioned
in the previous section because the problem of
lexical selection arises equally. We propose a
method to translate and disambiguate the source
queries to the appropriate target database infor-
mation in a direct translation approach.
</bodyText>
<subsectionHeader confidence="0.984494">
4.1 Word Sense Disambiguation and Target
Mapping
</subsectionHeader>
<bodyText confidence="0.9998529375">
Our method to disambiguate the source queries
is based on the semantic features of the lexi-
cal items. In lexical selection methods using
the semantic features and their syntactic rela-
tions (Palmer et al., 1999; Copestake and Sanfil-
ippo, 1993), the lexicon is designed with seman-
tic type-features constructed from the semantic
classifications of a language for the collocated
verb-object and modifier-modifiee relations. We
also consider these two syntactic relations, but
we do not adopt the general semantic classifi-
cations that are hard to construct automatically.
For this, we would need the additional mapping
information to the domain databases. So we de-
signed a method with the database information
which can play the role of semantic classifica-
tions in the restricted database domain.
In query 1b, the meaning of ‘wears’ is ‘to put
on the body’, but in 1c, its meaning is ‘to put
on the foot’. The meaning of ‘old’ in 1c is ‘not
new’, but that in the phrase ‘the oldest man’ is
‘not young’. Table 3 shows word senses and their
candidate target words of ‘wears’ and ‘old’ (Lee
et al., 1999). We can disambiguate the senses
of ‘wears’ with information in the database, like
the sample database shown in Table 1, annotated
in the lexical entries. But ‘old’ in 1c cannot
be disambiguated with the database information
alone because the values of the ‘old’ can occur
in the same table attributes as shown in the sam-
ple database (Table 1). For this problem, we can
think of two disambiguation methods.
</bodyText>
<listItem confidence="0.94897175">
• Use of additional semantic type-features
based on the semantic classifications
• Use of co-occurrence information between
the collocated words
</listItem>
<bodyText confidence="0.999972">
In the first method, the source queries are disam-
biguated during parsing, but this method requires
the semantic classification information. And the
semantic features from the classifications gener-
ate many lexical entries, since all the senses for
a given lexical item have to be accounted for. As
a result, we can expect that the increase in the
number of lexical entries may also cause the in-
crease in the loss of both the space and process-
ing time of the system.
</bodyText>
<figure confidence="0.9888665">
np:[year’.c1, year’,_]
s:[A&amp;B,C&amp;D,E&amp;F&amp;VALIDTIME(C) contains VALIDTIME(D)]
/s:[B,D,F]/np:[A,C,E]
np:[_,_,‘mary’]
s:[A,work’,work’.c2=‘marketing’&amp;work’.c1=C]
\np:[A,B,C]
.
.
wear:sin-ta
wear:ssu-ta
wear:ip-ta
wear:cha-ta
wear:tti-ta
wear:cis-ta
.
.
</figure>
<bodyText confidence="0.99984219047619">
The second method needs co-occurrence in-
formation, but no additional lexical entries. And
this method also requires an additional disam-
biguation process after the parsing to extract
information on the collocated words. How-
ever, since co-occurrence information between
the words can be automatically extracted from a
general-purpose corpus, the construction of this
information is thought to be relatively straight-
forward, compared to the construction of the se-
mantic classifications. (Park and Cho, 2000; Lee
et al., 1999) proposed to use the co-occurrence
information during parsing and lexical selection.
For example, in 1c, ‘wears’ is disambiguated
into ‘sin-ta’ for the semantics of ‘shoes’ and
the collocated words ‘old’ and ‘shoes’ is ex-
tracted during the parsing. Then the disambigua-
tion module selects the preferred sense of ‘old’
through the computation of the similarity for the
co-occurrence information. As a result, ‘old’ is
correctly disambiguated into the target ‘nalk-ta’.
</bodyText>
<subsectionHeader confidence="0.999743">
4.2 Representation of Lexical Entry
</subsectionHeader>
<bodyText confidence="0.995725">
In a CCG framework, all the levels of informa-
tion, such as syntax, semantics, and discourse,
are integrated into the categorial lexicon as lexi-
cal entries. The following shows example lexical
entries of a CCG for English.
</bodyText>
<listItem confidence="0.988242">
(7) (a) lex(coat,np:[ ,‘� �c&amp;quot;’,body=‘–$†ˆ’]; ).
(b) lex(coat,np:[ ,‘1&amp;quot;�&amp;quot;’,clothes=‘–$†ˆ’]; ).
(c) lex(wears,(s:[A,B,C];wear@B;D;E\np:[A, , ];D)/np:[ ,B,C];E).
(d) lex(old,np:[A,sin-ta,status=‘���F&amp;quot;’&amp;C];old-C;E/np:[A,B,C];E).
</listItem>
<bodyText confidence="0.9623550625">
The lexical entry consists of a lexical item and
its CCG category. The CCG category is a pair
of the syntactic and semantic information that
are interwoven in the following way. Elementary
CCG (syntactic) categories include np and s, and
CCG categories are recursively defined as either
X1 or X\Y , where X and Y are also CCG cat-
egories, including elementary categories. Each
elementary CCG (syntactic) category X is aug-
mented with an appropriate semantic informa-
tion Y and word disambiguation information Z
so that the resulting form X : Y ; Z is a CCG
category (Steedman, 1996). In our proposal, the
semantic information is replaced with a suitable
fragment of SQL, with slots corresponding to
Who wears a brown coat ?
</bodyText>
<figure confidence="0.960996142857143">
np:[person,_,_];_ (s:[A,B,C];wear@B;AE;BE np:[_,ip-ta,color=kal-sayk
\np:[A,_,_];AE)/np:[_,B,C];BE &amp;body=oy-twu];_
&gt;
s:[A,ip-ta,color=kal-sayk&amp;body=oy-twu];wear@ip-ta;AE;_
\np:[A,_,_];AE
&lt;
s:[person,ip-ta,color=kal-sayk&amp;body=oy-twu];wear@ip-ta;_
</figure>
<figureCaption confidence="0.9555345">
Figure 3: A Derivation of the Query 1c and a
Portion of the Translation Dictionary
</figureCaption>
<bodyText confidence="0.9993819375">
SELECT, FROM, and WHERE clauses in SQL,
bracketed by ‘[’ and ‘]’. For example, in en-
try 7a, ‘coat’ is assigned the syntactic category
‘np’ and the semantic information which encodes
the fact that the database attribute ‘body’ has the
value ‘qT’ (oy-twu, meaning ‘coat’) in the ta-
ble for ‘OJL}’ (ip-ta, meaning ‘to put on body’).
‘ O_ ] L}’ is described in FROM clause of SQL and
‘br�ody=q T’ in WHERE clause. In entry 7b, it
shows other ‘coat’ instances in the database ta-
ble ‘A}L}’ (sa-ta, meaning ‘buy’). In entries 7c
and 7d, the verb ‘wears’ and the adjective ‘old’
are taken to add information in form of X@Y
and X-Y for the disambiguation of their senses.
X&amp;quot;Y provides a template for co-occurrence in-
formation.
</bodyText>
<subsectionHeader confidence="0.992962">
4.3 Translation Process
</subsectionHeader>
<bodyText confidence="0.999987222222222">
Figure 3 shows a derivation of the query 1c and
a relevant portion of the translation dictionary.
This derivation does not show the binding with
SQL syntax. In the final step of the derivation,
the syntactic information is combined by a back-
ward application with the category sql:[SELECT
A,FROM B,WHERE C]\s:[A,B,C]; . And the
exhibited portion of the translation dictionary
shows the list of pairs of a word and its target
word. Using this information, after the deriva-
tion in Figure 3, semantic checking is performed
with the tagged information, that is, ‘wear@ip-
ta’. This tagging is compared with the transla-
tion dictionary for the correct sense disambigua-
tion. Through this process, the results that have
a matching pair in the translation dictionary are
confirmed as the desired result, and the others are
discarded. Because the result in Figure 3 has the
</bodyText>
<figure confidence="0.993718896551724">
English Lexicon
English Lexicon Korean Lexicon English-Korean
with POS Information Translation Dictionary
General-Purpose Database
POS Tagged Corpus Information
Syntactic information
Word disambiguation
Database mapping information
information
Syntactic information Database mapping
information
Query Sentence
(English/Korean)
Database Query
Results
Engine-DB
Interaction
Module
Lexicon
English-
Korean Dic.
Co-occurrence
Information
CCG Parser
Word Translation
Checking
Results
Generation
Query Results
</figure>
<figureCaption confidence="0.999527">
Figure 4: Resources for the Lexicon
</figureCaption>
<bodyText confidence="0.837886666666667">
correct pair in Table 3, it is selected as the right
result. The resulting SQL statement is shown be-
low:
</bodyText>
<sectionHeader confidence="0.4191985" genericHeader="method">
(8) SELECT person
FROM ip-ta
</sectionHeader>
<bodyText confidence="0.756203666666667">
WHERE color=kal-saik and body=oy-twu
In response to the SQL statement 8, the answer
‘Mary’ is produced from Table 1.
</bodyText>
<subsectionHeader confidence="0.986249">
4.4 Construction of the Lexicon from
Available Resources
</subsectionHeader>
<bodyText confidence="0.999843590909091">
We construct an English lexicon for the multi-
lingual query from several linguistic resources
such as an English lexicon with only POS infor-
mation, a Korean lexicon for the mapping infor-
mation and an English-Korean translation dictio-
nary. In our system, the English-Korean transla-
tion dictionary is needed in two processes. The
first is the process of adding word sense infor-
mation to the lexical items in English and the
second is the process of checking for the senses
of the given source word. The Korean lexicon
is used for the mapping into the database and
the English lexicon with POS tag is used for ex-
tracting syntactic categories and syntactic rela-
tions between the words. Figure 4 shows the
needed information resources for the English and
Korean lexicons. The Korean lexicon is con-
structed by a tool in a semi-automatic manner
(Lee and Park, 2001). The lexicon construction
tool constructs the Korean lexicon using infor-
mation from a general-purpose corpus and do-
main specific database information.
</bodyText>
<figureCaption confidence="0.884919">
Figure 5: The Structure of the Query Processing
Engine
</figureCaption>
<sectionHeader confidence="0.997175" genericHeader="method">
5 Implementation
</sectionHeader>
<bodyText confidence="0.999157375">
Figure 5 shows the structure of the engine that
processes multilingual queries. The database is
on the home appliance domain in e-commerce. It
contains objects for appliance information such
as category, name, maker, price, size, other
features and so forth. We have populated the
database with information from Korean shopping
mall websites. Two queries are shown below:
</bodyText>
<figure confidence="0.95617275">
(9) (a) Who makes a flat-screen TV set?
(b) SELECT maker FROM product
WHERE name=‘�&apos;_-1nF,P and category=‘TV’
(10) (a) :L ;`ÏÚç ÏÕòo¥ Ao`UWÉÚê x&amp;quot;UW ,]], Æ&amp;quot;,1ÏÚç % &amp;quot;1Æ&amp;quot;cg?
I want to buy a refrigerator of the smallest capacity, but what
is its price?
(b) SELECT price FROM product WHERE size IN
(SELECT min(size) FROM product WHERE category=‘-_o,_’)
</figure>
<bodyText confidence="0.999767">
The query processing engine is implemented
on the UNIX using SICStus Prolog. The word
translation checking module performs disam-
biguation using the English-Korean dictionary
(cf. Figure 3) and co-occurrence information.
The Korean lexicon contains about a million
number of lexical entries, but the English lexi-
con is comparatively much smaller, and still un-
der construction.
The system can process diverse linguistic ex-
pressions in English such as coordination, un-
bounded dependencies, and gapping etc. The
system can also process diverse expressions in
Korean including subject ellipsis, noun phrases,
numerical expressions, coordination, and subor-
dination where the performance of the system
for the queries in Korean is reported in (Lee and
Park, 2001).
</bodyText>
<sectionHeader confidence="0.999114" genericHeader="conclusions">
6 Conclusion
</sectionHeader>
<bodyText confidence="0.999974125">
In the paper, we proposed a method to disam-
biguate the source lexical items of queries with
database information such as the objects, table
names and attribute names. Since information
about the interpreted candidates and the collo-
cated words is extracted during parsing, the im-
plemented query interpretation system can ex-
tract the results in a straightforward manner.
Since full-fledged semantic classification in-
formation is difficult to construct either automat-
ically or manually in a reliable manner, we pro-
posed to dispense with it and instead to utilize
information that can be extracted automatically
from the available resources such as the database
information, a simple translation dictionary and
other linguistic resources.
</bodyText>
<sectionHeader confidence="0.999114" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999876581818182">
I. Androutsopoulos, G. D. Ritchie, and P. Thanisch.
1995. Natural Language Interfaces to Databases -
An Introduction. Natural Language Engineering,
1(1):29–81.
I. Androutsopoulos, G. D. Ritchie, and P. Thanisch.
1998. Time, Tense and Aspect in Natural Lan-
guage Database Interfaces. Natural Language En-
gineering, 4(3):229–276.
A. Copestake and A. Sanfilippo. 1993. Multilin-
gual lexical representation. In Proceedings of the
AAAI Spring Symposium: Building Lexicons for
Machine Translation.
A. Klein, J. Matiasek, and H. Trost. 1998. The
treatment of noun phrase queries in a natural
language database access system. In COLING-
ACL’98 workshop on the computational treatment
of nominals, pages 39–45.
H. Lee and J. C. Park. 2001. Translating Natural
Language Queries into Formal Language Queries
with Combinatory Categorial Grammar. In Inter-
national Conference on Computer Processing of
Oriental Languages. (to appear).
H. A. Lee, J. C. Park, and G. C. Kim. 1999. Lexi-
cal Selection with a Target Language Monolingual
Corpus and an MRD. In Proceedings of Interna-
tional Conference on Theoretical and Methodolog-
ical Issues in Machine Translation, pages 150–
160.
R. Nelken and N. Francez. 1999. A semantics
for temporal questions. In Proceedings of Formal
Grammar, pages 131–142.
R. Nelken and N. Francez. 2000. Querying Temporal
Databases Using Controlled Natural Language. In
COLING, pages 1076–1080.
M. Palmer, D. Egedi, C. Han, F. Xia, and J. Rosen-
zweig. 1999. Constraining Lexical Selection
Across Languages Using Tree Adjoining Gram-
mars. In TAG+3 Workshop Proceedings, CSLI
volume.
J. C. Park and H. J. Cho. 2000. Informed Parsing for
Coordination with Combinatory Categorial Gram-
mar. In COLING, pages 593–599.
M. Steedman. 1996. Surface Structure and Inter-
pretation. Number 30 in Linguistic Inquiry Mono-
graphs. MIT Press.
M. Steedman. 2000. The Syntactic Process. MIT
Press.
C. A. Thompson and R. J. Mooney. 1999. Automatic
Construction of Semantic Lexicons for Learning
Natural Language Interfaces. In AAAI/IAAI, pages
487–493.
D. Toman. 1996. Point vs. Interval-based Query Lan-
guages for Temporal Databases. In Proceedings
of the ACM SIGACT-SIGMOD-SIGART PODS,
pages 58–67.
</reference>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.289045">
<title confidence="0.9994455">Automatic Augmentation of Translation Dictionary Database Terminologies in Multilingual Query Interpretation</title>
<author confidence="0.980193">C Lee</author>
<affiliation confidence="0.763722">Computer Science Division and Korea Advanced Institute of Science and</affiliation>
<address confidence="0.337403">373-1 Gusung-dong, Yusong-gu, Daejon 305-701, South</address>
<abstract confidence="0.999674">In interpreting multilingual queries to databases whose domain information is described in a particular language, we must address the problem of word sense disambiguation. Since full-fledged semantic classification information is difficult to construct either automatically or manually for this purpose, we propose to disambiguate the senses of the source lexical items by automatically augmenting a simple translation dictionary with database terminologies and describe an implemented multilingual query interpretation system in a combinatory catego-</abstract>
<intro confidence="0.866429">grammar</intro>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>I Androutsopoulos</author>
<author>G D Ritchie</author>
<author>P Thanisch</author>
</authors>
<title>Natural Language Interfaces to Databases -An Introduction.</title>
<date>1995</date>
<journal>Natural Language Engineering,</journal>
<volume>1</volume>
<issue>1</issue>
<contexts>
<context position="8508" citStr="Androutsopoulos et al., 1995" startWordPosition="1400" endWordPosition="1403">matically constructs the lexicon for NLDBs, in various languages such as English, Spanish, Japanese, and Turkish, which represents the lexical entries with a pair of the phrases and the corresponding semantic representation in first-order logic. Since the semantic representation for lexical items is determined using the frequency of the general terms of the semantic representation in the corpus made up of the query sentences annotated by their logical representation, the system makes it difficult to incorporate various linguistic considerations on natural language. 3The reader is referred to (Androutsopoulos et al., 1995) for a survey. 3 Translation with CCG In this section, we discuss the translation with and without an intermediate language. The translation based on CCG can derive the target database language expressions/queries such as SQL, TSQL, and QUBE, as well as expressions in intermediate representation languages. We show the translation into both languages with examples (Nelken and Francez, 2000). 3.1 Indirect vs. Direct Translation Most NLDBs use an intermediate representation which does not make use of expressions that correspond directly to real database objects. The intermediate representations a</context>
<context position="10299" citStr="Androutsopoulos et al., 1995" startWordPosition="1673" endWordPosition="1676">ng; J) A J C past A J C I (c) NONSEQUENCED VALIDTIME SELECT DISTINCT a0.c1 AS c1 FROM work’ AS a1,year’ AS a0 WHERE VALIDTIME(a0) contains VALIDTIME(a1) AND a1.c1 = ‘mary’ AND a1.c2 = ‘marketing’ AND PERIOD(TIMESTAMP ‘beginning’, TIMESTAMP ‘now’) contains VALIDTIME(a1) The translation using an intermediate representation has several advantages, including (a) the availability of an independent linguistic frontend, (b) the separation of domain dependent knowledge from the system engine, and (c) the relative easiness of augmenting the system with an extra inference module for disambiguation (cf. Androutsopoulos et al., 1995). The points (a) and (b) indicate the separation of domain-dependent resources such as lexicon, database mapping information, and other knowledge bases. (c) arises from the modularity of the translation process. During which year; did mary work in marketing? (s=s)=np : np : year(I) s=s : np : mary0 snnp : (snnp)n(snnp) : o(x; I)o(y; J):x ^ y ^ J C I o(x; J):x ^ J C_ past Axay:9Jwork(x; y; J) marketing0 � s=s : o(y; J):year(I) ^ y ^ J C I snnp : Ay:9Jwork(y; marketing0; J) � s : 9Jwork(mary0; marketing; J) ^ J C past s : year(I) ^ 9Jwork(mary0; marketing; J) ^ J C past ^ J C I Figure 1: A Deriv</context>
</contexts>
<marker>Androutsopoulos, Ritchie, Thanisch, 1995</marker>
<rawString>I. Androutsopoulos, G. D. Ritchie, and P. Thanisch. 1995. Natural Language Interfaces to Databases -An Introduction. Natural Language Engineering, 1(1):29–81.</rawString>
</citation>
<citation valid="true">
<authors>
<author>I Androutsopoulos</author>
<author>G D Ritchie</author>
<author>P Thanisch</author>
</authors>
<title>Time, Tense and Aspect in Natural Language Database Interfaces.</title>
<date>1998</date>
<journal>Natural Language Engineering,</journal>
<volume>4</volume>
<issue>3</issue>
<contexts>
<context position="4192" citStr="Androutsopoulos et al., 1998" startWordPosition="667" endWordPosition="670">ated words such as (old,shoes) and (old,car) (Park and Cho, 2000; Lee et al., 1999). In this paper, we propose a disambiguation method with the database information and cooccurrence information (Park and Cho, 2000; Palmer et al., 1999) for the interpretation of natural language queries (Lee and Park, 2001) in multilingual query interpretation. Although we propose to construct the system without an intermediate representation language, we show that our Combinatory Categorial Grammar (CCG) framework is compatible with the approaches with an intermediate representation (Nelken and Francez, 2000; Androutsopoulos et al., 1998; Klein et al., 1998). We also discuss the advantages and disadvantages of these two approaches. The rest of the paper is organized as follows. A brief introduction to CCGs and natural language database interfaces (NLDBs) will be shown in Section 2. We show the translation process with and without an intermediate representation using CCG in Section 3. The proposed system with multilingual translation is described in Sections 4 and 5. 2 Related Work In this paper, we propose to interpret natural language queries in English and Korean with CCGs and argue that word selection problem must be resol</context>
<context position="7014" citStr="Androutsopoulos et al., 1998" startWordPosition="1168" endWordPosition="1172">Example 3 shows the CCG derivation for a query with coordination. (3) Who wears old shoes and a brown coat? np (s\np)/np np conj np np &gt; s\np &lt; s &gt; &gt; s &lt;,Dn&gt; In addition to function application utilized in examples 2 and 3, CCGs use rules for a limited set of combinators such as B (function composition), T (type raising), and S (function substitution) to model natural language. The reader is referred to (Steedman, 2000) for further details. 2.2 Multilingual Database Interfaces There have been many proposals for NLDBs since the 1960’s3. In this section, we review some of the more recent ones. (Androutsopoulos et al., 1998; Nelken and Francez, 2000) focus on queries in English with temporal expressions, with a specialized semantic representation language that can handle temporality. Examples are shown below. (4) (a) Did any flight circle while runway 2 was open? (b) Which companies serviced BA737 in 1990? (c) During which years did Mary work in marketing? The system in (Klein et al., 1998) interprets noun phrase queries such as 5 in German: (5) Ersatzzeiten wegen Kindererziehung (Exemption times because of child raising) While the system can analyze noun phrases with various adverbial phrases, it is not reporte</context>
<context position="9253" citStr="Androutsopoulos et al., 1998" startWordPosition="1515" endWordPosition="1518">nguage. The translation based on CCG can derive the target database language expressions/queries such as SQL, TSQL, and QUBE, as well as expressions in intermediate representation languages. We show the translation into both languages with examples (Nelken and Francez, 2000). 3.1 Indirect vs. Direct Translation Most NLDBs use an intermediate representation which does not make use of expressions that correspond directly to real database objects. The intermediate representations are usually notated as logic expressions such as a quasi-logical form (Klein et al., 1998) and a customized language (Androutsopoulos et al., 1998; Nelken and Francez, 2000). These representations provide a way to translate indirectly to the target database languages. For example, query 6a is translated into 6b with the intermediate representation LAtten (Nelken and Francez, 1999; Toman, 1996), and into 6c with the SQL/Temporal expressions (Nelken and Francez, 2000). (6) (a) During which years did Mary work in marketing? (b) year(I) A 71J(work(marg, marketing; J) A J C past A J C I (c) NONSEQUENCED VALIDTIME SELECT DISTINCT a0.c1 AS c1 FROM work’ AS a1,year’ AS a0 WHERE VALIDTIME(a0) contains VALIDTIME(a1) AND a1.c1 = ‘mary’ AND a1.c2 =</context>
</contexts>
<marker>Androutsopoulos, Ritchie, Thanisch, 1998</marker>
<rawString>I. Androutsopoulos, G. D. Ritchie, and P. Thanisch. 1998. Time, Tense and Aspect in Natural Language Database Interfaces. Natural Language Engineering, 4(3):229–276.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Copestake</author>
<author>A Sanfilippo</author>
</authors>
<title>Multilingual lexical representation.</title>
<date>1993</date>
<booktitle>In Proceedings of the AAAI Spring Symposium: Building Lexicons for Machine Translation.</booktitle>
<contexts>
<context position="16615" citStr="Copestake and Sanfilippo, 1993" startWordPosition="2597" endWordPosition="2601">tilingual Translation Source word disambiguation is an important problem in both of the approaches mentioned in the previous section because the problem of lexical selection arises equally. We propose a method to translate and disambiguate the source queries to the appropriate target database information in a direct translation approach. 4.1 Word Sense Disambiguation and Target Mapping Our method to disambiguate the source queries is based on the semantic features of the lexical items. In lexical selection methods using the semantic features and their syntactic relations (Palmer et al., 1999; Copestake and Sanfilippo, 1993), the lexicon is designed with semantic type-features constructed from the semantic classifications of a language for the collocated verb-object and modifier-modifiee relations. We also consider these two syntactic relations, but we do not adopt the general semantic classifications that are hard to construct automatically. For this, we would need the additional mapping information to the domain databases. So we designed a method with the database information which can play the role of semantic classifications in the restricted database domain. In query 1b, the meaning of ‘wears’ is ‘to put on </context>
</contexts>
<marker>Copestake, Sanfilippo, 1993</marker>
<rawString>A. Copestake and A. Sanfilippo. 1993. Multilingual lexical representation. In Proceedings of the AAAI Spring Symposium: Building Lexicons for Machine Translation.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Klein</author>
<author>J Matiasek</author>
<author>H Trost</author>
</authors>
<title>The treatment of noun phrase queries in a natural language database access system.</title>
<date>1998</date>
<booktitle>In COLINGACL’98 workshop on the computational treatment of nominals,</booktitle>
<pages>39--45</pages>
<contexts>
<context position="4213" citStr="Klein et al., 1998" startWordPosition="671" endWordPosition="674"> and (old,car) (Park and Cho, 2000; Lee et al., 1999). In this paper, we propose a disambiguation method with the database information and cooccurrence information (Park and Cho, 2000; Palmer et al., 1999) for the interpretation of natural language queries (Lee and Park, 2001) in multilingual query interpretation. Although we propose to construct the system without an intermediate representation language, we show that our Combinatory Categorial Grammar (CCG) framework is compatible with the approaches with an intermediate representation (Nelken and Francez, 2000; Androutsopoulos et al., 1998; Klein et al., 1998). We also discuss the advantages and disadvantages of these two approaches. The rest of the paper is organized as follows. A brief introduction to CCGs and natural language database interfaces (NLDBs) will be shown in Section 2. We show the translation process with and without an intermediate representation using CCG in Section 3. The proposed system with multilingual translation is described in Sections 4 and 5. 2 Related Work In this paper, we propose to interpret natural language queries in English and Korean with CCGs and argue that word selection problem must be resolved for multilingual </context>
<context position="7388" citStr="Klein et al., 1998" startWordPosition="1230" endWordPosition="1233">e reader is referred to (Steedman, 2000) for further details. 2.2 Multilingual Database Interfaces There have been many proposals for NLDBs since the 1960’s3. In this section, we review some of the more recent ones. (Androutsopoulos et al., 1998; Nelken and Francez, 2000) focus on queries in English with temporal expressions, with a specialized semantic representation language that can handle temporality. Examples are shown below. (4) (a) Did any flight circle while runway 2 was open? (b) Which companies serviced BA737 in 1990? (c) During which years did Mary work in marketing? The system in (Klein et al., 1998) interprets noun phrase queries such as 5 in German: (5) Ersatzzeiten wegen Kindererziehung (Exemption times because of child raising) While the system can analyze noun phrases with various adverbial phrases, it is not reported to handle more complex noun phrase queries such as those with subordinate or coordinate constructions. None of these work deals with multilingual issues. Nor is there much related work in the field of NLDBs. (Thompson and Mooney, 1999) presents a system that automatically constructs the lexicon for NLDBs, in various languages such as English, Spanish, Japanese, and Turk</context>
<context position="9197" citStr="Klein et al., 1998" startWordPosition="1506" endWordPosition="1509">translation with and without an intermediate language. The translation based on CCG can derive the target database language expressions/queries such as SQL, TSQL, and QUBE, as well as expressions in intermediate representation languages. We show the translation into both languages with examples (Nelken and Francez, 2000). 3.1 Indirect vs. Direct Translation Most NLDBs use an intermediate representation which does not make use of expressions that correspond directly to real database objects. The intermediate representations are usually notated as logic expressions such as a quasi-logical form (Klein et al., 1998) and a customized language (Androutsopoulos et al., 1998; Nelken and Francez, 2000). These representations provide a way to translate indirectly to the target database languages. For example, query 6a is translated into 6b with the intermediate representation LAtten (Nelken and Francez, 1999; Toman, 1996), and into 6c with the SQL/Temporal expressions (Nelken and Francez, 2000). (6) (a) During which years did Mary work in marketing? (b) year(I) A 71J(work(marg, marketing; J) A J C past A J C I (c) NONSEQUENCED VALIDTIME SELECT DISTINCT a0.c1 AS c1 FROM work’ AS a1,year’ AS a0 WHERE VALIDTIME(a</context>
</contexts>
<marker>Klein, Matiasek, Trost, 1998</marker>
<rawString>A. Klein, J. Matiasek, and H. Trost. 1998. The treatment of noun phrase queries in a natural language database access system. In COLINGACL’98 workshop on the computational treatment of nominals, pages 39–45.</rawString>
</citation>
<citation valid="true">
<authors>
<author>H Lee</author>
<author>J C Park</author>
</authors>
<title>Translating Natural Language Queries into Formal Language Queries with Combinatory Categorial Grammar.</title>
<date>2001</date>
<booktitle>In International Conference on Computer Processing of Oriental Languages.</booktitle>
<note>(to appear).</note>
<contexts>
<context position="3871" citStr="Lee and Park, 2001" startWordPosition="624" endWordPosition="627">, it is simply discarded. old in a query 1c can be interpreted into ‘nalk-ta’ (not new) and ‘nulk-ta’ (not young) because it appears in the same table entries for ‘sa-ta’. Since it is difficult to disambiguate the senses only with database information, we may utilize co-occurrence information between the collocated words such as (old,shoes) and (old,car) (Park and Cho, 2000; Lee et al., 1999). In this paper, we propose a disambiguation method with the database information and cooccurrence information (Park and Cho, 2000; Palmer et al., 1999) for the interpretation of natural language queries (Lee and Park, 2001) in multilingual query interpretation. Although we propose to construct the system without an intermediate representation language, we show that our Combinatory Categorial Grammar (CCG) framework is compatible with the approaches with an intermediate representation (Nelken and Francez, 2000; Androutsopoulos et al., 1998; Klein et al., 1998). We also discuss the advantages and disadvantages of these two approaches. The rest of the paper is organized as follows. A brief introduction to CCGs and natural language database interfaces (NLDBs) will be shown in Section 2. We show the translation proce</context>
<context position="24560" citStr="Lee and Park, 2001" startWordPosition="3819" endWordPosition="3822">In our system, the English-Korean translation dictionary is needed in two processes. The first is the process of adding word sense information to the lexical items in English and the second is the process of checking for the senses of the given source word. The Korean lexicon is used for the mapping into the database and the English lexicon with POS tag is used for extracting syntactic categories and syntactic relations between the words. Figure 4 shows the needed information resources for the English and Korean lexicons. The Korean lexicon is constructed by a tool in a semi-automatic manner (Lee and Park, 2001). The lexicon construction tool constructs the Korean lexicon using information from a general-purpose corpus and domain specific database information. Figure 5: The Structure of the Query Processing Engine 5 Implementation Figure 5 shows the structure of the engine that processes multilingual queries. The database is on the home appliance domain in e-commerce. It contains objects for appliance information such as category, name, maker, price, size, other features and so forth. We have populated the database with information from Korean shopping mall websites. Two queries are shown below: (9) </context>
<context position="26260" citStr="Lee and Park, 2001" startWordPosition="4077" endWordPosition="4080"> using the English-Korean dictionary (cf. Figure 3) and co-occurrence information. The Korean lexicon contains about a million number of lexical entries, but the English lexicon is comparatively much smaller, and still under construction. The system can process diverse linguistic expressions in English such as coordination, unbounded dependencies, and gapping etc. The system can also process diverse expressions in Korean including subject ellipsis, noun phrases, numerical expressions, coordination, and subordination where the performance of the system for the queries in Korean is reported in (Lee and Park, 2001). 6 Conclusion In the paper, we proposed a method to disambiguate the source lexical items of queries with database information such as the objects, table names and attribute names. Since information about the interpreted candidates and the collocated words is extracted during parsing, the implemented query interpretation system can extract the results in a straightforward manner. Since full-fledged semantic classification information is difficult to construct either automatically or manually in a reliable manner, we proposed to dispense with it and instead to utilize information that can be e</context>
</contexts>
<marker>Lee, Park, 2001</marker>
<rawString>H. Lee and J. C. Park. 2001. Translating Natural Language Queries into Formal Language Queries with Combinatory Categorial Grammar. In International Conference on Computer Processing of Oriental Languages. (to appear).</rawString>
</citation>
<citation valid="true">
<authors>
<author>H A Lee</author>
<author>J C Park</author>
<author>G C Kim</author>
</authors>
<title>Lexical Selection with a Target Language Monolingual Corpus and an MRD.</title>
<date>1999</date>
<booktitle>In Proceedings of International Conference on Theoretical and Methodological Issues in Machine Translation,</booktitle>
<pages>150--160</pages>
<contexts>
<context position="3647" citStr="Lee et al., 1999" startWordPosition="588" endWordPosition="591">s’, but ‘shoes’ appears in the table as related to ‘sin-ta’ and ‘sa-ta’. As shown, these senses can be disambiguated with the translation dictionary. Since ‘sa-ta’, or ‘buy’, is not registered in the translation dictionary, it is simply discarded. old in a query 1c can be interpreted into ‘nalk-ta’ (not new) and ‘nulk-ta’ (not young) because it appears in the same table entries for ‘sa-ta’. Since it is difficult to disambiguate the senses only with database information, we may utilize co-occurrence information between the collocated words such as (old,shoes) and (old,car) (Park and Cho, 2000; Lee et al., 1999). In this paper, we propose a disambiguation method with the database information and cooccurrence information (Park and Cho, 2000; Palmer et al., 1999) for the interpretation of natural language queries (Lee and Park, 2001) in multilingual query interpretation. Although we propose to construct the system without an intermediate representation language, we show that our Combinatory Categorial Grammar (CCG) framework is compatible with the approaches with an intermediate representation (Nelken and Francez, 2000; Androutsopoulos et al., 1998; Klein et al., 1998). We also discuss the advantages a</context>
<context position="17469" citStr="Lee et al., 1999" startWordPosition="2743" endWordPosition="2746">ot adopt the general semantic classifications that are hard to construct automatically. For this, we would need the additional mapping information to the domain databases. So we designed a method with the database information which can play the role of semantic classifications in the restricted database domain. In query 1b, the meaning of ‘wears’ is ‘to put on the body’, but in 1c, its meaning is ‘to put on the foot’. The meaning of ‘old’ in 1c is ‘not new’, but that in the phrase ‘the oldest man’ is ‘not young’. Table 3 shows word senses and their candidate target words of ‘wears’ and ‘old’ (Lee et al., 1999). We can disambiguate the senses of ‘wears’ with information in the database, like the sample database shown in Table 1, annotated in the lexical entries. But ‘old’ in 1c cannot be disambiguated with the database information alone because the values of the ‘old’ can occur in the same table attributes as shown in the sample database (Table 1). For this problem, we can think of two disambiguation methods. • Use of additional semantic type-features based on the semantic classifications • Use of co-occurrence information between the collocated words In the first method, the source queries are disa</context>
<context position="19255" citStr="Lee et al., 1999" startWordPosition="3009" endWordPosition="3012">=C] \np:[A,B,C] . . wear:sin-ta wear:ssu-ta wear:ip-ta wear:cha-ta wear:tti-ta wear:cis-ta . . The second method needs co-occurrence information, but no additional lexical entries. And this method also requires an additional disambiguation process after the parsing to extract information on the collocated words. However, since co-occurrence information between the words can be automatically extracted from a general-purpose corpus, the construction of this information is thought to be relatively straightforward, compared to the construction of the semantic classifications. (Park and Cho, 2000; Lee et al., 1999) proposed to use the co-occurrence information during parsing and lexical selection. For example, in 1c, ‘wears’ is disambiguated into ‘sin-ta’ for the semantics of ‘shoes’ and the collocated words ‘old’ and ‘shoes’ is extracted during the parsing. Then the disambiguation module selects the preferred sense of ‘old’ through the computation of the similarity for the co-occurrence information. As a result, ‘old’ is correctly disambiguated into the target ‘nalk-ta’. 4.2 Representation of Lexical Entry In a CCG framework, all the levels of information, such as syntax, semantics, and discourse, are </context>
</contexts>
<marker>Lee, Park, Kim, 1999</marker>
<rawString>H. A. Lee, J. C. Park, and G. C. Kim. 1999. Lexical Selection with a Target Language Monolingual Corpus and an MRD. In Proceedings of International Conference on Theoretical and Methodological Issues in Machine Translation, pages 150– 160.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Nelken</author>
<author>N Francez</author>
</authors>
<title>A semantics for temporal questions.</title>
<date>1999</date>
<booktitle>In Proceedings of Formal Grammar,</booktitle>
<pages>131--142</pages>
<contexts>
<context position="9489" citStr="Nelken and Francez, 1999" startWordPosition="1549" endWordPosition="1552">examples (Nelken and Francez, 2000). 3.1 Indirect vs. Direct Translation Most NLDBs use an intermediate representation which does not make use of expressions that correspond directly to real database objects. The intermediate representations are usually notated as logic expressions such as a quasi-logical form (Klein et al., 1998) and a customized language (Androutsopoulos et al., 1998; Nelken and Francez, 2000). These representations provide a way to translate indirectly to the target database languages. For example, query 6a is translated into 6b with the intermediate representation LAtten (Nelken and Francez, 1999; Toman, 1996), and into 6c with the SQL/Temporal expressions (Nelken and Francez, 2000). (6) (a) During which years did Mary work in marketing? (b) year(I) A 71J(work(marg, marketing; J) A J C past A J C I (c) NONSEQUENCED VALIDTIME SELECT DISTINCT a0.c1 AS c1 FROM work’ AS a1,year’ AS a0 WHERE VALIDTIME(a0) contains VALIDTIME(a1) AND a1.c1 = ‘mary’ AND a1.c2 = ‘marketing’ AND PERIOD(TIMESTAMP ‘beginning’, TIMESTAMP ‘now’) contains VALIDTIME(a1) The translation using an intermediate representation has several advantages, including (a) the availability of an independent linguistic frontend, (b</context>
<context position="14059" citStr="Nelken and Francez, 1999" startWordPosition="2286" endWordPosition="2289">d compositionally during parsing without such an intermediate representation through direct translation. 3.2 Translation to an Intermediate Representation While our approach does not make use of an intermediate representation, the CCG framework itself allows queries to be interpreted into an intermediate representation. Figure 1 shows the translation process from the query 6a to the form 6b which is in LAW,,. Since we are only showing the possibility of translation, we use an example from (Nelken and Francez, 2000). In Figure 1, we slightly modified the semantics in (Nelken and Francez, 2000; Nelken and Francez, 1999) for the convenience of translation. And for the same reason, we devised the operator o-(x, I) where x is an argument and I represents a time interval variable. 3.3 Translation to a Target Language Figure 2 shows the translation process from the query 6a to SQL/Temporal expression 6c, also indicating the need for post-processing. For inWord Relation Collocation Word sense Target words wear object coat,glasses put on q]=4(ip-ta), h`=4(ssu-ta), 2l=4(sin-ta), i�1=4(cha-ta) expression express 1=4(tti-ta), 1,=4(cis-ta) old modifiee man,book not young =4(nulk-ta), inoq(nonyen-uy) shoe,car not new �4</context>
</contexts>
<marker>Nelken, Francez, 1999</marker>
<rawString>R. Nelken and N. Francez. 1999. A semantics for temporal questions. In Proceedings of Formal Grammar, pages 131–142.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Nelken</author>
<author>N Francez</author>
</authors>
<title>Querying Temporal Databases Using Controlled Natural Language. In</title>
<date>2000</date>
<booktitle>COLING,</booktitle>
<pages>1076--1080</pages>
<contexts>
<context position="4162" citStr="Nelken and Francez, 2000" startWordPosition="663" endWordPosition="666">rmation between the collocated words such as (old,shoes) and (old,car) (Park and Cho, 2000; Lee et al., 1999). In this paper, we propose a disambiguation method with the database information and cooccurrence information (Park and Cho, 2000; Palmer et al., 1999) for the interpretation of natural language queries (Lee and Park, 2001) in multilingual query interpretation. Although we propose to construct the system without an intermediate representation language, we show that our Combinatory Categorial Grammar (CCG) framework is compatible with the approaches with an intermediate representation (Nelken and Francez, 2000; Androutsopoulos et al., 1998; Klein et al., 1998). We also discuss the advantages and disadvantages of these two approaches. The rest of the paper is organized as follows. A brief introduction to CCGs and natural language database interfaces (NLDBs) will be shown in Section 2. We show the translation process with and without an intermediate representation using CCG in Section 3. The proposed system with multilingual translation is described in Sections 4 and 5. 2 Related Work In this paper, we propose to interpret natural language queries in English and Korean with CCGs and argue that word s</context>
<context position="7041" citStr="Nelken and Francez, 2000" startWordPosition="1173" endWordPosition="1176">tion for a query with coordination. (3) Who wears old shoes and a brown coat? np (s\np)/np np conj np np &gt; s\np &lt; s &gt; &gt; s &lt;,Dn&gt; In addition to function application utilized in examples 2 and 3, CCGs use rules for a limited set of combinators such as B (function composition), T (type raising), and S (function substitution) to model natural language. The reader is referred to (Steedman, 2000) for further details. 2.2 Multilingual Database Interfaces There have been many proposals for NLDBs since the 1960’s3. In this section, we review some of the more recent ones. (Androutsopoulos et al., 1998; Nelken and Francez, 2000) focus on queries in English with temporal expressions, with a specialized semantic representation language that can handle temporality. Examples are shown below. (4) (a) Did any flight circle while runway 2 was open? (b) Which companies serviced BA737 in 1990? (c) During which years did Mary work in marketing? The system in (Klein et al., 1998) interprets noun phrase queries such as 5 in German: (5) Ersatzzeiten wegen Kindererziehung (Exemption times because of child raising) While the system can analyze noun phrases with various adverbial phrases, it is not reported to handle more complex no</context>
<context position="8900" citStr="Nelken and Francez, 2000" startWordPosition="1461" endWordPosition="1464">s made up of the query sentences annotated by their logical representation, the system makes it difficult to incorporate various linguistic considerations on natural language. 3The reader is referred to (Androutsopoulos et al., 1995) for a survey. 3 Translation with CCG In this section, we discuss the translation with and without an intermediate language. The translation based on CCG can derive the target database language expressions/queries such as SQL, TSQL, and QUBE, as well as expressions in intermediate representation languages. We show the translation into both languages with examples (Nelken and Francez, 2000). 3.1 Indirect vs. Direct Translation Most NLDBs use an intermediate representation which does not make use of expressions that correspond directly to real database objects. The intermediate representations are usually notated as logic expressions such as a quasi-logical form (Klein et al., 1998) and a customized language (Androutsopoulos et al., 1998; Nelken and Francez, 2000). These representations provide a way to translate indirectly to the target database languages. For example, query 6a is translated into 6b with the intermediate representation LAtten (Nelken and Francez, 1999; Toman, 19</context>
<context position="13260" citStr="Nelken and Francez, 2000" startWordPosition="2162" endWordPosition="2165">calized grammars such as CCG. In this case, the construction of a domain-dependent lexicon can be a problem, but it can be resolved to some extent with an automatic construction method. The point (c) is difficult to address, since the translation without an intermediate representation usually is done in a single module. The inference module, however, can be complemented by disambiguation using co-occurrence information (Park and Cho, 2000) and disambiguation of domaindependent word senses with consideration for the context-dependent information such as information structure (Steedman, 2000). (Nelken and Francez, 2000) use an intermediate representation because the compositional construction of formulae during parsing becomes easier. However, we show that database queries can be interpreted compositionally during parsing without such an intermediate representation through direct translation. 3.2 Translation to an Intermediate Representation While our approach does not make use of an intermediate representation, the CCG framework itself allows queries to be interpreted into an intermediate representation. Figure 1 shows the translation process from the query 6a to the form 6b which is in LAW,,. Since we are </context>
</contexts>
<marker>Nelken, Francez, 2000</marker>
<rawString>R. Nelken and N. Francez. 2000. Querying Temporal Databases Using Controlled Natural Language. In COLING, pages 1076–1080.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Palmer</author>
<author>D Egedi</author>
<author>C Han</author>
<author>F Xia</author>
<author>J Rosenzweig</author>
</authors>
<title>Constraining Lexical Selection Across Languages Using Tree Adjoining Grammars.</title>
<date>1999</date>
<booktitle>In TAG+3 Workshop Proceedings, CSLI volume.</booktitle>
<contexts>
<context position="1850" citStr="Palmer et al., 1999" startWordPosition="276" endWordPosition="279">ation described in Korean, lexical items in English must be disambiguated to the matching senses in Korean. This problem is similar to that of lexical selection in machine translation domain (Lee et al., 1This work was supported by the Korea Science and Engineering Foundation (KOSEF) through AITrc. ip-ta person body color ... Mary oy-twu kal-sayk ... ... ... ... ... sin-ta person foot status ... John sin-bal nalk-ta ... ... ... ... ... sa-ta person object status ... John ca-tong-cha nalk-ta ... Mary sin-bal nalk-ta ... Manny ko-yang-i nulk-ta ... ... ... ... ... Table 1: Sample Database 1999; Palmer et al., 1999), except that the target is different in the sense that one is a formal query language and the other is another natural language. This difference prompts us to make use of database information, such as domain database objects, table names, and attribute names, instead of the general semantic classifications (Palmer et al., 1999) for disambiguating the senses of lexical items in the query. Example queries are shown below: (1) (a) Which shoes does Mary buy? (b) Who wears a brown coat? (c) Who wears old shoes and buys an old car? Query 1a shows a query made up of unambiguous words having a unique</context>
<context position="3799" citStr="Palmer et al., 1999" startWordPosition="612" endWordPosition="615"> Since ‘sa-ta’, or ‘buy’, is not registered in the translation dictionary, it is simply discarded. old in a query 1c can be interpreted into ‘nalk-ta’ (not new) and ‘nulk-ta’ (not young) because it appears in the same table entries for ‘sa-ta’. Since it is difficult to disambiguate the senses only with database information, we may utilize co-occurrence information between the collocated words such as (old,shoes) and (old,car) (Park and Cho, 2000; Lee et al., 1999). In this paper, we propose a disambiguation method with the database information and cooccurrence information (Park and Cho, 2000; Palmer et al., 1999) for the interpretation of natural language queries (Lee and Park, 2001) in multilingual query interpretation. Although we propose to construct the system without an intermediate representation language, we show that our Combinatory Categorial Grammar (CCG) framework is compatible with the approaches with an intermediate representation (Nelken and Francez, 2000; Androutsopoulos et al., 1998; Klein et al., 1998). We also discuss the advantages and disadvantages of these two approaches. The rest of the paper is organized as follows. A brief introduction to CCGs and natural language database inte</context>
<context position="16582" citStr="Palmer et al., 1999" startWordPosition="2593" endWordPosition="2596">sults as in 6c. 4 Multilingual Translation Source word disambiguation is an important problem in both of the approaches mentioned in the previous section because the problem of lexical selection arises equally. We propose a method to translate and disambiguate the source queries to the appropriate target database information in a direct translation approach. 4.1 Word Sense Disambiguation and Target Mapping Our method to disambiguate the source queries is based on the semantic features of the lexical items. In lexical selection methods using the semantic features and their syntactic relations (Palmer et al., 1999; Copestake and Sanfilippo, 1993), the lexicon is designed with semantic type-features constructed from the semantic classifications of a language for the collocated verb-object and modifier-modifiee relations. We also consider these two syntactic relations, but we do not adopt the general semantic classifications that are hard to construct automatically. For this, we would need the additional mapping information to the domain databases. So we designed a method with the database information which can play the role of semantic classifications in the restricted database domain. In query 1b, the </context>
</contexts>
<marker>Palmer, Egedi, Han, Xia, Rosenzweig, 1999</marker>
<rawString>M. Palmer, D. Egedi, C. Han, F. Xia, and J. Rosenzweig. 1999. Constraining Lexical Selection Across Languages Using Tree Adjoining Grammars. In TAG+3 Workshop Proceedings, CSLI volume.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J C Park</author>
<author>H J Cho</author>
</authors>
<title>Informed Parsing for Coordination with Combinatory Categorial Grammar. In</title>
<date>2000</date>
<booktitle>COLING,</booktitle>
<pages>593--599</pages>
<contexts>
<context position="3628" citStr="Park and Cho, 2000" startWordPosition="584" endWordPosition="587"> restricted by ‘shoes’, but ‘shoes’ appears in the table as related to ‘sin-ta’ and ‘sa-ta’. As shown, these senses can be disambiguated with the translation dictionary. Since ‘sa-ta’, or ‘buy’, is not registered in the translation dictionary, it is simply discarded. old in a query 1c can be interpreted into ‘nalk-ta’ (not new) and ‘nulk-ta’ (not young) because it appears in the same table entries for ‘sa-ta’. Since it is difficult to disambiguate the senses only with database information, we may utilize co-occurrence information between the collocated words such as (old,shoes) and (old,car) (Park and Cho, 2000; Lee et al., 1999). In this paper, we propose a disambiguation method with the database information and cooccurrence information (Park and Cho, 2000; Palmer et al., 1999) for the interpretation of natural language queries (Lee and Park, 2001) in multilingual query interpretation. Although we propose to construct the system without an intermediate representation language, we show that our Combinatory Categorial Grammar (CCG) framework is compatible with the approaches with an intermediate representation (Nelken and Francez, 2000; Androutsopoulos et al., 1998; Klein et al., 1998). We also discu</context>
<context position="5614" citStr="Park and Cho, 2000" startWordPosition="918" endWordPosition="921"> \Z X\Y —s X\Z B/W Composition (&lt; B) X/Y Y \Z —s X\Z F/W Crossed Comp. (&gt; Bx) X —s T/(T \X) F/W Type Raising (&gt; T) X —s T \(T/X) B/W Type Raising (&lt; T) Table 2: CCG Rules for Korean 2.1 Combinatory Categorial Grammar Combinatory Categorial Grammars (CCGs) are combinatory extensions to the categorial grammars (Steedman, 2000). CCGs are among the lexicalized grammars, such as linear indexed grammars and tree adjoining grammars, and are generally known to provide a wide linguistic coverage and a way of processing sentences incrementally. Table 2 shows the CCG reduction rules proposed for Korean (Park and Cho, 2000). (Steedman, 2000) suggested the reduction rules for English which include backward crossed composition and backward substitution. We adopt this rule set for the processing of the queries in English. (2) Who wears old shoes? np (s\np)/np np/np np np s\np &lt; Example 2 shows a syntactic derivation for an example query using CCG. Transitive verbs like ‘wears’ are assigned the category (s\np)/np, which receives a phrase of category np on its right (the second np and the directionality is indicated by the slash /, that is, to the right) and then receives another np on its left (the first np and the </context>
<context position="13078" citStr="Park and Cho, 2000" startWordPosition="2138" endWordPosition="2141">ficult to overcome in this approach. However, the points (a) and (b) can be equally achieved by separating domain-dependent elements from the query processing module using lexicalized grammars such as CCG. In this case, the construction of a domain-dependent lexicon can be a problem, but it can be resolved to some extent with an automatic construction method. The point (c) is difficult to address, since the translation without an intermediate representation usually is done in a single module. The inference module, however, can be complemented by disambiguation using co-occurrence information (Park and Cho, 2000) and disambiguation of domaindependent word senses with consideration for the context-dependent information such as information structure (Steedman, 2000). (Nelken and Francez, 2000) use an intermediate representation because the compositional construction of formulae during parsing becomes easier. However, we show that database queries can be interpreted compositionally during parsing without such an intermediate representation through direct translation. 3.2 Translation to an Intermediate Representation While our approach does not make use of an intermediate representation, the CCG framework</context>
<context position="19236" citStr="Park and Cho, 2000" startWordPosition="3005" endWordPosition="3008">‘marketing’&amp;work’.c1=C] \np:[A,B,C] . . wear:sin-ta wear:ssu-ta wear:ip-ta wear:cha-ta wear:tti-ta wear:cis-ta . . The second method needs co-occurrence information, but no additional lexical entries. And this method also requires an additional disambiguation process after the parsing to extract information on the collocated words. However, since co-occurrence information between the words can be automatically extracted from a general-purpose corpus, the construction of this information is thought to be relatively straightforward, compared to the construction of the semantic classifications. (Park and Cho, 2000; Lee et al., 1999) proposed to use the co-occurrence information during parsing and lexical selection. For example, in 1c, ‘wears’ is disambiguated into ‘sin-ta’ for the semantics of ‘shoes’ and the collocated words ‘old’ and ‘shoes’ is extracted during the parsing. Then the disambiguation module selects the preferred sense of ‘old’ through the computation of the similarity for the co-occurrence information. As a result, ‘old’ is correctly disambiguated into the target ‘nalk-ta’. 4.2 Representation of Lexical Entry In a CCG framework, all the levels of information, such as syntax, semantics, </context>
</contexts>
<marker>Park, Cho, 2000</marker>
<rawString>J. C. Park and H. J. Cho. 2000. Informed Parsing for Coordination with Combinatory Categorial Grammar. In COLING, pages 593–599.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Steedman</author>
</authors>
<title>Surface Structure and Interpretation. Number 30 in Linguistic Inquiry Monographs.</title>
<date>1996</date>
<publisher>MIT Press.</publisher>
<contexts>
<context position="20784" citStr="Steedman, 1996" startWordPosition="3240" endWordPosition="3241">s=‘���F&amp;quot;’&amp;C];old-C;E/np:[A,B,C];E). The lexical entry consists of a lexical item and its CCG category. The CCG category is a pair of the syntactic and semantic information that are interwoven in the following way. Elementary CCG (syntactic) categories include np and s, and CCG categories are recursively defined as either X1 or X\Y , where X and Y are also CCG categories, including elementary categories. Each elementary CCG (syntactic) category X is augmented with an appropriate semantic information Y and word disambiguation information Z so that the resulting form X : Y ; Z is a CCG category (Steedman, 1996). In our proposal, the semantic information is replaced with a suitable fragment of SQL, with slots corresponding to Who wears a brown coat ? np:[person,_,_];_ (s:[A,B,C];wear@B;AE;BE np:[_,ip-ta,color=kal-sayk \np:[A,_,_];AE)/np:[_,B,C];BE &amp;body=oy-twu];_ &gt; s:[A,ip-ta,color=kal-sayk&amp;body=oy-twu];wear@ip-ta;AE;_ \np:[A,_,_];AE &lt; s:[person,ip-ta,color=kal-sayk&amp;body=oy-twu];wear@ip-ta;_ Figure 3: A Derivation of the Query 1c and a Portion of the Translation Dictionary SELECT, FROM, and WHERE clauses in SQL, bracketed by ‘[’ and ‘]’. For example, in entry 7a, ‘coat’ is assigned the syntactic cate</context>
</contexts>
<marker>Steedman, 1996</marker>
<rawString>M. Steedman. 1996. Surface Structure and Interpretation. Number 30 in Linguistic Inquiry Monographs. MIT Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Steedman</author>
</authors>
<title>The Syntactic Process.</title>
<date>2000</date>
<publisher>MIT Press.</publisher>
<contexts>
<context position="5321" citStr="Steedman, 2000" startWordPosition="872" endWordPosition="873">es in English and Korean with CCGs and argue that word selection problem must be resolved for multilingual query interpretation. Rule Rule Name (Symbol) X/Y Y —s X F/W Application (&gt;) Y X\Y —s X B/W Application (&lt;) X conj X —s X Coordination (&lt; 0n &gt;) X/Y Y/Z —s X/Z F/W Composition (&gt; B) Y \Z X\Y —s X\Z B/W Composition (&lt; B) X/Y Y \Z —s X\Z F/W Crossed Comp. (&gt; Bx) X —s T/(T \X) F/W Type Raising (&gt; T) X —s T \(T/X) B/W Type Raising (&lt; T) Table 2: CCG Rules for Korean 2.1 Combinatory Categorial Grammar Combinatory Categorial Grammars (CCGs) are combinatory extensions to the categorial grammars (Steedman, 2000). CCGs are among the lexicalized grammars, such as linear indexed grammars and tree adjoining grammars, and are generally known to provide a wide linguistic coverage and a way of processing sentences incrementally. Table 2 shows the CCG reduction rules proposed for Korean (Park and Cho, 2000). (Steedman, 2000) suggested the reduction rules for English which include backward crossed composition and backward substitution. We adopt this rule set for the processing of the queries in English. (2) Who wears old shoes? np (s\np)/np np/np np np s\np &lt; Example 2 shows a syntactic derivation for an exam</context>
<context position="6809" citStr="Steedman, 2000" startWordPosition="1138" endWordPosition="1139">he first np and the directionality is indicated by the backslash \, that is, to the left), to give rise to the phrase of category s. Such a computation is done by simple function application. Example 3 shows the CCG derivation for a query with coordination. (3) Who wears old shoes and a brown coat? np (s\np)/np np conj np np &gt; s\np &lt; s &gt; &gt; s &lt;,Dn&gt; In addition to function application utilized in examples 2 and 3, CCGs use rules for a limited set of combinators such as B (function composition), T (type raising), and S (function substitution) to model natural language. The reader is referred to (Steedman, 2000) for further details. 2.2 Multilingual Database Interfaces There have been many proposals for NLDBs since the 1960’s3. In this section, we review some of the more recent ones. (Androutsopoulos et al., 1998; Nelken and Francez, 2000) focus on queries in English with temporal expressions, with a specialized semantic representation language that can handle temporality. Examples are shown below. (4) (a) Did any flight circle while runway 2 was open? (b) Which companies serviced BA737 in 1990? (c) During which years did Mary work in marketing? The system in (Klein et al., 1998) interprets noun phra</context>
<context position="13232" citStr="Steedman, 2000" startWordPosition="2160" endWordPosition="2161"> module using lexicalized grammars such as CCG. In this case, the construction of a domain-dependent lexicon can be a problem, but it can be resolved to some extent with an automatic construction method. The point (c) is difficult to address, since the translation without an intermediate representation usually is done in a single module. The inference module, however, can be complemented by disambiguation using co-occurrence information (Park and Cho, 2000) and disambiguation of domaindependent word senses with consideration for the context-dependent information such as information structure (Steedman, 2000). (Nelken and Francez, 2000) use an intermediate representation because the compositional construction of formulae during parsing becomes easier. However, we show that database queries can be interpreted compositionally during parsing without such an intermediate representation through direct translation. 3.2 Translation to an Intermediate Representation While our approach does not make use of an intermediate representation, the CCG framework itself allows queries to be interpreted into an intermediate representation. Figure 1 shows the translation process from the query 6a to the form 6b whic</context>
</contexts>
<marker>Steedman, 2000</marker>
<rawString>M. Steedman. 2000. The Syntactic Process. MIT Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>C A Thompson</author>
<author>R J Mooney</author>
</authors>
<title>Automatic Construction of Semantic Lexicons for Learning Natural Language Interfaces. In</title>
<date>1999</date>
<booktitle>AAAI/IAAI,</booktitle>
<pages>487--493</pages>
<contexts>
<context position="7851" citStr="Thompson and Mooney, 1999" startWordPosition="1303" endWordPosition="1306">t circle while runway 2 was open? (b) Which companies serviced BA737 in 1990? (c) During which years did Mary work in marketing? The system in (Klein et al., 1998) interprets noun phrase queries such as 5 in German: (5) Ersatzzeiten wegen Kindererziehung (Exemption times because of child raising) While the system can analyze noun phrases with various adverbial phrases, it is not reported to handle more complex noun phrase queries such as those with subordinate or coordinate constructions. None of these work deals with multilingual issues. Nor is there much related work in the field of NLDBs. (Thompson and Mooney, 1999) presents a system that automatically constructs the lexicon for NLDBs, in various languages such as English, Spanish, Japanese, and Turkish, which represents the lexical entries with a pair of the phrases and the corresponding semantic representation in first-order logic. Since the semantic representation for lexical items is determined using the frequency of the general terms of the semantic representation in the corpus made up of the query sentences annotated by their logical representation, the system makes it difficult to incorporate various linguistic considerations on natural language. </context>
</contexts>
<marker>Thompson, Mooney, 1999</marker>
<rawString>C. A. Thompson and R. J. Mooney. 1999. Automatic Construction of Semantic Lexicons for Learning Natural Language Interfaces. In AAAI/IAAI, pages 487–493.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D Toman</author>
</authors>
<title>Point vs. Interval-based Query Languages for Temporal Databases.</title>
<date>1996</date>
<booktitle>In Proceedings of the ACM SIGACT-SIGMOD-SIGART PODS,</booktitle>
<pages>58--67</pages>
<contexts>
<context position="9503" citStr="Toman, 1996" startWordPosition="1553" endWordPosition="1554">ez, 2000). 3.1 Indirect vs. Direct Translation Most NLDBs use an intermediate representation which does not make use of expressions that correspond directly to real database objects. The intermediate representations are usually notated as logic expressions such as a quasi-logical form (Klein et al., 1998) and a customized language (Androutsopoulos et al., 1998; Nelken and Francez, 2000). These representations provide a way to translate indirectly to the target database languages. For example, query 6a is translated into 6b with the intermediate representation LAtten (Nelken and Francez, 1999; Toman, 1996), and into 6c with the SQL/Temporal expressions (Nelken and Francez, 2000). (6) (a) During which years did Mary work in marketing? (b) year(I) A 71J(work(marg, marketing; J) A J C past A J C I (c) NONSEQUENCED VALIDTIME SELECT DISTINCT a0.c1 AS c1 FROM work’ AS a1,year’ AS a0 WHERE VALIDTIME(a0) contains VALIDTIME(a1) AND a1.c1 = ‘mary’ AND a1.c2 = ‘marketing’ AND PERIOD(TIMESTAMP ‘beginning’, TIMESTAMP ‘now’) contains VALIDTIME(a1) The translation using an intermediate representation has several advantages, including (a) the availability of an independent linguistic frontend, (b) the separati</context>
</contexts>
<marker>Toman, 1996</marker>
<rawString>D. Toman. 1996. Point vs. Interval-based Query Languages for Temporal Databases. In Proceedings of the ACM SIGACT-SIGMOD-SIGART PODS, pages 58–67.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>