<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<title confidence="0.995506">
A UNIFICATION-BASED SEMANTIC INTERPRETATION
FOR COORDINATE CONSTRUCTS
</title>
<author confidence="0.998678">
Jong C. Park
</author>
<affiliation confidence="0.99488">
University of Pennsylvania
Computer and Information Science
</affiliation>
<address confidence="0.9360895">
200 South 33rd Street
Philadephia, PA 19104-6389 USA
</address>
<email confidence="0.479403">
Internet: parka/line . cis . upenn edu
</email>
<sectionHeader confidence="0.986275" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999627375">
This paper shows that a first-order unification-
based semantic interpretation for various coordi-
nate constructs is possible without an explicit use
of lambda expressions if we slightly modify the
standard Montagovian semantics of coordination.
This modification, along with partial execution,
completely eliminates the lambda reduction steps
during semantic interpretation.
</bodyText>
<sectionHeader confidence="0.999066" genericHeader="keywords">
1 Introduction
</sectionHeader>
<bodyText confidence="0.99871925">
Combinatory Categorial Grammar (CCG) has
been offered as a theory of coordination in nat-
ural language (Steedman [1990]). It has usually
been implemented in languages based on first or-
der unification. Moore [1989] however has pointed
out that coordination presents problems for first-
order unification-based semantic interpretation.
We show that it is possible to get over the problem
by compiling the lambda reduction steps that are
associated with coordination in the lexicon. We
show how our first-order unification handles the
following examples of coordinate constructs.
</bodyText>
<listItem confidence="0.9323105">
(1.1) Harry walks and every farmer walks.
(1.2) A farmer walks and talks.
(1.3) A farmer and every senator talk.
(1.4) Harry finds and a woman cooks a mushroom.
(1.5) Mary gives every dog a bone and some
policeman a flower.
</listItem>
<bodyText confidence="0.999752210526316">
We will first start with an illustration of why
standard Montagovian semantics of coordination
cannot be immediately rendered into a first-order
unification strategy. The lexicon must contain
multiple entries for the single lexical item &amp;quot;and&amp;quot;,
since only like categories are supposed to conjoin.
For example, the lexical entry for &amp;quot;and&amp;quot; in (1.1)
specifies the constraint that the lexical item should
expect on both sides sentences to give a sentence.
Moore [1989] predicts that a unification-based
semantic interpretation for sentences which in-
volve for example noun phrase coordination won&apos;t
be possible without an explicit use of lambda
expressions, though there are cases where some
lambda expressions can be eliminated by di-
rectly assigning values to variables embedded in
a logical-form expression. The problematic exam-
ple is shown in (1.6), where proper noun subjects
are conjoined.
</bodyText>
<listItem confidence="0.742358">
(1.6) john and bill walk.
</listItem>
<bodyText confidence="0.968347142857143">
The argument is that if we do not change the se-
mantics of &amp;quot;john&amp;quot; from j to AP.P(j), where P is a
second order variable for property in the Montago-
vian sensel , then the single predicate AX . walk (X)
should accommodate two different constants j and
b in a single variable X at the same time. Since
the unification simply blocks in this case, the ar-
gument goes, we need to use higher order lambda
expressions such as AP P ( j ) or AP • P (b) , which
when conjoined together, will yield semantics for
e.g. &amp;quot;john and bill&amp;quot; as
AP•CP(j) &amp; P(b)) .
Combined finally with the predicate, this will re-
sult in the semantics (1.7), after lambda reduction.
</bodyText>
<equation confidence="0.451648">
(1.7) walk(j) &amp; walk(b)
</equation>
<bodyText confidence="0.990827666666667">
&apos;Montague [1974]. APvP(j) to be exact, taking in-
tensionality into account. The semantics of the predi-
cate &amp;quot;walks&amp;quot; will then be (A Mt. valk(X)).
</bodyText>
<page confidence="0.997604">
209
</page>
<bodyText confidence="0.9996535">
Although Moore did not use quantified noun
phrases to illustrate the point, his observation gen-
eralizes straightforwardly to the sentence (1.3). In
this case, the semantics of &amp;quot;and&amp;quot;, &amp;quot;every&amp;quot; and
&amp;quot;some&amp;quot; (or &amp;quot;a&amp;quot;) will be (1.8) a, b, and c, respec-
tively.
</bodyText>
<listItem confidence="0.953641333333333">
(1.8) (a) AQ.AR.Ap.(Q(p) &amp; R(P))
(b) AS.AP&apos;.forall(X,S(X)=&gt;P1(X))
(c) As.AP&apos;&apos; .exists(X,S(X)&amp;P&apos; &apos; (X))
</listItem>
<bodyText confidence="0.957194944444445">
Thus, after four lambda reduction steps, one for
each of Q, R, p, and P&apos; &apos;,the the semantics of &amp;quot;a farmer
and every senator&amp;quot; will be
AP.(exists(X,farmer(X)&amp;P(X)) &amp;
forall(X,senator(X)=&gt;P(X))) ,
as desired.
Moore&apos;s paper showed how lambda reduction
could be avoided by performing lambda reduction
steps at compile time, by utilizing the lexicon, in-
stead of doing them at run time. Consider again
(1.8a). The reason why this formulation requires
four subsequent lambda reduction steps, not three,
is that the property p should be applied to each
of the conjuncts, requiring two separate lambda
reduction steps. Suppose that we try to eliminate
these two lambda reduction steps at compile time
by making the argument of the property p explicit
in the lexicon, following the semantics (1.9).
</bodyText>
<equation confidence="0.943498">
(1.9) AQ.AR.AP.(Q(Ax.P(x)) &amp; R(Ax.p(x)))
</equation>
<bodyText confidence="0.999873368421053">
The first-order variable X ranges over the set of
individuals, and the hope is that after lambda re-
duction it will be bound by the quantifiers, such
as forall, embedded in the expressions denoted
by the variables Q and R. Since the same variable
is used for both constructs, however, (1.9) works
only for pairs of quantified noun phrases, which
don&apos;t provide constants, but not for pairs involv-
ing proper nouns, which do provide constants. In-
cidentally, this problem is particular to a unifica-
tion approach, and there is nothing wrong with the
semantics (1.9), which is equivalent to (1.8a). This
unification problem cannot be avoided by having
two distinct variables Y and Z as in (1.10) either,
since there is only one source for the predicate
property for the coordinate noun phrases, thus
there is no way to isolate the argument of the pred-
icate and assign distinct variables for it at compile
time.
</bodyText>
<equation confidence="0.651288">
(1.10) AQ.AR.AP.(Q(AY.P(Y)) &amp; R(AZ.P(Z)))
</equation>
<bodyText confidence="0.999657333333333">
The way we propose to eliminate the gap be-
tween (1.9) and (1.10) is to introduce some spuri-
ous binding which can always be removed subse-
quently. The suggestion then is to use (1.11) for
the semantics of &amp;quot;and&amp;quot; for noun phrase conjunc-
tion.
</bodyText>
<listItem confidence="0.661834">
(1.11) Semantics of &amp;quot;and&amp;quot; for NP Conjunction:
</listItem>
<bodyText confidence="0.973151931818182">
AQ.AR.AP.(Q(AY.exists(X,X=YtiP(X)))
&amp; ROZ.exists(X,X=Z&amp;P(X))))
This satisfies, we believe, the two requirements,
one that the predicate have the same form, the
other that the variables for each conjunct be kept
distinct, at the same time. The rest of the lambda
expressions can be eliminated by using the notion
of partial execution (Pereira &amp; Shieber [1987]).
Details will be shown in Section 3, along with some
&amp;quot;more immediate but faulty&amp;quot; solutions. It is sur-
prising that the same idea can be applied to some
fairly complicated examples as (1.5), and we be-
lieve that the solution proposed is quite general.
In order to show how the idea works, we use a
first-order Montagovian Intensional Logic (Jowsey
[1987]; Jowsey [1990]) for a semantics. We apply
the proposal to CCG, but it could equally well
be applied to any lexicon based grammar formal-
ism. We explain briefly how a CCG works in the
first part of Section 2. As for the semantics, noth-
ing hinges on a particular choice, and in fact the
code we show is devoid of some crucial features
of Jowsey&apos;s semantics, such as indices for situ-
ations or sortal constraints for variable binding.
We present the version of Jowsey&apos;s semantics that
we adopt for our purposes in the second part of
Section 2, mainly for completeness. In Section 3,
each of the cases in (1.1) through (1.5), or varia-
tions thereof, is accounted for by encoding lexical
entries of &amp;quot;and&amp;quot;, although only (1.3) and (1.5) de-
pend crucially on the technique.
We have a few words for the organization of
a semantic interpretation system we are assum-
ing in this paper. We imagine that it consists of
two levels, where the second level takes a scope-
neutral logical form to produce every possible, gen-
uinely ambiguous, scoping possibilities in paral-
lel and the first level produces this scope-neutral
logical form from the source sentence. We as-
sume that our second level, which we leave for
future research, will not be very different from
the one in Hobbs Az Shieber [1987] or Pereira
Shieber [1987]. The goal of this paper is to
show how the scope-neutral logical forms are de-
</bodyText>
<page confidence="0.988383">
210
</page>
<bodyText confidence="0.999989666666667">
rived from natural language sentences with co-
ordinate constructs. Our &amp;quot;scope-neutral&amp;quot; logical
form, which we call &amp;quot;canonical&amp;quot; logical form (cis),
syntactically reflects derivation-dependent order of
quantifiers since they are derived by a derivation-
dependent sequence of combination. We empha-
size that this derivation-dependence is an artifact
of our illustrative example, and that it is not an
inherent consequence of our technique.
</bodyText>
<sectionHeader confidence="0.956983" genericHeader="introduction">
2 Background Formalisms
</sectionHeader>
<subsectionHeader confidence="0.527105">
A Combinatory Categorial Grammar
</subsectionHeader>
<bodyText confidence="0.998985857142857">
The minimal version of CCG we need to process
our examples contains four reduction rules, (2.1)
through (2.4), and two type raising rules, (2.5)
and (2.6), along with a lexicon where each lexical
item is assigned one or more categories. For the
reasons why we need these, the reader is referred
to Steedman [1990].
</bodyText>
<listItem confidence="0.999917666666667">
(2.1) Function Application (&gt;): X/Y Y =&gt; X
(2.2) Function Application (&lt;): Y X\Y =&gt; X
(2.3) Function Composition (&gt;B): X/Y Y/Z =&gt; X/Z2
(2.4) Function Composition (&lt;B): Y\Z X \Y =&gt; X\Z
(2.5) Type Raising, Subject (&gt;T): np =&gt; sgs\np)
(2.6) Type Raising, Backward (&lt;T): np =&gt; x\(x/np)
</listItem>
<bodyText confidence="0.999766909090909">
The present fragment is restricted to the basic
categories n, np and s.3 Derived categories, or
categories, are recursively defined to be basic cat-
egories combined by directional symbols (/ or \).
Given a category X/Y or X \ Y, we call X the range
category and Y the domain category. Parentheses
may be used to change the left-associative default.
The semantics part to be explained shortly, (2.7a)
through (2.7e) show examples of a common noun,
a proper noun, a quantifier, an intransitive verb,
a sentential conjunction, respectively.
</bodyText>
<listItem confidence="0.994980333333333">
(2.7) Sample Lexicon
(a) cat(farmer, n:X-farmer(X)).
(b) cat(harry, np:A1-(11-13)-13).
(c) cat(every, np:(X-A)-(X-Brforall(X,A=&gt;13)
(d) cat (walks, s:S\np:(X-A)-(X-walk(X))-S).
(e) cat(and, (s: (S1 &amp; S2)\s:S1)/s:S2).4
</listItem>
<sectionHeader confidence="0.516376" genericHeader="method">
A First-Order Montague Semantics
</sectionHeader>
<bodyText confidence="0.999954219512195">
In this section, we will focus on describing how
Jowsey has arrived at the first-order formalism
that we adopt for our purposes, and for further
details, the reader is referred to Jowsey [1987] and
Jowsey [1990]. The reader can safely skip this sec-
tion on a first reading since the semantics we use
for presentation in Section 3 lacks many of the new
features in this section.
Montague&apos;s PTQ analysis (Dowty, Wall &amp; Pe-
ters [1981]) defines an intensional logic with the
basic types e, t and s, where e is the type of en-
tities, t the type of truth values and $ the type
of indices. Derived types &lt;a,b&gt; and &lt;s ,a&gt; are re-
cursively defined over the basic types. A name,
which is of type e, denotes an individual; individ-
ual concepts are names relativized over indices, or
functions from indices to the set of individuals. In-
dividual concepts are of type &lt;s,e&gt;. A predicate
denotes a set of individuals, or a (characteristic)
function from the set of individuals to truth val-
ues. Properties are intensional predicates, or func-
tions from indices to the characteristic functions.
Properties are of type &lt;s,&lt;e,t&gt;&gt;, or &lt;e,&lt;s,t&gt;&gt;.
A formula denotes a truth value, and propositions
are intensional formulas, thus of type &lt;s , t&gt;.
By excluding individual concepts, we can en-
sure that only truth values are relativized over in-
dices, and thus a modal (omega-order) logic will
suffice to capture the semantics. For this purpose,
Jowsey defines two basic types e and o, where o
corresponds to the type &lt;s ,t&gt;, and then he de-
fines derived types &lt;a,b&gt;, where a and b range
over basic types and derived types. The logic is
then made into first-order by relying on a fixed
number of sorts and eliminating recursively de-
fined types. These sorts include e, s, o, p and
q, which correspond to the types e, s, &lt;s,t&gt;,
&lt;e,&lt;s,t&gt;&gt; and &lt;&lt;e,&lt;s,t»,&lt;s,t&gt;&gt; respectively
in an omega-order logic.
For a full exposition of the logic, the reader is
referred to Jowsey [1990]. For our presentation, we
</bodyText>
<footnote confidence="0.9748596">
2In Steedman [1990], this rule is conditioned by Z
s\np in order to prevent such constructs as &amp;quot;[Harry]
but [I doubt whether Fred] went home&amp;quot; or &amp;quot;*[I think
that Fred] and [Harry] went home.&amp;quot;
3For simplicity, we do not show variables for gen-
der, case, tense, and number. Larger fragment would
include pp, etc.
4The category (5 \ s)/s has the potential danger
of allowing the following construct, if combined with
the rule &lt;B: &amp;quot;*Mary finds a man who [walks],vip
[and he talks]&amp;quot;.&amp;quot; The suggestion in Steedman [1990]
is to add a new pair of reduction rules, X [X] =&gt; X and
conj X =&gt; [X]„, together with the category of &amp;quot;and&amp;quot;
as conj. Thus, the category of &amp;quot;and harry talks&amp;quot; is
now [s]„, blocking the unwanted combination.
</footnote>
<page confidence="0.996884">
211
</page>
<bodyText confidence="0.99911475">
will simplify the semantics and drop intensional-
ity altogether. We also drop the sortal constraint,
since our examples do not include belief operators
and hence the only variables left are of sort e.
</bodyText>
<sectionHeader confidence="0.96598" genericHeader="method">
3 A First-Order Unification
</sectionHeader>
<bodyText confidence="0.99791">
We will follow the standard technique of combin-
ing the syntactic information and the semantic
information as in (3.1), where up-arrow symbols
(&amp;quot;)6 are used to give structures to the seman-
tic information for partial execution (Pereira Si
Shieber [1987]), which has the effect of perform-
ing some lambda reduction steps at compile time.
</bodyText>
<figure confidence="0.630184333333333">
(3.1) Basic Categories
(a) n: (do-do)
(b) np: (do&amp;quot; do)&amp;quot; (do-ro)&amp;quot;so
</figure>
<listItem confidence="0.750143">
(c) s : so
</listItem>
<bodyText confidence="0.979407206896552">
The term do in (3.1a) and (3.1b) encodes domain
constraint for the variable de. Likewise, the term
ro in (3.1b) specifies range constraint for de. The
term so in (3.1b) and (3.1c) encodes the sentential
constraint associated with a sentence. In order to
avoid possible confusion, we shall henceforth call
categories without semantic information &amp;quot;syntac-
tic&amp;quot; categories.
In this section, we will develop lexical entries for
those coordinate constructs in (1.1) through (1.5),
or variations thereof. For each case, we will start
with &amp;quot;more immediate but faulty&amp;quot; solutions and
present what we believe to be the correct solution
in the last. (For those who want to skip to the
correct lexical entries for each of the cases, they
are the ones not commented out with %.) We have
seen the lexical entry for sentential conjunction in
(2.7d). The lexical entry for predicate conjunction
can be similarly encoded, as in (3.2).
(3.2) Lexical Entry for Predicate Conjunction
cat(and, ((s:S\np:A-(X-(131 &amp; B2))-S)
\(s:Sl\np:A-(X-B1)-S1))
gs:S2\np:A-(X-B2)-S2)).
When the conjoined predicates are combined with
the subject noun phrase, the subject NP provides
only the domain constraint, through A in the first
line. The range constraints in the last two NP
categories guarantee that El and B2 will bear the
same variable X in them, so that they can be safely
</bodyText>
<footnote confidence="0.7622295">
6Not to be confused with Montague&apos;s haCek sym-
bol, `^s.
</footnote>
<bodyText confidence="0.91593675">
put as the range constraint of the first NP cate-
gory. The CLF for (1.2) from (3.2) is shown in
(3.3).
(3.3) exists(Xl,farmer(Xl)gualk(X1)&amp;
talk(X1)))
Let us turn to noun phrase coordination, e.g.,
(1.3). The first try, on the model of predicate con-
junction, would be:
(3.4) Lexical Entry for NP Conjunction:
%cat(and, (np:A&amp;quot;(X-D)-(B &amp; C)
\np:A1-(Y-D)-B)
/np:A2-(Z^D)-C).
The intention is to collect the two domain con-
straints via Al and A2, to get the range constraint
from D in the first line, and then to combine them
by joining the two sentential constraints B and C
of the domain categories. This idea however does
not work, since the variables Y and Z do not ap-
pear in the range constraint D. As a result, (3.4)
will give the following ill-formed CLF for (1.3).
</bodyText>
<equation confidence="0.5163625">
% exists(Xl,farmer(X1)&amp;talk(X3))
% &amp;foral1(X2,senator(X2)=&gt;talk(X3))
</equation>
<bodyText confidence="0.990714">
We therefore need to use distinct variables in place
of D for the two range constraints which will have
the same predicate symbol for their range cate-
gories. Using the Prolog predicate univ (`=..&apos;),
we can correct (3.4) as follows:6
</bodyText>
<equation confidence="0.393903428571429">
(3.5) Lexical Entry for NP Conjunction:
%cat(and, (np:A-(X^D)&amp;quot;(B &amp; C)
\np:A1-(Y-B1)-13)
/np:A2-(Z-C1)-C) :-
% D =.. [Pred, X],
B1 =.. [Pred,
Cl =.. [Pred, Z] .
</equation>
<bodyText confidence="0.999423375">
This is an explicit case of a first-order simulation
of second order variables. Unfortunately, this does
not work, for several reasons.7 First, this handles
predicates of arity 1 only, and we need to know
the type of each argument if we want to provide
a different category for each predicate of different
arity. Second, this can not be combined with pred-
icate coordination, for example, such as &amp;quot;john and
</bodyText>
<footnote confidence="0.662621285714286">
6D =.. CP ,X] succeeds if D is unifiable with P(X).
70ne implementation-dependent reason is that the
Prolog requires at least one of the two variables D and
Pred to be already instantiated for the univ to work.
This can not be expected when the noun phrase con-
junction is being processed, since we don&apos;t yet know
what predicate(s) will follow.
</footnote>
<page confidence="0.997552">
212
</page>
<bodyText confidence="0.890328869565217">
a woman walk and talk,&amp;quot; or some complex verbs
that may require several predicates, such as &amp;quot;be-
lieves&amp;quot;, since it assumes only one predicate for the
range constraint.
The solution we propose is to use the revised
semantics of &amp;quot;and&amp;quot; in (1.11) instead. That is, we
expect (3.6) from (1.3):
(3.6) Proposed Semantics of (1.3):
exists(X1,farmer(X1)
k(exists(X2,(X2=X1)ftalk(X2))))
kforall(X3,senator(X3)
=&gt;(exists(X2,(X2=X3)&amp;talk(X2))))
We need to distinguish the variable X2 in the
second line from the variable X2 in the fourth
line, via something like a conversion, since in the
present form, the Prolog will consider them as the
same, while they are under distinct quantifiers.
In fact, since we are separating the semantic in-
terpretation into two levels, we can further pro-
cess the CLF at the second semantic interpretation
level to eliminate those spurious bindings such as
exists(X,(X=u)&amp;u) along with variable renaming
to derive the logical form (3.7) from (3.6):
</bodyText>
<figure confidence="0.8671155">
(3.7) exists(X1,farmer(X1)&amp;talk(X1))
kforall(X3,senator(X3)=&gt;talk(X3))
(3.8) produces the CLF (3.6) for (1.3).
(3.8) Lexical Entry for NP Conjunction:
cat(and,
(np:A-(X-D)-(13 &amp; C)
\np:A1-(7-(exists(X,(X=Y)&amp;D)))-8)
/np:A2-(Z-(exists(X,(X=Z)&amp;D)))-C).
</figure>
<bodyText confidence="0.879642111111111">
The reason why we are able to maintain in the
two domain categories two different forms of range
contraints is that the only place that will unify
with the actual range constraint, i.e., the predi-
cate, is the range constraint part of the range cat-
egory only. We note in passing that Jowsey pro-
vided yet another approach to noun phrase coordi-
nation, a generalized version of his idea as shown
below.
(3.8a) Lexical Entry for NP Conjunction:
cat(and,
(np:(X&amp;quot;A)-(X-D)-B
\np:(Y-A1)-(Y&amp;quot;C)-B)
/np:(Z-A2)-(Z-fora11(X,(X=Y v X=Z)=&gt;D))-C).
For example, (3.8a) will give the following seman-
tics for (1.3).
exists(X1,farmer(X1)&amp;forall(X2,senator(X2)
=&gt;forall(X3,(X3=X1 v X3=X2)=&gt;ta1k(X3))))
This approach has its limits, however, as indicated
in the footnote 8.
We now turn to some of the non-standard con-
stituent coordination. First, consider (1.4), which
is an instance of Right Node Raising (RNR). The
CCG syntactic category of the conjunction &amp;quot;and&amp;quot;
in this case is (C\C)/C, where C is s/np. (3.9)
shows one derivation, among others, for (1.4). The
syntactic category of &amp;quot;finds&amp;quot; is (s\np)/np.
</bodyText>
<figure confidence="0.775440764705882">
(3.9) One derivation for (1.4).
harry finds and a woman cooks a mushroom
&gt;T &gt;T
sgs\np) s/(s\np) np
&gt;8 &gt;8
s/np s/np
(s/np)\(s/np)
s/np
Assuming that the category of &amp;quot;finds&amp;quot; is as follows,
(3.10) Lexical Entry for &amp;quot;finds&amp;quot;:
cat(finds, ((s:S\np:A1-(X&amp;quot;A)-S)
/np:A2-(Y-find(X,Y))-A)).
here is the first try for the RNR &amp;quot;and.&amp;quot;
(3.11) Lexical Entry for RNR Conjunction:
9Ocat(and, ((s:S/np:A-(X-(81&amp;82))-51)
\(s:S/np:A-(X-81)-S1)
9; gs:S3/np:A-(X-82)-S2).
</figure>
<bodyText confidence="0.969573307692308">
For example, (3.11) will produce the CLF (3.12)
for the sentence &amp;quot;harry finds and mary cooks a
mushroom.&amp;quot;
(3.12) exists(X1,mushroom(X1)kfind(h1X1)k
cook(m,X1))
However, this works only for pairs of proper nouns.
For example, for the sentence &amp;quot;every man finds
and a woman cooks a mushroom,&amp;quot; it will give the
ill-formed CLF (3.13) where the domain constraint
for the noun phrase &amp;quot;a woman&amp;quot; is gone and X3
is therefore unbound. This happens because the
sentential constraint S2 is not utilized for the final
sentential constraint.
</bodyText>
<footnote confidence="0.609385666666667">
(3.13) %forall(X1,man(X1)=&gt;exists(X2,
Vomushroom(X2)kfind(X1,X2)
%&amp;cook(X3,X2)))
</footnote>
<page confidence="0.998636">
213
</page>
<bodyText confidence="0.9973078">
Putting the two sentential constraints Si and S2
together as follows does not work at all, since the
relation between S and SO is completely undefined,
unlike the ones between Si and B1 and between S2
and 82.
</bodyText>
<figure confidence="0.907946083333333">
%cat(and, ((s:S/np:A-(X-(S1&amp;S2))-S0)
96 \(s:S1/np:A1-(X-B1)-81))
gs:S2/np:A2-(X-82)-82)).
This problem is corrected in (3.14), which will pro-
duce the CLF (3.15) for (1.4):
(3.14) Lexical Entry for RNR Conjunction.
cat(and, ((s:S/np:A-(X-(S1&amp;S2))-S)
\(s:S1/11p:A1-(X-81)-81))
gs:S2/np:A2-(X-B2)^82)).
(3.15) Semantics of (1.4) from (3.14):
exists(Xl,mushroom(X1)&amp;find(h,X1))
&amp;exists(X2,woman(X2)&amp;cook(X2,X1)))
</figure>
<bodyText confidence="0.933588714285714">
(1.5) shows another case of non-standard con-
stituent coordination, which we will call an in-
stance of Left Node Raising (LNR). The syntactic
category of &amp;quot;and&amp;quot; for LNR is (C\C)/C where C
is (s\np)\(((s\np)/np)/np). (3.16) shows one
syntactic derivation for (1.5). The syntactic cate-
gory of &amp;quot;gives&amp;quot; is ((s\np)/np)/np.
</bodyText>
<figure confidence="0.967940555555556">
(3.16) One derivation for (1.5), fragment.
every dog a bone
&lt;T &lt;T
((s\np)/np)\(((s\np)/np)/np)
(s\np)\((s\np)/np)
&lt;8
(s\np)\(((s\np)/np)/np)
Again, we assume that the category of &amp;quot;gives&amp;quot; is:
(3.17) Lexical Entry for &amp;quot;gives&amp;quot;:
cat(gives, ((s:S1\np:A1-(X-S2)-S1)
/np:A2-(Y&amp;quot;give(X,Z,Y))-8)
/np:A3-(Z-B)-S2).
(3.18) shows the first try for the lexical entry.8
(3.18) Lexical Entry for LNR Conjunction.
%cat(and,
% (((s:_\np:_)
9)S \(((s:S\np:(X-A)-(X-(S4 &amp; S6))-S)
9E /np:A1-(Y-B)-S1)/np:A2-(Z-S1)-S2))
</figure>
<footnote confidence="0.9965142">
8In this case, we can no longer use the disjunctive
technique such as forall(X1,(X1= v X1= )=&gt;give(
,X1, )) for the CLF, since X1 is now a pair. The prob-
lem gets worse when the conjoined pairs do not have
the same type of quantifiers, as in (1.5).
</footnote>
<figure confidence="0.98372">
% \((s:_\np:_)\(((s:_\11p:_)
/np:A3-(Y-B)-S3)
/np:A4-(Z-S3)-S4)))
% /((s:_\np:_)\(((s:_\np:_)
/np:A5-(Y-B)-S5)
/np:A6-(Z-S5)-S6))).
It gives the CLF (3.19) for (1.5):
(3.19) Semantics of (1.5) from (3.18):
forall(X1,dog(X1)=&gt;exists(X2,bone(X2)
&amp;give(m,X1,X2)))&amp;exists(X1,policeman(X1)
&amp;exists(X2,flower(X2)&amp;give(m,X1,X2)))
</figure>
<figureCaption confidence="0.870042777777778">
Unfortunately, (3.18) favors quantified nouns too
much, so that when any proper noun is involved in
the conjunction the constant for the proper noun
will appear incorrectly in the two sentential con-
straints at the same time. It seems that the only
way to resolve this problem is to create four vari-
ables, Yl, Y2, Z1 and Z2, at the semantics level,
similar to idea in (1.11). (3.20) implements this
proposal.
</figureCaption>
<figure confidence="0.982367259259259">
(3.20) Lexical Entry for LNR Conjunction.
cat (and,
(((s:_\np:_)
\(((s:S
\np:(X-A)-(X-(S4 &amp; S6))-S)
/np:A1-(Y-B)-S1)
/np:A2-(Z-S1)-S2))
\((s:_\np:_)
\(((s:_\np:_)
/np:A3-(Y1-
(erists(Y,(Y=T1)&amp;B)))-S3)
/np:
A4-(Z1-(exists(Z,(Z=Z1)163)))-S4)))
/((s:_\np:_)
\(((s:_\np:_)
lap:
A5-(Y2-(exists(Y,(Y=Y2)&amp;8)))-S5)
lap:
A6-(Z2-exists(Z,(Z=Z2)865)))-S6))).
(3.20) will give the CLF (3.21) for (1.5).
(3.21) Semantics of (1.5) from (3.20):
forall(X1,dog(X1)=&gt;exists(X2,X2=X1
&amp;exists(X3,bone(X3)&amp;exists(X4,X4=X3
&amp;give(m,X2,X4)))))
&amp;exists(X1,policeman(X1)&amp;exists(X2,X2=X1
&amp;exists(X3,flower(X3)&amp;exists(X4,X4=X3
&amp;give(m,X2,X4)))))
</figure>
<bodyText confidence="0.639945333333333">
Using the technique of eliminating spurious bind-
ings, (3.21) may be replaced by a logical form
(3.22):
</bodyText>
<page confidence="0.993756">
214
</page>
<table confidence="0.46452375">
(3.22) f orall (X1 , dog(X1)
=&gt;exists (X3 ,bone (X3)&amp;give (m, X1 , X3) ) )
&amp;exists (X1 , policeman(X1)
&amp;exists (X3 , flower(X3)&amp;give (m, X1 , X3) ) )
</table>
<bodyText confidence="0.882588947368421">
In addition to this, (3.20) gives the CLF (3.23) for
(3.24),
(3.23) exists (X1 , X1=j&amp;exists (X2 ,bone (X2)
&amp;exists (X3 , X3=X2 &amp;give(m, X1 , X3) ) ))
&amp;exists (X1 Xl=b&amp;exists (X2 , flower (X2)
&amp;exists (X3 , X3=X2 &amp;give (m, X1 , X3) ) ))
(3.24) mary gives john a bone and bill a flower.
for which no CLF could be derived if we were using
(3.18). This completes our demonstration for the
technique.
The natural question at this point is how many
lexical entries we need for the conjunct &amp;quot;and&amp;quot;. If
natural language makes every possible category
conjoinable, the number of entries should be in-
finite, since function composition can grow cate-
gories unboundedly, if it can grow them at all. We
predict that in natural language we can limit the
conjunction arity to n, where n is the maximum
arity in the lexicon.
</bodyText>
<sectionHeader confidence="0.999517" genericHeader="conclusions">
4 Conclusion
</sectionHeader>
<bodyText confidence="0.999973842105263">
The system described in this paper is implemented
in Quintus Prolog. We expect that the approach
can be extended to any lexicon-based grammar of
the same power as CCG if it provides means for
term unification.
The reason we choose to eliminate all the
lambda expressions is that it allows uniform treat-
ment within first-order unification, since Jowsey&apos;s
results suggest that in other respects natural lan-
guage semantics can be characterized in a first-
order logic. As an alternative, we could choose
to enforce uniform treatment within second-order
unification, using the idea for example in Na-
dathur &amp; Miller [1988]. Although we leave this
possibility for future research, we believe that this
option might turn out to be more appropriate in
terms of elegance of the approach. And the result-
ing conceptual clarity might be exploited to design
a schema for generating these entries for &amp;quot;and&amp;quot;.
</bodyText>
<sectionHeader confidence="0.999532" genericHeader="acknowledgments">
5 Acknowledgements
</sectionHeader>
<bodyText confidence="0.9999286">
Many thanks are due to Dr. Mark Steedman,
whose guidance immensely helped to improve the
quality of presentation, as well as the quality of
the content. I am also very grateful to Dr. Mark
Johnson, who suggested, and took pains of going
over in detail, another way of presenting the thesis,
that resulted in the material in the introduction
section. All errors are however entirely mine. The
author was supported by the ARO grant DAAL03-
89-C-0031PRI.
</bodyText>
<sectionHeader confidence="0.99916" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999452424242424">
David R. Dowty, Robert E. Wall &amp; Stanley Peters
[1981], Introduction to Montague Seman-
tics, D. Reidel Publishing Company.
Jerry R. Hobbs &amp; Stuart M. Shieber [January-
June 1987], &amp;quot;An Algorithm for Generat-
ing Quantifier Scopings,&amp;quot; Computational
Linguistics 13, 47-63.
Einar Jowsey [19871, &amp;quot;Montague Grammar and
First Order Logic,&amp;quot; Edinburgh Work-
ing Papers in Cognitive Science: Catego-
rial Grammar, Unification Grammar and
Parsing 1, 143-194.
Einar Jowsey
[1990], Constraining Montague Grammar
for Computational Applications, Doctoral
Dissertation, Department of Al, Univer-
sity of Edinburgh.
Richard Montague [1974], in Formal Philosophy,
Richmond H. Thomason, ed., Yale Uni-
versity Press.
Robert C. Moore [1989], &amp;quot;Unification-Based Se-
mantic Interpretation,&amp;quot; Proceedings of
the ACL.
Gopalan Nadathur &amp; Dale Miller [1988], &amp;quot;An
Overview of .A-Prolog,&amp;quot; Proceedings of the
Fifth International Logic Programming
Conference.
Fernando C.N. Pereira &amp; Stuart M. Shieber [1987],
Prolog and Natural-Language Ananlysis,
CSLI Lecture Notes Number 10.
Mark J. Steedman [April 1990], &amp;quot;Gapping as Con-
stituent Coordination,&amp;quot; Linguistics and
Philosophy 13, 207-263.
</reference>
<page confidence="0.999145">
215
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.633945">
<title confidence="0.9990115">A UNIFICATION-BASED SEMANTIC INTERPRETATION FOR COORDINATE CONSTRUCTS</title>
<author confidence="0.999969">Jong C Park</author>
<affiliation confidence="0.9763165">University of Pennsylvania Computer and Information Science</affiliation>
<address confidence="0.9975085">200 South 33rd Street Philadephia, PA 19104-6389 USA</address>
<email confidence="0.695321">cis.edu</email>
<abstract confidence="0.995038111111111">This paper shows that a first-order unificationbased semantic interpretation for various coordinate constructs is possible without an explicit use of lambda expressions if we slightly modify the standard Montagovian semantics of coordination. This modification, along with partial execution, completely eliminates the lambda reduction steps during semantic interpretation.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="false">
<authors>
<author>David R Dowty</author>
<author>Robert E Wall</author>
<author>Stanley</author>
</authors>
<title>Peters [1981], Introduction to Montague Semantics,</title>
<publisher>Reidel Publishing Company.</publisher>
<location>D.</location>
<marker>Dowty, Wall, Stanley, </marker>
<rawString>David R. Dowty, Robert E. Wall &amp; Stanley Peters [1981], Introduction to Montague Semantics, D. Reidel Publishing Company.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jerry R Hobbs</author>
<author>M Stuart</author>
</authors>
<title>Shieber [JanuaryJune</title>
<date>1987</date>
<journal>Computational Linguistics</journal>
<volume>13</volume>
<pages>47--63</pages>
<marker>Hobbs, Stuart, 1987</marker>
<rawString>Jerry R. Hobbs &amp; Stuart M. Shieber [JanuaryJune 1987], &amp;quot;An Algorithm for Generating Quantifier Scopings,&amp;quot; Computational Linguistics 13, 47-63.</rawString>
</citation>
<citation valid="false">
<authors>
<author>Einar Jowsey</author>
</authors>
<title>19871, &amp;quot;Montague Grammar and First Order Logic,&amp;quot; Edinburgh Working Papers in Cognitive Science: Categorial Grammar, Unification Grammar and Parsing</title>
<volume>1</volume>
<pages>143--194</pages>
<marker>Jowsey, </marker>
<rawString>Einar Jowsey [19871, &amp;quot;Montague Grammar and First Order Logic,&amp;quot; Edinburgh Working Papers in Cognitive Science: Categorial Grammar, Unification Grammar and Parsing 1, 143-194.</rawString>
</citation>
<citation valid="false">
<authors>
<author>Einar Jowsey</author>
</authors>
<title>[1990], Constraining Montague Grammar for Computational Applications,</title>
<institution>Doctoral Dissertation, Department of Al, University of Edinburgh.</institution>
<marker>Jowsey, </marker>
<rawString>Einar Jowsey [1990], Constraining Montague Grammar for Computational Applications, Doctoral Dissertation, Department of Al, University of Edinburgh.</rawString>
</citation>
<citation valid="false">
<authors>
<author>Richard Montague</author>
</authors>
<title>[1974], in Formal Philosophy,</title>
<editor>Richmond H. Thomason, ed.,</editor>
<publisher>Yale University Press.</publisher>
<marker>Montague, </marker>
<rawString>Richard Montague [1974], in Formal Philosophy, Richmond H. Thomason, ed., Yale University Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Robert C Moore</author>
</authors>
<title>Unification-Based Semantic Interpretation,&amp;quot;</title>
<date>1989</date>
<booktitle>Proceedings of the ACL.</booktitle>
<marker>Moore, 1989</marker>
<rawString>Robert C. Moore [1989], &amp;quot;Unification-Based Semantic Interpretation,&amp;quot; Proceedings of the ACL.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Gopalan Nadathur</author>
<author>Dale Miller</author>
</authors>
<title>An Overview of .A-Prolog,&amp;quot;</title>
<date>1988</date>
<booktitle>Proceedings of the Fifth International Logic Programming Conference.</booktitle>
<marker>Nadathur, Miller, 1988</marker>
<rawString>Gopalan Nadathur &amp; Dale Miller [1988], &amp;quot;An Overview of .A-Prolog,&amp;quot; Proceedings of the Fifth International Logic Programming Conference.</rawString>
</citation>
<citation valid="false">
<authors>
<author>Fernando C N Pereira</author>
<author>M Stuart</author>
</authors>
<title>Shieber [1987], Prolog and Natural-Language Ananlysis,</title>
<journal>CSLI Lecture Notes Number</journal>
<volume>10</volume>
<marker>Pereira, Stuart, </marker>
<rawString>Fernando C.N. Pereira &amp; Stuart M. Shieber [1987], Prolog and Natural-Language Ananlysis, CSLI Lecture Notes Number 10.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Mark J Steedman</author>
</authors>
<title>Gapping as Constituent Coordination,&amp;quot;</title>
<date>1990</date>
<journal>Linguistics and Philosophy</journal>
<volume>13</volume>
<pages>207--263</pages>
<marker>Steedman, 1990</marker>
<rawString>Mark J. Steedman [April 1990], &amp;quot;Gapping as Constituent Coordination,&amp;quot; Linguistics and Philosophy 13, 207-263.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>