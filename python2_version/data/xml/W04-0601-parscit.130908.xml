<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000814">
<title confidence="0.980386">
Techniques for Text Planning with XSLT
</title>
<author confidence="0.980369">
Mary Ellen Foster and Michael White
</author>
<affiliation confidence="0.995163">
Institute for Communicating and Collaborative Systems
School of Informatics, University of Edinburgh
</affiliation>
<address confidence="0.869675">
Edinburgh EH8 9LW
</address>
<email confidence="0.99659">
{mef,mwhite}@inf.ed.ac.uk
</email>
<sectionHeader confidence="0.99382" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999815">
We describe an approach to text planning that uses
the XSLT template-processing engine to create log-
ical forms for an external surface realizer. Using a
realizer that can process logical forms with embed-
ded alternatives provides a substitute for backtrack-
ing in the text-planning process. This allows the text
planner to combine the strengths of the AI-planning
and template-based traditions in natural language
generation.
</bodyText>
<sectionHeader confidence="0.998801" genericHeader="keywords">
1 Introduction
</sectionHeader>
<bodyText confidence="0.999506038461539">
In the traditional pipeline view of natural language
generation (Reiter and Dale, 2000), many steps in-
volve converting between increasingly specific tree
representations. As Wilcock (2001) points out,
this sort of tree-to-tree transformation is a task
to which XML—and particularly XSLT template
processing—is particularly suited.
In this paper, we describe how we plan text by
treating the XSLT processor as a top-down rule-
expanding planner that translates dialogue-manager
specifications into logical forms to be sent to the
OpenCCG text realizer (White and Baldridge, 2003;
White, 2004a; White, 2004b). XSLT is used to per-
form many text-planning tasks, including structur-
ing and aggregating the content, performing lexical
choice via the selection of logical-form templates,
and generating multiple alternative realizations for
messages where possible.
Using an external realizer at the end of the plan-
ning process provides two advantages. First, we
can use the realizer to deal with those aspects of
surface realization that are difficult to implement
in XSLT, but that the realizer is designed to han-
dle (e.g., syntactic agreement via unification). Sec-
ond, we take advantage of OpenCCG’s use of statis-
tical language models by sending multiple alterna-
tive logical forms to the realizer, and having it make
the final choice of surface form. Allowing the text
planner to produce multiple alternatives also obvi-
ates the need for backtracking, which is not some-
thing that is otherwise easily incorporated into the a
system based on XSLT processing.
We have implemented this approach in two di-
alogue systems. In this paper, we concentrate on
how text is planned in the COMIC multimodal di-
alogue system (den Os and Boves, 2003). Similar
techniques are also used in the FLIGHTS spoken-
dialogue system (Moore et al., 2004), which gener-
ates user-tailored descriptions and comparisons of
flight itineraries.
The rest of this paper is organized as follows:
Section 2 gives an overview of the COMIC dia-
logue system and the OpenCCG text realizer. Sec-
tion 3 then shows how the COMIC text planner
generates logical forms for the realizer from high-
level dialogue-manager specifications. Section 4
describes how the interface between the text planner
and the realizer allows us to send multiple alterna-
tive logical forms, and shows the advantages of this
approach. Section 5 discusses related work, while
Section 6 outlines the future plans for this work and
gives some conclusions.
</bodyText>
<sectionHeader confidence="0.8088135" genericHeader="introduction">
2 Systems
2.1 COMIC
</sectionHeader>
<bodyText confidence="0.995446928571429">
COMIC1 (den Os and Boves, 2003) is an ongo-
ing project investigating multimodal dialogue sys-
tems. The demonstrator adds a dialogue interface
to a CAD-like application used in bathroom sales
situations to help clients redesign their rooms. The
input to the system includes speech, handwriting,
and pen gestures; the output combines synthesized
speech, a “talking head” avatar, and control of the
underlying application. Figure 1 shows screen shots
of the avatar and the bathroom-design application.
COMIC produces a variety of output, using its
full range of modalities. In this paper, we will
concentrate on the textual content of those turns in
which the system describes one or more options for
</bodyText>
<footnote confidence="0.7716545">
1COnversational Multimodal Interaction with Computers;
http://www.hcrc.ed.ac.uk/comic/.
</footnote>
<figure confidence="0.995893">
(a) Avatar (b) Bathroom-design application
</figure>
<figureCaption confidence="0.999996">
Figure 1: Components of the COMIC demonstrator
</figureCaption>
<bodyText confidence="0.981141">
decorating the user’s bathroom, as in the following
description of a set of tiles:
</bodyText>
<construct confidence="0.4337026">
(1) Here is a country design. It uses tiles from
Coem’s Armonie series. The tiles are terra-
cotta and beige, giving the room the feeling of
a Tuscan country home. There are floral motifs
on the decorative tiles.
</construct>
<subsectionHeader confidence="0.979967">
2.2 OpenCCG
</subsectionHeader>
<bodyText confidence="0.999947481481482">
The OpenCCG realizer (White and Baldridge,
2003) is a practical, open-source realizer based on
Combinatory Categorial Grammar (CCG; Steed-
man, 2000). It employs a novel ensemble of meth-
ods for improving the efficiency of CCG realization,
and in particular, makes integrated use of n-gram
scoring of possible realizations in its chart realiza-
tion algorithm (White, 2004a; White, 2004b). The
n-gram scoring allows the realizer to work in “any-
time” mode—able at any time to return the highest-
scoring complete realization—and ensures that a
good realization can be found reasonably quickly
even when the number of possibilities is exponen-
tial.
Like other realizers, the OpenCCG realizer is par-
tially responsible for determining word order and
inflection. For example, the realizer determines that
also should preferably follow the verb in There are
also floral motifs on the decorative tiles, whereas in
other cases it typically precedes the verb, as in It
also has abstract shapes. It also enforces subject-
verb agreement, e.g., between are and motifs, and
it and has, respectively. Less typically, in COMIC
and FLIGHTS, the OpenCCG realizer additionally
determines the type of pitch accents, and the type
and placement of boundary tones, based on the in-
formation structure of its input logical forms.
</bodyText>
<sectionHeader confidence="0.924816" genericHeader="method">
3 Text Planning in COMIC
</sectionHeader>
<bodyText confidence="0.99989108">
Broadly speaking, text planning in COMIC follows
the standard pipeline model of natural language
generation (Reiter and Dale, 2000). The input to
the COMIC text planner, from the dialogue man-
ager, specifies the content of the description at a
high level; the output consists of logical forms for
the OpenCCG realizer.
The module is implemented in Java and uses
Apache Xalan2 to process the XSLT templates. The
initial implementation of the presentation-planning
module—of which the XSLT-based sentence plan-
ner described here is just a part—took approxi-
mately one month. After that, the module was de-
bugged and updated incrementally over a period
of several months, during which time additional
templates were created to support updates in the
OpenCCG grammar. The development process was
made easier by the ability to use OpenCCG to parse
a target sentence, and then base a template on the
resulting logical form.
The current presentation planner uses 14 tem-
plates for content structuring and aggregation (Sec-
tion 3.2), and just over 100 to build the logical forms
(Section 3.3). The tasks described here take lit-
tle time to perform (i.e., hundreds of milliseconds);
</bodyText>
<footnote confidence="0.736113">
2http://xml.apache.org/xalan-j/
</footnote>
<figure confidence="0.994977727272727">
&lt;rdf:Description rdf:about=&amp;quot;#Tileset9&amp;quot;&gt;
&lt;rdf:type&gt;
&lt;daml:Class rdf:about=&amp;quot;#Tileset&amp;quot;/&gt;
&lt;/rdf:type&gt;
&lt;comic:has_id&gt;
&lt;xsd:string xsd:value=&amp;quot;9&amp;quot;/&gt;
&lt;/comic:has_id&gt;
&lt;comic:has_commentary
rdf:resource=&amp;quot;#Commentary9&amp;quot;/&gt;
&lt;comic:has_decoration&gt;
&lt;xsd:string xsd:value=&amp;quot;floral-motifs&amp;quot;/&gt;
&lt;/comic:has_decoration&gt;
&lt;comic:has_series&gt;
&lt;xsd:string xsd:value=&amp;quot;Armonie&amp;quot;/&gt;
&lt;/comic:has_series&gt;
&lt;comic:has_manufacturer&gt;
&lt;xsd:string xsd:value=&amp;quot;Coem&amp;quot;/&gt;
&lt;/comic:has_manufacturer&gt;
&lt;comic:has_colour rdf:resource=&amp;quot;#Terracotta&amp;quot;/&gt;
&lt;comic:has_colour rdf:resource=&amp;quot;#Beige&amp;quot;/&gt;
&lt;comic:has_style rdf:resource=&amp;quot;#Country&amp;quot;/&gt;
&lt;/rdf:Description&gt;
</figure>
<figureCaption confidence="0.908702">
Figure 2: Ontology properties of tileset 9
</figureCaption>
<figure confidence="0.999197333333333">
&lt;object type=&amp;quot;describe&amp;quot;&gt;
&lt;slot name=&amp;quot;has_object&amp;quot;&gt;
&lt;object type=&amp;quot;Tileset&amp;quot;&gt;
&lt;slot name=&amp;quot;has_id&amp;quot;&gt;
&lt;value type=&amp;quot;String&amp;quot;&gt;9&lt;/value&gt;
&lt;/slot&gt;
&lt;/object&gt;
&lt;/slot&gt;
&lt;slot name=&amp;quot;has_feature&amp;quot;&gt;
&lt;value type=&amp;quot;String&amp;quot;&gt;has_colour&lt;/value&gt;
&lt;/slot&gt;
&lt;/object&gt;
</figure>
<figureCaption confidence="0.999951">
Figure 3: Dialogue-manager specification
</figureCaption>
<bodyText confidence="0.997813">
most of the module’s time is spent communicating
with other modules in the system.
</bodyText>
<subsectionHeader confidence="0.999718">
3.1 Content Selection
</subsectionHeader>
<bodyText confidence="0.9997815">
The features of the available designs are stored
in the system ontology. This is represented in
DAML+OIL (soon to be OWL) and includes tile
properties such as style, colour, and decoration.
There is also canned-text commentary associated
with some features (e.g., the Tuscan country home
text in (1)). The ontology instance corresponding to
design (“tileset”) 9 is shown in Figure 2.
For a description like (1), the dialogue-manager
specifies only the tileset to be described, and option-
ally a set of features to include in the description.
Figure 3 shows a dialogue-manager message3 indi-
cating that tileset 9 should be described, and that the
description must include the colour.
To select the content of the description, we first
retrieve all of the features of the indicated design
</bodyText>
<footnote confidence="0.865371">
3The object-slot-value syntax used here allows messages
containing ontology instances to be validated easily against an
XML schema.
</footnote>
<bodyText confidence="0.999153571428572">
from the ontology, using the Jena semantic web
framework.4 We then use the system dialogue his-
tory to filter the retrieved features by removing any
that have already been described to the user. Finally,
we add back to the set any features specifically re-
quested by the dialogue manager, even if they have
been included in a previous description.
</bodyText>
<subsectionHeader confidence="0.999945">
3.2 Content Structuring
</subsectionHeader>
<bodyText confidence="0.999966076923077">
The result of content selection is an unordered set
of tileset features; this set is converted into a text
plan as follows. First, for each selected feature, a
message is created in XML that combines the in-
formation gathered from the ontology with infor-
mation from the system dialogue history. Figure 4
shows the messages corresponding to the colour
feature and to the associated canned-text commen-
tary. The dialogue-history information is included
in the same-as-last (i.e., whether this value is the
same as the corresponding value of the previous tile-
set) and already-said attributes.
The unordered set of messages is converted to an
ordered list using a small number of heuristics: for
example, features requested by the dialogue man-
ager are always put at the start of the list, while
canned-text commentary always goes immediately
after the feature to which it refers. These heuristics
provide a partial ordering, which is then converted
to a total ordering by breaking ties at random.
The next step is to aggregate the flat list of mes-
sages. In many NLG systems, aggregation is a task
that is done at the syntactic level; in COMIC, we
instead work at the conceptual level. Thanks to the
fact that we produce multiple alternative syntactic
structures (see Section 4), we can be confident that,
whatever the final set of messages, there will be
some syntactic structure available to realize them.
The aggregation is done using a set of XSLT tem-
plates that combine adjacent messages based on var-
ious criteria. For example, the template shown in
Figure 5 combines a feature-value message with
the associated canned-text commentary.5 Figure 6
shows the combined message that results when the
messages in Figure 4 are processed by this template.
The sentence boundaries in the final text are de-
termined by the content structure: each aggregated
message after aggregation corresponds to exactly
one sentence in the output.
</bodyText>
<footnote confidence="0.950792">
4http://jena.sourceforge.net/
5This template is simplified; there are actually many more
</footnote>
<figureCaption confidence="0.4105515">
tests, and aggregation is performed in several passes to allow
multi-level aggregation. The set namespace refers to a Java Set
instance that stores message IDs to avoid processing a message
twice.
</figureCaption>
<figure confidence="0.5913218">
&lt;messages&gt;
&lt;msg id=&amp;quot;t2-1-5&amp;quot; prop=&amp;quot;has_colour&amp;quot; type=&amp;quot;prop-has-val&amp;quot; same-as-last=&amp;quot;false&amp;quot; already-said=&amp;quot;false&amp;quot;&gt;
&lt;slot name=&amp;quot;object&amp;quot; value=&amp;quot;tileset9&amp;quot;/&gt;
&lt;slot name=&amp;quot;value&amp;quot; value=&amp;quot;terracotta beige&amp;quot;/&gt;
&lt;/msg&gt;
&lt;msg full-sentence=&amp;quot;false&amp;quot; id=&amp;quot;t2-1-6&amp;quot; prop=&amp;quot;has_colour&amp;quot; type=&amp;quot;canned-text&amp;quot;&gt;
&lt;slot name=&amp;quot;object&amp;quot; value=&amp;quot;tileset9&amp;quot;/&gt;
&lt;slot name=&amp;quot;value&amp;quot; value=&amp;quot;give-tuscan-feeling&amp;quot;/&gt;
&lt;/msg&gt;
&lt;/messages&gt;
</figure>
<figureCaption confidence="0.974713">
Figure 4: Initial messages
</figureCaption>
<figure confidence="0.99263792">
&lt;xsl:template match=&amp;quot;messages&amp;quot;&gt;
&lt;xsl:variable name=&amp;quot;void&amp;quot; select=&amp;quot;set:clear()&amp;quot;/&gt;
&lt;messages&gt;
&lt;xsl:for-each select=&amp;quot;msg&amp;quot;&gt;
&lt;xsl:variable name=&amp;quot;next&amp;quot; select=&amp;quot;following-sibling::msg[1]&amp;quot;/&gt;
&lt;xsl:choose&gt;
&lt;!-- Return nothing if we’ve already processed this message. --&gt;
&lt;xsl:when test=&amp;quot;set:contains(@id)&amp;quot;/&gt;
&lt;!-- Add canned text to a sentence. --&gt;
&lt;xsl:when test=&amp;quot;@prop=$next/@prop and @type=’prop-has-val’
and $next/@type=’canned-text’ and not($next/@full-sentence=’true’)&amp;quot;&gt;
&lt;msg type=&amp;quot;same-prop-canned-text&amp;quot; id=&amp;quot;{concat(@id, ’+’, $next/@id)}&amp;quot;&gt;
&lt;slot name=&amp;quot;prop&amp;quot;&gt; &lt;xsl:copy-of select=&amp;quot;.&amp;quot;/&gt; &lt;/slot&gt;
&lt;slot name=&amp;quot;text&amp;quot;&gt; &lt;xsl:copy-of select=&amp;quot;$next&amp;quot;/&gt; &lt;/slot&gt;
&lt;/msg&gt;
&lt;xsl:variable name=&amp;quot;void&amp;quot; select=&amp;quot;set:add(string(@id))&amp;quot;/&gt;
&lt;xsl:variable name=&amp;quot;void&amp;quot; select=&amp;quot;set:add(string($next/@id))&amp;quot;/&gt;
&lt;/xsl:when&gt;
&lt;!-- ... other tests ... --&gt;
&lt;!-- Nothing matched: just copy the message across. --&gt;
&lt;xsl:otherwise&gt; &lt;xsl:copy-of select=&amp;quot;.&amp;quot;/&gt; &lt;/xsl:otherwise&gt;
&lt;/xsl:choose&gt;
&lt;/xsl:for-each&gt;
&lt;/messages&gt;
&lt;/xsl:template&gt;
</figure>
<figureCaption confidence="0.999949">
Figure 5: Aggregation template (simplified)
</figureCaption>
<subsectionHeader confidence="0.999264">
3.3 Sentence Planning
</subsectionHeader>
<bodyText confidence="0.9999913125">
After the content of a description has been selected
and structured, the logical forms to send to the re-
alizer are created by applying further XSLT tem-
plates. Every such template matches a message
with particular properties, and produces a logical
form for the realizer, possibly combining the results
of other templates to produce its own final result.
XSLT modes are used to select different templates
in different target syntactic contexts.
Two sample templates are shown in Figure 7.
The first template produces the logical form for
a sentence (mode=&amp;quot;s&amp;quot;) describing the colours of
a tileset (e.g., The tiles are terracotta and beige).
The second template creates a logical form repre-
senting a commentary message as a verb phrase6
(mode=&amp;quot;vp&amp;quot;), and then appends it as an elaboration
</bodyText>
<footnote confidence="0.8134265">
6Canned-text commentary is represented in the realizer lex-
icon as a multi-word verb.
</footnote>
<bodyText confidence="0.9998569375">
to a sentence about the same property. When the
messages in Figure 6 are transformed by these tem-
plates, the result is the logical form shown in Fig-
ure 8, which corresponds to the sentence The tiles
are terracotta and beige, giving the room the feel-
ing of a Tuscan country home.
Referring expressions are generated based on the
number of mentions of the referent: the first refer-
ence gets a full NP (e.g., this design), while subse-
quent mentions are pronominalized.
The logical form created for each top-level mes-
sage is sent to the OpenCCG realizer, which then
generates and returns the corresponding surface
form. As described below, the logical forms may
incorporate alternatives, in which case the realizer
chooses the logical form to use.
</bodyText>
<sectionHeader confidence="0.914087" genericHeader="method">
4 Sending Alternatives to the Realizer
</sectionHeader>
<bodyText confidence="0.983076">
Many messages can be realized by several differ-
ent logical forms. For example, to inform the user
</bodyText>
<figure confidence="0.995015875">
&lt;messages&gt;
&lt;msg id=&amp;quot;t2-1-5+t2-1-6&amp;quot; type=&amp;quot;same-prop-canned-text&amp;quot;&gt;
&lt;slot name=&amp;quot;prop&amp;quot;&gt;
&lt;msg id=&amp;quot;t2-1-5&amp;quot; prop=&amp;quot;has_colour&amp;quot; type=&amp;quot;prop-has-val&amp;quot; same-as-last=&amp;quot;false&amp;quot; already-said=&amp;quot;false&amp;quot;&gt;
&lt;slot name=&amp;quot;object&amp;quot; value=&amp;quot;tileset9&amp;quot;/&gt;
&lt;slot name=&amp;quot;value&amp;quot; value=&amp;quot;terracotta beige&amp;quot;/&gt;
&lt;/msg&gt;
&lt;/slot&gt;
&lt;slot name=&amp;quot;text&amp;quot;&gt;
&lt;msg full-sentence=&amp;quot;false&amp;quot; id=&amp;quot;t2-1-6&amp;quot; prop=&amp;quot;has_colour&amp;quot; type=&amp;quot;canned-text&amp;quot;&gt;
&lt;slot name=&amp;quot;object&amp;quot; value=&amp;quot;tileset9&amp;quot;/&gt;
&lt;slot name=&amp;quot;text&amp;quot; value=&amp;quot;give-tuscan-feeling&amp;quot;/&gt;
&lt;/msg&gt;
&lt;/slot&gt;
&lt;/msg&gt;
&lt;/messages&gt;
</figure>
<figureCaption confidence="0.995972">
Figure 6: Combined messages
</figureCaption>
<figure confidence="0.984180083333333">
&lt;xsl:template match=&amp;quot;msg[@type=’prop-has-val’ and @prop=’has_colour’]&amp;quot; mode=&amp;quot;s&amp;quot;&gt;
&lt;node pred=&amp;quot;be&amp;quot; tense=&amp;quot;pres&amp;quot;&gt;
&lt;rel name=&amp;quot;Arg&amp;quot;&gt; &lt;node pred=&amp;quot;tile&amp;quot; det=&amp;quot;the&amp;quot; num=&amp;quot;pl&amp;quot;/&gt; &lt;/rel&gt;
&lt;rel name=&amp;quot;Prop&amp;quot;&gt; &lt;xsl:apply-templates select=&amp;quot;slot[@name=’value’]&amp;quot; mode=&amp;quot;np&amp;quot;/&gt; &lt;/rel&gt;
&lt;/node&gt;
&lt;/xsl:template&gt;
&lt;xsl:template match=&amp;quot;msg[@type=’same-prop-canned-text’]&amp;quot; mode=&amp;quot;s&amp;quot;&gt;
&lt;node pred=&amp;quot;elab-rel&amp;quot;&gt;
&lt;rel name=&amp;quot;Core&amp;quot;&gt; &lt;xsl:apply-templates select=&amp;quot;slot[@name=’prop’]/msg&amp;quot; mode=&amp;quot;s&amp;quot;/&gt; &lt;/rel&gt;
&lt;rel name=&amp;quot;Trib&amp;quot;&gt; &lt;xsl:apply-templates select=&amp;quot;slot[@name=’text’]/msg&amp;quot; mode=&amp;quot;vp&amp;quot;/&gt; &lt;/rel&gt;
&lt;/node&gt;
&lt;/xsl:template&gt;
</figure>
<figureCaption confidence="0.99998">
Figure 7: Sentence-planning templates (simplified)
</figureCaption>
<bodyText confidence="0.998328138888889">
that a particular design is in the country style, the
options include This design is in the country style
and This design is country. Often, the text planner
has no reason to prefer one alternative over another.
Rather than picking an arbitrary option within the
text planner (as did, e.g., van Deemter et al. (1999)),
we instead defer the choice and send all of the valid
alternatives to the realizer, in a packed representa-
tion. This makes the implementation of the text
planner more straightforward. Figure 9 shows an
example of such a logical form, incorporating both
of the above options under a &lt;one-of&gt; element.
To process a logical form with embedded alterna-
tives, the COMIC realizer makes use of the same
n-gram language models that it uses to guide its
search for the realization of a single logical form.
Since OpenCCG cannot yet handle the realization
of logical forms with embedded alternatives directly
(though this capability is planned), in the current
system the packed alternatives are first multiplied
out into a list of top-level alternatives, whose order
is randomly shuffled. The realizer then computes
the best realization for each top-level alternative in
turn, keeping track of the overall best scoring com-
plete realization, until either the anytime time limit
is reached or the list is exhausted. To allow for some
free variation, a new realization’s score must exceed
the current best one by a certain threshold before it
is considered significantly better.
As a concrete example, consider the case where
the system must confirm that the user intends to re-
fer to a tileset with a specific feature. The feature
could be included in the logical form in two ways: it
could be attached directly to the design node (2–3),
or it could instead be included as a non-restrictive
modifier (4).
</bodyText>
<listItem confidence="0.998540666666667">
(2) Do you mean this country design?
(3) Do you mean this design by Coem?
(4) Do you mean this design, with tiles by Coem?
</listItem>
<bodyText confidence="0.9997086">
When the modifier can be placed before design, as
in (2), the directly-attached structure is acceptable.
However, for some features, the modifier can only
be placed after the modified noun, as in (3). In
these cases, the preferred structure is instead the
non-restrictive one in (4); this breaks the sentence
into two intonational phrases, which makes it eas-
ier to understand when it is output by the speech
synthesizer. This preference is implemented by in-
cluding only sentences of the preferred type when
</bodyText>
<table confidence="0.649007363636364">
&lt;!-- The tiles are terracotta and beige, giving the room the feeling of a Tuscan country home. --&gt;
&lt;lf id=&amp;quot;t2-1-5+t2-1-6&amp;quot;&gt;
&lt;node mood=&amp;quot;dcl&amp;quot; info=&amp;quot;rh&amp;quot; pred=&amp;quot;elab-rel&amp;quot; id=&amp;quot;n7&amp;quot;&gt;
&lt;rel name=&amp;quot;Core&amp;quot;&gt;
&lt;node tense=&amp;quot;pres&amp;quot; id=&amp;quot;n2&amp;quot; pred=&amp;quot;be&amp;quot;&gt;
&lt;rel name=&amp;quot;Arg&amp;quot;&gt; &lt;node det=&amp;quot;the&amp;quot; pred=&amp;quot;tile&amp;quot; id=&amp;quot;n1&amp;quot; num=&amp;quot;pl&amp;quot;/&gt; &lt;/rel&gt;
&lt;rel name=&amp;quot;Prop&amp;quot;&gt;
&lt;node id=&amp;quot;n3&amp;quot; pred=&amp;quot;and&amp;quot;&gt;
&lt;rel name=&amp;quot;List&amp;quot;&gt;
&lt;node id=&amp;quot;n4&amp;quot; kon=&amp;quot;+&amp;quot; pred=&amp;quot;terracotta&amp;quot;&gt; &lt;rel name=&amp;quot;Of&amp;quot;&gt; &lt;node idref=&amp;quot;n1&amp;quot;/&gt; &lt;/rel&gt; &lt;/node&gt;
&lt;node kon=&amp;quot;+&amp;quot; id=&amp;quot;n6&amp;quot; pred=&amp;quot;beige&amp;quot;&gt; &lt;rel name=&amp;quot;Of&amp;quot;&gt; &lt;node idref=&amp;quot;n1&amp;quot;/&gt; &lt;/rel&gt; &lt;/node&gt;
</table>
<figure confidence="0.9920612">
&lt;/rel&gt;
&lt;/node&gt;
&lt;/rel&gt;
&lt;/node&gt;
&lt;/rel&gt;
&lt;rel name=&amp;quot;Trib&amp;quot;&gt;
&lt;node id=&amp;quot;n8&amp;quot; pred=&amp;quot;give-tuscan-feeling&amp;quot;&gt; &lt;rel name=&amp;quot;Arg&amp;quot;&gt; &lt;node idref=&amp;quot;n1&amp;quot;/&gt; &lt;/rel&gt; &lt;/node&gt;
&lt;/rel&gt;
&lt;/node&gt;
&lt;/lf&gt;
</figure>
<figureCaption confidence="0.993628">
Figure 8: Generated logical form
</figureCaption>
<figure confidence="0.90937716">
&lt;lf id=&amp;quot;t2-1-2&amp;quot;&gt;
&lt;!-- This design is ... --&gt;
&lt;node tense=&amp;quot;pres&amp;quot; mood=&amp;quot;dcl&amp;quot; info=&amp;quot;rh&amp;quot; pred=&amp;quot;be&amp;quot; id=&amp;quot;n13&amp;quot;&gt;
&lt;rel name=&amp;quot;Arg&amp;quot;&gt;
&lt;node id=&amp;quot;n1&amp;quot; num=&amp;quot;sg&amp;quot; pred=&amp;quot;design&amp;quot; kon=&amp;quot;+&amp;quot;&gt;
&lt;rel name=&amp;quot;Det&amp;quot;&gt; &lt;node kon=&amp;quot;+&amp;quot; pred=&amp;quot;this&amp;quot; id=&amp;quot;n18&amp;quot;/&gt; &lt;/rel&gt;
&lt;/node&gt;
&lt;/rel&gt;
&lt;rel name=&amp;quot;Prop&amp;quot;&gt;
&lt;one-of&gt;
&lt;!-- ... in the country style. --&gt;
&lt;node pred=&amp;quot;in&amp;quot; id=&amp;quot;n14&amp;quot;&gt;
&lt;rel name=&amp;quot;Fig&amp;quot;&gt; &lt;node idref=&amp;quot;n1&amp;quot;/&gt; &lt;/rel&gt;
&lt;rel name=&amp;quot;Ground&amp;quot;&gt;
&lt;node num=&amp;quot;sg&amp;quot; det=&amp;quot;the&amp;quot; pred=&amp;quot;style&amp;quot; id=&amp;quot;n15&amp;quot;&gt;
&lt;rel name=&amp;quot;HasProp&amp;quot;&gt; &lt;node id=&amp;quot;n16&amp;quot; kon=&amp;quot;+&amp;quot; pred=&amp;quot;country&amp;quot;/&gt; &lt;/rel&gt;
&lt;/node&gt;
&lt;/rel&gt;
&lt;/node&gt;
&lt;!-- ... country. --&gt;
&lt;node id=&amp;quot;n20&amp;quot; kon=&amp;quot;+&amp;quot; pred=&amp;quot;country&amp;quot;&gt; &lt;rel name=&amp;quot;Of&amp;quot;&gt; &lt;node idref=&amp;quot;n1&amp;quot;/&gt; &lt;/rel&gt; &lt;/node&gt;
&lt;/one-of&gt;
&lt;/rel&gt;
&lt;/node&gt;
&lt;/lf&gt;
</figure>
<figureCaption confidence="0.999903">
Figure 9: Logical form containing alternatives
</figureCaption>
<bodyText confidence="0.991712">
building the language model for OpenCCG. The re-
alizer will then give (4) a higher n-gram score than
(3), and will therefore choose the desired structure.
In addition to simplifying the implementation, re-
taining multiple alternatives through the planning
process also increases the robustness of the system,
and provides a substitute for backtracking. Particu-
larly during development, there may be times when
a required template simply does not exist; for ex-
ample, the second template in Figure 7 will fail if
the canned-text commentary cannot be realized as a
verb phrase. In such cases, the text planner prunes
out the failing possibilities before sending the set of
options to the realizer, using the template shown in
Figure 10.
</bodyText>
<sectionHeader confidence="0.999894" genericHeader="method">
5 Related Work
</sectionHeader>
<bodyText confidence="0.9992982">
The work presented here continues in the tradi-
tion of several recent NLG systems that use what
could be called generalized template-based process-
ing. By generalized, we mean that, rather than ma-
nipulating flat strings with no underlying linguis-
tic representation, these systems instead work with
structured fragments, which are often processed re-
cursively. Other systems that fall into this cate-
gory include EXEMPLARS (White and Caldwell,
1998), D2S (van Deemter et al., 1999), Interact
</bodyText>
<figure confidence="0.995615238095238">
&lt;xsl:template match=&amp;quot;one-of&amp;quot;&gt;
&lt;!-- Recursive pruning step --&gt;
&lt;xsl:variable name=&amp;quot;pruned-alts&amp;quot;&gt;
&lt;xsl:for-each select=&amp;quot;*&amp;quot;&gt;
&lt;xsl:variable name=&amp;quot;pruned-alt&amp;quot;&gt; &lt;xsl:apply-templates select=&amp;quot;.&amp;quot;/&gt; &lt;/xsl:variable&gt;
&lt;xsl:if test=&amp;quot;not(xalan:nodeset($pruned-alt)//fail)&amp;quot;&gt;
&lt;xsl:copy-of select=&amp;quot;$pruned-alt&amp;quot;/&gt;
&lt;/xsl:if&gt;
&lt;/xsl:for-each&gt;
&lt;/xsl:variable&gt;
&lt;xsl:variable name=&amp;quot;num-remaining&amp;quot; select=&amp;quot;count(xalan:nodeset($pruned-alts)/*)&amp;quot;/&gt;
&lt;!-- Propagation step --&gt;
&lt;xsl:choose&gt;
&lt;!-- keep one-of when multiple alts succeed --&gt;
&lt;xsl:when test=&amp;quot;$num-remaining &gt; 1&amp;quot;&gt; &lt;one-of&gt; &lt;xsl:copy-of select=&amp;quot;$pruned-alts&amp;quot;/&gt; &lt;/one-of&gt; &lt;/xsl:when&gt;
&lt;!-- filter out one-of when just one choice remains --&gt;
&lt;xsl:when test=&amp;quot;$num-remaining = 1&amp;quot;&gt; &lt;xsl:copy-of select=&amp;quot;$pruned-alts&amp;quot;/&gt; &lt;/xsl:when&gt;
&lt;!-- fail if none remain --&gt;
&lt;xsl:otherwise&gt; &lt;fail/&gt; &lt;/xsl:otherwise&gt;
&lt;/xsl:choose&gt;
&lt;/xsl:template&gt;
</figure>
<figureCaption confidence="0.997771">
Figure 10: Failure-pruning template
</figureCaption>
<bodyText confidence="0.989991533333333">
(Wilcock, 2001; Wilcock, 2003), and SmartKom
(Becker, 2002).
The main novel contribution of the text-planning
approach described here is in its use of an exter-
nal realizer that processes logical forms with em-
bedded alternatives. This eliminates the need to
use a backtracking AI planner (Becker, 2002) or to
make arbitrary choices when multiple alternatives
are available (van Deemter et al., 1999). The real-
izer also uses a completely different algorithm than
the XSLT template processing—bottom-up, chart-
based search rather than top-down rule expansion—
which allows it to deal with those aspects of NLG
that are more easily addressed using this kind of
processing strategy.
Our approach to text planning draws from both
the AI-planning and the template-based traditions
in natural language generation. Most previous
NLG systems that use AI planners use them pri-
marily to do hierarchical decomposition of com-
municative goals; the work described here uses
XSLT to achieve the same end, with a substitute
for backtracking provided by the realizer’s support
for multiple alternatives. The system is nonetheless
equally based on (generalized) template processing.
This demonstrates that, rather than being in con-
flict, the two traditions actually have complemen-
tary strengths, which can usefully be combined in a
single system (contra Reiter, 1995; cf. van Deemter
et al., 1999).
</bodyText>
<sectionHeader confidence="0.995625" genericHeader="conclusions">
6 Conclusions and Future Work
</sectionHeader>
<bodyText confidence="0.999988086956522">
We have described a successful implementation of
the classic NLG pipeline that uses XSLT template
processing as a top-down rule-expanding planner.
Implementing the necessary steps using XSLT was
generally straightforward, and the ability to use off-
the shelf, well-tested and well-documented tools
such as Java and Xalan adds to the ease of imple-
mentation and robustness.
Our implementation creates logical forms for the
OpenCCG realizer; this allows the realizer to be
used for those parts of the generation process to
which XSLT is less well-suited. We also take ad-
vantage of the fact that the realizer uses statistical
language models in its search for a surface form
by generating logical forms with embedded alter-
natives, allowing the realizer to choose the one to
use. This both adds robustness to the system and
eliminates the need for backtracking within the text
planner.
The current implementation is fast and reliable: it
correctly processes all input from the dialogue man-
ager, and the time it takes to do so is relatively short
compared to that required by the other processing
and communication tasks in COMIC.
The entire COMIC demonstrator will shortly be
evaluated. As part of this evaluation, we plan to
measure users’ recall of the information that the sys-
tem presents to them, where that information is gen-
erated at different levels of detail.
At the moment, the logical form for each mes-
sage is created in isolation. In future versions of
COMIC, we plan to use ideas from centering theory
to help ensure coherence by planning a coherent se-
quence of logical forms for a description. We will
implement this in a way similar to that described by
Kibble and Power (2000).
We will also incorporate a model of the user’s
preferences into a later version of COMIC. The
model will be used both to rank the options to be
presented to the user, and to generate user-tailored
descriptions of those options, as in FLIGHTS
(Moore et al., 2004).
Finally, we plan to extend the use of data-driven
techniques in the realizer, and to make use of these
techniques to help in choosing among alternatives
in the other COMIC output modalities.
</bodyText>
<sectionHeader confidence="0.996368" genericHeader="acknowledgments">
Acknowledgements
</sectionHeader>
<bodyText confidence="0.9986032">
Thanks to Jon Oberlander, Johanna Moore, and
the anonymous reviewers for helpful comments and
discussion. This work was supported in part by the
COMIC (IST-2001-32311) and FLIGHTS (EPSRC-
GR/R02450/01) projects.
</bodyText>
<sectionHeader confidence="0.99901" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.997112266666667">
Tilman Becker. 2002. Practical, template-based
natural language generation with TAG. In Pro-
ceedings of TAG+6.
Kees van Deemter, Emiel Krahmer, and Mari¨et The-
une. 1999. Plan-based vs. template-based NLG:
a false opposition? In Proceedings of “May I
speakfreely?” workshop at KI-99.
Rodger Kibble and Richard Power. 2000. An inte-
grated framework for text planning and pronomi-
nalisation. In Proceedings ofINLG 2000.
Johanna Moore, Mary Ellen Foster, Oliver Lemon,
and Michael White. 2004. Generating tailored,
comparative descriptions in spoken dialogue. In
Proceedings ofFLAIRS2004.
Els den Os and Lou Boves. 2003. Towards ambi-
ent intelligence: Multimodal computers that un-
derstand our intentions. In Proceedings of eChal-
lenges e-2003.
Ehud Reiter. 1995. NLG vs. templates. In Proceed-
ings ofEWNLG-95.
Ehud Reiter and Robert Dale. 2000. Building Nat-
ural Language Generation Systems. Cambridge
University Press.
Mark Steedman. 2000. The Syntactic Process.
MIT Press.
Michael White. 2004a. Efficient realization of
coordinate structures in Combinatory Categorial
Grammar. Research on Language and Computa-
tion. To appear.
Michael White. 2004b. Reining in CCG chart re-
alization. In Proceedings of INLG 2004. To ap-
pear.
Michael White and Jason Baldridge. 2003. Adapt-
ing chart realization to CCG. In Proceedings of
EWNLG-03.
Michael White and Ted Caldwell. 1998. EXEM-
PLARS: A practical, extensible framework for
dynamic text generation. In Proceedings ofINLG
1998.
Graham Wilcock. 2001. Pipelines, templates and
transformations: XML for natural language gen-
eration. In Proceedings ofNLPUML-2001.
Graham Wilcock. 2003. Integrating natural lan-
guage generation with XML web technology. In
Proceedings ofEACL-2003 Demo Sessions.
</reference>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.893655">
<title confidence="0.998853">Techniques for Text Planning with XSLT</title>
<author confidence="0.99966">Ellen Foster</author>
<affiliation confidence="0.995121">Institute for Communicating and Collaborative School of Informatics, University of</affiliation>
<email confidence="0.989481">mef@inf.ed.ac.uk</email>
<email confidence="0.989481">mwhite@inf.ed.ac.uk</email>
<abstract confidence="0.991192">We describe an approach to text planning that uses the XSLT template-processing engine to create logical forms for an external surface realizer. Using a realizer that can process logical forms with embedded alternatives provides a substitute for backtracking in the text-planning process. This allows the text planner to combine the strengths of the AI-planning and template-based traditions in natural language generation.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Tilman Becker</author>
</authors>
<title>Practical, template-based natural language generation with TAG.</title>
<date>2002</date>
<booktitle>In Proceedings of TAG+6.</booktitle>
<contexts>
<context position="21844" citStr="Becker, 2002" startWordPosition="3083" endWordPosition="3084"> &lt;xsl:variable name=&amp;quot;num-remaining&amp;quot; select=&amp;quot;count(xalan:nodeset($pruned-alts)/*)&amp;quot;/&gt; &lt;!-- Propagation step --&gt; &lt;xsl:choose&gt; &lt;!-- keep one-of when multiple alts succeed --&gt; &lt;xsl:when test=&amp;quot;$num-remaining &gt; 1&amp;quot;&gt; &lt;one-of&gt; &lt;xsl:copy-of select=&amp;quot;$pruned-alts&amp;quot;/&gt; &lt;/one-of&gt; &lt;/xsl:when&gt; &lt;!-- filter out one-of when just one choice remains --&gt; &lt;xsl:when test=&amp;quot;$num-remaining = 1&amp;quot;&gt; &lt;xsl:copy-of select=&amp;quot;$pruned-alts&amp;quot;/&gt; &lt;/xsl:when&gt; &lt;!-- fail if none remain --&gt; &lt;xsl:otherwise&gt; &lt;fail/&gt; &lt;/xsl:otherwise&gt; &lt;/xsl:choose&gt; &lt;/xsl:template&gt; Figure 10: Failure-pruning template (Wilcock, 2001; Wilcock, 2003), and SmartKom (Becker, 2002). The main novel contribution of the text-planning approach described here is in its use of an external realizer that processes logical forms with embedded alternatives. This eliminates the need to use a backtracking AI planner (Becker, 2002) or to make arbitrary choices when multiple alternatives are available (van Deemter et al., 1999). The realizer also uses a completely different algorithm than the XSLT template processing—bottom-up, chartbased search rather than top-down rule expansion— which allows it to deal with those aspects of NLG that are more easily addressed using this kind of pro</context>
</contexts>
<marker>Becker, 2002</marker>
<rawString>Tilman Becker. 2002. Practical, template-based natural language generation with TAG. In Proceedings of TAG+6.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kees van Deemter</author>
<author>Emiel Krahmer</author>
<author>Mari¨et Theune</author>
</authors>
<title>Plan-based vs. template-based NLG: a false opposition?</title>
<date>1999</date>
<booktitle>In Proceedings of “May I speakfreely?” workshop at KI-99.</booktitle>
<marker>van Deemter, Krahmer, Theune, 1999</marker>
<rawString>Kees van Deemter, Emiel Krahmer, and Mari¨et Theune. 1999. Plan-based vs. template-based NLG: a false opposition? In Proceedings of “May I speakfreely?” workshop at KI-99.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Rodger Kibble</author>
<author>Richard Power</author>
</authors>
<title>An integrated framework for text planning and pronominalisation.</title>
<date>2000</date>
<booktitle>In Proceedings ofINLG</booktitle>
<contexts>
<context position="24878" citStr="Kibble and Power (2000)" startWordPosition="3571" endWordPosition="3574">red by the other processing and communication tasks in COMIC. The entire COMIC demonstrator will shortly be evaluated. As part of this evaluation, we plan to measure users’ recall of the information that the system presents to them, where that information is generated at different levels of detail. At the moment, the logical form for each message is created in isolation. In future versions of COMIC, we plan to use ideas from centering theory to help ensure coherence by planning a coherent sequence of logical forms for a description. We will implement this in a way similar to that described by Kibble and Power (2000). We will also incorporate a model of the user’s preferences into a later version of COMIC. The model will be used both to rank the options to be presented to the user, and to generate user-tailored descriptions of those options, as in FLIGHTS (Moore et al., 2004). Finally, we plan to extend the use of data-driven techniques in the realizer, and to make use of these techniques to help in choosing among alternatives in the other COMIC output modalities. Acknowledgements Thanks to Jon Oberlander, Johanna Moore, and the anonymous reviewers for helpful comments and discussion. This work was suppor</context>
</contexts>
<marker>Kibble, Power, 2000</marker>
<rawString>Rodger Kibble and Richard Power. 2000. An integrated framework for text planning and pronominalisation. In Proceedings ofINLG 2000.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Johanna Moore</author>
<author>Mary Ellen Foster</author>
<author>Oliver Lemon</author>
<author>Michael White</author>
</authors>
<title>Generating tailored, comparative descriptions in spoken dialogue.</title>
<date>2004</date>
<booktitle>In Proceedings ofFLAIRS2004.</booktitle>
<contexts>
<context position="2485" citStr="Moore et al., 2004" startWordPosition="376" endWordPosition="379">f statistical language models by sending multiple alternative logical forms to the realizer, and having it make the final choice of surface form. Allowing the text planner to produce multiple alternatives also obviates the need for backtracking, which is not something that is otherwise easily incorporated into the a system based on XSLT processing. We have implemented this approach in two dialogue systems. In this paper, we concentrate on how text is planned in the COMIC multimodal dialogue system (den Os and Boves, 2003). Similar techniques are also used in the FLIGHTS spokendialogue system (Moore et al., 2004), which generates user-tailored descriptions and comparisons of flight itineraries. The rest of this paper is organized as follows: Section 2 gives an overview of the COMIC dialogue system and the OpenCCG text realizer. Section 3 then shows how the COMIC text planner generates logical forms for the realizer from highlevel dialogue-manager specifications. Section 4 describes how the interface between the text planner and the realizer allows us to send multiple alternative logical forms, and shows the advantages of this approach. Section 5 discusses related work, while Section 6 outlines the fut</context>
</contexts>
<marker>Moore, Foster, Lemon, White, 2004</marker>
<rawString>Johanna Moore, Mary Ellen Foster, Oliver Lemon, and Michael White. 2004. Generating tailored, comparative descriptions in spoken dialogue. In Proceedings ofFLAIRS2004.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Els den Os</author>
<author>Lou Boves</author>
</authors>
<title>Towards ambient intelligence: Multimodal computers that understand our intentions.</title>
<date>2003</date>
<booktitle>In Proceedings of eChallenges e-2003.</booktitle>
<marker>den Os, Boves, 2003</marker>
<rawString>Els den Os and Lou Boves. 2003. Towards ambient intelligence: Multimodal computers that understand our intentions. In Proceedings of eChallenges e-2003.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ehud Reiter</author>
</authors>
<title>NLG vs. templates.</title>
<date>1995</date>
<booktitle>In Proceedings ofEWNLG-95.</booktitle>
<contexts>
<context position="23130" citStr="Reiter, 1995" startWordPosition="3281" endWordPosition="3282">nning and the template-based traditions in natural language generation. Most previous NLG systems that use AI planners use them primarily to do hierarchical decomposition of communicative goals; the work described here uses XSLT to achieve the same end, with a substitute for backtracking provided by the realizer’s support for multiple alternatives. The system is nonetheless equally based on (generalized) template processing. This demonstrates that, rather than being in conflict, the two traditions actually have complementary strengths, which can usefully be combined in a single system (contra Reiter, 1995; cf. van Deemter et al., 1999). 6 Conclusions and Future Work We have described a successful implementation of the classic NLG pipeline that uses XSLT template processing as a top-down rule-expanding planner. Implementing the necessary steps using XSLT was generally straightforward, and the ability to use offthe shelf, well-tested and well-documented tools such as Java and Xalan adds to the ease of implementation and robustness. Our implementation creates logical forms for the OpenCCG realizer; this allows the realizer to be used for those parts of the generation process to which XSLT is less</context>
</contexts>
<marker>Reiter, 1995</marker>
<rawString>Ehud Reiter. 1995. NLG vs. templates. In Proceedings ofEWNLG-95.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ehud Reiter</author>
<author>Robert Dale</author>
</authors>
<title>Building Natural Language Generation Systems.</title>
<date>2000</date>
<publisher>Cambridge University Press.</publisher>
<contexts>
<context position="755" citStr="Reiter and Dale, 2000" startWordPosition="104" endWordPosition="107">ol of Informatics, University of Edinburgh Edinburgh EH8 9LW {mef,mwhite}@inf.ed.ac.uk Abstract We describe an approach to text planning that uses the XSLT template-processing engine to create logical forms for an external surface realizer. Using a realizer that can process logical forms with embedded alternatives provides a substitute for backtracking in the text-planning process. This allows the text planner to combine the strengths of the AI-planning and template-based traditions in natural language generation. 1 Introduction In the traditional pipeline view of natural language generation (Reiter and Dale, 2000), many steps involve converting between increasingly specific tree representations. As Wilcock (2001) points out, this sort of tree-to-tree transformation is a task to which XML—and particularly XSLT template processing—is particularly suited. In this paper, we describe how we plan text by treating the XSLT processor as a top-down ruleexpanding planner that translates dialogue-manager specifications into logical forms to be sent to the OpenCCG text realizer (White and Baldridge, 2003; White, 2004a; White, 2004b). XSLT is used to perform many text-planning tasks, including structuring and aggre</context>
<context position="5790" citStr="Reiter and Dale, 2000" startWordPosition="894" endWordPosition="897">in There are also floral motifs on the decorative tiles, whereas in other cases it typically precedes the verb, as in It also has abstract shapes. It also enforces subjectverb agreement, e.g., between are and motifs, and it and has, respectively. Less typically, in COMIC and FLIGHTS, the OpenCCG realizer additionally determines the type of pitch accents, and the type and placement of boundary tones, based on the information structure of its input logical forms. 3 Text Planning in COMIC Broadly speaking, text planning in COMIC follows the standard pipeline model of natural language generation (Reiter and Dale, 2000). The input to the COMIC text planner, from the dialogue manager, specifies the content of the description at a high level; the output consists of logical forms for the OpenCCG realizer. The module is implemented in Java and uses Apache Xalan2 to process the XSLT templates. The initial implementation of the presentation-planning module—of which the XSLT-based sentence planner described here is just a part—took approximately one month. After that, the module was debugged and updated incrementally over a period of several months, during which time additional templates were created to support upd</context>
</contexts>
<marker>Reiter, Dale, 2000</marker>
<rawString>Ehud Reiter and Robert Dale. 2000. Building Natural Language Generation Systems. Cambridge University Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Mark Steedman</author>
</authors>
<title>The Syntactic Process.</title>
<date>2000</date>
<publisher>MIT Press.</publisher>
<contexts>
<context position="4484" citStr="Steedman, 2000" startWordPosition="688" endWordPosition="690">Multimodal Interaction with Computers; http://www.hcrc.ed.ac.uk/comic/. (a) Avatar (b) Bathroom-design application Figure 1: Components of the COMIC demonstrator decorating the user’s bathroom, as in the following description of a set of tiles: (1) Here is a country design. It uses tiles from Coem’s Armonie series. The tiles are terracotta and beige, giving the room the feeling of a Tuscan country home. There are floral motifs on the decorative tiles. 2.2 OpenCCG The OpenCCG realizer (White and Baldridge, 2003) is a practical, open-source realizer based on Combinatory Categorial Grammar (CCG; Steedman, 2000). It employs a novel ensemble of methods for improving the efficiency of CCG realization, and in particular, makes integrated use of n-gram scoring of possible realizations in its chart realization algorithm (White, 2004a; White, 2004b). The n-gram scoring allows the realizer to work in “anytime” mode—able at any time to return the highestscoring complete realization—and ensures that a good realization can be found reasonably quickly even when the number of possibilities is exponential. Like other realizers, the OpenCCG realizer is partially responsible for determining word order and inflectio</context>
</contexts>
<marker>Steedman, 2000</marker>
<rawString>Mark Steedman. 2000. The Syntactic Process. MIT Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Michael White</author>
</authors>
<title>Efficient realization of coordinate structures in Combinatory Categorial Grammar. Research on Language and Computation.</title>
<date>2004</date>
<note>To appear.</note>
<contexts>
<context position="1256" citStr="White, 2004" startWordPosition="179" endWordPosition="180">ration. 1 Introduction In the traditional pipeline view of natural language generation (Reiter and Dale, 2000), many steps involve converting between increasingly specific tree representations. As Wilcock (2001) points out, this sort of tree-to-tree transformation is a task to which XML—and particularly XSLT template processing—is particularly suited. In this paper, we describe how we plan text by treating the XSLT processor as a top-down ruleexpanding planner that translates dialogue-manager specifications into logical forms to be sent to the OpenCCG text realizer (White and Baldridge, 2003; White, 2004a; White, 2004b). XSLT is used to perform many text-planning tasks, including structuring and aggregating the content, performing lexical choice via the selection of logical-form templates, and generating multiple alternative realizations for messages where possible. Using an external realizer at the end of the planning process provides two advantages. First, we can use the realizer to deal with those aspects of surface realization that are difficult to implement in XSLT, but that the realizer is designed to handle (e.g., syntactic agreement via unification). Second, we take advantage of OpenC</context>
<context position="4704" citStr="White, 2004" startWordPosition="724" endWordPosition="725">n of a set of tiles: (1) Here is a country design. It uses tiles from Coem’s Armonie series. The tiles are terracotta and beige, giving the room the feeling of a Tuscan country home. There are floral motifs on the decorative tiles. 2.2 OpenCCG The OpenCCG realizer (White and Baldridge, 2003) is a practical, open-source realizer based on Combinatory Categorial Grammar (CCG; Steedman, 2000). It employs a novel ensemble of methods for improving the efficiency of CCG realization, and in particular, makes integrated use of n-gram scoring of possible realizations in its chart realization algorithm (White, 2004a; White, 2004b). The n-gram scoring allows the realizer to work in “anytime” mode—able at any time to return the highestscoring complete realization—and ensures that a good realization can be found reasonably quickly even when the number of possibilities is exponential. Like other realizers, the OpenCCG realizer is partially responsible for determining word order and inflection. For example, the realizer determines that also should preferably follow the verb in There are also floral motifs on the decorative tiles, whereas in other cases it typically precedes the verb, as in It also has abstra</context>
</contexts>
<marker>White, 2004</marker>
<rawString>Michael White. 2004a. Efficient realization of coordinate structures in Combinatory Categorial Grammar. Research on Language and Computation. To appear.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Michael White</author>
</authors>
<title>Reining in CCG chart realization.</title>
<date>2004</date>
<booktitle>In Proceedings of INLG</booktitle>
<note>To appear.</note>
<contexts>
<context position="1256" citStr="White, 2004" startWordPosition="179" endWordPosition="180">ration. 1 Introduction In the traditional pipeline view of natural language generation (Reiter and Dale, 2000), many steps involve converting between increasingly specific tree representations. As Wilcock (2001) points out, this sort of tree-to-tree transformation is a task to which XML—and particularly XSLT template processing—is particularly suited. In this paper, we describe how we plan text by treating the XSLT processor as a top-down ruleexpanding planner that translates dialogue-manager specifications into logical forms to be sent to the OpenCCG text realizer (White and Baldridge, 2003; White, 2004a; White, 2004b). XSLT is used to perform many text-planning tasks, including structuring and aggregating the content, performing lexical choice via the selection of logical-form templates, and generating multiple alternative realizations for messages where possible. Using an external realizer at the end of the planning process provides two advantages. First, we can use the realizer to deal with those aspects of surface realization that are difficult to implement in XSLT, but that the realizer is designed to handle (e.g., syntactic agreement via unification). Second, we take advantage of OpenC</context>
<context position="4704" citStr="White, 2004" startWordPosition="724" endWordPosition="725">n of a set of tiles: (1) Here is a country design. It uses tiles from Coem’s Armonie series. The tiles are terracotta and beige, giving the room the feeling of a Tuscan country home. There are floral motifs on the decorative tiles. 2.2 OpenCCG The OpenCCG realizer (White and Baldridge, 2003) is a practical, open-source realizer based on Combinatory Categorial Grammar (CCG; Steedman, 2000). It employs a novel ensemble of methods for improving the efficiency of CCG realization, and in particular, makes integrated use of n-gram scoring of possible realizations in its chart realization algorithm (White, 2004a; White, 2004b). The n-gram scoring allows the realizer to work in “anytime” mode—able at any time to return the highestscoring complete realization—and ensures that a good realization can be found reasonably quickly even when the number of possibilities is exponential. Like other realizers, the OpenCCG realizer is partially responsible for determining word order and inflection. For example, the realizer determines that also should preferably follow the verb in There are also floral motifs on the decorative tiles, whereas in other cases it typically precedes the verb, as in It also has abstra</context>
</contexts>
<marker>White, 2004</marker>
<rawString>Michael White. 2004b. Reining in CCG chart realization. In Proceedings of INLG 2004. To appear.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Michael White</author>
<author>Jason Baldridge</author>
</authors>
<title>Adapting chart realization to CCG.</title>
<date>2003</date>
<booktitle>In Proceedings of EWNLG-03.</booktitle>
<contexts>
<context position="1243" citStr="White and Baldridge, 2003" startWordPosition="175" endWordPosition="178">ns in natural language generation. 1 Introduction In the traditional pipeline view of natural language generation (Reiter and Dale, 2000), many steps involve converting between increasingly specific tree representations. As Wilcock (2001) points out, this sort of tree-to-tree transformation is a task to which XML—and particularly XSLT template processing—is particularly suited. In this paper, we describe how we plan text by treating the XSLT processor as a top-down ruleexpanding planner that translates dialogue-manager specifications into logical forms to be sent to the OpenCCG text realizer (White and Baldridge, 2003; White, 2004a; White, 2004b). XSLT is used to perform many text-planning tasks, including structuring and aggregating the content, performing lexical choice via the selection of logical-form templates, and generating multiple alternative realizations for messages where possible. Using an external realizer at the end of the planning process provides two advantages. First, we can use the realizer to deal with those aspects of surface realization that are difficult to implement in XSLT, but that the realizer is designed to handle (e.g., syntactic agreement via unification). Second, we take advan</context>
<context position="4385" citStr="White and Baldridge, 2003" startWordPosition="673" endWordPosition="676">e on the textual content of those turns in which the system describes one or more options for 1COnversational Multimodal Interaction with Computers; http://www.hcrc.ed.ac.uk/comic/. (a) Avatar (b) Bathroom-design application Figure 1: Components of the COMIC demonstrator decorating the user’s bathroom, as in the following description of a set of tiles: (1) Here is a country design. It uses tiles from Coem’s Armonie series. The tiles are terracotta and beige, giving the room the feeling of a Tuscan country home. There are floral motifs on the decorative tiles. 2.2 OpenCCG The OpenCCG realizer (White and Baldridge, 2003) is a practical, open-source realizer based on Combinatory Categorial Grammar (CCG; Steedman, 2000). It employs a novel ensemble of methods for improving the efficiency of CCG realization, and in particular, makes integrated use of n-gram scoring of possible realizations in its chart realization algorithm (White, 2004a; White, 2004b). The n-gram scoring allows the realizer to work in “anytime” mode—able at any time to return the highestscoring complete realization—and ensures that a good realization can be found reasonably quickly even when the number of possibilities is exponential. Like othe</context>
</contexts>
<marker>White, Baldridge, 2003</marker>
<rawString>Michael White and Jason Baldridge. 2003. Adapting chart realization to CCG. In Proceedings of EWNLG-03.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Michael White</author>
<author>Ted Caldwell</author>
</authors>
<title>EXEMPLARS: A practical, extensible framework for dynamic text generation.</title>
<date>1998</date>
<booktitle>In Proceedings ofINLG</booktitle>
<contexts>
<context position="20852" citStr="White and Caldwell, 1998" startWordPosition="2986" endWordPosition="2989">hrase. In such cases, the text planner prunes out the failing possibilities before sending the set of options to the realizer, using the template shown in Figure 10. 5 Related Work The work presented here continues in the tradition of several recent NLG systems that use what could be called generalized template-based processing. By generalized, we mean that, rather than manipulating flat strings with no underlying linguistic representation, these systems instead work with structured fragments, which are often processed recursively. Other systems that fall into this category include EXEMPLARS (White and Caldwell, 1998), D2S (van Deemter et al., 1999), Interact &lt;xsl:template match=&amp;quot;one-of&amp;quot;&gt; &lt;!-- Recursive pruning step --&gt; &lt;xsl:variable name=&amp;quot;pruned-alts&amp;quot;&gt; &lt;xsl:for-each select=&amp;quot;*&amp;quot;&gt; &lt;xsl:variable name=&amp;quot;pruned-alt&amp;quot;&gt; &lt;xsl:apply-templates select=&amp;quot;.&amp;quot;/&gt; &lt;/xsl:variable&gt; &lt;xsl:if test=&amp;quot;not(xalan:nodeset($pruned-alt)//fail)&amp;quot;&gt; &lt;xsl:copy-of select=&amp;quot;$pruned-alt&amp;quot;/&gt; &lt;/xsl:if&gt; &lt;/xsl:for-each&gt; &lt;/xsl:variable&gt; &lt;xsl:variable name=&amp;quot;num-remaining&amp;quot; select=&amp;quot;count(xalan:nodeset($pruned-alts)/*)&amp;quot;/&gt; &lt;!-- Propagation step --&gt; &lt;xsl:choose&gt; &lt;!-- keep one-of when multiple alts succeed --&gt; &lt;xsl:when test=&amp;quot;$num-remaining &gt; 1&amp;quot;&gt; &lt;one-of&gt; &lt;xsl</context>
</contexts>
<marker>White, Caldwell, 1998</marker>
<rawString>Michael White and Ted Caldwell. 1998. EXEMPLARS: A practical, extensible framework for dynamic text generation. In Proceedings ofINLG 1998.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Graham Wilcock</author>
</authors>
<title>Pipelines, templates and transformations: XML for natural language generation.</title>
<date>2001</date>
<booktitle>In Proceedings ofNLPUML-2001.</booktitle>
<contexts>
<context position="856" citStr="Wilcock (2001)" startWordPosition="119" endWordPosition="120">n approach to text planning that uses the XSLT template-processing engine to create logical forms for an external surface realizer. Using a realizer that can process logical forms with embedded alternatives provides a substitute for backtracking in the text-planning process. This allows the text planner to combine the strengths of the AI-planning and template-based traditions in natural language generation. 1 Introduction In the traditional pipeline view of natural language generation (Reiter and Dale, 2000), many steps involve converting between increasingly specific tree representations. As Wilcock (2001) points out, this sort of tree-to-tree transformation is a task to which XML—and particularly XSLT template processing—is particularly suited. In this paper, we describe how we plan text by treating the XSLT processor as a top-down ruleexpanding planner that translates dialogue-manager specifications into logical forms to be sent to the OpenCCG text realizer (White and Baldridge, 2003; White, 2004a; White, 2004b). XSLT is used to perform many text-planning tasks, including structuring and aggregating the content, performing lexical choice via the selection of logical-form templates, and genera</context>
<context position="21799" citStr="Wilcock, 2001" startWordPosition="3077" endWordPosition="3078">&amp;quot;/&gt; &lt;/xsl:if&gt; &lt;/xsl:for-each&gt; &lt;/xsl:variable&gt; &lt;xsl:variable name=&amp;quot;num-remaining&amp;quot; select=&amp;quot;count(xalan:nodeset($pruned-alts)/*)&amp;quot;/&gt; &lt;!-- Propagation step --&gt; &lt;xsl:choose&gt; &lt;!-- keep one-of when multiple alts succeed --&gt; &lt;xsl:when test=&amp;quot;$num-remaining &gt; 1&amp;quot;&gt; &lt;one-of&gt; &lt;xsl:copy-of select=&amp;quot;$pruned-alts&amp;quot;/&gt; &lt;/one-of&gt; &lt;/xsl:when&gt; &lt;!-- filter out one-of when just one choice remains --&gt; &lt;xsl:when test=&amp;quot;$num-remaining = 1&amp;quot;&gt; &lt;xsl:copy-of select=&amp;quot;$pruned-alts&amp;quot;/&gt; &lt;/xsl:when&gt; &lt;!-- fail if none remain --&gt; &lt;xsl:otherwise&gt; &lt;fail/&gt; &lt;/xsl:otherwise&gt; &lt;/xsl:choose&gt; &lt;/xsl:template&gt; Figure 10: Failure-pruning template (Wilcock, 2001; Wilcock, 2003), and SmartKom (Becker, 2002). The main novel contribution of the text-planning approach described here is in its use of an external realizer that processes logical forms with embedded alternatives. This eliminates the need to use a backtracking AI planner (Becker, 2002) or to make arbitrary choices when multiple alternatives are available (van Deemter et al., 1999). The realizer also uses a completely different algorithm than the XSLT template processing—bottom-up, chartbased search rather than top-down rule expansion— which allows it to deal with those aspects of NLG that are</context>
</contexts>
<marker>Wilcock, 2001</marker>
<rawString>Graham Wilcock. 2001. Pipelines, templates and transformations: XML for natural language generation. In Proceedings ofNLPUML-2001.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Graham Wilcock</author>
</authors>
<title>Integrating natural language generation with XML web technology.</title>
<date>2003</date>
<booktitle>In Proceedings ofEACL-2003 Demo Sessions.</booktitle>
<contexts>
<context position="21815" citStr="Wilcock, 2003" startWordPosition="3079" endWordPosition="3080">/xsl:for-each&gt; &lt;/xsl:variable&gt; &lt;xsl:variable name=&amp;quot;num-remaining&amp;quot; select=&amp;quot;count(xalan:nodeset($pruned-alts)/*)&amp;quot;/&gt; &lt;!-- Propagation step --&gt; &lt;xsl:choose&gt; &lt;!-- keep one-of when multiple alts succeed --&gt; &lt;xsl:when test=&amp;quot;$num-remaining &gt; 1&amp;quot;&gt; &lt;one-of&gt; &lt;xsl:copy-of select=&amp;quot;$pruned-alts&amp;quot;/&gt; &lt;/one-of&gt; &lt;/xsl:when&gt; &lt;!-- filter out one-of when just one choice remains --&gt; &lt;xsl:when test=&amp;quot;$num-remaining = 1&amp;quot;&gt; &lt;xsl:copy-of select=&amp;quot;$pruned-alts&amp;quot;/&gt; &lt;/xsl:when&gt; &lt;!-- fail if none remain --&gt; &lt;xsl:otherwise&gt; &lt;fail/&gt; &lt;/xsl:otherwise&gt; &lt;/xsl:choose&gt; &lt;/xsl:template&gt; Figure 10: Failure-pruning template (Wilcock, 2001; Wilcock, 2003), and SmartKom (Becker, 2002). The main novel contribution of the text-planning approach described here is in its use of an external realizer that processes logical forms with embedded alternatives. This eliminates the need to use a backtracking AI planner (Becker, 2002) or to make arbitrary choices when multiple alternatives are available (van Deemter et al., 1999). The realizer also uses a completely different algorithm than the XSLT template processing—bottom-up, chartbased search rather than top-down rule expansion— which allows it to deal with those aspects of NLG that are more easily add</context>
</contexts>
<marker>Wilcock, 2003</marker>
<rawString>Graham Wilcock. 2003. Integrating natural language generation with XML web technology. In Proceedings ofEACL-2003 Demo Sessions.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>