<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<title confidence="0.4204715">
ALGORITHMS FOR GENERATION IN LAMBEK
THEOREM PROVING
</title>
<author confidence="0.826998">
Erik-Jan van der Linden *
Guido Minnen
</author>
<affiliation confidence="0.9871125">
Institute for Language Technology and Artificial Intelligence
Tilburg University
</affiliation>
<address confidence="0.945717">
PO Box 90153, 5000 LE Tilburg, The Netherlands
</address>
<email confidence="0.965483">
E-mail: vdlindenakub.n1
</email>
<sectionHeader confidence="0.992389" genericHeader="abstract">
ABSTRACT
</sectionHeader>
<bodyText confidence="0.999679818181818">
We discuss algorithms for generation within the
Lambek Theorem Proving Framework. Efficient
algorithms for generation in this framework take
a semantics-driven strategy. This strategy can
be modeled by means of rules in the calculus that
are geared to generation, or by means of an al-
gorithm for the Theorem Prover. The latter pos-
sibility enables processing of a bidirectional cal-
culus. Therefore Lambek Theorem Proving is a
natural candidate for a &apos;uniform&apos; architecture for
natural language parsing and generation.
</bodyText>
<keyword confidence="0.662954">
Keywords: generation algorithm; natural lan-
guage generation; theorem proving; bidirection-
ality; categorial grammar.
</keyword>
<sectionHeader confidence="0.999786" genericHeader="keywords">
1 INTRODUCTION
</sectionHeader>
<bodyText confidence="0.976513736842106">
Algorithms for tactical generation are becoming
an increasingly important subject of research in
computational linguistics (Shieber, 1988; Shieber
et al., 1989; Calder et al., 1989). In this pa-
per, we will discuss generation algorithms within
the Lambek Theorem Proving (LTP) framework
(Moortgat, 1988; Lambek, 1958; van Benthem,
1986). In section (2) we give an introduction to a
categorial calculus that is extended towards bidi-
rectionality. The naive top-down control strategy
in this section does not suit the needs of efficient
generation. Next, we discuss two ways to imple-
ment a semantics-driven strategy. Firstly, we add
inference rules and cut rules geared to generation
to the calculus (3). Secondly, since these changes
in the calculus do not support bidirectionality, we
&apos;We would like to thank Cosse Bou.ma, Wietske
Siitsma and Marianne Sanders for their comments on an
earlier draft of the paper.
</bodyText>
<page confidence="0.956706">
220
</page>
<bodyText confidence="0.9935995">
introduce a second implementation: a bottom-up
algorithm for the theorem prover (4).
</bodyText>
<sectionHeader confidence="0.9996845" genericHeader="introduction">
2 EXTENDING THE CAL-
CULUS
</sectionHeader>
<bodyText confidence="0.998062444444445">
Natural Language Processing as deduction
The architectures in this paper resemble the uni-
form architecture in Shieber (1988) because lan-
guage processing is viewed as logical deduction, in
analysis and generation:
&amp;quot;The generation of strings matching some crite-
ria can equally well be thought of as a deductive
process, namely a process of constructive proof of
the existence of a string that matches the crite-
ria.&amp;quot; (Shieber, 1988, p. 614).
In the LTP framework a categorial reduction sys-
tem is viewed as a logical calculus where parsing
a syntagm is an attempt to show that it follows
from a set of axioms and inference rules. These
inference rules describe what the processor does in
assembling a semantic representation (representa-
tional non-autonomy: Crain and Steedman, 1982;
Ades and Steedman, 1982). Derivation trees rep-
resent a particular parse process (Bouma, 1989).
These rules thus seem to be nondeclarative, and
this raises the question whether they can be used
for generation. The answer to this question will
emerge throughout this paper.
Lexical information As in any categorial
grammar, linguistic information in LTP is for the
larger part represented with the signs in the lex-
icon and not with the rules of the calculus (signs
are denoted by prosody:syntax:semantics). A
generator using a categorial grammar needs lex-
ical information about the syntactic form of a
functor that is connected to some semantic func-
tor in order to syntactically correctly generate the
semantic arguments of this functor. For a parser,
the reverse is true. In order to fulfil both needs,
lexical information is made available to the the-
orem prover in the form of instances of azioms.1
Axioms then truely represent what should be ax-
iomatic in a lexicalist description of a language:
the lexical items, the connections between form
and meaning.3
Rules Whenever inference rules are applied, an
attempt is made to axiomatize the functor that
participates in the inference by the first subse-
quent of the elimination rules. This way, lexical
information is retrieved from the lexicon.
A prosodic operator connects prosodic ele-
ments. A prosodic identity element, id, is neces-
sary because introduction rules are prosodically
vacuous. In order to avoid unwanted matching
between axioms and id-elements, one special ax-
iom is added for id-elements. Meta-logical checks
are included in the rules in order to avoid vari-
ables occuring in the final derivation. nogenvar
recursively checks whether any part of an expres-
sion is a variable.
A sequent in the calculus is denoted with
P =7 T, where P, called the antecedent, and T,
the succedent, are finite sequences of signs. The
calculus is presented in (1) . In what follows, X
and Y are categories; T and Z, are signs; R, U
and V are possibly empty sequences of signs;
denotes functional application, a caret denotes A-
abstraction.3
</bodyText>
<equation confidence="0.6352334">
(1)
/a axioms */
[Prom:X:Y] Dros:i: &lt;-
[Pros:X:Irl •1&gt; [Pros:X:Y]
true.
</equation>
<bodyText confidence="0.9442067">
[Pros:X:Y] &gt; [Pros:X:Y] &lt;-
(nogenvar(X), nonvar(Y))
true.
&apos;Van der Linden and Minnen (submitted) contains a
more elaborate comparison of the extended calculus with
the original calculus as proposed in Moortgat (1988).
&apos;A suggestion similar to this proposal was made by
Icinig (1989) who stated that lexical items are to be seen
as axioms, but did not include them as such in her de-
scription of the L-colculus.
</bodyText>
<subsectionHeader confidence="0.472434">
3Throughout this paper we will use a Prolog notation
because the architectures presented here depend partly on
</subsectionHeader>
<bodyText confidence="0.288329">
the Prolog unification mechanism. 221
</bodyText>
<figure confidence="0.895266466666667">
/* elimination rules */
(U,[Pros_Fu:X/Y:Fuuctor],[TIR],V)=&gt;[Z] ‹-
CPros_Fu:X/Y:Flinctor] &apos;*&gt;
[Pros_Fu:X/Y:Functor] I
[TIR] ■&gt; CPros_1rg:Y:Argl I
(U, [(Pros_Pu*Pros_Arg):X:FunctoreArg] V) &gt;
En.
(UJTIRJ,[Pros_Fu:YIX:FunctorLY) &apos;› [Z] &lt;-
(Prosju:Y\X:Functor) =&gt;
[Pros_Fu:Y\X:Functor]
[TM] =&gt; [Pros_Arg:T:Arg] I
(U,[(Pros_Arg*Pros_Pn):X:FunctoreArg],V) =&gt;
[Z].
/0 introduction rules */
[TIRJ=Y[Pros:Y\X:Var_Y-Term_X] C-
nosenvar(M)
([id:Y:Var_Y],[TIRD
[(id*Pros):X:Term_Z].
[TM] [Pros:X/Y:Var_Y&apos;Term_ij ‹-
nogenvar(X/Y) k
([TIR],[id:Y:Var_Y]) *);
[(Pros*id):X:Term_X].
/* axiom for prosodic id-element 0/
Eid:X:Y] [id:X:Y3 &lt;-
isvar(Y).
/* lexicon, Iexioms */
[john:np:John] ,E1&gt; [john:np:john].
psary:np:mary) l&gt; Esary:np:mary).
[loves:(np\s)/np:loves]
[loves:(np\s)/np:loves].
</figure>
<bodyText confidence="0.999912833333333">
In order to initiate analysis, the theorem prover is
presented with sequents like (2). Inference rules
are applied recursively to the antecedent of the
sequent until axioms are found. This regime can
be called top-down from the point of view of prob-
lem solving and bottom-up from a &amp;quot;parsing&amp;quot; point
of view. For generation, a sequent like (3) is pre-
sented to the theorem prover. Both analysis and
generation result in a derivation like (4). Note
that generation not only results in a sequence of
lexical signs, but also in a prosodic phrasing that
could be helpful for speech generation.
</bodyText>
<equation confidence="0.2552655">
ohn : A :B , loves :C: D , wary E : FJ &gt; [Pros:s:Sem.)
U =&gt; [Pxos:a:lovesemaryejohn]
</equation>
<bodyText confidence="0.953399">
Although both (2) and (3) result in (4), in the
case of generation, (4) does not represent the
</bodyText>
<figure confidence="0.471068636363636">
(4)
john:np:john loves:(np\e)/np:loves mary:np:mary •). john*(loves*mary):s:lovesOmaryijohn &lt;-
loves:(np\s)/np:loves •&gt; loves:(npW/np:loves &lt;-
1oves:(np\s)/np:lovee ml) lovems:(np\s)/np:loves &lt;- true
mary:np:mary =&gt; mary:np:mary &lt;-
mary:np:mary •1&gt; mary:np:mary &lt;- true
john:np:john loves*mary:np\a:lovesemary &gt; john*(lovesemary):e:lovesemaryljohn ‹-
lovessmary:np\s:lovesOmary =&gt; loyea*marymp\a:lovesemary &lt;- true
john:np:john &gt; john:np:john &lt;-
john:np:john =1&gt; john:np:john &lt;- true
john*(loves*mary):11:lovesOmaryljohn =&gt; johns(lovesemary):11:lovesemaryljohn:&lt;- true
</figure>
<bodyText confidence="0.9998805">
exact proceedings of the theorem prover. It
starts applying rules, matching them with the an-
tecedent, without making use of the original se-
mantic information, and thus resulting in an in-
efficient and nondeterministic generation process:
all possible derivations including all lexical items
are generated until some derivation is found that
results in the succedent.4 We conclude that the
algorithm normally used for parsing in LTP is in-
efficient with respect to generation.
</bodyText>
<sectionHeader confidence="0.9970805" genericHeader="method">
3 CALCULI DESIGNED
FOR GENERATION
</sectionHeader>
<bodyText confidence="0.999845521739131">
A solution to the efficiency problem raised in
the previous section is to start from the origi-
nal semantics. In this section we discuss calculi
that make explicit use of the original semantics.
Firstly, we present Lambek-like rules especially
designed for generation. Secondly, we introduce
a Cut-rule for generation with sets of categorial
reduction rules. Both entail a variant of the cru-
cial starting-point of the semantic-head-driven al-
gorithms described in Calder et al. (198) and
Shieber et al. (1989): if the functor of a semantic
representation can be identified, and can be re-
lated to a lexical representation containing syn-
tactic information, it is possible to generate the
arguments syntactically. The efficiency of this
strategy stems from the fact that it is guided by
the known semantic and syntactic information,
and lexical information is retrieved as soon as pos-
sible.
In contrast to the semantic-head-driven ap-
proach, our semantic representations do not al-
low for immediate recognition of semantic heads:
these can only be identified after all arguments
</bodyText>
<note confidence="0.857527">
4e1&amp;quot;. Shieber et al. (1989) on top-down generation
algorithms.
</note>
<page confidence="0.932764">
222
</page>
<figureCaption confidence="0.5640815">
have been stripped of the functor recursively
(lovesamarytfidohn =7 lovesOmary =&gt; loves).
</figureCaption>
<bodyText confidence="0.985490764705882">
Calder et al. conjecture that their algorithm
&amp;quot;(...) extends naturally to the rules of compo-
sition, division and permutation of Combinatory
Categorial Grammar (Steedman, 1987) and the
Lambek Calculus (1958)&amp;quot; (Calder et al., 1989, p.
237).
This conjecture should be handled with care. As
we have stated before, inference rules in LTP de-
scribe how a processor operates, An important
difference with the categorial reduction rules of
Calder et al. is that inference-rules in LTP implic-
itly initiate the recursion of the parsing and gen-
eration process. Technically speaking, Lambek
rules cannot be arguments of the rule-predicate
of Calder et al. (1989, p. 237). The gist of our
strategy is similar to theirs, but the algorithms
differ.
</bodyText>
<subsectionHeader confidence="0.721287">
Lambek-like generation Rules are presented
</subsectionHeader>
<bodyText confidence="0.999834916666667">
in (5) that explicitly start from the known infor-
mation during generation: the syntax and seman-
tics of the succedent. Literally, the inference rule
states that a sequent consisting of an antecedent
that unifies with two sequences of signs U and
V, and a succedent that unifies with a sign with
semantics Sern_ru0Sem_Arg is a theorem of
the calculus if V reduces to a syntactic functor
looking for an argument on its left side with the
functor-meaning of the original semantics, and U
reduces to its argument. This rule is an equiva-
lent of the second elimination rule in (1).
</bodyText>
<figure confidence="0.997547727272727">
(5)
/0 elimination rule */
CILIF]
[(Pros_Arg*Pros_Fu) Sem_FulSea_Arg] &lt;-
✓ *&gt;1:Pros_Fu:Y1X:Sei_Fu] k
U *&gt;CPros_Arg:Y:Sem_Arg].
/* introduction-rule */
[TIR] *7 CPros:Yli:Var_T-Tera_IJ 4-
nogenvar(YIX) k
(C[iff;Y:Ver_VD,(TIR)) *)
Uid*Pros):X:Tera_1].
</figure>
<sectionHeader confidence="0.912052333333333" genericHeader="method">
4 A COMBINED BOT-
TOM-UP/TOP-DOWN
REGIME
</sectionHeader>
<bodyText confidence="0.996373133333333">
In this section, we describe an algorithm for
the theorem prover that proceeds in a combined
bottom-up/top-down fashion from the problem
solving point of view. It maintains the same
semantics-driven strategy, and enables efficient
generation with the bidirectional calculus in (1).
The algorithm results in derivations like (4), in
the same theorem prover architecture, be it along
another path.
A Cut-rule for generation A Cut-rule is a
structural rule that can be used within the L-
calculus to include partial proofs derived with
categorial reduction rules into other proofs. In
(6) a generation Cut-rule is presented together
with the AB-system.
</bodyText>
<figure confidence="0.846052166666667">
(6)
/* Cut-rule for generation */
[U.V] EPros_Z:Z:Sem_Z] &lt;-
EPros_X:X:Sem_X, Pros_Y;Y:Semin **&gt;
CPros_Z:Z:Sem_Z3
U =&gt; (Pros_X:X:Sem_10
✓ m&gt; EPros_nY:Sem_Y).
/* reduction rules, system AB */
Dros_Fu:I/Y:Functor. Pros_Arg:Y:Are ottit&gt;
(Pros_FU*Pros_Arg):X:FunctorlAre.
rPros_Arg:Y:Arg. Pros_Fu:Y\X;Functor] =*&gt;
(Pros_Arg*Pros_Pu):I:FunctorlAre.
</figure>
<bodyText confidence="0.999698551020408">
The generator regimes presented in this section
are semantics-driven: they start from a seman-
tic representation, assume that it is part of the
uppermost serpent within a derivation, and work
towards the lexical items, axioms, with the recur-
sive application of inference rules. From the point
of view of theorem proving, this process should
be described as a top-down problem solving strat-
egy. The rules in this section are, however, geared
towards generation. Use of these rules for pars-
ing would result in massive non-determinism. Ef-
ficient parsing and generation require different
rules: the calculus is not bidirectional. 223
Bidirectionality There are two reasons to
avoid duplication of grammars for generation and
interpretation. Firstly, it is theoretically more el-
egant and simple to make use of one grammar.
Secondly, for any language processing system, hu-
man or machine, it is more economic (Bunt, 1987,
p. 333). Scholars in the area of language gen-
eration have therefore pleaded in favour of the
bidireetionality of linguistic descriptions (Appelt,
1987).
Bidirectionality might in the first place be im-
plemented by using one grammar and two sepa-
rate algorithms for analysis and generation (Ja-
cobs, 1985; Calder et al., 1989). However, apart
from the desirability to make use of one and the
same grammar for generation and analysis, it
would be attractive to have one and the same
processing architecture for both analysis and gen-
eration. Although attempts to find such architec-
tures (Shieber, 1988) have been termed looking
for the fountain of youth&amp;quot;,6 it is a stimulating
question to what extent it is possible to use the
same architecture for both tasks.
Example An example will illustrate how our
algorithm proceeds. In order to generate from
a sign, the theorem prover assumes that it is
the succedent of one of the subseguents of one
of the inference rules (7-1/2). (In case of an
introduction rule the sign is matched with the
succedent of the headsequent; this implies a top-
down step.) If unification with one of these subse-
quents can be established, the other subsequents
and the headsequent can be partly instantiated.
These sequents can then serve as starting points
for further bottom-up processing. Firstly, the
headsequent is subjected to bottom-up process-
</bodyText>
<footnote confidence="0.678652">
5Ron Kaplan during discussion of the Shieber presen-
tation at Coling MS,
</footnote>
<figure confidence="0.915992863636364">
(7)
Generation of nounphrase the table. Start with sequent
P =&gt; [Pros:np:theetable3
1- Assume succedent is part of an axiom:
EProe:np:thelltable) =&gt; [Prommp:theetable]
2- Match axiom with last subsequent of an inference rule:
(U,(Pros_Fu:X/Y:FunctorLETIR3,V) =7 CZ] &lt;-
1:Pros_Fu:I/Y:Functor) =&gt; [Pros_Fu:X/Y:Fuactor] &amp;
ETIR] ,•&gt; [Pros_Arg:Y:Are &amp;
(U,I(Proe_Fu*Pros_Arg):X:FunctoreAre,V) =7 CZ].
Z = Pros:np:theatable; Functor = the; Arg = table; X = np; U = [ ]; V
3- Derive instantiated head sequent:
(Pros_Fu:np/Y:theL[TIR] =) Dros:ap:theltable)
4- No more applications in head sequent: Prove (bottom-up) first instantiated subsequent:
EProe_Pu:np/Y:the] =&gt; EPros_Fu:ap/Y:theJ
Unifies with the axiom for &amp;quot;the&amp;quot;: Pros_Fu = the; Y = n.
5- Prove (bottom-up) second instantiated subsequent:
[T I Ft] =&gt;1:Pros_Arg n: t ab140
Unifies with axiom for &amp;quot;table&amp;quot;: Pros_Arg = table; T = table:n:table; It = [ I
8- Prove (bottum-up) last subsequent: is a nonlexical axiom.
Uthe*table):np:thettablel =&gt; Uthe*table):np:theftable].
7- Final derivation:
</figure>
<construct confidence="0.567063166666667">
the:np/n:the table:n:table =&gt; the*table:np:theitable &lt;-
the:lip/a:the =7 the:np/a:the &lt;-
the:up/a:the =1&gt; the:ap/n:the &lt;- true
table:n:table =&gt; table:a:table &lt;-
table:a:table =1) table:n:table &lt;- true
the*table:np:theltable =&gt; thestable:np:theitable &lt;- true
</construct>
<page confidence="0.99762">
224
</page>
<bodyText confidence="0.9997495625">
ing (7-3), in order to axiomatize the head functor
as soon as possible. Bottom-up processing stops
when no more application operators can be elim-
Mated from the head sequent (7-4). Secondly,
working top-down, the other subsequents (7-4/5)
are made subject to bottom-up processing, and at
last the last subsequent (7-6). (7) presents gen-
eration of a nounphrase, the table.
Non-determinism A source for non-determin-
ism in the semantics-driven strategy is the fact
that the theorem prover forms hypotheses about
the direction a functor seeks its arguments, and
then checks these against the lexicon. A possibil-
ity here would be to use a calculus where dom-
inance and precedence are taken apart. We will
pursue this suggestion in future research.
</bodyText>
<sectionHeader confidence="0.999948" genericHeader="conclusions">
5 CONCLUDING
REMARKS
</sectionHeader>
<bodyText confidence="0.996147853658536">
Conclusion Efficient, bidirectional use of cat-
egorial calculi is possible if extensions are made
with respect to the calculus, and if a combined
bottom-up/top-down algorithm is used for gener-
ation. Analysis and generation take place within
the same processing architecture, with the same
linguistics descriptions, be it with the use of dif-
ferent algorithms. LTP thus serves as a natural
candidate for a uniform architecture of parsing
and generation.
Semantic non-monotonicity A constraint on
grammar formalisms that can be dealt with in
current generation systems is semantic mono-
tonicity (Shieber, 1988; but cf. Shieber et aL,
1989). The algorithm in Calder et al. (1989) re-
quires an even stricter constaint. Firstly, in van
der Linden and Minnen (submitted) we describe
how the addition of a unification-based semantics
to the calculus described here enables process-
ing of non-monotonic phenomena such as non-
compositional verb particles and idioms. Identity
semantics (cf. Calder et al. p. 235) should be
no problem in this respect. Secondly, unary rules
and type-raising (ibid.) are part of the Is-calculus,
and are neither fundamental problems.
Inverse 0-reduction A problem that exists for
all generation systems that include some form of
)-semantics is that generation necessitates the in-
verse operation of 0-reduction. Although we have
implemented algorithms for inverse ,0-reduction,
these are not computationally tractable.° A way
out could be the inclusion of a unification based
semantics.7
°Bunt (1987) states that an expression with n constants
results in 2&apos;s — possible inverse 0-reductions.
?As proposed in van der Linden and Minnen (submit-
tell) for the calculus in (2). 225
Implementation The algorithms and calculi
presented here have been implemented with the
use of modified versions of the cat egorial calculi
interpreter described in Moortgat (1988).
</bodyText>
<sectionHeader confidence="0.999889" genericHeader="references">
6 REFERENCES
</sectionHeader>
<reference confidence="0.997318461538461">
Ades, A., and Steedman, M., 1982 On the order
of words. Linguistics and Philosophy, 4, pp. 517-
558.
Appe1t, D.E., 1987 Bidirectional Grammars and
the Design of Natural Language Systems. In
Wilks, Y. (Ed.), Theoretical Issues in Natural
Language Processing. Las Cruces, New Mexico:
New Mexico State University, January 7-9, pp.
185-191.
Van Benthem, J., 1986 Categorial Grammar.
Chapter 7 in Van Benthern, J., Essays in Logi-
cal Semantics. Reidel, Dordrecht.
Boun-ta, G., 1989 Efficient Processing of Flexi-
ble Categorial Grammar. In Proceedings of the
EACL 1989, Manchester. pp. 19-26.
Bunt, H., 1987 Utterance generation from seman-
tic representations augmented with pragmatic in-
formation. In Kempen 1987.
Calder, J., Reape M., and Zeevat, H., 1989 An
algorithm for generation in Unification Catego-
rial Grammar. In Proceedings of the EACL 1989,
Manchester. pp. 233-240.
Crain, S., and Steedman, M., 1982 On not being
led up the garden path. In Dowty, Karttunen and
Zwicky (Eds.) Natural language parsing. Cam-
bridge: Cambridge University Press.
Jacobs, P., 1985 PHRED, A generator for Natural
Language Interfaces. Computational Linguistics
11, 4, pp. 219-242.
Kempen , G., (Ed.) 1987 Natural language gen-
eration: new results in. artificial intelligence, psy-
chology and linguistics. Dordrecht: Nijhoff.
KOnig, E., 1989 Parsing as natural deduction. In
Proceedings of the ACL 1989, Vancouver.
Lambek, J., 1958 The mathematics of sentence
structure. Am.. Math Monthly, 65, 154-169.
Linden, E. van der, and Minnen, G., (submit-
ted) An account of Non-monotonous phenomena
in bidirectional Lambek Theorem Proving.
Moortgat, M., 1988 Categorial Investigations.
Logical and linguistic aspects of the Lanatek cal-
culus. Disseration, University of Amsterdam.
Shieber, S., 1988 A uniform architecture for Pars-
ing and Generation. In Proceedings of Coling
1988, Budapest, pp. 614-619.
Shieber, S., van Noord, G., Moore, R., and
Pereira, P., 1989 A semantic-Head-Driven Gen-
eration Algorithm for Unification-Based For-
malisms. In Proceedings of ACL 1989 Vancouver.
Steedman, M., 1987 Combinatory Grammars and
Parasitic Gaps Natural Language and Linguistic
Theory, 5, pp. 403-439.
</reference>
<page confidence="0.998803">
226
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.269104">
<title confidence="0.999022">ALGORITHMS FOR GENERATION IN LAMBEK THEOREM PROVING</title>
<author confidence="0.8010395">Erik-Jan van_der_Linden Guido Minnen</author>
<affiliation confidence="0.999015">Institute for Language Technology and Artificial Intelligence Tilburg University</affiliation>
<address confidence="0.849073">PO Box 90153, 5000 LE Tilburg, The Netherlands</address>
<email confidence="0.812149">E-mail:vdlindenakub.n1</email>
<abstract confidence="0.999873">We discuss algorithms for generation within the Lambek Theorem Proving Framework. Efficient algorithms for generation in this framework take a semantics-driven strategy. This strategy can be modeled by means of rules in the calculus that are geared to generation, or by means of an algorithm for the Theorem Prover. The latter possibility enables processing of a bidirectional calculus. Therefore Lambek Theorem Proving is a natural candidate for a &apos;uniform&apos; architecture for natural language parsing and generation.</abstract>
<keyword confidence="0.826060666666667">Keywords: generation algorithm; natural language generation; theorem proving; bidirectionality; categorial grammar.</keyword>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>A Ades</author>
<author>M Steedman</author>
</authors>
<title>On the order of words.</title>
<date>1982</date>
<journal>Linguistics and Philosophy,</journal>
<volume>4</volume>
<pages>517--558</pages>
<contexts>
<context position="2728" citStr="Ades and Steedman, 1982" startWordPosition="412" endWordPosition="415">tion, in analysis and generation: &amp;quot;The generation of strings matching some criteria can equally well be thought of as a deductive process, namely a process of constructive proof of the existence of a string that matches the criteria.&amp;quot; (Shieber, 1988, p. 614). In the LTP framework a categorial reduction system is viewed as a logical calculus where parsing a syntagm is an attempt to show that it follows from a set of axioms and inference rules. These inference rules describe what the processor does in assembling a semantic representation (representational non-autonomy: Crain and Steedman, 1982; Ades and Steedman, 1982). Derivation trees represent a particular parse process (Bouma, 1989). These rules thus seem to be nondeclarative, and this raises the question whether they can be used for generation. The answer to this question will emerge throughout this paper. Lexical information As in any categorial grammar, linguistic information in LTP is for the larger part represented with the signs in the lexicon and not with the rules of the calculus (signs are denoted by prosody:syntax:semantics). A generator using a categorial grammar needs lexical information about the syntactic form of a functor that is connecte</context>
</contexts>
<marker>Ades, Steedman, 1982</marker>
<rawString>Ades, A., and Steedman, M., 1982 On the order of words. Linguistics and Philosophy, 4, pp. 517-558.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D E Appe1t</author>
</authors>
<title>Bidirectional Grammars and the Design of Natural Language Systems. In</title>
<date>1987</date>
<pages>185--191</pages>
<institution>Mexico State University,</institution>
<location>New Mexico: New</location>
<marker>Appe1t, 1987</marker>
<rawString>Appe1t, D.E., 1987 Bidirectional Grammars and the Design of Natural Language Systems. In Wilks, Y. (Ed.), Theoretical Issues in Natural Language Processing. Las Cruces, New Mexico: New Mexico State University, January 7-9, pp. 185-191.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Van Benthem</author>
</authors>
<title>Categorial Grammar.</title>
<date>1986</date>
<journal>Chapter</journal>
<volume>7</volume>
<pages>in</pages>
<location>Reidel, Dordrecht.</location>
<marker>Van Benthem, 1986</marker>
<rawString>Van Benthem, J., 1986 Categorial Grammar. Chapter 7 in Van Benthern, J., Essays in Logical Semantics. Reidel, Dordrecht.</rawString>
</citation>
<citation valid="true">
<authors>
<author>G Boun-ta</author>
</authors>
<title>Efficient Processing of Flexible Categorial Grammar.</title>
<date>1989</date>
<booktitle>In Proceedings of the EACL 1989,</booktitle>
<pages>pp.</pages>
<location>Manchester.</location>
<marker>Boun-ta, 1989</marker>
<rawString>Boun-ta, G., 1989 Efficient Processing of Flexible Categorial Grammar. In Proceedings of the EACL 1989, Manchester. pp. 19-26.</rawString>
</citation>
<citation valid="true">
<authors>
<author>H Bunt</author>
</authors>
<title>Utterance generation from semantic representations augmented with pragmatic information. In</title>
<date>1987</date>
<location>Kempen</location>
<contexts>
<context position="12804" citStr="Bunt, 1987" startWordPosition="1908" endWordPosition="1909"> theorem proving, this process should be described as a top-down problem solving strategy. The rules in this section are, however, geared towards generation. Use of these rules for parsing would result in massive non-determinism. Efficient parsing and generation require different rules: the calculus is not bidirectional. 223 Bidirectionality There are two reasons to avoid duplication of grammars for generation and interpretation. Firstly, it is theoretically more elegant and simple to make use of one grammar. Secondly, for any language processing system, human or machine, it is more economic (Bunt, 1987, p. 333). Scholars in the area of language generation have therefore pleaded in favour of the bidireetionality of linguistic descriptions (Appelt, 1987). Bidirectionality might in the first place be implemented by using one grammar and two separate algorithms for analysis and generation (Jacobs, 1985; Calder et al., 1989). However, apart from the desirability to make use of one and the same grammar for generation and analysis, it would be attractive to have one and the same processing architecture for both analysis and generation. Although attempts to find such architectures (Shieber, 1988) h</context>
</contexts>
<marker>Bunt, 1987</marker>
<rawString>Bunt, H., 1987 Utterance generation from semantic representations augmented with pragmatic information. In Kempen 1987.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Calder</author>
<author>M Reape</author>
<author>H Zeevat</author>
</authors>
<title>An algorithm for generation in Unification Categorial Grammar.</title>
<date>1989</date>
<booktitle>In Proceedings of the EACL 1989,</booktitle>
<pages>233--240</pages>
<location>Manchester.</location>
<contexts>
<context position="1081" citStr="Calder et al., 1989" startWordPosition="149" endWordPosition="152">f rules in the calculus that are geared to generation, or by means of an algorithm for the Theorem Prover. The latter possibility enables processing of a bidirectional calculus. Therefore Lambek Theorem Proving is a natural candidate for a &apos;uniform&apos; architecture for natural language parsing and generation. Keywords: generation algorithm; natural language generation; theorem proving; bidirectionality; categorial grammar. 1 INTRODUCTION Algorithms for tactical generation are becoming an increasingly important subject of research in computational linguistics (Shieber, 1988; Shieber et al., 1989; Calder et al., 1989). In this paper, we will discuss generation algorithms within the Lambek Theorem Proving (LTP) framework (Moortgat, 1988; Lambek, 1958; van Benthem, 1986). In section (2) we give an introduction to a categorial calculus that is extended towards bidirectionality. The naive top-down control strategy in this section does not suit the needs of efficient generation. Next, we discuss two ways to implement a semantics-driven strategy. Firstly, we add inference rules and cut rules geared to generation to the calculus (3). Secondly, since these changes in the calculus do not support bidirectionality, w</context>
<context position="9489" citStr="Calder et al., 1989" startWordPosition="1409" endWordPosition="1412">l information is retrieved as soon as possible. In contrast to the semantic-head-driven approach, our semantic representations do not allow for immediate recognition of semantic heads: these can only be identified after all arguments 4e1&amp;quot;. Shieber et al. (1989) on top-down generation algorithms. 222 have been stripped of the functor recursively (lovesamarytfidohn =7 lovesOmary =&gt; loves). Calder et al. conjecture that their algorithm &amp;quot;(...) extends naturally to the rules of composition, division and permutation of Combinatory Categorial Grammar (Steedman, 1987) and the Lambek Calculus (1958)&amp;quot; (Calder et al., 1989, p. 237). This conjecture should be handled with care. As we have stated before, inference rules in LTP describe how a processor operates, An important difference with the categorial reduction rules of Calder et al. is that inference-rules in LTP implicitly initiate the recursion of the parsing and generation process. Technically speaking, Lambek rules cannot be arguments of the rule-predicate of Calder et al. (1989, p. 237). The gist of our strategy is similar to theirs, but the algorithms differ. Lambek-like generation Rules are presented in (5) that explicitly start from the known informat</context>
<context position="13128" citStr="Calder et al., 1989" startWordPosition="1958" endWordPosition="1961">ctional. 223 Bidirectionality There are two reasons to avoid duplication of grammars for generation and interpretation. Firstly, it is theoretically more elegant and simple to make use of one grammar. Secondly, for any language processing system, human or machine, it is more economic (Bunt, 1987, p. 333). Scholars in the area of language generation have therefore pleaded in favour of the bidireetionality of linguistic descriptions (Appelt, 1987). Bidirectionality might in the first place be implemented by using one grammar and two separate algorithms for analysis and generation (Jacobs, 1985; Calder et al., 1989). However, apart from the desirability to make use of one and the same grammar for generation and analysis, it would be attractive to have one and the same processing architecture for both analysis and generation. Although attempts to find such architectures (Shieber, 1988) have been termed looking for the fountain of youth&amp;quot;,6 it is a stimulating question to what extent it is possible to use the same architecture for both tasks. Example An example will illustrate how our algorithm proceeds. In order to generate from a sign, the theorem prover assumes that it is the succedent of one of the subs</context>
<context position="16979" citStr="Calder et al. (1989)" startWordPosition="2541" endWordPosition="2544"> calculi is possible if extensions are made with respect to the calculus, and if a combined bottom-up/top-down algorithm is used for generation. Analysis and generation take place within the same processing architecture, with the same linguistics descriptions, be it with the use of different algorithms. LTP thus serves as a natural candidate for a uniform architecture of parsing and generation. Semantic non-monotonicity A constraint on grammar formalisms that can be dealt with in current generation systems is semantic monotonicity (Shieber, 1988; but cf. Shieber et aL, 1989). The algorithm in Calder et al. (1989) requires an even stricter constaint. Firstly, in van der Linden and Minnen (submitted) we describe how the addition of a unification-based semantics to the calculus described here enables processing of non-monotonic phenomena such as noncompositional verb particles and idioms. Identity semantics (cf. Calder et al. p. 235) should be no problem in this respect. Secondly, unary rules and type-raising (ibid.) are part of the Is-calculus, and are neither fundamental problems. Inverse 0-reduction A problem that exists for all generation systems that include some form of )-semantics is that generati</context>
</contexts>
<marker>Calder, Reape, Zeevat, 1989</marker>
<rawString>Calder, J., Reape M., and Zeevat, H., 1989 An algorithm for generation in Unification Categorial Grammar. In Proceedings of the EACL 1989, Manchester. pp. 233-240.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S Crain</author>
<author>M Steedman</author>
</authors>
<title>On not being led up the garden path. In Dowty, Karttunen and Zwicky (Eds.) Natural language parsing. Cambridge:</title>
<date>1982</date>
<publisher>Cambridge University Press.</publisher>
<contexts>
<context position="2702" citStr="Crain and Steedman, 1982" startWordPosition="408" endWordPosition="411">is viewed as logical deduction, in analysis and generation: &amp;quot;The generation of strings matching some criteria can equally well be thought of as a deductive process, namely a process of constructive proof of the existence of a string that matches the criteria.&amp;quot; (Shieber, 1988, p. 614). In the LTP framework a categorial reduction system is viewed as a logical calculus where parsing a syntagm is an attempt to show that it follows from a set of axioms and inference rules. These inference rules describe what the processor does in assembling a semantic representation (representational non-autonomy: Crain and Steedman, 1982; Ades and Steedman, 1982). Derivation trees represent a particular parse process (Bouma, 1989). These rules thus seem to be nondeclarative, and this raises the question whether they can be used for generation. The answer to this question will emerge throughout this paper. Lexical information As in any categorial grammar, linguistic information in LTP is for the larger part represented with the signs in the lexicon and not with the rules of the calculus (signs are denoted by prosody:syntax:semantics). A generator using a categorial grammar needs lexical information about the syntactic form of </context>
</contexts>
<marker>Crain, Steedman, 1982</marker>
<rawString>Crain, S., and Steedman, M., 1982 On not being led up the garden path. In Dowty, Karttunen and Zwicky (Eds.) Natural language parsing. Cambridge: Cambridge University Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>P Jacobs</author>
</authors>
<title>PHRED, A generator for Natural Language Interfaces.</title>
<date>1985</date>
<journal>Computational Linguistics</journal>
<volume>11</volume>
<pages>219--242</pages>
<contexts>
<context position="13106" citStr="Jacobs, 1985" startWordPosition="1955" endWordPosition="1957"> is not bidirectional. 223 Bidirectionality There are two reasons to avoid duplication of grammars for generation and interpretation. Firstly, it is theoretically more elegant and simple to make use of one grammar. Secondly, for any language processing system, human or machine, it is more economic (Bunt, 1987, p. 333). Scholars in the area of language generation have therefore pleaded in favour of the bidireetionality of linguistic descriptions (Appelt, 1987). Bidirectionality might in the first place be implemented by using one grammar and two separate algorithms for analysis and generation (Jacobs, 1985; Calder et al., 1989). However, apart from the desirability to make use of one and the same grammar for generation and analysis, it would be attractive to have one and the same processing architecture for both analysis and generation. Although attempts to find such architectures (Shieber, 1988) have been termed looking for the fountain of youth&amp;quot;,6 it is a stimulating question to what extent it is possible to use the same architecture for both tasks. Example An example will illustrate how our algorithm proceeds. In order to generate from a sign, the theorem prover assumes that it is the succed</context>
</contexts>
<marker>Jacobs, 1985</marker>
<rawString>Jacobs, P., 1985 PHRED, A generator for Natural Language Interfaces. Computational Linguistics 11, 4, pp. 219-242.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kempen</author>
</authors>
<title>Natural language generation: new results in. artificial intelligence, psychology and linguistics.</title>
<date>1987</date>
<location>Dordrecht: Nijhoff.</location>
<marker>Kempen, 1987</marker>
<rawString>Kempen , G., (Ed.) 1987 Natural language generation: new results in. artificial intelligence, psychology and linguistics. Dordrecht: Nijhoff.</rawString>
</citation>
<citation valid="true">
<authors>
<author>E KOnig</author>
</authors>
<title>Parsing as natural deduction.</title>
<date>1989</date>
<booktitle>In Proceedings of the ACL 1989,</booktitle>
<location>Vancouver.</location>
<marker>KOnig, 1989</marker>
<rawString>KOnig, E., 1989 Parsing as natural deduction. In Proceedings of the ACL 1989, Vancouver.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Lambek</author>
</authors>
<title>The mathematics of sentence structure.</title>
<date>1958</date>
<journal>Am.. Math Monthly,</journal>
<volume>65</volume>
<pages>154--169</pages>
<contexts>
<context position="1215" citStr="Lambek, 1958" startWordPosition="171" endWordPosition="172">essing of a bidirectional calculus. Therefore Lambek Theorem Proving is a natural candidate for a &apos;uniform&apos; architecture for natural language parsing and generation. Keywords: generation algorithm; natural language generation; theorem proving; bidirectionality; categorial grammar. 1 INTRODUCTION Algorithms for tactical generation are becoming an increasingly important subject of research in computational linguistics (Shieber, 1988; Shieber et al., 1989; Calder et al., 1989). In this paper, we will discuss generation algorithms within the Lambek Theorem Proving (LTP) framework (Moortgat, 1988; Lambek, 1958; van Benthem, 1986). In section (2) we give an introduction to a categorial calculus that is extended towards bidirectionality. The naive top-down control strategy in this section does not suit the needs of efficient generation. Next, we discuss two ways to implement a semantics-driven strategy. Firstly, we add inference rules and cut rules geared to generation to the calculus (3). Secondly, since these changes in the calculus do not support bidirectionality, we &apos;We would like to thank Cosse Bou.ma, Wietske Siitsma and Marianne Sanders for their comments on an earlier draft of the paper. 220 </context>
</contexts>
<marker>Lambek, 1958</marker>
<rawString>Lambek, J., 1958 The mathematics of sentence structure. Am.. Math Monthly, 65, 154-169.</rawString>
</citation>
<citation valid="false">
<authors>
<author>E van der Linden</author>
<author>G Minnen</author>
</authors>
<title>(submitted) An account of Non-monotonous phenomena in bidirectional Lambek Theorem Proving.</title>
<marker>Linden, Minnen, </marker>
<rawString>Linden, E. van der, and Minnen, G., (submitted) An account of Non-monotonous phenomena in bidirectional Lambek Theorem Proving.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Moortgat</author>
</authors>
<title>Categorial Investigations. Logical and linguistic aspects of the Lanatek calculus. Disseration,</title>
<date>1988</date>
<institution>University of Amsterdam.</institution>
<contexts>
<context position="1201" citStr="Moortgat, 1988" startWordPosition="169" endWordPosition="170">ity enables processing of a bidirectional calculus. Therefore Lambek Theorem Proving is a natural candidate for a &apos;uniform&apos; architecture for natural language parsing and generation. Keywords: generation algorithm; natural language generation; theorem proving; bidirectionality; categorial grammar. 1 INTRODUCTION Algorithms for tactical generation are becoming an increasingly important subject of research in computational linguistics (Shieber, 1988; Shieber et al., 1989; Calder et al., 1989). In this paper, we will discuss generation algorithms within the Lambek Theorem Proving (LTP) framework (Moortgat, 1988; Lambek, 1958; van Benthem, 1986). In section (2) we give an introduction to a categorial calculus that is extended towards bidirectionality. The naive top-down control strategy in this section does not suit the needs of efficient generation. Next, we discuss two ways to implement a semantics-driven strategy. Firstly, we add inference rules and cut rules geared to generation to the calculus (3). Secondly, since these changes in the calculus do not support bidirectionality, we &apos;We would like to thank Cosse Bou.ma, Wietske Siitsma and Marianne Sanders for their comments on an earlier draft of t</context>
<context position="5073" citStr="Moortgat (1988)" startWordPosition="794" endWordPosition="795">calculus is denoted with P =7 T, where P, called the antecedent, and T, the succedent, are finite sequences of signs. The calculus is presented in (1) . In what follows, X and Y are categories; T and Z, are signs; R, U and V are possibly empty sequences of signs; denotes functional application, a caret denotes Aabstraction.3 (1) /a axioms */ [Prom:X:Y] Dros:i: &lt;- [Pros:X:Irl •1&gt; [Pros:X:Y] true. [Pros:X:Y] &gt; [Pros:X:Y] &lt;- (nogenvar(X), nonvar(Y)) true. &apos;Van der Linden and Minnen (submitted) contains a more elaborate comparison of the extended calculus with the original calculus as proposed in Moortgat (1988). &apos;A suggestion similar to this proposal was made by Icinig (1989) who stated that lexical items are to be seen as axioms, but did not include them as such in her description of the L-colculus. 3Throughout this paper we will use a Prolog notation because the architectures presented here depend partly on the Prolog unification mechanism. 221 /* elimination rules */ (U,[Pros_Fu:X/Y:Fuuctor],[TIR],V)=&gt;[Z] ‹- CPros_Fu:X/Y:Flinctor] &apos;*&gt; [Pros_Fu:X/Y:Functor] I [TIR] ■&gt; CPros_1rg:Y:Argl I (U, [(Pros_Pu*Pros_Arg):X:FunctoreArg] V) &gt; En. (UJTIRJ,[Pros_Fu:YIX:FunctorLY) &apos;› [Z] &lt;- (Prosju:Y\X:Functor) =</context>
</contexts>
<marker>Moortgat, 1988</marker>
<rawString>Moortgat, M., 1988 Categorial Investigations. Logical and linguistic aspects of the Lanatek calculus. Disseration, University of Amsterdam.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S Shieber</author>
</authors>
<title>A uniform architecture for Parsing and Generation.</title>
<date>1988</date>
<booktitle>In Proceedings of Coling 1988,</booktitle>
<pages>614--619</pages>
<location>Budapest,</location>
<contexts>
<context position="1037" citStr="Shieber, 1988" startWordPosition="143" endWordPosition="144">is strategy can be modeled by means of rules in the calculus that are geared to generation, or by means of an algorithm for the Theorem Prover. The latter possibility enables processing of a bidirectional calculus. Therefore Lambek Theorem Proving is a natural candidate for a &apos;uniform&apos; architecture for natural language parsing and generation. Keywords: generation algorithm; natural language generation; theorem proving; bidirectionality; categorial grammar. 1 INTRODUCTION Algorithms for tactical generation are becoming an increasingly important subject of research in computational linguistics (Shieber, 1988; Shieber et al., 1989; Calder et al., 1989). In this paper, we will discuss generation algorithms within the Lambek Theorem Proving (LTP) framework (Moortgat, 1988; Lambek, 1958; van Benthem, 1986). In section (2) we give an introduction to a categorial calculus that is extended towards bidirectionality. The naive top-down control strategy in this section does not suit the needs of efficient generation. Next, we discuss two ways to implement a semantics-driven strategy. Firstly, we add inference rules and cut rules geared to generation to the calculus (3). Secondly, since these changes in the</context>
<context position="2353" citStr="Shieber, 1988" startWordPosition="353" endWordPosition="354"> Marianne Sanders for their comments on an earlier draft of the paper. 220 introduce a second implementation: a bottom-up algorithm for the theorem prover (4). 2 EXTENDING THE CALCULUS Natural Language Processing as deduction The architectures in this paper resemble the uniform architecture in Shieber (1988) because language processing is viewed as logical deduction, in analysis and generation: &amp;quot;The generation of strings matching some criteria can equally well be thought of as a deductive process, namely a process of constructive proof of the existence of a string that matches the criteria.&amp;quot; (Shieber, 1988, p. 614). In the LTP framework a categorial reduction system is viewed as a logical calculus where parsing a syntagm is an attempt to show that it follows from a set of axioms and inference rules. These inference rules describe what the processor does in assembling a semantic representation (representational non-autonomy: Crain and Steedman, 1982; Ades and Steedman, 1982). Derivation trees represent a particular parse process (Bouma, 1989). These rules thus seem to be nondeclarative, and this raises the question whether they can be used for generation. The answer to this question will emerge </context>
<context position="13402" citStr="Shieber, 1988" startWordPosition="2005" endWordPosition="2006">omic (Bunt, 1987, p. 333). Scholars in the area of language generation have therefore pleaded in favour of the bidireetionality of linguistic descriptions (Appelt, 1987). Bidirectionality might in the first place be implemented by using one grammar and two separate algorithms for analysis and generation (Jacobs, 1985; Calder et al., 1989). However, apart from the desirability to make use of one and the same grammar for generation and analysis, it would be attractive to have one and the same processing architecture for both analysis and generation. Although attempts to find such architectures (Shieber, 1988) have been termed looking for the fountain of youth&amp;quot;,6 it is a stimulating question to what extent it is possible to use the same architecture for both tasks. Example An example will illustrate how our algorithm proceeds. In order to generate from a sign, the theorem prover assumes that it is the succedent of one of the subseguents of one of the inference rules (7-1/2). (In case of an introduction rule the sign is matched with the succedent of the headsequent; this implies a topdown step.) If unification with one of these subsequents can be established, the other subsequents and the headsequen</context>
<context position="16910" citStr="Shieber, 1988" startWordPosition="2530" endWordPosition="2531"> REMARKS Conclusion Efficient, bidirectional use of categorial calculi is possible if extensions are made with respect to the calculus, and if a combined bottom-up/top-down algorithm is used for generation. Analysis and generation take place within the same processing architecture, with the same linguistics descriptions, be it with the use of different algorithms. LTP thus serves as a natural candidate for a uniform architecture of parsing and generation. Semantic non-monotonicity A constraint on grammar formalisms that can be dealt with in current generation systems is semantic monotonicity (Shieber, 1988; but cf. Shieber et aL, 1989). The algorithm in Calder et al. (1989) requires an even stricter constaint. Firstly, in van der Linden and Minnen (submitted) we describe how the addition of a unification-based semantics to the calculus described here enables processing of non-monotonic phenomena such as noncompositional verb particles and idioms. Identity semantics (cf. Calder et al. p. 235) should be no problem in this respect. Secondly, unary rules and type-raising (ibid.) are part of the Is-calculus, and are neither fundamental problems. Inverse 0-reduction A problem that exists for all gene</context>
</contexts>
<marker>Shieber, 1988</marker>
<rawString>Shieber, S., 1988 A uniform architecture for Parsing and Generation. In Proceedings of Coling 1988, Budapest, pp. 614-619.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S Shieber</author>
<author>G van Noord</author>
<author>R Moore</author>
<author>P Pereira</author>
</authors>
<title>A semantic-Head-Driven Generation Algorithm for Unification-Based Formalisms.</title>
<date>1989</date>
<booktitle>In Proceedings of ACL</booktitle>
<location>Vancouver.</location>
<marker>Shieber, van Noord, Moore, Pereira, 1989</marker>
<rawString>Shieber, S., van Noord, G., Moore, R., and Pereira, P., 1989 A semantic-Head-Driven Generation Algorithm for Unification-Based Formalisms. In Proceedings of ACL 1989 Vancouver.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Steedman</author>
</authors>
<date>1987</date>
<booktitle>Combinatory Grammars and Parasitic Gaps Natural Language and Linguistic Theory,</booktitle>
<volume>5</volume>
<pages>403--439</pages>
<contexts>
<context position="9436" citStr="Steedman, 1987" startWordPosition="1402" endWordPosition="1403">wn semantic and syntactic information, and lexical information is retrieved as soon as possible. In contrast to the semantic-head-driven approach, our semantic representations do not allow for immediate recognition of semantic heads: these can only be identified after all arguments 4e1&amp;quot;. Shieber et al. (1989) on top-down generation algorithms. 222 have been stripped of the functor recursively (lovesamarytfidohn =7 lovesOmary =&gt; loves). Calder et al. conjecture that their algorithm &amp;quot;(...) extends naturally to the rules of composition, division and permutation of Combinatory Categorial Grammar (Steedman, 1987) and the Lambek Calculus (1958)&amp;quot; (Calder et al., 1989, p. 237). This conjecture should be handled with care. As we have stated before, inference rules in LTP describe how a processor operates, An important difference with the categorial reduction rules of Calder et al. is that inference-rules in LTP implicitly initiate the recursion of the parsing and generation process. Technically speaking, Lambek rules cannot be arguments of the rule-predicate of Calder et al. (1989, p. 237). The gist of our strategy is similar to theirs, but the algorithms differ. Lambek-like generation Rules are presented</context>
</contexts>
<marker>Steedman, 1987</marker>
<rawString>Steedman, M., 1987 Combinatory Grammars and Parasitic Gaps Natural Language and Linguistic Theory, 5, pp. 403-439.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>