<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000040">
<sectionHeader confidence="0.558514666666667" genericHeader="method">
ISSUES IN NATURAL LANGUAGE ACCESS TO DATABASES
FROM A LOGIC PROGRAMMING PERSPECTIVE
David H D Warren
Artificial Intelligence Center
SRI International, Menlo Park, CA 94025, USA
I INTRODUCTION
</sectionHeader>
<bodyText confidence="0.999163648936171">
I shall discuss issues in natural language
(NL) access to databases in the light of an
experimental NL question-answering system, Chat,
which I wrote with Fernando Pereira at Edinburgh
University, and which is described more fully
elsewhere [8] [61 [5]. Our approach was
strongly influenced by the work of Alain
Colmerauer [2] and Veronica Dahl [3] at
Marseille University.
Chat processes a NL question in three main
stages:
translation planning execution
English ----&gt; logic ----&gt; Prolog ----&gt; answer
corresponding roughly to: &amp;quot;What does the question
mean?&amp;quot;, &amp;quot;How shall I answer it?&amp;quot;, &amp;quot;What is the
answer?&amp;quot;. The meaning of a NL question, and the
database of information about the application
domain, are both represented as statements in an
extension of a subset of first-order logic, which
we call &amp;quot;definite closed world&amp;quot; (DCW) logic. This
logic is a subset of first-order logic, in that it
admits only &amp;quot;definite&amp;quot; statements; uncertain
information (&amp;quot;Either this or that&amp;quot;) is not
allowed. DCW logic extends first-order logic, in
that it provides constructions to support the
&amp;quot;closed world&amp;quot; assumption, that everything not
known to be true is false.
Why does Chat use this curious logic as a
meaning representation language? The main reason
is that it can be implemented very efficiently.
In fact, DCW logic forms the basis of a general
purpose programming language, Prolog [9] [1],
due to Colmerauer, which has had a wide variety of
applications. Prolog can be viewed either as an
extension of pure Lisp, or as an extension of a
relational database query language. Moreover, the
efficiency of the DEC-10 Prolog implementation is
comparable both with compiled Lisp [9] and with
current relational database systems [6] (for
databases within virtual memory).
Chat&apos;s second main stage, &amp;quot;planning&amp;quot;, is
responsible for transforming the logical form of
the NL query into efficient Prolog [6]. This
step is analogous to &amp;quot;query optimisation&amp;quot; in a
relational database system. The resulting Prolog
form is directly executed to yield the answer to
the original question. On Chat&apos;s domain of world
geography, most questions within the English
subset are answered in well under one second,
including queries which involve taking joins
between relations having of the order of a
thousand tuples.
A disadvantage of much current work on NL
access to databases is that the work is restricted
to providing access to databases, whereas users
would appreciate NL interfaces to computer systems
in general. Moreover, the attempt to provide a NL
&amp;quot;front-end&amp;quot; to databases is surely putting the
cart before the horse. What one should really do
is to investigate what &amp;quot;back-end&amp;quot; is needed to
support NL interfaces to computers, without being
constrained by the limitations of current database
management systems.
I would argue that the &amp;quot;logic programming&amp;quot;
approach taken in Chat is the right way to avoid
these drawbacks of current work in NL access to
databases. Most work which attempts to deal
precisely with the meaning of NL sentences uses
some system of logic as an intermediate meaning
representation language. Logic programming is
concerned with turning such systems of logic into
practical computational formalisms. The outcome
of this &amp;quot;top-down&amp;quot; approach, as realised in the
language Prolog, has a great deal in common with
the relational approach to databases, which can be
seen as the result of a &amp;quot;bottom-up&amp;quot; effort to make
database languages more like natural language.
However Prolog is much more general than
relational database formalisms, in that it permits
data to be defined by general rules having the
power of a fully general programming language.
The logic programming approach therefore allows
one to interface NL to general programs as well as
to databases.
Current Prolog systems, because they were
designed with programming not databases in mind,
are not capable of accommodating really large
databases. However there seems to be no technical
obstacle to building a Prolog system that is fully
comparable with current relational database
management systems, while retaining Prolog&apos;s
generality and efficiency as a programming
language. Indeed, I expect such a system to be
developed in the near future, especially now that
</bodyText>
<page confidence="0.997131">
63
</page>
<bodyText confidence="0.827826">
Prolog has been chosen as the kernel language for answer(M) &lt; \+ exists(D, department(D) &amp;
Japan&apos;s &amp;quot;Fifth Generation&amp;quot; computer project [4]. \+ manages(M,D))
</bodyText>
<sectionHeader confidence="0.945026" genericHeader="method">
II SPECIFIC ISSUES
</sectionHeader>
<subsectionHeader confidence="0.961628">
A. Aggregate Functions and Quantity Questions
</subsectionHeader>
<bodyText confidence="0.987761891891892">
To cater for aggregate and quantity
determiners, such as plural &amp;quot;the&amp;quot;, &amp;quot;two&amp;quot;, &amp;quot;how
many&amp;quot;, etc., DCW logic extends first-order logic
by allowing predications of the form:
setof(X,P,S)
to be read as &amp;quot;the set of Xs such that P is
provable is S&amp;quot; [7]. An efficient implementation
of &apos;seta is provided in DEC-10 Prolog and used
in Chat. Sets are actually represented as ordered
lists without duplicate elements. Something along
the lines of &apos;setof&apos; seems very necessary, as a
first step at least.
The question of how to treat explicitly
stored aggregate information, such as &amp;quot;number of
employees&amp;quot; in a department, is a special case of
the general issue of storing and accessing non-
primitive information, to be discussed below in
section D.
B. Time and Tense
The problem of providing a common framework
for time instants and time intervals is not one
that I have looked into very far, but it would
seem to be primarily a database rather than a
linguistic issue, and to highlight the limitations
of traditional databases, where all facts have to
be stored explicitly. Queries concerning time
instants and intervals will generally need to be
answered by calculation rather than by simple
retrieval. A common framework for both
calculation and retrieval is precisely what the
logic programming approach provides. For example,
the predication:
sailed(kennedy,july82,D)
occurring in a query might invoke a Prolog
procedure &apos;sailed&apos; to calculate the distance D
travelled, rather than cause a simple data look-
up.
</bodyText>
<sectionHeader confidence="0.386224" genericHeader="method">
C. Quantifying into Questions
</sectionHeader>
<bodyText confidence="0.999886916666667">
Quantifying into questions is an issue which
was an important concern in Chat, and one for
which I feel we produced a reasonably adequate
solution. The question &amp;quot;Who manages every
department?&amp;quot; would be translated into the
following logical form:
where &amp;quot;\+&apos; is to be read as &amp;quot;it is not known
that&amp;quot;, i.e. the logical form reads &amp;quot;M is an
answer if there is no known department that M does
not manage&amp;quot;. The question &amp;quot;Who manages each
department?&amp;quot;, on the other hand, would translate
into:
</bodyText>
<equation confidence="0.856055">
answer(D-M) &lt;= department(D) &amp; manages(M,D)
</equation>
<bodyText confidence="0.97195875">
generating answers which would be pairs of the
form:
accounts - andrews ;
sales - smith ; etc.
The two different logical forms result from the
different treatments accorded to &amp;quot;each&amp;quot; and
&amp;quot;every&amp;quot; by Chat&apos;s determiner scoping algorithm
[8] [5]â€¢
</bodyText>
<sectionHeader confidence="0.339168" genericHeader="method">
D. Querying Semantically Complex Fields
</sectionHeader>
<bodyText confidence="0.9455660625">
My general feeling here is that one should
not struggle too hard to bend one&apos;s NL interface
to fit an existing database. Rather the database
should be designed to meet the needs of NL access.
If the database does not easily support the kind
of NL queries the user wants to ask, it is
probably not a well-designed database. In general
it seems best to design a database so that only
primitive facts are stored explicitly, others
being derived by general rules, and also to avoid
storing redundant information.
However this general philosophy may not be
practicable in all cases. Suppose, indeed, that
&apos;childofalumnus&apos; is stored as primitive
information. Now the logical form for &amp;quot;Is John
Jones a child of an alumnus?&amp;quot; would be:
</bodyText>
<equation confidence="0.9852125">
answer(yes) &lt;-
childof(X,johnjones) &amp; alumnus(X)
</equation>
<bodyText confidence="0.841530571428571">
What we seem to need to do is to recognise that in
this particular case a simplification is possible
using the following definition:
childofalumnus(X) &lt;=&gt;
exists(Y, childof(Y,X) &amp; alumnus(Y))
giving the derived query:
answer(yes) &lt;= childofalumnus(johnjones)
However the logical form:
answer(X) &lt;
childof(X,johnjones) &amp; alumnus(X)
corresponding to &amp;quot;Of wh!&amp;quot;.h 7,1umnus is John Jones a
child?&amp;quot; would not be susceptible to
simplification, and the answer to the query would
have to be &amp;quot;Don&apos;t know&amp;quot;.
</bodyText>
<page confidence="0.997753">
64
</page>
<subsectionHeader confidence="0.276382">
E. Multi-File Queries
</subsectionHeader>
<bodyText confidence="0.999405555555556">
At the root of the difficulties raised here
is the question of what to do when the concepts
used in the NL query do not directly correspond to
what is stored in the database. With the logic
programming approach taken in Chat, there is a
simple solution. The database is augmented with
general rules which define the NL concepts in
terms of the explicitly stored data. For example,
the rule:
</bodyText>
<equation confidence="0.996388">
lengthof(S,L) &lt;=
classof(S,C) &amp; classlengthof(C,L).
</equation>
<bodyText confidence="0.999979769230769">
says that the length of a ship is the length of
that ship&apos;s class. These rules get invoked while
a query is being executed, and may be considered
to extend the database with &amp;quot;virtual files&amp;quot;.
Often a better approach would be to apply these
rules to preprocess the query in advance of actual
execution. In any event, there seems to be no
need to treat joins as implicit, as systems such
as Ladder have done. Joins, which are equivalent
to conjunctions in a logical form, should always
be expressed explicitly, either in the original
query, or in other domain-dependent rules which
help to support the NL interface.
</bodyText>
<sectionHeader confidence="0.639521" genericHeader="method">
III A FURTHER ISSUE - SEMANTICS OF PLURAL &amp;quot;THE&amp;quot;
</sectionHeader>
<bodyText confidence="0.9999919">
A difficulty we experienced in developing
Chat, which I would propose as one of the most
pressing problems in NL access to databases, is to
define an adequate theoretical and computational
semantics for plural noun phrases, especially
those with the definite article &amp;quot;the&amp;quot;. It is a
pressing problem because clearly even the most
minimal subset of NL suitable for querying a
database must include plural &amp;quot;the&amp;quot;. The problem
has two aspects:
</bodyText>
<listItem confidence="0.941095">
(1) to define a precise semantics that is
strictly correct in all cases;
</listItem>
<bodyText confidence="0.8910302">
(2) to implement this semantics in an
efficient way, giving results comparable
to what could be achieved if a formal
database query language were used in
place of NL.
As a first approximation, Chat treats plural
definite noun phrases as introducing sets,
formalised using the &apos;setof&apos; construct mentioned
earlier. Thus the translation of &amp;quot;the European
countries&amp;quot; would be S where:
</bodyText>
<equation confidence="0.625325">
setof(C,european(C) &amp; country(C),S).
</equation>
<bodyText confidence="0.988795296875">
The main drawback of this approach is that it
leaves open the question of how predicates applied
to sets relate to those same predicates applied to
individuals. Thus the question &amp;quot;Do the European
countries border the Atlantic?&amp;quot; gets as part of
its translation:
borders(S,atlantic)
where S is the set of European countries. Should
this predication be considered true if all
European countries border the Atlantic, or if just
some of them do? Or does it mean something else,
as in &amp;quot;Are the European countries allies?&amp;quot;?
At the moment, Chat makes the default
assumption that, in the absence of other
information, a predicate is &amp;quot;distributive&amp;quot;, i.e.
a predication over a set is true if and only if it
is true of each element. So the question above is
treated as meaning &amp;quot;Does every European country
border the Atlantic?&amp;quot;. And &amp;quot;Do the European
countries trade with the Caribbean countries?&amp;quot;
would be interpreted as &amp;quot;Does each European
country trade with each Caribbean country?&amp;quot;.
Chat only makes this default assumption in
the course of query execution, which may well be
very inefficient. If the &apos;setof can effectively
be dispensed with, producing a simpler logical
form, one would like to do this at an earlier
stage and take advantage of optimisations
applicable to the simpler logical form.
A further complication is illustrated by a
question such as &amp;quot;Who are the children of the
employees?&amp;quot;. A reasonable answer to this question
would be a table of employees with their children,
which is what Chat in fact produces. If one were
to use the more simple-minded approximations
discussed so far, the answer would be simply a set
of children, which would be empty (I) if the
&apos;childof&apos; predicate were treated as distributive.
In general, therefore, Chat treats nested
definite noun phrases as introducing &amp;quot;indexed
sets&amp;quot;, although the treatment is arguably somewhat
ad hoc. A phrase like &amp;quot;the children of the
employees&amp;quot; translates into S where:
setof(E-CC,employee(E) &amp;
setof(C,childof(E,C),CC),S).
If the indexed set occurs, not in the context of a
question, but as an argument to another predicate,
there is the further complication of defining the
semantics of predicates over indexed sets.
Consider, for example, &amp;quot;Are the major cities of
the Scandinavian countries linked by rail?&amp;quot;. In
cases involving aggregate operators such as
&amp;quot;total&amp;quot; and &amp;quot;average&amp;quot;, an indexed set is clearly
needed, and Chat handles these cases correctly.
Consider, for example, &amp;quot;What is the average of the
salaries of the part-time employees?&amp;quot;. One cannot
simply average over a set of salaries, since
several employees may have the same salary; an
indexed set ensures that each employee&apos;s salary is
counted separately.
To summarise the overall problem, then, can
one find a coherent semantics for plural &amp;quot;the&amp;quot;
that is intuitively correct, and that is
compatible with efficient database access?
</bodyText>
<page confidence="0.999497">
65
</page>
<sectionHeader confidence="0.997738" genericHeader="references">
REFERENCES
</sectionHeader>
<reference confidence="0.999936166666666">
1. Clocksin W F and Mellish C S. Programming in
Prolog. Springer-Verlag, 1981.
2. Colmerauer A. Un sous-ensemble interessant du
francais. RAIRO 13, 4 (1979), pp. 309-336.
[Presented as -1&amp;quot;An interesting natural
language subset&amp;quot; at the Workshop on Logic and
Databases, Toulouse, 1977].
3. Dahl V. Translating Spanish into logic
through logic. AJCL 7, 3 (Sep 1981), pp. 149-
164.
4. Fuchi K. Aiming for knowledge information
processing systems. Intl. Conf. on Fifth
Generation Computer Systems, Tokyo, Oct 1981,
pp. 101-114.
5. Pereira F C N. Logic for natural language
analysis. PhD thesis, University of
Edinburgh, 1982.
6. Warren D H D. Efficient processing of
interactive relational database queries
expressed in logic. Seventh Conf. on Very
Large Data Bases, Cannes, France, Sep 1981,
pp. 272-281.
7. Warren D H D. Higher-order extensions to
Prolog - are they needed? Tenth Machine
Intelligence Workshop, Cleveland, Ohio, Nov
1981.
8. Warren D H D and Pereira F C N. An efficient
easily adaptable system for interpreting
natural language queries. Research Paper 156,
Dept. of Artificial Intelligence, University
of Edinburgh, Feb 1981. [Submitted to AJCL].
9. Warren D H D, Pereira L M and Pereira F C N.
Prolog - the language and its implementation
compared with Lisp. ACM Symposium on Al and
Programming Languages, Rochester, New York,
Aug 1977, pp. 109-115.
</reference>
<page confidence="0.989015">
66
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.989373">
<title confidence="0.998204">ISSUES IN NATURAL LANGUAGE ACCESS TO DATABASES FROM A LOGIC PROGRAMMING PERSPECTIVE</title>
<author confidence="0.999894">David H D Warren</author>
<affiliation confidence="0.999366">Artificial Intelligence Center</affiliation>
<address confidence="0.993471">SRI International, Menlo Park, CA 94025, USA</address>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>W F Clocksin</author>
<author>C S Mellish</author>
</authors>
<title>Programming in Prolog.</title>
<date>1981</date>
<publisher>Springer-Verlag,</publisher>
<contexts>
<context position="1573" citStr="[1]" startWordPosition="247" endWordPosition="247"> logic, which we call &amp;quot;definite closed world&amp;quot; (DCW) logic. This logic is a subset of first-order logic, in that it admits only &amp;quot;definite&amp;quot; statements; uncertain information (&amp;quot;Either this or that&amp;quot;) is not allowed. DCW logic extends first-order logic, in that it provides constructions to support the &amp;quot;closed world&amp;quot; assumption, that everything not known to be true is false. Why does Chat use this curious logic as a meaning representation language? The main reason is that it can be implemented very efficiently. In fact, DCW logic forms the basis of a general purpose programming language, Prolog [9] [1], due to Colmerauer, which has had a wide variety of applications. Prolog can be viewed either as an extension of pure Lisp, or as an extension of a relational database query language. Moreover, the efficiency of the DEC-10 Prolog implementation is comparable both with compiled Lisp [9] and with current relational database systems [6] (for databases within virtual memory). Chat&apos;s second main stage, &amp;quot;planning&amp;quot;, is responsible for transforming the logical form of the NL query into efficient Prolog [6]. This step is analogous to &amp;quot;query optimisation&amp;quot; in a relational database system. The resulting </context>
</contexts>
<marker>1.</marker>
<rawString>Clocksin W F and Mellish C S. Programming in Prolog. Springer-Verlag, 1981.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Colmerauer</author>
</authors>
<title>Un sous-ensemble interessant du francais.</title>
<date>1979</date>
<journal>RAIRO</journal>
<volume>13</volume>
<pages>309--336</pages>
<location>Toulouse,</location>
<contexts>
<context position="9897" citStr="(2)" startWordPosition="1590" endWordPosition="1590">which help to support the NL interface. III A FURTHER ISSUE - SEMANTICS OF PLURAL &amp;quot;THE&amp;quot; A difficulty we experienced in developing Chat, which I would propose as one of the most pressing problems in NL access to databases, is to define an adequate theoretical and computational semantics for plural noun phrases, especially those with the definite article &amp;quot;the&amp;quot;. It is a pressing problem because clearly even the most minimal subset of NL suitable for querying a database must include plural &amp;quot;the&amp;quot;. The problem has two aspects: (1) to define a precise semantics that is strictly correct in all cases; (2) to implement this semantics in an efficient way, giving results comparable to what could be achieved if a formal database query language were used in place of NL. As a first approximation, Chat treats plural definite noun phrases as introducing sets, formalised using the &apos;setof&apos; construct mentioned earlier. Thus the translation of &amp;quot;the European countries&amp;quot; would be S where: setof(C,european(C) &amp; country(C),S). The main drawback of this approach is that it leaves open the question of how predicates applied to sets relate to those same predicates applied to individuals. Thus the question &amp;quot;Do the</context>
</contexts>
<marker>2.</marker>
<rawString>Colmerauer A. Un sous-ensemble interessant du francais. RAIRO 13, 4 (1979), pp. 309-336. [Presented as -1&amp;quot;An interesting natural language subset&amp;quot; at the Workshop on Logic and Databases, Toulouse, 1977].</rawString>
</citation>
<citation valid="true">
<authors>
<author>V Dahl</author>
</authors>
<title>Translating Spanish into logic through logic.</title>
<date>1981</date>
<journal>AJCL</journal>
<volume>7</volume>
<pages>149</pages>
<marker>3.</marker>
<rawString>Dahl V. Translating Spanish into logic through logic. AJCL 7, 3 (Sep 1981), pp. 149-</rawString>
</citation>
<citation valid="true">
<authors>
<author>K Fuchi</author>
</authors>
<title>Aiming for knowledge information processing systems.</title>
<date>1981</date>
<journal>Intl. Conf. on Fifth Generation Computer Systems,</journal>
<pages>101--114</pages>
<location>Tokyo,</location>
<contexts>
<context position="4557" citStr="[4]" startWordPosition="716" endWordPosition="716">nt Prolog systems, because they were designed with programming not databases in mind, are not capable of accommodating really large databases. However there seems to be no technical obstacle to building a Prolog system that is fully comparable with current relational database management systems, while retaining Prolog&apos;s generality and efficiency as a programming language. Indeed, I expect such a system to be developed in the near future, especially now that 63 Prolog has been chosen as the kernel language for answer(M) &lt; \+ exists(D, department(D) &amp; Japan&apos;s &amp;quot;Fifth Generation&amp;quot; computer project [4]. \+ manages(M,D)) II SPECIFIC ISSUES A. Aggregate Functions and Quantity Questions To cater for aggregate and quantity determiners, such as plural &amp;quot;the&amp;quot;, &amp;quot;two&amp;quot;, &amp;quot;how many&amp;quot;, etc., DCW logic extends first-order logic by allowing predications of the form: setof(X,P,S) to be read as &amp;quot;the set of Xs such that P is provable is S&amp;quot; [7]. An efficient implementation of &apos;seta is provided in DEC-10 Prolog and used in Chat. Sets are actually represented as ordered lists without duplicate elements. Something along the lines of &apos;setof&apos; seems very necessary, as a first step at least. The question of how to tr</context>
</contexts>
<marker>4.</marker>
<rawString>Fuchi K. Aiming for knowledge information processing systems. Intl. Conf. on Fifth Generation Computer Systems, Tokyo, Oct 1981, pp. 101-114.</rawString>
</citation>
<citation valid="true">
<authors>
<author>F C N Pereira</author>
</authors>
<title>Logic for natural language analysis.</title>
<date>1982</date>
<tech>PhD thesis,</tech>
<institution>University of Edinburgh,</institution>
<contexts>
<context position="6940" citStr="[5]" startWordPosition="1103" endWordPosition="1103">anages every department?&amp;quot; would be translated into the following logical form: where &amp;quot;\+&apos; is to be read as &amp;quot;it is not known that&amp;quot;, i.e. the logical form reads &amp;quot;M is an answer if there is no known department that M does not manage&amp;quot;. The question &amp;quot;Who manages each department?&amp;quot;, on the other hand, would translate into: answer(D-M) &lt;= department(D) &amp; manages(M,D) generating answers which would be pairs of the form: accounts - andrews ; sales - smith ; etc. The two different logical forms result from the different treatments accorded to &amp;quot;each&amp;quot; and &amp;quot;every&amp;quot; by Chat&apos;s determiner scoping algorithm [8] [5]â€¢ D. Querying Semantically Complex Fields My general feeling here is that one should not struggle too hard to bend one&apos;s NL interface to fit an existing database. Rather the database should be designed to meet the needs of NL access. If the database does not easily support the kind of NL queries the user wants to ask, it is probably not a well-designed database. In general it seems best to design a database so that only primitive facts are stored explicitly, others being derived by general rules, and also to avoid storing redundant information. However this general philosophy may not be practi</context>
</contexts>
<marker>5.</marker>
<rawString>Pereira F C N. Logic for natural language analysis. PhD thesis, University of Edinburgh, 1982.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D H D Warren</author>
</authors>
<title>Efficient processing of interactive relational database queries expressed in logic.</title>
<date>1981</date>
<booktitle>Seventh Conf. on Very Large Data Bases,</booktitle>
<pages>272--281</pages>
<location>Cannes, France,</location>
<contexts>
<context position="1909" citStr="[6]" startWordPosition="301" endWordPosition="301">hing not known to be true is false. Why does Chat use this curious logic as a meaning representation language? The main reason is that it can be implemented very efficiently. In fact, DCW logic forms the basis of a general purpose programming language, Prolog [9] [1], due to Colmerauer, which has had a wide variety of applications. Prolog can be viewed either as an extension of pure Lisp, or as an extension of a relational database query language. Moreover, the efficiency of the DEC-10 Prolog implementation is comparable both with compiled Lisp [9] and with current relational database systems [6] (for databases within virtual memory). Chat&apos;s second main stage, &amp;quot;planning&amp;quot;, is responsible for transforming the logical form of the NL query into efficient Prolog [6]. This step is analogous to &amp;quot;query optimisation&amp;quot; in a relational database system. The resulting Prolog form is directly executed to yield the answer to the original question. On Chat&apos;s domain of world geography, most questions within the English subset are answered in well under one second, including queries which involve taking joins between relations having of the order of a thousand tuples. A disadvantage of much current work</context>
</contexts>
<marker>6.</marker>
<rawString>Warren D H D. Efficient processing of interactive relational database queries expressed in logic. Seventh Conf. on Very Large Data Bases, Cannes, France, Sep 1981, pp. 272-281.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D H D Warren</author>
</authors>
<title>Higher-order extensions to Prolog - are they needed?</title>
<date></date>
<booktitle>Tenth Machine Intelligence Workshop,</booktitle>
<location>Cleveland, Ohio,</location>
<contexts>
<context position="4886" citStr="[7]" startWordPosition="770" endWordPosition="770">ity and efficiency as a programming language. Indeed, I expect such a system to be developed in the near future, especially now that 63 Prolog has been chosen as the kernel language for answer(M) &lt; \+ exists(D, department(D) &amp; Japan&apos;s &amp;quot;Fifth Generation&amp;quot; computer project [4]. \+ manages(M,D)) II SPECIFIC ISSUES A. Aggregate Functions and Quantity Questions To cater for aggregate and quantity determiners, such as plural &amp;quot;the&amp;quot;, &amp;quot;two&amp;quot;, &amp;quot;how many&amp;quot;, etc., DCW logic extends first-order logic by allowing predications of the form: setof(X,P,S) to be read as &amp;quot;the set of Xs such that P is provable is S&amp;quot; [7]. An efficient implementation of &apos;seta is provided in DEC-10 Prolog and used in Chat. Sets are actually represented as ordered lists without duplicate elements. Something along the lines of &apos;setof&apos; seems very necessary, as a first step at least. The question of how to treat explicitly stored aggregate information, such as &amp;quot;number of employees&amp;quot; in a department, is a special case of the general issue of storing and accessing nonprimitive information, to be discussed below in section D. B. Time and Tense The problem of providing a common framework for time instants and time intervals is not one t</context>
</contexts>
<marker>7.</marker>
<rawString>Warren D H D. Higher-order extensions to Prolog - are they needed? Tenth Machine Intelligence Workshop, Cleveland, Ohio, Nov</rawString>
</citation>
<citation valid="true">
<authors>
<author>D H D Warren</author>
<author>F C N Pereira</author>
</authors>
<title>An efficient easily adaptable system for interpreting natural language queries.</title>
<date>1981</date>
<tech>Research Paper 156,</tech>
<institution>Dept. of Artificial Intelligence, University of Edinburgh,</institution>
<note>[Submitted to AJCL].</note>
<contexts>
<context position="6936" citStr="[8]" startWordPosition="1102" endWordPosition="1102">ho manages every department?&amp;quot; would be translated into the following logical form: where &amp;quot;\+&apos; is to be read as &amp;quot;it is not known that&amp;quot;, i.e. the logical form reads &amp;quot;M is an answer if there is no known department that M does not manage&amp;quot;. The question &amp;quot;Who manages each department?&amp;quot;, on the other hand, would translate into: answer(D-M) &lt;= department(D) &amp; manages(M,D) generating answers which would be pairs of the form: accounts - andrews ; sales - smith ; etc. The two different logical forms result from the different treatments accorded to &amp;quot;each&amp;quot; and &amp;quot;every&amp;quot; by Chat&apos;s determiner scoping algorithm [8] [5]â€¢ D. Querying Semantically Complex Fields My general feeling here is that one should not struggle too hard to bend one&apos;s NL interface to fit an existing database. Rather the database should be designed to meet the needs of NL access. If the database does not easily support the kind of NL queries the user wants to ask, it is probably not a well-designed database. In general it seems best to design a database so that only primitive facts are stored explicitly, others being derived by general rules, and also to avoid storing redundant information. However this general philosophy may not be pr</context>
</contexts>
<marker>8.</marker>
<rawString>Warren D H D and Pereira F C N. An efficient easily adaptable system for interpreting natural language queries. Research Paper 156, Dept. of Artificial Intelligence, University of Edinburgh, Feb 1981. [Submitted to AJCL].</rawString>
</citation>
<citation valid="true">
<authors>
<author>D H D Warren</author>
<author>L M Pereira</author>
<author>F C N Pereira</author>
</authors>
<title>Prolog - the language and its implementation compared with Lisp.</title>
<date>1977</date>
<booktitle>ACM Symposium on Al and Programming Languages,</booktitle>
<pages>109--115</pages>
<location>Rochester, New York,</location>
<contexts>
<context position="1569" citStr="[9]" startWordPosition="246" endWordPosition="246">rder logic, which we call &amp;quot;definite closed world&amp;quot; (DCW) logic. This logic is a subset of first-order logic, in that it admits only &amp;quot;definite&amp;quot; statements; uncertain information (&amp;quot;Either this or that&amp;quot;) is not allowed. DCW logic extends first-order logic, in that it provides constructions to support the &amp;quot;closed world&amp;quot; assumption, that everything not known to be true is false. Why does Chat use this curious logic as a meaning representation language? The main reason is that it can be implemented very efficiently. In fact, DCW logic forms the basis of a general purpose programming language, Prolog [9] [1], due to Colmerauer, which has had a wide variety of applications. Prolog can be viewed either as an extension of pure Lisp, or as an extension of a relational database query language. Moreover, the efficiency of the DEC-10 Prolog implementation is comparable both with compiled Lisp [9] and with current relational database systems [6] (for databases within virtual memory). Chat&apos;s second main stage, &amp;quot;planning&amp;quot;, is responsible for transforming the logical form of the NL query into efficient Prolog [6]. This step is analogous to &amp;quot;query optimisation&amp;quot; in a relational database system. The result</context>
</contexts>
<marker>9.</marker>
<rawString>Warren D H D, Pereira L M and Pereira F C N. Prolog - the language and its implementation compared with Lisp. ACM Symposium on Al and Programming Languages, Rochester, New York, Aug 1977, pp. 109-115.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>