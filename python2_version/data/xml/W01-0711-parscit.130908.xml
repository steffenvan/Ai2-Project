<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000019">
<title confidence="0.86897">
Morpholog: Constrained and Supervised Learning of Morphology
</title>
<author confidence="0.98973">
Remi Zajac
</author>
<affiliation confidence="0.986848">
Computing Research Laboratory, New Mexico State University
</affiliation>
<email confidence="0.601644">
zajacOcrl.nmsu.edu
</email>
<sectionHeader confidence="0.957517" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999887857142857">
We present an automated method for build-
ing morphological analyzers using limited data
elicited from a linguist. The system uses an in-
duction procedure based on an extended edit
distance algorithm to automate the discovery
of morphological rules from examples. One of
the requirements of the method is to minimize
the size of the training data. The learning algo-
rithm incorporates morphological language pa-
rameters, defined by the user, that constrains
the space of the induction procedure. The re-
sult is a set of morphological rules that can be
inspected by the user and further compiled into
a morphological analyzer (or generator).
</bodyText>
<sectionHeader confidence="0.996296" genericHeader="introduction">
1 Introduction
</sectionHeader>
<bodyText confidence="0.999980034482758">
We present an automated method for devel-
oping morphological analyzers for natural lan-
guages. The morphological analyzer generated
by Morpholog is a component of an integrated
NLP system such as a machine translation sys-
tem. In such applications, the morphological
analyzer is given an inflected word as input
and produces the citation form of the word
plus a set of morphosyntactic features which
represent the morphological &apos;meaning&apos; of inflec-
tional morphemes. The morphological analyzer
is dictionary-free and produces all possible anal-
yses for a given word. The citation form is used
to lookup words in a syntactic or a translation
dictionary which can be maintained indepen-
dently of the morphological system.
The system uses an induction procedure
based on an extended edit distance algorithm to
automate the discovery of morphological rules
from examples. The training data consists of
pairs of inflected forms and dictionary cita-
tion forms plus morphosyntactic features. Since
such a training set is costly to develop by hand,
one the requirements of the method is to mini-
mize the size of the training data. The learning
algorithm incorporates morphological language
parameters, defined by the user, that constrains
the learning space. The result of the learning
procedure is a set of morphological rules in a
format that can be inspected by the user and
further compiled into a morphological analyzer
and generator.
The Morpholog system is integrated in the
Boas system for fast &amp;quot;ramp-up&amp;quot; of machine
translation systems for minority languages at
CRL (Nirenburg 98a; Nirenburg &amp; Raskin 98).
One assumption made for the Boas system is
that there may be little or no machine readable
resources for the source language (target is al-
ways English). Boas includes develop/test loop
where citation forms are given to the morpho-
logical generator and results are presented to
the user. When the user diagnoses erroneous
forms, he correct these erroneous forms and the
corrected forms are added to the learning set for
the next learning iteration. The Boas system
can be used by linguists with little knowledge
of computational linguistics formalisms (e.g.,
finite-state technology). Although we expect
that the set of rules induced from the training
set will cover all intended phenomena, the Mor-
pholog system allows expert users to inspect and
modify the learned rules prior to compilation.
The next section reviews related work. Sec-
tion 3 gives an overview of the system&apos;s archi-
tecture. Section 4 describes in more detail the
induction procedure. Finally, we present some
conclusions and ideas for future work.
</bodyText>
<sectionHeader confidence="0.997442" genericHeader="related work">
2 Related Work
</sectionHeader>
<bodyText confidence="0.997125218181818">
The automatic induction of morphological rules
is a long standing problem that has been men-
tioned at least since (Garvin 67). Various au-
thors have described, not always in great detail,
approaches similar to the one presented in this
paper, e.g. (Wothke 86; Brasington et als. 88).
Other machine learning approaches to morphol-
ogy have different goals. For example, (Gold-
smith 98) presents an algorithm to infer stem
and affixes from a large un-annotated corpus.
However, the results do not allow to recover ei-
ther the citation form of the word or associated
inflectional features of word forms. (Gilloux
91) describes a method to induce a probabilis-
tic finite-state transducer from examples. The
application to grapheme-phoneme transcription
seems relative straightforward. However, ap-
plication to morphological analysis would need
more extensive testing than the example pre-
sented in the paper. (Daelemans et als. 96) de-
scribes a system to learn phonological categories
from a set of phonetic transcriptions of words,
presumably for text-to-speech conversion.
The XMAS system (Zhang &amp; Kim 90) is sim-
ilar to the one described in this paper: the sys-
tem is given a set of examples in the form of
triples (features, citation form, inflected form)
and learns morphological rules that can be in-
terpreted by a morphological engine. The rule
discovery procedure is not explained in de-
tail but seems an improvement over (Wothke
86). Another similar approach is (Bonn 91)
who suggests to use an alignment algorithm
for stem/affix identification, and phonological
classes of graphemes to control generalization
(as in (Zhang &amp; Kim 90)). (Kuusik 96) de-
scribes a system for learning morphological
rules for Estonian. The system distinguishes
between affixation rules (so-called &apos;stem-end
changes&apos;) and morphophonemic rules (`stem-
grade changes&apos;). The system combines ordered
stem change rules (which combination seems to
be equivalent to the use of an edit distance al-
gorithm) and generalizations over morphemic
classes (vowels, consonants) tailored for Esto-
nian.
Finally, (Oflazer et als. 01) describe a a sys-
tem which has been used in a previous version
of the Boas system. The main differences be-
tween the approach described in this paper and
(Oflazer et als. 01) is the use of a generalized
edit distance which allows to identify stem and
affixes in a way that can be constrained by user
parameters (prefixation, infixation and suffixa-
tion).
</bodyText>
<sectionHeader confidence="0.986825" genericHeader="method">
3 Architecture
</sectionHeader>
<bodyText confidence="0.997061333333333">
The three main components of the Morpholog
system are the Morphological Knowledge Base,
the Morphological Learner and the Rule Com-
piler. The user first populate the Morphological
Knowledge Base (a set of XML files) by defin-
ing:
</bodyText>
<listItem confidence="0.98411045">
• The set of features and values that can ap-
pear in a morphological paradigm: part-of-
speech, number, person, etc.
• The classes of the phonological segments
(graphemes, composed of one or more char-
acters) that are used to segment a word
form into atomic segments. Basic classes
are vowels, consonants, suprasegmentals
(e.g., tone when written), and other writ-
ten marks (apostrophe, etc.).
• The set of examples structured as a set
of morphological paradigms. Each mor-
phological paradigm consist of one main
paradigm instance (the &amp;quot;primary&amp;quot; exam-
ple) and optionally of several additional
paradigm instances (&amp;quot;secondary&amp;quot; exam-
ples). Each paradigm instance, identified
by the citation form, contains a set of
pairs (word form, set of features) called
paradigm members.
</listItem>
<bodyText confidence="0.911188555555556">
The Morphological Learner works on a sin-
gle paradigm at a time and associate to each
paradigm member a morphological rule. The
Morphological Learner works as follows:
1. Each word form is aligned with the citation
form to extract stem and affix candidates.
The alignment procedure uses a generalized
edit distance which allows for prefixation,
suffixation and infixat ion.
</bodyText>
<listItem confidence="0.97676155">
2. All possible stem candidates are ranked by
frequency and by weight (length of stem).
At this step the user may select a stem
candidate from the list suggested by Mor-
pholog; he may also enter a stem which has
not been produced.
3. Each stem candidate produces a segmenta-
tion of all instances in the paradigm. This
step identifies affixes and generates seg-
mentation rules for all instances.
4. Affixes are compared between primary and
secondary examples for the same paradigm
member to check for affix consistency.
5. When pure affixation does not work, mor-
phophonemic adjustment of the stem (and
possibly of affixes) are postulated. This
step generate morphophonemic rules.
6. Segmentation and morphophonemic rules
are combined into morphological rules as-
sociated to each paradigm member.
</listItem>
<bodyText confidence="0.999981">
The rules are stored in the Morphological
Knowledge Base and can be inspected (and
modified) by the user. Once rules have been in-
duced for all paradigms, the rule compiler pro-
duces rules in a format acceptable by a mor-
phological engine. In the Boas system, we use a
(reversible) unification-based morphological en-
gine (Zajac 98).1 This engine is integrated in
the MEAT machine translation toolkit (Amtrup
&amp; Zajac 00) used to implement the Boas MT
systems.
In Boas, the user (who is not assumed to know
much about computational linguistic or linguis-
tics) is carefully guided in the process of elicit-
ing language data by a sequence of questions.
The language data is then saved as XML files
which are used as input by the Morpholog sys-
tem. In addition, the Boas system implements
an Elicit-Test-Build loop (Oflazer et als. 01) in
which the resulting analyzer is tested by gen-
erating all possible forms for new words (using
the morphological generation engine). The user
checks, by inspecting the forms, that no gaps
occur. If the user detect a gap, additional ex-
amples are provided to cover the gap (typically,
morphophonological phenomena not covered by
the primary examples).
</bodyText>
<sectionHeader confidence="0.66282" genericHeader="method">
4 The Morphological Discovery
Procedure
</sectionHeader>
<bodyText confidence="0.999457871794872">
Stem extraction. The stem extraction pro-
cedure operates on pairs of (citation form, word
form) and returns a list of segmented and
aligned pairs together with a weight which rep-
resent how closely a given segmentation aligns
the two forms. A segmented pair contains the
&apos;It should be fairly easy to produce rules in some
other format —e.g., Xerox-type rules— as the rule compiler
is written using XSLT.
stem (possibly discontinuous), the list of affixes
and the position of the stem in this list for all
forms, and the weight associated to the segmen-
tation.
The extraction algorithm pairs phonological
segments an inflected form to phonological seg-
ments in the citation form, with the constraint
that the pairs must not cross (but discontinu-
ities between pairs are allowed). The stem is the
list of paired segments. Since there will be of
course many possible alignments, each aligned
pair is weighted using the following heuristic,
which favors the longest common continuous
segment as the stem. The weight is simply the
number of contiguous paired segments. To fa-
vor continuous stems, if there are 2 or more dis-
continuous alignments, the number of unpaired
segments occurring between 2 contiguous paired
sequences is subtracted.
The stem alignment algorithm uses an ex-
tended edit distance metric (Kruskal &amp; Sankoff
99). The weights are based on consonant/vowel
classifications: we prefer substitutions to indels
(insertions/deletions) and we prefer substitu-
tions in the same class (the best distance is the
smallest one). We also favor consecutive indels
and substitutions over independent indels and
substitutions. Indels are given basic weight 3
and weight for substitutions is given by the fol-
lowing table:2
</bodyText>
<table confidence="0.821259">
VS CMO
V 1 2 3 4 4
S 2 1 2 4 4
C 3 2 1 4 4
M 4 4 4 14
0 4 4 4 4 1
</table>
<bodyText confidence="0.869542222222222">
The algorithm aligning a pair of (citation
form, word form) can be visualized as a boolean
matrix where rows and colons correspond to seg-
ments. For example, the alignment matrix for
the Spanish (enraizar, enraizaban) is:3
enraizaban
e 1000000000
n 0100000001
✓ 0010000000
</bodyText>
<footnote confidence="0.9631135">
2V: Vowel, S: Sonant, C: Consonant, M: Supraseg-
mental, 0: Other.
3 to take root: enraizaban is the indicative-preterit-
imperfect-3rd-plu.
</footnote>
<construct confidence="0.6686958">
a 0001001010
i 0000100000
z 0000010000
a 0001001010
r 0010000000
</construct>
<bodyText confidence="0.93043525">
The longest contiguous paired segments are
represented by diagonals of is in the matrix. In
this case:
lenraizal r
lenraizal ban
All the other paired segments are either cross-
ing or isolated (in this example, there are 6
other possible alignments, with diagonals re-
duced to one segment with weight 1), and there
are no discontinuous sequences.
Stem ranking. The result of stem extraction
is a list of aligned weighted of tuples (stem, ci-
tation, word, weight) where the citation form
and the word form are segmented and the stem
identified. This list is sorted by frequency of
occurrence of the stem. When 2 elements have
the same frequency, the elements are further or-
dered according to their weight. Let&apos;s assume
the following paradigm instance for the citation
form torebka:
</bodyText>
<figure confidence="0.1629525">
torebka
torebki
torebce
torebke
torebka
torebko
torebek
torebkom
torebkami
torebkach
The list of stem candidates is:
Stem Weight Frequency
</figure>
<figureCaption confidence="0.974816">
torebka 7 4
torebk 6 7
toreb 5 10
tore 4 10
tor 3 10
to 2 10
t 1 10
</figureCaption>
<bodyText confidence="0.998140375">
and the preferred stem candidate having the
highest frequency and highest weight is toreb
(which is not the correct stem in this case).
Paradigm segmentation. For a selected
stem, and for each member of a paradigm in-
stance, the pattern extraction procedure se-
lects the segmentation that contain the stem.
If there is no segmentation that contains that
stem, the next most frequent stem is selected
with the corresponding segmentation for that
paradigm member. This step also extracts affix
candidates. Suppose in the example above that
the selected stem is torebka. The segmented
paradigm identifying stem and affixes is (the +
indicates that the stem from the paradigm seg-
mentation is the same as the selected stem):
</bodyText>
<table confidence="0.845428117647059">
Stem Weight Frequency
torebka 7 4
+ torebka
- torebk i
- toreb ce
- torebk e
+ torebka
- torebk o
- toreb ek
- torebk om
+ torebka mi
+ torebka ch
Affixation rules derived from this segmenta-
tion are:
Stem Frequency Weight Oi
torebka 4 7 @ce
torebka $1+ $1+ Oe
i 00
torebk $1+ $1+ @ek
= = Oom
toreb $1+ $1+ Oim
ce @ch
= =
torebk $1+ $1+
e
torebka $1+ $1+
==
torebk o $1+ $1+
==
toreb ek $1+ $1+
torebk om $1+ $1+
torebka mi $1+ $1+
==
torebka ch $1+ $1+
</table>
<bodyText confidence="0.999975">
The notation for rule is as follows. Strings
belonging to the stem are prefixed with $ and
strings belonging to affixes are prefixed with ©.
Variable are numbers (e.g. $1), and + and *
are used to express positive and free iteration.
Constant strings are written as is (e.g., @im for
the affix im).
Constraints on affixes. In the torebka ex-
ample above, the selection of the most frequent
stem does not lead to the correct choice. The
correct segmentation should actually be based
on additional evidence, i.e. on additional in-
stances of the paradigm. In particular, the
identity of affixes for two different segmented
members in the same position (having with the
same set of morphological features) should be a
better criterion that frequency of stem alone.
Identity of affixes across word forms is con-
stitutive to the morphological definition of af-
fixes and affixes should be identical (modulo
morphophonemic changes) for all examples of a
paradigm member in the same position. There-
fore, when additional examples are available,
they are segmented according to the procedure
defined above. The number of identical (or sim-
ilar) affixes is counted and this information is
recorded in the segmented paradigm, and used
as the first ranking criteria instead of stem fre-
quency.
Morphophonemic rules. When there are
different stems in a segmented paradigm in-
stance, we need to account for the differ-
ences between the selected stem for the whole
paradigm and the stem of a member, as it is the
case in the example above (lines marked -).
</bodyText>
<listItem confidence="0.937194611111111">
1. If the selected stem is a sub-string of the
stem member, the difference is simply re-
assigned to an affix candidate.
2. If the selected stem contains the stem mem-
ber, we have a case of stem alternation
(morphophonemic change at the boundary)
and we need to produce a morphophonemic
rule (see below).
3. An overlap is treated as a combination of
the above
4. If the preferred stem is not comparable to
another candidate (edit distance too great),
we have a case of stem suppletion: either
the choice of word is inadequate (and the
user must provide another paradigm in-
stance) or the suppletion is regular (and
will be listed in the dictionary: no rule will
be generate for this element).
</listItem>
<bodyText confidence="0.999952636363636">
In the example above, cases of stem alterna-
tions (marked -) must be reduced using mor-
phophonemic rules. For example, to reconcile
the segmentation toreb I ce (where toreb is the
stem and ce is the suffix) with the selected stem
torebka, we must posit a rule which removes ka
at the end of the stem. These rules are built us-
ing an alignment algorithm similar to the one
used for stem extraction (there is always only
one morphophonemic rule generated for each
paradigm member).
Since morphophonemic changes are typically
triggered by specific morphophonemic contexts
in stem and affixes, morphophonemic rules may
include left and right contexts to restrict the
application of the rule. The context is always
generalized to the most specific morphophone-
mic class common to all segments involved when
3 or more different segments are found in the
context (in the same position). If all segments
are identical in a given position, no context is
generated, as in the following example:
</bodyText>
<figureCaption confidence="0.9842785">
torebka $1+ == $1+
torebk $1+ @a == $1+
toreb $1+ @ka == $1+
torebk $1+ @a == $1+
torebka $1+ == $1+
torebk $1+ @a == $1+
toreb $1+ @ka == $1+
torebk $1+ @a == $1+
torebka $1+ == $1+
torebka $1+ == $1+
</figureCaption>
<bodyText confidence="0.9993605">
When secondary examples are provided, the
context is specialized to be able to select a single
rule based on the context.
Once morphophonemic rules are extracted,
morphophonemic and affixation rules are then
composed into a single rule per member:
</bodyText>
<equation confidence="0.991401">
$1+ $ka == $1+
$1+ == $1+ @ce
$1+ $ka == $1+ @ce
</equation>
<bodyText confidence="0.99933">
These rules are recorded for each member and
the whole paradigm pattern is:
</bodyText>
<figureCaption confidence="0.641552666666667">
Stem Frequency Weight
torebka 4 7
torebka $1+ == $1+
torebki $1+ $a — $1+ @i
torebce $1+ $ka — $1+ @ce
torebke $1+ $a == $1+ @e
</figureCaption>
<equation confidence="0.991380166666667">
torebka $1+ == $1+
torebko $1+ $a == $1+ Oo
torebek $1+ $ka == $1+ Oek
torebkom $1+ $a == $1+ Oom
torebkami $1+ == $1+ @im
torebkach $1+ == $1+ @ch
</equation>
<bodyText confidence="0.993451142857143">
Language parameters as morphological
constraints. Although the algorithms for
stem extraction and morphophonological induc-
tion allow almost any kind of change, we con-
strain the set of possible changes by filtering out
phenonema which are not attested in the lan-
guage. This filtering can be expressed as a set
of patterns defining allowed changes. A pattern
correspond to a language parameter that can be
set by the user to allow/disallow classes of mor-
phological phenomena. These include affixation
(prefixation, suffixation, infixation, circumfixa-
tion) as well as morphophonemic patterns as,
for example:
</bodyText>
<listItem confidence="0.99474325">
1. Stem alternation: one (or more) segment is
changed into another segment(s). The rule
is
• $1* $3+ $2* == $1* $4+ $2*
</listItem>
<bodyText confidence="0.999369">
where $3 and $4 belong to the same colon
or the same row of the vowel (or consonant)
chart (they typically differ by one phono-
logical feature).
</bodyText>
<listItem confidence="0.98188425">
2. Stem epenthesis: a segment is deleted or
added.
• Insertion: $1* $2* == $1* $0 $2*
• Deletion: $1* $0 $2* == $1* $2*
</listItem>
<bodyText confidence="0.997540333333333">
Typically, epenthesis occurs at the stem-
affix boundary. Stem suffixal epenthesis is
described by the following rules:
</bodyText>
<listItem confidence="0.999977">
• Insertion: $1+ A2+ == $1+ $0 A2+
• Deletion: $1+ $0 2+ == $1+ A2+
</listItem>
<bodyText confidence="0.86499">
Stem prefixal epenthesis is described by the
following rules:
</bodyText>
<listItem confidence="0.999975">
• Insertion: ©1+ $2+ == ©1+ $0 $2+
• Deletion: ©1+ $0 $2+ == ©1+ $2+
</listItem>
<bodyText confidence="0.9999306">
We have similar rule for affix alternation and
epenthesis. These rules cover the most frequent
phenomena attested in a large set of languages
and provide a good starting point for handling
morphophonemic changes.
</bodyText>
<sectionHeader confidence="0.99786" genericHeader="conclusions">
5 Conclusion
</sectionHeader>
<bodyText confidence="0.991874417910448">
The Morpholog has been implemented and inte-
grated in the Boas system. The user can build
a morphological knowledge base (implemented
as a set of XML files), select various parameters
through the graphical interface, run the mor-
phological learner (fully automatically or with
an intermediate step to select a stem candidate),
inspect the resulting rules, compile a morpho-
logical analyzer and run the analyzer.
Morpholog currently covers affixation (pre-
fixes, suffixes, infixes and circumfixes), and stem
alternation and stem epenthesis. The next ver-
sion (which should be available soon) will cover
affix alternation and epenthesis. It is currently
being tested and refined on a large knowledge
base for Polish and on smaller ones for Spanish
and Arabic, but evaluation data is not avail-
able at the time of writing. Initial experiments
show that the stem suggested by the system is
correct in the majority of cases. However, con-
vergence to a stable system depends a lot on the
linguist definition of a paradigm. In particular,
it is possible to define as paradigms inflectional
paradigms that are only morphophonemic vari-
ants of each other, instead of conflating in a
single paradigm all cases which have identical
or similar affixes. Since the induction proce-
dure works on the basis of a single paradigm,
having a large number of paradigm variants will
produce rules with little generalization. On the
contrary, conflating morphophonemic variants
in a single paradigm (where variants are de-
fined as secondary examples) will produce rules
with a higher degree of generality. Also, in this
case, since there will be more examples for a sin-
gle paradigm, the induction procedure is more
likely to produce correct affixes.
This automated approach to the development
of morphological analyzers offers several advan-
tages over fully manual or fully automatic ap-
proaches. In comparison of fully manual ap-
proaches, our automated approach can be used
by linguists who are not specialists of compu-
tational morphological formalisms. A linguist
starts from a set of examples which are struc-
tured and presented in a way similar to tra-
ditional descriptions of morphology (conjuga-
tion/declension tables). Indeed, we started to
develop some of our test examples by simply
converting in XML published conjugation ta-
bles.
In comparison of fully automated approaches,
the involvement of the user in the learning pro-
cedure requires a more transparent approach to
learning. The benefits are that it allows to use
smaller training sets, and also avoid the noise
produced by some fully automatic schemes. The
search space for string transformations is re-
duced to a set known morphological phenom-
ena, and it can be further reduced by setting
language specific parameters. Planned devel-
opments include support for agglutination and
reduplication, as well as additional morpho-
phonemic phenomena.
Koskenniemi, Kimmo. 1981. &amp;quot;A discovery pro-
cedure for two-level phonology&amp;quot;. In Zampolli
et als. (eds). Computational Lexicology and
</bodyText>
<reference confidence="0.941895666666667">
Lexicography, Vol.1. pp451-456.
Kruskal, Jospeh &amp; David Sankoff. 1999. &amp;quot;An
Anthology of Algorithms and Concepts for
Sequence Comparison&amp;quot;. In David Sankoff &amp;
Jospeh Kruskal (eds.) Time Warps, String
Edits, and Macromolecules. The Theory and
Practice of Sequence Comparison. CSLI Pub-
lications.
Kuusik, Evelin. 1996. &amp;quot;Learning morphology:
algorithms for the identification of the stem
changes&amp;quot;. COLING-96.
Nirenburg, Sergei. 1998. &amp;quot;Project Boas: A
Linguist-in-a-box as a multi-purpose lan-
guage resource&amp;quot;. COLING-98.
Nirenburg, Sergei, &amp; Victor Raskin. 1998. &amp;quot;Uni-
versal grammar and lexis for quick ramp-up
of MT systems&amp;quot;. LREC-98.
Oflazer, Kemal, Sergei Nirenburg, Marjorie Mc-
Shane. 2000. &amp;quot;Bootstrapping morphological
analyzer by combining human elicitation and
machine learning&amp;quot;. Computational Linguis-
tics. (to appear)
Pilato, S.F., R.C. Berwick. 1985. Reversible au-
tomata and the induction of the English aux-
iliary system. 23rd ACL, Chicago.
Satta, Giorgo, &amp; John Anderson. 1997. &amp;quot;String
transformation Learning&amp;quot;. A CL/EA CL-97.
Tufis, D. 1989. &amp;quot;It would be much easier if Went
were GOED&amp;quot; . 4th EACL, Manchester.
Wothke, K. 1986. &amp;quot;Machine learning of morpho-
logical rules by generalization and analogy&amp;quot;.
11th COLING-86, Bonn.
Zajac, Remi. 1998. &amp;quot;Feature Structures, Unifi-
cation and Finite State Transducers&amp;quot;. Proc.
of the International Workshop on Finite State
Methods in Natural Language Processing,
FSMNLP-98, Bilkent University, Ankara,
Turkey. pp101-109.
Zhang, B.T., Y.-T.Kim. 1990. &amp;quot;Morphological
analysis and synthesis by automated discov-
ery and acquisition of linguistic rules&amp;quot;. 13rd
COLING-90, Helsinki.
</reference>
<sectionHeader confidence="0.838684" genericHeader="references">
References
</sectionHeader>
<bodyText confidence="0.957413571428572">
Amtrup, Jan W., &amp; Remi Zajac. 2000. &amp;quot;A
Freely Available Toolkit for Machine Transla-
tion&amp;quot;. COLING-2000, July 31-August 4 2000,
Saarbrucken, Germany.
Bonn, Lars. 1991. &amp;quot;The automatic induction of
morphological regularities&amp;quot;. Technical Report
RUUL-22, Department of Linguistics, Upp-
sala University, Sweden.
Brasington, R., S. Jones, C. Biggs. 1988. The
automatic induction of morphological rules.
Literary and Linguistic Computing 3(2).
Daelemans, Walter, Peter Berck, Steven Gillis.
1996. &amp;quot;Unsupervised discovery of phonolog-
ical categories through supervised learning
of morphological rules&amp;quot;. COLING-96, Copen-
hagen.
Garvin, Paul L. 1967. &amp;quot;The automation of dis-
covery procedure in linguistics&amp;quot;. Language
43(1), pp172-178.
Gilloux, M. 1991. &amp;quot;Automatic learning of word
transducers from examples&amp;quot;. Fifth EA CL,
Berlin.
Goldsmith, John. 1998. &amp;quot;Unsupervised
learning of the morphology of a nat-
ural language&amp;quot;. Unpublished ms. See
http ://humanities . uchicago . edu/f acuity/goldsmith!
Johnson,Mark. 1984. &amp;quot;A discovery procedure
for creating phonological rules&amp;quot;. COLING-84,
</bodyText>
<page confidence="0.580014">
pp344-347.
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.875780">
<title confidence="0.999396">Morpholog: Constrained and Supervised Learning of Morphology</title>
<author confidence="0.987855">Remi Zajac</author>
<affiliation confidence="0.974809">Computing Research Laboratory, New Mexico State</affiliation>
<email confidence="0.999465">zajacOcrl.nmsu.edu</email>
<abstract confidence="0.9934156">We present an automated method for building morphological analyzers using limited data elicited from a linguist. The system uses an induction procedure based on an extended edit distance algorithm to automate the discovery of morphological rules from examples. One of the requirements of the method is to minimize the size of the training data. The learning algorithm incorporates morphological language parameters, defined by the user, that constrains the space of the induction procedure. The result is a set of morphological rules that can be inspected by the user and further compiled into a morphological analyzer (or generator).</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="false">
<authors>
<author>Lexicography</author>
</authors>
<volume>1</volume>
<pages>451--456</pages>
<marker>Lexicography, </marker>
<rawString>Lexicography, Vol.1. pp451-456.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jospeh Kruskal</author>
<author>David Sankoff</author>
</authors>
<title>An Anthology of Algorithms and Concepts for Sequence Comparison&amp;quot;.</title>
<date>1999</date>
<booktitle>In David Sankoff &amp; Jospeh Kruskal (eds.) Time Warps, String Edits, and Macromolecules. The Theory and Practice of Sequence Comparison.</booktitle>
<publisher>CSLI Publications.</publisher>
<marker>Kruskal, Sankoff, 1999</marker>
<rawString>Kruskal, Jospeh &amp; David Sankoff. 1999. &amp;quot;An Anthology of Algorithms and Concepts for Sequence Comparison&amp;quot;. In David Sankoff &amp; Jospeh Kruskal (eds.) Time Warps, String Edits, and Macromolecules. The Theory and Practice of Sequence Comparison. CSLI Publications.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Evelin Kuusik</author>
</authors>
<title>Learning morphology: algorithms for the identification of the stem changes&amp;quot;.</title>
<date>1996</date>
<pages>96</pages>
<marker>Kuusik, 1996</marker>
<rawString>Kuusik, Evelin. 1996. &amp;quot;Learning morphology: algorithms for the identification of the stem changes&amp;quot;. COLING-96.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Sergei Nirenburg</author>
</authors>
<title>Project Boas: A Linguist-in-a-box as a multi-purpose language resource&amp;quot;.</title>
<date>1998</date>
<pages>98</pages>
<marker>Nirenburg, 1998</marker>
<rawString>Nirenburg, Sergei. 1998. &amp;quot;Project Boas: A Linguist-in-a-box as a multi-purpose language resource&amp;quot;. COLING-98.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Sergei Nirenburg</author>
<author>Victor Raskin</author>
</authors>
<title>Universal grammar and lexis for quick ramp-up of MT systems&amp;quot;.</title>
<date>1998</date>
<pages>98</pages>
<marker>Nirenburg, Raskin, 1998</marker>
<rawString>Nirenburg, Sergei, &amp; Victor Raskin. 1998. &amp;quot;Universal grammar and lexis for quick ramp-up of MT systems&amp;quot;. LREC-98.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kemal Oflazer</author>
<author>Sergei Nirenburg</author>
<author>Marjorie McShane</author>
</authors>
<title>Bootstrapping morphological analyzer by combining human elicitation and machine learning&amp;quot;. Computational Linguistics.</title>
<date>2000</date>
<note>(to appear)</note>
<marker>Oflazer, Nirenburg, McShane, 2000</marker>
<rawString>Oflazer, Kemal, Sergei Nirenburg, Marjorie McShane. 2000. &amp;quot;Bootstrapping morphological analyzer by combining human elicitation and machine learning&amp;quot;. Computational Linguistics. (to appear)</rawString>
</citation>
<citation valid="true">
<authors>
<author>S F Pilato</author>
<author>R C Berwick</author>
</authors>
<title>Reversible automata and the induction of the English auxiliary system. 23rd ACL,</title>
<date>1985</date>
<location>Chicago.</location>
<marker>Pilato, Berwick, 1985</marker>
<rawString>Pilato, S.F., R.C. Berwick. 1985. Reversible automata and the induction of the English auxiliary system. 23rd ACL, Chicago.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Giorgo Satta</author>
<author>John Anderson</author>
</authors>
<title>String transformation Learning&amp;quot;.</title>
<date>1997</date>
<journal>A CL/EA</journal>
<pages>97</pages>
<marker>Satta, Anderson, 1997</marker>
<rawString>Satta, Giorgo, &amp; John Anderson. 1997. &amp;quot;String transformation Learning&amp;quot;. A CL/EA CL-97.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D Tufis</author>
</authors>
<title>It would be much easier if Went were GOED&amp;quot;</title>
<date>1989</date>
<booktitle>4th EACL,</booktitle>
<location>Manchester.</location>
<marker>Tufis, 1989</marker>
<rawString>Tufis, D. 1989. &amp;quot;It would be much easier if Went were GOED&amp;quot; . 4th EACL, Manchester.</rawString>
</citation>
<citation valid="true">
<authors>
<author>K Wothke</author>
</authors>
<title>Machine learning of morphological rules by generalization and analogy&amp;quot;. 11th COLING-86,</title>
<date>1986</date>
<location>Bonn.</location>
<marker>Wothke, 1986</marker>
<rawString>Wothke, K. 1986. &amp;quot;Machine learning of morphological rules by generalization and analogy&amp;quot;. 11th COLING-86, Bonn.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Remi Zajac</author>
</authors>
<title>Feature Structures, Unification and Finite State Transducers&amp;quot;.</title>
<date>1998</date>
<booktitle>Proc. of the International Workshop on Finite State Methods in Natural Language Processing, FSMNLP-98,</booktitle>
<pages>101--109</pages>
<institution>Bilkent University,</institution>
<location>Ankara,</location>
<marker>Zajac, 1998</marker>
<rawString>Zajac, Remi. 1998. &amp;quot;Feature Structures, Unification and Finite State Transducers&amp;quot;. Proc. of the International Workshop on Finite State Methods in Natural Language Processing, FSMNLP-98, Bilkent University, Ankara, Turkey. pp101-109.</rawString>
</citation>
<citation valid="true">
<authors>
<author>B T Zhang</author>
<author>Y-T Kim</author>
</authors>
<title>Morphological analysis and synthesis by automated discovery and acquisition of linguistic rules&amp;quot;. 13rd COLING-90,</title>
<date>1990</date>
<location>Helsinki.</location>
<marker>Zhang, Kim, 1990</marker>
<rawString>Zhang, B.T., Y.-T.Kim. 1990. &amp;quot;Morphological analysis and synthesis by automated discovery and acquisition of linguistic rules&amp;quot;. 13rd COLING-90, Helsinki.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>