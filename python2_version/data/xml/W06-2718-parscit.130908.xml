<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.028717">
<title confidence="0.998604">
A Standoff Annotation Interface between DELPH-IN Components
</title>
<author confidence="0.999097">
Benjamin Waldron and Ann Copestake
</author>
<affiliation confidence="0.831213">
University of Cambridge Computer Laboratory
JJ Thomson Avenue
</affiliation>
<address confidence="0.994381">
Cambridge CB3 0FD, UK
</address>
<email confidence="0.999654">
{bmw20,aac10}@cl.cam.ac.uk
</email>
<sectionHeader confidence="0.998605" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999967363636364">
We present a standoff annotation frame-
work for the integration of NLP compo-
nents, currently implemented in the con-
text of the DELPH-IN tools1. This pro-
vides a flexible standoff pointer scheme
suitable for various types of data, a lat-
tice encodes structural ambiguity, intra-
annotation relationships are encoded, and
annotations are decorated with structured
content. We provide an XML serialization
for intercomponent communication.
</bodyText>
<sectionHeader confidence="0.994762" genericHeader="keywords">
1 Background
</sectionHeader>
<bodyText confidence="0.999959909090909">
An NLP system aims to map linguistic data to
a description at some suitable level of represen-
tation. To achieve this various component pro-
cesses must perform complex tasks. Increasingly
these individual processes are performed by dis-
tinct software components in cooperation. The
expressiveness of communication between such
components hence becomes an issue. For exam-
ple: we may wish to preserve a linkage from a
final semantic analysis to the raw data input; we
may wish to pass ambiguity to some later stage
where it is more appropriately resolved; we may
wish to represent the dependence of certain analy-
ses on other analyses; and we require sufficient ex-
pressiveness for the content of individual analyses
(henceforth ‘annotations’). This work addresses
these issues.
Annotations are often associated with a doc-
ument inline. This provides a convenient and
straightforward method of annotating many doc-
uments, but suffers from well-known drawbacks.
We adopt standoff annotation as an alternative.
</bodyText>
<footnote confidence="0.885242">
1http://wiki.delph-in.net
</footnote>
<bodyText confidence="0.994421333333333">
Here annotations live in a separate standoff anno-
tation document, and are anchored in the raw data
via standoff pointers.
</bodyText>
<sectionHeader confidence="0.984417" genericHeader="introduction">
2 The DELPH-IN collaboration
</sectionHeader>
<bodyText confidence="0.99996225">
DELPH-IN is a loose international collaboration
of researchers developing open-source software
components for language processing. These com-
ponents include deep parsers, deep grammars for
various natural languages, and tools for shallower
processing. The HOG system (Callmeier et al.,
2004) for the integration of shallow and deep lin-
guistic processors (using a pipeline making use of
XML plus XSLT transformations to pass data be-
tween processors) was developed during the Deep
Thought project, as was a standard for the inte-
gration of semantic analyses produced by diverse
components: RMRS (Copestake, 2003) allows un-
derspecification of semantic analyses in such a
way that the analysis produced by a shallow com-
ponent may be considered an underspecification of
a fuller semantic analysis produced by a deeper
component. Other work (Waldron et al., 2006) has
provided a representation of partial analyses at the
level of tokenization/morphology – using a mod-
ification of MAF (Clement and de la Clergerie,
2005). Current work within the SciBorg project2
is investigating more fine-grained integration of
shallow and deep processors.
</bodyText>
<sectionHeader confidence="0.9993015" genericHeader="method">
3 Standoff Annotation Framework
(SAF)
</sectionHeader>
<bodyText confidence="0.99975125">
Our standoff annotation framework borrows heav-
ily from the MAF proposal. The key components
of our framework are (i) grounding in primary lin-
guistic data via flexible standoff pointers, (ii) dec-
</bodyText>
<footnote confidence="0.974648">
2http://www.sciborg.org.uk/
</footnote>
<page confidence="0.986714">
97
</page>
<equation confidence="0.761394315789474">
&lt;?xml version=’1.0’ encoding=’UTF8’?&gt;
&lt;!DOCTYPE saf SYSTEM ’saf.dtd’&gt;
&lt;saf addressing=’char’&gt;
&lt;olac:olac xmlns:olac=’http://www.language-archives.org/OLAC/1.0/’ xml
ns=’http://purl.org/dc/elements/1.1/’ xmlns:xsi=’http://www.w3.org/2001
/XMLSchema-instance’ xsi:schemaLocation=’http://www.language-archives.o
rg/OLAC/1.0/ http://www.language-archives.org/OLAC/1.0/olac.xsd’&gt;
&lt;creator&gt;LKB x-preprocessor&lt;/creator&gt;
&lt;created&gt;18:11:31 1/31/2006 (UTC)&lt;/created&gt;
&lt;/olac:olac&gt;
&lt;fsm init=’v0’ final=’v9’&gt;
&lt;state id=’v0’/&gt;...&lt;state id=’v9’/&gt;
&lt;annot type=’token’ id=’t1’ from=’0’ to=’6’ value=’Gutten’ source=’
v0’ target=’v1’/&gt;
...
&lt;annot type=’token’ id=’t11’ from=’30’ to=’31’ value=’.’ source=’v8
’ target=’v9’/&gt;
&lt;/fsm&gt;
&lt;/saf&gt;
</equation>
<figureCaption confidence="0.999988">
Figure 1: SAF XML (containing token lattice)
Figure 2: Parse tree (LKB)
</figureCaption>
<bodyText confidence="0.998166578947369">
oration of individual annotations with structured
content, (iii) representation of structural ambigu-
ity via a lattice of annotations and (iv) a structure
of intra-annotation dependencies. In each case we
have generalized heavily in order to apply the SAF
framework to a wide domain. The basic unit of the
SAF framework is the annotation. An annotation
possesses properties as outlined below.
Each annotation describes a given span in the
raw linguistic data. This span is specified by from
and to standoff pointers. In order to cope with dif-
ferent possible data formats (e.g. audio files, XML
&lt;saf document=’/home/bmw20/b110865
b.xml’ addressing=’xpoint’&gt;
&lt;annot type=’sentence’ id=’s93’ fr
om=’/1/3/54.3’ to=’/1/3/58.89’ val
ue=’The results of this study are
depicted in Table 2&lt;p/&gt;’/&gt;
&lt;/saf&gt;
</bodyText>
<figureCaption confidence="0.999382">
Figure 3: A ’sentence’ annotation
</figureCaption>
<bodyText confidence="0.99996275">
text, pdf files) we make the pointer scheme a prop-
erty of each individual SAF object. So annotations
with respect to an audio file may use frame off-
sets, whilst for an XML text file we may use char-
acter (or more sophisticated xpoint-based) point-
ers. When processing XML text files, we have
found it easiest to work with a hybrid approach to
the standoff pointer scheme. Existing non-XML-
aware processing components can often be easily
adapted to produce (Unicode) character pointers;
for XML-aware components it is easier to work
with XML-aware pointing schemes – here we use
an extension of the xpoint scheme described in the
XPath specification3. A mapping between these
two sets of points provides interconversion suffi-
cient for our needs.
</bodyText>
<footnote confidence="0.953313">
3For example: /1/3.2 specifies the second point in the third
element of the first element of the root node, and an extension
allows text nodes in non-elements to be referenced also.
</footnote>
<page confidence="0.978565">
98
</page>
<figure confidence="0.8919148">
&lt;fs type=&amp;quot;ne-organisation&amp;quot;&gt;
&lt;f name=&amp;quot;OrgName&amp;quot;&gt;National Aerona
utics and Space Administration&lt;/f&gt;
&lt;f name=&amp;quot;OrgType&amp;quot;&gt;institution&lt;/f&gt;
&lt;/fs&gt;
</figure>
<figureCaption confidence="0.999373">
Figure 4: Named entity FSR content
</figureCaption>
<bodyText confidence="0.999976153846154">
Each annotation possesses a content, provid-
ing a (structured) description of the linguistic data
covered by the annotation. E.g. the content of an
annotation describing a token may be the text of
the token itself (see fig. 1); the content of an anno-
tation describing a named entity may be a feature
structure describing properties of the entity (see
fig. 4); the content of an annotation describing the
semantics of a sentence may be an RMRS descrip-
tion (see fig. 6). In most cases we describe this
content via a simple text string, or a feature struc-
ture following the TEI/ISO specification4. But in
some cases other representations are more appro-
priate (such cases are signalled by the type prop-
erty on annotations). The content will generally
contain meta-information in addition to the pure
content itself. The precise specification for the
content of different annotation types is a current
thrust of development.
Each annotation lives in a global lattice. Use of
a lattice (consisting of a set of nodes – including
a special start node and end node – and a set of
edges each with a source node and a target node)
allows us to handle the ambiguity seen in linguistic
analyses of natural languages. E.g. an automatic
speech recognition system may output a word lat-
tice, and a lattice representation can be very useful
in other contexts where we do not wish to collapse
the space of alternative hypotheses too early.
Fig. 2 shows a Norwegian sentence5 for which
the token lattice is very useful. Here the posses-
sive s clitic may attach to any word, but unlike in
English no apostrophe is used. Hence it not fea-
sible for the tokenizer to resolve this ambiguity
in tokenisation. The token lattice (produced by a
regex-based SAF-aware preprocessor) provides an
elegant solution to this problem: between nodes 2
and 4 (and nodes 4 and 6) the lattice provides alter-
native paths.6 The parser is able to resolve the am-
</bodyText>
<footnote confidence="0.9882634">
4http://www.tei-c.org/release/doc/tei-p5-
doc/html/FS.html
5Translation: The boy who is sitting’s house is yellow.
6The sentence also exhibits the same phenomena for the
final period – it could form part of an abbreviation.
</footnote>
<bodyText confidence="0.985921833333333">
0-1 [1] Gutten &lt;0 c 6&gt;
1-2 [2] som &lt;7 c 10&gt;
2-3 [3] sitter &lt;11 c 17&gt;
2-4 [5] sitters &lt;11 c 18&gt;
3-4 [4] s &lt;16 c 18&gt;
4-5 [6] hu &lt;19 c 21&gt;
4-6 [8] hus &lt;19 c 22&gt;
5-6 [7] s &lt;20 c 22&gt;
6-7 [9] er &lt;23 c 25&gt;
7-8 [10] gult &lt;26 c 30&gt;
7-9 [12] gult. &lt;26 c 31&gt;
8-9 [11] . &lt;30 c 31&gt;
</bodyText>
<figureCaption confidence="0.8782175">
Figure 5: Token lattice with character-point stand-
off pointers
</figureCaption>
<bodyText confidence="0.999220444444444">
biguity with lexical and syntactic knowledge un-
available to the preprocessor component. See fig.
5 for a simple representation of the token lattice,
and fig. 1 for the equivalent SAF XML.
Each annotation also lives in a hierarchy of an-
notation dependencies built over the lattice. E.g.
sentence splitting may be the lowest level; then
from each sentence we obtain a set (lattice) of to-
kens; for individual tokens (or each set of tokens
on a partial path through the lattice) we may ob-
tain an analysis from a named-entity component.
A parser may build on top of this, producing per-
haps a semantic analysis for certain paths in the
lattice. Each such level consists of a set of annota-
tions each of which may be said to build on a set
of lower annotations. This is encoded by means of
a depends on property on each annotation. The an-
notation in fig. 6 exhibits the use of the depends on
property to mark its dependency on the annotation
shown in fig. 3.
A number of well-formedness constrains apply
to SAF objects. For example, the ordering of
standoff pointers must be consistent with the or-
dering of annotation elements through all paths in
the lattice. Sets of annotations related (directly or
indirectly) via the depends on property must lie on
a single path through the lattice.
</bodyText>
<sectionHeader confidence="0.994387" genericHeader="method">
4 XML Serialization
</sectionHeader>
<bodyText confidence="0.999247">
Our SAF XML serialization is provided both for
inter-component communication and for persis-
tent storage. XML provides a clean standards-
based framework in which to serialize our SAF
objects. Our serialization was heavily influenced
by the MAF XML serialization.
</bodyText>
<page confidence="0.992668">
99
</page>
<figure confidence="0.839054666666667">
&lt;annot type=’rmrs’ deps=’s93’&gt;
&lt;label vid=’1’/&gt;
&lt;ep cfrom=’18476’ cto=’18526’&gt;
&lt;gpred&gt;prpstn_m_rel&lt;/gpred&gt;
&lt;label vid=’1’/&gt;
&lt;var sort=’e’ vid=’2’
tense=’present’/&gt;
&lt;/ep&gt;
...
&lt;rarg&gt;
&lt;rargname&gt;MARG&lt;/rargname&gt;
&lt;label vid=’1’/&gt;
&lt;var sort=’h’ vid=’3’/&gt;
&lt;/rarg&gt;
&lt;/annot&gt;
</figure>
<figureCaption confidence="0.999868">
Figure 6: An annotation with RMRS content
</figureCaption>
<bodyText confidence="0.999960714285714">
The SAF XML serialization is contained within
the top saf XML element. Here the pointer ad-
dressing scheme used (e.g. char for charac-
ter point offsets, xpoint for our xpoint-based
scheme), and the location of the primary data are
specified as attributes. This element may contain
an optional olac element7 to specify metadata
(e.g. creator) and a single fsm element holds the
rest of the object (as shorthand we also allow a se-
quence of the annot elements defined below in
place of the fsm). The fsm element consists of
a number of state elements (with attribute id)
declaring the available lattice nodes, followed by
annot annotation definitions.
Each annotation (annot) element possesses
the following attributes: from and to give stand-
off pointers into the primary data, encoded accord-
ing to the scheme specified by the saf element’s
addressing attribute; source and target
each give a state id (absent if the annotations
are listed sequentially outside of an fsr element);
deps is a set of idrefs; value is shorthand for
a string-valued content; type is shorthand for a
particular type of annotation content. The annota-
tion content, if not a value string, is represented
using the TEI/ISO FSR XML format or the appro-
priate XML format corresponding to the annota-
tion type.
</bodyText>
<sectionHeader confidence="0.999446" genericHeader="method">
5 Summary
</sectionHeader>
<bodyText confidence="0.9984195">
We are in the process of SAF-enabling a num-
ber of the DELPH-IN processing components.
</bodyText>
<footnote confidence="0.688907">
7http://www.language-archives.org/OLAC/metadata.html
</footnote>
<bodyText confidence="0.9999463125">
A SAF-aware sentence splitter produces SAF
XML describing the span of each sentence, from
which a SAF-aware (and XML-aware) preproces-
sor/tokeniser maps raw sentence text into a SAF
XML token lattice (with some additional annota-
tion to describe tokens such as digit sequences).
External preprocessor components (such as a mor-
phological analyser for Japanese) may also be ma-
nipulated in order to provide SAF input to the
parser. SAF is integrated into the parser of the
LKB grammar development environment (Copes-
take, 2002) and can also be used with the PET run-
time parser (Callmeier, 2000). The MAF XML
format (compatible with SAF) is also integrated
into the HOG system, and we hope to generalize
this to the full SAF framework.
</bodyText>
<sectionHeader confidence="0.999763" genericHeader="conclusions">
6 Acknowledgements
</sectionHeader>
<bodyText confidence="0.999828625">
The authors wish to thank Bernd Kiefer, Ul-
rich Schaefer, Dan Flickinger, Stephan Oepen and
other colleagues within the DELPH-IN collabo-
ration for many informative discussions. This
work was partly funded by a grant from Boeing
to Cambridge University, partly by the NorSource
Grammar Project8 at NTNU, and partly by EPSRC
project EP/C010035/1.
</bodyText>
<sectionHeader confidence="0.999547" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999009666666667">
Ulrich Callmeier, Andreas Eisele, Ulrich Schaefer, and
Melanie Siegel. 2004. The DeepThought Core Ar-
chitecture Framework. In Proceedings of the 4th In-
ternational Conference on Language Resources and
Evaluation, LREC’04, Lisbon, Portugal.
Ulrich Callmeier. 2000. PET. A Platform for Exper-
imentation with Efficient HPSG Processing Tech-
niques. Journal of Natural Language Engineering,
6(1):99–108.
Lionel Clement and Eric Villemonte de la Clergerie.
2005. MAF: a morphosyntactic annotation frame-
work. In Proceedings of the 2nd Language and
Technology Conference, Poznan, Poland.
Ann Copestake. 2002. Implementing Typed Feature
Structure Grammars. CSLI Publications, Stanford.
Ann Copestake. 2003. Report on the Design of RMRS.
Technical Report D1.1a, University of Cambridge,
UK.
Benjamin Waldron, Ann Copestake, Ulrich Schaefer,
and Bernd Kiefer. 2006. Preprocessing and Tokeni-
sation Standards in DELPH-IN Tools. In Proceed-
ings of the 5th International Conference On Lan-
guage Resources and Evaluation, LREC’06, Genoa,
Italy.
</reference>
<footnote confidence="0.840752">
8http://www.ling.hf.ntnu.no/forskning/norsource/
</footnote>
<page confidence="0.971756">
100
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.020844">
<title confidence="0.999096">A Standoff Annotation Interface between DELPH-IN Components</title>
<author confidence="0.977727">Waldron</author>
<affiliation confidence="0.995968">University of Cambridge Computer JJ Thomson</affiliation>
<address confidence="0.909412">Cambridge CB3 0FD,</address>
<abstract confidence="0.996915571906355">We present a standoff annotation framework for the integration of NLP components, currently implemented in the conof the DELPH-IN This provides a flexible standoff pointer scheme suitable for various types of data, a lattice encodes structural ambiguity, intraannotation relationships are encoded, and annotations are decorated with structured content. We provide an XML serialization for intercomponent communication. 1 Background An NLP system aims to map linguistic data to a description at some suitable level of representation. To achieve this various component processes must perform complex tasks. Increasingly these individual processes are performed by distinct software components in cooperation. The expressiveness of communication between such components hence becomes an issue. For example: we may wish to preserve a linkage from a final semantic analysis to the raw data input; we may wish to pass ambiguity to some later stage where it is more appropriately resolved; we may wish to represent the dependence of certain analyses on other analyses; and we require sufficient expressiveness for the content of individual analyses (henceforth ‘annotations’). This work addresses these issues. Annotations are often associated with a document inline. This provides a convenient and straightforward method of annotating many documents, but suffers from well-known drawbacks. We adopt standoff annotation as an alternative. Here annotations live in a separate standoff annotation document, and are anchored in the raw data via standoff pointers. 2 The DELPH-IN collaboration DELPH-IN is a loose international collaboration of researchers developing open-source software components for language processing. These components include deep parsers, deep grammars for various natural languages, and tools for shallower processing. The HOG system (Callmeier et al., 2004) for the integration of shallow and deep linguistic processors (using a pipeline making use of XML plus XSLT transformations to pass data between processors) was developed during the Deep Thought project, as was a standard for the integration of semantic analyses produced by diverse components: RMRS (Copestake, 2003) allows underspecification of semantic analyses in such a way that the analysis produced by a shallow component may be considered an underspecification of a fuller semantic analysis produced by a deeper component. Other work (Waldron et al., 2006) has provided a representation of partial analyses at the level of tokenization/morphology – using a modification of MAF (Clement and de la Clergerie, Current work within the SciBorg is investigating more fine-grained integration of shallow and deep processors. 3 Standoff Annotation Framework (SAF) Our standoff annotation framework borrows heavily from the MAF proposal. The key components of our framework are (i) grounding in primary lindata via flexible standoff pointers, (ii) dec- 97 &lt;?xml version=’1.0’ encoding=’UTF8’?&gt; &lt;!DOCTYPE saf SYSTEM ’saf.dtd’&gt; &lt;saf addressing=’char’&gt; &lt;olac:olac xmlns:olac=’http://www.language-archives.org/OLAC/1.0/’ xml ns=’http://purl.org/dc/elements/1.1/’ xmlns:xsi=’http://www.w3.org/2001 /XMLSchema-instance’ xsi:schemaLocation=’http://www.language-archives.o rg/OLAC/1.0/ http://www.language-archives.org/OLAC/1.0/olac.xsd’&gt; &lt;creator&gt;LKB x-preprocessor&lt;/creator&gt; &lt;created&gt;18:11:31 1/31/2006 (UTC)&lt;/created&gt; &lt;/olac:olac&gt; &lt;fsm init=’v0’ final=’v9’&gt; &lt;state id=’v0’/&gt;...&lt;state id=’v9’/&gt; &lt;annot type=’token’ id=’t1’ from=’0’ to=’6’ value=’Gutten’ source=’ v0’ target=’v1’/&gt; ... &lt;annot type=’token’ id=’t11’ from=’30’ to=’31’ value=’.’ source=’v8 ’ target=’v9’/&gt; &lt;/fsm&gt; &lt;/saf&gt; Figure 1: SAF XML (containing token lattice) Figure 2: Parse tree (LKB) oration of individual annotations with structured content, (iii) representation of structural ambiguity via a lattice of annotations and (iv) a structure of intra-annotation dependencies. In each case we have generalized heavily in order to apply the SAF framework to a wide domain. The basic unit of the SAF framework is the annotation. An annotation possesses properties as outlined below. Each annotation describes a given span in the linguistic data. This span is specified by pointers. In order to cope with different possible data formats (e.g. audio files, XML &lt;saf document=’/home/bmw20/b110865 b.xml’ addressing=’xpoint’&gt; &lt;annot type=’sentence’ id=’s93’ fr om=’/1/3/54.3’ to=’/1/3/58.89’ val ue=’The results of this study are depicted in Table 2&amp;lt;p/&amp;gt;’/&gt; &lt;/saf&gt; Figure 3: A ’sentence’ annotation text, pdf files) we make the pointer scheme a property of each individual SAF object. So annotations with respect to an audio file may use frame offsets, whilst for an XML text file we may use character (or more sophisticated xpoint-based) pointers. When processing XML text files, we have found it easiest to work with a hybrid approach to the standoff pointer scheme. Existing non-XMLaware processing components can often be easily adapted to produce (Unicode) character pointers; for XML-aware components it is easier to work with XML-aware pointing schemes – here we use an extension of the xpoint scheme described in the A mapping between these two sets of points provides interconversion sufficient for our needs. example: the second point in the third element of the first element of the root node, and an extension allows text nodes in non-elements to be referenced also. 98 &lt;fs type=&amp;quot;ne-organisation&amp;quot;&gt; &lt;f name=&amp;quot;OrgName&amp;quot;&gt;National Aerona utics and Space Administration&lt;/f&gt; &lt;f name=&amp;quot;OrgType&amp;quot;&gt;institution&lt;/f&gt; &lt;/fs&gt; Figure 4: Named entity FSR content annotation possesses a providing a (structured) description of the linguistic data by the annotation. E.g. the an annotation describing a token may be the text of token itself (see fig. 1); the an annotation describing a named entity may be a feature structure describing properties of the entity (see 4); the an annotation describing the semantics of a sentence may be an RMRS description (see fig. 6). In most cases we describe this content via a simple text string, or a feature strucfollowing the TEI/ISO But in some cases other representations are more appro- (such cases are signalled by the propon annotations). The generally contain meta-information in addition to the pure content itself. The precise specification for the different annotation types is a current thrust of development. annotation lives in a global Use of of a set of nodes – including a special start node and end node – and a set of edges each with a source node and a target node) allows us to handle the ambiguity seen in linguistic analyses of natural languages. E.g. an automatic speech recognition system may output a word lattice, and a lattice representation can be very useful in other contexts where we do not wish to collapse the space of alternative hypotheses too early. 2 shows a Norwegian for which the token lattice is very useful. Here the possesmay attach to any word, but unlike in English no apostrophe is used. Hence it not feasible for the tokenizer to resolve this ambiguity in tokenisation. The token lattice (produced by a regex-based SAF-aware preprocessor) provides an elegant solution to this problem: between nodes 2 and 4 (and nodes 4 and 6) the lattice provides alter- The parser is able to resolve the amdoc/html/FS.html boy who is sitting’s house is sentence also exhibits the same phenomena for the final period – it could form part of an abbreviation. 0-1 [1] Gutten &lt;0 c 6&gt; 1-2 [2] som &lt;7 c 10&gt; 2-3 [3] sitter &lt;11 c 17&gt; 2-4 [5] sitters &lt;11 c 18&gt; 3-4 [4] s &lt;16 c 18&gt; 4-5 [6] hu &lt;19 c 21&gt; 4-6 [8] hus &lt;19 c 22&gt; 5-6 [7] s &lt;20 c 22&gt; 6-7 [9] er &lt;23 c 25&gt; 7-8 [10] gult &lt;26 c 30&gt; 7-9 [12] gult. &lt;26 c 31&gt; 8-9 [11] . &lt;30 c 31&gt; Figure 5: Token lattice with character-point standoff pointers biguity with lexical and syntactic knowledge unavailable to the preprocessor component. See fig. 5 for a simple representation of the token lattice, and fig. 1 for the equivalent SAF XML. Each annotation also lives in a hierarchy of andependencies built over the E.g. sentence splitting may be the lowest level; then from each sentence we obtain a set (lattice) of tokens; for individual tokens (or each set of tokens on a partial path through the lattice) we may obtain an analysis from a named-entity component. A parser may build on top of this, producing perhaps a semantic analysis for certain paths in the lattice. Each such level consists of a set of annotations each of which may be said to build on a set of lower annotations. This is encoded by means of on on each annotation. The anin fig. 6 exhibits the use of the on property to mark its dependency on the annotation shown in fig. 3. A number of well-formedness constrains apply to SAF objects. For example, the ordering of standoff pointers must be consistent with the ordering of annotation elements through all paths in the lattice. Sets of annotations related (directly or via the on must lie on a single path through the lattice. 4 XML Serialization Our SAF XML serialization is provided both for inter-component communication and for persistent storage. XML provides a clean standardsbased framework in which to serialize our SAF objects. Our serialization was heavily influenced by the MAF XML serialization. 99 &lt;annot type=’rmrs’ deps=’s93’&gt; &lt;label vid=’1’/&gt; &lt;ep cfrom=’18476’ cto=’18526’&gt; &lt;gpred&gt;prpstn_m_rel&lt;/gpred&gt; &lt;label vid=’1’/&gt; &lt;var sort=’e’ vid=’2’ tense=’present’/&gt; &lt;/ep&gt; ... &lt;rarg&gt; &lt;rargname&gt;MARG&lt;/rargname&gt; &lt;label vid=’1’/&gt; &lt;var sort=’h’ vid=’3’/&gt; &lt;/rarg&gt; &lt;/annot&gt; Figure 6: An annotation with RMRS content The SAF XML serialization is contained within top element. Here the pointer adscheme used (e.g. characpoint offsets, our xpoint-based scheme), and the location of the primary data are specified as attributes. This element may contain optional to specify metadata creator) and a single holds the rest of the object (as shorthand we also allow a seof the defined below in of the The consists of number of (with attribute declaring the available lattice nodes, followed by definitions. annotation element possesses following attributes: standoff pointers into the primary data, encoded accordto the scheme specified by the give a (absent if the annotations listed sequentially outside of an a set of idrefs; shorthand for string-valued content; shorthand for a particular type of annotation content. The annotacontent, if not a is represented using the TEI/ISO FSR XML format or the appropriate XML format corresponding to the annota- 5 Summary We are in the process of SAF-enabling a number of the DELPH-IN processing components. A SAF-aware sentence splitter produces SAF XML describing the span of each sentence, from which a SAF-aware (and XML-aware) preprocessor/tokeniser maps raw sentence text into a SAF XML token lattice (with some additional annotation to describe tokens such as digit sequences). External preprocessor components (such as a morphological analyser for Japanese) may also be manipulated in order to provide SAF input to the parser. SAF is integrated into the parser of the LKB grammar development environment (Copestake, 2002) and can also be used with the PET runtime parser (Callmeier, 2000). The MAF XML format (compatible with SAF) is also integrated into the HOG system, and we hope to generalize this to the full SAF framework. 6 Acknowledgements The authors wish to thank Bernd Kiefer, Ulrich Schaefer, Dan Flickinger, Stephan Oepen and other colleagues within the DELPH-IN collaboration for many informative discussions. This work was partly funded by a grant from Boeing to Cambridge University, partly by the NorSource at NTNU, and partly by EPSRC project EP/C010035/1.</abstract>
<note confidence="0.758726291666666">References Ulrich Callmeier, Andreas Eisele, Ulrich Schaefer, and Melanie Siegel. 2004. The DeepThought Core Ar- Framework. In of the 4th International Conference on Language Resources and Lisbon, Portugal. Ulrich Callmeier. 2000. PET. A Platform for Experimentation with Efficient HPSG Processing Techof Natural Language 6(1):99–108. Lionel Clement and Eric Villemonte de la Clergerie. 2005. MAF: a morphosyntactic annotation frame- In of the 2nd Language and Poznan, Poland. Copestake. 2002. Typed Feature CSLI Publications, Stanford. Ann Copestake. 2003. Report on the Design of RMRS. Technical Report D1.1a, University of Cambridge, UK. Benjamin Waldron, Ann Copestake, Ulrich Schaefer, and Bernd Kiefer. 2006. Preprocessing and Tokeni- Standards in DELPH-IN Tools. In Proceedings of the 5th International Conference On Lan- Resources and Evaluation, Genoa,</note>
<address confidence="0.7919585">Italy. 100</address>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Ulrich Callmeier</author>
<author>Andreas Eisele</author>
<author>Ulrich Schaefer</author>
<author>Melanie Siegel</author>
</authors>
<title>The DeepThought Core Architecture Framework.</title>
<date>2004</date>
<booktitle>In Proceedings of the 4th International Conference on Language Resources and Evaluation, LREC’04,</booktitle>
<location>Lisbon, Portugal.</location>
<contexts>
<context position="2127" citStr="Callmeier et al., 2004" startWordPosition="307" endWordPosition="310"> convenient and straightforward method of annotating many documents, but suffers from well-known drawbacks. We adopt standoff annotation as an alternative. 1http://wiki.delph-in.net Here annotations live in a separate standoff annotation document, and are anchored in the raw data via standoff pointers. 2 The DELPH-IN collaboration DELPH-IN is a loose international collaboration of researchers developing open-source software components for language processing. These components include deep parsers, deep grammars for various natural languages, and tools for shallower processing. The HOG system (Callmeier et al., 2004) for the integration of shallow and deep linguistic processors (using a pipeline making use of XML plus XSLT transformations to pass data between processors) was developed during the Deep Thought project, as was a standard for the integration of semantic analyses produced by diverse components: RMRS (Copestake, 2003) allows underspecification of semantic analyses in such a way that the analysis produced by a shallow component may be considered an underspecification of a fuller semantic analysis produced by a deeper component. Other work (Waldron et al., 2006) has provided a representation of p</context>
</contexts>
<marker>Callmeier, Eisele, Schaefer, Siegel, 2004</marker>
<rawString>Ulrich Callmeier, Andreas Eisele, Ulrich Schaefer, and Melanie Siegel. 2004. The DeepThought Core Architecture Framework. In Proceedings of the 4th International Conference on Language Resources and Evaluation, LREC’04, Lisbon, Portugal.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ulrich Callmeier</author>
</authors>
<title>PET. A Platform for Experimentation with Efficient HPSG Processing Techniques.</title>
<date>2000</date>
<journal>Journal of Natural Language Engineering,</journal>
<volume>6</volume>
<issue>1</issue>
<marker>Callmeier, 2000</marker>
<rawString>Ulrich Callmeier. 2000. PET. A Platform for Experimentation with Efficient HPSG Processing Techniques. Journal of Natural Language Engineering, 6(1):99–108.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Lionel Clement</author>
</authors>
<title>Eric Villemonte de la Clergerie.</title>
<date>2005</date>
<booktitle>In Proceedings of the 2nd Language and Technology Conference,</booktitle>
<location>Poznan, Poland.</location>
<marker>Clement, 2005</marker>
<rawString>Lionel Clement and Eric Villemonte de la Clergerie. 2005. MAF: a morphosyntactic annotation framework. In Proceedings of the 2nd Language and Technology Conference, Poznan, Poland.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ann Copestake</author>
</authors>
<title>Implementing Typed Feature Structure Grammars.</title>
<date>2002</date>
<publisher>CSLI Publications, Stanford.</publisher>
<marker>Copestake, 2002</marker>
<rawString>Ann Copestake. 2002. Implementing Typed Feature Structure Grammars. CSLI Publications, Stanford.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ann Copestake</author>
</authors>
<title>Report on the Design of RMRS.</title>
<date>2003</date>
<tech>Technical Report D1.1a,</tech>
<institution>University of Cambridge, UK.</institution>
<contexts>
<context position="2445" citStr="Copestake, 2003" startWordPosition="360" endWordPosition="361">oration DELPH-IN is a loose international collaboration of researchers developing open-source software components for language processing. These components include deep parsers, deep grammars for various natural languages, and tools for shallower processing. The HOG system (Callmeier et al., 2004) for the integration of shallow and deep linguistic processors (using a pipeline making use of XML plus XSLT transformations to pass data between processors) was developed during the Deep Thought project, as was a standard for the integration of semantic analyses produced by diverse components: RMRS (Copestake, 2003) allows underspecification of semantic analyses in such a way that the analysis produced by a shallow component may be considered an underspecification of a fuller semantic analysis produced by a deeper component. Other work (Waldron et al., 2006) has provided a representation of partial analyses at the level of tokenization/morphology – using a modification of MAF (Clement and de la Clergerie, 2005). Current work within the SciBorg project2 is investigating more fine-grained integration of shallow and deep processors. 3 Standoff Annotation Framework (SAF) Our standoff annotation framework bor</context>
</contexts>
<marker>Copestake, 2003</marker>
<rawString>Ann Copestake. 2003. Report on the Design of RMRS. Technical Report D1.1a, University of Cambridge, UK.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Benjamin Waldron</author>
<author>Ann Copestake</author>
<author>Ulrich Schaefer</author>
<author>Bernd Kiefer</author>
</authors>
<title>Preprocessing and Tokenisation Standards in DELPH-IN Tools.</title>
<date>2006</date>
<booktitle>In Proceedings of the 5th International Conference On Language Resources and Evaluation, LREC’06,</booktitle>
<location>Genoa, Italy.</location>
<contexts>
<context position="2692" citStr="Waldron et al., 2006" startWordPosition="398" endWordPosition="401">ower processing. The HOG system (Callmeier et al., 2004) for the integration of shallow and deep linguistic processors (using a pipeline making use of XML plus XSLT transformations to pass data between processors) was developed during the Deep Thought project, as was a standard for the integration of semantic analyses produced by diverse components: RMRS (Copestake, 2003) allows underspecification of semantic analyses in such a way that the analysis produced by a shallow component may be considered an underspecification of a fuller semantic analysis produced by a deeper component. Other work (Waldron et al., 2006) has provided a representation of partial analyses at the level of tokenization/morphology – using a modification of MAF (Clement and de la Clergerie, 2005). Current work within the SciBorg project2 is investigating more fine-grained integration of shallow and deep processors. 3 Standoff Annotation Framework (SAF) Our standoff annotation framework borrows heavily from the MAF proposal. The key components of our framework are (i) grounding in primary linguistic data via flexible standoff pointers, (ii) dec2http://www.sciborg.org.uk/ 97 &lt;?xml version=’1.0’ encoding=’UTF8’?&gt; &lt;!DOCTYPE saf SYSTEM </context>
</contexts>
<marker>Waldron, Copestake, Schaefer, Kiefer, 2006</marker>
<rawString>Benjamin Waldron, Ann Copestake, Ulrich Schaefer, and Bernd Kiefer. 2006. Preprocessing and Tokenisation Standards in DELPH-IN Tools. In Proceedings of the 5th International Conference On Language Resources and Evaluation, LREC’06, Genoa, Italy.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>