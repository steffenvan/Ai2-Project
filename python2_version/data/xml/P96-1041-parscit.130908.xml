<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000004">
<title confidence="0.9976525">
An Empirical Study of Smoothing Techniques for Language
Modeling
</title>
<author confidence="0.99035">
Stanley F. Chen
</author>
<affiliation confidence="0.920469">
Harvard University
Aiken Computation Laboratory
</affiliation>
<address confidence="0.981443">
33 Oxford St.
Cambridge, MA 02138
</address>
<email confidence="0.99958">
sfc@eecs.harvard.edu
</email>
<author confidence="0.9939">
Joshua Goodman
</author>
<affiliation confidence="0.9218345">
Harvard University
Aiken Computation Laboratory
</affiliation>
<address confidence="0.9814655">
33 Oxford St.
Cambridge, MA 02138
</address>
<email confidence="0.999642">
goodman@eecs.harvard.edu
</email>
<sectionHeader confidence="0.997399" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999429705882353">
We present an extensive empirical com-
parison of several smoothing techniques in
the domain of language modeling, includ-
ing those described by Jelinek and Mer-
cer (1980), Katz (1987), and Church and
Gale (1991). We investigate for the first
time how factors such as training data
size, corpus (e.g., Brown versus Wall Street
Journal), and n-gram order (bigram versus
trigram) affect the relative performance of
these methods, which we measure through
the cross-entropy of test data. In addition,
we introduce two novel smoothing tech-
niques, one a variation of Jelinek-Mercer
smoothing and one a very simple linear in-
terpolation technique, both of which out-
perform existing methods.
</bodyText>
<sectionHeader confidence="0.999519" genericHeader="introduction">
1 Introduction
</sectionHeader>
<bodyText confidence="0.999974788461538">
Smoothing is a technique essential in the construc-
tion of n-gram language models, a staple in speech
recognition (Bahl, Jelinek, and Mercer, 1983) as well
as many other domains (Church, 1988; Brown et al.,
1990; Kernighan, Church, and Gale, 1990). A lan-
guage model is a probability distribution over strings
P(s) that attempts to reflect the frequency with
which each string s occurs as a sentence in natu-
ral text. Language models are used in speech recog-
nition to resolve acoustically ambiguous utterances.
For example, if we have that PO takes two) &gt;&gt;
P(it takes too), then we know ceieris paribus to pre-
fer the former transcription over the latter.
While smoothing is a central issue in language
modeling, the literature lacks a definitive compar-
ison between the many existing techniques. Previ-
ous studies (Nadas, 1984; Katz, 1987; Church and
Gale, 1991; MacKay and Peto, 1995) only compare
a small number of methods (typically two) on a sin-
gle corpus and using a single training data size. As
a result, it is currently difficult for a researcher to
intelligently choose between smoothing schemes.
In this work, we carry out an extensive
empirical comparison of the most widely used
smoothing techniques, including those described
by Jelinek and Mercer (1980), Katz (1987), and
Church and Gale (1991). We carry out experiments
over many training data sizes on varied corpora us-
ing both bigram and trigram models. We demon-
strate that the relative performance of techniques
depends greatly on training data size and n-gram
order. For example, for bigram models produced
from large training sets Church-Gale smoothing has
superior performance, while Katz smoothing per-
forms best on bigram models produced from smaller
data. For the methods with parameters that can
be tuned to improve performance, we perform an
automated search for optimal values and show that
sub-optimal parameter selection can significantly de-
crease performance. To our knowledge, this is the
first smoothing work that systematically investigates
any of these issues.
In addition, we introduce two novel smooth-
ing techniques: the first belonging to the class of
smoothing models described by Jelinek and Mer-
cer, the second a very simple linear interpolation
method. While being relatively simple to imple-
ment, we show that these methods yield good perfor-
mance in bigram models and superior performance
in trigram models.
We take the performance of a method in to be its
cross-entropy on test data
</bodyText>
<equation confidence="0.9664055">
_ Pm(ti)
NT i.1
</equation>
<bodyText confidence="0.999729">
where Pin (ti) denotes the language model produced
with method 711 and where the test data T is com-
posed of sentences (ti, , and contains a total
of NT words. The entropy is inversely related to
the average probability a model assigns to sentences
in the test data, and it is generally assumed that
lower entropy correlates with better performance in
applications.
</bodyText>
<page confidence="0.719965">
17,
1
310
</page>
<subsectionHeader confidence="0.98008">
1.1 Smoothing n-gram Models
</subsectionHeader>
<bodyText confidence="0.979289">
In n-gram language modeling, the probability of a
string P(s) is expressed as the product of the prob-
abilities of the words that compose the string, with
each word probability conditional on the identity of
the last n — 1 words, i.e., ifs &apos;tut • • wi we have
</bodyText>
<equation confidence="0.99959">
P(s) = 11 P(wi H P(wilwii=n1+1) (1)
i=1 i.1
</equation>
<bodyText confidence="0.999947">
where tul denotes the words wi • •w1. Typically, n is
taken to be two or three, corresponding to a bigram
or trigram model, respectively.&apos;
Consider the case n = 2. To estimate the proba-
bilities P(wi jwi_i) in equation (1), one can acquire
a large corpus of text, which we refer to as training
data, and take
</bodyText>
<equation confidence="0.999467833333333">
PmL(wi iwi—i) = P(wi-iwi)
P(wi- i)
c(wi_iwi)/Ns
c(wi_i)/Ns
C(Wi_ 1214)
C(Wi_i)
</equation>
<bodyText confidence="0.998777739130435">
where c(a) denotes the number of times the string
a occurs in the text and Ns denotes the total num-
ber of words. This is called the maximum likelihood
(ML) estimate for P(wilwi_i).
While intuitive, the maximum likelihood estimate
is a poor one when the amount of training data is
small compared to the size of the model being built,
as is generally the case in language modeling. For ex-
ample, consider the situation where a pair of words,
or bigram, say burnish the, doesn&apos;t occur in the
training data. Then, we have PmL(thelburnish) = 0,
which is clearly inaccurate as this probability should
be larger than zero. A zero bigram probability can
lead to errors in speech recognition, as it disallows
the bigram regardless of how informative the acous-
tic signal is. The term smoothing describes tech-
niques for adjusting the maximum likelihood esti-
mate to hopefully produce more accurate probabili-
ties.
As an example, one simple smoothing technique is
to pretend each bigram occurs once more than it ac-
tually did (Lidstone, 1920; Johnson, 1932; Jeffreys,
1948), yielding
</bodyText>
<equation confidence="0.9996595">
P�i(wiw_i) =
c(wi_i) + IVI
</equation>
<bodyText confidence="0.982735470588235">
where V is the vocabulary, the set of all words be-
ing considered. This has the desirable quality of
&apos;To make the term P(wilw:=41) meaningful for
i &lt; n, one can pad the beginning of the string with
a distinguished token. In this work, we assume there are
n —1 such distinguished tokens preceding each sentence.
preventing zero bigram probabilities. However, this
scheme has the flaw of assigning the same probabil-
ity to say, burnish the and burnish thou (assuming
neither occurred in the training data), even though
intuitively the former seems more likely because the
word the is much more common than thou.
To address this, another smoothing technique is to
interpolate the bigram model with a unigram model
PmL(wi) = c(w)/N5, a model that reflects how of-
ten each word occurs in the training data. For ex-
ample, we can take
</bodyText>
<equation confidence="0.6239408">
Pinterp (wi I wi-1) = APA4L(wi Iwz_i)+ (1— A)PmL(wi)
getting the behavior that bigrams involving common
words are assigned higher probabilities (Jelinek and
Mercer, 1980).
c(w1:41) + 6111 (2)
</equation>
<bodyText confidence="0.997157363636364">
and where Lidstone and Jeffreys advocate 6 = 1.
Gale and Church (1990; 1994) have argued that this
method generally performs poorly.
The Good-Turing estimate (Good, 1953) is cen-
tral to many smoothing techniques. It is not used
directly for n-gram smoothing because, like additive
smoothing, it does not perform the interpolation of
lower- and higher-order models essential for good
performance. Good-Turing states that an n-gram
that occurs r times should be treated as if it had
occurred r* times, where
</bodyText>
<equation confidence="0.986069">
r* = (r + 1) nr+1
</equation>
<bodyText confidence="0.9998813">
and where n,. is the number of n-grams that occur
exactly r times in the training data.
Katz smoothing (1987) extends the intuitions of
Good-Turing by adding the interpolation of higher-
order models with lower-order models. It is perhaps
the most widely used smoothing technique in speech
recognition.
Church and Gale (1991) describe a smoothing
method that combines the Good-Turing estimate
with bucketing, the technique of partitioning a set
of n-grams into disjoint groups, where each group
is characterized independently through a set of pa-
rameters. Like Katz, models are defined recursively
in terms of lower-order models. Each n-gram is as-
signed to one of several buckets based on its fre-
quency predicted from lower-order models. Each
bucket is treated as a separate distribution and
Good-Turing estimation is performed within each,
giving corrected counts that are normalized to yield
probabilities.
</bodyText>
<equation confidence="0.8605935">
C(Wi_ Wi) + 1
2 Previous Work
</equation>
<bodyText confidence="0.835745666666667">
The simplest type of smoothing used in practice is
additive smoothing (Lidstone, 1920; Johnson, 1932;
Jeffreys, 1948), where we take
</bodyText>
<equation confidence="0.7449515">
c(wLn+i) + 6
Padd (Wi I witni +1) =
</equation>
<page confidence="0.90019">
311
</page>
<figure confidence="0.997866">
old bucketing new bucketing
0.8
0.8
OA
0.6
2
0.4
0.4
0.2
0.2
100000
10000
100
(1.001
0.01 0.1 10
average norvaino count in distribution minus one
10 100 1000
number of counts in distribution
.
°
vu
:1; • o
.44% :•
tit..•••4.6.&amp;quot; 0.
8.8 :Of.% .° . • ..
**. . tt.. •
..• et.8 •
•••
°
01:
</figure>
<figureCaption confidence="0.981353">
Figure 1: A values for old and new bucketing schemes for Jelinek-Mercer smoothing; each point represents a
single bucket
</figureCaption>
<bodyText confidence="0.9997596">
The other smoothing technique besides Katz
smoothing widely used in speech recognition is due
to Jelinek and Mercer (1980). They present a class
of smoothing models that involve linear interpola-
tion, e.g., Brown et al. (1992) take
</bodyText>
<equation confidence="0.9858304">
Pinterp (Wi I W! in&apos; +1) -=
Aw.-1 PML(Wi 1U4--n1+1)
i—n+1
(1 — Aevi.-1 ) Pinterp(Wi IWi_ni-1+2) (3)
,-n+1
</equation>
<bodyText confidence="0.915731875">
That is, the maximum likelihood estimate is inter-
polated with the smoothed lower-order distribution,
which is defined analogously. Training a distinct
for each vi!---n+1 1 is not generally felicitous;
z
Bahl, Jelinek, and Mercer (1983) suggest partition-
ing the A-i into buckets according to c(wii=n1+1),
i—n+1
where all in the same bucket are constrained
-i-,,+1
to have the same value.
To yield meaningful results, the data used to esti-
mate the Ai-i need to be disjoint from the data
i—n+1
used to calculate PDAL.2 In held-out interpolation,
one reserves a section of the training data for this
purpose. Alternatively, Jelinek and Mercer describe
a technique called deleted interpolation where differ-
ent parts of the training data rotate in training either
PML or the A ; the results are then averaged.
Wi—n+1
Several smoothing techniques are motivated
within a Bayesian framework, including work by
Nadas (1984) and MacKay and Peto (1995).
</bodyText>
<sectionHeader confidence="0.950876" genericHeader="method">
3 Novel Smoothing Techniques
</sectionHeader>
<bodyText confidence="0.93287625">
Of the great many novel methods that we have tried,
two techniques have performed especially well.
2 When the same data is used to estimate both, setting
all ,-1 to one yields the optimal result.
</bodyText>
<subsectionHeader confidence="0.998404">
3.1 Method average-count
</subsectionHeader>
<bodyText confidence="0.978097166666667">
This scheme is an instance of Jelinek-Mercer
smoothing. Referring to equation (3), recall that
Bahl et al. suggest bucketing the A.,-i according
.-n+1
to c(w!=n1+1). We have found that partitioning the
A.,-i according to the average number of counts
</bodyText>
<equation confidence="0.9931305">
0— v.+ 1
C( 21):—
</equation>
<bodyText confidence="0.98959215">
per non-zero element 1...,(.:::+1 ) +,)&gt;O1 yields better
results.
Intuitively, the less sparse the data for estimat-
ing PmL(wi I Witn1+1)) the larger A.,-i should be.
,-n+1
While larger c(tv:tn1+1) generally correspond to less
sparse distributions, this quantity ignores the allo-
cation of counts between words. For example, we
would consider a distribution with ten counts dis-
tributed evenly among ten words to be much more
sparse than a distribution with ten counts all on a
single word. The average number of counts per word
seems to more directly express the concept of sparse-
ness.
In Figure 1, we graph the value of A assigned to
each bucket under the original and new bucketing
schemes on identical data. Notice that the new buck-
eting scheme results in a much tighter plot, indicat-
ing that it is better at grouping together distribu-
tions with similar behavior.
</bodyText>
<subsectionHeader confidence="0.999627">
3.2 Method one-count
</subsectionHeader>
<bodyText confidence="0.998995333333333">
This technique combines two intuitions. First,
MacKay and Peto (1995) argue that a reasonable
form for a smoothed distribution is
</bodyText>
<equation confidence="0.983301">
aPone(wilW!--n1 +2)
Pone(Wi I +1) =
C(Wii-n+1)
C(W---71:t+1) Ce
</equation>
<bodyText confidence="0.999372">
The parameter a can be thought of as the num-
ber of counts being added to the given distribution,
</bodyText>
<page confidence="0.993598">
312
</page>
<bodyText confidence="0.999996666666667">
where the new counts are distributed as in the lower-
order distribution. Secondly, the Good-Turing esti-
mate can be interpreted as stating that the number
of these extra counts should be proportional to the
number of words with exactly one count in the given
distribution. We have found that taking
</bodyText>
<equation confidence="0.993534333333333">
a = 7 (4)
works well, where
1/1(wii=n1+1) = ck-n+0 =
</equation>
<bodyText confidence="0.977854">
is the number of words with one count, and where )3
and -y are constants.
</bodyText>
<sectionHeader confidence="0.99928" genericHeader="method">
4 Experimental Methodology
</sectionHeader>
<subsectionHeader confidence="0.988973">
4.1 Data
</subsectionHeader>
<bodyText confidence="0.99999370967742">
We used the Penn treebank and TIPSTER cor-
pora distributed by the Linguistic Data Consor-
tium. From the treebank, we extracted text from
the tagged Brown corpus, yielding about one mil-
lion words. From TIPSTER, we used the Associ-
ated Press (AP), Wall Street Journal (WSJ), and
San Jose Mercury News (SJM) data, yielding 123,
84, and 43 million words respectively. We created
two distinct vocabularies, one for the Brown corpus
and one for the TIPSTER data. The former vocab-
ulary contains all 53,850 words occurring in Brown;
the latter vocabulary consists of the 65,173 words
occurring at least 70 times in TIPSTER.
For each experiment, we selected three segments
of held-out data along with the segment of train-
ing data. One held-out segment was used as the
test data for performance evaluation, and the other
two were used as development test data for opti-
mizing the parameters of each smoothing method.
Each piece of held-out data was chosen to be roughly
50,000 words. This decision does not reflect practice
very well, as when the training data size is less than
50,000 words it is not realistic to have so much devel-
opment test data available. However, we made this
decision to prevent us having to optimize the train-
ing versus held-out data tradeoff for each data size.
In addition, the development test data is used to op-
timize typically very few parameters, so in practice
small held-out sets are generally adequate, and per-
haps can be avoided altogether with techniques such
as deleted estimation.
</bodyText>
<subsectionHeader confidence="0.978006">
4.2 Smoothing Implementations
</subsectionHeader>
<bodyText confidence="0.999775266666667">
In this section, we discuss the details of our imple-
mentations of various smoothing techniques. Due
to space limitations, these descriptions are not com-
prehensive; a more complete discussion .is presented
in Chen (1996). The titles of the following sections
include the mnemonic we use to refer to the imple-
mentations in later sections. Unless otherwise speci-
fied, for those smoothing models defined recursively
in terms of lower-order models, we end the recursion
by taking the n = 0 distribution to be the uniform
distribution Pu(w) = VIVI. For each method, we
highlight the parameters (e.g., An and 6 below) that
can be tuned to optimize performance. Parameter
values are determined through training on held-out
data.
</bodyText>
<subsubsectionHeader confidence="0.611461">
4.2.1 Baseline Smoothing (interp-baseline)
</subsubsectionHeader>
<bodyText confidence="0.948959333333333">
For our baseline smoothing method, we use an
instance of Jelinek-Mercer smoothing where we con-
strain all Ami-i to be equal to a single value An for
</bodyText>
<equation confidence="0.8525568">
each n, i.e.,
Pbase (Wi iwitni +1) = An PmL(wi +1) +
(1 — An) Pbase(wilw!=n1+2)
4.2.2 Additive Smoothing (plus-one and
plus-delta)
</equation>
<bodyText confidence="0.998643666666667">
We consider two versions of additive smoothing.
Referring to equation (2), we fix 6 = 1 in plus-one
smoothing. In plus-delta, we consider any b.
</bodyText>
<subsubsectionHeader confidence="0.923734">
4.2.3 Katz Smoothing (katz)
</subsubsectionHeader>
<bodyText confidence="0.99993175">
While the original paper (Katz, 1987) uses a single
parameter k, we instead use a different k for each
n &gt; 1, kn. We smooth the unigram distribution
using additive smoothing with parameter b.
</bodyText>
<subsubsectionHeader confidence="0.916915">
4.2.4 Church-Gale Smoothing
</subsubsectionHeader>
<bodyText confidence="0.997844653846154">
(church-gale)
To smooth the counts 72, needed for the Good-
Turing estimate, we use the technique described by
Gale and Sampson (1995). We smooth the unigram
distribution using Good-Turing without any bucket-
ing.
Instead of the bucketing scheme described in the
original paper, we use a scheme analogous to the
one described by Bahl, Jelinek, and Mercer (1983).
We make the assumption that whether a bucket is
large enough for accurate Good-Turing estimation
depends on how many n-grams with non-zero counts
occur in it. Thus, instead of partitioning the space
of P(wi_i)P(wi) values in some uniform way as was
done by Church and Gale, we partition the space
so that at least crnin non-zero n-grams fall in each
bucket.
Finally, the original paper describes only bigram
smoothing in detail; extending this method to tri-
gram smoothing is ambiguous. In particular, it is
unclear whether to bucket trigrams according to
P(wr_21)P(wi) or P(w:=21)P(wilwi_1). We chose the
former; while the latter may yield better perfor-
mance, our belief is that it is much more difficult
to implement and that it requires a great deal more
computation.
</bodyText>
<subsubsectionHeader confidence="0.895414">
4.2.5 Jelinek-Mercer Smoothing
</subsubsectionHeader>
<bodyText confidence="0.966112666666667">
(interp-held-out and interp-del-int)
We implemented two versions of Jelinek-Mercer
smoothing differing only in what data is used to
</bodyText>
<page confidence="0.989798">
313
</page>
<bodyText confidence="0.330726">
train the A&apos;s. We bucket the .\,._i according to
</bodyText>
<equation confidence="0.668747">
I-n+1
c(2-1
</equation>
<bodyText confidence="0.999760916666667">
w+i) as suggested by Bahl et al. Similar to our
Church-Gale implementation, we choose buckets to
ensure that at least c„,,,,„ words in the data used to
train the A&apos;s fall in each bucket.
In int erp-held-out , the A&apos;s are trained using
held-out interpolation on one of the development
test sets. In interp-del-int, the A&apos;s are trained
using the relaxed deleted interpolation technique de-
scribed by Jelinek and Mercer, where one word is
deleted at a time. In interp-del-int, we bucket
an n-gram according to its count before deletion, as
this turned out to significantly improve performance.
</bodyText>
<subsubsectionHeader confidence="0.510744">
4.2.6 Novel Smoothing Methods
</subsubsectionHeader>
<bodyText confidence="0.979917285714286">
(new-avg-count and new-one-count)
The implementation new-avg-count, correspond-
ing to smoothing method average-count, is identical
to interp-held-out except that we use the novel
bucketing scheme described in section 3.1. In the
implementation new-one-count, we have different
parameters 3,, and 7„ in equation (4) for each n.
</bodyText>
<sectionHeader confidence="0.999888" genericHeader="evaluation">
5 Results
</sectionHeader>
<bodyText confidence="0.999975970588235">
In Figure 2, we display the performance of the
interp-baseline method for bigram and trigram
models on TIPSTER, Brown, and the WSJ subset
of TIPSTER. In Figures 3-6, we display the relative
performance of various smoothing techniques with
respect to the baseline method on these corpora, as
measured by difference in entropy. In the graphs
on the left of Figures 2-4, each point represents an
average over ten runs; the error bars represent the
empirical standard deviation over these runs. Due
to resource limitations, we only performed multiple
runs for data sets of 50,000 sentences or less. Each
point on the graphs on the right represents a sin-
gle run, but we consider sizes up to the amount of
data available. The graphs on the bottom of Fig-
ures 3-4 are close-ups of the graphs above, focusing
on those algorithms that perform better than the
baseline. To give an idea of how these cross-entropy
differences translate to perplexity, each 0.014 bits
correspond roughly to a 1% change in perplexity.
In each run except as noted below, optimal val-
ues for the parameters of the given technique were
searched for using Powell&apos;s search algorithm as real-
ized in Numerical Recipes in C (Press et al., 1988,
pp. 309-317). Parameters were chosen to optimize
the cross-entropy of one of the development test sets
associated with the given training set. To constrain
the search, we searched only those parameters that
were found to affect performance significantly, as
verified through preliminary experiments over sev-
eral data sizes. For katz and church-gale, we did
not perform the parameter search for training sets
over 50,000 sentences due to resource constraints,
and instead manually extrapolated parameter val-
</bodyText>
<table confidence="0.9638844">
Method Lines
interp-baseline3 400
plus-one 40
plus-delta 40
katz 300
church-gale 1000
int erp-held-out 400
interp-del-int 400
new-avg-count 400
new-one-count 50
</table>
<tableCaption confidence="0.9315785">
Table 1: Implementation difficulty of various meth-
ods in terms of lines of C++ code
</tableCaption>
<bodyText confidence="0.99904621875">
ues from optimal values found on smaller data sizes.
We ran interp-del-int only on sizes up to 50,000
sentences due to time constraints.
From these graphs, we see that additive smooth-
ing performs poorly and that methods katz and
interp-held-out consistently perform well. Our
implementation church-gale performs poorly ex-
cept on large bigram training sets, where it performs
the best. The novel methods new-avg-count and
new-one-count perform well uniformly across train-
ing data sizes, and are superior for trigram models.
Notice that while performance is relatively consis-
tent across corpora, it varies widely with respect to
training set size and n-gram order.
The method interp-del-int performs signifi-
cantly worse than interp-held-out, though they
differ only in the data used to train the A&apos;s. However,
we delete one word at a time in int erp-del-int; we
hypothesize that deleting larger chunks would lead
to more similar performance.
In Figure 7, we show how the values of the pa-
rameters 6 and emir, affect the performance of meth-
ods katz and new-avg-count, respectively, over sev-
eral training data sizes. Notice that poor parameter
setting can lead to very significant losses in perfor-
mance, and that optimal parameter settings depend
on training set size.
To give an informal estimate of the difficulty of
implementation of each method, in Table 1 we dis-
play the number of lines of C++ code in each imple-
mentation excluding the core code common across
techniques.
</bodyText>
<sectionHeader confidence="0.999382" genericHeader="conclusions">
6 Discussion
</sectionHeader>
<bodyText confidence="0.8178125">
To our knowledge, this is the first empirical compari-
son of smoothing techniques in language modeling of
such scope: no other study has used multiple train-
ing data sizes, corpora, or has performed parameter
optimization. We show that in order to completely
3To implement the baseline method, we just used the
interp-held-out code as it is a special case. Written
anew, it probably would have been about 50 lines.
</bodyText>
<page confidence="0.998295">
314
</page>
<figureCaption confidence="0.9894125">
Figure 2: Baseline cross-entropy on test data; graph on left displays averages over ten runs for training sets
up to 50,000 sentences, graph on right displays single runs for training sets up to 10,000,000 sentences
</figureCaption>
<figure confidence="0.992988369863014">
1000
100
10000 100000 1444-06 10,07
sentences of training data (-25 words/sentence)
average over ten runs at each size, up to 50,000 sentences
1000 10000
sentences of training data (-25 words/sentence)
single run at each size
TIPSTER bigram
7.5 .. .. -
WSJ bigram
7TIPSTER tdgran
WSJ tdgrair).--_
6.5
11.5
cross-entropy of test data (bits/token)
10.5
10
9_5
9
8.5
8
7.5
100
10.5
Brown bigram
Brawn Ingram
0
9
8.5
from baseline)
difference in test cross-entropy from baseline (bits/token)
difference in test cross-entropy from baseline
average over ten runs at each size, up to 50,000 sentence
church-gale
0
100 1000 10000
sentences et training data (-25 words/sentence)
-0.16
100 1000 10000
sentences of training data (-25 words/sentence)
single rural each size, up 10 10,000,000 sentences
-0.02
-0.04
-0.06
-0.06
-0.1
-0,12
-0.14
1000 10000 100000 1e406
sentences of training data (-25 words/Sentence)
plus-ort e
0.02
0
-0.02
-0.04
-0.06
-0.08
-0.12
-0.14
average over ten tins at each size, up to 50,000 sentences
•f . katz &apos;&apos;&apos; &apos;&apos;&apos;&apos;&apos;
r.......... •••?&apos;
---- --
--------- -------
new:acount
---------- n?--°_?7wl- ------ -
§ ---------- --- - !--
atz, en-held-out, Interp-del-int. new-avg-count, new-or7e&apos;-count (sen-nrrlow)
1
100 1000 10000 100000 10+06 ler.07
sentences ot training data (-25 words/sentence)
single run at each size, up to 10,000,000 sentences
</figure>
<figureCaption confidence="0.8714075">
Figure 3: Trigram model on TIPSTER data; relative performance of various methods with respect to baseline;
graphs on left display averages over ten runs for training sets up to 501000 sentences, graphs on right display
</figureCaption>
<footnote confidence="0.4856055">
single runs for training sets up to 10,000,000 sentences; top graphs show all algorithms, bottom graphs zoom
in on those methods that perform better than the baseline method
</footnote>
<page confidence="0.992885">
315
</page>
<figure confidence="0.994638757142857">
single run at each size, up 10 10,000,000 sentences
100
1000 10000
sentences of training data (-25 words/sentence)
average over ten runs at each size, up to 50,000 sentences
5
4.5
4
3.5
3
2.5
2
1.5
1
05
0
-0.5
100 1000 10000
sentences of training data (-25 words/sentence)
average over on runs at each size up to 50,000 santnncas
tome in test mosoentropy from baseline
0.02
0 -
-0.02
-0.04 -
-0.06 -
-0.08 -
.0.1
; ........... t.tz- .....
new-avg-count
interp-held-out. z ...............
... ....... ... ......
new-one-count
difference in test
-0.14 -
church-gale
church-gale
Katt, intem-held-out, interp-del-int, now.avg-count. naw-ons-count sea bele
difference in test cross-entropy from baseline (bits/token)
-0.02
-0.04
-0.06
-0.08
-0.1
-0.12
4.5
4
3
2.5
2
1.5
0.5
0
-0.5
100 1000 10000 100000 10.06
sentences of twining data (-25 words/sentence)
single run at each size, up to 10,000,000 sentences
0.02
new-one-count
naw.avg-count
tropy from baseline (bits/token)
15.07
0.14
100 1000 10000 100000 10,06
sentences of training data (-25 words/sentence)
1.07
us-one
°
to, interp-held-out, intarp-del-int, new-avg-count. new-one-count (sea below)
plus-delta
</figure>
<figureCaption confidence="0.97538525">
Figure 4: Bigram model on TIPSTER data; relative performance of various methods with respect to baseline;
graphs on left display averages over ten runs for training sets up to 50,000 sentences, graphs on right display
single runs for training sets up to 101000,000 sentences; top graphs show all algorithms, bottom graphs zoom
in on those methods that perform better than the baseline method
</figureCaption>
<figure confidence="0.995462342857143">
Ingram model
0,02
0
-0.02
-0.04
-0.06
-0.08
.0.12
-0.14
0.16
100 1000 10000
sentences of training data (-21 words/sentence)
difference in test cross-entropy from baseline (bitsnokan)
bigrarn model
0.02
0
interp-del-int
.. ,interp-held-out
difference in test crosoentropy from baseline (biLgtoken)
-0,02
-0.04
-0.06
-0.08
-0.1
-0.12
-0.14
-0.16
-0.18
100
1000 10000
sentences of twining data (-21 words/sentence)
...... ........
. ° ---------
---------------
new-atigZrint
</figure>
<figureCaption confidence="0.989945">
Figure 5: Bigram and trigram models on Brown corpus; relative performance of various methods with respect
to baseline
</figureCaption>
<page confidence="0.950701">
316
</page>
<figure confidence="0.997935269230769">
WI creme rn test cross entropy bore besets,. (bee/tel.,)
bigram model
trigram model
004
0.02
-0.04 -
100 1000 10000 100000 16.06
sentences of training data (-25 words/sentence)
0.02
0
C hurch-gale
new-avg-count
church-gale
1000 10000 100000
sentences of training data (-25 words/sentence)
difference in test cross-entro
-0.02
-0.04
-0.06
-0.08
-0.1
-0.12
-0.14
-0.16
-0.18
100
</figure>
<figureCaption confidence="0.9068035">
Figure 6: Bigram and trigram models on Wall Street Journal corpus; relative performance of various methods
with respect to baseline
</figureCaption>
<figure confidence="0.997940074074074">
performance of new-avg-count with respect to c-min
10 100 1000 10030 100000
minimum number of counts per bucket
delta
difference in test cross-entropy from baseline (bits/token)
0.05
-0.06
-0.07
-0.08
-0.0g
-0.1
-0.11
-0.12
-0.13
0.14
100
0.01
1000
performance of kat7 with respect to delta
1.6
1.4
I 1.2
0.4
0.2
13 0
-0.2
0,001
</figure>
<figureCaption confidence="0.999996">
Figure 7: Performance of katz and new-avg-count with respect to parameters 6 and en-in, respectively
</figureCaption>
<bodyText confidence="0.999769175">
characterize the relative performance of two tech-
niques, it is necessary to consider multiple training
set sizes and to try both bigram and trigram mod-
els. Multiple runs should be performed whenever
possible to discover whether any calculated differ-
ences are statistically significant. Furthermore, we
show that sub-optimal parameter selection can also
significantly affect relative performance.
We find that the two most widely used techniques,
Katz smoothing and Jelinek-Mercer smoothing, per-
form consistently well across training set sizes for
both bigram and trigram models, with Katz smooth-
ing performing better on trigram models produced
from large training sets and on bigram models in
general. These results question the generality of the
previous reference result concerning Katz smooth-
ing: Katz (1987) reported that his method slightly
outperforms an unspecified version ofJelinek-Mercer
smoothing on a single training set of 750,000 words.
Furthermore, we show that Church-Gale smooth-
ing, which previously had not been compared with
common smoothing techniques, outperforms all ex-
isting methods on bigram models produced from
large training sets. Finally, we find that our novel
methods average-count and one-count are superior
to existing methods for trigram models and perform
well on bigram models; method one-count yields
marginally worse performance but is extremely easy
to implement.
In this study, we measure performance solely
through the cross-entropy of test data; it would
be interesting to see how these cross-entropy differ-
ences correlate with performance in end applications
such as speech recognition. In addition, it would be
interesting to see whether these results extend to
fields other than language modeling where smooth-
ing is used, such as prepositional phrase attachment
(Collins and Brooks, 1995), part-of-speech tagging
(Church, 1988), and stochastic parsing (Magerman,
1994).
</bodyText>
<page confidence="0.997597">
317
</page>
<sectionHeader confidence="0.998086" genericHeader="acknowledgments">
Acknowledgements
</sectionHeader>
<bodyText confidence="0.9996574">
The authors would like to thank Stuart Shieber and
the anonymous reviewers for their comments on pre-
vious versions of this paper. We would also like to
thank William Gale and Geoffrey Sampson for sup-
plying us with code for &amp;quot;Good-Turing frequency esti-
mation without tears.&amp;quot; This research was supported
by the National Science Foundation under Grant No.
IRI-93-50192 and Grant No. CDA-94-01024. The
second author was also supported by a National Sci-
ence Foundation Graduate Student Fellowship.
</bodyText>
<sectionHeader confidence="0.999188" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999484068181818">
Bahl, Lalit R., Frederick Jelinek, and Robert L.
Mercer. 1983. A maximum likelihood approach
to continuous speech recognition. IEEE Trans-
actions on Pattern Analysis and Machine Intelli-
gence, PAMI-5(2):179-190, March.
Brown, Peter F., John Cocke, Stephen A. DellaPi-
etra, Vincent J. DellaPietra, Frederick Jelinek,
John D. Lafferty, Robert L. Mercer, and Paul S.
Roossin. 1990. A statistical approach to machine
translation. Computational Linguistics, 16(2)79-
85, June.
Brown, Peter F., Stephen A. DellaPietra, Vincent J.
DellaPietra, Jennifer C. Lai, and Robert L. Mer-
cer. 1992. An estimate of an upper bound for
the entropy of English. Computational Linguis-
tics, 18(1):31-40, March.
Chen, Stanley F. 1996. Building Probabilistic Mod-
els for Natural Language. Ph.D. thesis, Harvard
University. In preparation.
Church, Kenneth. 1988. A stochastic parts program
and noun phrase parser for unrestricted text. In
Proceedings of the Second Conference on Applied
Natural Language Processing, pages 136-143.
Church, Kenneth W. and William A. Gale. 1991.
A comparison of the enhanced Good-Turing and
deleted estimation methods for estimating proba-
bilities of English bigrams. Computer Speech and
Language, 5:19-54.
Collins, Michael and James Brooks. 1995. Prepo-
sitional phrase attachment through a backed-off
model. In David Yarowsky and Kenneth Church,
editors, Proceedings of the Third Workshop on
Very Large Corpora, pages 27-38, Cambridge,
MA, June.
Gale, William A. and Kenneth W. Church. 1990.
Estimation procedures for language context: poor
estimates are worse than none. In COMP-
STAT, Proceedings in Computational Statistics,
9th Symposium, pages 69-74, Dubrovnik, Yu-
goslavia, September.
Gale, William A. and Kenneth W. Church. 1994.
What&apos;s wrong with adding one? In N. Oostdijk
and P. de Haan, editors, Corpus-Based Research
into Language. Rodolpi, Amsterdam.
Gale, William A. and Geoffrey Sampson. 1995.
Good-Turing frequency estimation without tears.
Journal of Quantitative Linguistics, 2(3). To ap-
pear.
Good, I.J. 1953. The population frequencies of
species and the estimation of population parame-
ters. Biometrika, 40(3 and 4):237-264.
Jeffreys, H. 1948. Theory of Probability. Clarendon
Press, Oxford, second edition.
Jelinek, Frederick and Robert L. Mercer. 1980. In-
terpolated estimation of Markov source parame-
ters from sparse data. In Proceedings of the Work-
shop on Pattern Recognition in Practice, Amster-
dam, The Netherlands: North-Holland, May.
Johnson, W.E. 1932. Probability: deductive and
inductive problems. Mind, 41:421-423.
Katz, Slava M. 1987. Estimation of probabilities
from sparse data for the language model com-
ponent of a speech recognizer. IEEE Transac-
tions on Acoustics, Speech and Signal Processing,
ASSP-35(3):400-401, March.
Kernighan, M.D., K.W. Church, and W.A. Gale.
1990. A spelling correction program based on
a noisy channel model. In Proceedings of the
Thirteenth International Conference on Compu-
tational Linguistics, pages 205-210.
Lidstone, G.J. 1920. Note on the general case of the
Bayes-Laplace formula for inductive or a posteri-
ori probabilities. Transactions of the Faculty of
Actuaries, 8:182-192.
MacKay, David J. C. and Linda C. Peto. 1995. A hi-
erarchical Dirichlet language model. Natural Lan-
guage Engineering, 1(3):1-19.
Magerman, David M. 1994. Natural Language Pars-
ing as Statistical Pattern Recognition. Ph.D. the-
sis, Stanford University, February.
Nadas, Arthur. 1984. Estimation of probabilities in
the language model of the IBM speech recognition
system. IEEE Transactions on Acoustics, Speech
and Signal Processing, ASSP-32(4):859-861, Au-
gust.
Press, W.H., B.P. Flannery, S.A. Teukolsky, and
W.T. Vetterling. 1988. Numerical Recipes in C.
Cambridge University Press, Cambridge.
</reference>
<page confidence="0.997874">
318
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.511364">
<title confidence="0.999497">An Empirical Study of Smoothing Techniques for Language Modeling</title>
<author confidence="0.999681">Stanley F Chen</author>
<affiliation confidence="0.999067">Harvard University Aiken Computation Laboratory</affiliation>
<address confidence="0.8627965">33 Oxford St. Cambridge, MA 02138</address>
<email confidence="0.999822">sfc@eecs.harvard.edu</email>
<author confidence="0.999933">Joshua Goodman</author>
<affiliation confidence="0.9990665">Harvard University Aiken Computation Laboratory</affiliation>
<address confidence="0.862798">33 Oxford St. Cambridge, MA 02138</address>
<email confidence="0.999889">goodman@eecs.harvard.edu</email>
<abstract confidence="0.998691944444444">We present an extensive empirical comparison of several smoothing techniques in the domain of language modeling, including those described by Jelinek and Mercer (1980), Katz (1987), and Church and Gale (1991). We investigate for the first time how factors such as training data corpus versus Wall Street Journal), and n-gram order (bigram versus trigram) affect the relative performance of these methods, which we measure through the cross-entropy of test data. In addition, we introduce two novel smoothing techniques, one a variation of Jelinek-Mercer smoothing and one a very simple linear interpolation technique, both of which outperform existing methods.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Lalit R Bahl</author>
<author>Frederick Jelinek</author>
<author>Robert L Mercer</author>
</authors>
<title>A maximum likelihood approach to continuous speech recognition.</title>
<date>1983</date>
<journal>IEEE Transactions on Pattern Analysis and Machine Intelligence,</journal>
<pages>5--2</pages>
<contexts>
<context position="1155" citStr="Bahl, Jelinek, and Mercer, 1983" startWordPosition="166" endWordPosition="170"> We investigate for the first time how factors such as training data size, corpus (e.g., Brown versus Wall Street Journal), and n-gram order (bigram versus trigram) affect the relative performance of these methods, which we measure through the cross-entropy of test data. In addition, we introduce two novel smoothing techniques, one a variation of Jelinek-Mercer smoothing and one a very simple linear interpolation technique, both of which outperform existing methods. 1 Introduction Smoothing is a technique essential in the construction of n-gram language models, a staple in speech recognition (Bahl, Jelinek, and Mercer, 1983) as well as many other domains (Church, 1988; Brown et al., 1990; Kernighan, Church, and Gale, 1990). A language model is a probability distribution over strings P(s) that attempts to reflect the frequency with which each string s occurs as a sentence in natural text. Language models are used in speech recognition to resolve acoustically ambiguous utterances. For example, if we have that PO takes two) &gt;&gt; P(it takes too), then we know ceieris paribus to prefer the former transcription over the latter. While smoothing is a central issue in language modeling, the literature lacks a definitive co</context>
</contexts>
<marker>Bahl, Jelinek, Mercer, 1983</marker>
<rawString>Bahl, Lalit R., Frederick Jelinek, and Robert L. Mercer. 1983. A maximum likelihood approach to continuous speech recognition. IEEE Transactions on Pattern Analysis and Machine Intelligence, PAMI-5(2):179-190, March.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Peter F Brown</author>
<author>John Cocke</author>
<author>Stephen A DellaPietra</author>
<author>Vincent J DellaPietra</author>
<author>Frederick Jelinek</author>
<author>John D Lafferty</author>
<author>Robert L Mercer</author>
<author>Paul S Roossin</author>
</authors>
<title>A statistical approach to machine translation.</title>
<date>1990</date>
<journal>Computational Linguistics,</journal>
<pages>16--2</pages>
<contexts>
<context position="1220" citStr="Brown et al., 1990" startWordPosition="179" endWordPosition="182">pus (e.g., Brown versus Wall Street Journal), and n-gram order (bigram versus trigram) affect the relative performance of these methods, which we measure through the cross-entropy of test data. In addition, we introduce two novel smoothing techniques, one a variation of Jelinek-Mercer smoothing and one a very simple linear interpolation technique, both of which outperform existing methods. 1 Introduction Smoothing is a technique essential in the construction of n-gram language models, a staple in speech recognition (Bahl, Jelinek, and Mercer, 1983) as well as many other domains (Church, 1988; Brown et al., 1990; Kernighan, Church, and Gale, 1990). A language model is a probability distribution over strings P(s) that attempts to reflect the frequency with which each string s occurs as a sentence in natural text. Language models are used in speech recognition to resolve acoustically ambiguous utterances. For example, if we have that PO takes two) &gt;&gt; P(it takes too), then we know ceieris paribus to prefer the former transcription over the latter. While smoothing is a central issue in language modeling, the literature lacks a definitive comparison between the many existing techniques. Previous studies (</context>
</contexts>
<marker>Brown, Cocke, DellaPietra, DellaPietra, Jelinek, Lafferty, Mercer, Roossin, 1990</marker>
<rawString>Brown, Peter F., John Cocke, Stephen A. DellaPietra, Vincent J. DellaPietra, Frederick Jelinek, John D. Lafferty, Robert L. Mercer, and Paul S. Roossin. 1990. A statistical approach to machine translation. Computational Linguistics, 16(2)79-85, June.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Peter F Brown</author>
<author>Stephen A DellaPietra</author>
<author>Vincent J DellaPietra</author>
<author>Jennifer C Lai</author>
<author>Robert L Mercer</author>
</authors>
<title>An estimate of an upper bound for the entropy of English.</title>
<date>1992</date>
<journal>Computational Linguistics,</journal>
<pages>18--1</pages>
<contexts>
<context position="8961" citStr="Brown et al. (1992)" startWordPosition="1481" endWordPosition="1484">g new bucketing 0.8 0.8 OA 0.6 2 0.4 0.4 0.2 0.2 100000 10000 100 (1.001 0.01 0.1 10 average norvaino count in distribution minus one 10 100 1000 number of counts in distribution . ° vu :1; • o .44% :• tit..•••4.6.&amp;quot; 0. 8.8 :Of.% .° . • .. **. . tt.. • ..• et.8 • ••• ° 01: Figure 1: A values for old and new bucketing schemes for Jelinek-Mercer smoothing; each point represents a single bucket The other smoothing technique besides Katz smoothing widely used in speech recognition is due to Jelinek and Mercer (1980). They present a class of smoothing models that involve linear interpolation, e.g., Brown et al. (1992) take Pinterp (Wi I W! in&apos; +1) -= Aw.-1 PML(Wi 1U4--n1+1) i—n+1 (1 — Aevi.-1 ) Pinterp(Wi IWi_ni-1+2) (3) ,-n+1 That is, the maximum likelihood estimate is interpolated with the smoothed lower-order distribution, which is defined analogously. Training a distinct for each vi!---n+1 1 is not generally felicitous; z Bahl, Jelinek, and Mercer (1983) suggest partitioning the A-i into buckets according to c(wii=n1+1), i—n+1 where all in the same bucket are constrained -i-,,+1 to have the same value. To yield meaningful results, the data used to estimate the Ai-i need to be disjoint from the data i—n</context>
</contexts>
<marker>Brown, DellaPietra, DellaPietra, Lai, Mercer, 1992</marker>
<rawString>Brown, Peter F., Stephen A. DellaPietra, Vincent J. DellaPietra, Jennifer C. Lai, and Robert L. Mercer. 1992. An estimate of an upper bound for the entropy of English. Computational Linguistics, 18(1):31-40, March.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Stanley F Chen</author>
</authors>
<title>Building Probabilistic Models for Natural Language.</title>
<date>1996</date>
<tech>Ph.D. thesis,</tech>
<institution>Harvard University. In preparation.</institution>
<contexts>
<context position="13928" citStr="Chen (1996)" startWordPosition="2309" endWordPosition="2310">le. However, we made this decision to prevent us having to optimize the training versus held-out data tradeoff for each data size. In addition, the development test data is used to optimize typically very few parameters, so in practice small held-out sets are generally adequate, and perhaps can be avoided altogether with techniques such as deleted estimation. 4.2 Smoothing Implementations In this section, we discuss the details of our implementations of various smoothing techniques. Due to space limitations, these descriptions are not comprehensive; a more complete discussion .is presented in Chen (1996). The titles of the following sections include the mnemonic we use to refer to the implementations in later sections. Unless otherwise specified, for those smoothing models defined recursively in terms of lower-order models, we end the recursion by taking the n = 0 distribution to be the uniform distribution Pu(w) = VIVI. For each method, we highlight the parameters (e.g., An and 6 below) that can be tuned to optimize performance. Parameter values are determined through training on held-out data. 4.2.1 Baseline Smoothing (interp-baseline) For our baseline smoothing method, we use an instance o</context>
</contexts>
<marker>Chen, 1996</marker>
<rawString>Chen, Stanley F. 1996. Building Probabilistic Models for Natural Language. Ph.D. thesis, Harvard University. In preparation.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kenneth Church</author>
</authors>
<title>A stochastic parts program and noun phrase parser for unrestricted text.</title>
<date>1988</date>
<booktitle>In Proceedings of the Second Conference on Applied Natural Language Processing,</booktitle>
<pages>136--143</pages>
<contexts>
<context position="1200" citStr="Church, 1988" startWordPosition="177" endWordPosition="178">data size, corpus (e.g., Brown versus Wall Street Journal), and n-gram order (bigram versus trigram) affect the relative performance of these methods, which we measure through the cross-entropy of test data. In addition, we introduce two novel smoothing techniques, one a variation of Jelinek-Mercer smoothing and one a very simple linear interpolation technique, both of which outperform existing methods. 1 Introduction Smoothing is a technique essential in the construction of n-gram language models, a staple in speech recognition (Bahl, Jelinek, and Mercer, 1983) as well as many other domains (Church, 1988; Brown et al., 1990; Kernighan, Church, and Gale, 1990). A language model is a probability distribution over strings P(s) that attempts to reflect the frequency with which each string s occurs as a sentence in natural text. Language models are used in speech recognition to resolve acoustically ambiguous utterances. For example, if we have that PO takes two) &gt;&gt; P(it takes too), then we know ceieris paribus to prefer the former transcription over the latter. While smoothing is a central issue in language modeling, the literature lacks a definitive comparison between the many existing techniques</context>
</contexts>
<marker>Church, 1988</marker>
<rawString>Church, Kenneth. 1988. A stochastic parts program and noun phrase parser for unrestricted text. In Proceedings of the Second Conference on Applied Natural Language Processing, pages 136-143.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kenneth W Church</author>
<author>William A Gale</author>
</authors>
<title>A comparison of the enhanced Good-Turing and deleted estimation methods for estimating probabilities of English bigrams.</title>
<date>1991</date>
<journal>Computer Speech and Language,</journal>
<pages>5--19</pages>
<contexts>
<context position="1866" citStr="Church and Gale, 1991" startWordPosition="286" endWordPosition="289">Gale, 1990). A language model is a probability distribution over strings P(s) that attempts to reflect the frequency with which each string s occurs as a sentence in natural text. Language models are used in speech recognition to resolve acoustically ambiguous utterances. For example, if we have that PO takes two) &gt;&gt; P(it takes too), then we know ceieris paribus to prefer the former transcription over the latter. While smoothing is a central issue in language modeling, the literature lacks a definitive comparison between the many existing techniques. Previous studies (Nadas, 1984; Katz, 1987; Church and Gale, 1991; MacKay and Peto, 1995) only compare a small number of methods (typically two) on a single corpus and using a single training data size. As a result, it is currently difficult for a researcher to intelligently choose between smoothing schemes. In this work, we carry out an extensive empirical comparison of the most widely used smoothing techniques, including those described by Jelinek and Mercer (1980), Katz (1987), and Church and Gale (1991). We carry out experiments over many training data sizes on varied corpora using both bigram and trigram models. We demonstrate that the relative perform</context>
<context position="7544" citStr="Church and Gale (1991)" startWordPosition="1240" endWordPosition="1243">ed directly for n-gram smoothing because, like additive smoothing, it does not perform the interpolation of lower- and higher-order models essential for good performance. Good-Turing states that an n-gram that occurs r times should be treated as if it had occurred r* times, where r* = (r + 1) nr+1 and where n,. is the number of n-grams that occur exactly r times in the training data. Katz smoothing (1987) extends the intuitions of Good-Turing by adding the interpolation of higherorder models with lower-order models. It is perhaps the most widely used smoothing technique in speech recognition. Church and Gale (1991) describe a smoothing method that combines the Good-Turing estimate with bucketing, the technique of partitioning a set of n-grams into disjoint groups, where each group is characterized independently through a set of parameters. Like Katz, models are defined recursively in terms of lower-order models. Each n-gram is assigned to one of several buckets based on its frequency predicted from lower-order models. Each bucket is treated as a separate distribution and Good-Turing estimation is performed within each, giving corrected counts that are normalized to yield probabilities. C(Wi_ Wi) + 1 2 P</context>
</contexts>
<marker>Church, Gale, 1991</marker>
<rawString>Church, Kenneth W. and William A. Gale. 1991. A comparison of the enhanced Good-Turing and deleted estimation methods for estimating probabilities of English bigrams. Computer Speech and Language, 5:19-54.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Michael Collins</author>
<author>James Brooks</author>
</authors>
<title>Prepositional phrase attachment through a backed-off model.</title>
<date>1995</date>
<booktitle>Proceedings of the Third Workshop on Very Large Corpora,</booktitle>
<pages>27--38</pages>
<editor>In David Yarowsky and Kenneth Church, editors,</editor>
<location>Cambridge, MA,</location>
<contexts>
<context position="28206" citStr="Collins and Brooks, 1995" startWordPosition="4557" endWordPosition="4560">ount and one-count are superior to existing methods for trigram models and perform well on bigram models; method one-count yields marginally worse performance but is extremely easy to implement. In this study, we measure performance solely through the cross-entropy of test data; it would be interesting to see how these cross-entropy differences correlate with performance in end applications such as speech recognition. In addition, it would be interesting to see whether these results extend to fields other than language modeling where smoothing is used, such as prepositional phrase attachment (Collins and Brooks, 1995), part-of-speech tagging (Church, 1988), and stochastic parsing (Magerman, 1994). 317 Acknowledgements The authors would like to thank Stuart Shieber and the anonymous reviewers for their comments on previous versions of this paper. We would also like to thank William Gale and Geoffrey Sampson for supplying us with code for &amp;quot;Good-Turing frequency estimation without tears.&amp;quot; This research was supported by the National Science Foundation under Grant No. IRI-93-50192 and Grant No. CDA-94-01024. The second author was also supported by a National Science Foundation Graduate Student Fellowship. Refer</context>
</contexts>
<marker>Collins, Brooks, 1995</marker>
<rawString>Collins, Michael and James Brooks. 1995. Prepositional phrase attachment through a backed-off model. In David Yarowsky and Kenneth Church, editors, Proceedings of the Third Workshop on Very Large Corpora, pages 27-38, Cambridge, MA, June.</rawString>
</citation>
<citation valid="true">
<authors>
<author>William A Gale</author>
<author>Kenneth W Church</author>
</authors>
<title>Estimation procedures for language context: poor estimates are worse than none.</title>
<date>1990</date>
<booktitle>In COMPSTAT, Proceedings in Computational Statistics, 9th Symposium,</booktitle>
<pages>69--74</pages>
<location>Dubrovnik, Yugoslavia,</location>
<contexts>
<context position="6767" citStr="Gale and Church (1990" startWordPosition="1114" endWordPosition="1117">either occurred in the training data), even though intuitively the former seems more likely because the word the is much more common than thou. To address this, another smoothing technique is to interpolate the bigram model with a unigram model PmL(wi) = c(w)/N5, a model that reflects how often each word occurs in the training data. For example, we can take Pinterp (wi I wi-1) = APA4L(wi Iwz_i)+ (1— A)PmL(wi) getting the behavior that bigrams involving common words are assigned higher probabilities (Jelinek and Mercer, 1980). c(w1:41) + 6111 (2) and where Lidstone and Jeffreys advocate 6 = 1. Gale and Church (1990; 1994) have argued that this method generally performs poorly. The Good-Turing estimate (Good, 1953) is central to many smoothing techniques. It is not used directly for n-gram smoothing because, like additive smoothing, it does not perform the interpolation of lower- and higher-order models essential for good performance. Good-Turing states that an n-gram that occurs r times should be treated as if it had occurred r* times, where r* = (r + 1) nr+1 and where n,. is the number of n-grams that occur exactly r times in the training data. Katz smoothing (1987) extends the intuitions of Good-Turin</context>
</contexts>
<marker>Gale, Church, 1990</marker>
<rawString>Gale, William A. and Kenneth W. Church. 1990. Estimation procedures for language context: poor estimates are worse than none. In COMPSTAT, Proceedings in Computational Statistics, 9th Symposium, pages 69-74, Dubrovnik, Yugoslavia, September.</rawString>
</citation>
<citation valid="true">
<authors>
<author>William A Gale</author>
<author>Kenneth W Church</author>
</authors>
<title>What&apos;s wrong with adding one?</title>
<date>1994</date>
<booktitle>Corpus-Based Research into Language. Rodolpi,</booktitle>
<editor>In N. Oostdijk and P. de Haan, editors,</editor>
<location>Amsterdam.</location>
<marker>Gale, Church, 1994</marker>
<rawString>Gale, William A. and Kenneth W. Church. 1994. What&apos;s wrong with adding one? In N. Oostdijk and P. de Haan, editors, Corpus-Based Research into Language. Rodolpi, Amsterdam.</rawString>
</citation>
<citation valid="true">
<authors>
<author>William A Gale</author>
<author>Geoffrey Sampson</author>
</authors>
<title>Good-Turing frequency estimation without tears.</title>
<date>1995</date>
<journal>Journal of Quantitative Linguistics,</journal>
<volume>2</volume>
<issue>3</issue>
<note>To appear.</note>
<contexts>
<context position="15277" citStr="Gale and Sampson (1995)" startWordPosition="2530" endWordPosition="2533">) = An PmL(wi +1) + (1 — An) Pbase(wilw!=n1+2) 4.2.2 Additive Smoothing (plus-one and plus-delta) We consider two versions of additive smoothing. Referring to equation (2), we fix 6 = 1 in plus-one smoothing. In plus-delta, we consider any b. 4.2.3 Katz Smoothing (katz) While the original paper (Katz, 1987) uses a single parameter k, we instead use a different k for each n &gt; 1, kn. We smooth the unigram distribution using additive smoothing with parameter b. 4.2.4 Church-Gale Smoothing (church-gale) To smooth the counts 72, needed for the GoodTuring estimate, we use the technique described by Gale and Sampson (1995). We smooth the unigram distribution using Good-Turing without any bucketing. Instead of the bucketing scheme described in the original paper, we use a scheme analogous to the one described by Bahl, Jelinek, and Mercer (1983). We make the assumption that whether a bucket is large enough for accurate Good-Turing estimation depends on how many n-grams with non-zero counts occur in it. Thus, instead of partitioning the space of P(wi_i)P(wi) values in some uniform way as was done by Church and Gale, we partition the space so that at least crnin non-zero n-grams fall in each bucket. Finally, the or</context>
</contexts>
<marker>Gale, Sampson, 1995</marker>
<rawString>Gale, William A. and Geoffrey Sampson. 1995. Good-Turing frequency estimation without tears. Journal of Quantitative Linguistics, 2(3). To appear.</rawString>
</citation>
<citation valid="true">
<authors>
<author>I J Good</author>
</authors>
<title>The population frequencies of species and the estimation of population parameters.</title>
<date>1953</date>
<journal>Biometrika,</journal>
<volume>40</volume>
<issue>3</issue>
<pages>4--237</pages>
<contexts>
<context position="6868" citStr="Good, 1953" startWordPosition="1130" endWordPosition="1131">e is much more common than thou. To address this, another smoothing technique is to interpolate the bigram model with a unigram model PmL(wi) = c(w)/N5, a model that reflects how often each word occurs in the training data. For example, we can take Pinterp (wi I wi-1) = APA4L(wi Iwz_i)+ (1— A)PmL(wi) getting the behavior that bigrams involving common words are assigned higher probabilities (Jelinek and Mercer, 1980). c(w1:41) + 6111 (2) and where Lidstone and Jeffreys advocate 6 = 1. Gale and Church (1990; 1994) have argued that this method generally performs poorly. The Good-Turing estimate (Good, 1953) is central to many smoothing techniques. It is not used directly for n-gram smoothing because, like additive smoothing, it does not perform the interpolation of lower- and higher-order models essential for good performance. Good-Turing states that an n-gram that occurs r times should be treated as if it had occurred r* times, where r* = (r + 1) nr+1 and where n,. is the number of n-grams that occur exactly r times in the training data. Katz smoothing (1987) extends the intuitions of Good-Turing by adding the interpolation of higherorder models with lower-order models. It is perhaps the most w</context>
</contexts>
<marker>Good, 1953</marker>
<rawString>Good, I.J. 1953. The population frequencies of species and the estimation of population parameters. Biometrika, 40(3 and 4):237-264.</rawString>
</citation>
<citation valid="true">
<authors>
<author>H Jeffreys</author>
</authors>
<title>Theory of Probability.</title>
<date>1948</date>
<publisher>Clarendon Press,</publisher>
<location>Oxford,</location>
<note>second edition.</note>
<contexts>
<context position="5644" citStr="Jeffreys, 1948" startWordPosition="925" endWordPosition="926">bigram, say burnish the, doesn&apos;t occur in the training data. Then, we have PmL(thelburnish) = 0, which is clearly inaccurate as this probability should be larger than zero. A zero bigram probability can lead to errors in speech recognition, as it disallows the bigram regardless of how informative the acoustic signal is. The term smoothing describes techniques for adjusting the maximum likelihood estimate to hopefully produce more accurate probabilities. As an example, one simple smoothing technique is to pretend each bigram occurs once more than it actually did (Lidstone, 1920; Johnson, 1932; Jeffreys, 1948), yielding P�i(wiw_i) = c(wi_i) + IVI where V is the vocabulary, the set of all words being considered. This has the desirable quality of &apos;To make the term P(wilw:=41) meaningful for i &lt; n, one can pad the beginning of the string with a distinguished token. In this work, we assume there are n —1 such distinguished tokens preceding each sentence. preventing zero bigram probabilities. However, this scheme has the flaw of assigning the same probability to say, burnish the and burnish thou (assuming neither occurred in the training data), even though intuitively the former seems more likely becaus</context>
<context position="8274" citStr="Jeffreys, 1948" startWordPosition="1354" endWordPosition="1355"> set of n-grams into disjoint groups, where each group is characterized independently through a set of parameters. Like Katz, models are defined recursively in terms of lower-order models. Each n-gram is assigned to one of several buckets based on its frequency predicted from lower-order models. Each bucket is treated as a separate distribution and Good-Turing estimation is performed within each, giving corrected counts that are normalized to yield probabilities. C(Wi_ Wi) + 1 2 Previous Work The simplest type of smoothing used in practice is additive smoothing (Lidstone, 1920; Johnson, 1932; Jeffreys, 1948), where we take c(wLn+i) + 6 Padd (Wi I witni +1) = 311 old bucketing new bucketing 0.8 0.8 OA 0.6 2 0.4 0.4 0.2 0.2 100000 10000 100 (1.001 0.01 0.1 10 average norvaino count in distribution minus one 10 100 1000 number of counts in distribution . ° vu :1; • o .44% :• tit..•••4.6.&amp;quot; 0. 8.8 :Of.% .° . • .. **. . tt.. • ..• et.8 • ••• ° 01: Figure 1: A values for old and new bucketing schemes for Jelinek-Mercer smoothing; each point represents a single bucket The other smoothing technique besides Katz smoothing widely used in speech recognition is due to Jelinek and Mercer (1980). They present a</context>
</contexts>
<marker>Jeffreys, 1948</marker>
<rawString>Jeffreys, H. 1948. Theory of Probability. Clarendon Press, Oxford, second edition.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Frederick Jelinek</author>
<author>Robert L Mercer</author>
</authors>
<title>Interpolated estimation of Markov source parameters from sparse data.</title>
<date>1980</date>
<booktitle>In Proceedings of the Workshop on Pattern Recognition in Practice,</booktitle>
<location>Amsterdam, The Netherlands: North-Holland,</location>
<contexts>
<context position="2272" citStr="Jelinek and Mercer (1980)" startWordPosition="352" endWordPosition="355">er the latter. While smoothing is a central issue in language modeling, the literature lacks a definitive comparison between the many existing techniques. Previous studies (Nadas, 1984; Katz, 1987; Church and Gale, 1991; MacKay and Peto, 1995) only compare a small number of methods (typically two) on a single corpus and using a single training data size. As a result, it is currently difficult for a researcher to intelligently choose between smoothing schemes. In this work, we carry out an extensive empirical comparison of the most widely used smoothing techniques, including those described by Jelinek and Mercer (1980), Katz (1987), and Church and Gale (1991). We carry out experiments over many training data sizes on varied corpora using both bigram and trigram models. We demonstrate that the relative performance of techniques depends greatly on training data size and n-gram order. For example, for bigram models produced from large training sets Church-Gale smoothing has superior performance, while Katz smoothing performs best on bigram models produced from smaller data. For the methods with parameters that can be tuned to improve performance, we perform an automated search for optimal values and show that </context>
<context position="6676" citStr="Jelinek and Mercer, 1980" startWordPosition="1097" endWordPosition="1100">has the flaw of assigning the same probability to say, burnish the and burnish thou (assuming neither occurred in the training data), even though intuitively the former seems more likely because the word the is much more common than thou. To address this, another smoothing technique is to interpolate the bigram model with a unigram model PmL(wi) = c(w)/N5, a model that reflects how often each word occurs in the training data. For example, we can take Pinterp (wi I wi-1) = APA4L(wi Iwz_i)+ (1— A)PmL(wi) getting the behavior that bigrams involving common words are assigned higher probabilities (Jelinek and Mercer, 1980). c(w1:41) + 6111 (2) and where Lidstone and Jeffreys advocate 6 = 1. Gale and Church (1990; 1994) have argued that this method generally performs poorly. The Good-Turing estimate (Good, 1953) is central to many smoothing techniques. It is not used directly for n-gram smoothing because, like additive smoothing, it does not perform the interpolation of lower- and higher-order models essential for good performance. Good-Turing states that an n-gram that occurs r times should be treated as if it had occurred r* times, where r* = (r + 1) nr+1 and where n,. is the number of n-grams that occur exact</context>
<context position="8858" citStr="Jelinek and Mercer (1980)" startWordPosition="1464" endWordPosition="1467">one, 1920; Johnson, 1932; Jeffreys, 1948), where we take c(wLn+i) + 6 Padd (Wi I witni +1) = 311 old bucketing new bucketing 0.8 0.8 OA 0.6 2 0.4 0.4 0.2 0.2 100000 10000 100 (1.001 0.01 0.1 10 average norvaino count in distribution minus one 10 100 1000 number of counts in distribution . ° vu :1; • o .44% :• tit..•••4.6.&amp;quot; 0. 8.8 :Of.% .° . • .. **. . tt.. • ..• et.8 • ••• ° 01: Figure 1: A values for old and new bucketing schemes for Jelinek-Mercer smoothing; each point represents a single bucket The other smoothing technique besides Katz smoothing widely used in speech recognition is due to Jelinek and Mercer (1980). They present a class of smoothing models that involve linear interpolation, e.g., Brown et al. (1992) take Pinterp (Wi I W! in&apos; +1) -= Aw.-1 PML(Wi 1U4--n1+1) i—n+1 (1 — Aevi.-1 ) Pinterp(Wi IWi_ni-1+2) (3) ,-n+1 That is, the maximum likelihood estimate is interpolated with the smoothed lower-order distribution, which is defined analogously. Training a distinct for each vi!---n+1 1 is not generally felicitous; z Bahl, Jelinek, and Mercer (1983) suggest partitioning the A-i into buckets according to c(wii=n1+1), i—n+1 where all in the same bucket are constrained -i-,,+1 to have the same value</context>
</contexts>
<marker>Jelinek, Mercer, 1980</marker>
<rawString>Jelinek, Frederick and Robert L. Mercer. 1980. Interpolated estimation of Markov source parameters from sparse data. In Proceedings of the Workshop on Pattern Recognition in Practice, Amsterdam, The Netherlands: North-Holland, May.</rawString>
</citation>
<citation valid="true">
<authors>
<author>W E Johnson</author>
</authors>
<title>Probability: deductive and inductive problems.</title>
<date>1932</date>
<journal>Mind,</journal>
<pages>41--421</pages>
<contexts>
<context position="5627" citStr="Johnson, 1932" startWordPosition="923" endWordPosition="924">r of words, or bigram, say burnish the, doesn&apos;t occur in the training data. Then, we have PmL(thelburnish) = 0, which is clearly inaccurate as this probability should be larger than zero. A zero bigram probability can lead to errors in speech recognition, as it disallows the bigram regardless of how informative the acoustic signal is. The term smoothing describes techniques for adjusting the maximum likelihood estimate to hopefully produce more accurate probabilities. As an example, one simple smoothing technique is to pretend each bigram occurs once more than it actually did (Lidstone, 1920; Johnson, 1932; Jeffreys, 1948), yielding P�i(wiw_i) = c(wi_i) + IVI where V is the vocabulary, the set of all words being considered. This has the desirable quality of &apos;To make the term P(wilw:=41) meaningful for i &lt; n, one can pad the beginning of the string with a distinguished token. In this work, we assume there are n —1 such distinguished tokens preceding each sentence. preventing zero bigram probabilities. However, this scheme has the flaw of assigning the same probability to say, burnish the and burnish thou (assuming neither occurred in the training data), even though intuitively the former seems m</context>
<context position="8257" citStr="Johnson, 1932" startWordPosition="1352" endWordPosition="1353"> partitioning a set of n-grams into disjoint groups, where each group is characterized independently through a set of parameters. Like Katz, models are defined recursively in terms of lower-order models. Each n-gram is assigned to one of several buckets based on its frequency predicted from lower-order models. Each bucket is treated as a separate distribution and Good-Turing estimation is performed within each, giving corrected counts that are normalized to yield probabilities. C(Wi_ Wi) + 1 2 Previous Work The simplest type of smoothing used in practice is additive smoothing (Lidstone, 1920; Johnson, 1932; Jeffreys, 1948), where we take c(wLn+i) + 6 Padd (Wi I witni +1) = 311 old bucketing new bucketing 0.8 0.8 OA 0.6 2 0.4 0.4 0.2 0.2 100000 10000 100 (1.001 0.01 0.1 10 average norvaino count in distribution minus one 10 100 1000 number of counts in distribution . ° vu :1; • o .44% :• tit..•••4.6.&amp;quot; 0. 8.8 :Of.% .° . • .. **. . tt.. • ..• et.8 • ••• ° 01: Figure 1: A values for old and new bucketing schemes for Jelinek-Mercer smoothing; each point represents a single bucket The other smoothing technique besides Katz smoothing widely used in speech recognition is due to Jelinek and Mercer (1980</context>
</contexts>
<marker>Johnson, 1932</marker>
<rawString>Johnson, W.E. 1932. Probability: deductive and inductive problems. Mind, 41:421-423.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Slava M Katz</author>
</authors>
<title>Estimation of probabilities from sparse data for the language model component of a speech recognizer.</title>
<date>1987</date>
<journal>IEEE Transactions on Acoustics, Speech and Signal Processing,</journal>
<pages>35--3</pages>
<contexts>
<context position="1843" citStr="Katz, 1987" startWordPosition="284" endWordPosition="285">Church, and Gale, 1990). A language model is a probability distribution over strings P(s) that attempts to reflect the frequency with which each string s occurs as a sentence in natural text. Language models are used in speech recognition to resolve acoustically ambiguous utterances. For example, if we have that PO takes two) &gt;&gt; P(it takes too), then we know ceieris paribus to prefer the former transcription over the latter. While smoothing is a central issue in language modeling, the literature lacks a definitive comparison between the many existing techniques. Previous studies (Nadas, 1984; Katz, 1987; Church and Gale, 1991; MacKay and Peto, 1995) only compare a small number of methods (typically two) on a single corpus and using a single training data size. As a result, it is currently difficult for a researcher to intelligently choose between smoothing schemes. In this work, we carry out an extensive empirical comparison of the most widely used smoothing techniques, including those described by Jelinek and Mercer (1980), Katz (1987), and Church and Gale (1991). We carry out experiments over many training data sizes on varied corpora using both bigram and trigram models. We demonstrate th</context>
<context position="14962" citStr="Katz, 1987" startWordPosition="2479" endWordPosition="2480">erformance. Parameter values are determined through training on held-out data. 4.2.1 Baseline Smoothing (interp-baseline) For our baseline smoothing method, we use an instance of Jelinek-Mercer smoothing where we constrain all Ami-i to be equal to a single value An for each n, i.e., Pbase (Wi iwitni +1) = An PmL(wi +1) + (1 — An) Pbase(wilw!=n1+2) 4.2.2 Additive Smoothing (plus-one and plus-delta) We consider two versions of additive smoothing. Referring to equation (2), we fix 6 = 1 in plus-one smoothing. In plus-delta, we consider any b. 4.2.3 Katz Smoothing (katz) While the original paper (Katz, 1987) uses a single parameter k, we instead use a different k for each n &gt; 1, kn. We smooth the unigram distribution using additive smoothing with parameter b. 4.2.4 Church-Gale Smoothing (church-gale) To smooth the counts 72, needed for the GoodTuring estimate, we use the technique described by Gale and Sampson (1995). We smooth the unigram distribution using Good-Turing without any bucketing. Instead of the bucketing scheme described in the original paper, we use a scheme analogous to the one described by Bahl, Jelinek, and Mercer (1983). We make the assumption that whether a bucket is large enou</context>
<context position="27185" citStr="Katz (1987)" startWordPosition="4408" endWordPosition="4409">ossible to discover whether any calculated differences are statistically significant. Furthermore, we show that sub-optimal parameter selection can also significantly affect relative performance. We find that the two most widely used techniques, Katz smoothing and Jelinek-Mercer smoothing, perform consistently well across training set sizes for both bigram and trigram models, with Katz smoothing performing better on trigram models produced from large training sets and on bigram models in general. These results question the generality of the previous reference result concerning Katz smoothing: Katz (1987) reported that his method slightly outperforms an unspecified version ofJelinek-Mercer smoothing on a single training set of 750,000 words. Furthermore, we show that Church-Gale smoothing, which previously had not been compared with common smoothing techniques, outperforms all existing methods on bigram models produced from large training sets. Finally, we find that our novel methods average-count and one-count are superior to existing methods for trigram models and perform well on bigram models; method one-count yields marginally worse performance but is extremely easy to implement. In this s</context>
</contexts>
<marker>Katz, 1987</marker>
<rawString>Katz, Slava M. 1987. Estimation of probabilities from sparse data for the language model component of a speech recognizer. IEEE Transactions on Acoustics, Speech and Signal Processing, ASSP-35(3):400-401, March.</rawString>
</citation>
<citation valid="true">
<authors>
<author>K W Church Kernighan</author>
<author>W A Gale</author>
</authors>
<title>A spelling correction program based on a noisy channel model.</title>
<date>1990</date>
<booktitle>In Proceedings of the Thirteenth International Conference on Computational Linguistics,</booktitle>
<pages>205--210</pages>
<marker>Kernighan, Gale, 1990</marker>
<rawString>Kernighan, M.D., K.W. Church, and W.A. Gale. 1990. A spelling correction program based on a noisy channel model. In Proceedings of the Thirteenth International Conference on Computational Linguistics, pages 205-210.</rawString>
</citation>
<citation valid="true">
<authors>
<author>G J Lidstone</author>
</authors>
<title>Note on the general case of the Bayes-Laplace formula for inductive or a posteriori probabilities.</title>
<date>1920</date>
<journal>Transactions of the Faculty of Actuaries,</journal>
<pages>8--182</pages>
<contexts>
<context position="5612" citStr="Lidstone, 1920" startWordPosition="921" endWordPosition="922">tion where a pair of words, or bigram, say burnish the, doesn&apos;t occur in the training data. Then, we have PmL(thelburnish) = 0, which is clearly inaccurate as this probability should be larger than zero. A zero bigram probability can lead to errors in speech recognition, as it disallows the bigram regardless of how informative the acoustic signal is. The term smoothing describes techniques for adjusting the maximum likelihood estimate to hopefully produce more accurate probabilities. As an example, one simple smoothing technique is to pretend each bigram occurs once more than it actually did (Lidstone, 1920; Johnson, 1932; Jeffreys, 1948), yielding P�i(wiw_i) = c(wi_i) + IVI where V is the vocabulary, the set of all words being considered. This has the desirable quality of &apos;To make the term P(wilw:=41) meaningful for i &lt; n, one can pad the beginning of the string with a distinguished token. In this work, we assume there are n —1 such distinguished tokens preceding each sentence. preventing zero bigram probabilities. However, this scheme has the flaw of assigning the same probability to say, burnish the and burnish thou (assuming neither occurred in the training data), even though intuitively the</context>
<context position="8242" citStr="Lidstone, 1920" startWordPosition="1350" endWordPosition="1351">the technique of partitioning a set of n-grams into disjoint groups, where each group is characterized independently through a set of parameters. Like Katz, models are defined recursively in terms of lower-order models. Each n-gram is assigned to one of several buckets based on its frequency predicted from lower-order models. Each bucket is treated as a separate distribution and Good-Turing estimation is performed within each, giving corrected counts that are normalized to yield probabilities. C(Wi_ Wi) + 1 2 Previous Work The simplest type of smoothing used in practice is additive smoothing (Lidstone, 1920; Johnson, 1932; Jeffreys, 1948), where we take c(wLn+i) + 6 Padd (Wi I witni +1) = 311 old bucketing new bucketing 0.8 0.8 OA 0.6 2 0.4 0.4 0.2 0.2 100000 10000 100 (1.001 0.01 0.1 10 average norvaino count in distribution minus one 10 100 1000 number of counts in distribution . ° vu :1; • o .44% :• tit..•••4.6.&amp;quot; 0. 8.8 :Of.% .° . • .. **. . tt.. • ..• et.8 • ••• ° 01: Figure 1: A values for old and new bucketing schemes for Jelinek-Mercer smoothing; each point represents a single bucket The other smoothing technique besides Katz smoothing widely used in speech recognition is due to Jelinek a</context>
</contexts>
<marker>Lidstone, 1920</marker>
<rawString>Lidstone, G.J. 1920. Note on the general case of the Bayes-Laplace formula for inductive or a posteriori probabilities. Transactions of the Faculty of Actuaries, 8:182-192.</rawString>
</citation>
<citation valid="true">
<authors>
<author>David J C MacKay</author>
<author>Linda C Peto</author>
</authors>
<title>A hierarchical Dirichlet language model.</title>
<date>1995</date>
<journal>Natural Language Engineering,</journal>
<pages>1--3</pages>
<contexts>
<context position="1890" citStr="MacKay and Peto, 1995" startWordPosition="290" endWordPosition="293"> model is a probability distribution over strings P(s) that attempts to reflect the frequency with which each string s occurs as a sentence in natural text. Language models are used in speech recognition to resolve acoustically ambiguous utterances. For example, if we have that PO takes two) &gt;&gt; P(it takes too), then we know ceieris paribus to prefer the former transcription over the latter. While smoothing is a central issue in language modeling, the literature lacks a definitive comparison between the many existing techniques. Previous studies (Nadas, 1984; Katz, 1987; Church and Gale, 1991; MacKay and Peto, 1995) only compare a small number of methods (typically two) on a single corpus and using a single training data size. As a result, it is currently difficult for a researcher to intelligently choose between smoothing schemes. In this work, we carry out an extensive empirical comparison of the most widely used smoothing techniques, including those described by Jelinek and Mercer (1980), Katz (1987), and Church and Gale (1991). We carry out experiments over many training data sizes on varied corpora using both bigram and trigram models. We demonstrate that the relative performance of techniques depen</context>
<context position="10013" citStr="MacKay and Peto (1995)" startWordPosition="1651" endWordPosition="1654">l in the same bucket are constrained -i-,,+1 to have the same value. To yield meaningful results, the data used to estimate the Ai-i need to be disjoint from the data i—n+1 used to calculate PDAL.2 In held-out interpolation, one reserves a section of the training data for this purpose. Alternatively, Jelinek and Mercer describe a technique called deleted interpolation where different parts of the training data rotate in training either PML or the A ; the results are then averaged. Wi—n+1 Several smoothing techniques are motivated within a Bayesian framework, including work by Nadas (1984) and MacKay and Peto (1995). 3 Novel Smoothing Techniques Of the great many novel methods that we have tried, two techniques have performed especially well. 2 When the same data is used to estimate both, setting all ,-1 to one yields the optimal result. 3.1 Method average-count This scheme is an instance of Jelinek-Mercer smoothing. Referring to equation (3), recall that Bahl et al. suggest bucketing the A.,-i according .-n+1 to c(w!=n1+1). We have found that partitioning the A.,-i according to the average number of counts 0— v.+ 1 C( 21):— per non-zero element 1...,(.:::+1 ) +,)&gt;O1 yields better results. Intuitively, t</context>
<context position="11488" citStr="MacKay and Peto (1995)" startWordPosition="1895" endWordPosition="1898">onsider a distribution with ten counts distributed evenly among ten words to be much more sparse than a distribution with ten counts all on a single word. The average number of counts per word seems to more directly express the concept of sparseness. In Figure 1, we graph the value of A assigned to each bucket under the original and new bucketing schemes on identical data. Notice that the new bucketing scheme results in a much tighter plot, indicating that it is better at grouping together distributions with similar behavior. 3.2 Method one-count This technique combines two intuitions. First, MacKay and Peto (1995) argue that a reasonable form for a smoothed distribution is aPone(wilW!--n1 +2) Pone(Wi I +1) = C(Wii-n+1) C(W---71:t+1) Ce The parameter a can be thought of as the number of counts being added to the given distribution, 312 where the new counts are distributed as in the lowerorder distribution. Secondly, the Good-Turing estimate can be interpreted as stating that the number of these extra counts should be proportional to the number of words with exactly one count in the given distribution. We have found that taking a = 7 (4) works well, where 1/1(wii=n1+1) = ck-n+0 = is the number of words w</context>
</contexts>
<marker>MacKay, Peto, 1995</marker>
<rawString>MacKay, David J. C. and Linda C. Peto. 1995. A hierarchical Dirichlet language model. Natural Language Engineering, 1(3):1-19.</rawString>
</citation>
<citation valid="true">
<authors>
<author>David M Magerman</author>
</authors>
<title>Natural Language Parsing as Statistical Pattern Recognition.</title>
<date>1994</date>
<tech>Ph.D. thesis,</tech>
<institution>Stanford University,</institution>
<marker>Magerman, 1994</marker>
<rawString>Magerman, David M. 1994. Natural Language Parsing as Statistical Pattern Recognition. Ph.D. thesis, Stanford University, February.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Arthur Nadas</author>
</authors>
<title>Estimation of probabilities in the language model of the IBM speech recognition system.</title>
<date>1984</date>
<journal>IEEE Transactions on Acoustics, Speech and Signal Processing,</journal>
<pages>32--4</pages>
<contexts>
<context position="1831" citStr="Nadas, 1984" startWordPosition="282" endWordPosition="283">; Kernighan, Church, and Gale, 1990). A language model is a probability distribution over strings P(s) that attempts to reflect the frequency with which each string s occurs as a sentence in natural text. Language models are used in speech recognition to resolve acoustically ambiguous utterances. For example, if we have that PO takes two) &gt;&gt; P(it takes too), then we know ceieris paribus to prefer the former transcription over the latter. While smoothing is a central issue in language modeling, the literature lacks a definitive comparison between the many existing techniques. Previous studies (Nadas, 1984; Katz, 1987; Church and Gale, 1991; MacKay and Peto, 1995) only compare a small number of methods (typically two) on a single corpus and using a single training data size. As a result, it is currently difficult for a researcher to intelligently choose between smoothing schemes. In this work, we carry out an extensive empirical comparison of the most widely used smoothing techniques, including those described by Jelinek and Mercer (1980), Katz (1987), and Church and Gale (1991). We carry out experiments over many training data sizes on varied corpora using both bigram and trigram models. We de</context>
<context position="9986" citStr="Nadas (1984)" startWordPosition="1648" endWordPosition="1649">), i—n+1 where all in the same bucket are constrained -i-,,+1 to have the same value. To yield meaningful results, the data used to estimate the Ai-i need to be disjoint from the data i—n+1 used to calculate PDAL.2 In held-out interpolation, one reserves a section of the training data for this purpose. Alternatively, Jelinek and Mercer describe a technique called deleted interpolation where different parts of the training data rotate in training either PML or the A ; the results are then averaged. Wi—n+1 Several smoothing techniques are motivated within a Bayesian framework, including work by Nadas (1984) and MacKay and Peto (1995). 3 Novel Smoothing Techniques Of the great many novel methods that we have tried, two techniques have performed especially well. 2 When the same data is used to estimate both, setting all ,-1 to one yields the optimal result. 3.1 Method average-count This scheme is an instance of Jelinek-Mercer smoothing. Referring to equation (3), recall that Bahl et al. suggest bucketing the A.,-i according .-n+1 to c(w!=n1+1). We have found that partitioning the A.,-i according to the average number of counts 0— v.+ 1 C( 21):— per non-zero element 1...,(.:::+1 ) +,)&gt;O1 yields bet</context>
</contexts>
<marker>Nadas, 1984</marker>
<rawString>Nadas, Arthur. 1984. Estimation of probabilities in the language model of the IBM speech recognition system. IEEE Transactions on Acoustics, Speech and Signal Processing, ASSP-32(4):859-861, August.</rawString>
</citation>
<citation valid="true">
<authors>
<author>W H Press</author>
<author>B P Flannery</author>
<author>S A Teukolsky</author>
<author>W T Vetterling</author>
</authors>
<title>Numerical Recipes in C.</title>
<date>1988</date>
<publisher>Cambridge University Press,</publisher>
<location>Cambridge.</location>
<contexts>
<context position="18661" citStr="Press et al., 1988" startWordPosition="3079" endWordPosition="3082"> or less. Each point on the graphs on the right represents a single run, but we consider sizes up to the amount of data available. The graphs on the bottom of Figures 3-4 are close-ups of the graphs above, focusing on those algorithms that perform better than the baseline. To give an idea of how these cross-entropy differences translate to perplexity, each 0.014 bits correspond roughly to a 1% change in perplexity. In each run except as noted below, optimal values for the parameters of the given technique were searched for using Powell&apos;s search algorithm as realized in Numerical Recipes in C (Press et al., 1988, pp. 309-317). Parameters were chosen to optimize the cross-entropy of one of the development test sets associated with the given training set. To constrain the search, we searched only those parameters that were found to affect performance significantly, as verified through preliminary experiments over several data sizes. For katz and church-gale, we did not perform the parameter search for training sets over 50,000 sentences due to resource constraints, and instead manually extrapolated parameter valMethod Lines interp-baseline3 400 plus-one 40 plus-delta 40 katz 300 church-gale 1000 int er</context>
</contexts>
<marker>Press, Flannery, Teukolsky, Vetterling, 1988</marker>
<rawString>Press, W.H., B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling. 1988. Numerical Recipes in C. Cambridge University Press, Cambridge.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>