<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000284">
<title confidence="0.998812">
Millstream Systems – a Formal Model for
Linking Language Modules by Interfaces
</title>
<author confidence="0.994273">
Suna Bensch
</author>
<affiliation confidence="0.9914275">
Department of Computing Science,
Ume˚a University, Ume˚a, Sweden
</affiliation>
<email confidence="0.971578">
suna@cs.umu.se
</email>
<author confidence="0.995495">
Frank Drewes
</author>
<affiliation confidence="0.991266">
Department of Computing Science,
Ume˚a University, Ume˚a, Sweden
</affiliation>
<email confidence="0.986023">
drewes@cs.umu.se
</email>
<sectionHeader confidence="0.99458" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.9998944">
We introduce Millstream systems, a for-
mal model consisting of modules and an
interface, where the modules formalise
different aspects of language, and the in-
terface links these aspects with each other.
</bodyText>
<sectionHeader confidence="0.994441" genericHeader="keywords">
1 Credits
</sectionHeader>
<bodyText confidence="0.996619666666667">
This work is partially supported by the project
Tree Automata in Computational Language Tech-
nology within the Sweden – South Africa Re-
search Links Programme. A preliminary but more
detailed version of this article is available as a
technical report (Bensch and Drewes, 2009).
</bodyText>
<sectionHeader confidence="0.99891" genericHeader="introduction">
2 Introduction
</sectionHeader>
<bodyText confidence="0.998940409090909">
Modern linguistic theories (Sadock, 1991; Jack-
endoff, 2002) promote the view that different as-
pects of language, such as phonology, morphol-
ogy, syntax, and semantics should be viewed as
autonomous modules that work simultaneously
and are linked with each other by interfaces that
describe their interaction and interdependency.
Formalisms in modern computational linguistics
which establish interfaces between different as-
pects of language are the Combinatory Categorical
Grammar (CCG), the Functional Generative De-
scription (FGD), the Head-Driven Phrase Struc-
ture Grammar (HPSG), the Lexical Functional
Grammar (LFG), and the Extensible Dependency
Grammar (XDG).1 Here, we propose Millstream
systems, an approach from a formal language the-
oretic point of view which is based on the same
ideas as XDG, but uses tree-generating modules
of arbitrary kinds.
Let us explain in slightly more detail what a
Millstream system looks like. A Millstream sys-
tem contains any number of tree generators, called
</bodyText>
<note confidence="0.796308">
1See, e.g., (Dalrymple, 2001; Sgall et al., 1986; Pollard
and Sag, 1994; Steedman, 2000; Debusmann, 2006; Debus-
mann and Smolka, 2006).
</note>
<bodyText confidence="0.999840731707317">
its modules. Such a tree generator is any device
that specifies a tree language. For example, a tree
generator may be a context-free grammar, tree ad-
joining grammar, a finite-state tree automaton, a
dependency grammar, a corpus, human input, etc.
Even within a single Millstream system, the mod-
ules need not be of the same kind, since they are
treated as “black boxes”. The Millstream system
links the trees generated by the modules by an in-
terface consisting of logical formulas.
Suppose that a Millstream system has k mod-
ules. Then the interface consists of interface rules
in the form of logical expressions that establish
links between the (nodes of the) trees t1, ... , tk
that are generated by the individual modules.
Thus, a valid combination of trees is not just any
collection of trees t1, ... , tk generated by the k
modules. It also includes, between these struc-
tures, interconnecting links that represent their
relationships and that must follow the rules ex-
pressed by the interface. Grammaticality, in terms
of a Millstream system, means that the individ-
ual structures must be valid (i.e., generated by the
modules) and are linked in such a way that all in-
terface rules are logically satisfied. A Millstream
system can thus be considered to perform indepen-
dent concurrent derivations of autonomous mod-
ules, enriched by an interface that establishes links
between the outputs of the modules, thus con-
straining the acceptable configurations.
Millstream systems may, for example, be of in-
terest for natural language understanding and nat-
ural language generation. Simply put, the task
of natural language understanding is to construct
a suitable semantic representation of a sentence
that has been heard (phonology) and parsed (syn-
tax). Within the framework of Millstream sys-
tems this corresponds to the problem where we are
given a syntactic tree (and possibly a phonologi-
cal tree if such a module is involved) and the goal
is to construct an appropriate semantic tree. Con-
</bodyText>
<page confidence="0.983029">
28
</page>
<note confidence="0.9825185">
Proceedings of the 2010 Workshop on Applications of Tree Automata in Natural Language Processing, ACL 2010, pages 28–36,
Uppsala, Sweden, 16 July 2010. c�2010 Association for Computational Linguistics
</note>
<bodyText confidence="0.999936833333333">
versely, natural language generation can be seen as
the problem to construct an appropriate syntactic
(and/or phonological) tree from a given semantic
tree. In abstract terms, the situations just described
are identical. We refer to the problem as the
completion problem. While the current paper is
mainly devoted to the introduction and motivation
of Millstream systems, in (Bensch et al., 2010) the
completion problem is investigated for so-called
regular MSO Millstream systems, i.e. systems in
which the modules are regular tree grammars (or,
equivalently, finite tree automata) and the interface
conditions are expressed in monadic second-order
(MSO) logic. In Section 7, the results obtained so
far are briefly summarised.
Now, let us roughly compare Millstream sys-
tems with XDG. Conceptually, the k modules of a
Millstream system correspond to the k dimensions
of an XDG. In an XDG, a configuration consists
of dependency structures t1, ... , tk. The interface
of a Millstream system corresponds to the princi-
ples of the XDG. The latter are logical formulas
that express conditions that the collection of de-
pendency structures must fulfill.
The major difference between the two for-
malisms lies in the fact that XDG inherently builds
upon dependency structures, whereas the modules
of a Millstream system are arbitrary tree genera-
tors. In XDG, each of t1, ... , tk is a dependency
analysis of the sentence considered. In particu-
lar, they share the yield and the set of nodes (as
the nodes of a dependency tree correspond to the
words in the sentence analysed, and its yield is that
sentence). Millstream systems do not make simi-
lar assumptions, which means that they may give
rise to new questions and possibilities:
</bodyText>
<listItem confidence="0.9985074">
• The purpose of a Millstream system is not
necessarily the analysis of sentences. For ex-
ample, a Millstream system with two mod-
ules could translate one language into an-
other. For this, tree grammars representing
the source and target languages could be used
as modules, with an interface expressing that
t2 is a correct translation of t1. This sce-
nario makes no sense in the context of XDG,
because the sentences represented by t1 and
t2 differ. Many similar applications of Mill-
stream system may the thought of, for exam-
ple correction or simplification of sentences.
• As the modules may be arbitrary devices
specifying tree languages, they contribute
</listItem>
<bodyText confidence="0.999286285714286">
their own generative power and theoretical
properties to the whole (in contrast to XDG,
which does not have such a separation). This
makes it possible to apply known results from
tree language theory, and to study the inter-
play between different kinds of modules and
interface logics.
</bodyText>
<listItem confidence="0.916188473684211">
• The fact that the individual modules of a
Millstream system may belong to different
classes of tree generators could be linguis-
tically valuable. For example, a Millstream
system combining a dependency grammar
module with a regular tree grammar module,
could be able to formalise aspects of a given
natural language that cannot be formalised by
using only one of these formalisms.
• For Millstream systems whose modules are
generative grammar formalisms (such as reg-
ular tree grammars, tree-adjoining grammars
and context-free tree grammars), it will be in-
teresting to study conditions under which the
Millstream system as a whole becomes gen-
erative, in the sense that well-formed config-
urations can be constructed in a step-by-step
manner based on the derivation relations of
the individual modules.
</listItem>
<bodyText confidence="0.999787375">
Let us finally mention another, somewhat sub-
tle difference between XDG and Millstream sys-
tems. In XDG, the interfaces are dimensions
on their own. For example, an XDG captur-
ing the English syntax and semantics would have
three dimensions, namely syntax, semantics, and
the syntax-semantics interface. An analysis of a
sentence would thus consist of three dependency
trees, where the third one represents the relation
between the other two. In contrast, a correspond-
ing Millstream system would only have two mod-
ules. The interface between them is considered
to be conceptually different and establishes direct
links between the trees that are generated by the
two modules. One of our tasks (which is, however,
outside the scope of this contribution) is a study of
the formal relation between XDG and Millstream
systems, to achieve a proper understanding of their
similarities and differences.
The rest of the paper is organised as follows.
In the next section, we discuss an example illus-
trating the linguistic notions and ideas that Mill-
stream systems attempt to provide a formal basis
for. After some mathematical preliminaries, which
</bodyText>
<page confidence="0.997592">
29
</page>
<bodyText confidence="0.9998378">
are collected in Section 4, the formal definition of
Millstream systems is presented in Section 5. Sec-
tion 6 contains examples and remarks related to
Formal Language Theory. Finally, Section 7 dis-
cusses preliminary results and future work.
</bodyText>
<sectionHeader confidence="0.948056" genericHeader="method">
3 Linguistical Background
</sectionHeader>
<bodyText confidence="0.9990605">
In this section, we discuss an example, roughly
following (Jackendoff, 2002), that illustrates the
linguistic ideas that have motivated our approach.
Figure 1 shows the phonological, syntactical and
semantical structure, depicted as trees (a), (b) and
(c), respectively of the sentence Mary likes Peter.
Trees are defined formally in the next section, for
the time being we assume the reader to be familiar
with the general notion of a tree as used in linguis-
tics and computer science.
</bodyText>
<figure confidence="0.9720735">
(b) (c) s
S
</figure>
<figureCaption confidence="0.9200785">
Figure 1: Phonological, syntactical and semantical
structure of Mary likes Peter.
</figureCaption>
<bodyText confidence="0.991101977777778">
The segmental structure in the phonological
tree (a) is the basic pronunciation of the sentence
Mary likes Peter, where each symbol represents
a speech sound. This string of speech sound sym-
bols is structured into phonological words by mor-
phophonolgy. The morphophonological structure
in our example consists of the three full phono-
logical words me@ri, lack, pit@r and of the clitic s.
The clitic is attached to the adjacent phonologi-
cal word, thus forming a larger phonological con-
stituent. The syntactical tree (b) depicts the syn-
tactical constituents. The sentence S is divided
into a noun phrase NP and a verb phrase VP.
The verb phrase VP is divided into an inflected
verb V and a noun phrase NP. The inflected verb
consists of its uninflected form and its inflection,
which refers, in our example, to the grammatical
features present tense and third person singular.
The semantical tree (c) depicts the semantical con-
stituents. In our example, like is a function of type
state and takes two arguments, namely mary and
peter which are of type agent and patient.
The structure of Mary likes Peter is not just the
sum of its phonological, syntactical and semanti-
cal structures. It also includes the relationships be-
tween certain constituents in these tree structures.
To illustrate these relationships we use indices in
Figure 1. The sole role of the indices here is to
express the linguistic relationships among coin-
dexed constituents. The indices do not occur in the
formalisation, where they are replaced by logical
links relating the nodes that, in the figure, carry the
same indices.2 The morphophonological word w1,
for example, is linked with the noun phrase NP1
in the syntactical tree and with the conceptual con-
stituent maryagent 1in the semantical tree. This il-
lustrates that w1, NP1, and maryagent 1are the cor-
responding morphophonological, syntactical and
semantical representations of Mary, respectively.
But there are also correspondences that concern
only the phonological and syntactical trees, ex-
cluding the semantical tree. For example, the in-
flected word V2 in the syntactical structure corre-
sponds to the phonological word w2, but has no
link to the semantical structure whatsoever.
</bodyText>
<sectionHeader confidence="0.99554" genericHeader="method">
4 Preliminaries
</sectionHeader>
<bodyText confidence="0.9997475">
The set of non-negative integers is denoted by N,
and N+ = N \ {0}. For k E N, we let [k] =
11, ... , k}. For a set 5, the set of all nonempty
finite sequences (or strings) over 5 is denoted by
5+; if the empty sequence c is included, we write
5*. As usual, A1 x · · · x Ak denotes the Cartesian
product of sets A1, ... , Ak. The transitive and re-
flexive closure of a binary relation ==&gt;. C_ A x A on
a set A is denoted by ==&gt;.*. A ranked alphabet is
a finite set E of pairs (f, k), where f is a symbol
and k E N is its rank. We denote (f, k) by f(k), or
simply by f if k is understood or of lesser impor-
tance. Further, we let E(k) = If(n) E EI n = k}.
We define trees over E in one of the standard ways,
by identifying the nodes of a tree t with sequences
of natural numbers. Intuitively, such a sequence
</bodyText>
<footnote confidence="0.897661333333333">
2The reader is referred to (Bensch and Drewes, 2009) for
the proper formalisation of the example in terms of a Mill-
stream system.
</footnote>
<figure confidence="0.983906260869565">
(a)
s
w1
w2
w5
Morphophonology
w3
cl4
Segmental structure
me@ri
lack
s pit@r
1
gent peterpatient
mary
NP5
pressituation
4
likestate
3
NP1 VP
V2
V3 infl4
</figure>
<page confidence="0.981175">
30
</page>
<bodyText confidence="0.999318">
shows that path from the root of the tree to the
node in question. In particular, the root is the
empty sequence E.
Formally, the set TΣ of trees over E consists of
all mappings t: V (t) → E (called trees) with the
following properties:
</bodyText>
<listItem confidence="0.993000571428571">
• The set V (t) of nodes oft is a finite and non-
empty prefix-closed subset of N∗+. Thus, for
every node vi ∈ V (t) (where i ∈ N+), its
parent v is in V (t) as well.
• For every node v ∈ V (t), if t(v) = f(k), then
{i ∈ N  |vi ∈ V (t)} = [k]. In other words,
the children of v are v1, ... , vk.
</listItem>
<bodyText confidence="0.951648756097561">
Let t ∈ TΣ be a tree. The root of t is the node
E. For every node v ∈ V (t), the subtree of t
rooted at v is denoted by t/v. It is defined by
V (t/v) = {v0 ∈ N∗  |vv0 ∈ V (t)} and, for all
v0 ∈ V (t/v), (t/v)(v0) = t(vv0). We shall de-
note a tree t as f[t1, ... , tk] if t(E) = f(k) and
t/i = ti for i ∈ [k]. In the special case where
k = 0 (i.e., V (t) = {E}), the brackets may be
omitted, thus denoting t as f. For a set S of trees,
the set of all trees of the form f[t1, ... , tk] such
that f(k) ∈ E and t1, ... , tk ∈ S is denoted by
E(S). For a tuple T ∈ TkΣ, we let V (T) denote
the set {(i, v)  |i ∈ [k] and v ∈ V (ti)}. Thus,
V (T) is the disjoint union of the sets V (ti). Fur-
thermore, we let V (T, i) denote the ith component
of this disjoint union, i.e., V (T, i) = {i} × V (ti)
for all i ∈ [k]. A tree language is a subset of TΣ,
for a ranked alphabet E, and a E-tree generator (or
simply tree generator) is any sort of formal device
G that determines a tree language L(G) ⊆ TΣ. A
typical sort of tree generator, which we will use in
our examples, is the regular tree grammar.
Definition 1 (regular tree grammar). A regular
tree grammar is a tuple G = (N, E, R, S) con-
sisting of disjoint ranked alphabets N and E of
nonterminals and terminals, where N = N(0), a
finite set R of rules A → r, where A ∈ N and
r ∈ TΣ∪N, and an initial nonterminal S ∈ N.
Given trees t, t0 ∈ TΣ∪N, there is a derivation
step t ⇒ t0 if t0 is obtained from t by replacing
a single occurrence of a nonterminal A with r,
where A → r is a rule in R. The regular tree
language generated by G is
L(G)={t∈TΣ|S⇒ ∗ t}.
It is well known that a string language L is
context-free if and only if there is a regular tree
language L0, such that L = yield(L0). Here,
yield(L0) = {yield(t)  |t ∈ L0} denotes the set of
all yields of trees in L0, the yield yield(t) of a tree
t being the string obtained by reading its leaves
from left to right.
</bodyText>
<sectionHeader confidence="0.977934" genericHeader="method">
5 Millstream Systems
</sectionHeader>
<bodyText confidence="0.999399551724138">
Throughout the rest of this paper, let A denote any
type of predicate logic that allows us to make use
of n-ary predicates symbols. We indicate the ar-
ity of predicate symbols in the same way as the
rank of symbols in ranked alphabets, i.e., by writ-
ing P(n) if P is a predicate symbol of arity n. The
set of all well-formed formulas in A without free
variables (i.e., the set of sentences of A) is denoted
by FΛ. If S is a set, we say that a predicate symbol
P(n) is S-typed if it comes with an associated type
(s1, ... , sn) ∈ Sn. We write P : s1 × · · · × sn to
specify the type of P. Recall that an n-ary predi-
cate O on D is a function O: Dn → {true, false}.
Alternatively, O can be viewed as a subset of Dn,
namely the set of all (d1, ... , dn) ∈ Dn such that
O(d1, ... , dn) = true. We use these views in-
terchangeably, selecting whichever is more conve-
nient. Given a (finite) set P of predicate symbols,
a logical structure hD; (OP)P∈Pi consists of a set
D called the domain and, for each P(n) ∈ P, a
predicate OP ⊆ Dn. If an existing structure Z
is enriched with additional predicates (OP)P∈P&apos;
(where P ∩P0 = ∅), we denote the resulting struc-
ture by hZ; (OP)P∈P&apos;i. In this paper, we will only
consider structures with finite domains. To repre-
sent (tuples of) trees as logical structures, consider
a ranked alphabet E, and let r be the maximum
rank of symbols in E. A tuple T = (t1, ... , tk) ∈
Tk Σ will be represented by the structure
</bodyText>
<equation confidence="0.9002928">
|T  |= hV (T); (Vi)i∈[k], (labg)g∈Σ, (↓i)i∈[r]i
consisting of the domain V (T) and the predicates
V (1)
i (i ∈ [k]), lab(1) g(g ∈ E) and ↓(2)
i (i ∈ [r]).
</equation>
<bodyText confidence="0.959542">
The predicates are given as follows:
</bodyText>
<listItem confidence="0.993289444444444">
• For every i ∈ [k], Vi = V (T, i). Thus, Vi(d)
expresses that d is a node in ti (or, to be pre-
cise, that d represents a node of ti in the dis-
joint union V (T)).
• For every g ∈ E, labg = {(i, v) ∈ V (T) |
i ∈ [k] and ti(v) = g}. Thus, labg(d) ex-
presses that the label of d is g.
• For every j ∈ [r], ↓j = {((i, v), (i, vj)) |
i ∈ [k] and v, vj ∈ V (ti)}. Thus, ↓j(d, d0)
</listItem>
<page confidence="0.999478">
31
</page>
<bodyText confidence="0.99904093939394">
expresses that d&apos; is the jth child of d in one
of the trees t1, ... , tk. In the following, we
write d ↓j d&apos; instead of ↓j(d, d&apos;).
Note that, in the definition of |T|, we have
blurred the distinction between predicate symbols
and their interpretation as predicates, because this
interpretation is fixed. Especially in intuitive ex-
planations, we shall sometimes also identify the
logical structure |T |with the tuple T it represents.
To define Millstream systems, we start by for-
malising our notion of interfaces. The idea is that
a tuple T = (t1, ... , tk) of trees, represented by
the structure |T |, is augmented with additional in-
terface links that are subject to logical conditions.
An interface may contain finitely many different
kinds of interface links. Formally, the collection
of all interface links of a given kind is viewed as
a logical predicate. The names of the predicates
are called interface symbols. Each interface sym-
bol is given a type that indicates which trees it is
intended to link with each other.
For example, if we want to make use of ternary
links called TIE, each linking a node of t1 with
a node of t3 and a node of t4, we use the in-
terface symbol TIE: 1 × 3 × 4. This interface
symbol would then be interpreted as a predicate
OTIE ⊆ V (T, 1) × V (T, 3) × V (T, 4). Each triple
in OTIE would thus be an interface link of type TIE
that links a node in V (t1) with a node in V (t3) and
a node in V (t4).
Definition 2 (interface). Let E be a ranked al-
phabet. An interface on Tk E (k ∈ N) is a pair
INT = (I, -b), such that
</bodyText>
<listItem confidence="0.943983266666667">
• I is a finite set of [k]-typed predicate symbols
called interface symbols, and
• -b is a finite set of formulas in FA that may,
in addition to the fixed vocabulary of A, con-
tain the predicate symbols in I and those of
the structures |T |(where T ∈ Tk E). These
formulas are called interface conditions.
A configuration (w.r.t. INT) is a structure C =
h|T |; (OI)IETi, such that
•
T ⊆ Tk E,
•OI ⊆ V (T, i1) × · · · × V (T, ii) for every in-
terface symbol I : i1 × · · · × ii in I, and
• C satisfies the interface conditions in -1) (if
each symbol I ∈ I is interpreted as OI).
</listItem>
<bodyText confidence="0.992761357142857">
Note that several interfaces can always be com-
bined into one by just taking the union of their sets
of interface symbols and interface conditions.
Definition 3 (Millstream system). Let E be a
ranked alphabet and k ∈ N. A Millstream sys-
tem (MS, for short) is a system of the form MS =
(M1, ... , Mk; INT) consisting of E-tree genera-
tors M1, ... , Mk, called the modules of MS, and
an interface INT on TkE. The language L(MS)
generated by MS is the set of all configurations
h|T|; (OI)IETi such that T ∈ L(M1) × · · · ×
L(Mk).
Sometimes we consider only some of the trees
in these tuples. For this, if MS is as above and
</bodyText>
<equation confidence="0.990977666666667">
1 ≤ i1 &lt; · · · &lt; ii ≤ k, we define the notation
LMi1x···xMil (MS) = {(ti1, ... , til) |
h|(t1,..., tk); (OI)IET|i ∈ L(MS)}.
</equation>
<bodyText confidence="0.999958692307692">
The reader should note that, intentionally, Mill-
stream systems are not a priori “generative”. Even
less so, they are “derivational” by nature. This is
because there is no predefined notion of derivation
that allows us to create configurations by means
of a stepwise (though typically nondeterministic)
procedure. In fact, there cannot be one, unless we
make specific assumptions regarding the way in
which the modules work, but also regarding the
logic A and the form of the interface conditions
that may be used. Similarly, as mentioned in the
introduction, there is no predefined order of im-
portance or priority among the modules.
</bodyText>
<sectionHeader confidence="0.974013" genericHeader="method">
6 Examples and Remarks Related to
</sectionHeader>
<subsectionHeader confidence="0.571472">
Formal Language Theory
</subsectionHeader>
<bodyText confidence="0.9913956875">
The purpose of this section is to indicate, by
means of examples and easy observations, that
Millstream systems are not only linguistically well
motivated, but also worth studying from the point
of view of computer science, most notably regard-
ing their algorithmic and language-theoretic prop-
erties. While this kind of study is beyond the scope
of the current article, part of our future research on
Millstream systems will be devoted to such ques-
tions.
Example 1. Let A be ordinary first-order logic
with equality, and consider the Millstream system
MS over E = {◦(2), a(0), b(0), c(0), d(0)} which
consists of two identical modules M1 = M2 that
simply generate TE (e.g., using the regular tree
grammar with the single nonterminal S and the
</bodyText>
<page confidence="0.996867">
32
</page>
<bodyText confidence="0.963045">
rules3 S → ◦[S, S]  |a  |b  |c  |d) and a sin-
gle interface symbol BIJ: 1 × 2 with the interface
conditions
</bodyText>
<equation confidence="0.989088714285714">
∀x: lab{a,b,c,d}(x) ↔
∃y: BIJ(x, y) ∨ BIJ(y, x),
∀x, y, z: (BIJ(x, y) ∧ BIJ(x, z)∨
BIJ(y, x) ∧ BIJ(z, x)) → y = z,
∀x, y: BIJ(x, y) →
V (labz(x) ∧ labz(y)).
z∈{a,b,c,d}
</equation>
<bodyText confidence="0.995706777777778">
The first interface condition expresses that all
and only the leaves of both trees are linked. The
second expresses that no leaf is linked with two or
more leaves. In effect, this amounts to saying that
BIJ is a bijection between the leaves of the two
trees. The third interface condition expresses that
this bijection is label preserving. Altogether, this
amounts to saying that the yields of the two trees
are permutations of each other; see Figure 2.
</bodyText>
<figureCaption confidence="0.995884">
Figure 2: An element of L(MS) in Example 1.
</figureCaption>
<bodyText confidence="0.9967915">
Now, let us replace the modules by slightly
more interesting ones. For a string w over {A, B,
a, b, c, d}, let w denote any tree over {◦(2), A(0),
B(0), a(0), b(0), c(0), d(0)} with yield(w) = w.
(For example, we may choose w to be the left
comb whose leaf symbols are given by w.) Let the
Millstream system MS0 be defined as MS, but us-
ing the modules M01 = ({A, B, C, D}, E, R1, A)
and M02 = ({A, B}, E, R2, A) with the following
rules:
</bodyText>
<equation confidence="0.999579666666667">
R01 = {A → aA  |aB, B → bB  |bC,
C → cC  |cD, D → dD  |d},
R02 = {A → acA  |acB, B → bdB  |bd}.
</equation>
<bodyText confidence="0.993917333333333">
Thus, M01 and M02 are the “standard” grammars
(written as regular tree grammars) that generate
the regular languages {akblc&apos;dn  |k,1, m, n ≥
</bodyText>
<footnote confidence="0.500478">
3As usual, A --+ r  |r0 stands for A --+ r, A --+ r0.
</footnote>
<bodyText confidence="0.998110947368421">
1} and {(ac)&apos;(bd)n  |m, n ≥ 1}. The inter-
face makes sure that LM0�×M02(MS0) contains only
those pairs of trees t1, t2 in which yield(t1) is a
permutation of yield(t2). As a consequence, it
follows that yield(LM0�(MS)) = {a&apos;bnc&apos;dn |
m, n ≥ 1}.
The next example discusses how top-down tree
transductions can be implemented as Millstream
systems.
Example 2 (top-down tree transduction). Recall
that a tree transduction is a binary relation T ⊆
TΣ × TΣ0, where E and E0 are ranked alpha-
bets. The set of trees that a tree t ∈ TΣ is trans-
formed into is given by T(t) = {t0 ∈ TΣ0 |
(t, t0) ∈ T}. Obviously, every Millstream system
of the form MS = (M1, M2i INT) defines a tree
transduction, namely LM,×M2(MS). Let us con-
sider a very simple instance of a deterministic top-
down tree transduction T (see, e.g., (G´ecseg and
Steinby, 1997; F¨ul¨op and Vogler, 1998; Comon et
al., 2007) for definitions and references regarding
top-down tree transductions), where E = E0 =
{f(2),g(2), a(0)}.
the tree obtained from t by interchanging the sub-
trees of all top-most fs (i.e., of all nodes that are
labelled with f and do not have an ancestor that
is labelled with f as well) and turning the f at
hand into a g. To accomplish this, a top-down
tree transducer would use two states, say SWAP
and COPY, to traverse the input tree from the top
down, starting in state SWAP. Whenever an f is
reached in this state, its subtrees are interchanged
and the traversal continues in parallel on each of
the subtrees in state COPY. The only purpose of
this state is to copy the input to the output without
changing it. Formally, this would be expressed by
the following term rewrite rules, viewing the states
as symbols of rank 1:
</bodyText>
<equation confidence="0.788159833333333">
g[COPY[x2], COPY[x1]],
f[COPY[x1], COPY[x2]],
g[SWAP[x1], SWAP[x2]],
g[COPY[x1], COPY[x2]],
a,
a.
</equation>
<bodyText confidence="0.999826">
(We hope that these rules are intuitive enough to
be understood even by readers who are unfamiliar
with top-down tree transducers, as giving the for-
mal definition of top-down tree transducers would
be out of the scope of this article.) We mimic
the behaviour of the top-down tree transducer us-
</bodyText>
<figure confidence="0.999771541666666">
0
0
0
0
d 0
0
b 0
a c
0
c d
BIJ
BIJ
BIJ
c b
c a
BIJ
BIJ
We transform a tree t ∈ TΣ into
SWAP[f[x1, x2]] →
COPY[f[x1, x2]] →
SWAP[g[x1, x2]] →
COPY[g[x1, x2]] →
SWAP[a] →
COPY[a] →
</figure>
<page confidence="0.995788">
33
</page>
<bodyText confidence="0.993307909090909">
ing a Millstream system with interface symbols
SWAP : 1 x 2 and COPY: 1 x 2. Since the mod-
ules simply generate TΣ, they are not explicitly
discussed. The idea behind the interface is that an
interface link labelled q E {SWAP, COPY} links a
node v in the input tree with a node v� in the output
tree if the simulated computation of the tree trans-
ducer reaches v in state q, resulting in node v� in
the output tree. First, we specify that the initial
state is SWAP, which simply means that the roots
of the two trees are linked by a SWAP link:
</bodyText>
<equation confidence="0.937429">
Vx, y: root1(x) n root2(y) —* SWAP(x, y),
</equation>
<bodyText confidence="0.9957002">
where rooti is defined as rooti(x) - Vi(x) n
�y: y 11 x. It expresses that x is the root of
tree i. The next interface condition corresponds to
the first rule of the simulated top-down tree trans-
ducer:
</bodyText>
<equation confidence="0.999376666666667">
Vx, y, x1, x2: SWAP(x, y)nlabf(x)n x 11 x1n
x 12 x2 —* labg(y)nly1, y2: y 11 y1ny 12 y2n
COPY(x1, y2) n COPY(x2, y1).
</equation>
<bodyText confidence="0.977756">
In a similar way, the remaining rules are turned
into interface conditions, e.g.,
</bodyText>
<equation confidence="0.999239333333333">
Vx, y, x1, x2: COPY(x, y)nlabf(x)n x 11 x1n
x 12 x2 —* labf(y)nly1, y2: y 11 y1ny 12 y2n
COPY(x1, y1) n COPY(x2, y2).
</equation>
<bodyText confidence="0.9168528">
The reader should easily be able to figure out
the remaining interface conditions required.
One of the elements of L(MS) is shown in Fig-
ure 3. It should not be difficult to see that, indeed,
LM1xM2(MS) = τ.
</bodyText>
<figureCaption confidence="0.990869">
Figure 3: An element of L(MS) in Example 2.
</figureCaption>
<bodyText confidence="0.99957904">
Extending the previous example, one can eas-
ily see that all top-down and bottom-up tree trans-
ductions can be turned into Millstream systems
in a way similar to the construction above. A
similar remark holds for many other types of tree
transductions known from the literature. Most no-
tably, monadic second-order definable tree trans-
ductions (Engelfriet and Maneth, 1999; Engelfriet
and Hoogeboom, 2001; Engelfriet and Maneth,
2003) can be expressed as Millstream systems.
Since the mentioned types of tree transductions
are well studied, and much is known about their
algorithmic properties, future research on Mill-
stream systems should investigate the relation-
ship between different types of tree transductions
and Millstream systems in detail. In particular,
it should be tried to formulate requirements on
the interface conditions that can be used to ob-
tain characterisations of various classes of tree
transductions. We note here that results of this
type would not only be interesting from a purely
mathematical point of view, since tree transduc-
ers have turned out to be a valuable tool in, for
example, machine translation (Knight and Graehl,
2005; May and Knight, 2006; Graehl et al., 2008).
</bodyText>
<sectionHeader confidence="0.894014" genericHeader="method">
7 Preliminary Results and Future Work
</sectionHeader>
<bodyText confidence="0.99880928125">
Millstream systems, as introduced in this article,
are formal devices that allow to model situations
in which several tree-generating modules are inter-
connected by logical interfaces. In a forthcoming
paper (Bensch et al., 2010), we investigate the the-
oretical properties of regular MSO Millstream sys-
tems, i.e., Millstream systems in which the mod-
ules are regular tree grammars and the logic used
is monadic second-order logic. In particular, we
study the so-called completion problem. Given
a Millstream system with k modules and l &lt; k
known trees ti1, ... , til (1 &lt; i1 &lt; · · · &lt; il &lt; k),
the task is to find a completion, i.e., a configura-
tion whose ijth tree is tip for all j E [l]. Thus, if
viewed as a pure decision problem, the completion
problem corresponds to the membership problem
for LMi1x···xMil(MS). To be useful in applica-
tions, algorithms solving the completion problem
should, of course, be required to explicitly con-
struct a completion rather than just answering yes.
Let us briefly summarize the results of (Bensch
et al., 2010).
1. In general, the completion problem is unde-
cidable for k − l &gt; 2 even in the case where
only the use of first-order logic is permitted.
This can be shown by reducing Post’s corre-
spondence problem (PCP) to the emptiness
problem for a regular FO Millstream system
with k = 2. The Millstream system con-
structed is somewhat similar to the one in Ex-
ample 1, as it establishes bijective correspon-
dences between the nodes of two trees (that
</bodyText>
<figure confidence="0.994703">
9
f
a f
SWAP
9
SWAP
a
COPY
SWAP
f
9
a
a
COPY
a a
a a
COPY COPY
</figure>
<page confidence="0.99573">
34
</page>
<bodyText confidence="0.92558444">
represent the two parts of a solution to a PCP
instance).
2. If there are no direct links between unknown
trees (i.e., |{j1, ... , jm} \ {i1, ... , il} |G 1
for each interface symbol I : j1 x · · · x jm),
then the completion problem is solvable for
all regular MSO Millstream systems.
3. Applying some well-known results, the com-
pletion problem is solvable for all regular
MSO Millstream systems for which L(MS)
is of bounded tree width. Thus, it is of inter-
est to establish conditions that guarantee the
configurations in L(MS) to be of bounded
tree width. Two such conditions, are given
in (Bensch et al., 2010). Roughly speaking,
they require that the links respect the struc-
ture of the trees. Let us informally describe
one of them, called nestedness. Say that a
link I&apos;(u1, ... , um) is directly below a link
I(v1, ... , vl) if there are i, j such that uj is
a descendant of vi and none of the nodes in
between carries a link. Now, fix a constant
h. A configuration is nested if the roots are
linked with each other and the following hold
for every link A = I(v1, ... , vl):
</bodyText>
<listItem confidence="0.8801625">
(a) There are at most h links I&apos;(u1, ... , um)
directly below A.
(b) Each of the nodes uj in (a) is a descen-
dant of one of the nodes vi.
</listItem>
<bodyText confidence="0.99998792">
As mentioned above, L(MS) is of bounded
tree width if its configurations are nested
(with respect to the same constant h).
Nestedness, and also the second sufficient con-
dition for bounded tree width studied in (Bensch
et al., 2010) restrict the configurations themselves.
While such conditions may be appropriate in many
practical cases (where one knows what the config-
urations look like), future research should also at-
tempt to find out whether it is possible to put some
easily testable requirements on the interface con-
ditions in order to force the configurations to be
of bounded tree width. Note that, since the prop-
erty of being of tree width at most d is expressible
in monadic second-order logic, one can always ar-
tificially force the configurations of a given MSO
Millstream system to be of bounded tree width, but
this is not very useful as it would simply exclude
those configurations whose tree width is greater
than the desired constant d, thus changing the se-
mantics of the given Millstream system in a usu-
ally undesired manner.
Future work should also investigate properties
that make it possible to obtain or complete config-
urations in a generative way. For example, for reg-
ular MSO Millstream systems with interface con-
ditions of a suitable type, it should be possible to
generate the configurations in L(MS) by generat-
ing the k trees in a parallel top-down manner, at
the same time establishing the interface links. Re-
sults of this kind could also be used for solving
the completion problem in an efficient manner. In
general, it is clear that efficiency must be an im-
portant aspect of future theoretical investigations
into Millstream systems.
In addition to theoretical results, a good imple-
mentation of Millstream systems is needed in or-
der to make it possible to implement nontrivial ex-
amples. While this work should, to the extent pos-
sible, be application independent, it will also be
necessary to seriously attempt to formalise and im-
plement linguistic theories as Millstream systems.
This includes exploring various such theories with
respect to their appropriateness.
To gain further insight into the usefulness and
limitations of Millstream systems for Computa-
tional Linguistics, future work should elaborate if
and how it is possible to translate formalisms such
as HPSG, LFG, CCG, FDG and XDG into Mill-
stream systems.
</bodyText>
<sectionHeader confidence="0.998436" genericHeader="acknowledgments">
Acknowledgments
</sectionHeader>
<bodyText confidence="0.9999774">
We thank Dot and Danie van der Walt for pro-
viding us with a calm and relaxed atmosphere at
Millstream Guest House in Stellenbosch (South
Africa), where the first ideas around Millstream
systems were born in April 2009. Scientifically,
we would like to thank Henrik Bj¨orklund, Stephen
J. Hegner, and Brink van der Merwe for discus-
sions and constructive input. Furthermore, we
would like to thank one of the referees for valu-
able comments.
</bodyText>
<sectionHeader confidence="0.99897" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.695654">
Suna Bensch and Frank Drewes. 2009. Mill-
stream systems. Report UMINF 09.21,
UmeiUniversity. Available at http:
//www8.cs.umu.se/research/uminf/
index.cgi?year=2009&amp;number=21.
</reference>
<page confidence="0.991969">
35
</page>
<reference confidence="0.9999108">
Suna Bensch, Henrik Bj¨orklund, and Frank Drewes.
2010. Algorithmic properties of Millstream sys-
tems. In Sheng Yu, editor, Proc. 14th Intl. Conf.
on Developments in Language Theory (DLT 2010),
Lecture Notes in Computer Science. To appear.
Hubert Comon, Max Dauchet, R´emi Gilleron, Flo-
rent Jacquemard, Christof L¨oding, Denis Lugiez,
Sophie Tison, and Marc Tommasi. 2007. Tree
Automata Techniques and Applications. Internet
publication available at http://tata.gforge.
inria.fr. Release October 2007.
Mary Dalrymple. 2001. Lexical Functional Gram-
mar, volume 34 of Syntax and Semantics. Academic
Press.
Ralph Debusmann and Gert Smolka. 2006. Multi-
dimensional dependency grammar as multigraph de-
scription. In Proceedings of FLAIRS Conference,
pages 740–745.
Ralph Debusmann. 2006. Extensible Dependency
Grammar: A Modular Grammar Formalism Based
On Multigraph Description. Ph.D. thesis, Univer-
sit¨at des Saarlandes. Available at http://www.
ps.uni-sb.de/˜rade/papers/diss.pdf.
Joost Engelfriet and Henrik Jan Hoogeboom. 2001.
MSO definable string transductions and two-way
finite-state transducers. ACM Transactions on Com-
putational Logic, 2:216–254.
Joost Engelfriet and Sebastian Maneth. 1999. Macro
tree transducers, attribute grammars, and MSO de-
finable tree translations. Information and Computa-
tion, 154:34–91.
Joost Engelfriet and Sebastian Maneth. 2003. Macro
tree translations of linear size increase are MSO de-
finable. SIAM Journal on Computing, 32:950–1006.
Zolt´an F¨ul¨op and Heiko Vogler. 1998. Syntax-Directed
Semantics: Formal Models Based on Tree Transduc-
ers. Springer.
Ferenc G´ecseg and Magnus Steinby. 1997. Tree lan-
guages. In G. Rozenberg and A. Salomaa, editors,
Handbook of Formal Languages. Vol. 3: Beyond
Words, chapter 1, pages 1–68. Springer.
Jonathan Graehl, Kevin Knight, and Jonathan May.
2008. Training tree transducers. Computational
Linguistics, 34(3):391–427.
Ray Jackendoff. 2002. Foundations of Language:
Brain, Meaning, Grammar, Evolution. Oxford Uni-
versity Press, Oxford.
Kevin Knight and Jonathan Graehl. 2005. An
overview of probabilistic tree transducers for natural
language processing. In Alexander F. Gelbukh, edi-
tor, Proc. 6th Intl. Conf. on Computational Linguis-
tics and Intelligent Text Processing (CICLing 2005),
volume 3406 of Lecture Notes in Computer Science,
pages 1–24. Springer.
Jonathan May and Kevin Knight. 2006. Tiburon:
A weighted tree automata toolkit. In Oscar H.
Ibarra and Hsu-Chun Yen, editors, Proc. 11th Intl.
Conf. on Implementation and Application of Au-
tomata (CIAA 2006), volume 4094 of Lecture Notes
in Computer Science, pages 102–113. Springer.
Carl Pollard and Ivan Sag. 1994. Head-Driven Phrase
Structure Grammar. Chicago University Press.
Jerrold Sadock. 1991. Autolexical Syntax - A Theory
of Parallel Grammatical Representations. The Uni-
versity of Chicago Press, Chicago &amp; London.
Petr Sgall, Eva Hajiˇcov´a, and Jarmila Panevov´a. 1986.
The meaning of the sentence in its semantic and
pragmatic aspects. Reidel, Dordrecht.
Mark Steedman. 2000. The Syntactic Process (Lan-
guage, Speech, and Communication). MIT Press.
</reference>
<page confidence="0.998943">
36
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.379488">
<title confidence="0.998177">Millstream Systems – a Formal Model for Linking Language Modules by Interfaces</title>
<author confidence="0.910783">Suna</author>
<affiliation confidence="0.9990245">Department of Computing Ume˚a University, Ume˚a,</affiliation>
<email confidence="0.898338">suna@cs.umu.se</email>
<author confidence="0.995502">Frank</author>
<affiliation confidence="0.9985745">Department of Computing Ume˚a University, Ume˚a,</affiliation>
<email confidence="0.977092">drewes@cs.umu.se</email>
<abstract confidence="0.931172416666667">We introduce Millstream systems, a formal model consisting of modules and an interface, where the modules formalise different aspects of language, and the interface links these aspects with each other. 1 Credits This work is partially supported by the project Tree Automata in Computational Language Techthe Sweden – South Africa Research Links Programme. A preliminary but more detailed version of this article is available as a</abstract>
<note confidence="0.632291">technical report (Bensch and Drewes, 2009).</note>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Suna Bensch</author>
<author>Frank Drewes</author>
</authors>
<title>Millstream systems.</title>
<date>2009</date>
<tech>Report UMINF 09.21,</tech>
<note>UmeiUniversity. Available at http: //www8.cs.umu.se/research/uminf/ index.cgi?year=2009&amp;number=21.</note>
<contexts>
<context position="761" citStr="Bensch and Drewes, 2009" startWordPosition="109" endWordPosition="112">ity, Ume˚a, Sweden suna@cs.umu.se Frank Drewes Department of Computing Science, Ume˚a University, Ume˚a, Sweden drewes@cs.umu.se Abstract We introduce Millstream systems, a formal model consisting of modules and an interface, where the modules formalise different aspects of language, and the interface links these aspects with each other. 1 Credits This work is partially supported by the project Tree Automata in Computational Language Technology within the Sweden – South Africa Research Links Programme. A preliminary but more detailed version of this article is available as a technical report (Bensch and Drewes, 2009). 2 Introduction Modern linguistic theories (Sadock, 1991; Jackendoff, 2002) promote the view that different aspects of language, such as phonology, morphology, syntax, and semantics should be viewed as autonomous modules that work simultaneously and are linked with each other by interfaces that describe their interaction and interdependency. Formalisms in modern computational linguistics which establish interfaces between different aspects of language are the Combinatory Categorical Grammar (CCG), the Functional Generative Description (FGD), the Head-Driven Phrase Structure Grammar (HPSG), th</context>
<context position="12628" citStr="Bensch and Drewes, 2009" startWordPosition="2063" endWordPosition="2066"> we write 5*. As usual, A1 x · · · x Ak denotes the Cartesian product of sets A1, ... , Ak. The transitive and reflexive closure of a binary relation ==&gt;. C_ A x A on a set A is denoted by ==&gt;.*. A ranked alphabet is a finite set E of pairs (f, k), where f is a symbol and k E N is its rank. We denote (f, k) by f(k), or simply by f if k is understood or of lesser importance. Further, we let E(k) = If(n) E EI n = k}. We define trees over E in one of the standard ways, by identifying the nodes of a tree t with sequences of natural numbers. Intuitively, such a sequence 2The reader is referred to (Bensch and Drewes, 2009) for the proper formalisation of the example in terms of a Millstream system. (a) s w1 w2 w5 Morphophonology w3 cl4 Segmental structure me@ri lack s pit@r 1 gent peterpatient mary NP5 pressituation 4 likestate 3 NP1 VP V2 V3 infl4 30 shows that path from the root of the tree to the node in question. In particular, the root is the empty sequence E. Formally, the set TΣ of trees over E consists of all mappings t: V (t) → E (called trees) with the following properties: • The set V (t) of nodes oft is a finite and nonempty prefix-closed subset of N∗+. Thus, for every node vi ∈ V (t) (where i ∈ N+)</context>
</contexts>
<marker>Bensch, Drewes, 2009</marker>
<rawString>Suna Bensch and Frank Drewes. 2009. Millstream systems. Report UMINF 09.21, UmeiUniversity. Available at http: //www8.cs.umu.se/research/uminf/ index.cgi?year=2009&amp;number=21.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Suna Bensch</author>
<author>Henrik Bj¨orklund</author>
<author>Frank Drewes</author>
</authors>
<title>Algorithmic properties of Millstream systems.</title>
<date>2010</date>
<booktitle>Proc. 14th Intl. Conf. on Developments in Language Theory (DLT 2010), Lecture Notes in Computer Science.</booktitle>
<editor>In Sheng Yu, editor,</editor>
<note>To appear.</note>
<marker>Bensch, Bj¨orklund, Drewes, 2010</marker>
<rawString>Suna Bensch, Henrik Bj¨orklund, and Frank Drewes. 2010. Algorithmic properties of Millstream systems. In Sheng Yu, editor, Proc. 14th Intl. Conf. on Developments in Language Theory (DLT 2010), Lecture Notes in Computer Science. To appear.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Hubert Comon</author>
<author>Max Dauchet</author>
</authors>
<title>R´emi Gilleron, Florent Jacquemard, Christof L¨oding, Denis Lugiez, Sophie Tison, and Marc Tommasi.</title>
<date>2007</date>
<marker>Comon, Dauchet, 2007</marker>
<rawString>Hubert Comon, Max Dauchet, R´emi Gilleron, Florent Jacquemard, Christof L¨oding, Denis Lugiez, Sophie Tison, and Marc Tommasi. 2007. Tree Automata Techniques and Applications. Internet publication available at http://tata.gforge. inria.fr. Release October 2007.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Mary Dalrymple</author>
</authors>
<title>Lexical Functional Grammar,</title>
<date>2001</date>
<volume>34</volume>
<publisher>Academic Press.</publisher>
<contexts>
<context position="1804" citStr="Dalrymple, 2001" startWordPosition="265" endWordPosition="266">ifferent aspects of language are the Combinatory Categorical Grammar (CCG), the Functional Generative Description (FGD), the Head-Driven Phrase Structure Grammar (HPSG), the Lexical Functional Grammar (LFG), and the Extensible Dependency Grammar (XDG).1 Here, we propose Millstream systems, an approach from a formal language theoretic point of view which is based on the same ideas as XDG, but uses tree-generating modules of arbitrary kinds. Let us explain in slightly more detail what a Millstream system looks like. A Millstream system contains any number of tree generators, called 1See, e.g., (Dalrymple, 2001; Sgall et al., 1986; Pollard and Sag, 1994; Steedman, 2000; Debusmann, 2006; Debusmann and Smolka, 2006). its modules. Such a tree generator is any device that specifies a tree language. For example, a tree generator may be a context-free grammar, tree adjoining grammar, a finite-state tree automaton, a dependency grammar, a corpus, human input, etc. Even within a single Millstream system, the modules need not be of the same kind, since they are treated as “black boxes”. The Millstream system links the trees generated by the modules by an interface consisting of logical formulas. Suppose that</context>
</contexts>
<marker>Dalrymple, 2001</marker>
<rawString>Mary Dalrymple. 2001. Lexical Functional Grammar, volume 34 of Syntax and Semantics. Academic Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ralph Debusmann</author>
<author>Gert Smolka</author>
</authors>
<title>Multidimensional dependency grammar as multigraph description.</title>
<date>2006</date>
<booktitle>In Proceedings of FLAIRS Conference,</booktitle>
<pages>740--745</pages>
<contexts>
<context position="1909" citStr="Debusmann and Smolka, 2006" startWordPosition="279" endWordPosition="283">nerative Description (FGD), the Head-Driven Phrase Structure Grammar (HPSG), the Lexical Functional Grammar (LFG), and the Extensible Dependency Grammar (XDG).1 Here, we propose Millstream systems, an approach from a formal language theoretic point of view which is based on the same ideas as XDG, but uses tree-generating modules of arbitrary kinds. Let us explain in slightly more detail what a Millstream system looks like. A Millstream system contains any number of tree generators, called 1See, e.g., (Dalrymple, 2001; Sgall et al., 1986; Pollard and Sag, 1994; Steedman, 2000; Debusmann, 2006; Debusmann and Smolka, 2006). its modules. Such a tree generator is any device that specifies a tree language. For example, a tree generator may be a context-free grammar, tree adjoining grammar, a finite-state tree automaton, a dependency grammar, a corpus, human input, etc. Even within a single Millstream system, the modules need not be of the same kind, since they are treated as “black boxes”. The Millstream system links the trees generated by the modules by an interface consisting of logical formulas. Suppose that a Millstream system has k modules. Then the interface consists of interface rules in the form of logical</context>
</contexts>
<marker>Debusmann, Smolka, 2006</marker>
<rawString>Ralph Debusmann and Gert Smolka. 2006. Multidimensional dependency grammar as multigraph description. In Proceedings of FLAIRS Conference, pages 740–745.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ralph Debusmann</author>
</authors>
<title>Extensible Dependency Grammar: A Modular Grammar Formalism Based On Multigraph Description. Ph.D. thesis, Universit¨at des Saarlandes. Available at http://www.</title>
<date>2006</date>
<pages>ps.uni-sb.de/˜rade/papers/diss.pdf.</pages>
<contexts>
<context position="1880" citStr="Debusmann, 2006" startWordPosition="277" endWordPosition="278">the Functional Generative Description (FGD), the Head-Driven Phrase Structure Grammar (HPSG), the Lexical Functional Grammar (LFG), and the Extensible Dependency Grammar (XDG).1 Here, we propose Millstream systems, an approach from a formal language theoretic point of view which is based on the same ideas as XDG, but uses tree-generating modules of arbitrary kinds. Let us explain in slightly more detail what a Millstream system looks like. A Millstream system contains any number of tree generators, called 1See, e.g., (Dalrymple, 2001; Sgall et al., 1986; Pollard and Sag, 1994; Steedman, 2000; Debusmann, 2006; Debusmann and Smolka, 2006). its modules. Such a tree generator is any device that specifies a tree language. For example, a tree generator may be a context-free grammar, tree adjoining grammar, a finite-state tree automaton, a dependency grammar, a corpus, human input, etc. Even within a single Millstream system, the modules need not be of the same kind, since they are treated as “black boxes”. The Millstream system links the trees generated by the modules by an interface consisting of logical formulas. Suppose that a Millstream system has k modules. Then the interface consists of interface</context>
</contexts>
<marker>Debusmann, 2006</marker>
<rawString>Ralph Debusmann. 2006. Extensible Dependency Grammar: A Modular Grammar Formalism Based On Multigraph Description. Ph.D. thesis, Universit¨at des Saarlandes. Available at http://www. ps.uni-sb.de/˜rade/papers/diss.pdf.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Joost Engelfriet</author>
<author>Henrik Jan Hoogeboom</author>
</authors>
<title>MSO definable string transductions and two-way finite-state transducers.</title>
<date>2001</date>
<journal>ACM Transactions on Computational Logic,</journal>
<pages>2--216</pages>
<contexts>
<context position="27160" citStr="Engelfriet and Hoogeboom, 2001" startWordPosition="4946" endWordPosition="4949">ly be able to figure out the remaining interface conditions required. One of the elements of L(MS) is shown in Figure 3. It should not be difficult to see that, indeed, LM1xM2(MS) = τ. Figure 3: An element of L(MS) in Example 2. Extending the previous example, one can easily see that all top-down and bottom-up tree transductions can be turned into Millstream systems in a way similar to the construction above. A similar remark holds for many other types of tree transductions known from the literature. Most notably, monadic second-order definable tree transductions (Engelfriet and Maneth, 1999; Engelfriet and Hoogeboom, 2001; Engelfriet and Maneth, 2003) can be expressed as Millstream systems. Since the mentioned types of tree transductions are well studied, and much is known about their algorithmic properties, future research on Millstream systems should investigate the relationship between different types of tree transductions and Millstream systems in detail. In particular, it should be tried to formulate requirements on the interface conditions that can be used to obtain characterisations of various classes of tree transductions. We note here that results of this type would not only be interesting from a pure</context>
</contexts>
<marker>Engelfriet, Hoogeboom, 2001</marker>
<rawString>Joost Engelfriet and Henrik Jan Hoogeboom. 2001. MSO definable string transductions and two-way finite-state transducers. ACM Transactions on Computational Logic, 2:216–254.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Joost Engelfriet</author>
<author>Sebastian Maneth</author>
</authors>
<title>Macro tree transducers, attribute grammars, and MSO definable tree translations.</title>
<date>1999</date>
<journal>Information and Computation,</journal>
<pages>154--34</pages>
<contexts>
<context position="27128" citStr="Engelfriet and Maneth, 1999" startWordPosition="4942" endWordPosition="4945">, y2). The reader should easily be able to figure out the remaining interface conditions required. One of the elements of L(MS) is shown in Figure 3. It should not be difficult to see that, indeed, LM1xM2(MS) = τ. Figure 3: An element of L(MS) in Example 2. Extending the previous example, one can easily see that all top-down and bottom-up tree transductions can be turned into Millstream systems in a way similar to the construction above. A similar remark holds for many other types of tree transductions known from the literature. Most notably, monadic second-order definable tree transductions (Engelfriet and Maneth, 1999; Engelfriet and Hoogeboom, 2001; Engelfriet and Maneth, 2003) can be expressed as Millstream systems. Since the mentioned types of tree transductions are well studied, and much is known about their algorithmic properties, future research on Millstream systems should investigate the relationship between different types of tree transductions and Millstream systems in detail. In particular, it should be tried to formulate requirements on the interface conditions that can be used to obtain characterisations of various classes of tree transductions. We note here that results of this type would not</context>
</contexts>
<marker>Engelfriet, Maneth, 1999</marker>
<rawString>Joost Engelfriet and Sebastian Maneth. 1999. Macro tree transducers, attribute grammars, and MSO definable tree translations. Information and Computation, 154:34–91.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Joost Engelfriet</author>
<author>Sebastian Maneth</author>
</authors>
<title>Macro tree translations of linear size increase are MSO definable.</title>
<date>2003</date>
<journal>SIAM Journal on Computing,</journal>
<pages>32--950</pages>
<contexts>
<context position="27190" citStr="Engelfriet and Maneth, 2003" startWordPosition="4950" endWordPosition="4953">aining interface conditions required. One of the elements of L(MS) is shown in Figure 3. It should not be difficult to see that, indeed, LM1xM2(MS) = τ. Figure 3: An element of L(MS) in Example 2. Extending the previous example, one can easily see that all top-down and bottom-up tree transductions can be turned into Millstream systems in a way similar to the construction above. A similar remark holds for many other types of tree transductions known from the literature. Most notably, monadic second-order definable tree transductions (Engelfriet and Maneth, 1999; Engelfriet and Hoogeboom, 2001; Engelfriet and Maneth, 2003) can be expressed as Millstream systems. Since the mentioned types of tree transductions are well studied, and much is known about their algorithmic properties, future research on Millstream systems should investigate the relationship between different types of tree transductions and Millstream systems in detail. In particular, it should be tried to formulate requirements on the interface conditions that can be used to obtain characterisations of various classes of tree transductions. We note here that results of this type would not only be interesting from a purely mathematical point of view,</context>
</contexts>
<marker>Engelfriet, Maneth, 2003</marker>
<rawString>Joost Engelfriet and Sebastian Maneth. 2003. Macro tree translations of linear size increase are MSO definable. SIAM Journal on Computing, 32:950–1006.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Zolt´an F¨ul¨op</author>
<author>Heiko Vogler</author>
</authors>
<title>Syntax-Directed Semantics: Formal Models Based on Tree Transducers.</title>
<date>1998</date>
<publisher>Springer.</publisher>
<marker>F¨ul¨op, Vogler, 1998</marker>
<rawString>Zolt´an F¨ul¨op and Heiko Vogler. 1998. Syntax-Directed Semantics: Formal Models Based on Tree Transducers. Springer.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ferenc G´ecseg</author>
<author>Magnus Steinby</author>
</authors>
<title>Tree languages.</title>
<date>1997</date>
<booktitle>Handbook of Formal Languages. Vol. 3: Beyond Words, chapter 1,</booktitle>
<pages>1--68</pages>
<editor>In G. Rozenberg and A. Salomaa, editors,</editor>
<publisher>Springer.</publisher>
<marker>G´ecseg, Steinby, 1997</marker>
<rawString>Ferenc G´ecseg and Magnus Steinby. 1997. Tree languages. In G. Rozenberg and A. Salomaa, editors, Handbook of Formal Languages. Vol. 3: Beyond Words, chapter 1, pages 1–68. Springer.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jonathan Graehl</author>
<author>Kevin Knight</author>
<author>Jonathan May</author>
</authors>
<title>Training tree transducers.</title>
<date>2008</date>
<journal>Computational Linguistics,</journal>
<volume>34</volume>
<issue>3</issue>
<contexts>
<context position="27957" citStr="Graehl et al., 2008" startWordPosition="5072" endWordPosition="5075">c properties, future research on Millstream systems should investigate the relationship between different types of tree transductions and Millstream systems in detail. In particular, it should be tried to formulate requirements on the interface conditions that can be used to obtain characterisations of various classes of tree transductions. We note here that results of this type would not only be interesting from a purely mathematical point of view, since tree transducers have turned out to be a valuable tool in, for example, machine translation (Knight and Graehl, 2005; May and Knight, 2006; Graehl et al., 2008). 7 Preliminary Results and Future Work Millstream systems, as introduced in this article, are formal devices that allow to model situations in which several tree-generating modules are interconnected by logical interfaces. In a forthcoming paper (Bensch et al., 2010), we investigate the theoretical properties of regular MSO Millstream systems, i.e., Millstream systems in which the modules are regular tree grammars and the logic used is monadic second-order logic. In particular, we study the so-called completion problem. Given a Millstream system with k modules and l &lt; k known trees ti1, ... ,</context>
</contexts>
<marker>Graehl, Knight, May, 2008</marker>
<rawString>Jonathan Graehl, Kevin Knight, and Jonathan May. 2008. Training tree transducers. Computational Linguistics, 34(3):391–427.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ray Jackendoff</author>
</authors>
<title>Foundations of Language: Brain, Meaning, Grammar, Evolution.</title>
<date>2002</date>
<publisher>Oxford University Press,</publisher>
<location>Oxford.</location>
<contexts>
<context position="837" citStr="Jackendoff, 2002" startWordPosition="120" endWordPosition="122">˚a University, Ume˚a, Sweden drewes@cs.umu.se Abstract We introduce Millstream systems, a formal model consisting of modules and an interface, where the modules formalise different aspects of language, and the interface links these aspects with each other. 1 Credits This work is partially supported by the project Tree Automata in Computational Language Technology within the Sweden – South Africa Research Links Programme. A preliminary but more detailed version of this article is available as a technical report (Bensch and Drewes, 2009). 2 Introduction Modern linguistic theories (Sadock, 1991; Jackendoff, 2002) promote the view that different aspects of language, such as phonology, morphology, syntax, and semantics should be viewed as autonomous modules that work simultaneously and are linked with each other by interfaces that describe their interaction and interdependency. Formalisms in modern computational linguistics which establish interfaces between different aspects of language are the Combinatory Categorical Grammar (CCG), the Functional Generative Description (FGD), the Head-Driven Phrase Structure Grammar (HPSG), the Lexical Functional Grammar (LFG), and the Extensible Dependency Grammar (X</context>
<context position="9043" citStr="Jackendoff, 2002" startWordPosition="1435" endWordPosition="1436">milarities and differences. The rest of the paper is organised as follows. In the next section, we discuss an example illustrating the linguistic notions and ideas that Millstream systems attempt to provide a formal basis for. After some mathematical preliminaries, which 29 are collected in Section 4, the formal definition of Millstream systems is presented in Section 5. Section 6 contains examples and remarks related to Formal Language Theory. Finally, Section 7 discusses preliminary results and future work. 3 Linguistical Background In this section, we discuss an example, roughly following (Jackendoff, 2002), that illustrates the linguistic ideas that have motivated our approach. Figure 1 shows the phonological, syntactical and semantical structure, depicted as trees (a), (b) and (c), respectively of the sentence Mary likes Peter. Trees are defined formally in the next section, for the time being we assume the reader to be familiar with the general notion of a tree as used in linguistics and computer science. (b) (c) s S Figure 1: Phonological, syntactical and semantical structure of Mary likes Peter. The segmental structure in the phonological tree (a) is the basic pronunciation of the sentence </context>
</contexts>
<marker>Jackendoff, 2002</marker>
<rawString>Ray Jackendoff. 2002. Foundations of Language: Brain, Meaning, Grammar, Evolution. Oxford University Press, Oxford.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kevin Knight</author>
<author>Jonathan Graehl</author>
</authors>
<title>An overview of probabilistic tree transducers for natural language processing.</title>
<date>2005</date>
<booktitle>Proc. 6th Intl. Conf. on Computational Linguistics and Intelligent Text Processing (CICLing 2005),</booktitle>
<volume>3406</volume>
<pages>1--24</pages>
<editor>In Alexander F. Gelbukh, editor,</editor>
<publisher>Springer.</publisher>
<contexts>
<context position="27913" citStr="Knight and Graehl, 2005" startWordPosition="5064" endWordPosition="5067">udied, and much is known about their algorithmic properties, future research on Millstream systems should investigate the relationship between different types of tree transductions and Millstream systems in detail. In particular, it should be tried to formulate requirements on the interface conditions that can be used to obtain characterisations of various classes of tree transductions. We note here that results of this type would not only be interesting from a purely mathematical point of view, since tree transducers have turned out to be a valuable tool in, for example, machine translation (Knight and Graehl, 2005; May and Knight, 2006; Graehl et al., 2008). 7 Preliminary Results and Future Work Millstream systems, as introduced in this article, are formal devices that allow to model situations in which several tree-generating modules are interconnected by logical interfaces. In a forthcoming paper (Bensch et al., 2010), we investigate the theoretical properties of regular MSO Millstream systems, i.e., Millstream systems in which the modules are regular tree grammars and the logic used is monadic second-order logic. In particular, we study the so-called completion problem. Given a Millstream system wit</context>
</contexts>
<marker>Knight, Graehl, 2005</marker>
<rawString>Kevin Knight and Jonathan Graehl. 2005. An overview of probabilistic tree transducers for natural language processing. In Alexander F. Gelbukh, editor, Proc. 6th Intl. Conf. on Computational Linguistics and Intelligent Text Processing (CICLing 2005), volume 3406 of Lecture Notes in Computer Science, pages 1–24. Springer.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jonathan May</author>
<author>Kevin Knight</author>
</authors>
<title>Tiburon: A weighted tree automata toolkit.</title>
<date>2006</date>
<booktitle>Proc. 11th Intl. Conf. on Implementation and Application of Automata (CIAA</booktitle>
<volume>4094</volume>
<pages>102--113</pages>
<editor>In Oscar H. Ibarra and Hsu-Chun Yen, editors,</editor>
<publisher>Springer.</publisher>
<contexts>
<context position="27935" citStr="May and Knight, 2006" startWordPosition="5068" endWordPosition="5071">about their algorithmic properties, future research on Millstream systems should investigate the relationship between different types of tree transductions and Millstream systems in detail. In particular, it should be tried to formulate requirements on the interface conditions that can be used to obtain characterisations of various classes of tree transductions. We note here that results of this type would not only be interesting from a purely mathematical point of view, since tree transducers have turned out to be a valuable tool in, for example, machine translation (Knight and Graehl, 2005; May and Knight, 2006; Graehl et al., 2008). 7 Preliminary Results and Future Work Millstream systems, as introduced in this article, are formal devices that allow to model situations in which several tree-generating modules are interconnected by logical interfaces. In a forthcoming paper (Bensch et al., 2010), we investigate the theoretical properties of regular MSO Millstream systems, i.e., Millstream systems in which the modules are regular tree grammars and the logic used is monadic second-order logic. In particular, we study the so-called completion problem. Given a Millstream system with k modules and l &lt; k </context>
</contexts>
<marker>May, Knight, 2006</marker>
<rawString>Jonathan May and Kevin Knight. 2006. Tiburon: A weighted tree automata toolkit. In Oscar H. Ibarra and Hsu-Chun Yen, editors, Proc. 11th Intl. Conf. on Implementation and Application of Automata (CIAA 2006), volume 4094 of Lecture Notes in Computer Science, pages 102–113. Springer.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Carl Pollard</author>
<author>Ivan Sag</author>
</authors>
<title>Head-Driven Phrase Structure Grammar.</title>
<date>1994</date>
<publisher>Chicago University Press.</publisher>
<contexts>
<context position="1847" citStr="Pollard and Sag, 1994" startWordPosition="271" endWordPosition="274">Combinatory Categorical Grammar (CCG), the Functional Generative Description (FGD), the Head-Driven Phrase Structure Grammar (HPSG), the Lexical Functional Grammar (LFG), and the Extensible Dependency Grammar (XDG).1 Here, we propose Millstream systems, an approach from a formal language theoretic point of view which is based on the same ideas as XDG, but uses tree-generating modules of arbitrary kinds. Let us explain in slightly more detail what a Millstream system looks like. A Millstream system contains any number of tree generators, called 1See, e.g., (Dalrymple, 2001; Sgall et al., 1986; Pollard and Sag, 1994; Steedman, 2000; Debusmann, 2006; Debusmann and Smolka, 2006). its modules. Such a tree generator is any device that specifies a tree language. For example, a tree generator may be a context-free grammar, tree adjoining grammar, a finite-state tree automaton, a dependency grammar, a corpus, human input, etc. Even within a single Millstream system, the modules need not be of the same kind, since they are treated as “black boxes”. The Millstream system links the trees generated by the modules by an interface consisting of logical formulas. Suppose that a Millstream system has k modules. Then th</context>
</contexts>
<marker>Pollard, Sag, 1994</marker>
<rawString>Carl Pollard and Ivan Sag. 1994. Head-Driven Phrase Structure Grammar. Chicago University Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jerrold Sadock</author>
</authors>
<title>Autolexical Syntax - A Theory of Parallel Grammatical Representations.</title>
<date>1991</date>
<publisher>The University of Chicago Press,</publisher>
<location>Chicago &amp; London.</location>
<contexts>
<context position="818" citStr="Sadock, 1991" startWordPosition="118" endWordPosition="119">g Science, Ume˚a University, Ume˚a, Sweden drewes@cs.umu.se Abstract We introduce Millstream systems, a formal model consisting of modules and an interface, where the modules formalise different aspects of language, and the interface links these aspects with each other. 1 Credits This work is partially supported by the project Tree Automata in Computational Language Technology within the Sweden – South Africa Research Links Programme. A preliminary but more detailed version of this article is available as a technical report (Bensch and Drewes, 2009). 2 Introduction Modern linguistic theories (Sadock, 1991; Jackendoff, 2002) promote the view that different aspects of language, such as phonology, morphology, syntax, and semantics should be viewed as autonomous modules that work simultaneously and are linked with each other by interfaces that describe their interaction and interdependency. Formalisms in modern computational linguistics which establish interfaces between different aspects of language are the Combinatory Categorical Grammar (CCG), the Functional Generative Description (FGD), the Head-Driven Phrase Structure Grammar (HPSG), the Lexical Functional Grammar (LFG), and the Extensible De</context>
</contexts>
<marker>Sadock, 1991</marker>
<rawString>Jerrold Sadock. 1991. Autolexical Syntax - A Theory of Parallel Grammatical Representations. The University of Chicago Press, Chicago &amp; London.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Petr Sgall</author>
<author>Eva Hajiˇcov´a</author>
<author>Jarmila Panevov´a</author>
</authors>
<title>The meaning of the sentence in its semantic and pragmatic aspects.</title>
<date>1986</date>
<location>Reidel, Dordrecht.</location>
<marker>Sgall, Hajiˇcov´a, Panevov´a, 1986</marker>
<rawString>Petr Sgall, Eva Hajiˇcov´a, and Jarmila Panevov´a. 1986. The meaning of the sentence in its semantic and pragmatic aspects. Reidel, Dordrecht.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Mark Steedman</author>
</authors>
<title>The Syntactic Process (Language, Speech, and Communication).</title>
<date>2000</date>
<publisher>MIT Press.</publisher>
<contexts>
<context position="1863" citStr="Steedman, 2000" startWordPosition="275" endWordPosition="276"> Grammar (CCG), the Functional Generative Description (FGD), the Head-Driven Phrase Structure Grammar (HPSG), the Lexical Functional Grammar (LFG), and the Extensible Dependency Grammar (XDG).1 Here, we propose Millstream systems, an approach from a formal language theoretic point of view which is based on the same ideas as XDG, but uses tree-generating modules of arbitrary kinds. Let us explain in slightly more detail what a Millstream system looks like. A Millstream system contains any number of tree generators, called 1See, e.g., (Dalrymple, 2001; Sgall et al., 1986; Pollard and Sag, 1994; Steedman, 2000; Debusmann, 2006; Debusmann and Smolka, 2006). its modules. Such a tree generator is any device that specifies a tree language. For example, a tree generator may be a context-free grammar, tree adjoining grammar, a finite-state tree automaton, a dependency grammar, a corpus, human input, etc. Even within a single Millstream system, the modules need not be of the same kind, since they are treated as “black boxes”. The Millstream system links the trees generated by the modules by an interface consisting of logical formulas. Suppose that a Millstream system has k modules. Then the interface cons</context>
</contexts>
<marker>Steedman, 2000</marker>
<rawString>Mark Steedman. 2000. The Syntactic Process (Language, Speech, and Communication). MIT Press.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>