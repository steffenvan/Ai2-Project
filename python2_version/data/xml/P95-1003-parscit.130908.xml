<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<title confidence="0.9595695">
The Replace Operator
Lauri Karttunen
</title>
<note confidence="0.672133666666667">
Rank Xerox Research Centre
6, chemin de Maupertuis
F-38240 Meylan, France
</note>
<email confidence="0.935293">
lauri.karttunen@xerox.fr
</email>
<sectionHeader confidence="0.992623" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999900636363636">
This paper introduces to the calculus of
regular expressions a replace operator and
defines a set of replacement expressions
that concisely encode alternate variations
of the operation. Replace expressions de-
note regular relations, defined in terms of
other regular expression operators. The
basic case is unconditional obligatory re-
placement. We develop several versions of
conditional replacement that allow the op-
eration to be constrained by context
</bodyText>
<sectionHeader confidence="0.994496" genericHeader="introduction">
0. Introduction
</sectionHeader>
<bodyText confidence="0.98613364516129">
Linguistic descriptions in phonology, morphology,
and syntax typically make use of an operation that
replaces some symbol or sequence of symbols by
another sequence or symbol. We consider here the
replacement operation in the context of finite-state
grammars.
Our purpose in this paper is twofold. One is to
define replacement in a very general way, explicitly
allowing replacement to be constrained by input
and output contexts, as in two-level rules
(Koskenniemi 1983), but without the restriction of
only single-symbol replacements. The second ob-
jective is to define replacement within a general
calculus of regular expressions so that replace-
ments can be conveniently combined with other
kinds of operations, such as composition and un-
ion, to form complex expressions.
Our replacement operators are close relatives of the
rewrite-operator defined in Kaplan and Kay 1994,
but they are not identical to it. We discuss their
relationship in a section at the end of the paper.
O. 1. Simple regular expressions
The replacement operators are defined by means of
regular expressions. Some of the operators we use
to define them are specific to Xerox implementa-
tions of the finite-state calculus, but equivalent
formulations could easily be found in other nota-
tions.
The table below describes the types of expressions
and special symbols that are used to define the
replacement operators.
</bodyText>
<figure confidence="0.772383470588235">
(A) option (union of A with the
empty string)
-A complement (negation)
\A term complement (any symbol
other than A)
$A contains (all strings containing at
least one A)
A* Kleene star
A+ Kleene plus
A/B ignore (A interspersed with
strings from B)
AB concatenation
AIB union
A&amp; B intersection
A- B relative complement (minus)
A .x. B crossproduct (Cartesian product)
A .o. B composition
</figure>
<bodyText confidence="0.985762733333333">
Square brackets, [ ], are used for grouping expres-
sions. Thus [A] is equivalent to A while (A) is not.
The order in the above table corresponds to the
precedence of the operations. The prefix operators
( , , and $ ) bind more tightly than the postfix
operators (*, +, and /), which in turn rank above
concatenation. Union, intersection, and relative
complement are considered weaker than concate-
nation but stronger than crossproduct and compo-
sition. Operators sharing the same precedence are
interpreted left-to-right. Our new replacement
operator goes in a class between the Boolean op-
erators and composition. Taking advantage of all
these conventions, the fully bracketed expression
[ [ [ [ a]]* [ [b] /x] ] I c] .x. d ;
</bodyText>
<page confidence="0.994784">
16
</page>
<bodyText confidence="0.991691723404255">
can be rewritten more concisely as
-a* b/x I c .x. d
Expressions that contain the crossproduct ( . x .) or
the composition ( . o . ) operator describe regular
relations rather than regular languages. A regular
relation is a mapping from one regular language to
another one. Regular languages correspond to
simple finite-state automata; regular relations are
modeled by finite-state transducers. In the relation
A .x. B, we call the first member, A, the upper
language and the second member, B, the lower lan-
guage.
To make the notation less cumbersome, we sys-
tematically ignore the distinction between the lan-
guage A and the identity relation that maps every
string of A to itself. Correspondingly, a simple au-
tomaton may be thought of as representing a lan-
guage or as a transducer for its identity relation.
For the sake of convenience, we also equate a lan-
guage consisting of a single string with the string
itself. Thus the expression abc may denote, de-
pending on the context, (i) the string abc, (ii) the
language consisting of the string abc, and (iii) the
identity relation on that language.
We recognize two kinds of symbols: simple sym-
bols (a, b, c, etc.) and fst pairs (a :b, y: z, etc.). An
fst pair a :b can be thought of as the crossproduct
of a and b, the minimal relation consisting of a (the
upper symbol) and b (the lower symbol). Because
we regard the identity relation on A as equivalent
to A, we write a : a as just a. There are two special
symbols
0 epsilon (the empty string).
any symbol in the known alphabet and its
extensions.
The escape character, %, allows letters that have a
special meaning in the calculus to be used as ordi-
nary symbols. Thus %&amp; denotes a literal ampersand
as opposed to &amp;, the intersection operator; %O is the
ordinary zero symbol.
The following simple expressions appear fre-
quently in our formulas:
H the empty string language.
-$ [] the null set.
the universal (&amp;quot;sigma-star&amp;quot;) language: all
possible strings of any length induding the
empty string.
</bodyText>
<sectionHeader confidence="0.822001" genericHeader="method">
1. Unconditional replacement
</sectionHeader>
<bodyText confidence="0.98776375">
To the regular-expression language described
above, we add the new replacement operator. The
unconditional replacement of UPPER by LOWER is
written
</bodyText>
<sectionHeader confidence="0.643458" genericHeader="method">
UPPER -&gt; LOWER
</sectionHeader>
<bodyText confidence="0.999910666666667">
Here UPPER and LOWER are any regular expres-
sions that describe simple regular languages. We
define this replacement expression as
</bodyText>
<equation confidence="0.987198">
NO_UPPER [UPPER .x. LOWER] ]*
NO_UPPER ;
</equation>
<bodyText confidence="0.999442333333333">
where NO_UPPER abbreviates -$ [UPPER - [ ] ].
The definition describes a regular relation whose
members contain any number (including zero) of
iterations of RIPPER .x. LOWER], possibly alter-
nating with strings not containing UPPER that are
mapped to themselves.
</bodyText>
<subsectionHeader confidence="0.954909">
1.1. Examples
</subsectionHeader>
<bodyText confidence="0.998991333333333">
We illustrate the meaning of the replacement op-
erator with a few simple examples. The regular
expression
</bodyText>
<equation confidence="0.650100666666667">
[8]
ab lc -&gt; x ;
(same as [ [a b] I c] -&gt;
</equation>
<bodyText confidence="0.842530428571429">
describes a relation consisting of an infinite set of
pairs such as
abaca
x a x a
where all occurrences of ab and c are mapped to x
interspersed with unchanging pairings. It also in-
cludes all possible pairs like
</bodyText>
<figure confidence="0.4628345">
[10]
xaxa
xaxa
that do not contain either ab or c anywhere.
</figure>
<figureCaption confidence="0.433178666666667">
Figure 1 shows the state diagram of a transducer
that encodes this relation. The transducer consists
of states and arcs that indicate a transition from
</figureCaption>
<figure confidence="0.834392">
?*
[3]
</figure>
<page confidence="0.986448">
17
</page>
<bodyText confidence="0.920979545454545">
state to state over a given pair of symbols. For con-
venience we represent identity pairs by a single
symbol; for example, we write a : a as a. The sym-
bol? represents here the identity pairs of symbols
that are not explicitly present in the network. In
this case, ? stands for any identity pair other than
a : a, b :b, c : c, and x : x. Transitions that differ
only with respect to the label are collapsed into a
single multiply labelled arc. The state labeled 0 is
the start state. Final states are distinguished by a
double circle.
</bodyText>
<figureCaption confidence="0.998967">
Figure 1: ab I c -&gt; x
</figureCaption>
<bodyText confidence="0.984324714285714">
Every pair of strings in the relation corresponds to
a path from the initial 0 state of the transducer to a
final state. The abaca to xaxa path is 0-1-0-2-
0-2, where the 2-0 transition is over a c : x arc.
In case a given input string matches the replace-
ment relation in two ways, two outputs are pro-
duced. For example,
</bodyText>
<figure confidence="0.7896885">
[11]
ablbc-&gt;x ;
</figure>
<figureCaption confidence="0.991384">
Figure 2: ab I bc -&gt; x
</figureCaption>
<bodyText confidence="0.999791625">
The corresponding transducer paths in Figure 2 are
0-1-3-0 and 0-2-0-0, where the last 0-0 transi-
tion is over a c arc.
If this ambiguity is not desirable, we may write
two replacement expressions and compose them to
indicate which replacement should be preferred if a
choice has to be made. For example, if the ab match
should have precedence, we write
</bodyText>
<figure confidence="0.99774175">
[13]
a b -&gt; x
.0.
b c -&gt; x ;
</figure>
<figureCaption confidence="0.999759">
Figure 3: a b -&gt; x .o. b c -&gt; x
</figureCaption>
<bodyText confidence="0.9998676">
This composite relation produces the same output
as the previous one except for strings like abc
where it unambiguously makes only the first re-
placement, giving xc as the output. The abc to xc
path in Figure 3 is 0-2-0-0.
</bodyText>
<subsectionHeader confidence="0.960578">
1.2. Special cases
</subsectionHeader>
<bodyText confidence="0.846455142857143">
Let us illustrate the meaning of the replacement
operator by considering what our definition im-
plies in a few special cases.
If UPPER is the empty set, as in
[14]
the expression compiles to a transducer that freely
inserts as and bs in the input string.
</bodyText>
<figure confidence="0.965457333333333">
[15]
[12]
abc
a x
maps abc to both ax and xc:
abc
x c
If UPPER describes the null set, as in,
- $ [ ] -&gt;a l b ;
</figure>
<page confidence="0.918429">
18
</page>
<bodyText confidence="0.783709">
the context part as LEFT _ RIGHT, where the
underscore indicates where the replacement takes
place.
the LOWER part is irrelevant because there is no
replacement. This expression is a description of the
sigma-star language.
If LOWER describes the empty set, replacement be-
comes deletion. For example,
</bodyText>
<figure confidence="0.795149357142857">
a I b -&gt; M ;
removes all as and bs from the input.
If LOWER describes the null set, as in
a
all strings containing UPPER, here a or b, are ex-
cluded from the upper side language. Everything
else is mapped to itself. An equivalent expression is
b].
1.3. Inverse replacement
The inverse replacement operator.
[18]
UPPER &lt;- LOWER
is defined as the inverse of the relation LOWER -&gt;
UPPER.
</figure>
<subsectionHeader confidence="0.729243">
1.4. Optional replacement
</subsectionHeader>
<bodyText confidence="0.972525333333333">
An optional version of unconditional replacement
is derived simply by augmenting LOWER with UP-
PER in the replacement relation.
</bodyText>
<equation confidence="0.9349248">
[19]
UPPER (-&gt;) LOWER
is defined as
[20]
UPPER -&gt; [LOWER I UPPER] ;
</equation>
<bodyText confidence="0.997099666666667">
The optional replacement relation maps UPPER to
both LOWER and UPPER. The optional version of &lt;-
is defined in the same way.
</bodyText>
<sectionHeader confidence="0.990313" genericHeader="method">
2. Conditional replacement
</sectionHeader>
<bodyText confidence="0.998203916666667">
We now extend the notion of simple replacement
by allowing the operation to be constrained by a
left and a right context. A conditional replacement
expression has four components: UPPER, LOWER,
LEFT, and RIGHT. They must all be regular expres-
sions that describe a simple language. We write the
replacement part UPPER -&gt; LOWER, as before, and
In addition, we need a separator between the re-
placement and the context part. We use four alter-
nate separators, I I, / /, \ \ and \ /, which gives rise
to four types of conditional replacement expres-
sions:
</bodyText>
<table confidence="0.986433714285714">
(1) Upward-oriented: [21]
UPPER -&gt; LOWER I I LEFT .... RIGHT ;
(2) Right-oriented:
UPPER -&gt; LOWER // LEFT _ RIGHT ;
(3) Left-oriented:
UPPER -&gt; LOWER \\ LEFT RIGHT ;
-
</table>
<listItem confidence="0.470989">
(4) Downward-oriented:
</listItem>
<equation confidence="0.463107">
UPPER -&gt; LOWER \/ LEFT_ RIGHT ;
</equation>
<bodyText confidence="0.8656642">
All four kinds of replacement expressions describe
a relation that maps UPPER to LOWER between
LEFT and RIGHT leaving everything else un-
changed. The difference is in the interpretation of
&amp;quot;between LEFT and RIGHT.&amp;quot;
</bodyText>
<subsectionHeader confidence="0.976453">
2.1. Overview: divide and conquer
</subsectionHeader>
<bodyText confidence="0.999777">
We define UPPER -&gt; LOWER I I LEFT _ RIGHT
and the other versions of conditional replacement
in terms of expressions that are already in our regu-
lar expression language, including the uncondi-
tional version just defined. Our general intention is
to make the conditional replacement behave ex-
actly like unconditional replacement except that the
operation does not take place unless the specified
context is present.
This may seem a simple matter but it is not, as
Kaplan and Kay 1994 show. There are several
sources of complexity. One is that the part that is
being replaced may at the same time serve as the
context of another adjacent replacement. Another
complication is the fact just mentioned: there are
several ways to constrain a replacement by a con-
text.
We solve both problems using a technique that was
originally invented for the implementation of
phonological rewrite rules (Kaplan and Kay 1981,
1994) and later adapted for two-level rules (Kaplan,
Karttunen, Koskenniemi 1987; Karttunen and
</bodyText>
<page confidence="0.998259">
19
</page>
<bodyText confidence="0.94938675">
Beesley 1992). The strategy is first to decompose the
complex relation into a set of relatively simple
components, define the components independently
of one another, and then define the whole opera-
tion as a composition of these auxiliary relations.
We need six intermediate relations, to be defined
shortly:
[221
</bodyText>
<listItem confidence="0.998051166666667">
(1) InsertBrackets
(2) ConstrainBrackets
(3) LeftContext
(4) RightContext
(5) Replace
(6) RemoveBrackets
</listItem>
<bodyText confidence="0.989530727272727">
Relations (1), (5), and (6) involve the unconditional
replacement operator defined in the previous sec-
tion.
Two auxiliary symbols, &lt; and &gt;, are introduced in
(1) and (6). The left bracket, &lt;, indicates the end of a
left context. The right bracket, &gt;, marks the begin-
ning of a complete right context. The distribution of
the auxiliary brackets is controlled by (2), (3), and
(4). The relations (1) and (6) that introduce the
brackets internal to the composition at the same
time remove them from the result.
</bodyText>
<subsectionHeader confidence="0.790972">
2.2. Basic definition
</subsectionHeader>
<bodyText confidence="0.997926090909091">
The full specification of the six component relations
is given below. Here UPPER, LOWER, LEFT, and
RIGHT are placeholders for regular expressions of
any complexity.
In each case we give a regular expression that pre-
cisely defines the component followed by an Eng-
lish sentence describing the same language or rela-
tion. In our regular expression language, we have
to prefix the auxiliary context markers with the
escape symbol % to distinguish them from other
uses of &lt; and &gt;.
</bodyText>
<figure confidence="0.843023533333333">
[23]
(1) InsertBrackets
[] &lt; %&lt; 1 %&gt; ;
The relation that eliminates from the upper side lan-
guage all context markers that appear on the lower
side.
[24]
(2) ConstrainBrackets
-.$[%&lt; %&gt;] ;
The language consisting of strings that do not contain
&lt;&gt; anywhere.
[25]
(3) LeftContext
&amp;
-[ [...LEFT] -[&lt;...]] ;
</figure>
<bodyText confidence="0.948506111111111">
The language in which any instance of &lt; is immedi-
ately preceded by LEFT, and every LEFT is immedi-
ately followed by &lt;, ignoring irrelevant brackets.
Here [ . . . LEFT] is an abbreviation for [ ?*
LEFT/ [%&lt;1%&gt;] ] — [?* %&lt;] ], that is, any string
ending in LEFT, ignoring all brackets except for a
final &lt;. Similarly, [ % &lt; . . . ] stands for [ %&lt;/ %&gt;
* ] , any string beginning with &lt;, ignoring the
other bracket.
</bodyText>
<equation confidence="0.5767885">
[26]
(4) RightContext
-[ [...&gt;] -[RIGHT...] &amp;
.&gt;] [RIGHT...] ;
</equation>
<bodyText confidence="0.998714142857143">
The language in which any instance of &gt; is immedi-
ately followed by RIGHT, and any RIGHT is immedi-
ately preceded by &gt;, ignoring irrelevant brackets.
Here [ . . . &gt; ] abbreviates [ 7* %&gt; / %&lt; ], and
RIGHT.., stands for [RIGHT/ [%&lt; I %&gt;] - [%&gt;
?*] 3 , that is, any string beginning with RIGHT,
ignoring all brackets except for an initial &gt;.
</bodyText>
<equation confidence="0.4523256">
[27]
(5) Replace
%&lt; UPPER/[%&lt;1%&gt;] %&gt;
-&gt;
%&lt; LOWER/[%&lt;I%&gt;] %&gt; ;
</equation>
<bodyText confidence="0.99483625">
The unconditional replacement of &lt;UPPER&gt; by
&lt;LOWER&gt;, ignoring irrelevant brackets.
The redundant brackets on the lower side are im-
portant for the other versions of the operation.
</bodyText>
<equation confidence="0.250790666666667">
[28]
(6) RemoveBrackets
%&lt; I %&gt; -&gt; [] ;
</equation>
<page confidence="0.96996">
20
</page>
<bodyText confidence="0.9774938">
The relation that maps the strings of the upper lan-
guage to the same strings without any context mark-
ers.
The upper side brackets are eliminated by the in-
verse replacement defined in (1).
</bodyText>
<subsectionHeader confidence="0.905234">
2.3. Four ways of using contexts
</subsectionHeader>
<bodyText confidence="0.907594333333333">
The complete definition of the first version of con-
ditional replacement is the composition of these six
relations:
</bodyText>
<figure confidence="0.987695307692308">
[29]
UPPER -&gt; LOWER II LEFT RIGHT ;
InsertBrackets
.o.
ConstrainBrackets
.o.
LeftContext
.o.
RightContext
.o.
Replace
.o.
RemoveBrackets ;
</figure>
<bodyText confidence="0.982886307692308">
The composition with the left and right context
constraints prior to the replacement means that any
instance of UPPER that is subject to replacement is
surrounded by the proper context on the upper
side. Within this region, replacement operates just
as it does in the unconditional case.
Three other versions of conditional replacement
can be defined by applying one, or the other, or
both context constraints on the lower side of the
relation. It is done by varying the order of the three
middle relations in the composition. In the right-
oriented version (/ /), the left context is checked on
the lower side of replacement:
</bodyText>
<equation confidence="0.6356566">
[301
UPPER -&gt; LOWER // LEFT RIGHT ;
[31]
UPPER -&gt; LOWER \\ LEFT ___ RIGHT ;
Left▪ Context
</equation>
<bodyText confidence="0.892012857142857">
.o.
Replace
.o.
RightContext
The first three versions roughly correspond to the
three alternative interpretations of phonological
rewrite rules discussed in Kaplan and Kay 1994.
The upward-oriented version corresponds to si-
multaneous rule application; the right- and left-
oriented versions can model rightward or leftward
iterating processes, such as vowel harmony and
assimilation.
The fourth logical possibility is that the replace-
ment operation is constrained by the lower context.
</bodyText>
<figure confidence="0.702535285714286">
[32]
UPPER -&gt; LOWER \/ LEFT RIGHT ;
Replace
.o.
LeftContext
.o.
RightContext
</figure>
<bodyText confidence="0.97054475">
When the component relations are composed to-
gether in this manner, UPPER gets mapped to
LOWER just in case it ends up between LEFT and
RIGHT in the output string.
</bodyText>
<subsectionHeader confidence="0.827309">
2.4. Examples
</subsectionHeader>
<bodyText confidence="0.999015">
Let us illustrate the consequences of these defini-
tions with a few examples. We consider four ver-
sions of the same replacement expression, starting
with the upward-oriented version
</bodyText>
<figure confidence="0.45106175">
[33]
ab-&gt;x I I ab_a;
RightContext applied to the string abababa. The resulting rela-
.o. tion is
Replace [34]
.o. abababa
LeftContext ab x x a
. . .
</figure>
<bodyText confidence="0.9007025">
The left-oriented version applies the constraints in The second and the third occurrence of ab are re-
the opposite order: placed by x here because they are between ab and
</bodyText>
<page confidence="0.995693">
21
</page>
<bodyText confidence="0.8951705">
x on the upper side language of the relation. A
transducer for the relation is shown in Figure 4.
</bodyText>
<figure confidence="0.687001">
b:x
</figure>
<figureCaption confidence="0.93237">
Figure 4:ab-&gt;x II ab_a
</figureCaption>
<bodyText confidence="0.734058">
The path through the network that maps abababa
to abxxa is 0-1-2-5-7-5-6-3.
</bodyText>
<figure confidence="0.91832">
The right-oriented version,
a b -&gt; x // a b _ a;
</figure>
<figureCaption confidence="0.66659825">
Figure 5: a b -&gt; x // a b_a
gives us a different result:
abababa
ab x aba
</figureCaption>
<bodyText confidence="0.946631555555556">
following the path 0-1-2-5-6-1-2-3. The last
occurrence of ab must remain unchanged because it
does not have the required left context on the lower
side.
The left-oriented version of the rule shows the
opposite behavior because it constrains the left
context on the upper side of the replacement re-
lation and the right context on the lower side.
a.x
</bodyText>
<figureCaption confidence="0.990089">
Figure 6: a b -&gt; x \ \ a b .... a
</figureCaption>
<bodyText confidence="0.95526925">
With abababa composed on the upper side, it
yields
abababa
abab x a
by the path 0-1-2-3-4-5-6-3.
The first two occurrences of ab remain unchanged
because neither one has the proper right context on
the lower side to be replaced by x.
</bodyText>
<figure confidence="0.913979">
Finally, the downward-oriented fourth version:
a b -&gt; x \/ a b_a ;
a :x
</figure>
<figureCaption confidence="0.999933">
Figure 7: a b -&gt; x \/ a b_ a
</figureCaption>
<bodyText confidence="0.943807">
This time, surprisingly, we get two outputs from
the same input:
abababa , abababa
ab x aba abab x a
a b -&gt; x \\ a b_a ; [37] Path 0-1-2-5-6-1-2-3 yields abxaba, path 0 -
1-2-3- 4-5-6-1 gives us ababxa
It is easy to see that if the constraint for the re-
placement pertains to the lower side, then in this
case it can be satisfied in two ways.
</bodyText>
<page confidence="0.956416">
22
</page>
<sectionHeader confidence="0.911748" genericHeader="evaluation">
3. Comparisons
</sectionHeader>
<subsectionHeader confidence="0.918401">
3.1. Phonological rewrite rules
</subsectionHeader>
<bodyText confidence="0.999990964285714">
Our definition of replacement is in its technical
aspects very closely related to the way phonologi-
cal rewrite-rules are defined in Kaplan and Kay
1994 but there are important differences. The initial
motivation in their original 1981 presentation was
to model a left-to-right deterministic process of rule
application. In the course of exploring the issues,
Kaplan and Kay developed a more abstract notion
of rewrite rules, which we exploit here, but their
1994 paper retains the procedural point of view.
Our paper has a very different starting point. The
basic case for us is unconditional obligatory re-
placement, defined in a purely relational way
without any consideration of how it might be ap-
plied. By starting with obligatory replacement, we
can easily define an optional version of the opera-
tor. For Kaplan and Kay, the primary notion is op-
tional rewriting. It is quite cumbersome for them to
provide an obligatory version. The results are not
equivalent.
Although people may agree, in the case of simple
phonological rewrite rules, what the outcome of a
deterministic rewrite operation should be, it is not
clear that this is the case for replacement expres-
sions that involve arbitrary regular languages. For
that reason, we prefer to define the replacement
operator in relational terms without relying on an
uncertain intuition about a particular procedure.
</bodyText>
<subsectionHeader confidence="0.61072">
3.2. Two-level rules
</subsectionHeader>
<bodyText confidence="0.999974">
Our definition of replacement also has a close con-
nection to two-level rules. A two-level rule always
specifies whether a context element belongs to the
input (= lexical) or the output (= surface) context of
the rule. The two-level model also shares our pure
relational view of replacement as it is not con-
cerned about the application procedure. But the
two-level formalism is only defined for symbol-to-
symbol replacements.
</bodyText>
<sectionHeader confidence="0.973373" genericHeader="conclusions">
4. Conclusion
</sectionHeader>
<bodyText confidence="0.99962575">
The goal of this paper has been to introduce to the
calculus of regular expressions a replace operator,
-&gt;, with a set of associated replacement expressions
that concisely encode alternate variations of the
operation.
We defined unconditional and conditional re-
placement, taking the unconditional obligatory
replacement as the basic case. We provide a simple
declarative definition for it, easily expressed in
terms of the other regular expression operators,
and extend it to the conditional case providing four
ways to constrain replacement by a context.
These definitions have already been implemented.
The figures in this paper correspond exactly to the
output of the regular expression compiler in the
Xerox finite-state calculus.
</bodyText>
<sectionHeader confidence="0.998586" genericHeader="acknowledgments">
Acknowledgments
</sectionHeader>
<bodyText confidence="0.999129833333333">
This work is based on many years of productive
collaboration with Ronald M. Kaplan and Martin
Kay. I am particularly indebted to Kaplan for
writing a very helpful critique, even though he
strongly prefers the approach of Kaplan and Kay
1994. Special thanks are also due to Kenneth R.
Beesley for technical help on the definitions of the
replace operators and for expert editorial advice. I
am grateful to Pasi Tapanainen, Jean-Pierre
Chanod and Annie Zaenen for helping to correct
many terminological and rhetorical weaknesses of
the initial draft.
</bodyText>
<sectionHeader confidence="0.999086" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.998006789473684">
Kaplan, Ronald M., and Kay, Martin (1981).
Phonological Rules and Finite- State Transducers.
Paper presented at the Annual Meeting of the
Linguistic Society of America. New York.
Kaplan, Ronald M. and Kay, Martin (1994). Regular
Models of Phonological Rule Systems. Computa-
tional Linguistics. 20:3 331-378. 1994.
Karttunen, Lauri, Koskenniemi, Kimmo, and
Kaplan, Ronald M. (1987) A Compiler for Two-
level Phonological Rules. In Report No. CSU-87-
108. Center for the Study of Language and In-
formation. Stanford University.
Karttunen, Lauri and Beesley, Kenneth R. (1992).
Two-level Rule Compiler. Technical Report. ISTL-
92-2. Xerox Palo Alto Research Center.
Koskenniemi, Kimmo (1983). Two-level Morphology:
A General Computational Model for Word-Form Re-
cognition and Production. Department of General
Linguistics. University of Helsinki.
</reference>
<page confidence="0.998948">
23
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.432755">
<title confidence="0.999846">The Replace Operator</title>
<author confidence="0.999889">Lauri Karttunen</author>
<affiliation confidence="0.935467">Rank Xerox Research Centre</affiliation>
<address confidence="0.833081">6, chemin de Maupertuis F-38240 Meylan, France</address>
<email confidence="0.998213">lauri.karttunen@xerox.fr</email>
<abstract confidence="0.999902727272727">This paper introduces to the calculus of regular expressions a replace operator and defines a set of replacement expressions that concisely encode alternate variations of the operation. Replace expressions denote regular relations, defined in terms of other regular expression operators. The basic case is unconditional obligatory replacement. We develop several versions of conditional replacement that allow the op-</abstract>
<intro confidence="0.636671">eration to be constrained by context</intro>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Ronald M Kaplan</author>
<author>Martin Kay</author>
</authors>
<title>Phonological Rules and Finite- State Transducers. Paper presented at the Annual Meeting of the Linguistic Society of America.</title>
<date>1981</date>
<location>New York.</location>
<contexts>
<context position="11245" citStr="Kaplan and Kay 1981" startWordPosition="1947" endWordPosition="1950">ve exactly like unconditional replacement except that the operation does not take place unless the specified context is present. This may seem a simple matter but it is not, as Kaplan and Kay 1994 show. There are several sources of complexity. One is that the part that is being replaced may at the same time serve as the context of another adjacent replacement. Another complication is the fact just mentioned: there are several ways to constrain a replacement by a context. We solve both problems using a technique that was originally invented for the implementation of phonological rewrite rules (Kaplan and Kay 1981, 1994) and later adapted for two-level rules (Kaplan, Karttunen, Koskenniemi 1987; Karttunen and 19 Beesley 1992). The strategy is first to decompose the complex relation into a set of relatively simple components, define the components independently of one another, and then define the whole operation as a composition of these auxiliary relations. We need six intermediate relations, to be defined shortly: [221 (1) InsertBrackets (2) ConstrainBrackets (3) LeftContext (4) RightContext (5) Replace (6) RemoveBrackets Relations (1), (5), and (6) involve the unconditional replacement operator defin</context>
</contexts>
<marker>Kaplan, Kay, 1981</marker>
<rawString>Kaplan, Ronald M., and Kay, Martin (1981). Phonological Rules and Finite- State Transducers. Paper presented at the Annual Meeting of the Linguistic Society of America. New York.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ronald M Kaplan</author>
<author>Martin Kay</author>
</authors>
<title>Regular Models of Phonological Rule Systems. Computational Linguistics.</title>
<date>1994</date>
<volume>20</volume>
<pages>331--378</pages>
<contexts>
<context position="1487" citStr="Kaplan and Kay 1994" startWordPosition="215" endWordPosition="218">mars. Our purpose in this paper is twofold. One is to define replacement in a very general way, explicitly allowing replacement to be constrained by input and output contexts, as in two-level rules (Koskenniemi 1983), but without the restriction of only single-symbol replacements. The second objective is to define replacement within a general calculus of regular expressions so that replacements can be conveniently combined with other kinds of operations, such as composition and union, to form complex expressions. Our replacement operators are close relatives of the rewrite-operator defined in Kaplan and Kay 1994, but they are not identical to it. We discuss their relationship in a section at the end of the paper. O. 1. Simple regular expressions The replacement operators are defined by means of regular expressions. Some of the operators we use to define them are specific to Xerox implementations of the finite-state calculus, but equivalent formulations could easily be found in other notations. The table below describes the types of expressions and special symbols that are used to define the replacement operators. (A) option (union of A with the empty string) -A complement (negation) \A term complemen</context>
<context position="10822" citStr="Kaplan and Kay 1994" startWordPosition="1877" endWordPosition="1880"> leaving everything else unchanged. The difference is in the interpretation of &amp;quot;between LEFT and RIGHT.&amp;quot; 2.1. Overview: divide and conquer We define UPPER -&gt; LOWER I I LEFT _ RIGHT and the other versions of conditional replacement in terms of expressions that are already in our regular expression language, including the unconditional version just defined. Our general intention is to make the conditional replacement behave exactly like unconditional replacement except that the operation does not take place unless the specified context is present. This may seem a simple matter but it is not, as Kaplan and Kay 1994 show. There are several sources of complexity. One is that the part that is being replaced may at the same time serve as the context of another adjacent replacement. Another complication is the fact just mentioned: there are several ways to constrain a replacement by a context. We solve both problems using a technique that was originally invented for the implementation of phonological rewrite rules (Kaplan and Kay 1981, 1994) and later adapted for two-level rules (Kaplan, Karttunen, Koskenniemi 1987; Karttunen and 19 Beesley 1992). The strategy is first to decompose the complex relation into </context>
<context position="15535" citStr="Kaplan and Kay 1994" startWordPosition="2684" endWordPosition="2687">nditional case. Three other versions of conditional replacement can be defined by applying one, or the other, or both context constraints on the lower side of the relation. It is done by varying the order of the three middle relations in the composition. In the rightoriented version (/ /), the left context is checked on the lower side of replacement: [301 UPPER -&gt; LOWER // LEFT RIGHT ; [31] UPPER -&gt; LOWER \\ LEFT ___ RIGHT ; Left▪ Context .o. Replace .o. RightContext The first three versions roughly correspond to the three alternative interpretations of phonological rewrite rules discussed in Kaplan and Kay 1994. The upward-oriented version corresponds to simultaneous rule application; the right- and leftoriented versions can model rightward or leftward iterating processes, such as vowel harmony and assimilation. The fourth logical possibility is that the replacement operation is constrained by the lower context. [32] UPPER -&gt; LOWER \/ LEFT RIGHT ; Replace .o. LeftContext .o. RightContext When the component relations are composed together in this manner, UPPER gets mapped to LOWER just in case it ends up between LEFT and RIGHT in the output string. 2.4. Examples Let us illustrate the consequences of </context>
<context position="18184" citStr="Kaplan and Kay 1994" startWordPosition="3167" endWordPosition="3170">ented fourth version: a b -&gt; x \/ a b_a ; a :x Figure 7: a b -&gt; x \/ a b_ a This time, surprisingly, we get two outputs from the same input: abababa , abababa ab x aba abab x a a b -&gt; x \\ a b_a ; [37] Path 0-1-2-5-6-1-2-3 yields abxaba, path 0 - 1-2-3- 4-5-6-1 gives us ababxa It is easy to see that if the constraint for the replacement pertains to the lower side, then in this case it can be satisfied in two ways. 22 3. Comparisons 3.1. Phonological rewrite rules Our definition of replacement is in its technical aspects very closely related to the way phonological rewrite-rules are defined in Kaplan and Kay 1994 but there are important differences. The initial motivation in their original 1981 presentation was to model a left-to-right deterministic process of rule application. In the course of exploring the issues, Kaplan and Kay developed a more abstract notion of rewrite rules, which we exploit here, but their 1994 paper retains the procedural point of view. Our paper has a very different starting point. The basic case for us is unconditional obligatory replacement, defined in a purely relational way without any consideration of how it might be applied. By starting with obligatory replacement, we c</context>
</contexts>
<marker>Kaplan, Kay, 1994</marker>
<rawString>Kaplan, Ronald M. and Kay, Martin (1994). Regular Models of Phonological Rule Systems. Computational Linguistics. 20:3 331-378. 1994.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Lauri Karttunen</author>
<author>Kimmo Koskenniemi</author>
<author>Ronald M Kaplan</author>
</authors>
<title>A Compiler for Twolevel Phonological Rules.</title>
<date>1987</date>
<tech>In Report No. CSU-87-108.</tech>
<institution>Center for the Study of Language and Information. Stanford University.</institution>
<marker>Karttunen, Koskenniemi, Kaplan, 1987</marker>
<rawString>Karttunen, Lauri, Koskenniemi, Kimmo, and Kaplan, Ronald M. (1987) A Compiler for Twolevel Phonological Rules. In Report No. CSU-87-108. Center for the Study of Language and Information. Stanford University.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Lauri Karttunen</author>
<author>Kenneth R Beesley</author>
</authors>
<title>Two-level Rule Compiler.</title>
<date>1992</date>
<tech>Technical Report. ISTL92-2.</tech>
<institution>Xerox Palo Alto Research Center.</institution>
<marker>Karttunen, Beesley, 1992</marker>
<rawString>Karttunen, Lauri and Beesley, Kenneth R. (1992). Two-level Rule Compiler. Technical Report. ISTL92-2. Xerox Palo Alto Research Center.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kimmo Koskenniemi</author>
</authors>
<title>Two-level Morphology: A General Computational Model for Word-Form Recognition and Production.</title>
<date>1983</date>
<institution>Department of General Linguistics. University of Helsinki.</institution>
<contexts>
<context position="1084" citStr="Koskenniemi 1983" startWordPosition="156" endWordPosition="157">ligatory replacement. We develop several versions of conditional replacement that allow the operation to be constrained by context 0. Introduction Linguistic descriptions in phonology, morphology, and syntax typically make use of an operation that replaces some symbol or sequence of symbols by another sequence or symbol. We consider here the replacement operation in the context of finite-state grammars. Our purpose in this paper is twofold. One is to define replacement in a very general way, explicitly allowing replacement to be constrained by input and output contexts, as in two-level rules (Koskenniemi 1983), but without the restriction of only single-symbol replacements. The second objective is to define replacement within a general calculus of regular expressions so that replacements can be conveniently combined with other kinds of operations, such as composition and union, to form complex expressions. Our replacement operators are close relatives of the rewrite-operator defined in Kaplan and Kay 1994, but they are not identical to it. We discuss their relationship in a section at the end of the paper. O. 1. Simple regular expressions The replacement operators are defined by means of regular ex</context>
</contexts>
<marker>Koskenniemi, 1983</marker>
<rawString>Koskenniemi, Kimmo (1983). Two-level Morphology: A General Computational Model for Word-Form Recognition and Production. Department of General Linguistics. University of Helsinki.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>