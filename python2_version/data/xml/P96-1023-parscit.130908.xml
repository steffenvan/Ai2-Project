<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<title confidence="0.622672666666667">
INVITED TALK
Head Automata and Bilingual Tiling:
Translation with Minimal Representations
</title>
<author confidence="0.799894">
Hiyan Alshawi
</author>
<affiliation confidence="0.641187">
AT&amp;T Research
</affiliation>
<address confidence="0.713299">
600 Mountain Avenue, Murray Hill, NJ 07974, USA
</address>
<email confidence="0.996389">
hiyan@research.att.com
</email>
<sectionHeader confidence="0.99736" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.9999144375">
We present a language model consisting of
a collection of costed bidirectional finite
state automata associated with the head
words of phrases. The model is suitable
for incremental application of lexical asso-
ciations in a dynamic programming search
for optimal dependency tree derivations.
We also present a model and algorithm
for machine translation involving optimal
&amp;quot;tiling&amp;quot; of a dependency tree with entries
of a costed bilingual lexicon. Experimen-
tal results are reported comparing methods
for assigning cost functions to these mod-
els. We conclude with a discussion of the
adequacy of annotated linguistic strings as
representations for machine translation.
</bodyText>
<sectionHeader confidence="0.999516" genericHeader="keywords">
1 Introduction
</sectionHeader>
<bodyText confidence="0.99995584375">
Until the advent of statistical methods in the main-
stream of natural language processing, syntactic
and semantic representations were becoming pro-
gressively more complex. This trend is now revers-
ing itself, in part because statistical methods re-
duce the burden of detailed modeling required by
constraint-based grammars, and in part because sta-
tistical models for converting natural language into
complex syntactic or semantic representations is not
well understood at present. At the same time, lex-
ically centered views of language have continued to
increase in popularity. We can see this in lexical-
ized grammatical theories, head-driven parsing and
generation, and statistical disambiguation based on
lexical associations.
These themes — simple representations, statisti-
cal modeling, and lexicalism — form the basis for
the models and algorithms described in the bulk of
this paper. The primary purpose is to build effec-
tive mechanisms for machine translation, the oldest
and still the most commonplace application of non-
superficial natural language processing. A secondary
motivation is to test the extent to which a non-trivial
language processing task can be carried out without
complex semantic representations.
In Section 2 we present reversible mono-lingual
models consisting of collections of simple automata
associated with the heads of phrases. These head
automata are applied by an algorithm with admissi-
ble incremental pruning based on semantic associa-
tion costs, providing a practical solution to the prob-
lem of combinatoric disambiguation (Church and
Patil 1982). The model is intended to combine the
lexical sensitivity of N-gram models (Jelinek et al.
1992) and the structural properties of statistical con-
text free grammars (Booth 1969) without the com-
putational overhead of statistical lexicalized tree-
adjoining grammars (Schabes 1992, Resnik 1992).
For translation, we use a model for mapping de-
pendency graphs written by the source language
head automata. This model is coded entirely as
a bilingual lexicon, with associated cost parame-
ters. The transfer algorithm described in Section 4
searches for the lowest cost &apos;tiling&apos; of the target
dependency graph with entries from the bilingual
lexicon. Dynamic programming is again used to
make exhaustive search tractable, avoiding the com-
binatoric explosion of shake-and-bake translation
(Whitelock 1992, Brew 1992).
In Section 5 we present a general framework for as-
sociating costs with the solutions of search processes,
pointing out some benefits of cost functions other
than log likelihood, including an error-minimization
cost function for unsupervised training of the pa-
rameters in our translation application. Section 6
briefly describes an English-Chinese translator em-
ploying the models and algorithms. We also present
experimental results comparing the performance of
different cost assignment methods.
Finally, we return to the more general discussion
of representations for machine translation and other
natural language processing tasks, arguing the case
for simple representations close to natural language
itself.
</bodyText>
<sectionHeader confidence="0.971737" genericHeader="introduction">
2 Head Automata Language Models
</sectionHeader>
<subsectionHeader confidence="0.935365">
2.1 Lexical and Dependency Parameters
</subsectionHeader>
<bodyText confidence="0.999984833333333">
Head automata mono-lingual language models con-
sist of a lexicon, in which each entry is a pair (w, m)
of a word w from a vocabulary V and a head au-
tomaton in (defined below), and a parameter table
giving an assignment of costs to events in a genera-
tive process involving the automata.
</bodyText>
<page confidence="0.99563">
167
</page>
<bodyText confidence="0.993649592592593">
We first describe the model in terms of the familiar
paradigm of a generative statistical model, present-
ing the parameters as conditional probabilities. This
gives us a stochastic version of dependency grammar
(Hudson 1984).
Each derivation in the generative statistical model
produces an ordered dependency free, that is, a tree
in which nodes dominate ordered sequences of left
and right subtrees and in which the nodes have la-
bels taken from the vocabulary V and the arcs have
labels taken from a set R of relation symbols. When
a node with label w immediately dominates a node
with label w&apos; via an arc with label r, we say that
w&apos; is an r-dependent of the head w. The interpre-
tation of this directed arc is that relation r holds
between particular instances of w and w&apos;. (A word
may have several or no r-dependents for a particular
relation r.) A recursive left-parent-right traversal of
the nodes of an ordered dependency tree for a deriva-
tion yields the word string for the derivation.
A head automaton in of a lexical entry (w, m) de-
fines possible ordered local trees immediately dom-
inated by w in derivations. Model parameters for
head automata, together with dependency parame-
ters and lexical parameters, give a probability dis-
tribution for derivations.
A dependency parameter
</bodyText>
<equation confidence="0.567585">
P(1, wilw, r&apos;)
</equation>
<bodyText confidence="0.9227595">
is the probability, given a head w with a dependent
arc with label r&apos;, that w&apos; is the r&apos;-dependent for this
arc.
A lexical parameter
</bodyText>
<equation confidence="0.48504">
P(m,q1r, w)
</equation>
<bodyText confidence="0.99715525">
is the probability that a local tree immediately dom-
inated by an r-dependent w is derived by starting
in state q of some automaton m in a lexical entry
(w, in). The model also includes lexical parameters
</bodyText>
<equation confidence="0.812719">
P(w, m, gj t&gt;)
</equation>
<bodyText confidence="0.9971475">
for the probability that w is the head word for an
entire derivation initiated from state q of automaton
</bodyText>
<subsectionHeader confidence="0.999792">
2.2 Head Automata
</subsectionHeader>
<bodyText confidence="0.999513333333333">
A head automaton is a weighted finite state machine
that writes (or accepts) a pair of sequences of rela-
tion symbols from R:
</bodyText>
<equation confidence="0.974926">
((r1 • • • rk), (rk+i • • • rn))•
</equation>
<bodyText confidence="0.9987327">
These correspond to the relations between a head
word and the sequences of dependent phrases to its
left and right (see Figure 1). The machine consists
of a finite set go, • • , q, of states and an action ta-
ble specifying the finite cost (non-zero probability)
actions the automaton can undergo.
There are three types of action for an automaton
in: left transitions, right transitions, and stop ac-
tions. These actions, together with associated prob-
abilistic model parameters, are as follows.
</bodyText>
<figureCaption confidence="0.549091">
Figure 1: Head automaton m scans left and right
sequences of relations ri for dependents wi of w.
</figureCaption>
<listItem confidence="0.9636065">
• Left transition: if in state gi_ , m can write
a symbol r onto the right end of the current
lpef(,tse qi, riq
andquence_i m)
en. ter state gi with probability
• Right transition: if in state gi_ 1, m can write
a symbol r onto the left end of the current
right sequence and enter state gi with proba-
bility P(—, gi, r m)-
• Stop: if in state q, m can stop with probabil-
ity P(Olg, m), at which point the sequences are
considered complete.
</listItem>
<bodyText confidence="0.998807909090909">
For a consistent probabilistic model, the probabili-
ties of all transitions and stop actions from a state q
must sum to unity. Any state of a head automaton
can be an initial state, the probability of a partic-
ular initial state in a derivation being specified by
lexical parameters. A derivation of a pair of sym-
bol sequence thus corresponds to the selection of an
initial state, a sequence of zero or more transitions
(writing the symbols) and a stop action. The prob-
ability, given an initial state q, that automaton in
will a generate a pair of sequences, i.e.
</bodyText>
<equation confidence="0.99126">
P((ri • • • rk),(rk+i • • r)1m, q)
</equation>
<bodyText confidence="0.9997884">
is the product of the probabilities of the actions
taken to generate the sequences. The case of zero
transitions will yield empty sequences, correspond-
ing to a leaf node of the dependency tree.
From a linguistic perspective, head automata al-
low for a compact, graded, notion of lexical subcate-
gorization (Gazdar et al. 1985) and the linear order
of a head and its dependent phrases. Lexical param-
eters can control the saturation of a lexical item (for
example a verb that is both transitive and intran-
sitive) by starting the same automaton in different
states. Head automata can also be used to code a
grammar in which states of an automaton for word
w corresponds to X-bar levels (Jackendoff 1977) for
phrases headed by w.
Head automata are formally more powerful than
finite state automata that accept regular languages
in the following sense. Each head automaton defines
a formal language with alphabet R whose strings are
the concatenation of the left and right sequence pairs
</bodyText>
<table confidence="0.781722">
rk rk+1
wi Wk Wk+1 Wn
</table>
<page confidence="0.996058">
168
</page>
<bodyText confidence="0.999948555555556">
written by the automaton. The class of languages
defined in this way clearly includes all regular lan-
guages, since strings of a regular language can be
generated, for example, by a head automaton that
only writes a left sequence. Head automata can also
accept some non-regular languages requiring coordi-
nation of the left and right sequences, for example
the language an bn (requiring two states), and the
language of palindromes over a finite alphabet.
</bodyText>
<subsectionHeader confidence="0.996161">
2.3 Derivation Probability
</subsectionHeader>
<bodyText confidence="0.97773775">
Let the probability of generating an ordered depen-
dency subtree D headed by an r-dependent word w
be P(DIw, r). The recursive process of generating
this subtree proceeds as follows:
</bodyText>
<listItem confidence="0.992097">
1. Select an initial state q of an automaton in for
w with lexical probability P(m, q1r, w).
2. Run the automaton mo with initial state q to
generate a pair of relation sequences with prob-
ability P((ri • • • rk), (rk+1 • • rn)Im, q).
3. For each relation ri in these sequences, select a
dependent word wi with dependency probabil-
ity P(1, wi lw, ri).
4. For each dependent w, recursively generate a
subtree with probability P(Di (wi, ri).
</listItem>
<bodyText confidence="0.999485">
We can now express the probability P(Do) for an
entire ordered dependency tree derivation Do headed
by a word wo as
</bodyText>
<equation confidence="0.997644">
P(Do) =
P(wo, mo, goi
P((ri • • • rk), (rk+i • rn) Imo , go)
ni&lt;i&lt;71 P(1-, wilwo, ri)P(Di Iwi, ri).
</equation>
<bodyText confidence="0.99974735">
In the translation application we search for the high-
est probability derivation (or more generally, the N-
highest probability derivations). For other purposes,
the probability of strings may be of more interest.
The probability of a string according to the model is
the sum of the probabilities of derivations of ordered
dependency trees yielding the string.
In practice, the number of parameters in a head
automaton language model is dominated by the de-
pendency parameters, that is, 0(1V121/c11) parame-
ters. This puts the size of the model somewhere in
between 2-gram and 3-gram model. The similarly
motivated link grammar model (Lafferty, Sleator
and Temperley 1992) has Oa VI&apos;) parameters. Un-
like simple N-gram models, head automata models
yield an interesting distribution of sentence lengths.
For example, the average sentence length for Monte-
Carlo generation with our probabilistic head au-
tomata model for ATIS was 10.6 words (the average
was 9.7 words for the corpus it was trained on).
</bodyText>
<sectionHeader confidence="0.867788" genericHeader="method">
3 Analysis and Generation
</sectionHeader>
<subsectionHeader confidence="0.997436">
3.1 Analysis
</subsectionHeader>
<bodyText confidence="0.994999018518519">
Head automaton models admit efficient lexically
driven analysis (parsing) algorithms in which par-
tial analyses are costed incrementally as they are
constructed. Put in terms of the traditional parsing
issues in natural language understanding, &amp;quot;seman-
tic&amp;quot; associations coded as dependency parameters
are applied at each parsing step allowing semanti-
cally suboptimal analyses to be eliminated, so the
analysis with the best semantic score can be identi-
fied without scoring an exponential number of syn-
tactic parses. Since the model is lexical, linguistic
constructions headed by lexical items not present in
the input are not involved in the search the way
they are with typical top-down or predictive parsing
strategies.
We will sketch an algorithm for finding the lowest
cost ordered dependency tree derivation for an input
string in polynomial time in the length of the string.
In our experimental system we use a more general
version of the algorithm to allow input in the form
of word lattices.
The algorithm is a bottom-up tabular parser
(Younger 1967, Early 1970) in which constituents
are constructed &amp;quot;head-outwards&amp;quot; (Kay 1989, Sata
and Stock 1989). Since we are analyzing bottom-
up with generative model automata, the algorithm
&apos;runs&apos; the automata backwards. Edges in the parsing
lattice (or &amp;quot;chart&amp;quot;) are tuples representing partial or
complete phrases headed by a word w from position
i to position j in the string:
(w, t, j, m, q, c).
Here in is the head automaton for w in this deriva-
tion; the automaton is in state q; t is the dependency
tree constructed so far, and c is the cost of the par-
tial derivation. We will use the notation C(xly) for
the cost of a model event with probability P(xly);
the assignment of costs to events is discussed in Sec-
tion 5.
Initialization: For each word w in the input be-
tween positions i and j, the lattice is initialized with
phrases
(w, {}, i, j, in, qf , ci)
for any lexical entry (w, m) and any final state qi of
the automaton m in the entry. A final state is one
for which the stop action cost ci = C(DIqf, m) is
finite.
Transitions: Phrases are combined bottom-up to
form progressively larger phrases. There are two
types of combination corresponding to left and right
transitions of the automaton for the word acting as
the head in the combination. We will specify left
combination; right combination is the mirror im-
age of left combination. If the lattice contains two
phrases abutting at position k in the string:
</bodyText>
<page confidence="0.927972">
169
</page>
<equation confidence="0.9097005">
(ID ,t1, i, k, mi, qi, ci)
(W21 t27 k) 7 1722 q2 C2)
</equation>
<bodyText confidence="0.999928666666667">
and the parameter table contains the following finite
costs parameters (a left r-transition of m2, a lexical
parameter for wi, and an r-dependency parameter):
</bodyText>
<equation confidence="0.999844666666667">
C3 = q2) riqi2, M2)
C4 = C(M1) gill., 1) W1)
C5 = C(1, wilw2, r),
</equation>
<bodyText confidence="0.9962096">
then build a new phrase headed by w2 with a tree t;
formed by adding t1 to t2 as an r-dependent of w2:
j, m2, q&apos;2, ci C2 + C3 + C4 + C5).
When no more combinations are possible, for each
phrase spanning the entire input we add the appro-
priate start of derivation cost to these phrases and
select the one with the lowest total cost.
Pruning: The dynamic programming condition for
pruning suboptimal partial analyses is as follows.
Whenever there are two phrases
</bodyText>
<equation confidence="0.9888515">
p= (w, t, j,m, q, c)
p&apos; = (w,t&apos; j,m,q,c&apos;),
</equation>
<bodyText confidence="0.999953476190476">
and c&apos; is greater than c, then we can remove p&apos; be-
cause for any derivation involving p&apos; that spans the
entire string, there will be a lower cost derivation
involving p. This pruning condition is effective at
curbing a combinatorial explosion arising from, for
example, prepositional phrase attachment ambigui-
ties (coded in the alternative trees t and t&apos;).
The worst case asymptotic time complexity of&apos; the
analysis algorithm is 0(min(n2,1V12)n3), where n is
the length of an input string and I VI is the size of
the vocabulary. This limit can be derived in a simi-
lar way to cubic time tabular recognition algorithms
for context free grammars (Younger 1967) with the
grammar related term being replaced by the term
min(n2, 11/12) since the words of the input sentence
also act as categories in the head automata model.
In this context &amp;quot;recognition&amp;quot; refers to checking that
the input string can be generated from the grammar.
Note that our algorithm is for analysis (in the sense
of finding the best derivation) which, in general, is
a higher time complexity problem than recognition.
</bodyText>
<subsectionHeader confidence="0.99874">
3.2 Generation
</subsectionHeader>
<bodyText confidence="0.999971636363636">
By generation here we mean determining the low-
est cost linear surface ordering for the dependents of
each word in an unordered dependency structure re-
sulting from the transfer mapping described in Sec-
tion 4. In general, the output of transfer is a de-
pendency graph and the task of the generator in-
volves a search for a backbone dependency tree for
the graph, if necessary by adding dependency edges
to join up unconnected components of the graph.
For each graph component, the main steps of the
search process, described non-deterministically, are
</bodyText>
<listItem confidence="0.940714611111111">
1. Select a node with word label w having a finite
start of derivation cost C(w, in, qlt&gt;).
2. Execute a path through the head automaton m
starting at state q and ending at state q&apos; with a
finite stop action cost C(Ellq&apos;, m). When mak-
ing a transition with relation ri in the path, se-
lect a graph edge with label ri from w to some
previously unvisited node wi with finite depen-
dency cost C(1, wilw, ri). Include the cost of
the transition (e.g. qi,rijqi_i,rn)) in the
running total for this derivation.
3. For each dependent node wi, select a lexical en-
try with cost C(mi, qi In, we), and recursively
apply the machine mi from state qi as in step
2.
4. Perform a left-parent-right traversal of the
nodes of the resulting dependency tree, yield-
ing a target string.
</listItem>
<bodyText confidence="0.999882">
The target string resulting from the lowest cost tree
that includes all nodes in the graph is selected as the
translation target string. The independence assump-
tions implicit in head automata models mean that
we can select lowest cost orderings of local depen-
dency trees, below a given relation r, independently
in the search for the lowest cost derivation.
When the generator is used as part of the trans-
lation system, the dependency parameter costs are
not, in fact, applied by the generator. Instead, be-
cause these parameters are independent of surface
order, they are applied earlier by the transfer com-
ponent, influencing the choice of structure passed to
the generator.
</bodyText>
<sectionHeader confidence="0.998608" genericHeader="method">
4 Transfer Maps
</sectionHeader>
<subsectionHeader confidence="0.986149">
4.1 Transfer Model Bilingual Lexicon
</subsectionHeader>
<bodyText confidence="0.993298052631579">
The transfer model defines possible mappings, with
associated costs, of dependency trees with source-
language word node labels into ones with target-
language word labels. Unlike the head automata
monolingual models, the transfer model operates
with unordered dependency trees, that is, it treats
the dependents of a word as an unordered bag. The
model is general enough to cover the common trans-
lation problems discussed in the literature (e.g. Lin-
dop and Tsujii 1991 and Dorr 1994) including many-
to-many word mapping, argument switching, and
head switching.
A transfer model consists of a bilingual lexicon
and a transfer parameter table. The model uses de-
pendency tree fragments, which are the same as un-
ordered dependency trees except that some nodes
may not have word labels. In the bilingual lexicon,
an entry for a source word wi (see top portion of
Figure 2) has the form
</bodyText>
<subsubsectionHeader confidence="0.505026">
(wi, Hi,ni,Gi, fi)
</subsubsectionHeader>
<bodyText confidence="0.995178666666667">
where Hi is a source language tree fragment, ni (the
primary node) is a distinguished node of Hi with
label wi, Gi is a target tree fragment, and fi is a
</bodyText>
<page confidence="0.850431">
170
</page>
<bodyText confidence="0.990068611111111">
mapping function, i.e. a (possibly partial) function Ii
from the nodes of Hi to the nodes of G.
The transfer parameter table specifies costs for
the application of transfer entries. In a context-
independent model, each entry has a single cost pa-
rameter. In context-dependent transfer models, the
cost function takes into account the identities of the
labels of the arcs and nodes dominating wi in the
source graph. (Context dependence is discussed fur-
ther in Section 5.) The set of transfer parameters
may also include costs for the null transfer entries
for wi, for use in derivations in which wi is trans-
lated by the entry for another word v. For example,
the entry for v might be for translating an idiom
involving wi as a modifier.
Each entry in the bilingual lexicon specifies a
way of mapping part of a dependency tree, specifi-
cally that part &amp;quot;matching&amp;quot; (as explained below) the
source fragment of the entry, into part of a target
graph, as indicated by the target fragment. Entry
mapping functions specify how the set of target frag-
ments for deriving a translation are to be combined:
whenever an entry is applied, a global node-mapping
function is extended to include the entry mapping
function.
4.2 Matching, Tiling, and Derivation
Transfer mapping takes a source dependency tree S
from analysis and produces a minimum cost deriva-
tion of a target graph T and a (possibly partial)
function f from source nodes to target nodes. In
fact, the transfer model is applicable to certain types
of source dependency graphs that are more general
than trees, although the version of the head au-
tomata model described here only produces trees.
We will say that a tree fragment H matches an
unordered dependency tree S if there is a function
</bodyText>
<listItem confidence="0.963185">
g (a matching function) from the nodes of H to the
nodes of S such that
• g is a total one-one function;
• if a node n of H has a label, and that label is
word w, then the word label for g(n) is also w;
• for every arc in H with label r from node n1 to
</listItem>
<bodyText confidence="0.954157923076923">
node n2, there is an arc with label r from g(n1)
to g(n2).
Unlike first order unification, this definition of
matching is not commutative and is not determinis-
tic in that there may be multiple matching functions
for applying a bilingual entry to an input source tree.
A particular match of an entry against a dependency
tree can be represented by the matching function g,
a set of arcs A in S, and the (possibly context de-
pendent) cost c of applying the entry.
A tiling of a source graph with respect to a transfer
model is a set of entry matches
{(Ei gi , Ai , ci), • • • , (Ek,gk, Ak &apos;CO}
</bodyText>
<figureCaption confidence="0.624882666666667">
which is such that
171
Figure 2: Transfer matching and mapping functions
</figureCaption>
<listItem confidence="0.985692571428572">
• k is the number of nodes in the source tree S.
• Each E, 1 &lt; i &lt; k, is a bilingual entry
(wi,Hi,ni,Gi, fi) matching S with function gi
(see Figure 2) and arcs Ai.
• For primary nodes ni and ni of two distinct
entries Ei and Ej, g(n2) and gi(ni) are distinct.
• The sets of edges Ai form a partition of the
edges of S.
• The images g(L2) form a partition of the nodes
of S, where Li is the set of labeled source nodes
in the source fragment Hi of E.
• ci is the cost of the match specified by the pa-
rameter table.
A tiling of S yields a costed derivation of a target
dependency graph T as follows:
• The cost of the derivation is the sum of the costs
ci for each match in the tiling.
• The nodes and arcs of T are composed of the
nodes and arcs of the target fragments Gi for
the entries Ei.
• Let fi and fi be the mapping functions for en-
</listItem>
<bodyText confidence="0.990697287671233">
tries Ei and E. For any node n of S for which
target nodes fi(gT1(n)) and fi(e(n)) are de-
fined, these two nodes are identified as a single
node f(n) in T.
The merging of target fragment nodes in the last
condition has the effect of joining the target frag-
ments in a consistent fashion. The node mapping
function f for the entire tree thus has a different
role from the alignment function in the IBM statis-
tical translation model (Brown et al. 1990, 1993);
the role of the latter includes the linear ordering of
words in the target string. In our approach, tar-
get word order is handled exclusively by the target
monolingual model.
4.3 Transfer Algorithm
The main transfer search is preceded by a bilingual
lexicon matching phase. This leads to greater ef-
ficiency as it avoids repeating matching operations
during the search phase, and it allows a static analy-
sis of the matching entries and source tree to identify
subtrees for which the search phase can safely prune
out suboptimal partial translations.
Transfer Configurations In order to apply tar-
get language model relation costs incrementally, we
need to distinguish between complete and incom-
plete arcs: an arc is complete if both its nodes have
labels, otherwise it is incomplete. The output of the
lexicon matching phrase, and the partial derivations
manipulated by the search phase are both in the
form of transfer configurations
(S, R,T, P, f,c, I)
where S is the set of source nodes and arcs con-
sumed so far in the derivation, R the remaining
source nodes and arcs, f the mapping function built
so far, T the set of nodes and complete arcs of the
target graph, P the set of incomplete target arcs,
c the partial derivation cost, and I a set of source
nodes for which entries have yet to be applied.
Lexical matching phase The algorithm for lexi-
cal matching has a similar control structure to stan-
dard unification algorithms, except that it can result
in multiple matches. We omit the details. The lex-
icon matching phase returns, for each source node
i, a set of runtime entries. There is one runtime
entry for each successful match and possibly a null
entry for the node if the word label for i is included
in successful matches for other entries. Runtime en-
tries are transfer configurations of the form
in which Hi is the source fragment for the entry with
each node replaced by its image under the applica-
ble matching function; Gi the target fragment for
the entry, except for the incomplete arcs Pi of this
fragment; ft the composition of mapping function
for the entry with the inverse of the matching func-
tion; ci the cost of applying the entry in the context
of its match with the source graph plus the cost in
the target model of the arcs in G.
Transfer Search Before the transfer search
proper, the resulting runtime entries together with
the source graph are analyzed to determine decom-
position nodes. A decomposition node n is a source
tree node for which it is safe to prune suboptimal
translations of the subtree dominated by n. Specifi-
cally, it is checked that n is the root node of all source
fragments II„ of runtime entries in which both n and
its node label are included, and that fn(n) is not
dominated by (i.e. not reachable via directed arcs
from) another node in the target graph Gn of such
entries.
Transfer search maintains a set M of active run-
time entries. Initially, this is the set of runtime
entries resulting from the lexicon matching phase.
Overall search control is as follows:
</bodyText>
<listItem confidence="0.9906228">
1. Determine the set of decomposition nodes.
2. Sort the decomposition nodes into a list D such
that if ni dominates n2 in S then n2 precedes
n1 in D.
3. If D is empty, apply the subtree transfer search
(given below) to S, return the lowest cost solu-
tion, and stop.
4. Remove the first decomposition node n from D
and apply the subtree transfer search to the sub-
tree S&apos; dominated by n, to yield solutions
(51, 0, , 4),!&apos;, c&apos;, 0).
5. Partition these solutions into subsets with the
same word label for the node f&apos; (n), and select
the solution with lowest cost c&apos; from each sub-
set.
6. Remove from M the set of runtime entries for
nodes in 5&apos;.
7. For each selected subtree solution, add to M a
new runtime entry (5&apos;, CT&apos; , , c&apos;, {n}).
8. Repeat from step 3.
</listItem>
<bodyText confidence="0.5865945">
The subtree transfer search maintains a queue
Q of configurations corresponding to partial deriva-
tions for translating the subtree. Control follows a
standard non-deterministic search paradigm:
</bodyText>
<listItem confidence="0.989056">
1. Initialize Q to contain a single configuration
(0, Ho, 0, 0, 0, 0,1O) with the input subtree Ro
and the set of nodes /0 in Ro.
2. If Q is empty, return the lowest cost solution
found and stop.
3. Remove a configuration (S, R, T, P, f ,c, I) from
the queue.
4. If R is empty, add the configuration to the set
of subtree solutions.
5. Select a node i from I.
6. For each runtime entry (Hi, cb, Gi, Pi, f, c, {i})
for i, if Hi is a subgraph of R, add to Q a con-
figuration (SU Hi, R — Hi,TUGi UG&apos;, PU P —
</listItem>
<bodyText confidence="0.9735258">
G&apos;, f U , I —{i}), where G&apos; is the set
of newly completed arcs (those in P U Pi with
both node labels in T U Gi U P U Pi) and CG,
is the cost of the arcs G&apos; in the target language
model.
</bodyText>
<listItem confidence="0.996234333333333">
7. For any source node n for which f (n) and f2(n)
are both defined, merge these two target nodes.
8. Repeat from step 2.
</listItem>
<bodyText confidence="0.998536444444445">
Keeping the arcs P separate in the configuration al-
lows efficient incremental application of target de-
pendency costs CG&apos; during the search, so these costs
are taken into account in the pruning step of the
overall search control. This way we can keep the
benefits of monolingual/bilingual modularity (Is-
abelle and Macklovitch 1986) without the compu-
tational overhead of transfer-and-filter (Alshawi et
al. 1992).
</bodyText>
<page confidence="0.995776">
172
</page>
<bodyText confidence="0.9999435">
It is possible to apply the subtree search directly
to the whole graph starting with the initial runtime
entries from lexical matching. However, this would
result in an exponential search, specifically a search
tree with a branching factor of the order of the num-
ber of matching entries per input word. Fortunately,
long sentences typically have several decomposition
nodes, such as the heads of noun phrases, so the
search as described is factored into manageable com-
ponents.
</bodyText>
<sectionHeader confidence="0.994574" genericHeader="method">
5 Cost Functions
</sectionHeader>
<subsectionHeader confidence="0.999043">
5.1 Costed Search Processes
</subsectionHeader>
<bodyText confidence="0.99997936">
The head automata model and transfer model were
originally conceived as probabilistic models. In order
to take advantage of more of the information avail-
able in our training data, we experimented with cost
functions that make use of incorrect translations as
negative examples and also to treat the correctness
of a translation hypothesis as a matter of degree.
To experiment with different models, we imple-
mented a general mechanism for associating costs to
solutions of a search process. Here, a search process
is conceptualized as a non-deterministic computa-
tion that takes a single input string, undergoes a
sequence of state transitions in a non-deterministic
fashion, then outputs a solution string. Process
states are distinct from, but may include, head au-
tomaton states.
A cost function for a search process is a real val-
ued function defined on a pair of equivalence classes
of process states. The first element of the pair, a
context c, is an equivalence class of states before
transitions. The second element, an event e, is an
equivalence class of states after transitions. (The
equivalence relations for contexts and events may
be different.) We refer to an event-context pair as a
choice, for which we use the notation
</bodyText>
<equation confidence="0.630302">
(elc)
</equation>
<bodyText confidence="0.999744285714286">
borrowed from the special case of conditional prob-
abilities. The cost of a derivation of a solution by
the process is taken to be the sum of costs of choices
involved in the derivation.
We represent events and contexts by finite se-
quences of symbols (typically words or relation sym-
bols in the translation application). We write
</bodyText>
<equation confidence="0.617098">
C(al • • • an Ibi • • • bk)
</equation>
<bodyText confidence="0.999723307692308">
for the cost of the event represented by (al • • an) in
the context represented by(bi • • bk)•
&amp;quot;Backed off&amp;quot; costs can be computed by averag-
ing over larger equivalence classes (represented by
shorter sequences in which positions are eliminated
systematically). A similar smoothing technique has
been applied to the specific case of prepositional
phrase attachment by Collins and Brooks (1995).
We have used backed off costs in the translation ap-
plication for the various cost functions described be-
low. Although this resulted in some improvement in
testing, so far the improvement has not been statis-
tically significant.
</bodyText>
<subsectionHeader confidence="0.998236">
5.2 Model Cost Functions
</subsectionHeader>
<bodyText confidence="0.983802277777778">
Taken together, the events, contexts, and cost func-
tion constitute a process cost model, or simply a
model. The cost function specifies the model param-
eters; the other components are the model structure.
We have experimented with a number of model
types, including the following.
Probabilistic model: In this model we assume a
probability distribution on the possible events for a
context, that is,
Ee P(elc)= 1.
The cost parameters of the model are defined as:
C(elc)= —1n(P(elc)).
Given a set of solutions from executions of a process,
let n+(e lc) be the number of times choice (elc) was
taken leading to acceptable solutions (e.g. correct
translations) and n+ (c) be the number of times con-
text c was encountered for these solutions. We can
then estimate the probabilistic model costs with
</bodyText>
<equation confidence="0.942944">
ln(n+ (c)) — In(n+(e10)-
</equation>
<bodyText confidence="0.9806975">
Discriminative model: The costs in this model are
likelihood ratios comparing positive and negative
solutions, for example correct and incorrect trans-
lations. (See Dunning 1993 on the application of
likelihood ratios in computational linguistics.) Let
n(elc) be the count for choice (elc) leading to neg-
ative solutions. The cost function for the discrimi-
native model is estimated as
C(elc);,-, ln(n- (e 1c)) — In(n+(eic)).
Mean distance model: In the mean distance model,
we make use of some measure of goodness of a solu-
tion 13 for some input s by comparing it against an
ideal solution 13 for s with a distance metric h:
d
in which d is a non-negative real number. A param-
eter for choice (elc) in the distance model
</bodyText>
<equation confidence="0.428409">
C(elc)= Eh(elc)
</equation>
<bodyText confidence="0.891492785714286">
is the mean value of h(ts, is) for solutions 13 pro-
duced by derivations including the choice (elc).
Normalized distance model: The mean distance
model does not use the constraint that a particular
choice faced by a process is always a choice between
events with the same context. It is also somewhat
sensitive to peculiarities of the distance function h.
With the same assumptions we made for the mean
distance model, let
E h (C)
be the average of h(13, I.) for solutions derived from
sequences of choices including the context c. The
cost parameter for (elc) in the normalized distance
model is
</bodyText>
<page confidence="0.972748">
173
</page>
<equation confidence="0.965647">
C(elc) = EA,(4)
</equation>
<bodyText confidence="0.99992932">
that is, the ratio of the expected distance for deriva-
tions involving the choice and the expected distance
for all derivations involving the context for that
choice.
Reflexive Training If we have a manually trans-
lated corpus, we can apply the mean and normal-
ized distance models to translation by taking the
ideal solution t, for translating a source string s to
be the manual translation for s. In the absence of
good metrics for comparing translations, we employ
a heuristic string distance metric to compare word
selection and word order in t, and t,.
In order to train the model parameters without
a manually translated corpus, we use a &amp;quot;reflexive&amp;quot;
training method (similar in spirit to the &amp;quot;wake-
sleep&amp;quot; algorithm, Hinton et al. 1995). In this
method, our search process translates a source sen-
tence s to t, in the target language and then trans-
lates t, back to a source language sentence s&apos;. The
original sentence s can then act as the ideal solu-
tion of the overall process. For this training method
to be effective, we need a reasonably good initial
model, i.e. one for which the distance h(s, s&apos;) is in-
versely correlated with the probability that ts is a
good translation of s.
</bodyText>
<sectionHeader confidence="0.986107" genericHeader="method">
6 Experimental System
</sectionHeader>
<bodyText confidence="0.994125431818182">
We have built an experimental translation system
using the monolingual and translation models de-
scribed in this paper. The system translates sen-
tences in the ATIS domain (Hirschman et al. 1993)
between English and Mandarin Chinese. The trans-
lator is in fact a subsystem of a speech translation
prototype, though the experiments we describe here
are for transcribed spoken utterances. (We infor-
mally refer to the transcribed utterances as sen-
tences.) The average time taken for translation of
sentences (of unrestricted length) from the ATIS cor-
pus was around 1.7 seconds with approximately 0.4
seconds being taken by the analysis algorithm and
0.7 seconds by the transfer algorithm.
English and Chinese lexicons of around 1200 and
1000 words respectively were constructed. Alto-
gether, the entries in these lexicons made reference
to around 200 structurally distinct head automata.
The transfer lexicon contained around 3500 paired
graph fragments, most of which were used in both
transfer directions. With this model structure, we
tried a number of methods for assigning cost func-
tions. The nature of the training methods and their
corresponding cost functions meant that different
amounts of training data could be used, as discussed
further below.
The methods make use of a supervised training
set and an unsupervised training set, both sets be-
ing chosen at random from the 20,000 or so ATIS
sentences available to us. The supervised training
set comprised around 1950 sentences. A subcollec-
tion of 1150 of these sentences were translated by the
system, and the resulting translations manually clas-
sified as &apos;good&apos; (800 translations) or &apos;bad&apos; (350 trans-
lations). The remaining 800 supervised training set
sentences were hand-tagged for prepositional attach-
ment points. (Prepositional phrase attachment is a
major cause of ambiguity in the ATIS corpus, and
moreover can affect English-Chinese translation, see
Chen and Chen 1992.) The attachment informa-
tion was used to generate additional negative and
positive counts for dependency choices. The un-
supervised training set consisted of approximately
13,000 sentences; it was used for automatic training
(as described under &apos;Reflexive Training&apos; above) by
translating the sentences into Chinese and back to
English.
A. Qualitative Baseline: In this model, all choices
were assigned the same cost except for irregular
events (such as unknown words or partial analy-
ses) which were all assigned a high penalty cost.
This model gives an indication of performance based
solely on model structure.
B. Probabilistic: Counts for choices leading to good
translations for sentences of the supervised train-
ing corpus, together with counts from the manually
assigned attachment points, were used to compute
negated log probability costs.
C. Discriminative: The positive counts as in the
probabilistic method, together with corresponding
negative counts from bad translations or incorrect
attachment choices, were used to compute log likeli-
hood ratio costs.
D. Normalized Distance: In this fully automatic
method, normalized distance costs were computed
from reflexive translation of the sentences in the un-
supervised training corpus. The translation runs
were carried out with parameters from method A.
E. Bootstrapped Normalized Distance: The same as
method D except that the system used to carry out
the reflexive translation was running with parame-
ters from method C.
Table 1 shows the results of evaluating the per-
formance of these models for translating 200 unre-
stricted length ATIS sentences into Chinese. This
was a previously unseen test set not included in
any of the training sets. Two measures of transla-
tion acceptability are shown, as judged by a Chinese
speaker. (In separate experiments, we verified that
the judgments of this speaker were near the average
of five Chinese speakers). The first measure, &amp;quot;mean-
ing and grammar&amp;quot;, gives the percentage of sentence
translations judged to preserve meaning without the
introduction of grammatical errors. For the second
measure, &amp;quot;meaning preservation&amp;quot;, grammatical er-
rors were allowed if they did not interfere with mean-
ing (in the sense of misleading the hearer). In the ta-
ble, we have grouped together methods A and D for
</bodyText>
<page confidence="0.998955">
174
</page>
<tableCaption confidence="0.9989295">
Table 1: Translation performance of different cost
assignment methods
</tableCaption>
<table confidence="0.997637857142857">
Method Meaning and Meaning
Grammar (%) Preservation (%)
A 29 71
D 37 71
B 46 82
C 52 83
E 54 83
</table>
<bodyText confidence="0.99984415">
which the parameters were derived without human
supervision effort, and methods B, C, and E which
depended on the same amount of human supervision
effort. This means that side by side comparison of
these methods has practical relevance, even though
the methods exploited different amounts of data. In
the case of E, the supervision effort was used only
as an oracle during training, not directly in the cost
computations.
We can see from Table 1 that the choice of method
affected translation quality (meaning and grammar)
more than it affected preservation of meaning. A
possible explanation is that the model structure was
adequate for most lexical choice decisions because of
the relatively low degree of polysemy in the ATIS
corpus. For the stricter measure, the differences
were statistically significant, according to the sign
test at the 5% significance level, for the following
comparisons: C and E each outperformed B and D,
and B and D each outperformed A.
</bodyText>
<sectionHeader confidence="0.8215125" genericHeader="method">
7 Language Processing and
Semantic Representations
</sectionHeader>
<bodyText confidence="0.999994280487805">
The translation system we have described employs
only simple representations of sentences and phrases.
Apart from the words themselves, the only sym-
bols used are the dependency relations R. In our
experimental system, these relation symbols are
themselves natural language words, although this
is not a necessary property of our models. Infor-
mation coded explicitly in sentence representations
by word senses and feature constraints in our pre-
vious work (Alshawi 1992) is implicit in the mod-
els used to derive the dependency trees and trans-
lations. In particular, dependency parameters and
context-dependent transfer parameters give rise to
an implicit, graded notion of word sense.
For language-centered applications like transla-
tion or summarization, for which we have a large
body of examples of the desired behavior, we can
think of the task in terms of the formal problem of
modeling a relation between strings based on exam-
ples of that relation. By taking this viewpoint, we
seem to be ignoring the intuition that most interest-
ing natural language processing tasks (translation,
summarization, interfaces) are semantic in nature.
It is therefore tempting to conclude that an adequate
treatment of these tasks requires the manipulation
of artificial semantic representation languages with
well-understood formal denotations. While the in-
tuition seems reasonable, the conclusion might be
too strong in that it rules out the possibility that
natural language itself is adequate for manipulating
semantic denotations. After all, this is the primary
function of natural language.
The main justification for artificial semantic rep-
resentation languages is that they are unambiguous
by design. This may not be as critical, or useful,
as it might first appear. While it is true that nat-
ural language is ambiguous and under-specified out
of context, this uncertainty is greatly reduced by
context to the point where further resolution (e.g.
full scoping) is irrelevant to the task, or even the
intended meaning. The fact that translation is in-
sensitive to many ambiguities motivated the use of
unresolved quasi-logical form for transfer (Alshawi
et al. 1992).
To the extent that contextual resolution is neces-
sary, context may be provided by the state of the lan-
guage processor rather than complex semantic rep-
resentations. Local context may include the state of
local processing components (such as our head au-
tomata) for capturing grammatical constraints, or
the identity of other words in a phrase for capturing
sense distinctions. For larger scale context, I have
argued elsewhere (Alshawi 1987) that memory ac-
tivation patterns resulting from the process of car-
rying out an understanding task can act as global
context without explicit representations of discourse.
Under this view, the challenge is how to exploit con-
text in performing a task rather than how to map
natural language phrases to expressions of a formal-
ism for coding meaning independently of context or
intended use.
There is now greater understanding of the formal
semantics of under-specified and ambiguous repre-
sentations. In Alshawi 1996, I provide a denota-
tional semantics for a simple under-specified lan-
guage and argue for extending this treatment to a
formal semantics of natural language strings as ex-
pressions of an under-specified representation. In
this paradigm, ordered dependency trees can be
viewed as natural language strings annotated so that
some of the implicit relations are more explicit. A
milder form of this kind of annotation is a bracketed
natural language string. We are not advocating an
approach in which linguistic structure is ignored (as
it is in the IBM translator described by Brown et
al. 1990), but rather one in which the syntactic and
semantic structure of a string is implicit in the way
it is processed by an interpreter.
One important advantage of using representations
that are close to natural language itself is that it re-
duces the degrees of freedom in specifying language
and task models, making these models easier to ac-
</bodyText>
<page confidence="0.995207">
175
</page>
<bodyText confidence="0.999957666666667">
quire automatically. With these considerations in
mind, we have started to experiment with a version
of the translator described here with even simpler
representations and for which the model structure,
not just the parameters, can be acquired automati-
cally.
</bodyText>
<sectionHeader confidence="0.998935" genericHeader="acknowledgments">
Acknowledgments
</sectionHeader>
<bodyText confidence="0.989134">
The work on cost functions and training methods
was carried out jointly with Adam Buchsbaum who
also customized the English model to ATIS and in-
tegrated the translator into our speech translation
prototype. Jishen He constructed the Chinese ATIS
language model and bilingual lexicon and identified
many problems with early versions of the transfer
component. I am also grateful for advice and help
from Don Hindle, Fernando Pereira, Chi-Lin Shih,
Richard Sproat, and Bin Wu.
</bodyText>
<sectionHeader confidence="0.998308" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.99994672">
Alshawi, H. 1987. Memory and Context for Language
Interpretation. Cambridge University Press, Cambridge,
England.
Alshawi, H. 1996. &amp;quot;Underspecified First Order Log-
ics&amp;quot;. In Semantic Ambiguity and Underspecification,
edited by K. van Deemter and S. Peters, CSLI Publi-
cations, Stanford, California.
Alshawi, H. 1992. The Core Language Engine. MIT
Press, Cambridge, Massachusetts.
Alshawi, H., D. Carter, B. Gamback and M. Rayner.
1992. &amp;quot;Swedish-English QLF Translation&amp;quot;. In H. Al-
shawi (ed.) The Core Language Engine. MIT Press,
Cambridge, Massachusetts.
Booth, T. 1969. &amp;quot;Probabilistic Representation of For-
mal Languages&amp;quot;. Tenth Annual IEEE Symposium on
Switching and Automata Theory.
Brew, C. 1992. &amp;quot;Letting the Cat out of the Bag: Gen-
eration for Shake-and-Bake MT&amp;quot;. Proceedings of COL-
ING92, the International Conference on Computational
Linguistics, Nantes, France.
Brown, P., J. Cocke, S. Della Pietra, V. Della Pietra,
F. Jelinek, J. Lafferty, R. Mercer and P. Rossin. 1990.
&amp;quot;A Statistical Approach to Machine Translation&amp;quot;. Com-
putational Linguistics 16:79-85.
Brown, P.F., S.A. Della Pietra, V.J. Della Pietra, and
R.L. Mercer. 1993. &amp;quot;The Mathematics of Statistical
Machine Translation: Parameter Estimation&amp;quot;. Compu-
tational Linguistics 19:263-312.
Chen, K.H. and H. H. Chen. 1992. &amp;quot;Attachment and
Transfer of Prepositional Phrases with Constraint Prop-
agation&amp;quot;. Computer Processing of Chinese and Oriental
Languages, Vol. 6, No. 2, 123-142.
Church K. and R. Patil. 1982. &amp;quot;Coping with Syntactic
Ambiguity or How to Put the Block in the Box on the
Table&amp;quot;. Computational Linguistics 8:139-149.
Collins, M. and J. Brooks. 1995. &amp;quot;Prepositional
Phrase Attachment through a Backed-Off Model.&amp;quot; Pro-
ceedings of the Third Workshop on Very Large Corpora,
Cambridge, Massachusetts, ACL, 27-38.
Dorr, B.J. 1994. &amp;quot;Machine Translation Divergences:
A Formal Description and Proposed Solution&amp;quot;. Compu-
tational Linguistics 20:597-634.
Dunning, T. 1993. &amp;quot;Accurate Methods for Statistics of
Surprise and Coincidence.&amp;quot; Computational Linguistics.
19:61-74.
Early, J. 1970. &amp;quot;An Efficient Context-Free Parsing
Algorithm&amp;quot;. Communications of the ACM 14: 453-60.
Gazdar, G., E. Klein, G.K. Pullum, and I.A.Sag.
1985. Generalised Phrase Structure Grammar. Black-
well, Oxford.
Hinton, G.E., P. Dayan, B.J. Frey and R.M. Neal.
1995. &amp;quot;The `Wake-Sleep&apos; Algorithm for Unsupervised
Neural Networks&amp;quot;. Science 268:1158-1161.
Hudson, R.A. 1984. Word Grammar. Blackwell, Ox-
ford.
Hirschman, L., M. Bates, D. Dahl, W. Fisher, J. Garo-
folo, D. Pallett, K. Hunicke-Smith, P. Price, A. Rud-
nicky, and E. Tzoukermann. 1993. &amp;quot;Multi-Site Data
Collection and Evaluation in Spoken Language Under-
standing&amp;quot;. In Proceedings of the Human Language Tech-
nology Workshop, Morgan Kaufmann, San Francisco,
19-24.
Isabelle, P. and E. Macklovitch. 1986. &amp;quot;Transfer and
MT Modularity&amp;quot;, Eleventh International Conference on
Computational Linguistics, Bonn, Germany, 115-117.
Jackendoff, R.S. 1977. X-bar Syntax: A Study
of Phrase Structure. MIT Press, Cambridge, Mas-
sachusetts.
Jelinek, F., R.L. Mercer and S. Roukos. 1992. &amp;quot;Prin-
ciples of Lexical Language Modeling for Speech Recog-
nition&amp;quot;. In S. Furui and M.M. Sondhi (eds.), Advances
in Speech Signal Processing, Marcel Dekker, New York.
Lafferty, J., D. Sleator and D. Temperley. 1992.
&amp;quot;Grammatical Trigrams: A Probabilistic Model of Link
Grammar&amp;quot;. In Proceedings of the 1992 AAAI Fall Sym-
posium on Probabilistic Approaches to Natural Language,
89-97.
Kay, M. 1989. &amp;quot;Head Driven Parsing&amp;quot;. In Proceed-
ings of the Workshop on Parsing Technologies, Pitts-
burg, 1989.
Lindop, J. and J. Tsujii. 1991. &amp;quot;Complex Transfer
in MT: A Survey of Examples&amp;quot;. Technical Report 91/5,
Centre for Computational Linguistics, UMIST, Manch-
ester, UK.
Resnik, P. 1992. &amp;quot;Probabilistic Tree-Adjoining Gram-
mar as a Framework for Statistical Natural Language
Processing&amp;quot;. In Proceedings of COLING-92, Nantes,
France, 418-424.
Sata, G. and 0. Stock. 1989. &amp;quot;Head-Driven Bidi-
rectional Parsing&amp;quot;. In Proceedings of the Workshop on
Parsing Technologies, Pittsburg, 1989.
Schabes, Y. 1992. &amp;quot;Stochastic Lexicalized Tree-
Adjoining Grammars&amp;quot;. In Proceedings of COLING-92,
Nantes, France, 426-432.
Whitelock, P.J. 1992. &amp;quot;Shake-and-Bake Translation&amp;quot;.
Proceedings of COLING92, the International Conference
on Computational Linguistics, Nantes, France.
Younger, D. 1967. Recognition and Parsing of
Context-Free Languages in Time n3. Information and
Control, 10,189-208.
</reference>
<page confidence="0.998746">
176
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.981884">
<title confidence="0.998323333333333">INVITED TALK Head Automata and Bilingual Tiling: Translation with Minimal Representations</title>
<author confidence="0.995491">Hiyan Alshawi</author>
<affiliation confidence="0.999948">AT&amp;T Research</affiliation>
<address confidence="0.999907">600 Mountain Avenue, Murray Hill, NJ 07974, USA</address>
<email confidence="0.999708">hiyan@research.att.com</email>
<abstract confidence="0.999501764705882">We present a language model consisting of a collection of costed bidirectional finite state automata associated with the head words of phrases. The model is suitable for incremental application of lexical associations in a dynamic programming search for optimal dependency tree derivations. We also present a model and algorithm for machine translation involving optimal &amp;quot;tiling&amp;quot; of a dependency tree with entries of a costed bilingual lexicon. Experimental results are reported comparing methods for assigning cost functions to these models. We conclude with a discussion of the adequacy of annotated linguistic strings as representations for machine translation.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>H Alshawi</author>
</authors>
<title>Memory and Context for Language Interpretation.</title>
<date>1987</date>
<publisher>Cambridge University Press,</publisher>
<location>Cambridge, England.</location>
<contexts>
<context position="41986" citStr="Alshawi 1987" startWordPosition="7140" endWordPosition="7141">ven the intended meaning. The fact that translation is insensitive to many ambiguities motivated the use of unresolved quasi-logical form for transfer (Alshawi et al. 1992). To the extent that contextual resolution is necessary, context may be provided by the state of the language processor rather than complex semantic representations. Local context may include the state of local processing components (such as our head automata) for capturing grammatical constraints, or the identity of other words in a phrase for capturing sense distinctions. For larger scale context, I have argued elsewhere (Alshawi 1987) that memory activation patterns resulting from the process of carrying out an understanding task can act as global context without explicit representations of discourse. Under this view, the challenge is how to exploit context in performing a task rather than how to map natural language phrases to expressions of a formalism for coding meaning independently of context or intended use. There is now greater understanding of the formal semantics of under-specified and ambiguous representations. In Alshawi 1996, I provide a denotational semantics for a simple under-specified language and argue for</context>
</contexts>
<marker>Alshawi, 1987</marker>
<rawString>Alshawi, H. 1987. Memory and Context for Language Interpretation. Cambridge University Press, Cambridge, England.</rawString>
</citation>
<citation valid="true">
<authors>
<author>H Alshawi</author>
</authors>
<title>Underspecified First Order Logics&amp;quot;. In Semantic Ambiguity and Underspecification, edited by K. van Deemter</title>
<date>1996</date>
<publisher>CSLI Publications,</publisher>
<location>Stanford, California.</location>
<contexts>
<context position="42498" citStr="Alshawi 1996" startWordPosition="7222" endWordPosition="7223">e for capturing sense distinctions. For larger scale context, I have argued elsewhere (Alshawi 1987) that memory activation patterns resulting from the process of carrying out an understanding task can act as global context without explicit representations of discourse. Under this view, the challenge is how to exploit context in performing a task rather than how to map natural language phrases to expressions of a formalism for coding meaning independently of context or intended use. There is now greater understanding of the formal semantics of under-specified and ambiguous representations. In Alshawi 1996, I provide a denotational semantics for a simple under-specified language and argue for extending this treatment to a formal semantics of natural language strings as expressions of an under-specified representation. In this paradigm, ordered dependency trees can be viewed as natural language strings annotated so that some of the implicit relations are more explicit. A milder form of this kind of annotation is a bracketed natural language string. We are not advocating an approach in which linguistic structure is ignored (as it is in the IBM translator described by Brown et al. 1990), but rathe</context>
</contexts>
<marker>Alshawi, 1996</marker>
<rawString>Alshawi, H. 1996. &amp;quot;Underspecified First Order Logics&amp;quot;. In Semantic Ambiguity and Underspecification, edited by K. van Deemter and S. Peters, CSLI Publications, Stanford, California.</rawString>
</citation>
<citation valid="true">
<authors>
<author>H Alshawi</author>
</authors>
<title>The Core Language Engine.</title>
<date>1992</date>
<publisher>MIT Press,</publisher>
<location>Cambridge, Massachusetts.</location>
<contexts>
<context position="39858" citStr="Alshawi 1992" startWordPosition="6808" endWordPosition="6809">he following comparisons: C and E each outperformed B and D, and B and D each outperformed A. 7 Language Processing and Semantic Representations The translation system we have described employs only simple representations of sentences and phrases. Apart from the words themselves, the only symbols used are the dependency relations R. In our experimental system, these relation symbols are themselves natural language words, although this is not a necessary property of our models. Information coded explicitly in sentence representations by word senses and feature constraints in our previous work (Alshawi 1992) is implicit in the models used to derive the dependency trees and translations. In particular, dependency parameters and context-dependent transfer parameters give rise to an implicit, graded notion of word sense. For language-centered applications like translation or summarization, for which we have a large body of examples of the desired behavior, we can think of the task in terms of the formal problem of modeling a relation between strings based on examples of that relation. By taking this viewpoint, we seem to be ignoring the intuition that most interesting natural language processing tas</context>
</contexts>
<marker>Alshawi, 1992</marker>
<rawString>Alshawi, H. 1992. The Core Language Engine. MIT Press, Cambridge, Massachusetts.</rawString>
</citation>
<citation valid="true">
<authors>
<author>H Alshawi</author>
<author>D Carter</author>
<author>B Gamback</author>
<author>M Rayner</author>
</authors>
<title>Swedish-English QLF Translation&amp;quot;.</title>
<date>1992</date>
<booktitle>The Core Language Engine.</booktitle>
<editor>In H. Alshawi (ed.)</editor>
<publisher>MIT Press,</publisher>
<location>Cambridge, Massachusetts.</location>
<contexts>
<context position="27840" citStr="Alshawi et al. 1992" startWordPosition="4845" endWordPosition="4848">ls in T U Gi U P U Pi) and CG, is the cost of the arcs G&apos; in the target language model. 7. For any source node n for which f (n) and f2(n) are both defined, merge these two target nodes. 8. Repeat from step 2. Keeping the arcs P separate in the configuration allows efficient incremental application of target dependency costs CG&apos; during the search, so these costs are taken into account in the pruning step of the overall search control. This way we can keep the benefits of monolingual/bilingual modularity (Isabelle and Macklovitch 1986) without the computational overhead of transfer-and-filter (Alshawi et al. 1992). 172 It is possible to apply the subtree search directly to the whole graph starting with the initial runtime entries from lexical matching. However, this would result in an exponential search, specifically a search tree with a branching factor of the order of the number of matching entries per input word. Fortunately, long sentences typically have several decomposition nodes, such as the heads of noun phrases, so the search as described is factored into manageable components. 5 Cost Functions 5.1 Costed Search Processes The head automata model and transfer model were originally conceived as </context>
<context position="41545" citStr="Alshawi et al. 1992" startWordPosition="7068" endWordPosition="7071"> is the primary function of natural language. The main justification for artificial semantic representation languages is that they are unambiguous by design. This may not be as critical, or useful, as it might first appear. While it is true that natural language is ambiguous and under-specified out of context, this uncertainty is greatly reduced by context to the point where further resolution (e.g. full scoping) is irrelevant to the task, or even the intended meaning. The fact that translation is insensitive to many ambiguities motivated the use of unresolved quasi-logical form for transfer (Alshawi et al. 1992). To the extent that contextual resolution is necessary, context may be provided by the state of the language processor rather than complex semantic representations. Local context may include the state of local processing components (such as our head automata) for capturing grammatical constraints, or the identity of other words in a phrase for capturing sense distinctions. For larger scale context, I have argued elsewhere (Alshawi 1987) that memory activation patterns resulting from the process of carrying out an understanding task can act as global context without explicit representations of</context>
</contexts>
<marker>Alshawi, Carter, Gamback, Rayner, 1992</marker>
<rawString>Alshawi, H., D. Carter, B. Gamback and M. Rayner. 1992. &amp;quot;Swedish-English QLF Translation&amp;quot;. In H. Alshawi (ed.) The Core Language Engine. MIT Press, Cambridge, Massachusetts.</rawString>
</citation>
<citation valid="true">
<authors>
<author>T Booth</author>
</authors>
<title>Probabilistic Representation of Formal Languages&amp;quot;.</title>
<date>1969</date>
<booktitle>Tenth Annual IEEE Symposium on Switching and Automata Theory.</booktitle>
<contexts>
<context position="2633" citStr="Booth 1969" startWordPosition="387" endWordPosition="388">ocessing task can be carried out without complex semantic representations. In Section 2 we present reversible mono-lingual models consisting of collections of simple automata associated with the heads of phrases. These head automata are applied by an algorithm with admissible incremental pruning based on semantic association costs, providing a practical solution to the problem of combinatoric disambiguation (Church and Patil 1982). The model is intended to combine the lexical sensitivity of N-gram models (Jelinek et al. 1992) and the structural properties of statistical context free grammars (Booth 1969) without the computational overhead of statistical lexicalized treeadjoining grammars (Schabes 1992, Resnik 1992). For translation, we use a model for mapping dependency graphs written by the source language head automata. This model is coded entirely as a bilingual lexicon, with associated cost parameters. The transfer algorithm described in Section 4 searches for the lowest cost &apos;tiling&apos; of the target dependency graph with entries from the bilingual lexicon. Dynamic programming is again used to make exhaustive search tractable, avoiding the combinatoric explosion of shake-and-bake translatio</context>
</contexts>
<marker>Booth, 1969</marker>
<rawString>Booth, T. 1969. &amp;quot;Probabilistic Representation of Formal Languages&amp;quot;. Tenth Annual IEEE Symposium on Switching and Automata Theory.</rawString>
</citation>
<citation valid="true">
<authors>
<author>C Brew</author>
</authors>
<title>Letting the Cat out of the Bag: Generation for Shake-and-Bake MT&amp;quot;.</title>
<date>1992</date>
<booktitle>Proceedings of COLING92, the International Conference on Computational Linguistics,</booktitle>
<location>Nantes, France.</location>
<contexts>
<context position="3262" citStr="Brew 1992" startWordPosition="480" endWordPosition="481">ational overhead of statistical lexicalized treeadjoining grammars (Schabes 1992, Resnik 1992). For translation, we use a model for mapping dependency graphs written by the source language head automata. This model is coded entirely as a bilingual lexicon, with associated cost parameters. The transfer algorithm described in Section 4 searches for the lowest cost &apos;tiling&apos; of the target dependency graph with entries from the bilingual lexicon. Dynamic programming is again used to make exhaustive search tractable, avoiding the combinatoric explosion of shake-and-bake translation (Whitelock 1992, Brew 1992). In Section 5 we present a general framework for associating costs with the solutions of search processes, pointing out some benefits of cost functions other than log likelihood, including an error-minimization cost function for unsupervised training of the parameters in our translation application. Section 6 briefly describes an English-Chinese translator employing the models and algorithms. We also present experimental results comparing the performance of different cost assignment methods. Finally, we return to the more general discussion of representations for machine translation and other</context>
</contexts>
<marker>Brew, 1992</marker>
<rawString>Brew, C. 1992. &amp;quot;Letting the Cat out of the Bag: Generation for Shake-and-Bake MT&amp;quot;. Proceedings of COLING92, the International Conference on Computational Linguistics, Nantes, France.</rawString>
</citation>
<citation valid="true">
<authors>
<author>P Brown</author>
<author>J Cocke</author>
<author>S Della Pietra</author>
<author>V Della Pietra</author>
<author>F Jelinek</author>
<author>J Lafferty</author>
<author>R Mercer</author>
<author>P Rossin</author>
</authors>
<title>A Statistical Approach to Machine Translation&amp;quot;.</title>
<date>1990</date>
<journal>Computational Linguistics</journal>
<pages>16--79</pages>
<contexts>
<context position="22646" citStr="Brown et al. 1990" startWordPosition="3894" endWordPosition="3897">in the tiling. • The nodes and arcs of T are composed of the nodes and arcs of the target fragments Gi for the entries Ei. • Let fi and fi be the mapping functions for entries Ei and E. For any node n of S for which target nodes fi(gT1(n)) and fi(e(n)) are defined, these two nodes are identified as a single node f(n) in T. The merging of target fragment nodes in the last condition has the effect of joining the target fragments in a consistent fashion. The node mapping function f for the entire tree thus has a different role from the alignment function in the IBM statistical translation model (Brown et al. 1990, 1993); the role of the latter includes the linear ordering of words in the target string. In our approach, target word order is handled exclusively by the target monolingual model. 4.3 Transfer Algorithm The main transfer search is preceded by a bilingual lexicon matching phase. This leads to greater efficiency as it avoids repeating matching operations during the search phase, and it allows a static analysis of the matching entries and source tree to identify subtrees for which the search phase can safely prune out suboptimal partial translations. Transfer Configurations In order to apply t</context>
<context position="43087" citStr="Brown et al. 1990" startWordPosition="7316" endWordPosition="7319">resentations. In Alshawi 1996, I provide a denotational semantics for a simple under-specified language and argue for extending this treatment to a formal semantics of natural language strings as expressions of an under-specified representation. In this paradigm, ordered dependency trees can be viewed as natural language strings annotated so that some of the implicit relations are more explicit. A milder form of this kind of annotation is a bracketed natural language string. We are not advocating an approach in which linguistic structure is ignored (as it is in the IBM translator described by Brown et al. 1990), but rather one in which the syntactic and semantic structure of a string is implicit in the way it is processed by an interpreter. One important advantage of using representations that are close to natural language itself is that it reduces the degrees of freedom in specifying language and task models, making these models easier to ac175 quire automatically. With these considerations in mind, we have started to experiment with a version of the translator described here with even simpler representations and for which the model structure, not just the parameters, can be acquired automatically.</context>
</contexts>
<marker>Brown, Cocke, Pietra, Pietra, Jelinek, Lafferty, Mercer, Rossin, 1990</marker>
<rawString>Brown, P., J. Cocke, S. Della Pietra, V. Della Pietra, F. Jelinek, J. Lafferty, R. Mercer and P. Rossin. 1990. &amp;quot;A Statistical Approach to Machine Translation&amp;quot;. Computational Linguistics 16:79-85.</rawString>
</citation>
<citation valid="true">
<authors>
<author>P F Brown</author>
<author>S A Della Pietra</author>
<author>V J Della Pietra</author>
<author>R L Mercer</author>
</authors>
<title>The Mathematics of Statistical Machine Translation: Parameter Estimation&amp;quot;.</title>
<date>1993</date>
<journal>Computational Linguistics</journal>
<pages>19--263</pages>
<marker>Brown, Pietra, Pietra, Mercer, 1993</marker>
<rawString>Brown, P.F., S.A. Della Pietra, V.J. Della Pietra, and R.L. Mercer. 1993. &amp;quot;The Mathematics of Statistical Machine Translation: Parameter Estimation&amp;quot;. Computational Linguistics 19:263-312.</rawString>
</citation>
<citation valid="true">
<authors>
<author>K H Chen</author>
<author>H H Chen</author>
</authors>
<title>Attachment and Transfer of Prepositional Phrases with Constraint Propagation&amp;quot;.</title>
<date>1992</date>
<booktitle>Computer Processing of Chinese and Oriental Languages,</booktitle>
<volume>6</volume>
<pages>123--142</pages>
<contexts>
<context position="35913" citStr="Chen and Chen 1992" startWordPosition="6183" endWordPosition="6186">pervised training set, both sets being chosen at random from the 20,000 or so ATIS sentences available to us. The supervised training set comprised around 1950 sentences. A subcollection of 1150 of these sentences were translated by the system, and the resulting translations manually classified as &apos;good&apos; (800 translations) or &apos;bad&apos; (350 translations). The remaining 800 supervised training set sentences were hand-tagged for prepositional attachment points. (Prepositional phrase attachment is a major cause of ambiguity in the ATIS corpus, and moreover can affect English-Chinese translation, see Chen and Chen 1992.) The attachment information was used to generate additional negative and positive counts for dependency choices. The unsupervised training set consisted of approximately 13,000 sentences; it was used for automatic training (as described under &apos;Reflexive Training&apos; above) by translating the sentences into Chinese and back to English. A. Qualitative Baseline: In this model, all choices were assigned the same cost except for irregular events (such as unknown words or partial analyses) which were all assigned a high penalty cost. This model gives an indication of performance based solely on model</context>
</contexts>
<marker>Chen, Chen, 1992</marker>
<rawString>Chen, K.H. and H. H. Chen. 1992. &amp;quot;Attachment and Transfer of Prepositional Phrases with Constraint Propagation&amp;quot;. Computer Processing of Chinese and Oriental Languages, Vol. 6, No. 2, 123-142.</rawString>
</citation>
<citation valid="true">
<authors>
<author>K Church</author>
<author>R Patil</author>
</authors>
<title>Coping with Syntactic Ambiguity or How to Put the Block in the Box on the Table&amp;quot;.</title>
<date>1982</date>
<journal>Computational Linguistics</journal>
<pages>8--139</pages>
<contexts>
<context position="2456" citStr="Church and Patil 1982" startWordPosition="357" endWordPosition="360">lation, the oldest and still the most commonplace application of nonsuperficial natural language processing. A secondary motivation is to test the extent to which a non-trivial language processing task can be carried out without complex semantic representations. In Section 2 we present reversible mono-lingual models consisting of collections of simple automata associated with the heads of phrases. These head automata are applied by an algorithm with admissible incremental pruning based on semantic association costs, providing a practical solution to the problem of combinatoric disambiguation (Church and Patil 1982). The model is intended to combine the lexical sensitivity of N-gram models (Jelinek et al. 1992) and the structural properties of statistical context free grammars (Booth 1969) without the computational overhead of statistical lexicalized treeadjoining grammars (Schabes 1992, Resnik 1992). For translation, we use a model for mapping dependency graphs written by the source language head automata. This model is coded entirely as a bilingual lexicon, with associated cost parameters. The transfer algorithm described in Section 4 searches for the lowest cost &apos;tiling&apos; of the target dependency graph</context>
</contexts>
<marker>Church, Patil, 1982</marker>
<rawString>Church K. and R. Patil. 1982. &amp;quot;Coping with Syntactic Ambiguity or How to Put the Block in the Box on the Table&amp;quot;. Computational Linguistics 8:139-149.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Collins</author>
<author>J Brooks</author>
</authors>
<title>Prepositional Phrase Attachment through a Backed-Off Model.&amp;quot;</title>
<date>1995</date>
<booktitle>Proceedings of the Third Workshop on Very Large Corpora,</booktitle>
<pages>27--38</pages>
<location>Cambridge, Massachusetts, ACL,</location>
<contexts>
<context position="30355" citStr="Collins and Brooks (1995)" startWordPosition="5262" endWordPosition="5265"> to be the sum of costs of choices involved in the derivation. We represent events and contexts by finite sequences of symbols (typically words or relation symbols in the translation application). We write C(al • • • an Ibi • • • bk) for the cost of the event represented by (al • • an) in the context represented by(bi • • bk)• &amp;quot;Backed off&amp;quot; costs can be computed by averaging over larger equivalence classes (represented by shorter sequences in which positions are eliminated systematically). A similar smoothing technique has been applied to the specific case of prepositional phrase attachment by Collins and Brooks (1995). We have used backed off costs in the translation application for the various cost functions described below. Although this resulted in some improvement in testing, so far the improvement has not been statistically significant. 5.2 Model Cost Functions Taken together, the events, contexts, and cost function constitute a process cost model, or simply a model. The cost function specifies the model parameters; the other components are the model structure. We have experimented with a number of model types, including the following. Probabilistic model: In this model we assume a probability distrib</context>
</contexts>
<marker>Collins, Brooks, 1995</marker>
<rawString>Collins, M. and J. Brooks. 1995. &amp;quot;Prepositional Phrase Attachment through a Backed-Off Model.&amp;quot; Proceedings of the Third Workshop on Very Large Corpora, Cambridge, Massachusetts, ACL, 27-38.</rawString>
</citation>
<citation valid="true">
<authors>
<author>B J Dorr</author>
</authors>
<title>Machine Translation Divergences: A Formal Description and Proposed Solution&amp;quot;.</title>
<date>1994</date>
<journal>Computational Linguistics</journal>
<pages>20--597</pages>
<contexts>
<context position="18132" citStr="Dorr 1994" startWordPosition="3042" endWordPosition="3043">sfer component, influencing the choice of structure passed to the generator. 4 Transfer Maps 4.1 Transfer Model Bilingual Lexicon The transfer model defines possible mappings, with associated costs, of dependency trees with sourcelanguage word node labels into ones with targetlanguage word labels. Unlike the head automata monolingual models, the transfer model operates with unordered dependency trees, that is, it treats the dependents of a word as an unordered bag. The model is general enough to cover the common translation problems discussed in the literature (e.g. Lindop and Tsujii 1991 and Dorr 1994) including manyto-many word mapping, argument switching, and head switching. A transfer model consists of a bilingual lexicon and a transfer parameter table. The model uses dependency tree fragments, which are the same as unordered dependency trees except that some nodes may not have word labels. In the bilingual lexicon, an entry for a source word wi (see top portion of Figure 2) has the form (wi, Hi,ni,Gi, fi) where Hi is a source language tree fragment, ni (the primary node) is a distinguished node of Hi with label wi, Gi is a target tree fragment, and fi is a 170 mapping function, i.e. a (</context>
</contexts>
<marker>Dorr, 1994</marker>
<rawString>Dorr, B.J. 1994. &amp;quot;Machine Translation Divergences: A Formal Description and Proposed Solution&amp;quot;. Computational Linguistics 20:597-634.</rawString>
</citation>
<citation valid="true">
<authors>
<author>T Dunning</author>
</authors>
<title>Accurate Methods for Statistics of Surprise and Coincidence.&amp;quot; Computational Linguistics.</title>
<date>1993</date>
<pages>19--61</pages>
<contexts>
<context position="31604" citStr="Dunning 1993" startWordPosition="5466" endWordPosition="5467">ntext, that is, Ee P(elc)= 1. The cost parameters of the model are defined as: C(elc)= —1n(P(elc)). Given a set of solutions from executions of a process, let n+(e lc) be the number of times choice (elc) was taken leading to acceptable solutions (e.g. correct translations) and n+ (c) be the number of times context c was encountered for these solutions. We can then estimate the probabilistic model costs with ln(n+ (c)) — In(n+(e10)- Discriminative model: The costs in this model are likelihood ratios comparing positive and negative solutions, for example correct and incorrect translations. (See Dunning 1993 on the application of likelihood ratios in computational linguistics.) Let n(elc) be the count for choice (elc) leading to negative solutions. The cost function for the discriminative model is estimated as C(elc);,-, ln(n- (e 1c)) — In(n+(eic)). Mean distance model: In the mean distance model, we make use of some measure of goodness of a solution 13 for some input s by comparing it against an ideal solution 13 for s with a distance metric h: d in which d is a non-negative real number. A parameter for choice (elc) in the distance model C(elc)= Eh(elc) is the mean value of h(ts, is) for solutio</context>
</contexts>
<marker>Dunning, 1993</marker>
<rawString>Dunning, T. 1993. &amp;quot;Accurate Methods for Statistics of Surprise and Coincidence.&amp;quot; Computational Linguistics. 19:61-74.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Early</author>
</authors>
<title>An Efficient Context-Free Parsing Algorithm&amp;quot;.</title>
<date>1970</date>
<journal>Communications of the ACM</journal>
<volume>14</volume>
<pages>453--60</pages>
<contexts>
<context position="12330" citStr="Early 1970" startWordPosition="2025" endWordPosition="2026">thout scoring an exponential number of syntactic parses. Since the model is lexical, linguistic constructions headed by lexical items not present in the input are not involved in the search the way they are with typical top-down or predictive parsing strategies. We will sketch an algorithm for finding the lowest cost ordered dependency tree derivation for an input string in polynomial time in the length of the string. In our experimental system we use a more general version of the algorithm to allow input in the form of word lattices. The algorithm is a bottom-up tabular parser (Younger 1967, Early 1970) in which constituents are constructed &amp;quot;head-outwards&amp;quot; (Kay 1989, Sata and Stock 1989). Since we are analyzing bottomup with generative model automata, the algorithm &apos;runs&apos; the automata backwards. Edges in the parsing lattice (or &amp;quot;chart&amp;quot;) are tuples representing partial or complete phrases headed by a word w from position i to position j in the string: (w, t, j, m, q, c). Here in is the head automaton for w in this derivation; the automaton is in state q; t is the dependency tree constructed so far, and c is the cost of the partial derivation. We will use the notation C(xly) for the cost of a </context>
</contexts>
<marker>Early, 1970</marker>
<rawString>Early, J. 1970. &amp;quot;An Efficient Context-Free Parsing Algorithm&amp;quot;. Communications of the ACM 14: 453-60.</rawString>
</citation>
<citation valid="true">
<authors>
<author>G Gazdar</author>
<author>E Klein</author>
<author>G K Pullum</author>
<author>I A Sag</author>
</authors>
<title>Generalised Phrase Structure Grammar.</title>
<date>1985</date>
<publisher>Blackwell,</publisher>
<location>Oxford.</location>
<contexts>
<context position="8231" citStr="Gazdar et al. 1985" startWordPosition="1340" endWordPosition="1343">ir of symbol sequence thus corresponds to the selection of an initial state, a sequence of zero or more transitions (writing the symbols) and a stop action. The probability, given an initial state q, that automaton in will a generate a pair of sequences, i.e. P((ri • • • rk),(rk+i • • r)1m, q) is the product of the probabilities of the actions taken to generate the sequences. The case of zero transitions will yield empty sequences, corresponding to a leaf node of the dependency tree. From a linguistic perspective, head automata allow for a compact, graded, notion of lexical subcategorization (Gazdar et al. 1985) and the linear order of a head and its dependent phrases. Lexical parameters can control the saturation of a lexical item (for example a verb that is both transitive and intransitive) by starting the same automaton in different states. Head automata can also be used to code a grammar in which states of an automaton for word w corresponds to X-bar levels (Jackendoff 1977) for phrases headed by w. Head automata are formally more powerful than finite state automata that accept regular languages in the following sense. Each head automaton defines a formal language with alphabet R whose strings ar</context>
</contexts>
<marker>Gazdar, Klein, Pullum, Sag, 1985</marker>
<rawString>Gazdar, G., E. Klein, G.K. Pullum, and I.A.Sag. 1985. Generalised Phrase Structure Grammar. Blackwell, Oxford.</rawString>
</citation>
<citation valid="true">
<authors>
<author>G E Hinton</author>
<author>P Dayan</author>
<author>B J Frey</author>
<author>R M Neal</author>
</authors>
<title>The `Wake-Sleep&apos; Algorithm for Unsupervised Neural Networks&amp;quot;.</title>
<date>1995</date>
<journal>Science</journal>
<pages>268--1158</pages>
<contexts>
<context position="33515" citStr="Hinton et al. 1995" startWordPosition="5796" endWordPosition="5799">ivations involving the context for that choice. Reflexive Training If we have a manually translated corpus, we can apply the mean and normalized distance models to translation by taking the ideal solution t, for translating a source string s to be the manual translation for s. In the absence of good metrics for comparing translations, we employ a heuristic string distance metric to compare word selection and word order in t, and t,. In order to train the model parameters without a manually translated corpus, we use a &amp;quot;reflexive&amp;quot; training method (similar in spirit to the &amp;quot;wakesleep&amp;quot; algorithm, Hinton et al. 1995). In this method, our search process translates a source sentence s to t, in the target language and then translates t, back to a source language sentence s&apos;. The original sentence s can then act as the ideal solution of the overall process. For this training method to be effective, we need a reasonably good initial model, i.e. one for which the distance h(s, s&apos;) is inversely correlated with the probability that ts is a good translation of s. 6 Experimental System We have built an experimental translation system using the monolingual and translation models described in this paper. The system t</context>
</contexts>
<marker>Hinton, Dayan, Frey, Neal, 1995</marker>
<rawString>Hinton, G.E., P. Dayan, B.J. Frey and R.M. Neal. 1995. &amp;quot;The `Wake-Sleep&apos; Algorithm for Unsupervised Neural Networks&amp;quot;. Science 268:1158-1161.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R A Hudson</author>
</authors>
<title>Word Grammar.</title>
<date>1984</date>
<publisher>Blackwell,</publisher>
<location>Oxford.</location>
<contexts>
<context position="4558" citStr="Hudson 1984" startWordPosition="680" endWordPosition="681">e to natural language itself. 2 Head Automata Language Models 2.1 Lexical and Dependency Parameters Head automata mono-lingual language models consist of a lexicon, in which each entry is a pair (w, m) of a word w from a vocabulary V and a head automaton in (defined below), and a parameter table giving an assignment of costs to events in a generative process involving the automata. 167 We first describe the model in terms of the familiar paradigm of a generative statistical model, presenting the parameters as conditional probabilities. This gives us a stochastic version of dependency grammar (Hudson 1984). Each derivation in the generative statistical model produces an ordered dependency free, that is, a tree in which nodes dominate ordered sequences of left and right subtrees and in which the nodes have labels taken from the vocabulary V and the arcs have labels taken from a set R of relation symbols. When a node with label w immediately dominates a node with label w&apos; via an arc with label r, we say that w&apos; is an r-dependent of the head w. The interpretation of this directed arc is that relation r holds between particular instances of w and w&apos;. (A word may have several or no r-dependents for </context>
</contexts>
<marker>Hudson, 1984</marker>
<rawString>Hudson, R.A. 1984. Word Grammar. Blackwell, Oxford.</rawString>
</citation>
<citation valid="true">
<authors>
<author>L Hirschman</author>
<author>M Bates</author>
<author>D Dahl</author>
<author>W Fisher</author>
<author>J Garofolo</author>
<author>D Pallett</author>
<author>K Hunicke-Smith</author>
<author>P Price</author>
<author>A Rudnicky</author>
<author>E Tzoukermann</author>
</authors>
<title>Multi-Site Data Collection and Evaluation in Spoken Language Understanding&amp;quot;.</title>
<date>1993</date>
<booktitle>In Proceedings of the Human Language Technology Workshop,</booktitle>
<publisher>Morgan Kaufmann,</publisher>
<location>San Francisco,</location>
<contexts>
<context position="34177" citStr="Hirschman et al. 1993" startWordPosition="5913" endWordPosition="5916">nslates a source sentence s to t, in the target language and then translates t, back to a source language sentence s&apos;. The original sentence s can then act as the ideal solution of the overall process. For this training method to be effective, we need a reasonably good initial model, i.e. one for which the distance h(s, s&apos;) is inversely correlated with the probability that ts is a good translation of s. 6 Experimental System We have built an experimental translation system using the monolingual and translation models described in this paper. The system translates sentences in the ATIS domain (Hirschman et al. 1993) between English and Mandarin Chinese. The translator is in fact a subsystem of a speech translation prototype, though the experiments we describe here are for transcribed spoken utterances. (We informally refer to the transcribed utterances as sentences.) The average time taken for translation of sentences (of unrestricted length) from the ATIS corpus was around 1.7 seconds with approximately 0.4 seconds being taken by the analysis algorithm and 0.7 seconds by the transfer algorithm. English and Chinese lexicons of around 1200 and 1000 words respectively were constructed. Altogether, the entr</context>
</contexts>
<marker>Hirschman, Bates, Dahl, Fisher, Garofolo, Pallett, Hunicke-Smith, Price, Rudnicky, Tzoukermann, 1993</marker>
<rawString>Hirschman, L., M. Bates, D. Dahl, W. Fisher, J. Garofolo, D. Pallett, K. Hunicke-Smith, P. Price, A. Rudnicky, and E. Tzoukermann. 1993. &amp;quot;Multi-Site Data Collection and Evaluation in Spoken Language Understanding&amp;quot;. In Proceedings of the Human Language Technology Workshop, Morgan Kaufmann, San Francisco, 19-24.</rawString>
</citation>
<citation valid="true">
<authors>
<author>P Isabelle</author>
<author>E Macklovitch</author>
</authors>
<title>Transfer and MT Modularity&amp;quot;,</title>
<date>1986</date>
<booktitle>Eleventh International Conference on Computational Linguistics,</booktitle>
<pages>115--117</pages>
<location>Bonn, Germany,</location>
<contexts>
<context position="27760" citStr="Isabelle and Macklovitch 1986" startWordPosition="4833" endWordPosition="4837"> I —{i}), where G&apos; is the set of newly completed arcs (those in P U Pi with both node labels in T U Gi U P U Pi) and CG, is the cost of the arcs G&apos; in the target language model. 7. For any source node n for which f (n) and f2(n) are both defined, merge these two target nodes. 8. Repeat from step 2. Keeping the arcs P separate in the configuration allows efficient incremental application of target dependency costs CG&apos; during the search, so these costs are taken into account in the pruning step of the overall search control. This way we can keep the benefits of monolingual/bilingual modularity (Isabelle and Macklovitch 1986) without the computational overhead of transfer-and-filter (Alshawi et al. 1992). 172 It is possible to apply the subtree search directly to the whole graph starting with the initial runtime entries from lexical matching. However, this would result in an exponential search, specifically a search tree with a branching factor of the order of the number of matching entries per input word. Fortunately, long sentences typically have several decomposition nodes, such as the heads of noun phrases, so the search as described is factored into manageable components. 5 Cost Functions 5.1 Costed Search Pr</context>
</contexts>
<marker>Isabelle, Macklovitch, 1986</marker>
<rawString>Isabelle, P. and E. Macklovitch. 1986. &amp;quot;Transfer and MT Modularity&amp;quot;, Eleventh International Conference on Computational Linguistics, Bonn, Germany, 115-117.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R S Jackendoff</author>
</authors>
<title>X-bar Syntax: A Study of Phrase Structure.</title>
<date>1977</date>
<publisher>MIT Press,</publisher>
<location>Cambridge, Massachusetts.</location>
<contexts>
<context position="8605" citStr="Jackendoff 1977" startWordPosition="1408" endWordPosition="1409">. The case of zero transitions will yield empty sequences, corresponding to a leaf node of the dependency tree. From a linguistic perspective, head automata allow for a compact, graded, notion of lexical subcategorization (Gazdar et al. 1985) and the linear order of a head and its dependent phrases. Lexical parameters can control the saturation of a lexical item (for example a verb that is both transitive and intransitive) by starting the same automaton in different states. Head automata can also be used to code a grammar in which states of an automaton for word w corresponds to X-bar levels (Jackendoff 1977) for phrases headed by w. Head automata are formally more powerful than finite state automata that accept regular languages in the following sense. Each head automaton defines a formal language with alphabet R whose strings are the concatenation of the left and right sequence pairs rk rk+1 wi Wk Wk+1 Wn 168 written by the automaton. The class of languages defined in this way clearly includes all regular languages, since strings of a regular language can be generated, for example, by a head automaton that only writes a left sequence. Head automata can also accept some non-regular languages requ</context>
</contexts>
<marker>Jackendoff, 1977</marker>
<rawString>Jackendoff, R.S. 1977. X-bar Syntax: A Study of Phrase Structure. MIT Press, Cambridge, Massachusetts.</rawString>
</citation>
<citation valid="true">
<authors>
<author>F Jelinek</author>
<author>R L Mercer</author>
<author>S Roukos</author>
</authors>
<title>Principles of Lexical Language Modeling for Speech Recognition&amp;quot;.</title>
<date>1992</date>
<booktitle>Advances in Speech Signal Processing,</booktitle>
<editor>In S. Furui and M.M. Sondhi (eds.),</editor>
<publisher>Marcel Dekker,</publisher>
<location>New York.</location>
<contexts>
<context position="2553" citStr="Jelinek et al. 1992" startWordPosition="373" endWordPosition="376">ocessing. A secondary motivation is to test the extent to which a non-trivial language processing task can be carried out without complex semantic representations. In Section 2 we present reversible mono-lingual models consisting of collections of simple automata associated with the heads of phrases. These head automata are applied by an algorithm with admissible incremental pruning based on semantic association costs, providing a practical solution to the problem of combinatoric disambiguation (Church and Patil 1982). The model is intended to combine the lexical sensitivity of N-gram models (Jelinek et al. 1992) and the structural properties of statistical context free grammars (Booth 1969) without the computational overhead of statistical lexicalized treeadjoining grammars (Schabes 1992, Resnik 1992). For translation, we use a model for mapping dependency graphs written by the source language head automata. This model is coded entirely as a bilingual lexicon, with associated cost parameters. The transfer algorithm described in Section 4 searches for the lowest cost &apos;tiling&apos; of the target dependency graph with entries from the bilingual lexicon. Dynamic programming is again used to make exhaustive se</context>
</contexts>
<marker>Jelinek, Mercer, Roukos, 1992</marker>
<rawString>Jelinek, F., R.L. Mercer and S. Roukos. 1992. &amp;quot;Principles of Lexical Language Modeling for Speech Recognition&amp;quot;. In S. Furui and M.M. Sondhi (eds.), Advances in Speech Signal Processing, Marcel Dekker, New York.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Lafferty</author>
<author>D Sleator</author>
<author>D Temperley</author>
</authors>
<title>Grammatical Trigrams: A Probabilistic Model of Link Grammar&amp;quot;.</title>
<date>1992</date>
<booktitle>In Proceedings of the 1992 AAAI Fall Symposium on Probabilistic Approaches to Natural Language,</booktitle>
<pages>89--97</pages>
<marker>Lafferty, Sleator, Temperley, 1992</marker>
<rawString>Lafferty, J., D. Sleator and D. Temperley. 1992. &amp;quot;Grammatical Trigrams: A Probabilistic Model of Link Grammar&amp;quot;. In Proceedings of the 1992 AAAI Fall Symposium on Probabilistic Approaches to Natural Language, 89-97.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Kay</author>
</authors>
<title>Head Driven Parsing&amp;quot;.</title>
<date>1989</date>
<booktitle>In Proceedings of the Workshop on Parsing Technologies,</booktitle>
<location>Pittsburg,</location>
<contexts>
<context position="12394" citStr="Kay 1989" startWordPosition="2033" endWordPosition="2034">model is lexical, linguistic constructions headed by lexical items not present in the input are not involved in the search the way they are with typical top-down or predictive parsing strategies. We will sketch an algorithm for finding the lowest cost ordered dependency tree derivation for an input string in polynomial time in the length of the string. In our experimental system we use a more general version of the algorithm to allow input in the form of word lattices. The algorithm is a bottom-up tabular parser (Younger 1967, Early 1970) in which constituents are constructed &amp;quot;head-outwards&amp;quot; (Kay 1989, Sata and Stock 1989). Since we are analyzing bottomup with generative model automata, the algorithm &apos;runs&apos; the automata backwards. Edges in the parsing lattice (or &amp;quot;chart&amp;quot;) are tuples representing partial or complete phrases headed by a word w from position i to position j in the string: (w, t, j, m, q, c). Here in is the head automaton for w in this derivation; the automaton is in state q; t is the dependency tree constructed so far, and c is the cost of the partial derivation. We will use the notation C(xly) for the cost of a model event with probability P(xly); the assignment of costs to </context>
</contexts>
<marker>Kay, 1989</marker>
<rawString>Kay, M. 1989. &amp;quot;Head Driven Parsing&amp;quot;. In Proceedings of the Workshop on Parsing Technologies, Pittsburg, 1989.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Lindop</author>
<author>J Tsujii</author>
</authors>
<title>Complex Transfer in MT: A Survey of Examples&amp;quot;.</title>
<date>1991</date>
<tech>Technical Report 91/5,</tech>
<institution>Centre for Computational Linguistics,</institution>
<location>UMIST, Manchester, UK.</location>
<contexts>
<context position="18117" citStr="Lindop and Tsujii 1991" startWordPosition="3036" endWordPosition="3040">applied earlier by the transfer component, influencing the choice of structure passed to the generator. 4 Transfer Maps 4.1 Transfer Model Bilingual Lexicon The transfer model defines possible mappings, with associated costs, of dependency trees with sourcelanguage word node labels into ones with targetlanguage word labels. Unlike the head automata monolingual models, the transfer model operates with unordered dependency trees, that is, it treats the dependents of a word as an unordered bag. The model is general enough to cover the common translation problems discussed in the literature (e.g. Lindop and Tsujii 1991 and Dorr 1994) including manyto-many word mapping, argument switching, and head switching. A transfer model consists of a bilingual lexicon and a transfer parameter table. The model uses dependency tree fragments, which are the same as unordered dependency trees except that some nodes may not have word labels. In the bilingual lexicon, an entry for a source word wi (see top portion of Figure 2) has the form (wi, Hi,ni,Gi, fi) where Hi is a source language tree fragment, ni (the primary node) is a distinguished node of Hi with label wi, Gi is a target tree fragment, and fi is a 170 mapping fun</context>
</contexts>
<marker>Lindop, Tsujii, 1991</marker>
<rawString>Lindop, J. and J. Tsujii. 1991. &amp;quot;Complex Transfer in MT: A Survey of Examples&amp;quot;. Technical Report 91/5, Centre for Computational Linguistics, UMIST, Manchester, UK.</rawString>
</citation>
<citation valid="true">
<authors>
<author>P Resnik</author>
</authors>
<title>Probabilistic Tree-Adjoining Grammar as a Framework for Statistical Natural Language Processing&amp;quot;.</title>
<date>1992</date>
<booktitle>In Proceedings of COLING-92,</booktitle>
<pages>418--424</pages>
<location>Nantes, France,</location>
<contexts>
<context position="2746" citStr="Resnik 1992" startWordPosition="402" endWordPosition="403">no-lingual models consisting of collections of simple automata associated with the heads of phrases. These head automata are applied by an algorithm with admissible incremental pruning based on semantic association costs, providing a practical solution to the problem of combinatoric disambiguation (Church and Patil 1982). The model is intended to combine the lexical sensitivity of N-gram models (Jelinek et al. 1992) and the structural properties of statistical context free grammars (Booth 1969) without the computational overhead of statistical lexicalized treeadjoining grammars (Schabes 1992, Resnik 1992). For translation, we use a model for mapping dependency graphs written by the source language head automata. This model is coded entirely as a bilingual lexicon, with associated cost parameters. The transfer algorithm described in Section 4 searches for the lowest cost &apos;tiling&apos; of the target dependency graph with entries from the bilingual lexicon. Dynamic programming is again used to make exhaustive search tractable, avoiding the combinatoric explosion of shake-and-bake translation (Whitelock 1992, Brew 1992). In Section 5 we present a general framework for associating costs with the solutio</context>
</contexts>
<marker>Resnik, 1992</marker>
<rawString>Resnik, P. 1992. &amp;quot;Probabilistic Tree-Adjoining Grammar as a Framework for Statistical Natural Language Processing&amp;quot;. In Proceedings of COLING-92, Nantes, France, 418-424.</rawString>
</citation>
<citation valid="true">
<authors>
<author>G Sata</author>
</authors>
<title>Head-Driven Bidirectional Parsing&amp;quot;.</title>
<date>1989</date>
<booktitle>In Proceedings of the Workshop on Parsing Technologies,</booktitle>
<location>Pittsburg,</location>
<marker>Sata, 1989</marker>
<rawString>Sata, G. and 0. Stock. 1989. &amp;quot;Head-Driven Bidirectional Parsing&amp;quot;. In Proceedings of the Workshop on Parsing Technologies, Pittsburg, 1989.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Y Schabes</author>
</authors>
<title>Stochastic Lexicalized TreeAdjoining Grammars&amp;quot;.</title>
<date>1992</date>
<booktitle>In Proceedings of COLING-92,</booktitle>
<pages>426--432</pages>
<location>Nantes,</location>
<contexts>
<context position="2732" citStr="Schabes 1992" startWordPosition="400" endWordPosition="401"> reversible mono-lingual models consisting of collections of simple automata associated with the heads of phrases. These head automata are applied by an algorithm with admissible incremental pruning based on semantic association costs, providing a practical solution to the problem of combinatoric disambiguation (Church and Patil 1982). The model is intended to combine the lexical sensitivity of N-gram models (Jelinek et al. 1992) and the structural properties of statistical context free grammars (Booth 1969) without the computational overhead of statistical lexicalized treeadjoining grammars (Schabes 1992, Resnik 1992). For translation, we use a model for mapping dependency graphs written by the source language head automata. This model is coded entirely as a bilingual lexicon, with associated cost parameters. The transfer algorithm described in Section 4 searches for the lowest cost &apos;tiling&apos; of the target dependency graph with entries from the bilingual lexicon. Dynamic programming is again used to make exhaustive search tractable, avoiding the combinatoric explosion of shake-and-bake translation (Whitelock 1992, Brew 1992). In Section 5 we present a general framework for associating costs wi</context>
</contexts>
<marker>Schabes, 1992</marker>
<rawString>Schabes, Y. 1992. &amp;quot;Stochastic Lexicalized TreeAdjoining Grammars&amp;quot;. In Proceedings of COLING-92, Nantes, France, 426-432.</rawString>
</citation>
<citation valid="true">
<authors>
<author>P J Whitelock</author>
</authors>
<title>Shake-and-Bake Translation&amp;quot;.</title>
<date>1992</date>
<booktitle>Proceedings of COLING92, the International Conference on Computational Linguistics,</booktitle>
<location>Nantes, France.</location>
<contexts>
<context position="3250" citStr="Whitelock 1992" startWordPosition="478" endWordPosition="479">thout the computational overhead of statistical lexicalized treeadjoining grammars (Schabes 1992, Resnik 1992). For translation, we use a model for mapping dependency graphs written by the source language head automata. This model is coded entirely as a bilingual lexicon, with associated cost parameters. The transfer algorithm described in Section 4 searches for the lowest cost &apos;tiling&apos; of the target dependency graph with entries from the bilingual lexicon. Dynamic programming is again used to make exhaustive search tractable, avoiding the combinatoric explosion of shake-and-bake translation (Whitelock 1992, Brew 1992). In Section 5 we present a general framework for associating costs with the solutions of search processes, pointing out some benefits of cost functions other than log likelihood, including an error-minimization cost function for unsupervised training of the parameters in our translation application. Section 6 briefly describes an English-Chinese translator employing the models and algorithms. We also present experimental results comparing the performance of different cost assignment methods. Finally, we return to the more general discussion of representations for machine translati</context>
</contexts>
<marker>Whitelock, 1992</marker>
<rawString>Whitelock, P.J. 1992. &amp;quot;Shake-and-Bake Translation&amp;quot;. Proceedings of COLING92, the International Conference on Computational Linguistics, Nantes, France.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D Younger</author>
</authors>
<title>Recognition and Parsing of Context-Free Languages</title>
<date>1967</date>
<booktitle>in Time n3. Information and Control,</booktitle>
<pages>10--189</pages>
<contexts>
<context position="12317" citStr="Younger 1967" startWordPosition="2023" endWordPosition="2024"> identified without scoring an exponential number of syntactic parses. Since the model is lexical, linguistic constructions headed by lexical items not present in the input are not involved in the search the way they are with typical top-down or predictive parsing strategies. We will sketch an algorithm for finding the lowest cost ordered dependency tree derivation for an input string in polynomial time in the length of the string. In our experimental system we use a more general version of the algorithm to allow input in the form of word lattices. The algorithm is a bottom-up tabular parser (Younger 1967, Early 1970) in which constituents are constructed &amp;quot;head-outwards&amp;quot; (Kay 1989, Sata and Stock 1989). Since we are analyzing bottomup with generative model automata, the algorithm &apos;runs&apos; the automata backwards. Edges in the parsing lattice (or &amp;quot;chart&amp;quot;) are tuples representing partial or complete phrases headed by a word w from position i to position j in the string: (w, t, j, m, q, c). Here in is the head automaton for w in this derivation; the automaton is in state q; t is the dependency tree constructed so far, and c is the cost of the partial derivation. We will use the notation C(xly) for t</context>
<context position="15170" citStr="Younger 1967" startWordPosition="2539" endWordPosition="2540">e p&apos; because for any derivation involving p&apos; that spans the entire string, there will be a lower cost derivation involving p. This pruning condition is effective at curbing a combinatorial explosion arising from, for example, prepositional phrase attachment ambiguities (coded in the alternative trees t and t&apos;). The worst case asymptotic time complexity of&apos; the analysis algorithm is 0(min(n2,1V12)n3), where n is the length of an input string and I VI is the size of the vocabulary. This limit can be derived in a similar way to cubic time tabular recognition algorithms for context free grammars (Younger 1967) with the grammar related term being replaced by the term min(n2, 11/12) since the words of the input sentence also act as categories in the head automata model. In this context &amp;quot;recognition&amp;quot; refers to checking that the input string can be generated from the grammar. Note that our algorithm is for analysis (in the sense of finding the best derivation) which, in general, is a higher time complexity problem than recognition. 3.2 Generation By generation here we mean determining the lowest cost linear surface ordering for the dependents of each word in an unordered dependency structure resulting </context>
</contexts>
<marker>Younger, 1967</marker>
<rawString>Younger, D. 1967. Recognition and Parsing of Context-Free Languages in Time n3. Information and Control, 10,189-208.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>