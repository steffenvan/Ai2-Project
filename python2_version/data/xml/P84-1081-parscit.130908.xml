<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000003">
<sectionHeader confidence="0.902298" genericHeader="abstract">
INTERRUPTABLE TRANSITION NETWORKS
</sectionHeader>
<author confidence="0.281066">
Sergei Nirenburg
</author>
<affiliation confidence="0.349369333333333">
Colgate University
Chagit Attiya
Hebrew University of Jerusalem
</affiliation>
<sectionHeader confidence="0.869669" genericHeader="keywords">
ABSTRACT
</sectionHeader>
<bodyText confidence="0.9993263">
A specialized transition network
mechanism, the interruptable transition
network (ITN) is used to perform the last
of three stages in a multiprocessor
syntactic parser. This approach can be
seen as an exercise in implementing a
parsing procedure of the active chart
parser family.
Most of the ATN parser
implementations use the left-to-right
</bodyText>
<subsectionHeader confidence="0.484993">
top-down chronological backtracking
</subsectionHeader>
<bodyText confidence="0.999957641509434">
control structure (cf. Bates, 1978 for
discussion). The control strategies of
the active chart type permit a blend of
bottom-up and top-down parsing at the
expense of time and space overhead (cf.
Kaplan, 1973). The environment in which
the interruptable transition network (ITN)
has been implemented is not similar to
that of a typical ATN model. Nor is it a
straightforward implementation of an
active chart. ITN is responsible for one
stage in a multiprocessor parsing
technique described in Lozinskii &amp;
Nirenburg, (1982a and b), where parsing is
performed in essentially the bottom-up
fashion in parallel by a set of relatively
small and &amp;quot;dumb&amp;quot; processing units running
identical software. The process involves
three stages: (a) producing the candidate
strings of preterminal category symbols;
(b) determining the positions in this
string at which higher-level constituents
start and (c) determining the closing
boundaries of these constituents.
Each of the processors allocated to
the first stage obtains the set of all
syntactic readings of one word in the
input string. Using a table grammar, the
processors then choose a subset of the
word&apos;s readings to ensure compatibility
with similar subsets generated by this
processor&apos;s right and left neighbor.
Stage 2 uses the results of stage 1
and a different tabular grammar to
establish the left (&amp;quot;opening&amp;quot;) boundaries
for composite sentence constituents, such
as NP or PP. The output of this stage
assumes the form of a string of triads
Ilabel y&gt;, where label belongs to the
vocabulary of constituent types. In our
implementation this set includes S, NP,
VP, PP, NP&amp; (the &amp;quot;virtual&amp;quot; NP), Del (the
delimiter), etc. x and y are the left and
the right indices of the boundaries of
these constituents in the input string.
They mark the points at which parentheses
are to be opened (x) and closed (y) in the
tree representation. The values x and y
relate to positions of words in the
initial input string. For example, the
sentence (1) will be processed at stage 2
into the string (2). The &apos;?&apos; in (2) stand
for unknown coordinates y.
</bodyText>
<listItem confidence="0.530872142857143">
(1) The very big brick building that sits
1 2 3 4 5 6 7
on the hill belongs to the university.
8 9 10 11 12 13 14
(2) (s 1 ?)(np 1 ?)(s 6 ?)(np&amp; 6 6)
(vp 7 ?)(pp 8 ?)(np 9 ?)(vp 11 ?)
(pp 12 ?)(np 13 ?)
</listItem>
<bodyText confidence="0.999798275862069">
It is at this point that the
interruptable transition network starts
its work of finding the unknown boundary
coordinates and thus determining the upper
levels of the parse tree.
An input string n triads long will be
allocated ri identical processors.
Initially the chunk of every participating
processor will be one triad long. After
these processors finish with their chunks
(either succeeding or failing to find the
missing coordinate) a &amp;quot;change of levels&amp;quot;
interrupt occurs: the size of the chunks
is doubled and the number of &apos;active
processors halved. These latter continue
the scanning of the ITN from the point
they were interrupted taking as input what
was formerly the chunk of their right
neighbor. Note that all constituents
already closed in that chunk are
transparent to the current processor and
already closed in that chunk are
transparent to the current processor and
are not rescanned. The number of active
processors &apos;steadily reduces during
parsing. The choice of processors that
are to remain active is made with the help
of tne Pyramid protocol (cf. Lozinskii &amp;
Nirenburg, 1982). The processors released
</bodyText>
<page confidence="0.998443">
393
</page>
<bodyText confidence="0.998883260869565">
after each &amp;quot;layout&amp;quot; are returned to the
system pool of available resources. At
the top level in the pyramid only one
processor will remain. The status of such
a processor is declared final, and this
triggers the wrap-up operations and the
construction of output. The wrap-up uses
the original string of words and the
appropriate string of preterminal symbols
obtained at stage 1 together with the
results of stage 3 to build the parse
tree.
ITN can start processing at an
arbitrary position in the input string,
not necessarily at the beginning of a
sentence. Therefore, we introduce an
additional subnetwork, &amp;quot;initial&amp;quot;, used for
handling control flow among the other
subnetworks.
The list of &amp;quot;closed&amp;quot; constituents
obtained through ITN-based parsing of
string (2) can be found in (3), while (4)
is the output of ITN processing of (3).
</bodyText>
<listItem confidence="0.9983342">
(3) (s 1 14)(np 1 10)(s 6 10)(np&amp; 6 6)
(vp 7 10)(pp 8 10)(np 9 10)(vp 11 14)
(pp 12 14)(np 13 14)
(4) (s(np(s(np0(vp(pp(np)))))(vp(pp)))
3. An ITN Interpreter.
</listItem>
<bodyText confidence="0.994867423913044">
The interpreter was designed for a
parallel processing system. This goal
compelled us to use a program environment
somewhat different from the usual practice
of writing ATN interpreters. Our
interpreter can, however, be used to
interpret both ITNs and ATNs.
A new type of arc was introduced:
the interrupt arc INTR. The interrupt arc
is a way out of a network state additional
to the regular POP. It gives the process
the opportunity to resume from the very
point where the interrupt had been called,
but at a later stage (this mechanism is
rather similar to the detach-type commands
in programming languages which support
coroutines, such as, for instance,
SIMULA). Thus, the interpreter must be
able to suspend processing after trying to
proceed through any arc in a state and to
resume processing later in that very
state, from the arc immediately following
the interrupt arc. For example, if INTR
is the fourth of seven arcs in a state,
the work resumes from the fifth arc in
this state. This is implemented with a
stack in which the transitions in the net
are recorded. The PUSH and POP arcs are
also implemented through this stack and
not through the recursion handling
mechanisms built into Lisp.
Since it is never known to any
processor whether it will be active at the
next stage, it is necessary that the
information it obtained be saved in a
place where another processor will be able
to find it. Unlike the standard ATN
parsers (which return the parse tree as
the value of the parsing function), the
riN parser records the results in a
special working area (see discussion
below).
Implementation
The ITN interpreter was implemented
in YLISP, the dialect of LISP developed at
the Hebrew University of Jerusalem. A
special scheduler routine for simulating
parallel processes on a VAX 11/780 was
written by Jacob Levy. The interpreter
also uses the pyramid protocol program by
Shmuel Bahr.
In what follows we will describe the
organization of the stack, the working
area, and the program itself.
a) The stack. The item to be stacked
must describe a position in the network.
An item is pushed onto the stack every
time a PUSH or an INTR arc is traversed.
Every time a POP arc is traversed or a
return from an interrupt occurs one item
is popped. The stack item consists of:
1) names and values of the current network
registers; 2) the remainder of the arcs
in the state (after the PUSH or the INTR
traversed); 3) the actions of the PUSH
arc traversed; 4) the name of the current
network (i.e. that of the latter&apos;s
initial state); 5) the value of the input
pointer (for the case of a PUSH failure).
The working area is used for two
purposes: to support message passing
between the processors and to hold the
findings. The working area is organized
as an array, R, that holds a doubly linked
list used to construct the output tree.
The actions defined on the working area
are: a) initialization (procedure
mit-input): every cell R[i] in R obtains
a token from input, while the links
R[i].[next-index] and
R[i].[previous-index] obtain the values
i+1 and i-1, respectively; b) CLOSE, the
tool for delimiting subtrees in the input
string;
The array R is used in parallel by a
number of processors. At every level of
processing the active processors&apos; chunks
cover the array R. This arrangement does
not corrupt the parallel character of the
process, since no processor actually seeks
information from the chunks other than its
own.
</bodyText>
<page confidence="0.995132">
394
</page>
<bodyText confidence="0.992007540000001">
The main function of the interpreter
is called itn. It obtains the stack
containing the history of processing. If
an interrupt is encountered, the function
returns the stack with new history, to be
used for invoking this function again, by
the pyramid protocol.
If a call to ltn is a return from the
interrupt status, then a stack item is
popped (it corresponds to the last state
entered during the previous run). If the
function call is the initial one, we start
to scan the network from the first state
of the &amp;quot;initial&amp;quot; subnetwork.
At this stage we already know which
state of which network fragment we are in.
Moreover, we even know the path through
the states and fragments we took in order
to reach this state and the exact arc in
this state from which we have to start
processing. So, we execute the test on
the current arc. If the test succeeds we
perform branching on the arc name.
The INTR arc has the following
syntax: (INTR(dummy&gt;(test)&lt;action)*).
The current state is stacked and the
procedure is exited returning the stack as
the value. (dummy) was inserted simply to
preserve the usual convention of situating
the test in the third slot in an arc.
The ABORT arc has the syntax
(ABORT&lt;message)(test)).
When we encounter an error and it
becomes clear that the input string is
illegal, we want to be able to stop
processing immediately and print a
diagnostic message.
The actions on the stack involve the
movement of an item to and from the stack.
The stack item is the quantum value that
can be pushed and popped, that is no part
of the item is accessed separately from
the rest of the values in it. The
functions managing the stack are
push-on-stack and pop-from-stack.
The push-on-stack is called whenever
a PUSH or an INTR arc is traversed. The
pop-from-stack is called, first, when the
POP arc is traversed and, second, when the
process resumes after return from an
interrupt.
The close action is performed when we
find a boundary for a certain subtree for
which the opposite boundary is already
known (in our case the boundary that is
found is always the right boundary, y).
ClQae performs two tasks: first, it
inserts the numeric value for y and,
second, it declares the newly built
subtree a new token in the input string.
For example, if the input string had been
Cs 1 ?&gt;(np 1 ?)&lt;vp 4 ?&gt;&lt;np 6 8&gt;&lt;pp 9 10)
1 2 3 4 5
after the action (close 3 10) is performed
the input for further processing has the
form:
&lt;s 1 ?)&lt;np 1 ?)(vp 4 10).
The parameters of close are 1) the
number of the triad we want to close and
2) the value for which the y in this triad
is to be substituted. The default value
for the second parameter is the value of
the y in the triad current at the moment a
call to close is made.
When the processing is parallel,
close is applied multiply at every level,
which would mean that a higher level
processor will obtain prefabricated
subtrees as elementary input tokens. This
is a major source of the efficiency of
multiprocessor parsing.
The ITN in the current implementation
is relatively small. A broader
implementation will be needed to study the
properties of this parsing scheme,
including the estimates for its time
complexity, and the extendability of the
grammar. A comparison should also be made
with other multiprocessor parsing schemes,
including those that are based not on
organizing communication among relatively
&amp;quot;dumb&amp;quot; processors running identical
software but rather on interaction of
highly specialized and &amp;quot;intelligent&amp;quot;
processors -- cf., e.g., the word expert
parser (Small, 1981).
Acknowledgments. The authors thank
E. Lozinskii and Y. Ben Asher for the many
discussions of the ideas described in this
paper.
</bodyText>
<sectionHeader confidence="0.756808" genericHeader="introduction">
Bibliography
</sectionHeader>
<reference confidence="0.892491714285714">
Bates, M. (1978), The theory and practice
of augmented transition network
grammars. In: L. Bolc (ed.) , Natural
Language Communication with Computers.
Berlin: Springer.
Kaplan, R. M. (1973), A general syntactic
processor. In R. Rustin (ed. ), Natural
Language Processing. NY: Academic
Press.
Lozinskii, E. L. and S. Nirenburg
(1982a). Locality in Natural Language
processing. In: R. Trappl (ed.),
Cybernetics and Systems Research.
Amsterdam: North Holland.
</reference>
<page confidence="0.999604">
395
</page>
<bodyText confidence="0.9732261">
Lozinskii, E. L. and S. Nirenburg
(1982b), Parallel processing of natural
language. Proceedings of ECAI, Orsay,
France.
Small, S. (1981), Viewing word expert
parsing as a linguistic theory.
Proceedings of IJCAI, Vancouver, B.C..
Appendix A. ITN: the main function of
the interruptable transition network
interpreter
</bodyText>
<equation confidence="0.607897">
(def itn
(lambda ( stack )
</equation>
<bodyText confidence="0.671967611111111">
; stack - current processing stack
(prog (togs curt-state-arcs net-name
curt-arc $ test arc-name)
; regs - current registers of the network
; curr-state-arcs - list of arcs not yet
; processed in current state
; net-name - name of network being
: processed
; curr-arc - arc in processing
;(all these are pushed on stack when a
; &apos;push&apos; arc occurs)
; $ - a special register.
; the function first checks if stack is
; nil; if not then this call is a return
; from interrupt previous values must be
; popped from the stack
(cond (stack (seta ec pn nil)
;set end-chunk flag to nil
</bodyText>
<equation confidence="0.9599962">
(pop-from-stack t))
(t (set-net &apos;all
loop
( cond ((null curt-state-arcs)
(cond( (null (pop nil)) (return nil)]
</equation>
<bodyText confidence="0.841575142857143">
(set &apos;curt-arc (setcdr &apos;curt-state-arcs))
( set &apos;test (*nth curr-arc 3) )
( cond ((eval test)
;test succeeds - traverse the arc
( set &apos;arc-name (car curr-arc))
[cond
((eq arc-name &apos;push ) ; PUSH
</bodyText>
<equation confidence="0.924345222222222">
(evlist (*nth curr-arc 4))
(push-on-stack)
(set-net (cadr curt-arc))
(go loop))
((eq arc-name &apos;pop ) ; POP
(evlist (*nthcdr curr-arc 3))
(cond
((null (pop(eval(cadr curr-arc))))
(return $)))
</equation>
<bodyText confidence="0.9448244375">
(go loop))
((eq arc-name &apos;jump ) ; JUMP
(evlist (*nthcdr curr-arc 3))
(set-state (*nth curr-arc 2))
(go loop))
((eq arc-name &apos;to) ; TO
(evlist (*nthcdr curr-arc 3))
(set-state (*nth curr-arc 2))
(get-input)
(go loop))
((eq arc-name &apos;cat) ; CAT
(cond ((eq (curr(E.AB))
(*nth curr-arc 2))
(evlist
(*nthcdr curt-arc 3))))
(go loop))
((eq arc-name &apos;abort) ; ABORT
(tpatom (*nth curt-arc 2))
(return nil))
((eq arc-name &apos;intr) ; INTeRrupt
(push-on-stack)
(return stack))
(t ; error
(tpatom &apos;&amp;quot;illegal arc&amp;quot;)
(return nil))
( go loop ) ; try next arc
Appendix B.
A Fragment of an ITN network
(the &amp;quot;initial&amp;quot; and the sentence subnetworks)
;Note that &amp;quot;jump&amp;quot; and &amp;quot;to&amp;quot; can be either
;terminal actions on an arc or separate
;arcs
</bodyText>
<figure confidence="0.96849094047619">
(def-net &apos;(s-place) &apos;(
(initial
(pop t (end-of-sent) (close*))
(intr nil (end-of-chunk)((to initial)))
(push S (lab s)
((setr s-place (inp-pointer)))
((jump initial/DEL)))
(push NP (lab np) nil ((to initial)))
(push VP (lab vp) nil ((to initial)))
(push PP (lab pp) nil ((to initial)))
(cat np&amp; t (to initial))
(cat del t (to initial)))
(initial/DEL
(cat del t (close* (getr s-place))
(to initial))
(to initial t]
(def-net &apos;( vp-place no-pp pp-place
np-place)
.(
(S
(pop t (is-def (Y))(close (imp-pointer)))
(to S/ t (setr no-pp 0)))
(S/
(intr nil (end-of-chunk)((to S/)))
(push PP (and (lab pp)
(le (getr no-pp) 2))
((and (gt (getr no-pp) 0)
(close* (getr pp-place)))
(setr pp-place (inp-pointer)) )
((setr no-pp (addl
(getr no-pp)))
(jump S/)))
(abort &amp;quot;more than 2 PPs in S&amp;quot; (lab pp) )
(cat np&amp; t (to SiNF&amp;))
;(s (PP &amp; PP) --)
(cat del (gt (getr no-pp) 0)
(close* pp-place)
(setr no-pp 1)
(to S/))
(abort &amp;quot;DEL cannot appear at
beglnning of sent&amp;quot; (lab del))
(jump S/NF&amp; t]
(S/NP&amp;
(intr nil (end-of-chunk)((to S/NF&amp;)))
(push NP
396
(lab np)
((and
(getr pp-place)
(close* (getr pp-place)))
(setr np-place (inp-pointer)))
((to S/NP)))
;here we can allow PPs after an NP!
(push VP
(lab vp)
((and (getr pp-place)
(close* (getr pp-place))))
((jump S/OUT)))
(abort &amp;quot;no NP or VP in
the input sentence&amp;quot; t)
(jump S/NP t]
(S/NP
(abort &amp;quot;not enough VPs in S&amp;quot;
(end-of-sent))
(intr nil (end-of-chunk)((to S/NP)))
(push VP (lab vp)
((setr vp-place (inp-pointer))
if there is a del
(close* (getr np-place)))
;close the preceding NP
;and everything in it
((jump S/VP)))
;(s (np &amp; np) ..)
(cat del (lab del)
(close* (getr np-place))
(to S/NP&amp;))
(abort &amp;quot;too many NPs before a VP&amp;quot;
(lab np)
(S/VP
(cat del (lab del)
(close* (getr vp-place))
(jump S/VP/DEL))
(jump S/OUT t]
(S/VP/DEL
</figure>
<figureCaption confidence="0.793335">
;standing at &apos;del&apos; and looking ahead
(abort &amp;quot;del at EOS?&amp;quot;
</figureCaption>
<bodyText confidence="0.987428727272727">
(ge (next-one (inp-pointer))
sent-len))
; the above is a test for eos
(intr nil (null (look-ahead 1))
((jump S/VP/DEL)))
(to S/NP (eq (look-ahead 1) &apos;vp))
(jump S/OUT t]
;exit: it must be an s
(S/OUT
(pop t (end-of-sent) (close*))
(pop t t]
</bodyText>
<page confidence="0.997106">
397
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.026735">
<title confidence="0.995893">INTERRUPTABLE TRANSITION NETWORKS</title>
<author confidence="0.999713">Sergei Nirenburg</author>
<affiliation confidence="0.807739333333333">Colgate University Chagit Attiya Hebrew University of Jerusalem</affiliation>
<abstract confidence="0.998297823529412">A specialized transition network mechanism, the interruptable transition network (ITN) is used to perform the last of three stages in a multiprocessor syntactic parser. This approach can be seen as an exercise in implementing a parsing procedure of the active chart parser family. Most of the ATN parser implementations use the left-to-right top-down chronological backtracking control structure (cf. Bates, 1978 for discussion). The control strategies of the active chart type permit a blend of bottom-up and top-down parsing at the expense of time and space overhead (cf. Kaplan, 1973). The environment in which the interruptable transition network (ITN) has been implemented is not similar to that of a typical ATN model. Nor is it a straightforward implementation of an active chart. ITN is responsible for one stage in a multiprocessor parsing technique described in Lozinskii &amp; Nirenburg, (1982a and b), where parsing is performed in essentially the bottom-up fashion in parallel by a set of relatively small and &amp;quot;dumb&amp;quot; processing units running identical software. The process involves three stages: (a) producing the candidate strings of preterminal category symbols; (b) determining the positions in this string at which higher-level constituents start and (c) determining the closing boundaries of these constituents. Each of the processors allocated to the first stage obtains the set of all syntactic readings of one word in the input string. Using a table grammar, the processors then choose a subset of the word&apos;s readings to ensure compatibility with similar subsets generated by this processor&apos;s right and left neighbor. Stage 2 uses the results of stage 1 and a different tabular grammar to establish the left (&amp;quot;opening&amp;quot;) boundaries for composite sentence constituents, such as NP or PP. The output of this stage assumes the form of a string of triads Ilabel y&gt;, where label belongs to the vocabulary of constituent types. In our implementation this set includes S, NP, VP, PP, NP&amp; (the &amp;quot;virtual&amp;quot; NP), Del (the delimiter), etc. x and y are the left and the right indices of the boundaries of these constituents in the input string. They mark the points at which parentheses are to be opened (x) and closed (y) in the tree representation. The values x and y relate to positions of words in the initial input string. For example, the sentence (1) will be processed at stage 2 into the string (2). The &apos;?&apos; in (2) stand for unknown coordinates y. (1) The very big brick building that sits 1 2 3 4 5 6 7 on the hill belongs to the university. 8 9 10 11 12 13 14 (2) (s 1 ?)(np 1 ?)(s 6 ?)(np&amp; 6 6) (vp 7 ?)(pp 8 ?)(np 9 ?)(vp 11 ?) (pp 12 ?)(np 13 ?) It is at this point that the interruptable transition network starts its work of finding the unknown boundary coordinates and thus determining the upper levels of the parse tree. input string long will be allocated ri identical processors. Initially the chunk of every participating will triad long. After these processors finish with their chunks (either succeeding or failing to find the missing coordinate) a &amp;quot;change of levels&amp;quot; interrupt occurs: the size of the chunks is doubled and the number of &apos;active processors halved. These latter continue the scanning of the ITN from the point they were interrupted taking as input what formerly of their right neighbor. Note that all constituents already closed in that chunk are transparent to the current processor and already closed in that chunk are transparent to the current processor and are not rescanned. The number of active processors &apos;steadily reduces during parsing. The choice of processors that are to remain active is made with the help of tne Pyramid protocol (cf. Lozinskii &amp; Nirenburg, 1982). The processors released 393 after each &amp;quot;layout&amp;quot; are returned to the system pool of available resources. At the top level in the pyramid only one processor will remain. The status of such processor is declared this triggers the wrap-up operations and the construction of output. The wrap-up uses the original string of words and the appropriate string of preterminal symbols obtained at stage 1 together with the results of stage 3 to build the parse tree. ITN can start processing at an arbitrary position in the input string, not necessarily at the beginning of a sentence. Therefore, we introduce an additional subnetwork, &amp;quot;initial&amp;quot;, used for handling control flow among the other subnetworks. The list of &amp;quot;closed&amp;quot; constituents obtained through ITN-based parsing of string (2) can be found in (3), while (4) is the output of ITN processing of (3). (3) (s 1 14)(np 1 10)(s 6 10)(np&amp; 6 6) (vp 7 10)(pp 8 10)(np 9 10)(vp 11 14) (pp 12 14)(np 13 14) (4) (s(np(s(np0(vp(pp(np)))))(vp(pp))) ITN Interpreter. The interpreter was designed for a parallel processing system. This goal compelled us to use a program environment somewhat different from the usual practice of writing ATN interpreters. Our interpreter can, however, be used to interpret both ITNs and ATNs. A new type of arc was introduced: the interrupt arc INTR. The interrupt arc is a way out of a network state additional to the regular POP. It gives the process opportunity to resume from point where the interrupt had been called, but at a later stage (this mechanism is rather similar to the detach-type commands in programming languages which support coroutines, such as, for instance, SIMULA). Thus, the interpreter must be able to suspend processing after trying to proceed through any arc in a state and to resume processing later in that very state, from the arc immediately following the interrupt arc. For example, if INTR is the fourth of seven arcs in a state, the work resumes from the fifth arc in this state. This is implemented with a stack in which the transitions in the net are recorded. The PUSH and POP arcs are also implemented through this stack and not through the recursion handling mechanisms built into Lisp. Since it is never known to any processor whether it will be active at the next stage, it is necessary that the information it obtained be saved in a place where another processor will be able to find it. Unlike the standard ATN (which return the parse the value of the parsing function), the riN parser records the results in a special working area (see discussion below). Implementation interpreter was implemented in YLISP, the dialect of LISP developed at Hebrew University of A special scheduler routine for simulating parallel processes on a VAX 11/780 was written by Jacob Levy. The interpreter uses the pyramid protocol program Shmuel Bahr. In what follows we will describe the organization of the stack, the working area, and the program itself. a) The stack. The item to be stacked must describe a position in the network. item is pushed onto the stack a or an INTR arc is traversed. Every time a POP arc is traversed or a return from an interrupt occurs one item is popped. The stack item consists of: 1) names and values of the current network registers; 2) the remainder of the arcs in the state (after the PUSH or the INTR traversed); 3) the actions of the PUSH arc traversed; 4) the name of the current network (i.e. that of the latter&apos;s initial state); 5) the value of the input pointer (for the case of a PUSH failure). The working area is used for two purposes: to support message passing between the processors and to hold the findings. The working area is organized as an array, R, that holds a doubly linked list used to construct the output tree. The actions defined on the working area are: a) initialization (procedure mit-input): every cell R[i] in R obtains a token from input, while the links R[i].[next-index] and R[i].[previous-index] obtain the values i+1 and i-1, respectively; b) CLOSE, the tool for delimiting subtrees in the input string; The array R is used in parallel by a number of processors. At every level of processing the active processors&apos; chunks cover the array R. This arrangement does not corrupt the parallel character of the process, since no processor actually seeks information from the chunks other than its own. 394 The main function of the interpreter is called itn. It obtains the stack containing the history of processing. If an interrupt is encountered, the function returns the stack with new history, to be used for invoking this function again, by the pyramid protocol. If a call to ltn is a return from the interrupt status, then a stack item is popped (it corresponds to the last state entered during the previous run). If the function call is the initial one, we start to scan the network from the first state of the &amp;quot;initial&amp;quot; subnetwork. At this stage we already know which state of which network fragment we are in. Moreover, we even know the path through the states and fragments we took in order to reach this state and the exact arc in this state from which we have to start processing. So, we execute the test on the current arc. If the test succeeds we branching the arc The INTR arc has the following syntax: (INTR(dummy&gt;(test)&lt;action)*). The current state is stacked and the procedure is exited returning the stack as the value. (dummy) was inserted simply to preserve the usual convention of situating the test in the third slot in an arc. The ABORT arc has the syntax (ABORT&lt;message)(test)). When we encounter an error and it becomes clear that the input string is illegal, we want to be able to stop processing immediately and print a diagnostic message. The actions on the stack involve the movement of an item to and from the stack. The stack item is the quantum value that can be pushed and popped, that is no part of the item is accessed separately from the rest of the values in it. The functions managing the stack are push-on-stack and pop-from-stack. The push-on-stack is called whenever an INTR arc is traversed. The pop-from-stack is called, first, when the POP arc is traversed and, second, when the process resumes after return from an interrupt. close action performed when we find a boundary for a certain subtree for which the opposite boundary is already known (in our case the boundary that is found is always the right boundary, y). ClQae performs two tasks: first, it inserts the numeric value for y and, second, it declares the newly built subtree a new token in the input string. example, if the input string been Cs 1 ?&gt;(np 1 ?)&lt;vp 4 ?&gt;&lt;np 6 8&gt;&lt;pp 9 10) 1 2 3 4 5 after the action (close 3 10) is performed the input for further processing has the form: &lt;s 1 ?)&lt;np 1 ?)(vp 4 10). The parameters of close are 1) the number of the triad we want to close and 2) the value for which the y in this triad is to be substituted. The default value parameter is the value of the y in the triad current at the moment a call to close is made. When the processing is parallel, applied multiply at every level, which would mean that a higher level processor will obtain prefabricated subtrees as elementary input tokens. This is a major source of the efficiency of multiprocessor parsing. The ITN in the current implementation is relatively small. A broader implementation will be needed to study the properties of this parsing scheme, including the estimates for its time complexity, and the extendability of the grammar. A comparison should also be made with other multiprocessor parsing schemes, including those that are based not on organizing communication among relatively &amp;quot;dumb&amp;quot; processors running identical software but rather on interaction of highly specialized and &amp;quot;intelligent&amp;quot; processors -cf., e.g., the word expert parser (Small, 1981). Acknowledgments. The authors thank E. Lozinskii and Y. Ben Asher for the many discussions of the ideas described in this paper.</abstract>
<note confidence="0.781803291666667">Bibliography Bates, M. (1978), The theory and practice of augmented transition network grammars. In: L. Bolc (ed.) , Natural Language Communication with Computers. Berlin: Springer. Kaplan, R. M. (1973), A general syntactic In R. Rustin Natural Language Processing. NY: Academic Press. Lozinskii, E. L. and S. Nirenburg (1982a). Locality in Natural Language Trappl (ed.), Cybernetics and Systems Research. Amsterdam: North Holland. 395 Lozinskii, E. L. and S. Nirenburg (1982b), Parallel processing of natural language. Proceedings of ECAI, Orsay, France. Small, S. (1981), Viewing word expert parsing as a linguistic theory. Proceedings of IJCAI, Vancouver, B.C.. Appendix A. ITN: the main function of</note>
<abstract confidence="0.99953224117647">the interruptable transition network interpreter (def itn (lambda ( stack ) ; stack current processing stack (prog (togs curt-state-arcs net-name curt-arc $ test arc-name) ; regs current registers of the network ; curr-state-arcs list of arcs not yet ; processed in current state ; net-name name of network being : processed ; curr-arc arc in processing ;(all these are pushed on stack when a ; &apos;push&apos; arc occurs) ; $ a special register. ; the function first checks if stack is ; nil; if not then this call is a return ; from interrupt previous values must be ; popped from the stack (cond (stack (seta ec pn nil) ;set end-chunk flag to nil (pop-from-stack t)) (t (set-net &apos;all loop ( cond ((null curt-state-arcs) (cond( (null (pop nil)) (return nil)] (set &apos;curt-arc (setcdr &apos;curt-state-arcs)) ( set &apos;test (*nth curr-arc 3) ) ( cond ((eval test) ;test succeeds traverse the arc ( set &apos;arc-name (car curr-arc)) [cond &apos;push ) ; PUSH (evlist (*nth curr-arc 4)) (push-on-stack) (set-net (cadr curt-arc)) (go loop)) ((eq arc-name &apos;pop ) ; POP (evlist (*nthcdr curr-arc 3)) (cond ((null (pop(eval(cadr curr-arc)))) (return $))) (go loop)) ((eq arc-name &apos;jump ) ; JUMP (evlist (*nthcdr curr-arc 3)) (set-state (*nth curr-arc 2)) (go loop)) ((eq arc-name &apos;to) ; TO (*nthcdr curr-arc (*nth curr-arc (get-input) (go loop)) &apos;cat) ; CAT (cond ((eq (curr(E.AB)) (*nth curr-arc 2)) (evlist (*nthcdr curt-arc 3)))) (go loop)) &apos;abort) ; ABORT (tpatom (*nth curt-arc 2)) (return nil)) ((eq arc-name &apos;intr) ; INTeRrupt (push-on-stack) (return stack)) (t ; error (tpatom &apos;&amp;quot;illegal arc&amp;quot;) (return nil)) ( go loop ) ; try next arc Appendix B. A Fragment of an ITN network (the &amp;quot;initial&amp;quot; and the sentence subnetworks) that and &amp;quot;to&amp;quot; can be either ;terminal actions on an arc or separate ;arcs (def-net &apos;(s-place) &apos;( (initial (pop t (end-of-sent) (close*)) (intr nil (end-of-chunk)((to initial))) (push S (lab s) ((setr s-place (inp-pointer))) ((jump initial/DEL))) (push NP (lab np) nil ((to initial))) (push VP (lab vp) nil ((to initial))) (push PP (lab pp) nil ((to initial))) (cat np&amp; t (to initial)) (cat del t (to initial))) (initial/DEL (cat del t (close* (getr s-place)) (to initial)) (to initial t] (def-net &apos;( vp-place no-pp pp-place np-place) .( (S (pop t (is-def (Y))(close (imp-pointer))) (to S/ t (setr no-pp 0))) (S/ (intr nil (end-of-chunk)((to S/))) (push PP (and (lab pp) (le (getr no-pp) 2)) ((and (gt (getr no-pp) 0) (close* (getr pp-place))) (setr pp-place (inp-pointer)) ) ((setr no-pp (addl (getr no-pp))) (jump S/))) (abort &amp;quot;more than 2 PPs in S&amp;quot; (lab pp) ) (cat np&amp; t (to SiNF&amp;)) ;(s (PP &amp; PP) --) (cat del (gt (getr no-pp) 0) (close* pp-place) (setr no-pp 1) (to S/)) (abort &amp;quot;DEL cannot appear at beglnning of sent&amp;quot; (lab del)) (jump S/NF&amp; t] (S/NP&amp; (intr nil (end-of-chunk)((to S/NF&amp;))) (push NP 396 (lab np) ((and (getr pp-place) (close* (getr pp-place))) (setr np-place (inp-pointer))) ;here we can allow PPs after an NP! (push VP (lab vp) ((and (getr pp-place) (close* (getr pp-place)))) ((jump S/OUT))) (abort &amp;quot;no NP or VP in the input sentence&amp;quot; t) (S/NP (abort &amp;quot;not enough VPs in S&amp;quot; (end-of-sent)) (intr nil (end-of-chunk)((to S/NP))) (push VP (lab vp) ((setr vp-place (inp-pointer)) if there is a del (close* (getr np-place))) ;close the preceding NP ;and everything in it ((jump S/VP))) ;(s (np &amp; np) ..) (cat del (lab del) (close* (getr np-place)) (to S/NP&amp;)) (abort &amp;quot;too many NPs before a VP&amp;quot; (lab np) (S/VP (cat del (lab del) (close* (getr vp-place)) (jump S/VP/DEL)) (jump S/OUT t] (S/VP/DEL ;standing at &apos;del&apos; and looking ahead (abort &amp;quot;del at EOS?&amp;quot; (ge (next-one (inp-pointer)) sent-len)) ; the above is a test for eos (intr nil (null (look-ahead 1)) ((jump S/VP/DEL))) (to S/NP (eq (look-ahead 1) &apos;vp)) (jump S/OUT t] ;exit: it must be an s (S/OUT (pop t (end-of-sent) (close*)) (pop t t]</abstract>
<intro confidence="0.6375">397</intro>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>M Bates</author>
</authors>
<title>The theory and practice of augmented transition network grammars.</title>
<date>1978</date>
<booktitle>Natural Language Communication with Computers.</booktitle>
<editor>In: L. Bolc (ed.) ,</editor>
<publisher>Springer.</publisher>
<location>Berlin:</location>
<marker>Bates, 1978</marker>
<rawString>Bates, M. (1978), The theory and practice of augmented transition network grammars. In: L. Bolc (ed.) , Natural Language Communication with Computers. Berlin: Springer.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R M Kaplan</author>
</authors>
<title>A general syntactic processor. In</title>
<date>1973</date>
<editor>R. Rustin (ed. ), Natural Language Processing.</editor>
<publisher>NY: Academic Press.</publisher>
<contexts>
<context position="711" citStr="Kaplan, 1973" startWordPosition="101" endWordPosition="102">ity of Jerusalem ABSTRACT A specialized transition network mechanism, the interruptable transition network (ITN) is used to perform the last of three stages in a multiprocessor syntactic parser. This approach can be seen as an exercise in implementing a parsing procedure of the active chart parser family. Most of the ATN parser implementations use the left-to-right top-down chronological backtracking control structure (cf. Bates, 1978 for discussion). The control strategies of the active chart type permit a blend of bottom-up and top-down parsing at the expense of time and space overhead (cf. Kaplan, 1973). The environment in which the interruptable transition network (ITN) has been implemented is not similar to that of a typical ATN model. Nor is it a straightforward implementation of an active chart. ITN is responsible for one stage in a multiprocessor parsing technique described in Lozinskii &amp; Nirenburg, (1982a and b), where parsing is performed in essentially the bottom-up fashion in parallel by a set of relatively small and &amp;quot;dumb&amp;quot; processing units running identical software. The process involves three stages: (a) producing the candidate strings of preterminal category symbols; (b) determin</context>
</contexts>
<marker>Kaplan, 1973</marker>
<rawString>Kaplan, R. M. (1973), A general syntactic processor. In R. Rustin (ed. ), Natural Language Processing. NY: Academic Press.</rawString>
</citation>
<citation valid="false">
<authors>
<author>E L Lozinskii</author>
<author>S</author>
</authors>
<title>Nirenburg (1982a). Locality in Natural Language processing.</title>
<booktitle>Cybernetics and Systems Research.</booktitle>
<editor>In: R. Trappl (ed.),</editor>
<publisher>North Holland.</publisher>
<location>Amsterdam:</location>
<marker>Lozinskii, S, </marker>
<rawString>Lozinskii, E. L. and S. Nirenburg (1982a). Locality in Natural Language processing. In: R. Trappl (ed.), Cybernetics and Systems Research. Amsterdam: North Holland.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>