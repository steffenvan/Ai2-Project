<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<title confidence="0.933506">
Cascaded Regular Grammars over XML Documents*
</title>
<author confidence="0.833985">
Kiril Simov, Milen Kouylekov, Alexander Simov
</author>
<affiliation confidence="0.505129">
CLaRK Programme &amp; BulTreeBank Project
</affiliation>
<note confidence="0.3244775">
http://www.BulTreeBank.org
Linguistic Modelling Laboratory - CLPPI, Bulgarian Academy of Sciences
Acad. G.Bonchev Str. 25A, 1113 Sofia, Bulgaria
Tel: (+3592) 979 28 25, (+3592) 979 38 12, Fax: (+3592) 70 72 73
</note>
<email confidence="0.951182">
kivs@bultreebank.org, mkouylekov@dir.bg, adis 78@dir.bg
</email>
<sectionHeader confidence="0.977141" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999965125">
The basic mechanism of CLaRK for linguistic pro-
cessing of text corpora is the cascade regular gram-
mar processor. The main challenge to the grammars
in question is how to apply them on XML encoding
of the linguistic information. The system offers a so-
lution using an XPath language for constructing the
input word to the grammar and an XML encoding
of the categories of the recognized words.
</bodyText>
<sectionHeader confidence="0.995513" genericHeader="introduction">
1 Introduction
</sectionHeader>
<bodyText confidence="0.999979807692308">
This paper describes a mechanism for definition and
application of cascaded regular grammars over XML
documents. The main problems are how to define
the input words for a grammar and how to incorpo-
rate back in the document the grammar categories
returned by the rules of the grammar. The presented
solutions are implemented within the CLaRK Sys-
tem — an XML-based System for Corpora Develop-
ment (Simov et. al., 2001).
The main goal behind the design of the system
is the minimization of human intervention during
the creation of corpora. Creation of corpora is still
an important task for the majority of languages like
Bulgarian, where the invested effort in such devel-
opment is very modest in comparison with more
intensively studied languages like English, German
and French. We consider the corpora creation task
as editing, manipulation, searching and transform-
ing of documents. Some of these tasks will be done
for a single document or a set of documents, others
will be done on a part of a document. Besides effi-
ciency of the corresponding processing in each state
of the work, the most important investment is the
human labor. Thus, in our view, the design of the
system has to be directed to minimization of the hu-
man work. For document management, storing and
</bodyText>
<footnote confidence="0.892681125">
* This work is funded by the Volkswagen Stiftung, Federal
Republic of Germany under the Programme &amp;quot;Cooperation
with Natural and Engineering Scientists in Central and East-
ern Europe&amp;quot; contract I/76 887. The authors are grateful to
Tylman Ule from SfS, University of Tubingen, Germany and
the three anonymous reviewers for their comments on the ear-
lier drafts of the paper. Needless to say, all remaining errors
in the text are ours.
</footnote>
<bodyText confidence="0.999711695652174">
querying we have chosen the XML technology be-
cause of its popularity and its ease for understand-
ing. The XML technology becomes a part of our
lives and a predominant language for data descrip-
tion and exchange on the Internet. Moreover, a lot
of already developed standards for corpus descrip-
tions like (XCES, 2001) and (TEI, 2001) are already
adapted to the XML requirements. The core of the
CLaRK System is an XML Editor which is the main
interface to the system. With the help of the editor
the user can create, edit or browse XML documents.
To facilitate the corpus management, we enlarge the
XML inventory with facilities that support linguistic
work. We added the following basic language pro-
cessing modules: a tokenizer with a module that sup-
ports a hierarchy of token types, a finite-state engine
that supports the writing of cascaded regular gram-
mars and facilities for regular pattern search, the
XPath query language which is able to support nav-
igation over the whole set of mark-up of a document,
mechanisms for imposing constraints over XML doc-
uments which are applicable in the context of some
events. We envisage several usages of our system:
</bodyText>
<listItem confidence="0.942214578947368">
1. Corpora markup. Here users work with the
XML tools of the system in order to mark-
up texts with respect to an XML DTD. This
task usually requires an enormous human ef-
fort and comprises both the mark-up itself and
its validation afterwards. Using the available
grammar resources such as morphological ana-
lyzers or partial parsing, the system can state
local constraints reflecting the characteristics of
a particular kind of texts or mark-up. One ex-
ample of such constraints can be as follows: a
PP according to a DTD can have as parent an
NP or VP, but if the left sister is a VP then the
only possible parent is VP. The system can use
such kind of constraints in order to support the
user and minimize his/her work.
2. Dictionary compilation for human users. The
system supports the creation of the actual lexi-
cal entries whose structure is defined via a DTD.
</listItem>
<bodyText confidence="0.993091148148148">
The XML tools will be used also for corpus in-
vestigation that provides appropriate examples
of the word usage in the available corpora. The
constraints incorporated in the system are used
for writing a grammar of the sub-languages of
the definitions of the lexical items, for imposing
constraints over elements of lexical entries and
the dictionary as a whole.
3. Corpora investigation. The CLaRK System of-
fers a set of tools for searching over tokens and
mark-up in XML corpora, including cascaded
grammars, XPath language. The combinations
between these tools are used for tasks such as:
extraction of elements from a corpus - for exam-
ple, extraction of all NPs in the corpus; concor-
dance - for example, give me all NPs in contexts,
ordered by a user&apos;s defined set of criteria.
The structure of the paper is as follows: in the
next section we give a short introduction to the
main technologies on which the CLaRK System is
built. These are: XML technology; Cascaded regu-
lar grammars; Unicode-based tokenizers; and Con-
straints over XML documents. The third section
describes the definition of cascaded regular gram-
mars. The fourth section presents an approach for
applying cascaded regular grammars over XML doc-
uments. The last section concludes the paper.
</bodyText>
<sectionHeader confidence="0.5404625" genericHeader="method">
2 The technologies behind the
CLaRK System
</sectionHeader>
<bodyText confidence="0.926757333333333">
CLaRK is an XML-based software system for cor-
pora development implemented in JAVA. It incor-
porates several technologies:
</bodyText>
<listItem confidence="0.9521138">
. XML technology;
• Unicode;
• Regular Grammars (they are presented in the
next sections);
• Constraints over XML Documents.
</listItem>
<subsectionHeader confidence="0.880587">
2.1 XML Technology
</subsectionHeader>
<bodyText confidence="0.999977931034483">
The XML technology is at the heart of the CLaRK
system. It is implemented as a set of utilities for
structuring, manipulation and management of data.
We have chosen the XML technology because of its
popularity, its ease of understanding and its already
wide use in description of linguistic information. Be-
sides the XML language (see (XML, 2000)) proces-
sor itself, we have implemented an XPath language
(see (XPath, 1999)) engine for navigation in docu-
ments and an XSLT language (see (XSLT, 1999))
engine for transformation of XML documents. The
documents in the system are represented as DOM
Level1 trees (see (DOM, 1998)). We started with ba-
sic facilities for creation, editing, storing and query-
ing of XML documents and developed further this
inventory towards a powerful system for processing
not only single XML documents but an integrated
set of documents and constraints over them. The
main goal of this development is to allow the user to
add the desirable semantics to the XML documents.
In the implementation of cascaded regular gram-
mars within the CLaRK System, a crucial role plays
the XPath language. XPath is a powerful language
for selecting elements from an XML document. The
XPath engine considers each XML document as a
tree where the nodes of the tree represent the ele-
ments of the document, the document&apos;s most outer
tag is the root of the tree and the children of a
node represent the content of the corresponding el-
ement. The content nodes can be element nodes or
text nodes. Attributes and their values of each ele-
ment are represented additionally to the tree.
The XPath language uses the tree-based termi-
nology to point to some direction within the tree.
One of the basic notions of the XPath language is
the so called context node, i.e. a chosen node in the
tree. Each expression in the XPath language is eval-
uated with respect to some context node. The nodes
in the tree are categorized with respect to the con-
text node as follows: the nodes immediately under
the context node are called children of the context
node; all nodes under the context node are called
descendant nodes of the context node; the node im-
mediately above the context node is called parent of
the context node; all nodes that are above the con-
text node are called ancestor nodes of the context
node; the nodes that have the same parent as the
context node are called sibling nodes of the context
node; siblings of the context node are divided into
two types: preceding siblings and following siblings,
depending on their order with respect to the context
node in the content of their parent - if the sibling is
before the context node, then it is a preceding sib-
ling, otherwise it is a following sibling. Attribute
nodes are added with the context node as attribute
nodes and they are not children, descendant, parent
or ancestor nodes of the context node. The context
node with respect to itself is called self node.
</bodyText>
<subsectionHeader confidence="0.997379">
2.2 Tokenization
</subsectionHeader>
<bodyText confidence="0.999943470588235">
XML considers the content of each text element a
whole string that is usually unacceptable for cor-
pus processing. For this reason it is required for the
wordforms, punctuation and other tokens in the text
to be distinguished. In order to solve this problem,
the CLaRK system supports a user-defined hierar-
chy of tokenizers. At the very basic level the user can
define a tokenizer in terms of a set of token types.
In this basic tokenizer each token type is defined by
a set of UNICODE symbols. Above this basic level
tokenizers the user can define other tokenizers for
which the token types are defined as regular expres-
sions over the tokens of some other tokenizer, the so
called parent tokenizer. For each tokenizer an alpha-
betical order over the token types is defined. This
order is used for operations like the comparison be-
tween two tokens, sorting and similar.
</bodyText>
<subsectionHeader confidence="0.996631">
2.3 Constraints on XML documents
</subsectionHeader>
<bodyText confidence="0.991393454545454">
Several mechanisms for imposing constraints over
XML documents are available. The constraints can-
not be stated by the standard XML technology
(even by the means of XML Schema (XML Schema,
2000)). The following types of constraints are imple-
mented in CLaRK: 1) finite-state constraints - addi-
tional constraints over the content of given elements
based on a document context; 2) number restriction
constraints - cardinality constraints over the content
of a document; 3) value constraints - restriction of
the possible content or parent of an element in a
document based on a context. The constraints are
used in two modes: checking the validity of a docu-
ment regarding a set of constraints; supporting the
linguist in his/her work during the process of cor-
pus building. The first mode allows the creation of
constraints for the validation of a corpus according
to given requirements. The second mode helps the
underlying strategy of minimization of the human
labor.
The general syntax of the constraints in the
CLaRK system is the following:
</bodyText>
<equation confidence="0.521236">
(Selector, Condition, Event, Action)
</equation>
<bodyText confidence="0.999974088235294">
where the selector defines to which node(s) in the
document the constraint is applicable; the condition
defines the state of the document at the time when
the constraint is applied. The condition is stated as
an XPath expression which is evaluated with respect
to each node selected by the selector. If the evalu-
ation of the condition is a non-empty list of nodes
then the constraints are applied; the event defines
some conditions of the system when this constraint
is checked for application. Such events can be: the
selection of a menu item, the pressing of key short-
cut, some editing command as enter a child or a
parent and similar; the action defines the way of the
actual application of the constraint.
Here we present constraints of type &amp;quot;Some Chil-
dren&amp;quot;. This kind of constraints deal with the content
of some elements. They determine the existence of
certain values within the content of these elements.
A value can be a token or an XML mark-up and the
actual value for an element can be determined by
the context. Thus a constraint of this kind works in
the following way: first it determines to which ele-
ments in the document it is applicable, then for each
such element in turn it determines which values are
allowed and checks whether in the content of the el-
ement some of these values are presented as a token
or an XML mark-up. If there is such a value, then
the constraint chooses the next element. If there is
no such a value, then the constraint offers to the
user a possibility to choose one of the allowed values
for this element and the selected value is added to
the content as a first child. Additionally, there is a
mechanism for filtering of the appropriate values on
the basis of the context of the element.
</bodyText>
<sectionHeader confidence="0.949179" genericHeader="method">
3 Cascaded Regular Grammars
</sectionHeader>
<bodyText confidence="0.972900416666667">
The CLaRK System is equipped with a finite-state
engine which is used for several tasks in the system
such as validity check for XML documents, tokeniz-
ers, search and cascaded regular grammar. In this
and the next section we present the use of this en-
gine for cascaded regular grammars over XML doc-
uments along the lines described in (Abney, 1996).
The general idea underlying cascaded regular gram-
mars is that there is a set of regular grammars. The
grammars in the set are in particular order. The in-
put of a given grammar in the set is either the input
string if the grammar is first in the order or the out-
put string of the previous grammar. Another specific
feature of the cascaded grammars is that each gram-
mar tries to recognize only a particular category in
the string but not the whole string. The parts of
the input word that are not recognized by the gram-
mar are copied to the output word. Before going
into detail of how to apply grammars in the CLaRK
System some basic notions about regular expressions
are given.
Regular grammars standardly are formalized as a
set of rewriting rules of the following kinds
A -&gt; b C
A -&gt; B
A -&gt; b
where A, B, C stand for non-terminal symbols and
b stands for terminal symbols. Such grammars are
applied over a word of terminal symbols in order to
parse it to a special goal symbol S. Each language
accepted by such a grammar is called regular. Using
such a formalization one could situated the regular
languages within the families of other languages like
context free languages, context sensitive languages
and so on. In practice this formalization is rarely
used. Other formal devices for dealing with regular
languages are regular expressions and finite-state au-
tomata with the well know correspondence between
them. Although regular grammars are not expres-
sive enough in order to be a good model of nat-
ural languages they are widely used in NLP. They
are used in modelling of inflectional morphology (see
(Koskenniemi, 1983)), tokenization and Named En-
tity recognition (Grover et. al., 2000), and many oth-
ers.
In our work we modify the definition of regular
grammars along the lines of (Abney, 1996). We use
rewriting rules of the following kind:
</bodyText>
<equation confidence="0.716369">
C -&gt; R
</equation>
<bodyText confidence="0.999776243902439">
where R is a regular expression and C is a category
of the words recognized by R. We can think of C as
a name of the language recognized by R.
A regular grammar is a set of rules such that the
regular expressions of the rules recognize pairwise
disjoint languages. The disjointness condition is nec-
essary in order the grammar to assign a unique cat-
egory to each word recognized by it.
A regular grammar works over a word of letters,
called input word. The grammar scans the input
word from left to right trying to find the first sub-
word such that it belongs to the language of the
regular expression presented by some of the rules of
the grammar. If there is no such word starting with
the first letter in the input word, then the grammar
outputs the first letter of the word and prolongs the
scanning with the second letter. When the gram-
mar recognizes a sub-word then it outputs the cate-
gory of the corresponding rule and prolongs the scan-
ning with the letter after the recognized sub-word.
The grammar works deterministically over the input
word. The result of the application of the grammar
is a copy of the input word in which the recognized
sub-words are substituted with the categories of the
grammar. The result word is called output word of
the grammar. In this respect such kind of regular
grammars could be considered a kind of finite-state
transducers.
An additional requirement suggested by (Abney,
1996) is the so-called longest match, which is a way
to choose one of the possible analyses for a grammar.
The longest match strategy requires that the recog-
nized sub-words from left to right have the longest
length possible. Thus the segmentation of the in-
put word starts from the left and tries to find the
first longest sub-words that can be recognized by
the grammar and so on to the end of the word.
An example of such a regular grammar is the
grammar F1 for recognition of dates in the format
dd.mm.yyyy (10.11.2002) defined by the following
rule:
</bodyText>
<equation confidence="0.9879472">
Date -&gt;
( (0,(1|2|3|4|5|6|7|8|9)) |
((1|2),(0|1|2|3|4|5|6|7|8|9)) |
(3,(0|1))
)
,
.
,
((0,(1|2|3|4|5|6|7|8|9))|(1,(0|1|2)))
,
.
,
(((1|2|3|4|5|6|7|8|9),
(0|1|2|3|4|5|6|7|8|9)*))
word
</equation>
<bodyText confidence="0.9389993">
The feast is from 12.03.2002 to 15.03.2002.
will produce the output word
The feast is from Date to Date.
A cascaded regular grammar (Abney, 1996) is a
sequence of regular grammars defined in such a way
that the first grammar works over the input word
and produces an output word, the second grammar
works over the output word of the first grammar,
produces a new output word and so on.
As one example of a cascaded regular grammar let
us consider the sequence of F1 as defined above and
the grammar F2 defined by the following rule:
Period -&gt; from, Date, to, Date
Application of the grammar F2 on output of the
grammar F1:
The feast is from Date to Date.
will produce the following output word
The feast is Period.
In the next section we describe how cascaded reg-
ular grammars can be applied to XML documents.
</bodyText>
<sectionHeader confidence="0.9933225" genericHeader="method">
4 Cascaded Regular Grammars over
XML Documents
</sectionHeader>
<bodyText confidence="0.999528">
The application of the regular grammars to XML
documents is connected with the following problems:
</bodyText>
<listItem confidence="0.959295">
• how to treat the XML document as an input
word for a regular grammar;
• how should the returned grammar category be
incorporated into the XML document; and
• what kind of `letters&apos; to be used in the regu-
lar expressions so that they correspond to the
`letters&apos; in the XML document.
</listItem>
<bodyText confidence="0.982835411764706">
The solutions to these problems are described in
the next paragraphs.
First of all, we accept that each grammar works
on the content of an element in an XML document.
The content of each XML element1 is either a se-
quence of XML elements, or text, or both (MIXED
content). Thus, our first task is to define how to
turn the content of an XML element into an input
word of a grammar. We consider the two basic cases
- when the content is text and when it is a sequence
of elements.
When the content of the element to which the
grammar will be applied is a text we have two
choices:
&apos;Excluding the EMPTY elements on which regular gram-
mar cannot be applied.
Application of this grammar on the following input
</bodyText>
<listItem confidence="0.963009857142857">
1. we can accept that the &apos;letters&apos; of the grammars
are the codes of the symbols in the encoding of
the text; or
2. we can segment the text in meaningful non-
overlapping chunks (in usual terminology to-
kens) and treat them as &apos;letters&apos; of the gram-
mars.
</listItem>
<bodyText confidence="0.9998434">
We have adopted here the second approach. Each
text content of an element is first tokenized by a to-
kenizer2 and is then used as an input for grammars.
Additionally, each token receives a unique type. For
instance, the content of the following element
</bodyText>
<figure confidence="0.99183719047619">
&lt;s&gt;
John loves Mary who is in love with Peter
&lt;/s&gt;
can be segmented as follows:
&amp;quot;John&amp;quot; CAPITALFIRSTWORD
&amp;quot; &amp;quot; SPACE
&amp;quot;loves&amp;quot; WORD
&amp;quot; &amp;quot; SPACE
&amp;quot;Mary&amp;quot; CAPITALFIRSTWORD
&amp;quot; &amp;quot; SPACE
&amp;quot;who&amp;quot; WORD
&amp;quot; &amp;quot; SPACE
&amp;quot;is&amp;quot; WORD
&amp;quot; &amp;quot; SPACE
&amp;quot;in&amp;quot; WORD
&amp;quot; &amp;quot; SPACE
&amp;quot;love&amp;quot; WORD
&amp;quot; &amp;quot; SPACE
&amp;quot;with&amp;quot; WORD
&amp;quot; &amp;quot; SPACE
&amp;quot;Peter&amp;quot; CAPITALFIRSTWORD
</figure>
<bodyText confidence="0.99972705882353">
Here on each line in double quotes one token from
the text followed by its token type is presented.
Therefore when a text is considered an input word
for a grammar, it is represented as a sequence of to-
kens. How can we refer now to the tokens in the
regular expressions in the grammars? The most
simple way is by tokens. We decided to go further
and to enlarge the means for describing tokens with
the so called token descriptions which correspond to
the letter descriptions in the above section on reg-
ular expressions. In the token descriptions we use
strings (sequences of characters), wildcard symbols
# for zero or more symbols, @ for zero or one sym-
bol, and token categories. Each token description
matches exactly one token in the input word.
We divide the token descriptions into two types
- those that are interpreted directly as tokens and
</bodyText>
<footnote confidence="0.882623333333333">
2There are built-in tokenizers which are always available
and there is also a mechanism for defining new tokenizers by
the user.
</footnote>
<bodyText confidence="0.981370086956522">
others that are interpreted as token types first and
then as tokens belonging to these token types.
The first kind of token descriptions is represented
as a string enclosed in double quotes. The string is
interpreted as one token with respect to the current
tokenizer. If the string does not contain a wildcard
symbol then it represents exactly one token. If the
string contains the wildcard symbol # then it denotes
an infinite set of tokens depending on the symbols
that are replaced by #. This is not a problem in
the system because the token description is always
matched by a token in the input word. The other
wildcard symbol is treated in a similar way, but zero
or one symbol is put in its place. One token descrip-
tion may contain more than one wildcard symbol.
Examples:
&amp;quot;Peter&amp;quot; as a token description could be matched
only by the last token in the above example.
&amp;quot;lov#&amp;quot; could be matched by the tokens &amp;quot;loves&amp;quot;
and &amp;quot;love&amp;quot;
&amp;quot;lov@&amp;quot; is matched only by &amp;quot;love&amp;quot;
&amp;quot;@&amp;quot; is matched by the token corresponding to the
intervals &amp;quot; &amp;quot;
&amp;quot;#h#&amp;quot; is matched by &amp;quot;John&amp;quot;, &amp;quot;who&amp;quot;, and &amp;quot;with&amp;quot;
&amp;quot;#&amp;quot; is matched by any of the tokens including the
spaces.
The second kind of token description is repre-
sented by the dollar sign $ followed by a string. The
string is interpreted as either a token type or a set
of token types if it contains wildcard symbols. Then
the type of the token in the input word is matched
by the token types denoted by the string. If the to-
ken type of the token in the text is denoted by the
token description, then the token is matched to the
token description.
Examples:
$WORD is matched to &amp;quot;loves&amp;quot;, &amp;quot;who&amp;quot;, &amp;quot;is&amp;quot;, &amp;quot;in&amp;quot;,
&amp;quot;love&amp;quot;, &amp;quot;with&amp;quot;
$CAP# is matched to &amp;quot;John&amp;quot;, &amp;quot;Mary&amp;quot; and &amp;quot;Peter&amp;quot;
$#WORD is matched to &amp;quot;John&amp;quot;, &amp;quot;loves&amp;quot;, &amp;quot;Mary&amp;quot;,
&amp;quot;who&amp;quot;, &amp;quot;is&amp;quot;, &amp;quot;in&amp;quot;, &amp;quot;love&amp;quot;, &amp;quot;with&amp;quot;, and &amp;quot;Peter&amp;quot;
$# is matched to any of the tokens including the
spaces.
Now we turn to the case when the content of a
given element is a sequence of elements. For instance
the above sentence can be represented as:
</bodyText>
<figure confidence="0.8833558">
&lt;s&gt;
&lt;N&gt;John&lt;/N&gt;&lt;V&gt;loves&lt;/V&gt;&lt;N&gt;Mary&lt;/N&gt;
&lt;Pron&gt;who&lt;/Pron&gt;&lt;V&gt;is&lt;/V&gt;&lt;P&gt;in&lt;/P&gt;
&lt;N&gt;love&lt;/N&gt;&lt;P&gt;with&lt;/P&gt;&lt;N&gt;Peter&lt;/N&gt;
&lt;/s&gt;
</figure>
<bodyText confidence="0.836105">
At first sight the natural choice for the input word
is the sequences of the tags of the elements: &lt;N&gt;
&lt;V&gt; &lt;N&gt; &lt;Pron&gt; &lt;V&gt; &lt;P&gt; &lt;N&gt; &lt;P&gt; &lt;N&gt;, but when
the encoding of the grammatical features is more
sophisticated (see below):
</bodyText>
<figure confidence="0.981813818181818">
&lt;s&gt;
&lt;w g=&amp;quot;N&amp;quot;&gt;John&lt;/w&gt;
&lt;w g=&amp;quot;V&amp;quot;&gt;loves&lt;/w&gt;
&lt;w g=&amp;quot;N&amp;quot;&gt;Mary&lt;/w&gt;
&lt;w g=&amp;quot;Pron&amp;quot;&gt;who&lt;/w&gt;
&lt;w g=&amp;quot;V&amp;quot;&gt;is&lt;/w&gt;
&lt;w g=&amp;quot;P&amp;quot;&gt;in&lt;/w&gt;
&lt;w g=&amp;quot;N&amp;quot;&gt;love&lt;/w&gt;
&lt;w g=&amp;quot;P&amp;quot;&gt;with&lt;/w&gt;
&lt;w g=&amp;quot;N&amp;quot;&gt;Peter&lt;/w&gt;
&lt;/s&gt;
</figure>
<bodyText confidence="0.97793825">
then the sequence of tags is simply &lt;w&gt; &lt;w&gt; ...,
which is not acceptable as an input word. In order to
solve this problem we substitute each element with a
sequence of values. This sequence is determined by
an XPath expression that is evaluated taking the ele-
ment node as context node. The sequence defined by
an XPath expression is called element value. Thus
each element in the content of the element is replaced
by a sequence of text segments of appropriate types
as it is explained below.
For the above example a possible element value
for tag w could be defined by the XPath expression:
&amp;quot;attribute::g&amp;quot;. This XPath expression returns the
value of the attribute g for each element with tag
w. Therefore a grammar working on the content of
the above sentence will receive as an input word the
sequence: &amp;quot;&lt;&amp;quot; &amp;quot;N&amp;quot; &amp;quot;&gt;&amp;quot; &amp;quot;&lt;&amp;quot; &amp;quot;V&amp;quot; &amp;quot;&gt;&amp;quot; &amp;quot;&lt;&amp;quot; &amp;quot;N&amp;quot; &amp;quot;&gt;&amp;quot; &amp;quot;&lt;&amp;quot;
&amp;quot;Pron&amp;quot; &amp;quot;&gt;&amp;quot; &amp;quot;&lt;&amp;quot; &amp;quot;V&amp;quot; &amp;quot;&gt;&amp;quot; &amp;quot;&lt;&amp;quot; &amp;quot;P&amp;quot; &amp;quot;&gt;&amp;quot; &amp;quot;&lt;&amp;quot; &amp;quot;N&amp;quot; &amp;quot;&gt;&amp;quot;
&amp;quot;&lt;&amp;quot; &amp;quot;P&amp;quot; &amp;quot;&gt;&amp;quot; &amp;quot;&lt;&amp;quot; &amp;quot;N&amp;quot; &amp;quot;&gt;&amp;quot;. The angle brackets &amp;quot;&lt;&amp;quot;
&amp;quot;&gt;&amp;quot; determine the boundaries of the element value
for each of the elements.
Besides such text values, by using of XPath ex-
pressions one can point to arbitrary nodes in the
document, so that the element value is determined
differently. In fact, an XPath expression can be eval-
uated as a list of nodes and then the element value
will be a sequence of values.
For example, if the element values for the above
elements are defined by the following XPath ex-
pression: &amp;quot;text() I attribute::g&amp;quot;&apos;, then the input
word will be the sequence: &amp;quot;&lt;&amp;quot; &amp;quot;John&amp;quot; &amp;quot;N&amp;quot; &amp;quot;&gt;&amp;quot; &amp;quot;&lt;&amp;quot;
&amp;quot;loves&amp;quot; &amp;quot;V&amp;quot; &amp;quot;&gt;&amp;quot; &amp;quot;&lt;&amp;quot; &amp;quot;Mary&amp;quot; &amp;quot;N&amp;quot; &amp;quot;&gt;&amp;quot; &amp;quot;&lt;&amp;quot; &amp;quot;who&amp;quot;
&amp;quot;Pron&amp;quot; &amp;quot;&gt;&amp;quot; &amp;quot;&lt;&amp;quot; &amp;quot;is&amp;quot; &amp;quot;V&amp;quot; &amp;quot;&gt;&amp;quot; &amp;quot;&lt;&amp;quot; &amp;quot;in&amp;quot; &amp;quot;P&amp;quot; &amp;quot;&gt;&amp;quot; &amp;quot;&lt;&amp;quot;
&amp;quot;love&amp;quot; &amp;quot;N&amp;quot; &amp;quot;&gt;&amp;quot; &amp;quot;&lt;&amp;quot; &amp;quot;with&amp;quot; &amp;quot;P&amp;quot; &amp;quot;&gt;&amp;quot; &amp;quot;&lt;&amp;quot; &amp;quot;Peter&amp;quot;
&amp;quot;N&amp;quot; &amp;quot;&gt;&amp;quot;.
Using predicates in the XPath expressions one
can determine the element values on the basis
of the context. For example, if in the above
case we want to use the grammatical features
for verbs, nouns and pronouns, but the actual
words for prepositions, we can modify the XPath
expression for the element value in the follow-
ing way: &amp;quot;text()[../attribute::g=&amp;quot;P&amp;quot;] I at-
tribute::g[not(../attribute::g=&amp;quot;P&amp;quot;)]&amp;quot;. In this
</bodyText>
<footnote confidence="0.939219">
3The meaning of this XPath is point to the text child of
the element and the value of the attribute g.
</footnote>
<bodyText confidence="0.988367368421052">
case the XPath expression will select the textual con-
tent of the element if the value of the attribute g for
this element has value &amp;quot;P&amp;quot;. If the value of the at-
tribute g for the element is not &amp;quot;P&amp;quot;, then the XPath
expression will select the value of the attribute g.
The input word then is: &amp;quot;&lt;&amp;quot; &amp;quot;N&amp;quot; &amp;quot;&gt;&amp;quot; &amp;quot;&lt;&amp;quot; &amp;quot;V&amp;quot; &amp;quot;&gt;&amp;quot;
&amp;quot;&lt;&amp;quot; &amp;quot;N&amp;quot; &amp;quot;&gt;&amp;quot; &amp;quot;&lt;&amp;quot; &amp;quot;Pron&amp;quot; &amp;quot;&gt;&amp;quot; &amp;quot;&lt;&amp;quot; &amp;quot;V&amp;quot; &amp;quot;&gt;&amp;quot; &amp;quot;&lt;&amp;quot; &amp;quot;in&amp;quot;
&amp;quot;&gt;&amp;quot; &amp;quot;&lt;&amp;quot; &amp;quot;N&amp;quot; &amp;quot;&gt;&amp;quot; &amp;quot;&lt;&amp;quot; &amp;quot;with&amp;quot; &amp;quot;&gt;&amp;quot; &amp;quot;&lt;&amp;quot; &amp;quot;N&amp;quot; &amp;quot;&gt;&amp;quot;.
The element value is a representation of the im-
portant information for an element. One can con-
sider it conceptual information about the element.
From another point of view it can be seen as a tex-
tual representation of the element tree structure.
At the moment in the CLaRK system the nodes
selected by an XPath expression are processed in the
following way:
1. if the returned node is an element node, then
the tag of the node is returned with the addi-
tional information confirming that this is a tag;
</bodyText>
<listItem confidence="0.826379444444444">
2. if the returned node is an attribute node, then
the value of the attribute is:
(a) tokenized by an appropriate tokenizer if the
attribute value is declared as CDATA in
the DTD;
(b) text if the value of the attribute is declared
as an enumerated list or ID.;
3. if the returned node is a text node, then the
text is tokenized by an appropriate tokenizer.
</listItem>
<bodyText confidence="0.901841931034483">
Within the regular expressions we use the angle
brackets in order to denote the boundaries of the
element values. Inside the angle brackets we could
write a regular expression of arbitrary complexity in
round brackets. As letters in these regular expres-
sions we use again token descriptions for the values
of textual elements and the values of attributes. For
tag descriptions we use strings which are neither en-
closed in double quotes nor preceded by a dollar sign.
We can use wildcard symbols in the tag name. Thus
&lt;p&gt; is matched with a tag p;
&lt;@&gt; is matched with all tags with length one.
&lt;#&gt; is matched with all tags.
The last problem when applying grammars to
XML documents is how to incorporate the category
assigned to a given rule. In general we can accept
that the category has to be encoded as XML mark-
up in the document and that this mark-up could be
very different depending on the DTD we use. For in-
stance, let us have a simple tagger (example is based
on (Abney, 1996)):
Det -&gt; &amp;quot;the&amp;quot;|&amp;quot;a&amp;quot;
N -&gt; &amp;quot;telescope&amp;quot;|&amp;quot;garden&amp;quot;|&amp;quot;boy&amp;quot;
Adj -&gt; &amp;quot;slow&amp;quot;|&amp;quot;quick&amp;quot;|&amp;quot;lazy&amp;quot;
V -&gt; &amp;quot;walks&amp;quot;|&amp;quot;see&amp;quot;|&amp;quot;sees&amp;quot;|&amp;quot;saw&amp;quot;
Prep -&gt; &amp;quot;above&amp;quot;|&amp;quot;with&amp;quot;|&amp;quot;in&amp;quot;
Then one possibility for representing the cate-
gories as XML mark-up is by tags around the recog-
nized words:
</bodyText>
<figure confidence="0.9528128">
the boy with the telescope
becomes
&lt;Det&gt;the&lt;/Det&gt;&lt;N&gt;boy&lt;/N&gt;
&lt;Prep&gt;with&lt;/Prep&gt;
&lt;Det&gt;the&lt;/Det&gt;&lt;N&gt;telescope&lt;/N&gt;
</figure>
<bodyText confidence="0.954482666666667">
This encoding is straightforward but not very con-
venient when the given wordform is homonymous
like:
</bodyText>
<equation confidence="0.934045">
V -&gt; &amp;quot;move&amp;quot;
N -&gt; &amp;quot;move&amp;quot;
</equation>
<bodyText confidence="0.996576428571429">
In order to avoid such cases we decided that the
category for each rule in the CLaRK System is a cus-
tom mark-up that substitutes the recognized word.
Since in most cases we would also like to save the
recognized word, we use the variable \w for the rec-
ognized word. For instance, the above example will
be:
</bodyText>
<figure confidence="0.9188382">
&lt;Det&gt;\w&lt;/Det&gt; -&gt; &amp;quot;the&amp;quot;|&amp;quot;a&amp;quot;
&lt;N&gt;\w&lt;/N&gt; -&gt; &amp;quot;telescope&amp;quot;|&amp;quot;garden&amp;quot;|&amp;quot;boy&amp;quot;
&lt;Adj&gt;\w&lt;/Adj&gt; -&gt; &amp;quot;slow&amp;quot;|&amp;quot;quick&amp;quot;|&amp;quot;lazy&amp;quot;
&lt;V&gt;\w&lt;/V&gt; -&gt; &amp;quot;walks&amp;quot;|&amp;quot;see&amp;quot;|&amp;quot;sees&amp;quot;|&amp;quot;saw&amp;quot;
&lt;Prep&gt;\w&lt;/Prep&gt; -&gt; &amp;quot;above&amp;quot;|&amp;quot;with&amp;quot;|&amp;quot;in&amp;quot;
</figure>
<bodyText confidence="0.947108842105263">
The mark-up defining the category can be as com-
plicated as necessary. The variable \w can be re-
peated as many times as necessary (it can also be
omitted). For instance, for &amp;quot;move&amp;quot; the rule could
be:
&lt;w aa=&amp;quot;V;N&amp;quot;&gt;\w&lt;/w&gt; -&gt; &amp;quot;move&amp;quot;
Let us give now one examples in which element
values are used. For instance, the following grammar
recognizes prepositional phrases:
&lt;PP&gt;\w&lt;/PP&gt; -&gt; &lt;&amp;quot;P&amp;quot;&gt;&lt;&amp;quot;N#&amp;quot;&gt;
Generally it says that a prepositional phrase consists
of an element with element value &amp;quot;P&amp;quot; followed by an
element with element value which matches the to-
ken description &amp;quot;N#&amp;quot;. Usage of the token description
&amp;quot;N#&amp;quot; ensures that the rule will work also for the case
when a preposition is followed by an element with el-
ement value &amp;quot;NP&amp;quot;. The application of this grammar
on the above example with appropriate definition of
element values will result in the following document:
</bodyText>
<figure confidence="0.979343733333333">
&lt;s&gt;
&lt;w g=&amp;quot;N&amp;quot;&gt;John&lt;/w&gt;
&lt;w g=&amp;quot;V&amp;quot;&gt;loves&lt;/w&gt;
&lt;w g=&amp;quot;N&amp;quot;&gt;Mary&lt;/w&gt;
&lt;w g=&amp;quot;Pron&amp;quot;&gt;who&lt;/w&gt;
&lt;w g=&amp;quot;V&amp;quot;&gt;is&lt;/w&gt;
&lt;PP&gt;
&lt;w g=&amp;quot;P&amp;quot;&gt;in&lt;/w&gt;
&lt;w g=&amp;quot;N&amp;quot;&gt;love&lt;/w&gt;
&lt;/PP&gt;
&lt;PP&gt;
&lt;w g=&amp;quot;P&amp;quot;&gt;with&lt;/w&gt;
&lt;w g=&amp;quot;N&amp;quot;&gt;Peter&lt;/w&gt;
&lt;/PP&gt;
&lt;/s&gt;
</figure>
<bodyText confidence="0.9064105">
Here is another example (based on a grammar
developed by Petya Osenova for Bulgarian noun
phrases) which demonstrates a more complicated
regular expressions inside element descriptions:
&lt;np aa=&amp;quot;NPsn&amp;quot;&gt;\w&lt;/np&gt; -&gt;
&lt;(&amp;quot;An#&amp;quot;|&amp;quot;Pd@@@sn&amp;quot;)&gt;,&lt;(&amp;quot;Pneo-sn&amp;quot;|&amp;quot;Pfeo-sn&amp;quot;)&gt;
Here &amp;quot;An#&amp;quot; matches all morphosyntactic tags for
adjectives of neuter gender, &amp;quot;Pd@@@sn&amp;quot; matches all
morphosyntactic tags for demonstrative pronouns of
neuter gender, singular , &amp;quot;Pneo-sn&amp;quot; is a morphosyn-
tactic tag for the negative pronoun, neuter gender,
singular, and &amp;quot;Pfeo-sn&amp;quot; is a morphosyntactic tag
for the indefinite pronoun, neuter gender, singular.
This rule recognizes as a noun phrase each sequence
of two elements where the first element has an ele-
ment value corresponding to an adjective or demon-
strative pronoun with appropriate grammatical fea-
tures, followed by an element with element value cor-
responding to a negative or an indefinite pronoun.
Notice the attribute aa of the category of the rule.
It represents the information that the resulting noun
phrase is singular, neuter gender. Let us now sup-
pose that the next grammar is for determination of
prepositional phrases is defined as follows:
&lt;pp&gt;\w&lt;/pp&gt; -&gt; &lt;&amp;quot;R&amp;quot;&gt;&lt;&amp;quot;N#&amp;quot;&gt;
where &amp;quot;R&amp;quot; is the morphosyntactic tag for preposi-
tions. Let us trace the application of the two gram-
mars one after another on the following XML ele-
ment:
&lt;text&gt;
&lt;w aa=&amp;quot;R&amp;quot;&gt;s&lt;/w&gt;
&lt;w aa=&amp;quot;Ansd&amp;quot;&gt;golyamoto&lt;/w&gt;
&lt;w aa=&amp;quot;Pneo-sn&amp;quot;&gt;nisto&lt;/w&gt;
&lt;/text&gt;
First, we defined the element value for the ele-
ments with tag w by the XPath expression: &amp;quot;at-
tribute::aa&amp;quot;. Then the cascaded regular gram-
mar processor calculated the input word for the
first grammar: &amp;quot;&lt;&amp;quot; &amp;quot;R&amp;quot; &amp;quot;&gt;&amp;quot; &amp;quot;&lt;&amp;quot; &amp;quot;Ansd&amp;quot; &amp;quot;&gt;&amp;quot; &amp;quot;&lt;&amp;quot;
&amp;quot;Pneo-sn&amp;quot; &amp;quot;&gt;&amp;quot;. Then the first grammar is applied
on this input words and it recognizes the last two
elements as a noun phrase. This results in two ac-
tions: first, the markup of the rule is incorporated
into the original XML document:
</bodyText>
<figure confidence="0.990149714285714">
&lt;text&gt;
&lt;w aa=&amp;quot;R&amp;quot;&gt;s&lt;/w&gt;
&lt;np aa=&amp;quot;NPsn&amp;quot;&gt;
&lt;w aa=&amp;quot;Ansd&amp;quot;&gt;golyamoto&lt;/w&gt;
&lt;w aa=&amp;quot;Pneo-sn&amp;quot;&gt;nisto&lt;/w&gt;
&lt;/np&gt;
&lt;/text&gt;
</figure>
<bodyText confidence="0.999454">
Second, the element value for the new element &lt;np&gt;
is calculated and it is substituted in the input word
of the first grammar and in this way the input word
for the second grammar is constructed: &amp;quot;&lt;&amp;quot; &amp;quot;R&amp;quot; &amp;quot;&gt;&amp;quot;
&amp;quot;&lt;&amp;quot; &amp;quot;NPsn&amp;quot; &amp;quot;&gt;&amp;quot;. Then the second grammar is ap-
plied on this word and the result is incorporated in
the XML document:
</bodyText>
<figure confidence="0.994996222222222">
&lt;text&gt;
&lt;pp&gt;
&lt;w aa=&amp;quot;R&amp;quot;&gt;s&lt;/w&gt;
&lt;np aa=&amp;quot;NPsn&amp;quot;&gt;
&lt;w aa=&amp;quot;Ansd&amp;quot;&gt;golyamoto&lt;/w&gt;
&lt;w aa=&amp;quot;Pneo-sn&amp;quot;&gt;nisto&lt;/w&gt;
&lt;/np&gt;
&lt;/pp&gt;
&lt;/text&gt;
</figure>
<bodyText confidence="0.989912333333333">
Because the cascaded grammar only consists of this
two grammars the input word for the second gram-
mar is not modified, but simply deleted.
</bodyText>
<sectionHeader confidence="0.996619" genericHeader="conclusions">
5 Conclusion
</sectionHeader>
<bodyText confidence="0.999888">
In this paper we presented an approach to appli-
cation of cascaded regular grammars within XML.
This mechanism is implemented within the CLaRK
System (Simov et. al., 2001). The general idea is
that an XML document could be considered as a
&amp;quot;blackboard&amp;quot; on which different grammars work.
Each grammar is applied on the content of some of
the elements in the XML document. The content of
each of these elements is converted into input words.
If the content is text then it is converted into a se-
quence of tokens. If the content is a sequence of
elements, then each element is substituted by an el-
ement value. Each element value is defined by an
XPath expression. The XPath engine selects the ap-
propriate pieces of information which determine the
element value. The element value can be considered
as the category of the element, or as textual repre-
sentation of the tree structure of the element and its
context. The result of the grammar is incorporated
in the XML document as XML markup.
In fact in the CLaRK System are implemented
more tools for modification of an XML document,
such as: constraints, sort, remove, transformations.
These tools can write some information, reorder it
or delete it. The user can order the applications of
the different tools in order to achieve the necessary
processing. We call this possibility cascaded pro-
cessing after the cascaded regular grammars. In
this case we can order not just different grammars
but also other types of tools.
</bodyText>
<sectionHeader confidence="0.998436" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999663">
Steve Abney. 1996. Partial Parsing via Finite-State
Cascades. In: Proceedings of the ESSLLI&apos;96 Ro-
bust Parsing Workshop. Prague, Czech Republic.
DOM. 1998. Document Object Model (DOM) Level
1. Specification Version 1.0. W3C Recommenda-
tion. http://www.w3.org/TR/1998/REC-DOM--
Level-1-19981001
Claire Grover, Colin Matheson, Andrei Mikheev and
Marc Moens. 2000. LT TTT - A Flexible To-
kenisation Tool. In: Proceedings of Second Inter-
national Conference on Language Resources and
Evaluation (LREC 2000).
K. Koskenniemi. 1983. Two-level Model for Morpho-
logical Analysis. In: Proceedings of IJCAI-83 ,
pages: 683-685, Karlsruhe, Germany.
Kiril Simov, Zdravko Peev, Milen Kouylekov, Ale-
xander Simov, Marin Dimitrov, Atanas Kiryakov.
2001. CLaRK - an XML-based System for Corpora
Development. In: Proc. of the Corpus Linguistics
2001 Conference, pages: 558-560. Lancaster, UK.
Text Encoding Initiative. 1997. Guidelines for Elec-
tronic Text Encoding and Interchange. Sperberg-
McQueen C.M., Burnard L (eds).
Corpus Encoding Standard. 2001. XCES: Corpus
Encoding Standard for XML. Vassar College, New
York, USA.
http://www.cs.vassar.edu/XCES/
XML. 2000. Extensible Markup Language (XML) 1.0
(Second Edition). W3C Recommendation.
http://www.w3.org/TR/REC-xml
XML Schema. 2001. XML Schema Part 1: Struc-
tures. W3C Recommendation.
http://www.w3.org/TR/xmlschema-1/
XPath. 1999. XML Path Lamguage (XPath) version
1.0. W3C Recommendation.
http://www.w3.org/TR/xpath
XSLT. 1999. XSL Transformations (XSLT) version
1.0. W3C Recommendation.
http://www.w3.org/TR/xslt
</reference>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.136258">
<title confidence="0.963056">Cascaded Regular Grammars over XML Documents*</title>
<author confidence="0.890391">Kiril Simov</author>
<author confidence="0.890391">Milen Kouylekov</author>
<author confidence="0.890391">Alexander</author>
<affiliation confidence="0.665054">CLaRK Programme &amp; BulTreeBank</affiliation>
<address confidence="0.3098875">Linguistic Modelling Laboratory - CLPPI, Bulgarian Academy of Acad. G.Bonchev Str. 25A, 1113 Sofia,</address>
<phone confidence="0.989507">Tel: (+3592) 979 28 25, (+3592) 979 38 12, Fax: (+3592) 70 72</phone>
<email confidence="0.885376">kivs@bultreebank.org,mkouylekov@dir.bg,adis78@dir.bg</email>
<abstract confidence="0.999281777777778">The basic mechanism of CLaRK for linguistic processing of text corpora is the cascade regular grammar processor. The main challenge to the grammars in question is how to apply them on XML encoding of the linguistic information. The system offers a solution using an XPath language for constructing the input word to the grammar and an XML encoding of the categories of the recognized words.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Steve Abney</author>
</authors>
<title>Partial Parsing via Finite-State Cascades. In:</title>
<date>1996</date>
<booktitle>Proceedings of the ESSLLI&apos;96 Robust Parsing Workshop.</booktitle>
<location>Prague, Czech Republic.</location>
<contexts>
<context position="13117" citStr="Abney, 1996" startWordPosition="2227" endWordPosition="2228">to choose one of the allowed values for this element and the selected value is added to the content as a first child. Additionally, there is a mechanism for filtering of the appropriate values on the basis of the context of the element. 3 Cascaded Regular Grammars The CLaRK System is equipped with a finite-state engine which is used for several tasks in the system such as validity check for XML documents, tokenizers, search and cascaded regular grammar. In this and the next section we present the use of this engine for cascaded regular grammars over XML documents along the lines described in (Abney, 1996). The general idea underlying cascaded regular grammars is that there is a set of regular grammars. The grammars in the set are in particular order. The input of a given grammar in the set is either the input string if the grammar is first in the order or the output string of the previous grammar. Another specific feature of the cascaded grammars is that each grammar tries to recognize only a particular category in the string but not the whole string. The parts of the input word that are not recognized by the grammar are copied to the output word. Before going into detail of how to apply gramm</context>
<context position="14920" citStr="Abney, 1996" startWordPosition="2544" endWordPosition="2545">sitive languages and so on. In practice this formalization is rarely used. Other formal devices for dealing with regular languages are regular expressions and finite-state automata with the well know correspondence between them. Although regular grammars are not expressive enough in order to be a good model of natural languages they are widely used in NLP. They are used in modelling of inflectional morphology (see (Koskenniemi, 1983)), tokenization and Named Entity recognition (Grover et. al., 2000), and many others. In our work we modify the definition of regular grammars along the lines of (Abney, 1996). We use rewriting rules of the following kind: C -&gt; R where R is a regular expression and C is a category of the words recognized by R. We can think of C as a name of the language recognized by R. A regular grammar is a set of rules such that the regular expressions of the rules recognize pairwise disjoint languages. The disjointness condition is necessary in order the grammar to assign a unique category to each word recognized by it. A regular grammar works over a word of letters, called input word. The grammar scans the input word from left to right trying to find the first subword such tha</context>
<context position="16392" citStr="Abney, 1996" startWordPosition="2808" endWordPosition="2809">h the second letter. When the grammar recognizes a sub-word then it outputs the category of the corresponding rule and prolongs the scanning with the letter after the recognized sub-word. The grammar works deterministically over the input word. The result of the application of the grammar is a copy of the input word in which the recognized sub-words are substituted with the categories of the grammar. The result word is called output word of the grammar. In this respect such kind of regular grammars could be considered a kind of finite-state transducers. An additional requirement suggested by (Abney, 1996) is the so-called longest match, which is a way to choose one of the possible analyses for a grammar. The longest match strategy requires that the recognized sub-words from left to right have the longest length possible. Thus the segmentation of the input word starts from the left and tries to find the first longest sub-words that can be recognized by the grammar and so on to the end of the word. An example of such a regular grammar is the grammar F1 for recognition of dates in the format dd.mm.yyyy (10.11.2002) defined by the following rule: Date -&gt; ( (0,(1|2|3|4|5|6|7|8|9)) | ((1|2),(0|1|2|3</context>
<context position="27733" citStr="Abney, 1996" startWordPosition="4836" endWordPosition="4837">ptions we use strings which are neither enclosed in double quotes nor preceded by a dollar sign. We can use wildcard symbols in the tag name. Thus &lt;p&gt; is matched with a tag p; &lt;@&gt; is matched with all tags with length one. &lt;#&gt; is matched with all tags. The last problem when applying grammars to XML documents is how to incorporate the category assigned to a given rule. In general we can accept that the category has to be encoded as XML markup in the document and that this mark-up could be very different depending on the DTD we use. For instance, let us have a simple tagger (example is based on (Abney, 1996)): Det -&gt; &amp;quot;the&amp;quot;|&amp;quot;a&amp;quot; N -&gt; &amp;quot;telescope&amp;quot;|&amp;quot;garden&amp;quot;|&amp;quot;boy&amp;quot; Adj -&gt; &amp;quot;slow&amp;quot;|&amp;quot;quick&amp;quot;|&amp;quot;lazy&amp;quot; V -&gt; &amp;quot;walks&amp;quot;|&amp;quot;see&amp;quot;|&amp;quot;sees&amp;quot;|&amp;quot;saw&amp;quot; Prep -&gt; &amp;quot;above&amp;quot;|&amp;quot;with&amp;quot;|&amp;quot;in&amp;quot; Then one possibility for representing the categories as XML mark-up is by tags around the recognized words: the boy with the telescope becomes &lt;Det&gt;the&lt;/Det&gt;&lt;N&gt;boy&lt;/N&gt; &lt;Prep&gt;with&lt;/Prep&gt; &lt;Det&gt;the&lt;/Det&gt;&lt;N&gt;telescope&lt;/N&gt; This encoding is straightforward but not very convenient when the given wordform is homonymous like: V -&gt; &amp;quot;move&amp;quot; N -&gt; &amp;quot;move&amp;quot; In order to avoid such cases we decided that the category for each rule in the CLaRK System is a custom mark-up that </context>
</contexts>
<marker>Abney, 1996</marker>
<rawString>Steve Abney. 1996. Partial Parsing via Finite-State Cascades. In: Proceedings of the ESSLLI&apos;96 Robust Parsing Workshop. Prague, Czech Republic.</rawString>
</citation>
<citation valid="true">
<authors>
<author>DOM</author>
</authors>
<title>Document Object Model (DOM) Level 1. Specification Version 1.0. W3C Recommendation.</title>
<date>1998</date>
<pages>3--1998</pages>
<contexts>
<context position="6719" citStr="DOM, 1998" startWordPosition="1118" endWordPosition="1119">nology is at the heart of the CLaRK system. It is implemented as a set of utilities for structuring, manipulation and management of data. We have chosen the XML technology because of its popularity, its ease of understanding and its already wide use in description of linguistic information. Besides the XML language (see (XML, 2000)) processor itself, we have implemented an XPath language (see (XPath, 1999)) engine for navigation in documents and an XSLT language (see (XSLT, 1999)) engine for transformation of XML documents. The documents in the system are represented as DOM Level1 trees (see (DOM, 1998)). We started with basic facilities for creation, editing, storing and querying of XML documents and developed further this inventory towards a powerful system for processing not only single XML documents but an integrated set of documents and constraints over them. The main goal of this development is to allow the user to add the desirable semantics to the XML documents. In the implementation of cascaded regular grammars within the CLaRK System, a crucial role plays the XPath language. XPath is a powerful language for selecting elements from an XML document. The XPath engine considers each XM</context>
</contexts>
<marker>DOM, 1998</marker>
<rawString>DOM. 1998. Document Object Model (DOM) Level 1. Specification Version 1.0. W3C Recommendation. http://www.w3.org/TR/1998/REC-DOM--Level-1-19981001</rawString>
</citation>
<citation valid="true">
<authors>
<author>Claire Grover</author>
<author>Colin Matheson</author>
<author>Andrei Mikheev</author>
<author>Marc Moens</author>
</authors>
<title>LT TTT - A Flexible Tokenisation Tool. In:</title>
<date>2000</date>
<booktitle>Proceedings of Second International Conference on Language Resources and Evaluation (LREC</booktitle>
<marker>Grover, Matheson, Mikheev, Moens, 2000</marker>
<rawString>Claire Grover, Colin Matheson, Andrei Mikheev and Marc Moens. 2000. LT TTT - A Flexible Tokenisation Tool. In: Proceedings of Second International Conference on Language Resources and Evaluation (LREC 2000).</rawString>
</citation>
<citation valid="true">
<authors>
<author>K Koskenniemi</author>
</authors>
<title>Two-level Model for Morphological Analysis. In:</title>
<date>1983</date>
<booktitle>Proceedings of IJCAI-83 ,</booktitle>
<pages>683--685</pages>
<location>Karlsruhe, Germany.</location>
<contexts>
<context position="14745" citStr="Koskenniemi, 1983" startWordPosition="2514" endWordPosition="2515">such a grammar is called regular. Using such a formalization one could situated the regular languages within the families of other languages like context free languages, context sensitive languages and so on. In practice this formalization is rarely used. Other formal devices for dealing with regular languages are regular expressions and finite-state automata with the well know correspondence between them. Although regular grammars are not expressive enough in order to be a good model of natural languages they are widely used in NLP. They are used in modelling of inflectional morphology (see (Koskenniemi, 1983)), tokenization and Named Entity recognition (Grover et. al., 2000), and many others. In our work we modify the definition of regular grammars along the lines of (Abney, 1996). We use rewriting rules of the following kind: C -&gt; R where R is a regular expression and C is a category of the words recognized by R. We can think of C as a name of the language recognized by R. A regular grammar is a set of rules such that the regular expressions of the rules recognize pairwise disjoint languages. The disjointness condition is necessary in order the grammar to assign a unique category to each word rec</context>
</contexts>
<marker>Koskenniemi, 1983</marker>
<rawString>K. Koskenniemi. 1983. Two-level Model for Morphological Analysis. In: Proceedings of IJCAI-83 , pages: 683-685, Karlsruhe, Germany.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kiril Simov</author>
</authors>
<title>Zdravko Peev, Milen Kouylekov, Alexander Simov, Marin Dimitrov, Atanas Kiryakov.</title>
<date>2001</date>
<booktitle>Proc. of the Corpus Linguistics 2001 Conference,</booktitle>
<pages>558--560</pages>
<location>Lancaster, UK.</location>
<marker>Simov, 2001</marker>
<rawString>Kiril Simov, Zdravko Peev, Milen Kouylekov, Alexander Simov, Marin Dimitrov, Atanas Kiryakov. 2001. CLaRK - an XML-based System for Corpora Development. In: Proc. of the Corpus Linguistics 2001 Conference, pages: 558-560. Lancaster, UK.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Text Encoding Initiative</author>
</authors>
<title>Guidelines for Electronic Text Encoding and Interchange. SperbergMcQueen C.M.,</title>
<date>1997</date>
<journal>Burnard L</journal>
<marker>Initiative, 1997</marker>
<rawString>Text Encoding Initiative. 1997. Guidelines for Electronic Text Encoding and Interchange. SperbergMcQueen C.M., Burnard L (eds).</rawString>
</citation>
<citation valid="true">
<authors>
<author>Corpus Encoding Standard</author>
</authors>
<title>XCES: Corpus Encoding Standard for XML.</title>
<date>2001</date>
<publisher>Vassar College,</publisher>
<location>New York, USA.</location>
<marker>Standard, 2001</marker>
<rawString>Corpus Encoding Standard. 2001. XCES: Corpus Encoding Standard for XML. Vassar College, New York, USA.</rawString>
</citation>
<citation valid="true">
<authors>
<author>XML</author>
</authors>
<title>Extensible Markup Language (XML) 1.0 (Second Edition). W3C Recommendation.</title>
<date>2000</date>
<note>http://www.w3.org/TR/REC-xml</note>
<contexts>
<context position="6442" citStr="XML, 2000" startWordPosition="1073" endWordPosition="1074">CLaRK is an XML-based software system for corpora development implemented in JAVA. It incorporates several technologies: . XML technology; • Unicode; • Regular Grammars (they are presented in the next sections); • Constraints over XML Documents. 2.1 XML Technology The XML technology is at the heart of the CLaRK system. It is implemented as a set of utilities for structuring, manipulation and management of data. We have chosen the XML technology because of its popularity, its ease of understanding and its already wide use in description of linguistic information. Besides the XML language (see (XML, 2000)) processor itself, we have implemented an XPath language (see (XPath, 1999)) engine for navigation in documents and an XSLT language (see (XSLT, 1999)) engine for transformation of XML documents. The documents in the system are represented as DOM Level1 trees (see (DOM, 1998)). We started with basic facilities for creation, editing, storing and querying of XML documents and developed further this inventory towards a powerful system for processing not only single XML documents but an integrated set of documents and constraints over them. The main goal of this development is to allow the user t</context>
</contexts>
<marker>XML, 2000</marker>
<rawString>XML. 2000. Extensible Markup Language (XML) 1.0 (Second Edition). W3C Recommendation. http://www.w3.org/TR/REC-xml</rawString>
</citation>
<citation valid="true">
<authors>
<author>XML Schema</author>
</authors>
<date>2001</date>
<booktitle>XML Schema Part 1: Structures. W3C Recommendation. http://www.w3.org/TR/xmlschema-1/</booktitle>
<marker>Schema, 2001</marker>
<rawString>XML Schema. 2001. XML Schema Part 1: Structures. W3C Recommendation. http://www.w3.org/TR/xmlschema-1/</rawString>
</citation>
<citation valid="true">
<authors>
<author>XPath</author>
</authors>
<title>XML Path Lamguage (XPath) version 1.0. W3C Recommendation.</title>
<date>1999</date>
<note>http://www.w3.org/TR/xpath</note>
<contexts>
<context position="6518" citStr="XPath, 1999" startWordPosition="1085" endWordPosition="1086">in JAVA. It incorporates several technologies: . XML technology; • Unicode; • Regular Grammars (they are presented in the next sections); • Constraints over XML Documents. 2.1 XML Technology The XML technology is at the heart of the CLaRK system. It is implemented as a set of utilities for structuring, manipulation and management of data. We have chosen the XML technology because of its popularity, its ease of understanding and its already wide use in description of linguistic information. Besides the XML language (see (XML, 2000)) processor itself, we have implemented an XPath language (see (XPath, 1999)) engine for navigation in documents and an XSLT language (see (XSLT, 1999)) engine for transformation of XML documents. The documents in the system are represented as DOM Level1 trees (see (DOM, 1998)). We started with basic facilities for creation, editing, storing and querying of XML documents and developed further this inventory towards a powerful system for processing not only single XML documents but an integrated set of documents and constraints over them. The main goal of this development is to allow the user to add the desirable semantics to the XML documents. In the implementation of</context>
</contexts>
<marker>XPath, 1999</marker>
<rawString>XPath. 1999. XML Path Lamguage (XPath) version 1.0. W3C Recommendation. http://www.w3.org/TR/xpath</rawString>
</citation>
<citation valid="true">
<authors>
<author>XSLT</author>
</authors>
<title>XSL Transformations (XSLT) version 1.0. W3C Recommendation.</title>
<date>1999</date>
<note>http://www.w3.org/TR/xslt</note>
<contexts>
<context position="6593" citStr="XSLT, 1999" startWordPosition="1098" endWordPosition="1099">• Regular Grammars (they are presented in the next sections); • Constraints over XML Documents. 2.1 XML Technology The XML technology is at the heart of the CLaRK system. It is implemented as a set of utilities for structuring, manipulation and management of data. We have chosen the XML technology because of its popularity, its ease of understanding and its already wide use in description of linguistic information. Besides the XML language (see (XML, 2000)) processor itself, we have implemented an XPath language (see (XPath, 1999)) engine for navigation in documents and an XSLT language (see (XSLT, 1999)) engine for transformation of XML documents. The documents in the system are represented as DOM Level1 trees (see (DOM, 1998)). We started with basic facilities for creation, editing, storing and querying of XML documents and developed further this inventory towards a powerful system for processing not only single XML documents but an integrated set of documents and constraints over them. The main goal of this development is to allow the user to add the desirable semantics to the XML documents. In the implementation of cascaded regular grammars within the CLaRK System, a crucial role plays th</context>
</contexts>
<marker>XSLT, 1999</marker>
<rawString>XSLT. 1999. XSL Transformations (XSLT) version 1.0. W3C Recommendation. http://www.w3.org/TR/xslt</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>