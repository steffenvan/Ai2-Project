<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000538">
<title confidence="0.985634">
Mining Syntactically Annotated Corpora with XQuery
</title>
<author confidence="0.976533">
Gosse Bouma and Geert Kloosterman
</author>
<affiliation confidence="0.905162333333333">
Information Science
University of Groningen
The Netherlands
</affiliation>
<email confidence="0.993125">
g.bouma|g.j.kloosterman@rug.nl
</email>
<sectionHeader confidence="0.995537" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999789818181818">
This paper presents a uniform approach to
data extraction from syntactically annotated
corpora encoded in XML. XQuery, which
incorporates XPath, has been designed as
a query language for XML. The combina-
tion of XPath and XQuery offers flexibility
and expressive power, while corpus specific
functions can be added to reduce the com-
plexity of individual extraction tasks. We il-
lustrate our approach using examples from
dependency treebanks for Dutch.
</bodyText>
<sectionHeader confidence="0.99899" genericHeader="introduction">
1 Introduction
</sectionHeader>
<bodyText confidence="0.999454578947369">
Manually annotated treebanks have played an im-
portant role in the development of robust and ac-
curate syntactic analysers. Now that such parsers
are available for various languages, there is a grow-
ing interest in research that uses automatically an-
notated corpora. While such corpora are not error-
free, the fact that they can be constructed rela-
tively easily, and the fact that they can be an order
of magnitude larger than manually corrected tree-
banks, makes them attractive for several types of re-
search. Syntactically annotated corpora have suc-
cesfully been used to acquire lexico-semantic infor-
mation (Lin and Pantel, 2001; Snow et al., 2005), for
relation extraction (Bunescu and Mooney, 2005), in
IR (Cui et al., 2005), and in QA (Katz and Lin, 2003;
Moll´a and Gardiner, 2005).
What these tasks have in common is the fact that
they all operate on large amounts of data extracted
from syntactically annotated text. Tools to perform
</bodyText>
<page confidence="0.985606">
17
</page>
<bodyText confidence="0.9950665">
this task are often developed with only a single ap-
plication in mind (mostly corpus linguistics) or are
developed in an ad-hoc fashion, as part of a specific
application.
We propose a more principled approach, based on
two observations:
</bodyText>
<listItem confidence="0.990961666666667">
• XML is widely used to encode syntactic anno-
tation. Syntactic annotation is not more com-
plex that some other types of information that
is routinely stored in XML. This suggests that
XML technology can be used to process syn-
tactically annotated corpora.
• XQuery is a query language for XML data. As
such, it is the obvious choice for mining syn-
tactically annotated corpora.
</listItem>
<bodyText confidence="0.999792733333333">
The remainder of this paper is organised as fol-
lows. In the next section, we present the Alpino tree-
bank format, which we use for syntactic annotation.
The Alpino parser has been used to annotate large
corpora, and the results have been used in a number
of research projects.1
In section 3, we discuss the existing approaches
to data extraction from Alpino corpora. We note that
all of these have drawbacks, either because they lack
expressive power, or because they require a serious
amount of programming overhead.
In section 4, we present our approach, starting
from a relatively straightforward corpus linguistics
task, that requires little more than XPath, and end-
ing with a more advanced relation extraction task,
</bodyText>
<footnote confidence="0.996463">
1See www.let.rug.nl/∼vannoord/research.
html
</footnote>
<note confidence="0.948129">
Proceedings of the Linguistic Annotation Workshop, pages 17–24,
Prague, June 2007. c�2007 Association for Computational Linguistics
</note>
<bodyText confidence="0.9982755">
that requires XQuery. We demonstrate that much of
the complexity of advanced tasks can be avoided by
providing users with a corpus specific module, that
makes available common concepts and functions.
</bodyText>
<sectionHeader confidence="0.921216" genericHeader="method">
2 The Alpino Treebank format
</sectionHeader>
<bodyText confidence="0.9998822">
As part of the development of the Alpino parser
(Bouma et al., 2001), a number of manually an-
notated dependency treebanks have been created
(van der Beek et al., 2002). Annotation guidelines
were adopted from the Corpus of Spoken Dutch
(Oostdijk, 2000), a large corpus annotation project
for Dutch. In addition, large corpora (e.g. the 80M
word Dutch CLEF2 corpus, the 500M word Twente
News corpus3, and Dutch Wikipedia4) have been
annotated automatically. Both types of treebanks
have been used for corpus linguistics (van der Beek,
2005; Villada Moir´on, 2005; Bouma et al., 2007).
The automatically annoted treebanks have been used
for lexical acquisition (van der Plas and Bouma,
2005), and form the core of a Dutch QA system
(Bouma et al., 2005).
The format of Alpino dependency trees is illus-
trated in figure 1. The (somewhat simplified) XML
for this tree is in fig. 2. Nodes in the tree are labeled
with a dependency relation and a category or POS-
tag. Furthermore, the begin and end position of con-
stituents is represented in attributes,5 and the root
and word form of terminal nodes is encoded. Note
that heads do not have their dependents as children,
as is the case in most dependency tree formats. In-
stead, the head is a child of the constituent node if
which it is the head, and its dependents are siblings
of the head. Finally, trees may contain index nodes
(indicated by indices in bold in the graphical repre-
sentation and by the index attribute in the XML) to
indicate ’secondary’ edges. The subject Alan Turing
in fig. 2 is a subject of the passive auxiliary word,
but also a direct object of the verb aan tref. Thus,
Alpino dependency trees are actually graphs.
A large syntactically annotated corpus tends to
</bodyText>
<footnote confidence="0.985508714285714">
2www.clef-campaign.org
3www.vf.utwente.nl/∼druid/TwNC/
TwNC-main.html
4nl.wikipedia.org
5Note that constituents may be discontinuous, and thus, the
yield of a constituent may not contain every terminal node be-
tween begin and end. See also section 4.2.
</footnote>
<figure confidence="0.707846">
–
smain
</figure>
<figureCaption confidence="0.980461">
Figure 1: Op 7 juni 1954 werd Alan Turing dood
</figureCaption>
<bodyText confidence="0.932306777777778">
aangetroffen (On June 7, 1954, Alan Turing was
found dead)
give rise to even larger volumes of XML. To sup-
port efficient storage and retrieval of XML data, a
set of tools has been developed for compression of
XML data (using dictzip6) and for efficient visuali-
sation and search of data in compressed XML files.
The tools are described in more detail at the Alpino
website.7
</bodyText>
<sectionHeader confidence="0.968278" genericHeader="method">
3 Existing approaches to extraction
</sectionHeader>
<bodyText confidence="0.862719">
Users have taken quite different approaches to cor-
pus exploration and data extraction.
• For corpus exploration, Alpino dtsearch is
the most widely used tool. It allows XPath
queries to be matched against trees in a tree-
bank. The result can be a visual display of trees
with matching nodes highlighted, but alterna-
tive outputs are possible as well. Examples of
how XPath can be used for extraction are pre-
sented in the next section.
</bodyText>
<listItem confidence="0.9840735">
• For relation extraction (i.e. finding symptoms
of diseases), the Alpino system itself has been
</listItem>
<footnote confidence="0.888361">
6www.dict.org
7www.let.rug.nl/∼vannoord/alp/Alpino/
TreebankTools.html
</footnote>
<figure confidence="0.990865898305085">
hd
verb
word4
su
1
mwu
vc
ppart
mwp
name
Alan5
mwp
name
Turing6
predc
adj
dood7
hd
verb
tref aan8
hd
prep
op0
obj1
mwu
mwp
noun
19543
obj1
1
mod
pp
mwp
noun
71
mwp
noun
juni2
18
&lt;node begin=&amp;quot;0&amp;quot; cat=&amp;quot;smain&amp;quot; end=&amp;quot;9&amp;quot; rel=&amp;quot;--&amp;quot;&gt;
&lt;node begin=&amp;quot;4&amp;quot; end=&amp;quot;5&amp;quot; pos=&amp;quot;verb&amp;quot; rel=&amp;quot;hd&amp;quot; root=&amp;quot;word&amp;quot; word=&amp;quot;werd&amp;quot;/&gt;
&lt;node begin=&amp;quot;5&amp;quot; cat=&amp;quot;mwu&amp;quot; end=&amp;quot;7&amp;quot; index=&amp;quot;1&amp;quot; rel=&amp;quot;su&amp;quot;&gt;
&lt;node begin=&amp;quot;5&amp;quot; end=&amp;quot;6&amp;quot; pos=&amp;quot;name&amp;quot; rel=&amp;quot;mwp&amp;quot; neclass=&amp;quot;PER&amp;quot; root=&amp;quot;Alan&amp;quot; word=&amp;quot;Alan&amp;quot;/&gt;
&lt;node begin=&amp;quot;6&amp;quot; end=&amp;quot;7&amp;quot; pos=&amp;quot;name&amp;quot; rel=&amp;quot;mwp&amp;quot; neclass=&amp;quot;PER&amp;quot; root=&amp;quot;Turing&amp;quot; word=&amp;quot;Turing&amp;quot;/&gt;
&lt;/node&gt;
&lt;node begin=&amp;quot;0&amp;quot; cat=&amp;quot;ppart&amp;quot; end=&amp;quot;9&amp;quot; rel=&amp;quot;vc&amp;quot;&gt;
&lt;node begin=&amp;quot;0&amp;quot; cat=&amp;quot;pp&amp;quot; end=&amp;quot;4&amp;quot; rel=&amp;quot;mod&amp;quot;&gt;
&lt;node begin=&amp;quot;0&amp;quot; end=&amp;quot;1&amp;quot; pos=&amp;quot;prep&amp;quot; rel=&amp;quot;hd&amp;quot; root=&amp;quot;op&amp;quot; word=&amp;quot;Op&amp;quot;/&gt;
&lt;node begin=&amp;quot;1&amp;quot; cat=&amp;quot;mwu&amp;quot; end=&amp;quot;4&amp;quot; rel=&amp;quot;obj1&amp;quot;&gt;
&lt;node begin=&amp;quot;1&amp;quot; end=&amp;quot;2&amp;quot; pos=&amp;quot;noun&amp;quot; rel=&amp;quot;mwp&amp;quot; root=&amp;quot;7&amp;quot; word=&amp;quot;7&amp;quot;/&gt;
&lt;node begin=&amp;quot;2&amp;quot; end=&amp;quot;3&amp;quot; pos=&amp;quot;noun&amp;quot; rel=&amp;quot;mwp&amp;quot; root=&amp;quot;juni&amp;quot; word=&amp;quot;juni&amp;quot;/&gt;
&lt;node begin=&amp;quot;3&amp;quot; end=&amp;quot;4&amp;quot; pos=&amp;quot;noun&amp;quot; rel=&amp;quot;mwp&amp;quot; root=&amp;quot;1954&amp;quot; word=&amp;quot;1954&amp;quot;/&gt;
&lt;/node&gt;
&lt;/node&gt;
&lt;node begin=&amp;quot;5&amp;quot; end=&amp;quot;7&amp;quot; index=&amp;quot;1&amp;quot; rel=&amp;quot;obj1&amp;quot;/&gt;
&lt;node begin=&amp;quot;7&amp;quot; end=&amp;quot;8&amp;quot; pos=&amp;quot;adj&amp;quot; rel=&amp;quot;predc&amp;quot; root=&amp;quot;dood&amp;quot; word=&amp;quot;dood&amp;quot;/&gt;
&lt;node begin=&amp;quot;8&amp;quot; end=&amp;quot;9&amp;quot; pos=&amp;quot;verb&amp;quot; rel=&amp;quot;hd&amp;quot; root=&amp;quot;tref_aan&amp;quot; word=&amp;quot;aangetroffen&amp;quot;/&gt;
&lt;/node&gt;
&lt;/node&gt;
</figure>
<figureCaption confidence="0.999353">
Figure 2: XML encoding of the Alpino depedency tree in fig. 1
</figureCaption>
<bodyText confidence="0.6916534">
used. It provides functionality for converting
dependency trees in XML into a Prolog list of
dependency triples. The full functionality of
Prolog can then be used to do the actual extrac-
tion.
</bodyText>
<listItem confidence="0.983061833333333">
• Alternatively, one can use XSLT to extract data
from the XML directly. As XSLT is primarily
intended for transformations, this tends to give
rise to complex code.
• Alternatively, a general purpose scripting or
programming language such as Perl or Python,
with suitable XML support, can be used. As in
the Alpino/Prolog case, this has the advantage
that one has a full programming language avail-
able. A disadvantage is that there is no specific
support for working with dependency trees or
triples.
</listItem>
<bodyText confidence="0.9998643">
None of the approaches listed above is optimal.
XPath is suitable only for identifying syntactic pat-
terns, and does not offer the possibility of extraction
of elements (i.e. it has no capturing mechanism).
The other three approaches do allow for both match-
ing and extraction, but they all require skills that go
considerably beyond conceptual knowledge of the
treebank and some basic knowledge of XML.
Another disadvantage of the current situation is
that there is little or no sharing of solutions be-
tween users. Yet, different applications tend to en-
counter the same problems. For instance, multiword
expressions (such as Alan Turing or 7 juni 1954)
are encoded as trees, dominated by a cat=’mwu’
node. An extraction task that requires names
to be extracted must thus take into account the
fact that names can be both nodes with a label
pos=’name’ as well as cat=’mwu’ nodes (dom-
inating a pos=’name’). The situation is further
complicated by the fact that individual parts of a
name, such as Alan in Alan Turing, should nor-
mally not be matched. Similar problems arise if
one wants to match e.g. finite verbs (there is no
single attribute which expresses tense) or NPs (the
cat=’np’ attribute is only present on complex
NPs, not on single words). A very frequent issue
is the proper handling of index nodes. Searching
for the object of the verb tref aan in fig. 2 requires
that one finds the node in the tree that is coindexed
with the rel=’obj1’ node with index 1. This is
a challenge in all approaches listed above, except
for Alpino/Prolog, which solves the problem by con-
verting trees to sets of dependency triples.
Some of the problems mentioned above could be
solved by introducing more and more fine-grained
attributes (i.e. a separate attribute for tense, as-
signing both a category and a POS-tag to (non-
head) terminal-nodes, etc.) or by introducing unary
branching nodes. This has the obvious drawback
of introducing redundancy in the encoding, would
</bodyText>
<page confidence="0.996293">
19
</page>
<bodyText confidence="0.9999895">
mean another departure from the usual conception
of dependency trees (in the case unary branching is
introduced), and may still not cover all distinctions
that users need to make. Also, finding the content of
an index-node cannot be solved in this way.
One might consider moving to a radically differ-
ent treebank format, such as Tiger XML8 for in-
stance, in which trees are basically a listing of nodes,
with non-terminal nodes dominating a number of
edge elements that take (the index of) other nodes
as value. Note, however, that most of the problems
mentioned above refer to linguistic concepts, and
thus are unlikely to be solved by changing the ar-
chitecture of the underlying XML representation.
</bodyText>
<sectionHeader confidence="0.93032" genericHeader="evaluation">
4 XQuery and XPath
</sectionHeader>
<bodyText confidence="0.999952869565217">
Two closely related standards for processing XML
documents are XSLT9 and XQuery10 . Both make
use of XPath11, the XML language for locating parts
of XML documents. While XSLT is primarily in-
tended for transformations of documents, XQuery
is primarily intended for extraction of information
from XML databases. XQuery is in many respects
similar to SQL and is rapidly becoming the standard
for XML database systems.12 A distinctive differ-
ence between the XSLT and XQuery is the fact that
XSLT documents are themselves XML documents,
whereas this is not the case for XQuery. This typi-
cally makes XQuery more concise and easier to read
than XSLT.13
These considerations made us experiment with
XQuery as a language for data extraction from syn-
tactically annotated corpora. Similar studies were
carried out by Cassidy (2002) (for an early version
of XQuery) and Mayo et al. (2006), who compare
the NITE Query Language and XQuery. Below, we
first illustrate a task that requires use of XPath only,
and then move on to tasks that require the additional
functionality of XQuery.
</bodyText>
<footnote confidence="0.998070625">
8www.ims.uni-stuttgart.de/projekte/
TIGER/
9www.w3.org/TR/xslt20
10www.w3.org/TR/xquery
11www.w3.org/TR/xpath20
12e.g.exist.sourceforge.net,monetdb.cwi.nl,
www.oracle.com/database/berkeley-db/xml
13See Kay (2005) for a thorough comparison.
</footnote>
<subsectionHeader confidence="0.885601">
4.1 Corpus exploration with XPath
</subsectionHeader>
<bodyText confidence="0.995514673469388">
As argued in Bouma and Kloosterman (2002),
XPath provides a powerful query language for for-
mulating linguistically relevant queries, provided
that the XML encoding of the treebank reflects the
syntactic structure of the trees.
Inherent reflexive verbs, for instance, are verbal
heads with a rel=’se’ dependent. A verb with an
inherently reflexive can therefore be found as fol-
lows (remember that in Alpino dependency trees,
dependents are actually siblings of the head):
//node[@pos=&amp;quot;verb&amp;quot;
and @rel=&amp;quot;hd&amp;quot;
and ../node[@rel=&amp;quot;se&amp;quot;]
]
The double slash (’//’) ensures that we search for
nodes anywhere within the XML document. The
material in brackets ([ ]) can be used to specify
additional constraints that matching nodes have to
meet. The @-sign is used to refer to attributes of an
element. The double dots (’..’) locate the parent el-
ement of an XML element. Children of an element
are located using the single slash (’/’) operator. The
two can be combined to locate siblings.
Comparison operators are available to compare
e.g. attributes that have a numeric value. The follow-
ing XPath query identifies cases where the reflexive
precedes the subject:
//node[@pos=&amp;quot;verb&amp;quot;
and @rel=&amp;quot;hd&amp;quot;
and ../node[@rel=&amp;quot;se&amp;quot;]/@begin &lt;
../node[@rel=&amp;quot;su&amp;quot;]/@begin
]
Note that we can also use the ’/’ to locate attributes
of an element, and that the begin attribute encodes
the initial string position of a constituent.
Reflexives preceding the subject are a marked op-
tion in Dutch. We may contrast matching verbs with
verbs matching the following expression:
//node[@pos=&amp;quot;verb&amp;quot;
and @rel=&amp;quot;hd&amp;quot;
and ../node[@rel=&amp;quot;se&amp;quot;]/@begin &gt;
../node[@rel=&amp;quot;su&amp;quot;]/@begin
and not(../node[@rel=&amp;quot;su&amp;quot;]/@begin=&amp;quot;0&amp;quot;)
]
Here we have simply reversed the comparison op-
erator. As we want to exclude from considera-
tion cases where the subject precedes the finite verb
(e.g. is in sentence-initial position), we have added a
negative constraint with this effect.
</bodyText>
<page confidence="0.9823">
20
</page>
<table confidence="0.999448">
REFL-SU SU-REFL
% # % #
94.3 33 5.7 2
91.7 11 8.3 1
74.1 234 25.9 82
73.5 36 26.5 13
58.8 10 41.2 7
57.1 44 42.9 33
56.0 42 44.0 33
54.6 309 45.4 257
50.0 18 50.0 18
48.3 58 51.7 62
</table>
<tableCaption confidence="0.988364">
Table 1: Relative frequency of REFL-SU vs SU-REFL
word order
</tableCaption>
<bodyText confidence="0.998303111111111">
Using the two queries above to search one year
of newspaper text, we can collect the outcome and
compute, for a given verb, the relative frequency of
REFL-SU vs. SU-REFL order for non-subject initial
sentences in Dutch. A sample of verbs that have a
high percentage of REFL-SU occurrences, is given in
table 1. The result confirms an observation in Hae-
sereyn et al. (1997), that REFL-SU word order occurs
especially with verbs having a somewhat ’bleeched
semantics’ and expressing that something exists or
comes into existence.
It should be noted that XPath offers consider-
able more possibilities than what is illustrated here.
XPath 2.0 in particular is an important step forward
for linguistic search, as it includes far more func-
tionality for string processing (i.e. tokenization and
regular expressions) than its predecessors. Bird et al.
(2006) propose an extension of XPath 1.0 for lin-
guistic queries. The intuitive notation they intro-
duce might be useful for some users. However,
the examples they concentrate on (all having to do
with linear order) presuppose trees without ’cross-
ing branches’. The introduction of begin and end
attributes in the Alpino format makes it possible
to handle such queries for dependency trees (with
crossing branches) as well, and furthermore, does
not require an extension of XPath.
</bodyText>
<subsectionHeader confidence="0.969453">
4.2 Data Extraction with XQuery
</subsectionHeader>
<bodyText confidence="0.999990666666667">
The kind of explorative corpus search for which
XPath is ideally suited is supported by most other
treebank query languages as well, although not all
alternatives offer the same expressive power. There
are many applications, however, in which it is neces-
sary to extract more than just (root forms of) match-
ing nodes. XQuery offers the functionality that is
required to perform arbitrary extraction.
XQuery programs consist of so-called FLWOR
expressions (for, let, where, order by,
return, not all parts are required). The example
below illustrates this. Assume we want to extract
from a treebank all occurrences of names, along with
their named entity class. The following XQuery
script covers the base case.
</bodyText>
<equation confidence="0.918339428571428">
for $name in
collection(’ad1994’)//node[@pos=&amp;quot;name&amp;quot;]
let $nec := string($node/@neclass)
return
&lt;term nec=&amp;quot;{$nec}&amp;quot;&gt;
{string($name/@word)}
&lt;/term&gt;
</equation>
<bodyText confidence="0.87337255">
The for-statement locates the nodes to be pro-
cessed. Nodes are located by XPath expressions.
The collection-predicate defines the directory to be
processed. For every document in the collection,
nodes with a POS-attribute name are processed. We
use a let-statement to assign the variable $nec is
assigned the string value of the neclass-attibute
(which indicates the named entity class of the name).
The return-statement returns for each matching
node an XML element containing the string value of
the word attribute of the name, as well as an attribute
indicating the named entity class.
The complexity of XQuery scripts can increase
considerably, depending on the complexity of the
underlying XML data and the task being performed.
One of the most interesting features of XQuery is the
possibility to define functions. They can be used to
enhance the readibility of code. Furthermore, func-
tions can be collected in modules, and thus can be
reused across applications.
For Alpino treebanks, for instance, we have
implemented a module that covers concepts and
tasks that are needed frequently. As pointed
out above, names in the Alpino treebank are not
just single nodes, but, in case a name consists
of two or more words, can also consist of mul-
tiple node[@pos=’name’] elements, with a
node[@cat=’mwu’] as parent. This motivates
the introduction of a name and neclass function,
verb (gloss)
vorm (to shape)
ontvouw (to unfold)
doe voor (to happen)
teken af (to form)
wreek (to take revenge)
voltrek (to take place)
verzamel (to assemble)
bevind (to be located)
dring op (to impose)
dien aan (to announce)
</bodyText>
<page confidence="0.98919">
21
</page>
<bodyText confidence="0.933579613636364">
as shown in fig. 3. Assuming that the alpino mod-
ule has been imported, we can now write a better
name extraction script:
for $name in
collection(’ad1994’)//node
where alpino:name($name)
return
&lt;term nec=&amp;quot;{alpino:neclass($name)}&amp;quot;&gt;
{alpino:yield{$name)}
&lt;/term&gt;
As we are matching with non-terminal nodes as
well, we need to take into account that it no longer
suffices to return the value of word to obtain the
yield of a node. As this situation arises frequently
as well, we added a yield function (see fig. 3).
It takes a node as argument, collects all descen-
dant node/@word attribute values in the variable
$words, sorted by the begin value of their node
element. The yield function returns the string con-
catenation of the elements in $words, separated by
blanks. Note that this solution also gives the correct
result for discontinuous constituents.
We used a wrapper around the XQuery processor
Saxon14 to execute XQuery scripts directly on com-
pacted corpora. The result is output such as:
&lt;term nec=&amp;quot;ORG&amp;quot;&gt;PvdA&lt;/term&gt;
&lt;term nec=&amp;quot;LOC&amp;quot;&gt;Atlantische Oceaan&lt;/term&gt;
A more advanced relation extraction example is
given in fig. 4. It is a script for extraction of events
involving the death of a person from a syntactically
annotated corpus (Dutch wikipedia in this case). It
will return the name of the person who died, and,
if these can be found in the same sentence, the
date, location, and cause of death.15 The script
makes heavy use of functions from the alpino
module that were added to facilitate relation extrac-
tion. The selector-of function defines the ’se-
mantic head’ of a phrase. This is either the sibling
marked rel=’hd’, or (for nodes that are them-
selves heads) the head of the mother. For apposi-
tions and conjuncts, it it the selector of the head.
Note that the last case involves a recursive function
call. Similarly, the semantic role is normally iden-
tical to the value of the rel-attribute, but we go up
</bodyText>
<footnote confidence="0.986691666666667">
14www.saxonica.com
15Questions about such facts are relatively frequent in Ques-
tion Answering evaluation tasks.
</footnote>
<bodyText confidence="0.995746322580645">
one additional level for heads, appositions and con-
juncts. The value of $resolved is given by the
resolve-index function shown in fig. 3, i.e. if a
node is just an index (as is the case for the object of
aan tref in fig. 1), the ’antecedent’ node is returned.
In all other cases, the node itself is returned. Date
and place are found using functions for locating the
date and place dependents of the verb. Finally, rel-
evant events are found using the die-verb and
kill-verb functions.
Some examples of the output of the extraction
script are (i.e. John Lennon was killed on Decem-
ber 8, 1980, and Erasmus died in Basel on July, 12,
1536):
&lt;died-how place=&amp;quot;nil&amp;quot; file=&amp;quot;1687-98&amp;quot;
person=&amp;quot;John Lennon&amp;quot; cause=&amp;quot;vermoord&amp;quot;
date=&amp;quot;op 8 december 1980&amp;quot;/&gt;
&lt;died-how place=&amp;quot;in Bazel&amp;quot; file=&amp;quot;20336-37&amp;quot;
person=&amp;quot;Erasmus&amp;quot; cause=&amp;quot;overlijd&amp;quot;
date=&amp;quot;op 12 juli 1536&amp;quot;/&gt;
The functions illustrated in the two examples can
be used for a range of similar data extraction tasks,
whether these are intended for corpus linguistics re-
search or as part of an information extraction sys-
tem. The definition of corpus specific functions that
cover frequently used syntactic and semantic con-
cepts allows the application specific code to be rel-
atively compact and straightforward. In addition,
code which builds upon well tested corpus specific
functions tends to give more accurate results than
code developed from scratch.
</bodyText>
<sectionHeader confidence="0.999442" genericHeader="conclusions">
5 Conclusions
</sectionHeader>
<bodyText confidence="0.999956416666667">
In this paper, we have presented an approach to min-
ing syntactically corpora that uses standard XML
technology. It can be used both for corpus explo-
ration as well as for information extraction tasks. By
providing a corpus specific module, the complexity
of such tasks can be reduced. By adopting standard
XML languages, we can benefit optimally from the
fact that these are far more expressive than what is
provided in application specific languages or tools.
In addition, there is no shortage of tools or platforms
supporting these languages. Thus, development of
corpus specific tools can be kept at a minimum.
</bodyText>
<page confidence="0.993016">
22
</page>
<figure confidence="0.629930035714286">
module namespace alpino=&amp;quot;alpino.xq&amp;quot; ;
declare function name($constituent as element(node)) as xs:boolean
{ if ( $constituent[@pos=’name’] or
$constituent[@cat = ’mwu’]/node[@neclass=’PER’] )
then fn:true()
else fn:false()
};
declare function neclass($constituent as element(node)) as xs:string
{ if $constituent[@neclass]
then fn:string($constituent/@neclass)
else if $constituent/node[@neclass]
then fn:string($constituent/node[1]/@neclass)
};
declare function alpino:yield($constituent as element(node)) as xs:string
{ let $words :=
for $leaf in $constituent/descendant-or-self::node[@word]
order by number($leaf/@begin)
return $leaf/@word
return string-join($words,&amp;quot; &amp;quot;)
};
declare function alpino:resolve-index($constituent as element(node))
as element(node)
{ if ( $constituent[@index and not(@pos or @cat)] )
then $constituent/ancestor::alpino_ds/
descendant::node
[@index = $constituent/@index and (@pos or @cat)]
else $constituent
};
</figure>
<figureCaption confidence="0.997476">
Figure 3: XQuery module (fragment) for Alpino treebanks
</figureCaption>
<construct confidence="0.74055655">
for $node in collection(’wikipedia’)/alpino_ds//node
let $verb := alpino:selector-of($node)
let $date := if ( exists(alpino:date-dependents($verb)) )
then alpino:yield(alpino:date-dependents($verb)[1])
else ’nil’
let $place := if ( exists(alpino:location-dependents($verb)) )
then alpino:yield(alpino:location-dependents($verb)[1])
else ’nil’
let $cause := if ( $verb/../node[@rel=&amp;quot;pc&amp;quot;]/node[@root=&amp;quot;aan&amp;quot;] )
then alpino:yield($verb/../node[@rel=&amp;quot;pc&amp;quot;])
else [[omitted]]
let $role := alpino:semantic-role($node)
let $resolved := alpino:resolve-index($node)
where alpino:person-node($resolved)
and ( ( $role=&amp;quot;su&amp;quot; and alpino:die-verb($verb) )
or ( $role=&amp;quot;obj1&amp;quot; and alpino:kill-verb($verb) )
)
return
&lt;died-how file=&amp;quot;{alpino:file-id($node)}&amp;quot; person=&amp;quot;{alpino:root-string($resolved)}&amp;quot;
cause=&amp;quot;{$cause}&amp;quot; date=&amp;quot;{$date}&amp;quot; place = &amp;quot;{$place}&amp;quot; /&gt;
</construct>
<figureCaption confidence="0.989842">
Figure 4: Extracting circumstances of the death of a person
</figureCaption>
<page confidence="0.996327">
23
</page>
<sectionHeader confidence="0.989829" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999735693181818">
Steven Bird, Yi Chen, Susan B. Davidson, Haejoong
Lee, and Yifeng Zheng. Designing and evalu-
ating an XPath dialect for linguistic queries. In
Proceedings of 22nd International Conference on
Data Engineering (ICDE), 2006.
Gosse Bouma and Geert Kloosterman. Querying de-
pendency treebanks in XML. In Proceedings of
the 3rd conference on Language Resources and
Evaluation (LREC), Gran Canaria, 2002.
Gosse Bouma, Gertjan van Noord, and Robert Mal-
ouf. Alpino: Wide-coverage computational analy-
sis of Dutch. In Computational Linguistics in The
Netherlands 2000. Rodopi, Amsterdam, 2001.
Gosse Bouma, Ismail Fahmi, Jori Mur, Gertjan van
Noord, Lonneke van der Plas, and J¨org Tiede-
man. Linguistic knowledge and question answer-
ing. Traitement Automatique des Langues, 2(46):
15–39, 2005.
Gosse Bouma, Petra Hendriks, and Jack Hoeksema.
Focus particles inside prepositional phrases: A
comparison of Dutch, English, and German. Jour-
nal of Comparative Germanic Linguistics, 10(1),
2007.
Razvan Bunescu and Raymond Mooney. A short-
est path dependency kernel for relation extraction.
In Proceedings of HLT/EMNLP, pages 724–731,
Vancouver, 2005.
Steve Cassidy. XQuery as an annotation query lan-
guage: a use case analysis. In Language Re-
sources and Evaluation Conference (LREC), Gran
Canaria, 2002.
Hang Cui, Renxu Sun, Keya Li, Min-Yen Kan, and
Tat-Seng Chua. Question answering passage re-
trieval using dependency relations. In Proceed-
ings of SIGIR 05, Salvador, Brazil, 2005.
W. Haesereyn, K. Romijn, G. Geerts, J. De Rooy,
and M.C. Van den Toorn. Algemene Nederlandse
Spraakkunst. Martinus Nijhoff Uitgevers Gronin-
gen / Wolters Plantyn Deurne, 1997.
Boris Katz and Jimmy Lin. Selectively using rela-
tions to improve precision in question answering.
In Proceedings of the workshop on Natural Lan-
guage Processing for Question Answering (EACL
2003), pages 43–50, Budapest, 2003. EACL.
Michael Kay. Comparing XSLT and XQuery.
In Proceedings of XTech 2005, Amsterdam,
2005. URL www.idealliance.org/
proceedings/xtech05.
Dekan Lin and Patrick Pantel. Discovery of infer-
ence rules for question answering. Natural Lan-
guage Engineering, 7:343–360, 2001.
Neil Mayo, Jonathan Kilgour, and Jean Carletta.
Towards an alternative implementation of NXT
query language via XQuery. In Proceedings of the
EACL Workshop on Multi-dimensional Markup in
NLP, Trento, 2006.
D. Moll´a and M. Gardiner. Answerfinder - ques-
tion answering by combining lexical, syntactic
and semantic information. In Australasian Lan-
guage Technology Workshop (ALTW) 2004, Syd-
ney, 2005.
Nelleke Oostdijk. The Spoken Dutch Corpus:
Overview and first evaluation. In Proceedings of
LREC 2000, pages 887–894, 2000.
Rion Snow, Daniel Jurafsky, and Andrew Y. Ng.
Learning syntactic patterns for automatic hyper-
nym discovery. In Lawrence K. Saul, Yair Weiss,
and Lon Bottou, editors, Advances in Neural In-
formation Processing Systems 17, pages 1297–
1304. MIT Press, Cambridge, MA, 2005.
L. van der Beek, G. Bouma, R. Malouf, and
G. van Noord. The Alpino dependency treebank.
In Computational Linguistics in the Netherlands
(CLIN) 2001, Twente University, 2002.
Leonoor van der Beek. Topics in Corpus Based
Dutch Syntax. PhD thesis, University of Gronin-
gen, Groningen, 2005.
Lonneke van der Plas and Gosse Bouma. Auto-
matic acquisition of lexico-semantic knowledge
for question answering. In Proceedings of On-
tolex 2005 – Ontologies and Lexical Resources,
Jeju Island, South Korea, 2005.
Bego˜na Villada Moir´on. Linguistically enriched
corpora for establishing variation in support verb
constructions. In Proceedings of the 6th Inter-
national Workshop on Linguistically Interpreted
Corpora (LINC-2005), Jeju Island, Republic of
Korea, 2005.
</reference>
<page confidence="0.999178">
24
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.372855">
<title confidence="0.999084">Mining Syntactically Annotated Corpora with XQuery</title>
<author confidence="0.990025">Bouma</author>
<affiliation confidence="0.792205">Information University of The</affiliation>
<abstract confidence="0.993855083333333">This paper presents a uniform approach to data extraction from syntactically annotated corpora encoded in XML. XQuery, which incorporates XPath, has been designed as a query language for XML. The combination of XPath and XQuery offers flexibility and expressive power, while corpus specific functions can be added to reduce the complexity of individual extraction tasks. We illustrate our approach using examples from dependency treebanks for Dutch.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Steven Bird</author>
<author>Yi Chen</author>
<author>Susan B Davidson</author>
<author>Haejoong Lee</author>
<author>Yifeng Zheng</author>
</authors>
<title>Designing and evaluating an XPath dialect for linguistic queries.</title>
<date>2006</date>
<booktitle>In Proceedings of 22nd International Conference on Data Engineering (ICDE),</booktitle>
<contexts>
<context position="15327" citStr="Bird et al. (2006)" startWordPosition="2423" endWordPosition="2426"> verbs that have a high percentage of REFL-SU occurrences, is given in table 1. The result confirms an observation in Haesereyn et al. (1997), that REFL-SU word order occurs especially with verbs having a somewhat ’bleeched semantics’ and expressing that something exists or comes into existence. It should be noted that XPath offers considerable more possibilities than what is illustrated here. XPath 2.0 in particular is an important step forward for linguistic search, as it includes far more functionality for string processing (i.e. tokenization and regular expressions) than its predecessors. Bird et al. (2006) propose an extension of XPath 1.0 for linguistic queries. The intuitive notation they introduce might be useful for some users. However, the examples they concentrate on (all having to do with linear order) presuppose trees without ’crossing branches’. The introduction of begin and end attributes in the Alpino format makes it possible to handle such queries for dependency trees (with crossing branches) as well, and furthermore, does not require an extension of XPath. 4.2 Data Extraction with XQuery The kind of explorative corpus search for which XPath is ideally suited is supported by most ot</context>
</contexts>
<marker>Bird, Chen, Davidson, Lee, Zheng, 2006</marker>
<rawString>Steven Bird, Yi Chen, Susan B. Davidson, Haejoong Lee, and Yifeng Zheng. Designing and evaluating an XPath dialect for linguistic queries. In Proceedings of 22nd International Conference on Data Engineering (ICDE), 2006.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Gosse Bouma</author>
<author>Geert Kloosterman</author>
</authors>
<title>Querying dependency treebanks in XML.</title>
<date>2002</date>
<booktitle>In Proceedings of the 3rd conference on Language Resources and Evaluation (LREC), Gran Canaria,</booktitle>
<contexts>
<context position="12369" citStr="Bouma and Kloosterman (2002)" startWordPosition="1948" endWordPosition="1951">d corpora. Similar studies were carried out by Cassidy (2002) (for an early version of XQuery) and Mayo et al. (2006), who compare the NITE Query Language and XQuery. Below, we first illustrate a task that requires use of XPath only, and then move on to tasks that require the additional functionality of XQuery. 8www.ims.uni-stuttgart.de/projekte/ TIGER/ 9www.w3.org/TR/xslt20 10www.w3.org/TR/xquery 11www.w3.org/TR/xpath20 12e.g.exist.sourceforge.net,monetdb.cwi.nl, www.oracle.com/database/berkeley-db/xml 13See Kay (2005) for a thorough comparison. 4.1 Corpus exploration with XPath As argued in Bouma and Kloosterman (2002), XPath provides a powerful query language for formulating linguistically relevant queries, provided that the XML encoding of the treebank reflects the syntactic structure of the trees. Inherent reflexive verbs, for instance, are verbal heads with a rel=’se’ dependent. A verb with an inherently reflexive can therefore be found as follows (remember that in Alpino dependency trees, dependents are actually siblings of the head): //node[@pos=&amp;quot;verb&amp;quot; and @rel=&amp;quot;hd&amp;quot; and ../node[@rel=&amp;quot;se&amp;quot;] ] The double slash (’//’) ensures that we search for nodes anywhere within the XML document. The material in brack</context>
</contexts>
<marker>Bouma, Kloosterman, 2002</marker>
<rawString>Gosse Bouma and Geert Kloosterman. Querying dependency treebanks in XML. In Proceedings of the 3rd conference on Language Resources and Evaluation (LREC), Gran Canaria, 2002.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Gosse Bouma</author>
<author>Gertjan van Noord</author>
<author>Robert Malouf</author>
</authors>
<title>Alpino: Wide-coverage computational analysis of Dutch.</title>
<date>2000</date>
<booktitle>In Computational Linguistics in The Netherlands</booktitle>
<location>Rodopi, Amsterdam,</location>
<marker>Bouma, van Noord, Malouf, 2000</marker>
<rawString>Gosse Bouma, Gertjan van Noord, and Robert Malouf. Alpino: Wide-coverage computational analysis of Dutch. In Computational Linguistics in The Netherlands 2000. Rodopi, Amsterdam, 2001.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Gosse Bouma</author>
<author>Ismail Fahmi</author>
<author>Jori Mur</author>
<author>Gertjan van Noord</author>
<author>Lonneke van der Plas</author>
<author>J¨org Tiedeman</author>
</authors>
<title>Linguistic knowledge and question answering.</title>
<date>2005</date>
<booktitle>Traitement Automatique des Langues,</booktitle>
<volume>2</volume>
<issue>46</issue>
<pages>15--39</pages>
<marker>Bouma, Fahmi, Mur, van Noord, van der Plas, Tiedeman, 2005</marker>
<rawString>Gosse Bouma, Ismail Fahmi, Jori Mur, Gertjan van Noord, Lonneke van der Plas, and J¨org Tiedeman. Linguistic knowledge and question answering. Traitement Automatique des Langues, 2(46): 15–39, 2005.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Gosse Bouma</author>
<author>Petra Hendriks</author>
<author>Jack Hoeksema</author>
</authors>
<title>Focus particles inside prepositional phrases: A comparison of Dutch, English, and German.</title>
<date>2007</date>
<journal>Journal of Comparative Germanic Linguistics,</journal>
<volume>10</volume>
<issue>1</issue>
<contexts>
<context position="3910" citStr="Bouma et al., 2007" startWordPosition="615" endWordPosition="618">ctions. 2 The Alpino Treebank format As part of the development of the Alpino parser (Bouma et al., 2001), a number of manually annotated dependency treebanks have been created (van der Beek et al., 2002). Annotation guidelines were adopted from the Corpus of Spoken Dutch (Oostdijk, 2000), a large corpus annotation project for Dutch. In addition, large corpora (e.g. the 80M word Dutch CLEF2 corpus, the 500M word Twente News corpus3, and Dutch Wikipedia4) have been annotated automatically. Both types of treebanks have been used for corpus linguistics (van der Beek, 2005; Villada Moir´on, 2005; Bouma et al., 2007). The automatically annoted treebanks have been used for lexical acquisition (van der Plas and Bouma, 2005), and form the core of a Dutch QA system (Bouma et al., 2005). The format of Alpino dependency trees is illustrated in figure 1. The (somewhat simplified) XML for this tree is in fig. 2. Nodes in the tree are labeled with a dependency relation and a category or POStag. Furthermore, the begin and end position of constituents is represented in attributes,5 and the root and word form of terminal nodes is encoded. Note that heads do not have their dependents as children, as is the case in mos</context>
</contexts>
<marker>Bouma, Hendriks, Hoeksema, 2007</marker>
<rawString>Gosse Bouma, Petra Hendriks, and Jack Hoeksema. Focus particles inside prepositional phrases: A comparison of Dutch, English, and German. Journal of Comparative Germanic Linguistics, 10(1), 2007.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Razvan Bunescu</author>
<author>Raymond Mooney</author>
</authors>
<title>A shortest path dependency kernel for relation extraction.</title>
<date>2005</date>
<booktitle>In Proceedings of HLT/EMNLP,</booktitle>
<pages>724--731</pages>
<location>Vancouver,</location>
<contexts>
<context position="1347" citStr="Bunescu and Mooney, 2005" startWordPosition="200" endWordPosition="203">pment of robust and accurate syntactic analysers. Now that such parsers are available for various languages, there is a growing interest in research that uses automatically annotated corpora. While such corpora are not errorfree, the fact that they can be constructed relatively easily, and the fact that they can be an order of magnitude larger than manually corrected treebanks, makes them attractive for several types of research. Syntactically annotated corpora have succesfully been used to acquire lexico-semantic information (Lin and Pantel, 2001; Snow et al., 2005), for relation extraction (Bunescu and Mooney, 2005), in IR (Cui et al., 2005), and in QA (Katz and Lin, 2003; Moll´a and Gardiner, 2005). What these tasks have in common is the fact that they all operate on large amounts of data extracted from syntactically annotated text. Tools to perform 17 this task are often developed with only a single application in mind (mostly corpus linguistics) or are developed in an ad-hoc fashion, as part of a specific application. We propose a more principled approach, based on two observations: • XML is widely used to encode syntactic annotation. Syntactic annotation is not more complex that some other types of i</context>
</contexts>
<marker>Bunescu, Mooney, 2005</marker>
<rawString>Razvan Bunescu and Raymond Mooney. A shortest path dependency kernel for relation extraction. In Proceedings of HLT/EMNLP, pages 724–731, Vancouver, 2005.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Steve Cassidy</author>
</authors>
<title>XQuery as an annotation query language: a use case analysis.</title>
<date>2002</date>
<booktitle>In Language Resources and Evaluation Conference (LREC), Gran Canaria,</booktitle>
<contexts>
<context position="11802" citStr="Cassidy (2002)" startWordPosition="1880" endWordPosition="1881">formations of documents, XQuery is primarily intended for extraction of information from XML databases. XQuery is in many respects similar to SQL and is rapidly becoming the standard for XML database systems.12 A distinctive difference between the XSLT and XQuery is the fact that XSLT documents are themselves XML documents, whereas this is not the case for XQuery. This typically makes XQuery more concise and easier to read than XSLT.13 These considerations made us experiment with XQuery as a language for data extraction from syntactically annotated corpora. Similar studies were carried out by Cassidy (2002) (for an early version of XQuery) and Mayo et al. (2006), who compare the NITE Query Language and XQuery. Below, we first illustrate a task that requires use of XPath only, and then move on to tasks that require the additional functionality of XQuery. 8www.ims.uni-stuttgart.de/projekte/ TIGER/ 9www.w3.org/TR/xslt20 10www.w3.org/TR/xquery 11www.w3.org/TR/xpath20 12e.g.exist.sourceforge.net,monetdb.cwi.nl, www.oracle.com/database/berkeley-db/xml 13See Kay (2005) for a thorough comparison. 4.1 Corpus exploration with XPath As argued in Bouma and Kloosterman (2002), XPath provides a powerful query</context>
</contexts>
<marker>Cassidy, 2002</marker>
<rawString>Steve Cassidy. XQuery as an annotation query language: a use case analysis. In Language Resources and Evaluation Conference (LREC), Gran Canaria, 2002.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Hang Cui</author>
<author>Renxu Sun</author>
<author>Keya Li</author>
<author>Min-Yen Kan</author>
<author>Tat-Seng Chua</author>
</authors>
<title>Question answering passage retrieval using dependency relations.</title>
<date>2005</date>
<booktitle>In Proceedings of SIGIR 05,</booktitle>
<location>Salvador, Brazil,</location>
<contexts>
<context position="1373" citStr="Cui et al., 2005" startWordPosition="206" endWordPosition="209">ctic analysers. Now that such parsers are available for various languages, there is a growing interest in research that uses automatically annotated corpora. While such corpora are not errorfree, the fact that they can be constructed relatively easily, and the fact that they can be an order of magnitude larger than manually corrected treebanks, makes them attractive for several types of research. Syntactically annotated corpora have succesfully been used to acquire lexico-semantic information (Lin and Pantel, 2001; Snow et al., 2005), for relation extraction (Bunescu and Mooney, 2005), in IR (Cui et al., 2005), and in QA (Katz and Lin, 2003; Moll´a and Gardiner, 2005). What these tasks have in common is the fact that they all operate on large amounts of data extracted from syntactically annotated text. Tools to perform 17 this task are often developed with only a single application in mind (mostly corpus linguistics) or are developed in an ad-hoc fashion, as part of a specific application. We propose a more principled approach, based on two observations: • XML is widely used to encode syntactic annotation. Syntactic annotation is not more complex that some other types of information that is routine</context>
</contexts>
<marker>Cui, Sun, Li, Kan, Chua, 2005</marker>
<rawString>Hang Cui, Renxu Sun, Keya Li, Min-Yen Kan, and Tat-Seng Chua. Question answering passage retrieval using dependency relations. In Proceedings of SIGIR 05, Salvador, Brazil, 2005.</rawString>
</citation>
<citation valid="true">
<authors>
<author>W Haesereyn</author>
<author>K Romijn</author>
<author>G Geerts</author>
<author>J De Rooy</author>
<author>M C Van den Toorn</author>
</authors>
<title>Algemene Nederlandse Spraakkunst. Martinus Nijhoff Uitgevers Groningen / Wolters Plantyn Deurne,</title>
<date>1997</date>
<marker>Haesereyn, Romijn, Geerts, De Rooy, Van den Toorn, 1997</marker>
<rawString>W. Haesereyn, K. Romijn, G. Geerts, J. De Rooy, and M.C. Van den Toorn. Algemene Nederlandse Spraakkunst. Martinus Nijhoff Uitgevers Groningen / Wolters Plantyn Deurne, 1997.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Boris Katz</author>
<author>Jimmy Lin</author>
</authors>
<title>Selectively using relations to improve precision in question answering.</title>
<date>2003</date>
<booktitle>In Proceedings of the workshop on Natural Language Processing for Question Answering (EACL</booktitle>
<pages>43--50</pages>
<publisher>EACL.</publisher>
<location>Budapest,</location>
<contexts>
<context position="1404" citStr="Katz and Lin, 2003" startWordPosition="213" endWordPosition="216">parsers are available for various languages, there is a growing interest in research that uses automatically annotated corpora. While such corpora are not errorfree, the fact that they can be constructed relatively easily, and the fact that they can be an order of magnitude larger than manually corrected treebanks, makes them attractive for several types of research. Syntactically annotated corpora have succesfully been used to acquire lexico-semantic information (Lin and Pantel, 2001; Snow et al., 2005), for relation extraction (Bunescu and Mooney, 2005), in IR (Cui et al., 2005), and in QA (Katz and Lin, 2003; Moll´a and Gardiner, 2005). What these tasks have in common is the fact that they all operate on large amounts of data extracted from syntactically annotated text. Tools to perform 17 this task are often developed with only a single application in mind (mostly corpus linguistics) or are developed in an ad-hoc fashion, as part of a specific application. We propose a more principled approach, based on two observations: • XML is widely used to encode syntactic annotation. Syntactic annotation is not more complex that some other types of information that is routinely stored in XML. This suggests</context>
</contexts>
<marker>Katz, Lin, 2003</marker>
<rawString>Boris Katz and Jimmy Lin. Selectively using relations to improve precision in question answering. In Proceedings of the workshop on Natural Language Processing for Question Answering (EACL 2003), pages 43–50, Budapest, 2003. EACL.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Michael Kay</author>
</authors>
<title>Comparing XSLT and XQuery.</title>
<date>2005</date>
<booktitle>In Proceedings of XTech 2005,</booktitle>
<location>Amsterdam,</location>
<note>URL www.idealliance.org/ proceedings/xtech05.</note>
<contexts>
<context position="12266" citStr="Kay (2005)" startWordPosition="1934" endWordPosition="1935"> experiment with XQuery as a language for data extraction from syntactically annotated corpora. Similar studies were carried out by Cassidy (2002) (for an early version of XQuery) and Mayo et al. (2006), who compare the NITE Query Language and XQuery. Below, we first illustrate a task that requires use of XPath only, and then move on to tasks that require the additional functionality of XQuery. 8www.ims.uni-stuttgart.de/projekte/ TIGER/ 9www.w3.org/TR/xslt20 10www.w3.org/TR/xquery 11www.w3.org/TR/xpath20 12e.g.exist.sourceforge.net,monetdb.cwi.nl, www.oracle.com/database/berkeley-db/xml 13See Kay (2005) for a thorough comparison. 4.1 Corpus exploration with XPath As argued in Bouma and Kloosterman (2002), XPath provides a powerful query language for formulating linguistically relevant queries, provided that the XML encoding of the treebank reflects the syntactic structure of the trees. Inherent reflexive verbs, for instance, are verbal heads with a rel=’se’ dependent. A verb with an inherently reflexive can therefore be found as follows (remember that in Alpino dependency trees, dependents are actually siblings of the head): //node[@pos=&amp;quot;verb&amp;quot; and @rel=&amp;quot;hd&amp;quot; and ../node[@rel=&amp;quot;se&amp;quot;] ] The doubl</context>
</contexts>
<marker>Kay, 2005</marker>
<rawString>Michael Kay. Comparing XSLT and XQuery. In Proceedings of XTech 2005, Amsterdam, 2005. URL www.idealliance.org/ proceedings/xtech05.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Dekan Lin</author>
<author>Patrick Pantel</author>
</authors>
<title>Discovery of inference rules for question answering.</title>
<date>2001</date>
<journal>Natural Language Engineering,</journal>
<volume>7</volume>
<contexts>
<context position="1275" citStr="Lin and Pantel, 2001" startWordPosition="189" endWordPosition="192">lly annotated treebanks have played an important role in the development of robust and accurate syntactic analysers. Now that such parsers are available for various languages, there is a growing interest in research that uses automatically annotated corpora. While such corpora are not errorfree, the fact that they can be constructed relatively easily, and the fact that they can be an order of magnitude larger than manually corrected treebanks, makes them attractive for several types of research. Syntactically annotated corpora have succesfully been used to acquire lexico-semantic information (Lin and Pantel, 2001; Snow et al., 2005), for relation extraction (Bunescu and Mooney, 2005), in IR (Cui et al., 2005), and in QA (Katz and Lin, 2003; Moll´a and Gardiner, 2005). What these tasks have in common is the fact that they all operate on large amounts of data extracted from syntactically annotated text. Tools to perform 17 this task are often developed with only a single application in mind (mostly corpus linguistics) or are developed in an ad-hoc fashion, as part of a specific application. We propose a more principled approach, based on two observations: • XML is widely used to encode syntactic annotat</context>
</contexts>
<marker>Lin, Pantel, 2001</marker>
<rawString>Dekan Lin and Patrick Pantel. Discovery of inference rules for question answering. Natural Language Engineering, 7:343–360, 2001.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Neil Mayo</author>
<author>Jonathan Kilgour</author>
<author>Jean Carletta</author>
</authors>
<title>Towards an alternative implementation of NXT query language via XQuery.</title>
<date>2006</date>
<booktitle>In Proceedings of the EACL Workshop on Multi-dimensional Markup in NLP,</booktitle>
<location>Trento,</location>
<contexts>
<context position="11858" citStr="Mayo et al. (2006)" startWordPosition="1889" endWordPosition="1892">d for extraction of information from XML databases. XQuery is in many respects similar to SQL and is rapidly becoming the standard for XML database systems.12 A distinctive difference between the XSLT and XQuery is the fact that XSLT documents are themselves XML documents, whereas this is not the case for XQuery. This typically makes XQuery more concise and easier to read than XSLT.13 These considerations made us experiment with XQuery as a language for data extraction from syntactically annotated corpora. Similar studies were carried out by Cassidy (2002) (for an early version of XQuery) and Mayo et al. (2006), who compare the NITE Query Language and XQuery. Below, we first illustrate a task that requires use of XPath only, and then move on to tasks that require the additional functionality of XQuery. 8www.ims.uni-stuttgart.de/projekte/ TIGER/ 9www.w3.org/TR/xslt20 10www.w3.org/TR/xquery 11www.w3.org/TR/xpath20 12e.g.exist.sourceforge.net,monetdb.cwi.nl, www.oracle.com/database/berkeley-db/xml 13See Kay (2005) for a thorough comparison. 4.1 Corpus exploration with XPath As argued in Bouma and Kloosterman (2002), XPath provides a powerful query language for formulating linguistically relevant querie</context>
</contexts>
<marker>Mayo, Kilgour, Carletta, 2006</marker>
<rawString>Neil Mayo, Jonathan Kilgour, and Jean Carletta. Towards an alternative implementation of NXT query language via XQuery. In Proceedings of the EACL Workshop on Multi-dimensional Markup in NLP, Trento, 2006.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D Moll´a</author>
<author>M Gardiner</author>
</authors>
<title>Answerfinder - question answering by combining lexical, syntactic and semantic information.</title>
<date>2005</date>
<booktitle>In Australasian Language Technology Workshop (ALTW) 2004,</booktitle>
<location>Sydney,</location>
<marker>Moll´a, Gardiner, 2005</marker>
<rawString>D. Moll´a and M. Gardiner. Answerfinder - question answering by combining lexical, syntactic and semantic information. In Australasian Language Technology Workshop (ALTW) 2004, Sydney, 2005.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Nelleke Oostdijk</author>
</authors>
<title>The Spoken Dutch Corpus: Overview and first evaluation.</title>
<date>2000</date>
<booktitle>In Proceedings of LREC</booktitle>
<pages>887--894</pages>
<contexts>
<context position="3580" citStr="Oostdijk, 2000" startWordPosition="565" endWordPosition="566">l Proceedings of the Linguistic Annotation Workshop, pages 17–24, Prague, June 2007. c�2007 Association for Computational Linguistics that requires XQuery. We demonstrate that much of the complexity of advanced tasks can be avoided by providing users with a corpus specific module, that makes available common concepts and functions. 2 The Alpino Treebank format As part of the development of the Alpino parser (Bouma et al., 2001), a number of manually annotated dependency treebanks have been created (van der Beek et al., 2002). Annotation guidelines were adopted from the Corpus of Spoken Dutch (Oostdijk, 2000), a large corpus annotation project for Dutch. In addition, large corpora (e.g. the 80M word Dutch CLEF2 corpus, the 500M word Twente News corpus3, and Dutch Wikipedia4) have been annotated automatically. Both types of treebanks have been used for corpus linguistics (van der Beek, 2005; Villada Moir´on, 2005; Bouma et al., 2007). The automatically annoted treebanks have been used for lexical acquisition (van der Plas and Bouma, 2005), and form the core of a Dutch QA system (Bouma et al., 2005). The format of Alpino dependency trees is illustrated in figure 1. The (somewhat simplified) XML for </context>
</contexts>
<marker>Oostdijk, 2000</marker>
<rawString>Nelleke Oostdijk. The Spoken Dutch Corpus: Overview and first evaluation. In Proceedings of LREC 2000, pages 887–894, 2000.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Rion Snow</author>
<author>Daniel Jurafsky</author>
<author>Andrew Y Ng</author>
</authors>
<title>Learning syntactic patterns for automatic hypernym discovery. In</title>
<date>2005</date>
<booktitle>Advances in Neural Information Processing Systems 17,</booktitle>
<pages>1297--1304</pages>
<editor>Lawrence K. Saul, Yair Weiss, and Lon Bottou, editors,</editor>
<publisher>MIT Press,</publisher>
<location>Cambridge, MA,</location>
<contexts>
<context position="1295" citStr="Snow et al., 2005" startWordPosition="193" endWordPosition="196">s have played an important role in the development of robust and accurate syntactic analysers. Now that such parsers are available for various languages, there is a growing interest in research that uses automatically annotated corpora. While such corpora are not errorfree, the fact that they can be constructed relatively easily, and the fact that they can be an order of magnitude larger than manually corrected treebanks, makes them attractive for several types of research. Syntactically annotated corpora have succesfully been used to acquire lexico-semantic information (Lin and Pantel, 2001; Snow et al., 2005), for relation extraction (Bunescu and Mooney, 2005), in IR (Cui et al., 2005), and in QA (Katz and Lin, 2003; Moll´a and Gardiner, 2005). What these tasks have in common is the fact that they all operate on large amounts of data extracted from syntactically annotated text. Tools to perform 17 this task are often developed with only a single application in mind (mostly corpus linguistics) or are developed in an ad-hoc fashion, as part of a specific application. We propose a more principled approach, based on two observations: • XML is widely used to encode syntactic annotation. Syntactic annot</context>
</contexts>
<marker>Snow, Jurafsky, Ng, 2005</marker>
<rawString>Rion Snow, Daniel Jurafsky, and Andrew Y. Ng. Learning syntactic patterns for automatic hypernym discovery. In Lawrence K. Saul, Yair Weiss, and Lon Bottou, editors, Advances in Neural Information Processing Systems 17, pages 1297– 1304. MIT Press, Cambridge, MA, 2005.</rawString>
</citation>
<citation valid="true">
<authors>
<author>L van der Beek</author>
<author>G Bouma</author>
<author>R Malouf</author>
<author>G van Noord</author>
</authors>
<title>The Alpino dependency treebank.</title>
<date>2001</date>
<booktitle>In Computational Linguistics in the Netherlands (CLIN)</booktitle>
<institution>Twente University,</institution>
<marker>van der Beek, Bouma, Malouf, van Noord, 2001</marker>
<rawString>L. van der Beek, G. Bouma, R. Malouf, and G. van Noord. The Alpino dependency treebank. In Computational Linguistics in the Netherlands (CLIN) 2001, Twente University, 2002.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Leonoor van der Beek</author>
</authors>
<title>Topics in Corpus Based Dutch Syntax.</title>
<date>2005</date>
<tech>PhD thesis,</tech>
<institution>University of Groningen,</institution>
<location>Groningen,</location>
<marker>van der Beek, 2005</marker>
<rawString>Leonoor van der Beek. Topics in Corpus Based Dutch Syntax. PhD thesis, University of Groningen, Groningen, 2005.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Lonneke van der Plas</author>
<author>Gosse Bouma</author>
</authors>
<title>Automatic acquisition of lexico-semantic knowledge for question answering.</title>
<date>2005</date>
<booktitle>In Proceedings of Ontolex 2005 – Ontologies and Lexical Resources,</booktitle>
<location>Jeju Island, South</location>
<marker>van der Plas, Bouma, 2005</marker>
<rawString>Lonneke van der Plas and Gosse Bouma. Automatic acquisition of lexico-semantic knowledge for question answering. In Proceedings of Ontolex 2005 – Ontologies and Lexical Resources, Jeju Island, South Korea, 2005.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Bego˜na Villada Moir´on</author>
</authors>
<title>Linguistically enriched corpora for establishing variation in support verb constructions.</title>
<date>2005</date>
<booktitle>In Proceedings of the 6th International Workshop on Linguistically Interpreted Corpora (LINC-2005), Jeju Island,</booktitle>
<location>Republic of</location>
<marker>Moir´on, 2005</marker>
<rawString>Bego˜na Villada Moir´on. Linguistically enriched corpora for establishing variation in support verb constructions. In Proceedings of the 6th International Workshop on Linguistically Interpreted Corpora (LINC-2005), Jeju Island, Republic of Korea, 2005.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>