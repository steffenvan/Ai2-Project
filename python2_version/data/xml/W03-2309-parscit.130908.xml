<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000057">
<title confidence="0.978052">
A Phrasal Generator for Describing Relational Database Queries
</title>
<note confidence="0.84882125">
Michael J. Minock
mjm @cs. umu.se
The University of Umed
Umed, Sweden
</note>
<sectionHeader confidence="0.987234" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999986642857143">
This paper proposes a technique to gener-
ate single sentence natural language descrip-
tions for a wide class of relational database
queries. Such a capability meets an impor-
tant need in the area of cooperative informa-
tion systems.
The approach to describing queries is phrasal
and is restricted to tuple relational queries us-
ing positive or negatively signed sequences
of existential quantifiers over conjunctions of
conditions. Query containment and equiv-
alence are decidable for this class and this
property is exploited in the maintenance and
use of the phrasal lexicon.
</bodyText>
<sectionHeader confidence="0.999393" genericHeader="keywords">
1 Introduction
</sectionHeader>
<bodyText confidence="0.999977645833334">
Often relational database schemas are delivered as col-
lections of oddly named tables and attributes. Users
and administrators are expected to query, integrate and
otherwise maintain such systems. Natural language
generation has been seen as an important part of im-
proving the understandability of relational database
schemas(McKeown, 1985).
The focus here, however, is not to explain or describe
database schemas, but rather to describe database
queries. While at first this may seem to be of limited
value, we shall see that many techniques in cooperative
information systems(Gaasterland et al., 1992) require
&apos;query&apos; descriptions as an integral part of their commu-
nication process. The &apos;query&apos; being described is not
usually the user&apos;s own query, but rather some derived
expression that may be written in the form of a query.
A set of cooperative techniques that require such de-
scription services shall be reviewed in this paper. We
view the cooperative information system that bundles
these techniques, as essentially providing the services
of a strategic text planner. The cooperative informa-
tion system decides communication content with com-
munication acts consisting of template sentences with
embedded requests for &apos;query&apos; descriptions.
Given that we seek to describe queries, we must con-
tend with the fact that there are infinitely many syntac-
tically correct queries over a given schema. It is critical
that the generation system provide adequate coverage
over some well defined portion of this space. In this
paper the space of coverage mirrors a recently defined
class of schema tuple queries(Minock, 2002). Because
of the natural closure properties of this language, and
its decidability for equivalence and containment, it is
reasonable to assume that many cooperative techniques
may generate output &apos;queries&apos; within this form.
The author of the query description system is as-
sumed to be a database administrator. Thus we must
adopt a generation technique that does not require a
deep understanding of linguistics. Moreover the ad-
ministrator must be given a structured method of au-
thoring so that they may declare a schema covered.
That is the system should faithfully, if not always el-
egantly, describe all queries of the form that are posed
over the database schema. Given these requirements
we adopt a phrasal approach that couples parameter-
ized queries with patterns. The parameterized queries
are within the class of the identified form and the pat-
terns are simply modifier, head, complement triples.
</bodyText>
<subsectionHeader confidence="0.999548">
1.1 Organization of this Paper
</subsectionHeader>
<bodyText confidence="0.99995525">
Section 2 shall review cooperative information sys-
tems and shall illustrate how such systems play the
role of strategic natural language generators. Section 3
shall give a brief introduction to the language in which
queries must be expressed. Section 4 describes the
phrasal lexicon and section 5 describes the generation
process. Section 6 discusses this work in the context of
prior work and gives future directions.
</bodyText>
<sectionHeader confidence="0.997174" genericHeader="introduction">
2 Cooperative Information Systems
</sectionHeader>
<bodyText confidence="0.999871166666667">
Cooperative information systems(Gaasterland et al.,
1992) seek to extend conventional database query-
answer dialogues with the principles of cooperative
conversation(Grice, 1975). Thus the response to the
user&apos;s query is richer than simply presenting the an-
swers that meet the conditions of their query. Often
</bodyText>
<page confidence="0.998933">
63
</page>
<bodyText confidence="0.99980325">
such responses are conceptual and may in fact be spec-
ified with derived &apos;query&apos; expressions. We now cover
specific cooperative techniques that have such &apos;concep-
tual&apos; outputs.
</bodyText>
<subsectionHeader confidence="0.963882">
2.1 Cooperative Techniques
</subsectionHeader>
<bodyText confidence="0.999935573770492">
A user may have a query misconceptions, meaning that
the user is unaware that their query presupposes an il-
legal state of the database. For example assume that
a state law in Ohio is that all mayors must be over 25
years old. If a user is unaware of this restriction and
issues a request &amp;quot;list all female mayors in Ohio that are
younger than 23&amp;quot;, they should be informed that &amp;quot;it is
impossible for people under 25 to be mayors of cities
in Ohio.&amp;quot; Such a conceptual response is in the form
of a &apos;query&apos;. Gal (Gal and Minker, 1988) uses integrity
constraints to explain query misconceptions back to the
user.
Related to query misconceptions, a user should be
made aware of a false presupposition they have about
the database state. A false presupposition is an assump-
tion that is implicit in a user&apos;s query, though false. The
system CO-OP(Kaplan, 1982) used a limited theory of
cooperation to correct false presuppositions. For ex-
ample assume that a user requests: &amp;quot;Give the cities
with population over 2 million in the state of Alaska
or North Dakota that have a female mayor&amp;quot; A tradi-
tional system would say, &amp;quot;none.&amp;quot; A system that could
detect false presuppositions would respond, &amp;quot;there are
no cities in Alaska or North Dakota with a popula-
tion over 2 million.&amp;quot; This is a description of the mini-
mal failing sub-query of the users original query. Ef-
ficient algorithms exist to find minimal failing sub-
queries (MFS) as well maximal succeeding sub-queries
(MSS)(Godfrey, 1994).
Query relaxation is useful when a query has no
matching tuples. During query relaxation conditions
may be loosened or alternate entity types may be
queried. For example when asking for flights from
Dulles airport to La Guardia with a Sunday morning
departure at 10 am, a relaxed query might return a 9:32
am flight from Dulles arriving at JFK. An entity type
relaxation might offer a train or a bus trip rather than
airplane flight. It is important to describe the relaxed
query to the user before flooding them with extensional
answers.
Intensional query answering (Imielinski, 1988)
(Shum and Muntz, 1987) provides a summary answer
rather than the entire tuple extension satisfying the
query. If you are asking for all employees who make
over 100,000$, instead of listing every single manager
and Joe Star engineer, it is better to report &amp;quot;all the man-
agers and the engineer named &apos;Joe Star&apos;.&amp;quot; This inten-
sional response is more informative in the case that the
user does not interpret an enumeration of all the man-
agers names to mean &apos;all managers&apos;. Once again the
ability to describe queries is important.
The CARMIN system (Godfrey et al., 1994) in-
cludes an integrated explanation and answer presen-
tation system. System explanations are based on the
proof path used by a PROLOG meta-interpreter. As-
pects of what to include and how to coordinate these
explanations are also addressed(Gaasterland and Min-
kler, 1991). Natural language descriptions of the
user query and relaxation process are generated for
the cooperative information system CoBase(Chu et al.,
1996),(Minock and Chu, 1996).
</bodyText>
<subsectionHeader confidence="0.994134">
2.2 Cooperative Information Systems Serving as
&apos;Strategic&apos; Planners
</subsectionHeader>
<bodyText confidence="0.999984631578947">
We propose a modular approach in which the cooper-
ative information system decides &apos;what&apos; to say and a
query description sub-system decides &apos;how&apos; to say it.
Figure 1 shows an architecture for this approach.
The cooperative information system consists of sub-
systems that perform misconception detection, false
presupposition detection, query relaxation and inten-
sional answer generation. The user interface consists
of sub-systems that perform query formulation, query
description and answer presentation. Both the interface
and the cooperative information system have access to
the domain database.
A user is assumed to compose their query through
some type of query formulator. This may be as primi-
tive as a text box in which to type a logical query ex-
pression, to as advanced as a full natural language un-
derstanding system. Whatever the formulator type, it
may be helpful to provide the user a natural language
description of the query, q, that they have formulated.
After the user has verified their query, it is passed
from the user interface to the misconception detection
sub-system. If the query contains a misconception,
then the offending portion of the query that caused the
misconception, m, is reported as being &apos;impossible&apos; and
execution terminates. If the query contains no mis-
conception, then subsequent flow depends on whether
the user&apos;s query returns answers. If it does not re-
turn answers, the query is passed to the false presup-
position detection sub-system. This sub-system iden-
tifies a minimal failing sub-query of the query. This
minimal failing sub-query, s, is described to the user
as not returning answers in the current database state.
The minimal failing sub-query is then generalized to
an answer returning query by the query relaxation sub-
system. The fact that this relaxed query, a, generates
answers is communicated to the user. Now that either
the original query, or the derived relaxed query is an-
swer generating, we then check whether a suitable in-
</bodyText>
<page confidence="0.997317">
64
</page>
<figure confidence="0.489682">
RELATIONAL DATABASE
</figure>
<figureCaption confidence="0.99883">
Figure 1: A cooperative information system as a strategic planner.
</figureCaption>
<figure confidence="0.999188838709677">
a
COOPERATIVE
INFORMATION
SYSTEM
Misconception
Detection
Intensional
Answer
Generation
Floss at con 001
Message
+ &apos;Jamb.° access
• • • • Uses
USER INTERFACE
&amp;quot;You seek DESCRIBE(q).&amp;quot;
..........................
4 &amp;quot;DESCRIBE(m) are impossible.&amp;quot; ............
A &amp;quot;There are no DESCRIBE(n).&amp;quot;
A &amp;quot;There are DESCRIBE(a).&amp;quot;
-They are the DESCRIBE(s).&amp;quot;
Query
Description
Query
Formulation
Answer
Presentation
False
Presupposition
Detection
Query
Relaxatioi
</figure>
<bodyText confidence="0.9998972">
tensional summary may be returned as a substitute for
fetching all the extensional answers to the query. The
intensional answer generator either decides that no suit-
able summary exists, or it terminates the with a descrip-
tion of the summary &apos;query&apos; s. If no suitable summary
exists, then the extensional answers are retrieved from
the database and are passed to the answer presentation
sub-system.
Of course the proposed architecture leaves many is-
sues unspecified. For example how does one pick a sin-
gle minimal failing sub-query? How does one decide to
relax the user&apos;s query? When is a summary appropriate
in place of a full extensional answer. Still the impor-
tant point to note here is that the cooperative informa-
tion system makes such decisions based on semantic
and pragmatic issues. These considerations determine
the quantity,quality and relation of the content to be ex-
pressed. The tactical decision of the manner in which
to express such content is left up to the sub-system that
describes &apos;queries &apos; .
</bodyText>
<sectionHeader confidence="0.977378" genericHeader="method">
3 A Class of Describable Queries
</sectionHeader>
<bodyText confidence="0.986357357142857">
This paper now turns to the relatively pure problem
of generating natural language descriptions for a broad
class of relational database queries. Let us start by con-
sidering the following relational schema:
Person(name, gender, age, city)
City(cityName, population, mayor, state, country)
Knows(knower, known, opinion)
The semantics here are those of standard relational
databases. The underlined attributes are the primary
keys of the relations and the italicized attributes are
foreign keysl . A wide variety of queries from sim-
ple to somewhat complex may be expressed over this
schema. The goal here will be to describe such queries.
The following queries are of interest:
</bodyText>
<listItem confidence="0.99938">
1.) &amp;quot;Men living in &apos;Paris&apos; or &apos;Nice&apos;.&amp;quot;
2.) &amp;quot;People living in cities with populations of over
100,000 people.&amp;quot;
3.) &amp;quot;People not living in cities with populations of
over 100,000 people.&amp;quot;
4.) &amp;quot;People who know people living in &apos;Nice&apos;
5.) &amp;quot;People who do not know people living in &apos;Nice&apos;
6.) &amp;quot;People who know and like themselves&amp;quot;
7.) &amp;quot;People who know all people living in &apos;Nice&apos;
</listItem>
<bodyText confidence="0.9986226">
The first five queries above may be described using
our current approach. Query six has a reflexive ref-
erence that we are not yet able to handle. Query seven
may not be expressed within the language we limit our-
selves to - the language L.
</bodyText>
<equation confidence="0.727781666666667">
Definition 1 (The language L)
E L if t is in the form:
R(x) k-1 Si. (3)11
</equation>
<bodyText confidence="0.999561375">
where x is the only free variable of f, R(x) is the
range condition for x, si is a positive or negative (—,)
sign, A is a finite sequence of existentially quantified
variables and is a conjunction of range conditions,
simple conditions, set conditions and join conditions.
Those who are familiar with databases will note that this
schema makes the rather simplistic assumption that all city
names in the world are unique.
</bodyText>
<page confidence="0.997891">
65
</page>
<bodyText confidence="0.999484">
The example queries from above are shown here.
See (Minock, 2002) for a more complete discussion of
L. Each query {x1t} returns a set of tuples. For the first
six queries, t E L.
</bodyText>
<equation confidence="0.999280041666666">
1.){x1Person(x) A x.gender = &apos;male&apos; A x.age &gt; 18A
x.city E { Taris&apos;,`Nice&apos;}l
2.){x1Person(x) A (y)
(City(y) A y.population&gt; 100000A
y.cityName = x.city)}
3.){x1Person(x) A —,(]y)
(City(y) A y.population &gt; 100000A
y.cityName = x.city)}
4.){xlPerson(x) A (y)(±)(
(Know(y) A Person(z)A
z.city = &apos;Nice&apos; A
x.name = y.knower A y.known = z.name)}
5.){x1Person(x) A —,(]y)(]z)(
(Know(y) A Person(z)A
z.city = &apos;Nice&apos; A
x.name = y.knower A y.known = z.name)}
6.){x1Person(x) A (y)
(Know(y) A y.opinion = &apos;like&apos;
x.name = y.knower A y.known = x.name)}
Query seven may not be expressed using L
7 .){xlPerson(x) A (Vz) (3y)
(Person(z) A z.city = &apos;Nice&apos;
Know(y) A x.name = y.knowerA
y.known = z.name)}
</equation>
<construct confidence="0.893108166666667">
Naturally all of these queries may be expressed using
standard SQL.
Theorem 1 (L is decidable for C, = and disjointness)
if qi E L and q2 E L then there exists a sound and com-
plete inference mechanisms to decide if the three pred-
icates:
</construct>
<equation confidence="0.458217333333333">
I.) g {x21q2}
2.) {xilqi} = {x2{q2}
3.) {xi n {x21.72} = O.
</equation>
<bodyText confidence="0.9355396">
are necessarily true over the set of all database in-
stances.
See (Minock, 2002) for the proof of this theorem.
These properties will be used to maintain and select
entries from the phrasal lexicon.
</bodyText>
<sectionHeader confidence="0.994799" genericHeader="method">
4 The Phrasal Lexicon
</sectionHeader>
<bodyText confidence="0.99984103030303">
The approach here generates a single highly aggregated
sentence of natural language that describes a query
built over a formula in L. The knowledge used to
achieve this is a phrasal lexicon. The phrasal lexicon,
denoted PL, consists of a set of n entries where each
entry is a parameterized query/pattern pair. The i-th
entry is ({xlti} : pi) where {xltil is a parameterized
query and pi is a single pattern.
A parameterized query is simply a query defined us-
ing a formula in L in which constants may be parame-
ters. Thus the query {xl Person(x) A x.gender = ci} is
a parameterized query where the constant ci could be
&apos;male&apos; or &apos;female&apos;. The constant ci is said to be a pa-
rameter. We may also have set valued parameters as in:
{x1Person(x) A x.city E Ci }.
A pattern is simply the three phrases: &amp;quot;[modifier]
head [complement]&amp;quot;. Phrases consist of plain text, pos-
sibly including parameters2. The modifier, head and
complement distinction is best illustrated with exam-
ple. The simple description,&amp;quot;Young people living in
London&amp;quot; has &amp;quot;young&amp;quot; as a modifier, &amp;quot;people&amp;quot; as the
head, and &amp;quot;living in London&amp;quot; as the complement. Thus
it would be represented: &amp;quot;[Young] people [living in
London]&amp;quot;. The [phrase] syntax within a pattern sig-
nifies that groups of phrases may collect in such posi-
tions during aggregation. By contrast there can only be
one head. Thus we may generate the aggregated pat-
tern &amp;quot;[Young, employed] people [of the female gender,
living in &apos;London&apos;]&amp;quot;.
We now shall now cover the different types of en-
tries within the phrasal lexicon. Special attention will
be paid to insure that the entries completely cover the
database schema over which queries may be posed.
</bodyText>
<subsectionHeader confidence="0.998097">
4.1 Simple Entries
</subsectionHeader>
<bodyText confidence="0.999150666666667">
Let us start with the simplest type of entry. Here we
specify the pattern associated with the condition free
database relation Person:
</bodyText>
<equation confidence="0.4738605">
({x1Person(x)} :
&amp;quot;[] people [ ]&amp;quot;)
</equation>
<bodyText confidence="0.9244825">
Now we see the entry for the relation Person, the
attribute gender, and the operator =.
</bodyText>
<listItem confidence="0.8573115">
({xl Person(x) A x.gender = ci} :
&amp;quot;[] people [of the ci gender]&amp;quot;)
</listItem>
<bodyText confidence="0.995797">
The &amp;quot;[ ]&amp;quot; specifies that there is an an empty modi-
fier for this pattern. The head is &amp;quot;people&amp;quot;. Finally the
complement phrase &amp;quot;[of ci gender]&amp;quot; has the parameter
There may be more than one entry with equivalent
parameterized queries. For example:
</bodyText>
<listItem confidence="0.743320833333333">
({x1Person(x) A x.gender = ci}
&amp;quot;[ci] people [ ]&amp;quot;)
Naturally We may also have constants specified in
the queries as well.
({xl Person(x) A x.gender =&apos; male&apos;} :
&amp;quot;[] males [ ]&amp;quot;)
</listItem>
<footnote confidence="0.8204905">
2As we shall see later, the complement phrase may also
contain a recursive call to describe a sub-query.
</footnote>
<page confidence="0.991467">
66
</page>
<bodyText confidence="0.999986888888889">
In this final case we see that the head itself has been
changed from the default for the relation. This may
only occur once during a generation. The head is said
to be open if it contains the same value as the head for
the condition free entry over the relation. Otherwise it
is said to be frozen and may not be combined with other
patterns that alter the head.
Given the above entries we may generate the descrip-
tion of the query:
</bodyText>
<equation confidence="0.84993">
{x1Person(x) A x.gender = &apos;male&apos;}
</equation>
<bodyText confidence="0.99997775">
As &amp;quot;people of the male gender&amp;quot;, &amp;quot;male people&amp;quot;, or
&amp;quot;males&amp;quot;. The simple heuristics we employ prefer the
last form over the first two.
We must fully populate the lexicon to cover all of
the attribute/basic operator combinations for each re-
lation in the schema. If there are 6 basic operators
(&gt;, &gt;, =, ,&lt;,&lt;) and two set operators (E, (X), and
each attribute/operator combination makes sense, then
the minimal number of simple entries required by the
schema in section 3 is: (8 x 4 + 1) + (8 x 5 + 1) + (8 x
3 + 1). The `+1&apos; terms signify the entry for the case
where no conditions are applied.
</bodyText>
<subsectionHeader confidence="0.977689">
4.1.1 Aggregating Simple Entries
</subsectionHeader>
<bodyText confidence="0.999711">
Now we show how simple entries combine to de-
scribe queries with more than one condition. In ad-
dition to the previous entries, assume that we also have
the following entry:
</bodyText>
<listItem confidence="0.926926">
({xl Person(x) A x.city E CI } :
] people [living in Ci]&amp;quot;)
</listItem>
<bodyText confidence="0.9702905">
Now suppose that the query for the &amp;quot;males living in
Paris or Nice&amp;quot; needs to be described. The query is:
</bodyText>
<equation confidence="0.637452166666667">
{x1Person(x) A x.gender = &apos;male&apos; A
x.city e {Paris&apos;, &apos;Nice&apos;}}
This may be rewritten as a combination of filled in
parameterized queries from the phrasal lexicon.
{x1Person(x) A x.gender = &apos;male&apos;} fl
{x1Person(x) A x.city E {Paris&apos;, &apos;Nice&apos;}}
</equation>
<bodyText confidence="0.8569135">
Excluding the permutations of the &apos;Paris&apos; and &apos;Nice&apos;,
the possible ways to combine the 3 patterns that match
the first query and the 1 pattern that matches the second
are:
</bodyText>
<listItem confidence="0.997847166666667">
1.) [ ] males [living in &apos;Paris&apos; or `Nice&apos;]
2.) [male] people [living in &apos;Paris&apos; or &apos;Nice]
3.) [ ] people [of the male gender, living in &apos;Paris&apos; or
&apos;Nice&apos;]
4.) [ ] people [living in &apos;Paris&apos; or &apos;Nice&apos;, of the male
gender]
</listItem>
<bodyText confidence="0.9994964">
Using a simple heuristic of minimizing sentence
length, the first choice is preferred. Extending the
heuristic to communicate the maximum amount of in-
formation in k symbols, we induce the ordering pre-
sented here.
</bodyText>
<subsectionHeader confidence="0.995665">
4.2 Join Entries
</subsectionHeader>
<bodyText confidence="0.999933">
Now we face the issue of representing the patterns as-
sociated with join conditions within queries. First we
shall consider the simple case of joining over foreign
keys. This accounts for the bulk of meaningful many-
to-one and one-to-many relationships. Then we shall
consider the more complicated case involving many-
to-many relationships3.
</bodyText>
<sectionHeader confidence="0.564232" genericHeader="method">
4.2.1 One-to-many and many-to-one
Relationships
</sectionHeader>
<bodyText confidence="0.999356846153846">
Each attribute that can be meaningfully joined with
another must be considered. For the example of section
3 this would amount to a total of 6 attribute matches.
Assuming that we are only interested in equality joins,
then we must account for 2 x 2 x 6 entries to cover this
space. The reason for the first doubling is that one
must take into account direction when one describes
joins. The second doubling occurs because one must
also consider the negative case in which the query spec-
ifies that answers do not participate in such relation-
ships.
For the join involving person : city —&gt;+ city :
cityName we have the entry:
</bodyText>
<equation confidence="0.707309555555556">
({x1Person(x) A (3y)(City(y)A
x.city = y.cityName A c1}:
&amp;quot;[ ] people [that live in GEN ({y1City(y) A cI3})&amp;quot;])
The negative case is almost identical. The entry for
person: city city : cit yName is:
({xl Person(x) A –,(3y)(City(y)A
x.city = y.cityName A t}:
&amp;quot;[ ] people [that don&apos;t live in
GEN ({y1City(y) A (1)})&amp;quot;]&gt;
</equation>
<bodyText confidence="0.965075928571428">
The key issue to note here is that the complement
phrase has a recursive call. This will cause a com-
pletely new generation problem to be instantiated.
Assuming that we have simple entries covering city,
we may now generate descriptions such as &amp;quot;[adult]
[males] [that live in ([ ] cities [with populations over
100,000 people])&amp;quot;. The material enclosed within
3For those familiar with Entity-Relationship modeling,
the goal is to generate descriptions of an entity&apos;s participation
in one-to-many and many-to-many relationships. We skip
one-to-one relationships because of their simplicity. Note that
we do not yet handle either reflexive (self-joining) relation-
ships or general n-ary relationships, even though L admits
such queries
</bodyText>
<page confidence="0.998811">
67
</page>
<bodyText confidence="0.9871685">
parenthesis shows the solution to the recursive descrip-
tion problem.
</bodyText>
<subsubsectionHeader confidence="0.871961">
4.2.2 Many-to-many relationships through joins
</subsubsectionHeader>
<bodyText confidence="0.859699111111111">
We now consider a case of many-to-many type re-
lationships. These present a special, though not in-
surmountable difficulty. There is only one possible
many-to-many relationship in the example of section
3. This is the relationship that many people may know
many other people. Especially vexing is the fact that at-
tributes may also be involved within the many-to-many
relationship. For example the opinion one has about
who one knows. Consider the following entry:
</bodyText>
<equation confidence="0.989972833333333">
({x1Person(x)A
(3y)(3z)(Knows(y) A Person(z)A
opinion = el A x.personId = y.knowerA
y.known = z.personld A :
&amp;quot;[ ] people [who know and el some
GEN({z1Person(Z) A O})]&amp;quot;)
</equation>
<bodyText confidence="0.999807285714286">
The only way to precisely control this is to make
multiple join entries for each combination of given at-
tributes in the joining relation. Thankfully relations
that bridge many-to-many relations are often of fewer
attributes. In the case of the example in this paper the
many-to-many relationship is taken care of with 4 en-
tries.
</bodyText>
<subsectionHeader confidence="0.991412">
4.3 Coverage and extension of the phrasal lexicon
</subsectionHeader>
<bodyText confidence="0.998907888888889">
if we may guarantee that there are a sufficient set
of entries to fully cover the schema, we may declare
the phrasal lexicon to be covered with respect to the
schema. Thus based on the approach above, it takes
123 entries to cover the schema in section 3.
Naturally we may improve the phrasal lexicon by
extending it to cover more specific entries. For exam-
ple, the following entry will simplify some descriptions
considerably:
</bodyText>
<equation confidence="0.754498">
({x1Person(x) A x.gender = &apos;male&apos; A x.age &gt; 18}:
&amp;quot;[ ] men [ ]&amp;quot;)
</equation>
<sectionHeader confidence="0.905767" genericHeader="method">
5 The Generation Process
</sectionHeader>
<bodyText confidence="0.998535">
Beyond simple aggregation, we have not yet described
how the entries within the phrasal lexicon are used to
obtain natural language descriptions of a query. We
begin with a definition of what constitutes a description
and then we show a relatively efficient mechanism to
actually obtain such descriptions. Finally we say a little
about how specific descriptions are selected.
</bodyText>
<subsectionHeader confidence="0.995113">
5.1 Descriptions Defined
</subsectionHeader>
<bodyText confidence="0.999955518518519">
A description of a query is the aggregate pattern gener-
ated through applying a covering, non-redundant sub-
set of the phrasal lexicon over the query.
Before we define what a covering, non-redundant
subset of the the phrasal lexicon is, we must resolve
formal difficulties associated with parameters in the
phrasal lexicon. Because there are a finite number of
constants in the formula specifying the query (f) and
a finite number of parameters within the entries of the
phrasal lexicon (PL), we may consider the expansion of
the phrasal lexicon to be all combinations of constants
from within substituted in place of parameters within
the entries of PL. This generates the finite expanded
lexicon PLe where all parameters are bound.
We now define the subsets of the expanded lexicon
that cover the query without redundancy. A set of lex-
ical entries s E 2PLF are said to subsume {4e} iff the
set intersection of all the queries within the entries of s
necessarily contain {x1t} where T is substituted for C13
in every (parameterized) query. Another, more concise
way of saying this, is that the extension of the entries
s contains {4/}. A set of lexical entries s e 2PLf is
said to cover {x1E} iff there is no other s&apos; where s&apos; D s
where s&apos; subsumes {x1I}, and the extension of s&apos; are
properly contained within the extension of s. Finally a
set s e 2Pe is redundant iff some s&apos; C s has the same
extension as s.
</bodyText>
<subsectionHeader confidence="0.9994">
5.2 Obtaining Descriptions
</subsectionHeader>
<bodyText confidence="0.973553928571429">
To quickly identify subsets of the phrasal lexicon that
cover the user query without redundancy, we orga-
nize the phrasal lexicon into a subsumption hierarchy4.
The phrasal lexicon is compiled into a subsumption
hierarchy by sorting entries down into the hierarchy.
Nodes correspond to parameterized queries, though
entries with equivalent parameterized queries are col-
lapsed into a single node with multiple attached pat-
terns. When we sort the query into the subsumption
hierarchy, the set of immediate parents identify the set
of entries that cover the user query without redundancy.
Figure 2 illustrates the subsumption hierarchy for the
entries we have considered thus far. The upper portion
of the hierarchy consists of the nodes that correspond
to the 123 entries we must provide if we wish to cover
the given database schema. The lower portion of the
hierarchy consists of nodes representing entries that are
meant to make generation more precise. Figure 2 also
shows two queries sorted into the hierarchy.
The only complication in the sort procedure is han-
dling parameters and open formula of the lexical en-
tries. The way to handle parameters, is to allow them
to range over any domain value except a distinguished
4The notion of subsumption hierarchy here corresponds
with that used in description logics. However it should
be noted that the logic here differs considerably from the
unary and binary predicates of typical description logics. See
(Minock, 2002) for a full discussion of this.
</bodyText>
<page confidence="0.998438">
68
</page>
<figureCaption confidence="0.999216">
Figure 2: The phrasal lexicon organized as a subsumption hierarchy.
</figureCaption>
<figure confidence="0.963708692307692">
&amp;quot;inn/er living
in Paris or Nice&amp;quot;
&apos;people living in cities
with populations of
over 100,000 people&amp;quot;
• Lexically covered node
O Non—covered node
• Covered query
E Non—covered query
Subsumes
[] people [that live in GEN(W1)]
[] people [that don&apos;t live in GEN(W2)]
11 people [who know and c3 some GEN(W3)
</figure>
<bodyText confidence="0.998356181818182">
symbol unkown. This is recored by inserting the simple
condition that the parameter does not equal unknown.
Open formula c13 are simply assumed to be true and are
replaced with the symbol T.
Given that the parameterized queries and queries re-
quiring description tend to be of limited size, we as-
sume that deciding subsumption between two param-
eterized queries takes constant time. If the number of
entries in the phrasal lexicon is n, then 0(n) nodes are
in the subsumption hierarchy. It thus costs 0(n) sub-
sumption operations to sort a query into the hierarchy.
</bodyText>
<subsectionHeader confidence="0.997318">
5.3 Selecting Descriptions
</subsectionHeader>
<bodyText confidence="0.999950533333333">
Given a set of nodes that cover a query without re-
dundancy, we may select combinations of associated
patterns from this set of nodes to generate an actual
description. The conditions guiding this process are
that only one pattern is selected from each node and
at most one pattern of the combination may over-ride
the default head. A heuristic that we adopt is to prefer
the shortest sentence. It is likely that a greedy tech-
nique is sufficient to enable the identification of such
a minimal combination. Occasionally the whole gen-
eration process recurs when there is a (1) term within a
complement. Once all the textual material is obtained
from the recursive calls, a final process reorders the
constituents so that the shorter phrases appear before
longer phrases.
</bodyText>
<sectionHeader confidence="0.999792" genericHeader="evaluation">
6 Discussion
</sectionHeader>
<bodyText confidence="0.999994634146341">
It has been observed that fielded NLG systems tend
to have pipelined architectures with the vast major-
ity using some type of semantic network based rep-
resentations as the common knowledge representa-
tion language(Reiter, 1994). Surface realization tends
to be carried out using unification grammars(Kay,
1979)(Penman Project, 1989)(Elhadad, 1993). A com-
mon use for such grammars is enforcing number, gen-
der, and case agreement.
The system here is also pipelined. The coopera-
tive information system is granted the strategic deci-
sion about &apos;what&apos; to express and the query description
generator decides &apos;how&apos; to express description requests
from the cooperative information system. Thus the lan-
guage being shared here is the language of query ex-
pressions, which are analogous to a fragment of first
order logic. The description system interacts with the
semantical system to obtain the most succinct descrip-
tions of a &apos;query&apos;, but it does not pass any information
back to the cooperative information system. This is
in contrast to more general techniques that explicitly
plan content through complex plan operators(Moore
and Paris, 1989) or schemata(McKeown, 1985) using
established rhetorical theories(Mann and Thompson,
1988). The specific, cooperative information strategy
adopted here is less flexible, but the knowledge speci-
fication task is simplified considerably.
The choice of using a non-feature based phrasal
grammar is based on the relative ease by which
non-expert administrators might provide such phrasal
knowledge. It is also anticipated that case and num-
ber errors will be of only minor annoyance and that
clever administrators might be able to author phrases so
that such errors are minimized. Currently it is assumed
that a single, highly aggregated sentence, may describe
a query. Certainly there is some limit to the number
of query conditions that may be aggregated into a sin-
gle sentence. Techniques to break up of the sentences
must be entertained if we are to scale to more complex
queries. Issues such a pronominalization and ellipsis
are not yet addressed in this work, but will become
</bodyText>
<page confidence="0.997716">
69
</page>
<bodyText confidence="0.99991125">
more important as we consider how to span complex
query descriptions over multiple sentences.
Though the idea of using a phrasal grammar is not
new(Reiter, 1990), nor is using classification in text
generation(Reiter and Mellish, 1992), the approach
here is new in regard to exploiting the properties of the
query formation language L. As long as the reasoning
task is able to present its results as expressions within
this language (or, more liberally disjunctions of L ex-
pressions) then there may indeed be a high degree of
modularity between the reasoning system and the gen-
eration component(Shieber, 1994).
</bodyText>
<sectionHeader confidence="0.999534" genericHeader="conclusions">
7 Conclusions
</sectionHeader>
<bodyText confidence="0.9999896">
This paper proposes a scalable and structured approach
to generating natural language descriptions for a broad
class of relational database queries. The simplicity of
the phrasal approach enables clever database adminis-
trators to author the system without requiring special-
ized linguistic knowledge. The firm semantic basis of
the approach lends a great deal of structure to the au-
thoring process. Notably an administrator can declare
their schema &apos;covered&apos; once they have provided lexical
entries for a bounded set of simple and join conditions.
</bodyText>
<sectionHeader confidence="0.999932" genericHeader="acknowledgments">
8 Bibliography
References
</sectionHeader>
<reference confidence="0.99956895890411">
W. Chu, H. Yang, Chiang K., M. Minock, G. Chow,
and C. Larson. 1996. Cobase: A scalable and ex-
tensible cooperative information system. Intelligent
Information Systems, 6(3):223-259.
M. Elhadad. 1993. FUF: the Universal Unifier. User
Manual Version 5.2. Technical report, Computer
Science, Ben Gurion University.
T. Gaasterland and J. Minkler. 1991. User needs and
language generation issues in a cooperative answer-
ing system. In ICLP Workshop on Adv. Logic Pro-
gramming Tools and Formalisms for Language Proc.
T. Gaasterland, P. Godfrey, and J. Minker. 1992. An
overview of cooperative answering. Intelligent In-
formation Systems, 1(2):127-157.
A. Gal and J. Minker. 1988. Informative and coopera-
tive answers in databases using integrity constraints.
In Natural Language Understanding and Logic Pro-
gramming, pages 277-300.
P. Godfrey, J. Minker, and L. Novik. 1994. An archi-
tecture for a cooperative database system. In Pro-
ceedings of the 1994 International Conference on
Applications of Databases.
P. Godfrey. 1994. Minimization in cooperative re-
sponse to failing database queries. Technical report,
University of Maryland Dept. of Computer Science,
College Park, MD.
P. Grice. 1975. Logic and conversation. In P. Cole and
J. Morgan, editors, Syntax and Semantics. Academic
Press.
T. Imielinski. 1988. Intelligent query answering in rule
based systems. In J. Minker, editor, Foundations of
Deductive Databases and Logic Programming. Mor-
gan Kaufman Publishers.
S. Kaplan. 1982. Cooperative responces from a
portable natural language query system. Artificial
Intelligence, 19:165-187.
M. Kay. 1979. Functional grammar. Fifth Annual
Meeting of the Berkeley Linguistics Society.
W. Mann and S. Thompson. 1988. Rhetorical structure
theory. TEXT, 8(3):243-281.
K. McKeown. 1985. Using Discourse Strategies and
Focus Constraints to Generate Natural Language
Text. Cambridge University Press.
M. Minock and W. Chu. 1996. Interactive explanation
for cooperative information systems. In Proceedings
of the 9th International Symposium on Methodolo-
gies for Intelligent Information Systems.
M. Minock. 2002. Beyond query containment: a de-
cidable language supporting syntactic query differ-
ence. Technical Report 02.21, The Univeristy of
Umea, Umea, Sweden, December.
J. Moore and C. Paris. 1989. Planning text for advisory
dialogue. In Proceedings of the 27th Meeting of the
Association for Computational Linguistics.
Penman Project. 1989. Penman documentation:
the Primer, the User Guide, the Reference Man-
ual, and the Nigel manual. Technical report,
USC/Information Sciences Institute.
E. Reiter and C. Mellish. 1992. Using classification
to generate text. In Proceedings of the 30th Annual
Meeting of the Association for Computational Lin-
guistics., pages 265-272.
E. Reiter. 1990. Generating appropriate natural lan-
guage object descriptions. phd thesis. Hanytrd.
E. Reiter. 1994. Has a consensus NL generation archi-
tecture appeared, and is it psychologically plausible?
In Proceedings of the 7th. International Workshop on
Natural Language generation, pages 163-170.
S. Shieber. 1994. The problem of logical-form equiva-
lence. Computational Linguistics, 19(1):179-190.
C. Shum and R. Muntz. 1987. Implicit representation
for extensional answers. In L. Hershberg, editor, Ex-
pert Database Systems. Tysons Corner.
</reference>
<page confidence="0.998469">
70
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.510096">
<title confidence="0.999933">A Phrasal Generator for Describing Relational Database Queries</title>
<author confidence="0.999917">J Michael</author>
<email confidence="0.748745">@cs.</email>
<affiliation confidence="0.966548">The University of</affiliation>
<address confidence="0.688473">Umed, Sweden</address>
<abstract confidence="0.999243266666667">This paper proposes a technique to generate single sentence natural language descriptions for a wide class of relational database queries. Such a capability meets an important need in the area of cooperative information systems. The approach to describing queries is phrasal and is restricted to tuple relational queries using positive or negatively signed sequences of existential quantifiers over conjunctions of conditions. Query containment and equivalence are decidable for this class and this property is exploited in the maintenance and use of the phrasal lexicon.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>W Chu</author>
<author>H Yang</author>
<author>K Chiang</author>
<author>M Minock</author>
<author>G Chow</author>
<author>C Larson</author>
</authors>
<title>Cobase: A scalable and extensible cooperative information system.</title>
<date>1996</date>
<journal>Intelligent Information Systems,</journal>
<pages>6--3</pages>
<contexts>
<context position="7286" citStr="Chu et al., 1996" startWordPosition="1165" endWordPosition="1168">ase that the user does not interpret an enumeration of all the managers names to mean &apos;all managers&apos;. Once again the ability to describe queries is important. The CARMIN system (Godfrey et al., 1994) includes an integrated explanation and answer presentation system. System explanations are based on the proof path used by a PROLOG meta-interpreter. Aspects of what to include and how to coordinate these explanations are also addressed(Gaasterland and Minkler, 1991). Natural language descriptions of the user query and relaxation process are generated for the cooperative information system CoBase(Chu et al., 1996),(Minock and Chu, 1996). 2.2 Cooperative Information Systems Serving as &apos;Strategic&apos; Planners We propose a modular approach in which the cooperative information system decides &apos;what&apos; to say and a query description sub-system decides &apos;how&apos; to say it. Figure 1 shows an architecture for this approach. The cooperative information system consists of subsystems that perform misconception detection, false presupposition detection, query relaxation and intensional answer generation. The user interface consists of sub-systems that perform query formulation, query description and answer presentation. Bot</context>
</contexts>
<marker>Chu, Yang, Chiang, Minock, Chow, Larson, 1996</marker>
<rawString>W. Chu, H. Yang, Chiang K., M. Minock, G. Chow, and C. Larson. 1996. Cobase: A scalable and extensible cooperative information system. Intelligent Information Systems, 6(3):223-259.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Elhadad</author>
</authors>
<title>FUF: the Universal Unifier. User Manual Version 5.2.</title>
<date>1993</date>
<tech>Technical report,</tech>
<institution>Computer Science, Ben Gurion University.</institution>
<contexts>
<context position="28065" citStr="Elhadad, 1993" startWordPosition="4638" endWordPosition="4639">nally the whole generation process recurs when there is a (1) term within a complement. Once all the textual material is obtained from the recursive calls, a final process reorders the constituents so that the shorter phrases appear before longer phrases. 6 Discussion It has been observed that fielded NLG systems tend to have pipelined architectures with the vast majority using some type of semantic network based representations as the common knowledge representation language(Reiter, 1994). Surface realization tends to be carried out using unification grammars(Kay, 1979)(Penman Project, 1989)(Elhadad, 1993). A common use for such grammars is enforcing number, gender, and case agreement. The system here is also pipelined. The cooperative information system is granted the strategic decision about &apos;what&apos; to express and the query description generator decides &apos;how&apos; to express description requests from the cooperative information system. Thus the language being shared here is the language of query expressions, which are analogous to a fragment of first order logic. The description system interacts with the semantical system to obtain the most succinct descriptions of a &apos;query&apos;, but it does not pass a</context>
</contexts>
<marker>Elhadad, 1993</marker>
<rawString>M. Elhadad. 1993. FUF: the Universal Unifier. User Manual Version 5.2. Technical report, Computer Science, Ben Gurion University.</rawString>
</citation>
<citation valid="true">
<authors>
<author>T Gaasterland</author>
<author>J Minkler</author>
</authors>
<title>User needs and language generation issues in a cooperative answering system.</title>
<date>1991</date>
<booktitle>In ICLP Workshop on Adv. Logic Programming Tools and Formalisms for Language Proc.</booktitle>
<contexts>
<context position="7136" citStr="Gaasterland and Minkler, 1991" startWordPosition="1143" endWordPosition="1147"> manager and Joe Star engineer, it is better to report &amp;quot;all the managers and the engineer named &apos;Joe Star&apos;.&amp;quot; This intensional response is more informative in the case that the user does not interpret an enumeration of all the managers names to mean &apos;all managers&apos;. Once again the ability to describe queries is important. The CARMIN system (Godfrey et al., 1994) includes an integrated explanation and answer presentation system. System explanations are based on the proof path used by a PROLOG meta-interpreter. Aspects of what to include and how to coordinate these explanations are also addressed(Gaasterland and Minkler, 1991). Natural language descriptions of the user query and relaxation process are generated for the cooperative information system CoBase(Chu et al., 1996),(Minock and Chu, 1996). 2.2 Cooperative Information Systems Serving as &apos;Strategic&apos; Planners We propose a modular approach in which the cooperative information system decides &apos;what&apos; to say and a query description sub-system decides &apos;how&apos; to say it. Figure 1 shows an architecture for this approach. The cooperative information system consists of subsystems that perform misconception detection, false presupposition detection, query relaxation and in</context>
</contexts>
<marker>Gaasterland, Minkler, 1991</marker>
<rawString>T. Gaasterland and J. Minkler. 1991. User needs and language generation issues in a cooperative answering system. In ICLP Workshop on Adv. Logic Programming Tools and Formalisms for Language Proc.</rawString>
</citation>
<citation valid="true">
<authors>
<author>T Gaasterland</author>
<author>P Godfrey</author>
<author>J Minker</author>
</authors>
<title>An overview of cooperative answering.</title>
<date>1992</date>
<journal>Intelligent Information Systems,</journal>
<pages>1--2</pages>
<contexts>
<context position="1331" citStr="Gaasterland et al., 1992" startWordPosition="199" endWordPosition="202">exicon. 1 Introduction Often relational database schemas are delivered as collections of oddly named tables and attributes. Users and administrators are expected to query, integrate and otherwise maintain such systems. Natural language generation has been seen as an important part of improving the understandability of relational database schemas(McKeown, 1985). The focus here, however, is not to explain or describe database schemas, but rather to describe database queries. While at first this may seem to be of limited value, we shall see that many techniques in cooperative information systems(Gaasterland et al., 1992) require &apos;query&apos; descriptions as an integral part of their communication process. The &apos;query&apos; being described is not usually the user&apos;s own query, but rather some derived expression that may be written in the form of a query. A set of cooperative techniques that require such description services shall be reviewed in this paper. We view the cooperative information system that bundles these techniques, as essentially providing the services of a strategic text planner. The cooperative information system decides communication content with communication acts consisting of template sentences with em</context>
<context position="3788" citStr="Gaasterland et al., 1992" startWordPosition="583" endWordPosition="586">the identified form and the patterns are simply modifier, head, complement triples. 1.1 Organization of this Paper Section 2 shall review cooperative information systems and shall illustrate how such systems play the role of strategic natural language generators. Section 3 shall give a brief introduction to the language in which queries must be expressed. Section 4 describes the phrasal lexicon and section 5 describes the generation process. Section 6 discusses this work in the context of prior work and gives future directions. 2 Cooperative Information Systems Cooperative information systems(Gaasterland et al., 1992) seek to extend conventional database queryanswer dialogues with the principles of cooperative conversation(Grice, 1975). Thus the response to the user&apos;s query is richer than simply presenting the answers that meet the conditions of their query. Often 63 such responses are conceptual and may in fact be specified with derived &apos;query&apos; expressions. We now cover specific cooperative techniques that have such &apos;conceptual&apos; outputs. 2.1 Cooperative Techniques A user may have a query misconceptions, meaning that the user is unaware that their query presupposes an illegal state of the database. For exa</context>
</contexts>
<marker>Gaasterland, Godfrey, Minker, 1992</marker>
<rawString>T. Gaasterland, P. Godfrey, and J. Minker. 1992. An overview of cooperative answering. Intelligent Information Systems, 1(2):127-157.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Gal</author>
<author>J Minker</author>
</authors>
<title>Informative and cooperative answers in databases using integrity constraints.</title>
<date>1988</date>
<booktitle>In Natural Language Understanding and Logic Programming,</booktitle>
<pages>277--300</pages>
<contexts>
<context position="4774" citStr="Gal and Minker, 1988" startWordPosition="753" endWordPosition="756">ific cooperative techniques that have such &apos;conceptual&apos; outputs. 2.1 Cooperative Techniques A user may have a query misconceptions, meaning that the user is unaware that their query presupposes an illegal state of the database. For example assume that a state law in Ohio is that all mayors must be over 25 years old. If a user is unaware of this restriction and issues a request &amp;quot;list all female mayors in Ohio that are younger than 23&amp;quot;, they should be informed that &amp;quot;it is impossible for people under 25 to be mayors of cities in Ohio.&amp;quot; Such a conceptual response is in the form of a &apos;query&apos;. Gal (Gal and Minker, 1988) uses integrity constraints to explain query misconceptions back to the user. Related to query misconceptions, a user should be made aware of a false presupposition they have about the database state. A false presupposition is an assumption that is implicit in a user&apos;s query, though false. The system CO-OP(Kaplan, 1982) used a limited theory of cooperation to correct false presuppositions. For example assume that a user requests: &amp;quot;Give the cities with population over 2 million in the state of Alaska or North Dakota that have a female mayor&amp;quot; A traditional system would say, &amp;quot;none.&amp;quot; A system that</context>
</contexts>
<marker>Gal, Minker, 1988</marker>
<rawString>A. Gal and J. Minker. 1988. Informative and cooperative answers in databases using integrity constraints. In Natural Language Understanding and Logic Programming, pages 277-300.</rawString>
</citation>
<citation valid="true">
<authors>
<author>P Godfrey</author>
<author>J Minker</author>
<author>L Novik</author>
</authors>
<title>An architecture for a cooperative database system.</title>
<date>1994</date>
<booktitle>In Proceedings of the 1994 International Conference on Applications of Databases.</booktitle>
<contexts>
<context position="6868" citStr="Godfrey et al., 1994" startWordPosition="1102" endWordPosition="1105">l answers. Intensional query answering (Imielinski, 1988) (Shum and Muntz, 1987) provides a summary answer rather than the entire tuple extension satisfying the query. If you are asking for all employees who make over 100,000$, instead of listing every single manager and Joe Star engineer, it is better to report &amp;quot;all the managers and the engineer named &apos;Joe Star&apos;.&amp;quot; This intensional response is more informative in the case that the user does not interpret an enumeration of all the managers names to mean &apos;all managers&apos;. Once again the ability to describe queries is important. The CARMIN system (Godfrey et al., 1994) includes an integrated explanation and answer presentation system. System explanations are based on the proof path used by a PROLOG meta-interpreter. Aspects of what to include and how to coordinate these explanations are also addressed(Gaasterland and Minkler, 1991). Natural language descriptions of the user query and relaxation process are generated for the cooperative information system CoBase(Chu et al., 1996),(Minock and Chu, 1996). 2.2 Cooperative Information Systems Serving as &apos;Strategic&apos; Planners We propose a modular approach in which the cooperative information system decides &apos;what&apos; </context>
</contexts>
<marker>Godfrey, Minker, Novik, 1994</marker>
<rawString>P. Godfrey, J. Minker, and L. Novik. 1994. An architecture for a cooperative database system. In Proceedings of the 1994 International Conference on Applications of Databases.</rawString>
</citation>
<citation valid="true">
<authors>
<author>P Godfrey</author>
</authors>
<title>Minimization in cooperative response to failing database queries.</title>
<date>1994</date>
<tech>Technical report,</tech>
<institution>University of Maryland Dept. of Computer Science, College Park, MD.</institution>
<contexts>
<context position="5718" citStr="Godfrey, 1994" startWordPosition="910" endWordPosition="911">imited theory of cooperation to correct false presuppositions. For example assume that a user requests: &amp;quot;Give the cities with population over 2 million in the state of Alaska or North Dakota that have a female mayor&amp;quot; A traditional system would say, &amp;quot;none.&amp;quot; A system that could detect false presuppositions would respond, &amp;quot;there are no cities in Alaska or North Dakota with a population over 2 million.&amp;quot; This is a description of the minimal failing sub-query of the users original query. Efficient algorithms exist to find minimal failing subqueries (MFS) as well maximal succeeding sub-queries (MSS)(Godfrey, 1994). Query relaxation is useful when a query has no matching tuples. During query relaxation conditions may be loosened or alternate entity types may be queried. For example when asking for flights from Dulles airport to La Guardia with a Sunday morning departure at 10 am, a relaxed query might return a 9:32 am flight from Dulles arriving at JFK. An entity type relaxation might offer a train or a bus trip rather than airplane flight. It is important to describe the relaxed query to the user before flooding them with extensional answers. Intensional query answering (Imielinski, 1988) (Shum and Mun</context>
</contexts>
<marker>Godfrey, 1994</marker>
<rawString>P. Godfrey. 1994. Minimization in cooperative response to failing database queries. Technical report, University of Maryland Dept. of Computer Science, College Park, MD.</rawString>
</citation>
<citation valid="true">
<authors>
<author>P Grice</author>
</authors>
<title>Logic and conversation.</title>
<date>1975</date>
<editor>In P. Cole and J. Morgan, editors, Syntax and Semantics.</editor>
<publisher>Academic Press.</publisher>
<contexts>
<context position="3908" citStr="Grice, 1975" startWordPosition="600" endWordPosition="601">view cooperative information systems and shall illustrate how such systems play the role of strategic natural language generators. Section 3 shall give a brief introduction to the language in which queries must be expressed. Section 4 describes the phrasal lexicon and section 5 describes the generation process. Section 6 discusses this work in the context of prior work and gives future directions. 2 Cooperative Information Systems Cooperative information systems(Gaasterland et al., 1992) seek to extend conventional database queryanswer dialogues with the principles of cooperative conversation(Grice, 1975). Thus the response to the user&apos;s query is richer than simply presenting the answers that meet the conditions of their query. Often 63 such responses are conceptual and may in fact be specified with derived &apos;query&apos; expressions. We now cover specific cooperative techniques that have such &apos;conceptual&apos; outputs. 2.1 Cooperative Techniques A user may have a query misconceptions, meaning that the user is unaware that their query presupposes an illegal state of the database. For example assume that a state law in Ohio is that all mayors must be over 25 years old. If a user is unaware of this restrict</context>
</contexts>
<marker>Grice, 1975</marker>
<rawString>P. Grice. 1975. Logic and conversation. In P. Cole and J. Morgan, editors, Syntax and Semantics. Academic Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>T Imielinski</author>
</authors>
<title>Intelligent query answering in rule based systems.</title>
<date>1988</date>
<booktitle>Foundations of Deductive Databases and Logic Programming.</booktitle>
<editor>In J. Minker, editor,</editor>
<publisher>Morgan Kaufman Publishers.</publisher>
<contexts>
<context position="6304" citStr="Imielinski, 1988" startWordPosition="1007" endWordPosition="1008">ub-queries (MSS)(Godfrey, 1994). Query relaxation is useful when a query has no matching tuples. During query relaxation conditions may be loosened or alternate entity types may be queried. For example when asking for flights from Dulles airport to La Guardia with a Sunday morning departure at 10 am, a relaxed query might return a 9:32 am flight from Dulles arriving at JFK. An entity type relaxation might offer a train or a bus trip rather than airplane flight. It is important to describe the relaxed query to the user before flooding them with extensional answers. Intensional query answering (Imielinski, 1988) (Shum and Muntz, 1987) provides a summary answer rather than the entire tuple extension satisfying the query. If you are asking for all employees who make over 100,000$, instead of listing every single manager and Joe Star engineer, it is better to report &amp;quot;all the managers and the engineer named &apos;Joe Star&apos;.&amp;quot; This intensional response is more informative in the case that the user does not interpret an enumeration of all the managers names to mean &apos;all managers&apos;. Once again the ability to describe queries is important. The CARMIN system (Godfrey et al., 1994) includes an integrated explanation </context>
</contexts>
<marker>Imielinski, 1988</marker>
<rawString>T. Imielinski. 1988. Intelligent query answering in rule based systems. In J. Minker, editor, Foundations of Deductive Databases and Logic Programming. Morgan Kaufman Publishers.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S Kaplan</author>
</authors>
<title>Cooperative responces from a portable natural language query system.</title>
<date>1982</date>
<journal>Artificial Intelligence,</journal>
<pages>19--165</pages>
<contexts>
<context position="5095" citStr="Kaplan, 1982" startWordPosition="806" endWordPosition="807">s unaware of this restriction and issues a request &amp;quot;list all female mayors in Ohio that are younger than 23&amp;quot;, they should be informed that &amp;quot;it is impossible for people under 25 to be mayors of cities in Ohio.&amp;quot; Such a conceptual response is in the form of a &apos;query&apos;. Gal (Gal and Minker, 1988) uses integrity constraints to explain query misconceptions back to the user. Related to query misconceptions, a user should be made aware of a false presupposition they have about the database state. A false presupposition is an assumption that is implicit in a user&apos;s query, though false. The system CO-OP(Kaplan, 1982) used a limited theory of cooperation to correct false presuppositions. For example assume that a user requests: &amp;quot;Give the cities with population over 2 million in the state of Alaska or North Dakota that have a female mayor&amp;quot; A traditional system would say, &amp;quot;none.&amp;quot; A system that could detect false presuppositions would respond, &amp;quot;there are no cities in Alaska or North Dakota with a population over 2 million.&amp;quot; This is a description of the minimal failing sub-query of the users original query. Efficient algorithms exist to find minimal failing subqueries (MFS) as well maximal succeeding sub-queri</context>
</contexts>
<marker>Kaplan, 1982</marker>
<rawString>S. Kaplan. 1982. Cooperative responces from a portable natural language query system. Artificial Intelligence, 19:165-187.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Kay</author>
</authors>
<title>Functional grammar. Fifth Annual Meeting of the Berkeley Linguistics Society.</title>
<date>1979</date>
<journal>W. Mann</journal>
<pages>8--3</pages>
<contexts>
<context position="28028" citStr="Kay, 1979" startWordPosition="4635" endWordPosition="4636">ch a minimal combination. Occasionally the whole generation process recurs when there is a (1) term within a complement. Once all the textual material is obtained from the recursive calls, a final process reorders the constituents so that the shorter phrases appear before longer phrases. 6 Discussion It has been observed that fielded NLG systems tend to have pipelined architectures with the vast majority using some type of semantic network based representations as the common knowledge representation language(Reiter, 1994). Surface realization tends to be carried out using unification grammars(Kay, 1979)(Penman Project, 1989)(Elhadad, 1993). A common use for such grammars is enforcing number, gender, and case agreement. The system here is also pipelined. The cooperative information system is granted the strategic decision about &apos;what&apos; to express and the query description generator decides &apos;how&apos; to express description requests from the cooperative information system. Thus the language being shared here is the language of query expressions, which are analogous to a fragment of first order logic. The description system interacts with the semantical system to obtain the most succinct descriptions</context>
</contexts>
<marker>Kay, 1979</marker>
<rawString>M. Kay. 1979. Functional grammar. Fifth Annual Meeting of the Berkeley Linguistics Society. W. Mann and S. Thompson. 1988. Rhetorical structure theory. TEXT, 8(3):243-281.</rawString>
</citation>
<citation valid="true">
<authors>
<author>K McKeown</author>
</authors>
<title>Using Discourse Strategies and Focus Constraints to Generate Natural Language Text.</title>
<date>1985</date>
<publisher>Cambridge University Press.</publisher>
<contexts>
<context position="1068" citStr="McKeown, 1985" startWordPosition="159" endWordPosition="160"> queries using positive or negatively signed sequences of existential quantifiers over conjunctions of conditions. Query containment and equivalence are decidable for this class and this property is exploited in the maintenance and use of the phrasal lexicon. 1 Introduction Often relational database schemas are delivered as collections of oddly named tables and attributes. Users and administrators are expected to query, integrate and otherwise maintain such systems. Natural language generation has been seen as an important part of improving the understandability of relational database schemas(McKeown, 1985). The focus here, however, is not to explain or describe database schemas, but rather to describe database queries. While at first this may seem to be of limited value, we shall see that many techniques in cooperative information systems(Gaasterland et al., 1992) require &apos;query&apos; descriptions as an integral part of their communication process. The &apos;query&apos; being described is not usually the user&apos;s own query, but rather some derived expression that may be written in the form of a query. A set of cooperative techniques that require such description services shall be reviewed in this paper. We view</context>
<context position="28880" citStr="McKeown, 1985" startWordPosition="4767" endWordPosition="4768"> express and the query description generator decides &apos;how&apos; to express description requests from the cooperative information system. Thus the language being shared here is the language of query expressions, which are analogous to a fragment of first order logic. The description system interacts with the semantical system to obtain the most succinct descriptions of a &apos;query&apos;, but it does not pass any information back to the cooperative information system. This is in contrast to more general techniques that explicitly plan content through complex plan operators(Moore and Paris, 1989) or schemata(McKeown, 1985) using established rhetorical theories(Mann and Thompson, 1988). The specific, cooperative information strategy adopted here is less flexible, but the knowledge specification task is simplified considerably. The choice of using a non-feature based phrasal grammar is based on the relative ease by which non-expert administrators might provide such phrasal knowledge. It is also anticipated that case and number errors will be of only minor annoyance and that clever administrators might be able to author phrases so that such errors are minimized. Currently it is assumed that a single, highly aggreg</context>
</contexts>
<marker>McKeown, 1985</marker>
<rawString>K. McKeown. 1985. Using Discourse Strategies and Focus Constraints to Generate Natural Language Text. Cambridge University Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Minock</author>
<author>W Chu</author>
</authors>
<title>Interactive explanation for cooperative information systems.</title>
<date>1996</date>
<booktitle>In Proceedings of the 9th International Symposium on Methodologies for Intelligent Information Systems.</booktitle>
<contexts>
<context position="7309" citStr="Minock and Chu, 1996" startWordPosition="1168" endWordPosition="1171">oes not interpret an enumeration of all the managers names to mean &apos;all managers&apos;. Once again the ability to describe queries is important. The CARMIN system (Godfrey et al., 1994) includes an integrated explanation and answer presentation system. System explanations are based on the proof path used by a PROLOG meta-interpreter. Aspects of what to include and how to coordinate these explanations are also addressed(Gaasterland and Minkler, 1991). Natural language descriptions of the user query and relaxation process are generated for the cooperative information system CoBase(Chu et al., 1996),(Minock and Chu, 1996). 2.2 Cooperative Information Systems Serving as &apos;Strategic&apos; Planners We propose a modular approach in which the cooperative information system decides &apos;what&apos; to say and a query description sub-system decides &apos;how&apos; to say it. Figure 1 shows an architecture for this approach. The cooperative information system consists of subsystems that perform misconception detection, false presupposition detection, query relaxation and intensional answer generation. The user interface consists of sub-systems that perform query formulation, query description and answer presentation. Both the interface and the</context>
</contexts>
<marker>Minock, Chu, 1996</marker>
<rawString>M. Minock and W. Chu. 1996. Interactive explanation for cooperative information systems. In Proceedings of the 9th International Symposium on Methodologies for Intelligent Information Systems.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Minock</author>
</authors>
<title>Beyond query containment: a decidable language supporting syntactic query difference.</title>
<date>2002</date>
<tech>Technical Report 02.21,</tech>
<institution>The Univeristy of Umea, Umea, Sweden,</institution>
<contexts>
<context position="2345" citStr="Minock, 2002" startWordPosition="360" endWordPosition="361">s, as essentially providing the services of a strategic text planner. The cooperative information system decides communication content with communication acts consisting of template sentences with embedded requests for &apos;query&apos; descriptions. Given that we seek to describe queries, we must contend with the fact that there are infinitely many syntactically correct queries over a given schema. It is critical that the generation system provide adequate coverage over some well defined portion of this space. In this paper the space of coverage mirrors a recently defined class of schema tuple queries(Minock, 2002). Because of the natural closure properties of this language, and its decidability for equivalence and containment, it is reasonable to assume that many cooperative techniques may generate output &apos;queries&apos; within this form. The author of the query description system is assumed to be a database administrator. Thus we must adopt a generation technique that does not require a deep understanding of linguistics. Moreover the administrator must be given a structured method of authoring so that they may declare a schema covered. That is the system should faithfully, if not always elegantly, describe </context>
<context position="12793" citStr="Minock, 2002" startWordPosition="2053" endWordPosition="2054">language we limit ourselves to - the language L. Definition 1 (The language L) E L if t is in the form: R(x) k-1 Si. (3)11 where x is the only free variable of f, R(x) is the range condition for x, si is a positive or negative (—,) sign, A is a finite sequence of existentially quantified variables and is a conjunction of range conditions, simple conditions, set conditions and join conditions. Those who are familiar with databases will note that this schema makes the rather simplistic assumption that all city names in the world are unique. 65 The example queries from above are shown here. See (Minock, 2002) for a more complete discussion of L. Each query {x1t} returns a set of tuples. For the first six queries, t E L. 1.){x1Person(x) A x.gender = &apos;male&apos; A x.age &gt; 18A x.city E { Taris&apos;,`Nice&apos;}l 2.){x1Person(x) A (y) (City(y) A y.population&gt; 100000A y.cityName = x.city)} 3.){x1Person(x) A —,(]y) (City(y) A y.population &gt; 100000A y.cityName = x.city)} 4.){xlPerson(x) A (y)(±)( (Know(y) A Person(z)A z.city = &apos;Nice&apos; A x.name = y.knower A y.known = z.name)} 5.){x1Person(x) A —,(]y)(]z)( (Know(y) A Person(z)A z.city = &apos;Nice&apos; A x.name = y.knower A y.known = z.name)} 6.){x1Person(x) A (y) (Know(y) A y.op</context>
<context position="25946" citStr="Minock, 2002" startWordPosition="4291" endWordPosition="4292">e hierarchy consists of nodes representing entries that are meant to make generation more precise. Figure 2 also shows two queries sorted into the hierarchy. The only complication in the sort procedure is handling parameters and open formula of the lexical entries. The way to handle parameters, is to allow them to range over any domain value except a distinguished 4The notion of subsumption hierarchy here corresponds with that used in description logics. However it should be noted that the logic here differs considerably from the unary and binary predicates of typical description logics. See (Minock, 2002) for a full discussion of this. 68 Figure 2: The phrasal lexicon organized as a subsumption hierarchy. &amp;quot;inn/er living in Paris or Nice&amp;quot; &apos;people living in cities with populations of over 100,000 people&amp;quot; • Lexically covered node O Non—covered node • Covered query E Non—covered query Subsumes [] people [that live in GEN(W1)] [] people [that don&apos;t live in GEN(W2)] 11 people [who know and c3 some GEN(W3) symbol unkown. This is recored by inserting the simple condition that the parameter does not equal unknown. Open formula c13 are simply assumed to be true and are replaced with the symbol T. Given </context>
</contexts>
<marker>Minock, 2002</marker>
<rawString>M. Minock. 2002. Beyond query containment: a decidable language supporting syntactic query difference. Technical Report 02.21, The Univeristy of Umea, Umea, Sweden, December.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Moore</author>
<author>C Paris</author>
</authors>
<title>Planning text for advisory dialogue.</title>
<date>1989</date>
<booktitle>In Proceedings of the 27th Meeting of the Association for Computational Linguistics.</booktitle>
<contexts>
<context position="28853" citStr="Moore and Paris, 1989" startWordPosition="4762" endWordPosition="4765"> strategic decision about &apos;what&apos; to express and the query description generator decides &apos;how&apos; to express description requests from the cooperative information system. Thus the language being shared here is the language of query expressions, which are analogous to a fragment of first order logic. The description system interacts with the semantical system to obtain the most succinct descriptions of a &apos;query&apos;, but it does not pass any information back to the cooperative information system. This is in contrast to more general techniques that explicitly plan content through complex plan operators(Moore and Paris, 1989) or schemata(McKeown, 1985) using established rhetorical theories(Mann and Thompson, 1988). The specific, cooperative information strategy adopted here is less flexible, but the knowledge specification task is simplified considerably. The choice of using a non-feature based phrasal grammar is based on the relative ease by which non-expert administrators might provide such phrasal knowledge. It is also anticipated that case and number errors will be of only minor annoyance and that clever administrators might be able to author phrases so that such errors are minimized. Currently it is assumed t</context>
</contexts>
<marker>Moore, Paris, 1989</marker>
<rawString>J. Moore and C. Paris. 1989. Planning text for advisory dialogue. In Proceedings of the 27th Meeting of the Association for Computational Linguistics.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Penman Project</author>
</authors>
<title>Penman documentation: the Primer, the User Guide, the Reference Manual, and the Nigel manual.</title>
<date>1989</date>
<tech>Technical report, USC/Information</tech>
<institution>Sciences Institute.</institution>
<contexts>
<context position="28050" citStr="Project, 1989" startWordPosition="4637" endWordPosition="4638">nation. Occasionally the whole generation process recurs when there is a (1) term within a complement. Once all the textual material is obtained from the recursive calls, a final process reorders the constituents so that the shorter phrases appear before longer phrases. 6 Discussion It has been observed that fielded NLG systems tend to have pipelined architectures with the vast majority using some type of semantic network based representations as the common knowledge representation language(Reiter, 1994). Surface realization tends to be carried out using unification grammars(Kay, 1979)(Penman Project, 1989)(Elhadad, 1993). A common use for such grammars is enforcing number, gender, and case agreement. The system here is also pipelined. The cooperative information system is granted the strategic decision about &apos;what&apos; to express and the query description generator decides &apos;how&apos; to express description requests from the cooperative information system. Thus the language being shared here is the language of query expressions, which are analogous to a fragment of first order logic. The description system interacts with the semantical system to obtain the most succinct descriptions of a &apos;query&apos;, but it </context>
</contexts>
<marker>Project, 1989</marker>
<rawString>Penman Project. 1989. Penman documentation: the Primer, the User Guide, the Reference Manual, and the Nigel manual. Technical report, USC/Information Sciences Institute.</rawString>
</citation>
<citation valid="true">
<authors>
<author>E Reiter</author>
<author>C Mellish</author>
</authors>
<title>Using classification to generate text.</title>
<date>1992</date>
<booktitle>In Proceedings of the 30th Annual Meeting of the Association for Computational Linguistics.,</booktitle>
<pages>265--272</pages>
<contexts>
<context position="30067" citStr="Reiter and Mellish, 1992" startWordPosition="4953" endWordPosition="4956">s assumed that a single, highly aggregated sentence, may describe a query. Certainly there is some limit to the number of query conditions that may be aggregated into a single sentence. Techniques to break up of the sentences must be entertained if we are to scale to more complex queries. Issues such a pronominalization and ellipsis are not yet addressed in this work, but will become 69 more important as we consider how to span complex query descriptions over multiple sentences. Though the idea of using a phrasal grammar is not new(Reiter, 1990), nor is using classification in text generation(Reiter and Mellish, 1992), the approach here is new in regard to exploiting the properties of the query formation language L. As long as the reasoning task is able to present its results as expressions within this language (or, more liberally disjunctions of L expressions) then there may indeed be a high degree of modularity between the reasoning system and the generation component(Shieber, 1994). 7 Conclusions This paper proposes a scalable and structured approach to generating natural language descriptions for a broad class of relational database queries. The simplicity of the phrasal approach enables clever databas</context>
</contexts>
<marker>Reiter, Mellish, 1992</marker>
<rawString>E. Reiter and C. Mellish. 1992. Using classification to generate text. In Proceedings of the 30th Annual Meeting of the Association for Computational Linguistics., pages 265-272.</rawString>
</citation>
<citation valid="true">
<authors>
<author>E Reiter</author>
</authors>
<title>Generating appropriate natural language object descriptions. phd thesis.</title>
<date>1990</date>
<publisher>Hanytrd.</publisher>
<contexts>
<context position="29993" citStr="Reiter, 1990" startWordPosition="4945" endWordPosition="4946">thor phrases so that such errors are minimized. Currently it is assumed that a single, highly aggregated sentence, may describe a query. Certainly there is some limit to the number of query conditions that may be aggregated into a single sentence. Techniques to break up of the sentences must be entertained if we are to scale to more complex queries. Issues such a pronominalization and ellipsis are not yet addressed in this work, but will become 69 more important as we consider how to span complex query descriptions over multiple sentences. Though the idea of using a phrasal grammar is not new(Reiter, 1990), nor is using classification in text generation(Reiter and Mellish, 1992), the approach here is new in regard to exploiting the properties of the query formation language L. As long as the reasoning task is able to present its results as expressions within this language (or, more liberally disjunctions of L expressions) then there may indeed be a high degree of modularity between the reasoning system and the generation component(Shieber, 1994). 7 Conclusions This paper proposes a scalable and structured approach to generating natural language descriptions for a broad class of relational datab</context>
</contexts>
<marker>Reiter, 1990</marker>
<rawString>E. Reiter. 1990. Generating appropriate natural language object descriptions. phd thesis. Hanytrd.</rawString>
</citation>
<citation valid="true">
<authors>
<author>E Reiter</author>
</authors>
<title>Has a consensus NL generation architecture appeared, and is it psychologically plausible?</title>
<date>1994</date>
<booktitle>In Proceedings of the 7th. International Workshop on Natural Language generation,</booktitle>
<pages>163--170</pages>
<contexts>
<context position="27945" citStr="Reiter, 1994" startWordPosition="4624" endWordPosition="4625"> It is likely that a greedy technique is sufficient to enable the identification of such a minimal combination. Occasionally the whole generation process recurs when there is a (1) term within a complement. Once all the textual material is obtained from the recursive calls, a final process reorders the constituents so that the shorter phrases appear before longer phrases. 6 Discussion It has been observed that fielded NLG systems tend to have pipelined architectures with the vast majority using some type of semantic network based representations as the common knowledge representation language(Reiter, 1994). Surface realization tends to be carried out using unification grammars(Kay, 1979)(Penman Project, 1989)(Elhadad, 1993). A common use for such grammars is enforcing number, gender, and case agreement. The system here is also pipelined. The cooperative information system is granted the strategic decision about &apos;what&apos; to express and the query description generator decides &apos;how&apos; to express description requests from the cooperative information system. Thus the language being shared here is the language of query expressions, which are analogous to a fragment of first order logic. The description s</context>
</contexts>
<marker>Reiter, 1994</marker>
<rawString>E. Reiter. 1994. Has a consensus NL generation architecture appeared, and is it psychologically plausible? In Proceedings of the 7th. International Workshop on Natural Language generation, pages 163-170.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S Shieber</author>
</authors>
<title>The problem of logical-form equivalence.</title>
<date>1994</date>
<journal>Computational Linguistics,</journal>
<pages>19--1</pages>
<marker>Shieber, 1994</marker>
<rawString>S. Shieber. 1994. The problem of logical-form equivalence. Computational Linguistics, 19(1):179-190.</rawString>
</citation>
<citation valid="true">
<authors>
<author>C Shum</author>
<author>R Muntz</author>
</authors>
<title>Implicit representation for extensional answers.</title>
<date>1987</date>
<booktitle>Expert Database Systems. Tysons Corner.</booktitle>
<editor>In L. Hershberg, editor,</editor>
<contexts>
<context position="6327" citStr="Shum and Muntz, 1987" startWordPosition="1009" endWordPosition="1012">dfrey, 1994). Query relaxation is useful when a query has no matching tuples. During query relaxation conditions may be loosened or alternate entity types may be queried. For example when asking for flights from Dulles airport to La Guardia with a Sunday morning departure at 10 am, a relaxed query might return a 9:32 am flight from Dulles arriving at JFK. An entity type relaxation might offer a train or a bus trip rather than airplane flight. It is important to describe the relaxed query to the user before flooding them with extensional answers. Intensional query answering (Imielinski, 1988) (Shum and Muntz, 1987) provides a summary answer rather than the entire tuple extension satisfying the query. If you are asking for all employees who make over 100,000$, instead of listing every single manager and Joe Star engineer, it is better to report &amp;quot;all the managers and the engineer named &apos;Joe Star&apos;.&amp;quot; This intensional response is more informative in the case that the user does not interpret an enumeration of all the managers names to mean &apos;all managers&apos;. Once again the ability to describe queries is important. The CARMIN system (Godfrey et al., 1994) includes an integrated explanation and answer presentation</context>
</contexts>
<marker>Shum, Muntz, 1987</marker>
<rawString>C. Shum and R. Muntz. 1987. Implicit representation for extensional answers. In L. Hershberg, editor, Expert Database Systems. Tysons Corner.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>