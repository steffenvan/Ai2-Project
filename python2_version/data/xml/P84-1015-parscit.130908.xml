<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000003">
<title confidence="0.847639">
USES OF C-GRAPHS IN A PROTOTYPE FOR ALTOMATIC TRANSLATION.
</title>
<author confidence="0.934632">
Marco A. CLEMENTE-SALAZAR
</author>
<affiliation confidence="0.835134">
Centro de Graduados e Investigacion,
Instituto Tecnologico de Chihuahua,
</affiliation>
<address confidence="0.7563665">
Av. Tecnologico No. 2909,
31310 Chihuahua, Chih., MEXICO.
</address>
<email confidence="0.649665">
ABSTRACT
</email>
<bodyText confidence="0.999956">
This paper presents a prototype, not com-
pletely operational, that is intended to use
c-graphs in the translation of assemblers. Firstly,
the formalization of the structure and its princi-
pal notions (substructures, classes of substruc-
tures, order, etc.) are presented. Next section de-
scribes the prototype which is based on a Transfor-
mational System as well as on a rewriting system of
c-graphs which constitutes the nodes of the Trans-
formational System. The following part discusses a
set of operations on the structure. Finally, the
implementation in its present state is shown.
</bodyText>
<sectionHeader confidence="0.83047" genericHeader="abstract">
1. INTRODUCTION.
</sectionHeader>
<bodyText confidence="0.999986368421053">
In the past [10,11], several kinds of repre-
sentation have been used (strings, labelled trees,
trees with &amp;quot;decorations&amp;quot;, graphs of strings and
(semantic) networks). C-graphs had its origin as
an alternative in the representation and in the
treatment of ambiguities in Automatic Translation.
In earlier papers (4,5) this structure is named
E-graph but c-graph is better suited since it is a
generalized &amp;quot;grafo de cadenas&amp;quot; (graph of strings).
This structure combines some advantages of
the Q-systems ID and of the trees of AR1ANE-78
(1,2,11), in particular, the use of only one struc-
ture for all the translation process (as in the
former) and foreseeable decidability and parallel-
ism (as in the latter). This paper presents a pro-
totype, not completely operational, that uses
c-graphs and is intended to translate assemblers
to refine the adequacy of this kind of structure
in the translation of natural languages.
</bodyText>
<sectionHeader confidence="0.997847" genericHeader="introduction">
2. DEFINITIONS
</sectionHeader>
<bodyText confidence="0.999664888888889">
C-graph. A c-graph G is a cycle free,labelled
graph [1,9) without isolated nodes and with exactly
one entry node and one exit node. It is completely
determined by a 7-tuple: G.(A,S,0,1,0,E,c), where
A is a set of arcs, S a set of nodes, p a mapping
of A into SxS, I the input node, 0 the output node,
E a set of labels (c-trees, c-graphs) and c a map-
ping of A into E. For the sake of simplicity, arcs
and labels will be merged in the representation of
</bodyText>
<equation confidence="0.848605">
G (cf. Fig.1). Interesting c-graphs are sequential
c-graphs (cf. Fig.2a) and bundles (cf. Fig.2b).
A={1,...,12} ; S={1,...,7) ; l={1} ; 0={7}
p={(1,1,2),(2,2,4),(3,4,5),(4,5,7),(5,5,6),
(6,6,7),(7,6,7),(8,2,3),(9,3,4),(10,3,5),
(11,1,2),(12,1,2))
E={a,b,c,d,e,f,g,h,i,j,k}
c={(1,a),(2,b),(3,f),(11,g),(5,i),(6,j),
(7,k),(8,c),(9,d),(10,e),(11,b),(12,h)}
(a) (b)
Fig.2. A seq. c-graph (a) and a bundle (b).
</equation>
<bodyText confidence="0.966564055555556">
C-trees. A c-tree or a tree with decorations
is an ordered tree, with nodes labelled by a label
and a decoration that is itself a decorated tree,
possibly empty.
Classes of c-qraphs. There are three major
classes: (1) recursive c-graphs (cf. Fig.3a) where
each arc is labelled by a c-graph; (2) simple
c-graphs (cf. Fig.1) where each arc is labelled by
a c-tree and (3) regular c-graphs, a proper sub-
class of the second that is obtained by concatena-
tion and alternation of simple arcs (cf. Fig.3b).
By denoting concatenation by &amp;quot;.&amp;quot; and alternation
by &amp;quot;+&amp;quot;, we have an evident linear representation.
For example, G4=g+i.(j+k). Note that not every
c-graph may be obtained by these operations, e.g.G.
Substructures. For the sake of homogeneity,
the only substructures allowed are those that are
themselves c-graphs. They will be called sub-
</bodyText>
<equation confidence="0.7472075">
Fig.l. A c-graph.
Gl= -o G2=
</equation>
<page confidence="0.963987">
61
</page>
<bodyText confidence="0.701889">
-c-graphs or seg&apos;s. For example, GI and G2 are
seg&apos;s of G.
</bodyText>
<figure confidence="0.75926425">
G1 G1
03= a) A recursive c-graph.
G2
b) A regular c-graph. G4=
</figure>
<figureCaption confidence="0.785414">
Fig.3. Two classes of c-graphs.
</figureCaption>
<bodyText confidence="0.996086">
Isolatability. It is a feature that deter-
mines, for each c-graph G, several classes of seg&apos;s
An isolated seg G&apos; is intuitively a seg that has no
arcs that &amp;quot;enter&amp;quot; or that &amp;quot;leave&amp;quot; G&apos;. Depending on
the relation that each isolated seg keeps with the
rest of the c-graph, several classes of isolatabil-
ity can be defined.
</bodyText>
<listItem confidence="0.994202923076923">
a) Weak isolatability. A seg G&apos; of G is weakly
isolatable (segif) if and only if for every
node x of G&apos; (except l&apos; and 0&apos;), all of the
arcs that leave or enter x are in G&apos;. E.g.:
G5=i is a segif of G.
b) Normal isolatability. A seg G&apos; of G is normaly
isolatable (segmi) if and only if it is a
segif and there is a path, not in G&apos;, such
that it leaves l&apos; and enters 0&apos;. Example: G6=k
is a segmi of G.
c) Strong isolatability. A seg G&apos; of G is
strongly isolatable (segfi) if and only if the
only node that has entering arcs not in G&apos; is
</listItem>
<bodyText confidence="0.998711916666667">
I&apos; and the only node that has leaving arcs not
in G&apos; is 0&apos;. When G&apos; is not an arc and there
is no segfi contained strictly in G&apos;, then G&apos;
is an &amp;quot;elementary segfi&amp;quot;; if G contains no
segfi, then G.is elementary. E.g. G4 is a
segfi of G.
Order and roads. Two order relations are con-
sidered: (1) a &amp;quot;vertical&amp;quot; order or linear order of
the arcs having the same initial node and (2) a
&amp;quot;horizontal&amp;quot; order or partial order between two
arcs on the same path. A road is a path from I to 0
Vertical order induces a linear order on roads.
</bodyText>
<sectionHeader confidence="0.888955" genericHeader="method">
3. DEFINITION OF THE PROTOTYPE.
</sectionHeader>
<bodyText confidence="0.999964166666667">
The prototype consists of a model and a data
structure. The model is essentially a generaliza-
tion of a Transformational System (TS) analogous
to ROBRA EU and whose grammars are rewriting sys-
tems of c-graphs (RSC) 0,5,6]. Regarding data
structure, we use c•graphst
</bodyText>
<subsectionHeader confidence="0.912118">
3.1 A Transformational System.
</subsectionHeader>
<bodyText confidence="0.9923998">
This IS is a c-graph-oc-graph transducer. It
is a &amp;quot;control&amp;quot; graph whose nodes are RSC and the
arcs are labelled by conditions. &apos;
A IS is a cycle free oriented graph, with
only one input and such that,
</bodyText>
<listItem confidence="0.9994446">
(1) Each node is labelled with a RSC or &amp;nul.
(2) &amp;nul has no successor.
(3) Each grammar of the RSC has a transition
scheme S or c (empty scheme).
(4) Arcs of the same initial node are ordered.
</listItem>
<bodyText confidence="0.991713727272727">
T5 works heuristically. Given a c-graph go as
an input, it searches for the first path ending in
&amp;nul. This fact implies that all of the transition
schemes on the path were satisfied. Any scheme not
satisfied provokes a search of a new path. For
example, if Si is satisfied, IS produces Gl(gn)=g1
and it proceeds to calculate G2(G1(90))=g2. If 54
is satisfied the system stops and produces g2.
Otherwise, it backtracks to GI and tests S2. If it
is satisfied gl is produced. Otherwise, it tests
53&apos; etc.
</bodyText>
<sectionHeader confidence="0.483257" genericHeader="method">
Fig.4. A Transformational System.
</sectionHeader>
<subsectionHeader confidence="0.937295">
3.2 A REWRITING SYSTEM.
</subsectionHeader>
<bodyText confidence="0.999834666666667">
Let us consider a simple example: let GR be
the following grammar for syntactic analysis (with-
out intending an example of linguistic value).
</bodyText>
<equation confidence="0.999858461538461">
R1:(gl+al+g2)(g3+a2+g4)* / al=GN, a2=GV / ==
(gl+g2)(g3+a2+g4)+81 / 01:=PHRA(el,a2) I.
R2:(91+al+g2)(93+a2+g4) / al=VB, a2=GN /
(gl+g2)(g3+a2+g4)+81 / a1:=PRED(al,a2) I.
R3:cii(gl+a2+92) / al=NP, a2=AD / ==
al(gl+g2)+a1 / $1:=GN(al,a2) I.
R4:al(g1+a2+g2)
gl+g2+0 / al=NP, a2=PRED / ==
/ 61:=PHRA(al,a2) I.
R5:(gl+al+g2)(93+02+94) / al=PRON, a2=VB / ==
(91+92)(g3i-a2+g4)+0 / al:=GV(al,a2) I.
R6:(gl+al+g2)(g3+a2+g4) / al=ART, a2=NM / ==
(gl+g2)(g3+a2+g4)+31 / 131:=GN(al,a2) I.
</equation>
<bodyText confidence="0.983078666666667">
As we can see, each rule has: a name (R1,R2,
...), a left side and a right side.
The left side defines the geometrical form
</bodyText>
<figure confidence="0.985978714285714">
54
&amp;nul
52
&amp;
E
&amp;nul
&amp;nul
</figure>
<page confidence="0.995695">
62
</page>
<bodyText confidence="0.929409148148148">
and the condition that an actual seg must meet in
order to be transformed. It is a c-graph scheme
composed of two parts: the structural descriptor
that defines the geometrical form and the condition
(between slashes) that tests label information. The
first part use &amp;quot;*&amp;quot; as an &amp;quot;element of structural de-
scription&amp;quot; in the first rule. It denotes the fact
that no seg must be right-concatenated to g3+a2+g4.
The right side defines the transformation to
be done. It consists of a structural descriptor,
similar to the one on the left side and a list of
label assignments (also between slashes) where for
each new label we precise the values it takes; and
for each old one, its possible modifications. A
point ends the rule. Note the properties of an
empty g: if g&apos; is any c-graph, then g.g1=g and
g+gl=g1.
Let us analyze the phrase: &amp;quot;Ana lista la ti-
ra&amp;quot;. The representation in our formalism is 67.
Morphological analysis produces 68. Note that all
ambiguities are kept in the same structure in the
form of parallel arcs. The application of GR to 68
results in 69, where each arc will be labelled with
a c-tree with a possible interpretation of 68 in
grammar GR. The sequence of applications is R3, R6,
R5, R1, R2, R4. The system stops when.no more rules
are applicable.
</bodyText>
<figure confidence="0.962821714285714">
G7=
Anao lista la tira
0
listar tirar
listo tira
ad nm
lo
pron
, where
Operations are divided in two classes: (1)
those where the structure is taken as a whole (glob
al) and (2) those that transform substructures
(local).
1. Global Operations.
</figure>
<figureCaption confidence="0.971412875">
Concatenation and alternation have been de-
fined above. These operations produce sequential
c-graphs and bundles respectively, as well as the
polynomial writing of regular c-graphs.
Expansion. This operation produces a bundle
exp(G) from all the roads of a c-graph G. For exam-
ple, expansion of G1O produces exp(G10)=0).0+
(c.d.f)+(c.e).
</figureCaption>
<figure confidence="0.759214">
610=
</figure>
<figureCaption confidence="0.471822">
Fig.6. Expansion of a c-graph.
</figureCaption>
<bodyText confidence="0.973083625">
Factorization. There are two kinds and their
results may differ. Consider C11=a.b+a.c+d.e+d.f+
g.f+h.e. Left factorization produces G12=a.(b+c)+
d.(e+f)+g.f+h.e, and right factorization 613=a.b+
a.c+(d+h).e+(d+g).f.
Arborization. This operation constructs a
c-tree from a c-graph. There may be several kinds
of c-trees that can be constructed but we search
for a tree that keeps vertical and horizontal or-
ders, i.e. one that codes the structure of the
c-graph. An &amp;quot;and-or&amp;quot; (y-o) tree is well suited for
this purpose. The result of the operation will be
a c-graph with one and only one arc labelled by
the and-or tree. For example, arb(G)=G14 (cf. Fig.
7). Note that the non-regular seg has a as a root.
Regular seg&apos;s have o.
</bodyText>
<figure confidence="0.7874731">
Ana
68.
np
69.
A , where
6I4= o--140
Al=PHRA(GN(NP(Ana), AD(listo)), GV(PRON(10),
VB(tirar)))
A2=PHRA(NP(Ana), PRED(VB(listar, GN(ART(e1),
NM(tira))))
</figure>
<footnote confidence="0.741691777777778">
Fig.5. Example of sentence analysis.
3.3 Operations.
A. y(o(y(a),y(b),y(b)),a(y(b,f),y(c,d,f),
Y(c,e)),0(9,Y(i,0(j,k)))
Fig.7. Arborization of G.
2. Local Operations.
Replacement. Given two c-graphs G and G&amp;quot;,this
operation substitutes a seg G&apos; in G for G&amp;quot;, e.g.
if 6=64, G&amp;quot;=m+n and G&apos;.i, then the result will be
</footnote>
<page confidence="0.999296">
63
</page>
<bodyText confidence="0.956445541666667">
G15=g+(m+n):(j+k).
Addition. This operation inserts a c-graph G&apos;
into another, G, by merging two distinct nodes (x,
y) of G with the input and output of G&apos;. Addition
requires only that insertion does not produce cy-
cles. Note that if (1,0) are taken as a couple of
nodes, we have alternation. Example, let (2,3) be
a couple of nodes of G16 and take G&apos;=G17=s+u. The
resulting c-graph is G18.
G16
Fig.8. Addition of a c-graph.
Erasing. This eliminates a substructure G&apos;
of a c-graph G. Erasing may destroy the structure
even if we work with isolated seg&apos;s. Consequently,
it is only defined on particular classes of seg&apos;s,
namely segfi&apos;s and segmi&apos;s. For any other substruc-
ture, we eliminate the smaller segmi that contains
it. A special case constitutes a segfi G&apos; such
that I and 0 do not belong to G&apos;. Eliminating G&apos; in
such a case produces two non-connecting nodes in
the c-graph that we have chosen to merge to pre-
serve homogeneity. Example: let us take G and G&apos;=
GIO, then the result of erasing GIO from G is G19=
02.04.
</bodyText>
<sectionHeader confidence="0.974403" genericHeader="method">
4. IMPLEMENTATION.
</sectionHeader>
<bodyText confidence="0.982981870967742">
A small system has been programmed in PROLOG
141 (mainly operations) and in PASCAL (TS and RSC).
For the first approach, we chose regular c-graphs
to work with, since there is always a string to
represent a c-graph of this class.
In its present state, the system has two
parts: (1) the Transformational System including
the rewriting system and (2) the set of local and
global operations.
The IS is interactive. It consists of an ana-
lyzer that verifies the structure of the IS given
as a console input and of the TS proper. As data
we have the console input and a segment composed of
transition schemes. There are no finer controls for
different modes of grammar execution.
Regarding operations and from a methodological
point of view, algorithms for c-graph treatment can
be divided in two classes: (1) the one where we
search for substructures and (2) the one where this
search is not needed. Obviously, local operations
belong to the first class, but among global opera-
tions, only concatenation, alternation and expan-
sion belong to the second one. Detailed description
of algorithms of this part of the system can be
found in 141.
5. CONCLUSION.
Once we have an operational version of the
prototype, it is intended as a first approach to
proceed to the translation of assemblers of the
microprocessors available in our laboratory such
as INTEL&apos;s 8085 or 8080 and MOTOROLA&apos;s 6800.
</bodyText>
<reference confidence="0.96042303125">
6. REFERENCES.
1.[1] Boitet, Ch. UN ESSAI DE REPONSE A QUELQUES
QUESTIONS THEORIQUES ET PRATIQUES LIEES A LA TRA-
DUCTION AUTOMATIQUE. DEFINITION DUN SYSTEME PROTO-
TYPE. These d&apos;Etat. Grenoble. Avril. 1976.
2.121 Boitet, Ch. AUTOMATIC PRODUCTION OF CF AND CS
ANALYSERS USING A GENERAL TREE TRANSDUCER. Rapport
de recherche de l&apos;Institut de Mathematiques Appli-
quees N°218. Grenoble. Novembre. 1979.
3.14] Clemente-Salazar, M. ETUDES ET ALGORITHMES
LIES A UNE NOUVELLE STRUCTURE DE DONNEES EN T.A.:
LES E-GRAPHES. These Dr-Ing. Grenoble. Mai. 1982.
4.151 Clemente-Salazar, M. E-GRAPHS: AN INTERESTING
DATA STRUCTURE FOR M.T. Paper presented in COLING-
82. Prague. July. 1982.
5.[6] Clemente-Salazar, M. C-GRAPHS: A DATA STRUC-
TURE FOR AUTOMATED TRANSLATION. Paper presented in
the 26th International Midwest Symposium on Cir-
cuits and Systems. Puebla. Mexico. August. 1983.
6.[7] Colmerauer, A. LES SYSTEMES-Q. Universitg de
Montreal.Publication Interne N°43. Septembre. 1970.
7.19] Kuntzmann, J. THEORIE DES RESEAUX (GRAPHES).
Dunod. Paris. 1972.
8.r10] Vauquois, B. LA TRADUCTION AUTOMATIQUE A
GRENOBLE. Document de Linguistique Quantitative
N°24. Dunod. Paris. 1975.
9.[113 Vauquois, B. ASPECTS OF MECHANICAL TRANSLA-
TION IN 1979. Conference for Japan IBM Scientific
Program. Document du Groupe d&apos;Etudes pour la Tra-
duction Automatique. Grenoble. July. 1979.
************
G18.
</reference>
<page confidence="0.995973">
64
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.758627">
<title confidence="0.842094">USES OF C-GRAPHS IN A PROTOTYPE FOR ALTOMATIC TRANSLATION.</title>
<author confidence="0.994186">Marco A CLEMENTE-SALAZAR</author>
<affiliation confidence="0.9984255">Centro de Graduados e Investigacion, Instituto Tecnologico de Chihuahua,</affiliation>
<address confidence="0.960969">Tecnologico No. 31310 Chihuahua, Chih., MEXICO.</address>
<abstract confidence="0.998384076923077">This paper presents a prototype, not completely operational, that is intended to use c-graphs in the translation of assemblers. Firstly, the formalization of the structure and its principal notions (substructures, classes of substructures, order, etc.) are presented. Next section describes the prototype which is based on a Transformational System as well as on a rewriting system of c-graphs which constitutes the nodes of the Transformational System. The following part discusses a set of operations on the structure. Finally, the implementation in its present state is shown.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="false">
<authors>
<author>REFERENCES</author>
</authors>
<contexts>
<context position="2384" citStr="(5,5,6)" startWordPosition="381" endWordPosition="381">le free,labelled graph [1,9) without isolated nodes and with exactly one entry node and one exit node. It is completely determined by a 7-tuple: G.(A,S,0,1,0,E,c), where A is a set of arcs, S a set of nodes, p a mapping of A into SxS, I the input node, 0 the output node, E a set of labels (c-trees, c-graphs) and c a mapping of A into E. For the sake of simplicity, arcs and labels will be merged in the representation of G (cf. Fig.1). Interesting c-graphs are sequential c-graphs (cf. Fig.2a) and bundles (cf. Fig.2b). A={1,...,12} ; S={1,...,7) ; l={1} ; 0={7} p={(1,1,2),(2,2,4),(3,4,5),(4,5,7),(5,5,6), (6,6,7),(7,6,7),(8,2,3),(9,3,4),(10,3,5), (11,1,2),(12,1,2)) E={a,b,c,d,e,f,g,h,i,j,k} c={(1,a),(2,b),(3,f),(11,g),(5,i),(6,j), (7,k),(8,c),(9,d),(10,e),(11,b),(12,h)} (a) (b) Fig.2. A seq. c-graph (a) and a bundle (b). C-trees. A c-tree or a tree with decorations is an ordered tree, with nodes labelled by a label and a decoration that is itself a decorated tree, possibly empty. Classes of c-qraphs. There are three major classes: (1) recursive c-graphs (cf. Fig.3a) where each arc is labelled by a c-graph; (2) simple c-graphs (cf. Fig.1) where each arc is labelled by a c-tree and (3) regular </context>
</contexts>
<marker>6.</marker>
<rawString>REFERENCES.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ch Boitet</author>
</authors>
<date>1976</date>
<journal>UN ESSAI DE REPONSE A QUELQUES QUESTIONS THEORIQUES ET PRATIQUES LIEES A LA TRADUCTION AUTOMATIQUE. DEFINITION DUN SYSTEME PROTOTYPE. These d&apos;Etat. Grenoble. Avril.</journal>
<contexts>
<context position="1360" citStr="(1,2,11)" startWordPosition="207" endWordPosition="207">y, the implementation in its present state is shown. 1. INTRODUCTION. In the past [10,11], several kinds of representation have been used (strings, labelled trees, trees with &amp;quot;decorations&amp;quot;, graphs of strings and (semantic) networks). C-graphs had its origin as an alternative in the representation and in the treatment of ambiguities in Automatic Translation. In earlier papers (4,5) this structure is named E-graph but c-graph is better suited since it is a generalized &amp;quot;grafo de cadenas&amp;quot; (graph of strings). This structure combines some advantages of the Q-systems ID and of the trees of AR1ANE-78 (1,2,11), in particular, the use of only one structure for all the translation process (as in the former) and foreseeable decidability and parallelism (as in the latter). This paper presents a prototype, not completely operational, that uses c-graphs and is intended to translate assemblers to refine the adequacy of this kind of structure in the translation of natural languages. 2. DEFINITIONS C-graph. A c-graph G is a cycle free,labelled graph [1,9) without isolated nodes and with exactly one entry node and one exit node. It is completely determined by a 7-tuple: G.(A,S,0,1,0,E,c), where A is a set of</context>
<context position="2823" citStr="(1)" startWordPosition="435" endWordPosition="435">esting c-graphs are sequential c-graphs (cf. Fig.2a) and bundles (cf. Fig.2b). A={1,...,12} ; S={1,...,7) ; l={1} ; 0={7} p={(1,1,2),(2,2,4),(3,4,5),(4,5,7),(5,5,6), (6,6,7),(7,6,7),(8,2,3),(9,3,4),(10,3,5), (11,1,2),(12,1,2)) E={a,b,c,d,e,f,g,h,i,j,k} c={(1,a),(2,b),(3,f),(11,g),(5,i),(6,j), (7,k),(8,c),(9,d),(10,e),(11,b),(12,h)} (a) (b) Fig.2. A seq. c-graph (a) and a bundle (b). C-trees. A c-tree or a tree with decorations is an ordered tree, with nodes labelled by a label and a decoration that is itself a decorated tree, possibly empty. Classes of c-qraphs. There are three major classes: (1) recursive c-graphs (cf. Fig.3a) where each arc is labelled by a c-graph; (2) simple c-graphs (cf. Fig.1) where each arc is labelled by a c-tree and (3) regular c-graphs, a proper subclass of the second that is obtained by concatenation and alternation of simple arcs (cf. Fig.3b). By denoting concatenation by &amp;quot;.&amp;quot; and alternation by &amp;quot;+&amp;quot;, we have an evident linear representation. For example, G4=g+i.(j+k). Note that not every c-graph may be obtained by these operations, e.g.G. Substructures. For the sake of homogeneity, the only substructures allowed are those that are themselves c-graphs. They </context>
<context position="4770" citStr="(1)" startWordPosition="804" endWordPosition="804">y. A seg G&apos; of G is normaly isolatable (segmi) if and only if it is a segif and there is a path, not in G&apos;, such that it leaves l&apos; and enters 0&apos;. Example: G6=k is a segmi of G. c) Strong isolatability. A seg G&apos; of G is strongly isolatable (segfi) if and only if the only node that has entering arcs not in G&apos; is I&apos; and the only node that has leaving arcs not in G&apos; is 0&apos;. When G&apos; is not an arc and there is no segfi contained strictly in G&apos;, then G&apos; is an &amp;quot;elementary segfi&amp;quot;; if G contains no segfi, then G.is elementary. E.g. G4 is a segfi of G. Order and roads. Two order relations are considered: (1) a &amp;quot;vertical&amp;quot; order or linear order of the arcs having the same initial node and (2) a &amp;quot;horizontal&amp;quot; order or partial order between two arcs on the same path. A road is a path from I to 0 Vertical order induces a linear order on roads. 3. DEFINITION OF THE PROTOTYPE. The prototype consists of a model and a data structure. The model is essentially a generalization of a Transformational System (TS) analogous to ROBRA EU and whose grammars are rewriting systems of c-graphs (RSC) 0,5,6]. Regarding data structure, we use c•graphst 3.1 A Transformational System. This IS is a c-graph-oc-graph transduc</context>
<context position="8436" citStr="(1)" startWordPosition="1437" endWordPosition="1437">, then g.g1=g and g+gl=g1. Let us analyze the phrase: &amp;quot;Ana lista la tira&amp;quot;. The representation in our formalism is 67. Morphological analysis produces 68. Note that all ambiguities are kept in the same structure in the form of parallel arcs. The application of GR to 68 results in 69, where each arc will be labelled with a c-tree with a possible interpretation of 68 in grammar GR. The sequence of applications is R3, R6, R5, R1, R2, R4. The system stops when.no more rules are applicable. G7= Anao lista la tira 0 listar tirar listo tira ad nm lo pron , where Operations are divided in two classes: (1) those where the structure is taken as a whole (glob al) and (2) those that transform substructures (local). 1. Global Operations. Concatenation and alternation have been defined above. These operations produce sequential c-graphs and bundles respectively, as well as the polynomial writing of regular c-graphs. Expansion. This operation produces a bundle exp(G) from all the roads of a c-graph G. For example, expansion of G1O produces exp(G10)=0).0+ (c.d.f)+(c.e). 610= Fig.6. Expansion of a c-graph. Factorization. There are two kinds and their results may differ. Consider C11=a.b+a.c+d.e+d.f+ g.</context>
<context position="10368" citStr="(1,0)" startWordPosition="1731" endWordPosition="1731">RA(NP(Ana), PRED(VB(listar, GN(ART(e1), NM(tira)))) Fig.5. Example of sentence analysis. 3.3 Operations. A. y(o(y(a),y(b),y(b)),a(y(b,f),y(c,d,f), Y(c,e)),0(9,Y(i,0(j,k))) Fig.7. Arborization of G. 2. Local Operations. Replacement. Given two c-graphs G and G&amp;quot;,this operation substitutes a seg G&apos; in G for G&amp;quot;, e.g. if 6=64, G&amp;quot;=m+n and G&apos;.i, then the result will be 63 G15=g+(m+n):(j+k). Addition. This operation inserts a c-graph G&apos; into another, G, by merging two distinct nodes (x, y) of G with the input and output of G&apos;. Addition requires only that insertion does not produce cycles. Note that if (1,0) are taken as a couple of nodes, we have alternation. Example, let (2,3) be a couple of nodes of G16 and take G&apos;=G17=s+u. The resulting c-graph is G18. G16 Fig.8. Addition of a c-graph. Erasing. This eliminates a substructure G&apos; of a c-graph G. Erasing may destroy the structure even if we work with isolated seg&apos;s. Consequently, it is only defined on particular classes of seg&apos;s, namely segfi&apos;s and segmi&apos;s. For any other substructure, we eliminate the smaller segmi that contains it. A special case constitutes a segfi G&apos; such that I and 0 do not belong to G&apos;. Eliminating G&apos; in such a case produce</context>
</contexts>
<marker>1.</marker>
<rawString>[1] Boitet, Ch. UN ESSAI DE REPONSE A QUELQUES QUESTIONS THEORIQUES ET PRATIQUES LIEES A LA TRADUCTION AUTOMATIQUE. DEFINITION DUN SYSTEME PROTOTYPE. These d&apos;Etat. Grenoble. Avril. 1976.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ch Boitet</author>
</authors>
<title>de recherche de l&apos;Institut de Mathematiques Appliquees N°218.</title>
<date>1979</date>
<journal>AUTOMATIC PRODUCTION OF CF AND CS ANALYSERS USING A GENERAL TREE TRANSDUCER. Rapport</journal>
<location>Grenoble. Novembre.</location>
<contexts>
<context position="1360" citStr="(1,2,11)" startWordPosition="207" endWordPosition="207">y, the implementation in its present state is shown. 1. INTRODUCTION. In the past [10,11], several kinds of representation have been used (strings, labelled trees, trees with &amp;quot;decorations&amp;quot;, graphs of strings and (semantic) networks). C-graphs had its origin as an alternative in the representation and in the treatment of ambiguities in Automatic Translation. In earlier papers (4,5) this structure is named E-graph but c-graph is better suited since it is a generalized &amp;quot;grafo de cadenas&amp;quot; (graph of strings). This structure combines some advantages of the Q-systems ID and of the trees of AR1ANE-78 (1,2,11), in particular, the use of only one structure for all the translation process (as in the former) and foreseeable decidability and parallelism (as in the latter). This paper presents a prototype, not completely operational, that uses c-graphs and is intended to translate assemblers to refine the adequacy of this kind of structure in the translation of natural languages. 2. DEFINITIONS C-graph. A c-graph G is a cycle free,labelled graph [1,9) without isolated nodes and with exactly one entry node and one exit node. It is completely determined by a 7-tuple: G.(A,S,0,1,0,E,c), where A is a set of</context>
<context position="2900" citStr="(2)" startWordPosition="448" endWordPosition="448">. A={1,...,12} ; S={1,...,7) ; l={1} ; 0={7} p={(1,1,2),(2,2,4),(3,4,5),(4,5,7),(5,5,6), (6,6,7),(7,6,7),(8,2,3),(9,3,4),(10,3,5), (11,1,2),(12,1,2)) E={a,b,c,d,e,f,g,h,i,j,k} c={(1,a),(2,b),(3,f),(11,g),(5,i),(6,j), (7,k),(8,c),(9,d),(10,e),(11,b),(12,h)} (a) (b) Fig.2. A seq. c-graph (a) and a bundle (b). C-trees. A c-tree or a tree with decorations is an ordered tree, with nodes labelled by a label and a decoration that is itself a decorated tree, possibly empty. Classes of c-qraphs. There are three major classes: (1) recursive c-graphs (cf. Fig.3a) where each arc is labelled by a c-graph; (2) simple c-graphs (cf. Fig.1) where each arc is labelled by a c-tree and (3) regular c-graphs, a proper subclass of the second that is obtained by concatenation and alternation of simple arcs (cf. Fig.3b). By denoting concatenation by &amp;quot;.&amp;quot; and alternation by &amp;quot;+&amp;quot;, we have an evident linear representation. For example, G4=g+i.(j+k). Note that not every c-graph may be obtained by these operations, e.g.G. Substructures. For the sake of homogeneity, the only substructures allowed are those that are themselves c-graphs. They will be called subFig.l. A c-graph. Gl= -o G2= 61 -c-graphs or seg&apos;s. For exa</context>
<context position="4854" citStr="(2)" startWordPosition="820" endWordPosition="820">e is a path, not in G&apos;, such that it leaves l&apos; and enters 0&apos;. Example: G6=k is a segmi of G. c) Strong isolatability. A seg G&apos; of G is strongly isolatable (segfi) if and only if the only node that has entering arcs not in G&apos; is I&apos; and the only node that has leaving arcs not in G&apos; is 0&apos;. When G&apos; is not an arc and there is no segfi contained strictly in G&apos;, then G&apos; is an &amp;quot;elementary segfi&amp;quot;; if G contains no segfi, then G.is elementary. E.g. G4 is a segfi of G. Order and roads. Two order relations are considered: (1) a &amp;quot;vertical&amp;quot; order or linear order of the arcs having the same initial node and (2) a &amp;quot;horizontal&amp;quot; order or partial order between two arcs on the same path. A road is a path from I to 0 Vertical order induces a linear order on roads. 3. DEFINITION OF THE PROTOTYPE. The prototype consists of a model and a data structure. The model is essentially a generalization of a Transformational System (TS) analogous to ROBRA EU and whose grammars are rewriting systems of c-graphs (RSC) 0,5,6]. Regarding data structure, we use c•graphst 3.1 A Transformational System. This IS is a c-graph-oc-graph transducer. It is a &amp;quot;control&amp;quot; graph whose nodes are RSC and the arcs are labelled by conditi</context>
<context position="8500" citStr="(2)" startWordPosition="1450" endWordPosition="1450"> la tira&amp;quot;. The representation in our formalism is 67. Morphological analysis produces 68. Note that all ambiguities are kept in the same structure in the form of parallel arcs. The application of GR to 68 results in 69, where each arc will be labelled with a c-tree with a possible interpretation of 68 in grammar GR. The sequence of applications is R3, R6, R5, R1, R2, R4. The system stops when.no more rules are applicable. G7= Anao lista la tira 0 listar tirar listo tira ad nm lo pron , where Operations are divided in two classes: (1) those where the structure is taken as a whole (glob al) and (2) those that transform substructures (local). 1. Global Operations. Concatenation and alternation have been defined above. These operations produce sequential c-graphs and bundles respectively, as well as the polynomial writing of regular c-graphs. Expansion. This operation produces a bundle exp(G) from all the roads of a c-graph G. For example, expansion of G1O produces exp(G10)=0).0+ (c.d.f)+(c.e). 610= Fig.6. Expansion of a c-graph. Factorization. There are two kinds and their results may differ. Consider C11=a.b+a.c+d.e+d.f+ g.f+h.e. Left factorization produces G12=a.(b+c)+ d.(e+f)+g.f+h.e,</context>
<context position="10440" citStr="(2,3)" startWordPosition="1744" endWordPosition="1744">ntence analysis. 3.3 Operations. A. y(o(y(a),y(b),y(b)),a(y(b,f),y(c,d,f), Y(c,e)),0(9,Y(i,0(j,k))) Fig.7. Arborization of G. 2. Local Operations. Replacement. Given two c-graphs G and G&amp;quot;,this operation substitutes a seg G&apos; in G for G&amp;quot;, e.g. if 6=64, G&amp;quot;=m+n and G&apos;.i, then the result will be 63 G15=g+(m+n):(j+k). Addition. This operation inserts a c-graph G&apos; into another, G, by merging two distinct nodes (x, y) of G with the input and output of G&apos;. Addition requires only that insertion does not produce cycles. Note that if (1,0) are taken as a couple of nodes, we have alternation. Example, let (2,3) be a couple of nodes of G16 and take G&apos;=G17=s+u. The resulting c-graph is G18. G16 Fig.8. Addition of a c-graph. Erasing. This eliminates a substructure G&apos; of a c-graph G. Erasing may destroy the structure even if we work with isolated seg&apos;s. Consequently, it is only defined on particular classes of seg&apos;s, namely segfi&apos;s and segmi&apos;s. For any other substructure, we eliminate the smaller segmi that contains it. A special case constitutes a segfi G&apos; such that I and 0 do not belong to G&apos;. Eliminating G&apos; in such a case produces two non-connecting nodes in the c-graph that we have chosen to merge t</context>
</contexts>
<marker>2.</marker>
<rawString>121 Boitet, Ch. AUTOMATIC PRODUCTION OF CF AND CS ANALYSERS USING A GENERAL TREE TRANSDUCER. Rapport de recherche de l&apos;Institut de Mathematiques Appliquees N°218. Grenoble. Novembre. 1979.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Clemente-Salazar</author>
</authors>
<date>1982</date>
<booktitle>ETUDES ET ALGORITHMES LIES A UNE NOUVELLE STRUCTURE DE DONNEES EN T.A.: LES E-GRAPHES. These Dr-Ing.</booktitle>
<location>Grenoble. Mai.</location>
<contexts>
<context position="2368" citStr="(3,4,5)" startWordPosition="381" endWordPosition="381">graph G is a cycle free,labelled graph [1,9) without isolated nodes and with exactly one entry node and one exit node. It is completely determined by a 7-tuple: G.(A,S,0,1,0,E,c), where A is a set of arcs, S a set of nodes, p a mapping of A into SxS, I the input node, 0 the output node, E a set of labels (c-trees, c-graphs) and c a mapping of A into E. For the sake of simplicity, arcs and labels will be merged in the representation of G (cf. Fig.1). Interesting c-graphs are sequential c-graphs (cf. Fig.2a) and bundles (cf. Fig.2b). A={1,...,12} ; S={1,...,7) ; l={1} ; 0={7} p={(1,1,2),(2,2,4),(3,4,5),(4,5,7),(5,5,6), (6,6,7),(7,6,7),(8,2,3),(9,3,4),(10,3,5), (11,1,2),(12,1,2)) E={a,b,c,d,e,f,g,h,i,j,k} c={(1,a),(2,b),(3,f),(11,g),(5,i),(6,j), (7,k),(8,c),(9,d),(10,e),(11,b),(12,h)} (a) (b) Fig.2. A seq. c-graph (a) and a bundle (b). C-trees. A c-tree or a tree with decorations is an ordered tree, with nodes labelled by a label and a decoration that is itself a decorated tree, possibly empty. Classes of c-qraphs. There are three major classes: (1) recursive c-graphs (cf. Fig.3a) where each arc is labelled by a c-graph; (2) simple c-graphs (cf. Fig.1) where each arc is labelled by a c-tree </context>
<context position="5609" citStr="(3)" startWordPosition="956" endWordPosition="956">. DEFINITION OF THE PROTOTYPE. The prototype consists of a model and a data structure. The model is essentially a generalization of a Transformational System (TS) analogous to ROBRA EU and whose grammars are rewriting systems of c-graphs (RSC) 0,5,6]. Regarding data structure, we use c•graphst 3.1 A Transformational System. This IS is a c-graph-oc-graph transducer. It is a &amp;quot;control&amp;quot; graph whose nodes are RSC and the arcs are labelled by conditions. &apos; A IS is a cycle free oriented graph, with only one input and such that, (1) Each node is labelled with a RSC or &amp;nul. (2) &amp;nul has no successor. (3) Each grammar of the RSC has a transition scheme S or c (empty scheme). (4) Arcs of the same initial node are ordered. T5 works heuristically. Given a c-graph go as an input, it searches for the first path ending in &amp;nul. This fact implies that all of the transition schemes on the path were satisfied. Any scheme not satisfied provokes a search of a new path. For example, if Si is satisfied, IS produces Gl(gn)=g1 and it proceeds to calculate G2(G1(90))=g2. If 54 is satisfied the system stops and produces g2. Otherwise, it backtracks to GI and tests S2. If it is satisfied gl is produced. Otherwi</context>
<context position="10440" citStr="(2,3)" startWordPosition="1744" endWordPosition="1744">ntence analysis. 3.3 Operations. A. y(o(y(a),y(b),y(b)),a(y(b,f),y(c,d,f), Y(c,e)),0(9,Y(i,0(j,k))) Fig.7. Arborization of G. 2. Local Operations. Replacement. Given two c-graphs G and G&amp;quot;,this operation substitutes a seg G&apos; in G for G&amp;quot;, e.g. if 6=64, G&amp;quot;=m+n and G&apos;.i, then the result will be 63 G15=g+(m+n):(j+k). Addition. This operation inserts a c-graph G&apos; into another, G, by merging two distinct nodes (x, y) of G with the input and output of G&apos;. Addition requires only that insertion does not produce cycles. Note that if (1,0) are taken as a couple of nodes, we have alternation. Example, let (2,3) be a couple of nodes of G16 and take G&apos;=G17=s+u. The resulting c-graph is G18. G16 Fig.8. Addition of a c-graph. Erasing. This eliminates a substructure G&apos; of a c-graph G. Erasing may destroy the structure even if we work with isolated seg&apos;s. Consequently, it is only defined on particular classes of seg&apos;s, namely segfi&apos;s and segmi&apos;s. For any other substructure, we eliminate the smaller segmi that contains it. A special case constitutes a segfi G&apos; such that I and 0 do not belong to G&apos;. Eliminating G&apos; in such a case produces two non-connecting nodes in the c-graph that we have chosen to merge t</context>
</contexts>
<marker>3.</marker>
<rawString>14] Clemente-Salazar, M. ETUDES ET ALGORITHMES LIES A UNE NOUVELLE STRUCTURE DE DONNEES EN T.A.: LES E-GRAPHES. These Dr-Ing. Grenoble. Mai. 1982.</rawString>
</citation>
<citation valid="false">
<authors>
<author>M Clemente-Salazar</author>
</authors>
<journal>E-GRAPHS: AN INTERESTING DATA STRUCTURE FOR</journal>
<note>M.T. Paper presented in COLING-</note>
<contexts>
<context position="1135" citStr="(4,5)" startWordPosition="170" endWordPosition="170">which is based on a Transformational System as well as on a rewriting system of c-graphs which constitutes the nodes of the Transformational System. The following part discusses a set of operations on the structure. Finally, the implementation in its present state is shown. 1. INTRODUCTION. In the past [10,11], several kinds of representation have been used (strings, labelled trees, trees with &amp;quot;decorations&amp;quot;, graphs of strings and (semantic) networks). C-graphs had its origin as an alternative in the representation and in the treatment of ambiguities in Automatic Translation. In earlier papers (4,5) this structure is named E-graph but c-graph is better suited since it is a generalized &amp;quot;grafo de cadenas&amp;quot; (graph of strings). This structure combines some advantages of the Q-systems ID and of the trees of AR1ANE-78 (1,2,11), in particular, the use of only one structure for all the translation process (as in the former) and foreseeable decidability and parallelism (as in the latter). This paper presents a prototype, not completely operational, that uses c-graphs and is intended to translate assemblers to refine the adequacy of this kind of structure in the translation of natural languages. 2.</context>
<context position="2360" citStr="(2,2,4)" startWordPosition="381" endWordPosition="381">ph. A c-graph G is a cycle free,labelled graph [1,9) without isolated nodes and with exactly one entry node and one exit node. It is completely determined by a 7-tuple: G.(A,S,0,1,0,E,c), where A is a set of arcs, S a set of nodes, p a mapping of A into SxS, I the input node, 0 the output node, E a set of labels (c-trees, c-graphs) and c a mapping of A into E. For the sake of simplicity, arcs and labels will be merged in the representation of G (cf. Fig.1). Interesting c-graphs are sequential c-graphs (cf. Fig.2a) and bundles (cf. Fig.2b). A={1,...,12} ; S={1,...,7) ; l={1} ; 0={7} p={(1,1,2),(2,2,4),(3,4,5),(4,5,7),(5,5,6), (6,6,7),(7,6,7),(8,2,3),(9,3,4),(10,3,5), (11,1,2),(12,1,2)) E={a,b,c,d,e,f,g,h,i,j,k} c={(1,a),(2,b),(3,f),(11,g),(5,i),(6,j), (7,k),(8,c),(9,d),(10,e),(11,b),(12,h)} (a) (b) Fig.2. A seq. c-graph (a) and a bundle (b). C-trees. A c-tree or a tree with decorations is an ordered tree, with nodes labelled by a label and a decoration that is itself a decorated tree, possibly empty. Classes of c-qraphs. There are three major classes: (1) recursive c-graphs (cf. Fig.3a) where each arc is labelled by a c-graph; (2) simple c-graphs (cf. Fig.1) where each arc is labelled by a</context>
<context position="5684" citStr="(4)" startWordPosition="971" endWordPosition="971"> structure. The model is essentially a generalization of a Transformational System (TS) analogous to ROBRA EU and whose grammars are rewriting systems of c-graphs (RSC) 0,5,6]. Regarding data structure, we use c•graphst 3.1 A Transformational System. This IS is a c-graph-oc-graph transducer. It is a &amp;quot;control&amp;quot; graph whose nodes are RSC and the arcs are labelled by conditions. &apos; A IS is a cycle free oriented graph, with only one input and such that, (1) Each node is labelled with a RSC or &amp;nul. (2) &amp;nul has no successor. (3) Each grammar of the RSC has a transition scheme S or c (empty scheme). (4) Arcs of the same initial node are ordered. T5 works heuristically. Given a c-graph go as an input, it searches for the first path ending in &amp;nul. This fact implies that all of the transition schemes on the path were satisfied. Any scheme not satisfied provokes a search of a new path. For example, if Si is satisfied, IS produces Gl(gn)=g1 and it proceeds to calculate G2(G1(90))=g2. If 54 is satisfied the system stops and produces g2. Otherwise, it backtracks to GI and tests S2. If it is satisfied gl is produced. Otherwise, it tests 53&apos; etc. Fig.4. A Transformational System. 3.2 A REWRITING SYS</context>
</contexts>
<marker>4.</marker>
<rawString>151 Clemente-Salazar, M. E-GRAPHS: AN INTERESTING DATA STRUCTURE FOR M.T. Paper presented in COLING-</rawString>
</citation>
<citation valid="true">
<authors>
<author>Prague</author>
</authors>
<date>1982</date>
<marker>82.</marker>
<rawString>Prague. July. 1982.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Clemente-Salazar</author>
</authors>
<title>C-GRAPHS: A DATA STRUCTURE FOR AUTOMATED TRANSLATION.</title>
<date>1983</date>
<booktitle>Paper presented in the 26th International Midwest Symposium on Circuits and Systems.</booktitle>
<location>Puebla. Mexico.</location>
<contexts>
<context position="1135" citStr="(4,5)" startWordPosition="170" endWordPosition="170">which is based on a Transformational System as well as on a rewriting system of c-graphs which constitutes the nodes of the Transformational System. The following part discusses a set of operations on the structure. Finally, the implementation in its present state is shown. 1. INTRODUCTION. In the past [10,11], several kinds of representation have been used (strings, labelled trees, trees with &amp;quot;decorations&amp;quot;, graphs of strings and (semantic) networks). C-graphs had its origin as an alternative in the representation and in the treatment of ambiguities in Automatic Translation. In earlier papers (4,5) this structure is named E-graph but c-graph is better suited since it is a generalized &amp;quot;grafo de cadenas&amp;quot; (graph of strings). This structure combines some advantages of the Q-systems ID and of the trees of AR1ANE-78 (1,2,11), in particular, the use of only one structure for all the translation process (as in the former) and foreseeable decidability and parallelism (as in the latter). This paper presents a prototype, not completely operational, that uses c-graphs and is intended to translate assemblers to refine the adequacy of this kind of structure in the translation of natural languages. 2.</context>
<context position="2368" citStr="(3,4,5)" startWordPosition="381" endWordPosition="381">graph G is a cycle free,labelled graph [1,9) without isolated nodes and with exactly one entry node and one exit node. It is completely determined by a 7-tuple: G.(A,S,0,1,0,E,c), where A is a set of arcs, S a set of nodes, p a mapping of A into SxS, I the input node, 0 the output node, E a set of labels (c-trees, c-graphs) and c a mapping of A into E. For the sake of simplicity, arcs and labels will be merged in the representation of G (cf. Fig.1). Interesting c-graphs are sequential c-graphs (cf. Fig.2a) and bundles (cf. Fig.2b). A={1,...,12} ; S={1,...,7) ; l={1} ; 0={7} p={(1,1,2),(2,2,4),(3,4,5),(4,5,7),(5,5,6), (6,6,7),(7,6,7),(8,2,3),(9,3,4),(10,3,5), (11,1,2),(12,1,2)) E={a,b,c,d,e,f,g,h,i,j,k} c={(1,a),(2,b),(3,f),(11,g),(5,i),(6,j), (7,k),(8,c),(9,d),(10,e),(11,b),(12,h)} (a) (b) Fig.2. A seq. c-graph (a) and a bundle (b). C-trees. A c-tree or a tree with decorations is an ordered tree, with nodes labelled by a label and a decoration that is itself a decorated tree, possibly empty. Classes of c-qraphs. There are three major classes: (1) recursive c-graphs (cf. Fig.3a) where each arc is labelled by a c-graph; (2) simple c-graphs (cf. Fig.1) where each arc is labelled by a c-tree </context>
</contexts>
<marker>5.</marker>
<rawString>[6] Clemente-Salazar, M. C-GRAPHS: A DATA STRUCTURE FOR AUTOMATED TRANSLATION. Paper presented in the 26th International Midwest Symposium on Circuits and Systems. Puebla. Mexico. August. 1983.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A LES SYSTEMES-Q Colmerauer</author>
</authors>
<date>1970</date>
<booktitle>Universitg de Montreal.Publication Interne N°43. Septembre.</booktitle>
<contexts>
<context position="2384" citStr="(5,5,6)" startWordPosition="381" endWordPosition="381">le free,labelled graph [1,9) without isolated nodes and with exactly one entry node and one exit node. It is completely determined by a 7-tuple: G.(A,S,0,1,0,E,c), where A is a set of arcs, S a set of nodes, p a mapping of A into SxS, I the input node, 0 the output node, E a set of labels (c-trees, c-graphs) and c a mapping of A into E. For the sake of simplicity, arcs and labels will be merged in the representation of G (cf. Fig.1). Interesting c-graphs are sequential c-graphs (cf. Fig.2a) and bundles (cf. Fig.2b). A={1,...,12} ; S={1,...,7) ; l={1} ; 0={7} p={(1,1,2),(2,2,4),(3,4,5),(4,5,7),(5,5,6), (6,6,7),(7,6,7),(8,2,3),(9,3,4),(10,3,5), (11,1,2),(12,1,2)) E={a,b,c,d,e,f,g,h,i,j,k} c={(1,a),(2,b),(3,f),(11,g),(5,i),(6,j), (7,k),(8,c),(9,d),(10,e),(11,b),(12,h)} (a) (b) Fig.2. A seq. c-graph (a) and a bundle (b). C-trees. A c-tree or a tree with decorations is an ordered tree, with nodes labelled by a label and a decoration that is itself a decorated tree, possibly empty. Classes of c-qraphs. There are three major classes: (1) recursive c-graphs (cf. Fig.3a) where each arc is labelled by a c-graph; (2) simple c-graphs (cf. Fig.1) where each arc is labelled by a c-tree and (3) regular </context>
</contexts>
<marker>6.</marker>
<rawString>[7] Colmerauer, A. LES SYSTEMES-Q. Universitg de Montreal.Publication Interne N°43. Septembre. 1970.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Paris</author>
</authors>
<date>1972</date>
<contexts>
<context position="2376" citStr="(4,5,7)" startWordPosition="381" endWordPosition="381">is a cycle free,labelled graph [1,9) without isolated nodes and with exactly one entry node and one exit node. It is completely determined by a 7-tuple: G.(A,S,0,1,0,E,c), where A is a set of arcs, S a set of nodes, p a mapping of A into SxS, I the input node, 0 the output node, E a set of labels (c-trees, c-graphs) and c a mapping of A into E. For the sake of simplicity, arcs and labels will be merged in the representation of G (cf. Fig.1). Interesting c-graphs are sequential c-graphs (cf. Fig.2a) and bundles (cf. Fig.2b). A={1,...,12} ; S={1,...,7) ; l={1} ; 0={7} p={(1,1,2),(2,2,4),(3,4,5),(4,5,7),(5,5,6), (6,6,7),(7,6,7),(8,2,3),(9,3,4),(10,3,5), (11,1,2),(12,1,2)) E={a,b,c,d,e,f,g,h,i,j,k} c={(1,a),(2,b),(3,f),(11,g),(5,i),(6,j), (7,k),(8,c),(9,d),(10,e),(11,b),(12,h)} (a) (b) Fig.2. A seq. c-graph (a) and a bundle (b). C-trees. A c-tree or a tree with decorations is an ordered tree, with nodes labelled by a label and a decoration that is itself a decorated tree, possibly empty. Classes of c-qraphs. There are three major classes: (1) recursive c-graphs (cf. Fig.3a) where each arc is labelled by a c-graph; (2) simple c-graphs (cf. Fig.1) where each arc is labelled by a c-tree and (3) </context>
</contexts>
<marker>7.</marker>
<rawString>19] Kuntzmann, J. THEORIE DES RESEAUX (GRAPHES). Dunod. Paris. 1972.</rawString>
</citation>
<citation valid="true">
<authors>
<author>B Vauquois</author>
</authors>
<title>LA TRADUCTION AUTOMATIQUE A GRENOBLE.</title>
<date>1975</date>
<booktitle>Document de Linguistique Quantitative N°24. Dunod.</booktitle>
<location>Paris.</location>
<contexts>
<context position="2409" citStr="(8,2,3)" startWordPosition="382" endWordPosition="382">,9) without isolated nodes and with exactly one entry node and one exit node. It is completely determined by a 7-tuple: G.(A,S,0,1,0,E,c), where A is a set of arcs, S a set of nodes, p a mapping of A into SxS, I the input node, 0 the output node, E a set of labels (c-trees, c-graphs) and c a mapping of A into E. For the sake of simplicity, arcs and labels will be merged in the representation of G (cf. Fig.1). Interesting c-graphs are sequential c-graphs (cf. Fig.2a) and bundles (cf. Fig.2b). A={1,...,12} ; S={1,...,7) ; l={1} ; 0={7} p={(1,1,2),(2,2,4),(3,4,5),(4,5,7),(5,5,6), (6,6,7),(7,6,7),(8,2,3),(9,3,4),(10,3,5), (11,1,2),(12,1,2)) E={a,b,c,d,e,f,g,h,i,j,k} c={(1,a),(2,b),(3,f),(11,g),(5,i),(6,j), (7,k),(8,c),(9,d),(10,e),(11,b),(12,h)} (a) (b) Fig.2. A seq. c-graph (a) and a bundle (b). C-trees. A c-tree or a tree with decorations is an ordered tree, with nodes labelled by a label and a decoration that is itself a decorated tree, possibly empty. Classes of c-qraphs. There are three major classes: (1) recursive c-graphs (cf. Fig.3a) where each arc is labelled by a c-graph; (2) simple c-graphs (cf. Fig.1) where each arc is labelled by a c-tree and (3) regular c-graphs, a proper subcla</context>
</contexts>
<marker>8.</marker>
<rawString>r10] Vauquois, B. LA TRADUCTION AUTOMATIQUE A GRENOBLE. Document de Linguistique Quantitative N°24. Dunod. Paris. 1975.</rawString>
</citation>
<citation valid="true">
<date>1979</date>
<booktitle>ASPECTS OF MECHANICAL TRANSLATION IN 1979. Conference for Japan IBM Scientific Program. Document du Groupe d&apos;Etudes pour la Traduction Automatique.</booktitle>
<location>Grenoble.</location>
<note>G18.</note>
<contexts>
<context position="2417" citStr="(9,3,4)" startWordPosition="382" endWordPosition="382">out isolated nodes and with exactly one entry node and one exit node. It is completely determined by a 7-tuple: G.(A,S,0,1,0,E,c), where A is a set of arcs, S a set of nodes, p a mapping of A into SxS, I the input node, 0 the output node, E a set of labels (c-trees, c-graphs) and c a mapping of A into E. For the sake of simplicity, arcs and labels will be merged in the representation of G (cf. Fig.1). Interesting c-graphs are sequential c-graphs (cf. Fig.2a) and bundles (cf. Fig.2b). A={1,...,12} ; S={1,...,7) ; l={1} ; 0={7} p={(1,1,2),(2,2,4),(3,4,5),(4,5,7),(5,5,6), (6,6,7),(7,6,7),(8,2,3),(9,3,4),(10,3,5), (11,1,2),(12,1,2)) E={a,b,c,d,e,f,g,h,i,j,k} c={(1,a),(2,b),(3,f),(11,g),(5,i),(6,j), (7,k),(8,c),(9,d),(10,e),(11,b),(12,h)} (a) (b) Fig.2. A seq. c-graph (a) and a bundle (b). C-trees. A c-tree or a tree with decorations is an ordered tree, with nodes labelled by a label and a decoration that is itself a decorated tree, possibly empty. Classes of c-qraphs. There are three major classes: (1) recursive c-graphs (cf. Fig.3a) where each arc is labelled by a c-graph; (2) simple c-graphs (cf. Fig.1) where each arc is labelled by a c-tree and (3) regular c-graphs, a proper subclass of th</context>
</contexts>
<marker>9.</marker>
<rawString>[113 Vauquois, B. ASPECTS OF MECHANICAL TRANSLATION IN 1979. Conference for Japan IBM Scientific Program. Document du Groupe d&apos;Etudes pour la Traduction Automatique. Grenoble. July. 1979. ************ G18.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>