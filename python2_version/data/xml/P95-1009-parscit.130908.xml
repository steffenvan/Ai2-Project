<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000004">
<title confidence="0.995057">
User-Defined Nonmonotonicity in Unification-Based Formalisms
</title>
<author confidence="0.99582">
Lena Stromback
</author>
<affiliation confidence="0.9929965">
Department of Computer and Information Science
Linkoping University
</affiliation>
<address confidence="0.92391">
S-58185 LinkOping, Sweden
</address>
<email confidence="0.83018">
lestrOida.liu.se
</email>
<sectionHeader confidence="0.994695" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.998948727272727">
A common feature of recent unification-
based grammar formalisms is that they
give the user the ability to define his own
structures. However, this possibility is
mostly limited and does not include non-
monotonic operations. In this paper we
show how nonmonotonic operations can
also be user-defined by applying default lo-
gic (Reiter, 1980) and generalizing previous
results on nonmonotonic sorts (Young and
Rounds, 1993).
</bodyText>
<sectionHeader confidence="0.993458" genericHeader="keywords">
1 Background
</sectionHeader>
<bodyText confidence="0.999984333333334">
Most of the more recent unification-based forma-
lisms, such as TFS (Emele and Zajac, 1990), UD
(Johnson and Rosner, 1989), CUF (Dorre and Eisele,
1991), and FLUF (Stromback, 1994), provide some
possibility for the user to define constructions of his
own. This possibility can be more or less power-
ful in different formalisms. There are, however, se-
veral constructions proposed as desirable extensions
to unification grammars that cannot be defined in
a general and well-defined way in these formalisms.
One such class of constructions is those that have
some degree of nonmonotonic behaviour. Examples
of such constructions are any-values, default-values,
and some constructions (e.g. constraining equations,
completeness and coherence) used in LFG (Kaplan
and Bresnan, 1983).
This paper describes a method that permits the
user to define such nonmonotonic constructions.
This is done through generalizing the work on non-
monotonic sorts (Young and Rounds, 1993). This
generalization results in a default logic similar to
(Reiter, 1980), but where subsumption and unifica-
tion are used instead of logical truth and consistency.
There are three main advantages to Young and
Rounds&apos; work compared with other approaches to
default unification (Houma, 1990; Bouma, 1992;
Russel et al., 1992) which justify choosing it as a
starting point for this work. The first is the se-
paration of definite and default information, where
Young and Rounds are more distinct than the
other. The second is that the nonmonotonic uni-
fication operation used is order independent. This
is achieved by separating the unification operation
from computing the nonmonotonic extension, which
Young and Rounds call explanation. This suggests
that all the user needs to define when generalizing
the approach is how a sort is explained. Finally,
there is a close relationship to Reiter&apos;s (1980) de-
fault logic.
This paper starts by providing the minimal pro-
perties required of a unification-based formalism
when extending with nonmonotonic definitions. I
then describe the approach of user-defined nonmo-
notonicity and illustrate how some commonly used
nonmonotonic constructions can be defined within
it. Finally I conclude with a discussion of the re-
lation to Reiter&apos;s default logic and computational
properties of the approach.
</bodyText>
<sectionHeader confidence="0.997126" genericHeader="introduction">
2 Preliminaries
</sectionHeader>
<bodyText confidence="0.999893272727273">
There are two main properties that will be assumed
of a unification-based formalism in order to extend
it with the possibility of defining nonmonotonic con-
structions. The first, and most important, is that
we require a subsumption order on the set S of ob-
jects denoted by the formalism. Secondly it should
be possible to define inheritance hierarchies on the
linguistic knowledge described by the formalism.
One very plausible subsumption order that can be
used is the ordinary subsumption lattice of feature
structures. It is, however, possible to use some other
kind of subsumption order if that is more suitable for
the domain to be modelled by the formalism. Ex-
amples of other subsumption orders that might be
useful are typed feature structures, feature structu-
res extended with disjunction, or simply an order
based on sets and set inclusion.
In this paper the notation a C b is used whene-
ver a subsumes b (i.e. whenever a &amp;quot;is more specific
than&amp;quot; or &amp;quot;contains more information than&amp;quot; b). Con-
sequently, a c b is used whenever a C b but a 0 b.
The subsumption order is assumed to be a semi-
</bodyText>
<page confidence="0.999002">
63
</page>
<bodyText confidence="0.998715846153846">
lattice and permits computing a unifier, denoted
a 17 b, corresponding to the greatest lower bound,
for every pair of elements within it. The element
corresponding to the bottom of the order relation is
denoted fail and represents inconsistent information
or unification failure.
The second constraint placed on the formalism,
the possibility of defining an inheritance hierarchy,
is not essential for the definition of nonmonotonic
operations. It is, however, very useful when de-
fining nonmonotonic constructions. The following
notation will be used for describing an inheritance
hierarchy.
</bodyText>
<subsectionHeader confidence="0.903399333333333">
class the name of the class;
isa its parent in the hierarchy;
requires a structure.
</subsectionHeader>
<bodyText confidence="0.999940133333334">
Thus, each member in the inheritance hierarchy is
called a class, which is defined by giving it a name
and a parent in the hierarchy. It is also possible to
define some constraints, called requirements, which
must hold for a class. These requirements can be
both structures in the subsumption order and non-
monotonic rules. The constraints on classes are inhe-
rited through the hierarchy. Every object in a class is
assumed to contain at least the information given by
the constraints specified for it and all its ancestors.
For simplicity multiple inheritance between classes
will not be allowed. This means that two classes
where none of them is a subclass of the other, will
always be considered inconsistent and thus yield a
failure when unified.
</bodyText>
<sectionHeader confidence="0.996783" genericHeader="method">
3 User-Defined Nonmonotonicity
</sectionHeader>
<bodyText confidence="0.99650905">
I will now describe how the work by Young and
Rounds can be generalized to allow the user to de-
fine nonmonotonic constructions. The main idea in
their approach is that each node in a feature struc-
ture consists of a nonmonotonic sort. Such sorts can
contain two different kinds of information, the ordi-
nary monotonic information and a set of defaults. If
we assume that # is defined as a default in Young
and Rounds&apos; work then it is interpreted according to
the rule: if it is consistent to believe # then believe
0. In Reiter&apos;s default logic this is expressed with the
following normal default rule.
:
In this paper I want to allow the user to use other
forms of nonmonotonic inferences and not only the
normal default rule given above. Therefore, I will
consider the general form of default rules. An in-
tuitive reading of a general default rule is, if a is
believed and it is consistent to believe # then be-
lieve -T. In default logic this is usually expressed as
</bodyText>
<equation confidence="0.875629">
a : #
</equation>
<bodyText confidence="0.999945142857143">
The next question is how such defined nonmonoto-
nic rules are going to be interpreted in a unification
framework. In (Reiter, 1980), a rule like the one
above could be applied whenever a is true and )3
is consistent with the information we already have.
If we assume that V represents the information al-
ready given this means that the default rule can be
applied whenever V C a and V fl )3 does not yield
unification failure. When the rule is applied the new
information obtained would be v n -y.
In the approach described in this paper, the user is
allowed to define the actual nonmonotonic rule that
should be used for a particular operation by using
the following syntax.
</bodyText>
<equation confidence="0.685981666666667">
nonmon
name(parameteri,...parametera): when
a :# =&gt; 7
</equation>
<bodyText confidence="0.999947184210526">
In the syntax given above name assigns a name
to the defined rule, and thus allows the user to
use nonmonotonic information when defining lin-
guistic knowledge. The parameters in the rule de-
finition are variables, which can be used within
the actual default rule at the end of the descrip-
tion. The user is assumed to assign the nonmonoto-
nic information contained in this rule to his lingui-
stic knowledge by using an expression of the form
name(parameteri, ...parametern).
The when slot in the rule allows the user to decide
when the rule is going to be applied, or in Young
and Rounds&apos; terminology, explained. I will make
use of two values for the when-slot, imrnediaie and
posterior. Immediate means that the nonmonotonic
rule is going to be applied each time a full unifi-
cation task has been solved or whenever all infor-
mation about an object in the defined inheritance
hierarchy has been retrieved. Posterior explanation
means that the explanation of the rule is postponed
until reaching the result of some external process,
for example, a parser or generator. There is howe-
ver no hinder in excluding the use of other values
here. One could, for example, imagine cases where
one would want different nonmonotonic rules to be
explained after a completed parse, a generation, or
after resolving discourse referents.
Note that although the when slot in the defini-
tion of a nonmonotonic rule allows the user to define
when his rule is going to be applied we will still have
an order independent nonmonotonic unification ope-
rator. This is the case because we follow Young and
Rounds&apos; approach and separate the unification ope-
ration from the explanation of a nonmonotonic rule.
Therefore, what affects the final result of a computa-
tion is when one chooses to explain default rules and
not the order of the unification operations occurring
between such explanations.
</bodyText>
<page confidence="0.998865">
64
</page>
<sectionHeader confidence="0.999575" genericHeader="method">
4 Formal Definitions
</sectionHeader>
<bodyText confidence="0.997848966101695">
In this section I provide give the formal definitions
for nonmonotonic sorts and how nonmonotonic sorts
are unified and explained. The definitions are gene-
ralizations of the definitions in Young and Rounds
(1993). The notation a — b is used to denote the
fact that a n b does not yield unification failure.
A nonmonotonic sort is a structure containing
both information from the basic subsumption order
and information about default rules to be explained
at a later point in the computation.
Definition 1 A nonmonotonic sort is a pair (s, A)
where s E S and A is a set of nonmonotonic
rules of the form (w, a : -y) where w is an
atom and a, # and -y E S. It is assumed that for
each nonmonotonic rule 7 C #, a s, 8,
and 7 n s c s.
As seen by the definition a nonmonotonic sort is
considered to be a pair of monotonic information
from the subsumption order and nonmonotonic in-
formation represented as a set of nonmonotonic ru-
les. The user can assign nonmonotonic information
to a nonmonotonic sort by calling a nonmonotonic
definition as defined in the previous section. The ac-
tual nonmonotonic rule occurring within the sort is
a pair consisting of the when slot and the last part
of the nonmonotonic definition, with the parameter
variables instantiated according to the call made by
the user.
The second part of this definition contains some
well-foundedness conditions for a nonmonotonic
sort. The first condition (7 C II) is a restriction
similar to the restriction to normal default rules in
Reiter&apos;s (1980) default logic. This restriction ensu-
res that the application of one default rule will never
cause previously applied default rules to be inappli-
cable. This makes the procedure for application of
defaults more efficient and will be further discussed
in section 6.
The next two conditions in the definition, a s
and 13 s, guarantee that the default rule is or can
be applicable to the nonmonotonic sort. The reason
for only checking that a — s instead of s C a is that
future unifications can restrict the value of s into
something more specific than a and thus may make
the default rule applicable.
The last condition on a nonmonotonic sort, 7ns
s, may seem superfluous. The reason for including
it is to ensure that applying the default actually re-
stricts the value of the sort. Otherwise the default
rule would have no effect and can be removed. Note
in particular that the above conditions on a nonmo-
notonic sort implies that 7 may be fail.
Given the unification operation of objects within
the subsumption order and the definition of nonmo-
notonic sorts it is possible to define an operation for
nonmonotonic unification.
Definition 2 The nonmonotonic unification (nN)
of two nonmonotonic sorts (Si, Ai) and (82, 6,2)
is the sort (s, A) where
</bodyText>
<listItem confidence="0.877852">
• s = si n s2 and
• A ={dd = (w, a :/3=7), d€ A1 U
A2, a s, s, and -y n s C s}
</listItem>
<bodyText confidence="0.988243272727273">
The nonmonotonic unification is computed by
computing the unification of the monotonic parts of
the two sorts and then taking the union of their non-
monotonic parts. The extra conditions used when
forming the union of the nonmonotonic parts of the
sorts are the same as in the definition of a nonmo-
notonic sort and their purpose is to remove nonmo-
notonic rules that are no longer applicable, or would
have no effect when applied to the sort resulting from
the unification.
It is important to note that this generalization of
the original definition of nonmonotonic unification
from Young and Rounds (1993) preserves the pro-
perty of order independence for default unification.
When using nonmonotonic sorts containing non-
monotonic rules, we also need to know how to
merge the monotonic and nonmonotonic informa-
tion within the sort. I will use the terminology w-
application for applying one nonmonotonic rule to
the sort and w-explanation when applying all possi-
ble rules.
Definition 3 The nonmonotonic rule
</bodyText>
<listItem confidence="0.86674375">
(w, a : [3 =7) is w-applicable to s E S if:
• s a
• s—flors=fail
• sn-yCsors= fail
</listItem>
<bodyText confidence="0.997795833333333">
The result of the w-application is 7 n s
Note that the w in w-application should be consi-
dered as a variable. This means that only nonmono-
tonic rules whose first component is w are considered
and that it is possible to choose which nonmonoto-
nic rules should be applied in a particular point at
some computation.
In addition note that the restriction that -y #
in all nonmonotonic rules and the special cases for
s = fail ensures that the application of one non-
monotonic rule never destroys the applicability of a
previously applied rule. This reduces the amount
of work required when computing a w-explanation.
Based on these observations, a sufficient condition
for w-explanation is defined as follows.
Definition 4 t is a w-explanation of a nonmono-
tonic sort (s, A) if it can be computed in the
following way:
</bodyText>
<listItem confidence="0.9998274">
1. Ifs = fail or no d E A is w-applicable then
t = s else
2. Choose a d = (w, a : f3 -y) E A such that
d is w-applicable to s.
3. Let s = s n 7 and go to 1.
</listItem>
<page confidence="0.998137">
65
</page>
<bodyText confidence="0.999958086956522">
As shown by the definition, a w-explanation is
computed by choosing one w-applicable default rule
at a time and then applying it. Since the defini-
tion of w-applicability and the condition that 7 C
in all nonmonotonic rules ensures that whenever a
nonmonotonic rule is applied it can never be inapp-
licable, there is no need to check if the preconditions
of earlier applied nonmonotonic rules still hold.
Note also that the choice of which nonmonotonic
rule to apply in each step of a w-explanation is non-
deterministic. Consequently, it is possible to have
conflicting defaults and multiple w-explanations for
a nonmonotonic sort.
Note also that the result of a w-explanation is al-
lowed to be fail. Another option would be to inter-
pret fail as if the application of the nonmonotonic
rule should not be allowed. However, as seen in the
next section, for many uses of nonmonotonic exten-
sions within unification-based formalisms, the aim is
to derive failure if the resulting structure does not
fulfill some particular conditions. This makes it im-
portant to allow fail to be the result of applying a
nonmonotonic rule.
</bodyText>
<sectionHeader confidence="0.998124" genericHeader="method">
5 Examples
</sectionHeader>
<bodyText confidence="0.957660588235294">
In this section I will show how some of the most
common nonmonotonic extensions to unification-
based grammar can be expressed by defining rules
as above. I will start with defining default values.
This is done by defining a nonmonotonic rule default
for the class value, which is assumed to be the most
general class in a defined hierarchy. The rule defi-
ned here is treated as the one in (Young and Rounds,
1993).
class value;
nonmon def ault (X) : immediat e :X =&gt;
X
This default rule can be used when defining verbs.
The rule is used for stating that verbs are active by
default. I also define the two Swedish verbs skickade
(sent) and skickades (was sent) to illustrate how this
rule works.
</bodyText>
<construct confidence="0.9759985">
class verb;
isa value;
requires [form: default(active)] .
class skickade;
isa verb;
requires [lex: skicka].
class skickades;
isa verb;
requires [lex: skicka, form:
passive].
</construct>
<bodyText confidence="0.994079">
While retrieving the information for these two
verbs we will obtain the following two feature struc-
tures containing nonmonotonic sorts:
</bodyText>
<figure confidence="0.244681625">
For skickade:
[lex: skicka, form:
(0 ,{(immediate, :active
active )})]
For skickades:
[lex: skicka, form:
(passive,{(immediate, :active
active )})]
</figure>
<bodyText confidence="0.894707428571429">
Since I have used immediate for the when-slot in
the definition of the default rule, this nonmonotonic
rule will be applied immediately after retrieving all
information about a verb in the hierarchy. For the
two structures above, the default rule can be app-
lied for skickade, since active is consistent with 0,
but not for skickades, since active and passive are
inconsistent. The result after applying immediate-
explanation to the two structures above is shown
below.
For skickade:
[lex: skicka, form: active]
For skickades:
[lex: skicka, form: passive]
Another nonmonotonic operation that has been
used in LFG (Kaplan and Bresnan, 1983) is the va-
lue constraint (=c) used to check whether a sub-
structure has a particular value after a completed
parse. The definition of value constraints as a non-
monotonic rule makes use of negation, interpreted
as negation as failure.
</bodyText>
<subsectionHeader confidence="0.759899">
class value;
</subsectionHeader>
<bodyText confidence="0.982573608695652">
rionrson =c (X) :posterior : =&gt; fail.
One use of value constraints in LFG is to assert
a condition that some grammar rules can only be
used for passive sentences. I will here assume that
a representation for verbs where passive verbs have
the value passive for the attribute form, but where
other verbs have no value for this attribute. In the
syntax used in this paper the constraint that a par-
ticular grammar rule can only be used for passive
verbs would be expressed as below:
[form: =c(passive)]
This would result in the nonmonotonic sort:
[form: (0 ,{(posterior, :—passive
fail )}))
As seen by the definition of =c, the explanation
for this nonmonotonic sort is postponed and is assu-
med to be computed after finding a parse for some
sentence. This implies that the only case where this
rule would not apply, and thus not give fail as a re-
sult, is when the value of form actually is passive.
For all other values of form, we would have some-
thing that is consistent with --passive and thus the
nonmonotonic rule will derive failure when applied.
</bodyText>
<page confidence="0.978937">
66
</page>
<bodyText confidence="0.98073709375">
The next nonmonotonic structure I want to dis-
cuss is any-values. The inheritance hierarchy is used
to be able to define any-values in a simple way.
class value.
class none;
isa value.
class any_value;
isa value.
nonmon any() :posterior
: any_no_value =&gt; tail.
class any_no_value;
isa any_value.
In this small hierarchy it is assumed that all pos-
sible values of a structure is a subtype of value. We
then divide this into none, which represents that a
structure cannot have any value and any_value which
contains all actual values. The class any_value is
then further divided into a class called any_no_value,
which only contains this single value, and the ac-
tual values of a structure. The class any_no_value
should not be used when defining linguistic know-
ledge. However, when applying the default rule a
value that has not been instantiated is compatible
with this any_no_value. Therefore the default rule
can make the conclusion that the structure is in-
consistent, which is what we desire. Note that, as
soon as a value has been further instantiated into
a &apos;real&apos; value, it will no longer be consistent with
any_no_value, and the nonmonotonic rule cannot ap-
ply. Two examples will further illustrate this.
The nonmonotonic sort:
( 0 , {( posterior, :any_no_value
fail )})
will be posterior-explained to:
fail
While the sort:
([lex: kalle] , {( posterior,
:any_no_value = fail )})
will be posterior-explained to:
El ex : kalle]
The last nonmonotonic operations I want to dis-
cuss are completeness and coherence as used in LFG.
To be able to define these operations I assume the
inheritance hierarchy above, without the nonmono-
tonic definition of any. I will, instead, make use of
the two nonmonotonic definitions below.
class value;
nonmon coherence (A) : immediate :[A:
none] =&gt; [A: none] ;
nonmon completeness (A) :posterior
:[A: any_no_value] =&gt; fail.
The first of these rules is used to check coherence,
and the effect is to add the value none to each attri-
bute that has been defined to be relevant for cohe-
rence check, but has not been assigned a value in the
lexicon. The second rule is used for checking com-
pleteness and it works similarly to the any-definition
above.
Finally, I will show how a fragment of a lexicon can
be defined according to these rules. Note that in the
definition of the transitive verb, the value any_value
is given to the appropriate attributes. This means
that they are inconsistent with none, and thus, the
coherence rule cannot be applied.
</bodyText>
<figure confidence="0.606076">
concept verb;
isa any_value;
requires coherence(subj) A
coherence(obj) A ...;
requires completeness(subj) A
completeness(obj) A ....
</figure>
<construct confidence="0.395353">
concept trans it iveverb ;
isa verb;
requircs [subj : any_value, obj :
any _v alu e] .
</construct>
<sectionHeader confidence="0.919048" genericHeader="method">
6 Relation to Default Logic
</sectionHeader>
<bodyText confidence="0.99720559375">
In this section I will discuss the relation of this work
to Reiter&apos;s (1980) default logic. There will also be
some discussion on the computational properties and
limitations of the given approach.
Compared with Reiter&apos;s default logic, our notion
of nonmonotonic sorts corresponds to default theo-
ries. Unification of nonmonotonic sorts would then
correspond to merging two default theories into one
single theory and our notion of explaining a nonmo-
notonic sort corresponds to computing the extension
of a default theory in default logic.
In default logic there is often a restriction to
normal-default theories since non-normal default
theories are not even semi-decidable. The restric-
tion in our nonmonotonic rules that 7 C # is similar
to the restriction into normal default rules and cap-
tures the important property, that the application of
one nonmonotonic rule should not affect the appli-
cability of previously applied rules. The decidability
of the nonmonotonic rules defined here is, however,
highly dependant on the given subsumption order.
In particular it is dependent on having a decidable
unification operation and subsumption check.
As mentioned previously there is with nonmonoto-
nic sorts, as well as normal default logic, a possibility
of conflicting defaults and thus multiple nonmono-
tonic extensions for a structure. One difference is
that nonmonotonic sorts allow that the application
of a nonmonotonic rule leads to fail, i.e. an incon-
sistent structure, while default logic does not allow
this outcome. However, since fail is allowed as a va-
lid explanation for a nonmonotonic sort, there is, as
</bodyText>
<page confidence="0.998205">
67
</page>
<bodyText confidence="0.999727833333333">
for normal default logic, always at least one expla-
nation for a sort.
The two following examples will illustrate the dif-
ference between nonmonotonic rules giving multiple
extensions and nonmonotonic rules giving a single
explanation fail.
</bodyText>
<figure confidence="0.511394666666667">
Example a
:[a:1] 4c:2]
[a:1 b:1] [6:2 c:2]
Example b
:[a:1] 4b:2]
[a:1 b:1] [42:2 b:2]
</figure>
<bodyText confidence="0.999961842105263">
In example a the application of one rule, does not
make the other inapplicable. Thus the only expla-
nation for a structure is achieved by applying both
these two rules and results in fail. In example b,
however, the application of one of the rules would
block the application of the other. Thus, in this
case there are two explanations for the structure de-
pendant on which of the rules that has been app-
lied first. Note that even though there is an order
dependency on the application order of nonmonoto-
nic rules this does not affect the order independency
on nonmonotonic unification between application of
nonmonotonic rules.
Allowing multiple extensions gives a higher com-
putational complexity than allowing only theories
with one extension. Since it is the user who defines
the actual nonmonotonic theory multiple extensions
must be allowed and it must be considered a task for
the user to define his theory in the way he prefers.
</bodyText>
<sectionHeader confidence="0.922354" genericHeader="method">
7 Improvements of the Approach
</sectionHeader>
<bodyText confidence="0.997748543478261">
I will start with two observations regarding the de-
finitions given in section 3. First, it is possible to
generalize these definitions to allow the first com-
ponent of a nonmonotonic sort to contain substruc-
tures that are also nonmonotonic sorts. With the
generalized versions of the definitions explanations
that simultaneously explain all substructures of a
nonmonotonic sort will be considered. Note that
the explanation of default rules at one substructure
might affect the explanation of rules at other sub-
structures. Therefore the order on which nonmono-
tonic rules at different substructures are applied is
important and all possible application orders must
be considered.
Considering unification of nonmonotonic sorts it
is not necessary to simplify the nonmonotonic part
of the resulting sort. A = i U A2 can be defined as
an alternative to the given definition. This alternate
definition is useful for applications where the simpli-
fication of nonmonotonic sorts by each unification is
expected to be more expensive than the extra work
needed to explain a sort whose nonmonotonic part
is not simplified.
As stated previously, nonmonotonic sorts allow
multiple explanations of a nonmonotonic sort. If de-
sired, it would be fairly easy to add priorities to the
nonmonotonic rules, and thus induce a preference
order on explanations.
One further example will illustrate that it is also
possible to define negation as failure with nonmono-
tonic rules. An intuitive interpretation of the defined
rule below is that if X is believed (V C X), failure
should be derived.
nonmon not(X):immediate X =&gt; fail;
However, if this definition is to be really useful
we must also allow one definition of a nonmonoto-
nic rule to make use of other nonmonotonic rules.
In our original definition we said that the nonmo-
notonic rule above should be applied if V
This can be generalized to the case where is a
nonmonotonic rule if we extend the definition of
to also mean that the application (or explanation)
of the not rule at this node does not yield failure.
However, this generalization is outside default logic.
Therefore, its computational properties are unclear
and needs more investigation.
</bodyText>
<sectionHeader confidence="0.997844" genericHeader="conclusions">
8 Conclusion
</sectionHeader>
<bodyText confidence="0.9998648125">
In this paper I have proposed a method allowing
the user to define nonmonotonic operations in a
unification-based grammar formalism. This was
done by generalizing the work on nonmonotonic
sorts (Young and Rounds, 1993) to allow not only
normal defaults rules but general default rules that
are defined by the user. The method has a very
close relation to Reiter (1980). We also noted that
the method can be applied to all domains of structu-
res where we have a defined subsumption order and
unification operation.
The generality of the approach was demonstrated
by defining some of the most commonly used nonmo-
notonic operations. We also gave formal definitions
for the approach and provided a discussion on its
computational properties.
</bodyText>
<sectionHeader confidence="0.998361" genericHeader="acknowledgments">
Acknowledgments
</sectionHeader>
<bodyText confidence="0.999877">
This work has been supported by the Swedish Re-
search Council for Engineering Sciences (TFR). I
would also like to thank Lars Ahrenberg and Pa-
trick Doherty for comments on this work and Mark
A. Young for providing me with much-needed infor-
mation about his and Bill Rounds&apos; work.
</bodyText>
<sectionHeader confidence="0.999154" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.9824275">
Gosse Bouma. 1990. Defaults in Unification Gram-
mar. in Proceedings of the 1990 Conference of the
</reference>
<page confidence="0.988664">
68
</page>
<reference confidence="0.997652210526316">
Association for Computational Linguistics, pages
165-172.
Gosse Bouma. 1992. Feature Structures and
Nonmonotonicity. Computational Linguistics
18(2):183-203.
Jochen Dorre and Andreas Eisele. 1991. A Compre-
hensive Unification-Based Grammar Formalism.
DYANA Report — Deliverable R3.1B. January
1991.
Martin C. Emele, and Remi Zajac. 1990. Typed
Unification Grammars. In Proceedings of the 13th
International Conference on Computational Lin-
guistics, Vol. 3, pages 293-298, Helsinki, Finland.
Rod Johnson and Michael Rosner. 1989. A Rich En-
vironment for Experimentation with Unification
Grammars. In Proceedings of the 4th Conference
of the European Chapter of the Association for
Computational Linguistics, pages 182-189, Man-
chester, England.
R. Kaplan and J.Bresnan. 1983. A Formal System
for Grammatical Representation. In: J Bresnan
(ed.), The Mental Representation of Grammatical
Relations. MIT Press, Cambridge, Massachusetts.
Ray Reiter. 1980. A Logic for Default Reasoning.
In Artificial Intelligence, 13:81-132.
Graham Russel, Afzal Ballim, John Carrol and
Susan Warwick-Armstrong. 1992. A Practi-
cal Approach to Multiple Default Inheritance for
Unification-Based Lexicons. Computational Lin-
guistics 18(3):311-337.
Lena Stromback. 1994. Achieving Flexibility in Uni-
fication Grammars. In Proceedings of the 15th In-
ternational Conference on Computational Lingui-
stics, Vol. 3, pages 842-846, Kyoto, Japan.
Mark A Young and Bill Rounds. 1993. A Logi-
cal Semantics for Nonmonotonic Sorts. In Procee-
dings of the 1993 Conference of the Association
for Computational Linguistics, pages 209-215
</reference>
<page confidence="0.999284">
69
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.010982">
<title confidence="0.999524">User-Defined Nonmonotonicity in Unification-Based Formalisms</title>
<author confidence="0.999923">Lena Stromback</author>
<affiliation confidence="0.9999705">Department of Computer and Information Science Linkoping University</affiliation>
<address confidence="0.997127">S-58185 LinkOping, Sweden</address>
<email confidence="0.992524">lestrOida.liu.se</email>
<abstract confidence="0.994133629268294">A common feature of recent unificationbased grammar formalisms is that they give the user the ability to define his own structures. However, this possibility is mostly limited and does not include nonmonotonic operations. In this paper we show how nonmonotonic operations can also be user-defined by applying default logic (Reiter, 1980) and generalizing previous results on nonmonotonic sorts (Young and Rounds, 1993). 1 Background Most of the more recent unification-based formalisms, such as TFS (Emele and Zajac, 1990), UD (Johnson and Rosner, 1989), CUF (Dorre and Eisele, 1991), and FLUF (Stromback, 1994), provide some possibility for the user to define constructions of his own. This possibility can be more or less powerful in different formalisms. There are, however, several constructions proposed as desirable extensions to unification grammars that cannot be defined in a general and well-defined way in these formalisms. One such class of constructions is those that have some degree of nonmonotonic behaviour. Examples of such constructions are any-values, default-values, and some constructions (e.g. constraining equations, completeness and coherence) used in LFG (Kaplan and Bresnan, 1983). This paper describes a method that permits the user to define such nonmonotonic constructions. This is done through generalizing the work on nonmonotonic sorts (Young and Rounds, 1993). This generalization results in a default logic similar to (Reiter, 1980), but where subsumption and unification are used instead of logical truth and consistency. There are three main advantages to Young and Rounds&apos; work compared with other approaches to default unification (Houma, 1990; Bouma, 1992; Russel et al., 1992) which justify choosing it as a starting point for this work. The first is the separation of definite and default information, where Young and Rounds are more distinct than the other. The second is that the nonmonotonic unification operation used is order independent. This is achieved by separating the unification operation from computing the nonmonotonic extension, which Young and Rounds call explanation. This suggests that all the user needs to define when generalizing the approach is how a sort is explained. Finally, there is a close relationship to Reiter&apos;s (1980) default logic. This paper starts by providing the minimal properties required of a unification-based formalism when extending with nonmonotonic definitions. I then describe the approach of user-defined nonmonotonicity and illustrate how some commonly used nonmonotonic constructions can be defined within it. Finally I conclude with a discussion of the relation to Reiter&apos;s default logic and computational properties of the approach. 2 Preliminaries There are two main properties that will be assumed of a unification-based formalism in order to extend it with the possibility of defining nonmonotonic constructions. The first, and most important, is that require a subsumption order on the set objects denoted by the formalism. Secondly it should be possible to define inheritance hierarchies on the linguistic knowledge described by the formalism. One very plausible subsumption order that can be used is the ordinary subsumption lattice of feature structures. It is, however, possible to use some other kind of subsumption order if that is more suitable for the domain to be modelled by the formalism. Examples of other subsumption orders that might be useful are typed feature structures, feature structures extended with disjunction, or simply an order based on sets and set inclusion. this paper the notation a C used whenea subsumes whenever a &amp;quot;is more specific or &amp;quot;contains more information than&amp;quot; Cona c used whenever a C a b. subsumption order is assumed to be a semi- 63 lattice and permits computing a unifier, denoted 17 to the greatest lower bound, for every pair of elements within it. The element corresponding to the bottom of the order relation is represents inconsistent information or unification failure. The second constraint placed on the formalism, the possibility of defining an inheritance hierarchy, is not essential for the definition of nonmonotonic operations. It is, however, very useful when defining nonmonotonic constructions. The following notation will be used for describing an inheritance hierarchy. name of the class; parent in the hierarchy; a Thus, each member in the inheritance hierarchy is called a class, which is defined by giving it a name and a parent in the hierarchy. It is also possible to define some constraints, called requirements, which must hold for a class. These requirements can be both structures in the subsumption order and nonmonotonic rules. The constraints on classes are inherited through the hierarchy. Every object in a class is assumed to contain at least the information given by the constraints specified for it and all its ancestors. For simplicity multiple inheritance between classes will not be allowed. This means that two classes where none of them is a subclass of the other, will always be considered inconsistent and thus yield a failure when unified. Nonmonotonicity now describe how the work by Young and Rounds can be generalized to allow the user to define nonmonotonic constructions. The main idea in their approach is that each node in a feature strucconsists of a sort. sorts can contain two different kinds of information, the ordinary monotonic information and a set of defaults. If assume that defined as a default in Young and Rounds&apos; work then it is interpreted according to the rule: if it is consistent to believe # then believe Reiter&apos;s default logic this is expressed with the following normal default rule. : In this paper I want to allow the user to use other forms of nonmonotonic inferences and not only the normal default rule given above. Therefore, I will consider the general form of default rules. An intuitive reading of a general default rule is, if a is believed and it is consistent to believe # then believe -T. In default logic this is usually expressed as a : # The next question is how such defined nonmonotonic rules are going to be interpreted in a unification framework. In (Reiter, 1980), a rule like the one above could be applied whenever a is true and )3 is consistent with the information we already have. we assume that the information already given this means that the default rule can be whenever V C a and fl does not yield unification failure. When the rule is applied the new obtained would be n In the approach described in this paper, the user is allowed to define the actual nonmonotonic rule that should be used for a particular operation by using the following syntax. nonmon a :# =&gt; 7 In the syntax given above name assigns a name to the defined rule, and thus allows the user to use nonmonotonic information when defining linguistic knowledge. The parameters in the rule definition are variables, which can be used within the actual default rule at the end of the description. The user is assumed to assign the nonmonotonic information contained in this rule to his linguistic knowledge by using an expression of the form in the rule allows the user to decide when the rule is going to be applied, or in Young and Rounds&apos; terminology, explained. I will make of two values for the when-slot, and means that the nonmonotonic rule is going to be applied each time a full unification task has been solved or whenever all information about an object in the defined inheritance hierarchy has been retrieved. Posterior explanation means that the explanation of the rule is postponed until reaching the result of some external process, for example, a parser or generator. There is however no hinder in excluding the use of other values here. One could, for example, imagine cases where one would want different nonmonotonic rules to be explained after a completed parse, a generation, or after resolving discourse referents. Note that although the when slot in the definition of a nonmonotonic rule allows the user to define when his rule is going to be applied we will still have an order independent nonmonotonic unification operator. This is the case because we follow Young and Rounds&apos; approach and separate the unification operation from the explanation of a nonmonotonic rule. Therefore, what affects the final result of a computation is when one chooses to explain default rules and not the order of the unification operations occurring between such explanations. 64 4 Formal Definitions In this section I provide give the formal definitions for nonmonotonic sorts and how nonmonotonic sorts are unified and explained. The definitions are generalizations of the definitions in Young and Rounds The notation a — used to denote the that a n not yield unification failure. A nonmonotonic sort is a structure containing both information from the basic subsumption order and information about default rules to be explained at a later point in the computation. 1 A sort is pair E S A is a set of nonmonotonic of the form (w, a : w is an and a, -y E is assumed that for nonmonotonic rule 7 C #, a 8, 7 n As seen by the definition a nonmonotonic sort is considered to be a pair of monotonic information from the subsumption order and nonmonotonic information represented as a set of nonmonotonic rules. The user can assign nonmonotonic information to a nonmonotonic sort by calling a nonmonotonic definition as defined in the previous section. The actual nonmonotonic rule occurring within the sort is pair consisting of the and the last part of the nonmonotonic definition, with the parameter variables instantiated according to the call made by the user. The second part of this definition contains some well-foundedness conditions for a nonmonotonic The first condition (7 C a restriction similar to the restriction to normal default rules in Reiter&apos;s (1980) default logic. This restriction ensures that the application of one default rule will never cause previously applied default rules to be inapplicable. This makes the procedure for application of defaults more efficient and will be further discussed in section 6. next two conditions in the definition, a s that the default rule is or can be applicable to the nonmonotonic sort. The reason only checking that a — of a is that unifications can restrict the value of something more specific than a and thus may make the default rule applicable. last condition on a nonmonotonic sort, seem superfluous. The reason for including it is to ensure that applying the default actually restricts the value of the sort. Otherwise the default rule would have no effect and can be removed. Note in particular that the above conditions on a nonmosort implies that 7 may be Given the unification operation of objects within the subsumption order and the definition of nonmonotonic sorts it is possible to define an operation for nonmonotonic unification. 2 The unification two nonmonotonic sorts (Si,Ai) and (82, the sort where s = n and A ={dd = (w, a A1 U a s, and -y n s C s} The nonmonotonic unification is computed by computing the unification of the monotonic parts of the two sorts and then taking the union of their nonmonotonic parts. The extra conditions used when forming the union of the nonmonotonic parts of the sorts are the same as in the definition of a nonmonotonic sort and their purpose is to remove nonmonotonic rules that are no longer applicable, or would have no effect when applied to the sort resulting from the unification. It is important to note that this generalization of the original definition of nonmonotonic unification from Young and Rounds (1993) preserves the property of order independence for default unification. When using nonmonotonic sorts containing nonmonotonic rules, we also need to know how to merge the monotonic and nonmonotonic information within the sort. I will use the terminology wapplying one nonmonotonic rule to sort and applying all possible rules. Definition 3 The nonmonotonic rule a : =7) is w-applicable • s a • s—flors=fail sn-yCsors= result of the is 7 that the w in be considered as a variable. This means that only nonmonotonic rules whose first component is w are considered and that it is possible to choose which nonmonotonic rules should be applied in a particular point at some computation. In addition note that the restriction that -y # in all nonmonotonic rules and the special cases for = fail that the application of one nonmonotonic rule never destroys the applicability of a previously applied rule. This reduces the amount of work required when computing a w-explanation. Based on these observations, a sufficient condition for w-explanation is defined as follows. 4 w-explanation a nonmonosort A) it can be computed in the following way: 1. = fail no A is w-applicable then = Choose a = (w, a : f3 E A such that w-applicable to Let and go to 1. 65 As shown by the definition, a w-explanation is computed by choosing one w-applicable default rule at a time and then applying it. Since the definition of w-applicability and the condition that 7 C in all nonmonotonic rules ensures that whenever a nonmonotonic rule is applied it can never be inapplicable, there is no need to check if the preconditions of earlier applied nonmonotonic rules still hold. Note also that the choice of which nonmonotonic rule to apply in each step of a w-explanation is nondeterministic. Consequently, it is possible to have conflicting defaults and multiple w-explanations for a nonmonotonic sort. Note also that the result of a w-explanation is alto be option would be to interif the application of the nonmonotonic rule should not be allowed. However, as seen in the next section, for many uses of nonmonotonic extensions within unification-based formalisms, the aim is to derive failure if the resulting structure does not fulfill some particular conditions. This makes it imto allow be the result of applying a nonmonotonic rule. 5 Examples In this section I will show how some of the most common nonmonotonic extensions to unificationbased grammar can be expressed by defining rules as above. I will start with defining default values. is done by defining a nonmonotonic rule for the class value, which is assumed to be the most general class in a defined hierarchy. The rule defined here is treated as the one in (Young and Rounds, 1993). class value; nonmon def ault (X) : immediat e :X =&gt; X This default rule can be used when defining verbs. The rule is used for stating that verbs are active by I also define the two Swedish verbs (was sent) illustrate how this rule works. class verb; isa value; requires [form: default(active)] . class skickade; isa verb; requires [lex: skicka]. class skickades; isa verb; requires [lex: skicka, form: passive]. While retrieving the information for these two verbs we will obtain the following two feature structures containing nonmonotonic sorts: [lex: skicka, form: (0 ,{(immediate, :active active )})] [lex: skicka, form: (passive,{(immediate, :active I have used the when-slot in the definition of the default rule, this nonmonotonic rule will be applied immediately after retrieving all information about a verb in the hierarchy. For the two structures above, the default rule can be appfor consistent with 0, not for The result after applying immediateexplanation to the two structures above is shown below. [lex: skicka, form: active] [lex: skicka, form: passive] Another nonmonotonic operation that has been used in LFG (Kaplan and Bresnan, 1983) is the vaconstraint to check whether a substructure has a particular value after a completed parse. The definition of value constraints as a nonmonotonic rule makes use of negation, interpreted as negation as failure. class value; =c (X) :posterior : =&gt; One use of value constraints in LFG is to assert a condition that some grammar rules can only be used for passive sentences. I will here assume that a representation for verbs where passive verbs have value the attribute where other verbs have no value for this attribute. In the syntax used in this paper the constraint that a particular grammar rule can only be used for passive verbs would be expressed as below: [form: =c(passive)] This would result in the nonmonotonic sort: [form: (0 ,{(posterior, :—passive seen by the definition of explanation for this nonmonotonic sort is postponed and is assumed to be computed after finding a parse for some sentence. This implies that the only case where this rule would not apply, and thus not give fail as a reis when the value of is For all other values of form, we would have somethat is consistent with thus the nonmonotonic rule will derive failure when applied. 66 next nonmonotonic structure to disis inheritance hierarchy is used to be able to define any-values in a simple way. class value. class none; isa value. class any_value; isa value. nonmon any() :posterior : any_no_value =&gt; tail. class any_no_value; isa any_value. small hierarchy it is assumed that all posvalues of a structure is a subtype of divide this into represents that a cannot have any value and all actual values. The class further divided into a class called which only contains this single value, and the acvalues of a structure. The class should not be used when defining linguistic knowledge. However, when applying the default rule a value that has not been instantiated is compatible this the default rule can make the conclusion that the structure is inconsistent, which is what we desire. Note that, as soon as a value has been further instantiated into a &apos;real&apos; value, it will no longer be consistent with the nonmonotonic rule cannot apply. Two examples will further illustrate this. The nonmonotonic sort: 0 , posterior, :any_no_value fail )}) be to: fail While the sort: ([lex: kalle] , {( posterior, :any_no_value = fail )}) be to: El ex : kalle] last nonmonotonic operations to discuss are completeness and coherence as used in LFG. To be able to define these operations I assume the inheritance hierarchy above, without the nonmonodefinition of any. instead, make use of the two nonmonotonic definitions below. class value; nonmon coherence (A) : immediate :[A: none] =&gt; [A: none] ; nonmon completeness (A) :posterior :[A: any_no_value] =&gt; fail. The first of these rules is used to check coherence, and the effect is to add the value none to each attribute that has been defined to be relevant for coherence check, but has not been assigned a value in the lexicon. The second rule is used for checking completeness and it works similarly to the any-definition above. Finally, I will show how a fragment of a lexicon can be defined according to these rules. Note that in the of the transitive verb, the value is given to the appropriate attributes. This means they are inconsistent with thus, the coherence rule cannot be applied. concept verb; isa any_value; coherence(subj) ...; completeness(subj) .... concept trans it iveverb ; isa verb; requircs [subj : any_value, obj : any _v alu e] . to Default Logic In this section I will discuss the relation of this work to Reiter&apos;s (1980) default logic. There will also be some discussion on the computational properties and of the given Compared with Reiter&apos;s default logic, our notion of nonmonotonic sorts corresponds to default theories. Unification of nonmonotonic sorts would then correspond to merging two default theories into one single theory and our notion of explaining a nonmonotonic sort corresponds to computing the extension of a default theory in default logic. In default logic there is often a restriction to normal-default theories since non-normal default theories are not even semi-decidable. The restricin our nonmonotonic rules that C # is similar to the restriction into normal default rules and captures the important property, that the application of one nonmonotonic rule should not affect the applicability of previously applied rules. The decidability of the nonmonotonic rules defined here is, however, highly dependant on the given subsumption order. In particular it is dependent on having a decidable unification operation and subsumption check. As mentioned previously there is with nonmonotonic sorts, as well as normal default logic, a possibility of conflicting defaults and thus multiple nonmonotonic extensions for a structure. One difference is that nonmonotonic sorts allow that the application a nonmonotonic rule leads to an inconsistent structure, while default logic does not allow outcome. However, since allowed as a valid explanation for a nonmonotonic sort, there is, as 67 for normal default logic, always at least one explanation for a sort. The two following examples will illustrate the difference between nonmonotonic rules giving multiple extensions and nonmonotonic rules giving a single explanation fail. Example a b:1] Example b [a:1 b:1] [42:2 b:2] In example a the application of one rule, does not make the other inapplicable. Thus the only explanation for a structure is achieved by applying both two rules and results in example however, the application of one of the rules would block the application of the other. Thus, in this case there are two explanations for the structure dependant on which of the rules that has been applied first. Note that even though there is an order dependency on the application order of nonmonotonic rules this does not affect the order independency on nonmonotonic unification between application of nonmonotonic rules. Allowing multiple extensions gives a higher computational complexity than allowing only theories with one extension. Since it is the user who defines the actual nonmonotonic theory multiple extensions must be allowed and it must be considered a task for the user to define his theory in the way he prefers. 7 Improvements of the Approach I will start with two observations regarding the definitions given in section 3. First, it is possible to generalize these definitions to allow the first component of a nonmonotonic sort to contain substructures that are also nonmonotonic sorts. With the generalized versions of the definitions explanations that simultaneously explain all substructures of a nonmonotonic sort will be considered. Note that the explanation of default rules at one substructure might affect the explanation of rules at other substructures. Therefore the order on which nonmonotonic rules at different substructures are applied is important and all possible application orders must be considered. Considering unification of nonmonotonic sorts it is not necessary to simplify the nonmonotonic part the resulting sort. A = i A2 be defined as an alternative to the given definition. This alternate definition is useful for applications where the simplification of nonmonotonic sorts by each unification is expected to be more expensive than the extra work needed to explain a sort whose nonmonotonic part is not simplified. As stated previously, nonmonotonic sorts allow multiple explanations of a nonmonotonic sort. If desired, it would be fairly easy to add priorities to the nonmonotonic rules, and thus induce a preference order on explanations. One further example will illustrate that it is also to define as failure nonmonotonic rules. An intuitive interpretation of the defined below is that if believed C X), should be derived. nonmon not(X):immediate X =&gt; fail; However, if this definition is to be really useful we must also allow one definition of a nonmonotonic rule to make use of other nonmonotonic rules. In our original definition we said that the nonmorule above should be applied if This can be generalized to the case where is a nonmonotonic rule if we extend the definition of to also mean that the application (or explanation) of the not rule at this node does not yield failure. However, this generalization is outside default logic. Therefore, its computational properties are unclear and needs more investigation. 8 Conclusion In this paper I have proposed a method allowing the user to define nonmonotonic operations in a grammar formalism. This done by generalizing the work on nonmonotonic sorts (Young and Rounds, 1993) to allow not only normal defaults rules but general default rules that are defined by the user. The method has a very close relation to Reiter (1980). We also noted that the method can be applied to all domains of structures where we have a defined subsumption order and unification operation. The generality of the approach was demonstrated by defining some of the most commonly used nonmonotonic operations. We also gave formal definitions for the approach and provided a discussion on its computational properties. Acknowledgments This work has been supported by the Swedish Research Council for Engineering Sciences (TFR). I would also like to thank Lars Ahrenberg and Patrick Doherty for comments on this work and Mark A. Young for providing me with much-needed information about his and Bill Rounds&apos; work.</abstract>
<note confidence="0.832310837209302">References Gosse Bouma. 1990. Defaults in Unification Gramin of the 1990 Conference of the 68 for Computational Linguistics, 165-172. Gosse Bouma. 1992. Feature Structures and Linguistics 18(2):183-203. Jochen Dorre and Andreas Eisele. 1991. A Comprehensive Unification-Based Grammar Formalism. DYANA Report — Deliverable R3.1B. January 1991. Martin C. Emele, and Remi Zajac. 1990. Typed Grammars. In of the 13th International Conference on Computational Lin- 3, pages 293-298, Helsinki, Finland. Rod Johnson and Michael Rosner. 1989. A Rich Environment for Experimentation with Unification In of the 4th Conference of the European Chapter of the Association for Linguistics, Manchester, England. R. Kaplan and J.Bresnan. 1983. A Formal System for Grammatical Representation. In: J Bresnan Mental Representation of Grammatical Press, Cambridge, Massachusetts. Ray Reiter. 1980. A Logic for Default Reasoning. Intelligence, Graham Russel, Afzal Ballim, John Carrol and Susan Warwick-Armstrong. 1992. A Practical Approach to Multiple Default Inheritance for Unification-Based Lexicons. Computational Linguistics 18(3):311-337. Lena Stromback. 1994. Achieving Flexibility in Uni- Grammars. In of the 15th International Conference on Computational Lingui- 3, pages 842-846, Kyoto, Japan. Mark A Young and Bill Rounds. 1993. A Logi- Semantics for Nonmonotonic Sorts. In Proceedings of the 1993 Conference of the Association Computational Linguistics, 69</note>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Gosse Bouma</author>
</authors>
<title>Defaults in Unification Grammar.</title>
<date>1990</date>
<booktitle>in Proceedings of the 1990 Conference of the Association for Computational Linguistics,</booktitle>
<pages>165--172</pages>
<marker>Bouma, 1990</marker>
<rawString>Gosse Bouma. 1990. Defaults in Unification Grammar. in Proceedings of the 1990 Conference of the Association for Computational Linguistics, pages 165-172.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Gosse Bouma</author>
</authors>
<date>1992</date>
<booktitle>Feature Structures and Nonmonotonicity. Computational Linguistics</booktitle>
<pages>18--2</pages>
<contexts>
<context position="1891" citStr="Bouma, 1992" startWordPosition="276" endWordPosition="277">es, and some constructions (e.g. constraining equations, completeness and coherence) used in LFG (Kaplan and Bresnan, 1983). This paper describes a method that permits the user to define such nonmonotonic constructions. This is done through generalizing the work on nonmonotonic sorts (Young and Rounds, 1993). This generalization results in a default logic similar to (Reiter, 1980), but where subsumption and unification are used instead of logical truth and consistency. There are three main advantages to Young and Rounds&apos; work compared with other approaches to default unification (Houma, 1990; Bouma, 1992; Russel et al., 1992) which justify choosing it as a starting point for this work. The first is the separation of definite and default information, where Young and Rounds are more distinct than the other. The second is that the nonmonotonic unification operation used is order independent. This is achieved by separating the unification operation from computing the nonmonotonic extension, which Young and Rounds call explanation. This suggests that all the user needs to define when generalizing the approach is how a sort is explained. Finally, there is a close relationship to Reiter&apos;s (1980) def</context>
</contexts>
<marker>Bouma, 1992</marker>
<rawString>Gosse Bouma. 1992. Feature Structures and Nonmonotonicity. Computational Linguistics 18(2):183-203.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jochen Dorre</author>
<author>Andreas Eisele</author>
</authors>
<title>A Comprehensive Unification-Based Grammar Formalism.</title>
<date>1991</date>
<booktitle>DYANA Report — Deliverable R3.1B.</booktitle>
<contexts>
<context position="779" citStr="Dorre and Eisele, 1991" startWordPosition="108" endWordPosition="111">Oping, Sweden lestrOida.liu.se Abstract A common feature of recent unificationbased grammar formalisms is that they give the user the ability to define his own structures. However, this possibility is mostly limited and does not include nonmonotonic operations. In this paper we show how nonmonotonic operations can also be user-defined by applying default logic (Reiter, 1980) and generalizing previous results on nonmonotonic sorts (Young and Rounds, 1993). 1 Background Most of the more recent unification-based formalisms, such as TFS (Emele and Zajac, 1990), UD (Johnson and Rosner, 1989), CUF (Dorre and Eisele, 1991), and FLUF (Stromback, 1994), provide some possibility for the user to define constructions of his own. This possibility can be more or less powerful in different formalisms. There are, however, several constructions proposed as desirable extensions to unification grammars that cannot be defined in a general and well-defined way in these formalisms. One such class of constructions is those that have some degree of nonmonotonic behaviour. Examples of such constructions are any-values, default-values, and some constructions (e.g. constraining equations, completeness and coherence) used in LFG (K</context>
</contexts>
<marker>Dorre, Eisele, 1991</marker>
<rawString>Jochen Dorre and Andreas Eisele. 1991. A Comprehensive Unification-Based Grammar Formalism. DYANA Report — Deliverable R3.1B. January 1991.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Martin C Emele</author>
<author>Remi Zajac</author>
</authors>
<title>Typed Unification Grammars.</title>
<date>1990</date>
<booktitle>In Proceedings of the 13th International Conference on Computational Linguistics,</booktitle>
<volume>3</volume>
<pages>293--298</pages>
<location>Helsinki, Finland.</location>
<contexts>
<context position="718" citStr="Emele and Zajac, 1990" startWordPosition="98" endWordPosition="101">er and Information Science Linkoping University S-58185 LinkOping, Sweden lestrOida.liu.se Abstract A common feature of recent unificationbased grammar formalisms is that they give the user the ability to define his own structures. However, this possibility is mostly limited and does not include nonmonotonic operations. In this paper we show how nonmonotonic operations can also be user-defined by applying default logic (Reiter, 1980) and generalizing previous results on nonmonotonic sorts (Young and Rounds, 1993). 1 Background Most of the more recent unification-based formalisms, such as TFS (Emele and Zajac, 1990), UD (Johnson and Rosner, 1989), CUF (Dorre and Eisele, 1991), and FLUF (Stromback, 1994), provide some possibility for the user to define constructions of his own. This possibility can be more or less powerful in different formalisms. There are, however, several constructions proposed as desirable extensions to unification grammars that cannot be defined in a general and well-defined way in these formalisms. One such class of constructions is those that have some degree of nonmonotonic behaviour. Examples of such constructions are any-values, default-values, and some constructions (e.g. const</context>
</contexts>
<marker>Emele, Zajac, 1990</marker>
<rawString>Martin C. Emele, and Remi Zajac. 1990. Typed Unification Grammars. In Proceedings of the 13th International Conference on Computational Linguistics, Vol. 3, pages 293-298, Helsinki, Finland.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Rod Johnson</author>
<author>Michael Rosner</author>
</authors>
<title>A Rich Environment for Experimentation with Unification Grammars.</title>
<date>1989</date>
<booktitle>In Proceedings of the 4th Conference of the European Chapter of the Association for Computational Linguistics,</booktitle>
<pages>182--189</pages>
<location>Manchester, England.</location>
<contexts>
<context position="749" citStr="Johnson and Rosner, 1989" startWordPosition="103" endWordPosition="106">inkoping University S-58185 LinkOping, Sweden lestrOida.liu.se Abstract A common feature of recent unificationbased grammar formalisms is that they give the user the ability to define his own structures. However, this possibility is mostly limited and does not include nonmonotonic operations. In this paper we show how nonmonotonic operations can also be user-defined by applying default logic (Reiter, 1980) and generalizing previous results on nonmonotonic sorts (Young and Rounds, 1993). 1 Background Most of the more recent unification-based formalisms, such as TFS (Emele and Zajac, 1990), UD (Johnson and Rosner, 1989), CUF (Dorre and Eisele, 1991), and FLUF (Stromback, 1994), provide some possibility for the user to define constructions of his own. This possibility can be more or less powerful in different formalisms. There are, however, several constructions proposed as desirable extensions to unification grammars that cannot be defined in a general and well-defined way in these formalisms. One such class of constructions is those that have some degree of nonmonotonic behaviour. Examples of such constructions are any-values, default-values, and some constructions (e.g. constraining equations, completeness</context>
</contexts>
<marker>Johnson, Rosner, 1989</marker>
<rawString>Rod Johnson and Michael Rosner. 1989. A Rich Environment for Experimentation with Unification Grammars. In Proceedings of the 4th Conference of the European Chapter of the Association for Computational Linguistics, pages 182-189, Manchester, England.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Kaplan</author>
<author>J Bresnan</author>
</authors>
<title>A Formal System for Grammatical Representation. In:</title>
<date>1983</date>
<editor>J Bresnan (ed.),</editor>
<publisher>MIT Press,</publisher>
<location>Cambridge, Massachusetts.</location>
<contexts>
<context position="1403" citStr="Kaplan and Bresnan, 1983" startWordPosition="199" endWordPosition="202">), and FLUF (Stromback, 1994), provide some possibility for the user to define constructions of his own. This possibility can be more or less powerful in different formalisms. There are, however, several constructions proposed as desirable extensions to unification grammars that cannot be defined in a general and well-defined way in these formalisms. One such class of constructions is those that have some degree of nonmonotonic behaviour. Examples of such constructions are any-values, default-values, and some constructions (e.g. constraining equations, completeness and coherence) used in LFG (Kaplan and Bresnan, 1983). This paper describes a method that permits the user to define such nonmonotonic constructions. This is done through generalizing the work on nonmonotonic sorts (Young and Rounds, 1993). This generalization results in a default logic similar to (Reiter, 1980), but where subsumption and unification are used instead of logical truth and consistency. There are three main advantages to Young and Rounds&apos; work compared with other approaches to default unification (Houma, 1990; Bouma, 1992; Russel et al., 1992) which justify choosing it as a starting point for this work. The first is the separation </context>
<context position="16882" citStr="Kaplan and Bresnan, 1983" startWordPosition="2851" endWordPosition="2854"> used immediate for the when-slot in the definition of the default rule, this nonmonotonic rule will be applied immediately after retrieving all information about a verb in the hierarchy. For the two structures above, the default rule can be applied for skickade, since active is consistent with 0, but not for skickades, since active and passive are inconsistent. The result after applying immediateexplanation to the two structures above is shown below. For skickade: [lex: skicka, form: active] For skickades: [lex: skicka, form: passive] Another nonmonotonic operation that has been used in LFG (Kaplan and Bresnan, 1983) is the value constraint (=c) used to check whether a substructure has a particular value after a completed parse. The definition of value constraints as a nonmonotonic rule makes use of negation, interpreted as negation as failure. class value; rionrson =c (X) :posterior : =&gt; fail. One use of value constraints in LFG is to assert a condition that some grammar rules can only be used for passive sentences. I will here assume that a representation for verbs where passive verbs have the value passive for the attribute form, but where other verbs have no value for this attribute. In the syntax use</context>
</contexts>
<marker>Kaplan, Bresnan, 1983</marker>
<rawString>R. Kaplan and J.Bresnan. 1983. A Formal System for Grammatical Representation. In: J Bresnan (ed.), The Mental Representation of Grammatical Relations. MIT Press, Cambridge, Massachusetts.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ray Reiter</author>
</authors>
<title>A Logic for Default Reasoning.</title>
<date>1980</date>
<journal>In Artificial Intelligence,</journal>
<pages>13--81</pages>
<contexts>
<context position="1663" citStr="Reiter, 1980" startWordPosition="241" endWordPosition="242">rs that cannot be defined in a general and well-defined way in these formalisms. One such class of constructions is those that have some degree of nonmonotonic behaviour. Examples of such constructions are any-values, default-values, and some constructions (e.g. constraining equations, completeness and coherence) used in LFG (Kaplan and Bresnan, 1983). This paper describes a method that permits the user to define such nonmonotonic constructions. This is done through generalizing the work on nonmonotonic sorts (Young and Rounds, 1993). This generalization results in a default logic similar to (Reiter, 1980), but where subsumption and unification are used instead of logical truth and consistency. There are three main advantages to Young and Rounds&apos; work compared with other approaches to default unification (Houma, 1990; Bouma, 1992; Russel et al., 1992) which justify choosing it as a starting point for this work. The first is the separation of definite and default information, where Young and Rounds are more distinct than the other. The second is that the nonmonotonic unification operation used is order independent. This is achieved by separating the unification operation from computing the nonmo</context>
<context position="6589" citStr="Reiter, 1980" startWordPosition="1063" endWordPosition="1064">to believe # then believe 0. In Reiter&apos;s default logic this is expressed with the following normal default rule. : In this paper I want to allow the user to use other forms of nonmonotonic inferences and not only the normal default rule given above. Therefore, I will consider the general form of default rules. An intuitive reading of a general default rule is, if a is believed and it is consistent to believe # then believe -T. In default logic this is usually expressed as a : # The next question is how such defined nonmonotonic rules are going to be interpreted in a unification framework. In (Reiter, 1980), a rule like the one above could be applied whenever a is true and )3 is consistent with the information we already have. If we assume that V represents the information already given this means that the default rule can be applied whenever V C a and V fl )3 does not yield unification failure. When the rule is applied the new information obtained would be v n -y. In the approach described in this paper, the user is allowed to define the actual nonmonotonic rule that should be used for a particular operation by using the following syntax. nonmon name(parameteri,...parametera): when a :# =&gt; 7 In</context>
<context position="26372" citStr="Reiter (1980)" startWordPosition="4425" endWordPosition="4426">ean that the application (or explanation) of the not rule at this node does not yield failure. However, this generalization is outside default logic. Therefore, its computational properties are unclear and needs more investigation. 8 Conclusion In this paper I have proposed a method allowing the user to define nonmonotonic operations in a unification-based grammar formalism. This was done by generalizing the work on nonmonotonic sorts (Young and Rounds, 1993) to allow not only normal defaults rules but general default rules that are defined by the user. The method has a very close relation to Reiter (1980). We also noted that the method can be applied to all domains of structures where we have a defined subsumption order and unification operation. The generality of the approach was demonstrated by defining some of the most commonly used nonmonotonic operations. We also gave formal definitions for the approach and provided a discussion on its computational properties. Acknowledgments This work has been supported by the Swedish Research Council for Engineering Sciences (TFR). I would also like to thank Lars Ahrenberg and Patrick Doherty for comments on this work and Mark A. Young for providing me</context>
</contexts>
<marker>Reiter, 1980</marker>
<rawString>Ray Reiter. 1980. A Logic for Default Reasoning. In Artificial Intelligence, 13:81-132.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Graham Russel</author>
<author>Afzal Ballim</author>
<author>John Carrol</author>
<author>Susan Warwick-Armstrong</author>
</authors>
<title>A Practical Approach to Multiple Default Inheritance for Unification-Based Lexicons.</title>
<date>1992</date>
<journal>Computational Linguistics</journal>
<pages>18--3</pages>
<contexts>
<context position="1913" citStr="Russel et al., 1992" startWordPosition="278" endWordPosition="281">constructions (e.g. constraining equations, completeness and coherence) used in LFG (Kaplan and Bresnan, 1983). This paper describes a method that permits the user to define such nonmonotonic constructions. This is done through generalizing the work on nonmonotonic sorts (Young and Rounds, 1993). This generalization results in a default logic similar to (Reiter, 1980), but where subsumption and unification are used instead of logical truth and consistency. There are three main advantages to Young and Rounds&apos; work compared with other approaches to default unification (Houma, 1990; Bouma, 1992; Russel et al., 1992) which justify choosing it as a starting point for this work. The first is the separation of definite and default information, where Young and Rounds are more distinct than the other. The second is that the nonmonotonic unification operation used is order independent. This is achieved by separating the unification operation from computing the nonmonotonic extension, which Young and Rounds call explanation. This suggests that all the user needs to define when generalizing the approach is how a sort is explained. Finally, there is a close relationship to Reiter&apos;s (1980) default logic. This paper</context>
</contexts>
<marker>Russel, Ballim, Carrol, Warwick-Armstrong, 1992</marker>
<rawString>Graham Russel, Afzal Ballim, John Carrol and Susan Warwick-Armstrong. 1992. A Practical Approach to Multiple Default Inheritance for Unification-Based Lexicons. Computational Linguistics 18(3):311-337.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Lena Stromback</author>
</authors>
<title>Achieving Flexibility in Unification Grammars.</title>
<date>1994</date>
<booktitle>In Proceedings of the 15th International Conference on Computational Linguistics,</booktitle>
<volume>3</volume>
<pages>842--846</pages>
<location>Kyoto, Japan.</location>
<contexts>
<context position="807" citStr="Stromback, 1994" startWordPosition="114" endWordPosition="115">ract A common feature of recent unificationbased grammar formalisms is that they give the user the ability to define his own structures. However, this possibility is mostly limited and does not include nonmonotonic operations. In this paper we show how nonmonotonic operations can also be user-defined by applying default logic (Reiter, 1980) and generalizing previous results on nonmonotonic sorts (Young and Rounds, 1993). 1 Background Most of the more recent unification-based formalisms, such as TFS (Emele and Zajac, 1990), UD (Johnson and Rosner, 1989), CUF (Dorre and Eisele, 1991), and FLUF (Stromback, 1994), provide some possibility for the user to define constructions of his own. This possibility can be more or less powerful in different formalisms. There are, however, several constructions proposed as desirable extensions to unification grammars that cannot be defined in a general and well-defined way in these formalisms. One such class of constructions is those that have some degree of nonmonotonic behaviour. Examples of such constructions are any-values, default-values, and some constructions (e.g. constraining equations, completeness and coherence) used in LFG (Kaplan and Bresnan, 1983). Th</context>
</contexts>
<marker>Stromback, 1994</marker>
<rawString>Lena Stromback. 1994. Achieving Flexibility in Unification Grammars. In Proceedings of the 15th International Conference on Computational Linguistics, Vol. 3, pages 842-846, Kyoto, Japan.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Mark A Young</author>
<author>Bill Rounds</author>
</authors>
<title>A Logical Semantics for Nonmonotonic Sorts.</title>
<date>1993</date>
<booktitle>In Proceedings of the 1993 Conference of the Association for Computational Linguistics,</booktitle>
<pages>209--215</pages>
<contexts>
<context position="1589" citStr="Young and Rounds, 1993" startWordPosition="228" endWordPosition="231">owever, several constructions proposed as desirable extensions to unification grammars that cannot be defined in a general and well-defined way in these formalisms. One such class of constructions is those that have some degree of nonmonotonic behaviour. Examples of such constructions are any-values, default-values, and some constructions (e.g. constraining equations, completeness and coherence) used in LFG (Kaplan and Bresnan, 1983). This paper describes a method that permits the user to define such nonmonotonic constructions. This is done through generalizing the work on nonmonotonic sorts (Young and Rounds, 1993). This generalization results in a default logic similar to (Reiter, 1980), but where subsumption and unification are used instead of logical truth and consistency. There are three main advantages to Young and Rounds&apos; work compared with other approaches to default unification (Houma, 1990; Bouma, 1992; Russel et al., 1992) which justify choosing it as a starting point for this work. The first is the separation of definite and default information, where Young and Rounds are more distinct than the other. The second is that the nonmonotonic unification operation used is order independent. This is</context>
<context position="9285" citStr="Young and Rounds (1993)" startWordPosition="1519" endWordPosition="1522">order independent nonmonotonic unification operator. This is the case because we follow Young and Rounds&apos; approach and separate the unification operation from the explanation of a nonmonotonic rule. Therefore, what affects the final result of a computation is when one chooses to explain default rules and not the order of the unification operations occurring between such explanations. 64 4 Formal Definitions In this section I provide give the formal definitions for nonmonotonic sorts and how nonmonotonic sorts are unified and explained. The definitions are generalizations of the definitions in Young and Rounds (1993). The notation a — b is used to denote the fact that a n b does not yield unification failure. A nonmonotonic sort is a structure containing both information from the basic subsumption order and information about default rules to be explained at a later point in the computation. Definition 1 A nonmonotonic sort is a pair (s, A) where s E S and A is a set of nonmonotonic rules of the form (w, a : -y) where w is an atom and a, # and -y E S. It is assumed that for each nonmonotonic rule 7 C #, a s, 8, and 7 n s c s. As seen by the definition a nonmonotonic sort is considered to be a pair of monot</context>
<context position="12514" citStr="Young and Rounds (1993)" startWordPosition="2100" endWordPosition="2103">s, and -y n s C s} The nonmonotonic unification is computed by computing the unification of the monotonic parts of the two sorts and then taking the union of their nonmonotonic parts. The extra conditions used when forming the union of the nonmonotonic parts of the sorts are the same as in the definition of a nonmonotonic sort and their purpose is to remove nonmonotonic rules that are no longer applicable, or would have no effect when applied to the sort resulting from the unification. It is important to note that this generalization of the original definition of nonmonotonic unification from Young and Rounds (1993) preserves the property of order independence for default unification. When using nonmonotonic sorts containing nonmonotonic rules, we also need to know how to merge the monotonic and nonmonotonic information within the sort. I will use the terminology wapplication for applying one nonmonotonic rule to the sort and w-explanation when applying all possible rules. Definition 3 The nonmonotonic rule (w, a : [3 =7) is w-applicable to s E S if: • s a • s—flors=fail • sn-yCsors= fail The result of the w-application is 7 n s Note that the w in w-application should be considered as a variable. This me</context>
<context position="15505" citStr="Young and Rounds, 1993" startWordPosition="2635" endWordPosition="2638">formalisms, the aim is to derive failure if the resulting structure does not fulfill some particular conditions. This makes it important to allow fail to be the result of applying a nonmonotonic rule. 5 Examples In this section I will show how some of the most common nonmonotonic extensions to unificationbased grammar can be expressed by defining rules as above. I will start with defining default values. This is done by defining a nonmonotonic rule default for the class value, which is assumed to be the most general class in a defined hierarchy. The rule defined here is treated as the one in (Young and Rounds, 1993). class value; nonmon def ault (X) : immediat e :X =&gt; X This default rule can be used when defining verbs. The rule is used for stating that verbs are active by default. I also define the two Swedish verbs skickade (sent) and skickades (was sent) to illustrate how this rule works. class verb; isa value; requires [form: default(active)] . class skickade; isa verb; requires [lex: skicka]. class skickades; isa verb; requires [lex: skicka, form: passive]. While retrieving the information for these two verbs we will obtain the following two feature structures containing nonmonotonic sorts: For skic</context>
<context position="26222" citStr="Young and Rounds, 1993" startWordPosition="4396" endWordPosition="4399">hat the nonmonotonic rule above should be applied if V This can be generalized to the case where is a nonmonotonic rule if we extend the definition of to also mean that the application (or explanation) of the not rule at this node does not yield failure. However, this generalization is outside default logic. Therefore, its computational properties are unclear and needs more investigation. 8 Conclusion In this paper I have proposed a method allowing the user to define nonmonotonic operations in a unification-based grammar formalism. This was done by generalizing the work on nonmonotonic sorts (Young and Rounds, 1993) to allow not only normal defaults rules but general default rules that are defined by the user. The method has a very close relation to Reiter (1980). We also noted that the method can be applied to all domains of structures where we have a defined subsumption order and unification operation. The generality of the approach was demonstrated by defining some of the most commonly used nonmonotonic operations. We also gave formal definitions for the approach and provided a discussion on its computational properties. Acknowledgments This work has been supported by the Swedish Research Council for </context>
</contexts>
<marker>Young, Rounds, 1993</marker>
<rawString>Mark A Young and Bill Rounds. 1993. A Logical Semantics for Nonmonotonic Sorts. In Proceedings of the 1993 Conference of the Association for Computational Linguistics, pages 209-215</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>