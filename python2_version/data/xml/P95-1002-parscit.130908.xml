<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000112">
<title confidence="0.862797">
Automatic Induction of Finite State Transducers for Simple Phonological Rules
</title>
<author confidence="0.986622">
Daniel Gildea and Daniel Jurafsky
</author>
<affiliation confidence="0.9893615">
International Computer Science Institute and
University of California at Berkeley
</affiliation>
<email confidence="0.983083">
{ gildeajurafsky} @icsi.berkeley.edu
</email>
<sectionHeader confidence="0.993692" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.99996956">
This paper presents a method for learning
phonological rules from sample pairs of un-
derlying and surface forms, without negative
evidence. The learned rules are represented as
finite state transducers that accept underlying
forms as input and generate surface forms as
output. The algorithm for learning them is an
extension of the OSTIA algorithm for learn-
ing general subsequential finite state transduc-
ers. Although OSTIA is capable of learning
arbitrary sl.s.t&apos;s in the limit, large dictionaries
of actual English pronunciations did not give
enough samples to correctly induce phonolog-
ical rules. We then augmented OSTIA with
two kinds of knowledge specific to natural lan-
guage phonology, biases from &amp;quot;universal gram-
mar&amp;quot;. One bias is that underlying phones are
often realized as phonetically similar or iden-
tical surface phones. The other biases phono-
logical rules to apply across natural phonolog-
ical classes. The additions helped in learning
more compact, accurate, and general transduc-
ers than the unmodified OSTIA algorithm. An
implementation of the algorithm successfully
learns a number of English postlexical rules.
</bodyText>
<sectionHeader confidence="0.99888" genericHeader="keywords">
1 Introduction
</sectionHeader>
<bodyText confidence="0.999922666666667">
Johnson (1972) first observed that traditional phonolog-
ical rewrite rules can be expressed as regular relations
if one accepts the constraint that no rule may reapply
directly to its own output. This means that finite state
transducers can be used to represent phonological rules,
greatly simplifying the problem of parsing the output of
phonological rules in order to obtain the underlying, lex-
ical forms (Karttunen 1993). In this paper we explore an-
other consequence of FST models of phonological rules:
their weaker generative capacity also makes them easier
to learn. We describe our preliminary algorithm for learn-
ing rules from sample pairs of input and output strings,
and the results we obtained.
In order to take advantage of recent work in transducer
induction, we have chosen to represent rules as subse-
quential finite state transducers. Subsequential finite
state transducers are a subtype of finite state transduc-
ers with the following properties:
</bodyText>
<listItem confidence="0.99250225">
1. The transducer is deterministic, that is, there is only
one arc leaving a given state for each input symbol.
2. Each time a transition is made, exactly one symbol
of the input string is consumed.
3. A unique end of string symbol is introduced. At the
end of each input string, the transducer makes an
additional transition on the end of string symbol.
4. All states are accepting.
</listItem>
<bodyText confidence="0.901096428571429">
The length of the output strings associated with a subse-
quential transducer&apos;s transitions is not constrained.
The subsequential transducer for the English flapping
rule in 1 is shown in Figure 1; an underlying t is realized
as a flap after a stressed vowel and any number of r&apos;s, and
before an unstressed vowel.
(1) t dx /12. r* V
</bodyText>
<sectionHeader confidence="0.983283" genericHeader="introduction">
2 The OSTIA Algorithm
</sectionHeader>
<bodyText confidence="0.999271473684211">
Our phonological-rule induction algorithm is based on
augmenting the Onward Subsequential Transducer Infer-
ence Algorithm (OSTIA) of Oncina et al. (1993). This
section outlines the OSTIA algorithm to provide back-
ground for the modifications that follow.
OSTIA takes as input a training set of input-output
pairs. The algorithm begins by constructing a tree trans-
ducer which covers all the training samples. The root of
the tree is the transducer&apos;s initial state, and each leaf of
the tree corresponds to the end of an input sample.
The output symbols are placed as near the root of the
tree as possible while avoiding conflicts in the output of
a given arc. An example of the result of this initial tree
construction is shown in Figure 2.
At this point, the transducer covers all and only the
strings of the training set. OSTIA now attempts to gen-
eralize the transducer, by merging some of its states to-
gether. For each pair of states (s, t) in the transducer, the
algorithm will attempt to merge s with t, building a new
</bodyText>
<page confidence="0.99679">
9
</page>
<figureCaption confidence="0.998812">
Figure 2: Onward Tree Transducer for &amp;quot;bat&amp;quot;, &amp;quot;batter&amp;quot;, and &amp;quot;band&amp;quot; with Flapping Applied
Figure 1: Subsequential Transducer for English Flap-
</figureCaption>
<listItem confidence="0.766764333333333">
ping: Labels on arcs are of the form (input sym-
bol):(output symbol). Labels with no colon indicate the
same input and output symbols. &apos;V&apos; indicates any un-
stressed vowel, &apos;&apos; any stressed vowel, `dx&apos; a flap, and
&apos;C&apos; any consonant other than T , &apos;r&apos; or `dx&apos; . &apos;#&apos; is the
end of string symbol.
</listItem>
<bodyText confidence="0.82373275">
state with all of the incoming and outgoing transitions of
s and t. The result of the first merging operation on the
transducer of Figure 2 is shown in Figure 3, and the end
result of the OSTIA alogrithm in shown in Figure 4.
</bodyText>
<sectionHeader confidence="0.924113" genericHeader="method">
3 Problems Using OSTIA to learn
</sectionHeader>
<subsectionHeader confidence="0.748516">
Phonological Rules
</subsectionHeader>
<bodyText confidence="0.99943975">
The OSTIA algorithm can be proven to learn any subse-
quential relation in the limit. That is, given an infinite
sequence of valid input/output pairs, it will at some point
derive the target transducer from the samples seen so
</bodyText>
<figureCaption confidence="0.998016">
Figure 3: Result of Merging States 0 and 1 of Figure 2
</figureCaption>
<bodyText confidence="0.98523">
far. However, when trying to learn phonological rules
from linguistic data, the necessary training set may not
be available. In particular, systematic phonological con-
straints such as syllable structure may rule out the neces-
sary strings. The algorithm does not have the language
bias which would allow it to avoid linguistically unnatural
transducers.
</bodyText>
<figureCaption confidence="0.9975795">
Figure 4: Final Result of Merging Process on Transducer
from Figure 2
</figureCaption>
<bodyText confidence="0.999687222222222">
For example, OSTIA&apos;s tendency to produce overly
&amp;quot;clumped&amp;quot; transducers is illustrated by the arcs with out
&amp;quot;b ae&amp;quot; and &amp;quot;n d&amp;quot; in the transducer in Figure 4, or even Fig-
ure 2. OST1A&apos;s default behavior is to emit the remainder
of the output string for a transduction as soon as enough
input symbols have been seen to uniquely identify the
input string in the training set. This results in machines
which may, seemingly at random, insert or delete se-
quences of four or five phonemes, something which is
</bodyText>
<equation confidence="0.999113625">
b : b ae
ae : 0
n:nd
d : 0
# : 0
er : dx er
# : t
t : 0
</equation>
<page confidence="0.948065">
10
</page>
<bodyText confidence="0.999227047619048">
linguistically implausible. In addition, the incorrect dis-
tribution of output symbols prevents the optimal merging
of states during the learning process, resulting in large
and inaccurate transducers.
Another example of an unnatural generalization is
shown in 4, the final transducer induced by OSTIA on
the three word training set of Figure 2. For example, the
transducer of Figure 4 will insert an &apos;ae&apos; after any &apos;b&apos;,
and delete any &apos;ae&apos; from the input. Perhaps worse, it will
fail completely upon seeing any symbol other than &apos;er&apos; or
end-of-string after a &apos;t&apos;. While it might be unreasonable
to expect any transducer trained on three samples to be
perfect, the transducer of Figure 4 illustrates on a small
scale how the OSTIA algorithm might be improved.
Similarly, if the OSTIA algorithm is training on cases
of flapping in which the preceding environment is ev-
ery stressed vowel but one, the algorithm has no way
of knowing that it can generalize the environment to all
stressed vowels. The algorithm needs knowledge about
classes of phonemes to fill in accidental gaps in training
data coverage.
</bodyText>
<sectionHeader confidence="0.940554" genericHeader="method">
4 Using Alignment Information
</sectionHeader>
<bodyText confidence="0.930640545454546">
Our first modification of OSTIA was to add the bias that,
as a default, a phoneme is realized as itself, or as a sim-
ilar phone. Our algorithm guesses the most probable
phoneme to phoneme alignment between the input and
output strings, and uses this information to distribute the
output symbols among the arcs of the initial tree trans-
ducer. This is demonstrated for the word &amp;quot;importance&amp;quot;
in Figures 5 and 6.
ih m p oal r t ah n s
I H 1 /III
ih m p oal dx ah n t s
</bodyText>
<figureCaption confidence="0.9709145">
Figure 5: Alignment of &amp;quot;importance&amp;quot; with flapping, r-
deletion and t-insertion
</figureCaption>
<bodyText confidence="0.999958">
The modification proceeds in two stages. First, a
dynamic programming method is used to compute a
correspondence between input and output phonemes.
The alignment uses the algorithm of Wagner &amp; Fischer
(1974), which calculates the insertions, deletions, and
substitutions which make up the minimum edit distance
between the underlying and surface strings. The costs of
edit operations are based on phonetic features; we used 26
binary articulatory features. The cost function for sub-
stitutions was equal to the number of features changed
between the two phonemes. The cost of insertions and
deletions was 6 (roughly one quarter the maximum pos-
sible substitution cost). From the sequence of edit opera-
tions, a mapping of output phonemes to input phonemes
is generated according to the following rules:
</bodyText>
<listItem confidence="0.917721">
• Any phoneme maps to an input phoneme for which
it substitutes
• Inserted phonemes map to the input phoneme im-
mediately following the first substitution to the left
of the inserted phoneme
</listItem>
<bodyText confidence="0.999933523809524">
Second, when adding a new arc to the tree, all the un-
used output phonemes up to and including those which
map to the arc&apos;s input phoneme become the new ar-
c&apos;s output, and are now marked as having been used.
When walking down branches of the tree to add a new
input/output sample, the longest common prefix, n, of the
sample&apos;s unused output and the output of each arc is cal-
culated. The next n symbols of the transduction&apos;s output
are now marked as having been used. If the length, 1, of
the arc&apos;s output string is greater than n, it is necessary to
push back the last 1— n symbols onto arcs further down
the tree. A tree transducer constructed by this process
is shown in Figure 7, for comparison with the unaligned
version in Figure 2.
Results of our alignment algorithm are summarized in
§6. The denser distribution of output symbols resulting
from the alignment constrains the merging of states early
in the merging loop of the algorithm. Interestingly, pre-
venting the wrong states from merging early on allows
more merging later, and results in more compact trans-
ducers.
</bodyText>
<sectionHeader confidence="0.863377" genericHeader="method">
5 Generalizing Behavior With Decision
Trees
</sectionHeader>
<bodyText confidence="0.999902363636364">
In order to allow OSTIA to make natural generalizations
in its rules, we added a decision tree to each state of the
machine, describing the behavior of that state. For exam-
ple, the decision tree for state 2 of the machine in Figure
1 is shown in Figure 8. Note that if the underlying phone
is an unstressed vowel ([-cons,-stressp, the machine out-
puts a flap, followed by the underlying vowel, otherwise
it outputs a &apos;t&apos; followed by the underlying phone.
The decision trees describe the behavior of the machine
at a given state in terms of the next input symbol by
generalizing from the arcs leaving the state. The decision
trees classify the arcs leaving each state based on the arc&apos;s
input symbol into groups with the same behavior. The
same 26 binary phonetic features used in calculating edit
distance were used to classify phonemes in the decision
trees. Thus the branches of the decision tree are labeled
with phonetic feature values of the arc&apos;s input symbol,
and the leaves of the tree correspond to the different
behaviors. By an arc&apos;s behavior, we mean its output
string considered as a function of its input phoneme, and
its destination state. Two arcs are considered to have the
same behavior if they agree each of the following:
</bodyText>
<listItem confidence="0.999826833333333">
• the index i of the output symbol corresponding to
the input symbol (determined from the alignment
procedure)
• the difference of the phonetic feature vectors of the
input symbol and symbol i of the output string
• the prefix of length i — 1 of the output string
</listItem>
<page confidence="0.953075">
11
</page>
<equation confidence="0.634813714285714">
oal : oal 0
0
0
r : 0 t:dx°ah:ah n:n s:ts0
0 0 49 0 0
ih : ih m: m
P P
</equation>
<figureCaption confidence="0.929661666666667">
Figure 6: Resulting initial transducer for &amp;quot;importance&amp;quot;
Figure 7: Initial Tree Transducer Constructed with Alignment Information: Note that output symbols have been pushed
back across state 3 during the construction
</figureCaption>
<bodyText confidence="0.968375">
of phonemes, that is, a set of phonemes that can be de-
scribed by specifying values for some subset of the pho-
netic features. Thus if we think of the transducer as a
set of rewrite rules, we can now express the context of
each rule as a regular expression of natural classes of
preceding phonemes.
</bodyText>
<figure confidence="0.927440333333333">
• cons
stress
1 tense
/
stress
1
2
2
Outcomes:
</figure>
<listItem confidence="0.9604734">
1: Output: dx [ ], Destination State: 0
2: Output: t [ ], Destination State: 0
3: On end of string: Output: t, Destination State: 0
Figure 8: Example Decision Tree: This tree describes the
behavior of State 2 of the transducer in Figure 1. [ ] in
the output string indicates the arc&apos;s input symbol (with
no features changed).
• the suffix of the output string beginning at position
i+ 1
• the destination state
</listItem>
<bodyText confidence="0.998316666666667">
After the process of merging states terminates, a deci-
sion tree is induced at each state to classify the outgoing
arcs. Figure 9 shows a tree induced at the initial state of
the transducer for flapping.
Using phonetic features to build a decision tree guar-
antees that each leaf of the tree represents a natural class
</bodyText>
<equation confidence="0.938831875">
rounded 2
w—offglide y—offglide
\
2 prim—stress high 1
\+
1 2 2 prim—stress
\-1-
Outcomes: 1 2
</equation>
<listItem confidence="0.858719666666667">
1: Output: [ ], Destination State: 0
2: Output: [ ], Destination State: 1
On end of string: Output: nil, Destination State: 0
</listItem>
<figureCaption confidence="0.9860975">
Figure 9: Decision Tree Before Pruning: The initial state
of the flapping transducer
</figureCaption>
<bodyText confidence="0.952854">
Some induced transducers may need to be generalized
even further, since the input transducer to the decision
</bodyText>
<page confidence="0.997167">
12
</page>
<bodyText confidence="0.999782615384615">
tree learning may have arcs which are incorrect merely
because of accidental prior structure. Consider again the
English flapping rule, which applies in the context of a
preceding stressed vowel. Our algorithm first learned a
transducer whose decision tree is shown in Figure 9. In
this transducer all arcs leaving state 0 correctly lead to the
flapping state on stressed vowels, except for those stressed
vowels which happen not to have occurred in the training
set. For these unseen vowels (which consisted of the
rounded diphthongs &apos;oy&apos; and `ow&apos; with secondary stress),
the transducers incorrectly returns to state 0. In this case,
we wish the algorithm to make the generalization that the
rule applies after all stressed vowels.
</bodyText>
<figure confidence="0.8998325">
stress
1 2
</figure>
<figureCaption confidence="0.994579">
Figure 10: The Same Decision Tree After Pruning
</figureCaption>
<bodyText confidence="0.999724227272727">
This type of generalization can be accomplished by
pruning the decision trees at each state of the machine.
Pruning is done by stepping through each state of the
machine and pruning as many decision nodes as possible
at each state. The entire training set of transductions is
tested after each branch is pruned. If any errors are found,
the outcome of the pruned node&apos;s other child is tested. If
errors are still found, the pruning operation is reversed.
This process continues at the fringe of the decision tree
until no more pruning is possible. Figure 10 shows the
correct decision. tree for flapping, obtained by pruning the
tree in Figure 9.
The process of pruning the decision trees is compli-
cated by the fact that the pruning operations allowed at
one state depend on the status of the trees at each other
state. Thus it is necessary to make several passes through
the states, attempting additional pruning at each pass, un-
til no more improvement is possible. In addition, testing
each pruning operation against the entire training set is
expensive, but in the case of synthetic data it gives the
best results. For other applications it may be desirable to
keep a cross validation set for this purpose.
</bodyText>
<sectionHeader confidence="0.999772" genericHeader="evaluation">
6 Results and Discussion
</sectionHeader>
<bodyText confidence="0.946874428571428">
We tested our induction algorithm using a synthetic cor-
pus of 99,279 input/output pairs. Each pair consisted of
an underlying and a surface pronunciation of an individ-
ual word of English. The underlying string of each pair
was taken from the phoneme-based CMU pronunciation
dictionary. The surface string was generated from each
underlying form by mechanically applying the one or
more rules we were attempting to induce in each experi-
ment.
In our first experiment, we applied the flapping rule
in (2) to training corpora of between 6250 and 50,000
words. Figure 11 shows the transducer induced from
50,000 training samples, and Figure 12 shows some per-
formance results.
</bodyText>
<figure confidence="0.635233">
(2) t dx If7r* _V
</figure>
<figureCaption confidence="0.9703585">
Figure 11: Flapping Transducer Induced from 50,000
Samples
</figureCaption>
<table confidence="0.996873833333333">
OSTIA w/o Alignment OSTIA w/ Alignment
Samples States % Error States % Error
6250 19 2.32 3 0.34
12500 257 16.40 3 0.14
25000 141 4.46 3 0.06
50000 192 3.14 3 0.01
</table>
<figureCaption confidence="0.9624335">
Figure 12: Results Using Alignment Information on En-
glish Flapping
</figureCaption>
<bodyText confidence="0.996877476190476">
As can be seen from Figure 12, the use of alignment
information in creating the initial tree transducer dra-
matically decreases the number of states in the learned
transducer as well as the error performance on test data.
The improved algorithm induced a flapping transducer
with the minimum number of states with as few as 6250
samples. The use of alignment information also reduced
the learning time; the additional cost of calculating align-
ments is more than compensated for by quicker merging
of states.
The algorithm also successfully induced transducers
with the minimum number of states for the t-insertion
and t-deletion rules below, given only 6250 samples.
In our second experiment, we applied our learning
algorithm to a more difficult problem: inducing multiple
rules at once. A data set was constructed by applying
the t-insertion rule in (3), the t-deletion rule in (4) and
the flapping rule already seen in (2) one after another.
As is seen in Figure 13, a transducer of minimum size
(five states) was obtained with 12500 or more sample
transductions.
</bodyText>
<listItem confidence="0.942438333333333">
(3) 0 t 1 n_s
(4) t 01 n_[+vocalic
—stress
</listItem>
<bodyText confidence="0.970835">
The effects of adding decision tress at each state of the
machine for the composition oft-insertion, t-deletion and
flapping are shown in Figure 14.
</bodyText>
<equation confidence="0.967883">
:t V
C : t C
r : t r V :dxV
# :t
</equation>
<page confidence="0.987896">
13
</page>
<figure confidence="0.961769">
Samples
6250
12500
25000
50000
</figure>
<figureCaption confidence="0.936349">
Figure 13: Results on Three Rules Composed
</figureCaption>
<figure confidence="0.9914782">
Method
OSTIA
Alignment
Add D-trees
Prune D-trees
</figure>
<figureCaption confidence="0.971031166666667">
Figure 14: Results on Three Rules Composed 12,500
Training, 49,280 Test
Figure 15 shows the final transducer induced from this
corpus of 12,500 words with pruned decision trees.
Figure 15: Three Rule Transducer Induced from 12,500
Samples
</figureCaption>
<bodyText confidence="0.999982928571429">
An examination of the few errors (three samples) in
the induced flapping and three-rule transducers points
out a flaw in our model. While the learned transducer
correctly makes the generalization that flapping occurs
after any stressed vowel, it does not flap after two stressed
vowels in a row. This is possible because no samples
containing two stressed vowels in a row (or separated by
an &apos;r&apos;) immediately followed by a flap were in the training
data. This transducer will flap a &apos;t&apos; after any odd number
of stressed vowels, rather than simply after any stressed
vowel. Such a rule seems quite unnatural phonologically,
and makes for an odd context-sensitive rewrite rule. Any
sort of simplest hypothesis criterion applied to a system
of rewrite rules would prefer a rule such as
</bodyText>
<equation confidence="0.998277">
t —+ dx1f/.____ V
t dx/IVI-0*._ V
</equation>
<bodyText confidence="0.999978714285714">
which is the equivalent of the transducer learned from
the training data. This suggests that, the traditional for-
malism of context-sensitive rewrite rules contains im-
plicit generalizations about how phonological rules usu-
ally work that are not present in the transducer system.
We hope that further experimentation will lead to a way
of expressing this language bias in our induction system.
</bodyText>
<sectionHeader confidence="0.999973" genericHeader="related work">
7 Related Work
</sectionHeader>
<bodyText confidence="0.989366428571429">
Johnson (1984) gives one of the first computational al-
gorithms for phonological rule induction. His algorithm
works for rules of the form
(5) a bIC
where C is the feature matrix of the segments around
a. Johnson&apos;s algorithm sets up a system of constraint
equations which C must satisfy, by considering both the
positive contexts, i.e., all the contexts Ci in which a b
occurs on the surface, as well as all the negative contexts
Ci in which an a occurs on the surface. The set of all
positive and negative contexts will not generally deter-
mine a unique rule, but will determine a set of possible
rules.
Touretzky et al. (1990) extended Johnson&apos;s insight by
using the version spaces algorithm of Mitchell (1981) to
induce phonological rules in their Many Maps architec-
ture. Like Johnson&apos;s, their system looks at the underly-
ing and surface realizations of single segments. For each
segment, the system uses the version space algorithm to
search for the proper statement of the context.
Riley (1991) and Withgott &amp; Chen (1993) first pro-
posed a decision-tree approach to segmental mapping. A
decision tree is induced for each phoneme, classifying
possible realizations of the phoneme in terms of contex-
tual factors such as stress and the surrounding phonemes.
However, since the decision tree for each phoneme is
learned separately, the the technique misses generaliza-
tions about the behavior of similar phonemes. In addi-
tion, no generalizations are made about similar context
phonemes. In a transducer based formalism, general-
izations about similar context phonemes naturally follow
from generalizations about individual phonemes&apos; behav-
ior, as the context is represented by the current state of
the machine, which in turn depends on the behavior of
the machine on the previous phonemes.
We hope that our hybrid model will be more successful
at learning long distance dependencies than the simple
decision tree approach. To model long distance rules such
as vowel harmony in a simple decision tree approach, one
must add more distant phonemes to the features used to
learn the decision tree. In a transducer, this information
is represented in the current state of the transducer.
</bodyText>
<figure confidence="0.999677333333333">
V:dx[]
C:t[] V,C,r,n
r:t[] s:t[
n:t[]
OSTIA w/Alignment to a rule such as
States % Error
6 0.93
5 0.20
5 0.09
5 0.04
States % Error
329 22.09
5 0.20
5 0.04
5 0.01
</figure>
<page confidence="0.991286">
14
</page>
<sectionHeader confidence="0.995367" genericHeader="conclusions">
8 Conclusion
</sectionHeader>
<bodyText confidence="0.999887066666667">
Inferring finite state transducers seems to hold promise as
a method for learning phonological rules. Both of our ini-
tial augmentations of OSTIA to bias it toward phonologi-
cal naturalness improve performance. Using information
on the alignment between input and output strings al-
lows the algorithm to learn more compact, more accurate
transducers. The addition of decision trees at each state
of the resulting transducer further improves accuracy and
results in phonologically more natural transducers. We
believe that further and more integrated uses of phonolog-
ical naturalness, such as generalizing across similar phe-
nomena at different states of the transducer, interleaving
the merging of states and generalization of transitions,
and adding memory to the model of transduction, could
help even more.
Our current algorithm and most previous algorithms
are designed for obligatory rules. These algorithms fail
completely when faced with optional, probabilistic rules,
such as flapping. This is the advantage of probabilistic
approaches such as the Riley/Withgott approach. One
area we hope to investigate is the generalization of our
algorithm to probabilistic rules with probabilistic finite-
state transducers, perhaps by augmenting PFST induction
techniques such as Stolcke &amp; Omohundro (1994) with
insights from phonological naturalness.
Besides aiding in the development of a practical tool
for learning phonological rules, our results point to the
use of constraints from universal grammar as a strong
factor in the machine and possibly human learning of
natural language phonology.
</bodyText>
<sectionHeader confidence="0.992179" genericHeader="acknowledgments">
Acknowledgments
</sectionHeader>
<bodyText confidence="0.554203666666667">
Thanks to Jerry Feldman, Eric Fosler, Isabel Galiano-Ronda,
Lauri Karttunen, Jose Oncina,Andreas Stolcke, and Gary Tajch-
man. This work was partially funded by ICSI.
</bodyText>
<sectionHeader confidence="0.98737" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999766771428572">
JOHNSON, C. DOUGLAS. 1972. Formal Aspects of Phono-
logical Description. The Hague: Mouton.
JOHNSON, MARK. 1984. A discovery procedure for
certain phonological rules. In Proceedings of the
Tenth International Conference on Computational
Linguistics, 344-347, Stanford.
KARTTUNEN, LAURI. 1993. Finite-state constraints. In
The Last Phonological Rule, ed. by John Goldsmith.
University of Chicago Press.
MITCHELL, TOM M. 1981. Generalization as search.
In Readings in Artificial Intelligence, ed. by Bon-
nie Lynn Webber &amp; Nils J. Nilsson, 517-542. Los
Altos: Morgan Kaufmann.
ONCINA, Jose, PEDRO GARCIA, &amp; ENRIQUE VIDAL.
1993. Learning subsequential transducers for pat-
tern recognition tasks. IEEE Transactions on Pattern
Analysis and Machine Intelligence 15.448-458.
RILEY, MICHAEL D. 1991. A statistical model for gener-
ating pronunciation networks. In IEEE ICASSP-91,
737-740.
STOLCICE, ANDREAS, &amp; STEPHEN OMOHUNDRO. 1994.
Best-first model merging for hidden Markov model
induction. Technical Report TR-94-003, Interna-
tional Computer Science Institute, Berkeley, CA.
TOURETZKY, DAVID S., GILLETTE ELVGREN III, &amp;
DEIRDRE W. WHEELER. 1990. Phonological rule
induction: An architectural solution. In Proceed-
ings of the 12th Annual Conference of the Cognitive
Science Society (COGSCI-90), 348-355.
WAGNER, R. A., &amp; M. J. FISCHER. 1974. The string-to-
string correction problem. Journal of the Associa-
tion for Computation Machinery 21.168-173.
WITHGOTT, M. M., &amp; F. R. CHEN. 1993. Computation
Models of American Speech. Center for the Study
of Language and Information.
</reference>
<page confidence="0.997932">
15
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.980411">
<title confidence="0.99996">Automatic Induction of Finite State Transducers for Simple Phonological Rules</title>
<author confidence="0.999968">Daniel Gildea</author>
<author confidence="0.999968">Daniel Jurafsky</author>
<affiliation confidence="0.9979255">International Computer Science Institute and University of California at Berkeley</affiliation>
<email confidence="0.989358">{ gildeajurafsky} @icsi.berkeley.edu</email>
<abstract confidence="0.999810730769231">This paper presents a method for learning phonological rules from sample pairs of underlying and surface forms, without negative evidence. The learned rules are represented as finite state transducers that accept underlying forms as input and generate surface forms as output. The algorithm for learning them is an extension of the OSTIA algorithm for learning general subsequential finite state transducers. Although OSTIA is capable of learning arbitrary sl.s.t&apos;s in the limit, large dictionaries of actual English pronunciations did not give enough samples to correctly induce phonological rules. We then augmented OSTIA with two kinds of knowledge specific to natural language phonology, biases from &amp;quot;universal grammar&amp;quot;. One bias is that underlying phones are often realized as phonetically similar or identical surface phones. The other biases phonological rules to apply across natural phonological classes. The additions helped in learning more compact, accurate, and general transducers than the unmodified OSTIA algorithm. An implementation of the algorithm successfully learns a number of English postlexical rules.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>C DOUGLAS JOHNSON</author>
</authors>
<title>Formal Aspects of Phonological Description.</title>
<date>1972</date>
<publisher>The Hague: Mouton.</publisher>
<marker>JOHNSON, 1972</marker>
<rawString>JOHNSON, C. DOUGLAS. 1972. Formal Aspects of Phonological Description. The Hague: Mouton.</rawString>
</citation>
<citation valid="true">
<authors>
<author>MARK JOHNSON</author>
</authors>
<title>A discovery procedure for certain phonological rules.</title>
<date>1984</date>
<booktitle>In Proceedings of the Tenth International Conference on Computational Linguistics,</booktitle>
<pages>344--347</pages>
<location>Stanford.</location>
<marker>JOHNSON, 1984</marker>
<rawString>JOHNSON, MARK. 1984. A discovery procedure for certain phonological rules. In Proceedings of the Tenth International Conference on Computational Linguistics, 344-347, Stanford.</rawString>
</citation>
<citation valid="true">
<authors>
<author>LAURI KARTTUNEN</author>
</authors>
<title>Finite-state constraints.</title>
<date>1993</date>
<booktitle>In The Last Phonological Rule,</booktitle>
<editor>ed. by John Goldsmith.</editor>
<publisher>University of Chicago Press.</publisher>
<marker>KARTTUNEN, 1993</marker>
<rawString>KARTTUNEN, LAURI. 1993. Finite-state constraints. In The Last Phonological Rule, ed. by John Goldsmith. University of Chicago Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>TOM M MITCHELL</author>
</authors>
<title>Generalization as search.</title>
<date>1981</date>
<booktitle>In Readings in Artificial Intelligence,</booktitle>
<pages>517--542</pages>
<editor>ed. by Bonnie Lynn Webber &amp; Nils J. Nilsson,</editor>
<publisher>Morgan Kaufmann.</publisher>
<location>Los Altos:</location>
<marker>MITCHELL, 1981</marker>
<rawString>MITCHELL, TOM M. 1981. Generalization as search. In Readings in Artificial Intelligence, ed. by Bonnie Lynn Webber &amp; Nils J. Nilsson, 517-542. Los Altos: Morgan Kaufmann.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jose ONCINA</author>
<author>PEDRO GARCIA</author>
<author>ENRIQUE VIDAL</author>
</authors>
<title>Learning subsequential transducers for pattern recognition tasks.</title>
<date>1993</date>
<journal>IEEE Transactions on Pattern Analysis and Machine Intelligence</journal>
<pages>15--448</pages>
<marker>ONCINA, GARCIA, VIDAL, 1993</marker>
<rawString>ONCINA, Jose, PEDRO GARCIA, &amp; ENRIQUE VIDAL. 1993. Learning subsequential transducers for pattern recognition tasks. IEEE Transactions on Pattern Analysis and Machine Intelligence 15.448-458.</rawString>
</citation>
<citation valid="true">
<authors>
<author>MICHAEL D RILEY</author>
</authors>
<title>A statistical model for generating pronunciation networks.</title>
<date>1991</date>
<booktitle>In IEEE ICASSP-91,</booktitle>
<pages>737--740</pages>
<marker>RILEY, 1991</marker>
<rawString>RILEY, MICHAEL D. 1991. A statistical model for generating pronunciation networks. In IEEE ICASSP-91, 737-740.</rawString>
</citation>
<citation valid="true">
<authors>
<author>ANDREAS STOLCICE</author>
<author>STEPHEN OMOHUNDRO</author>
</authors>
<title>Best-first model merging for hidden Markov model induction.</title>
<date>1994</date>
<tech>Technical Report TR-94-003,</tech>
<institution>International Computer Science Institute,</institution>
<location>Berkeley, CA.</location>
<marker>STOLCICE, OMOHUNDRO, 1994</marker>
<rawString>STOLCICE, ANDREAS, &amp; STEPHEN OMOHUNDRO. 1994. Best-first model merging for hidden Markov model induction. Technical Report TR-94-003, International Computer Science Institute, Berkeley, CA.</rawString>
</citation>
<citation valid="true">
<authors>
<author>DAVID S TOURETZKY</author>
<author>GILLETTE ELVGREN</author>
<author>DEIRDRE W WHEELER</author>
</authors>
<title>Phonological rule induction: An architectural solution.</title>
<date>1990</date>
<booktitle>In Proceedings of the 12th Annual Conference of the Cognitive Science Society (COGSCI-90),</booktitle>
<pages>348--355</pages>
<marker>TOURETZKY, ELVGREN, WHEELER, 1990</marker>
<rawString>TOURETZKY, DAVID S., GILLETTE ELVGREN III, &amp; DEIRDRE W. WHEELER. 1990. Phonological rule induction: An architectural solution. In Proceedings of the 12th Annual Conference of the Cognitive Science Society (COGSCI-90), 348-355.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R A WAGNER</author>
<author>M J FISCHER</author>
</authors>
<title>The string-tostring correction problem.</title>
<date>1974</date>
<journal>Journal of the Association for Computation Machinery</journal>
<pages>21--168</pages>
<marker>WAGNER, FISCHER, 1974</marker>
<rawString>WAGNER, R. A., &amp; M. J. FISCHER. 1974. The string-tostring correction problem. Journal of the Association for Computation Machinery 21.168-173.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M M WITHGOTT</author>
<author>F R CHEN</author>
</authors>
<title>Computation Models of American Speech. Center for the Study of Language and Information.</title>
<date>1993</date>
<marker>WITHGOTT, CHEN, 1993</marker>
<rawString>WITHGOTT, M. M., &amp; F. R. CHEN. 1993. Computation Models of American Speech. Center for the Study of Language and Information.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>