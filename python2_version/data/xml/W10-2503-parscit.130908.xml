<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<title confidence="0.997022">
Parsing and Translation Algorithms
Based on Weighted Extended Tree Transducers
</title>
<author confidence="0.997645">
Andreas Maletti* Giorgio Satta
</author>
<affiliation confidence="0.966519333333333">
Departament de Filologies Rom`aniques Department of Information Engineering
Universitat Rovira i Virgili University of Padua
Tarragona, Spain Padua, Italy
</affiliation>
<sectionHeader confidence="0.979107" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999949375">
This paper proposes a uniform frame-
work for the development of parsing and
translation algorithms for weighted ex-
tended (top-down) tree transducers and in-
put strings. The asymptotic time complex-
ity of these algorithms can be improved
in practice by exploiting an algorithm for
rule factorization in the above transducers.
</bodyText>
<sectionHeader confidence="0.998429" genericHeader="introduction">
1 Introduction
</sectionHeader>
<bodyText confidence="0.995994233333334">
In the field of statistical machine translation, con-
siderable interest has recently been shown for
translation models based on weighted tree trans-
ducers. In this paper we consider the so-called
weighted extended (top-down) tree transducers
(WXTTs for short). WXTTs have been proposed
by Graehl and Knight (2004) and Knight (2007)
and are rooted in similar devices introduced ear-
lier in the formal language literature (Arnold and
Dauchet, 1982).
WXTTs have enough expressivity to represent
hierarchical syntactic analyses for natural lan-
guage sentences and can directly model most of
the elementary operations that rule the process
of translation between natural languages (Knight,
2007). Furthermore, the use of weights and in-
ternal states allows the encoding of statistical pa-
rameters that have recently been shown to be ex-
tremely useful in discriminating likely translations
from less plausible ones.
For an WXTT M, the parsing problem is tradi-
tionally defined for a pair of trees t and u and re-
quires as output some representation of the set of
all computations of M that map t into u. Similarly,
the translation problem for M is defined for an in-
put tree t and requires as output some representa-
tion of the set of all computations of M mapping t
*Financially supported by the Ministerio de Educaci´on y
Ciencia (MEC) grant JDCI-2007-760.
into any other tree. When we deal with natural
language processing applications, however, pars-
ing and translation are most often represented on
the basis of input strings rather than trees. Some
tricks are then applied to map the problem back
to the case of input trees. As an example in the
context of machine translation, let w be some in-
put string to be translated. One can intermediately
construct a tree automaton M,,, that recognizes the
set of all possible trees that have w as yield with
internal nodes from the input alphabet of M. This
automaton M,,, is further transformed into a tree
transducer implementing a partial identity trans-
lation. This transducer is then composed with M
(relational composition) to obtain a transducer that
represents all translations of w. This is usually
called the ‘cascaded’ approach.
In contrast with the cascaded approach above,
which may be rather inefficient, we investigate a
more direct technique for both parsing and transla-
tion of strings based on WXTTs. We do this by ex-
tending to WXTTs the well-known BAR-HILLEL
construction defined for context-free grammars
(Bar-Hillel et al., 1964) and for weighted context-
free grammars (Nederhof and Satta, 2003). We
then derive computational complexity results for
parsing and translation of input strings on the ba-
sis of WXTTs. Finally, we develop a novel fac-
torization algorithm for WXTTs that, in practical
applications, can reduce the asymptotic complex-
ity for such problems.
</bodyText>
<sectionHeader confidence="0.985304" genericHeader="method">
2 Preliminary definitions
</sectionHeader>
<bodyText confidence="0.999081571428572">
Let • be an associative binary operation on a set S.
If S contains an element 1 such that 1-s = s = s-1
for every s E S, then (S, •,1) is a monoid. Such
a monoid (S, •,1) is commutative if the identity
s1 •s2 = s2 •s1 holds for all s1, s2 E S. A commu-
tative semiring (S, +, , 0,1) is an algebraic struc-
ture such that:
</bodyText>
<listItem confidence="0.926516">
• (S, +, 0) and (S, •,1) are commutative
</listItem>
<page confidence="0.991048">
19
</page>
<note confidence="0.9870285">
Proceedings of the 2010 Workshop on Applications of Tree Automata in Natural Language Processing, ACL 2010, pages 19–27,
Uppsala, Sweden, 16 July 2010. c�2010 Association for Computational Linguistics
</note>
<bodyText confidence="0.568635">
monoids,
</bodyText>
<listItem confidence="0.994325076923077">
• · distributes over + (from both sides), and
• s · 0 = 0 = 0 · s for every s E S.
From now on, let (S,+,·,0,1) be a com-
mutative semiring. An alphabet is a finite
set of symbols. A weighted string automa-
ton [WSA] (Sch¨utzenberger, 1961; Eilenberg,
1974) is a system N = (P, F, J, ν, F) where
• P and F are alphabets of states and input
symbols, respectively,
• J, F : P —* S assign initial and final weights,
respectively, and
• ν : P x F x P —* S assigns a weight to each
transition.
</listItem>
<bodyText confidence="0.999301">
The transition weight mapping ν can be under-
stood as square matrices ν(·, γ, ·) E SP&amp;quot;P for ev-
ery γ E F. The WSA N is deterministic if
</bodyText>
<listItem confidence="0.9891445">
• J(p) =� 0 for at most one p E P and
• for every p E P and γ E F there exists at
</listItem>
<bodyText confidence="0.7700485">
most one p&apos; E P such that ν(p,γ, p&apos;) =� 0.
We now proceed with the semantics of N. We
will define the initial algebra semantics here; al-
ternative, equivalent definitions of the semantics
exist (Sakarovitch, 2009). Let w E F&apos; be an in-
put string, γ E F, and p, p&apos; E P be two states.
We extend ν to a mapping hν : P x F&apos; x P —* S
recursively as follows:
</bodyText>
<equation confidence="0.954653285714286">
hν(p, γw, p&apos;) = X ν(p,γ,p&apos;&apos;) · hν(p&apos;&apos;,w,p&apos;) .
p00EP
Consequently,
Xhν(p, uw, p&apos;) = hν(p, u, p&apos;&apos;) · hν(p&apos;&apos;, w, p&apos;)
p00EP
for all p, p&apos; E P and u, w E F&apos;. Then the matrix
hν(·,γ1 ···γk, ·) equals ν(·,γ1, ·) · ... · ν(·,γk, ·).
</equation>
<bodyText confidence="0.999159875">
Thus, if the semiring operations can be performed
in constant time and access to ν(p, γ, q) is in con-
stant time for every p, q E P, then for every
w E F&apos; we can compute the matrix hν(·, w, ·) in
time O(|w |· |P|3) because it can be computed by
|w |− 1 matrix multiplications.
The WSA N computes the map N : F&apos; —* S,
which is defined for every w E F&apos; by1
</bodyText>
<equation confidence="0.9872335">
N(w) = X J(p) · hν(p, w, p&apos;) · F(p&apos;) .
p,p0EP
</equation>
<footnote confidence="0.617417">
1We overload the symbol N to denote both the WSA and
its recognized mapping. However, the intended meaning will
always be clear from the context.
</footnote>
<bodyText confidence="0.998223888888889">
Since we will also consider individual runs,
let us recall the run semantics as well. Let
w = γ1 · · · γk E F&apos; be an input string of length k.
Then any mapping r: [0, k] —* P is a run of N
on w, where [0, k] denotes the set of integers be-
tween (inclusive) 0 and k. A run can be under-
stood as a vector of states and thus we some-
times write ri instead of r(i). The weight of
such a run r, denoted by wtN(r), is defined by
</bodyText>
<equation confidence="0.9966525">
wtN(r) = Qki=1 ν(ri−1,γi, ri). Then
Xhν(p, w, p&apos;) = wtN(r)
r: [0,k]→P
r0=p,rk=p0
</equation>
<bodyText confidence="0.886984">
for every p, p&apos; E P and w E F&apos;.
</bodyText>
<sectionHeader confidence="0.987465" genericHeader="method">
3 Weighted extended tree transducers
</sectionHeader>
<bodyText confidence="0.968437">
Next, we move to tree languages, for which we
need to introduce some additional notation. Let
E be a ranked alphabet, that is, an alphabet
whose symbols have a unique associated arity. We
write Ek to denote the set of all k-ary symbols
in E. We use the special nullary symbol e E E0 to
syntactically represent the empty string ε. The set
of E-trees indexed by a set V , denoted by TE(V ),
is the smallest set satisfying both of the following
conditions:
</bodyText>
<listItem confidence="0.980657">
• for every v E V , the single node labeled v,
written v, is a tree of TE(V ),
• for every σ E Ek and t1, ... , tk E TE(V ),
the tree with a root node labeled σ and
trees t1, ... , tk as its k children, written
σ(t1, ... , tk), belongs to TE(V ).
</listItem>
<bodyText confidence="0.985757">
Throughout this paper we sometimes write σ() as
just σ. In the following, let t E TE(V ). The set
of positions Pos(t) C N&apos; of a tree t E TE(V ) is
recursively defined as follows:
</bodyText>
<equation confidence="0.9997955">
Pos(v) = {ε}
Pos(t) = {ε} U {iw  |1 G i G k, w E Pos(ti)}
</equation>
<bodyText confidence="0.984086333333333">
for every v E V , σ E Ek, and t1, ... , tk E TE(V )
where t = σ(t1, ... , tk). The label of t at posi-
tion w E Pos(t) is denoted by t(w). The size of
the tree t E TE is defined as |t |= |Pos(t)|. For
every w E Pos(t) the subtree of t that is rooted
at w is denoted by subt(w); i.e.,
</bodyText>
<equation confidence="0.996228285714286">
subt(ε) = t
subσ(t1,...,tk)(iw) = subti(w)
hν(p,ε,p&apos;) =
e
(
1 ifp=p&apos;
0 otherwis
</equation>
<page confidence="0.901061">
20
</page>
<bodyText confidence="0.761068333333333">
for every σ ∈ Ek, t1, ... , tk ∈ TΣ(V ), 1 ≤ i ≤ k,
and w ∈ Pos(ti). Finally, the set of vari-
ables var(t) is given by
</bodyText>
<equation confidence="0.9946">
var(t) = {v ∈ V  |∃w ∈ Pos(t): t(w) = v} .
</equation>
<bodyText confidence="0.870605333333333">
If for every v ∈ var(t) there exists exactly one
w ∈ Pos(t) such that t(w) = v, then t is linear.
We use the fixed sets X = {xi  |i ≥ 1} and
</bodyText>
<equation confidence="0.739275777777778">
Y = {yi,j  |1 ≤ i &lt; j} of formal variables
and the subsets Xk = {xi  |1 ≤ i ≤ k} and
Yk = {yi,j  |1 ≤ i &lt; j ≤ k} for every k ≥ 0.
Note that X0 = ∅. For every H ⊆ E0 ∪X ∪Y , the
H-yield of t is recursively defined by ydH(t) = t
if t ∈ H \ {e}, ydH(t) = ydH(t1) · · · ydH(tk) if
t = σ(t1, ... , tk) with σ ∈ Ek and k ≥ 1, and
ydH(t) = ε otherwise. If H = E0 ∪ X ∪ Y , then
we also omit the index and just write yd(t).
</equation>
<bodyText confidence="0.871547833333333">
Let l ∈ TΣ(V ) and θ: V → TΣ(V ). Then
lθ denotes the result obtained from l by replacing
every occurrence of v ∈ V by θ(v). The k-fold
application is denoted by lθk. If lθk = lθk+1 for
some k ≥ 0, then we denote lθk by lθ*. In addi-
tion, if V = Xk, then we write l[θ(x1), ... , θ(xk)]
instead of lθ. We write CΣ(Xk) for the subset
of those trees of TΣ(Xk) such that every vari-
able of x ∈ Xk occurs exactly once in it. Given
t ∈ TΣ(X), we write dec(t) for the set
{(l,t1,. . . , tk) �l ∈ CΣ(Xk), l [t1, ... , tk] = t,1
t1,...,tk ∈ TΣ(X) J
</bodyText>
<listItem confidence="0.993375307692308">
A (linear and nondeleting) weighted extended
(top-down) tree transducer [WXTT] (Arnold and
Dauchet, 1975; Arnold and Dauchet, 1976; Lilin,
1981; Arnold and Dauchet, 1982; Maletti et al.,
2009) is a system M = (Q, E, A, I, R) where
• Q is an alphabet of states,
• E and A are ranked alphabets of input and
output symbols, respectively,
• I : Q → S assigns initial weights, and
• R is a finite set of rules of the form
(q, l) → s (q1 ··· qk, r) with q, q1, ... , qk ∈ Q,
l ∈ CΣ(Xk) and r ∈ CΔ(Xk), and s ∈ S
such that {l, r} ⊆6 X.
</listItem>
<bodyText confidence="0.999125142857143">
Let us discuss the final restriction imposed on
the rules of a WXTT. Essentially, it disallows rules
of the form (q, x1) s→ (q&apos;, x1) with q, q&apos; ∈ Q and
s ∈ S. Such pure epsilon rules only change the
state and charge a cost. However, they can yield
infinite derivations (and with it infinite products
and sums) and are not needed in our applications.
The WXTT M is standard if ydX(r) = x1 · · · xk
for every (q, l) →s (q1 · · · qk, r) ∈ R. This restric-
tion enforces that the order of the variables is fixed
on the right-hand side r, but since the order is ar-
bitrary in the left-hand side l (and the names of the
variables are inconsequential), it can be achieved
easily without loss of generality. If there are sev-
eral rules that differ only in the naming of the vari-
ables, then their weights should be added to obtain
a single standard rule. To keep the presentation
simple, we also construct nonstandard WXTTs in
the sequel. However, we implicitly assume that
those are converted into standard WXTTs.
The semantics of a standard WXTT is in-
spired by the initial-algebra semantics for classi-
cal weighted top-down and bottom-up tree trans-
ducers (F¨ul¨op and Vogler, 2009) [also called top-
down and bottom-up tree series transducers by En-
gelfriet et al. (2002)]. Note that our semantics
is equivalent to the classical term rewriting se-
mantics, which is presented by Graehl and Knight
(2004) and Graehl et al. (2008), for example. In
fact, we will present an equivalent semantics based
on runs later. Let M = (Q, E, A, I, R) be a
WXTT. We present a definition that is more gen-
eral than immediately necessary, but the general-
ization will be useful later on. For every n ∈ N,
p1, ... , pn ∈ Q, and L ⊆ R, we define the
</bodyText>
<equation confidence="0.954922818181818">
mapping hp1···pn
L : TΣ(Xn) × TΔ(Xn) → SQ by
hp1···pn
L (xi, xi)pi = 1 for every 1 ≤ i ≤ n and
hp1···pn
L (t, u)q
hp1···pn
L (ti, ui)qi (1)
(l,t1,...,tk)Edec(t)
(r,u1,...,uk)Edec(u)
(q,l) 3,(q1···qk,r)EL
</equation>
<bodyText confidence="0.9964413125">
for all remaining t ∈ TΣ(Xn), u ∈ TΔ(Xn), and
q ∈ Q. Note that for each nonzero summand in (1)
one of the decompositions dec(t) and dec(u) must
be proper (i.e., either l ∈/ X or r ∈/ X). This
immediately yields that the sum is finite and the
recursion well-defined. The transformation com-
puted by M, also denoted by M, is the map-
ping M : TΣ × TΔ → S, which is defined by
M(t, u) = EqEQ I(q)·hR(t, u)q for every t ∈ TΣ
and u ∈ TΔ.
Let us also introduce a run semantics for the
WXTT (Q, E, A, I, R). The rank of a rule
ρ = (q, l) →s (q1 · · · qk, r) ∈ R, denoted by rk(ρ),
is rk(ρ) = k. This turns R into a ranked alphabet.
The input state of ρ is in(ρ) = q, the ith output
state is outi(ρ) = qi for every 1 ≤ i ≤ k, and
</bodyText>
<equation confidence="0.9793705">
= �
k
s ·
i=1
</equation>
<page confidence="0.985861">
21
</page>
<bodyText confidence="0.99518625">
the weight of ρ is wt(ρ) = s. A tree r ∈ TR(X)
is called run if in(r(wi)) = outi(r(w)) for every
wi ∈ Pos(r) and 1 ≤ i ≤ rk(r(w)) such that
r(wi) ∈ R. The weight of a run r ∈ TR(X) is
</bodyText>
<equation confidence="0.995684">
�wt(r) = wt(r(w)) .
w∈Pos(r),r(w)∈R
</equation>
<bodyText confidence="0.9997688">
The evaluation mappings π1: TR(X) → TE(X)
and π2: TR(X) → TA(X) are defined for every
x ∈ X, ρ = (q, l) s→ (q1 · · · qk, r) ∈ R, and
r1, ... , rk ∈ TR(X) by π1(x) = x, π2(x) = x,
and
</bodyText>
<equation confidence="0.6080075">
π1(ρ(r1, ... , rk)) = l[π1(r1), ... , π1(rk)]
π2(ρ(r1, ... , rk)) = r[π2(r1), ... ,π2(rk)] .
</equation>
<bodyText confidence="0.99627">
We obtain the weighted tree transformation for ev-
ery t ∈ TE and u ∈ TA as follows2
</bodyText>
<equation confidence="0.998092333333333">
M(t, u) = � I(in(r(ε))) · wt(r) .
run r∈TR
t=π1(r),u=π2(r)
</equation>
<bodyText confidence="0.997266">
This approach is also called the bimorphism ap-
proach (Arnold and Dauchet, 1982) to tree trans-
formations.
</bodyText>
<sectionHeader confidence="0.943327" genericHeader="method">
4 Input and output restrictions of WXTT
</sectionHeader>
<bodyText confidence="0.997137714285714">
In this section we will discuss the BAIL-HILLEL
construction for the input and the output part of a
WXTT M. This construction essentially restricts
the input or output of the WXTT M to the string
language recognized by a WSA N. Contrary to
(direct or inverse) application, this construction
is supposed to yield another WXTT. More pre-
cisely, the constructed WXTT should assign to
each translation (t, u) the weight assigned to it
by M multiplied by the weight assigned by N
to the yield of t (or u if the output is restricted).
Since our WXTTs are symmetric, we will actu-
ally only need one construction. Let us quickly
establish the mentioned symmetry statement. Es-
sentially we just have to exchange left- and right-
hand sides and redistribute the states in those left-
and right-hand sides accordingly.
From now on, let M = (Q, E, A, I, R) be a
WXTT.
Theorem 1. There exists a WXTT M0 such that
M0(u, t) = M(t, u) for every t ∈ TE and u ∈ TA.
</bodyText>
<footnote confidence="0.995264">
2We immediately also use M for the run semantics be-
cause the two semantics trivially coincide.
</footnote>
<equation confidence="0.665494333333333">
Proof. Let M0 = (Q, A, E, I, R0) be the WXTT
such that
R0 = {(q, r) s→ (w, l)  |(q, l) → s(w, r) ∈ R} .
</equation>
<bodyText confidence="0.842286785714286">
It should be clear that M0(u, t) = M(t, u) for ev-
ery t ∈ TE and u ∈ TA.
With the symmetry established, we now only
need to present the BAIL-HILLEL construction for
either the input or output side. Without loss of
generality, let us assume that M is standard. We
then choose the output side here because the order
of variables is fixed in it. Note that we sometimes
use the angled parentheses ‘h’ and ‘i’ instead of
parentheses for clarity.
Definition 2. Let N = (P, F, J, ν, F) be a WSA
with F = Ao \ {e}. We construct the output prod-
uct Prod(M, N) = (P ×Q×P, E, A, I0, R0) such
that
</bodyText>
<listItem confidence="0.999731">
• I0(hp,q,p0i) = J(p) · I(q) · F(p0) for every
p,p0 ∈ P and q ∈ Q,
• for every rule (q, l) →s (q1 · · · qk, r) ∈ R and
every po, . . . , pk, p0�, . . . , p0k ∈ P, let
</listItem>
<equation confidence="0.74969625">
(q0, l) s·s�·...·s�
−−−−−→ (q01 ··· q0k, r) ∈ R0
where
– q0 = hpo,q,p0ki,
– q0i = hp0i−1, qi, pii for every 1 ≤ i ≤ k,
– yd(r) = wox1w1 · · · wk−1xkwk with
wO, ... , wk ∈ F∗, and
– si = hν(pi, wi, p0i) for every 0 ≤ i ≤ k.
</equation>
<bodyText confidence="0.99337625">
Let ρ = (q, l) → s(q1 · · · qk, r) ∈ R. The
size of ρ is |ρ |= |l |+ |r|. The size and
rank of the WXTT M are |M |= Eρ∈R|ρ|
and rk(M) = maxρ∈R rk(ρ), respectively. Fi-
nally, the maximal output yield length of M, de-
noted by len(M), is the maximal length of yd(r)
for all rules (q, l) s→ (q1 · · · qk, r) ∈ R.
The size and rank of Prod(M, N) are in
O(|M |· |P|2 rk(M)+2) and rk(M), respec-
tively. We can compute Prod(M, N) in time
O(|R |· len(M) · |P|2 rk(M)+5). If N is de-
terministic, then the size of Prod(M, N) is
in O(|M |· |P|rk(M)+1) and the required time is
in O(|R|·len(M)·|P|rk(M)+1). Next, let us prove
that our BAIL-HILLEL construction is actually cor-
rect.
Theorem 3. Let M and N be as in Defini-
tion 2, and let M0 = Prod(M, N). Then
M0(t, u) = M(t, u) · N(yd(u)) for every t ∈ TE
and u ∈ TA.
</bodyText>
<page confidence="0.965559">
22
</page>
<bodyText confidence="0.715887">
Proof. Let M&apos; = (Q&apos;, E, A, I&apos;, R&apos;). First, a sim-
ple proof shows that
</bodyText>
<equation confidence="0.998885">
hR0(t,u)(p,q,p0) = hR(t,u)q · hν(p,yd(u),p&apos;)
</equation>
<bodyText confidence="0.630316">
for every t ∈ TE, u ∈ TA, q ∈ Q, and p, p&apos; ∈ P.
Now we can prove the main statement as follows:
</bodyText>
<equation confidence="0.949206666666667">
M&apos;(t, u)
I: = I&apos;(q&apos;) · hR0(t, u)q0
q0EQ0
I:
= I&apos;(hp,q,p&apos;i) · hR(t,u)q · hν(p,yd(u),p&apos;)
p,p0EP
qEQ
= M(t, u) · N(yd(u))
for every t ∈ TE and u ∈ TA.
</equation>
<bodyText confidence="0.998245684210526">
Note that the typical property of many BAR-
HILLEL constructions, namely that a run of M
and a run of N uniquely determine a run
of Prod(M, N) and vice versa, does not hold for
our construction. In fact, a run of M and a run
of N uniquely determine a run of Prod(M, N),
but the converse does not hold. We could modify
the construction to enable this property at the ex-
pense of an exponential increase in the number of
states of Prod(M, N). However, since those re-
lations are important for our applications, we ex-
plore the relation between runs in some detail here.
To simplify the discussion, we assume, without
loss of generality, that M is standard and s = s&apos;
for every two rules (q, l) →s (w, r) ∈ R and
(q, l) s0 → (w, r) ∈ R. Moreover, we assume the
symbols of Definition 2. For every r&apos; ∈ TR0(X),
we let base(r&apos;) denote the run obtained from r&apos; by
replacing each symbol
</bodyText>
<equation confidence="0.9891625">
(q&apos;,l) s�s��...�s�
−−−−−→ (q&apos;1 ···q&apos;k,r)
</equation>
<bodyText confidence="0.98374775">
by just (q, l) →s (q1 · · · qk, r) ∈ R. Thus, we re-
place a rule (which is a symbol) of R&apos; by the un-
derlying rule of R. We start with a general lemma,
which we believe to be self-evident.
</bodyText>
<construct confidence="0.834573">
Lemma 4. Let r&apos; ∈ TR0 and n = |yd(72(r&apos;))|.
Then wtM0(r&apos;) = wtM(base(r&apos;))·ErER00 wtN(r)
where R&apos;&apos; is a nonempty subset of
{r: [0, n] → P  |in(r&apos;(E)) = hro, q, rni}.
</construct>
<bodyText confidence="0.9709688">
Let us assume that N is trim (i.e., all states are
reachable and co-reachable) and unambiguous. In
this case, for every -y1 · · · -yk ∈ F* and p, p&apos; ∈ P
there is at most one successful run r: [0, k] → P
such that
</bodyText>
<listItem confidence="0.999682">
• v(ri_1, -yi, ri) =6 0 for every 1 ≤ i ≤ k, and
• ro = p and rk = p&apos;.
</listItem>
<bodyText confidence="0.978075333333333">
This immediately yields the following corollary.
Corollary 5 (of Lemma 4). Let N be trim and
unambiguous. For every r&apos; ∈ TR0 we have
</bodyText>
<equation confidence="0.9689215">
wtM0(r&apos;) = wtM(base(r&apos;)) · wtN(r)
for some r: [0, n] → P with n = |yd(7r2(r&apos;))|.
</equation>
<bodyText confidence="0.998671611111111">
We now turn to applications of the product con-
struction. We first consider the translation prob-
lem for an input string w and a WXTT M. We can
represent w as a trim and unambiguous WSA Nw
that recognizes the language {w} with weight
of 1 on each transition (which amounts to ignor-
ing the weight contribution of Nw). Then the in-
put product transducer Mw = Prod(Nw, M) pro-
vides a compact representation of the set of all
computations of M that translate the string w.
From Corollary 5 we have that the weights of
these computations are also preserved. Thus,
Mw(TE × TA) = E(t,u)ETEXT, Mw(t,u) is the
weight of the set of string translations of w.
As usual in natural language processing ap-
plications, we can exploit appropriate semirings
and compute several useful statistical parameters
through Mw(TE × TA), as for instance the high-
est weight of a computation, the inside probabil-
ity and the rule expectations; see (Li and Eisner,
2009) for further discussion.
One could also construct in linear time the range
tree automaton for Mw, which can be interpreted
as a parsing forest with all the weighted trees as-
signed to translations of w under M. If we fur-
ther assume that M is unambiguous, then Mw will
also have this property, and we can apply standard
techniques to extract from Mw the highest score
computation. In machine translation applications,
the unambiguity assumption is usually met, and
avoids the so-called ‘spurious’ ambiguity, that is,
having several computations for an individual pair
of trees.
The parsing problem for input strings w and u
can be treated in a similar way, by restricting M
both to the left and to the right.
</bodyText>
<sectionHeader confidence="0.989568" genericHeader="method">
5 Rule factorization
</sectionHeader>
<bodyText confidence="0.9998985">
As already discussed, the time complexity of the
product construction is an exponential function
of the rank of the transducer. Unfortunately,
it is not possible in the general case to cast a
</bodyText>
<page confidence="0.99571">
23
</page>
<bodyText confidence="0.995012633333333">
WXTT into a normal form such that the rank is
bounded by some constant. This is also expected
from the fact that the translation problem for sub-
classes of WXTTs such as synchronous context-
free grammars is NP-hard (Satta and Peserico,
2005). Nonetheless, there are cases in which a
rank reduction is possible, which might result in
an improvement of the asymptotical run-time of
our construction.
Following the above line, we present here a
linear time algorithm for reducing the rank of a
WXTT under certain conditions. Similar algo-
rithms for tree-based transformation devices have
been discussed in the literature. Nesson et al.
(2008) consider synchronous tree adjoining gram-
mars; their algorithm is conceptually very sim-
ilar to ours, but computationally more demand-
ing due to the treatment of adjunction. Follow-
ing that work, we also demand here that the new
WXTT ‘preserves’ the recursive structure of the
input WXTT, as formalized below. Galley et al.
(2004) algorithm also behaves in linear time, but
deals with the different problem of tree to string
translation. Rank reduction algorithms for string-
based translation devices have also been discussed
by Zhang et al. (2006) and Gildea et al. (2006).
Recall that M = (Q, E, 0, I, R) is a standard
WXTT. Let M0 = (Q0, E, 0, I0, R0) be a WXTT
with Q ⊆ Q0.3 Then M0 is a structure-preserving
factorization of M if
</bodyText>
<listItem confidence="0.995367333333333">
• I0(q) = I(q) for every q ∈ Q and I0(q) = 0
otherwise, and
• hp�···p�
</listItem>
<equation confidence="0.997242">
R&apos; (t, u)q = hp�···p�
R (t, u)q for every
</equation>
<bodyText confidence="0.6282864">
q, p1, ... , pn ∈ Q, t ∈ TE(Xn), and
u ∈ TA(Xn).
In particular, we have hR&apos;(t, u)q = hR(t, u)q for
n = 0. Consequently, M0 and M are equivalent
because
</bodyText>
<equation confidence="0.98924225">
M0(t, u) = � I0(q) · hR&apos;(t, u)q
q∈Q&apos;
�= I(q) · hR(t, u)q = M(t, u) .
q∈Q
</equation>
<bodyText confidence="0.999206238095238">
Note that the relation ‘is structure-preserving fac-
torization of’ is reflexive and transitive, and thus, a
pre-order. Moreover, in a ring (actually, additively
cancellative semirings are sufficient) it is also anti-
symmetric, and consequently, a partial order.
3Actually, an injective mapping Q --+ Q&apos; would be suffi-
cient, but since the naming of the states is arbitrary, we im-
mediately identify according to the injective mapping.
Informally, a structure-preserving factorization
of M consists in a set of new rules that can be com-
posed to provide the original rules and preserve
their weights. We develop an algorithm for finding
a structure-preserving factorization by decompos-
ing each rule as much as possible. The algorithm
can then be iterated for all the rules in the WXTT.
The idea underlying our algorithm is very simple.
Let ρ = (q, l) s→ (q1 · · · qk, r) ∈ R be an origi-
nal rule. We look for subtrees l0 and r0 of l and r,
respectively, such that var(l0) = var(r0). The con-
dition that var(l0) = var(r0) is derived from the
fact that hq�···qk
</bodyText>
<equation confidence="0.989125">
R (l0, r0)q = 0 if var(l0) =6 var(r0).
</equation>
<bodyText confidence="0.904172">
We then split ρ into two new rules by ‘excis-
ing’ subtrees l0 and r0 from l and r, respectively.
In the remaining trees the ‘excised’ trees are re-
placed with some fresh variable. The tricky part
is the efficient computation of the pairs (wl, wr),
since in the worst case the number of such pairs
is in O(|l |· |r|), and naive testing of the condition
var(l0) = var(r0) takes time O(rk(ρ)).
Let us start with the formal development. Recall
the doubly-indexed set Y = {yi,j  |1 ≤ i &lt; j}.
Intuitively speaking, the variable yi,j will
represent the set {xi, ... , xj}. With this
intuition in mind, we define the mapping
vars: TE(X ∪ Y ) → N3 as follows:
</bodyText>
<equation confidence="0.969021666666667">
∞
vars(xi) = (i, i,1)
vars(yi,j) = (i, j, j − i + 1)
</equation>
<bodyText confidence="0.637609">
and vars(σ(t1, ... , tk)) is
</bodyText>
<equation confidence="0.966064">
k
vars(t`)1, max
`=1
</equation>
<bodyText confidence="0.99858675">
for every i, j ∈ N with i &lt; j, σ ∈ Ek, and
t1, ... , tk ∈ TE(X ∪ Y ). Clearly, vars(t) can
be computed in time O(|t|), which also in-
cludes the computation of vars(u) for every sub-
tree u of t. In addition, vars(t)3 = |var(t)|
for all linear t ∈ TE(X). Finally, if
t ∈ TE(X), then vars(t)1 and vars(t)2 are the
minimal and maximal index i ∈ N such that
xi ∈ var(t), respectively (they are ∞ and 0,
respectively, if var(t) = ∅). For better read-
ability, we use minvar(t) and maxvar(t) for
vars(t)1 and vars(t)2, respectively.
Let ρ = (q, l) →s (q1 · · · qk, r) ∈ R be an origi-
nal rule. In the following, we will use minvar(t),
maxvar(t), and |var(t) |freely for all subtrees t
of l and r and assume that they are precomputed,
</bodyText>
<equation confidence="0.5305985">
k
(min
`=1
k
vars(t`)2, vars(t`)3)
`=1
</equation>
<page confidence="0.996661">
24
</page>
<bodyText confidence="0.999461666666667">
which can be done in time O(|ρ|). Moreover, we
will freely use the test ‘var(t) = var(u)’ for sub-
trees t and u of l and r, respectively. This test can
be performed in constant time [disregarding the
time needed to precompute vars(t) and vars(u)]
by the equivalent test
</bodyText>
<listItem confidence="0.99952325">
• minvar(t) = minvar(u),
• maxvar(t) = maxvar(u),
• |var(t) |= maxvar(t) − minvar(t) + 1, and
• |var(u) |= maxvar(u) − minvar(u) + 1.
</listItem>
<bodyText confidence="0.999138891891892">
Our factorization algorithm is presented in Al-
gorithm 1. Its first two parameters hold the left-
and right-hand side (l, r), which are to be decom-
posed. The third and fourth parameter should ini-
tially be x1. To simplify the algorithm, we assume
that it is only called with left- and right-hand sides
that (i) contain the same variables and (ii) contain
at least two variables. These conditions are en-
sured by the algorithm for the recursive calls. The
algorithm returns a decomposition of (l, r) in the
form of a set D ⊆ TE(X ∪ Y ) × To(X ∪ Y )
such that var(l0) = var(r0) for every (l0, r0) ∈ D.
Moreover, all such l0 and r0 are linear. Finally, the
pairs in D can be composed (by means of point-
wise substitution at the variables of Y ) to form the
original pair (l, r).
Before we move on to formal properties of Al-
gorithm 1, let us illustrate its execution on an ex-
ample.
Example 6. We work with the left-hand side
l = σ(x1, σ(x3, x2)) and the right-hand side
r = γ(σ(x1,γ(σ(x2,x3)))). Then |var(l) |≥ 2
and var(l) = var(r). Let us trace the call
DECOMPOSE(l, r, x1, x1). The condition in line 1
is clearly false, so we proceed with line 3. The
condition is true for i = 1, so we continue with
DECOMPOSE(l, σ(x1, γ(σ(x2, x3))), x1, γ(x1)).
This time neither the condition in line 1 nor the
condition in line 3 are true. In line 6, j is set to 1
and we initialize r01 = x1 and r02 = γ(σ(x2, x3)).
Moreover, the array h is initialized to h(1) = 1,
h(2) = 2, and h(3) = 2. Now let us discuss the
main loop starting in line 12 in more detail. First,
we consider i = 1. Since l1 = x1, the condition in
line 13 is fulfilled and we set l01 = x1 and proceed
with the next iteration (i = 2). This time the condi-
tion of line 13 is false because l2 = σ(x3, x2) and
</bodyText>
<equation confidence="0.979999333333334">
var(l2) = var(rh(2)) = var(r2) = {x2, x3}. Con-
sequently, j is set to 2 and l02 = r02 = y2,3. Next,
DECOMPOSE(σ(x3, x2), γ(σ(x2, x3)), x1, x1) is
processed. Let us suppose that it generates the
set D. Then we return
D ∪ {(σ(x1, y2,3),γ(σ(x1, y2,3)))} .
</equation>
<bodyText confidence="0.987159583333333">
Finally, let us quickly discuss how the set D
is obtained. Since the condition in line 3 is
true, we have to evaluate the recursive call
DECOMPOSE(σ(x3, x2), σ(x2, x3), x1, γ(x1)).
Now, j = 2, h(2) = 1, and h(3) = 2.
Moreover, r01 = x2 and r02 = x3. In the
main loop starting in line 12, the condition of
line 13 is always fulfilled, which yields that
l01 = x3 and l02 = x2. Thus, we return
{(σ(x3, x2), γ(σ(x2, x3)))}, which is exactly the
input because decomposition completely failed.
Thus, the overall decomposition of l and r is
</bodyText>
<equation confidence="0.5924365">
{(σ(x1, y2,3), γ(σ(x1, y2,3))),
(σ(x3, x2), γ(σ(x2, x3)))} ,
</equation>
<bodyText confidence="0.942214473684211">
which, when the second pair is substituted (point-
wise) for y2,3 in the first pair, yields exactly (l, r).
Informally, the rules are obtained as follows
from D. If all variables occur in a pair (l0, r0) ∈ D,
then the left-hand side is assigned to the original
input state. Furthermore, for every variable yi,j we
introduce a new fresh state qi,j whereas the vari-
able xi is associated to qi. In this way, we deter-
mine the states in the right-hand side.
Formally, let ρ = (q, l) → � (q1 ··· qk, r)
be the original rule and D be the result of
DECOMPOSE(l, r, x1, x1) of Algorithm 1. In ad-
dition, for every 1 ≤ i &lt; j ≤ k, let qp,i,j be a new
state such that qp,1,k = q. Let
Q0p = {q, q1, ... , qk} ∪ {qp,i,j  |1 ≤ i &lt; j ≤ k} .
Then for every (l0, r0) ∈ D we obtain the rule
0
(qp,minvar(r&apos;),maxvar(r&apos;), l) �&apos;→ (p1 ··· pn, r0)
where ydX∪Y (r0) = z1 · · · zn,
</bodyText>
<equation confidence="0.955682">
s0 =�s if vars(r0)3 = k
1 otherwise
�
qj if zt = xj
q0t =
qp,i,j if zt = yi,j
</equation>
<bodyText confidence="0.999837">
for every 1 ≤ ` ≤ n. The rules obtained in this
fashion are collected in R0p.4 The WXTT dec(M)
is dec(M) = (Q0, E, A, I0, R0) where
</bodyText>
<footnote confidence="0.9889265">
4Those rules need to be normalized to obtain a standard
WXTT.
</footnote>
<page confidence="0.996271">
25
</page>
<construct confidence="0.6147752">
Algorithm 1 DECOMPOSE(l, r, l&apos;, r&apos;) computing the decomposition of linear l E TE(Xk) and
r E TA(Xk) with var(l) = var(r) and |var(l) |&gt; 2.
if l = σ(l1, ... , lm) and there exists i E ICY is such that var(li) = var(l) then
2: return DECOMPOSE(li, r, l0[σ(l1, ... , li−1, x1, li+1, ... , lm)], r0[x1])
if r = δ(r1, . . . , rn) and there exists i E ICY is such that var(ri) = var(r) then
</construct>
<figure confidence="0.875443125">
4: return DECOMPOSE(l, ri, l0[x1], r0[δ(r1, ... , ri−1, x1, ri+1, ... , rn)])
let l = σ(l1, ... ,lm) and r = δ(r1, ... ,rn)
6: j = minvar(r)
for all 1 &lt; i &lt; n do
8: r0i = ri
while j &lt; maxvar(ri) do
10: h(j)=i;j=j+1
D = 0
12: for all 1 &lt; i &lt; m do
if Fvar(li)F &lt; 1 or var(li) =� var(rh(minvar(li))) then
14: l0i = li
else
16: j = h(minvar(li))
l0i = r0j = yminvar(li),maxvar(li)
18: D = D U DECOMPOSE(li, rj, x1, x1)
return D U {(l0[σ(l01, ... ,l0m)], r0[δ(r01, ... ,r0n)])}
</figure>
<listItem confidence="0.91518775">
• Q&apos; = Q U UPER,rk(P)&gt;2 Q&apos;P,
• I&apos;(q) = I(q) for every q E Q and I&apos;(q) = 0
otherwise, and
• R&apos; is
</listItem>
<equation confidence="0.953019666666667">
�
{p E R  |rk(p) &lt; 2} U
PER,rk(P)&gt;2
</equation>
<bodyText confidence="0.969752028571429">
To measure the success of the factorization, we
introduce the following notion. The degree of M,
denoted by deg(M), is the minimal rank of all
structure-preserving factorizations M&apos; of M; i.e.,
min
M0 a structure-preserving
factorization of M
Then the goal of this section is the efficient com-
putation of a structure-preserving factorization M&apos;
of M such that rk(M&apos;) = deg(M).
Theorem 7. The WXTT dec(M) is a structure-
preserving factorization of M such that
rk(dec(M)) = deg(M). Moreover, dec(M) can
be computed in time O(|M|).
Proof. Let us only discuss the run-time complex-
ity shortly. Clearly, DECOMPOSE(l, r, x1, x1)
should be called once for each rule
(q, l) __&apos;+ (q1 · · · qk, r) E R. In lines 1–4 the
structure of l and r is inspected and the prop-
erties var(li) = var(l) and var(ri) = var(r)
are tested in constant time. Mind that we pre-
computed vars(l) and vars(r), which can be
done in linear time in the size of the rule. Then
each subtree ri is considered in lines 7–10 in
constant time. Finally, we consider all direct input
subtrees li in lines 12–18. The tests involving
the variables are all performed in constant time
due to the preprocessing step that computes
vars(l) and vars(r). Moreover, at most one
recursive call to DECOMPOSE is generated for
each input subtree ti. So if we implement the
union in lines 18 and 19 by a constant-time
operation (such as list concatenation, which can
be done since it is trivially a disjoint union), then
we obtain the linear time-complexity.
</bodyText>
<sectionHeader confidence="0.983186" genericHeader="conclusions">
6 Concluding remarks
</sectionHeader>
<bodyText confidence="0.99971235">
In this paper we have shown how to restrict com-
putations of WXTTs to given input and output
WSA, and have discussed the relevance of this
technique for parsing and translation applications
over input strings, resulting in the computation of
translation forests and other statistical parameters
of interest. We have also shown how to factorize
transducer rules, resulting in an asymptotic reduc-
tion in the complexity for these algorithms.
In machine translation applications transduc-
ers usually have very large sets of rules. One
should then specialize the restriction construction
in such a way that the number of useless rules
for Prod(N,,,, M) is considerably reduced, result-
ing in a more efficient construction. This can be
achieved by grounding the construction of the new
rules by means of specialized strategies, as usually
done for parsing based on context-free grammars;
see for instance the parsing algorithms by Younger
(1967) or by Earley (1970).
</bodyText>
<equation confidence="0.92010175">
R&apos;
P .
deg(M) =
rk(M&apos;) .
</equation>
<page confidence="0.993424">
26
</page>
<sectionHeader confidence="0.993805" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999951436781609">
Andr´e Arnold and Max Dauchet. 1975. Transductions
inversibles de forˆets. Th`ese 3`eme cycle M. Dauchet,
Universit´e de Lille.
Andr´e Arnold and Max Dauchet. 1976. Bi-
transductions de forˆets. In ICALP, pages 74–86. Ed-
inburgh University Press.
Andr´e Arnold and Max Dauchet. 1982. Morphismes
et bimorphismes d’arbres. Theoret. Comput. Sci.,
20(1):33–93.
Yehoshua Bar-Hillel, Micha Perles, and Eliyahu
Shamir. 1964. On formal properties of simple
phrase structure grammars. In Yehoshua Bar-Hillel,
editor, Language and Information: Selected Essays
on their Theory and Application, chapter 9, pages
116–150. Addison Wesley.
Jay Earley. 1970. An efficient context-free parsing al-
gorithm. Commun. ACM, 13(2):94–102.
Samuel Eilenberg. 1974. Automata, Languages, and
Machines, volume 59 of Pure and Applied Math.
Academic Press.
Joost Engelfriet, Zolt´an F¨ul¨op, and Heiko Vogler.
2002. Bottom-up and top-down tree series transfor-
mations. J. Autom. Lang. Combin., 7(1):11–70.
Zolt´an F¨ul¨op and Heiko Vogler. 2009. Weighted tree
automata and tree transducers. In Manfred Droste,
Werner Kuich, and Heiko Vogler, editors, Hand-
book of Weighted Automata, EATCS Monographs on
Theoret. Comput. Sci., chapter IX, pages 313–403.
Springer.
Michel Galley, Mark Hopkins, Kevin Knight, and
Daniel Marcu. 2004. What’s in a translation rule?
In Proc. HLT-NAACL, pages 273–280. Association
for Computational Linguistics.
Daniel Gildea, Giorgio Satta, and Hao Zhang. 2006.
Factoring synchronous grammars by sorting. In
Proc. CoLing/ACL, pages 279–286. Association for
Computational Linguistics.
Jonathan Graehl and Kevin Knight. 2004. Training
tree transducers. In HLT-NAACL, pages 105–112.
Association for Computational Linguistics. See
also (Graehl et al., 2008).
Jonathan Graehl, Kevin Knight, and Jonathan May.
2008. Training tree transducers. Computational
Linguistics, 34(3):391–427.
Kevin Knight. 2007. Capturing practical natural
language transformations. Machine Translation,
21(2):121–133.
Zhifei Li and Jason Eisner. 2009. First- and second-
order expectation semirings with applications to
minimum-risk training on translation forests. In
Proc. EMNLP, pages 40–51. Association for Com-
putational Linguistics.
Eric Lilin. 1981. Propri´et´es de clˆoture d’une extension
de transducteurs d’arbres d´eterministes. In CAAP,
volume 112 of LNCS, pages 280–289. Springer.
Andreas Maletti, Jonathan Graehl, Mark Hopkins,
and Kevin Knight. 2009. The power of ex-
tended top-down tree transducers. SIAMJ. Comput.,
39(2):410–430.
Mark-Jan Nederhof and Giorgio Satta. 2003. Prob-
abilistic parsing as intersection. In Proc. IWPT,
pages 137–148. Association for Computational Lin-
guistics.
Rebecca Nesson, Giorgio Satta, and Stuart M. Shieber.
2008. Optimal k-arization of synchronous tree-
adjoining grammar. In Proc. ACL, pages 604–612.
Association for Computational Linguistics.
Jacques Sakarovitch. 2009. Rational and recognisable
power series. In Manfred Droste, Werner Kuich, and
Heiko Vogler, editors, Handbook of Weighted Au-
tomata, EATCS Monographs on Theoret. Comput.
Sci., chapter IV, pages 105–174. Springer.
Giorgio Satta and Enoch Peserico. 2005. Some
computational complexity results for synchronous
context-free grammars. In Proc. HLT-EMNLP,
pages 803–810. Association for Computational Lin-
guistics.
Marcel Paul Sch¨utzenberger. 1961. On the definition
of a family of automata. Information and Control,
4(2–3):245–270.
Daniel H. Younger. 1967. Recognition and parsing of
context-free languages in time n3. Inform. Control,
10(2):189–208.
Hao Zhang, Liang Huang, Daniel Gildea, and Kevin
Knight. 2006. Synchronous binarization for ma-
chine translation. In Proc. HLT-NAACL, pages 256–
263. Association for Computational Linguistics.
</reference>
<page confidence="0.998809">
27
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.986296">
<title confidence="0.9999425">Parsing and Translation Based on Weighted Extended Tree Transducers</title>
<author confidence="0.999905">Andreas Satta</author>
<affiliation confidence="0.9989685">Departament de Filologies Rom`aniques Department of Information Engineering Universitat Rovira i Virgili University of Padua</affiliation>
<address confidence="0.993643">Tarragona, Spain Padua, Italy</address>
<abstract confidence="0.999398111111111">This paper proposes a uniform framework for the development of parsing and translation algorithms for weighted extended (top-down) tree transducers and input strings. The asymptotic time complexity of these algorithms can be improved in practice by exploiting an algorithm for rule factorization in the above transducers.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Andr´e Arnold</author>
<author>Max Dauchet</author>
</authors>
<title>Transductions inversibles de forˆets.</title>
<date>1975</date>
<booktitle>Th`ese 3`eme cycle M. Dauchet, Universit´e de Lille.</booktitle>
<contexts>
<context position="9071" citStr="Arnold and Dauchet, 1975" startWordPosition="1785" endWordPosition="1788"> θ: V → TΣ(V ). Then lθ denotes the result obtained from l by replacing every occurrence of v ∈ V by θ(v). The k-fold application is denoted by lθk. If lθk = lθk+1 for some k ≥ 0, then we denote lθk by lθ*. In addition, if V = Xk, then we write l[θ(x1), ... , θ(xk)] instead of lθ. We write CΣ(Xk) for the subset of those trees of TΣ(Xk) such that every variable of x ∈ Xk occurs exactly once in it. Given t ∈ TΣ(X), we write dec(t) for the set {(l,t1,. . . , tk) �l ∈ CΣ(Xk), l [t1, ... , tk] = t,1 t1,...,tk ∈ TΣ(X) J A (linear and nondeleting) weighted extended (top-down) tree transducer [WXTT] (Arnold and Dauchet, 1975; Arnold and Dauchet, 1976; Lilin, 1981; Arnold and Dauchet, 1982; Maletti et al., 2009) is a system M = (Q, E, A, I, R) where • Q is an alphabet of states, • E and A are ranked alphabets of input and output symbols, respectively, • I : Q → S assigns initial weights, and • R is a finite set of rules of the form (q, l) → s (q1 ··· qk, r) with q, q1, ... , qk ∈ Q, l ∈ CΣ(Xk) and r ∈ CΔ(Xk), and s ∈ S such that {l, r} ⊆6 X. Let us discuss the final restriction imposed on the rules of a WXTT. Essentially, it disallows rules of the form (q, x1) s→ (q&apos;, x1) with q, q&apos; ∈ Q and s ∈ S. Such pure epsilo</context>
</contexts>
<marker>Arnold, Dauchet, 1975</marker>
<rawString>Andr´e Arnold and Max Dauchet. 1975. Transductions inversibles de forˆets. Th`ese 3`eme cycle M. Dauchet, Universit´e de Lille.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Andr´e Arnold</author>
<author>Max Dauchet</author>
</authors>
<title>Bitransductions de forˆets.</title>
<date>1976</date>
<booktitle>In ICALP,</booktitle>
<pages>74--86</pages>
<publisher>Edinburgh University Press.</publisher>
<contexts>
<context position="9097" citStr="Arnold and Dauchet, 1976" startWordPosition="1789" endWordPosition="1792">notes the result obtained from l by replacing every occurrence of v ∈ V by θ(v). The k-fold application is denoted by lθk. If lθk = lθk+1 for some k ≥ 0, then we denote lθk by lθ*. In addition, if V = Xk, then we write l[θ(x1), ... , θ(xk)] instead of lθ. We write CΣ(Xk) for the subset of those trees of TΣ(Xk) such that every variable of x ∈ Xk occurs exactly once in it. Given t ∈ TΣ(X), we write dec(t) for the set {(l,t1,. . . , tk) �l ∈ CΣ(Xk), l [t1, ... , tk] = t,1 t1,...,tk ∈ TΣ(X) J A (linear and nondeleting) weighted extended (top-down) tree transducer [WXTT] (Arnold and Dauchet, 1975; Arnold and Dauchet, 1976; Lilin, 1981; Arnold and Dauchet, 1982; Maletti et al., 2009) is a system M = (Q, E, A, I, R) where • Q is an alphabet of states, • E and A are ranked alphabets of input and output symbols, respectively, • I : Q → S assigns initial weights, and • R is a finite set of rules of the form (q, l) → s (q1 ··· qk, r) with q, q1, ... , qk ∈ Q, l ∈ CΣ(Xk) and r ∈ CΔ(Xk), and s ∈ S such that {l, r} ⊆6 X. Let us discuss the final restriction imposed on the rules of a WXTT. Essentially, it disallows rules of the form (q, x1) s→ (q&apos;, x1) with q, q&apos; ∈ Q and s ∈ S. Such pure epsilon rules only change the st</context>
</contexts>
<marker>Arnold, Dauchet, 1976</marker>
<rawString>Andr´e Arnold and Max Dauchet. 1976. Bitransductions de forˆets. In ICALP, pages 74–86. Edinburgh University Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Andr´e Arnold</author>
<author>Max Dauchet</author>
</authors>
<title>Morphismes et bimorphismes d’arbres.</title>
<date>1982</date>
<journal>Theoret. Comput. Sci.,</journal>
<volume>20</volume>
<issue>1</issue>
<contexts>
<context position="1054" citStr="Arnold and Dauchet, 1982" startWordPosition="150" endWordPosition="153">ut strings. The asymptotic time complexity of these algorithms can be improved in practice by exploiting an algorithm for rule factorization in the above transducers. 1 Introduction In the field of statistical machine translation, considerable interest has recently been shown for translation models based on weighted tree transducers. In this paper we consider the so-called weighted extended (top-down) tree transducers (WXTTs for short). WXTTs have been proposed by Graehl and Knight (2004) and Knight (2007) and are rooted in similar devices introduced earlier in the formal language literature (Arnold and Dauchet, 1982). WXTTs have enough expressivity to represent hierarchical syntactic analyses for natural language sentences and can directly model most of the elementary operations that rule the process of translation between natural languages (Knight, 2007). Furthermore, the use of weights and internal states allows the encoding of statistical parameters that have recently been shown to be extremely useful in discriminating likely translations from less plausible ones. For an WXTT M, the parsing problem is traditionally defined for a pair of trees t and u and requires as output some representation of the se</context>
<context position="9136" citStr="Arnold and Dauchet, 1982" startWordPosition="1795" endWordPosition="1798">lacing every occurrence of v ∈ V by θ(v). The k-fold application is denoted by lθk. If lθk = lθk+1 for some k ≥ 0, then we denote lθk by lθ*. In addition, if V = Xk, then we write l[θ(x1), ... , θ(xk)] instead of lθ. We write CΣ(Xk) for the subset of those trees of TΣ(Xk) such that every variable of x ∈ Xk occurs exactly once in it. Given t ∈ TΣ(X), we write dec(t) for the set {(l,t1,. . . , tk) �l ∈ CΣ(Xk), l [t1, ... , tk] = t,1 t1,...,tk ∈ TΣ(X) J A (linear and nondeleting) weighted extended (top-down) tree transducer [WXTT] (Arnold and Dauchet, 1975; Arnold and Dauchet, 1976; Lilin, 1981; Arnold and Dauchet, 1982; Maletti et al., 2009) is a system M = (Q, E, A, I, R) where • Q is an alphabet of states, • E and A are ranked alphabets of input and output symbols, respectively, • I : Q → S assigns initial weights, and • R is a finite set of rules of the form (q, l) → s (q1 ··· qk, r) with q, q1, ... , qk ∈ Q, l ∈ CΣ(Xk) and r ∈ CΔ(Xk), and s ∈ S such that {l, r} ⊆6 X. Let us discuss the final restriction imposed on the rules of a WXTT. Essentially, it disallows rules of the form (q, x1) s→ (q&apos;, x1) with q, q&apos; ∈ Q and s ∈ S. Such pure epsilon rules only change the state and charge a cost. However, they ca</context>
<context position="12865" citStr="Arnold and Dauchet, 1982" startWordPosition="2571" endWordPosition="2574">very wi ∈ Pos(r) and 1 ≤ i ≤ rk(r(w)) such that r(wi) ∈ R. The weight of a run r ∈ TR(X) is �wt(r) = wt(r(w)) . w∈Pos(r),r(w)∈R The evaluation mappings π1: TR(X) → TE(X) and π2: TR(X) → TA(X) are defined for every x ∈ X, ρ = (q, l) s→ (q1 · · · qk, r) ∈ R, and r1, ... , rk ∈ TR(X) by π1(x) = x, π2(x) = x, and π1(ρ(r1, ... , rk)) = l[π1(r1), ... , π1(rk)] π2(ρ(r1, ... , rk)) = r[π2(r1), ... ,π2(rk)] . We obtain the weighted tree transformation for every t ∈ TE and u ∈ TA as follows2 M(t, u) = � I(in(r(ε))) · wt(r) . run r∈TR t=π1(r),u=π2(r) This approach is also called the bimorphism approach (Arnold and Dauchet, 1982) to tree transformations. 4 Input and output restrictions of WXTT In this section we will discuss the BAIL-HILLEL construction for the input and the output part of a WXTT M. This construction essentially restricts the input or output of the WXTT M to the string language recognized by a WSA N. Contrary to (direct or inverse) application, this construction is supposed to yield another WXTT. More precisely, the constructed WXTT should assign to each translation (t, u) the weight assigned to it by M multiplied by the weight assigned by N to the yield of t (or u if the output is restricted). Since </context>
</contexts>
<marker>Arnold, Dauchet, 1982</marker>
<rawString>Andr´e Arnold and Max Dauchet. 1982. Morphismes et bimorphismes d’arbres. Theoret. Comput. Sci., 20(1):33–93.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Yehoshua Bar-Hillel</author>
<author>Micha Perles</author>
<author>Eliyahu Shamir</author>
</authors>
<title>On formal properties of simple phrase structure grammars.</title>
<date>1964</date>
<booktitle>In Yehoshua Bar-Hillel, editor, Language and Information: Selected Essays on their Theory and Application, chapter 9,</booktitle>
<pages>116--150</pages>
<publisher>Addison Wesley.</publisher>
<contexts>
<context position="3089" citStr="Bar-Hillel et al., 1964" startWordPosition="486" endWordPosition="489">rom the input alphabet of M. This automaton M,,, is further transformed into a tree transducer implementing a partial identity translation. This transducer is then composed with M (relational composition) to obtain a transducer that represents all translations of w. This is usually called the ‘cascaded’ approach. In contrast with the cascaded approach above, which may be rather inefficient, we investigate a more direct technique for both parsing and translation of strings based on WXTTs. We do this by extending to WXTTs the well-known BAR-HILLEL construction defined for context-free grammars (Bar-Hillel et al., 1964) and for weighted contextfree grammars (Nederhof and Satta, 2003). We then derive computational complexity results for parsing and translation of input strings on the basis of WXTTs. Finally, we develop a novel factorization algorithm for WXTTs that, in practical applications, can reduce the asymptotic complexity for such problems. 2 Preliminary definitions Let • be an associative binary operation on a set S. If S contains an element 1 such that 1-s = s = s-1 for every s E S, then (S, •,1) is a monoid. Such a monoid (S, •,1) is commutative if the identity s1 •s2 = s2 •s1 holds for all s1, s2 E</context>
</contexts>
<marker>Bar-Hillel, Perles, Shamir, 1964</marker>
<rawString>Yehoshua Bar-Hillel, Micha Perles, and Eliyahu Shamir. 1964. On formal properties of simple phrase structure grammars. In Yehoshua Bar-Hillel, editor, Language and Information: Selected Essays on their Theory and Application, chapter 9, pages 116–150. Addison Wesley.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jay Earley</author>
</authors>
<title>An efficient context-free parsing algorithm.</title>
<date>1970</date>
<journal>Commun. ACM,</journal>
<volume>13</volume>
<issue>2</issue>
<marker>Earley, 1970</marker>
<rawString>Jay Earley. 1970. An efficient context-free parsing algorithm. Commun. ACM, 13(2):94–102.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Samuel Eilenberg</author>
</authors>
<date>1974</date>
<journal>Automata, Languages, and Machines,</journal>
<volume>59</volume>
<publisher>Academic Press.</publisher>
<contexts>
<context position="4274" citStr="Eilenberg, 1974" startWordPosition="706" endWordPosition="707">= s2 •s1 holds for all s1, s2 E S. A commutative semiring (S, +, , 0,1) is an algebraic structure such that: • (S, +, 0) and (S, •,1) are commutative 19 Proceedings of the 2010 Workshop on Applications of Tree Automata in Natural Language Processing, ACL 2010, pages 19–27, Uppsala, Sweden, 16 July 2010. c�2010 Association for Computational Linguistics monoids, • · distributes over + (from both sides), and • s · 0 = 0 = 0 · s for every s E S. From now on, let (S,+,·,0,1) be a commutative semiring. An alphabet is a finite set of symbols. A weighted string automaton [WSA] (Sch¨utzenberger, 1961; Eilenberg, 1974) is a system N = (P, F, J, ν, F) where • P and F are alphabets of states and input symbols, respectively, • J, F : P —* S assign initial and final weights, respectively, and • ν : P x F x P —* S assigns a weight to each transition. The transition weight mapping ν can be understood as square matrices ν(·, γ, ·) E SP&amp;quot;P for every γ E F. The WSA N is deterministic if • J(p) =� 0 for at most one p E P and • for every p E P and γ E F there exists at most one p&apos; E P such that ν(p,γ, p&apos;) =� 0. We now proceed with the semantics of N. We will define the initial algebra semantics here; alternative, equiv</context>
</contexts>
<marker>Eilenberg, 1974</marker>
<rawString>Samuel Eilenberg. 1974. Automata, Languages, and Machines, volume 59 of Pure and Applied Math. Academic Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Joost Engelfriet</author>
<author>Zolt´an F¨ul¨op</author>
<author>Heiko Vogler</author>
</authors>
<title>Bottom-up and top-down tree series transformations.</title>
<date>2002</date>
<journal>J. Autom. Lang. Combin.,</journal>
<volume>7</volume>
<issue>1</issue>
<marker>Engelfriet, F¨ul¨op, Vogler, 2002</marker>
<rawString>Joost Engelfriet, Zolt´an F¨ul¨op, and Heiko Vogler. 2002. Bottom-up and top-down tree series transformations. J. Autom. Lang. Combin., 7(1):11–70.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Zolt´an F¨ul¨op</author>
<author>Heiko Vogler</author>
</authors>
<title>Weighted tree automata and tree transducers.</title>
<date>2009</date>
<booktitle>Handbook of Weighted Automata, EATCS Monographs on Theoret. Comput. Sci., chapter IX,</booktitle>
<pages>313--403</pages>
<editor>In Manfred Droste, Werner Kuich, and Heiko Vogler, editors,</editor>
<publisher>Springer.</publisher>
<marker>F¨ul¨op, Vogler, 2009</marker>
<rawString>Zolt´an F¨ul¨op and Heiko Vogler. 2009. Weighted tree automata and tree transducers. In Manfred Droste, Werner Kuich, and Heiko Vogler, editors, Handbook of Weighted Automata, EATCS Monographs on Theoret. Comput. Sci., chapter IX, pages 313–403. Springer.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Michel Galley</author>
<author>Mark Hopkins</author>
<author>Kevin Knight</author>
<author>Daniel Marcu</author>
</authors>
<title>What’s in a translation rule? In</title>
<date>2004</date>
<booktitle>Proc. HLT-NAACL,</booktitle>
<pages>273--280</pages>
<publisher>Association</publisher>
<institution>for Computational Linguistics.</institution>
<contexts>
<context position="20788" citStr="Galley et al. (2004)" startWordPosition="4121" endWordPosition="4124">nt of the asymptotical run-time of our construction. Following the above line, we present here a linear time algorithm for reducing the rank of a WXTT under certain conditions. Similar algorithms for tree-based transformation devices have been discussed in the literature. Nesson et al. (2008) consider synchronous tree adjoining grammars; their algorithm is conceptually very similar to ours, but computationally more demanding due to the treatment of adjunction. Following that work, we also demand here that the new WXTT ‘preserves’ the recursive structure of the input WXTT, as formalized below. Galley et al. (2004) algorithm also behaves in linear time, but deals with the different problem of tree to string translation. Rank reduction algorithms for stringbased translation devices have also been discussed by Zhang et al. (2006) and Gildea et al. (2006). Recall that M = (Q, E, 0, I, R) is a standard WXTT. Let M0 = (Q0, E, 0, I0, R0) be a WXTT with Q ⊆ Q0.3 Then M0 is a structure-preserving factorization of M if • I0(q) = I(q) for every q ∈ Q and I0(q) = 0 otherwise, and • hp�···p� R&apos; (t, u)q = hp�···p� R (t, u)q for every q, p1, ... , pn ∈ Q, t ∈ TE(Xn), and u ∈ TA(Xn). In particular, we have hR&apos;(t, u)q </context>
</contexts>
<marker>Galley, Hopkins, Knight, Marcu, 2004</marker>
<rawString>Michel Galley, Mark Hopkins, Kevin Knight, and Daniel Marcu. 2004. What’s in a translation rule? In Proc. HLT-NAACL, pages 273–280. Association for Computational Linguistics.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Daniel Gildea</author>
<author>Giorgio Satta</author>
<author>Hao Zhang</author>
</authors>
<title>Factoring synchronous grammars by sorting.</title>
<date>2006</date>
<booktitle>In Proc. CoLing/ACL,</booktitle>
<pages>279--286</pages>
<publisher>Association</publisher>
<institution>for Computational Linguistics.</institution>
<contexts>
<context position="21030" citStr="Gildea et al. (2006)" startWordPosition="4160" endWordPosition="4163">n discussed in the literature. Nesson et al. (2008) consider synchronous tree adjoining grammars; their algorithm is conceptually very similar to ours, but computationally more demanding due to the treatment of adjunction. Following that work, we also demand here that the new WXTT ‘preserves’ the recursive structure of the input WXTT, as formalized below. Galley et al. (2004) algorithm also behaves in linear time, but deals with the different problem of tree to string translation. Rank reduction algorithms for stringbased translation devices have also been discussed by Zhang et al. (2006) and Gildea et al. (2006). Recall that M = (Q, E, 0, I, R) is a standard WXTT. Let M0 = (Q0, E, 0, I0, R0) be a WXTT with Q ⊆ Q0.3 Then M0 is a structure-preserving factorization of M if • I0(q) = I(q) for every q ∈ Q and I0(q) = 0 otherwise, and • hp�···p� R&apos; (t, u)q = hp�···p� R (t, u)q for every q, p1, ... , pn ∈ Q, t ∈ TE(Xn), and u ∈ TA(Xn). In particular, we have hR&apos;(t, u)q = hR(t, u)q for n = 0. Consequently, M0 and M are equivalent because M0(t, u) = � I0(q) · hR&apos;(t, u)q q∈Q&apos; �= I(q) · hR(t, u)q = M(t, u) . q∈Q Note that the relation ‘is structure-preserving factorization of’ is reflexive and transitive, and t</context>
</contexts>
<marker>Gildea, Satta, Zhang, 2006</marker>
<rawString>Daniel Gildea, Giorgio Satta, and Hao Zhang. 2006. Factoring synchronous grammars by sorting. In Proc. CoLing/ACL, pages 279–286. Association for Computational Linguistics.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jonathan Graehl</author>
<author>Kevin Knight</author>
</authors>
<title>Training tree transducers.</title>
<date>2004</date>
<booktitle>In HLT-NAACL,</booktitle>
<pages>105--112</pages>
<publisher>Association</publisher>
<contexts>
<context position="922" citStr="Graehl and Knight (2004)" startWordPosition="129" endWordPosition="132">iform framework for the development of parsing and translation algorithms for weighted extended (top-down) tree transducers and input strings. The asymptotic time complexity of these algorithms can be improved in practice by exploiting an algorithm for rule factorization in the above transducers. 1 Introduction In the field of statistical machine translation, considerable interest has recently been shown for translation models based on weighted tree transducers. In this paper we consider the so-called weighted extended (top-down) tree transducers (WXTTs for short). WXTTs have been proposed by Graehl and Knight (2004) and Knight (2007) and are rooted in similar devices introduced earlier in the formal language literature (Arnold and Dauchet, 1982). WXTTs have enough expressivity to represent hierarchical syntactic analyses for natural language sentences and can directly model most of the elementary operations that rule the process of translation between natural languages (Knight, 2007). Furthermore, the use of weights and internal states allows the encoding of statistical parameters that have recently been shown to be extremely useful in discriminating likely translations from less plausible ones. For an W</context>
<context position="10882" citStr="Graehl and Knight (2004)" startWordPosition="2137" endWordPosition="2140">variables, then their weights should be added to obtain a single standard rule. To keep the presentation simple, we also construct nonstandard WXTTs in the sequel. However, we implicitly assume that those are converted into standard WXTTs. The semantics of a standard WXTT is inspired by the initial-algebra semantics for classical weighted top-down and bottom-up tree transducers (F¨ul¨op and Vogler, 2009) [also called topdown and bottom-up tree series transducers by Engelfriet et al. (2002)]. Note that our semantics is equivalent to the classical term rewriting semantics, which is presented by Graehl and Knight (2004) and Graehl et al. (2008), for example. In fact, we will present an equivalent semantics based on runs later. Let M = (Q, E, A, I, R) be a WXTT. We present a definition that is more general than immediately necessary, but the generalization will be useful later on. For every n ∈ N, p1, ... , pn ∈ Q, and L ⊆ R, we define the mapping hp1···pn L : TΣ(Xn) × TΔ(Xn) → SQ by hp1···pn L (xi, xi)pi = 1 for every 1 ≤ i ≤ n and hp1···pn L (t, u)q hp1···pn L (ti, ui)qi (1) (l,t1,...,tk)Edec(t) (r,u1,...,uk)Edec(u) (q,l) 3,(q1···qk,r)EL for all remaining t ∈ TΣ(Xn), u ∈ TΔ(Xn), and q ∈ Q. Note that for eac</context>
</contexts>
<marker>Graehl, Knight, 2004</marker>
<rawString>Jonathan Graehl and Kevin Knight. 2004. Training tree transducers. In HLT-NAACL, pages 105–112. Association for Computational Linguistics. See also (Graehl et al., 2008).</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jonathan Graehl</author>
<author>Kevin Knight</author>
<author>Jonathan May</author>
</authors>
<title>Training tree transducers.</title>
<date>2008</date>
<journal>Computational Linguistics,</journal>
<volume>34</volume>
<issue>3</issue>
<contexts>
<context position="10907" citStr="Graehl et al. (2008)" startWordPosition="2142" endWordPosition="2145"> should be added to obtain a single standard rule. To keep the presentation simple, we also construct nonstandard WXTTs in the sequel. However, we implicitly assume that those are converted into standard WXTTs. The semantics of a standard WXTT is inspired by the initial-algebra semantics for classical weighted top-down and bottom-up tree transducers (F¨ul¨op and Vogler, 2009) [also called topdown and bottom-up tree series transducers by Engelfriet et al. (2002)]. Note that our semantics is equivalent to the classical term rewriting semantics, which is presented by Graehl and Knight (2004) and Graehl et al. (2008), for example. In fact, we will present an equivalent semantics based on runs later. Let M = (Q, E, A, I, R) be a WXTT. We present a definition that is more general than immediately necessary, but the generalization will be useful later on. For every n ∈ N, p1, ... , pn ∈ Q, and L ⊆ R, we define the mapping hp1···pn L : TΣ(Xn) × TΔ(Xn) → SQ by hp1···pn L (xi, xi)pi = 1 for every 1 ≤ i ≤ n and hp1···pn L (t, u)q hp1···pn L (ti, ui)qi (1) (l,t1,...,tk)Edec(t) (r,u1,...,uk)Edec(u) (q,l) 3,(q1···qk,r)EL for all remaining t ∈ TΣ(Xn), u ∈ TΔ(Xn), and q ∈ Q. Note that for each nonzero summand in (1) </context>
</contexts>
<marker>Graehl, Knight, May, 2008</marker>
<rawString>Jonathan Graehl, Kevin Knight, and Jonathan May. 2008. Training tree transducers. Computational Linguistics, 34(3):391–427.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kevin Knight</author>
</authors>
<title>Capturing practical natural language transformations.</title>
<date>2007</date>
<journal>Machine Translation,</journal>
<volume>21</volume>
<issue>2</issue>
<contexts>
<context position="940" citStr="Knight (2007)" startWordPosition="134" endWordPosition="135">opment of parsing and translation algorithms for weighted extended (top-down) tree transducers and input strings. The asymptotic time complexity of these algorithms can be improved in practice by exploiting an algorithm for rule factorization in the above transducers. 1 Introduction In the field of statistical machine translation, considerable interest has recently been shown for translation models based on weighted tree transducers. In this paper we consider the so-called weighted extended (top-down) tree transducers (WXTTs for short). WXTTs have been proposed by Graehl and Knight (2004) and Knight (2007) and are rooted in similar devices introduced earlier in the formal language literature (Arnold and Dauchet, 1982). WXTTs have enough expressivity to represent hierarchical syntactic analyses for natural language sentences and can directly model most of the elementary operations that rule the process of translation between natural languages (Knight, 2007). Furthermore, the use of weights and internal states allows the encoding of statistical parameters that have recently been shown to be extremely useful in discriminating likely translations from less plausible ones. For an WXTT M, the parsing</context>
</contexts>
<marker>Knight, 2007</marker>
<rawString>Kevin Knight. 2007. Capturing practical natural language transformations. Machine Translation, 21(2):121–133.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Zhifei Li</author>
<author>Jason Eisner</author>
</authors>
<title>First- and secondorder expectation semirings with applications to minimum-risk training on translation forests.</title>
<date>2009</date>
<booktitle>In Proc. EMNLP,</booktitle>
<pages>40--51</pages>
<publisher>Association</publisher>
<institution>for Computational Linguistics.</institution>
<contexts>
<context position="18902" citStr="Li and Eisner, 2009" startWordPosition="3807" endWordPosition="3810"> Then the input product transducer Mw = Prod(Nw, M) provides a compact representation of the set of all computations of M that translate the string w. From Corollary 5 we have that the weights of these computations are also preserved. Thus, Mw(TE × TA) = E(t,u)ETEXT, Mw(t,u) is the weight of the set of string translations of w. As usual in natural language processing applications, we can exploit appropriate semirings and compute several useful statistical parameters through Mw(TE × TA), as for instance the highest weight of a computation, the inside probability and the rule expectations; see (Li and Eisner, 2009) for further discussion. One could also construct in linear time the range tree automaton for Mw, which can be interpreted as a parsing forest with all the weighted trees assigned to translations of w under M. If we further assume that M is unambiguous, then Mw will also have this property, and we can apply standard techniques to extract from Mw the highest score computation. In machine translation applications, the unambiguity assumption is usually met, and avoids the so-called ‘spurious’ ambiguity, that is, having several computations for an individual pair of trees. The parsing problem for </context>
</contexts>
<marker>Li, Eisner, 2009</marker>
<rawString>Zhifei Li and Jason Eisner. 2009. First- and secondorder expectation semirings with applications to minimum-risk training on translation forests. In Proc. EMNLP, pages 40–51. Association for Computational Linguistics.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Eric Lilin</author>
</authors>
<title>Propri´et´es de clˆoture d’une extension de transducteurs d’arbres d´eterministes.</title>
<date>1981</date>
<booktitle>In CAAP,</booktitle>
<volume>112</volume>
<pages>280--289</pages>
<publisher>Springer.</publisher>
<contexts>
<context position="9110" citStr="Lilin, 1981" startWordPosition="1793" endWordPosition="1794">from l by replacing every occurrence of v ∈ V by θ(v). The k-fold application is denoted by lθk. If lθk = lθk+1 for some k ≥ 0, then we denote lθk by lθ*. In addition, if V = Xk, then we write l[θ(x1), ... , θ(xk)] instead of lθ. We write CΣ(Xk) for the subset of those trees of TΣ(Xk) such that every variable of x ∈ Xk occurs exactly once in it. Given t ∈ TΣ(X), we write dec(t) for the set {(l,t1,. . . , tk) �l ∈ CΣ(Xk), l [t1, ... , tk] = t,1 t1,...,tk ∈ TΣ(X) J A (linear and nondeleting) weighted extended (top-down) tree transducer [WXTT] (Arnold and Dauchet, 1975; Arnold and Dauchet, 1976; Lilin, 1981; Arnold and Dauchet, 1982; Maletti et al., 2009) is a system M = (Q, E, A, I, R) where • Q is an alphabet of states, • E and A are ranked alphabets of input and output symbols, respectively, • I : Q → S assigns initial weights, and • R is a finite set of rules of the form (q, l) → s (q1 ··· qk, r) with q, q1, ... , qk ∈ Q, l ∈ CΣ(Xk) and r ∈ CΔ(Xk), and s ∈ S such that {l, r} ⊆6 X. Let us discuss the final restriction imposed on the rules of a WXTT. Essentially, it disallows rules of the form (q, x1) s→ (q&apos;, x1) with q, q&apos; ∈ Q and s ∈ S. Such pure epsilon rules only change the state and charg</context>
</contexts>
<marker>Lilin, 1981</marker>
<rawString>Eric Lilin. 1981. Propri´et´es de clˆoture d’une extension de transducteurs d’arbres d´eterministes. In CAAP, volume 112 of LNCS, pages 280–289. Springer.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Andreas Maletti</author>
<author>Jonathan Graehl</author>
<author>Mark Hopkins</author>
<author>Kevin Knight</author>
</authors>
<title>The power of extended top-down tree transducers.</title>
<date>2009</date>
<journal>SIAMJ. Comput.,</journal>
<volume>39</volume>
<issue>2</issue>
<contexts>
<context position="9159" citStr="Maletti et al., 2009" startWordPosition="1799" endWordPosition="1802"> v ∈ V by θ(v). The k-fold application is denoted by lθk. If lθk = lθk+1 for some k ≥ 0, then we denote lθk by lθ*. In addition, if V = Xk, then we write l[θ(x1), ... , θ(xk)] instead of lθ. We write CΣ(Xk) for the subset of those trees of TΣ(Xk) such that every variable of x ∈ Xk occurs exactly once in it. Given t ∈ TΣ(X), we write dec(t) for the set {(l,t1,. . . , tk) �l ∈ CΣ(Xk), l [t1, ... , tk] = t,1 t1,...,tk ∈ TΣ(X) J A (linear and nondeleting) weighted extended (top-down) tree transducer [WXTT] (Arnold and Dauchet, 1975; Arnold and Dauchet, 1976; Lilin, 1981; Arnold and Dauchet, 1982; Maletti et al., 2009) is a system M = (Q, E, A, I, R) where • Q is an alphabet of states, • E and A are ranked alphabets of input and output symbols, respectively, • I : Q → S assigns initial weights, and • R is a finite set of rules of the form (q, l) → s (q1 ··· qk, r) with q, q1, ... , qk ∈ Q, l ∈ CΣ(Xk) and r ∈ CΔ(Xk), and s ∈ S such that {l, r} ⊆6 X. Let us discuss the final restriction imposed on the rules of a WXTT. Essentially, it disallows rules of the form (q, x1) s→ (q&apos;, x1) with q, q&apos; ∈ Q and s ∈ S. Such pure epsilon rules only change the state and charge a cost. However, they can yield infinite deriva</context>
</contexts>
<marker>Maletti, Graehl, Hopkins, Knight, 2009</marker>
<rawString>Andreas Maletti, Jonathan Graehl, Mark Hopkins, and Kevin Knight. 2009. The power of extended top-down tree transducers. SIAMJ. Comput., 39(2):410–430.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Mark-Jan Nederhof</author>
<author>Giorgio Satta</author>
</authors>
<title>Probabilistic parsing as intersection.</title>
<date>2003</date>
<booktitle>In Proc. IWPT,</booktitle>
<pages>137--148</pages>
<publisher>Association</publisher>
<institution>for Computational Linguistics.</institution>
<contexts>
<context position="3154" citStr="Nederhof and Satta, 2003" startWordPosition="496" endWordPosition="499">sformed into a tree transducer implementing a partial identity translation. This transducer is then composed with M (relational composition) to obtain a transducer that represents all translations of w. This is usually called the ‘cascaded’ approach. In contrast with the cascaded approach above, which may be rather inefficient, we investigate a more direct technique for both parsing and translation of strings based on WXTTs. We do this by extending to WXTTs the well-known BAR-HILLEL construction defined for context-free grammars (Bar-Hillel et al., 1964) and for weighted contextfree grammars (Nederhof and Satta, 2003). We then derive computational complexity results for parsing and translation of input strings on the basis of WXTTs. Finally, we develop a novel factorization algorithm for WXTTs that, in practical applications, can reduce the asymptotic complexity for such problems. 2 Preliminary definitions Let • be an associative binary operation on a set S. If S contains an element 1 such that 1-s = s = s-1 for every s E S, then (S, •,1) is a monoid. Such a monoid (S, •,1) is commutative if the identity s1 •s2 = s2 •s1 holds for all s1, s2 E S. A commutative semiring (S, +, , 0,1) is an algebraic structur</context>
</contexts>
<marker>Nederhof, Satta, 2003</marker>
<rawString>Mark-Jan Nederhof and Giorgio Satta. 2003. Probabilistic parsing as intersection. In Proc. IWPT, pages 137–148. Association for Computational Linguistics.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Rebecca Nesson</author>
<author>Giorgio Satta</author>
<author>Stuart M Shieber</author>
</authors>
<title>Optimal k-arization of synchronous treeadjoining grammar.</title>
<date>2008</date>
<booktitle>In Proc. ACL,</booktitle>
<pages>604--612</pages>
<publisher>Association</publisher>
<institution>for Computational Linguistics.</institution>
<contexts>
<context position="20461" citStr="Nesson et al. (2008)" startWordPosition="4068" endWordPosition="4071">al form such that the rank is bounded by some constant. This is also expected from the fact that the translation problem for subclasses of WXTTs such as synchronous contextfree grammars is NP-hard (Satta and Peserico, 2005). Nonetheless, there are cases in which a rank reduction is possible, which might result in an improvement of the asymptotical run-time of our construction. Following the above line, we present here a linear time algorithm for reducing the rank of a WXTT under certain conditions. Similar algorithms for tree-based transformation devices have been discussed in the literature. Nesson et al. (2008) consider synchronous tree adjoining grammars; their algorithm is conceptually very similar to ours, but computationally more demanding due to the treatment of adjunction. Following that work, we also demand here that the new WXTT ‘preserves’ the recursive structure of the input WXTT, as formalized below. Galley et al. (2004) algorithm also behaves in linear time, but deals with the different problem of tree to string translation. Rank reduction algorithms for stringbased translation devices have also been discussed by Zhang et al. (2006) and Gildea et al. (2006). Recall that M = (Q, E, 0, I, </context>
</contexts>
<marker>Nesson, Satta, Shieber, 2008</marker>
<rawString>Rebecca Nesson, Giorgio Satta, and Stuart M. Shieber. 2008. Optimal k-arization of synchronous treeadjoining grammar. In Proc. ACL, pages 604–612. Association for Computational Linguistics.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jacques Sakarovitch</author>
</authors>
<title>Rational and recognisable power series.</title>
<date>2009</date>
<booktitle>Handbook of Weighted Automata, EATCS Monographs on Theoret. Comput. Sci., chapter IV,</booktitle>
<pages>105--174</pages>
<editor>In Manfred Droste, Werner Kuich, and Heiko Vogler, editors,</editor>
<publisher>Springer.</publisher>
<contexts>
<context position="4934" citStr="Sakarovitch, 2009" startWordPosition="850" endWordPosition="851"> and F are alphabets of states and input symbols, respectively, • J, F : P —* S assign initial and final weights, respectively, and • ν : P x F x P —* S assigns a weight to each transition. The transition weight mapping ν can be understood as square matrices ν(·, γ, ·) E SP&amp;quot;P for every γ E F. The WSA N is deterministic if • J(p) =� 0 for at most one p E P and • for every p E P and γ E F there exists at most one p&apos; E P such that ν(p,γ, p&apos;) =� 0. We now proceed with the semantics of N. We will define the initial algebra semantics here; alternative, equivalent definitions of the semantics exist (Sakarovitch, 2009). Let w E F&apos; be an input string, γ E F, and p, p&apos; E P be two states. We extend ν to a mapping hν : P x F&apos; x P —* S recursively as follows: hν(p, γw, p&apos;) = X ν(p,γ,p&apos;&apos;) · hν(p&apos;&apos;,w,p&apos;) . p00EP Consequently, Xhν(p, uw, p&apos;) = hν(p, u, p&apos;&apos;) · hν(p&apos;&apos;, w, p&apos;) p00EP for all p, p&apos; E P and u, w E F&apos;. Then the matrix hν(·,γ1 ···γk, ·) equals ν(·,γ1, ·) · ... · ν(·,γk, ·). Thus, if the semiring operations can be performed in constant time and access to ν(p, γ, q) is in constant time for every p, q E P, then for every w E F&apos; we can compute the matrix hν(·, w, ·) in time O(|w |· |P|3) because it can be comp</context>
</contexts>
<marker>Sakarovitch, 2009</marker>
<rawString>Jacques Sakarovitch. 2009. Rational and recognisable power series. In Manfred Droste, Werner Kuich, and Heiko Vogler, editors, Handbook of Weighted Automata, EATCS Monographs on Theoret. Comput. Sci., chapter IV, pages 105–174. Springer.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Giorgio Satta</author>
<author>Enoch Peserico</author>
</authors>
<title>Some computational complexity results for synchronous context-free grammars.</title>
<date>2005</date>
<booktitle>In Proc. HLT-EMNLP,</booktitle>
<pages>803--810</pages>
<publisher>Association</publisher>
<institution>for Computational Linguistics.</institution>
<contexts>
<context position="20064" citStr="Satta and Peserico, 2005" startWordPosition="4006" endWordPosition="4009">tions for an individual pair of trees. The parsing problem for input strings w and u can be treated in a similar way, by restricting M both to the left and to the right. 5 Rule factorization As already discussed, the time complexity of the product construction is an exponential function of the rank of the transducer. Unfortunately, it is not possible in the general case to cast a 23 WXTT into a normal form such that the rank is bounded by some constant. This is also expected from the fact that the translation problem for subclasses of WXTTs such as synchronous contextfree grammars is NP-hard (Satta and Peserico, 2005). Nonetheless, there are cases in which a rank reduction is possible, which might result in an improvement of the asymptotical run-time of our construction. Following the above line, we present here a linear time algorithm for reducing the rank of a WXTT under certain conditions. Similar algorithms for tree-based transformation devices have been discussed in the literature. Nesson et al. (2008) consider synchronous tree adjoining grammars; their algorithm is conceptually very similar to ours, but computationally more demanding due to the treatment of adjunction. Following that work, we also de</context>
</contexts>
<marker>Satta, Peserico, 2005</marker>
<rawString>Giorgio Satta and Enoch Peserico. 2005. Some computational complexity results for synchronous context-free grammars. In Proc. HLT-EMNLP, pages 803–810. Association for Computational Linguistics.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Marcel Paul Sch¨utzenberger</author>
</authors>
<title>On the definition of a family of automata.</title>
<date>1961</date>
<journal>Information and Control,</journal>
<pages>4--2</pages>
<marker>Sch¨utzenberger, 1961</marker>
<rawString>Marcel Paul Sch¨utzenberger. 1961. On the definition of a family of automata. Information and Control, 4(2–3):245–270.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Daniel H Younger</author>
</authors>
<title>Recognition and parsing of context-free languages in time n3.</title>
<date>1967</date>
<journal>Inform. Control,</journal>
<volume>10</volume>
<issue>2</issue>
<marker>Younger, 1967</marker>
<rawString>Daniel H. Younger. 1967. Recognition and parsing of context-free languages in time n3. Inform. Control, 10(2):189–208.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Hao Zhang</author>
<author>Liang Huang</author>
<author>Daniel Gildea</author>
<author>Kevin Knight</author>
</authors>
<title>Synchronous binarization for machine translation.</title>
<date>2006</date>
<booktitle>In Proc. HLT-NAACL,</booktitle>
<pages>256--263</pages>
<publisher>Association</publisher>
<institution>for Computational Linguistics.</institution>
<contexts>
<context position="21005" citStr="Zhang et al. (2006)" startWordPosition="4155" endWordPosition="4158">rmation devices have been discussed in the literature. Nesson et al. (2008) consider synchronous tree adjoining grammars; their algorithm is conceptually very similar to ours, but computationally more demanding due to the treatment of adjunction. Following that work, we also demand here that the new WXTT ‘preserves’ the recursive structure of the input WXTT, as formalized below. Galley et al. (2004) algorithm also behaves in linear time, but deals with the different problem of tree to string translation. Rank reduction algorithms for stringbased translation devices have also been discussed by Zhang et al. (2006) and Gildea et al. (2006). Recall that M = (Q, E, 0, I, R) is a standard WXTT. Let M0 = (Q0, E, 0, I0, R0) be a WXTT with Q ⊆ Q0.3 Then M0 is a structure-preserving factorization of M if • I0(q) = I(q) for every q ∈ Q and I0(q) = 0 otherwise, and • hp�···p� R&apos; (t, u)q = hp�···p� R (t, u)q for every q, p1, ... , pn ∈ Q, t ∈ TE(Xn), and u ∈ TA(Xn). In particular, we have hR&apos;(t, u)q = hR(t, u)q for n = 0. Consequently, M0 and M are equivalent because M0(t, u) = � I0(q) · hR&apos;(t, u)q q∈Q&apos; �= I(q) · hR(t, u)q = M(t, u) . q∈Q Note that the relation ‘is structure-preserving factorization of’ is reflex</context>
</contexts>
<marker>Zhang, Huang, Gildea, Knight, 2006</marker>
<rawString>Hao Zhang, Liang Huang, Daniel Gildea, and Kevin Knight. 2006. Synchronous binarization for machine translation. In Proc. HLT-NAACL, pages 256– 263. Association for Computational Linguistics.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>