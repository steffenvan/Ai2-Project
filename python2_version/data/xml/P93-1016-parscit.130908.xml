<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<author confidence="0.7016135">
PRINCIPLE-BASED PARSING WITHOUT OVERGENERATION1
Dekang Lin
</author>
<affiliation confidence="0.903454">
Department of Computing Science, University of Manitoba
Winnipeg, Manitoba, Canada, R3T 2N2
</affiliation>
<email confidence="0.998244">
E-mail: lindek@cs.umanitoba.ca
</email>
<sectionHeader confidence="0.980114" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999214285714286">
Overgeneration is the main source of computational
complexity in previous principle-based parsers. This
paper presents a message passing algorithm for
principle-based parsing that avoids the overgenera-
tion problem. This algorithm has been implemented
in C++ and successfully tested with example sen-
tences from (van Riemsdijk and Williams, 1986).
</bodyText>
<sectionHeader confidence="0.991456" genericHeader="keywords">
1. Introduction
</sectionHeader>
<bodyText confidence="0.9999045">
Unlike rule-based grammars that use a large num-
ber of rules to describe patterns in a language,
Government-Binding (GB) Theory (Chomsky, 1981;
Haegeman, 1991; van Riemsdijk and Williams,
1986) explains these patterns in terms of more
foundmental and universal principles.
A key issue in building a principle-based parser is
how to procedurally interpret the principles. Since
GB principles are constraints over syntactic struc-
tures, one way to implement the principles is to
</bodyText>
<listItem confidence="0.997355">
1. generate candidate structures of the sentence
that satisfy X-bar theory and subcategoriza-
tion frames of the words in the sentence.
2. filter out structures that violates any one of
the principles.
3. the remaining structures are accepted as parse
trees of the sentence.
</listItem>
<bodyText confidence="0.999527090909091">
This implementation of GB theory is very ineffi-
cient, since there are a large number of structures
being generated and then filtered out. The prob-
lem of producing too many illicit structures is called
overgeneration and has been recognized as the cul-
prit of computational difficulties in principle-based
parsing (Berwick, 1991). Many methods have been
proposed to alleviate the overgeneration problem
by detecting illicit structures as early as possible,
such as optimal ordering of principles (Fong, 1991),
coroutining (Dorr, 1991; Johnson, 1991).
</bodyText>
<footnote confidence="0.86672575">
1The author wishes to thank the anonymous referees for
their helpful comments and suggestions. This research was
supported by Natural Sciences and Engineering Research
Council of Canada grant 0GP121338.
</footnote>
<bodyText confidence="0.99979516">
This paper presents a principle-based parser that
avoids the overgeneration problem by applying prin-
ciples to descriptions of the structures, instead of
the structures themselves. A structure for the input
sentence is only constructed after its description has
been found to satisfy all the principles. The struc-
ture can then be retrieved in time linear to its size
and is guaranteed to be consistent with the princi-
ples.
Since the descriptions of structures are constant-
sized attribute vectors, checking whether a struc-
tural description satisfy a principle takes constant
amount of time. This compares favorably to ap-
proaches where constraint satisfaction involves tree
traversal.
The next section presents a general framework
for parsing by message passing. Section 3 shows how
linguistic notions, such as dominance and govern-
ment, can be translated into relationships between
descriptions of structures. Section 4 describes in-
terpretation of GB principles. Familiarity with GB
theory is assumed in the presentation. Section 5
sketches an object-oriented implementation of the
parser. Section 6 discusses complexity issues and
related work.
</bodyText>
<sectionHeader confidence="0.576632" genericHeader="introduction">
2. Parsing by Message Passing
</sectionHeader>
<bodyText confidence="0.999929125">
The message passing algorithm presented here is
an extension to a message passing algorithm for
context-free grammars (Lin and Goebel, 1993).
We encode the grammar, as well as the parser,
in a network (Figure 1). The nodes in the net-
works represent syntactic categories. The links in
the network represent dominance and subsumption
relationships between the categories:
</bodyText>
<listItem confidence="0.971675333333333">
• There is a dominance link from node A to B
if B can be immediately dominated by A. The
dominance links can be further classified ac-
cording to the type of dominance relationship.
• There is a specialization link from A to B if A
subsumes B.
</listItem>
<bodyText confidence="0.996203">
The network is also a parser. The nodes in the
network are computing agents. They communicate
</bodyText>
<equation confidence="0.618701">
1 1 2
</equation>
<bodyText confidence="0.994449804878049">
with each other by passing messages in the reverse
direction of the links in the network.
The messages contains items. An item is a
triplet that describes a structure:
&lt;surface-string, attribute-values, sources&gt;,
where
surface-string is an integer interval [i, j] denoting
the i&apos;th to j&apos;th word in the input sentence.
attribute-values specify syntactic features, such as
cat, plu, case, of the root node of the struc-
ture described by the item.
sources component is the set of items that describe
the immediate sub-structures. Therefore, by
tracing the sources of an item, a complete
structure can be retrieved.
The location of the item in the network deter-
mines the syntactic category of the structure.
For example, [Nip the ice-cream] in the sentence
&amp;quot;the ice-cream was eaten&amp;quot; is represented by an item
i4 at NP node (see Figure 2):
&lt;[0,1], ((cat n) -plu (nform norm)
-cm +theta), {i1 i3}&gt;
An item represents the root node of a structure
and contains enough information such that the in-
ternal nodes of the structure are irrelevant.
The message passing process is initiated by send-
ing initial items externally to lexical nodes (e.g., N,
P, ...). The initial items represent the words in the
sentence. The attribute values of these items are
obtained from the lexicon.
In case of lexical ambiguity, each possibility is
represented by an item. For example, suppose the
input sentence is &amp;quot;I saw a man,&amp;quot; then the word
&amp;quot;saw&amp;quot; is represented by the following two items sent
to nodes N and V:NP2 respectively:
&lt; [1 , 1.] , ( (cat n) -plu (nform norm)), 0&gt;
&lt;[1,1], ((cat v) (cform fin) -pas
(tense past)), {}&gt;
When a node receives an item, it attempts to
combine the item with items from other nodes to
form new items. Two items
</bodyText>
<listItem confidence="0.995362666666667">
&lt;[ii,ji], Ai, Si&gt; and &lt;[i2,i2], A2, S2&gt;
can be combined if
1. their surface strings are adjacent to each
other: i2 =
2. their attribute values Ai and A2 are unifiable.
3. their sources are disjoint: Si C1 S2 ==
</listItem>
<bodyText confidence="0.999461607142857">
The result of the combination is a new item:
&lt;[i1j2], unify(Ai, A2), Si U S2&gt;•
The new items represent larger parse trees resulted
from combining smaller ones. They are then prop-
agated further to other nodes.
The principles in GB theory are implemented
as a set of constraints that must be satisfied dur-
ing the propagation and combination of items. The
constraints are attached to nodes and links in the
network. Different nodes and links may have differ-
ent constraints. The items received or created by a
node must satisfy the constraints at the node.
The constraints attached to the links serve as
filters. A link only allows items that satisfy its con-
straints to pass through. For example, the link from
V:NP to NP in Figure 1 has a constraint that any
item passing through it must be unifiable with (case
acc). Thus items representing NPs with nominative
case, such as &amp;quot;he&amp;quot;, will not be able to pass through
the link.
By default, the attributes of an item percolate
with the item as it is sent across a link. However,
the links in the network may block the percolation
of certain attributes.
The sentence is successfully parsed if an item is
found at IF or CP node whose surface string is the
input sentence. A parse tree of the sentence can be
retrieved by tracing the sources of the item.
</bodyText>
<subsectionHeader confidence="0.838604">
An example
</subsectionHeader>
<bodyText confidence="0.9935988">
The message passing process for analyzing the sen-
tence
2V:NP denotes verbs taking an NP complement. Sim-
ilarly, V:IP denotes verbs taking a CP complement, N:CP
represents nouns taking a CP complement.
</bodyText>
<figure confidence="0.756569363636364">
--- — ---- cp
/ \I • • i .
&apos;&apos;&apos; c
A Ploar* i / ............. • \ bar
\
, T.:7.,41:\ ...............&amp;quot;... .. Ii.:;1/41;
.1.
PSpec /
/ \
/ VP
\
\ \
I
4 li\NP
\ . \
:
V
■ I
—et /
— — — • barrier
adjunct—dominance specialization link
head dominance specifier—dirninance complement—dominance
</figure>
<figureCaption confidence="0.975316">
Figure 1: A Network Representation of Grammar
</figureCaption>
<figure confidence="0.987955">
AP
Aoe°11\
ASpec A or
V:NP
Aux Have Be
</figure>
<page confidence="0.990119">
113
</page>
<equation confidence="0.851200125">
ii2
11—Ibar i1
I i6 NP14
14 VP 47
Nbar i3
Det i, 1\1 i2 Be i5 V:NP i7
The ice-cream was eaten
paths of messages
</equation>
<construct confidence="0.878533916666667">
a. The message passing process b. The parse tree retrieved
ii =&lt;[0,0], ((cat d)), {}&gt;
i2 =&lt;[1,1], ((cat n) -plu (nform norm) +theta), {}&gt;
13 =&lt;[1,1], ((cat n) -plu (nform norm) +theta), {i2}&gt;
=&lt;[0,1], ((cat n) -plu (nform norm) -cm +theta), {it, i3}&gt;
i5 =&lt;[2,2], ((cat i) -plu (per 1 3) (cform fin) +be +ca +govern (tense past)), {}&gt;
is =&lt;[2,2], ((cat i) -plu (per 1 3) (cform fin) +be +ca +govern (tense past)), {i5}&gt;
i7 =&lt;[3,3], ((cat v) +pas), 0&gt;
18 ((cat v) +pas +nppg -npbarrier (np-atts NNORM)), Ii71&gt;
is =&lt; , , ((cat v) +pas +nppg -npbarrier (np-atts NNORM)), {40&gt;
iio=&lt; , ((cat v) +pas +nppg -npbarrier (np-atts NNORM) ) , { ig } &gt;
i11=&lt;[2,3], ((cat i) +pas +nppg -npbarrier (np-atts NNORM) (per 1 3) (cform fin)
</construct>
<figure confidence="0.984031833333333">
Aux Have Be
i9 Vbar
V is
+ca +govern (tense past))), {is, ito}&gt;
i12=&lt;[0,3], ((cat i) +pas (per 1 3) (cform
fin) +ca +govern (tense past)), {i4, itt}&gt;
</figure>
<figureCaption confidence="0.800419">
Figure 2: Parsing the sentence &amp;quot;The ice-cream was eaten&amp;quot;
(1) The ice-cream was eaten
</figureCaption>
<bodyText confidence="0.9961382">
is illustrated in Figure 2.a. In order not to convolute
the figure, we have only shown the items that are
involved in the parse tree of the sentence and their
propagation paths.
The parsing process is described as follows:
</bodyText>
<listItem confidence="0.875758181818182">
1. The item i1 is created by looking up the lexi-
con for the word &amp;quot;the&amp;quot; and is sent to the node
Det, which sends a copy of i1 to NP.
2. The item i2 is sent to N, which propagates it to
Nbar. The attribute values of i2 are percolated
to i3. The source component of i3 is {i2}. Item
i3 is then sent to NP node.
3. When NP receives i3 from Nbar, i3 is com-
bined with i1 from Det to form a new item i4.
One of the constraints at NP node is:
if (nform norm) then -cm,
</listItem>
<bodyText confidence="0.978790090909091">
which means that normal NPs need to be case-
marked. Therefore, i4 acquires -cm. Item i4 is
then sent to nodes that have links to NP.
4. The word &amp;quot;was&amp;quot; is represented by item i5,
which is sent to Ibar via I.
5. The word &amp;quot;eaten&amp;quot; can be either the past par-
ticiple or the passive voice of &amp;quot;eat&amp;quot;. The sec-
ond possibility is represented by the item i7.
The word belongs to the subcategory V:NP
which takes an NP as the complement. There-
fore, the item i7 is sent to node V:NP.
</bodyText>
<listItem confidence="0.876014916666667">
6. Since i7 has the attribute +pas (passive voice),
an np-movement is generated at V:NP. The
movement is represented by the attributes
nppg, npbarrier, and np-atts. The first two
attributes are used to make sure that the
movement is consistent with GB principles.
The value of np-atts is an attribute vector,
which must be unifiable with the antecedent
of this np-movement. NNORM is a shorthand for
(cat n) (nform norm).
7. When Ibar receives i10, which is propagated
to VP from V:NP, the item is combined with
</listItem>
<page confidence="0.992519">
114
</page>
<bodyText confidence="0.986799">
i6 from Ito form in.
8. When IP receives in, it is combined with i4
from NP to form i12. Since in contains an np-
movement whose np-atts attribute is unifiable
with i4, i4 is identified as the antecedent of np-
movement. The np-movement attributes in i12
are cleared.
The sources of i12 are i4 from NP and in from
Ibar. Therefore, the top-level of parse tree consists
of an NP and Ibar node dominated by IP node. The
complete parse tree (Figure 2.b) is obtained by re-
cursively tracing the origins of i4 and in from NP
and Ibar respectively. The trace after &amp;quot;eaten&amp;quot; is in-
dicated by the np-movement attributes of i7, even
though the tree does not include a node representing
the trace.
</bodyText>
<sectionHeader confidence="0.796796" genericHeader="method">
3. Modeling Linguistics Devices
</sectionHeader>
<bodyText confidence="0.983342923076923">
GB principles are stated in terms of linguistic con-
cepts such as barrier, government and movement,
which are relationships between nodes in syntactic
structures. Since we interpret the principles with
descriptions of the structures, instead of the struc-
tures themselves, we must be able to model these
notions with the descriptions.
Dominance and m-command:
Dominance and m-command are relationships be-
tween nodes in syntactic structures. Since an item
represent a node in a syntactic structure, relation-
ships between the nodes can be represented by re-
lationships between items:
dominance: An item dominates its direct and in-
direct sources. For example, in Figure 2, i4
dominates i1, i2, and i3.
in-command: The head daughter of an item repre-
senting a maximal category m-commands non-
head daughters of the item and their sources.
Barrier
Chomsky (1986) proposed the notion of barrier to
unify the treatment of government and subjacency.
In Chomsky&apos;s proposal, barrierhood is a property
of maximal nodes (nodes representing maximal cat-
egories). However, not every maximal node is a bar-
rier. The barrierhood of a node also depends on its
context, in terms of L-marking and inheritance.
Instead of making barrierhood a property of the
nodes in syntactic structures, we define it to be a
property of links in the grammar network. That
is, certain links in the grammar network are clas-
sified as barriers. In Figure 1, barrier links have a
black ink-spot on them. Barrierhood is a property
of these links, independent of the context. This def-
inition of barrier is simpler than Chomsky&apos;s since
it is context-free. In our experiments so far, this
simpler definition has been found to be adequate.
Government
Once the notion of barrier has been defined, the gov-
ernment relationship between two nodes in a struc-
ture can be defined as follows:
government: A governs B if A is the minimal gov-
ernor that m-commands B via a sequence of
non-barrier links, where governors are N, V,
P, A, and tensed I.
Items representing governors are assigned
+govern attribute. This attribute percolates across
head dominance links. If an item has +govern at-
tribute, then non-head sources of the item and their
sources are governed by the head of the item if there
are paths between them and the item satisfying the
conditions:
</bodyText>
<listItem confidence="0.978556">
1. there is no barrier on the path.
2. there is no other item with +govern attribute
on the path (minimality condition (Chomsky,
1986, p.10)).
</listItem>
<bodyText confidence="0.964921">
Movement :3
Movement is a major source of complexity in
principle-based parsing. Directly modeling Move-a
would obviously generate a large number of invalid
movements. Fortunately, movements must also sat-
isfy:
c-command condition: A moved element must c-
command its trace (Radford, 1988, p.564),
where A c-command B if A does not domi-
nate B but the parent of A dominates B.
The c-command condition implies that a movement
consists of a sequence of moves in the reverse direc-
tion of dominance links, except the last one. There-
fore, we can model a movement with a set of at-
tribute values. If an item contains these attribute
values, it means that there is a movement out of the
structure represented by the item. For example, in
Figure 2.b, item i10 contains movement attributes:
nppg , npbarrier and np-atts. This indicates that
there is an np-movement out of the VP whose root
node is ilo.
</bodyText>
<footnote confidence="0.9801175">
3We limit the discussion to np-movements and wh-
movements whose initial traces are in argument positions.
</footnote>
<page confidence="0.997434">
115
</page>
<bodyText confidence="0.997465257142857">
The movement attributes are generated at the
parent node of the initial trace. For example, V:NP
is a node representing normal transitive verbs which
take an NP as complement. When V:NP receives
an item representing the passive sense of the word
eaten, V:NP creates another item
&lt; [i, i] , ((cat v) -npbarrier +nppg
(np-atts (cat n))), 0&gt;
This item will not be combined with any item from
NP node because the NP complement is assumed
to be an np-trace. The item is then sent to nodes
dominating V:NP. As the item propagates further,
the attributes is carried with it, simulating the effect
of movement. The np-movement land at IP node
when the IP node combines an item from subject
NP and another item from Ibar with np-movement
attributes. A precondition on the landing is that
the attributes of the former can be unified with the
value of np-atts of the latter. Wh-movements are
dealt with by attributes whpg, whbarrier, wh-atts.
This treatment of movement requires that the
parent node of a initial trace be able to determine
the type of movement. When a movement is gener-
ated, the type of the movement depends on the ca
(case assigner) attribute of the item:
ca movement examples
+ wh active V, P, finite IP
- np A, passive V, non-finite IP
For example, when IP node receives an item from
Ibar, IP attempts to combine it with another item
from subject NP. If the subject is not found, then
the IF node generates a movement. If the item
represent a finite clause, then it has attributes +ca
(cform fin) and the movement is of type wh. Oth-
erwise, the movement is of type np.
</bodyText>
<sectionHeader confidence="0.876561" genericHeader="method">
4. Interpretation of Principles
</sectionHeader>
<bodyText confidence="0.993472">
We now describe how the principles of GB theory
are implemented.
</bodyText>
<listItem confidence="0.875166833333333">
IX-bar Theory:
1. Every syntactic category is a projection of a
lexical head.
2. There two levels of projection of lexical
heads. Only the bar-2 projections can be
complements and adjuncts.
</listItem>
<bodyText confidence="0.999466166666667">
The first condition requires that every non-lexical
category have a head. This is guaranteed by a con-
straint in item combination: one of the sources of
the two items being combined must be from the
head daughter.
The second condition is implemented by the
structure of the grammar network. The combina-
tions of items represent constructions of larger parse
trees from smaller ones. Since the structure of the
grammar network satisfies the constraint, the parse
trees constructed by item combination also satisfy
the X-bar theory.
</bodyText>
<listItem confidence="0.962531666666667">
[Case Filter: Every lexical NP must be case--
signer and A governs B (Haegeman, 1991, p.156).
marked, where A case-marks B if A is a case as-
</listItem>
<bodyText confidence="0.87424">
The case filter is implemented as follows:
</bodyText>
<listItem confidence="0.860577925925926">
1. Case assigners (P, active V, tensed I) have +ca
attribute. Governors that are not case assign-
ers (N, A, passive V) have -ca attribute.
2. Every item at NP node is assigned an at-
tribute value -cm, which means that the item
needs to be case-marked. The -cm attribute
then propagates with the item. This item is
said to be the origin of the -cm attribute.
3. Barrier links do not allow any item with -cm
to pass through, because, once the item goes
beyond the barrier, the origin of -cm will not
be governed, let alone case-marked.
4. Since each node has at most one governor, if
the governor is not a case assigner, the node
will not be case-marked. Therefore, a case-
filter violation is detected if +govern -cm -ca
co-occur in an item.
5. If +govern +ca -cm co-occur in an item, then
the head daughter of the item governs and
case-marks the origin of -cm. The case-filter
condition on the origin of -cm is met. The -cm
attribute is cleared.
For example, consider the following sentences:
(2) a. I believe John to have left.
b. *It was believed John to have left.
c. I would hope for John to leave.
d. *I would hope John to leave.
</listItem>
<bodyText confidence="0.999745818181818">
The word &amp;quot;believe&amp;quot; belongs to a subcategory of verb
(V:IP) that takes an IP as the complement. Since
there is no barrier between V:IP and the subject
of IP, words like &amp;quot;believe&amp;quot; can govern into the IP
complement and case-mark its subject (known as
exceptional case-marking in literature). In (2a), the
-cm attribute assigned to the item representing [NI,
John] percolates to V:IP node without being blocked
by any barrier. Since +govern +ca -cm co-occur in
the item at V:IP node, the case-filter is satisfied
(Figure 3.a). On the other hand, in (2b) the pas-
</bodyText>
<figure confidence="0.99779347368421">
1 1 6
+govern
/V:IP
+ca %%can
-pas
IP
believe
NP -cm Ibar
John
to have left
a. Case-filter satisfied at V:IP
+govern V:IP -cm
-ca `S.
+pas
IP
believed
NP -cm Ibar
John
to have left
b. Case-filter violation at V:EP
V:CP
1▪ 11▪ .
Cb
hope ++goavern
c ar
17/ crIr;
for NP -cm Ibar
John
to leave
c. Case-filter satisfied at Cbar, -cm cleared
CE11111....7cm
Cbar
hope -cm
IP
NP -cm Ibar
John
to leave
d. The attribute -cm is blocked by a barrier.
</figure>
<figureCaption confidence="0.999933">
Figure 3: Case Filter Examples
</figureCaption>
<bodyText confidence="0.996787785714286">
sive &amp;quot;believed&amp;quot; is not a case-assigner. The case-filter
violation is detected at V:IP node (Figure 3.b).
The word &amp;quot;hope&amp;quot; takes a CP complement. It
does not govern the subject of CP because there is
a barrier between them. The subject of an infini-
tive CP can only be governed by complement &amp;quot;for&amp;quot;
(Figure 3.c and 3.d).
4-criterion: Every chain must receive and ori-
only one 0-role, where a chain consists of an NP
and the traces (if any) coindexed with it (van
...liemsdijk and Williams, 1986, p.245).
We first consider chains consisting of one element.
The 0-criterion is implemented as the following con-
straints:
</bodyText>
<listItem confidence="0.995544222222222">
1. An item at NP node is assigned +theta if its
nform attribute is norm. Otherwise, if the value
of nt orm is there or it, then the item is as-
signed -theta.
2. Lexical nodes assign +theta or -theta to items
depending on whether they are 0-assigners (V,
A, P) or not (N, C).
3. Verbs and adjectives also have a subj-theta
attribute.
</listItem>
<bodyText confidence="0.967840181818182">
value 0-role* examples
+subj -theta yes &amp;quot;take&amp;quot;, &amp;quot;sleep&amp;quot;
-subj-theta no &amp;quot;seem&amp;quot;, passive verbs
*assigning 0-role to subject
This attribute percolates with the item from
V to IP. The IP node then check the value of
theta and subj-theta to make sure that the
verb assigns a 0-role to the subject if it re-
quires one, and vice versa.
Figure 4 shows an example of 0-criterion in action
when parsing:
</bodyText>
<figure confidence="0.8052162">
(3) *It loves Mary
-theta P+subj -theta
-cm t/ Sk, +govern
+ca
NP Ibar
It +theta v +theta
+subj-theta.&amp;quot;
+ca
+govern love NP
Mary
</figure>
<figureCaption confidence="0.999916">
Figure 4: 0-criterion in action
</figureCaption>
<bodyText confidence="0.99991175">
The subject NP, &amp;quot;it&amp;quot;, has attribute -theta, which
is percolated to the IP node. The verb &amp;quot;love&amp;quot; has
attributes +theta +subj-theta. The NP, &amp;quot;Mary&amp;quot;,
has attribute +theta. When the items representing
&amp;quot;love&amp;quot; and &amp;quot;Mary&amp;quot; are combined. Their theta at-
tribute are unifiable, thus satisfying the 0-criterion.
The +subj-theta attribute of &amp;quot;love&amp;quot; percolates with
the item representing &amp;quot;love Mary&amp;quot;, which is prop-
agated to IP node. When the item from NP and
Ibar are combined at IP node, the new item has
both -theta and +subj-theta attribute, resulting in
a 0-criterion violation.
</bodyText>
<page confidence="0.995088">
117
</page>
<bodyText confidence="0.999428909090909">
The above constraints guarantee that chains
with only one element satisfy 0-criterion. We now
consider chains with more than one element. The
base-position of a wh-movement is case-marked and
assigned a 0-role. The base position of an rip-
movement is assigned a 0-role, but not case-marked.
To ensure that the movement chains satisfy 0-
criterion we need only to make sure that the items
representing the parents of intermediate traces and
landing sites of the movements satisfy these condi-
tions:
</bodyText>
<listItem confidence="0.753523888888889">
• None of +ca, +theta and +subj-theta is
present in the items representing the parent
of intermediate traces of (wh- and np-) move-
ments as well as the landing sites of wh-
movements, thus these positions are not case-
marked and assigned a 0-role.
• Both +ca and +subj-theta are present in the
items representing parents of landing sites of
np-movements.
</listItem>
<bodyText confidence="0.992345">
Sub jacency: Movement cannot cross more than&apos;
one barrier (Haegeman, 1991, p.494).
A wh-movement carries a whbarrier attribute. The
value -whbarrier means that the movement has not
crossed any barrier and +whbarrier means that the
movement has already crossed one barrier. Barrier
links allow items with -whbarrier to pass through,
but change the value to +whbarrier. Items with
+whbarrier are blocked by barrier links. When a
wh-movement leaves an intermediate trace at a po-
sition, the corresponding whbarrier becomes -.
The subjacency of np-movements is similarly
handled with a npbarrier attribute.
Empty Category Principle (ECP): A trace&amp;quot;
or its parent must be properly governed.
In literature, proper government is not, as the term
suggests, subsumed by government. For example,
in
</bodyText>
<listItem confidence="0.658669">
(4) Who do you think [cp e&apos; [ip e came]]
</listItem>
<bodyText confidence="0.99887275">
the tensed I in [ip e came] governs but does not
properly govern the trace e. On the other hand, e&apos;
properly governs but does not govern e (Haegeman,
1991, p.456).
Here, we define proper government to be a sub-
class of government:
Proper government: A properly governs B if A
governs B and A is a 0-role assigner (A do not
have to assign 0-role to B).
Therefore, if an item have both +govern and one of
+theta or +subj-theta, then the head of the item
properly governs the non-head source items and
their sources that are reachable via a sequence of
non-barrier links. This definition unifies the notions
of government and proper government. In (4), e is
properly governed by tensed I, e&apos; is properly gov-
erned by &amp;quot;think&amp;quot;.
This definition won&apos;t be able to account for
difference between (4) and (5) (That-Trace Effect
(Haegeman, 1991, p.456)):
</bodyText>
<listItem confidence="0.522335">
(5) *Who do you think [cp e&apos; that [Hp e came]]
</listItem>
<bodyText confidence="0.9847166">
However, That-Trace Effect can be explained by a
separate principle.
The proper government of wh-traces are handled
by an attribute whpg (np-movements are similarly
dealt with by an uppg attribute):
Value Meaning
-whpg the most recent trace has yet to
+whpg be properly governed.
the most recent trace has already
been properly governed.
</bodyText>
<listItem confidence="0.764386888888889">
1. If an item has the attributes -whpg, -theta,
+govern, then the item is an ECP violation,
because the governor of the trace is not a 0-
role assigner. If an item has attributes -whpg,
+theta, +govern, then the trace is properly
governed. The value of whpg is changed to +.
2. Whenever a wh-movement leaves an interme-
diate trace, whpg becomes -.
3. Barrier links block items with -whpg.
</listItem>
<figureCaption confidence="0.995005">
Figure 5: An example of ECP violation
</figureCaption>
<bodyText confidence="0.964989625">
For example, the word claim takes a CP corn-
plement. In the sentence:
(6) *Whoi did you make the claim e that
Reagan met ei
there is a wh-movement out of the complement CP
of claim. When the movement left an intermedi-
ate trace at CSpec, the value of whpg became -.
When the item with -whpg is combined with the item
</bodyText>
<figure confidence="0.978109857142857">
CSpec Cbar
e&apos;
+govern
-theta CP
-ca
claim
1 1 8
</figure>
<bodyText confidence="0.974208578947368">
representing claim, their unification has attributes
(+govern -theta -whpg), which is an ECP violation.
The item is recognized as invalid and discarded.
PRO Theorem: PRO must be ungoverned
(Haegeman, 1991, p.263).
When the IP node receives an item from Ibar with
cform not being fin, the node makes a copy of the
item and assign +pro and -ppro to the copy and
then send it further without combining it with any
item from (subject) NP node. The attribute +pro
represents the hypothesis that the subject of the
clause is PRO. The meaning of -ppro is that the
subject PRO has not yet been protected (from being
governed).
When an item containing -ppro passes through a
barrier link, -ppro becomes +ppro which means that
the PRO subject has now been protected. A PRO-
theorem violation is detected if +govern and -ppro
co-occur in an item.
</bodyText>
<sectionHeader confidence="0.996645" genericHeader="method">
5. Objected-oriented Implementation
</sectionHeader>
<bodyText confidence="0.999958375">
The parser has been implemented in C++, an
object-oriented extension of C. The object-oriented
paradigm makes the relationships between nodes
and links in the grammar network and their soft-
ware counterparts explicit and direct. Communica-
tion via message passing is reflected in the message
passing metaphor used in object-oriented languages.
Nodes and links are implemented as objects.
Figure 6 shows the class hierarchy for nodes. The
constraints that implement the principles are dis-
tributed over the nodes and links in the network.
The implementation of the constraints is modular
because they are defined in class definitions and all
the instances of the class and its subclasses inherit
these constraints. The object-oriented paradigm al-
lows the subclasses to modify the constraints.
The implementation of the parser has been
tested with example sentences from Chapters 4-
10, 15-18 of (van Riemsdijk and Williams, 1986).
The chapters left out are mostly about logical form
and Binding Theory, which have not yet been im-
plemented in the parser. The average parsing time
for sentences with 5 to 20 words is below half of a
second on a SPARCstation ELC.
</bodyText>
<sectionHeader confidence="0.972931" genericHeader="method">
6. Discussion and Related Work
</sectionHeader>
<subsectionHeader confidence="0.629495">
Complexity of unification
</subsectionHeader>
<bodyText confidence="0.999530285714286">
The attribute vectors used here are similar to those
in unification based grammars/parsers. An impor-
tant difference, however, is that the attribute vec-
tors used here satisfy the unit closure condition
(Barton, Jr. et al., 1987, p.257). That is, non-
atomic attribute values are vectors that consist only
of atomic attribute values. For example:
</bodyText>
<construct confidence="0.250407333333333">
(7) a. ((cat v) +pas +whpg (wh-atts (cat p))
b. * ((cat v) +pas +whpg (wh-atts (cat v)
(np-att (cat n))))
</construct>
<bodyText confidence="0.983708076923077">
(7a) satisfies the unit closure condition, whereas
(7b) does not, because wh-atts in (7b) contains a
non-atomic attribute np-atts. (Barton, Jr. et al.,
1987) argued that the unification of recursive at-
tribute structures is a major source of computa-
tional complexity. On the other hand, let a be the
number of atomic attributes, n be the number of
non-atomic attributes. The time it takes to unify
two attribute vectors is a + ma if they satisfy the
unit closure condition. Since both n and a can
be regarded as constants, the unification takes only
constant amount of time. In our current implemen-
tation, n -= 2, a = 59.
</bodyText>
<sectionHeader confidence="0.642525" genericHeader="method">
Attribute grammar interpretation
</sectionHeader>
<bodyText confidence="0.999759692307692">
Correa (1991) proposed an interpretation of GB
principles based on attribute grammars. An at-
tribute grammar consists of a phrase structure
grammar and a set of attribution rules to compute
the attribute values of the non-terminal symbols.
The attributes are evaluated after a parse tree has
been constructed by the phrase structure grammar.
The original objective of attribute grammar is to
derive the semantics of programs from parse trees.
Since programming languages are designed to be un-
ambiguous, the attribution rules need to be eval-
uated on only one parse tree. In attribute gram-
mar interpretation of GB theory, the principles are
</bodyText>
<figure confidence="0.935371428571429">
OBNode
Bar0Node
BarlNode
Bar2Node
ISECE ERTI ITLIM
0
instance of subclass of instance
</figure>
<figureCaption confidence="0.994223">
Figure 6: The class hierarchy for nodes
</figureCaption>
<figure confidence="0.990125636363636">
/ I \
/ I I \ ,
iiwodei
000
II I I \
/ I I 1 \
/III\ IcPI
/ I I I \ 4
flAGGOOCO
class
1 1 9
</figure>
<bodyText confidence="0.999810444444444">
encoded in the attribution rules, and the phrase
structure grammar is replaced by X-bar theory and
Move-a. Therefore, a large number of structures
will be constructed and evaluated by the attribution
rules, thus leading to a serious overgeneration prob-
lem. For this reason, Correa pointed out that the
attribute grammar interpretation should be used as
a specification of an implementation, rather than an
implementation itself.
</bodyText>
<sectionHeader confidence="0.600785" genericHeader="method">
Actor-based GB parsing
</sectionHeader>
<bodyText confidence="0.999896307692308">
Abney and Cole (1986) presented a GB parser that
uses actors (Agha, 1986). Actors are similar to ob-
jects in having internal states and responding to
messages. In our model, each syntactic category
is represented by an object. In (Abney and Cole,
1986), each instance of a category is represented
by an actor. The actors build structures by creat-
ing other actors and their relationships according to
0-assignment, predication, and functional-selection.
Other principles are then used to filter out illicit
structures, such as subjacency and case-filter. This
generate-and-test nature of the algorithm makes it
suscetible to the overgeneration problem.
</bodyText>
<sectionHeader confidence="0.972037" genericHeader="conclusions">
7. Conclusion
</sectionHeader>
<bodyText confidence="0.999774">
We have presented an efficient message passing al-
gorithm for principle-based parsing, where
</bodyText>
<listItem confidence="0.9614418">
• overgeneration is avoided by interpreting prin-
ciples in terms of descriptions of structures;
• constraint checking involves only a constant-
sized attribute vector;
• principles are checked in different orders at dif-
</listItem>
<bodyText confidence="0.889341666666667">
ferent places so that stricter principles are ap-
plied earlier.
We have also proposed simplifications of GB the-
ory with regard to barrier and proper government,
which have been found to be adequate in our exper-
iments so far.
</bodyText>
<sectionHeader confidence="0.999522" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.997235509433963">
Abney, S. and Cole, J. (1986). A government-
binding parser. In Proceedings of NELS.
Agha, G. A. (1986). Actors: a model of concurrent
computation in distributed system. MIT Press,
Cambridge, MA.
Barton, Jr., G. E., Berwick, R. C., and Ristad, E. S.
(1987). Computational Complexity and Natural
Language. The MIT Press, Cambridge, Mas-
sachusetts.
Berwick, R. C. (1991). Principles of principle-based
parsing. In Berwick, B. C., Abney, S. P., and
Tenny, C., editors, Principle-Based Parsing:
Computation and Psycholinguistics, pages 1-
38. Kluwer Academic Publishers.
Chomsky, N. (1981). Lectures on Government
and Binding. Foris Publications, Cinnaminson,
USA.
Chomsky, N. (1986). Barriers. Linguistic Inquiry
Monographs. The MIT Press, Cambridge, MA.
Correa, N. (1991). Empty categories, chains, and
parsing. In Berwick, B. C., Abney, S. P., and
Tenny, C., editors, Principle-Based Parsing:
Computation and Psycholinguistics, pages 83-
121. Kluwer Academic Publishers.
Dorr, B. J. (1991). Principle-based parsing for ma-
chine translation. In Berwick, B. C., Abney,
S. P., and Tenny, C., editors, Principle-Based
Parsing: Computation and Psycholinguistics,
pages 153-184. Kluwer Academic Publishers.
Fong, S. (1991). The computational implementation
of principle-based parsers. In Berwick, B. C.,
Abney, S. P., and Tenny, C., editors, Principle-
Based Parsing: Computation and Psycholin-
guistics, pages 65-82. Kluwer Academic Pub-
lishers.
Haegeman, L. (1991). Introduction to Government
and Binding Theory. Basil Blackwell Ltd.
Johnson, M. (1991). Deductive parsing: The use
of knowledge of language. In Berwick, B. C.,
Abney, S. P., and Tenny, C., editors, Principle-
Based Parsing: Computation and Psycholin-
guistics, pages 39-64. Kluwer Academic Pub-
lishers.
Lin, D. and Goebel, R. (1993). Contex-free gram-
mar parsing by message passing. In Proceedings
of PACLING-93, Vancouver, BC.
Radford, A. (1988). Transformational Grammar.
Cambridge Textbooks in Linguistics. Cam-
bridge University Press, Cambridge, England.
van Riemsdijk, H. and Williams, E. (1986). Intro-
duction to the Theory of Grammar. Current
Studies in Linguistics. The MIT Press, Cam-
bridge, Massachusetts.
</reference>
<page confidence="0.996171">
120
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.882720">
<title confidence="0.998485">PARSING WITHOUT</title>
<author confidence="0.998967">Dekang Lin</author>
<affiliation confidence="0.999916">Department of Computing Science, University of Manitoba</affiliation>
<address confidence="0.999638">Winnipeg, Manitoba, Canada, R3T 2N2</address>
<email confidence="0.999602">E-mail:lindek@cs.umanitoba.ca</email>
<abstract confidence="0.997527">Overgeneration is the main source of computational complexity in previous principle-based parsers. This paper presents a message passing algorithm for principle-based parsing that avoids the overgeneration problem. This algorithm has been implemented in C++ and successfully tested with example sen-</abstract>
<note confidence="0.902525">tences from (van Riemsdijk and Williams, 1986).</note>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>S Abney</author>
<author>J Cole</author>
</authors>
<title>A governmentbinding parser.</title>
<date>1986</date>
<booktitle>In Proceedings of NELS.</booktitle>
<contexts>
<context position="29647" citStr="Abney and Cole (1986)" startWordPosition="5087" endWordPosition="5090">ass of instance Figure 6: The class hierarchy for nodes / I \ / I I \ , iiwodei 000 II I I \ / I I 1 \ /III\ IcPI / I I I \ 4 flAGGOOCO class 1 1 9 encoded in the attribution rules, and the phrase structure grammar is replaced by X-bar theory and Move-a. Therefore, a large number of structures will be constructed and evaluated by the attribution rules, thus leading to a serious overgeneration problem. For this reason, Correa pointed out that the attribute grammar interpretation should be used as a specification of an implementation, rather than an implementation itself. Actor-based GB parsing Abney and Cole (1986) presented a GB parser that uses actors (Agha, 1986). Actors are similar to objects in having internal states and responding to messages. In our model, each syntactic category is represented by an object. In (Abney and Cole, 1986), each instance of a category is represented by an actor. The actors build structures by creating other actors and their relationships according to 0-assignment, predication, and functional-selection. Other principles are then used to filter out illicit structures, such as subjacency and case-filter. This generate-and-test nature of the algorithm makes it suscetible t</context>
</contexts>
<marker>Abney, Cole, 1986</marker>
<rawString>Abney, S. and Cole, J. (1986). A governmentbinding parser. In Proceedings of NELS.</rawString>
</citation>
<citation valid="true">
<authors>
<author>G A Agha</author>
</authors>
<title>Actors: a model of concurrent computation in distributed system.</title>
<date>1986</date>
<publisher>MIT Press,</publisher>
<location>Cambridge, MA.</location>
<contexts>
<context position="29699" citStr="Agha, 1986" startWordPosition="5098" endWordPosition="5099">/ I I \ , iiwodei 000 II I I \ / I I 1 \ /III\ IcPI / I I I \ 4 flAGGOOCO class 1 1 9 encoded in the attribution rules, and the phrase structure grammar is replaced by X-bar theory and Move-a. Therefore, a large number of structures will be constructed and evaluated by the attribution rules, thus leading to a serious overgeneration problem. For this reason, Correa pointed out that the attribute grammar interpretation should be used as a specification of an implementation, rather than an implementation itself. Actor-based GB parsing Abney and Cole (1986) presented a GB parser that uses actors (Agha, 1986). Actors are similar to objects in having internal states and responding to messages. In our model, each syntactic category is represented by an object. In (Abney and Cole, 1986), each instance of a category is represented by an actor. The actors build structures by creating other actors and their relationships according to 0-assignment, predication, and functional-selection. Other principles are then used to filter out illicit structures, such as subjacency and case-filter. This generate-and-test nature of the algorithm makes it suscetible to the overgeneration problem. 7. Conclusion We have </context>
</contexts>
<marker>Agha, 1986</marker>
<rawString>Agha, G. A. (1986). Actors: a model of concurrent computation in distributed system. MIT Press, Cambridge, MA.</rawString>
</citation>
<citation valid="true">
<authors>
<author>G E Barton</author>
<author>R C Berwick</author>
<author>E S Ristad</author>
</authors>
<date>1987</date>
<booktitle>Computational Complexity and Natural Language. The</booktitle>
<publisher>MIT Press,</publisher>
<location>Cambridge, Massachusetts.</location>
<marker>Barton, Berwick, Ristad, 1987</marker>
<rawString>Barton, Jr., G. E., Berwick, R. C., and Ristad, E. S. (1987). Computational Complexity and Natural Language. The MIT Press, Cambridge, Massachusetts.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R C Berwick</author>
</authors>
<title>Principles of principle-based parsing.</title>
<date>1991</date>
<booktitle>Principle-Based Parsing: Computation and Psycholinguistics,</booktitle>
<pages>1--38</pages>
<editor>In Berwick, B. C., Abney, S. P., and Tenny, C., editors,</editor>
<publisher>Kluwer Academic Publishers.</publisher>
<contexts>
<context position="1628" citStr="Berwick, 1991" startWordPosition="236" endWordPosition="237">nciples is to 1. generate candidate structures of the sentence that satisfy X-bar theory and subcategorization frames of the words in the sentence. 2. filter out structures that violates any one of the principles. 3. the remaining structures are accepted as parse trees of the sentence. This implementation of GB theory is very inefficient, since there are a large number of structures being generated and then filtered out. The problem of producing too many illicit structures is called overgeneration and has been recognized as the culprit of computational difficulties in principle-based parsing (Berwick, 1991). Many methods have been proposed to alleviate the overgeneration problem by detecting illicit structures as early as possible, such as optimal ordering of principles (Fong, 1991), coroutining (Dorr, 1991; Johnson, 1991). 1The author wishes to thank the anonymous referees for their helpful comments and suggestions. This research was supported by Natural Sciences and Engineering Research Council of Canada grant 0GP121338. This paper presents a principle-based parser that avoids the overgeneration problem by applying principles to descriptions of the structures, instead of the structures themsel</context>
</contexts>
<marker>Berwick, 1991</marker>
<rawString>Berwick, R. C. (1991). Principles of principle-based parsing. In Berwick, B. C., Abney, S. P., and Tenny, C., editors, Principle-Based Parsing: Computation and Psycholinguistics, pages 1-38. Kluwer Academic Publishers.</rawString>
</citation>
<citation valid="true">
<authors>
<author>N Chomsky</author>
</authors>
<title>Lectures on Government and Binding.</title>
<date>1981</date>
<publisher>Foris Publications,</publisher>
<location>Cinnaminson, USA.</location>
<contexts>
<context position="694" citStr="Chomsky, 1981" startWordPosition="91" endWordPosition="92">g Science, University of Manitoba Winnipeg, Manitoba, Canada, R3T 2N2 E-mail: lindek@cs.umanitoba.ca Abstract Overgeneration is the main source of computational complexity in previous principle-based parsers. This paper presents a message passing algorithm for principle-based parsing that avoids the overgeneration problem. This algorithm has been implemented in C++ and successfully tested with example sentences from (van Riemsdijk and Williams, 1986). 1. Introduction Unlike rule-based grammars that use a large number of rules to describe patterns in a language, Government-Binding (GB) Theory (Chomsky, 1981; Haegeman, 1991; van Riemsdijk and Williams, 1986) explains these patterns in terms of more foundmental and universal principles. A key issue in building a principle-based parser is how to procedurally interpret the principles. Since GB principles are constraints over syntactic structures, one way to implement the principles is to 1. generate candidate structures of the sentence that satisfy X-bar theory and subcategorization frames of the words in the sentence. 2. filter out structures that violates any one of the principles. 3. the remaining structures are accepted as parse trees of the sen</context>
</contexts>
<marker>Chomsky, 1981</marker>
<rawString>Chomsky, N. (1981). Lectures on Government and Binding. Foris Publications, Cinnaminson, USA.</rawString>
</citation>
<citation valid="true">
<authors>
<author>N Chomsky</author>
</authors>
<title>Barriers. Linguistic Inquiry Monographs.</title>
<date>1986</date>
<publisher>The MIT Press,</publisher>
<location>Cambridge, MA.</location>
<contexts>
<context position="12047" citStr="Chomsky (1986)" startWordPosition="2057" endWordPosition="2058">ead of the structures themselves, we must be able to model these notions with the descriptions. Dominance and m-command: Dominance and m-command are relationships between nodes in syntactic structures. Since an item represent a node in a syntactic structure, relationships between the nodes can be represented by relationships between items: dominance: An item dominates its direct and indirect sources. For example, in Figure 2, i4 dominates i1, i2, and i3. in-command: The head daughter of an item representing a maximal category m-commands nonhead daughters of the item and their sources. Barrier Chomsky (1986) proposed the notion of barrier to unify the treatment of government and subjacency. In Chomsky&apos;s proposal, barrierhood is a property of maximal nodes (nodes representing maximal categories). However, not every maximal node is a barrier. The barrierhood of a node also depends on its context, in terms of L-marking and inheritance. Instead of making barrierhood a property of the nodes in syntactic structures, we define it to be a property of links in the grammar network. That is, certain links in the grammar network are classified as barriers. In Figure 1, barrier links have a black ink-spot on </context>
<context position="13626" citStr="Chomsky, 1986" startWordPosition="2326" endWordPosition="2327">ed as follows: government: A governs B if A is the minimal governor that m-commands B via a sequence of non-barrier links, where governors are N, V, P, A, and tensed I. Items representing governors are assigned +govern attribute. This attribute percolates across head dominance links. If an item has +govern attribute, then non-head sources of the item and their sources are governed by the head of the item if there are paths between them and the item satisfying the conditions: 1. there is no barrier on the path. 2. there is no other item with +govern attribute on the path (minimality condition (Chomsky, 1986, p.10)). Movement :3 Movement is a major source of complexity in principle-based parsing. Directly modeling Move-a would obviously generate a large number of invalid movements. Fortunately, movements must also satisfy: c-command condition: A moved element must ccommand its trace (Radford, 1988, p.564), where A c-command B if A does not dominate B but the parent of A dominates B. The c-command condition implies that a movement consists of a sequence of moves in the reverse direction of dominance links, except the last one. Therefore, we can model a movement with a set of attribute values. If a</context>
</contexts>
<marker>Chomsky, 1986</marker>
<rawString>Chomsky, N. (1986). Barriers. Linguistic Inquiry Monographs. The MIT Press, Cambridge, MA.</rawString>
</citation>
<citation valid="true">
<authors>
<author>N Correa</author>
</authors>
<title>Empty categories, chains, and parsing.</title>
<date>1991</date>
<booktitle>Principle-Based Parsing: Computation and Psycholinguistics,</booktitle>
<pages>83--121</pages>
<editor>In Berwick, B. C., Abney, S. P., and Tenny, C., editors,</editor>
<publisher>Kluwer Academic Publishers.</publisher>
<contexts>
<context position="28331" citStr="Correa (1991)" startWordPosition="4865" endWordPosition="4866">) does not, because wh-atts in (7b) contains a non-atomic attribute np-atts. (Barton, Jr. et al., 1987) argued that the unification of recursive attribute structures is a major source of computational complexity. On the other hand, let a be the number of atomic attributes, n be the number of non-atomic attributes. The time it takes to unify two attribute vectors is a + ma if they satisfy the unit closure condition. Since both n and a can be regarded as constants, the unification takes only constant amount of time. In our current implementation, n -= 2, a = 59. Attribute grammar interpretation Correa (1991) proposed an interpretation of GB principles based on attribute grammars. An attribute grammar consists of a phrase structure grammar and a set of attribution rules to compute the attribute values of the non-terminal symbols. The attributes are evaluated after a parse tree has been constructed by the phrase structure grammar. The original objective of attribute grammar is to derive the semantics of programs from parse trees. Since programming languages are designed to be unambiguous, the attribution rules need to be evaluated on only one parse tree. In attribute grammar interpretation of GB th</context>
</contexts>
<marker>Correa, 1991</marker>
<rawString>Correa, N. (1991). Empty categories, chains, and parsing. In Berwick, B. C., Abney, S. P., and Tenny, C., editors, Principle-Based Parsing: Computation and Psycholinguistics, pages 83-121. Kluwer Academic Publishers.</rawString>
</citation>
<citation valid="true">
<authors>
<author>B J Dorr</author>
</authors>
<title>Principle-based parsing for machine translation.</title>
<date>1991</date>
<booktitle>Principle-Based Parsing: Computation and Psycholinguistics,</booktitle>
<pages>153--184</pages>
<editor>In Berwick, B. C., Abney, S. P., and Tenny, C., editors,</editor>
<publisher>Kluwer Academic Publishers.</publisher>
<contexts>
<context position="1832" citStr="Dorr, 1991" startWordPosition="265" endWordPosition="266">ples. 3. the remaining structures are accepted as parse trees of the sentence. This implementation of GB theory is very inefficient, since there are a large number of structures being generated and then filtered out. The problem of producing too many illicit structures is called overgeneration and has been recognized as the culprit of computational difficulties in principle-based parsing (Berwick, 1991). Many methods have been proposed to alleviate the overgeneration problem by detecting illicit structures as early as possible, such as optimal ordering of principles (Fong, 1991), coroutining (Dorr, 1991; Johnson, 1991). 1The author wishes to thank the anonymous referees for their helpful comments and suggestions. This research was supported by Natural Sciences and Engineering Research Council of Canada grant 0GP121338. This paper presents a principle-based parser that avoids the overgeneration problem by applying principles to descriptions of the structures, instead of the structures themselves. A structure for the input sentence is only constructed after its description has been found to satisfy all the principles. The structure can then be retrieved in time linear to its size and is guaran</context>
</contexts>
<marker>Dorr, 1991</marker>
<rawString>Dorr, B. J. (1991). Principle-based parsing for machine translation. In Berwick, B. C., Abney, S. P., and Tenny, C., editors, Principle-Based Parsing: Computation and Psycholinguistics, pages 153-184. Kluwer Academic Publishers.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S Fong</author>
</authors>
<title>The computational implementation of principle-based parsers.</title>
<date>1991</date>
<booktitle>PrincipleBased Parsing: Computation and Psycholinguistics,</booktitle>
<pages>65--82</pages>
<editor>In Berwick, B. C., Abney, S. P., and Tenny, C., editors,</editor>
<publisher>Kluwer Academic Publishers.</publisher>
<contexts>
<context position="1807" citStr="Fong, 1991" startWordPosition="262" endWordPosition="263">ates any one of the principles. 3. the remaining structures are accepted as parse trees of the sentence. This implementation of GB theory is very inefficient, since there are a large number of structures being generated and then filtered out. The problem of producing too many illicit structures is called overgeneration and has been recognized as the culprit of computational difficulties in principle-based parsing (Berwick, 1991). Many methods have been proposed to alleviate the overgeneration problem by detecting illicit structures as early as possible, such as optimal ordering of principles (Fong, 1991), coroutining (Dorr, 1991; Johnson, 1991). 1The author wishes to thank the anonymous referees for their helpful comments and suggestions. This research was supported by Natural Sciences and Engineering Research Council of Canada grant 0GP121338. This paper presents a principle-based parser that avoids the overgeneration problem by applying principles to descriptions of the structures, instead of the structures themselves. A structure for the input sentence is only constructed after its description has been found to satisfy all the principles. The structure can then be retrieved in time linear </context>
</contexts>
<marker>Fong, 1991</marker>
<rawString>Fong, S. (1991). The computational implementation of principle-based parsers. In Berwick, B. C., Abney, S. P., and Tenny, C., editors, PrincipleBased Parsing: Computation and Psycholinguistics, pages 65-82. Kluwer Academic Publishers.</rawString>
</citation>
<citation valid="true">
<authors>
<author>L Haegeman</author>
</authors>
<title>Introduction to Government and Binding Theory.</title>
<date>1991</date>
<publisher>Basil Blackwell Ltd.</publisher>
<contexts>
<context position="710" citStr="Haegeman, 1991" startWordPosition="93" endWordPosition="94">ersity of Manitoba Winnipeg, Manitoba, Canada, R3T 2N2 E-mail: lindek@cs.umanitoba.ca Abstract Overgeneration is the main source of computational complexity in previous principle-based parsers. This paper presents a message passing algorithm for principle-based parsing that avoids the overgeneration problem. This algorithm has been implemented in C++ and successfully tested with example sentences from (van Riemsdijk and Williams, 1986). 1. Introduction Unlike rule-based grammars that use a large number of rules to describe patterns in a language, Government-Binding (GB) Theory (Chomsky, 1981; Haegeman, 1991; van Riemsdijk and Williams, 1986) explains these patterns in terms of more foundmental and universal principles. A key issue in building a principle-based parser is how to procedurally interpret the principles. Since GB principles are constraints over syntactic structures, one way to implement the principles is to 1. generate candidate structures of the sentence that satisfy X-bar theory and subcategorization frames of the words in the sentence. 2. filter out structures that violates any one of the principles. 3. the remaining structures are accepted as parse trees of the sentence. This impl</context>
<context position="17111" citStr="Haegeman, 1991" startWordPosition="2926" endWordPosition="2927"> The first condition requires that every non-lexical category have a head. This is guaranteed by a constraint in item combination: one of the sources of the two items being combined must be from the head daughter. The second condition is implemented by the structure of the grammar network. The combinations of items represent constructions of larger parse trees from smaller ones. Since the structure of the grammar network satisfies the constraint, the parse trees constructed by item combination also satisfy the X-bar theory. [Case Filter: Every lexical NP must be case-- signer and A governs B (Haegeman, 1991, p.156). marked, where A case-marks B if A is a case asThe case filter is implemented as follows: 1. Case assigners (P, active V, tensed I) have +ca attribute. Governors that are not case assigners (N, A, passive V) have -ca attribute. 2. Every item at NP node is assigned an attribute value -cm, which means that the item needs to be case-marked. The -cm attribute then propagates with the item. This item is said to be the origin of the -cm attribute. 3. Barrier links do not allow any item with -cm to pass through, because, once the item goes beyond the barrier, the origin of -cm will not be go</context>
<context position="22360" citStr="Haegeman, 1991" startWordPosition="3854" endWordPosition="3855">he movement chains satisfy 0- criterion we need only to make sure that the items representing the parents of intermediate traces and landing sites of the movements satisfy these conditions: • None of +ca, +theta and +subj-theta is present in the items representing the parent of intermediate traces of (wh- and np-) movements as well as the landing sites of whmovements, thus these positions are not casemarked and assigned a 0-role. • Both +ca and +subj-theta are present in the items representing parents of landing sites of np-movements. Sub jacency: Movement cannot cross more than&apos; one barrier (Haegeman, 1991, p.494). A wh-movement carries a whbarrier attribute. The value -whbarrier means that the movement has not crossed any barrier and +whbarrier means that the movement has already crossed one barrier. Barrier links allow items with -whbarrier to pass through, but change the value to +whbarrier. Items with +whbarrier are blocked by barrier links. When a wh-movement leaves an intermediate trace at a position, the corresponding whbarrier becomes -. The subjacency of np-movements is similarly handled with a npbarrier attribute. Empty Category Principle (ECP): A trace&amp;quot; or its parent must be properly</context>
<context position="23946" citStr="Haegeman, 1991" startWordPosition="4121" endWordPosition="4122"> government: Proper government: A properly governs B if A governs B and A is a 0-role assigner (A do not have to assign 0-role to B). Therefore, if an item have both +govern and one of +theta or +subj-theta, then the head of the item properly governs the non-head source items and their sources that are reachable via a sequence of non-barrier links. This definition unifies the notions of government and proper government. In (4), e is properly governed by tensed I, e&apos; is properly governed by &amp;quot;think&amp;quot;. This definition won&apos;t be able to account for difference between (4) and (5) (That-Trace Effect (Haegeman, 1991, p.456)): (5) *Who do you think [cp e&apos; that [Hp e came]] However, That-Trace Effect can be explained by a separate principle. The proper government of wh-traces are handled by an attribute whpg (np-movements are similarly dealt with by an uppg attribute): Value Meaning -whpg the most recent trace has yet to +whpg be properly governed. the most recent trace has already been properly governed. 1. If an item has the attributes -whpg, -theta, +govern, then the item is an ECP violation, because the governor of the trace is not a 0- role assigner. If an item has attributes -whpg, +theta, +govern, t</context>
<context position="25335" citStr="Haegeman, 1991" startWordPosition="4366" endWordPosition="4367">h -whpg. Figure 5: An example of ECP violation For example, the word claim takes a CP cornplement. In the sentence: (6) *Whoi did you make the claim e that Reagan met ei there is a wh-movement out of the complement CP of claim. When the movement left an intermediate trace at CSpec, the value of whpg became -. When the item with -whpg is combined with the item CSpec Cbar e&apos; +govern -theta CP -ca claim 1 1 8 representing claim, their unification has attributes (+govern -theta -whpg), which is an ECP violation. The item is recognized as invalid and discarded. PRO Theorem: PRO must be ungoverned (Haegeman, 1991, p.263). When the IP node receives an item from Ibar with cform not being fin, the node makes a copy of the item and assign +pro and -ppro to the copy and then send it further without combining it with any item from (subject) NP node. The attribute +pro represents the hypothesis that the subject of the clause is PRO. The meaning of -ppro is that the subject PRO has not yet been protected (from being governed). When an item containing -ppro passes through a barrier link, -ppro becomes +ppro which means that the PRO subject has now been protected. A PROtheorem violation is detected if +govern a</context>
</contexts>
<marker>Haegeman, 1991</marker>
<rawString>Haegeman, L. (1991). Introduction to Government and Binding Theory. Basil Blackwell Ltd.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Johnson</author>
</authors>
<title>Deductive parsing: The use of knowledge of language.</title>
<date>1991</date>
<booktitle>PrincipleBased Parsing: Computation and Psycholinguistics,</booktitle>
<pages>39--64</pages>
<editor>In Berwick, B. C., Abney, S. P., and Tenny, C., editors,</editor>
<publisher>Kluwer Academic Publishers.</publisher>
<contexts>
<context position="1848" citStr="Johnson, 1991" startWordPosition="267" endWordPosition="268"> remaining structures are accepted as parse trees of the sentence. This implementation of GB theory is very inefficient, since there are a large number of structures being generated and then filtered out. The problem of producing too many illicit structures is called overgeneration and has been recognized as the culprit of computational difficulties in principle-based parsing (Berwick, 1991). Many methods have been proposed to alleviate the overgeneration problem by detecting illicit structures as early as possible, such as optimal ordering of principles (Fong, 1991), coroutining (Dorr, 1991; Johnson, 1991). 1The author wishes to thank the anonymous referees for their helpful comments and suggestions. This research was supported by Natural Sciences and Engineering Research Council of Canada grant 0GP121338. This paper presents a principle-based parser that avoids the overgeneration problem by applying principles to descriptions of the structures, instead of the structures themselves. A structure for the input sentence is only constructed after its description has been found to satisfy all the principles. The structure can then be retrieved in time linear to its size and is guaranteed to be consi</context>
</contexts>
<marker>Johnson, 1991</marker>
<rawString>Johnson, M. (1991). Deductive parsing: The use of knowledge of language. In Berwick, B. C., Abney, S. P., and Tenny, C., editors, PrincipleBased Parsing: Computation and Psycholinguistics, pages 39-64. Kluwer Academic Publishers.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D Lin</author>
<author>R Goebel</author>
</authors>
<title>Contex-free grammar parsing by message passing.</title>
<date>1993</date>
<booktitle>In Proceedings of PACLING-93,</booktitle>
<location>Vancouver, BC.</location>
<contexts>
<context position="3366" citStr="Lin and Goebel, 1993" startWordPosition="491" endWordPosition="494">ection presents a general framework for parsing by message passing. Section 3 shows how linguistic notions, such as dominance and government, can be translated into relationships between descriptions of structures. Section 4 describes interpretation of GB principles. Familiarity with GB theory is assumed in the presentation. Section 5 sketches an object-oriented implementation of the parser. Section 6 discusses complexity issues and related work. 2. Parsing by Message Passing The message passing algorithm presented here is an extension to a message passing algorithm for context-free grammars (Lin and Goebel, 1993). We encode the grammar, as well as the parser, in a network (Figure 1). The nodes in the networks represent syntactic categories. The links in the network represent dominance and subsumption relationships between the categories: • There is a dominance link from node A to B if B can be immediately dominated by A. The dominance links can be further classified according to the type of dominance relationship. • There is a specialization link from A to B if A subsumes B. The network is also a parser. The nodes in the network are computing agents. They communicate 1 1 2 with each other by passing m</context>
</contexts>
<marker>Lin, Goebel, 1993</marker>
<rawString>Lin, D. and Goebel, R. (1993). Contex-free grammar parsing by message passing. In Proceedings of PACLING-93, Vancouver, BC.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Radford</author>
</authors>
<title>Transformational Grammar. Cambridge Textbooks in Linguistics.</title>
<date>1988</date>
<publisher>Cambridge University Press,</publisher>
<location>Cambridge, England.</location>
<contexts>
<context position="13921" citStr="Radford, 1988" startWordPosition="2369" endWordPosition="2370"> has +govern attribute, then non-head sources of the item and their sources are governed by the head of the item if there are paths between them and the item satisfying the conditions: 1. there is no barrier on the path. 2. there is no other item with +govern attribute on the path (minimality condition (Chomsky, 1986, p.10)). Movement :3 Movement is a major source of complexity in principle-based parsing. Directly modeling Move-a would obviously generate a large number of invalid movements. Fortunately, movements must also satisfy: c-command condition: A moved element must ccommand its trace (Radford, 1988, p.564), where A c-command B if A does not dominate B but the parent of A dominates B. The c-command condition implies that a movement consists of a sequence of moves in the reverse direction of dominance links, except the last one. Therefore, we can model a movement with a set of attribute values. If an item contains these attribute values, it means that there is a movement out of the structure represented by the item. For example, in Figure 2.b, item i10 contains movement attributes: nppg , npbarrier and np-atts. This indicates that there is an np-movement out of the VP whose root node is i</context>
</contexts>
<marker>Radford, 1988</marker>
<rawString>Radford, A. (1988). Transformational Grammar. Cambridge Textbooks in Linguistics. Cambridge University Press, Cambridge, England.</rawString>
</citation>
<citation valid="true">
<authors>
<author>H van Riemsdijk</author>
<author>E Williams</author>
</authors>
<title>Introduction to the Theory of Grammar. Current Studies in Linguistics.</title>
<date>1986</date>
<publisher>The MIT Press,</publisher>
<location>Cambridge, Massachusetts.</location>
<marker>van Riemsdijk, Williams, 1986</marker>
<rawString>van Riemsdijk, H. and Williams, E. (1986). Introduction to the Theory of Grammar. Current Studies in Linguistics. The MIT Press, Cambridge, Massachusetts.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>