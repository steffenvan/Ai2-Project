<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000516">
<title confidence="0.968143">
Referring Expressions as Formulas of Description Logic
</title>
<author confidence="0.964347">
Carlos Areces
</author>
<affiliation confidence="0.961969">
INRIA Nancy Grand Est
</affiliation>
<address confidence="0.588029">
Nancy, France
</address>
<email confidence="0.991484">
areces@loria.fr
</email>
<author confidence="0.993193">
Alexander Koller
</author>
<affiliation confidence="0.8818965">
University of Edinburgh
Edinburgh, UK
</affiliation>
<email confidence="0.983998">
a.koller@ed.ac.uk
</email>
<author confidence="0.914966">
Kristina Striegnitz
</author>
<affiliation confidence="0.880954">
Union College
</affiliation>
<address confidence="0.780952">
Schenectady, NY, US
</address>
<email confidence="0.998495">
striegnk@union.edu
</email>
<sectionHeader confidence="0.997388" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999812">
In this paper, we propose to reinterpret the
problem of generating referring expressions
(GRE) as the problem of computing a formula
in a description logic that is only satisfied by
the referent. This view offers a new unifying
perspective under which existing GRE algo-
rithms can be compared. We also show that
by applying existing algorithms for computing
simulation classes in description logic, we can
obtain extremely efficient algorithms for rela-
tional referring expressions without any dan-
ger of running into infinite regress.
</bodyText>
<sectionHeader confidence="0.999517" genericHeader="introduction">
1 Introduction
</sectionHeader>
<bodyText confidence="0.999755754385965">
The generation of referring expressions (GRE) is
one of the most active and successful research ar-
eas in natural language generation. Building upon
Dale and Reiter’s work (Dale, 1989; Dale and Reiter,
1995), various researchers have added extensions
such as reference to sets (Stone, 2000), more expres-
sive logical connectives (van Deemter, 2002), and
relational expressions (Dale and Haddock, 1991).
Referring expressions (REs) involving relations,
in particular, have received increasing attention re-
cently; especially in the context of spatial refer-
ring expressions in situated generation (e.g. (Kelle-
her and Kruijff, 2006)), where it seems particularly
natural to use expressions such as “the book on the
table”. However, the classical algorithm by Dale and
Haddock (1991) was recently shown to be unable
to generate satisfying REs in practice (Viethen and
Dale, 2006). Furthermore, the Dale and Haddock al-
gorithm and most of its successors (such as (Kelle-
her and Kruijff, 2006)) are vulnerable to the prob-
lem of “infinite regress”, where the algorithm jumps
back and forth between generating descriptions for
two related individuals infinitely, as in “the book on
the table which supports a book on the table ... ”.
In this paper, we propose to view GRE as the
problem of computing a formula of description logic
(DL) that denotes exactly the set of individuals that
we want to refer to. This very natural idea has been
mentioned in passing before (Krahmer et al., 2003;
Gardent and Striegnitz, 2007); however, we take it
one step further by proposing DL as an interlingua
for comparing the REs produced by different ap-
proaches to GRE. In this way, we can organize ex-
isting GRE approaches in an expressiveness hierar-
chy. For instance, the classical Dale and Reiter al-
gorithms compute purely conjunctive formulas; van
Deemter (2002) extends this language by adding the
other propositional connectives, whereas Dale and
Haddock (1991) extends it by allowing existential
quantification.
Furthermore, the view of GRE as a problem of
computing DL formulas with a given extension al-
lows us to apply existing algorithms for the lat-
ter problem to obtain efficient algorithms for GRE.
We present algorithms that compute such formulas
for the description logics £G (which allows only
conjunction and existential quantification) and AGC
(which also allows negation). These algorithms ef-
fectively compute REs for all individuals in the do-
main at the same time, which allows them to system-
atically avoid the infinite regress problem. The £G
algorithm is capable of generating 67% of the rela-
tional REs in the Viethen and Dale (2006) dataset, in
about 15 milliseconds. The AGC algorithm is even
faster; it computes relational REs for all 100 indi-
viduals in a random model in 140 milliseconds.
The paper is structured as follows. In Section 2,
</bodyText>
<page confidence="0.998235">
42
</page>
<bodyText confidence="0.99989975">
we will first define description logics. We will then
show how to generate REs by computing DL sim-
ilarity sets for AGC and £G in Section 3. In Sec-
tion 4, we evaluate our algorithms and discuss our
results. Section 5 compares our approach to related
research; in particular, it shows how various promi-
nent GRE algorithms fit into the DL framework.
Section 6 concludes and points to future work.
</bodyText>
<sectionHeader confidence="0.722899" genericHeader="method">
2 Description logics and similarity
</sectionHeader>
<bodyText confidence="0.991313933333333">
In this paper, we will represent referring expres-
sions as formulas of description logic (Baader et al.,
2003). In order to make this point, we will now de-
fine the two description logics we will be working
with: AGC and £G.
Formulas (or concepts) co of AGC are generated
by the following grammar:
co, co0 ::= T  |p  |-,co  |co n co0  |]R.co
where p is in the set of propositional symbols prop,
and R is in the set of relational symbols rel. £G is
the negation-free fragment of AGC.
Formulas of both AGC and £G are interpreted in
ordinary relational first-order models M = (A, ||&apos;||)
where A is a non-empty set and  ||&apos;  ||is an interpreta-
tion function such that:
</bodyText>
<equation confidence="0.971179166666667">
||p ||C A for p E prop
||R ||C A x A for R E rel
||-,co ||= A − ||co||
||co n co0 ||= ||co ||n ||co0||
||1R.co ||= {i  |for some i0, (i, i0) E ||R||
and i0 E ||co||}.
</equation>
<bodyText confidence="0.99970796969697">
Every formula of a description logic denotes a
set of individuals in the domain; thus we can use
such formulas to describe sets. For instance, in the
model in Fig. 1b, the formula flower denotes the set
{f1, f2}; the formula flower n lin.hat denotes {f2};
and the formula flower n -,Iin.hat denotes {f1}.
Different description logics differ in the inventory
of logical connectives they allow: While AGC per-
mits negation, £G doesn’t. There are many other
description logics in the literature; some that we
will get back to in Section 5 are CG (£G without
existential quantification, i.e., only conjunctions of
atoms); PG (AGC without existential quantification,
i.e., propositional logic); and £GLf(¬) (£G plus dis-
junction and atomic negation).
Below, we will use a key notion of formula preser-
vation that we call similarity. For any DL G, we
will say that an individual i is G-similar to i0 in a
given model M if for any formula co E G such that
i E ||co||, we also have i0 E ||co||. Equivalently, there
is no G-formula that holds of i but not of i0. We say
that the G-similarity set of some individual i is the
set of all individuals to which i is G-similar.
Notice that similarity is not necessarily a symmet-
rical relation: For instance, f1 is £G-similar to f2 in
Fig. 1b, but f2 is not £G-similar to f1 (it satisfies the
formula lin.hat and f1 doesn’t). However, AGC-
similarity is a symmetrical relation because the lan-
guage contains negation; and indeed, f1 is not AGC-
similar to f2 either because it satisfies -,]in.hat. Be-
cause AGC is more expressive than £G, it is possible
for some individual a to be £G-similar but not AGC-
similar to some individual b, but not vice versa.
</bodyText>
<sectionHeader confidence="0.970823" genericHeader="method">
3 Generating referring expressions
</sectionHeader>
<bodyText confidence="0.9997856">
Now we apply description logic to GRE. The core
claim of this paper is that it is natural and useful to
view the GRE problem as the problem of computing
a formula of some description logic G whose exten-
sion is a given target set A of individuals.
</bodyText>
<sectionHeader confidence="0.653944" genericHeader="method">
G-GRE PROBLEM
Input: A model M and a target set A C A.
</sectionHeader>
<bodyText confidence="0.992261388888889">
Output: A formula co E G such that ||co ||= A
(if such a formula exists).
In the examples above, it is because flower n
lin.hat denotes exactly {f2} that we can say “the
flower in the hat” to refer to f2. This perspective pro-
vides a general framework into which many existing
GRE approaches fit: Traditional attribute selection
(Dale and Reiter, 1995) corresponds to building DL
formulas that are conjunctions of atoms; relational
REs as in Dale and Haddock (1991) are formulas of
£G; and so on. We will further pursue the idea of or-
ganizing GRE approaches with respect to the variant
of DL they use in Section 5.
For the rest of this paper, we assume that we are
generating a singular RE, i.e., the target set A will
be a singleton. In this case, we will only be able
to generate a formula that denotes exactly A = {a}
(i.e., a RE that uniquely refers to a) if there is no
</bodyText>
<page confidence="0.999898">
43
</page>
<figureCaption confidence="0.9975175">
Figure 1: (a) The Dale and Haddock (1991) scenario; (b)
the Stone and Webber (1998) scenario.
</figureCaption>
<bodyText confidence="0.996538619047619">
other individual b to which a is similar; otherwise,
any formula that is satisfied by a is also satisfied by
b. Conversely, if we know that a is not similar to any
other individual, then there is a formula that is satis-
fied by a and not by anything else; this formula can
serve as a unique singular RE. In other words, we
can reduce the G-GRE problem for a given model
to the problem of computing the G-similarity sets of
this model. Notice that this use of similarity sets can
be seen as a generalization of van Deemter’s (2002)
“satellite sets” to relational descriptions.
In the rest of this section, we will present algo-
rithms that compute the similarity sets of a given
model for AGC and £G, together with characteris-
tic formulas that denote them. In the AGC case,
we adapt a standard algorithm from the literature
for computing simulation classes; we will then fur-
ther adapt this algorithm for £G. In effect, both al-
gorithms compute REs for all individuals in some
model at the same time – very efficiently and with-
out any danger of infinite regress.
</bodyText>
<subsectionHeader confidence="0.999929">
3.1 Computing similarity sets
</subsectionHeader>
<bodyText confidence="0.98550875">
It can be shown that for AGC, the similarity sets
of a finite model coincide exactly with the simu-
lation classes of this model. Simulation classes
have been studied extensively in the literature (see
e.g., Blackburn et al. (2001); Kurtonina and de Ri-
jke (1998)), and there are several efficient algorithms
for computing AGC-simulation classes (Hopcroft,
1971; Paige and Tarjan, 1987; Dovier et al., 2004).
However, these algorithms will only compute the
simulation classes themselves. Here we extend the
Hopcroft (1971) algorithm such that it computes,
along with each set, also a formula that denotes ex-
actly this set. We can then use these formulas as
representations of the referring expressions.
The pseudocode for our AGC algorithm is shown
as Algorithm 1 (with G = AGC) and Algorithm 2.
Given a model M = (A,  ||· ||), the algorithm com-
putes a set RE of AGC formulas such that {||co
co E RE} is the set of AGC-similarity sets of
M. The algorithm starts with RE = {T} (where
||T ||= A), and successively refines RE by mak-
ing its elements denote smaller and smaller sets. It
maintains the invariant that at the start and end of ev-
ery iteration, {||co   co E RE} is always a partition
of A. The algorithm iterates over all propositional
and relational symbols in prop and rel to construct
new formulas until either all formulas in RE denote
singletons (i.e., there is only one individual that sat-
isfies them), or no progress has been made in the
previous iteration. In each iteration, it calls the pro-
cedure addAcc(co, RE), which intersects co with any
formula 0 E RE which does not denote a singleton
and which is not equivalent to co and to eco. In this
case, it replaces 0 in RE by 0 n co and 0 n eco.
The AGC algorithm computes the AGC-similarity
sets of the model in time O(n3), where n is the num-
ber of individuals in the domain. However, it will
freely introduce negations in the case distinctions,
which can make the resulting formula hard to realize
(see also Section 4.3). This is why we also present
an algorithm for the £G-similarity sets; £G corre-
sponds to positive relational REs, which are gener-
ally much easier to realize.
We obtain the £G algorithm by replacing the call
to addAcc in Algorithm 1 by a call to addoL, which
is defined in Algorithm 3. As before, the algo-
rithm maintains a set RE = {co1, ... , con} of for-
mulas (this time of £G) such that ||co1 ||U ... U
||con ||= A, and which it refines iteratively. However,
where the AGC algorithm maintains the invariant
that ||co1||, ... ,||con ||is a partition of A, we weaken
this invariant to the requirement that there are no
m &gt; 2 pairwise different indices 1 &lt; i1, ... , im &lt;
n such that ||coi1 ||= ||coi2 ||U ... U ||coim||. We call coi1
subsumed if such a decomposition exists.
Because it maintains a weaker invariant, the set
RE may contain more formulas at the same time in
the £G algorithm than in the AGC algorithm. Given
that A has an exponential number of subsets, there is
a risk that the £G algorithm might have worst-case
</bodyText>
<figure confidence="0.943496211538461">
(a) c2 cup (b) r1 rabbit rabbit r2
bowl
cup
in
c1
on
b1
floor
b2
t1
table
on
on
in
bowl
f1
on
table
t2
flower
hat
hat
hat
hat
in
f2
in
h1 rabbit r4
h2
h3
h4
bathtub
flower
rabbit
in
r3
b1
f1
44
Algorithm 1: Computing the G-similarity sets
Input: A model M = (A,  ||- ||)
Output: A set RE of formulas such that
{||cp   cp E RE} is the set of
G-similarity sets of M.
1 RE +— {T}
2 for p E prop do
3 addL(p, RE)
4 while exists some cp E RE,  cp Nt &gt; 1 do
5 for cp E RE, R E rel do
6 addL(lR.cp, RE)
7 if made no changes to RE then
8 exit
</figure>
<bodyText confidence="0.999035384615385">
exponential runtime (although we are not aware of
such worst-case examples). We leave a more careful
complexity analysis for future work.
We presented both algorithms as first refining RE
according to propositional symbols, and then by re-
lational expressions of increasing depth. But actu-
ally, propositional symbols can be encoded using
new relational symbols (e.g., we could represent that
f1 is a flower in Fig. 1 as a relation labeled flower
from f1 to an additional dummy element d). In this
way, we don’t need to distinguish between proposi-
tions and relations, and any arbitrary preference or-
dering of properties can be used.
</bodyText>
<subsectionHeader confidence="0.99926">
3.2 Some examples
</subsectionHeader>
<bodyText confidence="0.998607529411764">
Let’s try our algorithms on some examples. We
first run the £G algorithm on the model shown in
Fig. 1a, which is taken from Dale and Haddock
(1991). The algorithm starts with RE = {T}. In
the first loop, it adds the formulas floor, bowl, cup,
and table, and then removes T because it is now
subsumed. Not all of these formulas denote single-
tons; for instance, ||cup ||contains two individuals.
So we iterate over the relations to refine our for-
mulas. After the first iteration over the relations,
we have RE = {floor, bowl n lon.floor, bowl n
lon.table, cup, table}. Notice that bowl has become
subsumed, but we haven’t distinguished the cups
and tables further.
Now we can use the split between the bowls to
distinguish the cups in the second iteration. The re-
sult of this is RE = {floor, bowl n lon.floor, bowl n
</bodyText>
<table confidence="0.772793818181818">
Algorithm 2: addALc(cp, RE)
1 for 0 E RE with  0  &gt; 1 do
2 if ||0 n cp ||=�O and ||0 n -,cp ||=�O then
3 add 0 n cp and 0 n -,cp to RE;
4 remove 0 from RE;
Algorithm 3: addgL(cp, RE)
1 for 0 E RE with  0  &gt; 1 do
2 if 0 n cp is not subsumed in RE and
||0 n cp ||=�O and ||0 n cp ||=� ||0 ||then
3 add 0 n c pto RE
4 remove subsumed formulas from RE
</table>
<bodyText confidence="0.994965857142857">
lon.table, cup n lin.(bowl n lon.floor), cup n
lin.(bowl n lon.table),table}. At this point, all
formulas except table denote singletons, and further
iterations don’t allow us to refine table; so the al-
gorithm terminates. Each formula with a singleton
extension {a} is a unique description of a; for in-
stance, cup n lin.(bowl n lon.table) is only satis-
fied by c2, so we may refer to c2 as “the cup in the
bowl on the table”. Notice that the algorithm didn’t
focus on any particular individual; it simultaneously
generated REs for all individuals except for the two
tables (which are similar to each other).
The £G algorithm has a harder time with the ex-
ample in Fig. 1b (Stone and Webber, 1998). While
it will correctly identify r1 as “the rabbit in the hat”
and f2 as “the flower in the hat”, it will not be able to
compute a RE for f1 because f1 is £G-similar to f2.
Indeed, the algorithm terminates with RE contain-
ing both flower and flowernlin.hat. This is atypical
pattern for asymmetrical cases of similarity in £G: If
there are two formulas cp1 and cp2 in the output set
with ||cp1 ||c ||cp2||, then there is generally some in-
dividual b E ||cp2 ||− ||cp1 ||such that all individuals in
||cp1 ||are similar to b, but not vice versa. By contrast,
the AGC algorithm can exploit the greater expressiv-
ity of AGC to split flower into the two new formulas
flower n lin.hat and flower n -,lin.hat, generating a
unique RE for f1 as well.
</bodyText>
<sectionHeader confidence="0.999693" genericHeader="method">
4 Discussion
</sectionHeader>
<bodyText confidence="0.998667">
We will now describe two experiments evaluating
the quality of the £G algorithm’s output and the effi-
</bodyText>
<page confidence="0.999322">
45
</page>
<figureCaption confidence="0.999844">
Figure 2: A schematic view of the filing cabinets.
</figureCaption>
<bodyText confidence="0.998965">
ciency of both of our algorithms, and we discuss the
interface between our algorithms and realization.
</bodyText>
<subsectionHeader confidence="0.94049">
4.1 Evaluation: Output quality
</subsectionHeader>
<bodyText confidence="0.99989206060606">
To compare the descriptions generated by our al-
gorithm to those humans produce, we use a cor-
pus of human-generated referring expressions col-
lected and made available by Jette Viethen and
Robert Dale.1 They asked human subjects to de-
scribe one of 16 filing cabinet drawers. The draw-
ers had different colors and were arranged in a
four-by-four grid (see Fig. 2). The human subjects
used four non-relational properties (the drawer’s
color, its column and row number, and whether
it is in a corner) and five relational properties
(above, below, next to, left of, right of). Of the 118
referring expressions obtained in the experiment,
only 15 use relations.
Viethen and Dale (2006) describe the data in
more detail and present results of evaluating the Full
Brevity algorithm, the Incremental Algorithm (both
by Dale and Reiter (1995)), and the Relational Al-
gorithm (Dale and Haddock, 1991) on this corpus.
The Incremental Algorithm is dependent on a pre-
defined ordering in which properties are added to
the description. Viethen and Dale, therefore, try all
possible orderings and evaluate what percentage of
descriptions an algorithm can generate with any of
them. The Full Brevity and the Relational Algo-
rithms choose properties based on their discrimina-
tory power and only use the orderings as tie break-
ers. Viethen and Dale found that the Incremental
Algorithm is capable of generating 98 of the 103
non-relational descriptions. However, the Relational
Algorithm was unable to generate even a single one
of the human-generated relational descriptions.
We replicated Viethen and Dale’s experiment for
</bodyText>
<footnote confidence="0.829835">
1http://www.ics.mq.edu.au/˜jviethen/drawers
</footnote>
<bodyText confidence="0.999840086956522">
the £G algorithm presented above. In the non-
relational case, our results are the same as theirs for
the Incremental Algorithm: the £G algorithm gener-
ates 98 of the 103 non-relational descriptions, using
four (of the possible) orderings. This is because the
two algorithms perform essentially the same compu-
tations if there are no relations.
When we add relations, our algorithm is able to
generate 10 of the 15 human-produced relational
descriptions correctly (in addition to the 98 non-
relational descriptions). Fig. 3 gives example out-
puts of the £G algorithm for three different order-
ings, which together achieve this coverage. Of the
five human-produced descriptions that the £G algo-
rithm cannot generate, three involve references to
sets (the two blues ones in horizontal sequence/the
two yellow drawers), and two contain so much re-
dundant information that our algorithm cannot re-
produce them: Similarly to the Incremental Algo-
rithm, our algorithm allows for some redundancy,
but stops once it has found a distinguishing descrip-
tion. It does, however, generate other, simpler de-
scriptions for these referents.
</bodyText>
<subsectionHeader confidence="0.985713">
4.2 Evaluation: Efficiency
</subsectionHeader>
<bodyText confidence="0.999937894736842">
Both the £G and the AGC algorithms took about 15
milliseconds to compute distinguishing formulas for
all 16 individuals in the Viethen and Dale dataset.2
In order to get a more comprehensive picture
of the algorithms’ efficiency, we ran them on ran-
dom models with increasing numbers of individu-
als. Each model had random interpretations for ten
different propositional and four relational symbols;
each individual had a 10% chance to be in the exten-
sion of each propositional symbol, and each pair of
individuals had a 10% chance to be related by a re-
lational symbol. The results (averaged over 10 runs
for each model size) are shown in Fig. 4. The £G al-
gorithm takes about 350 ms on average to generate
relational REs for all individuals in the model of size
100, i.e., less than 4 ms on average for each individ-
ual. The AGC algorithm is even faster, at about 140
ms for the model of size 100. As far as we know,
these are by far the fastest published runtimes for
</bodyText>
<footnote confidence="0.9949545">
2Runtimes were measured on a MacBook Pro (Intel Core 2
Duo, 2.16 GHz) running Java 1.6 beta. We allowed the Java
VM to warm up, i.e., just-in-time compile all bytecode, before
taking the measurements.
</footnote>
<page confidence="0.999528">
46
</page>
<bodyText confidence="0.99801945">
id human-produced description
output of the EG algorithm
2 the orange drawer above the blue drawer
orange u ∃above.blue /orange n 3above.(3below.(orange) n blue) /orange n 3next.(blue) n 3next.(pink)
4 the yellow drawer on the top of the pink one
yellow u ∃above.pink / yellow n corner n 3above.pink / yellow n corner n 3above.(3next.(yellow) n pink)
5 * the pink drawer in the fourth column below the yellow one
pink n 3above.orange / pink n 3below.yellow / pink n 3next.(yellow) n 3above.(3next.(yellow) n orange)
6 the yellow drawer on top of the yellow drawer (2x) / * the drawer after the two blue ones in horizontal sequence
yellow u ∃above.yellow /yellow n 3below.pink/ yellow n 3next.(blue) n 3next.(pink)
7 the blue drawer below the orange one / * the blue drawer below the orange drawer in the second column
bluen3above.(blue)n3next.(3above.(orange)nblue) / blueu∃below.(orange) / bluen3next.(blue)n3next.(yellow)
10 the blue drawer above the pink drawer (2x)
blue u ∃above.(pink) / blue n 3above.(pink) n 3below.(blue) / blue n 3next.(orange) n 3next.(yellow)
11 the yellow drawer next to the orange drawer (2x)
yellow n 3above.orange / yellow n 3below.yellow / yellow u ∃next.orange
12 the orange drawer below the pink drawer
orange n 3above.(pink n corner) / orange u ∃below.pink / orange n 3next.yellow
14 * the orange drawer below the two yellow drawers (2x)
orange n 3next.(pink n corner) n 3next.(pink) / orange n 3below.yellow / orange n 3next.(pink n corner)
</bodyText>
<figureCaption confidence="0.99810575">
Figure 3: The relational descriptions from Viethen and Dale (2006), annotated with the drawer id and the outputs of the
£G algorithm using three different orderings. Notice that four descriptions occurred twice in the corpus. Descriptions
that the £G algorithm cannot generate with any ordering are marked by *. Generated descriptions that match one
produced by humans are in boldface.
</figureCaption>
<bodyText confidence="0.501398">
any relational GRE algorithm in the literature.
</bodyText>
<subsectionHeader confidence="0.99419">
4.3 Interface to realization
</subsectionHeader>
<bodyText confidence="0.999961782608696">
Our GRE algorithms do not guarantee that the for-
mula they compute can actually be realized in lan-
guage. For example, none of the formulas our al-
gorithms computed in the Viethen and Dale domain
contained an atom that would commonly be realized
as a noun; the property drawer is never used be-
cause it applies to all individuals in the domain. This
particular problem could easily be worked around
in a post-processing step. However, another prob-
lem arises from the massive use of negation in the
AGC algorithm; it will be hard for any realizer to
find a reasonable way of expressing a formula like
-,]R.(-,Pn-,Q) as a smooth noun phrase. Although
we agree with van Deemter (2002) and others that
the careful use of negation and disjunction can im-
prove REs, these connectives must not be overused.
Thus we consider the formulas computed by the £G
algorithm “safer” with respect to realization.
Of course, we share the problem of interfacing
GRE and realization with every other approach that
separates these two modules, i.e., almost the en-
tire GRE literature (notable exceptions are, e.g., Ho-
racek (1997) and SPUD (Stone and Webber, 1998)).
</bodyText>
<figure confidence="0.972994">
300
200
100
0
10 20 30 40 50 60 70 80 90 100
</figure>
<figureCaption confidence="0.974527">
Figure 4: Average runtimes (in ms) of the two algorithms
on random models with different numbers of individuals.
</figureCaption>
<bodyText confidence="0.999138818181818">
In principle, we believe that it is a good idea to
handle sentence planning and realization in a single
module; for instance, SPUD can use its awareness
of the syntactic context to generate succinct REs as
in “take the rabbit from the hat”. We hope that the
ideas we have explored here for efficient and ex-
pressive RE generation can eventually be combined
with recent efficient algorithms for integrated sen-
tence planning and realization, such as in Koller and
Stone (2007).
One problem that arises in our approach is that
</bodyText>
<figure confidence="0.675085">
400
EL ALC
</figure>
<page confidence="0.997766">
47
</page>
<bodyText confidence="0.9999745">
both algorithms derive some measure of efficiency
from their freedom to build formulas without hav-
ing to respect any linguistic constraints. It seems
straightforward, for instance, to extend Krahmer et
al.’s (2003) approach such that it only considers sub-
graphs that can actually be realized, because their al-
gorithm proceeds by a genuine search for uniquely
identifying subgraphs, and will simply take a differ-
ent branch of the search if some subgraph is useless.
This would be harder in our case. Our algorithms
don’t search in the same way; if we disallow certain
refinements of a partition, we have to allow the al-
gorithms to backtrack and thus jeopardize the worst-
case polynomial runtime. Investigating this inter-
play between efficiency and linguistic constraints is
an interesting avenue for future research.
</bodyText>
<sectionHeader confidence="0.993021" genericHeader="method">
5 A unified perspective on GRE
</sectionHeader>
<bodyText confidence="0.999978379310345">
Viewing GRE as a problem of generating DL for-
mulas offers a unified perspective: It is the prob-
lem of computing a DL formula with a given exten-
sion. Many existing approaches can be subsumed
under this view; we have summarized this for some
of them in Fig. 5, along with the DL fragment they
use. We already discussed some of these approaches
in Section 3. Furthermore, the non-relational but
negative and disjunctive descriptions generated by
van Deemter (2002) are simply formulas of PL;
and Gardent (2002) generalizes this into generating
formulas of ELU(¬), i.e., EL plus disjunction and
atomic negation. The approach presented here fits
well into this landscape, and it completes the pic-
ture by showing how to generate REs in ALC, which
combines all connectives used in any of these previ-
ous approaches.
Where our approach breaks new ground is in the
way these formulas are computed: It successively
refines a decomposition of the domain into subsets.
In this way, it is reminiscent of the Incremental Al-
gorithm, which in fact can be seen as a special case
of the EL algorithm. However, unlike Dale and
Haddock (1991) and its successors, such as Kelle-
her and Kruijff (2006), we do not have to take spe-
cial precautions to avoid infinite regress. While Dale
and Haddock’s algorithm attempts to generate a RE
for a single individual, for successive individuals in
the model, our algorithms consider all individuals in
</bodyText>
<table confidence="0.625379166666667">
GRE algorithm DL variant
Dale and Reiter (1995)
van Deemter (2002)
Dale and Haddock (1991)
Kelleher and Kruijff (2006)
Gardent (2002)
</table>
<figureCaption confidence="0.988225">
Figure 5: DL variants used by different GRE algorithms.
</figureCaption>
<bodyText confidence="0.999438176470588">
parallel. It monotonically refines a partition of the
model and never needs to backtrack, and therefore
is always guaranteed to terminate.
Perhaps closest in spirit to our approach is Krah-
mer et al.’s graph algorithm (2003), which also com-
putes REs by extending them successively. How-
ever, their subgraphs go beyond the expressive
power of ALC in that they can distinguish between
“the dog that bites a dog” and “the dog that bites it-
self”. The price they pay for this increase in expres-
sive power is an NP-complete worst-case complex-
ity. Interestingly, Krahmer et al. themselves discuss
the possibility of seeing their subgraphs as formu-
las of hybrid logic which are satisfied at the points
where the subgraph can be embedded; and hybrid
logics can be seen as very expressive description
logics (Areces and ten Cate, 2006).
</bodyText>
<sectionHeader confidence="0.999541" genericHeader="conclusions">
6 Conclusion
</sectionHeader>
<bodyText confidence="0.99949755">
In this paper, we have explored the idea of view-
ing the generation of singular REs as the problem
of computing a DL formula with a given extension.
We have shown how such formulas can be computed
efficiently (for ALC and EL) by adapting existing
algorithms from the literature. The EL algorithm
is able to generate 95% of the non-relational and
67% of the relational REs from Viethen and Dale
(2006). Both algorithms are extremely efficient (350
ms and 140 ms respectively to generate relational
REs for all individuals in a random model with 100
individuals); to our knowledge, these are by far the
fastest runtimes for relational GRE reported in the
literature. We have made our implementation avail-
able online at http://code.google.com/p/
crisp-nlg/wiki/DlGre.
Because they compute referring expressions for
all individuals in the domain at once, our algorithms
will perform especially strongly in static settings,
such as the generation of descriptions for museum
</bodyText>
<figure confidence="0.8305688">
CL
PL
EL
EL
ELU(¬)
</figure>
<page confidence="0.998238">
48
</page>
<bodyText confidence="0.99969275">
exhibits, in which the individuals and their proper-
ties don’t change much. However, even in more dy-
namic settings, our algorithms have a chance to out-
perform search algorithms like Dale and Haddock’s
in the average case because they can’t get stuck in
unproductive branches of the search space. Never-
theless, one interesting question for future research
is how to incrementally update simulation classes
when the model changes. Similarly, it would be
interesting to explore how different linguistic con-
straints and attribute orderings can be taken into ac-
count efficiently, how our algorithms could be in-
tegrated with more standard DL T-Box inferences,
and how they can be adapted to use inverse relations
or to compute REs for sets. In exploring these ex-
tensions we will be able to draw on a rich body of
literature that has already considered many variants
of simulation algorithms addressing similar issues.
In experimenting with the Viethen and Dale data,
we found that there is no single ordering that covers
all human-produced descriptions, which seems to be
in contrast to Dale and Reiter’s (1995) assumption
that there is only one ordering for each given do-
main. In fact, it is not even the case that each speaker
consistently uses just one ordering. An interesting
open research question is thus what factors deter-
mine which ordering is used. Unfortunately, both
in the Viethen and Dale dataset and in the TUNA
corpus (van Deemter et al., 2006), only a minor-
ity of referring expressions is relational, maybe be-
cause these domains lend themselves very well to
row/column style propositional REs. We are cur-
rently collecting REs in a domain in which propo-
sitional REs are less preferred.
Acknowledgments. We are grateful to Hector
Geffner (who independently suggested to view GRE as
computation of DL formulas), Kees van Deemter, and
Emiel Krahmer for interesting discussions. We also
thank Jette Viethen and Robert Dale for making their
corpus available, and the reviewers for their comments.
</bodyText>
<sectionHeader confidence="0.999611" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999855593220339">
C. Areces and B. ten Cate. 2006. Hybrid logics. In
P. Blackburn, F. Wolter, and J. van Benthem, editors,
Handbook of Modal Logics. Elsevier.
F. Baader, D. McGuiness, D. Nardi, and P. Patel-
Schneider, editors. 2003. The Description Logic
Handbook: Theory, implementation and applications.
Cambridge University Press.
P. Blackburn, M. de Rijke, and Y. Venema. 2001. Modal
Logic. Cambridge University Press.
R. Dale and N. Haddock. 1991. Generating referring
expressions involving relations. In Proc. of the 5th
EACL.
R. Dale and E. Reiter. 1995. Computational interpreta-
tions of the Gricean maxims in the generation of refer-
ring expressions. Cognitive Science, 19.
R. Dale. 1989. Cooking up referring expressions. In
Proc. of the 27th ACL.
A. Dovier, C. Piazza, and A. Policriti. 2004. An ef-
ficient algorithm for computing bisimulation equiva-
lence. Theoretical Computer Science, 311(1–3).
C. Gardent and K. Striegnitz. 2007. Generating bridg-
ing definite descriptions. In H. Bunt and R. Muskens,
editors, Computing Meaning, Vol. 3. Springer.
C. Gardent. 2002. Generating minimal definite descrip-
tions. In Proc. of the 40th ACL.
J. Hopcroft. 1971. An n log(n) algorithm for minimizing
states in a finite automaton. In Z. Kohave, editor, The-
ory of Machines and computations. Academic Press.
H. Horacek. 1997. An algorithm for generating refer-
ential descriptions with flexible interfaces. In Proc. of
the 35th ACL.
J. Kelleher and G.-J. Kruijff. 2006. Incremental genera-
tion of spatial referring expressions in situated dialog.
In Proc. of COLING/ACL.
A. Koller and M. Stone. 2007. Sentence generation as
planning. In Proc. of the 45th ACL.
E. Krahmer, S. van Erk, and A. Verleg. 2003. Graph-
based generation of referring expressions. Computa-
tional Linguistics, 29(1).
N. Kurtonina and M. de Rijke. 1998. Expressiveness
of concept expressions in first-order description logics.
Artificial Intelligence, 107.
R. Paige and R. Tarjan. 1987. Three partition refinement
algorithms. SIAM Journal on Computing, 16(6).
M. Stone and B. Webber. 1998. Textual economy
through close coupling of syntax and semantics. In
Proc. of the 9th INLG workshop.
M. Stone. 2000. On identifying sets. In Proc. of the 1st
INLG.
K. van Deemter, I. van der Sluis, and A. Gatt. 2006.
Building a semantically transparent corpus for the gen-
eration of referring expressions. In Proc. of the 4th
INLG.
K. van Deemter. 2002. Generating referring expres-
sions: Boolean extensions of the incremental algo-
rithm. Computational Linguistics, 28(1):37–52.
J. Viethen and R. Dale. 2006. Algorithms for generating
referring expressions: Do they do what people do? In
Proc. of the 4th INLG.
</reference>
<page confidence="0.999544">
49
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.177233">
<title confidence="0.999585">Referring Expressions as Formulas of Description Logic</title>
<author confidence="0.888217">Carlos</author>
<affiliation confidence="0.964251">INRIA Nancy Grand</affiliation>
<address confidence="0.824592">Nancy,</address>
<email confidence="0.993093">areces@loria.fr</email>
<author confidence="0.952093">Alexander</author>
<affiliation confidence="0.867147">University of Edinburgh,</affiliation>
<email confidence="0.995453">a.koller@ed.ac.uk</email>
<author confidence="0.590446">Kristina</author>
<affiliation confidence="0.793967">Union Schenectady, NY,</affiliation>
<email confidence="0.99969">striegnk@union.edu</email>
<abstract confidence="0.997969538461538">In this paper, we propose to reinterpret the problem of generating referring expressions (GRE) as the problem of computing a formula in a description logic that is only satisfied by the referent. This view offers a new unifying perspective under which existing GRE algorithms can be compared. We also show that by applying existing algorithms for computing simulation classes in description logic, we can obtain extremely efficient algorithms for relational referring expressions without any danger of running into infinite regress.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>C Areces</author>
<author>B ten Cate</author>
</authors>
<title>Hybrid logics.</title>
<date>2006</date>
<booktitle>Handbook of Modal Logics.</booktitle>
<editor>In P. Blackburn, F. Wolter, and J. van Benthem, editors,</editor>
<publisher>Elsevier.</publisher>
<marker>Areces, Cate, 2006</marker>
<rawString>C. Areces and B. ten Cate. 2006. Hybrid logics. In P. Blackburn, F. Wolter, and J. van Benthem, editors, Handbook of Modal Logics. Elsevier.</rawString>
</citation>
<citation valid="true">
<title>The Description Logic Handbook: Theory, implementation and applications.</title>
<date>2003</date>
<editor>F. Baader, D. McGuiness, D. Nardi, and P. PatelSchneider, editors.</editor>
<publisher>Cambridge University Press.</publisher>
<contexts>
<context position="24016" citStr="(2003)" startWordPosition="4192" endWordPosition="4192">areness of the syntactic context to generate succinct REs as in “take the rabbit from the hat”. We hope that the ideas we have explored here for efficient and expressive RE generation can eventually be combined with recent efficient algorithms for integrated sentence planning and realization, such as in Koller and Stone (2007). One problem that arises in our approach is that 400 EL ALC 47 both algorithms derive some measure of efficiency from their freedom to build formulas without having to respect any linguistic constraints. It seems straightforward, for instance, to extend Krahmer et al.’s (2003) approach such that it only considers subgraphs that can actually be realized, because their algorithm proceeds by a genuine search for uniquely identifying subgraphs, and will simply take a different branch of the search if some subgraph is useless. This would be harder in our case. Our algorithms don’t search in the same way; if we disallow certain refinements of a partition, we have to allow the algorithms to backtrack and thus jeopardize the worstcase polynomial runtime. Investigating this interplay between efficiency and linguistic constraints is an interesting avenue for future research.</context>
<context position="26480" citStr="(2003)" startWordPosition="4602" endWordPosition="4602">void infinite regress. While Dale and Haddock’s algorithm attempts to generate a RE for a single individual, for successive individuals in the model, our algorithms consider all individuals in GRE algorithm DL variant Dale and Reiter (1995) van Deemter (2002) Dale and Haddock (1991) Kelleher and Kruijff (2006) Gardent (2002) Figure 5: DL variants used by different GRE algorithms. parallel. It monotonically refines a partition of the model and never needs to backtrack, and therefore is always guaranteed to terminate. Perhaps closest in spirit to our approach is Krahmer et al.’s graph algorithm (2003), which also computes REs by extending them successively. However, their subgraphs go beyond the expressive power of ALC in that they can distinguish between “the dog that bites a dog” and “the dog that bites itself”. The price they pay for this increase in expressive power is an NP-complete worst-case complexity. Interestingly, Krahmer et al. themselves discuss the possibility of seeing their subgraphs as formulas of hybrid logic which are satisfied at the points where the subgraph can be embedded; and hybrid logics can be seen as very expressive description logics (Areces and ten Cate, 2006)</context>
</contexts>
<marker>2003</marker>
<rawString>F. Baader, D. McGuiness, D. Nardi, and P. PatelSchneider, editors. 2003. The Description Logic Handbook: Theory, implementation and applications. Cambridge University Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>P Blackburn</author>
<author>M de Rijke</author>
<author>Y Venema</author>
</authors>
<title>Modal Logic.</title>
<date>2001</date>
<publisher>Cambridge University Press.</publisher>
<marker>Blackburn, de Rijke, Venema, 2001</marker>
<rawString>P. Blackburn, M. de Rijke, and Y. Venema. 2001. Modal Logic. Cambridge University Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Dale</author>
<author>N Haddock</author>
</authors>
<title>Generating referring expressions involving relations.</title>
<date>1991</date>
<booktitle>In Proc. of the 5th EACL.</booktitle>
<contexts>
<context position="1223" citStr="Dale and Haddock, 1991" startWordPosition="174" endWordPosition="177">xisting algorithms for computing simulation classes in description logic, we can obtain extremely efficient algorithms for relational referring expressions without any danger of running into infinite regress. 1 Introduction The generation of referring expressions (GRE) is one of the most active and successful research areas in natural language generation. Building upon Dale and Reiter’s work (Dale, 1989; Dale and Reiter, 1995), various researchers have added extensions such as reference to sets (Stone, 2000), more expressive logical connectives (van Deemter, 2002), and relational expressions (Dale and Haddock, 1991). Referring expressions (REs) involving relations, in particular, have received increasing attention recently; especially in the context of spatial referring expressions in situated generation (e.g. (Kelleher and Kruijff, 2006)), where it seems particularly natural to use expressions such as “the book on the table”. However, the classical algorithm by Dale and Haddock (1991) was recently shown to be unable to generate satisfying REs in practice (Viethen and Dale, 2006). Furthermore, the Dale and Haddock algorithm and most of its successors (such as (Kelleher and Kruijff, 2006)) are vulnerable </context>
<context position="2761" citStr="Dale and Haddock (1991)" startWordPosition="423" endWordPosition="426">gic (DL) that denotes exactly the set of individuals that we want to refer to. This very natural idea has been mentioned in passing before (Krahmer et al., 2003; Gardent and Striegnitz, 2007); however, we take it one step further by proposing DL as an interlingua for comparing the REs produced by different approaches to GRE. In this way, we can organize existing GRE approaches in an expressiveness hierarchy. For instance, the classical Dale and Reiter algorithms compute purely conjunctive formulas; van Deemter (2002) extends this language by adding the other propositional connectives, whereas Dale and Haddock (1991) extends it by allowing existential quantification. Furthermore, the view of GRE as a problem of computing DL formulas with a given extension allows us to apply existing algorithms for the latter problem to obtain efficient algorithms for GRE. We present algorithms that compute such formulas for the description logics £G (which allows only conjunction and existential quantification) and AGC (which also allows negation). These algorithms effectively compute REs for all individuals in the domain at the same time, which allows them to systematically avoid the infinite regress problem. The £G algo</context>
<context position="7393" citStr="Dale and Haddock (1991)" startWordPosition="1256" endWordPosition="1259">computing a formula of some description logic G whose extension is a given target set A of individuals. G-GRE PROBLEM Input: A model M and a target set A C A. Output: A formula co E G such that ||co ||= A (if such a formula exists). In the examples above, it is because flower n lin.hat denotes exactly {f2} that we can say “the flower in the hat” to refer to f2. This perspective provides a general framework into which many existing GRE approaches fit: Traditional attribute selection (Dale and Reiter, 1995) corresponds to building DL formulas that are conjunctions of atoms; relational REs as in Dale and Haddock (1991) are formulas of £G; and so on. We will further pursue the idea of organizing GRE approaches with respect to the variant of DL they use in Section 5. For the rest of this paper, we assume that we are generating a singular RE, i.e., the target set A will be a singleton. In this case, we will only be able to generate a formula that denotes exactly A = {a} (i.e., a RE that uniquely refers to a) if there is no 43 Figure 1: (a) The Dale and Haddock (1991) scenario; (b) the Stone and Webber (1998) scenario. other individual b to which a is similar; otherwise, any formula that is satisfied by a is al</context>
<context position="13322" citStr="Dale and Haddock (1991)" startWordPosition="2361" endWordPosition="2364">st refining RE according to propositional symbols, and then by relational expressions of increasing depth. But actually, propositional symbols can be encoded using new relational symbols (e.g., we could represent that f1 is a flower in Fig. 1 as a relation labeled flower from f1 to an additional dummy element d). In this way, we don’t need to distinguish between propositions and relations, and any arbitrary preference ordering of properties can be used. 3.2 Some examples Let’s try our algorithms on some examples. We first run the £G algorithm on the model shown in Fig. 1a, which is taken from Dale and Haddock (1991). The algorithm starts with RE = {T}. In the first loop, it adds the formulas floor, bowl, cup, and table, and then removes T because it is now subsumed. Not all of these formulas denote singletons; for instance, ||cup ||contains two individuals. So we iterate over the relations to refine our formulas. After the first iteration over the relations, we have RE = {floor, bowl n lon.floor, bowl n lon.table, cup, table}. Notice that bowl has become subsumed, but we haven’t distinguished the cups and tables further. Now we can use the split between the bowls to distinguish the cups in the second ite</context>
<context position="16958" citStr="Dale and Haddock, 1991" startWordPosition="3027" endWordPosition="3030"> drawers. The drawers had different colors and were arranged in a four-by-four grid (see Fig. 2). The human subjects used four non-relational properties (the drawer’s color, its column and row number, and whether it is in a corner) and five relational properties (above, below, next to, left of, right of). Of the 118 referring expressions obtained in the experiment, only 15 use relations. Viethen and Dale (2006) describe the data in more detail and present results of evaluating the Full Brevity algorithm, the Incremental Algorithm (both by Dale and Reiter (1995)), and the Relational Algorithm (Dale and Haddock, 1991) on this corpus. The Incremental Algorithm is dependent on a predefined ordering in which properties are added to the description. Viethen and Dale, therefore, try all possible orderings and evaluate what percentage of descriptions an algorithm can generate with any of them. The Full Brevity and the Relational Algorithms choose properties based on their discriminatory power and only use the orderings as tie breakers. Viethen and Dale found that the Incremental Algorithm is capable of generating 98 of the 103 non-relational descriptions. However, the Relational Algorithm was unable to generate </context>
<context position="25769" citStr="Dale and Haddock (1991)" startWordPosition="4484" endWordPosition="4487">nt (2002) generalizes this into generating formulas of ELU(¬), i.e., EL plus disjunction and atomic negation. The approach presented here fits well into this landscape, and it completes the picture by showing how to generate REs in ALC, which combines all connectives used in any of these previous approaches. Where our approach breaks new ground is in the way these formulas are computed: It successively refines a decomposition of the domain into subsets. In this way, it is reminiscent of the Incremental Algorithm, which in fact can be seen as a special case of the EL algorithm. However, unlike Dale and Haddock (1991) and its successors, such as Kelleher and Kruijff (2006), we do not have to take special precautions to avoid infinite regress. While Dale and Haddock’s algorithm attempts to generate a RE for a single individual, for successive individuals in the model, our algorithms consider all individuals in GRE algorithm DL variant Dale and Reiter (1995) van Deemter (2002) Dale and Haddock (1991) Kelleher and Kruijff (2006) Gardent (2002) Figure 5: DL variants used by different GRE algorithms. parallel. It monotonically refines a partition of the model and never needs to backtrack, and therefore is alway</context>
</contexts>
<marker>Dale, Haddock, 1991</marker>
<rawString>R. Dale and N. Haddock. 1991. Generating referring expressions involving relations. In Proc. of the 5th EACL.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Dale</author>
<author>E Reiter</author>
</authors>
<title>Computational interpretations of the Gricean maxims in the generation of referring expressions.</title>
<date>1995</date>
<journal>Cognitive Science,</journal>
<volume>19</volume>
<contexts>
<context position="1030" citStr="Dale and Reiter, 1995" startWordPosition="147" endWordPosition="150"> in a description logic that is only satisfied by the referent. This view offers a new unifying perspective under which existing GRE algorithms can be compared. We also show that by applying existing algorithms for computing simulation classes in description logic, we can obtain extremely efficient algorithms for relational referring expressions without any danger of running into infinite regress. 1 Introduction The generation of referring expressions (GRE) is one of the most active and successful research areas in natural language generation. Building upon Dale and Reiter’s work (Dale, 1989; Dale and Reiter, 1995), various researchers have added extensions such as reference to sets (Stone, 2000), more expressive logical connectives (van Deemter, 2002), and relational expressions (Dale and Haddock, 1991). Referring expressions (REs) involving relations, in particular, have received increasing attention recently; especially in the context of spatial referring expressions in situated generation (e.g. (Kelleher and Kruijff, 2006)), where it seems particularly natural to use expressions such as “the book on the table”. However, the classical algorithm by Dale and Haddock (1991) was recently shown to be unab</context>
<context position="7280" citStr="Dale and Reiter, 1995" startWordPosition="1238" endWordPosition="1241">to GRE. The core claim of this paper is that it is natural and useful to view the GRE problem as the problem of computing a formula of some description logic G whose extension is a given target set A of individuals. G-GRE PROBLEM Input: A model M and a target set A C A. Output: A formula co E G such that ||co ||= A (if such a formula exists). In the examples above, it is because flower n lin.hat denotes exactly {f2} that we can say “the flower in the hat” to refer to f2. This perspective provides a general framework into which many existing GRE approaches fit: Traditional attribute selection (Dale and Reiter, 1995) corresponds to building DL formulas that are conjunctions of atoms; relational REs as in Dale and Haddock (1991) are formulas of £G; and so on. We will further pursue the idea of organizing GRE approaches with respect to the variant of DL they use in Section 5. For the rest of this paper, we assume that we are generating a singular RE, i.e., the target set A will be a singleton. In this case, we will only be able to generate a formula that denotes exactly A = {a} (i.e., a RE that uniquely refers to a) if there is no 43 Figure 1: (a) The Dale and Haddock (1991) scenario; (b) the Stone and Webb</context>
<context position="16902" citStr="Dale and Reiter (1995)" startWordPosition="3018" endWordPosition="3021">ked human subjects to describe one of 16 filing cabinet drawers. The drawers had different colors and were arranged in a four-by-four grid (see Fig. 2). The human subjects used four non-relational properties (the drawer’s color, its column and row number, and whether it is in a corner) and five relational properties (above, below, next to, left of, right of). Of the 118 referring expressions obtained in the experiment, only 15 use relations. Viethen and Dale (2006) describe the data in more detail and present results of evaluating the Full Brevity algorithm, the Incremental Algorithm (both by Dale and Reiter (1995)), and the Relational Algorithm (Dale and Haddock, 1991) on this corpus. The Incremental Algorithm is dependent on a predefined ordering in which properties are added to the description. Viethen and Dale, therefore, try all possible orderings and evaluate what percentage of descriptions an algorithm can generate with any of them. The Full Brevity and the Relational Algorithms choose properties based on their discriminatory power and only use the orderings as tie breakers. Viethen and Dale found that the Incremental Algorithm is capable of generating 98 of the 103 non-relational descriptions. H</context>
<context position="26114" citStr="Dale and Reiter (1995)" startWordPosition="4541" endWordPosition="4544"> is in the way these formulas are computed: It successively refines a decomposition of the domain into subsets. In this way, it is reminiscent of the Incremental Algorithm, which in fact can be seen as a special case of the EL algorithm. However, unlike Dale and Haddock (1991) and its successors, such as Kelleher and Kruijff (2006), we do not have to take special precautions to avoid infinite regress. While Dale and Haddock’s algorithm attempts to generate a RE for a single individual, for successive individuals in the model, our algorithms consider all individuals in GRE algorithm DL variant Dale and Reiter (1995) van Deemter (2002) Dale and Haddock (1991) Kelleher and Kruijff (2006) Gardent (2002) Figure 5: DL variants used by different GRE algorithms. parallel. It monotonically refines a partition of the model and never needs to backtrack, and therefore is always guaranteed to terminate. Perhaps closest in spirit to our approach is Krahmer et al.’s graph algorithm (2003), which also computes REs by extending them successively. However, their subgraphs go beyond the expressive power of ALC in that they can distinguish between “the dog that bites a dog” and “the dog that bites itself”. The price they p</context>
</contexts>
<marker>Dale, Reiter, 1995</marker>
<rawString>R. Dale and E. Reiter. 1995. Computational interpretations of the Gricean maxims in the generation of referring expressions. Cognitive Science, 19.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Dale</author>
</authors>
<title>Cooking up referring expressions.</title>
<date>1989</date>
<booktitle>In Proc. of the 27th ACL.</booktitle>
<contexts>
<context position="1006" citStr="Dale, 1989" startWordPosition="145" endWordPosition="146">ng a formula in a description logic that is only satisfied by the referent. This view offers a new unifying perspective under which existing GRE algorithms can be compared. We also show that by applying existing algorithms for computing simulation classes in description logic, we can obtain extremely efficient algorithms for relational referring expressions without any danger of running into infinite regress. 1 Introduction The generation of referring expressions (GRE) is one of the most active and successful research areas in natural language generation. Building upon Dale and Reiter’s work (Dale, 1989; Dale and Reiter, 1995), various researchers have added extensions such as reference to sets (Stone, 2000), more expressive logical connectives (van Deemter, 2002), and relational expressions (Dale and Haddock, 1991). Referring expressions (REs) involving relations, in particular, have received increasing attention recently; especially in the context of spatial referring expressions in situated generation (e.g. (Kelleher and Kruijff, 2006)), where it seems particularly natural to use expressions such as “the book on the table”. However, the classical algorithm by Dale and Haddock (1991) was r</context>
</contexts>
<marker>Dale, 1989</marker>
<rawString>R. Dale. 1989. Cooking up referring expressions. In Proc. of the 27th ACL.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Dovier</author>
<author>C Piazza</author>
<author>A Policriti</author>
</authors>
<title>An efficient algorithm for computing bisimulation equivalence.</title>
<date>2004</date>
<journal>Theoretical Computer Science,</journal>
<pages>311--1</pages>
<contexts>
<context position="9391" citStr="Dovier et al., 2004" startWordPosition="1617" endWordPosition="1620">her adapt this algorithm for £G. In effect, both algorithms compute REs for all individuals in some model at the same time – very efficiently and without any danger of infinite regress. 3.1 Computing similarity sets It can be shown that for AGC, the similarity sets of a finite model coincide exactly with the simulation classes of this model. Simulation classes have been studied extensively in the literature (see e.g., Blackburn et al. (2001); Kurtonina and de Rijke (1998)), and there are several efficient algorithms for computing AGC-simulation classes (Hopcroft, 1971; Paige and Tarjan, 1987; Dovier et al., 2004). However, these algorithms will only compute the simulation classes themselves. Here we extend the Hopcroft (1971) algorithm such that it computes, along with each set, also a formula that denotes exactly this set. We can then use these formulas as representations of the referring expressions. The pseudocode for our AGC algorithm is shown as Algorithm 1 (with G = AGC) and Algorithm 2. Given a model M = (A, ||· ||), the algorithm computes a set RE of AGC formulas such that {||co co E RE} is the set of AGC-similarity sets of M. The algorithm starts with RE = {T} (where ||T ||= A), and successiv</context>
</contexts>
<marker>Dovier, Piazza, Policriti, 2004</marker>
<rawString>A. Dovier, C. Piazza, and A. Policriti. 2004. An efficient algorithm for computing bisimulation equivalence. Theoretical Computer Science, 311(1–3).</rawString>
</citation>
<citation valid="true">
<authors>
<author>C Gardent</author>
<author>K Striegnitz</author>
</authors>
<title>Generating bridging definite descriptions.</title>
<date>2007</date>
<journal>Computing Meaning,</journal>
<volume>3</volume>
<editor>In H. Bunt and R. Muskens, editors,</editor>
<publisher>Springer.</publisher>
<contexts>
<context position="2329" citStr="Gardent and Striegnitz, 2007" startWordPosition="354" endWordPosition="357">rthermore, the Dale and Haddock algorithm and most of its successors (such as (Kelleher and Kruijff, 2006)) are vulnerable to the problem of “infinite regress”, where the algorithm jumps back and forth between generating descriptions for two related individuals infinitely, as in “the book on the table which supports a book on the table ... ”. In this paper, we propose to view GRE as the problem of computing a formula of description logic (DL) that denotes exactly the set of individuals that we want to refer to. This very natural idea has been mentioned in passing before (Krahmer et al., 2003; Gardent and Striegnitz, 2007); however, we take it one step further by proposing DL as an interlingua for comparing the REs produced by different approaches to GRE. In this way, we can organize existing GRE approaches in an expressiveness hierarchy. For instance, the classical Dale and Reiter algorithms compute purely conjunctive formulas; van Deemter (2002) extends this language by adding the other propositional connectives, whereas Dale and Haddock (1991) extends it by allowing existential quantification. Furthermore, the view of GRE as a problem of computing DL formulas with a given extension allows us to apply existin</context>
</contexts>
<marker>Gardent, Striegnitz, 2007</marker>
<rawString>C. Gardent and K. Striegnitz. 2007. Generating bridging definite descriptions. In H. Bunt and R. Muskens, editors, Computing Meaning, Vol. 3. Springer.</rawString>
</citation>
<citation valid="true">
<authors>
<author>C Gardent</author>
</authors>
<title>Generating minimal definite descriptions.</title>
<date>2002</date>
<booktitle>In Proc. of the 40th ACL.</booktitle>
<contexts>
<context position="25155" citStr="Gardent (2002)" startWordPosition="4382" endWordPosition="4383">cy and linguistic constraints is an interesting avenue for future research. 5 A unified perspective on GRE Viewing GRE as a problem of generating DL formulas offers a unified perspective: It is the problem of computing a DL formula with a given extension. Many existing approaches can be subsumed under this view; we have summarized this for some of them in Fig. 5, along with the DL fragment they use. We already discussed some of these approaches in Section 3. Furthermore, the non-relational but negative and disjunctive descriptions generated by van Deemter (2002) are simply formulas of PL; and Gardent (2002) generalizes this into generating formulas of ELU(¬), i.e., EL plus disjunction and atomic negation. The approach presented here fits well into this landscape, and it completes the picture by showing how to generate REs in ALC, which combines all connectives used in any of these previous approaches. Where our approach breaks new ground is in the way these formulas are computed: It successively refines a decomposition of the domain into subsets. In this way, it is reminiscent of the Incremental Algorithm, which in fact can be seen as a special case of the EL algorithm. However, unlike Dale and </context>
</contexts>
<marker>Gardent, 2002</marker>
<rawString>C. Gardent. 2002. Generating minimal definite descriptions. In Proc. of the 40th ACL.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Hopcroft</author>
</authors>
<title>An n log(n) algorithm for minimizing states in a finite automaton.</title>
<date>1971</date>
<booktitle>Theory of Machines and computations.</booktitle>
<editor>In Z. Kohave, editor,</editor>
<publisher>Academic Press.</publisher>
<contexts>
<context position="9345" citStr="Hopcroft, 1971" startWordPosition="1611" endWordPosition="1612">ng simulation classes; we will then further adapt this algorithm for £G. In effect, both algorithms compute REs for all individuals in some model at the same time – very efficiently and without any danger of infinite regress. 3.1 Computing similarity sets It can be shown that for AGC, the similarity sets of a finite model coincide exactly with the simulation classes of this model. Simulation classes have been studied extensively in the literature (see e.g., Blackburn et al. (2001); Kurtonina and de Rijke (1998)), and there are several efficient algorithms for computing AGC-simulation classes (Hopcroft, 1971; Paige and Tarjan, 1987; Dovier et al., 2004). However, these algorithms will only compute the simulation classes themselves. Here we extend the Hopcroft (1971) algorithm such that it computes, along with each set, also a formula that denotes exactly this set. We can then use these formulas as representations of the referring expressions. The pseudocode for our AGC algorithm is shown as Algorithm 1 (with G = AGC) and Algorithm 2. Given a model M = (A, ||· ||), the algorithm computes a set RE of AGC formulas such that {||co co E RE} is the set of AGC-similarity sets of M. The algorithm starts </context>
</contexts>
<marker>Hopcroft, 1971</marker>
<rawString>J. Hopcroft. 1971. An n log(n) algorithm for minimizing states in a finite automaton. In Z. Kohave, editor, Theory of Machines and computations. Academic Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>H Horacek</author>
</authors>
<title>An algorithm for generating referential descriptions with flexible interfaces.</title>
<date>1997</date>
<booktitle>In Proc. of the 35th ACL.</booktitle>
<contexts>
<context position="23070" citStr="Horacek (1997)" startWordPosition="4026" endWordPosition="4028">n the AGC algorithm; it will be hard for any realizer to find a reasonable way of expressing a formula like -,]R.(-,Pn-,Q) as a smooth noun phrase. Although we agree with van Deemter (2002) and others that the careful use of negation and disjunction can improve REs, these connectives must not be overused. Thus we consider the formulas computed by the £G algorithm “safer” with respect to realization. Of course, we share the problem of interfacing GRE and realization with every other approach that separates these two modules, i.e., almost the entire GRE literature (notable exceptions are, e.g., Horacek (1997) and SPUD (Stone and Webber, 1998)). 300 200 100 0 10 20 30 40 50 60 70 80 90 100 Figure 4: Average runtimes (in ms) of the two algorithms on random models with different numbers of individuals. In principle, we believe that it is a good idea to handle sentence planning and realization in a single module; for instance, SPUD can use its awareness of the syntactic context to generate succinct REs as in “take the rabbit from the hat”. We hope that the ideas we have explored here for efficient and expressive RE generation can eventually be combined with recent efficient algorithms for integrated s</context>
</contexts>
<marker>Horacek, 1997</marker>
<rawString>H. Horacek. 1997. An algorithm for generating referential descriptions with flexible interfaces. In Proc. of the 35th ACL.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Kelleher</author>
<author>G-J Kruijff</author>
</authors>
<title>Incremental generation of spatial referring expressions in situated dialog.</title>
<date>2006</date>
<booktitle>In Proc. of COLING/ACL.</booktitle>
<contexts>
<context position="1450" citStr="Kelleher and Kruijff, 2006" startWordPosition="204" endWordPosition="208"> The generation of referring expressions (GRE) is one of the most active and successful research areas in natural language generation. Building upon Dale and Reiter’s work (Dale, 1989; Dale and Reiter, 1995), various researchers have added extensions such as reference to sets (Stone, 2000), more expressive logical connectives (van Deemter, 2002), and relational expressions (Dale and Haddock, 1991). Referring expressions (REs) involving relations, in particular, have received increasing attention recently; especially in the context of spatial referring expressions in situated generation (e.g. (Kelleher and Kruijff, 2006)), where it seems particularly natural to use expressions such as “the book on the table”. However, the classical algorithm by Dale and Haddock (1991) was recently shown to be unable to generate satisfying REs in practice (Viethen and Dale, 2006). Furthermore, the Dale and Haddock algorithm and most of its successors (such as (Kelleher and Kruijff, 2006)) are vulnerable to the problem of “infinite regress”, where the algorithm jumps back and forth between generating descriptions for two related individuals infinitely, as in “the book on the table which supports a book on the table ... ”. In th</context>
<context position="25825" citStr="Kelleher and Kruijff (2006)" startWordPosition="4493" endWordPosition="4497">of ELU(¬), i.e., EL plus disjunction and atomic negation. The approach presented here fits well into this landscape, and it completes the picture by showing how to generate REs in ALC, which combines all connectives used in any of these previous approaches. Where our approach breaks new ground is in the way these formulas are computed: It successively refines a decomposition of the domain into subsets. In this way, it is reminiscent of the Incremental Algorithm, which in fact can be seen as a special case of the EL algorithm. However, unlike Dale and Haddock (1991) and its successors, such as Kelleher and Kruijff (2006), we do not have to take special precautions to avoid infinite regress. While Dale and Haddock’s algorithm attempts to generate a RE for a single individual, for successive individuals in the model, our algorithms consider all individuals in GRE algorithm DL variant Dale and Reiter (1995) van Deemter (2002) Dale and Haddock (1991) Kelleher and Kruijff (2006) Gardent (2002) Figure 5: DL variants used by different GRE algorithms. parallel. It monotonically refines a partition of the model and never needs to backtrack, and therefore is always guaranteed to terminate. Perhaps closest in spirit to </context>
</contexts>
<marker>Kelleher, Kruijff, 2006</marker>
<rawString>J. Kelleher and G.-J. Kruijff. 2006. Incremental generation of spatial referring expressions in situated dialog. In Proc. of COLING/ACL.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Koller</author>
<author>M Stone</author>
</authors>
<title>Sentence generation as planning.</title>
<date>2007</date>
<booktitle>In Proc. of the 45th ACL.</booktitle>
<contexts>
<context position="23738" citStr="Koller and Stone (2007)" startWordPosition="4144" endWordPosition="4147">100 0 10 20 30 40 50 60 70 80 90 100 Figure 4: Average runtimes (in ms) of the two algorithms on random models with different numbers of individuals. In principle, we believe that it is a good idea to handle sentence planning and realization in a single module; for instance, SPUD can use its awareness of the syntactic context to generate succinct REs as in “take the rabbit from the hat”. We hope that the ideas we have explored here for efficient and expressive RE generation can eventually be combined with recent efficient algorithms for integrated sentence planning and realization, such as in Koller and Stone (2007). One problem that arises in our approach is that 400 EL ALC 47 both algorithms derive some measure of efficiency from their freedom to build formulas without having to respect any linguistic constraints. It seems straightforward, for instance, to extend Krahmer et al.’s (2003) approach such that it only considers subgraphs that can actually be realized, because their algorithm proceeds by a genuine search for uniquely identifying subgraphs, and will simply take a different branch of the search if some subgraph is useless. This would be harder in our case. Our algorithms don’t search in the sa</context>
</contexts>
<marker>Koller, Stone, 2007</marker>
<rawString>A. Koller and M. Stone. 2007. Sentence generation as planning. In Proc. of the 45th ACL.</rawString>
</citation>
<citation valid="true">
<authors>
<author>E Krahmer</author>
<author>S van Erk</author>
<author>A Verleg</author>
</authors>
<title>Graphbased generation of referring expressions.</title>
<date>2003</date>
<journal>Computational Linguistics,</journal>
<volume>29</volume>
<issue>1</issue>
<marker>Krahmer, van Erk, Verleg, 2003</marker>
<rawString>E. Krahmer, S. van Erk, and A. Verleg. 2003. Graphbased generation of referring expressions. Computational Linguistics, 29(1).</rawString>
</citation>
<citation valid="true">
<authors>
<author>N Kurtonina</author>
<author>M de Rijke</author>
</authors>
<title>Expressiveness of concept expressions in first-order description logics.</title>
<date>1998</date>
<journal>Artificial Intelligence,</journal>
<volume>107</volume>
<marker>Kurtonina, de Rijke, 1998</marker>
<rawString>N. Kurtonina and M. de Rijke. 1998. Expressiveness of concept expressions in first-order description logics. Artificial Intelligence, 107.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Paige</author>
<author>R Tarjan</author>
</authors>
<title>Three partition refinement algorithms.</title>
<date>1987</date>
<journal>SIAM Journal on Computing,</journal>
<volume>16</volume>
<issue>6</issue>
<contexts>
<context position="9369" citStr="Paige and Tarjan, 1987" startWordPosition="1613" endWordPosition="1616">asses; we will then further adapt this algorithm for £G. In effect, both algorithms compute REs for all individuals in some model at the same time – very efficiently and without any danger of infinite regress. 3.1 Computing similarity sets It can be shown that for AGC, the similarity sets of a finite model coincide exactly with the simulation classes of this model. Simulation classes have been studied extensively in the literature (see e.g., Blackburn et al. (2001); Kurtonina and de Rijke (1998)), and there are several efficient algorithms for computing AGC-simulation classes (Hopcroft, 1971; Paige and Tarjan, 1987; Dovier et al., 2004). However, these algorithms will only compute the simulation classes themselves. Here we extend the Hopcroft (1971) algorithm such that it computes, along with each set, also a formula that denotes exactly this set. We can then use these formulas as representations of the referring expressions. The pseudocode for our AGC algorithm is shown as Algorithm 1 (with G = AGC) and Algorithm 2. Given a model M = (A, ||· ||), the algorithm computes a set RE of AGC formulas such that {||co co E RE} is the set of AGC-similarity sets of M. The algorithm starts with RE = {T} (where ||T</context>
</contexts>
<marker>Paige, Tarjan, 1987</marker>
<rawString>R. Paige and R. Tarjan. 1987. Three partition refinement algorithms. SIAM Journal on Computing, 16(6).</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Stone</author>
<author>B Webber</author>
</authors>
<title>Textual economy through close coupling of syntax and semantics.</title>
<date>1998</date>
<booktitle>In Proc. of the 9th INLG workshop.</booktitle>
<contexts>
<context position="7889" citStr="Stone and Webber (1998)" startWordPosition="1356" endWordPosition="1359"> Reiter, 1995) corresponds to building DL formulas that are conjunctions of atoms; relational REs as in Dale and Haddock (1991) are formulas of £G; and so on. We will further pursue the idea of organizing GRE approaches with respect to the variant of DL they use in Section 5. For the rest of this paper, we assume that we are generating a singular RE, i.e., the target set A will be a singleton. In this case, we will only be able to generate a formula that denotes exactly A = {a} (i.e., a RE that uniquely refers to a) if there is no 43 Figure 1: (a) The Dale and Haddock (1991) scenario; (b) the Stone and Webber (1998) scenario. other individual b to which a is similar; otherwise, any formula that is satisfied by a is also satisfied by b. Conversely, if we know that a is not similar to any other individual, then there is a formula that is satisfied by a and not by anything else; this formula can serve as a unique singular RE. In other words, we can reduce the G-GRE problem for a given model to the problem of computing the G-similarity sets of this model. Notice that this use of similarity sets can be seen as a generalization of van Deemter’s (2002) “satellite sets” to relational descriptions. In the rest of</context>
<context position="15028" citStr="Stone and Webber, 1998" startWordPosition="2694" endWordPosition="2697">able}. At this point, all formulas except table denote singletons, and further iterations don’t allow us to refine table; so the algorithm terminates. Each formula with a singleton extension {a} is a unique description of a; for instance, cup n lin.(bowl n lon.table) is only satisfied by c2, so we may refer to c2 as “the cup in the bowl on the table”. Notice that the algorithm didn’t focus on any particular individual; it simultaneously generated REs for all individuals except for the two tables (which are similar to each other). The £G algorithm has a harder time with the example in Fig. 1b (Stone and Webber, 1998). While it will correctly identify r1 as “the rabbit in the hat” and f2 as “the flower in the hat”, it will not be able to compute a RE for f1 because f1 is £G-similar to f2. Indeed, the algorithm terminates with RE containing both flower and flowernlin.hat. This is atypical pattern for asymmetrical cases of similarity in £G: If there are two formulas cp1 and cp2 in the output set with ||cp1 ||c ||cp2||, then there is generally some individual b E ||cp2 ||− ||cp1 ||such that all individuals in ||cp1 ||are similar to b, but not vice versa. By contrast, the AGC algorithm can exploit the greater </context>
<context position="23104" citStr="Stone and Webber, 1998" startWordPosition="4031" endWordPosition="4034">ill be hard for any realizer to find a reasonable way of expressing a formula like -,]R.(-,Pn-,Q) as a smooth noun phrase. Although we agree with van Deemter (2002) and others that the careful use of negation and disjunction can improve REs, these connectives must not be overused. Thus we consider the formulas computed by the £G algorithm “safer” with respect to realization. Of course, we share the problem of interfacing GRE and realization with every other approach that separates these two modules, i.e., almost the entire GRE literature (notable exceptions are, e.g., Horacek (1997) and SPUD (Stone and Webber, 1998)). 300 200 100 0 10 20 30 40 50 60 70 80 90 100 Figure 4: Average runtimes (in ms) of the two algorithms on random models with different numbers of individuals. In principle, we believe that it is a good idea to handle sentence planning and realization in a single module; for instance, SPUD can use its awareness of the syntactic context to generate succinct REs as in “take the rabbit from the hat”. We hope that the ideas we have explored here for efficient and expressive RE generation can eventually be combined with recent efficient algorithms for integrated sentence planning and realization, </context>
</contexts>
<marker>Stone, Webber, 1998</marker>
<rawString>M. Stone and B. Webber. 1998. Textual economy through close coupling of syntax and semantics. In Proc. of the 9th INLG workshop.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Stone</author>
</authors>
<title>On identifying sets.</title>
<date>2000</date>
<booktitle>In Proc. of the 1st INLG.</booktitle>
<contexts>
<context position="1113" citStr="Stone, 2000" startWordPosition="161" endWordPosition="162">ng perspective under which existing GRE algorithms can be compared. We also show that by applying existing algorithms for computing simulation classes in description logic, we can obtain extremely efficient algorithms for relational referring expressions without any danger of running into infinite regress. 1 Introduction The generation of referring expressions (GRE) is one of the most active and successful research areas in natural language generation. Building upon Dale and Reiter’s work (Dale, 1989; Dale and Reiter, 1995), various researchers have added extensions such as reference to sets (Stone, 2000), more expressive logical connectives (van Deemter, 2002), and relational expressions (Dale and Haddock, 1991). Referring expressions (REs) involving relations, in particular, have received increasing attention recently; especially in the context of spatial referring expressions in situated generation (e.g. (Kelleher and Kruijff, 2006)), where it seems particularly natural to use expressions such as “the book on the table”. However, the classical algorithm by Dale and Haddock (1991) was recently shown to be unable to generate satisfying REs in practice (Viethen and Dale, 2006). Furthermore, th</context>
</contexts>
<marker>Stone, 2000</marker>
<rawString>M. Stone. 2000. On identifying sets. In Proc. of the 1st INLG.</rawString>
</citation>
<citation valid="true">
<authors>
<author>K van Deemter</author>
<author>I van der Sluis</author>
<author>A Gatt</author>
</authors>
<title>Building a semantically transparent corpus for the generation of referring expressions.</title>
<date>2006</date>
<booktitle>In Proc. of the 4th INLG.</booktitle>
<marker>van Deemter, van der Sluis, Gatt, 2006</marker>
<rawString>K. van Deemter, I. van der Sluis, and A. Gatt. 2006. Building a semantically transparent corpus for the generation of referring expressions. In Proc. of the 4th INLG.</rawString>
</citation>
<citation valid="true">
<authors>
<author>K van Deemter</author>
</authors>
<title>Generating referring expressions: Boolean extensions of the incremental algorithm.</title>
<date>2002</date>
<journal>Computational Linguistics,</journal>
<volume>28</volume>
<issue>1</issue>
<marker>van Deemter, 2002</marker>
<rawString>K. van Deemter. 2002. Generating referring expressions: Boolean extensions of the incremental algorithm. Computational Linguistics, 28(1):37–52.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Viethen</author>
<author>R Dale</author>
</authors>
<title>Algorithms for generating referring expressions: Do they do what people do?</title>
<date>2006</date>
<booktitle>In Proc. of the 4th INLG.</booktitle>
<contexts>
<context position="1696" citStr="Viethen and Dale, 2006" startWordPosition="245" endWordPosition="248"> such as reference to sets (Stone, 2000), more expressive logical connectives (van Deemter, 2002), and relational expressions (Dale and Haddock, 1991). Referring expressions (REs) involving relations, in particular, have received increasing attention recently; especially in the context of spatial referring expressions in situated generation (e.g. (Kelleher and Kruijff, 2006)), where it seems particularly natural to use expressions such as “the book on the table”. However, the classical algorithm by Dale and Haddock (1991) was recently shown to be unable to generate satisfying REs in practice (Viethen and Dale, 2006). Furthermore, the Dale and Haddock algorithm and most of its successors (such as (Kelleher and Kruijff, 2006)) are vulnerable to the problem of “infinite regress”, where the algorithm jumps back and forth between generating descriptions for two related individuals infinitely, as in “the book on the table which supports a book on the table ... ”. In this paper, we propose to view GRE as the problem of computing a formula of description logic (DL) that denotes exactly the set of individuals that we want to refer to. This very natural idea has been mentioned in passing before (Krahmer et al., 20</context>
<context position="3448" citStr="Viethen and Dale (2006)" startWordPosition="535" endWordPosition="538"> the view of GRE as a problem of computing DL formulas with a given extension allows us to apply existing algorithms for the latter problem to obtain efficient algorithms for GRE. We present algorithms that compute such formulas for the description logics £G (which allows only conjunction and existential quantification) and AGC (which also allows negation). These algorithms effectively compute REs for all individuals in the domain at the same time, which allows them to systematically avoid the infinite regress problem. The £G algorithm is capable of generating 67% of the relational REs in the Viethen and Dale (2006) dataset, in about 15 milliseconds. The AGC algorithm is even faster; it computes relational REs for all 100 individuals in a random model in 140 milliseconds. The paper is structured as follows. In Section 2, 42 we will first define description logics. We will then show how to generate REs by computing DL similarity sets for AGC and £G in Section 3. In Section 4, we evaluate our algorithms and discuss our results. Section 5 compares our approach to related research; in particular, it shows how various prominent GRE algorithms fit into the DL framework. Section 6 concludes and points to future</context>
<context position="16749" citStr="Viethen and Dale (2006)" startWordPosition="2994" endWordPosition="2997"> to those humans produce, we use a corpus of human-generated referring expressions collected and made available by Jette Viethen and Robert Dale.1 They asked human subjects to describe one of 16 filing cabinet drawers. The drawers had different colors and were arranged in a four-by-four grid (see Fig. 2). The human subjects used four non-relational properties (the drawer’s color, its column and row number, and whether it is in a corner) and five relational properties (above, below, next to, left of, right of). Of the 118 referring expressions obtained in the experiment, only 15 use relations. Viethen and Dale (2006) describe the data in more detail and present results of evaluating the Full Brevity algorithm, the Incremental Algorithm (both by Dale and Reiter (1995)), and the Relational Algorithm (Dale and Haddock, 1991) on this corpus. The Incremental Algorithm is dependent on a predefined ordering in which properties are added to the description. Viethen and Dale, therefore, try all possible orderings and evaluate what percentage of descriptions an algorithm can generate with any of them. The Full Brevity and the Relational Algorithms choose properties based on their discriminatory power and only use t</context>
<context position="21571" citStr="Viethen and Dale (2006)" startWordPosition="3776" endWordPosition="3779">w) 10 the blue drawer above the pink drawer (2x) blue u ∃above.(pink) / blue n 3above.(pink) n 3below.(blue) / blue n 3next.(orange) n 3next.(yellow) 11 the yellow drawer next to the orange drawer (2x) yellow n 3above.orange / yellow n 3below.yellow / yellow u ∃next.orange 12 the orange drawer below the pink drawer orange n 3above.(pink n corner) / orange u ∃below.pink / orange n 3next.yellow 14 * the orange drawer below the two yellow drawers (2x) orange n 3next.(pink n corner) n 3next.(pink) / orange n 3below.yellow / orange n 3next.(pink n corner) Figure 3: The relational descriptions from Viethen and Dale (2006), annotated with the drawer id and the outputs of the £G algorithm using three different orderings. Notice that four descriptions occurred twice in the corpus. Descriptions that the £G algorithm cannot generate with any ordering are marked by *. Generated descriptions that match one produced by humans are in boldface. any relational GRE algorithm in the literature. 4.3 Interface to realization Our GRE algorithms do not guarantee that the formula they compute can actually be realized in language. For example, none of the formulas our algorithms computed in the Viethen and Dale domain contained </context>
<context position="27494" citStr="Viethen and Dale (2006)" startWordPosition="4774" endWordPosition="4777">their subgraphs as formulas of hybrid logic which are satisfied at the points where the subgraph can be embedded; and hybrid logics can be seen as very expressive description logics (Areces and ten Cate, 2006). 6 Conclusion In this paper, we have explored the idea of viewing the generation of singular REs as the problem of computing a DL formula with a given extension. We have shown how such formulas can be computed efficiently (for ALC and EL) by adapting existing algorithms from the literature. The EL algorithm is able to generate 95% of the non-relational and 67% of the relational REs from Viethen and Dale (2006). Both algorithms are extremely efficient (350 ms and 140 ms respectively to generate relational REs for all individuals in a random model with 100 individuals); to our knowledge, these are by far the fastest runtimes for relational GRE reported in the literature. We have made our implementation available online at http://code.google.com/p/ crisp-nlg/wiki/DlGre. Because they compute referring expressions for all individuals in the domain at once, our algorithms will perform especially strongly in static settings, such as the generation of descriptions for museum CL PL EL EL ELU(¬) 48 exhibits,</context>
</contexts>
<marker>Viethen, Dale, 2006</marker>
<rawString>J. Viethen and R. Dale. 2006. Algorithms for generating referring expressions: Do they do what people do? In Proc. of the 4th INLG.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>