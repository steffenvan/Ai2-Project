<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000081">
<title confidence="0.999372">
A Case Analysis Method Cooperating with ATNG
and Its Application to Machine Translation
</title>
<author confidence="0.988344">
Hitoshi HDA, Kentaro OGURA and Hirosato NOMURA
</author>
<affiliation confidence="0.9330435">
Musashino Electrical Communication Laboratory, N.T.T.
Musashino-shi, Tokyo, 180, Japan
</affiliation>
<sectionHeader confidence="0.931096" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.9999645625">
This paper present a new method for parsing
English sentences. The parser called LUTE-EJ parser
is combined with case analysis and ATNG-based
analysis. LUTE-EJ parser has two interesting
mechanical characteristics. One is providing a
structured buffer, Structured Constituent Buffer, so
as to hold previous fillers for a case structure, instead
of case registers before a verb appears in a sentence.
The other is extended HOLD mechanism(in ATN), in
whose use an embedded clause, especially a &amp;quot;be-
deleted&amp;quot; clause, is recursively analyzed by case
analysis. This parser&apos;s features are (1)extracting a
case filler, basically as a noun phrase, by ATNG-
based analysis, including recursive case analysis, and
(2)mixing syntactic and semantic analysis by using
case frames in case analysis.
</bodyText>
<sectionHeader confidence="0.967765" genericHeader="introduction">
1. Introduction
</sectionHeader>
<bodyText confidence="0.999925263157895">
In a lot of natural language processing including
machine translation, ATNG-based analysis is a usual
method, while case analysis is commonly employed
for Japanese language processing.The parser
described in this paper consists of two major parts.
One is ATNG-based analysis for getting case
elements and the other is case-analysis for getting a
semantic clause analysis. LUTE-EJ parser has been
implemented on an experimental machine
translation system LUTE (Language Understander,
Translator &amp; Editor) which can translate English
into Japanese and vice versa. LUTE-EJ is the
English-to-Japanese version of LUTE.
In case analysis, two ways are generally used for
parsing. One way analyzes a sentence from left to
right, by using case registers. Case fillers which fill
each case registers are major participants of
constituents, for example SUBJECT, OBJECT,
PP(Prepositional Phrase)&apos;s and so on, in a sentence.
In particular, before a verb appears, at least one
participant(the subject) will be registered, for
example, in the AGENT register.
The other method has two phases on the analysis
processing. In the first processing, phrases are
extracted as case elements in order to fill the slots of a
case frame. The second is to choose the adequate case
element among the extracted phrases for a certain
case slot and to continue this process for the other
phrases and the other case slots. In this method,
there are no special actions, i.e. no registering before
a verb appears.(Winograd [83] )
English question-answering system PLANES
(Waltz [78] ) uses a special kind of case frames,
&amp;quot;concept case frames&amp;quot;. By using them, phrases in a
sentence, which are described by using particular
&amp;quot;subnets&amp;quot; and semantic features (for a plane type and
so on), are gathered and an action of a requirement (a
sentence) is constructed.
</bodyText>
<sectionHeader confidence="0.926102" genericHeader="method">
2. LUTE-EJ Parser
2.1. LUTE-EJ Parser&apos;s Domain
</sectionHeader>
<bodyText confidence="0.999885857142857">
The domain treated by LUTE-EJ parser is what
might be called a set of &amp;quot;complex sentences and
compound sentences&amp;quot;. Let S be an element of this set
and let CLAUSE be a simple sentence (which might
include an embedded sentence). Now, if MAJOR-CL
and MINOR-CL are principal clause and subordinate
clause, respectively, S can be written as follows.
</bodyText>
<figure confidence="0.617993">
(111) &lt;S&gt;::=(&lt;MINOR-CL&gt;)&lt;MAJOR-CL&gt;
(&lt;MINOR-CL&gt;)
(R2) &lt;MAJOR-CL&gt;::= &lt;CLAUSE&gt; / &lt;S&gt;
(R3) &lt;MINOR-CL&gt;::= &lt;CONJUNCTION&gt;
&lt;CLAUSE&gt; (in BNF)
</figure>
<bodyText confidence="0.9929927">
The syntactic and semantic structure for a
CLAUSE is basically expressed by a case structure.
In this expression, the structure can be described by
using case frames. The described structure implies
the semantic structure intended by a CLAUSE and
mainly depending on verb lexical information.
Case elements in a CLAUSE are Noun Phrases,
object NPs of PPs or some kinds of ADVerbs with
relation to times and locations. The NP structure is
described as follows,
</bodyText>
<footnote confidence="0.4818565">
(R4)&lt;NP&gt;::=(&lt;NHD&gt;){&lt;NP&gt;/NOUN}(&lt;NMP&gt;)
/&lt;Gerund-PH&gt; /&lt;To-infinitive-PH&gt; /That&lt;CLAUSE&gt;
</footnote>
<page confidence="0.999564">
154
</page>
<bodyText confidence="0.9938226">
where NHD(Noun HeaDer) is &amp;quot;premodification&amp;quot; and
NMP(Noun Modifier Phrase) is &amp;quot;postmodification&amp;quot;.
Thus, NMP is a set including various kinds of
embedded finite clauses, relative or be-deleted
relative finite clauses.
</bodyText>
<subsectionHeader confidence="0.986602">
2.2. LUTE-EJ Parser Overview
</subsectionHeader>
<bodyText confidence="0.999349292682927">
After morphological analysis with looking up
words for an input sentence in the dictionary, an
input sentence analysis is begun from left to right.
Thus, after a verb has been seen, it makes progress to
analyze a CLAUSE by referring to the case frame
corresponding to the verb, as each slot in the case
frame is filled with an NP or an object of PP. A case
slot consists of three elements: one semantic filler
condition slot and two syntactic and semantic marker
slots. Here, a preposition is directly used as a
syntactic marker. Furthermore, four pseudo
markers, &amp;quot;subject&amp;quot;, &amp;quot;object&amp;quot;, &amp;quot;indirect-object&amp;quot; and
&amp;quot;complement&amp;quot;, are used. As a semantic marker, a so-
called deep case is used (now, 41 ready for this case
system). Then, LUTE-EJ Parser extracts the
semantic structure implied in a sentence (S or
CLAUSE) as an event or state instance created from
a case frame, which is a class or a prototype. An NP is
parsed by the ATNG-based analysis in order to decide
a case slot filler (now, 81 nodes on this ATNG).
Next, the reason why the case analysis and
ATNG-based analysis are merged will be stated. It
has two main points.
One point is about the depth of embedded
structures. For example, the investigation on the
degree of a CLAUSE complexity resulted in the
necessity to handle a high degree of complexity with
efficiency. The NMP structure is also more complex.
In particular, embedded VPs or ADJPHs appear
recursively. Therefore, a recursive process for
analyzing NP is needed.
The other point is about the representation of
grammatical structures. Grammar descriptions
should be easy to read and write. Representations by
using case frames make rules of any kind for NMP
very simple, describing no NMP contents.
In order to deal with the above two points,
combining the case analysis with ATNG-based
analysis solves those problems. Verbal
NMP(VTYPE-NMP)s are dealt with by recursive
case-analyzing
</bodyText>
<subsectionHeader confidence="0.975669">
2.3. Structured Constituent Buffer
</subsectionHeader>
<bodyText confidence="0.996130871794872">
As mentioned above, syntactic and semantic
structures are basically derived from a sentence by
analyzing a CLAUSE. Analysis control depends on
the case frame, when the verb has been just
appearing in a CLAUSE. However until seeing the
verb, all of the phrases, which may be noun phrases
with embedded clauses, PPs or ADVs before the verb,
must be held in certain registers or buffers.
Here, a new buffer, STRuctured CONstituent
Buffer(STRCONB), is introduced to hold these
phrases. This buffer has surface constituents
structure, and consists of specific slots. There are two
slot types. One is a register to control English
analysis and the other is a buffer to hold some
mentioned-above constituents. The first type has two
slots; one is similar to a blackboard and registers the
names of unfilled-slots. The other stacks the names
of filled-slots in order of phrase appearance and is
used for backtracking in the analysis. The second slot
type involves several kinds of procedures. One of the
main procedures, &amp;quot;getphrase&amp;quot;, extracts some
candidates for the slot filler from the left side of a
CLAUSE. It fills the slot with these candidates. This
procedure takes one argument, which is a constituent
marker, &amp;quot;prepositional-phrase&amp;quot;, &amp;quot;noun-phrase&amp;quot; and so
on (in practice, using each abbreviation).
For example, when the following sentence is
given, the evaluation for &amp;quot;(getphrase &apos;preph)&amp;quot;in LISP
returns one symbol generated for the head
prepositional phrase, &amp;quot;In the machine language&amp;quot;, and
determines the slot filler.
(sl) &amp;quot;In the machine language each basic
machine operation is represented by the
numerical code that invokes it in the
computer, and &amp;quot;
However, if the argument is &apos;verb&amp;quot;, this procedure
only tells that the top word of unprocessed CLAUSE
is a verb. At that moment, the process of filling with
slots in STRCONB ends. Then case analysis starts.
</bodyText>
<subsectionHeader confidence="0.990715">
2.4. CLAUSE Analysis
</subsectionHeader>
<bodyText confidence="0.9999673125">
After seeing a verb in a CLAUSE, that is, filling
the verb slot in the STRCONB, the case analysis
starts. When the parser control moves on the case
frame, the analyzer falls to work in order to fill the
first case slot, which is generally one for the
constituent SUBJECT and for the case AGENT or
INSTRUMENT, etc. in the semantic structure. This
first slot is special, because the filler has already been
predicted in the slot for SUBJECT in STRCONB.
Therfore, the predicted phrase is tested to determine
whether or not it satisfies the semantic condition of
the first case slot. If it is good, the slot is filled with it
as a case instance. The parser control moves to the
next case slot and a candidate phrase for it is
extracted from the remainder of the input sentence by
invoking the function &amp;quot;getphrase&amp;quot; with NP-
</bodyText>
<page confidence="0.995239">
155
</page>
<bodyText confidence="0.999956095238095">
argument. This slot is usually OBJECT, or
obligatory prepositional phrase name if the verb is
intransitive. Furthermore, the control moves to the
next case slot to fill it, if the case frame has more
slots, all of which are obligatory case slots. They are
described in a meaning slot (whose value is a
meaning frame) in a case frame, while optional case
slots are united in a special frame.
The process to fill the case slots is continuing until
the end of the case frame. Then, more than one
candidate for a case structure may be extracted.
More than one for an NP extracted by &amp;quot;getphrase&amp;quot;
gives many case structures, because of the difference
in input remainders.
Next, recusive parsing will be mentioned. In
analyzing embedded clauses, which are VTYPE-
NMPs. CLAUSE analysis also gets in use of NPs
parsing. It is supported with a new STRCONB. The
procedure to call NP analysis is described in the next
section. The conceptual diagram for LUTE-EJ
analysis as a recusive CLAUSE is shown in Fig.1.
</bodyText>
<sectionHeader confidence="0.7618195" genericHeader="method">
Fig.1 Conceptual Diagram of LUTE-EJ Analysis
2.5. NP Analysis
</sectionHeader>
<bodyText confidence="0.96142175">
An NP structure is basically described as the rule
(R4). In this paper, NHD structure and the analysis
for it are omitted. NMP is another main NP
constituent and will be explained here.
</bodyText>
<listItem confidence="0.958874666666667">
NMT is described in the following form.
(R5) &lt;NMP&gt; : : =
&lt;PP&gt; i &lt;PResent-Participle-PHrase&gt; /
&lt; PaSt-Participle-PH &gt; / &lt; A DJ ective-PH &gt; /
&lt; INFinitive-PH &gt; / &lt; RE Lative-PH &gt; /
&lt;CARDINAL&gt; &lt;UNIT&gt; &lt;ADJ&gt;
</listItem>
<bodyText confidence="0.989687212121212">
If an NMP is represented by any kind of VP or
ADJ-PH, it is described in a case structure by using a
case frame. That is, VTYPE-NMPs are parsed in the
same way as CLAUSEs. However, a VTYPE-NMP
has one (or more) structural missing element (a hole)
compared with a CLAUSE. Therefore,
complementing them is needed by restoring a reduced
form to the complete CLAUSE. Extending &amp;quot;HOLD&amp;quot;-
manipulation in ATN makes it possible. This
extension deals with not only relative clauses but also
VTYPE-NMPs. That is, the phrases with a &amp;quot;whiz-
deletion&amp;quot; in Transformational Grammar can be
treated. ADJ-PHs can also be treated. For example,
the following phrase is discussed.
(s2) &amp;quot;I know an actor suitable for the part.&amp;quot;
nmp
In the above case, the deletion of the words, &amp;quot;who is&amp;quot;,
results in the complete sentence being the above
representation. The extending HOLD-manipulation
holds the antecedent of a CLAUSE with a VTYPE-
NMP. Calling the case analysis recursively, the
VTYPE-NMP is parsed by it. Each VTYPE-NMP has
a specific type, PRP-PH, PSP-PH, INF-PH or ADJ-
PH. Each of them looks for an antecedent, as the
object or the subject: so that each is treated according
to the procedure to decide the role of the antecedent
and the omitting grammatical relation. Therefore, it
is necessary to introduce one &amp;quot;context&amp;quot; representing
VTYPE-NMP. The present extension demands the
context with the antecedent and calls the case
analysis.
The following structured representation describes
a NOUN, as stated above.
</bodyText>
<table confidence="0.853982083333333">
(NOUN
(*TYPE ($value (instance)))
(*CATEGORY ($value (&amp;quot;semantic-category&amp;quot;)))
(*SELF ($value (&amp;quot;entry-name&amp;quot;)))
(*POS ($value (noun)))
(*MEANING ($value (&amp;quot;each-meaning-frame-list&amp;quot;)))
(*NUMBER ($value (&amp;quot;singular-or-plural&amp;quot;)))
(*MODIFIEFtS ($value (&amp;quot;NHD-or-NMP-instance-list&amp;quot;)))
(*MODIFYING ($value (&amp;quot;modificand&amp;quot;)))
(*APPOSMON ($value (&amp;quot; appositional -phrase-in stance &amp;quot;)))
(*PRE ($value (&amp;quot;prepositional-phrase-instance&amp;quot;)))
(*COORD ($value (&amp;quot;coordinate-phrase&amp;quot;))) )
</table>
<bodyText confidence="0.997691142857143">
Each word with prefix &amp;quot;*&amp;quot; describes a slot name such
as a case frame has. However many slots are
prepared for holding pointers to represent a syntactic
structure of an NP. The value for VTYPE-NMPs
*MODIFIERS is a pair of VTYPE-NMPs and an
individual verbal symbol, for example, &amp;quot;(PRP-PH
verb*1)&amp;quot;.
</bodyText>
<figure confidence="0.999683222222222">
STRUCTURED-CONSTITUENT-BUFFER
analysis of
NOUN Phrase
&lt;•sub &gt;
Case Analysis
ATNG-based analysis
•case-frame• process
&lt;•agent&gt; I embedded clause,
&lt;•object&gt; noun clause]
&lt;•recipient
STRUCTURED-CONSTITUENT-BUFFER •
Case Analysis
&amp;quot;case-frame•
&lt;•agent&gt;
&lt;•object
&lt;•rnethod
STRUCTURED-CONSTITUENT-BUFFER
Case Analysis
</figure>
<page confidence="0.996024">
156
</page>
<bodyText confidence="0.984722733333333">
Complementing NP&apos;s structure, an appositional
structure is introduced. It is described in
*APPOSITION-slot and treated in the same way as
NMPs. Those phrases are discriminated from
another NMP by a pair of a delimiter &amp;quot;,&amp;quot; and a phrase
terminal symbol, or, in particular, by proper nouns.
A Coordinate conjunction is another important
structure for an NP. There are three kinds of
coordinates in the present NP rule. The first is
between NPs, the second is NHDs, and the third is
NMPs. The NP representation with that conjunction
is described by an individual coordinate structure.
That is, the conjunction looks like a predicate with
any NPs as parameters, for example, (and NP1
NP2 NPi). Therfore, the coordinate structure has
&amp;quot;*COORDINATE-OBJECTS&amp;quot; and &amp;quot;*OBJ-CAT&amp;quot; slot,
each of which is filled with any instanciated
NP/NHD/NMP symbol or any coordinate type,
respectively.
Some linguistic heuristics are needed to parse
NPs, along with extracting as few inadequate NP
structures as possible. Several heuristics are
introduced into LUTE-EJ parser. They are shown as
follows.
(1) Heuristics for a compound NP
&amp;quot;Getphrase&amp;quot; function value for an NP is the list of
candidates for an adequate NP structure. The
function first extracts the longest NP candidate from
an input. In this analysis, its end word is separated
from the remainder of the input by some heuristics,
</bodyText>
<listItem confidence="0.91167925">
(a) The top word in the remainder is a personal
pronoun.
(b) Its end word has a plural form.
(c) Its top is a determiner.
</listItem>
<bodyText confidence="0.991413">
These heuristics prevent the value from having
abundant non-semantical structures.
(2) Heuristics by using contexts
When NP analysis is called when filling a case
slot, the case-marker&apos;s value for it is delivered to NP
analysis. This value is called &amp;quot;syntactic local
context&amp;quot;. It is useful in rejecting pronouns, which are
ungrammatically inflected, by testing the agreement
with the syntactic local context and the subject or the
object. Another context usage is shown below.
Assume that a phrase containing a coordinate
conjunction &amp;quot;and&amp;quot;, for example, is in a context which
is an object or a complement, and the word next to the
conjunction is a pronoun. If the pronoun is a
subjective case, the conjunction is determined to be
one between CLAUSEs. To the contrary, the pronoun
being a objective case determines the conjunction to
connect an NP with it.
</bodyText>
<listItem confidence="0.5732825">
(3) Apposition
Many various kinds of appositions are used in
texts. Most of them are shown by N. Sager [80). The
preceding appositional structures are used.
3. LUTE-EJ Parser Merits
3.1. A Merit of Using Case Analysis
</listItem>
<bodyText confidence="0.999978421052631">
In two sentences, each having different syntactic
structures. there is a problem involved in identifying
each case by extracting semantic relations between a
predicate and arguments (NPs, or NPs having
prepositional marks). LUTE-EJ case analysis has
solved this problem by introducing a new case slot
with three components (Section 2.2.). For case frames
in LUTE-EJ analysis containing the slots, an
analysis result has two features at the same time.
One is a surface syntactic structure and the other is a
semantic structure in two slots. Therefore, many case
frames are prepared according to predicate meanings
and case frames are prepared according to predicate
meanings and syntactic sentence patterns, depending
on one predicate (verb).
An analysis example is shown for the same
semantic structure, according to which there are
three different syntactic structures. These three
sentences are as follow (from Marcus [801).
</bodyText>
<listItem confidence="0.988896333333333">
(s3) &apos;The judge presented the prize to the boy.&amp;quot;
(s4) &apos;The judge presented the boy with the prize.&amp;quot;
(s5) &amp;quot;The judge presented the boy the prize.&amp;quot;
</listItem>
<bodyText confidence="0.977934">
Three individual structures are obtained for each
sentence and their meaning equivalence for each slot
is proved by matching the fillers of case-instances and
by doing the same for case-names.
Incidentally, a sentence containing another
meaning of &amp;quot;present&amp;quot; is as follows. It means &amp;quot;to show
or to offer to the sight&amp;quot;, for example, in a sentence,
(s6) &amp;quot;They presented the tickets at the gate.&amp;quot;
In this case, the &amp;quot;present&amp;quot; frame must prepare the
obligatory &amp;quot;at&amp;quot; case slot.
</bodyText>
<subsectionHeader confidence="0.466782">
3.2. An Effect of Combining Case Analysis with
ATNG-based Analysis
</subsectionHeader>
<bodyText confidence="0.984810083333333">
The next section shows one application of the
LUTE-EJ parser, which is a machine translation
system. So, taking the translated sample sentence in
Section 4., effective points in parsing are shown in
this section. The sample sentence is as follows.
(s7) &amp;quot;In the higher-level programming languages
the instructions are complex statements, each
equivalent to several machine-language
instructions, and they refer to memory
locations by names called variables.&amp;quot;
One point is NMP analysis method by recursive
calling for case frame analysis. In the example. two
</bodyText>
<page confidence="0.994882">
157
</page>
<bodyText confidence="0.991516222222222">
NMP phrases are seen.
(a) The phrase which is an adjective phrase and
modifies &amp;quot;each&amp;quot;, appositive
to the preceding &amp;quot;statements&amp;quot;,
(b) The phrase which is a past participle phrase
and modifies &amp;quot;names&amp;quot;.
These phrases are analyzed in the same case frame
analysis, except for the phrase deletion types
(depending on VTYPE-NMP) appearing in them. The
deleted phrases are the subject part and the object
part respectively. Judging from the point of a parsing
mechanism, extended HOLD-manipulation
transports the deleted phrases, &amp;quot;each&amp;quot; and &amp;quot;names&amp;quot;,
with the contexts to the case frame analysis.
The other point is to hold undecided case elements
in STRCONB. The head PP and the subject in the
sentences, for example, are buffering until seeing the
main verb.
</bodyText>
<listItem confidence="0.44695">
4. An Application to Machine Translation
</listItem>
<bodyText confidence="0.889680238095238">
One of the effective applications can be shown by
considering the NMP analysis with embedded
phrases. These NMPs are represented by instances of
actions, i.e. individual case frames which may be
having an unfilled case slot. Applying LUTE-EJ
parser to an automatic machine translation system,
there may be a little problem in lacking the case slots
information. The reason is because the lacking
information can be thought of as being indispensable
for a semantic structure in one language, for example
a target language Japanese, in spite of having them
in another languages, for example a source language
English. The problem is the difference in how to
modify a head noun by an NMP or an embedded
clause.
In Japanese, a NOUN is often modified by an
embedded clause in the following pattern.
&amp;quot; &lt;predicate&apos;s arguments &gt;* &lt;predicate&gt; NOUN&amp;quot;
; * representing recursive applications
Therefore, in Japanese, an NMP phrase represented
by a case frame corresponds to an embedded clause
and the verb of the frame corresponds to the
predicate.
A translation example is shown in Fig.2.
References
Marcus, Mitchell P., &amp;quot;A Theory of Syntactic
Recognition for Natural Language&amp;quot;, MIT Press, 1980.
Sager, Naomi, &amp;quot;Natural Language Information
Processing&amp;quot;, Addison-Wesley, 1981.
Waltz, David L., &amp;quot;An English Language Question..
AnsweringSystem for a Language Relational Data
Base&amp;quot;, CACM Vol.21, 1978.
Winograd, Terry, &amp;quot;Language as a Cognitive Process&amp;quot;,
Vo1.1, Addison-Wesley, 1983.
In the Hi9her-level pro9rame!
in9 lan9ua9es the instructiot
ns are fairly complex statemt
ents • each equivalent to se!
ve,-al machinela9a9e instr!
uctions and they refer to !
memory locations by names cal
Ited variables .
</bodyText>
<figure confidence="0.995825972222222">
/1-WidEtitc): MatcrsJ,----c t
. !
S.) Lge,ttiAPh
L_
Original Text (English)
E:SENTENCE:0002 E:E0NDID0TE.,4
E:SENTENCE:0006 E:CANDIDATEoc
E:EENTEMCE:0010 E:CANDIDATE*2
E:PPE0ICATE:0024 E:uERB.4
E&apos;E&amp;quot;E:ENTRY:01069 E:MEMORY
E.CA
,&apos;,E:SENTENCE:0006 E:CANDIDATEr
&apos;&apos;&apos;&apos;,&apos;&apos;E:SENTENCE:0010 E:CANDIOATE.
E.En
&apos; E:PREDICATE:0024 E:uERD.4
E:DE
,,E:ENTRY:006B E:BE
E:CASE-PI
&amp;quot;10E:N0UNPHP39E:0037 E:nOUN.11
E:Ef
E:ENTPY:006S E:InSTRUCTION
E:NO
E:DETERMINANT:0047 E:DET.7
E:En,
E:M0i:
E:PP E:C1‘6E-ELEMENT:0034 E:U6E-ELLMEnT-2
NOUNPHPASE:0037 E:NOuno46
ENTRY :0069 E:STATEMENT
NOu
.4.
IAD
IND
IN
(4.n
EnO
nOU
..•
nJE
UBJ
nO
INO
tuEl
UBJ
NOI
(NOI
Not
J•4(
rIOt
01,
•••I
UBJ
Noi
E:NOUN HEADER:0049 E:00Jm35
.&apos;&apos;&apos;.&apos;E:NOUN-HEPDER:0052 E:60J.35
E:COMPLEX
E:m001 Fl ER0067 E:ADVERB.IB
`;&apos;&amp;quot;E‘PPEDICATE:0024 E:PDJPm*5
E:E1-ITPY:0069 E:EQuIul,iLENT
E.CASE-ELEmENT:0054 E:CASE-ELEME141-4
kn
770V,
2
2 2
a 3. *-74;3.1t.001
2 4.
3 ,ITR,R;116
A*0 2. t
t6&apos; 75, td: M-4 td:
-LittAF14
Translated Result (Japanese)
EADE
Generated Internal Representation Processes Window
</figure>
<figureCaption confidence="0.616918">
Fig. 2 An Example of LUTE Translation Results on the Display
(from English to Japanese)
</figureCaption>
<page confidence="0.979897">
158
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.854435">
<title confidence="0.997503">A Case Analysis Method Cooperating with ATNG and Its Application to Machine Translation</title>
<author confidence="0.954648">Hitoshi HDA</author>
<author confidence="0.954648">Kentaro OGURA</author>
<author confidence="0.954648">Hirosato NOMURA</author>
<affiliation confidence="0.909153">Musashino Electrical Communication Laboratory, N.T.T.</affiliation>
<address confidence="0.929621">Musashino-shi, Tokyo, 180, Japan</address>
<abstract confidence="0.999210529411765">This paper present a new method for parsing English sentences. The parser called LUTE-EJ parser is combined with case analysis and ATNG-based analysis. LUTE-EJ parser has two interesting mechanical characteristics. One is providing a structured buffer, Structured Constituent Buffer, so as to hold previous fillers for a case structure, instead of case registers before a verb appears in a sentence. The other is extended HOLD mechanism(in ATN), in whose use an embedded clause, especially a &amp;quot;bedeleted&amp;quot; clause, is recursively analyzed by case analysis. This parser&apos;s features are (1)extracting a case filler, basically as a noun phrase, by ATNGbased analysis, including recursive case analysis, and (2)mixing syntactic and semantic analysis by using case frames in case analysis.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
</citationList>
</algorithm>
</algorithms>