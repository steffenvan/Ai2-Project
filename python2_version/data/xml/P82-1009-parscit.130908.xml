<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000004">
<note confidence="0.293632333333333">
THEORETICAL/TECHNICAL ISSUES IN NATURAL LANGUAGE ACCESS TO DATABASES
S. R. Petrick
IBM T.J. Watson Research Center
</note>
<sectionHeader confidence="0.990033" genericHeader="introduction">
INTRODUCTION
</sectionHeader>
<bodyText confidence="0.999975285714286">
In responding to the guidelines established by
the session chairman of this panel, three of the
Live topics he set forth will be discussed. These
include aggregate functions and quantity questions,
querying semantically complex fields, and multi-file
queries. As we will make clear in the sequel, the
transformational apparatus utilized in the TQA Ques-
tion Answering System provides a principled basis
for handling these and many other problems in
natural language access to databases.
In addition to considering some subset of the
chairman&apos;s five problems, each of the panelists was
invited to propose and choose one issue of his/her
own choosing. If time and space permitted, I would
have chosen the subject of extensibility of natural
language systems to new applications. In light of
existing restrictions, however, I have chosen a more
tractable problem to which I have given some atten-
tion and in whose treatment I am interested; this is
the translation of quantified relational calculus
expressions to a formal query language such as SQL.
</bodyText>
<sectionHeader confidence="0.98527" genericHeader="method">
AGGREGATE FUNCTIONS AND QUANTITY QUESTIONS
</sectionHeader>
<bodyText confidence="0.99952028125">
Questions such as &amp;quot;How many employees are in the
sales department?&amp;quot; must be mapped into three radi-
cally different database query language expressions
depending on how the database is set up. It may be
appropriate to retrieve a pre-stored total number of
employees from a NUMBER-OF-EMPLOYEES field of a
DEPARTMENT file, or to count the number of records
in an EMPLOYEE file that have the value SALES in the
DEPARTMENT field, or, if departments are broken down
into offices with which are associated the total
numbers of employees employed therein, to total the
values of the NUMBER-OF-EMPLOYEES field in all the
records for offices in the sales department.
In the TQA System there are a number of differ-
ent levels of representation of a given query. The
grammar which assigns structure to a query has some
core components which are essentially
application-independent (e.g., the cyclic and post-
cyclic transformations) and has other components
that are application-dependent (e.g., portions of
the lexicon and precyclic transformations). Surface
structures are mapped by the application-independent
post cyclic and cyclic transformations into a rela-
tively deep structural level which is referred to as
the underlying structure level. In this represen-
tation, sentence nodes are expanded into a verb fol-
lowed by a sequence of noun phrases, and the
representation of reference is facilitated by the
use of logical variables Xl, X2, . The underly-
ing structure corresponding to the previously cited
example sentence would be something like the follow-
ing (suppressing details):
</bodyText>
<sectionHeader confidence="0.8684485" genericHeader="method">
NP
LOCATED WH SOME MANY EMPLOYEE X1 SALES DEPARTMENT
</sectionHeader>
<bodyText confidence="0.999960166666667">
Now, depending on feature information associated
with the lexical items in the two NP&apos;s,
application-specific precyclic transformations can
be formulated to map this underlying structure into
any of three query structures that directly reflect
the three data structures and corresponding formal
queries previously discussed. Rather than sketching
query structures that could be produced for this
example, let me be more specific by substituting the
actual treatment of two similar sentences currently
treated by the TQA System land-use application.
These are the sentences:
</bodyText>
<listItem confidence="0.998327">
(1) &amp;quot;How many parking lots are there in ward 1 block
2?&amp;quot;
(2) &amp;quot;How many parking spaces are there in ward 1
block 2?&amp;quot;
</listItem>
<bodyText confidence="0.9976582">
In the current data base, individual lots are
identified as being parking lots by a land use code
relation LUCF, which has attributes that include
JACCN (parcel account number) and LUC (land use
code). Parking lots have an LUC value of 460. Anoth-
er relation, PARCFL, has attributes which include
JACCN and JPRK (the number of parking spaces on a
given parcel).
The underlying structures assigned to both these
sentences are nearly identical, differing only in
the lexical distinctions between &amp;quot;parking lot&amp;quot; and
&amp;quot;parking space&amp;quot;. The common structure is very much
like that of the previously given tree structure
except that PARKING LOT or PARKING_SPACE (together
with their associated features) replaces EMPLOYEE,
</bodyText>
<footnote confidence="0.6058154">
and the second NP dominates the string &amp;quot;WARD 1 BLOCK
2&amp;quot;. The feature + UNIT on a node that dominates
PARKING SPACE is not found in the corresponding
structure involving PARKING_LOT, and this feature
(together with a number of other structural prereq-
</footnote>
<page confidence="0.998648">
51
</page>
<bodyText confidence="0.999597833333333">
uisites) triggers a pair of precyclic
transformations. The action of those two transf-
ormations is roughly indicated by the following
sequence of bracketted terminal strings (the actual
trees together with all their features would take up
much more space):
</bodyText>
<equation confidence="0.997935954545455">
(BD LOCATED
((WH SOME MANY) (PARKING_SPACE X3))
((WARD 1) (BLOCK 2)) BD)
TOTPUNIT
(BD TOTAL
((WH SOME) (THING X46))
(THE (X3
(BD PARKING_SPACE
. X3
((WARD 1) (BLOCK 2)) BD))) BD)
LOTINS2
-&gt;
(BD TOTAL
((WH SOME) (THING X46))
(THE (X3
(BD PARKING_SPACE
X3
(THE ((LOT X48)
(BD LOCATED
X48
((WARD 1) (BLOCK 2))
BD))) BD))) BD)
</equation>
<bodyText confidence="0.999977222222222">
Note that the lot insertion transformation LOTINS2
has produced structure of the type which is more
directly assigned to the input query, &amp;quot;What is the
total number of parking spaces in the lots which are
located in ward 1 block 2?&amp;quot;. This structure is then
further transformed by a transformation LOCATION
that replaces the abstract verb LOCATED by a verb
(WBLOCK in this instance) which corresponds to an
existing data base relation.
</bodyText>
<equation confidence="0.9886985">
LOCATION
-&gt;
(BD TOTAL
((WH SOME) (THING X46))
(THE (X3
(BD PARKING_SPACE
X3
(THE ((LOT X48)
(BD WBLOCK
((WARD 1) (BLOCK 2))
X48
BD))) BD))) BD)
</equation>
<bodyText confidence="0.942559">
The latter structure is mapped via the TQA Knuth
attribute grammar formalism into the logical form:
</bodyText>
<equation confidence="0.993334076923077">
(setx &apos;X46
&apos;(total X46
(bagx &apos;X3
&apos;(setx &apos;X48
&apos;(and
(RELATION &apos;PARCFL
&apos;(JPRK JACCN)
&apos;(X3 X48)
&apos;(= =) )
(RELATION &apos;PARCFL
&apos;(WBLOCK JACCN
&apos;(&apos;100200 X48)
1(= =)))))))
</equation>
<bodyText confidence="0.9980092">
This logical form is in a set domain logical calcu-
lus to be discussed later in the paper. Roughly, it
denotes the set of elements X46 such that X46 is the
sum of the members of the bag (like a set, but with
possible duplicate elements) of elements X3 such
that a certain set is not empty, namely the set of
elements X48 such that X48 is the account number
(JACCN) of a parcel whose number of parking spaces
(JPRK) is X3 and whose wardblock (WBLOCK) is 100200.
The expression
</bodyText>
<equation confidence="0.989745">
(RELATION &apos;PARCFL
:&apos;(JPRK JACCN)
&apos;(X3 X48)
&apos;(= =) )
</equation>
<bodyText confidence="0.999944142857143">
in the above logical form denotes the proposition
that the relation formed from the PARCFL relation by
projecting over the attributes JPRK and JACCN con-
tains the tuple (X3 X48). The logical form is
straightforwardly translated by means of a LISP pro-
gram whose details we will not concern ourselves
with into the SQL query:
</bodyText>
<sectionHeader confidence="0.9174405" genericHeader="method">
SELECT SUM(A.JPRK)
FROM PARCFL A
</sectionHeader>
<bodyText confidence="0.973832777777778">
WHERE A.WBLOCK = &apos;100200&apos;;
The other structure (for the sentence with
PARKING_LOT) lacks the triggering feature + UNIT,
and hence transformations TOTPUNIT and LOTINS2 do
not apply; furthermore, the LOCATION transformation
applies to the original instance of the verb LOCATED
rather than the copy of LOCATED introduced by the
lot insertion transformation LOTINS2 in the analysis
of the previous sentence:
</bodyText>
<equation confidence="0.99613505">
(BD LOCATED
((WH SOME MANY) ((PARKING_LOT 460) X3))
((WARD 1) (BLOCK 2)) BD)
LOCATION
-&gt;
(BD WBLOCK
((WARD 1) (BLOCK 2))
((WH SOME MANY) ((PARKING_LOT 460) X3)) BD)
(setx &apos;X48
&apos;(quantity X48
(setx &apos;X3
&apos;(and
(RELATION &apos;PARCFL
&apos;(WBLOCK JACCN)
T100200 X3)
I(= =) )
(RELATION &apos;LUCF
&apos;(LUG JACCN)
TO460 X3)
1(= =) ) ) ) ) )
</equation>
<bodyText confidence="0.983621">
This structure is mapped via the Knuth attribute
_ grammar into the logical form:
</bodyText>
<page confidence="0.990053">
52
</page>
<bodyText confidence="0.9944935">
and this logical form is translated to the SQL
query:
</bodyText>
<sectionHeader confidence="0.3320222" genericHeader="method">
SELECT COUNT(UNIQUE A.JACCN)
FROM PARCFL A, LUCF B
WHERE A.JACCN = B.JACCN
AND B.LUC = &apos;0460&apos;
AND A.WBLOCK = &apos;100200&apos; ;
</sectionHeader>
<bodyText confidence="0.999983583333333">
The points to be made with respect to this
treatment are that the information indicating dif-
ferential, database-specific treatment can be
encoded in lexical features, and that differential
treatment itself can be implemented by means of pre-
cyclic transformations which are formally of the
same type that the TQA system uses to relate under-
lying to surface structures. The features, such as
+ UNIT in our example, are principled enough to per-
mit their specification by a data base administrator
with the help of an on-line application customiza-
tion program. (+ UNIT is also required in lexical
items such as DWELLING UNITS and STORIES).
If the database organization had been different,
simple lexical changes could have been made to trig-
ger different sequences of transformations, result-
ing in structures and ultimately SQL expressions
appropriate for that database organization. In this
way, it would be easy to handle such database organ-
izations as that in which the total number of
parking lots and/or parking spaces is stored for
each wardblock, and that in which such totals are
stored for each splitblock which is included within
a given wardblock.
</bodyText>
<sectionHeader confidence="0.902607" genericHeader="method">
QUERYING SEMANTICALLY COMPLEX FIELDS
</sectionHeader>
<bodyText confidence="0.999966780487805">
In posing this problem, the session chairman
pointed out that natural language query systems usu-
ally assume that the concepts represented by data-
base fields will always be expressed in English by
single words or fixed phrases. He cited as an exam-
ple the query &amp;quot;Is John Jones a child of an alumnus?&amp;quot;
where &amp;quot;child of an alumnus&amp;quot; is a fixed phrase
expressing the binary relation with attributes
APPLICANT (whose values are the names of applicants)
and CHILD-OF-ALUMNUS (whose values are either T or
F). He further noted that related queries such as
&amp;quot;Is one of John Jones&apos; parents an alumnus?&amp;quot; or &amp;quot;Did
either parent of John Jones attend the college?)&amp;quot;
require some different treatment.
The approach we have taken in TQA is, insofar as
possible, to provide the necessary coverage to per-
mit all the locutions that are natural in a given
application. The formalism by which this is
attempted is, once again, the transformational appa-
ratus. Transformations often coalesce queries which
have the same meaning but differ substantially in
their surface forms into common underlying or query
structures. There is, however, no requirement that
this always be done, so such queries are sometimes
mapped into logically equivalent rather than identi-
cal query structures. In either case, the
transformational formalism provides a solid basis
for assigning very deep semantic structures to a
wide spectrum of surface sentence structures. The
extent to which we have been successful in allowing
broad coverage of logically equivalent alternative
statements of a query is difficult to quantify, but
we believe that we have done well relative to other
efforts for two reasons: (1) We have made an effort
to cover as many underlying relations and their sur-
face realizations as possible in treating a given
application, and (2) The transformational formalism
we use is effective in providing the broad coverage
which reflects all the allowable interactions
between the syntactic phenomena treated by a partic-
ular grammar.
</bodyText>
<sectionHeader confidence="0.982246" genericHeader="method">
MULTI-FILE QUERIES
</sectionHeader>
<bodyText confidence="0.999880720930233">
This problem deals with multi-file databases and
the questions of which files are relevant to a given
query and how they should be joined. This &amp;quot;problem&amp;quot;
is one which is often raised, and which invariably
reflects a quick-and-dirty approach to syntactic and
semantic analysis. Within a framework such as that
provided by the transformational apparatus in TQA,
this problem simply doesn&apos;t arise. More accurately,
it is a problem which doesn&apos;t arise if an adequate
grammar is produced that assigns structure of the
depth of the TQA System&apos;s query structures. This,
of course, is no easy task, but it is one which is
central to the transformational grammar-based
approach, and its successful treatment does provide
a principled basis for eliminating a number of
potential difficulties such as this multi-file query
problem.
To see why this is so, let us consider how, for a
given query, relations are identified and joined in
TQA. As we have already indicated, TQA underlying
structures and query structures consist of sentence
nodes which dominate a verb followed by a sequence
of noun phrases. These simple structures are joined
together to form a complete sentence structure
through the use of additional phrase structure rules
which indicate conjunction, relative clause-main
clause connection, etc. Query structure verbs cor-
respond, for the most part, to database relations,
and the noun phrase arguments of those verbs corre-
spond to attributes of their associated relations.
Furthermore, query structures contain logical vari-
ables which serve the function of establishing
reference, including identity of reference. Thus if
the query structure assigned to a query identifies
two (or more) relations which have attributes whose
values are the same logical variable, we have an
indication that it is those attributes over which
the relations should be joined.
An example should make this clearer. Consider
the query structure which TQA assigns to the sen-
tence
&amp;quot;What is the zone of the vacant parcels in subplan-
ning area 410?&amp;quot;
</bodyText>
<page confidence="0.997266">
53
</page>
<bodyText confidence="0.999520166666667">
(SBLOCK) of a given parcel (JACCN) and the GEOBASE
relation gives the subplanning area (SUBPLA) of all
the parcels within a given splitblock (SBLOCK).
(We omit feature information and some structure
which is irrelevant to the subsequent discussion in
the structure below.)
</bodyText>
<equation confidence="0.973749071428571">
,.NP..,
,,DET ,....N
THE NOM S1
1 / N■,,,
/1 BD V NP
X4 / : &amp;quot;NP BD
ZONE X4 DiT NOM
. &apos; 1
THE .......40M
LOT X8 S1 S1
\\
BD V NP NP BD BD I/).: Bp
/ ■ \
SUBPLAN_AREA 410 X8 LUC 910 X8
</equation>
<bodyText confidence="0.999678714285714">
This structure represents the set of elements X4
such that X4 is the zone of an element of the set of
lots X8 such that the land use code (LUC) of X8 is
910 and the subplanning area (SUBPLAN_AREA) of X8 is
410. The structure is mapped in straightforward
fashion by a Knuth attribute grammar translation
procedure into the set domain relational calculus
</bodyText>
<equation confidence="0.9901421875">
expression:
(setx &apos;X4
&apos;(setx &apos;X8
&apos;(and
(RELATION &apos;ZONEF
&apos;(ZONE JACCN)
&apos;(X4 X8)
r(= =) )
(RELATION &apos;GEOBASE*
&apos;(SUBPLA JACCN)
T410 X8)
&apos;(= =) )
(RELATION &apos;LUCF
&apos;(LUC JACCN)
T910 X8)
&apos;(= =))))))
</equation>
<bodyText confidence="0.9960195">
Each deep (query structure) verb such as ZONE has
associated with it (by means of a translation table
entry) a relation, which is usually the projection
of an existing data base relation. Thus instead of
translating a portion of the above tree to (ZONE X4
X8), an expression which is true if X4 is the zone of
the parcel whose account number is X8, the
translation table is used to produce
</bodyText>
<equation confidence="0.89526375">
(RELATION &apos;ZONEF
&apos;(ZONE JACCN)
&apos;(X4 X8)
&apos;(= =) )
</equation>
<bodyText confidence="0.999674294117647">
which is true if the projection of the ZONEF
relation over attributes ZONE and JACCN (account
number) contains a tuple (X4 X8).
The conjunction of three relations with a common
JACCN attribute value of X8 indicates that the three
relations are to be joined over the attribute JACC&amp;quot;
There is, however, one complication in translat-
ing the relatior-i calculus expression above into a
formal query language such as SQL. The relations
ZONEF and LUCF are existing database relations, but
there is no relation GEOBASE* in the database, giv-
ing the subplanning area of specific parcels.
Instead, the PARCEL relation gives the splitblock
There are at least three solutions to the prob-
lem of bridging the gap between relational calculus
expressions such as this and appropriate formal que-
ry language expressions. These are:
</bodyText>
<listItem confidence="0.572531571428571">
(1) Write a precyclic database-specific splitblock
insertion transformation which assigns query struc-
ture corresponding to the query, &amp;quot;What are the zones
of the vacant parcels which are located in split-
blocks in subplanning area 410?&amp;quot;
(2) Store information that permits replacing
expressions involving virtual relations such as
</listItem>
<equation confidence="0.780912333333333">
(RELATION &apos;GEOBASE*
?(SUBPLA JACCN)
T0410 X8)
</equation>
<bodyText confidence="0.885399">
&apos;(= )
by existentially quantified expressions involving
only real database relations such as:
</bodyText>
<equation confidence="0.9956396">
(setx &apos;X111
(and
(RELATION &apos;PARCFL
&apos;(SBLOCK JACCN)
°(X111 X8)
&apos;(= =) )
(RELATION &apos;GEOBASE
&apos;(SUBPLA SBLOCK)
T410 X111)
1(= =) ) )
</equation>
<bodyText confidence="0.8397748">
(3) Make the data base administrator (DBA) respon-
sible for providing a formal query language defi-
nition of the virtual relations produced. In this
case that would take the form of defining GEOBASE*
as the appropriate join of projections over GEOBASE
and PARCFL.
All three solutions have been implemented in the
TQA System and used in specific cases as seems
appropriate. For a database system with the defini-
tional facilities available in SQL, solution (3) is
particularly attractive because it is the type of
activity with which data base administrators are
familiar. Solutions (1) and (2) were also imple-
mented at various times for examples such as the one
in question, leading to the following SQL query:
</bodyText>
<sectionHeader confidence="0.910777571428571" genericHeader="method">
SELECT UNIQUE A.ZONE, A.JACCN
FROM ZONEF A, GEOBASE B, PARCFL C, LUCF D
WHERE A.JACCN = C.JACCN
AND C.JACCN =D.JACCN
AND B.SBLOCK = C.SBLOCK
AND D.LUC = &apos;0910&apos;
AND B.SUBPLA = &apos;4100&apos;;
</sectionHeader>
<bodyText confidence="0.9994476">
(We note for the careful reader that &apos;0910&apos; and
&apos;4100&apos; are not misprints, but the discussion of how
such normalization can be automatically achieved
from DBA declarations is outside the scope of the
present paper.)
</bodyText>
<page confidence="0.997937">
54
</page>
<sectionHeader confidence="0.782095" genericHeader="method">
TRANSLATING QUANTIFIED RELATIONAL CALCULUS
EXPRESSIONS TO FORMAL QUERY LANGUAGE EQUIVALENTS
</sectionHeader>
<bodyText confidence="0.999663">
In this section we consider a problem of our own
choosing. In most of the existing relational calcu-
lus formalisms, use is made of logical variables and
some type of universal and existential quantifiers.
Early versions of TQA were typical in this respect.
The version of TQA which was tested in the White
Plains experiment, for example, made use of quanti-
fiers FORATLEAST and FORALL whose nature is best
explained by an examnle. The logical form assigned
to the previously considered sentence was, at one
time:
</bodyText>
<equation confidence="0.9979349375">
(setx &apos;X4
t(foratleast 1 &apos;X112
(setx &apos;X8
&apos;(and
(RELATION &apos;GEOBASE*
T(SUBPLA JACCN)
T410 X8)
&apos;(= =) )
(RELATION ILUCF
T(LUC JACCN)
T910 X8)
&apos;(= =) ) ) )
(RELATION &apos;ZONEF
&apos;(ZONE JACCN)
&apos;(X4 X112)
&apos;(= =) ) ) )
</equation>
<bodyText confidence="0.963055296296296">
This logical form denotes (roughly) the set of zones
X4 such that for at least one element X112 of the set
of parcels X8 which are in subplanning area 410 and
have a land use code of 910, parcel X112 is in zone
X4. In simple examples such as this, where only
existential quantification of logical forms is
involved, there is no problem in translating to a
formal query language such as SQL. However, when
various combinations of existential and universal
quantification are involved in a logical form, the
corresponding quantification-indicating constructs
to be used in the formal query language translation
of that logical form is not at all obvious. An exam-
ination of the literature indicates that the
arguments used in establishing the completeness of
query languages offer little or no guidance as to
the construction of a practical translator from
relational calculus to a formal query language such
as SQL. Hence, the approach used in translating TQA
logical forms to corresponding SQL expressions will
be discussed, in the expectation of eliciting expla-
nations of how the translation of quantification is
handled in other systems.
We begin by observing that a logical form
(foratleast 1 X1
(setx X2 (f X2))
(g XI))
(which denotes the proposition that for at least one
X1 which belongs to the set of elements X2 such that
f(X2) is true, g(X1) is true) is equivalent to the
requirement of the non-emptiness of the set
(1) (setx &apos;Xl &apos;(and (f X1) (g X1)))
Similarly,
(forall X1
(setx X2 (f X2))
(g X1))
(which denotes the proposition that for all X1 in
the set of elements X2 such that f(X2) is true, g(X1)
is true), is equivalent to a requirement of the emp-
tiness of the set
(2) (setx &apos;Xl &apos;(and (f XI) (not (g X1))))
Conversion of expressions with universal and exis-
tential quantifiers is then possible to expressions
involving only set notation and a predicate involv-
ing the emptiness of a set. The latter type of
expressions are called set domain relational calcu-
lus expressions.
Fortunately, SQL provides operators EXISTS and
NOT EXISTS which take as their argument an SQL
SELECT expression, the type of expression into which
logical forms of the type (setx &apos;Xl ) are trans-
lated. A recursive call to the basic logical
form-to-SQL translation facility then suffices to
supply the SQL argument of EXISTS or NOT EXISTS.
It is worth noting that, under certain circum-
stances which we will not explore here, the &amp;quot;(setx
X2&amp;quot; portion of an embedded expression (setx &apos;X2 (f
X2)) can be pulled forward, creating a
prefix-normal-form-like expression of the type (setx
&apos;Xl (setx &apos;X2 )), and the logical variables that
can be pulled all the way forward correspond to
information implicitly requested in English queries.
The values which satisfy these variables should also
be printed to satisfy users&apos; implicit requests for
information. For example, in our previously consid-
ered query
&amp;quot;What are the zones of the vacant parcels in sub-
planning area 410?&amp;quot;
one probably wants the parcels identified in addi-
tion to their zones. Translation to the form of set
domain relational calculus used in TQA then provides
a basis for either taking the initiative in automat-
ically printing these implicitly requested values or
for engaging in a dialog with the user to determine
whether they should be printed.
As a final example of this method of translating
quantified logical forms, consider the sentence
&amp;quot;What gas stations are in a ward in which there is
no drug store?&amp;quot;
The logical form initially assigned by TQA to this
sentence is
</bodyText>
<page confidence="0.984866">
55
</page>
<figure confidence="0.804867485714286">
(setx &apos;X2
&apos;(and
(RELATION &apos;LUCF
I(LUC JACCN)
TO553 X2)
1(= =) )
(foratleast 1 &apos;mil
(setx &apos;X7
(forall &apos;X80
(setx &apos;Xl3
(RELATION &apos;LUCF
f(LUC JACCN)
&apos;(&apos;0591 X13)
&apos;(= =) ) )
(RELATION &apos;PARCFL
&apos;(WARD JACCN)
1(X7 X80)
=) ) ) )
(RELATION &apos;PARCFL
&apos;(WARD JACCN)
&apos;(X81 X2)
=) ) ) ) )
which is translated to the set domain logical form:
(setx &apos;X2
&apos;(setx &apos;X7
&apos;(and
(RELATION &apos;PARCFL
&apos;(WARD JACCN)
&apos;(X7 X2)
&apos;(= =) )
(not
(setx &apos;X13
&apos;(and
(RELATION &apos;PARCFL
&apos;(WARD JACCN)
</figure>
<equation confidence="0.8526863">
I(X7 X13)
&apos;(= =) )
(RELATION &apos;LUCF
t(LUC JACCN)
&apos;(&apos;0591 X13)
l(= ) ) ) )
(RELATION &apos;LUCF
&apos;(LUC JACCN)
TO553 X2)
1(= =) ) ) ) )
</equation>
<bodyText confidence="0.998256">
The latter form translates easily into the SQL
expression:
</bodyText>
<sectionHeader confidence="0.984496909090909" genericHeader="method">
SELECT UNIQUE A.JACCN, A.WARD
FROM PARCFL A, LUCF B
WHERE A.JACCN = B.JACCN
AND B.LUC = &apos;0553&apos;
AND NOT EXISTS
(SELECT UNIQUE C.JACCN
FROM PARCFL C, LUCF D
WHERE C.WARD = A.WARD
AND C.JACCN = D.JACCN
AND D.LUC = &apos;0591&apos;);
REFERENCES
</sectionHeader>
<reference confidence="0.999928516129032">
Astrahan, M.M.; Blasgen, M.W.; Chamberlin, D.D.;
Eswaran, K.P.; Gray, J.N.; Griffiths, P.P.; King,
W.F.; Lories, R.A.; McJones, J.; Mehl, J.W.; Put-
zolu, G.R.; Traiger, I.L.; Wade, B.W.; and
Watson, V., &amp;quot;System R: Relational Approach to
Database Management,&amp;quot; ACM Transactions on Data-
base Systems, Vol. 1, No. 21, June, 1976, pp.
97-137.
Damerau, F.J., &amp;quot;Advantages of a Transformational
Grammar for Question Answering,&amp;quot; Proc. 5th IJCAI,
Vol. 1, 1977, p. 192.
Damerau, F.J., &amp;quot;Operating Statistics for The Trans-
formational Question Answering System,&amp;quot; American
Journal of Computational Linguistics, Vol. 7, No.
1, January-March 1981, pp. 30-42.
Petrick, S. R., &amp;quot;Semantic Interpretation in the
Request System,&amp;quot; in Computational and Mathemat-
ical Linguistics, Proceedings of the Interna-
tional Conference on Computational Linguistics,
Pisa, 27/VIII-1/IX 1973, pp. 585-610.
Petrick, S.R., &amp;quot;On Natural Language Based Computer
Systems,&amp;quot; IBM Journal of Research and
Development, Vol. 20, No. 4, July 1976, pp.
314-325.
Petrick, S.R. &amp;quot;Field Testing the Transformational
Question Answering (TQA) System,&amp;quot; Proc. 19th Ann.
Mtg. of the ACL, June 1981, pp. 35-36.
Plath, W.J., &amp;quot;REQUEST: A Natural Language
Question-Answering System,&amp;quot; IBM Journal of
Research and Development, Vol. 20, No. 4, July
1976, pp. 326-335.
</reference>
<page confidence="0.998423">
56
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.985104">
<title confidence="0.999493">THEORETICAL/TECHNICAL ISSUES IN NATURAL LANGUAGE ACCESS TO DATABASES</title>
<author confidence="0.999997">S R Petrick</author>
<affiliation confidence="0.985606">IBM T.J. Watson Research Center</affiliation>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>M M Astrahan</author>
<author>M W Blasgen</author>
<author>D D Chamberlin</author>
<author>K P Eswaran</author>
<author>J N Gray</author>
<author>P P Griffiths</author>
<author>W F King</author>
<author>R A Lories</author>
<author>J McJones</author>
<author>J W Mehl</author>
<author>G R Putzolu</author>
<author>I L Traiger</author>
<author>B W Wade</author>
<author>V Watson</author>
</authors>
<title>System R: Relational Approach to Database Management,&amp;quot;</title>
<date>1976</date>
<journal>ACM Transactions on Database Systems,</journal>
<volume>1</volume>
<pages>97--137</pages>
<marker>Astrahan, Blasgen, Chamberlin, Eswaran, Gray, Griffiths, King, Lories, McJones, Mehl, Putzolu, Traiger, Wade, Watson, 1976</marker>
<rawString>Astrahan, M.M.; Blasgen, M.W.; Chamberlin, D.D.; Eswaran, K.P.; Gray, J.N.; Griffiths, P.P.; King, W.F.; Lories, R.A.; McJones, J.; Mehl, J.W.; Putzolu, G.R.; Traiger, I.L.; Wade, B.W.; and Watson, V., &amp;quot;System R: Relational Approach to Database Management,&amp;quot; ACM Transactions on Database Systems, Vol. 1, No. 21, June, 1976, pp. 97-137.</rawString>
</citation>
<citation valid="true">
<authors>
<author>F J Damerau</author>
</authors>
<title>Advantages of a Transformational Grammar for Question Answering,&amp;quot;</title>
<date>1977</date>
<booktitle>Proc. 5th IJCAI,</booktitle>
<volume>1</volume>
<pages>192</pages>
<marker>Damerau, 1977</marker>
<rawString>Damerau, F.J., &amp;quot;Advantages of a Transformational Grammar for Question Answering,&amp;quot; Proc. 5th IJCAI, Vol. 1, 1977, p. 192.</rawString>
</citation>
<citation valid="true">
<authors>
<author>F J Damerau</author>
</authors>
<title>Operating Statistics for The Transformational Question Answering System,&amp;quot;</title>
<date>1981</date>
<journal>American Journal of Computational Linguistics,</journal>
<volume>7</volume>
<pages>30--42</pages>
<marker>Damerau, 1981</marker>
<rawString>Damerau, F.J., &amp;quot;Operating Statistics for The Transformational Question Answering System,&amp;quot; American Journal of Computational Linguistics, Vol. 7, No. 1, January-March 1981, pp. 30-42.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S R Petrick</author>
</authors>
<title>Semantic Interpretation in the Request System,&amp;quot;</title>
<date>1973</date>
<booktitle>in Computational and Mathematical Linguistics, Proceedings of the International Conference on Computational Linguistics,</booktitle>
<pages>585--610</pages>
<location>Pisa, 27/VIII-1/IX</location>
<marker>Petrick, 1973</marker>
<rawString>Petrick, S. R., &amp;quot;Semantic Interpretation in the Request System,&amp;quot; in Computational and Mathematical Linguistics, Proceedings of the International Conference on Computational Linguistics, Pisa, 27/VIII-1/IX 1973, pp. 585-610.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S R Petrick</author>
</authors>
<title>On Natural Language Based Computer Systems,&amp;quot;</title>
<date>1976</date>
<journal>IBM Journal of Research and Development,</journal>
<volume>20</volume>
<pages>314--325</pages>
<marker>Petrick, 1976</marker>
<rawString>Petrick, S.R., &amp;quot;On Natural Language Based Computer Systems,&amp;quot; IBM Journal of Research and Development, Vol. 20, No. 4, July 1976, pp. 314-325.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S R Petrick</author>
</authors>
<title>Field Testing the Transformational Question Answering (TQA) System,&amp;quot;</title>
<date>1981</date>
<booktitle>Proc. 19th Ann. Mtg. of the ACL,</booktitle>
<pages>35--36</pages>
<marker>Petrick, 1981</marker>
<rawString>Petrick, S.R. &amp;quot;Field Testing the Transformational Question Answering (TQA) System,&amp;quot; Proc. 19th Ann. Mtg. of the ACL, June 1981, pp. 35-36.</rawString>
</citation>
<citation valid="true">
<authors>
<author>W J Plath</author>
</authors>
<title>REQUEST: A Natural Language Question-Answering System,&amp;quot;</title>
<date>1976</date>
<journal>IBM Journal of Research and Development,</journal>
<volume>20</volume>
<pages>326--335</pages>
<marker>Plath, 1976</marker>
<rawString>Plath, W.J., &amp;quot;REQUEST: A Natural Language Question-Answering System,&amp;quot; IBM Journal of Research and Development, Vol. 20, No. 4, July 1976, pp. 326-335.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>