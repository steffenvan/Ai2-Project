<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.022335">
<title confidence="0.97713">
Speaker-independent context update rules for dialogue management
</title>
<author confidence="0.998541">
Samson de Jager, Nick Wright, Alistair Knott
</author>
<affiliation confidence="0.9989695">
Dept. of Computer Science
University of Otago
</affiliation>
<email confidence="0.99543">
sdejager/nwright/alik@cs.otago.ac.nz
</email>
<sectionHeader confidence="0.995608" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.987168234375">
This paper describes a dialogue manage-
ment system in which an attempt is made
to factor out a declarative theory of con-
text updates in dialogue from a procedural
theory of generating and interpreting ut-
terances in dialogue.
1 Background: declarative and procedural
resources for text processing
In computational linguistics, a very useful distinc-
tion can be drawn between declarative models of
language, which specify what constitutes a ‘correct’
or ‘proper’ sentence or discourse, and procedural
models, which specify how a proper sentence or dis-
course can be interpreted or generated. This distinc-
tion is virtually ubiquitous in computational mod-
els of sentence structure and sentence processing.
In these models, a sentence grammar is a declar-
ative construct, and a sentence parser or sentence
generator consults the grammar in a systematic way
at each iteration in order to interpret or create sen-
tences. The idea of systematicity is very important.
For instance, in a chart parser the process of sentence
parsing is broken down into a sequence of procedu-
ral operations each of which has exactly the same
general form: a search of the set of grammar rules,
and the creation of a new chart edge if the search
is successful. In fact, the benefits of thinking of a
parser as a procedural module consulting a declar-
ative grammatical resource are most clearly seen in
the fact that the procedural component can be ex-
pressed systematically in this way.
The declarative/procedural distinction is also in-
creasingly common in computational treatments of
extended monologues. There are several overtly
declarative theories of the structure of such texts
(many of them stemming from the work of Mann
and Thompson (1988) and Grosz and Sidner
(1986)), and several models of text generation and
text interpretation which make reference to these
declarative theories (see e.g. Hovy (1993) and
Marcu (2000) for a summary of generation and in-
terpretation methods respectively). Again, the most
attractive feature of the declarative/procedural dis-
tinction is that the procedural algorithms envisaged
are very systematic.
In models of dialogue structure, a clean separa-
tion between declarative and procedural models has
proved more elusive. By analogy with the cases of
sentences and monologic discourse just described,
what is required is a declarative model of ‘well-
formed dialogue’, together with procedural mecha-
nisms that consult this model in a systematic way to
produce and interpret contributions to a dialogue.
To begin with, what is a declarative theory of di-
alogue structure? In this paper, we will assume a
theoretical perspective in which dialogue moves are
represented as context-update operations (see e.g.
Traum et al (1999)). An utterance in a dialogue is
understood as a function which (when defined) takes
the current dialogue context and outputs a new dia-
logue context that constitutes the input to the next
utterance in the dialogue. The declarative theory of
dialogue coherence will therefore be a theory about
the legal ways in which the dialogue context can be
</bodyText>
<figure confidence="0.998404">
I’s utterance
interlocutor (I)
utterance
processing
Dialogue
context
B
A
utterance
processing
utterance
interpretation
A
B
utterance
generation
A’s utterance
A C
utterance processing rules
Process A consults data from B
Process A writes data in B
Process A hands control to process C
</figure>
<figureCaption confidence="0.999949">
Figure 1: A model of dialogue management factoring out a declarative component of ‘utterance processing’.
</figureCaption>
<bodyText confidence="0.999017434782609">
updated.1 The question we focus on is: how can we
formulate a model of dialogue processing that makes
reference in a systematic way to this declarative the-
ory?
The difficulty is that ‘dialogue processing’ is not
a uniform activity. There are two very different pro-
cesses involved: one is utterance interpretation, and
the other is utterance generation. An agent par-
ticipating in a dialogue runs these two processes
roughly in alternation. If an algorithm for dialogue
processing is to be systematic in the way discussed
above, we expect it to consult the declarative theory
of context updates in the same way when process-
ing each utterance, whether it is being generated or
interpreted. But is this really possible? The pro-
cess of generating an utterance seems very different
from that of interpreting one. Perhaps most obvi-
ously, when an agent is generating an utterance, it
needs to work out what the content of this utterance
is, while when the agent is interpreting an utterance,
this content is handed to it on a plate, and it simply
has to work out how it is to be incorporated into the
current discourse context.
</bodyText>
<sectionHeader confidence="0.9082685" genericHeader="method">
2 Dialogue management using
speaker-independent resources
</sectionHeader>
<bodyText confidence="0.994968333333333">
This paper describes the dialogue management
scheme implemented in a dialogue system called
Te Kaitito2 (Knott et al., 2002; de Jager et al.,
</bodyText>
<footnote confidence="0.984733">
1Note that there is nothing procedural in the notion of an
update; it is just a way of characterising the meaning of an ut-
terance in a dialogue.
2Te Kaitito is a bilingual system, which supports dialogues
in either English or Maori. Te Kaitito means ‘the extempore
speaker’ or ‘the improviser’.
</footnote>
<bodyText confidence="0.9988286">
2002). In this scheme, an attempt is made to fac-
tor out a speaker-independent component of ut-
terance processing which is the same whether the
utterance is being generated or interpreted from a
speaker-dependent component of utterance pro-
cessing which is completely different for utterance
generation and utterance interpretation. Both of
these types of processing are thought of as opera-
tions which perform updates on the dialogue con-
text. The basic idea is that a speaker-dependent op-
eration is responsible for adding new information
about an utterance and its semantic content to the
dialogue context, while a speaker-independent oper-
ation consults a declarative model of dialogue struc-
ture to further process this information in the light of
what is already in the dialogue context. Imagine an
agent A participating in a dialogue with an interlocu-
tor I. When A is generating an utterance, we pro-
pose that A performs two completely separate opera-
tions. Firstly there is a speaker-dependent operation
of utterance generation, which is performed using
a collection of very procedural and very domain-
specific resources, including A’s current plans and
knowledge of the world. As a consequence of this
operation, a new utterance representation is added
to the dialogue context, and (as a side-effect) A
actually makes an utterance. Secondly, a speaker-
independent operation of utterance processing oc-
curs, in which a set of utterance processing rules
are consulted, and various further changes are made
to the dialogue context. Imagine now that A inter-
prets a response utterance coming from I. There
are again two separate operations. Firstly there is a
speaker-dependent operation of utterance interpre-
tation, involving sentence parsing, syntactic and se-
mantic disambiguation and so on. As a consequence
of this operation, again a new utterance represen-
tation is added to the dialogue context. Secondly,
another speaker-independent operation of utterance
processing occurs, in which exactly the same set of
utterance processing rules are consulted, and further
context updates are made. This picture of dialogue
processing is summarised in Figure 1. In the remain-
der of the paper, this picture will be picture will be
examined in more detail.
</bodyText>
<sectionHeader confidence="0.9113655" genericHeader="method">
3 A DRT-based model of utterances and
dialogue context
</sectionHeader>
<bodyText confidence="0.999911772727273">
The semantics of sentences in Te Kaitito are rep-
resented using Discourse Representation Structures
(DRSs: see (Kamp and Reyle, 1993)), both for sen-
tence generation and sentence interpretation. The
main extension of classical DRT is to incorporate a
treatment of presuppositions along the lines of that
given in van der Sandt (1992). In this treatment,
a sentence is modelled as an assertion DRS and a
set of presupposition DRSs, each of which spec-
ifies information which must be found in the dia-
logue context before the sentence’s assertion can be
further processed. Our system is a modification of
van der Sandt’s, in that presuppositions are used to
model the context-dependence of questions and an-
swers as well as phenomena like definite descrip-
tions and anaphora (see de Jager et al. (2002) for
some motivation for this idea, and see Section 5 for
some examples).
The dialogue context in Te Kaitito is also repre-
sented as a DRS, with additional extensions roughly
along the lines of Poesio and Traum (1998). The
main extension is the idea of a discourse unit, which
is a sub-DRS gathering all of the semantic informa-
tion expressed in a single utterance by one of the
dialogue participants, the whole of which is treated
as a first-class object to which other predicates can
apply (e.g. asserts(speaker, U1)). This idea of
discourse units is also adopted in the MIDAS sys-
tem (Bos and Gabsdil, 2000). The other extension
of classical DRT (also following Poesio and Traum)
is that the dialogue context is modelled as a pair
of DRSs: a common ground DRS containing facts
which are mutually believed, and a stack DRS con-
taining ungrounded information (questions which
have not been fully answered, assertions which have
not been acknowledged, and so on). The stack DRS
is actually a sub-DRS of the common ground DRS
in our implementation, capturing the idea that refer-
ents within the common ground are available within
the stack DRS, but not vice versa.
Our model differs from that of Poesio and Traum
in one fairly small respect, because we also envis-
age a role for discourse units in text planning. One
of the functions of a dialogue in our system is to al-
low a user to author a knowledge base of facts that
serves as input to a text planning system (Knott and
Wright, 2003). A text planner needs to be able to
partition its knowledge base into ‘utterance-sized’
sets of facts, which can then be structured into larger
texts in various ways. It is very useful if the system
can remember how the user performed these parti-
tions during the authoring dialogue. The discourse
units of Poesio and Traum seem almost tailor-made
for this purpose. However, not all of the predicates
inside a discourse unit should be retained in these
cached utterances. Some predicates are only present
in a sentence because they feature in referring ex-
pressions; since referring expressions will be differ-
ent depending on the context in which they are pro-
duced, we need a separate context-specific routine
to add these predicates to the semantics of an utter-
ance when a sentence is to be produced. See Knott
and Wright (2003) for more details about how these
cached utterances are obtained and used.
An example of a dialogue context is given in Fig-
ure 2. This is how the context would appear after the
</bodyText>
<figure confidence="0.808792">
Common ground DRS
U1,X1,X2
</figure>
<figureCaption confidence="0.999513">
Figure 2: A simple dialogue context
</figureCaption>
<bodyText confidence="0.999084833333333">
interlocutor I has uttered the sentence A cat was in
a house, and the agent A has successfully added this
information to the common ground. Note first that
the stack DRS is empty. Note also that the predicates
cat(X1) and house(X2) have been moved from the
utterance unit U1 into the top level of the common
</bodyText>
<equation confidence="0.9056854">
cat(X1)
house(X2)
Stack DRS
U1:
in(X1,X2)
</equation>
<bodyText confidence="0.999968222222222">
ground, while the actual predication associated with
this sentence stays in the utterance. This ‘unloading’
of material into the top-level DRS is superficially
similar to the operation performed in MIDAS sys-
tem for grounding an utterance. But in our case its
function is purely to do with the text-planning appli-
cation, and has nothing to do with making referents
accessible. We assume all material inside utterance
units is accessible as if it were in the outer DRS.
</bodyText>
<sectionHeader confidence="0.949787" genericHeader="method">
4 Utterance processing rules
</sectionHeader>
<bodyText confidence="0.999636257142857">
In the top-level control loop of the dialogue man-
ager described in Section 2, when an utterance is
interpreted or generated (using speaker-specific pro-
cesses), a new utterance representation is added
to the stack DRS. An utterance representation con-
sists of a discourse unit as described in Section 3,
plus two kinds of predicate about the utterance rep-
resented by this unit: firstly a predicate specifying
what dialogue act it performs, and secondly predi-
cates specifying which variables it contains. After
this comes the speaker-independent operation of ut-
terance processing introduced in Section 2.
Utterance processing is modelled as a cyclical
process of applying context update rules, in the kind
of way envisaged in the MIDAS system (Bos and
Gabsdil, 2000). An utterance processing rule con-
tains a condition to look for in the dialogue context,
and an action, which is an update operation on the
context. At each cycle, the set of rules is searched,
and the first rule whose condition matches has its
action executed. The cycle is repeated until no rules
trigger.
There is no reason a priori why speaker-
independent context update operations need be ap-
plied cyclically by a rule interpreter. But there are
several reasons why one might want to use a cycli-
cal scheme. For Bos and Gabsdil (2000), the pri-
mary reason is that updating the context involves a
great deal of reasoning, and can in fact be construed
as a kind of reasoning. Reasoning is naturally mod-
elled as the cyclical application of rules of inference,
and hence a cyclical framework for updates seems
quite natural. In our system, however, the dialogue
manager does not invoke a general-purpose theorem
prover.3 We use a cyclical scheme for several sepa-
</bodyText>
<footnote confidence="0.913681">
3While this is of course limiting for a practical system, we
</footnote>
<bodyText confidence="0.998504235294118">
rate reasons.
Firstly, there are dialogue moves which decom-
pose naturally into sequences of smaller moves,
some of which can also be made individually. For
instance, an acknowledgement can be given explic-
itly (using an utterance like Okay), or implicitly, by
making a new forward-looking utterance. It makes
sense to model the implicit acknowledgement in this
latter case using the same rule used to model the ex-
plicit one. To do this requires a cyclical scheme for
making context updates.
Secondly, there are dialogue moves which decom-
pose into sub-moves which have specific verbal and
nonverbal reflexes. For instance, when a speaker is
processing an incoming question utterance, she first
of all has to recognise that it is a question. When
this happens, the agent might furrow her brow, or
utter a filler like Hmm!, and only after some time ac-
tually respond to the question. Such actions are con-
veniently modelled as overt side-effects of the appli-
cation of cyclical context-update rules.4
Perhaps most importantly, the cyclical applica-
tion of context-update rules has the same kind of
systematicity as is found in the operation of a sen-
tence parser or a sentence generator. In Section 1 it
was argued that the benefits of a separation between
declarative and procedural resources are largely due
to the systematic iterative or procedural recursive al-
gorithms which this separation permits. Our sug-
gestion is to think of the set of utterance-processing
rules as a declarative theory of ‘legal dialogue con-
text updates’, and to think of the rule interpreter cy-
cling on these rules as the dialogue equivalent of a
sentence generation algorithm.
</bodyText>
<sectionHeader confidence="0.984103" genericHeader="method">
5 A simple worked example
</sectionHeader>
<bodyText confidence="0.972540166666667">
In this section, we will give some examples of the
utterance processing rules used in Te Kaitito’s dia-
logue manager, and explain how they are used. The
examples relate to the very simple dialogue given in
Figure 3. After the first two utterances, the dialogue
context will be the one which was shown in Figure 2.
</bodyText>
<footnote confidence="0.910272666666667">
feel that architectures for dialogue management can be studied
relatively independently from issues to do with general-purpose
reasoning techniques.
4Te Kaitito has in fact been used as the back-end of an an-
imated conversational agent which performs a few simple non-
verbal strategies of this kind. For details see (King et al., 2003).
</footnote>
<figure confidence="0.996703066666667">
Common ground DRS
U1,X1,X2
cat(X1) Stack DRS
house(X2) U2
U1: U2:
in(X1,X2)
barked(X1)
var− assertion−
act(U2)
inside(X1, U2)
We take up the story when the agent’s interlocutor I
1 I A cat was in a house
2 A Okay
3 I The cat barked
4 A Okay
</figure>
<figureCaption confidence="0.998471">
Figure 3: An example dialogue
makes the second assertion. After this utterance has
been interpreted, the dialogue context is as shown in
Figure 4. Basically, a new sentence DRS has arrived
</figureCaption>
<figure confidence="0.9603355">
Common ground DRS
U1,X1,X2
</figure>
<figureCaption confidence="0.999652">
Figure 4: Context after interpretation of Utterance 3
</figureCaption>
<bodyText confidence="0.999872">
in the stack DRS. Note that the sentence contains a
presupposition DRS, which is given in dashed lines.
Note also the predicates specifying the dialogue act
performed by the utterance (which in this case is de-
rived from the syntax of the sentence), and detailing
which variables are mentioned in it.
Speaker-independent utterance processing rules
now fire. The first rule to fire in this case is a rule
which attempts to resolve the presuppositions of the
utterance. (Recall that presupposition resolution is
considered part of dialogue management rather than
simple sentence interpretation; again see de Jager et
al. (2002) for details.) After presupposition reso-
lution, the context is as shown in Figure 5; the pre-
supposition box disappears, and the variable x1 is
bound to X1. In fact, no further utterance process-
ing rules will fire in this cycle.
A speaker-specific process of response generation
is now invoked. In this case, the process specifies
that an assertion whose presuppositions have been
fully resolved should be acknowledged, and conse-
quently an acknowledgement is given to the speaker.
A semantic representation of this acknowledgement
</bodyText>
<figureCaption confidence="0.926314">
Figure 5: Context after processing of Utterance 3
sentence is added to the stack DRS, as shown in
Figure 6. Notice that an acknowledgement is rep-
resented semantically as presupposing a forward-
looking dialogue act. (In Te Kaitito’s type hierarchy,
an assertion is one such act.)
</figureCaption>
<figure confidence="0.9604055">
Common ground DRS
U1,X1,X2
</figure>
<figureCaption confidence="0.999767">
Figure 6: Context after generation of Utterance 4
</figureCaption>
<bodyText confidence="0.999942714285714">
The agent has now uttered the acknowledgement;
it remains for it to bring its dialogue context up
to date, using the same utterance processing rules
as are used when processing the interlocutor’s ut-
terance. The first rule is presupposition resolution
again. Crucially, the same presupposition resolu-
tion routine is invoked now as was invoked when the
interlocutor’s assertion was being processed. After
this routine, the presupposed forward-looking dia-
logue act is bound to the assertion utterance (which
in Te Kaitito’s type hierarchy is a type of forward-
looking act), the presupposition box is removed, and
an explicit statement of the relationship between the
assertion U2 and the acknowledgement U3 is added.
</bodyText>
<figure confidence="0.950615580645161">
cat(X1)
house(X2) Stack DRS
in(X1,X2)
U1:
U2
U2:
barked(x1)
x1
cat(x1)
assertion−act(U2)
var−inside(x1, U2)
Stack DRS
U2
U2:
barked(X1)
assertion−act(U2)
var−inside(x1, U2)
U3
U3: acknowledgement−
x1
forward−act(x1)
act(U3)
cat(X1)
house(X2)
U1:
in(X1,X2)
The dialogue context is now as shown in Figure 7.
An example dialogue to illustrate this alternative
pattern is given in Figure 9. During the course of
Common ground DRS
U1,X1,X2
</figure>
<figureCaption confidence="0.999934">
Figure 7: Context after processing Utterance 4 (1)
</figureCaption>
<bodyText confidence="0.9551135">
Finally, a second utterance-processing rule re-
moves the acknowledgement altogether and trans-
fers the assertion U2 to the common ground, as
shown in Figure 8.
</bodyText>
<figure confidence="0.8730185">
Common ground DRS
U1,X1,X2, U2
</figure>
<figureCaption confidence="0.99871">
Figure 8: Context after processing Utterance 4 (2)
</figureCaption>
<sectionHeader confidence="0.999499" genericHeader="discussions">
6 Discussion
</sectionHeader>
<bodyText confidence="0.999924384615385">
The important thing about the example just worked
through is that the utterance-processing rules which
operate after each utterance is added to the stack
would work in just the same way if the agent had
been making an assertion and the interlocutor had
been acknowledging it. The Te Kaitito system is
able to generate assertions as well as interpret them,
and is able to interpret acknowledgements as well
as generate them. For instance, if the user asks a
question, the system has to answer it with an as-
sertive statement, and it has to be able to interpret an
acknowledgement of this answer (whether the user
gives this explicitly, or implicitly).
</bodyText>
<figure confidence="0.804105">
5 I Which cat barked?
6 A It was the blue cat.
7 I Okay.
</figure>
<figureCaption confidence="0.998122">
Figure 9: Dialogue with an acknowledgement by I
</figureCaption>
<bodyText confidence="0.999959695652174">
this dialogue, the utterance processing rules which
update the dialogue context after the system’s asser-
tion (Utterance 6) are the same as those which up-
date the dialogue context after the assertion by the
user in Utterance 3 of Figure 3. And the utterance
processing rules which update the context after the
user’s acknowledgement (Utterance 7) are the same
as the rules which update the context after the sys-
tem’s acknowledgement of the user’s assertion in
Utterance 4 of Figure 3. The process of generating
an assertion is quite different from that of interpret-
ing one, as emphasised in Section 1, and the same
goes for the processes of interpreting and generating
an acknowledgement, but what this system attempts
to do is to factor out the components of these two
operations which are the same, and which just con-
cern how the semantic specification of an incoming
utterance can be incorporated into the current dia-
logue context. To the extent that this is possible,
an attractive separation can be achieved between a
declarative (rule-based) theory of context updates in
dialogue and a procedural theory of utterance inter-
pretation and generation.
</bodyText>
<sectionHeader confidence="0.998997" genericHeader="acknowledgments">
7 Acknowledgements
</sectionHeader>
<bodyText confidence="0.99971">
This work was funded by University of Otago Re-
search Grant MFHB10, and by the NZ Founda-
tion for Research in Science &amp; Technology grant
UOOX02.
</bodyText>
<sectionHeader confidence="0.999463" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999064571428571">
J Bos and M Gabsdil. 2000. First-order inference and the
interpretation of questions and answers. In Proceed-
ings of Gotalog 2000. Fourth Workshop on the Seman-
tics and Pragmatics ofDialogue., pages 43–50.
S de Jager, A Knott, and I Bayard. 2002. A DRT-based
framework for presuppositions in dialogue manage-
ment. In Proceedings of the 6th workshop on the se-
</reference>
<figure confidence="0.9985968">
cat(X1) Stack DRS
U2
U2:
barked(X1)
assertion−act(U2)
var−inside(X1, U2)
U3
U3: acknowl’ment− of(U3, U2)
house(X2)
U1: in(X1,X2)
Stack DRS
barked(X1)
cat(X1)
house(X2)
in(X1,X2)
</figure>
<reference confidence="0.991601071428572">
mantics and pragmatics of dialogue (EDILOG 2002),
Edinburgh.
B J Grosz and C L Sidner. 1986. Attention, intentions,
and the structure of discourse. Computational Lin-
guistics, pages 175–203.
E Hovy. 1993. Automated discourse generation using
discourse structure relations. Artificial Intelligence,
63:341–385.
H Kamp and U Reyle. 1993. From discourse to logic.
Kluwer Academic Publishers, Dordrecht.
S King, A Knott, and B McCane. 2003. Language-
driven nonverbal communication in a bilingual con-
versational agent. In Proceedings of the 16th Interna-
tional Conference on Computer Animation and Social
Agents (CASA).
A Knott and N Wright. 2003. A dialogue-based knowl-
edge authoring system for text generation. In AAAI
Spring Symposium on Natural Language Generation
in Spoken and Written Dialogue, Stanford, CA.
A Knott, I Bayard, S de Jager, and N Wright. 2002. An
architecture for bilingual and bidirectional nlp. In Pro-
ceedings of the 2nd Australasian Natural Language
Processing Workshop (ANLP 2002).
W C Mann and S A Thompson. 1988. Rhetorical
structure theory: A theory of text organization. Text,
8(3):243–281.
D Marcu. 2000. The Theory and Practice of Discourse
Parsing and Summarization. MIT Press, Cambridge,
MA.
M Poesio and D Traum. 1998. Towards an axiomati-
zation of dialogue acts. In J Hulstijn and A Nijholt,
editors, Proceedings of the Twente Workshop on the
Formal Semantics and Pragmatics of Dialogues (13th
Twente Workshop on Language Technology), pages
207–222.
D Traum, Bos J, R Cooper, S Larsson, I Lewin, C Mathe-
son, and M Poesio. 1999. A model of dialogue moves
and information state revision. TRINDI project deliv-
erable.
R Van der Sandt. 1992. Presupposition projection as
anaphora resolution. Journal of Semantics, 9:333–
377.
</reference>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.000180">
<title confidence="0.996748">Speaker-independent context update rules for dialogue management</title>
<author confidence="0.997306">Samson de_Jager</author>
<author confidence="0.997306">Nick Wright</author>
<author confidence="0.997306">Alistair</author>
<affiliation confidence="0.9990165">Dept. of Computer University of</affiliation>
<email confidence="0.88154">sdejager/nwright/alik@cs.otago.ac.nz</email>
<abstract confidence="0.983224130952381">This paper describes a dialogue management system in which an attempt is made to factor out a declarative theory of context updates in dialogue from a procedural theory of generating and interpreting utterances in dialogue. 1 Background: declarative and procedural resources for text processing In computational linguistics, a very useful distinction can be drawn between declarative models of language, which specify what constitutes a ‘correct’ or ‘proper’ sentence or discourse, and procedural models, which specify how a proper sentence or discourse can be interpreted or generated. This distinction is virtually ubiquitous in computational models of sentence structure and sentence processing. In these models, a sentence grammar is a declarative construct, and a sentence parser or sentence generator consults the grammar in a systematic way at each iteration in order to interpret or create sentences. The idea of systematicity is very important. For instance, in a chart parser the process of sentence parsing is broken down into a sequence of procedural operations each of which has exactly the same general form: a search of the set of grammar rules, and the creation of a new chart edge if the search is successful. In fact, the benefits of thinking of a parser as a procedural module consulting a declarative grammatical resource are most clearly seen in the fact that the procedural component can be expressed systematically in this way. The declarative/procedural distinction is also increasingly common in computational treatments of extended monologues. There are several overtly declarative theories of the structure of such texts (many of them stemming from the work of Mann and Thompson (1988) and Grosz and Sidner (1986)), and several models of text generation and text interpretation which make reference to these declarative theories (see e.g. Hovy (1993) and Marcu (2000) for a summary of generation and interpretation methods respectively). Again, the most attractive feature of the declarative/procedural distinction is that the procedural algorithms envisaged are very systematic. In models of dialogue structure, a clean separation between declarative and procedural models has proved more elusive. By analogy with the cases of sentences and monologic discourse just described, what is required is a declarative model of ‘wellformed dialogue’, together with procedural mechanisms that consult this model in a systematic way to produce and interpret contributions to a dialogue. To begin with, what is a declarative theory of dialogue structure? In this paper, we will assume a theoretical perspective in which dialogue moves are represented as context-update operations (see e.g. al An utterance in a dialogue is understood as a function which (when defined) takes the current dialogue context and outputs a new dialogue context that constitutes the input to the next utterance in the dialogue. The declarative theory of dialogue coherence will therefore be a theory about the legal ways in which the dialogue context can be I’s utterance interlocutor (I) utterance processing Dialogue context B A utterance processing utterance interpretation A B utterance generation A’s utterance A C utterance processing rules</abstract>
<title confidence="0.818245666666667">Process A consults data from B Process A writes data in B Process A hands control to process C</title>
<abstract confidence="0.996661720472441">Figure 1: A model of dialogue management factoring out a declarative component of ‘utterance processing’. The question we focus on is: how can we a model of dialogue makes reference in a systematic way to this declarative theory? The difficulty is that ‘dialogue processing’ is not a uniform activity. There are two very different processes involved: one is utterance interpretation, and the other is utterance generation. An agent participating in a dialogue runs these two processes roughly in alternation. If an algorithm for dialogue processing is to be systematic in the way discussed above, we expect it to consult the declarative theory of context updates in the same way when processing each utterance, whether it is being generated or interpreted. But is this really possible? The process of generating an utterance seems very different from that of interpreting one. Perhaps most obviously, when an agent is generating an utterance, it needs to work out what the content of this utterance is, while when the agent is interpreting an utterance, this content is handed to it on a plate, and it simply has to work out how it is to be incorporated into the current discourse context. 2 Dialogue management using speaker-independent resources This paper describes the dialogue management scheme implemented in a dialogue system called (Knott et al., 2002; de Jager et al., that there is nothing procedural in the notion of an update; it is just a way of characterising the meaning of an utterance in a dialogue. Kaitito is a bilingual system, which supports dialogues either English or Maori. Kaitito ‘the extempore speaker’ or ‘the improviser’. 2002). In this scheme, an attempt is made to facout a of utterance processing which is the same whether the utterance is being generated or interpreted from a of utterance processing which is completely different for utterance generation and utterance interpretation. Both of these types of processing are thought of as operations which perform updates on the dialogue context. The basic idea is that a speaker-dependent operation is responsible for adding new information about an utterance and its semantic content to the dialogue context, while a speaker-independent operation consults a declarative model of dialogue structure to further process this information in the light of what is already in the dialogue context. Imagine an in a dialogue with an interlocu- When generating an utterance, we prothat two completely separate operations. Firstly there is a speaker-dependent operation which is performed using a collection of very procedural and very domainresources, including current plans and knowledge of the world. As a consequence of this a new representation added the dialogue context, and (as a side-effect) actually makes an utterance. Secondly, a speakeroperation of processing ocin which a set of processing rules are consulted, and various further changes are made the dialogue context. Imagine now that intera response utterance coming from There are again two separate operations. Firstly there is a operation of interpreinvolving sentence parsing, syntactic and semantic disambiguation and so on. As a consequence of this operation, again a new utterance representation is added to the dialogue context. Secondly, speaker-independent operation of in which exactly the same set of utterance processing rules are consulted, and further context updates are made. This picture of dialogue processing is summarised in Figure 1. In the remainder of the paper, this picture will be picture will be examined in more detail. 3 A DRT-based model of utterances and dialogue context The semantics of sentences in Te Kaitito are represented using Discourse Representation Structures (DRSs: see (Kamp and Reyle, 1993)), both for sentence generation and sentence interpretation. The main extension of classical DRT is to incorporate a treatment of presuppositions along the lines of that given in van der Sandt (1992). In this treatment, sentence is modelled as an DRS a of each of which specifies information which must be found in the dialogue context before the sentence’s assertion can be further processed. Our system is a modification of van der Sandt’s, in that presuppositions are used to model the context-dependence of questions and answers as well as phenomena like definite descripand anaphora (see de Jager al. for some motivation for this idea, and see Section 5 for some examples). The dialogue context in Te Kaitito is also represented as a DRS, with additional extensions roughly along the lines of Poesio and Traum (1998). The extension is the idea of a which is a sub-DRS gathering all of the semantic information expressed in a single utterance by one of the dialogue participants, the whole of which is treated as a first-class object to which other predicates can (e.g. This idea of discourse units is also adopted in the MIDAS system (Bos and Gabsdil, 2000). The other extension of classical DRT (also following Poesio and Traum) that the dialogue context is modelled as a DRSs: a ground DRS facts are mutually believed, and a DRS con- (questions which have not been fully answered, assertions which have not been acknowledged, and so on). The stack DRS is actually a sub-DRS of the common ground DRS in our implementation, capturing the idea that referents within the common ground are available within the stack DRS, but not vice versa. Our model differs from that of Poesio and Traum in one fairly small respect, because we also envisage a role for discourse units in text planning. One of the functions of a dialogue in our system is to allow a user to author a knowledge base of facts that serves as input to a text planning system (Knott and Wright, 2003). A text planner needs to be able to partition its knowledge base into ‘utterance-sized’ sets of facts, which can then be structured into larger texts in various ways. It is very useful if the system can remember how the user performed these partitions during the authoring dialogue. The discourse units of Poesio and Traum seem almost tailor-made for this purpose. However, not all of the predicates inside a discourse unit should be retained in these cached utterances. Some predicates are only present in a sentence because they feature in referring expressions; since referring expressions will be different depending on the context in which they are produced, we need a separate context-specific routine to add these predicates to the semantics of an utterance when a sentence is to be produced. See Knott and Wright (2003) for more details about how these cached utterances are obtained and used. An example of a dialogue context is given in Figure 2. This is how the context would appear after the Common ground DRS U1,X1,X2 Figure 2: A simple dialogue context uttered the sentence cat was in and the agent successfully added this information to the common ground. Note first that the stack DRS is empty. Note also that the predicates been moved from the unit the top level of the common cat(X1) house(X2) Stack DRS U1: in(X1,X2) ground, while the actual predication associated with this sentence stays in the utterance. This ‘unloading’ of material into the top-level DRS is superficially similar to the operation performed in MIDAS system for grounding an utterance. But in our case its function is purely to do with the text-planning application, and has nothing to do with making referents accessible. We assume all material inside utterance units is accessible as if it were in the outer DRS. 4 Utterance processing rules In the top-level control loop of the dialogue manager described in Section 2, when an utterance is interpreted or generated (using speaker-specific proa new representation added to the stack DRS. An utterance representation consists of a discourse unit as described in Section 3, plus two kinds of predicate about the utterance represented by this unit: firstly a predicate specifying what dialogue act it performs, and secondly predicates specifying which variables it contains. After this comes the speaker-independent operation of utterance processing introduced in Section 2. Utterance processing is modelled as a cyclical process of applying context update rules, in the kind of way envisaged in the MIDAS system (Bos and 2000). An processing rule cona look for in the dialogue context, an which is an update operation on the context. At each cycle, the set of rules is searched, and the first rule whose condition matches has its action executed. The cycle is repeated until no rules trigger. is no reason priori speakerindependent context update operations need be applied cyclically by a rule interpreter. But there are several reasons why one might want to use a cyclical scheme. For Bos and Gabsdil (2000), the primary reason is that updating the context involves a great deal of reasoning, and can in fact be construed as a kind of reasoning. Reasoning is naturally modelled as the cyclical application of rules of inference, and hence a cyclical framework for updates seems quite natural. In our system, however, the dialogue manager does not invoke a general-purpose theorem We use a cyclical scheme for several sepathis is of course limiting for a practical system, we rate reasons. Firstly, there are dialogue moves which decompose naturally into sequences of smaller moves, some of which can also be made individually. For instance, an acknowledgement can be given explic- (using an utterance like or implicitly, by making a new forward-looking utterance. It makes sense to model the implicit acknowledgement in this latter case using the same rule used to model the explicit one. To do this requires a cyclical scheme for making context updates. Secondly, there are dialogue moves which decompose into sub-moves which have specific verbal and nonverbal reflexes. For instance, when a speaker is processing an incoming question utterance, she first of all has to recognise that it is a question. When this happens, the agent might furrow her brow, or a filler like and only after some time actually respond to the question. Such actions are conveniently modelled as overt side-effects of the appliof cyclical context-update Perhaps most importantly, the cyclical application of context-update rules has the same kind of systematicity as is found in the operation of a sentence parser or a sentence generator. In Section 1 it was argued that the benefits of a separation between declarative and procedural resources are largely due to the systematic iterative or procedural recursive algorithms which this separation permits. Our suggestion is to think of the set of utterance-processing rules as a declarative theory of ‘legal dialogue context updates’, and to think of the rule interpreter cycling on these rules as the dialogue equivalent of a sentence generation algorithm. 5 A simple worked example In this section, we will give some examples of the utterance processing rules used in Te Kaitito’s dialogue manager, and explain how they are used. The examples relate to the very simple dialogue given in Figure 3. After the first two utterances, the dialogue context will be the one which was shown in Figure 2. feel that architectures for dialogue management can be studied relatively independently from issues to do with general-purpose reasoning techniques. Kaitito has in fact been used as the back-end of an animated conversational agent which performs a few simple non-</abstract>
<note confidence="0.795084181818182">verbal strategies of this kind. For details see (King et al., 2003). Common ground DRS U1,X1,X2 cat(X1) Stack DRS house(X2) U2 U1: U2: in(X1,X2) barked(X1) var− assertion− act(U2) inside(X1, U2)</note>
<abstract confidence="0.979314879310345">take up the story when the agent’s interlocutor 1 I A cat was in a house 2 A Okay 3 I The cat barked 4 A Okay Figure 3: An example dialogue makes the second assertion. After this utterance has been interpreted, the dialogue context is as shown in Figure 4. Basically, a new sentence DRS has arrived Common ground DRS U1,X1,X2 Figure 4: Context after interpretation of Utterance 3 in the stack DRS. Note that the sentence contains a presupposition DRS, which is given in dashed lines. Note also the predicates specifying the dialogue act performed by the utterance (which in this case is derived from the syntax of the sentence), and detailing which variables are mentioned in it. Speaker-independent utterance processing rules now fire. The first rule to fire in this case is a rule which attempts to resolve the presuppositions of the utterance. (Recall that presupposition resolution is considered part of dialogue management rather than sentence interpretation; again see de Jager for details.) After presupposition resolution, the context is as shown in Figure 5; the prebox disappears, and the variable to In fact, no further utterance processing rules will fire in this cycle. A speaker-specific process of response generation is now invoked. In this case, the process specifies that an assertion whose presuppositions have been fully resolved should be acknowledged, and consequently an acknowledgement is given to the speaker. A semantic representation of this acknowledgement Figure 5: Context after processing of Utterance 3 sentence is added to the stack DRS, as shown in Figure 6. Notice that an acknowledgement is represented semantically as presupposing a forwardlooking dialogue act. (In Te Kaitito’s type hierarchy, an assertion is one such act.) Common ground DRS U1,X1,X2 Figure 6: Context after generation of Utterance 4 The agent has now uttered the acknowledgement; it remains for it to bring its dialogue context up to date, using the same utterance processing rules as are used when processing the interlocutor’s utterance. The first rule is presupposition resolution again. Crucially, the same presupposition resolution routine is invoked now as was invoked when the interlocutor’s assertion was being processed. After this routine, the presupposed forward-looking dialogue act is bound to the assertion utterance (which in Te Kaitito’s type hierarchy is a type of forwardlooking act), the presupposition box is removed, and an explicit statement of the relationship between the assertion U2 and the acknowledgement U3 is added.</abstract>
<note confidence="0.958607548387097">cat(X1) house(X2) Stack DRS in(X1,X2) U1: U2 U2: barked(x1) x1 cat(x1) assertion−act(U2) var−inside(x1, U2) Stack DRS U2 U2: barked(X1) assertion−act(U2) var−inside(x1, U2) U3 U3: acknowledgement− x1 forward−act(x1) act(U3) cat(X1) house(X2) U1: in(X1,X2) The dialogue context is now as shown in Figure 7. An example dialogue to illustrate this alternative pattern is given in Figure 9. During the course of Common ground DRS U1,X1,X2 Figure 7: Context after processing Utterance 4 (1)</note>
<abstract confidence="0.994797645833334">Finally, a second utterance-processing rule removes the acknowledgement altogether and transfers the assertion U2 to the common ground, as shown in Figure 8. Common ground DRS U1,X1,X2, U2 Figure 8: Context after processing Utterance 4 (2) 6 Discussion The important thing about the example just worked through is that the utterance-processing rules which operate after each utterance is added to the stack would work in just the same way if the agent had been making an assertion and the interlocutor had been acknowledging it. The Te Kaitito system is able to generate assertions as well as interpret them, and is able to interpret acknowledgements as well as generate them. For instance, if the user asks a question, the system has to answer it with an assertive statement, and it has to be able to interpret an acknowledgement of this answer (whether the user gives this explicitly, or implicitly). 5 I Which cat barked? 6 A It was the blue cat. 7 I Okay. 9: Dialogue with an acknowledgement by this dialogue, the utterance processing rules which update the dialogue context after the system’s assertion (Utterance 6) are the same as those which update the dialogue context after the assertion by the user in Utterance 3 of Figure 3. And the utterance processing rules which update the context after the user’s acknowledgement (Utterance 7) are the same as the rules which update the context after the system’s acknowledgement of the user’s assertion in Utterance 4 of Figure 3. The process of generating an assertion is quite different from that of interpreting one, as emphasised in Section 1, and the same goes for the processes of interpreting and generating an acknowledgement, but what this system attempts to do is to factor out the components of these two operations which are the same, and which just concern how the semantic specification of an incoming utterance can be incorporated into the current dialogue context. To the extent that this is possible, an attractive separation can be achieved between a declarative (rule-based) theory of context updates in dialogue and a procedural theory of utterance interpretation and generation.</abstract>
<note confidence="0.971352433333333">7 Acknowledgements This work was funded by University of Otago Research Grant MFHB10, and by the NZ Foundation for Research in Science &amp; Technology grant UOOX02. References J Bos and M Gabsdil. 2000. First-order inference and the of questions and answers. In Proceedings of Gotalog 2000. Fourth Workshop on the Semanand Pragmatics pages 43–50. S de Jager, A Knott, and I Bayard. 2002. A DRT-based framework for presuppositions in dialogue manage- In of the 6th workshop on the secat(X1) Stack DRS U2 U2: barked(X1) assertion−act(U2) var−inside(X1, U2) U3 U3: acknowl’ment− of(U3, U2) house(X2) U1: in(X1,X2) Stack DRS barked(X1) cat(X1) house(X2) in(X1,X2) and pragmatics of dialogue (EDILOG Edinburgh. B J Grosz and C L Sidner. 1986. Attention, intentions,</note>
<abstract confidence="0.67756975">the structure of discourse. Linpages 175–203. E Hovy. 1993. Automated discourse generation using structure relations.</abstract>
<note confidence="0.8556106875">63:341–385. Kamp and U Reyle. 1993. discourse to Kluwer Academic Publishers, Dordrecht. S King, A Knott, and B McCane. 2003. Languagedriven nonverbal communication in a bilingual conagent. In of the 16th International Conference on Computer Animation and Social A Knott and N Wright. 2003. A dialogue-based knowlauthoring system for text generation. In Spring Symposium on Natural Language Generation Spoken and Written Stanford, CA. A Knott, I Bayard, S de Jager, and N Wright. 2002. An for bilingual and bidirectional nlp. In Proceedings of the 2nd Australasian Natural Language Workshop (ANLP W C Mann and S A Thompson. 1988. Rhetorical</note>
<abstract confidence="0.909398777777778">theory: A theory of text organization. 8(3):243–281. Marcu. 2000. Theory and Practice of Discourse and MIT Press, Cambridge, MA. M Poesio and D Traum. 1998. Towards an axiomatization of dialogue acts. In J Hulstijn and A Nijholt, of the Twente Workshop on the Formal Semantics and Pragmatics of Dialogues (13th Workshop on Language pages 207–222. D Traum, Bos J, R Cooper, S Larsson, I Lewin, C Matheson, and M Poesio. 1999. A model of dialogue moves and information state revision. TRINDI project deliverable. R Van der Sandt. 1992. Presupposition projection as resolution. of 9:333– 377.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>J Bos</author>
<author>M Gabsdil</author>
</authors>
<title>First-order inference and the interpretation of questions and answers.</title>
<date>2000</date>
<booktitle>In Proceedings of Gotalog 2000. Fourth Workshop on the Semantics and Pragmatics ofDialogue.,</booktitle>
<pages>43--50</pages>
<contexts>
<context position="8974" citStr="Bos and Gabsdil, 2000" startWordPosition="1437" endWordPosition="1440">r et al. (2002) for some motivation for this idea, and see Section 5 for some examples). The dialogue context in Te Kaitito is also represented as a DRS, with additional extensions roughly along the lines of Poesio and Traum (1998). The main extension is the idea of a discourse unit, which is a sub-DRS gathering all of the semantic information expressed in a single utterance by one of the dialogue participants, the whole of which is treated as a first-class object to which other predicates can apply (e.g. asserts(speaker, U1)). This idea of discourse units is also adopted in the MIDAS system (Bos and Gabsdil, 2000). The other extension of classical DRT (also following Poesio and Traum) is that the dialogue context is modelled as a pair of DRSs: a common ground DRS containing facts which are mutually believed, and a stack DRS containing ungrounded information (questions which have not been fully answered, assertions which have not been acknowledged, and so on). The stack DRS is actually a sub-DRS of the common ground DRS in our implementation, capturing the idea that referents within the common ground are available within the stack DRS, but not vice versa. Our model differs from that of Poesio and Traum </context>
<context position="12526" citStr="Bos and Gabsdil, 2000" startWordPosition="2038" endWordPosition="2041">ecific processes), a new utterance representation is added to the stack DRS. An utterance representation consists of a discourse unit as described in Section 3, plus two kinds of predicate about the utterance represented by this unit: firstly a predicate specifying what dialogue act it performs, and secondly predicates specifying which variables it contains. After this comes the speaker-independent operation of utterance processing introduced in Section 2. Utterance processing is modelled as a cyclical process of applying context update rules, in the kind of way envisaged in the MIDAS system (Bos and Gabsdil, 2000). An utterance processing rule contains a condition to look for in the dialogue context, and an action, which is an update operation on the context. At each cycle, the set of rules is searched, and the first rule whose condition matches has its action executed. The cycle is repeated until no rules trigger. There is no reason a priori why speakerindependent context update operations need be applied cyclically by a rule interpreter. But there are several reasons why one might want to use a cyclical scheme. For Bos and Gabsdil (2000), the primary reason is that updating the context involves a gre</context>
</contexts>
<marker>Bos, Gabsdil, 2000</marker>
<rawString>J Bos and M Gabsdil. 2000. First-order inference and the interpretation of questions and answers. In Proceedings of Gotalog 2000. Fourth Workshop on the Semantics and Pragmatics ofDialogue., pages 43–50.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S de Jager</author>
<author>A Knott</author>
<author>I Bayard</author>
</authors>
<title>A DRT-based framework for presuppositions in dialogue management.</title>
<date>2002</date>
<booktitle>In Proceedings of the 6th workshop on the semantics and pragmatics of dialogue (EDILOG 2002),</booktitle>
<location>Edinburgh.</location>
<marker>de Jager, Knott, Bayard, 2002</marker>
<rawString>S de Jager, A Knott, and I Bayard. 2002. A DRT-based framework for presuppositions in dialogue management. In Proceedings of the 6th workshop on the semantics and pragmatics of dialogue (EDILOG 2002), Edinburgh.</rawString>
</citation>
<citation valid="true">
<authors>
<author>B J Grosz</author>
<author>C L Sidner</author>
</authors>
<title>Attention, intentions, and the structure of discourse. Computational Linguistics,</title>
<date>1986</date>
<pages>175--203</pages>
<contexts>
<context position="1942" citStr="Grosz and Sidner (1986)" startWordPosition="301" endWordPosition="304">form: a search of the set of grammar rules, and the creation of a new chart edge if the search is successful. In fact, the benefits of thinking of a parser as a procedural module consulting a declarative grammatical resource are most clearly seen in the fact that the procedural component can be expressed systematically in this way. The declarative/procedural distinction is also increasingly common in computational treatments of extended monologues. There are several overtly declarative theories of the structure of such texts (many of them stemming from the work of Mann and Thompson (1988) and Grosz and Sidner (1986)), and several models of text generation and text interpretation which make reference to these declarative theories (see e.g. Hovy (1993) and Marcu (2000) for a summary of generation and interpretation methods respectively). Again, the most attractive feature of the declarative/procedural distinction is that the procedural algorithms envisaged are very systematic. In models of dialogue structure, a clean separation between declarative and procedural models has proved more elusive. By analogy with the cases of sentences and monologic discourse just described, what is required is a declarative m</context>
</contexts>
<marker>Grosz, Sidner, 1986</marker>
<rawString>B J Grosz and C L Sidner. 1986. Attention, intentions, and the structure of discourse. Computational Linguistics, pages 175–203.</rawString>
</citation>
<citation valid="true">
<authors>
<author>E Hovy</author>
</authors>
<title>Automated discourse generation using discourse structure relations.</title>
<date>1993</date>
<journal>Artificial Intelligence,</journal>
<pages>63--341</pages>
<contexts>
<context position="2079" citStr="Hovy (1993)" startWordPosition="323" endWordPosition="324">parser as a procedural module consulting a declarative grammatical resource are most clearly seen in the fact that the procedural component can be expressed systematically in this way. The declarative/procedural distinction is also increasingly common in computational treatments of extended monologues. There are several overtly declarative theories of the structure of such texts (many of them stemming from the work of Mann and Thompson (1988) and Grosz and Sidner (1986)), and several models of text generation and text interpretation which make reference to these declarative theories (see e.g. Hovy (1993) and Marcu (2000) for a summary of generation and interpretation methods respectively). Again, the most attractive feature of the declarative/procedural distinction is that the procedural algorithms envisaged are very systematic. In models of dialogue structure, a clean separation between declarative and procedural models has proved more elusive. By analogy with the cases of sentences and monologic discourse just described, what is required is a declarative model of ‘wellformed dialogue’, together with procedural mechanisms that consult this model in a systematic way to produce and interpret c</context>
</contexts>
<marker>Hovy, 1993</marker>
<rawString>E Hovy. 1993. Automated discourse generation using discourse structure relations. Artificial Intelligence, 63:341–385.</rawString>
</citation>
<citation valid="true">
<authors>
<author>H Kamp</author>
<author>U Reyle</author>
</authors>
<title>From discourse to logic.</title>
<date>1993</date>
<publisher>Kluwer Academic Publishers,</publisher>
<location>Dordrecht.</location>
<contexts>
<context position="7705" citStr="Kamp and Reyle, 1993" startWordPosition="1220" endWordPosition="1223">is operation, again a new utterance representation is added to the dialogue context. Secondly, another speaker-independent operation of utterance processing occurs, in which exactly the same set of utterance processing rules are consulted, and further context updates are made. This picture of dialogue processing is summarised in Figure 1. In the remainder of the paper, this picture will be picture will be examined in more detail. 3 A DRT-based model of utterances and dialogue context The semantics of sentences in Te Kaitito are represented using Discourse Representation Structures (DRSs: see (Kamp and Reyle, 1993)), both for sentence generation and sentence interpretation. The main extension of classical DRT is to incorporate a treatment of presuppositions along the lines of that given in van der Sandt (1992). In this treatment, a sentence is modelled as an assertion DRS and a set of presupposition DRSs, each of which specifies information which must be found in the dialogue context before the sentence’s assertion can be further processed. Our system is a modification of van der Sandt’s, in that presuppositions are used to model the context-dependence of questions and answers as well as phenomena like </context>
</contexts>
<marker>Kamp, Reyle, 1993</marker>
<rawString>H Kamp and U Reyle. 1993. From discourse to logic. Kluwer Academic Publishers, Dordrecht.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S King</author>
<author>A Knott</author>
<author>B McCane</author>
</authors>
<title>Languagedriven nonverbal communication in a bilingual conversational agent.</title>
<date>2003</date>
<booktitle>In Proceedings of the 16th International Conference on Computer Animation and Social Agents (CASA).</booktitle>
<contexts>
<context position="15865" citStr="King et al., 2003" startWordPosition="2599" endWordPosition="2602">e some examples of the utterance processing rules used in Te Kaitito’s dialogue manager, and explain how they are used. The examples relate to the very simple dialogue given in Figure 3. After the first two utterances, the dialogue context will be the one which was shown in Figure 2. feel that architectures for dialogue management can be studied relatively independently from issues to do with general-purpose reasoning techniques. 4Te Kaitito has in fact been used as the back-end of an animated conversational agent which performs a few simple nonverbal strategies of this kind. For details see (King et al., 2003). Common ground DRS U1,X1,X2 cat(X1) Stack DRS house(X2) U2 U1: U2: in(X1,X2) barked(X1) var− assertion− act(U2) inside(X1, U2) We take up the story when the agent’s interlocutor I 1 I A cat was in a house 2 A Okay 3 I The cat barked 4 A Okay Figure 3: An example dialogue makes the second assertion. After this utterance has been interpreted, the dialogue context is as shown in Figure 4. Basically, a new sentence DRS has arrived Common ground DRS U1,X1,X2 Figure 4: Context after interpretation of Utterance 3 in the stack DRS. Note that the sentence contains a presupposition DRS, which is given </context>
</contexts>
<marker>King, Knott, McCane, 2003</marker>
<rawString>S King, A Knott, and B McCane. 2003. Languagedriven nonverbal communication in a bilingual conversational agent. In Proceedings of the 16th International Conference on Computer Animation and Social Agents (CASA).</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Knott</author>
<author>N Wright</author>
</authors>
<title>A dialogue-based knowledge authoring system for text generation.</title>
<date>2003</date>
<booktitle>In AAAI Spring Symposium on Natural Language Generation in Spoken and Written Dialogue,</booktitle>
<location>Stanford, CA.</location>
<contexts>
<context position="9848" citStr="Knott and Wright, 2003" startWordPosition="1592" endWordPosition="1595">uestions which have not been fully answered, assertions which have not been acknowledged, and so on). The stack DRS is actually a sub-DRS of the common ground DRS in our implementation, capturing the idea that referents within the common ground are available within the stack DRS, but not vice versa. Our model differs from that of Poesio and Traum in one fairly small respect, because we also envisage a role for discourse units in text planning. One of the functions of a dialogue in our system is to allow a user to author a knowledge base of facts that serves as input to a text planning system (Knott and Wright, 2003). A text planner needs to be able to partition its knowledge base into ‘utterance-sized’ sets of facts, which can then be structured into larger texts in various ways. It is very useful if the system can remember how the user performed these partitions during the authoring dialogue. The discourse units of Poesio and Traum seem almost tailor-made for this purpose. However, not all of the predicates inside a discourse unit should be retained in these cached utterances. Some predicates are only present in a sentence because they feature in referring expressions; since referring expressions will b</context>
</contexts>
<marker>Knott, Wright, 2003</marker>
<rawString>A Knott and N Wright. 2003. A dialogue-based knowledge authoring system for text generation. In AAAI Spring Symposium on Natural Language Generation in Spoken and Written Dialogue, Stanford, CA.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Knott</author>
<author>I Bayard</author>
<author>S de Jager</author>
<author>N Wright</author>
</authors>
<title>An architecture for bilingual and bidirectional nlp.</title>
<date>2002</date>
<booktitle>In Proceedings of the 2nd Australasian Natural Language Processing Workshop (ANLP</booktitle>
<marker>Knott, Bayard, de Jager, Wright, 2002</marker>
<rawString>A Knott, I Bayard, S de Jager, and N Wright. 2002. An architecture for bilingual and bidirectional nlp. In Proceedings of the 2nd Australasian Natural Language Processing Workshop (ANLP 2002).</rawString>
</citation>
<citation valid="true">
<authors>
<author>W C Mann</author>
<author>S A Thompson</author>
</authors>
<title>Rhetorical structure theory: A theory of text organization.</title>
<date>1988</date>
<tech>Text, 8(3):243–281.</tech>
<contexts>
<context position="1914" citStr="Mann and Thompson (1988)" startWordPosition="296" endWordPosition="299">has exactly the same general form: a search of the set of grammar rules, and the creation of a new chart edge if the search is successful. In fact, the benefits of thinking of a parser as a procedural module consulting a declarative grammatical resource are most clearly seen in the fact that the procedural component can be expressed systematically in this way. The declarative/procedural distinction is also increasingly common in computational treatments of extended monologues. There are several overtly declarative theories of the structure of such texts (many of them stemming from the work of Mann and Thompson (1988) and Grosz and Sidner (1986)), and several models of text generation and text interpretation which make reference to these declarative theories (see e.g. Hovy (1993) and Marcu (2000) for a summary of generation and interpretation methods respectively). Again, the most attractive feature of the declarative/procedural distinction is that the procedural algorithms envisaged are very systematic. In models of dialogue structure, a clean separation between declarative and procedural models has proved more elusive. By analogy with the cases of sentences and monologic discourse just described, what is</context>
</contexts>
<marker>Mann, Thompson, 1988</marker>
<rawString>W C Mann and S A Thompson. 1988. Rhetorical structure theory: A theory of text organization. Text, 8(3):243–281.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D Marcu</author>
</authors>
<title>The Theory and Practice of Discourse Parsing and Summarization.</title>
<date>2000</date>
<publisher>MIT Press,</publisher>
<location>Cambridge, MA.</location>
<contexts>
<context position="2096" citStr="Marcu (2000)" startWordPosition="326" endWordPosition="327">edural module consulting a declarative grammatical resource are most clearly seen in the fact that the procedural component can be expressed systematically in this way. The declarative/procedural distinction is also increasingly common in computational treatments of extended monologues. There are several overtly declarative theories of the structure of such texts (many of them stemming from the work of Mann and Thompson (1988) and Grosz and Sidner (1986)), and several models of text generation and text interpretation which make reference to these declarative theories (see e.g. Hovy (1993) and Marcu (2000) for a summary of generation and interpretation methods respectively). Again, the most attractive feature of the declarative/procedural distinction is that the procedural algorithms envisaged are very systematic. In models of dialogue structure, a clean separation between declarative and procedural models has proved more elusive. By analogy with the cases of sentences and monologic discourse just described, what is required is a declarative model of ‘wellformed dialogue’, together with procedural mechanisms that consult this model in a systematic way to produce and interpret contributions to a</context>
</contexts>
<marker>Marcu, 2000</marker>
<rawString>D Marcu. 2000. The Theory and Practice of Discourse Parsing and Summarization. MIT Press, Cambridge, MA.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Poesio</author>
<author>D Traum</author>
</authors>
<title>Towards an axiomatization of dialogue acts.</title>
<date>1998</date>
<booktitle>Proceedings of the Twente Workshop on the Formal Semantics and Pragmatics of Dialogues (13th Twente Workshop on Language Technology),</booktitle>
<pages>207--222</pages>
<editor>In J Hulstijn and A Nijholt, editors,</editor>
<contexts>
<context position="8583" citStr="Poesio and Traum (1998)" startWordPosition="1369" endWordPosition="1372">ion DRS and a set of presupposition DRSs, each of which specifies information which must be found in the dialogue context before the sentence’s assertion can be further processed. Our system is a modification of van der Sandt’s, in that presuppositions are used to model the context-dependence of questions and answers as well as phenomena like definite descriptions and anaphora (see de Jager et al. (2002) for some motivation for this idea, and see Section 5 for some examples). The dialogue context in Te Kaitito is also represented as a DRS, with additional extensions roughly along the lines of Poesio and Traum (1998). The main extension is the idea of a discourse unit, which is a sub-DRS gathering all of the semantic information expressed in a single utterance by one of the dialogue participants, the whole of which is treated as a first-class object to which other predicates can apply (e.g. asserts(speaker, U1)). This idea of discourse units is also adopted in the MIDAS system (Bos and Gabsdil, 2000). The other extension of classical DRT (also following Poesio and Traum) is that the dialogue context is modelled as a pair of DRSs: a common ground DRS containing facts which are mutually believed, and a stac</context>
</contexts>
<marker>Poesio, Traum, 1998</marker>
<rawString>M Poesio and D Traum. 1998. Towards an axiomatization of dialogue acts. In J Hulstijn and A Nijholt, editors, Proceedings of the Twente Workshop on the Formal Semantics and Pragmatics of Dialogues (13th Twente Workshop on Language Technology), pages 207–222.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D Traum</author>
<author>J Bos</author>
<author>R Cooper</author>
<author>S Larsson</author>
<author>I Lewin</author>
<author>C Matheson</author>
<author>M Poesio</author>
</authors>
<title>A model of dialogue moves and information state revision. TRINDI project deliverable.</title>
<date>1999</date>
<contexts>
<context position="2927" citStr="Traum et al (1999)" startWordPosition="451" endWordPosition="454">In models of dialogue structure, a clean separation between declarative and procedural models has proved more elusive. By analogy with the cases of sentences and monologic discourse just described, what is required is a declarative model of ‘wellformed dialogue’, together with procedural mechanisms that consult this model in a systematic way to produce and interpret contributions to a dialogue. To begin with, what is a declarative theory of dialogue structure? In this paper, we will assume a theoretical perspective in which dialogue moves are represented as context-update operations (see e.g. Traum et al (1999)). An utterance in a dialogue is understood as a function which (when defined) takes the current dialogue context and outputs a new dialogue context that constitutes the input to the next utterance in the dialogue. The declarative theory of dialogue coherence will therefore be a theory about the legal ways in which the dialogue context can be I’s utterance interlocutor (I) utterance processing Dialogue context B A utterance processing utterance interpretation A B utterance generation A’s utterance A C utterance processing rules Process A consults data from B Process A writes data in B Process </context>
</contexts>
<marker>Traum, Bos, Cooper, Larsson, Lewin, Matheson, Poesio, 1999</marker>
<rawString>D Traum, Bos J, R Cooper, S Larsson, I Lewin, C Matheson, and M Poesio. 1999. A model of dialogue moves and information state revision. TRINDI project deliverable.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Van der Sandt</author>
</authors>
<title>Presupposition projection as anaphora resolution.</title>
<date>1992</date>
<journal>Journal of Semantics,</journal>
<volume>9</volume>
<pages>377</pages>
<marker>Van der Sandt, 1992</marker>
<rawString>R Van der Sandt. 1992. Presupposition projection as anaphora resolution. Journal of Semantics, 9:333– 377.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>