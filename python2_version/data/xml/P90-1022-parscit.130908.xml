<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000276">
<note confidence="0.566735">
EXPRESSING DISJUNCTIVE AND NEGATIVE FEATURE CONSTRAINTS WITH
CLASSICAL FIRST-ORDER LOGIC.
Mark Johnson,
Cognitive and Linguistic Sciences, Box 1978,
Brown University, Providence, RI 02912.
</note>
<email confidence="0.990619">
mj@cs.brown.edu
</email>
<sectionHeader confidence="0.956464" genericHeader="abstract">
ABSTRACT
</sectionHeader>
<bodyText confidence="0.999666666666667">
In contrast to the &amp;quot;designer logic&amp;quot; approach, this
paper shows how the attribute-value feature
structures of unification grammar and
constraints on them can be axiomatized in
classical first-order logic, which can express
disjunctive and negative constraints. Because
only quantifier-free formulae are used in the
axiornatization, the satisfiability problem is 7P-
complete.
</bodyText>
<sectionHeader confidence="0.972455" genericHeader="introduction">
INTRODUCTION.
</sectionHeader>
<bodyText confidence="0.983525777777778">
Many modern linguistic theories, such as
Lexical-Functional Grammar [11, Functional
Unification Grammar [12] Generalized Phrase-
Structure Grammar [6], Categorial Unification
Grammar [20] and Head-driven Phrase-
Structure Grammar [18], replace the atomic
categories of a context-free grammar with a
&amp;quot;feature structure&amp;quot; that represents the syntactic
and semantic properties of the phrase. These
feature structures are specified in terms of
constraints that they must satisfy. Lexical
entries constrain the feature structures that can
be associated with terminal nodes of the
syntactic tree, and phrase structure rules
simultaneously constrain the feature structures
that can be associated with a parents and its
immediate descendants. The tree is well-formed
if and only if all of these constraints are
simultaneously satisfiable. Thus for the
purposes of recognition a method for
determining the sat isfiability of such constraints
is required: the nature of the satisfying feature
structures is of secondary importance.
Most work on unification-based
grammar (including the references cited above)
has adopted a type of feature structure called an
attribute-value structure. The elements in an
attribute-value structure come in two kinds:
constant elements and complex elements. Constant
elements are atomic entities with no internal
structure: i.e. they have no attributes. Complex
elements have zero or more attributes, whose
values may be any other element in the structure
(including a complex element) and any element
can be the value of zero, one or several
attributes. Attributes are partial: it need not he
the case that every attribute is defined for every
complex element. The set of attribute-value
structures partially ordered by the subsumption
relation (together with an additional entity T
that every attribute-value structure subsumes)
forms a lattice, and the join operation on this
lattice is called the unification operation 1191.
Example: (from [16]). The attrthute-value
structure (1) has six complex elements labelled
Cl e6 and two constant elements, singular and
third. The complex element ei has two
attributes, sub] and preil, the value of which are
the complex elements e2 and e3 respectively.
e7
(2) pred
subj
The unification of elements el of (1) and e7 of (2)
results in the attribute-value structure (3), the
</bodyText>
<figure confidence="0.997279666666667">
el verb
(1) subjpred te5
e2 agr
agr ef,
number person
singular third
verb
)elo
agr
</figure>
<page confidence="0.989365">
173
</page>
<equation confidence="0.972179">
minimal structure in the subsumption lattice
which subsumes both (1) and (2).
e7
(3)
subj „ed
Z
e2 es
agr
4 eb a r
number 11 person
singular third
</equation>
<bodyText confidence="0.998747740740741">
If constraints on attribute-value structures are
restricted to conjunctions of equality constraints
(i.e. requirements that the value of a path of
attributes is equal to a constant or the value of
another path) then the set of satisfying attribute-
value structures is the principal filter generated
by the minimal structure that satisfies the
constraints. The generator of the satisfying
principal filter of the conjunction of such
constraints is the unification of the generators of
the satisfying principal filters of each of the
conjuncts. Thus the set of attribute-value
structures that simultaneously satisfy a set of
such constraints can be characterized by
computing the unification of the generators of
the corresponding principal filters, and the
constraints are satisfiable iff the resulting
generator is not T (i.e. T represents unification
failure). Standard unification-based parsers use
unification in exactly this way.
When disjunctions and negations of
constraints are permitted, the set of satisfying
attribute-value structures does not always form
a principal filter [11], so the simple unification-
based technique for determining the
satisfiability of feature structure constraints
must be extended. Kasper and Rounds [11]
provide a formal framework for investigating
such constraints by reviving a distinction
originally made (as far as I am aware) by Kaplan
and Bresnan 1101 between the language in which
feature structure constraints are expressed and
the structures that satisfy these constraints.
Unification is supplanted by conjunction of
constraints, and disjunction and negation appear
only in the constraint language, not in the
feature structures themselves (an exception is 131
and [2], where feature bundles may contain
negative arcs).
Research in this genre usually follows a
general pattern: an abstract model for feature
structures and a specialized language for
expressing constraints on such structures are
&amp;quot;custom-crafted&amp;quot; to treat some problematic
feature constraint (such as negative feature
constraints). Table 1 sketches some of the
variety of feature structure models and
constraint types that previous analyses have
used.
This paper follows Kasper and Rounds
and most proposals listed in Table 1 by
distinguishing the constraint language from
feature structures, and restricts disjunction and
negation to the constraint language alone. It
</bodyText>
<figure confidence="0.6630305">
3 Cg
verb
</figure>
<tableCaption confidence="0.99287">
Table 1: Constraint Languages and Feature Structure Models.
</tableCaption>
<bodyText confidence="0.996455230769231">
Author Model of Feature Structures Constraint Language Features
Kaplan and Bresnan [101 Partial functions Disjunction, negation, set-
values
Pereira and Shieber [17] Information Domain
F=LIAFI-f-C
Kasper and Rounds [11] Acyclic finite automata Disjunction
Moshier and Rounds [14] Forcing sets of acyclic finite Intuitionistic negation
automata
Dawar and Vijayashankar 13] Acyclic finite automata Three truth values, negation
Gazdar, Pull um, Carpenter, Category structures Based on propositional modal
Klein, Hukari and Levine [7] logic
Johnson [9] &amp;quot;Attribute-value structures&amp;quot; Classical negation,
disjunction...
</bodyText>
<page confidence="0.894573">
174
</page>
<listItem confidence="0.979305">
(Al) For all constants c and attributes a, a(c) = I.
(A2) For all distinct pairs of constants c2, cj# c2.
(A3) For all attributes a, a(1) I.
(A4) For all constants c, c * 1.
(A5) For all terms u, v, u----v(u=vi\u-1)
</listItem>
<figureCaption confidence="0.906693">
Figure 1: The axiom schemata that define attribute-value structures.
</figureCaption>
<page confidence="0.991529">
175
</page>
<bodyText confidence="0.999892346153846">
differs by not proposing a custom-built
&amp;quot;designer logic&amp;quot; for describing feature
structures, but instead uses standard first-order
logic to axiomatize attribute-value structures
and express constraints on them, including
disjunctive and negative constraints. The
resulting system is a simplified version of
Attribute-Value Logic [9] which does not allow
values to be used as attributes (although it
would be easy to do this). The soundness and
completeness proofs in 191 and other papers
fisted in Table 1 are not required here because
these results are well-known properties of first-
order logic.
Since both the axiornatizion and the
constraints are actually expressed in a decidable
class of first-order formulae, viz, quantifier-free
formulae with equality,1 the decidability of
feature structure constraints follows trivially, in
fact, because the satisfiability problem for
quantifier-free formulae is V-complete [15] and
the relevant portion of the axiomatization and
translation of constraints can be constructed in
polynomial time, the satisfiability problem for
feature constraints (including negation) is also
V-complete.
</bodyText>
<sectionHeader confidence="0.955208" genericHeader="method">
A XIOMATIZING ATTRIBUTE-VALUE
STRUCTURES
</sectionHeader>
<bodyText confidence="0.969840578947369">
This section shows how attribute-value
structures can be axiornatizecl using first-order
quantifier-free formulae with equality. In the
next section we see that equality and inequality
constraints on the values of the attributes can
also be expressed as such formulae, so systems
of these constraints can be solved using standard
techniques such as the Congruence Closure
algorithm [15], [5].
The close relationship between quantifier-
free formulae and attribute-value constraints
was first noted in Kaplan and 13resnan [10].
The elements of the attribute-value
structure, both constant and complex, together
with an additional element 1 constitute the
domain of individuals of the intended
interpretation. The attributes are unary partial
functions over this domain (i.e. mappings from
elements to elements) which are always
undefined on constant elements. We capture
this partiality by the standard technique of
adding an additional element 1 to the domain to
serve as the value &apos;undefined&apos;. Thus a(x) =1 if x
does not have an attribute a, otherwise a(x) is the
value of x&apos;s attribute a.
We proceed by specifying the conditions
an interpretation must satisfy to be an attribute-
value structure. Modelling attributes with
functions automatically requires attributes to be
single-valued, as required.
Axiom schema (Al) describes the
properties of constants. It expresses the
requirement that constants have no attributes.
Axiom schema (A2) requires that
distinct constant symbols denote distinct elements
in any satisfying model. Without (A2) it would
be possible for two distinct constant elements,
say singular and plural, to denote the same
individual.2
Axiom schema (A3) and (A4) state the
properties of the &amp;quot;undefined value&amp;quot; I. It has no
attributes, and it is distinct from all of the
constants (and from all other elements as well —
this will be enforced by the translation of
equality constraints).
This completes the axiomatization. This
axiomatization is finite iff the sets of attribute
symbols and constant symbols are finite: in the
intended computational and linguistic
applications this is always the case. The claim is
that any interpretation which satisfies all of these
2 Such a schema is required because we are
concerned with satisfiability rather than
validity (as in e.g. logic programming).
axioms is an attribute-value structure; i.e. (Al) —
(A4) constitute a definition of attribute-value
structures.
express conjunctive, disjunctive and negative
feature constraints.
Example (continued): The interpretation
corresponding to the attribute-value structure
(1) has as its domain the set D = (el..... e6,
singular, third, 1). The attributes denote
functions from D to D. For example, agr denotes
the function whose value is 1 except on e2 and
e5, where its values are e4 and e6 respectively. it
is straight-forward to check that all the axioms
hold in the three attribute-value structures given
above.
In fact, any model for these axioms can be
regarded as a (possibly infinite and
disconnected) attribute-value feature structure,
where the model&apos;s individuals are the elements
or nodes, the unary functions define how
attributes take their values, the constant symbols
denote constant elements, and 1 is a sink state.
</bodyText>
<sectionHeader confidence="0.997581" genericHeader="method">
EXPRESSING CONSTRAINTS AS
QUANTIFIER-FREE FORMULAE.
</sectionHeader>
<bodyText confidence="0.976964857142857">
Various notations are currently used to express
attribute-value constraints: the constraint
requiring that the value of attribute a of (the
entity denoted by) x is (the entity denoted by) y
is written as (x a) = yin PATR-ll [19], as (x a) = y
in LFG [10], and as x(a) y in [9], for example.
At the risk of further confusion we use another
notation here, and write the constraint requiring
that the value of attribute a of x is y as a( y-
This notation emphasises the fact that attributes
are modelled by functions, and simplifies the
definition of
Clearly for an attribute-value structure
to satisfy the constraint u v then u and v must
denote the same element, i.e. u = v. However
this is not a sufficient condition: nurn(x) num(y)
is not satisfied if num(x) or num(y) is I. Thus it
is necessary that the arguments of denote
identical elements distinct from the denotation
of 1.
Even though there are infinitely many
instances of the schema in (A5) (since there are
infinitely many terms) this is not problematic,
since u v can be regarded as an abbreviation for
u=vnu*1.
Thus equality constraints on attribute-
value structures can be expressed with
quantifier-free formulae with equality. We use
classically interpreted boolean connectives to
Example (continued): Suppose each variable
xi denotes the corresponding ei, 11, of (1)
and (2). Then subj(xi) — x2,
number(x4) singular and number(agr( x2))
— number( x4) are true, for example. Since e4 and
e5 are distinct elements, xs xu is false and
hence x8 4. xii is true. Thus &amp;quot;b&amp;quot; means &amp;quot;not
identical to&amp;quot; or &amp;quot;not unified with&amp;quot;, rather than
&amp;quot;not unifiable with&amp;quot;.
Further, since agr(xi)
agr(n) agr(x) is false, even though
agr(rd agr( xi) is true. Thus t t is not a
theorem because of the possibility that t = 1.
</bodyText>
<sectionHeader confidence="0.993838" genericHeader="method">
SATISFACTION AND UNIFICATION
</sectionHeader>
<bodyText confidence="0.999969685714286">
Given any two formulae 4 and cp, the set of
models that satisfy both and p is exactly the set
of models that satisfy (1) A (p. That is, the
conjunction operation can be used to describe
the intersection of two sets of models each of
which is described by a constraint formula, even
if these satisfying models do not form principal
filters [11] [9]. Since conjunction is idempotent,
associative and commutative, the satisfiability of
a conjunction of constraint formulae is
independent of the order in which the conjuncts
are presented, irrespective of whether they
contain negation. Thus the evaluation (i.e.
simplification) of constraints containing
negation can be freely interleaved with other
constraints.
Unification identifies or merges exactly
the elements that the axiomatization implies are
equal. The unification of two complex elements
e and e&apos; causes the unification of elements a(e)
and a(e&apos;) for all attributes a that are defined on
both e and e&apos;. The constraint x x&apos; implies
a(x)— a(x&apos;) in exactly the same circumstances; i.e.
when a(x) and a(x&apos;) are both distinct from I.
Unification fails either when two different
constant elements are to be unified, or when a
complex element and a constant element are
unified (i.e. constant-constant clashes and constant-
complex clashes). The constraint x x&apos; is
unsatisfiable under exactly the same
circumstances. x x&apos; is unsatisfiable when x and
x&apos; are also required to satisfy x c and x&apos; c&apos; for
distinct constants c, c&apos;, since c c&apos; by axiom
schema (A2). x x&apos; is also unsatisfiable when x
and x&apos; are required to satisfy a(x) t and x&apos; c&apos;
</bodyText>
<page confidence="0.997391">
176
</page>
<bodyText confidence="0.9895848125">
for any attribute a, term t and constant c&apos;, since
a(c&amp;quot;) 1 by axiom schema (A3).
Since unification is a technique for
determining the satisfiability of conjunctions of
atomic equality constraints, the result of a
unification operation is exactly the set of atomic
consequences of the corresponding constraints.
Since unification fails precisely when the
corresponding constraints are unsatisfiable,
failure of unification occurs exactly when the
corresponding constraints are equivalent to
False.
Example (continued): The sets of satisfying
models for the formulae (1&apos;) and (2&apos;) are precisely
the principal filters generated by (1) and (2)
above.
</bodyText>
<equation confidence="0.979116857142857">
SUbi(Xj) X2 A agr(x2) x4 A
number(x4) ,- singular A pred(xi),- X3 A
verb(x3) x5 A agr(x5) - x6 A
person(x6) third
Su-, X8 A agr(x8) I
(2&apos;) hi( A pred(x7)--- X9 A
verb(x9) xio A agr(xio) xil
</equation>
<bodyText confidence="0.945749">
Because the principal filter generated by the
unification of el and e7 is the intersection of the
principal filters generated by (1) and (2), it is
also the set of satisfying models for the
conjunction of (1&apos;) and (2&apos;) with the formula
Xi 17 (3&apos;).
</bodyText>
<equation confidence="0.999781">
(3&apos;) SUbi(X1) X2 A agr(x2) 14 A
nmber(x4) - singular A pred(x1) - x3 A
verb(x3) 15 A agr(x5) x6 A
person(x6) third A SUbi(X7),--- X8 A
agr(X8) Xil A pred(x7) 19 A
verb(x9) - X10 A agr(x10) - x11 All X7.
</equation>
<bodyText confidence="0.996335375">
The satisfiabllity of a formula like (3&apos;) can be
shown using standard techniques such as the
Congruence Closure Algorithm 115], [5]. In
fact, using the substitutivity and transitivity of
equality, (3&apos;) can be simplified to (3&amp;quot;). It is easy
to check that (3) is a satisfying model for both
(3&amp;quot;) and the axioms for attribute-value
structures.
</bodyText>
<equation confidence="0.9839558">
(3&amp;quot;) subj(xi) 12 A agr(x2) x4 A
number(x4) singular A person(x4) -= third A
pred(xl) - 13 A verb(x3) 15 A agr(x5) - x4 A
X7 A X2 X5 A X3 X9 AX5 XIO A
X4 X6 A 14 X11.
</equation>
<bodyText confidence="0.98307696875">
The treatment of negative and disjunctive
constraints is straightforward. Since negation is
interpreted classically, the set of satisfying
models do not always form a filter (i.e. they are
not always upward closed f161). Nevertheless,
the quantifier-free language itself is capable of
characterizing exactly the set of feature
structures that satisfy any boolean combination
of constraints, so the failure of upward closure is
not a fatal flaw of this approach.
At a methodological level, I claim that
after the mathematical consequences of two
different interpretations of feature structure
constraints have been investigated, such as the
classical and intuitionistic interpretations of
negation in feature structure constraints [14], it
is primarily a linguistic question as to which is
better suited to the description of natural
language. I have been unable to find any
linguistic analyses which can yield a set of
constraints whose satisfiablity varies under the
classical and intuitionistic interpretations, so the
choice between classical and intuitionistic
negation may be moot.
For reasons of space the following
example (based on Pereira&apos;s example 1161
demonstrating a purported problem arising
from the failure of upward closure with classical
negation) exhibits only negative constraints.
Example: The conjunction of the formulae
number(agr(x)) - singular
and
</bodyText>
<equation confidence="0.75581">
agr(x) y A — pers(y) 3rd A
number(y)singular)
</equation>
<bodyText confidence="0.966210375">
can be simplified by substitution and transitivity
of equality and boolean equivalences to
(4&apos;) agr(x)-- y A number(y) singular A
per(y) 3rd.
This formula is satisfied by the structure (4)
when x denotes rand y denotes f. Note the
failure of upward closure, e.g. (5) does not satisfy
(4&apos;), even though (4) subsumes (5).
</bodyText>
<page confidence="0.979585">
177
</page>
<figure confidence="0.975438">
(4) e
agr (5) a r
number per s
number
4.
singular 3rd
singular
However, if (41 is conjoined with
</figure>
<construct confidence="0.395621666666667">
pers(agr(x)) 3rd the resulting formula (6) is
unsatisfiable since it is equivalent to (6&apos;), and
3rd 3rd is unsatisfiable.
</construct>
<equation confidence="0.68207725">
(6) agr(x) y A number(y) singular A
pers(y) 3rd A pers(agr(x)) - 3rd.
(6&apos;) agr(x) y A number(y) singular A
pers(y) - 3rd A 3rd 3rd.
</equation>
<sectionHeader confidence="0.823415" genericHeader="conclusions">
CONCLUSION
</sectionHeader>
<bodyText confidence="0.999948021276596">
This paper has shown how attribute-value
structures and constraints on them can be
axiomatized in a decidable class of first-order
logic. The primary advantage of this approach
over the &amp;quot;designer logic&amp;quot; approach is that
important properties of the logic of the feature
constraint language, such as soundness,
completeness, decidability and compactness,
follow immediately, rather than proven from
scratch. A secondary benefit is that the
substantial body of work on satisfiability
algorithms for first-order formulae (such as
ATMS-based techniques that can efficiently
evaluate some disjunctive constraints [13]) can
immediately be applied to feature structure
constraints.
Further, first-order logic can be used to
axiornatize other types of feature structures in
addition to attribute-value structures (such as
&amp;quot;set-valued&amp;quot; elements) and express a wider
variety of constraints than equality constraints
(e.g. subsumption constraints). In general these
extended systems cannot be axiornatized using
only quantifier-free formulae, so their
decidability may not follow directly as it does
here. However the decision problem for
sublanguages of first-order logic has been
intensively investigated [4], and there are
decidable classes of first-order formulae 181 that
appear to be expressive enough to axiomatize an
interesting variety of feature structures (e.g.
function-free universally-quantified prenex
formulae can express linguistically useful
constraints on &amp;quot;set-valued&amp;quot; elements).
An objection that might be raised to this
general approach is that classical first-order
logic cannot adequately express the inherently
&amp;quot;partial information&amp;quot; that feature structures
represent. While the truth value of any formula
with respect to a model (i.e. an interpretation
and variable assignment function) is completely
determined, in general there will be many
models that satisfy a given formula, i.e. a
formula only partially identifies a satisfying
model (i.e. attribute-value structure). The claim
is that this partiality suffices to describe the
partiality of feature structures.
</bodyText>
<sectionHeader confidence="0.98714" genericHeader="references">
BIBLIOGRAPHY
</sectionHeader>
<reference confidence="0.999936064516129">
1. Bresnan, J. The Mental Representation of
Grammatical Relations. 1982 The MIT Press.
Cambridge, Mass.
2. Dawar, A. and K. Vijayashanker. Three-
Valued Interpretation of Negation in Feature
Structure Descriptions. University of
Delaware Technical Report 90-03. 1989.
3. Dawar, A. and K. Vijayashanker. &amp;quot;A
Three-Valued Interpretation of Negation
in Feature Structures&amp;quot;, in The 27th Annual
Meeting of the Association of Computational
Linguistics, Vancouver, 1989,
4. Dreben, B. and W. D. Goldfarb. The
Decision Problem: Solvable Classes of
Quantificational Formulas. 1979 Addison-
Wesley. Reading, Mass.
5. Gather, J. H. Logic for Computer Science.
1986 Harper and Row. New York.
6. Gazdar, G., E. Klein, G. Pullum and I. Sag.
Generalized Phrase Structure Grammar. 1985
Blackwell. Oxford, England.
7. Gazclar, G., G. K. Pullum, R. Carpenter, E.
Klein, T. E. Hukari and R. D. Levine.
&amp;quot;Category Structures.&amp;quot; Computational
Linguistics. 14.1: 1 -.20,1988.
8. Gurevich, Y. &amp;quot;The Decision Problem for
Standard Classes.&amp;quot; ISL. 41.2: 460-464, 1976.
9. Johnson, M. Attribute-Value Logic and the
Theory of Grammar. CSLI Lecture Notes
Series. 1988 University of Chicago Press.
Chicago.
</reference>
<page confidence="0.986429">
178
</page>
<reference confidence="0.882200941176471">
CSLI Lecture Notes Series. 1986 University
of Chicago Press. Chicago.
20. Uszkoreit, H. &amp;quot;Categorial unification
grammar&amp;quot;, in COUNG-86, 1986, 187-194.
10. Kaplan, R. and J. Bresnan. &amp;quot;Lexical-
functional grammar, a formal system for
grammatical representation,&amp;quot; in The
Mental Representation of Grammatical
Relations, Bresnan ed., 1982 The MIT Press.
Cambridge, Mass.
11. Kasper, R. T. and W. C. Rounds. &amp;quot;A logical
semantics for feature structures&amp;quot;, in The
Proceedings of the 24th Annual Meeting of the
Association for Computational Linguistics,
Columbia University, New York, 1986,
257-266.
12. Kay, M. &amp;quot;Unification in Grammar,&amp;quot; in
Natural Language Understanding and Logic
Programming, Dahl and Saint—Dizier ed.,
1985 North Holland. Amsterdam, The
Netherlands.
13. Maxwell, J. T., III and R. Kaplan. &amp;quot;An
Overview of Disjunctive Constraint
Satisfaction&amp;quot;, in International Workshop on
Parsing Technologies, Pittsburgh, PA., 1989,
18 —27. Carnegie Mellon.
14. Moshier, M. D. and W. C. Rounds. &amp;quot;A
logic for partially specified data
structures&amp;quot;, in The ACM Symposium on the
Principles of Programming Languages,
Munich, Germany, 1987, Association for
Computing Machinery.
15. Nelson, G. and D. C. Oppen. &amp;quot;Fast
Decision Procedures based on Congruence
Closure.&amp;quot; J. ACM. 27.2: 245-257, 1980.
16. Pereira, F. C. N. &amp;quot;Grammars and Logics of
Partial Information&amp;quot;, in The Proceedings of
the international Conference on Logic
Programming, Melbourne, Australia, 1987.
17. Pereira, F. C. N. and S. M. Shieber. &amp;quot;The
semantics of grammar formalisms seen as
computer languages&amp;quot;, in CO LING-84,
Stanford University, 1984, 123-129. The
Association for Computational
Linguistics.
18. Pollard, C. and I. Sag. Information-based
Syntax and Semantics, Volume 7. CSLI
Lecture Notes. 1987 Chicago University
Press. Chicago.
19. Shieber, S. M. An introduction to
Unification-based Approaches to Grammar.
</reference>
<page confidence="0.998801">
179
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.359668">
<title confidence="0.9888585">DISJUNCTIVE AND NEGATIVE FEATURE WITH CLASSICAL FIRST-ORDER LOGIC.</title>
<author confidence="0.999954">Mark Johnson</author>
<affiliation confidence="0.7807275">Cognitive and Linguistic Sciences, Box 1978, Brown University, Providence, RI 02912.</affiliation>
<email confidence="0.999526">mj@cs.brown.edu</email>
<abstract confidence="0.9522529">In contrast to the &amp;quot;designer logic&amp;quot; approach, this paper shows how the attribute-value feature structures of unification grammar and constraints on them can be axiomatized in classical first-order logic, which can express disjunctive and negative constraints. Because only quantifier-free formulae are used in the the satisfiability problem is 7Pcomplete.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>J Bresnan</author>
</authors>
<title>The Mental Representation of Grammatical Relations.</title>
<date>1982</date>
<publisher>The MIT Press.</publisher>
<location>Cambridge, Mass.</location>
<contexts>
<context position="2603" citStr="(1)" startWordPosition="367" endWordPosition="367">or more attributes, whose values may be any other element in the structure (including a complex element) and any element can be the value of zero, one or several attributes. Attributes are partial: it need not he the case that every attribute is defined for every complex element. The set of attribute-value structures partially ordered by the subsumption relation (together with an additional entity T that every attribute-value structure subsumes) forms a lattice, and the join operation on this lattice is called the unification operation 1191. Example: (from [16]). The attrthute-value structure (1) has six complex elements labelled Cl e6 and two constant elements, singular and third. The complex element ei has two attributes, sub] and preil, the value of which are the complex elements e2 and e3 respectively. e7 (2) pred subj The unification of elements el of (1) and e7 of (2) results in the attribute-value structure (3), the el verb (1) subjpred te5 e2 agr agr ef, number person singular third verb )elo agr 173 minimal structure in the subsumption lattice which subsumes both (1) and (2). e7 (3) subj „ed Z e2 es agr 4 eb a r number 11 person singular third If constraints on attribute-valu</context>
<context position="6374" citStr="(1)" startWordPosition="937" endWordPosition="937">d Shieber [17] Information Domain F=LIAFI-f-C Kasper and Rounds [11] Acyclic finite automata Disjunction Moshier and Rounds [14] Forcing sets of acyclic finite Intuitionistic negation automata Dawar and Vijayashankar 13] Acyclic finite automata Three truth values, negation Gazdar, Pull um, Carpenter, Category structures Based on propositional modal Klein, Hukari and Levine [7] logic Johnson [9] &amp;quot;Attribute-value structures&amp;quot; Classical negation, disjunction... 174 (Al) For all constants c and attributes a, a(c) = I. (A2) For all distinct pairs of constants c2, cj# c2. (A3) For all attributes a, a(1) I. (A4) For all constants c, c * 1. (A5) For all terms u, v, u----v(u=vi\u-1) Figure 1: The axiom schemata that define attribute-value structures. 175 differs by not proposing a custom-built &amp;quot;designer logic&amp;quot; for describing feature structures, but instead uses standard first-order logic to axiomatize attribute-value structures and express constraints on them, including disjunctive and negative constraints. The resulting system is a simplified version of Attribute-Value Logic [9] which does not allow values to be used as attributes (although it would be easy to do this). The soundness and compl</context>
<context position="10277" citStr="(1)" startWordPosition="1510" endWordPosition="1510">sets of attribute symbols and constant symbols are finite: in the intended computational and linguistic applications this is always the case. The claim is that any interpretation which satisfies all of these 2 Such a schema is required because we are concerned with satisfiability rather than validity (as in e.g. logic programming). axioms is an attribute-value structure; i.e. (Al) — (A4) constitute a definition of attribute-value structures. express conjunctive, disjunctive and negative feature constraints. Example (continued): The interpretation corresponding to the attribute-value structure (1) has as its domain the set D = (el..... e6, singular, third, 1). The attributes denote functions from D to D. For example, agr denotes the function whose value is 1 except on e2 and e5, where its values are e4 and e6 respectively. it is straight-forward to check that all the axioms hold in the three attribute-value structures given above. In fact, any model for these axioms can be regarded as a (possibly infinite and disconnected) attribute-value feature structure, where the model&apos;s individuals are the elements or nodes, the unary functions define how attributes take their values, the constant</context>
<context position="12315" citStr="(1)" startWordPosition="1852" endWordPosition="1852">um(y) is not satisfied if num(x) or num(y) is I. Thus it is necessary that the arguments of denote identical elements distinct from the denotation of 1. Even though there are infinitely many instances of the schema in (A5) (since there are infinitely many terms) this is not problematic, since u v can be regarded as an abbreviation for u=vnu*1. Thus equality constraints on attributevalue structures can be expressed with quantifier-free formulae with equality. We use classically interpreted boolean connectives to Example (continued): Suppose each variable xi denotes the corresponding ei, 11, of (1) and (2). Then subj(xi) — x2, number(x4) singular and number(agr( x2)) — number( x4) are true, for example. Since e4 and e5 are distinct elements, xs xu is false and hence x8 4. xii is true. Thus &amp;quot;b&amp;quot; means &amp;quot;not identical to&amp;quot; or &amp;quot;not unified with&amp;quot;, rather than &amp;quot;not unifiable with&amp;quot;. Further, since agr(xi) agr(n) agr(x) is false, even though agr(rd agr( xi) is true. Thus t t is not a theorem because of the possibility that t = 1. SATISFACTION AND UNIFICATION Given any two formulae 4 and cp, the set of models that satisfy both and p is exactly the set of models that satisfy (1) A (p. That is, the </context>
<context position="15001" citStr="(1)" startWordPosition="2294" endWordPosition="2294">and constant c&apos;, since a(c&amp;quot;) 1 by axiom schema (A3). Since unification is a technique for determining the satisfiability of conjunctions of atomic equality constraints, the result of a unification operation is exactly the set of atomic consequences of the corresponding constraints. Since unification fails precisely when the corresponding constraints are unsatisfiable, failure of unification occurs exactly when the corresponding constraints are equivalent to False. Example (continued): The sets of satisfying models for the formulae (1&apos;) and (2&apos;) are precisely the principal filters generated by (1) and (2) above. SUbi(Xj) X2 A agr(x2) x4 A number(x4) ,- singular A pred(xi),- X3 A verb(x3) x5 A agr(x5) - x6 A person(x6) third Su-, X8 A agr(x8) I (2&apos;) hi( A pred(x7)--- X9 A verb(x9) xio A agr(xio) xil Because the principal filter generated by the unification of el and e7 is the intersection of the principal filters generated by (1) and (2), it is also the set of satisfying models for the conjunction of (1&apos;) and (2&apos;) with the formula Xi 17 (3&apos;). (3&apos;) SUbi(X1) X2 A agr(x2) 14 A nmber(x4) - singular A pred(x1) - x3 A verb(x3) 15 A agr(x5) x6 A person(x6) third A SUbi(X7),--- X8 A agr(X8) Xil</context>
</contexts>
<marker>1.</marker>
<rawString>Bresnan, J. The Mental Representation of Grammatical Relations. 1982 The MIT Press. Cambridge, Mass.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Dawar</author>
<author>K Vijayashanker</author>
</authors>
<title>ThreeValued Interpretation of Negation in Feature Structure Descriptions.</title>
<date>1989</date>
<tech>Technical Report 90-03.</tech>
<institution>University of Delaware</institution>
<contexts>
<context position="4885" citStr="[2]" startWordPosition="723" endWordPosition="723">tionbased technique for determining the satisfiability of feature structure constraints must be extended. Kasper and Rounds [11] provide a formal framework for investigating such constraints by reviving a distinction originally made (as far as I am aware) by Kaplan and Bresnan 1101 between the language in which feature structure constraints are expressed and the structures that satisfy these constraints. Unification is supplanted by conjunction of constraints, and disjunction and negation appear only in the constraint language, not in the feature structures themselves (an exception is 131 and [2], where feature bundles may contain negative arcs). Research in this genre usually follows a general pattern: an abstract model for feature structures and a specialized language for expressing constraints on such structures are &amp;quot;custom-crafted&amp;quot; to treat some problematic feature constraint (such as negative feature constraints). Table 1 sketches some of the variety of feature structure models and constraint types that previous analyses have used. This paper follows Kasper and Rounds and most proposals listed in Table 1 by distinguishing the constraint language from feature structures, and restr</context>
</contexts>
<marker>2.</marker>
<rawString>Dawar, A. and K. Vijayashanker. ThreeValued Interpretation of Negation in Feature Structure Descriptions. University of Delaware Technical Report 90-03. 1989.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Dawar</author>
<author>K Vijayashanker</author>
</authors>
<title>A Three-Valued Interpretation of Negation in Feature Structures&amp;quot;,</title>
<date>1989</date>
<booktitle>in The 27th Annual Meeting of the Association of Computational Linguistics,</booktitle>
<location>Vancouver,</location>
<contexts>
<context position="2931" citStr="(3)" startWordPosition="424" endWordPosition="424"> ordered by the subsumption relation (together with an additional entity T that every attribute-value structure subsumes) forms a lattice, and the join operation on this lattice is called the unification operation 1191. Example: (from [16]). The attrthute-value structure (1) has six complex elements labelled Cl e6 and two constant elements, singular and third. The complex element ei has two attributes, sub] and preil, the value of which are the complex elements e2 and e3 respectively. e7 (2) pred subj The unification of elements el of (1) and e7 of (2) results in the attribute-value structure (3), the el verb (1) subjpred te5 e2 agr agr ef, number person singular third verb )elo agr 173 minimal structure in the subsumption lattice which subsumes both (1) and (2). e7 (3) subj „ed Z e2 es agr 4 eb a r number 11 person singular third If constraints on attribute-value structures are restricted to conjunctions of equality constraints (i.e. requirements that the value of a path of attributes is equal to a constant or the value of another path) then the set of satisfying attributevalue structures is the principal filter generated by the minimal structure that satisfies the constraints. The g</context>
<context position="15915" citStr="(3)" startWordPosition="2465" endWordPosition="2465">al filters generated by (1) and (2), it is also the set of satisfying models for the conjunction of (1&apos;) and (2&apos;) with the formula Xi 17 (3&apos;). (3&apos;) SUbi(X1) X2 A agr(x2) 14 A nmber(x4) - singular A pred(x1) - x3 A verb(x3) 15 A agr(x5) x6 A person(x6) third A SUbi(X7),--- X8 A agr(X8) Xil A pred(x7) 19 A verb(x9) - X10 A agr(x10) - x11 All X7. The satisfiabllity of a formula like (3&apos;) can be shown using standard techniques such as the Congruence Closure Algorithm 115], [5]. In fact, using the substitutivity and transitivity of equality, (3&apos;) can be simplified to (3&amp;quot;). It is easy to check that (3) is a satisfying model for both (3&amp;quot;) and the axioms for attribute-value structures. (3&amp;quot;) subj(xi) 12 A agr(x2) x4 A number(x4) singular A person(x4) -= third A pred(xl) - 13 A verb(x3) 15 A agr(x5) - x4 A X7 A X2 X5 A X3 X9 AX5 XIO A X4 X6 A 14 X11. The treatment of negative and disjunctive constraints is straightforward. Since negation is interpreted classically, the set of satisfying models do not always form a filter (i.e. they are not always upward closed f161). Nevertheless, the quantifier-free language itself is capable of characterizing exactly the set of feature structures that satisfy</context>
</contexts>
<marker>3.</marker>
<rawString>Dawar, A. and K. Vijayashanker. &amp;quot;A Three-Valued Interpretation of Negation in Feature Structures&amp;quot;, in The 27th Annual Meeting of the Association of Computational Linguistics, Vancouver, 1989,</rawString>
</citation>
<citation valid="true">
<authors>
<author>B Dreben</author>
<author>W D Goldfarb</author>
</authors>
<title>The Decision Problem: Solvable Classes of Quantificational Formulas.</title>
<date>1979</date>
<location>Reading, Mass.</location>
<contexts>
<context position="19467" citStr="[4]" startWordPosition="3012" endWordPosition="3012">constraints [13]) can immediately be applied to feature structure constraints. Further, first-order logic can be used to axiornatize other types of feature structures in addition to attribute-value structures (such as &amp;quot;set-valued&amp;quot; elements) and express a wider variety of constraints than equality constraints (e.g. subsumption constraints). In general these extended systems cannot be axiornatized using only quantifier-free formulae, so their decidability may not follow directly as it does here. However the decision problem for sublanguages of first-order logic has been intensively investigated [4], and there are decidable classes of first-order formulae 181 that appear to be expressive enough to axiomatize an interesting variety of feature structures (e.g. function-free universally-quantified prenex formulae can express linguistically useful constraints on &amp;quot;set-valued&amp;quot; elements). An objection that might be raised to this general approach is that classical first-order logic cannot adequately express the inherently &amp;quot;partial information&amp;quot; that feature structures represent. While the truth value of any formula with respect to a model (i.e. an interpretation and variable assignment function)</context>
</contexts>
<marker>4.</marker>
<rawString>Dreben, B. and W. D. Goldfarb. The Decision Problem: Solvable Classes of Quantificational Formulas. 1979 AddisonWesley. Reading, Mass.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J H Gather</author>
</authors>
<title>Logic for Computer Science.</title>
<date>1986</date>
<location>New York.</location>
<contexts>
<context position="8088" citStr="[5]" startWordPosition="1184" endWordPosition="1184">tization and translation of constraints can be constructed in polynomial time, the satisfiability problem for feature constraints (including negation) is also V-complete. A XIOMATIZING ATTRIBUTE-VALUE STRUCTURES This section shows how attribute-value structures can be axiornatizecl using first-order quantifier-free formulae with equality. In the next section we see that equality and inequality constraints on the values of the attributes can also be expressed as such formulae, so systems of these constraints can be solved using standard techniques such as the Congruence Closure algorithm [15], [5]. The close relationship between quantifierfree formulae and attribute-value constraints was first noted in Kaplan and 13resnan [10]. The elements of the attribute-value structure, both constant and complex, together with an additional element 1 constitute the domain of individuals of the intended interpretation. The attributes are unary partial functions over this domain (i.e. mappings from elements to elements) which are always undefined on constant elements. We capture this partiality by the standard technique of adding an additional element 1 to the domain to serve as the value &apos;undefined&apos;</context>
<context position="15789" citStr="[5]" startWordPosition="2443" endWordPosition="2443">) xio A agr(xio) xil Because the principal filter generated by the unification of el and e7 is the intersection of the principal filters generated by (1) and (2), it is also the set of satisfying models for the conjunction of (1&apos;) and (2&apos;) with the formula Xi 17 (3&apos;). (3&apos;) SUbi(X1) X2 A agr(x2) 14 A nmber(x4) - singular A pred(x1) - x3 A verb(x3) 15 A agr(x5) x6 A person(x6) third A SUbi(X7),--- X8 A agr(X8) Xil A pred(x7) 19 A verb(x9) - X10 A agr(x10) - x11 All X7. The satisfiabllity of a formula like (3&apos;) can be shown using standard techniques such as the Congruence Closure Algorithm 115], [5]. In fact, using the substitutivity and transitivity of equality, (3&apos;) can be simplified to (3&amp;quot;). It is easy to check that (3) is a satisfying model for both (3&amp;quot;) and the axioms for attribute-value structures. (3&amp;quot;) subj(xi) 12 A agr(x2) x4 A number(x4) singular A person(x4) -= third A pred(xl) - 13 A verb(x3) 15 A agr(x5) - x4 A X7 A X2 X5 A X3 X9 AX5 XIO A X4 X6 A 14 X11. The treatment of negative and disjunctive constraints is straightforward. Since negation is interpreted classically, the set of satisfying models do not always form a filter (i.e. they are not always upward closed f161). Nev</context>
</contexts>
<marker>5.</marker>
<rawString>Gather, J. H. Logic for Computer Science. 1986 Harper and Row. New York.</rawString>
</citation>
<citation valid="true">
<authors>
<author>G Gazdar</author>
<author>E Klein</author>
<author>G Pullum</author>
<author>I Sag</author>
</authors>
<title>Generalized Phrase Structure Grammar.</title>
<date>1985</date>
<location>Blackwell. Oxford, England.</location>
<contexts>
<context position="749" citStr="[6]" startWordPosition="94" endWordPosition="94">8, Brown University, Providence, RI 02912. mj@cs.brown.edu ABSTRACT In contrast to the &amp;quot;designer logic&amp;quot; approach, this paper shows how the attribute-value feature structures of unification grammar and constraints on them can be axiomatized in classical first-order logic, which can express disjunctive and negative constraints. Because only quantifier-free formulae are used in the axiornatization, the satisfiability problem is 7Pcomplete. INTRODUCTION. Many modern linguistic theories, such as Lexical-Functional Grammar [11, Functional Unification Grammar [12] Generalized PhraseStructure Grammar [6], Categorial Unification Grammar [20] and Head-driven PhraseStructure Grammar [18], replace the atomic categories of a context-free grammar with a &amp;quot;feature structure&amp;quot; that represents the syntactic and semantic properties of the phrase. These feature structures are specified in terms of constraints that they must satisfy. Lexical entries constrain the feature structures that can be associated with terminal nodes of the syntactic tree, and phrase structure rules simultaneously constrain the feature structures that can be associated with a parents and its immediate descendants. The tree is well-f</context>
</contexts>
<marker>6.</marker>
<rawString>Gazdar, G., E. Klein, G. Pullum and I. Sag. Generalized Phrase Structure Grammar. 1985 Blackwell. Oxford, England.</rawString>
</citation>
<citation valid="false">
<authors>
<author>G Gazclar</author>
<author>G K Pullum</author>
<author>R Carpenter</author>
<author>E Klein</author>
<author>T E Hukari</author>
<author>R D Levine</author>
</authors>
<title>Category Structures.&amp;quot;</title>
<journal>Computational Linguistics.</journal>
<volume>14</volume>
<pages>20--1988</pages>
<contexts>
<context position="6150" citStr="[7]" startWordPosition="901" endWordPosition="901">. It 3 Cg verb Table 1: Constraint Languages and Feature Structure Models. Author Model of Feature Structures Constraint Language Features Kaplan and Bresnan [101 Partial functions Disjunction, negation, setvalues Pereira and Shieber [17] Information Domain F=LIAFI-f-C Kasper and Rounds [11] Acyclic finite automata Disjunction Moshier and Rounds [14] Forcing sets of acyclic finite Intuitionistic negation automata Dawar and Vijayashankar 13] Acyclic finite automata Three truth values, negation Gazdar, Pull um, Carpenter, Category structures Based on propositional modal Klein, Hukari and Levine [7] logic Johnson [9] &amp;quot;Attribute-value structures&amp;quot; Classical negation, disjunction... 174 (Al) For all constants c and attributes a, a(c) = I. (A2) For all distinct pairs of constants c2, cj# c2. (A3) For all attributes a, a(1) I. (A4) For all constants c, c * 1. (A5) For all terms u, v, u----v(u=vi\u-1) Figure 1: The axiom schemata that define attribute-value structures. 175 differs by not proposing a custom-built &amp;quot;designer logic&amp;quot; for describing feature structures, but instead uses standard first-order logic to axiomatize attribute-value structures and express constraints on them, including disj</context>
</contexts>
<marker>7.</marker>
<rawString>Gazclar, G., G. K. Pullum, R. Carpenter, E. Klein, T. E. Hukari and R. D. Levine. &amp;quot;Category Structures.&amp;quot; Computational Linguistics. 14.1: 1 -.20,1988.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Y Gurevich</author>
</authors>
<title>The Decision Problem for Standard Classes.&amp;quot;</title>
<date>1976</date>
<journal>ISL.</journal>
<volume>41</volume>
<pages>460--464</pages>
<marker>8.</marker>
<rawString>Gurevich, Y. &amp;quot;The Decision Problem for Standard Classes.&amp;quot; ISL. 41.2: 460-464, 1976.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Johnson</author>
</authors>
<title>Attribute-Value Logic and the Theory of Grammar. CSLI Lecture Notes Series.</title>
<date>1988</date>
<booktitle>CSLI Lecture Notes Series. 1986 University of</booktitle>
<publisher>Chicago Press. Chicago.</publisher>
<institution>University of Chicago Press.</institution>
<location>Chicago.</location>
<contexts>
<context position="6168" citStr="[9]" startWordPosition="904" endWordPosition="904">le 1: Constraint Languages and Feature Structure Models. Author Model of Feature Structures Constraint Language Features Kaplan and Bresnan [101 Partial functions Disjunction, negation, setvalues Pereira and Shieber [17] Information Domain F=LIAFI-f-C Kasper and Rounds [11] Acyclic finite automata Disjunction Moshier and Rounds [14] Forcing sets of acyclic finite Intuitionistic negation automata Dawar and Vijayashankar 13] Acyclic finite automata Three truth values, negation Gazdar, Pull um, Carpenter, Category structures Based on propositional modal Klein, Hukari and Levine [7] logic Johnson [9] &amp;quot;Attribute-value structures&amp;quot; Classical negation, disjunction... 174 (Al) For all constants c and attributes a, a(c) = I. (A2) For all distinct pairs of constants c2, cj# c2. (A3) For all attributes a, a(1) I. (A4) For all constants c, c * 1. (A5) For all terms u, v, u----v(u=vi\u-1) Figure 1: The axiom schemata that define attribute-value structures. 175 differs by not proposing a custom-built &amp;quot;designer logic&amp;quot; for describing feature structures, but instead uses standard first-order logic to axiomatize attribute-value structures and express constraints on them, including disjunctive and negati</context>
<context position="11263" citStr="[9]" startWordPosition="1678" endWordPosition="1678"> regarded as a (possibly infinite and disconnected) attribute-value feature structure, where the model&apos;s individuals are the elements or nodes, the unary functions define how attributes take their values, the constant symbols denote constant elements, and 1 is a sink state. EXPRESSING CONSTRAINTS AS QUANTIFIER-FREE FORMULAE. Various notations are currently used to express attribute-value constraints: the constraint requiring that the value of attribute a of (the entity denoted by) x is (the entity denoted by) y is written as (x a) = yin PATR-ll [19], as (x a) = y in LFG [10], and as x(a) y in [9], for example. At the risk of further confusion we use another notation here, and write the constraint requiring that the value of attribute a of x is y as a( yThis notation emphasises the fact that attributes are modelled by functions, and simplifies the definition of Clearly for an attribute-value structure to satisfy the constraint u v then u and v must denote the same element, i.e. u = v. However this is not a sufficient condition: nurn(x) num(y) is not satisfied if num(x) or num(y) is I. Thus it is necessary that the arguments of denote identical elements distinct from the denotation of 1</context>
<context position="13122" citStr="[9]" startWordPosition="2000" endWordPosition="2000">s &amp;quot;not identical to&amp;quot; or &amp;quot;not unified with&amp;quot;, rather than &amp;quot;not unifiable with&amp;quot;. Further, since agr(xi) agr(n) agr(x) is false, even though agr(rd agr( xi) is true. Thus t t is not a theorem because of the possibility that t = 1. SATISFACTION AND UNIFICATION Given any two formulae 4 and cp, the set of models that satisfy both and p is exactly the set of models that satisfy (1) A (p. That is, the conjunction operation can be used to describe the intersection of two sets of models each of which is described by a constraint formula, even if these satisfying models do not form principal filters [11] [9]. Since conjunction is idempotent, associative and commutative, the satisfiability of a conjunction of constraint formulae is independent of the order in which the conjuncts are presented, irrespective of whether they contain negation. Thus the evaluation (i.e. simplification) of constraints containing negation can be freely interleaved with other constraints. Unification identifies or merges exactly the elements that the axiomatization implies are equal. The unification of two complex elements e and e&apos; causes the unification of elements a(e) and a(e&apos;) for all attributes a that are defined on </context>
</contexts>
<marker>9.</marker>
<rawString>Johnson, M. Attribute-Value Logic and the Theory of Grammar. CSLI Lecture Notes Series. 1988 University of Chicago Press. Chicago. CSLI Lecture Notes Series. 1986 University of Chicago Press. Chicago.</rawString>
</citation>
<citation valid="true">
<authors>
<author>H Uszkoreit</author>
</authors>
<title>Categorial unification grammar&amp;quot;, in COUNG-86,</title>
<date>1986</date>
<pages>187--194</pages>
<contexts>
<context position="786" citStr="[20]" startWordPosition="98" endWordPosition="98">02912. mj@cs.brown.edu ABSTRACT In contrast to the &amp;quot;designer logic&amp;quot; approach, this paper shows how the attribute-value feature structures of unification grammar and constraints on them can be axiomatized in classical first-order logic, which can express disjunctive and negative constraints. Because only quantifier-free formulae are used in the axiornatization, the satisfiability problem is 7Pcomplete. INTRODUCTION. Many modern linguistic theories, such as Lexical-Functional Grammar [11, Functional Unification Grammar [12] Generalized PhraseStructure Grammar [6], Categorial Unification Grammar [20] and Head-driven PhraseStructure Grammar [18], replace the atomic categories of a context-free grammar with a &amp;quot;feature structure&amp;quot; that represents the syntactic and semantic properties of the phrase. These feature structures are specified in terms of constraints that they must satisfy. Lexical entries constrain the feature structures that can be associated with terminal nodes of the syntactic tree, and phrase structure rules simultaneously constrain the feature structures that can be associated with a parents and its immediate descendants. The tree is well-formed if and only if all of these con</context>
</contexts>
<marker>20.</marker>
<rawString>Uszkoreit, H. &amp;quot;Categorial unification grammar&amp;quot;, in COUNG-86, 1986, 187-194.</rawString>
</citation>
<citation valid="false">
<authors>
<author>R Kaplan</author>
<author>J Bresnan</author>
</authors>
<title>Lexicalfunctional grammar, a formal system for grammatical representation,&amp;quot;</title>
<booktitle>in The Mental Representation of Grammatical Relations, Bresnan ed., 1982 The</booktitle>
<publisher>MIT Press.</publisher>
<location>Cambridge, Mass.</location>
<contexts>
<context position="8220" citStr="[10]" startWordPosition="1202" endWordPosition="1202">including negation) is also V-complete. A XIOMATIZING ATTRIBUTE-VALUE STRUCTURES This section shows how attribute-value structures can be axiornatizecl using first-order quantifier-free formulae with equality. In the next section we see that equality and inequality constraints on the values of the attributes can also be expressed as such formulae, so systems of these constraints can be solved using standard techniques such as the Congruence Closure algorithm [15], [5]. The close relationship between quantifierfree formulae and attribute-value constraints was first noted in Kaplan and 13resnan [10]. The elements of the attribute-value structure, both constant and complex, together with an additional element 1 constitute the domain of individuals of the intended interpretation. The attributes are unary partial functions over this domain (i.e. mappings from elements to elements) which are always undefined on constant elements. We capture this partiality by the standard technique of adding an additional element 1 to the domain to serve as the value &apos;undefined&apos;. Thus a(x) =1 if x does not have an attribute a, otherwise a(x) is the value of x&apos;s attribute a. We proceed by specifying the condi</context>
<context position="11241" citStr="[10]" startWordPosition="1672" endWordPosition="1672">for these axioms can be regarded as a (possibly infinite and disconnected) attribute-value feature structure, where the model&apos;s individuals are the elements or nodes, the unary functions define how attributes take their values, the constant symbols denote constant elements, and 1 is a sink state. EXPRESSING CONSTRAINTS AS QUANTIFIER-FREE FORMULAE. Various notations are currently used to express attribute-value constraints: the constraint requiring that the value of attribute a of (the entity denoted by) x is (the entity denoted by) y is written as (x a) = yin PATR-ll [19], as (x a) = y in LFG [10], and as x(a) y in [9], for example. At the risk of further confusion we use another notation here, and write the constraint requiring that the value of attribute a of x is y as a( yThis notation emphasises the fact that attributes are modelled by functions, and simplifies the definition of Clearly for an attribute-value structure to satisfy the constraint u v then u and v must denote the same element, i.e. u = v. However this is not a sufficient condition: nurn(x) num(y) is not satisfied if num(x) or num(y) is I. Thus it is necessary that the arguments of denote identical elements distinct fr</context>
</contexts>
<marker>10.</marker>
<rawString>Kaplan, R. and J. Bresnan. &amp;quot;Lexicalfunctional grammar, a formal system for grammatical representation,&amp;quot; in The Mental Representation of Grammatical Relations, Bresnan ed., 1982 The MIT Press. Cambridge, Mass.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R T Kasper</author>
<author>W C Rounds</author>
</authors>
<title>A logical semantics for feature structures&amp;quot;,</title>
<date>1986</date>
<booktitle>in The Proceedings of the 24th Annual Meeting of the Association for Computational Linguistics,</booktitle>
<pages>257--266</pages>
<institution>Columbia University,</institution>
<location>New York,</location>
<contexts>
<context position="4259" citStr="[11]" startWordPosition="631" endWordPosition="631">he satisfying principal filters of each of the conjuncts. Thus the set of attribute-value structures that simultaneously satisfy a set of such constraints can be characterized by computing the unification of the generators of the corresponding principal filters, and the constraints are satisfiable iff the resulting generator is not T (i.e. T represents unification failure). Standard unification-based parsers use unification in exactly this way. When disjunctions and negations of constraints are permitted, the set of satisfying attribute-value structures does not always form a principal filter [11], so the simple unificationbased technique for determining the satisfiability of feature structure constraints must be extended. Kasper and Rounds [11] provide a formal framework for investigating such constraints by reviving a distinction originally made (as far as I am aware) by Kaplan and Bresnan 1101 between the language in which feature structure constraints are expressed and the structures that satisfy these constraints. Unification is supplanted by conjunction of constraints, and disjunction and negation appear only in the constraint language, not in the feature structures themselves (a</context>
<context position="5839" citStr="[11]" startWordPosition="859" endWordPosition="859">e of the variety of feature structure models and constraint types that previous analyses have used. This paper follows Kasper and Rounds and most proposals listed in Table 1 by distinguishing the constraint language from feature structures, and restricts disjunction and negation to the constraint language alone. It 3 Cg verb Table 1: Constraint Languages and Feature Structure Models. Author Model of Feature Structures Constraint Language Features Kaplan and Bresnan [101 Partial functions Disjunction, negation, setvalues Pereira and Shieber [17] Information Domain F=LIAFI-f-C Kasper and Rounds [11] Acyclic finite automata Disjunction Moshier and Rounds [14] Forcing sets of acyclic finite Intuitionistic negation automata Dawar and Vijayashankar 13] Acyclic finite automata Three truth values, negation Gazdar, Pull um, Carpenter, Category structures Based on propositional modal Klein, Hukari and Levine [7] logic Johnson [9] &amp;quot;Attribute-value structures&amp;quot; Classical negation, disjunction... 174 (Al) For all constants c and attributes a, a(c) = I. (A2) For all distinct pairs of constants c2, cj# c2. (A3) For all attributes a, a(1) I. (A4) For all constants c, c * 1. (A5) For all terms u, v, u--</context>
<context position="13118" citStr="[11]" startWordPosition="1999" endWordPosition="1999"> means &amp;quot;not identical to&amp;quot; or &amp;quot;not unified with&amp;quot;, rather than &amp;quot;not unifiable with&amp;quot;. Further, since agr(xi) agr(n) agr(x) is false, even though agr(rd agr( xi) is true. Thus t t is not a theorem because of the possibility that t = 1. SATISFACTION AND UNIFICATION Given any two formulae 4 and cp, the set of models that satisfy both and p is exactly the set of models that satisfy (1) A (p. That is, the conjunction operation can be used to describe the intersection of two sets of models each of which is described by a constraint formula, even if these satisfying models do not form principal filters [11] [9]. Since conjunction is idempotent, associative and commutative, the satisfiability of a conjunction of constraint formulae is independent of the order in which the conjuncts are presented, irrespective of whether they contain negation. Thus the evaluation (i.e. simplification) of constraints containing negation can be freely interleaved with other constraints. Unification identifies or merges exactly the elements that the axiomatization implies are equal. The unification of two complex elements e and e&apos; causes the unification of elements a(e) and a(e&apos;) for all attributes a that are defined</context>
</contexts>
<marker>11.</marker>
<rawString>Kasper, R. T. and W. C. Rounds. &amp;quot;A logical semantics for feature structures&amp;quot;, in The Proceedings of the 24th Annual Meeting of the Association for Computational Linguistics, Columbia University, New York, 1986, 257-266.</rawString>
</citation>
<citation valid="false">
<authors>
<author>M Kay</author>
</authors>
<title>Unification in Grammar,&amp;quot;</title>
<booktitle>in Natural Language Understanding and Logic Programming, Dahl and Saint—Dizier ed., 1985 North Holland.</booktitle>
<location>Amsterdam, The Netherlands.</location>
<contexts>
<context position="709" citStr="[12]" startWordPosition="89" endWordPosition="89">ognitive and Linguistic Sciences, Box 1978, Brown University, Providence, RI 02912. mj@cs.brown.edu ABSTRACT In contrast to the &amp;quot;designer logic&amp;quot; approach, this paper shows how the attribute-value feature structures of unification grammar and constraints on them can be axiomatized in classical first-order logic, which can express disjunctive and negative constraints. Because only quantifier-free formulae are used in the axiornatization, the satisfiability problem is 7Pcomplete. INTRODUCTION. Many modern linguistic theories, such as Lexical-Functional Grammar [11, Functional Unification Grammar [12] Generalized PhraseStructure Grammar [6], Categorial Unification Grammar [20] and Head-driven PhraseStructure Grammar [18], replace the atomic categories of a context-free grammar with a &amp;quot;feature structure&amp;quot; that represents the syntactic and semantic properties of the phrase. These feature structures are specified in terms of constraints that they must satisfy. Lexical entries constrain the feature structures that can be associated with terminal nodes of the syntactic tree, and phrase structure rules simultaneously constrain the feature structures that can be associated with a parents and its i</context>
</contexts>
<marker>12.</marker>
<rawString>Kay, M. &amp;quot;Unification in Grammar,&amp;quot; in Natural Language Understanding and Logic Programming, Dahl and Saint—Dizier ed., 1985 North Holland. Amsterdam, The Netherlands.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J T Maxwell</author>
<author>R Kaplan</author>
</authors>
<title>An Overview of Disjunctive Constraint Satisfaction&amp;quot;,</title>
<date>1989</date>
<booktitle>in International Workshop on Parsing Technologies,</booktitle>
<volume>18</volume>
<pages>27</pages>
<location>Pittsburgh, PA.,</location>
<contexts>
<context position="18880" citStr="[13]" startWordPosition="2932" endWordPosition="2932">per has shown how attribute-value structures and constraints on them can be axiomatized in a decidable class of first-order logic. The primary advantage of this approach over the &amp;quot;designer logic&amp;quot; approach is that important properties of the logic of the feature constraint language, such as soundness, completeness, decidability and compactness, follow immediately, rather than proven from scratch. A secondary benefit is that the substantial body of work on satisfiability algorithms for first-order formulae (such as ATMS-based techniques that can efficiently evaluate some disjunctive constraints [13]) can immediately be applied to feature structure constraints. Further, first-order logic can be used to axiornatize other types of feature structures in addition to attribute-value structures (such as &amp;quot;set-valued&amp;quot; elements) and express a wider variety of constraints than equality constraints (e.g. subsumption constraints). In general these extended systems cannot be axiornatized using only quantifier-free formulae, so their decidability may not follow directly as it does here. However the decision problem for sublanguages of first-order logic has been intensively investigated [4], and there a</context>
</contexts>
<marker>13.</marker>
<rawString>Maxwell, J. T., III and R. Kaplan. &amp;quot;An Overview of Disjunctive Constraint Satisfaction&amp;quot;, in International Workshop on Parsing Technologies, Pittsburgh, PA., 1989, 18 —27. Carnegie Mellon.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M D Moshier</author>
<author>W C Rounds</author>
</authors>
<title>A logic for partially specified data structures&amp;quot;,</title>
<date>1987</date>
<booktitle>in The ACM Symposium on the Principles of Programming Languages,</booktitle>
<location>Munich,</location>
<contexts>
<context position="5899" citStr="[14]" startWordPosition="867" endWordPosition="867">types that previous analyses have used. This paper follows Kasper and Rounds and most proposals listed in Table 1 by distinguishing the constraint language from feature structures, and restricts disjunction and negation to the constraint language alone. It 3 Cg verb Table 1: Constraint Languages and Feature Structure Models. Author Model of Feature Structures Constraint Language Features Kaplan and Bresnan [101 Partial functions Disjunction, negation, setvalues Pereira and Shieber [17] Information Domain F=LIAFI-f-C Kasper and Rounds [11] Acyclic finite automata Disjunction Moshier and Rounds [14] Forcing sets of acyclic finite Intuitionistic negation automata Dawar and Vijayashankar 13] Acyclic finite automata Three truth values, negation Gazdar, Pull um, Carpenter, Category structures Based on propositional modal Klein, Hukari and Levine [7] logic Johnson [9] &amp;quot;Attribute-value structures&amp;quot; Classical negation, disjunction... 174 (Al) For all constants c and attributes a, a(c) = I. (A2) For all distinct pairs of constants c2, cj# c2. (A3) For all attributes a, a(1) I. (A4) For all constants c, c * 1. (A5) For all terms u, v, u----v(u=vi\u-1) Figure 1: The axiom schemata that define attri</context>
<context position="16899" citStr="[14]" startWordPosition="2623" endWordPosition="2623">tisfying models do not always form a filter (i.e. they are not always upward closed f161). Nevertheless, the quantifier-free language itself is capable of characterizing exactly the set of feature structures that satisfy any boolean combination of constraints, so the failure of upward closure is not a fatal flaw of this approach. At a methodological level, I claim that after the mathematical consequences of two different interpretations of feature structure constraints have been investigated, such as the classical and intuitionistic interpretations of negation in feature structure constraints [14], it is primarily a linguistic question as to which is better suited to the description of natural language. I have been unable to find any linguistic analyses which can yield a set of constraints whose satisfiablity varies under the classical and intuitionistic interpretations, so the choice between classical and intuitionistic negation may be moot. For reasons of space the following example (based on Pereira&apos;s example 1161 demonstrating a purported problem arising from the failure of upward closure with classical negation) exhibits only negative constraints. Example: The conjunction of the f</context>
</contexts>
<marker>14.</marker>
<rawString>Moshier, M. D. and W. C. Rounds. &amp;quot;A logic for partially specified data structures&amp;quot;, in The ACM Symposium on the Principles of Programming Languages, Munich, Germany, 1987, Association for Computing Machinery.</rawString>
</citation>
<citation valid="true">
<authors>
<author>G Nelson</author>
<author>D C Oppen</author>
</authors>
<title>Fast Decision Procedures based on Congruence Closure.&amp;quot;</title>
<date>1980</date>
<journal>J. ACM.</journal>
<volume>27</volume>
<pages>245--257</pages>
<contexts>
<context position="7446" citStr="[15]" startWordPosition="1094" endWordPosition="1094">Value Logic [9] which does not allow values to be used as attributes (although it would be easy to do this). The soundness and completeness proofs in 191 and other papers fisted in Table 1 are not required here because these results are well-known properties of firstorder logic. Since both the axiornatizion and the constraints are actually expressed in a decidable class of first-order formulae, viz, quantifier-free formulae with equality,1 the decidability of feature structure constraints follows trivially, in fact, because the satisfiability problem for quantifier-free formulae is V-complete [15] and the relevant portion of the axiomatization and translation of constraints can be constructed in polynomial time, the satisfiability problem for feature constraints (including negation) is also V-complete. A XIOMATIZING ATTRIBUTE-VALUE STRUCTURES This section shows how attribute-value structures can be axiornatizecl using first-order quantifier-free formulae with equality. In the next section we see that equality and inequality constraints on the values of the attributes can also be expressed as such formulae, so systems of these constraints can be solved using standard techniques such as </context>
</contexts>
<marker>15.</marker>
<rawString>Nelson, G. and D. C. Oppen. &amp;quot;Fast Decision Procedures based on Congruence Closure.&amp;quot; J. ACM. 27.2: 245-257, 1980.</rawString>
</citation>
<citation valid="true">
<authors>
<author>F C N Pereira</author>
</authors>
<title>Grammars and Logics of Partial Information&amp;quot;,</title>
<date>1987</date>
<booktitle>in The Proceedings of the international Conference on Logic Programming,</booktitle>
<location>Melbourne, Australia,</location>
<contexts>
<context position="2567" citStr="[16]" startWordPosition="363" endWordPosition="363">tributes. Complex elements have zero or more attributes, whose values may be any other element in the structure (including a complex element) and any element can be the value of zero, one or several attributes. Attributes are partial: it need not he the case that every attribute is defined for every complex element. The set of attribute-value structures partially ordered by the subsumption relation (together with an additional entity T that every attribute-value structure subsumes) forms a lattice, and the join operation on this lattice is called the unification operation 1191. Example: (from [16]). The attrthute-value structure (1) has six complex elements labelled Cl e6 and two constant elements, singular and third. The complex element ei has two attributes, sub] and preil, the value of which are the complex elements e2 and e3 respectively. e7 (2) pred subj The unification of elements el of (1) and e7 of (2) results in the attribute-value structure (3), the el verb (1) subjpred te5 e2 agr agr ef, number person singular third verb )elo agr 173 minimal structure in the subsumption lattice which subsumes both (1) and (2). e7 (3) subj „ed Z e2 es agr 4 eb a r number 11 person singular th</context>
</contexts>
<marker>16.</marker>
<rawString>Pereira, F. C. N. &amp;quot;Grammars and Logics of Partial Information&amp;quot;, in The Proceedings of the international Conference on Logic Programming, Melbourne, Australia, 1987.</rawString>
</citation>
<citation valid="true">
<authors>
<author>F C N Pereira</author>
<author>S M Shieber</author>
</authors>
<title>The semantics of grammar formalisms seen as computer languages&amp;quot;,</title>
<date>1984</date>
<booktitle>in CO LING-84,</booktitle>
<pages>123--129</pages>
<institution>Stanford University,</institution>
<contexts>
<context position="5785" citStr="[17]" startWordPosition="852" endWordPosition="852">as negative feature constraints). Table 1 sketches some of the variety of feature structure models and constraint types that previous analyses have used. This paper follows Kasper and Rounds and most proposals listed in Table 1 by distinguishing the constraint language from feature structures, and restricts disjunction and negation to the constraint language alone. It 3 Cg verb Table 1: Constraint Languages and Feature Structure Models. Author Model of Feature Structures Constraint Language Features Kaplan and Bresnan [101 Partial functions Disjunction, negation, setvalues Pereira and Shieber [17] Information Domain F=LIAFI-f-C Kasper and Rounds [11] Acyclic finite automata Disjunction Moshier and Rounds [14] Forcing sets of acyclic finite Intuitionistic negation automata Dawar and Vijayashankar 13] Acyclic finite automata Three truth values, negation Gazdar, Pull um, Carpenter, Category structures Based on propositional modal Klein, Hukari and Levine [7] logic Johnson [9] &amp;quot;Attribute-value structures&amp;quot; Classical negation, disjunction... 174 (Al) For all constants c and attributes a, a(c) = I. (A2) For all distinct pairs of constants c2, cj# c2. (A3) For all attributes a, a(1) I. (A4) Fo</context>
</contexts>
<marker>17.</marker>
<rawString>Pereira, F. C. N. and S. M. Shieber. &amp;quot;The semantics of grammar formalisms seen as computer languages&amp;quot;, in CO LING-84, Stanford University, 1984, 123-129. The Association for Computational Linguistics.</rawString>
</citation>
<citation valid="true">
<authors>
<author>C Pollard</author>
<author>I Sag</author>
</authors>
<title>Information-based Syntax and Semantics, Volume 7. CSLI Lecture Notes.</title>
<date>1987</date>
<publisher>Chicago University Press. Chicago.</publisher>
<contexts>
<context position="831" citStr="[18]" startWordPosition="104" endWordPosition="104">o the &amp;quot;designer logic&amp;quot; approach, this paper shows how the attribute-value feature structures of unification grammar and constraints on them can be axiomatized in classical first-order logic, which can express disjunctive and negative constraints. Because only quantifier-free formulae are used in the axiornatization, the satisfiability problem is 7Pcomplete. INTRODUCTION. Many modern linguistic theories, such as Lexical-Functional Grammar [11, Functional Unification Grammar [12] Generalized PhraseStructure Grammar [6], Categorial Unification Grammar [20] and Head-driven PhraseStructure Grammar [18], replace the atomic categories of a context-free grammar with a &amp;quot;feature structure&amp;quot; that represents the syntactic and semantic properties of the phrase. These feature structures are specified in terms of constraints that they must satisfy. Lexical entries constrain the feature structures that can be associated with terminal nodes of the syntactic tree, and phrase structure rules simultaneously constrain the feature structures that can be associated with a parents and its immediate descendants. The tree is well-formed if and only if all of these constraints are simultaneously satisfiable. Thus</context>
</contexts>
<marker>18.</marker>
<rawString>Pollard, C. and I. Sag. Information-based Syntax and Semantics, Volume 7. CSLI Lecture Notes. 1987 Chicago University Press. Chicago.</rawString>
</citation>
<citation valid="false">
<authors>
<author>S M Shieber</author>
</authors>
<title>An introduction to Unification-based Approaches to Grammar.</title>
<contexts>
<context position="11215" citStr="[19]" startWordPosition="1664" endWordPosition="1664">above. In fact, any model for these axioms can be regarded as a (possibly infinite and disconnected) attribute-value feature structure, where the model&apos;s individuals are the elements or nodes, the unary functions define how attributes take their values, the constant symbols denote constant elements, and 1 is a sink state. EXPRESSING CONSTRAINTS AS QUANTIFIER-FREE FORMULAE. Various notations are currently used to express attribute-value constraints: the constraint requiring that the value of attribute a of (the entity denoted by) x is (the entity denoted by) y is written as (x a) = yin PATR-ll [19], as (x a) = y in LFG [10], and as x(a) y in [9], for example. At the risk of further confusion we use another notation here, and write the constraint requiring that the value of attribute a of x is y as a( yThis notation emphasises the fact that attributes are modelled by functions, and simplifies the definition of Clearly for an attribute-value structure to satisfy the constraint u v then u and v must denote the same element, i.e. u = v. However this is not a sufficient condition: nurn(x) num(y) is not satisfied if num(x) or num(y) is I. Thus it is necessary that the arguments of denote iden</context>
</contexts>
<marker>19.</marker>
<rawString>Shieber, S. M. An introduction to Unification-based Approaches to Grammar.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>