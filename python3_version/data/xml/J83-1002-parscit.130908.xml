<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<title confidence="0.997783">
Denotational Semantics for &amp;quot;Natural&amp;quot;
Language Question-Answering Programs&apos;
</title>
<author confidence="0.7283365">
Michael G. Main2
David B. Benson
</author>
<affiliation confidence="0.9813015">
Department of Computer Science
Washington State University
</affiliation>
<address confidence="0.557802">
Pullman, WA 99164-1210
</address>
<bodyText confidence="0.994759428571429">
Scott-Strachey style denotational semantics is proposed as a suitable means of commu-
nicating the specification of &amp;quot;natural&amp;quot; language question answerers to computer program-
mers and software engineers. The method is exemplified by a simple question answerer
communicating with a small data base. This example is partly based on treatment of
fragments of English by Montague. Emphasis is placed on the semantic interpretation of
questions. The &amp;quot;meaning&amp;quot; of a question is taken as a function from the set of universes to
a set of possible answers.
</bodyText>
<sectionHeader confidence="0.990135" genericHeader="abstract">
1. Introduction
</sectionHeader>
<bodyText confidence="0.999977913043479">
We advocate the use of Scott-Strachey denotational
semantics for &amp;quot;natural&amp;quot; language question-answering
programs. The majority of this paper demonstrates
the use of denotational semantics for a small question
answerer. The types of questions possible are similar
to those in Harris (1979), Winograd (1972), and
Woods (1972). The analysis is not as deep as in Kart-
tunen (1977) or similar studies, as it is oriented to the
specification of useful, but linguistically modest, capa-
bilities.
Before the demonstration, we discuss the benefits
of formal semantics and why denotational semantics is
an appropriate formalization. The semantics of a
question answerer is given by defining the action of
the program for each possible input. An informal
semantic description, perhaps in narrative form, is
necessary for a potential user who wants to know what
questions he may ask and what sort of answers the
program will provide. Informal meanings are also
valuable to the designer and implementer of a question
answerer. However, the designer and implementer
must understand all aspects of a proposed question
answerer in a precise unambiguous way that informal
</bodyText>
<footnote confidence="0.764899">
1 This research was supported in part by NSF grants
MCS7708486 and MCS8003433.
</footnote>
<affiliation confidence="0.8452095">
2 Current Address: Department of Computer Science, Uni-
versity of Colorado, Boulder, CO 80309.
</affiliation>
<bodyText confidence="0.9687460625">
methods do not provide. In short, a formal method of
specifying the semantics is needed at the design and
implementation stage (see Ashcroft and Wadge 1982).
Once a formal semantics has been given, it can be
put to other uses as well. It can provide the basis for
a rigorous proof of correctness of an implementation.
Furthermore, formal specifications might allow partial
automation of the implementation process in the same
way that automatic compiler-writers produce parts of a
compiler from a formal specification of a programming
language (see Johnson 1975). With the advent of at
least one commercially available &amp;quot;natural&amp;quot; language
question-answering program (Harris 1979), these ad-
vantages become even more concrete.
If there is a familiarity to these arguments, it is
because the same reasoning is used to justify formal
semantics for programming languages. The problems
of design and analysis of question answerers are much
the same for programming languages — Benson (1975)
argues this point at length. An obvious approach is to
apply a programming language technique — denotation-
al semantics — to the problem of formally specifying a
question answerer. As a bonus, the method is under-
stood by many programmers and software engineers
through introductory textbooks such as Stoy (1977),
Gordon (1979), McGettrick (1980), Pagan (1981),
and Tennent (1981). Additionally, linguistic treat-
ments of natural language, such as Montague (1973),
are basically denotational and we can modify such
Copyright 1983 by the Association for Computational Linguistics. Permission to copy without fee all or part of this material is granted
provided that the copies are not made for direct commercial advantage and the Journal reference and this copyright notice are included on
the first page. To copy otherwise, or to republish, requires a fee and/or specific permission.
</bodyText>
<page confidence="0.401714">
0362-613X/83/010011-11$03.00
</page>
<note confidence="0.94636">
American Journal of Computational Linguistics, Volume 9, Number 1, January-March 1983 11
Michael G. Main and David B. Benson Denotational Semantics for &apos;Natural&apos; Language Q-A Programs
</note>
<bodyText confidence="0.999541424242424">
treatments to meet our needs.
In denotational semantics for programming lan-
guages, evaluation functions map program segments
into objects in various semantic domains. These ob-
jects are taken as the meanings of the program seg-
ments, and determine the output of a program. Simi-
larly, in the semantics of a question answerer, evalua-
tion functions map input (questions) into objects that
determine the output (answers).
Deciding what objects are in the semantic domains
has a fundamental effect on the capabilities of the
overlying question answerer, as well as an effect on
the usefulness and clarity of the semantic descriptions.
Lewis (1972) discusses these considerations for natu-
ral language sentences and the domains described in
section 2 are based on his, although the treatment of
questions is closer to Ajdukiewicz (1926). Also intro-
duced in section 2 are the lambda expressions that
denote individual semantic objects. Such expressions
have been used in denotational semantics of program-
ming languages (see Scott 1970, Milne and Strachey
1976, Stoy 1977) and in treatments of fragments of
English by Montague (1973).
In section 3, evaluation functions mapping inputs
for a small question answerer to objects in the seman-
tic domain are given. The allowable questions are
defined by a category grammar as has been done by
Ajdukiewicz (1935), Carnap (1937), Lewis (1972),
Montague (1973), and others. An account of the
answer relationship is given in section 4.
In the final section, we briefly describe an imple-
mentation of the question answerer and suggest some
broad principles for designing question answerers.
</bodyText>
<sectionHeader confidence="0.760037" genericHeader="keywords">
2. Semantic Domains for Natural Language
</sectionHeader>
<subsectionHeader confidence="0.875873">
2.1 The Domains
</subsectionHeader>
<bodyText confidence="0.9999776">
A semantic domain is a set of objects. The objects are
meanings of syntactic constructs; in our case the syn-
tactic constructs are natural language phrases. In de-
notational semantics for programming languages, the
semantic domains often have some order imposed on
the objects to treat recursively defined functions. The
specification of a question answerer may also involve
explicit recursively defined questions, although in this
demonstration only quantification is used and not re-
cursion. This does not prevent an implementation
from using recursion — almost surely it will, to handle
the quantification. But lack of recursion does allow us
to use unordered semantic domains, as described be-
low.
One domain is the set of objects about which ques-
tions will be asked, e.g., moon rocks, toy blocks, or
whatever. We are not concerned with the internal
structure of these objects; hence they are called atoms
and the domain is designated A. Two other domains
are the set of natural numbers, designated N, and the
set of truth values {true, falsel, designated T.
A fourth domain is the set of possible universes,
designated U. Intuitively, a universe is a description
of properties of atoms, the relationships between at-
oms, the relationships between relationships, etc.... A
universe is usually a partial description including only
the properties and relationships of interest. For exam-
ple, in the toy blocks world (Winograd 1972) a uni-
verse is the specification of the size, shape, color, and
position of all the blocks in the scene. A toy blocks
universe does not include a description of the density,
mass, or material composition of the various blocks.
In application, the set of possible universes may be
called a &amp;quot;data base&amp;quot;, and each actual universe is a
specific state or configuration of the data base. The
internal structure of such a data base is left unspeci-
fied in this paper.
Other semantic domains are built from the four
basic domains. For example, the set of functions from
universes to truth values, designated [U.1], is a new
domain. In general, if X and Y designate sets, then
[X-..&apos;Y] designates the set of functions from X to Y.
Other semantic domains could be conceived (e.g.,
product or sum domains), but function domains will be
adequate for our examples.
</bodyText>
<subsectionHeader confidence="0.999874">
2.2 Assigning domains to syntactic categories
</subsectionHeader>
<bodyText confidence="0.99997752173913">
Natural language phrases have been divided into many
different categories (see Kahn 1978). Exactly which
categories are used depends upon syntax. In the cate-
gory grammar of section 3, the categories include sen-
tence, intransitive verb, common noun, noun group,
noun modifier, numeral, and so on. There are also
separate interrogative categories for phrases that ask a
question, such as how many stones.
To each syntactic category, a semantic domain is
assigned. The meaning of a phrase is an object in the
assigned domain. Ultimately, from the meaning of a
question, we will derive its answer. But first we assign
domains to non-interrogative categories, beginning
with the category of sentences.
A declarative sentence is a proposition — that is,
something to which a truth value can be assigned. The
meaning of a sentence somehow determines what that
truth value is in any possible universe. So, an appro-
priate semantic object for a sentence is a function
from possible universes to truth values. The domain
assigned to the category of sentences is therefore
[U-.-T], which we will designate S. If a declarative
sentence has a meaning a S, and [3 is a universe, then
</bodyText>
<footnote confidence="0.9790556">
/3 is true just if the sentence is true in the universe 0.3
3 Lower case Greek letters are semantic objects. Juxtaposi-
tion indicates functional application and associates left-to-right.
Thus, al3 means the function a applied to the argument /3, and afly
means (a(/3))(7).
</footnote>
<page confidence="0.820885">
12 American Journal of Computational Linguistics, Volume 9, Number 1, January-March 1983
</page>
<note confidence="0.783017">
Michael G. Main and David B. Benson Denotational Semantics for &apos;Natural&apos; Language Q-A Programs
</note>
<bodyText confidence="0.999949289473684">
If there is a single fixed universe, then sentences could
be assigned meanings in T alone. However, question
answerers are generally based on a changeable uni-
verse or data base. Hence, the [U.T] approach is
needed to give a fixed meaning to a sentence whose
truth value may vary from universe to universe.
Both common nouns and intransitive verbs define
subsets of A. The subset of stone (a common noun) is
the set of atoms that are stones. The subset for the
intransitive verb phrase belong to Preston is the set of
atoms that belong to Preston. The meaning of such a
phrase determines what that subset is for any possible
universe. This can be done by an object in
[U.[A-&gt;T]] (i.e., functions from U to [A-&gt;T]). This
domain is assigned to both common noun and intransi-
tive verb categories, and is designated by C. If a com-
mon noun has a meaning aEC, and /3 is a universe and
y an atom, then agy is true just if y is in the subset
defined by the common noun in the universe /3 — and
similarly for intransitive verbs.
For most other syntactic categories, the semantic
domain is determined by how phrases in that category
combine with sentences, common nouns, intransitive
verbs, and other phrases to form new phrases. For
example, a noun group combines with an intransitive
verb to form a sentence. Therefore, a semantic object
for a noun group should take a semantic object from C
(the domain for intransitive verbs) and yield a seman-
tic object from S (the domain for sentences). Thus,
the semantic domain for noun groups is [C-øS].4
Similarly, a noun modifier, such as black, combines
with a common noun, such as stone, to form a new
common noun — black stone. So, the semantic domain
for noun modifiers is [C-&gt;C]. By examining the syn-
tactic rules, this method can be applied to most cate-
gories.5 Occasional exceptions can be made — for
example, numerals are assigned the domain, N, of
natural numbers.
</bodyText>
<subsectionHeader confidence="0.999517">
2.3 Interrogative categories
</subsectionHeader>
<bodyText confidence="0.9996112">
So far, the categories include only non-interrogative
phrases. Syntactically, the interrogative phrases paral-
lel the non-interrogatives, but semantically an interro-
gative lacks something. For example, Ajdukiewicz
(1926) would represent the meaning of the interroga-
</bodyText>
<footnote confidence="0.9944505">
4 A name, such as John, is one type of noun group that de-
notes a particular atom which does not change from universe to
universe Therefore, it might be better to have names in a separate
syntactic category with assigned semantic domain A. But, doing
this would not do away with the category noun group, since some
noun phrases are not names (e.g., every stone). But, having two
categories unduly complicates the syntax, so we lump names togeth-
er with other noun groups, and treat them as Montague (1973) has.
5 This method of assigning semantic domains is an application
of Frege&apos;s rule of compositionality, which says that the meaning of
a compound phrase is composed from the meaning of its parts.
(Frege 1892, van Emde Boas and Janssen 1979)
</footnote>
<bodyText confidence="0.999785787878788">
tive sentence what is black and white and read all over
as: ?x(x is black and white and read all over). Here, x
is a variable and &amp;quot;?&amp;quot; a quantifier indicating the lack.
In this case, the range of the variable is the set of
noun group phrases that could answer the question.
There are also interrogative phrases in other cate-
gories, such as the intransitive verb phrase owns what.
And it is not always a noun group that is missing; for
example, the noun group how many stones lacks a nu-
meral. In general, any non-interrogative category is
made into an interrogative category by indicating what
is lacking. Hence, if X and Y are non-interrogative
categories, then X?Y designates the category of inter-
rogative phrases that are syntactically like X-phrases
but semantically lack a Y-phrase.6 If Y has semantic
domain Y and X has semantic domain X, then X?Y will
have semantic domain [Y-.X}. Furthermore, if an
interrogative phrase in X?Y has a meaning a [Y.X],
then al3 is that object of X that results when pc Y an-
swers the interrogative.
For example, the interrogative sentence who killed
cock robin will have a meaning a E [[C-+S]-0S], since it
is a sentence (domain S) lacking a noun group
(domain [C-&gt; S]). If the sparrow has a meaning
pE[c.s], and the sparrow killed cock robin has a
meaning y €S, then al3=y.
A similar idea can be applied to one other catego-
ry: yes—no questions. Such an interrogative lacks a
truth value, so the semantic domain assigned to yes—no
questions is [T-0.S]. If a [T-0.S] is the meaning of a
yes—no question, then s(true)ES is the meaning of the
sentence when it is answered by yes, and similarly for
an a(false).
</bodyText>
<subsectionHeader confidence="0.999638">
2.4 Lambda expressions
</subsectionHeader>
<bodyText confidence="0.965128418181818">
Up to this point, semantic objects have been described
in English. In order to be more precise, a formal no-
tation is needed. We use a typed lambda expression
for denoting functions, similar to the lambda calculi of
Church (1951).
Every lambda expression has a type that indicates
the semantic domain of the object denoted by the
expression. These types are in one-to-one correspon-
dence with the semantic domains (A, U, T, N,
etc....), so we will use the same letters in ordinary
typescript for the expression types (A, U, T, N,
[U.-...T], etc....).
The expressions of each type include a set of con-
stants and a denumerable set of variables. A function
that maps the constants into semantic objects is an
interpretation, and generally remains fixed. A func-
tion that maps variables into semantic objects is a
variable assignment and, as its name suggests, will
6 This could be extended to include phrases, like who does
what, which question more than one thing at a time.
American Journal of Computational Linguistics, Volume 9, Number 1, January-March 1983 13
Michael G. Main and David B. Benson Denotational Semantics for &apos;Natural&apos; Language Q-A Programs
change. If 4/ is a variable assignment, x is a variable
of any type, and a is an object from the semantic do-
main of x, then tp[a/x] is a changed variable assign-
ment that is like tp except that Ip[a/x] assigns a to the
variable x. In this way, new variable assignments are
formed from old. Finally, each lambda expression
denotes one semantic object, but which object this is
varies as the variable assignment changes. So, for an
expression b the notation 11b114i is to denote the se-
mantic object for the expression b, with variable as-
signment tP.7
Table 1 gives recursive rules defining lambda ex-
pressions and the semantic objects they denote. We
take as given a set of constants and a denumerable set
of variables for each type, and a fixed interpretation,
tp. X and Y are arbitrary types, with corresponding
semantic domains X and Y.
Some lambda expressions can be derived more than
one way. Any such ambiguities are resolved as fol-
lows:
a. The expression following a lambda abstraction (i.e.,
Ax) or a quantifier (i.e., 3x, Vx, 3nx,) will be as
long as possible — that is, to the first unmatched
right parenthesis or to the end of the entire expres-
sion.
b. The unary operator has higher priority than any
of the binary operators (A, V, =, and
functional application, which is indicated by juxta-
position). Functional application has the highest
priority of the binary operators and associates left-
to-right, e.g., bcd.(bc)d. The other binary opera-
tors have equal precedence and also associate left-
to-right, e.g., bcAdcVc = ((bc)A(dc))Vc.
</bodyText>
<sectionHeader confidence="0.76371" genericHeader="introduction">
3. Syntax and Semantics of a Small Question
Answerer
</sectionHeader>
<subsectionHeader confidence="0.999984">
3.1 Syntactic categories
</subsectionHeader>
<bodyText confidence="0.994733021276596">
To illustrate the mechanics of the previous section, we
give the syntax and semantics of a small question an-
swerer. The question answerer accepts questions
about configurations of pieces in the game of Go.
Briefly, a configuration consists of a 19 by 19 grid of
points, labeled A-1 through S-19. Each point may
contain a black or a white stone. Like-colored stones,
connected horizontally or vertically, form blocks.
Empty points adjacent to a block are that block&apos;s lib-
erties. Each configuration is a universe in the seman-
tic domain U.
The syntax for a question answerer must answer
the question: what phrases are grammatically correct
input to the question answerer? Our approach uses
various syntactic categories, in the style of Montague
7 The semantic object associated with a lambda expression
also depends on the interpretation function, but we assume this is
fixed.
(1973). A syntactic category is a set of phrases, in-
cluding basic phrases and derived phrases. The de-
rived phrases are specified by recursive syntactic rules
that describe how phrases from various categories
combine to form new phrases.
The syntax presented here has two kinds of cate-
gories. First, non-interrogative categories, whose
phrases do not ask questions. These categories are
listed in Table 2, along with an abbreviation for each,
the lists of basic expressions, and the associated se-
mantic domains from section 2. In the table, A-1,
A-2, and so on are names of points on the Go board.
The basic phrases heo, hei, theyo, theyi, and so on are
used as variables in a manner made precise by syntac-
tic rules given later.
The second kind of category is the interrogative
category. Syntactically, an interrogative category be-
haves like some non-interrogative category, but it also
asks a question whose answer is from some other non-
interrogative category. If a phrase is syntactically like
a phrase from category X, and asks a question whose
answer is in category Y, then that phrase is in a cate-
gory X?Y. This separation of interrogatives is needed
because the semantic domain for interrogatives differs
from that for non-interrogatives (see section 2.3).
One additional interrogative category does not follow
the X?Y pattern — the yes—no questions. We designate
this category YN and list it in Table 3 with the other
interrogative categories.
</bodyText>
<subsectionHeader confidence="0.999811">
3.2 Syntactic and semantic rules
</subsectionHeader>
<bodyText confidence="0.9999259">
We now give syntactic rules that define the phrases of
each category. With each syntactic rule is a semantic
rule. For each phrase that a syntactic rule creates, the
corresponding semantic rule tells precisely how to
translate that phrase into a lambda expression denot-
ing the meaning of the phrase. In these rules, italic
letters (u, v, w, ...) are arbitrary phrases from any
category and F1, F2, ..., are functions that combine
phrases to yield new phrases. Variables in lambda
expressions are of the following types.
</bodyText>
<listItem confidence="0.999889222222222">
• m,m&apos;,...of type N.
• t,t&apos;,... of type T.
• u,u&apos;,... of type U.
• x,x&apos;,... of type C.
• y,y&apos;,... of type [C-.51.
• qi is the (2i+3)th variable of type A.
• P1 is the (2i+4)th variable of type A.
• z is the first variable of type A.
• z&apos; is the second variable of type A.
</listItem>
<page confidence="0.758353">
14 American Journal of Computational Linguistics, Volume 9, Number 1, January-March 1983
</page>
<note confidence="0.882983">
Michael G. Main and David B. Benson Denotational Semantics for &apos;Natural&apos; Language Q-A Programs
</note>
<sectionHeader confidence="0.811437" genericHeader="method">
LAMBDA EXPRESSION SEMANTIC OBJECT
</sectionHeader>
<listItem confidence="0.980664304347826">
1. If b is a constant of type X, then b is an expression
of type X.
2. If x is a variable of type X, then x is an expression
of type X.
3. If b is an expression of type X, then (b) is also an
expression of type X.
4. If b is an expression of type Y and x is a variable
of type X, then Xx.b is an expression of type [X-0.Y].
5. If b is an expression of type [X-&gt;Y] and c is an
expression of type X, then be is an expression of type
Y.
6. If b and c are expressions of type X, then b = c is
an expression of type T.
7. If b and c are expressions of type T, then - b, bAc,
bVc, b+c, and b&lt;=&gt;c are expressions of type T.
8. If n is an expression of type N, then n+1 is an
expression of type N.
9. If b is an expression of type T and x is a variable
of type X, then 3x.b and Vx.b are expressions of type
T.
10. If b is an expression of type T, x is a variable of
type X and n is an expression of type N, then 3nx.b is
an expression of type T.
</listItem>
<bodyText confidence="0.70796725">
II b II IP is (pi) (i.e., the interpretation cp applied to the
constant b).
II x 0 IP is tpx (i.e., the variable assignment IP applied to
the variable x).
</bodyText>
<equation confidence="0.925912555555555">
II (b) hi, is II 1111 0.
II Ax.b II tP is that function a:X-0.Y, such that for every
13€ X, ai3 = lb II 0[13/x1.
II be II IP is the function II b II IP applied to the argument
II eIIIP.
I b
I Ickiiii is true iff II b II is the same semantic ob
je -
ct= c
</equation>
<bodyText confidence="0.888524666666667">
as II
II -.1:1 II 0 is true iff II b Ikti is false, and similarly for A
(and), V (or), (implication), and ..&gt; (coincidence).
111&apos;1+1 HIP is the natural number successor of II 110 0.
II 3x.b II IP is true iff there exists an a E X, such that
lb II ii[a/x] is true. II Vx.b Il IP is II -.3x.-,b II IP.
Let n = II n II 0. Then 0 3nx.b II 1P is true iff there exist
n distinct objects in X, so that for any of these n ob-
jects, say a, ll b II Vi[ce/X] is true.
</bodyText>
<tableCaption confidence="0.998408">
Table 1. Lambda expressions and their semantic objects.
</tableCaption>
<table confidence="0.885566857142857">
American Journal of Computational Linguistics, Volume 9, Number 1, January-March 1983 15
Michael G. Main and David B. Benson Denotational Semantics for &apos;Natural Language Q-A Programs
SYNTACTIC CATEGORY SEMANTIC DOMAIN &amp; BASIC PHRASES
SE (sentence) S = [U.T].
No basic phrases.
CN (common noun) C = [U-D.[A-&gt;T]].
player, block, stone, liberty, point
IV (intransitive verb) C.
exist
NG (noun group) [C -,.. S].
Black, White, heo, hei,..., theyo, theyi,..., A-1, A-2, ...
TV (transitive verb) [[C-&gt;S]-&gt;C].
own, belong to
NM (noun modifier) [C-C}.
black, white
MG (modifying group) [C.O.
No basic phrases.
PP (preposition or participial) [[C-.S]-...[C-&gt;C]].
at, with, owning, belonging to
NU (numerals) N
0, 1, 2, ...
</table>
<tableCaption confidence="0.986303">
Table 2. Syntactic categories (non-interrogative).
</tableCaption>
<table confidence="0.890557">
SYNTACTIC CATEGORY SEMANTIC DOMAIN &amp; BASIC PHRASES
YN (yes-no question) [T-.S].
No basic phrases.
NG?NG (noun group questioning a noun group) [[C-.S]...[C-.S]].
</table>
<bodyText confidence="0.82088">
who, what
For any two non-interrogative categories, X and Y, [Y-..X], where X is X&apos;s domain and Y is Y&apos;s domain.
X?Y is an interrogative category. None of these categories, except NG?NG, have basic
phrases.
</bodyText>
<tableCaption confidence="0.992277">
Table 3. Syntactic categories (interrogative).
</tableCaption>
<page confidence="0.469894">
16 American Journal of Computational Linguistics, Volume 9, Number 1, January-March 1983
</page>
<note confidence="0.784167">
Michael G. Main and David B. Benson Denotational Semantics for &apos;Natural&apos; Language Q-A Programs
</note>
<subsectionHeader confidence="0.656873">
3.2.1 The basic rule
</subsectionHeader>
<bodyText confidence="0.953438485714286">
Syntactic Rule:
RI. For each category, its basic phrases are phrases.
Semantics:
We give a translation of each basic phrase, according
to which category it is in:
CN,IV: player translates to a constant of type C,
denoted player; and similarly for any other basic
phrase of category CN or IV.
NG: Black translates to Xx.Xu.xu(Black), where
Black is a constant of type A. Having Black be a
constant of type A emphasizes the point that
Black is a name, associated with some particular
object in A. The translation of other basic phras-
es of NG will be similar, except for he; and they (i
= 0, 1, ...). In particular, he; translates to
Xx.Xu.xuqi and they translates to Xx.Xu.xupi.
TV: own translates to Xy.Xu.Xz.y(Xu&apos;.(own)utz)u,
where own is a constant of type [U [A [A
- TM; and similarly for any other basic phrase
of category TV. This emphasizes that a transitive
verb is a relation between two objects in A. In
particular, if own interprets to a E [U [A [A
-I. Till, U, and y, SEA, then aigy8 if true is the
object y owns the object 8 in the universe 0.8
NM: black translates to Xx.Xu.Xz.xuz A (black)uz,
where black is a constant of type C; and similarly
for other basic phrases of category NM.
PP: at translates to Xy.Xx.Xu.Xz.xuz A
y(Xu&apos;.(aOu&apos;z)u, where at is a constant of type
[U -0. [A -• [A T]l]; and so on.
NU: 0 translates to 0, a constant of type N, which
interprets to the natural number 0 in N; and simi-
larly for other numerals.
NG?NG: what translates to Xy.y and who translates
to Xy.Xx.Xu.y(player)u A yxu.
</bodyText>
<subsectionHeader confidence="0.896371">
3.2.2 The combinative rules
</subsectionHeader>
<bodyText confidence="0.999302857142857">
These rules use a set of syntactic functions, F1
through F4, which combine phrases in various ways
involving person, plurality, and so on. We give these
functions first.
F i(u,v) is uv&apos;, where v&apos; is v (if the first noun in u is
plural) or the result of replacing the first verb in v
by its third person singular form (if the first noun
</bodyText>
<footnote confidence="0.822084">
8 However, this scheme will not work with all transitive verbs,
for example, alleged to be. Such verbs, called intensional verbs,
require more complex translations, but the end result will still be of
type [IC S] C]. The same complexities arise for NM and PP.
Our example contains none of these intensional words.
</footnote>
<equation confidence="0.7870845">
in u is singular).
F2(u,v) is uv&apos;, where v&apos; is the result of replacing the
first noun in v by its objective form.
F3(u,v) = uv.
F 4(u,v) = vu.
Syntactic Rules:
</equation>
<listItem confidence="0.7766426">
R2. If u is a phrase from NG and v is a phrase from
IV, then Fi(u,v) is a phrase from SE.
R3. If u is a phrase from TV and v is a phrase from
NG, then F2(u,v) is a phrase from IV.
R4. If u is a phrase from PP and v is a phrase from
NG, then F2(u,v) is a phrase from MG.
R5. If u is a phrase from NM and v is a phrase from
CN, then F3(u,v) is a phrase from CN.
R6. If u is a phrase from MG and v is a phrase from
CN, then F4(u,v) is a phrase from CN.
</listItem>
<bodyText confidence="0.969331333333333">
Interrogative Variants of Syntactic Rules:
In any of the rules R2 through R6, exactly one of the
arguments, u or v, may be a phrase from category X?Y,
where X is the original category specified for the argu-
ment and Y is any non-interrogative category. If the
original result was to be from category Z, then the
new result is in category Z?Y. For example, from R2,
if u is a phrase from NG?NG and v is a phrase from
IV, then Fi(u,v) is a phrase from SE?NG.
Semantics:
Let w = Fi(u,v), for i = 1, 2, 3, or 4. Let u translate
to b and v translate to c. Then there are three cases
for the translation of w:
Case (i): If neither u nor v is from an interrogative
category, then w translates to bc.
Case (ii): If u is from an interrogative category X?Y,
then w translates to Xs.bsc, where s is a variable
of type assigned to the category Y.
Case (iii): If v is from an interrogative category X?Y,
then w translates to Xs.b(cs), where s is a varia-
ble of type assigned to the category Y.
</bodyText>
<subsectionHeader confidence="0.96249">
3.2.3 Extracategorical rules
</subsectionHeader>
<bodyText confidence="0.9883065">
These rules combine phrases with words from outside
the categories to form new phrases. The rules use two
syntactic functions given here:
F5(u,v) is vu&apos;, where u&apos; is u (if v = 1), or the result of
replacing the first noun in u by its plural form (if
v 0 1).
F6(u) is the result of replacing the first noun in u with
its plural form.
</bodyText>
<footnote confidence="0.620816">
Syntactic Rules and Semantics:
R7. Let u be a phrase from CN, translating to b.
</footnote>
<note confidence="0.8520005">
American Journal of Computational Linguistics, Volume 9, Number 1, January-March 1983 17
Michael G. Main and David B. Benson Denotational Semantics for &apos;Natural&apos; Language Q-A Programs
</note>
<bodyText confidence="0.529795">
Then:
</bodyText>
<listItem confidence="0.976163821428572">
(i) every u is a phrase from NG, translating to
Xx.Xu.Vz.buz xuz.
(ii) some u is a phrase from NG, translating to
Xx.Xu.3z.buz A xuz.
(iii) the u is a phrase from NG, translating to
Xx.Xu.3z.xuz A Vz&apos;. (buz&apos; (z=z&apos;)).
(iv) no u is a phrase from NG, translating to
Xx.Xu.-3z.buz A xuz.
R8. Let u be a phrase from CN, translating to b.
Also let v be a phrase from NU, which translates
to n. Then:
(i) exactly F5(u,v) is a phrase from NG, trans-
lating to Xx.Xu.(3nz.buz A xuz) A
(3(n+1)z.buz A xuz).
(ii) at least F5(u,v) is a phrase from NG,
translating to Xx.Xu.3nz.buz A xuz.
(iii) less than F5(u,v) is a phrase from NG,
translating to Xx.Xu.- (3nz.buz A xuz).
R9. Let u be a phrase from SE, translating to b.
Then is it the case that u is a phrase from YN,
translating to Xt.Xu.bu&lt;.&gt;t
R10. Let u be a phrase from CN, translating to b.
Then:
(i) what F6(u) is a phrase from NG?NG,
translating to Xy.Xx.Xu.ybu A yxu.
(ii) how many F 6(u) is a phrase from NG?NU,
translating to Xm.Xx.Xu.(3mz.buz A xuz)
A (3(m+1)z.buz A xuz.
</listItem>
<subsectionHeader confidence="0.815923">
3.2.4 The abstraction rule
</subsectionHeader>
<bodyText confidence="0.999962230769231">
This rule is to replace the variables hei and theyi by
other noun phrases. The necessity for abstraction is
discussed in Lewis (1972). The syntactic functions F7
and F8, defined below, are used. In these definitions,
let u&apos; be the result of replacing the first noun in u with
its objective form, let up be the result of replacing the
first noun in u with its plural form, and let u &apos;p be the
result of replacing the first noun in u with its plural
objective form.
F7(u,v,i) is the result of replacing, in v, all occurrences
of hei by u and all occurrences of him; by u&apos;.
F8(u,v,i) is the result of replacing in v, all occurrences
of theyi by up and all occurrences of them; by u&apos;p.
</bodyText>
<subsectionHeader confidence="0.745992">
Syntactic Rule:
</subsectionHeader>
<bodyText confidence="0.94570625">
R11. Let u be a phrase from NG, v be a phrase from
SE, IV, or CN, and i be a variable index (e.g.,
0, 1, 2, ...). Then F7(u,v,i) and F8(u,v,i) are
phrases from the same category as v.
</bodyText>
<subsectionHeader confidence="0.467934">
Interrogative Variant of Syntactic Rule:
</subsectionHeader>
<bodyText confidence="0.9813995">
Either u may be from NG?Y or v may be from SE?Y,
IV?Y, or CN?Y (but not both), where Y is any non-
interrogative category. In all cases, the result is from
X?Y, where X is the first portion of the category of v.
Semantics:
Let b be the translation of u and c be the translation
of v. The translation of F7(u,v,i) is given in the fol-
lowing table, where s is a variable of type Y:
</bodyText>
<figure confidence="0.524762">
Case 1: v from SE and u from NG: b(Xu.Xqi.cu)
Case 2: v from SE and u from NG?Y:
Xs.bx(Xu.Xqi.cu)
Case 3: v from IV or CN and u from NG:
Xu.Xz.b(Xu&apos; .Xqi.cu z)u
Case 4: v from IV or CN and u from NG?Y:
Xs.Xu.Xz.bs(Xu&apos; .Xqi.cu z)u
Case 5: v from SE?Y and u from NG:
Xs.b(Xu.Xqi.csu)
Case 6: v from IV?Y or CN?Y and u from NG:
Xs.Xu.Xz.b(Xu&apos; .Xqi.csu&apos; z)u
</figure>
<bodyText confidence="0.999222523809524">
The translation is identical for F8, except that qi is
replaced by pi.
Some of the notions in the syntactic rules must still
be formalized. We must define the plural, objective,
and plural objective forms of each basic phrase in CN,
NG, and NG?NG. A noun is then any such basic
phrase or one of these forms. A verb is any basic
phrase in IV or TV. For each verb we must define its
third person singular form.
A brief discussion of the abstraction rules can clari-
fy their usage and purpose. A sentence such as every
player owns some stone has two possible meanings. It
can mean: there is some particular stone owned by
every player; or alternately, every player owns at least
one stone, but not necessarily the same stone for each
player. These two meanings will be achieved by intro-
ducing the NG some stone at different times. The ab-
straction rules allow this by delaying the introduction
of a noun phrase. Initially, a variable (perhaps heo) is
put in the sentence as a place holder. The abstraction
rules allow an NG to later replace the variable.
</bodyText>
<subsectionHeader confidence="0.9571895">
4. Questions and Answers
4.1 Questions
</subsectionHeader>
<bodyText confidence="0.999283666666667">
A question is any phrase from category YN, SE?NG, or
SE?NU, along with its syntactic derivation. The syn-
tactic derivation is needed because some phrases can
be derived in more than one way (e.g., is it the case
that every player owns some stone).
Derivations are represented by trees. Each leaf in
a derivation tree is labeled with a basic phrase. Each
internal node is labeled with a derived phrase, plus the
number of the syntactic rule that is used to derive it
from its daughter leaves.
From the semantic rules, every question translates
to exactly one lambda expression.
</bodyText>
<page confidence="0.731924">
18 American Journal of Computational Linguistics, Volume 9, Number 1, January-March 1983
</page>
<note confidence="0.958863">
Michael G. Main and David B. Benson Denotational Semantics for &apos;Natural&apos; Language Q-A Programs
</note>
<subsectionHeader confidence="0.998504">
4.2 Answers
</subsectionHeader>
<bodyText confidence="0.9540905">
Let Q be a question that translates to a lambda ex-
pression, b, of type [X S]. Also let:
</bodyText>
<listItem confidence="0.968067">
• tp be a variable assignment,
• g be a constant of type U and II g II = y,
• d be a constant of type X and II d II = 8.
</listItem>
<bodyText confidence="0.961364545454546">
Then 8 is an answer to Q, in the universe y with varia-
ble assignment iff II bdg II Ji is true.
If b is an expression of type [X S], then the
answers to its corresponding question are semantic
objects in X. In general, these objects depend on the
choice of the universe and also on the variable assign-
ment. However, if the question does not contain any
variables (hei or theyi), then the set of answers is the
same for any variable assignment. Such a question is
called invariable, and we may speak of an answer with-
out respect to a variable assignment.
</bodyText>
<subsectionHeader confidence="0.999628">
4.3 Examples
</subsectionHeader>
<bodyText confidence="0.993295692307692">
All of these examples are invariable questions, so we
may choose a variable assignment, 1,G, at random. The
types of variables are as in section 3.2, and we also
use a lambda constant g, of type U. As always, there
is a fixed interpretation assigning the lambda constants
to semantic objects.
In translating the examples to lambda expressions,
we use the semantic rules of section 3.2. However,
after translating a phrase, we will sometimes alter the
lambda expression in ways that cannot change the
semantic object.9
Example 1. One derivation of the phrase is it the case
that every player owns some stone is:
</bodyText>
<equation confidence="0.933445">
(R9) is it the case that every player owns some stone
(R2) every player owns some stone
(R7) every player (R3) own some stone
V \
player own (R7) some stone
stone
</equation>
<bodyText confidence="0.948272">
We have these translations:
</bodyText>
<footnote confidence="0.921193">
own some stone:
Xu.Xz.3z&apos;.(stone)uz&apos; A (own)uzz&apos;
9 In particular, we use logical conversion (such as b A b
converts to b) and the a- and /3-conversions of lambda calculus.
a-conversion involves changing the name of a bound variable (e.g.,
Xx.x A y converts to Xz.z A y). /3-conversion corresponds to func-
tional application (e.g., (Xx.x A y)z converts to z A y). Details can
be found in Stoy (1977).
</footnote>
<figure confidence="0.884759714285714">
every player:
Xx.Xu.Vz.(player)uz xuz
every player owns some stone:
Xu.Vz.(player)uz (3z&apos;.(stone)uz&apos; A (own)uzz&apos;)
is it the case that every player owns some stone:
Xt.Au.(Vz.(player)uz (3z&apos;.(stone)uz&apos; A
(own)uzz&apos;)) &lt;=&gt; t
</figure>
<bodyText confidence="0.923281">
Let true be a constant of type T that interprets to
`true&apos;e T. From the definition of an answer, &apos;true&apos; is
an answer to this question in the universe II g II p iff:
</bodyText>
<figure confidence="0.809115739130435">
II (Xt.Xu.(Vz.(player)uz A (3z&apos;.(stone)uz&apos; A
(own)uzz&apos;)) t)(true)g II ip
Here, 11., can be picked at random. The above expres-
sion converts to
II Vz.(player)gz (3z&apos;.(stone)gz&apos; A (own)gzz&apos;)
This is a reasonable condition for &apos;true&apos; to answer the
question.
Example 2. An alternative derivation for the previous
phrase is:
(R9) is it the case that every player owns some stone
(R11) every player owns some stone
R(7) some stone (R2) every player owns himo
stone
(R7) every player (R3) own himo
player own heo
In this case, the translations are:
own himo:
Xu.Xz.(own)uzqc,
every player owns himo:
Xu.Vz.(player)uz (own)uzqc,
every player owns some stone:
Xu.3z1.(stone)uz&apos; A (Vz.(player)uz (own)uzz&apos;)
is it the case that every player owns some stone:
XtXu.(3z1.(stone)uz&apos; A (Vz.(player)uz
(own)uzz&apos;)) &lt;=&gt; t
In the universe II g II 0, &apos;true&apos; is an answer to this ques-
tion iff:
3z1.(stone)gz&apos; A (Vz.(player)gz (own)gzz&apos;) ip
This contrasts with example 1.
\
American Journal of Computational Linguistics, Volume 9, Number 1, January-March 1983 19
Michael G. Main and David B. Benson Denotational Semantics for &apos;Natural&apos; Language Q-A Programs
Example 3. Here is a derivation of a phrase from
SE?NU:
(R2) how many stones belong to Black
(R10) how many stones (R3) belong to Black
stone belong to Black
The semantic rules give these translations:
belong to Black:
Xu.Xz.(belong to)uz(Black)
how many stones:
Xm.Xx.Xu.(3inz.(stone)uz A xuz) A
(3(m+1)z.(stone)uz A xuz)
how many stones belong to Black:
Xm.Xu.(3mz.(stone)uz A (belong to)uz(Black)) A
-(3(m+1)z.(stone)uz A (belong to)uz(Black))
</figure>
<bodyText confidence="0.788874571428572">
Let n = II niltp be a natural number. Then n answers
this question in the universe II g tp, iff:
(3nz.(stone)gz A (belong to)gz(Black)) A
,(3(n+1)z.(stone)gz A (belong to)gz(Black))
That is, there exists 77 stones (but not 71+1) that be-
long to Black in the universe II g II
Example 4. This question is from SE?NG.
(R2) what owns no black stone
what (R2) own no black stone
own (R7) no black stone
(R5) black stone
black stone
Here are the translations to lambda expressions:
black stone:
</bodyText>
<subsectionHeader confidence="0.39683">
Xu.Xz.(stone)uz A (black)uz
</subsectionHeader>
<bodyText confidence="0.714214">
no black stone:
</bodyText>
<subsectionHeader confidence="0.405155">
Xx.Xu.-3z.(stone)uz A (black)uz A xuz
</subsectionHeader>
<bodyText confidence="0.728228">
own no black stone:
</bodyText>
<subsectionHeader confidence="0.667122">
Xu.Xz&apos;,3z.(stone)uz A (black)uz A (own)uz&apos;z
</subsectionHeader>
<bodyText confidence="0.924155">
what owns no black stone:
Xy.y(Xu.Xz&apos;.-.3z.(stone)uz A (black)uz A
(own)uz&apos;z)
The semantic object corresponding to White (namely,
II Xx.Xu.xu(White) II 0) answers this question in a uni-
verse, II g II i, iff:
</bodyText>
<sectionHeader confidence="0.881723" genericHeader="method">
II Az.(stone)gz A (black)gz A (own)g(White)z
</sectionHeader>
<bodyText confidence="0.99276471875">
Any realistic interpretation interprets the constants
black, own, and White so that 11 (black)gz II tp and
II (own)g(White)z II p are mutually exclusive for any g,
z, and tp, so that the semantic object for White does
answer this question.
The difficulty with examples such as these is that
even when the translations of individual constructions
are fairly simple the translation of a complex construc-
tion inevitably appears cryptic and the translation
process is tedious. However, the formal translations
are amenable to mechanical manipulations and the
translating process is also easily mechanized. Hence,
we leave it as an exerciue in the manipulations to show
that the translation of what blocks own at least 3 stones
with less than 2 liberties is as follows:
Xy.Xu.y(block)u A y(Xu.Xz&amp;quot;.33z1.(stone)uz&apos; A
-(32z.(liberty)uz A (with)uz&apos;z) A (own)uznz&apos;)u
The first part of the translation guarantees that a
possible answer, y, is indeed a block. The second part
checks that y owns at least 3 stones with less than 2
liberties. Note that, although there may be other pars-
ings of this sentence in a complete English grammar,
our simple syntactic rules have forced this particular
translation upon us.
Answers to SE?NG questions are objects from [C
S[. However, it might be more convenient to have
these answers be objects from A. A modification to
the definition of an answer could allow this. In partic-
ular, let b be a lambda constant of type A, which in-
terprets to PE A. Then 13 could answer a question in
the universe II g Ibp, with variable assignment 4), iff
II Xx.Xu.xub II 4i 6 [C SI, does.
</bodyText>
<sectionHeader confidence="0.999141" genericHeader="conclusions">
5. Discussion
</sectionHeader>
<bodyText confidence="0.999967666666667">
We have used denotational techniques to define the
semantics of a &amp;quot;natural&amp;quot; language question answerer.
The questions are defined by syntactic rules - a cate-
gory grammar. Associated with each syntactic rule is
a semantic rule, giving a semantic object for each
phrase the syntactic rule produces. The semantic ob-
jects for questions are functions, from possible an-
swers to propositions, where a proposition is an object
that takes on a truth value. Thus, if a question, Q, has
a semantic object that maps an answer, A, to a true
proposition, then A answers Q. In this way, the rela-
tion between questions and answers is formalized.
While it is not our intent to give implementation
details for the question answerer, an outline of the
program&apos;s organization will lead to some concluding
remarks. The program was written as a class project
by the first author and four other students. The logi-
cal divisions of the program were as follows:
</bodyText>
<page confidence="0.393109">
20 American Journal of Computational Linguistics, Volume 9, Number 1, January-March 1983
</page>
<note confidence="0.549056">
Michael G. Main and David B. Benson Denotational Semantics for &apos;Natural&apos; Language Q-A Programs
</note>
<listItem confidence="0.921824266666667">
• Lexical analysis. The input is broken into basic
component words, or &amp;quot;tokens&amp;quot;, using finite auto-
mata techniques as in Johnson et al. (1968).
• Syntactic parser. An augmented transition network
(Woods 1970) parses the input according to the
category grammar with heuristic rules and interac-
tive query to solve ambiguities. The output is a
single derivation tree.
• Semantic interpretation. The &amp;quot;meaning&amp;quot; of the sen-
tence is computed according to the semantic rules.
The output of this phase can be thought of as
&amp;quot;machine code&amp;quot; for finding answers. At this stage,
the &amp;quot;code&amp;quot; is independent of the actual structure of
the implementation of the underlying data base.
• Deductive components. The &amp;quot;code&amp;quot; from the previ-
</listItem>
<bodyText confidence="0.886590272727273">
ous stage is improved based on conversion rules of
logic, such as x or x = x. It is also modified ac-
cording to the specific structure of the data base.
The latter modifications are implementation de-
pendent.
• Answerer. This corresponds to a database query-
retrieval program. The &amp;quot;code&amp;quot; from the previous
step is executed to produce an answer.
In the actual implementation, the above stages are
not strictly separate; still, the model is useful. There
is a direct correspondence between the first four
stages of the implementation and the initial four stages
of a typical compiler (Aho and Ullman 1977). Hobbs
and Rosenschein (1977) indicate how these last three
stages could be developed using an augmented LISP as
&amp;quot;code&amp;quot;.
In this paper, we have recommended using denota-
tional semantics as a specification technique for
question-answering programs. The implementation
suggests that principles of compiler design can be used
as principles of question answerer design by the soft-
ware engineer.
</bodyText>
<sectionHeader confidence="0.995097" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.997254513888889">
Aho, A.V. and Ullman, J.D. 1977 Principles of Compiler Design.
Addison-Wesley, Reading, Massachusetts.
Ajdukiewicz, K. 1926 The Semantic Analysis of Interrogative
Sentences, Ruth Filozoficzny X.
Ajdukiewicz, K. 1935 Syntactic Connexion. In McCall, S., Ed.,
Polish Logic, 1920-1939. Clarendon, Oxford (1967).
Ashcroft, E.A. and Wadge, W.W. 1982 1&amp;. for Semantics. ACM
Trans. Prog. Lang. and Sys. 4: 283-294.
Benson, D.B. 1975 Formal Languages vis-a-vis &apos;Natural&apos; Lan-
guages. In Sedelow, W. and Sedelow, S., Ed., Computers in
Language Research: Trends in Linguistics. Mouton, the Hague
(1979).
Carnap, R. 1937 The Logical Syntax of Language. Smeaton, A.,
Trans. Kegan Paul, Trench, Trubner and Son, Ltd., London.
Church, A. 1951 The Calculi of Lambda-Conversion. Princeton
University Press, Princeton, New Jersey.
Frege, G. 1892 On Sense and Reference. In Geach, P. and Black,
M., Ed., Translations from the Philosophical Writings of Got/lob
Frege. Basil Blackwell, Oxford (1952).
Gordon, M.J.C. 1979 The Denotational Description of Programming
Languages. Springer-Verlag, New York.
Harris, L.R. 1979 Experience with ROBOT in 12 Commercial
Natural Language Data Base Query Applications, Proc. 6th
International Joint Conference on Artificial Intelligence. Tokyo:
365-368.
Hobbs, J.R. and Rosenschein, S.J. 1977 Making Computation
Sense of Montague&apos;s Intensional Logic, Artificial Intelligence 9:
287-306.
Johnson, S.C. 1975 YACC — Yet Another Compiler Compiler.
CSTR 32. Bell Laboratories, Murray Hill, New Jersey.
Johnson, W.L.; Porter, J.H.; Ackley, SI.; and Ross, D.T. 1968
Automatic Generation of Efficient Lexical Analyzers Using
Finite State Techniques, Communications of the ACM 11(12):
805-813.
Kahn, C. 1978 Questions and Categories. In Hiz, H., Ed.,
Questions. D. Reidel Publishing Co., Dordrecht, Holland.
Karttunen, L. 1977 Syntax and Semantics of Questions, Linguistics
and Philosophy 1:3-44.
Lewis, D. 1972 General semantics. In Davidson, D. and Harman,
G., Ed., Semantics of Natural Language. D. Reidel Publishing
Co., Dordrecht, Holland.
McGettrick, A.D. 1980. The Definition of Programming Languages.
(Cambridge Computer Science Texts 11.) Cambridge University
Press, Cambridge.
Milne, R. and Strachey, C. 1976 A Theory of Programming Lan-
guage Semantics. Chapman and Hall, London.
Montague, R. 1973 The Proper Treatment of Quantification in
Ordinary English. In Thomasen, R., Ed., Formal Philosophy.
Selected Papers of Richard Montague. Yale University Press, New
Haven, Connecticut (1974).
Pagen, F.G. 1981 Formal Specification of Programming Languages:
A Panoramic Primer. Prentice-Hall, Inc., Englewood Cliffs, New
Jersey.
Scott, D. 1976 Data Types as Lattices, SIAM Journal of Computing
5: 522-587.
Stoy, J. 1977 Denotational Semantics: The Scott-Strachey Approach
to Programming Language Theory. MIT Press, Cambridge, Mas-
sachusetts.
Tennent, R.D. 1981 Principles of Programming Languages. Prentice-
Hall, Inc., Englewood Cliffs, New Jersey.
van Emde Boas, P. and Janssen, T. 1979 The Impact of Frege&apos;s
Principle of Compositionality for the Semantics of Programming
and Natural Languages. Report 79-07, University of Amster-
dam.
Winograd, T. 1972 Understanding Natural Language. Academic
Press, New York, New York.
Woods, W.A. 1970 Transition Network Grammars for Natural
Language Analysis, Communications of the ACM 13(10): 591-
602.
Woods, W.A. 1972 The Lunar Sciences Natural Language Informa-
tion System. Report 2378, Bolt Beranek and Newman.
American Journal of Computational Linguistics, Volume 9, Number 1, January-March 1983 21
</reference>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.880197">
<title confidence="0.990084333333333">Denotational Semantics for Language Question-Answering Programs&apos; G.</title>
<author confidence="0.999852">David B Benson</author>
<affiliation confidence="0.9619435">Department of Computer Washington State</affiliation>
<address confidence="0.998866">Pullman, WA 99164-1210</address>
<abstract confidence="0.997487">Scott-Strachey style denotational semantics is proposed as a suitable means of communicating the specification of &amp;quot;natural&amp;quot; language question answerers to computer programmers and software engineers. The method is exemplified by a simple question answerer communicating with a small data base. This example is partly based on treatment of fragments of English by Montague. Emphasis is placed on the semantic interpretation of questions. The &amp;quot;meaning&amp;quot; of a question is taken as a function from the set of universes to a set of possible answers.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>A V Aho</author>
<author>J D Ullman</author>
</authors>
<date>1977</date>
<booktitle>Principles of Compiler Design.</booktitle>
<publisher>Addison-Wesley,</publisher>
<location>Reading, Massachusetts.</location>
<marker>Aho, Ullman, 1977</marker>
<rawString>Aho, A.V. and Ullman, J.D. 1977 Principles of Compiler Design. Addison-Wesley, Reading, Massachusetts.</rawString>
</citation>
<citation valid="true">
<authors>
<author>K Ajdukiewicz</author>
</authors>
<title>The Semantic Analysis of Interrogative Sentences, Ruth Filozoficzny X.</title>
<date>1926</date>
<contexts>
<context position="4980" citStr="Ajdukiewicz (1926)" startWordPosition="760" endWordPosition="761"> the program segments, and determine the output of a program. Similarly, in the semantics of a question answerer, evaluation functions map input (questions) into objects that determine the output (answers). Deciding what objects are in the semantic domains has a fundamental effect on the capabilities of the overlying question answerer, as well as an effect on the usefulness and clarity of the semantic descriptions. Lewis (1972) discusses these considerations for natural language sentences and the domains described in section 2 are based on his, although the treatment of questions is closer to Ajdukiewicz (1926). Also introduced in section 2 are the lambda expressions that denote individual semantic objects. Such expressions have been used in denotational semantics of programming languages (see Scott 1970, Milne and Strachey 1976, Stoy 1977) and in treatments of fragments of English by Montague (1973). In section 3, evaluation functions mapping inputs for a small question answerer to objects in the semantic domain are given. The allowable questions are defined by a category grammar as has been done by Ajdukiewicz (1935), Carnap (1937), Lewis (1972), Montague (1973), and others. An account of the answ</context>
<context position="11931" citStr="Ajdukiewicz (1926)" startWordPosition="1908" endWordPosition="1909">Similarly, a noun modifier, such as black, combines with a common noun, such as stone, to form a new common noun — black stone. So, the semantic domain for noun modifiers is [C-&gt;C]. By examining the syntactic rules, this method can be applied to most categories.5 Occasional exceptions can be made — for example, numerals are assigned the domain, N, of natural numbers. 2.3 Interrogative categories So far, the categories include only non-interrogative phrases. Syntactically, the interrogative phrases parallel the non-interrogatives, but semantically an interrogative lacks something. For example, Ajdukiewicz (1926) would represent the meaning of the interroga4 A name, such as John, is one type of noun group that denotes a particular atom which does not change from universe to universe Therefore, it might be better to have names in a separate syntactic category with assigned semantic domain A. But, doing this would not do away with the category noun group, since some noun phrases are not names (e.g., every stone). But, having two categories unduly complicates the syntax, so we lump names together with other noun groups, and treat them as Montague (1973) has. 5 This method of assigning semantic domains is</context>
</contexts>
<marker>Ajdukiewicz, 1926</marker>
<rawString>Ajdukiewicz, K. 1926 The Semantic Analysis of Interrogative Sentences, Ruth Filozoficzny X.</rawString>
</citation>
<citation valid="true">
<authors>
<author>K Ajdukiewicz</author>
</authors>
<title>Syntactic Connexion.</title>
<date>1935</date>
<journal>In McCall, S., Ed., Polish Logic,</journal>
<pages>1920--1939</pages>
<location>Clarendon, Oxford</location>
<contexts>
<context position="5498" citStr="Ajdukiewicz (1935)" startWordPosition="843" endWordPosition="844">d in section 2 are based on his, although the treatment of questions is closer to Ajdukiewicz (1926). Also introduced in section 2 are the lambda expressions that denote individual semantic objects. Such expressions have been used in denotational semantics of programming languages (see Scott 1970, Milne and Strachey 1976, Stoy 1977) and in treatments of fragments of English by Montague (1973). In section 3, evaluation functions mapping inputs for a small question answerer to objects in the semantic domain are given. The allowable questions are defined by a category grammar as has been done by Ajdukiewicz (1935), Carnap (1937), Lewis (1972), Montague (1973), and others. An account of the answer relationship is given in section 4. In the final section, we briefly describe an implementation of the question answerer and suggest some broad principles for designing question answerers. 2. Semantic Domains for Natural Language 2.1 The Domains A semantic domain is a set of objects. The objects are meanings of syntactic constructs; in our case the syntactic constructs are natural language phrases. In denotational semantics for programming languages, the semantic domains often have some order imposed on the ob</context>
</contexts>
<marker>Ajdukiewicz, 1935</marker>
<rawString>Ajdukiewicz, K. 1935 Syntactic Connexion. In McCall, S., Ed., Polish Logic, 1920-1939. Clarendon, Oxford (1967).</rawString>
</citation>
<citation valid="true">
<authors>
<author>E A Ashcroft</author>
<author>W W Wadge</author>
</authors>
<title>1&amp;. for Semantics.</title>
<date>1982</date>
<journal>ACM Trans. Prog. Lang. and Sys.</journal>
<volume>4</volume>
<pages>283--294</pages>
<contexts>
<context position="2231" citStr="Ashcroft and Wadge 1982" startWordPosition="337" endWordPosition="340">he may ask and what sort of answers the program will provide. Informal meanings are also valuable to the designer and implementer of a question answerer. However, the designer and implementer must understand all aspects of a proposed question answerer in a precise unambiguous way that informal 1 This research was supported in part by NSF grants MCS7708486 and MCS8003433. 2 Current Address: Department of Computer Science, University of Colorado, Boulder, CO 80309. methods do not provide. In short, a formal method of specifying the semantics is needed at the design and implementation stage (see Ashcroft and Wadge 1982). Once a formal semantics has been given, it can be put to other uses as well. It can provide the basis for a rigorous proof of correctness of an implementation. Furthermore, formal specifications might allow partial automation of the implementation process in the same way that automatic compiler-writers produce parts of a compiler from a formal specification of a programming language (see Johnson 1975). With the advent of at least one commercially available &amp;quot;natural&amp;quot; language question-answering program (Harris 1979), these advantages become even more concrete. If there is a familiarity to the</context>
</contexts>
<marker>Ashcroft, Wadge, 1982</marker>
<rawString>Ashcroft, E.A. and Wadge, W.W. 1982 1&amp;. for Semantics. ACM Trans. Prog. Lang. and Sys. 4: 283-294.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D B Benson</author>
</authors>
<title>Formal Languages vis-a-vis &apos;Natural&apos; Languages.</title>
<date>1975</date>
<booktitle>In Sedelow, W. and Sedelow, S., Ed., Computers in Language Research: Trends in Linguistics. Mouton, the Hague</booktitle>
<contexts>
<context position="3058" citStr="Benson (1975)" startWordPosition="467" endWordPosition="468">al automation of the implementation process in the same way that automatic compiler-writers produce parts of a compiler from a formal specification of a programming language (see Johnson 1975). With the advent of at least one commercially available &amp;quot;natural&amp;quot; language question-answering program (Harris 1979), these advantages become even more concrete. If there is a familiarity to these arguments, it is because the same reasoning is used to justify formal semantics for programming languages. The problems of design and analysis of question answerers are much the same for programming languages — Benson (1975) argues this point at length. An obvious approach is to apply a programming language technique — denotational semantics — to the problem of formally specifying a question answerer. As a bonus, the method is understood by many programmers and software engineers through introductory textbooks such as Stoy (1977), Gordon (1979), McGettrick (1980), Pagan (1981), and Tennent (1981). Additionally, linguistic treatments of natural language, such as Montague (1973), are basically denotational and we can modify such Copyright 1983 by the Association for Computational Linguistics. Permission to copy wit</context>
</contexts>
<marker>Benson, 1975</marker>
<rawString>Benson, D.B. 1975 Formal Languages vis-a-vis &apos;Natural&apos; Languages. In Sedelow, W. and Sedelow, S., Ed., Computers in Language Research: Trends in Linguistics. Mouton, the Hague (1979).</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Carnap</author>
</authors>
<title>The Logical Syntax of Language.</title>
<date>1937</date>
<journal>Smeaton, A., Trans. Kegan Paul, Trench, Trubner</journal>
<location>Ltd., London.</location>
<contexts>
<context position="5513" citStr="Carnap (1937)" startWordPosition="845" endWordPosition="846">ased on his, although the treatment of questions is closer to Ajdukiewicz (1926). Also introduced in section 2 are the lambda expressions that denote individual semantic objects. Such expressions have been used in denotational semantics of programming languages (see Scott 1970, Milne and Strachey 1976, Stoy 1977) and in treatments of fragments of English by Montague (1973). In section 3, evaluation functions mapping inputs for a small question answerer to objects in the semantic domain are given. The allowable questions are defined by a category grammar as has been done by Ajdukiewicz (1935), Carnap (1937), Lewis (1972), Montague (1973), and others. An account of the answer relationship is given in section 4. In the final section, we briefly describe an implementation of the question answerer and suggest some broad principles for designing question answerers. 2. Semantic Domains for Natural Language 2.1 The Domains A semantic domain is a set of objects. The objects are meanings of syntactic constructs; in our case the syntactic constructs are natural language phrases. In denotational semantics for programming languages, the semantic domains often have some order imposed on the objects to treat </context>
</contexts>
<marker>Carnap, 1937</marker>
<rawString>Carnap, R. 1937 The Logical Syntax of Language. Smeaton, A., Trans. Kegan Paul, Trench, Trubner and Son, Ltd., London.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Church</author>
</authors>
<title>The Calculi of Lambda-Conversion.</title>
<date>1951</date>
<publisher>Princeton University Press,</publisher>
<location>Princeton, New Jersey.</location>
<contexts>
<context position="14616" citStr="Church (1951)" startWordPosition="2381" endWordPosition="2382"> a meaning y €S, then al3=y. A similar idea can be applied to one other category: yes—no questions. Such an interrogative lacks a truth value, so the semantic domain assigned to yes—no questions is [T-0.S]. If a [T-0.S] is the meaning of a yes—no question, then s(true)ES is the meaning of the sentence when it is answered by yes, and similarly for an a(false). 2.4 Lambda expressions Up to this point, semantic objects have been described in English. In order to be more precise, a formal notation is needed. We use a typed lambda expression for denoting functions, similar to the lambda calculi of Church (1951). Every lambda expression has a type that indicates the semantic domain of the object denoted by the expression. These types are in one-to-one correspondence with the semantic domains (A, U, T, N, etc....), so we will use the same letters in ordinary typescript for the expression types (A, U, T, N, [U.-...T], etc....). The expressions of each type include a set of constants and a denumerable set of variables. A function that maps the constants into semantic objects is an interpretation, and generally remains fixed. A function that maps variables into semantic objects is a variable assignment a</context>
</contexts>
<marker>Church, 1951</marker>
<rawString>Church, A. 1951 The Calculi of Lambda-Conversion. Princeton University Press, Princeton, New Jersey.</rawString>
</citation>
<citation valid="true">
<authors>
<author>G Frege</author>
</authors>
<title>1892 On Sense and Reference. In</title>
<date>1952</date>
<location>Oxford</location>
<marker>Frege, 1952</marker>
<rawString>Frege, G. 1892 On Sense and Reference. In Geach, P. and Black, M., Ed., Translations from the Philosophical Writings of Got/lob Frege. Basil Blackwell, Oxford (1952).</rawString>
</citation>
<citation valid="true">
<authors>
<author>M J C Gordon</author>
</authors>
<title>The Denotational Description of Programming Languages.</title>
<date>1979</date>
<publisher>Springer-Verlag,</publisher>
<location>New York.</location>
<contexts>
<context position="3384" citStr="Gordon (1979)" startWordPosition="519" endWordPosition="520"> become even more concrete. If there is a familiarity to these arguments, it is because the same reasoning is used to justify formal semantics for programming languages. The problems of design and analysis of question answerers are much the same for programming languages — Benson (1975) argues this point at length. An obvious approach is to apply a programming language technique — denotational semantics — to the problem of formally specifying a question answerer. As a bonus, the method is understood by many programmers and software engineers through introductory textbooks such as Stoy (1977), Gordon (1979), McGettrick (1980), Pagan (1981), and Tennent (1981). Additionally, linguistic treatments of natural language, such as Montague (1973), are basically denotational and we can modify such Copyright 1983 by the Association for Computational Linguistics. Permission to copy without fee all or part of this material is granted provided that the copies are not made for direct commercial advantage and the Journal reference and this copyright notice are included on the first page. To copy otherwise, or to republish, requires a fee and/or specific permission. 0362-613X/83/010011-11$03.00 American Journa</context>
</contexts>
<marker>Gordon, 1979</marker>
<rawString>Gordon, M.J.C. 1979 The Denotational Description of Programming Languages. Springer-Verlag, New York.</rawString>
</citation>
<citation valid="true">
<authors>
<author>L R Harris</author>
</authors>
<title>Experience with ROBOT in 12 Commercial Natural Language Data Base Query Applications,</title>
<date>1979</date>
<booktitle>Proc. 6th International Joint Conference on Artificial Intelligence.</booktitle>
<pages>365--368</pages>
<location>Tokyo:</location>
<contexts>
<context position="1037" citStr="Harris (1979)" startWordPosition="149" endWordPosition="150">ple question answerer communicating with a small data base. This example is partly based on treatment of fragments of English by Montague. Emphasis is placed on the semantic interpretation of questions. The &amp;quot;meaning&amp;quot; of a question is taken as a function from the set of universes to a set of possible answers. 1. Introduction We advocate the use of Scott-Strachey denotational semantics for &amp;quot;natural&amp;quot; language question-answering programs. The majority of this paper demonstrates the use of denotational semantics for a small question answerer. The types of questions possible are similar to those in Harris (1979), Winograd (1972), and Woods (1972). The analysis is not as deep as in Karttunen (1977) or similar studies, as it is oriented to the specification of useful, but linguistically modest, capabilities. Before the demonstration, we discuss the benefits of formal semantics and why denotational semantics is an appropriate formalization. The semantics of a question answerer is given by defining the action of the program for each possible input. An informal semantic description, perhaps in narrative form, is necessary for a potential user who wants to know what questions he may ask and what sort of an</context>
<context position="2753" citStr="Harris 1979" startWordPosition="418" endWordPosition="419">e semantics is needed at the design and implementation stage (see Ashcroft and Wadge 1982). Once a formal semantics has been given, it can be put to other uses as well. It can provide the basis for a rigorous proof of correctness of an implementation. Furthermore, formal specifications might allow partial automation of the implementation process in the same way that automatic compiler-writers produce parts of a compiler from a formal specification of a programming language (see Johnson 1975). With the advent of at least one commercially available &amp;quot;natural&amp;quot; language question-answering program (Harris 1979), these advantages become even more concrete. If there is a familiarity to these arguments, it is because the same reasoning is used to justify formal semantics for programming languages. The problems of design and analysis of question answerers are much the same for programming languages — Benson (1975) argues this point at length. An obvious approach is to apply a programming language technique — denotational semantics — to the problem of formally specifying a question answerer. As a bonus, the method is understood by many programmers and software engineers through introductory textbooks suc</context>
</contexts>
<marker>Harris, 1979</marker>
<rawString>Harris, L.R. 1979 Experience with ROBOT in 12 Commercial Natural Language Data Base Query Applications, Proc. 6th International Joint Conference on Artificial Intelligence. Tokyo: 365-368.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J R Hobbs</author>
<author>S J Rosenschein</author>
</authors>
<date>1977</date>
<journal>Making Computation Sense of Montague&apos;s Intensional Logic, Artificial Intelligence</journal>
<volume>9</volume>
<pages>287--306</pages>
<marker>Hobbs, Rosenschein, 1977</marker>
<rawString>Hobbs, J.R. and Rosenschein, S.J. 1977 Making Computation Sense of Montague&apos;s Intensional Logic, Artificial Intelligence 9: 287-306.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S C Johnson</author>
</authors>
<title>YACC — Yet Another Compiler Compiler. CSTR 32. Bell Laboratories,</title>
<date>1975</date>
<publisher>Murray Hill,</publisher>
<location>New Jersey.</location>
<contexts>
<context position="2637" citStr="Johnson 1975" startWordPosition="403" endWordPosition="404">cience, University of Colorado, Boulder, CO 80309. methods do not provide. In short, a formal method of specifying the semantics is needed at the design and implementation stage (see Ashcroft and Wadge 1982). Once a formal semantics has been given, it can be put to other uses as well. It can provide the basis for a rigorous proof of correctness of an implementation. Furthermore, formal specifications might allow partial automation of the implementation process in the same way that automatic compiler-writers produce parts of a compiler from a formal specification of a programming language (see Johnson 1975). With the advent of at least one commercially available &amp;quot;natural&amp;quot; language question-answering program (Harris 1979), these advantages become even more concrete. If there is a familiarity to these arguments, it is because the same reasoning is used to justify formal semantics for programming languages. The problems of design and analysis of question answerers are much the same for programming languages — Benson (1975) argues this point at length. An obvious approach is to apply a programming language technique — denotational semantics — to the problem of formally specifying a question answerer</context>
</contexts>
<marker>Johnson, 1975</marker>
<rawString>Johnson, S.C. 1975 YACC — Yet Another Compiler Compiler. CSTR 32. Bell Laboratories, Murray Hill, New Jersey.</rawString>
</citation>
<citation valid="true">
<authors>
<author>W L Johnson</author>
<author>J H Porter</author>
<author>SI Ackley</author>
<author>D T Ross</author>
</authors>
<title>Automatic Generation of Efficient Lexical Analyzers Using Finite State Techniques,</title>
<date>1968</date>
<journal>Communications of the ACM</journal>
<volume>11</volume>
<issue>12</issue>
<pages>805--813</pages>
<contexts>
<context position="40458" citStr="Johnson et al. (1968)" startWordPosition="6997" endWordPosition="7000">s not our intent to give implementation details for the question answerer, an outline of the program&apos;s organization will lead to some concluding remarks. The program was written as a class project by the first author and four other students. The logical divisions of the program were as follows: 20 American Journal of Computational Linguistics, Volume 9, Number 1, January-March 1983 Michael G. Main and David B. Benson Denotational Semantics for &apos;Natural&apos; Language Q-A Programs • Lexical analysis. The input is broken into basic component words, or &amp;quot;tokens&amp;quot;, using finite automata techniques as in Johnson et al. (1968). • Syntactic parser. An augmented transition network (Woods 1970) parses the input according to the category grammar with heuristic rules and interactive query to solve ambiguities. The output is a single derivation tree. • Semantic interpretation. The &amp;quot;meaning&amp;quot; of the sentence is computed according to the semantic rules. The output of this phase can be thought of as &amp;quot;machine code&amp;quot; for finding answers. At this stage, the &amp;quot;code&amp;quot; is independent of the actual structure of the implementation of the underlying data base. • Deductive components. The &amp;quot;code&amp;quot; from the previous stage is improved based </context>
</contexts>
<marker>Johnson, Porter, Ackley, Ross, 1968</marker>
<rawString>Johnson, W.L.; Porter, J.H.; Ackley, SI.; and Ross, D.T. 1968 Automatic Generation of Efficient Lexical Analyzers Using Finite State Techniques, Communications of the ACM 11(12): 805-813.</rawString>
</citation>
<citation valid="true">
<authors>
<author>C Kahn</author>
</authors>
<title>Questions and Categories. In</title>
<date>1978</date>
<publisher>Reidel Publishing Co.,</publisher>
<location>Dordrecht, Holland.</location>
<contexts>
<context position="8242" citStr="Kahn 1978" startWordPosition="1289" endWordPosition="1290">base. The internal structure of such a data base is left unspecified in this paper. Other semantic domains are built from the four basic domains. For example, the set of functions from universes to truth values, designated [U.1], is a new domain. In general, if X and Y designate sets, then [X-..&apos;Y] designates the set of functions from X to Y. Other semantic domains could be conceived (e.g., product or sum domains), but function domains will be adequate for our examples. 2.2 Assigning domains to syntactic categories Natural language phrases have been divided into many different categories (see Kahn 1978). Exactly which categories are used depends upon syntax. In the category grammar of section 3, the categories include sentence, intransitive verb, common noun, noun group, noun modifier, numeral, and so on. There are also separate interrogative categories for phrases that ask a question, such as how many stones. To each syntactic category, a semantic domain is assigned. The meaning of a phrase is an object in the assigned domain. Ultimately, from the meaning of a question, we will derive its answer. But first we assign domains to non-interrogative categories, beginning with the category of sen</context>
</contexts>
<marker>Kahn, 1978</marker>
<rawString>Kahn, C. 1978 Questions and Categories. In Hiz, H., Ed., Questions. D. Reidel Publishing Co., Dordrecht, Holland.</rawString>
</citation>
<citation valid="true">
<authors>
<author>L Karttunen</author>
</authors>
<title>Syntax and Semantics of Questions,</title>
<date>1977</date>
<journal>Linguistics and Philosophy</journal>
<pages>1--3</pages>
<contexts>
<context position="1124" citStr="Karttunen (1977)" startWordPosition="164" endWordPosition="166">ased on treatment of fragments of English by Montague. Emphasis is placed on the semantic interpretation of questions. The &amp;quot;meaning&amp;quot; of a question is taken as a function from the set of universes to a set of possible answers. 1. Introduction We advocate the use of Scott-Strachey denotational semantics for &amp;quot;natural&amp;quot; language question-answering programs. The majority of this paper demonstrates the use of denotational semantics for a small question answerer. The types of questions possible are similar to those in Harris (1979), Winograd (1972), and Woods (1972). The analysis is not as deep as in Karttunen (1977) or similar studies, as it is oriented to the specification of useful, but linguistically modest, capabilities. Before the demonstration, we discuss the benefits of formal semantics and why denotational semantics is an appropriate formalization. The semantics of a question answerer is given by defining the action of the program for each possible input. An informal semantic description, perhaps in narrative form, is necessary for a potential user who wants to know what questions he may ask and what sort of answers the program will provide. Informal meanings are also valuable to the designer and</context>
</contexts>
<marker>Karttunen, 1977</marker>
<rawString>Karttunen, L. 1977 Syntax and Semantics of Questions, Linguistics and Philosophy 1:3-44.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D Lewis</author>
</authors>
<title>General semantics. In</title>
<date>1972</date>
<journal>Semantics of Natural Language. D. Reidel Publishing Co.,</journal>
<location>Dordrecht, Holland.</location>
<contexts>
<context position="4793" citStr="Lewis (1972)" startWordPosition="731" endWordPosition="732">. In denotational semantics for programming languages, evaluation functions map program segments into objects in various semantic domains. These objects are taken as the meanings of the program segments, and determine the output of a program. Similarly, in the semantics of a question answerer, evaluation functions map input (questions) into objects that determine the output (answers). Deciding what objects are in the semantic domains has a fundamental effect on the capabilities of the overlying question answerer, as well as an effect on the usefulness and clarity of the semantic descriptions. Lewis (1972) discusses these considerations for natural language sentences and the domains described in section 2 are based on his, although the treatment of questions is closer to Ajdukiewicz (1926). Also introduced in section 2 are the lambda expressions that denote individual semantic objects. Such expressions have been used in denotational semantics of programming languages (see Scott 1970, Milne and Strachey 1976, Stoy 1977) and in treatments of fragments of English by Montague (1973). In section 3, evaluation functions mapping inputs for a small question answerer to objects in the semantic domain ar</context>
<context position="29373" citStr="Lewis (1972)" startWordPosition="5071" endWordPosition="5072">xuz. (iii) less than F5(u,v) is a phrase from NG, translating to Xx.Xu.- (3nz.buz A xuz). R9. Let u be a phrase from SE, translating to b. Then is it the case that u is a phrase from YN, translating to Xt.Xu.bu&lt;.&gt;t R10. Let u be a phrase from CN, translating to b. Then: (i) what F6(u) is a phrase from NG?NG, translating to Xy.Xx.Xu.ybu A yxu. (ii) how many F 6(u) is a phrase from NG?NU, translating to Xm.Xx.Xu.(3mz.buz A xuz) A (3(m+1)z.buz A xuz. 3.2.4 The abstraction rule This rule is to replace the variables hei and theyi by other noun phrases. The necessity for abstraction is discussed in Lewis (1972). The syntactic functions F7 and F8, defined below, are used. In these definitions, let u&apos; be the result of replacing the first noun in u with its objective form, let up be the result of replacing the first noun in u with its plural form, and let u &apos;p be the result of replacing the first noun in u with its plural objective form. F7(u,v,i) is the result of replacing, in v, all occurrences of hei by u and all occurrences of him; by u&apos;. F8(u,v,i) is the result of replacing in v, all occurrences of theyi by up and all occurrences of them; by u&apos;p. Syntactic Rule: R11. Let u be a phrase from NG, v b</context>
</contexts>
<marker>Lewis, 1972</marker>
<rawString>Lewis, D. 1972 General semantics. In Davidson, D. and Harman, G., Ed., Semantics of Natural Language. D. Reidel Publishing Co., Dordrecht, Holland.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A D McGettrick</author>
</authors>
<title>The Definition of Programming Languages.</title>
<date>1980</date>
<journal>Cambridge Computer Science Texts</journal>
<volume>11</volume>
<publisher>Cambridge University Press,</publisher>
<location>Cambridge.</location>
<contexts>
<context position="3403" citStr="McGettrick (1980)" startWordPosition="521" endWordPosition="522">re concrete. If there is a familiarity to these arguments, it is because the same reasoning is used to justify formal semantics for programming languages. The problems of design and analysis of question answerers are much the same for programming languages — Benson (1975) argues this point at length. An obvious approach is to apply a programming language technique — denotational semantics — to the problem of formally specifying a question answerer. As a bonus, the method is understood by many programmers and software engineers through introductory textbooks such as Stoy (1977), Gordon (1979), McGettrick (1980), Pagan (1981), and Tennent (1981). Additionally, linguistic treatments of natural language, such as Montague (1973), are basically denotational and we can modify such Copyright 1983 by the Association for Computational Linguistics. Permission to copy without fee all or part of this material is granted provided that the copies are not made for direct commercial advantage and the Journal reference and this copyright notice are included on the first page. To copy otherwise, or to republish, requires a fee and/or specific permission. 0362-613X/83/010011-11$03.00 American Journal of Computational </context>
</contexts>
<marker>McGettrick, 1980</marker>
<rawString>McGettrick, A.D. 1980. The Definition of Programming Languages. (Cambridge Computer Science Texts 11.) Cambridge University Press, Cambridge.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Milne</author>
<author>C Strachey</author>
</authors>
<title>A Theory of Programming Language Semantics.</title>
<date>1976</date>
<publisher>Chapman and Hall,</publisher>
<location>London.</location>
<contexts>
<context position="5202" citStr="Milne and Strachey 1976" startWordPosition="792" endWordPosition="795">hat objects are in the semantic domains has a fundamental effect on the capabilities of the overlying question answerer, as well as an effect on the usefulness and clarity of the semantic descriptions. Lewis (1972) discusses these considerations for natural language sentences and the domains described in section 2 are based on his, although the treatment of questions is closer to Ajdukiewicz (1926). Also introduced in section 2 are the lambda expressions that denote individual semantic objects. Such expressions have been used in denotational semantics of programming languages (see Scott 1970, Milne and Strachey 1976, Stoy 1977) and in treatments of fragments of English by Montague (1973). In section 3, evaluation functions mapping inputs for a small question answerer to objects in the semantic domain are given. The allowable questions are defined by a category grammar as has been done by Ajdukiewicz (1935), Carnap (1937), Lewis (1972), Montague (1973), and others. An account of the answer relationship is given in section 4. In the final section, we briefly describe an implementation of the question answerer and suggest some broad principles for designing question answerers. 2. Semantic Domains for Natura</context>
</contexts>
<marker>Milne, Strachey, 1976</marker>
<rawString>Milne, R. and Strachey, C. 1976 A Theory of Programming Language Semantics. Chapman and Hall, London.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Montague</author>
</authors>
<title>The Proper Treatment of Quantification in Ordinary English. In</title>
<date>1973</date>
<publisher>Yale University Press,</publisher>
<location>New Haven, Connecticut</location>
<contexts>
<context position="3519" citStr="Montague (1973)" startWordPosition="537" endWordPosition="538">semantics for programming languages. The problems of design and analysis of question answerers are much the same for programming languages — Benson (1975) argues this point at length. An obvious approach is to apply a programming language technique — denotational semantics — to the problem of formally specifying a question answerer. As a bonus, the method is understood by many programmers and software engineers through introductory textbooks such as Stoy (1977), Gordon (1979), McGettrick (1980), Pagan (1981), and Tennent (1981). Additionally, linguistic treatments of natural language, such as Montague (1973), are basically denotational and we can modify such Copyright 1983 by the Association for Computational Linguistics. Permission to copy without fee all or part of this material is granted provided that the copies are not made for direct commercial advantage and the Journal reference and this copyright notice are included on the first page. To copy otherwise, or to republish, requires a fee and/or specific permission. 0362-613X/83/010011-11$03.00 American Journal of Computational Linguistics, Volume 9, Number 1, January-March 1983 11 Michael G. Main and David B. Benson Denotational Semantics fo</context>
<context position="5275" citStr="Montague (1973)" startWordPosition="806" endWordPosition="807">ies of the overlying question answerer, as well as an effect on the usefulness and clarity of the semantic descriptions. Lewis (1972) discusses these considerations for natural language sentences and the domains described in section 2 are based on his, although the treatment of questions is closer to Ajdukiewicz (1926). Also introduced in section 2 are the lambda expressions that denote individual semantic objects. Such expressions have been used in denotational semantics of programming languages (see Scott 1970, Milne and Strachey 1976, Stoy 1977) and in treatments of fragments of English by Montague (1973). In section 3, evaluation functions mapping inputs for a small question answerer to objects in the semantic domain are given. The allowable questions are defined by a category grammar as has been done by Ajdukiewicz (1935), Carnap (1937), Lewis (1972), Montague (1973), and others. An account of the answer relationship is given in section 4. In the final section, we briefly describe an implementation of the question answerer and suggest some broad principles for designing question answerers. 2. Semantic Domains for Natural Language 2.1 The Domains A semantic domain is a set of objects. The obj</context>
<context position="12479" citStr="Montague (1973)" startWordPosition="2005" endWordPosition="2006">y an interrogative lacks something. For example, Ajdukiewicz (1926) would represent the meaning of the interroga4 A name, such as John, is one type of noun group that denotes a particular atom which does not change from universe to universe Therefore, it might be better to have names in a separate syntactic category with assigned semantic domain A. But, doing this would not do away with the category noun group, since some noun phrases are not names (e.g., every stone). But, having two categories unduly complicates the syntax, so we lump names together with other noun groups, and treat them as Montague (1973) has. 5 This method of assigning semantic domains is an application of Frege&apos;s rule of compositionality, which says that the meaning of a compound phrase is composed from the meaning of its parts. (Frege 1892, van Emde Boas and Janssen 1979) tive sentence what is black and white and read all over as: ?x(x is black and white and read all over). Here, x is a variable and &amp;quot;?&amp;quot; a quantifier indicating the lack. In this case, the range of the variable is the set of noun group phrases that could answer the question. There are also interrogative phrases in other categories, such as the intransitive ve</context>
</contexts>
<marker>Montague, 1973</marker>
<rawString>Montague, R. 1973 The Proper Treatment of Quantification in Ordinary English. In Thomasen, R., Ed., Formal Philosophy. Selected Papers of Richard Montague. Yale University Press, New Haven, Connecticut (1974).</rawString>
</citation>
<citation valid="true">
<authors>
<author>F G Pagen</author>
</authors>
<title>Formal Specification of Programming Languages: A Panoramic Primer.</title>
<date>1981</date>
<publisher>Prentice-Hall, Inc.,</publisher>
<location>Englewood Cliffs, New Jersey.</location>
<marker>Pagen, 1981</marker>
<rawString>Pagen, F.G. 1981 Formal Specification of Programming Languages: A Panoramic Primer. Prentice-Hall, Inc., Englewood Cliffs, New Jersey.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D Scott</author>
</authors>
<title>Data Types as Lattices,</title>
<date>1976</date>
<journal>SIAM Journal of Computing</journal>
<volume>5</volume>
<pages>522--587</pages>
<marker>Scott, 1976</marker>
<rawString>Scott, D. 1976 Data Types as Lattices, SIAM Journal of Computing 5: 522-587.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Stoy</author>
</authors>
<title>Denotational Semantics: The Scott-Strachey Approach to Programming Language Theory.</title>
<date>1977</date>
<publisher>MIT Press,</publisher>
<location>Cambridge, Massachusetts.</location>
<contexts>
<context position="3369" citStr="Stoy (1977)" startWordPosition="517" endWordPosition="518">se advantages become even more concrete. If there is a familiarity to these arguments, it is because the same reasoning is used to justify formal semantics for programming languages. The problems of design and analysis of question answerers are much the same for programming languages — Benson (1975) argues this point at length. An obvious approach is to apply a programming language technique — denotational semantics — to the problem of formally specifying a question answerer. As a bonus, the method is understood by many programmers and software engineers through introductory textbooks such as Stoy (1977), Gordon (1979), McGettrick (1980), Pagan (1981), and Tennent (1981). Additionally, linguistic treatments of natural language, such as Montague (1973), are basically denotational and we can modify such Copyright 1983 by the Association for Computational Linguistics. Permission to copy without fee all or part of this material is granted provided that the copies are not made for direct commercial advantage and the Journal reference and this copyright notice are included on the first page. To copy otherwise, or to republish, requires a fee and/or specific permission. 0362-613X/83/010011-11$03.00 </context>
<context position="5214" citStr="Stoy 1977" startWordPosition="796" endWordPosition="797">mantic domains has a fundamental effect on the capabilities of the overlying question answerer, as well as an effect on the usefulness and clarity of the semantic descriptions. Lewis (1972) discusses these considerations for natural language sentences and the domains described in section 2 are based on his, although the treatment of questions is closer to Ajdukiewicz (1926). Also introduced in section 2 are the lambda expressions that denote individual semantic objects. Such expressions have been used in denotational semantics of programming languages (see Scott 1970, Milne and Strachey 1976, Stoy 1977) and in treatments of fragments of English by Montague (1973). In section 3, evaluation functions mapping inputs for a small question answerer to objects in the semantic domain are given. The allowable questions are defined by a category grammar as has been done by Ajdukiewicz (1935), Carnap (1937), Lewis (1972), Montague (1973), and others. An account of the answer relationship is given in section 4. In the final section, we briefly describe an implementation of the question answerer and suggest some broad principles for designing question answerers. 2. Semantic Domains for Natural Language 2</context>
<context position="34729" citStr="Stoy (1977)" startWordPosition="6066" endWordPosition="6067">er owns some stone is: (R9) is it the case that every player owns some stone (R2) every player owns some stone (R7) every player (R3) own some stone V \ player own (R7) some stone stone We have these translations: own some stone: Xu.Xz.3z&apos;.(stone)uz&apos; A (own)uzz&apos; 9 In particular, we use logical conversion (such as b A b converts to b) and the a- and /3-conversions of lambda calculus. a-conversion involves changing the name of a bound variable (e.g., Xx.x A y converts to Xz.z A y). /3-conversion corresponds to functional application (e.g., (Xx.x A y)z converts to z A y). Details can be found in Stoy (1977). every player: Xx.Xu.Vz.(player)uz xuz every player owns some stone: Xu.Vz.(player)uz (3z&apos;.(stone)uz&apos; A (own)uzz&apos;) is it the case that every player owns some stone: Xt.Au.(Vz.(player)uz (3z&apos;.(stone)uz&apos; A (own)uzz&apos;)) &lt;=&gt; t Let true be a constant of type T that interprets to `true&apos;e T. From the definition of an answer, &apos;true&apos; is an answer to this question in the universe II g II p iff: II (Xt.Xu.(Vz.(player)uz A (3z&apos;.(stone)uz&apos; A (own)uzz&apos;)) t)(true)g II ip Here, 11., can be picked at random. The above expression converts to II Vz.(player)gz (3z&apos;.(stone)gz&apos; A (own)gzz&apos;) This is a reasonable con</context>
</contexts>
<marker>Stoy, 1977</marker>
<rawString>Stoy, J. 1977 Denotational Semantics: The Scott-Strachey Approach to Programming Language Theory. MIT Press, Cambridge, Massachusetts.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R D Tennent</author>
</authors>
<title>Principles of Programming Languages.</title>
<date>1981</date>
<publisher>PrenticeHall, Inc.,</publisher>
<location>Englewood Cliffs, New Jersey.</location>
<contexts>
<context position="3437" citStr="Tennent (1981)" startWordPosition="526" endWordPosition="527">y to these arguments, it is because the same reasoning is used to justify formal semantics for programming languages. The problems of design and analysis of question answerers are much the same for programming languages — Benson (1975) argues this point at length. An obvious approach is to apply a programming language technique — denotational semantics — to the problem of formally specifying a question answerer. As a bonus, the method is understood by many programmers and software engineers through introductory textbooks such as Stoy (1977), Gordon (1979), McGettrick (1980), Pagan (1981), and Tennent (1981). Additionally, linguistic treatments of natural language, such as Montague (1973), are basically denotational and we can modify such Copyright 1983 by the Association for Computational Linguistics. Permission to copy without fee all or part of this material is granted provided that the copies are not made for direct commercial advantage and the Journal reference and this copyright notice are included on the first page. To copy otherwise, or to republish, requires a fee and/or specific permission. 0362-613X/83/010011-11$03.00 American Journal of Computational Linguistics, Volume 9, Number 1, J</context>
</contexts>
<marker>Tennent, 1981</marker>
<rawString>Tennent, R.D. 1981 Principles of Programming Languages. PrenticeHall, Inc., Englewood Cliffs, New Jersey.</rawString>
</citation>
<citation valid="true">
<authors>
<author>van Emde Boas</author>
<author>P</author>
<author>T Janssen</author>
</authors>
<title>The Impact of Frege&apos;s Principle of Compositionality for the Semantics of Programming and Natural Languages.</title>
<date>1979</date>
<tech>Report 79-07,</tech>
<institution>University of Amsterdam.</institution>
<marker>Boas, P, Janssen, 1979</marker>
<rawString>van Emde Boas, P. and Janssen, T. 1979 The Impact of Frege&apos;s Principle of Compositionality for the Semantics of Programming and Natural Languages. Report 79-07, University of Amsterdam.</rawString>
</citation>
<citation valid="true">
<authors>
<author>T Winograd</author>
</authors>
<title>Understanding Natural Language.</title>
<date>1972</date>
<publisher>Academic Press,</publisher>
<location>New York, New York.</location>
<contexts>
<context position="1054" citStr="Winograd (1972)" startWordPosition="151" endWordPosition="152">swerer communicating with a small data base. This example is partly based on treatment of fragments of English by Montague. Emphasis is placed on the semantic interpretation of questions. The &amp;quot;meaning&amp;quot; of a question is taken as a function from the set of universes to a set of possible answers. 1. Introduction We advocate the use of Scott-Strachey denotational semantics for &amp;quot;natural&amp;quot; language question-answering programs. The majority of this paper demonstrates the use of denotational semantics for a small question answerer. The types of questions possible are similar to those in Harris (1979), Winograd (1972), and Woods (1972). The analysis is not as deep as in Karttunen (1977) or similar studies, as it is oriented to the specification of useful, but linguistically modest, capabilities. Before the demonstration, we discuss the benefits of formal semantics and why denotational semantics is an appropriate formalization. The semantics of a question answerer is given by defining the action of the program for each possible input. An informal semantic description, perhaps in narrative form, is necessary for a potential user who wants to know what questions he may ask and what sort of answers the program</context>
<context position="7256" citStr="Winograd 1972" startWordPosition="1122" endWordPosition="1123"> are not concerned with the internal structure of these objects; hence they are called atoms and the domain is designated A. Two other domains are the set of natural numbers, designated N, and the set of truth values {true, falsel, designated T. A fourth domain is the set of possible universes, designated U. Intuitively, a universe is a description of properties of atoms, the relationships between atoms, the relationships between relationships, etc.... A universe is usually a partial description including only the properties and relationships of interest. For example, in the toy blocks world (Winograd 1972) a universe is the specification of the size, shape, color, and position of all the blocks in the scene. A toy blocks universe does not include a description of the density, mass, or material composition of the various blocks. In application, the set of possible universes may be called a &amp;quot;data base&amp;quot;, and each actual universe is a specific state or configuration of the data base. The internal structure of such a data base is left unspecified in this paper. Other semantic domains are built from the four basic domains. For example, the set of functions from universes to truth values, designated [</context>
</contexts>
<marker>Winograd, 1972</marker>
<rawString>Winograd, T. 1972 Understanding Natural Language. Academic Press, New York, New York.</rawString>
</citation>
<citation valid="true">
<authors>
<author>W A Woods</author>
</authors>
<title>Transition Network Grammars for Natural Language Analysis,</title>
<date>1970</date>
<journal>Communications of the ACM</journal>
<volume>13</volume>
<issue>10</issue>
<pages>591--602</pages>
<contexts>
<context position="40524" citStr="Woods 1970" startWordPosition="7008" endWordPosition="7009">n outline of the program&apos;s organization will lead to some concluding remarks. The program was written as a class project by the first author and four other students. The logical divisions of the program were as follows: 20 American Journal of Computational Linguistics, Volume 9, Number 1, January-March 1983 Michael G. Main and David B. Benson Denotational Semantics for &apos;Natural&apos; Language Q-A Programs • Lexical analysis. The input is broken into basic component words, or &amp;quot;tokens&amp;quot;, using finite automata techniques as in Johnson et al. (1968). • Syntactic parser. An augmented transition network (Woods 1970) parses the input according to the category grammar with heuristic rules and interactive query to solve ambiguities. The output is a single derivation tree. • Semantic interpretation. The &amp;quot;meaning&amp;quot; of the sentence is computed according to the semantic rules. The output of this phase can be thought of as &amp;quot;machine code&amp;quot; for finding answers. At this stage, the &amp;quot;code&amp;quot; is independent of the actual structure of the implementation of the underlying data base. • Deductive components. The &amp;quot;code&amp;quot; from the previous stage is improved based on conversion rules of logic, such as x or x = x. It is also modif</context>
</contexts>
<marker>Woods, 1970</marker>
<rawString>Woods, W.A. 1970 Transition Network Grammars for Natural Language Analysis, Communications of the ACM 13(10): 591-602.</rawString>
</citation>
<citation valid="true">
<authors>
<author>W A Woods</author>
</authors>
<title>The Lunar Sciences Natural Language Information System.</title>
<date>1972</date>
<tech>Report 2378,</tech>
<institution>Bolt Beranek and Newman.</institution>
<contexts>
<context position="1072" citStr="Woods (1972)" startWordPosition="154" endWordPosition="155">with a small data base. This example is partly based on treatment of fragments of English by Montague. Emphasis is placed on the semantic interpretation of questions. The &amp;quot;meaning&amp;quot; of a question is taken as a function from the set of universes to a set of possible answers. 1. Introduction We advocate the use of Scott-Strachey denotational semantics for &amp;quot;natural&amp;quot; language question-answering programs. The majority of this paper demonstrates the use of denotational semantics for a small question answerer. The types of questions possible are similar to those in Harris (1979), Winograd (1972), and Woods (1972). The analysis is not as deep as in Karttunen (1977) or similar studies, as it is oriented to the specification of useful, but linguistically modest, capabilities. Before the demonstration, we discuss the benefits of formal semantics and why denotational semantics is an appropriate formalization. The semantics of a question answerer is given by defining the action of the program for each possible input. An informal semantic description, perhaps in narrative form, is necessary for a potential user who wants to know what questions he may ask and what sort of answers the program will provide. Inf</context>
</contexts>
<marker>Woods, 1972</marker>
<rawString>Woods, W.A. 1972 The Lunar Sciences Natural Language Information System. Report 2378, Bolt Beranek and Newman.</rawString>
</citation>
<citation valid="true">
<date>1983</date>
<journal>American Journal of Computational Linguistics,</journal>
<volume>9</volume>
<pages>21</pages>
<marker>1983</marker>
<rawString>American Journal of Computational Linguistics, Volume 9, Number 1, January-March 1983 21</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>