<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000595">
<title confidence="0.988013">
Statistical Machine Translation by Parsing
</title>
<author confidence="0.975858">
I. Dan Melamed
</author>
<affiliation confidence="0.986979">
Computer Science Department
</affiliation>
<address confidence="0.813903">
New York University
New York, NY, U.S.A.
10003-6806
</address>
<email confidence="0.999295">
lastname@cs.nyu.edu
</email>
<sectionHeader confidence="0.993899" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.9974268">
In an ordinary syntactic parser, the input is a string,
and the grammar ranges over strings. This paper
explores generalizations of ordinary parsing algo-
rithms that allow the input to consist of string tu-
ples and/or the grammar to range over string tu-
ples. Such algorithms can infer the synchronous
structures hidden in parallel texts. It turns out that
these generalized parsers can do most of the work
required to train and apply a syntax-aware statisti-
cal machine translation system.
</bodyText>
<sectionHeader confidence="0.998783" genericHeader="introduction">
1 Introduction
</sectionHeader>
<bodyText confidence="0.994293586206897">
A parser is an algorithm for inferring the structure
of its input, guided by a grammar that dictates what
structures are possible or probable. In an ordinary
parser, the input is a string, and the grammar ranges
over strings. This paper explores generalizations of
ordinary parsing algorithms that allow the input to
consist of string tuples and/or the grammar to range
over string tuples. Such inference algorithms can
perform various kinds of analysis on parallel texts,
also known as multitexts.
Figure 1 shows some of the ways in which ordi-
nary parsing can be generalized. A synchronous
parser is an algorithm that can infer the syntactic
structure of each component text in a multitext and
simultaneously infer the correspondence relation
between these structures.&apos; When a parser’s input
can have fewer dimensions than the parser’s gram-
mar, we call it a translator. When a parser’s gram-
mar can have fewer dimensions than the parser’s
input, we call it a synchronizer. The corre-
sponding processes are called translation and syn-
chronization. To our knowledge, synchronization
has never been explored as a class of algorithms.
Neither has the relationship between parsing and
word alignment. The relationship between trans-
lation and ordinary parsing was noted a long time
&apos;A suitable set of ordinary parsers can also infer the syntac-
tic structure of each component, but cannot infer the correspon-
dence relation between these structures.
</bodyText>
<figureCaption confidence="0.992572444444444">
Figure 1: Generalizations of ordinary parsing.
ago (Aho &amp; Ullman, 1969), but here we articu-
late it in more detail: ordinary parsing is a spe-
cial case of synchronous parsing, which is a special
case of translation. This paper offers an informal
guided tour of the generalized parsing algorithms in
Figure 1. It culminates with a recipe for using these
algorithms to train and apply a syntax-aware statis-
tical machine translation (SMT) system.
</figureCaption>
<sectionHeader confidence="0.761526" genericHeader="method">
2 Multitext Grammars and Multitrees
</sectionHeader>
<bodyText confidence="0.999855692307692">
The algorithms in this paper can be adapted for any
synchronous grammar formalism. The vehicle for
the present guided tour shall be multitext grammar
(MTG), which is a generalization of context-free
grammar to the synchronous case (Melamed, 2003).
We shall limit our attention to MTGs in Generalized
Chomsky Normal Form (GCNF) (Melamed et al.,
2004). This normal form allows simpler algorithm
descriptions than the normal forms used by Wu
(1997) and Melamed (2003).
In GCNF, every production is either a terminal
production or a nonterminal production. A nonter-
minal production might look like this:
</bodyText>
<figure confidence="0.983092733333333">
ordinary
parsing
1
2
3
1
...
I = dimensionality of input
3
2
D = dimensionality of grammar
...
generalized parsing
(any D; any I)
synchronization
(I &gt;= D)
synchronous
translation
(D &gt;= I)
word
alignment
ordinary
parsing
(D=I=1)
parsing
(D=I)
D(2)
A
B
E
</figure>
<page confidence="0.478825">
(1)
</page>
<bodyText confidence="0.98965924137931">
There are nonterminals on the left-hand side (LHS)
and in parentheses on the right-hand side (RHS).
Each row of the production describes rewriting in
a different component text of a multitext. In each
row, a role template describes the relative order
and contiguity of the RHS nonterminals. E.g., in
the top row, [1,2] indicates that the first nonter-
minal (A) precedes the second (B). In the bottom
row, [1,2,1] indicates that the first nonterminal both
precedes and follows the second, i.e. D is discon-
tinuous. Discontinuous nonterminals are annotated
with the number of their contiguous segments, as in
. The (“join”) operator rearranges the non-
terminals in each component according to their role
template. The nonterminals on the RHS are writ-
ten in columns called links. Links express transla-
tional equivalence. Some nonterminals might have
no translation in some components, indicated by (),
as in the 2nd row. Terminal productions have ex-
actly one “active” component, in which there is ex-
actly one terminal on the RHS. The other compo-
nents are inactive. E.g.,
(2)
The semantics of are the usual semantics of
rewriting systems, i.e., that the expression on the
LHS can be rewritten as the expression on the RHS.
However, all the nonterminals in the same link must
be rewritten simultaneously. In this manner, MTGs
generate tuples of parse trees that are isomorphic up
to reordering of sibling nodes and deletion. Figure 2
shows two representations of a tree that might be
generated by an MTG in GCNF for the imperative
sentence pair Wash the dishes / Pasudu moy . The
tree exhibits both deletion and inversion in transla-
tion. We shall refer to such multidimensional trees
as multitrees.
The different classes of generalized parsing al-
gorithms in this paper differ only in their gram-
mars and in their logics. They are all compatible
with the same parsing semirings and search strate-
gies. Therefore, we shall describe these algorithms
in terms of their underlying logics and grammars,
abstracting away the semirings and search strate-
gies, in order to elucidate how the different classes
of algorithms are related to each other. Logical de-
scriptions of inference algorithms involve inference
rules: means that can be inferred from
and . An item that appears in an inference rule
stands for the proposition that the item is in the parse
chart. A production rule that appears in an inference
rule stands for the proposition that the production is
in the grammar. Such specifications are nondeter-
Figure 2: Above: A tree generated by a 2-MTG
in English and (transliterated) Russian. Every in-
ternal node is annotated with the linear order of
its children, in every component where there are
two children. Below: A graphical representation
of the same tree. Rectangles are 2D constituents.
</bodyText>
<equation confidence="0.935906">
S
NP
</equation>
<bodyText confidence="0.999665857142857">
ministic: they do not indicate the order in which a
parser should attempt inferences. A deterministic
parsing strategy can always be chosen later, to suit
the application. We presume that readers are famil-
iar with declarative descriptions of inference algo-
rithms, as well as with semiring parsing (Goodman,
1999).
</bodyText>
<sectionHeader confidence="0.991825" genericHeader="method">
3 A Synchronous CKY Parser
</sectionHeader>
<bodyText confidence="0.994124833333333">
Figure 3 shows Logic C. Parser C is any
parser based on Logic C. As in Melamed
(2003)’s Parser A, Parser C’s items consist
of a -dimensional label vector and a
-dimensional d-span vector .2 The items con-
tain d-spans, rather than ordinary spans, because
</bodyText>
<subsectionHeader confidence="0.443059">
2Superscripts and subscripts indicate the range of dimen-
</subsectionHeader>
<bodyText confidence="0.911632666666667">
sions of a vector. E.g., is a vector spanning dimensions 1
through . See Melamed (2003) for definitions of cardinality,
d-span, and the operators and .
</bodyText>
<figure confidence="0.992510533333334">
Wash
moy
the
dishes
Pasudu
V N
WASH D DISH
Wash the dishes
PAS
Pasudu
MIT
V moy
S
NP
N
</figure>
<bodyText confidence="0.999187121212121">
Parser C needs to know all the boundaries of each
item, not just the outermost boundaries. Some (but
not all) dimensions of an item can be inactive, de-
noted , and have an empty d-span ().
The input to Parser C is a tuple of parallel texts,
with lengths . The notation in-
dicates that the Goal item must span the input from
the left of the first word to the right of the last word
in each component . Thus, the Goal
item must be contiguous in all dimensions.
Parser C begins with an empty chart. The only in-
ferences that can fire in this state are those with no
antecedent items (though they can have antecedent
production rules). In Logic C, is the value
that the grammar assigns to the terminal production
. The range of this value depends on the
semiring used. A Scan inference can fire for theth
word in component for every terminal pro-
duction in the grammar where appears in the
th component. Each Scan consequent has exactly
one active d-span, and that d-span always has the
form because such items always span one
word, so the distance between the item’s boundaries
is always one.
The Compose inference in Logic C is the same
as in Melamed’s Parser A, using slightly different
notation: In Logic C, the function
represents the value that the grammar assigns to the
nonterminal production . Parser C can
compose two items if their labels appear on the RHS
of a production rule in the grammar, and if the con-
tiguity and relative order of their intervals is consis-
tent with the role templates of that production rule.
</bodyText>
<figureCaption confidence="0.981724">
Figure 3: Logic C (“C” for CKY)
</figureCaption>
<bodyText confidence="0.999943291666667">
These constraints are enforced by the d-span opera-
tors and .
Parser C is conceptually simpler than the syn-
chronous parsers of Wu (1997), Alshawi et al.
(2000), and Melamed (2003), because it uses only
one kind of item, and it never composes terminals.
The inference rules of Logic C are the multidimen-
sional generalizations of inference rules with the
same names in ordinary CKY parsers. For exam-
ple, given a suitable grammar and the input (imper-
ative) sentence pair Wash the dishes / Pasudu moy,
Parser C might make the 9 inferences in Figure 4 to
infer the multitree in Figure 2. Note that there is one
inference per internal node of the multitree.
Goodman (1999) shows how a parsing logic can
be combined with various semirings to compute dif-
ferent kinds of information about the input. De-
pending on the chosen semiring, a parsing logic can
compute the single most probable derivation and/or
its probability, the most probable derivations
and/or their total probability, all possible derivations
and/or their total probability, the number of possi-
ble derivations, etc. All the parsing semirings cat-
alogued by Goodman apply the same way to syn-
chronous parsing, and to all the other classes of al-
gorithms discussed in this paper.
The class of synchronous parsers includes some
algorithms for word alignment. A translation lexi-
con (weighted or not) can be viewed as a degenerate
MTG (not in GCNF) where every production has a
link of terminals on the RHS. Under such an MTG,
the logic of word alignment is the one in Melamed
(2003)’s Parser A, but without Compose inferences.
The only other difference is that, instead of a single
item, the Goal of word alignment is any set of items
that covers all dimensions of the input. This logic
can be used with the expectation semiring (Eisner,
2002) to find the maximum likelihood estimates of
the parameters of a word-to-word translation model.
An important application of Parser C is parameter
estimation for probabilistic MTGs (PMTGs). Eis-
ner (2002) has claimed that parsing under an expec-
tation semiring is equivalent to the Inside-Outside
algorithm for PCFGs. If so, then there is a straight-
forward generalization for PMTGs. Parameter es-
timation is beyond the scope of this paper, however.
The next section assumes that we have an MTG,
probabilistic or not, as required by the semiring.
</bodyText>
<sectionHeader confidence="0.99833" genericHeader="method">
4 Translation
</sectionHeader>
<bodyText confidence="0.975355">
A -MTG can guide a synchronous parser to in-
fer the hidden structure of a -component multi-
text. Now suppose that we have a -MTG and an
input multitext with only components, .
</bodyText>
<figure confidence="0.69089125">
Item Form: Goal:
Inference Rules
Scan component d, :
Compose:
</figure>
<figureCaption confidence="0.9947225">
Figure 4: Possible sequence of inferences of
Parser C on input Wash the dishes / Pasudu moy.
</figureCaption>
<bodyText confidence="0.986050375">
When some of the component texts are missing,
we can ask the parser to infer a -dimensional
multitree that includes the missing components.
The resulting multitree will cover the input
components/dimensions among its dimensions.
It will also express the output compo-
nents/dimensions, along with their syntactic struc-
tures.
</bodyText>
<figureCaption confidence="0.987117">
Figure 5: Logic CT (“T” for Translation)
</figureCaption>
<bodyText confidence="0.998331407407407">
Figure 5 shows Logic CT, which is a generaliza-
tion of Logic C. Translator CT is any parser based
on Logic CT. The items of Translator CT have a
-dimensional label vector, as usual. However,
their d-span vectors are only-dimensional, be-
cause it is not necessary to constrain absolute word
positions in the output dimensions. Instead, we need
only constrain the cardinality of the output nonter-
minals, which is accomplished by the role templates
in the term. Translator CT scans only
the input components. Terminal productions with
active output components are simply loaded from
the grammar, and their LHSs are added to the chart
without d-span information. Composition proceeds
as before, except that there are no constraints on the
role templates in the output dimensions – the role
templates in are free variables.
In summary, Logic CT differs from Logic C as
follows:
Items store no position information (d-spans)
for the output components.
For the output components, the Scan infer-
ences are replaced by Load inferences, which
are not constrained by the input.
The Compose inference does not constrain the
d-spans of the output components. (Though it
still constrains their cardinality.)
</bodyText>
<figure confidence="0.944389571428571">
Item Form: Goal:
Inference Rules
Scan component
:
Compose:
Load component,
:
</figure>
<bodyText confidence="0.999930310344828">
We have constructed a translator from a syn-
chronous parser merely by relaxing some con-
straints on the output dimensions. Logic C is just
Logic CT for the special case where . The
relationship between the two classes of algorithms
is easier to see from their declarative logics than it
would be from their procedural pseudocode or equa-
tions.
Like Parser C, Translator CT can Compose items
that have no dimensions in common. If one of the
items is active only in the input dimension(s), and
the other only in the output dimension(s), then the
inference is, de facto, a translation. The possible
translations are determined by consulting the gram-
mar. Thus, in addition to its usual function of eval-
uating syntactic structures, the grammar simultane-
ously functions as a translation model.
Logic CT can be coupled with any parsing semir-
ing. For example, under a boolean semiring, this
logic will succeed on an-dimensional input if and
only if it can infer a -dimensional multitree whose
root is the goal item. Such a tree would contain a
-dimensional translation of the input. Thus,
under a boolean semiring, Translator CT can deter-
mine whether a translation of the input exists.
Under an inside-probability semiring, Transla-
tor CT can compute the total probability of all mul-
titrees containing the input and its translations in the
output components. All these derivation trees,
along with their probabilities, can be efficiently rep-
resented as a packed parse forest, rooted at the goal
item. Unfortunately, finding the most probable out-
put string still requires summing probabilities over
an exponential number of trees. This problem was
shown to be NP-hard in the one-dimensional case
(Sima’an, 1996). We have no reason to believe that
it is any easier when
each internal node of the tree. The intended order-
ing of the terminals in each output dimension can be
assembled from these templates by a linear-time lin-
earization post-process that traverses the finished
multitree in postorder.
To the best of our knowledge, Logic CT is the first
published translation logic to be compatible with all
of the semirings catalogued by Goodman (1999),
among others. It is also the first to simultaneously
accommodate multiple input components and mul-
tiple output components. When a source docu-
ment is available in multiple languages, a translator
can benefit from the disambiguating information in
each. Translator CT can take advantage of such in-
formation without making the strong independence
assumptions of Och &amp; Ney (2001). When output is
desired in multiple languages, Translator CT offers
all the putative benefits of the interlingual approach
to MT, including greater efficiency and greater con-
sistency across output components. Indeed, the lan-
guage of multitrees can be viewed as an interlingua.
</bodyText>
<sectionHeader confidence="0.995005" genericHeader="method">
5 Synchronization
</sectionHeader>
<bodyText confidence="0.999656814814815">
We have explored inference of-dimensional multi-
trees under a -dimensional grammar, where
. Now we generalize along the other axis of
Figure 1(a). Multitext synchronization is most of-
ten used to infer-dimensional multitrees without
the benefit of an-dimensional grammar. One ap-
plication is inducing a parser in one language from a
parser in another (L¨u et al., 2002). The application
that is most relevant to this paper is bootstrapping an
-dimensional grammar. In theory, it is possible to
induce a PMTG from multitext in an unsupervised
manner. A more reliable way is to start from a
corpus of multitrees — a multitreebank.3
We are not aware of any multitreebanks at this
time. The most straightforward way to create one is
to parse some multitext using a synchronous parser,
such as Parser C. However, if the goal is to boot-
strap an-PMTG, then there is no-PMTG that can
evaluate the terms in the parser’s logic. Our solu-
tion is to orchestrate lower-dimensional knowledge
sources to evaluate the terms. Then, we can use
the same parsing logic to synchronize multitext into
a multitreebank.
To illustrate, we describe a relatively simple syn-
chronizer, using the Viterbi-derivation semiring.4
Under this semiring, a synchronizer computes the
single most probable multitree for a given multitext.
</bodyText>
<footnote confidence="0.99810075">
3In contrast, a parallel treebank might contain no informa-
tion about translational equivalence.
4The inside-probability semiring would be required for
maximum-likelihood synchronization.
</footnote>
<bodyText confidence="0.99485">
.
The Viterbi-derivation semiring would be the
most often used with Translator CT in prac-
tice. Given a -PMTG, Translator CT can
use this semiring to find the single most prob-
able -dimensional multitree that covers the
-dimensional input. The multitree inferred by the
translator will have the words of both the input and
the output components in its leaves. For example,
given a suitable grammar and the input Pasudu moy,
Translator CT could infer the multitree in Figure 2.
The set of inferences would be exactly the same as
those listed in Figure 4, except that the items would
have no d-spans in the English component.
In practice, we usually want the output as a string
tuple, rather than as a multitree. Under the vari-
ous derivation semirings (Goodman, 1999), Trans-
</bodyText>
<figure confidence="0.8449886">
lator CT can store the output role templates in
I fed the cat
ya
kota
kormil
</figure>
<figureCaption confidence="0.9994275">
Figure 6: Synchronization. Only one synchronous
dependency structure (dashed arrows) is compatible
with the monolingual structure (solid arrows) and
word alignment (shaded cells).
</figureCaption>
<bodyText confidence="0.999933580645161">
If we have no suitable PMTG, then we can use other
criteria to search for trees that have high probability.
We shall consider the common synchronization sce-
nario where a lexicalized monolingual grammar is
available for at least one component.5 Also, given
a tokenized set of-tuples of parallel sentences,
it is always possible to estimate a word-to-word
translation model (e.g., Och &amp; Ney,
2003).6
A word-to-word translation model and a lexical-
ized monolingual grammar are sufficient to drive a
synchronizer. For example, in Figure 6 a mono-
lingual grammar has allowed only one dependency
structure on the English side, and a word-to-word
translation model has allowed only one word align-
ment. The syntactic structures of all dimensions
of a multitree are isomorphic up to reordering of
sibling nodes and deletion. So, given a fixed cor-
respondence between the tree leaves (i.e. words)
across components, choosing the optimal structure
for one component is tantamount to choosing the
optimal synchronous structure for all components.7
Ignoring the nonterminal labels, only one depen-
dency structure is compatible with these constraints
– the one indicated by dashed arrows. Bootstrap-
ping a PMTG from a lower-dimensional PMTG and
a word-to-word translation model is similar in spirit
to the way that regular grammars can help to es-
timate CFGs (Lari &amp; Young, 1990), and the way
that simple translation models can help to bootstrap
more sophisticated ones (Brown et al., 1993).
</bodyText>
<footnote confidence="0.998964555555556">
5Such a grammar can be induced from a treebank, for exam-
ple. We are currently aware of treebanks for English, Spanish,
German, Chinese, Czech, Arabic, and Korean.
6Although most of the literature discusses word transla-
tion models between only two languages, it is possible to
combine several 2D models into a higher-dimensional model
(Mann &amp; Yarowsky, 2001).
7Except where the unstructured components have words
that are linked to nothing.
</footnote>
<bodyText confidence="0.998708904761905">
We need only redefine the terms in a way that
does not rely on an-PMTG. Without loss of gener-
ality, we shall assume a -PMTG that ranges over
the first components, where . We shall
then refer to the structured components and the
unstructured components.
We begin with . For the structured compo-
nents , we retain the grammar-
based definition:
by applying the chain rule9
and continues by making independence assump-
tions. The first assumption is that the structured
components of the production’s RHS are condition-
ally independent of the unstructured components of
its LHS:
The above probability can be looked up in the
-PMTG. Second, since we have no useful non-
terminals in the unstructured components, we let
if and otherwise. Third,
we assume that the word-to-word translation proba-
bilities are independent of anything else:
</bodyText>
<footnote confidence="0.9984945">
8We have ignored lexical heads so far, but we need them for
this synchronizer.
9The procedure is analogous when the heir is the first non-
terminal link on the RHS, rather than the second.
</footnote>
<bodyText confidence="0.985164352941176">
,s
where the latter probability can be looked up in
our -PMTG. For the unstructured components,
there are no useful nonterminal labels. Therefore,
we assume that the unstructured components use
only one (dummy) nonterminal label , so that
if and undefined oth-
erwise for .
Our treatment of nonterminal productions begins
These probabilities can be obtained from our word-
to-word translation model, which would typically
be estimated under exactly such an independence
assumption. Finally, we assume that the output role
templates are independent of each other and uni-
formly distributed, up to some maximum cardinal-
ity . Let be the number of unique role tem-
plates of cardinality or less. Then
</bodyText>
<subsectionHeader confidence="0.743001">
Under Assumptions 5–8,
</subsectionHeader>
<bodyText confidence="0.99994752173913">
if and 0 otherwise. We
can use these definitions of the grammar terms in the
inference rules of Logic C to synchronize multitexts
into multitreebanks.
More sophisticated synchronization methods are
certainly possible. For example, we could project
a part-of-speech tagger (Yarowsky &amp; Ngai, 2001)
to improve our estimates in Equation 6. Yet, de-
spite their relative simplicity, the above methods
for estimating production rule probabilities use all
of the available information in a consistent man-
ner, without double-counting. This kind of synchro-
nizer stands in contrast to more ad-hoc approaches
(e.g., Matsumoto, 1993; Meyers, 1996; Wu, 1998;
Hwa et al., 2002). Some of these previous works
fix the word alignments first, and then infer com-
patible parse structures. Others do the opposite. In-
formation about syntactic structure can be inferred
more accurately given information about transla-
tional equivalence, and vice versa. Commitment to
either kind of information without consideration of
the other increases the potential for compounded er-
rors.
</bodyText>
<sectionHeader confidence="0.982424" genericHeader="method">
6 Multitree-based Statistical MT
</sectionHeader>
<bodyText confidence="0.943795304347826">
Multitree-based statistical machine translation
(MTSMT) is an architecture for SMT that revolves
around multitrees. Figure 7 shows how to build and
use a rudimentary MTSMT system, starting from
some multitext and one or more monolingual tree-
banks. The recipe follows:
T1. Induce a word-to-word translation model.
T2. Induce PCFGs from the relative frequencies of
productions in the monolingual treebanks.
T3. Synchronize some multitext, e.g. using the ap-
proximations in Section 5.
T4. Induce an initial PMTG from the relative fre-
quencies of productions in the multitreebank.
T5. Re-estimate the PMTG parameters, using a
synchronous parser with the expectation semir-
ing.
A1. Use the PMTG to infer the most probable mul-
titree covering new input text.
A2. Linearize the output dimensions of the multi-
tree.
Steps T2, T4 and A2 are trivial. Steps T1, T3, T5,
and A1 are instances of the generalized parsers de-
scribed in this paper.
</bodyText>
<figureCaption confidence="0.926241">
Figure 7 is only an architecture. Computational
</figureCaption>
<bodyText confidence="0.983843181818182">
complexity and generalization error stand in the
way of its practical implementation. Nevertheless,
it is satisfying to note that all the non-trivial algo-
rithms in Figure 7 are special cases of Translator CT.
It is therefore possible to implement an MTSMT
system using just one inference algorithm, param-
eterized by a grammar, a semiring, and a search
strategy. An advantage of building an MT system in
this manner is that improvements invented for ordi-
nary parsing algorithms can often be applied to all
the main components of the system. For example,
Melamed (2003) showed how to reduce the com-
putational complexity of a synchronous parser by
, just by changing the logic. The same opti-
mization can be applied to the inference algorithms
in this paper. With proper software design, such op-
timizations need never be implemented more than
once. For simplicity, the algorithms in this paper
are based on CKY logic. However, the architecture
in Figure 7 can also be implemented using general-
izations of more sophisticated parsing logics, such
as those inherent in Earley or Head-Driven parsers.
</bodyText>
<sectionHeader confidence="0.998933" genericHeader="conclusions">
7 Conclusion
</sectionHeader>
<bodyText confidence="0.999597916666667">
This paper has presented generalizations of ordinary
parsing that emerge when the grammar and/or the
input can be multidimensional. Along the way, it
has elucidated the relationships between ordinary
parsers and other classes of algorithms, some pre-
viously known and some not. It turns out that, given
some multitext and a monolingual treebank, a rudi-
mentary multitree-based statistical machine transla-
tion system can be built and applied using only gen-
eralized parsers and some trivial glue.
There are three research benefits of using gener-
alized parsers to build MT systems. First, we can
</bodyText>
<figureCaption confidence="0.998359">
Figure 7: Data-flow diagram for a rudimentary MTSMT system based on generalizations of parsing.
</figureCaption>
<figure confidence="0.996679717948718">
monolingual
treebank(s)
PCFG(s)
T2
relative
frequency
computation
training
multitext
T1
word
alignment
T5
word−to−word
translation
model
estimation via
multitreebank
synchronous
parameter
parsing
T4
synchronization
relative
frequency
computation
T3
PMTG
input
multitext
A2
output
multitext
training
application
linearization
multitree
A1
translation
</figure>
<bodyText confidence="0.999564">
take advantage of past and future research on mak-
ing parsers more accurate and more efficient. There-
fore, second, we can concentrate our efforts on
better models, without worrying about MT-specific
search algorithms. Third, more generally and most
importantly, this approach encourages MT research
to be less specialized and more transparently related
to the rest of computational linguistics.
</bodyText>
<sectionHeader confidence="0.998231" genericHeader="acknowledgments">
Acknowledgments
</sectionHeader>
<bodyText confidence="0.990898">
Thanks to Joseph Turian, Wei Wang, Ben Wellington, and the
anonymous reviewers for valuable feedback. This research was
supported by an NSF CAREER Award, the DARPA TIDES
program, and an equipment gift from Sun Microsystems.
</bodyText>
<sectionHeader confidence="0.999232" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999732175438596">
A. Aho &amp; J. Ullman (1969) “Syntax Directed Translations and
the Pushdown Assembler,” Journal of Computer and System
Sciences 3, 37-56.
H. Alshawi, S. Bangalore, &amp; S. Douglas (2000) “Learning De-
pendency Translation Models as Collections of Finite State
Head Transducers,” Computational Linguistics 26(1):45-60.
P. F. Brown, S. A. Della Pietra, V. J. Della Pietra, &amp; R. L. Mer-
cer (1993) “The Mathematics of Statistical Machine Trans-
lation: Parameter Estimation,” Computational Linguistics
19(2):263–312.
J. Goodman (1999) “Semiring Parsing,” Computational Lin-
guistics 25(4):573–305.
R. Hwa, P. Resnik, A. Weinberg, &amp; O. Kolak (2002) “Evaluat-
ing Translational Correspondence using Annotation Projec-
tion,” Proceedings of the ACL.
J. Eisner (2002) “Parameter Estimation for Probabilistic Finite-
State Transducers,” Proceedings of the ACL.
K. Lari &amp; S. Young (1990) “The Estimation of Stochas-
tic Context-Free Grammars using the Inside-Outside Algo-
rithm,” Computer Speech and Language Processing 4:35–
56.
Y. L¨u, S. Li, T. Zhao, &amp; M. Yang (2002) “Learning Chinese
Bracketing Knowledge Based on a Bilingual Language
Model,” Proceedings of COLING.
G. S. Mann &amp; D. Yarowsky (2001) “Multipath Translation
Lexicon Induction via Bridge Languages,” Proceedings of
HLT/NAACL.
Y. Matsumoto (1993) “Structural Matching of Parallel Texts,”
Proceedings of the ACL.
I. D. Melamed (2003) “Multitext Grammars and Synchronous
Parsers,” Proceedings of HLT/NAACL.
I. D. Melamed, G. Satta, &amp; B. Wellington (2004) “General-
ized Multitext Grammars,” Proceedings of the ACL (this
volume).
A. Meyers, R. Yangarber, &amp; R. Grishman (1996) “Alignment of
Shared Forests for Bilingual Corpora,” Proceedings of COL-
ING.
F. Och &amp; H. Ney (2001) “Statistical Multi-Source Translation,”
Proceedings ofMT Summit VIII.
F. Och &amp; H. Ney (2003) “A Systematic Comparison of Various
Statistical Alignment Models,” Computational Linguistics
29(1):19-51.
K. Sima’an (1996) “Computational Complexity of Probabilis-
tic Disambiguation by means of Tree-Grammars,” Proceed-
ings of COLING.
D. Wu (1996) “A polynomial-time algorithm for statistical ma-
chine translation,” Proceedings of the ACL.
D. Wu (1997) “Stochastic inversion transduction grammars and
bilingual parsing of parallel corpora,” Computational Lin-
guistics 23(3):377-404.
D. Wu &amp; H. Wong (1998) “Machine translation with a stochas-
tic grammatical channel,” Proceedings of the ACL.
K. Yamada &amp; K. Knight (2002) “A Decoder for Syntax-based
Statistical MT,” Proceedings of the ACL.
D. Yarowsky &amp; G. Ngai (2001) “Inducing Multilingual POS
Taggers and NP Bracketers via Robust Projection Across
Aligned Corpora,” Proceedings of the NAACL.
</reference>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.714048">
<title confidence="0.999871">Statistical Machine Translation by Parsing</title>
<author confidence="0.999545">I Dan Melamed</author>
<affiliation confidence="0.996757">Computer Science Department New York University</affiliation>
<address confidence="0.999763">New York, NY, U.S.A.</address>
<phone confidence="0.727927">10003-6806</phone>
<email confidence="0.999661">lastname@cs.nyu.edu</email>
<abstract confidence="0.998911909090909">In an ordinary syntactic parser, the input is a string, and the grammar ranges over strings. This paper explores generalizations of ordinary parsing algorithms that allow the input to consist of string tuples and/or the grammar to range over string tuples. Such algorithms can infer the synchronous structures hidden in parallel texts. It turns out that these generalized parsers can do most of the work required to train and apply a syntax-aware statistical machine translation system.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>A Aho</author>
<author>J Ullman</author>
</authors>
<title>Syntax Directed Translations and the Pushdown Assembler,”</title>
<date>1969</date>
<journal>Journal of Computer and System Sciences</journal>
<volume>3</volume>
<pages>37--56</pages>
<contexts>
<context position="2179" citStr="Aho &amp; Ullman, 1969" startWordPosition="340" endWordPosition="343">mar can have fewer dimensions than the parser’s input, we call it a synchronizer. The corresponding processes are called translation and synchronization. To our knowledge, synchronization has never been explored as a class of algorithms. Neither has the relationship between parsing and word alignment. The relationship between translation and ordinary parsing was noted a long time &apos;A suitable set of ordinary parsers can also infer the syntactic structure of each component, but cannot infer the correspondence relation between these structures. Figure 1: Generalizations of ordinary parsing. ago (Aho &amp; Ullman, 1969), but here we articulate it in more detail: ordinary parsing is a special case of synchronous parsing, which is a special case of translation. This paper offers an informal guided tour of the generalized parsing algorithms in Figure 1. It culminates with a recipe for using these algorithms to train and apply a syntax-aware statistical machine translation (SMT) system. 2 Multitext Grammars and Multitrees The algorithms in this paper can be adapted for any synchronous grammar formalism. The vehicle for the present guided tour shall be multitext grammar (MTG), which is a generalization of context</context>
</contexts>
<marker>Aho, Ullman, 1969</marker>
<rawString>A. Aho &amp; J. Ullman (1969) “Syntax Directed Translations and the Pushdown Assembler,” Journal of Computer and System Sciences 3, 37-56.</rawString>
</citation>
<citation valid="true">
<authors>
<author>H Alshawi</author>
<author>S Bangalore</author>
<author>S Douglas</author>
</authors>
<title>Learning Dependency Translation Models as</title>
<date>2000</date>
<journal>Collections of Finite State Head Transducers,” Computational Linguistics</journal>
<pages>26--1</pages>
<contexts>
<context position="8832" citStr="Alshawi et al. (2000)" startWordPosition="1477" endWordPosition="1480"> Compose inference in Logic C is the same as in Melamed’s Parser A, using slightly different notation: In Logic C, the function represents the value that the grammar assigns to the nonterminal production . Parser C can compose two items if their labels appear on the RHS of a production rule in the grammar, and if the contiguity and relative order of their intervals is consistent with the role templates of that production rule. Figure 3: Logic C (“C” for CKY) These constraints are enforced by the d-span operators and . Parser C is conceptually simpler than the synchronous parsers of Wu (1997), Alshawi et al. (2000), and Melamed (2003), because it uses only one kind of item, and it never composes terminals. The inference rules of Logic C are the multidimensional generalizations of inference rules with the same names in ordinary CKY parsers. For example, given a suitable grammar and the input (imperative) sentence pair Wash the dishes / Pasudu moy, Parser C might make the 9 inferences in Figure 4 to infer the multitree in Figure 2. Note that there is one inference per internal node of the multitree. Goodman (1999) shows how a parsing logic can be combined with various semirings to compute different kinds </context>
</contexts>
<marker>Alshawi, Bangalore, Douglas, 2000</marker>
<rawString>H. Alshawi, S. Bangalore, &amp; S. Douglas (2000) “Learning Dependency Translation Models as Collections of Finite State Head Transducers,” Computational Linguistics 26(1):45-60.</rawString>
</citation>
<citation valid="true">
<authors>
<author>P F Brown</author>
<author>S A Della Pietra</author>
<author>V J Della Pietra</author>
<author>R L Mercer</author>
</authors>
<date>1993</date>
<journal>The Mathematics of Statistical Machine Translation: Parameter Estimation,” Computational Linguistics</journal>
<volume>19</volume>
<issue>2</issue>
<contexts>
<context position="19774" citStr="Brown et al., 1993" startWordPosition="3253" endWordPosition="3256">een the tree leaves (i.e. words) across components, choosing the optimal structure for one component is tantamount to choosing the optimal synchronous structure for all components.7 Ignoring the nonterminal labels, only one dependency structure is compatible with these constraints – the one indicated by dashed arrows. Bootstrapping a PMTG from a lower-dimensional PMTG and a word-to-word translation model is similar in spirit to the way that regular grammars can help to estimate CFGs (Lari &amp; Young, 1990), and the way that simple translation models can help to bootstrap more sophisticated ones (Brown et al., 1993). 5Such a grammar can be induced from a treebank, for example. We are currently aware of treebanks for English, Spanish, German, Chinese, Czech, Arabic, and Korean. 6Although most of the literature discusses word translation models between only two languages, it is possible to combine several 2D models into a higher-dimensional model (Mann &amp; Yarowsky, 2001). 7Except where the unstructured components have words that are linked to nothing. We need only redefine the terms in a way that does not rely on an-PMTG. Without loss of generality, we shall assume a -PMTG that ranges over the first compone</context>
</contexts>
<marker>Brown, Pietra, Pietra, Mercer, 1993</marker>
<rawString>P. F. Brown, S. A. Della Pietra, V. J. Della Pietra, &amp; R. L. Mercer (1993) “The Mathematics of Statistical Machine Translation: Parameter Estimation,” Computational Linguistics 19(2):263–312.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Goodman</author>
</authors>
<date>1999</date>
<journal>Semiring Parsing,” Computational Linguistics</journal>
<volume>25</volume>
<issue>4</issue>
<contexts>
<context position="6545" citStr="Goodman, 1999" startWordPosition="1061" endWordPosition="1062">ndeterFigure 2: Above: A tree generated by a 2-MTG in English and (transliterated) Russian. Every internal node is annotated with the linear order of its children, in every component where there are two children. Below: A graphical representation of the same tree. Rectangles are 2D constituents. S NP ministic: they do not indicate the order in which a parser should attempt inferences. A deterministic parsing strategy can always be chosen later, to suit the application. We presume that readers are familiar with declarative descriptions of inference algorithms, as well as with semiring parsing (Goodman, 1999). 3 A Synchronous CKY Parser Figure 3 shows Logic C. Parser C is any parser based on Logic C. As in Melamed (2003)’s Parser A, Parser C’s items consist of a -dimensional label vector and a -dimensional d-span vector .2 The items contain d-spans, rather than ordinary spans, because 2Superscripts and subscripts indicate the range of dimensions of a vector. E.g., is a vector spanning dimensions 1 through . See Melamed (2003) for definitions of cardinality, d-span, and the operators and . Wash moy the dishes Pasudu V N WASH D DISH Wash the dishes PAS Pasudu MIT V moy S NP N Parser C needs to know </context>
<context position="9339" citStr="Goodman (1999)" startWordPosition="1568" endWordPosition="1569">ors and . Parser C is conceptually simpler than the synchronous parsers of Wu (1997), Alshawi et al. (2000), and Melamed (2003), because it uses only one kind of item, and it never composes terminals. The inference rules of Logic C are the multidimensional generalizations of inference rules with the same names in ordinary CKY parsers. For example, given a suitable grammar and the input (imperative) sentence pair Wash the dishes / Pasudu moy, Parser C might make the 9 inferences in Figure 4 to infer the multitree in Figure 2. Note that there is one inference per internal node of the multitree. Goodman (1999) shows how a parsing logic can be combined with various semirings to compute different kinds of information about the input. Depending on the chosen semiring, a parsing logic can compute the single most probable derivation and/or its probability, the most probable derivations and/or their total probability, all possible derivations and/or their total probability, the number of possible derivations, etc. All the parsing semirings catalogued by Goodman apply the same way to synchronous parsing, and to all the other classes of algorithms discussed in this paper. The class of synchronous parsers i</context>
<context position="15121" citStr="Goodman (1999)" startWordPosition="2517" endWordPosition="2518">obable output string still requires summing probabilities over an exponential number of trees. This problem was shown to be NP-hard in the one-dimensional case (Sima’an, 1996). We have no reason to believe that it is any easier when each internal node of the tree. The intended ordering of the terminals in each output dimension can be assembled from these templates by a linear-time linearization post-process that traverses the finished multitree in postorder. To the best of our knowledge, Logic CT is the first published translation logic to be compatible with all of the semirings catalogued by Goodman (1999), among others. It is also the first to simultaneously accommodate multiple input components and multiple output components. When a source document is available in multiple languages, a translator can benefit from the disambiguating information in each. Translator CT can take advantage of such information without making the strong independence assumptions of Och &amp; Ney (2001). When output is desired in multiple languages, Translator CT offers all the putative benefits of the interlingual approach to MT, including greater efficiency and greater consistency across output components. Indeed, the l</context>
<context position="18040" citStr="Goodman, 1999" startWordPosition="2981" endWordPosition="2982">find the single most probable -dimensional multitree that covers the -dimensional input. The multitree inferred by the translator will have the words of both the input and the output components in its leaves. For example, given a suitable grammar and the input Pasudu moy, Translator CT could infer the multitree in Figure 2. The set of inferences would be exactly the same as those listed in Figure 4, except that the items would have no d-spans in the English component. In practice, we usually want the output as a string tuple, rather than as a multitree. Under the various derivation semirings (Goodman, 1999), Translator CT can store the output role templates in I fed the cat ya kota kormil Figure 6: Synchronization. Only one synchronous dependency structure (dashed arrows) is compatible with the monolingual structure (solid arrows) and word alignment (shaded cells). If we have no suitable PMTG, then we can use other criteria to search for trees that have high probability. We shall consider the common synchronization scenario where a lexicalized monolingual grammar is available for at least one component.5 Also, given a tokenized set of-tuples of parallel sentences, it is always possible to estima</context>
</contexts>
<marker>Goodman, 1999</marker>
<rawString>J. Goodman (1999) “Semiring Parsing,” Computational Linguistics 25(4):573–305.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Hwa</author>
<author>P Resnik</author>
<author>A Weinberg</author>
<author>O Kolak</author>
</authors>
<title>Evaluating Translational Correspondence using Annotation Projection,”</title>
<date>2002</date>
<booktitle>Proceedings of the ACL.</booktitle>
<contexts>
<context position="22601" citStr="Hwa et al., 2002" startWordPosition="3708" endWordPosition="3711">ions of the grammar terms in the inference rules of Logic C to synchronize multitexts into multitreebanks. More sophisticated synchronization methods are certainly possible. For example, we could project a part-of-speech tagger (Yarowsky &amp; Ngai, 2001) to improve our estimates in Equation 6. Yet, despite their relative simplicity, the above methods for estimating production rule probabilities use all of the available information in a consistent manner, without double-counting. This kind of synchronizer stands in contrast to more ad-hoc approaches (e.g., Matsumoto, 1993; Meyers, 1996; Wu, 1998; Hwa et al., 2002). Some of these previous works fix the word alignments first, and then infer compatible parse structures. Others do the opposite. Information about syntactic structure can be inferred more accurately given information about translational equivalence, and vice versa. Commitment to either kind of information without consideration of the other increases the potential for compounded errors. 6 Multitree-based Statistical MT Multitree-based statistical machine translation (MTSMT) is an architecture for SMT that revolves around multitrees. Figure 7 shows how to build and use a rudimentary MTSMT syste</context>
</contexts>
<marker>Hwa, Resnik, Weinberg, Kolak, 2002</marker>
<rawString>R. Hwa, P. Resnik, A. Weinberg, &amp; O. Kolak (2002) “Evaluating Translational Correspondence using Annotation Projection,” Proceedings of the ACL.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Eisner</author>
</authors>
<title>Parameter Estimation for Probabilistic FiniteState Transducers,”</title>
<date>2002</date>
<booktitle>Proceedings of the ACL.</booktitle>
<contexts>
<context position="10466" citStr="Eisner, 2002" startWordPosition="1758" endWordPosition="1759">ther classes of algorithms discussed in this paper. The class of synchronous parsers includes some algorithms for word alignment. A translation lexicon (weighted or not) can be viewed as a degenerate MTG (not in GCNF) where every production has a link of terminals on the RHS. Under such an MTG, the logic of word alignment is the one in Melamed (2003)’s Parser A, but without Compose inferences. The only other difference is that, instead of a single item, the Goal of word alignment is any set of items that covers all dimensions of the input. This logic can be used with the expectation semiring (Eisner, 2002) to find the maximum likelihood estimates of the parameters of a word-to-word translation model. An important application of Parser C is parameter estimation for probabilistic MTGs (PMTGs). Eisner (2002) has claimed that parsing under an expectation semiring is equivalent to the Inside-Outside algorithm for PCFGs. If so, then there is a straightforward generalization for PMTGs. Parameter estimation is beyond the scope of this paper, however. The next section assumes that we have an MTG, probabilistic or not, as required by the semiring. 4 Translation A -MTG can guide a synchronous parser to in</context>
</contexts>
<marker>Eisner, 2002</marker>
<rawString>J. Eisner (2002) “Parameter Estimation for Probabilistic FiniteState Transducers,” Proceedings of the ACL.</rawString>
</citation>
<citation valid="true">
<authors>
<author>K Lari</author>
<author>S Young</author>
</authors>
<title>The Estimation of Stochastic Context-Free Grammars using the Inside-Outside Algorithm,”</title>
<date>1990</date>
<journal>Computer Speech and Language Processing</journal>
<volume>4</volume>
<pages>56</pages>
<contexts>
<context position="19663" citStr="Lari &amp; Young, 1990" startWordPosition="3235" endWordPosition="3238"> multitree are isomorphic up to reordering of sibling nodes and deletion. So, given a fixed correspondence between the tree leaves (i.e. words) across components, choosing the optimal structure for one component is tantamount to choosing the optimal synchronous structure for all components.7 Ignoring the nonterminal labels, only one dependency structure is compatible with these constraints – the one indicated by dashed arrows. Bootstrapping a PMTG from a lower-dimensional PMTG and a word-to-word translation model is similar in spirit to the way that regular grammars can help to estimate CFGs (Lari &amp; Young, 1990), and the way that simple translation models can help to bootstrap more sophisticated ones (Brown et al., 1993). 5Such a grammar can be induced from a treebank, for example. We are currently aware of treebanks for English, Spanish, German, Chinese, Czech, Arabic, and Korean. 6Although most of the literature discusses word translation models between only two languages, it is possible to combine several 2D models into a higher-dimensional model (Mann &amp; Yarowsky, 2001). 7Except where the unstructured components have words that are linked to nothing. We need only redefine the terms in a way that d</context>
</contexts>
<marker>Lari, Young, 1990</marker>
<rawString>K. Lari &amp; S. Young (1990) “The Estimation of Stochastic Context-Free Grammars using the Inside-Outside Algorithm,” Computer Speech and Language Processing 4:35– 56.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Y L¨u</author>
<author>S Li</author>
<author>T Zhao</author>
<author>M Yang</author>
</authors>
<title>Learning Chinese Bracketing Knowledge Based on a Bilingual Language Model,”</title>
<date>2002</date>
<booktitle>Proceedings of COLING.</booktitle>
<marker>L¨u, Li, Zhao, Yang, 2002</marker>
<rawString>Y. L¨u, S. Li, T. Zhao, &amp; M. Yang (2002) “Learning Chinese Bracketing Knowledge Based on a Bilingual Language Model,” Proceedings of COLING.</rawString>
</citation>
<citation valid="true">
<authors>
<author>G S Mann</author>
<author>D Yarowsky</author>
</authors>
<title>Multipath Translation Lexicon Induction via Bridge Languages,”</title>
<date>2001</date>
<booktitle>Proceedings of HLT/NAACL.</booktitle>
<contexts>
<context position="20133" citStr="Mann &amp; Yarowsky, 2001" startWordPosition="3310" endWordPosition="3313">mensional PMTG and a word-to-word translation model is similar in spirit to the way that regular grammars can help to estimate CFGs (Lari &amp; Young, 1990), and the way that simple translation models can help to bootstrap more sophisticated ones (Brown et al., 1993). 5Such a grammar can be induced from a treebank, for example. We are currently aware of treebanks for English, Spanish, German, Chinese, Czech, Arabic, and Korean. 6Although most of the literature discusses word translation models between only two languages, it is possible to combine several 2D models into a higher-dimensional model (Mann &amp; Yarowsky, 2001). 7Except where the unstructured components have words that are linked to nothing. We need only redefine the terms in a way that does not rely on an-PMTG. Without loss of generality, we shall assume a -PMTG that ranges over the first components, where . We shall then refer to the structured components and the unstructured components. We begin with . For the structured components , we retain the grammarbased definition: by applying the chain rule9 and continues by making independence assumptions. The first assumption is that the structured components of the production’s RHS are conditionally in</context>
</contexts>
<marker>Mann, Yarowsky, 2001</marker>
<rawString>G. S. Mann &amp; D. Yarowsky (2001) “Multipath Translation Lexicon Induction via Bridge Languages,” Proceedings of HLT/NAACL.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Y Matsumoto</author>
</authors>
<title>Structural Matching of Parallel Texts,”</title>
<date>1993</date>
<booktitle>Proceedings of the ACL.</booktitle>
<contexts>
<context position="22558" citStr="Matsumoto, 1993" startWordPosition="3702" endWordPosition="3703">and 0 otherwise. We can use these definitions of the grammar terms in the inference rules of Logic C to synchronize multitexts into multitreebanks. More sophisticated synchronization methods are certainly possible. For example, we could project a part-of-speech tagger (Yarowsky &amp; Ngai, 2001) to improve our estimates in Equation 6. Yet, despite their relative simplicity, the above methods for estimating production rule probabilities use all of the available information in a consistent manner, without double-counting. This kind of synchronizer stands in contrast to more ad-hoc approaches (e.g., Matsumoto, 1993; Meyers, 1996; Wu, 1998; Hwa et al., 2002). Some of these previous works fix the word alignments first, and then infer compatible parse structures. Others do the opposite. Information about syntactic structure can be inferred more accurately given information about translational equivalence, and vice versa. Commitment to either kind of information without consideration of the other increases the potential for compounded errors. 6 Multitree-based Statistical MT Multitree-based statistical machine translation (MTSMT) is an architecture for SMT that revolves around multitrees. Figure 7 shows how</context>
</contexts>
<marker>Matsumoto, 1993</marker>
<rawString>Y. Matsumoto (1993) “Structural Matching of Parallel Texts,” Proceedings of the ACL.</rawString>
</citation>
<citation valid="true">
<authors>
<author>I D Melamed</author>
</authors>
<title>Multitext Grammars and Synchronous Parsers,”</title>
<date>2003</date>
<booktitle>Proceedings of HLT/NAACL.</booktitle>
<contexts>
<context position="2832" citStr="Melamed, 2003" startWordPosition="447" endWordPosition="448">ail: ordinary parsing is a special case of synchronous parsing, which is a special case of translation. This paper offers an informal guided tour of the generalized parsing algorithms in Figure 1. It culminates with a recipe for using these algorithms to train and apply a syntax-aware statistical machine translation (SMT) system. 2 Multitext Grammars and Multitrees The algorithms in this paper can be adapted for any synchronous grammar formalism. The vehicle for the present guided tour shall be multitext grammar (MTG), which is a generalization of context-free grammar to the synchronous case (Melamed, 2003). We shall limit our attention to MTGs in Generalized Chomsky Normal Form (GCNF) (Melamed et al., 2004). This normal form allows simpler algorithm descriptions than the normal forms used by Wu (1997) and Melamed (2003). In GCNF, every production is either a terminal production or a nonterminal production. A nonterminal production might look like this: ordinary parsing 1 2 3 1 ... I = dimensionality of input 3 2 D = dimensionality of grammar ... generalized parsing (any D; any I) synchronization (I &gt;= D) synchronous translation (D &gt;= I) word alignment ordinary parsing (D=I=1) parsing (D=I) D(2)</context>
<context position="6659" citStr="Melamed (2003)" startWordPosition="1084" endWordPosition="1085"> annotated with the linear order of its children, in every component where there are two children. Below: A graphical representation of the same tree. Rectangles are 2D constituents. S NP ministic: they do not indicate the order in which a parser should attempt inferences. A deterministic parsing strategy can always be chosen later, to suit the application. We presume that readers are familiar with declarative descriptions of inference algorithms, as well as with semiring parsing (Goodman, 1999). 3 A Synchronous CKY Parser Figure 3 shows Logic C. Parser C is any parser based on Logic C. As in Melamed (2003)’s Parser A, Parser C’s items consist of a -dimensional label vector and a -dimensional d-span vector .2 The items contain d-spans, rather than ordinary spans, because 2Superscripts and subscripts indicate the range of dimensions of a vector. E.g., is a vector spanning dimensions 1 through . See Melamed (2003) for definitions of cardinality, d-span, and the operators and . Wash moy the dishes Pasudu V N WASH D DISH Wash the dishes PAS Pasudu MIT V moy S NP N Parser C needs to know all the boundaries of each item, not just the outermost boundaries. Some (but not all) dimensions of an item can b</context>
<context position="8852" citStr="Melamed (2003)" startWordPosition="1482" endWordPosition="1483"> C is the same as in Melamed’s Parser A, using slightly different notation: In Logic C, the function represents the value that the grammar assigns to the nonterminal production . Parser C can compose two items if their labels appear on the RHS of a production rule in the grammar, and if the contiguity and relative order of their intervals is consistent with the role templates of that production rule. Figure 3: Logic C (“C” for CKY) These constraints are enforced by the d-span operators and . Parser C is conceptually simpler than the synchronous parsers of Wu (1997), Alshawi et al. (2000), and Melamed (2003), because it uses only one kind of item, and it never composes terminals. The inference rules of Logic C are the multidimensional generalizations of inference rules with the same names in ordinary CKY parsers. For example, given a suitable grammar and the input (imperative) sentence pair Wash the dishes / Pasudu moy, Parser C might make the 9 inferences in Figure 4 to infer the multitree in Figure 2. Note that there is one inference per internal node of the multitree. Goodman (1999) shows how a parsing logic can be combined with various semirings to compute different kinds of information about</context>
<context position="10205" citStr="Melamed (2003)" startWordPosition="1713" endWordPosition="1714">ost probable derivations and/or their total probability, all possible derivations and/or their total probability, the number of possible derivations, etc. All the parsing semirings catalogued by Goodman apply the same way to synchronous parsing, and to all the other classes of algorithms discussed in this paper. The class of synchronous parsers includes some algorithms for word alignment. A translation lexicon (weighted or not) can be viewed as a degenerate MTG (not in GCNF) where every production has a link of terminals on the RHS. Under such an MTG, the logic of word alignment is the one in Melamed (2003)’s Parser A, but without Compose inferences. The only other difference is that, instead of a single item, the Goal of word alignment is any set of items that covers all dimensions of the input. This logic can be used with the expectation semiring (Eisner, 2002) to find the maximum likelihood estimates of the parameters of a word-to-word translation model. An important application of Parser C is parameter estimation for probabilistic MTGs (PMTGs). Eisner (2002) has claimed that parsing under an expectation semiring is equivalent to the Inside-Outside algorithm for PCFGs. If so, then there is a </context>
<context position="24566" citStr="Melamed (2003)" startWordPosition="4020" endWordPosition="4021">igure 7 is only an architecture. Computational complexity and generalization error stand in the way of its practical implementation. Nevertheless, it is satisfying to note that all the non-trivial algorithms in Figure 7 are special cases of Translator CT. It is therefore possible to implement an MTSMT system using just one inference algorithm, parameterized by a grammar, a semiring, and a search strategy. An advantage of building an MT system in this manner is that improvements invented for ordinary parsing algorithms can often be applied to all the main components of the system. For example, Melamed (2003) showed how to reduce the computational complexity of a synchronous parser by , just by changing the logic. The same optimization can be applied to the inference algorithms in this paper. With proper software design, such optimizations need never be implemented more than once. For simplicity, the algorithms in this paper are based on CKY logic. However, the architecture in Figure 7 can also be implemented using generalizations of more sophisticated parsing logics, such as those inherent in Earley or Head-Driven parsers. 7 Conclusion This paper has presented generalizations of ordinary parsing </context>
</contexts>
<marker>Melamed, 2003</marker>
<rawString>I. D. Melamed (2003) “Multitext Grammars and Synchronous Parsers,” Proceedings of HLT/NAACL.</rawString>
</citation>
<citation valid="true">
<authors>
<author>I D Melamed</author>
<author>G Satta</author>
<author>B Wellington</author>
</authors>
<date>2004</date>
<booktitle>Generalized Multitext Grammars,” Proceedings of the ACL</booktitle>
<contexts>
<context position="2935" citStr="Melamed et al., 2004" startWordPosition="462" endWordPosition="465">lation. This paper offers an informal guided tour of the generalized parsing algorithms in Figure 1. It culminates with a recipe for using these algorithms to train and apply a syntax-aware statistical machine translation (SMT) system. 2 Multitext Grammars and Multitrees The algorithms in this paper can be adapted for any synchronous grammar formalism. The vehicle for the present guided tour shall be multitext grammar (MTG), which is a generalization of context-free grammar to the synchronous case (Melamed, 2003). We shall limit our attention to MTGs in Generalized Chomsky Normal Form (GCNF) (Melamed et al., 2004). This normal form allows simpler algorithm descriptions than the normal forms used by Wu (1997) and Melamed (2003). In GCNF, every production is either a terminal production or a nonterminal production. A nonterminal production might look like this: ordinary parsing 1 2 3 1 ... I = dimensionality of input 3 2 D = dimensionality of grammar ... generalized parsing (any D; any I) synchronization (I &gt;= D) synchronous translation (D &gt;= I) word alignment ordinary parsing (D=I=1) parsing (D=I) D(2) A B E (1) There are nonterminals on the left-hand side (LHS) and in parentheses on the right-hand side</context>
</contexts>
<marker>Melamed, Satta, Wellington, 2004</marker>
<rawString>I. D. Melamed, G. Satta, &amp; B. Wellington (2004) “Generalized Multitext Grammars,” Proceedings of the ACL (this volume).</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Meyers</author>
<author>R Yangarber</author>
<author>R Grishman</author>
</authors>
<title>Alignment of Shared Forests for Bilingual Corpora,”</title>
<date>1996</date>
<booktitle>Proceedings of COLING.</booktitle>
<marker>Meyers, Yangarber, Grishman, 1996</marker>
<rawString>A. Meyers, R. Yangarber, &amp; R. Grishman (1996) “Alignment of Shared Forests for Bilingual Corpora,” Proceedings of COLING.</rawString>
</citation>
<citation valid="true">
<authors>
<author>F Och</author>
<author>H Ney</author>
</authors>
<date>2001</date>
<booktitle>Statistical Multi-Source Translation,” Proceedings ofMT Summit VIII.</booktitle>
<contexts>
<context position="15498" citStr="Och &amp; Ney (2001)" startWordPosition="2573" endWordPosition="2576">ear-time linearization post-process that traverses the finished multitree in postorder. To the best of our knowledge, Logic CT is the first published translation logic to be compatible with all of the semirings catalogued by Goodman (1999), among others. It is also the first to simultaneously accommodate multiple input components and multiple output components. When a source document is available in multiple languages, a translator can benefit from the disambiguating information in each. Translator CT can take advantage of such information without making the strong independence assumptions of Och &amp; Ney (2001). When output is desired in multiple languages, Translator CT offers all the putative benefits of the interlingual approach to MT, including greater efficiency and greater consistency across output components. Indeed, the language of multitrees can be viewed as an interlingua. 5 Synchronization We have explored inference of-dimensional multitrees under a -dimensional grammar, where . Now we generalize along the other axis of Figure 1(a). Multitext synchronization is most often used to infer-dimensional multitrees without the benefit of an-dimensional grammar. One application is inducing a pars</context>
</contexts>
<marker>Och, Ney, 2001</marker>
<rawString>F. Och &amp; H. Ney (2001) “Statistical Multi-Source Translation,” Proceedings ofMT Summit VIII.</rawString>
</citation>
<citation valid="true">
<authors>
<author>F Och</author>
<author>H Ney</author>
</authors>
<date>2003</date>
<journal>A Systematic Comparison of Various Statistical Alignment Models,” Computational Linguistics</journal>
<pages>29--1</pages>
<contexts>
<context position="18699" citStr="Och &amp; Ney, 2003" startWordPosition="3083" endWordPosition="3086">emplates in I fed the cat ya kota kormil Figure 6: Synchronization. Only one synchronous dependency structure (dashed arrows) is compatible with the monolingual structure (solid arrows) and word alignment (shaded cells). If we have no suitable PMTG, then we can use other criteria to search for trees that have high probability. We shall consider the common synchronization scenario where a lexicalized monolingual grammar is available for at least one component.5 Also, given a tokenized set of-tuples of parallel sentences, it is always possible to estimate a word-to-word translation model (e.g., Och &amp; Ney, 2003).6 A word-to-word translation model and a lexicalized monolingual grammar are sufficient to drive a synchronizer. For example, in Figure 6 a monolingual grammar has allowed only one dependency structure on the English side, and a word-to-word translation model has allowed only one word alignment. The syntactic structures of all dimensions of a multitree are isomorphic up to reordering of sibling nodes and deletion. So, given a fixed correspondence between the tree leaves (i.e. words) across components, choosing the optimal structure for one component is tantamount to choosing the optimal synch</context>
</contexts>
<marker>Och, Ney, 2003</marker>
<rawString>F. Och &amp; H. Ney (2003) “A Systematic Comparison of Various Statistical Alignment Models,” Computational Linguistics 29(1):19-51.</rawString>
</citation>
<citation valid="true">
<authors>
<author>K Sima’an</author>
</authors>
<title>Computational Complexity of Probabilistic Disambiguation by means of Tree-Grammars,”</title>
<date>1996</date>
<booktitle>Proceedings of COLING.</booktitle>
<marker>Sima’an, 1996</marker>
<rawString>K. Sima’an (1996) “Computational Complexity of Probabilistic Disambiguation by means of Tree-Grammars,” Proceedings of COLING.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D Wu</author>
</authors>
<title>A polynomial-time algorithm for statistical machine translation,”</title>
<date>1996</date>
<booktitle>Proceedings of the ACL.</booktitle>
<marker>Wu, 1996</marker>
<rawString>D. Wu (1996) “A polynomial-time algorithm for statistical machine translation,” Proceedings of the ACL.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D Wu</author>
</authors>
<title>Stochastic inversion transduction grammars and bilingual parsing of parallel corpora,”</title>
<date>1997</date>
<journal>Computational Linguistics</journal>
<pages>23--3</pages>
<contexts>
<context position="3031" citStr="Wu (1997)" startWordPosition="479" endWordPosition="480">inates with a recipe for using these algorithms to train and apply a syntax-aware statistical machine translation (SMT) system. 2 Multitext Grammars and Multitrees The algorithms in this paper can be adapted for any synchronous grammar formalism. The vehicle for the present guided tour shall be multitext grammar (MTG), which is a generalization of context-free grammar to the synchronous case (Melamed, 2003). We shall limit our attention to MTGs in Generalized Chomsky Normal Form (GCNF) (Melamed et al., 2004). This normal form allows simpler algorithm descriptions than the normal forms used by Wu (1997) and Melamed (2003). In GCNF, every production is either a terminal production or a nonterminal production. A nonterminal production might look like this: ordinary parsing 1 2 3 1 ... I = dimensionality of input 3 2 D = dimensionality of grammar ... generalized parsing (any D; any I) synchronization (I &gt;= D) synchronous translation (D &gt;= I) word alignment ordinary parsing (D=I=1) parsing (D=I) D(2) A B E (1) There are nonterminals on the left-hand side (LHS) and in parentheses on the right-hand side (RHS). Each row of the production describes rewriting in a different component text of a multit</context>
<context position="8809" citStr="Wu (1997)" startWordPosition="1475" endWordPosition="1476">ys one. The Compose inference in Logic C is the same as in Melamed’s Parser A, using slightly different notation: In Logic C, the function represents the value that the grammar assigns to the nonterminal production . Parser C can compose two items if their labels appear on the RHS of a production rule in the grammar, and if the contiguity and relative order of their intervals is consistent with the role templates of that production rule. Figure 3: Logic C (“C” for CKY) These constraints are enforced by the d-span operators and . Parser C is conceptually simpler than the synchronous parsers of Wu (1997), Alshawi et al. (2000), and Melamed (2003), because it uses only one kind of item, and it never composes terminals. The inference rules of Logic C are the multidimensional generalizations of inference rules with the same names in ordinary CKY parsers. For example, given a suitable grammar and the input (imperative) sentence pair Wash the dishes / Pasudu moy, Parser C might make the 9 inferences in Figure 4 to infer the multitree in Figure 2. Note that there is one inference per internal node of the multitree. Goodman (1999) shows how a parsing logic can be combined with various semirings to c</context>
</contexts>
<marker>Wu, 1997</marker>
<rawString>D. Wu (1997) “Stochastic inversion transduction grammars and bilingual parsing of parallel corpora,” Computational Linguistics 23(3):377-404.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D Wu</author>
<author>H Wong</author>
</authors>
<title>Machine translation with a stochastic grammatical channel,”</title>
<date>1998</date>
<booktitle>Proceedings of the ACL. K. Yamada &amp; K. Knight (2002) “A Decoder for Syntax-based Statistical MT,” Proceedings of the ACL.</booktitle>
<marker>Wu, Wong, 1998</marker>
<rawString>D. Wu &amp; H. Wong (1998) “Machine translation with a stochastic grammatical channel,” Proceedings of the ACL. K. Yamada &amp; K. Knight (2002) “A Decoder for Syntax-based Statistical MT,” Proceedings of the ACL.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D Yarowsky</author>
<author>G Ngai</author>
</authors>
<date>2001</date>
<booktitle>Inducing Multilingual POS Taggers and NP Bracketers via Robust Projection Across Aligned Corpora,” Proceedings of the NAACL.</booktitle>
<contexts>
<context position="22235" citStr="Yarowsky &amp; Ngai, 2001" startWordPosition="3651" endWordPosition="3654">on model, which would typically be estimated under exactly such an independence assumption. Finally, we assume that the output role templates are independent of each other and uniformly distributed, up to some maximum cardinality . Let be the number of unique role templates of cardinality or less. Then Under Assumptions 5–8, if and 0 otherwise. We can use these definitions of the grammar terms in the inference rules of Logic C to synchronize multitexts into multitreebanks. More sophisticated synchronization methods are certainly possible. For example, we could project a part-of-speech tagger (Yarowsky &amp; Ngai, 2001) to improve our estimates in Equation 6. Yet, despite their relative simplicity, the above methods for estimating production rule probabilities use all of the available information in a consistent manner, without double-counting. This kind of synchronizer stands in contrast to more ad-hoc approaches (e.g., Matsumoto, 1993; Meyers, 1996; Wu, 1998; Hwa et al., 2002). Some of these previous works fix the word alignments first, and then infer compatible parse structures. Others do the opposite. Information about syntactic structure can be inferred more accurately given information about translatio</context>
</contexts>
<marker>Yarowsky, Ngai, 2001</marker>
<rawString>D. Yarowsky &amp; G. Ngai (2001) “Inducing Multilingual POS Taggers and NP Bracketers via Robust Projection Across Aligned Corpora,” Proceedings of the NAACL.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>