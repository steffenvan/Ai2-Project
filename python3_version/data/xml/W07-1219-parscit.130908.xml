<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.005593">
<title confidence="0.966265">
Local ambiguity packing and discontinuity in German
</title>
<author confidence="0.921927">
Berthold Crysmann
</author>
<affiliation confidence="0.875322">
DFKI GmbH &amp; Saarland University
</affiliation>
<address confidence="0.9029">
Stuhlsatzenhausweg 3
D-66123 Saarbr¨ucken
</address>
<email confidence="0.996367">
crysmann@dfki.de
</email>
<sectionHeader confidence="0.995564" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999882555555556">
We report on recent advances in HPSG pars-
ing of German with local ambiguity pack-
ing (Oepen and Carroll, 2000), achieving a
speed-up factor of 2 on a balanced test-suite.
In contrast to earlier studies carried out for
English using the same packing algorithm,
we show that restricting semantic features
only is insufficient for achieving acceptable
runtime performance with a German HPSG
grammar. In a series of experiments relating
to the three different types of discontinuities
in German (head movement, extraction, ex-
traposition), we examine the effects of re-
strictor choice, ultimately showing that ex-
traction and head movement require partial
restriction of the respective features encod-
ing the dependency, whereas full restriction
gives best results for extraposition.
</bodyText>
<sectionHeader confidence="0.999134" genericHeader="introduction">
1 Introduction
</sectionHeader>
<bodyText confidence="0.999868770833333">
It is a well-known fact that chart parsing with-
out techniques for local ambiguity packing (Earley,
1970) faces a combinatorial explosion of the search
space, owing to the (structural) ambiguity immi-
nent to natural language. Thus, identical edges with
different internal derivation history can be packed
into a single representative for further processing,
thereby effectively solving the complexity issue. In
context-free grammars augmented with a unifica-
tion formalism, packing based on the CF symbol
equality has been complemented by subsumption- or
disjunction-based packing of the associated feature
structures (Moore and Alshawi, 1992; Maxwell and
Kaplan, 1995). For parsing with constraint-based
grammars, such as HPSG, which do not possess an
explicit context-free backbone, (Oepen and Carroll,
2000) have proposed an efficient packing algorithm
based on feature structure subsumption only.
In contrast to the symbols in context-free gram-
mars, feature structures in unification-based gram-
mars often include information encoding (part of)
the derivation history, most notably semantics. In or-
der to achieve successful packing rates, feature re-
striction (Shieber, 1985) is used to remove this in-
formation during creation of the packed parse forest.
During the unpacking phase, which operates only
on successful parse trees, these features are unified
back in again.
For their experiments with efficient subsumption-
based packing, (Oepen and Carroll, 2000) experi-
mented with different settings of the packing restric-
tor for the English Resource Grammar ERG (Copes-
take and Flickinger, 2000): they found that good
packing rates, and overall good performance dur-
ing forest creation and unpacking were achieved, for
the ERG, with partial restriction of the semantics,
e.g. keeping index features unrestricted, since they
have an impact on external combinatorial potential,
but restricting most of the internal MRS represen-
tation, including the list of elementary predications
and scope constraints. Restriction of syntactically
potent features, has thus been found both unneces-
sary and less efficient.
First experiments in ambiguity packing with a
German HPSG grammar (GG; http://gg.dfki.de) re-
vealed that restriction of semantics only does not
give rise to any acceptible results in terms of runtime
performance. It became clear quite quickly that the
</bodyText>
<page confidence="0.97926">
144
</page>
<note confidence="0.9311225">
Proceedings of the ACL 2007 Workshop on Deep Linguistic Processing, pages 144–151,
Prague, Czech Republic, June, 2007. @2007 Association for Computational Linguistics
</note>
<bodyText confidence="0.999884689655172">
bulk of failing subsumptions impeding creation of a
sufficiently compact forest were related to two syn-
tactic features, SLASH and DSL. In German, these
features contain references to non-empty valence
lists, which eventually wind up encoding derivation
history. Using a more aggressive restrictor to elim-
inate these features during forest creation did not
show the desired performance either: owing to mas-
sive overgeneration, the resulting forest was either
not compact enough, or most of the efficiency gains
were wasted on unpacking failures in the second
phase.
In this paper we report on recent advances with
local ambiguity packing for German, showing how
partial restriction can achieve good packing rates at
negligible unpacking cost, yielding an overall speed-
up by a factor of 2, as compared to parsing without
ambiguity packing. Running a series of experiments
with different restrictor setting for three different
features involved with non-local dependencies we
examine in detail how the choice of restrictor affects
the observable performance. The paper is organised
as follows: section 2 will give an overview of the rel-
evant syntactic constructions of German, and their
implementation in GG. Section 3 gives a description
of the experimental setup (3.1), followed by a dis-
cussion of the main results (3.2), detailing how dif-
ferent settings for feature restriction affect parsing
performance.
</bodyText>
<sectionHeader confidence="0.94711" genericHeader="method">
2 Discontinuity in German
</sectionHeader>
<bodyText confidence="0.999794764705882">
Head movement German, in contrast to English is
a verb-final language with a verb-second effect, that
is, non-finite verbs are standardly placed sentence-
finally. In clauses other than complementizer-
introduced subclauses and relative clauses, the finite
verb surfaces in a clause-initial position (either first
or second). Any major constituent may occupy the
topic position preceding the finite verb, including
subject, complements or modifiers.
Owing to the V2 effect, the parts of a verb cluster
are discontinuous. Since both the finite verb and the
non-finite verb cluster impose constraints on con-
stituents in the Mittelfeld, standard approaches to
German syntax in HPSG assume, since (Kiss and
Wesche, 1991), that the initial verb is related to
the final verb cluster by means of head movement:
clause-finally, a trace is inserted that combines the
</bodyText>
<figure confidence="0.969619">
S
NP-A-V-MOD S/NP-A-V-MOD
helfen
</figure>
<figureCaption confidence="0.999876">
Figure 1: DSL: Monday let he him the man help
</figureCaption>
<bodyText confidence="0.999613710526316">
argument structure of the final cluster with the sub-
categorisation requirements percolated down from
the finite verb using a special feature DSL (=“dou-
ble SLASH”). Arguments in the Mittelfeld are satu-
rated as complements of the clause-final trace. The
grammar used here assumes head movement for dis-
continuous predicates (Crysmann, 2003), following
in this respect the earlier implementation by (M¨uller
and Kasper, 2000). In order to relate the initial verb
to the verb cluster and its arguments in the Mit-
telfeld, like the subject and direct object in figure 2,
the DSL (or V1) feature must percolate subcategori-
sation requirements for subject and object, as well as
for the verb cluster. At the gap site, the valence in-
formation percolated via DSL is inserted into the ac-
tual valence lists of the verb trace. Since the require-
ments are matched against actual arguments found
in the Mittelfeld, the valence lists contained in DSL
get instantiated to whatever argument it satisfies,
thereby creating a partial representation of deriva-
tion history. While theoretically, this is just the right
behaviour, it has clear repercussions for parsing with
ambiguity packing.
Partial VP fronting Another aspect, in which the
syntax of German differs from that of English is
in the area of extraction: while in English only
constituents with a saturated COMPS list can un-
dergo wh-movement, this is not the case in Ger-
man: as shown in figure 2, the verb schenken
‘give/donate’ has been fronted, leaving its two com-
plements behind.
In HPSG, partial VP fronting is analysed by
a combination of two mechanisms (M¨uller, 1999;
Nerbonne, 1994): first, standard argument com-
position in the verb cluster, following (Hinrichs
and Nakazawa, 1990), combined with a standard
SLASH-based treatment of long-distance extraction.
Again, since argument composition is performed
</bodyText>
<figure confidence="0.993006578947369">
N
V
EPS/NP-A-V-MOD
lasse
EPS/NP-A-V-MOD
NP-NOM-SG
Montag
ich
EPS/NP-A-V-MOD
NP-ACC-SG
ihn
NP-DAT
N
D
EPS/NP-A-V-MOD
EPS
V
Mann
dem
</figure>
<page confidence="0.583292">
145
</page>
<figure confidence="0.843527">
wollen
</figure>
<figureCaption confidence="0.998883">
Figure 2: SLASH: give has he him the book wanted
</figureCaption>
<bodyText confidence="0.999792">
by strcuture-sharing, i.e. reentrancy between the va-
lence list of the governing predicate and the unsatu-
rated valence list of the governed predicate, extrac-
tion of the governed predicate by means of SLASH
percolation carries this reentrancy over into SLASH.
From a general linguistic point of view, this is highly
desirable, because valence requirements of the ex-
tracted verb must be matched against the arguments
that satisfy them in the Mittelfeld. The only draw-
back is, that we are confronted, again, with a syntac-
tic feature containing, among other things, records
of derivation history.
</bodyText>
<sectionHeader confidence="0.996887" genericHeader="evaluation">
3 Evaluation
</sectionHeader>
<subsectionHeader confidence="0.999827">
3.1 Test setup
</subsectionHeader>
<bodyText confidence="0.999984088235294">
In order to systematically investigate the effect of re-
striction of syntactically potent features on the pars-
ing efficiency with local ambiguity packing, we cre-
ated a test field consisting of 8 different parameter
settings (out of 27 logically possible settings): 1 run
without packing, 1 run with optimal settings for the
three features under consideration, and 2 runs with
suboptimal settings for each of the three features.
All test runs were performed on a balanced test
suite extracted from the Verbmobil corpus, using
100 items per input length, from sentence length 1
to 22, thus totalling 2200 test items. Although the
Verbmobil corpus does contain test sentences of up
to 70 words long, their number drops quite quickly
from sentence length 23 on.
The parser used in the experiments is the cur-
rent SVN version of Pet (Callmeier, 2000), run-
ning the March 24 version of GG (http://gg.dfki.de;
(M¨uller and Kasper, 2000; Crysmann, 2003; Crys-
mann, 2005)). Tests were run on an Intel Core Duo
machine using a single T2600 CPU at 2.16GHz with
2 GB main memory.
To ensure that we can study parser performance
on input of increasing length, we used a rather gener-
ous upper limit of 150,000 passive edges. Taking as
a guideline the average space consumption per edge
of the non-packing parser, we calculated that pars-
ing could still be done comfortably in main memory,
i.e., without using swap space.
All measurements were performed using the [incr
tsdb()] profiling platform (Oepen and Flickinger,
1998). Parsing times reported are total CPU times
(in seconds), including exhaustive unpacking of the
parse forest, whenever applicable.
</bodyText>
<subsectionHeader confidence="0.853376">
3.2 Results
</subsectionHeader>
<bodyText confidence="0.999986285714286">
The main result of our study is that local ambiguity
packing in constraint-based parsing of German can
lead to performance improvements, once feature re-
striction is extended from purely semantic features
to syntactically potent features used to model dis-
continuity, such as SLASH, DSL, and ANC (see be-
low). We also found that positive performance ef-
fects could only be achieved, if SLASH and DSL
features were partially restricted in such a way as to
only eliminate all records of derivation history (in
terms of instatiated subcategorisation lists), while
retaining most of the other constraints represented
in these features.
Compared to a non-packing baseline parser with
feature structure unfilling, we observed an overall
speed-up by a factor of 2 with local ambiguity pack-
ing on a balanced test suite. As shown by figure
3.2, local ambiguity packing with optimal restrictor
settings is effective in taming the combinatorial ex-
plosition of the search observed by the non-packing
parser.
Analogous to the reduction in search space, per-
formance savings grow continuously with increas-
ing input length: from sentence length 14 onwards
(factor 0.84) relative processing time decreases con-
tinually up to a factor of 0.27 at sentence length
22. With an average CPU time of 0.69s at sentence
length 22, performance is by far better than real-
time behaviour. Note further, that the non-packing
parser benefits here from a ceiling effect: with 25 out
of 2200 test items (1%), the available resources of
150,000 passive chart edges were exhausted before
the search space was fully explored. With ambiguity
packing under an appropriate restrictor, by contrast,
the search space was fully explored.
</bodyText>
<figure confidence="0.943291">
S
V
S/V
V
V
EPS/V
hat
NP-NOM-SG
schenken
EPS/V
er NP-DAT EPS/V
ihm
EPS/V
V/V
das Buch V/V
V
D
N
NP-ACC-SG
146
String Length String Length
</figure>
<figureCaption confidence="0.999997">
Figure 3: Comparison of chart size relative to input length
Figure 4: Comparison of processing time relative to input length
</figureCaption>
<figure confidence="0.997454294117647">
• •
100000
80000
•
•
•
• — passive edges
•
• •
•
No packing
• •
•
• •
•
•
••
•
••
•
•
•
••
• • • •
• •
• • • •• • • •
• • •
• • • •
• • •
• • • • • •• • • • • •
• • •
• • • • •
• • •• • • • • • • • • • •
• •
• • • •• • • • •
• •• • • • •
• • ••• • • • • ••
1 3 5 7 9 11 13 15 17 19 21
1 3 5 7 9 11 13 15 17 19 21
•
•
Packing w/ partial SLASH/DSL; no ANC
•
60000
40000
20000
0
140000
• 120000
• — passive edges
•
•
••• • • •• • ••• • • • •
•
•
0
�
0
� �
� �
� � � �
� � � � � �
� � � � � � �
II
1 3 5 7 9 11 13 15 17 19 21
0
� � �
0
0
0
00
� �
� � � �
�0
0
�
0
�o°
� � �
0
0
No packing (unfilling)
o — Total CPU time (s)
0
0
String Length
Packing w/ partial SLASH/DSL; no ANC
1 3 5 7 9 11 13 15 17 19 21
String Length
0
22
o — Total CPU time (s)
0
20
18
16
14
12
0
10
8
0
�
� � ��� � ��� � � � �� � �� �� � �
�� �� �� � � � � � �
� � � � � � � � ��
0
0
�
�
6
4
2
0
0
�
140000
120000
100000
80000
60000
40000
20000
0
22
20
18
16
14
12
10
8
6
4
2
0
</figure>
<bodyText confidence="0.9645511875">
Restricting DSL The first syntactically potent
feature investigated in these experiments is the fea-
ture DSL (or V1), which serves to relate, by means
of simulated head movement, the finite verb in
clause-second position to the clause-final verb clus-
ter. Essentially, this feature is used to pass down
the valence information from the initial verb to the
clause-final verb trace, where this valence informa-
tion is combined with that of the cluster. In the
grammar under consideration, verb movement is re-
stricted to discontinuous verb clusters (Crysmann,
2003), i.e., to situations where there is either an overt
verb cluster, or a stranded verb particle in the right
sentence bracket.
Since actual or putative arguments of the verb
trace must be checked against the actual valence in-
formation of the V2 verb, derivation history must be
carried along as part of the DSL feature.
Obviously, any feature that (partially) encodes
derivation history is a potential threat to efficient
ambiguity packing. We therefore experimented with
three different settings regarding restriction of this
feature: full restriction, no restriction, and a par-
tial restriction, where only constraints pertaining to
HEAD information of the final cluster were retained,
such as category, or form (most crucial for stranded
particles).
Results are summarised in table 1. Besides the
feature studied here, the restrictor includes the se-
1Here, and in the following two tables =_ stands for packing
under equivalence, ::1 for proactive packing, C for retroactive
packing, and L for freezing.
</bodyText>
<table confidence="0.998539">
Edges Time (s) Unpack (s) Subsumption C L Factor (time) Subs. cost Pack rate
Unfill 6424 0.56 0 0 0 0 0 0 1 N/A 0
Partial DSL 1494 0.28 0.01 36404.15 307.28 193.33 36.67 335.84 0.5 67.76 0.36
Full DSL 1832 1.96 0.01 363840.47 186.19 111.31 42.96 251.32 3.5 1068.68 0.19
No DSL 1917 0.61 0.01 106392.57 568.34 484.68 80.8 926.79 1.09 93.83 0.59
</table>
<tableCaption confidence="0.999926">
Table 1: Performance of packed parsing with different restriction of DSL1
</tableCaption>
<bodyText confidence="0.998546378378378">
mantic features like RELS and HCONS, as in
(Oepen and Carroll, 2000), as well as optimal set-
tings for SLASH and ANC.
Leaving DSL unrestricted features the lowest
number of packings, amongst the three settings,
both in absolute terms, and in relative packings per
edge (0.19). As a consequence, average chart size is
bigger than with either partially or fully restricted
DSL. Another negative behaviour of packed pars-
ing with an unrestricted DSL is the incommensu-
rate number of subsumption tests carried out: at a
ratio of 1068.68 subsumption tests per packing, this
accounts chiefly for the inefficiency, in particular,
when compared to the much more moderate rates
of 67.76 and 93.83 achieved with partially restricted
and fully restricted DSL. Thus, even though over-
all chart size is reduced when compared to parsing
without ambiguity packing, these savings in space
are not sufficient enough to pay off the overhead in-
curred by testing for subsumption. As a net effect,
overall parsing time is 3.5 times longer compared to
the non-packing baseline.2
Fully restricting DSL by contrast yields a very
good packing rate (0.59) at moderate costs in terms
of subsumption test per packing (93.83). However,
with the grammar not being restrictive enough dur-
ing forest creation, overall chart size is bigger (1832
passive edges) than with partially restricted DSL
(1494). Best results are obtained with partially re-
stricted DSL, where derivation history in terms of
actual or putative arguments of the verb trace is re-
moved, but reference to HEAD information of the
final cluster is maintained, thereby ensuring that the
initial verb only combines with appropriate verb
clusters. This not only leads to the most compact
chart, but also features the lowest number of sub-
sumption tests, both absolute and relative. In sum,
</bodyText>
<tableCaption confidence="0.3395776">
2Edges in packed parsing are actually more costly than in
parsing without ambiguity packing. Since efficient subsumption
checking and feature structure unfilling are mutually exclusive,
edges in general consume much more space when parsing with
ambiguity packing, increasing the cost of copying in unification.
</tableCaption>
<bodyText confidence="0.99898512195122">
partial restriction of DSL was the only setting that
actually beat the baseline defined by parsing with-
out ambiguity packing.
Restricting SLASH The second experiment we
carried out relates to the feature SLASH, used for
long-distance dependencies. Owing to the V2 ef-
fect in German, constituents in the clause-initial pre-
verbal position are typically placed there by means
of extraction, including unmarked subjects. This dif-
fers quite clearly from English, where standard SVO
order does not involve any movement at all. Another
striking difference between the two languages is that
German, but not English permits fronting of par-
tial VPs: in complex predicates, as witnessed with
modals and control verbs, as well as in auxiliary-
participle combinations, the downstairs predicate
can be fronted, leaving part (or even all) of its com-
plements to be realised in the Mittelfeld. Since Ger-
man is a non-configurational language, pretty much
any combination of fronted vs. stranded comple-
ments can be found, in any order. In GG, partial
VP fronting is effected by special extraction rules,
which removes the valency of pertaing to the fronted
verb from the subcategorisation list of the embed-
ding predicate, and inserts it into SLASH. Simulta-
neously, the remaining complements of the embed-
ding verb are composed with the locally underspec-
ified subcategorisation list of the extracted verbal
complement. In order to match the subcategorisation
requirement of the extracted verb with those of its
complements that are realised in the Mittelfeld, the
subcategorisation list must be percolated via SLASH
as well. Since elements on the subcategorisation list
in SLASH are reentrant with elements on the com-
posed subcategorisation list of the embedding pred-
icate, the former gets specified to the complements
that saturate the requirements in the Mittelfeld. As a
result, we observe a massive encoding of derivation
history in SLASH.
Besides the rules for partial VP fronting, the
grammar recognises 3 more extraction rules, one for
</bodyText>
<page confidence="0.996244">
148
</page>
<bodyText confidence="0.985583288659794">
subject, one for non-subject complements, and one
for adjuncts. Out of these three, only adjunct ex-
traction rules encode reference to their extraction
context in SLASH: since modifiers select the heads
they adjoin to via a feature MOD, which is reentrant
with the SYNSEM of that head, they inevitably carry
along a good deal of that head’s derivation history.
We tested three different configurations of the re-
strictor: one with unrestricted SLASH, one where
the entire SLASH feature was removed during for-
est creation, and a partially restricted variant. This
partially restricted variant preserves the full SLASH
representation for ordinary subject and complement
extraction, but uses an impoverished representation
for adjunct extraction and partial VP fronting. Tech-
nically, this was achieved by using two SLASH fea-
tures in parallel: an auxiliary, impoverished SLASH
to be used during forest creation, and the full
SLASH feature during unpacking. For adjunct ex-
traction and partial VP fronting, SLASH contains
type restrictions on the head value of the fronted el-
ement, together with restrictions on the saturation of
valence lists, if applicable.3 For subject and comple-
ment extraction SLASH contains the same infor-
mation as SLASH. In sum, partial restriction tries
to maximise restrictiveness in those case, where no
reference to the extraction context is encoded in
SLASH, while at the same time it minimises encod-
ing of derivation history in the other cases, by re-
placing token identity with somewhat weaker type
constraints.
The results of this second experiment are sum-
marised in table 2. Again, we have used optimal set-
tings for DSL and ANC, as established by indepen-
dent experiments.
Parallel to our observations regarding the restric-
tion of DSL, we observe that performance is worst
for packed pasring with a completely unrestricted
SLASH feature: not only is the packing rate quite
low (0.25 packings per edge), but also the costs
for packing in terms of the number of subsumption
checks carried out is highest amongst all the experi-
ments reported on in this paper, peaking at 1355.85
subsumption tests per successful packing. The im-
pact on chart size is slightly worse than what we ob-
served with an unrestricted DSL feature. In sum, the
3E.g., modifiers must have saturated valence lists, whereas
fronted partial VP constituents may have open valencies relating
to complements in the Mittelfeld.
suboptimal packing together with the excessive sub-
sumption costs account for the fact that this setting
performs more than 8 times as badly as the baseline.
Although packed parsing with fully restricted
SLASH performs much better than having SLASH
entirely unrestricted, it still falls short of the base-
line by a factor of 1.36. This is due to several rea-
sons: first, although the packing rate is good (0.59),
the chart is the biggest observed with packed pars-
ing in all the experiments carried out, being more
than 2 times as big as the parse chart with optimal
restrictor settings. This is mainly due to the fact that
the grammar is far to unconstrained during forest
creation, allowing too many inconsistent analyses to
enter the chart. This is also corroborated by the fact
that this is the only test run where we experienced a
noticeable increase in unpacking time. Another ob-
servation, for which we cannot offer any explanation
at present, pertains to the increased cost associated
with retroactive packing: the amount of frezing that
has to be done for edges masked by retroactive pack-
ing is far higher than any other value found in these
experiments.
In a separate test run, we used simultaneous full
restriction for DSL and SLASH, in order to verify
whether our assumtion that the choice of one re-
strictor is independent from the others. By and large,
our hypothesis was confirmed: having both DSL and
SLASH fully restricted performed more than 2.5
times worse than full restrcition of SLASH whith
partial restriction of DSL.
Still in parallel to our findings regarding DSL,
partial restriction of SLASH performs best, con-
firming that the compromise between restrictiveness
and eleimination of derivation history is effective
to achieve a runtime behaviour that clearly outper-
forms the baseline. The packing rate achieved with
partial restriction of semantics, DSL and SLASH
(0.36) is actually very close to the packing rates re-
ported in (Oepen and Carroll, 2000) for the ERG,
which figures around 0.33 for input longer than 10
words. Also, the compactness of the chart with in-
put of increasing length (cf. figure 3.2), and the low
number (2) of performance outliers (cf. figure 3.2)
suggest that we are indeed close to optimal feature
restriction.
Decisions on which features to preserve within
SLASH under partial restriction were mainly de-
</bodyText>
<page confidence="0.99533">
149
</page>
<table confidence="0.9988532">
Edges Time (s) Unpack (s) Subsumption C L Factor (time) Subs. cost Pack rate
Unfill 6424 0.56 0 0 0 0 0 0 1 N/A 0
Partial SLASH 1494 0.28 0.01 36404.15 307.28 193.33 36.67 335.84 0.5 67.76 0.36
Full SLASH 2187 4.72 0.01 728385.4 314.66 149.21 73.35 826.1 8.43 1355.85 0.25
No SLASH 3435 0.76 0.16 97965.05 883.79 994.87 145.44 2583.51 1.36 48.4 0.59
</table>
<tableCaption confidence="0.999452">
Table 2: Performance of packed parsing with different restriction of SLASH
</tableCaption>
<bodyText confidence="0.999879611940299">
rived in a test-debug cycle. We therefore plan to
investigate different configurations of partially re-
stricted SLASH in future work.
Restricting ANC The last experiment we carried
out relates to the ANC (=ANCHOR) feature used
to percolate semantic attachment anchors for rela-
tive clause extraposition in the style of (Kiss, 2005;
Crysmann, 2005). Using ANC, index and handle of
each and every NP are collected and passed up the
tree, to be bound by an extraposed relative clause
attached to the same subclause.
Again, we tested three different settings: full re-
striction of all 3 anchor feature (SELF, ACTIVE, IN-
ERT), no restriction, and partial retsriction, where
the elements on the lists were restricted to *top*,
thereby recording only the number of percolated an-
chors, but not their nature in terms of index fea-
tures. ANC features encode derivation history in two
ways: first, structurally higher anchors (NPs) are
represented at the front of the list, whereas more
deeply embedded anchors are found further down
the list. Second, to control for spurious attachments,
only anchors inherited from a left daughter are ac-
cessible for binding (ACTIVE), the others remain on
the INERT list. Both the order of indices on the lists,
list length and the distribution of anchors over AC-
TIVE and INERT lists partially encode constituent-
internal structure.
Results of this experiment are summarised in ta-
ble 3.
Similar to our two previous experiments, en-
tirely unrestricted ANC behaves worst, but nowhere
nearly as bad as having SLASH or DSL unrestricted.
In fact, relative packing rates achieved by all three
restrictor settings are by and large the same in
this experiment. The main difference between un-
restricted ANC concerns the overall compactness of
the forest and the number of subsumption test per-
formed.
Partial restriction already performs better than un-
restricted ANC: since partially restricted ANC does
not record the nature of the anchors, at least one way
in which derivation history is recorded is effectively
masked.
Contrary to our previous experiments, however,
partial restriction does not outperform full restric-
tion. Although this finding comes somewhat at a
surprise, there is nevertheless a straightforward ex-
planation for the difference in behaviour: while full
restriction necessarily improves chart compactness,
the adverse effects of full restriction do not come
to bear as often as in the case of fully restricted
SLASH or DSL, since attachment of extraposed rel-
ative clauses presupposes the existence of an al-
ready constructed chart edge for the relative clause.
In contrast to extraction and head movement, which
can be found in practically every sentence-size test
item, distribution of relative clauses is comparatively
low. Furthermore, constituents serving as fillers for
SLASH or DSL dependencies can actually be quite
small in size and different in shape, which increases
the potential for overgeneration with fully restricted
movement features. Relative clauses, on the other
hand, are always clause-sized, and their properties
depend on the information percolated in ANC only
to a very little degree (namely number and gender
agreement of the relative pronoun).
</bodyText>
<sectionHeader confidence="0.999331" genericHeader="conclusions">
4 Conclusion
</sectionHeader>
<bodyText confidence="0.999948642857143">
In this paper, we have explored the effects in the
choice of restrictor for HPSG parsing of German
with local ambiguity packing. Based on initial ob-
servation that a semantics-only restrictor gives sub-
optimal runtime performance in packed parsing, we
found that three features representing discontinuities
were mainly responsible for inefficiency with lo-
cal ambiguity packing, namely SLASH for extrac-
tion, DSL for head movement, and ANC for relative
clause extraposition, all of which may encode part
of the derivation history.
We have shown that partial restriction of SLASH
and DSL features, together with full restriction
of ANC yields satisfactory parsing performance
</bodyText>
<page confidence="0.99658">
150
</page>
<table confidence="0.998466">
Edges Time (s) Unpack (s) Subsumption C L Factor (time) Subs. cost Pack rate
Unfill 6424 0.56 0 0 0 0 0 0 1 N/A 0
Partial ANC 1586 0.37 0.01 55392.34 319.35 232.28 51.34 608.51 0.66 91.87 0.38
Full ANC 1704 0.58 0.01 104699.81 346.35 257.92 64.66 758.27 1.04 156.52 0.39
No ANC 1494 0.28 0.01 36404.15 307.28 193.33 36.67 335.84 0.5 67.76 0.36
</table>
<tableCaption confidence="0.999895">
Table 3: Performance of packed parsing with different restriction of ANC
</tableCaption>
<bodyText confidence="0.999768833333333">
with ambiguity packing, outperforming the a non-
packing baseline parser with feature structure unfill-
ing by a factor of 2. Even more importantly, combi-
natorial explosion at increasing input length is effec-
tively tamed, such that performance gains improve
with longer input sentences.
</bodyText>
<sectionHeader confidence="0.987618" genericHeader="acknowledgments">
Acknowledgement
</sectionHeader>
<bodyText confidence="0.999975">
The research reported on in this paper has been car-
ried out as part of the DFKI project Checkpoint,
funded by the Federal State of Berlin and the EFRE
programme of the European Union. I am also grate-
fully indepted to Bernd Kiefer for his support of the
runtime parser and his expert advice. Many thanks
also to Ulrich Callmeier, Dan Flickinger, Stefan
M¨uller, Geert-Jan van Noord, and Stephan Oepen,
for their comments and suggestions.
</bodyText>
<sectionHeader confidence="0.99924" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.99964453030303">
Ulrich Callmeier. 2000. PET — a platform for experi-
mentation with efficient HPSG processing techniques.
Journal of Natural Language Engineering, 6(1):99–
108.
Ann Copestake and Dan Flickinger. 2000. An open-
source grammar development environment and broad-
coverage English grammar using HPSG. In Proceed-
ings of the Second conference on Language Resources
and Evaluation (LREC-2000), Athens.
Berthold Crysmann. 2003. On the efficient implemen-
tation of German verb placement in HPSG. In Pro-
ceedings of RANLP 2003, pages 112–116, Borovets,
Bulgaria.
Berthold Crysmann. 2005. Relative clause extraposition
in German: An efficient and portable implementation.
Research on Language and Computation, 3(1):61–82.
J. Earley. 1970. An efficient context-free parsing algo-
rithm. Communications of the ACM, 13(2):94–102.
E. Hinrichs and T. Nakazawa. 1990. Subcategorization
and VP structure in German. In Hughes, Shaun, and
Salmons, editors, Proceedings of the Third Symposium
on Germanic Linguistics, Amsterdam. Benjamins.
Tibor Kiss and Birgit Wesche. 1991. Verb order
and head movement. In Otthein Herzog and Claus-
Rolf Rollinger, editors, Text Understanding in LILOG,
number 546 in Lecture Notes in Artificial Intelligence,
pages 216–240. Springer-Verlag, Berlin.
Tibor Kiss. 2005. Semantic constraints on relative clause
extraposition. Natural Language and Linguistic The-
ory, 23:281–334.
John T. Maxwell and Ronald M. Kaplan. 1995. A
method for disjunctive constraint satisfaction. In Mary
Dalrymple, Ronald M. Kaplan, John T. Maxwell, III,
and Annie Zaenen, editors, Formal Issues in Lexical-
Functional Grammar, pages 381–401, Stanford Uni-
versity. CSLI.
R. C Moore and H. Alshawi. 1992. Syntactic and seman-
tic processing. In H. Alshawi, editor, The Core Lan-
guage Engine, pages 129–148. The MIT Press, Cam-
bridge, MA.
Stefan M¨uller and Walter Kasper. 2000. HPSG analy-
sis of German. In Wolfgang Wahlster, editor, Verb-
mobil: Foundations of Speech-to-Speech Translation,
pages 238–253. Springer, Berlin.
Stefan M¨uller. 1999. Deutsche Syntax — deklarativ.
Linguistische Arbeiten. Niemeyer, T¨ubingen.
John Nerbonne. 1994. Partial verb phrases and spu-
rious ambiguities. In John Nerbonne, Klaus Netter,
and Carl Pollard, editors, German in Head-Driven
Phrase Structure Grammar, number 46 in Lecture
Notes, pages 109–150. CSLI Publications, Stanford
University.
Stephan Oepen and John Carroll. 2000. Ambiguity pack-
ing in constraint-based parsing - practical results. In
Proceedings of the 1st Conference of the North Ameri-
can Chapter of the Association for Computational Lin-
guistics, pages 162–169, Seattle, WA.
Stephan Oepen and Dan Flickinger. 1998. Towards sys-
tematic grammar profiling. test suite technology ten
years after. Journal of Computer Speech and Lan-
guage, 12:411–436.
Stuart Shieber. 1985. Using restriction to extend pars-
ing algorithms for complex feature-based formalisms.
In Proceedings of 23rd meeting of the Association of
Computational Linguistics, pages 145–152, Chicago,
IL.
</reference>
<page confidence="0.998338">
151
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.373163">
<title confidence="0.987719">Local ambiguity packing and discontinuity in German</title>
<author confidence="0.984058">Berthold Crysmann</author>
<affiliation confidence="0.701014">DFKI GmbH &amp; Saarland Stuhlsatzenhausweg</affiliation>
<address confidence="0.793926">D-66123</address>
<email confidence="0.990948">crysmann@dfki.de</email>
<abstract confidence="0.998691263157895">We report on recent advances in HPSG parsing of German with local ambiguity packing (Oepen and Carroll, 2000), achieving a speed-up factor of 2 on a balanced test-suite. In contrast to earlier studies carried out for English using the same packing algorithm, we show that restricting semantic features only is insufficient for achieving acceptable runtime performance with a German HPSG grammar. In a series of experiments relating to the three different types of discontinuities in German (head movement, extraction, extraposition), we examine the effects of restrictor choice, ultimately showing that extraction and head movement require partial restriction of the respective features encoding the dependency, whereas full restriction gives best results for extraposition.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Ulrich Callmeier</author>
</authors>
<title>PET — a platform for experimentation with efficient HPSG processing techniques.</title>
<date>2000</date>
<journal>Journal of Natural Language Engineering,</journal>
<volume>6</volume>
<issue>1</issue>
<pages>108</pages>
<contexts>
<context position="9353" citStr="Callmeier, 2000" startWordPosition="1436" endWordPosition="1437"> of 27 logically possible settings): 1 run without packing, 1 run with optimal settings for the three features under consideration, and 2 runs with suboptimal settings for each of the three features. All test runs were performed on a balanced test suite extracted from the Verbmobil corpus, using 100 items per input length, from sentence length 1 to 22, thus totalling 2200 test items. Although the Verbmobil corpus does contain test sentences of up to 70 words long, their number drops quite quickly from sentence length 23 on. The parser used in the experiments is the current SVN version of Pet (Callmeier, 2000), running the March 24 version of GG (http://gg.dfki.de; (M¨uller and Kasper, 2000; Crysmann, 2003; Crysmann, 2005)). Tests were run on an Intel Core Duo machine using a single T2600 CPU at 2.16GHz with 2 GB main memory. To ensure that we can study parser performance on input of increasing length, we used a rather generous upper limit of 150,000 passive edges. Taking as a guideline the average space consumption per edge of the non-packing parser, we calculated that parsing could still be done comfortably in main memory, i.e., without using swap space. All measurements were performed using the </context>
</contexts>
<marker>Callmeier, 2000</marker>
<rawString>Ulrich Callmeier. 2000. PET — a platform for experimentation with efficient HPSG processing techniques. Journal of Natural Language Engineering, 6(1):99– 108.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ann Copestake</author>
<author>Dan Flickinger</author>
</authors>
<title>An opensource grammar development environment and broadcoverage English grammar using HPSG.</title>
<date>2000</date>
<booktitle>In Proceedings of the Second conference on Language Resources and Evaluation (LREC-2000),</booktitle>
<location>Athens.</location>
<contexts>
<context position="2552" citStr="Copestake and Flickinger, 2000" startWordPosition="368" endWordPosition="372">ructures in unification-based grammars often include information encoding (part of) the derivation history, most notably semantics. In order to achieve successful packing rates, feature restriction (Shieber, 1985) is used to remove this information during creation of the packed parse forest. During the unpacking phase, which operates only on successful parse trees, these features are unified back in again. For their experiments with efficient subsumptionbased packing, (Oepen and Carroll, 2000) experimented with different settings of the packing restrictor for the English Resource Grammar ERG (Copestake and Flickinger, 2000): they found that good packing rates, and overall good performance during forest creation and unpacking were achieved, for the ERG, with partial restriction of the semantics, e.g. keeping index features unrestricted, since they have an impact on external combinatorial potential, but restricting most of the internal MRS representation, including the list of elementary predications and scope constraints. Restriction of syntactically potent features, has thus been found both unnecessary and less efficient. First experiments in ambiguity packing with a German HPSG grammar (GG; http://gg.dfki.de) r</context>
</contexts>
<marker>Copestake, Flickinger, 2000</marker>
<rawString>Ann Copestake and Dan Flickinger. 2000. An opensource grammar development environment and broadcoverage English grammar using HPSG. In Proceedings of the Second conference on Language Resources and Evaluation (LREC-2000), Athens.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Berthold Crysmann</author>
</authors>
<title>On the efficient implementation of German verb placement in HPSG.</title>
<date>2003</date>
<booktitle>In Proceedings of RANLP 2003,</booktitle>
<pages>112--116</pages>
<location>Borovets, Bulgaria.</location>
<contexts>
<context position="6185" citStr="Crysmann, 2003" startWordPosition="923" endWordPosition="924">rman syntax in HPSG assume, since (Kiss and Wesche, 1991), that the initial verb is related to the final verb cluster by means of head movement: clause-finally, a trace is inserted that combines the S NP-A-V-MOD S/NP-A-V-MOD helfen Figure 1: DSL: Monday let he him the man help argument structure of the final cluster with the subcategorisation requirements percolated down from the finite verb using a special feature DSL (=“double SLASH”). Arguments in the Mittelfeld are saturated as complements of the clause-final trace. The grammar used here assumes head movement for discontinuous predicates (Crysmann, 2003), following in this respect the earlier implementation by (M¨uller and Kasper, 2000). In order to relate the initial verb to the verb cluster and its arguments in the Mittelfeld, like the subject and direct object in figure 2, the DSL (or V1) feature must percolate subcategorisation requirements for subject and object, as well as for the verb cluster. At the gap site, the valence information percolated via DSL is inserted into the actual valence lists of the verb trace. Since the requirements are matched against actual arguments found in the Mittelfeld, the valence lists contained in DSL get i</context>
<context position="9451" citStr="Crysmann, 2003" startWordPosition="1451" endWordPosition="1452">e features under consideration, and 2 runs with suboptimal settings for each of the three features. All test runs were performed on a balanced test suite extracted from the Verbmobil corpus, using 100 items per input length, from sentence length 1 to 22, thus totalling 2200 test items. Although the Verbmobil corpus does contain test sentences of up to 70 words long, their number drops quite quickly from sentence length 23 on. The parser used in the experiments is the current SVN version of Pet (Callmeier, 2000), running the March 24 version of GG (http://gg.dfki.de; (M¨uller and Kasper, 2000; Crysmann, 2003; Crysmann, 2005)). Tests were run on an Intel Core Duo machine using a single T2600 CPU at 2.16GHz with 2 GB main memory. To ensure that we can study parser performance on input of increasing length, we used a rather generous upper limit of 150,000 passive edges. Taking as a guideline the average space consumption per edge of the non-packing parser, we calculated that parsing could still be done comfortably in main memory, i.e., without using swap space. All measurements were performed using the [incr tsdb()] profiling platform (Oepen and Flickinger, 1998). Parsing times reported are total CP</context>
<context position="13616" citStr="Crysmann, 2003" startWordPosition="2310" endWordPosition="2311">0000 60000 40000 20000 0 22 20 18 16 14 12 10 8 6 4 2 0 Restricting DSL The first syntactically potent feature investigated in these experiments is the feature DSL (or V1), which serves to relate, by means of simulated head movement, the finite verb in clause-second position to the clause-final verb cluster. Essentially, this feature is used to pass down the valence information from the initial verb to the clause-final verb trace, where this valence information is combined with that of the cluster. In the grammar under consideration, verb movement is restricted to discontinuous verb clusters (Crysmann, 2003), i.e., to situations where there is either an overt verb cluster, or a stranded verb particle in the right sentence bracket. Since actual or putative arguments of the verb trace must be checked against the actual valence information of the V2 verb, derivation history must be carried along as part of the DSL feature. Obviously, any feature that (partially) encodes derivation history is a potential threat to efficient ambiguity packing. We therefore experimented with three different settings regarding restriction of this feature: full restriction, no restriction, and a partial restriction, wher</context>
</contexts>
<marker>Crysmann, 2003</marker>
<rawString>Berthold Crysmann. 2003. On the efficient implementation of German verb placement in HPSG. In Proceedings of RANLP 2003, pages 112–116, Borovets, Bulgaria.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Berthold Crysmann</author>
</authors>
<title>Relative clause extraposition in German: An efficient and portable implementation.</title>
<date>2005</date>
<journal>Research on Language and Computation,</journal>
<volume>3</volume>
<issue>1</issue>
<contexts>
<context position="9468" citStr="Crysmann, 2005" startWordPosition="1453" endWordPosition="1455"> consideration, and 2 runs with suboptimal settings for each of the three features. All test runs were performed on a balanced test suite extracted from the Verbmobil corpus, using 100 items per input length, from sentence length 1 to 22, thus totalling 2200 test items. Although the Verbmobil corpus does contain test sentences of up to 70 words long, their number drops quite quickly from sentence length 23 on. The parser used in the experiments is the current SVN version of Pet (Callmeier, 2000), running the March 24 version of GG (http://gg.dfki.de; (M¨uller and Kasper, 2000; Crysmann, 2003; Crysmann, 2005)). Tests were run on an Intel Core Duo machine using a single T2600 CPU at 2.16GHz with 2 GB main memory. To ensure that we can study parser performance on input of increasing length, we used a rather generous upper limit of 150,000 passive edges. Taking as a guideline the average space consumption per edge of the non-packing parser, we calculated that parsing could still be done comfortably in main memory, i.e., without using swap space. All measurements were performed using the [incr tsdb()] profiling platform (Oepen and Flickinger, 1998). Parsing times reported are total CPU times (in secon</context>
<context position="24724" citStr="Crysmann, 2005" startWordPosition="4105" endWordPosition="4106">.28 193.33 36.67 335.84 0.5 67.76 0.36 Full SLASH 2187 4.72 0.01 728385.4 314.66 149.21 73.35 826.1 8.43 1355.85 0.25 No SLASH 3435 0.76 0.16 97965.05 883.79 994.87 145.44 2583.51 1.36 48.4 0.59 Table 2: Performance of packed parsing with different restriction of SLASH rived in a test-debug cycle. We therefore plan to investigate different configurations of partially restricted SLASH in future work. Restricting ANC The last experiment we carried out relates to the ANC (=ANCHOR) feature used to percolate semantic attachment anchors for relative clause extraposition in the style of (Kiss, 2005; Crysmann, 2005). Using ANC, index and handle of each and every NP are collected and passed up the tree, to be bound by an extraposed relative clause attached to the same subclause. Again, we tested three different settings: full restriction of all 3 anchor feature (SELF, ACTIVE, INERT), no restriction, and partial retsriction, where the elements on the lists were restricted to *top*, thereby recording only the number of percolated anchors, but not their nature in terms of index features. ANC features encode derivation history in two ways: first, structurally higher anchors (NPs) are represented at the front </context>
</contexts>
<marker>Crysmann, 2005</marker>
<rawString>Berthold Crysmann. 2005. Relative clause extraposition in German: An efficient and portable implementation. Research on Language and Computation, 3(1):61–82.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Earley</author>
</authors>
<title>An efficient context-free parsing algorithm.</title>
<date>1970</date>
<journal>Communications of the ACM,</journal>
<volume>13</volume>
<issue>2</issue>
<contexts>
<context position="1064" citStr="Earley, 1970" startWordPosition="155" endWordPosition="156">ng semantic features only is insufficient for achieving acceptable runtime performance with a German HPSG grammar. In a series of experiments relating to the three different types of discontinuities in German (head movement, extraction, extraposition), we examine the effects of restrictor choice, ultimately showing that extraction and head movement require partial restriction of the respective features encoding the dependency, whereas full restriction gives best results for extraposition. 1 Introduction It is a well-known fact that chart parsing without techniques for local ambiguity packing (Earley, 1970) faces a combinatorial explosion of the search space, owing to the (structural) ambiguity imminent to natural language. Thus, identical edges with different internal derivation history can be packed into a single representative for further processing, thereby effectively solving the complexity issue. In context-free grammars augmented with a unification formalism, packing based on the CF symbol equality has been complemented by subsumption- or disjunction-based packing of the associated feature structures (Moore and Alshawi, 1992; Maxwell and Kaplan, 1995). For parsing with constraint-based gr</context>
</contexts>
<marker>Earley, 1970</marker>
<rawString>J. Earley. 1970. An efficient context-free parsing algorithm. Communications of the ACM, 13(2):94–102.</rawString>
</citation>
<citation valid="true">
<authors>
<author>E Hinrichs</author>
<author>T Nakazawa</author>
</authors>
<title>Subcategorization and VP structure</title>
<date>1990</date>
<booktitle>Proceedings of the Third Symposium on Germanic Linguistics,</booktitle>
<editor>in German. In Hughes, Shaun, and Salmons, editors,</editor>
<location>Amsterdam. Benjamins.</location>
<contexts>
<context position="7574" citStr="Hinrichs and Nakazawa, 1990" startWordPosition="1149" endWordPosition="1152">iour, it has clear repercussions for parsing with ambiguity packing. Partial VP fronting Another aspect, in which the syntax of German differs from that of English is in the area of extraction: while in English only constituents with a saturated COMPS list can undergo wh-movement, this is not the case in German: as shown in figure 2, the verb schenken ‘give/donate’ has been fronted, leaving its two complements behind. In HPSG, partial VP fronting is analysed by a combination of two mechanisms (M¨uller, 1999; Nerbonne, 1994): first, standard argument composition in the verb cluster, following (Hinrichs and Nakazawa, 1990), combined with a standard SLASH-based treatment of long-distance extraction. Again, since argument composition is performed N V EPS/NP-A-V-MOD lasse EPS/NP-A-V-MOD NP-NOM-SG Montag ich EPS/NP-A-V-MOD NP-ACC-SG ihn NP-DAT N D EPS/NP-A-V-MOD EPS V Mann dem 145 wollen Figure 2: SLASH: give has he him the book wanted by strcuture-sharing, i.e. reentrancy between the valence list of the governing predicate and the unsaturated valence list of the governed predicate, extraction of the governed predicate by means of SLASH percolation carries this reentrancy over into SLASH. From a general linguistic </context>
</contexts>
<marker>Hinrichs, Nakazawa, 1990</marker>
<rawString>E. Hinrichs and T. Nakazawa. 1990. Subcategorization and VP structure in German. In Hughes, Shaun, and Salmons, editors, Proceedings of the Third Symposium on Germanic Linguistics, Amsterdam. Benjamins.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Tibor Kiss</author>
<author>Birgit Wesche</author>
</authors>
<title>Verb order and head movement.</title>
<date>1991</date>
<booktitle>In Otthein Herzog and ClausRolf Rollinger, editors, Text Understanding in LILOG, number 546 in Lecture Notes in Artificial Intelligence,</booktitle>
<pages>216--240</pages>
<publisher>Springer-Verlag,</publisher>
<location>Berlin.</location>
<contexts>
<context position="5627" citStr="Kiss and Wesche, 1991" startWordPosition="832" endWordPosition="835">ffect, that is, non-finite verbs are standardly placed sentencefinally. In clauses other than complementizerintroduced subclauses and relative clauses, the finite verb surfaces in a clause-initial position (either first or second). Any major constituent may occupy the topic position preceding the finite verb, including subject, complements or modifiers. Owing to the V2 effect, the parts of a verb cluster are discontinuous. Since both the finite verb and the non-finite verb cluster impose constraints on constituents in the Mittelfeld, standard approaches to German syntax in HPSG assume, since (Kiss and Wesche, 1991), that the initial verb is related to the final verb cluster by means of head movement: clause-finally, a trace is inserted that combines the S NP-A-V-MOD S/NP-A-V-MOD helfen Figure 1: DSL: Monday let he him the man help argument structure of the final cluster with the subcategorisation requirements percolated down from the finite verb using a special feature DSL (=“double SLASH”). Arguments in the Mittelfeld are saturated as complements of the clause-final trace. The grammar used here assumes head movement for discontinuous predicates (Crysmann, 2003), following in this respect the earlier im</context>
</contexts>
<marker>Kiss, Wesche, 1991</marker>
<rawString>Tibor Kiss and Birgit Wesche. 1991. Verb order and head movement. In Otthein Herzog and ClausRolf Rollinger, editors, Text Understanding in LILOG, number 546 in Lecture Notes in Artificial Intelligence, pages 216–240. Springer-Verlag, Berlin.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Tibor Kiss</author>
</authors>
<title>Semantic constraints on relative clause extraposition.</title>
<date>2005</date>
<booktitle>Natural Language and Linguistic Theory,</booktitle>
<pages>23--281</pages>
<contexts>
<context position="24707" citStr="Kiss, 2005" startWordPosition="4103" endWordPosition="4104">36404.15 307.28 193.33 36.67 335.84 0.5 67.76 0.36 Full SLASH 2187 4.72 0.01 728385.4 314.66 149.21 73.35 826.1 8.43 1355.85 0.25 No SLASH 3435 0.76 0.16 97965.05 883.79 994.87 145.44 2583.51 1.36 48.4 0.59 Table 2: Performance of packed parsing with different restriction of SLASH rived in a test-debug cycle. We therefore plan to investigate different configurations of partially restricted SLASH in future work. Restricting ANC The last experiment we carried out relates to the ANC (=ANCHOR) feature used to percolate semantic attachment anchors for relative clause extraposition in the style of (Kiss, 2005; Crysmann, 2005). Using ANC, index and handle of each and every NP are collected and passed up the tree, to be bound by an extraposed relative clause attached to the same subclause. Again, we tested three different settings: full restriction of all 3 anchor feature (SELF, ACTIVE, INERT), no restriction, and partial retsriction, where the elements on the lists were restricted to *top*, thereby recording only the number of percolated anchors, but not their nature in terms of index features. ANC features encode derivation history in two ways: first, structurally higher anchors (NPs) are represen</context>
</contexts>
<marker>Kiss, 2005</marker>
<rawString>Tibor Kiss. 2005. Semantic constraints on relative clause extraposition. Natural Language and Linguistic Theory, 23:281–334.</rawString>
</citation>
<citation valid="true">
<authors>
<author>John T Maxwell</author>
<author>Ronald M Kaplan</author>
</authors>
<title>A method for disjunctive constraint satisfaction.</title>
<date>1995</date>
<booktitle>Formal Issues in LexicalFunctional Grammar,</booktitle>
<pages>381--401</pages>
<editor>In Mary Dalrymple, Ronald M. Kaplan, John T. Maxwell, III, and Annie Zaenen, editors,</editor>
<publisher>CSLI.</publisher>
<location>Stanford University.</location>
<contexts>
<context position="1626" citStr="Maxwell and Kaplan, 1995" startWordPosition="232" endWordPosition="235">g without techniques for local ambiguity packing (Earley, 1970) faces a combinatorial explosion of the search space, owing to the (structural) ambiguity imminent to natural language. Thus, identical edges with different internal derivation history can be packed into a single representative for further processing, thereby effectively solving the complexity issue. In context-free grammars augmented with a unification formalism, packing based on the CF symbol equality has been complemented by subsumption- or disjunction-based packing of the associated feature structures (Moore and Alshawi, 1992; Maxwell and Kaplan, 1995). For parsing with constraint-based grammars, such as HPSG, which do not possess an explicit context-free backbone, (Oepen and Carroll, 2000) have proposed an efficient packing algorithm based on feature structure subsumption only. In contrast to the symbols in context-free grammars, feature structures in unification-based grammars often include information encoding (part of) the derivation history, most notably semantics. In order to achieve successful packing rates, feature restriction (Shieber, 1985) is used to remove this information during creation of the packed parse forest. During the u</context>
</contexts>
<marker>Maxwell, Kaplan, 1995</marker>
<rawString>John T. Maxwell and Ronald M. Kaplan. 1995. A method for disjunctive constraint satisfaction. In Mary Dalrymple, Ronald M. Kaplan, John T. Maxwell, III, and Annie Zaenen, editors, Formal Issues in LexicalFunctional Grammar, pages 381–401, Stanford University. CSLI.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R C Moore</author>
<author>H Alshawi</author>
</authors>
<title>Syntactic and semantic processing.</title>
<date>1992</date>
<booktitle>The Core Language Engine,</booktitle>
<pages>129--148</pages>
<editor>In H. Alshawi, editor,</editor>
<publisher>The MIT Press,</publisher>
<location>Cambridge, MA.</location>
<contexts>
<context position="1599" citStr="Moore and Alshawi, 1992" startWordPosition="228" endWordPosition="231">wn fact that chart parsing without techniques for local ambiguity packing (Earley, 1970) faces a combinatorial explosion of the search space, owing to the (structural) ambiguity imminent to natural language. Thus, identical edges with different internal derivation history can be packed into a single representative for further processing, thereby effectively solving the complexity issue. In context-free grammars augmented with a unification formalism, packing based on the CF symbol equality has been complemented by subsumption- or disjunction-based packing of the associated feature structures (Moore and Alshawi, 1992; Maxwell and Kaplan, 1995). For parsing with constraint-based grammars, such as HPSG, which do not possess an explicit context-free backbone, (Oepen and Carroll, 2000) have proposed an efficient packing algorithm based on feature structure subsumption only. In contrast to the symbols in context-free grammars, feature structures in unification-based grammars often include information encoding (part of) the derivation history, most notably semantics. In order to achieve successful packing rates, feature restriction (Shieber, 1985) is used to remove this information during creation of the packed</context>
</contexts>
<marker>Moore, Alshawi, 1992</marker>
<rawString>R. C Moore and H. Alshawi. 1992. Syntactic and semantic processing. In H. Alshawi, editor, The Core Language Engine, pages 129–148. The MIT Press, Cambridge, MA.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Stefan M¨uller</author>
<author>Walter Kasper</author>
</authors>
<title>HPSG analysis of German.</title>
<date>2000</date>
<booktitle>Verbmobil: Foundations of Speech-to-Speech Translation,</booktitle>
<pages>238--253</pages>
<editor>In Wolfgang Wahlster, editor,</editor>
<publisher>Springer,</publisher>
<location>Berlin.</location>
<marker>M¨uller, Kasper, 2000</marker>
<rawString>Stefan M¨uller and Walter Kasper. 2000. HPSG analysis of German. In Wolfgang Wahlster, editor, Verbmobil: Foundations of Speech-to-Speech Translation, pages 238–253. Springer, Berlin.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Stefan M¨uller</author>
</authors>
<date>1999</date>
<booktitle>Deutsche Syntax — deklarativ. Linguistische Arbeiten.</booktitle>
<location>Niemeyer, T¨ubingen.</location>
<marker>M¨uller, 1999</marker>
<rawString>Stefan M¨uller. 1999. Deutsche Syntax — deklarativ. Linguistische Arbeiten. Niemeyer, T¨ubingen.</rawString>
</citation>
<citation valid="true">
<authors>
<author>John Nerbonne</author>
</authors>
<title>Partial verb phrases and spurious ambiguities. In</title>
<date>1994</date>
<booktitle>German in Head-Driven Phrase Structure Grammar, number 46 in Lecture Notes,</booktitle>
<pages>109--150</pages>
<editor>John Nerbonne, Klaus Netter, and Carl Pollard, editors,</editor>
<publisher>CSLI Publications, Stanford University.</publisher>
<contexts>
<context position="7475" citStr="Nerbonne, 1994" startWordPosition="1137" endWordPosition="1138">epresentation of derivation history. While theoretically, this is just the right behaviour, it has clear repercussions for parsing with ambiguity packing. Partial VP fronting Another aspect, in which the syntax of German differs from that of English is in the area of extraction: while in English only constituents with a saturated COMPS list can undergo wh-movement, this is not the case in German: as shown in figure 2, the verb schenken ‘give/donate’ has been fronted, leaving its two complements behind. In HPSG, partial VP fronting is analysed by a combination of two mechanisms (M¨uller, 1999; Nerbonne, 1994): first, standard argument composition in the verb cluster, following (Hinrichs and Nakazawa, 1990), combined with a standard SLASH-based treatment of long-distance extraction. Again, since argument composition is performed N V EPS/NP-A-V-MOD lasse EPS/NP-A-V-MOD NP-NOM-SG Montag ich EPS/NP-A-V-MOD NP-ACC-SG ihn NP-DAT N D EPS/NP-A-V-MOD EPS V Mann dem 145 wollen Figure 2: SLASH: give has he him the book wanted by strcuture-sharing, i.e. reentrancy between the valence list of the governing predicate and the unsaturated valence list of the governed predicate, extraction of the governed predicat</context>
</contexts>
<marker>Nerbonne, 1994</marker>
<rawString>John Nerbonne. 1994. Partial verb phrases and spurious ambiguities. In John Nerbonne, Klaus Netter, and Carl Pollard, editors, German in Head-Driven Phrase Structure Grammar, number 46 in Lecture Notes, pages 109–150. CSLI Publications, Stanford University.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Stephan Oepen</author>
<author>John Carroll</author>
</authors>
<title>Ambiguity packing in constraint-based parsing - practical results.</title>
<date>2000</date>
<booktitle>In Proceedings of the 1st Conference of the North American Chapter of the Association for Computational Linguistics,</booktitle>
<pages>162--169</pages>
<location>Seattle, WA.</location>
<contexts>
<context position="1767" citStr="Oepen and Carroll, 2000" startWordPosition="252" endWordPosition="255"> ambiguity imminent to natural language. Thus, identical edges with different internal derivation history can be packed into a single representative for further processing, thereby effectively solving the complexity issue. In context-free grammars augmented with a unification formalism, packing based on the CF symbol equality has been complemented by subsumption- or disjunction-based packing of the associated feature structures (Moore and Alshawi, 1992; Maxwell and Kaplan, 1995). For parsing with constraint-based grammars, such as HPSG, which do not possess an explicit context-free backbone, (Oepen and Carroll, 2000) have proposed an efficient packing algorithm based on feature structure subsumption only. In contrast to the symbols in context-free grammars, feature structures in unification-based grammars often include information encoding (part of) the derivation history, most notably semantics. In order to achieve successful packing rates, feature restriction (Shieber, 1985) is used to remove this information during creation of the packed parse forest. During the unpacking phase, which operates only on successful parse trees, these features are unified back in again. For their experiments with efficient</context>
<context position="15106" citStr="Oepen and Carroll, 2000" startWordPosition="2552" endWordPosition="2555">e following two tables =_ stands for packing under equivalence, ::1 for proactive packing, C for retroactive packing, and L for freezing. Edges Time (s) Unpack (s) Subsumption C L Factor (time) Subs. cost Pack rate Unfill 6424 0.56 0 0 0 0 0 0 1 N/A 0 Partial DSL 1494 0.28 0.01 36404.15 307.28 193.33 36.67 335.84 0.5 67.76 0.36 Full DSL 1832 1.96 0.01 363840.47 186.19 111.31 42.96 251.32 3.5 1068.68 0.19 No DSL 1917 0.61 0.01 106392.57 568.34 484.68 80.8 926.79 1.09 93.83 0.59 Table 1: Performance of packed parsing with different restriction of DSL1 mantic features like RELS and HCONS, as in (Oepen and Carroll, 2000), as well as optimal settings for SLASH and ANC. Leaving DSL unrestricted features the lowest number of packings, amongst the three settings, both in absolute terms, and in relative packings per edge (0.19). As a consequence, average chart size is bigger than with either partially or fully restricted DSL. Another negative behaviour of packed parsing with an unrestricted DSL is the incommensurate number of subsumption tests carried out: at a ratio of 1068.68 subsumption tests per packing, this accounts chiefly for the inefficiency, in particular, when compared to the much more moderate rates of</context>
<context position="23571" citStr="Oepen and Carroll, 2000" startWordPosition="3910" endWordPosition="3913">y and large, our hypothesis was confirmed: having both DSL and SLASH fully restricted performed more than 2.5 times worse than full restrcition of SLASH whith partial restriction of DSL. Still in parallel to our findings regarding DSL, partial restriction of SLASH performs best, confirming that the compromise between restrictiveness and eleimination of derivation history is effective to achieve a runtime behaviour that clearly outperforms the baseline. The packing rate achieved with partial restriction of semantics, DSL and SLASH (0.36) is actually very close to the packing rates reported in (Oepen and Carroll, 2000) for the ERG, which figures around 0.33 for input longer than 10 words. Also, the compactness of the chart with input of increasing length (cf. figure 3.2), and the low number (2) of performance outliers (cf. figure 3.2) suggest that we are indeed close to optimal feature restriction. Decisions on which features to preserve within SLASH under partial restriction were mainly de149 Edges Time (s) Unpack (s) Subsumption C L Factor (time) Subs. cost Pack rate Unfill 6424 0.56 0 0 0 0 0 0 1 N/A 0 Partial SLASH 1494 0.28 0.01 36404.15 307.28 193.33 36.67 335.84 0.5 67.76 0.36 Full SLASH 2187 4.72 0.</context>
</contexts>
<marker>Oepen, Carroll, 2000</marker>
<rawString>Stephan Oepen and John Carroll. 2000. Ambiguity packing in constraint-based parsing - practical results. In Proceedings of the 1st Conference of the North American Chapter of the Association for Computational Linguistics, pages 162–169, Seattle, WA.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Stephan Oepen</author>
<author>Dan Flickinger</author>
</authors>
<title>Towards systematic grammar profiling. test suite technology ten years after.</title>
<date>1998</date>
<journal>Journal of Computer Speech and Language,</journal>
<pages>12--411</pages>
<contexts>
<context position="10014" citStr="Oepen and Flickinger, 1998" startWordPosition="1544" endWordPosition="1547">GG (http://gg.dfki.de; (M¨uller and Kasper, 2000; Crysmann, 2003; Crysmann, 2005)). Tests were run on an Intel Core Duo machine using a single T2600 CPU at 2.16GHz with 2 GB main memory. To ensure that we can study parser performance on input of increasing length, we used a rather generous upper limit of 150,000 passive edges. Taking as a guideline the average space consumption per edge of the non-packing parser, we calculated that parsing could still be done comfortably in main memory, i.e., without using swap space. All measurements were performed using the [incr tsdb()] profiling platform (Oepen and Flickinger, 1998). Parsing times reported are total CPU times (in seconds), including exhaustive unpacking of the parse forest, whenever applicable. 3.2 Results The main result of our study is that local ambiguity packing in constraint-based parsing of German can lead to performance improvements, once feature restriction is extended from purely semantic features to syntactically potent features used to model discontinuity, such as SLASH, DSL, and ANC (see below). We also found that positive performance effects could only be achieved, if SLASH and DSL features were partially restricted in such a way as to only </context>
</contexts>
<marker>Oepen, Flickinger, 1998</marker>
<rawString>Stephan Oepen and Dan Flickinger. 1998. Towards systematic grammar profiling. test suite technology ten years after. Journal of Computer Speech and Language, 12:411–436.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Stuart Shieber</author>
</authors>
<title>Using restriction to extend parsing algorithms for complex feature-based formalisms.</title>
<date>1985</date>
<booktitle>In Proceedings of 23rd meeting of the Association of Computational Linguistics,</booktitle>
<pages>145--152</pages>
<location>Chicago, IL.</location>
<contexts>
<context position="2134" citStr="Shieber, 1985" startWordPosition="306" endWordPosition="307">ion-based packing of the associated feature structures (Moore and Alshawi, 1992; Maxwell and Kaplan, 1995). For parsing with constraint-based grammars, such as HPSG, which do not possess an explicit context-free backbone, (Oepen and Carroll, 2000) have proposed an efficient packing algorithm based on feature structure subsumption only. In contrast to the symbols in context-free grammars, feature structures in unification-based grammars often include information encoding (part of) the derivation history, most notably semantics. In order to achieve successful packing rates, feature restriction (Shieber, 1985) is used to remove this information during creation of the packed parse forest. During the unpacking phase, which operates only on successful parse trees, these features are unified back in again. For their experiments with efficient subsumptionbased packing, (Oepen and Carroll, 2000) experimented with different settings of the packing restrictor for the English Resource Grammar ERG (Copestake and Flickinger, 2000): they found that good packing rates, and overall good performance during forest creation and unpacking were achieved, for the ERG, with partial restriction of the semantics, e.g. ke</context>
</contexts>
<marker>Shieber, 1985</marker>
<rawString>Stuart Shieber. 1985. Using restriction to extend parsing algorithms for complex feature-based formalisms. In Proceedings of 23rd meeting of the Association of Computational Linguistics, pages 145–152, Chicago, IL.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>