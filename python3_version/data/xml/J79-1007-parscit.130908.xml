<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<note confidence="0.828987">
American Journal of Computational Linguistics Microfiche 7
</note>
<sectionHeader confidence="0.955170333333333" genericHeader="method">
SEMANTIC DIRECTED TRANSLATION
OF
CONTEXT FREE LANGUAGES
</sectionHeader>
<author confidence="0.583242">
H. William Buttelmann
</author>
<affiliation confidence="0.74006">
Ohio State University
</affiliation>
<copyright confidence="0.309848">
Copyright 1974 by the Association for Computational Linguistics
</copyright>
<page confidence="0.437128">
2
</page>
<sectionHeader confidence="0.634249" genericHeader="method">
ABSTRACT
</sectionHeader>
<bodyText confidence="0.999114785714286">
A formal definition for the semantics of a context free language,
called a phrase-structure semantics, is given. The definition is a model
of the notion that it is phrases which have meaning and that the meaning
of a phrase is a function of its syntactic structure and of the meanings
of its constituents. Next we give a definition for translation on context
free languages. We then study a certain kind of translation on cfl&apos;s,
which proceeds by translating on the phrase trees of the languages, and is
specified by a finite set of tree-replacement rules. We present a pro-
cedure which, given a cfg and phrase-structure semantics for a source
language and a cfg and phrase-structure semantics for a target language,
will (usually) produce the finite set of ttee-replacement rules for tne
translation, if the translation exists. The procedure may be viewed as a
computer program which is a translator generator, and which produces
another program that is a translator.
</bodyText>
<sectionHeader confidence="0.798329" genericHeader="method">
TABLE OF CONTENTS
</sectionHeader>
<table confidence="0.798946642857143">
Title Page 1
Abstract 2
Table of Contents 3
0. Introduction 4
1. Phrase Structure Syntax and Semantics 5
Definition 1 (phrase-structure semantics) 6
Example 1 (cfg and phrase-structure semantics) 7
Definition of semantic functions 0: T(G) 4&apos;4/ 8
Definition of meaning function L(G) 2U 9
2. Translations as Tree Mappings • 12
Definition of general translation T: L(G1) 42LCG2) . . . . 12
Definition of gen(T) 13
Example 2 (gen(T)) 13
Definition of transiatioh T: T(G1) + 2T(G2) 14
Definition of translation T: L(G1) -9- 2L(G2) • • . *** 15
Example 3 (finitely specified translation) 16
3. A Procedure for Finding Translations (Usually) 17
PROCEDURE 19
Proof that the function defined by PROCEDURE is a 22
trtnslation
Figure 1. Thanslator Generator and Translator 25
4. Sample Translations 27
TRANSLATION I (Postfix to Precedence Infix) 27
TRANSLATION II (Explicit * to Implicit *) 31
TRANSLATION II1(2,+ to 1,4) 32
TRANSLATION IV (1,4 to 2,4) 4 33
5. Conclusion and Further Research , 33
Selected Bibliography 36
</table>
<page confidence="0.802767">
3
</page>
<sectionHeader confidence="0.8353672" genericHeader="method">
SEMANTIC DIRECTED TRANSLATION
t
OF =TEXT FREE LANGUAGES
by
H. William Buttelmann
</sectionHeader>
<subsectionHeader confidence="0.648117">
Department of Computer and Information Science
</subsectionHeader>
<affiliation confidence="0.779373">
Ohio State University
</affiliation>
<sectionHeader confidence="0.693983" genericHeader="method">
Columbus, Ohio 43210
0. Introduction.
</sectionHeader>
<bodyText confidence="0.989493565217391">
This paper presents a formal model of the translation of context
free languages. The model is admittedly inadequate to provide for all
the intricacies and complexities of the problem of language translation.
Nevertheless, I hope that practicing applied and computational linguists
will find it intuitively satisfying in its simplicity. At the same time,
the model should give us a basis for proving some theoretical results
about the nature of language translation.
Translation is necessarily concerned with both syntax and semantics,
so we begin with a formal definition of semantics for context free grammars.
In Section 2, a simple algorithm for translating from one context free
language to another is given. The algorithm is &amp;quot;controlled&amp;quot; by a finite
set of rules which specify how to replace phrases in the source language
with semantically equivalent phrases in the target language. The trans-
lation algorithm, it turns out, is sttaightforward. The key problem is in
&amp;quot;finding&amp;quot; the finite set of rules which correctly specify the translation.
The main part of this paper, Section 3, is concerned with that problem.
Throughout tht paper, we assume that grammars and semantics are given.
There is nothing in this paper that tells you. how to go about writing the
&amp;quot;tight&amp;quot; grammar and semantics for a given cfl.
An earlier version of this paper was presented to the Eleventh Annual
Meeting of the Association for Computational Linguistics at Ann Arbor,
Michigan, August, 1973.
This research was supported in part by NSF grant GN-534.l.
</bodyText>
<note confidence="0.8890174">
5
Much of the presentation is formal. Some readers may find it helpful
to read only through Example 1, and then to peruse Section 4 (Sample
Translations) to pick up some intuition, before proceeding with the rest
of the paper.
</note>
<sectionHeader confidence="0.486726" genericHeader="method">
1. Phrase Structure Syntax and Semantics.
</sectionHeader>
<bodyText confidence="0.970356882352941">
I assume the reader is familiar with the notions of &amp;quot;derivation&amp;quot; and
&amp;quot;syntax tree&amp;quot; (alias &amp;quot;derivation tree&amp;quot;, alias &amp;quot;phrase marker&amp;quot;) for cfg&apos;s.
Several good texts on these subjects are listed in the bibliography.,
The definition of semantics which I am about to give is based on
the following two simple notions: 1) it is phrases which have meaptng
(paragraphs, sentences, clauses, and morphs are special cases of phrases),
and 2) the meaning of a phrase is a function of its syntactic structure
and of the meanings of its constituonts. Keeping in mind that a function
is nothing but an assignment of elements in its codomain to elements in
its domain, this definition will provide for idiomatic and emotive meaning,
as well as denotative or referential meaning, provided such meanings are
specified in the universe of discourse. I wish to add before giving the
definition that, although I have never seen it in this form before, I do
not believe this definition of semantics is original with me. I believe
it incorporates the notions of semantics in Benson (1970), Knuth (1968,
1971), some statements attributed to Thompson (et Benson, 1970), and in.
Tarski (1936). Now the definition:
</bodyText>
<figure confidence="0.546739423076923">
6
Definition 1.
Let .G = (V, E, P, S) be a context free grammar where:
✓ is the finite nonempty vocabulary,
E C V is the terminal alphabet,
S E CV - E) is the axiom, and
P is the finite nonempty set of grammar rules, having the form
A 0, for A E CV - E) and a E V+.
A phrase-structure semantics for G is a 7-tuple
(U, M, p, X, A, F, R), where:
U is a set, the universe of discourse,
M c 2 is a finite set of atomic morphemes,
p: V 2 is the vocabulary meaning function,
X = {(, ), „ xl, x2, ..., for some integer n,
A is a finite set of ndmes of partial recursive functions,
F is a finite set of definitions for the partial recursive
functions named in A,
R is a finite set of semantic rules, with the property that
to each grammar rule A .4- Bi...Bn there is assigned one
semantic rule, having the form rA B .B (x1,...,xn) =
e e p
l n
where p E U X U A)+, and r (x xn) = p
A B1...Bn &apos;
specifies a partial recursive function:
rA 4- B ...B : u(B1)x—xi1(Bn) P(A).
</figure>
<sectionHeader confidence="0.837511" genericHeader="method">
1 n
</sectionHeader>
<bodyText confidence="0.92514">
We also require that X n (4 u A) = 0.
=
There is an example on the next page.
</bodyText>
<page confidence="0.689264">
7
</page>
<tableCaption confidence="0.306752">
Example 1.
</tableCaption>
<bodyText confidence="0.5079215">
Codsider a cfg and phrase-structure semantics for well-formed addition
expressions over the alphabet E = {I, +). L(G) = {I, I+I, I+I+I, ...}.
G = (V, E, P, S), and qt3 = (u, M, p, X, A, F, R), where:
grammar semantics
</bodyText>
<equation confidence="0.9958238">
P: R:
rSS4.s(xx2&apos;x3) = x2(xx3)
rSI(x1) = 1(x1)
V = {S, I, +} U = N U {f4-} U {1}, where:
E = {I, -1} N is the set of non-megative integers,
</equation>
<bodyText confidence="0.837923">
and f+ and I are recursive functions
defined in F below.
</bodyText>
<equation confidence="0.9236048">
M = {N, 1, f+}
X = {(, ), „ xl, x2, x3}
A = {1, el
U(I) = (1}, P(+) = {f+}, u(S) = N
F contains just the following definitions:
1. (identity function on N N):
(x) = x
ff (integer addition onN xN4 N):
0) f+(0,y) = y
1) f+(x ,Y) = (e(x,Y)) (&apos; is the successor fn.)
</equation>
<bodyText confidence="0.946853166666667">
Note that r545+5(x1,x2&apos;x3) = x2(xx3) does indeed specify a recursive
function on p(S)xp(+)xp(S) p(S), since if x1 and x3 are in 11(S) = N and if
x2 is in u(+) = {e}, then x2(xx3) = f+(xx3) is in N and f+ is defined
primitive recursive.
Before explaining the example, let&apos;s first consider what the semantics
is used for. We will need the following notation for trees:
</bodyText>
<equation confidence="0.8693955">
0) a is a tree, for all a E E.
1) a&lt;t1...tn&gt; is a tree, for all a E E and trees t1, tn.
</equation>
<bodyText confidence="0.976264805555556">
For readability, we write the members of M without unnecessary braces
&amp;quot;1&amp;quot; instead of &amp;quot;{1}&amp;quot;.
8
The above inductive definition gives a &amp;quot;standard&amp;quot; parenthetized notation
for trees. Let us denote the root of a tree t, rt(t) and the frontier,
fr(t). We shall also need the following non-standard notation:
tolti...tn] is a tree if to, tl, tn are trees and if
fr(to) = rt(ti) rt(t2) rt(tn).
Informally, to[ti...tn] is the tree formed by &amp;quot;grafting&amp;quot; each ti at the
.th
node of the frontier of t02 which can be done since this node has the
same label as the root of ti. For example, the tree
bz\ac
d/r\e
is denoted a&lt;b&lt;de&gt;c&gt;, and it has all the following non-standard representa-
tions: a&lt;bc&gt;[b&lt;de&gt;c], a&lt;b&lt;de&gt;c&gt;[dec], and a[a&lt;bc&gt;][b&lt;de&gt;c]. As the reader
can see, the &amp;quot;box notation&amp;quot; is useful for isolating any rooted subtree. In
particular, note that S&lt;S+S&gt;[S&lt;I&gt;+S&lt;I&gt;] is the syntax tree S&lt;S&lt;I&gt;+S&lt;I&gt;&gt; of
the grammar of Example 1, with its dominating subtree S&lt;S+S&gt; isolated.
Now back to the semantics. The semantic rules R are used to define a
function on the trees of the grammar which assigns to each syntax tree t
a semantic function 0(t). Then and the meaning function p are. used to
define a meaning function p on the sentences of G. First, we define 0,
then p.
To define 0, we must first define the codomain of 0, 4). Informally,
4) is the set of all n-ary functions on 2 x...x2U -+ 2U, for arbitrary n.
Formally, let 4)n {f:2Ux...x2U ÷ 2U f is a function of n arguments}.
Then 4) = U
n=1,2,
The function 0:T(G) -+ 4) assigns to each t in T(G) a semantic function
0(0 on payx Odle xp(Bn p(rt(t)), where Bi...Bn = fr(t). To specify a
semantic function we will use the notation C, where f is
the name of the function, n) is the vector of arguments, D is the
domain, and C is the codomain. is defined by the following inductive
definition:
T(G) is the set of syntax trees (partial and complete) of G.
</bodyText>
<figure confidence="0.941363529411765">
9
0) 0(a)(x)Vp(a) 4 p(a) = i(x):p(a) p(a), where a E V,
0 (A&lt;Bi &apos;B&gt;) (xi, .x) :p (B1) x•&apos; .xp (Bn) p (A)
= rAB (K. , ,xn) :p (B1) x xp (Bn) 4 p (A) , where
4
16&amp;quot;B n
A 4 B1...Bn is a grammar rule.
1) Let t = to[ti...tn] E T(G),
and let Bi = fr(ti) for j = 1,...,n, where 1.0 = 0.
Then 0(t01t1...tn3)(x1,...,xi )41(B1)x...x1(B1 ) 4 p(rt(t0))
= 0(to)(0(ti)(xl,...,x, ):p(Bi)x...xp(B, )
OCY(xj .,,,...,x1 ):p(B,7-1 )
• • •
0(t )(x
n i +1&amp;quot;&apos;&amp;quot;x1 ):p(Bi ) 4 p(rt(t )))
n-1
: 11(rt(y)X..&amp;quot;1.1(rt(tn)) 4 p(rt(t0))
</figure>
<bodyText confidence="0.979818">
Intuitively, the semantic function assigned to each tree t is the composi-
tion of the semantic functions assigned to the subtrees of which t is
composed. We leave it to the reader to verify that is well-defined.
The meaning function p on sentences is a special case of the meaning
function p on a larger domain -- the set of phrase forms of the grammar,.
A. phrase form is similar to a sentential form, except that it need not be
derived from the axiom. Formally, the set of phrase, forms of G is the set
P(G) ={wfwEV* andA=wfor someAEV).
The function is used to define the meaning function as follows. The
function p:P(G) 4.2U is defined by the following rule: Let w = wi...wn be
a phrase form in P(G) and let w have syntax trees t19 ...9 tm Then the
set of meanings of w is the set
</bodyText>
<equation confidence="0.942257">
P = (I) ( t4 ) ( P (W1 ) P (Wn ) ) •
i=1,...,M &apos;A-
</equation>
<bodyText confidence="0.9961815">
L(G), the language of G, is a subset of P(G), so the meaning function on,
sentences, p:L(G) -0- 2U, is just the restriction of p to L(G).
</bodyText>
<page confidence="0.394261">
10
</page>
<bodyText confidence="0.99992105882353">
Since the three functions p, 11, and p have disjoint domains, they can
never be confused, so we shall write p for all three. p is the meaning
function, which assigns to each sentence, phrase form, and symbol, one or
more meanings according to the semantics J. Thus, we are assigning
meaning to a sentence by assigning to it the meanings which are computed by
the semantic functions specified by its phrase structures, taking as argu,
ments the meanings of the constituents of the sentence. The most elementary
constituents of a sentence are the members of E which constitute it. One
-may think of these as the lexical items of the language. Their deanings,
which are the arguments of the semantic function, are among the morphemes
of the language -- those morphemes which cannot be further separated into
morphemes (this is the set of &amp;quot;atomic morphemes&amp;quot;, M). Thus, the meaning
of a sentence is a function of its morphemes. Which function to use is
determined by its syntactic structure. A sentence can be semantically am-
biguous if it has more than one syntax tree or if at least one of its con-
stituents is semantically ambiguous.
We retyrn to Example 1 on the next page.
</bodyText>
<page confidence="0.848286">
11
</page>
<bodyText confidence="0.996802">
Now consider Example 1. Let w be the sentence &amp;quot;I + I + I&amp;quot;. It has
the syntax tree
</bodyText>
<equation confidence="0.994342090909091">
t
.00 %.
N.
S ■ + S 1
t I 1 ‘Ir%t
,,,,i■e, ,
s , ± k 1 , 4
1
t 41 I I i I
I 1 FiNt- .....0
2 ‘,......I.) . 3
</equation>
<bodyText confidence="0.993807666666667">
One meaning of w is 0 CO (p (I) , p (+) , p (I) , p (+) , p (I)) . For notational
purposes, let ti, t2, t3, and t4 be the subtrees of t circled in the
picture. Now compute this member of ii (w) :
</bodyText>
<equation confidence="0.883185375">
, p (I))
(i.&apos;(+)), 4)(t4) (11 (I) ))
= (IS (S&lt;S+S&gt;) (cb (SS+S&gt;[ t2+t3]) (p (I) , p (+) , &apos;(I)), qS(+) (p (+)) , 4)(S&lt;I&gt;) (p (I) ))
1:1) (S&lt;S+s&gt;) (s&lt;s+s&gt;) (4(t2) (p (I)) , (-0 (p(+)),(LI) Cu (I)) /P(+) (p(+)),
(1)(S &lt;I&gt;) (p (I)))
= (S&lt;S+S&gt;) (cb(S&lt;S+S&gt;) (4) (S&lt;I&gt;) (p (I)) , c1 (+) (p (+) ) , cl)(S&lt;I&gt;) (p (I)))
g+) (11(+)) • “S&lt;I&gt;) (I)))
= rS-÷S+S.(rS-+S+S (p (+)) , rS÷I (p (I))) , (p (+)) , rS.+I Cu (I)))
</equation>
<bodyText confidence="0.856869666666667">
= 1 (11(+)) , CI (I)) ) (11 (+) ) ))
S-4-S+S S÷S+S
= rS÷S+S (rS-*S+S (1. (1), ) , (1) ) , (f+) , (1) )
rS-+S+S(rS4-S+S(1, f , 1) , f , 1)
rS÷S+S(f+(1, 1) , f+, 1)
= f+ (f(1, 1), 1)
</bodyText>
<figure confidence="0.8479065">
St) CO CP (I) , , (I), P(+) PCI))
“S&lt;S+S&gt; [tit-t4] ) (p (I) , p (+) , p (I) , p (+)
= (S&lt;S+S&gt;) ((t1) (P (I) , 1-1(+) P (I)) , (+)
12
Note that &amp;quot;I + I + I&amp;quot; also has the syntax tree
t&apos;
but the sentence is not semantically ambiguous since
(t) (P (I) (+) (I) (+) (I) = (11 (I) (+) 1.1 (I) (4-) (i:))
2. Translation As Tree Mappings.
Consider now any two cfgts and their associated semantics, Gi, J11
and G2&apos; £2 A translation of L(G1) o L(G ) is a function
L(C2)
T: L(G1) 2 defined as folliowa:
-c(w) = w&apos; p2(w&apos;) n 0}
</figure>
<bodyText confidence="0.984010789473684">
The codomain of a translatfon must be the power set of the target language,
since every sentence in L(G1) may have many semantically equivalent sen-
tences in L(G2). In this paper we, focus on translations which are speci-
fied by a finite set of rules. For these translations, there is a simple
algorithm for computing the translation of any sentence. This section
presents the bethod for giving the finite specification of T and the
algorithm for computing the translation.
In fact, instead of specifying a translation on the languages, we
specify a translation on the trees of the syntaxes.
To make precise what is meant by &amp;quot;translations which are specified by
a finite set of rules&amp;quot; we introduce the concept of a generating set for
trees. Let T1 and T2 be two sets df trees with labels from some alphabet
0
E. Define the set TE to be the set of all trees with single nodes and
labels from t, Le., T = {alaEE). Informally, Tl isagenerating.set
0
for T2 just in case every tree in T9 is either in TE or is constructed of a
finite number of trees of Tl&apos; and just in case every tree so constructed is
in T2. Formally, let T be a set of trees with labels from E. The set
</bodyText>
<figure confidence="0.823803">
13
gen(T) of trees generated by T is defined inductively as follows:
0
0) TE Egen(y) and T C gen.(T),
1) to[ti...tn) E gen(T) if it is defined,
</figure>
<bodyText confidence="0.968992111111111">
for all positive integer&apos; n,
and for all trees t0&apos; t tn E gen(T).
T is a generating set for gen(T). We leave it to the reader to verify that
every tree in gen(T) can be written in the fort to[ti...tn], where
to E (T U T°) and each t E gen(T), for i = 1, ..., n.
Example 2.
The set of production, trees of a cfg is a generating set for the set
of all the syntax trees of the grammar. Let G = (V, E, P, S), let P
contain k rules, and let P = I A(i)+j i = 1, 2, ..., k).
</bodyText>
<equation confidence="0.95734325">
1 2 • ni
Then the set of production trees of G is the set •••9 k }
T = { A(i)&lt;B(i)B(i)...B(i)&gt; I i = 1, 2,
1 2 ni
</equation>
<bodyText confidence="0.9799165">
The set T(G) of all syntax trees of G is the set gen(T).
As a more concrete example, consider the cfg G given by the following
</bodyText>
<figure confidence="0.8513248">
rules:
S OS
S B
B 0
B 4- 1
</figure>
<bodyText confidence="0.923061923076923">
is the set { S&lt;OS&gt;, S&lt;B&gt;, B&lt;O&gt;, Ed&gt; }, or written pictorially:
T(G) = gen(Tp) contains all trees of the following forms::
S(&lt;0S)n(&gt;)n n &gt; 0,
S(&lt;0S)n&lt;B&gt;(&gt;)n n &gt;0,
S(&lt;0S)n&lt;11.&lt;0»(&gt;)n 2 n &gt;0,
S(&lt;0S)n&lt;B&lt;1»(&gt;)n 2 n &gt;0,
B, 0, 1, i&lt;O&gt;, and B&lt;l&gt;.
The tree t S&lt;OS&lt;OS&lt;B&gt;&gt;&gt; is in T(G) = gen(Tp) since t = S&lt;OS&gt;[0S&lt;OS&lt;B&gt;&gt;1
and S&lt;OS&gt; ET &amp;quot; 0 E gen(T ), and S&lt;OS&lt;B&gt;&gt; E gen(T ). Note that t can also
P&apos;
be written as t = S&lt;OS&lt;OS&gt;&gt;[00S&lt;B&gt;], and again, S&lt;OS&lt;OS&gt;&gt; E gen(cr),
0 E gen(Tp), and S&lt;B&gt; E gen(Tp).
To specify a translation from T(G1) to T(G2) we proceed as follows:
Let T be any partial function on VN VN , and let T be a generating set
1 2 t
for T(G1). Let T be a function on T T(G2) X No which satisfies the
following properties:
if -^r(t) = (t&apos;, xl...xn) then
i) rt(C) = .(rt(t)), and
ii) n = Ifr(C)1, and
iii) 0 &lt;x. &lt; Ifr(01, for i = 1, n, and
iv) xi 0 0 = fr(t&apos;) = T(fr(t) ), for i = 1, n.
T(G2)
Then we define the funbtion T: T(G1) 2 by the following inductive
definition:
0) t E T =T(t) = t , where ;(t) = (t&apos;, x).
1) T(to[t]....tm]) = T(t0)[ti...t:1],
where i)T(t0 ) = (T(t0), x1...xn)&apos; and
any member of T(tx.) if xi #0,
ii) = 1
fr(T(to))i if xi = O.
Note that the codomain of T is the power set of T(G2) because there may be
trees in T(G1) whose non-trivial factorings into to[ti...tm] are not unique.
For these trees, T(t) = { t(to[ti...tm]) I to[ti...tm] is a representation
of t }. As with languages, we will call T a translation only if it pre-
T(G2)
serves semantics, that is, T: T(G1) + 2 is a transtation iff for every
tree t E T(G1) and for every tree t&apos; E T(G2), if fr(t) = wi...wm and
fr(t&apos;) = w&apos; ..w&apos; then
</bodyText>
<listItem confidence="0.672874">
1. n&apos;
</listItem>
<equation confidence="0.674693">
t&apos; E T(t)cp(t)(111(w1),...,p1(wm)) n gc)(112(w1),...,p2(wil” o 0.
</equation>
<bodyText confidence="0.9778815">
N is the set of non-negative integers.
0
</bodyText>
<subsectionHeader confidence="0.481868">
15
</subsectionHeader>
<bodyText confidence="0.972672523809524">
We will call T fihitely specified (specified by a finite set of rules) iff
the generating set T is finite.
L(G2)
Finally, T is used to define a trdhslation T: L(G1) -0- 2 as follows:
Let w E L(G1) have syntax trees tl, tk. Then
= w&apos; I 3 t&apos; in T(G2) and 3 t in T(G1)
ti is a syntax tree of w&apos; and
is a syntax tree of w and
E T(t) 1.
•■■■•■
such that
It follows from the definitions that T is a translation if T is. To see
tilts, let w = w1...wm and w&apos; = . w1&apos;•..w&apos; and let w&apos; E T(w). Then there exist
n
w and t&apos; of w&apos; such that t&apos; E t(f). Let
..01 (w
1m)) and E2 = 4)(tr)(11 Then from
2C111&amp;quot;.&amp;quot;P264;)).
sytitax trees t of
El = gt)(111671),.
the definition of i, G p1 2 — (w) and C c Or&apos;) = 1.12(r(w)). If T is a
</bodyText>
<equation confidence="0.633605">
1 — 2
</equation>
<bodyText confidence="0.998669888888889">
translation, then Ei n C2 # 0, so 717/(w) 11 1-72(7(w)) # 0, and so 7 is a
translation.
The functions and T are the method for specifying the function T.
The specification is finite just in case the generating set T is finite.
The inductive definition for T gives the algorithm for computing the trans-
lation of any tree in T(Gi), and the definition of T, together with this
algorithm and a general context free parser such as Floyd&apos;s or Early&apos;s
algorithm, gives the algorithm for computing the translation of any sen-
tence in L(G1). The next example illustrates.
(In the following and in all subsequent examples, we shall give ex-
plicitly only the grammar rules, the right-hand side of the semantic rules,
the universes of discourse, the meaning function, and those definitions of
partial recursive functions that are necessary. The reader can easily
determine the rest of the specifications for the grammars and semantics, if
he wishes. For cfg&apos;s we shall follow the usual convention that all symbols
whicn do not appear on the left-hand side of some grammar rule are termi-
nal symbols, and that the axiom is the first symbol appearing in the first
rule.)
</bodyText>
<table confidence="0.628874833333333">
Example 3.
We present two cfg&apos;s and their semantics, and a finitely specified
q
translation T on T(G1 ) 4 2T(GL) . To help the intuition, consider that
Gi, 11 describes well-parenthesized subtraction expressions, and G2,412
describes subtraction expressions in Polish postfix notation.
G1 G2: R2:
E E-E x2(x1&apos;x3) S 4 SS- x3(xx2)
E (E) 1(x2) S 1 1(x1)
E 1 (x1) S 4 2 1(x1)
E 4. 2 (xi) S 4 3 1(x1)
Ul = U2 = N U {f-}, where
16
N is the set of integers and
f :NxN4Nis ordinary subtraction
1 p2(1) = 1
2 112(2) = 2
3 P2(3) = 3
</table>
<equation confidence="0.950197421052631">
P2(-) =
=
p1(1)
=
p1(2)
11 (3) =
1
P =
1
P = 0
1 p2(S) = N
P (-) = f
1
p1(E) = N
The translation is specified by:
i(E) = S
A
s • 2)
130)
</equation>
<page confidence="0.312212">
Ns■
C/&apos;1
</page>
<figure confidence="0.786660944444444">
S S -
17
The sentence 1-2-3 is semantically ambiguous (its meanings are 0 and -4),
and its two translations are given by:
1) AN_
-E3
2
i.e., T(1-2-3) contains 12-3-
f
1 (ISE 1 S - S
S - S
ASN I A\
I
2) AsS■
(■4%!
E E
i.e., T(1-2-3) contains 123--
On the other hand the sentence 1-(2-3) is unatbiguous and is translattd:
</figure>
<table confidence="0.7515924375">
E
-a/K
AN
1 ( E )Ts 1 (0/0K
fi
1
E - E
II / &amp;quot;
AN
2 3 2 3 2 3
i.e., T(1-(2-3)) contains 123--
3. A Procedure for Finding Translations (Usually).
Suppose an oracle presents us with two cfg&apos;s G1 and G2 and their
respective semantics ggi and a;2. Suppose also that a finitely specified
translation from T(G1) to T(G2) exists. Can we find it? That is, can we
18
</table>
<tableCaption confidence="0.425850833333333">
produce the finite set oft, rules defining the functions I and ;?
In this section we consider a procedure which accepts two arbitrary
cfg&apos;s and their phrase structure semantics and tries to find a descrip-
tion of such a translation. The procedure may not always work, in than
it may not halt or the Function T it describes may,be only partial. VUt
T is guaranteed to be correct; that is, the definitions of 1 and ; vro-
q
duced specify a partial function T: T(GI) 2T(GL) which is a translation
in the sense that, for any t E T(Gi), if T(t) is defined then T(t) is a
translation of t. First, the procedure is presented; then we give the
arguments that T is a (partial) translation.
Intuitively, the procedure works as follows: We try to find a finite
</tableCaption>
<table confidence="0.605689125">
generating set T for T(G1) and a pair of functions 1: VN VI and
1 2
T: T T(G2) x N40 which have the property that for every tree t0 E T, if
T(t ) = (t&apos;0 x) then t0 and t&apos; represent the same semantic function. What
0 &amp;quot; 0
is meant by &amp;quot;to and t0 represent the same semantic function&amp;quot; is lust this:
If ;(to) = (t13, xl...xn) then gt0)(571,...,ym) =
provided yl =
</table>
<construct confidence="0.551967">
if x = 0.
</construct>
<bodyText confidence="0.97117356">
2 0 i
In general, to get semantic equivalence, one has to be careful how the
syntactic variables on the frontier of to are associated by the string x
with the syntactic variables on the frontier of t(&apos;), since these represent
possible trees with meaning, and hence the domains of the semantic func-
tions for to and t(&apos;). If such a generating set T and functions 1 and ; can
be found, the job is finished, since it can then be shown that the function
T defined by 1 and T is a translation.
The procedure begins with the set Tp of production trees of Gl, which
is indeed a finite generating set for T(Gi). If the procedure can find a
&amp;quot;translation&amp;quot; for each t in TP&apos; it will be successful, and will halt and
output T, T, and The procedure systematically picks successive trees to
in T and searches T(G2) for a semantically equivalent tree t&apos; whose fron-
tier
it can match up by some rule x. If it finds one, it outputs the
definitionT(t0 ) 0&amp;quot; (t&apos; x) deletes t0 from T and tries one of the remain-
ing trees. If it succeeds in exnausting Tp, it is successful.
19
Suppose, however, that for some to in Tp, the procedure can&apos;t find a
&amp;quot;translation&amp;quot; in T(G2). Then if we assume that T does exist, it must be
the case that t0 is part of a larger tree (or of each of a set of larger
trees) which can be &amp;quot;translated&amp;quot;. Furthermore, if we also assume that
T is finitely specified, this set is finite. Thus, the procedure tries
to construct a new set of trees, T1, not containing to, which is a finite
generating set for T(G1) - {t0}. It cannot be the case that the frontier
</bodyText>
<equation confidence="0.54938325">
•■••■
of t0 is a sentence if we also assume that the existing T is total an
;Qg9 So, losing t0 from T(G1) cannot delete any sentences from the
1
</equation>
<bodyText confidence="0.996757941176471">
language represented by T(Gi). The procedure takes the set Tl as a new
generating set to work with and begins again.
It turns out that finding T depends heavily an the sequence in which
successive trees are chosen for translation attempts. Therefore, to
guarantee that T will be found if it exists, the procedure tries all poss-
ible sequences of trees. The procedure has the general sttuctume of a
&amp;quot;tree search&amp;quot;, and is represented by the search tree pictured below. Each
node in the tree represents a subprocedure which is described below the
tree.
PROCEDURE
Given two reducedt cfg&apos;s G1 and G2 and their respective phrase-
structure semantics el1 and .82&apos; execute the search tree below for all
integer pairs (maxi, maxs) = (1, 1), (1, 2), (2, 1), (2, 2), . If for
any pair step 1 halts and outputs &amp;quot;success&amp;quot;, then halt.
Reduced in the sense that each nonterminal symbol is derivable from the
axiom and derives terminal strings. It is well-known that every cfg can
be put into this form.
</bodyText>
<listItem confidence="0.96294575">
step 1: • Set i+. O.
• Define the (finite) set of trees
To = {A&lt;B22...Bn&gt; I A+ B1132...Bn E Pl.
• Define the (finite) set of all possible partial functions
{11, 12, ..., rk} such that for each j = 1, 2, k,
4- V and ;.(S1 ) = S2 and for all A E V p1 (A) = p26j(A)).
N2 j N &apos; 1
• Execute step 2 for each function 4j
</listItem>
<bodyText confidence="0.9939695">
(i.e., for each j 1, 2, ..., k). If for some j the execution
of step 2 returns &amp;quot;success&amp;quot;, then halt and output &amp;quot;success&amp;quot;. If
step 2 returns &amp;quot;fail&amp;quot;, increase j and continue. If step 2. returns
&amp;quot;fail&amp;quot; for all .r. (i.e., for all j), then halt and output &amp;quot;fail&amp;quot;.
</bodyText>
<listItem confidence="0.8993935">
step 2: (N.b., Ti is a finite set)
• If T. = 0 then return &amp;quot;success&amp;quot;.
• If i &gt; maid then return &amp;quot;fail&amp;quot;.
• Otherwise execute sstep.3 for each t E Ti. If the execution of
</listItem>
<bodyText confidence="0.721076">
step 3 returns &amp;quot;success&amp;quot;, then return &amp;quot;success&amp;quot;. If step 3
returns &amp;quot;fail&amp;quot;, then pick the next t in Ti and execute step 3
</bodyText>
<page confidence="0.408092">
21
</page>
<bodyText confidence="0.552158">
again.. If step 3 returns &amp;quot;fail&amp;quot; fot all t in Ti, then return
&amp;quot;fail&amp;quot;.
</bodyText>
<listItem confidence="0.8880708">
step 3: • Execute search.
• If search returns &amp;quot;fail&amp;quot; then execute expand.
• If expand returns &amp;quot;fail&amp;quot; then return &amp;quot;fail&amp;quot; to step 2.
• If either search or expand returns Itsuccessit then return
&amp;quot;success&amp;quot; to step 2.
</listItem>
<bodyText confidence="0.44824075">
search: • Generate the first (maxs) trees of
Tt
= {0 t&apos; ..., }.
l&apos; 2&apos; maxs
</bodyText>
<listItem confidence="0.975074">
• Test each tree 0 in T&apos; to see if it satisfies each of the
following properties:
</listItem>
<equation confidence="0.960219">
i) (rt(t)) = rt(0)
ii) There is a string of non-negative integers x
= ?clX2 ▪ &apos;AC
</equation>
<bodyText confidence="0.6862987">
such that each of the following is true:
a) n =
b) xi 0 = fr(0)1 = ;(fr(t)) for i = 1, 2,
xi
c) x. = 0 fr(0) E E2 for i = 1, 2,
d) 4(t)(Y1.,...07m) = ge)(Y1&apos;...,Y;1)
if xi 0 0
provided yl =
112(fr(0). if x = 0.
1)
</bodyText>
<listItem confidence="0.998697555555556">
• If no such tree t&apos; exists in T&apos;, then return &amp;quot;fail&amp;quot; to step 3.
• If such a tree 0 does exist in T&apos; then
A
• define T(t) = (0, x)
• set i + 1+1
• define the set T = (Ti-1 10)
• execute a new version of step 2.
• If step 2,returnssuccess11 return IIsuccessVI to step 3.
• If step 2 returns &amp;quot;fail&amp;quot; return &amp;quot;fail&amp;quot; to step 3.
</listItem>
<page confidence="0.492228">
22
</page>
<bodyText confidence="0.99921">
expand: • Let Dom(T) denote the domain of the current version of the
function T, i.e., Dom(?) = {t I“t) has been defined by.
some execution of search in the current path of the search
tree}. Let Ti denote the (finite) set (T. U Dom(?)). Define
the set Tt to be the smallest set of trees which is a generating
set for (gen(Ti) - {t}), and which contains the set (TI - {0).
(Note that Tt does not contain t,)
</bodyText>
<listItem confidence="0.999677166666667">
• If Tt is not finite, return &amp;quot;fail” to step 3.
• Set i i+1.
• Set T T.
• Execute a new version of step 2.
• If step 2 returns &amp;quot;success&amp;quot; return &apos;success&amp;quot; to step 3.
• If step 2 returns &amp;quot;fail&amp;quot; return &amp;quot;fail&amp;quot; to step 3.
</listItem>
<sectionHeader confidence="0.493236" genericHeader="method">
END OF PROCEDURE
</sectionHeader>
<bodyText confidence="0.996967">
Now we want to explain how the PROCEDURE defines functions (possibly
n
partial functions) on T(G1) 2T(G2) and on L(G1) 2L(G4) ) and prove that
the functions are translations. We shall also show that if the PROCEDUAE
halts, the translation it total, except under certain easily identifiable
conditions.
Consider any path in the search tree. It looks like this:
</bodyText>
<figure confidence="0.478956333333333">
is defined here.)
(T0 = T is defined here.)
P
6(0 = (t&apos;, x) is defined here if
the node is search.)
(T1 is defined here.)
•
(Tn is defined here.)
23
</figure>
<bodyText confidence="0.900149652173913">
We need to identify two particular sets of trees associated with this path.
Both are finite. The first is the domain of the function and the second
is the set of trees &amp;quot;excluded&amp;quot; by the successive executions of expand.
Note that each execution of the subroutine search adds one item to the
definition of the function. -Ar, and the entire definition of is given by
the set of all these items defined by executions of search in the path.
The domain of then, is the set
Dom(?) = 1 -I(t) is defined by some execution of the
subroutine search in the path}.
Similarly, each execution of the subroutine expand, in its first step,
defines a new set, Tt, which does not contain the tree t. This step has
the effect of excluding the tree t from any further consideration in the
translation process. The set of all such trees is the set
Excl = {t I Tt is defined by some execution of the
subroutine exclude in the path).
Now, the set (Dom() U Tn) is a finite generating set for the set
T(G1) - Excl), so the functions and -I define apartial function
T(GI)
4. 2 &apos; according to the definition in Section 2. Furthermore,
if Tn = 0 then T is total on,the generating set, and SO T is total on
(r(G1) - Excl), and this is just the case when the PROCEDURE halts. Since
Exal is a finite set, we have the result that T is defined on all but a
finite number of elements in T(G1), when the PROCEDURE halts.
</bodyText>
<equation confidence="0.918379666666667">
T(G2)
Since T is a partial function on T(G1 ) 2 , it follows from the
P(G2)
</equation>
<bodyText confidence="0.9581373">
definition of T in Section 2 that 7-is a partial function on P(G1) 2
L(G,)
and therefore on L(G1) 4 2 4 . Leti P(Excl) denote the set of frontiers
of the trees of Excl. Nate that each member of P(Excl) is a phrase form.
Then when the PROCEDURE halts, since T is total on (T(Gi) - Excl), it
follows that T is total on (P (G1)- P(Excl)) and on (L(G1) - P(Excl)).
Thus, Tis total on L(G1) if PROCEDURE halts and if none of the trees
excluded by exclude are complete syntax trees. If complete syntax trees
are excluded, then their sentences are the only ones for which Tis not
defined.
</bodyText>
<page confidence="0.475653">
24
</page>
<bodyText confidence="0.878433466666667">
We have left only to show that T is a translation. The reader may
recall that there may be several nontrivial factorings of trees into a
form for which T is defined, and that this may lead to non-unique trans-
lations. Furthermore, the languages may be semantically ambiguous. These
conditions make the proof that T is a translation less lucid, so we shall
give here the proof for the case where T is defined for only one factoring
of each tree and there is no ambiguity. It will be helpful in the proof
to have the following notation: Let t E T(G1) have fr(t) = wl...wm and let
t&apos; E T(G2) have fr(t&apos;) = . w1&apos; Then by 1(t) E (1)(e) we mean
n
4)(t)(p/(w/),...,u/(wm&amp;quot;) = cl)(e)(p2(w1),...,p2(wn&apos;)).
Now to the proof. Let T(t) = t&apos;. We wish to show that 4)(0 E (1)(e).
Since t E gen(Dom()), t can be written as to[t/...tm] where to E Dom6)
and each of the trees tl, ..4, tm E gen(Dom(-1)). Let T(to) = xl...xn).
Then from the definition of T2 T(t) =. ..t&apos;] where for each
</bodyText>
<figure confidence="0.854387419354839">
0 1 n &apos;
) if xi #0,
t!
1
fr(t&apos;)
0 i if x = O.
For inductive hypothesis, assume that for each j = 1,...,m,
4)(t)=0*(T(t.)). Then we have:
3
=
(1)(t0)(4)(t1 )(p1 (w1 p1 ),..., (w. ),...,(t,m)(111(wj +1
j ),...,p1wm))) and
1 m-1
=
(t;)0(ti)(p2(wi),...,p2(w;c. ),...,(1)(ti&apos;)(P2(witcn-1+1),...11.12(w:1))) and
1
gtx )
(.fr(t). ) = p2 (fr(t).) if xi = O.
0 - 0
if x #0,1
cRti) =
For r 1,...,m let yr = gt and
)(111(w. 4.1),--.2111(F4 )),
Jr-1 Jr
for i = 1,...,n let yl = gt1)(112(xqc 4.1),...1112(w;c. )). Then, if we
i-1
define Jo = ko = 0, the result above demonstrates that
25
if xi 0,
trx4
YT
</figure>
<bodyText confidence="0.902815083333334">
p2(fr(t;)i) if xi = O.
Thus, by the definlpion of T in search,
gt)(111(w1),...yul(wm)) = (t0Y(Y1,...,Ym) = (e)(571,...,y12
= 4)(t&apos;)02(w1),...,u2N)), or (PM E (1)(t&apos;). Thus T is a translation.
Finally, as we showed in Section 2, since T is a translation OM the.
syntax trees), T is a translation (on the languages).
In programming terminology a ,generator is a program whose input is a
set of parameters and whose output is a specialized program (cf Brooks and
Iverson (1969), p. 365). Then PROCEDURE constitutes a &amp;quot;translator
generator&amp;quot;: its input is two cfg&apos;s and their associated phrase structure
semantics, and its output is a table of tree transformations which &amp;quot;drives&amp;quot;
a standard tree-mapping program. The tree mapping program is designed to
be part of a translator system composed of a parser, the tree mapper, and
a frontier stripper (see Figure 1). Translation proceeds as follows: Let
G1 and qg1 be the cfg and semantics for the source language Ll&apos; and G2 and
j 2 the cfg and semantics for the target language L7. The translator is
given a sentence w imLi. The parser produces a parse tree t(w) for w, (If
w is syntactically ambiguous, the parser may produce all the parse trees of
w.) If t(w) is in the domain of the function T defined by the tree mapper,
the tree mapper will produce T(t(w)) whose frontier is a sentence u in L2.
[parser
table
e■I• ■■■■■■ mi■•■■•■•• ■■••• mow■ ••■•
MAPPER. STRIPPgR . 2
</bodyText>
<sectionHeader confidence="0.766565" genericHeader="method">
TRANSLATOR
</sectionHeader>
<subsectionHeader confidence="0.692208">
GENERATOR
</subsectionHeader>
<bodyText confidence="0.73811125">
Tree
transformation TRANSLATOR
table
( and =i-)
</bodyText>
<note confidence="0.375894666666667">
r/01••■■•■■•=1■11■ITINII■MA■•
Oilw E Ll I PARSERIMbt(w)----41TREI —41ImT(t(w)) —01 FRONTIER 1—tu E L
ell••••■ •■••••1 ,ffill■••• OIMIN■ 0■111•Int WINOINIO ••••••■•■• 4MPONIMP ••••••• aIMMI■ MOMME.1
</note>
<figureCaption confidence="0.995513">
Figure 1. Translator generator and translator.
</figureCaption>
<note confidence="0.232839">
26
The importance of the argument that the function defined by the PROCEDURE
Is a translation, is just that w and u are guaranteed to have the same
</note>
<tableCaption confidence="0.2326763">
meaning. if they are unambiguous, and if they are ambiguous, w and u are
guaranteed to have meanings in common -- i.e., that u is a bona fide
translation of w, in the ordinary sense of the word
The usefulness of such a method of translating is that the generator,
which has to consider all issues of syntax and semantics, and therefore
runs very slowly, need only run once. The translator which it produces
should run very fast, since, other than parsing, it bhly has to transform
trees according to the finite set of rules in the tree transformation
table (the function T). No semaneS computing is required at translate
time.
</tableCaption>
<table confidence="0.673527571428571">
27
4. Sample Translations.
This section presents some examples of translations on context free
languages. The tree search procedure outlined in Section 3 is programmed
in CPS and runs on the IBM S/370/165 at Ohio State. All of these trans-
lations were &amp;quot;found&amp;quot; by the program. Infix:
TRANSLATION I (Postfix to Precedence Infix)
Postfix:
G1: jl: G2: lc:
Grammar Rules Semantic Rules Grammar Rules Semantic Rules
S + SSO x3(I1&apos;x2) E + EOT x2(x1&apos;x3)
S ÷ A 1(x1) E + T 1(x1)
S + B 1(x1) T + TXF x2(x1,x3)
S + C 1(x1) T + F 1(x1)
</table>
<equation confidence="0.921469583333333">
0 + + l(x) F + (E) 1(x2)
0 + - l(x) F + A 1(x1)
0 + * l(x1) F + B 1(x1)
0 + / 1(x1) F + C 1(x1)
0 + + 1(x1)
0 4 - l(x1)
X + * 1(x1)
X + /
Universe of discourse
U1 = U2 =RUF
R = real numbers = {R1, R2&apos; R3&apos; ...}
F = {ft f-, f , f
</equation>
<page confidence="0.452415">
28
</page>
<bodyText confidence="0.763069">
Meaning function assigning atomic morphemes to lexicaL items and
syntactic variables:
</bodyText>
<equation confidence="0.932773086956522">
p1(A) = R1 p2(A) = R
1
Pl(B) = R2 1/2(B) = R2
p1 (C) = R3 112(C) = R3
(+) = f+
11)(+) f+
1
1
= f P2(*) = f
P (*)
1
(/) = f/ U2(/) = f/
1
112(()
p1(0) = F = 0
1-12 0
p1(S) = R =
112(X) = {f* ,f/ }
p2(0) = ff+,f-1
u2(F) =
2(T) = R
u2(E) = R
A1 = A2 = {1}, and F1 = F2 contains just the definition: 1: N N: 1(x) = x.
</equation>
<bodyText confidence="0.8500365">
The reader should be able to figure out, after reading the definition in
Section 1, that N1=442. = {R, R1, R2, R32 F2 f+f,f,f/}and
</bodyText>
<figure confidence="0.945170304347826">
x = x- = U, ) xl, X29,X3}0
-2
A number of finite specifications for tramlations are possible. One is:
•
EOT
-FII
=
Is S 0
E (1) , 10020
A
Ill
+AN
( E )
;
( , //05K =/
I ( I , 0100020 ;
S S i ) T
ANN■
* T X
I I
A
\( E )
, 0100020\
</figure>
<bodyText confidence="0.9699065">
It is interesting to note that the PROCEDURE does not have to know how
to coTpute the functions f+, f-, f*, and f in order to discover this
translation. All that is needed is to assume that if a symbol appears
in both semantics, it represents the same semantic entity in each,
whatever that entity is. For emample, consider the two trees in the
translation involving &amp;quot;+&amp;quot;. Let t = S&lt;SSO&lt;+&gt;&gt;, and t&apos; = E&lt;E0&lt;+&gt;T&lt;F&lt;(E)&gt;&gt;&gt;.
All we need to know is that cP(t) E ge),., and it turns out we can find
+
that out without computing f :
4(t)(P1(S),111(S),111(+))
= 0(S&lt;SS0&lt;+&gt;&gt;)(111(S),p1(S),111(+1)
=
=
rs+sso(1(Pi(s))g
= rS4550(P1(s),111(s),P1(+))
= r5-4.5S0(R, R, f)
= f+(R, R)
Similarly, cp(C)(p2(E),112(+),p2(0,p2(E),p2())) = f+(R, R), so we know
that, 4)(t) = ge).
Consider now the translation of ABC+*. The following shows that 30
</bodyText>
<figure confidence="0.983207055555555">
7F(ABC+*) = A*(B+(C)):
1---&apos;11 .1 1
*
I I 1 + I + F
FA IA\
(1 )
Fl
B i
F
I
C
B
I
IT 1
--
..---&amp;quot;...±4%•,..0
....••••°.°N■.. //.1
I I A\ f 1 A.
T X F
1 f1AN1fl I F * ( E )
F
1 ( f )
A AN
E 0 I
Fi
i I
I TA +
I h
A (E )
IB 1
H
Ti IA I ) I, T
Fl I
C F F
I l
C
</figure>
<page confidence="0.644341">
31
</page>
<sectionHeader confidence="0.536347" genericHeader="method">
TRANSLATION II (Explicit * to implicit *)
</sectionHeader>
<bodyText confidence="0.675383">
This translation is interesring because it shows the procedure has
the ability to &amp;quot;discover&amp;quot; that a word (*) in L(G1) has no translation.
But it can find a phrase form involving that word which can be translated
to a phrase form in L(G2).
</bodyText>
<figure confidence="0.973998825">
*
*
Implicit
G2: 42:
S 4 SS f*(X19X2)
S 4 A 1(x1)
S 10(1)
Explicit
G1:
E EOE
E ÷ A
E B
O+*
pI(A) = R
p1(B) = R
1(*) = f*
p1 (E) = R
p1(0) = f*
The translation is given by:
•
T(E) = S
E =(S , 0)
A A
Ul = U2 = R U {f*}
p2(A) = R
pB) = R
p2(S) = R
0) =V
, 13)
(f: 0 ((A
T(A*B*A) = ABA:
fi)
A*
A*MAN
SOS
III
B * A
BA B A
TRANSLATION III (2, + to 1, +) 32
L(G1) is the language of all addition expressions with 2, i.e., the
</figure>
<tableCaption confidence="0.6435924">
set of all strings of the form 2 + 2 + + 2. L(G2) is the set of all
strings of the form 1 + 1 + + 1. Under a standard semantics, L(G1)
expresses the even integers and L(G2) the integers. The procedure
&amp;quot;discovers&amp;quot; that the word &amp;quot;2&amp;quot; in L(C1) must be translated as the phrase
&amp;quot;1 + 1&amp;quot; in L(G2)
</tableCaption>
<figure confidence="0.836445166666667">
G2:
S 1+S
S + 2 1
Ul = U2 = N U (f+1
N = positive integers = {1, 2, ...}
p (2) = 2 p2(1) = 1
1
u (-0 = = f
f+ +
1 112(+)
p (S) = N p2(S) = N
1
Al = 2 = {14 f+}
F1 = F2&apos; which coitains the following definition
f x er
0) f(0y) = y
1) f+() = (f+(x, y))&apos; (I is the suc-
cessor fn,)
1:N N (identity): i(x) = x
The translation is specified by:
T(S) = S
Is)
(
1 +
</figure>
<page confidence="0.264597">
1
</page>
<bodyText confidence="0.643593">
= , 00003
</bodyText>
<sectionHeader confidence="0.300438" genericHeader="method">
000) T /4\
2 + S:) 1+S/
</sectionHeader>
<page confidence="0.6944515">
1
33
</page>
<bodyText confidence="0.98692859375">
Note that to &amp;quot;discover&amp;quot; this translation, the procedure must be able to
compute the function f+, since it needs to know that 2 = 1+1. Consider,
fot example, 0(S&lt;2&gt;)(1i1(2)) = r5÷2(pi(2)) = 1(2) = 2, but
0 (S &lt;1+S &lt;1&gt;&gt;) (p2 (1) , p (+) , p2 (1)) =
=
r51+S(1(1)0(e),1(1)) = f+(1,1) = 2. To get the last step in the
evaluation of the second semantic function, the procedure must be able to
compute f+(1,1).
TRANSLATION IV (1,+ to 2,+)
Suppose the procedure were asked to translate from L(G2) to L(G) in
the previous example -- i.e., from the integers to the even integers. It
would never halt, but it would &amp;quot;discover&amp;quot; that the phrase &amp;quot;1 + 1&amp;quot; is to be
translated as the word &amp;quot;2&amp;quot;, &amp;quot;1 + 1 + 1 + 1&amp;quot; as &amp;quot;2 2&amp;quot;, etc. It wodld
define a translation which is total on the strings in L(G2) whose values
are even, and it would continue to look forever for possible translations
for the odd-valued strings. We leave it as an exercise for the reader to
give the functions and which define this partial translation.
5. Conclusion and Further Research.
At the present time what is needed more than anything else in the area
of language translation is an understanding of the formal nature of
semantics, its relation to syntax in language description, and its role
in translation. I believe this paper provides some of the basis for that
understanding. Incidentally, the reader might have observed that the
definition of phrase-structure semantics in Section 1 provides for
solutions to the semantic projection problem (cf Katz and Fodor (1964), and
Langendoen (1969)).
The reader is certainly aware by now, if not before, that thee are
many grammars and semantics for a given language. After having played
with writing grammars and semantics for simple languages for quite a while
now, I believe that, for most languages at least, there are &amp;quot;better&amp;quot;
grammars and semantics and &amp;quot;worse&amp;quot; ones. Some just seem to be more
elegant or simple, or &amp;quot;natural&amp;quot; than others, for a given language. But I
</bodyText>
<page confidence="0.374863">
34
</page>
<bodyText confidence="0.978060971014493">
can&apos;t say much of a specific nature about what it means for a grammar and
semantics to be &amp;quot;elegant&amp;quot;, &amp;quot;simple&amp;quot;, or &amp;quot;natural&amp;quot;. It seems that some
study ih this area might give us insight into certain skills for making it
easier to write linguistic descriptions suitable for translation.
One phenomenon this model explains is why it is so difficult to
compute an inverse translation and get anything like the original. That
is, if one starts with sentence Nf in L1 and translates to w in L2&apos; then
translates w&apos; to w&amp;quot; back in L1, one would like for.w and w&amp;quot; to have the
same meaning. But the scuttlebutt says it isn&apos;t so, and this model shows
L,
why. Note that all that is required for T: LI ÷ 2 &apos; to be a translation
is that if w&apos; is a transIltion of w, then yi(w) n &amp;quot;12(w&apos;) 0, i.e., that
the source sentence and its translation have some common meaning. Now
suppose TT:L2 2 1 is also a translation and that w&amp;quot; E T&apos;(w&apos;). Then we
have p1(w) n P2 (W) 0 0 and id2(wI!) n p1(w&amp;quot;) 0 0, but Lt does not follow
that p1(w) n1(w&amp;quot;) o 0. In older to get back to the original meaning,
each translator must produce the entire set T(w), rather than just some
sentence in T(w), and then all of these must be retranslated in entirety.
Translation programs don&apos;t usually do that. Neither do human translators,
for that matter! Alternatively, the translator should bt able to give with
the translation, its parse and the atomic morphemes associated with the
sentence. The procedure in this paper provides for doing that.
The same definition of translation, if it is accurate, also explains
another phenomenon of language translation -- how it is that two very
differEnt translations can coi.le from the same source. If le and w&amp;quot; are
translations or w, then we have p1(w) n u2(e) 0 0 and PIM &apos;n 1-12(W&amp;quot;) # 0,
but it does not follow that P2(7&apos;) n 112(3.7&amp;quot;) 0 0.
For natural language, one would like to0&apos;exte i the theory in this
paper to arbitrary phrase structure grammars and to transformational
grammars. The exLension to transformational grammars requires only
The &amp;quot;lore&amp;quot; has it that someone fed. the following sentence to a
translator from LI to L2:
&amp;quot;The spirit indeed is willing, but the flesh is weak.&amp;quot;
Then he took the translation and fed it into a translator from L2 to
L1, and got:
&amp;quot;The liquor is all right, but the meat is spoiled.&amp;quot;
35
formalizing the notion of the transform pf a semantic function to be
associated with each syntax transformation. (For transformational semantic
theories which do not allow semantic change in the transformations, the
extension to arbitrary phrase structure grammars is sufficient, of course.)
The extension to arbitrary phrase structure grammars requires first a
formal sfatement of the &amp;quot;phrase structures&amp;quot; of unrestricted grammars,
since these structures are not trees. The author&apos;s forthcoming paper,
listed in the bibliography, covers the subject of the syntactic structures
for unrestricted languages in detail.
There are, of course, schemes for translation other than the one
described in this paper. One might think of computing the meaning of a
source sentence, and then having some effective way of generating the
target sentence directly from the meaning. The scheme in this paper,
however, is more attractive at present than such a &amp;quot;direct&amp;quot; scheme, for
three reasons: 1) It is intuitively satisfying. I believe I translate
by first translating simple phrases and then putting their separate
translations together according to some restructuring rules that are
guaranteed to preserve semantics. Thus, one &amp;quot;builds up&amp;quot; the translation
of a sentence recursively. I am more likely to call the result which I
get by first computing the whole meaning and then producing a sentence
(often it is a sequence of sentences) with the same meaning, a &amp;quot;paraphrase&amp;quot;
or an &amp;quot;interpretation&amp;quot;, rather than a &amp;quot;translation&amp;quot;. 2) If used much,
this scheme is likely to be more efficient than the &amp;quot;direct&amp;quot; scheme, since
no.semantic computation is required at translate time. Pal the semantic
problems are examined once and for all in the translator generator; at
translation time, only a sequence of tree mappings is performed -- simply
a structure matching and replacing technique. 3) The &amp;quot;direct&amp;quot; scheme
requires knowing how to specify linguistic descriptions in such a way that,
given a meaning in semantic notation, one can produce a sentence having
that meaning. This problem Is a diffidult one not yet well understood.
Presumably, the research currently under way in the field of generative
semantics will explicate the issues involved.
</bodyText>
<sectionHeader confidence="0.323613" genericHeader="method">
36
</sectionHeader>
<reference confidence="0.984269464285714">
Selected Bibliography.
Benson, D. B. (1970). Syntax and semantics: a categorial view. In
Information and Control, 16, pp. 738-773.
Benson, D. B. (forthcoming) Semantic preserving translations.
Brooks, F. P., Jr., and Iverson, K. E. (1969). Automatic Data Processing.
New York: Wiley.
ButtOlmann, H. W. (forthcoming). On the syntactic structures of unre-
stricted grammar. In Information and Control.
Katz, J., and Fodor, J. A. (164). The structure of a semantic theory.
In Language, 39, pp. 170-210. Reprinted in Fodor and Katz
(eds.) The Structure of Language. Englewood Cliffs, New
Jersey: Prentice-Hall, pp. 479-518.
Katz, J., and Postal, P. (1964). An Integrated Theory of Linguistic
Descriptions. Cambridge: MIT Press.
Hoperoft, J. and Ullmann, J. (1967). Formal Languages and their Relatioh
to Automata. Reading, Mass: Addison-Wesley.
Ginsburg, S. (1963). The Mathematical theory of Corftext Free .1,12EilE.
New York: McGraw-Hill.
Knuth, D. E. (19,68). Semantics Of context-free languages. In Mathe-
maOtal Systems Theory, 2, pp. 127-146.
. (1971). Examples of formal semantics. Symposium on
lemantics of Algorithmic Languages. Engelor, ed. Lecture Notes
in Math #188. New York: Springer-Varlag, pp. 212-235
Langendoen, D. T. (1969). The Study of Syntax. New York: Holt, Rine-
hart and Windton.
Tarski, A. (1936). per Wallrheitsbergriff in den formalasierten Sprachen.
In Studia Philosophica, I, pp. 261-304. Originally published
in 1933.
</reference>
<figure confidence="0.994428571428571">
IL°
11111 &amp;quot;
114
2.2
2.0
1.8
11111-1 25 111 I .6
</figure>
<sectionHeader confidence="0.7399255" genericHeader="method">
MICROCOPY RESOLUTION TEST CHART
N.ATIONAL BUREAU OF STANDARDS 1963 A
</sectionHeader>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.220926">
<note confidence="0.900338">Journal of Computational Linguistics 7</note>
<title confidence="0.985225333333333">SEMANTIC DIRECTED TRANSLATION OF CONTEXT FREE LANGUAGES</title>
<author confidence="0.999456">H William Buttelmann</author>
<affiliation confidence="0.998599">Ohio State University</affiliation>
<note confidence="0.6437315">Copyright 1974 by the Association for Computational Linguistics 2</note>
<abstract confidence="0.9994292">A formal definition for the semantics of a context free language, a semantics,is given. The definition is a model of the notion that it is phrases which have meaning and that the meaning of a phrase is a function of its syntactic structure and of the meanings of its constituents. Next we give a definition for translation on context free languages. We then study a certain kind of translation on cfl&apos;s, which proceeds by translating on the phrase trees of the languages, and is specified by a finite set of tree-replacement rules. We present a procedure which, given a cfg and phrase-structure semantics for a source language and a cfg and phrase-structure semantics for a target language, will (usually) produce the finite set of ttee-replacement rules for tne translation, if the translation exists. The procedure may be viewed as a computer program which is a translator generator, and which produces another program that is a translator.</abstract>
<note confidence="0.78332175">TABLE OF CONTENTS Title Page 1 Abstract 2 Table of Contents 3</note>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="false">
<authors>
<author>Selected Bibliography</author>
</authors>
<marker>Bibliography, </marker>
<rawString>Selected Bibliography.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D B Benson</author>
</authors>
<title>Syntax and semantics: a categorial view.</title>
<date>1970</date>
<journal>In Information and Control,</journal>
<volume>16</volume>
<pages>738--773</pages>
<contexts>
<context position="5290" citStr="Benson (1970)" startWordPosition="855" endWordPosition="856">ase is a function of its syntactic structure and of the meanings of its constituonts. Keeping in mind that a function is nothing but an assignment of elements in its codomain to elements in its domain, this definition will provide for idiomatic and emotive meaning, as well as denotative or referential meaning, provided such meanings are specified in the universe of discourse. I wish to add before giving the definition that, although I have never seen it in this form before, I do not believe this definition of semantics is original with me. I believe it incorporates the notions of semantics in Benson (1970), Knuth (1968, 1971), some statements attributed to Thompson (et Benson, 1970), and in. Tarski (1936). Now the definition: 6 Definition 1. Let .G = (V, E, P, S) be a context free grammar where: ✓ is the finite nonempty vocabulary, E C V is the terminal alphabet, S E CV - E) is the axiom, and P is the finite nonempty set of grammar rules, having the form A 0, for A E CV - E) and a E V+. A phrase-structure semantics for G is a 7-tuple (U, M, p, X, A, F, R), where: U is a set, the universe of discourse, M c 2 is a finite set of atomic morphemes, p: V 2 is the vocabulary meaning function, X = {(, </context>
</contexts>
<marker>Benson, 1970</marker>
<rawString>Benson, D. B. (1970). Syntax and semantics: a categorial view. In Information and Control, 16, pp. 738-773.</rawString>
</citation>
<citation valid="false">
<authors>
<author>D B Benson</author>
</authors>
<title>(forthcoming) Semantic preserving translations.</title>
<marker>Benson, </marker>
<rawString>Benson, D. B. (forthcoming) Semantic preserving translations.</rawString>
</citation>
<citation valid="true">
<authors>
<author>F P Brooks</author>
<author>K E Iverson</author>
</authors>
<title>Automatic Data Processing.</title>
<date>1969</date>
<publisher>Wiley.</publisher>
<location>New York:</location>
<contexts>
<context position="31585" citStr="Brooks and Iverson (1969)" startWordPosition="6069" endWordPosition="6072">for i = 1,...,n let yl = gt1)(112(xqc 4.1),...1112(w;c. )). Then, if we i-1 define Jo = ko = 0, the result above demonstrates that 25 if xi 0, trx4 YT p2(fr(t;)i) if xi = O. Thus, by the definlpion of T in search, gt)(111(w1),...yul(wm)) = (t0Y(Y1,...,Ym) = (e)(571,...,y12 = 4)(t&apos;)02(w1),...,u2N)), or (PM E (1)(t&apos;). Thus T is a translation. Finally, as we showed in Section 2, since T is a translation OM the. syntax trees), T is a translation (on the languages). In programming terminology a ,generator is a program whose input is a set of parameters and whose output is a specialized program (cf Brooks and Iverson (1969), p. 365). Then PROCEDURE constitutes a &amp;quot;translator generator&amp;quot;: its input is two cfg&apos;s and their associated phrase structure semantics, and its output is a table of tree transformations which &amp;quot;drives&amp;quot; a standard tree-mapping program. The tree mapping program is designed to be part of a translator system composed of a parser, the tree mapper, and a frontier stripper (see Figure 1). Translation proceeds as follows: Let G1 and qg1 be the cfg and semantics for the source language Ll&apos; and G2 and j 2 the cfg and semantics for the target language L7. The translator is given a sentence w imLi. The par</context>
</contexts>
<marker>Brooks, Iverson, 1969</marker>
<rawString>Brooks, F. P., Jr., and Iverson, K. E. (1969). Automatic Data Processing. New York: Wiley.</rawString>
</citation>
<citation valid="false">
<authors>
<author>H W ButtOlmann</author>
</authors>
<title>On the syntactic structures of unrestricted grammar.</title>
<booktitle>In Information and Control.</booktitle>
<marker>ButtOlmann, </marker>
<rawString>ButtOlmann, H. W. (forthcoming). On the syntactic structures of unrestricted grammar. In Information and Control.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Katz</author>
<author>J A Fodor</author>
</authors>
<title>The structure of a semantic theory.</title>
<date></date>
<journal>In Language,</journal>
<booktitle>The Structure of Language. Englewood Cliffs,</booktitle>
<volume>39</volume>
<pages>170--210</pages>
<editor>Fodor and Katz (eds.)</editor>
<publisher>Prentice-Hall,</publisher>
<location>New Jersey:</location>
<note>Reprinted in</note>
<marker>Katz, Fodor, </marker>
<rawString>Katz, J., and Fodor, J. A. (164). The structure of a semantic theory. In Language, 39, pp. 170-210. Reprinted in Fodor and Katz (eds.) The Structure of Language. Englewood Cliffs, New Jersey: Prentice-Hall, pp. 479-518.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Katz</author>
<author>P Postal</author>
</authors>
<title>An Integrated Theory of Linguistic Descriptions.</title>
<date>1964</date>
<publisher>MIT Press.</publisher>
<location>Cambridge:</location>
<marker>Katz, Postal, 1964</marker>
<rawString>Katz, J., and Postal, P. (1964). An Integrated Theory of Linguistic Descriptions. Cambridge: MIT Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Hoperoft</author>
<author>J Ullmann</author>
</authors>
<title>Formal Languages and their Relatioh to Automata.</title>
<date>1967</date>
<publisher>Addison-Wesley.</publisher>
<location>Reading, Mass:</location>
<marker>Hoperoft, Ullmann, 1967</marker>
<rawString>Hoperoft, J. and Ullmann, J. (1967). Formal Languages and their Relatioh to Automata. Reading, Mass: Addison-Wesley.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S Ginsburg</author>
</authors>
<date>1963</date>
<booktitle>The Mathematical theory of Corftext Free .1,12EilE.</booktitle>
<publisher>McGraw-Hill.</publisher>
<location>New York:</location>
<marker>Ginsburg, 1963</marker>
<rawString>Ginsburg, S. (1963). The Mathematical theory of Corftext Free .1,12EilE. New York: McGraw-Hill.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D E Knuth</author>
</authors>
<title>Semantics Of context-free languages.</title>
<date></date>
<booktitle>In MathemaOtal Systems Theory,</booktitle>
<volume>2</volume>
<pages>127--146</pages>
<marker>Knuth, </marker>
<rawString>Knuth, D. E. (19,68). Semantics Of context-free languages. In MathemaOtal Systems Theory, 2, pp. 127-146.</rawString>
</citation>
<citation valid="true">
<title>Examples of formal semantics.</title>
<date>1971</date>
<booktitle>Symposium on lemantics of Algorithmic Languages. Engelor, ed. Lecture Notes in Math #188.</booktitle>
<pages>212--235</pages>
<publisher>Springer-Varlag,</publisher>
<location>New York:</location>
<contexts>
<context position="5310" citStr="(1968, 1971)" startWordPosition="858" endWordPosition="859">its syntactic structure and of the meanings of its constituonts. Keeping in mind that a function is nothing but an assignment of elements in its codomain to elements in its domain, this definition will provide for idiomatic and emotive meaning, as well as denotative or referential meaning, provided such meanings are specified in the universe of discourse. I wish to add before giving the definition that, although I have never seen it in this form before, I do not believe this definition of semantics is original with me. I believe it incorporates the notions of semantics in Benson (1970), Knuth (1968, 1971), some statements attributed to Thompson (et Benson, 1970), and in. Tarski (1936). Now the definition: 6 Definition 1. Let .G = (V, E, P, S) be a context free grammar where: ✓ is the finite nonempty vocabulary, E C V is the terminal alphabet, S E CV - E) is the axiom, and P is the finite nonempty set of grammar rules, having the form A 0, for A E CV - E) and a E V+. A phrase-structure semantics for G is a 7-tuple (U, M, p, X, A, F, R), where: U is a set, the universe of discourse, M c 2 is a finite set of atomic morphemes, p: V 2 is the vocabulary meaning function, X = {(, ), „ xl, x2, ..., fo</context>
</contexts>
<marker>1971</marker>
<rawString>. (1971). Examples of formal semantics. Symposium on lemantics of Algorithmic Languages. Engelor, ed. Lecture Notes in Math #188. New York: Springer-Varlag, pp. 212-235</rawString>
</citation>
<citation valid="true">
<authors>
<author>D T Langendoen</author>
</authors>
<title>The Study of Syntax.</title>
<date>1969</date>
<location>New York: Holt, Rinehart</location>
<contexts>
<context position="39146" citStr="Langendoen (1969)" startWordPosition="7606" endWordPosition="7607">er to give the functions and which define this partial translation. 5. Conclusion and Further Research. At the present time what is needed more than anything else in the area of language translation is an understanding of the formal nature of semantics, its relation to syntax in language description, and its role in translation. I believe this paper provides some of the basis for that understanding. Incidentally, the reader might have observed that the definition of phrase-structure semantics in Section 1 provides for solutions to the semantic projection problem (cf Katz and Fodor (1964), and Langendoen (1969)). The reader is certainly aware by now, if not before, that thee are many grammars and semantics for a given language. After having played with writing grammars and semantics for simple languages for quite a while now, I believe that, for most languages at least, there are &amp;quot;better&amp;quot; grammars and semantics and &amp;quot;worse&amp;quot; ones. Some just seem to be more elegant or simple, or &amp;quot;natural&amp;quot; than others, for a given language. But I 34 can&apos;t say much of a specific nature about what it means for a grammar and semantics to be &amp;quot;elegant&amp;quot;, &amp;quot;simple&amp;quot;, or &amp;quot;natural&amp;quot;. It seems that some study ih this area might give</context>
</contexts>
<marker>Langendoen, 1969</marker>
<rawString>Langendoen, D. T. (1969). The Study of Syntax. New York: Holt, Rinehart and Windton.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Tarski</author>
</authors>
<title>per Wallrheitsbergriff in den formalasierten Sprachen.</title>
<date>1936</date>
<booktitle>In Studia Philosophica, I,</booktitle>
<pages>261--304</pages>
<note>Originally published in</note>
<contexts>
<context position="5391" citStr="Tarski (1936)" startWordPosition="870" endWordPosition="871"> that a function is nothing but an assignment of elements in its codomain to elements in its domain, this definition will provide for idiomatic and emotive meaning, as well as denotative or referential meaning, provided such meanings are specified in the universe of discourse. I wish to add before giving the definition that, although I have never seen it in this form before, I do not believe this definition of semantics is original with me. I believe it incorporates the notions of semantics in Benson (1970), Knuth (1968, 1971), some statements attributed to Thompson (et Benson, 1970), and in. Tarski (1936). Now the definition: 6 Definition 1. Let .G = (V, E, P, S) be a context free grammar where: ✓ is the finite nonempty vocabulary, E C V is the terminal alphabet, S E CV - E) is the axiom, and P is the finite nonempty set of grammar rules, having the form A 0, for A E CV - E) and a E V+. A phrase-structure semantics for G is a 7-tuple (U, M, p, X, A, F, R), where: U is a set, the universe of discourse, M c 2 is a finite set of atomic morphemes, p: V 2 is the vocabulary meaning function, X = {(, ), „ xl, x2, ..., for some integer n, A is a finite set of ndmes of partial recursive functions, F is</context>
</contexts>
<marker>Tarski, 1936</marker>
<rawString>Tarski, A. (1936). per Wallrheitsbergriff in den formalasierten Sprachen. In Studia Philosophica, I, pp. 261-304. Originally published in 1933.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>