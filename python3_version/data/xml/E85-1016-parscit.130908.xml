<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000003">
<note confidence="0.591392333333333">
PARAMETRIZED ABSTRACT OBJECTS
FOR LINGUISTIC INFORMATION PROCESSING
Helene Bestougeff, Gerard Ligozat
</note>
<sectionHeader confidence="0.522823666666667" genericHeader="abstract">
CNRS-Universite Paris VII
2,Place Jussieu 75005 PARIS FRANCE
ABSTRACT
</sectionHeader>
<bodyText confidence="0.995964088235294">
Programming languages which have
adequate primitives for linguistic
information processing and a clear
semantics at the formal computational
level are now slowly emerging as a
convergent effort from computer science,
linguistics, and artificial intelligence.
Our work on the processing of a special
kind of linguistic information, namely
temporal information ,has led us to
advocate the use of a language with the
following characteristic features:
- high level of abstraction;
- capacity for inference;
- modularity.
A high level of abstraction is needed
to deal with complex linguistic notions
which are not easily reducible to
elementary data structures.
A capacity for inference is required,
as most criteria or tests in linguistics
make use of particular kinds of
deductions, at different levels of the
linguistic analysis.
As for modularity, a typical situation
in linguistics has to do with a hierarchy
of concepts or units, and the relations
between those units at different levels.
This paper discusses the relevance of
the choice of parametrized abstract
objects as tools for linguistic
information processing and exemplifies
the use of such objects for temporal
information.
</bodyText>
<sectionHeader confidence="0.998664" genericHeader="introduction">
INTRODUCTION
</sectionHeader>
<bodyText confidence="0.99707225">
In computational linguistics, more
than often there is a tendency to
directly implement a model without really
going through a specification step which
would provide a correct abstraction of
the implementation. This attitude has at
least two drawbacks: Firstly, there is no
formal way of comparing two models; this
can lead to some pointless discussions
between different approaches which, at
an abstract level, can be shown to be
equivalent; secondly, any extension or
modification of the implemented model
requires a different program instead of
a mere adjustment at the abstract level
which should facilitate the modular
updating of the implementation and allow
a formal comparison between the old and
the new model.
Our work on tense -and time has
convinced us that, especially in
linguistic domains where models are
either loose or controversial, a
systematic approach to linguistic
information processing allowing
compatible constructions at all levels is
highly desirable. We therefore advocate
the use of a language with the following
features:
- high level of abstraction;
- capacity for inference;
- modularity.
This paper is in two parts. In the
first part, we try to justify our choice
of abstract parametrized objects as
adequate tools for linguistic information
processing; in the second part we
exemplify our approach by giving a
detailed account of the way we define and
construct temporal objects.
</bodyText>
<sectionHeader confidence="0.98575" genericHeader="method">
PARAMETRIZED ABSTRACT OBJECTS
</sectionHeader>
<bodyText confidence="0.9831598">
One of the basic difficulties in
natural language processing arises from
the fact that modularity is both a
desirable and hardly attainable property
of the systems. At first it seems quite
reasonable to break the programs into
manageable, modular sub-programs,
especially as the linguistic data, at
least at first approximation,lend
themselves to a clear-cut classification
in terms of morphology, syntax, semantics
and pragmatics. Moreover, comparatively
sophisticated techniques and methods are
already available in each subfield.
Unfortunately, it has now become
</bodyText>
<page confidence="0.997982">
107
</page>
<bodyText confidence="0.982935433070866">
commonplace knowledge that this strategy
of developing separate modules for each
sub-problem and integrating them smoothly
is not satisfactory: the operations of
parsing sentences, producing internal
representations, reasoning about them,
answering questions, generating text, and
so on, are strongly interdependent. The
degree, order and location of the
interactions between different parts may
vary significantly, according to
individual situations.
A consequence of the realization of
this fact has been the development of
strongly integrated, usually procedural
systems, where the individual sub-
programs operate simultaneously on
several deeply intricated linguistic
levels . The price one has to pay for a
relative success of this approach is in
terms of understandability and
generalization: many systems are strongly
dependent on the particular type of
problem they have been programmed to
solve, and possible extensions or
transpooitions would require fundamental
modifications.
What kind of software tools would
allow at the same time modularity and
multi-faceted, polymorphic and concurrent
interactions between processes ?
Modularity and complex interactions are
characteristic features of the object
oriented paradigm .
Modularity is provided by the
structuration in terms of objects.
Complex interaction is a consequence of
the distribution of the control between
te different objects and of the
(possibly multiple) inheritance
facilities between hierarchically
dependent objects. The possibility of
using different points of views for the
same objects is a consequence of this
structuration.
This approach leads to focussing on
the basic process of abstraction. In
this context, abstraction is a process
which, starting from a description of the
data, yields an abstract specification.
This involves three steps.
- define the relevant objects for the
problem under study;
- define the possible functions and
relations on the objects;
-give explicitly the constraints
between the functions and relations.
The object-oriented approach is
usually equated with the Smalltalk
&amp;quot;vision&amp;quot; ( Goldberg and Robson, 1983 ),
while other views of objects are rejected
as being irrelevant or even self
contradictory.
Smalltalk objects can be characterized
by the following properties:
- Each object is an instance of a class
(a generic object).
- Each object has a local memory which
can only be updated by functions (or
procedures) local to the object.
- Objects are organized into a tree-like
hierarchy implying tree-like inheritance.
- Communication between objects is
organized through message passing.
However ,it has been argued that the
object oriented approach can be
fruitfully carried over into applicative
language contexts (Steels ,1982) or into
particular systems based on logic where
the fundamental mechanism is data
abstraction (Goguen et al. 1983).
As regards Smalltalk, it does not
provide systematic facilities for
defining abstract data types; all
computations are highly dependent on side
effects (assignment is systematically
used in local operations) and there is no
explicit typing.
We favour the approach exemplified by
such languages as OBJ and their possible
extensions (Goguen and Meseguer, 1984),
as we think that they will allow ,in the
long range, a more efficient programming
style and make the systematic proof of
programs possible.
The OBJ language is based upon data
abstraction: an object is a type (i.e. a
domain of values with functions accessing
those values); objects are organized into
a hierarchy an acyclic graph)
representing the dependencies among
types. Computations are performed by
using equational axioms as oriented
rewrite rules.
Therefore , granted the availability
of a theorem prover , the consistency of
the specifications given in the abstract
data type can be formally checked. More-
over , since the objects have a clear
mathematical definition, all the
techniques of abstract algebra are also
available.
More generally, axioms could be given
not only as equations , but also as
formulas in a logical theory (such as
first order predicate calculus or
temporal logics) assuming those theories
satisfy some given restrictions ( Goguen
and Burstall, 1984).
As we have no access yet to any
version of OBJ, we have decided , in a
first stage, to restrict the object
structure to its free component, i.e.
only the signatures, not the axioms are
defined. Therefore-, the computations have
to be explicitely coded. As a
consequence, no checking of consistency
</bodyText>
<page confidence="0.99849">
108
</page>
<bodyText confidence="0.998774">
is possible for the time being.
The actual implementation is done in
the ML language (Gordon et al., 1979).
ML is a functional language which is
fully higher-order. &amp;quot;It has a polymorphic
type discipline which combines the
flexibility of programming in a typeless
language with the security of compile-
time type checking&amp;quot;. Moreover, one can
define one&apos;s own types , which may be
abstract and/or recursive.
To give a flavour of the ML
programming style, consider a possible
definition of the abstract recursive type
of binary trees, with tip values of
an arbitrary type (denoted by *) and non
tip nodes of some other arbitrary type
(denoted by **). (This exemple is taken
from Gordon et al., 1979):
</bodyText>
<equation confidence="0.668433">
absrectype (*,**) tree =
* + ** # (*,**)tree # (*,**)tree
</equation>
<bodyText confidence="0.998113545454546">
with tiptree x = abs_tree (ml x)
and comptree (y,t1,t2) =
abs_trce (inr (y,t1,t2))
and istip t =isl(rep_tree t)
and tipof t= outl(reptree t)
and labelof t = fst(outr (reptree t))
and sonof t =snd(outr(reptree t))
This type is defined as recursive and
abstract. The symbols and
respectively, denote the two type
constructors &amp;quot;disjoint sum&amp;quot; and
&amp;quot;cartesian product&amp;quot;. The functions
&amp;quot;abs_tree&amp;quot; and &amp;quot;rep_tree&amp;quot; ,both of them
of type (ty -&gt; ty), are only available
inside the definition of the abstract
type &amp;quot;tree&amp;quot; : abs_tree maps the concrete
representation of a tree unto its
abstraction; rep_tree has the converse
effect. Finally, isl, ml, inr, outl,
outr are functions or predicates on the
disjoint sum. They are defined as
follows:
</bodyText>
<construct confidence="0.9688288">
isl: (* + **) -&gt; bool
tests membership of left summand;
ml: * -&gt; (* + **)
injects into left summand;
inr: * -) (** + *)
injects into right summand;
outl: (* + **) -&gt; *
projects out left summand;
outr: (* + **) -&gt; **
projects out right summand.
</construct>
<bodyText confidence="0.89746">
The signature of this type is the set
of operators:
tiptree=-: * -&gt; (**,*)tree
comptree=-:
* # (**,*)tree # (**,*)tree -&gt;(*,**)tree
istip=-: (*,**)tree -&gt;bool
tipof=-: (*,**)tree -&gt;**
labelof=-;(*,**) tree -&gt; *
sonof=-:
(*,**)tree -&gt;((**,*)tree # (**,*) tree))
The version of ML we use (INRIA ,1984)
is written in Lisp with access to the
lisp system. So our object environment is
constructed as a collection of abstract
data types. The hierarchy between types
results from the combination and
enrichment of more basic types. This
hierarchy creates multiple inheritance
relations between types. Some examples
will be given in the context of temporal
objects.
Clearly, the management of the object
level must be done on top of ML . The
explicit coding mixes Lisp and ML.
As we work in a functional environment
there is no &amp;quot;local memory&amp;quot;.However, this
is , to our viewpoint, a minor drawback
compared to the advantage of the
abstraction facilities.
In a next stage, we intend to introduce
the necessary axioms and perform the
computations in a deductive style.
This approach can be used for the
formal representation of natural
language, or as a grammar formalism . In
particular the syntactical and semantical
analysis can be done in terms of objects.
(De Boissieu and Forest , 1985).
</bodyText>
<sectionHeader confidence="0.938986" genericHeader="method">
PROCESSING TEMPORAL INFORMATION
</sectionHeader>
<bodyText confidence="0.98615">
Tense and time representation in natural
languages is generally studied under
one of the three main disciplines :
logics, linguistics, and artificial
intelligence. A brief overview of these
different viewpoints is given in
(Bestougeff an Ligozat, 1984).
The main problem is to choose the
relevant objects in order to get an
adequate abstraction. It must be strongly
emphasized that we deny ourselves the
right to assume any particular physical
representation of time from the outset.
The concrete properties result from the
specifications.
The choice of the basic objects is
somehow arbitrary, but it should
nevertheless comply to the following
rules :the objects must be
- close to linguistic intuition.
- general enough to be reusable as
such in different contexts, or give rise
to new objects by enrichment or
inheritance.
The second point is required to avoid
</bodyText>
<page confidence="0.99578">
109
</page>
<bodyText confidence="0.997441111111111">
ad-hoc and independant specifications. To
wthieve these goals it may be necessary
to define primitive objects, which do not
have any lingustic interpretation but are
merely building blocks whose use enhances
modularity .
In this case ,the lower level objects can
be hidden to the user .
Keeping this in mind ,we can now
proceed to the description of the
linguistic motivations which are behind
the construction of temporal objects .
The idea is to give a systematic way of
representing temporal information by
defining abstract structures based upon
the concepts and the hypotheses of a
particular linguistic theory.
The linguistic theory we rely on is
that of A. Culioli (Culioli, 1980),
suitably adapted to computational
purposes.
Temporal information can be informally
characterized as information pertaining
to the location and &amp;quot;shape&amp;quot; of the states
and events described by natural language.
In particular, this includes what is
commonly referred to as aspect.
Furthermore, temporal information in
natural language has both a descriptive
and an operative structure: it describes
and allows the users to make systematic
inferences. Among these inferences are
those concerned with the ordering of
events, but such inferences are only part
of a whole set of inferences on the
factuality, the degree of completion, the
type of occurrence, of the situations
considered. In fact, it can be argued
that the ordering relations are not
necessarily of a primary nature.
Some examples will illustrate the
kind of data and inferences we have in
mind.
Consider the following simple
sentences:
</bodyText>
<listItem confidence="0.999649833333333">
(1) John is ill.
(2) John repairs cars.
(3) John is repairing my car.
(4) John repaired my car.
(5) John has repaired my car.
(6) John was repairing my car.
(7) My car has been repaired.
(B) My car is repaired now.
(9) John was singing.
(10) John sang.
(11) John has been singing.
(12) Cats are smart.
</listItem>
<bodyText confidence="0.995024666666667">
We wish to account for some basic
information imparted by the use of such
sentences. For example:
</bodyText>
<listItem confidence="0.96584">
- Sentence (2) does not imply (3),
neither does sentence (3) imply sentence
(2)
- Sentence (4) implies sentence (7), not
(8).
- Sentence (5) implies sentence (8).
- Sentence (6) implies neither sentence
(7) nor, a fortiori, (8), whereas
sentence (9) implies sentences (10),(11).
</listItem>
<bodyText confidence="0.999851851851852">
The different uses of the simple
present tense in (1) and (2) are related
to a difference between the semantic
types of the verbs to be ill and to
repair. We will account for this
difference by adapting a classification
(essentially due to Vendler (1967)) into
four semantic types ( state, activity,
accomplishement, achievement ) . The
usefulness of such a classification is
further illustrated by comparing the
behaviour of the verb to repair in
sentences (6, 7, 8) with that of the verb
to sing in (9, 10, 11).
The comparison between (4) and (6) in
relation with (7) shows the necessity of
suitably representing the difference
between the simple and the progressive
past, at least for verbs of the type to
repair a car , which are classified as
accomplishments.
To represent the difference between
(4) (simple past) and (5) (present
perfect), we have to express what makes
(8), but not (4), derivable from (5).
Reichenbach&apos;s system of temporal indexes
(point of speech, point of event, point
of reference ) can be used to handle
this phenomenon (Reichenbach, 1957 ). It
provides a way of describing the notion
of &amp;quot;present relevance&amp;quot;, which is present
in (5) , but not in (4).
The contrast between (1 , 2) and (12)
points to another kind of distinction one
has to make: (1) expresses a state, (2) a
habit, which hold at the moment of
speech. On the contrary, (12) states a
general fact which is basically
undetermined with respect to the moment
of speech. Dependence on the time of
speech is a fact of temporal deixis. We
shall refer to it as enunciativity ,
(following A. Culioli) . By opposition
situations such as (12) will be termed
aoristic.
The preceding examples give some idea
of the type of information that has to be
represented. We have deliberately played
down the purely sequential type of
information, which is the only type of
temporal information most systems are
concerned with.
Moreover, the purely sequential
type of information is mostly incomplete
</bodyText>
<page confidence="0.989073">
110
</page>
<bodyText confidence="0.895377">
(this is stressed in particular by Smith
(1978)). Consider the following examples:
</bodyText>
<listItem confidence="0.95807475">
(13) John saw his doctor this morning:
he is ill.
(14) John saw his doctor this morning:
now he is ill.
</listItem>
<bodyText confidence="0.9997477">
Contrasting (13) and (14) shows a
potential indeterminacy in the relation
between the two sentences. Smith (1978)
claims that sentences like (1), where no
explicit &amp;quot;reference time&amp;quot; is provided
(e.g. by a time adverbial such as now)
are temporally incomplete. We will be
content at this point of our discussion
with noting the need for a convenient
notation for such a phenomenon.
</bodyText>
<sectionHeader confidence="0.987219" genericHeader="conclusions">
TEMPORAL OBJECTS
</sectionHeader>
<bodyText confidence="0.99900225">
We assume that temporal information
in a text can be represented by
proceeding in three steps of increasing
difficulty:
</bodyText>
<listItem confidence="0.994309333333333">
- Tense in main clauses.
- Tense in subordinate clauses.
- Tense in texts.
</listItem>
<bodyText confidence="0.997205316326531">
This hierarchy follows that of Ejerhed
and Janlert ( 1981).
To summarize the discussion of the
previous paragraph, the following
elements of temporal information have to
be abstracted:
- temporal deixis (enunciative vs.
aoristic situations) . Following Comrie
(1976), we use the term &amp;quot;situation&amp;quot; as a
generic term covering states, events or
processes .
- inception and termination of a
situation.
- information relative to the
completion of the situation.
- local inferences on situations.
- mass/count properties of situations.
In our system, these elements are
reconstructed from the following
linguistic data:
- tenses in the finite forms of verbs.
- temporal specifiers (temporal
adverbials).
-semantic types of situations
(computed from the semantic type of the
verbs A la Vendler, and the syntactic
structure of the proposition).
At this point, most existing systems
of representation make a choice, since a
notion of duration has to be included in
the model as well. Either one conceives
of the basic elements as points, and the
notion of an interval has to be
introduced; or an interval is a basic
element, and a second relation (of
overlapping or inclusion ) is introduced.
In fact, in most existing models of time,
the basic elements of time are conceived
as elements or subsets of (a subset of)
the real line (or some ramified structure
built from it).
The choice of either &amp;quot;points&amp;quot; or
&amp;quot;intervals&amp;quot; as basic elements leads to
definite advantages and particular
difficulties. The point model is
basically simpler, but in some way harder
to justify semantically. However, as
shown by Kamp ( 1979) and Van Benthem
( 1980 ), both points of views are
essentially equivalent.
Our claim in the matter follows the
general philosophy of abstraction:
Instead of the nature of the basic
elements, consider their intended
properties and combination rules for
building derived elements. This
combinatorial point of view is implicit,
for example, in Allen&apos;s model (Allen 83),
where a set of &amp;quot;intervals&amp;quot; is abstractly
characterized by the relations holding
between its elements. It can be shown
(Bestougeff and Ligozat ,1984) that any
set theoritic model of Allen&apos;s axioms is
equivalent to (a subset) of the intervals
(that is, couples of points) on a totally
ordered set.
In our model,the basic elements are
typed boundaries, with a (partial) order
defined on them. As shown in (Bestougeff
and Ligozat, 1984) an alternative way of
considering the same abstraction would be
in terms of &amp;quot;intervals&amp;quot;, where an
interval is a couple (bl, b2) of
boundaries with bl &lt;b2 . In other words,
the term &amp;quot;interval&amp;quot; has only the notions
of a beginning and an end associated with
it, and it is immaterial whether one or
the other terminology is used. No
topological properties are implied , only
combinatorial properties (in terms of the
types of boundaries ) are retained in the
abstraction. Boundary types are
introduced in the model in order to
represent aspectual properties of the
data.
As an example, consider again
sentences (1) to (12).
The state be ill in (1) holds upon an
interval whose left and right boundaries
are &amp;quot;closing&amp;quot; and &amp;quot;opening&amp;quot;,
respectively.This is a general situation
for states in an enunciative setting.
The event John repair mi car in (5),
conversely, holds upon an interval with
resp. &amp;quot;opening&amp;quot; and &amp;quot;closing&amp;quot; left and
right boundaries. Consequently, the
adjacent resulting state &amp;quot;my car is
repaired&amp;quot; holds on an interval with a
</bodyText>
<page confidence="0.997607">
111
</page>
<bodyText confidence="0.971440513513514">
&amp;quot;closing&amp;quot; left boundary, as a state
should. The combination in (5) of a verb
of accomplishment with a &amp;quot;closing&amp;quot; right
boundary insures that such a resulting
state does indeed exist. This is to be
contrasted with the situation in (6).
There, the right boundary is an &amp;quot;opening
one&amp;quot;, which prevents the inference of a
completed action from being made.
It seems that the introduction of
such typed boundaries is enough to
capture the intuition behind the use of
topological intervals in systems
representing tense and time. The approach
chosen here prevents the overloading of
the objects with unnecessary or
undesirable properties, as is the case
when a concrete model like the real line
is adopted.
In terms of implemented objects, this
corresponds to the definition of abstract
intervals from typed boundaries and
predicate information (the latter can be
empty).
As an example the explicit
definition of an interval is as follows :
abstype intv =boundary # pred# boundary
with make_intv (11,12,13)=
abs_intv (11,12,13)
and left 1 =fst (rep_intv 1)
and right 1 = sad (sad (rep_intv 1))
and getp 1 =1st (sad (rep_intv 1))
and putl (b,i)=
if fst (rep_intv i) =U
then abs_intv (b,fst(snd(rep_intv)),
snd(snd (rep_intv i)))
else i
and putr(b,i)=
if snd(snd(rep_intv i))= U
then abs_intv(fst(rep_intv i),
fst(snd(rep_intv i)),b)
else i
and show_intv 1 =rep_intv 1;;
The signature of this object is the
set of typed operators:
make_intv=-:
(boundary # pred # boundary) -&gt; intv
left=-: intv -&gt; boundary
right=-: intv -&gt; boundary
getp =-: intv -&gt; pred
putl =-: (boundaryitintv) -&gt; intv
putr =-: (boundary # intv ) -&gt; intv
show_intv
intv -&gt;(intv + (intv nseq))
It seems intuitively satisfying to
consider the stretch of time involved in
a simple clause as totally ordered. The
local inferences operate on this
restricted scope.
To abstract this phenomenon we
introduce interval sequences with
constraints on the boundary types of
adjacent intervals:
absrectype nseq = intv + int # nseq
force=-: intv -&gt; nseq
ncons=-:(intv#nseq) -&gt; nseq
make_tnseq=-:(intv # nseq) -&gt; nseq
show_nseq=-:
nseq -&gt; (intv + (intv # nseq))
The central object in the model
corresponds to a simple clause. It is
called a polytyped string (or PTS). It is
obtained from an interval sequence by
adding the information about temporal
</bodyText>
<figure confidence="0.594273">
indexes a la Reichenbach: •
abstype pts =nseq #index
make_pts=-:((nseq *index) -&gt; pts)
f1=-: pred -&gt; pts
12=-: pred -&gt; pts
fn=-: pred -&gt; pts
rules=-:
(status # tense # vendler # adverbial)
-&gt; pred -&gt; pts)
apply_rules
(pred # status) -&gt; pts
</figure>
<bodyText confidence="0.999893333333334">
where the functional type &amp;quot;pred-&gt; pts&amp;quot;
denotes the set of functions which build
PTS&apos;s from predicate information.
The predicate information is given
through the &amp;quot; rules&amp;quot; where &amp;quot;status&amp;quot; is
the information relative to the
enunciative vs. aoristic status; &amp;quot;tense&amp;quot;
denotes the morphological tense of the
clause, &amp;quot;vendler&amp;quot; , the Vendler class
(i.e. state, activity, accomplishement
or achievement ) computed from classe(s)
assigned to verbs in the dictionary and
the syntactical configurations ; finally
&amp;quot;adverbial&amp;quot; corresponds to information
attached to the time adverbials.
Up to this point , we have described
the fundamentals of the system of
representation. Of course, the actual
construction of the representative
temporal object for a text in a given
language is highly language dependent.
For instance, the present tense in French
(which is the language we are working on)
is not in a simple correspondance with
the &amp;quot;corresponding&amp;quot; simple present in
English. Consequently , referring to the
objects described above, the functions
&amp;quot;fi&amp;quot;, and &amp;quot;rules&amp;quot; are quite specific to
the structure of the language
represented.
The temporal relations in longer units
of discourse are comparatively much more
loosely specified. Consider the following
</bodyText>
<page confidence="0.994808">
112
</page>
<listItem confidence="0.653407">
example:
(15) Shakespeare is dead. John is ill.
And I am not feeling well either.
</listItem>
<bodyText confidence="0.937670181818182">
Apart from considerations pertaining
to real-world knowledge, no information
is given about the relative order of the
beginnings of the three situations
considered. So the representation should
allow for indeterminacy, either in
listing all possible alternatives (this
would be the case in Allen&apos;s model), or
in leaving the order unspecified. This
more economical solution is chosen here.
Compare (15) to the following:
(16) Mary got pregnant. She married John.
(17) Mary married John. She got pregnant.
Here, the order of discourse seems
pertinent and should be represented.
More complex examples in this respect
are:
(18) John was angry when Mary dropped the
vase.
(19) Mary dropped the vac..e. John was
angry.
(20) John was angry. Mary dropped the
vase.
where (19) or alternatively (20) can be a
paraphrase of (18).
The preceding discussion shows that
the total ordering at the sentence level
cannot in general be extended to larger
units in a simple way. The eventual
relations between different simple
sentences are a result of a computation
making use of the temporal structure of
those sentences and the order of
discourse.
This fact is captured as follows: The
structure representing a text is
constructed stepwise. At each step of the
construction, the existing structure
provides a context, in which the order of
discourse, in particular, is represented.
In technical terms, the corresponding
object is called &amp;quot;temporal site&amp;quot;. It is
composed of a sequence of PTS&apos;s together
with a set of relations on the boundaries
of the constituent PTS&apos;s.So the next
sentence to be examined, taken in
isolation, is represented by a possibly
incomplete structure (a polytyped string)
with a total order on it, but with
possible indeterminacies (for example, in
the assignment of time indexes). This new
structure is inserted into the old one,
(already constructed temporal site )
thereby creating new constraints
resulting in the evaluation of some
undetermined parameters in both
structures.
Here again, the precise combination
rules are language specific, as they
depend on the semantic properties of the
time relations in the language.
It is beyond the scope of this paper
to give the rules used for French.
However to give an indication of what the
construction amounts to , consider the
following english sentences:
</bodyText>
<listItem confidence="0.807237">
(21) John was in love with Mary;
(22) John has built his house;
(23) John was building his house when I
left for Rome.
</listItem>
<bodyText confidence="0.957348489361702">
The analysis of (21) yields:
tense : simple past;
status : enunciative (by default);
vendler :state;
adverbial :none.
Denoting by &amp;quot;p&amp;quot; the predication: John
is in love with Mary, the structure of
the representing PTS can be symbolized by
the formula :
Cl p 02 9 03 (33 R2)
where the C&apos;s and O&apos;s denote closing and
opening boundaries and S and R,points of
speech and reference respectively . These
are indexed by the order of occurrence of
the corresponding boundaries. 9 denotes a
dummy predication.
Consider sentence (22) . Here
tense : present perfect;
status : enunciative (because of the
present perfect tense);
vendler : accomplishment (perfect form);
adverbial : none.
The formula :
01 p C2 reslt(p) 03 (53 R3)
describes the associated PTS, where p is
John builds his house and reslt(p) is a
resulting state, obtained by local
inference, which expresses : the house is
built .
Finally, consider sentence (23). The
associated temporal site can be
symbolized by:
1: 01 p 02 9 03 (53,R2)
2: 01 q C2 9 03 (S3,R2)
REL: 01:1 &lt; 01:2
02:1 &gt;= 01:2
This temporal site contains two PTS&apos;s,
with p = John builds his house and q=
I leave for Rome .q is an achievement in
Vendler&apos;s classification. The additional
information concerns the ordering
relations between the boundaries of the
PTS&apos;s, numbered 1 and 2.
We have been mainly concerned with
the representation of what we have termed
enunciative situations (as opposed to
aoristic ones). This is justified , as
</bodyText>
<page confidence="0.997411">
113
</page>
<bodyText confidence="0.99951184">
such situations play a central role in
discourse. Concerning aoristic
situations, similar representative
structures are used, which are in fact
more strictly constrained.
Habitual situations (e.g. sentence
(2)) involve a particular treatment of
the predicative component, but otherwise
fit into the general scheme described
above. From this point of view, they are
no different from factual situations.
Dispositional sentences, on the other
hand, cannot be discussed without
entering the domain of modality. Although
this may seem a serious limitation
(especially for English, where modality
is all pervasive ), we leave it aside in
the present consideration of tense and
time.
The preceding discussion illustrates
the use of linguistic inference at three
distinct levels:
a) At the simple sentence level,
building a representation involves a
first type of inference, which makes use
of morpho-syntactic and lexico-semantic
information .
b) At the next higher level, as
illustrated by examples (15-20), another
type of inference is used to specify and
build the corresponding structures
(temporal sites).
c) Still another kind of linguistic
inference should account for the possible
derivabilities or paraphrasings mentioned
A propos examples (1-12). Its
formalization should make it possible to
describe this inference which, starting
from a given temporal site allows to
deduce new sites from it.
Whereas the first two types of
inference are constitutive of the
derivation of temporal structures and are
central to our activity, the last type
has still to be defined and examined in a
systematic way i.e. defined explicitely
as derivation rules. In this context, the
facilities for self-reference and
structural inference in the software
environment are of primary relevance.
</bodyText>
<sectionHeader confidence="0.999678" genericHeader="references">
REFERENCES
</sectionHeader>
<reference confidence="0.998905032786885">
Allen,J.A.1983 Maintaining knowledge
about temporal intervals.Comm.ACM 26
pp.832-843.
Bestougeff, H. and Ligozat, G. 1984a
Processing Tense Information in French
Utterances.Proceedings of the 6th
European Conference on Artificial
Intelligence. Pisa, Italy:209-212
Bestougeff, H. and Ligozat, G. 1984b
L&apos;infdrence temporelle en situation
orientee par l&apos;action.Proceedings of
the CNRS Greco Seminar.Nancy, France.
Bestougeff, H. and Ligozat, G. 1984c
Temporal Intervals Revisited.
CNRS Research Report, Paris 7.
Culioli, A. 1980 Valeurs aspectuelles et
opdrations 6nonciatives.In David,J.and
Martin, R., Eds., La notion d&apos;aspect.
Klincksieck, Paris: 181-193.
Comrie, B. 1976 Aspect. Cambridge
University Press .
De Boissieu, A. and Forest, F. 1985
Analyse linguistique en termes
d&apos;objets.CNRS Research report,Paris 7.
Ejerhed, E.I. and Janlert, L.E. 1981
Representing time in natural language
processing. In Proceedings of the
Workshop on Models of Dialogue .
Linkoping UIT.
Goguen,J.A. Meseguer, J. Plaisted, D.
1983 Programming with Parametrized
Abstract Objects in OBJ. in Theory and
Practice of Software Technology. D.
Ferrari, M.Bolognani and Goguen Eds.
North Holland.
Goguen, J.A. and Burstall, R.M. 1984
Introducing Institutions. in
Proceedings , Logics of Programming
Workshop. E.Clarke and D.Kozen Eds.
Lecture Notes in Computer Science,
Vol 164 Springer Verlag.
Goguen J.A. and Meseguer J. 1984
Equality,Types,Modules and (why not?)
Generics for Logic Programming. J.
Logic Programming 1984:2.
Goldberg, A. and Robson, D. 1983
Smalltalk-80.The language and its
implementation. Addison Wesley
Publishing Company.
Gordon,M.J., Milner, A.J. Wadsworth,L.P.
1979 Edinburg LCF. Lecture Notes in
Computer Science Vol 78 . Springer
INRIA. 1984 The ML Handbook . Version
5.1. Report of Institut National de
Recherche en Informatique et
Automatique. France.
Kamp, H. 1979 Events, Instants, and
Temporal Reference.in Egli,U. and Von
Stechow, A., Eds. Semantics from a
multiple point of view. De Gruyther,
Berlin: 376-417.
</reference>
<page confidence="0.988701">
114
</page>
<reference confidence="0.988005666666667">
Reichenbach, H. 1957 The Philosophy of
Space and Time.New York.
Smith, C. 1978 The syntax and
interpretation of temporal expressions
in English.Linguistics and Philosophy
2: 44-99.
Steels, L. 1983 ORBIT : An Applicative
View of Object Programming. in
Integrated Interactive Computing
Systems .P.Degano, E. Sandewall Eds.
North Holland.
Van Benthem, J. 1980 Points and
periods. In Rohrer, C., Eds., Time,
Tense, and Quantifiers, Niemeyer,
Tuebingen:39-57.
Vendler, Z. 1967 Linguistics in
Philosophy. Cornell University Press,
Ithaca.
</reference>
<page confidence="0.999021">
115
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.875804">
<title confidence="0.997817">PARAMETRIZED ABSTRACT OBJECTS FOR LINGUISTIC INFORMATION PROCESSING</title>
<author confidence="0.998445">Helene Bestougeff</author>
<author confidence="0.998445">Gerard Ligozat</author>
<affiliation confidence="0.961206">CNRS-Universite Paris VII</affiliation>
<address confidence="0.941563">2,Place Jussieu 75005 PARIS FRANCE</address>
<abstract confidence="0.998781514285714">Programming languages which have adequate primitives for linguistic information processing and a clear semantics at the formal computational level are now slowly emerging as a convergent effort from computer science, linguistics, and artificial intelligence. Our work on the processing of a special kind of linguistic information, namely temporal information ,has led us to advocate the use of a language with the following characteristic features: high level of abstraction; capacity for inference; modularity. A high level of abstraction is needed to deal with complex linguistic notions which are not easily reducible to elementary data structures. A capacity for inference is required, as most criteria or tests in linguistics make use of particular kinds of deductions, at different levels of the linguistic analysis. As for modularity, a typical situation in linguistics has to do with a hierarchy of concepts or units, and the relations between those units at different levels. This paper discusses the relevance of the choice of parametrized abstract objects as tools for linguistic information processing and exemplifies the use of such objects for temporal information.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="false">
<title>Allen,J.A.1983 Maintaining knowledge about temporal</title>
<journal>intervals.Comm.ACM</journal>
<volume>26</volume>
<pages>832--843</pages>
<marker></marker>
<rawString>Allen,J.A.1983 Maintaining knowledge about temporal intervals.Comm.ACM 26 pp.832-843.</rawString>
</citation>
<citation valid="false">
<authors>
<author>H Bestougeff</author>
<author>G Ligozat</author>
</authors>
<booktitle>1984a Processing Tense Information in French Utterances.Proceedings of the 6th European Conference on Artificial Intelligence.</booktitle>
<location>Pisa, Italy:209-212</location>
<marker>Bestougeff, Ligozat, </marker>
<rawString>Bestougeff, H. and Ligozat, G. 1984a Processing Tense Information in French Utterances.Proceedings of the 6th European Conference on Artificial Intelligence. Pisa, Italy:209-212</rawString>
</citation>
<citation valid="true">
<authors>
<author>H Bestougeff</author>
<author>G Ligozat</author>
</authors>
<title>L&apos;infdrence temporelle en situation orientee par l&apos;action.Proceedings of the CNRS Greco Seminar.Nancy,</title>
<date>1984</date>
<contexts>
<context position="19227" citStr="Bestougeff and Ligozat, 1984" startWordPosition="3056" endWordPosition="3059"> the basic elements, consider their intended properties and combination rules for building derived elements. This combinatorial point of view is implicit, for example, in Allen&apos;s model (Allen 83), where a set of &amp;quot;intervals&amp;quot; is abstractly characterized by the relations holding between its elements. It can be shown (Bestougeff and Ligozat ,1984) that any set theoritic model of Allen&apos;s axioms is equivalent to (a subset) of the intervals (that is, couples of points) on a totally ordered set. In our model,the basic elements are typed boundaries, with a (partial) order defined on them. As shown in (Bestougeff and Ligozat, 1984) an alternative way of considering the same abstraction would be in terms of &amp;quot;intervals&amp;quot;, where an interval is a couple (bl, b2) of boundaries with bl &lt;b2 . In other words, the term &amp;quot;interval&amp;quot; has only the notions of a beginning and an end associated with it, and it is immaterial whether one or the other terminology is used. No topological properties are implied , only combinatorial properties (in terms of the types of boundaries ) are retained in the abstraction. Boundary types are introduced in the model in order to represent aspectual properties of the data. As an example, consider again se</context>
</contexts>
<marker>Bestougeff, Ligozat, 1984</marker>
<rawString>Bestougeff, H. and Ligozat, G. 1984b L&apos;infdrence temporelle en situation orientee par l&apos;action.Proceedings of the CNRS Greco Seminar.Nancy, France.</rawString>
</citation>
<citation valid="true">
<authors>
<author>H Bestougeff</author>
<author>G Ligozat</author>
</authors>
<title>Temporal Intervals Revisited. CNRS Research Report,</title>
<date>1984</date>
<location>Paris</location>
<contexts>
<context position="19227" citStr="Bestougeff and Ligozat, 1984" startWordPosition="3056" endWordPosition="3059"> the basic elements, consider their intended properties and combination rules for building derived elements. This combinatorial point of view is implicit, for example, in Allen&apos;s model (Allen 83), where a set of &amp;quot;intervals&amp;quot; is abstractly characterized by the relations holding between its elements. It can be shown (Bestougeff and Ligozat ,1984) that any set theoritic model of Allen&apos;s axioms is equivalent to (a subset) of the intervals (that is, couples of points) on a totally ordered set. In our model,the basic elements are typed boundaries, with a (partial) order defined on them. As shown in (Bestougeff and Ligozat, 1984) an alternative way of considering the same abstraction would be in terms of &amp;quot;intervals&amp;quot;, where an interval is a couple (bl, b2) of boundaries with bl &lt;b2 . In other words, the term &amp;quot;interval&amp;quot; has only the notions of a beginning and an end associated with it, and it is immaterial whether one or the other terminology is used. No topological properties are implied , only combinatorial properties (in terms of the types of boundaries ) are retained in the abstraction. Boundary types are introduced in the model in order to represent aspectual properties of the data. As an example, consider again se</context>
</contexts>
<marker>Bestougeff, Ligozat, 1984</marker>
<rawString>Bestougeff, H. and Ligozat, G. 1984c Temporal Intervals Revisited. CNRS Research Report, Paris 7.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Culioli</author>
</authors>
<title>Valeurs aspectuelles et opdrations 6nonciatives.In David,J.and</title>
<date>1980</date>
<pages>181--193</pages>
<location>Paris:</location>
<contexts>
<context position="12493" citStr="Culioli, 1980" startWordPosition="1943" endWordPosition="1944">ecessary to define primitive objects, which do not have any lingustic interpretation but are merely building blocks whose use enhances modularity . In this case ,the lower level objects can be hidden to the user . Keeping this in mind ,we can now proceed to the description of the linguistic motivations which are behind the construction of temporal objects . The idea is to give a systematic way of representing temporal information by defining abstract structures based upon the concepts and the hypotheses of a particular linguistic theory. The linguistic theory we rely on is that of A. Culioli (Culioli, 1980), suitably adapted to computational purposes. Temporal information can be informally characterized as information pertaining to the location and &amp;quot;shape&amp;quot; of the states and events described by natural language. In particular, this includes what is commonly referred to as aspect. Furthermore, temporal information in natural language has both a descriptive and an operative structure: it describes and allows the users to make systematic inferences. Among these inferences are those concerned with the ordering of events, but such inferences are only part of a whole set of inferences on the factuality</context>
</contexts>
<marker>Culioli, 1980</marker>
<rawString>Culioli, A. 1980 Valeurs aspectuelles et opdrations 6nonciatives.In David,J.and Martin, R., Eds., La notion d&apos;aspect. Klincksieck, Paris: 181-193.</rawString>
</citation>
<citation valid="true">
<authors>
<author>B Comrie</author>
</authors>
<title>Aspect.</title>
<date>1976</date>
<publisher>Cambridge University Press .</publisher>
<contexts>
<context position="17089" citStr="Comrie (1976)" startWordPosition="2709" endWordPosition="2710">y incomplete. We will be content at this point of our discussion with noting the need for a convenient notation for such a phenomenon. TEMPORAL OBJECTS We assume that temporal information in a text can be represented by proceeding in three steps of increasing difficulty: - Tense in main clauses. - Tense in subordinate clauses. - Tense in texts. This hierarchy follows that of Ejerhed and Janlert ( 1981). To summarize the discussion of the previous paragraph, the following elements of temporal information have to be abstracted: - temporal deixis (enunciative vs. aoristic situations) . Following Comrie (1976), we use the term &amp;quot;situation&amp;quot; as a generic term covering states, events or processes . - inception and termination of a situation. - information relative to the completion of the situation. - local inferences on situations. - mass/count properties of situations. In our system, these elements are reconstructed from the following linguistic data: - tenses in the finite forms of verbs. - temporal specifiers (temporal adverbials). -semantic types of situations (computed from the semantic type of the verbs A la Vendler, and the syntactic structure of the proposition). At this point, most existing s</context>
</contexts>
<marker>Comrie, 1976</marker>
<rawString>Comrie, B. 1976 Aspect. Cambridge University Press .</rawString>
</citation>
<citation valid="true">
<authors>
<author>A De Boissieu</author>
<author>F Forest</author>
</authors>
<title>Analyse linguistique en termes d&apos;objets.CNRS Research report,Paris 7.</title>
<date>1985</date>
<marker>De Boissieu, Forest, 1985</marker>
<rawString>De Boissieu, A. and Forest, F. 1985 Analyse linguistique en termes d&apos;objets.CNRS Research report,Paris 7.</rawString>
</citation>
<citation valid="true">
<authors>
<author>E I Ejerhed</author>
<author>L E Janlert</author>
</authors>
<title>Representing time in natural language processing.</title>
<date>1981</date>
<booktitle>In Proceedings of the Workshop on Models of Dialogue . Linkoping UIT.</booktitle>
<marker>Ejerhed, Janlert, 1981</marker>
<rawString>Ejerhed, E.I. and Janlert, L.E. 1981 Representing time in natural language processing. In Proceedings of the Workshop on Models of Dialogue . Linkoping UIT.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J A Meseguer Goguen</author>
<author>J Plaisted</author>
<author>D</author>
</authors>
<title>Programming with Parametrized Abstract Objects</title>
<date>1983</date>
<booktitle>in OBJ. in Theory and Practice of Software Technology. D. Ferrari, M.Bolognani</booktitle>
<publisher>North Holland.</publisher>
<contexts>
<context position="6248" citStr="Goguen et al. 1983" startWordPosition="918" endWordPosition="921">racterized by the following properties: - Each object is an instance of a class (a generic object). - Each object has a local memory which can only be updated by functions (or procedures) local to the object. - Objects are organized into a tree-like hierarchy implying tree-like inheritance. - Communication between objects is organized through message passing. However ,it has been argued that the object oriented approach can be fruitfully carried over into applicative language contexts (Steels ,1982) or into particular systems based on logic where the fundamental mechanism is data abstraction (Goguen et al. 1983). As regards Smalltalk, it does not provide systematic facilities for defining abstract data types; all computations are highly dependent on side effects (assignment is systematically used in local operations) and there is no explicit typing. We favour the approach exemplified by such languages as OBJ and their possible extensions (Goguen and Meseguer, 1984), as we think that they will allow ,in the long range, a more efficient programming style and make the systematic proof of programs possible. The OBJ language is based upon data abstraction: an object is a type (i.e. a domain of values with</context>
</contexts>
<marker>Goguen, Plaisted, D, 1983</marker>
<rawString>Goguen,J.A. Meseguer, J. Plaisted, D. 1983 Programming with Parametrized Abstract Objects in OBJ. in Theory and Practice of Software Technology. D. Ferrari, M.Bolognani and Goguen Eds. North Holland.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J A Goguen</author>
<author>R M Burstall</author>
</authors>
<title>Introducing Institutions.</title>
<date>1984</date>
<booktitle>in Proceedings , Logics of Programming Workshop. E.Clarke and D.Kozen Eds. Lecture Notes in Computer Science, Vol 164</booktitle>
<publisher>Springer Verlag.</publisher>
<contexts>
<context position="7592" citStr="Goguen and Burstall, 1984" startWordPosition="1128" endWordPosition="1131">cies among types. Computations are performed by using equational axioms as oriented rewrite rules. Therefore , granted the availability of a theorem prover , the consistency of the specifications given in the abstract data type can be formally checked. Moreover , since the objects have a clear mathematical definition, all the techniques of abstract algebra are also available. More generally, axioms could be given not only as equations , but also as formulas in a logical theory (such as first order predicate calculus or temporal logics) assuming those theories satisfy some given restrictions ( Goguen and Burstall, 1984). As we have no access yet to any version of OBJ, we have decided , in a first stage, to restrict the object structure to its free component, i.e. only the signatures, not the axioms are defined. Therefore-, the computations have to be explicitely coded. As a consequence, no checking of consistency 108 is possible for the time being. The actual implementation is done in the ML language (Gordon et al., 1979). ML is a functional language which is fully higher-order. &amp;quot;It has a polymorphic type discipline which combines the flexibility of programming in a typeless language with the security of com</context>
</contexts>
<marker>Goguen, Burstall, 1984</marker>
<rawString>Goguen, J.A. and Burstall, R.M. 1984 Introducing Institutions. in Proceedings , Logics of Programming Workshop. E.Clarke and D.Kozen Eds. Lecture Notes in Computer Science, Vol 164 Springer Verlag.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J A Goguen</author>
<author>J Meseguer</author>
</authors>
<title>Equality,Types,Modules and (why not?) Generics for Logic Programming.</title>
<date>1984</date>
<journal>J. Logic Programming</journal>
<pages>1984--2</pages>
<contexts>
<context position="6608" citStr="Goguen and Meseguer, 1984" startWordPosition="971" endWordPosition="974">passing. However ,it has been argued that the object oriented approach can be fruitfully carried over into applicative language contexts (Steels ,1982) or into particular systems based on logic where the fundamental mechanism is data abstraction (Goguen et al. 1983). As regards Smalltalk, it does not provide systematic facilities for defining abstract data types; all computations are highly dependent on side effects (assignment is systematically used in local operations) and there is no explicit typing. We favour the approach exemplified by such languages as OBJ and their possible extensions (Goguen and Meseguer, 1984), as we think that they will allow ,in the long range, a more efficient programming style and make the systematic proof of programs possible. The OBJ language is based upon data abstraction: an object is a type (i.e. a domain of values with functions accessing those values); objects are organized into a hierarchy an acyclic graph) representing the dependencies among types. Computations are performed by using equational axioms as oriented rewrite rules. Therefore , granted the availability of a theorem prover , the consistency of the specifications given in the abstract data type can be formall</context>
</contexts>
<marker>Goguen, Meseguer, 1984</marker>
<rawString>Goguen J.A. and Meseguer J. 1984 Equality,Types,Modules and (why not?) Generics for Logic Programming. J. Logic Programming 1984:2.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Goldberg</author>
<author>D Robson</author>
</authors>
<title>Smalltalk-80.The language and its implementation.</title>
<date>1983</date>
<publisher>Addison Wesley Publishing Company.</publisher>
<contexts>
<context position="5507" citStr="Goldberg and Robson, 1983" startWordPosition="803" endWordPosition="806">e possibility of using different points of views for the same objects is a consequence of this structuration. This approach leads to focussing on the basic process of abstraction. In this context, abstraction is a process which, starting from a description of the data, yields an abstract specification. This involves three steps. - define the relevant objects for the problem under study; - define the possible functions and relations on the objects; -give explicitly the constraints between the functions and relations. The object-oriented approach is usually equated with the Smalltalk &amp;quot;vision&amp;quot; ( Goldberg and Robson, 1983 ), while other views of objects are rejected as being irrelevant or even self contradictory. Smalltalk objects can be characterized by the following properties: - Each object is an instance of a class (a generic object). - Each object has a local memory which can only be updated by functions (or procedures) local to the object. - Objects are organized into a tree-like hierarchy implying tree-like inheritance. - Communication between objects is organized through message passing. However ,it has been argued that the object oriented approach can be fruitfully carried over into applicative langua</context>
</contexts>
<marker>Goldberg, Robson, 1983</marker>
<rawString>Goldberg, A. and Robson, D. 1983 Smalltalk-80.The language and its implementation. Addison Wesley Publishing Company.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M J Gordon</author>
<author>A J Wadsworth Milner</author>
<author>L P</author>
</authors>
<title>Edinburg LCF.</title>
<date>1979</date>
<journal>Lecture Notes in Computer Science Vol</journal>
<volume>78</volume>
<pages>.</pages>
<publisher>Springer</publisher>
<contexts>
<context position="8002" citStr="Gordon et al., 1979" startWordPosition="1200" endWordPosition="1203"> not only as equations , but also as formulas in a logical theory (such as first order predicate calculus or temporal logics) assuming those theories satisfy some given restrictions ( Goguen and Burstall, 1984). As we have no access yet to any version of OBJ, we have decided , in a first stage, to restrict the object structure to its free component, i.e. only the signatures, not the axioms are defined. Therefore-, the computations have to be explicitely coded. As a consequence, no checking of consistency 108 is possible for the time being. The actual implementation is done in the ML language (Gordon et al., 1979). ML is a functional language which is fully higher-order. &amp;quot;It has a polymorphic type discipline which combines the flexibility of programming in a typeless language with the security of compiletime type checking&amp;quot;. Moreover, one can define one&apos;s own types , which may be abstract and/or recursive. To give a flavour of the ML programming style, consider a possible definition of the abstract recursive type of binary trees, with tip values of an arbitrary type (denoted by *) and non tip nodes of some other arbitrary type (denoted by **). (This exemple is taken from Gordon et al., 1979): absrectype</context>
</contexts>
<marker>Gordon, Milner, P, 1979</marker>
<rawString>Gordon,M.J., Milner, A.J. Wadsworth,L.P. 1979 Edinburg LCF. Lecture Notes in Computer Science Vol 78 . Springer</rawString>
</citation>
<citation valid="true">
<authors>
<author>INRIA</author>
</authors>
<title>The ML Handbook . Version 5.1. Report of Institut National de Recherche en Informatique et Automatique.</title>
<date>1984</date>
<marker>INRIA, 1984</marker>
<rawString>INRIA. 1984 The ML Handbook . Version 5.1. Report of Institut National de Recherche en Informatique et Automatique. France.</rawString>
</citation>
<citation valid="true">
<authors>
<author>H Kamp</author>
</authors>
<title>Events, Instants, and Temporal Reference.in Egli,U. and Von Stechow, A., Eds. Semantics from a multiple point of view. De Gruyther,</title>
<date>1979</date>
<pages>376--417</pages>
<location>Berlin:</location>
<marker>Kamp, 1979</marker>
<rawString>Kamp, H. 1979 Events, Instants, and Temporal Reference.in Egli,U. and Von Stechow, A., Eds. Semantics from a multiple point of view. De Gruyther, Berlin: 376-417.</rawString>
</citation>
<citation valid="true">
<authors>
<author>H Reichenbach</author>
</authors>
<title>The Philosophy of Space and</title>
<date>1957</date>
<location>Time.New York.</location>
<contexts>
<context position="15135" citStr="Reichenbach, 1957" startWordPosition="2382" endWordPosition="2383">entences (6, 7, 8) with that of the verb to sing in (9, 10, 11). The comparison between (4) and (6) in relation with (7) shows the necessity of suitably representing the difference between the simple and the progressive past, at least for verbs of the type to repair a car , which are classified as accomplishments. To represent the difference between (4) (simple past) and (5) (present perfect), we have to express what makes (8), but not (4), derivable from (5). Reichenbach&apos;s system of temporal indexes (point of speech, point of event, point of reference ) can be used to handle this phenomenon (Reichenbach, 1957 ). It provides a way of describing the notion of &amp;quot;present relevance&amp;quot;, which is present in (5) , but not in (4). The contrast between (1 , 2) and (12) points to another kind of distinction one has to make: (1) expresses a state, (2) a habit, which hold at the moment of speech. On the contrary, (12) states a general fact which is basically undetermined with respect to the moment of speech. Dependence on the time of speech is a fact of temporal deixis. We shall refer to it as enunciativity , (following A. Culioli) . By opposition situations such as (12) will be termed aoristic. The preceding exa</context>
</contexts>
<marker>Reichenbach, 1957</marker>
<rawString>Reichenbach, H. 1957 The Philosophy of Space and Time.New York.</rawString>
</citation>
<citation valid="true">
<authors>
<author>C Smith</author>
</authors>
<title>The syntax and interpretation of temporal expressions in</title>
<date>1978</date>
<journal>English.Linguistics and Philosophy</journal>
<volume>2</volume>
<pages>44--99</pages>
<contexts>
<context position="16091" citStr="Smith (1978)" startWordPosition="2548" endWordPosition="2549">etermined with respect to the moment of speech. Dependence on the time of speech is a fact of temporal deixis. We shall refer to it as enunciativity , (following A. Culioli) . By opposition situations such as (12) will be termed aoristic. The preceding examples give some idea of the type of information that has to be represented. We have deliberately played down the purely sequential type of information, which is the only type of temporal information most systems are concerned with. Moreover, the purely sequential type of information is mostly incomplete 110 (this is stressed in particular by Smith (1978)). Consider the following examples: (13) John saw his doctor this morning: he is ill. (14) John saw his doctor this morning: now he is ill. Contrasting (13) and (14) shows a potential indeterminacy in the relation between the two sentences. Smith (1978) claims that sentences like (1), where no explicit &amp;quot;reference time&amp;quot; is provided (e.g. by a time adverbial such as now) are temporally incomplete. We will be content at this point of our discussion with noting the need for a convenient notation for such a phenomenon. TEMPORAL OBJECTS We assume that temporal information in a text can be represente</context>
</contexts>
<marker>Smith, 1978</marker>
<rawString>Smith, C. 1978 The syntax and interpretation of temporal expressions in English.Linguistics and Philosophy 2: 44-99.</rawString>
</citation>
<citation valid="true">
<authors>
<author>L Steels</author>
</authors>
<title>ORBIT : An Applicative View of Object Programming.</title>
<date>1983</date>
<booktitle>in Integrated Interactive Computing Systems .P.Degano, E. Sandewall Eds.</booktitle>
<publisher>North Holland.</publisher>
<marker>Steels, 1983</marker>
<rawString>Steels, L. 1983 ORBIT : An Applicative View of Object Programming. in Integrated Interactive Computing Systems .P.Degano, E. Sandewall Eds. North Holland.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Van Benthem</author>
</authors>
<title>Points and periods.</title>
<date>1980</date>
<journal>In Rohrer, C., Eds., Time, Tense, and Quantifiers, Niemeyer,</journal>
<pages>39--57</pages>
<marker>Van Benthem, 1980</marker>
<rawString>Van Benthem, J. 1980 Points and periods. In Rohrer, C., Eds., Time, Tense, and Quantifiers, Niemeyer, Tuebingen:39-57.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Z Vendler</author>
</authors>
<title>Linguistics in Philosophy.</title>
<date>1967</date>
<publisher>Cornell University Press,</publisher>
<location>Ithaca.</location>
<contexts>
<context position="14323" citStr="Vendler (1967)" startWordPosition="2246" endWordPosition="2247">t for some basic information imparted by the use of such sentences. For example: - Sentence (2) does not imply (3), neither does sentence (3) imply sentence (2) - Sentence (4) implies sentence (7), not (8). - Sentence (5) implies sentence (8). - Sentence (6) implies neither sentence (7) nor, a fortiori, (8), whereas sentence (9) implies sentences (10),(11). The different uses of the simple present tense in (1) and (2) are related to a difference between the semantic types of the verbs to be ill and to repair. We will account for this difference by adapting a classification (essentially due to Vendler (1967)) into four semantic types ( state, activity, accomplishement, achievement ) . The usefulness of such a classification is further illustrated by comparing the behaviour of the verb to repair in sentences (6, 7, 8) with that of the verb to sing in (9, 10, 11). The comparison between (4) and (6) in relation with (7) shows the necessity of suitably representing the difference between the simple and the progressive past, at least for verbs of the type to repair a car , which are classified as accomplishments. To represent the difference between (4) (simple past) and (5) (present perfect), we have </context>
</contexts>
<marker>Vendler, 1967</marker>
<rawString>Vendler, Z. 1967 Linguistics in Philosophy. Cornell University Press, Ithaca.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>