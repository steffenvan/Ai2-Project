<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<title confidence="0.981303">
Inference in DATR
</title>
<author confidence="0.955962">
Roger Evans &amp; Gerald Gazdar
</author>
<affiliation confidence="0.863043">
School of Cognitive and Computing Sciences
University of Sussex, BRIGHTON BN1 9QN
</affiliation>
<sectionHeader confidence="0.977901" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.99986555">
DATR is a declarative language for representing a
restricted class of inheritance networks, permit-
ting both multiple and default inheritance. The
principal intended area of application is the
representation of lexical entries for natural
language processing, and we use examples from
this domain throughout. In this paper we
present the syntax and inference mechanisms for
the language. The goal of the DATR enterprise is
the design of a simple language that (i) has the
necessary expressive power to encode the lexical
entries presupposed by contemporary work in
the unification grammar tradition, (ii) can
express all the evident generalizations about
such entries, (iii) has an explicit theory of infer-
ence, (iv) is computationally tractable, and (v)
has an explicit declarative semantics. The
present paper is primarily concerned with (iii),
though the examples used may hint at our stra-
tegy in respect of (i) and (ii).
</bodyText>
<sectionHeader confidence="0.999132" genericHeader="keywords">
1 Introduction
</sectionHeader>
<bodyText confidence="0.999881923076923">
Inheritance networks (&amp;quot;semantic nets&amp;quot;) provide
an intuitively appealing way of thinking about
the representation of various kinds of
knowledge. This fact has not gone unnoticed by
a number of researchers working on lexical
knowledge representation, e.g. de Smedt (1984),
Flickinger et al. (1985), Calder &amp; te Linden
(1987), Daelemans (1987a,1987b), Gazdar
(1987) and Calder (1989). However, many such
networks have been realized in the context of
programming systems or programming
languages that leave their precise meaning
unclear. In the light of Braclunan (1985), Ether.
ington (1988) and much other recent work, it ha
become apparent that the formal properties oi
notations intended to represent inheritance arc
highly problematic. Although not discussec
here, DATR has a formal semantics (Evans &amp;
Gazdar 1989) for which some completeness anc
soundness results have been derived. These
results, and others (on complexity, for example;
will be provided in a subsequent paper. There
are several prototype computational implementa.
tions of the language, and non-trivial lexicor
fragments for English, German and Latin have
been developed and tested.
</bodyText>
<sectionHeader confidence="0.993095" genericHeader="introduction">
2 Syntax
</sectionHeader>
<bodyText confidence="0.883465">
The syntax of DATR, especially the use of value
terminated attribute trees to encode information
derives from PATR (Shieber 1986). The language
consists of strings of symbols drawn from the se
S&apos;YM = {:, &amp;quot;, =, ==, &lt;, &gt;, (, )} and the set:
ATOM and NODE, all of which are disjoint.
A string is in DATR, (with respect to given set:
ATOM of [atom]s and NODE of [node]s) if it is
[sentence] as defined by the following set 01
rules:
</bodyText>
<equation confidence="0.985919461538462">
node]: [path] == [lvalue].
(nodellpath] = [value].
[latom] I ([lseq] )
[gatom] I ([gseq] )
[atom] I ( [sa] )
[desc] I [gatom]
&amp;quot;[desc]&amp;quot; I [atom]
[sentence] ::=
[ivalue] ::=
[gvalue] ::=
[value] ::=
[latom] ::=
[gatom] ::=
- 66 -
[desc] ::= [node] I [lpath]
I [node]:[1path]
[gsect] I [Iseq] Riese] [lseq]
[se41] I igsecl] &amp;quot;Wesel&amp;quot; [gseq]
I [value] [sec]]
[lseq]
[gseq]
[seq] ::=
[1path] ::= &lt; [laseq] &gt;
[path] ::= &lt; [aseq] &gt;
[laseq] ::= e I Datomillaseq]
[aseq] ::= e I [atom] [aseq]
</equation>
<bodyText confidence="0.998384470588235">
There are two kinds of sentence, those contain-
ing `-==&apos; and those containing `=&apos;. Both kinds
have on their left-hand side a node: path
specification, where a path is a sequence of
atoms enclosed in &lt;...&gt;. Pragmatically, the
`==3 sentences are intended for defining the net-
work, whilst the &apos;=&apos; statements express the
values at individual nodes. Put another way, the
former provide the database definition language
whilst the latter provide the query language: the
useful premises will standardly all be state-
ments, whilst the interesting theorems will stan-
dardly all be statements (though the language
itself also allows the former to be derived as
theorems and the latter to be used as premises).
In view of this distinction, we shall sometimes
refer to `=--&apos; sentences as definitional and 4=&apos;
sentences as extensional. Throughout the exam-
ples in this paper, we shall use bold for nodes
and roman for atoms. Bold italic and italic will
be used for corresponding meta-notational vari-
ables. Variables such as N, P, L,G and V will
be assumed to be typed (as nodes, paths, lvalues,
gvalues and values respectively). We shall
sometimes refer to atoms occurring in paths as
attributes.
The right-hand sides of extensional sentences are
values, that is, simple atoms or lists of
atoms/nested lists enclosed in (...). Lists are
provided to allow the components of complex
values to be specified independently (inherited
from different places, for example). As an
example, the following sentences might be
derivable from a lexical entry for English &apos;be&apos;:
</bodyText>
<subsectionHeader confidence="0.5380925">
Be:&lt;pres tense sing one&gt; = am.
Be:&lt;pres participle&gt; = (concat be ing).
</subsectionHeader>
<bodyText confidence="0.970604">
Likewise, the following for German `Buch&apos;:
</bodyText>
<equation confidence="0.515958">
Buch: &lt;sing&gt; = Buch.
Buch: &lt;plur&gt; = (concat (umlaut Buch) er).
</equation>
<bodyText confidence="0.999950904761905">
Values are the principal &apos;results&apos; of a DATR
description: the most typical operation is to
determine the value associated (by an exten-
sional sentence) with some node/path pair.
The right-hand sides of definitional sentences are
lvalues, which can be simple atoms, inheritance
descriptors (quoted or unquoted), or lists of
lvalues. An atom is primitive, an inheritance
descriptor specifies where the required value can
be inherited from, and lists allow arbitrary struc-
tures to be built as values. Inheritance descrip-
tors come in several forms with two dimensions
of variation. The unquoted/quoted distinction
specifies whether the inheritance context is local
(the most recent context employed) or global
(the initial context employed). Once the context
is established, the descriptor specifies a new
node, a new lpath, or both to be used to deter-
mine the inherited value. For example, the fol-
lowing sentences might be found in a description
of a lexicon for English:
</bodyText>
<construct confidence="0.5485238">
EN_MOR: &lt; &gt; == VERB.
EN_MOR:
&lt;past participle&gt; == (concat &amp;quot;&lt;root&gt;&amp;quot; en).
Take: &lt; &gt; == EN_MOR.
Take: &lt;root&gt; == take.
</construct>
<bodyText confidence="0.967707333333333">
Finally an lpath is a path made up of lvalues,
that is, elements which themselves may need
evaluation, as in this example:
</bodyText>
<sectionHeader confidence="0.450056" genericHeader="method">
Adjective:
</sectionHeader>
<bodyText confidence="0.916692666666667">
&lt;form&gt; == &lt;&amp;quot;&lt;gen&gt;&amp;quot; &amp;quot;&lt;num&gt;&amp;quot; &amp;quot;&lt;case&gt;&amp;quot;&gt;.
We adopt the following abbreviation convention
for sets of sentences about a single node:
</bodyText>
<figure confidence="0.700727923076923">
N: PI ==L1
P2 == L2
• • •
Pn == Ln.
abbreviates:
N: P1 == Ll
N: P2 == L2.
• • •
N: Pn == Ln.
- 67 -
and
N: P1 =V1
P2= V2
Pn=Vn.
abbreviates:
N: PI =V1.
N: P2 =V2.
N: Pn=Vn.
Thus the &apos;take&apos; example given above could
appear, in abbreviated form, as follows:
EN_MOR:
&lt; &gt; == VERB
&lt;past participle&gt; == (concat &amp;quot;&lt;rool&gt;&amp;quot; en).
Take:
&lt; &gt; == EN MOR.
&lt;root&gt; =--- take.
</figure>
<sectionHeader confidence="0.951852" genericHeader="method">
3 Rule-based inference
</sectionHeader>
<bodyText confidence="0.9914725">
DATR has seven syntactic rules of inference fal-
ling into three groups. The first rule just pro-
vides us with a trivial route from definitional to
extensional sentences:
</bodyText>
<equation confidence="0.704666833333333">
(I) N:P
N:P =V.
For example, from:
VERB: &lt;past&gt; =-- ed.
one can infer:
VERB: &lt;past&gt; = ed.
</equation>
<bodyText confidence="0.9991143">
Note that V must be a value (not an lvalue) here,
otherwise the consequent would not be well-
formed.
The next three rules implement local inheritance
of values, and use the following additional
meta-notational device: the expression
E0(E21E1) is well-formed iff EO, El and E2 are
lvalues and El occurs as a subexpression of EO.
In that case, the expression denotes the result of
substituting E2 for all occurrences of El in EO.
</bodyText>
<equation confidence="0.997175777777778">
N2:P2 == G.
Nl:P1 ==L.
Nl:P1==L(GIN2:P2).
(III) N2:P1 == G.
N1:P1 ==L.
N1:P1==L(GIN2).
(IV) N1:P2 == G.
Nl:P1 ==L.
N1:P1==L(G1P2).
</equation>
<bodyText confidence="0.940856181818182">
Rule II says that if we have a theorem Nl:P1 ==
L. where L contains N2:P2 as a subexpression,
and we also have a theorem N2:P2 == G., then
we can derive a theorem in which all
occurrences of N2:P2 in L are replaced by G. In
the simplest case, this means that we can inter-
pret a sentence of the form
N1:P1==N2:P2.
as an inheritance specification meaning &amp;quot;the
value of P1 at Ni is inherited from P2 at N2&amp;quot;.
So for example, from:
</bodyText>
<table confidence="0.680426">
NOUN: &lt;sing gen&gt; == s.
PRON: &lt;sing gen&gt; == NOUN:&lt;sing gen&gt;.
one can infer:
PRON: &lt;sing gen&gt; =-- s.
</table>
<bodyText confidence="0.983471142857143">
Rules III and IV are similar, but specify only a
new node or path (not both) to inherit from. The
other component (path or node) is unchanged,
that is, it is the same as the corresponding com-
ponent on the left-hand-side of the rule specify-
ing the inheritance. In fact, the following two
sentence schemas are entirely equivalent:
</bodyText>
<equation confidence="0.9081496">
N1:P1 ==N2.
N1:P1 N2:P1.
as are these two:
Nl:P1 =P2.
N1:P1 ==NI:P2.
</equation>
<bodyText confidence="0.9689904">
Rules II, III, and IV implement a local notion of
inheritance in the sense that the new node or
path specifications are interpreted in the current
local context. The three remaining inference
rules implement a non-local notion of inheri-
tance: quoted descriptors specify values to be
- 68 -
interpreted in the context in which the original
query was made (the global context), rather than
the current context.
</bodyText>
<equation confidence="0.846428333333333">
(V) N2:P2 =V.
Nl:P1==G.
N1:P1=G(VrN2:P2&amp;quot;).
(VI) N2:P1 =V.
N1:P1 == G.
N1:P1=G(Vi&apos;N2&amp;quot;).
(VII) N1:P2 =V.
Nl:P1==G.
N1:P1=G(Vi&apos;P2&amp;quot;).
</equation>
<bodyText confidence="0.919179333333333">
To see how the operation of these rules differs
from the earlier unquoted cases, consider the fol-
lowing theory:
</bodyText>
<figure confidence="0.846494714285714">
CAT: &lt;sing&gt; == &lt;plur&gt;.
V: &lt;sing&gt; == CAT
&lt;plur&gt; = er.
Al: &lt;sing&gt; == CAT
&lt;plur&gt; == ern.
A2: &lt;sing&gt; == en
&lt;plur&gt; == Al.
</figure>
<bodyText confidence="0.996617125">
The intention here is that the CAT node
expresses the generalisation that by default
plural is the same as singular, v and Al inherit
this, but A2, while inheriting its plural form from
Al, has an exceptional singular form, overriding
inheritance from CAT (via Al). Now from this
theory we can derive all the following theorems
concerning plural:
</bodyText>
<construct confidence="0.749245333333333">
V: &lt;plur&gt; = er.
Al: &lt;plur&gt; = ern.
A2: &lt;plur&gt; = ern.
</construct>
<bodyText confidence="0.956369857142857">
and the following theorem concerning singular:
A2: &lt;sing&gt; = en.
But we cannot derive a theorem for V:&lt;sing&gt;,
for example. This is because v:&lt;sing&gt; inherits
from cAT:&lt;sing&gt;, which inherits (locally) from
cAT:&lt;plur&gt;, which is not defined. What we
wanted was for cAT:&lt;sing&gt; to inherit from
v:&lt;plur&gt;, that is, from the global initial context.
To achieve this we change the CAT definition to
be:
CAT: &lt;sing&gt; == &amp;quot;&lt;plur&gt;&amp;quot;.
Now we find that we can still derive the same
plural theorems, but now in addition we get all
these theorems concerning singular:
</bodyText>
<construct confidence="0.681928333333333">
V: &lt;sing&gt; = er.
Al: &lt;sing&gt; = ern.
A2: &lt;sing&gt; = en.
</construct>
<bodyText confidence="0.8973885">
For example, the derivation for the first of these
is as follows:
</bodyText>
<listItem confidence="0.998833333333333">
(1) V: &lt;sing&gt; == CAT. (given)
(2) CAT: &lt;sing&gt; == &amp;quot;&lt;plur&gt;&amp;quot;. (given)
(3) V: &lt;sing&gt; == &amp;quot;&lt;plur&gt;&amp;quot;, (III on 1 and 2)
(4) V: &lt;plur&gt; =-- er. (given)
(5) V: &lt;plur&gt; = er. (Ion 4)
(6) V: &lt;sing&gt; = er. (VII on 3 and 5)
</listItem>
<bodyText confidence="0.99808125">
Finally, given a set of sentences T, we define the
rule-closure of 7, rc1( T) to be the closure of T
under finite application of the above inference
rules in the conventional fashion.
</bodyText>
<sectionHeader confidence="0.995426" genericHeader="method">
4 Default inference
</sectionHeader>
<bodyText confidence="0.999954681818182">
In addition to the conventional inference defined
above, DATR has a nonmonotonic notion of infer-
ence by default: each definitional sentence about
some node/path combination implicitly deter-
mines additional sentences about all the exten-
sions to the path at that node for which no more
specific definitional sentence exists in the theory.
Our overall approach follows Moore (1983,
1985), whose treatment of inferences from sets
of beliefs can be viewed more generally as a
technique for providing a semantics for a
declarative notion of inference by default (cf.
Touretzky 1986, p34; Evans 1987). We begin
with some auxiliary definitions.
The expression PAQ, where P and Q are paths,
denotes the path formed by concatenating com-
ponents of P and Q. A path P2 is an extension
of a path P1 iff there is a path Q such that P2 =
P1AQ. P2 is a strict extension if Q is non-
empty. We also use the A operator to denote
extension of all the paths in a DATR sentence, as
in the following examples:
</bodyText>
<table confidence="0.951756428571429">
- 69 -
S: N:&lt;a&gt; == v.
SA&lt;c d&gt;: N:&lt;a c d&gt; == v.
S: N1:&lt;a&gt; == N2:&lt;x y&gt;.
SA&lt;c d&gt;: N1:&lt;a c d&gt; == N2:&lt;x y c d&gt;.
S: N1:&lt;a&gt; == &amp;quot;N2:&lt;&gt;&amp;quot;.
SA&lt;c d&gt;: N1:&lt;a c d&gt; == &amp;quot;N2:&lt;c d&gt;&amp;quot;.
</table>
<bodyText confidence="0.997725357142857">
Given a sentence S, we define the root of S to
be the [node]:[path] expression appearing to the
left of the equality (`==&apos; or `=&apos;) in S (for exam-
ple the root of &apos;N:P =--- V.&apos; is &apos;N:P)&apos;. The root
does not correspond to any syntactic category
defined above: it is simply a substring of the
sentence.
Given a set of sentences in DATR, T, a node N
and a path P. we say N:P is specified in q- if &apos;T
contains a definitional sentence S whose root is
N:P.
Let Ni :P1, Ni :P2 be such that Ni :P1 is
specified in T. We say Nl:P2 is connected to
Ni :P1 (relative to ,r) if:
</bodyText>
<equation confidence="0.52807">
i) P2 is an extension of P1, and
</equation>
<bodyText confidence="0.962829444444444">
there is no strict extension P3 of P1 of which P2
is an extension such that N1:P3 is specified in T.
So Ni :P2 is connected to Ni :P1 if PI is the
maximal subpath of P2 that is specified (with
Ni) in T.
Now given a set of sentences T, define the path
closure pcl(T) of T to be:
pcl(T) = (S:S is an extensional sentence in )
(S^Q: S is a definitional sentence in T,
with root N:P, and N:PAQ is
connected to N:P)
It is clear from these definitions that any N:P is
connected to itself and thus that T is always a
subset of pd( T). The path closure contains all
those theorems which can be inferred by default
from T.
To illustrate path closure, consider the following
example theory:
</bodyText>
<figure confidence="0.814194833333333">
VERB:
&lt;past&gt; =-- ed
&lt;past participle&gt; == en.
We can infer by default the following theorems
for VERB:
VERB:
&lt;past&gt; =-- ed
&lt;past tense&gt; --= ed
&lt;past participle&gt; == en
&lt;past tense singular&gt; == ed
&lt;past participle plural&gt; --= en
&lt;past tense singular third&gt; == ed.
</figure>
<bodyText confidence="0.994028">
The situation is slightly more complicated with
sentences that have paths on their right-hand
sides. Such paths are also extended by the sub-
path used to extend the left-hand side. So the
sentence:
</bodyText>
<subsectionHeader confidence="0.283321">
A2:&lt;sing&gt; == &amp;quot;AlKplur&gt;&amp;quot;.
</subsectionHeader>
<bodyText confidence="0.987091">
might give rise (by default) to sentences such as:
A2:&lt;sing fern nom&gt; == &amp;quot;Alxplur fern nom&gt;&amp;quot;.
Using default inference, the example theory we
used to illustrate global inference can be phrased
more succinctly:
</bodyText>
<construct confidence="0.753411571428571">
CAT: &lt;sing&gt; == &amp;quot;&lt;plur&gt;&amp;quot;.
V: &lt; &gt; == CAT
&lt;plur&gt; == er,
Al: &lt; &gt; == CAT
&lt;plur&gt; == ern.
A2: &lt;sing&gt; == en
&lt;&gt;== Al.
</construct>
<bodyText confidence="0.9803329375">
In this version, we state that anything not
specifically mentioned for V is inherited (by
default) from CAT, whereas before we had to list
cases (only &apos;sing&apos; in the example) explicitly.
Similarly Al inherits by default from CAT, and
A2 from Al. The operation of path closure is
non-monotonic: if we add more sentences to
our original theory, some of our derived sen-
tences may cease to be true.
The two forms of inference in DATR are com-
bined by taking the path closure of a theory first,
and then applying the inference rules to the
result. In other words, given a theory qc and a
sentence S, S is provable from T if $
rd(pc1( 2)).
- 70 -
</bodyText>
<sectionHeader confidence="0.99035" genericHeader="acknowledgments">
Acknowledgements
</sectionHeader>
<bodyText confidence="0.86820875">
Evans&apos;s work was supported by a grant from the
SERC. Gazdar&apos;s work was supported by grants
from the ESRC and SERC. We are grateful to
our referees and to Jon Cunningham, Walter
Daelemans, David Israel, Bill Keller, Tom Kha-
baza, Ewan Klein, Bob Moore, Fernando
Pereira, Allan Ramsay and Chris Thornton for
clarifying our thinking about aspects of DATR.
</bodyText>
<sectionHeader confidence="0.996676" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.993674219178082">
Brachman, R. (1985) &amp;quot;I lied about the trees&amp;quot;, or
defaults and definitions in knowledge
representation. AI Magazine 6.3, 80-93.
Calder, J. (1989) Paradigmatic morphology.
Proceedings of the Fourth Conference of
the European Chapter of the Association
for Computational Linguistics, UMIST,
April 1989. Morristown, NJ: ACL.
Calder, J. &amp; E. te Linden (1987) The
protolexicon: towards a high-level language
for lexical description. In Ewan Klein &amp;
Johan van Benthem, eds. Categories,
Polymorphism and Unification
Edinburgh/Amsterdam: CCS/ILLI, 356-
370.
Daelemans, W.M.P. (1987a) A tool for the
automatic creation, extension and updating
of lexical knowledge bases. ACL
Proceedings, Third European Conference,
70-74
Daelemans, W.M.P. (1987b) Studies in
language technology: an object-oriented
computer model of morphonological
aspects of Dutch. Doctoral dissertation,
Catholic University of Leuven.
de Smedt, K. (1984) Using object-oriented
knowledge-representation techniques in
morphology and syntax programming. In T.
O&apos;Shea (ed.) ECAI-84: Proceedings of the
Sixth European Conference on Artificial
Intelligence Amsterdam: Elsevier, 181-184.
Etherington, D.W. (1988) Reasoning with
Incomplete Information. Los Altos:
Morgan Kabfmann.
Evans, R. (1987) Towards a formal specification
for defaults in GPSG. In Ewan Klein &amp;
Johan van Benthem, eds. Categories,
Polymorphism and Unification.
Edinburgh/Amsterdam: CCS/ILLI, 73-93.
Evans, R. &amp; Gazdar, G. (1989) The semantics of
DATR. In A. Cohn (ed.) AISB-89,
Proceeedings of the Seventh Conference of
the Society for the Study of Artificial
Intelligence and Simulation of Behaviour.
London: Pitman.
Flickinger, D., Pollard, C.J. &amp; Wasow, T. (1985)
Structure sharing in lexical representation.
Proceedings of the 23rd Annual Meeting of
the Association for Computational
Linguistics (Chicago), 262-267.
Gazdar, G. (1987) Linguistic applications of
default inheritance mechanisms. In Peter J.
Whitelock et al., eds. Linguistic Theory
and Computer Applications. London:
Academic Press, 37-67.
Moore, R.C. (1983) Semantical considerations
on nonmonotonic logic. Technical Note
284, SRI International, Menlo Park.
Revised and expanded version of a paper
that appeared in IJCAI-83, 272-279.
Moore, R.C. (1985) Possible-worlds semantics
for autoepistemic logic. Report No. CSLI-
85-41 , Center for the Study of Language
and Information, Stanford. Also published
in the Proceedings of the AAAI Non-
Monotonic Reasoning Workshop, 344-354.
Shieber, S.M. (1986) An Introduction to
Unification Approaches to Grammar.
Stanford: CSLI/Chicago University Press.
Touretzky, D.F. (1986) The Mathematics of
Inheritance Systems. Los Altos: Morgan
Kaufmann.
- 71 -
</reference>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.733189">
<title confidence="0.997847">in</title>
<author confidence="0.999568">Roger Evans</author>
<author confidence="0.999568">Gerald Gazdar</author>
<affiliation confidence="0.998143">School of Cognitive and Computing Sciences</affiliation>
<address confidence="0.951732">of Sussex, BN1 9QN</address>
<abstract confidence="0.989030142857143">a declarative language for representing a restricted class of inheritance networks, permitting both multiple and default inheritance. The principal intended area of application is the representation of lexical entries for natural language processing, and we use examples from this domain throughout. In this paper we present the syntax and inference mechanisms for language. The goal of the is the design of a simple language that (i) has the necessary expressive power to encode the lexical entries presupposed by contemporary work in the unification grammar tradition, (ii) can express all the evident generalizations about such entries, (iii) has an explicit theory of inference, (iv) is computationally tractable, and (v) has an explicit declarative semantics. The present paper is primarily concerned with (iii), though the examples used may hint at our strategy in respect of (i) and (ii).</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>R Brachman</author>
</authors>
<title>I lied about the trees&amp;quot;, or defaults and definitions in knowledge representation.</title>
<date>1985</date>
<journal>AI Magazine</journal>
<volume>6</volume>
<pages>80--93</pages>
<marker>Brachman, 1985</marker>
<rawString>Brachman, R. (1985) &amp;quot;I lied about the trees&amp;quot;, or defaults and definitions in knowledge representation. AI Magazine 6.3, 80-93.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Calder</author>
</authors>
<title>Paradigmatic morphology.</title>
<date>1989</date>
<booktitle>Proceedings of the Fourth Conference of the European Chapter of the Association for Computational Linguistics, UMIST,</booktitle>
<publisher>ACL.</publisher>
<location>Morristown, NJ:</location>
<contexts>
<context position="1456" citStr="Calder (1989)" startWordPosition="220" endWordPosition="221">nce, (iv) is computationally tractable, and (v) has an explicit declarative semantics. The present paper is primarily concerned with (iii), though the examples used may hint at our strategy in respect of (i) and (ii). 1 Introduction Inheritance networks (&amp;quot;semantic nets&amp;quot;) provide an intuitively appealing way of thinking about the representation of various kinds of knowledge. This fact has not gone unnoticed by a number of researchers working on lexical knowledge representation, e.g. de Smedt (1984), Flickinger et al. (1985), Calder &amp; te Linden (1987), Daelemans (1987a,1987b), Gazdar (1987) and Calder (1989). However, many such networks have been realized in the context of programming systems or programming languages that leave their precise meaning unclear. In the light of Braclunan (1985), Ether. ington (1988) and much other recent work, it ha become apparent that the formal properties oi notations intended to represent inheritance arc highly problematic. Although not discussec here, DATR has a formal semantics (Evans &amp; Gazdar 1989) for which some completeness anc soundness results have been derived. These results, and others (on complexity, for example; will be provided in a subsequent paper. </context>
</contexts>
<marker>Calder, 1989</marker>
<rawString>Calder, J. (1989) Paradigmatic morphology. Proceedings of the Fourth Conference of the European Chapter of the Association for Computational Linguistics, UMIST, April 1989. Morristown, NJ: ACL.</rawString>
</citation>
<citation valid="true">
<title>The protolexicon: towards a high-level language for lexical description.</title>
<date>1987</date>
<booktitle>Categories, Polymorphism and Unification Edinburgh/Amsterdam: CCS/ILLI,</booktitle>
<pages>356--370</pages>
<editor>Calder, J. &amp; E. te</editor>
<location>Linden</location>
<contexts>
<context position="1398" citStr="(1987)" startWordPosition="214" endWordPosition="214">uch entries, (iii) has an explicit theory of inference, (iv) is computationally tractable, and (v) has an explicit declarative semantics. The present paper is primarily concerned with (iii), though the examples used may hint at our strategy in respect of (i) and (ii). 1 Introduction Inheritance networks (&amp;quot;semantic nets&amp;quot;) provide an intuitively appealing way of thinking about the representation of various kinds of knowledge. This fact has not gone unnoticed by a number of researchers working on lexical knowledge representation, e.g. de Smedt (1984), Flickinger et al. (1985), Calder &amp; te Linden (1987), Daelemans (1987a,1987b), Gazdar (1987) and Calder (1989). However, many such networks have been realized in the context of programming systems or programming languages that leave their precise meaning unclear. In the light of Braclunan (1985), Ether. ington (1988) and much other recent work, it ha become apparent that the formal properties oi notations intended to represent inheritance arc highly problematic. Although not discussec here, DATR has a formal semantics (Evans &amp; Gazdar 1989) for which some completeness anc soundness results have been derived. These results, and others (on complex</context>
</contexts>
<marker>1987</marker>
<rawString>Calder, J. &amp; E. te Linden (1987) The protolexicon: towards a high-level language for lexical description. In Ewan Klein &amp; Johan van Benthem, eds. Categories, Polymorphism and Unification Edinburgh/Amsterdam: CCS/ILLI, 356-370.</rawString>
</citation>
<citation valid="true">
<authors>
<author>W M P Daelemans</author>
</authors>
<title>A tool for the automatic creation, extension and updating of lexical knowledge bases.</title>
<date>1987</date>
<booktitle>ACL Proceedings, Third European Conference,</booktitle>
<pages>70--74</pages>
<contexts>
<context position="1415" citStr="Daelemans (1987" startWordPosition="215" endWordPosition="216">ies, (iii) has an explicit theory of inference, (iv) is computationally tractable, and (v) has an explicit declarative semantics. The present paper is primarily concerned with (iii), though the examples used may hint at our strategy in respect of (i) and (ii). 1 Introduction Inheritance networks (&amp;quot;semantic nets&amp;quot;) provide an intuitively appealing way of thinking about the representation of various kinds of knowledge. This fact has not gone unnoticed by a number of researchers working on lexical knowledge representation, e.g. de Smedt (1984), Flickinger et al. (1985), Calder &amp; te Linden (1987), Daelemans (1987a,1987b), Gazdar (1987) and Calder (1989). However, many such networks have been realized in the context of programming systems or programming languages that leave their precise meaning unclear. In the light of Braclunan (1985), Ether. ington (1988) and much other recent work, it ha become apparent that the formal properties oi notations intended to represent inheritance arc highly problematic. Although not discussec here, DATR has a formal semantics (Evans &amp; Gazdar 1989) for which some completeness anc soundness results have been derived. These results, and others (on complexity, for example;</context>
</contexts>
<marker>Daelemans, 1987</marker>
<rawString>Daelemans, W.M.P. (1987a) A tool for the automatic creation, extension and updating of lexical knowledge bases. ACL Proceedings, Third European Conference, 70-74</rawString>
</citation>
<citation valid="true">
<authors>
<author>W M P Daelemans</author>
</authors>
<title>Studies in language technology: an object-oriented computer model of morphonological aspects of Dutch. Doctoral dissertation,</title>
<date>1987</date>
<institution>Catholic University of Leuven.</institution>
<contexts>
<context position="1415" citStr="Daelemans (1987" startWordPosition="215" endWordPosition="216">ies, (iii) has an explicit theory of inference, (iv) is computationally tractable, and (v) has an explicit declarative semantics. The present paper is primarily concerned with (iii), though the examples used may hint at our strategy in respect of (i) and (ii). 1 Introduction Inheritance networks (&amp;quot;semantic nets&amp;quot;) provide an intuitively appealing way of thinking about the representation of various kinds of knowledge. This fact has not gone unnoticed by a number of researchers working on lexical knowledge representation, e.g. de Smedt (1984), Flickinger et al. (1985), Calder &amp; te Linden (1987), Daelemans (1987a,1987b), Gazdar (1987) and Calder (1989). However, many such networks have been realized in the context of programming systems or programming languages that leave their precise meaning unclear. In the light of Braclunan (1985), Ether. ington (1988) and much other recent work, it ha become apparent that the formal properties oi notations intended to represent inheritance arc highly problematic. Although not discussec here, DATR has a formal semantics (Evans &amp; Gazdar 1989) for which some completeness anc soundness results have been derived. These results, and others (on complexity, for example;</context>
</contexts>
<marker>Daelemans, 1987</marker>
<rawString>Daelemans, W.M.P. (1987b) Studies in language technology: an object-oriented computer model of morphonological aspects of Dutch. Doctoral dissertation, Catholic University of Leuven.</rawString>
</citation>
<citation valid="true">
<authors>
<author>K de Smedt</author>
</authors>
<title>Using object-oriented knowledge-representation techniques in morphology and syntax programming. In</title>
<date>1984</date>
<booktitle>ECAI-84: Proceedings of the Sixth European Conference on Artificial Intelligence</booktitle>
<pages>181--184</pages>
<editor>T. O&apos;Shea (ed.)</editor>
<publisher>Elsevier,</publisher>
<location>Amsterdam:</location>
<marker>de Smedt, 1984</marker>
<rawString>de Smedt, K. (1984) Using object-oriented knowledge-representation techniques in morphology and syntax programming. In T. O&apos;Shea (ed.) ECAI-84: Proceedings of the Sixth European Conference on Artificial Intelligence Amsterdam: Elsevier, 181-184.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D W Etherington</author>
</authors>
<title>Reasoning with Incomplete Information.</title>
<date>1988</date>
<publisher>Morgan Kabfmann.</publisher>
<location>Los Altos:</location>
<marker>Etherington, 1988</marker>
<rawString>Etherington, D.W. (1988) Reasoning with Incomplete Information. Los Altos: Morgan Kabfmann.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Evans</author>
</authors>
<title>Towards a formal specification for defaults</title>
<date>1987</date>
<booktitle>Categories, Polymorphism and Unification. Edinburgh/Amsterdam: CCS/ILLI,</booktitle>
<pages>73--93</pages>
<editor>in GPSG. In Ewan Klein &amp; Johan van Benthem, eds.</editor>
<contexts>
<context position="11171" citStr="Evans 1987" startWordPosition="1881" endWordPosition="1882">Default inference In addition to the conventional inference defined above, DATR has a nonmonotonic notion of inference by default: each definitional sentence about some node/path combination implicitly determines additional sentences about all the extensions to the path at that node for which no more specific definitional sentence exists in the theory. Our overall approach follows Moore (1983, 1985), whose treatment of inferences from sets of beliefs can be viewed more generally as a technique for providing a semantics for a declarative notion of inference by default (cf. Touretzky 1986, p34; Evans 1987). We begin with some auxiliary definitions. The expression PAQ, where P and Q are paths, denotes the path formed by concatenating components of P and Q. A path P2 is an extension of a path P1 iff there is a path Q such that P2 = P1AQ. P2 is a strict extension if Q is nonempty. We also use the A operator to denote extension of all the paths in a DATR sentence, as in the following examples: - 69 - S: N:&lt;a&gt; == v. SA&lt;c d&gt;: N:&lt;a c d&gt; == v. S: N1:&lt;a&gt; == N2:&lt;x y&gt;. SA&lt;c d&gt;: N1:&lt;a c d&gt; == N2:&lt;x y c d&gt;. S: N1:&lt;a&gt; == &amp;quot;N2:&lt;&gt;&amp;quot;. SA&lt;c d&gt;: N1:&lt;a c d&gt; == &amp;quot;N2:&lt;c d&gt;&amp;quot;. Given a sentence S, we define the root of S </context>
</contexts>
<marker>Evans, 1987</marker>
<rawString>Evans, R. (1987) Towards a formal specification for defaults in GPSG. In Ewan Klein &amp; Johan van Benthem, eds. Categories, Polymorphism and Unification. Edinburgh/Amsterdam: CCS/ILLI, 73-93.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Evans</author>
<author>G Gazdar</author>
</authors>
<title>The semantics of DATR.</title>
<date>1989</date>
<booktitle>AISB-89, Proceeedings of the Seventh Conference of the Society for the Study of Artificial Intelligence and Simulation of Behaviour.</booktitle>
<editor>In A. Cohn (ed.)</editor>
<publisher>Pitman.</publisher>
<location>London:</location>
<contexts>
<context position="1891" citStr="Evans &amp; Gazdar 1989" startWordPosition="284" endWordPosition="287">earchers working on lexical knowledge representation, e.g. de Smedt (1984), Flickinger et al. (1985), Calder &amp; te Linden (1987), Daelemans (1987a,1987b), Gazdar (1987) and Calder (1989). However, many such networks have been realized in the context of programming systems or programming languages that leave their precise meaning unclear. In the light of Braclunan (1985), Ether. ington (1988) and much other recent work, it ha become apparent that the formal properties oi notations intended to represent inheritance arc highly problematic. Although not discussec here, DATR has a formal semantics (Evans &amp; Gazdar 1989) for which some completeness anc soundness results have been derived. These results, and others (on complexity, for example; will be provided in a subsequent paper. There are several prototype computational implementa. tions of the language, and non-trivial lexicor fragments for English, German and Latin have been developed and tested. 2 Syntax The syntax of DATR, especially the use of value terminated attribute trees to encode information derives from PATR (Shieber 1986). The language consists of strings of symbols drawn from the se S&apos;YM = {:, &amp;quot;, =, ==, &lt;, &gt;, (, )} and the set: ATOM and NODE,</context>
</contexts>
<marker>Evans, Gazdar, 1989</marker>
<rawString>Evans, R. &amp; Gazdar, G. (1989) The semantics of DATR. In A. Cohn (ed.) AISB-89, Proceeedings of the Seventh Conference of the Society for the Study of Artificial Intelligence and Simulation of Behaviour. London: Pitman.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D Flickinger</author>
<author>C J Pollard</author>
<author>T Wasow</author>
</authors>
<title>Structure sharing in lexical representation.</title>
<date>1985</date>
<booktitle>Proceedings of the 23rd Annual Meeting of the Association for Computational Linguistics (Chicago),</booktitle>
<pages>262--267</pages>
<contexts>
<context position="1371" citStr="Flickinger et al. (1985)" startWordPosition="206" endWordPosition="209">press all the evident generalizations about such entries, (iii) has an explicit theory of inference, (iv) is computationally tractable, and (v) has an explicit declarative semantics. The present paper is primarily concerned with (iii), though the examples used may hint at our strategy in respect of (i) and (ii). 1 Introduction Inheritance networks (&amp;quot;semantic nets&amp;quot;) provide an intuitively appealing way of thinking about the representation of various kinds of knowledge. This fact has not gone unnoticed by a number of researchers working on lexical knowledge representation, e.g. de Smedt (1984), Flickinger et al. (1985), Calder &amp; te Linden (1987), Daelemans (1987a,1987b), Gazdar (1987) and Calder (1989). However, many such networks have been realized in the context of programming systems or programming languages that leave their precise meaning unclear. In the light of Braclunan (1985), Ether. ington (1988) and much other recent work, it ha become apparent that the formal properties oi notations intended to represent inheritance arc highly problematic. Although not discussec here, DATR has a formal semantics (Evans &amp; Gazdar 1989) for which some completeness anc soundness results have been derived. These resu</context>
</contexts>
<marker>Flickinger, Pollard, Wasow, 1985</marker>
<rawString>Flickinger, D., Pollard, C.J. &amp; Wasow, T. (1985) Structure sharing in lexical representation. Proceedings of the 23rd Annual Meeting of the Association for Computational Linguistics (Chicago), 262-267.</rawString>
</citation>
<citation valid="true">
<authors>
<author>G Gazdar</author>
</authors>
<title>Linguistic applications of default inheritance mechanisms.</title>
<date>1987</date>
<booktitle>Linguistic Theory and Computer Applications.</booktitle>
<pages>37--67</pages>
<editor>In Peter J. Whitelock et al., eds.</editor>
<publisher>Academic Press,</publisher>
<location>London:</location>
<contexts>
<context position="1438" citStr="Gazdar (1987)" startWordPosition="217" endWordPosition="218">t theory of inference, (iv) is computationally tractable, and (v) has an explicit declarative semantics. The present paper is primarily concerned with (iii), though the examples used may hint at our strategy in respect of (i) and (ii). 1 Introduction Inheritance networks (&amp;quot;semantic nets&amp;quot;) provide an intuitively appealing way of thinking about the representation of various kinds of knowledge. This fact has not gone unnoticed by a number of researchers working on lexical knowledge representation, e.g. de Smedt (1984), Flickinger et al. (1985), Calder &amp; te Linden (1987), Daelemans (1987a,1987b), Gazdar (1987) and Calder (1989). However, many such networks have been realized in the context of programming systems or programming languages that leave their precise meaning unclear. In the light of Braclunan (1985), Ether. ington (1988) and much other recent work, it ha become apparent that the formal properties oi notations intended to represent inheritance arc highly problematic. Although not discussec here, DATR has a formal semantics (Evans &amp; Gazdar 1989) for which some completeness anc soundness results have been derived. These results, and others (on complexity, for example; will be provided in a </context>
</contexts>
<marker>Gazdar, 1987</marker>
<rawString>Gazdar, G. (1987) Linguistic applications of default inheritance mechanisms. In Peter J. Whitelock et al., eds. Linguistic Theory and Computer Applications. London: Academic Press, 37-67.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R C Moore</author>
</authors>
<title>Semantical considerations on nonmonotonic logic. Technical Note 284, SRI International, Menlo Park. Revised and expanded version of a paper that appeared in IJCAI-83,</title>
<date>1983</date>
<pages>272--279</pages>
<contexts>
<context position="10955" citStr="Moore (1983" startWordPosition="1846" endWordPosition="1847">&lt;sing&gt; = er. (VII on 3 and 5) Finally, given a set of sentences T, we define the rule-closure of 7, rc1( T) to be the closure of T under finite application of the above inference rules in the conventional fashion. 4 Default inference In addition to the conventional inference defined above, DATR has a nonmonotonic notion of inference by default: each definitional sentence about some node/path combination implicitly determines additional sentences about all the extensions to the path at that node for which no more specific definitional sentence exists in the theory. Our overall approach follows Moore (1983, 1985), whose treatment of inferences from sets of beliefs can be viewed more generally as a technique for providing a semantics for a declarative notion of inference by default (cf. Touretzky 1986, p34; Evans 1987). We begin with some auxiliary definitions. The expression PAQ, where P and Q are paths, denotes the path formed by concatenating components of P and Q. A path P2 is an extension of a path P1 iff there is a path Q such that P2 = P1AQ. P2 is a strict extension if Q is nonempty. We also use the A operator to denote extension of all the paths in a DATR sentence, as in the following ex</context>
</contexts>
<marker>Moore, 1983</marker>
<rawString>Moore, R.C. (1983) Semantical considerations on nonmonotonic logic. Technical Note 284, SRI International, Menlo Park. Revised and expanded version of a paper that appeared in IJCAI-83, 272-279.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R C Moore</author>
</authors>
<title>Possible-worlds semantics for autoepistemic logic.</title>
<date>1985</date>
<booktitle>Center for the Study of Language and Information, Stanford. Also published in the Proceedings of the AAAI NonMonotonic Reasoning Workshop,</booktitle>
<tech>Report No. CSLI85-41</tech>
<pages>344--354</pages>
<marker>Moore, 1985</marker>
<rawString>Moore, R.C. (1985) Possible-worlds semantics for autoepistemic logic. Report No. CSLI85-41 , Center for the Study of Language and Information, Stanford. Also published in the Proceedings of the AAAI NonMonotonic Reasoning Workshop, 344-354.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S M Shieber</author>
</authors>
<title>An Introduction to Unification Approaches to Grammar. Stanford:</title>
<date>1986</date>
<publisher>CSLI/Chicago University Press.</publisher>
<contexts>
<context position="2367" citStr="Shieber 1986" startWordPosition="357" endWordPosition="358"> intended to represent inheritance arc highly problematic. Although not discussec here, DATR has a formal semantics (Evans &amp; Gazdar 1989) for which some completeness anc soundness results have been derived. These results, and others (on complexity, for example; will be provided in a subsequent paper. There are several prototype computational implementa. tions of the language, and non-trivial lexicor fragments for English, German and Latin have been developed and tested. 2 Syntax The syntax of DATR, especially the use of value terminated attribute trees to encode information derives from PATR (Shieber 1986). The language consists of strings of symbols drawn from the se S&apos;YM = {:, &amp;quot;, =, ==, &lt;, &gt;, (, )} and the set: ATOM and NODE, all of which are disjoint. A string is in DATR, (with respect to given set: ATOM of [atom]s and NODE of [node]s) if it is [sentence] as defined by the following set 01 rules: node]: [path] == [lvalue]. (nodellpath] = [value]. [latom] I ([lseq] ) [gatom] I ([gseq] ) [atom] I ( [sa] ) [desc] I [gatom] &amp;quot;[desc]&amp;quot; I [atom] [sentence] ::= [ivalue] ::= [gvalue] ::= [value] ::= [latom] ::= [gatom] ::= - 66 - [desc] ::= [node] I [lpath] I [node]:[1path] [gsect] I [Iseq] Riese] [ls</context>
</contexts>
<marker>Shieber, 1986</marker>
<rawString>Shieber, S.M. (1986) An Introduction to Unification Approaches to Grammar. Stanford: CSLI/Chicago University Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D F Touretzky</author>
</authors>
<title>The Mathematics of Inheritance Systems.</title>
<date>1986</date>
<publisher>Morgan Kaufmann.</publisher>
<location>Los Altos:</location>
<contexts>
<context position="11153" citStr="Touretzky 1986" startWordPosition="1878" endWordPosition="1879">ventional fashion. 4 Default inference In addition to the conventional inference defined above, DATR has a nonmonotonic notion of inference by default: each definitional sentence about some node/path combination implicitly determines additional sentences about all the extensions to the path at that node for which no more specific definitional sentence exists in the theory. Our overall approach follows Moore (1983, 1985), whose treatment of inferences from sets of beliefs can be viewed more generally as a technique for providing a semantics for a declarative notion of inference by default (cf. Touretzky 1986, p34; Evans 1987). We begin with some auxiliary definitions. The expression PAQ, where P and Q are paths, denotes the path formed by concatenating components of P and Q. A path P2 is an extension of a path P1 iff there is a path Q such that P2 = P1AQ. P2 is a strict extension if Q is nonempty. We also use the A operator to denote extension of all the paths in a DATR sentence, as in the following examples: - 69 - S: N:&lt;a&gt; == v. SA&lt;c d&gt;: N:&lt;a c d&gt; == v. S: N1:&lt;a&gt; == N2:&lt;x y&gt;. SA&lt;c d&gt;: N1:&lt;a c d&gt; == N2:&lt;x y c d&gt;. S: N1:&lt;a&gt; == &amp;quot;N2:&lt;&gt;&amp;quot;. SA&lt;c d&gt;: N1:&lt;a c d&gt; == &amp;quot;N2:&lt;c d&gt;&amp;quot;. Given a sentence S, we def</context>
</contexts>
<marker>Touretzky, 1986</marker>
<rawString>Touretzky, D.F. (1986) The Mathematics of Inheritance Systems. Los Altos: Morgan Kaufmann.</rawString>
</citation>
<citation valid="false">
<pages>71</pages>
<marker></marker>
<rawString>- 71 -</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>