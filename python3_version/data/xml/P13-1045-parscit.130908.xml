<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.002212">
<title confidence="0.893069">
Parsing with Compositional Vector Grammars
</title>
<author confidence="0.935945">
Richard Socher John Bauer Christopher D. Manning Andrew Y. Ng
</author>
<affiliation confidence="0.948419">
Computer Science Department, Stanford University, Stanford, CA 94305, USA
</affiliation>
<email confidence="0.959847">
richard@socher.org, horatio@gmail.com, manning@stanford.edu, ang@cs.stanford.edu
</email>
<sectionHeader confidence="0.994521" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999982958333334">
Natural language parsing has typically
been done with small sets of discrete cat-
egories such as NP and VP, but this rep-
resentation does not capture the full syn-
tactic nor semantic richness of linguistic
phrases, and attempts to improve on this
by lexicalizing phrases or splitting cate-
gories only partly address the problem at
the cost of huge feature spaces and sparse-
ness. Instead, we introduce a Compo-
sitional Vector Grammar (CVG), which
combines PCFGs with a syntactically un-
tied recursive neural network that learns
syntactico-semantic, compositional vector
representations. The CVG improves the
PCFG of the Stanford Parser by 3.8% to
obtain an F1 score of 90.4%. It is fast
to train and implemented approximately as
an efficient reranker it is about 20% faster
than the current Stanford factored parser.
The CVG learns a soft notion of head
words and improves performance on the
types of ambiguities that require semantic
information such as PP attachments.
</bodyText>
<sectionHeader confidence="0.998881" genericHeader="introduction">
1 Introduction
</sectionHeader>
<bodyText confidence="0.999457769230769">
Syntactic parsing is a central task in natural lan-
guage processing because of its importance in me-
diating between linguistic expression and mean-
ing. For example, much work has shown the use-
fulness of syntactic representations for subsequent
tasks such as relation extraction, semantic role la-
beling (Gildea and Palmer, 2002) and paraphrase
detection (Callison-Burch, 2008).
Syntactic descriptions standardly use coarse
discrete categories such as NP for noun phrases
or PP for prepositional phrases. However, recent
work has shown that parsing results can be greatly
improved by defining more fine-grained syntactic
</bodyText>
<figure confidence="0.772042">
Discrete Syntactic – Continuous Semantic
Representations in the Compositional Vector Grammar
</figure>
<figureCaption confidence="0.994516">
Figure 1: Example of a CVG tree with (cate-
</figureCaption>
<bodyText confidence="0.996664137931034">
gory,vector) representations at each node. The
vectors for nonterminals are computed via a new
type of recursive neural network which is condi-
tioned on syntactic categories from a PCFG.
categories, which better capture phrases with simi-
lar behavior, whether through manual feature engi-
neering (Klein and Manning, 2003a) or automatic
learning (Petrov et al., 2006). However, subdi-
viding a category like NP into 30 or 60 subcate-
gories can only provide a very limited represen-
tation of phrase meaning and semantic similarity.
Two strands of work therefore attempt to go fur-
ther. First, recent work in discriminative parsing
has shown gains from careful engineering of fea-
tures (Taskar et al., 2004; Finkel et al., 2008). Fea-
tures in such parsers can be seen as defining effec-
tive dimensions of similarity between categories.
Second, lexicalized parsers (Collins, 2003; Char-
niak, 2000) associate each category with a lexical
item. This gives a fine-grained notion of semantic
similarity, which is useful for tackling problems
like ambiguous attachment decisions. However,
this approach necessitates complex shrinkage esti-
mation schemes to deal with the sparsity of obser-
vations of the lexicalized categories.
In many natural language systems, single words
and n-grams are usefully described by their distri-
butional similarities (Brown et al., 1992), among
many others. But, even with large corpora, many
</bodyText>
<equation confidence="0.599664">
(riding a bike,VP, )
(a bike,NP, )
(riding,V, ) (a,Det, ) (bike,NN, )
</equation>
<page confidence="0.987779">
455
</page>
<note confidence="0.9138445">
Proceedings of the 51st Annual Meeting of the Association for Computational Linguistics, pages 455–465,
Sofia, Bulgaria, August 4-9 2013. c�2013 Association for Computational Linguistics
</note>
<bodyText confidence="0.9999225625">
n-grams will never be seen during training, espe-
cially when n is large. In these cases, one cannot
simply use distributional similarities to represent
unseen phrases. In this work, we present a new so-
lution to learn features and phrase representations
even for very long, unseen n-grams.
We introduce a Compositional Vector Grammar
Parser (CVG) for structure prediction. Like the
above work on parsing, the model addresses the
problem of representing phrases and categories.
Unlike them, it jointly learns how to parse and how
to represent phrases as both discrete categories and
continuous vectors as illustrated in Fig. 1. CVGs
combine the advantages of standard probabilistic
context free grammars (PCFG) with those of re-
cursive neural networks (RNNs). The former can
capture the discrete categorization of phrases into
NP or PP while the latter can capture fine-grained
syntactic and compositional-semantic information
on phrases and words. This information can help
in cases where syntactic ambiguity can only be re-
solved with semantic information, such as in the
PP attachment of the two sentences: They ate udon
with forks. vs. They ate udon with chicken.
Previous RNN-based parsers used the same
(tied) weights at all nodes to compute the vector
representing a constituent (Socher et al., 2011b).
This requires the composition function to be ex-
tremely powerful, since it has to combine phrases
with different syntactic head words, and it is hard
to optimize since the parameters form a very deep
neural network. We generalize the fully tied RNN
to one with syntactically untied weights. The
weights at each node are conditionally dependent
on the categories of the child constituents. This
allows different composition functions when com-
bining different types of phrases and is shown to
result in a large improvement in parsing accuracy.
Our compositional distributed representation al-
lows a CVG parser to make accurate parsing de-
cisions and capture similarities between phrases
and sentences. Any PCFG-based parser can be im-
proved with an RNN. We use a simplified version
of the Stanford Parser (Klein and Manning, 2003a)
as the base PCFG and improve its accuracy from
86.56 to 90.44% labeled F1 on all sentences of the
WSJ section 23. The code of our parser is avail-
able at nlp.stanford.edu.
</bodyText>
<sectionHeader confidence="0.999648" genericHeader="related work">
2 Related Work
</sectionHeader>
<bodyText confidence="0.999855">
The CVG is inspired by two lines of research:
Enriching PCFG parsers through more diverse
sets of discrete states and recursive deep learning
models that jointly learn classifiers and continuous
feature representations for variable-sized inputs.
</bodyText>
<subsectionHeader confidence="0.538596">
Improving Discrete Syntactic Representations
</subsectionHeader>
<bodyText confidence="0.998078888888889">
As mentioned in the introduction, there are several
approaches to improving discrete representations
for parsing. Klein and Manning (2003a) use
manual feature engineering, while Petrov et
al. (2006) use a learning algorithm that splits
and merges the syntactic categories in order
to maximize likelihood on the treebank. Their
approach splits categories into several dozen
subcategories. Another approach is lexicalized
parsers (Collins, 2003; Charniak, 2000) that
describe each category with a lexical item, usually
the head word. More recently, Hall and Klein
(2012) combine several such annotation schemes
in a factored parser. We extend the above ideas
from discrete representations to richer continuous
ones. The CVG can be seen as factoring discrete
and continuous parsing in one model. Another
different approach to the above generative models
is to learn discriminative parsers using many well
designed features (Taskar et al., 2004; Finkel et
al., 2008). We also borrow ideas from this line of
research in that our parser combines the generative
PCFG model with discriminatively learned RNNs.
Deep Learning and Recursive Deep Learning
Early attempts at using neural networks to de-
scribe phrases include Elman (1991), who used re-
current neural networks to create representations
of sentences from a simple toy grammar and to
analyze the linguistic expressiveness of the re-
sulting representations. Words were represented
as one-on vectors, which was feasible since the
grammar only included a handful of words. Col-
lobert and Weston (2008) showed that neural net-
works can perform well on sequence labeling lan-
guage processing tasks while also learning appro-
priate features. However, their model is lacking
in that it cannot represent the recursive structure
inherent in natural language. They partially cir-
cumvent this problem by using either independent
window-based classifiers or a convolutional layer.
RNN-specific training was introduced by Goller
and K¨uchler (1996) to learn distributed represen-
tations of given, structured objects such as logi-
cal terms. In contrast, our model both predicts the
structure and its representation.
</bodyText>
<page confidence="0.998563">
456
</page>
<bodyText confidence="0.999977952380952">
Henderson (2003) was the first to show that neu-
ral networks can be successfully used for large
scale parsing. He introduced a left-corner parser to
estimate the probabilities of parsing decisions con-
ditioned on the parsing history. The input to Hen-
derson’s model consists of pairs of frequent words
and their part-of-speech (POS) tags. Both the orig-
inal parsing system and its probabilistic interpre-
tation (Titov and Henderson, 2007) learn features
that represent the parsing history and do not pro-
vide a principled linguistic representation like our
phrase representations. Other related work in-
cludes (Henderson, 2004), who discriminatively
trains a parser based on synchrony networks and
(Titov and Henderson, 2006), who use an SVM to
adapt a generative parser to different domains.
Costa et al. (2003) apply recursive neural net-
works to re-rank possible phrase attachments in
an incremental parser. Their work is the first to
show that RNNs can capture enough information
to make correct parsing decisions, but they only
test on a subset of 2000 sentences. Menchetti et
al. (2005) use RNNs to re-rank different parses.
For their results on full sentence parsing, they re-
rank candidate trees created by the Collins parser
(Collins, 2003). Similar to their work, we use the
idea of letting discrete categories reduce the search
space during inference. We compare to fully tied
RNNs in which the same weights are used at every
node. Our syntactically untied RNNs outperform
them by a significant margin. The idea of untying
has also been successfully used in deep learning
applied to vision (Le et al., 2010).
This paper uses several ideas of (Socher et al.,
2011b). The main differences are (i) the dual
representation of nodes as discrete categories and
vectors, (ii) the combination with a PCFG, and
(iii) the syntactic untying of weights based on
child categories. We directly compare models with
fully tied and untied weights. Another work that
represents phrases with a dual discrete-continuous
representation is (Kartsaklis et al., 2012).
</bodyText>
<sectionHeader confidence="0.983456" genericHeader="method">
3 Compositional Vector Grammars
</sectionHeader>
<bodyText confidence="0.999882347826087">
This section introduces Compositional Vector
Grammars (CVGs), a model to jointly find syntac-
tic structure and capture compositional semantic
information.
CVGs build on two observations. Firstly, that a
lot of the structure and regularity in languages can
be captured by well-designed syntactic patterns.
Hence, the CVG builds on top of a standard PCFG
parser. However, many parsing decisions show
fine-grained semantic factors at work. Therefore
we combine syntactic and semantic information
by giving the parser access to rich syntactico-
semantic information in the form of distributional
word vectors and compute compositional semantic
vector representations for longer phrases (Costa
et al., 2003; Menchetti et al., 2005; Socher et
al., 2011b). The CVG model merges ideas from
both generative models that assume discrete syn-
tactic categories and discriminative models that
are trained using continuous vectors.
We will first briefly introduce single word vec-
tor representations and then describe the CVG ob-
jective function, tree scoring and inference.
</bodyText>
<subsectionHeader confidence="0.998938">
3.1 Word Vector Representations
</subsectionHeader>
<bodyText confidence="0.999891757575757">
In most systems that use a vector representa-
tion for words, such vectors are based on co-
occurrence statistics of each word and its context
(Turney and Pantel, 2010). Another line of re-
search to learn distributional word vectors is based
on neural language models (Bengio et al., 2003)
which jointly learn an embedding of words into an
n-dimensional feature space and use these embed-
dings to predict how suitable a word is in its con-
text. These vector representations capture inter-
esting linear relationships (up to some accuracy),
such as king−man+woman ≈ queen (Mikolov
et al., 2013).
Collobert and Weston (2008) introduced a new
model to compute such an embedding. The idea
is to construct a neural network that outputs high
scores for windows that occur in a large unla-
beled corpus and low scores for windows where
one word is replaced by a random word. When
such a network is optimized via gradient ascent the
derivatives backpropagate into the word embed-
ding matrix X. In order to predict correct scores
the vectors in the matrix capture co-occurrence
statistics.
For further details and evaluations of these em-
beddings, see (Turian et al., 2010; Huang et al.,
2012). The resulting X matrix is used as follows.
Assume we are given a sentence as an ordered list
of m words. Each word w has an index [w] = i
into the columns of the embedding matrix. This
index is used to retrieve the word’s vector repre-
sentation a,,, using a simple multiplication with a
binary vector e, which is zero everywhere, except
</bodyText>
<page confidence="0.991678">
457
</page>
<bodyText confidence="0.998909625">
at the ith index. So aw = Lei E Rn. Henceforth,
after mapping each word to its vector, we represent
a sentence S as an ordered list of (word,vector)
pairs: x = ((w1, aw1), ... , (wm, awm)).
Now that we have discrete and continuous rep-
resentations for all words, we can continue with
the approach for computing tree structures and
vectors for nonterminal nodes.
</bodyText>
<subsectionHeader confidence="0.987117">
3.2 Max-Margin Training Objective for
CVGs
</subsectionHeader>
<bodyText confidence="0.999978076923077">
The goal of supervised parsing is to learn a func-
tion g : X -+ Y, where X is the set of sentences
and Y is the set of all possible labeled binary parse
trees. The set of all possible trees for a given sen-
tence xi is defined as Y (xi) and the correct tree
for a sentence is yi.
We first define a structured margin loss A(yi, ˆy)
for predicting a tree yˆ for a given correct tree.
The loss increases the more incorrect the proposed
parse tree is (Goodman, 1998). The discrepancy
between trees is measured by counting the number
of nodes N(y) with an incorrect span (or label) in
the proposed tree:
</bodyText>
<equation confidence="0.991634">
A(yi, ˆy) = X κ1{d E/ N(yi)J. (1)
dEN(ˆy)
</equation>
<bodyText confidence="0.999517">
We set κ = 0.1 in all experiments. For a given
set of training instances (xi, yi), we search for the
function gθ, parameterized by θ, with the smallest
expected loss on a new sentence. It has the follow-
ing form:
</bodyText>
<equation confidence="0.9998515">
gθ(x) = arg max s(CVG(θ, x, ˆy)), (2)
ˆyEY (x)
</equation>
<bodyText confidence="0.998396083333333">
where the tree is found by the Compositional Vec-
tor Grammar (CVG) introduced below and then
scored via the function s. The higher the score of
a tree the more confident the algorithm is that its
structure is correct. This max-margin, structure-
prediction objective (Taskar et al., 2004; Ratliff
et al., 2007; Socher et al., 2011b) trains the CVG
so that the highest scoring tree will be the correct
tree: gθ(xi) = yi and its score will be larger up to
a margin to other possible trees yˆ E Y(xi):
s(CVG(θ, xi, yi)) &gt;— s(CVG(θ, xi, ˆy)) + A(yi, ˆy).
This leads to the regularized risk function for m
</bodyText>
<equation confidence="0.963007833333333">
training examples:
λ
ri(θ) + 2 11θ1122, where
ri(θ) = max (s(CVG(xi, ˆy)) + A(yi, ˆy))
ˆyEY (xi)
− s(CVG(xi, yi)) (3)
</equation>
<bodyText confidence="0.999795333333333">
Intuitively, to minimize this objective, the score of
the correct tree yi is increased and the score of the
highest scoring incorrect tree yˆ is decreased.
</bodyText>
<subsectionHeader confidence="0.998985">
3.3 Scoring Trees with CVGs
</subsectionHeader>
<bodyText confidence="0.986786583333333">
For ease of exposition, we first describe how to
score an existing fully labeled tree with a standard
RNN and then with a CVG. The subsequent sec-
tion will then describe a bottom-up beam search
and its approximation for finding the optimal tree.
Assume, for now, we are given a labeled
parse tree as shown in Fig. 2. We define
the word representations as (vector, POS) pairs:
((a, A), (b, B), (c, C)), where the vectors are de-
fined as in Sec. 3.1 and the POS tags come from
a PCFG. The standard RNN essentially ignores all
POS tags and syntactic categories and each non-
terminal node is associated with the same neural
network (i.e., the weights across nodes are fully
tied). We can represent the binary tree in Fig. 2
in the form of branching triplets (p -+ c1c2).
Each such triplet denotes that a parent node p has
two children and each ck can be either a word
vector or a non-terminal node in the tree. For
the example in Fig. 2, we would get the triples
((p1 -+ bc), (p2 -+ ap1)). Note that in order
to replicate the neural network and compute node
representations in a bottom up fashion, the parent
must have the same dimensionality as the children:
p E Rn.
Given this tree structure, we can now compute
activations for each node from the bottom up. We
begin by computing the activation for p1 using
the children’s word vectors. We first concatenate
the children’s representations b, c E Rnx1 into a
E R2nx1. Then the composition
function multiplies this vector by the parameter
weights of the RNN W E Rnx2n and applies an
element-wise nonlinearity function f = tanh to
the output vector. The resulting output p(1) is then
given as input to compute p(2).
</bodyText>
<equation confidence="0.97955875">
p(1) = f CW [ b J / p(2) = f \W [ a1 J /
1
J(θ) = m
Xm
i=1
� b �
c
vector
</equation>
<page confidence="0.971261">
458
</page>
<figure confidence="0.997743666666666">
Standard Recursive Neural Network
(A, a= ) (B, b= ) (C, c= )
P(2), p(2)=
P(1), p(1)=
= f
a
W p(1)
= f
W
b
c
Syntactically Untied Recursive Neural Network
(A, a= ) (B, b= ) (C, c= )
P(2), p(2)=
P(1), p(1)=
= f
(1)
W(A,P )
= f
a
p(1)
W(B,C)
b
c
</figure>
<figureCaption confidence="0.991694">
Figure 2: An example tree with a simple Recursive
Neural Network: The same weight matrix is repli-
cated and used to compute all non-terminal node
representations. Leaf nodes are n-dimensional
vector representations of words.
</figureCaption>
<bodyText confidence="0.999081666666667">
In order to compute a score of how plausible of
a syntactic constituent a parent is the RNN uses a
single-unit linear layer for all i:
</bodyText>
<equation confidence="0.950672">
s(p(i)) = vTp(i),
</equation>
<bodyText confidence="0.989114964912281">
where v ∈ Rn is a vector of parameters that need
to be trained. This score will be used to find the
highest scoring tree. For more details on how stan-
dard RNNs can be used for parsing, see Socher et
al. (2011b).
The standard RNN requires a single composi-
tion function to capture all types of compositions:
adjectives and nouns, verbs and nouns, adverbs
and adjectives, etc. Even though this function is
a powerful one, we find a single neural network
weight matrix cannot fully capture the richness of
compositionality. Several extensions are possible:
A two-layered RNN would provide more expres-
sive power, however, it is much harder to train be-
cause the resulting neural network becomes very
deep and suffers from vanishing gradient prob-
lems. Socher et al. (2012) proposed to give ev-
ery single word a matrix and a vector. The ma-
trix is then applied to the sibling node’s vector
during the composition. While this results in a
powerful composition function that essentially de-
pends on the words being combined, the number
of model parameters explodes and the composi-
tion functions do not capture the syntactic com-
monalities between similar POS tags or syntactic
categories.
Based on the above considerations, we propose
the Compositional Vector Grammar (CVG) that
conditions the composition function at each node
on discrete syntactic categories extracted from a
Figure 3: Example of a syntactically untied RNN
in which the function to compute a parent vector
depends on the syntactic categories of its children
which we assume are given for now.
PCFG. Hence, CVGs combine discrete, syntactic
rule probabilities and continuous vector composi-
tions. The idea is that the syntactic categories of
the children determine what composition function
to use for computing the vector of their parents.
While not perfect, a dedicated composition func-
tion for each rule RHS can well capture common
composition processes such as adjective or adverb
modification versus noun or clausal complementa-
tion. For instance, it could learn that an NP should
be similar to its head noun and little influenced by
a determiner, whereas in an adjective modification
both words considerably determine the meaning of
a phrase. The original RNN is parameterized by a
single weight matrix W. In contrast, the CVG uses
a syntactically untied RNN (SU-RNN) which has
a set of such weights. The size of this set depends
on the number of sibling category combinations in
the PCFG.
Fig. 3 shows an example SU-RNN that com-
putes parent vectors with syntactically untied
weights. The CVG computes the first parent vec-
tor via the SU-RNN:
</bodyText>
<equation confidence="0.977915666666667">
� � b ��
p(1) = f W (B,C) ,
c
</equation>
<bodyText confidence="0.999934571428571">
where W(B,C) ∈ Rn×2n is now a matrix that de-
pends on the categories of the two children. In
this bottom up procedure, the score for each node
consists of summing two elements: First, a single
linear unit that scores the parent vector and sec-
ond, the log probability of the PCFG for the rule
that combines these two children:
</bodyText>
<equation confidence="0.981050666666667">
�p(1)� = �v(B,C)�T p(1) + log P(P1 → B C),
s
(4)
</equation>
<page confidence="0.980395">
459
</page>
<bodyText confidence="0.9979585">
where P(P1 -+ B C) comes from the PCFG.
This can be interpreted as the log probability of a
discrete-continuous rule application with the fol-
lowing factorization:
</bodyText>
<equation confidence="0.995605">
P((P1,p1) -+ (B, b)(C, c)) (5)
= P(p1 -+ b c|P1 -+ B C)P(P1 -+ B C),
</equation>
<bodyText confidence="0.999765285714286">
Note, however, that due to the continuous nature
of the word vectors, the probability of such a CVG
rule application is not comparable to probabilities
provided by a PCFG since the latter sum to 1 for
all children.
Assuming that node p1 has syntactic category
P1, we compute the second parent vector via:
</bodyText>
<equation confidence="0.986879">
\ � a J�
p(2) = f W (A,P1) .
p(1)
</equation>
<bodyText confidence="0.787163">
The score of the last parent in this trigram is com-
puted via:
</bodyText>
<equation confidence="0.9373125">
�p(2)� = �V(A,P1)�Tp(2) + log P(P2 -+ A P1).
s
</equation>
<subsectionHeader confidence="0.997569">
3.4 Parsing with CVGs
</subsectionHeader>
<bodyText confidence="0.985981471698113">
The above scores (Eq. 4) are used in the search for
the correct tree for a sentence. The goodness of a
tree is measured in terms of its score and the CVG
score of a complete tree is the sum of the scores at
each node:
� �pd�
s(CVG(θ, x, ˆy)) = s . (6)
d∈N(ˆy)
The main objective function in Eq. 3 includes a
maximization over all possible trees maxˆy∈Y (x).
Finding the global maximum, however, cannot be
done efficiently for longer sentences nor can we
use dynamic programming. This is due to the fact
that the vectors break the independence assump-
tions of the base PCFG. A (category, vector) node
representation is dependent on all the words in its
span and hence to find the true global optimum,
we would have to compute the scores for all bi-
nary trees. For a sentence of length n, there are
Catalan(n) many possible binary trees which is
very large even for moderately long sentences.
One could use a bottom-up beam search, keep-
ing a k-best list at every cell of the chart, possibly
for each syntactic category. This beam search in-
ference procedure is still considerably slower than
using only the simplified base PCFG, especially
since it has a small state space (see next section for
details). Since each probability look-up is cheap
but computing SU-RNN scores requires a matrix
product, we would like to reduce the number of
SU-RNN score computations to only those trees
that require semantic information. We note that
labeled F1 of the Stanford PCFG parser on the test
set is 86.17%. However, if one used an oracle to
select the best tree from the top 200 trees that it
produces, one could get an F1 of 95.46%.
We use this knowledge to speed up inference via
two bottom-up passes through the parsing chart.
During the first one, we use only the base PCFG to
run CKY dynamic programming through the tree.
The k = 200-best parses at the top cell of the
chart are calculated using the efficient algorithm
of (Huang and Chiang, 2005). Then, the second
pass is a beam search with the full CVG model (in-
cluding the more expensive matrix multiplications
of the SU-RNN). This beam search only consid-
ers phrases that appear in the top 200 parses. This
is similar to a re-ranking setup but with one main
difference: the SU-RNN rule score computation at
each node still only has access to its child vectors,
not the whole tree or other global features. This
allows the second pass to be very fast. We use this
setup in our experiments below.
</bodyText>
<subsectionHeader confidence="0.899356">
3.5 Training SU-RNNs
</subsectionHeader>
<bodyText confidence="0.999960476190476">
The full CVG model is trained in two stages. First
the base PCFG is trained and its top trees are
cached and then used for training the SU-RNN
conditioned on the PCFG. The SU-RNN is trained
using the objective in Eq. 3 and the scores as ex-
emplified by Eq. 6. For each sentence, we use the
method described above to efficiently find an ap-
proximation for the optimal tree.
To minimize the objective we want to increase
the scores of the correct tree’s constituents and
decrease the score of those in the highest scor-
ing incorrect tree. Derivatives are computed via
backpropagation through structure (BTS) (Goller
and K¨uchler, 1996). The derivative of tree i has
to be taken with respect to all parameter matrices
W (AB) that appear in it. The main difference be-
tween backpropagation in standard RNNs and SU-
RNNs is that the derivatives at each node only add
to the overall derivative of the specific matrix at
that node. For more details on backpropagation
through RNNs, see Socher et al. (2010)
</bodyText>
<page confidence="0.997567">
460
</page>
<subsectionHeader confidence="0.934882">
3.6 Subgradient Methods and AdaGrad
</subsectionHeader>
<bodyText confidence="0.999980875">
The objective function is not differentiable due to
the hinge loss. Therefore, we generalize gradient
ascent via the subgradient method (Ratliff et al.,
2007) which computes a gradient-like direction.
Let θ = (X, W(··), v(··)) E RM be a vector of all
M model parameters, where we denote W(··) as
the set of matrices that appear in the training set.
The subgradient of Eq. 3 becomes:
</bodyText>
<equation confidence="0.9566535">
∂s(xi, yi) + θ,
∂θ
</equation>
<bodyText confidence="0.999977285714286">
where ˆymax is the tree with the highest score. To
minimize the objective, we use the diagonal vari-
ant of AdaGrad (Duchi et al., 2011) with mini-
batches. For our parameter updates, we first de-
fine gT E RM×1 to be the subgradient at time step
τ and Gt = Et T=1 gTgTT . The parameter update at
time step t then becomes:
</bodyText>
<equation confidence="0.993394">
θt = θt−1 — α (diag(Gt))−1/2 gt, (7)
</equation>
<bodyText confidence="0.9999175">
where α is the learning rate. Since we use the di-
agonal of Gt, we only have to store M values and
the update becomes fast to compute: At time step
t, the update for the i’th parameter θt,i is:
</bodyText>
<equation confidence="0.908768666666667">
α
θt,i = θt−1,i � 2 gt,i. ( 8)
�EtT=1 gT,i
</equation>
<bodyText confidence="0.999989">
Hence, the learning rate is adapting differ-
ently for each parameter and rare parameters get
larger updates than frequently occurring parame-
ters. This is helpful in our setting since some W
matrices appear in only a few training trees. This
procedure found much better optima (by Pz3% la-
beled F1 on the dev set), and converged more
quickly than L-BFGS which we used previously
in RNN training (Socher et al., 2011a). Training
time is roughly 4 hours on a single machine.
</bodyText>
<subsectionHeader confidence="0.998562">
3.7 Initialization of Weight Matrices
</subsectionHeader>
<bodyText confidence="0.9998454">
In the absence of any knowledge on how to com-
bine two categories, our prior for combining two
vectors is to average them instead of performing a
completely random projection. Hence, we initial-
ize the binary W matrices with:
</bodyText>
<equation confidence="0.992853">
W(··) = 0.5[I.×.I.×.0.×1] + E,
</equation>
<bodyText confidence="0.9993945">
where we include the bias in the last column and
the random variable is uniformly distributed: E —
U[-0.001, 0.001]. The first block is multiplied by
the left child and the second by the right child:
</bodyText>
<equation confidence="0.965016">
⎤ ⎡ ⎤
a
[W(A)W(B)bias] ⎣b ⎦
1
= W(A)a + W(B)b + bias.
</equation>
<sectionHeader confidence="0.994916" genericHeader="method">
4 Experiments
</sectionHeader>
<bodyText confidence="0.999984333333333">
We evaluate the CVG in two ways: First, by a stan-
dard parsing evaluation on Penn Treebank WSJ
and then by analyzing the model errors in detail.
</bodyText>
<subsectionHeader confidence="0.98799">
4.1 Cross-validating Hyperparameters
</subsectionHeader>
<bodyText confidence="0.99978954054054">
We used the first 20 files of WSJ section 22
to cross-validate several model and optimization
choices. The base PCFG uses simplified cate-
gories of the Stanford PCFG Parser (Klein and
Manning, 2003a). We decreased the state split-
ting of the PCFG grammar (which helps both by
making it less sparse and by reducing the num-
ber of parameters in the SU-RNN) by adding
the following options to training: ‘-noRightRec -
dominatesV 0 -baseNP 0’. This reduces the num-
ber of states from 15,276 to 12,061 states and 602
POS tags. These include split categories, such as
parent annotation categories like VPˆS. Further-
more, we ignore all category splits for the SU-
RNN weights, resulting in 66 unary and 882 bi-
nary child pairs. Hence, the SU-RNN has 66+882
transformation matrices and scoring vectors. Note
that any PCFG, including latent annotation PCFGs
(Matsuzaki et al., 2005) could be used. However,
since the vectors will capture lexical and semantic
information, even simple base PCFGs can be sub-
stantially improved. Since the computational com-
plexity of PCFGs depends on the number of states,
a base PCFG with fewer states is much faster.
Testing on the full WSJ section 22 dev set (1700
sentences) takes roughly 470 seconds with the
simple base PCFG, 1320 seconds with our new
CVG and 1600 seconds with the currently pub-
lished Stanford factored parser. Hence, increased
performance comes also with a speed improve-
ment of approximately 20%.
We fix the same regularization of λ = 10−4
for all parameters. The minibatch size was set to
20. We also cross-validated on AdaGrad’s learn-
ing rate which was eventually set to α = 0.1 and
word vector size. The 25-dimensional vectors pro-
vided by Turian et al. (2010) provided the best
</bodyText>
<figure confidence="0.995590875">
∂J ∂s (xi, ˆymax)
∂θ ∂θ
Y_
⎡
W(AB) ⎣
a
b
1
</figure>
<page confidence="0.998004">
461
</page>
<table confidence="0.999178454545455">
Parser dev (all) test≤ 40 test (all)
Stanford PCFG 85.8 86.2 85.5
Stanford Factored 87.4 87.2 86.6
Factored PCFGs 89.7 90.1 89.4
Collins 87.7
SSN (Henderson) 89.4
Berkeley Parser 90.1
CVG (RNN) 85.7 85.1 85.0
CVG (SU-RNN) 91.2 91.1 90.4
Charniak-SelfTrain 91.0
Charniak-RS 92.1
</table>
<tableCaption confidence="0.933596666666667">
Table 1: Comparison of parsers with richer state
representations on the WSJ. The last line is the
self-trained re-ranked Charniak parser.
</tableCaption>
<bodyText confidence="0.9933686">
performance and were faster than 50-,100- or 200-
dimensional ones. We hypothesize that the larger
word vector sizes, while capturing more seman-
tic knowledge, result in too many SU-RNN matrix
parameters to train and hence perform worse.
</bodyText>
<subsectionHeader confidence="0.941889">
4.2 Results on WSJ
</subsectionHeader>
<bodyText confidence="0.999960136363636">
The dev set accuracy of the best model is 90.93%
labeled F1 on all sentences. This model re-
sulted in 90.44% on the final test set (WSJ sec-
tion 23). Table 1 compares our results to the
two Stanford parser variants (the unlexicalized
PCFG (Klein and Manning, 2003a) and the fac-
tored parser (Klein and Manning, 2003b)) and
other parsers that use richer state representations:
the Berkeley parser (Petrov and Klein, 2007),
Collins parser (Collins, 1997), SSN: a statistical
neural network parser (Henderson, 2004), Fac-
tored PCFGs (Hall and Klein, 2012), Charniak-
SelfTrain: the self-training approach of McClosky
et al. (2006), which bootstraps and parses addi-
tional large corpora multiple times, Charniak-RS:
the state of the art self-trained and discrimina-
tively re-ranked Charniak-Johnson parser combin-
ing (Charniak, 2000; McClosky et al., 2006; Char-
niak and Johnson, 2005). See Kummerfeld et al.
(2012) for more comparisons. We compare also
to a standard RNN ‘CVG (RNN)’ and to the pro-
posed CVG with SU-RNNs.
</bodyText>
<subsectionHeader confidence="0.999907">
4.3 Model Analysis
</subsectionHeader>
<bodyText confidence="0.999612625">
Analysis of Error Types. Table 2 shows a de-
tailed comparison of different errors. We use
the code provided by Kummerfeld et al. (2012)
and compare to the previous version of the Stan-
ford factored parser as well as to the Berkeley
and Charniak-reranked-self-trained parsers (de-
fined above). See Kummerfeld et al. (2012) for
details and comparisons to other parsers. One of
</bodyText>
<table confidence="0.999284363636364">
Error Type Stanford CVG Berkeley Char-RS
PP Attach 1.02 0.79 0.82 0.60
Clause Attach 0.64 0.43 0.50 0.38
Diff Label 0.40 0.29 0.29 0.31
Mod Attach 0.37 0.27 0.27 0.25
NP Attach 0.44 0.31 0.27 0.25
Co-ord 0.39 0.32 0.38 0.23
1-Word Span 0.48 0.31 0.28 0.20
Unary 0.35 0.22 0.24 0.14
NP Int 0.28 0.19 0.18 0.14
Other 0.62 0.41 0.41 0.50
</table>
<tableCaption confidence="0.998702">
Table 2: Detailed comparison of different parsers.
</tableCaption>
<bodyText confidence="0.999693121951219">
the largest sources of improved performance over
the original Stanford factored parser is in the cor-
rect placement of PP phrases. When measuring
only the F1 of parse nodes that include at least one
PP child, the CVG improves the Stanford parser
by 6.2% to an F1 of 77.54%. This is a 0.23 re-
duction in the average number of bracket errors
per sentence. The ‘Other’ category includes VP,
PRN and other attachments, appositives and inter-
nal structures of modifiers and QPs.
Analysis of Composition Matrices. An analy-
sis of the norms of the binary matrices reveals
that the model learns a soft vectorized notion of
head words: Head words are given larger weights
and importance when computing the parent vec-
tor: For the matrices combining siblings with cat-
egories VP:PP, VP:NP and VP:PRT, the weights in
the part of the matrix which is multiplied with the
VP child vector dominates. Similarly NPs dom-
inate DTs. Fig. 5 shows example matrices. The
two strong diagonals are due to the initialization
described in Sec. 3.7.
Semantic Transfer for PP Attachments. In this
small model analysis, we use two pairs of sen-
tences that the original Stanford parser and the
CVG did not parse correctly after training on
the WSJ. We then continue to train both parsers
on two similar sentences and then analyze if the
parsers correctly transferred the knowledge. The
training sentences are He eats spaghetti with a
fork. and She eats spaghetti with pork. The very
similar test sentences are He eats spaghetti with a
spoon. and He eats spaghetti with meat. Initially,
both parsers incorrectly attach the PP to the verb
in both test sentences. After training, the CVG
parses both correctly, while the factored Stanford
parser incorrectly attaches both PPs to spaghetti.
The CVG’s ability to transfer the correct PP at-
tachments is due to the semantic word vector sim-
ilarity between the words in the sentences. Fig. 4
shows the outputs of the two parsers.
</bodyText>
<page confidence="0.998752">
462
</page>
<figureCaption confidence="0.986308">
Figure 4: Test sentences of semantic transfer for PP attachments. The CVG was able to transfer se-
mantic word knowledge from two related training sentences. In contrast, the Stanford parser could not
distinguish the PP attachments based on the word semantics.
</figureCaption>
<figure confidence="0.9999165">
(a) Stanford factored parser
S
S
NP
VP
NP
VP
meat
He
NP
PP
eats
PP
NP
eats
He
spaghetti
with
PRP
NNS
IN
NP
spaghetti
with
DT
NN
IN
NNS
NP
NP
NP
PRP
VBZ
PRP
VBZ
a spoon
PRP
eats
(b) Compositional Vector Grammar
S
S
NP
VP
He
VBZ
NP
PP
eats
NP
PP
VBZ
NP
spaghetti
with
DT
NN
spaghetti
with
NN
meat
PRP
He
IN
NNS
NP
NP
VP
IN
NNS
NP
a spoon
ADJP-NP
</figure>
<figureCaption confidence="0.990503">
Figure 5: Three binary composition matrices
</figureCaption>
<bodyText confidence="0.5727518">
showing that head words dominate the composi-
tion. The model learns to not give determiners
much importance. The two diagonals show clearly
the two blocks that are multiplied with the left and
right children, respectively.
</bodyText>
<sectionHeader confidence="0.998023" genericHeader="conclusions">
5 Conclusion
</sectionHeader>
<bodyText confidence="0.999988083333333">
We introduced Compositional Vector Grammars
(CVGs), a parsing model that combines the speed
of small-state PCFGs with the semantic richness
of neural word representations and compositional
phrase vectors. The compositional vectors are
learned with a new syntactically untied recursive
neural network. This model is linguistically more
plausible since it chooses different composition
functions for a parent node based on the syntac-
tic categories of its children. The CVG obtains
90.44% labeled F1 on the full WSJ test set and is
20% faster than the previous Stanford parser.
</bodyText>
<sectionHeader confidence="0.997668" genericHeader="acknowledgments">
Acknowledgments
</sectionHeader>
<bodyText confidence="0.999475428571428">
We thank Percy Liang for chats about the paper.
Richard is supported by a Microsoft Research PhD
fellowship. The authors gratefully acknowledge
the support of the Defense Advanced Research
Projects Agency (DARPA) Deep Exploration and
Filtering of Text (DEFT) Program under Air Force
Research Laboratory (AFRL) prime contract no.
FA8750-13-2-0040, and the DARPA Deep Learn-
ing program under contract number FA8650-10-
C-7020. Any opinions, findings, and conclusions
or recommendations expressed in this material are
those of the authors and do not necessarily reflect
the view of DARPA, AFRL, or the US govern-
ment.
</bodyText>
<figure confidence="0.998503527777778">
5
10
15
20
25
0.6
0.4
0.2
0
−0.2
0.8
5
10
15
20
25
0.6
0.4
0.2
0
−0.2
DT-NP
0.6
5
0.4
10
0.2
15
20
25 −0.4
10 20 30 40 50
10 20 30 40 50
0
−0.2
VP-NP
10 20 30 40 50
</figure>
<page confidence="0.999642">
463
</page>
<sectionHeader confidence="0.993872" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999319862745099">
Y. Bengio, R. Ducharme, P. Vincent, and C. Janvin.
2003. A neural probabilistic language model. Jour-
nal of Machine Learning Research, 3:1137–1155.
P. F. Brown, P. V. deSouza, R. L. Mercer, V. J. Della
Pietra, and J. C. Lai. 1992. Class-based n-gram
models of natural language. Computational Lin-
guistics, 18.
C. Callison-Burch. 2008. Syntactic constraints on
paraphrases extracted from parallel corpora. In Pro-
ceedings of EMNLP, pages 196–205.
E. Charniak and M. Johnson. 2005. Coarse-to-fine
n-best parsing and maxent discriminative reranking.
In ACL.
E. Charniak. 2000. A maximum-entropy-inspired
parser. In Proceedings of ACL, pages 132–139.
M. Collins. 1997. Three generative, lexicalised models
for statistical parsing. In ACL.
M. Collins. 2003. Head-driven statistical models for
natural language parsing. Computational Linguis-
tics, 29(4):589–637.
R. Collobert and J. Weston. 2008. A unified archi-
tecture for natural language processing: deep neural
networks with multitask learning. In Proceedings of
ICML, pages 160–167.
F. Costa, P. Frasconi, V. Lombardo, and G. Soda. 2003.
Towards incremental parsing of natural language us-
ing recursive neural networks. Applied Intelligence.
J. Duchi, E. Hazan, and Y. Singer. 2011. Adaptive sub-
gradient methods for online learning and stochastic
optimization. JMLR, 12, July.
J. L. Elman. 1991. Distributed representations, sim-
ple recurrent networks, and grammatical structure.
Machine Learning, 7(2-3):195–225.
J. R. Finkel, A. Kleeman, and C. D. Manning. 2008.
Efficient, feature-based, conditional random field
parsing. In Proceedings of ACL, pages 959–967.
D. Gildea and M. Palmer. 2002. The necessity of pars-
ing for predicate argument recognition. In Proceed-
ings of ACL, pages 239–246.
C. Goller and A. K¨uchler. 1996. Learning task-
dependent distributed representations by backprop-
agation through structure. In Proceedings of the In-
ternational Conference on Neural Networks.
J. Goodman. 1998. Parsing Inside-Out. Ph.D. thesis,
MIT.
D. Hall and D. Klein. 2012. Training factored pcfgs
with expectation propagation. In EMNLP.
J. Henderson. 2003. Neural network probability esti-
mation for broad coverage parsing. In Proceedings
of EACL.
J. Henderson. 2004. Discriminative training of a neu-
ral network statistical parser. In ACL.
Liang Huang and David Chiang. 2005. Better k-best
parsing. In Proceedings of the 9th International
Workshop on Parsing Technologies (IWPT 2005).
E. H. Huang, R. Socher, C. D. Manning, and A. Y. Ng.
2012. Improving Word Representations via Global
Context and Multiple Word Prototypes. In ACL.
D. Kartsaklis, M. Sadrzadeh, and S. Pulman. 2012. A
unified sentence space for categorical distributional-
compositional semantics: Theory and experiments.
Proceedings of 24th International Conference on
Computational Linguistics (COLING): Posters.
D. Klein and C. D. Manning. 2003a. Accurate un-
lexicalized parsing. In Proceedings of ACL, pages
423–430.
D. Klein and C.D. Manning. 2003b. Fast exact in-
ference with a factored model for natural language
parsing. In NIPS.
J. K. Kummerfeld, D. Hall, J. R. Curran, and D. Klein.
2012. Parser showdown at the wall street corral: An
empirical investigation of error types in parser out-
put. In EMNLP.
Q. V. Le, J. Ngiam, Z. Chen, D. Chia, P. W. Koh, and
A. Y. Ng. 2010. Tiled convolutional neural net-
works. In NIPS.
T. Matsuzaki, Y. Miyao, and J. Tsujii. 2005. Proba-
bilistic cfg with latent annotations. In ACL.
D. McClosky, E. Charniak, and M. Johnson. 2006. Ef-
fective self-training for parsing. In NAACL.
S. Menchetti, F. Costa, P. Frasconi, and M. Pon-
til. 2005. Wide coverage natural language pro-
cessing using kernel methods and neural networks
for structured data. Pattern Recognition Letters,
26(12):1896–1906.
T. Mikolov, W. Yih, and G. Zweig. 2013. Linguis-
tic regularities in continuous spaceword representa-
tions. In HLT-NAACL.
S. Petrov and D. Klein. 2007. Improved inference for
unlexicalized parsing. In NAACL.
S. Petrov, L. Barrett, R. Thibaux, and D. Klein. 2006.
Learning accurate, compact, and interpretable tree
annotation. In Proceedings of ACL, pages 433–440.
N. Ratliff, J. A. Bagnell, and M. Zinkevich. 2007. (On-
line) subgradient methods for structured prediction.
In Eleventh International Conference on Artificial
Intelligence and Statistics (AIStats).
R. Socher, C. D. Manning, and A. Y. Ng. 2010. Learn-
ing continuous phrase representations and syntactic
parsing with recursive neural networks. In Proceed-
ings of the NIPS-2010 Deep Learning and Unsuper-
vised Feature Learning Workshop.
</reference>
<page confidence="0.994894">
464
</page>
<reference confidence="0.999537916666667">
R. Socher, E. H. Huang, J. Pennington, A. Y. Ng, and
C. D. Manning. 2011a. Dynamic Pooling and Un-
folding Recursive Autoencoders for Paraphrase De-
tection. In NIPS. MIT Press.
R. Socher, C. Lin, A. Y. Ng, and C.D. Manning. 2011b.
Parsing Natural Scenes and Natural Language with
Recursive Neural Networks. In ICML.
R. Socher, B. Huval, C. D. Manning, and A. Y. Ng.
2012. Semantic Compositionality Through Recur-
sive Matrix-Vector Spaces. In EMNLP.
B. Taskar, D. Klein, M. Collins, D. Koller, and C. Man-
ning. 2004. Max-margin parsing. In Proceedings of
EMNLP, pages 1–8.
I. Titov and J. Henderson. 2006. Porting statistical
parsers with data-defined kernels. In CoNLL-X.
I. Titov and J. Henderson. 2007. Constituent parsing
with incremental sigmoid belief networks. In ACL.
J. Turian, L. Ratinov, and Y. Bengio. 2010. Word rep-
resentations: a simple and general method for semi-
supervised learning. In Proceedings of ACL, pages
384–394.
P. D. Turney and P. Pantel. 2010. From frequency to
meaning: Vector space models of semantics. Jour-
nal of Artificial Intelligence Research, 37:141–188.
</reference>
<page confidence="0.999595">
465
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.802905">
<title confidence="0.999973">Parsing with Compositional Vector Grammars</title>
<author confidence="0.999904">Richard Socher John Bauer Christopher D Manning Andrew Y Ng</author>
<address confidence="0.825117">Computer Science Department, Stanford University, Stanford, CA 94305, USA</address>
<email confidence="0.999703">richard@socher.org,horatio@gmail.com,manning@stanford.edu,ang@cs.stanford.edu</email>
<abstract confidence="0.99891696">Natural language parsing has typically been done with small sets of discrete categories such as NP and VP, but this representation does not capture the full syntactic nor semantic richness of linguistic phrases, and attempts to improve on this by lexicalizing phrases or splitting categories only partly address the problem at the cost of huge feature spaces and sparseness. Instead, we introduce a Compositional Vector Grammar (CVG), which combines PCFGs with a syntactically untied recursive neural network that learns syntactico-semantic, compositional vector representations. The CVG improves the PCFG of the Stanford Parser by 3.8% to obtain an F1 score of 90.4%. It is fast to train and implemented approximately as an efficient reranker it is about 20% faster than the current Stanford factored parser. The CVG learns a soft notion of head words and improves performance on the types of ambiguities that require semantic information such as PP attachments.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Y Bengio</author>
<author>R Ducharme</author>
<author>P Vincent</author>
<author>C Janvin</author>
</authors>
<title>A neural probabilistic language model.</title>
<date>2003</date>
<journal>Journal of Machine Learning Research,</journal>
<pages>3--1137</pages>
<contexts>
<context position="11864" citStr="Bengio et al., 2003" startWordPosition="1821" endWordPosition="1824"> CVG model merges ideas from both generative models that assume discrete syntactic categories and discriminative models that are trained using continuous vectors. We will first briefly introduce single word vector representations and then describe the CVG objective function, tree scoring and inference. 3.1 Word Vector Representations In most systems that use a vector representation for words, such vectors are based on cooccurrence statistics of each word and its context (Turney and Pantel, 2010). Another line of research to learn distributional word vectors is based on neural language models (Bengio et al., 2003) which jointly learn an embedding of words into an n-dimensional feature space and use these embeddings to predict how suitable a word is in its context. These vector representations capture interesting linear relationships (up to some accuracy), such as king−man+woman ≈ queen (Mikolov et al., 2013). Collobert and Weston (2008) introduced a new model to compute such an embedding. The idea is to construct a neural network that outputs high scores for windows that occur in a large unlabeled corpus and low scores for windows where one word is replaced by a random word. When such a network is opti</context>
</contexts>
<marker>Bengio, Ducharme, Vincent, Janvin, 2003</marker>
<rawString>Y. Bengio, R. Ducharme, P. Vincent, and C. Janvin. 2003. A neural probabilistic language model. Journal of Machine Learning Research, 3:1137–1155.</rawString>
</citation>
<citation valid="true">
<authors>
<author>P F Brown</author>
<author>P V deSouza</author>
<author>R L Mercer</author>
<author>V J Della Pietra</author>
<author>J C Lai</author>
</authors>
<title>Class-based n-gram models of natural language.</title>
<date>1992</date>
<journal>Computational Linguistics,</journal>
<volume>18</volume>
<contexts>
<context position="3343" citStr="Brown et al., 1992" startWordPosition="501" endWordPosition="504">s in such parsers can be seen as defining effective dimensions of similarity between categories. Second, lexicalized parsers (Collins, 2003; Charniak, 2000) associate each category with a lexical item. This gives a fine-grained notion of semantic similarity, which is useful for tackling problems like ambiguous attachment decisions. However, this approach necessitates complex shrinkage estimation schemes to deal with the sparsity of observations of the lexicalized categories. In many natural language systems, single words and n-grams are usefully described by their distributional similarities (Brown et al., 1992), among many others. But, even with large corpora, many (riding a bike,VP, ) (a bike,NP, ) (riding,V, ) (a,Det, ) (bike,NN, ) 455 Proceedings of the 51st Annual Meeting of the Association for Computational Linguistics, pages 455–465, Sofia, Bulgaria, August 4-9 2013. c�2013 Association for Computational Linguistics n-grams will never be seen during training, especially when n is large. In these cases, one cannot simply use distributional similarities to represent unseen phrases. In this work, we present a new solution to learn features and phrase representations even for very long, unseen n-gr</context>
</contexts>
<marker>Brown, deSouza, Mercer, Pietra, Lai, 1992</marker>
<rawString>P. F. Brown, P. V. deSouza, R. L. Mercer, V. J. Della Pietra, and J. C. Lai. 1992. Class-based n-gram models of natural language. Computational Linguistics, 18.</rawString>
</citation>
<citation valid="true">
<authors>
<author>C Callison-Burch</author>
</authors>
<title>Syntactic constraints on paraphrases extracted from parallel corpora.</title>
<date>2008</date>
<booktitle>In Proceedings of EMNLP,</booktitle>
<pages>196--205</pages>
<contexts>
<context position="1620" citStr="Callison-Burch, 2008" startWordPosition="241" endWordPosition="242">ient reranker it is about 20% faster than the current Stanford factored parser. The CVG learns a soft notion of head words and improves performance on the types of ambiguities that require semantic information such as PP attachments. 1 Introduction Syntactic parsing is a central task in natural language processing because of its importance in mediating between linguistic expression and meaning. For example, much work has shown the usefulness of syntactic representations for subsequent tasks such as relation extraction, semantic role labeling (Gildea and Palmer, 2002) and paraphrase detection (Callison-Burch, 2008). Syntactic descriptions standardly use coarse discrete categories such as NP for noun phrases or PP for prepositional phrases. However, recent work has shown that parsing results can be greatly improved by defining more fine-grained syntactic Discrete Syntactic – Continuous Semantic Representations in the Compositional Vector Grammar Figure 1: Example of a CVG tree with (category,vector) representations at each node. The vectors for nonterminals are computed via a new type of recursive neural network which is conditioned on syntactic categories from a PCFG. categories, which better capture ph</context>
</contexts>
<marker>Callison-Burch, 2008</marker>
<rawString>C. Callison-Burch. 2008. Syntactic constraints on paraphrases extracted from parallel corpora. In Proceedings of EMNLP, pages 196–205.</rawString>
</citation>
<citation valid="true">
<authors>
<author>E Charniak</author>
<author>M Johnson</author>
</authors>
<title>Coarse-to-fine n-best parsing and maxent discriminative reranking.</title>
<date>2005</date>
<booktitle>In ACL.</booktitle>
<contexts>
<context position="30367" citStr="Charniak and Johnson, 2005" startWordPosition="5116" endWordPosition="5120">and Manning, 2003a) and the factored parser (Klein and Manning, 2003b)) and other parsers that use richer state representations: the Berkeley parser (Petrov and Klein, 2007), Collins parser (Collins, 1997), SSN: a statistical neural network parser (Henderson, 2004), Factored PCFGs (Hall and Klein, 2012), CharniakSelfTrain: the self-training approach of McClosky et al. (2006), which bootstraps and parses additional large corpora multiple times, Charniak-RS: the state of the art self-trained and discriminatively re-ranked Charniak-Johnson parser combining (Charniak, 2000; McClosky et al., 2006; Charniak and Johnson, 2005). See Kummerfeld et al. (2012) for more comparisons. We compare also to a standard RNN ‘CVG (RNN)’ and to the proposed CVG with SU-RNNs. 4.3 Model Analysis Analysis of Error Types. Table 2 shows a detailed comparison of different errors. We use the code provided by Kummerfeld et al. (2012) and compare to the previous version of the Stanford factored parser as well as to the Berkeley and Charniak-reranked-self-trained parsers (defined above). See Kummerfeld et al. (2012) for details and comparisons to other parsers. One of Error Type Stanford CVG Berkeley Char-RS PP Attach 1.02 0.79 0.82 0.60 C</context>
</contexts>
<marker>Charniak, Johnson, 2005</marker>
<rawString>E. Charniak and M. Johnson. 2005. Coarse-to-fine n-best parsing and maxent discriminative reranking. In ACL.</rawString>
</citation>
<citation valid="true">
<authors>
<author>E Charniak</author>
</authors>
<title>A maximum-entropy-inspired parser.</title>
<date>2000</date>
<booktitle>In Proceedings of ACL,</booktitle>
<pages>132--139</pages>
<contexts>
<context position="2880" citStr="Charniak, 2000" startWordPosition="435" endWordPosition="437">manual feature engineering (Klein and Manning, 2003a) or automatic learning (Petrov et al., 2006). However, subdividing a category like NP into 30 or 60 subcategories can only provide a very limited representation of phrase meaning and semantic similarity. Two strands of work therefore attempt to go further. First, recent work in discriminative parsing has shown gains from careful engineering of features (Taskar et al., 2004; Finkel et al., 2008). Features in such parsers can be seen as defining effective dimensions of similarity between categories. Second, lexicalized parsers (Collins, 2003; Charniak, 2000) associate each category with a lexical item. This gives a fine-grained notion of semantic similarity, which is useful for tackling problems like ambiguous attachment decisions. However, this approach necessitates complex shrinkage estimation schemes to deal with the sparsity of observations of the lexicalized categories. In many natural language systems, single words and n-grams are usefully described by their distributional similarities (Brown et al., 1992), among many others. But, even with large corpora, many (riding a bike,VP, ) (a bike,NP, ) (riding,V, ) (a,Det, ) (bike,NN, ) 455 Proceed</context>
<context position="6727" citStr="Charniak, 2000" startWordPosition="1025" endWordPosition="1026">arning models that jointly learn classifiers and continuous feature representations for variable-sized inputs. Improving Discrete Syntactic Representations As mentioned in the introduction, there are several approaches to improving discrete representations for parsing. Klein and Manning (2003a) use manual feature engineering, while Petrov et al. (2006) use a learning algorithm that splits and merges the syntactic categories in order to maximize likelihood on the treebank. Their approach splits categories into several dozen subcategories. Another approach is lexicalized parsers (Collins, 2003; Charniak, 2000) that describe each category with a lexical item, usually the head word. More recently, Hall and Klein (2012) combine several such annotation schemes in a factored parser. We extend the above ideas from discrete representations to richer continuous ones. The CVG can be seen as factoring discrete and continuous parsing in one model. Another different approach to the above generative models is to learn discriminative parsers using many well designed features (Taskar et al., 2004; Finkel et al., 2008). We also borrow ideas from this line of research in that our parser combines the generative PCFG</context>
<context position="30315" citStr="Charniak, 2000" startWordPosition="5110" endWordPosition="5111">ariants (the unlexicalized PCFG (Klein and Manning, 2003a) and the factored parser (Klein and Manning, 2003b)) and other parsers that use richer state representations: the Berkeley parser (Petrov and Klein, 2007), Collins parser (Collins, 1997), SSN: a statistical neural network parser (Henderson, 2004), Factored PCFGs (Hall and Klein, 2012), CharniakSelfTrain: the self-training approach of McClosky et al. (2006), which bootstraps and parses additional large corpora multiple times, Charniak-RS: the state of the art self-trained and discriminatively re-ranked Charniak-Johnson parser combining (Charniak, 2000; McClosky et al., 2006; Charniak and Johnson, 2005). See Kummerfeld et al. (2012) for more comparisons. We compare also to a standard RNN ‘CVG (RNN)’ and to the proposed CVG with SU-RNNs. 4.3 Model Analysis Analysis of Error Types. Table 2 shows a detailed comparison of different errors. We use the code provided by Kummerfeld et al. (2012) and compare to the previous version of the Stanford factored parser as well as to the Berkeley and Charniak-reranked-self-trained parsers (defined above). See Kummerfeld et al. (2012) for details and comparisons to other parsers. One of Error Type Stanford </context>
</contexts>
<marker>Charniak, 2000</marker>
<rawString>E. Charniak. 2000. A maximum-entropy-inspired parser. In Proceedings of ACL, pages 132–139.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Collins</author>
</authors>
<title>Three generative, lexicalised models for statistical parsing.</title>
<date>1997</date>
<booktitle>In ACL.</booktitle>
<contexts>
<context position="29945" citStr="Collins, 1997" startWordPosition="5058" endWordPosition="5059"> larger word vector sizes, while capturing more semantic knowledge, result in too many SU-RNN matrix parameters to train and hence perform worse. 4.2 Results on WSJ The dev set accuracy of the best model is 90.93% labeled F1 on all sentences. This model resulted in 90.44% on the final test set (WSJ section 23). Table 1 compares our results to the two Stanford parser variants (the unlexicalized PCFG (Klein and Manning, 2003a) and the factored parser (Klein and Manning, 2003b)) and other parsers that use richer state representations: the Berkeley parser (Petrov and Klein, 2007), Collins parser (Collins, 1997), SSN: a statistical neural network parser (Henderson, 2004), Factored PCFGs (Hall and Klein, 2012), CharniakSelfTrain: the self-training approach of McClosky et al. (2006), which bootstraps and parses additional large corpora multiple times, Charniak-RS: the state of the art self-trained and discriminatively re-ranked Charniak-Johnson parser combining (Charniak, 2000; McClosky et al., 2006; Charniak and Johnson, 2005). See Kummerfeld et al. (2012) for more comparisons. We compare also to a standard RNN ‘CVG (RNN)’ and to the proposed CVG with SU-RNNs. 4.3 Model Analysis Analysis of Error Type</context>
</contexts>
<marker>Collins, 1997</marker>
<rawString>M. Collins. 1997. Three generative, lexicalised models for statistical parsing. In ACL.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Collins</author>
</authors>
<title>Head-driven statistical models for natural language parsing.</title>
<date>2003</date>
<journal>Computational Linguistics,</journal>
<volume>29</volume>
<issue>4</issue>
<contexts>
<context position="2863" citStr="Collins, 2003" startWordPosition="433" endWordPosition="434">hether through manual feature engineering (Klein and Manning, 2003a) or automatic learning (Petrov et al., 2006). However, subdividing a category like NP into 30 or 60 subcategories can only provide a very limited representation of phrase meaning and semantic similarity. Two strands of work therefore attempt to go further. First, recent work in discriminative parsing has shown gains from careful engineering of features (Taskar et al., 2004; Finkel et al., 2008). Features in such parsers can be seen as defining effective dimensions of similarity between categories. Second, lexicalized parsers (Collins, 2003; Charniak, 2000) associate each category with a lexical item. This gives a fine-grained notion of semantic similarity, which is useful for tackling problems like ambiguous attachment decisions. However, this approach necessitates complex shrinkage estimation schemes to deal with the sparsity of observations of the lexicalized categories. In many natural language systems, single words and n-grams are usefully described by their distributional similarities (Brown et al., 1992), among many others. But, even with large corpora, many (riding a bike,VP, ) (a bike,NP, ) (riding,V, ) (a,Det, ) (bike,</context>
<context position="6710" citStr="Collins, 2003" startWordPosition="1023" endWordPosition="1024">cursive deep learning models that jointly learn classifiers and continuous feature representations for variable-sized inputs. Improving Discrete Syntactic Representations As mentioned in the introduction, there are several approaches to improving discrete representations for parsing. Klein and Manning (2003a) use manual feature engineering, while Petrov et al. (2006) use a learning algorithm that splits and merges the syntactic categories in order to maximize likelihood on the treebank. Their approach splits categories into several dozen subcategories. Another approach is lexicalized parsers (Collins, 2003; Charniak, 2000) that describe each category with a lexical item, usually the head word. More recently, Hall and Klein (2012) combine several such annotation schemes in a factored parser. We extend the above ideas from discrete representations to richer continuous ones. The CVG can be seen as factoring discrete and continuous parsing in one model. Another different approach to the above generative models is to learn discriminative parsers using many well designed features (Taskar et al., 2004; Finkel et al., 2008). We also borrow ideas from this line of research in that our parser combines th</context>
<context position="9655" citStr="Collins, 2003" startWordPosition="1481" endWordPosition="1482">discriminatively trains a parser based on synchrony networks and (Titov and Henderson, 2006), who use an SVM to adapt a generative parser to different domains. Costa et al. (2003) apply recursive neural networks to re-rank possible phrase attachments in an incremental parser. Their work is the first to show that RNNs can capture enough information to make correct parsing decisions, but they only test on a subset of 2000 sentences. Menchetti et al. (2005) use RNNs to re-rank different parses. For their results on full sentence parsing, they rerank candidate trees created by the Collins parser (Collins, 2003). Similar to their work, we use the idea of letting discrete categories reduce the search space during inference. We compare to fully tied RNNs in which the same weights are used at every node. Our syntactically untied RNNs outperform them by a significant margin. The idea of untying has also been successfully used in deep learning applied to vision (Le et al., 2010). This paper uses several ideas of (Socher et al., 2011b). The main differences are (i) the dual representation of nodes as discrete categories and vectors, (ii) the combination with a PCFG, and (iii) the syntactic untying of weigh</context>
</contexts>
<marker>Collins, 2003</marker>
<rawString>M. Collins. 2003. Head-driven statistical models for natural language parsing. Computational Linguistics, 29(4):589–637.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Collobert</author>
<author>J Weston</author>
</authors>
<title>A unified architecture for natural language processing: deep neural networks with multitask learning.</title>
<date>2008</date>
<booktitle>In Proceedings of ICML,</booktitle>
<pages>160--167</pages>
<contexts>
<context position="7813" citStr="Collobert and Weston (2008)" startWordPosition="1192" endWordPosition="1196">s (Taskar et al., 2004; Finkel et al., 2008). We also borrow ideas from this line of research in that our parser combines the generative PCFG model with discriminatively learned RNNs. Deep Learning and Recursive Deep Learning Early attempts at using neural networks to describe phrases include Elman (1991), who used recurrent neural networks to create representations of sentences from a simple toy grammar and to analyze the linguistic expressiveness of the resulting representations. Words were represented as one-on vectors, which was feasible since the grammar only included a handful of words. Collobert and Weston (2008) showed that neural networks can perform well on sequence labeling language processing tasks while also learning appropriate features. However, their model is lacking in that it cannot represent the recursive structure inherent in natural language. They partially circumvent this problem by using either independent window-based classifiers or a convolutional layer. RNN-specific training was introduced by Goller and K¨uchler (1996) to learn distributed representations of given, structured objects such as logical terms. In contrast, our model both predicts the structure and its representation. 45</context>
<context position="12193" citStr="Collobert and Weston (2008)" startWordPosition="1874" endWordPosition="1877">presentations In most systems that use a vector representation for words, such vectors are based on cooccurrence statistics of each word and its context (Turney and Pantel, 2010). Another line of research to learn distributional word vectors is based on neural language models (Bengio et al., 2003) which jointly learn an embedding of words into an n-dimensional feature space and use these embeddings to predict how suitable a word is in its context. These vector representations capture interesting linear relationships (up to some accuracy), such as king−man+woman ≈ queen (Mikolov et al., 2013). Collobert and Weston (2008) introduced a new model to compute such an embedding. The idea is to construct a neural network that outputs high scores for windows that occur in a large unlabeled corpus and low scores for windows where one word is replaced by a random word. When such a network is optimized via gradient ascent the derivatives backpropagate into the word embedding matrix X. In order to predict correct scores the vectors in the matrix capture co-occurrence statistics. For further details and evaluations of these embeddings, see (Turian et al., 2010; Huang et al., 2012). The resulting X matrix is used as follow</context>
</contexts>
<marker>Collobert, Weston, 2008</marker>
<rawString>R. Collobert and J. Weston. 2008. A unified architecture for natural language processing: deep neural networks with multitask learning. In Proceedings of ICML, pages 160–167.</rawString>
</citation>
<citation valid="true">
<authors>
<author>F Costa</author>
<author>P Frasconi</author>
<author>V Lombardo</author>
<author>G Soda</author>
</authors>
<title>Towards incremental parsing of natural language using recursive neural networks.</title>
<date>2003</date>
<journal>Applied Intelligence.</journal>
<contexts>
<context position="9220" citStr="Costa et al. (2003)" startWordPosition="1408" endWordPosition="1411">decisions conditioned on the parsing history. The input to Henderson’s model consists of pairs of frequent words and their part-of-speech (POS) tags. Both the original parsing system and its probabilistic interpretation (Titov and Henderson, 2007) learn features that represent the parsing history and do not provide a principled linguistic representation like our phrase representations. Other related work includes (Henderson, 2004), who discriminatively trains a parser based on synchrony networks and (Titov and Henderson, 2006), who use an SVM to adapt a generative parser to different domains. Costa et al. (2003) apply recursive neural networks to re-rank possible phrase attachments in an incremental parser. Their work is the first to show that RNNs can capture enough information to make correct parsing decisions, but they only test on a subset of 2000 sentences. Menchetti et al. (2005) use RNNs to re-rank different parses. For their results on full sentence parsing, they rerank candidate trees created by the Collins parser (Collins, 2003). Similar to their work, we use the idea of letting discrete categories reduce the search space during inference. We compare to fully tied RNNs in which the same wei</context>
<context position="11192" citStr="Costa et al., 2003" startWordPosition="1714" endWordPosition="1717"> find syntactic structure and capture compositional semantic information. CVGs build on two observations. Firstly, that a lot of the structure and regularity in languages can be captured by well-designed syntactic patterns. Hence, the CVG builds on top of a standard PCFG parser. However, many parsing decisions show fine-grained semantic factors at work. Therefore we combine syntactic and semantic information by giving the parser access to rich syntacticosemantic information in the form of distributional word vectors and compute compositional semantic vector representations for longer phrases (Costa et al., 2003; Menchetti et al., 2005; Socher et al., 2011b). The CVG model merges ideas from both generative models that assume discrete syntactic categories and discriminative models that are trained using continuous vectors. We will first briefly introduce single word vector representations and then describe the CVG objective function, tree scoring and inference. 3.1 Word Vector Representations In most systems that use a vector representation for words, such vectors are based on cooccurrence statistics of each word and its context (Turney and Pantel, 2010). Another line of research to learn distribution</context>
</contexts>
<marker>Costa, Frasconi, Lombardo, Soda, 2003</marker>
<rawString>F. Costa, P. Frasconi, V. Lombardo, and G. Soda. 2003. Towards incremental parsing of natural language using recursive neural networks. Applied Intelligence.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Duchi</author>
<author>E Hazan</author>
<author>Y Singer</author>
</authors>
<title>Adaptive subgradient methods for online learning and stochastic optimization.</title>
<date>2011</date>
<journal>JMLR,</journal>
<volume>12</volume>
<contexts>
<context position="25390" citStr="Duchi et al., 2011" startWordPosition="4259" endWordPosition="4262">ion through RNNs, see Socher et al. (2010) 460 3.6 Subgradient Methods and AdaGrad The objective function is not differentiable due to the hinge loss. Therefore, we generalize gradient ascent via the subgradient method (Ratliff et al., 2007) which computes a gradient-like direction. Let θ = (X, W(··), v(··)) E RM be a vector of all M model parameters, where we denote W(··) as the set of matrices that appear in the training set. The subgradient of Eq. 3 becomes: ∂s(xi, yi) + θ, ∂θ where ˆymax is the tree with the highest score. To minimize the objective, we use the diagonal variant of AdaGrad (Duchi et al., 2011) with minibatches. For our parameter updates, we first define gT E RM×1 to be the subgradient at time step τ and Gt = Et T=1 gTgTT . The parameter update at time step t then becomes: θt = θt−1 — α (diag(Gt))−1/2 gt, (7) where α is the learning rate. Since we use the diagonal of Gt, we only have to store M values and the update becomes fast to compute: At time step t, the update for the i’th parameter θt,i is: α θt,i = θt−1,i � 2 gt,i. ( 8) �EtT=1 gT,i Hence, the learning rate is adapting differently for each parameter and rare parameters get larger updates than frequently occurring parameters.</context>
</contexts>
<marker>Duchi, Hazan, Singer, 2011</marker>
<rawString>J. Duchi, E. Hazan, and Y. Singer. 2011. Adaptive subgradient methods for online learning and stochastic optimization. JMLR, 12, July.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J L Elman</author>
</authors>
<title>Distributed representations, simple recurrent networks, and grammatical structure.</title>
<date>1991</date>
<booktitle>Machine Learning,</booktitle>
<pages>7--2</pages>
<contexts>
<context position="7492" citStr="Elman (1991)" startWordPosition="1145" endWordPosition="1146">a factored parser. We extend the above ideas from discrete representations to richer continuous ones. The CVG can be seen as factoring discrete and continuous parsing in one model. Another different approach to the above generative models is to learn discriminative parsers using many well designed features (Taskar et al., 2004; Finkel et al., 2008). We also borrow ideas from this line of research in that our parser combines the generative PCFG model with discriminatively learned RNNs. Deep Learning and Recursive Deep Learning Early attempts at using neural networks to describe phrases include Elman (1991), who used recurrent neural networks to create representations of sentences from a simple toy grammar and to analyze the linguistic expressiveness of the resulting representations. Words were represented as one-on vectors, which was feasible since the grammar only included a handful of words. Collobert and Weston (2008) showed that neural networks can perform well on sequence labeling language processing tasks while also learning appropriate features. However, their model is lacking in that it cannot represent the recursive structure inherent in natural language. They partially circumvent this</context>
</contexts>
<marker>Elman, 1991</marker>
<rawString>J. L. Elman. 1991. Distributed representations, simple recurrent networks, and grammatical structure. Machine Learning, 7(2-3):195–225.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J R Finkel</author>
<author>A Kleeman</author>
<author>C D Manning</author>
</authors>
<title>Efficient, feature-based, conditional random field parsing.</title>
<date>2008</date>
<booktitle>In Proceedings of ACL,</booktitle>
<pages>959--967</pages>
<contexts>
<context position="2715" citStr="Finkel et al., 2008" startWordPosition="409" endWordPosition="412">ype of recursive neural network which is conditioned on syntactic categories from a PCFG. categories, which better capture phrases with similar behavior, whether through manual feature engineering (Klein and Manning, 2003a) or automatic learning (Petrov et al., 2006). However, subdividing a category like NP into 30 or 60 subcategories can only provide a very limited representation of phrase meaning and semantic similarity. Two strands of work therefore attempt to go further. First, recent work in discriminative parsing has shown gains from careful engineering of features (Taskar et al., 2004; Finkel et al., 2008). Features in such parsers can be seen as defining effective dimensions of similarity between categories. Second, lexicalized parsers (Collins, 2003; Charniak, 2000) associate each category with a lexical item. This gives a fine-grained notion of semantic similarity, which is useful for tackling problems like ambiguous attachment decisions. However, this approach necessitates complex shrinkage estimation schemes to deal with the sparsity of observations of the lexicalized categories. In many natural language systems, single words and n-grams are usefully described by their distributional simil</context>
<context position="7230" citStr="Finkel et al., 2008" startWordPosition="1102" endWordPosition="1105"> categories into several dozen subcategories. Another approach is lexicalized parsers (Collins, 2003; Charniak, 2000) that describe each category with a lexical item, usually the head word. More recently, Hall and Klein (2012) combine several such annotation schemes in a factored parser. We extend the above ideas from discrete representations to richer continuous ones. The CVG can be seen as factoring discrete and continuous parsing in one model. Another different approach to the above generative models is to learn discriminative parsers using many well designed features (Taskar et al., 2004; Finkel et al., 2008). We also borrow ideas from this line of research in that our parser combines the generative PCFG model with discriminatively learned RNNs. Deep Learning and Recursive Deep Learning Early attempts at using neural networks to describe phrases include Elman (1991), who used recurrent neural networks to create representations of sentences from a simple toy grammar and to analyze the linguistic expressiveness of the resulting representations. Words were represented as one-on vectors, which was feasible since the grammar only included a handful of words. Collobert and Weston (2008) showed that neur</context>
</contexts>
<marker>Finkel, Kleeman, Manning, 2008</marker>
<rawString>J. R. Finkel, A. Kleeman, and C. D. Manning. 2008. Efficient, feature-based, conditional random field parsing. In Proceedings of ACL, pages 959–967.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D Gildea</author>
<author>M Palmer</author>
</authors>
<title>The necessity of parsing for predicate argument recognition.</title>
<date>2002</date>
<booktitle>In Proceedings of ACL,</booktitle>
<pages>239--246</pages>
<contexts>
<context position="1572" citStr="Gildea and Palmer, 2002" startWordPosition="234" endWordPosition="237"> to train and implemented approximately as an efficient reranker it is about 20% faster than the current Stanford factored parser. The CVG learns a soft notion of head words and improves performance on the types of ambiguities that require semantic information such as PP attachments. 1 Introduction Syntactic parsing is a central task in natural language processing because of its importance in mediating between linguistic expression and meaning. For example, much work has shown the usefulness of syntactic representations for subsequent tasks such as relation extraction, semantic role labeling (Gildea and Palmer, 2002) and paraphrase detection (Callison-Burch, 2008). Syntactic descriptions standardly use coarse discrete categories such as NP for noun phrases or PP for prepositional phrases. However, recent work has shown that parsing results can be greatly improved by defining more fine-grained syntactic Discrete Syntactic – Continuous Semantic Representations in the Compositional Vector Grammar Figure 1: Example of a CVG tree with (category,vector) representations at each node. The vectors for nonterminals are computed via a new type of recursive neural network which is conditioned on syntactic categories </context>
</contexts>
<marker>Gildea, Palmer, 2002</marker>
<rawString>D. Gildea and M. Palmer. 2002. The necessity of parsing for predicate argument recognition. In Proceedings of ACL, pages 239–246.</rawString>
</citation>
<citation valid="true">
<authors>
<author>C Goller</author>
<author>A K¨uchler</author>
</authors>
<title>Learning taskdependent distributed representations by backpropagation through structure.</title>
<date>1996</date>
<booktitle>In Proceedings of the International Conference on Neural Networks.</booktitle>
<marker>Goller, K¨uchler, 1996</marker>
<rawString>C. Goller and A. K¨uchler. 1996. Learning taskdependent distributed representations by backpropagation through structure. In Proceedings of the International Conference on Neural Networks.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Goodman</author>
</authors>
<title>Parsing Inside-Out.</title>
<date>1998</date>
<tech>Ph.D. thesis,</tech>
<institution>MIT.</institution>
<contexts>
<context position="13956" citStr="Goodman, 1998" startWordPosition="2200" endWordPosition="2201">r all words, we can continue with the approach for computing tree structures and vectors for nonterminal nodes. 3.2 Max-Margin Training Objective for CVGs The goal of supervised parsing is to learn a function g : X -+ Y, where X is the set of sentences and Y is the set of all possible labeled binary parse trees. The set of all possible trees for a given sentence xi is defined as Y (xi) and the correct tree for a sentence is yi. We first define a structured margin loss A(yi, ˆy) for predicting a tree yˆ for a given correct tree. The loss increases the more incorrect the proposed parse tree is (Goodman, 1998). The discrepancy between trees is measured by counting the number of nodes N(y) with an incorrect span (or label) in the proposed tree: A(yi, ˆy) = X κ1{d E/ N(yi)J. (1) dEN(ˆy) We set κ = 0.1 in all experiments. For a given set of training instances (xi, yi), we search for the function gθ, parameterized by θ, with the smallest expected loss on a new sentence. It has the following form: gθ(x) = arg max s(CVG(θ, x, ˆy)), (2) ˆyEY (x) where the tree is found by the Compositional Vector Grammar (CVG) introduced below and then scored via the function s. The higher the score of a tree the more con</context>
</contexts>
<marker>Goodman, 1998</marker>
<rawString>J. Goodman. 1998. Parsing Inside-Out. Ph.D. thesis, MIT.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D Hall</author>
<author>D Klein</author>
</authors>
<title>Training factored pcfgs with expectation propagation.</title>
<date>2012</date>
<booktitle>In EMNLP.</booktitle>
<contexts>
<context position="6836" citStr="Hall and Klein (2012)" startWordPosition="1041" endWordPosition="1044">inputs. Improving Discrete Syntactic Representations As mentioned in the introduction, there are several approaches to improving discrete representations for parsing. Klein and Manning (2003a) use manual feature engineering, while Petrov et al. (2006) use a learning algorithm that splits and merges the syntactic categories in order to maximize likelihood on the treebank. Their approach splits categories into several dozen subcategories. Another approach is lexicalized parsers (Collins, 2003; Charniak, 2000) that describe each category with a lexical item, usually the head word. More recently, Hall and Klein (2012) combine several such annotation schemes in a factored parser. We extend the above ideas from discrete representations to richer continuous ones. The CVG can be seen as factoring discrete and continuous parsing in one model. Another different approach to the above generative models is to learn discriminative parsers using many well designed features (Taskar et al., 2004; Finkel et al., 2008). We also borrow ideas from this line of research in that our parser combines the generative PCFG model with discriminatively learned RNNs. Deep Learning and Recursive Deep Learning Early attempts at using </context>
<context position="30044" citStr="Hall and Klein, 2012" startWordPosition="5071" endWordPosition="5074">N matrix parameters to train and hence perform worse. 4.2 Results on WSJ The dev set accuracy of the best model is 90.93% labeled F1 on all sentences. This model resulted in 90.44% on the final test set (WSJ section 23). Table 1 compares our results to the two Stanford parser variants (the unlexicalized PCFG (Klein and Manning, 2003a) and the factored parser (Klein and Manning, 2003b)) and other parsers that use richer state representations: the Berkeley parser (Petrov and Klein, 2007), Collins parser (Collins, 1997), SSN: a statistical neural network parser (Henderson, 2004), Factored PCFGs (Hall and Klein, 2012), CharniakSelfTrain: the self-training approach of McClosky et al. (2006), which bootstraps and parses additional large corpora multiple times, Charniak-RS: the state of the art self-trained and discriminatively re-ranked Charniak-Johnson parser combining (Charniak, 2000; McClosky et al., 2006; Charniak and Johnson, 2005). See Kummerfeld et al. (2012) for more comparisons. We compare also to a standard RNN ‘CVG (RNN)’ and to the proposed CVG with SU-RNNs. 4.3 Model Analysis Analysis of Error Types. Table 2 shows a detailed comparison of different errors. We use the code provided by Kummerfeld </context>
</contexts>
<marker>Hall, Klein, 2012</marker>
<rawString>D. Hall and D. Klein. 2012. Training factored pcfgs with expectation propagation. In EMNLP.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Henderson</author>
</authors>
<title>Neural network probability estimation for broad coverage parsing.</title>
<date>2003</date>
<booktitle>In Proceedings of EACL.</booktitle>
<contexts>
<context position="8431" citStr="Henderson (2003)" startWordPosition="1286" endWordPosition="1287">howed that neural networks can perform well on sequence labeling language processing tasks while also learning appropriate features. However, their model is lacking in that it cannot represent the recursive structure inherent in natural language. They partially circumvent this problem by using either independent window-based classifiers or a convolutional layer. RNN-specific training was introduced by Goller and K¨uchler (1996) to learn distributed representations of given, structured objects such as logical terms. In contrast, our model both predicts the structure and its representation. 456 Henderson (2003) was the first to show that neural networks can be successfully used for large scale parsing. He introduced a left-corner parser to estimate the probabilities of parsing decisions conditioned on the parsing history. The input to Henderson’s model consists of pairs of frequent words and their part-of-speech (POS) tags. Both the original parsing system and its probabilistic interpretation (Titov and Henderson, 2007) learn features that represent the parsing history and do not provide a principled linguistic representation like our phrase representations. Other related work includes (Henderson, 2</context>
</contexts>
<marker>Henderson, 2003</marker>
<rawString>J. Henderson. 2003. Neural network probability estimation for broad coverage parsing. In Proceedings of EACL.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Henderson</author>
</authors>
<title>Discriminative training of a neural network statistical parser.</title>
<date>2004</date>
<booktitle>In ACL.</booktitle>
<contexts>
<context position="9035" citStr="Henderson, 2004" startWordPosition="1380" endWordPosition="1381">erson (2003) was the first to show that neural networks can be successfully used for large scale parsing. He introduced a left-corner parser to estimate the probabilities of parsing decisions conditioned on the parsing history. The input to Henderson’s model consists of pairs of frequent words and their part-of-speech (POS) tags. Both the original parsing system and its probabilistic interpretation (Titov and Henderson, 2007) learn features that represent the parsing history and do not provide a principled linguistic representation like our phrase representations. Other related work includes (Henderson, 2004), who discriminatively trains a parser based on synchrony networks and (Titov and Henderson, 2006), who use an SVM to adapt a generative parser to different domains. Costa et al. (2003) apply recursive neural networks to re-rank possible phrase attachments in an incremental parser. Their work is the first to show that RNNs can capture enough information to make correct parsing decisions, but they only test on a subset of 2000 sentences. Menchetti et al. (2005) use RNNs to re-rank different parses. For their results on full sentence parsing, they rerank candidate trees created by the Collins pa</context>
<context position="30005" citStr="Henderson, 2004" startWordPosition="5066" endWordPosition="5067">nowledge, result in too many SU-RNN matrix parameters to train and hence perform worse. 4.2 Results on WSJ The dev set accuracy of the best model is 90.93% labeled F1 on all sentences. This model resulted in 90.44% on the final test set (WSJ section 23). Table 1 compares our results to the two Stanford parser variants (the unlexicalized PCFG (Klein and Manning, 2003a) and the factored parser (Klein and Manning, 2003b)) and other parsers that use richer state representations: the Berkeley parser (Petrov and Klein, 2007), Collins parser (Collins, 1997), SSN: a statistical neural network parser (Henderson, 2004), Factored PCFGs (Hall and Klein, 2012), CharniakSelfTrain: the self-training approach of McClosky et al. (2006), which bootstraps and parses additional large corpora multiple times, Charniak-RS: the state of the art self-trained and discriminatively re-ranked Charniak-Johnson parser combining (Charniak, 2000; McClosky et al., 2006; Charniak and Johnson, 2005). See Kummerfeld et al. (2012) for more comparisons. We compare also to a standard RNN ‘CVG (RNN)’ and to the proposed CVG with SU-RNNs. 4.3 Model Analysis Analysis of Error Types. Table 2 shows a detailed comparison of different errors. </context>
</contexts>
<marker>Henderson, 2004</marker>
<rawString>J. Henderson. 2004. Discriminative training of a neural network statistical parser. In ACL.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Liang Huang</author>
<author>David Chiang</author>
</authors>
<title>Better k-best parsing.</title>
<date>2005</date>
<booktitle>In Proceedings of the 9th International Workshop on Parsing Technologies (IWPT</booktitle>
<contexts>
<context position="23297" citStr="Huang and Chiang, 2005" startWordPosition="3889" endWordPosition="3892">uce the number of SU-RNN score computations to only those trees that require semantic information. We note that labeled F1 of the Stanford PCFG parser on the test set is 86.17%. However, if one used an oracle to select the best tree from the top 200 trees that it produces, one could get an F1 of 95.46%. We use this knowledge to speed up inference via two bottom-up passes through the parsing chart. During the first one, we use only the base PCFG to run CKY dynamic programming through the tree. The k = 200-best parses at the top cell of the chart are calculated using the efficient algorithm of (Huang and Chiang, 2005). Then, the second pass is a beam search with the full CVG model (including the more expensive matrix multiplications of the SU-RNN). This beam search only considers phrases that appear in the top 200 parses. This is similar to a re-ranking setup but with one main difference: the SU-RNN rule score computation at each node still only has access to its child vectors, not the whole tree or other global features. This allows the second pass to be very fast. We use this setup in our experiments below. 3.5 Training SU-RNNs The full CVG model is trained in two stages. First the base PCFG is trained a</context>
</contexts>
<marker>Huang, Chiang, 2005</marker>
<rawString>Liang Huang and David Chiang. 2005. Better k-best parsing. In Proceedings of the 9th International Workshop on Parsing Technologies (IWPT 2005).</rawString>
</citation>
<citation valid="true">
<authors>
<author>E H Huang</author>
<author>R Socher</author>
<author>C D Manning</author>
<author>A Y Ng</author>
</authors>
<title>Improving Word Representations via Global Context and Multiple Word Prototypes.</title>
<date>2012</date>
<booktitle>In ACL.</booktitle>
<contexts>
<context position="12751" citStr="Huang et al., 2012" startWordPosition="1970" endWordPosition="1973">n ≈ queen (Mikolov et al., 2013). Collobert and Weston (2008) introduced a new model to compute such an embedding. The idea is to construct a neural network that outputs high scores for windows that occur in a large unlabeled corpus and low scores for windows where one word is replaced by a random word. When such a network is optimized via gradient ascent the derivatives backpropagate into the word embedding matrix X. In order to predict correct scores the vectors in the matrix capture co-occurrence statistics. For further details and evaluations of these embeddings, see (Turian et al., 2010; Huang et al., 2012). The resulting X matrix is used as follows. Assume we are given a sentence as an ordered list of m words. Each word w has an index [w] = i into the columns of the embedding matrix. This index is used to retrieve the word’s vector representation a,,, using a simple multiplication with a binary vector e, which is zero everywhere, except 457 at the ith index. So aw = Lei E Rn. Henceforth, after mapping each word to its vector, we represent a sentence S as an ordered list of (word,vector) pairs: x = ((w1, aw1), ... , (wm, awm)). Now that we have discrete and continuous representations for all wor</context>
</contexts>
<marker>Huang, Socher, Manning, Ng, 2012</marker>
<rawString>E. H. Huang, R. Socher, C. D. Manning, and A. Y. Ng. 2012. Improving Word Representations via Global Context and Multiple Word Prototypes. In ACL.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D Kartsaklis</author>
<author>M Sadrzadeh</author>
<author>S Pulman</author>
</authors>
<title>A unified sentence space for categorical distributionalcompositional semantics: Theory and experiments.</title>
<date>2012</date>
<booktitle>Proceedings of 24th International Conference on Computational Linguistics (COLING):</booktitle>
<publisher>Posters.</publisher>
<contexts>
<context position="10460" citStr="Kartsaklis et al., 2012" startWordPosition="1609" endWordPosition="1612"> every node. Our syntactically untied RNNs outperform them by a significant margin. The idea of untying has also been successfully used in deep learning applied to vision (Le et al., 2010). This paper uses several ideas of (Socher et al., 2011b). The main differences are (i) the dual representation of nodes as discrete categories and vectors, (ii) the combination with a PCFG, and (iii) the syntactic untying of weights based on child categories. We directly compare models with fully tied and untied weights. Another work that represents phrases with a dual discrete-continuous representation is (Kartsaklis et al., 2012). 3 Compositional Vector Grammars This section introduces Compositional Vector Grammars (CVGs), a model to jointly find syntactic structure and capture compositional semantic information. CVGs build on two observations. Firstly, that a lot of the structure and regularity in languages can be captured by well-designed syntactic patterns. Hence, the CVG builds on top of a standard PCFG parser. However, many parsing decisions show fine-grained semantic factors at work. Therefore we combine syntactic and semantic information by giving the parser access to rich syntacticosemantic information in the </context>
</contexts>
<marker>Kartsaklis, Sadrzadeh, Pulman, 2012</marker>
<rawString>D. Kartsaklis, M. Sadrzadeh, and S. Pulman. 2012. A unified sentence space for categorical distributionalcompositional semantics: Theory and experiments. Proceedings of 24th International Conference on Computational Linguistics (COLING): Posters.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D Klein</author>
<author>C D Manning</author>
</authors>
<title>Accurate unlexicalized parsing.</title>
<date>2003</date>
<booktitle>In Proceedings of ACL,</booktitle>
<pages>423--430</pages>
<contexts>
<context position="2316" citStr="Klein and Manning, 2003" startWordPosition="342" endWordPosition="345">s NP for noun phrases or PP for prepositional phrases. However, recent work has shown that parsing results can be greatly improved by defining more fine-grained syntactic Discrete Syntactic – Continuous Semantic Representations in the Compositional Vector Grammar Figure 1: Example of a CVG tree with (category,vector) representations at each node. The vectors for nonterminals are computed via a new type of recursive neural network which is conditioned on syntactic categories from a PCFG. categories, which better capture phrases with similar behavior, whether through manual feature engineering (Klein and Manning, 2003a) or automatic learning (Petrov et al., 2006). However, subdividing a category like NP into 30 or 60 subcategories can only provide a very limited representation of phrase meaning and semantic similarity. Two strands of work therefore attempt to go further. First, recent work in discriminative parsing has shown gains from careful engineering of features (Taskar et al., 2004; Finkel et al., 2008). Features in such parsers can be seen as defining effective dimensions of similarity between categories. Second, lexicalized parsers (Collins, 2003; Charniak, 2000) associate each category with a lexi</context>
<context position="5788" citStr="Klein and Manning, 2003" startWordPosition="885" endWordPosition="888">eural network. We generalize the fully tied RNN to one with syntactically untied weights. The weights at each node are conditionally dependent on the categories of the child constituents. This allows different composition functions when combining different types of phrases and is shown to result in a large improvement in parsing accuracy. Our compositional distributed representation allows a CVG parser to make accurate parsing decisions and capture similarities between phrases and sentences. Any PCFG-based parser can be improved with an RNN. We use a simplified version of the Stanford Parser (Klein and Manning, 2003a) as the base PCFG and improve its accuracy from 86.56 to 90.44% labeled F1 on all sentences of the WSJ section 23. The code of our parser is available at nlp.stanford.edu. 2 Related Work The CVG is inspired by two lines of research: Enriching PCFG parsers through more diverse sets of discrete states and recursive deep learning models that jointly learn classifiers and continuous feature representations for variable-sized inputs. Improving Discrete Syntactic Representations As mentioned in the introduction, there are several approaches to improving discrete representations for parsing. Klein </context>
<context position="27254" citStr="Klein and Manning, 2003" startWordPosition="4601" endWordPosition="4604">ias in the last column and the random variable is uniformly distributed: E — U[-0.001, 0.001]. The first block is multiplied by the left child and the second by the right child: ⎤ ⎡ ⎤ a [W(A)W(B)bias] ⎣b ⎦ 1 = W(A)a + W(B)b + bias. 4 Experiments We evaluate the CVG in two ways: First, by a standard parsing evaluation on Penn Treebank WSJ and then by analyzing the model errors in detail. 4.1 Cross-validating Hyperparameters We used the first 20 files of WSJ section 22 to cross-validate several model and optimization choices. The base PCFG uses simplified categories of the Stanford PCFG Parser (Klein and Manning, 2003a). We decreased the state splitting of the PCFG grammar (which helps both by making it less sparse and by reducing the number of parameters in the SU-RNN) by adding the following options to training: ‘-noRightRec - dominatesV 0 -baseNP 0’. This reduces the number of states from 15,276 to 12,061 states and 602 POS tags. These include split categories, such as parent annotation categories like VPˆS. Furthermore, we ignore all category splits for the SURNN weights, resulting in 66 unary and 882 binary child pairs. Hence, the SU-RNN has 66+882 transformation matrices and scoring vectors. Note tha</context>
<context position="29757" citStr="Klein and Manning, 2003" startWordPosition="5028" endWordPosition="5031">ith richer state representations on the WSJ. The last line is the self-trained re-ranked Charniak parser. performance and were faster than 50-,100- or 200- dimensional ones. We hypothesize that the larger word vector sizes, while capturing more semantic knowledge, result in too many SU-RNN matrix parameters to train and hence perform worse. 4.2 Results on WSJ The dev set accuracy of the best model is 90.93% labeled F1 on all sentences. This model resulted in 90.44% on the final test set (WSJ section 23). Table 1 compares our results to the two Stanford parser variants (the unlexicalized PCFG (Klein and Manning, 2003a) and the factored parser (Klein and Manning, 2003b)) and other parsers that use richer state representations: the Berkeley parser (Petrov and Klein, 2007), Collins parser (Collins, 1997), SSN: a statistical neural network parser (Henderson, 2004), Factored PCFGs (Hall and Klein, 2012), CharniakSelfTrain: the self-training approach of McClosky et al. (2006), which bootstraps and parses additional large corpora multiple times, Charniak-RS: the state of the art self-trained and discriminatively re-ranked Charniak-Johnson parser combining (Charniak, 2000; McClosky et al., 2006; Charniak and John</context>
</contexts>
<marker>Klein, Manning, 2003</marker>
<rawString>D. Klein and C. D. Manning. 2003a. Accurate unlexicalized parsing. In Proceedings of ACL, pages 423–430.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D Klein</author>
<author>C D Manning</author>
</authors>
<title>Fast exact inference with a factored model for natural language parsing.</title>
<date>2003</date>
<booktitle>In NIPS.</booktitle>
<contexts>
<context position="2316" citStr="Klein and Manning, 2003" startWordPosition="342" endWordPosition="345">s NP for noun phrases or PP for prepositional phrases. However, recent work has shown that parsing results can be greatly improved by defining more fine-grained syntactic Discrete Syntactic – Continuous Semantic Representations in the Compositional Vector Grammar Figure 1: Example of a CVG tree with (category,vector) representations at each node. The vectors for nonterminals are computed via a new type of recursive neural network which is conditioned on syntactic categories from a PCFG. categories, which better capture phrases with similar behavior, whether through manual feature engineering (Klein and Manning, 2003a) or automatic learning (Petrov et al., 2006). However, subdividing a category like NP into 30 or 60 subcategories can only provide a very limited representation of phrase meaning and semantic similarity. Two strands of work therefore attempt to go further. First, recent work in discriminative parsing has shown gains from careful engineering of features (Taskar et al., 2004; Finkel et al., 2008). Features in such parsers can be seen as defining effective dimensions of similarity between categories. Second, lexicalized parsers (Collins, 2003; Charniak, 2000) associate each category with a lexi</context>
<context position="5788" citStr="Klein and Manning, 2003" startWordPosition="885" endWordPosition="888">eural network. We generalize the fully tied RNN to one with syntactically untied weights. The weights at each node are conditionally dependent on the categories of the child constituents. This allows different composition functions when combining different types of phrases and is shown to result in a large improvement in parsing accuracy. Our compositional distributed representation allows a CVG parser to make accurate parsing decisions and capture similarities between phrases and sentences. Any PCFG-based parser can be improved with an RNN. We use a simplified version of the Stanford Parser (Klein and Manning, 2003a) as the base PCFG and improve its accuracy from 86.56 to 90.44% labeled F1 on all sentences of the WSJ section 23. The code of our parser is available at nlp.stanford.edu. 2 Related Work The CVG is inspired by two lines of research: Enriching PCFG parsers through more diverse sets of discrete states and recursive deep learning models that jointly learn classifiers and continuous feature representations for variable-sized inputs. Improving Discrete Syntactic Representations As mentioned in the introduction, there are several approaches to improving discrete representations for parsing. Klein </context>
<context position="27254" citStr="Klein and Manning, 2003" startWordPosition="4601" endWordPosition="4604">ias in the last column and the random variable is uniformly distributed: E — U[-0.001, 0.001]. The first block is multiplied by the left child and the second by the right child: ⎤ ⎡ ⎤ a [W(A)W(B)bias] ⎣b ⎦ 1 = W(A)a + W(B)b + bias. 4 Experiments We evaluate the CVG in two ways: First, by a standard parsing evaluation on Penn Treebank WSJ and then by analyzing the model errors in detail. 4.1 Cross-validating Hyperparameters We used the first 20 files of WSJ section 22 to cross-validate several model and optimization choices. The base PCFG uses simplified categories of the Stanford PCFG Parser (Klein and Manning, 2003a). We decreased the state splitting of the PCFG grammar (which helps both by making it less sparse and by reducing the number of parameters in the SU-RNN) by adding the following options to training: ‘-noRightRec - dominatesV 0 -baseNP 0’. This reduces the number of states from 15,276 to 12,061 states and 602 POS tags. These include split categories, such as parent annotation categories like VPˆS. Furthermore, we ignore all category splits for the SURNN weights, resulting in 66 unary and 882 binary child pairs. Hence, the SU-RNN has 66+882 transformation matrices and scoring vectors. Note tha</context>
<context position="29757" citStr="Klein and Manning, 2003" startWordPosition="5028" endWordPosition="5031">ith richer state representations on the WSJ. The last line is the self-trained re-ranked Charniak parser. performance and were faster than 50-,100- or 200- dimensional ones. We hypothesize that the larger word vector sizes, while capturing more semantic knowledge, result in too many SU-RNN matrix parameters to train and hence perform worse. 4.2 Results on WSJ The dev set accuracy of the best model is 90.93% labeled F1 on all sentences. This model resulted in 90.44% on the final test set (WSJ section 23). Table 1 compares our results to the two Stanford parser variants (the unlexicalized PCFG (Klein and Manning, 2003a) and the factored parser (Klein and Manning, 2003b)) and other parsers that use richer state representations: the Berkeley parser (Petrov and Klein, 2007), Collins parser (Collins, 1997), SSN: a statistical neural network parser (Henderson, 2004), Factored PCFGs (Hall and Klein, 2012), CharniakSelfTrain: the self-training approach of McClosky et al. (2006), which bootstraps and parses additional large corpora multiple times, Charniak-RS: the state of the art self-trained and discriminatively re-ranked Charniak-Johnson parser combining (Charniak, 2000; McClosky et al., 2006; Charniak and John</context>
</contexts>
<marker>Klein, Manning, 2003</marker>
<rawString>D. Klein and C.D. Manning. 2003b. Fast exact inference with a factored model for natural language parsing. In NIPS.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J K Kummerfeld</author>
<author>D Hall</author>
<author>J R Curran</author>
<author>D Klein</author>
</authors>
<title>Parser showdown at the wall street corral: An empirical investigation of error types in parser output.</title>
<date>2012</date>
<booktitle>In EMNLP.</booktitle>
<contexts>
<context position="30397" citStr="Kummerfeld et al. (2012)" startWordPosition="5122" endWordPosition="5125">red parser (Klein and Manning, 2003b)) and other parsers that use richer state representations: the Berkeley parser (Petrov and Klein, 2007), Collins parser (Collins, 1997), SSN: a statistical neural network parser (Henderson, 2004), Factored PCFGs (Hall and Klein, 2012), CharniakSelfTrain: the self-training approach of McClosky et al. (2006), which bootstraps and parses additional large corpora multiple times, Charniak-RS: the state of the art self-trained and discriminatively re-ranked Charniak-Johnson parser combining (Charniak, 2000; McClosky et al., 2006; Charniak and Johnson, 2005). See Kummerfeld et al. (2012) for more comparisons. We compare also to a standard RNN ‘CVG (RNN)’ and to the proposed CVG with SU-RNNs. 4.3 Model Analysis Analysis of Error Types. Table 2 shows a detailed comparison of different errors. We use the code provided by Kummerfeld et al. (2012) and compare to the previous version of the Stanford factored parser as well as to the Berkeley and Charniak-reranked-self-trained parsers (defined above). See Kummerfeld et al. (2012) for details and comparisons to other parsers. One of Error Type Stanford CVG Berkeley Char-RS PP Attach 1.02 0.79 0.82 0.60 Clause Attach 0.64 0.43 0.50 0.</context>
</contexts>
<marker>Kummerfeld, Hall, Curran, Klein, 2012</marker>
<rawString>J. K. Kummerfeld, D. Hall, J. R. Curran, and D. Klein. 2012. Parser showdown at the wall street corral: An empirical investigation of error types in parser output. In EMNLP.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Q V Le</author>
<author>J Ngiam</author>
<author>Z Chen</author>
<author>D Chia</author>
<author>P W Koh</author>
<author>A Y Ng</author>
</authors>
<title>Tiled convolutional neural networks.</title>
<date>2010</date>
<booktitle>In NIPS.</booktitle>
<contexts>
<context position="10024" citStr="Le et al., 2010" startWordPosition="1542" endWordPosition="1545">arsing decisions, but they only test on a subset of 2000 sentences. Menchetti et al. (2005) use RNNs to re-rank different parses. For their results on full sentence parsing, they rerank candidate trees created by the Collins parser (Collins, 2003). Similar to their work, we use the idea of letting discrete categories reduce the search space during inference. We compare to fully tied RNNs in which the same weights are used at every node. Our syntactically untied RNNs outperform them by a significant margin. The idea of untying has also been successfully used in deep learning applied to vision (Le et al., 2010). This paper uses several ideas of (Socher et al., 2011b). The main differences are (i) the dual representation of nodes as discrete categories and vectors, (ii) the combination with a PCFG, and (iii) the syntactic untying of weights based on child categories. We directly compare models with fully tied and untied weights. Another work that represents phrases with a dual discrete-continuous representation is (Kartsaklis et al., 2012). 3 Compositional Vector Grammars This section introduces Compositional Vector Grammars (CVGs), a model to jointly find syntactic structure and capture compositiona</context>
</contexts>
<marker>Le, Ngiam, Chen, Chia, Koh, Ng, 2010</marker>
<rawString>Q. V. Le, J. Ngiam, Z. Chen, D. Chia, P. W. Koh, and A. Y. Ng. 2010. Tiled convolutional neural networks. In NIPS.</rawString>
</citation>
<citation valid="true">
<authors>
<author>T Matsuzaki</author>
<author>Y Miyao</author>
<author>J Tsujii</author>
</authors>
<title>Probabilistic cfg with latent annotations.</title>
<date>2005</date>
<booktitle>In ACL.</booktitle>
<contexts>
<context position="27924" citStr="Matsuzaki et al., 2005" startWordPosition="4714" endWordPosition="4717">G grammar (which helps both by making it less sparse and by reducing the number of parameters in the SU-RNN) by adding the following options to training: ‘-noRightRec - dominatesV 0 -baseNP 0’. This reduces the number of states from 15,276 to 12,061 states and 602 POS tags. These include split categories, such as parent annotation categories like VPˆS. Furthermore, we ignore all category splits for the SURNN weights, resulting in 66 unary and 882 binary child pairs. Hence, the SU-RNN has 66+882 transformation matrices and scoring vectors. Note that any PCFG, including latent annotation PCFGs (Matsuzaki et al., 2005) could be used. However, since the vectors will capture lexical and semantic information, even simple base PCFGs can be substantially improved. Since the computational complexity of PCFGs depends on the number of states, a base PCFG with fewer states is much faster. Testing on the full WSJ section 22 dev set (1700 sentences) takes roughly 470 seconds with the simple base PCFG, 1320 seconds with our new CVG and 1600 seconds with the currently published Stanford factored parser. Hence, increased performance comes also with a speed improvement of approximately 20%. We fix the same regularization </context>
</contexts>
<marker>Matsuzaki, Miyao, Tsujii, 2005</marker>
<rawString>T. Matsuzaki, Y. Miyao, and J. Tsujii. 2005. Probabilistic cfg with latent annotations. In ACL.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D McClosky</author>
<author>E Charniak</author>
<author>M Johnson</author>
</authors>
<title>Effective self-training for parsing.</title>
<date>2006</date>
<booktitle>In NAACL.</booktitle>
<contexts>
<context position="30117" citStr="McClosky et al. (2006)" startWordPosition="5081" endWordPosition="5084"> The dev set accuracy of the best model is 90.93% labeled F1 on all sentences. This model resulted in 90.44% on the final test set (WSJ section 23). Table 1 compares our results to the two Stanford parser variants (the unlexicalized PCFG (Klein and Manning, 2003a) and the factored parser (Klein and Manning, 2003b)) and other parsers that use richer state representations: the Berkeley parser (Petrov and Klein, 2007), Collins parser (Collins, 1997), SSN: a statistical neural network parser (Henderson, 2004), Factored PCFGs (Hall and Klein, 2012), CharniakSelfTrain: the self-training approach of McClosky et al. (2006), which bootstraps and parses additional large corpora multiple times, Charniak-RS: the state of the art self-trained and discriminatively re-ranked Charniak-Johnson parser combining (Charniak, 2000; McClosky et al., 2006; Charniak and Johnson, 2005). See Kummerfeld et al. (2012) for more comparisons. We compare also to a standard RNN ‘CVG (RNN)’ and to the proposed CVG with SU-RNNs. 4.3 Model Analysis Analysis of Error Types. Table 2 shows a detailed comparison of different errors. We use the code provided by Kummerfeld et al. (2012) and compare to the previous version of the Stanford factore</context>
</contexts>
<marker>McClosky, Charniak, Johnson, 2006</marker>
<rawString>D. McClosky, E. Charniak, and M. Johnson. 2006. Effective self-training for parsing. In NAACL.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S Menchetti</author>
<author>F Costa</author>
<author>P Frasconi</author>
<author>M Pontil</author>
</authors>
<title>Wide coverage natural language processing using kernel methods and neural networks for structured data.</title>
<date>2005</date>
<journal>Pattern Recognition Letters,</journal>
<volume>26</volume>
<issue>12</issue>
<contexts>
<context position="9499" citStr="Menchetti et al. (2005)" startWordPosition="1454" endWordPosition="1457">nt the parsing history and do not provide a principled linguistic representation like our phrase representations. Other related work includes (Henderson, 2004), who discriminatively trains a parser based on synchrony networks and (Titov and Henderson, 2006), who use an SVM to adapt a generative parser to different domains. Costa et al. (2003) apply recursive neural networks to re-rank possible phrase attachments in an incremental parser. Their work is the first to show that RNNs can capture enough information to make correct parsing decisions, but they only test on a subset of 2000 sentences. Menchetti et al. (2005) use RNNs to re-rank different parses. For their results on full sentence parsing, they rerank candidate trees created by the Collins parser (Collins, 2003). Similar to their work, we use the idea of letting discrete categories reduce the search space during inference. We compare to fully tied RNNs in which the same weights are used at every node. Our syntactically untied RNNs outperform them by a significant margin. The idea of untying has also been successfully used in deep learning applied to vision (Le et al., 2010). This paper uses several ideas of (Socher et al., 2011b). The main differe</context>
<context position="11216" citStr="Menchetti et al., 2005" startWordPosition="1718" endWordPosition="1721">cture and capture compositional semantic information. CVGs build on two observations. Firstly, that a lot of the structure and regularity in languages can be captured by well-designed syntactic patterns. Hence, the CVG builds on top of a standard PCFG parser. However, many parsing decisions show fine-grained semantic factors at work. Therefore we combine syntactic and semantic information by giving the parser access to rich syntacticosemantic information in the form of distributional word vectors and compute compositional semantic vector representations for longer phrases (Costa et al., 2003; Menchetti et al., 2005; Socher et al., 2011b). The CVG model merges ideas from both generative models that assume discrete syntactic categories and discriminative models that are trained using continuous vectors. We will first briefly introduce single word vector representations and then describe the CVG objective function, tree scoring and inference. 3.1 Word Vector Representations In most systems that use a vector representation for words, such vectors are based on cooccurrence statistics of each word and its context (Turney and Pantel, 2010). Another line of research to learn distributional word vectors is based</context>
</contexts>
<marker>Menchetti, Costa, Frasconi, Pontil, 2005</marker>
<rawString>S. Menchetti, F. Costa, P. Frasconi, and M. Pontil. 2005. Wide coverage natural language processing using kernel methods and neural networks for structured data. Pattern Recognition Letters, 26(12):1896–1906.</rawString>
</citation>
<citation valid="true">
<authors>
<author>T Mikolov</author>
<author>W Yih</author>
<author>G Zweig</author>
</authors>
<title>Linguistic regularities in continuous spaceword representations.</title>
<date>2013</date>
<booktitle>In HLT-NAACL.</booktitle>
<contexts>
<context position="12164" citStr="Mikolov et al., 2013" startWordPosition="1870" endWordPosition="1873">nce. 3.1 Word Vector Representations In most systems that use a vector representation for words, such vectors are based on cooccurrence statistics of each word and its context (Turney and Pantel, 2010). Another line of research to learn distributional word vectors is based on neural language models (Bengio et al., 2003) which jointly learn an embedding of words into an n-dimensional feature space and use these embeddings to predict how suitable a word is in its context. These vector representations capture interesting linear relationships (up to some accuracy), such as king−man+woman ≈ queen (Mikolov et al., 2013). Collobert and Weston (2008) introduced a new model to compute such an embedding. The idea is to construct a neural network that outputs high scores for windows that occur in a large unlabeled corpus and low scores for windows where one word is replaced by a random word. When such a network is optimized via gradient ascent the derivatives backpropagate into the word embedding matrix X. In order to predict correct scores the vectors in the matrix capture co-occurrence statistics. For further details and evaluations of these embeddings, see (Turian et al., 2010; Huang et al., 2012). The resulti</context>
</contexts>
<marker>Mikolov, Yih, Zweig, 2013</marker>
<rawString>T. Mikolov, W. Yih, and G. Zweig. 2013. Linguistic regularities in continuous spaceword representations. In HLT-NAACL.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S Petrov</author>
<author>D Klein</author>
</authors>
<title>Improved inference for unlexicalized parsing.</title>
<date>2007</date>
<booktitle>In NAACL.</booktitle>
<contexts>
<context position="29913" citStr="Petrov and Klein, 2007" startWordPosition="5052" endWordPosition="5055">dimensional ones. We hypothesize that the larger word vector sizes, while capturing more semantic knowledge, result in too many SU-RNN matrix parameters to train and hence perform worse. 4.2 Results on WSJ The dev set accuracy of the best model is 90.93% labeled F1 on all sentences. This model resulted in 90.44% on the final test set (WSJ section 23). Table 1 compares our results to the two Stanford parser variants (the unlexicalized PCFG (Klein and Manning, 2003a) and the factored parser (Klein and Manning, 2003b)) and other parsers that use richer state representations: the Berkeley parser (Petrov and Klein, 2007), Collins parser (Collins, 1997), SSN: a statistical neural network parser (Henderson, 2004), Factored PCFGs (Hall and Klein, 2012), CharniakSelfTrain: the self-training approach of McClosky et al. (2006), which bootstraps and parses additional large corpora multiple times, Charniak-RS: the state of the art self-trained and discriminatively re-ranked Charniak-Johnson parser combining (Charniak, 2000; McClosky et al., 2006; Charniak and Johnson, 2005). See Kummerfeld et al. (2012) for more comparisons. We compare also to a standard RNN ‘CVG (RNN)’ and to the proposed CVG with SU-RNNs. 4.3 Model</context>
</contexts>
<marker>Petrov, Klein, 2007</marker>
<rawString>S. Petrov and D. Klein. 2007. Improved inference for unlexicalized parsing. In NAACL.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S Petrov</author>
<author>L Barrett</author>
<author>R Thibaux</author>
<author>D Klein</author>
</authors>
<title>Learning accurate, compact, and interpretable tree annotation.</title>
<date>2006</date>
<booktitle>In Proceedings of ACL,</booktitle>
<pages>433--440</pages>
<contexts>
<context position="2362" citStr="Petrov et al., 2006" startWordPosition="349" endWordPosition="352">ases. However, recent work has shown that parsing results can be greatly improved by defining more fine-grained syntactic Discrete Syntactic – Continuous Semantic Representations in the Compositional Vector Grammar Figure 1: Example of a CVG tree with (category,vector) representations at each node. The vectors for nonterminals are computed via a new type of recursive neural network which is conditioned on syntactic categories from a PCFG. categories, which better capture phrases with similar behavior, whether through manual feature engineering (Klein and Manning, 2003a) or automatic learning (Petrov et al., 2006). However, subdividing a category like NP into 30 or 60 subcategories can only provide a very limited representation of phrase meaning and semantic similarity. Two strands of work therefore attempt to go further. First, recent work in discriminative parsing has shown gains from careful engineering of features (Taskar et al., 2004; Finkel et al., 2008). Features in such parsers can be seen as defining effective dimensions of similarity between categories. Second, lexicalized parsers (Collins, 2003; Charniak, 2000) associate each category with a lexical item. This gives a fine-grained notion of </context>
<context position="6466" citStr="Petrov et al. (2006)" startWordPosition="987" endWordPosition="990"> 90.44% labeled F1 on all sentences of the WSJ section 23. The code of our parser is available at nlp.stanford.edu. 2 Related Work The CVG is inspired by two lines of research: Enriching PCFG parsers through more diverse sets of discrete states and recursive deep learning models that jointly learn classifiers and continuous feature representations for variable-sized inputs. Improving Discrete Syntactic Representations As mentioned in the introduction, there are several approaches to improving discrete representations for parsing. Klein and Manning (2003a) use manual feature engineering, while Petrov et al. (2006) use a learning algorithm that splits and merges the syntactic categories in order to maximize likelihood on the treebank. Their approach splits categories into several dozen subcategories. Another approach is lexicalized parsers (Collins, 2003; Charniak, 2000) that describe each category with a lexical item, usually the head word. More recently, Hall and Klein (2012) combine several such annotation schemes in a factored parser. We extend the above ideas from discrete representations to richer continuous ones. The CVG can be seen as factoring discrete and continuous parsing in one model. Anoth</context>
</contexts>
<marker>Petrov, Barrett, Thibaux, Klein, 2006</marker>
<rawString>S. Petrov, L. Barrett, R. Thibaux, and D. Klein. 2006. Learning accurate, compact, and interpretable tree annotation. In Proceedings of ACL, pages 433–440.</rawString>
</citation>
<citation valid="true">
<authors>
<author>N Ratliff</author>
<author>J A Bagnell</author>
<author>M Zinkevich</author>
</authors>
<title>(Online) subgradient methods for structured prediction.</title>
<date>2007</date>
<booktitle>In Eleventh International Conference on Artificial Intelligence and Statistics (AIStats).</booktitle>
<contexts>
<context position="14700" citStr="Ratliff et al., 2007" startWordPosition="2333" endWordPosition="2336">oposed tree: A(yi, ˆy) = X κ1{d E/ N(yi)J. (1) dEN(ˆy) We set κ = 0.1 in all experiments. For a given set of training instances (xi, yi), we search for the function gθ, parameterized by θ, with the smallest expected loss on a new sentence. It has the following form: gθ(x) = arg max s(CVG(θ, x, ˆy)), (2) ˆyEY (x) where the tree is found by the Compositional Vector Grammar (CVG) introduced below and then scored via the function s. The higher the score of a tree the more confident the algorithm is that its structure is correct. This max-margin, structureprediction objective (Taskar et al., 2004; Ratliff et al., 2007; Socher et al., 2011b) trains the CVG so that the highest scoring tree will be the correct tree: gθ(xi) = yi and its score will be larger up to a margin to other possible trees yˆ E Y(xi): s(CVG(θ, xi, yi)) &gt;— s(CVG(θ, xi, ˆy)) + A(yi, ˆy). This leads to the regularized risk function for m training examples: λ ri(θ) + 2 11θ1122, where ri(θ) = max (s(CVG(xi, ˆy)) + A(yi, ˆy)) ˆyEY (xi) − s(CVG(xi, yi)) (3) Intuitively, to minimize this objective, the score of the correct tree yi is increased and the score of the highest scoring incorrect tree yˆ is decreased. 3.3 Scoring Trees with CVGs For ea</context>
<context position="25012" citStr="Ratliff et al., 2007" startWordPosition="4187" endWordPosition="4190">agation through structure (BTS) (Goller and K¨uchler, 1996). The derivative of tree i has to be taken with respect to all parameter matrices W (AB) that appear in it. The main difference between backpropagation in standard RNNs and SURNNs is that the derivatives at each node only add to the overall derivative of the specific matrix at that node. For more details on backpropagation through RNNs, see Socher et al. (2010) 460 3.6 Subgradient Methods and AdaGrad The objective function is not differentiable due to the hinge loss. Therefore, we generalize gradient ascent via the subgradient method (Ratliff et al., 2007) which computes a gradient-like direction. Let θ = (X, W(··), v(··)) E RM be a vector of all M model parameters, where we denote W(··) as the set of matrices that appear in the training set. The subgradient of Eq. 3 becomes: ∂s(xi, yi) + θ, ∂θ where ˆymax is the tree with the highest score. To minimize the objective, we use the diagonal variant of AdaGrad (Duchi et al., 2011) with minibatches. For our parameter updates, we first define gT E RM×1 to be the subgradient at time step τ and Gt = Et T=1 gTgTT . The parameter update at time step t then becomes: θt = θt−1 — α (diag(Gt))−1/2 gt, (7) wh</context>
</contexts>
<marker>Ratliff, Bagnell, Zinkevich, 2007</marker>
<rawString>N. Ratliff, J. A. Bagnell, and M. Zinkevich. 2007. (Online) subgradient methods for structured prediction. In Eleventh International Conference on Artificial Intelligence and Statistics (AIStats).</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Socher</author>
<author>C D Manning</author>
<author>A Y Ng</author>
</authors>
<title>Learning continuous phrase representations and syntactic parsing with recursive neural networks.</title>
<date>2010</date>
<booktitle>In Proceedings of the NIPS-2010 Deep Learning and Unsupervised Feature Learning Workshop.</booktitle>
<contexts>
<context position="24813" citStr="Socher et al. (2010)" startWordPosition="4157" endWordPosition="4160"> minimize the objective we want to increase the scores of the correct tree’s constituents and decrease the score of those in the highest scoring incorrect tree. Derivatives are computed via backpropagation through structure (BTS) (Goller and K¨uchler, 1996). The derivative of tree i has to be taken with respect to all parameter matrices W (AB) that appear in it. The main difference between backpropagation in standard RNNs and SURNNs is that the derivatives at each node only add to the overall derivative of the specific matrix at that node. For more details on backpropagation through RNNs, see Socher et al. (2010) 460 3.6 Subgradient Methods and AdaGrad The objective function is not differentiable due to the hinge loss. Therefore, we generalize gradient ascent via the subgradient method (Ratliff et al., 2007) which computes a gradient-like direction. Let θ = (X, W(··), v(··)) E RM be a vector of all M model parameters, where we denote W(··) as the set of matrices that appear in the training set. The subgradient of Eq. 3 becomes: ∂s(xi, yi) + θ, ∂θ where ˆymax is the tree with the highest score. To minimize the objective, we use the diagonal variant of AdaGrad (Duchi et al., 2011) with minibatches. For </context>
</contexts>
<marker>Socher, Manning, Ng, 2010</marker>
<rawString>R. Socher, C. D. Manning, and A. Y. Ng. 2010. Learning continuous phrase representations and syntactic parsing with recursive neural networks. In Proceedings of the NIPS-2010 Deep Learning and Unsupervised Feature Learning Workshop.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Socher</author>
<author>E H Huang</author>
<author>J Pennington</author>
<author>A Y Ng</author>
<author>C D Manning</author>
</authors>
<title>Dynamic Pooling and Unfolding Recursive Autoencoders for Paraphrase Detection. In NIPS.</title>
<date>2011</date>
<publisher>MIT Press.</publisher>
<contexts>
<context position="4961" citStr="Socher et al., 2011" startWordPosition="753" endWordPosition="756">text free grammars (PCFG) with those of recursive neural networks (RNNs). The former can capture the discrete categorization of phrases into NP or PP while the latter can capture fine-grained syntactic and compositional-semantic information on phrases and words. This information can help in cases where syntactic ambiguity can only be resolved with semantic information, such as in the PP attachment of the two sentences: They ate udon with forks. vs. They ate udon with chicken. Previous RNN-based parsers used the same (tied) weights at all nodes to compute the vector representing a constituent (Socher et al., 2011b). This requires the composition function to be extremely powerful, since it has to combine phrases with different syntactic head words, and it is hard to optimize since the parameters form a very deep neural network. We generalize the fully tied RNN to one with syntactically untied weights. The weights at each node are conditionally dependent on the categories of the child constituents. This allows different composition functions when combining different types of phrases and is shown to result in a large improvement in parsing accuracy. Our compositional distributed representation allows a C</context>
<context position="10079" citStr="Socher et al., 2011" startWordPosition="1552" endWordPosition="1555">2000 sentences. Menchetti et al. (2005) use RNNs to re-rank different parses. For their results on full sentence parsing, they rerank candidate trees created by the Collins parser (Collins, 2003). Similar to their work, we use the idea of letting discrete categories reduce the search space during inference. We compare to fully tied RNNs in which the same weights are used at every node. Our syntactically untied RNNs outperform them by a significant margin. The idea of untying has also been successfully used in deep learning applied to vision (Le et al., 2010). This paper uses several ideas of (Socher et al., 2011b). The main differences are (i) the dual representation of nodes as discrete categories and vectors, (ii) the combination with a PCFG, and (iii) the syntactic untying of weights based on child categories. We directly compare models with fully tied and untied weights. Another work that represents phrases with a dual discrete-continuous representation is (Kartsaklis et al., 2012). 3 Compositional Vector Grammars This section introduces Compositional Vector Grammars (CVGs), a model to jointly find syntactic structure and capture compositional semantic information. CVGs build on two observations.</context>
<context position="14721" citStr="Socher et al., 2011" startWordPosition="2337" endWordPosition="2340"> = X κ1{d E/ N(yi)J. (1) dEN(ˆy) We set κ = 0.1 in all experiments. For a given set of training instances (xi, yi), we search for the function gθ, parameterized by θ, with the smallest expected loss on a new sentence. It has the following form: gθ(x) = arg max s(CVG(θ, x, ˆy)), (2) ˆyEY (x) where the tree is found by the Compositional Vector Grammar (CVG) introduced below and then scored via the function s. The higher the score of a tree the more confident the algorithm is that its structure is correct. This max-margin, structureprediction objective (Taskar et al., 2004; Ratliff et al., 2007; Socher et al., 2011b) trains the CVG so that the highest scoring tree will be the correct tree: gθ(xi) = yi and its score will be larger up to a margin to other possible trees yˆ E Y(xi): s(CVG(θ, xi, yi)) &gt;— s(CVG(θ, xi, ˆy)) + A(yi, ˆy). This leads to the regularized risk function for m training examples: λ ri(θ) + 2 11θ1122, where ri(θ) = max (s(CVG(xi, ˆy)) + A(yi, ˆy)) ˆyEY (xi) − s(CVG(xi, yi)) (3) Intuitively, to minimize this objective, the score of the correct tree yi is increased and the score of the highest scoring incorrect tree yˆ is decreased. 3.3 Scoring Trees with CVGs For ease of exposition, we </context>
<context position="17858" citStr="Socher et al. (2011" startWordPosition="2935" endWordPosition="2938">(1) W(A,P ) = f a p(1) W(B,C) b c Figure 2: An example tree with a simple Recursive Neural Network: The same weight matrix is replicated and used to compute all non-terminal node representations. Leaf nodes are n-dimensional vector representations of words. In order to compute a score of how plausible of a syntactic constituent a parent is the RNN uses a single-unit linear layer for all i: s(p(i)) = vTp(i), where v ∈ Rn is a vector of parameters that need to be trained. This score will be used to find the highest scoring tree. For more details on how standard RNNs can be used for parsing, see Socher et al. (2011b). The standard RNN requires a single composition function to capture all types of compositions: adjectives and nouns, verbs and nouns, adverbs and adjectives, etc. Even though this function is a powerful one, we find a single neural network weight matrix cannot fully capture the richness of compositionality. Several extensions are possible: A two-layered RNN would provide more expressive power, however, it is much harder to train because the resulting neural network becomes very deep and suffers from vanishing gradient problems. Socher et al. (2012) proposed to give every single word a matri</context>
<context position="26258" citStr="Socher et al., 2011" startWordPosition="4427" endWordPosition="4430"> Since we use the diagonal of Gt, we only have to store M values and the update becomes fast to compute: At time step t, the update for the i’th parameter θt,i is: α θt,i = θt−1,i � 2 gt,i. ( 8) �EtT=1 gT,i Hence, the learning rate is adapting differently for each parameter and rare parameters get larger updates than frequently occurring parameters. This is helpful in our setting since some W matrices appear in only a few training trees. This procedure found much better optima (by Pz3% labeled F1 on the dev set), and converged more quickly than L-BFGS which we used previously in RNN training (Socher et al., 2011a). Training time is roughly 4 hours on a single machine. 3.7 Initialization of Weight Matrices In the absence of any knowledge on how to combine two categories, our prior for combining two vectors is to average them instead of performing a completely random projection. Hence, we initialize the binary W matrices with: W(··) = 0.5[I.×.I.×.0.×1] + E, where we include the bias in the last column and the random variable is uniformly distributed: E — U[-0.001, 0.001]. The first block is multiplied by the left child and the second by the right child: ⎤ ⎡ ⎤ a [W(A)W(B)bias] ⎣b ⎦ 1 = W(A)a + W(B)b + b</context>
</contexts>
<marker>Socher, Huang, Pennington, Ng, Manning, 2011</marker>
<rawString>R. Socher, E. H. Huang, J. Pennington, A. Y. Ng, and C. D. Manning. 2011a. Dynamic Pooling and Unfolding Recursive Autoencoders for Paraphrase Detection. In NIPS. MIT Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Socher</author>
<author>C Lin</author>
<author>A Y Ng</author>
<author>C D Manning</author>
</authors>
<title>Parsing Natural Scenes and Natural Language with Recursive Neural Networks.</title>
<date>2011</date>
<booktitle>In ICML.</booktitle>
<contexts>
<context position="4961" citStr="Socher et al., 2011" startWordPosition="753" endWordPosition="756">text free grammars (PCFG) with those of recursive neural networks (RNNs). The former can capture the discrete categorization of phrases into NP or PP while the latter can capture fine-grained syntactic and compositional-semantic information on phrases and words. This information can help in cases where syntactic ambiguity can only be resolved with semantic information, such as in the PP attachment of the two sentences: They ate udon with forks. vs. They ate udon with chicken. Previous RNN-based parsers used the same (tied) weights at all nodes to compute the vector representing a constituent (Socher et al., 2011b). This requires the composition function to be extremely powerful, since it has to combine phrases with different syntactic head words, and it is hard to optimize since the parameters form a very deep neural network. We generalize the fully tied RNN to one with syntactically untied weights. The weights at each node are conditionally dependent on the categories of the child constituents. This allows different composition functions when combining different types of phrases and is shown to result in a large improvement in parsing accuracy. Our compositional distributed representation allows a C</context>
<context position="10079" citStr="Socher et al., 2011" startWordPosition="1552" endWordPosition="1555">2000 sentences. Menchetti et al. (2005) use RNNs to re-rank different parses. For their results on full sentence parsing, they rerank candidate trees created by the Collins parser (Collins, 2003). Similar to their work, we use the idea of letting discrete categories reduce the search space during inference. We compare to fully tied RNNs in which the same weights are used at every node. Our syntactically untied RNNs outperform them by a significant margin. The idea of untying has also been successfully used in deep learning applied to vision (Le et al., 2010). This paper uses several ideas of (Socher et al., 2011b). The main differences are (i) the dual representation of nodes as discrete categories and vectors, (ii) the combination with a PCFG, and (iii) the syntactic untying of weights based on child categories. We directly compare models with fully tied and untied weights. Another work that represents phrases with a dual discrete-continuous representation is (Kartsaklis et al., 2012). 3 Compositional Vector Grammars This section introduces Compositional Vector Grammars (CVGs), a model to jointly find syntactic structure and capture compositional semantic information. CVGs build on two observations.</context>
<context position="14721" citStr="Socher et al., 2011" startWordPosition="2337" endWordPosition="2340"> = X κ1{d E/ N(yi)J. (1) dEN(ˆy) We set κ = 0.1 in all experiments. For a given set of training instances (xi, yi), we search for the function gθ, parameterized by θ, with the smallest expected loss on a new sentence. It has the following form: gθ(x) = arg max s(CVG(θ, x, ˆy)), (2) ˆyEY (x) where the tree is found by the Compositional Vector Grammar (CVG) introduced below and then scored via the function s. The higher the score of a tree the more confident the algorithm is that its structure is correct. This max-margin, structureprediction objective (Taskar et al., 2004; Ratliff et al., 2007; Socher et al., 2011b) trains the CVG so that the highest scoring tree will be the correct tree: gθ(xi) = yi and its score will be larger up to a margin to other possible trees yˆ E Y(xi): s(CVG(θ, xi, yi)) &gt;— s(CVG(θ, xi, ˆy)) + A(yi, ˆy). This leads to the regularized risk function for m training examples: λ ri(θ) + 2 11θ1122, where ri(θ) = max (s(CVG(xi, ˆy)) + A(yi, ˆy)) ˆyEY (xi) − s(CVG(xi, yi)) (3) Intuitively, to minimize this objective, the score of the correct tree yi is increased and the score of the highest scoring incorrect tree yˆ is decreased. 3.3 Scoring Trees with CVGs For ease of exposition, we </context>
<context position="17858" citStr="Socher et al. (2011" startWordPosition="2935" endWordPosition="2938">(1) W(A,P ) = f a p(1) W(B,C) b c Figure 2: An example tree with a simple Recursive Neural Network: The same weight matrix is replicated and used to compute all non-terminal node representations. Leaf nodes are n-dimensional vector representations of words. In order to compute a score of how plausible of a syntactic constituent a parent is the RNN uses a single-unit linear layer for all i: s(p(i)) = vTp(i), where v ∈ Rn is a vector of parameters that need to be trained. This score will be used to find the highest scoring tree. For more details on how standard RNNs can be used for parsing, see Socher et al. (2011b). The standard RNN requires a single composition function to capture all types of compositions: adjectives and nouns, verbs and nouns, adverbs and adjectives, etc. Even though this function is a powerful one, we find a single neural network weight matrix cannot fully capture the richness of compositionality. Several extensions are possible: A two-layered RNN would provide more expressive power, however, it is much harder to train because the resulting neural network becomes very deep and suffers from vanishing gradient problems. Socher et al. (2012) proposed to give every single word a matri</context>
<context position="26258" citStr="Socher et al., 2011" startWordPosition="4427" endWordPosition="4430"> Since we use the diagonal of Gt, we only have to store M values and the update becomes fast to compute: At time step t, the update for the i’th parameter θt,i is: α θt,i = θt−1,i � 2 gt,i. ( 8) �EtT=1 gT,i Hence, the learning rate is adapting differently for each parameter and rare parameters get larger updates than frequently occurring parameters. This is helpful in our setting since some W matrices appear in only a few training trees. This procedure found much better optima (by Pz3% labeled F1 on the dev set), and converged more quickly than L-BFGS which we used previously in RNN training (Socher et al., 2011a). Training time is roughly 4 hours on a single machine. 3.7 Initialization of Weight Matrices In the absence of any knowledge on how to combine two categories, our prior for combining two vectors is to average them instead of performing a completely random projection. Hence, we initialize the binary W matrices with: W(··) = 0.5[I.×.I.×.0.×1] + E, where we include the bias in the last column and the random variable is uniformly distributed: E — U[-0.001, 0.001]. The first block is multiplied by the left child and the second by the right child: ⎤ ⎡ ⎤ a [W(A)W(B)bias] ⎣b ⎦ 1 = W(A)a + W(B)b + b</context>
</contexts>
<marker>Socher, Lin, Ng, Manning, 2011</marker>
<rawString>R. Socher, C. Lin, A. Y. Ng, and C.D. Manning. 2011b. Parsing Natural Scenes and Natural Language with Recursive Neural Networks. In ICML.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Socher</author>
<author>B Huval</author>
<author>C D Manning</author>
<author>A Y Ng</author>
</authors>
<title>Semantic Compositionality Through Recursive Matrix-Vector Spaces.</title>
<date>2012</date>
<booktitle>In EMNLP.</booktitle>
<contexts>
<context position="18415" citStr="Socher et al. (2012)" startWordPosition="3023" endWordPosition="3026"> standard RNNs can be used for parsing, see Socher et al. (2011b). The standard RNN requires a single composition function to capture all types of compositions: adjectives and nouns, verbs and nouns, adverbs and adjectives, etc. Even though this function is a powerful one, we find a single neural network weight matrix cannot fully capture the richness of compositionality. Several extensions are possible: A two-layered RNN would provide more expressive power, however, it is much harder to train because the resulting neural network becomes very deep and suffers from vanishing gradient problems. Socher et al. (2012) proposed to give every single word a matrix and a vector. The matrix is then applied to the sibling node’s vector during the composition. While this results in a powerful composition function that essentially depends on the words being combined, the number of model parameters explodes and the composition functions do not capture the syntactic commonalities between similar POS tags or syntactic categories. Based on the above considerations, we propose the Compositional Vector Grammar (CVG) that conditions the composition function at each node on discrete syntactic categories extracted from a F</context>
</contexts>
<marker>Socher, Huval, Manning, Ng, 2012</marker>
<rawString>R. Socher, B. Huval, C. D. Manning, and A. Y. Ng. 2012. Semantic Compositionality Through Recursive Matrix-Vector Spaces. In EMNLP.</rawString>
</citation>
<citation valid="true">
<authors>
<author>B Taskar</author>
<author>D Klein</author>
<author>M Collins</author>
<author>D Koller</author>
<author>C Manning</author>
</authors>
<title>Max-margin parsing.</title>
<date>2004</date>
<booktitle>In Proceedings of EMNLP,</booktitle>
<pages>1--8</pages>
<contexts>
<context position="2693" citStr="Taskar et al., 2004" startWordPosition="405" endWordPosition="408"> computed via a new type of recursive neural network which is conditioned on syntactic categories from a PCFG. categories, which better capture phrases with similar behavior, whether through manual feature engineering (Klein and Manning, 2003a) or automatic learning (Petrov et al., 2006). However, subdividing a category like NP into 30 or 60 subcategories can only provide a very limited representation of phrase meaning and semantic similarity. Two strands of work therefore attempt to go further. First, recent work in discriminative parsing has shown gains from careful engineering of features (Taskar et al., 2004; Finkel et al., 2008). Features in such parsers can be seen as defining effective dimensions of similarity between categories. Second, lexicalized parsers (Collins, 2003; Charniak, 2000) associate each category with a lexical item. This gives a fine-grained notion of semantic similarity, which is useful for tackling problems like ambiguous attachment decisions. However, this approach necessitates complex shrinkage estimation schemes to deal with the sparsity of observations of the lexicalized categories. In many natural language systems, single words and n-grams are usefully described by thei</context>
<context position="7208" citStr="Taskar et al., 2004" startWordPosition="1098" endWordPosition="1101">Their approach splits categories into several dozen subcategories. Another approach is lexicalized parsers (Collins, 2003; Charniak, 2000) that describe each category with a lexical item, usually the head word. More recently, Hall and Klein (2012) combine several such annotation schemes in a factored parser. We extend the above ideas from discrete representations to richer continuous ones. The CVG can be seen as factoring discrete and continuous parsing in one model. Another different approach to the above generative models is to learn discriminative parsers using many well designed features (Taskar et al., 2004; Finkel et al., 2008). We also borrow ideas from this line of research in that our parser combines the generative PCFG model with discriminatively learned RNNs. Deep Learning and Recursive Deep Learning Early attempts at using neural networks to describe phrases include Elman (1991), who used recurrent neural networks to create representations of sentences from a simple toy grammar and to analyze the linguistic expressiveness of the resulting representations. Words were represented as one-on vectors, which was feasible since the grammar only included a handful of words. Collobert and Weston (</context>
<context position="14678" citStr="Taskar et al., 2004" startWordPosition="2329" endWordPosition="2332"> (or label) in the proposed tree: A(yi, ˆy) = X κ1{d E/ N(yi)J. (1) dEN(ˆy) We set κ = 0.1 in all experiments. For a given set of training instances (xi, yi), we search for the function gθ, parameterized by θ, with the smallest expected loss on a new sentence. It has the following form: gθ(x) = arg max s(CVG(θ, x, ˆy)), (2) ˆyEY (x) where the tree is found by the Compositional Vector Grammar (CVG) introduced below and then scored via the function s. The higher the score of a tree the more confident the algorithm is that its structure is correct. This max-margin, structureprediction objective (Taskar et al., 2004; Ratliff et al., 2007; Socher et al., 2011b) trains the CVG so that the highest scoring tree will be the correct tree: gθ(xi) = yi and its score will be larger up to a margin to other possible trees yˆ E Y(xi): s(CVG(θ, xi, yi)) &gt;— s(CVG(θ, xi, ˆy)) + A(yi, ˆy). This leads to the regularized risk function for m training examples: λ ri(θ) + 2 11θ1122, where ri(θ) = max (s(CVG(xi, ˆy)) + A(yi, ˆy)) ˆyEY (xi) − s(CVG(xi, yi)) (3) Intuitively, to minimize this objective, the score of the correct tree yi is increased and the score of the highest scoring incorrect tree yˆ is decreased. 3.3 Scoring </context>
</contexts>
<marker>Taskar, Klein, Collins, Koller, Manning, 2004</marker>
<rawString>B. Taskar, D. Klein, M. Collins, D. Koller, and C. Manning. 2004. Max-margin parsing. In Proceedings of EMNLP, pages 1–8.</rawString>
</citation>
<citation valid="true">
<authors>
<author>I Titov</author>
<author>J Henderson</author>
</authors>
<title>Porting statistical parsers with data-defined kernels.</title>
<date>2006</date>
<booktitle>In CoNLL-X.</booktitle>
<contexts>
<context position="9133" citStr="Titov and Henderson, 2006" startWordPosition="1392" endWordPosition="1395">ge scale parsing. He introduced a left-corner parser to estimate the probabilities of parsing decisions conditioned on the parsing history. The input to Henderson’s model consists of pairs of frequent words and their part-of-speech (POS) tags. Both the original parsing system and its probabilistic interpretation (Titov and Henderson, 2007) learn features that represent the parsing history and do not provide a principled linguistic representation like our phrase representations. Other related work includes (Henderson, 2004), who discriminatively trains a parser based on synchrony networks and (Titov and Henderson, 2006), who use an SVM to adapt a generative parser to different domains. Costa et al. (2003) apply recursive neural networks to re-rank possible phrase attachments in an incremental parser. Their work is the first to show that RNNs can capture enough information to make correct parsing decisions, but they only test on a subset of 2000 sentences. Menchetti et al. (2005) use RNNs to re-rank different parses. For their results on full sentence parsing, they rerank candidate trees created by the Collins parser (Collins, 2003). Similar to their work, we use the idea of letting discrete categories reduce</context>
</contexts>
<marker>Titov, Henderson, 2006</marker>
<rawString>I. Titov and J. Henderson. 2006. Porting statistical parsers with data-defined kernels. In CoNLL-X.</rawString>
</citation>
<citation valid="true">
<authors>
<author>I Titov</author>
<author>J Henderson</author>
</authors>
<title>Constituent parsing with incremental sigmoid belief networks.</title>
<date>2007</date>
<booktitle>In ACL.</booktitle>
<contexts>
<context position="8848" citStr="Titov and Henderson, 2007" startWordPosition="1351" endWordPosition="1354">ller and K¨uchler (1996) to learn distributed representations of given, structured objects such as logical terms. In contrast, our model both predicts the structure and its representation. 456 Henderson (2003) was the first to show that neural networks can be successfully used for large scale parsing. He introduced a left-corner parser to estimate the probabilities of parsing decisions conditioned on the parsing history. The input to Henderson’s model consists of pairs of frequent words and their part-of-speech (POS) tags. Both the original parsing system and its probabilistic interpretation (Titov and Henderson, 2007) learn features that represent the parsing history and do not provide a principled linguistic representation like our phrase representations. Other related work includes (Henderson, 2004), who discriminatively trains a parser based on synchrony networks and (Titov and Henderson, 2006), who use an SVM to adapt a generative parser to different domains. Costa et al. (2003) apply recursive neural networks to re-rank possible phrase attachments in an incremental parser. Their work is the first to show that RNNs can capture enough information to make correct parsing decisions, but they only test on </context>
</contexts>
<marker>Titov, Henderson, 2007</marker>
<rawString>I. Titov and J. Henderson. 2007. Constituent parsing with incremental sigmoid belief networks. In ACL.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Turian</author>
<author>L Ratinov</author>
<author>Y Bengio</author>
</authors>
<title>Word representations: a simple and general method for semisupervised learning.</title>
<date>2010</date>
<booktitle>In Proceedings of ACL,</booktitle>
<pages>384--394</pages>
<contexts>
<context position="12730" citStr="Turian et al., 2010" startWordPosition="1966" endWordPosition="1969">such as king−man+woman ≈ queen (Mikolov et al., 2013). Collobert and Weston (2008) introduced a new model to compute such an embedding. The idea is to construct a neural network that outputs high scores for windows that occur in a large unlabeled corpus and low scores for windows where one word is replaced by a random word. When such a network is optimized via gradient ascent the derivatives backpropagate into the word embedding matrix X. In order to predict correct scores the vectors in the matrix capture co-occurrence statistics. For further details and evaluations of these embeddings, see (Turian et al., 2010; Huang et al., 2012). The resulting X matrix is used as follows. Assume we are given a sentence as an ordered list of m words. Each word w has an index [w] = i into the columns of the embedding matrix. This index is used to retrieve the word’s vector representation a,,, using a simple multiplication with a binary vector e, which is zero everywhere, except 457 at the ith index. So aw = Lei E Rn. Henceforth, after mapping each word to its vector, we represent a sentence S as an ordered list of (word,vector) pairs: x = ((w1, aw1), ... , (wm, awm)). Now that we have discrete and continuous repres</context>
<context position="28758" citStr="Turian et al. (2010)" startWordPosition="4857" endWordPosition="4860">tates, a base PCFG with fewer states is much faster. Testing on the full WSJ section 22 dev set (1700 sentences) takes roughly 470 seconds with the simple base PCFG, 1320 seconds with our new CVG and 1600 seconds with the currently published Stanford factored parser. Hence, increased performance comes also with a speed improvement of approximately 20%. We fix the same regularization of λ = 10−4 for all parameters. The minibatch size was set to 20. We also cross-validated on AdaGrad’s learning rate which was eventually set to α = 0.1 and word vector size. The 25-dimensional vectors provided by Turian et al. (2010) provided the best ∂J ∂s (xi, ˆymax) ∂θ ∂θ Y_ ⎡ W(AB) ⎣ a b 1 461 Parser dev (all) test≤ 40 test (all) Stanford PCFG 85.8 86.2 85.5 Stanford Factored 87.4 87.2 86.6 Factored PCFGs 89.7 90.1 89.4 Collins 87.7 SSN (Henderson) 89.4 Berkeley Parser 90.1 CVG (RNN) 85.7 85.1 85.0 CVG (SU-RNN) 91.2 91.1 90.4 Charniak-SelfTrain 91.0 Charniak-RS 92.1 Table 1: Comparison of parsers with richer state representations on the WSJ. The last line is the self-trained re-ranked Charniak parser. performance and were faster than 50-,100- or 200- dimensional ones. We hypothesize that the larger word vector sizes, </context>
</contexts>
<marker>Turian, Ratinov, Bengio, 2010</marker>
<rawString>J. Turian, L. Ratinov, and Y. Bengio. 2010. Word representations: a simple and general method for semisupervised learning. In Proceedings of ACL, pages 384–394.</rawString>
</citation>
<citation valid="true">
<authors>
<author>P D Turney</author>
<author>P Pantel</author>
</authors>
<title>From frequency to meaning: Vector space models of semantics.</title>
<date>2010</date>
<journal>Journal of Artificial Intelligence Research,</journal>
<pages>37--141</pages>
<contexts>
<context position="11744" citStr="Turney and Pantel, 2010" startWordPosition="1801" endWordPosition="1804">l semantic vector representations for longer phrases (Costa et al., 2003; Menchetti et al., 2005; Socher et al., 2011b). The CVG model merges ideas from both generative models that assume discrete syntactic categories and discriminative models that are trained using continuous vectors. We will first briefly introduce single word vector representations and then describe the CVG objective function, tree scoring and inference. 3.1 Word Vector Representations In most systems that use a vector representation for words, such vectors are based on cooccurrence statistics of each word and its context (Turney and Pantel, 2010). Another line of research to learn distributional word vectors is based on neural language models (Bengio et al., 2003) which jointly learn an embedding of words into an n-dimensional feature space and use these embeddings to predict how suitable a word is in its context. These vector representations capture interesting linear relationships (up to some accuracy), such as king−man+woman ≈ queen (Mikolov et al., 2013). Collobert and Weston (2008) introduced a new model to compute such an embedding. The idea is to construct a neural network that outputs high scores for windows that occur in a la</context>
</contexts>
<marker>Turney, Pantel, 2010</marker>
<rawString>P. D. Turney and P. Pantel. 2010. From frequency to meaning: Vector space models of semantics. Journal of Artificial Intelligence Research, 37:141–188.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>