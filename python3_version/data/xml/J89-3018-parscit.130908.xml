<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000167">
<sectionHeader confidence="0.802328" genericHeader="abstract">
ABSTRACTS OF CURRENT LITERATURE
</sectionHeader>
<bodyText confidence="0.766251">
The following research reports are available on request from:
</bodyText>
<affiliation confidence="0.879239333333333">
Advanced Computational Methods Center
Computer Services Annex Building
University of Georgia
</affiliation>
<address confidence="0.69742">
Athens, Georgia 30602
</address>
<figure confidence="0.9425983125">
NEW REPORTS AND MEMOS
01-0004
A Programming Solution to Certain
Problems with Loops in Prolog
Nute, D.
01-0006
A Further Note on Looping in Prolog
Covington, M.
01-0007
A Non-Monotonic Logic Based on
Conditional Logic
Nute, D.
01-0009
Could Non-monotonic Inference Ever
Be Deductively Valid?
Rankin, T.
</figure>
<bodyText confidence="0.98663655">
Representing transitive relations in the obvious way in Prolog
results in unwanted loops. A programming solution to this
problem is provided and limitations and possible extension of
this solution to other looping problems is discussed. (Bound
with 01-0001 and 01-0006.)
In an earlier paper (01-0001) I proposed that looping in Prolog
should be prevented by blocking all derivations in which the
current goal matches a higher goal. This is too strong a
constraint; it causes exhaustive searches to be incomplete. A
better approach is to block all derivations in which the current
goal matches a higher goal and is about to be evaluated using
the same rule as was used to evaluate the higher goal. This is
sufficient to block looping, and produce otherwise correct
behavior, in all of the cases mentioned in the earlier paper.
(Bound with 01-0001 and 01-0004.)
A reasoning system is monotonic just in case it has the
following property: whenever it infers a conclusion C from a
set of assumptions S, it will also infer C from any larger set of
assumptions containing S. Many Al researchers have stressed
the need for non-monotonic reasoning systems, systems that can
draw good conclusions from incomplete information and revise
them as more information becomes available. Human beings
often use defeasible rules in such reasoning. I will develop a
system of formal logic for sentential versions of defeasible rules
and compare this logic to other formal systems proposed as a
foundation for non-monotonic reasoning. I will also discuss
briefly a PROLOG program within which this logic is
implemented.
Recent advances in Artificial Intelligence (AI) meant to provide
formal systems of non-monotonic inference have apparently
prompted some linguists, logicians, and philosophers to take
seriously the notion of &amp;quot;nonmonotonic validity.&amp;quot; Arguments
presented here reveal this approach as a mistake that will only
lead to a drastically weakened conception of deductive validity
that appears to be inherently inconsistent. If so, it cannot be an
adequate program or framework for achieving the characteristic
goal of deduction (i.e., truth preservation), but it can be seen
as an indispensable feature of any program or framework in
which the characteristic goal of induction (i.e., knowledge
extension) could be achieved.
</bodyText>
<page confidence="0.989596">
214 Computational Linguistics, Volume 15, Number 3, September 1989
</page>
<figure confidence="0.983001631578947">
Abstracts of Current Literature
01-0011A
Evaluations of Expert System
Development Tools
Lewis, M.
01-0013
LDR: A Logic for Defeasible
Reasoning
Nute, D.
01-0014
The Automation of a Practical
Reasoning System Based on Concepts
in Deontic Logic
Lewis, M.
01-0022
Parsing Variable Word Order
Languages With Unification-Based
Dependency Grammar
Covington, M.
</figure>
<page confidence="0.320497">
01-0023
</page>
<bodyText confidence="0.981824890909091">
An Implementation of Discourse
Representation Theory
Covington, M. and Schmitz, N.
This document contains reports that describe and evaluate
expert system development tools. Its purpose is twofold: 1. to
advise and assist potential expert system builders, and 2. to
prepare the way for the construction of new expert system
development tools at ACMC. The reports herein are not
intended to substitute for the reference manuals, although the
reader should find them informative and helpful. Ideally, the
reports are useful as a basis for selecting the most suitable tool
prior to consulting the appropriate manual.
Our reasoning often leads to conclusions that we would reject if
we had additional information. We need a general account of
this &amp;quot;defeasible&amp;quot; reasoning. Several accounts found in the
literature give intuitively incorrect answers when applied to
examples of correct defeasible reasoning in ordinary
circumstances. An account that avoids these problems is
developed in the form of a formal system of sentential logic
and an accompanying epistemic semantics. Called LDR, this
logic is implemented in Prolog.
In this report I examine three systems of deontic logic (the
logic of &amp;quot;ought&amp;quot;), and based two automated practical reasoning
systems on them. The first one is implemented in Prolog. It is
a second order reasoning system that involves quantification
over act properties (or norms) and act individuals. The second
one is implemented in d-Prolog, and is a propositional reasoning
system that appeals to general defeasible rules of thumb.
Defeasibility of practical conclusions is a feature of both
systems.
This paper presents a formal description of one case of
implicature (Pelletier&apos;s analysis of &amp;quot;or&amp;quot;) using LDR1, a non-
monotonic logic that was originally developed to encode
generalizations that have exceptions.
GULP 1.1 is a syntactic extension of Prolog similar in purpose
and function to PATR-II (Shieber 1986) and PrAtt (Johnson and
Klein 1986). It provides a convenient notation for feature
structures in which features are identified by keyword rather
than by position. The present version of GULP runs under the
Arity Prolog Interpreter version 4.0.
This paper presents a formalism and an n3-time parsing
algorithm for unification-based dependency grammars. Unlike
phrase structure grammars, a dependency grammar does not
divide the sentence up into substrings (constituents); instead, it
identifies the grammatical relations that connect one word to
another. This is advantageous in languages where the order of
words is variable and many of the constituents are
discontinuous. The algorithm presented here has been used
successfully to parse Russian and Latin sentences.
This paper documents a computer program that constructs
discourse representation structures (DRSes) from ordinary
English input. A source listing of the program is included. This
program is a much extended version of the one developed by
Johnson and Klein (1986) and was built to serve as a basis for
other research. It is implemented in Prolog using GULP, a
</bodyText>
<table confidence="0.824854212121212">
01-0015
Implicature, Disjunction, and Non-
monotonic Logic
Nute, D. and Covington, M.
01-0021
GULP 1.1: An Extension of Prolog for
Unification-Based Grammar
Covington, M.
Computational Linguistics, Volume 15, Number 3, September 1989 215
Abstracts of Current Literature
01-0024 locally developed system for translating feature structure
From English to Prolog via Discourse notation into Prolog terms. The reader of this paper is expected
Representation Theory to be familiar with discourse representation theory, Prolog, and
Covington, M.; Nute, D.; Schmitz, N.; and GULP.
Goodman, D. This is a preliminary report on a set of techniques for
translating the discourse representation structures (DRSes) of
Kamp (1981) into semantically equivalent clauses in a slightly
extended form of Prolog. Together with discourse representation
theory (DRT) itself, these techniques yield a system for
translating English into Prolog. A working prototype has been
built using Quintus Prolog on a VAX workstation.
01-0025 READ.PRO is a Prolog program that simulates a theory of
READ.PRO: A Pattern Matching perceptual learning in reading. The theory employs pattern
Approach to Perceptual Learning in matching (unification) as a recognition mechanism. The primary
Reading determinant of learning is the frequency with which letter
McEneaney, J. strings are encountered in the text. A source listing is included.
01-0026
Parsing German with GPSG: The
Problem of Separable Prefix Verbs
Volk, M.
01-0027
A Comparative Performance Study on
Various Parsers Written in Prolog
</table>
<tableCaption confidence="0.358662">
Chou, T.
</tableCaption>
<bodyText confidence="0.999358666666666">
This paper discusses parsing with GPSG (generalized phrase
structure grammar) in general, then examines the problem of
separable prefix verbs in German. Verb and prefix can be
separated dependent on the type of sentence and the form of
the verb. An implementation of a parser (in Prolog) that
handles these verbs will demonstrate the suitability of GPSG for
this problem.
This paper compares the actual performance of several types of
top-down and bottom-up parsers on subsets of English with a
variety of crucial properties. Timings are given for Arity Prolog,
ALS Prolog, and Quintus Prolog.
The following new papers from the project group KIT can be obtained free of charge from:
</bodyText>
<figure confidence="0.965424818181818">
PROJEKTGRUPPE KIT
Technische Universitat Berlin
Fachbereich Informatik
Sekr. FR5-12
Franklinstr. 28/29
D-1000 Berlin 10
Fed. Rep. of Germany
ciskit%dbOtuill.bitnet@cunyvm.cuny.edu
KIT-Report 63
GROW: Graphik-orientierte
Wissenpraesentation fuer KL-ONE
</figure>
<figureCaption confidence="0.951316">
Kindermann, C. and Quantz, J.
June 1988, 85 pp.
</figureCaption>
<bodyText confidence="0.999984733333333">
The topic of this paper is the graphics-oriented presentation of
knowledge for KL-ONE. A knowledge representation system
can be decomposed into an interaction component and an appli-
cation component, so we therefore distinguish between
presentation and representation of knowledge. Beginning with a
modeling scenario and a study of existing user interfaces for
KL-ONE systems and general demands on graphic user
interfaces, we discuss problems concerning the presentation KL-
ONE and propose solutions. The incremental modeling of a
domain, the inspection of the represented knowledge, the
navigation through large nets, and the visualization of structural
changes as a result of classification or deletion can be
supported by graphics-oriented techniques. Since the design of a
presentational component leads to new demands on the
representational component, we give a brief specification of
</bodyText>
<page confidence="0.974095">
216 Computational Linguistics, Volume 15, Number 3, September 1989
</page>
<subsectionHeader confidence="0.940971">
Abstracts of Current Literature
</subsectionHeader>
<bodyText confidence="0.999506333333333">
these demands. Some of the proposed solutions have been
implemented in a prototype of a user interface for the BACK
System at the TU Berlin.
</bodyText>
<table confidence="0.9813993125">
KIT-Report 66
Incremental and Reversible Acquisition
of Taxonomies
Kietz, J.
October 1988, 11 pp.
To appear in: J. Boose, B. Gaines, M.
Linster (eds.): Proceedings of the
European Knowledge Acquisition
Workshop (EKAW&apos;88), GMD-Studien Nr.
143, GMD, Sankt Augustin, 1988
KIT-Report 68
Wortorientiertes Parsen
Eimermacher, M.
November 1988, 312 pp.
Ph.D. thesis, Computer Science
Department, Technical University Berlin,
</table>
<page confidence="0.522874">
1988
</page>
<bodyText confidence="0.988283555555556">
One of the prerequisites for building up a domain model is the
specification of a description language. For a logic-oriented
representation, domain-specific predicates have to be declared
along with their admissible arguments. If a many sorted logic is
used for representing the domain model, the sorts of the
arguments, the compatibility of the sorts, and the mapping of
terms to sorts have to be declared, as well. This specification
can be viewed as a knowledge acquisition task itself. In this
paper, an implemented approach to the automatic acquisition of
a sort taxonomy is presented. The sort taxonomy, as well as
the sorts of the predicates arguments are constructed
automatically on the basis of facts inputted by the user. The
sort taxonomy is used to specify the well-sorted expressions in
a many sorted logic, i.e., to specify the logic description
language for a particular domain model.
Conventional grammars are restricted to the competence of
language. They describe which syntactical structures are correct,
but not how they can be generated. Therefore, the Parser has
to search through a large space of syntactical rules. In order to
obtain an adequate left-right parsing without superfluous
backtracking, knowledge of cross-relations between individual
words and different readings is required, i.e., a word-oriented
grammar (object-oriented knowledge representation). Rieger/
Small&apos;s Word-Expert System did have one &amp;quot;Expert&amp;quot; for each
word, but there was no grammar to define general rules (about
those Experts). Therefore, lexical transformation rules are
introduced, which reconcile two (up until now) seemingly
opposing goals: On the one hand, these WAXPs (Word-Class
Experts, German: Wortartexperten) are general rules, so they
may be investigated linguistically. On the other hand, they
generate WXPs (Words Experts) which can exploit the relations
between single words. So WXPs are no longer stored in a
dictionary; instead they are generated for the current input &amp;quot;on
demand.&amp;quot; Therefore, linguistic knowledge is modularized:
vertically by lattices for semantic sorts and word classes. On
this basis, syntax and semantics can be integrated horizontally
by individual experts for the morpheme, word, and sentence
level (quasi-parallel evaluation). The evaluation is supported by
powerful representation structures (augmented binary chart, a
stack &amp;quot;Expectations of Context,&amp;quot; different lattices). As well as
the basic idea of a word-oriented parse system, the thesis deals
with complex grammatical problems, e.g., bracketed infinitives
and extrapositions. Within the word-oriented grammar, modifiers
are treated separately from the WAXPs by &amp;quot;filters,&amp;quot; so that no
&amp;quot;normal&amp;quot; rule (WAXP) has to take account of these
exceptions. Moreover, sentence structures are introduced
concerning meta-grammatical phenomena (wrong input and
elliptical conjunctions). Since WAXPs already contain the kernel
of the grammar, the sentence level can be represented by
means of flat (and efficient) sentence frames. The word-oriented
procedure allows for a wide range of parse strategies. They are
compiled into a hierarchical master strategy, which makes it
largely possible to avoid backtracking.
Computational Linguistics, Volume 15, Number 3, September 1989 217
</bodyText>
<subsectionHeader confidence="0.280724">
Abstracts of Current Literature
</subsectionHeader>
<bodyText confidence="0.668556666666667">
KIT-Report 69 A representation of time and specialized temporal reasoning
Temporal Constraint Networks mechanisms can greatly enhance the capabilities of hybrid
Schmiedel, A. knowledge representation formalisms such as the BACK system.
November 1988, 30 pp. Time lends itself to a special purpose treatment because of its
uniform structure across all kinds of domains. After discussing
various classes of conceivable constraint types, simple order
constraints, bounded differences, and Allen&apos;s interval relations
are considered in more detail, and a uniform algorithmic
approach is presented. While complete polynomial time
algorithms for simple order constraints and bounded differences
exist, ensuring consistency for networks based on Allen&apos;s
interval relations is intractable.
</bodyText>
<page confidence="0.923309">
218 Computational Linguistics, Volume 15, Number 3, September 1989
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.000000">
<title confidence="0.890439">ABSTRACTS OF CURRENT LITERATURE</title>
<author confidence="0.422716">The following research reports are available on request from</author>
<affiliation confidence="0.922694666666667">Advanced Computational Methods Center Computer Services Annex Building University of Georgia</affiliation>
<address confidence="0.99436">Athens, Georgia 30602</address>
<affiliation confidence="0.513283">NEW REPORTS AND MEMOS</affiliation>
<address confidence="0.255217">01-0004</address>
<note confidence="0.278746266666667">A Programming Solution to Certain Problems with Loops in Prolog Nute, D. 01-0006 A Further Note on Looping in Prolog Covington, M. 01-0007 A Non-Monotonic Logic Based on Conditional Logic Nute, D. 01-0009 Could Non-monotonic Inference Ever Be Deductively Valid? Rankin, T. Representing transitive relations in the obvious way in Prolog</note>
<abstract confidence="0.996014974358974">results in unwanted loops. A programming solution to this problem is provided and limitations and possible extension of this solution to other looping problems is discussed. (Bound with 01-0001 and 01-0006.) an earlier paper (01-0001) that looping in Prolog should be prevented by blocking all derivations in which the current goal matches a higher goal. This is too strong a constraint; it causes exhaustive searches to be incomplete. A better approach is to block all derivations in which the current goal matches a higher goal and is about to be evaluated using the same rule as was used to evaluate the higher goal. This is sufficient to block looping, and produce otherwise correct behavior, in all of the cases mentioned in the earlier paper. (Bound with 01-0001 and 01-0004.) A reasoning system is monotonic just in case it has the following property: whenever it infers a conclusion C from a set of assumptions S, it will also infer C from any larger set of assumptions containing S. Many Al researchers have stressed the need for non-monotonic reasoning systems, systems that can draw good conclusions from incomplete information and revise them as more information becomes available. Human beings often use defeasible rules in such reasoning. I will develop a system of formal logic for sentential versions of defeasible rules and compare this logic to other formal systems proposed as a foundation for non-monotonic reasoning. I will also discuss briefly a PROLOG program within which this logic is implemented. Recent advances in Artificial Intelligence (AI) meant to provide formal systems of non-monotonic inference have apparently prompted some linguists, logicians, and philosophers to take seriously the notion of &amp;quot;nonmonotonic validity.&amp;quot; Arguments presented here reveal this approach as a mistake that will only lead to a drastically weakened conception of deductive validity that appears to be inherently inconsistent. If so, it cannot be an adequate program or framework for achieving the characteristic goal of deduction (i.e., truth preservation), but it can be seen as an indispensable feature of any program or framework in which the characteristic goal of induction (i.e., knowledge extension) could be achieved.</abstract>
<date confidence="0.359744">214 Computational Linguistics, Volume 15, Number 3, September 1989</date>
<title confidence="0.573006">Abstracts of Current Literature 01-0011A Evaluations of Expert System Development Tools</title>
<author confidence="0.485604">M Lewis</author>
<pubnum confidence="0.427454">01-0013</pubnum>
<title confidence="0.961592">LDR: A Logic for Defeasible Reasoning</title>
<author confidence="0.316692">D Nute</author>
<pubnum confidence="0.481683">01-0014</pubnum>
<title confidence="0.953092333333333">The Automation of a Practical Reasoning System Based on Concepts in Deontic Logic</title>
<author confidence="0.534072">M Lewis</author>
<pubnum confidence="0.640172">01-0022</pubnum>
<title confidence="0.955041">Parsing Variable Word Order</title>
<author confidence="0.340765">Languages With Unification-Based</author>
<affiliation confidence="0.49167">Dependency Grammar</affiliation>
<address confidence="0.727">Covington, M.</address>
<pubnum confidence="0.406417">01-0023</pubnum>
<title confidence="0.810757">An Implementation of Discourse Representation Theory</title>
<address confidence="0.55665">Covington, M. and Schmitz, N.</address>
<abstract confidence="0.955887763636364">This document contains reports that describe and evaluate expert system development tools. Its purpose is twofold: 1. to advise and assist potential expert system builders, and 2. to prepare the way for the construction of new expert system development tools at ACMC. The reports herein are not intended to substitute for the reference manuals, although the reader should find them informative and helpful. Ideally, the reports are useful as a basis for selecting the most suitable tool prior to consulting the appropriate manual. Our reasoning often leads to conclusions that we would reject if we had additional information. We need a general account of this &amp;quot;defeasible&amp;quot; reasoning. Several accounts found in the literature give intuitively incorrect answers when applied to examples of correct defeasible reasoning in ordinary circumstances. An account that avoids these problems is developed in the form of a formal system of sentential logic and an accompanying epistemic semantics. Called LDR, this logic is implemented in Prolog. In this report I examine three systems of deontic logic (the logic of &amp;quot;ought&amp;quot;), and based two automated practical reasoning systems on them. The first one is implemented in Prolog. It is a second order reasoning system that involves quantification over act properties (or norms) and act individuals. The second one is implemented in d-Prolog, and is a propositional reasoning system that appeals to general defeasible rules of thumb. Defeasibility of practical conclusions is a feature of both systems. This paper presents a formal description of one case of implicature (Pelletier&apos;s analysis of &amp;quot;or&amp;quot;) using LDR1, a nonmonotonic logic that was originally developed to encode generalizations that have exceptions. GULP 1.1 is a syntactic extension of Prolog similar in purpose and function to PATR-II (Shieber 1986) and PrAtt (Johnson and Klein 1986). It provides a convenient notation for feature structures in which features are identified by keyword rather than by position. The present version of GULP runs under the Arity Prolog Interpreter version 4.0. paper presents a formalism and an parsing algorithm for unification-based dependency grammars. Unlike phrase structure grammars, a dependency grammar does not divide the sentence up into substrings (constituents); instead, it identifies the grammatical relations that connect one word to another. This is advantageous in languages where the order of words is variable and many of the constituents are discontinuous. The algorithm presented here has been used successfully to parse Russian and Latin sentences. This paper documents a computer program that constructs discourse representation structures (DRSes) from ordinary English input. A source listing of the program is included. This program is a much extended version of the one developed by Johnson and Klein (1986) and was built to serve as a basis for other research. It is implemented in Prolog using GULP, a 01-0015 Implicature, Disjunction, and Nonmonotonic Logic</abstract>
<note confidence="0.825200833333333">Nute, D. and Covington, M. 01-0021 GULP 1.1: An Extension of Prolog for Unification-Based Grammar Covington, M. Computational Linguistics, Volume 15, Number 3, September 1989 215</note>
<abstract confidence="0.977989">Abstracts of Current Literature 01-0024 locally developed system for translating feature structure From English to Prolog via Discourse Representation Theory notation into Prolog terms. The reader of this paper is expected to be familiar with discourse representation theory, Prolog, and GULP. Covington, M.; Nute, D.; Schmitz, N.; and Goodman, D. This is a preliminary report on a set of techniques for translating the discourse representation structures (DRSes) of Kamp (1981) into semantically equivalent clauses in a slightly extended form of Prolog. Together with discourse representation theory (DRT) itself, these techniques yield a system for translating English into Prolog. A working prototype has been built using Quintus Prolog on a VAX workstation. is a Prolog program that simulates a theory of A Pattern Matching learning in reading. The theory employs pattern to Perceptual Learning in (unification) as a recognition mechanism. The primary of learning is the frequency with which letter J. are encountered in the text. A source listing is included.</abstract>
<pubnum confidence="0.558542">01-0026</pubnum>
<title confidence="0.755917">Parsing German with GPSG: The Problem of Separable Prefix Verbs</title>
<author confidence="0.57571">M Volk</author>
<pubnum confidence="0.38854">01-0027</pubnum>
<title confidence="0.7238155">A Comparative Performance Study on Various Parsers Written in Prolog</title>
<abstract confidence="0.867350769230769">Chou, T. This paper discusses parsing with GPSG (generalized phrase structure grammar) in general, then examines the problem of separable prefix verbs in German. Verb and prefix can be separated dependent on the type of sentence and the form of the verb. An implementation of a parser (in Prolog) that handles these verbs will demonstrate the suitability of GPSG for this problem. This paper compares the actual performance of several types of top-down and bottom-up parsers on subsets of English with a variety of crucial properties. Timings are given for Arity Prolog, ALS Prolog, and Quintus Prolog. The following new papers from the project group KIT can be obtained free of charge from:</abstract>
<affiliation confidence="0.834717333333333">PROJEKTGRUPPE KIT Technische Universitat Berlin Fachbereich Informatik</affiliation>
<address confidence="0.963452666666667">Sekr. FR5-12 Franklinstr. 28/29 D-1000 Berlin 10</address>
<author confidence="0.673482">Rep of Germany</author>
<email confidence="0.996166">ciskit%dbOtuill.bitnet@cunyvm.cuny.edu</email>
<abstract confidence="0.8191212">KIT-Report 63 GROW: Graphik-orientierte Wissenpraesentation fuer KL-ONE Kindermann, C. and Quantz, J. June 1988, 85 pp. The topic of this paper is the graphics-oriented presentation of knowledge for KL-ONE. A knowledge representation system can be decomposed into an interaction component and an application component, so we therefore distinguish between presentation and representation of knowledge. Beginning with a modeling scenario and a study of existing user interfaces for KL-ONE systems and general demands on graphic user interfaces, we discuss problems concerning the presentation KL- ONE and propose solutions. The incremental modeling of a domain, the inspection of the represented knowledge, the navigation through large nets, and the visualization of structural changes as a result of classification or deletion can be supported by graphics-oriented techniques. Since the design of a presentational component leads to new demands on the representational component, we give a brief specification of 216 Computational Linguistics, Volume 15, Number 3, September 1989 Abstracts of Current Literature these demands. Some of the proposed solutions have been implemented in a prototype of a user interface for the BACK System at the TU Berlin. KIT-Report 66 Incremental and Reversible Acquisition of Taxonomies Kietz, J. October 1988, 11 pp.</abstract>
<note confidence="0.7916145">To appear in: J. Boose, B. Gaines, M. Linster (eds.): Proceedings of the European Knowledge Acquisition Workshop (EKAW&apos;88), GMD-Studien Nr. 143, GMD, Sankt Augustin, 1988 KIT-Report 68 Wortorientiertes Parsen Eimermacher, M. November 1988, 312 pp. Ph.D. thesis, Computer Science</note>
<affiliation confidence="0.992828">Department, Technical University Berlin,</affiliation>
<date confidence="0.61817">1988</date>
<abstract confidence="0.999657056603773">One of the prerequisites for building up a domain model is the specification of a description language. For a logic-oriented representation, domain-specific predicates have to be declared along with their admissible arguments. If a many sorted logic is used for representing the domain model, the sorts of the arguments, the compatibility of the sorts, and the mapping of terms to sorts have to be declared, as well. This specification can be viewed as a knowledge acquisition task itself. In this paper, an implemented approach to the automatic acquisition of a sort taxonomy is presented. The sort taxonomy, as well as the sorts of the predicates arguments are constructed automatically on the basis of facts inputted by the user. The sort taxonomy is used to specify the well-sorted expressions in a many sorted logic, i.e., to specify the logic description language for a particular domain model. Conventional grammars are restricted to the competence of language. They describe which syntactical structures are correct, but not how they can be generated. Therefore, the Parser has to search through a large space of syntactical rules. In order to obtain an adequate left-right parsing without superfluous backtracking, knowledge of cross-relations between individual words and different readings is required, i.e., a word-oriented grammar (object-oriented knowledge representation). Rieger/ Small&apos;s Word-Expert System did have one &amp;quot;Expert&amp;quot; for each word, but there was no grammar to define general rules (about those Experts). Therefore, lexical transformation rules are introduced, which reconcile two (up until now) seemingly opposing goals: On the one hand, these WAXPs (Word-Class Experts, German: Wortartexperten) are general rules, so they may be investigated linguistically. On the other hand, they generate WXPs (Words Experts) which can exploit the relations between single words. So WXPs are no longer stored in a dictionary; instead they are generated for the current input &amp;quot;on demand.&amp;quot; Therefore, linguistic knowledge is modularized: vertically by lattices for semantic sorts and word classes. On this basis, syntax and semantics can be integrated horizontally by individual experts for the morpheme, word, and sentence level (quasi-parallel evaluation). The evaluation is supported by powerful representation structures (augmented binary chart, a stack &amp;quot;Expectations of Context,&amp;quot; different lattices). As well as the basic idea of a word-oriented parse system, the thesis deals with complex grammatical problems, e.g., bracketed infinitives and extrapositions. Within the word-oriented grammar, modifiers are treated separately from the WAXPs by &amp;quot;filters,&amp;quot; so that no &amp;quot;normal&amp;quot; rule (WAXP) has to take account of these exceptions. Moreover, sentence structures are introduced concerning meta-grammatical phenomena (wrong input and elliptical conjunctions). Since WAXPs already contain the kernel of the grammar, the sentence level can be represented by means of flat (and efficient) sentence frames. The word-oriented procedure allows for a wide range of parse strategies. They are compiled into a hierarchical master strategy, which makes it largely possible to avoid backtracking.</abstract>
<note confidence="0.527098166666667">Computational Linguistics, Volume 15, Number 3, September 1989 217 Abstracts of Current Literature KIT-Report 69 of time and specialized temporal reasoning mechanisms can greatly enhance the capabilities of hybrid knowledge representation formalisms such as the BACK system. Time lends itself to a special purpose treatment because of its uniform structure across all kinds of domains. After discussing various classes of conceivable constraint types, simple order constraints, bounded differences, and Allen&apos;s interval relations are considered in more detail, and a uniform algorithmic approach is presented. While complete polynomial time algorithms for simple order constraints and bounded differences exist, ensuring consistency for networks based on Allen&apos;s interval relations is intractable. Temporal Constraint Networks Schmiedel, A. November 1988, 30 pp. Linguistics, Volume 15, Number 3, September 1989</note>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
</citationList>
</algorithm>
</algorithms>