<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000500">
<title confidence="0.9957095">
An Earley-style Predictive Chart Parsing
Method for Lambek Grammars
</title>
<author confidence="0.999121">
Mark Hepple
</author>
<affiliation confidence="0.7013955">
Department of Computer Science, University of Sheffield, Regent Court,
211 Portobello Street, Sheffield Si 4DP, UK [heppladcs .shef .ac .uk]
</affiliation>
<sectionHeader confidence="0.878976" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999801666666667">
We present a new chart parsing method for
Lambek grammars, inspired by a method for D-
Tree grammar parsing. The formulae of a Lam-
bek sequent are firstly converted into rules of
an indexed grammar formalism, which are used
in an Earley-style predictive chart algorithm.
The method is non-polynomial, but performs
well for practical purposes — much better than
previous chart methods for Lambek grammars.
</bodyText>
<sectionHeader confidence="0.995517" genericHeader="introduction">
1 Introduction
</sectionHeader>
<bodyText confidence="0.9999641">
We present a new chart parsing method for
Lambek grammars. The starting point for
this work is the observation, in (Hepple, 1998),
of certain similarities between categorial gram-
mars and the D-Tree grammar (DTG) formal-
ism of Rambow et al. (1995a). On this basis,
we have explored adapting the DTG parsing ap-
proach of Rambow et al. (1995b) for use with
the Lambek calculus. The resulting method is
one in which the formulae of a Lambek sequent
that is to be proven are first converted to pro-
duce rules of a formalism which combines ideas
from the multiset-valued linear indexed gram-
mar formalism of Rambow (1994), with the
Lambek calculus span labelling scheme of Mor-
rill (1995), and with the first-order compilation
method for categorial parsing of Hepple (1996).
The resulting &apos;grammar&apos; is then parsed using an
Earley-style predictive chart algorithm which is
adapted from Rambow et al. (1995b).
</bodyText>
<sectionHeader confidence="0.938137" genericHeader="method">
2 The Lambek Calculus
</sectionHeader>
<bodyText confidence="0.997562583333333">
We are concerned with the implicational (or
&apos;product-free&apos;) fragment of the associative Lam-
bek calculus (Lambek, 1958). A natural deduc-
tion formulation is provided by the following
rules of elimination and introduction, which cor-
respond to steps of functional application and
abstraction, respectively (as the term labelling
reveals). The rules are sensitive to the order of
assumptions. In the (resp. [\I]) rule, [B] in-
dicates a discharged or withdrawn assumption,
which is required to be the rightmost (resp. left-
most) of the proof.
</bodyText>
<figure confidence="0.961591083333333">
AIB :a B:b
/E
A : (ab)
• !•[B v]
A : a
AI B : Av.a /I
(ate)
(np\s)/np [np]
/E
np\s
\E
rel
</figure>
<bodyText confidence="0.9900295">
The above proof illustrates &apos;hypothetical
reasoning&apos;, i.e. the presence of additional as-
sumptions (&apos;hypotheticals&apos;) in proofs that are
subsequently discharged. It is because of this
phenomenon that standard chart methods are
inadequate for the Lambek calculus — hypo-
theticals don&apos;t belong at any position on the
single ordering over lexical categories by which
standard charts are organised.1 The previ-
ous chart methods for the Lambek calculus
deal with this problem in different ways. The
method of Konig (1990, 1994) places hypothet-
icals on separate `minicharts&apos; which can attach
into other (mini)charts where combinations are
&apos;In effect, hypotheticals belong on additional subor-
derings, which can connect into the main ordering of
the chart at various positions, generating a branching,
multi-dimensional ordering scheme.
</bodyText>
<figure confidence="0.996866333333333">
B : b B\A : a
A: (ab)
[B : v]• •
A.: a
\I
B\A : Av.a
\E
(which) (mary)
rel/(s/np) np
</figure>
<page confidence="0.999704">
465
</page>
<bodyText confidence="0.9993142">
possible. The method requires rather com-
plicated book-keeping. The method of Hepple
(1992) avoids this complicated book-keeping,
and also rules out some useless subderivations
allowed by Konig&apos;s method, but does so at
the cost of computing a representation of all
the possible category sequences that might be
tested in an exhaustive sequent proof search.
Neither of these methods exhibits performance
that would be satisfactory for practical use.2
</bodyText>
<sectionHeader confidence="0.996873" genericHeader="method">
3 Some Preliminaries
</sectionHeader>
<subsectionHeader confidence="0.999924">
3.1 First-order Compilation for
Categorial Parsing
</subsectionHeader>
<bodyText confidence="0.999967294117647">
Hepple (1996) introduces a method of first-
order compilation for implicational linear logic,
to provide a basis for efficient theorem proving
of various categorial formalisms. Implicational
linear logic is similar to the Lambek calculus,
except having only a single non-directional im-
plication —o. The idea of first-order compil-
ation is to eliminate the need for hypothetical
reasoning by simplifying higher-order formulae
(whose presence requires hypothetical reason-
ing) to first-order formulae. This involves ex-
cising the subformulae that correspond to hy-
potheticals, leaving a first-order residue. The
excised subformulae are added as additional as-
sumptions. For example, a higher-order formula
(Z —0Y) —0 X simplifies to Z+ (Y —0 X), allow-
ing proof (a) to be replaced by (b):
</bodyText>
<equation confidence="0.9951455">
(a) [Z] Z W —o Y (Z —o Y) —o X
Z
(b) Z Z W —o Y Y —o X
X
</equation>
<bodyText confidence="0.9992555">
The method faces two key problems: avoiding
invalid deduction and getting an appropriate se-
</bodyText>
<footnote confidence="0.711890333333333">
2Morrill (1996) provides a somewhat different tabular
method for Lambek parsing within the proof net deduc-
tion framework, in an approach where proof net check-
ing is made by unifying labels marked on literals. The
approach tabulates MG U&apos;s for the labels of contiguous
subsegments of a proof net.
</footnote>
<bodyText confidence="0.997728894736842">
mantics for the combination. To avoid invalid
deduction, an indexing scheme is used to en-
sure that a hypothetical must be used to de-
rive the argument of the residue functor from
which was excised (e.g. Z must be used to
derive the argument Y of Y —o X, a condition
satisfied in proof (b). To get the same se-
mantics with compilation as without, the se-
mantic effects of the introduction rule are com-
piled into the terms of the formulae produced,
e.g. (Z —0 Y) —0 X : w gives Z: z plus Y —0 X :
Au.w(Az.u). Terms are combined, not using
standard application//3-reduction, but rather
an operation Ax.g + h = g[hIl x] where a
variant of substitution is used that allows &apos;ac-
cidental&apos; variable capture. Thus when Y —0 X
combines with its argument, whose derivation
includes Z, the latter&apos;s variable becomes bound,
e.g. Au.w(Az.u) + x(yz) = w(Az.x(yz))
</bodyText>
<subsectionHeader confidence="0.9930075">
3.2 Multiset-valued Linear Indexed
Grammar
</subsectionHeader>
<bodyText confidence="0.999285">
Rambow (1994) introduces the multiset-valued
linear indexed grammar formalism ({}-LIG). In-
dices are stored in an unordered multiset rep-
resentation (c.f. the stack of conventional lin-
ear indexed grammar). The contents of the
multiset at any mother node in a tree is dis-
tributed amongst its daughter nodes in a lin-
ear fashion, i.e each index is passed to pre-
cisely one daughter. Rules take the form
Ao[mo] -4 Ai [mi] ... [m,]. The multiset of
indices mo are required to be present in, and
are removed from, the multiset context of the
mother node in a tree. For each daughter Az,
the indices mi are added into whatever other
indices are inherited to that daughter. Thus,
a rule AH B[1] CH (where H indicates an
empty multiset) can license the use of a rule
D[1] -4 a within the derivation of its daugh-
ter B[1], and so the indexing system allows the
encoding of dominance relations.
</bodyText>
<sectionHeader confidence="0.960054" genericHeader="method">
4 A New Chart Parsing Method for
Lambek Grammars
</sectionHeader>
<subsectionHeader confidence="0.999622">
4.1 Lambek to SLMG Conversion
</subsectionHeader>
<bodyText confidence="0.9999515">
The first task of the parsing approach is to con-
vert the antecedent formulae of the sequent to
be proved into a collection of rules of a form-
alism I call Span Labelled Multiset Grammar
(SLMG). For digestibility, I will present the con-
version process in three stages. (I will assume
</bodyText>
<page confidence="0.999402">
466
</page>
<figureCaption confidence="0.997545">
Figure 1: Phase 1 of conversion (span labelling)
</figureCaption>
<equation confidence="0.622504125">
Method: where j is a new
(A:(i—j))&amp;quot; = A:(i— j) where A atomic variable/constant
(A I B:(h—i))P = (A:(h— j))P I (B:(i— j))P as p is + I —
(B\A:(h—i))&amp;quot; = (B:(j—h))P \ (A:(j —i))P
Example:
(X I (Y Z):(0-1))+ X:(0—h)/(Y:(1—k)/Z:(h—k))
(W:(1-2)) W:(1-2)
((W\Y)/Z:(2-3))+ (W:(i-2)\Y:(i—j))IZ:(3—j)
</equation>
<bodyText confidence="0.991402367647059">
that in any sequent F = A to be proved, the
succedent A is atomic. Any sequent not in this
form is easily converted to one, of equivalent
theoremhood, which is.)
Firstly, directional types are labelled with
span information using the labelling scheme
of Morrill (1995) (which is justified in rela-
tion to relational algebraic models for the Lam-
bek calculus (van Benthem, 1991)). An ante-
cedent Xi in Xi ... X = X0 has basic span
(h—i) where h = (i — 1). The labelled for-
mula is computed from (Xi: (h — 0)-1- using the
polar translation functions shown in Figure 1
(where 15 denotes the complementary polarity
to p).3 As an example, Figure 1 also shows
the results of converting the antededents of
Xl(YIZ),W,(W\Y)IZ = X (where k is a con-
stant and i, j variables).4
The second stage of the conversion is adap-
ted from the first-order compilation method of
Hepple (1996), discussed earlier, modified to
handle directional formulae and using a mod-
ified indexation scheme to record dependencies
3The constants produced in the translation corres-
pond to &apos;new&apos; string positions, which make up the addi-
tional suborderings on which hypotheticals are located.
The variables produced in the translation become instan-
tiated to some string constant during an analysis, fixing
the position at which an additional subordering becomes
&apos;attached to&apos; another (sub)ordering.
4The idea of implementing categorial grammar as a
non-directional logic, but associating atomic types with
string position pairs (i.e. spans) to handle word order,
is used in Pareschi (1988), although in that approach all
string positions instantiate to values on a single ordering
(i.e. integers 0 — n for a string of length n), which is not
sufficient for Lambek calculus deductions.
between residue formulae and excised hypothet-
icals (one where both the residue and hypothet-
ical record the dependency). For this proced-
ure, the &apos;atomic type plus span label&apos; units that
result from the previous stage are treated as
atomic units. The procedure -r is defined by the
cases shown in Figure 2 (although the method is
perhaps best understood from the example also
shown there). Its input is a pair (T, t), T a span
labelled formula, t its associated term.5
This procedure simplifies higher-order formu-
lae to first-order ones in the manner already dis-
cussed, and records dependencies between hy-
pothetical and residue formulae using the in-
dexing scheme. Assuming the antecedents of
our example Xl(YIZ),W,(W\Y)1Z = X, to
have terms Si, s2, s3 respectively, compilation
yields results as in the example in Figure 2. The
higher-order X/(Y/Z) yields two output formu-
lae: the main residue XIY and the hypothetical
Z, with the dependency between the two indic-
ated by the common index 1 in the argument
index set of the former and the principal index
set of the latter. The empty sets elsewhere in-
dicate the absence of such dependencies.
The final stage of the conversion process
converts the results of the second phrase into
SLMG productions. The method will be ex-
plained by example. For a functor such
as B\(((A\X)I D)IC), we can easily pro-
ject the sequence of arguments it requires:
</bodyText>
<footnote confidence="0.551942">
&apos;Note that the &amp;quot;+&amp;quot; of (A ± f) in (TO) simply pairs
together the single compiled formula A with the set r of
compiled formulae, where A is the main residue of the
input formula and r its derived hypotheticals.
</footnote>
<page confidence="0.991414">
467
</page>
<note confidence="0.354735">
Method:
</note>
<equation confidence="0.7420390625">
(TO) r((T, t)) =Aur where T((0, T, t)) = A + r
(Tia) r((m, X/ Y, t)) = r((m, XAY:(1), t)) where Y has no index set
(rib) as for (T1a) modulo directionality of connective
(T2a) r((m, /(Y:mi), t)) = X2 /(Y:rni ), Av.$) + r
where Y atomic, T((m, (tv))) = (n, X2 S) +r, v afresh variable
(T2b) as for (T2a) modulo directionality of connective
(r3a) r((m, X I ((Y Z):mi),t)) = A + (B u r U A)
where w,v fresh variables, i a fresh multiset index, m2 = i U mi
T(On,X/(17:m2),Aw.t(Av.w))) = A + r, T((i, Z, v)) = B + A
(r3b)—(73d) as for (T3a) modulo directionality of connectives
Example:
{ (0, X :(0 — h) (Y :(1—k):{1}), Au.si(Az.u))
({1},Z:(h—k)),z)
TW:(1-2), 82)) = (0, W:(1-2), 82)
7-(((W:(i-2)\Y:(i—j))1Z:(3—j),s3)) = (0, ((W:(i-2):0)\Y :(i — j))1(Z:(3— j):0), AvAw .(s3 v w))
r((X:(0—h)/(Y:(1—k)/Z:(h—k)),81)) =
</equation>
<figureCaption confidence="0.943487">
Figure 2: Phase 2 of conversion (first-order compilation)
</figureCaption>
<bodyText confidence="0.997577673469388">
A,B,BW(A\X)1D)1C),C,D = X. If the
functor was the lexical category of a word w, it
might be viewed as fulfilling a role akin to a PS
rule such asX--*ABwCD. For the present
approach, with explicit span labelling, there is
no need to include a rhs element to mark the
position of the functor (or word) itself, so the
corresponding production would be more akin
to X .—=1. B C D. For an atomic formula, the
corresponding production will have an empty
rhs, e.g. A -4 ().6
The left and right hand side units of SLMG
productions all take the form A[mj(i—j), where
A is an atomic type, m is a set of indices (if
m is empty, the unit may be written A[](i—j)),
6Note that () is used rather than 6 to avoid the sug-
gestion of the empty string, which it is not — matters to
do with the &apos;string&apos; are handled solely within the span
labelling. This point is reinforced by observing that the
&apos;string language&apos; generated by a collection SLMG pro-
ductions will consist only of (nonempty) sequences of
()&apos;s. The real import of a SLMG derivation is not its ter-
minal yield, but rather the instantiation of span labels
that it induces (for string matters), and its structure (for
semantic matters).
and (i—i) a span label. For a formula (m, T ,t)
resulting after first-order compilation, the rhs
elements of the corresponding production cor-
respond to the arguments (if any) of T , whereas
its lhs combines the result type (plus span) of
T with the multiset m. For our running ex-
ample Xl(Y1Z),W,(W\Y)1Z = X, the formu-
lae resulting from the second phase (by first-
order compilation) give rise to productions as
shown in Figure 3. The associated semantic
term for each rule is intended to be applied to
the semantics if its daughters in their left-to-
right order (which may require some reordering
of the outermost lambdas c.f. the terms of the
first-order formulae, e.g. as for the last rule).
A sequent X1 ... X n, X0 is proven if we
can build a SLMG tree with root X0[](0—n) in
which the SLMG rules derived from the ante-
cedents are each used precisely once, and which
induces a consistent binding over span variables.
For our running example, the required deriva-
tion, shown below, yields the correct interpret-
ation si(Az.s3 z 82). Note that &apos;linear resource
use&apos;, i.e. that each rule must be used precisely
</bodyText>
<page confidence="0.960747">
468
</page>
<equation confidence="0.9662765">
Example:
(0, X :(0 — h) I (Y :(1—k):{1}), Au.si(Az.u)) = X[](0—h) Y[1](1—k) : Au.si(Az.u)
({1}, Z :(h—k)), z) = Z[1](h—k) —&gt; () : z
(0, W:(1-2), 82) = WH(1-2) -4 0 : s2
(0, ((W:(i-2):0)\Y:(i—j))/(Z:(3 — j):0) , Av AID .(s3 v w))
YH(i—j) W[](i-2) Z[](3—j) : AwAv .(s3 v w)
</equation>
<figureCaption confidence="0.985616">
Figure 3: Phase 3 of conversion (converting to SLMG productions)
</figureCaption>
<bodyText confidence="0.999798555555556">
once, is enforced by the span labelling scheme
and does not need to be separately stipulated.
Thus, the span (0—n) is marked on the root of
the derivation. To bridge this span, the main
residues of the antecedent formulae must all
participate (since each &apos;consumes&apos; a basic sub-
span of the main span) and they in turn require
participation of their hypotheticals via the in-
dexing scheme.
</bodyText>
<equation confidence="0.9748775">
XH(0-3)
Y[1](1—k)
WH(1-2) Z[1](3—k)
0
</equation>
<subsectionHeader confidence="0.99097">
4.2 The Earley-style Parsing Method
</subsectionHeader>
<bodyText confidence="0.997710069767442">
The chart parsing method to be presented
is derived from the Earley-style DTG pars-
ing method of Rambow et al. (1995), and
in some sense both simplifies and complicates
their method. In effect, we abstract from their
method a simpler one for Earley-style parsing of
{}-LIG (which is a simpler formalism than the
Linear Prioritized Multiset Grammar (LPMG)
into which they compile DTG), and then ex-
tend this method to handle the span labelling
of SLMG. A key differences of the new approach
as compared to standard chart methods is that
the usual external notion of span is dispensed
with, and the combination of edges is instead re-
gimented in terms of the explicit span labelling
of categories in rules. The unification of span
labels requires edges to carry explicit binding
information for span variables. We use R to de-
note the set of rules derived from the sequent,
and E the set of edges in the chart. The general
form of edges is: ((mi , m2), 0, r, (A F • A))
where (A —&gt; r, A) E R, U is a substitution
over span variables, r is a restrictor set identi-
fying span variables whose values are required
non-locally (explained below), and ml, m2 are
multisets. In a {}-LIG or SLMG tree, there is
no restriction on how the multiset indices associ-
ated with any non-terminal node can be distrib-
uted amongst its daughters. Rather than cash-
ing out the possible distributions as alternative
edges in the predictor step, we can instead, in
effect, &apos;thread&apos; the multiset through the daugh-
ters, i.e. passing the entire multiset down to
the first daughter, and passing any that are not
used there on to the next daughter, and so on.
For an edge ((mi, m2), 0, r, (A r • A)), mi
corresponds to the multiset context at the time
the ancestor edge with dotted rule (A —&gt; .FA)
was introduced, and m2 is the current multiset
for passing onto the daughters in A. We call m1
the initial multiset and m2 the current multiset.
The chart method employs the rules shown in
Figure 4. We shall consider each in turn.
</bodyText>
<sectionHeader confidence="0.77685" genericHeader="method">
Initialisation:
</sectionHeader>
<bodyText confidence="0.997371375">
The rule recorded on the edge in this chart rule
is not a real one (i.e. ct R), but serves to drive
the parsing process via the prediction of edges
for rules that can derive X0[1(1—n). A success-
ful proof of the sequent is shown if the com-
pleted chart contains an inactive edge for the
special goal category, i.e. there is some edge
((0, 0), 0, 0, (GOAL[](4,—*) A.)) E E
</bodyText>
<sectionHeader confidence="0.493065" genericHeader="method">
Prediction:
</sectionHeader>
<bodyText confidence="0.9999694">
The current multiset of the predicting edge is
passed onto the new edge as its initial multiset.
The latter&apos;s current multiset (m6) may differ
from its initial one due either to the removal of
an index to license the new rule&apos;s use (i.e. if
</bodyText>
<page confidence="0.999679">
469
</page>
<figureCaption confidence="0.994616">
Figure 4: Chart rules
</figureCaption>
<table confidence="0.8561122">
Initialisation:
if the initial sequent is X1 . • . Xn= Xo
then ((0,0),(b,0, (GOAL[j(*—*) —+ •Xo[](1—n))) E E
Prediction:
if ((ml, m2), 01, n., (A[m3](e—f) r • B[m4] (9—h), A)) E E
and (B[m,d(i—j) A) E R
then ((m2,m6),02,r2,(B[m51(g—(h0)) .(A0))) e E
where 01+ MGU((g—h),(i—j)) ; m5 .g m2 U m4 ; ms = (m2 U m4) — ;
= nlv(m2 U m4) ; 02 = 0/(r2 U dauglnlv(A))
Completer:
if ((mi, m2), 01, r1, (A[m.3](f —g) -4 r • B[m4yi —h), .60) E E
and ((m2, m5), 02, 7&apos;2, (B[m61(i—j) —* A.)) E E
then ((mi,m5),03,ri, (A[m3](f —(g0)) F, B[m4](i—j) • (AB))) E E
where 0 = + 02 ± MGU(h)j) ; M5 C M2 ; M6 C M2 U M4 ;
03 = 01(n. U dauglnlv(A))
</table>
<bodyText confidence="0.99944116">
m5 is non-empty), or to the addition of indices
from the predicting edge&apos;s next rhs unit (i.e. if
m4 is non-empty). (Note the &apos;sloppy&apos; use of set,
rather than explicitly multiset, notation. The
present approach is such that the same index
should never appear in both of two unioned sets,
so there is in practice little difference.)
The line 0 = 0 + MG CI ((g—h),(i— j)) checks
that the corresponding span labels unify, and
that the resulting MGU can consistently aug-
ment the binding context of the predicting edge.
This augmented binding is used to instantiate
span variables in the new edge where possible.
It is a characteristic of this parsing method,
with top-down left-to-right traversal and associ-
ated propagation of span information, that the
left span index of the next daughter sought by
any active edge is guarenteed to be instantiated,
i.e. g above is a constant.
Commonly the variables appearing in SLMG
rules have only local significance and so their
substitutions do not need to be carried around
with edges. For example, an active edge might
require two daughters Bll(g—h) CH(h—i). A
substitution for h that comes from combin-
ing with an inactive edge for BH(g—h) can
be immediately applied to the next daughter
C[1(h—i), and so does not need to be carried
explicitly in the binding of the resulting edge.
However, a situation where two occurrences of
a variable appear in different rules may arise
as a result of first-order compilation, which will
sometimes (but not always) separate a variable
occurrence in the hypothetical from another in
the residue. For the rule set of our running ex-
ample, we find an occurrence of h in both the
first and second rule (corresponding to the main
residue and hypothetical of the initial higher-
order functor). The link between the two rules is
also indicated by the indexing system. It turns
out that for each index there is at most one vari-
able that may appear in the two rules linked
by the index. The identity of the &apos;non-local
variables&apos; that associate with each index can
be straightforwardly computed off the SLMG
grammar (or during the conversion process).
The function nlv returns the set of non-local
variables that associate with a multiset of in-
dices. The line r2 = nlv(m2 U m4) computes
the set of variables whose values may need to
</bodyText>
<page confidence="0.99451">
470
</page>
<bodyText confidence="0.999946326086957">
be passed non-locally, i.e. from the predicting
edge down to the predicted edge, or from an
inactive edge that results from combination of
this predicted edge up to the active edge that
consumes it. This `restrictor set&apos; is used in redu-
cing the substitution 0 to cover only those vari-
ables whose values need to be stored with the
edge. The only case where a substitution needs
to be retained for variable that is not in the re-
strictor set arises regarding the next daughter
it seeks. For example, an active edge might
require two daughters .13[](g—h) C[1](k—i),
where the second&apos;s index links it to a hypo-
thetical with span (k—h). Here, a substitution
for h from a combination for the first daughter
cannot be immediately applied and so should
be retained until a combination is made for the
second daughter. The function call dauglnlv(A)
returns the set of non-local variables associated
with the multiset indices of the next daugh-
ter in A (or the empty set if A is empty).
There may be at most one variable in this set
that appears in the substitution 0. The line
0 2 = 61/(r2 U dauglnlv(A)) reduces the substi-
tution to cover only the variables whose values
need to be stored. Failing to restrict the substi-
tution in this way undermines the compaction
of derivations by the chart, i.e. so that we find
edges in the chart corresponding to the same
subderivation, but which are not recognised as
such during parsing due to them recording in-
compatible substitutions.
Completer:
Recall from the prediction step that the pre-
dicted edge&apos;s current multiset may differ from
its initial multiset due to the addition of indices
from the predicting edge&apos;s next rhs unit (i.e. m4
in the prediction rule). Any such added indices
must be &apos;used up&apos; within the subderivation of
that rhs element which is realised by the com-
binations of the predicted edge. This require-
ment is checked by the condition m5 C m2.
The treatment of substitutions here is very
much as for the prediction rule, except that both
input edges contribute their own substitution.
Note that for the inactive edge (as for all inact-
ive edges), both components of the span (i—i)
will be instantiated, so we need only unify the
right index of the two spans — the left indices
can simply be checked for atomic identity. This
observation is important to efficient implement-
ation of the algorithm, for which most effort is in
practice expended on the completer step. Act-
ive edges should be indexed (i.e. hashed) with
respect to the (atomic) type and left span index
of the next rhs element sought. For inactive
edges, the type and left span index of the lhs
element should be used. For the completer step
when an active edge is added, we need only ac-
cess inactive edges that are hashed on the same
type/left span index to consider for combina-
tion, all others can be ignored, and vice versa
for the addition of an inactive edge.
It is notable that the algorithm has no scan-
ning rule, which is due to the fact that the po-
sitions of &apos;lexical items&apos; or antecedent categor-
ies are encoded in the span labels of rules, and
need no further attention. In the (Rambow et
al., 1995) algorithm, the scanning component
also deals with epsilon productions. Here, rules
with an empty rhs are dealt with by prediction,
by allowing an edge added for a rule with an
empty rhs to be treated as an inactive edge (i.e.
we equate &amp;quot;( ) s&amp;quot; and &amp;quot;s
If the completed chart indicates a successful
analysis, it is straightforward to compute the
proof terms of the corresponding natural deduc-
tion proofs, given a record of which edges were
produced by combination of which other edges,
or by prediction from which rule. Thus, the
term for a predicted edge is simply that of the
rule in R, whereas a term for an edge produced
by a completer step is arrived at by combining a
term of the active edge with one for the inactive
edge (using the special substitution operation
that allows &apos;accidental binding&apos; of variables, as
discussed earlier). Of course, a single edge may
compact multiple alternative subproofs, and so
return multiple terms. Note that the approach
has no problem in handling multiple lexical as-
signments, they simply result in multiple rules
generated off the same basic span of the chart.
</bodyText>
<sectionHeader confidence="0.979178" genericHeader="conclusions">
5 Efficiency and Complexity
</sectionHeader>
<bodyText confidence="0.999874625">
The method is shown to be non-polynomial by
considering a simple class of examples of the
form X1,. . . Xn_1, a = a, where each X is
a/(a/(a\ a)). Each such Xi gives a hypothetical
whose dependency is encoded by a multiset in-
dex. Examination of the chart reveals spans for
which there are multiple edges, differing in their
&apos;initial&apos; multiset (and other ways), there being
</bodyText>
<page confidence="0.997885">
471
</page>
<figureCaption confidence="0.9499105">
xo/a/(xi/(a/a)), xi /(x2/(a/a)), x2/(a/a), a/a, a/a, a/a, a/a, a/a, a =xo
Figure 5: Example for comparison of methods
</figureCaption>
<bodyText confidence="0.999983551020408">
one for edge for each subset of the indices deriv-
ing from the antecedents X1,. . . Xn-2, i.e. giv-
ing 2(n-2) distinct edges. This non-polynomial
number of edge results in non-polynomial time
for the completer step, and in turn for the al-
gorithm as a whole. Hence, this approach does
not resolve the open question of the polynomial
time parsability of the Lambek calculus. In-
formally, however, these observations are sug-
gestive of a possible locus of difficulty in achiev-
ing such a result. Thus, the hope for polyno-
mial time parsability of the Lambek calculus
comes from it being an ordered &apos;list-like&apos; sys-
tem, rather than an unordered &apos;bag-like&apos; sys-
tem, but in the example just discussed, we ob-
serve &apos;bag-like&apos; behaviour in a compact encoding
(the multiset) of the dependencies of hypothet-
ical reasoning.
We should note that the DTG parsing
method of (Rambow et al., 1995), from which
the current approach is derived, is polynomial
time. This follows from the fact that their com-
pilation applies to a preset DTG, giving rise to
a fixed maximal set of distinct indices in the
LPMG that the compilation generates. This
fixed set of indices gives rise to a very large,
but polynomial, worst-case upper limit on the
number of edges in a chart, which in turn yields
a polynomial time result. A key difference for
the present approach is that our task is to parse
arbitrary initial sequents, and hence we do not
have the fixed initial grammar that is the basis
of the Rambow et al. complexity result.
For practical comparison to the previous
Lambek chart methods, consider the highly am-
biguous artificial example shown in Figure 5,
(which has six readings). Konig (1994) reports
that a Prolog implementation of her method,
running on a major workstation produces 300
edges in 50 seconds. A Prolog implementation
of the current method, on a current major work
station, produces 75 edges in less than a tenth
of a second. Of course, the increase in comput-
ing power over the years makes the times not
strictly comparable, but still a substantial speed
up is indicated. The difference in the number
of edges suggests that the Konig method is sub-
optimal in its compaction of alternative deriva-
tions.
</bodyText>
<sectionHeader confidence="0.999146" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999218833333333">
van Benthem, J. 1991. Language in Ac-
tion: Categories, Lamdas and Dynamic Lo-
gic. Studies in Logic and the Foundations of
Mathematics, vol 130, North-Holland, Ams-
terdam.
Hepple, M. 1992. Chart Parsing Lambek
Grammars: Modal Extensions and Incre-
mentality&apos;, Proc. of COLING-92.
Mark Hepple. 1996. &apos;A Compilation-Chart
Method for Linear Categorial Deduction.&apos;
Proc. COLING-96, Copenhagen.
Hepple, M. 1998. &apos;On Some Similarities
Between D-Tree Grammars and Type-Logical
Grammars.&apos; Proc. Fourth Workshop on Tree-
Adjoining Grammars and Related Frame-
works.
Konig, E. 1990, &apos;The complexity of parsing
with extended categorial grammars&apos;, Proc. of
COLING-90.
Esther Konig. 1994. &apos;A Hypothetical Reas-
oning Algorithm for Linguistic Analysis.&apos;
Journal of Logic and Computation, Vol. 4,
No 1.
Lambek, J. 1958. &apos;The mathematics of sentence
structure.&apos; American Mathematical Monthly
65. 154-170.
Morrill, G. 1995. &apos;Higher-order Linear Logic
Programming of Categorial Dedution&apos;, Proc.
of EACL-7, Dublin.
Morrill, G. 1996. `Memoisation for Categorial
Proof Nets: Parallelism in Categorial Pro-
cessing.&apos; Research Report LSI-96-24-R, Uni-
versitat Politecnica de Catalunya.
Pareschi, R. 1988. &apos;A Definite Clause Version
of Categorial Grammar.&apos; Proc. 26th ACL.
Rambow, 0. 1994. &apos;Multiset-valued linear index
grammars.&apos; Proc. ACL
Rambow, 0., Vijay-Shanker, K. &amp; Weir, D.
1995a. &apos;D-Tree Grammars.&apos; Proc. ACL-95.
Rambow, 0., Vijay-Shanker, K. &amp; Weir, D.
1995b. &apos;Parsing D-Tree Grammars.&apos; Proc.
Int. Workshop on Parsing Technologies.
</reference>
<page confidence="0.99849">
472
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.646775">
<title confidence="0.9998535">An Earley-style Predictive Chart Parsing Method for Lambek Grammars</title>
<author confidence="0.999982">Mark Hepple</author>
<affiliation confidence="0.999931">Department of Computer Science, University of Sheffield, Regent Court,</affiliation>
<address confidence="0.91749">Portobello Street, Sheffield Si 4DP, UK .shef .ac .uk</address>
<abstract confidence="0.994938242424242">We present a new chart parsing method for Lambek grammars, inspired by a method for D- Tree grammar parsing. The formulae of a Lambek sequent are firstly converted into rules of an indexed grammar formalism, which are used in an Earley-style predictive chart algorithm. The method is non-polynomial, but performs well for practical purposes — much better than previous chart methods for Lambek grammars. We present a new chart parsing method for Lambek grammars. The starting point for this work is the observation, in (Hepple, 1998), of certain similarities between categorial grammars and the D-Tree grammar (DTG) formalof Rambow al. On this basis, we have explored adapting the DTG parsing apof Rambow al. for use with the Lambek calculus. The resulting method is one in which the formulae of a Lambek sequent that is to be proven are first converted to produce rules of a formalism which combines ideas the linear indexed gramof Rambow (1994), with the Lambek calculus span labelling scheme of Mor- (1995), and with the compilation method for categorial parsing of Hepple (1996). The resulting &apos;grammar&apos; is then parsed using an Earley-style predictive chart algorithm which is from Rambow al. 2 The Lambek Calculus We are concerned with the implicational (or &apos;product-free&apos;) fragment of the associative Lamcalculus (Lambek, 1958). A deducis provided by the following of correspond to steps of functional application and abstraction, respectively (as the term labelling reveals). The rules are sensitive to the order of In the (resp. [\I]) rule, dicates a discharged or withdrawn assumption, which is required to be the rightmost (resp. leftmost) of the proof. AIB :a B:b /E : • v] A : a B : (ate) (np\s)/np [np] /E np\s \E rel The above proof illustrates &apos;hypothetical reasoning&apos;, i.e. the presence of additional assumptions (&apos;hypotheticals&apos;) in proofs that are subsequently discharged. It is because of this phenomenon that standard chart methods are inadequate for the Lambek calculus — hypotheticals don&apos;t belong at any position on the single ordering over lexical categories by which charts are The previous chart methods for the Lambek calculus deal with this problem in different ways. The method of Konig (1990, 1994) places hypotheticals on separate `minicharts&apos; which can attach into other (mini)charts where combinations are &apos;In effect, hypotheticals belong on additional suborderings, which can connect into the main ordering of the chart at various positions, generating a branching, multi-dimensional ordering scheme. B : b B\A : a [B : v]• • a \I : \E (which) (mary) rel/(s/np) np 465 possible. The method requires rather complicated book-keeping. The method of Hepple (1992) avoids this complicated book-keeping, and also rules out some useless subderivations allowed by Konig&apos;s method, but does so at the cost of computing a representation of all the possible category sequences that might be tested in an exhaustive sequent proof search. Neither of these methods exhibits performance would be satisfactory for practical 3 Some Preliminaries 3.1 First-order Compilation for Categorial Parsing (1996) introduces a method of firstcompilation implicational linear logic, to provide a basis for efficient theorem proving of various categorial formalisms. Implicational linear logic is similar to the Lambek calculus, except having only a single non-directional imidea of first-order compilation is to eliminate the need for hypothetical reasoning by simplifying higher-order formulae (whose presence requires hypothetical reasoning) to first-order formulae. This involves excising the subformulae that correspond to hypotheticals, leaving a first-order residue. The excised subformulae are added as additional assumptions. For example, a higher-order formula —0Y) —0 X to —0 allowing proof (a) to be replaced by (b): [Z] Z —o Y —o —o Z Z Z —o Y Y —o X The method faces two key problems: avoiding deduction and getting an appropriate se- (1996) provides a somewhat different method for Lambek parsing within the proof net deduction framework, in an approach where proof net checking is made by unifying labels marked on literals. The tabulates U&apos;s the labels of contiguous subsegments of a proof net. mantics for the combination. To avoid invalid deduction, an indexing scheme is used to enthat a hypothetical used to derive the argument of the residue functor from was excised (e.g. be used to the argument Y of Y condition satisfied in proof (b). To get the same semantics with compilation as without, the se-</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>J van Benthem</author>
</authors>
<title>Language in Action: Categories, Lamdas and Dynamic Logic.</title>
<date>1991</date>
<booktitle>Studies in Logic and the Foundations of Mathematics, vol 130, North-Holland,</booktitle>
<location>Amsterdam.</location>
<marker>van Benthem, 1991</marker>
<rawString>van Benthem, J. 1991. Language in Action: Categories, Lamdas and Dynamic Logic. Studies in Logic and the Foundations of Mathematics, vol 130, North-Holland, Amsterdam.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Hepple</author>
</authors>
<title>Chart Parsing Lambek Grammars: Modal Extensions and Incrementality&apos;,</title>
<date>1992</date>
<booktitle>Proc. of COLING-92.</booktitle>
<contexts>
<context position="3195" citStr="Hepple (1992)" startWordPosition="516" endWordPosition="517">1 The previous chart methods for the Lambek calculus deal with this problem in different ways. The method of Konig (1990, 1994) places hypotheticals on separate `minicharts&apos; which can attach into other (mini)charts where combinations are &apos;In effect, hypotheticals belong on additional suborderings, which can connect into the main ordering of the chart at various positions, generating a branching, multi-dimensional ordering scheme. B : b B\A : a A: (ab) [B : v]• • A.: a \I B\A : Av.a \E (which) (mary) rel/(s/np) np 465 possible. The method requires rather complicated book-keeping. The method of Hepple (1992) avoids this complicated book-keeping, and also rules out some useless subderivations allowed by Konig&apos;s method, but does so at the cost of computing a representation of all the possible category sequences that might be tested in an exhaustive sequent proof search. Neither of these methods exhibits performance that would be satisfactory for practical use.2 3 Some Preliminaries 3.1 First-order Compilation for Categorial Parsing Hepple (1996) introduces a method of firstorder compilation for implicational linear logic, to provide a basis for efficient theorem proving of various categorial formal</context>
</contexts>
<marker>Hepple, 1992</marker>
<rawString>Hepple, M. 1992. Chart Parsing Lambek Grammars: Modal Extensions and Incrementality&apos;, Proc. of COLING-92.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Mark Hepple</author>
</authors>
<title>A Compilation-Chart Method for Linear Categorial Deduction.&apos;</title>
<date>1996</date>
<booktitle>Proc. COLING-96,</booktitle>
<location>Copenhagen.</location>
<contexts>
<context position="1409" citStr="Hepple (1996)" startWordPosition="226" endWordPosition="227">ities between categorial grammars and the D-Tree grammar (DTG) formalism of Rambow et al. (1995a). On this basis, we have explored adapting the DTG parsing approach of Rambow et al. (1995b) for use with the Lambek calculus. The resulting method is one in which the formulae of a Lambek sequent that is to be proven are first converted to produce rules of a formalism which combines ideas from the multiset-valued linear indexed grammar formalism of Rambow (1994), with the Lambek calculus span labelling scheme of Morrill (1995), and with the first-order compilation method for categorial parsing of Hepple (1996). The resulting &apos;grammar&apos; is then parsed using an Earley-style predictive chart algorithm which is adapted from Rambow et al. (1995b). 2 The Lambek Calculus We are concerned with the implicational (or &apos;product-free&apos;) fragment of the associative Lambek calculus (Lambek, 1958). A natural deduction formulation is provided by the following rules of elimination and introduction, which correspond to steps of functional application and abstraction, respectively (as the term labelling reveals). The rules are sensitive to the order of assumptions. In the (resp. [\I]) rule, [B] indicates a discharged or</context>
<context position="3639" citStr="Hepple (1996)" startWordPosition="581" endWordPosition="582">: a A: (ab) [B : v]• • A.: a \I B\A : Av.a \E (which) (mary) rel/(s/np) np 465 possible. The method requires rather complicated book-keeping. The method of Hepple (1992) avoids this complicated book-keeping, and also rules out some useless subderivations allowed by Konig&apos;s method, but does so at the cost of computing a representation of all the possible category sequences that might be tested in an exhaustive sequent proof search. Neither of these methods exhibits performance that would be satisfactory for practical use.2 3 Some Preliminaries 3.1 First-order Compilation for Categorial Parsing Hepple (1996) introduces a method of firstorder compilation for implicational linear logic, to provide a basis for efficient theorem proving of various categorial formalisms. Implicational linear logic is similar to the Lambek calculus, except having only a single non-directional implication —o. The idea of first-order compilation is to eliminate the need for hypothetical reasoning by simplifying higher-order formulae (whose presence requires hypothetical reasoning) to first-order formulae. This involves excising the subformulae that correspond to hypotheticals, leaving a first-order residue. The excised s</context>
<context position="8187" citStr="Hepple (1996)" startWordPosition="1373" endWordPosition="1374">of Morrill (1995) (which is justified in relation to relational algebraic models for the Lambek calculus (van Benthem, 1991)). An antecedent Xi in Xi ... X = X0 has basic span (h—i) where h = (i — 1). The labelled formula is computed from (Xi: (h — 0)-1- using the polar translation functions shown in Figure 1 (where 15 denotes the complementary polarity to p).3 As an example, Figure 1 also shows the results of converting the antededents of Xl(YIZ),W,(W\Y)IZ = X (where k is a constant and i, j variables).4 The second stage of the conversion is adapted from the first-order compilation method of Hepple (1996), discussed earlier, modified to handle directional formulae and using a modified indexation scheme to record dependencies 3The constants produced in the translation correspond to &apos;new&apos; string positions, which make up the additional suborderings on which hypotheticals are located. The variables produced in the translation become instantiated to some string constant during an analysis, fixing the position at which an additional subordering becomes &apos;attached to&apos; another (sub)ordering. 4The idea of implementing categorial grammar as a non-directional logic, but associating atomic types with strin</context>
</contexts>
<marker>Hepple, 1996</marker>
<rawString>Mark Hepple. 1996. &apos;A Compilation-Chart Method for Linear Categorial Deduction.&apos; Proc. COLING-96, Copenhagen.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Hepple</author>
</authors>
<title>On Some Similarities Between D-Tree Grammars and Type-Logical Grammars.&apos;</title>
<date>1998</date>
<booktitle>Proc. Fourth Workshop on TreeAdjoining Grammars and Related Frameworks.</booktitle>
<contexts>
<context position="776" citStr="Hepple, 1998" startWordPosition="119" endWordPosition="120">lo Street, Sheffield Si 4DP, UK [heppladcs .shef .ac .uk] Abstract We present a new chart parsing method for Lambek grammars, inspired by a method for DTree grammar parsing. The formulae of a Lambek sequent are firstly converted into rules of an indexed grammar formalism, which are used in an Earley-style predictive chart algorithm. The method is non-polynomial, but performs well for practical purposes — much better than previous chart methods for Lambek grammars. 1 Introduction We present a new chart parsing method for Lambek grammars. The starting point for this work is the observation, in (Hepple, 1998), of certain similarities between categorial grammars and the D-Tree grammar (DTG) formalism of Rambow et al. (1995a). On this basis, we have explored adapting the DTG parsing approach of Rambow et al. (1995b) for use with the Lambek calculus. The resulting method is one in which the formulae of a Lambek sequent that is to be proven are first converted to produce rules of a formalism which combines ideas from the multiset-valued linear indexed grammar formalism of Rambow (1994), with the Lambek calculus span labelling scheme of Morrill (1995), and with the first-order compilation method for ca</context>
</contexts>
<marker>Hepple, 1998</marker>
<rawString>Hepple, M. 1998. &apos;On Some Similarities Between D-Tree Grammars and Type-Logical Grammars.&apos; Proc. Fourth Workshop on TreeAdjoining Grammars and Related Frameworks.</rawString>
</citation>
<citation valid="true">
<authors>
<author>E Konig</author>
</authors>
<title>The complexity of parsing with extended categorial grammars&apos;,</title>
<date>1990</date>
<booktitle>Proc. of COLING-90.</booktitle>
<contexts>
<context position="2702" citStr="Konig (1990" startWordPosition="436" endWordPosition="437">he proof. AIB :a B:b /E A : (ab) • !•[B v] A : a AI B : Av.a /I (ate) (np\s)/np [np] /E np\s \E rel The above proof illustrates &apos;hypothetical reasoning&apos;, i.e. the presence of additional assumptions (&apos;hypotheticals&apos;) in proofs that are subsequently discharged. It is because of this phenomenon that standard chart methods are inadequate for the Lambek calculus — hypotheticals don&apos;t belong at any position on the single ordering over lexical categories by which standard charts are organised.1 The previous chart methods for the Lambek calculus deal with this problem in different ways. The method of Konig (1990, 1994) places hypotheticals on separate `minicharts&apos; which can attach into other (mini)charts where combinations are &apos;In effect, hypotheticals belong on additional suborderings, which can connect into the main ordering of the chart at various positions, generating a branching, multi-dimensional ordering scheme. B : b B\A : a A: (ab) [B : v]• • A.: a \I B\A : Av.a \E (which) (mary) rel/(s/np) np 465 possible. The method requires rather complicated book-keeping. The method of Hepple (1992) avoids this complicated book-keeping, and also rules out some useless subderivations allowed by Konig&apos;s me</context>
</contexts>
<marker>Konig, 1990</marker>
<rawString>Konig, E. 1990, &apos;The complexity of parsing with extended categorial grammars&apos;, Proc. of COLING-90.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Esther Konig</author>
</authors>
<title>A Hypothetical Reasoning Algorithm for Linguistic Analysis.&apos;</title>
<date>1994</date>
<journal>Journal of Logic and Computation,</journal>
<volume>4</volume>
<marker>Konig, 1994</marker>
<rawString>Esther Konig. 1994. &apos;A Hypothetical Reasoning Algorithm for Linguistic Analysis.&apos; Journal of Logic and Computation, Vol. 4, No 1.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Lambek</author>
</authors>
<title>The mathematics of sentence structure.&apos;</title>
<date>1958</date>
<journal>American Mathematical Monthly</journal>
<volume>65</volume>
<pages>154--170</pages>
<contexts>
<context position="1684" citStr="Lambek, 1958" startWordPosition="267" endWordPosition="268">f a Lambek sequent that is to be proven are first converted to produce rules of a formalism which combines ideas from the multiset-valued linear indexed grammar formalism of Rambow (1994), with the Lambek calculus span labelling scheme of Morrill (1995), and with the first-order compilation method for categorial parsing of Hepple (1996). The resulting &apos;grammar&apos; is then parsed using an Earley-style predictive chart algorithm which is adapted from Rambow et al. (1995b). 2 The Lambek Calculus We are concerned with the implicational (or &apos;product-free&apos;) fragment of the associative Lambek calculus (Lambek, 1958). A natural deduction formulation is provided by the following rules of elimination and introduction, which correspond to steps of functional application and abstraction, respectively (as the term labelling reveals). The rules are sensitive to the order of assumptions. In the (resp. [\I]) rule, [B] indicates a discharged or withdrawn assumption, which is required to be the rightmost (resp. leftmost) of the proof. AIB :a B:b /E A : (ab) • !•[B v] A : a AI B : Av.a /I (ate) (np\s)/np [np] /E np\s \E rel The above proof illustrates &apos;hypothetical reasoning&apos;, i.e. the presence of additional assumpt</context>
</contexts>
<marker>Lambek, 1958</marker>
<rawString>Lambek, J. 1958. &apos;The mathematics of sentence structure.&apos; American Mathematical Monthly 65. 154-170.</rawString>
</citation>
<citation valid="true">
<authors>
<author>G Morrill</author>
</authors>
<title>Higher-order Linear Logic Programming of Categorial Dedution&apos;,</title>
<date>1995</date>
<booktitle>Proc. of EACL-7,</booktitle>
<location>Dublin.</location>
<contexts>
<context position="1324" citStr="Morrill (1995)" startWordPosition="213" endWordPosition="215">starting point for this work is the observation, in (Hepple, 1998), of certain similarities between categorial grammars and the D-Tree grammar (DTG) formalism of Rambow et al. (1995a). On this basis, we have explored adapting the DTG parsing approach of Rambow et al. (1995b) for use with the Lambek calculus. The resulting method is one in which the formulae of a Lambek sequent that is to be proven are first converted to produce rules of a formalism which combines ideas from the multiset-valued linear indexed grammar formalism of Rambow (1994), with the Lambek calculus span labelling scheme of Morrill (1995), and with the first-order compilation method for categorial parsing of Hepple (1996). The resulting &apos;grammar&apos; is then parsed using an Earley-style predictive chart algorithm which is adapted from Rambow et al. (1995b). 2 The Lambek Calculus We are concerned with the implicational (or &apos;product-free&apos;) fragment of the associative Lambek calculus (Lambek, 1958). A natural deduction formulation is provided by the following rules of elimination and introduction, which correspond to steps of functional application and abstraction, respectively (as the term labelling reveals). The rules are sensitive</context>
<context position="7591" citStr="Morrill (1995)" startWordPosition="1263" endWordPosition="1264"> 466 Figure 1: Phase 1 of conversion (span labelling) Method: where j is a new (A:(i—j))&amp;quot; = A:(i— j) where A atomic variable/constant (A I B:(h—i))P = (A:(h— j))P I (B:(i— j))P as p is + I — (B\A:(h—i))&amp;quot; = (B:(j—h))P \ (A:(j —i))P Example: (X I (Y Z):(0-1))+ X:(0—h)/(Y:(1—k)/Z:(h—k)) (W:(1-2)) W:(1-2) ((W\Y)/Z:(2-3))+ (W:(i-2)\Y:(i—j))IZ:(3—j) that in any sequent F = A to be proved, the succedent A is atomic. Any sequent not in this form is easily converted to one, of equivalent theoremhood, which is.) Firstly, directional types are labelled with span information using the labelling scheme of Morrill (1995) (which is justified in relation to relational algebraic models for the Lambek calculus (van Benthem, 1991)). An antecedent Xi in Xi ... X = X0 has basic span (h—i) where h = (i — 1). The labelled formula is computed from (Xi: (h — 0)-1- using the polar translation functions shown in Figure 1 (where 15 denotes the complementary polarity to p).3 As an example, Figure 1 also shows the results of converting the antededents of Xl(YIZ),W,(W\Y)IZ = X (where k is a constant and i, j variables).4 The second stage of the conversion is adapted from the first-order compilation method of Hepple (1996), di</context>
</contexts>
<marker>Morrill, 1995</marker>
<rawString>Morrill, G. 1995. &apos;Higher-order Linear Logic Programming of Categorial Dedution&apos;, Proc. of EACL-7, Dublin.</rawString>
</citation>
<citation valid="true">
<authors>
<author>G Morrill</author>
</authors>
<title>Memoisation for Categorial Proof Nets: Parallelism in Categorial Processing.&apos;</title>
<date>1996</date>
<tech>Research Report LSI-96-24-R, Universitat Politecnica de Catalunya.</tech>
<contexts>
<context position="4568" citStr="Morrill (1996)" startWordPosition="734" endWordPosition="736">tion is to eliminate the need for hypothetical reasoning by simplifying higher-order formulae (whose presence requires hypothetical reasoning) to first-order formulae. This involves excising the subformulae that correspond to hypotheticals, leaving a first-order residue. The excised subformulae are added as additional assumptions. For example, a higher-order formula (Z —0Y) —0 X simplifies to Z+ (Y —0 X), allowing proof (a) to be replaced by (b): (a) [Z] Z W —o Y (Z —o Y) —o X Z (b) Z Z W —o Y Y —o X X The method faces two key problems: avoiding invalid deduction and getting an appropriate se2Morrill (1996) provides a somewhat different tabular method for Lambek parsing within the proof net deduction framework, in an approach where proof net checking is made by unifying labels marked on literals. The approach tabulates MG U&apos;s for the labels of contiguous subsegments of a proof net. mantics for the combination. To avoid invalid deduction, an indexing scheme is used to ensure that a hypothetical must be used to derive the argument of the residue functor from which was excised (e.g. Z must be used to derive the argument Y of Y —o X, a condition satisfied in proof (b). To get the same semantics with</context>
</contexts>
<marker>Morrill, 1996</marker>
<rawString>Morrill, G. 1996. `Memoisation for Categorial Proof Nets: Parallelism in Categorial Processing.&apos; Research Report LSI-96-24-R, Universitat Politecnica de Catalunya.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Pareschi</author>
</authors>
<title>A Definite Clause Version of Categorial Grammar.&apos;</title>
<date>1988</date>
<booktitle>Proc. 26th ACL. Rambow,</booktitle>
<volume>0</volume>
<contexts>
<context position="8865" citStr="Pareschi (1988)" startWordPosition="1472" endWordPosition="1473">d using a modified indexation scheme to record dependencies 3The constants produced in the translation correspond to &apos;new&apos; string positions, which make up the additional suborderings on which hypotheticals are located. The variables produced in the translation become instantiated to some string constant during an analysis, fixing the position at which an additional subordering becomes &apos;attached to&apos; another (sub)ordering. 4The idea of implementing categorial grammar as a non-directional logic, but associating atomic types with string position pairs (i.e. spans) to handle word order, is used in Pareschi (1988), although in that approach all string positions instantiate to values on a single ordering (i.e. integers 0 — n for a string of length n), which is not sufficient for Lambek calculus deductions. between residue formulae and excised hypotheticals (one where both the residue and hypothetical record the dependency). For this procedure, the &apos;atomic type plus span label&apos; units that result from the previous stage are treated as atomic units. The procedure -r is defined by the cases shown in Figure 2 (although the method is perhaps best understood from the example also shown there). Its input is a p</context>
</contexts>
<marker>Pareschi, 1988</marker>
<rawString>Pareschi, R. 1988. &apos;A Definite Clause Version of Categorial Grammar.&apos; Proc. 26th ACL. Rambow, 0. 1994. &apos;Multiset-valued linear index grammars.&apos; Proc. ACL Rambow, 0., Vijay-Shanker, K. &amp; Weir, D. 1995a. &apos;D-Tree Grammars.&apos; Proc. ACL-95.</rawString>
</citation>
<citation valid="true">
<authors>
<author>K Vijay-Shanker</author>
<author>D Weir</author>
</authors>
<title>Parsing D-Tree Grammars.&apos;</title>
<date>1995</date>
<booktitle>Proc. Int. Workshop on Parsing Technologies.</booktitle>
<marker>Vijay-Shanker, Weir, 1995</marker>
<rawString>Rambow, 0., Vijay-Shanker, K. &amp; Weir, D. 1995b. &apos;Parsing D-Tree Grammars.&apos; Proc. Int. Workshop on Parsing Technologies.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>