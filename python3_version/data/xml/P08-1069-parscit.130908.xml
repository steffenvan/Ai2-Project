<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000012">
<title confidence="0.967861">
Optimal k-arization of Synchronous Tree-Adjoining Grammar
</title>
<author confidence="0.986623">
Rebecca Nesson
</author>
<affiliation confidence="0.971641666666667">
School of Engineering
and Applied Sciences
Harvard University
</affiliation>
<address confidence="0.954322">
Cambridge, MA 02138
</address>
<email confidence="0.999258">
nesson@seas.harvard.edu
</email>
<author confidence="0.992675">
Giorgio Satta
</author>
<affiliation confidence="0.87531075">
Department of
Information Engineering
University of Padua
I-35131 Padova, Italy
</affiliation>
<email confidence="0.99489">
satta@dei.unipd.it
</email>
<author confidence="0.993316">
Stuart M. Shieber
</author>
<affiliation confidence="0.972912">
School of Engineering
and Applied Sciences
Harvard University
</affiliation>
<address confidence="0.954484">
Cambridge, MA 02138
</address>
<email confidence="0.999303">
shieber@seas.harvard.edu
</email>
<sectionHeader confidence="0.998946" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.982210666666667">
Synchronous Tree-Adjoining Grammar
(STAG) is a promising formalism for syntax-
aware machine translation and simultaneous
computation of natural-language syntax and
semantics. Current research in both of these
areas is actively pursuing its incorporation.
However, STAG parsing is known to be
NP-hard due to the potential for intertwined
correspondences between the linked nonter-
minal symbols in the elementary structures.
Given a particular grammar, the polynomial
degree of efficient STAG parsing algorithms
depends directly on the rank of the grammar:
the maximum number of correspondences that
appear within a single elementary structure.
In this paper we present a compile-time
algorithm for transforming a STAG into a
strongly-equivalent STAG that optimally
minimizes the rank, k, across the grammar.
The algorithm performs in O(JGJ + JY J · LG)
time where LG is the maximum number of
links in any single synchronous tree pair in
the grammar and Y is the set of synchronous
tree pairs of G.
</bodyText>
<sectionHeader confidence="0.999471" genericHeader="introduction">
1 Introduction
</sectionHeader>
<bodyText confidence="0.999982627906976">
Tree-adjoining grammar is a widely used formal-
ism in natural-language processing due to its mildly-
context-sensitive expressivity, its ability to naturally
capture natural-language argument substitution (via
its substitution operation) and optional modifica-
tion (via its adjunction operation), and the existence
of efficient algorithms for processing it. Recently,
the desire to incorporate syntax-awareness into ma-
chine translation systems has generated interest in
the application of synchronous tree-adjoining gram-
mar (STAG) to this problem (Nesson, Shieber, and
Rush, 2006; Chiang and Rambow, 2006). In a par-
allel development, interest in incorporating seman-
tic computation into the TAG framework has led
to the use of STAG for this purpose (Nesson and
Shieber, 2007; Han, 2006b; Han, 2006a; Nesson
and Shieber, 2006). Although STAG does not in-
crease the expressivity of the underlying formalisms
(Shieber, 1994), STAG parsing is known to be NP-
hard due to the potential for intertwined correspon-
dences between the linked nonterminal symbols in
the elementary structures (Satta, 1992; Weir, 1988).
Without efficient algorithms for processing it, its po-
tential for use in machine translation and TAG se-
mantics systems is limited.
Given a particular grammar, the polynomial de-
gree of efficient STAG parsing algorithms depends
directly on the rank of the grammar: the maximum
number of correspondences that appear within a sin-
gle elementary structure. This is illustrated by the
tree pairs given in Figure 1 in which no two num-
bered links may be isolated. (By “isolated”, we
mean that the links can be contained in a fragment
of the tree that contains no other links and domi-
nates only one branch not contained in the fragment.
A precise definition is given in section 3.)
An analogous problem has long been known
to exist for synchronous context-free grammars
(SCFG) (Aho and Ullman, 1969). The task of
producing efficient parsers for SCFG has recently
been addressed by binarization or k-arization of
SCFG grammars that produce equivalent grammars
in which the rank, k, has been minimized (Zhang
</bodyText>
<page confidence="0.982204">
604
</page>
<note confidence="0.669567">
Proceedings ofACL-08: HLT, pages 604–612,
</note>
<page confidence="0.41587">
Columbus, Ohio, USA, June 2008. c�2008 Association for Computational Linguistics
</page>
<figure confidence="0.974910178571428">
γ1 : γ2 : A 1 A γ3 :
2
D1 E F G
2 3 4 D2 E F G
4 1 3
W x y z w
B C
A
B C
A
B 2 B
C 3 C
D4 D
w/
4
3
1
B C
3 4
D 1
W x w/
A5 A
E 2
B C
2
D3 E4
5
1
</figure>
<figureCaption confidence="0.998424166666667">
Figure 1: Example of intertwined links that cannot be binarized. No two links can be isolated in both trees in a tree
pair. Note that in tree pair y1, any set of three links may be isolated while in tree pair y2, no group of fewer than four
links may be isolated. In y3 no group of links smaller than four may be isolated.
Figure 2: An example STAG derivation of the English/French sentence pair “John likes red candies”/“Jean aime les
bonbons rouges”. The figure is divided as follows: (a) the STAG grammar, (b) the derivation tree for the sentence
pair, and (c) the derived tree pair for the sentences.
</figureCaption>
<figure confidence="0.98993174">
(a) S S (b) likes (e)
NPI 1 V P NPI 1
Adj N. N.
red rouges candies
N
V
likes
V P
NPI2 V NPI
N
Adj
aime
NP
N
1
2
Det
les bonbons
NP
John candies
N
1 2
1
NP NP
John Jean
red
1
NP V P
John V
likes
S
Adj
red
NP
N
candies
N
Jean
S
NP V P
aime
V
Det
les
bonbons
NP
N
N
Adj
rouges
</figure>
<bodyText confidence="0.999370576923077">
and Gildea, 2007; Zhang et al., 2006; Gildea, Satta,
and Zhang, 2006). The methods for k-arization
of SCFG cannot be directly applied to STAG be-
cause of the additional complexity introduced by
the expressivity-increasing adjunction operation of
TAG. In SCFG, where substitution is the only avail-
able operation and the depth of elementary struc-
tures is limited to one, the k-arization problem re-
duces to analysis of permutations of strings of non-
terminal symbols. In STAG, however, the arbitrary
depth of the elementary structures and the lack of
restriction to contiguous strings of nonterminals in-
troduced by adjunction substantially complicate the
task.
In this paper we offer the first algorithm address-
ing this problem for the STAG case. We present
a compile-time algorithm for transforming a STAG
into a strongly-equivalent STAG that optimally min-
imizes k across the grammar. This is a critical mini-
mization because k is the feature of the grammar that
appears in the exponent of the complexity of parsing
algorithms for STAG. Following the method of Seki
et al. (1991), an STAG parser can be implemented
with complexity O(n4·(k+1) |G|). By minimizing
k, the worst-case complexity of a parser instanti-
ated for a particular grammar is optimized. The k-
</bodyText>
<page confidence="0.590257">
3
</page>
<bodyText confidence="0.999764166666667">
arization algorithm performs in O ( |G  |+  |Y  |LG)
time where LG is the maximum number of links in
any single synchronous tree pair in the grammar and
Y is the set of synchronous tree pairs of G. By com-
parison, a baseline algorithm performing exhaustive
search requires O(|G |+ |Y  |LG) time.1
The remainder of the paper proceeds as follows.
In section 2 we provide a brief introduction to the
STAG formalism. We present the k-arization algo-
rithm in section 3 and an analysis of its complexity
in section 4. We prove the correctness of the algo-
rithm in section 5.
</bodyText>
<footnote confidence="0.5452086">
1In a synchronous tree pair with L links, there are O(L4)
pairs of valid fragments. It takes O(L) time to check if the two
components in a pair have the same set of links. Once the syn-
chronous fragment with the smallest number of links is excised,
this process iterates at most L times, resulting in time O(LG).
</footnote>
<page confidence="0.997796">
605
</page>
<figureCaption confidence="0.7838515">
Figure 3: A synchronous tree pair containing frag-
ments αL = γL(n1,n2) and αR = γR(n3). Since
</figureCaption>
<equation confidence="0.97206825">
links(n1,n2) = links(n3) = 12, 4, 5}, we can de-
fine synchronous fragment α = (αL, αR). Note also
that node n3 is a maximal node and node n5 is not.
σ(n1) = 2 5 5 3 3 2 4 4; σ(n3) = 2 5 5 4 4 2.
</equation>
<sectionHeader confidence="0.940828" genericHeader="method">
2 Synchronous Tree-Adjoining Grammar
</sectionHeader>
<bodyText confidence="0.999939516129032">
A tree-adjoining grammar (TAG) consists of a set of
elementary tree structures of arbitrary depth, which
are combined by substitution, familiar from context-
free grammars, or an operation of adjunction that is
particular to the TAG formalism. Auxiliary trees
are elementary trees in which the root and a frontier
node, called the foot node and distinguished by the
diacritic *, are labeled with the same nonterminal A.
The adjunction operation involves splicing an auxil-
iary tree in at an internal node in an elementary tree
also labeled with nonterminal A. Trees without a
foot node, which serve as a base for derivations, are
called initial trees. For further background, refer to
the survey by Joshi and Schabes (1997).
We depart from the traditional definition in nota-
tion only by specifying adjunction and substitution
sites explicitly with numbered links. Each link may
be used only once in a derivation. Operations may
only occur at nodes marked with a link. For sim-
plicity of presentation we provisionally assume that
only one link is permitted at a node. We later drop
this assumption.
In a synchronous TAG (STAG) the elementary
structures are ordered pairs of TAG trees, with a
linking relation specified over pairs of nonterminal
nodes. Each link has two locations, one in the left
tree in a pair and the other in the right tree. An ex-
ample of an STAG derivation including both substi-
tution and adjunction is given in Figure 2. For fur-
ther background, refer to the work of Shieber and
Schabes (1990) and Shieber (1994).
</bodyText>
<sectionHeader confidence="0.995709" genericHeader="method">
3 k-arization Algorithm
</sectionHeader>
<bodyText confidence="0.999973347826087">
For a synchronous tree pair γ = (γL, γR), a frag-
ment of γL (or γR) is a complete subtree rooted at
some node n of γL, written γL(n), or else a subtree
rooted at n with a gap at node n&apos;, written γL(n, n&apos;);
see Figure 3 for an example. We write links(n) and
links(n, n&apos;) to denote the set of links of γL(n) and
γL(n, n&apos;), respectively. When we do not know the
root or gap nodes of some fragment αL, we also
write links(αL).
We say that a set of links A from γ can be iso-
lated if there exist fragments αL and αR of γL
and γR, respectively, both with links A. If this is
the case, we can construct a synchronous fragment
α = (αL, αR). The goal of our algorithm is to de-
compose γ into synchronous fragments such that the
maximum number of links of a synchronous frag-
ment is kept to a minimum, and γ can be obtained
from the synchronous fragments by means of the
usual substitution and adjunction operations. In or-
der to simplify the presentation of our algorithm we
assume, without any loss of generality, that all ele-
mentary trees of the source STAG have nodes with
at most two children.
</bodyText>
<subsectionHeader confidence="0.998157">
3.1 Maximal Nodes
</subsectionHeader>
<bodyText confidence="0.976929857142857">
A node n of γL (or γR) is called maximal if
(i) links(n) =� 0, and (ii) it is either the root node
of γL or, for its parent node n&apos;, we have links(n&apos;) =�
links(n). Note that for every node n&apos; of γL such
that links(n&apos;) =� 0 there is always a unique maxi-
mal node n such that links(n&apos;) = links(n). Thus,
for the purpose of our algorithm, we need only look
at maximal nodes as places for excising tree frag-
ments. We can show that the number of maxi-
mal nodes Mn in a subtree γL(n) always satisfies
|links(n) |&lt; Mn &lt; 2 x |links(n) |− 1.
Let n be some node of γL, and let l(n) be the
(unique) link impinging on n if such a link exists,
and l(n) = ε otherwise. We associate n with a
string σ(n), defined by a pre- and post-order traver-
sal of fragment γL(n). The symbols of σ(n) are the
links in links(n), viewed as atomic symbols. Given
a node n with p children ni, ... , np, 0 &lt; p &lt; 2,
we define σ(n) = l(n) σ(n1) · · · σ(np) l(n). See
again Figure 3 for an example. Note that |σ(n) |=
2 x |links(n)|.
</bodyText>
<equation confidence="0.884691523809524">
γ :
E 5 n2 : F
Y z
C
2
nl :
B
A
3 n5 :G4
n4 :
D
M N4
5
W z
K
n3 :
I2 J3
H
L
y�
z&apos;
</equation>
<page confidence="0.94871">
606
</page>
<table confidence="0.854527833333333">
1 0 0 0 0 0 0 0 0 1
2 0 1 0 0 0 0 1 0 0 0
1
5 0 0 1 1 0 0 0 0 0 0
5 0 0 1 1 0 0 0 0 0 0
3 0 0 0 0 0 0 0 1 1 0
3 0 0 0 0 0 0 0 1 1 0
2 0 1 0 0 0 0 1 0 0 0
4 0 0 0 0 1 1 0 0 0 0
4 0 0 0 0 1 1 0 0 0 0
1 0 0 0 0 0 0 0 0 1
2 5 5 4 4 2 3 3
</table>
<figure confidence="0.959423705882353">
X X X&apos; X X
X&apos;
3
G
X&apos;
G2
G2
G
2
X*
G
X&apos;
excise adjoin G transform
2
ItL
nl
n2
</figure>
<figureCaption confidence="0.996441">
Figure 4: A diagram of the tree transformation performed
when fragment γL(n1, n2) is removed. In this and the
diagrams that follow, patterned or shaded triangles rep-
resent segments of the tree that contain multiple nodes
and at least one link. Where the pattern or shading corre-
sponds across trees in a tree pair, the set of links contained
within those triangles are equivalent.
</figureCaption>
<subsectionHeader confidence="0.999613">
3.2 Excision of Synchronous Fragments
</subsectionHeader>
<bodyText confidence="0.999856884615385">
Although it would be possible to excise synchronous
fragments without creating new nonterminal nodes,
for clarity we present a simple tree transforma-
tion when a fragment is excised that leaves exist-
ing nodes intact. A schematic depiction is given in
Figure 4. In the figure, we demonstrate the exci-
sion process on one half of a synchronous fragment:
γL(n1, n2) is excised to form two new trees. The
excised tree is not processed further. In the exci-
sion process the root and gap nodes of the original
tree are not altered. The material between them is
replaced with a single new node with a fresh non-
terminal symbol and a fresh link number. This non-
terminal node and link form the adjunction or sub-
stitution site for the excised tree. Note that any link
impinging on the root node of the excised fragment
is by our convention included in the fragment and
any link impinging on the gap node is not.
To regenerate the original tree, the excised frag-
ment can be adjoined or substituted back into the
tree from which it was excised. The new nodes that
were generated in the excision may be removed and
the original root and gap nodes may be merged back
together retaining any impinging links, respectively.
Note that if there was a link on either the root or gap
node in the original tree, it is not lost or duplicated
</bodyText>
<figureCaption confidence="0.968871">
Figure 5: Table π with synchronous fragment
(γL(n1, n2), γR(n3)) from Figure 3 highlighted.
</figureCaption>
<bodyText confidence="0.851846">
in the process.
</bodyText>
<subsectionHeader confidence="0.990677">
3.3 Method
</subsectionHeader>
<bodyText confidence="0.999975172413793">
Let nL and nR be the root nodes of trees γL and γR,
respectively. We know that links(nL) = links(nR),
and |σ(nL) |= |σ(nR)|, the second string being a
rearrangement of the occurrences of symbols in the
first one. The main data structure of our algorithm is
a Boolean matrix π of size |σ(nL)|x|σ(nL)|, whose
rows are addressed by the occurrences of symbols in
σ(nL), in the given order, and whose columns are
similarly addressed by σ(nR). For occurrences of
links x1 , x2 , the element of π at a row addressed by
x1 and a column addressed by x2 is 1 if x1 = x2,
and 0 otherwise. Thus, each row and column of π
has exactly two non-zero entries. See Figure 5 for
an example.
For a maximal node n1 of γL, we let π(n1) de-
note the stripe of adjacent rows of π addressed by
substring σ(n1) of σ(nL). If n1 dominates n2 in γL,
we let π(n1, n2) denote the rows of π addressed by
σ(n1) but not by σ(n2). This forms a pair of hori-
zontal stripes in π. For nodes n3, n4 of γR, we sim-
ilarly define π(n3) and π(n3, n4) as vertical stripes
of adjacent columns. See again Figure 5.
Our algorithm is reported in Figure 6. For each
synchronous tree pair γ = (γL, γR) from the in-
put grammar, we maintain an agenda B with all
candidate fragments αL from γL having at least
two links. These fragments are processed greed-
ily in order of increasing number of links. The
function ISOLATE(), described in more detail be-
</bodyText>
<page confidence="0.984273">
607
</page>
<listItem confidence="0.99331388">
1: Function KARIZE(G) {G a binary STAG}
2: G&apos; ← STAG with empty set of synch trees;
3: for all γ = hγL, γRi in G do
4: init π and B;
5: while B =6 ∅ do
6: αL ← next fragment from B;
7: αR ← ISOLATE(αL, π, γR);
8: if αR =6 null then
9: add hαL, αRi to G&apos;;
10: γ ← excise hαL, αRi from γ;
11: update π and B;
12: add γ to G&apos;;
13: return G&apos;
1: Function ISOLATE(αL, π, γR)
2: select n ∈ γR such that σ(n) is the shortest
string within σ(nR) including left/right bound-
aries of αL in π;
3: if |σ(n) |= 2 × |links(αL) |then
4: return γR(n);
5: select n&apos; ∈ γR such that σ(n&apos;) is the gap string
within σ(n) for which links(n) − links(n&apos;) =
links(αL);
6: if n&apos; is not defined then
7: return null; {more than one gap}
8: return γR(n, n&apos;);
</listItem>
<figureCaption confidence="0.9999935">
Figure 7: Find synchronous fragment.
Figure 6: Main algorithm.
</figureCaption>
<bodyText confidence="0.999941304347826">
low, looks for a right fragment αR with the same
links as αL. Upon success, the synchronous frag-
ment α = hαL, αRi is added to the output grammar.
Furthermore, we excise α from γ and update data
structures π and B. The above process is iterated
until B becomes empty. We show in section 5 that
this greedy strategy is sound and complete.
The function ISOLATE() is specified in Figure 7.
We take as input a left fragment αL, which is asso-
ciated with one or two horizontal stripes in π, de-
pending on whether αL has a gap node or not. The
left boundary of αL in π is the index x1 of the col-
umn containing the leftmost occurrence of a 1 in the
horizontal stripes associated with αL. Similarly, the
right boundary of αL in π is the index x2 of the col-
umn containing the rightmost occurrence of a 1 in
these stripes. We retrieve the shortest substring σ(n)
of σ(nR) that spans over indices x1 and x2. This
means that n is the lowest node from γR such that
the links of αL are a subset of the links of γR(n).
If the condition at line 3 is satisfied, all of the ma-
trix entries of value 1 that are found from column
x1 to column x2 fall within the horizontal stripes
associated with αL. In this case we can report the
right fragment αR = γR(n). Otherwise, we check
whether the entries of value 1 that fall outside of
the two horizontal stripes in between columns x1
and x2 occur within adjacent columns, say from col-
umn x3 ≥ x1 to column x4 ≤ x2. In this case,
we check whether there exists some node n&apos; such
that the substring of σ(n) from position x3 to x4 is
an occurrence of string σ(n&apos;). This means that n&apos;
is the gap node, and we report the right fragment
αL = γR(n, n&apos;). See again Figure 5.
We now drop the assumption that only one link
may impinge on a node. When multiple links im-
pinge on a single node n, l(n) is an arbitrary order
over those links. In the execution of the algorithm,
any stripe that contains one link in l(n) it must in-
clude every link in l(n). This prevents the excision
of a proper subset of the links at any node. This pre-
serves correctness because excising any proper sub-
set would impose an order over the links at n that
is not enforced in the input grammar. Because the
links at a node are treated as a unit, the complexity
of the algorithm is not affected.
</bodyText>
<sectionHeader confidence="0.998733" genericHeader="method">
4 Complexity
</sectionHeader>
<bodyText confidence="0.999771133333333">
We discuss here an implementation of the algo-
rithm of section 3 resulting in time complexity
O(|G |+ |Y  |· L3G), where Y is the set of syn-
chronous tree pairs of G and LG is the maximum
number of links in a synchronous tree pair in Y .
Consider a synchronous tree pair γ = hγL, γRi
with L links. If M is the number of maximal nodes
in γL or γR, we have M = Θ(L) (Section 3.1). We
implement the sparse table π in O(L) space, record-
ing for each row and column the indices of its two
non-zero entries. We also assume that we can go
back and forth between maximal nodes n and strings
σ(n) in constant time. Here each σ(n) is represented
by its boundary positions within σ(nL) or σ(nR),
nL and nR the root nodes of γL and γR, respectively.
</bodyText>
<page confidence="0.997487">
608
</page>
<bodyText confidence="0.999696239130435">
At line 2 of the function ISOLATE() (Figure 7) we
retrieve the left and right boundaries by scanning the
rows of 7r associated with input fragment αL. We
then retrieve node n by visiting all maximal nodes
of -yL spanning these boundaries. Under the above
assumptions, this can be done in time O(L). In a
similar way we can implement line 5, resulting in
overall run time O(L) for function ISOLATE().
In the function KARIZE() (Figure 6) we use buck-
ets Bi, 1 ≤ i ≤ L, where each Bi stores the candi-
date fragments αL with |links(αL) |= i. To populate
these buckets, we first process fragments -yL(n) by
visiting bottom up the maximal nodes of -yL. The
quantity |links(n) |is computed from the quantities
|links(ni)|, where ni are the highest maximal nodes
dominated by n. (There are at most two such nodes.)
Fragments -yL(n, n&apos;) can then be processed using
the relation |links(n,n&apos;) |= |links(n) |− |links(n&apos;)|.
In this way each fragment is processed in constant
time, and population of all the buckets takes O(L2)
time.
We now consider the while loop at lines 5 to 11 in
function KARIZE(). For a synchronous tree pair -y,
the loop iterates once for each candidate fragment
αL in some bucket. We have a total of O(L2) it-
erations, since the initial number of candidates in
the buckets is O(L2), and the possible updating of
the buckets after a synchronous fragment is removed
does not increase the total size of all the buckets. If
the links in αL cannot be isolated, one iteration takes
time O(L) (the call to function ISOLATE()). If the
links in αL can be isolated, then we need to restruc-
ture 7r and to repopulate the buckets. The former
can be done in time O(L) and the latter takes time
O(L2), as already discussed. Crucially, the updat-
ing of 7r and the buckets takes place no more than
L − 1 times. This is because each time we excise
a synchronous fragment, the number of links in -y is
reduced by at least one.
We conclude that function KARIZE() takes time
O(L3) for each synchronous tree -y, and the total
running time is O(|G |+ |Y  |· L3G), where Y is the
set of synchronous tree pairs of G. The term |G |ac-
counts for the reading of the input, and dominates
the complexity of the algorithm only in case there
are very few links in each synchronous tree pair.
</bodyText>
<figureCaption confidence="0.981245">
Figure 8: In -y links 3 and 5 cannot be isolated because
the fragment would have to contain two gaps. However,
after the removal of fragment -y(n1, n2), an analogous
fragment -y&apos;(n3, n4) may be removed.
</figureCaption>
<sectionHeader confidence="0.93044" genericHeader="method">
5 Proof of Correctness
</sectionHeader>
<bodyText confidence="0.9985295">
The algorithm presented in the previous sections
produces an optimal k-arization for the input gram-
mar. In this section we sketch a proof of correctness
of the strategy employed by the algorithm.2
The k-arization strategy presented above is
greedy in that it always chooses the excisable frag-
ment with the smallest number of links at each step
and does not perform any backtracking. We must
therefore show that this process cannot result in a
non-optimal solution. If fragments could not overlap
each other, this would be trivial to show because the
excision process would be confluent. If all overlap-
ping fragments were cases of complete containment
of one fragment within another, the proof would also
be trivial because the smallest-to-largest excision or-
der would guarantee optimality. However, it is pos-
sible for fragments to partially overlap each other,
meaning that the intersection of the set of links con-
tained in the two fragments is non-empty and the dif-
ference between the set of links in one fragment and
the other is also non-empty. Overlapping fragment
configurations are given in Figure 9 and discussed in
detail below.
The existence of partially overlapping fragments
complicates the proof of optimality for two reasons.
First, the excision of a fragment α that is partially
overlapped with another fragment Q necessarily pre-
cludes the excision of Q at a later stage in the ex-
</bodyText>
<footnote confidence="0.780775666666667">
2Note that the soundness of the algorithm can be easily veri-
fied from the fact that the removal of fragments can be reversed
by performing standard STAG adjunction and substitution oper-
ations until a single STAG tree pair is produced. This tree pair
is trivially homomorphic to the original tree pair and can easily
be mapped to the original tree pair.
</footnote>
<figure confidence="0.950779428571428">
γ : n1 :A γ� .
5
n2 :
B C
3 4
n3 :
A&apos;
B
A
3
D 1
n4 :
D 1
E 2
</figure>
<page confidence="0.963085">
609
</page>
<equation confidence="0.968411022222223">
ni : A (2) n5 :A (3)
n2 :
n3 :
n4 :
B
D
C
n6 : n7 :
B C
nio : n11 :
C D
n8 :
ng :
B
A
n2 :
B
K x
D
n2 :
C
n3 :
remove α
n3 :
C
n6 :
F
J x
D
n4 :
n4 :
D
remove,8
n4 :
D
E
nl :
nl :
A n5 :
A n5 :E ni :A n5 :E
n6 : n7 :
F G
H x Ix
B
n4 :
</equation>
<figureCaption confidence="0.984745">
Figure 9: The four possible configurations of overlapped
</figureCaption>
<bodyText confidence="0.830239375">
fragments within a single tree. For type 1, let α =
γ(n1, n3) and β = γ(n2, n4). The roots and gaps of the
fragments are interleaved. For type 1&apos;, let α = γ(n1, n3)
and β = γ(n2). The root of β dominates the gap of α.
For type 2, let α = γ(n5, ns) and β = γ(n5, n7). The
fragments share a root and have gap nodes that do not
dominate each other. For type 3 let α = γ(n8, n10) and
β = γ(n9, n11). The root of α dominates the root of β,
both roots dominate both gaps, but neither gap dominates
the other.
cision process. Second, the removal of a fragment
may cause a previously non-isolatable set of links to
become isolatable, effectively creating a new frag-
ment that may be advantageous to remove. This is
demonstrated in Figure 8. These possibilities raise
the question of whether the choice between remov-
ing fragments α and β may have consequences at a
later stage in the excision process. We demonstrate
that this choice cannot affect the k found for a given
grammar.
We begin by sketching the proof of a lemma that
shows that removal of a fragment β that partially
overlaps another fragment α always leaves an anal-
ogous fragment that may be removed.
</bodyText>
<subsectionHeader confidence="0.996287">
5.1 Validity Preservation
</subsectionHeader>
<bodyText confidence="0.998705333333333">
Consider a STAG tree pair γ containing the set of
links A and two synchronous fragments α and β
with α containing links links(α) and β containing
links(β) (links(α), links(β) C A).
If α and β do not overlap, the removal of β is
defined as validity preserving with respect to α.
If α and β overlap, removal of β from γ is valid-
ity preserving with respect to α if after the removal
there exists a valid synchronous fragment (contain-
ing at most one gap on each side) that contains all
and only the links (links(α)−links(β))U{x} where
x is the new link added to γ.
</bodyText>
<figureCaption confidence="0.779748333333333">
Figure 10: Removal from a tree pair γ containing type 1–
type 2 fragment overlap. The fragment α is represented
by the horizonal-lined pieces of the tree pair. The frag-
ment β is represented by the vertical-lined pieces of the
tree pair. Cross-hatching indicates the overlapping por-
tion of the two fragments.
</figureCaption>
<bodyText confidence="0.9996945625">
We prove a lemma that removal of any syn-
chronous fragment from an STAG tree pair is va-
lidity preserving with respect to all of the other syn-
chronous fragments in the tree pair.
It suffices to show that for two arbitrary syn-
chronous fragments α and β, the removal of β is
validity preserving with respect to α. We show this
by examination of the possible configurations of α
and β.
Consider the case in which β is fully contained
within α. In this case links(β) C links(α). The re-
moval of β leaves the root and gap of α intact in both
trees in the pair, so it remains a valid fragment. The
new link is added at the new node inserted where
β was removed. Since β is fully contained within
α, this node is below the root of α but not below
its gap. Thus, the removal process leaves α with the
links (links(α)−links(β))U{x}, where x isthelink
added in the removal process; the removal is validity
preserving.
Synchronous fragments may partially overlap in
several different ways. There are four possible con-
figurations for an overlapped fragment within a sin-
gle tree, depicted in Figure 9. These different single-
tree overlap types can be combined in any way to
form valid synchronous fragments. Due to space
constraints, we consider two illustrative cases and
leave the remainder as an exercise to the reader.
An example of removing fragments from
a tree set containing type 1–type 2 over-
lapped fragments is given in Figure 10.
Let α = (γL(n1, n3),γR(n5, n6)). Let
</bodyText>
<page confidence="0.981257">
610
</page>
<bodyText confidence="0.995284782608696">
β = (γL(n2, n4),γR(n5, n7)). If α is re-
moved, the validity preserving fragment for β is
(γ&apos;L(n1, n4), γ&apos;R(n5)). It contains the links in the
vertical-lined part of the tree and the new link x.
This forms a valid fragment because both sides con-
tain at most one gap and both contain the same set
of links. In addition, it is validity preserving for β
because it contains exactly the set of links that were
in links(β) and not in links(α) plus the new link
x. If we instead choose to remove β, the validity
preserving fragment for α is (γ&apos;L(n1, n4), γ&apos;R(n5)).
The links in each side of this fragment are the same,
each side contains at most one gap, and the set of
links is exactly the set left over from links(α) once
links(β) is removed plus the newly generated link x.
An example of removing fragments from a tree
set containing type 1&apos;–type 3 (reversed) overlapped
fragments is given in Figure 11. If α is re-
moved, the validity preserving fragment for β is
(γ&apos;L(n1),γ&apos;R(n4)). If β is removed, the validity pre-
serving fragment for α is (γ&apos; L(n1,n8),γ&apos;R(n4)).
Similar reasoning follows for all remaining types
of overlapped fragments.
</bodyText>
<subsectionHeader confidence="0.999152">
5.2 Proof Sketch
</subsectionHeader>
<bodyText confidence="0.989527869565217">
We show that smallest-first removal of fragments is
optimal. Consider a decision point at which a choice
is made about which fragment to remove. Call the
size of the smallest fragments at this point m, and let
the set of fragments of size m be X with α, β E X.
There are two cases to consider. First, consider
two partially overlapped fragments α E X and
δ E/ X. Note that |links(α) |&lt; |links(δ)|. Valid-
ity preservation of α with respect to δ guarantees
that δ or its validity preserving analog will still be
available for excision after α is removed. Excising
δ increases k more than excising α or any fragment
that removal of α will lead to before δ is considered.
Thus, removal of δ cannot result in a smaller value
for k if it is removed before α rather than after α.
Second, consider two partially overlapped frag-
ments α, β E X. Due to the validity preservation
lemma, we may choose arbitrarily between the frag-
ments in X without jeopardizing our ability to later
remove other fragments (or their validity preserving
analogs) in that set. Removal of fragment α cannot
increase the size of any remaining fragment.
Removal of α or β may generate new fragments
Figure 11: Removal from a tree pair γ containing a type
1&apos;–type 3 (reversed) fragment overlap. The fragment α is
represented by the horizontal lined pieces of the tree pair.
The fragment β is represented by the vertical-lined pieces
of the tree pair. Cross-hatching indicates the overlapping
portion of the two fragments.
that were not previously valid and may reduce the
size of existing fragments that it overlaps. In addi-
tion, removal of α may lead to availability of smaller
fragments at the next removal step than removal of β
(and vice versa). However, since removal of either α
or β produces a k of size at least m, the later removal
of fragments of size less than m cannot affect the k
found by the algorithm. Due to validity preservation,
removal of any of these smaller fragments will still
permit removal of all currently existing fragments or
their analogs at a later step in the removal process.
If the removal of α generates a new fragment δ of
size larger than m all remaining fragments in X (and
all others smaller than δ) will be removed before δ
is considered. Therefore, if removal of β generates a
new fragment smaller than δ, the smallest-first strat-
egy will properly guarantee its removal before δ.
</bodyText>
<sectionHeader confidence="0.999384" genericHeader="conclusions">
6 Conclusion
</sectionHeader>
<bodyText confidence="0.999983785714286">
In order for STAG to be used in machine translation
and other natural-language processing tasks it must
be possible to process it efficiently. The difficulty in
parsing STAG stems directly from the factor k that
indicates the degree to which the correspondences
are intertwined within the elementary structures of
the grammar. The algorithm presented in this pa-
per is the first method available for k-arizing a syn-
chronous TAG grammar into an equivalent grammar
with an optimal value for k. The algorithm operates
offline and requires only O(|G |+ |Y  |� LG) time.
Both the derivation trees and derived trees produced
are trivially homomorphic to those that are produced
by the original grammar.
</bodyText>
<equation confidence="0.666285416666667">
ni :A n4 :D ni :A
n4 :D nl :A
C
n6 :
n5 :
E
n3 :
x
K x
G
n3 :
C n6 : n7 :
</equation>
<figure confidence="0.9457725">
F G
I
F
n2 :
B
n7 :
n8 :
J↓
x
remove α
remove fl
D
n4 :
IIx n5 :E
B
n2 :
</figure>
<page confidence="0.987768">
611
</page>
<sectionHeader confidence="0.997516" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.998004549295775">
Aho, Alfred V. and Jeffrey D. Ullman. 1969. Syntax di-
rected translations and the pushdown assembler. Jour-
nal of Computer and System Sciences, 3(1):37–56.
Chiang, David and Owen Rambow. 2006. The hid-
den TAG model: synchronous grammars for parsing
resource-poor languages. In Proceedings of the 8th
International Workshop on Tree Adjoining Grammars
and Related Formalisms (TAG+ 8), pages 1–8.
Gildea, Daniel, Giorgio Satta, and Hao Zhang. 2006.
Factoring synchronous grammars by sorting. In Pro-
ceedings of the International Conference on Compu-
tational Linguistics and the Association for Computa-
tional Linguistics (COLING/ACL-06), July.
Han, Chung-Hye. 2006a. Pied-piping in relative clauses:
Syntax and compositional semantics based on syn-
chronous tree adjoining grammar. In Proceedings
of the 8th International Workshop on Tree Adjoining
Grammars and Related Formalisms (TAG+ 8), pages
41–48, Sydney, Australia.
Han, Chung-Hye. 2006b. A tree adjoining grammar
analysis of the syntax and semantics of it-clefts. In
Proceedings of the 8th International Workshop on Tree
Adjoining Grammars and Related Formalisms (TAG+
8), pages 33–40, Sydney, Australia.
Joshi, Aravind K. and Yves Schabes. 1997. Tree-
adjoining grammars. In G. Rozenberg and A. Sa-
lomaa, editors, Handbook of Formal Languages.
Springer, pages 69–124.
Nesson, Rebecca and Stuart M. Shieber. 2006. Sim-
pler TAG semantics through synchronization. In Pro-
ceedings of the 11th Conference on Formal Grammar,
Malaga, Spain, 29–30 July.
Nesson, Rebecca and Stuart M. Shieber. 2007. Extrac-
tion phenomena in synchronous TAG syntax and se-
mantics. In Proceedings of Syntax and Structure in
Statistical Translation (SSST), Rochester, NY, April.
Nesson, Rebecca, Stuart M. Shieber, and Alexander
Rush. 2006. Induction of probabilistic synchronous
tree-insertion grammars for machine translation. In
Proceedings of the 7th Conference of the Associa-
tion for Machine Translation in the Americas (AMTA
2006), Boston, Massachusetts, 8-12 August.
Satta, Giorgio. 1992. Recognition of linear context-free
rewriting systems. In Proceedings of the 10th Meet-
ing of the Association for Computational Linguistics
(ACL92), pages 89–95, Newark, Delaware.
Seki, H., T. Matsumura, M. Fujii, and T. Kasami. 1991.
On multiple context-free grammars. Theoretical Com-
puter Science, 88:191–229.
Shieber, Stuart M. 1994. Restricting the weak-generative
capacity of synchronous tree-adjoining grammars.
Computational Intelligence, 10(4):371–385, Novem-
ber.
Shieber, Stuart M. and Yves Schabes. 1990. Syn-
chronous tree adjoining grammars. In Proceedings of
the 13th International Conference on Computational
Linguistics (COLING ’90), Helsinki, August.
Weir, David. 1988. Characterizing mildly context-
sensitive grammar formalisms. PhD Thesis, Depart-
ment of Computer and Information Science, Univer-
sity of Pennsylvania.
Zhang, Hao and Daniel Gildea. 2007. Factorization of
synchronous context-free grammars in linear time. In
NAACL Workshop on Syntax and Structure in Statisti-
cal Translation (SSST), April.
Zhang, Hao, Liang Huang, Daniel Gildea, and Kevin
Knight. 2006. Synchronous binarization for ma-
chine translation. In Proceedings of the Human Lan-
guage Technology Conference/North American Chap-
ter of the Association for Computational Linguistics
(HLT/NAACL).
</reference>
<page confidence="0.997439">
612
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.635110">
<title confidence="0.999284">of Synchronous Tree-Adjoining Grammar</title>
<author confidence="0.997341">Rebecca Nesson</author>
<affiliation confidence="0.995816666666667">School of Engineering and Applied Sciences Harvard University</affiliation>
<address confidence="0.99999">Cambridge, MA 02138</address>
<email confidence="0.999643">nesson@seas.harvard.edu</email>
<author confidence="0.999835">Giorgio Satta</author>
<affiliation confidence="0.998886">Department of Information Engineering University of Padua</affiliation>
<address confidence="0.999653">I-35131 Padova, Italy</address>
<email confidence="0.998726">satta@dei.unipd.it</email>
<author confidence="0.999976">Stuart M Shieber</author>
<affiliation confidence="0.995934333333333">School of Engineering and Applied Sciences Harvard University</affiliation>
<address confidence="0.999989">Cambridge, MA 02138</address>
<email confidence="0.999878">shieber@seas.harvard.edu</email>
<abstract confidence="0.98524772">Synchronous Tree-Adjoining Grammar (STAG) is a promising formalism for syntaxaware machine translation and simultaneous computation of natural-language syntax and semantics. Current research in both of these areas is actively pursuing its incorporation. However, STAG parsing is known to be NP-hard due to the potential for intertwined correspondences between the linked nonterminal symbols in the elementary structures. Given a particular grammar, the polynomial degree of efficient STAG parsing algorithms directly on the the grammar: the maximum number of correspondences that appear within a single elementary structure. In this paper we present a compile-time algorithm for transforming a STAG into a strongly-equivalent STAG that optimally the rank, across the grammar. algorithm performs in · where the maximum number of links in any single synchronous tree pair in grammar and the set of synchronous pairs of</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Alfred V Aho</author>
<author>Jeffrey D Ullman</author>
</authors>
<title>Syntax directed translations and the pushdown assembler.</title>
<date>1969</date>
<journal>Journal of Computer and System Sciences,</journal>
<volume>3</volume>
<issue>1</issue>
<contexts>
<context position="3325" citStr="Aho and Ullman, 1969" startWordPosition="496" endWordPosition="499">omial degree of efficient STAG parsing algorithms depends directly on the rank of the grammar: the maximum number of correspondences that appear within a single elementary structure. This is illustrated by the tree pairs given in Figure 1 in which no two numbered links may be isolated. (By “isolated”, we mean that the links can be contained in a fragment of the tree that contains no other links and dominates only one branch not contained in the fragment. A precise definition is given in section 3.) An analogous problem has long been known to exist for synchronous context-free grammars (SCFG) (Aho and Ullman, 1969). The task of producing efficient parsers for SCFG has recently been addressed by binarization or k-arization of SCFG grammars that produce equivalent grammars in which the rank, k, has been minimized (Zhang 604 Proceedings ofACL-08: HLT, pages 604–612, Columbus, Ohio, USA, June 2008. c�2008 Association for Computational Linguistics γ1 : γ2 : A 1 A γ3 : 2 D1 E F G 2 3 4 D2 E F G 4 1 3 W x y z w B C A B C A B 2 B C 3 C D4 D w/ 4 3 1 B C 3 4 D 1 W x w/ A5 A E 2 B C 2 D3 E4 5 1 Figure 1: Example of intertwined links that cannot be binarized. No two links can be isolated in both trees in a tree pa</context>
</contexts>
<marker>Aho, Ullman, 1969</marker>
<rawString>Aho, Alfred V. and Jeffrey D. Ullman. 1969. Syntax directed translations and the pushdown assembler. Journal of Computer and System Sciences, 3(1):37–56.</rawString>
</citation>
<citation valid="true">
<authors>
<author>David Chiang</author>
<author>Owen Rambow</author>
</authors>
<title>The hidden TAG model: synchronous grammars for parsing resource-poor languages.</title>
<date>2006</date>
<booktitle>In Proceedings of the 8th International Workshop on Tree Adjoining Grammars and Related Formalisms (TAG+ 8),</booktitle>
<pages>1--8</pages>
<contexts>
<context position="2037" citStr="Chiang and Rambow, 2006" startWordPosition="282" endWordPosition="285">s of G. 1 Introduction Tree-adjoining grammar is a widely used formalism in natural-language processing due to its mildlycontext-sensitive expressivity, its ability to naturally capture natural-language argument substitution (via its substitution operation) and optional modification (via its adjunction operation), and the existence of efficient algorithms for processing it. Recently, the desire to incorporate syntax-awareness into machine translation systems has generated interest in the application of synchronous tree-adjoining grammar (STAG) to this problem (Nesson, Shieber, and Rush, 2006; Chiang and Rambow, 2006). In a parallel development, interest in incorporating semantic computation into the TAG framework has led to the use of STAG for this purpose (Nesson and Shieber, 2007; Han, 2006b; Han, 2006a; Nesson and Shieber, 2006). Although STAG does not increase the expressivity of the underlying formalisms (Shieber, 1994), STAG parsing is known to be NPhard due to the potential for intertwined correspondences between the linked nonterminal symbols in the elementary structures (Satta, 1992; Weir, 1988). Without efficient algorithms for processing it, its potential for use in machine translation and TAG </context>
</contexts>
<marker>Chiang, Rambow, 2006</marker>
<rawString>Chiang, David and Owen Rambow. 2006. The hidden TAG model: synchronous grammars for parsing resource-poor languages. In Proceedings of the 8th International Workshop on Tree Adjoining Grammars and Related Formalisms (TAG+ 8), pages 1–8.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Daniel Gildea</author>
<author>Giorgio Satta</author>
<author>Hao Zhang</author>
</authors>
<title>Factoring synchronous grammars by sorting.</title>
<date>2006</date>
<booktitle>In Proceedings of the International Conference on Computational Linguistics and the Association for Computational Linguistics (COLING/ACL-06),</booktitle>
<contexts>
<context position="4752" citStr="Gildea, Satta, and Zhang, 2006" startWordPosition="809" endWordPosition="813">ated. Figure 2: An example STAG derivation of the English/French sentence pair “John likes red candies”/“Jean aime les bonbons rouges”. The figure is divided as follows: (a) the STAG grammar, (b) the derivation tree for the sentence pair, and (c) the derived tree pair for the sentences. (a) S S (b) likes (e) NPI 1 V P NPI 1 Adj N. N. red rouges candies N V likes V P NPI2 V NPI N Adj aime NP N 1 2 Det les bonbons NP John candies N 1 2 1 NP NP John Jean red 1 NP V P John V likes S Adj red NP N candies N Jean S NP V P aime V Det les bonbons NP N N Adj rouges and Gildea, 2007; Zhang et al., 2006; Gildea, Satta, and Zhang, 2006). The methods for k-arization of SCFG cannot be directly applied to STAG because of the additional complexity introduced by the expressivity-increasing adjunction operation of TAG. In SCFG, where substitution is the only available operation and the depth of elementary structures is limited to one, the k-arization problem reduces to analysis of permutations of strings of nonterminal symbols. In STAG, however, the arbitrary depth of the elementary structures and the lack of restriction to contiguous strings of nonterminals introduced by adjunction substantially complicate the task. In this pape</context>
</contexts>
<marker>Gildea, Satta, Zhang, 2006</marker>
<rawString>Gildea, Daniel, Giorgio Satta, and Hao Zhang. 2006. Factoring synchronous grammars by sorting. In Proceedings of the International Conference on Computational Linguistics and the Association for Computational Linguistics (COLING/ACL-06), July.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Chung-Hye Han</author>
</authors>
<title>Pied-piping in relative clauses: Syntax and compositional semantics based on synchronous tree adjoining grammar.</title>
<date>2006</date>
<booktitle>In Proceedings of the 8th International Workshop on Tree Adjoining Grammars and Related Formalisms (TAG+ 8),</booktitle>
<pages>41--48</pages>
<location>Sydney, Australia.</location>
<contexts>
<context position="2216" citStr="Han, 2006" startWordPosition="315" endWordPosition="316">language argument substitution (via its substitution operation) and optional modification (via its adjunction operation), and the existence of efficient algorithms for processing it. Recently, the desire to incorporate syntax-awareness into machine translation systems has generated interest in the application of synchronous tree-adjoining grammar (STAG) to this problem (Nesson, Shieber, and Rush, 2006; Chiang and Rambow, 2006). In a parallel development, interest in incorporating semantic computation into the TAG framework has led to the use of STAG for this purpose (Nesson and Shieber, 2007; Han, 2006b; Han, 2006a; Nesson and Shieber, 2006). Although STAG does not increase the expressivity of the underlying formalisms (Shieber, 1994), STAG parsing is known to be NPhard due to the potential for intertwined correspondences between the linked nonterminal symbols in the elementary structures (Satta, 1992; Weir, 1988). Without efficient algorithms for processing it, its potential for use in machine translation and TAG semantics systems is limited. Given a particular grammar, the polynomial degree of efficient STAG parsing algorithms depends directly on the rank of the grammar: the maximum numbe</context>
</contexts>
<marker>Han, 2006</marker>
<rawString>Han, Chung-Hye. 2006a. Pied-piping in relative clauses: Syntax and compositional semantics based on synchronous tree adjoining grammar. In Proceedings of the 8th International Workshop on Tree Adjoining Grammars and Related Formalisms (TAG+ 8), pages 41–48, Sydney, Australia.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Chung-Hye Han</author>
</authors>
<title>A tree adjoining grammar analysis of the syntax and semantics of it-clefts.</title>
<date>2006</date>
<booktitle>In Proceedings of the 8th International Workshop on Tree Adjoining Grammars and Related Formalisms (TAG+ 8),</booktitle>
<pages>33--40</pages>
<location>Sydney, Australia.</location>
<contexts>
<context position="2216" citStr="Han, 2006" startWordPosition="315" endWordPosition="316">language argument substitution (via its substitution operation) and optional modification (via its adjunction operation), and the existence of efficient algorithms for processing it. Recently, the desire to incorporate syntax-awareness into machine translation systems has generated interest in the application of synchronous tree-adjoining grammar (STAG) to this problem (Nesson, Shieber, and Rush, 2006; Chiang and Rambow, 2006). In a parallel development, interest in incorporating semantic computation into the TAG framework has led to the use of STAG for this purpose (Nesson and Shieber, 2007; Han, 2006b; Han, 2006a; Nesson and Shieber, 2006). Although STAG does not increase the expressivity of the underlying formalisms (Shieber, 1994), STAG parsing is known to be NPhard due to the potential for intertwined correspondences between the linked nonterminal symbols in the elementary structures (Satta, 1992; Weir, 1988). Without efficient algorithms for processing it, its potential for use in machine translation and TAG semantics systems is limited. Given a particular grammar, the polynomial degree of efficient STAG parsing algorithms depends directly on the rank of the grammar: the maximum numbe</context>
</contexts>
<marker>Han, 2006</marker>
<rawString>Han, Chung-Hye. 2006b. A tree adjoining grammar analysis of the syntax and semantics of it-clefts. In Proceedings of the 8th International Workshop on Tree Adjoining Grammars and Related Formalisms (TAG+ 8), pages 33–40, Sydney, Australia.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Aravind K Joshi</author>
<author>Yves Schabes</author>
</authors>
<title>Treeadjoining grammars.</title>
<date>1997</date>
<booktitle>Handbook of Formal Languages.</booktitle>
<pages>69--124</pages>
<editor>In G. Rozenberg and A. Salomaa, editors,</editor>
<publisher>Springer,</publisher>
<contexts>
<context position="7863" citStr="Joshi and Schabes (1997)" startWordPosition="1352" endWordPosition="1355">h, which are combined by substitution, familiar from contextfree grammars, or an operation of adjunction that is particular to the TAG formalism. Auxiliary trees are elementary trees in which the root and a frontier node, called the foot node and distinguished by the diacritic *, are labeled with the same nonterminal A. The adjunction operation involves splicing an auxiliary tree in at an internal node in an elementary tree also labeled with nonterminal A. Trees without a foot node, which serve as a base for derivations, are called initial trees. For further background, refer to the survey by Joshi and Schabes (1997). We depart from the traditional definition in notation only by specifying adjunction and substitution sites explicitly with numbered links. Each link may be used only once in a derivation. Operations may only occur at nodes marked with a link. For simplicity of presentation we provisionally assume that only one link is permitted at a node. We later drop this assumption. In a synchronous TAG (STAG) the elementary structures are ordered pairs of TAG trees, with a linking relation specified over pairs of nonterminal nodes. Each link has two locations, one in the left tree in a pair and the other</context>
</contexts>
<marker>Joshi, Schabes, 1997</marker>
<rawString>Joshi, Aravind K. and Yves Schabes. 1997. Treeadjoining grammars. In G. Rozenberg and A. Salomaa, editors, Handbook of Formal Languages. Springer, pages 69–124.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Rebecca Nesson</author>
<author>Stuart M Shieber</author>
</authors>
<title>Simpler TAG semantics through synchronization.</title>
<date>2006</date>
<booktitle>In Proceedings of the 11th Conference on Formal Grammar,</booktitle>
<location>Malaga,</location>
<contexts>
<context position="2256" citStr="Nesson and Shieber, 2006" startWordPosition="319" endWordPosition="322">tution (via its substitution operation) and optional modification (via its adjunction operation), and the existence of efficient algorithms for processing it. Recently, the desire to incorporate syntax-awareness into machine translation systems has generated interest in the application of synchronous tree-adjoining grammar (STAG) to this problem (Nesson, Shieber, and Rush, 2006; Chiang and Rambow, 2006). In a parallel development, interest in incorporating semantic computation into the TAG framework has led to the use of STAG for this purpose (Nesson and Shieber, 2007; Han, 2006b; Han, 2006a; Nesson and Shieber, 2006). Although STAG does not increase the expressivity of the underlying formalisms (Shieber, 1994), STAG parsing is known to be NPhard due to the potential for intertwined correspondences between the linked nonterminal symbols in the elementary structures (Satta, 1992; Weir, 1988). Without efficient algorithms for processing it, its potential for use in machine translation and TAG semantics systems is limited. Given a particular grammar, the polynomial degree of efficient STAG parsing algorithms depends directly on the rank of the grammar: the maximum number of correspondences that appear within </context>
</contexts>
<marker>Nesson, Shieber, 2006</marker>
<rawString>Nesson, Rebecca and Stuart M. Shieber. 2006. Simpler TAG semantics through synchronization. In Proceedings of the 11th Conference on Formal Grammar, Malaga, Spain, 29–30 July.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Rebecca Nesson</author>
<author>Stuart M Shieber</author>
</authors>
<title>Extraction phenomena in synchronous TAG syntax and semantics.</title>
<date>2007</date>
<booktitle>In Proceedings of Syntax and Structure in Statistical Translation (SSST),</booktitle>
<location>Rochester, NY,</location>
<contexts>
<context position="2205" citStr="Nesson and Shieber, 2007" startWordPosition="311" endWordPosition="314">naturally capture natural-language argument substitution (via its substitution operation) and optional modification (via its adjunction operation), and the existence of efficient algorithms for processing it. Recently, the desire to incorporate syntax-awareness into machine translation systems has generated interest in the application of synchronous tree-adjoining grammar (STAG) to this problem (Nesson, Shieber, and Rush, 2006; Chiang and Rambow, 2006). In a parallel development, interest in incorporating semantic computation into the TAG framework has led to the use of STAG for this purpose (Nesson and Shieber, 2007; Han, 2006b; Han, 2006a; Nesson and Shieber, 2006). Although STAG does not increase the expressivity of the underlying formalisms (Shieber, 1994), STAG parsing is known to be NPhard due to the potential for intertwined correspondences between the linked nonterminal symbols in the elementary structures (Satta, 1992; Weir, 1988). Without efficient algorithms for processing it, its potential for use in machine translation and TAG semantics systems is limited. Given a particular grammar, the polynomial degree of efficient STAG parsing algorithms depends directly on the rank of the grammar: the ma</context>
</contexts>
<marker>Nesson, Shieber, 2007</marker>
<rawString>Nesson, Rebecca and Stuart M. Shieber. 2007. Extraction phenomena in synchronous TAG syntax and semantics. In Proceedings of Syntax and Structure in Statistical Translation (SSST), Rochester, NY, April.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Rebecca Nesson</author>
<author>Stuart M Shieber</author>
<author>Alexander Rush</author>
</authors>
<title>Induction of probabilistic synchronous tree-insertion grammars for machine translation.</title>
<date>2006</date>
<booktitle>In Proceedings of the 7th Conference of the Association for Machine Translation in the Americas (AMTA 2006),</booktitle>
<location>Boston, Massachusetts,</location>
<contexts>
<context position="2011" citStr="Nesson, Shieber, and Rush, 2006" startWordPosition="277" endWordPosition="281"> the set of synchronous tree pairs of G. 1 Introduction Tree-adjoining grammar is a widely used formalism in natural-language processing due to its mildlycontext-sensitive expressivity, its ability to naturally capture natural-language argument substitution (via its substitution operation) and optional modification (via its adjunction operation), and the existence of efficient algorithms for processing it. Recently, the desire to incorporate syntax-awareness into machine translation systems has generated interest in the application of synchronous tree-adjoining grammar (STAG) to this problem (Nesson, Shieber, and Rush, 2006; Chiang and Rambow, 2006). In a parallel development, interest in incorporating semantic computation into the TAG framework has led to the use of STAG for this purpose (Nesson and Shieber, 2007; Han, 2006b; Han, 2006a; Nesson and Shieber, 2006). Although STAG does not increase the expressivity of the underlying formalisms (Shieber, 1994), STAG parsing is known to be NPhard due to the potential for intertwined correspondences between the linked nonterminal symbols in the elementary structures (Satta, 1992; Weir, 1988). Without efficient algorithms for processing it, its potential for use in ma</context>
</contexts>
<marker>Nesson, Shieber, Rush, 2006</marker>
<rawString>Nesson, Rebecca, Stuart M. Shieber, and Alexander Rush. 2006. Induction of probabilistic synchronous tree-insertion grammars for machine translation. In Proceedings of the 7th Conference of the Association for Machine Translation in the Americas (AMTA 2006), Boston, Massachusetts, 8-12 August.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Giorgio Satta</author>
</authors>
<title>Recognition of linear context-free rewriting systems.</title>
<date>1992</date>
<booktitle>In Proceedings of the 10th Meeting of the Association for Computational Linguistics (ACL92),</booktitle>
<pages>89--95</pages>
<location>Newark, Delaware.</location>
<contexts>
<context position="2521" citStr="Satta, 1992" startWordPosition="362" endWordPosition="363">ication of synchronous tree-adjoining grammar (STAG) to this problem (Nesson, Shieber, and Rush, 2006; Chiang and Rambow, 2006). In a parallel development, interest in incorporating semantic computation into the TAG framework has led to the use of STAG for this purpose (Nesson and Shieber, 2007; Han, 2006b; Han, 2006a; Nesson and Shieber, 2006). Although STAG does not increase the expressivity of the underlying formalisms (Shieber, 1994), STAG parsing is known to be NPhard due to the potential for intertwined correspondences between the linked nonterminal symbols in the elementary structures (Satta, 1992; Weir, 1988). Without efficient algorithms for processing it, its potential for use in machine translation and TAG semantics systems is limited. Given a particular grammar, the polynomial degree of efficient STAG parsing algorithms depends directly on the rank of the grammar: the maximum number of correspondences that appear within a single elementary structure. This is illustrated by the tree pairs given in Figure 1 in which no two numbered links may be isolated. (By “isolated”, we mean that the links can be contained in a fragment of the tree that contains no other links and dominates only </context>
</contexts>
<marker>Satta, 1992</marker>
<rawString>Satta, Giorgio. 1992. Recognition of linear context-free rewriting systems. In Proceedings of the 10th Meeting of the Association for Computational Linguistics (ACL92), pages 89–95, Newark, Delaware.</rawString>
</citation>
<citation valid="true">
<authors>
<author>H Seki</author>
<author>T Matsumura</author>
<author>M Fujii</author>
<author>T Kasami</author>
</authors>
<title>On multiple context-free grammars.</title>
<date>1991</date>
<journal>Theoretical Computer Science,</journal>
<pages>88--191</pages>
<contexts>
<context position="5758" citStr="Seki et al. (1991)" startWordPosition="972" endWordPosition="975">mbols. In STAG, however, the arbitrary depth of the elementary structures and the lack of restriction to contiguous strings of nonterminals introduced by adjunction substantially complicate the task. In this paper we offer the first algorithm addressing this problem for the STAG case. We present a compile-time algorithm for transforming a STAG into a strongly-equivalent STAG that optimally minimizes k across the grammar. This is a critical minimization because k is the feature of the grammar that appears in the exponent of the complexity of parsing algorithms for STAG. Following the method of Seki et al. (1991), an STAG parser can be implemented with complexity O(n4·(k+1) |G|). By minimizing k, the worst-case complexity of a parser instantiated for a particular grammar is optimized. The k3 arization algorithm performs in O ( |G |+ |Y |LG) time where LG is the maximum number of links in any single synchronous tree pair in the grammar and Y is the set of synchronous tree pairs of G. By comparison, a baseline algorithm performing exhaustive search requires O(|G |+ |Y |LG) time.1 The remainder of the paper proceeds as follows. In section 2 we provide a brief introduction to the STAG formalism. We presen</context>
</contexts>
<marker>Seki, Matsumura, Fujii, Kasami, 1991</marker>
<rawString>Seki, H., T. Matsumura, M. Fujii, and T. Kasami. 1991. On multiple context-free grammars. Theoretical Computer Science, 88:191–229.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Stuart M Shieber</author>
</authors>
<title>Restricting the weak-generative capacity of synchronous tree-adjoining grammars.</title>
<date>1994</date>
<journal>Computational Intelligence,</journal>
<volume>10</volume>
<issue>4</issue>
<contexts>
<context position="2351" citStr="Shieber, 1994" startWordPosition="335" endWordPosition="336">existence of efficient algorithms for processing it. Recently, the desire to incorporate syntax-awareness into machine translation systems has generated interest in the application of synchronous tree-adjoining grammar (STAG) to this problem (Nesson, Shieber, and Rush, 2006; Chiang and Rambow, 2006). In a parallel development, interest in incorporating semantic computation into the TAG framework has led to the use of STAG for this purpose (Nesson and Shieber, 2007; Han, 2006b; Han, 2006a; Nesson and Shieber, 2006). Although STAG does not increase the expressivity of the underlying formalisms (Shieber, 1994), STAG parsing is known to be NPhard due to the potential for intertwined correspondences between the linked nonterminal symbols in the elementary structures (Satta, 1992; Weir, 1988). Without efficient algorithms for processing it, its potential for use in machine translation and TAG semantics systems is limited. Given a particular grammar, the polynomial degree of efficient STAG parsing algorithms depends directly on the rank of the grammar: the maximum number of correspondences that appear within a single elementary structure. This is illustrated by the tree pairs given in Figure 1 in which</context>
<context position="8671" citStr="Shieber (1994)" startWordPosition="1494" endWordPosition="1495">ations may only occur at nodes marked with a link. For simplicity of presentation we provisionally assume that only one link is permitted at a node. We later drop this assumption. In a synchronous TAG (STAG) the elementary structures are ordered pairs of TAG trees, with a linking relation specified over pairs of nonterminal nodes. Each link has two locations, one in the left tree in a pair and the other in the right tree. An example of an STAG derivation including both substitution and adjunction is given in Figure 2. For further background, refer to the work of Shieber and Schabes (1990) and Shieber (1994). 3 k-arization Algorithm For a synchronous tree pair γ = (γL, γR), a fragment of γL (or γR) is a complete subtree rooted at some node n of γL, written γL(n), or else a subtree rooted at n with a gap at node n&apos;, written γL(n, n&apos;); see Figure 3 for an example. We write links(n) and links(n, n&apos;) to denote the set of links of γL(n) and γL(n, n&apos;), respectively. When we do not know the root or gap nodes of some fragment αL, we also write links(αL). We say that a set of links A from γ can be isolated if there exist fragments αL and αR of γL and γR, respectively, both with links A. If this is the cas</context>
</contexts>
<marker>Shieber, 1994</marker>
<rawString>Shieber, Stuart M. 1994. Restricting the weak-generative capacity of synchronous tree-adjoining grammars. Computational Intelligence, 10(4):371–385, November.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Stuart M Shieber</author>
<author>Yves Schabes</author>
</authors>
<title>Synchronous tree adjoining grammars.</title>
<date>1990</date>
<booktitle>In Proceedings of the 13th International Conference on Computational Linguistics (COLING ’90),</booktitle>
<location>Helsinki,</location>
<contexts>
<context position="8652" citStr="Shieber and Schabes (1990)" startWordPosition="1489" endWordPosition="1492">only once in a derivation. Operations may only occur at nodes marked with a link. For simplicity of presentation we provisionally assume that only one link is permitted at a node. We later drop this assumption. In a synchronous TAG (STAG) the elementary structures are ordered pairs of TAG trees, with a linking relation specified over pairs of nonterminal nodes. Each link has two locations, one in the left tree in a pair and the other in the right tree. An example of an STAG derivation including both substitution and adjunction is given in Figure 2. For further background, refer to the work of Shieber and Schabes (1990) and Shieber (1994). 3 k-arization Algorithm For a synchronous tree pair γ = (γL, γR), a fragment of γL (or γR) is a complete subtree rooted at some node n of γL, written γL(n), or else a subtree rooted at n with a gap at node n&apos;, written γL(n, n&apos;); see Figure 3 for an example. We write links(n) and links(n, n&apos;) to denote the set of links of γL(n) and γL(n, n&apos;), respectively. When we do not know the root or gap nodes of some fragment αL, we also write links(αL). We say that a set of links A from γ can be isolated if there exist fragments αL and αR of γL and γR, respectively, both with links A.</context>
</contexts>
<marker>Shieber, Schabes, 1990</marker>
<rawString>Shieber, Stuart M. and Yves Schabes. 1990. Synchronous tree adjoining grammars. In Proceedings of the 13th International Conference on Computational Linguistics (COLING ’90), Helsinki, August.</rawString>
</citation>
<citation valid="true">
<authors>
<author>David Weir</author>
</authors>
<title>Characterizing mildly contextsensitive grammar formalisms.</title>
<date>1988</date>
<tech>PhD Thesis,</tech>
<institution>Department of Computer and Information Science, University of Pennsylvania.</institution>
<contexts>
<context position="2534" citStr="Weir, 1988" startWordPosition="364" endWordPosition="365">nchronous tree-adjoining grammar (STAG) to this problem (Nesson, Shieber, and Rush, 2006; Chiang and Rambow, 2006). In a parallel development, interest in incorporating semantic computation into the TAG framework has led to the use of STAG for this purpose (Nesson and Shieber, 2007; Han, 2006b; Han, 2006a; Nesson and Shieber, 2006). Although STAG does not increase the expressivity of the underlying formalisms (Shieber, 1994), STAG parsing is known to be NPhard due to the potential for intertwined correspondences between the linked nonterminal symbols in the elementary structures (Satta, 1992; Weir, 1988). Without efficient algorithms for processing it, its potential for use in machine translation and TAG semantics systems is limited. Given a particular grammar, the polynomial degree of efficient STAG parsing algorithms depends directly on the rank of the grammar: the maximum number of correspondences that appear within a single elementary structure. This is illustrated by the tree pairs given in Figure 1 in which no two numbered links may be isolated. (By “isolated”, we mean that the links can be contained in a fragment of the tree that contains no other links and dominates only one branch no</context>
</contexts>
<marker>Weir, 1988</marker>
<rawString>Weir, David. 1988. Characterizing mildly contextsensitive grammar formalisms. PhD Thesis, Department of Computer and Information Science, University of Pennsylvania.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Hao Zhang</author>
<author>Daniel Gildea</author>
</authors>
<title>Factorization of synchronous context-free grammars in linear time.</title>
<date>2007</date>
<booktitle>In NAACL Workshop on Syntax and Structure in Statistical Translation (SSST),</booktitle>
<marker>Zhang, Gildea, 2007</marker>
<rawString>Zhang, Hao and Daniel Gildea. 2007. Factorization of synchronous context-free grammars in linear time. In NAACL Workshop on Syntax and Structure in Statistical Translation (SSST), April.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Hao Zhang</author>
<author>Liang Huang</author>
<author>Daniel Gildea</author>
<author>Kevin Knight</author>
</authors>
<title>Synchronous binarization for machine translation.</title>
<date>2006</date>
<booktitle>In Proceedings of the Human Language Technology Conference/North American Chapter of the Association for Computational Linguistics (HLT/NAACL).</booktitle>
<contexts>
<context position="4720" citStr="Zhang et al., 2006" startWordPosition="805" endWordPosition="808">han four may be isolated. Figure 2: An example STAG derivation of the English/French sentence pair “John likes red candies”/“Jean aime les bonbons rouges”. The figure is divided as follows: (a) the STAG grammar, (b) the derivation tree for the sentence pair, and (c) the derived tree pair for the sentences. (a) S S (b) likes (e) NPI 1 V P NPI 1 Adj N. N. red rouges candies N V likes V P NPI2 V NPI N Adj aime NP N 1 2 Det les bonbons NP John candies N 1 2 1 NP NP John Jean red 1 NP V P John V likes S Adj red NP N candies N Jean S NP V P aime V Det les bonbons NP N N Adj rouges and Gildea, 2007; Zhang et al., 2006; Gildea, Satta, and Zhang, 2006). The methods for k-arization of SCFG cannot be directly applied to STAG because of the additional complexity introduced by the expressivity-increasing adjunction operation of TAG. In SCFG, where substitution is the only available operation and the depth of elementary structures is limited to one, the k-arization problem reduces to analysis of permutations of strings of nonterminal symbols. In STAG, however, the arbitrary depth of the elementary structures and the lack of restriction to contiguous strings of nonterminals introduced by adjunction substantially c</context>
</contexts>
<marker>Zhang, Huang, Gildea, Knight, 2006</marker>
<rawString>Zhang, Hao, Liang Huang, Daniel Gildea, and Kevin Knight. 2006. Synchronous binarization for machine translation. In Proceedings of the Human Language Technology Conference/North American Chapter of the Association for Computational Linguistics (HLT/NAACL).</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>