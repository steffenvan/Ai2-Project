<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<title confidence="0.763043">
AN ALGORITHM FOR GENERATING QUANTIFIER SCOPINGS
</title>
<author confidence="0.698229">
Jerry R. Hobbs and Stuart M. Shieber
</author>
<sectionHeader confidence="0.909180333333333" genericHeader="method">
Artificial Intelligence Center
SRI International
Menlo Park, CA 94025
</sectionHeader>
<bodyText confidence="0.912056405405405">
and
Center for the Study of Language and Information
Stanford University
Stanford, CA 94305
The syntactic structure of a sentence often manifests quite clearly the predicate-argument structure and
relations of grammatical subordination. But scope dependencies are not so transparent. As a result, many
systems for representing the semantics of sentences have ignored scoping or generated scopings with
mechanisms that have often been inexplicit as to the range of scopings they choose among or profligate in
the scopings they allow.
This paper presents, along with proofs of some of its important properties, an algorithm that generates
scoped semantic forms from unscoped expressions encoding predicate-argument structure. The algorithm
is not profligate as are those based on permutation of quantifiers, and it can provide a solid foundation for
computational solutions where completeness is sacrificed for efficiency and heuristic efficacy.
1 INTRODUCTION present an algorithm that generates quantifier scopings
for English sentences.
A principal focus of computational linguistics, as a
branch of computer science, ought to be the design of
algorithms. A large number of algorithms have undoubt-
edly been devised for dealing with problems every
researcher has to face in constructing a natural language
system, but they simply have not received wide circu-
lation. These algorithms are part of the &amp;quot;folk culture&amp;quot;,
buried in the most technical, unreadable portions of thes-
es, passed among colleagues informally at best, and often
reinvented. It should be a practice to publish these algo-
rithms in isolation, independent of a particular implemen-
tation or system.
This paper constitutes an effort to initiate such a prac-
tice. A problem that many natural-language efforts have
faced is the recovery of implicit semantic scope depend-
ency possibilities — such as those manifest in quantifiers
and modals — from predicate-argument relations and
relations of grammatical subordination, which are more
or less transparently conveyed by the syntactic structure
of sentences. Previous computational efforts typically
have not been based on an explicit notion of the range of
possible scopings. In response to this problem, we
</bodyText>
<subsectionHeader confidence="0.977071">
1.1 THE PROBLEM OF GENERATING QUANTIFIER SCOPINGS
</subsectionHeader>
<bodyText confidence="0.9997035">
The naive algorithm for generating quantifier scopings is
to generate all permutations of the quantifiers. For a
sentence with n quantified noun phrases this will gener-
ate n! different readings. But for the sentence
</bodyText>
<listItem confidence="0.9760845">
(1) Every representative of a company saw most
samples.
</listItem>
<bodyText confidence="0.958508444444444">
there are not six different readings, but only five. The
reading that is missing is the one in which most samples is
outscoped by every representative but outscopes a compa-
ny. A model for the disallowed reading could include a
different company not only for each representative but
also for each sample.
The reduction in number of readings for a given
sentence is not significant for sentence (1), but in the
sentence
</bodyText>
<listItem confidence="0.637858">
(2) Some representative of every department in most
companies saw a few samples of each product.
</listItem>
<bodyText confidence="0.9905496">
there are only 42 valid readings, as opposed to the 120
readings the naive algorithm would generate, and this
Copyright 1987 by the Association for Computational Linguistics. Permission to copy without fee all or part of this material is granted provided that
the copies are not made for direct commercial advantage and the CL reference and this copyright notice are included on the first page. To. copy
otherwise, or to republish, requires a fee and/or specific permission.
</bodyText>
<page confidence="0.456888">
0362-613X/87/010047-63$03.00
</page>
<note confidence="0.7351355">
Computational Linguistics, Volume 13, Numbers 1-2, January-June 1987 47
Jerry R. Hobbs and Stuart M. Shieber An Algorithm for Generating Quantifier Seopings
</note>
<bodyText confidence="0.968163116883117">
constitutes a significant difference indeed. The recent
trend in computational linguistics has been to view more
and more noun phrases, as well as other constituents, as
introducing quantifiers, so that sentences with this much
quantificational complexity are not at all unusual. (The
immediately preceding sentence, for example, has six or
seven quantifiers.)
This observation of &amp;quot;illegitimate readings&amp;quot; is not
intended as a new or controversial claim about an idio-
syncrasy of English. It accords well with semantic judg-
ments about the possibility of such readings. For
instance, we find it impossible to view sentence (1) as
expressing that for each representative there was a group
of most samples which he saw, and furthermore, for each
sample he saw, there was a company he was a represen-
tative of.
We can find the same problem of illegitimate readings
in the standard account of the &amp;quot;Cooper storage&amp;quot; mech-
anism for generating quantifier scopings (Cooper 1983).
Cooper&apos;s method generates an expression in intensional
logic for the illegitimate readings, but the expression
contains an unbound variable and a vacuous quantifier.&apos;
Finally, the observation follows merely syntactically
from the ill-formedness of certain logical form
expressions. Let us examine why this is so. The proposi-
tional content of a sentence can be seen as combining
specifications that restrict the range of quantified entities,
together with assertions about the entities so specified.
This intuition is often made formal in the use of logical
languages that syntactically separate the notion of the
range of a quantified expression from its scope by placing
the information about the range in a part of the
expression we call the restriction and the assertions in a
part called the body. (Henceforth, we will uniformly use
the terms restriction and body.) The separation of these
two semantic roles of range and scope into restriction
and body as an important fact of the logical structure of
English can be seen, for example, in Woods&apos;s four-part
quantifier structures (Woods 1977), in the recommen-
dations of Moore (1981), and in the generalized quantifi-
er research of Barwise and Cooper and others. The
latter have demonstrated the necessity of such a sepa-
ration for quantifiers other than the standard first-order
ones (Barwise and Cooper, 1981; Cushing, 1976).
But under this understanding of English logical struc-
ture, it follows that no sixth reading exists for sentence
(1) above. Consider the reading in which the universal
outscopes the most which outscopes the existential in the
logical form for this sentence. Then, using the notation
of Moore (1981) for four-part quantifier structures, the
logical form must have the following structure:
all(r, representative(r) , ...)
since the universal is outermost. Now the existential is
within the scope of the universal by hypothesis, and since
it provides a restriction on the range of the variable r, it
must occur in the restriction of the quantifier. Thus, we
have:
all(r, representative(r) &amp; some(c, company(c),
of(c,r)), ...saw(r,$)...)
But where can the quantifier most be put to bind the vari-
able s corresponding to the samples seen? It must
outscope its occurrence in the body of the universal, but
it must also by hypothesis outscope the existential in the
restriction of the universal. To outscope both, it must
outscope the universal itself, but this violates the
assumed scope relations. Thus, no such reading is possi-
ble. By a similar argument, it follows from the logical
structure of English that in general a quantifier from else-
where in a sentence cannot come after the quantifier
associated with a head noun and before the quantifier
associated with a noun phrase in the head noun&apos;s comple-
ment.
Most research in linguistic semantics, e.g., Montague
(1973) and Cooper (1983), has concentrated on explicit-
ly defining the range of possible scope relationships that
can be manifested in sentences. But, to our knowledge,
all fall prey to the profligacy of generation just outlined.
</bodyText>
<note confidence="0.71037">
1.2 OTHER ISSUES IN QUANTIFIER SCOPING
1.2.1 OTHER SPURIOUS SCOPINGS
</note>
<bodyText confidence="0.9986855">
We are concerned here only with suppressing readings
that are spurious for purely structural reasons, that is, for
reasons that follow from the general relationship between
the structure of sentences and the structure of their
logical forms and independent of the meanings of the
particular sentences. For instance, we are not concerned
with logical redundancies, such as those due to the
commutativity of successive universal quantifiers. When
we move beyond the two first-order logical quantifiers to
deal with the so-called generalized quantifiers such as
most, these logical redundancies become quite rare. Simi-
larly, we are not concerned with the infelicity of certain
readings due to lexical semantic or world knowledge,
such as the fact that a child cannot outscope every man in
the sentence
I&apos;ve met a child of every man in this room.
</bodyText>
<subsubsectionHeader confidence="0.534076">
1.2.2 HEURISTICALLY PRIMARY SCOPINGS
</subsubsectionHeader>
<bodyText confidence="0.99959175">
Computational research on quantifier scoping has
emphasized generating a single scoping, which can be
thought of as heuristically primary, as discussed by, for
example, Woods (1977), Pereira (1983), and Grosz et al.
(1985). We are concerned not with generating the best
reading but with generating all readings. The reader may
object that it is inappropriate in a practical natural
language system to generate scopings one by one for
testing against semantic and pragmatic criteria. Instead,
one should appeal to various heuristics to generate only
the most likely reading, or at least to generate readings in
order of their plausibility. These include the following:
</bodyText>
<listItem confidence="0.9933495">
• lexical heuristics, e.g., each usually outscopes some;
• syntactic heuristics, e.g., a noun phrase in a relative
clause is usually outscoped by the head noun, and a
noun phrase in a prepositional phrase complement of a
</listItem>
<page confidence="0.927169">
48 Computational Linguistics, Volume 13, Numbers 1-2, January-June 1987
</page>
<note confidence="0.423286">
Jerry R. Hobbs and Stuart M. Shieber An Algorithm for Generating Quantifier Scopings
</note>
<bodyText confidence="0.981425">
relational head noun usually outscopes the head noun;
and
</bodyText>
<listItem confidence="0.908314666666667">
• ordering heuristics, such as the principle that left-to-
right order at the same syntactic level is generally
preserved in the quantifier order.2
</listItem>
<bodyText confidence="0.99965375">
We are sympathetic with this view. Nevertheless, there
are several reasons that codifying a complete algorithm
remains useful. First, a complete and sound algorithm
provides a benchmark against which other approaches
can be tested. Second, one may actually wish to use a
generate-and-test mechanism in simpler implementations,
and it should be correct and as efficient as possible. It
should not generate scopings that can be ruled out on
purely structural grounds. Finally, the algorithm we
present might be modified to incorporate heuristics to
generate scopings in a certain order or only certain of the
scopings. The soundness and correctness of the underly-
ing algorithm, provide a guarantee of soundness for a
heuristically guided version. We include a few comments
below about incorporating ordering heuristics into our
scoping generation algorithm, although we should point
out that the possibilities are somewhat limited due to the
local nature of where the heuristics can be applied. A
full discussion of heuristically-guided scoping generation
is, of course, beyond the scope of this paper.
</bodyText>
<sectionHeader confidence="0.337517" genericHeader="method">
1.2.3 SCOPE OF OPAQUE PREDICATES
</sectionHeader>
<bodyText confidence="0.980732">
In addition to handling the scoping of quantifiers relative
to each other, the algorithm we present also allows quan-
tifiers to be scoped within or outside of opaque argu-
ments of higher-order predicates. For instance, the
algorithm generates two readings for the sentence
Everyone isn&apos;t here.
corresponding to the two relative scopings of the
universal quantifier and the negation.
</bodyText>
<sectionHeader confidence="0.98475" genericHeader="method">
2 THE ALGORITHM
</sectionHeader>
<bodyText confidence="0.999988538461539">
In the discussion below, we assume that parsing has
made explicit the predicate-argument relations and the
relations of grammatical subordination in the form of a
logical encoding in an input language. A well-formed
formula (wff) in the input language is a predicate or other
operator applied to one or more arguments. An argu-
ment can be a constant or variable, another wff, or what
we will call a complex term. A complex term is an
ordered triple consisting of a quantifier, a variable, and a
wff (called the restriction), which represents the predi-
cation that is grammatically subordinated to the variable.
The input representation for sentence (2) is, then, the
following (ignoring tense):
</bodyText>
<equation confidence="0.992666571428571">
see( &lt;some r
and( rep(r),
of (r, &lt; every d
and( dept(d),
in(d,&lt;most c co(c)&gt;))&gt;))&gt;,
&lt;a-few s and(samp(s),
of(s,&lt;each p prod(p)&gt;))&gt;)
</equation>
<bodyText confidence="0.981470785714286">
A complex term can be read &amp;quot;quantifier variable such
that restriction&amp;quot;, e.g., &amp;quot;most c such that c is a company&amp;quot;.
The output language is identical to the input language,
except that it does not contain complex terms. Quantifi-
ers are expressed in the output language as operators that
take three arguments: the variable bound by the quantifi-
er, a wff restricting the range of the quantified variable,
and the body scoped by the quantification, schematically
quantifier(variable, restriction, body)
This encoding of quantification is the same as that found
in Woods (1977) and Moore (1981). We will refer to
such expressions as quantified wffs. Thus, one reading
for sentence (2) is represented by the following quanti-
fied wff:
</bodyText>
<equation confidence="0.967766777777778">
some(r, and(rep(r),
every(d, and(dept(d),
most(c, co(c),
in(d, c))),
of (r, d))),
a-few(s, and( samp(s),
each(p, prod(p),
of(s, p))),
see(r, s)))
</equation>
<bodyText confidence="0.999975384615385">
Intermediate structures built during the course of scoping
include both complex terms and quantified wffs. We use
the term full scoping for an expression in the output
language, i.e., one that has no complex terms.
We also will use the terms bound and free as follows:
An expression binds a variable v if the expression is of the
form &lt; q v r&gt; or q(v, r, s) where g is a quantifier. The
variable v is said to be bound in the expressions r, or r
and s, respectively. A variable v is unbound or free in an
expression a if there is an occurrence of v in a that is not
also an occurrence in a subexpression of a binding v.
Note that here quantified wffs and complex terms are
both thought of as expressions binding a variable.
</bodyText>
<subsectionHeader confidence="0.639131">
2.1 SUMMARY OF THE ALGORITHM
</subsectionHeader>
<bodyText confidence="0.951626272727273">
We present both nondeterministic and deterministic
versions of the algorithm3 in an ALGOL-like language.
Both algorithms, however, have the same underlying
structure, based on the primitive operation of &amp;quot;applying&amp;quot;
a complex term to a wff in which it occurs: a complex
term in a wff is replaced by the variable it restricts, and
that variable is then bound by wrapping the entire form
in the appropriate quantifier. Thus, applying the term
&lt;q x r(x) &gt; to a wff containing that complex term, say,
p( &lt;q x r(x) &gt; ), yields the quantified wff
Computational Linguistics, Volume 13, Numbers 1-2, January-June 1987 49
Jerry R. Hobbs and Stuart M. Shieber An Algorithm for Generating Quantifier Scopings
q(x, r(x), p(x)). This is the primitive operation by which
complex terms are removed from a wff and quantified
wffs are introduced. It is implemented by the function
apply.
The generation of a scoping from a wff proceeds in
two stages. First, the opaque argument positions within
the wff are scoped. The function pull-opaque-args
performs this task by replacing wffs in opaque argument
positions by a (full or partial) scoping of the original wff.
For instance, if p were a predicate opaque in its only
argument, then, for the wff p(s( &lt;q x r(x) &gt; )), pull-
opaque-args would generate the wff p(q(x, r(x), s(x))) or
the unchanged wff p(s( &lt; q x r(x) &gt; )). In the former,
the opaque predicate p outscopes the quantifier q. In the
latter, the quantifier q has not been applied yet and the
wff will subsequently yield readings in which q has wider
scope than p.
Second, some or all of the remaining terms are applied
to the entire wff. The function apply-terms iteratively
(through a tail recursion) chooses a complex term in the
wff and applies it. Thus apply-terms acting upon the wff
</bodyText>
<equation confidence="0.820480428571429">
p( &lt;q1 x r1(x) &gt; &lt; q2 y r2(y) &gt;) will yield one of the
five wffs
p( &lt; x ri(x) &gt; , &lt; q2 y r2(Y) &gt; )
qi(x, ri(x), p(x, &lt; q2 y r2(y) &gt; ))
92(Y, r2(y), P( &lt; q1 x r1(x) &gt; .Y))
92(Y, r2(y), 91(x, ri(x), p(x, .0))
qi(x, ri(x), q2(y, r2(y), p(x, y)))
</equation>
<bodyText confidence="0.99795604">
depending on how many quantifiers are applied and in
what order. The choice of a complex term is restricted to
a subset of the terms in the wff, the so-called applicable
terms. The principal restriction on applicable terms is
that they not be embedded in any other complex term in
the wff. Section 4.1 discusses a further restriction. The
function applicable-term returns an applicable term in a
given wff.
These two stages are manifested in the function pull
which generates all partial or full scopings of a wff by
invoking pull-opaque-args and apply-terms. Since ulti-
mately only full scopings are desired, an additional argu-
ment to pull and apply-terms controls whether partial
scopings are to be returned. When this flag, complete?, is
true, apply-terms, and hence pull, will return only
expressions in which no more complex terms remain to
be applied, for example, only the last two of the five
readings above.
Finally, the restrictions of the complex terms may
themselves contain complex terms and must be scoped
themselves. The apply function therefore recursively
generates the scopings for the restriction by calling pull
on that restriction, and a quantified wff is generated for
each possible partial or complete scoping of the
restriction. Schematically, in the simplest case, for the
</bodyText>
<equation confidence="0.973219166666667">
expression p( &lt;q1 x ri(x, &lt; q2 y r2(y) &gt; ) and its complex
term &lt; q1 &gt; ,4 apply generates the complete scoping
(x, q2(y, r2(y), (x, y)), p(x))
(having called apply recursively on &lt;q2 &gt; ), and the
partial scoping
qi(x, ri(x, &lt; q2 y r2(y) &gt; ), p(x))
</equation>
<bodyText confidence="0.974595105263158">
A subsequent application of the remaining complex term
will yield the &amp;quot;wide scope&amp;quot; reading
q2(y, r2(y), qi(x, ri(xty), p(x))
The disallowed readings produced by the &amp;quot;all per-
mutations&amp;quot; algorithm are never produced by this algo-
rithm, because it is everywhere sensitive to the four-part
quantifier structure of the target logical form.
The difference between the nondeterministic and
deterministic versions lies only in their implementation of
the choice of terms and returning of values. This is done
either nondeterministically, or by iterating through and
returning explicit sets of possibilities. A nondeterministic
Prolog version and a deterministic COMMON LISP
version of the algorithm are given in Appendices A and
B. The full text of these versions (including auxiliary
functions not listed here) is available from the authors.
A variant of the COMMON LISP version is currently
being used at SRI International to generate scopings in
the KLAUS system.
</bodyText>
<subsectionHeader confidence="0.996895">
2.2 LANGUAGE CONSTRUCTS
</subsectionHeader>
<bodyText confidence="0.94815125">
In the specifications below, the let construct implements
local variable assignment. All assignments are done
sequentially, not in parallel. The syntax is
let (assignments)
in (body)
The entire expression returns what the body returns.
Destructuring by pattern matching is allowed in the
assignments; for example,
let &lt;quant var restrict&gt; := term
in (body)
simultaneously binds quant, var, and restrict to the three
corresponding components in term. The symbol &amp;quot;:=&amp;quot; is
used for assignment. lambda is an anonymous-function-
forming operator. Its syntax is
lambda( (variable)).
(body)
where (variable) is free in (body). We assume lexical
scoping in lambda expressions. The statement &amp;quot;return
value&amp;quot; returns a value from a function. The binary func-
tion map (similar to LISP&apos;s mapcar) applies its second
argument (a lambda expression) to each of the elements
of its first argument (a list). It returns a corresponding
list of the values of the individual applications. The func-
tion integers(lower,upper) returns a list of the integers in
</bodyText>
<page confidence="0.881391">
50 Computational Linguistics, Volume 13, Numbers 1-2, January-June 1987
</page>
<note confidence="0.431371">
Jerry R. Hobbs and Stuart M. Shieber An Algorithm for Generating Quantifier Scopings
</note>
<bodyText confidence="0.999746478260869">
the range lower to upper, inclusive and in order
(corresponding to APL&apos;s iota). The function length(list)
is obvious. The expression list!n! returns the nth element
of the list list. The function subst(x,y,expr) substitutes x
for all occurrences of y in expr.
The unary function predicate(wff) returns the main
predicate in a wff. The unary function arguments(wff)
returns a list of the arguments in a wff. Applied to two
arguments, wff is a binary function that takes a predicate
name and a list of arguments, and returns the wff consist-
ing of the application of the predicate to the arguments.
Applied to four arguments, wff is a quaternary function
that takes a quantifier name, a variable name, a
restriction, and a body, and returns the quantified wff
consisting of the binding of the variable by the quantifier
in the restriction and body. The binary predicate
opaque(predicate, n) returns true if and only if the predi-
cate is opaque in its nth argument. It is naturally
assumed that opaque argument positions are filled by wff
expressions, not terms. Each of the unary predicates
wff?, term?, and quantifier? returns true if and only if its
argument is a wff, a complex term, or a quantifier opera-
tor, respectively.
</bodyText>
<subsectionHeader confidence="0.998441">
2.3 THE NONDETERMINISTIC ALGORITHM
</subsectionHeader>
<bodyText confidence="0.97104795">
In the nondeterministic version of the algorithm, there
are three special language constructs. The unary predi-
cate exists(expression) evaluates its argument nondeter-
ministically to a value and returns true if and only if there
exist one or more values for the expression. The binary
operator &amp;quot;ail b&amp;quot; nondeterministically returns one of its
arguments (a or b). The function term(form) nondeter-
ministically returns a complex term in form. Finally, the
function applicable-term(form) nondeterministically
returns a complex term in form that can be applied to
form.
The nondeterministic version of the algorithm is as
follows. The function gen(form) nondeterministically
returns a valid full scoping of the formula form.
function gen (form);
return pull(form,true).
The function pull(form,complete?) nondeterministically
returns a valiciscoping of the formula form. If complete?
is true, then only full scopings are returned; otherwise,
partial scopings are allowed as well.
</bodyText>
<equation confidence="0.927860333333333">
function pull(form, complete?);
return apply-terms(pull-opaque-args(form),
complete?).
</equation>
<bodyText confidence="0.835744">
The function pull-opaque-args(form), when applied to a
wff, returns a wff generated from form but with argu-
ments in opaque argument positions replaced by a valid
scoping of the original value. Since the recursive call to
pull has complete? set to false, the unchanged argument is
a nondeterministic possibility, even for opaque argument
positions. When applied to any other type of expression
(i.e., a term of some sort), form is unchanged.
function pull-opaque-args(form);
if not(wff.2(form))
then return form
else
let predicate := predicate(form);
</bodyText>
<equation confidence="0.6267125">
args := arguments(form)
in return
wff(predicate,
map( integers(1,1ength(args)),
lambda(arg-index).
if opaque(predicate,arg-index)
then pull(args[arg-index],false)
else pull-opaque-args(args[arg-index]) )).
</equation>
<bodyText confidence="0.81656004">
The function apply-terms(form, complete?) chooses function apply-terms(form, complete?);
several terms in form nondeterministically and applies if not(exists(term(form)))
them to form. If complete? is true, then only full scopings then return form
are returned. else
let scoped-form :=
apply-terms(apply(applicable-term(form),
form),
complete?)
in
if complete?
then return scoped-form
else return scoped -form II form.
Computational Linguistics, Volume 13, Numbers 1-2, January-June 1987 51
Jerry R. Hobbs and Stuart M. Shieber An Algorithm for Generating Quantifier Seopings
The function apply(term, form) returns a wff consisting
of the given complex term term applied to a form form in
which it occurs. In addition, the restriction of the
complex term is recursively scoped.
function apply(term,form);
let &lt;quant var restrict&gt; := term
return
wff(quant,
var,
pull(restrict,false),
subst(var,term,form)).
</bodyText>
<subsectionHeader confidence="0.967744">
2.4 THE DETERMINISTIC ALGORITHM
</subsectionHeader>
<bodyText confidence="0.999703153846154">
For the deterministic version of the algorithm, there are
five special language constructs. The unary predicate
empty(set) returns true if and only if set is empty. Paired
braces &amp;quot;I ... I&amp;quot; constitute a set-forming operator. The
binary function union applies its second argument (a
lambda expression) to each of the elements of its first
argument (a set). It returns a corresponding set of the
values of the individual applications. The binary infix
operator U returns the union of its two arguments (both
sets). The function cross-product takes a list of sets as its
argument and returns the set of lists corresponding to
each way of taking an element from each of the sets in
order. For example,
</bodyText>
<equation confidence="0.980494">
cross-product( [fa, 14, {c,d,e]] ) =
[ [a,c1, [a,(11, [a,e], [b,c], [b,d], [b,e] 1.
</equation>
<bodyText confidence="0.963256625">
The function terms(form) returns the set of all complex
terms in form. The function applicable-terms(form)
returns the set of all complex terms in form that can be
applied to form.
The deterministic version of the algorithm is identical
in structure to the nondeterministic version. Each func-
tion operates in the same way as its nondeterministic
counterpart, except that they uniformly return sets rather
than nondeterministically returning single values.
The algorithm is as follows. The function gen (form)
returns a set of all valid full scopings of the formula form.
function gen (form);
return pull(form,true).
The function pull returns a set of all valid scopings of the
formula form. If complete? is true, only full scopings are
returned; otherwise, partial scopings are allowed as well.
</bodyText>
<equation confidence="0.905127">
function pull(form, complete?);
return union( pull-opaque-args(form),
lambda(pulled-opaque).
apply-terms( pulled-opaque,
complete?)).
</equation>
<bodyText confidence="0.999692875">
The function pull-opaque-args(form) returns a set of all
wffs generated from form, but with arguments in opaque
argument positions replaced by a valid scoping of the
original value. Since the recursive call to pull has
complete? set to false, the unchanged argument is a possi-
bility even for opaque argument positions. When applied
to any other type of expression (i.e., a term of some
sort), the argument is unchanged.
</bodyText>
<equation confidence="0.870525266666667">
function pull-opaque-args(form)
if not(wff.2(form))
then return {form}
else
let predicate := predicate(form);
args arguments(form)
return
union( cross-product(
map( integers(I,length(args)),
lambda(arg-index).
if opaque(predicate,arg-index)
then pull(args[arg-index], false)
else pull-opaque-args(args[arg-index1))),
lambda (args-possibility).
wff(predicate, args-possibility)} ).
</equation>
<bodyText confidence="0.99646725">
The function apply-terms (form, complete?) returns a set of
scopings of form constituting all of the ways of choosing
several terms in form and applying them to form. If
complete? is true, then only the full scopings are returned.
</bodyText>
<page confidence="0.846656">
52 Computational Linguistics, Volume 13, Numbers 1-2, January-June 1987
</page>
<figure confidence="0.908094866666667">
Jerry R. Hobbs and Stuart M. Shieber An Algorithm for Generating Quantifier Seopings
function apply-terms(form, complete?);
if empty(terms(form))
then return {forml
else
let scoped-forms :=
union( applicable-terms (form),
lambda(term).
union(apply(term, form),
lambda(applied-form).
apply-terms(applied-form, complete?))).
in
if complete?
then return scoped-forms
(3) else return {form } U scoped-forms.
</figure>
<bodyText confidence="0.924789428571429">
The function apply(term, form) returns a set of all wffs
consisting of the given complex term term applied to the
form form in which it occurs, with the restriction of the
complex term recursively scoped in all possible ways.
function apply(term,form);
let (quant var restrict) := term
in return
</bodyText>
<figure confidence="0.683568333333333">
(4) union( pull(restrict,false),
lambda(pulled-restrict).
fwff(quant,
var,
pulled-restrict,
subst(var,term,form))}).
</figure>
<sectionHeader confidence="0.738878" genericHeader="method">
3 Two EXAMPLES
</sectionHeader>
<bodyText confidence="0.909115">
Since the algorithm is not completely transparent, it may
be useful to work through the deterministic version for a
detailed example.
</bodyText>
<listItem confidence="0.563845">
(5) Some representative of every department in most
companies saw a few samples.
</listItem>
<bodyText confidence="0.978507">
The predicate-argument structure of this sentence may
be represented as follows:
</bodyText>
<figure confidence="0.697562166666667">
see( &lt;some r
and( rep(r),
of(r,&lt;every d
and( dept(d),
in(d,&lt;most c
&lt;a-few s samp(s)&gt;)
</figure>
<bodyText confidence="0.847392777777778">
Suppose gen is called with expression (6) as form. Since
this is the representation of the whole sentence, pull will
be called with complete? equal to true. The call to pull-
opaque-args will return the original wff unchanged since
there are no opaque operators in the wff. We therefore
call apply-terms on the wff.
In apply-terms, the call to applicable-terms returns a list
of all of the unnested complex terms. For (6), there will
be two:
</bodyText>
<listItem confidence="0.518557">
(7) &lt;some r
and( rep(r),
of(r,&lt;every d
and( dept(d),
in(d,&lt;most c co(c)&gt;))&gt;))&gt;
(8) &lt;a-few s samp(s)&gt;
</listItem>
<bodyText confidence="0.9958944">
Each of these complex terms will ultimately yield the
wffs in which its variable is the more deeply nested of the
two.
The function apply is called for each of these complex
terms, and inside apply there is a recursive call to pull on
the restriction of the complex term. This generates all
the possible scopings for the restriction. When apply is
called with (6) as form and (7) as term, the result of
scoping the restriction of (7) will be the following four
wffs:
</bodyText>
<listItem confidence="0.9457735">
(9) and( rep(r),
of(r,&lt;every d
and( dept(d),
in(d,&lt;most c co(c)&gt;))&gt;))
(10) every(d, and(dept(d), in(d, &lt;most c co(c)&gt;)),
and(rep(r), of(r, d)))
(11) most(c, co(c), every(d, and(dept(d), in(d,c)),
and(rep(r), of(r,d))))
(12) every(d, most(c, co(c), and(dept(d), in(d,c))),
and(rep(r), of(r, d)))
</listItem>
<bodyText confidence="0.92867976">
Because this call to pull has complete? equal to false, the
unprocessed restriction itself, wff (9), as well as the
partially scoped wff (10), is returned along with the fully
scoped forms of the restriction. Wff (9) will ultimately
generate the two readings in which variables d and c
outscope r. Wff (10) is also partial as it still contains a
complex term. It will ultimately yield a reading in which
r outscopes d but is outscoped by c; the complex term for
c is still available for an application that will give it wide
Computational Linguistics, Volume 13, Numbers 1-2, January-June 1987 53
Jerry R. Hobbs and Stuart M. Shieber An Algorithm for Generating Quantifier Scopings
scope. Wffs (11) and (12) will ultimately yield readings
in which d and c are outscoped by r.
Each of these wffs becomes the restriction in a quanti-
fied wff constructed by apply. Thus, from restriction
(10), apply will construct the quantified wff
(13) some(r, every(d, and(dept(d),
in(d, &lt;most c
and(rep(r), of(r, d))),
see(r, &lt;a-few s samp(s)&gt;))
In apply-terms, the tail recursion turns the remaining
complex terms into quantifiers with wide scope. Thus, in
(13) c and s will be given wider scope than r and d. For
example, one of the readings generated from wff (13)
will be
</bodyText>
<equation confidence="0.6066388">
most(c, co(c),
a-few(s, samp(s),
some(r, every(d, and(dept(d), in(d, c)),
and(rep(r), of(r, d))),
see(r, s))))
</equation>
<bodyText confidence="0.984533388888889">
Sentence (5), by the way, has 14 different readings.
As an example of the operation of the algorithm on a
wff with opaque operators, we consider the sentence
Everyone isn&apos;t here.
This has the predicate-argument structure
not(here(&lt;every x person(x)&gt;))
where not is an operator opaque in its only argument.
The call to pull-opaque-args returns the two scopings
not(here(&lt;every x person(x)&gt;))
not(every(x,person(x),here(x)))
The call to apply-terms then turns the first of these into
every(x,person(x),not(here(x)))
Thus, the following two full scopings are generated:
every(x,person(x),not(here(x)))
not(every(x,person(x),here(x)))
Note that because of the recursive call in pull-opaque-args
these two readings will be generated even if this form is
embedded within other transparent predicates.
</bodyText>
<sectionHeader confidence="0.937381" genericHeader="method">
4 MODIFICATIONS AND EXTENSIONS
4.1 RESTRICTING APPLICABLE TERMS
</sectionHeader>
<bodyText confidence="0.9999576">
The notion of applicable term used above was quite
simple. A complex term was applicable to a wff if it was
embedded in no other complex term within the wff. The
restriction is motivated by the following consideration.
Suppose the input wff is
</bodyText>
<equation confidence="0.845559">
p( &lt; x (x, &lt; q2 y r2 (y) &gt; ) &gt; )
If the embedded term were first applied, yielding
q2 (y, r2 (y), p( &lt;q1 x r1 (x ,y) &gt; ))
</equation>
<bodyText confidence="0.920996333333333">
the remaining complex term would include a free occur-
rence of y so that when it is later applied, resulting in the
formula
</bodyText>
<equation confidence="0.90279">
q1 (x, r1 (x,y), q2 (y, r2 (y), p(x)))
</equation>
<bodyText confidence="0.995558888888889">
the variable y occurs free in the restriction of q, .
Thus, it is critical that a term never be applied to a
form when a variable that is free in the term is bound
outside of it in the form. The simple definition of appli-
cability goes part of the way towards enforcing this
requirement.
Unfortunately, this simple definition of applicability is
inadequate. If x had itself been free in the embedded
complex term, as in the wff
</bodyText>
<equation confidence="0.640795">
p( &lt;q1xr1 (x, &lt; q2 y r2 (x, y) &gt; ) &gt; )
</equation>
<bodyText confidence="0.9960494">
the application of the outer term followed by the inner
term would still leave an unbound variable, namely x.
This is because the inner term, which uses x, has been
applied outside the scope of the binder for x. Such struc-
tures can occur, for instance, in sentences like the follow-
ing, where an embedded noun phrase requires reference
to its embedding noun phrase.5
Every man that I know a child of has arrived.
Every man with a picture of himself has arrived.
In these two sentences the quantifier a cannot outscope
every because the noun phrase beginning with a embeds a
reference to every man. If a were to outscope every, then
himself or the trace following child of would be outside
the scope of every man.
The definition of applicable term must be modified as
follows. A term in a wff is applicable to the wff if and
only if all variable occurrences that are free in the term
are free in the wff as well. Our previous definition of
applicability, that the term be unembedded in another
term in the wff, is a simple consequence of this
restriction. The versions of the algorithm given in
Appendices A and B define the functions applicable-term
and applicable-terms in this way. Given this definition,
the algorithm can be shown never to generate unbound
variables. (See Appendix C.)
</bodyText>
<subsectionHeader confidence="0.953793">
4.2 ADDING ORDERING HEURISTICS
</subsectionHeader>
<bodyText confidence="0.992032277777778">
A full discussion of heuristic rules for guiding generation
of quantifier scopings is outside of the aims of this paper.
However, certain ordering heuristics can be incorporated
relatively easily into the algorithm merely by controlling
the way in which nondeterministic choices are made. We
discuss a few examples here, merely to give the flavor for
how such heuristics might be added.
For instance, suppose we want to favor the original
left-to-right order in the sentence. The function applica-
ble-terms should return the complex terms in right-to-left
order, since quantifiers are extracted from the inside out.
The union in line (3) should return form after scoped-
forms.
If we want to give a noun phrase wide scope when it
occurs as a prepositional phrase noun complement to a
function word, e.g., every side of a triangle, then form
should come before scoped-form in line (3) when pull has
been called from line (4) in apply where the first argu-
</bodyText>
<page confidence="0.978955">
54 Computational Linguistics, Volume 13, Numbers 1-2, January-June 1987
</page>
<note confidence="0.627507">
Jerry R. Hobbs and Stuart M. Shieber An Algorithm for Generating Quantifier Scopings
</note>
<bodyText confidence="0.999243">
ment to apply is a complex term for a noun phrase satis-
fying those conditions, e.g., the complex term for every
side of a triangle.
The modifications turn out to be quite complicated if
we wish to order quantifiers according to lexical heuris-
tics, such as having each outscope some. Because of the
recursive nature of the algorithm, there are limits to the
amount of ordering that can be done in this manner. At
the most, we can sometimes guarantee that the best scop-
ing comes first. Of course, one can always associate a
score with each reading as it is being generated and sort
the list afterwards.
</bodyText>
<subsectionHeader confidence="0.995283">
4.3 NONSTANDARD INPUT STRUCTURES
</subsectionHeader>
<bodyText confidence="0.99555275">
The algorithm as presented will operate correctly only for
input structures that are themselves well-formed. For
instance, they must contain no unbound variables.
Certain natural language phenomena, such as the
so-called donkey sentences, exhibit structures that are
ill-formed with respect to the assumptions made by this
algorithm. For instance, the sentence
Every man who owns a donkey beats it.
has an ill-formed input structure because the pronoun has
to reach inside the scope of an existential quantifier for
its antecedent. Its predicate-argument structure might be
something like
</bodyText>
<equation confidence="0.917944333333333">
beat(&lt;every m and(man(m),
own(m, &lt;some d donkey(d)&gt;))&gt;,
d)
</equation>
<bodyText confidence="0.994071666666667">
An alternative is to leave the pronoun unanalyzed, in
which case the closest reading produced by the algorithm
is
</bodyText>
<equation confidence="0.506349666666667">
every(m, and(man(m),
some(d, and(donkey(d), own(m, d)))),
the(x, it(x), beat(m, x)))
</equation>
<bodyText confidence="0.999849142857143">
In fact, this is not bad if we take it(x) to mean that x is
nonhuman and that x is mentioned in the prior discourse
in a position determined by whatever coreference resol-
ution process is used. There is a problem if we take the
quantifier the to mean that there is a unique such x and
take the sentence to mean that a man who owns many
donkeys will beat every donkey he owns. But we can get
around this if, following the approach taken by Hobbs
(1983), we take a donkey to be generic, take it to refer to
the unique generic donkey that m owns, and assume that
to beat a generic donkey is to beat all its instances.
In any case, modifications to the algorithm would be
needed to handle such anaphora phenomena in all their
complexity.
</bodyText>
<sectionHeader confidence="0.99675" genericHeader="method">
5 CONCLUSION
</sectionHeader>
<bodyText confidence="0.99977325">
We have presented an algorithm for generating exactly
those quantifier scopings that are consistent with the
logical structure of English. While this algorithm can
sometimes result in a significant savings over the naive
approach, it by no means solves the entire quantifier
scoping problem, as we have already pointed out. There
has already been much research on the problem of
choosing the preferred reading among these allowable
ones, but the methods that have been suggested need to
be specified in an implementation-free fashion more
precisely than they have been previously, and they need
to be evaluated rigorously on large bodies of naturalistic
data. More important, methods need to be developed for
using pragmatic considerations and world knowledge —
particularly reasoning about quantities and dependencies
among entities — to resolve quantifier scope ambiguities,
and these methods need to be integrated smoothly with
the other kinds of syntactic, semantic, and pragmatic
processing required in the interpretation of natural
language texts.
</bodyText>
<sectionHeader confidence="0.995192" genericHeader="method">
ACKNOWLEDGMENTS
</sectionHeader>
<bodyText confidence="0.999815571428572">
We have profited from discussions about this work with
Paul Martin and Fernando Pereira, and from the
comments of the anonymous reviewers of the paper.
This research was supported by NIH Grant LM03611
from the National Library of Medicine, by Grant
IST-8209346 from the National Science Foundation, and
by a gift from the System Development Foundation.
</bodyText>
<sectionHeader confidence="0.991162" genericHeader="method">
REFERENCES
</sectionHeader>
<reference confidence="0.400196666666667">
Barwise, Jon and Cooper. Robin 1981 Generalized Quantifiers and
Natural Language. Linguistics and Philosophy 4(2): 159-219.
Cooper, Robin 1983 Quantification and Syntactic Theory. Reidel,
Dordrecht.
Cushing, Steven 1976 The Formal Semantics of Quantification. Ph.D.
dissertation. University of California, Los Angeles.
Grosz, Barbara J. Appelt, Douglas E. Martin, Paul; Pereira, Fernando
C.N.; and Shinkle, Lorna 1985 The TEAM Natural-Language
Interface System. Final Report, Project 4865. Artificial Intelligence
Center, SRI International, Menlo Park, California.
Hobbs, Jerry R. 1983 An Improper Treatment of Quantification in
Ordinary English. In Proceedings of the 21st Annual Meeting of the
Association for Computational Linguistics. Cambridge, Massachusetts:
57-63.
Keller, William 1986 Nested Cooper Storage. Paper presented at the
Workshop on Word Order and Parsing in Unification Grammars,
Friedenweiler, West Germany (7-11 April).
Montague, Richard 1973 The Proper Treatment of Quantification in
Ordinary English. In Thomason, R., Ed., Formal Philosophy,
Selected Papers of Richard Montague. Yale University Press, New
Haven, Connecticut.
Moore, Robert C. 1981 Problems in Logical Form. In Proceedings of
the 19th Annual Meeting of the Association for Computational Linguis-
tics. Stanford, California: 117-124.
Pereira, Fernando C.N. 1983 Logic for Natural Language Analysis.
Technical Note 275. Artificial Intelligence Center, SRI International,
Menlo Park, California.
Woods, William 1977 Semantics and Quantification in Natural
Language Question Answering. Advances in Computers. Volume 17.
Academic Press, New York: 1-87.
</reference>
<page confidence="0.244657">
Computational Linguistics, Volume 13, Numbers 1-2, January-June 1987 55
</page>
<note confidence="0.394081">
Jerry R. Hobbs and Stuart M. Shieber An Algorithm for Generating Quantifier Scopings
</note>
<sectionHeader confidence="0.861258" genericHeader="method">
APPENDIX A. PROLOG IMPLEMENTATION OF THE ALGORITHM
</sectionHeader>
<bodyText confidence="0.9975185">
The following is the core of a Prolog implementation of the nondeterministic algorithm which includes all but the lowest
level of routines. The syntax is that of Edinburgh Prologs, e.g., DEC-20 Prolog.
</bodyText>
<figure confidence="0.546446">
/*****************************************************************************
Prolog Implementation of Scope Generation Algorithm
************************************M**************************************/
/*
</figure>
<bodyText confidence="0.962701">
Representation of wffs:
A wff of the form &apos;p(argl,...,argn)&apos; is represented as the Prolog term
wff(p,[arg1&apos;,...,argn1) where argi&apos; is the encoding of the
subexpression argi.
A constant term is represented by the homonymous Prolog constant.
A complex term is represented by the Prolog term
term(quant,var,restrict&apos;) where restrict&apos; is the encoding of the wff
that forms the restriction of the quantifier.
</bodyText>
<equation confidence="0.774544714285714">
*/
% gen(Form,ScopedForm)
Form ==&gt; a wff with in-place complex terms
ScopedForm &lt;== a full scoping of Form
gen(Form, ScopedForm) :-
pull(Form, true, ScopedForm).
% pull(Form, Complete?, ScopedForm)
</equation>
<bodyText confidence="0.992984833333333">
Form ==&gt; a wff with in-place complex terms
Complete? ==&gt; true iff only full scopings are allowed
ScopedForm &lt;== a full or partial scoping of Form
Applies terms at various level of embedding in Form, including
applying to the entire Form, and to opaque argument positions
inside Form.
</bodyText>
<listItem confidence="0.5781805">
pull(Form, Complete, ScopedForm) :-
pull_opaque_args(Form, PulledOpaque),
apply_terms(PulledOpaque, Complete, ScopedForm).
% pull_opaque_args(Form, ScopedForm)
</listItem>
<bodyText confidence="0.820557">
Form ==&gt; a term or a wff with in-Place complex terms
ScopedForm &lt;== Form with opaque argument positions recursively scoped
Scopes arguments of the given Form recursively.
</bodyText>
<construct confidence="0.285017333333333">
pull_opaque_args(wff(Pred,Args), wff(Pred, ScopedArgs)) !,
pull_opaque_args(Pred, 1, Args, ScopedArgs).
pull_opaque_args(Term, Term).
</construct>
<page confidence="0.950447">
56 Computational Linguistics, Volume 13, Numbers 1-2, January-June 1987
</page>
<note confidence="0.730988">
Jerry R. Hobbs and Stuart M. Shieber An Algorithm for Generating Quantifier Scopings
</note>
<bodyText confidence="0.837485727272727">
% pull_opaque_args(Pred, ArgIndex, Args, ScopedArgs)
the wff whose args are being scoped
argument currently being scoped
ArgIndex on
argument positions recursively scoped
Scopes a given argument if opaque; otherwise, scopes its
subparts recursively.
% No more arguments.
pull_opaque_args(_Pred,_ArgIndex,H,H) !.
% Current argument position is opaque; scope it.
pull_opaque_args(Pred, ArgIndex,
</bodyText>
<equation confidence="0.970836714285714">
[FirstArglRestArgs],
[ScopedFirstArgIScopedRestArgs]) :-
opaque(Pred,ArgIndex), !,
pull(FirstArg,false,ScopedFirstArg),
NextIndex is ArgIndex+1,
pull_opaque_args(Pred, NextIndex, RestArgs, ScopedRestArgs).
% Current argument is not opaque; don&apos;t scope it.
pull_opaque_args(Pred, ArgIndex,
[FirstArglRestArgs],
[ScopedFirstArgIScopedRestArg0 :-
pull_opaque_args(FirstArg,ScopedFirstArg),
NextIndex is ArgIndex+1,
pull_opaque_args(Pred, NextIndex, RestArgs, ScopedRestArgs).
% apply_terms(Form, Complete?, ScopedForm)
</equation>
<bodyText confidence="0.944506142857143">
Form ==&gt; a wff with in-place complex terms
Complete? ==&gt; true iff only full scopings are allowed
ScopedForm &lt;== a full or partial scoping of Form
Applies one or more terms to the Form alone (not to any embedded
forms.
apply_terms(Form, _Complete, Form) :-
not(term(Form,_Term)), !.
</bodyText>
<reference confidence="0.3964684">
apply_terms(Form, false, Form).
apply_terms(Form, Complete, ScopedForm) :-
applicable_term(Form, Term),
apply(Term, Form, AppliedForm),
apply_terms(AppliedForm, Complete, ScopedForm).
</reference>
<bodyText confidence="0.931201714285714">
% apply(Term,Form,NewForm)
Term ==&gt; a complex term
Form ==&gt; the wff to apply Term to
NewForm &lt;== Form with the quantifier wrapped around it
apply(term(Quant,Var,Restrict),
Body,
wff(Quant,[var,PulledRestrict,OutBody])) :-
pull(Restrict, false, PulledRestrict),
subst(Var,term(Quant,Var,Restrict),Body,OutBody).
% applicable_term(Form, Term)
Form ==&gt; an expression in the logical form language
Term &lt;== a top-level term in Form (that is, a term embedded in
no other term) which is not free in any variable bound
along the path from Form to the Term.
</bodyText>
<table confidence="0.659685333333333">
Fred ==&gt; the predicate of
ArgIndex ==&gt; the index of the
Args ==&gt; list of args from
ScopedArgs &lt;== Args with opaque
Computational Linguistics, Volume 13, Numbers 1-2, January-June 1987 57
Jerry R. Hobbs and Stuart M. Shieber An Algorithm for Generating Quantifier Scopings
</table>
<equation confidence="0.740955">
applicable_term(Form, Term) :-
applicable_term(Form, Term, H).
% applicable_term(Form,Term,BlockingVars)
</equation>
<bodyText confidence="0.94018">
Form ==&gt; an expression in the logical form language
Term &lt;== a top-level term in Form (that is, a term embedded in
no other term) which is not free in any variable bound
along the path from Form to the Term.
BlockingVars ==&gt;
a list of variables bound along the path so far
% A term is an applicable top-level term...
applicable_term(term(Q,V,R),term(Q,V,R), BVs)
% if it meets the definition.
not(free_in(BVs, R)).
% An applicable term of the restriction or body of a quantifier is applicable
% only if the variable bound by the quantifier is not free in the term.
applicable_term(wff(Quant,[Var,Restrict,Body]),Term, BVs) :-
quantifier(Quant), !,
(applicable_term(Restrict,Term,[VarIBVs]);
applicable_term(Body,Term,[VarIBV0).
</bodyText>
<listItem confidence="0.9905636">
% An applicable term of an argument list is an applicable term of the wff.
applicable_term(wff(_Pred,Args),Term, BVs) :-
applicable_term(Args, Term, BVs).
% An applicable term of any argument is an applicable term of the whole
% list.
</listItem>
<equation confidence="0.811264333333333">
applicable_term([F I R],Term, BVs) :-
applicable_term(F,Term,BVs) ;
applicable_term(R,Term,BVs).
</equation>
<bodyText confidence="0.848728">
% Note the absence of a rule looking for applicable terms inside of
% complex terms. This limits applicable terms to be top-level.
</bodyText>
<sectionHeader confidence="0.706787" genericHeader="method">
APPENDIX B. COMMON LISP IMPLEMENTATION OF THE ALGORITHM
</sectionHeader>
<bodyText confidence="0.930172">
The following is the core of a COMMON LISP implementation of the deterministic algorithm which includes all but the
lowest level of routines.
;;;.***************************************************************************
</bodyText>
<sectionHeader confidence="0.666103" genericHeader="method">
COMMON LISP Implementation of Scope Generation Algorithm
</sectionHeader>
<subsectionHeader confidence="0.607785">
Representation of Wffs
</subsectionHeader>
<bodyText confidence="0.998171285714286">
;;; A wff of the form &apos;p(argl,...,argn)&apos; is represented as the
;;; s-expression (p argi&apos; argn&apos;) where argi&apos; is the encoding of the
;;; subexpression argi.
A constant term is represented by the homonymous LISP atom.
A complex term is represented by the s-expression (:term quant
;;; var restrict&apos;) where restrict&apos; is the encoding of the wff that forms
;;; the restriction of the quantifier.
</bodyText>
<page confidence="0.966651">
58 Computational Linguistics, Volume 13, Numbers 1-2, January-June 1987
</page>
<note confidence="0.451868">
Jerry R. Hobbs and Stuart M. Shieber An Algorithm for Generating Quantifier Scopings
I f I
</note>
<bodyText confidence="0.953973909090909">
Implementation notes:
;;; The following simple utility functions are assumed:
;;; map-union -- implements the binary function UNION
;;; cross-product -- implements the function CROSS-PRODUCT
opaque -- implements the binary function OPAQUE
;;; integers -- implements the binary function INTEGERS
;;; The infix union is implemented with CL function UNION.
;;; The binary prefix union is implemented under the name MAP-UNION
;;; to avoid conflict with the CL function UNION.
;;; The function APPLY is implemented under the name APPLY-Q to avoid
;;; conflict with the CL function APPLY.
</bodyText>
<figure confidence="0.268473636363636">
(defun gen (form)
(pull form t))
(defun pull (form complete?)
(map-union (pull-opaque-args form)
(function (lambda (pulled-opaque)
(apply-terms pulled-opaque complete?)))))
(defun pull-opaque-args (form)
(if (not (wff? form))
(list form)
(let ((predicate (first form))
(args (rest form)))
(map-union (cross-product
(mapcar (function (lambda (arg-index)
(if (opaque predicate arg-index)
(pull (nth (- arg-index 1) args)
nil)
(pull-opaque-args (nth (- arg-index 1)
args)))))
(integer&apos;s 1 (length args))))
(function (lambda (args-possibility)
(list (cons predicate args-possibility))))))))
(defun apply-terms (form complete?)
(if (null (terms form))
(list form)
(let ((scoped-forms
(map-union
(applicable-terms form)
(function (lambda (term)
(map-union
(apply-q term form)
(function (lambda (applied-form)
(apply-terms applied-form
complete?)))))))))
(if complete?
scoped-forms
(adjoin form scoped-forms)))))
(defun apply-q (term form)
(let ((quant (second term))
(var (third term))
(restrict (fourth term)))
(map-union (pull restrict nil)
(function (lambda (pulled-restrict)
(list
(list quant var pulled-restrict
(subst var term form))))))))
(defun applicable-terms (form)
(applicable-terms1 form &apos;()))
Computational Linguistics, Volume 13, Numbers 1-2, January-June 1987 59
Jerry R. Hobbs and Stuart M. Shieber An Algorithm for Generating Quantifier Scopings
Cdefun applicable-terms1 (form blocking-vars)
(cond ( (atom form)
&apos; 0)
((and (term? form)
(not-free-in blocking-vars (fourth form)))
(list form))
((term? form)
0)
((and (wff? form)
(quantifier? (first form)))
(union (applicable-terms1 (third form)
(cons (second form) blocking-vars))
(applicable-terms1 (fourth form)
(cons (second form) blocking-vars))))
(t (mapcan (function (lambda (arg)
(applicable-terms1 arg blocking-vars)))
(cdr form)))))
</figure>
<sectionHeader confidence="0.473913" genericHeader="method">
APPENDIX C. PROOFS OF ALGORITHM PROPERTIES
</sectionHeader>
<bodyText confidence="0.99893288">
This appendix includes informal proofs of some impor-
tant properties of the nondeterminisitc version of the
presented algorithm. First, we present a proof of the
termination of the algorithm. Several criteria of the
partial correctness of the algorithm are also informally
shown, especially, that the algorithm does not generAte
wffs with unbound variables.
However, we do not prove correctness in the sense of
showing that the algorithm is semantically sound, i.e.,
that it yields wffs with interpretations consistent with the
interpretation of the input expression, simply because we
do not provide a semantics for the input language. (The
output language, of course, has a standard logical seman-
tics.)
We do not attempt to prove completeness for the algo-
rithm, as the concept of completeness is open to interpre-
tation, depending as it does on just which scopings one
deems possible, but we expect that the algorithm is
complete in the sense that every permutation of quantifi-
ers respecting the considerations in the introduction is
generated. We also do not prove the nonredundancy of
the nondeterminism in the algorithm, i.e., that the algo-
rithm will not generate the same result along different
nondeterministic paths, although we believe that the
algorithm is nonredundant.
</bodyText>
<sectionHeader confidence="0.741193" genericHeader="conclusions">
C.1 NOTATION
</sectionHeader>
<bodyText confidence="0.99986075">
We will use lower Greek letters (a, /3, ...) as variables
ranging over expressions in the logical form language.
We inductively define a metric p on expressions in the
logical form language as follows:
</bodyText>
<equation confidence="0.721491333333333">
2 + p(r) if a is a complex term &lt; q v r &gt;
P(a) = 1 + p(a,) if a is a wff f(ai, , an) and I p(a) &gt; 0
0 otherwise
Informally, p is a measure of the embedding depth of the
complex terms in an expression.
C.2 TERMINATION
</equation>
<bodyText confidence="0.810037384615385">
We will give an informal proof of termination for the
nondeterministic algorithm by induction on this metric p.
But first, we present without proof three simple but
useful properties of the metric.
Lemma 1 If a is a wff, then p(a) = 0 if and only if a
contains no complex terms.
Lemma 2 If a is a wff and 0 is a subexpression of a and
p(a) &gt; 0, then p(P) &lt; p(a)
Lemma 3 If a is a wff and /3 is a subexpression of a and
p(a) = 0, then p(i3) = 0.
We now prove the following theorem, and its corollary
which gives the termination of the algorithm. We assume
that calls to the auxiliary functions wff, term, wff?, term?,
</bodyText>
<construct confidence="0.871919411764706">
predicate, arguments, opaque, map, exists, not, applicable-
term, subst, and so forth always terminate if the computa-
tion of their arguments terminates.
Theorem 1. For all expressions a, the following six
conditions hold-.
Condition I: pull-opaque-args(a) terminates with result 0
such that p(0) &lt; p(a),
Condition 2: for all complex terms t in a, apply(t,a) termi-
nates with result s such that p(f3) &lt; p(a),
Condition 3: apply-terms(a,true) terminates with result /3
such that p(P) = 0,
Condition 4: apply-terms(a false) terminates with result
such that p(g) &lt; p(a),
Condition 5: pull(a,true) terminates with result 0 such
that p(0) = 0,
Condition 6: pull(a false) terminates with result /3 such
that p(I3) p(a).
</construct>
<page confidence="0.939891">
60 Computational Linguistics, Volume 13, Numbers 1-2, January-June 1987
</page>
<note confidence="0.724039">
Jerry R. Hobbs and Stuart M. Shieber An Algorithm for Generating Quantifier Seopings
</note>
<bodyText confidence="0.972629068965517">
Proof: We first prove the base case, for p(a) = 0. By
Lemma 1, a must contain no complex terms. Three of
the conditions are easily proved.
Condition 2: Since, by Lemma 1, there are no complex
terms in a, this condition holds vacuously.
Condition 3: Again, the absence of complex terms in a
causes the call to apply-terms to return with result a,
and p(a) = 0, so the condition holds.
Condition 4: Similarly, and p(a) &lt; p(a) trivially.
Conditions 1,5, and 6: These conditions follow directly
from Lemma 4 given below.
Lemma 4 For all expressions a such that p(a) = 0,
pull(a,x) and pull-opaque-args(a) terminate
with result a.
Proof sketch: The proof is by a simple induction on
the length of the expression, and uses the base case for
conditions 3 and 4 proved above.
For the induction step for Theorem 1, we assume the
induction hypotheses that the six conditions hold for all a
such that p(a) &lt; n and prove the conditions for p(a) = n,
for n&gt;0. The conditions are proved sequentially. In
particular, earlier conditions for the case p(a) = n are
used in the proofs of later ones. (Since there is no use of
later conditions in earlier ones, this does not introduce
any circularity in the proof.)
Condition 1: We must show that pull-opaque-args(a)
terminates with result (3 such that p(13) &lt; p(a). If a is
not a wff, then the condition holds vacuously, so we
assume that a = f(cei, ,a,). By definition of p,
</bodyText>
<equation confidence="0.8209445">
PO 5 1 ± Ep(o).
,=1
</equation>
<bodyText confidence="0.99309675">
(The inequality is necessary because p(f3) may be
zero.) Now /3, is either a, or pull(a,false). In the first
case, p(1t) &lt; p(a,) trivially. In the second case, since
a, is a subexpression of a, by Lemma 2 we have that
p(a,) &lt; p(a) and we can use the induction hypothesis
to show the termination of the call to pull. Also by
the induction hypothesis, p(f11) &lt; p(a,).
Thus, we see that in either case, p(A) &lt; p(a,). So
</bodyText>
<equation confidence="0.9956005">
P(13) 5_ 1 + Epco 1 + Ep(a1) = p(a).
1=1 t=1
</equation>
<bodyText confidence="0.953074727272727">
Condition 2: We must show that for all terms t in a,
apply(t,a) terminates with result p such that p(I3) &lt;
p(a). Suppose t=&lt;qvr&gt;. Then = aPP1.YRq v
r&gt;, a) = q(v, y, 8) where y = pull(r, false) and 8 =
subst(v, &lt;q v r&gt;, a).
Now, let p(r) = m. By Lemma 2, m &lt;n. So by the
induction hypothesis, the computation of y terminates
and p(y) &lt; m. Also, the computation of 8 is assumed
to terminate (as mentioned above) with 8 missing the
complex term t that occurs in a (and possibly other
complex terms embedded within 1). So
</bodyText>
<equation confidence="0.578742">
p(8) p(a) — p(t) = n —(2 + p(r)) = n — 2 — m.
</equation>
<bodyText confidence="0.982527462962963">
Finally, by definition of p we have p(fl) &lt; 1 + p(y) +
p(8)&lt;1+m+n— 2 —m=n-1&lt;n.
We will use the two conditions just proved in the
proofs of the final four conditions.
Condition 3: We must show that apply-terms(a,true)
terminates with result /3 such that p(13) = 0. By
Lemma 1, we know that complex terms exist in a so
the else clause is taken. Let t = applicable-term(a)
and y = apply(t,a). By the second condition just
proved above, the latter computation terminates with
p(y) &lt; p(a) — 1 &lt; n. Now let E = apply-terms(y,
true). Again, by the induction hypothesis, this compu-
tation terminates with p( €) = 0. Since complete? =
true, we return c as g, so p(P) = 0 as required.
Condition 4: We must show that apply-terms(a false)
terminates with result 13 such that p([3) &lt; p(a). By
Lemma 1, we know that complex terms exist in a so
the else clause is taken. Let t = applicable-term(a)
and y = apply(t,a). By the second condition just
proved above, this computation terminates with p(y)
&lt; p(a) — 1 &lt; n. Now let E = apply-terms(y false).
Again by the induction hypothesis, this computation
terminates with p(E) &lt; p(y) &lt; n. Since complete? =
false, we return E or a as p. In either case, p(I3) &lt;
p(a) as required.
We will use the four conditions just proved in the
proofs of the final two conditions.
Condition 5: We must show that pull(a,true) terminates
with result g such that p(13) = 0. Let y = pull-opaque-
args(a). By the first condition just proved above, we
know this computation terminates and p(y) &lt;n. Now,
let E = apply-terms(y,true). Again by the third condi-
tion just proved above, this computation terminates
with p(E) = 0. Since complete? = true, we return E
as 0, so p(P) = 0 as required.
Condition 6: We must show that pull(a false) terminates
with result /3 such that p([3) &lt; p(a). The argument is
similar to that for condition 5. Let y = pull-opaque-
args(a). By the first condition just proved above, we
know this computation terminates and p(y) &lt; n. Now,
let E = apply-terms(y, false). Again by the fourth
condition just proved above, this computation termi-
nates with p(E) &lt; p(y) &lt; n. Since complete? = false,
we return either E or a as p. In either case, p(13) &lt;
p(a) as rquired.
This completes the proof of the six conditions, given
the induction hypotheses, and thus completes the induc-
tive proof of the theorem.
Corollary 1 For all wffs a, gen(a) terminates with result
g such that [3 has no complex terms as subexpressions.
Proof: This follows immediately from the fifth condi-
tion in Theorem 1 and Lemma 1.
Computational Linguistics, Volume 13, Numbers 1-2, January-June 1987 61
Jerry R. Hobbs and Stuart M. Shieber An Algorithm for Generating Quantifier Seopings
</bodyText>
<sectionHeader confidence="0.615709" genericHeader="acknowledgments">
C.3 CORRECTNESS
</sectionHeader>
<bodyText confidence="0.994584857142857">
We consider several criteria for correctness of the algo-
rithm. Let U(a) = the set of variables that are unbound
in a and V(a) = the set of variables that are vacuously
quantified in a.6 We show that if input expression a is
well-formed, that is, has no unbound variables and no
vacuous quantifiers ( U(a) = V(a) = 0), and if /3 =
gen(a), then
</bodyText>
<figureCaption confidence="0.905057333333333">
Criterion 1: 13 has no complex terms;
Criterion 2: 0 has no unbound variables (u(0) = 0);
Criterion 3: 13 has no vacuous quantifiers (V(/3) = 0);
</figureCaption>
<bodyText confidence="0.951831568627451">
Criterion 4: for every complex term t in a, there is a
quantifier in [3 that binds the same variable as t and
has the position held by tin a in its body; and
Criterion 5: for every quantifier q in g, there is either a
quantifier in a or a complex term in a that binds the
same variable.
Proof of these five statements does not constitute a
proof of correctness, but provides motivation for assum-
ing the correctness of the algorithm. As unbound vari-
ables in the output are the prime symptom of problems
with previous algorithms, we take these criteria to be the
most critical for indicating correctness.
The first criterion follows directly from Corollary 1.
The second and third criteria are a consequence of the
following theorem which we prove informally.
Theorem 2 For all expressions such that U(a) =
u = , um&apos; and V(a) = v = , v,j, and
for b E {true, falsel and for 0 any of gen(a), pull(a, b),
pull-opaque-args(a), apply-terms(a, b), and
apply(applicable-term(a), a), u(g) = u and V(P) = v.
Proof: Again, the proof is by induction on p(a), but
we will be less formal in demonstrating the well-founded-
ness of the induction. The base case is trivial because, as
shown in the proofs of Theorem 1 and Lemma 4, the
functions all return their argument unchanged when p(a)
= 0. For the induction step, we will merely show that
each function maintains the unbound variables and vacu-
ous quantifiers, assuming that all the others do. The
previous proof of termination provides the well-founded-
ness of this proof.
apply(applicable-term(a),a): We must show that if
t= &lt;qxr&gt; is an applicable term in a and U(a)=u
and V(a) = v then U(apply(t,a)) = u and V(apply(t,a))
= v as well.
The unbound variables u in a can be divided into
two (possibly overlapping) sets u, and u„ where u,
consists of those variables in u that occur in r and u,
consists of those variables in u that occur outside of t
in a. Note that u = u, U u,. Now assume x occurs in r.
Then U(r) = {x} U u„U uo where 140 is the set of vari-
ables bound within a but outside of t and which occur
free in r. But t is an applicable term, and by the defi-
nition of &amp;quot;applicable term&amp;quot; uo must be empty. So
U(r) = {x} U u„. (If x does not occur in r, a similar
argument shows that U(r) = u,.)
Let r&apos; = pull(r, false) and s = subst(x,t,a). By the
induction hypothesis, U(r&apos;) = fx1 U ur. Since s does
not include t (which binds x) but does include
x, U(s) = 1x1 U u. In forming the quantified wff
/3 = q(x, , s), the unbound variables in g consist of
those in and those in s except for x, that is
</bodyText>
<equation confidence="0.990062">
U(/3) = R{x} U u,)U (ix} Uu,)1— {x} = u Utt — u
(If x does not occur in r, similar arguments show that
U(r&apos;) = u„ U(s) = {x} U u, and u(g) = ROO U u,)
U ur] — {x} = U u„ = u.)
</equation>
<bodyText confidence="0.998476764705882">
Vacuous quantified variables can be divided simi-
larly into v. (those bound vacuously in r) and v, (those
bound vacuously outside of t in a). Again, v = v, U v,.
Trivially, V(r) = v„. By induction, V(I) = v, also.
Since s does not include t, V(s) = v,. V(I3) =
V(r) U V(s) = v unless the quantification of x in 13 is
vacuous. Since x is guaranteed to occur in s (as it
replaces t in s), the quantification is clearly not vacu-
ous. So v(0) = v.
apply-terms(a,b): This follows straightforwardly from the
previous subproof for apply and the induction hypoth-
esis for apply-terms.
pull-opaque-args(a): If a is not a wff, then the proof is
trivial. Otherwise, there are two cases, depending on
whether the predicate in a, p, is or is not a quantifier.
If p is not a quantifier, then the result follows imme-
diately from the induction hypothesis for pull and pull-
opaque-args.
If p is a quantifier, then let a = p(x,r,$). The output
13 then is wff(p, pull-opaque-args(x), pull-
opaque-args(r), pull-opaque-args(s)). The first call to
pull-opaque-args merely returns x. Now by an argu-
ment similar to that given in the subproof for apply,
the unbound variables in a can be exhaustively divided
into u, and u, depending on whether they occur in r
and s. Depending on whether x occurs in r,
U(r) = fx1 U u, or U(r) = ur. Similarly, U(s) = {x} U u,
or U(s) = u,. Suppose the second and third calls to
pull-opaque-args return r&apos; and s&apos; respectively. By the
induction hypotheses U(I) = U(r) and U(s&apos;) = U(s).
If the quantification of x in a is not vacuous, then x
occurs free in either r or s (and by induction in or s&apos;)
so u(p) = {x} U u, U u, — {xl = u. If the quantification
of x is vacuous, then U(r&apos;) = u, and U(s&apos;) = u, and
</bodyText>
<equation confidence="0.636073">
U(f3) = u.
</equation>
<bodyText confidence="0.9619325">
Vacuous quantified variables can be divided into v„
and vs similarly. Suppose the quantification of x is
vacuous (i.e., x does not occur free in r or s). Then V
V(a) = {x} U v, U v. By the induction hypothesis,
V(I) = V(r) = v, and V(s&apos;) = V(s) = v,. Also by
induction, x does not occur free in or s&apos;. Therefore,
the quantification of x in p is also vacuous and
V(13) = {x} U v,U v, = V(a).
If the quantification of x is not vacuous, then
v = v, U v, and x occurs free in either r or s. By induca-
</bodyText>
<page confidence="0.96995">
62 Computational Linguistics, Volume 13, Numbers 1-2, January-June 1987
</page>
<note confidence="0.469505">
Jerry R. Hobbs and Stuart M. Shieber An Algorithm for Generating Quantifier Scopings
</note>
<bodyText confidence="0.999532">
tion, x occurs free in either or s&apos; so the quantifica-
tion of x in g is also non-vacuous. Also by induction
as before, V(I) = v,. and V(s&apos;) = v„ so
</bodyText>
<equation confidence="0.966645">
V(13) = V(I) U V(s) = vr U vs = V(a).
</equation>
<bodyText confidence="0.997647958333333">
pull(a,b): This follows directly, using the previously
proved induction steps for apply-terms and pull-
opaque-args.
gen(a): This follows directly, using the previously proved
induction step for pull.
This concludes the proof of the induction step and the
theorem.
The second and third criteria follow from the
presumed well-formedness of a and Theorem 2 which
demonstrates that gen maintains well-formedness.
The fourth and fifth criteria we argue informally as
follows: Since no complex terms occur in g (by Corol-
lary 1), we can assume that every complex term t in a
was applied (i.e., the first argument of apply) at some
time in the processing of a. But if it was applied, then it
must have been an applicable term occurring in the wff it
was applied to (as the only call to apply is of this form).
Then the call to subst in apply will not be vacuous, the
quantifier will bind the same variable as t and will
outscope the position held by t in a. Thus the fourth
criterion holds. Also note that all quantifiers in ,13 are
either the result of such an application or were in a
originally. Thus the fifth criterion follows immediately as
well.
</bodyText>
<sectionHeader confidence="0.971829" genericHeader="references">
NOTES
</sectionHeader>
<reference confidence="0.982778842105263">
1. William Keller (1986) has also noted this problem with Cooper&apos;s
method. His independent solution to the problem, stated in terms
of &amp;quot;nested Cooper storage&amp;quot;, resembles the one presented here.
2. These heuristics should themselves be made available in a public
forum.
3. A nondeterministic version of the algorithm, formulated by both
authors, was presented by Hobbs (1983).
4. Note that this term is applicable according to the criterion discussed
above, whereas the embedded term binding y is not. The fact that
we still get both scopings even without the possibility of applying
the embedded term first demonstrates that the restriction on appli-
cable terms does not affect completeness of the algorithm.
5. This problem was pointed out to us by Fernando Pereira.
6. A variable v is vacuously quantified in an expression a if and only if
v is bound in a subexpression of a, a quantified wff of the form
q(v, r, s) and v does not occur free in r or s. This definition implies
that variables bound by complex terms are never vacuously quanti-
fied.
Computational Linguistics, Volume 13, Numbers 1-2, January-June 1987 63
</reference>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.581553">
<title confidence="0.98579">AN ALGORITHM FOR GENERATING QUANTIFIER SCOPINGS</title>
<author confidence="0.896601">Stuart</author>
<affiliation confidence="0.927985">Artificial Intelligence SRI</affiliation>
<address confidence="0.932354">Menlo Park, CA</address>
<affiliation confidence="0.859621">Center for the Study of Language and Stanford</affiliation>
<address confidence="0.99695">Stanford, CA 94305</address>
<abstract confidence="0.997135111111111">The syntactic structure of a sentence often manifests quite clearly the predicate-argument structure and relations of grammatical subordination. But scope dependencies are not so transparent. As a result, many systems for representing the semantics of sentences have ignored scoping or generated scopings with mechanisms that have often been inexplicit as to the range of scopings they choose among or profligate in the scopings they allow. This paper presents, along with proofs of some of its important properties, an algorithm that generates scoped semantic forms from unscoped expressions encoding predicate-argument structure. The algorithm is not profligate as are those based on permutation of quantifiers, and it can provide a solid foundation for computational solutions where completeness is sacrificed for efficiency and heuristic efficacy.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Robin</author>
</authors>
<date>1981</date>
<journal>Generalized Quantifiers and Natural Language. Linguistics and Philosophy</journal>
<volume>4</volume>
<issue>2</issue>
<pages>159--219</pages>
<marker>Robin, 1981</marker>
<rawString>Barwise, Jon and Cooper. Robin 1981 Generalized Quantifiers and Natural Language. Linguistics and Philosophy 4(2): 159-219.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Robin Cooper</author>
</authors>
<title>Quantification and Syntactic Theory.</title>
<date>1983</date>
<location>Reidel, Dordrecht.</location>
<contexts>
<context position="4833" citStr="Cooper 1983" startWordPosition="743" endWordPosition="744">ifiers.) This observation of &amp;quot;illegitimate readings&amp;quot; is not intended as a new or controversial claim about an idiosyncrasy of English. It accords well with semantic judgments about the possibility of such readings. For instance, we find it impossible to view sentence (1) as expressing that for each representative there was a group of most samples which he saw, and furthermore, for each sample he saw, there was a company he was a representative of. We can find the same problem of illegitimate readings in the standard account of the &amp;quot;Cooper storage&amp;quot; mechanism for generating quantifier scopings (Cooper 1983). Cooper&apos;s method generates an expression in intensional logic for the illegitimate readings, but the expression contains an unbound variable and a vacuous quantifier.&apos; Finally, the observation follows merely syntactically from the ill-formedness of certain logical form expressions. Let us examine why this is so. The propositional content of a sentence can be seen as combining specifications that restrict the range of quantified entities, together with assertions about the entities so specified. This intuition is often made formal in the use of logical languages that syntactically separate the</context>
<context position="7696" citStr="Cooper (1983)" startWordPosition="1200" endWordPosition="1201">e body of the universal, but it must also by hypothesis outscope the existential in the restriction of the universal. To outscope both, it must outscope the universal itself, but this violates the assumed scope relations. Thus, no such reading is possible. By a similar argument, it follows from the logical structure of English that in general a quantifier from elsewhere in a sentence cannot come after the quantifier associated with a head noun and before the quantifier associated with a noun phrase in the head noun&apos;s complement. Most research in linguistic semantics, e.g., Montague (1973) and Cooper (1983), has concentrated on explicitly defining the range of possible scope relationships that can be manifested in sentences. But, to our knowledge, all fall prey to the profligacy of generation just outlined. 1.2 OTHER ISSUES IN QUANTIFIER SCOPING 1.2.1 OTHER SPURIOUS SCOPINGS We are concerned here only with suppressing readings that are spurious for purely structural reasons, that is, for reasons that follow from the general relationship between the structure of sentences and the structure of their logical forms and independent of the meanings of the particular sentences. For instance, we are not</context>
</contexts>
<marker>Cooper, 1983</marker>
<rawString>Cooper, Robin 1983 Quantification and Syntactic Theory. Reidel, Dordrecht.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Steven Cushing</author>
</authors>
<title>The Formal Semantics of Quantification.</title>
<date>1976</date>
<tech>Ph.D. dissertation.</tech>
<institution>University of California,</institution>
<location>Los Angeles.</location>
<contexts>
<context position="6212" citStr="Cushing, 1976" startWordPosition="960" endWordPosition="961"> assertions in a part called the body. (Henceforth, we will uniformly use the terms restriction and body.) The separation of these two semantic roles of range and scope into restriction and body as an important fact of the logical structure of English can be seen, for example, in Woods&apos;s four-part quantifier structures (Woods 1977), in the recommendations of Moore (1981), and in the generalized quantifier research of Barwise and Cooper and others. The latter have demonstrated the necessity of such a separation for quantifiers other than the standard first-order ones (Barwise and Cooper, 1981; Cushing, 1976). But under this understanding of English logical structure, it follows that no sixth reading exists for sentence (1) above. Consider the reading in which the universal outscopes the most which outscopes the existential in the logical form for this sentence. Then, using the notation of Moore (1981) for four-part quantifier structures, the logical form must have the following structure: all(r, representative(r) , ...) since the universal is outermost. Now the existential is within the scope of the universal by hypothesis, and since it provides a restriction on the range of the variable r, it mu</context>
</contexts>
<marker>Cushing, 1976</marker>
<rawString>Cushing, Steven 1976 The Formal Semantics of Quantification. Ph.D. dissertation. University of California, Los Angeles.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Barbara J Appelt Grosz</author>
<author>Douglas E Martin</author>
<author>Pereira Paul</author>
<author>C N Fernando</author>
<author>Shinkle</author>
</authors>
<date>1985</date>
<booktitle>The TEAM Natural-Language Interface System. Final Report, Project 4865. Artificial Intelligence Center, SRI International,</booktitle>
<location>Lorna</location>
<contexts>
<context position="9072" citStr="Grosz et al. (1985)" startWordPosition="1411" endWordPosition="1414">ical quantifiers to deal with the so-called generalized quantifiers such as most, these logical redundancies become quite rare. Similarly, we are not concerned with the infelicity of certain readings due to lexical semantic or world knowledge, such as the fact that a child cannot outscope every man in the sentence I&apos;ve met a child of every man in this room. 1.2.2 HEURISTICALLY PRIMARY SCOPINGS Computational research on quantifier scoping has emphasized generating a single scoping, which can be thought of as heuristically primary, as discussed by, for example, Woods (1977), Pereira (1983), and Grosz et al. (1985). We are concerned not with generating the best reading but with generating all readings. The reader may object that it is inappropriate in a practical natural language system to generate scopings one by one for testing against semantic and pragmatic criteria. Instead, one should appeal to various heuristics to generate only the most likely reading, or at least to generate readings in order of their plausibility. These include the following: • lexical heuristics, e.g., each usually outscopes some; • syntactic heuristics, e.g., a noun phrase in a relative clause is usually outscoped by the head</context>
</contexts>
<marker>Grosz, Martin, Paul, Fernando, Shinkle, 1985</marker>
<rawString>Grosz, Barbara J. Appelt, Douglas E. Martin, Paul; Pereira, Fernando C.N.; and Shinkle, Lorna 1985 The TEAM Natural-Language Interface System. Final Report, Project 4865. Artificial Intelligence Center, SRI International, Menlo Park, California.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jerry R Hobbs</author>
</authors>
<title>An Improper Treatment of Quantification in Ordinary English.</title>
<date>1983</date>
<booktitle>In Proceedings of the 21st Annual Meeting of the Association for Computational Linguistics.</booktitle>
<pages>57--63</pages>
<location>Cambridge, Massachusetts:</location>
<contexts>
<context position="36737" citStr="Hobbs (1983)" startWordPosition="5832" endWordPosition="5833">n unanalyzed, in which case the closest reading produced by the algorithm is every(m, and(man(m), some(d, and(donkey(d), own(m, d)))), the(x, it(x), beat(m, x))) In fact, this is not bad if we take it(x) to mean that x is nonhuman and that x is mentioned in the prior discourse in a position determined by whatever coreference resolution process is used. There is a problem if we take the quantifier the to mean that there is a unique such x and take the sentence to mean that a man who owns many donkeys will beat every donkey he owns. But we can get around this if, following the approach taken by Hobbs (1983), we take a donkey to be generic, take it to refer to the unique generic donkey that m owns, and assume that to beat a generic donkey is to beat all its instances. In any case, modifications to the algorithm would be needed to handle such anaphora phenomena in all their complexity. 5 CONCLUSION We have presented an algorithm for generating exactly those quantifier scopings that are consistent with the logical structure of English. While this algorithm can sometimes result in a significant savings over the naive approach, it by no means solves the entire quantifier scoping problem, as we have a</context>
</contexts>
<marker>Hobbs, 1983</marker>
<rawString>Hobbs, Jerry R. 1983 An Improper Treatment of Quantification in Ordinary English. In Proceedings of the 21st Annual Meeting of the Association for Computational Linguistics. Cambridge, Massachusetts: 57-63.</rawString>
</citation>
<citation valid="true">
<authors>
<author>William Keller</author>
</authors>
<title>Nested Cooper Storage. Paper presented at the Workshop on Word Order and Parsing in Unification Grammars,</title>
<date>1986</date>
<location>Friedenweiler, West</location>
<marker>Keller, 1986</marker>
<rawString>Keller, William 1986 Nested Cooper Storage. Paper presented at the Workshop on Word Order and Parsing in Unification Grammars, Friedenweiler, West Germany (7-11 April).</rawString>
</citation>
<citation valid="true">
<authors>
<author>Richard Montague</author>
</authors>
<title>The Proper Treatment of Quantification in Ordinary English. In</title>
<date>1973</date>
<publisher>Yale University Press,</publisher>
<location>New Haven, Connecticut.</location>
<contexts>
<context position="7678" citStr="Montague (1973)" startWordPosition="1197" endWordPosition="1198">its occurrence in the body of the universal, but it must also by hypothesis outscope the existential in the restriction of the universal. To outscope both, it must outscope the universal itself, but this violates the assumed scope relations. Thus, no such reading is possible. By a similar argument, it follows from the logical structure of English that in general a quantifier from elsewhere in a sentence cannot come after the quantifier associated with a head noun and before the quantifier associated with a noun phrase in the head noun&apos;s complement. Most research in linguistic semantics, e.g., Montague (1973) and Cooper (1983), has concentrated on explicitly defining the range of possible scope relationships that can be manifested in sentences. But, to our knowledge, all fall prey to the profligacy of generation just outlined. 1.2 OTHER ISSUES IN QUANTIFIER SCOPING 1.2.1 OTHER SPURIOUS SCOPINGS We are concerned here only with suppressing readings that are spurious for purely structural reasons, that is, for reasons that follow from the general relationship between the structure of sentences and the structure of their logical forms and independent of the meanings of the particular sentences. For in</context>
</contexts>
<marker>Montague, 1973</marker>
<rawString>Montague, Richard 1973 The Proper Treatment of Quantification in Ordinary English. In Thomason, R., Ed., Formal Philosophy, Selected Papers of Richard Montague. Yale University Press, New Haven, Connecticut.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Robert C Moore</author>
</authors>
<title>Problems in Logical Form.</title>
<date>1981</date>
<booktitle>In Proceedings of the 19th Annual Meeting of the Association for Computational Linguistics.</booktitle>
<pages>117--124</pages>
<location>Stanford, California:</location>
<contexts>
<context position="5971" citStr="Moore (1981)" startWordPosition="922" endWordPosition="923">ade formal in the use of logical languages that syntactically separate the notion of the range of a quantified expression from its scope by placing the information about the range in a part of the expression we call the restriction and the assertions in a part called the body. (Henceforth, we will uniformly use the terms restriction and body.) The separation of these two semantic roles of range and scope into restriction and body as an important fact of the logical structure of English can be seen, for example, in Woods&apos;s four-part quantifier structures (Woods 1977), in the recommendations of Moore (1981), and in the generalized quantifier research of Barwise and Cooper and others. The latter have demonstrated the necessity of such a separation for quantifiers other than the standard first-order ones (Barwise and Cooper, 1981; Cushing, 1976). But under this understanding of English logical structure, it follows that no sixth reading exists for sentence (1) above. Consider the reading in which the universal outscopes the most which outscopes the existential in the logical form for this sentence. Then, using the notation of Moore (1981) for four-part quantifier structures, the logical form must </context>
<context position="13042" citStr="Moore (1981)" startWordPosition="2037" endWordPosition="2038">of(s,&lt;each p prod(p)&gt;))&gt;) A complex term can be read &amp;quot;quantifier variable such that restriction&amp;quot;, e.g., &amp;quot;most c such that c is a company&amp;quot;. The output language is identical to the input language, except that it does not contain complex terms. Quantifiers are expressed in the output language as operators that take three arguments: the variable bound by the quantifier, a wff restricting the range of the quantified variable, and the body scoped by the quantification, schematically quantifier(variable, restriction, body) This encoding of quantification is the same as that found in Woods (1977) and Moore (1981). We will refer to such expressions as quantified wffs. Thus, one reading for sentence (2) is represented by the following quantified wff: some(r, and(rep(r), every(d, and(dept(d), most(c, co(c), in(d, c))), of (r, d))), a-few(s, and( samp(s), each(p, prod(p), of(s, p))), see(r, s))) Intermediate structures built during the course of scoping include both complex terms and quantified wffs. We use the term full scoping for an expression in the output language, i.e., one that has no complex terms. We also will use the terms bound and free as follows: An expression binds a variable v if the expres</context>
</contexts>
<marker>Moore, 1981</marker>
<rawString>Moore, Robert C. 1981 Problems in Logical Form. In Proceedings of the 19th Annual Meeting of the Association for Computational Linguistics. Stanford, California: 117-124.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Fernando C N Pereira</author>
</authors>
<title>Logic for Natural Language Analysis.</title>
<date>1983</date>
<booktitle>Technical Note 275. Artificial Intelligence Center, SRI International,</booktitle>
<location>Menlo Park, California.</location>
<contexts>
<context position="9047" citStr="Pereira (1983)" startWordPosition="1408" endWordPosition="1409"> two first-order logical quantifiers to deal with the so-called generalized quantifiers such as most, these logical redundancies become quite rare. Similarly, we are not concerned with the infelicity of certain readings due to lexical semantic or world knowledge, such as the fact that a child cannot outscope every man in the sentence I&apos;ve met a child of every man in this room. 1.2.2 HEURISTICALLY PRIMARY SCOPINGS Computational research on quantifier scoping has emphasized generating a single scoping, which can be thought of as heuristically primary, as discussed by, for example, Woods (1977), Pereira (1983), and Grosz et al. (1985). We are concerned not with generating the best reading but with generating all readings. The reader may object that it is inappropriate in a practical natural language system to generate scopings one by one for testing against semantic and pragmatic criteria. Instead, one should appeal to various heuristics to generate only the most likely reading, or at least to generate readings in order of their plausibility. These include the following: • lexical heuristics, e.g., each usually outscopes some; • syntactic heuristics, e.g., a noun phrase in a relative clause is usua</context>
</contexts>
<marker>Pereira, 1983</marker>
<rawString>Pereira, Fernando C.N. 1983 Logic for Natural Language Analysis. Technical Note 275. Artificial Intelligence Center, SRI International, Menlo Park, California.</rawString>
</citation>
<citation valid="true">
<authors>
<author>William Woods</author>
</authors>
<title>Semantics and Quantification in Natural Language Question Answering.</title>
<date>1977</date>
<booktitle>Advances in Computers. Volume 17.</booktitle>
<pages>1--87</pages>
<publisher>Academic Press,</publisher>
<location>New York:</location>
<contexts>
<context position="5931" citStr="Woods 1977" startWordPosition="915" endWordPosition="916">so specified. This intuition is often made formal in the use of logical languages that syntactically separate the notion of the range of a quantified expression from its scope by placing the information about the range in a part of the expression we call the restriction and the assertions in a part called the body. (Henceforth, we will uniformly use the terms restriction and body.) The separation of these two semantic roles of range and scope into restriction and body as an important fact of the logical structure of English can be seen, for example, in Woods&apos;s four-part quantifier structures (Woods 1977), in the recommendations of Moore (1981), and in the generalized quantifier research of Barwise and Cooper and others. The latter have demonstrated the necessity of such a separation for quantifiers other than the standard first-order ones (Barwise and Cooper, 1981; Cushing, 1976). But under this understanding of English logical structure, it follows that no sixth reading exists for sentence (1) above. Consider the reading in which the universal outscopes the most which outscopes the existential in the logical form for this sentence. Then, using the notation of Moore (1981) for four-part quant</context>
<context position="9031" citStr="Woods (1977)" startWordPosition="1406" endWordPosition="1407">ove beyond the two first-order logical quantifiers to deal with the so-called generalized quantifiers such as most, these logical redundancies become quite rare. Similarly, we are not concerned with the infelicity of certain readings due to lexical semantic or world knowledge, such as the fact that a child cannot outscope every man in the sentence I&apos;ve met a child of every man in this room. 1.2.2 HEURISTICALLY PRIMARY SCOPINGS Computational research on quantifier scoping has emphasized generating a single scoping, which can be thought of as heuristically primary, as discussed by, for example, Woods (1977), Pereira (1983), and Grosz et al. (1985). We are concerned not with generating the best reading but with generating all readings. The reader may object that it is inappropriate in a practical natural language system to generate scopings one by one for testing against semantic and pragmatic criteria. Instead, one should appeal to various heuristics to generate only the most likely reading, or at least to generate readings in order of their plausibility. These include the following: • lexical heuristics, e.g., each usually outscopes some; • syntactic heuristics, e.g., a noun phrase in a relativ</context>
<context position="13025" citStr="Woods (1977)" startWordPosition="2034" endWordPosition="2035">w s and(samp(s), of(s,&lt;each p prod(p)&gt;))&gt;) A complex term can be read &amp;quot;quantifier variable such that restriction&amp;quot;, e.g., &amp;quot;most c such that c is a company&amp;quot;. The output language is identical to the input language, except that it does not contain complex terms. Quantifiers are expressed in the output language as operators that take three arguments: the variable bound by the quantifier, a wff restricting the range of the quantified variable, and the body scoped by the quantification, schematically quantifier(variable, restriction, body) This encoding of quantification is the same as that found in Woods (1977) and Moore (1981). We will refer to such expressions as quantified wffs. Thus, one reading for sentence (2) is represented by the following quantified wff: some(r, and(rep(r), every(d, and(dept(d), most(c, co(c), in(d, c))), of (r, d))), a-few(s, and( samp(s), each(p, prod(p), of(s, p))), see(r, s))) Intermediate structures built during the course of scoping include both complex terms and quantified wffs. We use the term full scoping for an expression in the output language, i.e., one that has no complex terms. We also will use the terms bound and free as follows: An expression binds a variabl</context>
</contexts>
<marker>Woods, 1977</marker>
<rawString>Woods, William 1977 Semantics and Quantification in Natural Language Question Answering. Advances in Computers. Volume 17. Academic Press, New York: 1-87.</rawString>
</citation>
<citation valid="false">
<authors>
<author>applyterms applyterms</author>
</authors>
<journal>Complete, ScopedForm) :-applicable_term(Form, Term), apply(Term, Form, AppliedForm), apply_terms(AppliedForm, Complete, ScopedForm).</journal>
<marker>applyterms, </marker>
<rawString>apply_terms(Form, false, Form). apply_terms(Form, Complete, ScopedForm) :-applicable_term(Form, Term), apply(Term, Form, AppliedForm), apply_terms(AppliedForm, Complete, ScopedForm).</rawString>
</citation>
<citation valid="true">
<authors>
<author>William Keller</author>
</authors>
<title>has also noted this problem with Cooper&apos;s method. His independent solution to the problem, stated in terms of &amp;quot;nested Cooper storage&amp;quot;, resembles the one presented here.</title>
<date>1986</date>
<marker>Keller, 1986</marker>
<rawString>1. William Keller (1986) has also noted this problem with Cooper&apos;s method. His independent solution to the problem, stated in terms of &amp;quot;nested Cooper storage&amp;quot;, resembles the one presented here.</rawString>
</citation>
<citation valid="false">
<title>These heuristics should themselves be made available in a public forum.</title>
<marker></marker>
<rawString>2. These heuristics should themselves be made available in a public forum.</rawString>
</citation>
<citation valid="true">
<title>A nondeterministic version of the algorithm, formulated by both authors, was presented by Hobbs</title>
<date>1983</date>
<contexts>
<context position="7696" citStr="(1983)" startWordPosition="1201" endWordPosition="1201">of the universal, but it must also by hypothesis outscope the existential in the restriction of the universal. To outscope both, it must outscope the universal itself, but this violates the assumed scope relations. Thus, no such reading is possible. By a similar argument, it follows from the logical structure of English that in general a quantifier from elsewhere in a sentence cannot come after the quantifier associated with a head noun and before the quantifier associated with a noun phrase in the head noun&apos;s complement. Most research in linguistic semantics, e.g., Montague (1973) and Cooper (1983), has concentrated on explicitly defining the range of possible scope relationships that can be manifested in sentences. But, to our knowledge, all fall prey to the profligacy of generation just outlined. 1.2 OTHER ISSUES IN QUANTIFIER SCOPING 1.2.1 OTHER SPURIOUS SCOPINGS We are concerned here only with suppressing readings that are spurious for purely structural reasons, that is, for reasons that follow from the general relationship between the structure of sentences and the structure of their logical forms and independent of the meanings of the particular sentences. For instance, we are not</context>
<context position="9047" citStr="(1983)" startWordPosition="1409" endWordPosition="1409">st-order logical quantifiers to deal with the so-called generalized quantifiers such as most, these logical redundancies become quite rare. Similarly, we are not concerned with the infelicity of certain readings due to lexical semantic or world knowledge, such as the fact that a child cannot outscope every man in the sentence I&apos;ve met a child of every man in this room. 1.2.2 HEURISTICALLY PRIMARY SCOPINGS Computational research on quantifier scoping has emphasized generating a single scoping, which can be thought of as heuristically primary, as discussed by, for example, Woods (1977), Pereira (1983), and Grosz et al. (1985). We are concerned not with generating the best reading but with generating all readings. The reader may object that it is inappropriate in a practical natural language system to generate scopings one by one for testing against semantic and pragmatic criteria. Instead, one should appeal to various heuristics to generate only the most likely reading, or at least to generate readings in order of their plausibility. These include the following: • lexical heuristics, e.g., each usually outscopes some; • syntactic heuristics, e.g., a noun phrase in a relative clause is usua</context>
<context position="36737" citStr="(1983)" startWordPosition="5833" endWordPosition="5833">alyzed, in which case the closest reading produced by the algorithm is every(m, and(man(m), some(d, and(donkey(d), own(m, d)))), the(x, it(x), beat(m, x))) In fact, this is not bad if we take it(x) to mean that x is nonhuman and that x is mentioned in the prior discourse in a position determined by whatever coreference resolution process is used. There is a problem if we take the quantifier the to mean that there is a unique such x and take the sentence to mean that a man who owns many donkeys will beat every donkey he owns. But we can get around this if, following the approach taken by Hobbs (1983), we take a donkey to be generic, take it to refer to the unique generic donkey that m owns, and assume that to beat a generic donkey is to beat all its instances. In any case, modifications to the algorithm would be needed to handle such anaphora phenomena in all their complexity. 5 CONCLUSION We have presented an algorithm for generating exactly those quantifier scopings that are consistent with the logical structure of English. While this algorithm can sometimes result in a significant savings over the naive approach, it by no means solves the entire quantifier scoping problem, as we have a</context>
</contexts>
<marker>1983</marker>
<rawString>3. A nondeterministic version of the algorithm, formulated by both authors, was presented by Hobbs (1983).</rawString>
</citation>
<citation valid="false">
<title>Note that this term is applicable according to the criterion discussed above, whereas the embedded term binding y is not. The fact that we still get both scopings even without the possibility of applying the embedded term first demonstrates that the restriction on applicable terms does not affect completeness of the algorithm. 5. This problem was pointed out to us by Fernando Pereira.</title>
<marker></marker>
<rawString>4. Note that this term is applicable according to the criterion discussed above, whereas the embedded term binding y is not. The fact that we still get both scopings even without the possibility of applying the embedded term first demonstrates that the restriction on applicable terms does not affect completeness of the algorithm. 5. This problem was pointed out to us by Fernando Pereira.</rawString>
</citation>
<citation valid="false">
<title>A variable v is vacuously quantified in an expression a if and only if v is bound in a subexpression of a, a quantified wff of the form q(v, r, s) and v does not occur free in r or s. This definition implies that variables bound by complex terms are never vacuously quantified.</title>
<marker></marker>
<rawString>6. A variable v is vacuously quantified in an expression a if and only if v is bound in a subexpression of a, a quantified wff of the form q(v, r, s) and v does not occur free in r or s. This definition implies that variables bound by complex terms are never vacuously quantified.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Computational Linguistics</author>
</authors>
<date>1987</date>
<volume>13</volume>
<pages>63</pages>
<location>Numbers</location>
<marker>Linguistics, 1987</marker>
<rawString>Computational Linguistics, Volume 13, Numbers 1-2, January-June 1987 63</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>