<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000006">
<title confidence="0.996681">
A Syntax-Driven Bracketing Model for Phrase-Based Translation
</title>
<author confidence="0.933561">
Deyi Xiong, Min Zhang, Aiti Aw and Haizhou Li
</author>
<affiliation confidence="0.868168">
Human Language Technology
Institute for Infocomm Research
</affiliation>
<address confidence="0.501529">
1 Fusionopolis Way, #21-01 South Connexis, Singapore 138632
</address>
<email confidence="0.984263">
{dyxiong, mzhang, aaiti, hli}@i2r.a-star.edu.sg
</email>
<sectionHeader confidence="0.993609" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999951473684211">
Syntactic analysis influences the way in
which the source sentence is translated.
Previous efforts add syntactic constraints
to phrase-based translation by directly
rewarding/punishing a hypothesis when-
ever it matches/violates source-side con-
stituents. We present a new model that
automatically learns syntactic constraints,
including but not limited to constituent
matching/violation, from training corpus.
The model brackets a source phrase as
to whether it satisfies the learnt syntac-
tic constraints. The bracketed phrases are
then translated as a whole unit by the de-
coder. Experimental results and analy-
sis show that the new model outperforms
other previous methods and achieves a
substantial improvement over the baseline
which is not syntactically informed.
</bodyText>
<sectionHeader confidence="0.998993" genericHeader="introduction">
1 Introduction
</sectionHeader>
<bodyText confidence="0.994237">
The phrase-based approach is widely adopted in
statistical machine translation (SMT). It segments
a source sentence into a sequence of phrases, then
translates and reorder these phrases in the target.
In such a process, original phrase-based decod-
ing (Koehn et al., 2003) does not take advan-
tage of any linguistic analysis, which, however,
is broadly used in rule-based approaches. Since
it is not linguistically motivated, original phrase-
based decoding might produce ungrammatical or
even wrong translations. Consider the following
Chinese fragment with its parse tree:
Src: [把 [[7月 11日]NP [设立 [为 [航海 节]NP
]PP ]VP ]IP ]VP
Ref: established July 11 as Sailing Festival day
Output: [to/把 [([set up/设 立 [for/为 naviga-
tion/航海]] on July 11/7月11日) knots/节]]
The output is generated from a phrase-based sys-
tem which does not involve any syntactic analy-
sis. Here we use “[]” (straight orientation) and
“()” (inverted orientation) to denote the common
structure of the source fragment and its transla-
tion found by the decoder. We can observe that
the decoder inadequately breaks up the second NP
phrase and translates the two words “航海” and
“节” separately. However, the parse tree of the
source fragment constrains the phrase “航海 节”
to be translated as a unit.
Without considering syntactic constraints from
the parse tree, the decoder makes wrong decisions
not only on phrase movement but also on the lex-
ical selection for the multi-meaning word “节”1.
To avert such errors, the decoder can fully respect
linguistic structures by only allowing syntactic
constituent translations and reorderings. This, un-
fortunately, significantly jeopardizes performance
(Koehn et al., 2003; Xiong et al., 2008) because by
integrating syntactic constraint into decoding as a
hard constraint, it simply prohibits any other use-
ful non-syntactic translations which violate con-
stituent boundaries.
To better leverage syntactic constraint yet still
allow non-syntactic translations, Chiang (2005)
introduces a count for each hypothesis and ac-
cumulates it whenever the hypothesis exactly
matches syntactic boundaries on the source side.
On the contrary, Marton and Resnik (2008) and
Cherry (2008) accumulate a count whenever hy-
potheses violate constituent boundaries. These
constituent matching/violation counts are used as
a feature in the decoder’s log-linear model and
their weights are tuned via minimal error rate
training (MERT) (Och, 2003). In this way, syn-
tactic constraint is integrated into decoding as a
soft constraint to enable the decoder to reward hy-
potheses that respect syntactic analyses or to pe-
</bodyText>
<footnote confidence="0.9543">
1This word can be translated into “section”, “festival”,
and “knot” in different contexts.
</footnote>
<page confidence="0.966598">
315
</page>
<note confidence="0.9996155">
Proceedings of the 47th Annual Meeting of the ACL and the 4th IJCNLP of the AFNLP, pages 315–323,
Suntec, Singapore, 2-7 August 2009. c�2009 ACL and AFNLP
</note>
<bodyText confidence="0.968516884615385">
nalize hypotheses that violate syntactic structures.
Although experiments show that this con-
stituent matching/violation counting feature
achieves significant improvements on various
language-pairs, one issue is that matching syn-
tactic analysis can not always guarantee a good
translation, and violating syntactic structure does
not always induce a bad translation. Marton and
Resnik (2008) find that some constituency types
favor matching the source parse while others
encourage violations. Therefore it is necessary to
integrate more syntactic constraints into phrase
translation, not just the constraint of constituent
matching/violation.
The other issue is that during decoding we are
more concerned with the question of phrase co-
hesion, i.e. whether the current phrase can be
translated as a unit or not within particular syntac-
tic contexts (Fox, 2002)2, than that of constituent
matching/violation. Phrase cohesion is one of
the main reasons that we introduce syntactic con-
straints (Cherry, 2008). If a source phrase remains
contiguous after translation, we refer this type of
phrase bracketable, otherwise unbracketable. It
is more desirable to translate a bracketable phrase
than an unbracketable one.
In this paper, we propose a syntax-driven brack-
eting (SDB) model to predict whether a phrase
(a sequence of contiguous words) is bracketable
or not using rich syntactic constraints. We parse
the source language sentences in the word-aligned
training corpus. According to the word align-
ments, we define bracketable and unbracketable
instances. For each of these instances, we auto-
matically extract relevant syntactic features from
the source parse tree as bracketing evidences.
Then we tune the weights of these features us-
ing a maximum entropy (ME) trainer. In this way,
we build two bracketing models: 1) a unary SDB
model (UniSDB) which predicts whether an inde-
pendent phrase is bracketable or not; and 2) a bi-
nary SDB model(BiSDB) which predicts whether
two neighboring phrases are bracketable. Similar
to previous methods, our SDB model is integrated
into the decoder’s log-linear model as a feature so
that we can inherit the idea of soft constraints.
In contrast to the constituent matching/violation
counting (CMVC) (Chiang, 2005; Marton and
Resnik, 2008; Cherry, 2008), our SDB model has
2Here we expand the definition of phrase to include both
syntactic and non-syntactic phrases.
the following advantages
</bodyText>
<listItem confidence="0.817169411764706">
• The SDB model automatically learns syntac-
tic constraints from training data while the
CMVC uses manually defined syntactic con-
straints: constituency matching/violation. In
our SDB model, each learned syntactic fea-
ture from bracketing instances can be consid-
ered as a syntactic constraint. Therefore we
can use thousands of syntactic constraints to
guide phrase translation.
• The SDB model maintains and protects the
strength of the phrase-based approach in a
better way than the CMVC does. It is able to
reward non-syntactic translations by assign-
ing an adequate probability to them if these
translations are appropriate to particular syn-
tactic contexts on the source side, rather than
always punish them.
</listItem>
<bodyText confidence="0.99981732">
We test our SDB model against the baseline
which doest not use any syntactic constraints on
Chinese-to-English translation. To compare with
the CMVC, we also conduct experiments using
(Marton and Resnik, 2008)’s XP+. The XP+ ac-
cumulates a count for each hypothesis whenever
it violates the boundaries of a constituent with a
label from {NP, VP, CP, IP, PP, ADVP, QP, LCP,
DNP}. The XP+ is the best feature among all fea-
tures that Marton and Resnik use for Chinese-to-
English translation. Our experimental results dis-
play that our SDB model achieves a substantial
improvement over the baseline and significantly
outperforms XP+ according to the BLEU metric
(Papineni et al., 2002). In addition, our analysis
shows further evidences of the performance gain
from a different perspective than that of BLEU.
The paper proceeds as follows. In section 2 we
describe how to learn bracketing instances from
a training corpus. In section 3 we elaborate the
syntax-driven bracketing model, including feature
generation and the integration of the SDB model
into phrase-based SMT. In section 4 and 5, we
present our experiments and analysis. And we fi-
nally conclude in section 6.
</bodyText>
<sectionHeader confidence="0.982481" genericHeader="method">
2 The Acquisition of Bracketing
Instances
</sectionHeader>
<bodyText confidence="0.942956">
In this section, we formally define the bracket-
ing instance, comprising two types namely binary
bracketing instance and unary bracketing instance.
</bodyText>
<page confidence="0.998771">
316
</page>
<bodyText confidence="0.999704117647059">
We present an algorithm to automatically ex-
tract these bracketing instances from word-aligned
bilingual corpus where the source language sen-
tences are parsed.
Let c and e be the source sentence and the
target sentence, W be the word alignment be-
tween them, T be the parse tree of c. We
define a binary bracketing instance as a tu-
ple (b,T(ci..j),T(cj+1..k),T(ci..k)) where b E
{bracketable, unbracketable}, ci..j and cj+1..k
are two neighboring source phrases and T(T, s)
(T(s) for short) is a subtree function which returns
the minimal subtree covering the source sequence
s from the source parse tree T. Note that T(ci..k)
includes both T(ci..j) and T(cj+1..k). For the two
neighboring source phrases, the following condi-
tions are satisfied:
</bodyText>
<equation confidence="0.990337333333333">
]eu..v, ep..q E e s.t.
b(m,n)EW,i&lt;m&lt;jHu&lt;n&lt;v (1)
b(m,n)EW,j+1&lt;m&lt;kHp&lt;n&lt;q (2)
</equation>
<bodyText confidence="0.999101481481482">
The above (1) means that there exists a target
phrase eu..v aligned to ci..j and (2) denotes a tar-
get phrase ep..q aligned to cj+1..k. If eu..v and
ep..q are neighboring to each other or all words be-
tween the two phrases are aligned to null, we set
b = bracketable, otherwise b = unbracketable.
From a binary bracketing instance, we derive a
unary bracketing instance (b,T(ci..k)), ignoring
the subtrees T(ci..j) and T(cj+1..k).
Let n be the number of words of c. If we ex-
tract all potential bracketing instances, there will
be o(n2) unary instances and o(n3) binary in-
stances. To keep the number of bracketing in-
stances tractable, we only record 4 representa-
tive bracketing instances for each index j: 1) the
bracketable instance with the minimal T(ci..k), 2)
the bracketable instance with the maximal T(ci..k),
3) the unbracketable instance with the minimal
T(ci..k), and 4) the unbracketable instance with the
maximal T(ci..k).
Figure 1 shows the algorithm to extract brack-
eting instances. Line 3-11 find all potential brack-
eting instances for each (i, j, k) E c but only keep
4 bracketing instances for each index j: two min-
imal and two maximal instances. This algorithm
learns binary bracketing instances, from which we
can derive unary bracketing instances.
</bodyText>
<listItem confidence="0.980937944444444">
1: Input: sentence pair (c, e), the parse tree T of c and the
word alignment W between c and e
2: R := 0
3: for each (i, j, k) E c do
4: if There exist a target phrase eu..v aligned to ci..j and
ep..9 aligned to cj+1..k then
5: Get T(ci..j), T(cj+1..k), and T(ci..k)
6: Determine b according to the relationship between
eu..v and ep..9
7: if T(ci..k) is currently maximal or minimal then
8: Update bracketing instances for index j
9: end if
10: end if
11: end for
12: for each j E c do
13: R := R U {bracketing instances from j}
14: end for
15: Output: bracketing instances R
</listItem>
<figureCaption confidence="0.9716815">
Figure 1: Bracketing Instances Extraction Algo-
rithm.
</figureCaption>
<sectionHeader confidence="0.970287" genericHeader="method">
3 The Syntax-Driven Bracketing Model
</sectionHeader>
<subsectionHeader confidence="0.939554">
3.1 The Model
</subsectionHeader>
<bodyText confidence="0.999827818181818">
Our interest is to automatically detect phrase
bracketing using rich contextual information. We
consider this task as a binary-class classification
problem: whether the current source phrase s is
bracketable (b) within particular syntactic contexts
(T(s)). If two neighboring sub-phrases s1 and s2
are given, we can use more inner syntactic con-
texts to complete this binary classification task.
We construct the syntax-driven bracketing
model within the maximum entropy framework. A
unary SDB model is defined as:
</bodyText>
<equation confidence="0.978200666666667">
PUniSDB(b1T(s),T) =
exp(Pi Bihi(b,T(s),T) (3)
Pb exp(Pi Bihi(b, T(s), T)
</equation>
<bodyText confidence="0.99987325">
where hi E 10, 11 is a binary feature function
which we will describe in the next subsection, and
Bi is the weight of hi. Similarly, a binary SDB
model is defined as:
</bodyText>
<equation confidence="0.966606333333333">
PBiSDB(b1T(s1),T(s2),T(s),T) =
exp(Pi Bihi(b,T(s1),T(s2),T(s),T) (4)
Pb exp(Pi Bihi(b, T(s1), T(s2), T(s), T)
</equation>
<bodyText confidence="0.999980285714286">
The most important advantage of ME-based
SDB model is its capacity of incorporating more
fine-grained contextual features besides the binary
feature that detects constituent boundary violation
or matching. By employing these features, we
can investigate the value of various syntactic con-
straints in phrase translation.
</bodyText>
<page confidence="0.978447">
317
</page>
<figure confidence="0.685814">
(11a11)11 (11b11)11 (11c11)11
</figure>
<figureCaption confidence="0.83059075">
Figure 3: Three scenarios of the relationship be-
tween phrase boundaries and constituent bound-
aries. The gray circles are constituent boundaries
while the black circles are phrase boundaries.
</figureCaption>
<figure confidence="0.999321681818182">
NOP❑
AmOVEPO
NOPO
IEPO
VEPO
VEP❑
NEN11
AOSO
NEN11 NEN11
AmO VOVO
j�i�n�g�f�a�ng�
y�i�
p11o1:lAIcOe[]
s�h sih
s❑
f�e�n�g�su�o�
l�e�
bElOoOcOkO
b�a�o�z�ha
x�i�a
�n�c�h�a�n�g�
bOoOmObO sOcOeCnOeO
</figure>
<figureCaption confidence="0.759876">
In figure 2, the path features are “ADVP
VP”, “VP VP” and “VP IP” for s1, s2 and s
respectively.
Figure 2: Illustration of syntax-driven features
</figureCaption>
<bodyText confidence="0.7789774">
used in SDB. Here we only show the features for
the source phrase s. The triangle, rounded rect-
angle and rectangle denote the rule feature, path
feature and constituent boundary matching feature
respectively.
</bodyText>
<subsectionHeader confidence="0.994694">
3.2 Syntax-Driven Features
</subsectionHeader>
<bodyText confidence="0.99995975">
Let s be the source phrase in question, s1 and s2
be the two neighboring sub-phrases. U(.) is the
root node of T(.). The SDB model exploits various
syntactic features as follows.
</bodyText>
<listItem confidence="0.996228">
• Rule Features (RF)
</listItem>
<bodyText confidence="0.999373666666667">
We use the CFG rules of U(s), U(s1) and
U(s2) as features. These features capture
syntactic “horizontal context” which demon-
strates the expansion trend of the source
phrase s, s1 and s2 on the parse tree.
In figure 2, the CFG rule “ADVP—*AD”,
“VP—*VV AS NP”, and “VP—*ADVP
VP” are used as features for s1, s2 and s
respectively.
</bodyText>
<listItem confidence="0.988649">
• Path Features (PF)
</listItem>
<bodyText confidence="0.95175025">
The tree path U(s1)..U(s) connecting U(s1)
and U(s), U(s2)..U(s) connecting U(s2)
and U(s), and U(s)..p connecting U(s) and
the root node p of the whole parse tree are
used as features. These features provide
syntactic “vertical context” which shows the
generation history of the source phrases on
the parse tree.
</bodyText>
<listItem confidence="0.998341">
• Constituent Boundary Matching Features
(CBMF)
</listItem>
<bodyText confidence="0.9746302">
These features are to capture the relationship
between a source phrase s and T(s) or
T(s)’s subtrees. There are three different
scenarios3: 1) exact match, where s exactly
matches the boundaries of T(s) (figure 3(a)),
</bodyText>
<listItem confidence="0.998394">
2) inside match, where s exactly spans a
sequence of T(s)’s subtrees (figure 3(b)), and
3) crossing, where s crosses the boundaries
of one or two subtrees of T(s) (figure 3(c)).
In the case of 1) or 2), we set the value of
this feature to U(s)-M or U(s)-I respectively.
When s crosses the boundaries of the sub-
constituent El on s’s left, we set the value to
U(El)-LC; If s crosses the boundaries of the
sub-constituent Er on s’s right, we set the
value to U(Er)-RC; If both, we set the value
to U(El)-LC-U(Er)-RC.
</listItem>
<bodyText confidence="0.99841825">
Let’s revisit the Figure 2. The source
phrase s1 exactly matches the constituent
ADVP, therefore CBMF is “ADVP-M”. The
source phrase s2 exactly spans two sub-trees
VV and AS of VP, therefore CBMF is
“VP-I”. Finally, the source phrase s cross
boundaries of the lower VP on the right,
therefore CBMF is “VP-RC”.
</bodyText>
<subsectionHeader confidence="0.928151">
3.3 The Integration of the SDB Model into
Phrase-Based SMT
</subsectionHeader>
<bodyText confidence="0.997930333333333">
We integrate the SDB model into phrase-based
SMT to help decoder perform syntax-driven
phrase translation. In particular, we add a
</bodyText>
<footnote confidence="0.988415">
3The three scenarios that we define here are similar to
those in (L¨u et al., 2002).
</footnote>
<page confidence="0.994175">
318
</page>
<bodyText confidence="0.999976805555555">
new feature into the log-linear translation model:
PSDB(b|T,T(.)). This feature is computed by the
SDB model described in equation (3) or equation
(4), which estimates a probability that a source
span is to be translated as a unit within partic-
ular syntactic contexts. If a source span can be
translated as a unit, the feature will give a higher
probability even though this span violates bound-
aries of a constituent. Otherwise, a lower proba-
bility is given. Through this additional feature, we
want the decoder to prefer hypotheses that trans-
late source spans which can be translated as a unit,
and avoids translating those which are discontinu-
ous after translation. The weight of this new fea-
ture is tuned via MERT, which measures the extent
to which this feature should be trusted.
In this paper, we implement the SDB model in a
state-of-the-art phrase-based system which adapts
a binary bracketing transduction grammar (BTG)
(Wu, 1997) to phrase translation and reordering,
described in (Xiong et al., 2006). Whenever a
BTG merging rule (s —* [s1 s21 or s —* (s1 s2))
is used, the SDB model gives a probability to the
span s covered by the rule, which estimates the
extent to which the span is bracketable. For the
unary SDB model, we only consider the features
from T(s). For the binary SDB model, we use all
features from T(s1), 7-(s2) and T(s) since the bi-
nary SDB model is naturally suitable to the binary
BTG rules.
The SDB model, however, is not only limited
to phrase-based SMT using BTG rules. Since it
is applied on a source span each time, any other
hierarchical phrase-based or syntax-based system
that translates source spans recursively or linearly,
can adopt the SDB model.
</bodyText>
<sectionHeader confidence="0.999644" genericHeader="method">
4 Experiments
</sectionHeader>
<bodyText confidence="0.999976428571429">
We carried out the MT experiments on Chinese-
to-English translation, using (Xiong et al., 2006)’s
system as our baseline system. We modified the
baseline decoder to incorporate our SDB mod-
els as descried in section 3.3. In order to com-
pare with Marton and Resnik’s approach, we also
adapted the baseline decoder to their XP+ feature.
</bodyText>
<subsectionHeader confidence="0.966613">
4.1 Experimental Setup
</subsectionHeader>
<bodyText confidence="0.999939041666667">
In order to obtain syntactic trees for SDB models
and XP+, we parsed source sentences using a lex-
icalized PCFG parser (Xiong et al., 2005). The
parser was trained on the Penn Chinese Treebank
with an F1 score of 79.4%.
All translation models were trained on the FBIS
corpus. We removed 15,250 sentences, for which
the Chinese parser failed to produce syntactic
parse trees. To obtain word-level alignments, we
ran GIZA++ (Och and Ney, 2000) on the remain-
ing corpus in both directions, and applied the
“grow-diag-final” refinement rule (Koehn et al.,
2005) to produce the final many-to-many word
alignments. We built our four-gram language
model using Xinhua section of the English Gi-
gaword corpus (181.1M words) with the SRILM
toolkit (Stolcke, 2002).
For the efficiency of MERT, we built our de-
velopment set (580 sentences) using sentences not
exceeding 50 characters from the NIST MT-02 set.
We evaluated all models on the NIST MT-05 set
using case-sensitive BLEU-4. Statistical signif-
icance in BLEU score differences was tested by
paired bootstrap re-sampling (Koehn, 2004).
</bodyText>
<subsectionHeader confidence="0.98992">
4.2 SDB Training
</subsectionHeader>
<bodyText confidence="0.999996818181818">
We extracted 6.55M bracketing instances from our
training corpus using the algorithm shown in fig-
ure 1, which contains 4.67M bracketable instances
and 1.89M unbracketable instances. From ex-
tracted bracketing instances we generated syntax-
driven features, which include 73,480 rule fea-
tures, 153,614 path features and 336 constituent
boundary matching features. To tune weights of
features, we ran the MaxEnt toolkit (Zhang, 2004)
with iteration number being set to 100 and Gaus-
sian prior to 1 to avoid overfitting.
</bodyText>
<subsectionHeader confidence="0.783359">
4.3 Results
</subsectionHeader>
<bodyText confidence="0.999901823529412">
We ran the MERT module with our decoders to
tune the feature weights. The values are shown
in Table 1. The PSDB receives the largest feature
weight, 0.29 for UniSDB and 0.38 for BiSDB, in-
dicating that the SDB models exert a nontrivial im-
pact on decoder.
In Table 2, we present our results. Like (Mar-
ton and Resnik, 2008), we find that the XP+ fea-
ture obtains a significant improvement of 1.08
BLEU over the baseline. However, using all
syntax-driven features described in section 3.2,
our SDB models achieve larger improvements
of up to 1.67 BLEU. The binary SDB (BiSDB)
model statistically significantly outperforms Mar-
ton and Resnik’s XP+ by an absolute improvement
of 0.59 (relatively 2%). It is also marginally better
than the unary SDB model.
</bodyText>
<page confidence="0.998152">
319
</page>
<table confidence="0.999745833333333">
System P(c|e) P(e|c) P.(c|e) P.(e|c) Features Pr(e) Word Phr. XP+ PSDB
Plm(e)
Baseline 0.041 0.030 0.006 0.065 0.20 0.35 0.19 -0.12 — —
XP+ 0.002 0.049 0.046 0.044 0.17 0.29 0.16 0.12 -0.12 —
UniSDB 0.023 0.051 0.055 0.012 0.21 0.20 0.12 0.04 — 0.29
BiSDB 0.016 0.032 0.027 0.013 0.13 0.23 0.08 0.09 — 0.38
</table>
<tableCaption confidence="0.945175333333333">
Table 1: Feature weights obtained by MERT on the development set. The first 4 features are the phrase
translation probabilities in both directions and the lexical translation probabilities in both directions. Plm
= language model; Pr = MaxEnt-based reordering model; Word = word bonus; Phr = phrase bonus.
</tableCaption>
<table confidence="0.999510833333333">
BLEU-n n-gram Precision
System 4 1 2 3 4 5 6 7 8
Baseline 0.2612 0.71 0.36 0.18 0.10 0.054 0.030 0.016 0.009
XP+ 0.2720** 0.72 0.37 0.19 0.11 0.060 0.035 0.021 0.012
UniSDB 0.2762**+ 0.72 0.37 0.20 0.11 0.062 0.035 0.020 0.011
BiSDB 0.2779**++ 0.72 0.37 0.20 0.11 0.065 0.038 0.022 0.014
</table>
<tableCaption confidence="0.9605355">
Table 2: Results on the test set. **: significantly better than baseline (p &lt; 0.01). + or ++: significantly
better than Marton and Resnik’s XP+ (p &lt; 0.05 or p &lt; 0.01, respectively).
</tableCaption>
<sectionHeader confidence="0.965099" genericHeader="method">
5 Analysis
</sectionHeader>
<bodyText confidence="0.9999028">
In this section, we present analysis to perceive the
influence mechanism of the SDB model on phrase
translation by studying the effects of syntax-driven
features and differences of 1-best translation out-
puts.
</bodyText>
<subsectionHeader confidence="0.999575">
5.1 Effects of Syntax-Driven Features
</subsectionHeader>
<bodyText confidence="0.999835">
We conducted further experiments using individ-
ual syntax-driven features and their combinations.
Table 3 shows the results, from which we have the
following key observations.
</bodyText>
<listItem confidence="0.95725275">
• The constituent boundary matching feature
(CBMF) is a very important feature, which
by itself achieves significant improvement
over the baseline (up to 1.13 BLEU). Both
our CBMF and Marton and Resnik’s XP+
feature focus on the relationship between a
source phrase and a constituent. Their signifi-
cant contribution to the improvement implies
that this relationship is an important syntactic
constraint for phrase translation.
• Adding more features, such as path feature
and rule feature, achieves further improve-
ments. This demonstrates the advantage of
using more syntactic constraints in the SDB
model, compared with Marton and Resnik’s
XP+.
</listItem>
<table confidence="0.9998225">
Features UniSDB BLEU-4
BiSDB
PF + RF 0.2555 0.2644*@@
PF 0.2596 0.2671**@@
CBMF 0.2678** 0.2725**@
RF + CBMF 0.2737** 0.2780**++@@
PF + CBMF 0.2755**+ 0.2782**++@−
RF + PF + CBMF 0.2762**+ 0.2779**++
</table>
<tableCaption confidence="0.998812">
Table 3: Results of different feature sets. * or **:
</tableCaption>
<bodyText confidence="0.813641">
significantly better than baseline (p &lt; 0.05 or p &lt;
0.01, respectively). + or ++: significantly better
than XP+ (p &lt; 0.05 or p &lt; 0.01, respectively).
@−: almost significantly better than its UniSDB
counterpart (p &lt; 0.075). @ or @@: significantly
better than its UniSDB counterpart (p &lt; 0.05 or
p &lt; 0.01, respectively).
</bodyText>
<listItem confidence="0.936829">
• In most cases, the binary SDB is constantly
significantly better than the unary SDB, sug-
gesting that inner contexts are useful in pre-
dicting phrase bracketing.
</listItem>
<subsectionHeader confidence="0.999126">
5.2 Beyond BLEU
</subsectionHeader>
<bodyText confidence="0.999853428571429">
We want to further study the happenings after we
integrate the constraint feature (our SDB model
and Marton and Resnik’s XP+) into the log-linear
translation model. In particular, we want to inves-
tigate: to what extent syntactic constraints change
translation outputs? And in what direction the
changes take place? Since BLEU is not sufficient
</bodyText>
<page confidence="0.983474">
320
</page>
<figure confidence="0.95927">
System
CCM Rate (%)
Baseline
XP+
BiSDB
43.5
74.5
72.4
</figure>
<tableCaption confidence="0.97938">
Table 4: Consistent constituent matching rates re-
</tableCaption>
<table confidence="0.9046396">
ported on 1-best translation outputs.
CCM Rates (%)
System &lt;6 6-10 11-15 16-20 &gt;20
XP+ 75.2 70.9 71.0 76.2 82.2
BiSDB 69.3 74.7 74.2 80.0 85.6
</table>
<tableCaption confidence="0.968038">
Table 6: Consistent constituent matching rates for
structures with different spans.
</tableCaption>
<bodyText confidence="0.999737538461538">
to provide such insights, we introduce a new sta-
tistical metric which measures the proportion of
syntactic constituents 4 whose boundaries are con-
sistently matched by decoder during translation.
This proportion, which we call consistent con-
stituent matching (CCM) rate , reflects the ex-
tent to which the translation output respects the
source parse tree.
In order to calculate this rate, we output transla-
tion results as well as phrase alignments found by
decoders. Then for each multi-branch constituent
cz spanning from i to j on the source side, we
check the following conditions.
</bodyText>
<listItem confidence="0.8438652">
• If its boundaries i and j are aligned to phrase
segmentation boundaries found by decoder.
• If all target phrases inside cz’s target span 5
are aligned to the source phrases within cz
and not to the phrases outside cz .
</listItem>
<bodyText confidence="0.996375277777778">
If both conditions are satisfied, the constituent cz
is consistently matched by decoder.
Table 4 shows the consistent constituent match-
ing rates. Without using any source-side syntac-
tic information, the baseline obtains a low CCM
rate of 43.53%, indicating that the baseline de-
coder violates the source parse tree more than it
respects the source structure. The translation out-
put described in section 1 is actually generated by
the baseline decoder, where the second NP phrase
boundaries are violated.
By integrating syntactic constraints into decod-
ing, we can see that both Marton and Resnik’s
XP+ and our SDB model achieve a significantly
higher constituent matching rate, suggesting that
they are more likely to respect the source struc-
ture. The examples in Table 5 show that the de-
coder is able to generate better translations if it is
</bodyText>
<footnote confidence="0.8675514">
4We only consider multi-branch constituents.
5Given a phrase alignment P = {cgf +-+ eqp}, if the seg-
mentation within cji defined by P is cji = cj1
i1 ...cjk
ik , and
</footnote>
<page confidence="0.266245">
cjr
</page>
<bodyText confidence="0.997525863636364">
ir +-+ evrur E P, 1 &lt; r &lt; k, we define the target span of cji
as a pair where the first element is min(eu1...euk) and the
second element is max(ev1...evk), similar to (Fox, 2002).
faithful to the source parse tree by using syntactic
constraints.
We further conducted a deep comparison of
translation outputs of BiSDB vs. XP+ with re-
gard to constituent matching and violation. We
found two significant differences that may explain
why our BiSDB outperforms XP+. First, although
the overall CCM rate of XP+ is higher than that
of BiSDB, BiSDB obtains higher CCM rates for
long-span structures than XP+ does, which are
shown in Table 6. Generally speaking, viola-
tions of long-span constituents have a more neg-
ative impact on performance than short-span vio-
lations if these violations are toxic. This explains
why BiSDB achieves relatively higher precision
improvements for higher n-grams over XP+, as
shown in Table 3.
Second, compared with XP+ that only punishes
constituent boundary violations, our SDB model
is able to encourage violations if these violations
are done on bracketable phrases. We observed in
many cases that by violating constituent bound-
aries BiSDB produces better translations than XP+
does, which on the contrary matches these bound-
aries. Still consider the example shown in section
1. The following translations are found by XP+
and BiSDB respectively.
XP+: [to/把 ([set up/设立 [for the/为 [naviga-
tion/航海 section/节]]] on July 11/7月11日)]
BiSDB: [to/把 ([[set up/设立 a/为] [marine/航海
festival/节]] on July 11/7月11日)]
XP+ here matches all constituent boundaries while
BiSDB violates the PP constituent to translate the
non-syntactic phrase “设立 为”. Table 7 shows
more examples. From these examples, we clearly
see that appropriate violations are helpful and even
necessary for generating better translations. By
allowing appropriate violations to translate non-
syntactic phrases according to particular syntac-
tic contexts, our SDB model better inherits the
strength of phrase-based approach than XP+.
</bodyText>
<page confidence="0.995797">
321
</page>
<table confidence="0.987273428571429">
Src: [[为 [印度 洋 灾区 民众]NP ]PP [奉献 [自己]NP [一 份 爱心]NP ]VP ]VP
Ref: show their loving hearts to people in the Indian Ocean disaster areas
Baseline: hlove/爱心 [for the/为 h[people/民众 [to/奉献 [own/自己 a report/一份]]]i hin/灾区 the Indian Ocean/印
度洋i]i
XP+: h[contribute/奉献 [its/自己 [part/一份 love/爱心]]] [for/为 hthe people/民众 hin/灾区 the Indian Ocean/印度洋ii]i
BiSDB: h[[[contribute/奉献 its/自己] part/一份] love/爱心] [for/为 hthe people/民众 hin/灾区 the Indian Ocean印度洋ii]i
Src: [五角大厦 [已]ADVP [派遣 [[二十 架]QP 飞机]NP [至 南亚]PP]VP]IP [,]PU [其中 包括...]IP
Ref: The Pentagon has dispatched 20 airplanes to South Asia, including...
Baseline: [[The Pentagon/五角大厦 has sent/已派遣] [h[to/至 [[South Asia/南亚 ,/,] including/其中包括]] [20/二
十 plane/架飞机]i]]
XP+: [The Pentagon/五角大厦 [has/已 [sent/派遣 [[20/二十 planes/架飞机] [to/至 South Asia/南亚]]]]] [,/,
[including/其中包括...]]
BiSDB: [The Pentagon/五角大厦 [has sent/已派遣 [[20/二十 planes/架飞机] [to/至 South Asia/南亚]]] [,/, [in-
cluding/其中包括...]]
</table>
<tableCaption confidence="0.955222">
Table 5: Translation examples showing that both XP+ and BiSDB produce better translations than the
baseline, which inappropriately violates constituent boundaries (within underlined phrases).
</tableCaption>
<figure confidence="0.726096166666667">
Src: [[在 [[[美国国务院 与 鲍尔]NP [短暂]ADJP [会谈]NP]NP 后]LCP]PP 表示]VP
Ref: said after a brief discussion with Powell at the US State Department
XP+: [hafter/后 hh[a brief/短暂 meeting/会谈] [with/与 Powell/鲍尔]i [in/在 the US State Department/美国国
务院]i said/表示]
BiSDB: hsaid after/后 表示 h[a brief/短暂 meeting/会谈] h with Powell/与 鲍尔 [at/在 the State Department of the
United States/美国国务院]iii
Src: [向 [[建立 [未来 民主 政治]NP]VP]IP]PP [迈出 了 [关键性 的 一 步]NP]VP
Ref: took a key step towards building future democratic politics
XP+: h[a/了 [key/关键性 step/的一步]] hforward/迈出 [to/向 [a/建立 [future/未来 political democracy/民主政
治]]]ii
BiSDB: h[made a/迈出了 [key/关键性 step/的一步]] [towards establishing a/向 建立 hdemocratic politics/民主政
治 in the future/未来i]i
</figure>
<tableCaption confidence="0.96102">
Table 7: Translation examples showing that BiSDB produces better translations than XP+ via appropriate
violations of constituent boundaries (within double-underlined phrases).
</tableCaption>
<sectionHeader confidence="0.998402" genericHeader="conclusions">
6 Conclusion
</sectionHeader>
<bodyText confidence="0.999945333333333">
In this paper, we presented a syntax-driven brack-
eting model that automatically learns bracketing
knowledge from training corpus. With this knowl-
edge, the model is able to predict whether source
phrases can be translated together, regardless of
matching or crossing syntactic constituents. We
integrate this model into phrase-based SMT to
increase its capacity of linguistically motivated
translation without undermining its strengths. Ex-
periments show that our model achieves substan-
tial improvements over baseline and significantly
outperforms (Marton and Resnik, 2008)’s XP+.
Compared with previous constituency feature,
our SDB model is capable of incorporating more
syntactic constraints, and rewarding necessary vi-
olations of the source parse tree. Marton and
Resnik (2008) find that their constituent con-
straints are sensitive to language pairs. In the fu-
ture work, we will use other language pairs to test
our models so that we could know whether our
method is language-independent.
</bodyText>
<sectionHeader confidence="0.999259" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999867625">
Colin Cherry. 2008. Cohesive Phrase-based Decoding
for Statistical Machine Translation. In Proceedings
ofACL.
David Chiang. 2005. A Hierarchical Phrase-based
Model for Statistical Machine Translation. In Pro-
ceedings ofACL, pages 263–270.
David Chiang, Yuval Marton and Philip Resnik. 2008.
Online Large-Margin Training of Syntactic and
Structural Translation Features. In Proceedings of
EMNLP.
Heidi J. Fox 2002. Phrasal Cohesion and Statistical
Machine Translation. In Proceedings of EMNLP,
pages 304–311.
Philipp Koehn, Franz Joseph Och, and Daniel Marcu.
2003. Statistical Phrase-based Translation. In Pro-
ceedings ofHLT-NAACL.
</reference>
<page confidence="0.979843">
322
</page>
<reference confidence="0.998196142857143">
Philipp Koehn. 2004. Statistical Significance Tests for
Machine Translation Evaluation. In Proceedings of
EMNLP.
Philipp Koehn, Amittai Axelrod, Alexandra Birch
Mayne, Chris Callison-Burch, Miles Osborne and
David Talbot. 2005. Edinburgh System Descrip-
tion for the 2005 IWSLT Speech Translation Eval-
uation. In International Workshop on Spoken Lan-
guage Translation.
Yajuan L¨u, Sheng Li, Tiezhun Zhao and Muyun Yang.
2002. Learning Chinese Bracketing Knowledge
Based on a Bilingual Language Model. In Proceed-
ings of COLING.
Yuval Marton and Philip Resnik. 2008. Soft Syntactic
Constraints for Hierarchical Phrase-Based Transla-
tion. In Proceedings ofACL.
Franz Josef Och and Hermann Ney. 2000. Improved
Statistical Alignment Models. In Proceedings of
ACL 2000.
Franz Josef Och. 2003. Minimum Error Rate Training
in Statistical Machine Translation. In Proceedings
ofACL 2003.
Kishore Papineni, Salim Roukos, Todd Ward, and Wei-
Jing Zhu. 2002. Bleu: a Method for Automatically
Evaluation of Machine Translation. In Proceedings
ofACL.
Andreas Stolcke. 2002. SRILM - an Extensible Lan-
guage Modeling Toolkit. In Proceedings ofInterna-
tional Conference on Spoken Language Processing,
volume 2, pages 901-904.
Dekai Wu. 1997. Stochastic Inversion Transduction
Grammars and Bilingual Parsing of Parallel Cor-
pora. Computational Linguistics, 23(3):377-403.
Deyi Xiong, Shuanglong Li, Qun Liu, Shouxun Lin,
Yueliang Qian. 2005. Parsing the Penn Chinese
Treebank with Semantic Knowledge. In Proceed-
ings ofIJCNLP, Jeju Island, Korea.
Deyi Xiong, Qun Liu and Shouxun Lin. 2006. Max-
imum Entropy Based Phrase Reordering Model for
Statistical Machine Translation. In Proceedings of
ACL-COLING 2006.
Deyi Xiong, Min Zhang, Aiti Aw, and Haizhou Li.
2008. Linguistically Annotated BTG for Statistical
Machine Translation. In Proceedings of COLING
2008.
Le Zhang. 2004. Maximum Entropy Model-
ing Tooklkit for Python and C++. Available at
http://homepages.inf.ed.ac.uk/s0450736
/maxent toolkit.html.
</reference>
<page confidence="0.999281">
323
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.351040">
<title confidence="0.999909">A Syntax-Driven Bracketing Model for Phrase-Based Translation</title>
<author confidence="0.975743">Deyi Xiong</author>
<author confidence="0.975743">Min Zhang</author>
<author confidence="0.975743">Aiti Aw</author>
<author confidence="0.975743">Haizhou Li</author>
<affiliation confidence="0.981678">Human Language Technology Institute for Infocomm Research</affiliation>
<address confidence="0.385483">1 Fusionopolis Way, #21-01 South Connexis, Singapore 138632</address>
<email confidence="0.741876">mzhang,aaiti,</email>
<abstract confidence="0.99955015">Syntactic analysis influences the way in which the source sentence is translated. Previous efforts add syntactic constraints to phrase-based translation by directly rewarding/punishing a hypothesis whenever it matches/violates source-side constituents. We present a new model that automatically learns syntactic constraints, including but not limited to constituent matching/violation, from training corpus. The model brackets a source phrase as to whether it satisfies the learnt syntactic constraints. The bracketed phrases are then translated as a whole unit by the decoder. Experimental results and analysis show that the new model outperforms other previous methods and achieves a substantial improvement over the baseline which is not syntactically informed.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Colin Cherry</author>
</authors>
<title>Cohesive Phrase-based Decoding for Statistical Machine Translation.</title>
<date>2008</date>
<booktitle>In Proceedings ofACL.</booktitle>
<contexts>
<context position="3227" citStr="Cherry (2008)" startWordPosition="478" endWordPosition="479">uent translations and reorderings. This, unfortunately, significantly jeopardizes performance (Koehn et al., 2003; Xiong et al., 2008) because by integrating syntactic constraint into decoding as a hard constraint, it simply prohibits any other useful non-syntactic translations which violate constituent boundaries. To better leverage syntactic constraint yet still allow non-syntactic translations, Chiang (2005) introduces a count for each hypothesis and accumulates it whenever the hypothesis exactly matches syntactic boundaries on the source side. On the contrary, Marton and Resnik (2008) and Cherry (2008) accumulate a count whenever hypotheses violate constituent boundaries. These constituent matching/violation counts are used as a feature in the decoder’s log-linear model and their weights are tuned via minimal error rate training (MERT) (Och, 2003). In this way, syntactic constraint is integrated into decoding as a soft constraint to enable the decoder to reward hypotheses that respect syntactic analyses or to pe1This word can be translated into “section”, “festival”, and “knot” in different contexts. 315 Proceedings of the 47th Annual Meeting of the ACL and the 4th IJCNLP of the AFNLP, page</context>
<context position="4896" citStr="Cherry, 2008" startWordPosition="728" endWordPosition="729">) find that some constituency types favor matching the source parse while others encourage violations. Therefore it is necessary to integrate more syntactic constraints into phrase translation, not just the constraint of constituent matching/violation. The other issue is that during decoding we are more concerned with the question of phrase cohesion, i.e. whether the current phrase can be translated as a unit or not within particular syntactic contexts (Fox, 2002)2, than that of constituent matching/violation. Phrase cohesion is one of the main reasons that we introduce syntactic constraints (Cherry, 2008). If a source phrase remains contiguous after translation, we refer this type of phrase bracketable, otherwise unbracketable. It is more desirable to translate a bracketable phrase than an unbracketable one. In this paper, we propose a syntax-driven bracketing (SDB) model to predict whether a phrase (a sequence of contiguous words) is bracketable or not using rich syntactic constraints. We parse the source language sentences in the word-aligned training corpus. According to the word alignments, we define bracketable and unbracketable instances. For each of these instances, we automatically ext</context>
<context position="6180" citStr="Cherry, 2008" startWordPosition="928" endWordPosition="929">ng evidences. Then we tune the weights of these features using a maximum entropy (ME) trainer. In this way, we build two bracketing models: 1) a unary SDB model (UniSDB) which predicts whether an independent phrase is bracketable or not; and 2) a binary SDB model(BiSDB) which predicts whether two neighboring phrases are bracketable. Similar to previous methods, our SDB model is integrated into the decoder’s log-linear model as a feature so that we can inherit the idea of soft constraints. In contrast to the constituent matching/violation counting (CMVC) (Chiang, 2005; Marton and Resnik, 2008; Cherry, 2008), our SDB model has 2Here we expand the definition of phrase to include both syntactic and non-syntactic phrases. the following advantages • The SDB model automatically learns syntactic constraints from training data while the CMVC uses manually defined syntactic constraints: constituency matching/violation. In our SDB model, each learned syntactic feature from bracketing instances can be considered as a syntactic constraint. Therefore we can use thousands of syntactic constraints to guide phrase translation. • The SDB model maintains and protects the strength of the phrase-based approach in a</context>
</contexts>
<marker>Cherry, 2008</marker>
<rawString>Colin Cherry. 2008. Cohesive Phrase-based Decoding for Statistical Machine Translation. In Proceedings ofACL.</rawString>
</citation>
<citation valid="true">
<authors>
<author>David Chiang</author>
</authors>
<title>A Hierarchical Phrase-based Model for Statistical Machine Translation.</title>
<date>2005</date>
<booktitle>In Proceedings ofACL,</booktitle>
<pages>263--270</pages>
<contexts>
<context position="3028" citStr="Chiang (2005)" startWordPosition="447" endWordPosition="448">only on phrase movement but also on the lexical selection for the multi-meaning word “节”1. To avert such errors, the decoder can fully respect linguistic structures by only allowing syntactic constituent translations and reorderings. This, unfortunately, significantly jeopardizes performance (Koehn et al., 2003; Xiong et al., 2008) because by integrating syntactic constraint into decoding as a hard constraint, it simply prohibits any other useful non-syntactic translations which violate constituent boundaries. To better leverage syntactic constraint yet still allow non-syntactic translations, Chiang (2005) introduces a count for each hypothesis and accumulates it whenever the hypothesis exactly matches syntactic boundaries on the source side. On the contrary, Marton and Resnik (2008) and Cherry (2008) accumulate a count whenever hypotheses violate constituent boundaries. These constituent matching/violation counts are used as a feature in the decoder’s log-linear model and their weights are tuned via minimal error rate training (MERT) (Och, 2003). In this way, syntactic constraint is integrated into decoding as a soft constraint to enable the decoder to reward hypotheses that respect syntactic </context>
<context position="6140" citStr="Chiang, 2005" startWordPosition="922" endWordPosition="923"> from the source parse tree as bracketing evidences. Then we tune the weights of these features using a maximum entropy (ME) trainer. In this way, we build two bracketing models: 1) a unary SDB model (UniSDB) which predicts whether an independent phrase is bracketable or not; and 2) a binary SDB model(BiSDB) which predicts whether two neighboring phrases are bracketable. Similar to previous methods, our SDB model is integrated into the decoder’s log-linear model as a feature so that we can inherit the idea of soft constraints. In contrast to the constituent matching/violation counting (CMVC) (Chiang, 2005; Marton and Resnik, 2008; Cherry, 2008), our SDB model has 2Here we expand the definition of phrase to include both syntactic and non-syntactic phrases. the following advantages • The SDB model automatically learns syntactic constraints from training data while the CMVC uses manually defined syntactic constraints: constituency matching/violation. In our SDB model, each learned syntactic feature from bracketing instances can be considered as a syntactic constraint. Therefore we can use thousands of syntactic constraints to guide phrase translation. • The SDB model maintains and protects the st</context>
</contexts>
<marker>Chiang, 2005</marker>
<rawString>David Chiang. 2005. A Hierarchical Phrase-based Model for Statistical Machine Translation. In Proceedings ofACL, pages 263–270.</rawString>
</citation>
<citation valid="true">
<authors>
<author>David Chiang</author>
<author>Yuval Marton</author>
<author>Philip Resnik</author>
</authors>
<title>Online Large-Margin Training of Syntactic and Structural Translation Features.</title>
<date>2008</date>
<booktitle>In Proceedings of EMNLP.</booktitle>
<marker>Chiang, Marton, Resnik, 2008</marker>
<rawString>David Chiang, Yuval Marton and Philip Resnik. 2008. Online Large-Margin Training of Syntactic and Structural Translation Features. In Proceedings of EMNLP.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Heidi J Fox</author>
</authors>
<title>Phrasal Cohesion and Statistical Machine Translation.</title>
<date>2002</date>
<booktitle>In Proceedings of EMNLP,</booktitle>
<pages>304--311</pages>
<contexts>
<context position="4751" citStr="Fox, 2002" startWordPosition="707" endWordPosition="708">n not always guarantee a good translation, and violating syntactic structure does not always induce a bad translation. Marton and Resnik (2008) find that some constituency types favor matching the source parse while others encourage violations. Therefore it is necessary to integrate more syntactic constraints into phrase translation, not just the constraint of constituent matching/violation. The other issue is that during decoding we are more concerned with the question of phrase cohesion, i.e. whether the current phrase can be translated as a unit or not within particular syntactic contexts (Fox, 2002)2, than that of constituent matching/violation. Phrase cohesion is one of the main reasons that we introduce syntactic constraints (Cherry, 2008). If a source phrase remains contiguous after translation, we refer this type of phrase bracketable, otherwise unbracketable. It is more desirable to translate a bracketable phrase than an unbracketable one. In this paper, we propose a syntax-driven bracketing (SDB) model to predict whether a phrase (a sequence of contiguous words) is bracketable or not using rich syntactic constraints. We parse the source language sentences in the word-aligned traini</context>
<context position="25386" citStr="Fox, 2002" startWordPosition="4097" endWordPosition="4098">ton and Resnik’s XP+ and our SDB model achieve a significantly higher constituent matching rate, suggesting that they are more likely to respect the source structure. The examples in Table 5 show that the decoder is able to generate better translations if it is 4We only consider multi-branch constituents. 5Given a phrase alignment P = {cgf +-+ eqp}, if the segmentation within cji defined by P is cji = cj1 i1 ...cjk ik , and cjr ir +-+ evrur E P, 1 &lt; r &lt; k, we define the target span of cji as a pair where the first element is min(eu1...euk) and the second element is max(ev1...evk), similar to (Fox, 2002). faithful to the source parse tree by using syntactic constraints. We further conducted a deep comparison of translation outputs of BiSDB vs. XP+ with regard to constituent matching and violation. We found two significant differences that may explain why our BiSDB outperforms XP+. First, although the overall CCM rate of XP+ is higher than that of BiSDB, BiSDB obtains higher CCM rates for long-span structures than XP+ does, which are shown in Table 6. Generally speaking, violations of long-span constituents have a more negative impact on performance than short-span violations if these violatio</context>
</contexts>
<marker>Fox, 2002</marker>
<rawString>Heidi J. Fox 2002. Phrasal Cohesion and Statistical Machine Translation. In Proceedings of EMNLP, pages 304–311.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Philipp Koehn</author>
<author>Franz Joseph Och</author>
<author>Daniel Marcu</author>
</authors>
<title>Statistical Phrase-based Translation.</title>
<date>2003</date>
<booktitle>In Proceedings ofHLT-NAACL.</booktitle>
<contexts>
<context position="1334" citStr="Koehn et al., 2003" startWordPosition="185" endWordPosition="188">rce phrase as to whether it satisfies the learnt syntactic constraints. The bracketed phrases are then translated as a whole unit by the decoder. Experimental results and analysis show that the new model outperforms other previous methods and achieves a substantial improvement over the baseline which is not syntactically informed. 1 Introduction The phrase-based approach is widely adopted in statistical machine translation (SMT). It segments a source sentence into a sequence of phrases, then translates and reorder these phrases in the target. In such a process, original phrase-based decoding (Koehn et al., 2003) does not take advantage of any linguistic analysis, which, however, is broadly used in rule-based approaches. Since it is not linguistically motivated, original phrasebased decoding might produce ungrammatical or even wrong translations. Consider the following Chinese fragment with its parse tree: Src: [把 [[7月 11日]NP [设立 [为 [航海 节]NP ]PP ]VP ]IP ]VP Ref: established July 11 as Sailing Festival day Output: [to/把 [([set up/设 立 [for/为 navigation/航海]] on July 11/7月11日) knots/节]] The output is generated from a phrase-based system which does not involve any syntactic analysis. Here we use “[]” (stra</context>
<context position="2727" citStr="Koehn et al., 2003" startWordPosition="404" endWordPosition="407">er inadequately breaks up the second NP phrase and translates the two words “航海” and “节” separately. However, the parse tree of the source fragment constrains the phrase “航海 节” to be translated as a unit. Without considering syntactic constraints from the parse tree, the decoder makes wrong decisions not only on phrase movement but also on the lexical selection for the multi-meaning word “节”1. To avert such errors, the decoder can fully respect linguistic structures by only allowing syntactic constituent translations and reorderings. This, unfortunately, significantly jeopardizes performance (Koehn et al., 2003; Xiong et al., 2008) because by integrating syntactic constraint into decoding as a hard constraint, it simply prohibits any other useful non-syntactic translations which violate constituent boundaries. To better leverage syntactic constraint yet still allow non-syntactic translations, Chiang (2005) introduces a count for each hypothesis and accumulates it whenever the hypothesis exactly matches syntactic boundaries on the source side. On the contrary, Marton and Resnik (2008) and Cherry (2008) accumulate a count whenever hypotheses violate constituent boundaries. These constituent matching/v</context>
</contexts>
<marker>Koehn, Och, Marcu, 2003</marker>
<rawString>Philipp Koehn, Franz Joseph Och, and Daniel Marcu. 2003. Statistical Phrase-based Translation. In Proceedings ofHLT-NAACL.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Philipp Koehn</author>
</authors>
<title>Statistical Significance Tests for Machine Translation Evaluation.</title>
<date>2004</date>
<booktitle>In Proceedings of EMNLP.</booktitle>
<contexts>
<context position="18504" citStr="Koehn, 2004" startWordPosition="2954" endWordPosition="2955"> in both directions, and applied the “grow-diag-final” refinement rule (Koehn et al., 2005) to produce the final many-to-many word alignments. We built our four-gram language model using Xinhua section of the English Gigaword corpus (181.1M words) with the SRILM toolkit (Stolcke, 2002). For the efficiency of MERT, we built our development set (580 sentences) using sentences not exceeding 50 characters from the NIST MT-02 set. We evaluated all models on the NIST MT-05 set using case-sensitive BLEU-4. Statistical significance in BLEU score differences was tested by paired bootstrap re-sampling (Koehn, 2004). 4.2 SDB Training We extracted 6.55M bracketing instances from our training corpus using the algorithm shown in figure 1, which contains 4.67M bracketable instances and 1.89M unbracketable instances. From extracted bracketing instances we generated syntaxdriven features, which include 73,480 rule features, 153,614 path features and 336 constituent boundary matching features. To tune weights of features, we ran the MaxEnt toolkit (Zhang, 2004) with iteration number being set to 100 and Gaussian prior to 1 to avoid overfitting. 4.3 Results We ran the MERT module with our decoders to tune the fe</context>
</contexts>
<marker>Koehn, 2004</marker>
<rawString>Philipp Koehn. 2004. Statistical Significance Tests for Machine Translation Evaluation. In Proceedings of EMNLP.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Philipp Koehn</author>
<author>Amittai Axelrod</author>
<author>Alexandra Birch Mayne</author>
<author>Chris Callison-Burch</author>
<author>Miles Osborne</author>
<author>David Talbot</author>
</authors>
<title>IWSLT Speech Translation Evaluation.</title>
<date>2005</date>
<booktitle>Edinburgh System Description for the</booktitle>
<contexts>
<context position="17983" citStr="Koehn et al., 2005" startWordPosition="2871" endWordPosition="2874">e baseline decoder to their XP+ feature. 4.1 Experimental Setup In order to obtain syntactic trees for SDB models and XP+, we parsed source sentences using a lexicalized PCFG parser (Xiong et al., 2005). The parser was trained on the Penn Chinese Treebank with an F1 score of 79.4%. All translation models were trained on the FBIS corpus. We removed 15,250 sentences, for which the Chinese parser failed to produce syntactic parse trees. To obtain word-level alignments, we ran GIZA++ (Och and Ney, 2000) on the remaining corpus in both directions, and applied the “grow-diag-final” refinement rule (Koehn et al., 2005) to produce the final many-to-many word alignments. We built our four-gram language model using Xinhua section of the English Gigaword corpus (181.1M words) with the SRILM toolkit (Stolcke, 2002). For the efficiency of MERT, we built our development set (580 sentences) using sentences not exceeding 50 characters from the NIST MT-02 set. We evaluated all models on the NIST MT-05 set using case-sensitive BLEU-4. Statistical significance in BLEU score differences was tested by paired bootstrap re-sampling (Koehn, 2004). 4.2 SDB Training We extracted 6.55M bracketing instances from our training co</context>
</contexts>
<marker>Koehn, Axelrod, Mayne, Callison-Burch, Osborne, Talbot, 2005</marker>
<rawString>Philipp Koehn, Amittai Axelrod, Alexandra Birch Mayne, Chris Callison-Burch, Miles Osborne and David Talbot. 2005. Edinburgh System Description for the 2005 IWSLT Speech Translation Evaluation. In International Workshop on Spoken Language Translation.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Yajuan L¨u</author>
<author>Sheng Li</author>
<author>Tiezhun Zhao</author>
<author>Muyun Yang</author>
</authors>
<title>Learning Chinese Bracketing Knowledge Based on a Bilingual Language Model.</title>
<date>2002</date>
<booktitle>In Proceedings of COLING.</booktitle>
<marker>L¨u, Li, Zhao, Yang, 2002</marker>
<rawString>Yajuan L¨u, Sheng Li, Tiezhun Zhao and Muyun Yang. 2002. Learning Chinese Bracketing Knowledge Based on a Bilingual Language Model. In Proceedings of COLING.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Yuval Marton</author>
<author>Philip Resnik</author>
</authors>
<title>Soft Syntactic Constraints for Hierarchical Phrase-Based Translation.</title>
<date>2008</date>
<booktitle>In Proceedings ofACL.</booktitle>
<contexts>
<context position="3209" citStr="Marton and Resnik (2008)" startWordPosition="473" endWordPosition="476">ly allowing syntactic constituent translations and reorderings. This, unfortunately, significantly jeopardizes performance (Koehn et al., 2003; Xiong et al., 2008) because by integrating syntactic constraint into decoding as a hard constraint, it simply prohibits any other useful non-syntactic translations which violate constituent boundaries. To better leverage syntactic constraint yet still allow non-syntactic translations, Chiang (2005) introduces a count for each hypothesis and accumulates it whenever the hypothesis exactly matches syntactic boundaries on the source side. On the contrary, Marton and Resnik (2008) and Cherry (2008) accumulate a count whenever hypotheses violate constituent boundaries. These constituent matching/violation counts are used as a feature in the decoder’s log-linear model and their weights are tuned via minimal error rate training (MERT) (Och, 2003). In this way, syntactic constraint is integrated into decoding as a soft constraint to enable the decoder to reward hypotheses that respect syntactic analyses or to pe1This word can be translated into “section”, “festival”, and “knot” in different contexts. 315 Proceedings of the 47th Annual Meeting of the ACL and the 4th IJCNLP </context>
<context position="6165" citStr="Marton and Resnik, 2008" startWordPosition="924" endWordPosition="927">ce parse tree as bracketing evidences. Then we tune the weights of these features using a maximum entropy (ME) trainer. In this way, we build two bracketing models: 1) a unary SDB model (UniSDB) which predicts whether an independent phrase is bracketable or not; and 2) a binary SDB model(BiSDB) which predicts whether two neighboring phrases are bracketable. Similar to previous methods, our SDB model is integrated into the decoder’s log-linear model as a feature so that we can inherit the idea of soft constraints. In contrast to the constituent matching/violation counting (CMVC) (Chiang, 2005; Marton and Resnik, 2008; Cherry, 2008), our SDB model has 2Here we expand the definition of phrase to include both syntactic and non-syntactic phrases. the following advantages • The SDB model automatically learns syntactic constraints from training data while the CMVC uses manually defined syntactic constraints: constituency matching/violation. In our SDB model, each learned syntactic feature from bracketing instances can be considered as a syntactic constraint. Therefore we can use thousands of syntactic constraints to guide phrase translation. • The SDB model maintains and protects the strength of the phrase-base</context>
<context position="19369" citStr="Marton and Resnik, 2008" startWordPosition="3095" endWordPosition="3099">enerated syntaxdriven features, which include 73,480 rule features, 153,614 path features and 336 constituent boundary matching features. To tune weights of features, we ran the MaxEnt toolkit (Zhang, 2004) with iteration number being set to 100 and Gaussian prior to 1 to avoid overfitting. 4.3 Results We ran the MERT module with our decoders to tune the feature weights. The values are shown in Table 1. The PSDB receives the largest feature weight, 0.29 for UniSDB and 0.38 for BiSDB, indicating that the SDB models exert a nontrivial impact on decoder. In Table 2, we present our results. Like (Marton and Resnik, 2008), we find that the XP+ feature obtains a significant improvement of 1.08 BLEU over the baseline. However, using all syntax-driven features described in section 3.2, our SDB models achieve larger improvements of up to 1.67 BLEU. The binary SDB (BiSDB) model statistically significantly outperforms Marton and Resnik’s XP+ by an absolute improvement of 0.59 (relatively 2%). It is also marginally better than the unary SDB model. 319 System P(c|e) P(e|c) P.(c|e) P.(e|c) Features Pr(e) Word Phr. XP+ PSDB Plm(e) Baseline 0.041 0.030 0.006 0.065 0.20 0.35 0.19 -0.12 — — XP+ 0.002 0.049 0.046 0.044 0.17</context>
</contexts>
<marker>Marton, Resnik, 2008</marker>
<rawString>Yuval Marton and Philip Resnik. 2008. Soft Syntactic Constraints for Hierarchical Phrase-Based Translation. In Proceedings ofACL.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Franz Josef Och</author>
<author>Hermann Ney</author>
</authors>
<title>Improved Statistical Alignment Models.</title>
<date>2000</date>
<booktitle>In Proceedings of ACL</booktitle>
<contexts>
<context position="17868" citStr="Och and Ney, 2000" startWordPosition="2853" endWordPosition="2856">r SDB models as descried in section 3.3. In order to compare with Marton and Resnik’s approach, we also adapted the baseline decoder to their XP+ feature. 4.1 Experimental Setup In order to obtain syntactic trees for SDB models and XP+, we parsed source sentences using a lexicalized PCFG parser (Xiong et al., 2005). The parser was trained on the Penn Chinese Treebank with an F1 score of 79.4%. All translation models were trained on the FBIS corpus. We removed 15,250 sentences, for which the Chinese parser failed to produce syntactic parse trees. To obtain word-level alignments, we ran GIZA++ (Och and Ney, 2000) on the remaining corpus in both directions, and applied the “grow-diag-final” refinement rule (Koehn et al., 2005) to produce the final many-to-many word alignments. We built our four-gram language model using Xinhua section of the English Gigaword corpus (181.1M words) with the SRILM toolkit (Stolcke, 2002). For the efficiency of MERT, we built our development set (580 sentences) using sentences not exceeding 50 characters from the NIST MT-02 set. We evaluated all models on the NIST MT-05 set using case-sensitive BLEU-4. Statistical significance in BLEU score differences was tested by paired</context>
</contexts>
<marker>Och, Ney, 2000</marker>
<rawString>Franz Josef Och and Hermann Ney. 2000. Improved Statistical Alignment Models. In Proceedings of ACL 2000.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Franz Josef Och</author>
</authors>
<title>Minimum Error Rate Training in Statistical Machine Translation.</title>
<date>2003</date>
<booktitle>In Proceedings ofACL</booktitle>
<contexts>
<context position="3477" citStr="Och, 2003" startWordPosition="514" endWordPosition="515">on-syntactic translations which violate constituent boundaries. To better leverage syntactic constraint yet still allow non-syntactic translations, Chiang (2005) introduces a count for each hypothesis and accumulates it whenever the hypothesis exactly matches syntactic boundaries on the source side. On the contrary, Marton and Resnik (2008) and Cherry (2008) accumulate a count whenever hypotheses violate constituent boundaries. These constituent matching/violation counts are used as a feature in the decoder’s log-linear model and their weights are tuned via minimal error rate training (MERT) (Och, 2003). In this way, syntactic constraint is integrated into decoding as a soft constraint to enable the decoder to reward hypotheses that respect syntactic analyses or to pe1This word can be translated into “section”, “festival”, and “knot” in different contexts. 315 Proceedings of the 47th Annual Meeting of the ACL and the 4th IJCNLP of the AFNLP, pages 315–323, Suntec, Singapore, 2-7 August 2009. c�2009 ACL and AFNLP nalize hypotheses that violate syntactic structures. Although experiments show that this constituent matching/violation counting feature achieves significant improvements on various </context>
</contexts>
<marker>Och, 2003</marker>
<rawString>Franz Josef Och. 2003. Minimum Error Rate Training in Statistical Machine Translation. In Proceedings ofACL 2003.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kishore Papineni</author>
<author>Salim Roukos</author>
<author>Todd Ward</author>
<author>WeiJing Zhu</author>
</authors>
<title>Bleu: a Method for Automatically Evaluation of Machine Translation.</title>
<date>2002</date>
<booktitle>In Proceedings ofACL.</booktitle>
<contexts>
<context position="7706" citStr="Papineni et al., 2002" startWordPosition="1168" endWordPosition="1171">ot use any syntactic constraints on Chinese-to-English translation. To compare with the CMVC, we also conduct experiments using (Marton and Resnik, 2008)’s XP+. The XP+ accumulates a count for each hypothesis whenever it violates the boundaries of a constituent with a label from {NP, VP, CP, IP, PP, ADVP, QP, LCP, DNP}. The XP+ is the best feature among all features that Marton and Resnik use for Chinese-toEnglish translation. Our experimental results display that our SDB model achieves a substantial improvement over the baseline and significantly outperforms XP+ according to the BLEU metric (Papineni et al., 2002). In addition, our analysis shows further evidences of the performance gain from a different perspective than that of BLEU. The paper proceeds as follows. In section 2 we describe how to learn bracketing instances from a training corpus. In section 3 we elaborate the syntax-driven bracketing model, including feature generation and the integration of the SDB model into phrase-based SMT. In section 4 and 5, we present our experiments and analysis. And we finally conclude in section 6. 2 The Acquisition of Bracketing Instances In this section, we formally define the bracketing instance, comprisin</context>
</contexts>
<marker>Papineni, Roukos, Ward, Zhu, 2002</marker>
<rawString>Kishore Papineni, Salim Roukos, Todd Ward, and WeiJing Zhu. 2002. Bleu: a Method for Automatically Evaluation of Machine Translation. In Proceedings ofACL.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Andreas Stolcke</author>
</authors>
<title>SRILM - an Extensible Language Modeling Toolkit.</title>
<date>2002</date>
<booktitle>In Proceedings ofInternational Conference on Spoken Language Processing,</booktitle>
<volume>2</volume>
<pages>901--904</pages>
<contexts>
<context position="18178" citStr="Stolcke, 2002" startWordPosition="2903" endWordPosition="2904">5). The parser was trained on the Penn Chinese Treebank with an F1 score of 79.4%. All translation models were trained on the FBIS corpus. We removed 15,250 sentences, for which the Chinese parser failed to produce syntactic parse trees. To obtain word-level alignments, we ran GIZA++ (Och and Ney, 2000) on the remaining corpus in both directions, and applied the “grow-diag-final” refinement rule (Koehn et al., 2005) to produce the final many-to-many word alignments. We built our four-gram language model using Xinhua section of the English Gigaword corpus (181.1M words) with the SRILM toolkit (Stolcke, 2002). For the efficiency of MERT, we built our development set (580 sentences) using sentences not exceeding 50 characters from the NIST MT-02 set. We evaluated all models on the NIST MT-05 set using case-sensitive BLEU-4. Statistical significance in BLEU score differences was tested by paired bootstrap re-sampling (Koehn, 2004). 4.2 SDB Training We extracted 6.55M bracketing instances from our training corpus using the algorithm shown in figure 1, which contains 4.67M bracketable instances and 1.89M unbracketable instances. From extracted bracketing instances we generated syntaxdriven features, w</context>
</contexts>
<marker>Stolcke, 2002</marker>
<rawString>Andreas Stolcke. 2002. SRILM - an Extensible Language Modeling Toolkit. In Proceedings ofInternational Conference on Spoken Language Processing, volume 2, pages 901-904.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Dekai Wu</author>
</authors>
<title>Stochastic Inversion Transduction Grammars and Bilingual Parsing of Parallel Corpora.</title>
<date>1997</date>
<journal>Computational Linguistics,</journal>
<pages>23--3</pages>
<contexts>
<context position="16305" citStr="Wu, 1997" startWordPosition="2585" endWordPosition="2586">l give a higher probability even though this span violates boundaries of a constituent. Otherwise, a lower probability is given. Through this additional feature, we want the decoder to prefer hypotheses that translate source spans which can be translated as a unit, and avoids translating those which are discontinuous after translation. The weight of this new feature is tuned via MERT, which measures the extent to which this feature should be trusted. In this paper, we implement the SDB model in a state-of-the-art phrase-based system which adapts a binary bracketing transduction grammar (BTG) (Wu, 1997) to phrase translation and reordering, described in (Xiong et al., 2006). Whenever a BTG merging rule (s —* [s1 s21 or s —* (s1 s2)) is used, the SDB model gives a probability to the span s covered by the rule, which estimates the extent to which the span is bracketable. For the unary SDB model, we only consider the features from T(s). For the binary SDB model, we use all features from T(s1), 7-(s2) and T(s) since the binary SDB model is naturally suitable to the binary BTG rules. The SDB model, however, is not only limited to phrase-based SMT using BTG rules. Since it is applied on a source s</context>
</contexts>
<marker>Wu, 1997</marker>
<rawString>Dekai Wu. 1997. Stochastic Inversion Transduction Grammars and Bilingual Parsing of Parallel Corpora. Computational Linguistics, 23(3):377-403.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Deyi Xiong</author>
<author>Shuanglong Li</author>
<author>Qun Liu</author>
<author>Shouxun Lin</author>
<author>Yueliang Qian</author>
</authors>
<title>Parsing the Penn Chinese Treebank with Semantic Knowledge.</title>
<date>2005</date>
<booktitle>In Proceedings ofIJCNLP, Jeju Island,</booktitle>
<contexts>
<context position="17566" citStr="Xiong et al., 2005" startWordPosition="2803" endWordPosition="2806">se-based or syntax-based system that translates source spans recursively or linearly, can adopt the SDB model. 4 Experiments We carried out the MT experiments on Chineseto-English translation, using (Xiong et al., 2006)’s system as our baseline system. We modified the baseline decoder to incorporate our SDB models as descried in section 3.3. In order to compare with Marton and Resnik’s approach, we also adapted the baseline decoder to their XP+ feature. 4.1 Experimental Setup In order to obtain syntactic trees for SDB models and XP+, we parsed source sentences using a lexicalized PCFG parser (Xiong et al., 2005). The parser was trained on the Penn Chinese Treebank with an F1 score of 79.4%. All translation models were trained on the FBIS corpus. We removed 15,250 sentences, for which the Chinese parser failed to produce syntactic parse trees. To obtain word-level alignments, we ran GIZA++ (Och and Ney, 2000) on the remaining corpus in both directions, and applied the “grow-diag-final” refinement rule (Koehn et al., 2005) to produce the final many-to-many word alignments. We built our four-gram language model using Xinhua section of the English Gigaword corpus (181.1M words) with the SRILM toolkit (St</context>
</contexts>
<marker>Xiong, Li, Liu, Lin, Qian, 2005</marker>
<rawString>Deyi Xiong, Shuanglong Li, Qun Liu, Shouxun Lin, Yueliang Qian. 2005. Parsing the Penn Chinese Treebank with Semantic Knowledge. In Proceedings ofIJCNLP, Jeju Island, Korea.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Deyi Xiong</author>
<author>Qun Liu</author>
<author>Shouxun Lin</author>
</authors>
<title>Maximum Entropy Based Phrase Reordering Model for Statistical Machine Translation.</title>
<date>2006</date>
<booktitle>In Proceedings of ACL-COLING</booktitle>
<contexts>
<context position="16377" citStr="Xiong et al., 2006" startWordPosition="2594" endWordPosition="2597">ndaries of a constituent. Otherwise, a lower probability is given. Through this additional feature, we want the decoder to prefer hypotheses that translate source spans which can be translated as a unit, and avoids translating those which are discontinuous after translation. The weight of this new feature is tuned via MERT, which measures the extent to which this feature should be trusted. In this paper, we implement the SDB model in a state-of-the-art phrase-based system which adapts a binary bracketing transduction grammar (BTG) (Wu, 1997) to phrase translation and reordering, described in (Xiong et al., 2006). Whenever a BTG merging rule (s —* [s1 s21 or s —* (s1 s2)) is used, the SDB model gives a probability to the span s covered by the rule, which estimates the extent to which the span is bracketable. For the unary SDB model, we only consider the features from T(s). For the binary SDB model, we use all features from T(s1), 7-(s2) and T(s) since the binary SDB model is naturally suitable to the binary BTG rules. The SDB model, however, is not only limited to phrase-based SMT using BTG rules. Since it is applied on a source span each time, any other hierarchical phrase-based or syntax-based syste</context>
</contexts>
<marker>Xiong, Liu, Lin, 2006</marker>
<rawString>Deyi Xiong, Qun Liu and Shouxun Lin. 2006. Maximum Entropy Based Phrase Reordering Model for Statistical Machine Translation. In Proceedings of ACL-COLING 2006.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Deyi Xiong</author>
<author>Min Zhang</author>
<author>Aiti Aw</author>
<author>Haizhou Li</author>
</authors>
<title>Linguistically Annotated BTG for Statistical Machine Translation.</title>
<date>2008</date>
<booktitle>In Proceedings of COLING</booktitle>
<contexts>
<context position="2748" citStr="Xiong et al., 2008" startWordPosition="408" endWordPosition="411">ks up the second NP phrase and translates the two words “航海” and “节” separately. However, the parse tree of the source fragment constrains the phrase “航海 节” to be translated as a unit. Without considering syntactic constraints from the parse tree, the decoder makes wrong decisions not only on phrase movement but also on the lexical selection for the multi-meaning word “节”1. To avert such errors, the decoder can fully respect linguistic structures by only allowing syntactic constituent translations and reorderings. This, unfortunately, significantly jeopardizes performance (Koehn et al., 2003; Xiong et al., 2008) because by integrating syntactic constraint into decoding as a hard constraint, it simply prohibits any other useful non-syntactic translations which violate constituent boundaries. To better leverage syntactic constraint yet still allow non-syntactic translations, Chiang (2005) introduces a count for each hypothesis and accumulates it whenever the hypothesis exactly matches syntactic boundaries on the source side. On the contrary, Marton and Resnik (2008) and Cherry (2008) accumulate a count whenever hypotheses violate constituent boundaries. These constituent matching/violation counts are u</context>
</contexts>
<marker>Xiong, Zhang, Aw, Li, 2008</marker>
<rawString>Deyi Xiong, Min Zhang, Aiti Aw, and Haizhou Li. 2008. Linguistically Annotated BTG for Statistical Machine Translation. In Proceedings of COLING 2008.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Le Zhang</author>
</authors>
<date>2004</date>
<booktitle>Maximum Entropy Modeling Tooklkit for Python and C++. Available at http://homepages.inf.ed.ac.uk/s0450736</booktitle>
<marker>Le Zhang, 2004</marker>
<rawString>Le Zhang. 2004. Maximum Entropy Modeling Tooklkit for Python and C++. Available at http://homepages.inf.ed.ac.uk/s0450736</rawString>
</citation>
<citation valid="false">
<note>maxent toolkit.html.</note>
<marker></marker>
<rawString>/maxent toolkit.html.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>