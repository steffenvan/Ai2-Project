<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000463">
<title confidence="0.989721">
Rhetorical Parsing with Underspecification and Forests
</title>
<author confidence="0.996427">
Thomas Hanneforth
</author>
<affiliation confidence="0.9977465">
Dept. of Linguistics
University of Potsdam
</affiliation>
<address confidence="0.8994595">
P.O. Box 601553
14415 Potsdam, Germany
</address>
<email confidence="0.664897">
tomQling.uni-
potsdam.de
</email>
<author confidence="0.984239">
Silvan Heintze
</author>
<affiliation confidence="0.9975025">
Dept. of Linguistics
University of Potsdam
</affiliation>
<address confidence="0.872109">
P.O. Box 601553
14415 Potsdam, Germany
</address>
<email confidence="0.5887365">
heintzeQling.uni-
potsdam.de
</email>
<author confidence="0.968608">
Manfred Stede
</author>
<affiliation confidence="0.9966025">
Dept. of Linguistics
University of Potsdam
</affiliation>
<address confidence="0.8942565">
P.O. Box 601553
14415 Potsdam, Germany
</address>
<email confidence="0.6614465">
stedeQling.uni-
potsdam.de
</email>
<sectionHeader confidence="0.995971" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.9998864">
We combine a surface based approach to dis-
course parsing with an explicit rhetorical
grammar in order to efficiently construct an
underspecified representation of possible dis-
course structures.
</bodyText>
<sectionHeader confidence="0.999393" genericHeader="introduction">
1 Introduction
</sectionHeader>
<bodyText confidence="0.9999618">
The task of rhetorical parsing, i.e., automatically de-
termining discourse structure, has been shown to be
relevant, inter alia, for automatic summarization (e.g.,
Marcu, 2000). Not surprisingly, though, the task is very
difficult. Previous approaches have thus emphasized the
need for heuristic or probabilistic information in the
process of finding the best or most likely rhetorical tree.
As an alternative, we explore the idea of strictly
separating “high-confidence” information from hypo-
thetical reasoning and of working with underspecified
trees as much as possible. We create a parse forest on
the basis of surface cues found in the text. This forest
can then be subject to further processing. Depending on
the application, such further steps can either calculate
the “best” tree out of the forest or continue working
with a set of structured hypotheses.
Section 2 briefly summarizes our proposal on under-
specified rhetorical trees; section 3 introduces our
grammar approach to text structure; section 4 compares
this strategy to earlier work.
</bodyText>
<sectionHeader confidence="0.937461" genericHeader="method">
2 Parse forests and underspecification
</sectionHeader>
<bodyText confidence="0.999092366666667">
We will illustrate the underspecification of ambiguities
with the following example:
“(1) Yesterday the delegates elected their new rep-
resentative by a narrow margin. Even though (2) Smith
got only 234 votes, (3) he accepted the position. But (4)
his predecessor was rather irritated by the results.”
We take it that even though unambiguously marks a
CONCESSION between the embedded clause (2, satellite)
and the matrix clause (3, nucleus). For the purpose of
illustration, we also assume that “but” can only signal a
bi-nuclear CONTRAST relation with the second nucleus
(4); the span of the first nucleus is in this case ambigu-
ous (1-3 or 2-3). For linking (1) to the remaining mate-
rial, we suppose that either ELABORATION (with nucleus
(1)) or SEQUENCE holds. Further relations are possible,
which will add to the possibilities, but our points can be
made with the situation as just described.
Instead of enumerating all possible rhetorical trees
for our example text, we use a parse forest representa-
tion which compactly encodes the different analysises.
A parse forest is basically an attributed And-Or-graph
with the properties of subtree sharing and containment
of ambiguities. The first property means that a subtree,
which plays different roles in some bigger structure, is
represented only once. The second property ensures that
two subtrees which have in common the same category
and the same terminal yield, but which differ in the first
step of a leftmost derivation are unified together.
Fig. 1 shows a simplified parse forest for the exam-
ple text.
</bodyText>
<subsubsectionHeader confidence="0.568264">
Fig.1: Parse forest for the input text
</subsubsectionHeader>
<bodyText confidence="0.998002">
Subtree sharing is indicated by nodes (e.g. “1”)
which have several incoming edges. Containment of
ambiguities is exemplified in fig. 1 by the upper left
contrast node which represents a disjunctive hypothesis
concerning the span of the relation.
Reitter and Stede (to appear) developed an XML-
DTD scheme to represent such parse forests in XML
notation.
</bodyText>
<sectionHeader confidence="0.94204" genericHeader="method">
3 Discourse structure parsing
</sectionHeader>
<bodyText confidence="0.999961">
In our approach, we combine a standard chunk parser
which identifies the relevant units for discourse process-
ing with a feature-based grammar which builds larger
rhetorical trees out of these chunks. The categories and
features we use are summarized in table 1.
</bodyText>
<figureCaption confidence="0.991167588235294">
Cat. Feat. Values Comment
rst RST-tree
cat macro_seg, The category of the
s, ip, pp, ... RST-tree: macro
segments, phrases
sentences etc.
type ns, Type of RST-tree:
nn, nuc-sat, multi-
term nuclear or terminal
role nuc, sat Nucleus or satellite
relation elaboration, The relation which
contrast, combines the
cause, ... daughters of the
RST-tree.
dp no_dp, The discourse par-
but, al- ticle triggering the
though, relation, or no_dp,
</figureCaption>
<table confidence="0.7567572">
... if absent.
dp See Discourse particle
above
chunk Phrase or sentence
punct Punctuation
</table>
<tableCaption confidence="0.995239">
Table 1: Grammar categories and features
</tableCaption>
<bodyText confidence="0.994669">
There are three groups of grammar rules:
</bodyText>
<listItem confidence="0.994043833333333">
1. Rules combining chunks to terminal RST-trees
2. Rules combining discourse particles and sentence
fragments to non-primitives RST-trees
3. Rules combining sentences or groups of sentences
(so called macro segments) to non-primitive RST-
trees.
</listItem>
<bodyText confidence="0.932229159090909">
An example for a rule in group 1 is the one which
builds a terminal RST-tree of category mc (main clause)
out of a discourse particle, and sentence fragment and a
full stop (all examples are given in Prolog-style nota-
tion, with curly brackets indicating feature structures):
(1)
rst({cat:mc, dp:DP, type:term}) ---&gt;
dp({cat:pav, dp:DP}),
chunk({cat:ip}),
punct({cat:fullstop}).
Rules like this one are used to build terminal RST-
trees for sentences like (4) in our example text.
The second group of rules is exemplified by a rule
which combines two terminal RST-trees - a subordinate
clause containing a conjunction like even though and
another clause - to a hypotactic RST-tree:
rst({cat:mc, rel:concession, dp:no_dp, type:ns}) ---&gt;
rst({cat:sc, dp:even_though, role:sat}),
rst({cat:mc, dp:no_dp, role:nuc}).
The macro segment building rules of the third group
can be divided into two subclasses. The first class is
constituted by rules which construct RST-trees on the
basis of a relation that is triggered by a discourse parti-
cle. An example of this type is the possible contrast-
relation between segments 4 and 2-3 in (1), which is
triggered by the discourse particle but.
rst({cat:macro_seg, rel:contrast,
dp:no_dp, type:ns}) ---&gt;
rst({cat:macro_seg, role:sat}),
rst({cat:macro_seg, role:nuc, dp:but}).
The other subclass contains rules which freely con-
struct branching RST-trees without the overt evidence
of discourse particles. The relations which are typically
involved here are SEQUENCE and ELABORATION. Rela-
tions which have in common the same type of nucleus-
satellite-configuration are unified into a single rule us-
ing the list-valued form of the relation-feature:
rst({cat:macro_seg, rel:[sequence,elaboration],
dp:no_dp, type:nn}) ---&gt;
rst({cat:macro_seg, role:nuc, dp:no_dp}),
rst({cat:macro_seg, role:nuc, dp:no_dp}).
Fig. 2 shows a parse tree which reflects one analysis
of our example text. Note that the segments into which
the input is broken usually smaller than sentences.
</bodyText>
<figure confidence="0.6586925">
0-10
contrast
</figure>
<figureCaption confidence="0.618427">
Fig.2: Sample parse tree for the input text
</figureCaption>
<bodyText confidence="0.871308">
Rules like (4) ensure the robustness of the grammar
as they can be used to combine partial structures with-
out any structure triggering discourse particles.
</bodyText>
<figure confidence="0.99558334">
Even
though
Smith
got only
234
votes
,
he
accepted
the
position
.
.
But
his
predecessor
was
rather
irritated
by the
results
0-7
sequence
rst [cat:mc]
dp [cat:pav]
chunk [cat:ip]
punct
rst [cat:mc]
2-
concession
chunk [cat:s]
Yesterday
the
delegates
elected
their
new
representative
by a
narrow
margin
punct
rst [cat:sc]
rst [cat:mc]
dp [cat:kous]
chunk [cat:ip]
punct
chunk [cat:ip]
punct
.
</figure>
<bodyText confidence="0.99219902173913">
Furthermore, rules of the kind shown in (4) are on
the one hand necessary to produce all possible branch-
ing structure over a given sequence of terminal ele-
ments. On the other hand they introduce massive
ambiguities into the grammar which causes the number
of analyses to grow according to the Catalan numbers
(cf. Aho and Ullman, 1972, p. 165).
It is therefore crucial that during parsing the con-
struction of parse trees is strictly avoided because that
would turn an otherwise polynomial parsing algorithm
like chart parsing into an exponential one. Instead we
incrementally build the parse forest mentioned in sec-
tion 2. This is done by assigning a unique id to each
edge introduced into the chart and by storing the ids of
the immediate daughters within the edge. After parsing
the parse forest is constructed by partitioning the set of
edges into equivalence classes. Two chart edges E1 and
E2 are in the same equivalence class if they a) have
identical start and end positions and b) the categories of
E1 and E2 subsume each other. For the subsumption test
it is necessary to ignore the role-feature, because this
feature is an attribute of the parse forest edges and not
of the parse forest nodes.
Besides keeping the parsing algorithm polynomial it
is of equal importance to keep the grammar constant
low. For example, rule (4) which establishes a
SEQUENCE/ELABORATION relation between two macro
segments also connects two simple clauses (of category
mc), a macro segment and a simple clause, or a simple
clause and a macro segment. The standard move to
avoid this kind of rule multiplication is to introduce an
unary chain rule of the form
rst({cat:macro_seg}) ---&gt; rst({cat:mc})
which ensures the desired level shifting.
Because of the inherent relational nature of RST trees
this solution is blocked. Instead we use an inheritance
hierarchy like that in fig. 3 and replace rule (4) with the
following one, which is underspecified w.r.t to the cate-
gory feature.
(5)
rst({cat:macro_seg, rel:[sequence,elaboration],
dp:no_dp, type:nn}) ---&gt;
rst({cat:rst_tree, role:nuc, dp:no_dp}),
rst({cat:rst_tree, role:nuc, dp:no_dp}).
segment
rst_tree non_rst_tree
</bodyText>
<sectionHeader confidence="0.999714" genericHeader="method">
4 Related work
</sectionHeader>
<bodyText confidence="0.999955315789474">
Similar to Marcu (2000) we assume discourse markers
as indicators for rhetorical relations.
But contrary to Marcu (1999) and also to Schilder
(2002) we use a full-fledged discourse grammar and a
standard parsing algorithm, which makes it, in our opin-
ion, unnecessary to propose special rhetorical tree build-
ing operations, as suggested e.g. by Marcu (1999).
By using the chart parsing algorithm combined with
the construction of an underspecified parse forest, it can
easily be shown that our method is of cubic complexity.
This is a crucial property, because it is commonly as-
sumed that the number of distinct structures that can be
constructed over a sequence of n discourse units is ex-
ponential in n, (as it is for example implicit in the DCG
based algorithm proposed by Schilder, 2002).
Our system is robust in the same way as the one in
Schilder (2002) because the grammar admits under-
specified rhetorical trees in the absence of overt dis-
course markers.
</bodyText>
<sectionHeader confidence="0.999602" genericHeader="conclusions">
5 Conclusion
</sectionHeader>
<bodyText confidence="0.999888333333333">
We have shown that a grammar based approach to rhe-
torical parsing is suitable for efficient and robust con-
struction of underspecified rhetorical structures.
</bodyText>
<sectionHeader confidence="0.999247" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.96144925">
Alfred V. Aho and Jeffrey D. Ullman. 1972. The Theory
of Parsing, Translating and Compiling. Volume 1.
Prentice-Hall, Englewood Cliffs, NJ.
Daniel Marcu. 1999. A decision-based approach to rhe-
torical parsing. The 37th Annual Meeting of the Asso-
ciation for Computational Linguistics (ACL&apos;99),
pages 365-372, Maryland, June 1999.
Daniel Marcu. 2000. The Rhetorical Parsing of Unre-
stricted Texts: A Surface-Based Approach. Computa-
tional Linguistics, 26 (3), pages 395-448.
David Reitter and Manfred Stede. to appear. Step by
Step: Underspecified Markup in Incremental Rhe-
torical Analysis. To appear in: Proc. Of the 4th Inter-
national Workshop on Linguistically Interpreted
Corpora (LINC-03). Budapest.
Frank Schilder. 2002. Robust Discourse Parsing via
Discourse Markers, Topicality and Position. Natural
Language Engineering 8 (2/3).
mc macro_seg pp sc
Fig 3: Simplified inheritance hierarchy for cat
</reference>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.161573">
<title confidence="0.999365">Rhetorical Parsing with Underspecification and Forests</title>
<author confidence="0.981145">Thomas</author>
<affiliation confidence="0.997164">Dept. of University of</affiliation>
<address confidence="0.8065725">P.O. Box 14415 Potsdam, Germany</address>
<email confidence="0.995223">potsdam.de</email>
<author confidence="0.925723">Silvan</author>
<affiliation confidence="0.9969075">Dept. of University of</affiliation>
<address confidence="0.8066705">P.O. Box 14415 Potsdam, Germany</address>
<email confidence="0.9261225">heintzeQling.unipotsdam.de</email>
<author confidence="0.963121">Manfred</author>
<affiliation confidence="0.996957">Dept. of University of</affiliation>
<address confidence="0.806558">P.O. Box 14415 Potsdam, Germany</address>
<email confidence="0.998156">potsdam.de</email>
<abstract confidence="0.992175833333333">We combine a surface based approach to discourse parsing with an explicit rhetorical grammar in order to efficiently construct an underspecified representation of possible discourse structures.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Alfred V Aho</author>
<author>Jeffrey D Ullman</author>
</authors>
<date>1972</date>
<booktitle>The Theory of Parsing, Translating and Compiling. Volume 1. Prentice-Hall,</booktitle>
<location>Englewood Cliffs, NJ.</location>
<contexts>
<context position="7754" citStr="Aho and Ullman, 1972" startWordPosition="1181" endWordPosition="1184">ted by the results 0-7 sequence rst [cat:mc] dp [cat:pav] chunk [cat:ip] punct rst [cat:mc] 2- concession chunk [cat:s] Yesterday the delegates elected their new representative by a narrow margin punct rst [cat:sc] rst [cat:mc] dp [cat:kous] chunk [cat:ip] punct chunk [cat:ip] punct . Furthermore, rules of the kind shown in (4) are on the one hand necessary to produce all possible branching structure over a given sequence of terminal elements. On the other hand they introduce massive ambiguities into the grammar which causes the number of analyses to grow according to the Catalan numbers (cf. Aho and Ullman, 1972, p. 165). It is therefore crucial that during parsing the construction of parse trees is strictly avoided because that would turn an otherwise polynomial parsing algorithm like chart parsing into an exponential one. Instead we incrementally build the parse forest mentioned in section 2. This is done by assigning a unique id to each edge introduced into the chart and by storing the ids of the immediate daughters within the edge. After parsing the parse forest is constructed by partitioning the set of edges into equivalence classes. Two chart edges E1 and E2 are in the same equivalence class if</context>
</contexts>
<marker>Aho, Ullman, 1972</marker>
<rawString>Alfred V. Aho and Jeffrey D. Ullman. 1972. The Theory of Parsing, Translating and Compiling. Volume 1. Prentice-Hall, Englewood Cliffs, NJ.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Daniel Marcu</author>
</authors>
<title>A decision-based approach to rhetorical parsing.</title>
<date>1999</date>
<booktitle>The 37th Annual Meeting of the Association for Computational Linguistics (ACL&apos;99),</booktitle>
<pages>365--372</pages>
<location>Maryland,</location>
<contexts>
<context position="9715" citStr="Marcu (1999)" startWordPosition="1492" endWordPosition="1493">mc}) which ensures the desired level shifting. Because of the inherent relational nature of RST trees this solution is blocked. Instead we use an inheritance hierarchy like that in fig. 3 and replace rule (4) with the following one, which is underspecified w.r.t to the category feature. (5) rst({cat:macro_seg, rel:[sequence,elaboration], dp:no_dp, type:nn}) ---&gt; rst({cat:rst_tree, role:nuc, dp:no_dp}), rst({cat:rst_tree, role:nuc, dp:no_dp}). segment rst_tree non_rst_tree 4 Related work Similar to Marcu (2000) we assume discourse markers as indicators for rhetorical relations. But contrary to Marcu (1999) and also to Schilder (2002) we use a full-fledged discourse grammar and a standard parsing algorithm, which makes it, in our opinion, unnecessary to propose special rhetorical tree building operations, as suggested e.g. by Marcu (1999). By using the chart parsing algorithm combined with the construction of an underspecified parse forest, it can easily be shown that our method is of cubic complexity. This is a crucial property, because it is commonly assumed that the number of distinct structures that can be constructed over a sequence of n discourse units is exponential in n, (as it is for ex</context>
</contexts>
<marker>Marcu, 1999</marker>
<rawString>Daniel Marcu. 1999. A decision-based approach to rhetorical parsing. The 37th Annual Meeting of the Association for Computational Linguistics (ACL&apos;99), pages 365-372, Maryland, June 1999.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Daniel Marcu</author>
</authors>
<title>The Rhetorical Parsing of Unrestricted Texts: A Surface-Based Approach.</title>
<date>2000</date>
<journal>Computational Linguistics,</journal>
<volume>26</volume>
<issue>3</issue>
<pages>395--448</pages>
<contexts>
<context position="816" citStr="Marcu, 2000" startWordPosition="108" endWordPosition="109">nguistics University of Potsdam P.O. Box 601553 14415 Potsdam, Germany heintzeQling.unipotsdam.de Manfred Stede Dept. of Linguistics University of Potsdam P.O. Box 601553 14415 Potsdam, Germany stedeQling.unipotsdam.de Abstract We combine a surface based approach to discourse parsing with an explicit rhetorical grammar in order to efficiently construct an underspecified representation of possible discourse structures. 1 Introduction The task of rhetorical parsing, i.e., automatically determining discourse structure, has been shown to be relevant, inter alia, for automatic summarization (e.g., Marcu, 2000). Not surprisingly, though, the task is very difficult. Previous approaches have thus emphasized the need for heuristic or probabilistic information in the process of finding the best or most likely rhetorical tree. As an alternative, we explore the idea of strictly separating “high-confidence” information from hypothetical reasoning and of working with underspecified trees as much as possible. We create a parse forest on the basis of surface cues found in the text. This forest can then be subject to further processing. Depending on the application, such further steps can either calculate the </context>
<context position="9618" citStr="Marcu (2000)" startWordPosition="1478" endWordPosition="1479">ultiplication is to introduce an unary chain rule of the form rst({cat:macro_seg}) ---&gt; rst({cat:mc}) which ensures the desired level shifting. Because of the inherent relational nature of RST trees this solution is blocked. Instead we use an inheritance hierarchy like that in fig. 3 and replace rule (4) with the following one, which is underspecified w.r.t to the category feature. (5) rst({cat:macro_seg, rel:[sequence,elaboration], dp:no_dp, type:nn}) ---&gt; rst({cat:rst_tree, role:nuc, dp:no_dp}), rst({cat:rst_tree, role:nuc, dp:no_dp}). segment rst_tree non_rst_tree 4 Related work Similar to Marcu (2000) we assume discourse markers as indicators for rhetorical relations. But contrary to Marcu (1999) and also to Schilder (2002) we use a full-fledged discourse grammar and a standard parsing algorithm, which makes it, in our opinion, unnecessary to propose special rhetorical tree building operations, as suggested e.g. by Marcu (1999). By using the chart parsing algorithm combined with the construction of an underspecified parse forest, it can easily be shown that our method is of cubic complexity. This is a crucial property, because it is commonly assumed that the number of distinct structures t</context>
</contexts>
<marker>Marcu, 2000</marker>
<rawString>Daniel Marcu. 2000. The Rhetorical Parsing of Unrestricted Texts: A Surface-Based Approach. Computational Linguistics, 26 (3), pages 395-448.</rawString>
</citation>
<citation valid="false">
<authors>
<author>David Reitter</author>
<author>Manfred Stede</author>
</authors>
<title>to appear. Step by Step: Underspecified Markup in Incremental Rhetorical Analysis. To appear in:</title>
<booktitle>Proc. Of the 4th International Workshop on Linguistically Interpreted Corpora (LINC-03).</booktitle>
<location>Budapest.</location>
<marker>Reitter, Stede, </marker>
<rawString>David Reitter and Manfred Stede. to appear. Step by Step: Underspecified Markup in Incremental Rhetorical Analysis. To appear in: Proc. Of the 4th International Workshop on Linguistically Interpreted Corpora (LINC-03). Budapest.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Frank Schilder</author>
</authors>
<title>Robust Discourse Parsing via Discourse Markers, Topicality and Position.</title>
<date>2002</date>
<journal>Natural Language Engineering</journal>
<volume>8</volume>
<pages>2--3</pages>
<contexts>
<context position="9743" citStr="Schilder (2002)" startWordPosition="1497" endWordPosition="1498">sired level shifting. Because of the inherent relational nature of RST trees this solution is blocked. Instead we use an inheritance hierarchy like that in fig. 3 and replace rule (4) with the following one, which is underspecified w.r.t to the category feature. (5) rst({cat:macro_seg, rel:[sequence,elaboration], dp:no_dp, type:nn}) ---&gt; rst({cat:rst_tree, role:nuc, dp:no_dp}), rst({cat:rst_tree, role:nuc, dp:no_dp}). segment rst_tree non_rst_tree 4 Related work Similar to Marcu (2000) we assume discourse markers as indicators for rhetorical relations. But contrary to Marcu (1999) and also to Schilder (2002) we use a full-fledged discourse grammar and a standard parsing algorithm, which makes it, in our opinion, unnecessary to propose special rhetorical tree building operations, as suggested e.g. by Marcu (1999). By using the chart parsing algorithm combined with the construction of an underspecified parse forest, it can easily be shown that our method is of cubic complexity. This is a crucial property, because it is commonly assumed that the number of distinct structures that can be constructed over a sequence of n discourse units is exponential in n, (as it is for example implicit in the DCG ba</context>
</contexts>
<marker>Schilder, 2002</marker>
<rawString>Frank Schilder. 2002. Robust Discourse Parsing via Discourse Markers, Topicality and Position. Natural Language Engineering 8 (2/3).</rawString>
</citation>
<citation valid="false">
<title>mc macro_seg pp sc Fig 3: Simplified inheritance hierarchy for cat</title>
<marker></marker>
<rawString>mc macro_seg pp sc Fig 3: Simplified inheritance hierarchy for cat</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>