<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<title confidence="0.9661865">
Disjunctions and Inheritance
in the Context Feature Structure System
</title>
<author confidence="0.933176">
Martin Böttcher
</author>
<affiliation confidence="0.676952">
GMD-IPSI
</affiliation>
<address confidence="0.300263333333333">
Dolivostrafie 15
D 6100 Darmstadt
Germany
</address>
<email confidence="0.414627">
boettche©darmstadt.gmd.de
</email>
<sectionHeader confidence="0.969165" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999717294117647">
Substantial efforts have been made in or-
der to cope with disjunctions in constraint
based grammar formalisms (e.g. [Kasper,
1987; Maxwell and Kaplan, 1991; DZirre and
Eisele, 1990].). This paper describes the
roles of disjunctions and inheritance in the
use of feature structures and their formal
semantics. With the notion of contexts we
abstract from the graph structure of feature
structures and properly define the search
space of alternatives. The graph unifica-
tion algorithm precomputes nogood combi-
nations, and a specialized search procedure
which we propose here uses them as a con-
trolling factor in order to delay decisions as
long as there is no logical necessity for de-
ciding.
</bodyText>
<sectionHeader confidence="0.998874" genericHeader="keywords">
1 Introduction
</sectionHeader>
<bodyText confidence="0.9998015">
The Context Feature Structure System (CFS)
[Böttcher and Konyves-T6th, 1992] is a unification
based system which evaluates feature structures with
distributed disjunctions and dynamically definable
types for structure inheritance. CPS is currently
used to develop and to test a dependency grammar
for German in the text analysis project KONTEXT.
In this paper disjunctions and inheritance will be in-
vestigated with regard to both, their application di-
mension and their efficient computational treatment.
The unification algorithm of CFS and the con-
cept of virtual agreements for structure sharing has
been introduced in [Böttcher and Konyves-T6th,
19921. The algorithm handles structure inheritance
by structure sharing and constraint sharing which
avoids copying of path structures and constraints
completely. Disjunctions are evaluated concurrently
without backtracking and without combinatoric mul-
tiplication of the path structure. For that purpose
the path structure is separated from the structure of
disjunctions by the introduction of contexts.
Contexts are one of the key concepts for main-
taining disjunctions in feature terms. They describe
readings of disjunctive feature structures. We define
them slightly different from the definitions in [DEIrre
and Eisele, 1990] and [Backofen et at., 1991], with a
technical granularity which is more appropriate for
their efficient treatment. The CFS unification algo-
rithm computes a set of nogood contexts for all con-
flicts which occur during unification of structures.
An algorithm for contexts which computes from a
set of nogoods whether a structure is valid, will be
described in this paper. It is a specialized search
procedure which avoids the investigation of the full
search space of contexts by clustering disjunctions.
We start with some examples how disjunctions and
inheritance are used in the CFS environment. Then
contexts are formally defined on the basis of the se-
mantics of CFS feature structures. Finally the algo-
rithm computing validity of contexts is outlined.
</bodyText>
<sectionHeader confidence="0.988074" genericHeader="introduction">
2 The Use of Disjunctions and
Inheritance
</sectionHeader>
<subsectionHeader confidence="0.544963">
Disjunctions
</subsectionHeader>
<bodyText confidence="0.99406575">
Disjunctions are used to express ambiguity and ca-
pability. A first example is provided by the lexicon
entry for German die (the, that, .. .) in Figure 1. It
may be nominative or accusative, and if it is singular
the gender has to be feminine.
Those parts of the term which are not inside a dis-
junction are required in any case. Such parts shall be
shared by all &amp;quot;readings&amp;quot; of the term. The internal
</bodyText>
<page confidence="0.975444">
54
</page>
<equation confidence="0.8109276">
die :=
L_definit-or-relative&lt;&gt;
- graph : die
cas :
syn : categ :
</equation>
<figureCaption confidence="0.998249">
Figure 1: Lexicon Entry for die
</figureCaption>
<bodyText confidence="0.962984944444444">
representation shall provide for mechanisms which
prevent from multiplication of independent disjunc-
tions (into dnf).
Inheritance
Inheritance is used for two purposes: abstraction in
the lexicon and non-destructive combination of chart
entries. Figure 3 together with the type trans of Fig-
ure 2 shows an example of abstraction: The feature
structure of trans is inherited (marked by O&lt;&gt;) to
the structure for the lexeme spielen (to play) at the
destination of the path syn : slots : . A virtual copy
of the type structure is inserted. The type trans will
be inherited to all the verbs which allow (or require)
a transitive object. It is obvious that it makes sense
not only to inherit the structure to all the verbs on
the level of grammar description but also to share
the structure in the internal representation, without
copying it.
</bodyText>
<equation confidence="0.981850628571429">
{ nom
acc
num : pl
{num : sg
gen : fern
trans := trans
L_spielen :=
lexem : spielen
fle_verb : schwach
syn : ca eg .
pfk : haben
slots : transe&lt;&gt;
v-verbe&lt;&gt;
Figure 3: Lexicon Entry for spielen
&amp;quot; dom : syn : categ : gvb : aktiv
syn : categ :
cas : acc
.]class : nomn
[categ
: hypo&apos;
categ : class : ssent
pm n : none
_ &lt;tree-filler&gt; = &lt;role-filler trans&gt;
dom :
gvb : passiv syn : categ : rei : 01
1
-
[ { durch
categ : [rel : #1
class : prpo I
lexem : von 1
&lt;tree-filler&gt; = &lt;role-filler agens&gt;
v-verb-trans-slote&lt;&gt;
syn :
syn :
</equation>
<figureCaption confidence="0.999486">
Figure 2: The Type trans
</figureCaption>
<bodyText confidence="0.999710888888889">
As a second example Figure 2 shows a type de-
scribing possible realizations of a transitive object.
The outermost disjunction distinguishes whether the
dominating predicate is in active or in passive voice.
For active predicates either a noun (syn : categ :
class : nomn) or a subsentence (syn : categ : class :
ssent) is allowed. This way disjunctions describe
and restrict the possibility of combinations of con-
stituents.
</bodyText>
<subsectionHeader confidence="0.983866">
External Treatment of Disjunctions
</subsectionHeader>
<bodyText confidence="0.999941977777778">
The KONTEXT grammar is a lexicalized gram-
mar. This means that the possibility of combinations
of constituents is described with the entries in the
lexicon rather than in a separated, general grammar.
A chart parser is used in order to decide which con-
stituents to combine and maintain the combinations.
This means that some of the disjunctions concerning
concrete combinations are handled not by the unifi-
cation formalism, but by the chart. Therefore struc-
ture sharing for inheritance which is extensively used
by the parser is even more important.
Inheritance is also extensively used by the parser.
It works bottom-up and has to try different combi-
nations of constituents. For single words it just looks
up the structures in the lexicon. Then it combines a
slot of a functor with a filler. An example is given in
Figure 4 which shows a trace of the chart for the sen-
tence Kinder spielen eine Rolle im Theater. (Chil-
dren play a part in the theatre.) In the 6&apos;th block, in
the line starting with ...4 the parser combines type
_16 (for the lexicon entry of im) with the type _17
(for Theater) and defines this combination dynami-
cally as type _18. _16 is the functor, _17 the filler,
and caspn the name of the slot. The combination is
done by unification of feature structures by the CFS
system.
The point here is that the parser tries to combine
the result _18 of this step more than once with differ-
ent other structures, but unification is a destructive
operation! So, instead of directly unifying the struc-
tures of say _7 and _18 (_11 and _18, ... ), _7 and
_18 are inherited into the new structure of _20. This
way virtual copies of the structures are produced,
and these are unified. It is essential for efficiency
that a virtual copy does not mean that the structure
of the type has to be copied. The lazy copying ap-
proach ([Kogure, 1990], and [Emele, 1991] for lazy
copying in TFS with historical backtracking) copies
only overlapping parts of the structure. CFS avoids
even this by structure- and constraint-sharing.
For common sentences in German, which tend to
be rather long, a lot of types will be generated. They
supply only a small part of structure themselves (just
the path from the functor to the filler and a simple
slot-filler combination structure). The bulk of the
</bodyText>
<page confidence="0.995972">
55
</page>
<table confidence="0.977518892857143">
1: Kinder
_1 : Kinder open/sat
2: spielen
...1 _2 : spielen open
_3 : spielen _2 subje Kinder _1 open/sat
_4 : spielen _2 trans Kinder _1 open
3: eine
...2 _5 : eine open/sat
4: Rolle
...3 _6 : Rolle open/sat
...2 _7 : Rolle _6 refer eine _5 open/sat
_11: spielen _3 trans Rolle _7 open/sat
...1 _14: spielen _2 trans Rolle _7 open
5: in
...4 _16: in open
6: Theater
...5 Theater open/sat
in _16 caspn Theater _17 open/sat
Rolle _6 caspp in _18 open/sat
Rolle _7 caspp in _18 open/sat
spielen _11 caspp in _18 open/sat
...1 spielen _14 caspp in _18 open
_26: spielen _3 trans Rolle _20 open/sat
...1 _29: spielen _2 trans Rolle _20 open
7: .
...6 . open
. _30 praed spielen _26 sat
. _30 praed spielen _21 sat
</table>
<figureCaption confidence="0.996652">
Figure 4: Chart for Kinder spielen . . .
</figureCaption>
<bodyText confidence="0.9878515">
structure is shared among the lexicon and all the
different combinations produced by the parser.
</bodyText>
<sectionHeader confidence="0.392756" genericHeader="method">
Avoiding Recursive Inheritance
</sectionHeader>
<bodyText confidence="0.999751923076923">
Recursive inheritance would be a means to com-
bine phrases in order to analyze (and generate) with-
out a parser (as in TFS). On the other hand a parser
is a controlled device which e.g. knows about im-
portant paths in feature structures describing con-
stituents, and which can do steps in a certain se-
quence, while unification in principle is sequence-
invariant. We think that recursion is not in princi-
ple impossible in spite of CFS&apos; concurrent treatment
of disjunctions, but we draw the borderline between
the parser and the unification formalism such that
the cases for recursion and iteration are handled by
the parser. This seems to be more efficient.
</bodyText>
<subsectionHeader confidence="0.866557">
The Connection between Disjunctions and
Types
</subsectionHeader>
<bodyText confidence="0.999946466666667">
The similarity of the relation between disjunctive
structure and disjunct and the relation between type
and instance is, that in a set theoretic semantics (see
below) the denotation of the former is a superset
of the denotation of the latter. The difference is
that a disjunctive structure is invalid, i.e. has the
empty set as denotation, if each disjunct is invalid.
A type, however, stays valid even when all its cur-
rently known instances are invalid. This distinction
mirrors the uses of the two: inheritance for abstrac-
tion, disjunctions for complete enumeration of alter-
natives. When an external system, like the chart of
the parser, keeps track of the relation between types
and instances disjunctions might be replaced by in-
heritance.
</bodyText>
<sectionHeader confidence="0.98001" genericHeader="method">
3 Contexts and Inheritance
</sectionHeader>
<bodyText confidence="0.999982631578947">
This chapter introduces the syntax and semantics of
CFS feature terms, defines contexts, and investigates
the relation between type and instance concerning
the validity of contexts. We want to define contexts
such that they describe a certain reading of a (dis-
junctive) term, i.e. chooses a disjunct for some or all
of the disjunctions. We will define validity of a con-
text such that the intended reading has a non-empty
denotation.
The CFS unification algorithm as described in
[Blittcher, Konyves-Toth 92] computes a set of in-
valid contexts for all unification conflicts, which are
always conflicts between constraints expressed in the
feature term (or in types). The purpose of the defini-
tion of contexts is to cover all possible conflicts, and
to define an appropriate search space for the search
procedure described in the last part of this paper.
Therefore our definition of contexts differ from those
in [Dorre and Eisele, 1990] or [Backofen et al., 1991].
</bodyText>
<subsectionHeader confidence="0.734515">
Syntax and Semantics of Feature Terms
</subsectionHeader>
<bodyText confidence="0.919842714285714">
Let A = {a,.. .}be a set of atoms, F = If , fi, gi,
a set of feature names, D = Id, . .1 a set of disjunc-
tion names, X = {x,y,z,...} a set of type names,
I = {i,...) a set of instantiation names. The set
of terms T = {t, ti, .} is defined by the recursive
scheme in Figure 5. A sequence of type definitions is
x := t1 y := t2 Z :=
</bodyText>
<figureCaption confidence="0.998308">
Figure 5: The Set of Feature Terms T
</figureCaption>
<bodyText confidence="0.999503833333333">
The concrete syntax of CFS is richer than this def-
inition. Variables are allowed to express path equa-
tions, and types can be unified destructively. Cyclic
path equations (e.g. &lt;&gt;= &lt;gi, .. gm&gt;) are supported,
but recursive type definition and negation are not
supported, yet.
</bodyText>
<figure confidence="0.897015833333333">
a
f : t
[t1 tn]
ft1 .tal
..fn&gt; = &lt;91 . . gm&gt;
xe&lt;&gt;i
atom
feature value pair
unification
disjunction
path equation
type inheritance
</figure>
<page confidence="0.981879">
56
</page>
<bodyText confidence="0.999768833333333">
In order to define contexts we define the set of dis-
junctions of a term, the disjuncts of a disjunction,
and deciders as (complete) functions from disjunc-
tions to disjuncts. Mi is a mapping substituting all
disjunction names d by i(d), where i is unique for
each instantiation.
</bodyText>
<equation confidence="0.9872477">
--o• 2N,
:= 0
= }
:= dis(t)
:= dis(Mi(t))1x := t
:= U5 dis(ti)
{d} UU5 dis(ti),
sub(d) := {1, ..., n}
deciders(t):=
{choice: dis(t) Nichoice(d) E sub(d)}
</equation>
<bodyText confidence="0.8722115">
Figure 6 defines the interpretation I[t], of deciders r
c w.r.t. terms t as subsets of some universe U (similar
to [Smolka, 19881, without sorts, but with named
disjunctions and instantiations).
</bodyText>
<equation confidence="0.9933651">
a/ E U,
P. : Uj_ -- U.I., tr(aI) = .t, f&apos;(±) =
:={a/}
if : illc :=fs E Ulf/(s) E 1[4,}
Et1..tn11, :=ni iitiiic
1[ {t1..in}cdc :=Pc(d)le
Kfl-fn&gt; = &lt;91-grAc:=fs E Ui.g(.41(s)) =
g4.4(..gf(s)) 0 1}
fre&lt;&gt;il, :=1.9 E UIX := t
s E [Mi(t)ic}
</equation>
<figureCaption confidence="0.997093">
Figure 6: Decider Interpretation
</figureCaption>
<bodyText confidence="0.999398">
Similar to deciders we define specializers as partial
functions from disjunctions to disjuncts. We also
define a partial order -.&lt;t on specializers of a term:
</bodyText>
<equation confidence="0.997342333333333">
c2 if
V,EE d I•sk ,t) (c2 is defined on d A c2 (d) = j)
ci(d) =j
</equation>
<bodyText confidence="0.7329435">
The interpretation function can be extended to
specializers now: If c is a specializer oft, then
</bodyText>
<equation confidence="0.920801">
Mc := U Mc&apos;
C,Edeciders(t)Aci-(ic
</equation>
<bodyText confidence="0.9991255">
A specializer is valid if it&apos;s denotation is not empty.
For the most general specializer, the function c-r
which is undefined on each disjunction, we get the
interpretation of the term:
</bodyText>
<equation confidence="0.728643">
pi := ItIICT
Contexts
</equation>
<bodyText confidence="0.920089611111111">
Contexts will be objects of computation and repre-
sentation. They are used in order to record validity
for distributed disjunctions. We give our definition
first, and a short discussion afterwards.
For the purpose of explanation we restrict the syn-
tax concerning the composition of disjunctions. We
say that a disjunctive subterm {...}d oft is outwards
in t if there is no subterm {..,t5, ..}d, of t with {...}d
subterm of ti. We require for each disjunctive sub-
term {...}d oft and each subterm {..,ti, ..}d1 oft: if
{...}d is outwards in ti then each subterm {...}d of t
is outwards in ti. This relation between d&apos; and d we
define as subdis(d&apos;, j, d). Figure 7 shows the defini-
tion of contexts.
A specializer c oft is a context of t, if
Vd, d&apos; E dis(t):
(c is defined on d A subdis(d&apos; , j, d))
#.(c is defined on d&apos; A c(d&apos;) = j)
</bodyText>
<figureCaption confidence="0.999925">
Figure 7: Definition of Contexts
</figureCaption>
<bodyText confidence="0.9268042">
The set of contexts and a bottom element 1 form
a lattice (-&lt;i, C1). The infimum operator of this
lattice we write as nt. We drop the index t from
operators whenever it is clear which term is meant.
Discussion: E.g. for the term
</bodyText>
<equation confidence="0.990161666666667">
f { 1,
di
--0 2, d2 1) is a specializer but not a con-
</equation>
<bodyText confidence="0.999819166666667">
text. We exclude such specializers which have more
general specializers (d1 --+ 2) with the same deno-
tation. For the same term (d2 1) is not a con-
text. This makes sense due to the fact that there
is no constraint expressed in the term required in
(d2 •—■ 1), but e.g. a at the destination of f is re-
quired in (d1 1, d2 1). We will utilize this
information about the dependency of disjunctions as
it is expressed in our definition of contexts.
In order to show what contexts are used for we
define the relation is required in (requi) of subterms
and contexts of t by the recursive scheme:
</bodyText>
<equation confidence="0.979735833333333">
t requi c-r
t&apos; requi c
Mi(e) requi c
t&apos; requi c
. (d —+ j
requt d, c(d,)
</equation>
<bodyText confidence="0.9438346">
The contexts in which some subterms of t are re-
quired, we call input contexts of t. Each value con-
straint at the destination of a certain path and each
path equation is required in a certain input context.
Example: In
</bodyText>
<equation confidence="0.842300727272727">
[f
f
dis(a)
dis(&lt;p&gt; = &lt;g&gt;)
dis(f : t)
dis(xe&lt;&gt;i)
dis(fti,..,t4d)
f : t&apos; requi c
xe&lt;&gt;i requi c A x := e
[..,e,..] requi c
{..,i5, ..}d requi c
</equation>
<page confidence="0.921528">
57
</page>
<figure confidence="0.990296833333333">
E fg aa bal .2 Fhf .31
f : b g : a
g : b h : b f : a ,
(di
(d2
(d3
</figure>
<figureCaption confidence="0.999781">
Figure 9: Term and Nogood Contexts
</figureCaption>
<table confidence="0.950074333333333">
1, d2 1), (d1 2, d2 —* 2),
1, d3 1), (d2 -4 2, d3 2),
1, d1 1), (d3 2, d1 2)
</table>
<tableCaption confidence="0.471087">
a is required in (d1 -4 1) at the destination of f,
</tableCaption>
<bodyText confidence="0.97776675">
and e is required in (d2 2) at the destination of f,
and the conflict is in the infimum context (d1 1) n
(d2 2) = (d1 1, d2 2). This way each conflict
is always in one context, and any context might be a
context of a conflict. So the contexts are defined with
the necessary differentiation and without superfluous
elements.
We call the contexts of conflicts nogoods. It is not
a trivial problem to compute the validity of a term
or a context from the set of nogoods in the general
case. This will be the topic of the last part (4).
Instantiation
If x := t is a type, and x is inherited to some term
x@&lt;&gt;; then for each context c of x there is a corre-
sponding context c&apos; of xe&lt;&gt;i with the same denota-
tion.
</bodyText>
<equation confidence="0.9972055">
fre&lt;&gt;iic, = [Mi(t)11c, =
dis(Mi(t) --+ N, c&apos; (i(d)) = c(d)
</equation>
<bodyText confidence="0.997249266666667">
Therefore each nogood of t also implies that the cor-
responding context of the instance term x0&lt;&gt;i has
the empty denotation. It is not necessary to detect
the conflicts again. The nogoods can be inherited.
(In fact they have to because CFS will never com-
pute a conflict twice.)
If the instance is a larger term, the instance usually
will be more specific than the type, and there might
be conflicts between constraints in the type and con-
straints in the instance. In this case there are valid
contexts of the type with invalid corresponding con-
texts of the instance. Furthermore the inheritance
can occur in the scope of disjunctions of the instance.
We summarize this by the definition of context map-
ping mi in Figure 8.
</bodyText>
<equation confidence="0.998771833333333">
x := t, c E contexts(t)
t&apos; =
xe&lt;&gt;i is required in c&apos; E conterts(e)
mi:conterts(t) contexts(e),
i(d) c(d)
d&apos; e(d) )
</equation>
<figureCaption confidence="0.992733">
Figure 8: Context Mappings
</figureCaption>
<sectionHeader confidence="0.876055" genericHeader="method">
4 Computing Validity
</sectionHeader>
<bodyText confidence="0.999111542857143">
Given a set of nogood contexts, the disjunctions and
the subdis-relation of a term, the question is whether
the term is valid, i.e. whether it has a non-empty
denotation. A nogood context n means that [tin =
{}. The answer to this question in this section will be
an algorithm, which in CFS is run after all conflicts
are computed, because an incremental version of the
algorithm seems to be more expensive. We start with
an example in order to show that simple approaches
are not effective.
For the term in Figure 9 the unification algorithm
of CFS computes the shown nogoods. The term is
invalid because each decider&apos;s denotation is empty.
A strategy which looks for similar nogoods and tries
to replace them by a more general one will fail. This
example shows that it is necessary at least in some
cases to look at (a covering of) more specific contexts.
But before we start to describe an algorithm for
this purpose we want to explain why the algorithm
we describe does a little bit more. It computes all
most general invalid contexts from the set of given
nogoods. This border of invalid contexts, the com-
puted nogoods, allows us afterwards to test at a low
rate whether a context is invalid or not. It is just the
test 3n E Computed-Nogoods : c n. This test is
frequently required during inspection of a result and
during output. Moreover nogoods are inherited, and
if these nogoods are the most general invalid con-
texts, computations for instances will be reduced.
The search procedure for the most general invalid
contexts starts from the most general context CT
It descends through the context lattice and modifies
the set of nogoods. We give a rough description first
and a refinement afterwards:
Recursive procedure n-1
</bodyText>
<listItem confidence="0.976933636363636">
1. if 3n E Nogoods : c n then return &apos;bad&apos;.
2. select a disjunction d with c undefined on d and
such that the specializer (d --+ j, d&apos; --+ c(d1)) is
a context. if no such disjunction exists, return
&apos;good&apos;.
3. for each j E sub(d) recursively call n-1 with (d
j, --+ c(d1)).
4. if each call returns &apos;bad&apos;, then replace all n E
Nogoods : n c by c and return &apos;bad&apos;.
5. continue with step 2 selecting a different disjunc-
tion.
</listItem>
<bodyText confidence="0.977676125">
If we replace the fifth step by
5. return &apos;good&apos;
n-1 will be a test procedure for validity.
n-1 is not be very efficient since it visits contexts
more than once and since it descends down to most
specific contexts even in cases without nogoods. In
order to describe the enhancements we write: c1 is
relevant for c2, if c1 n e2 1.
</bodyText>
<page confidence="0.99345">
58
</page>
<bodyText confidence="0.8721075">
The algorithm implemented for CFS is based on
the following ideas:
(a) select nogoods relevant for c, return &apos;good&apos; if
there are none
</bodyText>
<listItem confidence="0.76710175">
(b) specialize c only by disjunctions for which at
least some of the relevant nogoods is defined.
(c) order the disjunctions, select in this order in the
step 2.-4. cycle.
</listItem>
<bodyText confidence="0.962311074074074">
(d) prevent multiple visits of contexts by different
specialization sequences: if the selected disjunc-
tion is lower than some disjunction c is defined
on, do not select any disjunction in the recursive
calls (do step 1 only).
The procedure will be favorably parametrized not
only by the context c, but also by the selection of
relevant nogoods, which is reduced in each recursive
call (because only &apos;relevant&apos; disjunctions are selected
due to enhencement (b)). This makes the procedure
stop at depth linear to the number of disjunctions
a nogood is defined on. Together with the ordering
(c,d) every context which is more general than any
nogood is visited once (step 1 visits due to enhence-
ment (d) not counted), because they are candidates
for most general nogood contexts. For very few no-
goods it might be better to use a different proce-
dure searching &apos;bottom-up&apos; from the nogoods (as [de
Kleer, 1986, second part] proposed for ATMS).
(a) reduces spreading by recognizing contexts
without more specific invalid contexts. (b) might be
further restricted in some cases: select only such d
with Vj E sub(d) : 3n E relevant-nogoods : n(d) = j.
(b) in fact clusters disjunctions into mutually inde-
pendent sets of disjunctions. This also ignores dis-
junctions for which there are currently no nogoods
thereby reducing the search space exponentially.
</bodyText>
<sectionHeader confidence="0.59981" genericHeader="method">
Eliminating Irrelevant Disjunctions
</sectionHeader>
<bodyText confidence="0.999709375">
The algorithm implemented in CFS is also capable
of a second task: It computes whether disjunctions
are no longer relevant. This is the case if either the
context in which the disjunctive term is required is
invalid, or the contexts of all but one disjunct is in-
valid.
Why is this an interesting property? There are two
reasons: This knowledge reduces the search space of
the algorithm computing the border of most general
nogoods. And during inheritance neither the dis-
junction nor the nogoods for such disjunctions need
to be inherited. It is most often during inheritance
that a disjunction of a type becomes irrelevant in the
instance. (Nobody would write down a disjunction
which becomes irrelevant in the instance itself.)
Structure- and constraint sharing in CFS makes it
necessary to keep this information because contexts
of shared constraints in the type are still defined on
this disjunction, i.e. the disjunction stays relevant
in the type. Let the only valid disjunct of d be k.
The information that either the constraint can be
ignored (c(d) k) or the disjunction can be ignored
(c(d) = k) is stored with the instantiation. The con-
text mapping for the instantiation filters out either
the whole context or the disjunction.
The algorithm is extended in the following way:
4a. if c is an input context of t and d is a disjunc-
tion specializing c and the subcontexts are also
input contexts, and if all but one specialization
delivers &apos;bad&apos; the disjunction is irrelevant for t.
All subdisjunctions of subterms other than the
one which is not &apos;bad&apos; are irrelevant, too.
</bodyText>
<sectionHeader confidence="0.621809" genericHeader="evaluation">
Consequences
</sectionHeader>
<bodyText confidence="0.9999895">
One consequence of the elimination of irrelevant dis-
junctions during inheritance is, that an efficient im-
plementation of contexts by bitvectors (as proposed
in e.g. [de Kleer, 1986]) with a simple shift operation
for context mappings will waste a lot of space. Either
sparse coding of these bit vectors or a difficult corn-
pactifying context mapping is required. The sparse
coding are just vectors of pairs of disjunction names
and choices. Maybe someone finds a good solution
to this problem. Nevertheless the context mapping is
not consuming much of the resources, and the elim-
ination of irrelevant disjunctions is worth it.
</bodyText>
<sectionHeader confidence="0.997464" genericHeader="conclusions">
5 Conclusion
</sectionHeader>
<bodyText confidence="0.999995066666667">
For the tasks outlined in the first part, the efficient
treatment of disjunctions and inheritance, we intro-
duced contexts. Contexts have been defined on the
basis of a set theoretic semantics for CFS feature
structures, such that they describe the space of pos-
sible unification conflicts adequately. The unification
formalism of CFS computes a set of nogood contexts,
from which the algorithm outlined in the third part
computes the border of most general nogood con-
texts, which is also important for inspection and out-
put. Clearly we cannot find a polynomial algorithm
for an exponential problem (number of possible no-
goods), but by elaborated techniques we can reduce
the effort exponentially in order to get usable sys-
tems in the practical case.
</bodyText>
<sectionHeader confidence="0.998295" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.998793384615385">
[Backofen et al., 1991] R. Backofen, L. Euler, and
G. Gorz. Distributed disjunctions for life. In
H. Boley and M. M. Richter, editors, Processing
Declarative Knowledge. Springer, Berlin, 1991.
[Böttcher and Konyves-T6th, 1992] M. Böttcher
and M. KOnyves-T6th. Non-destructive unifica-
tion of disjunctive feature structures by constraint
sharing. In H. Trost and R. Backofen, editors,
Coping with Linguistic Ambiguity in Typed Fea-
ture Formalisms, Workshop Notes, Vienna, 1992.
ECAI &apos;92.
[de Kleer, 1986] J. de Kleer. ATMS. Artificial In-
telligence, 28(2), 1986.
</reference>
<page confidence="0.98722">
59
</page>
<reference confidence="0.96330295">
[Dorre and Eisele, 1990] J. Done and A. Eisele. Fea-
ture logic with disjunctive unification. In Proceed-
ings of COLING &apos;90, Helsinki, 1990.
[Emele, 1991] M. C. Emele. Unification with lazy
non-redundant copying. In Proceedings of the 29&apos;th
ACL, Berkeley, 1991.
[Kasper, 1987] R. Kasper. A unification method for
disjunctive feature descriptions. In Proceedings of
the 25&apos;ih ACL, Stanford, 1987.
[Kogure, 1990] K. Kogure. Strategic lazy incremen-
tal copy graph unification. In Proceedings of COL-
ING &apos;90, Helsinki, 1990.
[Maxwell and Kaplan, 1991] J. T. Maxwell and
R. M. Kaplan. A method for disjunctive constraint
satisfaction. In M. Tomita, editor, Current Issues
in Parsing Technology. Kluver Academic Publish-
ers, 1991.
[Smolka, 1988] G. Smolka. A feature logic with
subsorts. Lilog Report 33, IBM Deutschland,
Stuttgart, 1988.
</reference>
<page confidence="0.998409">
60
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.347572">
<title confidence="0.9981465">Disjunctions and Inheritance in the Context Feature Structure System</title>
<author confidence="0.999662">Martin Böttcher</author>
<affiliation confidence="0.662558">GMD-IPSI</affiliation>
<address confidence="0.742727666666667">Dolivostrafie 15 D 6100 Darmstadt Germany</address>
<email confidence="0.999195">boettche©darmstadt.gmd.de</email>
<abstract confidence="0.982504722222222">Substantial efforts have been made in order to cope with disjunctions in constraint based grammar formalisms (e.g. [Kasper, 1987; Maxwell and Kaplan, 1991; DZirre and Eisele, 1990].). This paper describes the roles of disjunctions and inheritance in the use of feature structures and their formal semantics. With the notion of contexts we abstract from the graph structure of feature structures and properly define the search space of alternatives. The graph unificaalgorithm precomputes combinations, and a specialized search procedure which we propose here uses them as a controlling factor in order to delay decisions as long as there is no logical necessity for deciding.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>R Backofen</author>
<author>L Euler</author>
<author>G Gorz</author>
</authors>
<title>Distributed disjunctions for life.</title>
<date>1991</date>
<booktitle>Processing Declarative Knowledge.</booktitle>
<editor>In H. Boley and M. M. Richter, editors,</editor>
<publisher>Springer,</publisher>
<location>Berlin,</location>
<marker>[Backofen et al., 1991]</marker>
<rawString>R. Backofen, L. Euler, and G. Gorz. Distributed disjunctions for life. In H. Boley and M. M. Richter, editors, Processing Declarative Knowledge. Springer, Berlin, 1991.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Böttcher</author>
<author>M KOnyves-T6th</author>
</authors>
<title>Non-destructive unification of disjunctive feature structures by constraint sharing.</title>
<date>1992</date>
<booktitle>Coping with Linguistic Ambiguity in Typed Feature Formalisms, Workshop Notes,</booktitle>
<editor>In H. Trost and R. Backofen, editors,</editor>
<location>Vienna,</location>
<note>ECAI &apos;92.</note>
<marker>[Böttcher and Konyves-T6th, 1992]</marker>
<rawString>M. Böttcher and M. KOnyves-T6th. Non-destructive unification of disjunctive feature structures by constraint sharing. In H. Trost and R. Backofen, editors, Coping with Linguistic Ambiguity in Typed Feature Formalisms, Workshop Notes, Vienna, 1992. ECAI &apos;92.</rawString>
</citation>
<citation valid="true">
<authors>
<author>ATMS</author>
</authors>
<date>1986</date>
<journal>Artificial Intelligence,</journal>
<volume>28</volume>
<issue>2</issue>
<marker>[de Kleer, 1986]</marker>
<rawString>J. de Kleer. ATMS. Artificial Intelligence, 28(2), 1986.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Done</author>
<author>A Eisele</author>
</authors>
<title>Feature logic with disjunctive unification.</title>
<date>1990</date>
<booktitle>In Proceedings of COLING &apos;90,</booktitle>
<location>Helsinki,</location>
<marker>[Dorre and Eisele, 1990]</marker>
<rawString>J. Done and A. Eisele. Feature logic with disjunctive unification. In Proceedings of COLING &apos;90, Helsinki, 1990.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M C Emele</author>
</authors>
<title>Unification with lazy non-redundant copying.</title>
<date>1991</date>
<booktitle>In Proceedings of the 29&apos;th ACL,</booktitle>
<location>Berkeley,</location>
<marker>[Emele, 1991]</marker>
<rawString>M. C. Emele. Unification with lazy non-redundant copying. In Proceedings of the 29&apos;th ACL, Berkeley, 1991.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Kasper</author>
</authors>
<title>A unification method for disjunctive feature descriptions.</title>
<date>1987</date>
<booktitle>In Proceedings of the 25&apos;ih ACL,</booktitle>
<location>Stanford,</location>
<marker>[Kasper, 1987]</marker>
<rawString>R. Kasper. A unification method for disjunctive feature descriptions. In Proceedings of the 25&apos;ih ACL, Stanford, 1987.</rawString>
</citation>
<citation valid="true">
<authors>
<author>K Kogure</author>
</authors>
<title>Strategic lazy incremental copy graph unification.</title>
<date>1990</date>
<booktitle>In Proceedings of COLING &apos;90,</booktitle>
<location>Helsinki,</location>
<marker>[Kogure, 1990]</marker>
<rawString>K. Kogure. Strategic lazy incremental copy graph unification. In Proceedings of COLING &apos;90, Helsinki, 1990.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J T Maxwell</author>
<author>R M Kaplan</author>
</authors>
<title>A method for disjunctive constraint satisfaction.</title>
<date>1991</date>
<booktitle>Current Issues in Parsing Technology.</booktitle>
<editor>In M. Tomita, editor,</editor>
<publisher>Kluver Academic Publishers,</publisher>
<marker>[Maxwell and Kaplan, 1991]</marker>
<rawString>J. T. Maxwell and R. M. Kaplan. A method for disjunctive constraint satisfaction. In M. Tomita, editor, Current Issues in Parsing Technology. Kluver Academic Publishers, 1991.</rawString>
</citation>
<citation valid="true">
<authors>
<author>G Smolka</author>
</authors>
<title>A feature logic with subsorts. Lilog Report 33, IBM Deutschland,</title>
<date>1988</date>
<location>Stuttgart,</location>
<marker>[Smolka, 1988]</marker>
<rawString>G. Smolka. A feature logic with subsorts. Lilog Report 33, IBM Deutschland, Stuttgart, 1988.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>