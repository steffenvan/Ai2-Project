<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<title confidence="0.996177">
Morphonology in the Lexicon
</title>
<author confidence="0.9983">
Lynne J Cahill*
</author>
<affiliation confidence="0.9989665">
School of Cognitive and Computing Sciences
University of Sussex, Brighton BN1 9Q11, England
</affiliation>
<email confidence="0.998142">
Email: lynneca@cogs.susx.ac.uk
</email>
<sectionHeader confidence="0.998567" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999480785714286">
In this paper we present a means of defin-
ing morphonological phenomena in an in-
heritance based lexicon. We make use
of the theory behind the formal language
MOLUSC, in which morphological alterna-
tions were defined as mappings between se-
quences of tree-structured syllables. We
discuss how the alternations can be defined
in the inheritance-based lexical representa-
tion language DATR, and how the phono-
logical aspects can be built upon to bring
it closer to an integrated lexicon with rep-
resentations which can be used by both the
morphology and phonology of a language.
</bodyText>
<sectionHeader confidence="0.999517" genericHeader="introduction">
1 Introduction
</sectionHeader>
<bodyText confidence="0.989066218181818">
The use of inheritance mechanisms in computational
linguistics has become wide-ranging, with applica-
tions in semantics, syntax, morphology and phonol-
ogy. In this paper, we shall examine the applicability
of such mechanisms to phonological aspects of mor-
phology.
The inheritance-based lexical representation lan-
guage, DATR, has become widely used for vari-
ous aspects of linguistic description, and previous
treatments of both morphological and phonologi-
cal phenomena in DATR have shown its applica-
bility to this area, both for its handling of inher-
itance by default, and for its ability to define hi-
erarchical structures. For example, [Gibbon, 1990]
describes how Kikuyu tone displacement and Ara-
bic non-concatenative morphology can be defined in
&amp;quot;Thanks are due to Roger Evans and Dafydd Gibbon
for comments on previous drafts of this paper.
DATR and [Reinhard, 1990] describes a hierarchical
approach to German umlaut. In this paper we as-
sume a knowledge of DATR and refer the reader to
the introductions in [Cahill and Evans, 1990] and
[Evans and Gazdar, 1990].
MOLUSC 1990a],[Cahill, 1990b],[Cahill
and Gazdar, 1990]), is a formal language for defin-
ing morphological alternations as mappings between
sequences of tree-structured syllables. It is based on
the theory that (many) morphological alternations
are phonologically based, and can best be described
as operating on hierarchical structures, such as the
syllable. However, there are fundamentally linear as-
pects of morphological alternations, which require
reference to concepts such as &amp;quot;initial&amp;quot;, &amp;quot;final&amp;quot; and
&amp;quot;penultimate&amp;quot;.
An account of English verbal morphology was dis-
cussed in [Cahill, 1990b] which was expressed in a
combined DATR/MOLUSC lexicon fragment. The
morphological distribution was defined by the DATR
while the morphological realisation was defined by a
set of MOLUSC functions. In this paper, we discuss
an account derived from this (see appendix), which
expresses the distribution of alternations involved in
the same underlying way, but which does not require
a separate language to define them. In doing this, we
can reduce the two-tiered DATR/MOLUSC approach
originally used, to a single-tiered account. This has
the obvious advantage of reducing the &amp;quot;mechanisms&amp;quot;
needed. More importantly, however, we shall demon-
strate, with discussion of how the morphonological
information may be generalised to be more useful to
the phonology proper, it also has the advantage of
moving the account towards a fully-integrated lex-
icon, in which ultimately all levels of description —
morphology, phonology, orthography, syntax, seman-
tics — are combined.
</bodyText>
<page confidence="0.99808">
87
</page>
<bodyText confidence="0.999963888888889">
In the following sections we shall consider the
structures involved and how they may be defined in
DATR, considering how to model both the precise
structures used by MOLUSC and more generally use-
ful phonological structures. We shall then consider
how we might define the alternations. Finally, we
shall discuss the advantages of this approach over
previous descriptions of such phenomena as well as
over the original MOLUSC language.
</bodyText>
<sectionHeader confidence="0.985353" genericHeader="method">
2 Phonological Structures
</sectionHeader>
<bodyText confidence="0.992666090909091">
In many previous approaches to morphology, partic-
ularly in the English-dominated NLP community, it
was assumed that morphology consisted fundamen-
tally of &amp;quot;sticking together&amp;quot; morphemes, and making
the necessary adjustments to allow for spelling pe-
culiarities. [Cahill, 1990b] suggested that this was
too narrow a view, even for the rather impover-
ished inflection displayed by English. That there are
several subclasses of English verbs which inflect by
means other than affixation (e.g. &amp;quot;bring&amp;quot;-&amp;quot;brought&amp;quot; ,
&amp;quot;sit&amp;quot;-&amp;quot;sat&amp;quot;) would seem to be a strong argument in
itself, but looking at other languages such as the
Semitic languages shows that there is an enormous
body of interesting morphological phenomena which
needs to be addressed. [Cahill, 1990b] showed that a
view of morphological alternations as mappings be-
tween tree-structured syllables permitted a natural
and succinct way of defining such alternations. It
also showed that levels of structure above the level of
the syllable, while clearly vital for phonological de-
scription, were not necessary for morphological de-
scription. Thus the approach used structures which
consisted only of linear sequences of tree-structured
syllables.
The question of structure above the level of the
syllable is an interesting one. The use of metrical or
tonal structure is clearly relevant to the phonology
of a language, but it is debatable whether it has any
place at all in the lexicon. While certain metrical no-
tions such as stress are relevant to the lexicon (con-
sider the noun—verb alternation &amp;quot;re&apos;ject&amp;quot;—&amp;quot;reject&amp;quot;),
the actual metrical structure of even a polysyllabic
word is dependent on the context in which it appears.
Thus, it would seem reasonable to assume that the
lexicon specifies the actual level of stress on each syl-
lable of a word&apos; but that the structure derived from
this is extra-lexical.
In the two-tiered DATR/MOLUSC lexicon, the
phonological structures were assumed to be defined
fully at each lexical entry. This meant that we
could not make use of the inheritance mechanisms
in DATR, even though the structures lent themselves
to such definition. In the present work we shall define
the structures hierarchically in DATR, thus avoiding
&apos;There is an issue of how many levels we may want
to differentiate in the lexicon, but it is not one which we
propose to address in the current work.
redundancy and enabling generalisations about the
structures which were previously impossible.
The formal semantics of MOLUSC ([Cahill and
Gazdar, 1990]) defined the structures as having sets
of feature definitions at each node. Although this
facility was not used in the examples provided nor
in the implementation, it is an aspect of the theory
which we shall build upon in the current work.
</bodyText>
<subsectionHeader confidence="0.922538">
2.1 Trees
</subsectionHeader>
<bodyText confidence="0.913483875">
In the first instance, let us consider the simple situ-
ation, where there are onset, peak, coda and rhyme
nodes which consist of (sequences of) phonemes. A
simple mono-syllabic root may be defined in DATR
by the following:
Word: &lt;root&gt; == (&amp;quot;&lt;onset&gt;&amp;quot; &amp;quot;&lt;rhyme&gt;&amp;quot;)
&lt;rhyme&gt; == (&amp;quot;&lt;peak&gt;&amp;quot; &amp;quot;&lt;coda&gt;&amp;quot;)
&lt;onset&gt; == 0
&lt;peak&gt; == 0
&lt;coda&gt; == 0.
Here the root is said to consist of an onset and
a rhyme (which are provided at the original query
node), and a rhyme (if not explicitly defined at the
query node) consists of a peak and a coda. The on-
set, peak and coda are by default 0. Now we can
define the root &amp;quot;spell&amp;quot; as follows:
</bodyText>
<equation confidence="0.6532345">
Spell: &lt;&gt; == Word
&lt;onset&gt; == (s p)
&lt;peak&gt; == e
&lt;coda&gt; == 1.
</equation>
<bodyText confidence="0.99993924">
The structure is inherited from the Word node, with
just the values of the onset, peak and coda defined
at the node Spe112.
In our example theory defining a fragment of the
English verb system, we only have mono- and di-
syllabic roots to contend with, but we need to con-
sider how to handle a root consisting of an arbitrary
number of syllables. We need to allow for a poten-
tially infinite number of syllables in a root, but we
also need each syllable in a root to maintain its own
identity so as to permit both the definition of the
values of the onset, peak and coda of the individual
lexemes, and to allow for the definition of alterna-
tions in particular syllables. In MOLUSC this was
achieved by means of a simple numbering convention
where +N referred to the Nth syllable from the left
and —N referred to the Nth syllable from the right.
In our DATR-only account, we achieve the linear
structures by means of a path prefix &amp;quot;struct&amp;quot;, and by
defining the number of syllables in a root at its own
lexical entry by means of a sequence of symbols —
one for each syllable more than one. In the example
below, we use the term &amp;quot;ext&amp;quot; (for &amp;quot;extension&amp;quot;) to
denote each syllable above one. Thus, a disyllabic
root could be defined by the line:
</bodyText>
<footnote confidence="0.881124">
2The brackets around the s p are just for the benefit
of DATR. They are removed in the final result.
</footnote>
<page confidence="0.997407">
88
</page>
<bodyText confidence="0.8303705">
&lt;sylls&gt; == ext
and a tri-syllabic root:
&lt;sylls&gt; == (ext ext)
and so on. At a higher node (in our case, &amp;quot;VERB&amp;quot;)
we can then define the structure of a root with the
following:
</bodyText>
<equation confidence="0.9672635">
&lt;root&gt; == &lt;struct &amp;quot;&lt;sylls&gt;&amp;quot;&gt;
&lt;struct ext&gt; == (&lt;struct&gt; &amp;quot;&lt;syll ext&gt;&amp;quot;)
&lt;struct&gt; == &lt;syll&gt;
&lt;syll&gt; == (&amp;quot;&lt;onset&gt;&amp;quot; &amp;quot;&lt;rhyme&gt;&amp;quot;)
</equation>
<bodyText confidence="0.999889625">
Let us run through how this works by looking at
the example of a tri-syllabic root which does not
have values for any &lt;syll&gt; paths defined at its
node, so we can ignore the quotes on the &lt;syll&gt;
paths. A tri-syllabic root will have the value (ext
ext) for the path &lt;sylls&gt; at its own entry, so
the first line defines the root in this case to be
&lt;struct ext ext&gt;. The second line defines the
value for the path &lt;struct ext&gt;, and this is the
closest match for the path we want to evaluate. It is
defined to be the list (&lt;struct ext&gt; &amp;quot;&lt;syll ext
ext&gt;&amp;quot;), as the extra &amp;quot;ext&amp;quot;from the path we are
evaluating gets added to any paths to be evaluated
on the right hand side. Taking the second part
of this first, &lt;syll ext ext&gt;, assuming it isn&apos;t ex-
plicitly defined at the word&apos;s entry, is defined as
(&amp;quot;&lt;onset ext ext&gt;&amp;quot; &amp;quot;&lt;rhyme ext ext&gt;&amp;quot;). This
again is because we carry over the extra elements
from a left-hand side path to the right-hand side.
The path &lt;struct ext&gt; is defined explicitly as
(&lt;struct&gt; &amp;quot;&lt;syll ext&gt;&amp;quot;), and &lt;struct&gt; is de-
fined as being the same as &lt;syll&gt;. The derivation
can be viewed as follows, with the numbers of the
lines from which values are derived in brackets:
</bodyText>
<equation confidence="0.950817">
&lt;root&gt; == &lt;struct ext ext&gt; (1)
&lt;struct ext ext&gt; == (&lt;struct ext&gt;
&amp;quot;&lt;syll ext ext&gt;&amp;quot;) (2)
&lt;struct ext&gt; == (&lt;struct&gt; &amp;quot;&lt;syll ext&gt;&amp;quot;) (2)
&lt;struct&gt; == &lt;syll&gt; (3)
&lt;syll&gt; == (&amp;quot;&lt;onset&gt;&amp;quot; &amp;quot;&lt;rhyme&gt;&amp;quot;) (4)
</equation>
<listItem confidence="0.634244823529412">
-&gt; &lt;struct ext&gt; == ((&amp;quot;&lt;onset&gt;&amp;quot; &amp;quot;&lt;rhyme&gt;&amp;quot;)
&amp;quot;&lt;syll ext&gt;&amp;quot;)
&lt;syll ext&gt; == (&amp;quot;&lt;onset ext&gt;&amp;quot;
&amp;quot;&lt;rhyme ext&gt;&amp;quot;) (4)
-&gt; &lt;struct ext&gt; == ((&amp;quot;&lt;onset&gt;&amp;quot; &amp;quot;&lt;rhyme&gt;&amp;quot;)
(&amp;quot;&lt;onset ext&gt;&amp;quot;
&amp;quot;&lt;rhyme ext&gt;&amp;quot;))
-&gt; &lt;struct ext ext&gt; == ((&amp;quot;&lt;onset&gt;&amp;quot;
&amp;quot;&lt;rhyme&gt;&amp;quot;)
(&amp;quot;&lt;onset ext&gt;&amp;quot;
&amp;quot;&lt;rhyme ext&gt;&amp;quot;)
&amp;quot;&lt;syll ext ext&gt;&amp;quot;)
&lt;syll ext ext&gt; == (&amp;quot;&lt;onset ext ext&gt;&amp;quot;
&amp;quot;&lt;rhyme ext ext&gt;&amp;quot;) (4)
-&gt; &lt;struct ext ext&gt; == ((&amp;quot;&lt;onset&gt;&amp;quot;
&amp;quot;&lt;rhyme&gt;&amp;quot;)
(&amp;quot;&lt;onset ext&gt;&amp;quot;
</listItem>
<bodyText confidence="0.996120122807018">
&amp;quot;&lt;rhyme ext&gt;&amp;quot;)
(&amp;quot;&lt;onset ext ext&gt;&amp;quot;
&amp;quot;&lt;rhyme ext ext&gt;&amp;quot;))
-&gt; &lt;root&gt; == ((&amp;quot;&lt;onset&gt;&amp;quot; &amp;quot;&lt;rhyme&gt;&amp;quot;)
(&amp;quot;&lt;onset ext&gt;&amp;quot; &amp;quot;&lt;rhyme ext&gt;&amp;quot;)
(&amp;quot;&lt;onset ext ext&gt;&amp;quot;
&amp;quot;&lt;rhyme ext ext&gt;&amp;quot;))
The root which results is therefore,
(&amp;quot;&lt;onset&gt;&amp;quot; &amp;quot;&lt;rhyme&gt;&amp;quot;
&amp;quot;&lt;onset ext&gt;&amp;quot; &amp;quot;&lt;rhyme ext&gt;&amp;quot;
&amp;quot;&lt;onset ext ext&gt;&amp;quot; &amp;quot;&lt;rhyme ext ext&gt;&amp;quot;)
so that we can refer to the initial syllable and its
constituents with paths without any &amp;quot;ext&amp;quot;s, the sec-
ond syllable and its constituents with paths with one
&amp;quot;ext&amp;quot; suffixed and so on.
The idea of having to define the number of sylla-
bles in a root at each lexical entry may seem a little
undesirable, but we will need to define each syllable
separately at the entry anyway, so the explicit in-
formation of how many syllables there are is a very
small cost. In addition, since in our example frag-
ment below most roots are monosyllabic anyway, this
will not have to be defined for each entry. We can
have a default value for &lt;sylls&gt; at the VERB node of
&amp;quot;0&amp;quot;. Although this is a language specific advantage,
it is expected that it would not often be necessary to
define polysyllabic roots for any language, since very
long words will usually be made up of either com-
pounded roots (as happens frequently in German)
or a single root plus several affixes (as happens in
agglutinative languages such as Turkish).
The structures as defined above allow us to refer
to an individual syllable provided we know its po-
sition from the left. But if we want to refer to the
last syllable in a root, for example, we need to know
how many syllables are in each root, thus preventing
us from making generalisations over classes of verbs
which do not all have the same number of syllables.
This is clearly undesirable, but it can be avoided. In
the example of English verbs, it is a feature of the
verb roots that while most roots are monosyllabic
those which are not only require reference to their
final syllable, never their initial syllable. We there-
fore want to reverse the structure definition above,
which can be very simply achieved by reversing the
order of the paths &lt;struct&gt; and &amp;quot;&lt;syll ext&gt;&amp;quot; in
the list on the right-hand side of the second line3.
What this means is that we must define for each lan-
guage or language fragment (it may be different for
nouns and verbs, for example) whether any alterna-
tions take place at the right- or left-hand end of the
root. It is possible to refer to a syllable any num-
ber in from either side, not just the initial or final
&apos;In our example fragment, we have replaced the term
&amp;quot;ext&amp;quot; with &amp;quot;pref&amp;quot; to reflect the fact that it is prefixing
which extends the structure. The actual term used is, of
course, irrelevant.
</bodyText>
<page confidence="0.998842">
89
</page>
<bodyText confidence="0.999978384615385">
and any form or set of forms which show a devia-
tion from the norm can be accommodated in DATR
simply by means of overriding structure definitions
at a lower node in the hierarchy. However, the def-
inition of structure at the higher node(s) make for
a generalisation about the set of forms covered by
that node. This is in marked contrast to MOLUSC,
which permitted equally easy reference to either end,
and even permitted mixing within a single alterna-
tion definition. MOLUSC was much too powerful in
this respect, and permitted the definition of alterna-
tions which do not occur in any language, so this is
clearly a desirable restriction.
</bodyText>
<subsectionHeader confidence="0.996989">
2.2 Segments within onset, peak and coda
</subsectionHeader>
<bodyText confidence="0.999992388888889">
As well as accessing syllables within a sequence, MO-
LUSC permitted the accessing of segments within the
onset, peak and coda in a similar way. Although we
do not want to go into detail here, as we do not pro-
pose to ultimately use discrete segments, we can do
the same in the DATR framework outlined above, by
means of a similar mechanism to that used for sylla-
bles. Again, we need to decide whether we want to
extend leftwards or rightwards, and this again gives
us a highly desirable restriction, which in this case
we can use to restrict onsets to extend rightwards
and codas to extend leftwards. Thus, we may refer
to initial, second etc. segments within the onset and
final, penultimate etc. segments within the coda but
not vice versa. Of course, DATR itself does not force
such restrictions, but the framework we have defined
forces the lexicon writer to decide on how to apply
the restrictions.
</bodyText>
<subsectionHeader confidence="0.998223">
2.3 Phonological features
</subsectionHeader>
<bodyText confidence="0.999997142857143">
As mentioned above, we have used segments in the
examples given so far for clarity of explanation. In
MOLUSC and in the current work we intend the real
unit of description to be the phonological feature or
event rather than the segment. Much recent work,
both computational and theoretical, has shown that
the use of such units permits a more accurate, and
above all, a declarative description of phonological
phenomena such as ellision, epenthesis and assimila-
tion (e.g. [Coleman, 1992], [Bird and Klein, 1990]).
As mentioned above, [Cahill and Gazdar, 1990] de-
fined a formal semantics for the MOLUSC language
which permitted the definition of phonological fea-
tures at any level in the structure, although the im-
plementation and examples did not make use of fea-
ture definitions except at terminal nodes. Thus, the
segment labels below the onset, peak and coda nodes
were deemed to be abbreviations for a set of fea-
tures, any one or more of which could be altered
by a morphological alternation. It is possible to
talk about inheritance of phonological features up
or down the tree. For example, a [+ voice] fea-
ture at a rhyme node may be considered to be in-
herited by the peak and coda nodes below it, so that
any segments within either of those two will contain
the feature [+ voice]. Alternatively, the value of a
coda node (null or non-null) may be inherited by the
rhyme and syllable nodes above it in order to spec-
ify stress values which may be affected by whether a
syllable is &amp;quot;open&amp;quot; or &amp;quot;closed&amp;quot;.
In the account we are proposing here, we only re-
quire the latter type of inheritance, where the higher
nodes inherit features from the lower nodes. This is
because we are advocating an approach to phonology
like that proposed by [Bird and Klein, 1990], [Cole-
man, 1992]. In both of these approaches, phonologi-
cal features consist of a feature (or &amp;quot;event&amp;quot;) name, a
value for that feature and an argument which defines
how it relates temporally to the other features in the
wore. Thus, for example, in the word &amp;quot;bat&amp;quot; there
may be features such as [-I- voice], [4- labial], [+
alveolar], [4. consonant] and [+ vowel] amongst
others5. The voice feature would have a temporal ar-
gument which expressed the fact that it lasts for the
entire word, the labial feature would be defined as
lasting for some time from the beginning of the word
until the onset of the vowel feature and the alveolar
feature would be defined as commencing at the end
of the vowel feature and ending at the end of the
word. Of course, this is very approximate, but it is
intended only to give the flavour of the treatment.
In an account of this nature, it is not necessary for
the features at higher nodes to be &amp;quot;trickled&amp;quot; down
to lower nodes, since the temporal arguments define
how they relate. However, that is not to say that
the structure is unimportant. Both of the theories
from which we are borrowing here make use of the
notion of a tree-structured syllable, and phonological
restrictions are defined as holding within such struc-
tures. In particular, from the point of view of the
current account, reference to parts of the structure
is necessary for the definition of morphological alter-
nations (see below). In our definition of the structure
given above, the result is a simple list (of segments
in the example we gave). If we use features instead
of segments, the same result is achieved, but instead
of a list of segments, considered to be temporally or-
dered, we end up with a list of features, not tempo-
rally ordered, but with explicit temporal arguments
defining their relationship to each other.
</bodyText>
<subsectionHeader confidence="0.603643">
2.3.1 The features and their arguments
</subsectionHeader>
<bodyText confidence="0.998640090909091">
Although we will not be using segments, we main-
tain the notion of segmental units in the temporal
4[Bird and Klein, 1990] does not use features in this
form exactly, but the notion of temporal relations be-
tween the events is vital to their account
&apos;It is important to note here that in this and all subse-
quent examples of actual phonological features, no claim
is being made as to the accuracy of the actual features
used. They are meant purely to demonstrate the applica-
bility of the framework to (morpho)phonological descrip-
tion and not to demonstrate a full phonological theory.
</bodyText>
<page confidence="0.990515">
90
</page>
<bodyText confidence="0.998777125">
arguments in our examples below. We argue that
segments, although possibly unnecessary in strict
phonological terms, do seem to have a role at some
level. The very fact that our writing system makes
use of segment-type units appears to be an argument
in favour of maintaining their existence at some level,
and in morphological terms it is clear that many al-
ternations seem to require reference to such units.
For example, the English alternation &amp;quot;bend&amp;quot;-&amp;quot;bent&amp;quot;
can be defined as an alternation in the voicing feature
of only the final segment of the coda. We are there-
fore assuming timing boundaries at what would have
been segment boundaries. Thus the word &amp;quot;spell&amp;quot; is
assumed to have four &amp;quot;timing sections&amp;quot;, one for each
of the conventional segments. The stem &amp;quot;spell&amp;quot; can
thus be redefined as follows:
</bodyText>
<table confidence="0.800961333333333">
Spell: &lt;&gt; == VERB
&lt;rhyme_f eats&gt; == ([ + voice 2-4 ])
&lt;onset&gt; == - voice 0-2 ]
+ sibilant 0-1 ]
+ alveolar 0-1 ]
+ stop 1-2 ]
+ labial 1-2 ])
&lt;peak&gt; == (C - round 2-3 ]
- high 2-3 ]
- low 2-3 ]
+ front 2-3 ])
&lt;coda&gt; == ([ + lateral 3-4 ]).
</table>
<bodyText confidence="0.9848905">
The third element in each list is a (very simple)
temporal argument. The sibilant feature, for exam-
ple, lasts from 0 to 1, i.e. the first &amp;quot;segmentsworth&amp;quot;;
the approximant feature of the onset goes from 1 to
2, i.e. the second &amp;quot;segmentsworth&amp;quot;; the voice feature
of the onset covers the whole two segmentsworth of
the onset. These are of course extremely simplified,
both in the definition of the temporal arguments,
and in the descriptions of the features themselves.
But the theories from which we are borrowing have
plenty to say about these aspects of phonology which
is not relevant to how it might be expressed in a
DATR lexicon combining phonological and morpho-
logical description. Note that in the example above,
since we have temporal arguments, it is possibly not
necessary to differentiate the rhyme features (just the
voicing feature in the above example) from syllable
features. We can have the feature [ + voice 2-4 ]
defined at either the rhyme or syllable node. Since
all rhyme features are inherited by the syllable, it
will only be relevant to make the distinction if an
alternation requires reference to the rhyme features
specifically. However, it is more accurate to maintain
the distinction, and so we shall do so.
2.3.2 Inheriting feature arguments
The description above requires that every feature
for which we want to define a value in a stem must be
explicitly defined. In addition, every value for every
feature must be explicitly defined. There is no room
for a marked/unmarked distinction, for example. In
doing this, we are not making use of DATR&apos;s default
inheritance mechanisms to define default values for
features. What we can do to improve on this situ-
ation is to define a set of features for which a value
and a timing must be given (although the value may
be &amp;quot;under&apos; or some such), and provide default values
for each feature at a very high node.
The set of features we have chosen are not intended
to be comprehensive or even necessarily consistent,
but are simply those sufficient to describe the stems
and alternations involved in our example fragment.
The feature set is as follows:
</bodyText>
<figure confidence="0.986467461538461">
alv alveolar
approx = approximant
fric = fricative
high = high
lab labial
lat lateral
low low
nasal = nasal
round = round
sib sibilant
stop = stop
vel velar
voice = voice
</figure>
<bodyText confidence="0.99989316">
The default value for all features is &amp;quot;-&amp;quot; and the de-
fault timing is rl, for &amp;quot;root length&amp;quot; - i.e. the whole
length of the root.
The definition of the structure of a stem (i.e. the
number of syllables) is as before, but the definition of
a syllable needs to take into account the fact that we
are now dealing with lists of features and their val-
ues and timings, rather than linear sequences of seg-
ments. Since we are going to permit the permeation
of features up the tree, we want the syllable node to
contain all of the features for the onset and rhyme
nodes, and the rhyme node to contain all of the fea-
tures for the peak and coda nodes. One consequence
of this is that we cannot simply allow the definition
of features shared by say the peak and coda nodes at
the rhyme node, since they will not then be inherited
downwards, and any alternation which is dependent
on the value of a feature at the coda node will need
to look at the rhyme and syllable nodes&apos; features,
taking the timings into account as well. It would un-
doubtedly be possible to get around this problem but
for our present purposes the extra cost of defining a
shared feature at both nodes which share it is not a
problem.
The feature sets can be defined as follows:
</bodyText>
<equation confidence="0.9021915">
&lt;syll&gt; == ([ &lt;feats syll&gt; ]
[ &lt;feats onset&gt; ]
[ &lt;rhyme&gt; ])
&lt;rhyme&gt; == ([ &lt;feats rhyme&gt; ]
[ &lt;feats peak&gt; ]
E &lt;feats coda&gt; ])
</equation>
<bodyText confidence="0.9953335">
The paths are not quoted in this because we want the
actual feature set to be defined at the top node, with
</bodyText>
<page confidence="0.997545">
91
</page>
<bodyText confidence="0.991839">
just the values and timings defined at the terminal
nodes. Thus, the feature set can be defi ned:
</bodyText>
<table confidence="0.9884555">
&lt;feats&gt; == &amp;quot;&lt;val alv&gt;&amp;quot; &amp;quot;&lt;time alv&gt;&amp;quot;
[ alv &amp;quot;&lt;val approx&gt;&amp;quot; &amp;quot;&lt;time approx&gt;&amp;quot;
approx &amp;quot;&lt;val fric&gt;&amp;quot; &amp;quot;&lt;time fric&gt;&amp;quot;
fric &amp;quot;&lt;val high&gt;&amp;quot; &amp;quot;&lt;time high&gt;&amp;quot;
high &amp;quot;&lt;val lab&gt;&amp;quot; &amp;quot;&lt;time lab&gt;&amp;quot;
lab &amp;quot;&lt;val lat&gt;&amp;quot; &amp;quot;&lt;time lat&gt;&amp;quot;
lat &amp;quot;&lt;val low&gt;&amp;quot; &amp;quot;&lt;time low&gt;&amp;quot;
low &amp;quot;&lt;val nasal&gt;&amp;quot; &amp;quot;&lt;time nasal&gt;&amp;quot;
nasal &amp;quot;&lt;val round&gt;&amp;quot; &amp;quot;&lt;time round&gt;&amp;quot;
round &amp;quot;&lt;val sib&gt;&amp;quot; &amp;quot;&lt;time sib&gt;&amp;quot;
sib &amp;quot;&lt;val stop&gt;&amp;quot; &amp;quot;&lt;time stop&gt;&amp;quot;
stop &amp;quot;&lt;val vel&gt;&amp;quot; &amp;quot;&lt;time vel&gt;&amp;quot;
vel &amp;quot;&lt;val voice&gt;&amp;quot; &amp;quot;&lt;time voice&gt;&amp;quot; ])
voice
</table>
<bodyText confidence="0.9882974">
Then to find the set of features at the peak node,
for example, the word peak is appended to all of the
(quoted) paths in the feature list, thus evaluating
the val and time for each feature at that node. The
paths:
</bodyText>
<equation confidence="0.941476">
&lt;val&gt; == -
&lt;time&gt; == rl
</equation>
<bodyText confidence="0.972487942028986">
then define default values for the val and time paths.
With these definitions, we can define a stem by sim-
ply providing values for all those features which have
the value &amp;quot;+&amp;quot;6 and times for these. The example
stem &amp;quot;spell&apos; can therefore be defined as:
Spell: &lt;&gt; == VERB_A
&lt;val sib onset&gt; == +
&lt;val lab onset&gt; == +
&lt;val stop onset&gt; == +
&lt;val front peak&gt; == +
&lt;val voice peak&gt; == +
&lt;val lat coda&gt; == +
&lt;val voice coda&gt; m= +
&lt;time sib onset&gt; == 0-1
&lt;time lab onset&gt; == 1-2
&lt;time stop onset&gt; == 1-2
&lt;time front peak&gt; == 2-3
&lt;time voice peak&gt; == 2-3
&lt;time voice coda&gt; == 3-4
&lt;time lat coda&gt; == 3-4.
Although the timings we are using here are extremely
approximate, they can provide a starting point for
phonological/phonetic systems, such as YorkTalk
([Coleman, 1992]). The YorkTalk system defines
phenomena such as epenthesis as adjustments in the
timings of such features, so as to blur the bound-
aries between &amp;quot;segment&amp;quot; sections. For example, the
epenthesis which occurs in words such as &amp;quot;mince&amp;quot;
(/mints/) is a result of the fact that the closure as-
pect of the nasal /n/ is carried over to the non-nasal
&apos;We are using simple boolean valued features here,
but this is not a restriction. Multi-valued features, such
as stress (see section 2 above), can be just as easily
accommodated.
/s/, resulting in a /t/ sound. This type of phonolog-
ical phenomenon is not something we would expect
to be represented in the lexical entry for the word
&amp;quot;mince&amp;quot;, but having approximate, relative timings of
the features gives a system like YorkTalk something
with which it can work more easily than simple seg-
mental structures. They also eliminate the need to
refer to individual segments within onset, peak and
coda. The stem &amp;quot;bend&amp;quot; for example has a coda which
consists of an &amp;quot;n&amp;quot; and a &amp;quot;d&amp;quot; (in conventional terms).
This can be expressed in our account by the features
voice, alveolar, nasal and stop having the value &amp;quot;+&amp;quot;
in the coda, but with the following timings:
&lt;time voice coda&gt; == 2-4
&lt;time nasal coda&gt; == 2-3
&lt;time alv coda&gt; == 2-4
&lt;time stop coda&gt; == 3-4
The voice and alveolar features carry across the
whole coda, but the nasal feature is only on the first
section and the stop feature is only on the second.
There would appear to be a problem here, result-
ing from the decision to only allow inheritance of fea-
tures up the tree, in that it is possible for a feature
at a particular node to be given a value at that node
but a timing which only covers part of the node. For
example, the stem &amp;quot;swell&amp;quot; has an onset whose voice
feature has the value &amp;quot;-&amp;quot; for the first section and
&amp;quot;+&amp;quot; for the second section. However, as we noted in
the example of &amp;quot;spell&amp;quot; above, it is possible for the
syllable node to contain features whose temporal ar-
guments do not cover the whole syllable. Thus, the
onset of &amp;quot;swell&amp;quot; would have a feature &amp;quot;[- voice)&amp;quot;
which has the timing &amp;quot;0-1&amp;quot; and the syllable node
would have the feature &amp;quot;E+ voice]&amp;quot;, with the tem-
poral argument &amp;quot;1-4&amp;quot;.
</bodyText>
<sectionHeader confidence="0.995502" genericHeader="method">
3 Morphological Alternations
</sectionHeader>
<bodyText confidence="0.9873843125">
Let us momentarily return to the use of segments for
clarity, and consider how to define alternations be-
tween forms. In our example case of English verbs,
most of the inflections take the form of suffixation,
which can be defined trivially. For example, the
present participle form might be defined:
&lt;pres part&gt; == (&amp;quot;&lt;root pres&gt;&amp;quot; ing)
(with the suffix itself having its structure defined
- we are not concerned with that here). What is
more interesting, however, is the definition of alter-
nations such as that in the forms &amp;quot;bereave&amp;quot;-&amp;quot;bereft&amp;quot;,
&amp;quot;cleave&amp;quot;-&amp;quot;cleft&amp;quot;. Such verbs, although only in small
groups, do exhibit consistent, phonologically deter-
mined, but not strictly phonological, alternations. In
MOLUSC, these could be defined by means of func-
tions such as the following:
</bodyText>
<footnote confidence="0.991498">
[(peak,-1)/ii/ = /e/]
[(coda,-1,-1)/v/ If/]
[(coda,-1,-1)[+ voice] [- voice]]
</footnote>
<page confidence="0.995912">
92
</page>
<bodyText confidence="0.9993268">
There are two aspects to these alternations. On
the one hand, defining the alternation between, say, a
peak of /ii/ with a peak of /e/ is extremely straight-
forward, simply requiring path extensions to the
&amp;quot;&lt;peak&gt;&amp;quot;7 definitions for past and present. Thus,
the following would define the alternation:
&lt;peak pres&gt; == ii
&lt;peak past&gt; == e
However, in the account of English verbs in [Cahill,
1990b], such verbs were grouped together with a
large number of other verbs which did not exhibit
this precise alternation, with the peak alternation
being dependent on the original peak. Thus, the past
tense peak is /e/ if the present tense peak is /ii/ and
the same as the present tense peak otherwise.
</bodyText>
<subsectionHeader confidence="0.9926225">
3.1 Defining context-dependent
alternations
</subsectionHeader>
<bodyText confidence="0.998935647058823">
We can define this type of context-dependent alter-
nation in our framework by evaluating the present
tense value for the peak and using that as an argu-
ment in a path for defining the past tense peak. The
code for this is:
&lt;peak past&gt; == &lt;peak_change &amp;quot;&lt;peak pres&gt;&amp;quot;&gt;
&lt;peak_change ii&gt; == e
&lt;peak_change&gt; == &amp;quot;&lt;peak pres&gt;&amp;quot;
This says that the peak of the past tense root
(&lt;peak past&gt;) is found by evaluating the path which
has the word peak_change followed by whatever the
value of the present tense peak is (&amp;quot;&lt;peak pres&gt;&amp;quot;).
If this results in the path &lt;peak_change ii&gt; (i.e. if
the present tense peak is &amp;quot;ii&amp;quot;) then the past tense
peak is &amp;quot;e&amp;quot;. In any other case (the path with the
present peak value unspecified) the past tense peak is
the same as the present tense peak (&amp;quot;&lt;peak pres&gt;&amp;quot;).
</bodyText>
<subsectionHeader confidence="0.999936">
3.2 Defining feature value alternations
</subsectionHeader>
<bodyText confidence="0.974585545454546">
The coda change function is given in MOLUSC in two
different forms - one with segments and the other
with features. The version with segments can, unsur-
prisingly, be defined in exactly the same way as the
peak change above. Let us consider the alternation
defined as an alternation in the value of the voicing
feature. The voicing feature of the set of verbs we
are talking about is altered if the final segment of
the coda is either a labial fricative (&amp;quot;v&amp;quot;) or an alve-
olar stop (&amp;quot;d&amp;quot;). There are therefore four features in
whose values we are interested: lab, fric, alv and
stop. We can define the value of the voicing feature
of the coda in the past tense form to be dependent
on the values of all four of these features:
&lt;val voice coda past&gt; ==
&lt;coda_change &amp;quot;&lt;val fric coda pres&gt;&amp;quot;
&apos;This is the peak of the final syllable in all cases. We
have already discussed above how to define roots as ex-
tending from either the right or the left, and we assume
here that the roots all extend from the right.
&amp;quot;&lt;val lab coda pres&gt;&amp;quot;
&amp;quot;&lt;val stop coda pres&gt;&amp;quot;
&amp;quot;&lt;val alv coda pres&gt;&amp;quot;&gt;
and we can define the actual value simply by means
of the following two DATR sentences:
&lt;coda_change + +&gt; == -
&lt;coda_change - - + +&gt; == -
The first says that, if the values of both the fric
and lab features are &amp;quot;+&amp;quot; then the voice feature has
the value &amp;quot;-&amp;quot;, regardless of what the values of the
stop and all, features are. The second says that if
the fric and lab features both have the value &amp;quot;-&amp;quot;
and the stop and alv features both have the value
&amp;quot;+&amp;quot; then the value of the voice feature is &amp;quot;-&amp;quot;. Note
that the asymmetry is necessary but insignificant. It
is not possible to define the alternation so that it is
unimportant what the values of either the fric and
lab features or the stop and alv features are, but
it should be clear that in a consistent phonology, it
would not be possible to have both the fric and
stop features having the value &amp;quot;+&amp;quot; and even if it
were possible to have the alv and lab features with
the value it is highly unlikely that it would af-
fect such an alternation. That is to say, in the exam-
ples of alternations we have looked at, such conflicts
have never arisen.
Two more alternations which can interestingly be
handled very neatly in this framework are the sibi-
lant/voice and alveolar/voice dependent &amp;quot;s&amp;quot; and &amp;quot;d&amp;quot;
suffixes in English. The plural noun and present
tense third person singular verb suffixes in English
both have three realisations: /iz/ after sibilants, /s/
after unvoiced non-sibilants and /z/ after voiced non-
sibilants. Traditionally this is defined with rules such
as,
</bodyText>
<equation confidence="0.989289">
S /iz/ / [-1- sib]
S /s/ / [- voice]
S /z/ / voice]
</equation>
<bodyText confidence="0.960350642857143">
where the first rule must apply before the other two.
Alternatively, the feature [- sib] must be specified in
the second and third rules in order to eliminate the
need for ordering. In our account, we can define this
alternation declaratively and succinctly. As with the
coda voicing alternation described above, we need to
evaluate a path which contains values of features -
in this case the sib and voice features. The present
tense third person singular form is defined as:
&lt;pres third sing&gt; ==
(&amp;quot;&lt;root pres&gt;&amp;quot; &lt;ssuff &amp;quot;&lt;val sib coda&gt;&amp;quot;
&amp;quot;&lt;val voice coda&gt;&amp;quot;&gt;)
and the value of the suffix (&amp;quot;ssuff&amp;quot;) is defined very
simply with the following liness:
</bodyText>
<construct confidence="0.485587666666667">
&lt;ssuff +&gt; == iz
&lt;ssuff - +&gt; == z
&lt;ssuff -&gt; == s
</construct>
<footnote confidence="0.9747655">
8We have left the suffix forms as segments rather than
expanding them out to features for simplicity.
</footnote>
<page confidence="0.998506">
93
</page>
<bodyText confidence="0.999843454545455">
This says that if the value of the sib feature is &amp;quot;+&amp;quot;
then the ssuff is &amp;quot;iz&amp;quot; , regardless of what the value
of the voice feature is, and if the sib feature has
the value &amp;quot;-&amp;quot; then the ssuff is &amp;quot;z&amp;quot; if the voice fea-
ture has the value &amp;quot;+&amp;quot; and &amp;quot;s&amp;quot; otherwise. We can
do a similar thing for the past tense lid/-/d/-/t/
suffix with the all: and voice features. This analy-
sis permits us to define the alternation declaratively,
and hence without any need for rule ordering, but we
can specify one feature value less than is necessary
to avoid ordering in the traditional description.
</bodyText>
<sectionHeader confidence="0.996977" genericHeader="method">
4 Conclusions
</sectionHeader>
<bodyText confidence="0.999963047058824">
We have presented an approach to describing mor-
phological alternations in the lexicon which combines
linear and hierarchical notions, making use of the
theory behind MOLUSC. Let us now consider the
advantages of this approach, both over the MOLUSC
language and over previous DATR approaches to such
phenomena.
MOLUSC defined all morphological alternations
as mappings between linear sequences of tree-
structured syllables, including affixation. This re-
quired extending the numerical labelling to include
+0 and -0 to represent the prefix and suffix slots.
While this was a reasonable extension to permit the
definition of all morphological alternations within the
same framework, it ignored the obvious difference be-
tween affixation and phonologically related alterna-
tions. It also implied (although it did not require)
that all affixes were monosyllabic. While this is very
often the case, it is by no means always so (e.g. En-
glish &amp;quot;ation&amp;quot; , Latin &amp;quot;amus&amp;quot; etc.) and MOLUSC did
not have anything to say about these. Equally, it did
not permit compounding, since every morphological
process had to involve a stem and an affix.
In the account we have proposed here, we can have
the best of both worlds. We can use the type of defi-
nitions of alternations that MOLUSC used to handle
the phonologically related phenomena, but we can
leave the affixation and compounding to be treated
as simple concatenation in DATR lists.
The account proposed here also has the advantage,
mentioned above, that certain types of alternation
and structural definition are much harder to define
than in MQLUSC. MOLUSC was noticably overpow-
ered, permitting the definition of alternations which
affected both the first syllable and penultimate coda,
dependent on the value of the third onset, for exam-
ple, a combination unlikely in the extreme. [Cahill,
1990b] discussed some possible ways to restrict the
language to have context dependencies adjacent to
the alternation being defined and to only permit ref-
erence to the initial, second, final and penultimate
syllables, for example. Such restrictions are not en-
forced by the account discussed above, but the kind
of alternations which we would want to avoid are no-
tably more difficult to define, which is in contrast to
MOLUSC.
The present account has much in common with
that in [Gibbon, 1990], which provided accounts of
Kikuyu tone displacement and Arabic bin yan mor-
phology. The account Gibbon gave of Arabic can be
directly contrasted with the general approach pro-
posed here. Gibbon, like most others, makes use of
a C V template level, with the C and V slots be-
ing filled by inheritance through a DATR lexicon. In
our account, we can deal with the Arabic &amp;quot;template&amp;quot;
morphology without the need for this extra layer, by
using the syllabic structure. The vowels are defined
simply to be the peaks of the first, second etc. syl-
lables and the consonants are defined as the onsets
and codas. An analysis along these lines using MO-
LUSC was given in [Cahill, 1990b], and it could be
translated into the framework described above in the
same way as the English fragment has been. This
would amount to a description very similar to that
in [Gibbon, 1990], but the resultant form, instead
of being simply a sequence of segments, would be
a fully specified phonological structure of the type
described above. Thus, the node for each triliteral
root would define the three basic consonant feature
sets, with the form for each bin yan being defined as
a syllable sequence, for which the onset and coda for
each syllable would inherit from the root definition.
The vowel alternations would be defined exactly as
the peak alternations in the English example above.
A small example DATR theory by Dafydd Gib-
bon in [Evans and Gazdar, 1990] (pp. 99-100) also
gives a small example of phonological underspecifi-
cation could be expressed in DATR. An interesting
extension of the current work would be to attempt
to integrate it with the definition of underspecified
phonology given by Gibbon.
The framework outlined here, then, permits the
same intuitive description of morphonological alter-
nations as did MOLUSC, but with the following ad-
vantages:
</bodyText>
<listItem confidence="0.9938485">
• it forces the lexicon writer to restrict, or at least
guide, the types of alternations occurring in any
language fragment;
• it permits a more simple and intuitive treatment
of concatenation;
• it moves the theory closer to an integrated lex-
</listItem>
<bodyText confidence="0.7953835">
icon - the output of the morphology is phono-
logical representations which could be used by
existing phonological theories and implementa-
tions.
</bodyText>
<sectionHeader confidence="0.953291" genericHeader="conclusions">
Appendix: The DATR code
</sectionHeader>
<figure confidence="0.920210217391304">
VERB:
&lt;&gt; == ()
&lt;root&gt; == &lt;struct &amp;quot;&lt;sylls&gt;&amp;quot;&gt;
&lt;sylls&gt; == ()
&lt;struct pref&gt; == (&amp;quot;&lt;syll pref&gt;&amp;quot;
&lt;struct&gt;)
&lt;struct&gt; == &lt;syll&gt;
94
&lt;syll&gt; == a &lt;feats syll&gt; ]
[ &lt;feats onset&gt; ]
[ &lt;rhyme&gt; ])
&lt;rhyme&gt; == a &lt;feats rhyme&gt; ]
&lt;feats peak&gt; ]
[ &lt;feats coda&gt; ])
&lt;feats&gt; ==
([alv &amp;quot;&lt;val alv&gt;&amp;quot; &amp;quot;&lt;time alv&gt;&amp;quot;
approx &amp;quot;&lt;val approx&gt;&amp;quot; &amp;quot;&lt;time approx&gt;&amp;quot;
fric &amp;quot;&lt;val fric&gt;&amp;quot; &amp;quot;&lt;time fric&gt;&amp;quot;
high &amp;quot;&lt;val high&gt;&amp;quot; &amp;quot;&lt;time high&gt;&amp;quot;
lab &amp;quot;&lt;val lab&gt;&amp;quot; &amp;quot;&lt;time lab&gt;&amp;quot;
lat &amp;quot;&lt;val lat&gt;&amp;quot; &amp;quot;&lt;time lat&gt;&amp;quot;
low &amp;quot;&lt;val low&gt;&amp;quot; &amp;quot;&lt;time low&gt;&amp;quot;
nasal &amp;quot;&lt;val nasal&gt;&amp;quot; &amp;quot;&lt;time nasal&gt;&amp;quot;
round &amp;quot;&lt;val round&gt;&amp;quot; &amp;quot;&lt;time round&gt;&amp;quot;
sib &amp;quot;&lt;val sib&gt;&amp;quot; &amp;quot;&lt;time sib&gt;&amp;quot;
stop &amp;quot;&lt;val stop&gt;&amp;quot; &amp;quot;&lt;time stop&gt;&amp;quot;
vel &amp;quot;&lt;val vel&gt;&amp;quot; &amp;quot;&lt;time vel&gt;&amp;quot;
voice &amp;quot;&lt;val voice&gt;&amp;quot; &amp;quot;&lt;time voice&gt;&amp;quot;])
&lt;val&gt; == -
&lt;time&gt; == rl
&lt;pres&gt; == &amp;quot;&lt;root pres&gt;&amp;quot;
&lt;pres part&gt; == (&amp;quot;&lt;root pres&gt;&amp;quot; ing)
&lt;pres third sing&gt; == (&amp;quot;&lt;root pres&gt;&amp;quot;
&lt;ssuff &amp;quot;&lt;val sib coda&gt;&amp;quot;
&amp;quot;&lt;val voice coda&gt;&amp;quot;&gt;)
&lt;ssuff +&gt; == iz
&lt;ssuff - +&gt; == z
&lt;ssuff - -&gt; == s
&lt;past&gt; == (&amp;quot;&lt;root past&gt;&amp;quot;
&amp;quot;&lt;dsuff &amp;quot;&lt;val alv coda&gt;&amp;quot;
&amp;quot;&lt;val voice coda&gt;&amp;quot;&gt;&amp;quot;)
&lt;dsuff +&gt; == id
&lt;dsuff - +&gt; == d
&lt;dsuff - -&gt; == t.
VERB_A:
&lt;&gt; == VERB
</figure>
<reference confidence="0.983255146666667">
&lt;feats peak past&gt; == &lt;peak_change
&amp;quot;&lt;feats peak pres&gt;&amp;quot;&gt;
&lt;peak_change ii&gt; == e
&lt;peak_change&gt; == &amp;quot;&lt;feats peak pres&gt;&amp;quot;
&lt;val voice coda past&gt; ==
&lt;coda_change &amp;quot;&lt;val fric coda pres&gt;&amp;quot;
&amp;quot;&lt;val lab coda pres&gt;&amp;quot;
&amp;quot;&lt;val stop coda pres&gt;&amp;quot;
&amp;quot;&lt;val alv coda pres&gt;&amp;quot;&gt;
&lt;coda_change + +&gt; == -
&lt;coda_change - - + +&gt; == -
&lt;coda_change&gt; == &amp;quot;&lt;val voice coda pres&gt;&amp;quot;
&lt;dsuff&gt; == t.
Spell: &lt;&gt; == VERB_A
&lt;val sib onset&gt; == +
&lt;val lab onset&gt; == +
&lt;val stop onset&gt; == +
&lt;val front peak&gt; == +
&lt;val voice peak&gt; == +
&lt;val lat coda&gt; == +
&lt;val voice coda&gt; == +
&lt;time sib onset&gt; == 0-1
&lt;time lab onset&gt; == 1-2
&lt;time stop onset&gt; == 1-2
&lt;time front peak&gt; == 2-3
&lt;time voice peak&gt; == 2-3
&lt;time voice coda&gt; == 3-4
&lt;time lat coda&gt; == 3-4.
Live: &lt;&gt; == VERB
&lt;val lat onset&gt; == +
&lt;val voice onset&gt; == +
&lt;val high peak&gt; == +
&lt;val front peak&gt; == +
&lt;val voice peak&gt; == +
&lt;val voice coda&gt; ==
&lt;val fric coda&gt; == +
&lt;val lab coda&gt; == +
&lt;time lat onset&gt; == 0-1
&lt;time voice onset&gt; == 0-1
&lt;time high peak&gt; == 1-2
&lt;time front peak&gt; == 1-2
&lt;time voice peak&gt; == 1-2
&lt;time voice coda&gt; == 2-3
&lt;time fric coda&gt; == 2-3
&lt;time lab coda&gt; == 2-3.
Bereave:&lt;&gt; == VERB_A
&lt;sylls&gt; == pref
&lt;val voice onset pref&gt; == +
&lt;val lab onset pref&gt; == +
&lt;val stop onset pref&gt; == +
&lt;val front peak pref&gt; == +
&lt;val voice peak pref&gt; == +
&lt;feats coda pref&gt; == 0
&lt;val voice onset&gt; == +
&lt;val approx onset&gt; == +
&lt;val high peak&gt; == +
&lt;val front peak&gt; == +
&lt;val voice peak&gt; == +
&lt;val voice coda&gt; == +
&lt;val fric coda&gt; == +
&lt;val lab coda&gt; == +
&lt;time voice onset pref&gt; == 0-1
&lt;time lab onset pref&gt; == 0-1
&lt;time stop onset pref&gt; == 0-1
&lt;time front peak pref&gt; == 1-2
&lt;time voice peak pref&gt; == 1-2
&lt;time voice onset&gt; == 2-3
&lt;time approx onset&gt; == 2-3
&lt;time high peak&gt; == 3-5
&lt;time front peak&gt; == 3-5
&lt;time voice peak&gt; == 3-5
&lt;time voice coda&gt; == 5-6
&lt;time fric coda&gt; == 5-6
&lt;time lab coda&gt; == 5-6.
Bend: &lt;&gt; == VERB_A
</reference>
<page confidence="0.988388">
95
</page>
<reference confidence="0.95093">
editors, Lexicon und Lexicographie. Olms Verlag,
Hildesheim, 1990.
&lt;val voice onset&gt; == +
&lt;val lab onset&gt; == +
&lt;val stop onset&gt; == +
&lt;val front peak&gt; == +
&lt;val voice peak&gt; == +
&lt;val voice coda&gt; ==
&lt;val nasal coda&gt; == +
&lt;val alv coda&gt; == +
&lt;val stop coda&gt; ==
&lt;time voice onset&gt; == 0-1
&lt;time lab onset&gt; == 0-1
&lt;time stop onset&gt; == 0-1
&lt;time front peak&gt; == 1-2
&lt;time voice peak&gt; == 1-2
&lt;time voice coda&gt; == 2-4
&lt;time nasal coda&gt; == 2-3
&lt;time alv coda&gt; == 2-4
&lt;time stop coda&gt; == 3-4.
</reference>
<sectionHeader confidence="0.91569" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.997084235294117">
[Bird and Klein, 1990] S. Bird and E. Klein. Phono-
logical events. Journal of Linguistics, 26, 1990.
[Cahill and Evans, 19901 Lynne J. Cahill and Roger
Evans. An application of DATR: The TIC lexicon.
In Proc. ECAI-90, pages 120-125, 1990.
[Cahill and Gazdar, 1990] L. J. Cahill and G. J. M.
Gazdar. The semantics of MOLUSC. In ECAI-90,
pages 126-131, Stockholm, 1990.
[Cahill, 1990a] L. J. Cahill. Syllable-based morphol-
ogy. In COLING 90, volume 3, pages 48-53,
Helsinki, 1990.
[Cahill, 1990b] L. J. Cahill. Syllable-based morphol-
ogy for natural language processing (DPhil Disser-
tation). Technical Report Cognitive Science Re-
search Report 181, Cognitive and Computing Sci-
ences, University of Sussex, 1990.
[Coleman, 1992] J. S. Coleman. Synthesis by rule
without segments or rewrite rules. In C.Benoit
and G.Bailly, editors, Talking Machines. Elsevier,
1992.
[Evans and Gazdar, 1990] R. Evans and G. Gazdar.
The DATR papers. Cognitive science research re-
port 139, Cognitive and Computing Sciences, Uni-
versity of Sussex, 1990.
[Gibbon, 1990] Dafydd Gibbon. Prosodic associa-
tion by template inheritance. In Walter Dade-
mans and Gerald Gazdar, editors, Proceedings of
the Workshop on Inheritance in Natural Language
Processing, pages 65-81. Institute for Language
Technology, Tilburg, 1990.
[Reinhard, 1990] S. Rein-
hard. Verarbeitungsprobleme nichtlinearer Mor-
phologien: Umlaut-beschreibung in einem hierar-
chischen Lexicon. In B. Rieger and B. Schaeder,
</reference>
<page confidence="0.998461">
96
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.979716">
<title confidence="0.990744">Morphonology in the Lexicon</title>
<author confidence="0.999866">Lynne J Cahill</author>
<affiliation confidence="0.999762">School of Cognitive and Computing Sciences</affiliation>
<address confidence="0.999789">of Sussex, Brighton BN1 England</address>
<email confidence="0.999907">lynneca@cogs.susx.ac.uk</email>
<abstract confidence="0.9992628">In this paper we present a means of defining morphonological phenomena in an inheritance based lexicon. We make use of the theory behind the formal language MOLUSC, in which morphological alternations were defined as mappings between sequences of tree-structured syllables. We discuss how the alternations can be defined in the inheritance-based lexical representation language DATR, and how the phonological aspects can be built upon to bring it closer to an integrated lexicon with representations which can be used by both the morphology and phonology of a language.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="false">
<title>peak past&gt; == &amp;quot;&lt;feats peak pres&gt;&amp;quot;&gt; ii&gt; == e == &amp;quot;&lt;feats peak pres&gt;&amp;quot; voice coda past&gt;</title>
<publisher></publisher>
<marker></marker>
<rawString>&lt;feats peak past&gt; == &lt;peak_change &amp;quot;&lt;feats peak pres&gt;&amp;quot;&gt; &lt;peak_change ii&gt; == e &lt;peak_change&gt; == &amp;quot;&lt;feats peak pres&gt;&amp;quot; &lt;val voice coda past&gt; ==</rawString>
</citation>
<citation valid="false">
<title>val fric coda pres&gt;&amp;quot; &amp;quot;&lt;val lab coda pres&gt;&amp;quot; &amp;quot;&lt;val stop coda pres&gt;&amp;quot; &amp;quot;&lt;val alv coda pres&gt;&amp;quot;&gt;</title>
<journal>coda_change - - + +&gt; == -&lt;coda_change&gt; ==</journal>
<marker></marker>
<rawString>&lt;coda_change &amp;quot;&lt;val fric coda pres&gt;&amp;quot; &amp;quot;&lt;val lab coda pres&gt;&amp;quot; &amp;quot;&lt;val stop coda pres&gt;&amp;quot; &amp;quot;&lt;val alv coda pres&gt;&amp;quot;&gt; &lt;coda_change + +&gt; == -&lt;coda_change - - + +&gt; == -&lt;coda_change&gt; == &amp;quot;&lt;val voice coda pres&gt;&amp;quot; &lt;dsuff&gt; == t.</rawString>
</citation>
<citation valid="false">
<authors>
<author>Spell</author>
</authors>
<title>VERB_A sib onset&gt;</title>
<journal>lab onset&gt; == + stop onset&gt; == + front peak&gt; == + voice peak&gt; == +</journal>
<marker>Spell, </marker>
<rawString>Spell: &lt;&gt; == VERB_A &lt;val sib onset&gt; == + &lt;val lab onset&gt; == + &lt;val stop onset&gt; == + &lt;val front peak&gt; == + &lt;val voice peak&gt; == +</rawString>
</citation>
<citation valid="false">
<authors>
<author>lat coda</author>
</authors>
<journal>voice coda&gt; == + sib onset&gt; == 0-1 lab onset&gt; == 1-2 stop onset&gt; == 1-2 front peak&gt; == 2-3 voice peak&gt; == 2-3 voice coda&gt; == 3-4 lat coda&gt; ==</journal>
<pages>3--4</pages>
<marker>coda, </marker>
<rawString>&lt;val lat coda&gt; == + &lt;val voice coda&gt; == + &lt;time sib onset&gt; == 0-1 &lt;time lab onset&gt; == 1-2 &lt;time stop onset&gt; == 1-2 &lt;time front peak&gt; == 2-3 &lt;time voice peak&gt; == 2-3 &lt;time voice coda&gt; == 3-4 &lt;time lat coda&gt; == 3-4.</rawString>
</citation>
<citation valid="false">
<authors>
<author>Live VERB lat</author>
</authors>
<title>onset&gt; == + voice onset&gt; == + high peak&gt; == + front peak&gt;</title>
<journal>voice peak&gt; == + voice coda&gt; == fric coda&gt; == + lab coda&gt; == + lat onset&gt; == 0-1 voice onset&gt; == 0-1 high peak&gt; ==</journal>
<volume>1</volume>
<pages>2--3</pages>
<note>front peak&gt; == 1-2 voice peak&gt; == 1-2 voice coda&gt; == 2-3 fric coda&gt; == 2-3 lab coda&gt; ==</note>
<marker>lat, </marker>
<rawString>Live: &lt;&gt; == VERB &lt;val lat onset&gt; == + &lt;val voice onset&gt; == + &lt;val high peak&gt; == + &lt;val front peak&gt; == + &lt;val voice peak&gt; == + &lt;val voice coda&gt; == &lt;val fric coda&gt; == + &lt;val lab coda&gt; == + &lt;time lat onset&gt; == 0-1 &lt;time voice onset&gt; == 0-1 &lt;time high peak&gt; == 1-2 &lt;time front peak&gt; == 1-2 &lt;time voice peak&gt; == 1-2 &lt;time voice coda&gt; == 2-3 &lt;time fric coda&gt; == 2-3 &lt;time lab coda&gt; == 2-3.</rawString>
</citation>
<citation valid="false">
<authors>
<author>Bereave</author>
</authors>
<title>VERB_A == pref voice onset pref&gt; == + lab onset pref&gt; == + stop onset pref&gt; == +</title>
<note>front peak pref&gt; == + voice peak pref&gt; == + coda pref&gt; == 0</note>
<marker>Bereave, </marker>
<rawString>Bereave:&lt;&gt; == VERB_A &lt;sylls&gt; == pref &lt;val voice onset pref&gt; == + &lt;val lab onset pref&gt; == + &lt;val stop onset pref&gt; == + &lt;val front peak pref&gt; == + &lt;val voice peak pref&gt; == + &lt;feats coda pref&gt; == 0</rawString>
</citation>
<citation valid="false">
<journal>voice onset&gt; == + approx onset&gt; == + high peak&gt; == + front peak&gt; == + voice peak&gt; == + voice coda&gt; == + fric coda&gt; == + lab coda&gt; == + voice onset pref&gt; ==</journal>
<pages>0--1</pages>
<marker></marker>
<rawString>&lt;val voice onset&gt; == + &lt;val approx onset&gt; == + &lt;val high peak&gt; == + &lt;val front peak&gt; == + &lt;val voice peak&gt; == + &lt;val voice coda&gt; == + &lt;val fric coda&gt; == + &lt;val lab coda&gt; == + &lt;time voice onset pref&gt; == 0-1</rawString>
</citation>
<citation valid="false">
<title>lab onset pref&gt; == 0-1 stop onset pref&gt; == 0-1 front peak pref&gt;</title>
<journal></journal>
<volume>1</volume>
<pages>1--2</pages>
<note>voice peak pref&gt; ==</note>
<marker></marker>
<rawString>&lt;time lab onset pref&gt; == 0-1 &lt;time stop onset pref&gt; == 0-1 &lt;time front peak pref&gt; == 1-2 &lt;time voice peak pref&gt; == 1-2</rawString>
</citation>
<citation valid="false">
<journal>voice onset&gt; == 2-3 approx onset&gt; ==</journal>
<pages>2--3</pages>
<marker></marker>
<rawString>&lt;time voice onset&gt; == 2-3 &lt;time approx onset&gt; == 2-3</rawString>
</citation>
<citation valid="false">
<pages>3--5</pages>
<note>high peak&gt; == 3-5 front peak&gt; == 3-5 voice peak&gt; ==</note>
<marker></marker>
<rawString>&lt;time high peak&gt; == 3-5 &lt;time front peak&gt; == 3-5 &lt;time voice peak&gt; == 3-5</rawString>
</citation>
<citation valid="false">
<authors>
<author>voice coda</author>
</authors>
<title>5-6 fric coda&gt;</title>
<journal>5-6 lab coda&gt; ==</journal>
<pages>5--6</pages>
<marker>coda, </marker>
<rawString>&lt;time voice coda&gt; == 5-6 &lt;time fric coda&gt; == 5-6 &lt;time lab coda&gt; == 5-6.</rawString>
</citation>
<citation valid="true">
<date>1990</date>
<booktitle>Lexicon und Lexicographie.</booktitle>
<editor>Bend: &lt;&gt; == VERB_A editors,</editor>
<publisher>Olms Verlag,</publisher>
<location>Hildesheim,</location>
<marker>1990</marker>
<rawString>Bend: &lt;&gt; == VERB_A editors, Lexicon und Lexicographie. Olms Verlag, Hildesheim, 1990.</rawString>
</citation>
<citation valid="false">
<journal>voice onset&gt; == + lab onset&gt; == + stop onset&gt; == + front peak&gt; == + voice peak&gt; == + voice coda&gt; == nasal coda&gt; == + alv coda&gt; == + stop coda&gt; == voice onset&gt; == 0-1 lab onset&gt; == 0-1 stop onset&gt; == 0-1 front peak&gt; ==</journal>
<volume>1</volume>
<pages>3--4</pages>
<note>voice peak&gt; == 1-2 voice coda&gt; == 2-4 nasal coda&gt; == 2-3 alv coda&gt; == 2-4 stop coda&gt; ==</note>
<marker></marker>
<rawString>&lt;val voice onset&gt; == + &lt;val lab onset&gt; == + &lt;val stop onset&gt; == + &lt;val front peak&gt; == + &lt;val voice peak&gt; == + &lt;val voice coda&gt; == &lt;val nasal coda&gt; == + &lt;val alv coda&gt; == + &lt;val stop coda&gt; == &lt;time voice onset&gt; == 0-1 &lt;time lab onset&gt; == 0-1 &lt;time stop onset&gt; == 0-1 &lt;time front peak&gt; == 1-2 &lt;time voice peak&gt; == 1-2 &lt;time voice coda&gt; == 2-4 &lt;time nasal coda&gt; == 2-3 &lt;time alv coda&gt; == 2-4 &lt;time stop coda&gt; == 3-4.</rawString>
</citation>
<citation valid="true">
<title>Phonological events.</title>
<date>1990</date>
<journal>Journal of Linguistics,</journal>
<volume>26</volume>
<marker>1990</marker>
<rawString>[Bird and Klein, 1990] S. Bird and E. Klein. Phonological events. Journal of Linguistics, 26, 1990.</rawString>
</citation>
<citation valid="true">
<title>An application of DATR: The TIC lexicon.</title>
<date>1990</date>
<booktitle>In Proc. ECAI-90,</booktitle>
<pages>120--125</pages>
<marker>1990</marker>
<rawString>[Cahill and Evans, 19901 Lynne J. Cahill and Roger Evans. An application of DATR: The TIC lexicon. In Proc. ECAI-90, pages 120-125, 1990.</rawString>
</citation>
<citation valid="true">
<title>The semantics of MOLUSC.</title>
<date>1990</date>
<booktitle>In ECAI-90,</booktitle>
<pages>126--131</pages>
<location>Stockholm,</location>
<marker>1990</marker>
<rawString>[Cahill and Gazdar, 1990] L. J. Cahill and G. J. M. Gazdar. The semantics of MOLUSC. In ECAI-90, pages 126-131, Stockholm, 1990.</rawString>
</citation>
<citation valid="true">
<authors>
<author>L J Cahill</author>
</authors>
<title>Syllable-based morphology.</title>
<date>1990</date>
<booktitle>In COLING 90,</booktitle>
<volume>3</volume>
<pages>48--53</pages>
<location>Helsinki,</location>
<contexts>
<context position="1852" citStr="Cahill, 1990" startWordPosition="287" endWordPosition="288">shown its applicability to this area, both for its handling of inheritance by default, and for its ability to define hierarchical structures. For example, [Gibbon, 1990] describes how Kikuyu tone displacement and Arabic non-concatenative morphology can be defined in &amp;quot;Thanks are due to Roger Evans and Dafydd Gibbon for comments on previous drafts of this paper. DATR and [Reinhard, 1990] describes a hierarchical approach to German umlaut. In this paper we assume a knowledge of DATR and refer the reader to the introductions in [Cahill and Evans, 1990] and [Evans and Gazdar, 1990]. MOLUSC 1990a],[Cahill, 1990b],[Cahill and Gazdar, 1990]), is a formal language for defining morphological alternations as mappings between sequences of tree-structured syllables. It is based on the theory that (many) morphological alternations are phonologically based, and can best be described as operating on hierarchical structures, such as the syllable. However, there are fundamentally linear aspects of morphological alternations, which require reference to concepts such as &amp;quot;initial&amp;quot;, &amp;quot;final&amp;quot; and &amp;quot;penultimate&amp;quot;. An account of English verbal morphology was discussed in [Cahill, 1990b] which was expressed in a combined </context>
<context position="4116" citStr="Cahill, 1990" startWordPosition="623" endWordPosition="624"> to model both the precise structures used by MOLUSC and more generally useful phonological structures. We shall then consider how we might define the alternations. Finally, we shall discuss the advantages of this approach over previous descriptions of such phenomena as well as over the original MOLUSC language. 2 Phonological Structures In many previous approaches to morphology, particularly in the English-dominated NLP community, it was assumed that morphology consisted fundamentally of &amp;quot;sticking together&amp;quot; morphemes, and making the necessary adjustments to allow for spelling peculiarities. [Cahill, 1990b] suggested that this was too narrow a view, even for the rather impoverished inflection displayed by English. That there are several subclasses of English verbs which inflect by means other than affixation (e.g. &amp;quot;bring&amp;quot;-&amp;quot;brought&amp;quot; , &amp;quot;sit&amp;quot;-&amp;quot;sat&amp;quot;) would seem to be a strong argument in itself, but looking at other languages such as the Semitic languages shows that there is an enormous body of interesting morphological phenomena which needs to be addressed. [Cahill, 1990b] showed that a view of morphological alternations as mappings between tree-structured syllables permitted a natural and succin</context>
<context position="28890" citStr="Cahill, 1990" startWordPosition="4992" endWordPosition="4993">lly determined, but not strictly phonological, alternations. In MOLUSC, these could be defined by means of functions such as the following: [(peak,-1)/ii/ = /e/] [(coda,-1,-1)/v/ If/] [(coda,-1,-1)[+ voice] [- voice]] 92 There are two aspects to these alternations. On the one hand, defining the alternation between, say, a peak of /ii/ with a peak of /e/ is extremely straightforward, simply requiring path extensions to the &amp;quot;&lt;peak&gt;&amp;quot;7 definitions for past and present. Thus, the following would define the alternation: &lt;peak pres&gt; == ii &lt;peak past&gt; == e However, in the account of English verbs in [Cahill, 1990b], such verbs were grouped together with a large number of other verbs which did not exhibit this precise alternation, with the peak alternation being dependent on the original peak. Thus, the past tense peak is /e/ if the present tense peak is /ii/ and the same as the present tense peak otherwise. 3.1 Defining context-dependent alternations We can define this type of context-dependent alternation in our framework by evaluating the present tense value for the peak and using that as an argument in a path for defining the past tense peak. The code for this is: &lt;peak past&gt; == &lt;peak_change &amp;quot;&lt;peak</context>
<context position="35906" citStr="Cahill, 1990" startWordPosition="6223" endWordPosition="6224"> of definitions of alternations that MOLUSC used to handle the phonologically related phenomena, but we can leave the affixation and compounding to be treated as simple concatenation in DATR lists. The account proposed here also has the advantage, mentioned above, that certain types of alternation and structural definition are much harder to define than in MQLUSC. MOLUSC was noticably overpowered, permitting the definition of alternations which affected both the first syllable and penultimate coda, dependent on the value of the third onset, for example, a combination unlikely in the extreme. [Cahill, 1990b] discussed some possible ways to restrict the language to have context dependencies adjacent to the alternation being defined and to only permit reference to the initial, second, final and penultimate syllables, for example. Such restrictions are not enforced by the account discussed above, but the kind of alternations which we would want to avoid are notably more difficult to define, which is in contrast to MOLUSC. The present account has much in common with that in [Gibbon, 1990], which provided accounts of Kikuyu tone displacement and Arabic bin yan morphology. The account Gibbon gave of </context>
</contexts>
<marker>Cahill, 1990</marker>
<rawString>[Cahill, 1990a] L. J. Cahill. Syllable-based morphology. In COLING 90, volume 3, pages 48-53, Helsinki, 1990.</rawString>
</citation>
<citation valid="true">
<authors>
<author>L J Cahill</author>
</authors>
<title>Syllable-based morphology for natural language processing (DPhil Dissertation).</title>
<date>1990</date>
<tech>Technical Report Cognitive Science Research Report 181,</tech>
<institution>Cognitive and Computing Sciences, University of Sussex,</institution>
<contexts>
<context position="1852" citStr="Cahill, 1990" startWordPosition="287" endWordPosition="288">shown its applicability to this area, both for its handling of inheritance by default, and for its ability to define hierarchical structures. For example, [Gibbon, 1990] describes how Kikuyu tone displacement and Arabic non-concatenative morphology can be defined in &amp;quot;Thanks are due to Roger Evans and Dafydd Gibbon for comments on previous drafts of this paper. DATR and [Reinhard, 1990] describes a hierarchical approach to German umlaut. In this paper we assume a knowledge of DATR and refer the reader to the introductions in [Cahill and Evans, 1990] and [Evans and Gazdar, 1990]. MOLUSC 1990a],[Cahill, 1990b],[Cahill and Gazdar, 1990]), is a formal language for defining morphological alternations as mappings between sequences of tree-structured syllables. It is based on the theory that (many) morphological alternations are phonologically based, and can best be described as operating on hierarchical structures, such as the syllable. However, there are fundamentally linear aspects of morphological alternations, which require reference to concepts such as &amp;quot;initial&amp;quot;, &amp;quot;final&amp;quot; and &amp;quot;penultimate&amp;quot;. An account of English verbal morphology was discussed in [Cahill, 1990b] which was expressed in a combined </context>
<context position="4116" citStr="Cahill, 1990" startWordPosition="623" endWordPosition="624"> to model both the precise structures used by MOLUSC and more generally useful phonological structures. We shall then consider how we might define the alternations. Finally, we shall discuss the advantages of this approach over previous descriptions of such phenomena as well as over the original MOLUSC language. 2 Phonological Structures In many previous approaches to morphology, particularly in the English-dominated NLP community, it was assumed that morphology consisted fundamentally of &amp;quot;sticking together&amp;quot; morphemes, and making the necessary adjustments to allow for spelling peculiarities. [Cahill, 1990b] suggested that this was too narrow a view, even for the rather impoverished inflection displayed by English. That there are several subclasses of English verbs which inflect by means other than affixation (e.g. &amp;quot;bring&amp;quot;-&amp;quot;brought&amp;quot; , &amp;quot;sit&amp;quot;-&amp;quot;sat&amp;quot;) would seem to be a strong argument in itself, but looking at other languages such as the Semitic languages shows that there is an enormous body of interesting morphological phenomena which needs to be addressed. [Cahill, 1990b] showed that a view of morphological alternations as mappings between tree-structured syllables permitted a natural and succin</context>
<context position="28890" citStr="Cahill, 1990" startWordPosition="4992" endWordPosition="4993">lly determined, but not strictly phonological, alternations. In MOLUSC, these could be defined by means of functions such as the following: [(peak,-1)/ii/ = /e/] [(coda,-1,-1)/v/ If/] [(coda,-1,-1)[+ voice] [- voice]] 92 There are two aspects to these alternations. On the one hand, defining the alternation between, say, a peak of /ii/ with a peak of /e/ is extremely straightforward, simply requiring path extensions to the &amp;quot;&lt;peak&gt;&amp;quot;7 definitions for past and present. Thus, the following would define the alternation: &lt;peak pres&gt; == ii &lt;peak past&gt; == e However, in the account of English verbs in [Cahill, 1990b], such verbs were grouped together with a large number of other verbs which did not exhibit this precise alternation, with the peak alternation being dependent on the original peak. Thus, the past tense peak is /e/ if the present tense peak is /ii/ and the same as the present tense peak otherwise. 3.1 Defining context-dependent alternations We can define this type of context-dependent alternation in our framework by evaluating the present tense value for the peak and using that as an argument in a path for defining the past tense peak. The code for this is: &lt;peak past&gt; == &lt;peak_change &amp;quot;&lt;peak</context>
<context position="35906" citStr="Cahill, 1990" startWordPosition="6223" endWordPosition="6224"> of definitions of alternations that MOLUSC used to handle the phonologically related phenomena, but we can leave the affixation and compounding to be treated as simple concatenation in DATR lists. The account proposed here also has the advantage, mentioned above, that certain types of alternation and structural definition are much harder to define than in MQLUSC. MOLUSC was noticably overpowered, permitting the definition of alternations which affected both the first syllable and penultimate coda, dependent on the value of the third onset, for example, a combination unlikely in the extreme. [Cahill, 1990b] discussed some possible ways to restrict the language to have context dependencies adjacent to the alternation being defined and to only permit reference to the initial, second, final and penultimate syllables, for example. Such restrictions are not enforced by the account discussed above, but the kind of alternations which we would want to avoid are notably more difficult to define, which is in contrast to MOLUSC. The present account has much in common with that in [Gibbon, 1990], which provided accounts of Kikuyu tone displacement and Arabic bin yan morphology. The account Gibbon gave of </context>
</contexts>
<marker>Cahill, 1990</marker>
<rawString>[Cahill, 1990b] L. J. Cahill. Syllable-based morphology for natural language processing (DPhil Dissertation). Technical Report Cognitive Science Research Report 181, Cognitive and Computing Sciences, University of Sussex, 1990.</rawString>
</citation>
<citation valid="true">
<title>Synthesis by rule without segments or rewrite rules.</title>
<date>1992</date>
<booktitle>In C.Benoit</booktitle>
<editor>and G.Bailly, editors, Talking Machines.</editor>
<publisher>Elsevier,</publisher>
<marker>1992</marker>
<rawString>[Coleman, 1992] J. S. Coleman. Synthesis by rule without segments or rewrite rules. In C.Benoit and G.Bailly, editors, Talking Machines. Elsevier, 1992.</rawString>
</citation>
<citation valid="true">
<title>The DATR papers. Cognitive science research report 139, Cognitive and Computing Sciences,</title>
<date>1990</date>
<institution>University of Sussex,</institution>
<marker>1990</marker>
<rawString>[Evans and Gazdar, 1990] R. Evans and G. Gazdar. The DATR papers. Cognitive science research report 139, Cognitive and Computing Sciences, University of Sussex, 1990.</rawString>
</citation>
<citation valid="true">
<title>Dafydd Gibbon. Prosodic association by template inheritance.</title>
<date>1990</date>
<booktitle>Proceedings of the Workshop on Inheritance in Natural Language Processing,</booktitle>
<pages>65--81</pages>
<editor>In Walter Dademans and Gerald Gazdar, editors,</editor>
<institution>Institute for Language Technology,</institution>
<location>Tilburg,</location>
<marker>1990</marker>
<rawString>[Gibbon, 1990] Dafydd Gibbon. Prosodic association by template inheritance. In Walter Dademans and Gerald Gazdar, editors, Proceedings of the Workshop on Inheritance in Natural Language Processing, pages 65-81. Institute for Language Technology, Tilburg, 1990.</rawString>
</citation>
<citation valid="true">
<title>Verarbeitungsprobleme nichtlinearer Morphologien: Umlaut-beschreibung in einem hierarchischen Lexicon. In</title>
<date>1990</date>
<marker>1990</marker>
<rawString>[Reinhard, 1990] S. Reinhard. Verarbeitungsprobleme nichtlinearer Morphologien: Umlaut-beschreibung in einem hierarchischen Lexicon. In B. Rieger and B. Schaeder,</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>