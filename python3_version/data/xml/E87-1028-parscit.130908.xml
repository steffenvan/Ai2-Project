<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<note confidence="0.977917">
DANISH FIELD GRAMMAR IN TYPED PROLOG
</note>
<author confidence="0.885583">
Henrik Rue
</author>
<affiliation confidence="0.890346">
UNI-C, Danish Computing Center for Research and Education
</affiliation>
<address confidence="0.345671">
Vermundsgade 5, DK 2100 0, Copenhagen, Denmark
</address>
<sectionHeader confidence="0.803099" genericHeader="abstract">
ABSTRACT
</sectionHeader>
<bodyText confidence="0.999227166666667">
This paper describes a field grammar for
Danish and its implementations in a Prolog
version with predeclared types. In compa-
rison to the ususal S -&gt; NP VP schema,
this kind of grammar, where the first rule
is S -&gt; CNF FF NF CF enhances analysis
effeciency because the fields specify
constituents and syntactic function at the
same time. The field grammar tradition is
outlinedand an overview of the major rules I
of the Prolog program, which implements
the grammar, is given.
</bodyText>
<sectionHeader confidence="0.944251" genericHeader="method">
FIELD GRAMMAR
A Syntactic Strategy
</sectionHeader>
<bodyText confidence="0.970393060606061">
In terms of computational linguistics,
field grammar may be viewed as a syntactic
strategy, which offers the user the imme-
diate constituents while at the same time
giving their syntactic functions and the
functional sentence perspective, in part
at least. Field grammar furthermore faci-
litates the handling of discontinuous con-
stituents, as will be shown.
Background
The field grammar of the Danish linguist
Paul Diderichsen adequately describes con-
stituent structure in Danish, while at the
same time capturing both topicalization
and syntactic roles. Diderichsens grammar
&amp;quot;Elementmr dansk grammatik&amp;quot; (1946) was
developed from the 1940&apos;s onwards with the
intention that it should be used as a
common framework for grammar teaching in
secondary school as well as on university
level. This grammar has since served as
one cornerstone of Danish grammatical
thought.
Diderichsen&apos;s grammar is distinguished
by a high degree of formalization, and it
is one of the aims of the work presented
in this paper to see how much of the
original formalism can be implemented
directly as a Prolog program, and whether
it is necessary to make substantial chan-
ges in the definition and inventory of
fields in order to make an executable
program.
</bodyText>
<subsectionHeader confidence="0.864882">
Prolog Dialect
</subsectionHeader>
<bodyText confidence="0.9982235625">
The Prolog dialect used is the Danish
prototype of Borland&apos;s TurboProlog. This
is a typed prolog, and may be termed a
hybrid between Prolog and Pascal. When
seeing a sample grammar written in this
dialect, one is impressed by the clarity
it achieves: grammatical structures are
statically described in the declaration of
types. The dynamic part which enables one
to get at these structures are the rules
of the program. A further aim of this
work, then, is to explore whether this
clarity will prevail also in an elaborate
grammar program.
Other Purposes
Apart from the purpose implicit in the
aims we believe that field theory offers a
sound (read: economic) starting point for
a great variety of parsing purposes. As
mentioned, the theory offers a combina-
tion of constituent structure analysis
with syntactic and thematic analysis.
This will not only hold for the Scandi-
navian languages, but presumably also for
other Germanic language like English,
where one might abandon the S -&gt; NP VP in
favour of something on the lines of the
SVC SVA SV SVO etc. clause patterns of
Quirk (1972) et al.
In the work presented here, however,
there is no exploitation of the topicali-
zation facilities offered by the grammar.
</bodyText>
<sectionHeader confidence="0.938703" genericHeader="method">
A DANISH FIELD GRAMMAR
</sectionHeader>
<bodyText confidence="0.938098">
According to Diderichsen, the Danish
sentence structure has four major fields,
the connector field, the fundament field,
the nexus field and the content field.
The four types are present in main sen-
tences
</bodyText>
<page confidence="0.97864">
167
</page>
<bodyText confidence="0.988579277777778">
S -&gt; CONN FF NF CF
and three of them in subordinate ones:
SS -&gt; CONN S-NF CF
where all fields except the nexus field
(NF or S-NF) may be empty.
The CONN is the field for conjunctions.
The FF (for Fundament Field, which is
the Danish topicalization device) may
contain any complete constituent, which is
there as a result of a movement from its
field in the sentence: &apos;Moderen giver
drengen gaven&apos; vs. &apos;Gaven giver moderen
drengen&apos;, (&apos;The mother gives the boy a
gift&apos;) where the second version differes
in its thematical content only: it stres-
ses the direct object as the theme.
The NF, for Nexus Field, contains a
finite verbform, a possible subject plus
adverbials modifying the verb; the inter-
nal structure of the nexus field differs
in main and subordinate clauses.
The CF, for Content Field, contains two
possible infinite verbforms, the objects
and predicates plus adverbial and other
modifiers.
The Grammar Declaration
So far the project has implemented field
analysis of both main and subordinate
sentences. However, not all topicaliza-
tions are handled yet: in questions, the
fundament field may be empty too, but this
is not incorporated in the program, as it
remains to be seen whether an anlysis with
the finite topicalized, that is moved into
the fundament field, would be more fit for
the purpose.
</bodyText>
<subsectionHeader confidence="0.78616">
Clause structure
</subsectionHeader>
<bodyText confidence="0.996604">
The following declarations describe main
and subordinate clauses and furthermore
the internal structure of the major
fields:
</bodyText>
<equation confidence="0.958681533333333">
S = s( CONN, FUNDF, NEXUSF, CONTENTF );
nil;
s_s( CONN, NEXUSF_S, CONTENTF )
CONN .
nil;
konj( KONJ )
FUNDF = fundf n( NOMINAL ); /* No nil */
fundf—a( ADVERBIAL );
fundf—i( INF );
fundf=c( CONTENTF )
NEXUSF = nexusf( FINIT, SUBJ, NADV )
NEXUSF_S = nexusf_s( SUBJ, NADV, FINIT )
CONTENTF = nil;
contentf( INFFLD, OBJFLD,
CADVFLD )
</equation>
<bodyText confidence="0.970228793103448">
These are the major fields. They may in
turn be divided into subfields:
INFFLD . nil;
inffld( INF1, INF2 )
means that Danish has a possibility of two
auxiliaries, (the finite + one infinite),
and implicitly that if INF2 is filled,
then this will be the content verb. This
treatment is not quite adequate, actually,
but it follows Diderichsen&apos;s schema.
OBJFLD . nil;
objfld( NOMINAL, PREPG, NOMINAL )
the object field, which at the moment con-
tains a quick-and-dirty solution to the
problem that the indirect object may be
expressed by a prepositional phrase in
Danish, the solution being the incorpora-
tion of an unwarranted PREP subfield.
It should be noted in passing, that the
connector field in Diderichsen&apos;s formalism
is one of the places where the system will
not be able to hold on to the original.
This field is part of scemata not only for
sentences, but also for noun- and adver-
bial phrases, where it may contain i.a.
preposition. The system thus has to di-
stinguish between the two types of connec-
tor fields in order to avoid the genera-
tion of spurious analysis results.
</bodyText>
<sectionHeader confidence="0.680336" genericHeader="method">
Discontinuous Verbal Particles
</sectionHeader>
<bodyText confidence="0.999994066666667">
In Danish some verbs are either prefi-
gated or obligatorly constructed with a
particle, a preposition actually, which
moves to the end of the sentence with all
finite forms: &apos;oplade&apos; (&apos;charge&apos;) but &apos;han
lader batteriet op&apos;, (the charges the
battery&apos;); ilukke op&apos; (&apos;open up&apos;) but &apos;han
lukker doren op&apos; (the opens the-door up&apos;).
The same phenomenon exists in German:
&apos;Peter gab sein rauchen auf&apos;. This is one
of the places where field grammar shows
its force as a syntactic strategy, because
the phenomenon of discontinuity is handled
in a straightforward way at the first
level of analysis:
</bodyText>
<equation confidence="0.8152235">
ADVFLD . nil;
cadvfld( CADF, CADF )
with
CADF . nil;
prep( PREP );
cadf( ADVERBIAL )
</equation>
<bodyText confidence="0.9951785">
where CADF is the field for i.a. conten-
tial adverbs, but also for disjunct verbal
</bodyText>
<page confidence="0.991845">
168
</page>
<bodyText confidence="0.999559444444445">
particles. These are acommodated by split-
ting the original Diderichsen subfield for
content adverbials into two further sub-
fields, one of which will contain the
verbal particle (if any) the other the
regular content adverbials. This is suffi-
cient for the declaration of the grammar;
how our analysis handles the various
fields will be shown in a later section.
Phrasal structure
Syntagmatic structures are also divided
into fields. As the system stands it is
implemented for adverbial phrases, but not
yet for noun phrases. These are at the
moment structured in a way, that is pretty
much on the NP -&gt; Det AdjP N lines. As
regards adverbials, the structure given is
only one of several possible:
</bodyText>
<equation confidence="0.993443909090909">
NOMINAL = nil;
nominal( ART, ADJEKTIVAL, SUBKERN
PREPP, CS )
ADVERBIAL = nil;
adverbial( CONN,
DEGREEF, SITUATF, ADVKERN,
PREP?, CS )
The CS is a symbol representing subordi-
nate sentences, which have the form:
CS = nil;
cs( S, SYNT )
</equation>
<bodyText confidence="0.988271902439024">
where S is the field structure, and SYNT
the corresponding syntactical structure of
the subordinate sentence represented by
the token of the symbol type CS.
Verb phrases, on the other hand, do not
exist as such. Instead we have:
FINIT = finit( VERB, VERB, TEMPG )
INFINIT = infinit( VERB, VERB, TEMPG )
VERB = Symbol
which means that a verb, whether it be
finite or infinite, is described by a
structure, which consists of 1) the verbal
form itself as it is found in the sentence
(the first &apos;VERB&apos;), 2) a lexical unit,
(the second &apos;VERB&apos;, which will be found as
a result of the analysis of the sentence,
and which will leave the fields for infi-
nite form empty) and 3) a complex descrip-
tion, TEMPG, of tense, aspect, voice,
modality and the telic/atelic property of
the situation described by the verb. This
TEMPG is used of the sentence as a whole
also.
In this way a &apos;FINIT&apos; in a sentence will
have either an auxiliary, a finite verb-
form missing the verbal prefix or the
full, finite form of the content verb in
the first &apos;VERB&apos; slot when field analysis
is carried out. The result of the syntac-
tical analysis which follows, will be in
the second &apos;VERB&apos; slot.
Syntax
The system also comprises a syntactic
part, based on traditional school grammar:
SYNT = synt( SUBJ, VERB, NADV, SUBJPRED,
OBJ, OBJPRED, IOBJ, CADV,
TEMPG )
where NADV and CADV are the adverbial
modifiers of the nexus and the con-
tentfield respectivily. The other mnemo-
nics should be self evident.
</bodyText>
<subsectionHeader confidence="0.509448">
The Dictionary
</subsectionHeader>
<bodyText confidence="0.9998955">
As the dictionary of the system has not
been given much attention yet, and as it
works on a purely ad hoc basis, it will
not be treated in this paper.
</bodyText>
<sectionHeader confidence="0.964881" genericHeader="method">
ANALYSIS
</sectionHeader>
<bodyText confidence="0.9997155">
Analysis runs in two steps, one carrying
out the field analysis, the other handling
the syntactical interpretation of the
result of the field analysis.
</bodyText>
<subsectionHeader confidence="0.932061">
Field Analysys
</subsectionHeader>
<bodyText confidence="0.902181">
Field analysis is carried out by a call to
the following major rule:
is_s( I, 0, s( CONN, FUNDF, NEXUSF,
</bodyText>
<equation confidence="0.743113333333333">
CONTENTF ) ):-
is_forb( I, Il, CONN, FEATC ),
FEATC &lt;&gt; subord,
</equation>
<bodyText confidence="0.802211090909091">
is fundf( 11, 12, FUNDF ),
is=nexusf( 12, 13, NEXUSF ),
is_contentf( 13, 0, CONTENTF ).
which applies the following rules in order
to succeed (or fail):
is fundf( I, 0, fundf n( NOMINAL ) ):-
is_nomen( I, 0, NOMINAL ), I &lt;&gt; O.
is fundf( I, 0, fundf_a( ADVERBIAL ) ):-
— is adverbial( I, 0, ADVERBIAL, _ ),
I Z&gt; O.
is_nexusf( I, 0, nexusf( FINIT, NOMINAL,
</bodyText>
<sectionHeader confidence="0.684133" genericHeader="method">
ADVERBIAL ) ):-
</sectionHeader>
<bodyText confidence="0.986355">
- is finit( I, Il, FINIT ),
is=nomen( II, 12, NOMINAL, _, _ ),
is_adverbial( 12, 0, ADVERBIAL, _ ).
and
</bodyText>
<page confidence="0.959542">
169
</page>
<equation confidence="0.982123428571429">
is_contentf( I, 0, contentf( INFFLD,
OBJFLD, CADVFLD ) ):-
is inffld( I, I1, INFFLD ),
is=objf1d( I1, 12, OBJFLD ),
is cadvfld( 12, 0, CADVFLD ),
I 7&gt; o.
is_contentf( I, I, nil ).
</equation>
<bodyText confidence="0.971917833333333">
As a consequence of having a possible nil-
filling for a major field, the content
field, it becomes necessary to explode the
number of rules which identify and collect
compound verb forms, or in other words
what is gained in the simplicity of the
grammar is lost again by the number of
rules.
Discontinous Verbal Particles
As an example of the rules handling the
major fields, we shall take a look at the
rule, which picks out discontinous verbal
particles.
The rules which handle the adverbial sub-
field of the content field contain a spe-
cification for the particles, as they
allow for the class of prepositional ad-
verbs:
</bodyText>
<equation confidence="0.8664895625">
is_cadvfld( I, 0, cadvfld( PREPG,
C ADVERBIAL ) ):-
_
is_advprep( I, I1, PREPG ),
is c adverbial( I1, 0, C_ADVERBIAL ),
I 7&gt;— o.
is_cadvfld( I, 0, cadvfld( C ADVERBIAL,
P-1EPG ) ):-
is c adverbial( I, I1, C ADVERBIAL ),
is —aUvprep( I1, 0, PREPG— ),
noT_nom( 0 ), I &lt;&gt; O.
The prepositional adverbs are then picked
up by the rule:
is advprep( I, 0, prep( PREP ) ):-
Fronttoken( I, PREP, 0 ),
dic_prep( X ), X = PREP.
</equation>
<bodyText confidence="0.960456090909091">
which in fact is an ad hoc rule to circum-
vent the restrictions posed on the system
be the typing facility. During syntactic
analysis the disjunct particles are col-
lected with the verb by the rule
extract_disco_vpart, as will be demon-
strated in the following.
Syntactic Analysis
There is one major clause for syntactic
analysis, &apos;is_syn&apos;, which is called by the
top level anlysis clause &apos;start&apos;:
</bodyText>
<equation confidence="0.914643">
start:-
write(&amp;quot;Skriv en smtning&amp;quot;),n1,
readln( Line ),
is s( Line, &amp;quot;&amp;quot;, S ),
issyn( S, SYNT ),
nl,_ write(&amp;quot;Feltanalyse:&amp;quot;),n1,
skriv_s( S, 0 ), nl,
nl, write(&amp;quot;Syntaktisk analyse:&amp;quot;), nl,
skriv( SYNT, 0 ), nl, fail.
is_syn( S, SYNT ):-
</equation>
<table confidence="0.9002472">
extract_vg( S, VERB1, TEMPG ),
extract_disco_vpart( VERB1, S, VERB ),
extract_advg( S, NADV, CADV ),
interpret_nominals( S, VERB, SUBJ,
SUBJPRED, OBJ,
OBJPRED, IOBJ ),
collect_synt( VERB, NADV, SUBJ,
SUBJPRED, OBJ, OBJPRED,
IOBJ, CADV, TEMPG, SYNT ).
is_syn( nil, nz..1 ).
</table>
<tableCaption confidence="0.57426675">
The claim was that field grammar facili-
tates syntactic analysis, and we shall now
endeavour to support this claim by looking
at the handling of the noun phrases.
</tableCaption>
<table confidence="0.731318444444444">
The major rule is &apos;interpret_nominals&apos;,
which has the form:
interpret nominals(
s( , FUNDF, NEXUSF, CONTENTF ),
VERB, SUBJ, SUBJPRED,
OBJ, OBJPRED, IOBJ ):-
syn_nomfund( FUNDF, NEXUSF, CONTENTF,
VERB, SUBJ, SUBJPRED,
OBJ, OBJPRED, IOBJ).
</table>
<bodyText confidence="0.93910725">
For transitive verbs the following
version of a &apos;syn_nomfunde rule
generates the filler in the fundament
field as subject, and two fillers to the
object and indirect object slots; if there
is only one filler in the object subfield
this will be the object:
syn nomfund(
</bodyText>
<equation confidence="0.8588545">
Tundf n( FUNDFN I ),
nexusT( , nil, —_ ),
CONTENT F,_
VERB, subj( FUNDFN 0 ), nil,
OBJS, nil, IOBJS )7-
trans_verb( VERB, DITRANS ),
check_sentcomp( FUNDFN_I, FUNDFN_O ),
extract_obj( nil, DITRANS, CONTENTF,
</equation>
<bodyText confidence="0.972741333333333">
OBJS, IOBJS ),!.
where the interesting call is the one to
&apos;extract_obj&apos;, where the following will
match (the &apos;check_sentcomp&apos; in the follo-
wing rules should be disregarded, as it
has nothing to do with the analysis of the
arguments proper, it only activates a
syntactic analysis of a possible clausal
complement to the given nominal kernels):
</bodyText>
<page confidence="0.991263">
170
</page>
<table confidence="0.847769">
extract obj( nil, _,
contentf( , objfld( NOM_I, nil, nil ),
),
obj( NOM_O—), nil ):-
check_sentcomp( NOM_I, NOM_O ),!,
is_noprep( NOM_O ).
extract obj( nil, DITRA,
contentf( ,
13bjf1d( NOM1_I, nil, NOM2_I ),
),
obj( NOM225 ), iobj( NOM1_0 ) ):-
DITRA &lt;&gt; nil,
is noprep( NOM1 I ),
</table>
<equation confidence="0.891361444444444">
check_sentcomp( NOM1_I, NOM1_0 ),
check_sentcomp( NOM2_I, NOM2_0 ),!.
extract_obj( nil, DITRA,
contentf(
objfld( NOM1 I, prep( PREP ),
NOM2=I ),
_ ),
obj( NOM1 0 ), iobj( NOM2_0 )
DITRA —0 nil,
is_noprep( NOM1_I ),
check_tilfor( PREP ),
check_sentcomp( NOM1_I, NOM1 0 ),
check_sentcomp( NOM2_I, NOM2:0 ),!.
extract obj( nil,
_
contentf( , nil, ),
nil, nil )._ _
extract obj( nil, _, nil, nil, nil ).
</equation>
<bodyText confidence="0.98563675">
Even if simplicity is in the eye of the
beholder, we are confident that the rules
above are not very complicated.
It is evident, however, that at least
one necessary modification to the claim
must be that the two structures for &apos;The
mother gives the boy a present&apos; example:
s(fundf n(X),nexusf(finit(Y),nil,_),
conteaf(objf1d(nominal(XX)„
nominal(YY))T
s(fundf n(X),nexusf(finit(Y),subj(Z),_),
conteiTtf(objf1d(obj1(XX),_,ni1))
can only be distinguished from each other
in analysis by a call to a rule that
operates at the lexical level of the verb
and its arguments.
</bodyText>
<subsectionHeader confidence="0.569649">
Discontinouos Verbal Particles
</subsectionHeader>
<bodyText confidence="0.99935275">
In the syntactic analysis, a possible
discontinous verbal particles is disco-
vered by the rule extract_disco_vpart,
which has the form:
</bodyText>
<table confidence="0.372920636363636">
extract disco_vpart(
s( , , ,
conIentf(
cadvfld( prep( PREPIN ),
VERBOUT ):-
dic v( VERB, , „ „ „ discon, _ ),
VERB = VERBIN,
die v discon( VERB, PREP„ ),
VER IS VERBIN, PREPIN = PREP,
concat( VERB, &amp;quot; &amp;quot;, X ),
concat( X, PREP, VERBCUT ).
</table>
<sectionHeader confidence="0.388865" genericHeader="evaluation">
PERFORMANCE
</sectionHeader>
<bodyText confidence="0.998399515151515">
The system consists of 35 complex gramma-
tical objects, eg. FUNDF, NOMINAL, with a
total of 69 possible internal structu-
rings. There are 18 simple grammatical
types, eg. INF, ADV.
There are 77 predicate types for the
analysis proper, and another 36 types used
for prettyprinting the results of the
analysis.
There are 72 rules for the handling of
the field grammar analysis, and 74 rules
for the syntactic analysis.
Finally there are 70 actual rules to the
36 types of prettyprinting.
This reflects on one of the shortcomings
of the typing system: you need a separate
predicate for each object type you want to
type out. Up to a certain point one may
have one predicate type handle several
object types, but what happens is that
instead the compiler generates different
predicate types behind your back. All in
all one must say, that running on an IBM
XT you will very soon hit the upper limits
of the various tables in the compiler,
when you attempt to exploit the typing
facilities offered.
The sentence &apos;den meget gode dreng som
giver moderen gaven lukker 01 op med et
redskab&apos; (&apos;The very good boy who gives
the-mother the-gift opens beer up with a
tool&apos;) takes a total of 21.13 seconds in
field and syntactic analysis:
</bodyText>
<figure confidence="0.975670065217391">
Field analysis:
FUNDAMENTFIELD
FUNDF
• NOM dreng
DET den
ADJ gode
ADV meget
171
CONJ sow
NEXUSFIELD
FINIT
VERB giver
CONTENTFIELD
OBJ-SUBPRED FIELD
OBJ1/SP
NOM moderen
OBJ2/0P gaven
NEXUSFIELD
FINIT
VERB lukker
CONTENTFIELD
OBJ-SUBPRED FIELD
OBJ1/SP
NOM 01
CONTENT ADVERBIAL FIELD
VB-PART op
CF-ADV
PREP med
NOM redskab
DET et
SYNTACTIC ANALYSIS
SUBJ NOM dreng
DET den
ADJ gode
ADV meget
SUBJ NOM RelT&amp;quot;
VERB give
DIR-OBJ NOM gaven
DAT-OBJ NOM moderen
TEMP tempg(pres,contmp,act,
nil,imperf,atelic)
VERB oplukke
DIR-OBJ NOM 01
CF-ADV PREP med
NOM redskab
DET et
</figure>
<sectionHeader confidence="0.663668" genericHeader="conclusions">
CONCLUSIONS
</sectionHeader>
<bodyText confidence="0.99988915625">
As the project is still running, it is
too early to propose any firm conclusions.
It has been seen ,though, that a field
analysis for Danish is easily implemented
in Prolog, that for the most part short-
cuts are merely programming conveniences,
and that typed Prolog using mnemotecnic
variable names enhance readability and
thereby adaptability.
On the other hand, our experience has
shown that expanding the system is easy
but expensive in process time. When eg.
subordinate clauses were introduced to
noun phrases and adverbial phrases, this
was a very simple operation in the grammar
(it required the addition of a single
symbol) but it had severe consequenses for
execution time: roughly a 25% increase in
analysis time for the sentence &apos;den meget
gode dreng vil gerne fA givet moderen den
gode gave&apos; (&apos;The very good boy will be-
happy-to manage-to give the-mother the-
present&apos;): 1.21 seconds before, 1:60 after
the extension.
Experience has also shown that typed
Prolog is a hindrance for the writing of
rules, which handle different construc-
tors: the compiler generates separate
rules for each cnstructor, and that leaves
you with a severe problem of adequacy of
space in the rule tables, when running on
an IBM XT.
</bodyText>
<sectionHeader confidence="0.996216" genericHeader="references">
REFERENCES
</sectionHeader>
<reference confidence="0.999465">
Paul Diderichsen, Elementmr dansk gram-
matik, Copenhagen 1946
Randolph Quirk, Sidney Greenbaum, Geof-
fry Leech &amp; Jan Svartvik, A Grammar of
Contemporary English, London 1972
PC PROLOG, Tutorial and User&apos;s guide,
Prolog Development Center, Copenhagen
1985, 1986.
</reference>
<page confidence="0.997878">
172
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.000047">
<title confidence="0.998985">DANISH FIELD GRAMMAR IN TYPED PROLOG</title>
<author confidence="0.999856">Henrik Rue</author>
<affiliation confidence="0.996871">UNI-C, Danish Computing Center for Research and Education</affiliation>
<address confidence="0.997329">Vermundsgade 5, DK 2100 0, Copenhagen, Denmark</address>
<abstract confidence="0.972255133152173">This paper describes a field grammar for Danish and its implementations in a Prolog version with predeclared types. In comparison to the ususal S -&gt; NP VP schema, this kind of grammar, where the first rule S -&gt; CNF NF enhances analysis effeciency because the fields specify constituents and syntactic function at the same time. The field grammar tradition is outlinedand an overview of the major rules I of the Prolog program, which implements the grammar, is given. FIELD GRAMMAR A Syntactic Strategy In terms of computational linguistics, field grammar may be viewed as a syntactic strategy, which offers the user the immediate constituents while at the same time giving their syntactic functions and the functional sentence perspective, in part at least. Field grammar furthermore facilitates the handling of discontinuous constituents, as will be shown. Background The field grammar of the Danish linguist Paul Diderichsen adequately describes constituent structure in Danish, while at the same time capturing both topicalization and syntactic roles. Diderichsens grammar &amp;quot;Elementmr dansk grammatik&amp;quot; (1946) was developed from the 1940&apos;s onwards with the intention that it should be used as a common framework for grammar teaching in secondary school as well as on university level. This grammar has since served as one cornerstone of Danish grammatical thought. Diderichsen&apos;s grammar is distinguished by a high degree of formalization, and it is one of the aims of the work presented this paper to much of the original formalism can be implemented directly as a Prolog program, and whether it is necessary to make substantial changes in the definition and inventory of fields in order to make an executable program. Prolog Dialect The Prolog dialect used is the Danish prototype of Borland&apos;s TurboProlog. This is a typed prolog, and may be termed a hybrid between Prolog and Pascal. When seeing a sample grammar written in this dialect, one is impressed by the clarity it achieves: grammatical structures are statically described in the declaration of types. The dynamic part which enables one to get at these structures are the rules of the program. A further aim of this work, then, is to explore whether this clarity will prevail also in an elaborate grammar program. Other Purposes Apart from the purpose implicit in the aims we believe that field theory offers a sound (read: economic) starting point for a great variety of parsing purposes. As mentioned, the theory offers a combination of constituent structure analysis with syntactic and thematic analysis. This will not only hold for the Scandinavian languages, but presumably also for other Germanic language like English, where one might abandon the S -&gt; NP VP in favour of something on the lines of the SVC SVA SV SVO etc. clause patterns of Quirk (1972) et al. In the work presented here, however, there is no exploitation of the topicalization facilities offered by the grammar. A DANISH FIELD GRAMMAR According to Diderichsen, the Danish sentence structure has four major fields, the connector field, the fundament field, the nexus field and the content field. The four types are present in main sentences 167 S -&gt; CONN FF NF CF and three of them in subordinate ones: -&gt; CONN where all fields except the nexus field (NF or S-NF) may be empty. The CONN is the field for conjunctions. The FF (for Fundament Field, which is the Danish topicalization device) may contain any complete constituent, which is there as a result of a movement from its field in the sentence: &apos;Moderen giver drengen gaven&apos; vs. &apos;Gaven giver moderen drengen&apos;, (&apos;The mother gives the boy a gift&apos;) where the second version differes in its thematical content only: it stresses the direct object as the theme. The NF, for Nexus Field, contains a finite verbform, a possible subject plus adverbials modifying the verb; the internal structure of the nexus field differs in main and subordinate clauses. The CF, for Content Field, contains two possible infinite verbforms, the objects and predicates plus adverbial and other modifiers. The Grammar Declaration So far the project has implemented field analysis of both main and subordinate sentences. However, not all topicalizations are handled yet: in questions, the fundament field may be empty too, but this is not incorporated in the program, as it remains to be seen whether an anlysis with the finite topicalized, that is moved into the fundament field, would be more fit for the purpose. Clause structure The following declarations describe main and subordinate clauses and furthermore the internal structure of the major fields: S = s( CONN, FUNDF, NEXUSF, CONTENTF ); nil; s_s( CONN, NEXUSF_S, CONTENTF ) CONN . nil; konj( KONJ ) FUNDF = fundf n( NOMINAL ); /* No nil */ ADVERBIAL ); INF ); fundf=c( CONTENTF ) NEXUSF = nexusf( FINIT, SUBJ, NADV ) = nexusf_s( FINIT ) CONTENTF = nil; contentf( INFFLD, OBJFLD, CADVFLD ) These are the major fields. They may in turn be divided into subfields: INFFLD . nil; inffld( INF1, INF2 ) means that Danish has a possibility of two auxiliaries, (the finite + one infinite), and implicitly that if INF2 is filled, then this will be the content verb. This treatment is not quite adequate, actually, but it follows Diderichsen&apos;s schema. OBJFLD . nil; objfld( NOMINAL, PREPG, NOMINAL ) the object field, which at the moment contains a quick-and-dirty solution to the problem that the indirect object may be expressed by a prepositional phrase in Danish, the solution being the incorporation of an unwarranted PREP subfield. It should be noted in passing, that the connector field in Diderichsen&apos;s formalism is one of the places where the system will not be able to hold on to the original. This field is part of scemata not only for sentences, but also for nounand adverbial phrases, where it may contain i.a. preposition. The system thus has to distinguish between the two types of connector fields in order to avoid the generation of spurious analysis results. Discontinuous Verbal Particles In Danish some verbs are either prefigated or obligatorly constructed with a particle, a preposition actually, which moves to the end of the sentence with all finite forms: &apos;oplade&apos; (&apos;charge&apos;) but &apos;han lader batteriet op&apos;, (the charges the battery&apos;); ilukke op&apos; (&apos;open up&apos;) but &apos;han lukker doren op&apos; (the opens the-door up&apos;). The same phenomenon exists in German: &apos;Peter gab sein rauchen auf&apos;. This is one of the places where field grammar shows its force as a syntactic strategy, because the phenomenon of discontinuity is handled in a straightforward way at the first level of analysis: ADVFLD . nil; cadvfld( CADF, CADF ) with CADF . nil; prep( PREP ); cadf( ADVERBIAL ) where CADF is the field for i.a. contential adverbs, but also for disjunct verbal 168 particles. These are acommodated by splitting the original Diderichsen subfield for content adverbials into two further subfields, one of which will contain the verbal particle (if any) the other the regular content adverbials. This is sufficient for the declaration of the grammar; how our analysis handles the various fields will be shown in a later section. Phrasal structure Syntagmatic structures are also divided into fields. As the system stands it is implemented for adverbial phrases, but not yet for noun phrases. These are at the moment structured in a way, that is pretty much on the NP -&gt; Det AdjP N lines. As regards adverbials, the structure given is only one of several possible: NOMINAL = nil; nominal( ART, ADJEKTIVAL, SUBKERN PREPP, CS ) ADVERBIAL = nil; adverbial( CONN, DEGREEF, SITUATF, ADVKERN, PREP?, CS ) The CS is a symbol representing subordinate sentences, which have the form: CS = nil; cs( S, SYNT ) the field structure, and SYNT the corresponding syntactical structure of the subordinate sentence represented by the token of the symbol type CS. Verb phrases, on the other hand, do not exist as such. Instead we have: FINIT = finit( VERB, VERB, TEMPG ) INFINIT = infinit( VERB, VERB, TEMPG ) VERB = Symbol which means that a verb, whether it be finite or infinite, is described by a structure, which consists of 1) the verbal form itself as it is found in the sentence (the first &apos;VERB&apos;), 2) a lexical unit, (the second &apos;VERB&apos;, which will be found as a result of the analysis of the sentence, and which will leave the fields for infinite form empty) and 3) a complex description, TEMPG, of tense, aspect, voice, modality and the telic/atelic property of the situation described by the verb. This TEMPG is used of the sentence as a whole also. In this way a &apos;FINIT&apos; in a sentence will have either an auxiliary, a finite verbform missing the verbal prefix or the full, finite form of the content verb in the first &apos;VERB&apos; slot when field analysis is carried out. The result of the syntactical analysis which follows, will be in the second &apos;VERB&apos; slot. Syntax The system also comprises a syntactic part, based on traditional school grammar: SYNT = synt( SUBJ, VERB, NADV, SUBJPRED, OBJ, OBJPRED, IOBJ, CADV, TEMPG ) where NADV and CADV are the adverbial modifiers of the nexus and the contentfield respectivily. The other mnemonics should be self evident. The Dictionary As the dictionary of the system has not been given much attention yet, and as it works on a purely ad hoc basis, it will not be treated in this paper. ANALYSIS Analysis runs in two steps, one carrying out the field analysis, the other handling the syntactical interpretation of the result of the field analysis. Field Analysys Field analysis is carried out by a call to the following major rule: I, 0, FUNDF, NEXUSF, CONTENTF ) ):is_forb( I, Il, CONN, FEATC ), FEATC &lt;&gt; subord, is fundf( 11, 12, FUNDF ), is=nexusf( 12, 13, NEXUSF ), is_contentf( 13, 0, CONTENTF ). which applies the following rules in order to succeed (or fail): is fundf( I, 0, fundf n( NOMINAL ) ):is_nomen( I, 0, NOMINAL ), I &lt;&gt; O. is fundf( I, 0, fundf_a( ADVERBIAL ) ):- — is adverbial( I, 0, ADVERBIAL, _ ), I Z&gt; O. is_nexusf( I, 0, nexusf( FINIT, NOMINAL, ) ):- is finit( I, Il, FINIT ), is=nomen( II, 12, NOMINAL, _, _ ), is_adverbial( 12, 0, ADVERBIAL, _ ). and 169 is_contentf( I, 0, contentf( INFFLD, OBJFLD, CADVFLD ) ):is inffld( I, I1, INFFLD ), is=objf1d( I1, 12, OBJFLD ), is cadvfld( 12, 0, CADVFLD ), o. is_contentf( I, I, nil ). As a consequence of having a possible nilfilling for a major field, the content field, it becomes necessary to explode the number of rules which identify and collect compound verb forms, or in other words what is gained in the simplicity of the grammar is lost again by the number of rules. Discontinous Verbal Particles As an example of the rules handling the major fields, we shall take a look at the rule, which picks out discontinous verbal particles. The rules which handle the adverbial subfield of the content field contain a specification for the particles, as they allow for the class of prepositional adverbs: is_cadvfld( I, 0, cadvfld( PREPG, C ADVERBIAL ) ):- _ is_advprep( I, I1, PREPG ), is c adverbial( I1, 0, C_ADVERBIAL ), o. is_cadvfld( I, 0, cadvfld( C ADVERBIAL, ) ):is c adverbial( I, I1, C ADVERBIAL ), I1, 0, ), noT_nom( 0 ), I &lt;&gt; O. The prepositional adverbs are then picked up by the rule: is advprep( I, 0, prep( PREP ) ):- Fronttoken( I, PREP, 0 ), dic_prep( X ), X = PREP. which in fact is an ad hoc rule to circumvent the restrictions posed on the system be the typing facility. During syntactic analysis the disjunct particles are collected with the verb by the rule extract_disco_vpart, as will be demonstrated in the following. Syntactic Analysis There is one major clause for syntactic analysis, &apos;is_syn&apos;, which is called by the top level anlysis clause &apos;start&apos;: start:write(&amp;quot;Skriv en smtning&amp;quot;),n1, readln( Line ), is s( Line, &amp;quot;&amp;quot;, S ), issyn( S, SYNT ), nl,_ write(&amp;quot;Feltanalyse:&amp;quot;),n1, skriv_s( S, 0 ), nl, nl, write(&amp;quot;Syntaktisk analyse:&amp;quot;), nl, skriv( SYNT, 0 ), nl, fail. is_syn( S, SYNT ):extract_vg( S, VERB1, TEMPG ), extract_disco_vpart( VERB1, S, VERB ), extract_advg( S, NADV, CADV ),</abstract>
<keyword confidence="0.560084166666667">SUBJ, SUBJPRED, OBJ, OBJPRED, IOBJ ), collect_synt( VERB, NADV, SUBJ, SUBJPRED, OBJ, OBJPRED, IOBJ, CADV, TEMPG, SYNT ).</keyword>
<abstract confidence="0.944098777777778">is_syn( nil, nz..1 ). The claim was that field grammar facilitates syntactic analysis, and we shall now endeavour to support this claim by looking at the handling of the noun phrases. The major rule is &apos;interpret_nominals&apos;, which has the form: interpret nominals( s( , FUNDF, NEXUSF, CONTENTF ),</abstract>
<keyword confidence="0.8115368">VERB, SUBJ, SUBJPRED, OBJ, OBJPRED, IOBJ ):syn_nomfund( FUNDF, NEXUSF, CONTENTF, VERB, SUBJ, SUBJPRED, OBJ, OBJPRED, IOBJ).</keyword>
<abstract confidence="0.991637756218905">For transitive verbs the following version of a &apos;syn_nomfunde rule generates the filler in the fundament field as subject, and two fillers to the object and indirect object slots; if there is only one filler in the object subfield this will be the object: syn nomfund( Tundf n( FUNDFN I ), nexusT( , nil, —_ ), CONTENT F,_ VERB, subj( FUNDFN 0 ), nil, OBJS, nil, IOBJS )7trans_verb( VERB, DITRANS ), check_sentcomp( FUNDFN_I, FUNDFN_O ), extract_obj( nil, DITRANS, CONTENTF, OBJS, IOBJS ),!. where the interesting call is the one to &apos;extract_obj&apos;, where the following will match (the &apos;check_sentcomp&apos; in the following rules should be disregarded, as it has nothing to do with the analysis of the arguments proper, it only activates a syntactic analysis of a possible clausal complement to the given nominal kernels): 170 extract obj( nil, _, contentf( , objfld( NOM_I, nil, nil ), ), nil ):check_sentcomp( NOM_I, NOM_O ),!, is_noprep( NOM_O ). extract obj( nil, DITRA, contentf( , 13bjf1d( NOM1_I, nil, NOM2_I ), ), NOM225 ), iobj( NOM1_0 ) ):- DITRA &lt;&gt; nil, is noprep( NOM1 I ), check_sentcomp( NOM1_I, NOM1_0 ), check_sentcomp( NOM2_I, NOM2_0 ),!. extract_obj( nil, DITRA, contentf( objfld( NOM1 I, prep( PREP ), NOM2=I ), _ ), obj( NOM1 0 ), iobj( NOM2_0 ) nil, is_noprep( NOM1_I ), check_tilfor( PREP ), check_sentcomp( NOM1_I, NOM1 0 ), check_sentcomp( NOM2_I, NOM2:0 ),!. extract obj( nil, _ contentf( , nil, ), nil, nil )._ _ extract obj( nil, _, nil, nil, nil ). Even if simplicity is in the eye of the beholder, we are confident that the rules above are not very complicated. It is evident, however, that at least one necessary modification to the claim must be that the two structures for &apos;The mother gives the boy a present&apos; example: s(fundf n(X),nexusf(finit(Y),nil,_), conteaf(objf1d(nominal(XX)„ nominal(YY))T s(fundf n(X),nexusf(finit(Y),subj(Z),_), conteiTtf(objf1d(obj1(XX),_,ni1)) can only be distinguished from each other in analysis by a call to a rule that operates at the lexical level of the verb and its arguments. Discontinouos Verbal Particles In the syntactic analysis, a possible discontinous verbal particles is discovered by the rule extract_disco_vpart, which has the form: extract disco_vpart( s( , , , conIentf( cadvfld( prep( PREPIN ), VERBOUT ):v( VERB, , „„ „discon, _ ), VERB = VERBIN, die v discon( VERB, PREP„ ), VER IS VERBIN, PREPIN = PREP, concat( VERB, &amp;quot; &amp;quot;, X ), concat( X, PREP, VERBCUT ). PERFORMANCE system consists 35 complex grammatical objects, eg. FUNDF, NOMINAL, with a total of 69 possible internal structurings. There are 18 simple grammatical types, eg. INF, ADV. There are 77 predicate types for the analysis proper, and another 36 types used for prettyprinting the results of the analysis. There are 72 rules for the handling of the field grammar analysis, and 74 rules for the syntactic analysis. Finally there are 70 actual rules to the 36 types of prettyprinting. This reflects on one of the shortcomings of the typing system: you need a separate predicate for each object type you want to type out. Up to a certain point one may have one predicate type handle several object types, but what happens is that instead the compiler generates different predicate types behind your back. All in all one must say, that running on an IBM XT you will very soon hit the upper limits of the various tables in the compiler, when you attempt to exploit the typing facilities offered. The sentence &apos;den meget gode dreng som moderen gaven lukker med et redskab&apos; (&apos;The very good boy who gives the-mother the-gift opens beer up with a tool&apos;) takes a total of 21.13 seconds in field and syntactic analysis: Field analysis: FUNDAMENTFIELD FUNDF • NOM dreng DET den ADJ gode ADV meget 171 CONJ sow NEXUSFIELD FINIT VERB giver CONTENTFIELD OBJ-SUBPRED FIELD OBJ1/SP moderen OBJ2/0P gaven NEXUSFIELD FINIT VERB lukker CONTENTFIELD OBJ-SUBPRED FIELD OBJ1/SP NOM 01 CONTENT ADVERBIAL FIELD VB-PART op CF-ADV PREP med NOM redskab DET et SYNTACTIC ANALYSIS SUBJ NOM dreng DET den ADJ gode ADV meget SUBJ NOM RelT&amp;quot; VERB give DAT-OBJ NOM moderen TEMP tempg(pres,contmp,act, nil,imperf,atelic) VERB oplukke DIR-OBJ NOM 01 CF-ADV PREP med NOM redskab DET et CONCLUSIONS As the project is still running, it is too early to propose any firm conclusions. It has been seen ,though, that a field analysis for Danish is easily implemented in Prolog, that for the most part shortcuts are merely programming conveniences, and that typed Prolog using mnemotecnic variable names enhance readability and thereby adaptability. On the other hand, our experience has shown that expanding the system is easy but expensive in process time. When eg. subordinate clauses were introduced to noun phrases and adverbial phrases, this was a very simple operation in the grammar (it required the addition of a single symbol) but it had severe consequenses for execution time: roughly a 25% increase in analysis time for the sentence &apos;den meget gode dreng vil gerne fA givet moderen den gode gave&apos; (&apos;The very good boy will behappy-to manage-to give the-mother thepresent&apos;): 1.21 seconds before, 1:60 after the extension. Experience has also shown that typed Prolog is a hindrance for the writing of rules, which handle different constructors: the compiler generates separate rules for each cnstructor, and that leaves you with a severe problem of adequacy of space in the rule tables, when running on an IBM XT.</abstract>
<title confidence="0.613385">REFERENCES</title>
<author confidence="0.824684">Paul Diderichsen</author>
<author confidence="0.824684">Elementmr dansk gram-</author>
<note confidence="0.7391735">matik, Copenhagen 1946 Randolph Quirk, Sidney Greenbaum, Geoffry Leech &amp; Jan Svartvik, A Grammar of Contemporary English, London 1972 PC PROLOG, Tutorial and User&apos;s guide, Prolog Development Center, Copenhagen 1985, 1986. 172</note>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Paul Diderichsen</author>
</authors>
<title>Elementmr dansk grammatik,</title>
<date>1946</date>
<location>Copenhagen</location>
<marker>Diderichsen, 1946</marker>
<rawString>Paul Diderichsen, Elementmr dansk grammatik, Copenhagen 1946</rawString>
</citation>
<citation valid="true">
<authors>
<author>Randolph Quirk</author>
<author>Sidney Greenbaum</author>
<author>Geoffry Leech</author>
<author>Jan Svartvik</author>
</authors>
<title>A Grammar of Contemporary English,</title>
<date>1972</date>
<location>London</location>
<marker>Quirk, Greenbaum, Leech, Svartvik, 1972</marker>
<rawString>Randolph Quirk, Sidney Greenbaum, Geoffry Leech &amp; Jan Svartvik, A Grammar of Contemporary English, London 1972</rawString>
</citation>
<citation valid="true">
<authors>
<author>PC PROLOG</author>
</authors>
<title>Tutorial and User&apos;s guide, Prolog Development Center,</title>
<date>1985</date>
<location>Copenhagen</location>
<marker>PROLOG, 1985</marker>
<rawString>PC PROLOG, Tutorial and User&apos;s guide, Prolog Development Center, Copenhagen 1985, 1986.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>