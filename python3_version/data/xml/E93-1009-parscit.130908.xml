<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<title confidence="0.974114">
A Strategy for Dynamic Interpretation: a Fragment and an
Implementation
</title>
<author confidence="0.988938">
Olivier Bouchez1&apos;2, Jan van Eijck2,3 and Olivier Istace1,2
</author>
<email confidence="0.896888">
EMAIL: obo@info.fundp.ac.be, jve@cwi.nl, ois@info.fundp.ac.be
</email>
<bodyText confidence="0.601045333333333">
lInstitut d&apos; Informatique, FUNDP, 61 Rue de Bruxelles, 5000 Namur, Belgium,
2CWI, P.O. Box 4079, 1009 AB Amsterdam, The Netherlands
30TS, Trans 10, 3512 JK Utrecht, The Netherlands
</bodyText>
<sectionHeader confidence="0.9914595" genericHeader="abstract">
1 The Idea of Dynamic
Interpretation
</sectionHeader>
<bodyText confidence="0.993401970588235">
Recent developments in Natural Language semantics
have witnessed a shift away from static represen-
tation languages towards representation languages
with a dynamic flavour. Such representation lan-
guages can be viewed as definitions of very simple
imperative programming languages.
To see how the imperative style comes in, consider
the treatment of indefinite descriptions (or: existen-
tial phrases). Existential quantifiers are viewed dy-
namically as random assignment statements followed
by tests. The translation of the natural language
phrase &apos;a man&apos; becomes something like:
x := ?; man(x)
The first part of this statement can be viewed as a
random assignment to register x, the second part as a
test on the value of x. This sequence of instructions is
performed against the background of a database, i.e.,
a model of first order logic. The sequence succeeds if
the database contains (representations of) men, and
it can succeed in as many ways as there are men
available in the database.
The motivating examples for the shift from static
to dynamic representation have to do with pronoun
binding. The translation of phrases like &apos;a man&apos; in
terms of assignments of values to registers makes
it possible to treat binding of pronouns across sen-
tence boundaries (the next sentence can start with
&apos;He&apos; to pick up the reference to &apos;a man&apos;). The nice
thing about the treatment in terms of assignment is
that the scope of the existential quantification is not
closed off at the end of a sentence, as used to be the
case for NL systems that employ static representa-
tion (in terms of the existential quantifiers of predi-
cate logic, with their irritating closing brackets).
</bodyText>
<sectionHeader confidence="0.667328" genericHeader="introduction">
Abstract
</sectionHeader>
<bodyText confidence="0.99994506060606">
The strategy for natural language interpre-
tation presented in this paper implements
the dynamics of context change by translat-
ing natural language texts into a meaning
representation language consisting of (de-
scriptions of) programs, in the spirit of dy-
namic predicate logic (DPL) [5]. The dif-
ference with DPL is that the usual DPL
semantics is replaced by an error state se-
mantics [2]. This allows for the treatment
of unbound anaphors, as in DPL, but also
of presuppositions and presupposition pro-
jection.
The use of this dynamic interpretation
strategy is demonstrated in an implemen-
tation of a small fragment of natural lan-
guage which handles unbound pronoun an-
tecedent links, where it is assumed that the
intended links are indicated in the input
string, and uniqueness presuppositions of
definite descriptions. The implementation
consists of a syntax module which outputs
parse trees, a semantic module mapping
parse trees to DPL representations, a repre-
sentation processor which determines truth
conditions, falsity conditions and presuppo-
sition failure conditions, and an evaluator of
these conditions in a database model.
The implementation uses the logic pro-
gramming language Godel [6], an exper-
imental successor of Prolog, with similar
functionality and expressiveness, but with
an improved declarative semantics.
</bodyText>
<page confidence="0.99858">
61
</page>
<bodyText confidence="0.988104222222222">
Recently, it has become clear that dynamic repre-
sentation has some other interesting features:
• It becomes possible to give an account of pre-
supposition failure phenomena in terms of the
definition of an error state semantics for the dy-
namic representation language [3; 2]. Presuppo-
sition failure occurs for example if one tries to
interpret &amp;quot;John&apos;s wife is unhappy&amp;quot; in a situation
where John is not married.
</bodyText>
<listItem confidence="0.958490666666667">
• A more natural treatment of tense becomes pos-
sible. A sequence of sentences in the past tense
like &amp;quot;A man walked in. He sat down. He or-
</listItem>
<bodyText confidence="0.962543206896552">
dered a drink&amp;quot; etc, is represented using subse-
quent assignments of values (time intervals) to
a dedicated time register t [10].
The dynamic representation language can be anal-
ysed with tools that were originally designed
for analysing imperative programming languages,
namely the tools for precondition reasoning from
Hoare logic or dynamic logic [11]. Precondition rea-
soning for dynamic predicate logic with standard se-
mantics was introduced in [4]. Precondition reason-
ing gives the truth conditions of DPL representations
in the form of formulas of first order logic (FOL).
When applied to the error state semantics of DPL,
precondition reasoning can also be used to find the
presupposition failure conditions of DPL representa-
tions as FOL formulas.
We provide an integrated treatment of syntax and
semantics of a small fragment of natural language
and test this by implementing it. The syntax of our
toy grammar is a version of categorial grammar with
feature unification. The semantics uses DPL rep-
resentations, with an error state semantics which is
reflected in the rules for precondition reasoning im-
plemented in the precondition module. This module
generates predicate logical formulas expressing the
weakest preconditions of success, failure or error of
the DPL representations.
In detail, our interpretation strategy consists of
the following steps:
</bodyText>
<listItem confidence="0.987564222222222">
1. Parsing a sentence or text and building a repre-
sentation tree of its structure.
2. Translating the parse tree into a DPL program.
3. Using precondition reasoning to compute pre-
conditions as formulas of FOL.
4. Simplifying the preconditions using a simplifier
for FOL formulas.
5. Evaluating the resulting formulas in a database
model.
</listItem>
<bodyText confidence="0.999857">
The current implementation produces for an input
text within the grammar fragment: a LaTeX form re-
port containing the sentence, the parse tree, the DPL
translation, the precondition of success, the precon-
dition of failure and the precondition of error, all in
simplified form, and the result of evaluation in the
database.
</bodyText>
<sectionHeader confidence="0.976095" genericHeader="method">
2 Dynamic Predicate Logic
</sectionHeader>
<subsectionHeader confidence="0.924166">
2.1 Informal discussion
</subsectionHeader>
<bodyText confidence="0.999718142857143">
DPL meaning representations for natural language
sentences can be viewed as procedures or programs
with a relational semantics. The programs that rep-
resent the meanings are interpreted as relations be-
tween input states and output states. A state is a
mapping from variables to values in a model (in our
simple set-up all variables are of the same type). The
representation for an example sentence such as &amp;quot;John
saw a man&amp;quot; is a program which associates John with
a variable x, a man with a variable y, and first checks
whether the value of x equals John, next puts a value
in y which satisfies the predicate of being a man, and
finally checks whether the values of x and y are such
that the first saw the second.
Thus, the representation of &amp;quot;John saw a man&amp;quot;
is a program which relates input states where a is
mapped to John to output states where x is mapped
to John and y is mapped to some man seen by John.
If the evaluation takes place in a model where John
saw several men, then there are several possible out-
put states. If the evaluation takes place in a model
where John saw no men at all, then there is no out-
put. A program that yields no output for a given in-
put fails for that input. A program yielding at least
one output for a given input succeeds for that input.
A program which yields at most one output for a
given input is deterministic for that input. A pro-
gram which yields more than one output for a given
input is indeterministic for that input. The example
&amp;quot;John saw a man&amp;quot; shows that indefinite descriptions
may give rise to indeterministic programs. Deter-
ministic programs that do not change their input are
called test programs. If a test program succeeds, its
output equals its input. The sentence &amp;quot;John saw
him&amp;quot; would give rise to a test program. Assuming
that the variable x,y are used for the subject and
object of the sentence, respectively, the program will
succeed for any input with x mapped to John and y
mapped to some male individual seen by John. In
this case success means that the output state equals
the input state. The program will fail for any other
input.
All basic programs of DPL are tests; they do not
change their input, and they succeed if the values of
terms are in a specified relation and fail otherwise.
Indeterminism in DPL arises from assignment pro-
grams. The assignment program for an indefinite de-
scription a man will assign a new value to a variable
x and succeed for any value of a which is a man.
This is called indefinite assignment. The assignment
program for a definite description the manager gives
a value to a variable if and only if there is only one
possible value in the model under consideration.
Complex programs can be formed by means of
negation, implication and sequential composition.
Negation and implication always form tests, but se-
</bodyText>
<page confidence="0.998451">
62
</page>
<bodyText confidence="0.997806333333333">
quential composition does not. Sequential composi-
tions are tests if and only if the component programs
are tests.
</bodyText>
<subsectionHeader confidence="0.995891">
2.2 Syntax
</subsectionHeader>
<bodyText confidence="0.935329142857143">
For ease of exposition we will assume there are no
function symbols in the DPL representation lan-
guage, so the terms of DPL are either constants or
variables. Let C be the set of constants, V the set of
variables, and assume c E C, v E V.
DPL terms t ::= c I v.
Assume a set of relation symbols R with arities.
Then the programs of DPL are given by the following
BNF definition.
DPL programs ir ::= t = t I Rt • •t I (ir; 7r) I (7r
7) (-17) nv 7 I IV :
We will use man, see as the relation symbols that
translate &amp;quot;man&amp;quot;, &amp;quot;see&amp;quot;, and so on. Thus, (1) is a
DPL program.
</bodyText>
<equation confidence="0.878689">
(1) (71v2: man(v2); see(v2, v4))•
</equation>
<bodyText confidence="0.999965857142857">
We will omit outermost brackets and brackets in
sequential compositions like ((in; 7 2);r3). This is
harmless, for sequential composition is associative.
Also, we will abbreviate qv : v = t as v := t. This
abbreviation is natural, as the sequential composi-
tion of random assignment to v and test for equality
with t boils down to assigning the value of t to v.
</bodyText>
<subsectionHeader confidence="0.982209">
2.3 Indices for Antecedents and Anaphors
</subsectionHeader>
<bodyText confidence="0.999972">
In the natural language fragment we treat, we use
co-indexing to indicate intended anaphoric links.
We follow Barwise [1] in using superscripts for an-
tecedents and subscripts for anaphors.
</bodyText>
<listItem confidence="0.962668">
(2) A man walked in. He smiled.
</listItem>
<bodyText confidence="0.995327666666667">
If we intend the pronoun in (2) to refer to the subject
of the first sentence, we indicate this intention as
follows.
</bodyText>
<listItem confidence="0.984193">
(3) A man&apos; walked in. Hei
</listItem>
<bodyText confidence="0.999843375">
The superscript on the indefinite noun phrase indi-
cates that this NP acts as an antecedent for NPs
with the same index as a subscript. The subscript
on the pronoun indicates the antecedent to which the
pronoun is linked.
The use of subscripts and superscripts is necessary
because noun phrases can act as anaphors and an-
tecedents at the same time.
</bodyText>
<listItem confidence="0.962342333333333">
(4) A man&apos; walked in.
Another man walked out.
He2 was angry.
</listItem>
<bodyText confidence="0.99201">
In example (4) the noun phrase another man is
anaphorically constrained by an antecedent noun
phrase a man (it must have a different referent), and
at the same time acts as antecedent for the second
occurrence of a man.
The superscripts and subscripts refer to the vari-
ables we employ in the translation of the noun
phrases. Superscripts correspond to variables that
get assigned a value in the translation, subscripts to
variables that are simply used. Sentence (5) will get
translated as (6) (tense is ignored, here and hereafter,
for ease of exposition).
</bodyText>
<listItem confidence="0.997416857142857">
(5) John1 saw a man2.
(6) vi := J; nv2 : man(v2); see(vi, v2)•
Sentence (7) gets translated as (8).
(7) Mare ignored himi.
(8) v3 := M; ignore(v3, vi).
Sentence (9) gets translated as (10).
(9) She3 saw another man.
</listItem>
<equation confidence="0.682631">
(10) 71v4; v4 0 v2; man(v4); see(va, v4).
</equation>
<bodyText confidence="0.9474065">
Turning now to definite descriptions, the natural
translation of example (11) is (12).
</bodyText>
<listItem confidence="0.9974495">
(11) John&apos; saw the man2.
(12) vi := J; tv2 : man(v2); see(vi, v2)•
</listItem>
<bodyText confidence="0.999928">
In the error state semantics for DPL that we have in
mind for this, (12) gives error in every model where
there is no unique man. It is clear that in most cases
this is too strong. Still, we do not think this is a
serious problem for our general approach. It seems
to be a linguistic fact that definite descriptions often
are used in a context-dependent way, to designate
a unique referent in a very specific context, which
however is not made fully explicit.
One context where (11) makes perfect sense is a
situation where John and some other male individ-
ual are present, and where it is left implicit that John
is excluded from the context where the reference is
unique. In such cases we propose to read the def-
inite description as uniquely satisfying the descrip-
tion plus the extra condition of being non-identical
with some constraining antecedent, in this case the
subject of the sentence. This strategy boils down to
reading (11) as (13).
</bodyText>
<listItem confidence="0.875356">
(13) Johnl saw the other man?.
</listItem>
<bodyText confidence="0.7257725">
Here the determiner the otheri is treated similarly to
anotheri. This gives translation (14).
</bodyText>
<listItem confidence="0.6586606">
(14) v1 := J;tv2: (v2 0 v1; man(v2));
see (vi, v2).
In many cases another mechanism seems to be at
work.
(15) A man walked in. John saw the man.
</listItem>
<bodyText confidence="0.9606655">
Example (15) has a natural reading where the
definite description is anaphorically linked to an
antecedent. We propose to make such implicit
anaphoric links explicit, as in (16).
</bodyText>
<listItem confidence="0.836382">
(16) A manl walked in. John2 saw the man?.
</listItem>
<bodyText confidence="0.9910895">
If we provide the right translation instruction for
such anaphoric uses of the, we arrive at translation
</bodyText>
<page confidence="0.958075">
63
</page>
<equation confidence="0.701607666666667">
(17).
(17) riv1 : man(vi); walk-in(vi); v2 := J;
1.1)3 : (v3 = vi; man(v3)); see(v2, v3).
</equation>
<bodyText confidence="0.998434285714286">
This gives the ma4 the meaning: the unique man
that is equal to vi, with v3 available for later reference
to this individual. It seems to us that this gives the
correct result, in the present case and in lots of other
cases.
In the case of (18) we still run into trouble, how-
ever.
</bodyText>
<listItem confidence="0.93765175">
(18) The man with the hat smiled.
Here, the natural translation is (19).
(19) tvi : (man(vi); tv2 : hat(v2); is-of (v2, vi);
smi/e(vi).
</listItem>
<bodyText confidence="0.990466142857143">
This translation contains a definite assignment tv2 :
hat(v2), so it seems to assume that there is a unique
hat in the domain of discourse, which is perhaps a
bit too strong. There are at least the following two
ways out. One is by handwaving. Just remark that
in descriptions like the man with the golden gun, the
second definite article is not quite as definite as it
looks, and the description is in fact idiomatic for the
more strictly correct the man with a golden gun. The
other escape is to add an epicycle to the analysis, in
order to achieve that man1 with&apos; the hat2 translates
into (20).
(20) man(vi); tv2 : (hat(v2); is-of (v2, vi)).
We provisionally opt for the first solution.
</bodyText>
<subsectionHeader confidence="0.990477">
2.4 Semantics
</subsectionHeader>
<bodyText confidence="0.994673935483871">
The standard DPL semantics maps input states to
sets of possible output states. Let a model M =
(M, I), where M is the domain and I the interpre-
tation function for a set of constants and relation
symbols be given. Then the set of states is the set of
functions MV, and the standard semantics for DPL
is given by a function Hm p(mV).
In order to capture the uniqueness presuppositions
of definite descriptions, we replace the standard se-
mantics by an error state semantics. In a Russellian
account of definite descriptions, &amp;quot;The king of France
is bald&amp;quot; when evaluated with respect to the state of
affairs in 1905 or 1993 is false, for there is no unique
referent for the description. But it is much more nat-
ural to follow Frege, Strawson and the majority of the
linguistic community in assuming that statements in-
volving &amp;quot;the king of France&amp;quot;, when interpreted with
respect to a state of affairs where there is no unique
king of France, may be neither true nor false, because
they suffer from presupposition failure.
We propose to use an error state semantics to take
in account the failure of uniqueness presuppositions
of t assignments. The error state semantics of DPL
if given by a function
: (Mv U e) &apos;P(Mv U c).
In the definition of this function, which follows, e
refers to a special error state, A ranges over proper
states, B ranges over states in general (including the
error state), and A[x := cl] is used for the proper
state which is like A, except for the fact that z is
mapped to d.
</bodyText>
<listItem confidence="0.9221755">
1. Prlm(e) = {f}
2. Pti • • • tnIIA4(A) =
</listItem>
<equation confidence="0.955548714285714">
f {A} if (VAA,A(ti),..., VM,A(t.)) E 1(R)
1 0 otherwise.
3. It1 = t2)I4(A) =
r {A} if Vm,A(ii) = Vm,A(t2)
1 0 otherwise.
4. I(ri; x2)1m(A) =
UfirAm(B) I B E Prilm(A)}.
5. [(vi x2)]A4(A) =
/ 0 otherwise.
(c) if there is a state B E Film(A)
{A} if for all B E[rjm(A)
withirAm(B) = {c}
it holds thatfr21m(B) ¢ (c)
6. [(-Am(A) =
0 otherwise. {c} if [x]Im(A) = {c}
/ NM(A) if m(A) = 0
7. P.m : rim(A)=
U{Prim(A[x := d]) I d E M).
8. [ix: allm(A) =
1[111A,f(A[x := d]) for the unique d with
1 frim(A[r := di) g {e)
</equation>
<bodyText confidence="0.981953166666667">
if d exists
{e} otherwise.
More information on this definition can be found in
[2]. For present purposes it is sufficient to note that
a DPL program can execute in three different ways,
when acting on a given input state:
</bodyText>
<listItem confidence="0.99462125">
1. The program reports success by producing at
least one proper output state. For example, the
program man (vi) when acting on an input state
where v1 refers to John will succeed and return
the input state as its only output state.
2. The program reports failure by not producing
any output at all. For example, the program
nvi : woman(vi) will fail for any input state
(except e) if there are no women in the model
under consideration (its output state set will be
empty).
3. The program reports error by producing c as its
only output. For example, the program Lv1
manager(vi) will produce e for any input state
if the model under consideration does not have
a unique manager.
</listItem>
<page confidence="0.998425">
64
</page>
<sectionHeader confidence="0.942164" genericHeader="method">
3 Preconditions of DPL programs
</sectionHeader>
<bodyText confidence="0.999652333333333">
Above, we have referred to DPL formulas as pro-
grams. We are now going to use tools for program-
ming language analysis on DPL. We will use quan-
tified dynamic logic over DPL to describe the pre-
conditions for success, failure and error of DPL pro-
grams.
</bodyText>
<equation confidence="0.7806024">
QDL terms t ::= c I v,
QDL programs r ::= t = t I Rt—t (7r;7r)
(r r) (-,7r) I ?iv : tv : r,
QDL formulas w ::=t = t I Rt • • •t (So A 50) I -&amp;quot;Ca
3vio I (7)S0 I [7]ç0-
</equation>
<bodyText confidence="0.989619166666667">
Note that the QDL programs are precisely the DPL
programs. An atomic relation Rti, • • • ,t„ can occur
inside a QDL program or as an atomic QDL formula,
so we need to distinguish the programs of QDL from
the static QDL relations. We use boldface for the
test program Rt, • • -4, and italics for the formula
Rti • -tn.
We omit outermost parentheses as usual, and use
T for a formula which is always true, 1 for a formula
which is always false.
The semantics of QDL is as for first order logic,
with the following clauses for the program modalities
</bodyText>
<listItem confidence="0.9186376">
added (assume A 0 c):
• M kA (w)co if there is some B with B E
Pr]Im(A), B c and M B So.
• M kA [7r]ço if for all B E 1[21m(A) it holds
that B c and M kEs
</listItem>
<bodyText confidence="0.999168">
Note that (7r) and [71-] are not duals. (7r)T expresses
the conditions for success of r, [7r].1 the conditions
for failure of r. It follows that --.(7r)T A --[71-]1 ex-
presses the conditions for error.
The following axiom schemata can be used to com-
pute these conditions as formulas of FOL.
</bodyText>
<listItem confidence="0.997445933333333">
1. (Rt, • • • t,i)co 4-4 (Rti • • t,, A co).
2. [Rt, • • • t„]co (Rti • • • tr, yo).
3. (t, = ta)cp (ti = t2 A co).
4. [t, = t,lio (ti = 12 -+ co).
5. (71; 72)So (70 (7r2)so•
6. fir1;7r2b1 4-4 [71][112)9-
7. (-17)51 (S0 A [7]-1-).
8. [-mica 4-4 ((i1-)T V (co A [7r]..L)).
9. (IT. 1r2)40 4-4 (so A [7rj(7r2)T).
10. [7r1 7r2)4,0 4-4 (([71]((72)T V [71-2].1)) A
([71](10T 41)).
11. (riv : w)y, 3v(71-)v.
12. [riv : who Vv[ir]v.
13. (tv : 7r)co (3!v(71-)T A 3v(ir)co).
14. [tv : 7r]o 4-4 (3!v(7r)T A Vv((ir)T MO).
</listItem>
<bodyText confidence="0.9998504">
The most interesting item of this list is the univer-
sal schema for i assignment (item 14). To see what
it means, note that [ir]T expresses that all output
states of r are proper. The schema states that the
following are equivalent:
</bodyText>
<listItem confidence="0.914292">
• For proper input state A, the program iv r
does only have proper output states, and all of
these satisfy 4p.
• For proper input state A there is precisely one
d E M for which r has a proper output on input
A[v := d], and for all d&apos; for which r has proper
outputs on A[v := d&apos;], all outputs of r on A[v :=
d&apos;] are proper and satisfy co.
</listItem>
<bodyText confidence="0.995643846153846">
It is not very difficult to see that these are indeed
equivalent, so the axiom schema is sound, as are the
other axiom schemata.
The axiom schemata can be used to calculate the
truth, falsity and error conditions of DPL programs
as formulas of FOL. If we represent a first order
model as a database, then evaluation of DPL in a
model reduces to evaluation of first order formulas
in the database.
An example will make clear how the axioms may
be used to compute preconditions of DPL programs
as FOL formulas. Consider example (21) with trans-
lation (22).
</bodyText>
<listItem confidence="0.68262275">
(21) If a woman is married,
her husband looks after her.
(22) (qx : Wx; Mx) = (ty : Hyx; Lyx).
Here is the derivation of the truth conditions.
Wx; Mx) * (IN : Hyx; Lyx))T
[nx : Wx; Mx](ty : Hyx; Li/x)T
[rix : Wx][Mx](cy : Hyx)(Lyx)T
▪ Vx[Wx][Mx](ty : Hyx)(Lyx)T
</listItem>
<equation confidence="0.9864968">
4-4 VX(WX (Mx -+ (cy : Hyx)(Lyx)T))
Vx(Wx (Mx
(3!y(Hyx)T A 3y(Hyx)(Lyx)T)))
Vx(Wx -* (Mx -.4
(3!yHyx A 3y(Hyx A Lyx)))).
</equation>
<bodyText confidence="0.989006">
To calculate the falsity conditions, we can use
theorem (23), which is derivable from the axiom
schemata:
</bodyText>
<listItem confidence="0.760067125">
(23) [7r1 7r3]1 4-4 air,JT A (70 [7r2]1).
Applying theorem (23), we get the following falsity
conditions for (22):
3x(Wx A Mx A 3!yHyx A Vy(Hyx
Program (22) aborts with error if it doesn&apos;t succeed
and doesn&apos;t fail. Modulo some FOL reasoning the
conditions for this are given by (24):
(24) Bx(Wx A Mx A -.3!yHyx).
</listItem>
<bodyText confidence="0.9989772">
This means that in all models where married women
do have unique husbands, program (22) will never
abort with error. In other words, the calculus allows
us to derive that the presupposition of the definite
description has been cancelled by the implication.
</bodyText>
<page confidence="0.999694">
65
</page>
<sectionHeader confidence="0.997389" genericHeader="method">
4 The Implementation
</sectionHeader>
<bodyText confidence="0.9908871875">
The parser The grammar for our fragment uses
categorial feature unification, and the parser is based
on standard techniques for such grammars. The syn-
tax consists of a lexicon, which associates categories
with lexical items, a category descriptor which gives
definitions of complex categories in terms of simpler
categories and some reduction rules.
Basic categories are S without features, and E
with features for number, person, case, ninder for
up index (= antecedent index) and dindex for down
index (= anaphor index). Complex categories are
built with / and \ and the constraints on feature uni-
fication in the usual way. The index features sin der
and dindex also occur on noun phrases and determin-
ers. Here are some examples of complex categories
(* marks the feature values that do not matter).
</bodyText>
<listItem confidence="0.999721333333333">
• N(number) =
S/E(number,*,*,*).
• NP (number,person,case,uindex,dindex) =
S/(E(numb er , p erson ,case,uindex,dindex) \ S) .
• VP(number,person,*) =
E(number,person,Nom,*,*) \S.
• TV(number,person,tense) =
VP(*,*,tense)/NP(*,*,Acc,*,*).
• DET(number,uindex,dindex) =
NP(number,Third,*,uindex,dindex)/
N (number) .
• AUX(number,person) =
VP(number,person,Tensed)/
VP (number ,person,Inf).
• NEG =
</listItem>
<bodyText confidence="0.412885">
AUX(number,person)\AUX(number,person).
Basic categories get assigned in the lexicon. For ex-
ample:
</bodyText>
<table confidence="0.984000692307692">
word Category
John&apos; NP(Sg,Third,*,i,*)
hei NP(Sg,Third,Nom,*,i)
himi NP(Sg,Third,Acc,*,i)
sees TV(Sg,Third,Tensed)
ai DET(Sg,i,*)
thei DET(*,i,*)
another; DET(*,ij)
j DET(*,i,j)
his
i
man N(Sg)
with (N(nr)\ N(nr))/NP(*,*,*,*,*)
</table>
<tableCaption confidence="0.223298">
Some examples of complex category formation:
</tableCaption>
<listItem confidence="0.973799">
• a mans:
</listItem>
<equation confidence="0.951877666666667">
DET(Sg,i,*) • N(Sg) =
NP(Sg,Third,*,i,*)/N(Sg) • N(Sg) =
NP(Sg,Third,*,i,*).
</equation>
<listItem confidence="0.928189">
• sees a mani:
</listItem>
<equation confidence="0.8379905">
TV(Sg, Third, Tensed) • NP(Sg,Third,*,*,*)
= (VP(Sg,Third,Tensed)/
NP(Sg,Third,Acc,*,*,*))
-NP(Sg,Third,*,*,*)
= VP(Sg,Third,Tensed).
• John&apos; sees a mani:
NP(Sg,Third,*,j,*) - VP(Sg,Third,Tensed) =--
(S/(E(Sg,Third,*,j,*)\S))-
(E(Sg,Third,Nom,*,*)\S)
=S.
</equation>
<bodyText confidence="0.986546291666666">
The translator The translator uses A-calculus to
translate parse trees into DPL programs. We could
have translated on the fly, building translations while
parsing, but the present set-up seemed preferable for
reasons of modularity of design.
The translation algorithm makes use of a lexical
function mapping pairs consisting of a lexical item
with an associated category to A-expressions in the
lexicon, along the lines of [9].
Translating a sentence into DPL boils down to
lambda reduction of the lambda expression which
results from combining the lambda expressions as-
sociated with the leaves of the parse tree, according
to the rules of functional application dictated by the
categorial structure.
Here are some examples of lambda expressions as-
sociated with lexical items with categories. Note that
we assume the presence of indices in the lexicon, so
we can handle anaphoric links by co-indexing.
For a proper understanding of the translation in-
structions one should bear in mind the distinction
between DPL variables that are used for DPL assign-
ment and lambda calculus variables. We use lower
case for the first and upper case for the latter.
</bodyText>
<table confidence="0.907456">
Translation for man, N(Sg):
AVI.man(14).
Translation for Johni ,NP(Sg,Third,*,i,*):
AVI.vi := J; Vi(vi).
Translation for sees, TV(Sg,Third,Tensed):
AVI.(AV2.(VIAV3.see(V2, V3))).
Translation for is, TV(Sg,Third,Tensed):
AVI.(AV2.(VIAV3.V2 = Vs)).
Translation for a(ni, Det(Sg,i,*):
AV1.(AV2.(tiv1 : Vi(vi); V2(vi))).
Translation for the&apos;, Det(*,i,*):
</table>
<equation confidence="0.476121">
AVI.(AV2.(tv1 : 14(vi); V2(N))).
</equation>
<bodyText confidence="0.663474285714286">
Translation for the i j, Det(*,i,j) (the anaphoric use of
the):
AV1.(AV2.ivi :(vi = vi; Vivi); V2(vi)).
Translation for if, (S/S)/S:
AVI,(AV2.V1 V2).
Translation for does, AUX(Sg,Third):
AVI.Vi.
</bodyText>
<page confidence="0.939253">
66
</page>
<table confidence="0.587057181818182">
Translation for not, NEG:
AVI.(AV2.--,(ViV2)).
Translation for anotherli , DET(Sg,i,j):
AVI.(AV2.(7iv1 : v vj; Vi(vi); V2(v1))).
Translation for the °the? DET(*,i,j):
AV1.(AV2.(cvi : (vi vj; Vi(vi)); V2(vi))).
Translation for hei, NP(Sg,Third,Nom,*,i):
Translation for his, , DET(*,i,j):
.(AV2.tvi : Vi(vi); iso! (vi, vi); V2(v1)).
Translation for with, (N(nr)\ N(nr))/NP(*,*,*,*,*):
AV1.(AV2.(AV3.(V2(V3); Vi(AV4 isof (V4, V3)))).
</table>
<bodyText confidence="0.999535615384616">
All these translations are typed, but we have left
most of the typing discipline implicit. For example,
the translations of noun phrases all are of the type
of (dynamic) generalized quantifiers, which take a
property to give a DPL program. The translation
of proper names is a dynamic variation of the Mon-
tague treatment for proper names [8]. In extensional
Montague grammar, proper names translate into ex-
pressions denoting the set of properties which are
true of the named individual. Here, proper names
translate into expressions that for every property
give the DPL program which first assigns the name
of the individual to the index variable of the proper
name, and then tests for the property. This is like
in Montague grammar, but with a dynamic touch
added. Anaphoric links to the name remain possible
by means of the index variable as long as its value
remains unchanged.
Other noun phrases with a dynamic flavour are
indefinite and definite descriptions. Indefinite de-
scriptions translate into expressions that for every
property give the DPL program which does an in-
definite assignment to an index variable and tests
for the property. Definite descriptions are handled
likewise, but with definite assignment instead of in-
definite assignment.
</bodyText>
<listItem confidence="0.493294">
(25) Johnl uses his pc?.
</listItem>
<bodyText confidence="0.962496333333334">
As an example, we treat the translation of (25),
which is obtained starting from the following parse
tree:
</bodyText>
<equation confidence="0.984357481481481">
(S,
(N , J ohn) ,
(VP,
(TV, uses),
(NP?,
(D ET? , his),
(N , pc)
The translation step by step:
his pc? AVI.(A112.1v2 :
Vi(v2); is-of (v2, vi); V2(v2))(AVI .pc(V1))
AV 2 .tv2 : (AK .pc(K))(v2); is-of (v2, vi);V2(v2)
AV2 .1v2 : pc(v2); is-of (v2, vi);V2(v2).
uses his pc?
AVI.(AV2.14(AV3. use(V2 , V3)))
(AV2 .tv2 : pc(v2); is-of (v2, vi);V2(v2))
AV2.(AV2.(tv2 : pc(v2); is-of (v2, vi);V2(v2))
(AV3 .use(V2 , V3))
-4
0172 3V2
pc(v2); is-of (v2, vi);(.XV3.use(V2,113))(v2))
AV 2 .tv2 : pc(v2); is-of (v2, vi); use(V2, v2)•
Johnl uses his pc?
:= J;(iii(vi))
AV2.tv2 : pc(v2); is-of (v2, vi.); use(V2, v2)
:= J;
(AV2 .tv2 : pc(v2); is-of (v2, vi); use (V2 v2))(vi)
V1 := J; tv2 : pc(v2); is-of (v2, vi); use(vi, v2)•
</equation>
<bodyText confidence="0.972828">
In the same way, (26) gets translated into (27).
</bodyText>
<listItem confidence="0.908833666666667">
(26) John&apos; is a man2.
(27) vi := J; tiv2 : man(v2); vi = vz.
Note that &apos;is&apos; is treated as in Montague grammar [8].
</listItem>
<sectionHeader confidence="0.834371" genericHeader="method">
5 Experiences with the Godel
Implementation Language
</sectionHeader>
<bodyText confidence="0.99994147826087">
The declarative semantics of Godel improves on the
semantics of Prolog: extra-logical predicates (such as
var, nonvar, assert, retract, !, .) are avoided and
sometimes replaced by declarative counterparts.
Like Lambda Prolog [7], Giidel is a typed language:
it is necessary to declare the type and domain of all
functions and predicates (polymorphism is allowed,
however). This convention makes program writing a
bit more cumbersome. For example, we have to de-
clare the type Program for representing a DPL pro-
gram. For each DPL statement, it is necessary to
define a function to build a Program (example: Pi-
ota : Variable * Program —k Program). We also have
to declare a type Expression for A-expressions. Some
complications arise from the fact that an expression
may contain a DPL program and vice versa. On the
plus side, more errors are detected during compila-
tion, the compiler generates more efficient code, and
the typing discipline makes for more legible, com-
prehensible programs. Last but not least, the typing
discipline has obliged us to think a bit more about
the clauses we were writing than we perhaps would
have done otherwise.
</bodyText>
<page confidence="0.998776">
67
</page>
<bodyText confidence="0.999977666666667">
Godel has facilities that permit elegant meta-
programming. In Prolog the program and the meta-
program are not independent: the predicates as-
sert and retract modify the program itself in which
these predicates occur. In Godel, program and meta-
program are completely independent. It is possible
for a program to load another program, to modify
this other program by inserting or retracting predi-
cates, functions or types, and to demonstrate a goal.
In our implementation we use these facilities to rep-
resent a model as a logic database and a precondition
as a complex goal.
</bodyText>
<sectionHeader confidence="0.988731" genericHeader="method">
6 The Program Itself
</sectionHeader>
<bodyText confidence="0.9888236">
The main module takes a sentence or text as input
and produces a report containing the sentence, the
parse tree, the DPL program it gets translated into,
and the preconditions. This module uses the follow-
ing submodules:
</bodyText>
<listItem confidence="0.956790636363636">
• the parser module which from a sentence, finds
its category and builds its parse tree,
• the translation module which from the parse
tree, computes a representation of a DPL pro-
gram,
• the precondition module which from a DPL pro-
gram, derives the preconditions (this module
calls another module to simplify the resulting
FOL formulas),
• the evaluation module which performs a
database evaluation.
</listItem>
<bodyText confidence="0.999085333333333">
A lexicon module is called by the first two of these
modules. It contains the words, with their categories
and the associated A-expressions.
</bodyText>
<subsectionHeader confidence="0.999247">
6.1 Main module
</subsectionHeader>
<bodyText confidence="0.99962">
This module receives a sentence represented by a list
of words and parses it, translates it, produces a re-
port, computes preconditions and evaluates these in
a given model.
</bodyText>
<subsectionHeader confidence="0.996791">
6.2 Output
</subsectionHeader>
<bodyText confidence="0.999551333333333">
This module defines how to output programs, ex-
pressions, categories, trees, words, ... It uses the
facilities of Godel for manipulating text files.
</bodyText>
<subsectionHeader confidence="0.998504">
6.3 Lexicon
</subsectionHeader>
<bodyText confidence="0.999752">
The lexicon is defined by a predicate Diet with three
arguments: the word itself, a category and an appro-
priate lambda expression.
</bodyText>
<subsectionHeader confidence="0.98001">
6.4 Parser
</subsectionHeader>
<bodyText confidence="0.999112">
The parser employs backtracking and unification in
the usual way. Giidel (as all logic programming lan-
guages) has these features built in, which makes it
very easy to implement a parser for a simple frag-
ment like ours. The parsing of a sentence consists of
three steps:
</bodyText>
<listItem confidence="0.9963062">
• generate a list of categories corresponding to the
sequence of words,
• reduce the list of categories,
• test if you have a sentence else retrace your steps
and try again.
</listItem>
<bodyText confidence="0.972733260869565">
We use the type cat egor to represent categories. It
is defined by the constant S and the functions
4number,person,case,uindex,dinder),
NP(numbenperson,case,uindex,dindex),
N(number),
and so on. The two infix functions / and \ serve to
build new and more complex categories.
Sentences are parsed by building a binary parse tree
in bottom-up fashion. The binary parse trees are
represented by a constant Empty and a function A.
Empty represents the empty tree and the function
A gives the information at the current node, the left
subtree, and the right subtree. The information con-
tent of the nodes is of two kinds: internal nodes carry
the result of combining the categories of the subtrees
and leaf nodes carry a pair consisting of a word and
its category.
The parse trees are built during the reduction of the
list of categories, starting with a list of trees corre-
sponding to the words of the sentence. When we
reduce two adjacent categories, we replace the two
corresponding trees Ti T2 by a single tree with T1
and T2 as immediate subtrees.
</bodyText>
<subsectionHeader confidence="0.73936">
6.5 Translator
</subsectionHeader>
<bodyText confidence="0.99992676">
The translator uses two types: Program and Expres-
sion. The first represents a DPL-program, the sec-
ond a complex A-expression. We have left the rest of
the typing of the lambda expressions implicit.
The definition of programs and lambda expressions
is a bit cumbersome, for a A-expression may contain
a program and vice versa. This complication is re-
fleeted in the rules for substitution and reduction.
For example, it is necessary to define the substitu-
tion of an expression for a variable in a program, the
free occurrence of a variable in a program, etc. The
rules of reduction are a straightforward rendering of
the rules of /3-reduction and 7-reduction in A calcu-
lus. We do not handle a reduction, as we see no need
for variable renaming.
The translation process employs the following pred-
icates:
Trad This predicate translates a parse tree into a
reduced A-expression. Depending on the information
at the current node of the parse tree, a lexical look-
up of the translation takes place, or the translation is
found by reducing the application of the translations
of the left and right subtrees.
Trans This predicate translates a list of parse trees
for the sentences of a text into the corresponding
</bodyText>
<page confidence="0.997923">
68
</page>
<bodyText confidence="0.999159166666667">
DPL program. It uses the predicate Trad to trans-
late each sentence, and then links these translations
by applications.
Canred This predicates takes a .\-expression and
reduces it using the declarative functional semantics
of )-calculus.
</bodyText>
<subsectionHeader confidence="0.95486">
6.6 From DPL to QDL
</subsectionHeader>
<bodyText confidence="0.9999645">
We have seen that DPL programs are represented
as G6del functions. The reduction of DPL to FOL
by means of QDL gets implemented by defining re-
duction predicates corresponding to the QDL axiom
schemata. These predicates call each other recur-
sively.
</bodyText>
<listItem confidence="0.999089833333333">
• FR(Rel(s, v)) is a relational atomic test.
(Rti • • •in)
• Fequal(tl, t2) is an atomic test of equality of
the terms ti and t2. (ti = t2)
• Fand(phil, phi2) is the conjunction of two for-
mulas. ((pi A co)
• For(phil, phi2) is the disjunction of two for-
mulas. ((pi V co2)
• Fimplic(phl, phi2) is the implication of two
formulas. (wi —4 so2)
• Fall(V(i), phi) is the expression (Vvicp)
• Fexist(V(i), phi) is the expression (Jaw)
• Fonlyone(V(i), phi) is the expression (3!vico)
• Fnot (phi) is the negation of the formula co.
(—Y)
• Fprecexist(pi, phi) is the expression ((7)6o)
• Fprecuniv(pi, phi) is the expression ([4p)
• Fpar(pi, phi) is the expression (--.(r)co A-44p).
</listItem>
<bodyText confidence="0.995651555555556">
In the course of applying these predicates, formulas
may get generated with obvious redundancies. We
have defined a formula simplifier to remove some of
these. This improves the readability of the output
(the formulas are output in LaTeX format) and the
performance of the database lookup on the basis of
the conditions.
There is the list of simplifications handled by the
module Simple.
</bodyText>
<listItem confidence="0.999959">
• co A T co
•
• wVT4—■T
• yo V 1 4-4
• (yo T) 1-4 T
• (T 4- (p)
• (fp I) 4-3.
• (j_ (p) 4-■ T
• —LI_ T
• —IT 4-t•
• (3!vp A 3v9) 4-4 3!v6o.
</listItem>
<subsectionHeader confidence="0.963461">
6.7 Evaluation
</subsectionHeader>
<bodyText confidence="0.9993218">
The intermediate language QDL allows us to trans-
late DPL programs into formulas of FOL. These are
then evaluated in a database model, i.e., a first order
model which is implemented as a GOdel database (a
Godel program). There we have a so-called meta-
module Evaluation and an object program Logic
Database, and the meta-program manipulates the
object program. We translate first order conditions
into Godel goals, and then apply the goal to the ob-
ject Godel program, using the possibilities of meta-
programming offered by Godel. In ordinary Prolog,
these things could also be done, but they would look
much less elegant.
Here is an example of a Gide&apos; model (the lines pre-
ceded by % are comment lines):
</bodyText>
<reference confidence="0.745007555555556">
MODULE Modell.
IMPORT Strings, Sets.
BASE Symbol.
% We use this base for every kind of term.
CONSTANT
John, Bill, Freddy, Borsalino, Myclone: Symbol.
PROPOSITION Top.
PREDICATE
Admire, Cheer, Isof, See, Use: Symbol * Symbol;
Hat, Man, Adult, King, Pc, Manager: Symbol.
% The relations defined in the model
Admire(John,Bill).
King(Bill).
Isof(Borsalino,Bill).
Hat(Borsalino).
See(John,Bill).
See(Bill,John).
Manager(Bill).
Man(John).
Man(Bill).
Man(Freddy).
Adult(John).
Adult (Bill).
Pc(Myclone).
Use(John,Myclone).
Top.
% Top must be defined in every model.
</reference>
<page confidence="0.999533">
69
</page>
<sectionHeader confidence="0.999454" genericHeader="conclusions">
7 Conclusion
</sectionHeader>
<bodyText confidence="0.999859526315789">
The QDL translation discussed above only handles
uniqueness presuppositions of definite descriptions.
The method employed is general enough, however,
to handle lots of other kinds of presupposition. Lex-
ical presuppositions, for example, are handled in the
error state semantics by a slight revision of the se-
mantic clause for atomic tests. Being a bachelor pre-
supposes being male and adult, so the test for bach-
elorhood should give error if it is performed on an
entity that does not satisfy the test for being a male
adult.
Formally, the revision boils down to this. Let At be
the set of atomic formulae of DPL. Assume a lexi-
cal presupposition function lp : At —* DPL mapping
each atomic test predicate of the representation lan-
guage to its associated lexical presupposition, con-
ceived as a program of the representation language.
For example, here are the lexical presuppositions for
bachelorhood.
</bodyText>
<equation confidence="0.51656">
lp(bachelor x) = (male x; adult x).
</equation>
<bodyText confidence="0.91456305">
The semantic clause for atomic relations is mod-
ified to take the function lp into account:
2&apos;. [R(ti • • • tn)])m(A) =
{{A} if [1p(Rh - - • tn)1m(A) g {e}
and M 1=4 Rh • - • in)
0 if [1p(Rti - • • tn)]1m(A) ¢ {c}
and M KA Rh • • • tn,
{e} if [1p(Rh - • • tn)1m(A) c {e}.
This modified definition gives the success and failure
of the relational test modulo the fact that the lexi-
cal presupposition of the relational test holds; if the
presupposition does not hold then the test results in
error.
There is no need for any other changes in the rules,
for the projection of lexical presupposition is taken
care of by the general principles• of error percola-
tion that are already implicit in the semantic clauses.
Thus, the DPL error semantics gives us that (28) pre-
supposes that Jan is male and adult, but that (29)
only presupposes that Jan is adult.
</bodyText>
<listItem confidence="0.371211">
(28) Jan is a bachelor.
(29) If Jan&apos; is male, then he, is a bachelor.
</listItem>
<bodyText confidence="0.874464">
The change in the semantic clause for atomic re-
lations is reflected in the calculus by replacing the
schemata for Rt, • • •tn by the following versions:
</bodyText>
<listItem confidence="0.637696333333333">
1. (Rti • • • tn)S0 *4
(Ril • • • tn A q, A (IP(Rti • • •
2. [Rti • • • tn]ço 4-
</listItem>
<equation confidence="0.752349">
(Rti • • - in -4 yo) A (1p(Rt1 • • • inDT).
</equation>
<bodyText confidence="0.9990125">
In the implementation, lexical presupposition is han-
dled by a predicate Lp and a modification of the
reduction predicates for the relational test axiom
schemata.
Right now, we are extending the fragment to deal
with other kinds of presupposition failure, in partic-
ular failure of presupposition of aspectual verbs such
as start and stop.
</bodyText>
<sectionHeader confidence="0.998481" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999956775">
[1] J. Barwise. Noun phrases, generalized quanti-
fiers and anaphora. In P. Gardenfors, editor,
Generalized Quantifiers: linguistic and logical
approaches, pages 1-30. D. Reidel Publishing
Company, Dordrecht, 1987.
[2] J. van Eijck. The dynamics of description. Jour-
nal of Semantics, 10, 1993. to appear.
[3] J. van Eijck. Presupposition failure — a comedy
of errors. Manuscript, CWI, Amsterdam, 1993.
[4] J. van Eijck and F .J. de Vries. Dynamic in-
terpretation and Hoare deduction. Journal of
Logic, Language, and Information, 1:1-44, 1992.
[5] J. Groenendijk and M. Stokhof. Dynamic pred-
icate logic. Linguistics and Philosophy, 14:39-
100, 1991.
[6] P.M. Hill and J.W. Lloyd. The Godel report.
Technical report, Department of Computer Sci-
ence, University of Bristol, Bristol, 1991 (re-
vised 1992).
[7] D.A. Miller. A logic programming language with
lambda abstraction, function variables and sim-
ple unification. In P. Schroeder-Heister, edi-
tor, Extensions of Logic Programming. Springer,
1990.
[8] R. Montague. The proper treatment of quantifi-
cation in ordinary english. In J. Hintikka e.a.,
editor, Approaches to Natural Language, pages
221-242. Reidel, 1973.
[9] R. Muskens. Anaphora and the logic of change.
In J. van Eijck, editor, Logics in Al / Eu-
ropean Workshop JELIA &apos;90 / Amsterdam,
The Netherlands, September 1990 / Proceed-
ings, Lecture Notes in Artificial Intelligence 478,
pages 412-427. Springer Verlag, 1991.
[10] R. Muskens. Tense and the logic of change.
Manuscript, University of Tilburg, 1992.
[11] V. Pratt. Semantical considerations on Floyd-
Hoare logic. Proceedings 17th IEEE Symposium
on Foundations of Computer Science, pages
109-121, 1976.
</reference>
<page confidence="0.99848">
70
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.000000">
<title confidence="0.998844">A Strategy for Dynamic Interpretation: a Fragment and an Implementation</title>
<author confidence="0.998851">Jan van_and Olivier</author>
<email confidence="0.969936">obo@info.fundp.ac.be,jve@cwi.nl,ois@info.fundp.ac.be</email>
<address confidence="0.831240333333333">lInstitut d&apos; Informatique, FUNDP, 61 Rue de Bruxelles, 5000 Namur, Belgium, P.O. Box 4079, 1009 AB Amsterdam, The Netherlands 10, 3512 JK Utrecht, The Netherlands</address>
<abstract confidence="0.994406061571125">1 The Idea of Dynamic Interpretation Recent developments in Natural Language semantics have witnessed a shift away from static representation languages towards representation languages with a dynamic flavour. Such representation languages can be viewed as definitions of very simple imperative programming languages. To see how the imperative style comes in, consider the treatment of indefinite descriptions (or: existential phrases). Existential quantifiers are viewed dynamically as random assignment statements followed by tests. The translation of the natural language phrase &apos;a man&apos; becomes something like: x := ?; man(x) The first part of this statement can be viewed as a random assignment to register x, the second part as a test on the value of x. This sequence of instructions is performed against the background of a database, i.e., a model of first order logic. The sequence succeeds if the database contains (representations of) men, and it can succeed in as many ways as there are men available in the database. The motivating examples for the shift from static to dynamic representation have to do with pronoun binding. The translation of phrases like &apos;a man&apos; in terms of assignments of values to registers makes it possible to treat binding of pronouns across sentence boundaries (the next sentence can start with &apos;He&apos; to pick up the reference to &apos;a man&apos;). The nice thing about the treatment in terms of assignment is that the scope of the existential quantification is not closed off at the end of a sentence, as used to be the case for NL systems that employ static representation (in terms of the existential quantifiers of predicate logic, with their irritating closing brackets). Abstract The strategy for natural language interpretation presented in this paper implements the dynamics of context change by translating natural language texts into a meaning representation language consisting of (descriptions of) programs, in the spirit of dynamic predicate logic (DPL) [5]. The difference with DPL is that the usual DPL semantics is replaced by an error state semantics [2]. This allows for the treatment of unbound anaphors, as in DPL, but also of presuppositions and presupposition projection. The use of this dynamic interpretation strategy is demonstrated in an implementation of a small fragment of natural language which handles unbound pronoun antecedent links, where it is assumed that the intended links are indicated in the input string, and uniqueness presuppositions of definite descriptions. The implementation consists of a syntax module which outputs parse trees, a semantic module mapping parse trees to DPL representations, a representation processor which determines truth conditions, falsity conditions and presupposition failure conditions, and an evaluator of these conditions in a database model. The implementation uses the logic programming language Godel [6], an experimental successor of Prolog, with similar functionality and expressiveness, but with an improved declarative semantics. 61 Recently, it has become clear that dynamic representation has some other interesting features: • It becomes possible to give an account of presupposition failure phenomena in terms of the definition of an error state semantics for the dynamic representation language [3; 2]. Presupposition failure occurs for example if one tries to interpret &amp;quot;John&apos;s wife is unhappy&amp;quot; in a situation where John is not married. • A more natural treatment of tense becomes possible. A sequence of sentences in the past tense like &amp;quot;A man walked in. He sat down. He ordered a drink&amp;quot; etc, is represented using subsequent assignments of values (time intervals) to a dedicated time register t [10]. The dynamic representation language can be analysed with tools that were originally designed for analysing imperative programming languages, namely the tools for precondition reasoning from Hoare logic or dynamic logic [11]. Precondition reasoning for dynamic predicate logic with standard semantics was introduced in [4]. Precondition reasoning gives the truth conditions of DPL representations in the form of formulas of first order logic (FOL). When applied to the error state semantics of DPL, precondition reasoning can also be used to find the presupposition failure conditions of DPL representations as FOL formulas. We provide an integrated treatment of syntax and semantics of a small fragment of natural language and test this by implementing it. The syntax of our toy grammar is a version of categorial grammar with feature unification. The semantics uses DPL representations, with an error state semantics which is reflected in the rules for precondition reasoning implemented in the precondition module. This module generates predicate logical formulas expressing the weakest preconditions of success, failure or error of the DPL representations. In detail, our interpretation strategy consists of the following steps: 1. Parsing a sentence or text and building a representation tree of its structure. 2. Translating the parse tree into a DPL program. 3. Using precondition reasoning to compute preconditions as formulas of FOL. 4. Simplifying the preconditions using a simplifier for FOL formulas. 5. Evaluating the resulting formulas in a database model. The current implementation produces for an input text within the grammar fragment: a LaTeX form report containing the sentence, the parse tree, the DPL translation, the precondition of success, the precondition of failure and the precondition of error, all in simplified form, and the result of evaluation in the database. 2 Dynamic Predicate Logic 2.1 Informal discussion DPL meaning representations for natural language sentences can be viewed as procedures or programs with a relational semantics. The programs that represent the meanings are interpreted as relations between input states and output states. A state is a mapping from variables to values in a model (in our simple set-up all variables are of the same type). The representation for an example sentence such as &amp;quot;John a man&amp;quot; is a program which associates variable a variable first checks the value of John, next puts a value satisfies the predicate of being a man, and checks whether the values of x and such that the first saw the second. Thus, the representation of &amp;quot;John saw a man&amp;quot; a program which relates input states where to John to output states where mapped John and mapped to some man seen by John. If the evaluation takes place in a model where John saw several men, then there are several possible output states. If the evaluation takes place in a model where John saw no men at all, then there is no output. A program that yields no output for a given input fails for that input. A program yielding at least one output for a given input succeeds for that input. A program which yields at most one output for a given input is deterministic for that input. A program which yields more than one output for a given input is indeterministic for that input. The example &amp;quot;John saw a man&amp;quot; shows that indefinite descriptions may give rise to indeterministic programs. Deterministic programs that do not change their input are called test programs. If a test program succeeds, its output equals its input. The sentence &amp;quot;John saw him&amp;quot; would give rise to a test program. Assuming the variable used for the subject and object of the sentence, respectively, the program will succeed for any input with x mapped to John and y mapped to some male individual seen by John. In this case success means that the output state equals the input state. The program will fail for any other input. All basic programs of DPL are tests; they do not change their input, and they succeed if the values of terms are in a specified relation and fail otherwise. Indeterminism in DPL arises from assignment programs. The assignment program for an indefinite description a man will assign a new value to a variable succeed for any value of is a man. This is called indefinite assignment. The assignment for a definite description manager a value to a variable if and only if there is only one possible value in the model under consideration. Complex programs can be formed by means of negation, implication and sequential composition. and implication always form tests, but se- 62 quential composition does not. Sequential compositions are tests if and only if the component programs are tests. For ease of exposition we will assume there are no function symbols in the DPL representation language, so the terms of DPL are either constants or Let the set of constants, set of and assume E ::= c I v. a set of relation symbols arities. Then the programs of DPL are given by the following BNF definition. ::= • •t (ir; I (7r nv : will use man, the relation symbols that translate &amp;quot;man&amp;quot;, &amp;quot;see&amp;quot;, and so on. Thus, (1) is a DPL program. (71v2: man(v2); v4))• We will omit outermost brackets and brackets in compositions like ((in; 2);r3). is harmless, for sequential composition is associative. we will abbreviate qv : v = v := abbreviation is natural, as the sequential composition of random assignment to v and test for equality down to assigning the value of v. 2.3 Indices for Antecedents and Anaphors In the natural language fragment we treat, we use co-indexing to indicate intended anaphoric links. We follow Barwise [1] in using superscripts for antecedents and subscripts for anaphors. (2) A man walked in. He smiled. If we intend the pronoun in (2) to refer to the subject of the first sentence, we indicate this intention as follows. A in. Hei The superscript on the indefinite noun phrase indicates that this NP acts as an antecedent for NPs with the same index as a subscript. The subscript on the pronoun indicates the antecedent to which the pronoun is linked. The use of subscripts and superscripts is necessary because noun phrases can act as anaphors and antecedents at the same time. (4) A man&apos; walked in. Another man walked out. example (4) the noun phrase man anaphorically constrained by an antecedent noun phrase a man (it must have a different referent), and at the same time acts as antecedent for the second occurrence of a man. The superscripts and subscripts refer to the variables we employ in the translation of the noun phrases. Superscripts correspond to variables that get assigned a value in the translation, subscripts to variables that are simply used. Sentence (5) will get translated as (6) (tense is ignored, here and hereafter, for ease of exposition). (5) saw a vi := nv2 : see(vi, Sentence (7) gets translated as (8). (7) Mare ignored himi. v3 := vi). Sentence (9) gets translated as (10). (9) She3 saw another man. 71v4; v4 0 v2; see(va, Turning now to definite descriptions, the natural translation of example (11) is (12). John&apos; saw the vi := tv2 : see(vi, v2)• the error state semantics for we have in mind for this, (12) gives error in every model where there is no unique man. It is clear that in most cases this is too strong. Still, we do not think this is a serious problem for our general approach. It seems to be a linguistic fact that definite descriptions often are used in a context-dependent way, to designate a unique referent in a very specific context, which however is not made fully explicit. One context where (11) makes perfect sense is a situation where John and some other male individual are present, and where it is left implicit that John is excluded from the context where the reference is unique. In such cases we propose to read the definite description as uniquely satisfying the description plus the extra condition of being non-identical with some constraining antecedent, in this case the subject of the sentence. This strategy boils down to reading (11) as (13). (13) saw the other the determiner otheri treated similarly to gives translation (14). (14) := (v2 0 see (vi, v2). many another mechanism seems to be at work. (15) A man walked in. John saw the man. Example (15) has a natural reading where the definite description is anaphorically linked to an antecedent. We propose to make such implicit anaphoric links explicit, as in (16). A in. saw the man?. If we provide the right translation instruction for anaphoric uses of we at translation 63 (17). riv1 : walk-in(vi); v2 := (v3 = vi; man(v3)); see(v2, v3). gives ma4 meaning: unique man is equal to available for later reference to this individual. It seems to us that this gives the correct result, in the present case and in lots of other cases. In the case of (18) we still run into trouble, however. (18) The man with the hat smiled. Here, the natural translation is (19). tvi : : is-of vi); smi/e(vi). This translation contains a definite assignment tv2 : seems to assume that there is a unique hat in the domain of discourse, which is perhaps a bit too strong. There are at least the following two ways out. One is by handwaving. Just remark that descriptions like man with the golden gun, second definite article is not quite as definite as it looks, and the description is in fact idiomatic for the strictly correct man with a golden gun. other escape is to add an epicycle to the analysis, in to achieve that the translates into (20). man(vi); tv2 : is-of (v2, We provisionally opt for the first solution. The standard DPL semantics maps input states to sets of possible output states. Let a model M = I), the domain and interpretation function for a set of constants and relation symbols be given. Then the set of states is the set of MV,and the standard semantics for DPL given by a function In order to capture the uniqueness presuppositions of definite descriptions, we replace the standard semantics by an error state semantics. In a Russellian account of definite descriptions, &amp;quot;The king of France is bald&amp;quot; when evaluated with respect to the state of affairs in 1905 or 1993 is false, for there is no unique referent for the description. But it is much more natural to follow Frege, Strawson and the majority of the linguistic community in assuming that statements involving &amp;quot;the king of France&amp;quot;, when interpreted with respect to a state of affairs where there is no unique king of France, may be neither true nor false, because they suffer from presupposition failure. We propose to use an error state semantics to take in account the failure of uniqueness presuppositions of t assignments. The error state semantics of DPL if given by a function U e) U c). In the definition of this function, which follows, e refers to a special error state, A ranges over proper over states in general (including the state), and := cl] used for the proper state which is like A, except for the fact that z is to 1. Prlm(e) = {f} 2. • • • = {A} if (VAA,A(ti),..., 3. It1 = t2)I4(A) = if Vm,A(ii) = Vm,A(t2) 4. I(ri; x2)1m(A) = I Prilm(A)}. 5. [(vi x2)]A4(A) = (c) if there is a state B E Film(A) if for B withirAm(B) = {c} it holds thatfr21m(B) ¢ (c) 6. [(-Am(A) = {c} if [x]Im(A) = {c} / NM(A) if m(A) = 0 7. : := d]) I d M). 8. = := d]) the unique 1 frim(A[r := di) g {e) {e} otherwise. More information on this definition can be found in [2]. For present purposes it is sufficient to note that a DPL program can execute in three different ways, when acting on a given input state: 1. The program reports success by producing at least one proper output state. For example, the program man (vi) when acting on an input state where v1 refers to John will succeed and return the input state as its only output state. 2. The program reports failure by not producing any output at all. For example, the program : woman(vi) will fail for any input state (except e) if there are no women in the model under consideration (its output state set will be empty). The program reports error by producing as output. For example, the program manager(vi) will produce e for any input state if the model under consideration does not have a unique manager. 64 3 Preconditions of DPL programs Above, we have referred to DPL formulas as programs. We are now going to use tools for programming language analysis on DPL. We will use quantified dynamic logic over DPL to describe the preconditions for success, failure and error of DPL programs. terms ::= c I programs r ::= I Rt—t r) (-,7r) I r, formulas w = t I Rt • • •t A I I I Note that the QDL programs are precisely the DPL An atomic relation • • occur inside a QDL program or as an atomic QDL formula, so we need to distinguish the programs of QDL from the static QDL relations. We use boldface for the program • • -4, italics for the formula • We omit outermost parentheses as usual, and use T for a formula which is always true, 1 for a formula which is always false. The semantics of QDL is as for first order logic, with the following clauses for the program modalities (assume 0 c): M kA (w)co there is some B c M B M kA if for all 1[21m(A) it c M Note that (7r) and [71-] are not duals. (7r)T expresses the conditions for success of r, [7r].1 the conditions failure of r. It follows that --.(7r)T expresses the conditions for error. The following axiom schemata can be used to compute these conditions as formulas of FOL. (Rt, • • • co). [Rt, • • • • • yo). (t, = (ti = t2 A co). [t, = t,lio (ti = -+ co). 5. (70 (7r2)so• fir1;7r2b1 4-4 7. A [-mica 4-4 ((i1-)T V (co 9. (IT. 1r2)40 4-4 (so A [7rj(7r2)T). 10. 4-4V A : w)y, 12. [riv : who Vv[ir]v. 13. (tv : 7r)co (3!v(71-)T A 3v(ir)co). 14. [tv : 7r]o 4-4 (3!v(7r)T A Vv((ir)T MO). The most interesting item of this list is the universal schema for i assignment (item 14). To see what it means, note that [ir]T expresses that all output states of r are proper. The schema states that the following are equivalent: For proper input state program iv r does only have proper output states, and all of these satisfy 4p. For proper input state is precisely one which r has a proper output on input := for all which r has proper on A[v := outputs of r on A[v := proper and satisfy co. It is not very difficult to see that these are indeed equivalent, so the axiom schema is sound, as are the other axiom schemata. The axiom schemata can be used to calculate the truth, falsity and error conditions of DPL programs as formulas of FOL. If we represent a first order model as a database, then evaluation of DPL in a model reduces to evaluation of first order formulas in the database. An example will make clear how the axioms may be used to compute preconditions of DPL programs as FOL formulas. Consider example (21) with translation (22). If is her husband looks after her. (qx : Wx; = : Lyx). Here is the derivation of the truth conditions.</abstract>
<title confidence="0.7567482">(IN : Hyx; Mx](ty Hyx; Li/x)T : Hyx)(Lyx)T ▪ Vx[Wx][Mx](ty : Hyx)(Lyx)T VX(WX (Mx -+ : Hyx)(Lyx)T</title>
<author confidence="0.556993">Vx</author>
<abstract confidence="0.987319074074074">A -* -.4 A 3y(Hyx A To calculate the falsity conditions, we can use theorem (23), which is derivable from the axiom schemata: (23) 4-4 air,JT Applying theorem (23), we get the following falsity conditions for (22): A 3!yHyx A Vy(Hyx Program (22) aborts with error if it doesn&apos;t succeed and doesn&apos;t fail. Modulo some FOL reasoning the conditions for this are given by (24): Bx(Wx -.3!yHyx). means that in all models women do have unique husbands, program (22) will never abort with error. In other words, the calculus allows us to derive that the presupposition of the definite description has been cancelled by the implication. 65 4 The Implementation The parser The grammar for our fragment uses categorial feature unification, and the parser is based on standard techniques for such grammars. The syntax consists of a lexicon, which associates categories with lexical items, a category descriptor which gives definitions of complex categories in terms of simpler categories and some reduction rules. categories are features, and features for number, person, case, index (= antecedent index) and down index (= anaphor index). Complex categories are built with / and \ and the constraints on feature uniin the usual way. The index features der occur on noun phrases and determiners. Here are some examples of complex categories (* marks the feature values that do not matter). • N(number) = S/E(number,*,*,*). • NP (number,person,case,uindex,dindex) = S/(E(numb er , p erson ,case,uindex,dindex) \ S) . • VP(number,person,*) = E(number,person,Nom,*,*) \S. • TV(number,person,tense) = VP(*,*,tense)/NP(*,*,Acc,*,*). • DET(number,uindex,dindex) = NP(number,Third,*,uindex,dindex)/ N (number) . • AUX(number,person) = VP(number,person,Tensed)/ VP (number ,person,Inf). • NEG = AUX(number,person)\AUX(number,person). Basic categories get assigned in the lexicon. For example: word Category John&apos; NP(Sg,Third,*,i,*) hei NP(Sg,Third,Nom,*,i) himi NP(Sg,Third,Acc,*,i) sees TV(Sg,Third,Tensed) ai DET(Sg,i,*) thei DET(*,i,*) another; DET(*,ij) j DET(*,i,j) his i man N(Sg) with (N(nr)\ N(nr))/NP(*,*,*,*,*) Some examples of complex category formation: a DET(Sg,i,*) • N(Sg) = NP(Sg,Third,*,i,*)/N(Sg) • N(Sg) = NP(Sg,Third,*,i,*). • sees a mani: TV(Sg, Third, Tensed) • NP(Sg,Third,*,*,*) = (VP(Sg,Third,Tensed)/ NP(Sg,Third,Acc,*,*,*)) -NP(Sg,Third,*,*,*) = VP(Sg,Third,Tensed). John&apos; sees a NP(Sg,Third,*,j,*) - VP(Sg,Third,Tensed) =-- (S/(E(Sg,Third,*,j,*)\S))- (E(Sg,Third,Nom,*,*)\S) =S. The translator The translator uses A-calculus to translate parse trees into DPL programs. We could have translated on the fly, building translations while parsing, but the present set-up seemed preferable for reasons of modularity of design. The translation algorithm makes use of a lexical function mapping pairs consisting of a lexical item with an associated category to A-expressions in the lexicon, along the lines of [9]. Translating a sentence into DPL boils down to lambda reduction of the lambda expression which results from combining the lambda expressions associated with the leaves of the parse tree, according to the rules of functional application dictated by the categorial structure. Here are some examples of lambda expressions associated with lexical items with categories. Note that we assume the presence of indices in the lexicon, so we can handle anaphoric links by co-indexing. For a proper understanding of the translation instructions one should bear in mind the distinction between DPL variables that are used for DPL assignment and lambda calculus variables. We use lower case for the first and upper case for the latter.</abstract>
<note confidence="0.961626176470588">Translation for man, N(Sg): AVI.man(14). for ,NP(Sg,Third,*,i,*): := for AVI.(AV2.(VIAV3.see(V2, V3))). Translation for is, TV(Sg,Third,Tensed): AVI.(AV2.(VIAV3.V2 = Vs)). Translation for a(ni, Det(Sg,i,*): AV1.(AV2.(tiv1 : Vi(vi); V2(vi))). for : 14(vi); for i (the anaphoric use of the): AV1.(AV2.ivi :(vi = vi; Vivi); V2(vi)). Translation for if, (S/S)/S: AVI,(AV2.V1 V2).</note>
<email confidence="0.209688">for</email>
<abstract confidence="0.945524045454545">AVI.Vi. 66 for for , : v vj; Vi(vi); V2(v1))). for °the? : (vi vj; Vi(vi)); V2(vi))). for for , : Vi(vi); (vi, vi); for N(nr))/NP(*,*,*,*,*): isof All these translations are typed, but we have left most of the typing discipline implicit. For example, the translations of noun phrases all are of the type of (dynamic) generalized quantifiers, which take a property to give a DPL program. The translation of proper names is a dynamic variation of the Montague treatment for proper names [8]. In extensional Montague grammar, proper names translate into expressions denoting the set of properties which are true of the named individual. Here, proper names translate into expressions that for every property give the DPL program which first assigns the name of the individual to the index variable of the proper name, and then tests for the property. This is like in Montague grammar, but with a dynamic touch added. Anaphoric links to the name remain possible by means of the index variable as long as its value remains unchanged. Other noun phrases with a dynamic flavour are indefinite and definite descriptions. Indefinite descriptions translate into expressions that for every property give the DPL program which does an indefinite assignment to an index variable and tests for the property. Definite descriptions are handled likewise, but with definite assignment instead of indefinite assignment. uses his pc?. As an example, we treat the translation of (25), which is obtained starting from the following parse tree: (N , J ohn) , (VP,</abstract>
<keyword confidence="0.358701666666667">(TV, uses), (NP?, (D ET? , his),</keyword>
<note confidence="0.945701636363637">(N , pc) The translation step by step: pc? : vi); V2(v2))(AVI AV 2 .tv2 : (AK .pc(K))(v2); is-of (v2, vi);V2(v2) AV2 .1v2 : pc(v2); is-of (v2, vi);V2(v2). uses his pc? , V3))) (AV2 .tv2 : pc(v2); is-of (v2, vi);V2(v2)) AV2.(AV2.(tv2 : pc(v2); is-of (v2, vi);V2(v2)) (AV3 .use(V2 , V3</note>
<abstract confidence="0.960182113207547">4 3V2 is-of (v2, 2 .tv2 : pc(v2); is-of (v2, vi); use(V2, uses his pc? : is-of v2) := J; (AV2 .tv2 : pc(v2); is-of (v2, vi); use (V2 v2))(vi) := J; tv2 : pc(v2); is-of use(vi, In the same way, (26) gets translated into (27). John&apos; is vi := tiv2 : vi = vz. Note that &apos;is&apos; is treated as in Montague grammar [8]. 5 Experiences with the Godel Implementation Language The declarative semantics of Godel improves on the semantics of Prolog: extra-logical predicates (such as assert, retract, !, .) avoided and sometimes replaced by declarative counterparts. Like Lambda Prolog [7], Giidel is a typed language: it is necessary to declare the type and domain of all functions and predicates (polymorphism is allowed, however). This convention makes program writing a bit more cumbersome. For example, we have to declare the type Program for representing a DPL program. For each DPL statement, it is necessary to define a function to build a Program (example: Piota : Variable * Program —k Program). We also have to declare a type Expression for A-expressions. Some complications arise from the fact that an expression may contain a DPL program and vice versa. On the plus side, more errors are detected during compilation, the compiler generates more efficient code, and the typing discipline makes for more legible, comprehensible programs. Last but not least, the typing discipline has obliged us to think a bit more about the clauses we were writing than we perhaps would have done otherwise. 67 Godel has facilities that permit elegant metaprogramming. In Prolog the program and the metaare not independent: the predicates asthe program itself in which these predicates occur. In Godel, program and metaprogram are completely independent. It is possible for a program to load another program, to modify this other program by inserting or retracting predicates, functions or types, and to demonstrate a goal. In our implementation we use these facilities to represent a model as a logic database and a precondition as a complex goal. 6 The Program Itself The main module takes a sentence or text as input and produces a report containing the sentence, the parse tree, the DPL program it gets translated into, and the preconditions. This module uses the following submodules: • the parser module which from a sentence, finds its category and builds its parse tree, • the translation module which from the parse tree, computes a representation of a DPL program, the precondition module which from a prothe preconditions (this module calls another module to simplify the resulting FOL formulas), • the evaluation module which performs a database evaluation. A lexicon module is called by the first two of these contains words, with their categories and the associated A-expressions. 6.1 Main module This module receives a sentence represented by a list and parses it, translates it, produces a report, computes preconditions and evaluates these in given 6.2 Output module how to output programs, excategories, trees, words, ... the of Godel for manipulating text 6.3 Lexicon lexicon defined by a predicate arguments: the word itself, a category and an appropriate lambda expression. 6.4 Parser The parser employs backtracking and unification in the usual way. Giidel (as all logic programming languages) has these features built in, which makes it very easy to implement a parser for a simple fragment like ours. The parsing of a sentence consists of three steps: • generate a list of categories corresponding to the sequence of words, • reduce the list of categories, • test if you have a sentence else retrace your steps and try again. use the type egor represent categories. It is defined by the constant S and the functions 4number,person,case,uindex,dinder), NP(numbenperson,case,uindex,dindex), N(number), and so on. The two infix functions / and \ serve to build new and more complex categories. Sentences are parsed by building a binary parse tree in bottom-up fashion. The binary parse trees are by a constant a function the empty tree and the function A gives the information at the current node, the left subtree, and the right subtree. The information content of the nodes is of two kinds: internal nodes carry the result of combining the categories of the subtrees and leaf nodes carry a pair consisting of a word and its category. The parse trees are built during the reduction of the list of categories, starting with a list of trees corresponding to the words of the sentence. When we reduce two adjacent categories, we replace the two trees T2 a single tree with T1 immediate subtrees. 6.5 Translator translator uses two types: Program and Expresfirst represents a DPL-program, the second a complex A-expression. We have left the rest of the typing of the lambda expressions implicit. The definition of programs and lambda expressions is a bit cumbersome, for a A-expression may contain a program and vice versa. This complication is refleeted in the rules for substitution and reduction. For example, it is necessary to define the substitution of an expression for a variable in a program, the free occurrence of a variable in a program, etc. The rules of reduction are a straightforward rendering of the rules of /3-reduction and 7-reduction in A calculus. We do not handle a reduction, as we see no need for variable renaming. The translation process employs the following predicates: Trad This predicate translates a parse tree into a reduced A-expression. Depending on the information at the current node of the parse tree, a lexical lookup of the translation takes place, or the translation is found by reducing the application of the translations of the left and right subtrees. Trans This predicate translates a list of parse trees for the sentences of a text into the corresponding 68 DPL program. It uses the predicate Trad to translate each sentence, and then links these translations by applications. Canred This predicates takes a .\-expression and reduces it using the declarative functional semantics of )-calculus. DPL to QDL We have seen that DPL programs are represented as G6del functions. The reduction of DPL to FOL by means of QDL gets implemented by defining reduction predicates corresponding to the QDL axiom schemata. These predicates call each other recursively. • FR(Rel(s, v)) is a relational atomic test. • •in) Fequal(tl, t2) an atomic test of equality of the terms ti and t2. (ti = t2) Fand(phil, phi2) the conjunction of two formulas. ((pi A co) For(phil, phi2) the disjunction of two formulas. ((pi V co2) Fimplic(phl, phi2) the implication of two —4 so2) Fall(V(i), phi) the expression (Vvicp) Fexist(V(i), phi) the expression (Jaw) Fonlyone(V(i), phi) the expression (3!vico) Fnot (phi) the negation of the formula Fprecexist(pi, phi) the expression ((7)6o) Fprecuniv(pi, phi) the expression Fpar(pi, phi) the expression A-44p). In the course of applying these predicates, formulas may get generated with obvious redundancies. We have defined a formula simplifier to remove some of these. This improves the readability of the output (the formulas are output in LaTeX format) and the performance of the database lookup on the basis of the conditions. There is the list of simplifications handled by the co A T • • wVT4—■T • yo V 1 4-4 (yo T) 1-4T (T • (fp I) 4-3. (j_ • —LI_ T —IT (3!vp A 3v9) 4-4 6.7 Evaluation The intermediate language QDL allows us to translate DPL programs into formulas of FOL. These are then evaluated in a database model, i.e., a first order model which is implemented as a GOdel database (a Godel program). There we have a so-called metaan object program the meta-program manipulates the object program. We translate first order conditions into Godel goals, and then apply the goal to the object Godel program, using the possibilities of metaprogramming offered by Godel. In ordinary Prolog, these things could also be done, but they would look much less elegant. Here is an example of a Gide&apos; model (the lines preceded by % are comment lines): MODULE Modell.</abstract>
<note confidence="0.829198724137931">IMPORT Strings, Sets. BASE Symbol. % We use this base for every kind of term. CONSTANT John, Bill, Freddy, Borsalino, Myclone: Symbol. PROPOSITION Top. PREDICATE Admire, Cheer, Isof, See, Use: Symbol * Symbol; Hat, Man, Adult, King, Pc, Manager: Symbol. % The relations defined in the model Admire(John,Bill). King(Bill). Isof(Borsalino,Bill). Hat(Borsalino). See(John,Bill). See(Bill,John). Manager(Bill). Man(John). Man(Bill). Man(Freddy). Adult(John). Adult (Bill). Pc(Myclone). Use(John,Myclone). Top. % Top must be defined in every model. 69 7 Conclusion The QDL translation discussed above only handles</note>
<abstract confidence="0.990059293103448">uniqueness presuppositions of definite descriptions. The method employed is general enough, however, to handle lots of other kinds of presupposition. Lexical presuppositions, for example, are handled in the error state semantics by a slight revision of the semantic clause for atomic tests. Being a bachelor presupposes being male and adult, so the test for bachelorhood should give error if it is performed on an entity that does not satisfy the test for being a male adult. the revision boils down to this. Let the set of atomic formulae of DPL. Assume a lexipresupposition function lp : —* DPL each atomic test predicate of the representation language to its associated lexical presupposition, conceived as a program of the representation language. For example, here are the lexical presuppositions for bachelorhood. = (male x; adult x). The semantic clause for atomic relations is modified to take the function lp into account: • • [1p(Rh - - • M 1=4 Rh • - • [1p(Rti - • • tn)]1m(A) ¢ {c} M • • tn, if [1p(Rh - • • tn)1m(A) This modified definition gives the success and failure of the relational test modulo the fact that the lexical presupposition of the relational test holds; if the presupposition does not hold then the test results in error. There is no need for any other changes in the rules, for the projection of lexical presupposition is taken care of by the general principles• of error percolation that are already implicit in the semantic clauses. Thus, the DPL error semantics gives us that (28) presupposes that Jan is male and adult, but that (29) only presupposes that Jan is adult. (28) Jan is a bachelor. (29) If Jan&apos; is male, then he, is a bachelor. The change in the semantic clause for atomic relations is reflected in the calculus by replacing the for • • by the following versions: (Rti • • • *4 • • A q, A (IP(Rti • • • [Rti • • • 4- • - -4 yo) A • • • In the implementation, lexical presupposition is hanby a predicate a modification of the reduction predicates for the relational test axiom schemata. Right now, we are extending the fragment to deal with other kinds of presupposition failure, in particular failure of presupposition of aspectual verbs such References [1] J. Barwise. Noun phrases, generalized quantifiers and anaphora. In P. Gardenfors, editor,</abstract>
<note confidence="0.715544435897436">Generalized Quantifiers: linguistic and logical 1-30. D. Reidel Publishing Company, Dordrecht, 1987. J. van Eijck. The dynamics of description. Jourof Semantics, 1993. to appear. [3] J. van Eijck. Presupposition failure — a comedy of errors. Manuscript, CWI, Amsterdam, 1993. [4] J. van Eijck and F .J. de Vries. Dynamic inand Hoare deduction. of Language, and Information, 1992. [5] J. Groenendijk and M. Stokhof. Dynamic predlogic. and Philosophy, 14:39- 100, 1991. [6] P.M. Hill and J.W. Lloyd. The Godel report. Technical report, Department of Computer Science, University of Bristol, Bristol, 1991 (revised 1992). [7] D.A. Miller. A logic programming language with lambda abstraction, function variables and simple unification. In P. Schroeder-Heister, ediof Logic Programming. 1990. [8] R. Montague. The proper treatment of quantification in ordinary english. In J. Hintikka e.a., to Natural Language, 221-242. Reidel, 1973. [9] R. Muskens. Anaphora and the logic of change. J. van Eijck, editor, in Al / European Workshop JELIA &apos;90 / Amsterdam, The Netherlands, September 1990 / Proceed- Notes in Artificial Intelligence 478, pages 412-427. Springer Verlag, 1991. [10] R. Muskens. Tense and the logic of change. Manuscript, University of Tilburg, 1992. [11] V. Pratt. Semantical considerations on Floydlogic. 17th IEEE Symposium Foundations of Computer Science, 109-121, 1976. 70</note>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="false">
<authors>
<author>IMPORT Strings</author>
<author>Sets BASE Symbol</author>
</authors>
<title>We use this base for every kind of term.</title>
<journal>Symbol. % The relations defined in the model Admire(John,Bill). King(Bill). Isof(Borsalino,Bill). Hat(Borsalino). See(John,Bill). See(Bill,John). Manager(Bill). Man(John). Man(Bill). Man(Freddy). Adult(John). Adult (Bill). Pc(Myclone). Use(John,Myclone). Top. % Top</journal>
<booktitle>Symbol. PROPOSITION Top. PREDICATE Admire, Cheer, Isof, See, Use: Symbol * Symbol; Hat,</booktitle>
<publisher>CONSTANT John,</publisher>
<location>Bill, Freddy, Borsalino, Myclone:</location>
<note>must be defined in every model.</note>
<marker>Strings, Symbol, </marker>
<rawString> MODULE Modell. IMPORT Strings, Sets. BASE Symbol. % We use this base for every kind of term. CONSTANT John, Bill, Freddy, Borsalino, Myclone: Symbol. PROPOSITION Top. PREDICATE Admire, Cheer, Isof, See, Use: Symbol * Symbol; Hat, Man, Adult, King, Pc, Manager: Symbol. % The relations defined in the model Admire(John,Bill). King(Bill). Isof(Borsalino,Bill). Hat(Borsalino). See(John,Bill). See(Bill,John). Manager(Bill). Man(John). Man(Bill). Man(Freddy). Adult(John). Adult (Bill). Pc(Myclone). Use(John,Myclone). Top. % Top must be defined in every model.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Barwise</author>
</authors>
<title>Noun phrases, generalized quantifiers and anaphora.</title>
<date>1987</date>
<booktitle>Generalized Quantifiers: linguistic and logical approaches,</booktitle>
<pages>1--30</pages>
<editor>In P. Gardenfors, editor,</editor>
<publisher>Publishing Company,</publisher>
<location>Dordrecht,</location>
<contexts>
<context position="10089" citStr="[1]" startWordPosition="1697" endWordPosition="1697">&amp;quot;see&amp;quot;, and so on. Thus, (1) is a DPL program. (1) (71v2: man(v2); see(v2, v4))• We will omit outermost brackets and brackets in sequential compositions like ((in; 7 2);r3). This is harmless, for sequential composition is associative. Also, we will abbreviate qv : v = t as v := t. This abbreviation is natural, as the sequential composition of random assignment to v and test for equality with t boils down to assigning the value of t to v. 2.3 Indices for Antecedents and Anaphors In the natural language fragment we treat, we use co-indexing to indicate intended anaphoric links. We follow Barwise [1] in using superscripts for antecedents and subscripts for anaphors. (2) A man walked in. He smiled. If we intend the pronoun in (2) to refer to the subject of the first sentence, we indicate this intention as follows. (3) A man&apos; walked in. Hei The superscript on the indefinite noun phrase indicates that this NP acts as an antecedent for NPs with the same index as a subscript. The subscript on the pronoun indicates the antecedent to which the pronoun is linked. The use of subscripts and superscripts is necessary because noun phrases can act as anaphors and antecedents at the same time. (4) A ma</context>
</contexts>
<marker>[1]</marker>
<rawString>J. Barwise. Noun phrases, generalized quantifiers and anaphora. In P. Gardenfors, editor, Generalized Quantifiers: linguistic and logical approaches, pages 1-30. D. Reidel Publishing Company, Dordrecht, 1987.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J van Eijck</author>
</authors>
<title>The dynamics of description.</title>
<date>1993</date>
<journal>Journal of Semantics,</journal>
<volume>10</volume>
<note>to appear.</note>
<contexts>
<context position="2470" citStr="[2]" startWordPosition="393" endWordPosition="393">osed off at the end of a sentence, as used to be the case for NL systems that employ static representation (in terms of the existential quantifiers of predicate logic, with their irritating closing brackets). Abstract The strategy for natural language interpretation presented in this paper implements the dynamics of context change by translating natural language texts into a meaning representation language consisting of (descriptions of) programs, in the spirit of dynamic predicate logic (DPL) [5]. The difference with DPL is that the usual DPL semantics is replaced by an error state semantics [2]. This allows for the treatment of unbound anaphors, as in DPL, but also of presuppositions and presupposition projection. The use of this dynamic interpretation strategy is demonstrated in an implementation of a small fragment of natural language which handles unbound pronoun antecedent links, where it is assumed that the intended links are indicated in the input string, and uniqueness presuppositions of definite descriptions. The implementation consists of a syntax module which outputs parse trees, a semantic module mapping parse trees to DPL representations, a representation processor which</context>
<context position="3686" citStr="[3; 2]" startWordPosition="577" endWordPosition="578">s truth conditions, falsity conditions and presupposition failure conditions, and an evaluator of these conditions in a database model. The implementation uses the logic programming language Godel [6], an experimental successor of Prolog, with similar functionality and expressiveness, but with an improved declarative semantics. 61 Recently, it has become clear that dynamic representation has some other interesting features: • It becomes possible to give an account of presupposition failure phenomena in terms of the definition of an error state semantics for the dynamic representation language [3; 2]. Presupposition failure occurs for example if one tries to interpret &amp;quot;John&apos;s wife is unhappy&amp;quot; in a situation where John is not married. • A more natural treatment of tense becomes possible. A sequence of sentences in the past tense like &amp;quot;A man walked in. He sat down. He ordered a drink&amp;quot; etc, is represented using subsequent assignments of values (time intervals) to a dedicated time register t [10]. The dynamic representation language can be analysed with tools that were originally designed for analysing imperative programming languages, namely the tools for precondition reasoning from Hoare lo</context>
<context position="16597" citStr="[2]" startWordPosition="2886" endWordPosition="2886">tnIIA4(A) = f {A} if (VAA,A(ti),..., VM,A(t.)) E 1(R) 1 0 otherwise. 3. It1 = t2)I4(A) = r {A} if Vm,A(ii) = Vm,A(t2) 1 0 otherwise. 4. I(ri; x2)1m(A) = UfirAm(B) I B E Prilm(A)}. 5. [(vi x2)]A4(A) = / 0 otherwise. (c) if there is a state B E Film(A) {A} if for all B E[rjm(A) withirAm(B) = {c} it holds thatfr21m(B) ¢ (c) 6. [(-Am(A) = 0 otherwise. {c} if [x]Im(A) = {c} / NM(A) if m(A) = 0 7. P.m : rim(A)= U{Prim(A[x := d]) I d E M). 8. [ix: allm(A) = 1[111A,f(A[x := d]) for the unique d with 1 frim(A[r := di) g {e) if d exists {e} otherwise. More information on this definition can be found in [2]. For present purposes it is sufficient to note that a DPL program can execute in three different ways, when acting on a given input state: 1. The program reports success by producing at least one proper output state. For example, the program man (vi) when acting on an input state where v1 refers to John will succeed and return the input state as its only output state. 2. The program reports failure by not producing any output at all. For example, the program nvi : woman(vi) will fail for any input state (except e) if there are no women in the model under consideration (its output state set wi</context>
</contexts>
<marker>[2]</marker>
<rawString>J. van Eijck. The dynamics of description. Journal of Semantics, 10, 1993. to appear.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J van Eijck</author>
</authors>
<title>Presupposition failure — a comedy of errors.</title>
<date>1993</date>
<location>Manuscript, CWI, Amsterdam,</location>
<contexts>
<context position="3686" citStr="[3; 2]" startWordPosition="577" endWordPosition="578">s truth conditions, falsity conditions and presupposition failure conditions, and an evaluator of these conditions in a database model. The implementation uses the logic programming language Godel [6], an experimental successor of Prolog, with similar functionality and expressiveness, but with an improved declarative semantics. 61 Recently, it has become clear that dynamic representation has some other interesting features: • It becomes possible to give an account of presupposition failure phenomena in terms of the definition of an error state semantics for the dynamic representation language [3; 2]. Presupposition failure occurs for example if one tries to interpret &amp;quot;John&apos;s wife is unhappy&amp;quot; in a situation where John is not married. • A more natural treatment of tense becomes possible. A sequence of sentences in the past tense like &amp;quot;A man walked in. He sat down. He ordered a drink&amp;quot; etc, is represented using subsequent assignments of values (time intervals) to a dedicated time register t [10]. The dynamic representation language can be analysed with tools that were originally designed for analysing imperative programming languages, namely the tools for precondition reasoning from Hoare lo</context>
</contexts>
<marker>[3]</marker>
<rawString>J. van Eijck. Presupposition failure — a comedy of errors. Manuscript, CWI, Amsterdam, 1993.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J van Eijck</author>
<author>F J de Vries</author>
</authors>
<title>Dynamic interpretation and Hoare deduction.</title>
<date>1992</date>
<journal>Journal of Logic, Language, and Information,</journal>
<pages>1--1</pages>
<contexts>
<context position="4409" citStr="[4]" startWordPosition="697" endWordPosition="697"> is not married. • A more natural treatment of tense becomes possible. A sequence of sentences in the past tense like &amp;quot;A man walked in. He sat down. He ordered a drink&amp;quot; etc, is represented using subsequent assignments of values (time intervals) to a dedicated time register t [10]. The dynamic representation language can be analysed with tools that were originally designed for analysing imperative programming languages, namely the tools for precondition reasoning from Hoare logic or dynamic logic [11]. Precondition reasoning for dynamic predicate logic with standard semantics was introduced in [4]. Precondition reasoning gives the truth conditions of DPL representations in the form of formulas of first order logic (FOL). When applied to the error state semantics of DPL, precondition reasoning can also be used to find the presupposition failure conditions of DPL representations as FOL formulas. We provide an integrated treatment of syntax and semantics of a small fragment of natural language and test this by implementing it. The syntax of our toy grammar is a version of categorial grammar with feature unification. The semantics uses DPL representations, with an error state semantics whi</context>
</contexts>
<marker>[4]</marker>
<rawString>J. van Eijck and F .J. de Vries. Dynamic interpretation and Hoare deduction. Journal of Logic, Language, and Information, 1:1-44, 1992.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Groenendijk</author>
<author>M Stokhof</author>
</authors>
<title>Dynamic predicate logic.</title>
<date>1991</date>
<journal>Linguistics and Philosophy,</journal>
<pages>14--39</pages>
<contexts>
<context position="2369" citStr="[5]" startWordPosition="373" endWordPosition="373">ut the treatment in terms of assignment is that the scope of the existential quantification is not closed off at the end of a sentence, as used to be the case for NL systems that employ static representation (in terms of the existential quantifiers of predicate logic, with their irritating closing brackets). Abstract The strategy for natural language interpretation presented in this paper implements the dynamics of context change by translating natural language texts into a meaning representation language consisting of (descriptions of) programs, in the spirit of dynamic predicate logic (DPL) [5]. The difference with DPL is that the usual DPL semantics is replaced by an error state semantics [2]. This allows for the treatment of unbound anaphors, as in DPL, but also of presuppositions and presupposition projection. The use of this dynamic interpretation strategy is demonstrated in an implementation of a small fragment of natural language which handles unbound pronoun antecedent links, where it is assumed that the intended links are indicated in the input string, and uniqueness presuppositions of definite descriptions. The implementation consists of a syntax module which outputs parse </context>
</contexts>
<marker>[5]</marker>
<rawString>J. Groenendijk and M. Stokhof. Dynamic predicate logic. Linguistics and Philosophy, 14:39-100, 1991.</rawString>
</citation>
<citation valid="true">
<authors>
<author>P M Hill</author>
<author>J W Lloyd</author>
</authors>
<title>The Godel report.</title>
<date>1991</date>
<tech>Technical report,</tech>
<institution>Department of Computer Science, University of Bristol,</institution>
<location>Bristol,</location>
<contexts>
<context position="3280" citStr="[6]" startWordPosition="515" endWordPosition="515"> of a small fragment of natural language which handles unbound pronoun antecedent links, where it is assumed that the intended links are indicated in the input string, and uniqueness presuppositions of definite descriptions. The implementation consists of a syntax module which outputs parse trees, a semantic module mapping parse trees to DPL representations, a representation processor which determines truth conditions, falsity conditions and presupposition failure conditions, and an evaluator of these conditions in a database model. The implementation uses the logic programming language Godel [6], an experimental successor of Prolog, with similar functionality and expressiveness, but with an improved declarative semantics. 61 Recently, it has become clear that dynamic representation has some other interesting features: • It becomes possible to give an account of presupposition failure phenomena in terms of the definition of an error state semantics for the dynamic representation language [3; 2]. Presupposition failure occurs for example if one tries to interpret &amp;quot;John&apos;s wife is unhappy&amp;quot; in a situation where John is not married. • A more natural treatment of tense becomes possible. A s</context>
</contexts>
<marker>[6]</marker>
<rawString>P.M. Hill and J.W. Lloyd. The Godel report. Technical report, Department of Computer Science, University of Bristol, Bristol, 1991 (revised 1992).</rawString>
</citation>
<citation valid="true">
<authors>
<author>D A Miller</author>
</authors>
<title>A logic programming language with lambda abstraction, function variables and simple unification.</title>
<date>1990</date>
<booktitle>Extensions of Logic Programming.</booktitle>
<editor>In P. Schroeder-Heister, editor,</editor>
<publisher>Springer,</publisher>
<contexts>
<context position="17863" citStr="[7]" startWordPosition="3133" endWordPosition="3133">s only output. For example, the program Lv1 manager(vi) will produce e for any input state if the model under consideration does not have a unique manager. 64 3 Preconditions of DPL programs Above, we have referred to DPL formulas as programs. We are now going to use tools for programming language analysis on DPL. We will use quantified dynamic logic over DPL to describe the preconditions for success, failure and error of DPL programs. QDL terms t ::= c I v, QDL programs r ::= t = t I Rt—t (7r;7r) (r r) (-,7r) I ?iv : tv : r, QDL formulas w ::=t = t I Rt • • •t (So A 50) I -&amp;quot;Ca 3vio I (7)S0 I [7]ç0- Note that the QDL programs are precisely the DPL programs. An atomic relation Rti, • • • ,t„ can occur inside a QDL program or as an atomic QDL formula, so we need to distinguish the programs of QDL from the static QDL relations. We use boldface for the test program Rt, • • -4, and italics for the formula Rti • -tn. We omit outermost parentheses as usual, and use T for a formula which is always true, 1 for a formula which is always false. The semantics of QDL is as for first order logic, with the following clauses for the program modalities added (assume A 0 c): • M kA (w)co if there is so</context>
<context position="19084" citStr="[7]" startWordPosition="3388" endWordPosition="3388">m(A), B c and M B So. • M kA [7r]ço if for all B E 1[21m(A) it holds that B c and M kEs Note that (7r) and [71-] are not duals. (7r)T expresses the conditions for success of r, [7r].1 the conditions for failure of r. It follows that --.(7r)T A --[71-]1 expresses the conditions for error. The following axiom schemata can be used to compute these conditions as formulas of FOL. 1. (Rt, • • • t,i)co 4-4 (Rti • • t,, A co). 2. [Rt, • • • t„]co (Rti • • • tr, yo). 3. (t, = ta)cp (ti = t2 A co). 4. [t, = t,lio (ti = 12 -+ co). 5. (71; 72)So (70 (7r2)so• 6. fir1;7r2b1 4-4 [71][112)9- 7. (-17)51 (S0 A [7]-1-). 8. [-mica 4-4 ((i1-)T V (co A [7r]..L)). 9. (IT. 1r2)40 4-4 (so A [7rj(7r2)T). 10. [7r1 7r2)4,0 4-4 (([71]((72)T V [71-2].1)) A ([71](10T 41)). 11. (riv : w)y, 3v(71-)v. 12. [riv : who Vv[ir]v. 13. (tv : 7r)co (3!v(71-)T A 3v(ir)co). 14. [tv : 7r]o 4-4 (3!v(7r)T A Vv((ir)T MO). The most interesting item of this list is the universal schema for i assignment (item 14). To see what it means, note that [ir]T expresses that all output states of r are proper. The schema states that the following are equivalent: • For proper input state A, the program iv r does only have proper output states, a</context>
<context position="28209" citStr="[7]" startWordPosition="4836" endWordPosition="4836">AV2.tv2 : pc(v2); is-of (v2, vi.); use(V2, v2) := J; (AV2 .tv2 : pc(v2); is-of (v2, vi); use (V2 v2))(vi) V1 := J; tv2 : pc(v2); is-of (v2, vi); use(vi, v2)• In the same way, (26) gets translated into (27). (26) John&apos; is a man2. (27) vi := J; tiv2 : man(v2); vi = vz. Note that &apos;is&apos; is treated as in Montague grammar [8]. 5 Experiences with the Godel Implementation Language The declarative semantics of Godel improves on the semantics of Prolog: extra-logical predicates (such as var, nonvar, assert, retract, !, .) are avoided and sometimes replaced by declarative counterparts. Like Lambda Prolog [7], Giidel is a typed language: it is necessary to declare the type and domain of all functions and predicates (polymorphism is allowed, however). This convention makes program writing a bit more cumbersome. For example, we have to declare the type Program for representing a DPL program. For each DPL statement, it is necessary to define a function to build a Program (example: Piota : Variable * Program —k Program). We also have to declare a type Expression for A-expressions. Some complications arise from the fact that an expression may contain a DPL program and vice versa. On the plus side, more</context>
</contexts>
<marker>[7]</marker>
<rawString>D.A. Miller. A logic programming language with lambda abstraction, function variables and simple unification. In P. Schroeder-Heister, editor, Extensions of Logic Programming. Springer, 1990.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Montague</author>
</authors>
<title>The proper treatment of quantification in ordinary english.</title>
<date>1973</date>
<booktitle>Approaches to Natural Language,</booktitle>
<pages>221--242</pages>
<editor>In J. Hintikka e.a., editor,</editor>
<location>Reidel,</location>
<contexts>
<context position="26008" citStr="[8]" startWordPosition="4468" endWordPosition="4468">.(AV2.(cvi : (vi vj; Vi(vi)); V2(vi))). Translation for hei, NP(Sg,Third,Nom,*,i): Translation for his, , DET(*,i,j): .(AV2.tvi : Vi(vi); iso! (vi, vi); V2(v1)). Translation for with, (N(nr)\ N(nr))/NP(*,*,*,*,*): AV1.(AV2.(AV3.(V2(V3); Vi(AV4 isof (V4, V3)))). All these translations are typed, but we have left most of the typing discipline implicit. For example, the translations of noun phrases all are of the type of (dynamic) generalized quantifiers, which take a property to give a DPL program. The translation of proper names is a dynamic variation of the Montague treatment for proper names [8]. In extensional Montague grammar, proper names translate into expressions denoting the set of properties which are true of the named individual. Here, proper names translate into expressions that for every property give the DPL program which first assigns the name of the individual to the index variable of the proper name, and then tests for the property. This is like in Montague grammar, but with a dynamic touch added. Anaphoric links to the name remain possible by means of the index variable as long as its value remains unchanged. Other noun phrases with a dynamic flavour are indefinite and</context>
<context position="27926" citStr="[8]" startWordPosition="4796" endWordPosition="4796">VI.(AV2.14(AV3. use(V2 , V3))) (AV2 .tv2 : pc(v2); is-of (v2, vi);V2(v2)) AV2.(AV2.(tv2 : pc(v2); is-of (v2, vi);V2(v2)) (AV3 .use(V2 , V3)) -4 0172 3V2 pc(v2); is-of (v2, vi);(.XV3.use(V2,113))(v2)) AV 2 .tv2 : pc(v2); is-of (v2, vi); use(V2, v2)• Johnl uses his pc? := J;(iii(vi)) AV2.tv2 : pc(v2); is-of (v2, vi.); use(V2, v2) := J; (AV2 .tv2 : pc(v2); is-of (v2, vi); use (V2 v2))(vi) V1 := J; tv2 : pc(v2); is-of (v2, vi); use(vi, v2)• In the same way, (26) gets translated into (27). (26) John&apos; is a man2. (27) vi := J; tiv2 : man(v2); vi = vz. Note that &apos;is&apos; is treated as in Montague grammar [8]. 5 Experiences with the Godel Implementation Language The declarative semantics of Godel improves on the semantics of Prolog: extra-logical predicates (such as var, nonvar, assert, retract, !, .) are avoided and sometimes replaced by declarative counterparts. Like Lambda Prolog [7], Giidel is a typed language: it is necessary to declare the type and domain of all functions and predicates (polymorphism is allowed, however). This convention makes program writing a bit more cumbersome. For example, we have to declare the type Program for representing a DPL program. For each DPL statement, it is </context>
</contexts>
<marker>[8]</marker>
<rawString>R. Montague. The proper treatment of quantification in ordinary english. In J. Hintikka e.a., editor, Approaches to Natural Language, pages 221-242. Reidel, 1973.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Muskens</author>
</authors>
<title>Anaphora and the logic of change.</title>
<date>1990</date>
<booktitle>Logics in Al / European Workshop JELIA &apos;90 /</booktitle>
<pages>412--427</pages>
<editor>In J. van Eijck, editor,</editor>
<publisher>Springer Verlag,</publisher>
<location>Amsterdam, The Netherlands,</location>
<contexts>
<context position="23929" citStr="[9]" startWordPosition="4168" endWordPosition="4168">,Acc,*,*,*)) -NP(Sg,Third,*,*,*) = VP(Sg,Third,Tensed). • John&apos; sees a mani: NP(Sg,Third,*,j,*) - VP(Sg,Third,Tensed) =-- (S/(E(Sg,Third,*,j,*)\S))- (E(Sg,Third,Nom,*,*)\S) =S. The translator The translator uses A-calculus to translate parse trees into DPL programs. We could have translated on the fly, building translations while parsing, but the present set-up seemed preferable for reasons of modularity of design. The translation algorithm makes use of a lexical function mapping pairs consisting of a lexical item with an associated category to A-expressions in the lexicon, along the lines of [9]. Translating a sentence into DPL boils down to lambda reduction of the lambda expression which results from combining the lambda expressions associated with the leaves of the parse tree, according to the rules of functional application dictated by the categorial structure. Here are some examples of lambda expressions associated with lexical items with categories. Note that we assume the presence of indices in the lexicon, so we can handle anaphoric links by co-indexing. For a proper understanding of the translation instructions one should bear in mind the distinction between DPL variables tha</context>
</contexts>
<marker>[9]</marker>
<rawString>R. Muskens. Anaphora and the logic of change. In J. van Eijck, editor, Logics in Al / European Workshop JELIA &apos;90 / Amsterdam, The Netherlands, September 1990 / Proceedings, Lecture Notes in Artificial Intelligence 478, pages 412-427. Springer Verlag, 1991.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Muskens</author>
</authors>
<title>Tense and the logic of change.</title>
<date>1992</date>
<tech>Manuscript,</tech>
<institution>University of Tilburg,</institution>
<contexts>
<context position="4086" citStr="[10]" startWordPosition="650" endWordPosition="650">her interesting features: • It becomes possible to give an account of presupposition failure phenomena in terms of the definition of an error state semantics for the dynamic representation language [3; 2]. Presupposition failure occurs for example if one tries to interpret &amp;quot;John&apos;s wife is unhappy&amp;quot; in a situation where John is not married. • A more natural treatment of tense becomes possible. A sequence of sentences in the past tense like &amp;quot;A man walked in. He sat down. He ordered a drink&amp;quot; etc, is represented using subsequent assignments of values (time intervals) to a dedicated time register t [10]. The dynamic representation language can be analysed with tools that were originally designed for analysing imperative programming languages, namely the tools for precondition reasoning from Hoare logic or dynamic logic [11]. Precondition reasoning for dynamic predicate logic with standard semantics was introduced in [4]. Precondition reasoning gives the truth conditions of DPL representations in the form of formulas of first order logic (FOL). When applied to the error state semantics of DPL, precondition reasoning can also be used to find the presupposition failure conditions of DPL represe</context>
</contexts>
<marker>[10]</marker>
<rawString>R. Muskens. Tense and the logic of change. Manuscript, University of Tilburg, 1992.</rawString>
</citation>
<citation valid="true">
<authors>
<author>V Pratt</author>
</authors>
<title>Semantical considerations on FloydHoare logic.</title>
<date>1976</date>
<booktitle>Proceedings 17th IEEE Symposium on Foundations of Computer Science,</booktitle>
<pages>109--121</pages>
<contexts>
<context position="4311" citStr="[11]" startWordPosition="682" endWordPosition="682">ure occurs for example if one tries to interpret &amp;quot;John&apos;s wife is unhappy&amp;quot; in a situation where John is not married. • A more natural treatment of tense becomes possible. A sequence of sentences in the past tense like &amp;quot;A man walked in. He sat down. He ordered a drink&amp;quot; etc, is represented using subsequent assignments of values (time intervals) to a dedicated time register t [10]. The dynamic representation language can be analysed with tools that were originally designed for analysing imperative programming languages, namely the tools for precondition reasoning from Hoare logic or dynamic logic [11]. Precondition reasoning for dynamic predicate logic with standard semantics was introduced in [4]. Precondition reasoning gives the truth conditions of DPL representations in the form of formulas of first order logic (FOL). When applied to the error state semantics of DPL, precondition reasoning can also be used to find the presupposition failure conditions of DPL representations as FOL formulas. We provide an integrated treatment of syntax and semantics of a small fragment of natural language and test this by implementing it. The syntax of our toy grammar is a version of categorial grammar w</context>
</contexts>
<marker>[11]</marker>
<rawString>V. Pratt. Semantical considerations on FloydHoare logic. Proceedings 17th IEEE Symposium on Foundations of Computer Science, pages 109-121, 1976.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>