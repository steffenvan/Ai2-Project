<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<title confidence="0.788205">
JPSG Parser on Constraint Logic Programming
</title>
<author confidence="0.860007">
TUDA, Hirosi *
</author>
<affiliation confidence="0.997134666666667">
Department of information science
Faculty of science
University of Tokyo 7-3-1 Hongo, Bunkyo-ku Tokyo, 113 Japan
</affiliation>
<email confidence="0.989476">
e-mail: a30728%tansei.cc.u-tokyo.junet@relay.cs.net
</email>
<author confidence="0.573295">
HASIDA, Koiti
</author>
<affiliation confidence="0.824084">
Institute for New Generation Computer Technology (ICOT)
</affiliation>
<address confidence="0.794899">
1-4-28 Mita, Minato-ku Tokyo, 108 Japan
</address>
<email confidence="0.991649">
e-mail: hasida@icot.jp@relay.cs.net
</email>
<author confidence="0.51502">
SIRAI, Hidetosi
</author>
<affiliation confidence="0.982729">
Tamagawa University
</affiliation>
<address confidence="0.883655">
6-1-1 Tamagawa gakuen, Machida-shi Tokyo, 194 Japan
</address>
<email confidence="0.999329">
e-mail: a88868%tansei.cc.u-tokyo.junet@re1ay.cs.net
</email>
<sectionHeader confidence="0.993114" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999907">
This paper presents a constraint logic programming
language cu-Prolog and introduces a simple Japanese
parser based on Japanese Phrase Structure Grammar
(JPSG) as a suitable application of cu-Prolog.
cu-Prolog adopts constraint unification instead of
the normal Prolog unification. In cu-Prolog, con-
straints in terms of user defined predicates can be
directly added to the program clauses. Such a clause
is called Constraint Added Horn Clause (CAHC).
Unlike conventional CLP systems, cu-Prolog deals
with constraints about symbolic or combinatorial ob-
jects. For natural language processing, such con-
straints are more important than those on numeri-
cal or boolean objects. In comparison with normal
Prolog, cu-Prolog has more descriptive power, and is
more declarative. It enables a natural implementa-
tion of JPSG and other unification based grammar
formalisms.
</bodyText>
<note confidence="0.584578">
From this April, Fujitsu Corporation
</note>
<sectionHeader confidence="0.997033" genericHeader="introduction">
1 Introduction
</sectionHeader>
<bodyText confidence="0.985832111111111">
Prolog is frequently used in implementing natural
language parsers or generators based on unification
based grammars. This is because Prolog is also
based on unification, and therefore has a declarative
feature. One important characteristic of unification
based grammar is also a declarative grammar formal-
ization [11].
However, Prolog does not have sufficient power of
expressing constraints because it executes every parts
of its programs as procedures and because every vari-
able of Prolog can be instantiated with any objects.
Hence, the constraints in unification based grammar
are forced to be implemented not declaratively but
procedurally.
We developed a new constraint logic programming
language cu-Prolog which is free from this defect of
traditional Prolog [13]. In cu-Prolog, user defined
constraints can be directly added to a program clause
(constraint added Horn clause), and the constraint
unification [12, 8] 1 is adopted instead of the nor-
lln these earlier papers, &amp;quot;constraint unification&amp;quot; was called
&amp;quot;conditioned unification.&amp;quot;
- 95 -
mal unification. This paper discusses the outline of
the cu-Prolog system, and presents a Japanese parser
based on JPSG (Japanese Phrase Structure Gram-
mar) [7] as a suitable application of cu-Prolog.
</bodyText>
<sectionHeader confidence="0.7037155" genericHeader="method">
2 Constraint Added Horn
Clause (CAHC)
</sectionHeader>
<bodyText confidence="0.992327">
Most of the constraint logic programming language
systems (CAL [2], PrologIII [5], etc.) deal with con-
straints about algebraic equations, i.e., constraints
about numerical domains, such as that of real num-
bers etc.
However, in the problems arising in Artificial In-
telligence, constraints on symbolic or combinatorial
objects are far more important than those on nu-
merical objects. cu-Prolog handles constraints de-
scribed in terms of sequence of atomic formulas of
Prolog. The program clauses of cu-Prolog are fol-
lowing type, which we call Constraint Added Horn
Clauses (CAHCs):
</bodyText>
<equation confidence="0.7457485">
1. H
(H is called the head, B1, B2, Bn is the
</equation>
<bodyText confidence="0.903094333333333">
body, Ci,C2, ,Cm is the constraint. The
body and the constraint can be empty.)
C1, C2, , Cm comprise a set of constraints on
the variables occurring in the rest of the clause.
C1, C2, ,Cm must be, in the current implementa-
tion, modular in the sense that it has the following
canonical form.
[Def.] 1 (modular) A sequence of atomic formulas
Ci,C2,...,Cm is modular when
</bodyText>
<listItem confidence="0.902427">
1. every arguments of Ci is variable, and
2. no variable occurs in two distinct places, and
3. the predicate of C1 is modularly defined (1 &lt; i&lt;
m).
</listItem>
<equation confidence="0.6718156">
[Def.] 2 (modularly defined) Predicate p is mod-
ularly defined, when in every definition clause of p,
P&apos; : —D.,
D is empty,
Or
</equation>
<listItem confidence="0.9676">
1. every argument of D is variable,
2. no variable occurs in two distinct space, and
3. every predicate occurring in D is p or modularl?
defined.
</listItem>
<equation confidence="0.914824">
For example,
member(X ,Y), member(U , V) is modular,
member(X ,Y), member(Y, Z) is not modu-
lar, and
append(X , Y, [a, b, c, (1) is not modular.
</equation>
<bodyText confidence="0.944281666666667">
Seen from the declarative semantics, the progran
clause of cu-Prolog is equivalent to the following pro
gram clause of Prolog:
</bodyText>
<listItem confidence="0.693431">
1. H — H2, • •
</listItem>
<sectionHeader confidence="0.924471" genericHeader="method">
3 cu-Prolog
</sectionHeader>
<subsectionHeader confidence="0.999852">
3.1 Constraint Unification
</subsectionHeader>
<bodyText confidence="0.9910748125">
cu-Prolog employs Constraint Unification [12, E
which is the usual Prolog unification plus constrain
transformation (normalization).
Using constraint unification, the inference rule c
cu-Prolog is as follows:
Q,R;C. , Q&apos; :—S;D.,
= mgu(Q ,Q1), B = m f (C0 , DO)
SO, RO; B
(Q is an atomic formula. R, C, S, D,
and B are sequences of atomic formulas.
mgu(Q,Q&apos;) is a most general unifier be-
tween Q and Q&apos;.)
mf (Ci , , Cm) is a modular constraint which
equivalent to C1, , Cm. If C1, , Cm is inconsil
tent, mf(Ci, , Cm) is not defined. In this case, th
above inference rule is inapplicable.
</bodyText>
<equation confidence="0.3867685">
- 96 -
For example,
</equation>
<construct confidence="0.7713414">
mf (member(X, [a, b, member(X , [6, c, d]))
returns a new constraint cO(X), where the definition
of c0 is
c0(b).
c0(c).
</construct>
<bodyText confidence="0.6714704">
and
mf (member(X ,[a, 1 c]), member(X , [k, I, m]))
is not undefined.
This transformation is done by repeating un-
fold/fold transformations as described later.
</bodyText>
<subsectionHeader confidence="0.992624">
3.2 Comparison with conventional ap-
proaches
</subsectionHeader>
<bodyText confidence="0.92577052173913">
In normal Prolog, constraints are inserted in a goal
and processed as procedures. It is not desirable for a
declarative programming language, and the execution
can be ineffective when constraints are inserted in a
insufficient place.
As constraints are rewritten at every unification,
cu-Prolog has more powerful descriptive ability than
the bind-hook technique. For example, freeze in Pro-
log II[4] can impose constraints on one variable, so
that when the variable is instantiated, the constraints
are executed as a procedure. Freeze has, however,
two disadvantages. First, freeze cannot impose a con-
straint on plural variables at one time. For example,
it cannot express the following CAHC.
1(X), g(Y, Z); append(X,Y, Z).
Second, since the contradiction between constraints is
not detected until the variable is instantiated, there
is a possibility of executing useless computation in
constraints deadlocking. For example, X and Y are
unifiable even after executing
f ree ze(X , member(X , [a, b]))
and
free ze(Y , member(Y, [u, v]))
</bodyText>
<equation confidence="0.587377">
In cu-Prolog,
f (X); member(X ,[a,b]).2
</equation>
<bodyText confidence="0.696186">
and
f (Y);member(Y, [u, v]).
are not unifiable.
</bodyText>
<subsectionHeader confidence="0.998433">
3.3 Constraint Transformation
</subsectionHeader>
<bodyText confidence="0.99344">
This subsection explains the mechanism of constraint
transformation in cu-Prolog.
</bodyText>
<equation confidence="0.356835125">
Let T be definition clauses of modularly defined
constraints, E be a set of constraints {C1, , Cn}
that contains variables xl, , x,„ and p be a new
m-ary predicate.
Let V be definition clauses of new predicates, and
PO =Tuv
D is initially
:
</equation>
<bodyText confidence="0.649611">
and other new predicates are included through the
constraint normalization.
Then, mf(E) returns p(xi, , xrn), if there exists
a sequence of program clauses
</bodyText>
<listItem confidence="0.5202388">
PO I&apos;ll • • • 11:1w
and Pn is modularly defined, where 2i.f.1 is derived
from Pi (0 &lt; i &lt; n) by one of the following three
types of transformations.
1. unfold transformation
</listItem>
<bodyText confidence="0.5784074">
Select one clause C from Pi and one atomic for-
mula A from the body of C. Let C1,... ,C, be all
the clauses whose heads unify with A, and C.`i be
the result of applying Ci to A of C (j = 1, . . . ,n).
Pi+i is obtained by replacing C in Pi with
</bodyText>
<figure confidence="0.881110611111111">
2member(X, [a, b]) is not modular, but is equivalent to
pl(X ), where
pl(a).
p2(b).
- 97 -
2. fold transformation
Let C(A: -K&amp;L.) be a clause in Pi, and D(B :
-K&apos;.) be a clause in D, and 0 be mgu(K,K&apos;)
that meets the following conditions.
and
Po = {Ti, T2, T3, T4, D1},T0 = {D1}
Unfolding the first formula of Dl&apos;s body, we get
(a) No variables occur in both K and L, and
(b) C is not contained in D.
Then, Pi+1 is obtained by replacing C in Pi with
AB :-.130&amp;L.
3. integration
Let C (H : -B&amp;R.) be a clause in Pi, where B
</figure>
<bodyText confidence="0.9473265">
is not modular and contains variables xl, ,x„,
and there are no common variables between B
and R. Let p be a new m-ary predicate and the
following clause E:
</bodyText>
<equation confidence="0.82147725">
11(xi, • • -B.
be the definition of p. Then, Pi+i is obtained by
replacing C in Pi with
H : , x,,,)&amp;R.
</equation>
<bodyText confidence="0.998388571428571">
and adding E. E is also added to V.
The third transformation can be seen as a special
case of fold transformation. Hence, these three trans-
formations preserve the semantics of programs be-
cause unfold/fold transformation has been proved as
valid [6]. &amp;quot;
The following example shows a transformation of
</bodyText>
<equation confidence="0.942914423076923">
member(A, Z), append(X,Y, Z).
Here, T is { T1,T2,T3, T4 }, where
Ti = member(X, IY3) •
T2 = member (X , CY I Z3 ) : -member (X , Z) .
T3 = append( 0 ,X , X) .
T4 = append( [A IX] Y CA I Z3 ) :-append(X , Y ,Z) .
and E is fmember(A, Z),append(X,Y,Z)}. The new
predicate pl is defined as
Di: pi(A,X,Y,Z):-member(A,Z),append(X,Y,Z).
T5 = pl(A,X,Y, CAI :-append(X,Y, CA Z)) •
T6 = pl(A,X,Y, [BIZ]) :-member, (A,Z) ,
append(X,Y, [91Z]).
So
Pi = {Tl, T2, T3, T4, T5, T6}
By integration,
T5&apos; = pi(A,X,Y,EAIZ]):-p2(X,Y,A,Z).
T6&apos; = pi(A,X,Y,[131Z]):-p3(A,Z,X,Y,6).
D2 = p2(X,Y,A,Z):-append(X,Y,EAIZ]).
D3 = p3(A,Z,X,Y,B):-
member(A,Z) ,append(X,Y, [BIZ)).
and
22 = {Ti, T2, T3, T4, T5&apos;, T6&apos;,D2, D3}
= {D1,D2, D3}
By unfolding D2,
T7 = p2(0,EA1Z] ,A,Z).
T8 = p2( DIX] ,Y,A,Z):-append(X,Y,Z).
</equation>
<bodyText confidence="0.7857055">
These clauses comprise the modular definition of p2
Thus
</bodyText>
<equation confidence="0.898250384615385">
23 = {T1, T2, T3, T4, T5&apos;, T6&apos;, T7, T8,D3}.
Unfold the second definition of D3, and we have
T9 = p3(A,Z, , [BIZ] ,B) :-member(A,Z)
TiO = p3(A,Z, CBI ,Y,B):-
member(A,Z) ,append(X,Y,Z).
P4 = {Ti, T2, T3, T4, T51, T6&apos;, T7, T8, T9, T10}.
Folding T10 by D1 will generate
TiO&apos; = p3(A,Z,E81XLY,B):-pi(A,X,Y,Z).
Accordingly
25 = {Ti, T2, T3, T4, T5&apos;, T6&apos;, T7, T8, T9, T101}.
- 98 -
As a result,
member(A, Z),append(X ,Y, Z)
</equation>
<bodyText confidence="0.929398">
has been transformed to pl(A, X, Y,Z) preserving
equivalence, and the following new clauses have been
defined.
1T4, TV, TV, T7, T8, T9, T1011.
</bodyText>
<subsectionHeader confidence="0.965116">
3.4 Implementation
</subsectionHeader>
<bodyText confidence="0.998883222222222">
The source code of cu-Prolog is, at present (Ver 2.0),
composed of 4,500 lines of language C on UNIX sys-
tem. Its precise computation speed is under evalua-
tion, but is sufficient for practical use.
Implementation of the effective constraint trans-
formation shown in above subsection requires some
heuristics in the application of three transformation.
Especially, in unfold transformation, one atomic for-
mula A is selected in the following heuristic rules
</bodyText>
<listItem confidence="0.993627714285714">
1. The atomic formula of the finite predicate.
2. The atomic formula that has constants or [ ] in
its arguments.
3. The atomic formula that has lists in its argu-
ment.
4. The atomic formula that has plural dependen-
cies.
</listItem>
<figure confidence="0.5921046">
Here,
[Def.] 3 (finite predicate) A predicate p is finite,
when the body of every definition clause of p is
1. nil, or
2. expressed by finite predicates
</figure>
<figureCaption confidence="0.977087">
Figure 1 demonstrates constraint transformation.
</figureCaption>
<sectionHeader confidence="0.990783" genericHeader="method">
4 A JPSG parser
</sectionHeader>
<bodyText confidence="0.999954928571429">
As an application of cu-Prolog, a natural language
parser based on unification based grammar has been
considered first of all. Since constraints can be added
directly to the program clause representing a lexi-
cal entry or a phrase structure rule, the grammar is
implemented more naturally and declaratively than
with ordinary Prolog. Here we describe a simple
Japanese parser of JPSG in cu-Prolog. CAHC plays
an important role in two respects.
First, CAHC is used in the lexicon of homonyms
or polysemic words. For example, a Japanese noun
&amp;quot;hasi&amp;quot; is 3-way ambiguous, it means a bridge, chop-
sticks, or an edge. This polysemic word can be sub-
sumed in the following single lexical entry.
</bodyText>
<equation confidence="0.9167325">
lexiconahasin X ,[. semS EM]);
hasi_sem(SEM).
</equation>
<bodyText confidence="0.98600875">
where hasi_sem is defined as follows.
hasi_sem(bridge).
hasi_sem(chopsticks).
hasi_sem(edge).
The value of the semantic feature is a vari-
able (SEM), and the constraint on SEM is
hasi_sem(SEM). Note that predicate hasi_sem is
modularly defined. According to CAHC, such ambi-
guity may be considered at one time, instead of being
divided in separate lexical entries. Japanese has such
an ambiguity is also shown in conjugation, post po-
sitions, etc. They can be treated in this manner.
Second, a phrase structure rule is written naturally
in a CAHC. In JPSG [7], FFP(FOOT Feature Prin-
ciple) is:
The value of a FOOT feature of the mother
unifies with the union of those of her daugh-
ters.
This principle is embedded in a phrase structure
rule as follows:
</bodyText>
<construct confidence="0.652085">
psraslashMS],[slashLDS] ,[slashRDS]);
union(LDS, RDS, MS).
</construct>
<bodyText confidence="0.933998">
However, this cannot be described in this manner in
traditional Prolog.
</bodyText>
<table confidence="0.563202">
- 99 -
_member(X,[111]).
_member(I,U14):-member(I,Z).
_append(CLI/I).
-sppend([11ILYJAIZ]):-append(X,Y,Z).
membera,[ga,wo,ni]),member(X,Eno,wo,ni]).
solution = cO(X)
cl(wo).
c1(ni).
cO(X0):-ci(I0).
_0 member(A,Z),append(X,Y,Z).
solution c7(A, Z, I, Y)
c8(12, 12, 10, Y1, Y3):-append(X0, Yl, Y3).
c8(I2, Y3, 10, Yl, Z4):-c7(12, Z4, IO, Y1).
c7(k0, Xi, 0, X1):-Inember(A0, X1).
c7(10, [111Z4], [A1112], Y3):-c8(A0, Al, 12, Y3, Z4).
The first four lines are definitions of member and append. The lines that begin with &amp;quot;@&amp;quot; are user&apos;s input atomic formulas
(constraints). The system returns the constraint (c0(X)) that is equivalent to the input constraint, and its definitions.
</table>
<figureCaption confidence="0.999781">
Figure 1: Demonstration of the constraint transformation routine
</figureCaption>
<bodyText confidence="0.998825833333333">
Figure 2 shows a simple demonstration of our
JPSG parser, and Figure 3 shows an example of
treating ambiguity as constraint. The current parser
treats a few feature and has little lexicon. However,
the expansion is easy. It parses about ten to twenty
words sentences within a second on VAX8600. Since
JPSG is a declarative grammar formalism and cu-
Prolog describes JPSG also declaratively, the parser
needs parsing algorithms independently. In the cur-
rent implementation, we adopt the left corner parsing
algorithm [1]. Furthermore, we would even be able
to abandon parsing algorithm altogether [10].
</bodyText>
<sectionHeader confidence="0.997887" genericHeader="method">
5 Final Remarks
</sectionHeader>
<bodyText confidence="0.998940466666667">
The further study of cu-Prolog has many prospects.
For example, to expand descriptive ability of con-
straints, the negative operator or the universal quan-
tifier can be added. The constraint-based, alias par-
tial, aspects of Situation Semantics[3] are naturally
implemented in terms of an extended version of cu-
Prolog [9]. For practical applications in Artificial In-
telligence in general and natural language process-
ing in particular, one needs a mechanism for carrying
out computation partially, instead of totally as de-
scribed above, where constraint transformation halts
only when the constraint in question is entirely mod-
ular. So the most difficult problem one must tackle
concerns itself with heuristics about how to control
computation.
</bodyText>
<sectionHeader confidence="0.991286" genericHeader="acknowledgments">
Acknowledgments
</sectionHeader>
<bodyText confidence="0.9997205">
This study owes much to our colleagues in the
JPSG Working group at ICOT. The implementation
of cu-Prolog is supported by ICOT and the Ministry
of International Trade and Industry in Japan.
</bodyText>
<sectionHeader confidence="0.998597" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.983602193548387">
[1] A. V. Aho and J. D. Ullman. The Theory of
Parsing, Translation, and Compiling, Volume I:
Parsing. Prentice-Hall, 1972.
[2] A. AIBA. Seiyaku Ronri Programming (Con-
straint Logic Programming). bit, 20(1):89-97,
1988. (in Japanese).
[3] J. Barwise and J. Perry. Situation and Attitudes.
MIT Press, Cambridge, Mass, 1983.
[4] A. Colmerauer. Prolog II Reference Manual
and Theoretical Model. Technical Report, ER-
ACRANS 363, Groupe d&apos;-Intelligence Artifielle,
Universite Aix-Marseille II, October 1982.
[5] A. Colmerauer. Prolog III. BYTE, August 1987.
- 100 -
_:-p(Eken,ga,naami,wo,ai,surn]).
v[Form_764, AMEAdj_7681, SC(SubCat_772}]:SEN_776---[suff_p]
--v[vs2, SC(Sc_752}]:[love,Sbj_120,0bj_124]---[subcat_p]
--p[ga]:ken---[adjacent_p]
I--n[n]:ken---[ken]
I__pEga, AJA{n[n]}]:ken---[ga]
__v[vs2, SC{p[ga], Sc_752).]:[love,Sbj_120,Obj_124]---[subcat_p]
--p[wo]:naomi---ladjacent_p]
--n[n] :naomi---[naomi]
I__p[wo, AJA{n[n]}]:naomi---[wo]
__v[vs2, SCfp[wo], P[ga), Sc_7521]:[love,Sbj_120,Obj_124]---[ai]
__v[Form_764, AJAEv[vs2,SC{Sc_752}]}, AJNEAdj_7681,
SC(SubCat_772}]:SEM_776---[surn]
cat cat(v, Form_764, E), Adj_768, SubCat_772, SEM_776)
cond [c2(Sc_752, Obj_124, Sbj_120, Form_764, SubCat_772, Adj_768, SEN_776)]
True.
F = synsi SC . [] ADJ = U SEM = [love,ken,naomi]
</reference>
<bodyText confidence="0.869602333333333">
The first line is a user&apos;s input. &amp;quot;Ken-ga Naomi-wo ai-suru&amp;quot; means &amp;quot;Ken loves Naomi.&amp;quot;
Then, the parser returns the parse tree and the category and constraint (c2( )) of the top node. User solves the constraint
to get the actual value of the variables.
</bodyText>
<figureCaption confidence="0.986516">
Figure 2: Demonstration of our JPSG parser
</figureCaption>
<reference confidence="0.93168175">
_:-p([ai,surn,hito]).
n[n]:Semantics_824---[adjunct_p]
--v[Form_T96, AJN(ninp, SOL8201]:Sementics_824---[suff_p]
I--v[vs2, SCESc_3761]:[love,Sbj_162,0bj_156]---[ai]
I__v[Form.796, AJA(v[vs2,SCE5c_3761]1, AJLininn, SC{-820]:Semantics_824---[suru]
inst(Obj_932, [people,Obj_932])---[hito]
cat cat(n, n, [], [], U, Semantics_824)
cond [c6(Sc_376, Obj_156, Sbj_152, Form_796, _820, Obj_932, Semantics_824)]
True.
-:-c6(_,-,-,-,-,-,Sem).
Sem = inst(Obj0_136, [and,[people,Obj0_136],[love,Sbj1_140,0bj0_136]])
Sem inst(Sbj0_136, iando[Psople,Sbj0_136],[love,gbj0_136,0bj1_140]))
</reference>
<bodyText confidence="0.8892305">
This is a parse tree of &amp;quot;ai-suru hito&amp;quot; that has two meaning: &amp;quot;people whom someone loves&amp;quot; or &amp;quot;people who loves someone&amp;quot;.
These ambiguity is shown in two solution of the constraint.
</bodyText>
<figureCaption confidence="0.986475">
Figure 3: Example of ambiguity
</figureCaption>
<reference confidence="0.976264">
- 101 -
[6] K. FURUKAWA and F. MIZOGUTI, editors.
Program Henkan (Program Transformation).
Tisiki Johoshori Series No.7, Kyoritu, Tokyo,
1987. (in Japanese).
[7] T. GUNJI. Japanese Phrase Structure Gram-
mar. Reidel, Dordrecht, 1986.
[8] K. HASIDA. Conditioned Unification for Natu-
ral Language Processing. In Proceedings of the
11th COLING, pages 85-87, 1986.
[9] K. HASIDA. A Constraint-Based View of Lan-
guage. In Proceedings of Workshop on Situation
Theory and its Applitation, 1989. (to appear).
[10] K. HASIDA and S. ISIZAKI. Dependency Prop-
agation: A Unified Theory of Sentence Cmpri-
hension and Generation. In Proceedings of IJ-
CAI, 1987.
[11] S. M. Shieber. An Introduction to Unification-
Based Approach to Grammar. CSLI Lecture
Notes Series No.4, Stanford:CSLI, 1986.
[12] H. SIRAI and K. HASIDA. Zyookentuki Tanitu-
ka (Conditioned Unification). Computer Soft-
ware, 3(4):28-38, 1986. (in Japanese).
[13] H. TUDA. A JPSG Parser in Constraint Logic
Programming. Master&apos;s thesis, Department of
Information Science, University of Tokyo, 1989.
(to appear).
- 102 -
</reference>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.079989">
<title confidence="0.997831">JPSG Parser on Constraint Logic Programming</title>
<author confidence="0.953105">Hirosi TUDA</author>
<affiliation confidence="0.970509666666667">Department of information science Faculty of science University of Tokyo 7-3-1 Hongo, Bunkyo-ku Tokyo, 113 Japan</affiliation>
<email confidence="0.956842">e-mail:a30728%tansei.cc.u-tokyo.junet@relay.cs.net</email>
<affiliation confidence="0.745575">HASIDA, Koiti Institute for New Generation Computer Technology (ICOT)</affiliation>
<address confidence="0.977387">1-4-28 Mita, Minato-ku Tokyo, 108 Japan</address>
<email confidence="0.997482">e-mail:hasida@icot.jp@relay.cs.net</email>
<author confidence="0.400756">Hidetosi SIRAI</author>
<affiliation confidence="0.999953">Tamagawa University</affiliation>
<address confidence="0.973176">6-1-1 Tamagawa gakuen, Machida-shi Tokyo, 194 Japan</address>
<email confidence="0.992706">e-mail:a88868%tansei.cc.u-tokyo.junet@re1ay.cs.net</email>
<abstract confidence="0.999202947368421">This paper presents a constraint logic programming introduces a simple Japanese parser based on Japanese Phrase Structure Grammar as suitable application of cu-Prolog. adopts unification of the normal Prolog unification. In cu-Prolog, constraints in terms of user defined predicates can be directly added to the program clauses. Such a clause called Added Horn Clause (CAHC). Unlike conventional CLP systems, cu-Prolog deals with constraints about symbolic or combinatorial objects. For natural language processing, such constraints are more important than those on numerical or boolean objects. In comparison with normal Prolog, cu-Prolog has more descriptive power, and is more declarative. It enables a natural implementation of JPSG and other unification based grammar formalisms.</abstract>
<note confidence="0.524491">From this April, Fujitsu Corporation</note>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>A V Aho</author>
<author>J D Ullman</author>
</authors>
<title>The Theory of Parsing, Translation, and Compiling, Volume I: Parsing.</title>
<date>1972</date>
<publisher>Prentice-Hall,</publisher>
<contexts>
<context position="13694" citStr="[1]" startWordPosition="2254" endWordPosition="2254">and its definitions. Figure 1: Demonstration of the constraint transformation routine Figure 2 shows a simple demonstration of our JPSG parser, and Figure 3 shows an example of treating ambiguity as constraint. The current parser treats a few feature and has little lexicon. However, the expansion is easy. It parses about ten to twenty words sentences within a second on VAX8600. Since JPSG is a declarative grammar formalism and cuProlog describes JPSG also declaratively, the parser needs parsing algorithms independently. In the current implementation, we adopt the left corner parsing algorithm [1]. Furthermore, we would even be able to abandon parsing algorithm altogether [10]. 5 Final Remarks The further study of cu-Prolog has many prospects. For example, to expand descriptive ability of constraints, the negative operator or the universal quantifier can be added. The constraint-based, alias partial, aspects of Situation Semantics[3] are naturally implemented in terms of an extended version of cuProlog [9]. For practical applications in Artificial Intelligence in general and natural language processing in particular, one needs a mechanism for carrying out computation partially, instead</context>
</contexts>
<marker>[1]</marker>
<rawString>A. V. Aho and J. D. Ullman. The Theory of Parsing, Translation, and Compiling, Volume I: Parsing. Prentice-Hall, 1972.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A AIBA</author>
</authors>
<title>Seiyaku Ronri Programming (Constraint Logic Programming).</title>
<date>1988</date>
<tech>bit,</tech>
<pages>20--1</pages>
<note>(in Japanese).</note>
<contexts>
<context position="2787" citStr="[2]" startWordPosition="394" endWordPosition="394">tional Prolog [13]. In cu-Prolog, user defined constraints can be directly added to a program clause (constraint added Horn clause), and the constraint unification [12, 8] 1 is adopted instead of the norlln these earlier papers, &amp;quot;constraint unification&amp;quot; was called &amp;quot;conditioned unification.&amp;quot; - 95 - mal unification. This paper discusses the outline of the cu-Prolog system, and presents a Japanese parser based on JPSG (Japanese Phrase Structure Grammar) [7] as a suitable application of cu-Prolog. 2 Constraint Added Horn Clause (CAHC) Most of the constraint logic programming language systems (CAL [2], PrologIII [5], etc.) deal with constraints about algebraic equations, i.e., constraints about numerical domains, such as that of real numbers etc. However, in the problems arising in Artificial Intelligence, constraints on symbolic or combinatorial objects are far more important than those on numerical objects. cu-Prolog handles constraints described in terms of sequence of atomic formulas of Prolog. The program clauses of cu-Prolog are following type, which we call Constraint Added Horn Clauses (CAHCs): 1. H (H is called the head, B1, B2, Bn is the body, Ci,C2, ,Cm is the constraint. The bo</context>
</contexts>
<marker>[2]</marker>
<rawString>A. AIBA. Seiyaku Ronri Programming (Constraint Logic Programming). bit, 20(1):89-97, 1988. (in Japanese).</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Barwise</author>
<author>J Perry</author>
</authors>
<title>Situation and Attitudes.</title>
<date>1983</date>
<publisher>MIT Press,</publisher>
<location>Cambridge, Mass,</location>
<contexts>
<context position="14037" citStr="[3]" startWordPosition="2306" endWordPosition="2306">sentences within a second on VAX8600. Since JPSG is a declarative grammar formalism and cuProlog describes JPSG also declaratively, the parser needs parsing algorithms independently. In the current implementation, we adopt the left corner parsing algorithm [1]. Furthermore, we would even be able to abandon parsing algorithm altogether [10]. 5 Final Remarks The further study of cu-Prolog has many prospects. For example, to expand descriptive ability of constraints, the negative operator or the universal quantifier can be added. The constraint-based, alias partial, aspects of Situation Semantics[3] are naturally implemented in terms of an extended version of cuProlog [9]. For practical applications in Artificial Intelligence in general and natural language processing in particular, one needs a mechanism for carrying out computation partially, instead of totally as described above, where constraint transformation halts only when the constraint in question is entirely modular. So the most difficult problem one must tackle concerns itself with heuristics about how to control computation. Acknowledgments This study owes much to our colleagues in the JPSG Working group at ICOT. The implement</context>
</contexts>
<marker>[3]</marker>
<rawString>J. Barwise and J. Perry. Situation and Attitudes. MIT Press, Cambridge, Mass, 1983.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Colmerauer</author>
</authors>
<title>Prolog II Reference Manual and Theoretical Model.</title>
<date>1982</date>
<booktitle>ERACRANS 363, Groupe d&apos;-Intelligence Artifielle, Universite Aix-Marseille II,</booktitle>
<tech>Technical Report,</tech>
<contexts>
<context position="5786" citStr="[4]" startWordPosition="917" endWordPosition="917">. and mf (member(X ,[a, 1 c]), member(X , [k, I, m])) is not undefined. This transformation is done by repeating unfold/fold transformations as described later. 3.2 Comparison with conventional approaches In normal Prolog, constraints are inserted in a goal and processed as procedures. It is not desirable for a declarative programming language, and the execution can be ineffective when constraints are inserted in a insufficient place. As constraints are rewritten at every unification, cu-Prolog has more powerful descriptive ability than the bind-hook technique. For example, freeze in Prolog II[4] can impose constraints on one variable, so that when the variable is instantiated, the constraints are executed as a procedure. Freeze has, however, two disadvantages. First, freeze cannot impose a constraint on plural variables at one time. For example, it cannot express the following CAHC. 1(X), g(Y, Z); append(X,Y, Z). Second, since the contradiction between constraints is not detected until the variable is instantiated, there is a possibility of executing useless computation in constraints deadlocking. For example, X and Y are unifiable even after executing f ree ze(X , member(X , [a, b])</context>
</contexts>
<marker>[4]</marker>
<rawString>A. Colmerauer. Prolog II Reference Manual and Theoretical Model. Technical Report, ERACRANS 363, Groupe d&apos;-Intelligence Artifielle, Universite Aix-Marseille II, October 1982.</rawString>
</citation>
<citation valid="false">
<authors>
<author>Prolog BYTE</author>
</authors>
<title>100 -_:-p(Eken,ga,naami,wo,ai,surn]). v[Form_764, AMEAdj_7681, SC(SubCat_772}]:SEN_776---[suff_p] --v[vs2, SC(Sc_752}]:[love,Sbj_120,0bj_124]---[subcat_p] --p[ga]:ken---[adjacent_p] I--n[n]:ken---[ken] I__pEga, AJA{n[n]}]:ken---[ga] __v[vs2, SC{p[ga], Sc_752).]:[love,Sbj_120,Obj_124]---[subcat_p] --p[wo]:naomi---ladjacent_p] --n[n] :naomi---[naomi] I__p[wo, AJA{n[n]}]:naomi---[wo]</title>
<date>1987</date>
<booktitle>v[vs2, SCfp[wo], P[ga), Sc_7521]:[love,Sbj_120,Obj_124]---[ai] __v[Form_764, AJAEv[vs2,SC{Sc_752}]}, AJNEAdj_7681, SC(SubCat_772}]:SEM_776---[surn] cat cat(v, Form_764, E), Adj_768, SubCat_772, SEM_776) cond [c2(Sc_752, Obj_124, Sbj_120, Form_764, SubCat_772, Adj_768, SEN_776)] True. F = synsi SC . [] ADJ = U SEM = [love,ken,naomi] _:-p([ai,surn,hito]). n[n]:Semantics_824---[adjunct_p] --v[Form_T96, AJN(ninp, SOL8201]:Sementics_824---[suff_p] I--v[vs2, SCESc_3761]:[love,Sbj_162,0bj_156]---[ai] I__v[Form.796, AJA(v[vs2,SCE5c_3761]1, AJLininn, SC{-820]:Semantics_824---[suru] inst(Obj_932, [people,Obj_932])---[hito] cat cat(n, n, [], [], U, Semantics_824) cond [c6(Sc_376, Obj_156, Sbj_152, Form_796, _820, Obj_932, Semantics_824)] True. -:-c6(_,-,-,-,-,-,Sem). Sem = inst(Obj0_136, [and,[people,Obj0_136],[love,Sbj1_140,0bj0_136]]) Sem inst(Sbj0_136, iando[Psople,Sbj0_136],[love,gbj0_136,0bj1_140])) -</booktitle>
<pages>101</pages>
<contexts>
<context position="2802" citStr="[5]" startWordPosition="396" endWordPosition="396">13]. In cu-Prolog, user defined constraints can be directly added to a program clause (constraint added Horn clause), and the constraint unification [12, 8] 1 is adopted instead of the norlln these earlier papers, &amp;quot;constraint unification&amp;quot; was called &amp;quot;conditioned unification.&amp;quot; - 95 - mal unification. This paper discusses the outline of the cu-Prolog system, and presents a Japanese parser based on JPSG (Japanese Phrase Structure Grammar) [7] as a suitable application of cu-Prolog. 2 Constraint Added Horn Clause (CAHC) Most of the constraint logic programming language systems (CAL [2], PrologIII [5], etc.) deal with constraints about algebraic equations, i.e., constraints about numerical domains, such as that of real numbers etc. However, in the problems arising in Artificial Intelligence, constraints on symbolic or combinatorial objects are far more important than those on numerical objects. cu-Prolog handles constraints described in terms of sequence of atomic formulas of Prolog. The program clauses of cu-Prolog are following type, which we call Constraint Added Horn Clauses (CAHCs): 1. H (H is called the head, B1, B2, Bn is the body, Ci,C2, ,Cm is the constraint. The body and the cons</context>
</contexts>
<marker>[5]</marker>
<rawString>A. Colmerauer. Prolog III. BYTE, August 1987. - 100 -_:-p(Eken,ga,naami,wo,ai,surn]). v[Form_764, AMEAdj_7681, SC(SubCat_772}]:SEN_776---[suff_p] --v[vs2, SC(Sc_752}]:[love,Sbj_120,0bj_124]---[subcat_p] --p[ga]:ken---[adjacent_p] I--n[n]:ken---[ken] I__pEga, AJA{n[n]}]:ken---[ga] __v[vs2, SC{p[ga], Sc_752).]:[love,Sbj_120,Obj_124]---[subcat_p] --p[wo]:naomi---ladjacent_p] --n[n] :naomi---[naomi] I__p[wo, AJA{n[n]}]:naomi---[wo] __v[vs2, SCfp[wo], P[ga), Sc_7521]:[love,Sbj_120,Obj_124]---[ai] __v[Form_764, AJAEv[vs2,SC{Sc_752}]}, AJNEAdj_7681, SC(SubCat_772}]:SEM_776---[surn] cat cat(v, Form_764, E), Adj_768, SubCat_772, SEM_776) cond [c2(Sc_752, Obj_124, Sbj_120, Form_764, SubCat_772, Adj_768, SEN_776)] True. F = synsi SC . [] ADJ = U SEM = [love,ken,naomi] _:-p([ai,surn,hito]). n[n]:Semantics_824---[adjunct_p] --v[Form_T96, AJN(ninp, SOL8201]:Sementics_824---[suff_p] I--v[vs2, SCESc_3761]:[love,Sbj_162,0bj_156]---[ai] I__v[Form.796, AJA(v[vs2,SCE5c_3761]1, AJLininn, SC{-820]:Semantics_824---[suru] inst(Obj_932, [people,Obj_932])---[hito] cat cat(n, n, [], [], U, Semantics_824) cond [c6(Sc_376, Obj_156, Sbj_152, Form_796, _820, Obj_932, Semantics_824)] True. -:-c6(_,-,-,-,-,-,Sem). Sem = inst(Obj0_136, [and,[people,Obj0_136],[love,Sbj1_140,0bj0_136]]) Sem inst(Sbj0_136, iando[Psople,Sbj0_136],[love,gbj0_136,0bj1_140])) - 101 -</rawString>
</citation>
<citation valid="true">
<date>1987</date>
<booktitle>Program Henkan (Program Transformation). Tisiki Johoshori Series No.7,</booktitle>
<editor>K. FURUKAWA and F. MIZOGUTI, editors.</editor>
<location>Kyoritu, Tokyo,</location>
<note>(in Japanese).</note>
<contexts>
<context position="5106" citStr="[6, c, d]" startWordPosition="810" endWordPosition="812">on [12, E which is the usual Prolog unification plus constrain transformation (normalization). Using constraint unification, the inference rule c cu-Prolog is as follows: Q,R;C. , Q&apos; :—S;D., = mgu(Q ,Q1), B = m f (C0 , DO) SO, RO; B (Q is an atomic formula. R, C, S, D, and B are sequences of atomic formulas. mgu(Q,Q&apos;) is a most general unifier between Q and Q&apos;.) mf (Ci , , Cm) is a modular constraint which equivalent to C1, , Cm. If C1, , Cm is inconsil tent, mf(Ci, , Cm) is not defined. In this case, th above inference rule is inapplicable. - 96 - For example, mf (member(X, [a, b, member(X , [6, c, d])) returns a new constraint cO(X), where the definition of c0 is c0(b). c0(c). and mf (member(X ,[a, 1 c]), member(X , [k, I, m])) is not undefined. This transformation is done by repeating unfold/fold transformations as described later. 3.2 Comparison with conventional approaches In normal Prolog, constraints are inserted in a goal and processed as procedures. It is not desirable for a declarative programming language, and the execution can be ineffective when constraints are inserted in a insufficient place. As constraints are rewritten at every unification, cu-Prolog has more powerful descr</context>
<context position="8468" citStr="[6]" startWordPosition="1410" endWordPosition="1410">eplacing C in Pi with AB :-.130&amp;L. 3. integration Let C (H : -B&amp;R.) be a clause in Pi, where B is not modular and contains variables xl, ,x„, and there are no common variables between B and R. Let p be a new m-ary predicate and the following clause E: 11(xi, • • -B. be the definition of p. Then, Pi+i is obtained by replacing C in Pi with H : , x,,,)&amp;R. and adding E. E is also added to V. The third transformation can be seen as a special case of fold transformation. Hence, these three transformations preserve the semantics of programs because unfold/fold transformation has been proved as valid [6]. &amp;quot; The following example shows a transformation of member(A, Z), append(X,Y, Z). Here, T is { T1,T2,T3, T4 }, where Ti = member(X, IY3) • T2 = member (X , CY I Z3 ) : -member (X , Z) . T3 = append( 0 ,X , X) . T4 = append( [A IX] Y CA I Z3 ) :-append(X , Y ,Z) . and E is fmember(A, Z),append(X,Y,Z)}. The new predicate pl is defined as Di: pi(A,X,Y,Z):-member(A,Z),append(X,Y,Z). T5 = pl(A,X,Y, CAI :-append(X,Y, CA Z)) • T6 = pl(A,X,Y, [BIZ]) :-member, (A,Z) , append(X,Y, [91Z]). So Pi = {Tl, T2, T3, T4, T5, T6} By integration, T5&apos; = pi(A,X,Y,EAIZ]):-p2(X,Y,A,Z). T6&apos; = pi(A,X,Y,[131Z]):-p3(A,Z,</context>
</contexts>
<marker>[6]</marker>
<rawString>K. FURUKAWA and F. MIZOGUTI, editors. Program Henkan (Program Transformation). Tisiki Johoshori Series No.7, Kyoritu, Tokyo, 1987. (in Japanese).</rawString>
</citation>
<citation valid="true">
<authors>
<author>T GUNJI</author>
</authors>
<title>Japanese Phrase Structure Grammar.</title>
<date>1986</date>
<location>Reidel, Dordrecht,</location>
<contexts>
<context position="2642" citStr="[7]" startWordPosition="372" endWordPosition="372">ed not declaratively but procedurally. We developed a new constraint logic programming language cu-Prolog which is free from this defect of traditional Prolog [13]. In cu-Prolog, user defined constraints can be directly added to a program clause (constraint added Horn clause), and the constraint unification [12, 8] 1 is adopted instead of the norlln these earlier papers, &amp;quot;constraint unification&amp;quot; was called &amp;quot;conditioned unification.&amp;quot; - 95 - mal unification. This paper discusses the outline of the cu-Prolog system, and presents a Japanese parser based on JPSG (Japanese Phrase Structure Grammar) [7] as a suitable application of cu-Prolog. 2 Constraint Added Horn Clause (CAHC) Most of the constraint logic programming language systems (CAL [2], PrologIII [5], etc.) deal with constraints about algebraic equations, i.e., constraints about numerical domains, such as that of real numbers etc. However, in the problems arising in Artificial Intelligence, constraints on symbolic or combinatorial objects are far more important than those on numerical objects. cu-Prolog handles constraints described in terms of sequence of atomic formulas of Prolog. The program clauses of cu-Prolog are following ty</context>
<context position="12115" citStr="[7]" startWordPosition="2025" endWordPosition="2025"> lexiconahasin X ,[. semS EM]); hasi_sem(SEM). where hasi_sem is defined as follows. hasi_sem(bridge). hasi_sem(chopsticks). hasi_sem(edge). The value of the semantic feature is a variable (SEM), and the constraint on SEM is hasi_sem(SEM). Note that predicate hasi_sem is modularly defined. According to CAHC, such ambiguity may be considered at one time, instead of being divided in separate lexical entries. Japanese has such an ambiguity is also shown in conjugation, post positions, etc. They can be treated in this manner. Second, a phrase structure rule is written naturally in a CAHC. In JPSG [7], FFP(FOOT Feature Principle) is: The value of a FOOT feature of the mother unifies with the union of those of her daughters. This principle is embedded in a phrase structure rule as follows: psraslashMS],[slashLDS] ,[slashRDS]); union(LDS, RDS, MS). However, this cannot be described in this manner in traditional Prolog. - 99 - _member(X,[111]). _member(I,U14):-member(I,Z). _append(CLI/I). -sppend([11ILYJAIZ]):-append(X,Y,Z). membera,[ga,wo,ni]),member(X,Eno,wo,ni]). solution = cO(X) cl(wo). c1(ni). cO(X0):-ci(I0). _0 member(A,Z),append(X,Y,Z). solution c7(A, Z, I, Y) c8(12, 12, 10, Y1, Y3):-a</context>
</contexts>
<marker>[7]</marker>
<rawString>T. GUNJI. Japanese Phrase Structure Grammar. Reidel, Dordrecht, 1986.</rawString>
</citation>
<citation valid="true">
<authors>
<author>K HASIDA</author>
</authors>
<title>Conditioned Unification for Natural Language Processing.</title>
<date>1986</date>
<booktitle>In Proceedings of the 11th COLING,</booktitle>
<pages>85--87</pages>
<contexts>
<context position="2355" citStr="[12, 8]" startWordPosition="326" endWordPosition="327">]. However, Prolog does not have sufficient power of expressing constraints because it executes every parts of its programs as procedures and because every variable of Prolog can be instantiated with any objects. Hence, the constraints in unification based grammar are forced to be implemented not declaratively but procedurally. We developed a new constraint logic programming language cu-Prolog which is free from this defect of traditional Prolog [13]. In cu-Prolog, user defined constraints can be directly added to a program clause (constraint added Horn clause), and the constraint unification [12, 8] 1 is adopted instead of the norlln these earlier papers, &amp;quot;constraint unification&amp;quot; was called &amp;quot;conditioned unification.&amp;quot; - 95 - mal unification. This paper discusses the outline of the cu-Prolog system, and presents a Japanese parser based on JPSG (Japanese Phrase Structure Grammar) [7] as a suitable application of cu-Prolog. 2 Constraint Added Horn Clause (CAHC) Most of the constraint logic programming language systems (CAL [2], PrologIII [5], etc.) deal with constraints about algebraic equations, i.e., constraints about numerical domains, such as that of real numbers etc. However, in the pro</context>
</contexts>
<marker>[8]</marker>
<rawString>K. HASIDA. Conditioned Unification for Natural Language Processing. In Proceedings of the 11th COLING, pages 85-87, 1986.</rawString>
</citation>
<citation valid="true">
<authors>
<author>K HASIDA</author>
</authors>
<title>A Constraint-Based View of Language.</title>
<date>1989</date>
<booktitle>In Proceedings of Workshop on Situation Theory and its Applitation,</booktitle>
<note>(to appear).</note>
<contexts>
<context position="14111" citStr="[9]" startWordPosition="2319" endWordPosition="2319">formalism and cuProlog describes JPSG also declaratively, the parser needs parsing algorithms independently. In the current implementation, we adopt the left corner parsing algorithm [1]. Furthermore, we would even be able to abandon parsing algorithm altogether [10]. 5 Final Remarks The further study of cu-Prolog has many prospects. For example, to expand descriptive ability of constraints, the negative operator or the universal quantifier can be added. The constraint-based, alias partial, aspects of Situation Semantics[3] are naturally implemented in terms of an extended version of cuProlog [9]. For practical applications in Artificial Intelligence in general and natural language processing in particular, one needs a mechanism for carrying out computation partially, instead of totally as described above, where constraint transformation halts only when the constraint in question is entirely modular. So the most difficult problem one must tackle concerns itself with heuristics about how to control computation. Acknowledgments This study owes much to our colleagues in the JPSG Working group at ICOT. The implementation of cu-Prolog is supported by ICOT and the Ministry of International </context>
</contexts>
<marker>[9]</marker>
<rawString>K. HASIDA. A Constraint-Based View of Language. In Proceedings of Workshop on Situation Theory and its Applitation, 1989. (to appear).</rawString>
</citation>
<citation valid="true">
<authors>
<author>K HASIDA</author>
<author>S ISIZAKI</author>
</authors>
<title>Dependency Propagation: A Unified Theory of Sentence Cmprihension and Generation.</title>
<date>1987</date>
<booktitle>In Proceedings of IJCAI,</booktitle>
<contexts>
<context position="13775" citStr="[10]" startWordPosition="2266" endWordPosition="2266">utine Figure 2 shows a simple demonstration of our JPSG parser, and Figure 3 shows an example of treating ambiguity as constraint. The current parser treats a few feature and has little lexicon. However, the expansion is easy. It parses about ten to twenty words sentences within a second on VAX8600. Since JPSG is a declarative grammar formalism and cuProlog describes JPSG also declaratively, the parser needs parsing algorithms independently. In the current implementation, we adopt the left corner parsing algorithm [1]. Furthermore, we would even be able to abandon parsing algorithm altogether [10]. 5 Final Remarks The further study of cu-Prolog has many prospects. For example, to expand descriptive ability of constraints, the negative operator or the universal quantifier can be added. The constraint-based, alias partial, aspects of Situation Semantics[3] are naturally implemented in terms of an extended version of cuProlog [9]. For practical applications in Artificial Intelligence in general and natural language processing in particular, one needs a mechanism for carrying out computation partially, instead of totally as described above, where constraint transformation halts only when t</context>
</contexts>
<marker>[10]</marker>
<rawString>K. HASIDA and S. ISIZAKI. Dependency Propagation: A Unified Theory of Sentence Cmprihension and Generation. In Proceedings of IJCAI, 1987.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S M Shieber</author>
</authors>
<title>An Introduction to UnificationBased Approach to Grammar.</title>
<date>1986</date>
<booktitle>CSLI Lecture Notes Series No.4, Stanford:CSLI,</booktitle>
<contexts>
<context position="1749" citStr="[11]" startWordPosition="236" endWordPosition="236"> than those on numerical or boolean objects. In comparison with normal Prolog, cu-Prolog has more descriptive power, and is more declarative. It enables a natural implementation of JPSG and other unification based grammar formalisms. From this April, Fujitsu Corporation 1 Introduction Prolog is frequently used in implementing natural language parsers or generators based on unification based grammars. This is because Prolog is also based on unification, and therefore has a declarative feature. One important characteristic of unification based grammar is also a declarative grammar formalization [11]. However, Prolog does not have sufficient power of expressing constraints because it executes every parts of its programs as procedures and because every variable of Prolog can be instantiated with any objects. Hence, the constraints in unification based grammar are forced to be implemented not declaratively but procedurally. We developed a new constraint logic programming language cu-Prolog which is free from this defect of traditional Prolog [13]. In cu-Prolog, user defined constraints can be directly added to a program clause (constraint added Horn clause), and the constraint unification [</context>
</contexts>
<marker>[11]</marker>
<rawString>S. M. Shieber. An Introduction to UnificationBased Approach to Grammar. CSLI Lecture Notes Series No.4, Stanford:CSLI, 1986.</rawString>
</citation>
<citation valid="true">
<authors>
<author>H SIRAI</author>
<author>K HASIDA</author>
</authors>
<title>Zyookentuki Tanituka (Conditioned Unification).</title>
<date>1986</date>
<journal>Computer Software,</journal>
<pages>3--4</pages>
<note>(in Japanese).</note>
<contexts>
<context position="2355" citStr="[12, 8]" startWordPosition="326" endWordPosition="327">]. However, Prolog does not have sufficient power of expressing constraints because it executes every parts of its programs as procedures and because every variable of Prolog can be instantiated with any objects. Hence, the constraints in unification based grammar are forced to be implemented not declaratively but procedurally. We developed a new constraint logic programming language cu-Prolog which is free from this defect of traditional Prolog [13]. In cu-Prolog, user defined constraints can be directly added to a program clause (constraint added Horn clause), and the constraint unification [12, 8] 1 is adopted instead of the norlln these earlier papers, &amp;quot;constraint unification&amp;quot; was called &amp;quot;conditioned unification.&amp;quot; - 95 - mal unification. This paper discusses the outline of the cu-Prolog system, and presents a Japanese parser based on JPSG (Japanese Phrase Structure Grammar) [7] as a suitable application of cu-Prolog. 2 Constraint Added Horn Clause (CAHC) Most of the constraint logic programming language systems (CAL [2], PrologIII [5], etc.) deal with constraints about algebraic equations, i.e., constraints about numerical domains, such as that of real numbers etc. However, in the pro</context>
</contexts>
<marker>[12]</marker>
<rawString>H. SIRAI and K. HASIDA. Zyookentuki Tanituka (Conditioned Unification). Computer Software, 3(4):28-38, 1986. (in Japanese).</rawString>
</citation>
<citation valid="true">
<authors>
<author>H TUDA</author>
</authors>
<title>A JPSG Parser in Constraint Logic Programming.</title>
<date>1989</date>
<tech>Master&apos;s thesis,</tech>
<institution>Department of Information Science, University of Tokyo,</institution>
<note>(to appear). - 102 -</note>
<contexts>
<context position="2202" citStr="[13]" startWordPosition="304" endWordPosition="304">on, and therefore has a declarative feature. One important characteristic of unification based grammar is also a declarative grammar formalization [11]. However, Prolog does not have sufficient power of expressing constraints because it executes every parts of its programs as procedures and because every variable of Prolog can be instantiated with any objects. Hence, the constraints in unification based grammar are forced to be implemented not declaratively but procedurally. We developed a new constraint logic programming language cu-Prolog which is free from this defect of traditional Prolog [13]. In cu-Prolog, user defined constraints can be directly added to a program clause (constraint added Horn clause), and the constraint unification [12, 8] 1 is adopted instead of the norlln these earlier papers, &amp;quot;constraint unification&amp;quot; was called &amp;quot;conditioned unification.&amp;quot; - 95 - mal unification. This paper discusses the outline of the cu-Prolog system, and presents a Japanese parser based on JPSG (Japanese Phrase Structure Grammar) [7] as a suitable application of cu-Prolog. 2 Constraint Added Horn Clause (CAHC) Most of the constraint logic programming language systems (CAL [2], PrologIII [5]</context>
</contexts>
<marker>[13]</marker>
<rawString>H. TUDA. A JPSG Parser in Constraint Logic Programming. Master&apos;s thesis, Department of Information Science, University of Tokyo, 1989. (to appear). - 102 -</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>