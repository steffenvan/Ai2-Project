<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.010916">
<title confidence="0.940914">
Poliqarp
An open source corpus indexer and search engine with syntactic extensions
</title>
<author confidence="0.84402">
Daniel Janus
</author>
<affiliation confidence="0.311416">
Sentivision Polska Sp. z o.o.
</affiliation>
<address confidence="0.640267">
Marynarska 19a, 02-674 Warsaw, Poland
</address>
<email confidence="0.992138">
nathell@korpus.pl
</email>
<author confidence="0.992643">
Adam Przepiórkowski
</author>
<affiliation confidence="0.9595685">
Insitute of Computer Science
Polish Academy of Sciences
</affiliation>
<address confidence="0.889672">
Ordona 21, 01-237 Warsaw, Poland
</address>
<email confidence="0.996414">
adamp@ipipan.waw.pl
</email>
<sectionHeader confidence="0.995573" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.9998921">
This paper presents recent extensions to
Poliqarp, an open source tool for index-
ing and searching morphosyntactically an-
notated corpora, which turn it into a tool for
indexing and searching certain kinds of tree-
banks, complementary to existing treebank
search engines. In particular, the paper dis-
cusses the motivation for such a new tool,
the extended query syntax of Poliqarp and
implementation and efficiency issues.
</bodyText>
<sectionHeader confidence="0.998993" genericHeader="introduction">
1 Introduction
</sectionHeader>
<bodyText confidence="0.999946388888889">
The aim of this paper is to present extensions
to Poliqarp,1 an efficient open source indexer
and search tool for morphosyntactically annotated
XCES-encoded (Ide et al., 2000) corpora, with
query syntax based on that of CQP (Christ, 1994),
but extending it in interesting ways. Poliqarp
has been in constant development since 2003
(Przepiórkowski et al., 2004) and it is currently em-
ployed as the search engine of the IPI PAN Cor-
pus of Polish (Przepiórkowski, 2004) and the Lis-
bon corpus of Portuguese (Barreto et al., 2006),
as well as in other projects. Poliqarp has a typi-
cal server-client architecture, with various Poliqarp
clients developed so far, including GUI clients for
a variaty of operating systems (Linux, Windows,
MacOS, Solaris) and architectures (big-endian and
little-endian), as well as a PHP client. Since March
2006, the 1st stable version of Poliqarp (Janus and
</bodyText>
<footnote confidence="0.985699">
1Polyinterpretation Indexing Query And Retrieval
Processor
</footnote>
<page confidence="0.996766">
85
</page>
<bodyText confidence="0.977917153846154">
Przepiórkowski, 2006) is available under GPL.2 A
version of Poliqarp that implements various statisti-
cal extensions is at the beta-testing stage.
Although Poliqarp was designed as a tool for cor-
pora linguistically annotated at word-level only, the
extensions described in this paper turn it into an in-
dexing and search tool for certain kinds of treebanks,
complementary to existing treebank search engines.
Section 2 briefly introduces the basic query syn-
tax of Poliqarp, section 3 presents extensions of
Poliqarp aimed at the processing of treebanks, sec-
tion 4 discusses implementation and efficiency is-
sues, and section 5 concludes the paper.
</bodyText>
<sectionHeader confidence="0.938551" genericHeader="method">
2 Query Syntax
</sectionHeader>
<bodyText confidence="0.998306764705882">
In the Poliqarp query language, just as in CQP, reg-
ular expressions may be formulated over corpus po-
sitions, e.g.: [pos=&amp;quot;adj&amp;quot;]+, where any non-empty
sequence of adjectives is sought, or within values
of attributes, e.g.: [pos=&amp;quot;a.*&amp;quot;], concerning forms
(henceforth: segments) tagged with POSs whose
names start with an a, e.g., adj and adv.
Parts of speech and morphosyntactic cate-
gories may be queried separately, e.g., the query
[gend=masc] could be used to search for masculine
segments, regardless of the POS or other categories,
while the query [pos=&amp;quot;subst|ger&amp;quot; &amp; gend!=masc]
can be used to find nominal and gerundive segments
which are not masculine.
A unique feature of Poliqarp is that it may be
used for searching corpora containing, in addition to
disambiguated interpretations, information about all
</bodyText>
<footnote confidence="0.857411">
2Cf. http://poliqarp.sourceforge.net/.
</footnote>
<note confidence="0.517421">
Proceedings of the ACL 2007 Demo and Poster Sessions, pages 85–88,
</note>
<bodyText confidence="0.9915444">
Prague, June 2007. c�2007 Association for Computational Linguistics
possible morphosyntactic interpretations given by
the morphological analyser. For example, the query
[case~acc] finds all segments with an accusative
interpretation (even if this is not the interpretation
selected in a given context), while [case=acc] finds
segments which were disambiguated to accusative in
a given context.
Moreover, Poliqarp does not make the assump-
tion that only one interpretation must be correct for
any given segment; some examples of sentences
containing an ambiguous segment which cannot be
uniquely disambiguated even given unlimited con-
text and all the linguistic and encyclopaedic knowl-
edge are cited in (Przepiórkowski et al., 2004). In
such cases, the = operator has the existential mean-
ing, i.e., [case=acc] finds segments with at least
one accusative interpretation marked as correct in
the context (“disambiguated”). On the other hand,
the operator == is universal, i.e., [case==acc] finds
segments whose all disambiguated interpretations
are accusative: segments which were truly uniquely
disambiguated to one (accusative) interpretation, or
segments which have many interpretations correct in
the context, but all of them are accusative.3 For com-
pleteness, the operator ~~ is added, which univer-
sally applies to all morphosyntactic interpretations,
i.e., [case~~acc] finds segments whose all interpre-
tations as given by a morphological analyser (before
disambiguation) are accusative.
The most detailed presentation of the orig-
inal query syntax of Poliqarp is available in
(Przepiórkowski, 2004), downloadable from
http://korpus.pl/index.php?page=
publications.
</bodyText>
<sectionHeader confidence="0.974104" genericHeader="method">
3 Syntactic Extensions
</sectionHeader>
<bodyText confidence="0.99988075">
(Przepiórkowski, 2007) argues for the explicit rep-
resentation of both a syntactic head and a seman-
tic head for each syntactic group identified in a
(partially parsed) constituency-based (as opposed to
dependency-based) treebank. For example, for the
Polish syntactic group tuzin białych koni, ‘a dozen
of white horses’, lit. ‘dozen-NOM/ACC white-GEN
horses-GEN’, the syntactic head is tuzin ‘dozen’,
</bodyText>
<footnote confidence="0.5241285">
3In Polish this may happen, for example, in case of some
gerund forms which are homographs of true nouns, where
meaning does not make it possible to decide on the nominal /
gerundive interpretation of the form.
</footnote>
<bodyText confidence="0.999971829268293">
while the semantic head is koni ‘horses’. The seg-
ment koni is also both the syntactic head and the
semantic head of the embedded nominal group bi-
ałych koni ‘white horses’. In general, following
(Przepiórkowski, 2007), a given segment is a syn-
tactic head of at most one group (e.g., tuzin and koni
in the example above), but it may be a semantic head
of a number of groups (e.g., koni above is a semantic
head of białych koni and of tuzin białych koni).
This kind of representation is problematic for gen-
eral search tools for constituency-based treebanks,4
such as TIGERSearch (Lezius, 2002),5 which usu-
ally assume that the set of edges within a syntactic
representation of a sentence is a tree, in particular,
that it has a single root node and that each leaf has
(at most) one incoming edge.6 While the former as-
sumption is not a serious problem (an artificial sin-
gle root may always be added), the latter is fatal for
representations alluded to above, as a single segment
may be a semantic head of a number of syntactic
groups, i.e., it may have several incoming edges.
The extension of Poliqarp presented here makes
it possible to index and search for such (partial)
syntactic-semantic treebanks. Specifications of syn-
tactic constructions in the extended Poliqarp query
language syntax are similar to specifications of par-
ticular segments, but they use a different repertoire
of attributes, non-overlapping with the attributes
used to specify single segments. Two main at-
tributes to be used for querying for syntactic groups
are: type and head. The attribute type spec-
ifies the general syntactic type of the group, so
[type=Coordination] will find coordinated con-
structions, while [type=&amp;quot;[PN]G&amp;quot;] will find prepo-
sitional and nominal groups.
The syntax of values of the attribute head differs
from that of the other attributes; its values must be
enclosed in a double or a single set of square brack-
ets, as in: [head=[...][...]] or [head=[...]].
In the first case, the first brackets specify the syntac-
tic head and second brackets specify the semantic
</bodyText>
<footnote confidence="0.997775">
4It seems that it would also be problematic for depen-
dency tools such as Netgraph, cf. (Hajiˇc et al., 2006) and
http://quest.ms.mff.cuni.cz/netgraph/doc/
netgraph_manual.html.
5Cf. http://www.ims.uni-stuttgart.de/
projekte/TIGER/.
6In TIGER tools, there is a special mechanism for adding a
second edge, e.g., in order to represent control.
</footnote>
<page confidence="0.998681">
86
</page>
<bodyText confidence="0.999979023809524">
head, as in the following query which may be used
to find elective constructions of the type najstarszy
z koni ‘(the) oldest of horses’, which are syntacti-
cally headed by the adjective and semantically by
the semantic head of the dependent of that adjective:
[head=[pos=adj][pos=noun]].
In the second case, the content of the single brack-
ets specifies both the syntactic head and the se-
mantic head and, additionally, makes the require-
ment that they be the same segment. This means
that the queries [head=[case=gen][case=gen]]
and [head=[case=gen]] have a slightly different
semantics: the first will find syntactic groups where
the two heads may be different or the same, but they
must be genitive; the second will find groups with
the two heads being necessarily the same genitive
segment.
The usefulness of such queries may be illus-
trated with a query for verbs which co-occur with
dative dependents denoting students; the first
approximation of such a query may look like this:
[pos=verb][head=[case=dat][base=student]].
This query will find not only dative nominal groups
headed by a form of STUDENT, but also dative
numeral groups whose main noun is a form of
STUDENT, appropriate dative adjectival elective
groups, etc.
As syntactic sugar, the constructs synh=[...]
and semh=[...] can be used to enforce a con-
straint only on, respectively, syntactic or semantic
head of a group.
It may seem that, given the possibility to specify
the syntactic head of the construction, the attribute
type is redundant; in fact, we are not currently
aware of cases where the specification type=&amp;quot;PG&amp;quot;
or type=&amp;quot;NG&amp;quot; could not be replaced by an ap-
propriate reference to the grammatical class (part of
speech) of the syntactic head. However, the type
attribute is useful for finding constructions which are
not defined by their heads, for example, oratio recta
constructions, and it is also useful for dealing with
coordinate structures.
</bodyText>
<sectionHeader confidence="0.990551" genericHeader="method">
4 Implementation Issues
</sectionHeader>
<bodyText confidence="0.999923190476191">
To allow for fast searching, the original Poliqarp
uses its own compact binary format for corpora,
described in detail in (Janus, 2006) and briefly in
(Janus and Przepiórkowski, 2006). Because the
number of syntactic groups can easily grow very
large and be on par with total number of words in a
fully-tagged corpus, the representation of syntactic
groups should be space-efficient, yet allow for fast
decoding and random access.
The key observation to achieving this goal is that,
due to the tree nature of the group set, any two
groups can be either mutually disjoint or completely
contained in each other. Thus, it is possible to seri-
alize the tree into a list, sorted by the lower bound of
a group,7 such that each group is immediately fol-
lowed by its direct subgroups.
More precisely, the on-disk representation of a
treebank is a bit vector that contains the following
data for each group: 1) synchronization bit (see be-
low), usually 0; 2) the difference between the lower
bound of the previous group and the lower bound
of the one in question, encoded in &apos;y-code;8 3) &apos;y-
encoded length of current group in segments; 4)
&apos;y-encoded number of type of this group (the map-
ping of numbers to type names is stored in a sepa-
rate on-disk dictionary in which two type numbers
are reserved: 0 for coordinated groups and 1 for
conjunctions); 5) if this is a coordinated construct
(i.e., type = 0) —&apos;y-encoded number of subsequent
groups (excluding the current one but including in-
direct subgroups) that are part of the coordination;9
or 6) if this is not a coordinated construct (i.e., it is
an ordinary group) — offset of syntactic and seman-
tic head of this group, in that order, each represented
by a binary number of log l bits, where l stands for
the length of the group.
One drawback of this representation is that it does
not allow for random access: the &apos;y-code and head
offsets have variable length, thus it is not possible to
determine which bit one should start with to decode
the group sequence for a certain segment. To miti-
gate this, a synchronization mechanism is employed.
</bodyText>
<footnote confidence="0.9237893">
7The corpus proper is represented by one large vector of
fixed-size structures denoting segments; here, the bounds of a
group mean offsets into that vector.
8The -y-code is a prefix-free variable-length code that en-
codes arbitrary integers so that the representation of small num-
bers takes few bits; see (Witten et al., 1999) for details.
9Special treatment of coordination is caused by the fact that,
as argued in (Przepiórkowski, 2007), coordinate structures are
best treated as multi-headed constructions, with each conjunct
bringing its own syntactic and semantic head.
</footnote>
<page confidence="0.996663">
87
</page>
<bodyText confidence="0.995550780487805">
For every k-th segment (k is a constant defined for tools for the shallow processing of Portuguese: The
the corpus, usually 1024), the bit offset of start of TagShare project. In Proceedings of the Fifth Interna-
the description of the earliest group that intersects tional Conference on Language Resources and Evalu-
this segment is stored as an unsigned little-endian ation (LREC 2006).
32-bit integer in a separate file. In the description of Oli Christ. 1994. A modular and flexible architecture for
this group, the synchronization bit is set to 1, and the an integrated corpus query system. In COMPLEX’94,
lower bound is spelled in full (as an unsigned 32-bit Budapest.
binary integer) so that it is not necessary to know the Jan Hajiˇc, Eva Hajiˇcová, Jaroslava Hlaváˇcová, Václav
previous lower bound to start decoding. Klimeš, Jiˇrí Mirovský, Petr Pajas, Jan Štˇepánek, Bar-
This synchronization lines up with the sparse in- bara Vidová Hladká, and Zdenˇek Žabokrtský, 2006.
verted indexing mechanism used by Poliqarp for ef- PDT 2.0 – Guide. Charles University, Prague. June
ficient searching. Poliqarp artificially splits the cor- 20, 2006.
pus into fixed-size chunks and remembers which Nancy Ide, Patrice Bonhomme, and Laurent Romary.
segments occur in which chunks; if the search en- 2000. XCES: An XML-based standard for linguistic
gine makes random access to the corpus, the ac- corpora. In Proceedings of the Linguistic Resources
cessed segments’ offsets are multiplies of the chunk and Evaluation Conference, pages 825–830, Athens,
size. It is best, thus, to ascertain that the constant k Greece.
is also equal to this chunk size. Daniel Janus and Adam Przepiórkowski. 2006. Poliqarp
In a typical scenario with many mostly small 1.0: Some technical aspects of a linguistic search en-
groups occurring close to each other, this encoding gine for large corpora. In Jacek Wali´nski, Krzysztof
schema is capable of achieving the ratio of well un- Kredens, and Stanisław Goidi-Roszkowski, editors,
der two bytes per group and does not incur a signifi- The proceedings of Practical Applications of Linguis-
cant overhead in corpus size (which is usually in the tic Corpora 2005, Frankfurt am Main. Peter Lang.
range of 10–12 bytes times the number of segments Daniel Janus. 2006. Metody przeszukiwania i obrazowa-
for a morphosyntactically but not structurally tagged nia jego wyników w duiych korpusach tekstów. Mas-
corpus). This is important, since disk access is the ter’s thesis, Uniwersytet Warszawski, Wydział Matem-
key factor in Poliqarp’s performance. atyki, Informatyki i Mechaniki, Warsaw.
5 Conclusions Wolfgang Lezius. 2002. TIGERSearch — ein Suchw-
In this paper, we presented an extension of Poliqarp, erkzeug für Baumbanken. In Stephan Busemann, ed-
a tool for indexing and searching morphosyntacti- itor, Proceedings der 6. Konferenz zur Verarbeitung
cally annotated corpora, towards the management of natürlicher Sprache (KONVENS 2002), Saarbrücken.
syntactically annotated corpora. An interesting fea- Adam Przepiórkowski, Zygmunt Krynicki, Łukasz
ture of thus extended Poliqarp is its ability to deal D˛ebowski, Marcin Woli´nski, Daniel Janus, and Pi-
with treebanks which do not adopt the “at most one otr Ba´nski. 2004. A search tool for corpora with
incoming edge” assumption and which distinguish positional tagsets and ambiguities. In Proceedings
between syntactic heads and semantic heads. We of the Fourth International Conference on Language
also sketched the original and efficient method of Resources and Evaluation, LREC2004, pages 1235–
indexing such treebanks. The implementation of 1238, Lisbon. ELRA.
the extensions currently approaches the alpha stage. Adam Przepiórkowski. 2004. The IPI PAN Corpus: Pre-
By the time of ACL 2007, we expect to release the liminary version. Institute of Computer Science, Pol-
sources of a relatively stable beta-stage version. ish Academy of Sciences, Warsaw.
</bodyText>
<reference confidence="0.992259777777778">
References Adam Przepiórkowski. 2007. On heads and coordina-
Florbela Barreto, António Branco, Eduardo Ferreira, tion in valence acquisition. In Alexander Gelbukh,
Amália Mendes, Maria Fernanda Nascimento, Filipe editor, Computational Linguistics and Intelligent Text
Nunes, and João Silva. 2006. Open resources and Processing (CICLing 2007), Lecture Notes in Com-
88 puter Science, pages 50–61, Berlin. Springer-Verlag.
Ian H. Witten, Alistair Moffat, and Timothy C. Bell.
1999. Managing Gigabytes: Compressing and Index-
ing Documents and Images. Morgan Kaufmann Pub-
lishers Inc., San Francisco, CA, 2nd edition.
</reference>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.847324">
<title confidence="0.999125">Poliqarp An open source corpus indexer and search engine with syntactic extensions</title>
<author confidence="0.999725">Daniel Janus</author>
<affiliation confidence="0.912263">Sentivision Polska Sp. z o.o.</affiliation>
<address confidence="0.95623">Marynarska 19a, 02-674 Warsaw, Poland</address>
<email confidence="0.975888">nathell@korpus.pl</email>
<author confidence="0.991936">Adam Przepiórkowski</author>
<affiliation confidence="0.9971615">Insitute of Computer Science Polish Academy of Sciences</affiliation>
<address confidence="0.99159">Ordona 21, 01-237 Warsaw, Poland</address>
<email confidence="0.988101">adamp@ipipan.waw.pl</email>
<abstract confidence="0.998253545454546">This paper presents recent extensions to Poliqarp, an open source tool for indexing and searching morphosyntactically annotated corpora, which turn it into a tool for indexing and searching certain kinds of treebanks, complementary to existing treebank search engines. In particular, the paper discusses the motivation for such a new tool, the extended query syntax of Poliqarp and implementation and efficiency issues.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
</citationList>
</algorithm>
</algorithms>