<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.001360">
<note confidence="0.713407">
Proceedings of EACL &apos;99
</note>
<title confidence="0.9978095">
Representing a System of Lexical Types Using Default
Unification
</title>
<author confidence="0.990081">
Aline Villavicencio
</author>
<affiliation confidence="0.9917405">
Computer Laboratory
University of Cambridge
</affiliation>
<address confidence="0.92483225">
New Museums Site
Pembroke Street
Cambridge CB2 3QG
ENGLAND
</address>
<email confidence="0.815798">
Aline.VillavicencioAcl.cam.ac.uk
</email>
<sectionHeader confidence="0.996484" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.9996885">
Default inheritance is a useful tool for
encoding linguistic generalisations that
have exceptions. In this paper we show
how the use of an order independent
typed default unification operation can
provide non-redundant highly structured
and concise representation to specify a
network of lexical types, that encodes
linguistic information about verbal sub-
categorisation. The system of lexical
types is based on the one proposed by
Pollard and Sag (1987), but uses the
more expressive typed default feature
structures, is more succinct, and able to
express linguistic sub-regularities more
elegantly.
</bodyText>
<sectionHeader confidence="0.999517" genericHeader="introduction">
1 Introduction
</sectionHeader>
<bodyText confidence="0.9997789375">
Several authors have highlighted the importance
of using defaults in the representation of linguistic
knowledge, in order to get linguistically adequate
descriptions for some natural language phenom-
ena ((Gazdar, 1987), (Bouma, 1992), (Daelemans
et al, 1992), (Briscoe, 1993)). Defaults have been
used in the definition of inflectional morphology,
specification of lexical semantics, analysis of gap-
ping constructions and ellipsis among others. In
this paper we use defaults to structure the lexicon,
concentrating on the description of verbal subcat-
egorisation information.
The issue of how to organise lexical informa-
tion is especially important when a lexicalised for-
malism like Categorial Grammar (CG) or Head-
Driven Phrase Structure Grammar (HPSG) is em-
ployed, since the burden of linguistic description
is concentrated in the lexicon and if lexical en-
tries are organised as unrelated lists, there is a
significant loss of generalisation and an increase
in redundancy. Alternatively, it is possible to use
inheritance networks, which provide representa-
tions that are able to capture linguistic regulari-
ties about classes of items that behave similarly.
This idea is employed in Pollard and Sag&apos;s (1987)
sketch of an HPSG lexicon as a monotonic mul-
tiple orthogonal inheritance type hierarchy. How-
ever, this work fail to make use of defaults, which
would significantly reduce redundancy in lexical
specifications and would enable them to elegantly
express sub-regularities (Krieger and Nerbonne,
1993). In this paper we demonstrate that using
default unification, namely the order-independent
and persistent version of default unification de-
scribed in (Lascarides et al, 1996b) and (Las-
carides and Copestake, 1999), to implement a de-
fault inheritance network results in a fully declar-
ative specification of a lexical fragment based on
Pollard and Sag&apos;s (1987), but that is both more
succinct and able to express elegantly linguistic
sub-regularities, such as the marked status of sub-
ject control of transitive subject-control verbs.
In section 2, a brief description of the use of de-
faults and YADU is given. In section 3, we present
the results of representing the proposed lexical
fragment in terms of default multiple inheritance
networks. Finally, we discuss the results achieved
and future work.
</bodyText>
<sectionHeader confidence="0.862494" genericHeader="method">
2 Default Inheritance and YADU
</sectionHeader>
<bodyText confidence="0.999536076923077">
In this work, a default multiple orthogonal inher-
itance network is used to represent lexical infor-
mation. Thus, with different subnetworks used to
encode different kinds of linguistic knowledge, the
idea is that linguistic regularities are encoded near
the top of the network, while nodes further down
the network are used to represent sub-regularities
or exceptions. Such an approach to representing
the lexicon has some advantages, like its ability
to capture linguistic generalisations, conciseness,
uniformity, ease of maintenance and modification,
and modularity (Daelemans et al, 1992).
This default multiple inheritance network is im-
</bodyText>
<page confidence="0.993406">
261
</page>
<bodyText confidence="0.983232196078432">
Proceedings of EACL &apos;99
plemented using YADU (Lascarides and Copes-
take, 1999), which is an order independent default
unification operation on typed feature structures
(TFS). YADU uses an extended definition of TFSs
called typed default feature structures (TDFSs), to
explicitly distinguish the non-default information
from the default one, where a TDFS is composed
by an indefeasible TFS (I), which contains the
non-default information and a defeasible TFS (D),
which contains the default information, with a T
separating these two TFss (I on the left-hand and
D on the right-hand). As a consequence, during
default unification non-default information can al-
ways be preserved and only consistent default in-
formation is incorporated into the defeasible TFS.
Another important point is that default unifica-
tion of two feature structures is deterministic, al-
ways returning a single value. Moreover, default
specifications can be made to act as indefeasible
information, using YADU&apos;s DefFill operation (Las-
carides and Copestake, 1999), that has a TDFS as
input and returns a TFS by incorporating all the
default information into the indefeasible TFS, say
at the interface between the lexicon and the rest of
the system. YADU also provides the possibility of
defining defaults that are going to persist outside
the lexicon, with the p operator (Lascarides et al,
1996b), which was already shown to be significant,
for example, for the interface between the lexicon
and pragmatics, where lexically encoded semantic
defaults can be overridden by discourse informa-
tion (Lascarides et al, 1996a). Furthermore, YADU
supports the definition of inequalities, which are
used to override default reentrancies when no con-
flicting values are defined in the types involved
(Lascarides and Copestake, 1999).
&lt;&gt;
YADU ( n ) can be informally defined as an op-
eration that takes two TDFSs and produces a new
one, whose indefeasible part is the result of uni-
fying the indefeasible information defined in the
input TDFSs; and the defeasible part is the result
of combining the indefeasible part with the maxi-
mal set of compatible default elements, according
to type specificity, as shown in the example below.
Throughout this paper we adopt the abbreviatory
notation from (Lascarides et al, 1996b) where In-
defeasible/Defeasible is abbreviated to Indefeasi-
ble if Indefeasible = Defeasible and T I Defeasible
is abbreviated to 1 Defeasible.
</bodyText>
<equation confidence="0.720443">
t&apos; E
t &lt;&gt; t&apos;
FT fl F /a
CT G /b
</equation>
<listItem confidence="0.97770325">
• I = [F&apos; T
G:T CT CT
• D= a
G b
</listItem>
<bodyText confidence="0.883989">
For a more detailed introduction to YADU see
(Lascarides and Copestake, 1999).
</bodyText>
<sectionHeader confidence="0.956327" genericHeader="method">
3 The proposed lexical network
</sectionHeader>
<bodyText confidence="0.999319">
The proposed verbal subcategorisation hierar-
chyl, which is based on the sketch by Pollard and
Sag (1987) is shown in figure 1. In this hierarchy,
types are ordered according to the number and
type of the subcategorisation arguments they
specify. The subcategorisation arguments of a
particular category2 are defined in its SUBCAT
feature as a difference-list. Thus, the verbal
hierarchy starts with the intrans type, which
by default specifies the need for exactly one
argument, the NP subject, where e-list is a type
that marks the end of the subcategorisation list:
</bodyText>
<listItem confidence="0.8821205">
(1) intrans type:
[SUBCAT: &lt;HEAD: up, TAIL: /e-list&gt;].
</listItem>
<bodyText confidence="0.9945364">
Now all the attributes specified for the sub-
categorised subject NP in intrans are inherited
by instances of this type and by its subtypes3,
namely, trans and intrans-control. However, since
these types subcategorise for 2 arguments, they
need to override the default of exactly one argu-
ment, specified by the e-list value for TAIL, and
add an extra argument: an NP object for trans,
and a predicative complement for intrans-control.
In this way, the specification of the trans type is:
</bodyText>
<listItem confidence="0.6833515">
(2) trans type:
[SUBCAT:&lt;TAIL: HEAD: rip, TAIL: TAIL:
</listItem>
<bodyText confidence="0.95512152631579">
/e-list&gt;1.
Similarly, the instances and subtypes of trans
inherit from intrans all the attributes for the
subject NP and from trans the attributes for the
object NP, in addition to their own constraints.
With the use of defaults there is no need for
specifying a type like strict-trans, as defined in
Pollard and Sag&apos;s hierarchy, since it contains
exactly the same information as their trans type,
except that the former specifies the SUBCAT
For reasons of space we are only showing the parts
of the lexical hierarchy that are relevant for this paper.
2 Linguistic information is expressed using a sim-
plified notation for the SUBCAT list, and for reasons of
clarity, we are only showing categories in an atomic
form, without the attributes defined.
&apos;In this paper, we are not assuming the coverage
condition, that any type in a hierarchy has to be re-
solvable to a most specific type.
</bodyText>
<page confidence="0.989398">
262
</page>
<figure confidence="0.9930976">
Proceedings of EACL &apos;99
intrans ...........
intrans-control trans walk
..........
ditrans like
intrans-equi trans-equi
try trans-raising super-equi
give /subject-control
believe / ask
persuade promise
</figure>
<figureCaption confidence="0.999993">
Figure 1: The Proposed Hierarchy
</figureCaption>
<bodyText confidence="0.84502">
attribute as containing exactly two arguments:
</bodyText>
<listItem confidence="0.993222333333333">
(3) Pollard and Sag&apos;s strict-trans type:
[SUBCAT: &lt;HEAD: np, TAIL: HEAD: np, TAIL:
TAIL: e-list&gt;],
</listItem>
<bodyText confidence="0.99891825">
while the latter works as an intermediate type,
where SUBCAT contains at least two arguments,
as shown in (4), offering its subtypes the possibil-
ity of adding extra arguments.
</bodyText>
<listItem confidence="0.958956">
(4) Pollard and Sag&apos;s trans type:
[suscAT: &lt;HEAD: np, TAIL: HEAD: np&gt;],
</listItem>
<bodyText confidence="0.9996503125">
Defaults automatically provide this possibility,
by defeasibly marking the end of the subcat-
egorisation list, which defines the number of
arguments needed, avoiding the need for these
redundant specifications, where the information
contained in one lexical sign is repeated in others.
Furthermore, these defaults are used to capture
lexical generalisations, but outside the lexicon,
we want them to act as indefeasible constraints;
therefore, we apply the DefFill operation to these
default specifications, except where marked as
persistently default. In this way, a type like
trans, after DefFill, has the consistent defaults
incorporated and specifies, indefeasibly the need
for exactly two arguments, as Pollard and Sag&apos;s
strict-trans shown in (3):
</bodyText>
<listItem confidence="0.707903666666667">
(5) trans type DefFilled:
[SUBCAT: &lt;HEAD: np, TAIL: HEAD: np, TAIL:
TAIL: e-list&gt;].
</listItem>
<bodyText confidence="0.9980806">
Apart from supporting this kind of gen-
eralisation, defaults are also used to express
sub-regularities, as, for example, in the case of
super-equi and subject-control verbs, which are
both exceptions to the general case specified
by trans-equi. The type trans-equi encodes
transitive-equi verbs by specifying that the
predicative complement of the transitive verb
is by default controlled by the object (e.g. The
teacher persuaded the doctor to go):
</bodyText>
<listItem confidence="0.86692375">
(6) trans-equi type:
[SUBCAT: &lt;TAIL: HEAD: up! fl TAIL: TAIL:
HEAD: vp( INF, SUBCAT:&lt;HEAD: np/ &gt;),
TAIL: TAIL: TAIL: e-list&gt;].
</listItem>
<bodyText confidence="0.993930375">
For super-equi verbs, the predicative comple-
ments can be controlled by either the object or
the subject. Therefore, the default object-control
in the super-equi type, inherited from trans-equi,
should be explicitly marked with the p operator
to persist until discourse interpretation, as shown
in (7), since all other features are made indefeasi-
ble prior to parsing.
</bodyText>
<listItem confidence="0.81679325">
(7) super-equi type:
[SUBCAT: &lt;TAIL: HEAD: npip II, TAIL:
TAIL: HEAD: vp( INF, SUBCAT: &lt;HEAD:
np/p &gt;)&gt;].
</listItem>
<bodyText confidence="0.9994285625">
This default would only survive in the absence
of conflicting discourse information (as in e.g.:
They needed someone with medical training. So,
the teacher asked the doctor to go (since she had
none), which is object-controlled). Otherwise,
if there is conflicting information, this default is
rejected (as in e.g.: They needed someone with
teaching experience. So, the teacher asked the
doctor (to be allowed) to go, where the control
is by the subject). A description of the precise
mechanism to do this can be found in (Las-
carides et al, 1996a). Transitive subject-control
verbs follow the pattern specified by trans-equi,
but contrary to this pattern, it is the subject
that controls the predicative complement and
not the object (e.g. The teacher promised to go):
</bodyText>
<listItem confidence="0.886712">
(8) subject-control type:
</listItem>
<bodyText confidence="0.9850576">
In this case, the constraint on subject-control
specifies that the coindexation is determined by
the subject, and as it does not conflict with the de-
fault coindexation by the object-control, inequal-
ities (#) are used to remove the default value.
</bodyText>
<note confidence="0.8221975">
[SUBCAT: &lt;HEAD: np o , TAIL: HEAD: np/
TAIL: TAIL: HEAD: vp( INF, SUBCAT: &lt;HEAD:
</note>
<figure confidence="0.980508333333333">
up &gt;) &gt;, a].
El
131
intrans-raising
seem
trans-control
</figure>
<page confidence="0.988981">
263
</page>
<bodyText confidence="0.983025444444445">
Proceedings of EACL &apos;99
As a result of using default inheritance to repre-
sent information about verbal subcategorisation,
it is possible to obtain a highly structured and
succinct hierarchy. In comparison with the hier-
archy defined by Pollard and Sag (1987), this one
avoids the need of redundant specifications and
associated type declarations, like the strict-trans
type, which are needed in a monotonic encoding.
In this way, while Pollard and Sag&apos;s hierarchy is
defined using 23 nodes, this is defined using only
19 nodes, and by defining 2 more nodes, it is possi-
ble to specify subject-control and super-egui types.
By avoiding this redundancy, there is a real gain in
conciseness, with the resulting hierarchy extend-
ing the information defined in Pollard and Sag&apos;s,
with the addition of sub-regularities, in a more
compact encoding.
</bodyText>
<sectionHeader confidence="0.998732" genericHeader="conclusions">
4 Conclusion
</sectionHeader>
<bodyText confidence="0.999767441176471">
In this paper we demonstrated how the use of de-
fault unification in the organisation of lexical in-
formation can provide non-redundant description
of lexical types. In this way, we implemented a
default inheritance network that represents ver-
bal subcategorisation information, using YADU. It
resulted in a significant reduction in lexical re-
dundancy, with linguistic regularities and sub-
regularities defined by means of TDFSS, in a lexi-
con that is succinctly organised, and that is also
easier to maintain and modify, when compared to
its monotonic counterpart. The resulting verbal
hierarchy is able not only to encode the same in-
formation as Pollard and Sag&apos;s but also to spec-
ify more sub-regularities, in a more concise way.
Such an approach has the advantage of optionally
allowing default specifications to persist outside
the lexicon, which is important for the specifica-
tion of control in super-equi verbs and for lexical
semantics. Moreover, as an order independent op-
eration, it provides a declarative mechanism for
default specification, with no cost in formal ele-
gance. Finally, as YADU operates directly on fea-
ture structures, defaults are allowed as a fully in-
tegrated part of the typed feature structure sys-
tem, and, as a consequence YADU integrates well
with constraint-based formalisms. Further work
will complement these results by comparing the
adequacy of different default unification opera-
tions, like the one used in DATR, for this kind
of linguistic description. This work is part of a
larger project concerned with the investigation of
grammatical acquisition within constraint-based
formalisms.
</bodyText>
<sectionHeader confidence="0.995586" genericHeader="acknowledgments">
5 Acknowledgements
</sectionHeader>
<bodyText confidence="0.999899166666667">
I would like to thank Ted Briscoe, Ann Copes-
take and Fabio Nemetz for their comments and
advice on this paper. Thanks also to the anony-
mous reviewers for their comments. The research
reported on this paper is supported by doctoral
studentship from CAPES/Brazil.
</bodyText>
<sectionHeader confidence="0.998417" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.998899">
Bouma, Gosse. 1992. Feature Structures and Non-
monotonicity. Computational Linguistics, 18.2.
Briscoe, Ted. 1993. Introduction. Inheritance, De-
faults and the Lexicon. Ted Briscoe, Ann Copes-
take and Valeria de Paiva eds. Cambridge Uni-
versity Press, Cambridge.
Daelemans, Walter, Koenraad De Smedt and Ger-
ald Gazdar. 1992. Inheritance in Natural Lan-
guage Processing. Computational Linguistics,
18.2.
Gazdar, Gerald. 1987. Linguistic Applications
of Default Inheritance Mechanisms. Linguis-
tic Theory and Computer Applications. Pete
Whitelock, Mary M. Wood, Harold Somers,
Rod Johnson and Paul Bennett eds.
Krieger, Hans-Ulrich. and John Nerbonne. 1993.
Feature-Based Inheritance Networks for Com-
putational Lexicons. Inheritance, Defaults and
the Lexicon. Ted Briscoe, Ann Copestake and
Valeria de Paiva eds. Cambridge University
Press, Cambridge.
Lascarides, Alex, Ann Copestake and Ted Briscoe.
1996a. Ambiguity and Coherence. Journal of
Semantics, 13.1, 41-65.
Lascarides, Alex, Ted Briscoe, Nicholas Asher and
Ann Copestake. 1996b. Order Independent Per-
sistent Typed Default Unification. Linguistics
and Philosophy, 19.1, 1-89.
Lascarides, Alex and Ann Copestake. 1999.
Default Representation in Constraint-based
Frameworks. To appear in Computational Lin-
guistics, 25.2. An earlier version of the paper
is available at http://www.csli.stanford.edu/
—aac/ papers/ yadu.gz
Pollard, Carl. and Ivan A. Sag. 1987. Information-
Based Syntax and Semantics, CSLI lecture notes
series, Number 13.
</reference>
<page confidence="0.998206">
264
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.244100">
<note confidence="0.815852">Proceedings of EACL &apos;99</note>
<title confidence="0.99684">Representing a System of Lexical Types Using Default Unification</title>
<author confidence="0.999377">Aline Villavicencio</author>
<affiliation confidence="0.999645">Computer Laboratory University of Cambridge</affiliation>
<title confidence="0.557206">New Museums Site</title>
<author confidence="0.635811">Pembroke Street</author>
<address confidence="0.8115835">Cambridge CB2 3QG ENGLAND</address>
<email confidence="0.957793">Aline.VillavicencioAcl.cam.ac.uk</email>
<abstract confidence="0.993507176470588">Default inheritance is a useful tool for encoding linguistic generalisations that have exceptions. In this paper we show how the use of an order independent typed default unification operation can provide non-redundant highly structured and concise representation to specify a network of lexical types, that encodes linguistic information about verbal subcategorisation. The system of lexical types is based on the one proposed by Pollard and Sag (1987), but uses the more expressive typed default feature structures, is more succinct, and able to express linguistic sub-regularities more elegantly.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Gosse Bouma</author>
</authors>
<date>1992</date>
<booktitle>Feature Structures and Nonmonotonicity. Computational Linguistics,</booktitle>
<pages>18--2</pages>
<contexts>
<context position="1101" citStr="Bouma, 1992" startWordPosition="151" endWordPosition="152">d and concise representation to specify a network of lexical types, that encodes linguistic information about verbal subcategorisation. The system of lexical types is based on the one proposed by Pollard and Sag (1987), but uses the more expressive typed default feature structures, is more succinct, and able to express linguistic sub-regularities more elegantly. 1 Introduction Several authors have highlighted the importance of using defaults in the representation of linguistic knowledge, in order to get linguistically adequate descriptions for some natural language phenomena ((Gazdar, 1987), (Bouma, 1992), (Daelemans et al, 1992), (Briscoe, 1993)). Defaults have been used in the definition of inflectional morphology, specification of lexical semantics, analysis of gapping constructions and ellipsis among others. In this paper we use defaults to structure the lexicon, concentrating on the description of verbal subcategorisation information. The issue of how to organise lexical information is especially important when a lexicalised formalism like Categorial Grammar (CG) or HeadDriven Phrase Structure Grammar (HPSG) is employed, since the burden of linguistic description is concentrated in the le</context>
</contexts>
<marker>Bouma, 1992</marker>
<rawString>Bouma, Gosse. 1992. Feature Structures and Nonmonotonicity. Computational Linguistics, 18.2.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ted Briscoe</author>
</authors>
<date>1993</date>
<booktitle>Introduction. Inheritance, Defaults and the Lexicon. Ted Briscoe, Ann Copestake and Valeria de Paiva eds.</booktitle>
<publisher>Cambridge University Press,</publisher>
<location>Cambridge.</location>
<contexts>
<context position="1143" citStr="Briscoe, 1993" startWordPosition="157" endWordPosition="158">a network of lexical types, that encodes linguistic information about verbal subcategorisation. The system of lexical types is based on the one proposed by Pollard and Sag (1987), but uses the more expressive typed default feature structures, is more succinct, and able to express linguistic sub-regularities more elegantly. 1 Introduction Several authors have highlighted the importance of using defaults in the representation of linguistic knowledge, in order to get linguistically adequate descriptions for some natural language phenomena ((Gazdar, 1987), (Bouma, 1992), (Daelemans et al, 1992), (Briscoe, 1993)). Defaults have been used in the definition of inflectional morphology, specification of lexical semantics, analysis of gapping constructions and ellipsis among others. In this paper we use defaults to structure the lexicon, concentrating on the description of verbal subcategorisation information. The issue of how to organise lexical information is especially important when a lexicalised formalism like Categorial Grammar (CG) or HeadDriven Phrase Structure Grammar (HPSG) is employed, since the burden of linguistic description is concentrated in the lexicon and if lexical entries are organised</context>
</contexts>
<marker>Briscoe, 1993</marker>
<rawString>Briscoe, Ted. 1993. Introduction. Inheritance, Defaults and the Lexicon. Ted Briscoe, Ann Copestake and Valeria de Paiva eds. Cambridge University Press, Cambridge.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Walter Daelemans</author>
<author>Koenraad De Smedt</author>
<author>Gerald Gazdar</author>
</authors>
<date>1992</date>
<booktitle>Inheritance in Natural Language Processing. Computational Linguistics,</booktitle>
<pages>18--2</pages>
<marker>Daelemans, De Smedt, Gazdar, 1992</marker>
<rawString>Daelemans, Walter, Koenraad De Smedt and Gerald Gazdar. 1992. Inheritance in Natural Language Processing. Computational Linguistics, 18.2.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Gerald Gazdar</author>
</authors>
<title>Linguistic Applications of Default Inheritance Mechanisms. Linguistic Theory and Computer Applications.</title>
<date>1987</date>
<editor>Pete Whitelock, Mary M. Wood, Harold Somers, Rod Johnson and Paul Bennett eds.</editor>
<contexts>
<context position="1086" citStr="Gazdar, 1987" startWordPosition="149" endWordPosition="150">highly structured and concise representation to specify a network of lexical types, that encodes linguistic information about verbal subcategorisation. The system of lexical types is based on the one proposed by Pollard and Sag (1987), but uses the more expressive typed default feature structures, is more succinct, and able to express linguistic sub-regularities more elegantly. 1 Introduction Several authors have highlighted the importance of using defaults in the representation of linguistic knowledge, in order to get linguistically adequate descriptions for some natural language phenomena ((Gazdar, 1987), (Bouma, 1992), (Daelemans et al, 1992), (Briscoe, 1993)). Defaults have been used in the definition of inflectional morphology, specification of lexical semantics, analysis of gapping constructions and ellipsis among others. In this paper we use defaults to structure the lexicon, concentrating on the description of verbal subcategorisation information. The issue of how to organise lexical information is especially important when a lexicalised formalism like Categorial Grammar (CG) or HeadDriven Phrase Structure Grammar (HPSG) is employed, since the burden of linguistic description is concent</context>
</contexts>
<marker>Gazdar, 1987</marker>
<rawString>Gazdar, Gerald. 1987. Linguistic Applications of Default Inheritance Mechanisms. Linguistic Theory and Computer Applications. Pete Whitelock, Mary M. Wood, Harold Somers, Rod Johnson and Paul Bennett eds.</rawString>
</citation>
<citation valid="true">
<authors>
<author>John Nerbonne</author>
</authors>
<date>1993</date>
<booktitle>Feature-Based Inheritance Networks for Computational Lexicons. Inheritance, Defaults and the Lexicon. Ted Briscoe, Ann Copestake and Valeria de Paiva eds.</booktitle>
<publisher>Cambridge University Press,</publisher>
<location>Cambridge.</location>
<contexts>
<context position="2371" citStr="Nerbonne, 1993" startWordPosition="343" endWordPosition="344"> lists, there is a significant loss of generalisation and an increase in redundancy. Alternatively, it is possible to use inheritance networks, which provide representations that are able to capture linguistic regularities about classes of items that behave similarly. This idea is employed in Pollard and Sag&apos;s (1987) sketch of an HPSG lexicon as a monotonic multiple orthogonal inheritance type hierarchy. However, this work fail to make use of defaults, which would significantly reduce redundancy in lexical specifications and would enable them to elegantly express sub-regularities (Krieger and Nerbonne, 1993). In this paper we demonstrate that using default unification, namely the order-independent and persistent version of default unification described in (Lascarides et al, 1996b) and (Lascarides and Copestake, 1999), to implement a default inheritance network results in a fully declarative specification of a lexical fragment based on Pollard and Sag&apos;s (1987), but that is both more succinct and able to express elegantly linguistic sub-regularities, such as the marked status of subject control of transitive subject-control verbs. In section 2, a brief description of the use of defaults and YADU is</context>
</contexts>
<marker>Nerbonne, 1993</marker>
<rawString>Krieger, Hans-Ulrich. and John Nerbonne. 1993. Feature-Based Inheritance Networks for Computational Lexicons. Inheritance, Defaults and the Lexicon. Ted Briscoe, Ann Copestake and Valeria de Paiva eds. Cambridge University Press, Cambridge.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Alex Lascarides</author>
<author>Ann Copestake</author>
<author>Ted Briscoe</author>
</authors>
<title>Ambiguity and Coherence.</title>
<date>1996</date>
<journal>Journal of Semantics,</journal>
<volume>13</volume>
<pages>41--65</pages>
<contexts>
<context position="2545" citStr="Lascarides et al, 1996" startWordPosition="366" endWordPosition="369">ations that are able to capture linguistic regularities about classes of items that behave similarly. This idea is employed in Pollard and Sag&apos;s (1987) sketch of an HPSG lexicon as a monotonic multiple orthogonal inheritance type hierarchy. However, this work fail to make use of defaults, which would significantly reduce redundancy in lexical specifications and would enable them to elegantly express sub-regularities (Krieger and Nerbonne, 1993). In this paper we demonstrate that using default unification, namely the order-independent and persistent version of default unification described in (Lascarides et al, 1996b) and (Lascarides and Copestake, 1999), to implement a default inheritance network results in a fully declarative specification of a lexical fragment based on Pollard and Sag&apos;s (1987), but that is both more succinct and able to express elegantly linguistic sub-regularities, such as the marked status of subject control of transitive subject-control verbs. In section 2, a brief description of the use of defaults and YADU is given. In section 3, we present the results of representing the proposed lexical fragment in terms of default multiple inheritance networks. Finally, we discuss the results </context>
<context position="5208" citStr="Lascarides et al, 1996" startWordPosition="777" endWordPosition="780"> defeasible TFS. Another important point is that default unification of two feature structures is deterministic, always returning a single value. Moreover, default specifications can be made to act as indefeasible information, using YADU&apos;s DefFill operation (Lascarides and Copestake, 1999), that has a TDFS as input and returns a TFS by incorporating all the default information into the indefeasible TFS, say at the interface between the lexicon and the rest of the system. YADU also provides the possibility of defining defaults that are going to persist outside the lexicon, with the p operator (Lascarides et al, 1996b), which was already shown to be significant, for example, for the interface between the lexicon and pragmatics, where lexically encoded semantic defaults can be overridden by discourse information (Lascarides et al, 1996a). Furthermore, YADU supports the definition of inequalities, which are used to override default reentrancies when no conflicting values are defined in the types involved (Lascarides and Copestake, 1999). &lt;&gt; YADU ( n ) can be informally defined as an operation that takes two TDFSs and produces a new one, whose indefeasible part is the result of unifying the indefeasible info</context>
<context position="11544" citStr="Lascarides et al, 1996" startWordPosition="1788" endWordPosition="1792">: &lt;TAIL: HEAD: npip II, TAIL: TAIL: HEAD: vp( INF, SUBCAT: &lt;HEAD: np/p &gt;)&gt;]. This default would only survive in the absence of conflicting discourse information (as in e.g.: They needed someone with medical training. So, the teacher asked the doctor to go (since she had none), which is object-controlled). Otherwise, if there is conflicting information, this default is rejected (as in e.g.: They needed someone with teaching experience. So, the teacher asked the doctor (to be allowed) to go, where the control is by the subject). A description of the precise mechanism to do this can be found in (Lascarides et al, 1996a). Transitive subject-control verbs follow the pattern specified by trans-equi, but contrary to this pattern, it is the subject that controls the predicative complement and not the object (e.g. The teacher promised to go): (8) subject-control type: In this case, the constraint on subject-control specifies that the coindexation is determined by the subject, and as it does not conflict with the default coindexation by the object-control, inequalities (#) are used to remove the default value. [SUBCAT: &lt;HEAD: np o , TAIL: HEAD: np/ TAIL: TAIL: HEAD: vp( INF, SUBCAT: &lt;HEAD: up &gt;) &gt;, a]. El 131 int</context>
</contexts>
<marker>Lascarides, Copestake, Briscoe, 1996</marker>
<rawString>Lascarides, Alex, Ann Copestake and Ted Briscoe. 1996a. Ambiguity and Coherence. Journal of Semantics, 13.1, 41-65.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Alex Lascarides</author>
<author>Ted Briscoe</author>
<author>Nicholas Asher</author>
<author>Ann Copestake</author>
</authors>
<title>Order Independent Persistent Typed Default Unification. Linguistics and Philosophy,</title>
<date>1996</date>
<volume>19</volume>
<pages>1--89</pages>
<contexts>
<context position="2545" citStr="Lascarides et al, 1996" startWordPosition="366" endWordPosition="369">ations that are able to capture linguistic regularities about classes of items that behave similarly. This idea is employed in Pollard and Sag&apos;s (1987) sketch of an HPSG lexicon as a monotonic multiple orthogonal inheritance type hierarchy. However, this work fail to make use of defaults, which would significantly reduce redundancy in lexical specifications and would enable them to elegantly express sub-regularities (Krieger and Nerbonne, 1993). In this paper we demonstrate that using default unification, namely the order-independent and persistent version of default unification described in (Lascarides et al, 1996b) and (Lascarides and Copestake, 1999), to implement a default inheritance network results in a fully declarative specification of a lexical fragment based on Pollard and Sag&apos;s (1987), but that is both more succinct and able to express elegantly linguistic sub-regularities, such as the marked status of subject control of transitive subject-control verbs. In section 2, a brief description of the use of defaults and YADU is given. In section 3, we present the results of representing the proposed lexical fragment in terms of default multiple inheritance networks. Finally, we discuss the results </context>
<context position="5208" citStr="Lascarides et al, 1996" startWordPosition="777" endWordPosition="780"> defeasible TFS. Another important point is that default unification of two feature structures is deterministic, always returning a single value. Moreover, default specifications can be made to act as indefeasible information, using YADU&apos;s DefFill operation (Lascarides and Copestake, 1999), that has a TDFS as input and returns a TFS by incorporating all the default information into the indefeasible TFS, say at the interface between the lexicon and the rest of the system. YADU also provides the possibility of defining defaults that are going to persist outside the lexicon, with the p operator (Lascarides et al, 1996b), which was already shown to be significant, for example, for the interface between the lexicon and pragmatics, where lexically encoded semantic defaults can be overridden by discourse information (Lascarides et al, 1996a). Furthermore, YADU supports the definition of inequalities, which are used to override default reentrancies when no conflicting values are defined in the types involved (Lascarides and Copestake, 1999). &lt;&gt; YADU ( n ) can be informally defined as an operation that takes two TDFSs and produces a new one, whose indefeasible part is the result of unifying the indefeasible info</context>
<context position="11544" citStr="Lascarides et al, 1996" startWordPosition="1788" endWordPosition="1792">: &lt;TAIL: HEAD: npip II, TAIL: TAIL: HEAD: vp( INF, SUBCAT: &lt;HEAD: np/p &gt;)&gt;]. This default would only survive in the absence of conflicting discourse information (as in e.g.: They needed someone with medical training. So, the teacher asked the doctor to go (since she had none), which is object-controlled). Otherwise, if there is conflicting information, this default is rejected (as in e.g.: They needed someone with teaching experience. So, the teacher asked the doctor (to be allowed) to go, where the control is by the subject). A description of the precise mechanism to do this can be found in (Lascarides et al, 1996a). Transitive subject-control verbs follow the pattern specified by trans-equi, but contrary to this pattern, it is the subject that controls the predicative complement and not the object (e.g. The teacher promised to go): (8) subject-control type: In this case, the constraint on subject-control specifies that the coindexation is determined by the subject, and as it does not conflict with the default coindexation by the object-control, inequalities (#) are used to remove the default value. [SUBCAT: &lt;HEAD: np o , TAIL: HEAD: np/ TAIL: TAIL: HEAD: vp( INF, SUBCAT: &lt;HEAD: up &gt;) &gt;, a]. El 131 int</context>
</contexts>
<marker>Lascarides, Briscoe, Asher, Copestake, 1996</marker>
<rawString>Lascarides, Alex, Ted Briscoe, Nicholas Asher and Ann Copestake. 1996b. Order Independent Persistent Typed Default Unification. Linguistics and Philosophy, 19.1, 1-89.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Alex Lascarides</author>
<author>Ann Copestake</author>
</authors>
<title>Default Representation in Constraint-based Frameworks. To appear in Computational Linguistics, 25.2. An earlier version of the paper is available at http://www.csli.stanford.edu/ —aac/</title>
<date>1999</date>
<note>papers/ yadu.gz</note>
<contexts>
<context position="2584" citStr="Lascarides and Copestake, 1999" startWordPosition="371" endWordPosition="375">e linguistic regularities about classes of items that behave similarly. This idea is employed in Pollard and Sag&apos;s (1987) sketch of an HPSG lexicon as a monotonic multiple orthogonal inheritance type hierarchy. However, this work fail to make use of defaults, which would significantly reduce redundancy in lexical specifications and would enable them to elegantly express sub-regularities (Krieger and Nerbonne, 1993). In this paper we demonstrate that using default unification, namely the order-independent and persistent version of default unification described in (Lascarides et al, 1996b) and (Lascarides and Copestake, 1999), to implement a default inheritance network results in a fully declarative specification of a lexical fragment based on Pollard and Sag&apos;s (1987), but that is both more succinct and able to express elegantly linguistic sub-regularities, such as the marked status of subject control of transitive subject-control verbs. In section 2, a brief description of the use of defaults and YADU is given. In section 3, we present the results of representing the proposed lexical fragment in terms of default multiple inheritance networks. Finally, we discuss the results achieved and future work. 2 Default Inh</context>
<context position="3923" citStr="Lascarides and Copestake, 1999" startWordPosition="577" endWordPosition="581">al information. Thus, with different subnetworks used to encode different kinds of linguistic knowledge, the idea is that linguistic regularities are encoded near the top of the network, while nodes further down the network are used to represent sub-regularities or exceptions. Such an approach to representing the lexicon has some advantages, like its ability to capture linguistic generalisations, conciseness, uniformity, ease of maintenance and modification, and modularity (Daelemans et al, 1992). This default multiple inheritance network is im261 Proceedings of EACL &apos;99 plemented using YADU (Lascarides and Copestake, 1999), which is an order independent default unification operation on typed feature structures (TFS). YADU uses an extended definition of TFSs called typed default feature structures (TDFSs), to explicitly distinguish the non-default information from the default one, where a TDFS is composed by an indefeasible TFS (I), which contains the non-default information and a defeasible TFS (D), which contains the default information, with a T separating these two TFss (I on the left-hand and D on the right-hand). As a consequence, during default unification non-default information can always be preserved a</context>
<context position="5634" citStr="Lascarides and Copestake, 1999" startWordPosition="839" endWordPosition="842"> interface between the lexicon and the rest of the system. YADU also provides the possibility of defining defaults that are going to persist outside the lexicon, with the p operator (Lascarides et al, 1996b), which was already shown to be significant, for example, for the interface between the lexicon and pragmatics, where lexically encoded semantic defaults can be overridden by discourse information (Lascarides et al, 1996a). Furthermore, YADU supports the definition of inequalities, which are used to override default reentrancies when no conflicting values are defined in the types involved (Lascarides and Copestake, 1999). &lt;&gt; YADU ( n ) can be informally defined as an operation that takes two TDFSs and produces a new one, whose indefeasible part is the result of unifying the indefeasible information defined in the input TDFSs; and the defeasible part is the result of combining the indefeasible part with the maximal set of compatible default elements, according to type specificity, as shown in the example below. Throughout this paper we adopt the abbreviatory notation from (Lascarides et al, 1996b) where Indefeasible/Defeasible is abbreviated to Indefeasible if Indefeasible = Defeasible and T I Defeasible is ab</context>
</contexts>
<marker>Lascarides, Copestake, 1999</marker>
<rawString>Lascarides, Alex and Ann Copestake. 1999. Default Representation in Constraint-based Frameworks. To appear in Computational Linguistics, 25.2. An earlier version of the paper is available at http://www.csli.stanford.edu/ —aac/ papers/ yadu.gz</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ivan A Sag</author>
</authors>
<title>InformationBased Syntax and Semantics, CSLI lecture notes series,</title>
<date>1987</date>
<journal>Number</journal>
<volume>13</volume>
<contexts>
<context position="707" citStr="Sag (1987)" startWordPosition="97" endWordPosition="98">llavicencio Computer Laboratory University of Cambridge New Museums Site Pembroke Street Cambridge CB2 3QG ENGLAND Aline.VillavicencioAcl.cam.ac.uk Abstract Default inheritance is a useful tool for encoding linguistic generalisations that have exceptions. In this paper we show how the use of an order independent typed default unification operation can provide non-redundant highly structured and concise representation to specify a network of lexical types, that encodes linguistic information about verbal subcategorisation. The system of lexical types is based on the one proposed by Pollard and Sag (1987), but uses the more expressive typed default feature structures, is more succinct, and able to express linguistic sub-regularities more elegantly. 1 Introduction Several authors have highlighted the importance of using defaults in the representation of linguistic knowledge, in order to get linguistically adequate descriptions for some natural language phenomena ((Gazdar, 1987), (Bouma, 1992), (Daelemans et al, 1992), (Briscoe, 1993)). Defaults have been used in the definition of inflectional morphology, specification of lexical semantics, analysis of gapping constructions and ellipsis among ot</context>
<context position="6540" citStr="Sag (1987)" startWordPosition="1004" endWordPosition="1005">mal set of compatible default elements, according to type specificity, as shown in the example below. Throughout this paper we adopt the abbreviatory notation from (Lascarides et al, 1996b) where Indefeasible/Defeasible is abbreviated to Indefeasible if Indefeasible = Defeasible and T I Defeasible is abbreviated to 1 Defeasible. t&apos; E t &lt;&gt; t&apos; FT fl F /a CT G /b • I = [F&apos; T G:T CT CT • D= a G b For a more detailed introduction to YADU see (Lascarides and Copestake, 1999). 3 The proposed lexical network The proposed verbal subcategorisation hierarchyl, which is based on the sketch by Pollard and Sag (1987) is shown in figure 1. In this hierarchy, types are ordered according to the number and type of the subcategorisation arguments they specify. The subcategorisation arguments of a particular category2 are defined in its SUBCAT feature as a difference-list. Thus, the verbal hierarchy starts with the intrans type, which by default specifies the need for exactly one argument, the NP subject, where e-list is a type that marks the end of the subcategorisation list: (1) intrans type: [SUBCAT: &lt;HEAD: up, TAIL: /e-list&gt;]. Now all the attributes specified for the subcategorised subject NP in intrans are</context>
<context position="12437" citStr="Sag (1987)" startWordPosition="1933" endWordPosition="1934">ubject-control specifies that the coindexation is determined by the subject, and as it does not conflict with the default coindexation by the object-control, inequalities (#) are used to remove the default value. [SUBCAT: &lt;HEAD: np o , TAIL: HEAD: np/ TAIL: TAIL: HEAD: vp( INF, SUBCAT: &lt;HEAD: up &gt;) &gt;, a]. El 131 intrans-raising seem trans-control 263 Proceedings of EACL &apos;99 As a result of using default inheritance to represent information about verbal subcategorisation, it is possible to obtain a highly structured and succinct hierarchy. In comparison with the hierarchy defined by Pollard and Sag (1987), this one avoids the need of redundant specifications and associated type declarations, like the strict-trans type, which are needed in a monotonic encoding. In this way, while Pollard and Sag&apos;s hierarchy is defined using 23 nodes, this is defined using only 19 nodes, and by defining 2 more nodes, it is possible to specify subject-control and super-egui types. By avoiding this redundancy, there is a real gain in conciseness, with the resulting hierarchy extending the information defined in Pollard and Sag&apos;s, with the addition of sub-regularities, in a more compact encoding. 4 Conclusion In th</context>
</contexts>
<marker>Sag, 1987</marker>
<rawString>Pollard, Carl. and Ivan A. Sag. 1987. InformationBased Syntax and Semantics, CSLI lecture notes series, Number 13.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>