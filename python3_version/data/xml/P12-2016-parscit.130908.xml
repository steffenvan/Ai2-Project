<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.013843">
<title confidence="0.82809">
Decoding Running Key Ciphers
</title>
<author confidence="0.855658">
Sravana Reddy*
</author>
<affiliation confidence="0.999133">
Department of Computer Science
The University of Chicago
</affiliation>
<address confidence="0.9273345">
1100 E. 58th Street
Chicago, IL 60637, USA
</address>
<email confidence="0.999487">
sravana@cs.uchicago.edu
</email>
<author confidence="0.997975">
Kevin Knight
</author>
<affiliation confidence="0.9967065">
Information Sciences Institute
University of Southern California
</affiliation>
<address confidence="0.9059065">
4676 Admiralty Way
Marina del Rey, CA 90292, USA
</address>
<email confidence="0.999516">
knight@isi.edu
</email>
<sectionHeader confidence="0.995651" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999753">
There has been recent interest in the problem
of decoding letter substitution ciphers using
techniques inspired by natural language pro-
cessing. We consider a different type of classi-
cal encoding scheme known as the running key
cipher, and propose a search solution using
Gibbs sampling with a word language model.
We evaluate our method on synthetic cipher-
texts of different lengths, and find that it out-
performs previous work that employs Viterbi
decoding with character-based models.
</bodyText>
<sectionHeader confidence="0.998992" genericHeader="introduction">
1 Introduction
</sectionHeader>
<bodyText confidence="0.99851275">
The running key cipher is an encoding scheme that
uses a secret key R that is typically a string of words,
usually taken from a book or other text that is agreed
upon by the sender and receiver. When sending a
plaintext message P, the sender truncates R to the
length of the plaintext. The scheme also relies on
a substitution function f, which is usually publicly
known, that maps a plaintext letter p and key letter
r to a unique ciphertext letter c. The most common
choice for f is the tabula recta, where c = (p + r)
mod 26 for letters in the English alphabet, with A
= 0, B = 1, and so on.
To encode a plaintext with a running key, the
spaces in the plaintext and the key are removed, and
for every 0 &lt; i &lt; |P|, the ciphertext letter at posi-
tion i is computed to be Ci +— f(Pi, Ri). Figure 1
shows an example encoding using the tabula recta.
For a given ciphertext and known f, the plaintext
uniquely determines the running key and vice versa.
*Research conducted while the author was visiting ISI.
Since we know that the plaintext and running key
are both drawn from natural language, our objective
function for the solution plaintext under some lan-
guage model is:
</bodyText>
<equation confidence="0.999342">
P� = arg max logPr(P) Pr(RP�C) (1)
P
</equation>
<bodyText confidence="0.9999845">
where the running key RP�C is the key that corre-
sponds to plaintext P and ciphertext C.
Note that if RP�C is a perfectly random sequence
of letters, this scheme is effectively a ‘one-time pad’,
which is provably unbreakable (Shannon, 1949).
The knowledge that both the plaintext and the key
are natural language strings is important in breaking
a running key cipher.
The letter-frequency distribution of running key
ciphertexts is notably flatter than than the plaintext
distribution, unlike substitution ciphers where the
frequency profile remains unchanged, modulo letter
substitutions. However, the ciphertext letter distri-
bution is not uniform; there are peaks corresponding
to letters (like I) that are formed by high-frequency
plaintext/key pairs (like E and E).
</bodyText>
<sectionHeader confidence="0.99994" genericHeader="related work">
2 Related Work
</sectionHeader>
<subsectionHeader confidence="0.999719">
2.1 Running Key Ciphers
</subsectionHeader>
<bodyText confidence="0.999947">
Bauer and Tate (2002) use letter n-grams (without
smoothing) up to order 6 to find the most probable
plaintext/key character pair at each position in the ci-
phertext. They test their method on 1000-character
ciphertexts produced from plaintexts and keys ex-
tracted from Project Gutenberg. Their accuracies
range from 28.9% to 33.5%, where accuracy is mea-
sured as the percentage of correctly decoded char-
</bodyText>
<page confidence="0.979186">
80
</page>
<note confidence="0.9012035">
Proceedings of the 50th Annual Meeting of the Association for Computational Linguistics, pages 80–84,
Jeju, Republic of Korea, 8-14 July 2012. c�2012 Association for Computational Linguistics
</note>
<figureCaption confidence="0.998553">
Figure 1: Example of a running key cipher. Note that key is truncated to the length of the plaintext.
</figureCaption>
<table confidence="0.6785565">
Plaintext – linguistics is fun, Running Key – colorless green ideas, tabula recta substitution where Ci +— (Pi + Ri) mod 26
Plaintext: L I N G U I S T I C S I S F U N
Running Key: C O L O R L E S S G R E E N I D
Ciphertext: N W Y U L T W L A I J M W S C Q
</table>
<bodyText confidence="0.982354">
acters. Such figures are too low to produce read-
able plaintexts, especially if the decoded regions are
not contiguous. Griffing (2006) uses Viterbi decod-
ing and letter 6-grams to improve on the above re-
sult, achieving a median 87% accuracy over several
1000-character ciphertexts. A key shortcoming of
this work is that it requires searching through about
265 states at each position in the ciphertext.
</bodyText>
<subsectionHeader confidence="0.996058">
2.2 Letter Substitution Ciphers
</subsectionHeader>
<bodyText confidence="0.999854375">
Previous work in decipherment of classical ciphers
has mainly focused on letter substitution. These ci-
phers use a substitution table as the secret key. The
ciphertext is generated by substituting each letter of
the plaintext according to the substitution table. The
table may be homophonic; that is, a single plaintext
letter could map to more than one possible cipher-
text letter. Just as in running key ciphers, spaces in
the plaintext are usually removed before encoding.
Proposed decipherment solutions for letter substi-
tution ciphers include techniques that use expecta-
tion maximization (Ravi and Knight, 2008), genetic
algorithms (Oranchak, 2008), integer programming
(Ravi and Knight, 2009), A* decoding (Corlett and
Penn, 2010), and Bayesian learning with Dirichlet
processes (Ravi and Knight, 2011).
</bodyText>
<subsectionHeader confidence="0.99489">
2.3 Vigen`ere Ciphers
</subsectionHeader>
<bodyText confidence="0.999878117647059">
A scheme similar to the running key cipher is the Vi-
gen`ere cipher, also known as the periodic key cipher.
Instead of a single long string spanning the length of
the plaintext, the key is a short string – usually but
not always a single word or phrase – repeated to the
length of the plaintext. Figure 2 shows an example
Vigen`ere cipher encoding. This cipher is less secure
than the running key, since the short length of the
key vastly reduces the size of the search space, and
the periodic repetition of the key leaks information.
Recent work on decoding periodic key ciphers
perform Viterbi search on the key using letter n-
gram models (Olsen et al., 2011), with the assump-
tion that the length of the key is known. If unknown,
the key length can be inferred using the Kasiski Test
(Kasiski, 1863) which takes advantage of repeated
plaintext/key character pairs.
</bodyText>
<sectionHeader confidence="0.756457" genericHeader="method">
3 Solution with Gibbs Sampling
</sectionHeader>
<bodyText confidence="0.9973065">
In this paper, we describe a search algorithm that
uses Gibbs Sampling to break a running key cipher.
</bodyText>
<subsectionHeader confidence="0.999371">
3.1 Choice of Language Model
</subsectionHeader>
<bodyText confidence="0.999997428571428">
The main advantage of a sampling-based approach
over Viterbi decoding is that it allows us to seam-
lessly use word-based language models. Lower or-
der letter n-grams may fail to decipher most cipher-
texts even with perfect search, since an incorrect
plaintext and key could have higher likelihood un-
der a weak language model than the actual message.
</bodyText>
<subsectionHeader confidence="0.999417">
3.2 Blocked Sampling
</subsectionHeader>
<bodyText confidence="0.9998657">
One possible approach is to sample a plaintext letter
at each position in the ciphertext. The limitation of
such a sampler for the running key problem is that
is extremely slow to mix, especially for longer ci-
phertexts: we found that in practice, it does not usu-
ally converge to the optimal solution in a reasonable
number of iterations even with simulated annealing.
We therefore propose a blocked sampling algorithm
that samples words rather than letters in the plain-
text, as follows:
</bodyText>
<listItem confidence="0.9997535">
1. Initialize randomly P := p1p2 ... p1q, fix R as
the key that corresponds to P, C
2. Repeat for some number of iterations
(a) Sample spaces (word boundaries) in P ac-
cording to Pr(P)
(b) Sample spaces in R according to Pr(R)
(c) Sample each word in P according to
Pr(P) Pr(R), updating R along with P
(d) Sample each word in R according to
Pr(P) Pr(R), updating P along with R
</listItem>
<page confidence="0.996631">
81
</page>
<figureCaption confidence="0.982935">
Figure 2: Example of a Vigen`ere cipher cipher, with a 5-letter periodic key, repeated to the length of the plaintext.
</figureCaption>
<table confidence="0.8963075">
Plaintext – linguistics is fun, Periodic Key – green, tabula recta substitution.
Plaintext: L I N G U I S T I C S I S F U N
Running Key: G R E E N G R E E N G R E E N G
Ciphertext: R Z R K H O J X M P Y Z W J H T
</table>
<listItem confidence="0.54302">
3. Remove spaces and return P, R
</listItem>
<bodyText confidence="0.997809583333333">
Note that every time a word in P is sampled, it
induces a change in R that may not be a word or a
sequence of words, and vice versa. Sampling word
boundaries will also produce hypotheses contain-
ing non-words. For this reason, we use a word tri-
gram model linearly interpolated with letter trigrams
(including the space character).1 The interpolation
mainly serves to smooth the search space, with the
added benefit of accounting for out-of-vocabulary,
misspelled, or truncated words in the actual plaintext
or key. Table 1 shows an example of one sampling
iteration on the ciphertext shown in Figure 1.
</bodyText>
<tableCaption confidence="0.8757055">
Table 1: First sampling iteration on the ciphertext
NWYULTWLAIJMWSCQ
</tableCaption>
<table confidence="0.999119125">
Generate P, R P: WERGATERYBVIEDOW
with letter trigrams R: RSHOLASUCHOESPOU
Sample spaces in P P: WERGAT ER YB VIEDOW
Sample spaces in R R: RS HOLASUCHOES POU
Sample words in P P: ADJUST AN MY WILLOW
R: NT PATAWYOKNEL HOU
Sample words in R P: NEWNXI ST HE SYLACT
R: AS CHOLESTEROL SAX
</table>
<sectionHeader confidence="0.997705" genericHeader="method">
4 Experiments
</sectionHeader>
<subsectionHeader confidence="0.9538">
4.1 Data
</subsectionHeader>
<bodyText confidence="0.999967090909091">
We randomly select passages from the Project
Gutenberg and Wall Street Journal Corpus extracts
that are included in the NLTK toolkit (Bird et al.,
2009). The passages are used as plaintext and key
pairs, and combined to generate synthetic ciphertext
data. Unlike previous works which used constant-
length ciphertexts, we study the effect of message
length on decipherment by varying the ciphertext
length (10, 100, and 1000 characters).
Our language model is an interpolation of word
trigrams and letter trigrams trained on the Brown
</bodyText>
<footnote confidence="0.9068065">
1Pr(P) = A Pr(P|word LM) + (1 − A) Pr(P|letter LM),
and similarly for Pr(R).
</footnote>
<bodyText confidence="0.995127333333333">
Corpus (Nelson and Kucera, 1979), with Kneser-
Ney smoothing. We fixed the word language model
interpolation weight to A = 0.7.
</bodyText>
<subsectionHeader confidence="0.98258">
4.2 Baseline and Evaluation
</subsectionHeader>
<bodyText confidence="0.999995214285714">
For comparison with the previous work, we re-
implement Viterbi decoding over letter 6-grams
(Griffing, 2006) trained on the Brown Corpus. In
addition to decipherment accuracy, we compare the
running time in seconds of the two algorithms.
Both decipherment programs were implemented in
Python and run on the same machines. The Gibbs
Sampler was run for 10000 iterations.
As in the Griffing (2006) paper, since the plaintext
and running key are interchangeable, we measure
the accuracy of a hypothesized solution against the
reference as the max of the accuracy between the hy-
pothesized plaintext and the reference plaintext, and
the hypothesized plaintext and the reference key.
</bodyText>
<subsectionHeader confidence="0.926571">
4.3 Results
</subsectionHeader>
<bodyText confidence="0.9999792">
Table 2 shows the average decipherment accuracy of
our algorithm and the baseline on each dataset. Also
shown is the number of times that the Gibbs Sam-
pling search failed – that is, when the algorithm did
not hypothesize a solution that had a probability at
least as high as the reference within 10000 iterations.
It is clear that the Gibbs Sampler is orders of mag-
nitude faster than Viterbi decoding. Performance
on the short (length 10) ciphertexts is poor under
both algorithms. This is expected, since the degree
of message uncertainty, or message equivocation as
defined by Shannon, is high for short ciphertexts:
there are several possible plaintexts and keys be-
sides the original that are likely under an English
language model. Consider the ciphertext WAEEXF-
PROV which was generated by the plaintext seg-
ment ON A REFEREN and key INENTAL AKI.
The algorithm hypothesizes that the plaintext is THE
STRAND S and key DTAME OPELD, which both
receive high language model probability.
</bodyText>
<page confidence="0.999416">
82
</page>
<tableCaption confidence="0.974693">
Table 2: Decipherment accuracy (proportion of correctly deciphered characters). Plaintext and key sources for the
ciphertext test data were extracted by starting at random points in the corpora, and selecting the following n characters.
</tableCaption>
<table confidence="0.999805111111111">
Length of Plaintext and key # Cipher- Average Accuracy Avg. running time (sec) # Failed Gibbs
ciphertext source texts searches
Viterbi Gibbs Viterbi Gibbs
10 Project Gutenberg 100 14% 17% 1005 47 5
Wall Street Journal 100 10% 26% 986 38 2
100 Project Gutenberg 100 27% 42% 10212 236 19
Wall Street Journal 100 22% 58% 10433 217 12
1000 Project Gutenberg 100 63% 88% 112489 964 32
Wall Street Journal 100 60% 93% 117303 1025 25
</table>
<tableCaption confidence="0.9930295">
Table 3: Substitution function parameterized by the keyword, CIPHER. f(p, r) is the entry in the row corresponding to p and the
column corresponding to r.
</tableCaption>
<figure confidence="0.6139548">
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
A C I P H E R A B D F G J K L M N O Q S T U V W X Y Z
B I P H E R A B D F G J K L M N O Q S T U V W X Y Z C
C P H E R A B D F G J K L M N O Q S T U V W X Y Z C I
. . .
</figure>
<bodyText confidence="0.999772857142857">
However, on the long ciphertexts, our algorithm
gets close to perfect decipherment, surpassing the
Viterbi algorithm by a large margin.2 Accuracies on
the Wall Street Journal ciphertexts are higher than on
the Gutenberg ciphertexts for our algorithm, which
may be because the latter is more divergent from the
Brown Corpus language model.
</bodyText>
<sectionHeader confidence="0.999917" genericHeader="method">
5 Future Work
</sectionHeader>
<subsectionHeader confidence="0.99398">
5.1 Unknown substitution functions
</subsectionHeader>
<bodyText confidence="0.999987636363636">
Some running key ciphers also use a secret substi-
tution function f rather than the tabula recta or an-
other known function. In typical cases, these func-
tions are not arbitrary, but are parameterized by a se-
cret keyword that mutates the tabula recta table. For
example, the function with the keyword CIPHER
would be the substitution table shown in Table 3.
Decoding a running key ciphertext under a latent
substitution function is an open line of research. One
possibility is to extend our approach by sampling the
keyword or function in addition to the plaintext.
</bodyText>
<subsectionHeader confidence="0.985672">
5.2 Exact search
</subsectionHeader>
<bodyText confidence="0.999847666666667">
Since some the errors in Gibbs Sampling decipher-
ment are due to search failures, a natural exten-
sion of this work would be to adapt Viterbi search
</bodyText>
<footnote confidence="0.943562333333333">
2The accuracies that we found for Viterbi decoding are
lower than those reported by Griffing (2006), which might be
because they use an in-domain language model.
</footnote>
<bodyText confidence="0.998806333333333">
or other exact decoding algorithms like A* to use
word-level language models. A naive implementa-
tion of Viterbi word-based decoding results in com-
putationally inefficient search spaces for large vo-
cabularies, so more sophisticated methods or heuris-
tics will be required.
</bodyText>
<subsectionHeader confidence="0.999653">
5.3 Analysis of Running Key Decipherment
</subsectionHeader>
<bodyText confidence="0.999981833333333">
While there has been theoretical and empirical anal-
ysis of the security of letter substitution ciphers
of various lengths under different language models
(Shannon, 1949; Ravi and Knight, 2008), there has
been no similar exposition of running key ciphers,
which we reserve for future work.
</bodyText>
<sectionHeader confidence="0.999249" genericHeader="conclusions">
6 Conclusion
</sectionHeader>
<bodyText confidence="0.9999668">
We propose a decipherment algorithm for running
key ciphers that uses Blocked Gibbs Sampling and
word-based language models, which shows signifi-
cant speed and accuracy improvements over previ-
ous research into this problem.
</bodyText>
<sectionHeader confidence="0.998843" genericHeader="acknowledgments">
Acknowledgments
</sectionHeader>
<bodyText confidence="0.999793">
We would like to thank Sujith Ravi for initial exper-
iments using Gibbs sampling, and the anonymous
reviewers. This research was supported in part by
NSF grant 0904684.
</bodyText>
<page confidence="0.998418">
83
</page>
<sectionHeader confidence="0.995886" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999797571428571">
Craig Bauer and Christian Tate. 2002. A statistical attack
on the running key cipher. Cryptologia, 26(4).
Steven Bird, Edward Loper, and Ewan Klein. 2009. Nat-
ural Language Processing with Python. O’Reilly Me-
dia Inc.
Eric Corlett and Gerald Penn. 2010. An exact A* method
of deciphering letter-substitution ciphers. In Proceed-
ings of ACL.
Alexander Griffing. 2006. Solving the running key ci-
pher with the Viterbi algorithm. Cryptologia, 30(4).
Friedrich Kasiski. 1863. Die Geheimschriften und die
Dechiffrir-Kunst. E. S. Mittler und Sohn.
Francis Nelson and Henry Kucera. 1979. The Brown
Corpus: A Standard Corpus of Present-Day Edited
American English. Brown University.
Peder Olsen, John Hershey, Steven Rennie, and Vaib-
hava Goel. 2011. A speech recognition solution to
an ancient cryptography problem. Technical Report
RC25109 (W1102-005), IBM Research.
David Oranchak. 2008. Evolutionary algorithm for de-
cryption of monoalphabetic homophonic substitution
ciphers encoded as constraint satisfaction problems. In
Proceedings of the Conference on Genetic and Evolu-
tionary Computation.
Sujith Ravi and Kevin Knight. 2008. Attacking deci-
pherment problems optimally with low-order n-gram
models. In Proceedings of EMNLP.
Sujith Ravi and Kevin Knight. 2009. Attacking letter
substitution ciphers with integer programming. Cryp-
tologia, 33(4).
Sujith Ravi and Kevin Knight. 2011. Bayesian inference
for Zodiac and other homophonic ciphers. In Proceed-
ings of ACL.
Claude Shannon. 1949. Communication theory of se-
crecy systems. Bell System Technical Journal, 28(4).
</reference>
<page confidence="0.99924">
84
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.712187">
<title confidence="0.938252">Decoding Running Key Ciphers</title>
<affiliation confidence="0.9964345">Department of Computer The University of</affiliation>
<address confidence="0.935544">1100 E. 58th Chicago, IL 60637,</address>
<email confidence="0.999535">sravana@cs.uchicago.edu</email>
<author confidence="0.957804">Kevin</author>
<affiliation confidence="0.9997215">Information Sciences University of Southern</affiliation>
<address confidence="0.9607105">4676 Admiralty Marina del Rey, CA 90292,</address>
<email confidence="0.999703">knight@isi.edu</email>
<abstract confidence="0.997018416666667">There has been recent interest in the problem of decoding letter substitution ciphers using techniques inspired by natural language processing. We consider a different type of classiencoding scheme known as the key and propose a search solution using Gibbs sampling with a word language model. We evaluate our method on synthetic ciphertexts of different lengths, and find that it outperforms previous work that employs Viterbi decoding with character-based models.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Craig Bauer</author>
<author>Christian Tate</author>
</authors>
<title>A statistical attack on the running key cipher.</title>
<date>2002</date>
<journal>Cryptologia,</journal>
<volume>26</volume>
<issue>4</issue>
<contexts>
<context position="2857" citStr="Bauer and Tate (2002)" startWordPosition="475" endWordPosition="478">bly unbreakable (Shannon, 1949). The knowledge that both the plaintext and the key are natural language strings is important in breaking a running key cipher. The letter-frequency distribution of running key ciphertexts is notably flatter than than the plaintext distribution, unlike substitution ciphers where the frequency profile remains unchanged, modulo letter substitutions. However, the ciphertext letter distribution is not uniform; there are peaks corresponding to letters (like I) that are formed by high-frequency plaintext/key pairs (like E and E). 2 Related Work 2.1 Running Key Ciphers Bauer and Tate (2002) use letter n-grams (without smoothing) up to order 6 to find the most probable plaintext/key character pair at each position in the ciphertext. They test their method on 1000-character ciphertexts produced from plaintexts and keys extracted from Project Gutenberg. Their accuracies range from 28.9% to 33.5%, where accuracy is measured as the percentage of correctly decoded char80 Proceedings of the 50th Annual Meeting of the Association for Computational Linguistics, pages 80–84, Jeju, Republic of Korea, 8-14 July 2012. c�2012 Association for Computational Linguistics Figure 1: Example of a ru</context>
</contexts>
<marker>Bauer, Tate, 2002</marker>
<rawString>Craig Bauer and Christian Tate. 2002. A statistical attack on the running key cipher. Cryptologia, 26(4).</rawString>
</citation>
<citation valid="true">
<authors>
<author>Steven Bird</author>
<author>Edward Loper</author>
<author>Ewan Klein</author>
</authors>
<date>2009</date>
<booktitle>Natural Language Processing with Python. O’Reilly Media Inc.</booktitle>
<contexts>
<context position="8813" citStr="Bird et al., 2009" startWordPosition="1531" endWordPosition="1534">. Table 1 shows an example of one sampling iteration on the ciphertext shown in Figure 1. Table 1: First sampling iteration on the ciphertext NWYULTWLAIJMWSCQ Generate P, R P: WERGATERYBVIEDOW with letter trigrams R: RSHOLASUCHOESPOU Sample spaces in P P: WERGAT ER YB VIEDOW Sample spaces in R R: RS HOLASUCHOES POU Sample words in P P: ADJUST AN MY WILLOW R: NT PATAWYOKNEL HOU Sample words in R P: NEWNXI ST HE SYLACT R: AS CHOLESTEROL SAX 4 Experiments 4.1 Data We randomly select passages from the Project Gutenberg and Wall Street Journal Corpus extracts that are included in the NLTK toolkit (Bird et al., 2009). The passages are used as plaintext and key pairs, and combined to generate synthetic ciphertext data. Unlike previous works which used constantlength ciphertexts, we study the effect of message length on decipherment by varying the ciphertext length (10, 100, and 1000 characters). Our language model is an interpolation of word trigrams and letter trigrams trained on the Brown 1Pr(P) = A Pr(P|word LM) + (1 − A) Pr(P|letter LM), and similarly for Pr(R). Corpus (Nelson and Kucera, 1979), with KneserNey smoothing. We fixed the word language model interpolation weight to A = 0.7. 4.2 Baseline and</context>
</contexts>
<marker>Bird, Loper, Klein, 2009</marker>
<rawString>Steven Bird, Edward Loper, and Ewan Klein. 2009. Natural Language Processing with Python. O’Reilly Media Inc.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Eric Corlett</author>
<author>Gerald Penn</author>
</authors>
<title>An exact A* method of deciphering letter-substitution ciphers.</title>
<date>2010</date>
<booktitle>In Proceedings of ACL.</booktitle>
<contexts>
<context position="4959" citStr="Corlett and Penn, 2010" startWordPosition="835" endWordPosition="838"> a substitution table as the secret key. The ciphertext is generated by substituting each letter of the plaintext according to the substitution table. The table may be homophonic; that is, a single plaintext letter could map to more than one possible ciphertext letter. Just as in running key ciphers, spaces in the plaintext are usually removed before encoding. Proposed decipherment solutions for letter substitution ciphers include techniques that use expectation maximization (Ravi and Knight, 2008), genetic algorithms (Oranchak, 2008), integer programming (Ravi and Knight, 2009), A* decoding (Corlett and Penn, 2010), and Bayesian learning with Dirichlet processes (Ravi and Knight, 2011). 2.3 Vigen`ere Ciphers A scheme similar to the running key cipher is the Vigen`ere cipher, also known as the periodic key cipher. Instead of a single long string spanning the length of the plaintext, the key is a short string – usually but not always a single word or phrase – repeated to the length of the plaintext. Figure 2 shows an example Vigen`ere cipher encoding. This cipher is less secure than the running key, since the short length of the key vastly reduces the size of the search space, and the periodic repetition </context>
</contexts>
<marker>Corlett, Penn, 2010</marker>
<rawString>Eric Corlett and Gerald Penn. 2010. An exact A* method of deciphering letter-substitution ciphers. In Proceedings of ACL.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Alexander Griffing</author>
</authors>
<title>Solving the running key cipher with the Viterbi algorithm.</title>
<date>2006</date>
<journal>Cryptologia,</journal>
<volume>30</volume>
<issue>4</issue>
<contexts>
<context position="3924" citStr="Griffing (2006)" startWordPosition="678" endWordPosition="679">tional Linguistics, pages 80–84, Jeju, Republic of Korea, 8-14 July 2012. c�2012 Association for Computational Linguistics Figure 1: Example of a running key cipher. Note that key is truncated to the length of the plaintext. Plaintext – linguistics is fun, Running Key – colorless green ideas, tabula recta substitution where Ci +— (Pi + Ri) mod 26 Plaintext: L I N G U I S T I C S I S F U N Running Key: C O L O R L E S S G R E E N I D Ciphertext: N W Y U L T W L A I J M W S C Q acters. Such figures are too low to produce readable plaintexts, especially if the decoded regions are not contiguous. Griffing (2006) uses Viterbi decoding and letter 6-grams to improve on the above result, achieving a median 87% accuracy over several 1000-character ciphertexts. A key shortcoming of this work is that it requires searching through about 265 states at each position in the ciphertext. 2.2 Letter Substitution Ciphers Previous work in decipherment of classical ciphers has mainly focused on letter substitution. These ciphers use a substitution table as the secret key. The ciphertext is generated by substituting each letter of the plaintext according to the substitution table. The table may be homophonic; that is,</context>
<context position="9532" citStr="Griffing, 2006" startWordPosition="1648" endWordPosition="1649">Unlike previous works which used constantlength ciphertexts, we study the effect of message length on decipherment by varying the ciphertext length (10, 100, and 1000 characters). Our language model is an interpolation of word trigrams and letter trigrams trained on the Brown 1Pr(P) = A Pr(P|word LM) + (1 − A) Pr(P|letter LM), and similarly for Pr(R). Corpus (Nelson and Kucera, 1979), with KneserNey smoothing. We fixed the word language model interpolation weight to A = 0.7. 4.2 Baseline and Evaluation For comparison with the previous work, we reimplement Viterbi decoding over letter 6-grams (Griffing, 2006) trained on the Brown Corpus. In addition to decipherment accuracy, we compare the running time in seconds of the two algorithms. Both decipherment programs were implemented in Python and run on the same machines. The Gibbs Sampler was run for 10000 iterations. As in the Griffing (2006) paper, since the plaintext and running key are interchangeable, we measure the accuracy of a hypothesized solution against the reference as the max of the accuracy between the hypothesized plaintext and the reference plaintext, and the hypothesized plaintext and the reference key. 4.3 Results Table 2 shows the </context>
<context position="13355" citStr="Griffing (2006)" startWordPosition="2354" endWordPosition="2355">eyword that mutates the tabula recta table. For example, the function with the keyword CIPHER would be the substitution table shown in Table 3. Decoding a running key ciphertext under a latent substitution function is an open line of research. One possibility is to extend our approach by sampling the keyword or function in addition to the plaintext. 5.2 Exact search Since some the errors in Gibbs Sampling decipherment are due to search failures, a natural extension of this work would be to adapt Viterbi search 2The accuracies that we found for Viterbi decoding are lower than those reported by Griffing (2006), which might be because they use an in-domain language model. or other exact decoding algorithms like A* to use word-level language models. A naive implementation of Viterbi word-based decoding results in computationally inefficient search spaces for large vocabularies, so more sophisticated methods or heuristics will be required. 5.3 Analysis of Running Key Decipherment While there has been theoretical and empirical analysis of the security of letter substitution ciphers of various lengths under different language models (Shannon, 1949; Ravi and Knight, 2008), there has been no similar expos</context>
</contexts>
<marker>Griffing, 2006</marker>
<rawString>Alexander Griffing. 2006. Solving the running key cipher with the Viterbi algorithm. Cryptologia, 30(4).</rawString>
</citation>
<citation valid="false">
<title>Die Geheimschriften und die Dechiffrir-Kunst.</title>
<journal>E. S. Mittler und Sohn.</journal>
<marker></marker>
<rawString>Friedrich Kasiski. 1863. Die Geheimschriften und die Dechiffrir-Kunst. E. S. Mittler und Sohn.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Francis Nelson</author>
<author>Henry Kucera</author>
</authors>
<title>The Brown Corpus: A Standard Corpus of Present-Day Edited American English.</title>
<date>1979</date>
<publisher>Brown University.</publisher>
<contexts>
<context position="9303" citStr="Nelson and Kucera, 1979" startWordPosition="1610" endWordPosition="1613"> passages from the Project Gutenberg and Wall Street Journal Corpus extracts that are included in the NLTK toolkit (Bird et al., 2009). The passages are used as plaintext and key pairs, and combined to generate synthetic ciphertext data. Unlike previous works which used constantlength ciphertexts, we study the effect of message length on decipherment by varying the ciphertext length (10, 100, and 1000 characters). Our language model is an interpolation of word trigrams and letter trigrams trained on the Brown 1Pr(P) = A Pr(P|word LM) + (1 − A) Pr(P|letter LM), and similarly for Pr(R). Corpus (Nelson and Kucera, 1979), with KneserNey smoothing. We fixed the word language model interpolation weight to A = 0.7. 4.2 Baseline and Evaluation For comparison with the previous work, we reimplement Viterbi decoding over letter 6-grams (Griffing, 2006) trained on the Brown Corpus. In addition to decipherment accuracy, we compare the running time in seconds of the two algorithms. Both decipherment programs were implemented in Python and run on the same machines. The Gibbs Sampler was run for 10000 iterations. As in the Griffing (2006) paper, since the plaintext and running key are interchangeable, we measure the accu</context>
</contexts>
<marker>Nelson, Kucera, 1979</marker>
<rawString>Francis Nelson and Henry Kucera. 1979. The Brown Corpus: A Standard Corpus of Present-Day Edited American English. Brown University.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Peder Olsen</author>
<author>John Hershey</author>
<author>Steven Rennie</author>
<author>Vaibhava Goel</author>
</authors>
<title>A speech recognition solution to an ancient cryptography problem.</title>
<date>2011</date>
<tech>Technical Report RC25109 (W1102-005), IBM Research.</tech>
<contexts>
<context position="5714" citStr="Olsen et al., 2011" startWordPosition="967" endWordPosition="970">er is the Vigen`ere cipher, also known as the periodic key cipher. Instead of a single long string spanning the length of the plaintext, the key is a short string – usually but not always a single word or phrase – repeated to the length of the plaintext. Figure 2 shows an example Vigen`ere cipher encoding. This cipher is less secure than the running key, since the short length of the key vastly reduces the size of the search space, and the periodic repetition of the key leaks information. Recent work on decoding periodic key ciphers perform Viterbi search on the key using letter ngram models (Olsen et al., 2011), with the assumption that the length of the key is known. If unknown, the key length can be inferred using the Kasiski Test (Kasiski, 1863) which takes advantage of repeated plaintext/key character pairs. 3 Solution with Gibbs Sampling In this paper, we describe a search algorithm that uses Gibbs Sampling to break a running key cipher. 3.1 Choice of Language Model The main advantage of a sampling-based approach over Viterbi decoding is that it allows us to seamlessly use word-based language models. Lower order letter n-grams may fail to decipher most ciphertexts even with perfect search, sinc</context>
</contexts>
<marker>Olsen, Hershey, Rennie, Goel, 2011</marker>
<rawString>Peder Olsen, John Hershey, Steven Rennie, and Vaibhava Goel. 2011. A speech recognition solution to an ancient cryptography problem. Technical Report RC25109 (W1102-005), IBM Research.</rawString>
</citation>
<citation valid="true">
<authors>
<author>David Oranchak</author>
</authors>
<title>Evolutionary algorithm for decryption of monoalphabetic homophonic substitution ciphers encoded as constraint satisfaction problems.</title>
<date>2008</date>
<booktitle>In Proceedings of the Conference on Genetic and Evolutionary Computation.</booktitle>
<contexts>
<context position="4876" citStr="Oranchak, 2008" startWordPosition="825" endWordPosition="826">ssical ciphers has mainly focused on letter substitution. These ciphers use a substitution table as the secret key. The ciphertext is generated by substituting each letter of the plaintext according to the substitution table. The table may be homophonic; that is, a single plaintext letter could map to more than one possible ciphertext letter. Just as in running key ciphers, spaces in the plaintext are usually removed before encoding. Proposed decipherment solutions for letter substitution ciphers include techniques that use expectation maximization (Ravi and Knight, 2008), genetic algorithms (Oranchak, 2008), integer programming (Ravi and Knight, 2009), A* decoding (Corlett and Penn, 2010), and Bayesian learning with Dirichlet processes (Ravi and Knight, 2011). 2.3 Vigen`ere Ciphers A scheme similar to the running key cipher is the Vigen`ere cipher, also known as the periodic key cipher. Instead of a single long string spanning the length of the plaintext, the key is a short string – usually but not always a single word or phrase – repeated to the length of the plaintext. Figure 2 shows an example Vigen`ere cipher encoding. This cipher is less secure than the running key, since the short length o</context>
</contexts>
<marker>Oranchak, 2008</marker>
<rawString>David Oranchak. 2008. Evolutionary algorithm for decryption of monoalphabetic homophonic substitution ciphers encoded as constraint satisfaction problems. In Proceedings of the Conference on Genetic and Evolutionary Computation.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Sujith Ravi</author>
<author>Kevin Knight</author>
</authors>
<title>Attacking decipherment problems optimally with low-order n-gram models.</title>
<date>2008</date>
<booktitle>In Proceedings of EMNLP.</booktitle>
<contexts>
<context position="4839" citStr="Ravi and Knight, 2008" startWordPosition="819" endWordPosition="822">Ciphers Previous work in decipherment of classical ciphers has mainly focused on letter substitution. These ciphers use a substitution table as the secret key. The ciphertext is generated by substituting each letter of the plaintext according to the substitution table. The table may be homophonic; that is, a single plaintext letter could map to more than one possible ciphertext letter. Just as in running key ciphers, spaces in the plaintext are usually removed before encoding. Proposed decipherment solutions for letter substitution ciphers include techniques that use expectation maximization (Ravi and Knight, 2008), genetic algorithms (Oranchak, 2008), integer programming (Ravi and Knight, 2009), A* decoding (Corlett and Penn, 2010), and Bayesian learning with Dirichlet processes (Ravi and Knight, 2011). 2.3 Vigen`ere Ciphers A scheme similar to the running key cipher is the Vigen`ere cipher, also known as the periodic key cipher. Instead of a single long string spanning the length of the plaintext, the key is a short string – usually but not always a single word or phrase – repeated to the length of the plaintext. Figure 2 shows an example Vigen`ere cipher encoding. This cipher is less secure than the </context>
</contexts>
<marker>Ravi, Knight, 2008</marker>
<rawString>Sujith Ravi and Kevin Knight. 2008. Attacking decipherment problems optimally with low-order n-gram models. In Proceedings of EMNLP.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Sujith Ravi</author>
<author>Kevin Knight</author>
</authors>
<title>Attacking letter substitution ciphers with integer programming.</title>
<date>2009</date>
<journal>Cryptologia,</journal>
<volume>33</volume>
<issue>4</issue>
<contexts>
<context position="4921" citStr="Ravi and Knight, 2009" startWordPosition="829" endWordPosition="832">etter substitution. These ciphers use a substitution table as the secret key. The ciphertext is generated by substituting each letter of the plaintext according to the substitution table. The table may be homophonic; that is, a single plaintext letter could map to more than one possible ciphertext letter. Just as in running key ciphers, spaces in the plaintext are usually removed before encoding. Proposed decipherment solutions for letter substitution ciphers include techniques that use expectation maximization (Ravi and Knight, 2008), genetic algorithms (Oranchak, 2008), integer programming (Ravi and Knight, 2009), A* decoding (Corlett and Penn, 2010), and Bayesian learning with Dirichlet processes (Ravi and Knight, 2011). 2.3 Vigen`ere Ciphers A scheme similar to the running key cipher is the Vigen`ere cipher, also known as the periodic key cipher. Instead of a single long string spanning the length of the plaintext, the key is a short string – usually but not always a single word or phrase – repeated to the length of the plaintext. Figure 2 shows an example Vigen`ere cipher encoding. This cipher is less secure than the running key, since the short length of the key vastly reduces the size of the sear</context>
</contexts>
<marker>Ravi, Knight, 2009</marker>
<rawString>Sujith Ravi and Kevin Knight. 2009. Attacking letter substitution ciphers with integer programming. Cryptologia, 33(4).</rawString>
</citation>
<citation valid="true">
<authors>
<author>Sujith Ravi</author>
<author>Kevin Knight</author>
</authors>
<title>Bayesian inference for Zodiac and other homophonic ciphers.</title>
<date>2011</date>
<booktitle>In Proceedings of ACL.</booktitle>
<contexts>
<context position="5031" citStr="Ravi and Knight, 2011" startWordPosition="845" endWordPosition="848">ubstituting each letter of the plaintext according to the substitution table. The table may be homophonic; that is, a single plaintext letter could map to more than one possible ciphertext letter. Just as in running key ciphers, spaces in the plaintext are usually removed before encoding. Proposed decipherment solutions for letter substitution ciphers include techniques that use expectation maximization (Ravi and Knight, 2008), genetic algorithms (Oranchak, 2008), integer programming (Ravi and Knight, 2009), A* decoding (Corlett and Penn, 2010), and Bayesian learning with Dirichlet processes (Ravi and Knight, 2011). 2.3 Vigen`ere Ciphers A scheme similar to the running key cipher is the Vigen`ere cipher, also known as the periodic key cipher. Instead of a single long string spanning the length of the plaintext, the key is a short string – usually but not always a single word or phrase – repeated to the length of the plaintext. Figure 2 shows an example Vigen`ere cipher encoding. This cipher is less secure than the running key, since the short length of the key vastly reduces the size of the search space, and the periodic repetition of the key leaks information. Recent work on decoding periodic key ciphe</context>
</contexts>
<marker>Ravi, Knight, 2011</marker>
<rawString>Sujith Ravi and Kevin Knight. 2011. Bayesian inference for Zodiac and other homophonic ciphers. In Proceedings of ACL.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Claude Shannon</author>
</authors>
<title>Communication theory of secrecy systems.</title>
<date>1949</date>
<journal>Bell System Technical Journal,</journal>
<volume>28</volume>
<issue>4</issue>
<contexts>
<context position="2267" citStr="Shannon, 1949" startWordPosition="390" endWordPosition="391">tabula recta. For a given ciphertext and known f, the plaintext uniquely determines the running key and vice versa. *Research conducted while the author was visiting ISI. Since we know that the plaintext and running key are both drawn from natural language, our objective function for the solution plaintext under some language model is: P� = arg max logPr(P) Pr(RP�C) (1) P where the running key RP�C is the key that corresponds to plaintext P and ciphertext C. Note that if RP�C is a perfectly random sequence of letters, this scheme is effectively a ‘one-time pad’, which is provably unbreakable (Shannon, 1949). The knowledge that both the plaintext and the key are natural language strings is important in breaking a running key cipher. The letter-frequency distribution of running key ciphertexts is notably flatter than than the plaintext distribution, unlike substitution ciphers where the frequency profile remains unchanged, modulo letter substitutions. However, the ciphertext letter distribution is not uniform; there are peaks corresponding to letters (like I) that are formed by high-frequency plaintext/key pairs (like E and E). 2 Related Work 2.1 Running Key Ciphers Bauer and Tate (2002) use lette</context>
</contexts>
<marker>Shannon, 1949</marker>
<rawString>Claude Shannon. 1949. Communication theory of secrecy systems. Bell System Technical Journal, 28(4).</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>