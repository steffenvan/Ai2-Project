<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000001">
<title confidence="0.994224">
Transfer Learning for Constituency-Based Grammars
</title>
<author confidence="0.993175">
Yuan Zhang, Regina Barzilay Amir Globerson
</author>
<affiliation confidence="0.995629">
Massachusetts Institute of Technology The Hebrew University
</affiliation>
<email confidence="0.998548">
{yuanzh, regina}@csail.mit.edu gamir@cs.huji.ac.il
</email>
<sectionHeader confidence="0.993887" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999982375">
In this paper, we consider the problem
of cross-formalism transfer in parsing.
We are interested in parsing constituency-
based grammars such as HPSG and CCG
using a small amount of data specific for
the target formalism, and a large quan-
tity of coarse CFG annotations from the
Penn Treebank. While all of the target
formalisms share a similar basic syntactic
structure with Penn Treebank CFG, they
also encode additional constraints and se-
mantic features. To handle this appar-
ent discrepancy, we design a probabilistic
model that jointly generates CFG and tar-
get formalism parses. The model includes
features of both parses, allowing trans-
fer between the formalisms, while pre-
serving parsing efficiency. We evaluate
our approach on three constituency-based
grammars — CCG, HPSG, and LFG, aug-
mented with the Penn Treebank-1. Our ex-
periments show that across all three for-
malisms, the target parsers significantly
benefit from the coarse annotations.1
</bodyText>
<sectionHeader confidence="0.999132" genericHeader="keywords">
1 Introduction
</sectionHeader>
<bodyText confidence="0.9997547">
Over the last several decades, linguists have in-
troduced many different grammars for describing
the syntax of natural languages. Moreover, the
ongoing process of developing new formalisms is
intrinsic to linguistic research. However, before
these grammars can be used for statistical pars-
ing, they require annotated sentences for training.
The difficulty of obtaining such annotations is a
key limiting factor that inhibits the effective use of
these grammars.
</bodyText>
<footnote confidence="0.993642333333333">
1The source code for the work is available at
http://groups.csail.mit.edu/rbg/code/
grammar/acl2013.
</footnote>
<bodyText confidence="0.999957">
The standard solution to this bottleneck has re-
lied on manually crafted transformation rules that
map readily available syntactic annotations (e.g,
the Penn Treebank) to the desired formalism. De-
signing these transformation rules is a major un-
dertaking which requires multiple correction cy-
cles and a deep understanding of the underlying
grammar formalisms. In addition, designing these
rules frequently requires external resources such
as Wordnet, and even involves correction of the
existing treebank. This effort has to be repeated
for each new grammar formalism, each new anno-
tation scheme and each new language.
In this paper, we propose an alternative ap-
proach for parsing constituency-based grammars.
Instead of using manually-crafted transformation
rules, this approach relies on a small amount of
annotations in the target formalism. Frequently,
such annotations are available in linguistic texts
that introduce the formalism. For instance, a
textbook on HPSG (Pollard and Sag, 1994) il-
lustrates grammatical constructions using about
600 examples. While these examples are infor-
mative, they are not sufficient for training. To
compensate for the annotation sparsity, our ap-
proach utilizes coarsely annotated data readily
available in large quantities. A natural candidate
for such coarse annotations is context-free gram-
mar (CFG) from the Penn Treebank, while the
target formalism can be any constituency-based
grammars, such as Combinatory Categorial Gram-
mar (CCG) (Steedman, 2001), Lexical Functional
Grammar (LFG) (Bresnan, 1982) or Head-Driven
Phrase Structure Grammar (HPSG) (Pollard and
Sag, 1994). All of these formalisms share a sim-
ilar basic syntactic structure with Penn Treebank
CFG. However, the target formalisms also encode
additional constraints and semantic features. For
instance, Penn Treebank annotations do not make
an explicit distinction between complement and
adjunct, while all the above grammars mark these
</bodyText>
<page confidence="0.967378">
291
</page>
<note confidence="0.914407">
Proceedings of the 51st Annual Meeting of the Association for Computational Linguistics, pages 291–301,
Sofia, Bulgaria, August 4-9 2013. c�2013 Association for Computational Linguistics
</note>
<bodyText confidence="0.999694">
roles explicitly. Moreover, even the identical syn-
tactic information is encoded differently in these
formalisms. An example of this phenomenon is
the marking of subject. In LFG, this informa-
tion is captured in the mapping equation, namely
↑ SBJ =↓, while Penn Treebank represents it as
a functional tag, such as NP-SBJ. Figure 1 shows
derivations in the three target formalisms we con-
sider, as well as a CFG derivation. We can see that
the derivations of these formalisms share the same
basic structure, while the formalism-specific infor-
mation is mainly encoded in the lexical entries and
node labels.
To enable effective transfer the model has to
identify shared structural components between
the formalisms despite the apparent differences.
Moreover, we do not assume parallel annotations.
To this end, our model jointly parses the two cor-
pora according to the corresponding annotations,
enabling transfer via parameter sharing. In partic-
ular, we augment each target tree node with hidden
variables that capture the connection to the coarse
annotations. Specifically, each node in the target
tree has two labels: an entry which is specific to
the target formalism, and a latent label containing
a value from the Penn Treebank tagset, such as NP
(see Figure 2). This design enables us to repre-
sent three types of features: the target formalism-
specific features, the coarse formalism features,
and features that connect the two. This model-
ing approach makes it possible to perform transfer
to a range of target formalisms, without manually
drafting formalism-specific rules.
We evaluate our approach on three
constituency-based grammars — CCG, HPSG,
and LFG. As a source of coarse annotations,
we use the Penn Treebank.2 Our results clearly
demonstrate that for all three formalisms, pars-
ing accuracy can be improved by training with
additional coarse annotations. For instance, the
model trained on 500 HPSG sentences achieves
labeled dependency F-score of 72.3%. Adding
15,000 Penn Treebank sentences during training
leads to 78.5% labeled dependency F-score, an
absolute improvement of 6.2%. To achieve similar
performance in the absence of coarse annotations,
the parser has to be trained on about 1,500
sentences, namely three times what is needed
when using coarse annotations. Similar results are
</bodyText>
<footnote confidence="0.976232333333333">
2While the Penn Treebank-2 contains richer annotations,
we decided to use the Penn Treebank-1 to demonstrate the
feasibility of transfer from coarse annotations.
</footnote>
<figureCaption confidence="0.9887155">
Figure 1: Derivation trees for CFG as well as
CCG, HPSG and LFG formalisms.
</figureCaption>
<bodyText confidence="0.812908">
also observed on CCG and LFG formalisms.
</bodyText>
<sectionHeader confidence="0.998813" genericHeader="introduction">
2 Related Work
</sectionHeader>
<bodyText confidence="0.999134914285714">
Our work belongs to a broader class of research
on transfer learning in parsing. This area has gar-
nered significant attention due to the expense asso-
ciated with obtaining syntactic annotations. Trans-
fer learning in parsing has been applied in differ-
ent contexts, such as multilingual learning (Sny-
der et al., 2009; Hwa et al., 2005; McDonald et
al., 2006; McDonald et al., 2011; Jiang and Liu,
2009), domain adaptation (McClosky et al., 2010;
Dredze et al., 2007; Blitzer et al., 2006), and cross-
formalism transfer (Hockenmaier and Steedman,
2002; Miyao et al., 2005; Cahill et al., 2002; Rie-
zler et al., 2002; Chen and Shanker, 2005; Candito
et al., 2010).
There have been several attempts to map anno-
tations in coarse grammars like CFG to annota-
tions in richer grammar, like HPSG, LFG, or CCG.
Traditional approaches in this area typically rely
on manually specified rules that encode the rela-
tion between the two formalisms. For instance,
mappings may specify how to convert traces and
functional tags in Penn Treebank to the f-structure
in LFG (Cahill, 2004). These conversion rules
are typically utilized in two ways: (1) to create a
new treebank which is consequently used to train a
parser for the target formalism (Hockenmaier and
Steedman, 2002; Clark and Curran, 2003; Miyao
et al., 2005; Miyao and Tsujii, 2008), (2) to trans-
late the output of a CFG parser into the target for-
malism (Cahill et al., 2002).
The design of these rules is a major linguis-
tic and computational undertaking, which requires
multiple iterations over the data to increase cov-
erage (Miyao et al., 2005; Oepen et al., 2004).
By nature, the mapping rules are formalism spe-
</bodyText>
<figure confidence="0.83790955">
TSBJ=1 T-1 TOBJ=1
[Pron.I] [ SBJ, OBJ] [N.3pl]
T T
NP VB NP
I eat apples
I eat apples
ROOT
S
T-1
VP
CFG S[dcl] CCG
LFG
[N.no3sg] [N&lt;V.bse&gt;N] [N.3pl]
NP (S[dcl]\NP)/NP NP
I eat apples
I eat apples
subj_head
head_comp
S[dcl]\NP
HPSG
</figure>
<page confidence="0.995651">
292
</page>
<bodyText confidence="0.999953862068966">
cific and therefore not transferable. Moreover, fre-
quently designing such mappings involves modifi-
cation to the original annotations. For instance,
Hockenmaier and Steedman (2002) made thou-
sands of POS and constituent modifications to the
Penn Treebank to facilitate transfer to CCG. More
importantly, in some transfer scenarios, determin-
istic rules are not sufficient, due to the high am-
biguity inherent in the mapping. Therefore, our
work considers an alternative set-up for cross-
formalism transfer where a small amount of an-
notations in the target formalism is used as an al-
ternative to using deterministic rules.
The limitation of deterministic transfer rules
has been recognized in prior work (Riezler et al.,
2002). Their method uses a hand-crafted LFG
parser to create a set of multiple parsing candi-
dates for a given sentence. Using the partial map-
ping from CFG to LFG as the guidance, the re-
sulting trees are ranked based on their consistency
with the labeled LFG bracketing imported from
CFG. In contrast to this method, we neither require
a parser for the target formalism, nor manual rules
for partial mapping. Consequently, our method
can be applied to many different target grammar
formalisms without significant engineering effort
for each one. The utility of coarse-grained tree-
banks is determined by the degree of structural
overlap with the target formalism.
</bodyText>
<sectionHeader confidence="0.974154" genericHeader="method">
3 The Learning Problem
</sectionHeader>
<bodyText confidence="0.9826168">
Recall that our goal is to learn how to parse the tar-
get formalisms while using two annotated sources:
a small set of sentences annotated in the target for-
malism (e.g., CCG), and a large set of sentences
with coarse annotations. For the latter, we use the
CFG parses from the Penn Treebank. For sim-
plicity we focus on the CCG formalism in what
follows. We also generalize our model to other
formalisms, as explained in Section 5.4.
Our notations are as follows: an input sentence
is denoted by S. A CFG parse is denoted by yCFG
and a CCG parse is denoted by yCCG. Clearly the
set of possible values for yCFG and yCCG is deter-
mined by S and the grammar. The training set is a
set of N sentences Si, ... , SN with CFG parses
</bodyText>
<equation confidence="0.8915065">
1N
yCFG , . . . , yCFG
</equation>
<bodyText confidence="0.9384906">
, and M sentences ¯S1, ... , ¯SM
with CCG parses y1CCG, . . . , yMCCG. It is impor-
tant to note that we do not assume we have parallel
data for CCG and CFG.
Our goal is to use such a corpus for learning
</bodyText>
<figure confidence="0.924949571428571">
coarse feature on yCFG
VP VP,NP
formalism feature on yCCG
S[dcl]\NP (S[dcl]\NP)/NP,NP
joint feature on yCFG, yCCG
VP, S[dcl]\NP
(VP, (S[dcl]\NP)/NP), (NP, NP)
</figure>
<figureCaption confidence="0.996581">
Figure 2: Illustration of the joint CCG-CFG representa-
tion. The shadowed labels correspond to the CFG deriva-
tion yCFG, whereas the other labels correspond to the CCG
derivation yCCG. Note that the two derivations share the
same (binarized) tree structure. Also shown are features that
are turned on for this joint derivation (see Section 6).
</figureCaption>
<bodyText confidence="0.908689">
how to generate CCG parses to unseen sentences.
</bodyText>
<sectionHeader confidence="0.992922" genericHeader="method">
4 A Joint Model for Two Formalisms
</sectionHeader>
<bodyText confidence="0.999945485714286">
The key idea behind our work is to learn a joint
distribution over CCG and CFG parses. Such a
distribution can be marginalized to obtain a distri-
bution over CCG or CFG and is thus appropriate
when the training data is not parallel, as it is in our
setting.
It is not immediately clear how to jointly model
the CCG and CFG parses, which are structurally
quite different. Furthermore, a joint distribution
over these will become difficult to handle com-
putationally if not constructed carefully. To ad-
dress this difficulty, we make several simplifying
assumptions. First, we assume that both parses are
given in normal form, i.e., they correspond to bi-
nary derivation trees. CCG parses are already pro-
vided in this form in CCGBank. CFG parses in the
Penn Treebank are not binary, and we therefore bi-
narize them, as explained in Section 5.3.
Second, we assume that any yCFG and yCCG
jointly generated must share the same derivation
tree structure. This makes sense. Since both for-
malisms are constituency-based, their trees are ex-
pected to describe the same constituents. We de-
note the set of valid CFG and CCG joint parses for
sentence S by Y(S).
The above two simplifying assumptions make
it easy to define joint features on the two parses,
as explained in Section 6. The representation and
features are illustrated in Figure 2.
We shall work within the discriminative frame-
work, where given a sentence we model a dis-
tribution over parses. As is standard in such
settings, the distribution will be log-linear in a
set of features of these parses. Denoting y =
(yCFG, yCCG), we seek to model the distribution
</bodyText>
<figure confidence="0.995748666666667">
S[dcl]\NP
VP
eat apples
VP
NP NP
(S[dcl]\NP)/NP
</figure>
<page confidence="0.996602">
293
</page>
<bodyText confidence="0.99886075">
p(y|S) corresponding to the probability of gen-
erating a pair of parses (CFG and CCG) given a
sentence. The distribution thus has the following
form:
</bodyText>
<equation confidence="0.99967">
pjoint(y|S; B) = 1 ef(y,S)&apos;θ
Z(S; B) (1)
</equation>
<bodyText confidence="0.999768642857143">
where B is a vector of parameters to be learned
from data, and f(y, S) is a feature vector. Z(S; B)
is a normalization (partition) function normalized
over y E Y(S) the set of valid joint parses.
The feature vector contains three types of fea-
tures: CFG specific, CCG specific and joint CFG-
CCG. We denote these by fCFG, fCCG, fjoint.
These depend on yCCG, yCFG and y respectively.
Accordingly, the parameter vector B is a concate-
nation of BCCG, BCFG and Bjoint.
As mentioned above, we can use Equation 1
to obtain distributions over yCCG and yCFG via
marginalization. For the distribution over yCCG
we do precisely this, namely use:
</bodyText>
<equation confidence="0.993431">
pCCG(yCCG|S; B) = X pjoint(y|S; B) (2)
yCFG
</equation>
<bodyText confidence="0.999958142857143">
For the distribution over yCFG we could have
marginalized pjoint over yCCG. However, this
computation is costly for each sentence, and has
to be repeated for all the sentences. Instead, we
assume that the distribution over yCFG is a log-
linear model with parameters BCFG (i.e., a sub-
vector of B) , namely:
</bodyText>
<equation confidence="0.9834365">
pCFG(yCFG|S; BCFG) =
(3)
</equation>
<bodyText confidence="0.999958166666667">
Thus, we assume that both pjoint and pCFG have
the same dependence on the fCFG features.
The Likelihood Objective: Given the models
above, it is natural to use maximum likelihood to
find the optimal parameters. To do this, we define
the following regularized likelihood function:
</bodyText>
<equation confidence="0.9896746">
N
L(B) = log (pCFG(yiCFG|Si, BCFG)) +
i=1
M log (pCCG(yiCCG |¯Si, B)) − λ2 IIBII22
i=1
</equation>
<bodyText confidence="0.999948736842105">
where pCCG and pCFG are defined in Equations
2 and 3 respectively. The last term is the l2-norm
regularization. Our goal is then to find a B that
maximizes L(B).
Training Algorithm: For maximizing L(B)
w.r.t. B we use the limited-memory BFGS algo-
rithm (Nocedal and Wright, 1999). Calculating
the gradient of L(B) requires evaluating the ex-
pected values of f(y, S) and fCFG under the dis-
tributions pjoint and pCFG respectively. This can
be done via the inside-outside algorithm.3
Parsing Using the Model: To parse a sentence
S, we calculate the maximum probability assign-
ment for pjoint(y|S; B).4 The result is both a CFG
and a CCG parse. Here we will mostly be inter-
ested in the CCG parse. The joint parse with max-
imum probability is found using a standard CYK
chart parsing algorithm. The chart construction
will be explained in Section 5.
</bodyText>
<sectionHeader confidence="0.996668" genericHeader="method">
5 Implementation
</sectionHeader>
<bodyText confidence="0.9998424">
This section introduces important implementa-
tion details, including supertagging, feature for-
est pruning and binarization methods. Finally,
we explain how to generalize our model to other
constituency-based formalisms.
</bodyText>
<subsectionHeader confidence="0.995929">
5.1 Supertagging
</subsectionHeader>
<bodyText confidence="0.999952153846154">
When parsing a target formalism tree, one needs
to associate each word with a lexical entry. How-
ever, since the number of candidates is typically
more than one thousand, the size of the chart ex-
plodes. One effective way of reducing the number
of candidates is via supertagging (Clark and Cur-
ran, 2007). A supertagger is used for selecting a
small set of lexical entry candidates for each word
in the sentence. We use the tagger in (Clark and
Curran, 2007) as a general suppertagger for all the
grammars considered. The only difference is that
we use different lexical entries in different gram-
mars.
</bodyText>
<subsectionHeader confidence="0.99679">
5.2 Feature Forest Pruning
</subsectionHeader>
<bodyText confidence="0.999933">
In the BFGS algorithm (see Section 4), feature ex-
pectation is computed using the inside-outside al-
gorithm. To perform this dynamic programming
efficiently, we first need to build the packed chart,
namely the feature forest (Miyao, 2006) to rep-
resent the exponential number of all possible tree
</bodyText>
<footnote confidence="0.974036">
3To speed up the implementation, gradient computation
is parallelized, using the Message Passing Interface pack-
age (Gropp et al., 1999).
4An alternative approach would be to marginalize over
yCFG and maximize over yCCG. However, this is a harder
computational problem.
</footnote>
<equation confidence="0.5999135">
efCFG(yCFG,S)&apos;θCFG
Z(S; BCFG) .
</equation>
<page confidence="0.988947">
294
</page>
<bodyText confidence="0.999892916666667">
structures. However, a common problem for lex-
icalized grammars is that the forest size is too
large. In CFG, the forest is pruned according to
the inside probability of a simple generative PCFG
model and a prior (Collins, 2003). The basic idea
is to prune the trees with lower probability. For the
target formalism, a common practice is to prune
the forest using the supertagger (Clark and Cur-
ran, 2007; Miyao, 2006). In our implementation,
we applied all pruning techniques, because the for-
est is a combination of CFG and target grammar
formalisms (e.g., CCG or HPSG).
</bodyText>
<subsectionHeader confidence="0.985237">
5.3 Binarization
</subsectionHeader>
<bodyText confidence="0.999950111111111">
We assume that the derivation tree in the target for-
malism is in a normal form, which is indeed the
case for the treebanks we consider. As mentioned
in Section 4, we would also like to work with bi-
narized CFG derivations, such that all trees are in
normal form and it is easy to construct features
that link the two (see Section 6).
Since Penn Treebank trees are not binarized, we
construct a simple procedure for binarizing them.
The procedure is based on the available target for-
malism parses in the training corpus, which are bi-
narized. We illustrate it with an example. In what
follows, we describe derivations using the POS of
the head words of the corresponding node in the
tree. This makes it possible to transfer binariza-
tion rules between formalisms.
Suppose we want to learn the binarization rule
of the following derivation in CFG:
</bodyText>
<equation confidence="0.90773">
NN → (DT JJ NN) (4)
</equation>
<bodyText confidence="0.9997678">
We now look for binary derivations with these
POS in the target formalism corpus, and take the
most common binarization form. For example, we
may find that the most common binarization to bi-
narize the CFG derivation in Equation 4 is:
</bodyText>
<equation confidence="0.5644">
NN → (DT (JJ NN))
</equation>
<bodyText confidence="0.9997845">
If no (DT JJ NN) structure is observed in the
CCG corpus, we first apply the binary branching
on the children to the left of the head, and then on
the children to the right of the head.
We also experiment with using fixed binariza-
tion rules such as left/right branching, instead of
learning them. This results in a drop on the depen-
dency F-score by about 5%.
</bodyText>
<subsectionHeader confidence="0.977291">
5.4 Implementation in Other Formalisms
</subsectionHeader>
<bodyText confidence="0.9999046">
We introduce our model in the context of CCG,
but the model can easily be generalized to other
constituency-based grammars, such as HPSG and
LFG. In a derivation tree, the formalism-specific
information is mainly encoded in the lexical en-
tries and the applied grammar rules, rather than the
tree structures. Therefore we only need to change
the node labels and lexical entries to the language-
specific ones, while the framework of the model
remains the same.
</bodyText>
<sectionHeader confidence="0.999799" genericHeader="method">
6 Features
</sectionHeader>
<bodyText confidence="0.984890647058823">
Feature functions in log-linear models are de-
signed to capture the characteristics of each
derivation in the tree. In our model, as mentioned
in Section 1, the features are also defined to en-
able information transfer between coarse and rich
formalisms. In this section, we first introduce how
different types of feature templates are designed,
and then show an example of how the features help
transfer the syntactic structure information. Note
that the same feature templates are used for all the
target grammar formalisms.
Recall that our y contains both the CFG and
CCG parses, and that these use the same derivation
tree structure. Each feature will consider either the
CFG derivation, the CCG derivation or these two
derivations jointly.
The feature construction is similar to construc-
</bodyText>
<tableCaption confidence="0.84875675">
tions used in previous work (Miyao, 2006). The
features are based on the atomic features listed in
Table 1. These will be used to construct f(y, S) as
explained next.
</tableCaption>
<table confidence="0.6746152">
hl lexical entries/CCG categories of the head word
r grammar rules, i.e. HPSG schema, resulting CCG
categories, LFG mapping equations
sy CFG syntactic label of the node (e.g. NP, VP)
d distance between the head words of the children
</table>
<bodyText confidence="0.839548166666667">
c whether a comma exists between the head words
of the children
sp the span of the subtree rooted at the node
hw surface form of the head word of the node
hp part-of-speech of the head word
pi part-of-speech of the i-th word in the sentence
</bodyText>
<tableCaption confidence="0.991451">
Table 1: Templates of atomic features.
</tableCaption>
<bodyText confidence="0.999983">
We define the following feature templates:
fbinary for binary derivations, funary for unary
derivations, and froot for the root nodes. These
use the atomic features in Table 1, resulting in the
</bodyText>
<page confidence="0.98958">
295
</page>
<figure confidence="0.709912263157895">
following templates:
� r,syp,d,c
syl, spl, hwl, hpl, hll,
fbinary = syr, spr, hwr, hpr, hlr,
pst−1, pst−2, pen+1, pen+2
funary = (r, syp, hw, hp, hl)
fCFG(y,S): fCFG(y,S) :
Penn Treebank CCGbank
write letters eat apples
VP
NP
VP
(S[dcl]\NP)/NP
VP
S[dcl]\NP
NP NP
VP
VP VP,NP VP VP,NP
froot = (sy, hw, hp, hl)
</figure>
<bodyText confidence="0.994044482758621">
In the above we used the following notation: p,l, r
denote the parent node and left/right child node,
and st, en denote the starting and ending index of
the constituent.
We also consider templates with subsets of the
above features. The final list of binary feature tem-
plates is shown in Table 2. It can be seen that some
features depend only on the CFG derivations (i.e.,
those without r,hl), and are thus in fCFG(y, S).
Others depend only on CCG derivations (i.e.,
those without sy), and are in fCCG(y, S). The
rest depend on both CCG and CFG and are thus
in fjoint(y, S).
Note that after binarization, grandparent and
sibling information becomes very important in en-
coding the structure. However, we limit the fea-
tures to be designed locally in a derivation in order
to run inside-outside efficiently. Therefore we use
the preceding and succeeding POS tag information
to approximate the grandparent and sibling infor-
mation. Empirically, these features yield a signifi-
cant improvement on the constituent accuracy.
Table 2: Binary feature templates used in f(y, S).
Unary and root features follow a similar pattern.
In order to apply the same feature templates to
other target formalisms, we only need to assign
the atomic features r and hl with the formalism-
specific values. We do not need extra engineering
work on redesigning the feature templates.
</bodyText>
<equation confidence="0.9351412">
k.(Y,S) :
S[dcl]\NP (S[dcl]\NP)/NP,NP
fj�.(y,S) :
VP, S[dcl]\NP
(VP, (S[dcl]\NP)/NP), (NP, NP)
</equation>
<figureCaption confidence="0.996454">
Figure 3: Example of transfer between CFG and
CCG formalisms.
</figureCaption>
<bodyText confidence="0.8829513125">
Figure 3 gives an example in CCG of how
features help transfer the syntactic information
from Penn Treebank and learn the correspondence
to the formalism-specific information. From the
Penn Treebank CFG annotations, we can learn
that the derivation VP→(VP, NP) is common, as
shown on the left of Figure 3. In a CCG tree, this
tendency will encourage the yCFG (latent) vari-
ables to take this CFG parse. Then weights on the
fjoint features will be learned to model the con-
nection between the CFG and CCG labels. More-
over, the formalism-specific features fCCG can
also encode the formalism-specific syntactic and
semantic information. These three types of fea-
tures work together to generate a tree skeleton and
fill in the CFG and CCG labels.
</bodyText>
<sectionHeader confidence="0.991982" genericHeader="method">
7 Evaluation Setup
</sectionHeader>
<table confidence="0.999181">
Grammar Train Dev. Test
CCG Sec. 02-21 Sec. 00 Sec. 23
HPSG
LFG 140 sents. in 560 sents. in
PARC700 PARC700
</table>
<tableCaption confidence="0.8439255">
Table 3: Training/Dev./Test split on WSJ sections
and PARC700 for different grammar formalisms.
</tableCaption>
<bodyText confidence="0.9991614">
Datasets: As a source of coarse annotations, we
use the Penn Treebank-1 (Marcus et al., 1993). In
addition, for CCG, HPSG and LFG, we rely on
formalism-specific corpora developed in prior re-
search (Hockenmaier and Steedman, 2002; Miyao
et al., 2005; Cahill et al., 2002; King et al., 2003).
All of these corpora were derived via conversion
of Penn Treebank to the target formalisms. In par-
ticular, our CCG and HPSG datasets were con-
verted from the Penn Treebank based on hand-
</bodyText>
<equation confidence="0.907641315789474">
(d, wl,r, hpl,r, syp,l,r), (d, wl,r, syp,l,r),
(c, wl,r, hpl,r, syp,l,r), (c, wl,r, syp,l,r),
(d, c, hpl,r, syp,l,r), (d, c, syp,l,r),
(c, spl,r, hpl,r, syp,l,r), (c, spl,r, syp,l,r),
(pst−1, syp,l,r), (pen+1, syp,l,r),
(pst−1, pen+1, syp,l,r),
(pst−1, pst−2, syp,l,r), (pen+1, pen+2, syp,l,r),
(pst−1, pst−2, pen+1, pen+2, syp,l,r),
(r, d, c, hwl,r, hpl,r, hll,r), (r, d, c, hwl,r, hpl,r)
(r, d, c, hwl,r, hll,r),
(r, c, spl,r, hwl,r, hpl,r, hll,r)
(r, c, spl,r, hwl,r, hpl,r, ), (r, c, spl,r, hwl,r, hll,r)
(r, d, c, hpl,r, hll,r), (r, d, c, hpl,r), (r, d, c, hll,r)
(r, c, hpl,r, hll,r), (r, c, hpl,r), (r, c, hll,r)
(r, d, c, syl,r, hll,r), (r, d, c, syl,r)
(r, c, spl,r, syl,r, hll,r), (r, c, spl,r, syl,r)
fCFG
fCCG
fjoint
</equation>
<page confidence="0.937695">
296
</page>
<figure confidence="0.987433727272727">
88
86
84
82
80
78
76
740 1000 3000 7000 11000 15000
(a) CCG
0 1000 3000 7000 11000 15000
(b) HPSG
86
84
82
80
78
76
74
72
Labeled Dep
Unlabeled Dep
Unlabeled Parseval
80
75
70
Labeled Dep
Unlabeled Dep
Unlabeled Parseval
65 0 1000 3000 7000 11000 15000
(c) LFG
Labeled Dep
Unlabeled Dep
Unlabeled Parseval
</figure>
<figureCaption confidence="0.99851">
Figure 4: Model performance with 500 target formalism trees and different numbers of CFG trees,
evaluated using labeled/unlabeled dependency F-score and unlabeled PARSEVAL.
</figureCaption>
<bodyText confidence="0.99055745945946">
crafted rules (Hockenmaier and Steedman, 2002;
Miyao et al., 2005). Table 3 shows which sec-
tions of the treebanks were used in training, test-
ing and development for both formalisms. Our
LFG training dataset was constructed in a sim-
ilar fashion (Cahill et al., 2002). However, we
choose to use PARC700 as our LFG tesing and de-
velopment datasets, following the previous work
by (Kaplan et al., 2004). It contains 700 man-
ually annotated sentences that are randomly se-
lected from Penn Treebank Section 23. The split
of PARC700 follows the setting in (Kaplan et al.,
2004). Since our model does not assume parallel
data, we use distinct sentences in the source and
target treebanks. Following previous work (Hock-
enmaier, 2003; Miyao and Tsujii, 2008), we only
consider sentences not exceeding 40 words, except
on PARC700 where all sentences are used.
Evaluation Metrics: We use two evaluation
metrics. First, following previous work, we eval-
uate our method using the labeled and unlabeled
predicate-argument dependency F-score. This
metric is commonly used to measure parsing qual-
ity for the formalisms considered in this paper.
The detailed definition of this measure as applied
for each formalism is provided in (Clark and Cur-
ran, 2003; Miyao and Tsujii, 2008; Cahill et al.,
2004). For CCG, we use the evaluation script
from the C&amp;C tools.5 For HPSG, we evaluate
all types of dependencies, including punctuations.
For LFG, we consider the preds-only dependen-
cies, which are the dependencies between pairs
of words. Secondly, we also evaluate using unla-
beled PARSEVAL, a standard measure for PCFG
parsing (Petrov and Klein, 2007; Charniak and
Johnson, 2005; Charniak, 2000; Collins, 1997).
The dependency F-score captures both the target-
</bodyText>
<footnote confidence="0.992294">
5Available at http://svn.ask.it.usyd.edu.au/trac/candc/wiki
</footnote>
<bodyText confidence="0.995673095238095">
grammar labels and tree-structural relations. The
unlabeled PARSEVAL is used as an auxiliary mea-
sure that enables us to separate these two aspects
by focusing on the structural relations exclusively.
Training without CFG Data: To assess the
impact of coarse data in the experiments be-
low, we also consider the model trained only on
formalism-specific annotations. When no CFG
sentences are available, we assign all the CFG la-
bels to a special value shared by all the nodes. In
this set-up, the model reduces to a normal log-
linear model for the target formalism.
Parameter Settings: During training, all the
feature parameters θ are initialized to zero. The
hyperparameters used in the model are tuned on
the development sets. We noticed, however, that
the resulting values are consistent across differ-
ent formalisms. In particular, we set the l2-norm
weight to A = 1.0, the supertagger threshold to
β = 0.01, and the PCFG pruning threshold to
α = 0.002.
</bodyText>
<sectionHeader confidence="0.951997" genericHeader="evaluation">
8 Experiment and Analysis
</sectionHeader>
<subsectionHeader confidence="0.518521">
Impact of Coarse Annotations on Target For-
</subsectionHeader>
<bodyText confidence="0.999876142857143">
malism: To analyze the effectiveness of annota-
tion transfer, we fix the number of annotated trees
in the target formalism and vary the amount of
coarse annotations available to the algorithm dur-
ing training. In particular, we use 500 sentences
with formalism-specific annotations, and vary the
number of CFG trees from zero to 15,000.
As Figure 4 shows, CFG data boosts parsing ac-
curacy for all the target formalisms. For instance,
there is a gain of 6.2% in labeled dependency
F-score for HPSG formalism when 15,000 CFG
trees are used. Moreover, increasing the number
of coarse annotations used in training leads to fur-
ther improvement on different evaluation metrics.
</bodyText>
<page confidence="0.986619">
297
</page>
<figure confidence="0.9984974375">
0 1000 2000 3000 4000 5000 6000
(b) HPSG
0 1000 2000 3000 4000 5000 6000
(c) LFG
84
82
80
78
76
74
72
w/o CFG
15000 CFG
78
76
74
72
70
68
66
w/o CFG
15000 CFG
86
84
82
80
78
76
74
72
70
0 1000 2000 3000 4000 5000 6000
0 1000 2000 3000 4000 5000 6000
w/o CFG
15000 CFG
w/o CFG
15000 CFG
84
82
80
78
76
74
72
70
68
(e) HPSG (f) LFG
(a) CCG
(d) CCG
w/o CFG
15000 CFG
1000 2000 3000 4000 5000 6000
75
74
0
84
83
82
81
80
79
78
77
76
w/o CFG
15000 CFG
1000 2000 3000 4000 5000 6000
78
77
0
88
87
86
85
84
83
82
81
80
79
</figure>
<figureCaption confidence="0.93245">
Figure 5: Model performance with different target formalism trees and zero or 15,000 CFG trees. The
first row shows the results of labeled dependency F-score and the second row shows the results of unla-
beled PARSEVAL.
</figureCaption>
<bodyText confidence="0.988065470588235">
Tradeoff between Target and Coarse Annota-
tions: We also assess the relative contribution
of coarse annotations when the size of annotated
training corpus in the target formalism varies. In
this set of experiments, we fix the number of CFG
trees to 15,000 and vary the number of target an-
notations from 500 to 4,000. Figure 5 shows
the relative contribution of formalism-specific an-
notations compared to that of the coarse annota-
tions. For instance, Figure 5a shows that the pars-
ing performance achieved using 2,000 CCG sen-
tences can be achieved using approximately 500
CCG sentences when coarse annotations are avail-
able for training. More generally, the result con-
vincingly demonstrates that coarse annotations are
helpful for all the sizes of formalism-specific train-
ing data. As expected, the improvement margin
decreases when more formalism-specific data is
used.
Figure 5 also illustrates a slightly different char-
acteristics of transfer performance between two
evaluation metrics. Across all three grammars,
we can observe that adding CFG data has a
more pronounced effect on the PARSEVAL mea-
sure than the dependency F-score. This phe-
nomenon can be explained as follows. The un-
labeled PARSEVAL score (Figure 5d-f) mainly re-
lies on the coarse structural information. On
the other hand, predicate-argument dependency F-
score (Figure 5a-c) also relies on the target gram-
mar information. Because that our model only
transfers structural information from the source
treebank, the gains of PARSEVAL are expected to
be larger than that of dependency F-score.
</bodyText>
<table confidence="0.999584">
Grammar Parser # Grammar trees
1,000 15,000
CCG C&amp;C 74.1 / 83.4 82.6 / 90.1
Model 76.8 / 85.5 84.7 / 90.9
HPSG Enju 75.8 / 80.6 84.2 / 87.3
Model 76.9 / 82.0 84.9 / 88.3
LFG Pipeline 68.5 / 74.0 82.6 / 85.9
Annotator
Model 69.8 / 76.6 81.1 / 84.7
</table>
<tableCaption confidence="0.755090333333333">
Table 4: The labeled/unlabeled dependency F-
score comparisons between our model and state-
of-the-art parsers.
</tableCaption>
<bodyText confidence="0.969964055555556">
Comparison to State-of-the-art Parsers: We
would also like to demonstrate that the above
gains of our transfer model are achieved using
an adequate formalism-specific parser. Since our
model can be trained exclusively on formalism-
specific data, we can compare it to state-of-the-
art formalism-specific parsers. For this experi-
ment, we choose the C&amp;C parser (Clark and Cur-
ran, 2003) for CCG, Enju parser (Miyao and Tsu-
jii, 2008) for HPSG and pipeline automatic an-
notator (Cahill et al., 2004) with Charniak parser
for LFG. For all three parsers, we use the imple-
mentation provided by the authors with the default
parameter values. All the models are trained on
either 1,000 or 15,000 sentences annotated with
formalism-specific trees, thus evaluating their per-
formances on small scale or large scale of data.
As Table 4 shows, our model is competitive with
</bodyText>
<page confidence="0.991228">
298
</page>
<bodyText confidence="0.983588666666667">
all the baselines described above. It’s not sur-
prising that Cahill’s model outperforms our log-
linear model because it relies heavily on hand-
crafted rules optimized for the dataset.
Correspondence between CFG and Target For-
malisms: Finally, we analyze highly weighted
features. Table 5 shows such features for HPSG;
similar patterns are also found for the other
grammar formalisms. The first two features are
formalism-specific ones, the first for HPSG and
the second for CFG. They show that we correctly
learn a frequent derivation in the target formalism
and CFG. The third one shows an example of a
connection between CFG and the target formal-
ism. Our model correctly learns that a syntactic
derivation with children VP and NP is very likely
to be mapped to the derivation (head comp)→
([N(V) N],[N.3sg]) in HPSG.
</bodyText>
<table confidence="0.991951133333334">
Feature type Features with high weight
Target Template
formalism (r) —+ (hll, hpl)(hlr, pr)
Examples
(head comp)—+
([N(V)N],VB)([N.3sg],NN)
Coarse Template
formalism (syp) —+ (syl, hpl)(syr, hpr)
Examples
(VP)—+(VP,VB)(NP,NN)
Joint Template
features (r) —+ (hll, syl)(ler, syr)
Examples
(head comp)—+
([N(V)N],VP)([N.3sg],NP)
</table>
<tableCaption confidence="0.998552">
Table 5: Example features with high weight.
</tableCaption>
<sectionHeader confidence="0.988449" genericHeader="conclusions">
9 Conclusions
</sectionHeader>
<bodyText confidence="0.999963875">
We present a method for cross-formalism trans-
fer in parsing. Our model utilizes coarse syn-
tactic annotations to supplement a small num-
ber of formalism-specific trees for training on
constituency-based grammars. Our experimen-
tal results show that across a range of such for-
malisms, the model significantly benefits from the
coarse annotations.
</bodyText>
<sectionHeader confidence="0.998296" genericHeader="acknowledgments">
Acknowledgments
</sectionHeader>
<bodyText confidence="0.999735818181818">
The authors acknowledge the support of the Army
Research Office (grant 1130128-258552). We
thank Yusuke Miyao, Ozlem Cetinoglu, Stephen
Clark, Michael Auli and Yue Zhang for answering
questions and sharing the codes of their work. We
also thank the members of the MIT NLP group
and the ACL reviewers for their suggestions and
comments. Any opinions, findings, conclusions,
or recommendations expressed in this paper are
those of the authors, and do not necessarily reflect
the views of the funding organizations.
</bodyText>
<sectionHeader confidence="0.998479" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.99819085106383">
John Blitzer, Ryan McDonald, and Fernando Pereira.
2006. Domain adaptation with structural correspon-
dence learning. In Proceedings of the 2006 Con-
ference on Empirical Methods in Natural Language
Processing, pages 120–128. Association for Com-
putational Linguistics.
Joan Bresnan. 1982. The mental representation of
grammatical relations, volume 1. The MIT Press.
Aoife Cahill, Mairad McCarthy, Josef van Genabith,
and Andy Way. 2002. Parsing with pcfgs and au-
tomatic f-structure annotation. In Proceedings of
the Seventh International Conference on LFG, pages
76–95. CSLI Publications.
Aoife Cahill, Michael Burke, Ruth O’Donovan, Josef
Van Genabith, and Andy Way. 2004. Long-distance
dependency resolution in automatically acquired
wide-coverage pcfg-based lfg approximations. In
Proceedings of the 42nd Annual Meeting on Associ-
ation for Computational Linguistics, page 319. As-
sociation for Computational Linguistics.
Aoife Cahill. 2004. Parsing with Automatically Ac-
quired, Wide-Coverage, Robust, Probabilistic LFG
Approximation. Ph.D. thesis.
Marie Candito, Benoit Crabb´e, Pascal Denis, et al.
2010. Statistical french dependency parsing: tree-
bank conversion and first results. In Proceed-
ings of the Seventh International Conference on
Language Resources and Evaluation (LREC 2010),
pages 1840–1847.
Eugene Charniak and Mark Johnson. 2005. Coarse-
to-fine n-best parsing and maxent discriminative
reranking. In Proceedings of the 43rd Annual Meet-
ing on Association for Computational Linguistics,
pages 173–180. Association for Computational Lin-
guistics.
Eugene Charniak. 2000. A maximum-entropy-
inspired parser. In Proceedings of the 1st North
American chapter of the Association for Computa-
tional Linguistics conference, pages 132–139.
John Chen and Vijay K Shanker. 2005. Automated
extraction of tags from the penn treebank. New de-
velopments in parsing technology, pages 73–89.
Stephen Clark and James R Curran. 2003. Log-linear
models for wide-coverage ccg parsing. In Proceed-
ings of the 2003 conference on Empirical methods
in natural language processing, pages 97–104. As-
sociation for Computational Linguistics.
</reference>
<page confidence="0.978728">
299
</page>
<reference confidence="0.999547411214953">
Stephen Clark and James R Curran. 2007. Wide-
coverage efficient statistical parsing with ccg and
log-linear models. Computational Linguistics,
33(4):493–552.
Michael Collins. 1997. Three generative, lexicalised
models for statistical pprsing. In Proceedings of the
eighth conference on European chapter of the Asso-
ciation for Computational Linguistics, pages 16–23.
Association for Computational Linguistics.
Michael Collins. 2003. Head-driven statistical mod-
els for natural language parsing. Computational lin-
guistics, 29(4):589–637.
Mark Dredze, John Blitzer, Partha Pratim Talukdar,
Kuzman Ganchev, Joao V Grac¸a, and Fernando
Pereira. 2007. Frustratingly hard domain adap-
tation for dependency parsing. In Proceedings of
the CoNLL Shared Task Session of EMNLP-CoNLL,
volume 2007.
William Gropp, Ewing Lusk, and Anthony Skjellum.
1999. Using MPI: portable parallel programming
with the message passing interface, volume 1. MIT
press.
Julia Hockenmaier and Mark Steedman. 2002.
Acquiring compact lexicalized grammars from a
cleaner treebank. In Proceedings of the Third LREC
Conference, pages 1974–1981.
Julia Hockenmaier. 2003. Data and models for statis-
tical parsing with combinatory categorial grammar.
Rebecca Hwa, Philip Resnik, and Amy Weinberg.
2005. Breaking the resource bottleneck for multi-
lingual parsing. Technical report, DTIC Document.
Wenbin Jiang and Qun Liu. 2009. Automatic adap-
tation of annotation standards for dependency pars-
ing: using projected treebank as source corpus. In
Proceedings of the 11th International Conference on
Parsing Technologies, pages 25–28. Association for
Computational Linguistics.
Ronald M. Kaplan, Stefan Riezler, Tracy H. King, John
T. Maxwell III, Alexander Vasserman, and Richard
Crouch. 2004. Speed and accuracy in shallow and
deep stochastic parsing. In Proceedings of NAACL.
Tracy Holloway King, Richard Crouch, Stefan Riezler,
Mary Dalrymple, and Ronald M Kaplan. 2003. The
parc 700 dependency bank. In Proceedings of the
EACL03: 4th International Workshop on Linguisti-
cally Interpreted Corpora (LINC-03), pages 1–8.
Mitchell P Marcus, Mary Ann Marcinkiewicz, and
Beatrice Santorini. 1993. Building a large anno-
tated corpus of english: The penn treebank. Compu-
tational linguistics, 19(2):313–330.
David McClosky, Eugene Charniak, and Mark John-
son. 2010. Automatic domain adaptation for pars-
ing. In Human Language Technologies: The 2010
Annual Conference of the North American Chap-
ter of the Association for Computational Linguistics,
pages 28–36. Association for Computational Lin-
guistics.
Ryan McDonald, Kevin Lerman, and Fernando Pereira.
2006. Multilingual dependency analysis with a two-
stage discriminative parser. In Proceedings of the
Tenth Conference on Computational Natural Lan-
guage Learning, pages 216–220. Association for
Computational Linguistics.
Ryan McDonald, Slav Petrov, and Keith Hall. 2011.
Multi-source transfer of delexicalized dependency
parsers. In Proceedings of the Conference on Em-
pirical Methods in Natural Language Processing,
pages 62–72. Association for Computational Lin-
guistics.
Yusuke Miyao and Jun’ichi Tsujii. 2008. Feature for-
est models for probabilistic hpsg parsing. Computa-
tional Linguistics, 34(1):35–80.
Yusuke Miyao, Takashi Ninomiya, and Junichi Tsu-
jii. 2005. Corpus-oriented grammar development
for acquiring a head-driven phrase structure gram-
mar from the penn treebank. Natural Language
Processing–IJCNLP 2004, pages 684–693.
Yusuke Miyao. 2006. From Linguistic Theory to Syn-
tactic Analysis: Corpus-Oriented Grammar Devel-
opment and Feature Forest Model. Ph.D. thesis.
Jorge Nocedal and Stephen J Wright. 1999. Numerical
optimization. Springer verlag.
Stephan Oepen, Dan Flickinger, and Francis Bond.
2004. Towards holistic grammar engineering
and testing–grafting treebank maintenance into the
grammar revision cycle. In Proceedings of the IJC-
NLP workshop beyond shallow analysis. Citeseer.
Slav Petrov and Dan Klein. 2007. Improved infer-
ence for unlexicalized parsing. In Human Language
Technologies 2007: The Conference of the North
American Chapter of the Association for Computa-
tional Linguistics, pages 404–411.
Carl Pollard and Ivan A Sag. 1994. Head-driven
phrase structure grammar. University of Chicago
Press.
Stefan Riezler, Tracy H King, Ronald M Kaplan,
Richard Crouch, John T Maxwell III, and Mark
Johnson. 2002. Parsing the wall street journal us-
ing a lexical-functional grammar and discriminative
estimation techniques. In Proceedings of the 40th
Annual Meeting on Association for Computational
Linguistics, pages 271–278. Association for Com-
putational Linguistics.
Benjamin Snyder, Tahira Naseem, and Regina Barzi-
lay. 2009. Unsupervised multilingual grammar in-
duction. In Proceedings of the Joint Conference
of the 47th Annual Meeting of the ACL and the
</reference>
<page confidence="0.970953">
300
</page>
<reference confidence="0.9978924">
4th International Joint Conference on Natural Lan-
guage Processing of the AFNLP: Volume 1-Volume
1, pages 73–81. Association for Computational Lin-
guistics.
Mark Steedman. 2001. The syntactic process. MIT
press.
Yue Zhang, Stephen Clark, et al. 2011. Shift-reduce
ccg parsing. In Proceedings of the 49th Meeting
of the Association for Computational Linguistics,
pages 683–692.
</reference>
<page confidence="0.9989">
301
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.700816">
<title confidence="0.999954">Transfer Learning for Constituency-Based Grammars</title>
<author confidence="0.99838">Yuan Zhang</author>
<author confidence="0.99838">Regina Barzilay Amir Globerson</author>
<affiliation confidence="0.999937">Massachusetts Institute of Technology The Hebrew University</affiliation>
<email confidence="0.991423">gamir@cs.huji.ac.il</email>
<abstract confidence="0.98768532">In this paper, we consider the problem of cross-formalism transfer in parsing. We are interested in parsing constituencybased grammars such as HPSG and CCG using a small amount of data specific for the target formalism, and a large quantity of coarse CFG annotations from the Penn Treebank. While all of the target formalisms share a similar basic syntactic structure with Penn Treebank CFG, they also encode additional constraints and semantic features. To handle this apparent discrepancy, we design a probabilistic model that jointly generates CFG and target formalism parses. The model includes features of both parses, allowing transfer between the formalisms, while preserving parsing efficiency. We evaluate our approach on three constituency-based grammars — CCG, HPSG, and LFG, augmented with the Penn Treebank-1. Our experiments show that across all three formalisms, the target parsers significantly from the coarse</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>John Blitzer</author>
<author>Ryan McDonald</author>
<author>Fernando Pereira</author>
</authors>
<title>Domain adaptation with structural correspondence learning.</title>
<date>2006</date>
<booktitle>In Proceedings of the 2006 Conference on Empirical Methods in Natural Language Processing,</booktitle>
<pages>120--128</pages>
<publisher>Association</publisher>
<institution>for Computational Linguistics.</institution>
<contexts>
<context position="6955" citStr="Blitzer et al., 2006" startWordPosition="1047" endWordPosition="1050">ns. Figure 1: Derivation trees for CFG as well as CCG, HPSG and LFG formalisms. also observed on CCG and LFG formalisms. 2 Related Work Our work belongs to a broader class of research on transfer learning in parsing. This area has garnered significant attention due to the expense associated with obtaining syntactic annotations. Transfer learning in parsing has been applied in different contexts, such as multilingual learning (Snyder et al., 2009; Hwa et al., 2005; McDonald et al., 2006; McDonald et al., 2011; Jiang and Liu, 2009), domain adaptation (McClosky et al., 2010; Dredze et al., 2007; Blitzer et al., 2006), and crossformalism transfer (Hockenmaier and Steedman, 2002; Miyao et al., 2005; Cahill et al., 2002; Riezler et al., 2002; Chen and Shanker, 2005; Candito et al., 2010). There have been several attempts to map annotations in coarse grammars like CFG to annotations in richer grammar, like HPSG, LFG, or CCG. Traditional approaches in this area typically rely on manually specified rules that encode the relation between the two formalisms. For instance, mappings may specify how to convert traces and functional tags in Penn Treebank to the f-structure in LFG (Cahill, 2004). These conversion rule</context>
</contexts>
<marker>Blitzer, McDonald, Pereira, 2006</marker>
<rawString>John Blitzer, Ryan McDonald, and Fernando Pereira. 2006. Domain adaptation with structural correspondence learning. In Proceedings of the 2006 Conference on Empirical Methods in Natural Language Processing, pages 120–128. Association for Computational Linguistics.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Joan Bresnan</author>
</authors>
<title>The mental representation of grammatical relations,</title>
<date>1982</date>
<volume>1</volume>
<publisher>The MIT Press.</publisher>
<contexts>
<context position="3280" citStr="Bresnan, 1982" startWordPosition="476" endWordPosition="477">rmalism. For instance, a textbook on HPSG (Pollard and Sag, 1994) illustrates grammatical constructions using about 600 examples. While these examples are informative, they are not sufficient for training. To compensate for the annotation sparsity, our approach utilizes coarsely annotated data readily available in large quantities. A natural candidate for such coarse annotations is context-free grammar (CFG) from the Penn Treebank, while the target formalism can be any constituency-based grammars, such as Combinatory Categorial Grammar (CCG) (Steedman, 2001), Lexical Functional Grammar (LFG) (Bresnan, 1982) or Head-Driven Phrase Structure Grammar (HPSG) (Pollard and Sag, 1994). All of these formalisms share a similar basic syntactic structure with Penn Treebank CFG. However, the target formalisms also encode additional constraints and semantic features. For instance, Penn Treebank annotations do not make an explicit distinction between complement and adjunct, while all the above grammars mark these 291 Proceedings of the 51st Annual Meeting of the Association for Computational Linguistics, pages 291–301, Sofia, Bulgaria, August 4-9 2013. c�2013 Association for Computational Linguistics roles exp</context>
</contexts>
<marker>Bresnan, 1982</marker>
<rawString>Joan Bresnan. 1982. The mental representation of grammatical relations, volume 1. The MIT Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Aoife Cahill</author>
<author>Mairad McCarthy</author>
<author>Josef van Genabith</author>
<author>Andy Way</author>
</authors>
<title>Parsing with pcfgs and automatic f-structure annotation.</title>
<date>2002</date>
<booktitle>In Proceedings of the Seventh International Conference on LFG,</booktitle>
<pages>76--95</pages>
<publisher>CSLI Publications.</publisher>
<marker>Cahill, McCarthy, van Genabith, Way, 2002</marker>
<rawString>Aoife Cahill, Mairad McCarthy, Josef van Genabith, and Andy Way. 2002. Parsing with pcfgs and automatic f-structure annotation. In Proceedings of the Seventh International Conference on LFG, pages 76–95. CSLI Publications.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Aoife Cahill</author>
<author>Michael Burke</author>
<author>Ruth O’Donovan</author>
<author>Josef Van Genabith</author>
<author>Andy Way</author>
</authors>
<title>Long-distance dependency resolution in automatically acquired wide-coverage pcfg-based lfg approximations.</title>
<date>2004</date>
<booktitle>In Proceedings of the 42nd Annual Meeting on Association for Computational Linguistics,</booktitle>
<pages>319</pages>
<publisher>Association</publisher>
<institution>for Computational Linguistics.</institution>
<marker>Cahill, Burke, O’Donovan, Van Genabith, Way, 2004</marker>
<rawString>Aoife Cahill, Michael Burke, Ruth O’Donovan, Josef Van Genabith, and Andy Way. 2004. Long-distance dependency resolution in automatically acquired wide-coverage pcfg-based lfg approximations. In Proceedings of the 42nd Annual Meeting on Association for Computational Linguistics, page 319. Association for Computational Linguistics.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Aoife Cahill</author>
</authors>
<title>Parsing with Automatically Acquired, Wide-Coverage, Robust, Probabilistic LFG Approximation.</title>
<date>2004</date>
<tech>Ph.D. thesis.</tech>
<contexts>
<context position="7532" citStr="Cahill, 2004" startWordPosition="1145" endWordPosition="1146"> et al., 2007; Blitzer et al., 2006), and crossformalism transfer (Hockenmaier and Steedman, 2002; Miyao et al., 2005; Cahill et al., 2002; Riezler et al., 2002; Chen and Shanker, 2005; Candito et al., 2010). There have been several attempts to map annotations in coarse grammars like CFG to annotations in richer grammar, like HPSG, LFG, or CCG. Traditional approaches in this area typically rely on manually specified rules that encode the relation between the two formalisms. For instance, mappings may specify how to convert traces and functional tags in Penn Treebank to the f-structure in LFG (Cahill, 2004). These conversion rules are typically utilized in two ways: (1) to create a new treebank which is consequently used to train a parser for the target formalism (Hockenmaier and Steedman, 2002; Clark and Curran, 2003; Miyao et al., 2005; Miyao and Tsujii, 2008), (2) to translate the output of a CFG parser into the target formalism (Cahill et al., 2002). The design of these rules is a major linguistic and computational undertaking, which requires multiple iterations over the data to increase coverage (Miyao et al., 2005; Oepen et al., 2004). By nature, the mapping rules are formalism speTSBJ=1 T</context>
</contexts>
<marker>Cahill, 2004</marker>
<rawString>Aoife Cahill. 2004. Parsing with Automatically Acquired, Wide-Coverage, Robust, Probabilistic LFG Approximation. Ph.D. thesis.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Marie Candito</author>
<author>Benoit Crabb´e</author>
<author>Pascal Denis</author>
</authors>
<title>Statistical french dependency parsing: treebank conversion and first results.</title>
<date>2010</date>
<booktitle>In Proceedings of the Seventh International Conference on Language Resources and Evaluation (LREC</booktitle>
<pages>1840--1847</pages>
<marker>Candito, Crabb´e, Denis, 2010</marker>
<rawString>Marie Candito, Benoit Crabb´e, Pascal Denis, et al. 2010. Statistical french dependency parsing: treebank conversion and first results. In Proceedings of the Seventh International Conference on Language Resources and Evaluation (LREC 2010), pages 1840–1847.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Eugene Charniak</author>
<author>Mark Johnson</author>
</authors>
<title>Coarseto-fine n-best parsing and maxent discriminative reranking.</title>
<date>2005</date>
<booktitle>In Proceedings of the 43rd Annual Meeting on Association for Computational Linguistics,</booktitle>
<pages>173--180</pages>
<publisher>Association</publisher>
<institution>for Computational Linguistics.</institution>
<contexts>
<context position="27190" citStr="Charniak and Johnson, 2005" startWordPosition="4487" endWordPosition="4490"> metric is commonly used to measure parsing quality for the formalisms considered in this paper. The detailed definition of this measure as applied for each formalism is provided in (Clark and Curran, 2003; Miyao and Tsujii, 2008; Cahill et al., 2004). For CCG, we use the evaluation script from the C&amp;C tools.5 For HPSG, we evaluate all types of dependencies, including punctuations. For LFG, we consider the preds-only dependencies, which are the dependencies between pairs of words. Secondly, we also evaluate using unlabeled PARSEVAL, a standard measure for PCFG parsing (Petrov and Klein, 2007; Charniak and Johnson, 2005; Charniak, 2000; Collins, 1997). The dependency F-score captures both the target5Available at http://svn.ask.it.usyd.edu.au/trac/candc/wiki grammar labels and tree-structural relations. The unlabeled PARSEVAL is used as an auxiliary measure that enables us to separate these two aspects by focusing on the structural relations exclusively. Training without CFG Data: To assess the impact of coarse data in the experiments below, we also consider the model trained only on formalism-specific annotations. When no CFG sentences are available, we assign all the CFG labels to a special value shared by </context>
</contexts>
<marker>Charniak, Johnson, 2005</marker>
<rawString>Eugene Charniak and Mark Johnson. 2005. Coarseto-fine n-best parsing and maxent discriminative reranking. In Proceedings of the 43rd Annual Meeting on Association for Computational Linguistics, pages 173–180. Association for Computational Linguistics.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Eugene Charniak</author>
</authors>
<title>A maximum-entropyinspired parser.</title>
<date>2000</date>
<booktitle>In Proceedings of the 1st North American chapter of the Association for Computational Linguistics conference,</booktitle>
<pages>132--139</pages>
<contexts>
<context position="27206" citStr="Charniak, 2000" startWordPosition="4491" endWordPosition="4492">measure parsing quality for the formalisms considered in this paper. The detailed definition of this measure as applied for each formalism is provided in (Clark and Curran, 2003; Miyao and Tsujii, 2008; Cahill et al., 2004). For CCG, we use the evaluation script from the C&amp;C tools.5 For HPSG, we evaluate all types of dependencies, including punctuations. For LFG, we consider the preds-only dependencies, which are the dependencies between pairs of words. Secondly, we also evaluate using unlabeled PARSEVAL, a standard measure for PCFG parsing (Petrov and Klein, 2007; Charniak and Johnson, 2005; Charniak, 2000; Collins, 1997). The dependency F-score captures both the target5Available at http://svn.ask.it.usyd.edu.au/trac/candc/wiki grammar labels and tree-structural relations. The unlabeled PARSEVAL is used as an auxiliary measure that enables us to separate these two aspects by focusing on the structural relations exclusively. Training without CFG Data: To assess the impact of coarse data in the experiments below, we also consider the model trained only on formalism-specific annotations. When no CFG sentences are available, we assign all the CFG labels to a special value shared by all the nodes. I</context>
</contexts>
<marker>Charniak, 2000</marker>
<rawString>Eugene Charniak. 2000. A maximum-entropyinspired parser. In Proceedings of the 1st North American chapter of the Association for Computational Linguistics conference, pages 132–139.</rawString>
</citation>
<citation valid="true">
<authors>
<author>John Chen</author>
<author>Vijay K Shanker</author>
</authors>
<title>Automated extraction of tags from the penn treebank. New developments in parsing technology,</title>
<date>2005</date>
<pages>73--89</pages>
<contexts>
<context position="7103" citStr="Chen and Shanker, 2005" startWordPosition="1072" endWordPosition="1075">longs to a broader class of research on transfer learning in parsing. This area has garnered significant attention due to the expense associated with obtaining syntactic annotations. Transfer learning in parsing has been applied in different contexts, such as multilingual learning (Snyder et al., 2009; Hwa et al., 2005; McDonald et al., 2006; McDonald et al., 2011; Jiang and Liu, 2009), domain adaptation (McClosky et al., 2010; Dredze et al., 2007; Blitzer et al., 2006), and crossformalism transfer (Hockenmaier and Steedman, 2002; Miyao et al., 2005; Cahill et al., 2002; Riezler et al., 2002; Chen and Shanker, 2005; Candito et al., 2010). There have been several attempts to map annotations in coarse grammars like CFG to annotations in richer grammar, like HPSG, LFG, or CCG. Traditional approaches in this area typically rely on manually specified rules that encode the relation between the two formalisms. For instance, mappings may specify how to convert traces and functional tags in Penn Treebank to the f-structure in LFG (Cahill, 2004). These conversion rules are typically utilized in two ways: (1) to create a new treebank which is consequently used to train a parser for the target formalism (Hockenmaie</context>
</contexts>
<marker>Chen, Shanker, 2005</marker>
<rawString>John Chen and Vijay K Shanker. 2005. Automated extraction of tags from the penn treebank. New developments in parsing technology, pages 73–89.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Stephen Clark</author>
<author>James R Curran</author>
</authors>
<title>Log-linear models for wide-coverage ccg parsing.</title>
<date>2003</date>
<booktitle>In Proceedings of the 2003 conference on Empirical methods in natural language processing,</booktitle>
<pages>97--104</pages>
<publisher>Association</publisher>
<institution>for Computational Linguistics.</institution>
<contexts>
<context position="7747" citStr="Clark and Curran, 2003" startWordPosition="1178" endWordPosition="1181">). There have been several attempts to map annotations in coarse grammars like CFG to annotations in richer grammar, like HPSG, LFG, or CCG. Traditional approaches in this area typically rely on manually specified rules that encode the relation between the two formalisms. For instance, mappings may specify how to convert traces and functional tags in Penn Treebank to the f-structure in LFG (Cahill, 2004). These conversion rules are typically utilized in two ways: (1) to create a new treebank which is consequently used to train a parser for the target formalism (Hockenmaier and Steedman, 2002; Clark and Curran, 2003; Miyao et al., 2005; Miyao and Tsujii, 2008), (2) to translate the output of a CFG parser into the target formalism (Cahill et al., 2002). The design of these rules is a major linguistic and computational undertaking, which requires multiple iterations over the data to increase coverage (Miyao et al., 2005; Oepen et al., 2004). By nature, the mapping rules are formalism speTSBJ=1 T-1 TOBJ=1 [Pron.I] [ SBJ, OBJ] [N.3pl] T T NP VB NP I eat apples I eat apples ROOT S T-1 VP CFG S[dcl] CCG LFG [N.no3sg] [N&lt;V.bse&gt;N] [N.3pl] NP (S[dcl]\NP)/NP NP I eat apples I eat apples subj_head head_comp S[dcl]\</context>
<context position="26769" citStr="Clark and Curran, 2003" startWordPosition="4419" endWordPosition="4423">data, we use distinct sentences in the source and target treebanks. Following previous work (Hockenmaier, 2003; Miyao and Tsujii, 2008), we only consider sentences not exceeding 40 words, except on PARC700 where all sentences are used. Evaluation Metrics: We use two evaluation metrics. First, following previous work, we evaluate our method using the labeled and unlabeled predicate-argument dependency F-score. This metric is commonly used to measure parsing quality for the formalisms considered in this paper. The detailed definition of this measure as applied for each formalism is provided in (Clark and Curran, 2003; Miyao and Tsujii, 2008; Cahill et al., 2004). For CCG, we use the evaluation script from the C&amp;C tools.5 For HPSG, we evaluate all types of dependencies, including punctuations. For LFG, we consider the preds-only dependencies, which are the dependencies between pairs of words. Secondly, we also evaluate using unlabeled PARSEVAL, a standard measure for PCFG parsing (Petrov and Klein, 2007; Charniak and Johnson, 2005; Charniak, 2000; Collins, 1997). The dependency F-score captures both the target5Available at http://svn.ask.it.usyd.edu.au/trac/candc/wiki grammar labels and tree-structural rel</context>
<context position="32052" citStr="Clark and Curran, 2003" startWordPosition="5321" endWordPosition="5325">nju 75.8 / 80.6 84.2 / 87.3 Model 76.9 / 82.0 84.9 / 88.3 LFG Pipeline 68.5 / 74.0 82.6 / 85.9 Annotator Model 69.8 / 76.6 81.1 / 84.7 Table 4: The labeled/unlabeled dependency Fscore comparisons between our model and stateof-the-art parsers. Comparison to State-of-the-art Parsers: We would also like to demonstrate that the above gains of our transfer model are achieved using an adequate formalism-specific parser. Since our model can be trained exclusively on formalismspecific data, we can compare it to state-of-theart formalism-specific parsers. For this experiment, we choose the C&amp;C parser (Clark and Curran, 2003) for CCG, Enju parser (Miyao and Tsujii, 2008) for HPSG and pipeline automatic annotator (Cahill et al., 2004) with Charniak parser for LFG. For all three parsers, we use the implementation provided by the authors with the default parameter values. All the models are trained on either 1,000 or 15,000 sentences annotated with formalism-specific trees, thus evaluating their performances on small scale or large scale of data. As Table 4 shows, our model is competitive with 298 all the baselines described above. It’s not surprising that Cahill’s model outperforms our loglinear model because it rel</context>
</contexts>
<marker>Clark, Curran, 2003</marker>
<rawString>Stephen Clark and James R Curran. 2003. Log-linear models for wide-coverage ccg parsing. In Proceedings of the 2003 conference on Empirical methods in natural language processing, pages 97–104. Association for Computational Linguistics.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Stephen Clark</author>
<author>James R Curran</author>
</authors>
<title>Widecoverage efficient statistical parsing with ccg and log-linear models.</title>
<date>2007</date>
<journal>Computational Linguistics,</journal>
<volume>33</volume>
<issue>4</issue>
<contexts>
<context position="15907" citStr="Clark and Curran, 2007" startWordPosition="2583" endWordPosition="2587">ng algorithm. The chart construction will be explained in Section 5. 5 Implementation This section introduces important implementation details, including supertagging, feature forest pruning and binarization methods. Finally, we explain how to generalize our model to other constituency-based formalisms. 5.1 Supertagging When parsing a target formalism tree, one needs to associate each word with a lexical entry. However, since the number of candidates is typically more than one thousand, the size of the chart explodes. One effective way of reducing the number of candidates is via supertagging (Clark and Curran, 2007). A supertagger is used for selecting a small set of lexical entry candidates for each word in the sentence. We use the tagger in (Clark and Curran, 2007) as a general suppertagger for all the grammars considered. The only difference is that we use different lexical entries in different grammars. 5.2 Feature Forest Pruning In the BFGS algorithm (see Section 4), feature expectation is computed using the inside-outside algorithm. To perform this dynamic programming efficiently, we first need to build the packed chart, namely the feature forest (Miyao, 2006) to represent the exponential number of</context>
<context position="17233" citStr="Clark and Curran, 2007" startWordPosition="2800" endWordPosition="2804">age Passing Interface package (Gropp et al., 1999). 4An alternative approach would be to marginalize over yCFG and maximize over yCCG. However, this is a harder computational problem. efCFG(yCFG,S)&apos;θCFG Z(S; BCFG) . 294 structures. However, a common problem for lexicalized grammars is that the forest size is too large. In CFG, the forest is pruned according to the inside probability of a simple generative PCFG model and a prior (Collins, 2003). The basic idea is to prune the trees with lower probability. For the target formalism, a common practice is to prune the forest using the supertagger (Clark and Curran, 2007; Miyao, 2006). In our implementation, we applied all pruning techniques, because the forest is a combination of CFG and target grammar formalisms (e.g., CCG or HPSG). 5.3 Binarization We assume that the derivation tree in the target formalism is in a normal form, which is indeed the case for the treebanks we consider. As mentioned in Section 4, we would also like to work with binarized CFG derivations, such that all trees are in normal form and it is easy to construct features that link the two (see Section 6). Since Penn Treebank trees are not binarized, we construct a simple procedure for b</context>
</contexts>
<marker>Clark, Curran, 2007</marker>
<rawString>Stephen Clark and James R Curran. 2007. Widecoverage efficient statistical parsing with ccg and log-linear models. Computational Linguistics, 33(4):493–552.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Michael Collins</author>
</authors>
<title>Three generative, lexicalised models for statistical pprsing.</title>
<date>1997</date>
<booktitle>In Proceedings of the eighth conference on European chapter of the Association for Computational Linguistics,</booktitle>
<pages>16--23</pages>
<publisher>Association</publisher>
<institution>for Computational Linguistics.</institution>
<contexts>
<context position="27222" citStr="Collins, 1997" startWordPosition="4493" endWordPosition="4494">quality for the formalisms considered in this paper. The detailed definition of this measure as applied for each formalism is provided in (Clark and Curran, 2003; Miyao and Tsujii, 2008; Cahill et al., 2004). For CCG, we use the evaluation script from the C&amp;C tools.5 For HPSG, we evaluate all types of dependencies, including punctuations. For LFG, we consider the preds-only dependencies, which are the dependencies between pairs of words. Secondly, we also evaluate using unlabeled PARSEVAL, a standard measure for PCFG parsing (Petrov and Klein, 2007; Charniak and Johnson, 2005; Charniak, 2000; Collins, 1997). The dependency F-score captures both the target5Available at http://svn.ask.it.usyd.edu.au/trac/candc/wiki grammar labels and tree-structural relations. The unlabeled PARSEVAL is used as an auxiliary measure that enables us to separate these two aspects by focusing on the structural relations exclusively. Training without CFG Data: To assess the impact of coarse data in the experiments below, we also consider the model trained only on formalism-specific annotations. When no CFG sentences are available, we assign all the CFG labels to a special value shared by all the nodes. In this set-up, t</context>
</contexts>
<marker>Collins, 1997</marker>
<rawString>Michael Collins. 1997. Three generative, lexicalised models for statistical pprsing. In Proceedings of the eighth conference on European chapter of the Association for Computational Linguistics, pages 16–23. Association for Computational Linguistics.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Michael Collins</author>
</authors>
<title>Head-driven statistical models for natural language parsing.</title>
<date>2003</date>
<booktitle>Computational linguistics,</booktitle>
<pages>29--4</pages>
<contexts>
<context position="17058" citStr="Collins, 2003" startWordPosition="2772" endWordPosition="2773">ure forest (Miyao, 2006) to represent the exponential number of all possible tree 3To speed up the implementation, gradient computation is parallelized, using the Message Passing Interface package (Gropp et al., 1999). 4An alternative approach would be to marginalize over yCFG and maximize over yCCG. However, this is a harder computational problem. efCFG(yCFG,S)&apos;θCFG Z(S; BCFG) . 294 structures. However, a common problem for lexicalized grammars is that the forest size is too large. In CFG, the forest is pruned according to the inside probability of a simple generative PCFG model and a prior (Collins, 2003). The basic idea is to prune the trees with lower probability. For the target formalism, a common practice is to prune the forest using the supertagger (Clark and Curran, 2007; Miyao, 2006). In our implementation, we applied all pruning techniques, because the forest is a combination of CFG and target grammar formalisms (e.g., CCG or HPSG). 5.3 Binarization We assume that the derivation tree in the target formalism is in a normal form, which is indeed the case for the treebanks we consider. As mentioned in Section 4, we would also like to work with binarized CFG derivations, such that all tree</context>
</contexts>
<marker>Collins, 2003</marker>
<rawString>Michael Collins. 2003. Head-driven statistical models for natural language parsing. Computational linguistics, 29(4):589–637.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Mark Dredze</author>
<author>John Blitzer</author>
</authors>
<title>Partha Pratim Talukdar, Kuzman Ganchev, Joao</title>
<date>2007</date>
<booktitle>In Proceedings of the CoNLL Shared Task Session of EMNLP-CoNLL,</booktitle>
<volume>volume</volume>
<marker>Dredze, Blitzer, 2007</marker>
<rawString>Mark Dredze, John Blitzer, Partha Pratim Talukdar, Kuzman Ganchev, Joao V Grac¸a, and Fernando Pereira. 2007. Frustratingly hard domain adaptation for dependency parsing. In Proceedings of the CoNLL Shared Task Session of EMNLP-CoNLL, volume 2007.</rawString>
</citation>
<citation valid="true">
<authors>
<author>William Gropp</author>
<author>Ewing Lusk</author>
<author>Anthony Skjellum</author>
</authors>
<title>Using MPI: portable parallel programming with the message passing interface, volume 1.</title>
<date>1999</date>
<publisher>MIT press.</publisher>
<contexts>
<context position="16661" citStr="Gropp et al., 1999" startWordPosition="2706" endWordPosition="2709">k and Curran, 2007) as a general suppertagger for all the grammars considered. The only difference is that we use different lexical entries in different grammars. 5.2 Feature Forest Pruning In the BFGS algorithm (see Section 4), feature expectation is computed using the inside-outside algorithm. To perform this dynamic programming efficiently, we first need to build the packed chart, namely the feature forest (Miyao, 2006) to represent the exponential number of all possible tree 3To speed up the implementation, gradient computation is parallelized, using the Message Passing Interface package (Gropp et al., 1999). 4An alternative approach would be to marginalize over yCFG and maximize over yCCG. However, this is a harder computational problem. efCFG(yCFG,S)&apos;θCFG Z(S; BCFG) . 294 structures. However, a common problem for lexicalized grammars is that the forest size is too large. In CFG, the forest is pruned according to the inside probability of a simple generative PCFG model and a prior (Collins, 2003). The basic idea is to prune the trees with lower probability. For the target formalism, a common practice is to prune the forest using the supertagger (Clark and Curran, 2007; Miyao, 2006). In our imple</context>
</contexts>
<marker>Gropp, Lusk, Skjellum, 1999</marker>
<rawString>William Gropp, Ewing Lusk, and Anthony Skjellum. 1999. Using MPI: portable parallel programming with the message passing interface, volume 1. MIT press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Julia Hockenmaier</author>
<author>Mark Steedman</author>
</authors>
<title>Acquiring compact lexicalized grammars from a cleaner treebank.</title>
<date>2002</date>
<booktitle>In Proceedings of the Third LREC Conference,</booktitle>
<pages>1974--1981</pages>
<contexts>
<context position="7016" citStr="Hockenmaier and Steedman, 2002" startWordPosition="1055" endWordPosition="1058">G, HPSG and LFG formalisms. also observed on CCG and LFG formalisms. 2 Related Work Our work belongs to a broader class of research on transfer learning in parsing. This area has garnered significant attention due to the expense associated with obtaining syntactic annotations. Transfer learning in parsing has been applied in different contexts, such as multilingual learning (Snyder et al., 2009; Hwa et al., 2005; McDonald et al., 2006; McDonald et al., 2011; Jiang and Liu, 2009), domain adaptation (McClosky et al., 2010; Dredze et al., 2007; Blitzer et al., 2006), and crossformalism transfer (Hockenmaier and Steedman, 2002; Miyao et al., 2005; Cahill et al., 2002; Riezler et al., 2002; Chen and Shanker, 2005; Candito et al., 2010). There have been several attempts to map annotations in coarse grammars like CFG to annotations in richer grammar, like HPSG, LFG, or CCG. Traditional approaches in this area typically rely on manually specified rules that encode the relation between the two formalisms. For instance, mappings may specify how to convert traces and functional tags in Penn Treebank to the f-structure in LFG (Cahill, 2004). These conversion rules are typically utilized in two ways: (1) to create a new tre</context>
<context position="8538" citStr="Hockenmaier and Steedman (2002)" startWordPosition="1313" endWordPosition="1316">rules is a major linguistic and computational undertaking, which requires multiple iterations over the data to increase coverage (Miyao et al., 2005; Oepen et al., 2004). By nature, the mapping rules are formalism speTSBJ=1 T-1 TOBJ=1 [Pron.I] [ SBJ, OBJ] [N.3pl] T T NP VB NP I eat apples I eat apples ROOT S T-1 VP CFG S[dcl] CCG LFG [N.no3sg] [N&lt;V.bse&gt;N] [N.3pl] NP (S[dcl]\NP)/NP NP I eat apples I eat apples subj_head head_comp S[dcl]\NP HPSG 292 cific and therefore not transferable. Moreover, frequently designing such mappings involves modification to the original annotations. For instance, Hockenmaier and Steedman (2002) made thousands of POS and constituent modifications to the Penn Treebank to facilitate transfer to CCG. More importantly, in some transfer scenarios, deterministic rules are not sufficient, due to the high ambiguity inherent in the mapping. Therefore, our work considers an alternative set-up for crossformalism transfer where a small amount of annotations in the target formalism is used as an alternative to using deterministic rules. The limitation of deterministic transfer rules has been recognized in prior work (Riezler et al., 2002). Their method uses a hand-crafted LFG parser to create a s</context>
<context position="24078" citStr="Hockenmaier and Steedman, 2002" startWordPosition="3966" endWordPosition="3969">also encode the formalism-specific syntactic and semantic information. These three types of features work together to generate a tree skeleton and fill in the CFG and CCG labels. 7 Evaluation Setup Grammar Train Dev. Test CCG Sec. 02-21 Sec. 00 Sec. 23 HPSG LFG 140 sents. in 560 sents. in PARC700 PARC700 Table 3: Training/Dev./Test split on WSJ sections and PARC700 for different grammar formalisms. Datasets: As a source of coarse annotations, we use the Penn Treebank-1 (Marcus et al., 1993). In addition, for CCG, HPSG and LFG, we rely on formalism-specific corpora developed in prior research (Hockenmaier and Steedman, 2002; Miyao et al., 2005; Cahill et al., 2002; King et al., 2003). All of these corpora were derived via conversion of Penn Treebank to the target formalisms. In particular, our CCG and HPSG datasets were converted from the Penn Treebank based on hand(d, wl,r, hpl,r, syp,l,r), (d, wl,r, syp,l,r), (c, wl,r, hpl,r, syp,l,r), (c, wl,r, syp,l,r), (d, c, hpl,r, syp,l,r), (d, c, syp,l,r), (c, spl,r, hpl,r, syp,l,r), (c, spl,r, syp,l,r), (pst−1, syp,l,r), (pen+1, syp,l,r), (pst−1, pen+1, syp,l,r), (pst−1, pst−2, syp,l,r), (pen+1, pen+2, syp,l,r), (pst−1, pst−2, pen+1, pen+2, syp,l,r), (r, d, c, hwl,r, hp</context>
<context position="25582" citStr="Hockenmaier and Steedman, 2002" startWordPosition="4225" endWordPosition="4228">c, syl,r, hll,r), (r, d, c, syl,r) (r, c, spl,r, syl,r, hll,r), (r, c, spl,r, syl,r) fCFG fCCG fjoint 296 88 86 84 82 80 78 76 740 1000 3000 7000 11000 15000 (a) CCG 0 1000 3000 7000 11000 15000 (b) HPSG 86 84 82 80 78 76 74 72 Labeled Dep Unlabeled Dep Unlabeled Parseval 80 75 70 Labeled Dep Unlabeled Dep Unlabeled Parseval 65 0 1000 3000 7000 11000 15000 (c) LFG Labeled Dep Unlabeled Dep Unlabeled Parseval Figure 4: Model performance with 500 target formalism trees and different numbers of CFG trees, evaluated using labeled/unlabeled dependency F-score and unlabeled PARSEVAL. crafted rules (Hockenmaier and Steedman, 2002; Miyao et al., 2005). Table 3 shows which sections of the treebanks were used in training, testing and development for both formalisms. Our LFG training dataset was constructed in a similar fashion (Cahill et al., 2002). However, we choose to use PARC700 as our LFG tesing and development datasets, following the previous work by (Kaplan et al., 2004). It contains 700 manually annotated sentences that are randomly selected from Penn Treebank Section 23. The split of PARC700 follows the setting in (Kaplan et al., 2004). Since our model does not assume parallel data, we use distinct sentences in </context>
</contexts>
<marker>Hockenmaier, Steedman, 2002</marker>
<rawString>Julia Hockenmaier and Mark Steedman. 2002. Acquiring compact lexicalized grammars from a cleaner treebank. In Proceedings of the Third LREC Conference, pages 1974–1981.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Julia Hockenmaier</author>
</authors>
<title>Data and models for statistical parsing with combinatory categorial grammar.</title>
<date>2003</date>
<contexts>
<context position="26257" citStr="Hockenmaier, 2003" startWordPosition="4341" endWordPosition="4343"> treebanks were used in training, testing and development for both formalisms. Our LFG training dataset was constructed in a similar fashion (Cahill et al., 2002). However, we choose to use PARC700 as our LFG tesing and development datasets, following the previous work by (Kaplan et al., 2004). It contains 700 manually annotated sentences that are randomly selected from Penn Treebank Section 23. The split of PARC700 follows the setting in (Kaplan et al., 2004). Since our model does not assume parallel data, we use distinct sentences in the source and target treebanks. Following previous work (Hockenmaier, 2003; Miyao and Tsujii, 2008), we only consider sentences not exceeding 40 words, except on PARC700 where all sentences are used. Evaluation Metrics: We use two evaluation metrics. First, following previous work, we evaluate our method using the labeled and unlabeled predicate-argument dependency F-score. This metric is commonly used to measure parsing quality for the formalisms considered in this paper. The detailed definition of this measure as applied for each formalism is provided in (Clark and Curran, 2003; Miyao and Tsujii, 2008; Cahill et al., 2004). For CCG, we use the evaluation script fr</context>
</contexts>
<marker>Hockenmaier, 2003</marker>
<rawString>Julia Hockenmaier. 2003. Data and models for statistical parsing with combinatory categorial grammar.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Rebecca Hwa</author>
<author>Philip Resnik</author>
<author>Amy Weinberg</author>
</authors>
<title>Breaking the resource bottleneck for multilingual parsing.</title>
<date>2005</date>
<tech>Technical report, DTIC Document.</tech>
<contexts>
<context position="6801" citStr="Hwa et al., 2005" startWordPosition="1021" endWordPosition="1024">e Penn Treebank-2 contains richer annotations, we decided to use the Penn Treebank-1 to demonstrate the feasibility of transfer from coarse annotations. Figure 1: Derivation trees for CFG as well as CCG, HPSG and LFG formalisms. also observed on CCG and LFG formalisms. 2 Related Work Our work belongs to a broader class of research on transfer learning in parsing. This area has garnered significant attention due to the expense associated with obtaining syntactic annotations. Transfer learning in parsing has been applied in different contexts, such as multilingual learning (Snyder et al., 2009; Hwa et al., 2005; McDonald et al., 2006; McDonald et al., 2011; Jiang and Liu, 2009), domain adaptation (McClosky et al., 2010; Dredze et al., 2007; Blitzer et al., 2006), and crossformalism transfer (Hockenmaier and Steedman, 2002; Miyao et al., 2005; Cahill et al., 2002; Riezler et al., 2002; Chen and Shanker, 2005; Candito et al., 2010). There have been several attempts to map annotations in coarse grammars like CFG to annotations in richer grammar, like HPSG, LFG, or CCG. Traditional approaches in this area typically rely on manually specified rules that encode the relation between the two formalisms. For</context>
</contexts>
<marker>Hwa, Resnik, Weinberg, 2005</marker>
<rawString>Rebecca Hwa, Philip Resnik, and Amy Weinberg. 2005. Breaking the resource bottleneck for multilingual parsing. Technical report, DTIC Document.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Wenbin Jiang</author>
<author>Qun Liu</author>
</authors>
<title>Automatic adaptation of annotation standards for dependency parsing: using projected treebank as source corpus.</title>
<date>2009</date>
<booktitle>In Proceedings of the 11th International Conference on Parsing Technologies,</booktitle>
<pages>25--28</pages>
<publisher>Association</publisher>
<institution>for Computational Linguistics.</institution>
<contexts>
<context position="6869" citStr="Jiang and Liu, 2009" startWordPosition="1033" endWordPosition="1036"> the Penn Treebank-1 to demonstrate the feasibility of transfer from coarse annotations. Figure 1: Derivation trees for CFG as well as CCG, HPSG and LFG formalisms. also observed on CCG and LFG formalisms. 2 Related Work Our work belongs to a broader class of research on transfer learning in parsing. This area has garnered significant attention due to the expense associated with obtaining syntactic annotations. Transfer learning in parsing has been applied in different contexts, such as multilingual learning (Snyder et al., 2009; Hwa et al., 2005; McDonald et al., 2006; McDonald et al., 2011; Jiang and Liu, 2009), domain adaptation (McClosky et al., 2010; Dredze et al., 2007; Blitzer et al., 2006), and crossformalism transfer (Hockenmaier and Steedman, 2002; Miyao et al., 2005; Cahill et al., 2002; Riezler et al., 2002; Chen and Shanker, 2005; Candito et al., 2010). There have been several attempts to map annotations in coarse grammars like CFG to annotations in richer grammar, like HPSG, LFG, or CCG. Traditional approaches in this area typically rely on manually specified rules that encode the relation between the two formalisms. For instance, mappings may specify how to convert traces and functional</context>
</contexts>
<marker>Jiang, Liu, 2009</marker>
<rawString>Wenbin Jiang and Qun Liu. 2009. Automatic adaptation of annotation standards for dependency parsing: using projected treebank as source corpus. In Proceedings of the 11th International Conference on Parsing Technologies, pages 25–28. Association for Computational Linguistics.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ronald M Kaplan</author>
<author>Stefan Riezler</author>
<author>Tracy H King</author>
<author>John T Maxwell Alexander Vasserman</author>
<author>Richard Crouch</author>
</authors>
<title>Speed and accuracy in shallow and deep stochastic parsing.</title>
<date>2004</date>
<booktitle>In Proceedings of NAACL.</booktitle>
<contexts>
<context position="25934" citStr="Kaplan et al., 2004" startWordPosition="4287" endWordPosition="4290"> LFG Labeled Dep Unlabeled Dep Unlabeled Parseval Figure 4: Model performance with 500 target formalism trees and different numbers of CFG trees, evaluated using labeled/unlabeled dependency F-score and unlabeled PARSEVAL. crafted rules (Hockenmaier and Steedman, 2002; Miyao et al., 2005). Table 3 shows which sections of the treebanks were used in training, testing and development for both formalisms. Our LFG training dataset was constructed in a similar fashion (Cahill et al., 2002). However, we choose to use PARC700 as our LFG tesing and development datasets, following the previous work by (Kaplan et al., 2004). It contains 700 manually annotated sentences that are randomly selected from Penn Treebank Section 23. The split of PARC700 follows the setting in (Kaplan et al., 2004). Since our model does not assume parallel data, we use distinct sentences in the source and target treebanks. Following previous work (Hockenmaier, 2003; Miyao and Tsujii, 2008), we only consider sentences not exceeding 40 words, except on PARC700 where all sentences are used. Evaluation Metrics: We use two evaluation metrics. First, following previous work, we evaluate our method using the labeled and unlabeled predicate-arg</context>
</contexts>
<marker>Kaplan, Riezler, King, Vasserman, Crouch, 2004</marker>
<rawString>Ronald M. Kaplan, Stefan Riezler, Tracy H. King, John T. Maxwell III, Alexander Vasserman, and Richard Crouch. 2004. Speed and accuracy in shallow and deep stochastic parsing. In Proceedings of NAACL.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Tracy Holloway King</author>
<author>Richard Crouch</author>
<author>Stefan Riezler</author>
<author>Mary Dalrymple</author>
<author>Ronald M Kaplan</author>
</authors>
<title>The parc 700 dependency bank.</title>
<date>2003</date>
<booktitle>In Proceedings of the EACL03: 4th International Workshop on Linguistically Interpreted Corpora (LINC-03),</booktitle>
<pages>1--8</pages>
<contexts>
<context position="24139" citStr="King et al., 2003" startWordPosition="3978" endWordPosition="3981">ese three types of features work together to generate a tree skeleton and fill in the CFG and CCG labels. 7 Evaluation Setup Grammar Train Dev. Test CCG Sec. 02-21 Sec. 00 Sec. 23 HPSG LFG 140 sents. in 560 sents. in PARC700 PARC700 Table 3: Training/Dev./Test split on WSJ sections and PARC700 for different grammar formalisms. Datasets: As a source of coarse annotations, we use the Penn Treebank-1 (Marcus et al., 1993). In addition, for CCG, HPSG and LFG, we rely on formalism-specific corpora developed in prior research (Hockenmaier and Steedman, 2002; Miyao et al., 2005; Cahill et al., 2002; King et al., 2003). All of these corpora were derived via conversion of Penn Treebank to the target formalisms. In particular, our CCG and HPSG datasets were converted from the Penn Treebank based on hand(d, wl,r, hpl,r, syp,l,r), (d, wl,r, syp,l,r), (c, wl,r, hpl,r, syp,l,r), (c, wl,r, syp,l,r), (d, c, hpl,r, syp,l,r), (d, c, syp,l,r), (c, spl,r, hpl,r, syp,l,r), (c, spl,r, syp,l,r), (pst−1, syp,l,r), (pen+1, syp,l,r), (pst−1, pen+1, syp,l,r), (pst−1, pst−2, syp,l,r), (pen+1, pen+2, syp,l,r), (pst−1, pst−2, pen+1, pen+2, syp,l,r), (r, d, c, hwl,r, hpl,r, hll,r), (r, d, c, hwl,r, hpl,r) (r, d, c, hwl,r, hll,r),</context>
</contexts>
<marker>King, Crouch, Riezler, Dalrymple, Kaplan, 2003</marker>
<rawString>Tracy Holloway King, Richard Crouch, Stefan Riezler, Mary Dalrymple, and Ronald M Kaplan. 2003. The parc 700 dependency bank. In Proceedings of the EACL03: 4th International Workshop on Linguistically Interpreted Corpora (LINC-03), pages 1–8.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Mitchell P Marcus</author>
<author>Mary Ann Marcinkiewicz</author>
<author>Beatrice Santorini</author>
</authors>
<title>Building a large annotated corpus of english: The penn treebank.</title>
<date>1993</date>
<booktitle>Computational linguistics,</booktitle>
<pages>19--2</pages>
<contexts>
<context position="23943" citStr="Marcus et al., 1993" startWordPosition="3945" endWordPosition="3948">s will be learned to model the connection between the CFG and CCG labels. Moreover, the formalism-specific features fCCG can also encode the formalism-specific syntactic and semantic information. These three types of features work together to generate a tree skeleton and fill in the CFG and CCG labels. 7 Evaluation Setup Grammar Train Dev. Test CCG Sec. 02-21 Sec. 00 Sec. 23 HPSG LFG 140 sents. in 560 sents. in PARC700 PARC700 Table 3: Training/Dev./Test split on WSJ sections and PARC700 for different grammar formalisms. Datasets: As a source of coarse annotations, we use the Penn Treebank-1 (Marcus et al., 1993). In addition, for CCG, HPSG and LFG, we rely on formalism-specific corpora developed in prior research (Hockenmaier and Steedman, 2002; Miyao et al., 2005; Cahill et al., 2002; King et al., 2003). All of these corpora were derived via conversion of Penn Treebank to the target formalisms. In particular, our CCG and HPSG datasets were converted from the Penn Treebank based on hand(d, wl,r, hpl,r, syp,l,r), (d, wl,r, syp,l,r), (c, wl,r, hpl,r, syp,l,r), (c, wl,r, syp,l,r), (d, c, hpl,r, syp,l,r), (d, c, syp,l,r), (c, spl,r, hpl,r, syp,l,r), (c, spl,r, syp,l,r), (pst−1, syp,l,r), (pen+1, syp,l,r)</context>
</contexts>
<marker>Marcus, Marcinkiewicz, Santorini, 1993</marker>
<rawString>Mitchell P Marcus, Mary Ann Marcinkiewicz, and Beatrice Santorini. 1993. Building a large annotated corpus of english: The penn treebank. Computational linguistics, 19(2):313–330.</rawString>
</citation>
<citation valid="true">
<authors>
<author>David McClosky</author>
<author>Eugene Charniak</author>
<author>Mark Johnson</author>
</authors>
<title>Automatic domain adaptation for parsing. In Human Language Technologies: The</title>
<date>2010</date>
<contexts>
<context position="6911" citStr="McClosky et al., 2010" startWordPosition="1039" endWordPosition="1042">easibility of transfer from coarse annotations. Figure 1: Derivation trees for CFG as well as CCG, HPSG and LFG formalisms. also observed on CCG and LFG formalisms. 2 Related Work Our work belongs to a broader class of research on transfer learning in parsing. This area has garnered significant attention due to the expense associated with obtaining syntactic annotations. Transfer learning in parsing has been applied in different contexts, such as multilingual learning (Snyder et al., 2009; Hwa et al., 2005; McDonald et al., 2006; McDonald et al., 2011; Jiang and Liu, 2009), domain adaptation (McClosky et al., 2010; Dredze et al., 2007; Blitzer et al., 2006), and crossformalism transfer (Hockenmaier and Steedman, 2002; Miyao et al., 2005; Cahill et al., 2002; Riezler et al., 2002; Chen and Shanker, 2005; Candito et al., 2010). There have been several attempts to map annotations in coarse grammars like CFG to annotations in richer grammar, like HPSG, LFG, or CCG. Traditional approaches in this area typically rely on manually specified rules that encode the relation between the two formalisms. For instance, mappings may specify how to convert traces and functional tags in Penn Treebank to the f-structure </context>
</contexts>
<marker>McClosky, Charniak, Johnson, 2010</marker>
<rawString>David McClosky, Eugene Charniak, and Mark Johnson. 2010. Automatic domain adaptation for parsing. In Human Language Technologies: The 2010</rawString>
</citation>
<citation valid="false">
<booktitle>Annual Conference of the North American Chapter of the Association for Computational Linguistics,</booktitle>
<pages>28--36</pages>
<publisher>Association</publisher>
<institution>for Computational Linguistics.</institution>
<marker></marker>
<rawString>Annual Conference of the North American Chapter of the Association for Computational Linguistics, pages 28–36. Association for Computational Linguistics.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ryan McDonald</author>
<author>Kevin Lerman</author>
<author>Fernando Pereira</author>
</authors>
<title>Multilingual dependency analysis with a twostage discriminative parser.</title>
<date>2006</date>
<booktitle>In Proceedings of the Tenth Conference on Computational Natural Language Learning,</booktitle>
<pages>216--220</pages>
<publisher>Association</publisher>
<institution>for Computational Linguistics.</institution>
<contexts>
<context position="6824" citStr="McDonald et al., 2006" startWordPosition="1025" endWordPosition="1028">contains richer annotations, we decided to use the Penn Treebank-1 to demonstrate the feasibility of transfer from coarse annotations. Figure 1: Derivation trees for CFG as well as CCG, HPSG and LFG formalisms. also observed on CCG and LFG formalisms. 2 Related Work Our work belongs to a broader class of research on transfer learning in parsing. This area has garnered significant attention due to the expense associated with obtaining syntactic annotations. Transfer learning in parsing has been applied in different contexts, such as multilingual learning (Snyder et al., 2009; Hwa et al., 2005; McDonald et al., 2006; McDonald et al., 2011; Jiang and Liu, 2009), domain adaptation (McClosky et al., 2010; Dredze et al., 2007; Blitzer et al., 2006), and crossformalism transfer (Hockenmaier and Steedman, 2002; Miyao et al., 2005; Cahill et al., 2002; Riezler et al., 2002; Chen and Shanker, 2005; Candito et al., 2010). There have been several attempts to map annotations in coarse grammars like CFG to annotations in richer grammar, like HPSG, LFG, or CCG. Traditional approaches in this area typically rely on manually specified rules that encode the relation between the two formalisms. For instance, mappings may</context>
</contexts>
<marker>McDonald, Lerman, Pereira, 2006</marker>
<rawString>Ryan McDonald, Kevin Lerman, and Fernando Pereira. 2006. Multilingual dependency analysis with a twostage discriminative parser. In Proceedings of the Tenth Conference on Computational Natural Language Learning, pages 216–220. Association for Computational Linguistics.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ryan McDonald</author>
<author>Slav Petrov</author>
<author>Keith Hall</author>
</authors>
<title>Multi-source transfer of delexicalized dependency parsers.</title>
<date>2011</date>
<booktitle>In Proceedings of the Conference on Empirical Methods in Natural Language Processing,</booktitle>
<pages>62--72</pages>
<publisher>Association</publisher>
<institution>for Computational Linguistics.</institution>
<contexts>
<context position="6847" citStr="McDonald et al., 2011" startWordPosition="1029" endWordPosition="1032">ions, we decided to use the Penn Treebank-1 to demonstrate the feasibility of transfer from coarse annotations. Figure 1: Derivation trees for CFG as well as CCG, HPSG and LFG formalisms. also observed on CCG and LFG formalisms. 2 Related Work Our work belongs to a broader class of research on transfer learning in parsing. This area has garnered significant attention due to the expense associated with obtaining syntactic annotations. Transfer learning in parsing has been applied in different contexts, such as multilingual learning (Snyder et al., 2009; Hwa et al., 2005; McDonald et al., 2006; McDonald et al., 2011; Jiang and Liu, 2009), domain adaptation (McClosky et al., 2010; Dredze et al., 2007; Blitzer et al., 2006), and crossformalism transfer (Hockenmaier and Steedman, 2002; Miyao et al., 2005; Cahill et al., 2002; Riezler et al., 2002; Chen and Shanker, 2005; Candito et al., 2010). There have been several attempts to map annotations in coarse grammars like CFG to annotations in richer grammar, like HPSG, LFG, or CCG. Traditional approaches in this area typically rely on manually specified rules that encode the relation between the two formalisms. For instance, mappings may specify how to convert</context>
</contexts>
<marker>McDonald, Petrov, Hall, 2011</marker>
<rawString>Ryan McDonald, Slav Petrov, and Keith Hall. 2011. Multi-source transfer of delexicalized dependency parsers. In Proceedings of the Conference on Empirical Methods in Natural Language Processing, pages 62–72. Association for Computational Linguistics.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Yusuke Miyao</author>
<author>Jun’ichi Tsujii</author>
</authors>
<title>Feature forest models for probabilistic hpsg parsing.</title>
<date>2008</date>
<journal>Computational Linguistics,</journal>
<volume>34</volume>
<issue>1</issue>
<contexts>
<context position="7792" citStr="Miyao and Tsujii, 2008" startWordPosition="1186" endWordPosition="1189">nnotations in coarse grammars like CFG to annotations in richer grammar, like HPSG, LFG, or CCG. Traditional approaches in this area typically rely on manually specified rules that encode the relation between the two formalisms. For instance, mappings may specify how to convert traces and functional tags in Penn Treebank to the f-structure in LFG (Cahill, 2004). These conversion rules are typically utilized in two ways: (1) to create a new treebank which is consequently used to train a parser for the target formalism (Hockenmaier and Steedman, 2002; Clark and Curran, 2003; Miyao et al., 2005; Miyao and Tsujii, 2008), (2) to translate the output of a CFG parser into the target formalism (Cahill et al., 2002). The design of these rules is a major linguistic and computational undertaking, which requires multiple iterations over the data to increase coverage (Miyao et al., 2005; Oepen et al., 2004). By nature, the mapping rules are formalism speTSBJ=1 T-1 TOBJ=1 [Pron.I] [ SBJ, OBJ] [N.3pl] T T NP VB NP I eat apples I eat apples ROOT S T-1 VP CFG S[dcl] CCG LFG [N.no3sg] [N&lt;V.bse&gt;N] [N.3pl] NP (S[dcl]\NP)/NP NP I eat apples I eat apples subj_head head_comp S[dcl]\NP HPSG 292 cific and therefore not transfera</context>
<context position="26282" citStr="Miyao and Tsujii, 2008" startWordPosition="4344" endWordPosition="4347">d in training, testing and development for both formalisms. Our LFG training dataset was constructed in a similar fashion (Cahill et al., 2002). However, we choose to use PARC700 as our LFG tesing and development datasets, following the previous work by (Kaplan et al., 2004). It contains 700 manually annotated sentences that are randomly selected from Penn Treebank Section 23. The split of PARC700 follows the setting in (Kaplan et al., 2004). Since our model does not assume parallel data, we use distinct sentences in the source and target treebanks. Following previous work (Hockenmaier, 2003; Miyao and Tsujii, 2008), we only consider sentences not exceeding 40 words, except on PARC700 where all sentences are used. Evaluation Metrics: We use two evaluation metrics. First, following previous work, we evaluate our method using the labeled and unlabeled predicate-argument dependency F-score. This metric is commonly used to measure parsing quality for the formalisms considered in this paper. The detailed definition of this measure as applied for each formalism is provided in (Clark and Curran, 2003; Miyao and Tsujii, 2008; Cahill et al., 2004). For CCG, we use the evaluation script from the C&amp;C tools.5 For HP</context>
<context position="32098" citStr="Miyao and Tsujii, 2008" startWordPosition="5330" endWordPosition="5334">84.9 / 88.3 LFG Pipeline 68.5 / 74.0 82.6 / 85.9 Annotator Model 69.8 / 76.6 81.1 / 84.7 Table 4: The labeled/unlabeled dependency Fscore comparisons between our model and stateof-the-art parsers. Comparison to State-of-the-art Parsers: We would also like to demonstrate that the above gains of our transfer model are achieved using an adequate formalism-specific parser. Since our model can be trained exclusively on formalismspecific data, we can compare it to state-of-theart formalism-specific parsers. For this experiment, we choose the C&amp;C parser (Clark and Curran, 2003) for CCG, Enju parser (Miyao and Tsujii, 2008) for HPSG and pipeline automatic annotator (Cahill et al., 2004) with Charniak parser for LFG. For all three parsers, we use the implementation provided by the authors with the default parameter values. All the models are trained on either 1,000 or 15,000 sentences annotated with formalism-specific trees, thus evaluating their performances on small scale or large scale of data. As Table 4 shows, our model is competitive with 298 all the baselines described above. It’s not surprising that Cahill’s model outperforms our loglinear model because it relies heavily on handcrafted rules optimized for</context>
</contexts>
<marker>Miyao, Tsujii, 2008</marker>
<rawString>Yusuke Miyao and Jun’ichi Tsujii. 2008. Feature forest models for probabilistic hpsg parsing. Computational Linguistics, 34(1):35–80.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Yusuke Miyao</author>
<author>Takashi Ninomiya</author>
<author>Junichi Tsujii</author>
</authors>
<title>Corpus-oriented grammar development for acquiring a head-driven phrase structure grammar from the penn treebank. Natural Language Processing–IJCNLP</title>
<date>2005</date>
<pages>684--693</pages>
<contexts>
<context position="7036" citStr="Miyao et al., 2005" startWordPosition="1059" endWordPosition="1062"> observed on CCG and LFG formalisms. 2 Related Work Our work belongs to a broader class of research on transfer learning in parsing. This area has garnered significant attention due to the expense associated with obtaining syntactic annotations. Transfer learning in parsing has been applied in different contexts, such as multilingual learning (Snyder et al., 2009; Hwa et al., 2005; McDonald et al., 2006; McDonald et al., 2011; Jiang and Liu, 2009), domain adaptation (McClosky et al., 2010; Dredze et al., 2007; Blitzer et al., 2006), and crossformalism transfer (Hockenmaier and Steedman, 2002; Miyao et al., 2005; Cahill et al., 2002; Riezler et al., 2002; Chen and Shanker, 2005; Candito et al., 2010). There have been several attempts to map annotations in coarse grammars like CFG to annotations in richer grammar, like HPSG, LFG, or CCG. Traditional approaches in this area typically rely on manually specified rules that encode the relation between the two formalisms. For instance, mappings may specify how to convert traces and functional tags in Penn Treebank to the f-structure in LFG (Cahill, 2004). These conversion rules are typically utilized in two ways: (1) to create a new treebank which is conse</context>
<context position="24098" citStr="Miyao et al., 2005" startWordPosition="3970" endWordPosition="3973">ic syntactic and semantic information. These three types of features work together to generate a tree skeleton and fill in the CFG and CCG labels. 7 Evaluation Setup Grammar Train Dev. Test CCG Sec. 02-21 Sec. 00 Sec. 23 HPSG LFG 140 sents. in 560 sents. in PARC700 PARC700 Table 3: Training/Dev./Test split on WSJ sections and PARC700 for different grammar formalisms. Datasets: As a source of coarse annotations, we use the Penn Treebank-1 (Marcus et al., 1993). In addition, for CCG, HPSG and LFG, we rely on formalism-specific corpora developed in prior research (Hockenmaier and Steedman, 2002; Miyao et al., 2005; Cahill et al., 2002; King et al., 2003). All of these corpora were derived via conversion of Penn Treebank to the target formalisms. In particular, our CCG and HPSG datasets were converted from the Penn Treebank based on hand(d, wl,r, hpl,r, syp,l,r), (d, wl,r, syp,l,r), (c, wl,r, hpl,r, syp,l,r), (c, wl,r, syp,l,r), (d, c, hpl,r, syp,l,r), (d, c, syp,l,r), (c, spl,r, hpl,r, syp,l,r), (c, spl,r, syp,l,r), (pst−1, syp,l,r), (pen+1, syp,l,r), (pst−1, pen+1, syp,l,r), (pst−1, pst−2, syp,l,r), (pen+1, pen+2, syp,l,r), (pst−1, pst−2, pen+1, pen+2, syp,l,r), (r, d, c, hwl,r, hpl,r, hll,r), (r, d, </context>
<context position="25603" citStr="Miyao et al., 2005" startWordPosition="4229" endWordPosition="4232">r) (r, c, spl,r, syl,r, hll,r), (r, c, spl,r, syl,r) fCFG fCCG fjoint 296 88 86 84 82 80 78 76 740 1000 3000 7000 11000 15000 (a) CCG 0 1000 3000 7000 11000 15000 (b) HPSG 86 84 82 80 78 76 74 72 Labeled Dep Unlabeled Dep Unlabeled Parseval 80 75 70 Labeled Dep Unlabeled Dep Unlabeled Parseval 65 0 1000 3000 7000 11000 15000 (c) LFG Labeled Dep Unlabeled Dep Unlabeled Parseval Figure 4: Model performance with 500 target formalism trees and different numbers of CFG trees, evaluated using labeled/unlabeled dependency F-score and unlabeled PARSEVAL. crafted rules (Hockenmaier and Steedman, 2002; Miyao et al., 2005). Table 3 shows which sections of the treebanks were used in training, testing and development for both formalisms. Our LFG training dataset was constructed in a similar fashion (Cahill et al., 2002). However, we choose to use PARC700 as our LFG tesing and development datasets, following the previous work by (Kaplan et al., 2004). It contains 700 manually annotated sentences that are randomly selected from Penn Treebank Section 23. The split of PARC700 follows the setting in (Kaplan et al., 2004). Since our model does not assume parallel data, we use distinct sentences in the source and target</context>
</contexts>
<marker>Miyao, Ninomiya, Tsujii, 2005</marker>
<rawString>Yusuke Miyao, Takashi Ninomiya, and Junichi Tsujii. 2005. Corpus-oriented grammar development for acquiring a head-driven phrase structure grammar from the penn treebank. Natural Language Processing–IJCNLP 2004, pages 684–693.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Yusuke Miyao</author>
</authors>
<title>From Linguistic Theory to Syntactic Analysis: Corpus-Oriented Grammar Development and Feature Forest Model.</title>
<date>2006</date>
<tech>Ph.D. thesis.</tech>
<contexts>
<context position="16468" citStr="Miyao, 2006" startWordPosition="2678" endWordPosition="2679">idates is via supertagging (Clark and Curran, 2007). A supertagger is used for selecting a small set of lexical entry candidates for each word in the sentence. We use the tagger in (Clark and Curran, 2007) as a general suppertagger for all the grammars considered. The only difference is that we use different lexical entries in different grammars. 5.2 Feature Forest Pruning In the BFGS algorithm (see Section 4), feature expectation is computed using the inside-outside algorithm. To perform this dynamic programming efficiently, we first need to build the packed chart, namely the feature forest (Miyao, 2006) to represent the exponential number of all possible tree 3To speed up the implementation, gradient computation is parallelized, using the Message Passing Interface package (Gropp et al., 1999). 4An alternative approach would be to marginalize over yCFG and maximize over yCCG. However, this is a harder computational problem. efCFG(yCFG,S)&apos;θCFG Z(S; BCFG) . 294 structures. However, a common problem for lexicalized grammars is that the forest size is too large. In CFG, the forest is pruned according to the inside probability of a simple generative PCFG model and a prior (Collins, 2003). The basi</context>
<context position="20231" citStr="Miyao, 2006" startWordPosition="3318" endWordPosition="3319">tween coarse and rich formalisms. In this section, we first introduce how different types of feature templates are designed, and then show an example of how the features help transfer the syntactic structure information. Note that the same feature templates are used for all the target grammar formalisms. Recall that our y contains both the CFG and CCG parses, and that these use the same derivation tree structure. Each feature will consider either the CFG derivation, the CCG derivation or these two derivations jointly. The feature construction is similar to constructions used in previous work (Miyao, 2006). The features are based on the atomic features listed in Table 1. These will be used to construct f(y, S) as explained next. hl lexical entries/CCG categories of the head word r grammar rules, i.e. HPSG schema, resulting CCG categories, LFG mapping equations sy CFG syntactic label of the node (e.g. NP, VP) d distance between the head words of the children c whether a comma exists between the head words of the children sp the span of the subtree rooted at the node hw surface form of the head word of the node hp part-of-speech of the head word pi part-of-speech of the i-th word in the sentence </context>
</contexts>
<marker>Miyao, 2006</marker>
<rawString>Yusuke Miyao. 2006. From Linguistic Theory to Syntactic Analysis: Corpus-Oriented Grammar Development and Feature Forest Model. Ph.D. thesis.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jorge Nocedal</author>
<author>Stephen J Wright</author>
</authors>
<title>Numerical optimization.</title>
<date>1999</date>
<publisher>Springer verlag.</publisher>
<contexts>
<context position="14790" citStr="Nocedal and Wright, 1999" startWordPosition="2402" endWordPosition="2405"> both pjoint and pCFG have the same dependence on the fCFG features. The Likelihood Objective: Given the models above, it is natural to use maximum likelihood to find the optimal parameters. To do this, we define the following regularized likelihood function: N L(B) = log (pCFG(yiCFG|Si, BCFG)) + i=1 M log (pCCG(yiCCG |¯Si, B)) − λ2 IIBII22 i=1 where pCCG and pCFG are defined in Equations 2 and 3 respectively. The last term is the l2-norm regularization. Our goal is then to find a B that maximizes L(B). Training Algorithm: For maximizing L(B) w.r.t. B we use the limited-memory BFGS algorithm (Nocedal and Wright, 1999). Calculating the gradient of L(B) requires evaluating the expected values of f(y, S) and fCFG under the distributions pjoint and pCFG respectively. This can be done via the inside-outside algorithm.3 Parsing Using the Model: To parse a sentence S, we calculate the maximum probability assignment for pjoint(y|S; B).4 The result is both a CFG and a CCG parse. Here we will mostly be interested in the CCG parse. The joint parse with maximum probability is found using a standard CYK chart parsing algorithm. The chart construction will be explained in Section 5. 5 Implementation This section introdu</context>
</contexts>
<marker>Nocedal, Wright, 1999</marker>
<rawString>Jorge Nocedal and Stephen J Wright. 1999. Numerical optimization. Springer verlag.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Stephan Oepen</author>
<author>Dan Flickinger</author>
<author>Francis Bond</author>
</authors>
<title>Towards holistic grammar engineering and testing–grafting treebank maintenance into the grammar revision cycle.</title>
<date>2004</date>
<booktitle>In Proceedings of the IJCNLP workshop</booktitle>
<publisher>Citeseer.</publisher>
<contexts>
<context position="8076" citStr="Oepen et al., 2004" startWordPosition="1237" endWordPosition="1240">d functional tags in Penn Treebank to the f-structure in LFG (Cahill, 2004). These conversion rules are typically utilized in two ways: (1) to create a new treebank which is consequently used to train a parser for the target formalism (Hockenmaier and Steedman, 2002; Clark and Curran, 2003; Miyao et al., 2005; Miyao and Tsujii, 2008), (2) to translate the output of a CFG parser into the target formalism (Cahill et al., 2002). The design of these rules is a major linguistic and computational undertaking, which requires multiple iterations over the data to increase coverage (Miyao et al., 2005; Oepen et al., 2004). By nature, the mapping rules are formalism speTSBJ=1 T-1 TOBJ=1 [Pron.I] [ SBJ, OBJ] [N.3pl] T T NP VB NP I eat apples I eat apples ROOT S T-1 VP CFG S[dcl] CCG LFG [N.no3sg] [N&lt;V.bse&gt;N] [N.3pl] NP (S[dcl]\NP)/NP NP I eat apples I eat apples subj_head head_comp S[dcl]\NP HPSG 292 cific and therefore not transferable. Moreover, frequently designing such mappings involves modification to the original annotations. For instance, Hockenmaier and Steedman (2002) made thousands of POS and constituent modifications to the Penn Treebank to facilitate transfer to CCG. More importantly, in some transfe</context>
</contexts>
<marker>Oepen, Flickinger, Bond, 2004</marker>
<rawString>Stephan Oepen, Dan Flickinger, and Francis Bond. 2004. Towards holistic grammar engineering and testing–grafting treebank maintenance into the grammar revision cycle. In Proceedings of the IJCNLP workshop beyond shallow analysis. Citeseer.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Slav Petrov</author>
<author>Dan Klein</author>
</authors>
<title>Improved inference for unlexicalized parsing.</title>
<date>2007</date>
<booktitle>In Human Language Technologies 2007: The Conference of the North American Chapter of the Association for Computational Linguistics,</booktitle>
<pages>404--411</pages>
<contexts>
<context position="27162" citStr="Petrov and Klein, 2007" startWordPosition="4483" endWordPosition="4486">dependency F-score. This metric is commonly used to measure parsing quality for the formalisms considered in this paper. The detailed definition of this measure as applied for each formalism is provided in (Clark and Curran, 2003; Miyao and Tsujii, 2008; Cahill et al., 2004). For CCG, we use the evaluation script from the C&amp;C tools.5 For HPSG, we evaluate all types of dependencies, including punctuations. For LFG, we consider the preds-only dependencies, which are the dependencies between pairs of words. Secondly, we also evaluate using unlabeled PARSEVAL, a standard measure for PCFG parsing (Petrov and Klein, 2007; Charniak and Johnson, 2005; Charniak, 2000; Collins, 1997). The dependency F-score captures both the target5Available at http://svn.ask.it.usyd.edu.au/trac/candc/wiki grammar labels and tree-structural relations. The unlabeled PARSEVAL is used as an auxiliary measure that enables us to separate these two aspects by focusing on the structural relations exclusively. Training without CFG Data: To assess the impact of coarse data in the experiments below, we also consider the model trained only on formalism-specific annotations. When no CFG sentences are available, we assign all the CFG labels t</context>
</contexts>
<marker>Petrov, Klein, 2007</marker>
<rawString>Slav Petrov and Dan Klein. 2007. Improved inference for unlexicalized parsing. In Human Language Technologies 2007: The Conference of the North American Chapter of the Association for Computational Linguistics, pages 404–411.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Carl Pollard</author>
<author>Ivan A Sag</author>
</authors>
<title>Head-driven phrase structure grammar.</title>
<date>1994</date>
<publisher>University of Chicago Press.</publisher>
<contexts>
<context position="2731" citStr="Pollard and Sag, 1994" startWordPosition="396" endWordPosition="399"> designing these rules frequently requires external resources such as Wordnet, and even involves correction of the existing treebank. This effort has to be repeated for each new grammar formalism, each new annotation scheme and each new language. In this paper, we propose an alternative approach for parsing constituency-based grammars. Instead of using manually-crafted transformation rules, this approach relies on a small amount of annotations in the target formalism. Frequently, such annotations are available in linguistic texts that introduce the formalism. For instance, a textbook on HPSG (Pollard and Sag, 1994) illustrates grammatical constructions using about 600 examples. While these examples are informative, they are not sufficient for training. To compensate for the annotation sparsity, our approach utilizes coarsely annotated data readily available in large quantities. A natural candidate for such coarse annotations is context-free grammar (CFG) from the Penn Treebank, while the target formalism can be any constituency-based grammars, such as Combinatory Categorial Grammar (CCG) (Steedman, 2001), Lexical Functional Grammar (LFG) (Bresnan, 1982) or Head-Driven Phrase Structure Grammar (HPSG) (Po</context>
</contexts>
<marker>Pollard, Sag, 1994</marker>
<rawString>Carl Pollard and Ivan A Sag. 1994. Head-driven phrase structure grammar. University of Chicago Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Stefan Riezler</author>
<author>Tracy H King</author>
<author>Ronald M Kaplan</author>
<author>Richard Crouch</author>
<author>John T Maxwell</author>
<author>Mark Johnson</author>
</authors>
<title>Parsing the wall street journal using a lexical-functional grammar and discriminative estimation techniques.</title>
<date>2002</date>
<booktitle>In Proceedings of the 40th Annual Meeting on Association for Computational Linguistics,</booktitle>
<pages>271--278</pages>
<publisher>Association</publisher>
<institution>for Computational Linguistics.</institution>
<contexts>
<context position="7079" citStr="Riezler et al., 2002" startWordPosition="1067" endWordPosition="1071">lated Work Our work belongs to a broader class of research on transfer learning in parsing. This area has garnered significant attention due to the expense associated with obtaining syntactic annotations. Transfer learning in parsing has been applied in different contexts, such as multilingual learning (Snyder et al., 2009; Hwa et al., 2005; McDonald et al., 2006; McDonald et al., 2011; Jiang and Liu, 2009), domain adaptation (McClosky et al., 2010; Dredze et al., 2007; Blitzer et al., 2006), and crossformalism transfer (Hockenmaier and Steedman, 2002; Miyao et al., 2005; Cahill et al., 2002; Riezler et al., 2002; Chen and Shanker, 2005; Candito et al., 2010). There have been several attempts to map annotations in coarse grammars like CFG to annotations in richer grammar, like HPSG, LFG, or CCG. Traditional approaches in this area typically rely on manually specified rules that encode the relation between the two formalisms. For instance, mappings may specify how to convert traces and functional tags in Penn Treebank to the f-structure in LFG (Cahill, 2004). These conversion rules are typically utilized in two ways: (1) to create a new treebank which is consequently used to train a parser for the targ</context>
<context position="9079" citStr="Riezler et al., 2002" startWordPosition="1400" endWordPosition="1403">ation to the original annotations. For instance, Hockenmaier and Steedman (2002) made thousands of POS and constituent modifications to the Penn Treebank to facilitate transfer to CCG. More importantly, in some transfer scenarios, deterministic rules are not sufficient, due to the high ambiguity inherent in the mapping. Therefore, our work considers an alternative set-up for crossformalism transfer where a small amount of annotations in the target formalism is used as an alternative to using deterministic rules. The limitation of deterministic transfer rules has been recognized in prior work (Riezler et al., 2002). Their method uses a hand-crafted LFG parser to create a set of multiple parsing candidates for a given sentence. Using the partial mapping from CFG to LFG as the guidance, the resulting trees are ranked based on their consistency with the labeled LFG bracketing imported from CFG. In contrast to this method, we neither require a parser for the target formalism, nor manual rules for partial mapping. Consequently, our method can be applied to many different target grammar formalisms without significant engineering effort for each one. The utility of coarse-grained treebanks is determined by the</context>
</contexts>
<marker>Riezler, King, Kaplan, Crouch, Maxwell, Johnson, 2002</marker>
<rawString>Stefan Riezler, Tracy H King, Ronald M Kaplan, Richard Crouch, John T Maxwell III, and Mark Johnson. 2002. Parsing the wall street journal using a lexical-functional grammar and discriminative estimation techniques. In Proceedings of the 40th Annual Meeting on Association for Computational Linguistics, pages 271–278. Association for Computational Linguistics.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Benjamin Snyder</author>
<author>Tahira Naseem</author>
<author>Regina Barzilay</author>
</authors>
<title>Unsupervised multilingual grammar induction.</title>
<date>2009</date>
<booktitle>In Proceedings of the Joint Conference of the 47th Annual Meeting of the ACL and the 4th International Joint Conference on Natural Language Processing of the AFNLP: Volume</booktitle>
<volume>1</volume>
<pages>73--81</pages>
<publisher>Association</publisher>
<institution>for Computational Linguistics.</institution>
<contexts>
<context position="6783" citStr="Snyder et al., 2009" startWordPosition="1016" endWordPosition="1020">results are 2While the Penn Treebank-2 contains richer annotations, we decided to use the Penn Treebank-1 to demonstrate the feasibility of transfer from coarse annotations. Figure 1: Derivation trees for CFG as well as CCG, HPSG and LFG formalisms. also observed on CCG and LFG formalisms. 2 Related Work Our work belongs to a broader class of research on transfer learning in parsing. This area has garnered significant attention due to the expense associated with obtaining syntactic annotations. Transfer learning in parsing has been applied in different contexts, such as multilingual learning (Snyder et al., 2009; Hwa et al., 2005; McDonald et al., 2006; McDonald et al., 2011; Jiang and Liu, 2009), domain adaptation (McClosky et al., 2010; Dredze et al., 2007; Blitzer et al., 2006), and crossformalism transfer (Hockenmaier and Steedman, 2002; Miyao et al., 2005; Cahill et al., 2002; Riezler et al., 2002; Chen and Shanker, 2005; Candito et al., 2010). There have been several attempts to map annotations in coarse grammars like CFG to annotations in richer grammar, like HPSG, LFG, or CCG. Traditional approaches in this area typically rely on manually specified rules that encode the relation between the t</context>
</contexts>
<marker>Snyder, Naseem, Barzilay, 2009</marker>
<rawString>Benjamin Snyder, Tahira Naseem, and Regina Barzilay. 2009. Unsupervised multilingual grammar induction. In Proceedings of the Joint Conference of the 47th Annual Meeting of the ACL and the 4th International Joint Conference on Natural Language Processing of the AFNLP: Volume 1-Volume 1, pages 73–81. Association for Computational Linguistics.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Mark Steedman</author>
</authors>
<title>The syntactic process.</title>
<date>2001</date>
<publisher>MIT press.</publisher>
<contexts>
<context position="3230" citStr="Steedman, 2001" startWordPosition="470" endWordPosition="471">available in linguistic texts that introduce the formalism. For instance, a textbook on HPSG (Pollard and Sag, 1994) illustrates grammatical constructions using about 600 examples. While these examples are informative, they are not sufficient for training. To compensate for the annotation sparsity, our approach utilizes coarsely annotated data readily available in large quantities. A natural candidate for such coarse annotations is context-free grammar (CFG) from the Penn Treebank, while the target formalism can be any constituency-based grammars, such as Combinatory Categorial Grammar (CCG) (Steedman, 2001), Lexical Functional Grammar (LFG) (Bresnan, 1982) or Head-Driven Phrase Structure Grammar (HPSG) (Pollard and Sag, 1994). All of these formalisms share a similar basic syntactic structure with Penn Treebank CFG. However, the target formalisms also encode additional constraints and semantic features. For instance, Penn Treebank annotations do not make an explicit distinction between complement and adjunct, while all the above grammars mark these 291 Proceedings of the 51st Annual Meeting of the Association for Computational Linguistics, pages 291–301, Sofia, Bulgaria, August 4-9 2013. c�2013 A</context>
</contexts>
<marker>Steedman, 2001</marker>
<rawString>Mark Steedman. 2001. The syntactic process. MIT press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Yue Zhang</author>
<author>Stephen Clark</author>
</authors>
<title>Shift-reduce ccg parsing.</title>
<date>2011</date>
<booktitle>In Proceedings of the 49th Meeting of the Association for Computational Linguistics,</booktitle>
<pages>683--692</pages>
<marker>Zhang, Clark, 2011</marker>
<rawString>Yue Zhang, Stephen Clark, et al. 2011. Shift-reduce ccg parsing. In Proceedings of the 49th Meeting of the Association for Computational Linguistics, pages 683–692.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>