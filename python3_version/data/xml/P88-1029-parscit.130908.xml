<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000108">
<title confidence="0.9993275">
Conditional Descriptions in
Functional Unification Grammar
</title>
<author confidence="0.895294">
Robert T. Kasper
</author>
<affiliation confidence="0.534014666666667">
USC/Information Sciences Institute
4676 Admiralty Way, Suite 1001
Marina del Rey, CA 90292 U.S.A.
</affiliation>
<sectionHeader confidence="0.944946" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999784928571429">
A grammatical description often applies to a linguistic object
only when that object has certain features. Such conditional
descriptions can be indirectly modeled in Kay&apos;s Functional
Unification Grammar (FUG) using functional descriptions
that are embedded within disjunctive alternatives. An ex-
tension to FUG is proposed that allows for a direct represen-
tation of conditional descriptions. This extension has been
used to model the input conditions on the systems of systemic
grammar. Conditional descriptions are formally defined in
terms of logical implication and negation. This formal defi-
nition enables the use of conditional descriptions as a general
notational extension to any of the unification-based gram-
mar representation systems currently used in computational
linguistics.
</bodyText>
<sectionHeader confidence="0.998988" genericHeader="keywords">
1 Introduction
</sectionHeader>
<bodyText confidence="0.999608476190476">
Functional Unification Grammar [Kay79] (FUG) and other
grammatical formalisms that use feature structures and uni-
fication provide a general basis for the declarative representa-
tion of natural language grammars. In order to utilize some
of the computational tools available with unification gram-
mars, we have developed a mapping from systemic gram-
mars [Ha1176] into FUG notation. This mapping has been
used as the first step in creating a general parsing method
for systemic grammars tKas87a1. The experience of trans-
lating systemic grammars into FUG has shown several ways
in which the notational resources of FUG may be improved.
In particular, FUG has limited notational resources for ex-
pressing conditional information. In this paper we describe
how FUG has been enhanced by the addition of conditional
descriptions, building on research that has already been re-
ported [Kas87a,Kas86,Kas87b].
Conditional information is stated explicitly in systemic
grammars by the input conditions of systems that specify
when a system must be used. Consider, for example, the two
systems (MoodType and IndicativeType)&apos; shown in Figure 1.
The input condition for the MoodType system is the feature
</bodyText>
<footnote confidence="0.485527666666667">
1This example is extracted from Nigel [Mann831, a large sys-
temic grammar of English that has been developed in text gener-
ation research at USC/ISI.
</footnote>
<bodyText confidence="0.9990348">
Clause, and the input condition for the IndicativeType sys-
tem is the feature Indicative. Because the features of a sys-
temic grammar are normally introduced by a unique system,
these input conditions actually express a bidirectional type
of logical implication:
</bodyText>
<listItem confidence="0.872809142857143">
1. If a constituent has the feature(s) specified by a sys-
tem&apos;s input condition, then exactly one of the alterna-
tives described by that system must also be valid for
the constituent;
2. If a constituent has one of the feature alternatives de-
scribed by a system, then it must also have the fea-
ture(s) specified by that system&apos;s input condition.
</listItem>
<bodyText confidence="0.99328744">
Thus the input condition of the IndicativeType system ex-
presses the following implications:
1. If a clause has the feature Indicative, then it must also
have exactly one of the alternatives from the Indica-
tiveType system (either Declarative or Interrogative).
2. If a clause has one of the feature alternatives described
by the Indicative Type system (either Declarative or In-
terrogative), then it must also have the feature Indica-
tive.
While it is theoretically correct to regard the two directions of
implication as exact converses of each other, there is a subtle
difference between them. The consequent of the first type of
implication is the description of the entire system, including
systemic features and their realizations.2 The antecedent of
the second type of implication can be safely abbreviated by
the systemic features without their realizations, because the
presence of a systemic feature implies that its realizations
also hold. We will return to this distinction when we provide
a formal definition of conditional descriptions in Section 2.
For simple input conditions, the first type of implication
can be expressed in FUG, as it was originally formulated by
Kay [Kay79], by embedding the description of one system in-
side the description of another. For example, we can capture
this implication for the IndicativeType system by embedding
it within the description of the Indicative alternative of the
</bodyText>
<footnote confidence="0.998911333333333">
2A realisation is a statement of structural properties that are
required by a feature, such as the statement that SUBJECT pre-
cedes FINITE for the feature declarative.
</footnote>
<page confidence="0.998374">
233
</page>
<figure confidence="0.999301846153846">
—Clause
MOOD
TYPE
Imperative
NONFINITIVE!S tem
Declarative
SUBJECT A FINITE
INDICATIVE
TYPE
SUBJECT:Nominative
RANK
Indicative
Interrogative
</figure>
<figureCaption confidence="0.998888">
Figure 1: The MoodType and IndicativeType Systems
</figureCaption>
<figure confidence="0.949899222222222">
Rank = Clause
MoodType = Imperative
NONFINITIVE = [ Form = Stem]
MoodType = Indicative
SUBJECT = [ Case = Nominative]
IndicativeType = Declarative
pattern = (... SUBJECT FINITE ...)
IndicativeType = Interrogative
3 IndicativeType [ MoodType = Indicative
</figure>
<figureCaption confidence="0.999824">
Figure 2: The MoodType and IndicativeType Systems in FUG
</figureCaption>
<bodyText confidence="0.9346845625">
MoodType system, as shown in Figure 2. Note that the sec-
ond type of implication expressed by systemic input condi-
tions has not been expressed by embedding one functional
description inside another. To express the second type of im-
plication, we have used a different notational device, called a
feature existence condition; it will be defined in Section 2.4.
Not all systems have simple input conditions consisting
of single features. Those input conditions which are com-
plex boolean expressions over features cannot be expressed
directly by embedding. Consider the BenefactiveVoice sys-
tem shown in Figure 3 as an example. Its input condition is
the conjunction of two features, Agentive and Benefactive.
One way to express a system with a complex input con-
dition in FUG is to use a disjunction with two alternatives,
as shown in Figure 4. The first alternative corresponds to
what happens when the BenefactiveVoice system is entered;
the second alternative corresponds to what happens when the
BenefactiveVoice system is not entered. The first alternative
also includes the features of the input condition. The second
alternative includes the features of the negated input condi-
tion. Notice that the input condition and its negation must
both be stated explicitly, unlike in systemic notation. If the
negation of the input condition was not included in the sec-
ond alternative, it would be possible to use this alternative
&apos;The BenefactivcVoice system is also extracted from the Nigel
grammar [Mann83]. It describes the active and passive voice op-
tions that are possible in clauses that have both an agent and
a beneficiary. The active/passive distinction is not primitive in
systemic grammars of English. Instead, it is decomposed into sev-
eral cases depending on which participant roles are present in the
clause. In this case the subject of a passive clause may be conflated
with either beneficiary or medium.
even when the input condition for the system holds. Thus
the description of the system would not always be used when
it should be. Note that this method of encoding systemic in-
put conditions presupposes an adequate treatment of negated
features.&apos; A formal definition of negation will be developed
in Section 2.3.
While it is formally possible to encode complex input con-
ditions by disjunction and negation, such encoding is not al-
together satisfactory.. It should not be necessary to state the
negated input condition explicitly, since it can always be de-
rived automatically from the unnegated condition. It is also
rather inefficient to mix the features of the input condition
with the other features of the system. The features of the in-
put condition contain exactly the information that is needed
to choose between the two alternatives of the disjunction (i.e.,
to choose whether the system is entered or not). It would be
more efficient and less verbose to have a notation in which
the features of the input condition are distinguished from
the other features of the system, and in which the negation
of the input condition does not need to be stated explicitly.
Therefore, we have developed an extension to FUG that uses
a conditional operator (-0), as illustrated by the encoding of
the BenefactiveVoice system shown in Figure 5. A descrip-
tion corresponding to the input condition appears to the left
of the symbol, and the description to be included when
the input condition is satisfied appears to its right. A formal
definition of what it means for a description to be satisfied
will be given in Section 2.1.
*Some negations of atomic features can be replaced by a finite
disjunction of other possible values for that feature, but this tech-
nique only works effectively when the set of possible values is small
and can be enumerated.
</bodyText>
<page confidence="0.988927">
234
</page>
<figure confidence="0.977180375">
BenefactiveActive
AGENT / SUBJECT
MEDIUM / DIRECTCOMP
Agentive — edioPassive
Benefactive — MEDIUM / SUBJECT
enePassive
BENEFICIARY / SUBJECT
MEDIUM / DIRECTCOMP
</figure>
<figureCaption confidence="0.984948">
Figure 3: The BenefactiveVoice System.
</figureCaption>
<figure confidence="0.996071">
Rank = Clause
Agentivity = Agentive
Benefaction = Benefacitve
BenefactiveVoice = BenefactiveActive
AGENT = &lt;SUBJECT&gt;
MEDIUM = &lt;DIRECTCOMP&gt;
BenefactiveVoice = MedloPassive
MEDIUM = &lt;SUBJECT&gt;
BenefactiveVoice = BenePassive
BENEFICIARY = &lt;SUBJECT&gt;
MEDIUM = &lt;DIRECTCOMP&gt;
Agentivity = NOT Agentive .1 I
Benefaction = NOT Benefactive
BenefactiveVoice = NONE
</figure>
<figureCaption confidence="0.994443">
Figure 4: BenefactiveVoice system in FUG, using disjunction and negation.
</figureCaption>
<figure confidence="0.989060083333333">
Rank = Clause
BenefactiveVoice = BenefactiveActive
AGENT = &lt;SUBJECT&gt;
MEDIUM = &lt;DIRECTCOMP&gt;
Agentivity = Agentive I _, BenefactiveVoice = MedioPassive
{
Benefaction = Benefactive MEDIUM = &lt;SUBJECT&gt;
BenefactiveVoice = BenePassive
BENEFICIARY = &lt;SUBJECT&gt;
MEDIUM = &lt;DIRECTCOMP&gt;
9 BenefactiveVoice —■ [ Agentivity = Agentive I
Benefaction = Benefactive
</figure>
<figureCaption confidence="0.998305">
Figure 5: BenefactiveVoice system in extended FUG, using two conditional descriptions.
</figureCaption>
<bodyText confidence="0.3553955">
Note: In systemic notation curly braces represent conjunction and square braces represent disjunction, while in FUG curly
braces represent disjunction and square braces represent conjunction.
</bodyText>
<page confidence="0.901814">
235
</page>
<bodyText confidence="0.997026">
NIL denoting no information;
a where a E A, to describe atomic values;
: where 1 E L and 0 E FDL, to describe structures
in which the feature labeled by 1 has a value described by 0;
where each pi E Ls, to describe an equivalence class
of paths sharing a common value in a feature structure;
where 0; E FDL, denoting conjunction;
where 0; E FDL, denoting disjunction.
01 A 02 or [01.• • On]
</bodyText>
<note confidence="0.611942">
Note: A and L are sets of symbols which are used to denote atomic values and feature labels, respectively.
</note>
<figureCaption confidence="0.997157">
Figure 6: Syntax of FDL Formulas.
</figureCaption>
<sectionHeader confidence="0.976059" genericHeader="introduction">
2 Definitions
</sectionHeader>
<bodyText confidence="0.999977">
The feature description logic (FDL) of Kasper and
Rounds [Kas861 provides a coherent framework to give a pre-
cise interpretation for conditional descriptions. As in previ-
ous work, we carefully observe the distinction between fea-
ture structures and their descriptions. Feature structures are
represented by directed graphs (DGs), and descriptions of
feature structures are represented by logical formulas. The
syntax for formulas of FDL is given in Figure 6. We define
several new types of formulas for conditional descriptions and
negations, but the domain of feature structures remains DGs,
as before.
</bodyText>
<subsectionHeader confidence="0.98969">
2.1 Satisfaction and Compatibility
</subsectionHeader>
<bodyText confidence="0.999592913043478">
In order to understand how conditional descriptions are used,
it is important to recognize two relations that may hold be-
tween a particular feature structure and a description: satis-
faction and compatibility. Satisfaction implies compatibility,
so there are three possible states that a particular structure
may have with respect to a description: the structure may
fully satisfy the description, the structure may be incompat-
ible with the description, or the structure may be compatible
with (but not satisfy) the description. To define these terms
more precisely, consider the state of an arbitrary structure,
A, with respect to an atomic feature description, f : v:
A satisfies f : v if f occurs in A with value v;
A is incompatible with f: v if f occurs in A with value
z, for some z v;
A is (merely) compatible with f : v if f does not occur
in A.
Because feature structures are used to represent partial
information, it is possible for a structure that is merely com-
patible with a description to be extended (i.e., by adding a
value for some previously nonexistent feature) so that it ei-
ther satisfies or becomes incompatible with the description.
Consider, for example, the structure (Ai) shown in Figure 7,
and the three descriptions:
</bodyText>
<table confidence="0.977007666666667">
subj: (person : 3 A number : sing)
subj: (person: 1 A number : sing)
subj : (case : norm A number : sing)
subj
erson number gender
3 sing neut
</table>
<figureCaption confidence="0.993787">
Figure 7: Example feature structure (Ai).
</figureCaption>
<bodyText confidence="0.997484333333333">
Description (1) is satisfied by A1, because Ai is fully instan-
tiated with all the required feature values. Description (2) is
incompatible with A1, because Ai has a different value for the
feature subj : person. Description (3) is merely compatible
with A1 (but not satisfied by Ai), because Ai has no value
for the feature subj : case.
In the following definitions, the notation A =0 means that
the structure A satisfies the description 0, and the notation
A &amp;quot;, 0 means that the structure A is compatible with the
description 0.
Logical combinations of feature descriptions are evaluated
with their usual semantics to determine whether they are
satisfied by a structure. Thus, a conjunction is satisfied only
when every conjunct is satisfied, and a disjunction is satis-
fied if any disjunct is satisfied. The formal semantics of the
satisfaction relation has been specified in our previous work
describing FDL [Kas86]. The semantics of the compatibility
relation is given by the following conditions:
</bodyText>
<listItem confidence="0.99561325">
1. A-&apos; NIL always;
2. A a •:=:.• A is the atomic structure a;
3. A &amp;quot;, 1.&lt; pi &lt; p. 4=. all DGs in the
set {A/ &lt; pi &gt;,...,A/ &lt; p,, &gt;} can be unified (any
member of this set may be undefined; such members
are equivalent to null DGs);
4. A &amp;quot;,l:0 &lt;=&gt;. All is undefined or All&amp;quot;, d;
6. A 0 A 0 4=:- A &amp;quot;, canonical form of 0 A 0.
</listItem>
<bodyText confidence="0.852091666666667">
Unlike satisfaction, the semantics of compatibility cannot be
defined by simple induction over conjunctive formulas, be-
cause of a subtle interaction between path equivalences and
</bodyText>
<page confidence="0.991207">
236
</page>
<bodyText confidence="0.9953974">
nonexistent features. For example, consider whether A:,
shown in Figure 7, is compatible with the description:
number : pi A ll&lt; number &gt;,&lt; aubj number &gt;1.
A1 is compatible with number : pl, and A1 is also compat-
ible with l&lt; number &gt;,&lt; &apos;Raj number &gt;1, but A: is not
compatible with the conjunction of these two descriptions,
because it requires subj : number : pi and AL has sing as the
value of that feature.
Thus, in order to determine whether a structure is compat-
ible with a conjunctive description, it is generally necessary
to unify all conjuncts, putting the description into the canon-
ical form described in [Kas87c]. This canonical form (i.e. the
feature-description data structure) contains definite and in-
definite components. The definite component contains no
disjunction, and is represented by a DG structure that satis-
fies all non-disjunctive parts of a description. The indefinite
component is a list of disjunctions. A structure is compatible
with a description in canonical form if and only if it is unifi-
able with the definite component and it is compatible with
each disjunction of the indefinite component.
</bodyText>
<subsectionHeader confidence="0.996155">
2.2 Conditional Description
</subsectionHeader>
<bodyText confidence="0.999986666666667">
We augment FDL with a new type of formula to represent
conditional descriptions, using the notation, a #, and the
standard interpretation given for material implication:
</bodyText>
<equation confidence="0.817927">
Aa-015 -ia V fl. (4)
</equation>
<bodyText confidence="0.997238">
This interpretation of conditionals presupposes an interpre-
tation of negation over feature descriptions, which is given
below. To simplify the interpretation of negations, we ex-
clude formulas containing path equivalences and path values
from the antecedents of conditionals.
</bodyText>
<subsectionHeader confidence="0.993841">
2.3 Negation
</subsectionHeader>
<bodyText confidence="0.998982333333333">
We use the classical interpretation of negation, where
A -10 4=4. A (P. Negated descriptions are defined for
the following types of formulas:
</bodyText>
<listItem confidence="0.96677025">
1. A 4=t- A is not the atom a;
2. A : 4)) -4==. A : -10 or A is not defined;
3. A j= --1(95 V 1,0 &lt;=i. A = -4 A -4;
4. A -v(4) A 0) &lt;=&gt;.
</listItem>
<bodyText confidence="0.9922591875">
Note that we have not defined negation for formulas contain-
ing path equivalences or path values. This restriction makes
it possible to reduce all occurrences of negation to a boolean
combination of a finite number of negative constraints on
atomic values. While the classical interpretation of negation
is not strictly monotonic with respect to the normal sub-
sumption ordering on feature structures, the restricted type
of negation proposed here does not suffer from the ineffi-
ciencies and order-dependent unification properties of gen-
eral negation or intuitionistic negation [Mosh87,Per87]. The
reason for this is that we have restricted negation so that
all negative information can be specified as local constraints
on single atomic feature values. Thus, these constraints only
come into play when specific atomic values are proposed for
a feature, and they can be checked as efficiently as positive
atomic value constraints.
</bodyText>
<subsectionHeader confidence="0.995256">
2.4 Feature Existence Conditions
</subsectionHeader>
<bodyText confidence="0.978829892857143">
A special type of conditional description is needed when the
antecedent of a conditional is an existence predicate for a
particular feature, and not a regular feature description. We
call this type of conditional a feature existence condition, and
use the notation:
3f —■ (k, where A3f 4=&gt; Al f is defined.
This use of 3! is essentially equivalent to the use off = ANY
in Kay&apos;s FUG, where ANY is a place-holder for any substan-
tive (i.e., non-NIL) value.
The primary effect of a feature existence condition, such as
3f --• 4,, is that the consequent is asserted whenever a sub-
stantive value is introduced for a feature labeled by f. The
treatment of feature existence conditions differs slightly from
other conditional descriptions in the way that an unsatisfiable
consequent is handled. In order to negate the antecedent of
3f —■ 4o, we need to state that f may never have any sub-
stantive value. This is accomplished by unifying a special
atomic value, such as NONE, with the value of f. This spe-
cial atomic value is incompatible with any other real value
that might be proposed as a value for f.
Feature existence conditions are needed to model the sec-
ond type of implication expressed by systemic input condi-
tions - namely, when a constituent has one of the feature
alternatives described by a system, it must also have the fea-
ture(s) specified by that system&apos;s input condition. Generally,
a system named f with input condition a and alternatives
described by ft, can be represented by two conditional de-
scriptions:
</bodyText>
<listItem confidence="0.9853165">
1. a 7+ 13;
2. 3f --• a.
</listItem>
<bodyText confidence="0.99984975">
For example, recall the BenfactiveVoice system, which is rep-
resented by the two conditionals shown in Figure 5.
It is important to note that feature existence conditions
are used for systems with simple input conditions as well as
for those with complex input conditions. The use of feature
existence conditions is essential in both cases to encode the
bidirectional dependency between systems that is implicit in
a systemic network.
</bodyText>
<sectionHeader confidence="0.984304" genericHeader="method">
3 Unification with Conditional
Descriptions
</sectionHeader>
<bodyText confidence="0.999652">
The unification operation, which is commonly used to com-
bine feature structures (i.e., non-disjunctive, non-conditional
DGs), can be generalized to define an operation for combining
the information of two feature descriptions (i.e., formulas of
FDL). In FDL, the unification of two descriptions is equiva-
lent to their logical conjunction, as discussed in [Kas871,]. We
</bodyText>
<page confidence="0.990827">
237
</page>
<bodyText confidence="0.999920521739131">
have shown in previous work 1Kas87c1 how unification can be
accomplished for disjunctive descriptions without expanding
to disjunctive normal form.
This unification method factors descriptions into a canon-
ical form consisting of definite and indefinite components.
The definite component contains no disjunction, and is rep-
resented by a DG structure that satisfies all non-disjunctive
parts of a description. The indefinite component of a de-
scription is a list of disjunctions. When two descriptions
are unified, the first step is to unify their definite compo-
nents. Then the indefinite components of each description
are checked for compatibility with the resulting definite com-
ponent. Disjuncts are eliminated from the description when
they are inconsistent with definite information. When only
one alternative of a disjunction remains, it is unified with the
definite component of the description.
This section details how this unification method can be
extended to handle conditional descriptions. Conditionals
may be regarded as another type of indefinite information in
the description of a feature structure. They are indefinite in
the sense that they impose constraints that can be satisfied
by several alternatives, depending on the values of features
already present in a structure.
</bodyText>
<subsectionHeader confidence="0.996943">
3.1 How to Satisfy a Conditional
Description
</subsectionHeader>
<bodyText confidence="0.986920517241379">
The constraints imposed on a feature structure by a condi-
tional description can usually be determined most efficiently
by first examining the antecedent of the conditional, because
it generally contains a smaller amount of information than
the consequent. Examining the antecedent is often sufficient
to determine whether the consequent is to be included or
discarded.
Given a conditional description, C = a we can
define the constraints that it imposes on a feature structure
(A) as follows. When:
A a, then A
A 96 a, then C imposes no further constraint on A, and can
therefore be eliminated;
A a, then check whether # is compatible with A.
If compatible, then C must be retained in the descrip-
tion of A.
If incompatible, then A -la (and C can be elimi-
nated).
These constraints follow directly from the interpretation (4)
that we have given for conditional descriptions. These con-
straints are logically equivalent to those that would be im-
posed on A by the disjunction -Ice V # , as required. However,
the constraints of the conditional can often be imposed more
efficiently than those of the equivalent disjunction, because
examining the antecedent of the conditional carries the same
cost as examining only one of the disjuncts. When the con-
straints of a disjunction are imposed, both of the disjuncts
must be examined in all cases.
5Ftead this constraint as: &apos;make sure that A satisfies a.&amp;quot;
</bodyText>
<subsectionHeader confidence="0.995523">
3.2 Extending the Unification
Algorithm
</subsectionHeader>
<bodyText confidence="0.982516777777778">
The unification algorithm for disjunctive feature descrip-
tions [Kas87c) can be extended to handle conditionals by
recognizing two types of indefinite information in a descrip-
tion: disjunctions and conditionals. The extended feature-
description data structure has the components:
definite: a DG structure;
disjunction&apos;: a list of disjunctions;
conditionals: a list of conditional descriptions.
The part of the unification algorithm that checks the compat-
ibility of indefinite components of a description with its def-
inite component is defined by the function CHECK-INDEF,
shown in Figure 8. This algorithm checks the disjunctions of
a description before conditionals, but an equally correct ver-
sion of this algorithm might check conditionals before disjunc-
tions. In our application of parsing with a systemic grammar
it is generally more efficient to check disjunctions first, but
other applications might be made more efficient by varying
this order.
</bodyText>
<sectionHeader confidence="0.997841" genericHeader="method">
4 Potential Refinements
</sectionHeader>
<bodyText confidence="0.99987255">
Several topics merit further investigation regarding condi-
tional descriptions. The implementation we describe has the
constraints of conditionals and disjunctions imposed in an ar-
bitrary order. Changing the order has no effect on the final
result, but it is likely that the efficiency of unification could
be improved by ordering the conditionals of a grammar in
a deliberate way. Another way to improve the efficiency of
unification with conditionals would involve indexing them by
the features that they contain. Then a conditional would
not need to be checked against a structure until some feature
value of the structure might determine the manner in which
it is satisfied. The amount of efficiency gained by such tech-
niques clearly depends largely on the nature of the particular
grammar being used in an application.
A slightly different type of conditional might be used as a
way to speed up unification with binary disjunctive descrip-
tions. If it is known that the values of a relatively small
number of features can be used to discriminate between two
alternative descriptions, then those features can be factored
into a separate condition in a description such as
</bodyText>
<sectionHeader confidence="0.741696" genericHeader="method">
IF condition THEN alti ELSE alt2.
</sectionHeader>
<bodyText confidence="0.9999178">
When the condition is satisfied by a structure, then alt i is
selected. When the condition is incompatible with a struc-
ture, then alt2 is selected. Otherwise both alternatives must
remain under consideration. As it oftm requires a consider-
able amount of time to check which alternatives of a disjunc-
tion are applicable, this technique might offer a significant
improvement in an application where large disjunctive de-
scriptions are used.
Remember that we have restricted conditionals by requir-
ing that their antecedents do not contain path equivalences.
</bodyText>
<page confidence="0.993063">
238
</page>
<table confidence="0.911596379310345">
Function CHECK-INDEF (desc) Returns feature-description:
where desc is a feature-description.
Let D = desc.definite (a DG).
Let disjunctions = desc.disjunctions.
Let conditionals = desc.conditionals.
Let unchecked-parts = true.
While unchecked-parts, do:
unchecked-parts := false.
Cluck compatibility of disjunctions with D (omited, see [Kas87c]).
Check compatibility of conditionals with D:
Let new-conditionals = 0.
For each a —+ p in conditionals:
test whether D satisfies or is compatible with a:
SATISFIES: P := UNIFY-DGS (D, P.definite),
disjunctions := disjunctions u p .disjunctions,
unchecked-parts := true;
COMPATIBLE: If D is compatible with p,
then new-conditionals := new-conditionals U {a —■ p},
else let neg-ante =
D := UNIFY-DGS (P, neg-ante.definite),
disjunctions := disjunctions u neg-ante.disjunctions,
unchecked-parts := true;
INCOMPATIBLE: this conditional imposes no further constraint.
end (for loop).
conditionals := new-conditionals.
end (while loop).
Let nd = make feature-description with:
nd.definite = D, nd.disjunctions = disjunctions, nd.conditionals = conditionals.
Return (nd).
</table>
<figureCaption confidence="0.9971125">
Figure 8: CHECK-INDEF: Algorithm for checking compatibility of indefinite parts of a feature-description with its
definite component.
</figureCaption>
<bodyText confidence="0.999939857142857">
This restriction has been acceptable in our use of condi-
tional descriptions to model systemic grammars. It is unclear
whether a treatment of conditional descriptions without this
restriction will be needed in other applications. If this restric-
tion is lifted, then further work will be necessary to define the
behavior of negation over path equivalences, and to handle
such negations in a reasonably efficient manner.
</bodyText>
<sectionHeader confidence="0.999082" genericHeader="conclusions">
5 Summary
</sectionHeader>
<bodyText confidence="0.99995753125">
We have shown how the notational resources of FUG can be
extended to include descriptions of conditional information
about feature structures. Conditional descriptions have been
given a precise logical definition in terms of the feature de-
scription logic of Kasper and Rounds, and we have shown
how a unification method for feature descriptions can be ex-
tended to use conditional descriptions. We have implemented
this unification method and tested it in a parser for systemic
grammars, using several hundred conditional descriptions.
The definition of conditional descriptions and the unifica-
tion method should be generally applicable as an extension
to other unification-based grammar frameworks, as well as to
FUG and the modeling of systemic grammars. In fact, the
implementation described has been carried out by extending
PATR-II [Shie841, a general representational framework for
unification-based grammars.
While it is theoretically possible to represent the informa-
tion of conditional descriptions indirectly using notational
devices already present in Kay&apos;s FUG, there are practical
advantages to representing conditional descriptions directly.
The indirect encoding of conditional descriptions by disjunc-
tions and negations entails approximately doubling the size of
a description, adding many explicit nonexistence constraints
on features (NONE values), and slowing the unification pro-
cess. In our experiments, unification with conditional de-
scriptions requires approximately 50% of the time required
by unification with an indirect encoding of the same descrip-
tions. By adding conditional descriptions as a notational
resource to FUG, we have not changed the theoretical limits
of what FUG can do, but we have developed a representation
that is more perspicuous, less verbose, and computationally
more efficient.
</bodyText>
<sectionHeader confidence="0.998077" genericHeader="acknowledgments">
Acknowledgements
</sectionHeader>
<bodyText confidence="0.995439">
I would like to thank Bill Rounds for suggesting that it might
be worthwhile to clarify ideas about conditional descriptions
</bodyText>
<page confidence="0.929699">
239
</page>
<bodyText confidence="0.802073666666667">
that were only partially formulated in my dissertation at the [Per87I Fernando C.N. Pereira. Grammars and Logics of
University of Michigan. Helpful comments on earlier versions [Shie841 Partial Information. In Proceedings of the Inter-
of this paper were provided by Bill Mann, Ed Hovy and John national Conference on Logic Programming, Mel-
Bateman. bourne, Australia, May 1987.
This research was sponsored by the United States Air Stuart M. Shieber. The design of a computer lan-
Force Office of Scientific Research under contract F49620- guage for linguistic information. In Proceedings of
87-C-0005; the opinions expressed here are solely those of the Tenth International Conference on Computa-
the author. tional Linguistics: COLING 84, Stanford Univer-
sity, Stanford, California, July 2-7, 1984.
</bodyText>
<sectionHeader confidence="0.997991" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999819921052632">
[Hall76] Gunther R. Kress, editor. Halliday: System and
Function in Language. Oxford University Press,
London, England, 1976.
[Kas87a1 Robert T. Kasper. Systemic Grammar and Func-
tional Unification Grammar. In J. Benson and W.
Greaves, editors, Systemic Functional Approaches
to Discourse, Norwood, New Jersey: Ablex (in
press). Also available as USC/Information Sci-
enees Institute, Technical Report RS-87-179, May
1987.
[Kas86] Robert,T. Kasper and William C. Rounds. A Log-
ical Semantics for Feature Structures. In Proceed-
ings of the 24th Annual Meeting of the Association
for Computational Linguistics, Columbia Univer-
sity, New York, NY, June 10-13, 1986.
[Kas871:1] Robert T. Kasper. Feature Structures: A Logical
Theory with Application to Language Analysis. PhD
dissertation, University of Michigan, 1987.
[Kas87c) Robert T. Kasper. A Unification Method for Dis-
junctive Feature Descriptions. In Proceedings of the
25th Annual Meeting of the Association for Compu-
tational Linguistics, Stanford University, Stanford,
CA, July 6-9, 1987.
[Kay79] Martin Kay. Functional Grammar. In Proceedings
of the Fifth Annual Meeting of the Berkeley Linguis-
tics Society, Berkeley Linguistics Society, Berkeley,
California, February 17-19, 1979.
[Mann83] William C. Moan and Christian Matthiessen.
Nigel: A Systemic Grammar for Text Generation.
USC / Information Sciences Institute, RR-83-105.
Also appears in R. Benson and J. Greaves, editors,
Systemic Perspectives on Discourse: Selected Pa-
pers Papers from the Ninth International Systemics
Workshop, Ablex, London, England, 1985.
[Mosh871 M. Drew Moshier and William C. Rounds. A Logic
for Partially Specified Data Structures. In Proceed-
ings of the ACM Symposium on Principles of Pro-
gramming Languages, 1987.
</reference>
<page confidence="0.997025">
240
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.907063">
<title confidence="0.989071">Conditional Descriptions in Functional Unification Grammar</title>
<author confidence="0.999983">Robert T Kasper</author>
<affiliation confidence="0.999955">USC/Information Sciences Institute</affiliation>
<address confidence="0.9932505">4676 Admiralty Way, Suite 1001 Marina del Rey, CA 90292 U.S.A.</address>
<abstract confidence="0.995744333333333">A grammatical description often applies to a linguistic object only when that object has certain features. Such conditional descriptions can be indirectly modeled in Kay&apos;s Functional Unification Grammar (FUG) using functional descriptions that are embedded within disjunctive alternatives. An extension to FUG is proposed that allows for a direct representation of conditional descriptions. This extension has been used to model the input conditions on the systems of systemic grammar. Conditional descriptions are formally defined in terms of logical implication and negation. This formal definition enables the use of conditional descriptions as a general notational extension to any of the unification-based grammar representation systems currently used in computational linguistics.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<date>1976</date>
<booktitle>System and Function in Language.</booktitle>
<editor>[Hall76] Gunther R. Kress, editor. Halliday:</editor>
<publisher>Oxford University Press,</publisher>
<location>London, England,</location>
<marker>1976</marker>
<rawString>[Hall76] Gunther R. Kress, editor. Halliday: System and Function in Language. Oxford University Press, London, England, 1976.</rawString>
</citation>
<citation valid="true">
<title>Systemic Grammar and Functional Unification Grammar.</title>
<date>1987</date>
<booktitle>Systemic Functional Approaches to Discourse,</booktitle>
<tech>Technical Report RS-87-179,</tech>
<editor>In J. Benson and W. Greaves, editors,</editor>
<location>Norwood, New Jersey:</location>
<marker>1987</marker>
<rawString>[Kas87a1 Robert T. Kasper. Systemic Grammar and Functional Unification Grammar. In J. Benson and W. Greaves, editors, Systemic Functional Approaches to Discourse, Norwood, New Jersey: Ablex (in press). Also available as USC/Information Scienees Institute, Technical Report RS-87-179, May 1987.</rawString>
</citation>
<citation valid="true">
<authors>
<author>T Kasper Robert</author>
<author>William C Rounds</author>
</authors>
<title>A Logical Semantics for Feature Structures.</title>
<date>1986</date>
<booktitle>In Proceedings of the 24th Annual Meeting of the Association for Computational Linguistics,</booktitle>
<institution>Columbia University,</institution>
<location>New York, NY,</location>
<marker>Robert, Rounds, 1986</marker>
<rawString>[Kas86] Robert,T. Kasper and William C. Rounds. A Logical Semantics for Feature Structures. In Proceedings of the 24th Annual Meeting of the Association for Computational Linguistics, Columbia University, New York, NY, June 10-13, 1986.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Robert T Kasper</author>
</authors>
<title>Feature Structures: A Logical Theory with Application to Language Analysis.</title>
<date>1987</date>
<institution>University of Michigan,</institution>
<note>PhD dissertation,</note>
<marker>Kasper, 1987</marker>
<rawString>[Kas871:1] Robert T. Kasper. Feature Structures: A Logical Theory with Application to Language Analysis. PhD dissertation, University of Michigan, 1987.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Robert T Kasper</author>
</authors>
<title>A Unification Method for Disjunctive Feature Descriptions.</title>
<date>1987</date>
<booktitle>In Proceedings of the 25th Annual Meeting of the Association for Computational Linguistics,</booktitle>
<location>Stanford University, Stanford, CA,</location>
<marker>Kasper, 1987</marker>
<rawString>[Kas87c) Robert T. Kasper. A Unification Method for Disjunctive Feature Descriptions. In Proceedings of the 25th Annual Meeting of the Association for Computational Linguistics, Stanford University, Stanford, CA, July 6-9, 1987.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Martin Kay</author>
</authors>
<title>Functional Grammar.</title>
<date>1979</date>
<booktitle>In Proceedings of the Fifth Annual Meeting of the</booktitle>
<institution>Berkeley Linguistics Society, Berkeley Linguistics Society,</institution>
<location>Berkeley, California,</location>
<marker>Kay, 1979</marker>
<rawString>[Kay79] Martin Kay. Functional Grammar. In Proceedings of the Fifth Annual Meeting of the Berkeley Linguistics Society, Berkeley Linguistics Society, Berkeley, California, February 17-19, 1979.</rawString>
</citation>
<citation valid="true">
<authors>
<author>William C Moan</author>
<author>Christian Matthiessen</author>
</authors>
<title>Nigel: A Systemic Grammar for Text Generation.</title>
<date>1985</date>
<booktitle>USC / Information Sciences Institute,</booktitle>
<pages>83--105</pages>
<editor>R. Benson and J. Greaves, editors,</editor>
<location>Ablex, London, England,</location>
<note>Also appears in</note>
<marker>Moan, Matthiessen, 1985</marker>
<rawString>[Mann83] William C. Moan and Christian Matthiessen. Nigel: A Systemic Grammar for Text Generation. USC / Information Sciences Institute, RR-83-105. Also appears in R. Benson and J. Greaves, editors, Systemic Perspectives on Discourse: Selected Papers Papers from the Ninth International Systemics Workshop, Ablex, London, England, 1985.</rawString>
</citation>
<citation valid="true">
<title>A Logic for Partially Specified Data Structures.</title>
<date>1987</date>
<booktitle>In Proceedings of the ACM Symposium on Principles of Programming Languages,</booktitle>
<marker>1987</marker>
<rawString>[Mosh871 M. Drew Moshier and William C. Rounds. A Logic for Partially Specified Data Structures. In Proceedings of the ACM Symposium on Principles of Programming Languages, 1987.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>