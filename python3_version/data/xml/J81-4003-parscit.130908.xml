<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<title confidence="0.921926">
Extraposition Grammars
</title>
<author confidence="0.877243">
Fernando Pereira
</author>
<affiliation confidence="0.870865">
Department of Architecture
University of Edinburgh
</affiliation>
<bodyText confidence="0.73169975">
Edinburgh EH1 1JZ SCOTLAND
Extraposition grammars are an extension of definite clause grammars, and are similarly
defined in terms of logic clauses. The extended formalism makes it easy to describe left
extraposition of constituents, an important feature of natural language syntax.
</bodyText>
<sectionHeader confidence="0.994127" genericHeader="abstract">
1. Introduction
</sectionHeader>
<bodyText confidence="0.998159638888889">
This paper presents a grammar formalism for natu-
ral language analysis, called extraposition grammars
(XGs), based on the subset of predicate calculus
known as definite, or Horn, clauses. It is argued that
certain important linguistic phenomena, collectively
known in transformational grammar as left extra-
position, can be described better in XGs than in earlier
grammar formalisms based on definite clauses.
The XG formalism is an extension of the definite
clause grammar (DCG) [6] formalism, which is itself a
restriction of Colmerauer&apos;s formalism of metamorphosis
grammars (MGs) [2]. Thus XGs and MGs may be
seen as two alternative extensions of the same basic
formalism, DCGs.
The argument for XGs will start with a comparison
with DCGs. I should point out, however, that the
motivation for the development of XGs came from
studying large MGs for natural language [4,7].
The relationship between MGs and DCGs is analo-
gous to that between type-0 grammars and context-
free grammars. So, some of the linguistic phenomena
which are seen as rewriting one sequence of constitu-
ents into another might be described better in a MG
than in a DCG. However, it will be shown that re-
writings such as the one involved in left extraposition
cannot easily be described in either of the two formal-
isms.
Left extraposition has been used by grammarians to
describe the form of interrogative sentences and rela-
tive clauses, at least in languages such as English,
French, Spanish and Portuguese. The importance of
these constructions, even in simplified subsets of natu-
ral language, such as those used in database interfaces,
suggests that a grammar formalism should be able to
express them in a clear and concise manner. This is the
purpose of XGs.
</bodyText>
<sectionHeader confidence="0.912886" genericHeader="method">
2. Grammars in Logic
</sectionHeader>
<bodyText confidence="0.984616076923077">
This section summarises the concepts of definite
clause grammars (DCGs), and of the underlying sys-
tem of logic, definite clauses, needed for the rest of the
paper. A fuller discussion can be found elsewhere [6].
A definite clause has either the form
to be read as &amp;quot;P is true if Q1, ..., Qn are true&amp;quot;, or the
form
P.
to be read as &amp;quot;P is true&amp;quot;. P is the head of the clause,
are goals, forming the body of the clause.
The symbols P, Qi, Qn stand for literals. A literal
has a predicate symbol, and possibly some arguments
(in parentheses, separated by commas), e.g.
</bodyText>
<equation confidence="0.617489">
father(X,Y) false number(0)
</equation>
<bodyText confidence="0.9974434">
A literal is to be interpreted as denoting a relation
between its arguments; e.g. &amp;quot;father(X,Y)&amp;quot; denotes the
relation &apos;father&apos; between X and Y.
Arguments are terms, standing for partially speci-
fied objects. Terms may be
</bodyText>
<listItem confidence="0.979097333333333">
• variables, denoting unspecified objects
(variable names are capitalised):
X Case Agreement
• atomic symbols, denoting specific objects:
plural [ ] 3
• compound terms, denoting complex objects:
</listItem>
<equation confidence="0.82256">
s(NP,VP) succ(succ(0))
</equation>
<bodyText confidence="0.8017448">
A compound term has a functor and some arguments,
which are terms. Compound terms are best seen as
Copyright 1981 by the Association for Computational Linguistics. Permission to copy without fee all or part of this material is granted
provided that the copies are not made for direct commercial advantage and the Journal reference and this copyright notice are included on
the first page. To copy otherwise, or to republish, requires a fee and/or specific permission.
</bodyText>
<page confidence="0.409877">
0362-613X/81/040243-14$01.00
</page>
<note confidence="0.6580595">
American Journal of Computational Linguistics, Volume 7, Number 4, October-December 1981 243
Fernando Pereira Extraposition Grammars
</note>
<equation confidence="0.424829333333333">
trees, e.g.
/
NP VP
</equation>
<bodyText confidence="0.99904325">
A particular type of term, the list, has a simplified
notation. The binary functor . &apos; makes up non-
empty lists, and the atom `[ ]&apos; denotes the empty list.
In the special list notation,
</bodyText>
<equation confidence="0.656785">
[a,b] [X I V]
represent respectively the terms
.(a,. (b,[ ]) .(X,Y)
Putting these concepts together, the clause
grandfather(X,Z) father(X,Y), parent(Y,Z).
</equation>
<bodyText confidence="0.945255117647059">
may be read as &amp;quot;X is grandfather of Z if X is father of
Y and Y is a parent of Z&amp;quot;; the clause
father(john,mary).
may be read as &amp;quot;John is father of Mary&amp;quot; (note the use
of lower case for the constants in the clause).
A set of definite clauses forms a program. A pro-
gram defines the relations denoted by the predicates
appearing on the head of clauses. When using a defi-
nite clause interpreter, such as PROLOG [9], a goal
statement
?- P.
specifies that the relation instances that match P are
required.
Now, any context-free rule, such as
sentence --&gt; noun phrase, verb_phrase.
(I use `,&apos; for concatenation, and `.&apos; to terminate a rule)
may be translated into a definite clause
</bodyText>
<equation confidence="0.7639095">
sentence(SO,S) noun_phrase(SO,S1),
verb_phrase(S1,S).
</equation>
<bodyText confidence="0.872245785714286">
which says: &amp;quot;there is a sentence between points SO
and S in a string if there is a noun phrase between
points SO and Si, and a verb phrase between points Si
and S&amp;quot;. A context-free rule like
determiner --&gt; [the].
(where the square brackets mark a terminal) can be
translated into
determiner(SO,S) connects(SO,the,S).
which may be read as &amp;quot;there is a determiner between
points SO and S in a string if SO is joined to S by the
word `the&amp;quot;. The predicate &apos;connects&apos; is used to relate
terms denoting points in a string to the words which
join those points. Depending on the application, differ-
ent definitions of &apos;connects&apos; might be used. In particu-
lar, if a point in a string is represented by the list of
words after that point, &apos;connects&apos; has the very simple
definition
connects([WordIS1,Word,S).
which may be read as &amp;quot;a string point represented by a
list of words with first element Word and rest S is
connected by the word Word to the string point repre-
sented by list S.&amp;quot;
DCGs are the natural extension of context-free
grammars (CFGs) obtained through the translation
into definite clauses outlined above. A DCG non-
terminal may have arguments, of the same form as
those of a predicate, and a terminal may be any term.
For instance, the rule
</bodyText>
<equation confidence="0.64833475">
sentence(s(NP,VP)) --&gt; noun_phrase(NP,N),
verb_phrase(VP,N).
states: &amp;quot;A sentence with structure
NP VP
</equation>
<bodyText confidence="0.9982555">
is made of a noun phrase with structure NP and num-
ber N (which can be either &apos;singular&apos; or &apos;plural&apos;), fol-
lowed by a verb phrase with structure VP agreeing
with the number N&amp;quot;. A DCG rule is just &amp;quot;syntactic
sugar&amp;quot; for a definite clause. The clause for the exam-
ple above is
</bodyText>
<equation confidence="0.971565666666667">
sentence(s(NP,VP),SO,S) :-
noun_phrase(NP,N,SO,S1),
verb_phrase(VP,N,S1,S).
</equation>
<bodyText confidence="0.999980625">
In general, a DCG non-terminal with n arguments is
translated into a predicate of n+2 arguments, the last
two of which are the string points, as in the translation
of context-free rules into definite clauses.
The main idea of DCGs is then that grammar sym-
bols can be general logic terms rather than just atomic
symbols. This makes DCGs a general-purpose gram-
mar formalism, capable of describing any type-0 lan-
guage. The first grammar formalism with logic terms
as grammar symbols was Colmerauer&apos;s metamorphosis
grammars [2]. Where a DCG is a CFG with logic
terms for grammar symbols, a MG is a somewhat re-
stricted type-0 grammar with logic terms for grammar
symbols. However, the very simple translation of
DCGs into definite clauses presented above does not
carry over directly to MGs.
</bodyText>
<subsectionHeader confidence="0.497962">
3. Left Extraposition
</subsectionHeader>
<bodyText confidence="0.995225083333333">
Roughly speaking, left extraposition occurs in a
natural language sentence when a subconstituent of
some constituent is missing, and some other constitu-
ent, to the left of the incomplete one, represents the
missing constituent in some way. It is useful to think
that an empty constituent, the trace, occupies the
&amp;quot;hole&amp;quot; left by the missing constituent, and that the
constituent to the left, which represents the missing
part, is a marker, indicating that a constituent to its
right contains a trace [1]. One can then say that the
constituent in whose place the trace stands has been
extraposed to the left, and, in its new position, is rep-
</bodyText>
<page confidence="0.858089">
244 American Journal of Computational Linguistics, Volume 7, Number 4, October-December 1981
</page>
<note confidence="0.302505">
Fernando Pereira Extraposition Grammars
</note>
<equation confidence="0.898943181818182">
sentence --&gt; noun_phrase, verb_phrase.
noun_phrase --&gt; proper_noun.
noun_phrase --&gt; determiner, noun, relative.
noun_phrase --&gt; determiner, noun, prep_phrase.
noun_phrase --&gt; trace. (1)
trace --&gt; [ ].
verb_phrase --&gt; verb, noun_phrase.
verb_phrase --&gt; verb.
relative --&gt; [ ].
relative --&gt; rel_pronoun, sentence.
prep_phrase --&gt; preposition, noun_phrase.
</equation>
<figureCaption confidence="0.930076">
Figure 4.1. CFG for relative clauses.
</figureCaption>
<bodyText confidence="0.999196">
resented by the marker. For instance, relative clauses
are formed by a marker, which in the simpler cases is
just a relative pronoun, followed by a sentence where
some noun phrase has been replaced by a trace. This
is represented in the following annotated surface struc-
ture:
</bodyText>
<subsectionHeader confidence="0.768592">
The man thati [John met ti] is a grammarian.
</subsectionHeader>
<bodyText confidence="0.999735076923077">
In this example, t stands for the trace, &apos;that&apos; is the
surface form of the marker, and the connection be-
tween the two is indicated by the common index i.
The concept of left extraposition plays an essential
role, directly or indirectly, in many formal descriptions
of relative and interrogative clauses. Related to this
concept, there are several &amp;quot;global constraints&amp;quot;, the
&amp;quot;island constraints&amp;quot;, that have been introduced to
restrict the situations in which left extraposition can
be applied. For instance, the Ross complex-NP con-
straint [8], implies that any relative pronoun occurring
outside a given noun phrase cannot be bound to a
trace occurring inside a relative clause which is a sub-
constituent of the noun phrase. This means that it is
not possible to have a configuration like
Xi... [np [rel X2 [s t2 tl 1] ...
Note that here I use the concept of left extraposi-
tion in a loose sense, without relating it to transforma-
tions as in transformational grammar. In XGs, and also
in other formalisms for describing languages (for in-
stance the context-free rule schemas of Gazdar [5]),
the notion of transformation is not used, but a concep-
tual operation of some kind is required for instance to
relate a relative pronoun to a &amp;quot;hole&amp;quot; in the structural
representation of the constituent following the pro-
noun.
</bodyText>
<subsectionHeader confidence="0.778149">
4. Limitations of Other Formalisms
</subsectionHeader>
<bodyText confidence="0.999092">
To describe a fragment of language where left ex-
traposition occurs, one might start with a CFG which
gives a rough approximation of the fragment. The
grammar may then be refined by adding arguments to
</bodyText>
<equation confidence="0.995812">
full_sentence --&gt; sentence(ni1).
sentence(Hole0) --&gt;
noun_phrase(Hole0,Hole1), verb_phrase(Hole1).
noun_phrase(Hole,Hole) --&gt; proper_noun.
noun_phrase(Hole,Hole) --&gt;
determiner, noun, relative.
noun_phrase(Hole0,Hole) --&gt;
determiner, noun, prep_phrase(Hole0,Hole).
noun_phrase(trace,nil) --&gt; trace. (2)
trace --&gt; [ ].
verb_phrase(Hole) --&gt;
verb, noun_phrase(Hole,ni1).
verb_phrase(nil) --&gt; verb.
relative --&gt; [ ].
relative --&gt;
rel_pronoun, sentence(trace).
prep_phrase(Hole0,Hole) --&gt;
preposition, noun_phrase(Hole0,Hole).
</equation>
<figureCaption confidence="0.912133">
Figure 4.2. DCG for relative clauses.
</figureCaption>
<bodyText confidence="0.999072121212121">
non-terminals, to carry extraposed constituents across
phrases. This method is analogous to the introduction
of &amp;quot;derived&amp;quot; rules by Gazdar [5]. Take for example
the CFG in Figure 4.1. In this grammar it is possible
to use rule (1) to expand a noun phrase into a trace,
even outside a relative clause. To prevent this, I will
add arguments to all non-terminals from Which a noun
phrase might be extraposed. The modified grammar,
now a DCG, is given in Figure 4.2. A variable
&apos;Hole...&apos; will have the value &apos;trace&apos; if an extraposed
noun phrase occurs somewhere to the right, &apos;nil&apos; other-
wise. The parse tree of Figure 4.3 shows the variable
values when the grammar of Figure 4.2 is used to ana-
lyse the noun phrase &amp;quot;the man that John met&amp;quot;.
Intuitively, we either can see noun phrases moving
to the left, leaving traces behind, or traces appearing
from markers and moving to the right. In a phrase
&amp;quot;noun phrase(Hole 1 ,Hole2)&amp;quot;, Holel will have the
value &apos;trace&apos; when a trace occurs somewhere to the
right of the left end of the phrase. In that case, Hole2
will be &apos;nil&apos; if the noun phrase contains the trace,
&apos;trace&apos; if the trace appears to the right of the right end
of this noun phrase. Thus, rule (2) in Figure 4.2 speci-
fies that a noun phrase expands into a trace if a trace
appears from the left, and as this trace is now placed,
it will not be found further to the right.
The non-terminal &apos;relative&apos; has no arguments, be-
cause the complex-NP constraint prevents noun phras-
es from moving out of a relative clause. However, that
constraint does not apply to prepositional phrases, so
&apos;prep_phrase&apos; has arguments. The non-terminal
&apos;sentence&apos; (and consequently &apos;verb_phrase&apos;) has a
single argument, because in a relative clause the trace
</bodyText>
<figure confidence="0.978942083333333">
American Journal of Computational Linguistics, Volume 7, Number 4, October-December 1981 245
Fernando Pereira Extraposition Grammars
noun_phrase(nil,ntl)
determiner noun relative
rel_pronoun sentence (trace)
noun_phrase(trace,trace) verb_phrase(trace)
proper_noun verb noun_phrase(trace,nil)
the
man that
John met
trace
E]
</figure>
<figureCaption confidence="0.999654">
Figure 4.3. DCG parse tree.
</figureCaption>
<bodyText confidence="0.998775285714286">
must occur in the sentence immediately to the right of
the relative pronoun.
It is obvious that in a more extensive grammar,
many non-terminals would need extraposition argu-
ments, and the increased complication would make the
grammar larger and less readable.
Colmerauer&apos;s MG formalism allows an alternative
way to express left extraposition. It involves the use
of rules whose left-hand side is a non-terminal fol-
lowed by a string of &amp;quot;dummy&amp;quot; terminal symbols which
do not occur in the input vocabulary. An example of
such a rule is:
rel_marker, [t] --&gt; rel pronoun.
Its meaning is that &apos;rel pronoun&apos; can be analysed as a
&apos;rel marker&apos; provided that the terminal &apos;t&apos; is added to
the front of the input remaining after the rule applica-
tion. Subsequent rule applications will have to cope
explicitly with such dummy terminals. This method
has been used in several published grammars [2, 4, 7],
but in a large grammar it has the same (if not worse)
problems of size and clarity as the previous method.
It also suffers from a theoretical problem: in general,
the language defined by such a grammar will contain
extra sentences involving the dummy terminals. For
parsing, however, no problem arises, because the input
sentences are not supposed to contain dummy termi-
nals. These inadequacies of MGs were the main moti-
vation for the development of XGs.
</bodyText>
<sectionHeader confidence="0.979275" genericHeader="method">
5. Informal Description of XGs
</sectionHeader>
<bodyText confidence="0.951789714285714">
To describe left extraposition, we need to relate
non-contiguous parts of a sentence. But neither DCGs
nor MGs have means of representing such a relation-
ship by specific grammar rules. Rather; the relation-
ship can only be described implicitly, by adding extra
information to many unrelated rules in the grammar.
That is, one cannot look at a grammar and find a set
of rules specific to the constructions which involve left
extraposition.
With extraposition grammars, I attempt to provide
a formalism in which such rules can be written.
In this informal introduction to the XG formalism,
I will avoid the extra complications of non-terminal
arguments. So, in the discussion that follows, we may
look at XGs as an extension of CFGs.
Sometimes it is easier to look at grammar rules in
the left-to-right, or synthesis, direction. I will say then
that a rule is being used to expand or rewrite a string.
In other cases, it is easier to look at a rule in the right-
to-left, or analysis, direction. I will say then that the
rule is being used to analyse a string.
Let us first look at the following XG fragment:
sentence --&gt; noun_phrase, verb_phrase.
noun_phrase --&gt; determiner, noun, relative.
noun_phrase --&gt; trace.
relative --&gt; [ 1.
relative --&gt; rel marker, sentence.
rel marker ... trace --&gt; rel pronoun.
</bodyText>
<page confidence="0.322784">
246 American Journal of Computational Linguistics, Volume 7, Number 4, October-December 1981
</page>
<figure confidence="0.333126666666667">
Fernando Pereira Extraposition Grammars
the mouse rel_marker the cat chased trace squeaks
the mouse rel_pronoun the cat chased squeaks
</figure>
<figureCaption confidence="0.935588">
Figure 5.1. Applying an XG rule.
</figureCaption>
<bodyText confidence="0.999994176470588">
All rules but the last are context-free. The last rule
expresses the extraposition in simple relative clauses.
It states that a relative pronoun is to be analysed as a
marker, followed by some unknown constituents
(denoted by `...&apos;), followed by a trace. This is shown
in Figure 5.1. As in the DCG example of the previous
section, the extraposed noun phrase is expanded into a
trace. However, instead of the trace being rewritten
into the empty string, the trace is used as part of the
analysis of `rel marker&apos;.
The difference between XG rules and DCG rules is
then that the left-hand side of an XG rule may contain
several symbols. Where a DCG rule is seen as ex-
pressing the expansion of a single non-terminal into a
string, an XG rule is seen as expanding together several
non-contiguous symbols into a string. More precisely,
an XG rule has the general form
</bodyText>
<equation confidence="0.83656">
s s2 etc. sk_ sk --&gt; r. (3)
</equation>
<bodyText confidence="0.980288578947368">
Here each segment s, (separated from other segments
by `...&apos;) is a sequence of terminals and non-terminals
(written in DCG notation, with `,&apos; for concatenation).
The first symbol in s 1 , the leading symbol, is restricted
to be a non-terminal. The right-hand side r is as in a
DCG rule.
Leaving aside the constraints discussed in the next
section, the meaning of a rule like (3) is that any se-
quence of symbols of the form
sixis 2x 2 etc. sk_ ixk_isk
with arbitrary xi&apos;s, can be rewritten into rx ix 2...xk_ 1.
Thinking procedurally, one can say that a non-
terminal may be expanded by matching it to the lead-
ing symbol on the left-hand side of a rule, and the rest
of the left-hand side is &amp;quot;put aside&amp;quot; to wait for the
derivation of symbols which match each of its symbols
in sequence. This sequence of symbols can be inter-
rupted by arbitrary strings, paired to the occurrences
of `...&apos; on the left-hand side of the rule.
</bodyText>
<sectionHeader confidence="0.978834" genericHeader="method">
6. XG Derivations
</sectionHeader>
<bodyText confidence="0.977997285714286">
When several XG rules are involved, the derivation
of a surface string becomes more complicated than in
the single rule example of the previous section, be-
cause rule applications interact in the way now to be
described.
To represent the intermediate stages in an XG de-
rivation, I will use bracketed strings, made up of
</bodyText>
<listItem confidence="0.999773">
• terminal symbols
• non-terminal symbols
• the open bracket &lt;
• the close bracket &gt;
</listItem>
<bodyText confidence="0.951330121212121">
A bracketed string is balanced if the brackets in it
balance in the usual way.
Now, an XG rule
etc . ...un --&gt; V.
can be applied to bracketed string s if
s = x0u1x1u2 etc. xn_ unxn
and each of the gaps x1, ..., xn_1 is balanced. The
substring of s between xo and xn is the span of the
rule application. The application rewrites s into new
string t, replacing u1 by v followed by n-1 open brack-
ets, and replacing each of u2, un by a close brack-
et; in short, s is replaced by
xov&lt;&lt; ... &lt;x1 &gt;x&gt; ...
The relation between the original string s and the
derived string t is abbreviated as s =&gt; t. In the new
string t, the substring between xo and xn is the result
of the application. In particular, the application of a
rule with a single segment in its left-hand side is no
different from what it would be in a type-0 grammar
Taking again the rule
rel marker ... trace --&gt; rel pronoun.
its application to
rel marker John likes trace
produces
rel _pronoun &lt; John likes &gt;
After this rule application, it is not possible to apply
any rule with a segment matching inside a bracketed
portion and another segment matching outside it. The
use of the above rule has divided the string into two
isolated portions, each of which must be independently
expanded.
Given an XG with initial symbol s, a sentence t is
in the language defined by the XG if there is a se-
</bodyText>
<figure confidence="0.9834365">
American Journal of Computational Linguistics, Volume 7, Number 4, October-December 1981 247
Fernando Pereira Extraposition Grammars
a a
Conventions:
o = rule application
(node)
x = non-terminal
x = terminal
[] = empty string
as CS
</figure>
<figureCaption confidence="0.999954">
Figure 7.1. Derivation graph for &amp;quot;aabbcc&amp;quot;.
</figureCaption>
<bodyText confidence="0.999817733333333">
quence of rule applications that transforms s into a
string from which t can be obtained by deleting all
brackets.
I shall refer to the restrictions on XG rule applica-
tion which I have just described as the bracketing
constraint. The effect of the bracketing constraint is
independent of the order of application of rules, be-
cause if two rules are used in a derivation, the brack-
ets introduced by each of them must be compatible in
the way described above. As brackets are added and
never deleted, it is clear that the order of application
is irrelevant. For similar reasons, any two applications
in a derivation where the rules involved have more
than one segment in their left-hand sides, one and only
one of the two following situations arises:
</bodyText>
<listItem confidence="0.9843514">
• the span of neither application intersects the result
of the other;
• the result of one of the applications is contained
entirely in a gap of the other application — the ap-
plications are nested.
</listItem>
<bodyText confidence="0.999748375">
If one follows to the letter the definitions in this
section, then checking, in a parsing procedure, whether
an XG rule may be applied, would require a scan of
the whole intermediate string. However, we will see in
Section 10 that this check may be done &amp;quot;on the fly&amp;quot;
as brackets are introduced, with a cost independent of
the length of the current intermediate string in the
derivation.
</bodyText>
<sectionHeader confidence="0.626812" genericHeader="method">
7. Derivation Graphs
</sectionHeader>
<bodyText confidence="0.9995735">
In the same way as parse trees are used to visualise
context-free derivations, I use derivation graphs to
represent XG derivations.
In a derivation graph, as in a parse tree, each node
corresponds to a rule application or to a terminal sym-
bol in the derived sentence, and the edges leaving a
node correspond to the symbols in the right-hand side
of that node&apos;s rule. In a derivation graph, however, a
node can have more than one incoming edge — in fact,
one such edge for each of the symbols on the left-
</bodyText>
<page confidence="0.600807">
248 American Journal of Computational Linguistics, Volume 7, Number 4, October-December 1981
</page>
<note confidence="0.602974">
Fernando Pereira Extraposition Grammars
</note>
<bodyText confidence="0.999504">
hand side of the rule corresponding to that node. Of
these edges, only the one corresponding to the leading
symbol is used to define the left-to-right order of the
symbols in the sentence whose derivation is represent-
ed by the graph. If one deletes from a derivation graph
all except the first of the incoming edges to every
node, the result is a tree analogous to a parse tree.
For example, Figure 7.1 shows the derivation graph
for the string &amp;quot;aabbcc&amp;quot; according to the XG:
</bodyText>
<equation confidence="0.709597714285714">
S --&gt; as, bs, cs.
as --&gt; E I.
as ... xb --&gt; [a], as.
bs --&gt; ].
bs xc --&gt; xb, [b], bs.
cs --&gt; J.
cs --&gt; xc, [c], CS.
</equation>
<bodyText confidence="0.9624599">
This XG defines the language formed by the set of all
strings
anbnen for n&gt;0.
The example shows, incidentally, that XGs, even with-
out arguments, are strictly more powerful than CFGs,
since the language described is not context-free.
The topology of derivation graphs reflects clearly
the bracketing constraint. Assume the following two
conventions for the drawing of a derivation graph,
which are followed in all the graphs shown here:
</bodyText>
<listItem confidence="0.594801571428571">
• the edges entering a node are ordered clockwise
following the sequence of the corresponding sym-
bols in the left-hand side of the rule for that node;
• the edges issuing from a node are ordered counter-
clockwise following the sequence of the corre-
sponding symbols in the right-hand side of the rule
for the node.
</listItem>
<bodyText confidence="0.9901934375">
Then the derivation graph obeys the bracketing const-
raint if and only if it can be drawn, following the con-
ventions, without any edges crossing.1 The example of
Figure 7.2 shows this clearly. In this figure, the closed
path formed by edges 1, 2, 3, and 4 has the same ef-
fect as a matching pair of brackets in a bracketed
string.
It is also worth noting that nested rule applications
appear in a derivation graph as a configuration like the
one depicted in Figure 7.3.
8. XGs and Left Extraposition
We saw in Figure 4.2 a DCG for (some) relative
clauses. The XG of Figure 8.1 describes essentially
the same language fragment, showing how easy it is to
describe left extraposition in an XG. In that grammar,
the sentence
</bodyText>
<footnote confidence="0.858766">
1 In some of the examples of this article, edges cross to make
the graphs more readable, but such crossings could be trivially
avoided.
</footnote>
<figure confidence="0.993412833333333">
5 --&gt; a, b, c, d.
a c --&gt; [x].
b d --&gt; Ey].
X
s =&gt; a bcd =&gt; x &lt; b &gt; d =&gt; ? (blocks)
s =&gt; a bc d =&gt; a y &lt; c &gt; =&gt; ?
</figure>
<figureCaption confidence="0.9998895">
Figure 7.2. Relating derivations to derivation graphs.
Figure 7.3. Nested rule applications.
</figureCaption>
<bodyText confidence="0.96742425">
The mouse that the cat chased squeaks.
has the derivation graph shown in Figure 8.2. The left
extraposition implicit in the structure of the sentence
is represented in the derivation graph by the applica-
</bodyText>
<figure confidence="0.986863142857143">
American Journal of Computational Linguistics, Volume 7, Number 4, October-December 1981 249
Fernando Pereira Extraposition Grammars
rel
vp
verb
det noun
det
np
rel
relp
vp
det noun rel
vp
verb
np
(1)
fl
re Ip
the mouse that the cat
chased
squeaks
</figure>
<figureCaption confidence="0.993982">
Figure 8.2. Example of derivation graph for the XG in Figure 8.1.
</figureCaption>
<figure confidence="0.872853157894737">
determiner
noun_phrase
rel_marker
relative
rel_pronoun
sentence
trace
verb_phrase
sentence --&gt; noun_phrase, verb_phrase.
noun_phrase --&gt; proper_noun.
noun_phrase --&gt; determiner, noun, relative.
noun_phrase --&gt; determiner, noun, prep_phrase.
noun_phrase --&gt; trace.
verb_phrase --&gt; verb, noun_phrase.
verb_phrase --&gt; verb.
relative --&gt; [
relative --&gt; rel marker, sentence. (4)
rel marker ... trace --&gt; rel pronoun.
prep_phrase --&gt; preposition, noun_phrase.
</figure>
<figureCaption confidence="0.989654">
Figure 8.1. XG for relative clauses.
</figureCaption>
<bodyText confidence="0.999911866666667">
tion of the rule for &apos;rel marker&apos;, at the node marked
(*) in the figure. One can say that the left extraposi-
tion has been &amp;quot;reversed&amp;quot; in the derivation by the use
of this rule, which may be looked at as repositioning
&apos;trace&apos; to the right, thus &amp;quot;reversing&amp;quot; the extraposition
of the original sentence.
In the rest of this paper, I often refer to a constitu-
ent being repositioned into a bracketed string (or into a
fragment of derivation graph), to mean that a rule
having that constituent as a non-leading symbol in the
left-hand side has been applied, and the symbol
matches some symbol in the string (or corresponds to
some edge in the fragment). For example, in Figure
8.2 the trace T is repositioned into the subgraph with
root
</bodyText>
<subsectionHeader confidence="0.655569">
9. Using the Bracketing Constraint
</subsectionHeader>
<bodyText confidence="0.9985269">
In the example of Figure 8.2, there is only one
application of a non-DCG rule, at the place marked
(*). However, we have seen that when a derivation
contains several applications of such rules, the applica-
tions must obey the bracketing constraint. The use of
the constraint in a grammar is better explained with an
example. From the sentences
The mouse squeaks.
The cat likes fish.
The cat chased the mouse.
</bodyText>
<page confidence="0.903679">
250 American Journal of Computational Linguistics, Volume 7, Number 4, October-December 1981
</page>
<figure confidence="0.99755375">
Extraposition Grammars
Fernando Pereira
det noun
ret +
np ++
&gt;16P
det noun rel verb np
det noun
rep
rnpa2
(1) verb np
**
relp
the mouse that the cat that
chased likes fish squeaks
[]
vp
verb
ref
f]
</figure>
<figureCaption confidence="0.999986">
Figure 9.1. Violation of the complex-NP constraint.
</figureCaption>
<bodyText confidence="0.976121260869565">
the grammar of Figure 8.1 can derive the following
string, which violates the complex-NP constraint:
* The mouse that the cat that chased likes fish squeaks.
The derivation of this ungrammatical string can be
better understood if we compare it with a sentence
outside the fragment:
The mouse, that the cat which chased it likes fish,
squeaks.
where the pronoun &apos;it&apos; takes the place of the incorrect
trace.
The derivation graph for that un-English string is
shown in Figure 9.1. In the graph, (*) and (**) mark
two nested applications of the rule for `rel marker&apos;.
The string is un-English because the higher &apos;relative&apos;
(marked (+) in the graph) binds a trace occurring
inside a sentence which is part of the subordinated
&apos;noun phrase&apos; (+ +).
Now, using the bracketing constraint one can neat-
ly express the complex-NP constraint. It is only neces-
sary to change the second rule for &apos;relative&apos; in Figure
8.1 to
relative --&gt; open, rel marker, sentence, close. (5)
and add the rule
</bodyText>
<equation confidence="0.469359">
open ... close --&gt; Ii 1. (6)
</equation>
<bodyText confidence="0.991485533333333">
With this modified grammar, it is no longer possible to
violate the complex-NP constraint, because no constit-
uent can be repositioned from outside into the gap
created by the application of rule (6) to the result of
applying the rule for relatives (5).
The non-terminals &apos;open&apos; and &apos;close&apos; bracket a sub-
derivation
... open x close ... =&gt; &lt; x &gt;
preventing any constituent from being repositioned
from outside that subderivation into it. Figure 9.2
shows the use of rule (6) in the derivation of the sen-
tence
The mouse that the cat that likes fish chased squeaks.
This is based on the same three simple sentences as
the ungrammatical string of Figure 9.1, which the
</bodyText>
<figure confidence="0.992567285714285">
American Journal of Computational Linguistics, Volume 7, Number 4, October-December 1981 251
Fernando Pereira Extraposition Grammars
S
e
np
det noun rel
1
verb
S
S
open r
close
det noun rel
-------e‘.\
open r s
verb
close
det noun rel
H1
f
[3
re (p
Li
the mouse that
the cat that likes
chased squeaks
relp
fish
</figure>
<figureCaption confidence="0.999976">
Figure 9.2. Implementation of the complex-NP constraint.
</figureCaption>
<bodyText confidence="0.998763">
reader can now try to derive in the modified grammar,
to see how the bracketing constraint prevents the de-
rivation.
</bodyText>
<subsectionHeader confidence="0.696311">
10. XGs as Logic Programs
</subsectionHeader>
<bodyText confidence="0.996098866666667">
In the previous sections, I avoided the complication
of non-terminal arguments. Although it would be pos-
sible to describe fully the operation of XGs in terms of
derivations on bracketed strings, it is much simpler to
complete the explanation of XGs using the translation
of XG rules into definite clauses. In fact, a rigorous
definition of XGs independently of definite clauses
would require a formal apparatus very similar to the
one needed to formalise definite clause programs in
the first place, and so it would fall outside the scope
of the present paper. The interested reader will find a
full discussion of those issues in two articles by Col-
merauer [2,3].
Like a DCG, a general XG is no more than a con-
venient notation for a set of definite clauses. An XG
non-terminal of arity n corresponds to an n+4 place
predicate (with the same name). Of the extra four
arguments, two are used to represent string positions
as in DCGs, and the other two are used to represent
positions in an extraposition list, which carries symbols
to be repositioned.
Each element of the extraposition list represents a
symbol being repositioned as a 4-tuple
x (context, type, symbol, xlist)
where context is either &apos;gap&apos;, if the symbol was preced-
ed by `...&apos; in the rule where it originated, or `nogap&apos;, if
the symbol was preceded by `,&apos;; type may be &apos;terminal&apos;
or `nonterminal&apos;, with the obvious meaning; symbol is
the symbol proper; x/ist is the remainder of the extra-
position list (an empty list being represented by&apos;[ ]&apos;).
</bodyText>
<note confidence="0.653031">
252 American Journal of Computational Linguistics, Volume 7, Number 4, October-December 1981
Fernando Pereira Extraposition Grammars
</note>
<bodyText confidence="0.9993818">
An XG rule is translated into a clause for the pred-
icate corresponding to the leading symbol of the rule.
In the case where the XG rule has just a single symbol
on the left-hand side, the translation is very similar to
that of DCG rules. For example, the rule
</bodyText>
<equation confidence="0.9633956">
sentence --&gt; noun_phrase, verb_phrase.
translates into
sentence(SO,S,X0,X) :-
noun_phrase(SO,S1,X0,X1),
verb_phrase(S1,S,X1,X).
</equation>
<bodyText confidence="0.99990425">
A terminal t in the right-hand side of a rule translates
into a call to the predicate &apos;terminal&apos;, defined below,
whose role is analogous to that of &apos;connects&apos; in DCGs.
For example, the rule
</bodyText>
<equation confidence="0.85446375">
rel pronoun --&gt; [that] .
translates into
rel_pronoun(SO,S,X0,X) :-
terminal(that,SO,S,X0,X).
</equation>
<bodyText confidence="0.927807833333333">
The translation of a rule with more than one symbol in
the left-hand side is a bit more complicated. Informal-
ly, each symbol after the first is made into a 4-tuple as
described above, and fronted to the extraposition list.
Thus, for example, the rule
rel marker ... trace --&gt; rel pronoun.
</bodyText>
<equation confidence="0.939095333333333">
translates into
rel_marker(SO,S,X0,x(gap,nonterminal,trace,X)) :-
rel_pronoun(SO,S,X0,X).
</equation>
<bodyText confidence="0.999928">
Furthermore, for each distinct non-leading non-
terminal nt (with arity n) in the left-hand side of a rule
of the XG, the translation includes the clause
</bodyText>
<equation confidence="0.8664635">
nt(V1,...,Vn,S,S,X0,X) :-
virtual(nt(V1,...,Vn),X0,X).
</equation>
<bodyText confidence="0.994252909090909">
where `virtual(C,X0,X)&apos;, defined later, can be read as
&amp;quot;C is the constituent between XO and X in the extra-
position list&amp;quot;, and the variables Vi transfer the argu-
ments of the symbol in the extraposition list to the
predicate which translates that symbol.
For example, the rule
marker(Var), [the] ... [of.whom], trace(Var) --&gt;
[whose].
which can be used in a more complex grammar of
relative clauses to transform &amp;quot;whose X&amp;quot; into &amp;quot;the X of
whom&amp;quot;, corresponds to the clauses:
</bodyText>
<equation confidence="0.7277945">
marker(Var,SO,S,X0,
x(nogap,terminal,the,
x(gap,terminal,of,
x(nogap,terminal,whom,
x(nogap,nonterminal,trace(Var),
X ) ) ) ) )
terminal (whose ,S0 ,S ,X0, X )
trace(Var,S,S,X0,X) virtual(trace(Var),XO,X).
</equation>
<bodyText confidence="0.9913325">
Finally, the two auxiliary predicates &apos;virtual&apos; and
&apos;terminal&apos; are defined as follows:-
</bodyText>
<construct confidence="0.5640715">
virtual(NT, x(C,nonterminal,NT,X), X).
terminal(T, SO, S, X, X) :-
gap(X), connects(SO, 1, S).
terminal (1, S, S, x(C,terminal,T,X), X).
</construct>
<bodyText confidence="0.698073318181818">
gap(x(gap,T,S,X)).
gap([ ]).
where &apos;connects&apos; is as for DCGs.
These definitions need some comment. The first
clause for &apos;terminal&apos; says that, provided the current
extraposition list allows a gap to appear in the deriva-
tion, terminal symbol T may be taken from the posi-
tion SO in the source string, where T connects SO to
some new position S. The second clause for &apos;terminal&apos;
says that if the next symbol in the current extraposi-
tion list is a terminal T, then this symbol can be taken
as if it occurred at S in the source string. The clause
for &apos;virtual&apos; allows a non-terminal to be &amp;quot;read off
from&amp;quot; the extraposition list.
* relative(6,9,X,X)
* open(6,6,x(gap,nt,trace,x(gap,nt,close,[])),
x(gap,nt,close,x(gap,nt,trace,
x(gap,nt,close,[]))))
* rel_marker(6,7,x(gap,nt,close,x(gap,nt,trace,
x(gap,nt,close,[]))),
x(gap,nt,trace,x(gap,nt,close,
x(gap,nt,trace,x(gap,nt,close,[])))))
</bodyText>
<listItem confidence="0.93736332">
• rel_pronoun(6,7,X,X)
[that]
* sentence(7,9,x(gap,nt,trace,x(gap,nt,close,
x(gap,nt,trace,x(gap,nt,close,[])))),
x(gap,nt,close,x(gap,nt,trace,
x(gap,nt,close,[]))))
• noun_phrase(7,7,x(gap,nt,trace,x(gap,nt,close,
x(gap,nt,trace,x(gap,nt,close,[])))),
x(gap,nt,close,x(gap,nt,trace,
x(gap,nt,close,[]))))
• trace(7,7,x(gap,nt,trace,x(gap,nt,close,
x(gap,nt,trace,x(gap,nt,close,[])))),
x(gap,nt,close,x(gap,nt,trace,
x(gap,nt,close,[]))))
• verb_phrase(7,9,X,X)
• verb(7,8,X,X)
[likes]
• noun_phrase(8,9,X,X)
• determiner(8,8,X,X)
• noun(8,9,X,X)
[fish]
• relative(9,9,X,X)
* close(9,9,x(gap,nt,close,x(gap,nt,trace,
x(gap,nt,close,[]))),
x(gap,nt,trace,x(gap,nt,close,[])))
</listItem>
<figureCaption confidence="0.9552442">
Figure 10.1. Derivation of &amp;quot;that likes fish&amp;quot;.
Figure 10.1 shows a fragment of the analysis in
Figure 9.2, but now in terms of the translation of XG
rules into definite clauses. Points on the sentence are
labelled as follows:
</figureCaption>
<figure confidence="0.51846925">
American Journal of Computational Linguistics, Volume 7, Number 4, October-December 1981 253
Fernando Pereira Extraposition Grammars
the mouse that the cat that likes fish chased squeaks
1 2 3 4 5 6 7 8 9 10 11
</figure>
<bodyText confidence="0.9998188">
The nodes of the analysis fragment, for the relative
clause &amp;quot;that likes fish&amp;quot;, are represented by the corre-
sponding goals, indented in proportion to their dis-
tance from the root of the graph. The following con-
ventions are used to simplify the figure:
</bodyText>
<listItem confidence="0.962590909090909">
• The leaves (terminals) of the graph are listed
directly;
• the vrlues of the extraposition arguments are
explictly represented only for those goals that
add or delete something to the extraposition list;
for the other goals, the two identical values are
represented by the variable &apos;X&apos;;
• the goals for &apos;terminal&apos; and &apos;virtual&apos; are left out
as they can be easily reconstructed from the
other goals and the definitions above;
• `nonterminal&apos; is abbreviated as &apos;ne.
</listItem>
<bodyText confidence="0.999972470588235">
The definite clause program corresponding to the
grammar for this example is listed in Appendix II.
The example shows clearly how the bracketing
constraint works. Symbols are placed in the extraposi-
tion list by rules with more than one symbol in the
left-hand side, and removed by calls to &apos;virtual&apos;, on a
first-in-last-out basis; that is, the extraposition list is a
stack. But this property of the extraposition list is
exactly what is needed to balance &amp;quot;on the fly&amp;quot; the
auxiliary brackets in the intermediate steps of a deri-
vation.
Being no more than a logic program, an XG can be
used for analysis and for synthesis in the same way as
a DCG. For instance, to determine whether a string s
with initial point initial and final point final is in the
language defined by the XG of Figure 8.1, one tries to
prove the goal statement
</bodyText>
<equation confidence="0.586374">
?- sentence(initial,final,[ LE ])
</equation>
<bodyText confidence="0.975503125">
As for DCGs, the string s can be represented in sever-
al ways. If it is represented as a list, the above goal
would be written
?- sentence(sj LE LE 1).
The last two arguments of the goal are 1 ]&apos; to mean
that the overall extraposition list goes from &apos;[ ]&apos; to
&apos;[ ]&apos;; i.e., it is the empty list. Thus, no constituent can
be repositioned into or out of the top level &apos;sentence&apos;.
</bodyText>
<subsectionHeader confidence="0.660462">
11. Conclusions and Further Work
</subsectionHeader>
<bodyText confidence="0.997985714285714">
In this paper I have proposed an extension of
DCGs. The motivation for this extension was to pro-
vide a simple formal device to describe the structure of
such important natural language constructions as rela-
tive clauses and interrogative sentences. In transforma-
tional grammar, these constructions have usually been
analysed in terms of left extraposition, together with
global constraints, such as the complex-NP constraint,
which restrict the range of the extraposition. Global
constraints are not explicit in the grammar rules, but
are given externally to be enforced across rule applica-
tions. These external global constraints cause theoret-
ical difficulties, because the formal properties of the
resulting systems are far from evident, and practical
difficulties, because they lead to obscure grammars
and prevent the use of any reasonable parsing algor-
ithm.
DCGs, although they provide the basic machinery
for a clear description of languages and their struc-
tures, lack a mechanism to describe simply left extra-
position and the associated restrictions. MGs can
express the rewrite of several symbols in a single rule,
but the symbols must be contiguous, as in a type-0
grammar rule. This is still not enough to describe left
extraposition without complicating the rest of the
grammar. XGs are an answer to those limitations.
An XG has the same fundamental property as a
DCG, that it is no more than a convenient notation
for the clauses of an ordinary logic program. XGs and
their translation into definite clauses have been de-
signed to meet three requirements: (i) to be a princi-
pled extension of DCGs, which can be interpreted as a
grammar formalism independently of its translation
into definite clauses; (ii) to provide for simple descrip-
tion of left extraposition and related restrictions; (iii)
to be comparable in efficiency with DCGs when exec-
uted by PROLOG. It turns out that these requirements
are not contradictory, and that the resulting design is
extremely simple. The restrictions on extraposition are
naturally expressed in terms of scope, and scope is
expressed in the formalism by &amp;quot;bracketing out&amp;quot; sub-
derivations corresponding to balanced strings. The
notion of bracketed string derivation is introduced in
order to describe extraposition and bracketing inde-
pendently of the translation of XGs into logic pro-
grams.
Some questions about XGs have not been tackled
in this paper. First, from a theoretical point of view it
would be necessary to complete the independent char-
acterisation of XGs in terms of bracketed strings, and
show rigorously that the translation of XGs into logic
programs correctly renders this independent character-
isation of the semantics of XGs. As pointed out be-
fore, this formalisation does not offer any substantial
problems.
Next, it is not clear whether XGs are as general as
they could be. For instance, it might be possible to
extend them to handle right extraposition of constitu-
ents, which, although less common than left extraposi-
tion, can be used to describe quite frequent English
constructions, such as the gap between head noun and
relative clause in:
What files are there that were created today?
</bodyText>
<page confidence="0.622335">
254 American Journal of Computational Linguistics, Volume 7, Number 4, October-December 1981
</page>
<note confidence="0.712642">
Fernando Pereira Extraposition Grammars
</note>
<bodyText confidence="0.999692909090909">
It may however be possible to describe such situations
in terms of left extraposition of some other constituent
(e.g. the verb phrase &amp;quot;are there&amp;quot; in the example
above).
Finally, I have been looking at what transforma-
tions should be applied to an XG developed as a clear
description of a language, so that the resulting gram-
mar could be used more efficiently in parsing. In par-
ticular, I have been trying to generalise results on det-
erministic parsing of context-free languages into ap-
propriate principles of transformation.
</bodyText>
<sectionHeader confidence="0.968074" genericHeader="method">
Acknowledgements
</sectionHeader>
<bodyText confidence="0.997180875">
David Warren and Michael McCord read drafts of
this paper, and their comments led to many improve-
ments, both in content and in form. The comments of
the referees were also very useful. A British Council
Fellowship partly supported my work in this subject.
The computing facilities I used to experiment with
XGs and to prepare this paper were made available by
British Science Research Council grants.
</bodyText>
<sectionHeader confidence="0.788395" genericHeader="method">
Appendix I. Translating XGs
</sectionHeader>
<bodyText confidence="0.911790636363636">
The following PROLOG program (for the DEC-10
PROLOG system) defines a predicate `grammar(File)&apos;
which translates and stores the XG rules contained in
File. The symbol &amp;quot; as a predicate or functor argu-
ment denotes an &amp;quot;anonymous&amp;quot; variable, i.e. each such
occurrence stands for a separate variable with a single
occurrence.
% Definition of the grammar rule operators
op(1001,xfy,(...)).
op(1200,xfx,(--&gt;)).
% Process the XG in File
</bodyText>
<figure confidence="0.890385655172414">
grammar(File) :-
seeing(01d),
see(File),
consume,
seen,
see(01d).
% Loop until end_of_file
consume :-
repeat,
read(X),
( X=end_of_file, !;
process(X),
fail ).
% Process a grammar rule
process((L--&gt;P)) !,
expandlhs(L,SO,S,HO,H,P),
expandrhs(R,SO,S,HO,H,Q),
assertz((P Q)), !.
% Execute a command
process(( G)) !,
G.
% Store a normal clause
process((P Q))
assertz((P Q)).
% Store a unit clause
process(P) :-
assertz(P).
% Translate an XG rule
% Translate the left-hand side
</figure>
<reference confidence="0.840233937984496">
expandlhs(T,SO,S,HO,H1,Q) :-
flatten(T,CP I L],[]),
front(L,H1,H),
tag(P,SO,S,HO,H,Q).
flatten((X...Y),LO,L) !,
flatten(X,LO,Cgap I Lin,
flatten(Y,L1,L).
flatten((X,Y),LO,L) !,
flatten(X,LO,Enogap I L17),
flatten(Y,L1,L).
flatten(X,CX I L7,L).
front(C7,H,H).
front(CK,X I LLHO,H) :-
case(X,K,H1,H),
front(L,HO,H1).
caseaT I Ts],K,H0,x(K,terminal ,T,H)) !,
unwind(Ts,HO,H).
case(Nt,K,H,x(K,nonterminal ,Nt,H)) :-
virtual_rule(Nt).
% Create the clause
% Nt(S,S,X0,X) virtual(Nt,X0,X)
% for extraposed symbol Nt
virtual_rule(Nt) :-
functor(Nt,F,N),
functor(Y,F,N),
tag(Y,S,S,Hx,Hy,P),
( clause(P,virtual(_,_,_),_), !;
assertaUP virtual(Y,Hx,Hy))) ).
% Translate the right-hand side
expandrhs((X1,X2),SO,S,HO,H,Y) !,
expandrhs(XI,SO,S1,HO,H1,Y1),
expandrhs(X2,S1,S,H1,H,Y2),
and(Y1,Y2,Y).
expandrhs((Xl;X2),SO,S,HO,H,(Y1;Y2)) !,
expandor(X1,SO,S,HO,H,Y1),
expandor(X2,SO,S,HO,H,Y2).
expandrhs(IX1,S,S,H,H,X) .
expandrhs(L,SO,S,HO,H,G) islist(L), !,
expandlist(L,SO,S,HO,H,G).
expandrhs(X,SO,S,HO,H,Y) :-
tag(X,SO,S,HO,H,Y).
expandor(X,SO,S,HO,H,Y) :-
expandrhs(X,S0a,S,H0a,H,Ya),
( S\—S0a, !, SO=S0a, Yb=Ya; and(SO=S0a,Ya,Yb) ),
( H\==H0a, !, HO=H0a, Y=Yb; and(HO=H0a,Yb,Y) ).
expandlist(ELS,S,H,H,true).
expandlist(CX7,SO,S,HO,H,terminal(X,SO,S,HO,H) ) !.
expandlist(IXILLSO,S,HO,H,
American Journal of Computational Linguistics, Volume 7, Number 4, October-December 1981 255
Fernando Pereira Extraposition Grammars
(terminal(X,SO,S1,HO,H1),Y)) :-
expandlist(L,S1,S,H1,H,Y).
tag(P,A1,A2,A3,A4,Q) :-
P=..[FlArgs0],
conc(Args0JA1,A2,A3,A4],Args),
Q=..[FlArgs].
and(true,P,P) !.
and(P,true,P) !.
and(P,Q,(P,Q)).
islist(M).
unwind(M,H,H) !.
unwind([T I Ts],H0,x(nogap,terminal ,T,H)) :-
unwind(Ts,HO,H).
conc(ELL,L) !.
conc([X I L1],L2,[X I L3]) :-
conc(L1,L2,L3).
sentence(SO,S,X0,X) :-
noun_phrase(SO,S1,X0,X1),
verb_phrase(S1,S,X1,X).
noun_phrase(SO,S,X0,X) :-
proper_noun(SO,S,X0,X).
noun_phrase(SO,S,X0,X) :-
determiner(SO,S1,X0,X1),
noun(S1,S2,X1,X2),
relative(S2,S,X2,X).
noun_phrase(SO,S,X0,X) :-
determiner(SO,S1,X0,X1),
noun(S1,S2,X1,X2),
prep_phrase(S2,S,X2,X).
noun_phrase(SO,S,X0,X) :-
trace(SO,S,X0,X).
verb_phrase(SO,S,X0,X) :-
verb(SO,S1,X0,X1),
noun_phrase(S1,S,X1,X).
verb_phrase(SO,S,X0,X) :-
verb(SO,S,X0,X).
relative(SO,S0,X,X).
relative(SO,S,X0,X) :-
open(SO,S1,X0,X1),
rel_marker(S1,S2,X1,X2),
sentence(S2,S3,X2,X3),
close(S3,S,X3,X).
trace(SO,S0,X0,X) :-
virtual(trace,X0,X).
rel_marker(SO,S,X0,x(gap,nonterminal,trace,X)) :-
rel_pronoun(SO,S,X0,X).
prep_phrase(SO,S,X0,X) :-
preposition(SO,S1,X0,X1),
noun_phrase(S1,S,X1,X).
open(SO,S0,X,x(gap,nonterminal,close,X)).
close(SO,S0,X0,X) :-
virtual(close,X0,X).
References
1. Chomsky, N. Reflections on Language. Pantheon, 1975.
2. Colmerauer, A. &amp;quot;Metamorphosis Grammars.&amp;quot; In Natural Lan-
guage Communication with Computers, L .Bole (ed.). Springer-
Verlag, 1978. First appeared as an internal report, &apos;Les Gram-
maires de Metamorphose&apos;, in November 1975
3. Colmerauer, A. &amp;quot;Les Bases Theoriques de PROLOG.&amp;quot; Groupe
d&apos;Intelligence Artificielle, U. E. R. de Luminy, Universite d&apos;Aix-
Marseille II, 1979.
4. Dahl, V. &amp;quot;Un Systeme Deductif d&apos;Interrogation de Banques de
Donnees en Espagnol.&amp;quot; Groupe d&apos;Intelligence Artificielle, U.
E. R. de Luminy, Universite d&apos;Aix-Marseille II, 1977.
5. Gazdar, G. &amp;quot;English as a Context-Free Language.&amp;quot; School of
Social Sciences, University of Sussex, April, 1979.
6. Pereira, F. and Warren, D. H. D. &amp;quot;Definite Clause Grammars
for Language Analysis — A Survey of the Formalism and a
Comparison with Augmented Transition Networks.&amp;quot; Artificial
Intelligence 13 (1980) 231-278.
7. Pique, J. F. &amp;quot;Interrogation en Francais d&apos;une Base de Donnees
Relationnelle.&amp;quot; Groupe d&apos;Intelligence Artificielle, U. E. R. de
Luminy, Universite d&apos;Aix-Marseille II, 1978.
8. Ross, J. R. Excerpts from &apos;Constraints on Variables in Syntax&apos;.
In G. Harman (ed.): On Noam Chomsky: Critical Essays, An-
chor Books, 1974.
9. Roussel, P. &amp;quot;PROLOG : Manuel de Reference et Utilisation.&amp;quot;
Groupe d&apos;Intelligence Artificielle, U.E.R. de Luminy, Universite
d&apos;Aix-Marseille II, 1975.
</reference>
<bodyText confidence="0.633184428571428">
Fernando C. N. Pereira is a research associate in the
Department of Architecture at Edinburgh University, and
also a graduate student in the Department of Artificial
Intelligence. He received the M.Sc. degree in mathemat-
ics from Lisbon University in 1975.
Appendix II. Definite clauses for the grammar
used in Figure 9.2
</bodyText>
<page confidence="0.670589">
256 American Journal of Computational Linguistics, Volume 7, Number 4, October-December 1981
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.920437">
<title confidence="0.999904">Extraposition Grammars</title>
<author confidence="0.999691">Fernando Pereira</author>
<affiliation confidence="0.9996135">Department of University of Edinburgh</affiliation>
<address confidence="0.954867">Edinburgh EH1 1JZ SCOTLAND</address>
<abstract confidence="0.987071333333333">Extraposition grammars are an extension of definite clause grammars, and are similarly defined in terms of logic clauses. The extended formalism makes it easy to describe left extraposition of constituents, an important feature of natural language syntax.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="false">
<note>expandlhs(T,SO,S,HO,H1,Q) :-flatten(T,CP I L],[]), front(L,H1,H),</note>
<marker></marker>
<rawString>expandlhs(T,SO,S,HO,H1,Q) :-flatten(T,CP I L],[]), front(L,H1,H),</rawString>
</citation>
<citation valid="false">
<date></date>
<marker></marker>
<rawString>tag(P,SO,S,HO,H,Q). flatten((X...Y),LO,L) !, flatten(X,LO,Cgap I Lin, flatten(Y,L1,L).</rawString>
</citation>
<citation valid="false">
<title>flatten(X,LO,Enogap I L17), flatten(Y,L1,L). flatten(X,CX I</title>
<marker></marker>
<rawString>flatten((X,Y),LO,L) !, flatten(X,LO,Enogap I L17), flatten(Y,L1,L). flatten(X,CX I L7,L). front(C7,H,H).</rawString>
</citation>
<citation valid="false">
<booktitle>front(CK,X I LLHO,H) :-case(X,K,H1,H),</booktitle>
<pages>1</pages>
<marker></marker>
<rawString>front(CK,X I LLHO,H) :-case(X,K,H1,H), front(L,HO,H1).</rawString>
</citation>
<citation valid="false">
<tech>caseaT I Ts],K,H0,x(K,terminal ,T,H)) !, unwind(Ts,HO,H).</tech>
<marker></marker>
<rawString>caseaT I Ts],K,H0,x(K,terminal ,T,H)) !, unwind(Ts,HO,H).</rawString>
</citation>
<citation valid="false">
<note>case(Nt,K,H,x(K,nonterminal ,Nt,H)) :-virtual_rule(Nt).</note>
<marker></marker>
<rawString>case(Nt,K,H,x(K,nonterminal ,Nt,H)) :-virtual_rule(Nt).</rawString>
</citation>
<citation valid="false">
<booktitle>Create the clause % Nt(S,S,X0,X) virtual(Nt,X0,X) %</booktitle>
<note>for extraposed symbol Nt</note>
<marker></marker>
<rawString>% Create the clause % Nt(S,S,X0,X) virtual(Nt,X0,X) % for extraposed symbol Nt</rawString>
</citation>
<citation valid="false">
<authors>
<author>virtualrule -functor</author>
</authors>
<title>functor(Y,F,N), tag(Y,S,S,Hx,Hy,P), ( clause(P,virtual(_,_,_),_), !; assertaUP virtual(Y,Hx,Hy</title>
<booktitle>Translate the right-hand side expandrhs((X1,X2),SO,S,HO,H,Y) !, expandrhs(XI,SO,S1,HO,H1,Y1), expandrhs(X2,S1,S,H1,H,Y2),</booktitle>
<pages>1--2</pages>
<marker>-functor, </marker>
<rawString>virtual_rule(Nt) :-functor(Nt,F,N), functor(Y,F,N), tag(Y,S,S,Hx,Hy,P), ( clause(P,virtual(_,_,_),_), !; assertaUP virtual(Y,Hx,Hy))) ). % Translate the right-hand side expandrhs((X1,X2),SO,S,HO,H,Y) !, expandrhs(XI,SO,S1,HO,H1,Y1), expandrhs(X2,S1,S,H1,H,Y2), and(Y1,Y2,Y).</rawString>
</citation>
<citation valid="false">
<volume>1</volume>
<pages>2--2</pages>
<marker></marker>
<rawString>expandrhs((Xl;X2),SO,S,HO,H,(Y1;Y2)) !, expandor(X1,SO,S,HO,H,Y1), expandor(X2,SO,S,HO,H,Y2).</rawString>
</citation>
<citation valid="false">
<authors>
<author>expandrhs</author>
</authors>
<note>expandrhs(L,SO,S,HO,H,G) islist(L), !, expandlist(L,SO,S,HO,H,G). expandrhs(X,SO,S,HO,H,Y) :-tag(X,SO,S,HO,H,Y).</note>
<marker>expandrhs, </marker>
<rawString>expandrhs(IX1,S,S,H,H,X) . expandrhs(L,SO,S,HO,H,G) islist(L), !, expandlist(L,SO,S,HO,H,G). expandrhs(X,SO,S,HO,H,Y) :-tag(X,SO,S,HO,H,Y).</rawString>
</citation>
<citation valid="false">
<note>expandor(X,SO,S,HO,H,Y) :-expandrhs(X,S0a,S,H0a,H,Ya),</note>
<marker></marker>
<rawString>expandor(X,SO,S,HO,H,Y) :-expandrhs(X,S0a,S,H0a,H,Ya),</rawString>
</citation>
<citation valid="false">
<booktitle>S\—S0a, !, SO=S0a, Yb=Ya; and(SO=S0a,Ya,Yb) ), ( H\==H0a, !, HO=H0a, Y=Yb; and(HO=H0a,Yb,Y) ). expandlist(ELS,S,H,H,true).</booktitle>
<marker></marker>
<rawString>( S\—S0a, !, SO=S0a, Yb=Ya; and(SO=S0a,Ya,Yb) ), ( H\==H0a, !, HO=H0a, Y=Yb; and(HO=H0a,Yb,Y) ). expandlist(ELS,S,H,H,true).</rawString>
</citation>
<citation valid="false">
<tech>expandlist(CX7,SO,S,HO,H,terminal(X,SO,S,HO,H) ) !. expandlist(IXILLSO,S,HO,H,</tech>
<marker></marker>
<rawString>expandlist(CX7,SO,S,HO,H,terminal(X,SO,S,HO,H) ) !. expandlist(IXILLSO,S,HO,H,</rawString>
</citation>
<citation valid="true">
<title>255 Fernando Pereira Extraposition Grammars (terminal(X,SO,S1,HO,H1),Y)) :-expandlist(L,S1,S,H1,H,Y).</title>
<date>1981</date>
<journal>American Journal of Computational Linguistics,</journal>
<volume>7</volume>
<marker>1981</marker>
<rawString>American Journal of Computational Linguistics, Volume 7, Number 4, October-December 1981 255 Fernando Pereira Extraposition Grammars (terminal(X,SO,S1,HO,H1),Y)) :-expandlist(L,S1,S,H1,H,Y).</rawString>
</citation>
<citation valid="false">
<note>tag(P,A1,A2,A3,A4,Q) :-P=..[FlArgs0],</note>
<marker></marker>
<rawString>tag(P,A1,A2,A3,A4,Q) :-P=..[FlArgs0],</rawString>
</citation>
<citation valid="false">
<note>conc(Args0JA1,A2,A3,A4],Args), Q=..[FlArgs].</note>
<marker></marker>
<rawString>conc(Args0JA1,A2,A3,A4],Args), Q=..[FlArgs].</rawString>
</citation>
<citation valid="false">
<marker></marker>
<rawString>and(true,P,P) !. and(P,true,P) !. and(P,Q,(P,Q)). islist(M). unwind(M,H,H) !.</rawString>
</citation>
<citation valid="false">
<booktitle>unwind([T I Ts],H0,x(nogap,terminal ,T,H)) :-unwind(Ts,HO,H). conc(ELL,L) !.</booktitle>
<marker></marker>
<rawString>unwind([T I Ts],H0,x(nogap,terminal ,T,H)) :-unwind(Ts,HO,H). conc(ELL,L) !.</rawString>
</citation>
<citation valid="false">
<booktitle>conc([X I L1],L2,[X I L3]) :-conc(L1,L2,L3).</booktitle>
<marker></marker>
<rawString>conc([X I L1],L2,[X I L3]) :-conc(L1,L2,L3).</rawString>
</citation>
<citation valid="false">
<note>sentence(SO,S,X0,X) :-noun_phrase(SO,S1,X0,X1), verb_phrase(S1,S,X1,X).</note>
<marker></marker>
<rawString>sentence(SO,S,X0,X) :-noun_phrase(SO,S1,X0,X1), verb_phrase(S1,S,X1,X).</rawString>
</citation>
<citation valid="false">
<marker></marker>
<rawString>noun_phrase(SO,S,X0,X) :-proper_noun(SO,S,X0,X).</rawString>
</citation>
<citation valid="false">
<volume>0</volume>
<pages>2--2</pages>
<marker></marker>
<rawString>noun_phrase(SO,S,X0,X) :-determiner(SO,S1,X0,X1), noun(S1,S2,X1,X2), relative(S2,S,X2,X).</rawString>
</citation>
<citation valid="false">
<volume>0</volume>
<pages>2--2</pages>
<marker></marker>
<rawString>noun_phrase(SO,S,X0,X) :-determiner(SO,S1,X0,X1), noun(S1,S2,X1,X2), prep_phrase(S2,S,X2,X).</rawString>
</citation>
<citation valid="false">
<marker></marker>
<rawString>noun_phrase(SO,S,X0,X) :-trace(SO,S,X0,X).</rawString>
</citation>
<citation valid="false">
<volume>0</volume>
<pages>1--1</pages>
<marker></marker>
<rawString>verb_phrase(SO,S,X0,X) :-verb(SO,S1,X0,X1), noun_phrase(S1,S,X1,X).</rawString>
</citation>
<citation valid="false">
<marker></marker>
<rawString>verb_phrase(SO,S,X0,X) :-verb(SO,S,X0,X).</rawString>
</citation>
<citation valid="false">
<note>relative(SO,S0,X,X). relative(SO,S,X0,X) :-open(SO,S1,X0,X1), close(S3,S,X3,X).</note>
<marker></marker>
<rawString>relative(SO,S0,X,X). relative(SO,S,X0,X) :-open(SO,S1,X0,X1), close(S3,S,X3,X).</rawString>
</citation>
<citation valid="false">
<marker></marker>
<rawString>trace(SO,S0,X0,X) :-virtual(trace,X0,X).</rawString>
</citation>
<citation valid="false">
<marker></marker>
<rawString>rel_marker(SO,S,X0,x(gap,nonterminal,trace,X)) :-rel_pronoun(SO,S,X0,X).</rawString>
</citation>
<citation valid="false">
<note>prep_phrase(SO,S,X0,X) :-preposition(SO,S1,X0,X1), noun_phrase(S1,S,X1,X). open(SO,S0,X,x(gap,nonterminal,close,X)).</note>
<marker></marker>
<rawString>prep_phrase(SO,S,X0,X) :-preposition(SO,S1,X0,X1), noun_phrase(S1,S,X1,X). open(SO,S0,X,x(gap,nonterminal,close,X)).</rawString>
</citation>
<citation valid="false">
<marker></marker>
<rawString>close(SO,S0,X0,X) :-virtual(close,X0,X).</rawString>
</citation>
<citation valid="true">
<authors>
<author>N Chomsky</author>
</authors>
<title>Reflections on Language. Pantheon,</title>
<date>1975</date>
<marker>Chomsky, 1975</marker>
<rawString>References 1. Chomsky, N. Reflections on Language. Pantheon, 1975.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Colmerauer</author>
</authors>
<title>Metamorphosis Grammars.&amp;quot; In Natural Language Communication with Computers,</title>
<date>1978</date>
<editor>L .Bole (ed.).</editor>
<publisher>SpringerVerlag,</publisher>
<location>in</location>
<marker>Colmerauer, 1978</marker>
<rawString>2. Colmerauer, A. &amp;quot;Metamorphosis Grammars.&amp;quot; In Natural Language Communication with Computers, L .Bole (ed.). SpringerVerlag, 1978. First appeared as an internal report, &apos;Les Grammaires de Metamorphose&apos;, in November 1975</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Colmerauer</author>
</authors>
<title>Les Bases Theoriques de PROLOG.&amp;quot; Groupe d&apos;Intelligence</title>
<date>1979</date>
<marker>Colmerauer, 1979</marker>
<rawString>3. Colmerauer, A. &amp;quot;Les Bases Theoriques de PROLOG.&amp;quot; Groupe d&apos;Intelligence Artificielle, U. E. R. de Luminy, Universite d&apos;AixMarseille II, 1979.</rawString>
</citation>
<citation valid="true">
<authors>
<author>V Dahl</author>
</authors>
<title>Un Systeme Deductif d&apos;Interrogation de Banques de Donnees en Espagnol.&amp;quot; Groupe d&apos;Intelligence</title>
<date>1977</date>
<marker>Dahl, 1977</marker>
<rawString>4. Dahl, V. &amp;quot;Un Systeme Deductif d&apos;Interrogation de Banques de Donnees en Espagnol.&amp;quot; Groupe d&apos;Intelligence Artificielle, U. E. R. de Luminy, Universite d&apos;Aix-Marseille II, 1977.</rawString>
</citation>
<citation valid="true">
<authors>
<author>G Gazdar</author>
</authors>
<title>English as a Context-Free Language.&amp;quot; School of Social Sciences,</title>
<date>1979</date>
<institution>University of Sussex,</institution>
<marker>Gazdar, 1979</marker>
<rawString>5. Gazdar, G. &amp;quot;English as a Context-Free Language.&amp;quot; School of Social Sciences, University of Sussex, April, 1979.</rawString>
</citation>
<citation valid="true">
<authors>
<author>F Pereira</author>
<author>D H D Warren</author>
</authors>
<title>Definite Clause Grammars for Language Analysis — A Survey of the Formalism and a Comparison with Augmented Transition Networks.&amp;quot;</title>
<date>1980</date>
<journal>Artificial Intelligence</journal>
<volume>13</volume>
<pages>231--278</pages>
<marker>Pereira, Warren, 1980</marker>
<rawString>6. Pereira, F. and Warren, D. H. D. &amp;quot;Definite Clause Grammars for Language Analysis — A Survey of the Formalism and a Comparison with Augmented Transition Networks.&amp;quot; Artificial Intelligence 13 (1980) 231-278.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J F Pique</author>
</authors>
<title>Interrogation en Francais d&apos;une Base de Donnees Relationnelle.&amp;quot; Groupe d&apos;Intelligence</title>
<date>1978</date>
<marker>Pique, 1978</marker>
<rawString>7. Pique, J. F. &amp;quot;Interrogation en Francais d&apos;une Base de Donnees Relationnelle.&amp;quot; Groupe d&apos;Intelligence Artificielle, U. E. R. de Luminy, Universite d&apos;Aix-Marseille II, 1978.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J R Ross</author>
</authors>
<title>Excerpts from &apos;Constraints on Variables in Syntax&apos;.</title>
<date>1974</date>
<booktitle>On Noam Chomsky: Critical Essays, Anchor Books,</booktitle>
<editor>In G. Harman (ed.):</editor>
<marker>Ross, 1974</marker>
<rawString>8. Ross, J. R. Excerpts from &apos;Constraints on Variables in Syntax&apos;. In G. Harman (ed.): On Noam Chomsky: Critical Essays, Anchor Books, 1974.</rawString>
</citation>
<citation valid="true">
<authors>
<author>P Roussel</author>
</authors>
<title>PROLOG : Manuel de Reference et Utilisation.&amp;quot;</title>
<date>1975</date>
<booktitle>Groupe d&apos;Intelligence Artificielle, U.E.R. de Luminy, Universite d&apos;Aix-Marseille II,</booktitle>
<marker>Roussel, 1975</marker>
<rawString>9. Roussel, P. &amp;quot;PROLOG : Manuel de Reference et Utilisation.&amp;quot; Groupe d&apos;Intelligence Artificielle, U.E.R. de Luminy, Universite d&apos;Aix-Marseille II, 1975.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>