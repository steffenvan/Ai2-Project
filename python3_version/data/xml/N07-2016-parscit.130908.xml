<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000680">
<bodyText confidence="0.999452692307692">
is a unique edge p → v for all v ∈ V, v =% r. Relation
→∗ is the reflexive transitive closure of → and is
usually called subordination.
The following definitions allow us to formulate
our results succinctly. For each node i we define
its level as the length of the path r →∗ i; we de-
note it leveli. The symmetrization ↔ = → ∪ →−1
makes it possible to talk about edges (pairs of nodes
i, j such that i → j) without explicitly specifying
the parent (head etc.; i here) and the child (de-
pendent etc.; j here); so → represents directed
edges and ↔ undirected edges. To retain the abil-
ity to talk about the direction of edges, we define
</bodyText>
<equation confidence="0.998956">
i if i → j j if i → j
Parenti↔j = j if j → i and Childi↔j = i if j → i.
</equation>
<bodyText confidence="0.975707">
Our notation for rooted subtrees is Subtreei = {v ∈
V  |i →∗ v}, Subtreei↔j = {v ∈ V  |Parenti↔j →∗ v},
and for ancestors Anci = {v ∈ V  |v →∗ i}, Anci↔j =
{v ∈ V  |v →∗ Parenti↔j}. To be able to talk con-
cisely about the total order on nodes &amp;quot;, we de-
fine open and closed intervals whose endpoints need
not be in a prescribed order: (i, j) = {v ∈ V |
min&amp;quot;{i, j} ≺ v ≺ max&amp;quot;{i, j}} and [i, j] = {v ∈ V |
min&amp;quot;{i, j} &amp;quot; v &amp;quot; max&amp;quot;{i, j}}, resp. For any edge
</bodyText>
<equation confidence="0.941239">
i ↔ j we define its gap as follows Gapi↔j = {v ∈
</equation>
<bodyText confidence="0.8050193">
V  |v ∈ (i, j) &amp; v ∈/ Subtreei↔j}. An edge with an
empty gap is projective, an edge whose gap is non-
empty is non-projective. (See e.g. (Havelka, 2005)
for the characterization of projectivity via properties
of edges and further references.)
Property 2 Let a be a node and i ↔ j any edge
disjoint from a. Then i ∈ Subtreea ⇔ j ∈ Subtreea.
PROOF. From the assumption i =% a =% j it follows
that i, j ∈ Subtreea ⇔ Parenti↔j ∈ Subtreea.
Proposition 3 Let i ↔ j, u ↔ v be disjoint edges.
</bodyText>
<listItem confidence="0.9507266">
(i) If u,v ∈ (i, j), then u ∈ Gapi↔j ⇔ v ∈ Gapi↔j.
(ii) If u ∈ Gapi↔j and v ∈/ Gapi↔j, then v ∈/ [i, j].
PROOF. (i) follows immediately from the definition
of Gapi↔j and Property 2. To prove (ii), assume v ∈
(i, j) and using (i) arrive at a contradiction.
</listItem>
<sectionHeader confidence="0.950869" genericHeader="abstract">
3 Well-nestedness
</sectionHeader>
<bodyText confidence="0.99392996">
Kuhlmann and Nivre (2006) claim that the constraint
of well-nestedness seems to approximate well de-
pendency structures occurring in natural language.
DeÞnition 4 A dependency tree T is ill-nested if
there are disjoint subtrees T1, T2 of T and nodes
x1,y1 ∈ T1 and x2,y2 ∈ T2 such that x1 ∈ (x2,y2) and
x2 ∈ (x1,y1). A dependency tree T that is not ill-
nested is well-nested.2
It is easy to express the constraint in terms of
edges—it will prove crucial in Sect. 5.
Theorem 5 A dependency tree T is ill-nested iff
there are edges i1 ↔ j1, i2 ↔ j2 in disjoint subtrees
T1, T2 of T, resp., such that i1 ∈ (i2, j2), i2 ∈ (i1, j1).
PROOF. Direction ⇐ is obvious.
Direction ⇒: Let ri be the root of Ti. To find
i1 ↔ j1, first suppose that r1 ∈ (x2,y2). Consider the
first edge vk → vk+1 on the downward path v0 = r1,
v1,...,vm = y1, m &gt; 0, such that vk ∈ (x2,y2) and
vk+1 ∈/ [x2,y2]. If r1 ∈/ [x2,y2], consider the first edge
vk+1 → vk on the upward path v0 = x1,v1,...,vn =
r1, n &gt; 0, such that vk ∈ (x2,y2) and vk+1 ∈/ [x2,y2].
Let us denote i1 = vk and j1 = vk+1, and possibly re-
name x2,y2 so that i1 ∈ (x2,y2) and x2 ∈ (i1, j1). To
find i2 ↔ j2 such that i1 ∈ (i2, j2), i2 ∈ (i1, j1), pro-
ceed similarly as above. Obviously, edges i1 ↔ j1,
</bodyText>
<equation confidence="0.857211">
i2 ↔ j2 are in disjoint subtrees.
</equation>
<sectionHeader confidence="0.911856" genericHeader="method">
4 Level types of non-projective edges
</sectionHeader>
<bodyText confidence="0.968449125">
Level types of non-projective edges allow their
structural classification with interesting formal prop-
erties. They were introduced by Havelka (2005),
who presents them in more detail.
DeÞnition 6 The level type (or just type) of a non-
projective edge i ↔ j is defined as follows
Typei↔j = levelChildi↔ j − minn∈Gapi↔ j leveln .
The type of an edge is the distance of its child
node and a node in its gap closest to the root (dis-
tance here means difference in levels)—for sample
configurations see Figure 13. Note that there may
be more than one node witnessing an edge’s type.
The type of an edge is not bounded—it can take any
integer value (depending on the height of a tree).
Our definition of level type of non-projective
edges extends naturally the original definition im-
</bodyText>
<footnote confidence="0.512943">
2The original definition requires x1 ≺ x2 ≺ y1 ≺ y2, however
our equivalent formulation leads to shorter theorems and proofs.
3We adopt the following convention: nodes are drawn top-
down according to their increasing level, with nodes on the
same level on the same horizontal line; nodes are drawn from
left to right according to the total order on nodes; edges are
drawn as solid lines, paths as dotted curves. We assume that no
node on a path lies in the span of an edge the path crosses.
</footnote>
<page confidence="0.995645">
62
</page>
<bodyText confidence="0.803437">
positive type type 0 negative type
</bodyText>
<figureCaption confidence="0.998657">
Figure 1: Sample non-projective edges
</figureCaption>
<bodyText confidence="0.903631157894737">
plicit in (Havelka, 2005), where classes correspond-
ing to positive, zero and negative types are deÞned.
We now show a relationship between edges of cer-
tain types that will allow us to derive a relationship
between non-projective edges and well-nestedness.
Theorem 7 For any non-projective edge i H j in a
dependency tree T with TypeiHj &lt; 0 (&lt; 0) there is
a non-projective edge v —* u in T with TypeuHv &gt; 0
(&gt; 0) such that u E argminnEGapiHj leveln and either
i E GapuHv, or j E GapuHv.
PROOF. Let u be any node in argminnEGapiHj leveln.
From the assumption TypeiHj &lt; 0 node u has a par-
ent v E/ GapiHj. Obviously i H j, v —* u are dis-
joint, thus from Proposition 3 we have v E/ [i, j], and
so either i E (u,v), or j E (u,v). Since levelv &gt;
levelParentiHj, we have that ParentiHj E/ Subtreev, and
so either i E GapuHv, or j E GapuHv. Finally from
TypeiHj &lt; 0 (&lt; 0) we get levelu — levelChildiHj &gt; 0
(&gt; 0), hence TypeuHv &gt; 0 (&gt; 0).
</bodyText>
<sectionHeader confidence="0.987112" genericHeader="method">
5 Well-nestedness &amp; non-projective edges
</sectionHeader>
<bodyText confidence="0.999955">
We give characterizations of well-nestedness solely
in terms of properties of non-projective edges and
show some applications.
</bodyText>
<subsectionHeader confidence="0.995535">
5.1 Characterization using pairs of edges
</subsectionHeader>
<bodyText confidence="0.999730166666667">
First we give a characterization of pairs of edges in
Theorem 5 in terms of their gaps.
Theorem 8 Let i1 H j1, i2 H j2 be two edges in a
dependency tree T. They are in disjoint subtrees T1,
T2, resp., and satisfy i1 E (i2, j2), i2 E (i1, j1) iff the
following condition holds
</bodyText>
<equation confidence="0.905684">
(inp) i1 E Gapi2Hj2 &amp; i2 E Gapi1Hj1 .
</equation>
<bodyText confidence="0.977904">
PROOF. Direction &lt;--: Root Tk in ParentikHjk, k =
1,2. Condition (inp) obviously implies i1 E (i2, j2),
i2 E (i1, j1), which in turn implies that edges i1 H j1,
i2 H j2 are disjoint. From Property 2 we get that
both Parenti2Hj2 E/ Subtreei1Hj1 and Parenti1Hj1 E/
Subtreei2Hj2, hence subtrees T1, T2 are disjoint.
Direction ==&gt;.: Let us consider the edge i2 H j2
and node i1. Since T1 is disjoint from T2, we have
that i1 E/ Subtreei2Hj2, and therefore i1 E Gapi2Hj2.
The proof that i2 E Gapi1Hj1 is analogous.
Condition (inp) allows us to talk about pairs of
edges causing ill-nestedness and so characterize
well-nestedness using properties of pairs of edges.
DeÞnition 9 We say that any two non-projective
edges i1 H j1, i2 H j2 in a dependency tree T sat-
isfying condition (inp) form an ill-nested pair of
edges.
Corollary 10 A dependency tree T is ill-nested iff it
contains an ill-nested pair of edges.
PROOF. Follows from Theorems 5 and 8.
</bodyText>
<subsectionHeader confidence="0.998373">
5.2 SufÞcient condition for ill-nestedness
</subsectionHeader>
<bodyText confidence="0.983216545454546">
The results of Section 4 and previous subsection give
the following relationship between types of non-
projective edges and well-nestedness.
Theorem 11 If a dependency tree contains a non-
proj. edge of nonpositive type, then it is ill-nested.
PROOF. Follows from Theorems 7 and 10.
We see that types of non-projective edges and
well-nestedness share a common ground; however,
the statement of Theorem 11 cannot be strengthened
to equivalence (it is easy to see that also two edges
of positive type can satisfy (inp)).
</bodyText>
<subsectionHeader confidence="0.997449">
5.3 Characterization using single edges
</subsectionHeader>
<bodyText confidence="0.999721166666667">
Now we show that well-nestedness can be character-
ized in terms of properties of single non-projective
edges only. We deÞne the ill-nested set of an edge
and show that it gives the desired characterization.
DeÞnition 12 The ill-nested set of any edge i H j
is deÞned as follows
</bodyText>
<equation confidence="0.9008245">
IniHj = {u H v  |u E GapiHj &amp; v E/ [i, j]
&amp; u,v E/ AnciHj} .
</equation>
<bodyText confidence="0.9861055">
The next proposition exposes the relationship of
edges in IniHj to the gap of i H j.
</bodyText>
<footnote confidence="0.6369804">
Proposition 13 For any edge i H j IniHj = {u H v |
u E GapiHj &amp; v E/ GapiHj &amp; u,v E/ AnciHj}.
PROOF. The inclusion C_ is obvious. The inclusion
_D follows from Proposition 3 (u E GapiHj and v E/
AnciHj imply that edges i H j, u H v are disjoint).
</footnote>
<page confidence="0.999165">
63
</page>
<bodyText confidence="0.917515086956522">
We are ready to formulate the main result of this
section, which gives as corollary a characterization
of well-nestedness using properties of single edges.
Theorem 14 Let i ↔ j be an edge in a dependency
tree T. The edges that form an ill-nested pair with
the edge i ↔ j are exactly the edges in Ini↔j.
PROOF. Direction ⇒: Let u ↔ v be an edge forming
an ill-nested pair with the edge i ↔ j, i.e. i ∈ Gapu↔v
and u ∈ Gapi↔ j. This implies i ∈ (u,v) and u ∈ (i, j),
which immediately gives v ∈/ [i, j]. Supposing u ∈
Anci↔j or v ∈ Anci↔j we get i ∈ Subtreeu↔v, which
is in contradiction with i ∈ Gapu↔v, and therefore
u,v ∈/ Anci↔j. Hence u ↔ v ∈ Ini↔j.
Direction ⇐: Let u ↔ v ∈ Ini↔j (i.e. u ∈ Gapi↔j,
v ∈/ [i, j], and u,v ∈/ Anci↔j; without loss of gen-
erality assume i ∈ (u,v)). From the assumptions
u ∈ Gapi↔j and v ∈/ [i, j] we get that edges i ↔ j,
u ↔ v are disjoint. Using Property 2, from the as-
sumption u,v ∈/ Anci↔j we get i ∈/ Subtreeu↔v, thus
i ∈ Gapu↔v. Hence i ↔ j, u ↔ v satisfy (inp).
Corollary 15 A dependency tree T is ill-nested iff
Ini↔j =% 0 for some non-projective edge i ↔ j in T.
PROOF. Follows from Theorems 8 and 14.
</bodyText>
<subsectionHeader confidence="0.993646">
5.4 Checking well-nestedness
</subsectionHeader>
<bodyText confidence="0.999971333333333">
Our characterization of well-nestedness gives also a
novel way of checking it. Here is a pseudocode of
an algorithm for fully determining all ill-nested sets:
</bodyText>
<listItem confidence="0.992293333333333">
1: for all edges i ↔ j do
2: for all edges u ↔ v s.t. u ∈ (i, j) do
3: check u ↔ v ∈ Ini↔j
</listItem>
<bodyText confidence="0.99583664">
Its time complexity is obviously O(n2), since the
check on line 3 can be implemented so as to take
constant time (by precompuing →∗, which can be
done in O(n2) time). The bound is the same
as for the reported algorithms for checking well-
nestedness (Mšhl, 2006).
However, the following theorem allows well-
nestedness checking to be linear for projective trees,
to be faster for random input, and to remain O(n2).
Theorem 16 In any ill-nested pair of edges, at least
one of the edges is of nonnegative type (witnessed by
an end-point of the other edge).
PROOF. Let i1 ↔ j1, i2 ↔ j2 satisfy (inp). Let
us suppose that levelChildi1↔j1 ≥ levelChildi2↔j2. Since
levelChildu↔v ≥ levelu for any edge u ↔ v, we have
that levelChild i1↔j1 ≥ leveli2, and hence Typei1↔j1 ≥
0. If levelChildi1↔j1 ≤ levelChildi2↔j2, it is analogously
proved that i2 ↔ j2 is of nonnegative type.
Havelka (2005) presents a linear algorithm for
finding all non-projective edges of nonnegative type.
Thus well-nestedness can be checked as follows:
first find all edges of nonnegative type, and then
check their ill-nested sets for non-emptiness. Com-
puting →∗ on demand for subtrees of the processed
edges, we preserve worst-case quadratic complexity.
</bodyText>
<sectionHeader confidence="0.999174" genericHeader="conclusions">
6 Conclusion
</sectionHeader>
<bodyText confidence="0.998940153846154">
We have presented new formal results linking prop-
erties of non-projective edges and their level types to
well-nestedness. This work extends the current body
of research on non-projective dependency structures
in natural language. In particular, we offer new in-
sights into formal properties of non-projective edges
that, if possible, both provide adequate means for
linguistic description and at the same time are use-
ful as features in machine-learning approaches.
Acknowledgement This work was supported by
projects 1ET201120505 of the Ministry of Edu-
cation of the Czech Republic and 374/2005/A-
INF/MFF of Grant Agency of Charles University.
</bodyText>
<sectionHeader confidence="0.999097" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.9993135">
Jif’ Havelka. 2005. Projectivity in Totally Ordered
Rooted Trees: An Alternative Definition of Projec-
tivity and Optimal Algorithms for Detecting Non-
Projective Edges and Projectivizing Totally Ordered
Rooted Trees. Prague Bulletin of Mathematical Lin-
guistics, 84:13–30.
Marco Kuhlmann and Joakim Nivre. 2006. Mildly Non-
Projective Dependency Structures. In Proceedings of
COLING/ACL, pages 507–514.
Ryan McDonald, Fernando Pereira, Kiril Ribarov, and
Jan Hajic. 2005. Non-Projective Dependency Pars-
ing using Spanning Tree Algorithms. In Proceedings
of HLT/EMNLP, pages 523–530.
Mathias Mšhl. 2006. Drawings as models of syntac-
tic structure: Theory and algorithms. Diploma thesis,
Programming Systems Lab, UniversitŠt des Saarlan-
des, Saarbrficken.
Joakim Nivre. 2006. Constraints on Non-Projective De-
pendency Parsing. In Proc. of EACL, pages 73–80.
Neil J. A. Sloane. 2007. On-Line Encyclopedia
of Integer Sequences. Published electronically at
www.research.att.com/~njas/sequences/.
</reference>
<page confidence="0.999409">
64
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.007993">
<title confidence="0.734123">a unique p all Relation</title>
<abstract confidence="0.99400864556962">the transitive closure of is called following allow us to formulate results succinctly. For each node the length of the path we deit The symmetrization ∪ makes it possible to talk about edges (pairs of nodes that without explicitly specifying and the so directed and edges. To retain the abilto talk about the direction of edges, we j notation for rooted for To be able to talk conabout the total order on nodes we deintervals endpoints need be in a prescribed order: = ≺ = &amp;quot; resp. For any edge its follows An edge with an gap is an edge whose gap is nonis (See e.g. (Havelka, 2005) for the characterization of projectivity via properties of edges and further references.) 2 a be a node and i any edge from a. Then i ⇔ From the assumption follows ⇔ 3 i u be disjoint edges. If then u If u v then v (i) follows immediately from the and Property 2. To prove (ii), assume using (i) arrive at a contradiction. 3 Well-nestedness Kuhlmann and Nivre (2006) claim that the constraint of well-nestedness seems to approximate well dependency structures occurring in natural language. 4 dependency tree are disjoint subtrees nodes that A dependency tree is not illis It is easy to express the constraint in terms of edges—it will prove crucial in Sect. 5. 5 dependency tree T is ill-nested iff are edges disjoint subtrees T, resp., such that Direction obvious. Let the root of To suppose that Consider the edge the downward path = such that If consider the edge the upward path = such that us denote and possibly reso that To that prosimilarly as above. Obviously, edges in disjoint subtrees. 4 Level types of non-projective edges Level types of non-projective edges allow their with interesting formal properties. They were introduced by Havelka (2005), who presents them in more detail. 6 type just of a nonedge as follows j . The type of an edge is the distance of its child node and a node in its gap closest to the root (distance here means difference in levels)—for sample see Figure Note that there may be more than one node witnessing an edge’s type. The type of an edge is not bounded—it can take any integer value (depending on the height of a tree). of level type of non-projective extends naturally the original imoriginal requires however our equivalent formulation leads to shorter theorems and proofs. adopt the following convention: nodes are drawn topdown according to their increasing level, with nodes on the same level on the same horizontal line; nodes are drawn from left to right according to the total order on nodes; edges are drawn as solid lines, paths as dotted curves. We assume that no node on a path lies in the span of an edge the path crosses. 62 positive type type 0 negative type Figure 1: Sample non-projective edges plicit in (Havelka, 2005), where classes correspondto positive, zero and negative types are We now show a relationship between edges of certain types that will allow us to derive a relationship between non-projective edges and well-nestedness. 7 any non-projective edge i in a tree T with there is non-projective edge v in T with such that u and either or j Let any node in the assumption node a par- Obviously disthus from Proposition 3 we have and either or Since &gt; we have that E/ and either or Finally from we get — hence 5 Well-nestedness &amp; non-projective edges We give characterizations of well-nestedness solely in terms of properties of non-projective edges and show some applications. 5.1 Characterization using pairs of edges First we give a characterization of pairs of edges in Theorem 5 in terms of their gaps. 8 two edges in a tree T. They are in disjoint subtrees resp., and satisfy the following condition holds . Direction Root k Condition obviously implies which in turn implies that edges disjoint. From Property 2 we get that E/ and E/ hence subtrees disjoint. Let us consider the edge node Since disjoint from we have and therefore proof that is analogous. allows us to talk about pairs of edges causing ill-nestedness and so characterize well-nestedness using properties of pairs of edges. 9 say that any two non-projective a dependency tree satcondition form an pair of 10 dependency tree T is ill-nested iff it contains an ill-nested pair of edges. Follows from Theorems 5 and 8. condition for ill-nestedness The results of Section 4 and previous subsection give the following relationship between types of nonprojective edges and well-nestedness. 11 a dependency tree contains a nonproj. edge of nonpositive type, then it is ill-nested. Follows from Theorems 7 and 10. We see that types of non-projective edges and well-nestedness share a common ground; however, the statement of Theorem 11 cannot be strengthened to equivalence (it is easy to see that also two edges positive type can satisfy 5.3 Characterization using single edges Now we show that well-nestedness can be characterized in terms of properties of single non-projective only. We the ill-nested set of an edge and show that it gives the desired characterization. 12 set any edge as follows . The next proposition exposes the relationship of in to the gap of 13 any edge i The inclusion obvious. The inclusion from Proposition 3 and that edges disjoint). 63 We are ready to formulate the main result of this section, which gives as corollary a characterization of well-nestedness using properties of single edges. 14 i be an edge in a dependency tree T. The edges that form an ill-nested pair with edge i are exactly the edges in Direction Let an edge forming ill-nested pair with the edge i.e. This implies immediately gives Supposing get which in contradiction with and therefore Hence Let and without loss of genassume From the assumptions get that edges disjoint. Using Property 2, from the asget thus Hence 15 dependency tree T is ill-nested iff some non-projective edge i in T. Follows from Theorems 8 and 14. 5.4 Checking well-nestedness Our characterization of well-nestedness gives also a novel way of checking it. Here is a pseudocode of an algorithm for fully determining all ill-nested sets: for edges for edges check time complexity is obviously since the check on line 3 can be implemented so as to take time (by precompuing which can be in The bound is the same as for the reported algorithms for checking wellnestedness (Mšhl, 2006). However, the following theorem allows wellnestedness checking to be linear for projective trees, be faster for random input, and to remain 16 any ill-nested pair of edges, at least one of the edges is of nonnegative type (witnessed by an end-point of the other edge). Let Let suppose that Since any edge we have and hence If it is analogously that of nonnegative type. Havelka (2005) presents a linear algorithm for all non-projective edges of nonnegative type. Thus well-nestedness can be checked as follows: all edges of nonnegative type, and then check their ill-nested sets for non-emptiness. Comdemand for subtrees of the processed edges, we preserve worst-case quadratic complexity. 6 Conclusion We have presented new formal results linking properties of non-projective edges and their level types to well-nestedness. This work extends the current body of research on non-projective dependency structures in natural language. In particular, we offer new insights into formal properties of non-projective edges that, if possible, both provide adequate means for linguistic description and at the same time are useful as features in machine-learning approaches. work was supported by projects 1ET201120505 of the Ministry of Education of the Czech Republic and 374/2005/A-</abstract>
<affiliation confidence="0.613074">INF/MFF of Grant Agency of Charles University.</affiliation>
<title confidence="0.77671">References Havelka. 2005. Projectivity in Totally Ordered Trees: An Alternative of Projectivity and Optimal Algorithms for Detecting Non- Projective Edges and Projectivizing Totally Ordered</title>
<author confidence="0.935673">Bulletin of Mathematical Lin-</author>
<note confidence="0.524704411764706">84:13–30. Marco Kuhlmann and Joakim Nivre. 2006. Mildly Non- Dependency Structures. In of pages 507–514. Ryan McDonald, Fernando Pereira, Kiril Ribarov, and 2005. Non-Projective Dependency Parsusing Spanning Tree Algorithms. In pages 523–530. Mathias Mšhl. 2006. Drawings as models of syntactic structure: Theory and algorithms. Diploma thesis, Programming Systems Lab, UniversitŠt des Saarlandes, Saarbrficken. Joakim Nivre. 2006. Constraints on Non-Projective De- Parsing. In of pages 73–80. Neil J. A. Sloane. 2007. On-Line Encyclopedia of Integer Sequences. Published electronically at 64</note>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Jif’ Havelka</author>
</authors>
<title>Projectivity in Totally Ordered Rooted Trees: An Alternative Definition of Projectivity and Optimal Algorithms for Detecting NonProjective Edges and Projectivizing Totally Ordered Rooted Trees.</title>
<date>2005</date>
<booktitle>Prague Bulletin of Mathematical Linguistics,</booktitle>
<pages>84--13</pages>
<contexts>
<context position="1348" citStr="Havelka, 2005" startWordPosition="295" endWordPosition="296">es is Subtreei = {v ∈ V |i →∗ v}, Subtreei↔j = {v ∈ V |Parenti↔j →∗ v}, and for ancestors Anci = {v ∈ V |v →∗ i}, Anci↔j = {v ∈ V |v →∗ Parenti↔j}. To be able to talk concisely about the total order on nodes &amp;quot;, we define open and closed intervals whose endpoints need not be in a prescribed order: (i, j) = {v ∈ V | min&amp;quot;{i, j} ≺ v ≺ max&amp;quot;{i, j}} and [i, j] = {v ∈ V | min&amp;quot;{i, j} &amp;quot; v &amp;quot; max&amp;quot;{i, j}}, resp. For any edge i ↔ j we define its gap as follows Gapi↔j = {v ∈ V |v ∈ (i, j) &amp; v ∈/ Subtreei↔j}. An edge with an empty gap is projective, an edge whose gap is nonempty is non-projective. (See e.g. (Havelka, 2005) for the characterization of projectivity via properties of edges and further references.) Property 2 Let a be a node and i ↔ j any edge disjoint from a. Then i ∈ Subtreea ⇔ j ∈ Subtreea. PROOF. From the assumption i =% a =% j it follows that i, j ∈ Subtreea ⇔ Parenti↔j ∈ Subtreea. Proposition 3 Let i ↔ j, u ↔ v be disjoint edges. (i) If u,v ∈ (i, j), then u ∈ Gapi↔j ⇔ v ∈ Gapi↔j. (ii) If u ∈ Gapi↔j and v ∈/ Gapi↔j, then v ∈/ [i, j]. PROOF. (i) follows immediately from the definition of Gapi↔j and Property 2. To prove (ii), assume v ∈ (i, j) and using (i) arrive at a contradiction. 3 Well-nest</context>
<context position="3411" citStr="Havelka (2005)" startWordPosition="709" endWordPosition="710"> vk ∈ (x2,y2) and vk+1 ∈/ [x2,y2]. If r1 ∈/ [x2,y2], consider the first edge vk+1 → vk on the upward path v0 = x1,v1,...,vn = r1, n &gt; 0, such that vk ∈ (x2,y2) and vk+1 ∈/ [x2,y2]. Let us denote i1 = vk and j1 = vk+1, and possibly rename x2,y2 so that i1 ∈ (x2,y2) and x2 ∈ (i1, j1). To find i2 ↔ j2 such that i1 ∈ (i2, j2), i2 ∈ (i1, j1), proceed similarly as above. Obviously, edges i1 ↔ j1, i2 ↔ j2 are in disjoint subtrees. 4 Level types of non-projective edges Level types of non-projective edges allow their structural classification with interesting formal properties. They were introduced by Havelka (2005), who presents them in more detail. DeÞnition 6 The level type (or just type) of a nonprojective edge i ↔ j is defined as follows Typei↔j = levelChildi↔ j − minn∈Gapi↔ j leveln . The type of an edge is the distance of its child node and a node in its gap closest to the root (distance here means difference in levels)—for sample configurations see Figure 13. Note that there may be more than one node witnessing an edge’s type. The type of an edge is not bounded—it can take any integer value (depending on the height of a tree). Our definition of level type of non-projective edges extends naturally</context>
<context position="4629" citStr="Havelka, 2005" startWordPosition="930" endWordPosition="931"> original definition im2The original definition requires x1 ≺ x2 ≺ y1 ≺ y2, however our equivalent formulation leads to shorter theorems and proofs. 3We adopt the following convention: nodes are drawn topdown according to their increasing level, with nodes on the same level on the same horizontal line; nodes are drawn from left to right according to the total order on nodes; edges are drawn as solid lines, paths as dotted curves. We assume that no node on a path lies in the span of an edge the path crosses. 62 positive type type 0 negative type Figure 1: Sample non-projective edges plicit in (Havelka, 2005), where classes corresponding to positive, zero and negative types are deÞned. We now show a relationship between edges of certain types that will allow us to derive a relationship between non-projective edges and well-nestedness. Theorem 7 For any non-projective edge i H j in a dependency tree T with TypeiHj &lt; 0 (&lt; 0) there is a non-projective edge v —* u in T with TypeuHv &gt; 0 (&gt; 0) such that u E argminnEGapiHj leveln and either i E GapuHv, or j E GapuHv. PROOF. Let u be any node in argminnEGapiHj leveln. From the assumption TypeiHj &lt; 0 node u has a parent v E/ GapiHj. Obviously i H j, v —* u</context>
<context position="10569" citStr="Havelka (2005)" startWordPosition="2064" endWordPosition="2065">wever, the following theorem allows wellnestedness checking to be linear for projective trees, to be faster for random input, and to remain O(n2). Theorem 16 In any ill-nested pair of edges, at least one of the edges is of nonnegative type (witnessed by an end-point of the other edge). PROOF. Let i1 ↔ j1, i2 ↔ j2 satisfy (inp). Let us suppose that levelChildi1↔j1 ≥ levelChildi2↔j2. Since levelChildu↔v ≥ levelu for any edge u ↔ v, we have that levelChild i1↔j1 ≥ leveli2, and hence Typei1↔j1 ≥ 0. If levelChildi1↔j1 ≤ levelChildi2↔j2, it is analogously proved that i2 ↔ j2 is of nonnegative type. Havelka (2005) presents a linear algorithm for finding all non-projective edges of nonnegative type. Thus well-nestedness can be checked as follows: first find all edges of nonnegative type, and then check their ill-nested sets for non-emptiness. Computing →∗ on demand for subtrees of the processed edges, we preserve worst-case quadratic complexity. 6 Conclusion We have presented new formal results linking properties of non-projective edges and their level types to well-nestedness. This work extends the current body of research on non-projective dependency structures in natural language. In particular, we o</context>
</contexts>
<marker>Havelka, 2005</marker>
<rawString>Jif’ Havelka. 2005. Projectivity in Totally Ordered Rooted Trees: An Alternative Definition of Projectivity and Optimal Algorithms for Detecting NonProjective Edges and Projectivizing Totally Ordered Rooted Trees. Prague Bulletin of Mathematical Linguistics, 84:13–30.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Marco Kuhlmann</author>
<author>Joakim Nivre</author>
</authors>
<title>Mildly NonProjective Dependency Structures.</title>
<date>2006</date>
<booktitle>In Proceedings of COLING/ACL,</booktitle>
<pages>507--514</pages>
<contexts>
<context position="1980" citStr="Kuhlmann and Nivre (2006)" startWordPosition="422" endWordPosition="425">e characterization of projectivity via properties of edges and further references.) Property 2 Let a be a node and i ↔ j any edge disjoint from a. Then i ∈ Subtreea ⇔ j ∈ Subtreea. PROOF. From the assumption i =% a =% j it follows that i, j ∈ Subtreea ⇔ Parenti↔j ∈ Subtreea. Proposition 3 Let i ↔ j, u ↔ v be disjoint edges. (i) If u,v ∈ (i, j), then u ∈ Gapi↔j ⇔ v ∈ Gapi↔j. (ii) If u ∈ Gapi↔j and v ∈/ Gapi↔j, then v ∈/ [i, j]. PROOF. (i) follows immediately from the definition of Gapi↔j and Property 2. To prove (ii), assume v ∈ (i, j) and using (i) arrive at a contradiction. 3 Well-nestedness Kuhlmann and Nivre (2006) claim that the constraint of well-nestedness seems to approximate well dependency structures occurring in natural language. DeÞnition 4 A dependency tree T is ill-nested if there are disjoint subtrees T1, T2 of T and nodes x1,y1 ∈ T1 and x2,y2 ∈ T2 such that x1 ∈ (x2,y2) and x2 ∈ (x1,y1). A dependency tree T that is not illnested is well-nested.2 It is easy to express the constraint in terms of edges—it will prove crucial in Sect. 5. Theorem 5 A dependency tree T is ill-nested iff there are edges i1 ↔ j1, i2 ↔ j2 in disjoint subtrees T1, T2 of T, resp., such that i1 ∈ (i2, j2), i2 ∈ (i1, j1).</context>
</contexts>
<marker>Kuhlmann, Nivre, 2006</marker>
<rawString>Marco Kuhlmann and Joakim Nivre. 2006. Mildly NonProjective Dependency Structures. In Proceedings of COLING/ACL, pages 507–514.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ryan McDonald</author>
<author>Fernando Pereira</author>
<author>Kiril Ribarov</author>
<author>Jan Hajic</author>
</authors>
<title>Non-Projective Dependency Parsing using Spanning Tree Algorithms.</title>
<date>2005</date>
<booktitle>In Proceedings of HLT/EMNLP,</booktitle>
<pages>523--530</pages>
<marker>McDonald, Pereira, Ribarov, Hajic, 2005</marker>
<rawString>Ryan McDonald, Fernando Pereira, Kiril Ribarov, and Jan Hajic. 2005. Non-Projective Dependency Parsing using Spanning Tree Algorithms. In Proceedings of HLT/EMNLP, pages 523–530.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Mathias Mšhl</author>
</authors>
<title>Drawings as models of syntactic structure: Theory and algorithms.</title>
<date>2006</date>
<booktitle>Diploma thesis, Programming Systems Lab, UniversitŠt des Saarlandes, Saarbrficken.</booktitle>
<contexts>
<context position="9951" citStr="Mšhl, 2006" startWordPosition="1957" endWordPosition="1958"> non-projective edge i ↔ j in T. PROOF. Follows from Theorems 8 and 14. 5.4 Checking well-nestedness Our characterization of well-nestedness gives also a novel way of checking it. Here is a pseudocode of an algorithm for fully determining all ill-nested sets: 1: for all edges i ↔ j do 2: for all edges u ↔ v s.t. u ∈ (i, j) do 3: check u ↔ v ∈ Ini↔j Its time complexity is obviously O(n2), since the check on line 3 can be implemented so as to take constant time (by precompuing →∗, which can be done in O(n2) time). The bound is the same as for the reported algorithms for checking wellnestedness (Mšhl, 2006). However, the following theorem allows wellnestedness checking to be linear for projective trees, to be faster for random input, and to remain O(n2). Theorem 16 In any ill-nested pair of edges, at least one of the edges is of nonnegative type (witnessed by an end-point of the other edge). PROOF. Let i1 ↔ j1, i2 ↔ j2 satisfy (inp). Let us suppose that levelChildi1↔j1 ≥ levelChildi2↔j2. Since levelChildu↔v ≥ levelu for any edge u ↔ v, we have that levelChild i1↔j1 ≥ leveli2, and hence Typei1↔j1 ≥ 0. If levelChildi1↔j1 ≤ levelChildi2↔j2, it is analogously proved that i2 ↔ j2 is of nonnegative ty</context>
</contexts>
<marker>Mšhl, 2006</marker>
<rawString>Mathias Mšhl. 2006. Drawings as models of syntactic structure: Theory and algorithms. Diploma thesis, Programming Systems Lab, UniversitŠt des Saarlandes, Saarbrficken.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Joakim Nivre</author>
</authors>
<title>Constraints on Non-Projective Dependency Parsing.</title>
<date>2006</date>
<booktitle>In Proc. of EACL,</booktitle>
<pages>73--80</pages>
<contexts>
<context position="1980" citStr="Nivre (2006)" startWordPosition="424" endWordPosition="425">ation of projectivity via properties of edges and further references.) Property 2 Let a be a node and i ↔ j any edge disjoint from a. Then i ∈ Subtreea ⇔ j ∈ Subtreea. PROOF. From the assumption i =% a =% j it follows that i, j ∈ Subtreea ⇔ Parenti↔j ∈ Subtreea. Proposition 3 Let i ↔ j, u ↔ v be disjoint edges. (i) If u,v ∈ (i, j), then u ∈ Gapi↔j ⇔ v ∈ Gapi↔j. (ii) If u ∈ Gapi↔j and v ∈/ Gapi↔j, then v ∈/ [i, j]. PROOF. (i) follows immediately from the definition of Gapi↔j and Property 2. To prove (ii), assume v ∈ (i, j) and using (i) arrive at a contradiction. 3 Well-nestedness Kuhlmann and Nivre (2006) claim that the constraint of well-nestedness seems to approximate well dependency structures occurring in natural language. DeÞnition 4 A dependency tree T is ill-nested if there are disjoint subtrees T1, T2 of T and nodes x1,y1 ∈ T1 and x2,y2 ∈ T2 such that x1 ∈ (x2,y2) and x2 ∈ (x1,y1). A dependency tree T that is not illnested is well-nested.2 It is easy to express the constraint in terms of edges—it will prove crucial in Sect. 5. Theorem 5 A dependency tree T is ill-nested iff there are edges i1 ↔ j1, i2 ↔ j2 in disjoint subtrees T1, T2 of T, resp., such that i1 ∈ (i2, j2), i2 ∈ (i1, j1).</context>
</contexts>
<marker>Nivre, 2006</marker>
<rawString>Joakim Nivre. 2006. Constraints on Non-Projective Dependency Parsing. In Proc. of EACL, pages 73–80.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Neil J A Sloane</author>
</authors>
<title>On-Line Encyclopedia of Integer Sequences.</title>
<date>2007</date>
<note>Published electronically at www.research.att.com/~njas/sequences/.</note>
<marker>Sloane, 2007</marker>
<rawString>Neil J. A. Sloane. 2007. On-Line Encyclopedia of Integer Sequences. Published electronically at www.research.att.com/~njas/sequences/.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>