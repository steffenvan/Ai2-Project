<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<note confidence="0.682259555555556">
American Journal of Computational Linguistics Microfiche 75
xaTlc IRE FINITE STRING
NEWSLETTER OF THE ASSOCIATION FOR COMPUTATIONAL LINGUISTICS
VOLUME 15 - Numav 2 JUNE 1978
AMERICAN JOURNAL OF COMPUTATIONAL LINGUISTICS is published by
the Association for Computational Linguistics
SECRETARY-TREASURER Donald E Walker, SRI International,
Menlo Park, California 94025
EDITOR David G Hays, 5046 Lakeshore Road, Hamburg, New
York, 14075
ASSOCIATE EDITOR George E Heidorn, IBM Research Center,
P 0 Bot 218, Yorktown Heights, New York 10598
EDITORIAL ASSISTANT William Benzon
Copyright 1978
Association for Computational Linguistics
American Journal of Computational Linguistics
CONTENTS Vicxof iche 75: 2
THE DERIVATION OF ANSWERS FROM LOGICAL FORMS m A
</note>
<sectionHeader confidence="0.800969" genericHeader="method">
QUESTION ANSWERING SSTE.M, Fred .5 Dlmenu 3
</sectionHeader>
<note confidence="0.436151">
ONE MORE STEP TOWARD COMPUTER LEXICOMETWr,
Nicholas V Findlet and Shu-Hua Lee 43
</note>
<sectionHeader confidence="0.8487155" genericHeader="method">
COMPUTATION IN DEPARTMENTS QF LINGUISTICS R1Chald Fiit2son 02
MANIFESTO I THE PRESS AT TWIN WILLOWS 69
</sectionHeader>
<note confidence="0.7130675">
REVIEW&apos;S OF MICRO HARDWARE &amp;SOFTWARE TO BE PUBLISHED 71
PUBLISHING A..101. 73
</note>
<sectionHeader confidence="0.584757333333333" genericHeader="method">
CONFERENCES ASIS ARO HICSS \74
LINGUISTIC STRUCTURES PROCESSING Zampolli, ed 75
NATURAL LANGUAGE IN INFORMATION SCIENCE,
</sectionHeader>
<keyword confidence="0.268682">
Walker, Karlgren, and 1.(a\ edc 76
</keyword>
<sectionHeader confidence="0.8536535" genericHeader="method">
DESCRIPTION OF AJCL 77
AFIPS WASHINGTIA REPORT JUNE 78 79
</sectionHeader>
<note confidence="0.61322">
American Journal of Computational Linguistics Microfiche 75: 3
</note>
<title confidence="0.974845">
THE DERIVATID OF ANSNERS FROM LOGICAL FORMS
IN A QUESTION ANSWERING SYSTEM
</title>
<author confidence="0.85184">
FRED J DAMERAU
</author>
<affiliation confidence="0.446031">
IBM Corporation
Thomas- J Watson Research Center
Yorktown Heights, New York
</affiliation>
<sectionHeader confidence="0.937458" genericHeader="method">
ABSTRACT
</sectionHeader>
<bodyText confidence="0.98518724">
This paper describes how the process of genervting a
response given an underlying representation for an input
question is accomplished in the Transformational 2uestion
Answering (ToA) system under development at IBM Research, a
brief description of which is given.
The last formal level of representation in this system is
called a logical form. The baslc method of evaluation of
logical forms is the generate and test&amp;quot; paradigm, used, for
oufample in the LUNAR system (Woods, Kaplan and Nash-Webber,
1972), although thetimplementation must be fairly tificient
in order tot be practical on a moderate site data base. The
basic idea is to keep track of the equivalence telationships
betwlen the variables in the logical fort and associated
constants, and Use this information to derive from the data
base the extensions of the predicates contained in the
logical form. A similar proposal has been made by
Reiter(1976). The logical forms and the process by which
candidate sets are computed from these forms ,#re described
in considelable detail. We believe it should not be
necessary for a computational linguistics project to
describe operations beyond the last level of formal
representation in order Sol an outsider to understand
exactly how a system operates sufficiently well that he.can
pzedict its behavior. Although we have attempted to achieve
that, we still have a considerable way to go,.
</bodyText>
<sectionHeader confidence="0.53116" genericHeader="method">
4
</sectionHeader>
<bodyText confidence="0.999022909090909">
This paper describes how the process of generatima
response given an underlying representaion foir an input
question is accomplished in the! Transiorvational 2uestion
Answering (T2?) sy.stem under continuing deveLopment at IN
Research. T2A has been, operational in a laboratory -mode for
several years, The system ts now installed &apos;in the office of
the planning department 01 a small city where it is used to
access- the file of land use for each parcel of land in the
city, (about 10,000 parcels with 40 pieces of data for each
parcel). The sysytem is undergoin3 modifications and
improvement prior to a formal evaluation stage.
</bodyText>
<figureCaption confidence="0.689849333333333">
S.STEt• OVERV EW
A generalized flow diagram of the&apos; Tin system is given in
Figure 1. Input, from a display device or typewriter—li,ke
terminal, is fed to the preprocessor, which segments the
input character striag a.nto words and performs lexical
lookup. The process of lookup is complicated somewhat by a
</figureCaption>
<tableCaption confidence="0.384890666666667">
provision for synonym and phrase replacement. Words like
&amp;quot;car&amp;quot; and &amp;quot;automobile&amp;quot; are changed to &amp;quot;auto&amp;quot;, an&amp; strings
like &amp;quot;gas station&amp;quot; are froln into single lexical units,
</tableCaption>
<figure confidence="0.996345076923077">
PAGE 5
wok
Input LexicOn
1
IPreptocessor! &lt;
I.
1 List of lexical trees
or.
ITransformetional parson&apos; &lt;----Strinq transformations
I List of trees
&apos;Context free parser&apos; &lt;—
L
1 List of surface trees
17ransformational parsetl &lt;----Inverse transformational
grammar
I Deep sttucture(s)
&apos;Transformational parseri &lt;----Data base specific
transformational rules
I&amp;quot; Query structure(s)
[Semantic, interpreter! &lt;-----Sementic rules
J &lt;--1
1
[ Logical form(s)
1 Data base
&apos;Evaluator&apos; &lt;
Answet
</figure>
<figureCaption confidence="0.814905">
Figure 1
</figureCaption>
<figure confidence="0.608979">
Contelit free Phraze
strvicrure rules
PAGE 6
</figure>
<bodyText confidence="0.966806739130435">
The output from the lexical lookup is a list of trees,
each tree. containing pdrt of sreech inlormation, lyntactic
features and semantic features, as required A descriAtseom
of the lexical component, now obsolete in Its detail but
still valid in maln outline is given in RobinsanC1773). Tht
list of trees is input to a set of Itual trAnl,fs_triansm.s.
described in P1athf1974). These trAnsformations operate on
adjacent lexicalpitems to deal with patterns of classifiers&apos;
ordinal numbers, stranded prepolitions and the like. The
effect of this pnase is to reduce the number of surface
parses and the amount of work clone in the transformational
cycle. The resulting list of trees is input to a context
free patser, which produaes a set of surface trees, each of
which is fed to the transformational recognizer.
The tecognizer attempts to find an linAptiaing s:tructIl_ne.
for\ each surface tree. Plath(1973). Typically only one of
a set of surface trQes will result- in an underlying
Structure. This structure itself is input once again to the
transformational recognizer, using a (small) set of grammar
rules tailoTed to a speciic data base to produce a guarv
structure. Query structures are vimilar to underlying
structures in farm, but re-fleet the paxticular meanimg
constraints resulting from the format and content of a given
</bodyText>
<note confidence="0.47665425">
data base. The query structure tree is processed by a
Knuth-style semantic interpreter, Pettick (1977), producing
a logical form. A logical form can best be thought of, in
PAGE 7
</note>
<bodyText confidence="0.999680125">
our, context, as a retrieval expression. which is to. be
evaluated, producing an anamer to the English input query.
Since the major part of this paper is concerned with
processing logical forms, discussion of their specifics will
be deferred until later
The process of ansmer extraction from the data base is
accvmplished by a combinatIvn of LISP and PL/I programs,
described below, and an experimental relational data base
management system called Relational Storage System (RSS)
(Astrahan, et al. 1976). The RSs provides the capability
to generate a data base of n-ary relations, with indexes on
any field of the relation, and low-level access commands
liRe OPEN. NEXT, CLOSE. with appropriate parameters, Lc)
retrieve information from such a data base.
All the processing modules are under the control of a
driver module, which maintains comitanication with the user,
calls the processors in the correct sequence, and tests for
errors. An example of the progwssing of a question, with
tile intermediate outputs, is given in Figure 2.
In this example, the numbers 2945, 6535, 6635, 6975 are
the numbers of milliseconds .of computer time used up to the
point shown, on en IBM S/370 Model 168. The strUctures
printed are a bracketted terminal string representation of
structures which are stored and manipulated as trees by the
</bodyText>
<figure confidence="0.94040353125">
PAGE 8
what are the heights of the drug stores ?
Z945 SURFACE STRUCTURES:
(((441-I SOME) (THING X1)) BE (THE ((HEIGHT X4)
(OF (VhE ((DRUa,STORE 591) X7))))) ?.)
6535 UNDERLYING STRUCTURSS:
1. (BD IDENTICAL UTHE.(X4 (I, Bp HE/G,HT X4
&apos;(THE ((DRUG_STOSE 5.91)iX7)).BD *)i)“(Wn SOME,
CITING X1)) BD)
6635 QUERY STAUCTURES:
1. (THE (X4 (* BD HETGHT X4 (THE ((DRUG_JTORE 591.)
)01)) ED *)))
6975 LOGICAL FORM:
(setx lX4!
&apos;Eforat1east,1 &apos;)(44
&amp;quot;(setx
f(testfdt
&apos;59V
&apos;(&apos;LUC X7 &apos;1976)
) )
(testict
X4
&apos;(&amp;quot;JSTOR X44 &apos;1976)
) ) )
7995 ANSWERS:
HUMBER
STORIES
1976
70590001610 1
8010.0000710 1
8010000081t 2
90430000910 1
</figure>
<figureCaption confidence="0.868318">
Figure 2
</figureCaption>
<equation confidence="0.54338">
PAGE 9
</equation>
<bodyText confidence="0.967003888888889">
processing programs,. The nonterminal nodes pi the tree,
together with their associated complex feattires, represent
much additional infbrmation that ie not shown here. The
number 591 is a lend use code which. in the data Dose,
indicates a drug store, and the long numbers in bhe ans4er
axe the parcel identifiers, (ward-block-lot).
Feon this brief description, it should be apparent that
the T2A system, considered as a blacit box, is simllar td
many others. In particular, there is a desItnated level of
heaning representation, the logical form, which is the last
formal construct in the system. The remaining processing
necessary to derive an answer and to format it for
presentation to a user is accomplished ny an unstructured
set of computer programs. Two separate issues arise as a
resu1t4 how efficiently can the logical form be evaluated
against a real data base, and to what extent do the
processing functions further specify meaning, beyond that
carried by the logical form?
</bodyText>
<sectionHeader confidence="0.924564" genericHeader="method">
XVALUATION OF LOGICAL FORMS
</sectionHeader>
<subsectionHeader confidence="0.882609">
The basic Method of evaluation of Logical forms is the
</subsectionHeader>
<bodyText confidence="0.958782">
&amp;quot;generate and test&amp;quot; paradigm used, for example, in the LUKAR
</bodyText>
<equation confidence="0.594594">
PAGE 10
</equation>
<bodyText confidence="0.998185857142857">
system goods Kaplan and Nash-Webber, 1972). The simple
version of this paradigm, used by Wooas and implemented in
our early systems, involves checking pre-selected lists of
objects or, in tht worst case, all the objects kno;.in to the
system, to see, if they satiSfy. the query predicates. It is
computationally impractical except ±or small data bases.
Our current&apos; varlant oi this method is much more efficient.
The basic idea is to keep track of the equivalence
relationships between the vaxiables in the logical form and
associated constants, and use this infoTmation to derive the
extensions ot the predicates ,contained in the logieal form
fIam tne ciata base. A similar-proposal has been made by
Reltez(1976) We do not however, mace such extensive use of
queil transformations as Reiter outlined.
</bodyText>
<subsectionHeader confidence="0.87067">
Logical forms
</subsectionHeader>
<bodyText confidence="0.999644">
In order to describe the ev.altation process, it is
necessary to describe the logical form in somewhat more
detail, referring for a&apos;n example again to Figure 2. In the
first place, except or the set-±orming function setx, which
takes as arguments a variable name and a proposition, all
other well-formed fotmulas are composed of predicates and
their arguments. Some of the predicates are perfectly
ordinary like greaterthan. Some are quantifiers, like
formtaeast, which takes a limit argument n, an argument
</bodyText>
<equation confidence="0.5231">
PAGE 11
</equation>
<bodyText confidence="0.98932924">
which is a set, and a proposition 2, and which is true just
in case n or mor e elements of the specified set satisfy the
proposition 2. Others are special application preaicates
like parcel, which is true just in ease its single argument
is 4 parcel identifier.
The Main data base related ptedicate is named testfqi.
Referring to Figure 2, it is seen that testit has three
arguments. The first is a constant or a variabLe which 14111
be replaced by a constant befaxe evaluation, the second
argument is a list whos members determille a particular
data base value, and the third is an operator specifying the
relation which must hold between the first argument and the
data base value determined by the Second argument.
The data base can be thought of as a coilectinn 4 binary
relations, all sharing the same key. In our applica;tioh,
this is the parcel identification or: account number, by
which any piece 10f property can be identified. The list
which is the second argument of testfct consists of the
relation name and the key which identifies &apos;a value in the
relation. The key actually has two parts. The second part
is a year, now unused, although since the files in which we
are currently interested are changed on a yearly basis, we
anticipate maintaining and accessing historical data. The
first part of the key is the account number mentioned above.
In general, the second argument of testfct must be
</bodyText>
<equation confidence="0.913231">
PAGE 12
</equation>
<bodyText confidence="0.981393">
sufficient to identify a unique binary relation and value in
that relation.
If the logical form is itself a proposition the system
will answer eithet &amp;quot;yes&amp;quot; or &amp;quot;no&amp;quot;. If the logical form has a
top level setx, the system will print the members of the set
satisfying the specified proposition, perhaps along with
some identifytng information:
</bodyText>
<subsectionHeader confidence="0.91528">
Simplifications
</subsectionHeader>
<bodyText confidence="0.9940479375">
A number of simplificationm can be, and in part have been,
carried out on logi.cal forms prior to evaltation. Some
predicates, for example, are essentially empty for purposes
of evaluation, in that they always evaluate to true. As an
example, the predicate dollar, for information fields
referring to taxed, is empty of meaning because the
processor assumes that the contents of the taxes field are
always dollars. A slightly less obvious example of a
possible simplification can be seen in Figure 2. The set
argument of the foratleast predicate contains no free
variables. It is not necessary, therefore, to evaluate the
inner setx funotion for each evaluation of the ioratleast
predicate. Instead, the setx function is evaluated as soon
as the semantic Interpreter has discovered that it hag no
free variables, using the standard evaluation mechanism, and
the value, i.e., a set, is substituted ier the setx
</bodyText>
<equation confidence="0.952958">
PAGE 13
</equation>
<bodyText confidence="0.984107444444445">
expression. Our system peri.ormt simplifications of this
Rind in its normal mode (although it can also deity all
evaluations until a complete form has been built), so that
the final logical form seen by the retrieval functions
during proceSsing is usually that shown ih FiguTe 3, where
the inne. setx has been replaced by the satisfying set
viz the parcel identifiers of the set of drug stores.2
After all the applivOle simplifications have been done, tiu
resulting form is passed to he evaluation function, MIALU.
</bodyText>
<subsectionHeader confidence="0.955654">
The Pre-evaluator
</subsectionHeader>
<bodyText confidence="0.999941857142857">
It might seem that since the system has been written in
LISP, it would only be necessary to define the appropriate
functions and then call the regular tISF evaluator, Instead
of a special evaluator like EVALU. While this would be
possible, the, aifficulty with such an approach can readily
bc seen by considering the embedded setx in Figure 2. The
desired set of X7s is that set of parcel identifiers fo
which the associated land use code is &amp;quot;591&amp;quot;. tes_tfct is a
predicate which is true for the appropriate X7s, but what is
the candidate set of X7s which should be tested? At worst,
the system might consider the net of all objects it knows
about. As a better choice, the systey could infer from the
syntax of testfct that the candidates are all members of the
set of parcel identifiers, but still there are almost 10,000
</bodyText>
<figure confidence="0.979282655172414">
PAGE 14
what are the heignts 0± tne arug stores y
2930 SURFACE MUCTURES:
1. (((WN SUM) (THING X1)) BE (TUE ((HEIGHT X4)
(OF (THE ((DRUG STORE 591) Xr7)T))) ?)
6500 UNDERLY±NG STRUCTURES:.
1. CBM IZENTICAL (THE (X4 (* MY HEIGHT X4 (THE
CCDRUG_STORE 591) X7)) BD i))) ((144,SOME)
(THIN )1)) MD)
6599 &apos;QUERY STRUCTURES:
1 (THE (-X4 (* BD HEIGHT X4 (THE &apos;ADRUG_STORE 591)
X7)) BD *)))
11&apos;76 LOGICAL FORM:
(setx 1X4
&apos;iforatleast 1 &apos;X44
(90430000910 8010000.0811 80100000710
70590001610)
(testfct
X4
(&apos;JSTOR X44 1976)
&apos;= ) ) )
7385 ANSWERS:
NUMBER
STORI-ES
1976
70590001610 1
80100000710 1
80100000811
90430000910 1
</figure>
<figureCaption confidence="0.829701">
Figure 3
</figureCaption>
<bodyText confidence="0.86610075">
molt
vi those A much better approach is to attempt to compute
the extension of those predicates for which the variable
being sought is an argunlent Again referring to Figure 2, a
</bodyText>
<equation confidence="0.414364">
PAGE 15
</equation>
<bodyText confidence="0.967812346153846">
reasonable set in fact the pertect set) of candidates for
X7 can 1.7e found by. Looking in thc data base for that set of
identifiers for which the land use code is 591 If the data
base is properly organized, such a search can be very tast
Not all predicates are so simple however. The remainder of
this section will describe in some detail hom candidate sets
for more complicated predicates are *rived at. Once
candidate sets have been compute &amp; the EVALU function can
invoke the LISP evaluatom (Ili the logical form. The
alternative of incLuding a candidate generator in the setx
program and all the T)dtential top level predicates and then
applying the LISP EVAL function directly seems much less
attractive.
As a preliminary, notice that we need only insure that
candidate sets have been established fiSr all the setx
variables in a logical form. This is so because, while each
quantifier has an associated variable, the domain of that
quantifier is either given explicitly as a llst of
constants, or implicitly by a.setx expression. Secondly,
since the object of pre-evaluation is merely to find
efficient, not nedesr-tily nptimal, candidate sets for the
setx variables, we need not keep track of the structure of a
complex predicate. As an example, consider Figure 4, which
is the logical form foir the question,
&amp;quot;What drug stores are located in ward 2?&amp;quot;
The pr4dicate of the setx is &amp;quot;and&amp;quot;, but for purposes o2
</bodyText>
<figure confidence="0.974013818181818">
PAGE 16
(setx &apos;X2
&apos;(and
(testfct
&apos;591
I(TLUC X2 &apos;1976)
)
(testfct
wz
&apos;0WARD X2 &apos;1976)
• = ) )
</figure>
<figureCaption confidence="0.952906">
Figure 4
</figureCaption>
<bodyText confidence="0.908537133333333">
determining a candidate set we can consider each term of the
&amp;quot;and&amp;quot; individually. Evaluation of the form with a given
candidate set will ensure that a particular member
satisfies both terms of the &amp;quot;and&amp;quot;.
Operation of the pre-evaluation function. Pre-evaluation
is accomplished by a functioh EVALUA, which takes a logical
form, i.e., a setx expression or a proposition as its
argument. It determines the type of form with which it is
dealing and calls an appropriate specialist routihe If as
in the case ef the &amp;quot;and&amp;quot; of Figure 4, the logical form being
considered contains more than ohe component form, EVALUA
calls itsif recursively. Consequently, pre-evaluAtion is a
depth-first, left-to-rioht process. The function always
returns nil, all work being acccomplishcd by changes to
global variables. Among these are a LISP variable which
</bodyText>
<equation confidence="0.4515">
PAGE 17
</equation>
<bodyText confidence="0.942433545454545">
contains a list of all setx variables in the logical form, a
LISP variable which lists each query variable for which a
value has been found, and its value, and a LISP variable
which keeps track ai the equality relationships which have
been discovered between query variables for which a value is
yet to be found.
Operation of the algorithm can be better understood bv
considering somewhat more complicated examples than those
seen previously. When EVALUA is given the logical form o&apos;f
What pwrcels have an area exceeding 550000
square feet ?
</bodyText>
<sectionHeader confidence="0.38397" genericHeader="method">
7524 LOGICAL FORM:
</sectionHeader>
<figure confidence="0.9326165">
Csetx &apos;X2
/(and
(foratleast 1 wX39
(setx 1X5
&apos;(ttstfct
X5
&apos;(&apos;PARAREA X2 &apos;1176)
&apos;= ) )
&apos;(greaterthan X39 &apos;550000) )
(parcel X2) ) )
</figure>
<figureCaption confidence="0.9049102">
Figure 5
Figure 5, it calls the setx specialist, which adds X2 to the
(null) list of set variables and the (null) list of query
vatiables, and calls EVALUA with the associated setx
predicate, rand&amp;quot;. As mentioned&apos;, this simply results in two
</figureCaption>
<equation confidence="0.368578">
PAGE 13
</equation>
<bodyText confidence="0.995653307692308">
calls to EVALUA, the first of which causes the quantifier
specialist to be invoked. (The second call, when made, will
not cause any change to the global lists of candidate values
for variables, since a candidate set of all parcel
identifiers is not useLul for purposes of retrieval.) X39
is added to the list of query variables, and the domain
argument of the quantifier is inspected. When this is seen
to. be an instance of setx rather than a list of constants,
two actions are taken. Notice that whatever the domain, of
X39 it, it is a subset (perhaps not a proper subsets) of the
domain of X5, i.e., the candidate set fox X5 must include at
least all of the elements of X39. Further, any restrictions
which can be imposed on X39 can also le imposed on X5, since
the proposition associated with thd quantifier is the one to
be satisfied, and any candidate not meeting this criterion
would be supertkuow. TheLefore, we can 1) enter into the
list of variable relationships the information that for
purposes of the pre-evaluator, X39 and X5 are equivalen and
2.) call EVALUA once more with the satx associated with X5 as
an argument.
X5 is added to the last of set variables, and
reinvocation of EVALUA with the ,setx predicate causes a call
to the- specialist for testfct. Since there are two variables
in testfct, X5 and X2, for which values are unknown, a&apos; call
to the data base cannot yet be made. The instance of
testfct is placed on a list of pending lata base calls,
</bodyText>
<equation confidence="0.478643">
PAGE 19
</equation>
<bodyText confidence="0.99958148">
preceded by the variables which require values. (Each time a
value for a variable is found) that list is inspected, and
any data base calls which can then be made are executed.)
Return is made to the quantifier specialist, which calls
EVALUA with the predicate over whose arguments
quantification is ,made, viz., greaterthan.
The specialist for numeric predicates, finding that one
argument is a variable and the other a constamt, causes a
tthange in the variable list to show that X39 and
consequently X5 are greater than 550,000. A value like
&amp;quot;&gt;550,000&amp;quot; can be used by the data base component to narrow
its search just as well as a constant ox list of constants,
and is therefore acceptable as the value of a candidate
list. These changes to the variable lists cause the list of
pending data base calls to be inspected and, since only one
variable is now unknown in the stacked testfct, a call to
the data base is made for thoss parcels with an area greater
than 550,000 square feet.
The specialist for testfct instructs the data base search
routine to return as a value a list corresponding to the
remaining varia,ble in the form, i.e., X2. In the present
example, that is a list of parcel numbers, viz., those
parcels which have an area exceeding 550,000 square feet.
This liSt is then assigned as the value of the candidate set
for X2.
</bodyText>
<equation confidence="0.425678">
PAGE 20
</equation>
<bodyText confidence="0.958585692307692">
The stack of recursive calls to EVALUA will now unwind,
until a return is made to the eValuation function EVALU.
This function determines that candidate lists for all the
setx variables have been found, and qreates a hew list of
variable-candidate vet pairs for use by the setx function
itself. Finally, EVALP an call the LISP evaluator, with
the original logical form as an argument.
The case of negatives., The predicate &amp;quot;not&amp;quot;, denoted in
our system by not to distinguish it from the LISP not,
presents special problefis for the kind of system outlined
above. A simple example of the difficulty can be seeh ift
What drug stores are not in traffic
zone 6 ?
</bodyText>
<sectionHeader confidence="0.354254" genericHeader="method">
5651 LOGICAL FORM:
</sectionHeader>
<figure confidence="0.957483">
(setx &apos;X3
1(and
(not*
(testfct
&apos;6
&apos;CITRAFZ xa &apos;1976)
&apos;=1 ) )
4testfct
&apos;591
&apos;(&apos;LUC X3 &apos;1976)
T= ) ) )
Fiaure 6
</figure>
<figureCaption confidence="0.994626">
Figure 6, which corresponds to the question
</figureCaption>
<bodyText confidence="0.377487">
&amp;quot;What drug stores are not located in traffic zone 6?&amp;quot;
</bodyText>
<equation confidence="0.447136">
PAGE 21
</equation>
<bodyText confidence="0.995055923076923">
and variants thereof. &apos;When the testfct specialist is given
the first half of the and, in this form, along with
information that there is a dominatIng not*, it could in
principle generate a data base c.all, since there is only one
unassigned var,iable. The effect wolld be the retrieval of
all parcel iftntifiers of parcels nbt located in traffic
zone 6. This is a substantial fraction of the data&apos; base, and
would require inordinate amounts of time and storage space
to handle Notice that the other half of the and will also
provide a candidate list for the variable X,3, presumably
much smaller in size. It appears to be the case, from our
so far limited experience, that questions containing only 4
single negated search clause hardly ever occur. The
evaluator therefore puts a testfct call of this type on the
stack mentioned earlier, indexeft by the variable(s)
corresponding to the parcel identifier. When the second
half of the and of Figure 6 is processed, and a value found
for X3, eke deferred testfct will be unstacked, xesurting in
a data base call, and causing a retrieval based on that list
of identifiers rather than on the negated value. This data
base search is necessary, since we must find the traffic
zones for the parcels contained in the candidate list.
This example is also an illustration ot why, as was
mentioned above, the logical form as a whole must in general
be evaluated by the LISP evaluator. In this case, the
candidate set for X3 derived from the second clause of the
</bodyText>
<figure confidence="0.625634111111111">
PAGE 22
aild is a superset of the answer set whicn can only be
derived by evaluating the whole canluffction. Some
efficiencies could doubtless Ixe g.ained eby skipping
evaluation in those cases where lt is unnec&apos;essaty, hut that
is purely an implementation decision
The riot* of Figure 7 presents a different kind o problem
Row many banks have a height not exceeding
S floors ?
7966 LOGICAY FN:
Csetx &apos;XI
s
&apos;(quantity X1
(setx &apos;X3
&apos;(and
(not*
fforatleast 1 vX46
(sets &apos;X6
T(testict
X6
&apos;(&apos;JSTOR X3 &apos;1976)
&apos;= )
l(greaterthan X45 ) )
(testfct
611 .
&apos;(&apos;LUC X3 &apos;1976)
) ) ) ) )
</figure>
<figureCaption confidence="0.900777">
FiguKe 7
</figureCaption>
<bodyText confidence="0.98615925">
from the previous example. Firstly, notinA- that the
negative must be passed inside the quanti,fier since the
alternative of linding all buildings greater than 5 stories
in height and then getting the complement set with respect
</bodyText>
<equation confidence="0.757952">
PE 23
</equation>
<bodyText confidence="0.99979508">
to all buildingp is extremely unattractive computationally.
in the second place, a search qualifier of &amp;quot;&lt;= 5&amp;quot; does not
intuitively seem to be much worse than &amp;quot;› 5&amp;quot;, at least in
the absence of aata base distribUtiOnal statistics. One
might, therefore, generate a search with such a qualifier.
Our present system dots this, although experience thay show
that all instances- of testet dominated by not should be
deierred, as are the cases 0±&amp;quot;-&apos;=&amp;quot;p for efficiency reasons.
Other specialists Most of the important specialist
routines in the pre-tevaluator have already been mentioned.
There are a few others which should be noted. One is a
generator function which, giv.en a predicate, will produce
its extension ,from a stored lists. This feature was heavil
used in our early system, which had a small database, but
is currently hardly used at all, though it remains
availdble. In principle, one could, given a predicate liWe
&amp;quot;SCHOOL(X)&amp;quot;, generate a list of schools. In the preselt
apPlioation, this would not be useful, but might in some
other. The sole uses at present are a generator for the
predicate RANK, far which a list of numbers from 1 to 100 is
produced, and for the predicate YEAR, which produces a list
0± the numbers 1960 to 1985.
The proposition &amp;quot;(QUANTITY x s)&amp;quot; is true if x .is equal ko
the cardinality of the set. sz The associated specialist hfas
the obvious functiomof determining x when s is an inStanice
</bodyText>
<equation confidence="0.861652">
PAGE 24
</equation>
<bodyText confidence="0.98677016">
of setx.
Equality between variables can be inferred where the
domain of a quantified variable is aiven by an instance of
setx, as was illustrated above. Certain predicates also
allow this inference to be made. It is clear that
predicates like 41EiltAL&amp;quot;, &amp;quot;SAMEREF&amp;quot;&apos;, (for &amp;quot;same reference&amp;quot;),*
and &amp;quot;IDENTIOAL&amp;quot; should belong to this class. Since
variables can only refer to individuals, the predicate
&amp;quot;MEMBER&amp;quot; also is in this clAss, e.g., given (MEMBtR X3 (SeTX
)), a candidate set for X3 can be derived by evaluating
the setx expression.
Furtherfefficiencv considerations. It has already been
noted that generation from instances of testfct with an
operator of &amp;quot;-=&amp;quot; are deferred until enough information is
available to execute the query using a list of parcel
identifiers. Some other steps have also been taken to
reduce data base access time and subsequent evaluation time
For one thing, tha semantic interpreter has a preferred
ordering fox instances of the predicate testfct. For
example, the relation 4WARD&amp;quot; divides the pareels of the city
into 6 classes, while the relation &amp;quot;LUC&amp;quot; (Land Use Code)
divides the parcels into several hundred classes. If there
is no intrinsic reason for ordering the instances of teskfct
differently, the one with &amp;quot;LUC&amp;quot; will occur earlier in the
logical form, (cf. Figure 4). The pre-evaluation specialist
</bodyText>
<equation confidence="0.54161">
PAGE 25
</equation>
<bodyText confidence="0.9945582">
for testfct makes use of this ordering in two ways. 12 a
Variable has been assigned a list of identifiers containing
fewer members than some threshold x, (x is currently slit to
25, but can easily be changed), then a retrieval will always
be made using the list of identifFers rather than by a
constant compared to data base values. In Figure 4, the
second call to the testfct specialist will look up the ward
of the lour drug stores instead of finding the hundreds of
parcels in ward 2. In some instances, particularly for
relations like Land Use Cole, this may result in mor&amp; data
base accbsses than retrieving a new set of keys depending on
value, but the improwement cannot be larre. In many other
instances, there is a big reduction in accesses.
If the caRdidate set is larger than.25, retrieval will be
made using the constant, but the length of the current
candidate list is used to limit the number of accesses.
Thus, if thd current* candidate list is 50, the data base
access program will terminate if it finds more than 50
identifiers with the value being used. A re-access is then
made using the list of identifiers. Again, this may result
ift.inefficiency in some cases where searches are ended jUst
before normal termination, but it does provide a guarantee
against excessively long retrievals.
Any number oi other efficiency measures could be adopted,
and more may be necessary than we now have. For the moment,
</bodyText>
<equation confidence="0.583345">
PAGE 26
</equation>
<bodyText confidence="0.993472952380953">
these seem to provide acceptable retrieval times.
The Evialuaton
For the most part, evaluation of logical forms is quite
straightforward. Hidden semantic effects are discussed in
the next section; here we are mainly concerned with
computation.
Each instance of setx searchs the list of
variable-candidate set pairs to find the candidate set
associated with its own variable and substitutes the members
of the set for the variable one by one into its associated
predicate. Those members of the candidate set for which the
predicate evaluates to true are Placed in the solution set.
Operation of the quantifier predicates is similar to that of
setx, except that, as in Figure 5, it may be necessary to
evaluate an instance of setx to find the domain of the
quantification variable..
Evaluation of the ether predicates consists simply of
applying a corresponding LISP function to the arguments.
Sometimes the final logical form to be evaluated bears no
obvious relation to the input question, as in Figure 8. The
usual reason is that a large amouy of evaluation was done
</bodyText>
<figure confidence="0.4893236">
PAGE 27
Are there more than 25 parcels in the Carhart
neighborhood ?
36229 LOGICAL FORM:
(greatexthah &apos;176 &apos;25)
</figure>
<figureCaption confidence="0.870412">
Figure 8
</figureCaption>
<bodyText confidence="0.719722">
during interpretation, because form contained no fret
variables. The tuil logical form corresponding to Figure 8
</bodyText>
<sectionHeader confidence="0.3841925" genericHeader="method">
Are thPre more than 25 parcels in the Carhart neighborhood.?
15986 LaGICAL FORM:
</sectionHeader>
<figure confidence="0.954267916666667">
(forall &apos;X115
(setx &apos;X38
&apos;Cquantirty
X38
(setx `X34
&apos;(and
(testfct
9
(&apos;NEIGH X34 &apos;1976)
T= )
(parcel X34) ) ) ) )
(greaterthan X115 &apos;25) )
</figure>
<figureCaption confidence="0.993926">
Figure 9
</figureCaption>
<bodyText confidence="0.806296">
is,-given in Figure 9.
</bodyText>
<equation confidence="0.452891">
PAGE 28
</equation>
<bodyText confidence="0.998516761904762">
The evaluatian of the predicate testict is not as obVious
as that of the others One of the design goals in the
project has been to make it relatiVely easy to move from one
data base to another. As part of that effdrt, we have
attempted to make the LISP programs, as contrasted td the
PL/I programs, insensitive to the structure of the datu
base. Our approach to tlais has been to define a list
strticture, essentiAlly nested binary relatont, into which
the real data structure is mapped. Restructuring is
accomplished by the PL/I program which serves as the LISP
RSS interface. At the same time, as the PL/I program returns
values to the test.fct specialist during the pre-evaluation
phase, it formatS the corresponding data base items into the
standard structure and writes them onto a disk file, in
effect creating a sub-data base for the particular query.
Only the sub-data base is used during evaluation of logical
forms, to find values corresponding to keys in the instances
of testfat. In addition to isolating the LISP programs from
the real data structure, this tactic makes it unnecessary
for any programs called by the evaluator to re-acc-ess the
full data base, with a consequent efficiency gain.
</bodyText>
<subsectionHeader confidence="0.861013">
Creation of the stahdard LISP data, Vase into which the
</subsectionHeader>
<bodyText confidence="0.99607675">
real data is translated hag meant that the set of ISP
functions has undergone the least modification in our chanTe
of data base from business statistics to planning data.
Except for improvements made to increase the efficiency of
</bodyText>
<equation confidence="0.582895">
PAGE 29
</equation>
<bodyText confidence="0.9965815">
programs, these q 2outines axe almost the same as they were
befoxe.
</bodyText>
<sectionHeader confidence="0.897876" genericHeader="method">
SEMANTIC EFFECTS 0: EVALUATION
</sectionHeader>
<bodyText confidence="0.99078115">
In principle the processes which will bw used to compute
the answer to a query should be obvious at the level of
ether the query struciure or the logical form. We have
not, however, been zlompletely successful in accomplishing
this. In some cases, we can see how it might be done and
have not gotten around to doing it because of more urgent
concerns. In other cases, we can see how to diz it, but not
how to do it efficiently. In a few cases, it is not clear
what fo do.
Approximation. Consider the senIence and corresponding
logical form shown in Figure JO. The precise system meaning
of &amp;quot;about&amp;quot; is clearly hidden Ln the program coxrespondIng to
the operator APPROX. In the present implementation, APPPDX
of x and y is true if:
1) wnen y&lt;10, -x&gt;y-2 and x&lt;y+2,
2) when 10&lt;y&lt;40, x&gt;y-3 and *x&lt;y+3,
3) when y&gt;=41, x&gt;y-.05y and x&lt;y+.05y.
I.e., b and 8 are approximately equal to 7, 14 aild 18 are
approximately equal to 16, and 951 and 1049 are
approximateli, equal to 1000. Whether -Ellis de.inition us
</bodyText>
<figure confidence="0.988953058823529">
PAGE 30
What parcels are asse-ssed at about $ 1000000 ?
6168 LOGICAL FORM:
Csetx &apos;X2
(and
(testfct
&apos;101)0000
&apos;(&apos;VNCIT X2 &apos;1976)
&apos;APPRDX )
(parcel X2) ) )
6373 ANSWERS:
ASSESSMENT-
1976 977,750
70596,002600 1,000,000
70430000609 1,033,425
70400000600 j 955,900
10310000602
</figure>
<figureCaption confidence="0.985136">
Figure 10
</figureCaption>
<bodyText confidence="0.9391282">
satisfactory or not clearly depenAs on a variety of
contextual factors. should also be clear that the
semantic interpreter could produce a logical form in which
this meaning was expressed directly. We have chosen to
express the meaning in our processing programs primarily for
convenience, ie. it was easiest to do it in this way, and
there was no obvious reason to do it elsewhere.
A similar hut slightly different en.umple is shown in
Figure 11, where the output rather than the input is to be
an approximation to the true value. In this inttance, a
</bodyText>
<figure confidence="0.958894125">
function called FUZZUP is applied to a data base value to
PAGE 11
About how many square feet do the, drug
stores have ?
7227 LOGICAL FORM:
Csgtx &apos;X4
&apos;(foratleast 1 &apos;X52 &amp;quot;(18570 24814 8440
5465) &apos;(approx X52 X4)) )
7109 ANSWERS:
PARCEL
AREA-SQ_FT
1976 19,000
70590001614 25,000
80100000714 B,400
80100000814 5,500
9043000&apos;0914
</figure>
<figureCaption confidence="0.99755">
Figure 11-
</figureCaption>
<bodyText confidence="0.976498">
find that number with the maximum number of trailing zeros
which. satisfies the APPROX relation. The fuzzed value
rather than the true value becomes the output.
A mere subtle case is illustrated by rigure 12. It seems
clear that what is really wanted. are -Ellose parcels with an
area of a million square feet or more, rather than exactly
1,-000,000 square feet. If the latter result is wanted, the
question is better phrased &amp;quot;exactly 1,000,000w, (and must be
phrased in this or a similar way in our system.) On the
other hand, a value like 1,000,205 seems to imply that exact
equality is wanted. This intuition is captured in our system
</bodyText>
<figure confidence="0.794492785714286">
PAGE 32
what parcels have an area of
1,000,000 square feet?
8416 LOGICAL FORM:*
(setx &apos;X2
&apos;(and
(foratleast 1 &apos;X45
(tetx &apos;X5
i(tas-tfct
XS
&apos;PPARAREA.X2 &apos;1976)
Tr; ) )
&apos;(equal X45.&apos;1000000) )
(parcel X2) ) )
8789 ANSWERS:
1: 79-880000900
24 7079_0000100
3: 71790000100
9 •
22: 80300000101
MORE PARTICULAhS DESIRED?
YES OR MO?
yes
EXPLANATIONS TO THE ANSWERS:
FOR 70880000900 MORE - 13590410
FOR 70790000100 MORE - 5977500
FOR 70790000100 MORE - 5583085
FOR 80300000101 ALMOST.- 958320
</figure>
<figureCaption confidence="0.667567">
Fig-ure 12
</figureCaption>
<bodyText confidence="0.999880833333333">
by having the testfct predicate inspect its numeric
arguments with a function called ROUNDMM, which is true if
an argument is a round number, defined in our systam to be a
number greater than 99 in which at least the rightmost half
crf its digits are 0. In the case-of round numbers, it seems
reaSZnable to give as an answer the identifier of a parcel
</bodyText>
<note confidence="0.329616">
PAGE 33
</note>
<bodyText confidence="0.9142857">
whose area is only slightly less than 1,000,000 squaie feet,
as well as greater.. In our implementation, we use the same
lower limit as for APPROX, but this may be too low. In
order to insure that the answer is correctly understood by
the user, the system saves the exact values retrieved and
displays them on request, as shown in Figurev,12.
tqualitv of character values. A problem analagous to that
of nuterical approximations occurs also in comparing
character string values. Consider the question and answer
pair shown in Fisure 13. The contents of the OWNER field
</bodyText>
<table confidence="0.902751090909091">
4.■
What parcels does Shell-own ?
4244 LOGICAL FORM:
(setx &apos;X2
&apos;(and
(testfct
&apos;SHELL
&apos;(&apos;OWNER X2 &apos;1976)
)
(parcel X2) ),
4432 ANSWERS:
</table>
<figure confidence="0.49948075">
OWNER
1976
70600009501 SHELL OIL COMPANY
80220003300 SHELL OIL CO
</figure>
<figureCaption confidence="0.834831">
Figure 13
</figureCaption>
<bodyText confidence="0.804887">
have not been stanAardi_zed, so that parcels could be owned
</bodyText>
<equation confidence="0.653109">
PAGE 34
</equation>
<bodyText confidence="0.958146125">
by &amp;quot;Shell Oil&amp;quot;, &amp;quot;Shbll Oil Co.&amp;quot;, etc. Fortunately, for names
of persons&apos;, last names are listed first, so tha;t the
strategy of assuming equality if the input argument and the
field value match up to a comma or a blank is generally
successful. Problems do arise; for example, properties
belong both to &amp;quot;The City of ...&amp;quot; and &amp;quot;City of ...&amp;quot;, where
the left match fails to find all the relevant data items.
The opposite situation, i.e., aver-generalization, can of
</bodyText>
<table confidence="0.846396928571429">
what parcels does Gluck own
4525 LOGICAL FORM:
(setx &apos;X2
&apos;(and
(testfct
&apos;GLUCK
&apos;(&apos;OWNER X2 &apos;1976)
I= )
(parcel X2) ) )
4742 ANSWERS:
OWNER
1976
90400000100 GLUCK, DE &amp; ORS
90410000900 GLUCK, CP
</table>
<figureCaption confidence="0.765875">
Figure 14
</figureCaption>
<subsectionHeader confidence="0.579848">
am%
</subsectionHeader>
<bodyText confidence="0.98062625">
course also occur, cf. Figure 14. Tn any event, the
decision as to what constitutes sameness of reference is
buried in computer code in this instance in the PM/I
program as well as in the LISP definition Df the function
</bodyText>
<note confidence="0.447956">
PAGE 35
</note>
<bodyText confidence="0.97197447368421">
SAMEREF.
The extensional definition of most
predicates can be derived from the data base. A few
predicates are defined by the syRtem code. Examples are RANK
and, YEAR. u.rhidh as mentioned above have associated
generators An additional example is LASTYEAR which is
defined tc be the previous year. Many other definitions of
this Rind have been eliminatell in the current version df the
system.
Answers. It is not always obvious what constitutes the
answer to A question. Consider the example in Figure 15.
Both the English question in its literal reading and the
logical form would seem to imply that the question would be
answered by presenting only the numbers in the right hand
column of the table which is actualiy printed as an answer.
Yet it ls quite clear that a simple list would generally be
useless without the parcel identifiers printed on the left,
and indeed that identification would be expected by the
pecson entering such a question. The example of Figute 16
</bodyText>
<table confidence="0.785244894736842">
PAGE 36
what is the gross floor area of the drug stores ?
7245 LOTICAL FORM:
setx &apos;X4 80100000710
(foratleast 1 &apos;)44
(904300001.910 80100000811
70590001610)
(testfct
X4
&apos;(&apos;PGFAREA X44 &apos;1976)
) ) )
7465 ANSWERS:
GROUND-FLOOR
AREA-S2_FT
1976
70590001610 7.078
80100000710 10&apos;,125
80100000811 6,500
90430000910 1,800
</table>
<figureCaption confidence="0.859057">
Figure 15
</figureCaption>
<bodyText confidence="0.7042261">
is less clear. An enumeration of the three ward6 in which
the four drug stores were located might have been a
sufficient answer. The answer given would be correct for
&amp;quot;In khat ward is each drug store located?&amp;quot;
Moreover, given the question
&amp;quot;What are the wards which have drug stores?&amp;quot;
it is clear tbat only a list of waxds should he the output,
and given
&amp;quot;What is the combined floor area ot tile drug stores?&amp;quot;
only a single number representing tne total is the desired
</bodyText>
<figure confidence="0.778120333333333">
PAGE 37
In what wards are the drug stores located ?
9,403 LOGICAL FORM:
(setx &apos;X3
&apos;(foratleast 1 &apos;X64
&apos;(90430000910 80100000811 8010000.9710
70590.001610)
e(testfct
X3
&apos;(&apos;WARD X64 &apos;1976)
&apos;= ) ) )
9597 ANSWERS:
WARD
1976
70590.001610 2
80100000710 3
80100000811 3
90430000910 5
</figure>
<figureCaption confidence="0.995768">
Figure 16
</figureCaption>
<bodyText confidence="0.997298636363636">
answer. (Our system does not as yt answer this question or
its analogues, tlthougth this is planned for later in the
Yeax.) Since the ambiguity exhibited by the questjon of
Figure 14 is so pervasive in- an application of this kind, we
have chosen to present a -maximally general answer, including
identifications, when me are unable to resolve the ambiguity
directly. An exchange with the user could be devised to
elicit the information for resolution, but would apidly
becOme tedious for questions of this type. . For yes/no
questions, and for questions in which there is only one
object in the answer set, thjs problem naturally does not
</bodyText>
<note confidence="0.372181">
PAGE 3-8
arise, and the appropriate answer Is eas.ily produced.,
</note>
<sectionHeader confidence="0.537156" genericHeader="method">
CQNCLUStOXS
</sectionHeader>
<bodyText confidence="0.995864681818182">
We have not yet concerned ourselves with adding an
English response generatDr to the T2A system. In the
applications envisioned at present, such a capability does
n6t seem to be critical. We are able to manage with short
answers from the data base and with canned information and
error messages. In spite of this omission, it should also
be apparent that our computational component has a
considerable amount of lingukstic knowledge embedded in it,
more than we would like. Whether it is possible to achieve
a level ef formal representation which would make this
unnecessary is still unclear. Moreover, even if it were
possible, it is not clear whether such a solution would be
efficient enough, or even if it would be more perspicuous
than the current system We intena to proceed as far as we
are able in this direction, out of conviction that
practically useful systems must be easily adaptable to new
applications, and that such adaptation is much More
difficult when computer code, even high—level computer code,
must be changed, rather than tables. This is not to imply
that we regard modification of a table whose size is on the
order of a grammar as trivial; quite, the contrary.
Monetheless, we believe it is easier to change.a gramma&apos; or
</bodyText>
<equation confidence="0.480304">
PAGE 39
</equation>
<bodyText confidence="0.8827435">
a semantic interpreter expressed in table form than it is to
change a Special parser or a special interpreter. In
essence, we believe it should not be necessary for a
computational linguistics project to describe operations
beyond the last level of fcirmal representation in order for
an outsider to Inderstanu egactly how &apos;a system operates.
</bodyText>
<equation confidence="0.1678125">
FAGE 40
F0-4TNpTES
</equation>
<bodyText confidence="0.9823139375">
This system was formerly called REPUEST.
The form of Figu.re 3 is, in fact, subject to Another
syntactic transformation prior to execution. Normally,
foratleast needs to be executed once for each potential
value of the getx variable. However, in the case where the
quantificational range of foratleast 1 is a constant,
repeated evaluation of thd quantifier is quite
inefficient. Instead, a special retrieval function called
MAPFIELA, which can accept a listiof arguments, replaces:a
forms like those of Figure 3. In thLs example the
replacement taXes the form
( MAPFIELD &apos;x77 &apos;1/47STOR &apos;(5043.., ...00) &apos;1976
Although-this transformaiion arises quite 0:E:ten in practice,
it is sufficiently non-general that we have not augmented
our inventory of logical forms by including MAPFIELD.
Instead, we look on it as an implementation measure only.
</bodyText>
<note confidence="0.706659">
PAGE 41
</note>
<sectionHeader confidence="0.970234" genericHeader="method">
References
</sectionHeader>
<reference confidence="0.983089714285714">
Astrahan, M.M.; Blascien, M.W.; ChamberLin, D.D.; Eswaran,
m.p.; Gray, J.H.; Griffiths, P.P.; King, W.F.; Lone, R.A.;
McJones, J.; Mehl, J.W.; Putzolu, G.R.; Traiger, I.L.; Wade,
B.W., Watson, V.(1976). System R: Relat4.onal Approach to
Database Management. ACM Transactions on Database Systems,
Vol. 1, No. 21 June, 1976, pp. 97-137.
Petrick Stanley R.(1977). Semantic Interpretation in the
Request System: In in Cbmputational and Mathematical
Lingustics, Proceedings of the Internamtional Conference on
Computational Linguistics, Pisa, 27/VIII-1/IX 1973, PP.
585-610.
Plath, Warren J.(1973). Transtormational Gramm&apos;ar and
Transformational Parsing &apos;in the Request System. IBM Research
Report RC 4396. Thomas J. Watson Research Center, Yorktown
Heights, N.Y.
Plath, Warren 7.(1974). String Transiormatione in the
REQUEST System American Journal of Computational
Linguistics, Microfiche 8.
Reiter, Ragmond(1976). 2uezy Optimization for
Question-Answering Systems. In: COLING 76, Proceedings.
PAGE 42
Robinson, Jane J.(1973). An Inverse Transformational
LexiCon. In Natural Language Processing. Randall Austin, ed.
AlgorithMics Press, Inc., New York, N.Y., 1973 pp. 43-60.
Woods, W.A.; Kaplan, R.M.; Kash-Webber, B.(1972). The Lunar
Sciences Natural Language Information System! Final Rep9rt.
BBK Report No. 2.378. Bolt Beranek and Newman, Inc.,
Cambridge, Massachusetts. June 15, 1972.
</reference>
<note confidence="0.6572635">
American Journal of Computational Linguistics Microfiche 75: 43
ONE MORE STEP TOWARD COMPUTER LEXICOMETPY
</note>
<author confidence="0.540682">
NICHOLAS V. FINDLER AND- SHLHWA LEE
</author>
<affiliation confidence="0.676381">
Department of Computer Scince
State University of New York at Buffalo
</affiliation>
<sectionHeader confidence="0.893279666666667" genericHeader="method">
4226 Ridge Lea Road
Amlirsts New Ydrk 14226
ABSTRACT
</sectionHeader>
<bodyText confidence="0.951332363636364">
We describe the continuation of an earlier work on the
prbblem of lenical coverage. The objective is to prove
experimentally certain mathematical conjectures concerning the
relationship between the sizes of the covering and covered sets
of words, and-the maximum length of dictionary definitions. The
data base on which the experiments are carried out has been also
extended to the full contents of an existing dictionary of
computer terminology. The results of the previous and present
work lay the foundations for quantitative studies on lexical
valence and its relation to the frequency of usage and other
principles of dictionary selection.
</bodyText>
<subsectionHeader confidence="0.654885">
Besides the inherent interest in these investigations, the
concepts dealt with and the methods of quantifying dictionary
Variables may eventually lead to more efficient dictionaries with
</subsectionHeader>
<bodyText confidence="0.5830935">
respect to precision, compactness, and computer time and memory
needed for processing.
</bodyText>
<footnote confidence="0.314328">
Supported by NSF Grant MCS 76-24278.
</footnote>
<note confidence="0.78434">
A4
</note>
<sectionHeader confidence="0.831106" genericHeader="method">
rNTRODUCTION
</sectionHeader>
<bodyText confidence="0.991521458333333">
rirst, we shall introduce the problem define some basic
terms and provide a brief historical account of past results. In
order to render this paper fairly self-sufficient, 4 brief
summary of the previous work, Findler Viii (1974), will also
have to be given.
A. monolingual dictionary may be considered economical and
efficient if a small set of words are used to define a relatively
large set of entries. Quantitative information as to what size
vocabulary is needed to cover a given number of entries is very
scarce and may be characterized by two &amp;quot;data points&amp;quot;:
The New Method Enalish Dictionary published by M.P. West and
J.G. Endicott in 1961 uses 1,490 lelf-defined basic words to
explain some 18,000 words and 6,000 idioms, i.e. about 24,000
expressions. Thus, the size ratio is 0.062.
Ogden&apos;s Basic English, published in 1933„ involves 850
English words and 50 &amp;quot;international!&apos; words to defihe 20100u
English words. The ratio of the covering and covered set sizes
is 0.045.
The basis of selection was the &amp;quot;usefulness&amp;quot; of the words
employed in the definitions, as opposed to the freauency of their
occurrence in some standard texts. However, neither this concept
nor other principles of selection suggested by other researchers
havg ever been quantitatively analyzed and made use of. We shall
discuss these issues later on.
</bodyText>
<figure confidence="0.6806562">
45
In order to approach the problem in definite terms, Findler
(1970) considered three basic variabies:
(i) the covering set, RI of size VR,
(ii) the covered set, S, of size Vs,
</figure>
<bodyText confidence="0.832978083333333">
(iii) the maximum definition leffgth, N, such that each word
in S can be defined by at most N ordered words from R.
The task was formulated to find
VR as a function of vs at different parametric values
of N, and
(b) VR as a function of N at different parametric &apos;Values
v
Callina AVR/AVS increment ratio and VR/VS size ratio the
following cbnjectures vere made concernina the first task:
(al) Theiincrement ratio is, in general, less than one.
(a2) The increment ratio, in general, decreases as vs
increases.
(a3) For larae -constant values or N, vR approaches a
limiting value asymptotically as vs increases.
(0) The incremeflit ratio never exceeds the size ratio.
Two points need to be-noted in this connection. An excep-
tion to rtiles (al) and (a2) would occur in a dictionary system,
whibh does not treat polysemous words or homonyms as individual
entries, every time a new word with many meanings or homonyms, is
introduced into the covered set. Second, the cited case is an
exception to rule (al) but not to (a4). When N=1, the covering
and the covered sets are of the same size, i.e.. both the incre-
ment ratio and the size ratio equal one. However, not every word
is defined by itself only. If a new word is introduced that-al-
</bodyText>
<page confidence="0.5966">
46
</page>
<bodyText confidence="0.949030333333333">
ready has a synonym in the covering set, it will be defined by
that synonym. In this case, the increment ratio is 0 and the size
ratio becomes less than 1. (This will be clear with the descrip-
tion of the data base construction on page 11.)
FOr the second general task, (b) the following
conjectures were also made:
</bodyText>
<listItem confidence="0.39159">
(b1) vR monotonically decreases as N increases.
(b2) For any fixed value of V, v R asymptotically
apptoaches a lower limit as N increases vithout bound.
</listItem>
<bodyText confidence="0.986303875">
It seems reasonable to state in a aualitative sense that in
the process of aeneratina a dictionary smaller VR values mean
smaller storage requirements whereas smiller N values tend to
reduce processing time and output volume. In order to answer the
question &amp;quot;What are the optimum Values of VR and N for a given vs
liww.1==t
for a certain (family of) computer applications on a machine with
a given cost structure?&apos; one has to consider the interrelation
of the above three basic variables and to compute three entities:
the semantic index (roughly, the number of different meanings) of
the elements in the covered set, the lexical valence (roughly
the capability of being substituted for another word) of the
elements in the coverina set, and the freauency of dccurence of
the elements of both sets. Quantitative investigations of the
last three dictionary variables are planned to f011ow the
Present, second stage of our study.
</bodyText>
<sectionHeader confidence="0.572204" genericHeader="method">
THE DATA BASE AND THE PROnRAM
</sectionHeader>
<bodyText confidence="0.978281310344828">
We have eYtended the data base used in our previous work,
47
Findler and Viii (1.974), The whole contents ot tne aictlonary on
computer technoloay, Chandor (1970), is now included in the
present study. Its structure, AAther simple and uniform, is
described below. First, some general principles of data base
constructiop are outlined.
Eve a eiement of the covered set is considered a single
laical item, regardless of the number of words the original
dictionary entry consists of. Also1 eacn word is coded as a
stria of at most 10 characters (containable in one CDC Cyber
computer word). The abbreviations are still easy to Tread with
relatively short practice.
Only the dominant meaning of paysemous terms was dealt
with. Each entry has thus one meaning and one definition.
Terms in the definitions (elements of the covering set) are
also gonsidored lexical items, i.e. even multiword entities
appear as a single unit and are represented by at most 10
characters,
The basic vocabulary, that is the covering set, consists of
elements that also appeemin the covered set y In our particular
case, they are non-technical words used to aefine the technical
terms of the computer dictionarV. A definite distinction was
made between content woraa and function words (also called
operators), The latter were not included in the covering set nor
were they counted in determining the length of definitions.
Hence, tw_h* covering set consists only of content words.
The function words indicate grammatical and loaical
relationships between the words contributing to the content.
</bodyText>
<page confidence="0.588676">
48
</page>
<reference confidence="0.97020545">
They belong to 11 categories:
1) prepositions, 0.0. of, in, to;
2) conjunctions, e.g. and, or, if;
3) the relative pronoun which;
4) combinations of preposition and relative prdnoun, e.g. in
which, to which, by which;
5) present participles eauivalent to a nreposition, e.g.
using, containinc&amp;quot;, representing,
6) combinations of participle and preposition, e.TA
consisting of, opposed to, applied to;
7) combinations of adjective and preposition, e.a. capable
of, exclusive of, equal to;
8) combinations of noun and nreposition, e.g. _Eart_olfset
of, number of;
9) combinations of preposition, noun, and preposition, e.a.
in terms of, bv means of, in the form of;
10) prepositional phrases associated with a following
infinitive, e.g, used to, necessary to, in order to
11) other frequently used purely functional expressions, e.g.
for example, namely, known as.
</reference>
<bodyText confidence="0.925941333333333">
Actually, the function words were replaced by code numbers
in the dictionary. The code numbers were assigned consecutively
as the function words-were needed durina the construction of the
diAta base so that the order is purely random. A complete list of
the 121 function words used, toaether with their code numbers, is
given in TabSe I.
</bodyText>
<page confidence="0.397791">
49
</page>
<bodyText confidence="0.463173">
r
</bodyText>
<sectionHeader confidence="0.892249" genericHeader="method">
INSERT TABLE I ABOUT HERE
</sectionHeader>
<bodyText confidence="0.983982235294118">
The original definitions were somewhat simplified and
standardized. In this process, articles were omitted (many
languages do very well without them). On the other hand,
implicit relationships were made explicit-. Nouns are represented
in singular, thus avoidim another dictionary entry for plural
or, what would be worse, programming a &amp;quot;grammar&amp;quot;. Likewise.
finite verb forma are represented in third person plural pretent
iAdicative active. Avoiding the third person singular eliminates,
another dittionary entry, and avoiding thg passive voice
eliminates a great many participles, which otherwise would have
had. to be entered. Of course, present .and past participles (the
former identical to gerund in form) could not always be avoided
and had to be entered in the dictionary where needed. Auxiliary
verbs were automatically eliminated by avoiding pompound tenses
and the passive voice. Finally, &amp;quot;to do&amp;quot; associated with negationt
was simply omitted.
Some examples 61411 make the encodina process clear.
</bodyText>
<reference confidence="0.943082916666667">
Original dictionary entry:
aberration A defect in the electronic lens system of a
cathode ra? tube.
Definition in the data base:
DEFECT (in) SYSTEM (of) ELECTRONIC LENS (of)
CATHRAYTUB
1. is equivalent to 62. if 50
2. of 63. among
3. in 64. by
4. in terms of 65. namely
5. using 66. related to
6. and 67. concerned with
7. which 68. based on
8. in which 69. constituting
9. between 70. resulting from
10. to 71. set of
11. or 72. including
12. from 73. followed by
13. used to 74. provided by
14. necessary to 75. developed by
15b part of 76. assigned to
16. consisting of 77. referred to
17. containing 78. on wnicn
18. capable of 79, used as
19. by means of 80. in the form of
20, opposed to 81. from which
21. when 82. into which
22. on 83. number of
23. so that 84. less
24. in order to 85. defining
25. exclusive of 86. known as
26. for 87. performing
27. pertaining to 88. performed by
28. under 89. independeht of
29. as 90. cnosen by
30. such as 91. for which
</reference>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.000000">
<note confidence="0.876062">Journal of Computational Linguistics 75</note>
<title confidence="0.8364965">FINITE STRING NEWSLETTER OF THE ASSOCIATION FOR COMPUTATIONAL LINGUISTICS</title>
<author confidence="0.5790435">Numav AMERICAN JOURNAL OF COMPUTATIONAL LINGUISTICS is published by</author>
<affiliation confidence="0.710756">Association Computational Linguistics E Walker, SRI International,</affiliation>
<address confidence="0.99728">Menlo Park, California 94025 EDITOR David G Hays, 5046 Lakeshore Road, Hamburg, New York, 14075</address>
<affiliation confidence="0.991293">ASSOCIATE EDITOR George E Heidorn, IBM Research Center,</affiliation>
<address confidence="0.990114">0 218, Heights, New York 10598</address>
<author confidence="0.429852">EDITORIAL ASSISTANT William Benzon</author>
<note confidence="0.858859">Copyright 1978 Association for Computational Linguistics American Journal of Computational Linguistics</note>
<title confidence="0.654148">iche DERIVATION OF ANSWERS FROM LOGICAL FORMS</title>
<author confidence="0.718735">ANSWERING SSTE M</author>
<affiliation confidence="0.6821395">ONE MORE STEP TOWARD COMPUTER LEXICOMETWr, V Findlet and Shu-Hua Lee</affiliation>
<address confidence="0.721448">IN DEPARTMENTS QF LINGUISTICS 02</address>
<affiliation confidence="0.4544125">I PRESS AT TWIN WILLOWS OF MICRO HARDWARE &amp;SOFTWARE TO BE PUBLISHED</affiliation>
<address confidence="0.377724">73</address>
<title confidence="0.74892">ASIS ARO HICSS</title>
<author confidence="0.46706">STRUCTURES PROCESSING ed</author>
<affiliation confidence="0.479952">LANGUAGE IN INFORMATION</affiliation>
<address confidence="0.526507">Walker, Karlgren, and 1.(a\ edc 76</address>
<note confidence="0.943668">OF 77 WASHINGTIA REPORT JUNE 78 Journal of Computational Linguistics 75: 3</note>
<title confidence="0.989266">THE DERIVATID OF ANSNERS FROM LOGICAL FORMS IN A QUESTION ANSWERING SYSTEM</title>
<author confidence="0.999792">FRED J DAMERAU</author>
<affiliation confidence="0.9981595">IBM Corporation J Watson Research Center</affiliation>
<address confidence="0.932758">Yorktown Heights, New York</address>
<abstract confidence="0.981272056">This paper describes how the process of genervting a given an underlying for an input question is accomplished in the Transformational 2uestion (ToA) system under development at IBM a brief description of which is given. The last formal level of representation in this system is logical form. The baslc method of evaluation of logical forms is the generate and test&amp;quot; paradigm, used, for the LUNAR system (Woods, Kaplan and Nash-Webber, although must be fairly tificient order tot be practical moderate site data base. The idea is to keep of the equivalence telationships betwlen the variables in the logical fort and associated Use this information to derive from the the extensions of the predicates the logical form. A similar proposal has been made by Reiter(1976). The logical forms and the process by which candidate sets are computed from these forms ,#re described in considelable detail. We believe it should not be necessary for a computational linguistics project to describe operations beyond the last level of formal representation in order Sol an outsider to understand exactly how a system operates sufficiently well that he.can its behavior. Although we to achieve that, we still have a considerable way to go,. 4 This paper describes how the process of response given an underlying representaion foir an question is accomplished in the! Transiorvational (T2?) under continuing deveLopment at IN Research. T2A has been, operational in a laboratory -mode years, The system ts now installed &apos;in the of planning department small city where it is used to the file of land use for each parcel of land in the city, (about 10,000 parcels with 40 pieces of data for each parcel). The sysytem is undergoin3 modifications and improvement prior to a formal evaluation stage. S.STEt•OVERV EW A generalized flow diagram of the&apos; Tin system is given in 1. Input, from a display device or terminal, is fed to the preprocessor, which segments the input character striag a.nto words and performs lexical lookup. The process of lookup is complicated somewhat by a provision for synonym and phrase replacement. Words &amp;quot;car&amp;quot; and &amp;quot;automobile&amp;quot; are changed to &amp;quot;auto&amp;quot;, an&amp; strings like &amp;quot;gas station&amp;quot; are froln into single lexical units, wok Input LexicOn 1 IPreptocessor! &lt; I. 1 List of lexical trees or. parson&apos; transformations I List of trees &apos;Context free parser&apos; &lt;— L 1 List of surface trees 17ransformational parsetl &lt;----Inverse transformational grammar I Deep sttucture(s) &apos;Transformational parseri &lt;----Data base specific I&amp;quot; Query structure(s) interpreter! &lt;-----Sementic J 1 [ Logical form(s) 1 Data base &apos;Evaluator&apos; &lt; Answet Figure 1 Contelit free Phraze strvicrure rules The output from the lexical lookup is a list of trees, each tree. containing pdrt of sreech inlormation, lyntactic features and semantic features, as required A of the lexical component, now obsolete in Its detail but still valid in maln outline is given in RobinsanC1773). Tht of trees is input to Itual trAnl,fs_triansm.s. described in P1athf1974). These trAnsformations operate on adjacent lexicalpitems to deal with patterns of classifiers&apos; ordinal numbers, stranded prepolitions and the like. effect of this pnase is to reduce the number of surface parses and the amount of work clone in the transformational cycle. The resulting list of trees is input to a context patser, which produaes a set of trees,each of which is fed to the transformational recognizer. The tecognizer attempts to find an linAptiaing s:tructIl_ne. each surface tree. Plath(1973). Typically only one a set of surface trQes will resultin an underlying This structure itself is input once again to transformational recognizer, using a (small) set of grammar tailoTed to a speciic data base to produce a structures are vimilar to structures in farm, but re-fleet the paxticular meanimg constraints resulting from the format and content of a given data base. The query structure tree is processed by a Knuth-style semantic interpreter, Pettick (1977), producing logicalform. A logical form can best be thought of, in context, as a retrieval expression. which is to. be evaluated, producing an anamer to the English input query. Since the major part of this paper is concerned with processing logical forms, discussion of their specifics will be deferred until later The process of ansmer extraction from the data base is accvmplished by a combinatIvn of LISP and PL/I programs, described below, and an experimental relational data base management system called Relational Storage System (RSS) (Astrahan, et al. 1976). The RSs provides the to generate a data base of n-ary relations, with indexes on any field of the relation, and low-level access commands liRe OPEN. NEXT, CLOSE. with appropriate parameters, retrieve information from such a data base. All the processing modules are under the control of a driver module, which maintains comitanication with the user, calls the processors in the correct sequence, and tests for errors. An example of the progwssing of a question, with tile intermediate outputs, is given in Figure 2. In this example, the numbers 2945, 6535, 6635, 6975 are the numbers of milliseconds .of computer time used up to the point shown, on en IBM S/370 Model 168. The strUctures printed are a bracketted terminal string representation of structures which are stored and manipulated as trees by the are the heights of stores ?</abstract>
<note confidence="0.908099777777778">Z945 SURFACE STRUCTURES: (((441-I SOME) (THING X1)) BE (THE ((HEIGHT X4) (OF (VhE ((DRUa,STORE 591) X7))))) ?.) 6535 UNDERLYING STRUCTURSS: (BD IDENTICAL UTHE.(X4 Bp X4 ((DRUG_STOSE *)i)“(Wn SOME, CITING X1)) BD) 6635 QUERY STAUCTURES: 1. (THE (X4 (* BD HETGHT X4 (THE ((DRUG_JTORE 591.)</note>
<address confidence="0.384473">01)) ED *))) 6975 LOGICAL FORM:</address>
<abstract confidence="0.944055114285714">(setx lX4! &apos;)(44 &amp;quot;(setx f(testfdt &apos;59V &apos;(&apos;LUC X7 &apos;1976) ) ) (testict X4 &apos;(&amp;quot;JSTOR X44 &apos;1976) ) ) ) 7995 ANSWERS: HUMBER STORIES 1976 70590001610 1 8010.0000710 1 8010000081t 2 90430000910 1 Figure 2 processing programs,. The nonterminal nodes pi the tree, with associated complex feattires, represent additional infbrmation that shown here. 591 a lend use code which. in the data Dose, indicates a drug store, and the long numbers in bhe ans4er axe the parcel identifiers, (ward-block-lot). Feon this brief description, it should be apparent that the T2A system, considered as a blacit box, is simllar td many others. In particular, there is a desItnated level of representation, the logical form, which is the formal construct in the system. The remaining processing to derive an to format it for presentation to a user is accomplished ny an unstructured set of computer programs. Two separate issues arise as a resu1t4 how efficiently can the logical form be evaluated a real data base, and to what the functions further specify beyond that carried by the logical form? XVALUATIONOF FORMS The basic Method of evaluation of Logical forms is the &amp;quot;generate and test&amp;quot; paradigm used, for example, in the LUKAR PAGE 10 Kaplan and Nash-Webber, 1972). The simple version of this paradigm, used by Wooas and implemented in our early systems, involves checking pre-selected lists of objects or, in tht worst case, all the objects kno;.in to the system, to see, if they satiSfy. the query predicates. It is impractical except data bases. Our current&apos; varlant oi this method is much more efficient. The basic idea is to keep track of the equivalence relationships between the vaxiables in the logical form and constants, and infoTmation to derive the ot the predicates in the logieal form fIam tne ciata base. A similar-proposal has been made Reltez(1976) We do not however, mace such extensive use of queil transformations as Reiter outlined. Logical forms In order to describe the ev.altation process, it is necessary to describe the logical form in somewhat more detail, referring for a&apos;n example again to Figure 2. In the place, except or the set-±orming setx,which takes as arguments a variable name and a proposition, all well-formed composed of and their arguments. Some of the predicates are like greaterthan.Some are quantifiers, like formtaeast,which takes a argument n, an which is a set, and a proposition 2, and which is true just case mor e elements of the specified set satisfy the proposition 2. Others are special application parcel,which is true just in ease its single argument identifier. Main data base related ptedicate is named testfqi. to Figure 2, it is seen that testithas three arguments. The first is a constant or a variabLe which 14111 be replaced by a constant befaxe evaluation, the second argument is a list whos members determille a particular base value, and the third is an specifying the relation which must hold between the first argument and the base value determined Second argument. data base can be thought of as a coilectinn 4binary all the same key. In our applica;tioh, this is the parcel identification or: account number, by any piece can be identified. The list is the second argument of testfctconsists of the relation name and the key which identifies &apos;a value in the relation. The key actually has two parts. The second part is a year, now unused, although since the files in which we are currently interested are changed on a yearly basis, we anticipate maintaining and accessing historical data. first part of the key is the account number mentioned above. In general, the second argument of testfct must be sufficient to identify a unique binary relation and value in If the logical form is itself a proposition the system will answer eithet &amp;quot;yes&amp;quot; or &amp;quot;no&amp;quot;. If the logical form has a system will print the members of the set satisfying the specified proposition, perhaps along with identifytng Simplifications A number of simplificationm can be, and in part have been, carried out on logi.cal forms prior to evaltation. Some predicates, for example, are essentially empty for purposes of evaluation, in that they always evaluate to true. As an the predicate dollar,for information fields referring to taxed, is empty of meaning because the processor assumes that the contents of the taxes field are always dollars. A slightly less obvious example of possible simplification can be seen in Figure 2. The set of the foratleastpredicate contains no free variables. It is not necessary, therefore, to evaluate the setx funotion for each evaluation of the Instead, the setxfunction is evaluated as soon as the semantic Interpreter has discovered that it hag no free variables, using the standard evaluation mechanism, and value, i.e., a set, is substituted ier the PAGE 13 expression. Our system peri.ormt simplifications of this in its normal it can also deity all evaluations until a complete form has been built), so that final logical by the retrieval functions proceSsing is usually that shown 3, where inne. setxhas been replaced by the satisfying set parcel identifiers of the set drug all the applivOle simplifications have been resulting form is passed to he evaluation function, MIALU. The Pre-evaluator It might seem that since the system has been written in LISP, it would only be necessary to define the appropriate functions and then call the regular tISF evaluator, Instead of a special evaluator like EVALU. While this would be possible, the, aifficulty with such an approach can readily seen by considering the embedded setxin Figure 2. The desired set of X7s is that set of parcel identifiers fo the associated land use code is &amp;quot;591&amp;quot;. tes_tfctis a predicate which is true for the appropriate X7s, but what is the candidate set of X7s which should be tested? At worst, the system might consider the net of all objects it knows As a the systey could infer from the of testfctthat the candidates are all members of the set of parcel identifiers, but still there are almost 10,000 are the heignts 0± tne arug stores</abstract>
<note confidence="0.8661851">2930 SURFACE MUCTURES: 1. (((WN SUM) (THING X1)) BE (TUE ((HEIGHT X4) (OF (THE ((DRUG STORE 591) Xr7)T))) ?) 6500 UNDERLY±NG STRUCTURES:. (THE (X4 (* MY HEIGHT X4 (THE CCDRUG_STORE 591) X7)) BD i))) ((144,SOME) (THIN )1)) MD) 6599 &apos;QUERY STRUCTURES: (THE (* BD HEIGHT X4 (THE &apos;ADRUG_STORE 591) X7)) BD *))) 11&apos;76 LOGICAL FORM: &apos;iforatleast 1 &apos;X44 (90430000910 8010000.0811 80100000710 70590001610) (testfct X4 (&apos;JSTOR X44 &apos;= ) ) ) 7385 ANSWERS: NUMBER</note>
<date confidence="0.791658">1976</date>
<address confidence="0.666228">70590001610 1 80100000710 1 80100000811</address>
<phone confidence="0.627356">90430000910 1</phone>
<abstract confidence="0.965246254988913">Figure 3 molt A much better approach is to attempt to compute the extension of those predicates for which the variable being sought is an argunlent Again referring to Figure 2, a reasonable set in fact the pertect set) of candidates for X7 can 1.7e found by. Looking in thc data base for that set of identifiers for which the land use code is 591 If the base is properly organized, such a search can be very tast Not all predicates are so simple however. The remainder of this section will describe in some detail hom candidate sets more predicates are Once candidate sets have been compute &amp; the EVALU function the LISP evaluatom logical form. The of incLuding a candidate in the program and all the T)dtential top level predicates and then applying the LISP EVAL function directly seems much less attractive. As a preliminary, notice that we need only insure that sets have been established fiSr all the in logical form. This is so because, while each has an associated variable, the domain of is given explicitly as a llst of or implicitly by a.setxexpression. Secondly, since the object of pre-evaluation is merely to find efficient, not nedesr-tily nptimal, candidate sets for the setxvariables, we need keep track of the of a complex predicate. As an example, consider Figure 4, which the logical form foir question, &amp;quot;What drug stores are located in ward 2?&amp;quot; The pr4dicate of the setx is &amp;quot;and&amp;quot;, but for purposes o2 (setx &apos;X2 &apos;(and (testfct &apos;591 I(TLUC X2 &apos;1976) ) (testfct wz &apos;0WARD X2 &apos;1976) • = ) ) Figure 4 a candidate set we can consider each the Evaluation of the form with a set will ensure that a member satisfies both terms of the &amp;quot;and&amp;quot;. of the pre-evaluation function.Pre-evaluation accomplished by a functioh EVALUA,which takes a logical i.e., a setxexpression or a proposition as its It determines type of form with which it is dealing and calls an appropriate specialist routihe If as in the case ef the &amp;quot;and&amp;quot; of Figure 4, the logical form being considered contains more than ohe component form, EVALUA itsif recursively. pre-evaluAtion is a depth-first, left-to-rioht process. The function always returns nil, all work being acccomplishcd by changes to global variables. Among these are a LISP variable which a of all setxvariables in the logical form, a LISP variable which lists each query variable for which a value has been found, and its value, and a LISP variable which keeps track ai the equality relationships which have been discovered between query variables for which a value is yet to be found. Operation of the algorithm can be better understood bv considering somewhat more complicated examples than those previously. When EVALUA is given the logical form What pwrcels have an area exceeding 550000 square feet ? 7524 LOGICAL FORM: Csetx &apos;X2 /(and (foratleast 1 wX39 &apos;(ttstfct X5 &apos;(&apos;PARAREA X2 &apos;1176) &apos;= ) ) &apos;(greaterthan X39 &apos;550000) ) (parcel X2) ) ) Figure 5 5, it calls the which adds X2 to the (null) list of set variables and the (null) list of query vatiables, and calls EVALUA with the associated setx rand&amp;quot;. As mentioned&apos;, simply results in two calls to EVALUA, the first of which causes the quantifier specialist to be invoked. (The second call, when made, will cause any change to the global lists of values for variables, since a candidate set of all parcel identifiers is not useLul for purposes of retrieval.) X39 is added to the list of query variables, and the domain argument of the quantifier is inspected. When this is seen to. be an instance of setx rather than a list of constants, two actions are taken. Notice that whatever the domain, of X39 it, it is a subset (perhaps not a proper subsets) of the domain of X5, i.e., the candidate set fox X5 must include at all of the elements of X39. Further, any which can be imposed on X39 can also le imposed on X5, since the proposition associated with thd quantifier is the one to be satisfied, and any candidate not meeting this criterion would be supertkuow. TheLefore, we can 1) enter into the of variable the information that of the pre-evaluator, X39 and X5 equivalen and 2.) call EVALUA once more with the satx associated with X5 as an argument. is added to the set variables, and of EVALUA with the ,setxpredicate causes a call thespecialist for testfct.Since there are two variables testfct,X5 and X2, for which values are unknown, a&apos; call the data base cannot yet be made. The testfctis placed on a list of pending lata base calls, preceded by the variables which require values. (Each time a value for a variable is found) that list is inspected, and any data base calls which can then be made are executed.) Return is made to the quantifier specialist, which calls EVALUA with the predicate over whose arguments is ,made, viz., greaterthan. The specialist for numeric predicates, finding that one argument is a variable and the other a constamt, causes a tthange in the variable list to show that X39 and consequently X5 are greater than 550,000. A value &amp;quot;&gt;550,000&amp;quot; can be used by the data base component to narrow its search just as well as a constant ox list of constants, and is therefore acceptable as the value of a candidate list. These changes to the variable lists cause the list of pending data base calls to be inspected and, since only one is now stacked testfct,a call to the data base is made for thoss parcels with an area greater than 550,000 square feet. specialist for testfctinstructs data base search to return as a value a list to the in the form, In the present example, that is a list of parcel numbers, viz., those parcels which have an area exceeding 550,000 square feet. This liSt is then assigned as the value of the candidate set for X2. PAGE 20 The stack of recursive calls to EVALUA will now unwind, until a return is made to the eValuation function EVALU. This function determines that candidate lists for all the setx variables have been found, and qreates a hew list of vet pairs for use by the setxfunction itself. Finally, EVALP an call the LISP evaluator, with the original logical form as an argument. case of negatives.,The predicate denoted in system by notto distinguish it from the LISP presents special problefis for the kind of system outlined above. A simple example of the difficulty can be seeh ift What drug stores are not in traffic zone 6 ? 5651 LOGICAL FORM: (setx &apos;X3 (not* (testfct &apos;6 &apos;=1 ) ) 4testfct &apos;591 &apos;(&apos;LUC X3 &apos;1976) T= ) ) ) Fiaure 6 Figure 6, which corresponds to the question &amp;quot;What drug stores are not located in traffic zone 6?&amp;quot; variants thereof. &apos;When the testfctspecialist is given first half of the and,in this along information that there is a dominatIng not*, it could in principle generate a data base c.all, since there is only one unassigned var,iable. The effect wolld be the retrieval of all parcel iftntifiers of parcels nbt located in traffic zone 6. This is a substantial fraction of the data&apos; base, and require of time and storage space to handle Notice that the other half of the and will a candidate list for the variable presumably much smaller in size. It appears to be the case, from our far limited experience, that questions containing only search clause ever occur. The therefore puts a testfctcall of this type on the stack mentioned earlier, indexeft by the variable(s) corresponding to the parcel identifier. When the second half of the and of Figure 6 is processed, and a value found X3, testfctwill be unstacked, in a data base call, and causing a retrieval based on that list of identifiers rather than on the negated value. This data base search is necessary, since we must find the traffic zones for the parcels contained in the candidate list. This example is also an illustration ot why, as was the logical form as a whole must in general evaluated by the evaluator. In this case, candidate set for X3 derived from the second clause of the aildis a superset of the answer set whicn can only be by evaluating the Some could doubtless eby those cases lt is unnec&apos;essaty, purely an implementation The riot* of Figure 7 presents a different kind o problem Row many banks have a height not exceeding S floors ? 7966 LOGICAY FN: Csetx &apos;XI s X1 (setx &apos;X3 &apos;(and (not* fforatleast 1 vX46 (sets &apos;X6 T(testict X6 &apos;(&apos;JSTOR X3 &apos;1976) &apos;= ) l(greaterthan X45 ) ) (testfct 611 . &apos;(&apos;LUC X3 &apos;1976) ) ) ) ) ) FiguKe 7 from the previous example. Firstly, notinAthat the must be passed inside the since the alternative of linding all buildings greater than 5 stories in height and then getting the complement set with respect is extremely unattractive computationally. in the second place, a search qualifier of &amp;quot;&lt;= 5&amp;quot; does not intuitively seem to be much worse than &amp;quot;› 5&amp;quot;, at least in the absence of aata base distribUtiOnal statistics. might, therefore, generate a search with such a qualifier. Our present system dots this, although experience thay show all instancesof testetdominated by not should as are the cases efficiency reasons. specialistsMost of the important specialist routines in the pre-tevaluator have already been mentioned. There are a few others which should be noted. One is a which, giv.en a predicate, will produce extension ,from a stored feature was heavil used in our early system, which had a small database, but currently hardly used all, though it remains In principle, one could, given a predicate &amp;quot;SCHOOL(X)&amp;quot;, generate a list of schools. In the preselt apPlioation, this would not be useful, but might in some The sole uses at present are for the predicate RANK, far which a list of numbers from 1 to 100 is produced, and for the predicate YEAR, which produces a list 0± the numbers 1960 to 1985. proposition &amp;quot;(QUANTITY x s)&amp;quot; is true if x .is equal the cardinality of the set. sz The associated specialist hfas obvious functiomof determining x when s is an setx. Equality between variables can be inferred where the of a quantified variable is aiven by an of setx,as was illustrated above. Certain predicates allow this inference to be made. It is clear that like &amp;quot;SAMEREF&amp;quot;&apos;, &amp;quot;same and &amp;quot;IDENTIOAL&amp;quot; should belong to this class. Since variables can only refer to individuals, the predicate &amp;quot;MEMBER&amp;quot; also is in this clAss, e.g., given (MEMBtR X3 (SeTX )), a candidate set for X3 can be derived by evaluating setxexpression. considerations.It has already been that generation from instances of testfctwith an operator of &amp;quot;-=&amp;quot; are deferred until enough information is available to execute the query using a list of parcel identifiers. Some other steps have also been taken data base access time subsequent evaluation For one thing, tha semantic interpreter has a preferred fox instances of the testfct.For the relation divides the pareels of the city into 6 classes, while the relation &amp;quot;LUC&amp;quot; (Land Use Code) divides the parcels into several hundred classes. If there no intrinsic reason for ordering the instances of differently, the one with &amp;quot;LUC&amp;quot; will occur earlier in the logical form, (cf. Figure 4). The pre-evaluation specialist PAGE 25 testfctmakes use of this ordering in two ways. 12 a Variable has been assigned a list of identifiers containing fewer members than some threshold x, (x is currently slit to 25, but can easily be changed), then a retrieval will always be made using the list of identifFers rather than by a constant compared to data base values. In Figure 4, call to the testfctspecialist will look up the ward of the lour drug stores instead of finding the hundreds of parcels in ward 2. In some instances, particularly for like Land this may result in mor&amp; data base accbsses than retrieving a new set of keys depending on but the improwement cannot be larre. In other instances, there is a big reduction in accesses. If the caRdidate set is larger than.25, retrieval will be made using the constant, but the length of the current candidate list is used to limit the number of accesses. Thus, if thd current* candidate list is 50, the data base access program will terminate if it finds more than 50 identifiers with the value being used. A re-access is then made using the list of identifiers. Again, this may result ift.inefficiency in some cases where searches are ended jUst before normal termination, but it does provide a guarantee against excessively long retrievals. Any number oi other efficiency measures could be adopted, and more may be necessary than we now have. For the moment, PAGE 26 these seem to provide acceptable retrieval times. The Evialuaton For the most part, evaluation of logical forms is quite straightforward. Hidden semantic effects are discussed in the next section; here we are mainly concerned with computation. Each instance of setx searchs the list of variable-candidate set pairs to find the candidate set associated with its own variable and substitutes the members of the set for the variable one by one into its associated predicate. Those members of the candidate set for which the evaluates to true are the solutionset. Operation of the quantifier predicates is similar to that of setx,except that, as in Figure 5, it may be necessary to an instance of setxto find the domain of the quantification variable.. Evaluation of the ether predicates consists simply of applying a corresponding LISP function to the arguments. the final logical form to be evaluated obvious relation to the input question, as in Figure 8. The usual reason is that a large amouy of evaluation was done Are there more than 25 parcels in the Carhart neighborhood ? 36229 LOGICAL FORM: (greatexthah &apos;176 &apos;25) Figure 8 during interpretation, because form contained no fret The logical form corresponding to Figure 8 Are thPre more than 25 parcels in the Carhart neighborhood.? 15986 LaGICAL FORM: (forall &apos;X115 (setx &apos;X38 X38 (setx `X34 &apos;(and (testfct 9 (&apos;NEIGH X34 &apos;1976) T= ) (parcel X34) ) ) ) ) (greaterthan X115 &apos;25) ) Figure 9 in Figure 9. PAGE 28 evaluatian of the predicate testictis not as obVious as that of the others One of the design goals in the project has been to make it relatiVely easy to move from one data base to another. As part of that effdrt, we have attempted to make the LISP programs, as contrasted td the PL/I programs, insensitive to the structure of the datu base. Our approach to tlais has been to define a list strticture, essentiAlly nested binary relatont, into which the real data structure is mapped. Restructuring is accomplished by the PL/I program which serves as the LISP interface. At the time, the PL/I program returns to the test.fctspecialist the pre-evaluation it formatS the corresponding data base items standard structure and writes them onto a disk file, in effect creating a sub-data base for the particular query. Only the sub-data base is used during evaluation of logical forms, to find values corresponding to keys in the instances testfat.In addition to isolating the from the real data structure, this tactic makes it unnecessary any programs called evaluator to the full data base, with a consequent efficiency gain. Creation of the stahdard LISP data, Vase into which the data is translated meant that the set of functions has undergone the least modification in our chanTe data base from business to planning Except for improvements made to increase the efficiency of programs, these q 2outines axe almost the same as they were befoxe. EFFECTS0: In principle the processes which will bw used to compute the answer to a query should be obvious at the level of ether the query struciure or the logical form. We not, however, been zlompletely successful in accomplishing this. In some cases, we can see how it might be done and have not gotten around to doing it because of more urgent concerns. In other cases, we can see how to diz it, but not how to do it efficiently. In a few cases, it is not clear what fo do. Approximation.Consider the senIence and corresponding logical form shown in Figure JO. The precise system meaning of &amp;quot;about&amp;quot; is clearly hidden Ln the program coxrespondIng to operator APPROX.In the present implementation, of x and y is true if: wnen y&lt;10, and x&lt;y+2, 2) when 10&lt;y&lt;40, x&gt;y-3 and *x&lt;y+3, 3) when y&gt;=41, x&gt;y-.05y and x&lt;y+.05y. 8 are approximately equal to 7, 14 aild 18 are equal to 16, and 951 and 1049are equal to 1000. Whether de.inition us parcels are at about $ 1000000 ? 6168 LOGICAL FORM: Csetx &apos;X2 (and (testfct &apos;101)0000 &apos;(&apos;VNCIT X2 &apos;1976) &apos;APPRDX ) (parcel X2) ) ) 6373 ANSWERS: ASSESSMENT- 1976 70596,002600 70430000609 70400000600 10310000602 977,750 1,000,000 1,033,425 j955,900 Figure 10 satisfactory or not clearly depenAs on a variety of contextual factors. should also be clear that semantic interpreter could produce a logical form in which meaning was expressed have chosen the meaning in our programs primarily for ie. it was easiest to do it this way, and there was no obvious reason to do it elsewhere. A similar hut slightly different en.umple is shown in Figure 11, where the output rather than the input is to be approximation to the true value. In this a called FUZZUPis applied to a data base value to PAGE 11 About how many square feet do the, drug stores have ? 7227 LOGICAL FORM: Csgtx &apos;X4 &apos;(foratleast 1 &apos;X52 &amp;quot;(18570 24814 8440 5465) &apos;(approx X52 X4)) ) ANSWERS: PARCEL AREA-SQ_FT 1976 70590001614 80100000714 80100000814 9043000&apos;0914 19,000 25,000 B,400 5,500 Figure 11find that number with the maximum number of trailing zeros satisfies the APPROXrelation. The fuzzed rather than the true value becomes the output. subtle case is illustrated by rigure 12. It seems that what is really wanted. are parcels with an area of a million square feet or more, rather than exactly 1,-000,000 square feet. If the latter result is wanted, the question is better phrased &amp;quot;exactly 1,000,000w, (and must be in this similar way in our system.) On other hand, a value like 1,000,205 seems to imply that exact is wanted. intuition is in our system what parcels have an area of 1,000,000 square feet? 8416 LOGICAL FORM:* (setx &apos;X2 &apos;(and (foratleast 1 &apos;X45 (tetx &apos;X5 XS &apos;PPARAREA.X2 &apos;1976) Tr; ) ) &apos;(equal X45.&apos;1000000) ) (parcel X2) ) ) 8789 ANSWERS:</abstract>
<phone confidence="0.8254916">1: 79-880000900 24 7079_0000100 3: 71790000100 9 • 22: 80300000101</phone>
<title confidence="0.733828">MORE PARTICULAhS DESIRED?</title>
<author confidence="0.464519">YES OR MO</author>
<email confidence="0.492063">yes</email>
<affiliation confidence="0.288321">EXPLANATIONS TO THE ANSWERS:</affiliation>
<address confidence="0.51378325">FOR 70880000900 MORE - 13590410 FOR 70790000100 MORE - 5977500 FOR 70790000100 MORE - 5583085 FOR 80300000101 ALMOST.- 958320</address>
<abstract confidence="0.95868362962963">Fig-ure 12 having the testfctpredicate inspect its numeric arguments with a function called ROUNDMM, which is true if an argument is a round number, defined in our systam to be a greater than 99 in which at least the rightmost digits are 0. In the case-of round numbers, it seems reaSZnable to give as an answer the identifier of a parcel PAGE 33 area is only slightly less than squaie as well as greater.. In our implementation, we use the same lower limit as for APPROX, but this may be too low. In order to insure that the answer is correctly understood by user, the system saves the exact values retrieved displays them on request, as shown in Figurev,12. of character values.A problem analagous to that of nuterical approximations occurs also in comparing character string values. Consider the question and answer pair shown in Fisure 13. The contents of the OWNER field What parcels does Shell-own ? 4244 LOGICAL FORM: (setx &apos;X2 &apos;(and (testfct &apos;SHELL &apos;(&apos;OWNER X2 &apos;1976) ) (parcel X2) ),</abstract>
<address confidence="0.444126">4432 ANSWERS:</address>
<date confidence="0.803922">1976</date>
<address confidence="0.9858525">70600009501 SHELL OIL COMPANY 80220003300 SHELL OIL CO</address>
<abstract confidence="0.93859942">Figure 13 have not been stanAardi_zed, so that parcels could be owned by &amp;quot;Shell Oil&amp;quot;, &amp;quot;Shbll Oil Co.&amp;quot;, etc. Fortunately, for names of persons&apos;, last names are listed first, so tha;t strategy of assuming equality if the input argument and the field value match up to a comma or a blank is generally successful. Problems do arise; for example, properties both to &amp;quot;The City of ...&amp;quot; and &amp;quot;City of ...&amp;quot;, the left match fails to find all the relevant data items. The opposite situation, i.e., aver-generalization, can of what parcels does Gluck own 4525 LOGICAL FORM: (setx &apos;X2 &apos;(and (testfct &apos;GLUCK &apos;(&apos;OWNER X2 &apos;1976) ) (parcel X2) ) ) 4742 ANSWERS: OWNER 1976 GLUCK, DE &amp; CP Figure 14 am% cf. Figure 14. Tn any event, the decision as to what constitutes sameness of reference is buried in computer code in this instance in the PM/I program as well as in the LISP definition Df the function SAMEREF. The extensional definition of most predicates can be derived from the data base. A predicates are defined by the syRtem code. Examples are RANK and, YEAR. u.rhidh as mentioned above have associated generators An additional example is LASTYEAR which defined tc be the previous year. Many other definitions of this Rind have been eliminatell in the current version df the system. Answers.It is not always obvious what constitutes the answer to A question. Consider the example in Figure 15. Both the English question in its literal reading and the logical form would seem to imply that the question would be answered by presenting only the numbers in the right hand column of the table which is actualiy printed as an answer. it clear that a simple list be useless without the parcel identifiers printed on the left, and indeed that identification would be expected by the pecson entering such a question. The example of Figute 16 what is the gross floor area of the drug stores ?</abstract>
<address confidence="0.501524">7245 LOTICAL FORM:</address>
<phone confidence="0.328584">setx &apos;X4 80100000710</phone>
<note confidence="0.7206246">(foratleast 1 &apos;)44 80100000811 70590001610) (testfct X4 &apos;(&apos;PGFAREA X44 &apos;1976) ) ) ) 7465 ANSWERS: GROUND-FLOOR AREA-S2_FT</note>
<date confidence="0.910605">1976</date>
<address confidence="0.842027">70590001610 7.078 80100000710 10&apos;,125 80100000811 6,500</address>
<phone confidence="0.498316">90430000910 1,800</phone>
<abstract confidence="0.59867136">Figure 15 is less clear. An enumeration of the three ward6 in which the four drug stores were located might have been a sufficient answer. The answer given would be correct for &amp;quot;In khat ward is each drug store located?&amp;quot; Moreover, given the question &amp;quot;What are the wards which have drug stores?&amp;quot; is clear tbat only a list of waxds should he and given is the combined floor area ot tile only a single number representing tne total is the desired In what wards are the drug stores located ? 9,403 LOGICAL FORM: (setx &apos;X3 &apos;(foratleast 1 &apos;X64 &apos;(90430000910 80100000811 8010000.9710 70590.001610) e(testfct X3 &apos;(&apos;WARD X64 &apos;1976) &apos;= ) ) ) 9597 ANSWERS: WARD 1976 2</abstract>
<address confidence="0.5277265">80100000710 3 80100000811 3</address>
<phone confidence="0.800621">90430000910 5</phone>
<abstract confidence="0.990837258620689">Figure 16 answer. (Our system does not as yt answer this question or its analogues, tlthougth this is planned for later in the Yeax.) Since the ambiguity exhibited by the questjon of Figure 14 is so pervasive inan application of this kind, we have chosen to present a -maximally general answer, including identifications, when me are unable to resolve the ambiguity directly. An exchange with the user could be devised to elicit the information for resolution, but would becOme tedious for questions of this type. . For yes/no questions, and for questions in which there is only one object in the answer set, thjs problem naturally does not arise, and the appropriate answer Is eas.ily produced., have yet ourselves with adding an generatDr to the T2A system. In the applications envisioned at present, such a capability does n6t seem to be critical. We are able to manage with short answers from the data base and with canned information and error messages. In spite of this omission, it should also apparent that computational component has a considerable amount of lingukstic knowledge embedded in it, more than we would like. Whether it is possible to achieve a level ef formal representation which would make this is still unclear. Moreover, even if it possible, it is not clear whether such a solution would be efficient enough, or even if it would be more perspicuous than the current system We intena to proceed as far as we are able in this direction, out of conviction that useful systems must be adaptable to new applications, and that such adaptation is much More difficult when computer code, even high—level computer code, must be changed, rather than tables. This is not to imply that we regard modification of a table whose size is on the of a grammar as trivial; quite, Monetheless, we believe it is easier to change.a gramma&apos; or a semantic interpreter expressed in table form than it is to change a Special parser or a special interpreter. essence, we believe it should not be necessary for a computational linguistics project to describe operations level of fcirmal representation in order for an outsider to Inderstanu egactly how &apos;a system operates. F0-4TNpTES This system was formerly called REPUEST. The form of Figu.re 3 is, in fact, subject to Another syntactic transformation prior to execution. Normally, foratleastneeds to be executed once for each potential of the getxvariable. However, in the case where the range of 1is a constant, repeated evaluation of thd quantifier is quite inefficient. Instead, a special retrieval function called MAPFIELA,which can accept a listiof arguments, replaces:a forms like those of Figure 3. In thLs example replacement taXes the form ( MAPFIELD &apos;x77 &apos;1/47STOR &apos;(5043.., ...00) &apos;1976 transformaiion arises quite 0:E:ten in practice, it is sufficiently non-general that we have not augmented our inventory of logical forms by including MAPFIELD. Instead, we look on it as an implementation measure only.</abstract>
<note confidence="0.905476034482759">References Astrahan, M.M.; Blascien, M.W.; ChamberLin, D.D.; Eswaran, J.H.; Griffiths, P.P.; King, W.F.; Lone, R.A.; McJones, J.; Mehl, J.W.; Putzolu, G.R.; Traiger, I.L.; Wade, B.W., Watson, V.(1976). System R: Relat4.onal Approach to Database Management. ACM Transactions on Database Systems, Vol. 1, No. 21 June, 1976, pp. 97-137. Stanley R.(1977). in the Request System: In in Cbmputational and Mathematical Proceedings of Internamtional Conference on Computational Linguistics, Pisa, 27/VIII-1/IX 1973, PP. 585-610. Plath, Warren J.(1973). Transtormational Gramm&apos;ar and Transformational Parsing &apos;in the Request System. IBM Research RC 4396. Thomas J. Research Heights, N.Y. Plath, Warren 7.(1974). String Transiormatione in the REQUEST System American Journal of Computational Linguistics, Microfiche 8. Reiter, Ragmond(1976). 2uezy Optimization for Systems. In: COLING Proceedings. Jane J.(1973). Transformational LexiCon. In Natural Language Processing. Randall Austin, ed. AlgorithMics Press, Inc., New York, N.Y., 1973 pp. 43-60. Woods, W.A.; Kaplan, R.M.; Kash-Webber, B.(1972). The Lunar Sciences Natural Language Information System! Final Rep9rt. BBK Report No. 2.378. Bolt Beranek and Newman, Inc., Cambridge, Massachusetts. June 15, 1972. Journal of Computational Linguistics</note>
<title confidence="0.58137">ONE MORE STEP TOWARD COMPUTER LEXICOMETPY</title>
<author confidence="0.69286">NICHOLAS V FINDLER AND- SHLHWA LEE</author>
<affiliation confidence="0.990301">Computer Scince State University of New York at Buffalo</affiliation>
<address confidence="0.9531915">4226 Ridge Lea Road New Ydrk 14226</address>
<abstract confidence="0.994237187499999">We describe the continuation of an earlier work on the prbblem of lenical coverage. The objective is to prove experimentally certain mathematical conjectures concerning the relationship between the sizes of the covering and covered sets of words, and-the maximum length of dictionary definitions. The data base on which the experiments are carried out has been also extended to the full contents of an existing dictionary of computer terminology. The results of the previous and present work lay the foundations for quantitative studies on lexical valence and its relation to the frequency of usage and other principles of dictionary selection. Besides the inherent interest in these investigations, the dealt with methods of quantifying dictionary may eventually lead to dictionaries with respect to precision, compactness, and computer time and memory needed for processing. by MCS 76-24278. A4 rNTRODUCTION rirst, we shall introduce the problem define some basic terms and provide a brief historical account of past results. In order to render this paper fairly self-sufficient, 4 brief summary of the previous work, Findler Viii (1974), will also have to be given. A. monolingual dictionary may be considered economical and efficient if a small set of words are used to define a relatively large set of entries. Quantitative information as to what size vocabulary is needed to cover a given number of entries is very scarce and may be characterized by two &amp;quot;data points&amp;quot;: Enalish Dictionary published by M.P. West and J.G. Endicott in 1961 uses 1,490 lelf-defined basic words to explain some 18,000 words and 6,000 idioms, i.e. about 24,000 expressions. Thus, the size ratio is 0.062. Ogden&apos;s Basic English, published in 1933„ involves 850 words and 50 &amp;quot;international!&apos; words to defihe English words. The ratio of the covering and covered set sizes is 0.045. The basis of selection was the &amp;quot;usefulness&amp;quot; of the words employed in the definitions, as opposed to the freauency of their occurrence in some standard texts. However, neither this concept nor other principles of selection suggested by other researchers havg ever been quantitatively analyzed and made use of. We shall discuss these issues later on. 45 In order to approach the problem in definite terms, Findler (1970) considered three basic variabies: the set,RI size the set,S, of size the maximum leffgth,N, such that each word S can be defined by at most words from R. The task was formulated to find a function of at different parametric values a function of different parametric &apos;Values v AVR/AVS increment ratio and VR/VSsize ratio the following cbnjectures vere made concernina the first task: (al) Theiincrement ratio is, in general, less than one. (a2) The increment ratio, in general, decreases as vs increases. For larae -constant values or N, approaches value asymptotically as increases. (0) The incremeflit ratio never exceeds the size ratio. points need to be-noted in this connection. An excepto rtiles (al) and (a2) would occur in dictionary does not polysemous words or homonyms as individual entries, every time a new word with many meanings or homonyms, is introduced into the covered set. Second, the cited case is an exception to rule (al) but not to (a4). When N=1, the covering and the covered sets are of the same size, i.e.. both the increratio the size equal one. not every defined by itself only. If a new word is introduced that-al- 46 ready has a synonym in the covering set, it will be defined by synonym. In this increment ratio is 0 and the size becomes less than will be clear with the descripof the data base construction on page second general task, (b) the following conjectures were also made: (b1) decreases as For any fixed value of R apptoaches a lower limit as N increases vithout bound. It seems reasonable to state in a aualitative sense that in process of a dictionary smaller VRvalues mean storage smiller tend to processing time and output volume. In order to answer &amp;quot;What are the optimum Values of VRand N for a given liww.1==t for a certain (family of) computer applications on a machine with a given cost structure?&apos; one has to consider the interrelation of the above three basic variables and to compute three entities: index(roughly, the number of different meanings) elements in the covered set, the valence(roughly capability of being substituted for another of the in the coverina set, and the of dccurenceof the elements of both sets. Quantitative investigations of the last three dictionary variables are planned to f011ow the stage of our study. BASE AND THE PROnRAM have eYtended the data base in our work, 47 Findler and Viii (1.974), The whole contents ot tne aictlonary on computer technoloay, Chandor (1970), is now included in the present study. Its structure, AAther simple and uniform, is described below. First, some general principles of data base constructiop are outlined. Eve a eiement of the covered set is considered a single laical item, regardless of the number of words the original dictionary entry consists of. Also1 eacn word is coded as a stria of at most 10 characters (containable in one CDC Cyber computer word). The abbreviations are still easy to Tread with relatively short practice. Only the dominant meaning of paysemous terms was dealt with. Each entry has thus one meaning and one definition. Terms in the definitions (elements of the covering set) are also gonsidored lexical items, i.e. even multiword entities appear as a single unit and are represented by at most 10 characters, The basic vocabulary, that is the covering set, consists of elements that also appeemin the covered set y In our particular case, they are non-technical words used to aefine the technical terms of the computer dictionarV. A definite distinction was between woraaand words(also called operators), The latter were not included in the covering set nor were they counted in determining the length of definitions. Hence, tw_h* covering set consists only of content words. The function words indicate grammatical and loaical relationships between the words contributing to the content. 48 They belong to 11 categories: 1) prepositions, 0.0. of, in, to; 2) conjunctions, e.g. and, or, if; 3) the relative pronoun which; 4) combinations of preposition and relative prdnoun, e.g. in which,by which; 5) present participles eauivalent to a nreposition, e.g. representing, combinations of participle and preposition, consisting of, opposed to, applied to; combinations of adjective and preposition, e.a. of, equal to; combinations of noun and nreposition, e.g. of; 9) combinations of preposition, noun, and preposition, e.a. terms of,bv means of, in the form of; 10) prepositional phrases associated with a following e.g, to, to, in order to 11) other frequently used purely functional expressions, e.g. example,namely, as. Actually, the function words were replaced by code numbers in the dictionary. The code numbers were assigned consecutively the function words-were needed durina the construction diAta base so that the order is purely random. A complete list of the 121 function words used, toaether with their code numbers, is given in TabSe I. 49 r INSERT TABLE I ABOUT HERE The original definitions were somewhat simplified and standardized. In this process, articles were omitted (many languages do very well without them). On the other hand, relationships were made Nouns are represented in singular, thus avoidim another dictionary entry for plural or, what would be worse, programming a &amp;quot;grammar&amp;quot;. Likewise. finite verb forma are represented in third person plural pretent iAdicative active. Avoiding the third person singular eliminates, another dittionary entry, and avoiding thg passive voice eliminates a great many participles, which otherwise would have to be entered. Of course, present .and past participles (the former identical to gerund in form) could not always be avoided and had to be entered in the dictionary where needed. Auxiliary verbs were automatically eliminated by avoiding pompound tenses and the passive voice. Finally, &amp;quot;to do&amp;quot; associated with negationt was simply omitted. Some examples 61411 make the encodina process clear. Original dictionary entry: aberration A defect in the electronic lens system of a cathode ra? tube. Definition in the data base: DEFECT (in) SYSTEM (of) ELECTRONIC LENS (of) CATHRAYTUB is equivalent to 62. if 2. of 63. among 3. in 64. by 4. in terms of 65. namely 5. using 66. related to 6. and 67. concerned with 7. which 68. based on 8. in which 69. constituting 9. between 70. resulting from 10. to 71. set of 11. or 72. including</abstract>
<note confidence="0.772099375">12. from 73. followed by 13. used to 74. provided by 14. necessary to 75. developed by 15b part of 76. assigned to 16. consisting of 77. referred to 17. containing 78. on wnicn 18. capable of 79, used as 19. by means of 80. in the form of</note>
<abstract confidence="0.8748181">20, opposed to 81. from which 21. when 82. into which 22. on 83. number of 23. so that 84. less 24. in order to 85. defining 25. exclusive of 86. known as 26. for 87. performing 27. pertaining to 88. performed by 28. under 89. independeht of 29. as 90. cnosen by</abstract>
<intro confidence="0.521919">30. such as 91. for which</intro>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="false">
<title>System R: Relat4.onal Approach to Database Management.</title>
<date>1976</date>
<journal>ACM Transactions on Database Systems,</journal>
<booktitle>in Cbmputational and Mathematical Lingustics, Proceedings of the Internamtional Conference on Computational Linguistics,</booktitle>
<volume>1</volume>
<pages>97--137</pages>
<editor>Astrahan, M.M.; Blascien, M.W.; ChamberLin, D.D.; Eswaran, m.p.; Gray, J.H.; Griffiths, P.P.; King, W.F.; Lone, R.A.; McJones, J.; Mehl, J.W.; Putzolu, G.R.; Traiger, I.L.; Wade, B.W., Watson, V.(1976).</editor>
<publisher>AlgorithMics Press, Inc.,</publisher>
<location>Pisa, 27/VIII-1/IX</location>
<contexts>
<context position="2424" citStr="(1976)" startWordPosition="364" endWordPosition="364">is system is called a logical form. The baslc method of evaluation of logical forms is the generate and test&amp;quot; paradigm, used, for oufample in the LUNAR system (Woods, Kaplan and Nash-Webber, 1972), although thetimplementation must be fairly tificient in order tot be practical on a moderate site data base. The basic idea is to keep track of the equivalence telationships betwlen the variables in the logical fort and associated constants, and Use this information to derive from the data base the extensions of the predicates contained in the logical form. A similar proposal has been made by Reiter(1976). The logical forms and the process by which candidate sets are computed from these forms ,#re described in considelable detail. We believe it should not be necessary for a computational linguistics project to describe operations beyond the last level of formal representation in order Sol an outsider to understand exactly how a system operates sufficiently well that he.can pzedict its behavior. Although we have attempted to achieve that, we still have a considerable way to go,. 4 This paper describes how the process of generatima response given an underlying representaion foir an input questio</context>
<context position="9866" citStr="(1976)" startWordPosition="1554" endWordPosition="1554">ed in our early systems, involves checking pre-selected lists of objects or, in tht worst case, all the objects kno;.in to the system, to see, if they satiSfy. the query predicates. It is computationally impractical except ±or small data bases. Our current&apos; varlant oi this method is much more efficient. The basic idea is to keep track of the equivalence relationships between the vaxiables in the logical form and associated constants, and use this infoTmation to derive the extensions ot the predicates ,contained in the logieal form fIam tne ciata base. A similar-proposal has been made by Reltez(1976) We do not however, mace such extensive use of queil transformations as Reiter outlined. Logical forms In order to describe the ev.altation process, it is necessary to describe the logical form in somewhat more detail, referring for a&apos;n example again to Figure 2. In the first place, except or the set-±orming function setx, which takes as arguments a variable name and a proposition, all other well-formed fotmulas are composed of predicates and their arguments. Some of the predicates are perfectly ordinary like greaterthan. Some are quantifiers, like formtaeast, which takes a limit argument n, a</context>
</contexts>
<marker>1976</marker>
<rawString> Astrahan, M.M.; Blascien, M.W.; ChamberLin, D.D.; Eswaran, m.p.; Gray, J.H.; Griffiths, P.P.; King, W.F.; Lone, R.A.; McJones, J.; Mehl, J.W.; Putzolu, G.R.; Traiger, I.L.; Wade, B.W., Watson, V.(1976). System R: Relat4.onal Approach to Database Management. ACM Transactions on Database Systems, Vol. 1, No. 21 June, 1976, pp. 97-137. Petrick Stanley R.(1977). Semantic Interpretation in the Request System: In in Cbmputational and Mathematical Lingustics, Proceedings of the Internamtional Conference on Computational Linguistics, Pisa, 27/VIII-1/IX 1973, PP. 585-610. Plath, Warren J.(1973). Transtormational Gramm&apos;ar and Transformational Parsing &apos;in the Request System. IBM Research Report RC 4396. Thomas J. Watson Research Center, Yorktown Heights, N.Y. Plath, Warren 7.(1974). String Transiormatione in the REQUEST System American Journal of Computational Linguistics, Microfiche 8. Reiter, Ragmond(1976). 2uezy Optimization for Question-Answering Systems. In: COLING 76, Proceedings. PAGE 42 Robinson, Jane J.(1973). An Inverse Transformational LexiCon. In Natural Language Processing. Randall Austin, ed. AlgorithMics Press, Inc., New York, N.Y., 1973 pp. 43-60. Woods, W.A.; Kaplan, R.M.; Kash-Webber, B.(1972). The Lunar Sciences Natural Language Information System! Final Rep9rt. BBK Report No. 2.378. Bolt Beranek and Newman, Inc., Cambridge, Massachusetts. June 15, 1972. They belong to 11 categories: 1) prepositions, 0.0. of, in, to; 2) conjunctions, e.g. and, or, if; 3) the relative pronoun which; 4) combinations of preposition and relative prdnoun, e.g. in which, to which, by which; 5) present participles eauivalent to a nreposition, e.g. using, containinc&amp;quot;, representing, 6) combinations of participle and preposition, e.TA consisting of, opposed to, applied to; 7) combinations of adjective and preposition, e.a. capable of, exclusive of, equal to; 8) combinations of noun and nreposition, e.g. _Eart_olfset of, number of; 9) combinations of preposition, noun, and preposition, e.a. in terms of, bv means of, in the form of; 10) prepositional phrases associated with a following infinitive, e.g, used to, necessary to, in order to 11) other frequently used purely functional expressions, e.g. for example, namely, known as. Original dictionary entry: aberration A defect in the electronic lens system of a cathode ra? tube. Definition in the data base: DEFECT (in) SYSTEM (of) ELECTRONIC LENS (of) CATHRAYTUB</rawString>
</citation>
<citation valid="false">
<title>is equivalent to 62.</title>
<note>if 50</note>
<marker>1.</marker>
<rawString>is equivalent to 62. if 50</rawString>
</citation>
<citation valid="false">
<journal>of</journal>
<volume>63</volume>
<pages>among</pages>
<marker>2.</marker>
<rawString>of 63. among</rawString>
</citation>
<citation valid="false">
<note>in 64. by</note>
<marker>3.</marker>
<rawString>in 64. by</rawString>
</citation>
<citation valid="false">
<note>in terms of 65. namely</note>
<marker>4.</marker>
<rawString>in terms of 65. namely</rawString>
</citation>
<citation valid="false">
<authors>
<author>using</author>
</authors>
<note>related to</note>
<marker>5.</marker>
<rawString>using 66. related to</rawString>
</citation>
<citation valid="false">
<note>concerned with</note>
<marker>6.</marker>
<rawString>and 67. concerned with</rawString>
</citation>
<citation valid="false">
<authors>
<author>which</author>
</authors>
<note>based on</note>
<marker>7.</marker>
<rawString>which 68. based on</rawString>
</citation>
<citation valid="false">
<note>in which 69. constituting</note>
<marker>8.</marker>
<rawString>in which 69. constituting</rawString>
</citation>
<citation valid="false">
<authors>
<author>between</author>
</authors>
<note>resulting from</note>
<marker>9.</marker>
<rawString>between 70. resulting from</rawString>
</citation>
<citation valid="false">
<note>to 71. set of</note>
<marker>10.</marker>
<rawString>to 71. set of</rawString>
</citation>
<citation valid="false">
<authors>
<author>or</author>
</authors>
<pages>including</pages>
<marker>11.</marker>
<rawString>or 72. including</rawString>
</citation>
<citation valid="false">
<authors>
<author>from</author>
</authors>
<note>followed by</note>
<marker>12.</marker>
<rawString>from 73. followed by</rawString>
</citation>
<citation valid="false">
<note>used to 74. provided by</note>
<marker>13.</marker>
<rawString>used to 74. provided by</rawString>
</citation>
<citation valid="false">
<title>necessary to 75. developed by 15b part of 76.</title>
<note>assigned to</note>
<marker>14.</marker>
<rawString>necessary to 75. developed by 15b part of 76. assigned to</rawString>
</citation>
<citation valid="false">
<title>consisting of 77.</title>
<note>referred to</note>
<marker>16.</marker>
<rawString>consisting of 77. referred to</rawString>
</citation>
<citation valid="false">
<title>containing 78. on wnicn</title>
<marker>17.</marker>
<rawString>containing 78. on wnicn</rawString>
</citation>
<citation valid="false">
<note>capable of 79, used as</note>
<marker>18.</marker>
<rawString>capable of 79, used as</rawString>
</citation>
<citation valid="false">
<title>by means of 80. in the form of 20, opposed to 81. from which</title>
<marker>19.</marker>
<rawString>by means of 80. in the form of 20, opposed to 81. from which</rawString>
</citation>
<citation valid="false">
<authors>
<author>when</author>
</authors>
<note>into which</note>
<marker>21.</marker>
<rawString>when 82. into which</rawString>
</citation>
<citation valid="false">
<authors>
<author>on</author>
</authors>
<note>number of</note>
<marker>22.</marker>
<rawString>on 83. number of</rawString>
</citation>
<citation valid="false">
<note>so that 84. less</note>
<marker>23.</marker>
<rawString>so that 84. less</rawString>
</citation>
<citation valid="false">
<note>in order to 85. defining</note>
<marker>24.</marker>
<rawString>in order to 85. defining</rawString>
</citation>
<citation valid="false">
<title>exclusive of 86. known as</title>
<marker>25.</marker>
<rawString>exclusive of 86. known as</rawString>
</citation>
<citation valid="false">
<note>for 87. performing</note>
<marker>26.</marker>
<rawString>for 87. performing</rawString>
</citation>
<citation valid="false">
<title>pertaining to 88.</title>
<note>performed by</note>
<marker>27.</marker>
<rawString>pertaining to 88. performed by</rawString>
</citation>
<citation valid="false">
<authors>
<author>under</author>
</authors>
<note>independeht of</note>
<marker>28.</marker>
<rawString>under 89. independeht of</rawString>
</citation>
<citation valid="false">
<authors>
<author>as</author>
</authors>
<note>cnosen by</note>
<marker>29.</marker>
<rawString>as 90. cnosen by</rawString>
</citation>
<citation valid="false">
<title>such as 91.</title>
<note>for which</note>
<marker>30.</marker>
<rawString>such as 91. for which</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>