<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<title confidence="0.5140365">
Using Descriptions of Trees in a Tree
Adjoining Grammar
</title>
<author confidence="0.985942">
K. Vijay-Shanker*
</author>
<affiliation confidence="0.97819">
University of Delaware
</affiliation>
<bodyText confidence="0.999119722222222">
This paper describes a new interpretation of Tree Adjoining Grammars (TAG) that allows the
embedding of TAG in the unification framework in a manner consistent with the declarative
approach taken in this framework. In the new interpretation we present in this paper, the objects
manipulated by a TAG are considered to be descriptions of trees. This is in contrast to the traditional
view that in a TAG the composition operations of adjoining and substitution combine trees.
Borrowing ideas from Description Theory, we propose quasi-trees as a means to represent partial
descriptions of trees. Using quasi-trees, we are able to justify the definition of feature structureâ€”
based Tree Adjoining Grammars (FTAG) that was first given in Vijay-Shanker (1987) and Vijay-
Shanker and Joshi (1988). In the definition of the FTAG formalism given here, we argue that a
grammar manipulates descriptions of trees (i.e., quasi-trees); whereas the structures derived by
a grammar are trees that are obtained by taking the minimal readings of such descriptions. We
then build on and refine the earlier version of FTAG, give examples that illustrate the usefulness of
embedding TAG in the unification framework, and present a logical formulation (and its associated
semantics) of FTAG that shows the separation between descriptions of well-formed structures and
the actual structures that are derived, a theme that is central to this work. Finally, we discuss
some questions that are raised by our new interpretation of the TAG formalism: questions dealing
with the nature and definition of the adjoining operation (in contrast to substitution), its relation
to multi-component adjoining, and the distinctions between auxiliary and initial structures.
</bodyText>
<sectionHeader confidence="0.992102" genericHeader="abstract">
1. Introduction
</sectionHeader>
<bodyText confidence="0.999682571428571">
A number of grammatical systems and linguistic theories, such as Functional Unifi-
cation Grammars (FUGs), Lexical Functional Grammars (LFGs), Generalized Phrase
Structure Grammars (GPSGs), and Head-driven Phrase Structure Grammars (HPSGs),
are said to take the unification-based approach to grammars. A common aspect shared
by these grammars or theories is that they are based on specifying constraints that de-
fine well-formed structures. This work discusses viewing Tree Adjoining Grammars
(TAG) in such a manner and embedding it in a unification-based framework.
Tree Adjoining Grammars (TAG) were first introduced by Joshi, Levy, and Taka-
hashi (1975). A preliminary study of this formalism, from the point of view of its
formal properties and linguistic applicability, was carried out by Joshi (1985). A de-
tailed study of the linguistic relevance of TAG was done by Kroch and Joshi (1985).
Abeille et al. (1990) discuss a fairly substantial grammar for English using the lexi-
calized approach to TAG that was originally proposed by Schabes, Abeille, and Joshi
(1988).
</bodyText>
<affiliation confidence="0.460313">
* Department of Computer and Information Sciences, University of Delaware, Newark, DE 19716.
</affiliation>
<note confidence="0.8299635">
(i) 1992 Association for Computational Linguistics
Computational Linguistics Volume 18, Number 4
</note>
<bodyText confidence="0.999447739130435">
TAG is defined as a tree rewriting system. In the definition given traditionally,
a TAG is defined by a finite set of trees and an operation called adjoining to com-
pose trees. One of the basic intuitions underlying the use of the TAG formalism is
that these trees provide a large enough structure that most cooccurrence restrictions
(dependencies) can be stated over (localized within) these trees. Predicate-argument,
wh-dependencies, and filler-gap dependencies are examples of dependencies that can
be localized in a TAG.
Our aim is to view a TAG as defining constraints on well-formed structures (ac-
cording to the linguistic intuitions being instantiated in the grammar). In this paper,
we argue that if we chose to interpret the objects manipulated by a TAG as trees (as
is done currently) then it is not possible to embed TAG in a unification framework
in a straightforward manner. We show that this follows from the fact that the adjoin-
ing operation on trees is such that it does not preserve the structural relationships
that have been specified in the structures being combined. We argue that instead we
should view the objects manipulated (to be distinguished from derived) by a TAG as
(partial) descriptions of trees. In particular, these descriptions include the partial spec-
ification of domination, as in description theory or D-theory (Marcus, Hindle, and Fleck
1983), in addition to the specification of immediate domination. We argue that this is a
well-motivated interpretation that is consistent with certain assumptions made in the
lexicalized approach to TAG. We introduce quasi-trees as a means to structurally de-
pict partial specifications of trees. Using this interpretation, we show that the resulting
structure obtained after adjoining preserves the structural relationships described in
the structures being composed.
</bodyText>
<subsectionHeader confidence="0.985169">
1.1 Outline of the Paper
</subsectionHeader>
<bodyText confidence="0.9991955">
For the sake of contrasting the two definitions, we start by giving the currently used
definition of TAG. In Section 2, we show that this definition is not consistent with the
assumptions made in the unification framework. We propose a novel way of interpret-
ing the basic objects of a TAG, borrowing ideas from description theory (D-theory).
By means of an example, we introduce the notion of quasi-trees. We then show how
TAG can be embedded in a unification-based framework. This interpretation of the
objects manipulated by a TAG grammar as quasi-trees not only leads to our current
definition of FTAG, but also explains the earlier definition (Vijay-Shanker 1987; Vijay-
Shanker and Joshi 1988). In Section 3, we give examples to show why the introduction
of feature structures and unification adds to the descriptive capabilities of TAG. In
particular, we focus on the implementation of the so-called adjoining constraints (that
determine locally which structures can be used for adjoining and whether adjunction
is mandatory). We will show that not only can adjoining constraints be specified in
a linguistically more appealing manner now, but also that in several cases redundant
specifications of structural descriptions can be avoided.
In Section 5, we consider some possible implications of the new interpretation of
the formalism proposed here. One particular question that arises is whether the oper-
ations of adjoining and even multi-component adjoining (as used in Multi-component
Tree Adjoining Grammar) can be considered to be the same as the substitution oper-
ation where the characteristics of the adjoining and multi-component adjoining oper-
ations can be derived from the fundamental (linguistic) assumptions that concern the
make-up of elementary objects of a grammar. Questions related to this issue, such as
whether a distinction between initial and auxiliary structures (the two types of basic
structures used in a TAG) needs to be made, are also raised. Further work along the
lines suggested in this section depends on investigation of certain linguistic issues
involved in the use of the TAG formalism that is beyond the scope of this work. Al-
</bodyText>
<page confidence="0.995742">
482
</page>
<figure confidence="0.9975755">
K. Vijay-Shanker Using Descriptions of Trees in a Tree Adjoining Grammar
az
al
a3 :
NP
nO
dea
NP!. VP
v0 NIP;
NP1 VP
</figure>
<figureCaption confidence="0.992972">
Figure 1
Initial trees.
</figureCaption>
<bodyText confidence="0.999985166666667">
though we provide no definitive answers to these questions, these topics are raised
in this paper because they are brought out by the new interpretation of the TAG
formalism that we propose.
In Section 4, we propose a logical formulation of FTAG grammars (along the lines
of the logical formulation of Functional Unification Grammars given by Rounds and
Manaster-Ramer [19871) and then show how the denotation of a FTAG grammar can
be obtained. The logical formulation is given, in part, to show the separation between
the descriptions of well-formed structures (as specified in a FTAG grammar) and the
models that satisfy these descriptions.
We would like to note that the work presented in this paper concerns a formalism
and not linguistic issues. A deliberate attempt has been made to only discuss the
TAG formalism in general terms rather than focusing on linguistic issues. By doing
so, our intent is to pay closer attention to the formalism itself and uncover the aspects
of the definition of TAG that are stipulations and those that fall out as a corollary
of a formalism that tries to localize dependencies. The use of linguistic examples in
this paper by no means indicates the suitability of any linguistic theories. The only
assumption that we make is that a grammar will attempt to localize dependencies to
the extent possible.
</bodyText>
<subsectionHeader confidence="0.98793">
1.2 Introduction to Tree Adjoining Grammars
</subsectionHeader>
<bodyText confidence="0.994178666666667">
A Tree Adjoining Grammar (TAG) as defined traditionally is said to be specified by a fi-
nite set of elementary trees. Unlike the string rewriting formalisms that write recursion
into the rules that generate the phrase structure, a TAG factors recursion and depen-
dencies into a finite set of elementary trees. The elementary trees in a TAG correspond
to minimal linguistic structures that localize the dependencies such as subcategoriza-
tion, and filler-gap. There are two kinds of elementary trees: initial trees and auxiliary
trees. Originally, initial trees (e.g., al and a2 in Figure 1) were defined to correspond
to minimal sentential structures. Therefore, the root of an initial tree was required to
be labeled by the symbol S. With the advent of lexicalized TAG and the use of the
substitution operation, this assumption is no longer made (see a3).
Auxiliary trees (012 in Figure 2) are usually defined to correspond to minimal
recursive constructions. Thus, if the root of an auxiliary tree is labeled by a nonterminal
</bodyText>
<page confidence="0.998775">
483
</page>
<figure confidence="0.981857166666667">
Computational Linguistics Volume 18, Number 4
/82
VP
VP* adv
NP1 VP
v0 S*
</figure>
<figureCaption confidence="0.97601">
Figure 2
</figureCaption>
<bodyText confidence="0.967523103448276">
Auxiliary trees.
symbol, A, then there is a distinguished node, called the foot node, in the frontier of
this tree that is also labeled by A. The foot nodes of auxiliary trees, /31 and /32, are
indicated with an asterisk.
The adjoining operation is used to compose trees. An auxiliary tree, whose root
and foot node are labeled A, can be adjoined at a node that is also labeled A. Adjoining
may be described as follows: the subtree below the node of adjunction is excised; the
auxiliary tree is inserted in its place; and the excised subtree is substituted at the foot
node of the inserted auxiliary tree.
Figure 3 shows the result of adjoining /31 at the VP node in al (to yield -yl) as well
as the adjunction of /32 in az to yield -y2. The latter example illustrates a key feature of
TAG, i.e., localization of dependencies. The tree a2 indicates the topicalization of the
object, localizing the filler-gap dependency. Notice that although the dependent nodes
(the two nodes labeled NP,) are stretched apart in -y2, the adjoining operation does not
alter any dependency present in the original trees being composed.
1.2.1 Lexicalized Approach to TAG and Substitution. In the traditional approach
to TAG, adjunction was the only operation used to compose trees. In the lexicalized
approach to TAG as proposed by Schabes, Abeille, and Joshi (1988), the substitution
operation is also used. In this approach, elementary trees are associated with lexical
items. These lexical items (indicated by 0) are said to be the anchors of the trees. These
trees define the arguments required by the anchor. Figure 1 shows two initial trees
al and a2 whose anchors are transitive verbs. The two trees specify the arguments
required by the anchor (a transitive verb) and describe the structure for the simple
declarative form and for the case where the object is topicalized. Note in both these
trees, the argument (subject and object NP) nodes are not elaborated any further. This
elaboration is done instead by substituting other initial trees at these nodes. The tree -y3
(Figure 3) is the result of substituting a3 at the subject NP node in al. In a lexicalized
TAG, frontier nodes labeled by nonterminals (with the exception of foot nodes) are
marked for substitution (specified by 1).
</bodyText>
<footnote confidence="0.3617485">
1.2.2 Adjoining Constraints. So far, the only restriction we have placed on the set of
auxiliary trees that can be adjoined at a node is that the label of that node must be the
same as the label of the root (and the foot) node of the auxiliary tree. However, often
it becomes necessary to allow only a subset of such auxiliary trees to be adjoined at
</footnote>
<page confidence="0.998008">
484
</page>
<figure confidence="0.992291285714286">
K. Vijay-Shanker Using Descriptions of Trees in a Tree Adjoining Grammar
S
&apos;72
NP1
NP1 VP NP1 VP NPi 73
VP adv
v NP4.
</figure>
<figureCaption confidence="0.875936">
Figure 3
</figureCaption>
<subsectionHeader confidence="0.763754">
Some examples of adjoining and substitution.
</subsectionHeader>
<bodyText confidence="0.999599307692308">
a node. In a TAG, associated with each node is a list of auxiliary trees that can be
adjoined at that node. This specification of a set of auxiliary trees with each node is
called the Selective Adjoining (SA) constraints of the nodes. A node is said to have a
Null Adjoining (NA) constraint if no auxiliary tree is allowed to be adjoined at that
node. An NA constraint is specified by associating an empty set with a node. In current
TAG literature NA constraints are therefore said to be a special case of SA constraints.
In addition, for some nodes it is necessary to insist that adjunction is mandatory at
a node. In such a case, we say that the node has an Obligatory Adjoining (OA)
constraint.
A more detailed description of TAG, the use of adjoining constraints, their prop-
agation during derivation, and their usefulness in providing linguistic analyses may
be found in Kroch and Joshi (1985). At this point we would like to note that by the
specification of such adjoining constraints are stipulations of the adjunction possibil-
</bodyText>
<page confidence="0.997553">
485
</page>
<note confidence="0.827016">
Computational Linguistics Volume 18, Number 4
</note>
<bodyText confidence="0.998403571428572">
ities at that node. On the other hand, we will see that in the version of FTAG we
define here, decisions such as the choice of auxiliary trees that can be adjoined at
a node or whether adjunction is mandatory at a node follows from the assertions
(stated in terms of feature structures) about the linguistic features of individual nodes,
rather than being specific to the adjoining operation. In fact, in this paper, we would
like to highlight this issue while addressing the usefulness of this &amp;quot;unification-based
approach&amp;quot; to TAG.
</bodyText>
<sectionHeader confidence="0.644859" genericHeader="method">
2. A Unification-Based Approach to Tree Adjoining Grammars (FTAG)
</sectionHeader>
<bodyText confidence="0.999959">
In the unification-based approach to grammars, the rules of a grammar are viewed as
constraints that define well-formedness. At any point during derivation, the structures
built reflect the information known at (or the constraints specified up to) that point.
Further derivation leads to more constraints being specified. We begin this section by
illustrating why the traditional definition of TAG is incompatible with this aspect of
the unification-based approach to grammars.
</bodyText>
<subsectionHeader confidence="0.999983">
2.1 Adjoining of Trees
</subsectionHeader>
<bodyText confidence="0.999743105263158">
Given al (Figure 1), we can state that there is a relationship between the S node and
the v node that is fixed by the fact that we have stated that ai is a tree. For instance,
one of the assertions we can make is that (since we consider al as a tree) following two
immediate domination (ID) links from the S node leads us to the v node. Now consider
the tree 11 (Figure 3) obtained by adjoining at the VP node (of ai) that lies along the
path from the S node to the v node. In although the S and v node are still present,
the v node is no longer the grandchild (two ID links) of the root node. This example
illustrates that, in general, the adjoining operation on trees nullifies certain assertions
that can be made about the component trees (that are composed). The reason that the
traditional definition of TAG is not compatible with the unification approach is that
it defines that the grammar manipulates (composes) fully specified structures (trees
in this case) rather than partially specified structures. The composition operation of
adjoining creates a new structure that does not maintain all of the properties that held
in the original (fully specified) structures of which it is composed.
In the rest of the paper we will discuss an alternate definition of TAG and argue
that our proposed definition is more compatible with the unification approach. Unlike
the traditional definition of TAG, we do not consider the objects manipulated by a
grammar to be trees. Rather, we will say that although the elementary objects do
specify tree structures, they do so only in a partial fashion.
</bodyText>
<subsectionHeader confidence="0.999917">
2.2 A New Interpretation of TAG Objects
</subsectionHeader>
<bodyText confidence="0.999892">
We start by examining the nature of objects that are manipulated by a TAG. The only
assumption we will make about these objects is that the elementary objects of the
grammar give a sufficiently enlarged domain of locality that allows localization of
statements of dependencies such as subcategorization, and filler-gap.
</bodyText>
<listItem confidence="0.649759428571429">
2.2.1 Quasi-Trees. Let us reconsider al (shown in Figure 1), which is assumed to be
one of the tree structures associated with a transitive verb. Let us consider which
information captured in this tree is important for asserting the cooccurrence depen-
dencies involved. We must represent the obligatory arguments required by a transitive
verb. If we look at the relationship between the obligatory arguments and the anchor
captured by the tree al, we notice that the sentence structure is formed by combining
the subject NP node with a VP node. This information is often captured by a rule
</listItem>
<page confidence="0.986295">
486
</page>
<note confidence="0.170615">
K. Vijay-Shanker Using Descriptions of Trees in a Tree Adjoining Grammar
</note>
<bodyText confidence="0.96456">
(1): S -- NP VP. Also, notice that a VP that captures the combination of the lexical an-
chor with the other obligatory arguments must be formed. In the case of a transitive
verb, such information can be captured by a rule (2): VP â€”+ v NP. Thus we can see
that the essential information captured by al includes the simultaneous use of the two
rules and can be described by stating the relationships between the six entities (three
for each rule) involved in the rules.
These relationships can be stated by means of some assertions about the indi-
vidual entities. At this point it is useful to use some names (identifiers) to refer to
these entities) Let these names be si, npi, vpi (for the three symbols in rule (1)) and
vp2, v2, np2 (for the three symbols in rule (2)). The assertions given below (that can
be captured by the structural representation, a4, given in Figure 4) can be stated to
minimally describe a structure anchored by a transitive verb.
</bodyText>
<listItem confidence="0.92185855">
1. The label of the entity referred by s1 is S. It immediately dominates the
entities referred to by npi and vpi. npi and vpi correspond to the
occurrences of NP and VP in the right-hand side of rule (1) and hence
the immediate domination.
2. npi refers to the subject of v2 and is labeled by the symbol NP. It is one
of the obligatory arguments required by the anchor.
3. vpi is labeled by VP and is used to indicate the combination with the
subject (i.e., npi) to yield a sentence.
4. vp2 (also labeled VP), corresponds to the occurrence of VP in the
left-hand side of rule (2). It immediately dominates v2 and np2. vp2 is
used to indicate the result of the combination of the transitive verb with
the obligatory object argument (given by np2).
5. Since the combination of the anchor with the subcategorized arguments
(given by npi and np2) will yield a sentence, the s1 dominates v2 by a
path of length at least two. Furthermore, the nodes named vpi and vp2
lie on the path from the v2 node to the s1 node. Since vpi must dominate
v2, we can conclude that the node named vpi must dominate the node
named vp2 (indicated by a dashed link in a6) and thus, in turn the v2
node. Immediate domination, on the other hand, is represented in the usual
fashion.
</listItem>
<bodyText confidence="0.999553454545455">
Here we define the domination relation to be reflexive (i.e., a node dominates
itself) in addition to being transitive and antisymmetric. Therefore, we are not stating
that the nodes named as vpi and vp2 are necessarily different. Notice that the above
assertions have been made independent of TAG or the commitment to use trees for
the elementary objects. In TAG, given the decision to use trees, a (minimal) tree that
satisfies these assertions will be used. It is due to this minimality requirement that the
nodes named as vpi and vp2 are assumed to be the same.
On the other hand, the only decision we have committed to is to use structures
large enough to localize subcategorization. In this case, we have given some assertions
that describe the structure for simple declarative sentences anchored by a transitive
verb. Although compatible (though different) assertions have been made about the
</bodyText>
<footnote confidence="0.992117">
1 We adopt this practice of naming nodes following D-theory. This choice to incorporate ideas from
D-theory arose from an observation made by S. M. Shieber.
</footnote>
<page confidence="0.997728">
487
</page>
<figure confidence="0.984642916666667">
Computational Linguistics Volume 18, Number 4
o5
NPS age,. 52
S 53
o4
NP.. VP â€”vpL NP1 VP
npi 1
VP
./A\
vet NP
VP â– ereâ€”vp2
VO NP.1. ---n p2
</figure>
<figureCaption confidence="0.994997">
Figure 4
</figureCaption>
<bodyText confidence="0.9966856">
The domination relations.
nodes referred by vpi and vp2, (from these assertions) we cannot conclude whether
these nodes are different or are the same node. In fact, this is the reason that structures
such as (which represents the case where the two are different) in Figure 3 as well
as ai (where vpi and vp2 both refer to the same node), given in Figure 1, can both be
derived. The structure given by a4 (with the dashed link indicating possible separation)
partially describes the phrase structure tree for both cases. Since vpi and vp2 can both
refer to the same node, to avoid confusion, henceforth we will call them quasi-nodes.
Thus a node such as the VP node in ai (Figure 1) is represented by a pair of quasi-
nodes in a4. We will refer to these quasi-nodes as the top (for example, vpi) quasi-node
and the bottom (vp2) quasi-node. Structures such as a4 will be called quasi-trees to
indicate that they are not trees but (partial) descriptions of trees.
A second example that also motivates the proposed interpretation of TAG where
the elementary objects are taken to be descriptions of trees (quasi-trees with domina-
tion and immediate domination links) rather than trees involves the tree structure in
the case of topicalization. The topicalization of the object of a transitive verb can be
described by the quasi-tree a5 (in Figure 4), which is the counterpart of a2 (Figure 1)
used traditionally in TAG. If the elementary structures in a TAG are supposed to de-
pict the localization of dependencies such as those arising due to subcategorization
and movement, then we claim structures like a5 are indeed the appropriate structures
to consider. For instance, no treatment of topicalization can justify the identification of
the nodes referred to by s2 and s3. Thus, a pair of quasi-nodes is appropriate for their
representation. As in the case of vpi and vp2 quasi-nodes in a4, one can only claim
that s2 quasi-node dominates s3 quasi-node (again, by domination, we also allow for
the possibility that s2 and s3 can refer to the same node). It may be interesting to
contrast this lack of information in a5 (whether or not they refer to the same node)
with the use of functional uncertainty in LFG (Kaplan and Maxwell 1988) to account
for long-distance dependency
In order to consistently maintain the distinction between descriptions of trees
with trees, while discussing the proposed interpretation of TAG we will use the terms
</bodyText>
<page confidence="0.996298">
488
</page>
<figure confidence="0.813534818181818">
K. Vijay-Shanker Using Descriptions of Trees in a Tree Adjoining Grammar
as a7 :
NP 1 [head: agr : &lt;I&gt; (1
VP [head: [sub.1 [agr : &lt;14
VP [head : &lt;2&gt; [1
NP1 [head [agr : &lt;2&gt; (1
VP [head: [sub): [agr :.c2&gt;1
[head: &lt;I&gt;1
/N.
&apos;14 [head: &lt;I&gt; [1 NP-4.
vO head : &lt;2..A NP.
</figure>
<figureCaption confidence="0.813007">
Figure 5
</figureCaption>
<bodyText confidence="0.784010666666667">
Associating feature structures with quasi-nodes.
initial quasi-tree, auxiliary quasi-tree, quasi-root, and quasi-foot in place of initial
tree, auxiliary tree, root node, and foot node, respectively.
</bodyText>
<subsectionHeader confidence="0.999993">
2.3 Associating Feature Structures with Quasi-Nodes
</subsectionHeader>
<bodyText confidence="0.999172433333333">
Let us now consider a4 given in Figure 4 and the pair of VP quasi-nodes. In the version
of FTAG formalism we define here, the feature structure that we associate with quasi-
nodes simply reflects the assertions that we make about them. For instance, suppose
a constraint VP .head.subj.agr = NP .head.agr was used in conjunction with the rule
S NP VP; and the constraint VP .head = v .head was used with the rule VP v NP.
These two rules (and associated constraint equations) when used together produce a6,
shown in Figure 5. Notice that the feature structure associated with a top quasi-node
can be considered as constraints on it (and hence a constraint on the nature of tree that
is rooted at this quasi-node) that are made on the basis of its ancestors and siblings.
Similarly, the feature structure associated with a bottom quasi-node reflects the nature
of tree that is rooted at this quasi-node (that is its descendants).
Instead of explicitly using a pair of quasi-nodes and drawing the domination
(dashed) link between them, we can also depict it in a more traditional manner found
in TAG literature (see a7 in Figure 5). In such a case a node, such as the VP node in
a7, will have two feature structures (the ones associated with the two quasi-nodes)
associated with it. This matches the previous definition of feature structureâ€”based
Tree Adjoining Grammars where these two feature structures were called the top and
bottom feature structures associated with a node. In fact, this correspondence was
independently observed by Henderson (1990) and was used in the translation of an
FTAG to a Structure Unification Grammar. When convenient, we will use &amp;quot;a node with
two associated feature structures&amp;quot; instead of &amp;quot;a pair of quasi-nodes (with one feature
structure associated with each quasi-node).&amp;quot;
If the objects manipulated by a TAG are considered as quasi-trees, a natural ques-
tion arises when one considers what would be a node in a tree as a pair of quasi-nodes.
For our current purposes, this aspect is not relevant. For instance, the auxiliary quasi-
trees, /33104105) 06 in Figure 6, are equally acceptable (well-formed structures) in the
formalism. No matter which one is used, for an auxiliary quasi-tree, we have to state
the quasi-root node and the quasi-foot node. As shown in Figure 6, for the auxiliary
quasi-trees, 037 04, 05) 06, they are given by the pairs of names vp3, vp4; vp5, vp6; vp7, vp5;
and Vp9, Vpio, respectively.
</bodyText>
<page confidence="0.997493">
489
</page>
<figure confidence="0.999655818181818">
Computational Linguistics
Volume 18, Number 4
/33: VP
vp3/1&amp;quot;
VP
VP adv0
vP5 vP9
VP VP
V1P* * adv0
vP6---*r &apos; VP*
v1)4 vP10
</figure>
<figureCaption confidence="0.96882">
Figure 6
</figureCaption>
<bodyText confidence="0.805525">
Some possible auxiliary quasi-trees.
</bodyText>
<subsectionHeader confidence="0.993461">
2.4 The Adjoining Operation
</subsectionHeader>
<bodyText confidence="0.9787155">
We will now define the adjoining operation on quasi-trees and see that (unlike pre-
viously) this operation has the property that in the resulting structure all the struc-
tural relations specified in the objects being composed are preserved. We will see that
this, in turn, allows for a straightforward embedding of TAG in the unification-based
framework. Recall that by considering a pair of quasi-nodes we allow for possible
separation. We now define the operation of adjoining as the operation that achieves
this separation. Consider a quasi-tree, as shown in Figure 7, with a pair of top and
bottom quasi-nodes referred by the names, say rit and rib respectively. In this figure, we
have deliberately chosen to indicate that feature structures (ft and fb) as labeling quasi-
nodes Ow and rib respectively). Consider a auxiliary quasi-tree, 0, with the quasi-root
node and quasi-foot node referred by the names rooto and footo as shown in Figure 7.
Adjoining 0 at the pair of quasi-nodes (nt, nb) in a is now defined by stating that the
domination relation between the pair of quasi-nodes is specified to be the same domi-
nation relation that exists between the quasi-root node of 0 and the quasi-foot node of
0. Thus, the pair of quasi-nodes (referred by the names rit and rib) get separated when
the quasi-nodes referred by Tit (rib) and rooto (footo) are identified. Adjunction is thus
defined as a pair of simultaneous substitutions.&apos; Note that the adjoining operation is
defined only if the point of adjunction is specified as a pair of quasi-nodes.
We stated that the feature structure associated with a quasi-node is an encoding of
the assertions (in terms of feature-value pairs) that are made about it. Let ft fb, &apos; f
root. and
ffoot be the feature structures that satisfy the constraints stated about the quasi-nodes
referred by rit,m,,rooto, and footo respectively. Then, because adjunction is defined as
identifying the quasi-nodes referred by Tit and rooto (as well as those referred by rib
and footo), ft and froot v (fb , and ffoot.) satisfy the constraints expressed about the same
j
quasi-node. Thus they have to be unified (as shown in Figure 8). Note that we have
motivated ft as a reflection on the constraints about the tree below the corresponding
2 In this way, we have defined adjoining to make it compatible with the traditional definition of
adjoining. Recall that in Section 1.2 adjoining in TAG was defined as substituting the auxiliary tree at
the node of adjunction with the excised subtree being substituted at the foot node. In Section 5, we
look more closely at the definition of adjoining, in particular whether the definition can be made to
follow from linguistic principles or stipulations, i.e., whether adjoining is a derived operation and not a
fundamental one.
</bodyText>
<page confidence="0.996983">
490
</page>
<figureCaption confidence="0.79126">
Figure 7
The adjoining operation in FTAG.
</figureCaption>
<figure confidence="0.9940682">
74
K. Vijay-Shanker Using Descriptions of Trees in a Tree Adjoining Grammar
Droot
â€¢
â€¢
â€¢
â€¢
Effoot fb:
a: 13:
NP.I. VP
VP
.75
adv NP.I. VP
VP adv
v NP.4 v NPL.
</figure>
<figureCaption confidence="0.986633">
Figure 8
</figureCaption>
<subsectionHeader confidence="0.506864">
Examples of the adjoining operation.
</subsectionHeader>
<bodyText confidence="0.998965142857143">
quasi-node, one that possibly arises due to the relationship of this quasi-node with its
ancestors and siblings in -y. The feature structure froot also reflects the nature of the tree
below the quasi-root node. Since these two quasi-nodes are now required to be the
same, the unification of ft with froot gives a feature structure that reflects all constraints
when the quasi-nodes are identified.
Figure 8 shows the result of adjoining at the paired VP quasi-nodes in ce4 by the
auxiliary quasi-trees 03 (resulting in -y4) and 06 eY5
</bodyText>
<subsectionHeader confidence="0.99715">
2.5 The Substitution Operation
</subsectionHeader>
<bodyText confidence="0.999959">
The substitution operation used in TAG is the same as that used in context-free gram-
mars (CFGs), where one considers a CFG as a tree-rewriting formalism rather than a
string-rewriting formalism. In this case, given two trees, the substitution operation can
be defined as the tree obtained by identifying the root node of one tree with the target
</bodyText>
<equation confidence="0.408894">
VP
VP
</equation>
<page confidence="0.64356">
491
</page>
<figure confidence="0.9943145">
Computational Linguistics Volume 18, Number 4
E frooti
</figure>
<figureCaption confidence="0.990787">
Figure 9
</figureCaption>
<bodyText confidence="0.965811">
The substitution operation.
(of the substitution operation) node appearing in the frontier of the other tree. Due
to this identification, the feature structures associated with the two nodes in question
are unified.
A similar definition will be used to define the substitution operation here. Let n
refer to a quasi-node in the frontier (see Figure 9). The substitution of 7 at the quasi-
node 77 is defined as the quasi-tree obtained by identifying the quasi-nodes 71 and
the quasi-root of 7. Thus the feature structures associated with these quasi-nodes get
unified as shown in Figure 9.
</bodyText>
<subsectionHeader confidence="0.996707">
2.6 Some Observations
</subsectionHeader>
<bodyText confidence="0.999993333333333">
We can make the following observations at this stage. The dashed link between a pair
of quasi-nodes indicates that it is possible for the two to be the same. However it is
possible to insist that such a pair of quasi-nodes are distinct. This is possible, by stating
incompatible assertions about them. On the other hand, as was noted by Marcus,
Hindle, and Fleck (1983), without explicitly stating so, we cannot make assertions about
a pair of quasi-nodes that will indicate that they are the same. These observations will
be further elaborated in Section 3 to capture obligatory adjoining (OA) constraints.
Another point that can be noted is that the adjoining operation and its use of
auxiliary trees can itself be motivated from the definition of quasi-trees. Notice that we
have introduced the concept of quasi-trees simply from the motivation of considering
structures with enlarged domains of locality in order to localize dependencies such as
subcategorization and filler-gap. In defining quasi-trees we stated that pairs of quasi-
node can be separated (i.e., they need not be the same node). If a pair of associated
quasi-nodes are to be separated by the use of a composition operation, it is easy to
see that it can only be done by an operation like adjunction, and the kind of structure
that can fit between them must have the general form of an auxiliary tree. Of course,
with the use of the new notation, the insistence that the root and foot nodes (of
auxiliary trees) be labeled by the same nonterminal symbol (as well as for the target
of adjunction) is only a stipulation (and not required by the formalism). Let us consider
the labeling of nodes (quasi-nodes) by atomic symbols (such as S, NP). In contrasting
the traditional definition of TAG with the definition given here, suppose we make a
correspondence between a node in a tree (using the traditional definition) with a pair
of quasi-nodes in a quasi-tree. It must be the case that such a pair of quasi-nodes are
labeled by the same atomic symbol (since they correspond to a single node according
to the traditional definition of TAG). Proceeding with the assumption that pairs of
quasi-nodes are labeled by the same symbol we note from the definition of adjoining
given in Section 2.4, it follows that for any auxiliary tree to be adjoined at this node,
</bodyText>
<page confidence="0.973261">
492
</page>
<bodyText confidence="0.9596208125">
K. Vijay-Shanker Using Descriptions of Trees in a Tree Adjoining Grammar
the quasi-root of this auxiliary tree and the quasi-foot must also be labeled the same.
Thus the above-mentioned stipulation is a statement that recursion is factored out of
elementary trees. In fact, as we will see, if instead of nonterminal symbols we consider
category structures (as specified in GPSG) as labeling nodes then almost all pairs of
quasi-nodes in the trees we will consider here will be labeled differently (by compatible
or incompatible categories). In fact, it is the relationship between the two labels that
will determine the subset of auxiliary trees that can be adjoined at a node. Further
discussion on this matter can be found in Section 3.
In the definition here, since we do not start by assuming that trees are composed,
there is no need to make such an assumption that a pair of quasi-nodes separated by
the domination (dashed) link must be labeled the same, unless if it follows from some
linguistic principle/intuition being expressed using the TAG formalism. At this point
we would like to note that enforcing such a stipulation has significant consequences
on the definition of the formalism. Some of these consequences are noted in Section 5,
where we contrast multi-component adjoining with adjoining.
</bodyText>
<subsectionHeader confidence="0.991966">
2.7 Objects Derived by a Grammar
</subsectionHeader>
<bodyText confidence="0.99998593939394">
We have stated that an FTAG grammar manipulates (partial) descriptions of trees (i.e.,
quasi-trees). We will now state that a grammar derives trees (with nodes labeled by
feature structures).
The composition operations of adjoining and substitution compose quasi-trees to
build more complex (and more specific) quasi-trees. Each quasi-tree obtained during
the derivation process specifies a set of trees. The set of trees derived can be obtained by
taking the circumscriptive reading of the domination relation indicated in the quasi-trees
obtained. The domination link between a pair of quasi-nodes represents the situation
that they may or may not refer to the same object. In the absence of further information
(for instance at the end of the derivation process) we shall consider that the pair of
quasi-nodes refer to the same (single) node. Thus, given a quasi-tree, its minimal
reading leads to the derived tree that is obtained by explicitly equating the related
top and bottom quasi-nodes for each pair of quasi-nodes (since by the domination
relation specified here any quasi-node dominates itself). Thus, in a derived tree (such
as a2, in Figure 1, obtained by taking the circumscriptive reading of the domination
relationship specified by the quasi-tree a5 given in Figure 4) only one feature structure
is associated with each node.
The discussion given above justifies the unification (or coindexing) of the top and
bottom feature structures of a node at the end of the derivation process as specified in
the previous definition of FTAG. Of course, due to the associativity of the unification
operation, the coindexing of the top and bottom feature structures for all nodes does
not have to be delayed until the end of the derivation process. Such unifications for
a node can be done whenever one decides that there will be no more adjunctions at
that particular node.
In the traditional definition of TAGs, a derived tree cannot have nodes with OA
constraints, even though intermediate trees can have nodes with OA constraints. This
requirement on derived trees is analogous to the use of ANY in FUG. In our current
definition a tree is derived (in the above-mentioned manner) only if the corresponding
quasi-tree has compatible feature structures associated with each pair of quasi-nodes.
If this were not the case, i.e., some pair of quasi-nodes had incompatible feature struc-
tures associated with them, then taking the circumscriptive reading of the domination
relation will not be possible. Such quasi-trees do describe a set of trees, but the one
obtained by equating the pairs of top and bottom quasi-nodes is not one of them. Obvi-
</bodyText>
<page confidence="0.991167">
493
</page>
<note confidence="0.314537">
Computational Linguistics Volume 18, Number 4
</note>
<bodyText confidence="0.9720305">
ously this should be the case, since incompatible assertions about a pair of quasi-nodes
indicates that they do refer to different nodes (and hence specify OA constraints).
</bodyText>
<subsectionHeader confidence="0.997747">
2.8 Using One (Rather than Two) Feature Structure
</subsectionHeader>
<bodyText confidence="0.999943185185185">
A question arises whether (as in standard CFG-based unification grammars) one could
associate just one (rather than two) feature structure per node, i.e., whether it is neces-
sary to consider pairs of quasi-nodes. In fact, Harbusch (1990) defined such a treatment
of TAG where only one feature structure is associated with each node.
One could argue that it may be inefficient (for instance, when implementing the
formalism as defined here) to start with the pairs of quasi-nodes and then try to merge
them eventually when possible. Strategies to improve processing may be considered
particularly if we believe that, on an average, a relatively small proportion of potential
sites will become actual targets of adjunctions during a derivation of a sentence. Then
(to improve performance) we could specify that by default the associated pair of top
and bottom quasi-nodes are to be identified. That is, we will not consider a node as
a pair of quasi-nodes unless there is reason to believe it is necessary (if adjunction
has to be performed). So we can even state that there is just one feature structure per
node, which has to be the one obtained by unifying the feature structures associated
with the top and bottom quasi-nodes. Now if adjunction takes place at a node in
some tree that has been derived, then the &amp;quot;unification&amp;quot; that has been performed has
to be undone to recover the top (relating it with its ancestors and siblings) and bottom
(based on the structure it dominates) feature structures. This undoing can be quite
complex, especially if the pair of quasi-nodes in question is a part of a derived object
rather than an elementary structure specified by the grammar. The above description
essentially captures the definition of the formalism presented by Harbusch (1990).
Another point can be made about the scheme presented above. Consider a node
whose top and bottom feature structures are incompatible and hence nonunifiable. If
we were to insist that only one feature structure were to be associated with every node
then we can only unify the compatible parts of the top and bottom feature structures
and somehow (perhaps with the use of a device like ANY) retain (effectively) the OA
constraint machinery.
</bodyText>
<sectionHeader confidence="0.504141" genericHeader="method">
3. Feature Structures and Adjoining Constraints
</sectionHeader>
<bodyText confidence="0.999766909090909">
In the traditional definition of a TAG, the adjoining possibilities at a node is deter-
mined by the association of adjoining constraints with each node. In this section we
consider how such constraints may be captured by the use of feature structures and
then contrast the two methods of determining the adjoining possibilities. Since we
attempt to contrast the adjoining possibilities, in this section we will make correspon-
dences between nodes in trees (used in the traditional definition of TAG) with pairs of
quasi-nodes that are linked by the domination (dashed) link. That is, we talk of such
pairs of quasi-nodes as the target of adjunction. Also, if we have a pair of quasi-nodes
given by m and ri2 where Th quasi-node dominates 7/2, we will say that the n2 is the
bottom quasi-node paired with ni or that ni quasi-node is the top quasi-node paired
with 772.
</bodyText>
<subsectionHeader confidence="0.81394">
3.1 OA Constraint
</subsectionHeader>
<bodyText confidence="0.9999045">
In the definition of TAG, given in Section 1.2, it was stated that if a node has an
OA constraint, then adjoining is mandatory at that node. In terms of quasi-nodes this
means that the corresponding pair of quasi-nodes must be separated. Therefore, the
use of an OA constraint at a node may be interpreted as stating that the related pair
</bodyText>
<page confidence="0.994362">
494
</page>
<figure confidence="0.999672260869565">
K. Vijay-Shanker Using Descriptions of Trees in a Tree Adjoining Grammar
76
S [tense : A
S [tense A
NP1 VP
07
S [tense : 4]
â€žor
1
S [tense : -] NP1. VP
VP
NP
PRO S [tense : &lt;1&gt; -]
win tries S [tense : &lt;1&gt;]
VP
S [tense : &lt;1&gt; â€¢ ]
tries S [tense : &lt;1&gt;]
NP VP
PRO
to
win
s 0
S [tense : 4].
</figure>
<figureCaption confidence="0.7060305">
Figure 10
&amp;quot;OA&amp;quot; constraints.
</figureCaption>
<bodyText confidence="0.99985">
of quasi-nodes are indeed distinct, i.e., there must be some feature that distinguishes
them. Hence the linguistic basis for making the claim that the node has an OA con-
straint must be stated in such a way that the feature structures on the two quasi-nodes
are incompatible. As an example, consider a8 given in Figure 10. The feature structure
of the quasi-root of a8 has a value of + for the tense attribute to specify that any tree
rooted at this quasi-node must satisfy the constraint that it describes a tensed sen-
tence. On the other hand, the feature structure of the paired bottom quasi-node has a
value of â€” for the tense attribute since it only reflects the descendants. Since these two
feature structures are incompatible, this pair of quasi-nodes has an &amp;quot;OA constraint&amp;quot;
(since it is not possible to stop the derivation process and identify the top with the
bottom quasi-node). However, 76 that results from the adjoining of 07 does not have
any pair of quasi-nodes with an &amp;quot;OA constraint.&amp;quot;
</bodyText>
<subsectionHeader confidence="0.998689">
3.2 SA Constraints
</subsectionHeader>
<bodyText confidence="0.99979325">
Recall that an SA constraint of a node lists a subset of auxiliary trees that can be
adjoined at this node. The definition of adjunction used here is stated in terms of a pair
of substitutions (and thus adjunction involves two unifications). In terms of quasi-trees,
we allow the &amp;quot;SA&amp;quot; constraints to be determined as a consequence of the unifications
required by identifications of quasi-nodes. If an auxiliary quasi-tree cannot be adjoined
at a pair of quasi-nodes, then it must be the case that there is an incompatibility among
the relevant pairs of feature structures that we unify when we attempt adjunction.
When we attempt adjunction the feature structure of the top quasi-node (in the pair
</bodyText>
<page confidence="0.992486">
495
</page>
<table confidence="0.9962307">
Computational Linguistics Volume 18, Number 4
S [tense : [tetISC : A
S [tense : S [tense :
VP A
VP NP.1. VP
VP
S [tense : &lt;1&gt; 41
thinks
S [tense
met
</table>
<figureCaption confidence="0.818645">
Figure 11
</figureCaption>
<bodyText confidence="0.9436235">
&amp;quot;SA&amp;quot; constraints.
where adjunction is attempted) and the feature structure of the quasi-root (of the
auxiliary quasi-tree) are unified, as are the feature structure associated with the bottom
quasi-node (in the pair where adjunction is attempted) and the feature structure of the
quasi-foot (of the quasi-tree being adjoined). If at least one of these unifications fails
then adjunction is not possible.
Consider 08 given in Figure 11. This quasi-tree cannot be adjoined at the pair
(s1, s2) in as (Figure 10) but can be adjoined at the pair (si 52) of a9. On the other
hand, we saw that 07 can be adjoined at the pair (si , s2) of a8. Thus we can say that
the pair (51,52) of a8 has an &amp;quot;SA constraint&amp;quot; that includes 07 but not Os.
</bodyText>
<subsectionHeader confidence="0.616217">
3.3 NA Constraints
</subsectionHeader>
<bodyText confidence="0.999675133333333">
Recall that a node with an NA constraint cannot be the target of an adjunction. Tradi-
tionally, this is specified by stating that the set of auxiliary trees that can be adjoined
at such a node is the empty set. For this reason, it is often stated that NA constraints
are special form of SA constraints.
There are two possible ways of interpreting &amp;quot;NA constraints&amp;quot; in the quasi-tree
framework. Firstly, a pair of quasi-nodes with an &amp;quot;NA constraint&amp;quot; may be interpreted
as a stipulation that insists that no quasi-tree can be adjoined at this pair; a statement
made regardless of the nature of the auxiliary quasi-trees in the grammar. This may
for instance be made if we wish to allow only certain derivation sequences. One could
argue that the reason for insisting that foot nodes of complement&apos; auxiliary trees have
NA constraints, as is the case in most TAG accounts, is to avoid certain derivation
sequences (Kroch and Joshi 1985).
On the other hand, we may also interpret the association of &amp;quot;NA constraint&amp;quot; with
a pair of quasi-nodes as a statement that none of the auxiliary quasi-trees in the
grammar matches the requirements of the type of auxiliary quasi-trees that can be
</bodyText>
<footnote confidence="0.382208">
3 A complement tree (for example, the tree i32 in Figure 2) is one where the foot node corresponds to one
of the arguments required by the anchor of the tree.
</footnote>
<page confidence="0.990677">
496
</page>
<note confidence="0.405165">
K. Vijay-Shanker Using Descriptions of Trees in a Tree Adjoining Grammar
</note>
<bodyText confidence="0.999571107142857">
adjoined at this pair (as determined by the associated feature structures). Unlike the
previous case, adjunction is not barred per se. Instead, attempting to adjoin at such
a pair will never yield well-formed structures. This is because of the nature of such
a pair and of the auxiliary quasi-trees in the given grammar. In the TAG formalism,
both these interpretations are captured by the same operational mechanism.
The first kind of NA constraint is easily stated. According to this interpretation,
for each pair of quasi-nodes with an &amp;quot;NA constraint,&amp;quot; the two quasi-nodes are indeed
the same node (since we are stating that there is no possible separation). Since the
two quasi-nodes are to be identified, the feature structure associated with the resulting
quasi-node must reflect both the relationship of the quasi-node with its ancestor (which
we assume stands for the top feature structure) as well as its relationship with its
descendants (the bottom feature structure).
Earlier we had stated that the target of an adjunction operation must be a pair
of quasi-nodes that have not been identified (i.e., merged). Suppose that a pair of
quasi-nodes (711,7/2) were merged. Let the quasi-root and quasi-foot of some auxiliary
quasi-trees /3 be given by r and f. Adjoining 0 at the pair given by m and 712 (after they
have been identified) will result in the identification of 7p with r and 772 with f and thus
r with f. If we stipulate that in all auxiliary quasi-trees, the quasi-root and quasi-foot
do not refer to the same node (i.e., the quasi-root properly dominates the quasi-foot),
then no adjunction can occur at a pair of quasi-nodes that have been identified. Thus
the identification of a pair of quasi-nodes captures &amp;quot;NA constraints&amp;quot; of the first kind.
As far as the second kind of &amp;quot;NA constraints&amp;quot; is concerned, we note that it is
only a specific case of &amp;quot;SA constraints.&amp;quot; Therefore, given a pair of quasi-nodes, if the
associated feature structures are such that no auxiliary quasi-tree can be adjoined at
this pair then it has an &amp;quot;NA constraint&amp;quot; (of the second kind). However, because of the
nature of feature structures (in that they capture only partial information), it is hard
to detect if a pair of quasi-nodes has such an &amp;quot;NA constraint.&amp;quot; In Section 3.4, we will
consider such an example.
</bodyText>
<subsectionHeader confidence="0.999566">
3.4 Comparing the Implementation of Adjoining Constraints
</subsectionHeader>
<bodyText confidence="0.999955952380953">
In the TAG formalism, selective adjoining constraints are specified by enumeration,
and hence are stipulations stating which trees can be adjoined at a node. Hence,
specifying adjoining constraints in such a way is not a linguistically appealing solution.
Obviously, such stipulations are needed because the information content of the labels
of nodes in a TAG is often insufficient to determine the trees that can be adjoined at
various nodes. In the case of FTAG, labeling of quasi-nodes by symbols such as NP, S is
only a part of information contained in the feature structures associated with them. We
associate with a pair of quasi-nodes feature structures that describe the features of the
top and bottom quasi-nodes. The fact that only appropriate quasi-trees get adjoined is
a corollary of the fact that only those consistent with these declarations are acceptable.
Additionally, in a FTAG, &amp;quot;adjoining constraints&amp;quot; can be dynamically instantiated and
are not pre-specified as in a TAG.
We will now point out some differences between the implementation of adjoining
constraints in TAG and FTAG that arise because of different methods adopted in
adjoining constraint specification. Of course, if the constraints are prespecified as in
TAG, then little work has to be done (say by a parser) to verify whether an auxiliary
tree can be adjoined at a node during the derivation process. This is not the case
in FTAG, because of dynamic instantiation of &amp;quot;constraints&amp;quot; in FTAG. For example,
instead of 137 (Figure 10), suppose we consider 139 shown in Figure 12. The result of
adjoining 09 at the pair (si , s2) of a9 is &apos;)/7. There is a pair of quasi-nodes, (s3, s4), in -y7
with values of â€” and + for the tense attribute (thus giving rise to &amp;quot;OA constraints&amp;quot;).
</bodyText>
<page confidence="0.979756">
497
</page>
<figure confidence="0.998656666666667">
Computational Linguistics Volume 18, Number 4
77
s :
s (ten. :
NP1 VP
/39 S [tense : +3 a9 : S [tense : sl VP
S [tense : S [tense; A S2 s (tâ€ž,. .1
NP.I. VP tries s Eteci&apos;s. : â€¢16â€” s4
NP. VP
VP NP 1 VP
VP
VP
S [tense : -1
v NP1
tries S met met
</figure>
<figureCaption confidence="0.938881">
Figure 12
</figureCaption>
<bodyText confidence="0.952959285714286">
Comparison of adjunction constraintsâ€”Example 1.
In a TAG grammar, the SA constraints at the root of tree corresponding to a9 would
be given to disallow this adjunction. In the case of FTAG, as shown in Figure 12, this
adjunction is allowed, because the associated unifications did not fail. Now suppose
(as one might expect) the auxiliary quasi-trees in the grammar were such that none
of them had their quasi-root with a feature structure compatible with tense: â€” and
quasi-foot with a feature structure compatible with tense: Â±. In this case, although
the adjunction of 09 was permitted, no tree can ever be derived from the result of
adjunction. In fact, until we try all possible adjunctions at the node n in -y7, we cannot
realize that adjunction of /39 at the root of a9 can result in a final acceptable tree. Thus,
the pair (53, 54) has an NA constraint of the second kind.
Now we will consider an example where specification of constraints in TAG suf-
fers in comparison with the implementation of &amp;quot;constraints&amp;quot; in FTAG. Consider the
following well-formed sentences
</bodyText>
<listItem confidence="0.998687714285714">
(1) Who did John see?
(2) Who did Peter think John saw?
(3) I wonder who John saw.
(4) I wonder who Peter thought John saw.
(5) Peter thought John saw Mary
and the following, which are not well-formed sentences.
(6) Who John saw?
</listItem>
<page confidence="0.980824">
498
</page>
<table confidence="0.927709">
K. Vijay-Shanker Using Descriptions of Trees in a Tree Adjoining Grammar
aio ZN
NP;
who NP VP
John
saw e
filo pH
NP VP NP VP #12 sax So
s. IA did
wonder Petsr v S.
think
Figure 13
Comparison of adjunction constraintsâ€”Example 2.
</table>
<listItem confidence="0.9101035">
(7) I wonder who did John see?
(8) Who Peter thought John saw.
</listItem>
<bodyText confidence="0.999905">
We will first consider a TAG account (in traditional style). The trees (without consid-
ering adjoining constraints) given in Figure 13 have been suggested in literature to
account for the well-formed sentences above. We have drawn these trees accounting
for substitution at the NP nodes.
From the well-formedness of (1) and ill-formedness of (6) it follows that the node
n of aw must have an OA constraint with 1312 in its SA constraint. On the other hand,
from the well-formedness of (3) and ill-formedness of (6) it follows that the root of aio
must have an OA constraint with Ow in its SA constraint. However, the requirement
of an OA constraint on these two nodes in a10 is mutually exclusive. Because of this,
a TAG grammar that accounts for the sentences above must have two trees, that have
exactly the same tree structure but only differ in the adjoining constraints attached at
the nodes.
Now, from the well-formedness of (5), which can be derived by adjoining On at
the root of an, we can conclude that there need not be an OA constraint on the root of
On. However, suppose we adjoin /3u. at the node n in aio such that the frontier matches
with (8). From the ill-formedness of (8) and the well-formedness of (2) we realize that
there must be an OA constraint on the root of On with ,312 in its OA constraint. Thus,
</bodyText>
<page confidence="0.993535">
499
</page>
<note confidence="0.527294">
Computational Linguistics Volume 18, Number 4
</note>
<bodyText confidence="0.996148">
again we will need two trees (corresponding to On ), with identical tree structure but
differing in the adjoining constraints.
We will see that such replication of tree structure is not necessary. Now consider
the RAG fragment (inspired by similar treatment in Abeille [19911) given in Figure 14.
If the feature structures of s1 and s2 quasi-nodes of oe12 are unified then the other pair
</bodyText>
<figure confidence="0.996191">
S [main :
S [wh : +
main : &lt;1&gt; [
ai3
V
saw
S [inv : &lt;1&gt;1
S [Inv :
NP
John
S Oman :
S [Iny :
-1
wh : â€¢
VP
Joh.
S [main :
Sony: â€¢I
s [whiny:-
.I
013
1314
Peter
01s
at= 85.v
wonder think did
</figure>
<figureCaption confidence="0.862278">
Figure 14
Comparison of adjunction constraintsâ€”Example 2.
</figureCaption>
<page confidence="0.904286">
500
</page>
<note confidence="0.369808">
K. Vijay-Shanker Using Descriptions of Trees in a Tree Adjoining Grammar
</note>
<bodyText confidence="0.9960629">
of quasi-nodes labeled S will obtain an &amp;quot;OA constraint&amp;quot; and vice versa as required
(hence (6) can not be derived). In fact, if 013 were adjoined at the root of a12 (and thus
showing (3) is well formed) then it will no longer be possible to derive (7). Likewise,
by adjoining 015 at the pair of 53 and s4 quasi-nodes in ail, we can derive (1) but will
no longer be able to derive (7).
Proceeding in this manner we can show the well-formedness of (1)â€”(5) and the ill-
formedness of (6)â€”(8). Thus we have shown that if appropriate assertions can be stated
about the individual nodes then a more succinct grammar can be given: one that does
not require replication of tree structures, due to the fact that adjoining constraints are
not pre-specified as in a TAG.
</bodyText>
<sectionHeader confidence="0.880972" genericHeader="method">
4. A Logical Formulation
</sectionHeader>
<bodyText confidence="0.999645257142857">
A central theme in our definition of FTAG has been the view that the objects manip-
ulated by a grammar are descriptions of trees (rather than trees). This separation of
descriptions of trees from the trees (models) derived has been crucial in embedding
TAG in the unification framework. The question of which language to use to describe
trees (together with its semantics) arises. We have used quasi-trees (as the descriptions
themselves) in order to focus on TAG, and have not introduced some general formal
framework for describing trees. The discussion below does not constitute a suggestion
about how such general descriptions may be given, but is one way to specify an FTAG
that will be convenient for our purposes here.
In this section, we describe a logical formulation of the unification-based approach
to TAGs. The purpose of providing a logical formulation of FTAG is so that we can
find the denotation of an FTAG grammar (the set of structures generated) as well
as contrast it with context-free grammar-based unification grammars. To define the
denotation of an FTAG grammar, we will first describe how an FTAG grammar can
be represented. This representation uses the logical formulation of feature structures
as given by Kasper and Rounds (1986) and Johnson (1988) and is similar in approach
to the logical formulation of Functional Unification Grammar (FUG) given by Rounds
and Manaster-Ramer (1987).
In the framework of Rounds and Manaster-Ramer (1987), an FUG (or any context-
free grammar with associated unification equations as in, say PATR-II) can be rep-
resented by means of a set of equations, using the formulae of Kasperâ€”Rounds to
represent feature structures. For example, a context-free grammar rule S NP VP can
be represented as s ::= CAT: S A 1 : np A 2 : vp. Here s, np, and vp are type variables.
The attributes 1 and 2 are used to indicate the first and second children respectively.
Using standard techniques to derive fixed points from a set of recursive rules, the
denotation of type variables are obtained. The denotation of the type variables gives
the set of structures derived from the corresponding nonterminals.
Now suppose we wish to express reentrancy in feature structures by using vari-
ables; it is clear that we have to use individual variables and not type variables. As in
Johnson (1988), we use individual variables and equalities to express reentrancy. The
syntax we adopt to describe attribute-value structures is as follows. Firstly, the set of
terms is defined as
t::= a where a is an atomic value
where x is an individual variable
1(t1) where 1 is a label (or attribute) and t1 is a term.
</bodyText>
<page confidence="0.985828">
501
</page>
<figure confidence="0.654726875">
Computational Linguistics Volume 18, Number 4
The set of formulae is defined as
0::= 1.1 t2 where t1, t2 are terms
01 A 02 where 01,02 are formulae
cbi V 02 where 01,02 are formulae.
For example, (1(x) = y) A (h(x) = z) A (g(y) = z) A (z = a) describes (among others)
the following feature structure.
[ g: U
</figure>
<bodyText confidence="0.998610625">
Note that individual variables (that stand for individual feature structures) are
being used to capture reentrancy, whereas typed variables play a role analogous to
the role of nonterminals in grammars (such as CFGs) and stand for a set of feature
structures. For the purpose of describing an FTAG, we need individual variables to
specify reentrancy (as well as to refer to quasi-nodes) and &amp;quot;typed&amp;quot; variables to denote
the set of structures derived from elementary quasi-trees. To distinguish between these
two kinds of variables, in our framework, we will use monadic predicate instead of
typed variables.
</bodyText>
<subsectionHeader confidence="0.996844">
4.1 Expressing an FTAG
</subsectionHeader>
<bodyText confidence="0.999900166666667">
Firstly, we note that quasi-initial trees are analogous to nonterminals in CFGs. Thus, as
indicated above, quasi-initial trees will be represented by monadic predicates. If a is a
quasi-initial tree, then we will use a predicate symbol -a to represent this quasi-tree. If
a structure A is derivable in the grammar starting from a then we would like to have
A to belong to the set denoted by d. For example, any structure described by a14 can
be assumed to satisfy the requirements on the variable x in
</bodyText>
<equation confidence="0.639163">
cat(x) S A Dom(x,y) A cat(y) S A 1(y) z A count(y) zero A cat(z) c.
</equation>
<bodyText confidence="0.99953975">
This description is intended to not only describe the features of nodes, but also the
structure of the subtrees rooted at each node (with attributes 1,2,... used to specify
the first, second, ... child of a node). In the formula given above, x represents the
quasi-root node. Therefore, we will define rem by
</bodyText>
<equation confidence="0.922708">
14(x) &lt; &gt; cat(x) S A Dom(x,y) A cat(y) S A 1(y) z A count(y) zero A cat(z) c.
</equation>
<bodyText confidence="0.9998456">
In this case, Dom(x, y) is used to indicate that the quasi-root (x) dominates the associ-
ated bottom quasi-node (given by y).
Now if we view the definition of ai4 independent of the rest of the grammar, then
Dom(x,y) represents domination in any arbitrary manner. However, the rest of the
grammar specifies the constraints on the domination relation by defining the actual
possibilities for the domination. This is because a pair of quasi-nodes (say as given by
x and y in a14) is intended to mean that either they are the same objects or are different
nodes that are related by proper domination. In our definition, the separation can take
place only by adjunction. So given a grammar, we can specify that the domination
relationship is actually defined by
</bodyText>
<equation confidence="0.431526">
Dom(x,y) &lt; &gt;xy V ,7 3 -1(x , y) V . . . V,T3 n (x , y)
</equation>
<bodyText confidence="0.9870455">
where {31, , on} are the quasi-auxiliary trees in the grammar. Here we assume that
13 captures the (domination) relationship between its quasi-root and quasi-foot nodes
</bodyText>
<page confidence="0.983476">
502
</page>
<note confidence="0.402552">
K. Vijay-Shanker Using Descriptions of Trees in a Tree Adjoining Grammar
</note>
<bodyText confidence="0.9996846">
of the quasi-auxiliary tree O. Since the actual definition of the domination between a
pair of quasi-nodes is determined by the quasi-trees of the grammar, it is appropriate
to consider fixed-point semantics to define the denotation of a grammar.
Before we discuss the fixed point we will complete our discussion about how we
can specify a grammar. Let us define another monadic predicate Inittree by
</bodyText>
<equation confidence="0.937492">
Inittree(x) &lt; &gt;61(x) V ... V -6,,i(x)
</equation>
<bodyText confidence="0.997134333333333">
where {oil, , am} is the set of initial trees. If we further wish to stipulate that a
structure is derived in a FTAG if it is derived from some quasi-initial tree and is
rooted in S we can define
</bodyText>
<equation confidence="0.968532">
Grammar(x) &lt; &gt; Inittree(x) A cat(x) -= S.
</equation>
<bodyText confidence="0.998705363636364">
Note that for a quasi-node (referred to as x) where substitution can take place, we can
specify Inittree(x) to specify the substitution.
We will now illustrate the representation of an FTAG grammar, shown pictorially
in Figure 15. This grammar contains a14 and 016. Apart from the cat information, the
only other attribute used in the feature structures are count (counts the number of
adjoining operations used in deriving a tree), one (used in counting), and attributes
1, 2, 3 (which are used for specifying the children of a node).
To compare our representational scheme for FTAG with that for FUG given by
Rounds and Manaster-Ramer (1987), we have used predicate symbols instead of type
variables. The use of monadic predicates alone is sufficient to represent FUG (or ac-
tually a CFG-based unification grammar) since only &amp;quot;substitution&amp;quot; is used. Binary
</bodyText>
<figure confidence="0.99442984">
/316
stl
a 14
s
Xâ€¢â€¢â€¢&amp;quot;*....1r
S [count : 03
S [count : [one : &lt;I&gt; (11 Z
a S [count : b
1 \
S [count &lt;1,] Z2
y
Inittree(x) A cat(x) S
.a.714(x)
cat(x) S A Dorn(z,y) A cat(y) SA
1(y) z A count(y) zero A cat(z) c
1316(x , y) V (x y)
cat(x) S A Dom(x , z) A cat(z) S A one(count(z)) P.,- count(z2)
Al(z) z1 A 2(z) Pe, z2 A 3(z) z3 A cat(zi) P.: a
ADom(z2, y) A cat(z2) S A cat(z3) b A cat(y) S
Acount(z2) count(y)
Grammar(x)
Inittree(x)
-al 4 (X)
Dom(x,y)
-16(x,Y)
</figure>
<figureCaption confidence="0.935829">
Figure 15
</figureCaption>
<footnote confidence="0.365348">
Example: An FTAG grammar and its representation.
</footnote>
<page confidence="0.976767">
503
</page>
<note confidence="0.509553">
Computational Linguistics Volume 18, Number 4
</note>
<bodyText confidence="0.9510595">
predicates are used to capture adjunction (which is defined as a pair of substitutions)
in FTAG.
</bodyText>
<subsectionHeader confidence="0.99472">
4.2 Fixed-Point Semantics (Denotation of an FTAG Grammar)
</subsectionHeader>
<bodyText confidence="0.9924662">
As mentioned before, the set of terms is defined recursively as
t::= a where a is an atomic value
where x is an individual variable
1(t1) where 1 is a label and t1 is a term.
However the set of formulae is now defined by
</bodyText>
<equation confidence="0.864598333333333">
0::= 1.1 t2 where t1, t2 are terms
P(ti , â€¢ tn) where t1, , tâ€ž are terms and P is a n-ary predicate symbol
01 A 02 where 01, 02 are formulae
01 V 02 where 01,02 are formulae.
From the discussion given in the previous section any FTAG can be stated as
,tm,n) &lt; &gt;qn
</equation>
<bodyText confidence="0.990291">
where 01, â€¢ â€¢ â€¢ , On are formulae and â€¢ â€¢ â€¢ tm,i ti,n â€¢ â€¢ â€¢ , ttn,n are terms such that for 1 &lt;
i,j &lt; n, if i j then the symbol P, Pl. Of course for describing an FTAG, monadic
and binary predicates are enough.
The structures that terms denote are the finite state automata (actually equiva-
lence classes containing such automata; for details, we refer to Moshier [1988] for a
discussion about these structures) as defined by Kasper and Rounds (1986) and used in
defining the satisfiability of formulae in their logic. We can give a fixed point semantics
of a grammar in the standard way.
</bodyText>
<subsectionHeader confidence="0.871769">
Definition
</subsectionHeader>
<bodyText confidence="0.999332666666667">
Let p be a function that maps each variable to an automaton. We define a Value function
as a partial function that returns the denotation of a term (an automaton) relative to
an environment (mapping variables to automata).
</bodyText>
<listItem confidence="0.981597">
â€¢ Value(x) = p(x) where x is a variable.
â€¢ Value(a) = Aa where a is an atom, where A, is the atomic structure that
corresponds to the atom a.
â€¢ Value p(1(t)) = .AII, if ,4// is defined, where 1 is an attribute, t is a term
and Value(t) = A. If Value(t) is not defined or Value(t) = A but All is
not defined then Valuep(1(t)) is not defined.
</listItem>
<bodyText confidence="0.99818275">
Let p be an environment function and I be an interpretation mapping predicate
symbols to their denotations, i.e., if P is a n-ary predicate symbol then I maps P to some
set of n-tuples of automata. Given an interpretation function I and an environment p
we define in the following way.
</bodyText>
<page confidence="0.988607">
504
</page>
<figure confidence="0.2178205">
K. Vijay-Shanker Using Descriptions of Trees in a Tree Adjoining Grammar
Definition
</figure>
<equation confidence="0.9705224">
(I, p) =01 A 02 iff (&apos;p) = 01 and (I, P)
(&apos;p) 1=01 V cb2 iff (I, P) =(ki or P) 1= c52
(I, p) 1= ti t2 iff Value(ti) and Va/uep(t2) are defined and Value(t1) = Value(t2)
(I, p) P(ti, â€¢ â€¢ â€¢ ,t) if Value(t) is defined (1 &lt; i &lt; n) and
(Va/uep(ti), , Valuep(tn) E I(P).
</equation>
<bodyText confidence="0.98977025">
We now define a transformation function mapping interpretations in the following
way. For some m &gt; 1, let P,(t,,i, ,t,) &lt; &gt; 0, (1 &lt; i &lt; m) be the grammar specifica-
tion. We define the transformation function, TG, such that given an interpretation, I,
TG returns an interpretation TG (I) given by
</bodyText>
<subsectionHeader confidence="0.793445">
Definition
</subsectionHeader>
<bodyText confidence="0.7212305">
For all substitutions, p, where Va/uep(t,,j) is defined for 1 &lt; j
(Value (t,1),.. , Value ,(t,)) E T G (I) (P i) if (I ,p) H
</bodyText>
<subsectionHeader confidence="0.975094">
Ordering relations
</subsectionHeader>
<bodyText confidence="0.998810666666667">
We use the ordering relationship, E, as defined by Rounds and Kasper (1986) i.e.,
A1 E A2 iff there is a homomorphism mapping the states of A1 to the states of A2
that preserves the transition and output functions. We extend this ordering relation
to an ordering on n-tuples and state that â€¢â€¢â€¢ ,A) E , iff for 1 &lt; i &lt; n
A, E B.
Among pairs of sets of n-tuples of automata, say D1, D2, we use the same ordering
as that used by Rounds and Manaster-Ramer (1987) and state that Di E D2 iff Di c D2.
The least element among the sets of n-tuples of automata is the empty set. The ordering
among interpretation functions is defined as 11 E /2 iff for all predicate symbols P.
</bodyText>
<figure confidence="0.221199333333333">
(P) LI I2(P), i.e., 11(P) C I2(P).
Lemma 4.1.
If /1 E I2, then for all environments, p, and formulae, 0, if (11, p) Hcb then (12, p) H c.
</figure>
<subsectionHeader confidence="0.73071">
This can be easily shown by using induction on the structure of the formula 0.
Theorem 4.1.
</subsectionHeader>
<bodyText confidence="0.98983325">
The transformation function is monotonic.
Let /1 E .12. We have to show for all P that TG(II)(P) C TG(I2)(P). Let P(ti, . . â€¢ , tn) &lt; &gt;
be a part of the grammar specification and let (Ai, â€¢ â€¢ â€¢ , An) E TG(II)(P). Thus, for any
environment p such that (1.1, p) H0 and for 1 &lt; i &lt; n we have Value(t) = A. By
the above lemma, we also have /2, P H and hence (Ai, â€¢â€¢â€¢ E Tc(-12)(P). Thus,
TG(Ii)(P) C TG(I2)(P) and T G(Ii) L TG (I2)â€¢
We will call an interpretation, I, finite if for all predicate symbols, P. I(P) is a finite
set.
</bodyText>
<subsectionHeader confidence="0.792417">
Lemma 4.2.
</subsectionHeader>
<bodyText confidence="0.9068875">
For all environments, p, and interpretations, I, if (I, p) H cb then there is a finite
interpretation 10 such that 1 L I and (I, p) H0.
This can be shown by a straightforward induction on the structure of 0, and by con-
structing /0 in the obvious manner.
</bodyText>
<page confidence="0.99264">
505
</page>
<note confidence="0.65249">
Computational Linguistics Volume 18, Number 4
</note>
<bodyText confidence="0.7148505">
Theorem 4.2.
The transformation function is continuous.
This can be easily established using Lemma 4.1 and Lemma 4.2.
Since TG is continuous, the least fixed point of TG can be obtained as
</bodyText>
<equation confidence="0.982313">
T&apos; (IÂ±)
i&gt;0
</equation>
<bodyText confidence="0.99990275">
where ./Â± is the least interpretation function and is given by /AP) the empty set
for all predicate symbols P. Let IG be the fixed point of TG. Then the set of structures
derived by a grammar G is given by IG (Grammar), where Grammar is the distinguished
predicate symbol as defined earlier.
</bodyText>
<subsectionHeader confidence="0.999462">
4.3 Some Remarks
</subsectionHeader>
<bodyText confidence="0.999996">
The logical formulation of FTAG given above is similar to the formulation of FUG
and the associated semantics given by Rounds and Manaster-Ramer. This logical for-
mulation of FUG essentially captures CFG-based unification grammars where substi-
tution (and associated unifications) is the operation used for composition. This can be
seen from their semantic treatment where type variables are repeatedly substituted
for. Rather than using type variables for &amp;quot;nonterminals,&amp;quot; in our formulation predi-
cate symbols represent the nonterminals. Although &amp;quot;substitution&amp;quot; at frontier nodes
can be effectively captured by Roundsâ€”Manaster-Ramer calculus, we found it less
cumbersome to express adjunction operation and FTAG in the above DCG-like style.
The domination relation and adjunction operation are easily captured by using binary
predicates and their substitutions. Despite these syntactic differences, the presentation
of the semantics is essentially the same traditional fixed-point semantics. Not only do
we capture the substitution operation, as was done in the Roundsâ€”Manaster-Ramer
calculus, but we are also able to contrast FUG (and CFG-based unification grammars)
with FTAG by capturing adjoining as a pair of substitutions.
</bodyText>
<sectionHeader confidence="0.84998" genericHeader="method">
5. Some Consequences of the New Interpretation
</sectionHeader>
<bodyText confidence="0.999909166666667">
So far we have concerned ourselves with an interpretation of TAG that is compatible
with the constraint-based approach to grammars. We will now briefly discuss some
possible implications that this new interpretation may have on design or development
of TAG grammars. The point of this section is simply to raise certain possibilities and
questions. Providing definitive answers and solutions involves exploring linguistic
issues that are beyond the scope of this work.
</bodyText>
<subsectionHeader confidence="0.990626">
5.1 Adjoining, Multi-Component Adjoining, and Substitution
</subsectionHeader>
<bodyText confidence="0.999777444444444">
We defined the adjoining operation as an operation that fits a structure in the gap be-
tween a pair of associated quasi-nodes. Although the nature of the adjoining operation
itself has not been examined in much detail in this paper (apart from defining it in
terms of quasi-nodes in a manner such that it is similar to the traditional definition),
questions that arise from this work are: how different is the adjoining operation from
the more commonly used substitution operation; and whether the definition of adjoin-
ing itself (as stated here) follows from some more fundamental linguistic assumptions.
To motivate our arguments, we start by considering an example using the so-called
multi-component adjoining.
</bodyText>
<page confidence="0.990366">
506
</page>
<note confidence="0.431594">
K. Vijay-Shanker Using Descriptions of Trees in a Tree Adjoining Grammar
</note>
<bodyText confidence="0.641668">
Consider the derivation of:
</bodyText>
<listItem confidence="0.978829">
(1) Which picture did you buy a copy of?
(2) Which picture did you buy a photograph of a copy of?
</listItem>
<bodyText confidence="0.999416783783784">
This form of long-distance dependency cannot be localized in a TAG if we wish to
localize the predicate-argument dependencies as well (for details, see Kroch [19871).
On the other hand, an analysis has been given using a version of multi-component
adjoining. Multi-Component Tree Adjoining Grammar (MCTAG) differs from (the tra-
ditional definition of) TAG in that the elementary objects of the grammar are sets of
trees rather than trees, and multi-component adjoining involves the composition of
these elementary sets of trees&apos; (rather than elementary trees). See Joshi (1987) for more
details on Multi-Component Tree Adjoining Grammars (MCTAG).
The multi-component sets, given in Figure 16, may be used to give an account for
sentences (1) and (2). Obtained by adjoining the two components of 017 in a15t N can
be used for sentence (1) (Figure 17).
The need for introducing multi-component sets and multi-component adjoining
(in this case, at least) arises because of the decision in traditional TAGs to compose
trees (rather than descriptions of trees, i.e., quasi-trees). In particular, the domination
relations allow us to give partial descriptions of trees such as a16 (in Figure 18) that
captures the same information as in the multi-component set Or (in Figure 16). Note
that a16 can be described by using the same principles that relate a13 and a12 (see
Figure 14). If, for a moment, we consider a15 to be an auxiliary quasi-tree (rather
than an initial quasi-tree) and use it for &amp;quot;adjoining&amp;quot; (treating the n2 quasi-node as the
quasi-foot) then we obtain the same structure as 0,5 (Figure 17).
Two issues can be raised with respect to this example. Firstly we can question
whether such uses of multi-component adjoining (and where the foot node of one
component dominates the root of the other components in the eventual structure5) can
be considered to be adjoining in the quasi-tree framework; and secondly whether these
operations can be thought of as essentially the substitution operation when viewed in
this framework (that uses quasi-trees rather than trees). However, a15 would normally
be called an initial quasi-tree, and we would have considered substitution at the n2
quasi-node rather than treating a15 as an auxiliary quasi-tree and the n2 quasi-node
as the quasi-foot. Nevertheless, this &amp;quot;adjunction&amp;quot; of a15 seems to be really playing the
role of substitution (with a sub-quasi tree though).
Addressing the first issue, in the case of the multi-component adjoining example
used here, we believe the need for multi-component adjoining arises from the fact
that objects being composed were defined to be trees. Even in the previous version
of FTAG, it was assumed that the objects being composed were trees despite the fact
that two feature structures were associated with each node. These top and bottom
feature structures associated with a node were supposed to account for a view of
that node from two different perspectives (from the top and from below). However,
</bodyText>
<footnote confidence="0.974766888888889">
4 There are three different definitions of multi-component adjoining that have been proposed. The
version considered here is the simplest kind: one where a set of trees are simultaneously adjoined into
a single tree. This version leads to a system weakly equivalent to TAG. The other definitions include
the case where sets of trees are adjoined simultaneously into nodes in trees that belong to another set
and finally where a set of auxiliary trees are adjoined simultaneously without any restriction on the
adjoining sites,
5 Although not a part of the definition of multi-component adjoining, in all analyses we are aware of, it
is the case that the foot node of one component dominates the root of the other component in the
eventual structure.
</footnote>
<page confidence="0.989692">
507
</page>
<figure confidence="0.995374117647059">
Computational Linguistics Volume 18, Number 4
NP
DET N&apos;
S&apos;
p NP,
of
NP; S
which painting
017
a15
018 NP
ZN
DET N&apos;
ZN
a PP
photograph p NP;
of
</figure>
<figureCaption confidence="0.541795">
Figure 16
</figureCaption>
<figure confidence="0.986956142857143">
A multi-component tree adjoining grammar.
aux
1 A
did NP
I AVP
you v NP
I
</figure>
<subsectionHeader confidence="0.741079">
buy e
</subsectionHeader>
<bodyText confidence="0.999821">
because one was dealing with a single node, it was taken for granted that the two
feature structures associated with the single node would assign the node the same
label (S,NP,...), no matter which perspective (viewing a node from above or from
below) one took. That is, we could not consider the possibility of a node whose top and
bottom parts were labeled by S and NP. Therefore, instead of using one quasi-tree (a16),
a multi-component set, 1317, composed of two trees is used. Assuming the possibility
of stating domination between quasi-nodes with different labels (as in cti6), we can
similarly extend the definition of &amp;quot;auxiliary quasi-trees&amp;quot; to allow for the quasi-root
and quasi-foot nodes being labeled differently. This is the assumption we made when
we &amp;quot;adjoined&amp;quot; the quasi-tree ce15 to capture the effect of multi-component adjoining.
Assuming that (2E15 is an auxiliary structure points out the similarities between
multi-component adjoining and adjoining. However, it is more natural to assume it
is an initial quasi-tree and use substitution at the object NP node (rather than call
cei5 an auxiliary quasi-tree and n2 quasi-node, without any justification, a quasi-foot).
A similar situation arises when we consider the so-called complement auxiliary trees
(see Kroch [1987]). 019, an elementary quasi-tree anchored by a verb such as &amp;quot;think,&amp;quot;
would be defined to be a complement auxiliary quasi-tree because the quasi-foot is
present due to the subcategorization requirements of the anchor. In general, in the
lexicalized approach to TAG, it is assumed that such an argument node is expanded
</bodyText>
<page confidence="0.984357">
508
</page>
<figure confidence="0.993408">
K. Vijay-Shanker Using Descriptions of Trees in a Tree Adjoining Grammar
S&apos;
NP;
/\
which painting aux
did NP VP
I 7\
you v NP
buy DET N&apos;
IA
a N PP
copy p NP
of I
e
</figure>
<figureCaption confidence="0.985102">
Figure 17
</figureCaption>
<bodyText confidence="0.970684772727273">
Derivations in MCTAG.
by substitution. This is consistent with Figure 19 where we could call 1319 an initial
quasi-tree and substitute ct17 at the supposed quasi-foot (52) to derive a structure for
Peter thinks John saw Mary. However, a quaSi-tree such as 019 must be treated as an
auxiliary structure in order that we could use it for adjoining so that it can be adjoined
in ck18 (see Figure 18) at the pair (s3, s4) to derive a structure for who did Peter think John
saw.
The question about the basis of deciding when one should call an elementary
structure auxiliary or initial remains. It is hard to justify that s2 quasi-node of ,(319 is
the quasi-foot on the basis of factoring of recursion (the original reason for introducing
auxiliary structures). However, while developing a grammar, the 52 node in 019 is not
expanded further because we wish to factor recursion, but because it is required by
the subcategorization of the anchor and such nodes are expanded as a result of a
derivation step. Among the quasi-nodes that appear in the frontier of 019, the s2 quasi-
node is called the quasi-foot because extraction cannot occur from a tree that can
appear below the subject NP quasi-node, whereas it can in the case of 52 quasi-node.
However, on this basis, one could also call a15 an auxiliary quasi-tree and state that
the n2 quasi-node is the quasi-foot.
Structures such as 019 and am (of Figure 20) raise the question of whether there
is an essential difference between initial and (complement) auxiliary quasi-trees, and
whether adjoining is only a special form of substitution. It appears that in the case of
the two examples above, we came to the situation of calling certain structures auxiliary
</bodyText>
<page confidence="0.986392">
509
</page>
<figure confidence="0.993842375">
Computational Linguistics Volume 18, Number 4
S&apos;
019
NP VP
Peter
NP v S
72.
saw Mary think
</figure>
<figureCaption confidence="0.981225">
Figure 19
</figureCaption>
<bodyText confidence="0.978085818181818">
Initial or auxiliary?
structures solely for the purpose of using the adjoining operation. If we wish to claim
that there is no essential difference between initial and auxiliary structures (at least
of the complement auxiliary tree variety), then we must account for the apparent
difference between substitution and adjoining operations. We argue now that it may
not be necessary to make this distinction if we take a closer look at the adjoining and
substitution operations.
Recall that the substitution operation was defined by the identification of two
quasi-nodes. So far this has been illustrated by identifying a quasi-node that appears
in the frontier of a quasi-tree with the quasi-root of another quasi-tree. However, now
consider 019 (see Figure 21) and &amp;quot;substitution&amp;quot; at s2 by the subtree rooted at s4 (i.e.,
</bodyText>
<figure confidence="0.9926058">
als
which painting NP
NP,
aux
did NP VP
you v NP it,
buy
Figure 18
Multi-component adjoining seen as adjoining.
of e
copy NP;
John
510
K. Vijay-Shanker Using Descriptions of Trees in a Tree Adjoining Grammar
a18
S
A S
NP; S -lcâ€” S3 th9 :
I 1
1
who s eekr..., s S
/\\ 4 /\
NP VP
.
I A . I A
v NI); v S â€¢114-- sz
I I I
saw e think
Figure 20
Adjoining versus substitution.
NI); S
s wh7SNÂ°
NP; S
019
who S
S
NP VP
John
v NPi
saw e
</figure>
<figureCaption confidence="0.735155">
Figure 21
</figureCaption>
<figure confidence="0.892059333333333">
Adjoining seen as substitution.
VP
ZN
think
NP VP
Peter s .s, JoIhn v NPi
think saw e
NP
Peter
511
Computational Linguistics Volume 18, Number 4
a20 : a21 : a22 :
</figure>
<figureCaption confidence="0.746395">
Figure 22
Adjoining.
</figureCaption>
<bodyText confidence="0.999817117647059">
identify the nodes referred by s2 and s4). If we insist that the resulting structure must
describe a tree, then we must have either s1 dominate s3 or s3 dominate sl. Now
suppose there are some fundamental linguistic principles (perhaps those principles
that govern the makeup of elementary structures and hence also the characteristics
of the domination link between paired quasi-nodes) that determine that it is the case
that s3 must dominate s1 and not vice versa. In this case we obtain 79 (as shown in
Figure 21), a structure obtained by &amp;quot;adjoining&amp;quot; 019. In fact, that s3 must dominate s1
must be derivable from any reasonable linguistic theory that is used to produce the
elementary structures concerned (for otherwise a wrong sequence of words would
be predicted). One possible explanation of why s3 dominates si could be given by
importing a device like the functional uncertainty machinery (Kaplan and Maxwell
1988) used in LFG. The treatment used in LFG, when imported here, would suggest
that zero or more structures of the form given by 019 would fit in the gap specified
by the domination link between s3 and s4. Thus when the identification of s2 and s4
takes place, 53 must dominate si and again zero or more structures of the form of
/319 could fit between s3 and Si now (see Joshi and Vijay-Shanker [1989]) for a discus-
sion of the treatment of long-distance dependency in TAG and LFG). Another way
to explain the domination of 53 over si could be done by using the notions of max-
imal government domains discussed by Kroch (1989) and using it now to define the
characteristics of the domination links such as that between s3 and s4. Note that once
the nature of the adjoining operation has been derived, one can pre-compile out the
linguistic principles and machinery used to express it. Thus even if one uses, say, the
functional uncertainty machinery or maximal government domains, these additional
devices (used during the developmental stages) of the grammar need not be used
again during the derivation process once we have derived the adjoining operation.
This is analogous to the situation with elementary structures. Some linguistic theory
will be involved in defining the elementary structures of a TAG. However, once the
grammar has been developed, these principles are no longer directly involved during
the derivation phase. This is because the principles have been pre-compiled into the
elementary structures built.
Figure 22 describes the general situation that may be used to contrast substitution,
adjoining and multi-component adjoining. As usual, the identification of the b1 and b2
quasi-nodes defines the substitution of the an at the b1 quasi-node of a20. Now suppose
instead of considering a (quasi) root such as the one named b2 we consider a pair of
</bodyText>
<page confidence="0.975145">
512
</page>
<figure confidence="0.996414">
K. Vijay-Shanker Using Descriptions of Trees in a Tree Adjoining Grammar
A
ZD\
.11E-*GZ22
It
</figure>
<figureCaption confidence="0.7411575">
Figure 23
Multi-component adjoining.
</figureCaption>
<bodyText confidence="0.999957633333333">
quasi-nodes, such as c1 and b3, that are interior quasi-nodes. Now suppose we unify
the b1 and b3 quasi-nodes. Since we will assume that the resulting structure must be a
description of a tree, we must have the al quasi-node dominate c1 quasi-node or vice
versa. If the c1 quasi-node dominates al (as in -no), we have a structure that appears
like the one obtained by adjoining. Suppose there is some principle that predicts this
situation to occur when substitution takes place; then we can conclude that adjoining
is not a fundamental operation in itself but rather a derived operation. Trying to
capture the above-mentioned principle would involve specifying the characteristics of
the domination link between pairs of quasi-nodes such as that specified by c1 and b3
and the makeup of elementary structures of a grammar.
Let us now consider the other case. Suppose we substitute at the b1 node with
the quasi-tree rooted by b3; there is no reason to assume that c1 must dominate al.
Consider the case when al dominates c1. In this case, the structure a20 must be spliced
into two (c43 and 4) as indicated in Figure 23. There are several possibilities. First,
a2&apos;0 may appear above all of a22 as indicated by This appears to correspond to the
version of multi-component adjoining where different components of a set ({a0, a0})
are adjoined simultaneously into another multi-component set, ({c:42,(42}). Other pos-
sibilities include c40 and c42 splintered into some number of pieces (depending on the
domination links found in them) and interleaved in a more complex fashion.
To summarize, when we substitute at bi by identifying it with a quasi-root of
another structure, we have the standard substitution. On the other hand, when we
substitute at b1 by identifying b1 and b3, if Cl dominates al then the resulting structure
appears to be the one formed after adjunction. When al dominates c1 the situation
seems to be comparable with that of multi-component adjoining, where a20 and a22
are multi-component sets made up of c:tc,, aq0 and (2c2, q2, respectively. Such multi-
component adjoining has been used previously in providing linguistic analyses. Since
both cases occur (a1 dominates c1 or vice versa), we believe it only further justifies our
claim that in situations where we consider substitutions as above, whether we have c1
dominating al (adjoining) or not (multi-component adjoining) depends on the linguis-
tic principles being instantiated during the development of elementary structures (and
</bodyText>
<page confidence="0.995118">
513
</page>
<table confidence="0.866158285714286">
Computational Linguistics Volume 18, Number 4
712 (123
A13
NP VP
Am- 2
VP
VP
</table>
<figureCaption confidence="0.772121">
Figure 24
</figureCaption>
<bodyText confidence="0.90577075">
Representation of an elementary structure.
hence also determining the nature of domination links). Thus, this raises the question
that although adjoining is used in defining the TAG formalism, could it too (like the
elementary structures) be precompiled from some more fundamental principles?
</bodyText>
<subsectionHeader confidence="0.99974">
5.2 Describing the Elementary Objects of a Grammar
</subsectionHeader>
<bodyText confidence="0.894153423076923">
In this section we show that the new interpretation of the TAG formalism allows the
possibility of representing a grammar in a more compact fashion. This is illustrated
by means of an example.
The structure named 712 (Figure 24) pictorially represents the normal (or default)
tree structure that can be associated with any verb, whereas 713 will be used specifically
in the case of a simple transitive verb. The default structure associated with a simple
transitive verb can be obtained by considering the description illustrated pictorially
by 713 and inheriting the description (712) that is common for all verbs. Now since the
v1 and v2 nodes have to be identified, we have the following.
â€¢ The domination link between vpi and v1 quasi-nodes indicates a path
length greater than or equal to 0. However, in this case since the labels of
these quasi-nodes are different, they cannot refer to the same node. Thus,
in this case we have a path length that is greater than 0.
â€¢ 0p2 quasi-node immediately dominates the v2 quasi-node (i.e., path
length=1).
â€¢ Since v1 and v2 quasi-nodes are identified and since we insist on a tree
structure, we have vpi and vp2 quasi-nodes in the domination relation. In
fact vpi quasi-node must dominate vp2 quasi-node in the resulting
structure by a path of length 0 or more (from the two observations
above).
Thus we get the structure given by ci23 as desired. Rogers and Vijay-Shanker (1992)
describe a proof system that can be used to perform the type of reasoning involved
in constructing the structure a23 as described above.
In the manner described above we can build the default structure for every sub-
categorization frame. Such structures will be specified in any lexicalized TAG; the
difference (in the envisaged specification method) is that we no longer precompile out
</bodyText>
<page confidence="0.969433">
514
</page>
<bodyText confidence="0.884187">
K. Vijay-Shanker Using Descriptions of Trees in a Tree Adjoining Grammar
all possibilities (thus repeating the structure 712 in all structures associated with every
type of verb). To complete the description of the rest of the elementary quasi-trees one
would have to use transformations, meta-rules, or lexical rules to specify the structures
for passivization, wh-movement, topicalization, etc. Work along this direction is being
carried out (Vijay-Shanker and Schabes 1992).
</bodyText>
<sectionHeader confidence="0.999345" genericHeader="conclusions">
6. Conclusions
</sectionHeader>
<bodyText confidence="0.999986209302326">
In this paper, we have embedded TAG in the unification framework in a manner con-
sistent with the constraint-based approach used in this framework. Starting from first
principles and taking the localization of dependencies within the elementary struc-
tures of a TAG grammar as the only basic principle, we have argued that the objects
manipulated by such a grammar are not trees but descriptions of well-formed syntac-
tic structures. From D-Theory, we have adopted the use of domination relation and
use of identifiers to refer to nodes while describing such structures. Quasi-trees were
introduced to depict pictorially partial descriptions of trees. The pairing of quasi-nodes
(with domination link between them) was then used to explain the association of two
feature structures with individual nodes in previous definition of Feature structureâ€”
based Tree Adjoining Grammars (FTAG). In fact, we also show that the formalism
defined in Harbusch (1990) (where only one feature structure is associated with ev-
ery node) turns out to be similar to the use of FTAG with an additional decision
to merge every pair of quasi-nodes by default. We argue that such defaults lead to
nonmonotonic behavior.
One can now view FTAG as a generalization of TAG in that arbitrary categories
(as used in GPSG) can label nodes, instead of just atomic symbols (nonterminals) as in
TAG. In fact, by not insisting that a pair of quasi-nodes be labeled by the same category
in FTAG, as was done in TAG, we argue that the &amp;quot;adjoining constraints&amp;quot; follow from
the definition of adjunction and the labeling of quasi-nodes, thus making unnecessary
the stipulations of SA and OA constraints. In addition, contrary to the assumptions
made in current literature on TAG, we show that there are two possible interpretations
of NA constraints, only one of which is a special case of SA constraint. We note that
as the information associated with quasi-nodes grows during derivation, &amp;quot;adjoining
constraints&amp;quot; get instantiated dynamically in an FTAG. We make use of this property in
order to give examples to show how FTAG can give more succinct descriptions than
TAG.
We have given a logical formulation of FTAG. This builds on a similar treatment
of FUG given by Rounds and Manaster-Ramer. We view this logical formulation as a
description of those trees and associated feature structures that are built by CFG-based
unification grammars. Unlike a CFG-based formalism that allows only for substitution
operation, for an FTAG one has to depict adjunction in addition to substitution. Our
treatment captures both these cases. We end by giving a presentation of the semantics
that can be used to give the denotation of a grammar, i.e., in our case, the structures
derived by a grammar.
We have emphasized throughout the paper that we are only interested in the
definition of the FTAG formalism. In particular, we have not been concerned with
linguistic analyses. However, we have raised a few questions about the formalism
that we believe can only be answered on linguistic grounds. In the context of the new
interpretation, some of these include whether the linguistic uses of multi-component
adjoining can be simulated as the adjoining operation; whether there is an essen-
tial need to divide the elementary structures of the grammar as initial and auxiliary
structures; and whether the adjoining operation itself can be defined as a substitution
</bodyText>
<page confidence="0.978818">
515
</page>
<note confidence="0.359493">
Computational Linguistics Volume 18, Number 4
</note>
<bodyText confidence="0.999891">
operation, the apparent differences between these operations being derived on the
basis of some more fundamental linguistic principles used in the design of the ele-
mentary structures of the grammar. Even if the answer is in the affirmative, we believe
there is considerable advantage to be gained by deriving this operation in order that
we can manipulate directly the elementary structures that localize various forms of
the dependencies. As observed earlier, with the derivation of this operation (like the
derivation of the elementary structures of the grammar), we can disregard (i.e., not
reason with) the principles used (to derive them) during the derivation of more com-
plex structures. Finally we have also shown that the new interpretation of the TAG
formalism proposed here allows for the possibility of a more compact representation
of a TAG grammar.
</bodyText>
<sectionHeader confidence="0.995695" genericHeader="acknowledgments">
Acknowledgments
</sectionHeader>
<bodyText confidence="0.958719142857143">
This work was partially supported by NSF
grant IRI-9016591.
I am extremely grateful to A. Abeille,
A. K. Joshi, A. Kroch, K. F. McCoy,
Y. Schabes, S. M. Shieber, and D. J. Weir.
Their suggestions and comments at various
stages have played a substantial role in the
development of this work. I am thankful to
the reviewers for many useful suggestions.
Many of the figures in this paper have been
drawn by XTAG (Schabes and Paroubek
1992), a workbench for Tree-Adjoining
Grammars. I would like to thank Yves
Schabes for making this available to me.
</bodyText>
<sectionHeader confidence="0.993913" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999756716216216">
Abeille, A.; Bishop, K.; Cote, Sharon; and
Schabes, Y. (1990). &amp;quot;A lexicalized tree
adjoining grammar for English.&amp;quot;
Technical report MS-CIS-90-24,
Department of Computer and Information
Science, University of Pennsylvania.
Abeille, A. (1991). Une grammaire lexicalis&amp;
d&apos;Arbres adjoints pour le Francais: Application
a l&apos;analyse automatique. Doctoral
dissertation, Universite Paris 7, Paris,
France.
Gazdar, G.; Klein, E.; Pullum, S.; and Sag, I.
(1985). Generalized Phrase Structure
Grammar. Blackwell.
Harbusch, K. (1990). &amp;quot;Constraining tree
adjoining grammars by unification.&amp;quot; In
Proceedings, 13th International Conference on
Computational Linguistics.
Henderson, J. (1990). &amp;quot;Structure Unification
Grammar: A Unifying Framework for
Investigating Natural Language.&amp;quot;
Technical Report MS-CIS-90-94,
Department of Computer and Information
Science, University of Pennsylvania.
Johnson, M. (1988). Attribute Value Logic and
the Theory of Grammar. University of
Chicago Press.
Joshi, A. K. (1987). &amp;quot;An introduction to tree
adjoining grammar.&amp;quot; In Mathematics of
Language, edited by A. Manaster-Ramer,
87-115. Benjamins Publishing Company.
Joshi, A. K. (1985). &amp;quot;How much
context-sensitivity is necessary for
characterizing structural
descriptionsâ€”Tree Adjoining Grammars.&amp;quot;
In Natural Language Processingâ€”Theoretical,
Computational and Psychological Perspective,
edited by D. Dowty, L. Karttunen, and
A. Zwicky, 206-250. Cambridge
University Press.
Joshi, A. K., and Vijay-Shanker, K. (1989).
&amp;quot;Treatment of long-distance dependencies
in LFG and TAG.&amp;quot; In Proceedings, 27th
Annual Meeting of the Association for
Computational Linguistics, 220-227.
Joshi, A. K.; Levy, L. S.; and Takahashi, M.
(1975). &amp;quot;Tree adjunct grammars.&amp;quot; Journal
of Computer and System Sciences, 10(1),
136-163.
Kaplan, R. M., and Maxwell, J. T. (1988).
&amp;quot;An algorithm for functional uncertainty.&amp;quot;
In Proceedings, 12th International Conference
on Computational Linguistics, 297-302.
Kasper, R., and Rounds, W. C. (1986). &amp;quot;A
logical semantics for feature structures.&amp;quot;
In Proceedings, 24th Annual Meeting of the
Association for Computational Linguistics,
257-266.
Kroch, A. S. (1989). &amp;quot;Asymmetries in long
distance extraction in a tag grammar.&amp;quot; In
Alternative Conceptions of Phrase Structure,
edited by M. Baltin and A. Kroch, 66-98.
University of Chicago Press.
Kroch, A. S. (1987). &amp;quot;Unbounded
dependencies and subjacency in a tree
adjoining grammar.&amp;quot; In Mathematics of
Language, edited by A. Manaster-Ramer,
143-172. Benjamins Publishing Company.
Kroch, A., and Joshi, A. K. (1985).
&amp;quot;Linguistic relevance of tree adjoining
grammars.&amp;quot; Technical report MS-CI-85-18,
Department of Computer and Information
Science, University of Pennsylvania.
Marcus, M.; Hindle, D.; and Fleck, M. M.
</reference>
<page confidence="0.96234">
516
</page>
<reference confidence="0.985184181818182">
K. Vijay-Shanker Using Descriptions of Trees in a Tree Adjoining Grammar
(1983). &amp;quot;D-theoryâ€”talking about talking
about trees.&amp;quot; In Proceedings, 21st Annual
Meeting of the Association for Computational
Linguistics, 129-136.
Moshier, M. A. (1988). Extensions to
unification grammar for the description of
programming languages. Doctoral
dissertation, University of Michigan, Ann
Arbor, MI.
Rogers, J., and Vijay-Shanker, K. (1992).
&amp;quot;Reasoning with descriptions of trees.&amp;quot; In
Proceedings, 30th Annual Meeting of the
Association for Computational Linguistics,
72-80.
Rounds, W., and Manaster-Ramer, A. (1987).
&amp;quot;A logical version of functional
grammar.&amp;quot; In Proceedings, 25th Annual
Meeting of the Association for Computational
Linguistics, 89-96.
Schabes, Y., and Paroubek, P. (1992).
&amp;quot;Xtagâ€”a graphical workbench for
developing tree adjoining grammars.&amp;quot; In
Proceedings, Third Conference on Applied
Natural Language Processing, 216-223.
Schabes, Y; Abeille, A.; and Joshi, A. K.
(1988). &amp;quot;New parsing strategies for tree
adjoining grammars.&amp;quot; In Proceedings, 12th
International Conference on Computational
Linguistics, 578-583.
Vijay-Shanker, K. (1987). A study of tree
adjoining grammars. Doctoral dissertation,
University of Pennsylvania, Philadelphia,
PA.
Vijay-Shanker, K., and Joshi, A. K. (1988).
&amp;quot;Feature structure based tree adjoining
grammars.&amp;quot; In Proceedings, 12th
International Conference on Computational
Linguistics, 714-719.
Vijay-Shanker, K., and Schabes, Y. (1992).
&amp;quot;Structure sharing in a lexicalized tree
adjoining grammar.&amp;quot; In Proceedings, 14th
International Conference on Computational
Linguistics, 205-211.
</reference>
<page confidence="0.996829">
517
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.923413">
<title confidence="0.992842">Using Descriptions of Trees in a Tree Adjoining Grammar</title>
<author confidence="0.996914">K Vijay-Shanker</author>
<affiliation confidence="0.96867">University of Delaware</affiliation>
<abstract confidence="0.998206111111111">This paper describes a new interpretation of Tree Adjoining Grammars (TAG) that allows the embedding of TAG in the unification framework in a manner consistent with the declarative approach taken in this framework. In the new interpretation we present in this paper, the objects manipulated by a TAG are considered to be descriptions of trees. This is in contrast to the traditional view that in a TAG the composition operations of adjoining and substitution combine trees. ideas from Description Theory, we propose a means to represent partial descriptions of trees. Using quasi-trees, we are able to justify the definition of feature structureâ€” based Tree Adjoining Grammars (FTAG) that was first given in Vijay-Shanker (1987) and Vijay- Shanker and Joshi (1988). In the definition of the FTAG formalism given here, we argue that a of trees (i.e., quasi-trees); whereas the structures derived by a grammar are trees that are obtained by taking the minimal readings of such descriptions. We then build on and refine the earlier version of FTAG, give examples that illustrate the usefulness of embedding TAG in the unification framework, and present a logical formulation (and its associated semantics) of FTAG that shows the separation between descriptions of well-formed structures and the actual structures that are derived, a theme that is central to this work. Finally, we discuss some questions that are raised by our new interpretation of the TAG formalism: questions dealing with the nature and definition of the adjoining operation (in contrast to substitution), its relation to multi-component adjoining, and the distinctions between auxiliary and initial structures.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>A Abeille</author>
<author>K Bishop</author>
<author>Sharon Cote</author>
<author>Y Schabes</author>
</authors>
<title>A lexicalized tree adjoining grammar for English.&amp;quot;</title>
<date>1990</date>
<tech>Technical report MS-CIS-90-24,</tech>
<institution>Department of Computer and Information Science, University of Pennsylvania.</institution>
<contexts>
<context position="2760" citStr="Abeille et al. (1990)" startWordPosition="417" endWordPosition="420">ammars. A common aspect shared by these grammars or theories is that they are based on specifying constraints that define well-formed structures. This work discusses viewing Tree Adjoining Grammars (TAG) in such a manner and embedding it in a unification-based framework. Tree Adjoining Grammars (TAG) were first introduced by Joshi, Levy, and Takahashi (1975). A preliminary study of this formalism, from the point of view of its formal properties and linguistic applicability, was carried out by Joshi (1985). A detailed study of the linguistic relevance of TAG was done by Kroch and Joshi (1985). Abeille et al. (1990) discuss a fairly substantial grammar for English using the lexicalized approach to TAG that was originally proposed by Schabes, Abeille, and Joshi (1988). * Department of Computer and Information Sciences, University of Delaware, Newark, DE 19716. (i) 1992 Association for Computational Linguistics Computational Linguistics Volume 18, Number 4 TAG is defined as a tree rewriting system. In the definition given traditionally, a TAG is defined by a finite set of trees and an operation called adjoining to compose trees. One of the basic intuitions underlying the use of the TAG formalism is that th</context>
</contexts>
<marker>Abeille, Bishop, Cote, Schabes, 1990</marker>
<rawString>Abeille, A.; Bishop, K.; Cote, Sharon; and Schabes, Y. (1990). &amp;quot;A lexicalized tree adjoining grammar for English.&amp;quot; Technical report MS-CIS-90-24, Department of Computer and Information Science, University of Pennsylvania.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Abeille</author>
</authors>
<title>Une grammaire lexicalis&amp; d&apos;Arbres adjoints pour le Francais: Application a l&apos;analyse automatique. Doctoral dissertation, Universite Paris 7,</title>
<date>1991</date>
<location>Paris, France.</location>
<marker>Abeille, 1991</marker>
<rawString>Abeille, A. (1991). Une grammaire lexicalis&amp; d&apos;Arbres adjoints pour le Francais: Application a l&apos;analyse automatique. Doctoral dissertation, Universite Paris 7, Paris, France.</rawString>
</citation>
<citation valid="true">
<authors>
<author>G Gazdar</author>
<author>E Klein</author>
<author>S Pullum</author>
<author>I Sag</author>
</authors>
<title>Generalized Phrase Structure Grammar.</title>
<date>1985</date>
<publisher>Blackwell.</publisher>
<marker>Gazdar, Klein, Pullum, Sag, 1985</marker>
<rawString>Gazdar, G.; Klein, E.; Pullum, S.; and Sag, I. (1985). Generalized Phrase Structure Grammar. Blackwell.</rawString>
</citation>
<citation valid="true">
<authors>
<author>K Harbusch</author>
</authors>
<title>Constraining tree adjoining grammars by unification.&amp;quot;</title>
<date>1990</date>
<booktitle>In Proceedings, 13th International Conference on Computational Linguistics.</booktitle>
<contexts>
<context position="37901" citStr="Harbusch (1990)" startWordPosition="6305" endWordPosition="6306"> trees, but the one obtained by equating the pairs of top and bottom quasi-nodes is not one of them. Obvi493 Computational Linguistics Volume 18, Number 4 ously this should be the case, since incompatible assertions about a pair of quasi-nodes indicates that they do refer to different nodes (and hence specify OA constraints). 2.8 Using One (Rather than Two) Feature Structure A question arises whether (as in standard CFG-based unification grammars) one could associate just one (rather than two) feature structure per node, i.e., whether it is necessary to consider pairs of quasi-nodes. In fact, Harbusch (1990) defined such a treatment of TAG where only one feature structure is associated with each node. One could argue that it may be inefficient (for instance, when implementing the formalism as defined here) to start with the pairs of quasi-nodes and then try to merge them eventually when possible. Strategies to improve processing may be considered particularly if we believe that, on an average, a relatively small proportion of potential sites will become actual targets of adjunctions during a derivation of a sentence. Then (to improve performance) we could specify that by default the associated pa</context>
<context position="39447" citStr="Harbusch (1990)" startWordPosition="6562" endWordPosition="6563">e structures associated with the top and bottom quasi-nodes. Now if adjunction takes place at a node in some tree that has been derived, then the &amp;quot;unification&amp;quot; that has been performed has to be undone to recover the top (relating it with its ancestors and siblings) and bottom (based on the structure it dominates) feature structures. This undoing can be quite complex, especially if the pair of quasi-nodes in question is a part of a derived object rather than an elementary structure specified by the grammar. The above description essentially captures the definition of the formalism presented by Harbusch (1990). Another point can be made about the scheme presented above. Consider a node whose top and bottom feature structures are incompatible and hence nonunifiable. If we were to insist that only one feature structure were to be associated with every node then we can only unify the compatible parts of the top and bottom feature structures and somehow (perhaps with the use of a device like ANY) retain (effectively) the OA constraint machinery. 3. Feature Structures and Adjoining Constraints In the traditional definition of a TAG, the adjoining possibilities at a node is determined by the association </context>
<context position="88079" citStr="Harbusch (1990)" startWordPosition="14957" endWordPosition="14958">ipulated by such a grammar are not trees but descriptions of well-formed syntactic structures. From D-Theory, we have adopted the use of domination relation and use of identifiers to refer to nodes while describing such structures. Quasi-trees were introduced to depict pictorially partial descriptions of trees. The pairing of quasi-nodes (with domination link between them) was then used to explain the association of two feature structures with individual nodes in previous definition of Feature structureâ€” based Tree Adjoining Grammars (FTAG). In fact, we also show that the formalism defined in Harbusch (1990) (where only one feature structure is associated with every node) turns out to be similar to the use of FTAG with an additional decision to merge every pair of quasi-nodes by default. We argue that such defaults lead to nonmonotonic behavior. One can now view FTAG as a generalization of TAG in that arbitrary categories (as used in GPSG) can label nodes, instead of just atomic symbols (nonterminals) as in TAG. In fact, by not insisting that a pair of quasi-nodes be labeled by the same category in FTAG, as was done in TAG, we argue that the &amp;quot;adjoining constraints&amp;quot; follow from the definition of a</context>
</contexts>
<marker>Harbusch, 1990</marker>
<rawString>Harbusch, K. (1990). &amp;quot;Constraining tree adjoining grammars by unification.&amp;quot; In Proceedings, 13th International Conference on Computational Linguistics.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Henderson</author>
</authors>
<title>Structure Unification Grammar: A Unifying Framework for Investigating Natural Language.&amp;quot;</title>
<date>1990</date>
<tech>Technical Report MS-CIS-90-94,</tech>
<institution>Department of Computer and Information Science, University of Pennsylvania.</institution>
<contexts>
<context position="25326" citStr="Henderson (1990)" startWordPosition="4218" endWordPosition="4219">of explicitly using a pair of quasi-nodes and drawing the domination (dashed) link between them, we can also depict it in a more traditional manner found in TAG literature (see a7 in Figure 5). In such a case a node, such as the VP node in a7, will have two feature structures (the ones associated with the two quasi-nodes) associated with it. This matches the previous definition of feature structureâ€”based Tree Adjoining Grammars where these two feature structures were called the top and bottom feature structures associated with a node. In fact, this correspondence was independently observed by Henderson (1990) and was used in the translation of an FTAG to a Structure Unification Grammar. When convenient, we will use &amp;quot;a node with two associated feature structures&amp;quot; instead of &amp;quot;a pair of quasi-nodes (with one feature structure associated with each quasi-node).&amp;quot; If the objects manipulated by a TAG are considered as quasi-trees, a natural question arises when one considers what would be a node in a tree as a pair of quasi-nodes. For our current purposes, this aspect is not relevant. For instance, the auxiliary quasitrees, /33104105) 06 in Figure 6, are equally acceptable (well-formed structures) in the </context>
</contexts>
<marker>Henderson, 1990</marker>
<rawString>Henderson, J. (1990). &amp;quot;Structure Unification Grammar: A Unifying Framework for Investigating Natural Language.&amp;quot; Technical Report MS-CIS-90-94, Department of Computer and Information Science, University of Pennsylvania.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Johnson</author>
</authors>
<title>Attribute Value Logic and the Theory of Grammar.</title>
<date>1988</date>
<publisher>University of Chicago Press.</publisher>
<contexts>
<context position="55655" citStr="Johnson (1988)" startWordPosition="9402" endWordPosition="9403">specify an FTAG that will be convenient for our purposes here. In this section, we describe a logical formulation of the unification-based approach to TAGs. The purpose of providing a logical formulation of FTAG is so that we can find the denotation of an FTAG grammar (the set of structures generated) as well as contrast it with context-free grammar-based unification grammars. To define the denotation of an FTAG grammar, we will first describe how an FTAG grammar can be represented. This representation uses the logical formulation of feature structures as given by Kasper and Rounds (1986) and Johnson (1988) and is similar in approach to the logical formulation of Functional Unification Grammar (FUG) given by Rounds and Manaster-Ramer (1987). In the framework of Rounds and Manaster-Ramer (1987), an FUG (or any contextfree grammar with associated unification equations as in, say PATR-II) can be represented by means of a set of equations, using the formulae of Kasperâ€”Rounds to represent feature structures. For example, a context-free grammar rule S NP VP can be represented as s ::= CAT: S A 1 : np A 2 : vp. Here s, np, and vp are type variables. The attributes 1 and 2 are used to indicate the first</context>
</contexts>
<marker>Johnson, 1988</marker>
<rawString>Johnson, M. (1988). Attribute Value Logic and the Theory of Grammar. University of Chicago Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A K Joshi</author>
</authors>
<title>An introduction to tree adjoining grammar.&amp;quot;</title>
<date>1987</date>
<journal>In Mathematics of Language, edited by A. Manaster-Ramer,</journal>
<pages>87--115</pages>
<publisher>Benjamins Publishing Company.</publisher>
<contexts>
<context position="70512" citStr="Joshi (1987)" startWordPosition="12028" endWordPosition="12029"> you buy a photograph of a copy of? This form of long-distance dependency cannot be localized in a TAG if we wish to localize the predicate-argument dependencies as well (for details, see Kroch [19871). On the other hand, an analysis has been given using a version of multi-component adjoining. Multi-Component Tree Adjoining Grammar (MCTAG) differs from (the traditional definition of) TAG in that the elementary objects of the grammar are sets of trees rather than trees, and multi-component adjoining involves the composition of these elementary sets of trees&apos; (rather than elementary trees). See Joshi (1987) for more details on Multi-Component Tree Adjoining Grammars (MCTAG). The multi-component sets, given in Figure 16, may be used to give an account for sentences (1) and (2). Obtained by adjoining the two components of 017 in a15t N can be used for sentence (1) (Figure 17). The need for introducing multi-component sets and multi-component adjoining (in this case, at least) arises because of the decision in traditional TAGs to compose trees (rather than descriptions of trees, i.e., quasi-trees). In particular, the domination relations allow us to give partial descriptions of trees such as a16 (i</context>
</contexts>
<marker>Joshi, 1987</marker>
<rawString>Joshi, A. K. (1987). &amp;quot;An introduction to tree adjoining grammar.&amp;quot; In Mathematics of Language, edited by A. Manaster-Ramer, 87-115. Benjamins Publishing Company.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A K Joshi</author>
</authors>
<title>How much context-sensitivity is necessary for characterizing structural descriptionsâ€”Tree Adjoining Grammars.&amp;quot;</title>
<date>1985</date>
<booktitle>In Natural Language Processingâ€”Theoretical, Computational and Psychological Perspective,</booktitle>
<pages>206--250</pages>
<publisher>Cambridge University Press.</publisher>
<note>edited by</note>
<contexts>
<context position="2649" citStr="Joshi (1985)" startWordPosition="398" endWordPosition="399">d Head-driven Phrase Structure Grammars (HPSGs), are said to take the unification-based approach to grammars. A common aspect shared by these grammars or theories is that they are based on specifying constraints that define well-formed structures. This work discusses viewing Tree Adjoining Grammars (TAG) in such a manner and embedding it in a unification-based framework. Tree Adjoining Grammars (TAG) were first introduced by Joshi, Levy, and Takahashi (1975). A preliminary study of this formalism, from the point of view of its formal properties and linguistic applicability, was carried out by Joshi (1985). A detailed study of the linguistic relevance of TAG was done by Kroch and Joshi (1985). Abeille et al. (1990) discuss a fairly substantial grammar for English using the lexicalized approach to TAG that was originally proposed by Schabes, Abeille, and Joshi (1988). * Department of Computer and Information Sciences, University of Delaware, Newark, DE 19716. (i) 1992 Association for Computational Linguistics Computational Linguistics Volume 18, Number 4 TAG is defined as a tree rewriting system. In the definition given traditionally, a TAG is defined by a finite set of trees and an operation ca</context>
<context position="13484" citStr="Joshi (1985)" startWordPosition="2189" endWordPosition="2190">aint if no auxiliary tree is allowed to be adjoined at that node. An NA constraint is specified by associating an empty set with a node. In current TAG literature NA constraints are therefore said to be a special case of SA constraints. In addition, for some nodes it is necessary to insist that adjunction is mandatory at a node. In such a case, we say that the node has an Obligatory Adjoining (OA) constraint. A more detailed description of TAG, the use of adjoining constraints, their propagation during derivation, and their usefulness in providing linguistic analyses may be found in Kroch and Joshi (1985). At this point we would like to note that by the specification of such adjoining constraints are stipulations of the adjunction possibil485 Computational Linguistics Volume 18, Number 4 ities at that node. On the other hand, we will see that in the version of FTAG we define here, decisions such as the choice of auxiliary trees that can be adjoined at a node or whether adjunction is mandatory at a node follows from the assertions (stated in terms of feature structures) about the linguistic features of individual nodes, rather than being specific to the adjoining operation. In fact, in this pap</context>
<context position="45039" citStr="Joshi 1985" startWordPosition="7551" endWordPosition="7552">ible ways of interpreting &amp;quot;NA constraints&amp;quot; in the quasi-tree framework. Firstly, a pair of quasi-nodes with an &amp;quot;NA constraint&amp;quot; may be interpreted as a stipulation that insists that no quasi-tree can be adjoined at this pair; a statement made regardless of the nature of the auxiliary quasi-trees in the grammar. This may for instance be made if we wish to allow only certain derivation sequences. One could argue that the reason for insisting that foot nodes of complement&apos; auxiliary trees have NA constraints, as is the case in most TAG accounts, is to avoid certain derivation sequences (Kroch and Joshi 1985). On the other hand, we may also interpret the association of &amp;quot;NA constraint&amp;quot; with a pair of quasi-nodes as a statement that none of the auxiliary quasi-trees in the grammar matches the requirements of the type of auxiliary quasi-trees that can be 3 A complement tree (for example, the tree i32 in Figure 2) is one where the foot node corresponds to one of the arguments required by the anchor of the tree. 496 K. Vijay-Shanker Using Descriptions of Trees in a Tree Adjoining Grammar adjoined at this pair (as determined by the associated feature structures). Unlike the previous case, adjunction is </context>
</contexts>
<marker>Joshi, 1985</marker>
<rawString>Joshi, A. K. (1985). &amp;quot;How much context-sensitivity is necessary for characterizing structural descriptionsâ€”Tree Adjoining Grammars.&amp;quot; In Natural Language Processingâ€”Theoretical, Computational and Psychological Perspective, edited by D. Dowty, L. Karttunen, and A. Zwicky, 206-250. Cambridge University Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A K Joshi</author>
<author>K Vijay-Shanker</author>
</authors>
<title>Treatment of long-distance dependencies in LFG and TAG.&amp;quot;</title>
<date>1989</date>
<booktitle>In Proceedings, 27th Annual Meeting of the Association for Computational Linguistics,</booktitle>
<pages>220--227</pages>
<marker>Joshi, Vijay-Shanker, 1989</marker>
<rawString>Joshi, A. K., and Vijay-Shanker, K. (1989). &amp;quot;Treatment of long-distance dependencies in LFG and TAG.&amp;quot; In Proceedings, 27th Annual Meeting of the Association for Computational Linguistics, 220-227.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A K Joshi</author>
<author>L S Levy</author>
<author>M Takahashi</author>
</authors>
<title>Tree adjunct grammars.&amp;quot;</title>
<date>1975</date>
<journal>Journal of Computer and System Sciences,</journal>
<volume>10</volume>
<issue>1</issue>
<pages>136--163</pages>
<marker>Joshi, Levy, Takahashi, 1975</marker>
<rawString>Joshi, A. K.; Levy, L. S.; and Takahashi, M. (1975). &amp;quot;Tree adjunct grammars.&amp;quot; Journal of Computer and System Sciences, 10(1), 136-163.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R M Kaplan</author>
<author>J T Maxwell</author>
</authors>
<title>An algorithm for functional uncertainty.&amp;quot;</title>
<date>1988</date>
<booktitle>In Proceedings, 12th International Conference on Computational Linguistics,</booktitle>
<pages>297--302</pages>
<contexts>
<context position="23039" citStr="Kaplan and Maxwell 1988" startWordPosition="3834" endWordPosition="3837">indeed the appropriate structures to consider. For instance, no treatment of topicalization can justify the identification of the nodes referred to by s2 and s3. Thus, a pair of quasi-nodes is appropriate for their representation. As in the case of vpi and vp2 quasi-nodes in a4, one can only claim that s2 quasi-node dominates s3 quasi-node (again, by domination, we also allow for the possibility that s2 and s3 can refer to the same node). It may be interesting to contrast this lack of information in a5 (whether or not they refer to the same node) with the use of functional uncertainty in LFG (Kaplan and Maxwell 1988) to account for long-distance dependency In order to consistently maintain the distinction between descriptions of trees with trees, while discussing the proposed interpretation of TAG we will use the terms 488 K. Vijay-Shanker Using Descriptions of Trees in a Tree Adjoining Grammar as a7 : NP 1 [head: agr : &lt;I&gt; (1 VP [head: [sub.1 [agr : &lt;14 VP [head : &lt;2&gt; [1 NP1 [head [agr : &lt;2&gt; (1 VP [head: [sub): [agr :.c2&gt;1 [head: &lt;I&gt;1 /N. &apos;14 [head: &lt;I&gt; [1 NP-4. vO head : &lt;2..A NP. Figure 5 Associating feature structures with quasi-nodes. initial quasi-tree, auxiliary quasi-tree, quasi-root, and quasi-fo</context>
<context position="79877" citStr="Kaplan and Maxwell 1988" startWordPosition="13623" endWordPosition="13626">s and hence also the characteristics of the domination link between paired quasi-nodes) that determine that it is the case that s3 must dominate s1 and not vice versa. In this case we obtain 79 (as shown in Figure 21), a structure obtained by &amp;quot;adjoining&amp;quot; 019. In fact, that s3 must dominate s1 must be derivable from any reasonable linguistic theory that is used to produce the elementary structures concerned (for otherwise a wrong sequence of words would be predicted). One possible explanation of why s3 dominates si could be given by importing a device like the functional uncertainty machinery (Kaplan and Maxwell 1988) used in LFG. The treatment used in LFG, when imported here, would suggest that zero or more structures of the form given by 019 would fit in the gap specified by the domination link between s3 and s4. Thus when the identification of s2 and s4 takes place, 53 must dominate si and again zero or more structures of the form of /319 could fit between s3 and Si now (see Joshi and Vijay-Shanker [1989]) for a discussion of the treatment of long-distance dependency in TAG and LFG). Another way to explain the domination of 53 over si could be done by using the notions of maximal government domains disc</context>
</contexts>
<marker>Kaplan, Maxwell, 1988</marker>
<rawString>Kaplan, R. M., and Maxwell, J. T. (1988). &amp;quot;An algorithm for functional uncertainty.&amp;quot; In Proceedings, 12th International Conference on Computational Linguistics, 297-302.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Kasper</author>
<author>W C Rounds</author>
</authors>
<title>A logical semantics for feature structures.&amp;quot;</title>
<date>1986</date>
<booktitle>In Proceedings, 24th Annual Meeting of the Association for Computational Linguistics,</booktitle>
<pages>257--266</pages>
<contexts>
<context position="55636" citStr="Kasper and Rounds (1986)" startWordPosition="9397" endWordPosition="9400"> be given, but is one way to specify an FTAG that will be convenient for our purposes here. In this section, we describe a logical formulation of the unification-based approach to TAGs. The purpose of providing a logical formulation of FTAG is so that we can find the denotation of an FTAG grammar (the set of structures generated) as well as contrast it with context-free grammar-based unification grammars. To define the denotation of an FTAG grammar, we will first describe how an FTAG grammar can be represented. This representation uses the logical formulation of feature structures as given by Kasper and Rounds (1986) and Johnson (1988) and is similar in approach to the logical formulation of Functional Unification Grammar (FUG) given by Rounds and Manaster-Ramer (1987). In the framework of Rounds and Manaster-Ramer (1987), an FUG (or any contextfree grammar with associated unification equations as in, say PATR-II) can be represented by means of a set of equations, using the formulae of Kasperâ€”Rounds to represent feature structures. For example, a context-free grammar rule S NP VP can be represented as s ::= CAT: S A 1 : np A 2 : vp. Here s, np, and vp are type variables. The attributes 1 and 2 are used to</context>
<context position="63166" citStr="Kasper and Rounds (1986)" startWordPosition="10747" endWordPosition="10750"> predicate symbol 01 A 02 where 01, 02 are formulae 01 V 02 where 01,02 are formulae. From the discussion given in the previous section any FTAG can be stated as ,tm,n) &lt; &gt;qn where 01, â€¢ â€¢ â€¢ , On are formulae and â€¢ â€¢ â€¢ tm,i ti,n â€¢ â€¢ â€¢ , ttn,n are terms such that for 1 &lt; i,j &lt; n, if i j then the symbol P, Pl. Of course for describing an FTAG, monadic and binary predicates are enough. The structures that terms denote are the finite state automata (actually equivalence classes containing such automata; for details, we refer to Moshier [1988] for a discussion about these structures) as defined by Kasper and Rounds (1986) and used in defining the satisfiability of formulae in their logic. We can give a fixed point semantics of a grammar in the standard way. Definition Let p be a function that maps each variable to an automaton. We define a Value function as a partial function that returns the denotation of a term (an automaton) relative to an environment (mapping variables to automata). â€¢ Value(x) = p(x) where x is a variable. â€¢ Value(a) = Aa where a is an atom, where A, is the atomic structure that corresponds to the atom a. â€¢ Value p(1(t)) = .AII, if ,4// is defined, where 1 is an attribute, t is a term and </context>
</contexts>
<marker>Kasper, Rounds, 1986</marker>
<rawString>Kasper, R., and Rounds, W. C. (1986). &amp;quot;A logical semantics for feature structures.&amp;quot; In Proceedings, 24th Annual Meeting of the Association for Computational Linguistics, 257-266.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A S Kroch</author>
</authors>
<title>Asymmetries in long distance extraction in a tag grammar.&amp;quot; In Alternative Conceptions of Phrase Structure,</title>
<date>1989</date>
<pages>66--98</pages>
<publisher>University of Chicago Press.</publisher>
<note>edited by</note>
<contexts>
<context position="80498" citStr="Kroch (1989)" startWordPosition="13740" endWordPosition="13741">LFG. The treatment used in LFG, when imported here, would suggest that zero or more structures of the form given by 019 would fit in the gap specified by the domination link between s3 and s4. Thus when the identification of s2 and s4 takes place, 53 must dominate si and again zero or more structures of the form of /319 could fit between s3 and Si now (see Joshi and Vijay-Shanker [1989]) for a discussion of the treatment of long-distance dependency in TAG and LFG). Another way to explain the domination of 53 over si could be done by using the notions of maximal government domains discussed by Kroch (1989) and using it now to define the characteristics of the domination links such as that between s3 and s4. Note that once the nature of the adjoining operation has been derived, one can pre-compile out the linguistic principles and machinery used to express it. Thus even if one uses, say, the functional uncertainty machinery or maximal government domains, these additional devices (used during the developmental stages) of the grammar need not be used again during the derivation process once we have derived the adjoining operation. This is analogous to the situation with elementary structures. Some</context>
</contexts>
<marker>Kroch, 1989</marker>
<rawString>Kroch, A. S. (1989). &amp;quot;Asymmetries in long distance extraction in a tag grammar.&amp;quot; In Alternative Conceptions of Phrase Structure, edited by M. Baltin and A. Kroch, 66-98. University of Chicago Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A S Kroch</author>
</authors>
<title>Unbounded dependencies and subjacency in a tree adjoining grammar.&amp;quot;</title>
<date>1987</date>
<journal>In Mathematics of Language, edited by A. Manaster-Ramer,</journal>
<pages>143--172</pages>
<publisher>Benjamins Publishing Company.</publisher>
<marker>Kroch, 1987</marker>
<rawString>Kroch, A. S. (1987). &amp;quot;Unbounded dependencies and subjacency in a tree adjoining grammar.&amp;quot; In Mathematics of Language, edited by A. Manaster-Ramer, 143-172. Benjamins Publishing Company.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Kroch</author>
<author>A K Joshi</author>
</authors>
<title>Linguistic relevance of tree adjoining grammars.&amp;quot;</title>
<date>1985</date>
<tech>Technical report MS-CI-85-18,</tech>
<institution>Department of Computer and Information Science, University of Pennsylvania.</institution>
<contexts>
<context position="2737" citStr="Kroch and Joshi (1985)" startWordPosition="413" endWordPosition="416">ion-based approach to grammars. A common aspect shared by these grammars or theories is that they are based on specifying constraints that define well-formed structures. This work discusses viewing Tree Adjoining Grammars (TAG) in such a manner and embedding it in a unification-based framework. Tree Adjoining Grammars (TAG) were first introduced by Joshi, Levy, and Takahashi (1975). A preliminary study of this formalism, from the point of view of its formal properties and linguistic applicability, was carried out by Joshi (1985). A detailed study of the linguistic relevance of TAG was done by Kroch and Joshi (1985). Abeille et al. (1990) discuss a fairly substantial grammar for English using the lexicalized approach to TAG that was originally proposed by Schabes, Abeille, and Joshi (1988). * Department of Computer and Information Sciences, University of Delaware, Newark, DE 19716. (i) 1992 Association for Computational Linguistics Computational Linguistics Volume 18, Number 4 TAG is defined as a tree rewriting system. In the definition given traditionally, a TAG is defined by a finite set of trees and an operation called adjoining to compose trees. One of the basic intuitions underlying the use of the T</context>
<context position="13484" citStr="Kroch and Joshi (1985)" startWordPosition="2187" endWordPosition="2190">NA) constraint if no auxiliary tree is allowed to be adjoined at that node. An NA constraint is specified by associating an empty set with a node. In current TAG literature NA constraints are therefore said to be a special case of SA constraints. In addition, for some nodes it is necessary to insist that adjunction is mandatory at a node. In such a case, we say that the node has an Obligatory Adjoining (OA) constraint. A more detailed description of TAG, the use of adjoining constraints, their propagation during derivation, and their usefulness in providing linguistic analyses may be found in Kroch and Joshi (1985). At this point we would like to note that by the specification of such adjoining constraints are stipulations of the adjunction possibil485 Computational Linguistics Volume 18, Number 4 ities at that node. On the other hand, we will see that in the version of FTAG we define here, decisions such as the choice of auxiliary trees that can be adjoined at a node or whether adjunction is mandatory at a node follows from the assertions (stated in terms of feature structures) about the linguistic features of individual nodes, rather than being specific to the adjoining operation. In fact, in this pap</context>
<context position="45039" citStr="Kroch and Joshi 1985" startWordPosition="7549" endWordPosition="7552">e two possible ways of interpreting &amp;quot;NA constraints&amp;quot; in the quasi-tree framework. Firstly, a pair of quasi-nodes with an &amp;quot;NA constraint&amp;quot; may be interpreted as a stipulation that insists that no quasi-tree can be adjoined at this pair; a statement made regardless of the nature of the auxiliary quasi-trees in the grammar. This may for instance be made if we wish to allow only certain derivation sequences. One could argue that the reason for insisting that foot nodes of complement&apos; auxiliary trees have NA constraints, as is the case in most TAG accounts, is to avoid certain derivation sequences (Kroch and Joshi 1985). On the other hand, we may also interpret the association of &amp;quot;NA constraint&amp;quot; with a pair of quasi-nodes as a statement that none of the auxiliary quasi-trees in the grammar matches the requirements of the type of auxiliary quasi-trees that can be 3 A complement tree (for example, the tree i32 in Figure 2) is one where the foot node corresponds to one of the arguments required by the anchor of the tree. 496 K. Vijay-Shanker Using Descriptions of Trees in a Tree Adjoining Grammar adjoined at this pair (as determined by the associated feature structures). Unlike the previous case, adjunction is </context>
</contexts>
<marker>Kroch, Joshi, 1985</marker>
<rawString>Kroch, A., and Joshi, A. K. (1985). &amp;quot;Linguistic relevance of tree adjoining grammars.&amp;quot; Technical report MS-CI-85-18, Department of Computer and Information Science, University of Pennsylvania.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Marcus</author>
<author>D Hindle</author>
<author>M M K Fleck</author>
</authors>
<title>Vijay-Shanker Using Descriptions of Trees in a Tree Adjoining Grammar</title>
<date>1983</date>
<booktitle>In Proceedings, 21st Annual Meeting of the Association for Computational Linguistics,</booktitle>
<pages>129--136</pages>
<marker>Marcus, Hindle, Fleck, 1983</marker>
<rawString>Marcus, M.; Hindle, D.; and Fleck, M. M. K. Vijay-Shanker Using Descriptions of Trees in a Tree Adjoining Grammar (1983). &amp;quot;D-theoryâ€”talking about talking about trees.&amp;quot; In Proceedings, 21st Annual Meeting of the Association for Computational Linguistics, 129-136.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M A Moshier</author>
</authors>
<title>Extensions to unification grammar for the description of programming languages. Doctoral dissertation,</title>
<date>1988</date>
<institution>University of Michigan,</institution>
<location>Ann Arbor, MI.</location>
<marker>Moshier, 1988</marker>
<rawString>Moshier, M. A. (1988). Extensions to unification grammar for the description of programming languages. Doctoral dissertation, University of Michigan, Ann Arbor, MI.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Rogers</author>
<author>K Vijay-Shanker</author>
</authors>
<title>Reasoning with descriptions of trees.&amp;quot;</title>
<date>1992</date>
<booktitle>In Proceedings, 30th Annual Meeting of the Association for Computational Linguistics,</booktitle>
<pages>72--80</pages>
<contexts>
<context position="86244" citStr="Rogers and Vijay-Shanker (1992)" startWordPosition="14674" endWordPosition="14677">. However, in this case since the labels of these quasi-nodes are different, they cannot refer to the same node. Thus, in this case we have a path length that is greater than 0. â€¢ 0p2 quasi-node immediately dominates the v2 quasi-node (i.e., path length=1). â€¢ Since v1 and v2 quasi-nodes are identified and since we insist on a tree structure, we have vpi and vp2 quasi-nodes in the domination relation. In fact vpi quasi-node must dominate vp2 quasi-node in the resulting structure by a path of length 0 or more (from the two observations above). Thus we get the structure given by ci23 as desired. Rogers and Vijay-Shanker (1992) describe a proof system that can be used to perform the type of reasoning involved in constructing the structure a23 as described above. In the manner described above we can build the default structure for every subcategorization frame. Such structures will be specified in any lexicalized TAG; the difference (in the envisaged specification method) is that we no longer precompile out 514 K. Vijay-Shanker Using Descriptions of Trees in a Tree Adjoining Grammar all possibilities (thus repeating the structure 712 in all structures associated with every type of verb). To complete the description o</context>
</contexts>
<marker>Rogers, Vijay-Shanker, 1992</marker>
<rawString>Rogers, J., and Vijay-Shanker, K. (1992). &amp;quot;Reasoning with descriptions of trees.&amp;quot; In Proceedings, 30th Annual Meeting of the Association for Computational Linguistics, 72-80.</rawString>
</citation>
<citation valid="true">
<authors>
<author>W Rounds</author>
<author>A Manaster-Ramer</author>
</authors>
<title>A logical version of functional grammar.&amp;quot;</title>
<date>1987</date>
<booktitle>In Proceedings, 25th Annual Meeting of the Association for Computational Linguistics,</booktitle>
<pages>89--96</pages>
<contexts>
<context position="55791" citStr="Rounds and Manaster-Ramer (1987)" startWordPosition="9420" endWordPosition="9423">he unification-based approach to TAGs. The purpose of providing a logical formulation of FTAG is so that we can find the denotation of an FTAG grammar (the set of structures generated) as well as contrast it with context-free grammar-based unification grammars. To define the denotation of an FTAG grammar, we will first describe how an FTAG grammar can be represented. This representation uses the logical formulation of feature structures as given by Kasper and Rounds (1986) and Johnson (1988) and is similar in approach to the logical formulation of Functional Unification Grammar (FUG) given by Rounds and Manaster-Ramer (1987). In the framework of Rounds and Manaster-Ramer (1987), an FUG (or any contextfree grammar with associated unification equations as in, say PATR-II) can be represented by means of a set of equations, using the formulae of Kasperâ€”Rounds to represent feature structures. For example, a context-free grammar rule S NP VP can be represented as s ::= CAT: S A 1 : np A 2 : vp. Here s, np, and vp are type variables. The attributes 1 and 2 are used to indicate the first and second children respectively. Using standard techniques to derive fixed points from a set of recursive rules, the denotation of typ</context>
<context position="61293" citStr="Rounds and Manaster-Ramer (1987)" startWordPosition="10383" endWordPosition="10386">or a quasi-node (referred to as x) where substitution can take place, we can specify Inittree(x) to specify the substitution. We will now illustrate the representation of an FTAG grammar, shown pictorially in Figure 15. This grammar contains a14 and 016. Apart from the cat information, the only other attribute used in the feature structures are count (counts the number of adjoining operations used in deriving a tree), one (used in counting), and attributes 1, 2, 3 (which are used for specifying the children of a node). To compare our representational scheme for FTAG with that for FUG given by Rounds and Manaster-Ramer (1987), we have used predicate symbols instead of type variables. The use of monadic predicates alone is sufficient to represent FUG (or actually a CFG-based unification grammar) since only &amp;quot;substitution&amp;quot; is used. Binary /316 stl a 14 s Xâ€¢â€¢â€¢&amp;quot;*....1r S [count : 03 S [count : [one : &lt;I&gt; (11 Z a S [count : b 1 \ S [count &lt;1,] Z2 y Inittree(x) A cat(x) S .a.714(x) cat(x) S A Dorn(z,y) A cat(y) SA 1(y) z A count(y) zero A cat(z) c 1316(x , y) V (x y) cat(x) S A Dom(x , z) A cat(z) S A one(count(z)) P.,- count(z2) Al(z) z1 A 2(z) Pe, z2 A 3(z) z3 A cat(zi) P.: a ADom(z2, y) A cat(z2) S A cat(z3) b A cat(y</context>
<context position="65427" citStr="Rounds and Manaster-Ramer (1987)" startWordPosition="11180" endWordPosition="11183">on TG (I) given by Definition For all substitutions, p, where Va/uep(t,,j) is defined for 1 &lt; j (Value (t,1),.. , Value ,(t,)) E T G (I) (P i) if (I ,p) H Ordering relations We use the ordering relationship, E, as defined by Rounds and Kasper (1986) i.e., A1 E A2 iff there is a homomorphism mapping the states of A1 to the states of A2 that preserves the transition and output functions. We extend this ordering relation to an ordering on n-tuples and state that â€¢â€¢â€¢ ,A) E , iff for 1 &lt; i &lt; n A, E B. Among pairs of sets of n-tuples of automata, say D1, D2, we use the same ordering as that used by Rounds and Manaster-Ramer (1987) and state that Di E D2 iff Di c D2. The least element among the sets of n-tuples of automata is the empty set. The ordering among interpretation functions is defined as 11 E /2 iff for all predicate symbols P. (P) LI I2(P), i.e., 11(P) C I2(P). Lemma 4.1. If /1 E I2, then for all environments, p, and formulae, 0, if (11, p) Hcb then (12, p) H c. This can be easily shown by using induction on the structure of the formula 0. Theorem 4.1. The transformation function is monotonic. Let /1 E .12. We have to show for all P that TG(II)(P) C TG(I2)(P). Let P(ti, . . â€¢ , tn) &lt; &gt; be a part of the gramma</context>
</contexts>
<marker>Rounds, Manaster-Ramer, 1987</marker>
<rawString>Rounds, W., and Manaster-Ramer, A. (1987). &amp;quot;A logical version of functional grammar.&amp;quot; In Proceedings, 25th Annual Meeting of the Association for Computational Linguistics, 89-96.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Y Schabes</author>
<author>P Paroubek</author>
</authors>
<title>Xtagâ€”a graphical workbench for developing tree adjoining grammars.&amp;quot;</title>
<date>1992</date>
<booktitle>In Proceedings, Third Conference on Applied Natural Language Processing,</booktitle>
<pages>216--223</pages>
<marker>Schabes, Paroubek, 1992</marker>
<rawString>Schabes, Y., and Paroubek, P. (1992). &amp;quot;Xtagâ€”a graphical workbench for developing tree adjoining grammars.&amp;quot; In Proceedings, Third Conference on Applied Natural Language Processing, 216-223.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Y Schabes</author>
<author>A Abeille</author>
<author>A K Joshi</author>
</authors>
<title>New parsing strategies for tree adjoining grammars.&amp;quot;</title>
<date>1988</date>
<booktitle>In Proceedings, 12th International Conference on Computational Linguistics,</booktitle>
<pages>578--583</pages>
<marker>Schabes, Abeille, Joshi, 1988</marker>
<rawString>Schabes, Y; Abeille, A.; and Joshi, A. K. (1988). &amp;quot;New parsing strategies for tree adjoining grammars.&amp;quot; In Proceedings, 12th International Conference on Computational Linguistics, 578-583.</rawString>
</citation>
<citation valid="true">
<authors>
<author>K Vijay-Shanker</author>
</authors>
<title>A study of tree adjoining grammars. Doctoral dissertation,</title>
<date>1987</date>
<institution>University of Pennsylvania,</institution>
<location>Philadelphia, PA.</location>
<contexts>
<context position="850" citStr="Vijay-Shanker (1987)" startWordPosition="129" endWordPosition="130">ork in a manner consistent with the declarative approach taken in this framework. In the new interpretation we present in this paper, the objects manipulated by a TAG are considered to be descriptions of trees. This is in contrast to the traditional view that in a TAG the composition operations of adjoining and substitution combine trees. Borrowing ideas from Description Theory, we propose quasi-trees as a means to represent partial descriptions of trees. Using quasi-trees, we are able to justify the definition of feature structureâ€” based Tree Adjoining Grammars (FTAG) that was first given in Vijay-Shanker (1987) and VijayShanker and Joshi (1988). In the definition of the FTAG formalism given here, we argue that a grammar manipulates descriptions of trees (i.e., quasi-trees); whereas the structures derived by a grammar are trees that are obtained by taking the minimal readings of such descriptions. We then build on and refine the earlier version of FTAG, give examples that illustrate the usefulness of embedding TAG in the unification framework, and present a logical formulation (and its associated semantics) of FTAG that shows the separation between descriptions of well-formed structures and the actua</context>
<context position="5641" citStr="Vijay-Shanker 1987" startWordPosition="871" endWordPosition="872"> we start by giving the currently used definition of TAG. In Section 2, we show that this definition is not consistent with the assumptions made in the unification framework. We propose a novel way of interpreting the basic objects of a TAG, borrowing ideas from description theory (D-theory). By means of an example, we introduce the notion of quasi-trees. We then show how TAG can be embedded in a unification-based framework. This interpretation of the objects manipulated by a TAG grammar as quasi-trees not only leads to our current definition of FTAG, but also explains the earlier definition (Vijay-Shanker 1987; VijayShanker and Joshi 1988). In Section 3, we give examples to show why the introduction of feature structures and unification adds to the descriptive capabilities of TAG. In particular, we focus on the implementation of the so-called adjoining constraints (that determine locally which structures can be used for adjoining and whether adjunction is mandatory). We will show that not only can adjoining constraints be specified in a linguistically more appealing manner now, but also that in several cases redundant specifications of structural descriptions can be avoided. In Section 5, we consid</context>
</contexts>
<marker>Vijay-Shanker, 1987</marker>
<rawString>Vijay-Shanker, K. (1987). A study of tree adjoining grammars. Doctoral dissertation, University of Pennsylvania, Philadelphia, PA.</rawString>
</citation>
<citation valid="true">
<authors>
<author>K Vijay-Shanker</author>
<author>A K Joshi</author>
</authors>
<title>Feature structure based tree adjoining grammars.&amp;quot;</title>
<date>1988</date>
<booktitle>In Proceedings, 12th International Conference on Computational Linguistics,</booktitle>
<pages>714--719</pages>
<marker>Vijay-Shanker, Joshi, 1988</marker>
<rawString>Vijay-Shanker, K., and Joshi, A. K. (1988). &amp;quot;Feature structure based tree adjoining grammars.&amp;quot; In Proceedings, 12th International Conference on Computational Linguistics, 714-719.</rawString>
</citation>
<citation valid="true">
<authors>
<author>K Vijay-Shanker</author>
<author>Y Schabes</author>
</authors>
<title>Structure sharing in a lexicalized tree adjoining grammar.&amp;quot;</title>
<date>1992</date>
<booktitle>In Proceedings, 14th International Conference on Computational Linguistics,</booktitle>
<pages>205--211</pages>
<contexts>
<context position="87111" citStr="Vijay-Shanker and Schabes 1992" startWordPosition="14806" endWordPosition="14809">. Such structures will be specified in any lexicalized TAG; the difference (in the envisaged specification method) is that we no longer precompile out 514 K. Vijay-Shanker Using Descriptions of Trees in a Tree Adjoining Grammar all possibilities (thus repeating the structure 712 in all structures associated with every type of verb). To complete the description of the rest of the elementary quasi-trees one would have to use transformations, meta-rules, or lexical rules to specify the structures for passivization, wh-movement, topicalization, etc. Work along this direction is being carried out (Vijay-Shanker and Schabes 1992). 6. Conclusions In this paper, we have embedded TAG in the unification framework in a manner consistent with the constraint-based approach used in this framework. Starting from first principles and taking the localization of dependencies within the elementary structures of a TAG grammar as the only basic principle, we have argued that the objects manipulated by such a grammar are not trees but descriptions of well-formed syntactic structures. From D-Theory, we have adopted the use of domination relation and use of identifiers to refer to nodes while describing such structures. Quasi-trees wer</context>
</contexts>
<marker>Vijay-Shanker, Schabes, 1992</marker>
<rawString>Vijay-Shanker, K., and Schabes, Y. (1992). &amp;quot;Structure sharing in a lexicalized tree adjoining grammar.&amp;quot; In Proceedings, 14th International Conference on Computational Linguistics, 205-211.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>