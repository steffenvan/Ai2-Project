<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.019310">
<title confidence="0.94571">
Grammatical Framework Web Service
</title>
<author confidence="0.95542">
Bj¨orn Bringert* and Krasimir Angelov and Aarne Ranta
</author>
<affiliation confidence="0.999416">
Department of Computer Science and Engineering
Chalmers University of Technology and University of Gothenburg
</affiliation>
<email confidence="0.991257">
{bringert,krasimir,aarne}@chalmers.se
</email>
<sectionHeader confidence="0.997279" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999930785714286">
We present a web service for natural language
parsing, prediction, generation, and translation
using grammars in Portable Grammar Format
(PGF), the target format of the Grammatical
Framework (GF) grammar compiler. The web
service implementation is open source, works
with any PGF grammar, and with any web
server that supports FastCGI. The service ex-
poses a simple interface which makes it pos-
sible to use it for interactive natural language
web applications. We describe the function-
ality and interface of the web service, and
demonstrate several applications built on top
of it.
</bodyText>
<sectionHeader confidence="0.999393" genericHeader="keywords">
1 Introduction
</sectionHeader>
<bodyText confidence="0.999976944444444">
Current web applications often consist of JavaScript
code that runs in the user’s web browser, with server-
side code that does the heavy lifting. We present a web
service for natural language processing with Portable
Grammar Format (PGF, Angelov et al., 2008) gram-
mars, which can be used to build interactive natural lan-
guage web applications. PGF is the back-end format
to which Grammatical Framework (GF, Ranta, 2004)
grammars are compiled. PGF has been designed to al-
low efficient implementations.
The web service has a simple API based solely on
HTTP GET requests. It returns responses in JavaScript
Object Notation (JSON, Crockford, 2006). The server-
side program is distributed as part of the GF software
distribution, under the GNU General Public License
(GPL). The program is generic, in the sense that it can
be used with any PGF grammar without any modifica-
tion of the program.
</bodyText>
<sectionHeader confidence="0.998777" genericHeader="introduction">
2 Grammatical Framework
</sectionHeader>
<bodyText confidence="0.998703333333333">
Grammatical Framework (GF, Ranta, 2004) is a type-
theoretical grammar formalism. A GF grammar con-
sists of an abstract syntax, which defines a set of ab-
stract syntax trees, and one or more concrete syntaxes,
which define how abstract syntax trees are mapped to
(and from) strings. The process of producing a string
</bodyText>
<subsectionHeader confidence="0.295456">
*Now at Google Inc.
</subsectionHeader>
<bodyText confidence="0.857543071428571">
(or, more generally, a feature structure) from an ab-
stract syntax tree is called linearization. The oppo-
site, producing an abstract syntax tree (or several, if the
grammar is ambiguous) from a string is called parsing.
In a small, semantically oriented application gram-
mar, the sentence “2 is even” may correspond to the
abstract syntax tree Even 2. In a larger, more syn-
tactically oriented grammar, in this case the English
GF resource grammar (Ranta, 2007), the same sen-
tence can correspond to the abstract syntax tree PhrUtt
NoPConj (UttS (UseCl (TTAnt TPres ASimul)
PPos (PredVP (UsePN (NumPN (NumDigits (Ug
D 2)))) (UseComp (CompAP (PositA even A))))))
NoVoc.
</bodyText>
<subsectionHeader confidence="0.994958">
2.1 Portable Grammar Format (PGF)
</subsectionHeader>
<bodyText confidence="0.9999147">
Portable Grammar Format (PGF, Angelov et al., 2008)
is a low-level format to which GF grammars are com-
piled. The PGF Web Service loads PGF files from disk,
and uses them to serve client requests. These PGF files
are normally produced by compiling GF grammars, but
they could also be produced by other means, for exam-
ple by a compiler from another grammar formalism.
Such compilers currently exist for context-free gram-
mars in BNF and EBNF formats, though they compile
via GF.
</bodyText>
<subsectionHeader confidence="0.999806">
2.2 Parsing and Word Prediction
</subsectionHeader>
<bodyText confidence="0.999170944444445">
For each concrete syntax in a PGF file, there is a pars-
ing grammar, which is a Parallel Multiple Context Free
Grammar (PMCFG, Seki et al., 1991). The PGF inter-
preter uses an efficient parsing algorithm for PMCFG
(Angelov, 2009) which is similar to the Earley algo-
rithm for CFG. The algorithm is top-down and incre-
mental which makes it possible to use it for word com-
pletion. When the whole sentence is known, the parser
just takes the tokens one by one and computes the chart
of all possible parse trees. If the sentence is not yet
complete, then the known tokens can be used to com-
pute a partial parse chart. Since the algorithm is top-
down it is possible to predict the set of valid next tokens
by using just the partial chart.
The prediction can be used in applications to guide
the user to stay within the coverage of the grammar. At
each point the set of valid next tokens is shown and the
user can select one of them.
</bodyText>
<note confidence="0.337591">
Proceedings of the EACL 2009 Demonstrations Session, pages 9–12,
Athens, Greece, 3 April 2009. c�2009 Association for Computational Linguistics
</note>
<page confidence="0.991567">
9
</page>
<figureCaption confidence="0.88748">
Figure 1: Translator interface. This example uses
the Bronzeage grammar, which consists of simple
syntactic rules along with lexica based on Swadesh
lists. Demo at http://digitalgrammars.com/
translate.
</figureCaption>
<bodyText confidence="0.999973625">
The word prediction is based entirely on the gram-
mar and not on any additional n-gram model. This
means that it works with any PGF grammar and no ex-
tra work is needed. In addition it works well even with
long distance dependencies. For example if the subject
is in a particular gender and the verb requires gender
agreement, then the the correct form is predicted, inde-
pendently on how far the verb is from the subject.
</bodyText>
<sectionHeader confidence="0.995091" genericHeader="method">
3 Applications
</sectionHeader>
<bodyText confidence="0.9999605">
Several interactive web applications have been built
with the PGF Web Service. They are all JavaScript pro-
grams which run in the user’s web browser and send
asynchronous HTTP requests to the PGF Web Service.
</bodyText>
<subsectionHeader confidence="0.984253">
3.1 Translator
</subsectionHeader>
<bodyText confidence="0.999983">
The simplest application (see Figure 1) presents the
user with a text field for input, and drop-down boxes for
selecting the grammar and language to use. For every
change in the text field, the application asks the PGF
Web Service for a number of possible completions of
the input, and displays them below the text field. The
user can continue typing, or select one of the sugges-
tions. When the current input can be parsed completely,
the input is translated to all available languages.
</bodyText>
<subsectionHeader confidence="0.999605">
3.2 Fridge Poetry
</subsectionHeader>
<bodyText confidence="0.999405">
The second application is similar in functionality to the
first, but it presents a different user interface. The in-
terface (see Figure 2) mimics the popular refrigerator
magnet poetry sets. However, in contrast to physical
fridge magnets, this application handles inflection au-
tomatically and only allows the construction of gram-
matically correct sentences (as defined by the selected
grammar). It also shows translations for complete in-
puts and allows the user to switch languages.
</bodyText>
<figureCaption confidence="0.99464925">
Figure 2: Fridge poetry screenshot. Demo at http:
//digitalgrammars.com/fridge.
Figure 3: Reasoning screenshot. Demo at http://
digitalgrammars.com/mosg.
</figureCaption>
<subsectionHeader confidence="0.998036">
3.3 Reasoning
</subsectionHeader>
<bodyText confidence="0.999848333333333">
Another application is a natural language reasoning
system which accepts facts and questions from the
users, and tries to answer the questions based on the
facts given. The application uses the PGF Web Service
to parse inputs. It uses two other web services for se-
mantic interpretation and reasoning, respectively. The
semantic interpretation service uses a continuation-
based compositional mapping of abstract syntax terms
to first-order logic formulas (Bringert, 2008). The rea-
soning service is a thin layer on top of the Equinox the-
orem prover and the Paradox model finder (Claessen
and S¨orensson, 2003).
</bodyText>
<sectionHeader confidence="0.999491" genericHeader="method">
4 API
</sectionHeader>
<bodyText confidence="0.99974575">
Below, we will show URI paths for each function,
for example /pgf/food.pgf/parse. Arguments
to each function are given in the URL query string,
in application/x-www-form-urlencoded
(Raggett et al., 1999) format. Thus, if the service is
running on example.com, the URI for a request to
parse the string “this fish is fresh” using the FoodEng
concrete syntax in the food.pgf grammar would
</bodyText>
<page confidence="0.992374">
10
</page>
<bodyText confidence="0.998133851851852">
be: http://example.com/pgf/food.pgf/
parse?input=this+fish+is+fresh&amp;from=
FoodEng. The functions described below each accept
some subset of the following arguments:
from The name of the concrete syntax to parse with
or translate from. Multiple from arguments can
be given, in which case all the specified languages
are tried. If omitted, all languages (that can be
used for parsing) are used.
cat The name of the abstract syntax category to parse
or translate in, or generate output in. If omitted,
the start category specified in the PGF file is used.
to The name of the concrete syntax to linearize or
translate to. Multiple to arguments can be given,
in which case all the specified languages are used.
If omitted, results for all languages are returned.
input The text to parse, complete or translate. If
omitted, the empty string is used.
tree The abstract syntax tree to linearize.
limit The maximum number of results to return.
All results are returned in UTF-8 encoded JSON or
JSONP format. A jsonp argument can be given to
each function to invoke a callback function when the
response is evaluated in a JavaScript interpreter. This
makes it possible to circumvent the Same Origin Policy
in the web browser and call the PGF Web Service from
applications loaded from another server.
</bodyText>
<subsectionHeader confidence="0.96885">
4.1 Grammar List
</subsectionHeader>
<bodyText confidence="0.953734">
/pgf retrieves a list of the available PGF files.
</bodyText>
<subsectionHeader confidence="0.901848">
4.2 Grammar Info
</subsectionHeader>
<bodyText confidence="0.9999768">
/pgf/grammar.pgf, where grammar.pgf is the
name of a PGF file on the server, retrieves information
about the given grammar. This information includes
the name of the abstract syntax, the categories in the
abstract syntax, and the list of concrete syntaxes.
</bodyText>
<subsectionHeader confidence="0.998962">
4.3 Parsing
</subsectionHeader>
<bodyText confidence="0.998660333333333">
/pgf/grammar.pgf/parse parses an input string
and returns a number of abstract syntax trees. Optional
arguments: input, from, cat.
</bodyText>
<subsectionHeader confidence="0.989187">
4.4 Completion
</subsectionHeader>
<bodyText confidence="0.99974225">
/pgf/grammar.pgf/complete returns a list of
predictions for the next token, given a partial input.
Optional arguments: input, from, cat, limit. If
limit is omitted, all results are returned.
</bodyText>
<subsectionHeader confidence="0.973928">
4.5 Linearization
</subsectionHeader>
<bodyText confidence="0.99826475">
/pgf/grammar.pgf/linearize accepts an ab-
stract syntax tree, and returns the results of lineariz-
ing it to one or more languages. Mandatory arguments:
tree. Optional arguments: to.
</bodyText>
<subsectionHeader confidence="0.990169">
4.6 Random Generation
</subsectionHeader>
<bodyText confidence="0.9997055">
/pgf/grammar.pgf/random generates anumber
of randomly generated abstract syntax trees for the se-
lected grammar. Optional arguments: cat, limit. If
limit is omitted, one tree is returned.
</bodyText>
<subsectionHeader confidence="0.958197">
4.7 Translation
</subsectionHeader>
<bodyText confidence="0.99795175">
/pgf/grammar.pgf/translate performs text
to text translation. This is done by parsing, followed
by linearization. Optional arguments: input, from,
cat, to.
</bodyText>
<sectionHeader confidence="0.972436" genericHeader="method">
5 Application to Controlled Languages
</sectionHeader>
<bodyText confidence="0.999976375">
The use of controlled languages is becoming more pop-
ular with the development of Web and Semantic Web
technologies. Related projects include Attempto (At-
tempto, 2008), CLOnE (Funk et al., 2007), and Com-
mon Logic Controlled English (CLCE) (Sowa, 2004).
All these projects provide languages which are subsets
of English and have semantic translations into first or-
der logic (CLCE), OWL (CLOnE) or both (Attempto).
In the case of Attempto, the translation is into first order
logic and if it is possible to the weaker OWL language.
The general idea is that since the controlled language
is a subset of some other language it should be under-
standable to everyone without special training. The op-
posite is not true - not every English sentence is a valid
sentence in the controlled language and the user must
learn how to stay within its limitations. Although this
is a disadvantage, in practice it is much easier to re-
member some subset of English phrases rather than to
learn a whole new formal language. Word suggestion
functionality such as that in the PGF Web Service can
help the user stay within the controlled fragment.
In contrast to the above mentioned systems, GF is
not a system which provides only one controlled lan-
guage, but a framework within which the developer can
develop his own language. The task is simplified by the
existence of a resource grammar library (Ranta, 2007)
which takes care of all low-level details such as word
order, and gender, number or case agreement. In fact,
the language developer does not have to be skilled in
linguistics, but does have to be a domain expert and
can concentrate on the specific task.
Most controlled language frameworks are focused
on some subset of English while other languages re-
ceive very little or no attention. With GF, the con-
trolled language does not have to be committed to only
one natural language but could have a parallel grammar
with realizations into many languages. In this case the
user could choose whether to use the English version
or, for example, the French version, and still produce
the same abstract representation.
</bodyText>
<sectionHeader confidence="0.995451" genericHeader="method">
6 Implementation
</sectionHeader>
<bodyText confidence="0.975918">
The PGF Web Service is a FastCGI program written in
Haskell. The program is a thin layer on top of the PGF
</bodyText>
<page confidence="0.998218">
11
</page>
<bodyText confidence="0.9999849">
interpreter, which implements all the PGF functional-
ity, such as parsing, completion and linearization. The
web service also uses external libraries for FastCGI
communication, and JSON and UTF-8 encoding and
decoding.
The main advantage of using FastCGI instead of
plain CGI is that the PGF file does not have to be
reloaded for each request. Instead, each PGF file is
loaded the first time it is requested, and after that, it is
only reloaded if the file on disk is changed.
</bodyText>
<sectionHeader confidence="0.992243" genericHeader="evaluation">
7 Performance
</sectionHeader>
<bodyText confidence="0.999985125">
The web service layer introduces minimal overhead.
The typical response time for a parse request with a
small grammar, when running on a typical current PC,
is around 1 millisecond. For large grammars, response
times can be on the order of several seconds, but this is
entirely dependent on the PGF interpreter implementa-
tion.
The server is multi-threaded, with one lightweight
thread for each client request. A single instance of the
server can run threads on all cores of a multi-core pro-
cessor. Since the server maintains no state and requires
no synchronization, it can be easily replicated on mul-
tiple machines with load balancing. Since all requests
are cacheable HTTP GET requests, a caching proxy
could be used to improve performance if it is expected
that there will be repeated requests for the same URI.
</bodyText>
<sectionHeader confidence="0.9996" genericHeader="discussions">
8 Future Work
</sectionHeader>
<bodyText confidence="0.99995425">
The abstract syntax in GF is based on Martin
L¨of’s (1984) type theory and supports dependent types.
They can be used go beyond the pure syntax and to
check the sentences for semantic consistency. The cur-
rent parser completely ignores dependent types. This
means that the word prediction will suggest comple-
tions which might not be semantically meaningful.
In order to improve performance for high-traffic ap-
plications that use large grammars, the web service
could cache responses. As long as the grammar is not
modified, identical requests will always produce iden-
tical responses.
</bodyText>
<sectionHeader confidence="0.997669" genericHeader="conclusions">
9 Conclusions
</sectionHeader>
<bodyText confidence="0.999948285714286">
We have presented a web service for grammar-based
natural language processing, which can be used to build
interactive natural language web applications. The web
service has a simple API, based on HTTP GET requests
with JSON responses. The service allows high levels of
performance and scalability, and has been used to build
several applications.
</bodyText>
<sectionHeader confidence="0.999309" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.99975650877193">
Krasimir Angelov. 2009. Incremental Parsing with Par-
allel Multiple Context-Free Grammars. In European
Chapter of the Association for Computational Lin-
guistics.
Krasimir Angelov, Bj¨orn Bringert, and Aarne
Ranta. 2008. PGF: A Portable Run-Time For-
mat for Type-Theoretical Grammars. Journal
of Logic, Language and Information, submit-
ted. URL http://www.cs.chalmers.se/
˜bringert/publ/pgf/pgf.pdf.
Attempto. 2008. Attempto Project Homepage -
http://attempto.ifi.uzh.ch/site/. URL http://
attempto.ifi.uzh.ch/site/.
Bj¨orn Bringert. 2008. Delimited Contin-
uations, Applicative Functors and Natu-
ral Language Semantics. URL http:
//www.cs.chalmers.se/˜bringert/
publ/continuation-semantics/
continuation-semantics.pdf.
Koen Claessen and Niklas S¨orensson. 2003. New
Techniques that Improve MACE-style Model Find-
ing. In Workshop on Model Computation
(MODEL). URL http://www.cs.chalmers.
se/˜koen/pubs/model-paradox.ps.
Douglas Crockford. 2006. The application/json Media
Type for JavaScript Object Notation (JSON). RFC
4627 (Informational). URL http://www.ietf.
org/rfc/rfc4627.txt.
Adam Funk, Valentin Tablan, Kalina Bontcheva,
Hamish Cunningham, Brian Davis, and Siegfried
Handschuh. 2007. CLOnE: Controlled Language for
Ontology Editing. In Proceedings of the Interna-
tional Semantic Web Conference (ISWC 2007). Bu-
san, Korea.
Per Martin-L¨of. 1984. Intuitionistic Type Theory. Bib-
liopolis, Naples.
Dave Raggett, Arnaud Le Hors, and Ian Jacobs.
1999. HTML 4.01 Specification. Technical report,
W3C. URL http://www.w3.org/TR/1999/
REC-html401-19991224/.
Aarne Ranta. 2004. Grammatical Framework: A
Type-Theoretical Grammar Formalism. Jour-
nal of Functional Programming, 14(2):145–189.
URL http://dx.doi.org/10.1017/
S0956796803004738.
Aarne Ranta. 2007. Modular Grammar Engineering
in GF. Research on Language and Computation,
5(2):133–158. URLhttp://dx.doi.org/10.
1007/s11168-007-9030-6.
Hiroyuki Seki, Takashi Matsumura, Mamoru Fujii,
and Tadao Kasami. 1991. On multiple context-
free grammars. Theoretical Computer Science,
88(2):191–229. URL http://dx.doi.org/
10.1016/0304-3975(91)90374-B.
John Sowa. 2004. Common Logic Controlled En-
glish. Draft. URL http://www.jfsowa.com/
clce/specs.htm.
</reference>
<page confidence="0.998459">
12
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.737460">
<title confidence="0.823502">Grammatical Framework Web Service</title>
<author confidence="0.989549">Angelov Ranta</author>
<affiliation confidence="0.9558005">Department of Computer Science and Engineering Chalmers University of Technology and University of Gothenburg</affiliation>
<abstract confidence="0.9988812">We present a web service for natural language parsing, prediction, generation, and translation using grammars in Portable Grammar Format (PGF), the target format of the Grammatical Framework (GF) grammar compiler. The web service implementation is open source, works with any PGF grammar, and with any web server that supports FastCGI. The service exposes a simple interface which makes it possible to use it for interactive natural language web applications. We describe the functionality and interface of the web service, and demonstrate several applications built on top of it.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Krasimir Angelov</author>
</authors>
<title>Incremental Parsing with Parallel Multiple Context-Free Grammars.</title>
<date>2009</date>
<booktitle>In European Chapter of the Association for Computational Linguistics.</booktitle>
<contexts>
<context position="3518" citStr="Angelov, 2009" startWordPosition="565" endWordPosition="566">Service loads PGF files from disk, and uses them to serve client requests. These PGF files are normally produced by compiling GF grammars, but they could also be produced by other means, for example by a compiler from another grammar formalism. Such compilers currently exist for context-free grammars in BNF and EBNF formats, though they compile via GF. 2.2 Parsing and Word Prediction For each concrete syntax in a PGF file, there is a parsing grammar, which is a Parallel Multiple Context Free Grammar (PMCFG, Seki et al., 1991). The PGF interpreter uses an efficient parsing algorithm for PMCFG (Angelov, 2009) which is similar to the Earley algorithm for CFG. The algorithm is top-down and incremental which makes it possible to use it for word completion. When the whole sentence is known, the parser just takes the tokens one by one and computes the chart of all possible parse trees. If the sentence is not yet complete, then the known tokens can be used to compute a partial parse chart. Since the algorithm is topdown it is possible to predict the set of valid next tokens by using just the partial chart. The prediction can be used in applications to guide the user to stay within the coverage of the gr</context>
</contexts>
<marker>Angelov, 2009</marker>
<rawString>Krasimir Angelov. 2009. Incremental Parsing with Parallel Multiple Context-Free Grammars. In European Chapter of the Association for Computational Linguistics.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Krasimir Angelov</author>
<author>Bj¨orn Bringert</author>
<author>Aarne Ranta</author>
</authors>
<title>PGF: A Portable Run-Time Format for Type-Theoretical Grammars.</title>
<date>2008</date>
<journal>Journal of Logic, Language and Information, submitted. URL</journal>
<note>http://www.cs.chalmers.se/ ˜bringert/publ/pgf/pgf.pdf.</note>
<contexts>
<context position="1099" citStr="Angelov et al., 2008" startWordPosition="159" endWordPosition="162">lementation is open source, works with any PGF grammar, and with any web server that supports FastCGI. The service exposes a simple interface which makes it possible to use it for interactive natural language web applications. We describe the functionality and interface of the web service, and demonstrate several applications built on top of it. 1 Introduction Current web applications often consist of JavaScript code that runs in the user’s web browser, with serverside code that does the heavy lifting. We present a web service for natural language processing with Portable Grammar Format (PGF, Angelov et al., 2008) grammars, which can be used to build interactive natural language web applications. PGF is the back-end format to which Grammatical Framework (GF, Ranta, 2004) grammars are compiled. PGF has been designed to allow efficient implementations. The web service has a simple API based solely on HTTP GET requests. It returns responses in JavaScript Object Notation (JSON, Crockford, 2006). The serverside program is distributed as part of the GF software distribution, under the GNU General Public License (GPL). The program is generic, in the sense that it can be used with any PGF grammar without any m</context>
<context position="2834" citStr="Angelov et al., 2008" startWordPosition="444" endWordPosition="447">ct syntax tree (or several, if the grammar is ambiguous) from a string is called parsing. In a small, semantically oriented application grammar, the sentence “2 is even” may correspond to the abstract syntax tree Even 2. In a larger, more syntactically oriented grammar, in this case the English GF resource grammar (Ranta, 2007), the same sentence can correspond to the abstract syntax tree PhrUtt NoPConj (UttS (UseCl (TTAnt TPres ASimul) PPos (PredVP (UsePN (NumPN (NumDigits (Ug D 2)))) (UseComp (CompAP (PositA even A)))))) NoVoc. 2.1 Portable Grammar Format (PGF) Portable Grammar Format (PGF, Angelov et al., 2008) is a low-level format to which GF grammars are compiled. The PGF Web Service loads PGF files from disk, and uses them to serve client requests. These PGF files are normally produced by compiling GF grammars, but they could also be produced by other means, for example by a compiler from another grammar formalism. Such compilers currently exist for context-free grammars in BNF and EBNF formats, though they compile via GF. 2.2 Parsing and Word Prediction For each concrete syntax in a PGF file, there is a parsing grammar, which is a Parallel Multiple Context Free Grammar (PMCFG, Seki et al., 1991</context>
</contexts>
<marker>Angelov, Bringert, Ranta, 2008</marker>
<rawString>Krasimir Angelov, Bj¨orn Bringert, and Aarne Ranta. 2008. PGF: A Portable Run-Time Format for Type-Theoretical Grammars. Journal of Logic, Language and Information, submitted. URL http://www.cs.chalmers.se/ ˜bringert/publ/pgf/pgf.pdf.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Attempto</author>
</authors>
<title>Attempto Project Homepage -http://attempto.ifi.uzh.ch/site/.</title>
<date>2008</date>
<note>URL http:// attempto.ifi.uzh.ch/site/.</note>
<contexts>
<context position="10143" citStr="Attempto, 2008" startWordPosition="1625" endWordPosition="1627">tree. Optional arguments: to. 4.6 Random Generation /pgf/grammar.pgf/random generates anumber of randomly generated abstract syntax trees for the selected grammar. Optional arguments: cat, limit. If limit is omitted, one tree is returned. 4.7 Translation /pgf/grammar.pgf/translate performs text to text translation. This is done by parsing, followed by linearization. Optional arguments: input, from, cat, to. 5 Application to Controlled Languages The use of controlled languages is becoming more popular with the development of Web and Semantic Web technologies. Related projects include Attempto (Attempto, 2008), CLOnE (Funk et al., 2007), and Common Logic Controlled English (CLCE) (Sowa, 2004). All these projects provide languages which are subsets of English and have semantic translations into first order logic (CLCE), OWL (CLOnE) or both (Attempto). In the case of Attempto, the translation is into first order logic and if it is possible to the weaker OWL language. The general idea is that since the controlled language is a subset of some other language it should be understandable to everyone without special training. The opposite is not true - not every English sentence is a valid sentence in the </context>
</contexts>
<marker>Attempto, 2008</marker>
<rawString>Attempto. 2008. Attempto Project Homepage -http://attempto.ifi.uzh.ch/site/. URL http:// attempto.ifi.uzh.ch/site/.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Bj¨orn Bringert</author>
</authors>
<title>Delimited Continuations, Applicative Functors and Natural Language Semantics.</title>
<date>2008</date>
<note>URL http: //www.cs.chalmers.se/˜bringert/ publ/continuation-semantics/ continuation-semantics.pdf.</note>
<contexts>
<context position="6846" citStr="Bringert, 2008" startWordPosition="1112" endWordPosition="1113">y screenshot. Demo at http: //digitalgrammars.com/fridge. Figure 3: Reasoning screenshot. Demo at http:// digitalgrammars.com/mosg. 3.3 Reasoning Another application is a natural language reasoning system which accepts facts and questions from the users, and tries to answer the questions based on the facts given. The application uses the PGF Web Service to parse inputs. It uses two other web services for semantic interpretation and reasoning, respectively. The semantic interpretation service uses a continuationbased compositional mapping of abstract syntax terms to first-order logic formulas (Bringert, 2008). The reasoning service is a thin layer on top of the Equinox theorem prover and the Paradox model finder (Claessen and S¨orensson, 2003). 4 API Below, we will show URI paths for each function, for example /pgf/food.pgf/parse. Arguments to each function are given in the URL query string, in application/x-www-form-urlencoded (Raggett et al., 1999) format. Thus, if the service is running on example.com, the URI for a request to parse the string “this fish is fresh” using the FoodEng concrete syntax in the food.pgf grammar would 10 be: http://example.com/pgf/food.pgf/ parse?input=this+fish+is+fre</context>
</contexts>
<marker>Bringert, 2008</marker>
<rawString>Bj¨orn Bringert. 2008. Delimited Continuations, Applicative Functors and Natural Language Semantics. URL http: //www.cs.chalmers.se/˜bringert/ publ/continuation-semantics/ continuation-semantics.pdf.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Koen Claessen</author>
<author>Niklas S¨orensson</author>
</authors>
<title>New Techniques that Improve MACE-style Model Finding.</title>
<date>2003</date>
<booktitle>In Workshop on Model Computation (MODEL). URL</booktitle>
<note>http://www.cs.chalmers. se/˜koen/pubs/model-paradox.ps.</note>
<marker>Claessen, S¨orensson, 2003</marker>
<rawString>Koen Claessen and Niklas S¨orensson. 2003. New Techniques that Improve MACE-style Model Finding. In Workshop on Model Computation (MODEL). URL http://www.cs.chalmers. se/˜koen/pubs/model-paradox.ps.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Douglas Crockford</author>
</authors>
<title>The application/json Media Type for JavaScript Object Notation (JSON).</title>
<date>2006</date>
<booktitle>RFC 4627 (Informational). URL http://www.ietf. org/rfc/rfc4627.txt.</booktitle>
<contexts>
<context position="1483" citStr="Crockford, 2006" startWordPosition="222" endWordPosition="223">ften consist of JavaScript code that runs in the user’s web browser, with serverside code that does the heavy lifting. We present a web service for natural language processing with Portable Grammar Format (PGF, Angelov et al., 2008) grammars, which can be used to build interactive natural language web applications. PGF is the back-end format to which Grammatical Framework (GF, Ranta, 2004) grammars are compiled. PGF has been designed to allow efficient implementations. The web service has a simple API based solely on HTTP GET requests. It returns responses in JavaScript Object Notation (JSON, Crockford, 2006). The serverside program is distributed as part of the GF software distribution, under the GNU General Public License (GPL). The program is generic, in the sense that it can be used with any PGF grammar without any modification of the program. 2 Grammatical Framework Grammatical Framework (GF, Ranta, 2004) is a typetheoretical grammar formalism. A GF grammar consists of an abstract syntax, which defines a set of abstract syntax trees, and one or more concrete syntaxes, which define how abstract syntax trees are mapped to (and from) strings. The process of producing a string *Now at Google Inc.</context>
</contexts>
<marker>Crockford, 2006</marker>
<rawString>Douglas Crockford. 2006. The application/json Media Type for JavaScript Object Notation (JSON). RFC 4627 (Informational). URL http://www.ietf. org/rfc/rfc4627.txt.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Adam Funk</author>
<author>Valentin Tablan</author>
<author>Kalina Bontcheva</author>
<author>Hamish Cunningham</author>
<author>Brian Davis</author>
<author>Siegfried Handschuh</author>
</authors>
<title>CLOnE: Controlled Language for Ontology Editing.</title>
<date>2007</date>
<booktitle>In Proceedings of the International Semantic Web Conference (ISWC 2007). Busan,</booktitle>
<contexts>
<context position="10170" citStr="Funk et al., 2007" startWordPosition="1629" endWordPosition="1632">: to. 4.6 Random Generation /pgf/grammar.pgf/random generates anumber of randomly generated abstract syntax trees for the selected grammar. Optional arguments: cat, limit. If limit is omitted, one tree is returned. 4.7 Translation /pgf/grammar.pgf/translate performs text to text translation. This is done by parsing, followed by linearization. Optional arguments: input, from, cat, to. 5 Application to Controlled Languages The use of controlled languages is becoming more popular with the development of Web and Semantic Web technologies. Related projects include Attempto (Attempto, 2008), CLOnE (Funk et al., 2007), and Common Logic Controlled English (CLCE) (Sowa, 2004). All these projects provide languages which are subsets of English and have semantic translations into first order logic (CLCE), OWL (CLOnE) or both (Attempto). In the case of Attempto, the translation is into first order logic and if it is possible to the weaker OWL language. The general idea is that since the controlled language is a subset of some other language it should be understandable to everyone without special training. The opposite is not true - not every English sentence is a valid sentence in the controlled language and the</context>
</contexts>
<marker>Funk, Tablan, Bontcheva, Cunningham, Davis, Handschuh, 2007</marker>
<rawString>Adam Funk, Valentin Tablan, Kalina Bontcheva, Hamish Cunningham, Brian Davis, and Siegfried Handschuh. 2007. CLOnE: Controlled Language for Ontology Editing. In Proceedings of the International Semantic Web Conference (ISWC 2007). Busan, Korea.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Per Martin-L¨of</author>
</authors>
<title>Intuitionistic Type Theory. Bibliopolis,</title>
<date>1984</date>
<location>Naples.</location>
<marker>Martin-L¨of, 1984</marker>
<rawString>Per Martin-L¨of. 1984. Intuitionistic Type Theory. Bibliopolis, Naples.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Dave Raggett</author>
<author>Arnaud Le Hors</author>
<author>Ian Jacobs</author>
</authors>
<date>1999</date>
<booktitle>HTML 4.01 Specification. Technical report, W3C. URL http://www.w3.org/TR/1999/</booktitle>
<pages>401--19991224</pages>
<marker>Raggett, Le Hors, Jacobs, 1999</marker>
<rawString>Dave Raggett, Arnaud Le Hors, and Ian Jacobs. 1999. HTML 4.01 Specification. Technical report, W3C. URL http://www.w3.org/TR/1999/ REC-html401-19991224/.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Aarne Ranta</author>
</authors>
<title>Grammatical Framework: A Type-Theoretical Grammar Formalism.</title>
<date>2004</date>
<journal>Journal of Functional Programming,</journal>
<volume>14</volume>
<issue>2</issue>
<contexts>
<context position="1259" citStr="Ranta, 2004" startWordPosition="187" endWordPosition="188">use it for interactive natural language web applications. We describe the functionality and interface of the web service, and demonstrate several applications built on top of it. 1 Introduction Current web applications often consist of JavaScript code that runs in the user’s web browser, with serverside code that does the heavy lifting. We present a web service for natural language processing with Portable Grammar Format (PGF, Angelov et al., 2008) grammars, which can be used to build interactive natural language web applications. PGF is the back-end format to which Grammatical Framework (GF, Ranta, 2004) grammars are compiled. PGF has been designed to allow efficient implementations. The web service has a simple API based solely on HTTP GET requests. It returns responses in JavaScript Object Notation (JSON, Crockford, 2006). The serverside program is distributed as part of the GF software distribution, under the GNU General Public License (GPL). The program is generic, in the sense that it can be used with any PGF grammar without any modification of the program. 2 Grammatical Framework Grammatical Framework (GF, Ranta, 2004) is a typetheoretical grammar formalism. A GF grammar consists of an </context>
</contexts>
<marker>Ranta, 2004</marker>
<rawString>Aarne Ranta. 2004. Grammatical Framework: A Type-Theoretical Grammar Formalism. Journal of Functional Programming, 14(2):145–189.</rawString>
</citation>
<citation valid="false">
<note>URL http://dx.doi.org/10.1017/ S0956796803004738.</note>
<marker></marker>
<rawString>URL http://dx.doi.org/10.1017/ S0956796803004738.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Aarne Ranta</author>
</authors>
<title>Modular Grammar Engineering in GF.</title>
<date>2007</date>
<journal>Research on Language and Computation,</journal>
<volume>5</volume>
<issue>2</issue>
<pages>10--1007</pages>
<contexts>
<context position="2542" citStr="Ranta, 2007" startWordPosition="401" endWordPosition="402">or more concrete syntaxes, which define how abstract syntax trees are mapped to (and from) strings. The process of producing a string *Now at Google Inc. (or, more generally, a feature structure) from an abstract syntax tree is called linearization. The opposite, producing an abstract syntax tree (or several, if the grammar is ambiguous) from a string is called parsing. In a small, semantically oriented application grammar, the sentence “2 is even” may correspond to the abstract syntax tree Even 2. In a larger, more syntactically oriented grammar, in this case the English GF resource grammar (Ranta, 2007), the same sentence can correspond to the abstract syntax tree PhrUtt NoPConj (UttS (UseCl (TTAnt TPres ASimul) PPos (PredVP (UsePN (NumPN (NumDigits (Ug D 2)))) (UseComp (CompAP (PositA even A)))))) NoVoc. 2.1 Portable Grammar Format (PGF) Portable Grammar Format (PGF, Angelov et al., 2008) is a low-level format to which GF grammars are compiled. The PGF Web Service loads PGF files from disk, and uses them to serve client requests. These PGF files are normally produced by compiling GF grammars, but they could also be produced by other means, for example by a compiler from another grammar form</context>
<context position="11364" citStr="Ranta, 2007" startWordPosition="1836" endWordPosition="1837">d language and the user must learn how to stay within its limitations. Although this is a disadvantage, in practice it is much easier to remember some subset of English phrases rather than to learn a whole new formal language. Word suggestion functionality such as that in the PGF Web Service can help the user stay within the controlled fragment. In contrast to the above mentioned systems, GF is not a system which provides only one controlled language, but a framework within which the developer can develop his own language. The task is simplified by the existence of a resource grammar library (Ranta, 2007) which takes care of all low-level details such as word order, and gender, number or case agreement. In fact, the language developer does not have to be skilled in linguistics, but does have to be a domain expert and can concentrate on the specific task. Most controlled language frameworks are focused on some subset of English while other languages receive very little or no attention. With GF, the controlled language does not have to be committed to only one natural language but could have a parallel grammar with realizations into many languages. In this case the user could choose whether to u</context>
</contexts>
<marker>Ranta, 2007</marker>
<rawString>Aarne Ranta. 2007. Modular Grammar Engineering in GF. Research on Language and Computation, 5(2):133–158. URLhttp://dx.doi.org/10. 1007/s11168-007-9030-6.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Hiroyuki Seki</author>
<author>Takashi Matsumura</author>
<author>Mamoru Fujii</author>
<author>Tadao Kasami</author>
</authors>
<title>On multiple contextfree grammars.</title>
<date>1991</date>
<journal>Theoretical Computer Science,</journal>
<volume>88</volume>
<issue>2</issue>
<pages>10--1016</pages>
<contexts>
<context position="3435" citStr="Seki et al., 1991" startWordPosition="550" endWordPosition="553">lov et al., 2008) is a low-level format to which GF grammars are compiled. The PGF Web Service loads PGF files from disk, and uses them to serve client requests. These PGF files are normally produced by compiling GF grammars, but they could also be produced by other means, for example by a compiler from another grammar formalism. Such compilers currently exist for context-free grammars in BNF and EBNF formats, though they compile via GF. 2.2 Parsing and Word Prediction For each concrete syntax in a PGF file, there is a parsing grammar, which is a Parallel Multiple Context Free Grammar (PMCFG, Seki et al., 1991). The PGF interpreter uses an efficient parsing algorithm for PMCFG (Angelov, 2009) which is similar to the Earley algorithm for CFG. The algorithm is top-down and incremental which makes it possible to use it for word completion. When the whole sentence is known, the parser just takes the tokens one by one and computes the chart of all possible parse trees. If the sentence is not yet complete, then the known tokens can be used to compute a partial parse chart. Since the algorithm is topdown it is possible to predict the set of valid next tokens by using just the partial chart. The prediction </context>
</contexts>
<marker>Seki, Matsumura, Fujii, Kasami, 1991</marker>
<rawString>Hiroyuki Seki, Takashi Matsumura, Mamoru Fujii, and Tadao Kasami. 1991. On multiple contextfree grammars. Theoretical Computer Science, 88(2):191–229. URL http://dx.doi.org/ 10.1016/0304-3975(91)90374-B.</rawString>
</citation>
<citation valid="true">
<authors>
<author>John Sowa</author>
</authors>
<date>2004</date>
<journal>Common Logic Controlled English. Draft. URL</journal>
<note>http://www.jfsowa.com/ clce/specs.htm.</note>
<contexts>
<context position="10227" citStr="Sowa, 2004" startWordPosition="1640" endWordPosition="1641">umber of randomly generated abstract syntax trees for the selected grammar. Optional arguments: cat, limit. If limit is omitted, one tree is returned. 4.7 Translation /pgf/grammar.pgf/translate performs text to text translation. This is done by parsing, followed by linearization. Optional arguments: input, from, cat, to. 5 Application to Controlled Languages The use of controlled languages is becoming more popular with the development of Web and Semantic Web technologies. Related projects include Attempto (Attempto, 2008), CLOnE (Funk et al., 2007), and Common Logic Controlled English (CLCE) (Sowa, 2004). All these projects provide languages which are subsets of English and have semantic translations into first order logic (CLCE), OWL (CLOnE) or both (Attempto). In the case of Attempto, the translation is into first order logic and if it is possible to the weaker OWL language. The general idea is that since the controlled language is a subset of some other language it should be understandable to everyone without special training. The opposite is not true - not every English sentence is a valid sentence in the controlled language and the user must learn how to stay within its limitations. Alth</context>
</contexts>
<marker>Sowa, 2004</marker>
<rawString>John Sowa. 2004. Common Logic Controlled English. Draft. URL http://www.jfsowa.com/ clce/specs.htm.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>