<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.003390">
<title confidence="0.941109">
Finite Structure Query: A Tool for Querying Syntactically Annotated
Corpora
</title>
<author confidence="0.881657">
Stephan Kepser
</author>
<affiliation confidence="0.505496">
SFB 441 — University of Tubingen
</affiliation>
<address confidence="0.737651">
Nauklerstr. 35, 72074 Tubingen, Germany
</address>
<email confidence="0.984346">
kepser@sfs.uni-tuebingen.de
</email>
<sectionHeader confidence="0.997167" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999788857142857">
Finite structure query (fsq for short) is
a tool for querying syntactically anno-
tated corpora. fsq employs a query lan-
guage of high expressive power, namely
full first order logic. It can be used to
query arbitrary finite structures, not just
trees.
</bodyText>
<sectionHeader confidence="0.999394" genericHeader="introduction">
1 Introduction
</sectionHeader>
<bodyText confidence="0.99999052631579">
In recent years large amounts of electronic texts
have become available providing a new base for
empirical studies in linguistics and offering a
chance to linguists to compare their theories with
large amounts of utterances from &amp;quot;the real world&amp;quot;.
While tagging with morphosyntactic categories
has become a standard for almost all corpora,
more and more of them are nowadays annotated
with refined syntactic information. Examples
are the Penn Treebank (Marcus et al., 1993) for
American English annotated at the University of
Pennsylvania, the French treebank (AbelIle and
Clement, 1999) developed in Paris, the NEGRA
Corpus (Brants et al., 1999) for German anno-
tated at the University of Saarbriicken, and the
Tubingen Treebanks (Hinrichs et al., 2000) for
Japanese, German and English from the Univer-
sity of Tubingen. To make these rich syntactic an-
notations accessible for linguists the development
of powerful query tools is an obvious need and
has become an important task in computational
linguistics.
In this paper, we present finite structure query
(fsq), a query tool for syntactically annotated cor-
pora. Special emphasis in the development of
fsq is layed on providing users a very powerful
query language. Therefore full first-order logic
was chosen as query language which allows ar-
bitrary quantifications over nodes in a tree. This
choice is to the authors&apos; knowledge unique, no
other query tool offers such an expressive power.
It is on the other hand not arbitrary, we will show
that there are interesting linguistic queries that re-
quire such an expressive power. The tool is de-
veloped for treebanks in NEGRA export format
(Brants, 1997), but can be adopted to other cor-
pus formats as well. The linguistic examples that
follow are from the Tubingen Treebanks
</bodyText>
<subsectionHeader confidence="0.993555">
1.1 The Tübingen Treebanks
</subsectionHeader>
<bodyText confidence="0.998015782608696">
The Tubingen Treebanks, annotated at the Uni-
versity of Tubingen, comprise a German, an En-
glish and a Japanese treebank consisting of spo-
ken dialogs restricted to the domain of arranging
business appointments. In this paper, we focus on
the German treebank (TiiBa-D) (Stegmann et al.,
2000; Hinrichs et al., 2000) that contains approx-
imately 38.000 trees.
The treebank is part-of-speech tagged using the
Stuttgart-TUbingen tag set (STTS) developed by
Schiller et al. (1995). One of the design deci-
sions for the development of the treebank was the
commitment to reusability. As a consequence,
the choice of the syntactic annotation scheme
should not reflect a particular syntactic theory but
rather be as theory-neutral as possible. There-
fore a surface-oriented scheme was adopted to
structure German sentences that uses the notion
of topological fields in a sense similar to that of
Hohle (1985). The verbal elements have the cat-
egories LK (linke Klammer) and vC (verbal com-
plex), roughly everything preceeding the LK forms
the &amp;quot;Vorfeld&amp;quot; VF, everything between LK and vC
</bodyText>
<page confidence="0.998006">
179
</page>
<figureCaption confidence="0.999628">
Figure 1: An example sentence from TUBa-D
</figureCaption>
<bodyText confidence="0.999806722222222">
forms the &amp;quot;Mittelfeld&amp;quot; MF, and the material fol-
lowing the VC forms the &amp;quot;Nachfeld&amp;quot; NF.
The corpus is annotated with syntactic cate-
gories as node labels, grammatical functions as
edge labels and dependency relations. The syn-
tactic categories follow traditional phrase struc-
ture and the theory of topological fields. An ex-
ample of a tree can be found in Figure 1. To cope
with the characteristics of spontaneous speech, the
data structures in the Tubingen Treebanks are of a
more general form than trees. For example, an
entry may consist of several tree structures. It
also may contain completely disconnected nodes.
In contrast to NEGRA or the Penn Treebank,
there are neither crossing branches nor empty cat-
egories.
The design goal of fsq has been to make this
rich annotation queryable for linguists.
</bodyText>
<sectionHeader confidence="0.859373" genericHeader="method">
2 The Query Language of fsq
</sectionHeader>
<subsectionHeader confidence="0.932792">
2.1 Syntax
</subsectionHeader>
<bodyText confidence="0.999345416666667">
In order to provide a high expressive power, full
first-order logic is chosen as the query language
for fsq. Atomic formulae express the syntactic an-
notation of a node in a tree or the relationships
between nodes such as dominance or precedence.
Hence, variables, words made of letters and dig-
its, are supposed to range over nodes in a tree. The
formula (or query) syntax is LISP-like. Let x and
y be variables and let T be a token, C a category,
M a morphological tag, and F a function from the
annotation scheme. The atomic formulae are as
follows:
</bodyText>
<listItem confidence="0.999174636363636">
• (= x y) &amp;quot;x equals y&amp;quot;
• (&gt; x y) &amp;quot;x is the mother of y&amp;quot;
• (&gt;&gt; x y) &amp;quot;x dominates y&amp;quot;
• ( x y) &amp;quot;x immediately precedes y&amp;quot;
• ( x y) &amp;quot;x precedes y&amp;quot;
• (tok x T) &amp;quot;x has token T&amp;quot;
• (cat x C) &amp;quot;x is of category C&amp;quot;
• (mor x M) &amp;quot;x has morphological tag 14&amp;quot;
• (fct x F) &amp;quot;x is of function F&amp;quot;
• (ref1 x y) &amp;quot;there is a ref 1-secondary edge
from x to y&amp;quot;
</listItem>
<bodyText confidence="0.986979">
Trees in the treebank may have secondary
edges. An example is the ref1 edge from the
TUBa-D, which expresses a reference relation be-
tween infinitival verbs in a verb complex.
Complex formulae are constructed in a way
normal for first-order logic. Let cp, (p1, , (pn, and
be formulae, and x a variable. Then the follow-
ing are well-formed formulae:
</bodyText>
<listItem confidence="0.999748333333333">
• ( (p) (negation)
• ( &amp; (pi ... (p,7) (conjunction)
• ( (pi • • • (pn) (disjunction)
• (—&gt; ( NJ) (implication)
• (E x (p) (existential quantification)
• (A x (p) (universal quantification)
</listItem>
<bodyText confidence="0.999669">
A query is a closed formula, i.e., a formula
where each variable is bound by some quantifier.
</bodyText>
<subsectionHeader confidence="0.995867">
2.2 Semantics
</subsectionHeader>
<bodyText confidence="0.999890285714286">
One central idea of fsq is to regard a tree or tree-
like structure as a finite first-order structure. The
reason behind this decision is that a finite struc-
ture is the common denominator for existing tree-
banks and corpus formats. A closer look not only
at the Tabingen Treebanks reveals that most of
these corpora do not only contain proper trees in
the mathematical sense. Some of these extensions
of trees may be harmless. But some of them, like
secondary relations, can, if used extensively, tran-
scend the tree structure completely. A query ap-
proach that is designed to cope with all of these
extensions therefore needs to opt for a general
data structure. And the one data structure that fits
</bodyText>
<figure confidence="0.994868333333333">
ist,
VAFIN
der
ART
Ii
vierundzwanzigste
ADJA
Juli
NN
</figure>
<page confidence="0.991175">
180
</page>
<bodyText confidence="0.9997098125">
most easily with all treebank formats is that of a
finite first-order structure.
One big advantage of the approach of regarding
a &amp;quot;tree&amp;quot; as a finite first-order structure is that we
are immediately given a very natural and widely
understood semantics for queries, namely classi-
cal first-order logic semantics. The universe of a
structure is a finite set of nodes. Relations like
(immediate) dominance and precedence as well as
secondary edges are interpreted as binary predi-
cates over nodes. Relations like token, category,
morphology, or function each introduce a finite
family of unary predicates. Each such predicate
stands for a particular token (or category or func-
tion) value like, e.g., the German word Hannover.
More formally, the signature for a treebank con-
sists of the two binary relation symbols Id, Ip
(for immediate dominance and immediate prece-
dence), up to 8 binary relation symbols Sec, for
secondary relations, and finite families (I&apos;, )i&lt;i&lt;k,
(C,)] ‹,&lt;/, (M1)1&lt;1‹,0, and (F1)1&lt;,&lt;,,, of unary pred-
icate symbols (for tokens, categories, morpholog-
ical tags, and functions). A tree is a finite first-
order interpretation of this signature, and a tree-
bank is a finite sequence of trees.
Let T = (N , (Id . I p, See , , Secs, (Ti) , (Ci),
(M,),(F,))) be a tree, and X be a set of variables.
A variable assignment a : X N is a function that
assigns a node from N to each variable. Let a be
a variable assignment. The truth conditions of the
atomic formulae are as follows: (Id* (Ip*) is the
reflexive-transitive closure of Id (Ip).)
</bodyText>
<equation confidence="0.95882">
(= x y) true, if a(x) =
(&gt; x y) true, if (a(x), a (y)) c Id,
(» x y) true, if (a(x). a (y)) e
(. x y) true, if (a(x), a (y)) E Ip,
</equation>
<bodyText confidence="0.977667166666667">
(.. x y) true, if (a(x).a(y)) e I p* ,
(refl x y) true, if (a(x),a(y)) E Sec,/ where
Secj is the secondary relation rep-
resenting refl,
(tok x T) true, if a(x) E T.] where Tj is the
predicate representing token T,
(cat x C) true, if a(x) E Cj where Cj is the
predicate representing category C,
(mor x M) true, if a(x) E M1 where Ali repre-
sents morphological tag m,
(fct x F) true, if a(x) C Fj where FJ is the
predicate representing function F.
Complex formulae are interpreted classically.
As a result, a query or closed formula is true or
false of a tree. Thus, a tree is an answer to a query,
if it is a model for the query. And the result of a
query on a treebank is the set of all trees which are
models of the query.
</bodyText>
<subsectionHeader confidence="0.996164">
2.3 Expressive Power
</subsectionHeader>
<bodyText confidence="0.985785205128205">
The primary idea behind fsq is to provide a query
system with a powerful language and clear and
well-established semantics. We therefore opted to
use full first-order logic as a query language. In
this section, we will show the expressive power of
this query language with linguistically motivated
examples.
When so-called fuzzy tree fragments (see (Wal-
lis and Nelson, 2000)) were first introduced, they
provided a significant progress over simple string
matching languages. Nowadays they are standard,
every sensitive query tool for syntactically anno-
tated corpora offers this type of underspecifica-
tion, and fsq is no exception to this rule. We
will therefore bypass them completely. Due to
space restrictions, we will neither show how to
query unconnected sub-parts of a tree. The reader
interested in this issue is referred to the article
by Kallmeyer and Steiner (2003). Everything dis-
cussed there for the query tool VIQTORYA can be
queried by fsq, too. Rather we focus on the use
of quantification, something that fsq offers, but no
other query tool does in a similar way.
Suppose we are looking for trees where a clause
lacks the subject. We can pose the following query
to do so:1
]x SIMPX (x) A Vy((x&gt;&gt; y) —iON(y) )
The formula reads &amp;quot;There is a clause node (node
of category SIMPX) such that no node below it
is a subject node (node of function ON (Object in
the Nominative)).&amp;quot; An example result is the tree
in Figure 1. Another result from the same corpus
would be &amp;quot;aber gut, wir konnen ja malfragen, was
gegeben wird.&amp;quot; (All right, we can ask, what&apos;s on
play.) where there is no subject in the German
subordinate clause. If one is interested in finding
only those trees where the subject is lacking in a
&apos;For better readability, we use classical first-order logic
syntax and not fsq syntax.
</bodyText>
<page confidence="0.992886">
181
</page>
<bodyText confidence="0.9628395">
subordinate clause, the above query has to be ex-
tended to
</bodyText>
<listItem confidence="0.9586345">
]x]y SIMPX(x) A SIMPX(y) A (x &gt;&gt; y) A
(x y) A (Vz ((y &gt;&gt; z) A ON(z)))
</listItem>
<bodyText confidence="0.9987261">
&amp;quot;There are two different clause nodes, one dom-
inating the other, and no node below the lower
clause node is a subject node.&amp;quot; This is a query of
quantifier depth 3 (number of deepest nestings of
quantifiers). On second thought one can see that
this query is still too simple to find all subordi-
nate clauses without subject. It does not reflect the
possibility to have a subordinate clause with sub-
ject as a subclause of a subordinate clause without
subject. Here is a query that does: (Query 1)
</bodyText>
<equation confidence="0.7682538">
]x]y SIMPX(x) A SIMPX(y) A
(x &gt;&gt; y) A (x y) A
(Vz ON(z) (y &gt;&gt; z) V
]14; SIMPX(w) A (y &gt;&gt; w) A
(y w) A (w &gt;&gt; z)))
</equation>
<bodyText confidence="0.999795444444444">
&amp;quot;There are two different clause nodes, one domi-
nating the other, and every subject node is either
not dominated by the lower clause node or there
is a further clause node intervening.&amp;quot; This query
is even of quantifier depth 4.
Another complicated query must be used if we
want to find all trees in which the main clause
lacks the subject, but subordinate clauses may
have one. The query looks like this:
</bodyText>
<equation confidence="0.7090014">
Ax SIMPX(x) A
(Vy SIMPX(y) (x &gt;&gt; y A x y)) A
(Vy((x &gt; &gt; y) A ON(y)))
Az (SIMPX(z) A (x &gt;&gt; z) A
(xy)A(z&gt;&gt;y)))
</equation>
<bodyText confidence="0.979057173913043">
&amp;quot;There is a highest clause node such that for ev-
ery subject node dominated by it there is a second
clause node intervening.&amp;quot;
Suppose now, we want to find trees with no Vor-
feld. We can do this by querying:
(ay SIMPX (x)) A (Vy —iVF(y))
&amp;quot;There is a clause node but no Vorfeld node.&amp;quot; A
look at the result trees shows that many of them,
e.g., &amp;quot;kein Problem, geht auf die Spesenrechnung&amp;quot;
(no problem, will be put on the travel expenses
bill) have unconnected subparts. If we find that
undesirable, we conjoin the above query with the
simple AxVy(x &gt;&gt; y) demanding a proper root
node, and then get nicer results like &amp;quot;machen wir
den full&amp;quot; (Let&apos;s take July).
Many more interesting examples for involved
queries could be provided, but space does not per-
mit to do so. When a linguist actually starts ex-
tracting instances of more complicated syntactic
phenomena, he will quickly develop a desire to
have access to arbitrary quantification in the query
language. That&apos;s why we chose to provide this in
the query language of fsq.
</bodyText>
<subsectionHeader confidence="0.99864">
2.4 Complexity Issues
</subsectionHeader>
<bodyText confidence="0.999917485714286">
One of the fundamental insights of database the-
ory is that there is a price to pay for providing
a powerful query language, and this price is that
the evaluation of a query can become quite expen-
sive. On the theoretical side it is the so-called data
complexity that is relevant for us. This notion, in-
troduced by Vardi (1982), describes the complex-
ity of evaluating a query in terms of the size of
the database or treebank. It is common known-
ledge that the problem of evaluating a first-order
sentence on a finite structure is in the complex-
ity class LOGSPACE and therefore in PTIME in
terms of the size of the structure (see, e.g., (Vardi,
1982)). But it is currently unknown, whether the
problem fits into a proper subclass of PTIME in
the polynomial hierarchy, i.e., whether there is
a fixed exponent — independent of the structure
and the query — such that the evaluation time is
in the order of the size of the structure to the
power of that exponent (see, e.g., the work by
Stolboushkin and Taitslin (1994), which suggests
a negative answer to the question).
The algorithm implemented in fsq, although
simple, has a data complexity of PTIME. More
precisely, if n is the number of nodes in a tree
and k is the quantifier depth of the query, then the
algorithm evaluates the query on the tree in time
0(nk). As stated above, it is not known whether
algorithms with a better complexity do exist at all.
Practically, this result is of course not unprob-
lematic, and the question arises at what quanti-
fier depth the evaluation time of a query becomes
so long that it exceeds user sustainable response
time. Our tests indicate that a strict quantifier
bound can not really be given for fsq. Queries
</bodyText>
<page confidence="0.992241">
182
</page>
<bodyText confidence="0.999987666666667">
of quantifier depth up to and including 3 pose
no problem, they are almost instantaneously an-
swered. Queries of depth 4 can take more time to
answer: Some of them, like Query 1 in the pre-
vious section are answered in 2-3 seconds, others
like Query 2 below require an evaluation time of
half an hour. (All: wall clock time on a Pentium
IV, 1.6GHz system.) Response times therefore de-
pend on the individual query and the corpus.
A solution to the problem of longer response
times can sometimes be found in a reformulation
of the query. The same content can be logically
formulated in different ways with formulas hav-
ing quite different quantifier depth. Let us high-
light this fact by an example. Suppose a user looks
for the four words (tokens) heute, Treffen, in, and
Hannover to appear together in a tree. This could
be formulated as follows: (Query 2)
</bodyText>
<equation confidence="0.995360666666667">
(E x (E y (E z (E w
(&amp; (tok x heute) (tok y Treffen)
(tok z in) (tok w Hannover) ) )) ) )
</equation>
<bodyText confidence="0.834943">
with quantifier depth 4. But it could also be for-
mulated as
</bodyText>
<equation confidence="0.999913333333333">
(&amp; (E x (tok x heute) ) (E x (tok x in) )
(E x (tok x Treffen) )
(E x (tok x Hannover)))
</equation>
<bodyText confidence="0.892048">
with quantifier depth just 1!
</bodyText>
<sectionHeader confidence="0.990727" genericHeader="method">
3 The Architecture of fsq
</sectionHeader>
<bodyText confidence="0.999911625">
fsq consists of three main parts: A treebank ini-
tialiser, the query engine, and a graphical user in-
terface to the query engine. All components of fsq
are implemented in Java JDK 1.3. No propriatory
or special libraries are used, so fsq can be run on
any standard Java runtime environment (JRE 1.3)
independent of the platform and operating system
chosen.
</bodyText>
<subsectionHeader confidence="0.999563">
3.1 Initialising a Treebank
</subsectionHeader>
<bodyText confidence="0.999986230769231">
The input format of treebanks fsq can cope with is
the NEGRA export format (Brants, 1997). This
format is designed for data exchange and to be
readable by humans. It is not very well suited as
a format to be queried, because relations between
nodes are implicitely instead of explicitely repre-
sented. Therefore we need an initialisation step
that transforms the NEGRA format into one that
can be queried a lot faster. The query format is
a compact binary representation of the relations
of the trees. Each tree has its own representation,
independent of the others. The binary relations
(dominance, precedence, etc.) are represented as
a twodimensional quadratic array indexed by the
nodes of the particular tree. Each cell of the array
states for all relations if the two nodes addressing
the cell stand in the relations or do not. The unary
relations (token, category, morphology, and func-
tion) are represented by a onedimensional array
indexed again by the nodes of the tree. Each cell
codes the category and function of the addressing
node. Needless to say that the initialisation step
has to be performed only once per treebank. On
a 1.5MB treebank of TiiBa-D, it typically takes 2-
4 minutes (wall clock time, Pentium IV, 1.6GHz),
so it&apos;s rather fast for a precompilation step.
</bodyText>
<subsectionHeader confidence="0.999117">
3.2 The Query Engine
</subsectionHeader>
<bodyText confidence="0.999975285714286">
The query engine parses a submitted query and
successively evaluates it on each finite structure.
Due to the clarity of the query syntax, the parsing
step is simple and quickly performed. A query
is a first order formula and therefore inductively
defined. It is evaluated on a tree by a structural
recursion on its form. During this recursion, a
variable assignment, which is initially empty, is
constructed stepwise. The evaluation of an exis-
tential quantification is achieved by extending the
current variable assignment by supplying a value
for the existentially quantified variable and then
recursing on the body of the quantification with
the extended variable assignment. For complete-
ness reasons it is clear that each node of the struc-
ture under evaluation has to be at some time the
value of the quantified variable. This is achieved
by a loop. The first recursion returning true ren-
ders the formula true. If the body is evaluated to
false under any assignment of a node to the quan-
tified variable, the formula is false. Universally
quantified formulae are evaluated similarly. The
evaluation of a boolean connective is a straightfor-
ward recursion. In the case of a conjunction, e.g.,
each conjunct is evaluated separately with the cur-
rent variable assignment. Only if each conjunct
evaluates to true, the evaluation value of the con-
junction is true, too. Of course, we stop the evalu-
</bodyText>
<page confidence="0.970086">
183
</page>
<equation confidence="0.822967">
repuLsolirronptiAtzicaiTtozi:151.7do
(E x (Cy (E z (E w (Se (tok x lieute) (tok v Treffen) (tok z in) (tok w Hann over))11))
E y (E z (E w (&amp; (tok x heute)(tok y Treffen)(tok z in) (tok w Hannover)))))
E z (E v (&amp; (tok x heute)(tok y Treffen)(tok z in) (tok w Hannover))))
E w (&amp; (tok x heute) (tok y Treffen) (tok z in) (tok w Hannover)))
&amp; (tok x heute) (tok y Treffen) (tok z in) (tok w Hannover))
tok x heute)
tok y Treffen)
tok z in)
tnk a H.nnnver)
submit r Result
</equation>
<figureCaption confidence="0.987534">
Figure 2: Graphical user interface of fsq
</figureCaption>
<bodyText confidence="0.999978">
ation of the conjuncts the moment we receive the
first conjunct being evaluated to false and return
false as value of the conjunction. For atomic for-
mulae, the evaluation is a mere look-up to check
if the nodes of the structure as given by the vari-
able assignment do stand in the relation that is
expressed by the formula. All in all, the evalu-
ation process follows the definition of the seman-
tics rather closely. Each tree is checked separately,
and those trees for which the query evaluates to
true are returned as answers to the query.
</bodyText>
<subsectionHeader confidence="0.997617">
3.3 The Graphical User Interface
</subsectionHeader>
<bodyText confidence="0.999977707692308">
The graphical user interface is designed to assist
the user in formulating a query by supporting him
to compose formulae in a bottom-up fashion.
The centre of the interface (see Figure 2) con-
sists of a list of formulae that the user can ma-
nipulate. To pose a query, the user selects one
of these formulae and clicks the Submit button.
Thereafter, the result set in the form of the num-
bers of those trees for which the query is true can
be browsed by pressing the Result button. It is in-
tended that the user feeds this result set into tools
like Annotate (Plaehn and Brants, 2000) that al-
low a detailed inspection of the results.
When composing a query most users think in
a bottom-up fashion focusing first on the atomic
constituents. This approach is systematically sup-
ported by the user interface in the following way.
The Atomic menu lets the user compose atomic
formulae. He picks the relation of his choice, say,
e.g., the dominance relation. He is successively
asked for names of the variables one dominating
the other, say, e.g., x and y. Thereafter, the syntac-
tically correct formula ( &gt;&gt; x y) is added to the
list of formulae as the topmost element. The other
atomic formulae can be constructed in a similar
fashion.
In order to get more complex formulae, the user
can choose operations from the Complex menu.
It contains menu options for the boolean connec-
tives and quantifiers. To compose, e.g,, a con-
junction, the user first chooses the formulae he
wishes to conjoin by clicking on them in the list
of formulae. Thereafter he just picks the Conjunc-
tion menu item and the conjunction of the for-
mulae he chose is added to the list of formulae
as the topmost element. In case of an existential
or universal quantification, the user selects a for-
mula from the list, say, e.g., ( &gt;&gt; x y) and, e.g.,
the Existential Quantification menu item. He will
be asked for the name of the variable to quantify
over, say x, and the existentially quantified for-
mula, ( E x (&gt;&gt; x y) ), is added to the list of for-
mulae as the topmost element.
The Form menu offers additional operations on
formulae. The user can edit a formula by hand,
or enter a new one by hand He can duplicate or
delete a formula from the list. Or he can swap the
order of two formulae on the list.
The File menu offers the ability to save the cur-
rent list of formulae for further use or to load a list
of formulae saved as a file.
The user also has to choose a corpus, not just
compose a query. This step is supported by a file
chooser that starts when clicking the word Cotpus
and offers only corpora precompiled for fsq.
The refinement checkbox to the right of the
chosen corpus field helps the user in narrowing
in search results. If checked, the next query will
not be executed on the whole corpus chosen but
rather on the previous search result for that cor-
pus. Thus the user can first pose an approximat-
ing query, inspect the result and then formulate a
more fine grained query to be executed only on the
result of the first query to get a smaller answer set.
Of course these steps can be iterated.
</bodyText>
<sectionHeader confidence="0.999684" genericHeader="related work">
4 Related Work
</sectionHeader>
<bodyText confidence="0.9956756">
In recent times, a number of query tools for
syntactically annotated corpora have been pro-
posed. Amongst the most important ones are
CorpusSearch (Randall, 2000), ICECUP III (Wal-
lis and Nelson, 2000), NetGraph (Mfrovsk3i et
</bodyText>
<page confidence="0.997309">
184
</page>
<bodyText confidence="0.980377594936709">
al., 2002), TGrep2 (Rohde, 2001), TIGERsearch
(Konig and Lezius, 2000), and VIQTORYA
(Kallmeyer and Steiner, 2003). We compare them
here to fsq focusing our attention on the expres-
sive power of the query language, on the underly-
ing data structures, on the existence of a user in-
terface, and on corpus formats they can cope with.
Since unary and binary predicates for node labels,
tokens, dominance, and precedence are in some
form or other provided by all query languages, we
do not mention them.
CorpusSearch was developed for querying the
Penn-Helsinki Parsed Corpus of Middle English.
Its query language offers only a restricted form
of negation and disjunction, and no quantifica-
tion. Node variables are implicitely existentially
quantified. The underlying data structure must be
strictly trees. No graphical user interface is pro-
vided. CorpusSearch can be used to query all cor-
pora annotated in the Penn Treebank style.
ICECUP III was developed for querying the
ICE-GB, the British component of the Interna-
tional Corpus of English. Its query language con-
tains only a restricted form of negation, no dis-
junction and no quantification. Node variables are
implicitely existentially quantified. The underly-
ing data structure must be strictly trees. ICECUP
has a nice graphical user interface. It is designed
to query the ICE-GB, it is unclear whether it can
be used on other corpora than ICE.
NetGraph was developed as a corpus work-
bench for the Prague Dependency Treebank. Its
query component implements the positive existen-
tial fragment. The data structures underlying the
queries are strict trees. NetGraph has a nice graph-
ical user interface. It is designed for the Prague
Dependency Treebank; whether it can be used on
other corpora is unclear to the author.
TGrep2 was developed for querying corpora
annotated in the Penn Treebank style. Its pat-
tern matching query language is difficult to cap-
ture in logical terms. It goes beyond the existen-
tial fragment2, but is not full first order. There is
no overt quantification. The underlying data struc-
tures must be strictly trees. There is no graphical
2Arbitrary conjunctions, disjunctions, and negations of
formulae, but all variables are interpreted as being existen-
tially quantified.
user interface provided.
TIGERsearch, originally developed to query a
German newspaper treebank, is one of the most
advanced tools. Its query language is the existen-
tial fragment, the underlying data structures can
be more general than trees. TIGERsearch has
a nice graphical user interface. Its greatest ad-
vantage is probably its usability on many differ-
ent corpus formats including NEGRA and Penn
Treebank. On a side note, TIGERsearch imple-
ments a strange notion of linear precedence which
is probably counterintuitive and undesirable for
linguists. For more details, see the discussion by
Kallmeyer and Steiner (2003, p. 23).
VIQTORYA was developed for querying the
Tubingen Treebanks. Its query language is the
existential fragment, the underlying data struc-
tures can be more general than trees. VIQTORYA
comes with a nice graphical user interface. It is
applicable to those corpora in NEGRA export for-
mat where no trees have crossing branches or sec-
ondary edges.
None of the above query tools can compete with
fsq on the grounds of expressive power of the
query language and generality of the underlying
data structures. For some, like TIGERsearch and
VIQTORYA, one can see a division of labour. They
are more appropriate for fast answers to purely
existential queries, while fsq is the query tool of
choice for queries that require an intensive use of
quantification.
</bodyText>
<sectionHeader confidence="0.997486" genericHeader="conclusions">
5 Conclusion and Future Work
</sectionHeader>
<bodyText confidence="0.999960733333333">
In this paper, we presented fsq, a query tool for
syntactically annotated corpora. fsq is designed
to provide users a very expressive query system.
Therefore its query language is full first-order
logic, and its underlying data structures are fi-
nite first-order structures. These data structures
include proper trees, but also all of those exten-
sions one can find in existing corpora like discon-
tinuous substructures, crossing branches or sec-
ondary edges. The query language allows to query
these structures using full first-order quantifica-
tion. Hence, fsq seems one of the most powerful
query system for annotated corpora currently ex-
isting. fsq is publicly available, see http: //t cl .
sfs .urn-tuebingen. de/ fsq.
</bodyText>
<page confidence="0.996683">
185
</page>
<bodyText confidence="0.9998678">
The two main directions of extensions are the
query language and the corpus input formats fsq
can cope with. Although first-order logic is quite
an expressive language, there are well-known re-
strictions. It may therefore be worthwhile to con-
sider (fragments of) second-order logic as query
language. Second order quantification allows to
define new relations not contained in the signa-
ture such as transitive closure of a relation. An-
other extension of the query language can be a
simplified syntax for simple queries without com-
plex quantification to make the tool easier usable
for linguists with less experience in formal logics.
The extension to other corpus input formats is
of course an important step to increase usability of
the tool. We therefore intend to extend fsq to cope
with corpora in the Penn Treebank format and cer-
tain formats in XML. The main work for such an
extension lies in extending the initialisation com-
ponent.
</bodyText>
<sectionHeader confidence="0.978918" genericHeader="acknowledgments">
Acknowledgements
</sectionHeader>
<bodyText confidence="0.999958142857143">
The work presented here is part of the project A2
in the Special Research Programme (SFB) 441
&amp;quot;Linguistic Data Structures&amp;quot; at the University of
Tubingen funded by a grant of the German Re-
search Council (DFG SFB 441-02). We would
like to thank Ilona Steiner for interesting and fruit-
ful discussions.
</bodyText>
<sectionHeader confidence="0.998275" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999710746268657">
Anne Abeille and Lionel Clement. 1999. A tagged ref-
erence corpus for French. In Proceedings of EACL-
LINC.
Thorsten Brants, Wojciech Skut, and Hans Uszkoreit.
1999. Syntactic annotation of a German newspa-
per corpus. In Proceedings of the ATALA Treebank
Workshop, pages 69-76.
Thorsten Brants. 1997. The NEGRA export for-
mat. CLAUS Report 98, Universitat des Saarlandes,
Computerlinguistik, Saarbriicken, Germany.
Erhard Hinrichs, Julia Bartels, Yasuhiro Kawata, Valia
Kordoni, and Heike Telljohann. 2000. The VERB-
MOBIL treebanks. In Proceedings of KONVENS
2000.
Tilman Mlle. 1985. Der Begriff `Mittelfeld&apos;.
Anmerkungen fiber die Theorie der topologischen
Felder. In A. Schone, editor, Kontroversen, alte und
neue. Akten des 7. Internationalen Germanistenkon-
gresses, pages 329-340.
Laura Kallmeyer and Ilona Steiner. 2003. Querying
treebanks of spontaneous speech with VIQTORYA.
Traitement Automatique des Lan gues, 43(2).
Esther Konig and Wolfgang Lezius. 2000. A descrip-
tion language for syntactically annotated corpora.
In Proceedings of the COLING Conference, pages
1056-1060.
Mitchell Marcus, Beatrice Santorini, and Mary Ann
Marcinkiewicz. 1993. Building a large annotated
corpus of English: The Penn Treebank. Computa-
tional Linguistics, 19(2):313-330.
Jiff MfrovskY, Roman Ondrugka, and Daniel Prega.
2002. Searching through Prague Dependency Tree-
bank. In Erhard Hinrichs and Kiril Simov, editors,
Proceedings of Treebanks and Linguistic Theories,
pages 114-122.
Oliver Plaehn and Thorsten Brants. 2000. Annotate
- an efficient interactive annotation tool. In Sixth
Conference on Applied Natural Language Process-
ing (ANLP-2000).
Beth Randall. 2000. CorpusSearch user&apos;s man-
ual. Technical report, University of Pennsyl-
vania. http://www.ling.upenn.edu/mideng/
ppeme2dir/.
Douglas Rohde. 2001. Tgrep2. Technical report,
Carnegie Mellon University. http: //tedlab.
mit.edu/-dr/Tgrep2/.
Anne Schiller, Simone Teufel, and Christine Thie-
len. 1995. Guidelines fiir das Tagging deutscher
Textcorpora mit STTS. Manuscript, Universities of
Stuttgart and Tiibingen.
Rosmary Stegmann, Heike Telljohann, and Erhard
Hinrichs. 2000. Stylebook for the German tree-
bank in VERBMOBIL. Technical Report 239, SfS,
University of Tilbingen.
Alexei Stolboushkin and Michael Taitslin. 1994.
Is first order contained in an initial segment of
PTIME? In Leszek Pacholski and Jerzy Tiuryn, ed-
itors, Proceedings CSL, volume LNCS 933, pages
242-248. Springer.
Moshe Vardi. 1982. The complexity of relational
query languages. In Proceedings of the 14th ACM
Symposium on Theory of Computing, pages 137-
146.
Sean Wallis and Gerald Nelson. 2000. Exploiting
fuzzy tree fragment queries in the investigation of
parsed corpora. Literary and Linguistic Computing,
15(3):339-361.
</reference>
<page confidence="0.998788">
186
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.493049">
<title confidence="0.99375">Finite Structure Query: A Tool for Querying Syntactically Annotated Corpora</title>
<author confidence="0.995875">Stephan Kepser</author>
<address confidence="0.688843">441 — of Tubingen Nauklerstr. 35, 72074 Tubingen, Germany</address>
<abstract confidence="0.9978295">Finite structure query (fsq for short) is a tool for querying syntactically annotated corpora. fsq employs a query language of high expressive power, namely full first order logic. It can be used to query arbitrary finite structures, not just trees.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Anne Abeille</author>
<author>Lionel Clement</author>
</authors>
<title>A tagged reference corpus for French.</title>
<date>1999</date>
<booktitle>In Proceedings of EACLLINC.</booktitle>
<marker>Abeille, Clement, 1999</marker>
<rawString>Anne Abeille and Lionel Clement. 1999. A tagged reference corpus for French. In Proceedings of EACLLINC.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Thorsten Brants</author>
<author>Wojciech Skut</author>
<author>Hans Uszkoreit</author>
</authors>
<title>Syntactic annotation of a German newspaper corpus.</title>
<date>1999</date>
<booktitle>In Proceedings of the ATALA Treebank Workshop,</booktitle>
<pages>69--76</pages>
<contexts>
<context position="1111" citStr="Brants et al., 1999" startWordPosition="164" endWordPosition="167">unts of electronic texts have become available providing a new base for empirical studies in linguistics and offering a chance to linguists to compare their theories with large amounts of utterances from &amp;quot;the real world&amp;quot;. While tagging with morphosyntactic categories has become a standard for almost all corpora, more and more of them are nowadays annotated with refined syntactic information. Examples are the Penn Treebank (Marcus et al., 1993) for American English annotated at the University of Pennsylvania, the French treebank (AbelIle and Clement, 1999) developed in Paris, the NEGRA Corpus (Brants et al., 1999) for German annotated at the University of Saarbriicken, and the Tubingen Treebanks (Hinrichs et al., 2000) for Japanese, German and English from the University of Tubingen. To make these rich syntactic annotations accessible for linguists the development of powerful query tools is an obvious need and has become an important task in computational linguistics. In this paper, we present finite structure query (fsq), a query tool for syntactically annotated corpora. Special emphasis in the development of fsq is layed on providing users a very powerful query language. Therefore full first-order lo</context>
</contexts>
<marker>Brants, Skut, Uszkoreit, 1999</marker>
<rawString>Thorsten Brants, Wojciech Skut, and Hans Uszkoreit. 1999. Syntactic annotation of a German newspaper corpus. In Proceedings of the ATALA Treebank Workshop, pages 69-76.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Thorsten Brants</author>
</authors>
<title>The NEGRA export format.</title>
<date>1997</date>
<tech>CLAUS Report 98,</tech>
<institution>Universitat des Saarlandes,</institution>
<location>Computerlinguistik, Saarbriicken, Germany.</location>
<contexts>
<context position="2117" citStr="Brants, 1997" startWordPosition="330" endWordPosition="331">e structure query (fsq), a query tool for syntactically annotated corpora. Special emphasis in the development of fsq is layed on providing users a very powerful query language. Therefore full first-order logic was chosen as query language which allows arbitrary quantifications over nodes in a tree. This choice is to the authors&apos; knowledge unique, no other query tool offers such an expressive power. It is on the other hand not arbitrary, we will show that there are interesting linguistic queries that require such an expressive power. The tool is developed for treebanks in NEGRA export format (Brants, 1997), but can be adopted to other corpus formats as well. The linguistic examples that follow are from the Tubingen Treebanks 1.1 The Tübingen Treebanks The Tubingen Treebanks, annotated at the University of Tubingen, comprise a German, an English and a Japanese treebank consisting of spoken dialogs restricted to the domain of arranging business appointments. In this paper, we focus on the German treebank (TiiBa-D) (Stegmann et al., 2000; Hinrichs et al., 2000) that contains approximately 38.000 trees. The treebank is part-of-speech tagged using the Stuttgart-TUbingen tag set (STTS) developed by S</context>
<context position="16343" citStr="Brants, 1997" startWordPosition="2908" endWordPosition="2909">E x (tok x heute) ) (E x (tok x in) ) (E x (tok x Treffen) ) (E x (tok x Hannover))) with quantifier depth just 1! 3 The Architecture of fsq fsq consists of three main parts: A treebank initialiser, the query engine, and a graphical user interface to the query engine. All components of fsq are implemented in Java JDK 1.3. No propriatory or special libraries are used, so fsq can be run on any standard Java runtime environment (JRE 1.3) independent of the platform and operating system chosen. 3.1 Initialising a Treebank The input format of treebanks fsq can cope with is the NEGRA export format (Brants, 1997). This format is designed for data exchange and to be readable by humans. It is not very well suited as a format to be queried, because relations between nodes are implicitely instead of explicitely represented. Therefore we need an initialisation step that transforms the NEGRA format into one that can be queried a lot faster. The query format is a compact binary representation of the relations of the trees. Each tree has its own representation, independent of the others. The binary relations (dominance, precedence, etc.) are represented as a twodimensional quadratic array indexed by the nodes</context>
</contexts>
<marker>Brants, 1997</marker>
<rawString>Thorsten Brants. 1997. The NEGRA export format. CLAUS Report 98, Universitat des Saarlandes, Computerlinguistik, Saarbriicken, Germany.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Erhard Hinrichs</author>
<author>Julia Bartels</author>
<author>Yasuhiro Kawata</author>
<author>Valia Kordoni</author>
<author>Heike Telljohann</author>
</authors>
<title>The VERBMOBIL treebanks.</title>
<date>2000</date>
<booktitle>In Proceedings of KONVENS</booktitle>
<contexts>
<context position="1218" citStr="Hinrichs et al., 2000" startWordPosition="181" endWordPosition="184">and offering a chance to linguists to compare their theories with large amounts of utterances from &amp;quot;the real world&amp;quot;. While tagging with morphosyntactic categories has become a standard for almost all corpora, more and more of them are nowadays annotated with refined syntactic information. Examples are the Penn Treebank (Marcus et al., 1993) for American English annotated at the University of Pennsylvania, the French treebank (AbelIle and Clement, 1999) developed in Paris, the NEGRA Corpus (Brants et al., 1999) for German annotated at the University of Saarbriicken, and the Tubingen Treebanks (Hinrichs et al., 2000) for Japanese, German and English from the University of Tubingen. To make these rich syntactic annotations accessible for linguists the development of powerful query tools is an obvious need and has become an important task in computational linguistics. In this paper, we present finite structure query (fsq), a query tool for syntactically annotated corpora. Special emphasis in the development of fsq is layed on providing users a very powerful query language. Therefore full first-order logic was chosen as query language which allows arbitrary quantifications over nodes in a tree. This choice i</context>
<context position="2578" citStr="Hinrichs et al., 2000" startWordPosition="404" endWordPosition="407">ow that there are interesting linguistic queries that require such an expressive power. The tool is developed for treebanks in NEGRA export format (Brants, 1997), but can be adopted to other corpus formats as well. The linguistic examples that follow are from the Tubingen Treebanks 1.1 The Tübingen Treebanks The Tubingen Treebanks, annotated at the University of Tubingen, comprise a German, an English and a Japanese treebank consisting of spoken dialogs restricted to the domain of arranging business appointments. In this paper, we focus on the German treebank (TiiBa-D) (Stegmann et al., 2000; Hinrichs et al., 2000) that contains approximately 38.000 trees. The treebank is part-of-speech tagged using the Stuttgart-TUbingen tag set (STTS) developed by Schiller et al. (1995). One of the design decisions for the development of the treebank was the commitment to reusability. As a consequence, the choice of the syntactic annotation scheme should not reflect a particular syntactic theory but rather be as theory-neutral as possible. Therefore a surface-oriented scheme was adopted to structure German sentences that uses the notion of topological fields in a sense similar to that of Hohle (1985). The verbal eleme</context>
</contexts>
<marker>Hinrichs, Bartels, Kawata, Kordoni, Telljohann, 2000</marker>
<rawString>Erhard Hinrichs, Julia Bartels, Yasuhiro Kawata, Valia Kordoni, and Heike Telljohann. 2000. The VERBMOBIL treebanks. In Proceedings of KONVENS 2000.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Tilman Mlle</author>
</authors>
<title>Der Begriff `Mittelfeld&apos;. Anmerkungen fiber die Theorie der topologischen Felder. In</title>
<date>1985</date>
<booktitle>Kontroversen, alte und neue. Akten des 7. Internationalen Germanistenkongresses,</booktitle>
<pages>329--340</pages>
<editor>A. Schone, editor,</editor>
<marker>Mlle, 1985</marker>
<rawString>Tilman Mlle. 1985. Der Begriff `Mittelfeld&apos;. Anmerkungen fiber die Theorie der topologischen Felder. In A. Schone, editor, Kontroversen, alte und neue. Akten des 7. Internationalen Germanistenkongresses, pages 329-340.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Laura Kallmeyer</author>
<author>Ilona Steiner</author>
</authors>
<title>Querying treebanks of spontaneous speech with VIQTORYA.</title>
<date>2003</date>
<booktitle>Traitement Automatique des Lan gues,</booktitle>
<pages>43--2</pages>
<contexts>
<context position="9801" citStr="Kallmeyer and Steiner (2003)" startWordPosition="1696" endWordPosition="1699">f this query language with linguistically motivated examples. When so-called fuzzy tree fragments (see (Wallis and Nelson, 2000)) were first introduced, they provided a significant progress over simple string matching languages. Nowadays they are standard, every sensitive query tool for syntactically annotated corpora offers this type of underspecification, and fsq is no exception to this rule. We will therefore bypass them completely. Due to space restrictions, we will neither show how to query unconnected sub-parts of a tree. The reader interested in this issue is referred to the article by Kallmeyer and Steiner (2003). Everything discussed there for the query tool VIQTORYA can be queried by fsq, too. Rather we focus on the use of quantification, something that fsq offers, but no other query tool does in a similar way. Suppose we are looking for trees where a clause lacks the subject. We can pose the following query to do so:1 ]x SIMPX (x) A Vy((x&gt;&gt; y) —iON(y) ) The formula reads &amp;quot;There is a clause node (node of category SIMPX) such that no node below it is a subject node (node of function ON (Object in the Nominative)).&amp;quot; An example result is the tree in Figure 1. Another result from the same corpus would b</context>
<context position="23466" citStr="Kallmeyer and Steiner, 2003" startWordPosition="4168" endWordPosition="4171">s search result for that corpus. Thus the user can first pose an approximating query, inspect the result and then formulate a more fine grained query to be executed only on the result of the first query to get a smaller answer set. Of course these steps can be iterated. 4 Related Work In recent times, a number of query tools for syntactically annotated corpora have been proposed. Amongst the most important ones are CorpusSearch (Randall, 2000), ICECUP III (Wallis and Nelson, 2000), NetGraph (Mfrovsk3i et 184 al., 2002), TGrep2 (Rohde, 2001), TIGERsearch (Konig and Lezius, 2000), and VIQTORYA (Kallmeyer and Steiner, 2003). We compare them here to fsq focusing our attention on the expressive power of the query language, on the underlying data structures, on the existence of a user interface, and on corpus formats they can cope with. Since unary and binary predicates for node labels, tokens, dominance, and precedence are in some form or other provided by all query languages, we do not mention them. CorpusSearch was developed for querying the Penn-Helsinki Parsed Corpus of Middle English. Its query language offers only a restricted form of negation and disjunction, and no quantification. Node variables are implic</context>
<context position="26211" citStr="Kallmeyer and Steiner (2003" startWordPosition="4606" endWordPosition="4609">tified. user interface provided. TIGERsearch, originally developed to query a German newspaper treebank, is one of the most advanced tools. Its query language is the existential fragment, the underlying data structures can be more general than trees. TIGERsearch has a nice graphical user interface. Its greatest advantage is probably its usability on many different corpus formats including NEGRA and Penn Treebank. On a side note, TIGERsearch implements a strange notion of linear precedence which is probably counterintuitive and undesirable for linguists. For more details, see the discussion by Kallmeyer and Steiner (2003, p. 23). VIQTORYA was developed for querying the Tubingen Treebanks. Its query language is the existential fragment, the underlying data structures can be more general than trees. VIQTORYA comes with a nice graphical user interface. It is applicable to those corpora in NEGRA export format where no trees have crossing branches or secondary edges. None of the above query tools can compete with fsq on the grounds of expressive power of the query language and generality of the underlying data structures. For some, like TIGERsearch and VIQTORYA, one can see a division of labour. They are more appr</context>
</contexts>
<marker>Kallmeyer, Steiner, 2003</marker>
<rawString>Laura Kallmeyer and Ilona Steiner. 2003. Querying treebanks of spontaneous speech with VIQTORYA. Traitement Automatique des Lan gues, 43(2).</rawString>
</citation>
<citation valid="true">
<authors>
<author>Esther Konig</author>
<author>Wolfgang Lezius</author>
</authors>
<title>A description language for syntactically annotated corpora.</title>
<date>2000</date>
<booktitle>In Proceedings of the COLING Conference,</booktitle>
<pages>1056--1060</pages>
<contexts>
<context position="23422" citStr="Konig and Lezius, 2000" startWordPosition="4162" endWordPosition="4165">corpus chosen but rather on the previous search result for that corpus. Thus the user can first pose an approximating query, inspect the result and then formulate a more fine grained query to be executed only on the result of the first query to get a smaller answer set. Of course these steps can be iterated. 4 Related Work In recent times, a number of query tools for syntactically annotated corpora have been proposed. Amongst the most important ones are CorpusSearch (Randall, 2000), ICECUP III (Wallis and Nelson, 2000), NetGraph (Mfrovsk3i et 184 al., 2002), TGrep2 (Rohde, 2001), TIGERsearch (Konig and Lezius, 2000), and VIQTORYA (Kallmeyer and Steiner, 2003). We compare them here to fsq focusing our attention on the expressive power of the query language, on the underlying data structures, on the existence of a user interface, and on corpus formats they can cope with. Since unary and binary predicates for node labels, tokens, dominance, and precedence are in some form or other provided by all query languages, we do not mention them. CorpusSearch was developed for querying the Penn-Helsinki Parsed Corpus of Middle English. Its query language offers only a restricted form of negation and disjunction, and </context>
</contexts>
<marker>Konig, Lezius, 2000</marker>
<rawString>Esther Konig and Wolfgang Lezius. 2000. A description language for syntactically annotated corpora. In Proceedings of the COLING Conference, pages 1056-1060.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Mitchell Marcus</author>
<author>Beatrice Santorini</author>
<author>Mary Ann Marcinkiewicz</author>
</authors>
<title>Building a large annotated corpus of English: The Penn Treebank. Computational Linguistics,</title>
<date>1993</date>
<pages>19--2</pages>
<contexts>
<context position="938" citStr="Marcus et al., 1993" startWordPosition="138" endWordPosition="141">nguage of high expressive power, namely full first order logic. It can be used to query arbitrary finite structures, not just trees. 1 Introduction In recent years large amounts of electronic texts have become available providing a new base for empirical studies in linguistics and offering a chance to linguists to compare their theories with large amounts of utterances from &amp;quot;the real world&amp;quot;. While tagging with morphosyntactic categories has become a standard for almost all corpora, more and more of them are nowadays annotated with refined syntactic information. Examples are the Penn Treebank (Marcus et al., 1993) for American English annotated at the University of Pennsylvania, the French treebank (AbelIle and Clement, 1999) developed in Paris, the NEGRA Corpus (Brants et al., 1999) for German annotated at the University of Saarbriicken, and the Tubingen Treebanks (Hinrichs et al., 2000) for Japanese, German and English from the University of Tubingen. To make these rich syntactic annotations accessible for linguists the development of powerful query tools is an obvious need and has become an important task in computational linguistics. In this paper, we present finite structure query (fsq), a query t</context>
</contexts>
<marker>Marcus, Santorini, Marcinkiewicz, 1993</marker>
<rawString>Mitchell Marcus, Beatrice Santorini, and Mary Ann Marcinkiewicz. 1993. Building a large annotated corpus of English: The Penn Treebank. Computational Linguistics, 19(2):313-330.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jiff MfrovskY</author>
<author>Roman Ondrugka</author>
<author>Daniel Prega</author>
</authors>
<title>Searching through Prague Dependency Treebank.</title>
<date>2002</date>
<booktitle>In Erhard Hinrichs and Kiril Simov, editors, Proceedings of Treebanks and Linguistic Theories,</booktitle>
<pages>114--122</pages>
<marker>MfrovskY, Ondrugka, Prega, 2002</marker>
<rawString>Jiff MfrovskY, Roman Ondrugka, and Daniel Prega. 2002. Searching through Prague Dependency Treebank. In Erhard Hinrichs and Kiril Simov, editors, Proceedings of Treebanks and Linguistic Theories, pages 114-122.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Oliver Plaehn</author>
<author>Thorsten Brants</author>
</authors>
<title>Annotate - an efficient interactive annotation tool.</title>
<date>2000</date>
<booktitle>In Sixth Conference on Applied Natural Language Processing (ANLP-2000).</booktitle>
<contexts>
<context position="20619" citStr="Plaehn and Brants, 2000" startWordPosition="3654" endWordPosition="3657"> the query. 3.3 The Graphical User Interface The graphical user interface is designed to assist the user in formulating a query by supporting him to compose formulae in a bottom-up fashion. The centre of the interface (see Figure 2) consists of a list of formulae that the user can manipulate. To pose a query, the user selects one of these formulae and clicks the Submit button. Thereafter, the result set in the form of the numbers of those trees for which the query is true can be browsed by pressing the Result button. It is intended that the user feeds this result set into tools like Annotate (Plaehn and Brants, 2000) that allow a detailed inspection of the results. When composing a query most users think in a bottom-up fashion focusing first on the atomic constituents. This approach is systematically supported by the user interface in the following way. The Atomic menu lets the user compose atomic formulae. He picks the relation of his choice, say, e.g., the dominance relation. He is successively asked for names of the variables one dominating the other, say, e.g., x and y. Thereafter, the syntactically correct formula ( &gt;&gt; x y) is added to the list of formulae as the topmost element. The other atomic for</context>
</contexts>
<marker>Plaehn, Brants, 2000</marker>
<rawString>Oliver Plaehn and Thorsten Brants. 2000. Annotate - an efficient interactive annotation tool. In Sixth Conference on Applied Natural Language Processing (ANLP-2000).</rawString>
</citation>
<citation valid="true">
<authors>
<author>Beth Randall</author>
</authors>
<title>CorpusSearch user&apos;s manual.</title>
<date>2000</date>
<tech>Technical report,</tech>
<institution>University of Pennsylvania.</institution>
<note>http://www.ling.upenn.edu/mideng/ ppeme2dir/.</note>
<contexts>
<context position="23285" citStr="Randall, 2000" startWordPosition="4143" endWordPosition="4144">chosen corpus field helps the user in narrowing in search results. If checked, the next query will not be executed on the whole corpus chosen but rather on the previous search result for that corpus. Thus the user can first pose an approximating query, inspect the result and then formulate a more fine grained query to be executed only on the result of the first query to get a smaller answer set. Of course these steps can be iterated. 4 Related Work In recent times, a number of query tools for syntactically annotated corpora have been proposed. Amongst the most important ones are CorpusSearch (Randall, 2000), ICECUP III (Wallis and Nelson, 2000), NetGraph (Mfrovsk3i et 184 al., 2002), TGrep2 (Rohde, 2001), TIGERsearch (Konig and Lezius, 2000), and VIQTORYA (Kallmeyer and Steiner, 2003). We compare them here to fsq focusing our attention on the expressive power of the query language, on the underlying data structures, on the existence of a user interface, and on corpus formats they can cope with. Since unary and binary predicates for node labels, tokens, dominance, and precedence are in some form or other provided by all query languages, we do not mention them. CorpusSearch was developed for query</context>
</contexts>
<marker>Randall, 2000</marker>
<rawString>Beth Randall. 2000. CorpusSearch user&apos;s manual. Technical report, University of Pennsylvania. http://www.ling.upenn.edu/mideng/ ppeme2dir/.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Douglas Rohde</author>
</authors>
<date>2001</date>
<tech>Tgrep2. Technical report,</tech>
<institution>Carnegie Mellon University.</institution>
<note>http: //tedlab. mit.edu/-dr/Tgrep2/.</note>
<contexts>
<context position="23384" citStr="Rohde, 2001" startWordPosition="4159" endWordPosition="4160">t be executed on the whole corpus chosen but rather on the previous search result for that corpus. Thus the user can first pose an approximating query, inspect the result and then formulate a more fine grained query to be executed only on the result of the first query to get a smaller answer set. Of course these steps can be iterated. 4 Related Work In recent times, a number of query tools for syntactically annotated corpora have been proposed. Amongst the most important ones are CorpusSearch (Randall, 2000), ICECUP III (Wallis and Nelson, 2000), NetGraph (Mfrovsk3i et 184 al., 2002), TGrep2 (Rohde, 2001), TIGERsearch (Konig and Lezius, 2000), and VIQTORYA (Kallmeyer and Steiner, 2003). We compare them here to fsq focusing our attention on the expressive power of the query language, on the underlying data structures, on the existence of a user interface, and on corpus formats they can cope with. Since unary and binary predicates for node labels, tokens, dominance, and precedence are in some form or other provided by all query languages, we do not mention them. CorpusSearch was developed for querying the Penn-Helsinki Parsed Corpus of Middle English. Its query language offers only a restricted </context>
</contexts>
<marker>Rohde, 2001</marker>
<rawString>Douglas Rohde. 2001. Tgrep2. Technical report, Carnegie Mellon University. http: //tedlab. mit.edu/-dr/Tgrep2/.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Anne Schiller</author>
<author>Simone Teufel</author>
<author>Christine Thielen</author>
</authors>
<title>Guidelines fiir das Tagging deutscher Textcorpora mit STTS.</title>
<date>1995</date>
<tech>Manuscript,</tech>
<institution>Universities of Stuttgart and Tiibingen.</institution>
<contexts>
<context position="2738" citStr="Schiller et al. (1995)" startWordPosition="427" endWordPosition="430">), but can be adopted to other corpus formats as well. The linguistic examples that follow are from the Tubingen Treebanks 1.1 The Tübingen Treebanks The Tubingen Treebanks, annotated at the University of Tubingen, comprise a German, an English and a Japanese treebank consisting of spoken dialogs restricted to the domain of arranging business appointments. In this paper, we focus on the German treebank (TiiBa-D) (Stegmann et al., 2000; Hinrichs et al., 2000) that contains approximately 38.000 trees. The treebank is part-of-speech tagged using the Stuttgart-TUbingen tag set (STTS) developed by Schiller et al. (1995). One of the design decisions for the development of the treebank was the commitment to reusability. As a consequence, the choice of the syntactic annotation scheme should not reflect a particular syntactic theory but rather be as theory-neutral as possible. Therefore a surface-oriented scheme was adopted to structure German sentences that uses the notion of topological fields in a sense similar to that of Hohle (1985). The verbal elements have the categories LK (linke Klammer) and vC (verbal complex), roughly everything preceeding the LK forms the &amp;quot;Vorfeld&amp;quot; VF, everything between LK and vC 17</context>
</contexts>
<marker>Schiller, Teufel, Thielen, 1995</marker>
<rawString>Anne Schiller, Simone Teufel, and Christine Thielen. 1995. Guidelines fiir das Tagging deutscher Textcorpora mit STTS. Manuscript, Universities of Stuttgart and Tiibingen.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Rosmary Stegmann</author>
<author>Heike Telljohann</author>
<author>Erhard Hinrichs</author>
</authors>
<title>Stylebook for the German treebank in VERBMOBIL.</title>
<date>2000</date>
<tech>Technical Report 239,</tech>
<institution>SfS, University of Tilbingen.</institution>
<contexts>
<context position="2554" citStr="Stegmann et al., 2000" startWordPosition="400" endWordPosition="403">t arbitrary, we will show that there are interesting linguistic queries that require such an expressive power. The tool is developed for treebanks in NEGRA export format (Brants, 1997), but can be adopted to other corpus formats as well. The linguistic examples that follow are from the Tubingen Treebanks 1.1 The Tübingen Treebanks The Tubingen Treebanks, annotated at the University of Tubingen, comprise a German, an English and a Japanese treebank consisting of spoken dialogs restricted to the domain of arranging business appointments. In this paper, we focus on the German treebank (TiiBa-D) (Stegmann et al., 2000; Hinrichs et al., 2000) that contains approximately 38.000 trees. The treebank is part-of-speech tagged using the Stuttgart-TUbingen tag set (STTS) developed by Schiller et al. (1995). One of the design decisions for the development of the treebank was the commitment to reusability. As a consequence, the choice of the syntactic annotation scheme should not reflect a particular syntactic theory but rather be as theory-neutral as possible. Therefore a surface-oriented scheme was adopted to structure German sentences that uses the notion of topological fields in a sense similar to that of Hohle </context>
</contexts>
<marker>Stegmann, Telljohann, Hinrichs, 2000</marker>
<rawString>Rosmary Stegmann, Heike Telljohann, and Erhard Hinrichs. 2000. Stylebook for the German treebank in VERBMOBIL. Technical Report 239, SfS, University of Tilbingen.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Alexei Stolboushkin</author>
<author>Michael Taitslin</author>
</authors>
<title>Is first order contained in an initial segment of PTIME?</title>
<date>1994</date>
<booktitle>In Leszek Pacholski and Jerzy Tiuryn, editors, Proceedings CSL, volume LNCS 933,</booktitle>
<pages>242--248</pages>
<publisher>Springer.</publisher>
<contexts>
<context position="14033" citStr="Stolboushkin and Taitslin (1994)" startWordPosition="2480" endWordPosition="2483">ms of the size of the database or treebank. It is common knownledge that the problem of evaluating a first-order sentence on a finite structure is in the complexity class LOGSPACE and therefore in PTIME in terms of the size of the structure (see, e.g., (Vardi, 1982)). But it is currently unknown, whether the problem fits into a proper subclass of PTIME in the polynomial hierarchy, i.e., whether there is a fixed exponent — independent of the structure and the query — such that the evaluation time is in the order of the size of the structure to the power of that exponent (see, e.g., the work by Stolboushkin and Taitslin (1994), which suggests a negative answer to the question). The algorithm implemented in fsq, although simple, has a data complexity of PTIME. More precisely, if n is the number of nodes in a tree and k is the quantifier depth of the query, then the algorithm evaluates the query on the tree in time 0(nk). As stated above, it is not known whether algorithms with a better complexity do exist at all. Practically, this result is of course not unproblematic, and the question arises at what quantifier depth the evaluation time of a query becomes so long that it exceeds user sustainable response time. Our t</context>
</contexts>
<marker>Stolboushkin, Taitslin, 1994</marker>
<rawString>Alexei Stolboushkin and Michael Taitslin. 1994. Is first order contained in an initial segment of PTIME? In Leszek Pacholski and Jerzy Tiuryn, editors, Proceedings CSL, volume LNCS 933, pages 242-248. Springer.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Moshe Vardi</author>
</authors>
<title>The complexity of relational query languages.</title>
<date>1982</date>
<booktitle>In Proceedings of the 14th ACM Symposium on Theory of Computing,</booktitle>
<pages>137--146</pages>
<contexts>
<context position="13346" citStr="Vardi (1982)" startWordPosition="2359" endWordPosition="2360">o so. When a linguist actually starts extracting instances of more complicated syntactic phenomena, he will quickly develop a desire to have access to arbitrary quantification in the query language. That&apos;s why we chose to provide this in the query language of fsq. 2.4 Complexity Issues One of the fundamental insights of database theory is that there is a price to pay for providing a powerful query language, and this price is that the evaluation of a query can become quite expensive. On the theoretical side it is the so-called data complexity that is relevant for us. This notion, introduced by Vardi (1982), describes the complexity of evaluating a query in terms of the size of the database or treebank. It is common knownledge that the problem of evaluating a first-order sentence on a finite structure is in the complexity class LOGSPACE and therefore in PTIME in terms of the size of the structure (see, e.g., (Vardi, 1982)). But it is currently unknown, whether the problem fits into a proper subclass of PTIME in the polynomial hierarchy, i.e., whether there is a fixed exponent — independent of the structure and the query — such that the evaluation time is in the order of the size of the structure</context>
</contexts>
<marker>Vardi, 1982</marker>
<rawString>Moshe Vardi. 1982. The complexity of relational query languages. In Proceedings of the 14th ACM Symposium on Theory of Computing, pages 137-146.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Sean Wallis</author>
<author>Gerald Nelson</author>
</authors>
<title>Exploiting fuzzy tree fragment queries in the investigation of parsed corpora.</title>
<date>2000</date>
<booktitle>Literary and Linguistic Computing,</booktitle>
<pages>15--3</pages>
<contexts>
<context position="9301" citStr="Wallis and Nelson, 2000" startWordPosition="1617" endWordPosition="1621">a result, a query or closed formula is true or false of a tree. Thus, a tree is an answer to a query, if it is a model for the query. And the result of a query on a treebank is the set of all trees which are models of the query. 2.3 Expressive Power The primary idea behind fsq is to provide a query system with a powerful language and clear and well-established semantics. We therefore opted to use full first-order logic as a query language. In this section, we will show the expressive power of this query language with linguistically motivated examples. When so-called fuzzy tree fragments (see (Wallis and Nelson, 2000)) were first introduced, they provided a significant progress over simple string matching languages. Nowadays they are standard, every sensitive query tool for syntactically annotated corpora offers this type of underspecification, and fsq is no exception to this rule. We will therefore bypass them completely. Due to space restrictions, we will neither show how to query unconnected sub-parts of a tree. The reader interested in this issue is referred to the article by Kallmeyer and Steiner (2003). Everything discussed there for the query tool VIQTORYA can be queried by fsq, too. Rather we focus</context>
<context position="23323" citStr="Wallis and Nelson, 2000" startWordPosition="4147" endWordPosition="4151">e user in narrowing in search results. If checked, the next query will not be executed on the whole corpus chosen but rather on the previous search result for that corpus. Thus the user can first pose an approximating query, inspect the result and then formulate a more fine grained query to be executed only on the result of the first query to get a smaller answer set. Of course these steps can be iterated. 4 Related Work In recent times, a number of query tools for syntactically annotated corpora have been proposed. Amongst the most important ones are CorpusSearch (Randall, 2000), ICECUP III (Wallis and Nelson, 2000), NetGraph (Mfrovsk3i et 184 al., 2002), TGrep2 (Rohde, 2001), TIGERsearch (Konig and Lezius, 2000), and VIQTORYA (Kallmeyer and Steiner, 2003). We compare them here to fsq focusing our attention on the expressive power of the query language, on the underlying data structures, on the existence of a user interface, and on corpus formats they can cope with. Since unary and binary predicates for node labels, tokens, dominance, and precedence are in some form or other provided by all query languages, we do not mention them. CorpusSearch was developed for querying the Penn-Helsinki Parsed Corpus of</context>
</contexts>
<marker>Wallis, Nelson, 2000</marker>
<rawString>Sean Wallis and Gerald Nelson. 2000. Exploiting fuzzy tree fragment queries in the investigation of parsed corpora. Literary and Linguistic Computing, 15(3):339-361.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>