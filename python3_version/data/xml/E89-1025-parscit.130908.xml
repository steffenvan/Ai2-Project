<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<bodyText confidence="0.98020075">
A rich environment for experimentation with
unification grammars
R. Johnson &amp; M. Rosner
IDSIA, Lugano
</bodyText>
<sectionHeader confidence="0.756095" genericHeader="abstract">
ABSTRACT
</sectionHeader>
<bodyText confidence="0.997767142857143">
This paper describes some of
the features of a sophisti-
cated language and environment
designed for experimentation
with unification-oriented
linguistic descriptions. The
system, which is called ud,
has to date been used success-
fully as a development and
prototyping tool in a research
project on the application of
situation schemata to the
representation of real text,
and in extensive experimenta-
tion in machine translation.
While the ud language bears
close resemblances to all the
well-known unification grammar
formalisms, it offers a wider
range of features than any
single alternative, plus
powerful facilities for nota-
tional abstraction which allow
users to simulate different
theoretical approaches in a
natural way.
After a brief discussion of
the motivation for implement-
ing yet another unification
device, the main body of the
paper is devoted to a descrip-
tion of the most important
novel features of ud.
The paper concludes with a
discussion of some questions
of implementation and com-
pleteness.
several languages: principally
a demanding machine transla-
tion exercise and a substan-
tial investigation into some
practical applications of
situation semantics (Johnson,
Rosner and Rupp, forthcoming).
The interaction between users
and implementers has figured
largely in the development of
the system, and a major reason
for the richness of its
language and environment has
been the pressure to accommo-
date the needs of a group of
linguists working on three or
four languages simultaneously
and importing ideas from a
variety of different theoreti-
cal backgrounds.
Historically ud evolved out of
a near relative of PATR-II
(Shieber, 1984), and its ori-
gins are still apparent, not
least in the notation. In the
course of development, how-
ever, ud .has been enriched
with ideas from many other
sources, most notably from LFG
(Bresnan, 1982) and HPSG (Sag
and Pollard, 1987).
Among the language features
mentioned in the paper are
- a wide range of data
types, including lists,
trees and user-restricted
types, in addition to the
normal feature structures
comprehensive treatment
of disjunction
</bodyText>
<sectionHeader confidence="0.519249" genericHeader="keywords">
1. Introduction.
</sectionHeader>
<bodyText confidence="0.958778535714286">
The development of ud arose
out of the need to have avail-
able a full set of prototyping
and development tools for a
number of different research
projects in computational
linguistics, all involving
extensive text coverage in
- dynamic binding of path-
name segments
A particular article of faith
which has been very influen-
tial in our work has been the
conviction that well-designed
programming languages (includ-
ing ones used primarily by
- 182 -
linguists), should not only
supply a set of primitives
which are appropriate for the
application domain but should
also contain within themselves
sufficient apparatus to enable
the user to create new
abstractions which can be
tuned to a particular view of
the data.
We have therefore paid partic-
ular attention to a construct
which in ud we call a rela-
tional abstraction, a general-
isation of PATR-II templates
which can take arguments and
which allow multiple, recur-
sive definition. In many
respects relational abstrac-
tions resemble Prolog pro-
cedures, but with a declara-
tive semantics implemented in
terms of a typical feature-
structure unifier.
1.1. Structure of the paper
_ _
Section 2 gives a concise sum-
mary of the semantics of the
basic ud unifier. This serves
as a basis for an informal
discussion, in Section 3, of
our implementation of rela-
tional abstractions in terms
of &apos;lazy&apos; unification. The
final section contains a few
remarks on the issue of com-
pleteness, and a brief survey
of some other language
features.
</bodyText>
<sectionHeader confidence="0.647057" genericHeader="introduction">
2. Basic Unifier Semantics
</sectionHeader>
<bodyText confidence="0.999915470588235">
In addition to the usual atoms
and feature structures, the ud
unifier also deals with lists,
trees, feature structures,
typed instances, and positive
and negative disjunctions of
atoms. This section contains
the definition of unification
over these constructs and
employs certain notational
conventions to represent these
primitive ud data types, as
shown in figure 1.
Throughout the description,
the metavariables U and V
stand for objects of arbitrary
type, and juxtaposed integers
</bodyText>
<subsectionHeader confidence="0.629469">
CP-N
</subsectionHeader>
<bodyText confidence="0.990902461538462">
are intended to be read as
subscripts.
Three other special symbols
are used:
* stands for the unifica-
tion operator
stands for top, the
underdefined element.
# stands for bottom, the
overdefined element that
corresponds to failure.
The semantics of unification
proper are summarised in fig-
ures 2 - 4. Clauses [1] - [3]
define its algebraic proper-
ties; clauses [4] - [6] define
unification over constants,
lists and trees in a manner
analagous to that found in
Prolog.
In figure 4, clause [7] treats
positive and negative disjunc-
tions with respect to sets of
atomic values. Clause [8]
deals with feature structures
and typed instances. Intui-
tively, type assignment is a
method of strictly constrain-
ing the set of attributes
admissible in a feature struc-
ture.
Any case not covered by [1] to
[8] yields #. Moreover, all
the complex type constructors
are strict, yielding # if
applied to any argument that
is itself #.
The extensions to a conven-
tional feature structure
unifier described in this sec-
tion are little more than
cosmetic frills, most of which
could be simulated in a stan-
dard PATR environment, even if
with some loss of descriptive
clarity.
In the rest of the paper, we
discuss a further enhancement
which dramatically and perhaps
controversially extends the
expressive power of the
language.
</bodyText>
<figure confidence="0.813439444444444">
- 183 -
:Type name Notation
:constant A B C
:list [U V]
:n-ary tree VO(V1,..,Vn)
:+ve disjunction /C1,..,Cr/
:-ve disjunction
:feature structure i&lt;A1,V1â€º,..,&lt;Ar,Vr&gt;1
:typed instance &lt;C,f&lt;A1,V1&gt;,..,&lt;An,Vn&gt;1&gt;
</figure>
<figureCaption confidence="0.616306">
:figure 1 : Notational Conventions
</figureCaption>
<equation confidence="0.945228818181818">
+ is commutative:
U + V = V + U
:12] * is the identity:
V+ * V
:[3] + is #-preserving:
:figure 2 : Algebraic Properties
:[4] unification of constants:
:C1 + C2 = Cl, if Cl = C2
:[5] unification of lists:
:[Ul:U2] + [V1:V2] = [111+V1:U2+V2]
:161 unification of trees:
:UO(U1,..,Un) + VO(V1,..,Vn) = UO+VO(U1+V1,..,Un+Vn)
:figure 3 : Constants, Lists and Trees
- 184 -
:[7] disjunction:
+ C = C, if C in {C1 Cn}
+,Bq/
= /C1,..,Cr/, if Ci in {A1,..,Ap}
and Ci in 1131,..,Bql,
r &gt; 0
+ C = C, if C -= Ci, 1&lt;=i&lt;=n
:-/A1,..,Ap/ + -/B1,..,Bq/
</equation>
<bodyText confidence="0.949473333333333">
= -/C1,..,Cr/, where Ci in fAl,..,Api
or Ci in tB1,..,Bql,
l&lt;=i&lt;=r
= -/C1,..,Cr/, where Ci in tAl,..,Apl
and Ci not in iB1,..,Bql,
l&lt;=i&lt;=r
</bodyText>
<equation confidence="0.934791666666667">
:[8] feature structures:
:f&lt;A1,(11&gt;,..,&lt;Ap,Up&gt;1 + t&lt;B1,V1&gt;,..,&lt;Bq,Vq&gt;1
= t&lt;Ai,Ui&gt; : Ai not in f)31,..,B(411 union
t&lt;Bj,Uj&gt; Bj not in {Al,..,Ap)I union
t&lt;Ai,Ui+Vj&gt; : Ai = Bj},
1&lt;=i&lt;=p, 1&lt;=j&lt;=q1
:&lt;C,I&lt;A1,U1&gt;,..,&lt;Ap,Up&gt;1&gt; + &lt;C,I&lt;A1,V1&gt;,..,&lt;Ap,Vp&gt;1&gt;
= &lt;C,I&lt;A1,U1+V1&gt;,..,&lt;Ap,Up+Vp&gt;1&gt;
:&lt;C,I&lt;A1,U1&gt;,..,&lt;Ap,Up&gt;1&gt; + I&lt;B1,V1&gt;,..,&lt;Bg,Vq&gt;1
</equation>
<bodyText confidence="0.977215689655172">
= &lt;C,I&lt;Ai,Ui&gt; : Ai not in IB1,..,B(411
union t&lt;Ai,Ui+Vj&gt; : Al = Bjl&gt;,
if all Bj in fAl,..,Apl,
where 1&lt;=i&lt;=p, 1&lt;=j&lt;=q
:figure 4 : Atomic Value Disjunctions and Feature Structures
3. Extending the Unifier
One of the major shortcomings
of typical PATR-style
languages is their lack of
facilities for defining new
abstractions and expressing
linguistic generalisations not
foreseen (or even foreseeable)
by the language designer. This
becomes a serious issue when,
as in our own case, quite
large teams of linguists need
to develop several large
descriptions simultaneously.
To meet this need, ud provides
a powerful abstraction mechan-
ism which is notationally
similar to a Prolog procedure,
but having a strictly declara-
tive interpretation. We use
the term relational abstrac-
tion to emphasise the non-
procedural nature of the con-
struct.
</bodyText>
<subsectionHeader confidence="0.570855">
3.1. Some Examples of
</subsectionHeader>
<bodyText confidence="0.97552176">
Rela-
tional Abstraction
The examples in this section
are all adapted from a
- 185
description of a large subset
of German written in ud by
C.J. Rupp. As well as rela-
tional abstractions, two other
ud features are introduced
here: a built-in list concate-
nation operator &apos;++&apos; and gen-
eralised disjunction, notated
by curly brackets (e.g.
1X,Y1). These are discussed
briefly in Section 4.
The first example illustrates
a relation Merge, used to col-
lect together the semantics of
an arbitrary number of modif-
iers in some list X into the
semantics of their head Y.
Its definition in the external
syntax of the current ud ver-
sion is
</bodyText>
<equation confidence="0.98855875">
Merge(X,Y) :
Merge-all (X,
&lt;Y desc cond&gt;,
&lt;Y desc ind&gt;)
</equation>
<bodyText confidence="0.998238933333333">
(The invocation operator &apos;I&apos;
is an artefact of the LALR(1)
compiler used to compile the
external notation - one day it
will go away. X and Y should,
in this context, be variables
over feature structures. The
desc, cond and ind attributes
are intended to be mnemonics
for, respectively, &apos;descrip-
tion&apos;, (a list of) &apos;condi-
tions&apos; and &apos;indeterminate&apos;.)
Merge is defined in terms of a
second relation, Merge-all,
whose definition is
</bodyText>
<equation confidence="0.906611">
Merge-all(EHd;Tll,
&lt;Hd desc cond&gt; ++ L,
Ind) :
Ind = &lt;Hd desc ind&gt;
&apos; IMerge-all(T1,L,Ind)
Merge-all([,[],Ind)
</equation>
<bodyText confidence="0.922286206349206">
Merge-all does all the hard
work, making sure that all the
indeterminates are consistent
and recursively combining
together the condition lists.
Although these definitions
look suspiciously like pieces
of Prolog, to which we are
clearly indebted for the nota-
tion, the important differ-
ence, which we already
referred to above, is that the
interpretation of Merge and
Merge-all is strictly declara-
tive.
The best examples of the prac-
tical advantages of this kind
of abstraction tend to be in
the lexicon, typically used to
decouple the great complexity
of lexically oriented descrip-
tions from the intuitive
definitions often expected
from dictionary coders. As
illustration, without entering
into discussion of the under-
lying complexity, for which we
unfortunately do not have
space here, we give an exter-
nal form of a lexical entry
for some of the senses of the
German verb traeumen.
This is a real entry taken
from an HPSG-inspired analysis
mapping into a quite sophisti-
cated situation semantics
representation. All of the
necessary information is
encoded into the four lines of
the entry; the expansions of
Pref, Loctype and Subcat are
all themselves written in ud.
The feature -prefix is merely
a flag interpreted by a
separate morphological com-
ponent to mean that traeumen
has no unstressed prefix and
can take &apos;ge-&apos; in its past
participle form.
traeumen -prefix
!Pref(none)
ILoctype([project])
!Subcat(np(nom),
ivp(inf,squi),
pp(von,dat)Il
Pref is a syntactic abstrac-
tion used in unraveling the
syntax of German separable
prefixes
Loctype is a rudimentary
encoding of Actionsart.
Subcat contains all the infor-
mation necessary for mapping
</bodyText>
<page confidence="0.853046">
-186-
</page>
<bodyText confidence="0.999756555555556">
instances of verbs with vp or
pp complements to a situation
schema (Fenstad, Halvorsen,
Langholm and van Benthem,
1987).
Here, for completeness but
without further discussion,
are the relevant fragments of
the definition of Subcat.
</bodyText>
<equation confidence="0.9993995">
Subcat(np(nom),pp(P,C)) :
!Normal
!Obl(Pobj,P,C,X)
!Arg(X,2)
&lt;* subcat&gt; = [Pobj:T1
!Assign(T,_)
Subcat(np(nom),vp(F,squi))
Control Verb
!Vcomp(VP,F,NP,Sit)
!Arg(Sit,2)
&lt;* subcat&gt; = [VP:T]
!Assign(T,X)
F = inf/bse
!Control(X,NP)
Assign([X],X)
&lt;* voice&gt; = active
!Subj(X)
lArg(X,1)
</equation>
<bodyText confidence="0.99975">
is that some unifications
which would ultimately con-
verge may not converge locally
(i.e. at some given intermedi-
ate stage in a derivation) if
insufficient information is
available at the time when the
unification is attempted (of
course some pathological cases
may not converge at all - we
return to this question
below).
We cope with this by defining
an argument to the unifier as
a pair &lt;I,K&gt;, consisting of an
information structure
belonging to one of the types
listed in section 2, plus an
agenda which holds the set of
as yet unresolved constraints
K which potentially hold over
I. Unification of two
objects,
</bodyText>
<equation confidence="0.820198">
&lt;I1,K1&gt; + &lt;I2,K2&gt;
</equation>
<bodyText confidence="0.959746285714286">
involves the attempt to
resolve the pooled set of con-
straints
K1 union K2 = KO
Assign(1[Y],[]1,Z)
&lt;* voice&gt; = passive
&lt;* vform&gt; = psp
ITakes(none)
!Obl(Y,von,dat,Z)
!Arg(Z,1)
4. Implementation of the
Extensions
In this section we describe
briefly the algorithm used to
implement a declarative seman-
tics for relational abstrac-
tions, concluding with some
remarks on further interesting
extensions which can be imple-
mented naturally once the
basic algorithm is in place.
For the moment, we have only
an informal characterisation,
but a more formal treatment is
in preparation.
4.1. The solution algorithm
_ _
The main problem which arises
when we introduce relational
abstractions into the language
with respect to the newly uni-
fied information structure IO
= I1 + 12, if it exists.
The question of deciding
whether or not some given con-
straint set will converge
locally is solved by a very
simple heuristic. First we
observe that application of
the constraint pool KO to IO
is likely to be non-
deterministic, leading to a
set of possible solutions.
Growth of this solution set
can be contained locally in a
simple way, by constraining
each potentially troublesome
(i.e. recursively definined)
member of KO to apply only
once for each of its possible
expansions, and freezing pos-
sible continuations in a new
constraint set.
After one iteration of this
process we are then left with
a set of pairs
</bodyText>
<equation confidence="0.318541">
f&lt;J1,W &lt;Jr,Lr&gt;l, where
- 187 -
</equation>
<bodyText confidence="0.99802145">
the Li are the current con-
straint sets for the
corresponding Ji.
If this result set is empty,
the unification fails immedi-
ately, i.e. IO is inconsistent
with KO. Otherwise, we allow
the process to continue,
breadth first, only with those
&lt;Ji,Li&gt; pairs such that the
cardinality of Li is strictly
less than at the previous
iteration. The other members
are left unchanged in the
final result, where they are
interpreted as provisional
solutions pending arrival of
further information, for exam-
ple at the next step in a
derivation.
</bodyText>
<equation confidence="0.3811745">
4.2. Decidability
_ _
</equation>
<bodyText confidence="0.9850132">
It is evident that, when all
steps in a derivation have
been completed, the process
described above will in gen-
eral yield a set of
information/constraint pairs
kIl,K1&gt;...&lt;InKn&gt;1 where some
solutions are still incomplete
- i.e. some of the Ki are not
empty. In very many cir-
cumstances it may well be leg-
itimate to take no further
action - for example where the
output from a linguistic pro-
cessor will be passed to some
other device for further
treatment, or where one solu-
tion is adequate and at least
one of the Ki is empty. Gen-
erally, however, the result
set will have to be processed
further.
The obvious move, of relaxing
the requirement on immediate
local convergence and allowing
the iteration to proceed
without bound, is of course
not guaranteed to converge at
all in pathological cases.
Even so, if there exist some
finite number of complete
solutions our depth first
strategy is guaranteed to find
them eventually. If even this
expedient fails, or is unac-
ceptable for some reason, the
user is allowed to change the
environment dynamically so as
to set an arbitrary depth
bound on the number of final
divergent iterations. In
these latter cases, the result
is presented in the form of a
feature structure annotated
with details of any con-
straints which are still
unresolved.
4.2.1. Discussion
_ _ _
Designers of unification gram-
mar formalisms typically avoid
including constructs with the
power of relational abstrac-
tion, presumably through con-
cern about issues of complete-
ness and decidability. We
feel that this is an unfor-
tunate decision in view of the
tremendous increase in expres-
siveness which these con-
structs can give. (Inciden-
tally, they can be introduced,
as in ud, without compromising
declarativeness and monotoni-
city, which are arguably, from
a practical point of view,
more important considera-
tions.) On a more pragmatic
note, ud has been running now
without observable error for
almost a year on descriptions
of substantial subsets of
French and German, and we have
only once had to intervene on
the depth bound, which
defaults to zero (this was
when someone tried to use it
to run Prolog programs).
In practice, users seem to
need the extra power very
sparingly, perhaps in one or
two abstractions in their
entire description, but then
it seems to be crucially
important to the clarity and
elegance of the whole descrip-
tive structure (list appending
operations, as in HPSG, for
example, may be a typical
case).
</bodyText>
<footnote confidence="0.696198">
4.3. Other extensions
_ _
</footnote>
<bodyText confidence="0.9833598">
Once we have a mechanism for
&apos;lazy&apos; unification, it becomes
natural to use the same
apparatus to implement a
- 188 -
variety of features which
improve the habitability and
expressiveness of the system
as a whole. Most obviously we
can exploit the same framework
of local convergence or
suspension to support hand-
coded versions of some basic
primitives like list concate-
nation and non-deterministic
extraction of elements from
arbitrary list positions.
This has been done to advan-
tage in our case, for example,
to facilitate importation of
useful ideas from, inter alia
HPSG and JPSG (Gunji, 1987).
We have also implemented a
fully generalised disjunction
(as oppposed to the atomic
value disjunction described in
section 2) using the same lazy
strategy to avoid exploding
alternatives unnecessarily.
Similarly, it was quite simple
to add a treatment of under-
specified pathnames to allow
simulation of some recent
ideas from LFG (Kaplan,
Maxwell and Zaenen, 1987).
</bodyText>
<sectionHeader confidence="0.887538" genericHeader="method">
5. Current state
</sectionHeader>
<bodyText confidence="0.999517689655172">
The system is still under
development, with a complete
parser and rudimentary syn-
thesiser, plus a full, rever-
sible, morphological com-
ponent. We are now working on
a more satisfactory generation
component, as well as tools -
such as bi/multi-lingual lexi-
cal access and transfer -
specifically crafted for use
in machine translation
research. Substantial frag-
ments of German and French
developed in ud are already
operational.
There is also a rich user
environment, of which space
limitations preclude discus-
sion here, including tracing
and debugging tools and a
variety of interactive
parameterisations for modify-
ing run-time behaviour and
performance. The whole pack-
age runs on Suns, and we have
begun to work on portability
to other lisp/unix combina-
tions.
</bodyText>
<sectionHeader confidence="0.967327" genericHeader="method">
References
</sectionHeader>
<reference confidence="0.969081870967742">
Bresnan J (ed) (1982). The
Mental Representation of Gram-
matical Relations. MIT Press.
Fenstad J-E, P-K Halvorsen, T
Langholm and J van Benthem
(1987). Situations, Language
and Logic. Reidel.
Gunji T (1987). Japanese
Phrase Structure Grammar.
Reidel.
Johnson R, M Rosner and C J
Rupp (forthcoming). &apos;Situa-
tion schemata and linguistic
representation&apos;. In M Rosner
and R Johnson (eds). Computa-
tional Linguistics and Formal
Semantics. Cambridge Univer-
sity Press (to appear in
1989).
Kaplan R, J Maxwell and A
Zaenen (1987). &apos;Functional
Uncertainty&apos;. In CSLI
Monthly, January 1987.
Sag I and C Pollard (1987).
Head-Driven Phrase Structure
Grammar: an Informal Synopsis.
CSLI Report # CSLI-87-79.
Shieber S (1984). &apos;The
design of a computer language
for linguistic information&apos;.
Proceedings of Coling 84.
</reference>
<sectionHeader confidence="0.986417" genericHeader="method">
Acknowledgements
</sectionHeader>
<bodyText confidence="0.9843502">
We thank the Fondazione Dalle
Molle, Suissetra and the
University of Geneva for sup-
porting the work reported in
this paper. We are grateful
to all our former colleagues
in ISSCO, and to all ud users
for their help and encourage-
ment. Special thanks are due
to C.J. Rupp for being a wil-
ling and constructive guinea-
pig, as well as for allowing
us to plunder his work for
German examples.
- 189
</bodyText>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.290107">
<title confidence="0.8908965">environment for experimentation with unification grammars</title>
<author confidence="0.884562">M Johnson&amp;</author>
<affiliation confidence="0.444608">IDSIA, Lugano</affiliation>
<abstract confidence="0.998668298701299">This paper describes some of the features of a sophisticated language and environment designed for experimentation with unification-oriented linguistic descriptions. The system, which is called ud, has to date been used successfully as a development and prototyping tool in a research project on the application of situation schemata to the representation of real text, and in extensive experimentation in machine translation. While the ud language bears close resemblances to all the well-known unification grammar formalisms, it offers a wider range of features than any single alternative, plus powerful facilities for notational abstraction which allow users to simulate different theoretical approaches in a natural way. After a brief discussion of the motivation for implementing yet another unification device, the main body of the paper is devoted to a description of the most important novel features of ud. The paper concludes with a discussion of some questions of implementation and completeness. several languages: principally a demanding machine translation exercise and a substantial investigation into some practical applications of situation semantics (Johnson, Rosner and Rupp, forthcoming). The interaction between users and implementers has figured largely in the development of the system, and a major reason for the richness of its language and environment has been the pressure to accommodate the needs of a group of linguists working on three or four languages simultaneously and importing ideas from a variety of different theoretical backgrounds. Historically ud evolved out of a near relative of PATR-II (Shieber, 1984), and its origins are still apparent, not least in the notation. In the course of development, howud been enriched with ideas from many other sources, most notably from LFG (Bresnan, 1982) and HPSG (Sag and Pollard, 1987). Among the language features mentioned in the paper are a wide range of data types, including lists, trees and user-restricted types, in addition to the normal feature structures comprehensive treatment</abstract>
<intro confidence="0.700116">of disjunction</intro>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>J Bresnan</author>
</authors>
<title>The Mental Representation of Grammatical Relations.</title>
<date>1982</date>
<publisher>MIT Press.</publisher>
<contexts>
<context position="1956" citStr="Bresnan, 1982" startWordPosition="302" endWordPosition="303">en users and implementers has figured largely in the development of the system, and a major reason for the richness of its language and environment has been the pressure to accommodate the needs of a group of linguists working on three or four languages simultaneously and importing ideas from a variety of different theoretical backgrounds. Historically ud evolved out of a near relative of PATR-II (Shieber, 1984), and its origins are still apparent, not least in the notation. In the course of development, however, ud .has been enriched with ideas from many other sources, most notably from LFG (Bresnan, 1982) and HPSG (Sag and Pollard, 1987). Among the language features mentioned in the paper are - a wide range of data types, including lists, trees and user-restricted types, in addition to the normal feature structures comprehensive treatment of disjunction 1. Introduction. The development of ud arose out of the need to have available a full set of prototyping and development tools for a number of different research projects in computational linguistics, all involving extensive text coverage in - dynamic binding of pathname segments A particular article of faith which has been very influential in </context>
</contexts>
<marker>Bresnan, 1982</marker>
<rawString>Bresnan J (ed) (1982). The Mental Representation of Grammatical Relations. MIT Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J-E Fenstad</author>
<author>P-K Halvorsen</author>
<author>T Langholm</author>
<author>J van Benthem</author>
</authors>
<date>1987</date>
<journal>Situations, Language</journal>
<marker>Fenstad, Halvorsen, Langholm, van Benthem, 1987</marker>
<rawString>Fenstad J-E, P-K Halvorsen, T Langholm and J van Benthem (1987). Situations, Language and Logic. Reidel.</rawString>
</citation>
<citation valid="true">
<authors>
<author>T Gunji</author>
</authors>
<date>1987</date>
<journal>Japanese Phrase Structure Grammar. Reidel.</journal>
<contexts>
<context position="16651" citStr="Gunji, 1987" startWordPosition="2703" endWordPosition="2704"> extensions _ _ Once we have a mechanism for &apos;lazy&apos; unification, it becomes natural to use the same apparatus to implement a - 188 - variety of features which improve the habitability and expressiveness of the system as a whole. Most obviously we can exploit the same framework of local convergence or suspension to support handcoded versions of some basic primitives like list concatenation and non-deterministic extraction of elements from arbitrary list positions. This has been done to advantage in our case, for example, to facilitate importation of useful ideas from, inter alia HPSG and JPSG (Gunji, 1987). We have also implemented a fully generalised disjunction (as oppposed to the atomic value disjunction described in section 2) using the same lazy strategy to avoid exploding alternatives unnecessarily. Similarly, it was quite simple to add a treatment of underspecified pathnames to allow simulation of some recent ideas from LFG (Kaplan, Maxwell and Zaenen, 1987). 5. Current state The system is still under development, with a complete parser and rudimentary synthesiser, plus a full, reversible, morphological component. We are now working on a more satisfactory generation component, as well as</context>
</contexts>
<marker>Gunji, 1987</marker>
<rawString>Gunji T (1987). Japanese Phrase Structure Grammar. Reidel.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Johnson</author>
<author>M Rosner</author>
<author>C J Rupp</author>
</authors>
<title>Situation schemata and linguistic representation&apos;.</title>
<date>1989</date>
<booktitle>In M Rosner and R Johnson (eds). Computational Linguistics and Formal Semantics.</booktitle>
<publisher>Cambridge University Press</publisher>
<note>to appear in</note>
<marker>Johnson, Rosner, Rupp, 1989</marker>
<rawString>Johnson R, M Rosner and C J Rupp (forthcoming). &apos;Situation schemata and linguistic representation&apos;. In M Rosner and R Johnson (eds). Computational Linguistics and Formal Semantics. Cambridge University Press (to appear in 1989).</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Kaplan</author>
<author>J Maxwell</author>
<author>A Zaenen</author>
</authors>
<title>Functional Uncertainty&apos;.</title>
<date>1987</date>
<booktitle>In CSLI Monthly,</booktitle>
<marker>Kaplan, Maxwell, Zaenen, 1987</marker>
<rawString>Kaplan R, J Maxwell and A Zaenen (1987). &apos;Functional Uncertainty&apos;. In CSLI Monthly, January 1987.</rawString>
</citation>
<citation valid="true">
<authors>
<author>I Sag</author>
<author>C Pollard</author>
</authors>
<title>Head-Driven Phrase Structure Grammar: an Informal Synopsis.</title>
<date>1987</date>
<tech>CSLI Report #</tech>
<pages>87--79</pages>
<contexts>
<context position="1989" citStr="Sag and Pollard, 1987" startWordPosition="306" endWordPosition="309"> has figured largely in the development of the system, and a major reason for the richness of its language and environment has been the pressure to accommodate the needs of a group of linguists working on three or four languages simultaneously and importing ideas from a variety of different theoretical backgrounds. Historically ud evolved out of a near relative of PATR-II (Shieber, 1984), and its origins are still apparent, not least in the notation. In the course of development, however, ud .has been enriched with ideas from many other sources, most notably from LFG (Bresnan, 1982) and HPSG (Sag and Pollard, 1987). Among the language features mentioned in the paper are - a wide range of data types, including lists, trees and user-restricted types, in addition to the normal feature structures comprehensive treatment of disjunction 1. Introduction. The development of ud arose out of the need to have available a full set of prototyping and development tools for a number of different research projects in computational linguistics, all involving extensive text coverage in - dynamic binding of pathname segments A particular article of faith which has been very influential in our work has been the conviction </context>
</contexts>
<marker>Sag, Pollard, 1987</marker>
<rawString>Sag I and C Pollard (1987). Head-Driven Phrase Structure Grammar: an Informal Synopsis. CSLI Report # CSLI-87-79.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S Shieber</author>
</authors>
<title>The design of a computer language for linguistic information&apos;.</title>
<date>1984</date>
<journal>Proceedings of Coling</journal>
<volume>84</volume>
<contexts>
<context position="1757" citStr="Shieber, 1984" startWordPosition="267" endWordPosition="268">cipally a demanding machine translation exercise and a substantial investigation into some practical applications of situation semantics (Johnson, Rosner and Rupp, forthcoming). The interaction between users and implementers has figured largely in the development of the system, and a major reason for the richness of its language and environment has been the pressure to accommodate the needs of a group of linguists working on three or four languages simultaneously and importing ideas from a variety of different theoretical backgrounds. Historically ud evolved out of a near relative of PATR-II (Shieber, 1984), and its origins are still apparent, not least in the notation. In the course of development, however, ud .has been enriched with ideas from many other sources, most notably from LFG (Bresnan, 1982) and HPSG (Sag and Pollard, 1987). Among the language features mentioned in the paper are - a wide range of data types, including lists, trees and user-restricted types, in addition to the normal feature structures comprehensive treatment of disjunction 1. Introduction. The development of ud arose out of the need to have available a full set of prototyping and development tools for a number of diff</context>
</contexts>
<marker>Shieber, 1984</marker>
<rawString>Shieber S (1984). &apos;The design of a computer language for linguistic information&apos;. Proceedings of Coling 84.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>