<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000034">
<title confidence="0.855974">
A MODEL FOR PREFERENCE
</title>
<author confidence="0.894031">
Dominique Petitpierre
</author>
<affiliation confidence="0.896939">
ISSCO
University of Geneva
</affiliation>
<address confidence="0.495304625">
54 route des Acacias
CH-1227 Geneva, Switzerland
Steven Krauwer
Louis des Tombe
Instituut voor Algemene Taalwetenschap
Rijksuniversiteit Utrecht
Trans 14
3512 JK Utrecht, The Netherlands
</address>
<author confidence="0.79633">
Doug Arnold
</author>
<affiliation confidence="0.9933995">
Centre for Cognitive Studies
University of Essex
</affiliation>
<bodyText confidence="0.5083112">
Colchester, C04 3SQ, England
Giovanni B. Varile
DG XIII, Batiment Jean Monnet
Commission of the European communities
P.O. Box 1907, Luxembourg, Luxembourg
</bodyText>
<sectionHeader confidence="0.923505" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.9971768">
In this paper we address the problem of
choosing the best solution(s) from a set
of interpretations of the same object (in
our case a segment of text). A notion of
preference is stated, based on pairwise
comparisons of complete interpretations in
order to obtain a partial order among the
competing interpretations. An experimental
implementation is described, which uses
Prolog-like preference statements.
</bodyText>
<sectionHeader confidence="0.996957" genericHeader="introduction">
1. Introduction
</sectionHeader>
<bodyText confidence="0.9982948">
In this paper we address the problem of
choosing the best solution(s) from a set
of interpretations of the same text seg-
ment (For the sake of brevity, throughout
this text we use the term interpretation,
where in fact we should write representa-
tion of an interpretation). Although
developed in the context of a machine
translation system (the Eurotra project,
Arnold 1986, Arnold and des Tombe 1987),
we believe that our approach is suited to
many other fields of computational
linguistics and even outside (pattern
recognition, etc.).
After a brief overview of the problem
(section 2), we suggest a general method
to deal with preference (section 3) and
then describe a possible implementation
(section 4). An appendix gives actual
examples of preference statements.
</bodyText>
<sectionHeader confidence="0.839902" genericHeader="method">
2. What is preference?
</sectionHeader>
<bodyText confidence="0.9942175">
In the computational linguistics
literature, the term &apos;preference&apos; has been
used in different contexts. We shall men-
tion a few, selectively, (in section 2.1
which may be skipped) and then state our
own view (in section 2.2).
</bodyText>
<subsectionHeader confidence="0.963446">
2.1. Various approaches
</subsectionHeader>
<bodyText confidence="0.998906">
Preference strategies have often been
used for dealing with the problem of ill-
formed input (a particular case of robust-
ness, cf below section 2.2) (AJCL 1983,
Charniak 1983). Following Weischedel and
Sondheimer (1983) we distinguish the cases
</bodyText>
<page confidence="0.997612">
134
</page>
<bodyText confidence="0.999923343283582">
where preference is part of the particular
computation being performed (Wilks 1973,
Fass and Wilks 1983, Pereira 1985) from
the case where it is a separate process,
run after the results of the computation
have been obtained (Jensen et al 1983,
Weischedel and Sondheimer 1983).
A frequent approach to preference is
scoring. A numeric score is calculated,
independently, for each competing
interpretation and is then used to rank
the interpretations. The best interpreta-
tions are then chosen. The score can be
the number of constraints satisfied by the
interpretation (Wilks 1973, Fass &amp; Wilks
1983), where these constraints might be
assigned relative weights by the linguist
(Robinson 1982, Charniak 1983, Bennett and
Slocum 1985) or calculated by the computer
(Papegaaij 1986). Such techniques have
been used extensively for speech recogni-
tion (Paxton 1977, Walker et al 1978) and
in the field of expert systems (such as
Mycin, Buchanan &amp; Shortliffe 1984), where
the calculation of both score and ranking
become quite complex with probabilities
and thresholds.
The problem with scoring is that it
seems quite unnatural for a linguist to
associate a score (or weight or probabil-
ity) to a particular rule or piece of data
when the knowledge being encoded is in
fact qualitative. Furthermore, combining
the scores based on different types of
reasoning to calculate a global score for
a representation seems a rather arbitrary
procedure. Such a uniform metric, even if
it can model actual linguistic knowledge,
forces the grammar writer to juggle with
numbers to get the behaviour he wants,
thus making the preference process
obscure.
A further disadvantage of this approach is
that the score is often based on the way
interpretations are built, rather than on
the properties of the interpretations
themselves.
Preference is also mentioned in a
linguistic controversy started by Frazier
and Fodor (1979) with their principles of
right association and minimal attachment
(Schubert 1984). There the problem is to
disambiguate many readings (or interpreta-
tions) of a sentence in order to find the
good (preferred) one(s). Various contribu-
tions on that issue have in common that
bad interpretations are abandoned before
being finished, during computation
(Shieber 1983, Pereira 1985). Although
this method speeds up the computation,
there is a risk that a possiblity will be
abandoned too early, before the relevant
information has been found. This is shown
by Wilks et al (1985) who claim to have
the ideal solution in Preference Seman-
tics, which uses as part of its computa-
tion scoring and ranking.
</bodyText>
<subsectionHeader confidence="0.997804">
2.2. Our notion of preference
</subsectionHeader>
<bodyText confidence="0.999767122807018">
Our approach, although stemming from
earlier work in the Eurotra project
(McNaught et al 1983, Johnson et al 1985),
is, we believe, new and original.
We make the following assumptions:
i the relation &apos;translation of&apos; between
texts as established by a machine
translation system has to be one to one
(1-1)?
ii There is apriori no formal or linguis-
tic guarantee that this will be the
case for the relation as a whole or for
the translation steps between inter-
mediate levels of representation. (An
attempt to formalize this can be found
in Krauwer and des Tombe 1984 or in
section 4 of Johnson et al 1985).
The problem we want to address here is the
following:
Given the fact that one to many (1-n)
translations do occur, how do we ensure
that the final result is still 1-1.
This problem is not restricted to machine
translation:
Often a program (for example a parser or a
text generator) produces many interpreta-
tions of the same object (usually a text
segment) when in the ideal case only one
is wanted. In the following we refer to a
&apos;1-n translation&apos; for this general
phenomenon.
We see two types of solutions to this
problem, each of them applicable to
specific classes of cases:
i Spurious results can be eliminated on
the basis of their own individual pro-
perties (e.g. well-formedness, com-
pleteness); for this we will use the
term &apos;filtering&apos;.
ii Spurious results can be eliminated via
comparison of competing representa-
tions, where only the best one(s) will
have the right to survive; for this we
will use the term &apos;preference&apos;.
It is important to note that we res-
trict ourselves to reducing 1-n transla-
tions to (ideally) 1-1. We will assume
that the &apos;good&apos; translation is one of the
candidates. The problem of forcing the
system to come up with at least 1 transla-
tion (i.e. do something about possible 1-0
cases) will not be addressed here. In
order to avoid confusion we will use the
term &apos;robustness&apos; to refer to this type of
problem. We are aware of the fact that we
deviate slightly from the standard use of
the term preference.
</bodyText>
<page confidence="0.994284">
135
</page>
<bodyText confidence="0.999864632653061">
There are two main types of 1-n -ness:
i linguistically motivated (i.e. real
ambiguity in analysis, or true synonymy
in generation).
ii accidental, caused by overgeneration of
the descriptive devices that define the
resulting (or intermediate) interpreta-
tions.
Note that overgeneration and ambiguity or
synonymy may hide cases of undergeneration
(et the robustness problem).
We define the application of preference
as the selection of the best element(s)
from a set of competing interpretations of
the same object.
According to this definition the scor-
ing and ranking mechanism described in the
previous section is a case of preference.
In the rest of this paper we will
describe a preference device that is dif-
ferent from the scoring and ranking
mechanism in the sense that it is not
based on the way interpretations are
built, but rather on linguistic properties
of the objects themselves. Its main
characteristics are that:
i it applies to complete and sound (well
formed) interpretations only. That is,
all the other modules of construction,
transformation and filtering have been
applied (Ex: parsing, Wh-movement,
etc). Thus, for these modules all com-
peting representations are equivalent,
and all the information needed for com-
paring them has been found.
ii it is based on pairwise comparison
between alternative (competing)
interpretations of the same object.
The problem can then be stated as fol-
lows:
How do we make use of the linguistic
knowledge in order to insure a 1-1 trans-
lation?
It is our basic belief that it is impossi-
ble for the linguist to know the exact
nature of a class of competing interpreta-
tions in advance. This implies that he
cannot in general formulate one single
rule that picks out the best one.
</bodyText>
<subsectionHeader confidence="0.784525">
3. The proposed method
3.1. Basic idea
</subsectionHeader>
<bodyText confidence="0.999057294117647">
Our proposal is the following:
It should be possible to make
(linguistic) statements of the type: if
representation A has property X, and B
property Y, then A is to be preferred over
B (e.g. &apos;in law texts declarative sen-
tences are better than questions&apos;, or
&apos;sentences with a main verb are better
than sentences without one&apos;).
- On the basis of a set of such statements
it should be possible to establish a par-
tial order over the set of competing
representations.
- And in that case the number of candi-
dates can be reduced by, for example, let-
ting only the maximal elements survive, or
discarding the minimal ones.
</bodyText>
<subsectionHeader confidence="0.998237">
3.2. Problems with the method
</subsectionHeader>
<bodyText confidence="0.999919738095238">
The first (but least serious) problem
is that it is not certain that linguists
will always be able to make such state-
ments (we will call them &apos;preference
statements&apos;) over pairs of representa-
tions. Experimentation is necessary.
The second one is more serious: it
would be highly unrealistic to expect that
the result of applying of the preference
statements will be a linear order, in fact
there is not even a guarantee that the
order will be partial. In general the out-
come will be a directed graph. There are
three ways of tackling this problem:
i The linguist should try to make the set
of preference statements homogeneous
and constrained, and should have con-
trol over the way in which they are
applied, so that he can avoid contrad-
ictory statements.
ii One tries to make a formal device that
checks whether contradictions can
occur.
iii One tries to compare pairs of competi-
tors in a specific order such that it
can be guaranteed that the result is
always a partial order.
At the moment (iii) is the most feasible,
(ii) the most ambitious, and (i) the most
desirable solution. Currently we envisage
a combination of (i) and (iii).
The third problem is that of the maxi-
mal elements. Ideally there would be just
one maximal element, i.e. the preferred
representation. This cannot be guaranteed
to be true.
The problems sketched here are by no
means trivial. That is why we want to
experiment with a first implementation of
this method, to identify the various
relevant parameters in the specific con-
text of Eurotra.
</bodyText>
<sectionHeader confidence="0.777045" genericHeader="method">
4. The proposed implementation
</sectionHeader>
<bodyText confidence="0.9774455">
The implementation proposed here is
described in very general terms, and can
</bodyText>
<page confidence="0.994448">
176
</page>
<bodyText confidence="0.9998755">
be adapted for a wide range of applica-
tions. We give in the appendix some com-
mented examples specific to our particular
context.
</bodyText>
<subsectionHeader confidence="0.997803">
4.1. Preference rules
</subsectionHeader>
<bodyText confidence="0.999894882352941">
Preference statements are expressed by
the user in the form of rules (preference
rules). There are three types of prefer-
ence rules: simple rules, predefined rules
and composite rules. A preference rule
applied to two representations of
interpretation tries to decide which one
is better than the other (preferred to the
other). It is not guaranteed that a rule
can always take a decision.
A simple preference rule is of the form
p = (Patternl &gt; Pattern2)
The name of the rule is p, and Patternl
and Pattern2 are current patterns. When
given two arguments (two representations
or subparts) A and B (written p(A,B)) the
system will try to match Patternl with A
and Pattern2 with B. If this succeeds then
A is better than B (or A is preferred to B
or A&gt;B). If it fails then the system will
try to match A with Pattern2 and B with
Patternl. If this succeeds then B is
better than A.
Predefined rules are provided for the
cases where simple rules cannot express
some useful basic preference statement.
For example, in our actual implementation
(cf appendix), two predefined rules say
that a tree structure with fewer (more)
branches than the other is to be preferred
to one with more (fewer) branches. This
cannot be expressed with the particular
language for patterns.
A composite preference rule is of the
</bodyText>
<equation confidence="0.83609225">
form
p = (Patternl,Pattern2)
=&gt; (pl($V,$W),
p2($X,$Y),
</equation>
<bodyText confidence="0.999524121212121">
Identifiers p, pl, p2, ... are rule names,
Patternl and Pattern2 are actual patterns,
and $V, $W, $X, $Y, ... are variable iden-
tifiers, that should also occur in Pat-
ternl ($V,$X) and Pattern2 ($W,$Y) where
they identify sub-parts of the interpreta-
tions. When given two arguments A and B,
the system tries to match A with Patternl
and B with Pattern2. If this succeeds, the
variables $V,$X,.. occurring in Patternl
and $W,$Y,... occurring in Pattern2 are
instantiated to sub-parts of A and B
respectively. Then the system tries each
preference rule of the list, with the
instantiated arguments, till one rule can
decide. In this case the relationship
holding between A and B is the same as
that holding between the sub-part of A and
the sub-part of B. If no rule of the list
can decide then preference is not decided.
If the initial match doesn&apos;t succeed, then
an attempt will be made to match A with
Pattern2 and B with Patternl. If this
succeeds the system tries the rules of the
list in the same way as above. Composite
preference rules allow recursion.
This formalism is very much inspired by
the programming language Prolog: a prefer-
ence rule is analogous to a three argument
predicate (two interpretations and the
resulting relationship), a simple rule to
an assertion, and a composite rule to a
clause with sub-goals.
</bodyText>
<subsectionHeader confidence="0.996982">
4.2. General algorithm
</subsectionHeader>
<bodyText confidence="0.99991772972973">
Initially, all competing objects are in
the set of non ordered objects N and the
set of ordered objects 0 is empty. Then,
the following is repeated until N is
empty: an object is removed from N and is
compared to each object of 0 (if any),
then it is added to 0.
This algorithm does not ensure that the
resulting directed graph of preference
relationships among the competing objects
has no cycle. Anyway, maximal (minimal)
elements can be defined in the following
way:
An object E is a maximal (minimal) ele-
ment if no competing object is better
(worse) than E.
Thus an object in a cycle of the graph
cannot be maximal (minimal).
To give the user control of how rules
are tried on the competing objects, only
one distinguished rule is applied to each
competing pair. In the general case it
should be a composite rule that just
passes its two arguments to the rules of
the list, thus ensuring that only these
rules are tried and in that order.
The pattern matching mechanism of com-
posite rules is quite powerful. (see also
the appendix): It allows some preferences
rule to be applied only to selected
objects (satisfying a precondition). It
also allows (recursive) exploration of
sub-parts of representations (a derivation
tree for example), in parallel or not.
Finally it enables the user to give prior-
ity to some preference rules over some
others.
</bodyText>
<subsectionHeader confidence="0.996957">
4.3. Problems with the implementation
</subsectionHeader>
<bodyText confidence="0.999313833333333">
Although we decided that this model is
good enough for preliminary experimenta-
tion, certain problems are already
apparent:
- The system takes arbitrary decisions in
the case of a contradiction, that is if
</bodyText>
<page confidence="0.995357">
137
</page>
<bodyText confidence="0.81873675">
some rule can be applied to a pair of
arguments in both orders (if p(A,B) and
p(B,A) are both possible). In particular a
preference decision should not be taken
between identical objects.
- Infinite recursion can occur with
site preference rules.
- Maximal (minimal) elements may not exist
in the resulting graph of preference rela-
tionships (for example if all elements are
in a cycle).
- Arbitrary decisions may be taken if the
patterns allow multiple matches: the
current model will stop with the first
match that produces a decision.
Currently it is the user&apos;s responsibil-
ity to avoid these problems by writing
&amp;quot;sensible&amp;quot; rules. In the next section we
sketch some possible solutions that are
considered for a future implementation.
</bodyText>
<sectionHeader confidence="0.948532" genericHeader="method">
5. Future directions
</sectionHeader>
<bodyText confidence="0.998511272727273">
The implementation of this preference
model has been written in Prolog. To
facilitate experimentation, a mechanism is
provided for tracing the preference rules
application to observe their behaviour.
The model described above is very flex-
ible. We are currently studying the imple-
mentation of variants of the basic com-
parison algorithm:
We are investigating algorithms that
would:
</bodyText>
<listItem confidence="0.951042909090909">
- reduce the number of comparisons, by
aiming at extracting only the maximal
(minimal) elements, without trying to
order all elements.
- calculate the transitive closure of the
directed graph, and then remove all con-
tradictory relationships, thereby removing
all cycles. This amounts to saying that
two interpretations are not comparable if
their comparison leads to contradictory
decisions.
</listItem>
<bodyText confidence="0.9646025">
- compare the competing interpretations
stepwise, that is all comparisons are per-
formed with the first rule in a list, then
only the pairs for which there is no deci-
sion yet are compared with the second
rule, and so on.
</bodyText>
<sectionHeader confidence="0.991474" genericHeader="evaluation">
ACKNOWLEDGEMENTS
</sectionHeader>
<bodyText confidence="0.99913575">
We would like to thank Paul Bennett,
Maghi King, Gertjan Van Noord, Mike Rosner
and Susan Warwick for their fruitful com-
ments and their support.
</bodyText>
<sectionHeader confidence="0.980314" genericHeader="conclusions">
APPENDIX
</sectionHeader>
<bodyText confidence="0.957362272727273">
In the current framework of EUROTRA
(Arnold and des Tombe 1987), representa-
tion of interpretations are derivation
trees, containing at each node a set of
attribute-value pairs. Here is a very
sketchy and intuitive description of the
syntax used in the patterns:
- The identifiers s, np, vp etc. are
values of the distinguished attribute
of the node (in these examples, the
syntactic category).
</bodyText>
<listItem confidence="0.8940358125">
- Curly brackets delimit a set of condi-
tions to be satisfied by a node. For
example (s,f=declarative) indicate the
required conditions on the node for the
distinguished attribute (should have
value s) and for an f attribute (should
have value declarative).
- $A, $B, etc. are variable identifiers.
- s.(np,vp] indicates a tree with root s
and two daughters np and vp.
- ? or (?) indicates an unspecified node.
- * indicates a list of unspecified
nodes.
- $A!Pattern indicates that the variable
$A is instantiated to the sub-tree that
matches Pattern
</listItem>
<bodyText confidence="0.958295">
- $more_branches (and $less_branches) is
a predefined preference rule that
prefer the argument that has more
(less) branches than the other.
- The first rule declared becomes the
distinguished rule applied to the com-
peting interpretations.
</bodyText>
<equation confidence="0.9497664">
Example 1
p0 = ($A!(?),$B!(?)
=&gt; (p1($A,S13),
p2($A,$B)),
pl = ((s,f=declarative)
&gt; (s,f=interrogative)),
p2 = (s.(np,v,$A!s,*],
s.[np,v,$B!s,*))
=&gt; (p1($A,$B),
p2($A,$B)) .
</equation>
<bodyText confidence="0.9689916875">
This set of preference rules will
explore, in parallel, two trees, from top
to bottom, always taking the &apos;s&apos; branch,
and prefer the tree in which it finds a
declarative sentence (opposed to an
interrogative),If one inverts the order of
pl and p2 in the distinguished composite
rule pc) the trees would be explored from
bottom to top.
Rule p0 just passes its arguments to pl or
p2.
Rule pl prefers a declarative s over an
interrogative s.
Rule p2 identifies the embedded s in each
argument and passes them to pl or p2.
Example 2
</bodyText>
<equation confidence="0.790771166666667">
p0 = (s.(np,vp.[*,$A!(?)]],
s.(np,vp.[*,$B!(?)]])
=&gt; (p1($A,$B),
p2($A,$B),
P3($A,$13)),
P1 = (nP.C*,PP] &gt; PP),
</equation>
<page confidence="0.708635">
138
</page>
<bodyText confidence="0.982122392857143">
p2 = (np.[*,$A!np] $B!pp)
=&gt; (p1($A4B),
p2($A,$B).
P3($A,$B)),
P3 = (nP-[*/$A1(?)],
np.[*,$B!(?)])
=&gt; (p1($A4B),
p2($A,$B),
p3($A,$B)).
Given two sentences, this set of rules
will prefer the one that has the pp
attached deeper in the structure than the
other (right attachment). This example is
restricted to explore only embedded nps.
For both arguments, rule p0 identifies the
last daughters of the vp of a sentence s,
and passes them to preference rules pl or
p2 or p3.
Rule pl will prefer a pp attached under an
np to a pp (which was attached higher in
the structure).
Rule p2 will be tried only if p1 was not
applicable. It is there for the case the
pp is imbedded deeper in the np.
Rule p3 is similar to rule p0, except that
it takes the last daughters of a np. It is
tried only if pl and p2 are not applica-
ble.
</bodyText>
<sectionHeader confidence="0.99967" genericHeader="references">
REFERENCES
</sectionHeader>
<reference confidence="0.998583422680412">
AJCL. 1983 Special issue on ill-formed
input. American journal of computa-
tional linguistics 9(3-4).
Arnold, Doug. 1986 Eurotra: A European
Perspective On Machine Translation.
Proceedings of the IEEE 74(7): 979-992.
Arnold, Doug and des Tombe, Louis. 1987
Basic Theory and Methodology in EURO-
TRA. In: Nirenburg, Sergei, Ed.,
Machine Translation. Cambridge Univer-
sity Press, Cambridge, England: 114-
135.
Bennett, Winfield S. and Slocum, Jonathan.
1985 The LRC machine Translation Sys-
tem. Computational linguistics 11(2-
3): 111-121.
Buchanan, Bruce G. and Shortliffe, Edward
H. 1984 Rule-joased Expert Systems.
Addison Wesley, Reading, Massachusetts.
Charniak, Eugene. 1983 A Parser With
Something for Everyone. In: King, Mar-
garet, Ed., Parsing Natural Language.
Academic Press, London, England: 117-
149.
Fass, Dan and Wilks, Yorick. 1983 Prefer-
ence Semantics, Ill-Formedness, and
Metaphor. American journal of computa-
tional linguistics 9(3-4): 178-187.
Frazier, Lyn and Fodor, Janet D. 1978 The
Sausage Machine: A New Two-Stage Pars-
ing Model. Cognition 6: 291-325.
Jensen, K.; Heidorn, G. E.; Miller, L. A.
and Ravin, Y. 1983 Parse Fitting and
Prose Fixing: Getting a Hold on Ill-
Formedness. American journal of compu-
tational linguistics 9(3-4): 147-160.
Johnson, Rod; King, Margaret and des
Tombe, Louis. 1985 EUROTRA: A Multil-
ingual System Under Development. Com-
putational linguistics 11(2-3): 155-
169.
Krauwer, Steven and des Tombe, Louis.
1984 Transfer in a Multilingual Machine
Translation System. In: Proceedings of
Coling84, Stanford, California: 464-
467.
Mc Naught, Jock; Arnold, Doug; Bennett,
Paul; Fass, Dan; Grover, Claire; Huang,
Xiuming; Johnson, Rod; Somers, Harry;
Whitelock, Pete and Wilks, Yorick 1983
Structure, Strategies and Taxonomy.
Eurotra contract report ETL-1, Commis-
sion of the European Communities, Lux-
embourg, Luxembourg.
Papegaaij, Bart; Sadler, Victor and Wit-
kam, Toon. 1986 Word Expert Semantics;
an Interlingual Knowledge Based Ap-
proach. Foris, Dordrecht, Holland.
Paxton, W.H. 1977 A Framework for Speech
Understanding. Ph.D. Dissertation,
Stanford University, Stanford, Califor-
nia.
Pereira, Fernando C. 1985 A New Charac-
terization of Attachment Preferences.
In: Dowty, David R.; Kartunnen, Lauri
and Zwicky, Arnold M., Eds., Natural
language parsing. Cambridge University
Press, Cambridge,. England: 307-319.
Robinson, Jane J. 1982 DIAGRAM: A Grammar
for Dialogues. Communications of the
AN 25(1): 27-47.
Schubert, Lenhart K. 1984 On Parsing
Preferences. In: Proceedings of COL-
ING84 Stanford, California: 247-250.
Shieber, Stuart. 1983 Sentence Disambi-
guation by a Shift-Reduce Parsing Tech-
nique. In: proceedings of IJCAI-83
Karlsruhe, West Germany: 699-703.
Walker, D.E., Ed., 1978 Understanding Spo-
ken Language. North Holland, New York,
New York.
Weischedel, Ralph M. and Sondheimer, Nor-
man K. 1983 Meta-rules as a Basis for
Processing Ill-Formed Input. American
journal of computational linguistics
9(3-4): 161-177.
Wilks, Yorick. 1973 An Artificial Intel-
ligence Approach to Machine Transla-
tion, In: Schank, Roger C. and Colby,
Mark Kenneth, Eds., Computer Models of
Thought and Language. W.H. Freeman and
Co, San Francisco, California: 114-151.
Wilks, Yorick; Huang, Xiuming and Fass
Dan. 1985 Syntax, Preference and Right
Attachment. MCCS-85-5, July 1985, Com-
puting Research Laboratory, New Mexico
State University.
</reference>
<page confidence="0.998858">
139
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.546966">
<title confidence="0.998886">A MODEL FOR PREFERENCE</title>
<author confidence="0.997956">Dominique Petitpierre</author>
<affiliation confidence="0.9863175">ISSCO University of Geneva</affiliation>
<address confidence="0.993865">54 route des Acacias CH-1227 Geneva, Switzerland</address>
<author confidence="0.922465">Steven Krauwer Louis des Tombe</author>
<affiliation confidence="0.8405495">Instituut voor Algemene Taalwetenschap Rijksuniversiteit Utrecht</affiliation>
<address confidence="0.9736855">Trans 14 3512 JK Utrecht, The Netherlands</address>
<author confidence="0.991007">Doug Arnold</author>
<affiliation confidence="0.999744">Centre for Cognitive Studies University of Essex</affiliation>
<address confidence="0.999507">Colchester, C04 3SQ, England</address>
<author confidence="0.9978425">Giovanni B Varile DG Batiment Jean Monnet</author>
<affiliation confidence="0.974598">Commission of the European communities</affiliation>
<address confidence="0.974144">P.O. Box 1907, Luxembourg, Luxembourg</address>
<abstract confidence="0.998069090909091">In this paper we address the problem of choosing the best solution(s) from a set of interpretations of the same object (in our case a segment of text). A notion of preference is stated, based on pairwise comparisons of complete interpretations in order to obtain a partial order among the competing interpretations. An experimental implementation is described, which uses Prolog-like preference statements.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>AJCL</author>
</authors>
<title>Special issue on ill-formed input.</title>
<date>1983</date>
<journal>American journal of computational linguistics</journal>
<pages>9--3</pages>
<contexts>
<context position="2104" citStr="AJCL 1983" startWordPosition="323" endWordPosition="324">e suggest a general method to deal with preference (section 3) and then describe a possible implementation (section 4). An appendix gives actual examples of preference statements. 2. What is preference? In the computational linguistics literature, the term &apos;preference&apos; has been used in different contexts. We shall mention a few, selectively, (in section 2.1 which may be skipped) and then state our own view (in section 2.2). 2.1. Various approaches Preference strategies have often been used for dealing with the problem of illformed input (a particular case of robustness, cf below section 2.2) (AJCL 1983, Charniak 1983). Following Weischedel and Sondheimer (1983) we distinguish the cases 134 where preference is part of the particular computation being performed (Wilks 1973, Fass and Wilks 1983, Pereira 1985) from the case where it is a separate process, run after the results of the computation have been obtained (Jensen et al 1983, Weischedel and Sondheimer 1983). A frequent approach to preference is scoring. A numeric score is calculated, independently, for each competing interpretation and is then used to rank the interpretations. The best interpretations are then chosen. The score can be t</context>
</contexts>
<marker>AJCL, 1983</marker>
<rawString>AJCL. 1983 Special issue on ill-formed input. American journal of computational linguistics 9(3-4).</rawString>
</citation>
<citation valid="true">
<authors>
<author>Doug Arnold</author>
</authors>
<title>Eurotra: A European Perspective On Machine Translation.</title>
<date>1986</date>
<journal>Proceedings of the IEEE</journal>
<volume>74</volume>
<issue>7</issue>
<pages>979--992</pages>
<contexts>
<context position="1278" citStr="Arnold 1986" startWordPosition="191" endWordPosition="192">d, based on pairwise comparisons of complete interpretations in order to obtain a partial order among the competing interpretations. An experimental implementation is described, which uses Prolog-like preference statements. 1. Introduction In this paper we address the problem of choosing the best solution(s) from a set of interpretations of the same text segment (For the sake of brevity, throughout this text we use the term interpretation, where in fact we should write representation of an interpretation). Although developed in the context of a machine translation system (the Eurotra project, Arnold 1986, Arnold and des Tombe 1987), we believe that our approach is suited to many other fields of computational linguistics and even outside (pattern recognition, etc.). After a brief overview of the problem (section 2), we suggest a general method to deal with preference (section 3) and then describe a possible implementation (section 4). An appendix gives actual examples of preference statements. 2. What is preference? In the computational linguistics literature, the term &apos;preference&apos; has been used in different contexts. We shall mention a few, selectively, (in section 2.1 which may be skipped) a</context>
</contexts>
<marker>Arnold, 1986</marker>
<rawString>Arnold, Doug. 1986 Eurotra: A European Perspective On Machine Translation. Proceedings of the IEEE 74(7): 979-992.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Doug Arnold</author>
<author>des Tombe</author>
<author>Louis</author>
</authors>
<title>Basic Theory and Methodology in EUROTRA. In: Nirenburg, Sergei, Ed., Machine Translation.</title>
<date>1987</date>
<pages>114--135</pages>
<publisher>Cambridge University Press,</publisher>
<location>Cambridge, England:</location>
<marker>Arnold, Tombe, Louis, 1987</marker>
<rawString>Arnold, Doug and des Tombe, Louis. 1987 Basic Theory and Methodology in EUROTRA. In: Nirenburg, Sergei, Ed., Machine Translation. Cambridge University Press, Cambridge, England: 114-135.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Winfield S Bennett</author>
<author>Jonathan Slocum</author>
</authors>
<date>1985</date>
<booktitle>The LRC machine Translation System. Computational linguistics 11(2-3):</booktitle>
<pages>111--121</pages>
<contexts>
<context position="2924" citStr="Bennett and Slocum 1985" startWordPosition="447" endWordPosition="450">ereira 1985) from the case where it is a separate process, run after the results of the computation have been obtained (Jensen et al 1983, Weischedel and Sondheimer 1983). A frequent approach to preference is scoring. A numeric score is calculated, independently, for each competing interpretation and is then used to rank the interpretations. The best interpretations are then chosen. The score can be the number of constraints satisfied by the interpretation (Wilks 1973, Fass &amp; Wilks 1983), where these constraints might be assigned relative weights by the linguist (Robinson 1982, Charniak 1983, Bennett and Slocum 1985) or calculated by the computer (Papegaaij 1986). Such techniques have been used extensively for speech recognition (Paxton 1977, Walker et al 1978) and in the field of expert systems (such as Mycin, Buchanan &amp; Shortliffe 1984), where the calculation of both score and ranking become quite complex with probabilities and thresholds. The problem with scoring is that it seems quite unnatural for a linguist to associate a score (or weight or probability) to a particular rule or piece of data when the knowledge being encoded is in fact qualitative. Furthermore, combining the scores based on different</context>
</contexts>
<marker>Bennett, Slocum, 1985</marker>
<rawString>Bennett, Winfield S. and Slocum, Jonathan. 1985 The LRC machine Translation System. Computational linguistics 11(2-3): 111-121.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Bruce G Buchanan</author>
<author>Edward H Shortliffe</author>
</authors>
<title>Rule-joased Expert Systems.</title>
<date>1984</date>
<publisher>Addison Wesley,</publisher>
<location>Reading, Massachusetts.</location>
<contexts>
<context position="3150" citStr="Buchanan &amp; Shortliffe 1984" startWordPosition="484" endWordPosition="487">eric score is calculated, independently, for each competing interpretation and is then used to rank the interpretations. The best interpretations are then chosen. The score can be the number of constraints satisfied by the interpretation (Wilks 1973, Fass &amp; Wilks 1983), where these constraints might be assigned relative weights by the linguist (Robinson 1982, Charniak 1983, Bennett and Slocum 1985) or calculated by the computer (Papegaaij 1986). Such techniques have been used extensively for speech recognition (Paxton 1977, Walker et al 1978) and in the field of expert systems (such as Mycin, Buchanan &amp; Shortliffe 1984), where the calculation of both score and ranking become quite complex with probabilities and thresholds. The problem with scoring is that it seems quite unnatural for a linguist to associate a score (or weight or probability) to a particular rule or piece of data when the knowledge being encoded is in fact qualitative. Furthermore, combining the scores based on different types of reasoning to calculate a global score for a representation seems a rather arbitrary procedure. Such a uniform metric, even if it can model actual linguistic knowledge, forces the grammar writer to juggle with numbers</context>
</contexts>
<marker>Buchanan, Shortliffe, 1984</marker>
<rawString>Buchanan, Bruce G. and Shortliffe, Edward H. 1984 Rule-joased Expert Systems. Addison Wesley, Reading, Massachusetts.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Eugene Charniak</author>
</authors>
<title>A Parser With Something for Everyone. In: King, Margaret, Ed., Parsing Natural Language.</title>
<date>1983</date>
<pages>117--149</pages>
<publisher>Academic Press,</publisher>
<location>London, England:</location>
<contexts>
<context position="2120" citStr="Charniak 1983" startWordPosition="325" endWordPosition="326"> general method to deal with preference (section 3) and then describe a possible implementation (section 4). An appendix gives actual examples of preference statements. 2. What is preference? In the computational linguistics literature, the term &apos;preference&apos; has been used in different contexts. We shall mention a few, selectively, (in section 2.1 which may be skipped) and then state our own view (in section 2.2). 2.1. Various approaches Preference strategies have often been used for dealing with the problem of illformed input (a particular case of robustness, cf below section 2.2) (AJCL 1983, Charniak 1983). Following Weischedel and Sondheimer (1983) we distinguish the cases 134 where preference is part of the particular computation being performed (Wilks 1973, Fass and Wilks 1983, Pereira 1985) from the case where it is a separate process, run after the results of the computation have been obtained (Jensen et al 1983, Weischedel and Sondheimer 1983). A frequent approach to preference is scoring. A numeric score is calculated, independently, for each competing interpretation and is then used to rank the interpretations. The best interpretations are then chosen. The score can be the number of con</context>
</contexts>
<marker>Charniak, 1983</marker>
<rawString>Charniak, Eugene. 1983 A Parser With Something for Everyone. In: King, Margaret, Ed., Parsing Natural Language. Academic Press, London, England: 117-149.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Dan Fass</author>
<author>Yorick Wilks</author>
</authors>
<title>Preference Semantics, Ill-Formedness, and Metaphor. American journal of computational linguistics</title>
<date>1983</date>
<pages>9--3</pages>
<contexts>
<context position="2297" citStr="Fass and Wilks 1983" startWordPosition="349" endWordPosition="352">What is preference? In the computational linguistics literature, the term &apos;preference&apos; has been used in different contexts. We shall mention a few, selectively, (in section 2.1 which may be skipped) and then state our own view (in section 2.2). 2.1. Various approaches Preference strategies have often been used for dealing with the problem of illformed input (a particular case of robustness, cf below section 2.2) (AJCL 1983, Charniak 1983). Following Weischedel and Sondheimer (1983) we distinguish the cases 134 where preference is part of the particular computation being performed (Wilks 1973, Fass and Wilks 1983, Pereira 1985) from the case where it is a separate process, run after the results of the computation have been obtained (Jensen et al 1983, Weischedel and Sondheimer 1983). A frequent approach to preference is scoring. A numeric score is calculated, independently, for each competing interpretation and is then used to rank the interpretations. The best interpretations are then chosen. The score can be the number of constraints satisfied by the interpretation (Wilks 1973, Fass &amp; Wilks 1983), where these constraints might be assigned relative weights by the linguist (Robinson 1982, Charniak 198</context>
<context position="2792" citStr="Fass &amp; Wilks 1983" startWordPosition="428" endWordPosition="431">guish the cases 134 where preference is part of the particular computation being performed (Wilks 1973, Fass and Wilks 1983, Pereira 1985) from the case where it is a separate process, run after the results of the computation have been obtained (Jensen et al 1983, Weischedel and Sondheimer 1983). A frequent approach to preference is scoring. A numeric score is calculated, independently, for each competing interpretation and is then used to rank the interpretations. The best interpretations are then chosen. The score can be the number of constraints satisfied by the interpretation (Wilks 1973, Fass &amp; Wilks 1983), where these constraints might be assigned relative weights by the linguist (Robinson 1982, Charniak 1983, Bennett and Slocum 1985) or calculated by the computer (Papegaaij 1986). Such techniques have been used extensively for speech recognition (Paxton 1977, Walker et al 1978) and in the field of expert systems (such as Mycin, Buchanan &amp; Shortliffe 1984), where the calculation of both score and ranking become quite complex with probabilities and thresholds. The problem with scoring is that it seems quite unnatural for a linguist to associate a score (or weight or probability) to a particular</context>
</contexts>
<marker>Fass, Wilks, 1983</marker>
<rawString>Fass, Dan and Wilks, Yorick. 1983 Preference Semantics, Ill-Formedness, and Metaphor. American journal of computational linguistics 9(3-4): 178-187.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Lyn Frazier</author>
<author>Janet D Fodor</author>
</authors>
<title>The Sausage Machine: A New Two-Stage Parsing Model.</title>
<date>1978</date>
<journal>Cognition</journal>
<volume>6</volume>
<pages>291--325</pages>
<marker>Frazier, Fodor, 1978</marker>
<rawString>Frazier, Lyn and Fodor, Janet D. 1978 The Sausage Machine: A New Two-Stage Parsing Model. Cognition 6: 291-325.</rawString>
</citation>
<citation valid="true">
<authors>
<author>K Jensen</author>
<author>G E Heidorn</author>
<author>L A Miller</author>
<author>Y Ravin</author>
</authors>
<title>Parse Fitting and Prose Fixing: Getting a Hold on IllFormedness. American journal of computational linguistics</title>
<date>1983</date>
<pages>9--3</pages>
<contexts>
<context position="2437" citStr="Jensen et al 1983" startWordPosition="374" endWordPosition="377"> few, selectively, (in section 2.1 which may be skipped) and then state our own view (in section 2.2). 2.1. Various approaches Preference strategies have often been used for dealing with the problem of illformed input (a particular case of robustness, cf below section 2.2) (AJCL 1983, Charniak 1983). Following Weischedel and Sondheimer (1983) we distinguish the cases 134 where preference is part of the particular computation being performed (Wilks 1973, Fass and Wilks 1983, Pereira 1985) from the case where it is a separate process, run after the results of the computation have been obtained (Jensen et al 1983, Weischedel and Sondheimer 1983). A frequent approach to preference is scoring. A numeric score is calculated, independently, for each competing interpretation and is then used to rank the interpretations. The best interpretations are then chosen. The score can be the number of constraints satisfied by the interpretation (Wilks 1973, Fass &amp; Wilks 1983), where these constraints might be assigned relative weights by the linguist (Robinson 1982, Charniak 1983, Bennett and Slocum 1985) or calculated by the computer (Papegaaij 1986). Such techniques have been used extensively for speech recognitio</context>
</contexts>
<marker>Jensen, Heidorn, Miller, Ravin, 1983</marker>
<rawString>Jensen, K.; Heidorn, G. E.; Miller, L. A. and Ravin, Y. 1983 Parse Fitting and Prose Fixing: Getting a Hold on IllFormedness. American journal of computational linguistics 9(3-4): 147-160.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Rod Johnson</author>
<author>Margaret King</author>
<author>des Tombe</author>
<author>Louis</author>
</authors>
<date>1985</date>
<booktitle>EUROTRA: A Multilingual System Under Development. Computational linguistics</booktitle>
<pages>11--2</pages>
<contexts>
<context position="4932" citStr="Johnson et al 1985" startWordPosition="771" endWordPosition="774">ious contributions on that issue have in common that bad interpretations are abandoned before being finished, during computation (Shieber 1983, Pereira 1985). Although this method speeds up the computation, there is a risk that a possiblity will be abandoned too early, before the relevant information has been found. This is shown by Wilks et al (1985) who claim to have the ideal solution in Preference Semantics, which uses as part of its computation scoring and ranking. 2.2. Our notion of preference Our approach, although stemming from earlier work in the Eurotra project (McNaught et al 1983, Johnson et al 1985), is, we believe, new and original. We make the following assumptions: i the relation &apos;translation of&apos; between texts as established by a machine translation system has to be one to one (1-1)? ii There is apriori no formal or linguistic guarantee that this will be the case for the relation as a whole or for the translation steps between intermediate levels of representation. (An attempt to formalize this can be found in Krauwer and des Tombe 1984 or in section 4 of Johnson et al 1985). The problem we want to address here is the following: Given the fact that one to many (1-n) translations do oc</context>
</contexts>
<marker>Johnson, King, Tombe, Louis, 1985</marker>
<rawString>Johnson, Rod; King, Margaret and des Tombe, Louis. 1985 EUROTRA: A Multilingual System Under Development. Computational linguistics 11(2-3): 155-169.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Steven Krauwer</author>
<author>des Tombe</author>
<author>Louis</author>
</authors>
<title>Transfer in a Multilingual Machine Translation System. In:</title>
<date>1984</date>
<booktitle>Proceedings of Coling84,</booktitle>
<pages>464--467</pages>
<location>Stanford, California:</location>
<marker>Krauwer, Tombe, Louis, 1984</marker>
<rawString>Krauwer, Steven and des Tombe, Louis. 1984 Transfer in a Multilingual Machine Translation System. In: Proceedings of Coling84, Stanford, California: 464-467.</rawString>
</citation>
<citation valid="false">
<authors>
<author>Mc Naught</author>
<author>Arnold Jock</author>
<author>Bennett Doug</author>
</authors>
<location>Paul; Fass, Dan; Grover, Claire; Huang, Xiuming; Johnson, Rod; Somers, Harry;</location>
<marker>Naught, Jock, Doug, </marker>
<rawString>Mc Naught, Jock; Arnold, Doug; Bennett, Paul; Fass, Dan; Grover, Claire; Huang, Xiuming; Johnson, Rod; Somers, Harry;</rawString>
</citation>
<citation valid="true">
<authors>
<author>Pete Whitelock</author>
<author>Wilks</author>
</authors>
<date>1983</date>
<booktitle>Structure, Strategies and Taxonomy. Eurotra contract report ETL-1, Commission of the European Communities,</booktitle>
<location>Yorick</location>
<marker>Whitelock, Wilks, 1983</marker>
<rawString>Whitelock, Pete and Wilks, Yorick 1983 Structure, Strategies and Taxonomy. Eurotra contract report ETL-1, Commission of the European Communities, Luxembourg, Luxembourg.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Bart Papegaaij</author>
<author>Victor Sadler</author>
<author>Toon Witkam</author>
</authors>
<title>Word Expert Semantics; an Interlingual Knowledge Based Approach. Foris,</title>
<date>1986</date>
<location>Dordrecht, Holland.</location>
<marker>Papegaaij, Sadler, Witkam, 1986</marker>
<rawString>Papegaaij, Bart; Sadler, Victor and Witkam, Toon. 1986 Word Expert Semantics; an Interlingual Knowledge Based Approach. Foris, Dordrecht, Holland.</rawString>
</citation>
<citation valid="true">
<authors>
<author>W H Paxton</author>
</authors>
<title>A Framework for Speech Understanding.</title>
<date>1977</date>
<institution>Ph.D. Dissertation, Stanford University,</institution>
<location>Stanford, California.</location>
<contexts>
<context position="3051" citStr="Paxton 1977" startWordPosition="468" endWordPosition="469">eischedel and Sondheimer 1983). A frequent approach to preference is scoring. A numeric score is calculated, independently, for each competing interpretation and is then used to rank the interpretations. The best interpretations are then chosen. The score can be the number of constraints satisfied by the interpretation (Wilks 1973, Fass &amp; Wilks 1983), where these constraints might be assigned relative weights by the linguist (Robinson 1982, Charniak 1983, Bennett and Slocum 1985) or calculated by the computer (Papegaaij 1986). Such techniques have been used extensively for speech recognition (Paxton 1977, Walker et al 1978) and in the field of expert systems (such as Mycin, Buchanan &amp; Shortliffe 1984), where the calculation of both score and ranking become quite complex with probabilities and thresholds. The problem with scoring is that it seems quite unnatural for a linguist to associate a score (or weight or probability) to a particular rule or piece of data when the knowledge being encoded is in fact qualitative. Furthermore, combining the scores based on different types of reasoning to calculate a global score for a representation seems a rather arbitrary procedure. Such a uniform metric,</context>
</contexts>
<marker>Paxton, 1977</marker>
<rawString>Paxton, W.H. 1977 A Framework for Speech Understanding. Ph.D. Dissertation, Stanford University, Stanford, California.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Fernando C Pereira</author>
</authors>
<title>A New Characterization of Attachment Preferences.</title>
<date>1985</date>
<pages>307--319</pages>
<publisher>Cambridge University Press,</publisher>
<location>In: Dowty, David</location>
<contexts>
<context position="2312" citStr="Pereira 1985" startWordPosition="353" endWordPosition="354">n the computational linguistics literature, the term &apos;preference&apos; has been used in different contexts. We shall mention a few, selectively, (in section 2.1 which may be skipped) and then state our own view (in section 2.2). 2.1. Various approaches Preference strategies have often been used for dealing with the problem of illformed input (a particular case of robustness, cf below section 2.2) (AJCL 1983, Charniak 1983). Following Weischedel and Sondheimer (1983) we distinguish the cases 134 where preference is part of the particular computation being performed (Wilks 1973, Fass and Wilks 1983, Pereira 1985) from the case where it is a separate process, run after the results of the computation have been obtained (Jensen et al 1983, Weischedel and Sondheimer 1983). A frequent approach to preference is scoring. A numeric score is calculated, independently, for each competing interpretation and is then used to rank the interpretations. The best interpretations are then chosen. The score can be the number of constraints satisfied by the interpretation (Wilks 1973, Fass &amp; Wilks 1983), where these constraints might be assigned relative weights by the linguist (Robinson 1982, Charniak 1983, Bennett and </context>
<context position="4470" citStr="Pereira 1985" startWordPosition="693" endWordPosition="694">approach is that the score is often based on the way interpretations are built, rather than on the properties of the interpretations themselves. Preference is also mentioned in a linguistic controversy started by Frazier and Fodor (1979) with their principles of right association and minimal attachment (Schubert 1984). There the problem is to disambiguate many readings (or interpretations) of a sentence in order to find the good (preferred) one(s). Various contributions on that issue have in common that bad interpretations are abandoned before being finished, during computation (Shieber 1983, Pereira 1985). Although this method speeds up the computation, there is a risk that a possiblity will be abandoned too early, before the relevant information has been found. This is shown by Wilks et al (1985) who claim to have the ideal solution in Preference Semantics, which uses as part of its computation scoring and ranking. 2.2. Our notion of preference Our approach, although stemming from earlier work in the Eurotra project (McNaught et al 1983, Johnson et al 1985), is, we believe, new and original. We make the following assumptions: i the relation &apos;translation of&apos; between texts as established by a m</context>
</contexts>
<marker>Pereira, 1985</marker>
<rawString>Pereira, Fernando C. 1985 A New Characterization of Attachment Preferences. In: Dowty, David R.; Kartunnen, Lauri and Zwicky, Arnold M., Eds., Natural language parsing. Cambridge University Press, Cambridge,. England: 307-319.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jane J Robinson</author>
</authors>
<title>DIAGRAM: A Grammar for Dialogues.</title>
<date>1982</date>
<journal>Communications of the AN</journal>
<volume>25</volume>
<issue>1</issue>
<pages>27--47</pages>
<contexts>
<context position="2883" citStr="Robinson 1982" startWordPosition="443" endWordPosition="444">s 1973, Fass and Wilks 1983, Pereira 1985) from the case where it is a separate process, run after the results of the computation have been obtained (Jensen et al 1983, Weischedel and Sondheimer 1983). A frequent approach to preference is scoring. A numeric score is calculated, independently, for each competing interpretation and is then used to rank the interpretations. The best interpretations are then chosen. The score can be the number of constraints satisfied by the interpretation (Wilks 1973, Fass &amp; Wilks 1983), where these constraints might be assigned relative weights by the linguist (Robinson 1982, Charniak 1983, Bennett and Slocum 1985) or calculated by the computer (Papegaaij 1986). Such techniques have been used extensively for speech recognition (Paxton 1977, Walker et al 1978) and in the field of expert systems (such as Mycin, Buchanan &amp; Shortliffe 1984), where the calculation of both score and ranking become quite complex with probabilities and thresholds. The problem with scoring is that it seems quite unnatural for a linguist to associate a score (or weight or probability) to a particular rule or piece of data when the knowledge being encoded is in fact qualitative. Furthermore</context>
</contexts>
<marker>Robinson, 1982</marker>
<rawString>Robinson, Jane J. 1982 DIAGRAM: A Grammar for Dialogues. Communications of the AN 25(1): 27-47.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Lenhart K Schubert</author>
</authors>
<title>On Parsing Preferences. In:</title>
<date>1984</date>
<booktitle>Proceedings of COLING84</booktitle>
<pages>247--250</pages>
<location>Stanford, California:</location>
<contexts>
<context position="4176" citStr="Schubert 1984" startWordPosition="648" endWordPosition="649">bal score for a representation seems a rather arbitrary procedure. Such a uniform metric, even if it can model actual linguistic knowledge, forces the grammar writer to juggle with numbers to get the behaviour he wants, thus making the preference process obscure. A further disadvantage of this approach is that the score is often based on the way interpretations are built, rather than on the properties of the interpretations themselves. Preference is also mentioned in a linguistic controversy started by Frazier and Fodor (1979) with their principles of right association and minimal attachment (Schubert 1984). There the problem is to disambiguate many readings (or interpretations) of a sentence in order to find the good (preferred) one(s). Various contributions on that issue have in common that bad interpretations are abandoned before being finished, during computation (Shieber 1983, Pereira 1985). Although this method speeds up the computation, there is a risk that a possiblity will be abandoned too early, before the relevant information has been found. This is shown by Wilks et al (1985) who claim to have the ideal solution in Preference Semantics, which uses as part of its computation scoring a</context>
</contexts>
<marker>Schubert, 1984</marker>
<rawString>Schubert, Lenhart K. 1984 On Parsing Preferences. In: Proceedings of COLING84 Stanford, California: 247-250.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Stuart Shieber</author>
</authors>
<title>Sentence Disambiguation by a Shift-Reduce Parsing Technique. In:</title>
<date>1983</date>
<booktitle>proceedings of IJCAI-83</booktitle>
<pages>699--703</pages>
<location>Karlsruhe, West Germany:</location>
<contexts>
<context position="4455" citStr="Shieber 1983" startWordPosition="691" endWordPosition="692">ntage of this approach is that the score is often based on the way interpretations are built, rather than on the properties of the interpretations themselves. Preference is also mentioned in a linguistic controversy started by Frazier and Fodor (1979) with their principles of right association and minimal attachment (Schubert 1984). There the problem is to disambiguate many readings (or interpretations) of a sentence in order to find the good (preferred) one(s). Various contributions on that issue have in common that bad interpretations are abandoned before being finished, during computation (Shieber 1983, Pereira 1985). Although this method speeds up the computation, there is a risk that a possiblity will be abandoned too early, before the relevant information has been found. This is shown by Wilks et al (1985) who claim to have the ideal solution in Preference Semantics, which uses as part of its computation scoring and ranking. 2.2. Our notion of preference Our approach, although stemming from earlier work in the Eurotra project (McNaught et al 1983, Johnson et al 1985), is, we believe, new and original. We make the following assumptions: i the relation &apos;translation of&apos; between texts as est</context>
</contexts>
<marker>Shieber, 1983</marker>
<rawString>Shieber, Stuart. 1983 Sentence Disambiguation by a Shift-Reduce Parsing Technique. In: proceedings of IJCAI-83 Karlsruhe, West Germany: 699-703.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D E Walker</author>
<author>Ed</author>
</authors>
<title>Understanding Spoken Language.</title>
<date>1978</date>
<publisher>North Holland,</publisher>
<location>New York, New York.</location>
<marker>Walker, Ed, 1978</marker>
<rawString>Walker, D.E., Ed., 1978 Understanding Spoken Language. North Holland, New York, New York.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ralph M Weischedel</author>
<author>Norman K Sondheimer</author>
</authors>
<title>Meta-rules as a Basis for Processing Ill-Formed Input. American journal of computational linguistics</title>
<date>1983</date>
<pages>9--3</pages>
<contexts>
<context position="2164" citStr="Weischedel and Sondheimer (1983)" startWordPosition="328" endWordPosition="331">th preference (section 3) and then describe a possible implementation (section 4). An appendix gives actual examples of preference statements. 2. What is preference? In the computational linguistics literature, the term &apos;preference&apos; has been used in different contexts. We shall mention a few, selectively, (in section 2.1 which may be skipped) and then state our own view (in section 2.2). 2.1. Various approaches Preference strategies have often been used for dealing with the problem of illformed input (a particular case of robustness, cf below section 2.2) (AJCL 1983, Charniak 1983). Following Weischedel and Sondheimer (1983) we distinguish the cases 134 where preference is part of the particular computation being performed (Wilks 1973, Fass and Wilks 1983, Pereira 1985) from the case where it is a separate process, run after the results of the computation have been obtained (Jensen et al 1983, Weischedel and Sondheimer 1983). A frequent approach to preference is scoring. A numeric score is calculated, independently, for each competing interpretation and is then used to rank the interpretations. The best interpretations are then chosen. The score can be the number of constraints satisfied by the interpretation (Wi</context>
</contexts>
<marker>Weischedel, Sondheimer, 1983</marker>
<rawString>Weischedel, Ralph M. and Sondheimer, Norman K. 1983 Meta-rules as a Basis for Processing Ill-Formed Input. American journal of computational linguistics 9(3-4): 161-177.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Yorick Wilks</author>
</authors>
<title>An Artificial Intelligence Approach to Machine Translation, In: Schank, Roger C. and Colby,</title>
<date>1973</date>
<contexts>
<context position="2276" citStr="Wilks 1973" startWordPosition="347" endWordPosition="348">tements. 2. What is preference? In the computational linguistics literature, the term &apos;preference&apos; has been used in different contexts. We shall mention a few, selectively, (in section 2.1 which may be skipped) and then state our own view (in section 2.2). 2.1. Various approaches Preference strategies have often been used for dealing with the problem of illformed input (a particular case of robustness, cf below section 2.2) (AJCL 1983, Charniak 1983). Following Weischedel and Sondheimer (1983) we distinguish the cases 134 where preference is part of the particular computation being performed (Wilks 1973, Fass and Wilks 1983, Pereira 1985) from the case where it is a separate process, run after the results of the computation have been obtained (Jensen et al 1983, Weischedel and Sondheimer 1983). A frequent approach to preference is scoring. A numeric score is calculated, independently, for each competing interpretation and is then used to rank the interpretations. The best interpretations are then chosen. The score can be the number of constraints satisfied by the interpretation (Wilks 1973, Fass &amp; Wilks 1983), where these constraints might be assigned relative weights by the linguist (Robins</context>
</contexts>
<marker>Wilks, 1973</marker>
<rawString>Wilks, Yorick. 1973 An Artificial Intelligence Approach to Machine Translation, In: Schank, Roger C. and Colby,</rawString>
</citation>
<citation valid="false">
<authors>
<author>Mark Kenneth</author>
</authors>
<title>Eds., Computer Models of Thought</title>
<pages>114--151</pages>
<location>San Francisco, California:</location>
<marker>Kenneth, </marker>
<rawString>Mark Kenneth, Eds., Computer Models of Thought and Language. W.H. Freeman and Co, San Francisco, California: 114-151.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Yorick Wilks</author>
<author>Xiuming Huang</author>
<author>Fass Dan</author>
</authors>
<title>Syntax, Preference and Right Attachment.</title>
<date>1985</date>
<pages>85--5</pages>
<institution>Computing Research Laboratory, New Mexico State University.</institution>
<contexts>
<context position="4666" citStr="Wilks et al (1985)" startWordPosition="725" endWordPosition="728">ontroversy started by Frazier and Fodor (1979) with their principles of right association and minimal attachment (Schubert 1984). There the problem is to disambiguate many readings (or interpretations) of a sentence in order to find the good (preferred) one(s). Various contributions on that issue have in common that bad interpretations are abandoned before being finished, during computation (Shieber 1983, Pereira 1985). Although this method speeds up the computation, there is a risk that a possiblity will be abandoned too early, before the relevant information has been found. This is shown by Wilks et al (1985) who claim to have the ideal solution in Preference Semantics, which uses as part of its computation scoring and ranking. 2.2. Our notion of preference Our approach, although stemming from earlier work in the Eurotra project (McNaught et al 1983, Johnson et al 1985), is, we believe, new and original. We make the following assumptions: i the relation &apos;translation of&apos; between texts as established by a machine translation system has to be one to one (1-1)? ii There is apriori no formal or linguistic guarantee that this will be the case for the relation as a whole or for the translation steps betw</context>
</contexts>
<marker>Wilks, Huang, Dan, 1985</marker>
<rawString>Wilks, Yorick; Huang, Xiuming and Fass Dan. 1985 Syntax, Preference and Right Attachment. MCCS-85-5, July 1985, Computing Research Laboratory, New Mexico State University.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>