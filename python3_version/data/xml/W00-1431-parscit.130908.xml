<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000001">
<note confidence="0.7870632">
The. CLEF semi=Tecursive,generation- .algorithm
Rodrigo Reyes
Thomson-CSF/LCR
Talana, Univ. Paris 7
February 6111 ,2000
</note>
<sectionHeader confidence="0.903286" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.997606857142857">
-,We will discuss the-serni-recursive algorithm for
text generation, as defined for the GTAG
formalism, and its implementation in the CLEF
project. We will show how to use lexical choice
constraints and properties of the LTAG grammar
to minimize the backtracking of the semi-
recursive algorithm.
</bodyText>
<sectionHeader confidence="0.967728" genericHeader="introduction">
1 Introduction
</sectionHeader>
<bodyText confidence="0.9950408">
GTAG is a multilingual text generation
formalism derived from the Tree Adjoining
Grammar model ((Joshi and al.,1975), (Shabes
and Shieber,1994)). This formalism, which is still
evolving, uses slightly enriched TAG grammars
as its syntactic back-end.
GTAG only deals with the « How to say it ?»
aspect of the generation process. It takes as input
a partly computed symbolic representation of the
discourse, and defines the processing and the data
necessary to produce the final text.GTAG is
widely described in (Danlos, 1996), (Danlos,
1998), and (Danlos1999).
Flaubert was the first GTAG implementation,
conducted by Cora SA ((Meunier and Danlos,
1998), (Meunier 1997)). This implementation
validated the first versions of the formalism, and
yielded a stable version of GTAG. A new
implementation has been initiated by Thomson-
CSF LCR ((Meunier and Reyes, 1999), (Meunier,
1999)), using the Java language, with a strong
emphasis on research and applications.
We will give firstly a short insight of the GTAG
formalism, then introduce the semi-recursive
algorithm in comparison with the recursive
. approach. Then, we will give a presentation of
the CLEF generation algorithm that yields a
nearly-surfacic syntactic representation from the
conceptual representation (a post-processing
phase takes care of the final output).
</bodyText>
<sectionHeader confidence="0.802589" genericHeader="method">
2 Presentation of GTAG
</sectionHeader>
<bodyText confidence="0.997945125">
..The.GTAG formalism describes, the-domain
model used to specify the input of the generator,
as well as the linguistics data and processing
necessary to generate texts. GTAG uses a first-
order logic formalism for its domain model, and a
lexicalized TAG grammar as its syntactic model.
We introduce hereafter both sub-formalisms, and
the manner in which GTAG links them.
</bodyText>
<subsectionHeader confidence="0.654659">
2.1 Domain model
</subsectionHeader>
<bodyText confidence="0.989218888888889">
The Login (Logic and inheritance) formalism
((ATt-Kaci and Nasr, 1986), (Meunier, 1997)) has
been used to model the domain knowledge. It
takes type constraints into account, thus allowing
to validate, to a certain extent, the input
structures&apos; coherence.
GTAG specifies an additional constraint on the
model: the existence of three generic concepts
used to divide the conceptual domain, as follows.
</bodyText>
<listItem confidence="0.907335857142857">
O Entities, representing objects (individuals) of
the world.
O 1st-order relations, representing simple
events, between entities, or between entities
and relations.
• 2&amp;quot;d-order relations, representing relations
between relations.
</listItem>
<figure confidence="0.50630125">
9JXES
Rel ions Entities
ls&apos;-order 2&amp;quot;-order
relations relations
</figure>
<figureCaption confidence="0.999136">
Figure 1. A typical Model for the domain.
</figureCaption>
<bodyText confidence="0.999947">
Thus, a typical model will have the following
form, as shown in figure I.
</bodyText>
<page confidence="0.994626">
231
</page>
<subsectionHeader confidence="0.981568">
2.2 The grammar
</subsectionHeader>
<bodyText confidence="0.901572">
The syntactic back-end is a Lexicalized Tree
Adjoining Grammar, which complies with the
Predicate-Argument Cooccurrence Principle
(AbeiIle, 1993), enriched with the following:
</bodyText>
<listItem confidence="0.883286">
• T-Features, that tag and identify the
</listItem>
<bodyText confidence="0.4227161">
differences between the syntactic structures
(namely the trees). Those atomic tags, such
.as T_CANONICAL, T PASSIVE,
T WITHOUT ARG1,
T WITHOUT ARG2, etc., are used as a
compositional selection mechanism of
syntactic structures. For instance, the
« passive without agent )4. structure is
determined by the following array of
features:
</bodyText>
<listItem confidence="0.810196590909091">
T CANONICAL+T PASSIVE+T WITHOU
T ARGI.
o Forms features, associated with each of the
grammar trees, indicating their textual level.
The possible values for the form features are
as follows :
• -T-P : for noun phrases.
• -T+P : fora single sentence.
fora text, i.e. various
sentences.
• +P : for either a single sentence or a
text.
a G-derivation structures, which correspond to
underspecified derivation trees. The nodes
. can be constant (each nodeis equivalent to an
elementary tree, as in standard derivation
trees), or variable. In the latter case, the node
can be associated with either a concept
attribute name, or with an instantiated
concept.
• Syntactic functions, which are encoded in the
grammar.
</listItem>
<subsectionHeader confidence="0.999559">
2.3 The sworn tic-conee ptua I interface
</subsectionHeader>
<bodyText confidence="0.998122764705882">
The semantic-conceptual interface is provided by
the lexical bases (LB), which relate each
instantiated concept from the generator input
structure with an array of g-derivation trees. This
interface associates arguments (from the
grammar) with concept attributes (from the
conceptual domain).
A lexical base must be able to give, at any time of
the process, a valid lexical choice. When it is
created, a lexical base refers to a g-derivation
tree, selected by default by the domain creator.
This lexical choice can be modified by
constraints introduced by the generation process.
The GTAG global generation strategy is to
modify the lexical base so that the lexical choices
be coherent (selected trees can be combined), and
that the text be as good as possible.
</bodyText>
<figureCaption confidence="0.996919">
Figure 2. The input structure associated to lexical bases
</figureCaption>
<bodyText confidence="0.519983">
The input structure
</bodyText>
<page confidence="0.948258">
232
</page>
<sectionHeader confidence="0.63693" genericHeader="method">
3 . The.generatioiralgarithm
</sectionHeader>
<bodyText confidence="0.997980736842105">
Tactical generation algorithms use various
strategies which are all input-dependent.
Moreover, defining the bounds between the &amp;quot;how
to say&amp;quot; and the &amp;quot;what to say&amp;quot; is still an open
question. RAGS (rags, 1999) proposes a standard
architecture for the data, but leaves the
processing details underspecified.
However two main approaches can- beltotioecl -
the recursive one and the deductive one. The
recursive approach is basically a depth-first
backtracking search (for example (Nicolov,
1998)), while the deductive one uses inference
mechanisms such as those used in expert systems
or specialized languages such as PROLOG
(Panaget, 1997). As deductive systems are often
used as opaque ways of resolving problems, we
will focus on the recursive algorithm, that can
easily be used as a base for the customizing of
algorithms.
</bodyText>
<subsectionHeader confidence="0.936382">
3.1 The input structure
</subsectionHeader>
<bodyText confidence="0.9989462">
The input of the CLEF generation system is a
hierarchical representation (i.e. a tree structure)
of the conceptual structure. Therefore, a crucial
choice is done before the proper linguistic
generation : selecting the theme and the rheme of
the utterancel.
The main advantage from a technical point of
view is the processing linearization : such a
structure is not ambiguous regarding to the
mapping between the elements of the input
structures and the elements of the grammar. The
input structure is therefore always considered as
a single tree, and the text generation algorithm is
basically a tree walk on this structure, with a
lexical choice processing for each node.
</bodyText>
<subsectionHeader confidence="0.999408">
3.2 Lexical choice constraints
</subsectionHeader>
<bodyText confidence="0.958763769230769">
The lexical choices made by the lexical bases are
modified by constraints that are related to
different aspects of the selection either on the T-
This choice is clearly arbitrary, because it is
equally relevant to the &amp;quot;what to say&amp;quot; and the
&amp;quot;how to say it-. Such a choice for CLEF was
mainly guided by technical considerations.
Feature, or on thelinear order of the elements, .or
on the realisation of the arguments, etc.
A list of constraints (initially empty) is associated
to each lexical base, and the generation process
adds new constraints while parsing the input
structure. There are two types of constraints
additions:
0 implicit constraints. Such constraints are
-added.by a_parent,LB that,addecLa oonstrAillt ,
due to its own internal lexical choice. For
example, the lexical selection of &amp;quot;Sl before
S2&amp;quot; (for a succession concept) imposes
grammatical constraints on the argument
&amp;quot;after&amp;quot; (related to S2) so that the selection of
the argument be grammatically compatible
(i.e. add a constraint that imposes the use of
an infinitive sentence).
0 explicit contraints. Those constraints are
added by stylistic rules that will carry on the
</bodyText>
<figure confidence="0.91646825">
RO
E2 RI
EliE12
_Alf°
</figure>
<figureCaption confidence="0.95800675">
Figure 3: RO and RI are two 2nd-order
relations. E2, Eli, and E12 are two 1st
orderrelation. E0 and El are two
global schemas.
</figureCaption>
<bodyText confidence="0.999925384615385">
lexical choice in order to avoid poor style, or
to prevent dead-ends in the generation
process. For example, the parallelism rule
(Meunier 97) should impose that two verbal
predicates use the same syntactic function for
an argument they have in common.
Every constraint addition is associated with a
position in the input structure walk, so that it can
be removed whenever the backtracking is used.
We will also discuss how the backtracking can be
partly avoided taking into account some
properties of the algorithm, and using a minimum
constraint propagation technique.
</bodyText>
<page confidence="0.992225">
233
</page>
<bodyText confidence="0.677855">
Combination +
stylistic tests
</bodyText>
<subsectionHeader confidence="0.980673">
3.3 The semi-recursive.algorithm
</subsectionHeader>
<bodyText confidence="0.982390366666667">
(Danlos, 1996) emphasizes on the problems tied
to the use of a recursive depth-first algorithm in
the area of text generation. More specifically she
discusses the impossibility of preventing poor
stylistic choices, even when they can be easily
predicted. In fact, the problem holds in that
stylistic or grammatical rules use information that
=are,computed laterimthegenesatioastage by the
recursive algorithm.
Thus, in the examples given by (Danlos, 1996)
(see figure 3), the two 2nd-order relation choices
are obviously linked to each other. Nevertheless,
the computation of the selection of R1 is not done
until other selections are done (at least E2, in this
example). In this way, if no lexical selection
satisfies the syntactic or stylistic constraints, the
generation process will backtrack on the whole
array of previous selections.
Some techniques can be used to
partially make up for the
problem, for example the
memoization ((Nicolov, 1998), 2&apos;d-order
(Becker, 1998)), but it does not relations LB
solve the problem. The fact is
that depth-first recursive
approaches are not adapted to
text generation, where lexical
choices must be done in a
global, holistic perspective
(Danlos, 1998) and (Busernann,
1993).
In this perspective, (Danlos,
1996) proposes a different
algorithm, called &amp;quot;semi-
recursive- algorithm, in that it
remedies to the main drawbacks
of the recursive algorithm. The
latter is caracterized by the
following features:
* The lexical choices of the
different levels of relations
are carried out in parallel.
The combinations of the trees and the
stylistic choices are carried out separately for
each level of concept. Thus, the consistency
of all the lexical choices for a particular level
is,ensuredrand.eachlevekofconcept is
considered globally.
e The compatibility tests between the
selections (i.e. the three levels of concepts)
are carried out. If the combination is valid, it
is accepted, otherwise some new selections
are done until the compatibility tests succeed.
..The.approach_of this,algorithnhis..particularly
relevant, as the consistency is not ensured merely
for the array of previous lexical choices (which is
not enough, as we discussed), but for the whole
set of lexical choices on the same level. This
provides a realistic implementation of the global
approach.
</bodyText>
<subsectionHeader confidence="0.704974">
3.4 The CLEF algorithm
</subsectionHeader>
<bodyText confidence="0.997543">
The CLEF algorithm is a variant of the semi-
recursive algorithm. In fact, the main idea of the
semi-recursive algorithm is the separated
</bodyText>
<equation confidence="0.98231175">
RO
RI E2
Eli E12
Q. E1 EO
</equation>
<bodyText confidence="0.89636925">
Lexical selection for
E12, and E2
processing of the different levels (entity, I &apos;-order
relations, 2nd-order relations).
One problem remains : although the context is
taken into account, it is only used in the same
level of concepts. Thus, both the 2nd-order
relations and the I &apos;`-order relations remain
</bodyText>
<figure confidence="0.91285475">
Lexical Sc ection for
RO and R1
Combination of I s&apos;-order relations LB and
2&apos;d-order relations LB
</figure>
<figureCaption confidence="0.997382">
Figure 4. The semi-recursive algorithm.
</figureCaption>
<figure confidence="0.991565">
I&apos;-order
relations LB
Compatibility tests
</figure>
<page confidence="0.996867">
234
</page>
<bodyText confidence="0.999929152777778">
independent from each other; and in case of
failure of the compatibility test, incompatible
selections must be computed again. This is due to
the fact that choices are carried out in parallel. In
order to solve this problem easily, computation
should be carried out sequentially and the
different levels should be computed in a
predefined order. In this case, the question
arises: in which order should the different
conceptual levels be computed?
Several evidences indicate that higher level
elements should be selected first, then the lower
levels (i.e. the 2&amp;quot;d-order relations first, then the
Ist-order relations, and then the entities). In fact,
on the rhetorical point of view, the higher level
elements (in GTAG, the rd-order relations)
determine the text argumentative structure, thus
providing stylistic consistency on the whole
generated text. Were they not selected first, they
would be constrained by the lexical choices of
the other types of concepts. In other words, they
would yield to constraints other than purely
stylistic, which is not suitable for elements which
first criterion of choice is, precisely, stylistics.
Moreover, it seems that in numerous cases, it is
preferable to select the simpler elements
according to more complex ones. This
corresponds to the approach developped by
(Rastier and al., 1994), that shows that an
element is only relevant in its surrounding
context. Such an approach is relevant in our
framework, since a particular lexical selection
can only be done with full knowledge of the facts
if its context is known. By context, we mean the
conceptual-semantic context (eg. a reference to
an entity that already exists in the discourse), the
lexical context (eg, some lexical selection that
has already been used for an entity), and the
syntactic- one (eg. a previous lexical selection -
imposes some syntactic constraint). Many
essential information, for example to decide
whether a noun phrase must be pronominalized or
not, whether a verb can be elided or not, are
available only if the surrounding context does
exist and is known.
,`principle:ofthelletermination ofthe_loeal ,
context by the global one&amp;quot; (called &amp;quot;hermeneutics
principle&amp;quot; in (Rastier and al., 1994)) can
therefore be applied only if the global context is
already computed, then the local one, according
to the global context. In order for the generation
process to be compliant with this principle,
elements should be computed in the following
order: 2&amp;quot;-order relations first, then 1st-order
relations, and then entities.
Proceeding otherwise would be inconsistent: it is
not possible to determine the lexical-syntactic
selection of an entity without knowing if it is
bound to a noun or a verb. The two possibilities
are not necessarily available for a given concept,
and carrying on without this piece of information
could be considered a last resort.
Besides surrounding context, the local context is
also necessary, as shows the perspective notion
which can be found in (Busemann, 1993), and
also supported by (Rastier and al., 1994). It is
therefore necessary to know the dependents (the
children in the input tree structure) in order to
make a lexical-syntactic choice.
These elements were crucial for the design of the
CLEF generation algorithm, which we will
described hereafter.
</bodyText>
<page confidence="0.994487">
235
</page>
<subsectionHeader confidence="0.760125">
3.4.1 Linearization of the algorithm
</subsectionHeader>
<bodyText confidence="0.997948">
The CLEF generation algorithm considers the
three conceptual levels one by one, carrying out
the lexical selection at first on the 2&amp;quot;1-order
relations, then on the 1&apos;E-order relations, and
finally on the entities.
</bodyText>
<sectionHeader confidence="0.70505525" genericHeader="method">
SUC SSION
MARY TART EAT SLEEP
ZN SL?
PETER TART PETER
</sectionHeader>
<bodyText confidence="0.907425625">
Flame 5 The 1 otiose
. « Mary_cooked.a..tam,. then _.... »),.7then
COOK will be computed before EAT and
SLEEP. On the contrary, if a tree anchoring
« SI after S2&gt;&gt; is used (like in « Peter ate the
tart and fell asleep after... »), EAT and
SLEEP will be computed first, then COOK.
This important property of the algorithm
</bodyText>
<figure confidence="0.4953845">
SUCCESq0N
MARY TART EAT SLEEP
ZN
PETER TART PETER
Flame 6. The 2.nd nhase
PETER TART PETER
</figure>
<figureCaption confidence="0.404282">
Eimire 7
</figureCaption>
<bodyText confidence="0.995645454545455">
The graph walk has the following properties:
o It is carried out in three phases, one for each
conceptual level.
o The walk is done depth-first, but following
the surfacic linear order of the elements.
Thus, the walk order for the 1&apos;c-order
elements depends on the lexical choices for
RO and RI (see fig.3) : if the lexicalized tree
selected for RI situates E2 before RI, then
E2 should be computed before Ell and E12.
The same way, for El l and E12, the order of
the processing will depend on the tree
selected by RI. On our example (fig. 5 to 7),
this means that the order of walk of the
second phase (regarding the l&apos;-order
relations) will depend on the lexical choices
took during the first phase. For instance, if
the SUCCESSION concept is lexical izcd
using a tree anchoring.« S1 then S2 » (like in
The 1rd nhase
allows to make lexical choices according to
previous ones.
</bodyText>
<listItem confidence="0.834575">
• A stack is added, and allows the storage of
every lexical choice according to their linear
order. This stack stores the history of the
choices carried out, and thus allows to
backtrack when needed.
• During the tree walk, some constraints are
</listItem>
<bodyText confidence="0.999356272727273">
propagated towards the lower elements of the
tree. So, a lexical-syntactic selection of a
concept would be able to add constraints over
the lexical choices of.the lexical bases lower-
dependent. For example, such a concept
could select a particular Form feature, or a
particular set of T-Features, for one of its
dependent.
Unlike the semi-recursive algorithm, the global
context choice also carries out according to local
choices. The stylistic rules can not only use the
</bodyText>
<page confidence="0.992687">
236
</page>
<bodyText confidence="0.9989405">
information given by. the-concepts.ofThe same
level, but also the information given by the
dependent nodes, which allows the retrieval of
some predictable information. This information
is, of course, limited as the lexical-syntactic
choice of the dependent lexical bases if not
performed at this point.
For example, if E2 and E12 refers to the same
concept, some constraints could be computed as.
soon as the lexical selection for RO is done, and
added to the lexical bases of the dependent nodes
of RO, in particular RI.
</bodyText>
<subsectionHeader confidence="0.9272605">
3.4.2 Minimum constraint propagation:
controlling the backtracking
</subsectionHeader>
<bodyText confidence="0.999256394736842">
The backtrack, when the processing comes to an
impossibility for a lexical base to get a
satisfactory lexical choice, is not excluded,
although it is inherently limited by the nature of
the graph walk.
The handling of the backtracking can also take
advantage of both the walk mechanism and the
data structures used.
For example, if the algorithm fails to find a valid
choice for the E12 element (see figure 3), the
backtracking can be performed directly on R1, to
find an alternative choice compatible with all the
dependent nodes (that is Ell and RO, in our
example). If a modification is both available and
compatible with the related lexical bases, it will
be validated. For a lexical base, a modification is
considered compatible if it does not imply any
modification in the set of implicit constraints
added to the related lexical bases, except the
lexical base from which the processing
backtracks.
In our example, the backtracking process can ask
the LI3 for RI to find an alternative choice that
modifies the constraints on E12. without
modifying any other, that is letting the implicit
constraints for Ell et RO untouched. In other
words, it consists in adding a new constraint on
R1 that will imply the selection of a new lexical-
syntactic structure so that the implicit constraints
on Ell and RO remain identical, and so that the
implicit constraints on E12 impose a new,
compatible. choice.
The algorithm can therefore carry out a minimum
propagation of the constraints, without
necessarily doing a full backtracking. In that case,
. _ it_attempts.1o..find.thtbest eampromise with..the
related lexical bases, before falling back to the
normal backtracking mechanism.
</bodyText>
<sectionHeader confidence="0.989102" genericHeader="conclusions">
4 Conclusion
</sectionHeader>
<bodyText confidence="0.8634675">
We discussed how to implement and improve the
semi-recursive algorithm described in
</bodyText>
<figureCaption confidence="0.694558">
(Danlos1996), so that the global (holistic)
approach ((Danlos, 1996) and (Rastier and
al.;1994)) be realisfiCally impleniented. &apos;Because
of its nature, the algorithm is intented rather for
best-first generation, and several improvements
are still being studied, regarding the paraphrase
and the dynamic construction and updating of the
lexical bases.
</figureCaption>
<sectionHeader confidence="0.976779" genericHeader="references">
5 References
</sectionHeader>
<reference confidence="0.995761">
(Abeille, 1993) Abeille A. (1993) : o Les
nouvelles syntaxes: grammaires d&apos;unification et
analyse du francais », Armand Colin, Paris.
(AR-Kaci and Nasr, 1986) Pat-Kaci H, Nasr R.
(1986) : o Login: A logic-Programming
Language with Built-In Inheritance », in Journal
of Logic Programming, 3.
(Seeker, 1998) Becker T. (1998) : « Fully
Lexicalized head-driven syntactic generation )5,
INLG&apos;98, Niagara-on-the-Lake, Ontario, Canada.
(Busemann, 1993) Busemann S. (1993) : « A
holistic view of lexical choice », in Helmut
Horacek (ed.), New Concepts in Natural
Language Generation: Planning, Realization, and
Systems, Frances Pinter, London, New-York.
(Danlos, 1996) Danlos L. (1996) : « Presentation
de G-TAG, un formalisme pour la generation de
textes inspire des grammaires d&apos;arbres adjoints »,
in Ades TALN-96, Marseille.
(Danlos, 1998) Danlos L. (1998), &lt;G-TAG: a
Formalism for Text Generation inspired from
Tree Adjoining Grammar: TAG issues », in
Abeille A., Rambow, 0. (eds), Tree Adjoining
Grammars, CSLI, Standford.
(Danlos, 1999) Danlos L. (1999), « G-TAG tin
formalisme lexicalis&amp; pour la generation de textes
inspire de TAG », TAL, Vol. 39.2.
(Danlos and Meunier, 1996) Dan los L., Meunier
F. (1996), o La generation multiling,ue
applications industrielles et realisation
Sc ientifique », Longues situees, technologic.
communications, 1996
</reference>
<page confidence="0.963408">
237
</page>
<reference confidence="0.997499428571429">
(Joshi and al., 1975) Joshi A., Levy L.,
Takahashi M. (1975) : « Tree Adjunct
Grammars », in Journal of the Computer and
System Sciences, 10 :1.
(Meunier, 1997) Meunier F. (1997),
Implantation du formalisme de generation
G-TAG, These de doctorat, Universite de Paris 7
(Meunier, 1999) Meunier F. (1999),
Modelisation des ressources linguistiques d&apos;une
application industrielle, Actes TALN&apos;99, Cargese.
(Meunier and Reyes, 1999) Meunier F., Reyes
R. (1999), Plate-forme de developpement de
generateurs multi lingues, Actes GA T&apos;99,
Grenoble, France.
(Meunier and Danlos, 1998) Danlos L., Meunier
F. (1998), « FLAUBERT : User-friendly
multilingual NLG 1NLG 1998, Niagara-on-the-
Lake, Ontario, Canada.
(Nicolov, 1998) Nicolov N. (1998) :
(&lt; Memoization in Sentence Generation with
Lexicalized Grammars ». Proceedings of the 4th
International Workshop on Tree-Adjoining
Grammars and Related Frameworks (TAG+4),
Philadelphia.
(Rags, 1999) The RAGS Project (1999) :
« Toward a reference architecture for natural
language generation systems ».
http://www. it r .bri gh ton .ac .uk/projects/rags
(Rustier and al., 1994) Rastier F., Cavazza M.,
and Abeille A. (1994) : « Semantique pour
l&apos;analyse Masson, Paris.
(Schabes and Shieber, 1994) Schabes Y.., and
Shieber S. (1994) : « An alternative conception of
the Tree-Adjoining Grammars in Actes 13&amp;quot;1
COLING-90, Helsinki.
</reference>
<page confidence="0.997057">
238
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.369467">
<title confidence="0.993094">CLEF</title>
<author confidence="0.992175">Rodrigo</author>
<affiliation confidence="0.863488">Talana, Univ. Paris</affiliation>
<address confidence="0.43169">2000</address>
<abstract confidence="0.989812125">We will discuss the-serni-recursive algorithm for text generation, as defined for the GTAG formalism, and its implementation in the CLEF project. We will show how to use lexical choice constraints and properties of the LTAG grammar to minimize the backtracking of the semirecursive algorithm.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>A Abeille</author>
</authors>
<title>o Les nouvelles syntaxes: grammaires d&apos;unification et analyse du francais », Armand Colin,</title>
<date>1993</date>
<location>Paris.</location>
<marker>(Abeille, 1993)</marker>
<rawString>Abeille A. (1993) : o Les nouvelles syntaxes: grammaires d&apos;unification et analyse du francais », Armand Colin, Paris.</rawString>
</citation>
<citation valid="false">
<authors>
<author>H Pat-Kaci</author>
<author>R Nasr</author>
</authors>
<marker>(AR-Kaci and Nasr, 1986)</marker>
<rawString>Pat-Kaci H, Nasr R.</rawString>
</citation>
<citation valid="false">
<title>o Login: A logic-Programming Language with Built-In Inheritance »,</title>
<journal>in Journal of Logic Programming,</journal>
<volume>3</volume>
<marker>(1986)</marker>
<rawString>: o Login: A logic-Programming Language with Built-In Inheritance », in Journal of Logic Programming, 3.</rawString>
</citation>
<citation valid="true">
<authors>
<author>T Becker</author>
</authors>
<title>Fully Lexicalized head-driven syntactic generation )5, INLG&apos;98,</title>
<date>1998</date>
<location>Niagara-on-the-Lake, Ontario, Canada.</location>
<marker>(Seeker, 1998)</marker>
<rawString>Becker T. (1998) : « Fully Lexicalized head-driven syntactic generation )5, INLG&apos;98, Niagara-on-the-Lake, Ontario, Canada.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S Busemann</author>
</authors>
<title>A holistic view of lexical choice »,</title>
<date>1993</date>
<booktitle>in Helmut Horacek (ed.), New Concepts in Natural Language Generation: Planning, Realization, and Systems,</booktitle>
<location>Frances Pinter, London, New-York.</location>
<marker>(Busemann, 1993)</marker>
<rawString>Busemann S. (1993) : « A holistic view of lexical choice », in Helmut Horacek (ed.), New Concepts in Natural Language Generation: Planning, Realization, and Systems, Frances Pinter, London, New-York.</rawString>
</citation>
<citation valid="true">
<authors>
<author>L Danlos</author>
</authors>
<title>Presentation de G-TAG, un formalisme pour la generation de textes inspire des grammaires d&apos;arbres adjoints »,</title>
<date>1996</date>
<booktitle>in Ades TALN-96,</booktitle>
<location>Marseille.</location>
<marker>(Danlos, 1996)</marker>
<rawString>Danlos L. (1996) : « Presentation de G-TAG, un formalisme pour la generation de textes inspire des grammaires d&apos;arbres adjoints », in Ades TALN-96, Marseille.</rawString>
</citation>
<citation valid="true">
<authors>
<author>L Danlos</author>
</authors>
<title>a Formalism for Text Generation inspired from Tree Adjoining Grammar:</title>
<date>1998</date>
<journal>TAG issues », in Abeille A., Rambow,</journal>
<volume>0</volume>
<location>CSLI, Standford.</location>
<marker>(Danlos, 1998)</marker>
<rawString>Danlos L. (1998), &lt;G-TAG: a Formalism for Text Generation inspired from Tree Adjoining Grammar: TAG issues », in Abeille A., Rambow, 0. (eds), Tree Adjoining Grammars, CSLI, Standford.</rawString>
</citation>
<citation valid="true">
<authors>
<author>L Danlos</author>
</authors>
<title>G-TAG tin formalisme lexicalis&amp; pour la generation de textes inspire de</title>
<date>1999</date>
<journal>TAG », TAL,</journal>
<volume>39</volume>
<marker>(Danlos, 1999)</marker>
<rawString>Danlos L. (1999), « G-TAG tin formalisme lexicalis&amp; pour la generation de textes inspire de TAG », TAL, Vol. 39.2.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Dan los L</author>
<author>F Meunier</author>
</authors>
<title>o La generation multiling,ue applications industrielles et realisation Sc ientifique », Longues situees, technologic. communications,</title>
<date>1996</date>
<marker>(Danlos and Meunier, 1996)</marker>
<rawString>Dan los L., Meunier F. (1996), o La generation multiling,ue applications industrielles et realisation Sc ientifique », Longues situees, technologic. communications, 1996</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Joshi</author>
<author>L Levy</author>
<author>M Takahashi</author>
</authors>
<title>Tree Adjunct Grammars »,</title>
<date>1975</date>
<journal>in Journal of the Computer and System Sciences,</journal>
<volume>10</volume>
<marker>(Joshi and al., 1975)</marker>
<rawString>Joshi A., Levy L., Takahashi M. (1975) : « Tree Adjunct Grammars », in Journal of the Computer and System Sciences, 10 :1.</rawString>
</citation>
<citation valid="true">
<authors>
<author>F Meunier</author>
</authors>
<title>Implantation du formalisme de generation G-TAG, These de doctorat,</title>
<date>1997</date>
<journal>Universite de Paris</journal>
<volume>7</volume>
<marker>(Meunier, 1997)</marker>
<rawString>Meunier F. (1997), Implantation du formalisme de generation G-TAG, These de doctorat, Universite de Paris 7</rawString>
</citation>
<citation valid="true">
<authors>
<author>F Meunier</author>
</authors>
<title>Modelisation des ressources linguistiques d&apos;une application industrielle, Actes</title>
<date>1999</date>
<tech>TALN&apos;99, Cargese.</tech>
<marker>(Meunier, 1999)</marker>
<rawString>Meunier F. (1999), Modelisation des ressources linguistiques d&apos;une application industrielle, Actes TALN&apos;99, Cargese.</rawString>
</citation>
<citation valid="true">
<authors>
<author>F Meunier</author>
<author>R Reyes</author>
</authors>
<title>Plate-forme de developpement de generateurs multi lingues,</title>
<date>1999</date>
<booktitle>Actes GA T&apos;99,</booktitle>
<location>Grenoble, France.</location>
<marker>(Meunier and Reyes, 1999)</marker>
<rawString>Meunier F., Reyes R. (1999), Plate-forme de developpement de generateurs multi lingues, Actes GA T&apos;99, Grenoble, France.</rawString>
</citation>
<citation valid="true">
<authors>
<author>L Danlos</author>
<author>F Meunier</author>
</authors>
<date>1998</date>
<booktitle>FLAUBERT : User-friendly multilingual NLG 1NLG</booktitle>
<location>Niagara-on-theLake, Ontario, Canada.</location>
<marker>(Meunier and Danlos, 1998)</marker>
<rawString>Danlos L., Meunier F. (1998), « FLAUBERT : User-friendly multilingual NLG 1NLG 1998, Niagara-on-theLake, Ontario, Canada.</rawString>
</citation>
<citation valid="true">
<authors>
<author>N Nicolov</author>
</authors>
<title>Memoization in Sentence Generation with Lexicalized Grammars ».</title>
<date>1998</date>
<booktitle>Proceedings of the 4th International Workshop on Tree-Adjoining Grammars and Related Frameworks (TAG+4),</booktitle>
<location>Philadelphia.</location>
<marker>(Nicolov, 1998)</marker>
<rawString>Nicolov N. (1998) : (&lt; Memoization in Sentence Generation with Lexicalized Grammars ». Proceedings of the 4th International Workshop on Tree-Adjoining Grammars and Related Frameworks (TAG+4), Philadelphia.</rawString>
</citation>
<citation valid="true">
<title>Toward a reference architecture for natural language generation systems ». http://www. it r .bri gh ton .ac .uk/projects/rags</title>
<date>1999</date>
<booktitle>The RAGS Project</booktitle>
<marker>(Rags, 1999)</marker>
<rawString>The RAGS Project (1999) : « Toward a reference architecture for natural language generation systems ». http://www. it r .bri gh ton .ac .uk/projects/rags</rawString>
</citation>
<citation valid="true">
<authors>
<author>F Rastier</author>
<author>M Cavazza</author>
<author>A Abeille</author>
</authors>
<title>Semantique pour l&apos;analyse Masson,</title>
<date>1994</date>
<location>Paris.</location>
<marker>(Rustier and al., 1994)</marker>
<rawString>Rastier F., Cavazza M., and Abeille A. (1994) : « Semantique pour l&apos;analyse Masson, Paris.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Y Schabes</author>
<author>S Shieber</author>
</authors>
<title>An alternative conception of the Tree-Adjoining Grammars in Actes 13&amp;quot;1 COLING-90,</title>
<date>1994</date>
<location>Helsinki.</location>
<marker>(Schabes and Shieber, 1994)</marker>
<rawString>Schabes Y.., and Shieber S. (1994) : « An alternative conception of the Tree-Adjoining Grammars in Actes 13&amp;quot;1 COLING-90, Helsinki.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>