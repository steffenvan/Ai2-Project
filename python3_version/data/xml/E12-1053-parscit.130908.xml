<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.051837">
<title confidence="0.9960045">
Learning How to Conjugate the Romanian Verb. Rules for Regular and
Partially Irregular Verbs
</title>
<note confidence="0.831013666666667">
Liviu P. Dinu Vlad Niculae Octavia-Maria S, ulea
Faculty of Mathematics Faculty of Mathematics Faculty of Foreign Languages
and Computer Science and Computer Science and Literatures
</note>
<affiliation confidence="0.907108">
University of Bucharest University of Bucharest Faculty of Mathematics
ldinu@fmi.unibuc.ro vlad@vene.ro and Computer Science
University of Bucharest
</affiliation>
<email confidence="0.971038">
mary.octavia@gmail.com
</email>
<sectionHeader confidence="0.993637" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.9845105">
In this paper we extend our work described
in (Dinu et al., 2011) by adding more con-
jugational rules to the labelling system in-
troduced there, in an attempt to capture
the entire dataset of Romanian verbs ex-
tracted from (Barbu, 2007), and we em-
ploy machine learning techniques to predict
a verb’s correct label (which says what con-
jugational pattern it follows) when only the
infinitive form is given.
</bodyText>
<sectionHeader confidence="0.998755" genericHeader="keywords">
1 Introduction
</sectionHeader>
<bodyText confidence="0.999977515625">
Using only a restricted group of verbs, in (Dinu
et al., 2011) we validated the hypothesis that pat-
terns can be identified in the conjugation of the
Romanian (partially irregular) verb and that these
patterns can be learnt automatically so that, given
the infinitive of a verb, its correct conjugation
for the indicative present tense can be produced.
In this paper, we extend our investigation to the
whole dataset described in (Barbu, 2008) and at-
tempt to capture, beside the general ending pat-
terns during conjugation, as much of the phono-
logical alternations occuring in the stem of verbs
(apophony) from the dataset as we can.
Traditionally, Romanian has received a Latin-
inspired classification of verbs into 4 (or some-
times 5) conjugational classes based on the ending
of their infinitival form alone (Costanzo, 2011).
However, this infinitive-based classification has
proved itself inadequate due to its inability to ac-
count for the behavior of partially irregular verbs
(whose stems have a smaller number of allo-
morphs than the completely irregular) during their
conjugation.
There have been, thus, numerous attempts
throughout the history of Romanian Linguistics
to give other conjugational classifications based
on the way the verb actually conjugates. Lom-
bard (1955), looking at a corpus of 667 verbs,
combined the traditional 4 classes with the way in
which the biggest two subgroups conjugate (one
using the suffix ”ez”, the other ”esc”) and ar-
rived at 6 classes. Ciompec (Ciompec et. al.,
1985 in Costanzo, 2011) proposed 10 conjuga-
tional classes, while Felix (1964) proposed 12,
both of them looking at the inflection of the verbs
and number of allomorphs of the stem. Romalo
(1968, p. 5-203) produced a list of 38 verb types,
which she eventually reduced to 10.
For the purpose of machine translation, Moisil
(1960) proposed 5 regrouped classes of verbs,
with numerous subgroups, and introduced the
method of letters with variable values, while Pa-
pastergiou et al. (2007) have recently developed
a classification from a (second) language acquisi-
tion point of view, dividing the 1st and 4th tradi-
tional classes into 3 and respectively 5 subclasses,
each with a different conjugational pattern, and
offering rules for alternations in the stem.
Of the more extensive classifications, Barbu
(2007) distinguished 41 conjugational classes for
all tenses and 30 for the indicative present alone,
covering a whole corpus of more that 7000 con-
temporary Romanian verbs, a corpus which was
also used in the present paper. However, her
classes were developed on the basis of the suf-
fixes each verb receives during conjugation, and
the classification system did not take into account
the alternations occuring in the stem of irregular
and partially irregular verbs. The system of rules
presented below took into account both the end-
ings pattern and the type of stem alternation for
each verb.
In what follows we describe our method for la-
beling the dataset and finding a model able to pre-
</bodyText>
<page confidence="0.972483">
524
</page>
<bodyText confidence="0.485681666666667">
Proceedings of the 13th Conference of the European Chapter of the Association for Computational Linguistics, pages 524–528,
Avignon, France, April 23 - 27 2012. c�2012 Association for Computational Linguistics
dict the labels.
</bodyText>
<sectionHeader confidence="0.884204" genericHeader="introduction">
2 Approach
</sectionHeader>
<bodyText confidence="0.999964">
The problem which we are aiming to solve is to
determine how to conjugate a verb, given its in-
finitive form. The traditional infinitive-based clas-
sification taught in school does not take one all the
way to solving this problem. Many conjugational
patterns exist within each of these four classes.
</bodyText>
<subsectionHeader confidence="0.99946">
2.1 Labeling the dataset
</subsectionHeader>
<bodyText confidence="0.999904236842105">
Following our own observations, the alternations
identified in (Papastergiou et al., 2007) and the
classes of suffix patterns given in (Barbu, 2007),
we developed a number of conjugational rules
which were narrowed down to the 30 most pro-
ductive in relation to the dataset. Each of these
30 rules (or patterns) contains 6 regular expres-
sions through which the rule models how a (dif-
ferent) type of Romanian verb conjugates in the
indicative present. They each consist of 6 reg-
ular expressions because there are three persons
(first, second, and third) times two numbers (sin-
gular and plural).
Rule 10, for example, models, as stated in
the list that follows, how verbs of the type
”a c&amp;quot;anta” (to sing) conjugate in the indicative
present, by having the first regular expression
model the first person singular form ”(eu) c&amp;quot;ant”
(in regular expression format: &amp;quot;(.+)$), the sec-
ond, model the second person singular form ”(tu)
c&amp;quot;anli” (&amp;quot;(.+)t¸i$), the third, model the third per-
son singular form ”(ei) c&amp;quot;ant˘a” (&amp;quot;(.+)˘a$), and so
forth. Thus, rule 10 catches the alternation t—*lfor the 2nd person singular, while modelling a
particular type of verb class with a particular set
of suffixes. Note that the dot accepts any letter
in the Romanian alphabet and that, for each of
the six forms, the value of the capturing groups
(those between brackets) remains constant, in this
case cˆan. These groups correspond to all parts of
the stem that remain unchanged and ensure that,
given the infinitive and the regular expressions,
one can work backwards and produce the correct
conjugation.
For a clearer understanding of one such rule,
Table 1 shows an example of how the verb ”a
tres˘alta” is modeled by rule 14.
Below, we list all the rules used, with the stem
alternations they capture and an example of a verb
</bodyText>
<table confidence="0.999203142857143">
Person Regexp Example
1st singular &amp;quot;(.+)a(.+)t$ tresalt
2nd singular &amp;quot;(.+)a(.+)t¸i$ tresalt¸i
3rd singular &amp;quot;(.+)a(.+)t˘a$ tresalt˘a
1st plural &amp;quot;(.+)˘a(.+)t˘am$ tres˘alt˘am
2nd plural &amp;quot;(.+)˘a(.+)tali$ tres˘altat¸i
3rd plural &amp;quot;(.+)a(.+)t˘a$ tresalt˘a
</table>
<tableCaption confidence="0.999877">
Table 1: Rule 14 modelling ”a tres˘alta”
</tableCaption>
<bodyText confidence="0.999586428571429">
that they model. Note that, when we say (no) al-
ternation, we mean (no) alternation in the stem.
So the difference between rules 1, 20, 22, and the
sort lies in the suffix that is added to the stem
for each verb form. They may share some suf-
fixes, but not all and/or not for the same person
and number.
</bodyText>
<listItem confidence="0.991428740740741">
1. no alternation; ”a spera” (to hope);
2. alternation: ˘a—*e for the 2nd person singular;
”a num˘ara” (to count);
3. no alternation; ”a intra” (to enter), stem ends
in ”tr”, ”pl”, ”bl” or ”fl” which determines
the addition of ”u” at the end of the 1st per-
son singular form;
4. alternation: it lacks t—*lfor the 2nd person
singular, which otherwise normally occurs;
”a mis¸ca” (to move), stem ends in ”s¸ca”;
5. no alternation; ”a t˘aia” (to cut), ends in ”ia”
and has a vowel before;
6. no alternation; ”a speria” (to scare), ends in
”ia” and has a consonant before;
7. no alternation; ”a dansa” (to dance), conju-
gated with the suffix ”ez”;
8. no alternation; ”a copia” (to copy), conju-
gated with a modified ”ez” due to the stem
ending in ”ia”;
9. altenation c—*ch(e) or g—*gh(e); ”a parca”
(to park), conjugated with ”ez”, ending in
”ca” or ”ga”;
10. alternation: t—*lfor the 2nd person singular;
”a c&amp;quot;anta” (to sing);
11. alternation: s—*s¸ which replaces the usual
t—*lfor the 2nd person singular; ”a exista”
(to exist);
</listItem>
<page confidence="0.988055">
525
</page>
<bodyText confidence="0.913698833333333">
12. alternation: a—*ea for the 3rd person singular
and plural, t—*t¸ for the 2nd person singular;
”a des¸tepta” (to awake/arouse);
13. alternation: e—*ea for the 3rd person singular
and plural, t—*t¸ for the 2nd person singular;
”a des¸erta” (to empty);
</bodyText>
<listItem confidence="0.952857391304348">
14. alternation: ˘a—*a for all the forms except the
1st and 2nd person plural; ”a tres˘alta” (to
start, to take fright);
15. alternation: ˘a—*a in the 3rd person singular
and plural, ˘a—*e in the 2nd person singular;
”a desf˘ata” (to delight);
16. alternation: ˘a—*a for all the forms except for
the 1st and 2nd person plural; ”a p˘area” (to
seem);
17. alternation: d—*z for the 2nd person singu-
lar due to palatalization, along with ˘a—*e; ”a
vedea” (to see), stem ends in ”d”;
18. alternation: ˘a—*a for all forms except the 1st
and 2nd person plural, d—*z for the 2nd per-
son singular due to palatalization; ”a c˘adea”
(to fall);
19. no alternation; ”a veghea” (to watch over),
conjugates with another type of ”ez” ending
pattern;
20. no alternations; ”a merge” (to walk), receives
the typical ending pattern for the third conju-
gational class;
21. alternation: t—*t¸ for the 2nd person singular;
”a promite” (to promise);
22. no alternation; ”a scrie” (to write);
23. alternations: s¸t—*sc for the 1st person singu-
lar and 3rd person plural; ”a nas¸te” (to give
birth), ends in ”s¸te”;
24. alternation: ”n” is deleted from the stem in
the 2nd person singular; ”a pune” (to put),
ends in ”ne”;
25. alternation: d—*z in the 2nd person singular
due to palatalization; ”a crede” (to believe),
stem ends in ”d”;
26. no alternation; ”a sui” (to climb), ends in
”ui”, ”˘ai”, or ”ˆai”;
27. no alternation; ”a citi” (to read), conjugates
with the suffix ”esc” ;
28. this type preserves the ”i” from the infinitive;
”a locui” (to reside), ends in ”˘ai”, ”oi”, or ui”
and conjugates with ”esc”;
29. alternation: o—*oa in the 3rd person singular
and plural; end in ”ˆı”, ”a omorT” (to kill);
30. no alternation; ”a hot˘arˆı” (to decide), ends in
”T” and conjugates with ”˘asc”, a variant of
”esc”
</listItem>
<subsectionHeader confidence="0.996312">
2.2 Classifiers and features
</subsectionHeader>
<bodyText confidence="0.999952891891892">
Each infinitive in the dataset received a label cor-
responding to the first rule that correctly produces
a conjugation for it. This was implemented in
order to reduce the ambiguity of the data, which
was due to some verbs having alternate conjuga-
tion patterns. The unlabeled verbs were thrown
out, while the labeled ones were used to train and
evaluate a classifier.
The context sensitive nature of the alternations
leads to the idea that n-gram character windows
are useful. In the preprocessing step, the list of in-
finitives is transformed to a sparse matrix whose
lines correspond to samples, and whose features
are the occurence or the frequency of a specific n-
gram. This feature extraction step has three free
parameters: the maximum n-gram length, the op-
tional binarization of the features (taking only bi-
nary occurences instead of counts), and the op-
tional appending of a terminator character. The
terminator character allows the classifier to iden-
tify and assign a different weight to the n-grams
that overlap with the suffix of the string.
For example, consider the English infinitive to
walk. We will assume the following illustrative
values for the parameters: n-gram size of 3 and
appending the terminator character. Firstly, a ter-
minator is appended to the end, yielding the string
walk$. Subsequently, the string is broken into 1, 2
and 3-grams: w, a, l, k, $, wa, al, lk, k$, wal, alk,
lk$. Next, this list is turned into a vector using a
standard process. We have first built a dictionary
of all the n-grams from the whole dataset. These,
in order, encode the features. The verb (to) walk
is therefore encoded as a row vector with ones in
the columns corresponding to the features w, a,
etc. and zeros in the rest. In this particular case,
there is no difference between binary and count
</bodyText>
<page confidence="0.995141">
526
</page>
<table confidence="0.999743375">
rule no. verbs rule no. verbs
1 547 16 13
2 8 17 6
3 18 18 4
4 5 19 14
5 8 20 124
6 16 21 25
7 3330 22 15
8 273 23 7
9 89 24 41
10 4 25 51
11 5 26 185
12 4 27 1554
13 106 28 486
14 13 29 5
15 5 30 27
</table>
<tableCaption confidence="0.999388">
Table 2: Number of verbs captured by each of our rules
</tableCaption>
<bodyText confidence="0.998068416666667">
features because all of the n-grams of this short
verb occur only once. But for a verb such as (to)
tantalize, the feature corresponding to the 2-gram
ta would get a value of 2 in a count reprezentation,
but only a value of 1 in a binary one.
The system was put together using the scikit-
learn machine learning library for Python (Pe-
dregosa et al., 2011), which provides a fast, scal-
able implementation of linear support vector ma-
chines based on liblinear (Fan et al., 2008), along
with n-gram extraction and grid search function-
ality.
</bodyText>
<sectionHeader confidence="0.999883" genericHeader="background">
3 Results
</sectionHeader>
<bodyText confidence="0.999970741935484">
Tabel 2 shows how well the rules fitted the dataset.
Out of 7,295 verbs in the dataset, 349 were uncap-
tured by our rules. As expected, the rule capturing
the most verbs (3,330) is the one modelling those
from the 1st conjugational class (whose infinitives
end in ”a”) which conjugate with the ”ez” suffix
and are regular, namely rule 7, created for verbs
like ”a dansa”. The second largest class, also as
expected, is the one belonging to verbs from the
4th conjugational group (whose infinitives end in
”i”), which are regular, meaning no alternation in
the stem, and conjugate with the ”esc” suffix. This
class is modeled by rule number 27.
The support vector classifier was evaluated
using a 10-fold cross-validation. The multi-
class problem is treated using the one-versus-all
scheme. The parameters chosen by grid search are
a maximum n-gram length of 5, with appended
terminator and with non-binarized (count) fea-
tures. The estimated correct classification rate is
90.64%, with a weighted averaged precision of
80.90%, recall of 90.64% and F1 score of 89.89%.
Appending the artificial terminator character ’$’
consistently improves accuracy by around 0.7%.
Because each word was represented as a bag of
character n-grams instead of a continuous string,
and because, by its nature, a SVM yields sparse
solutions, combined with the evaluation using
cross-validation, we can safely say that the model
does not overfit and indeed learns useful decision
boundaries.
</bodyText>
<sectionHeader confidence="0.999136" genericHeader="conclusions">
4 Conclusions and Future Works
</sectionHeader>
<bodyText confidence="0.9999428">
Our results show that the labelling system based
on the verb conjugation model we developed can
be learned with reasonable accuracy. In the future,
we plan to develop a multiple tiered labelling sys-
tem that will allow for general alternations, such
as the ones occuring as a result of palatalization,
to be defined only once for all verbs that have
them, taking cues from the idea of letters with
multiple values. This, we feel, will highly im-
prove the acuracy of the classifier.
</bodyText>
<sectionHeader confidence="0.998888" genericHeader="acknowledgments">
5 Acknowledgements
</sectionHeader>
<bodyText confidence="0.999805625">
The authors would like to thank the anonymous
reviewers for their helpful comments. All authors
contributed equally to this work. The research of
Liviu P. Dinu was supported by the CNCS, IDEI
- PCE project 311/2011, ”The Structure and In-
terpretation of the Romanian Nominal Phrase in
Discourse Representation Theory: the Determin-
ers.”
</bodyText>
<sectionHeader confidence="0.998483" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.99174325">
Ana-Maria Barbu. Conjugarea verbelor romˆa-
nes¸ti. Dict¸ionar: 7500 de verbe romˆanes¸ti gru-
pate pe clase de conjugare. Bucharest: Coresi,
2007. 4th edition, revised. (In Romanian.) (263
pp.).
Ana-Maria Barbu. Romanian lexical databases:
Inflected and syllabic forms dictionaries. In
Sixth International Language Resources and
Evaluation (LREC’08), 2008.
Angelo Roth Costanzo. Romance Conjugational
Classes: Learning from the Peripheries. PhD
thesis, Ohio State University, 2011.
</reference>
<page confidence="0.997185">
527
</page>
<figureCaption confidence="0.8896755">
Figure 1: 10-fold cross validation scores for various combination of parameters. Only the values corresponding
to the best C regularization parameters are shown.
</figureCaption>
<reference confidence="0.999358638888889">
Liviu P. Dinu, Emil Ionescu, Vlad Niculae, and
Octavia-Maria S¸ulea. Can alternations be
learned? a machine learning approach to verb
alternations. In Recent Advances in Natural
Language Processing 2011, September 2011.
Rong-En Fan, Kai-Wei Chang, Cho-Jui Hsieh,
Xiang-Rui Wang, and Chih-Jen Lin. Liblinear:
A library for large linear classification. Journal
of Machine Learning Research, 9:1871–1874,
June 2008. ISSN 1532-4435.
Jiˇri Felix. Classification des verbes roumains, vol-
ume VII. Philosophica Pragensia, 1964.
Alf Lombard. Le verbe roumain. Etude mor-
phologique, volume 1. Lund, C. W. K. Gleerup,
1955.
Grigore C. Moisil. Probleme puse de traduc-
erea automat˘a. conjugarea verbelor in limba
romˆan˘a. Studii si cercet˘ari lingvistice, XI(1):
7–29, 1960.
I. Papastergiou, N. Papastergiou, and L. Man-
deki. Verbul romˆanesc - reguli pentru inlesnirea
insus¸irii indicativului prezent. In Romanian
National Symposium ”Directions in Roma-
nian Philological Research”, 7th Edition, May
2007.
F. Pedregosa, G. Varoquaux, A. Gramfort,
V. Michel, B. Thirion, O. Grisel, M. Blon-
del, P. Prettenhofer, R. Weiss, V. Dubourg,
J. Vanderplas, A. Passos, D. Cournapeau,
M. Brucher, M. Perrot, and E. Duchesnay.
Scikit-learn: Machine learning in Python. Jour-
nal of Machine Learning Research, 12:2825–
2830, Oct 2011.
Valeria Guju Romalo. Morfologie Structural˘a a
limbii romˆane. Editura Academiei Republicii
Socialiste Romˆania, 1968.
</reference>
<page confidence="0.996727">
528
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.859873">
<title confidence="0.993611">Learning How to Conjugate the Romanian Verb. Rules for Regular Partially Irregular Verbs</title>
<author confidence="0.951209">Liviu P Vlad Faculty of Foreign</author>
<affiliation confidence="0.97727275">Faculty of Faculty of and and Computer and Computer Faculty of University of University of and Computer ldinu@fmi.unibuc.ro vlad@vene.ro University of</affiliation>
<email confidence="0.993843">mary.octavia@gmail.com</email>
<abstract confidence="0.998502818181818">In this paper we extend our work described in (Dinu et al., 2011) by adding more conjugational rules to the labelling system introduced there, in an attempt to capture the entire dataset of Romanian verbs extracted from (Barbu, 2007), and we employ machine learning techniques to predict a verb’s correct label (which says what conjugational pattern it follows) when only the infinitive form is given.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Ana-Maria Barbu</author>
</authors>
<title>Conjugarea verbelor romˆanes¸ti. Dict¸ionar: 7500 de verbe romˆanes¸ti grupate pe clase de conjugare.</title>
<date>2007</date>
<journal>(In Romanian.)</journal>
<volume>263</volume>
<pages>pp.).</pages>
<location>Bucharest: Coresi,</location>
<note>4th edition, revised.</note>
<contexts>
<context position="689" citStr="Barbu, 2007" startWordPosition="99" endWordPosition="100">Irregular Verbs Liviu P. Dinu Vlad Niculae Octavia-Maria S, ulea Faculty of Mathematics Faculty of Mathematics Faculty of Foreign Languages and Computer Science and Computer Science and Literatures University of Bucharest University of Bucharest Faculty of Mathematics ldinu@fmi.unibuc.ro vlad@vene.ro and Computer Science University of Bucharest mary.octavia@gmail.com Abstract In this paper we extend our work described in (Dinu et al., 2011) by adding more conjugational rules to the labelling system introduced there, in an attempt to capture the entire dataset of Romanian verbs extracted from (Barbu, 2007), and we employ machine learning techniques to predict a verb’s correct label (which says what conjugational pattern it follows) when only the infinitive form is given. 1 Introduction Using only a restricted group of verbs, in (Dinu et al., 2011) we validated the hypothesis that patterns can be identified in the conjugation of the Romanian (partially irregular) verb and that these patterns can be learnt automatically so that, given the infinitive of a verb, its correct conjugation for the indicative present tense can be produced. In this paper, we extend our investigation to the whole dataset </context>
<context position="3182" citStr="Barbu (2007)" startWordPosition="499" endWordPosition="500"> p. 5-203) produced a list of 38 verb types, which she eventually reduced to 10. For the purpose of machine translation, Moisil (1960) proposed 5 regrouped classes of verbs, with numerous subgroups, and introduced the method of letters with variable values, while Papastergiou et al. (2007) have recently developed a classification from a (second) language acquisition point of view, dividing the 1st and 4th traditional classes into 3 and respectively 5 subclasses, each with a different conjugational pattern, and offering rules for alternations in the stem. Of the more extensive classifications, Barbu (2007) distinguished 41 conjugational classes for all tenses and 30 for the indicative present alone, covering a whole corpus of more that 7000 contemporary Romanian verbs, a corpus which was also used in the present paper. However, her classes were developed on the basis of the suffixes each verb receives during conjugation, and the classification system did not take into account the alternations occuring in the stem of irregular and partially irregular verbs. The system of rules presented below took into account both the endings pattern and the type of stem alternation for each verb. In what follo</context>
<context position="4577" citStr="Barbu, 2007" startWordPosition="726" endWordPosition="727">inguistics, pages 524–528, Avignon, France, April 23 - 27 2012. c�2012 Association for Computational Linguistics dict the labels. 2 Approach The problem which we are aiming to solve is to determine how to conjugate a verb, given its infinitive form. The traditional infinitive-based classification taught in school does not take one all the way to solving this problem. Many conjugational patterns exist within each of these four classes. 2.1 Labeling the dataset Following our own observations, the alternations identified in (Papastergiou et al., 2007) and the classes of suffix patterns given in (Barbu, 2007), we developed a number of conjugational rules which were narrowed down to the 30 most productive in relation to the dataset. Each of these 30 rules (or patterns) contains 6 regular expressions through which the rule models how a (different) type of Romanian verb conjugates in the indicative present. They each consist of 6 regular expressions because there are three persons (first, second, and third) times two numbers (singular and plural). Rule 10, for example, models, as stated in the list that follows, how verbs of the type ”a c&amp;quot;anta” (to sing) conjugate in the indicative present, by having</context>
</contexts>
<marker>Barbu, 2007</marker>
<rawString>Ana-Maria Barbu. Conjugarea verbelor romˆanes¸ti. Dict¸ionar: 7500 de verbe romˆanes¸ti grupate pe clase de conjugare. Bucharest: Coresi, 2007. 4th edition, revised. (In Romanian.) (263 pp.).</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ana-Maria Barbu</author>
</authors>
<title>Romanian lexical databases: Inflected and syllabic forms dictionaries.</title>
<date>2008</date>
<booktitle>In Sixth International Language Resources and Evaluation (LREC’08),</booktitle>
<contexts>
<context position="1315" citStr="Barbu, 2008" startWordPosition="202" endWordPosition="203">y machine learning techniques to predict a verb’s correct label (which says what conjugational pattern it follows) when only the infinitive form is given. 1 Introduction Using only a restricted group of verbs, in (Dinu et al., 2011) we validated the hypothesis that patterns can be identified in the conjugation of the Romanian (partially irregular) verb and that these patterns can be learnt automatically so that, given the infinitive of a verb, its correct conjugation for the indicative present tense can be produced. In this paper, we extend our investigation to the whole dataset described in (Barbu, 2008) and attempt to capture, beside the general ending patterns during conjugation, as much of the phonological alternations occuring in the stem of verbs (apophony) from the dataset as we can. Traditionally, Romanian has received a Latininspired classification of verbs into 4 (or sometimes 5) conjugational classes based on the ending of their infinitival form alone (Costanzo, 2011). However, this infinitive-based classification has proved itself inadequate due to its inability to account for the behavior of partially irregular verbs (whose stems have a smaller number of allomorphs than the comple</context>
</contexts>
<marker>Barbu, 2008</marker>
<rawString>Ana-Maria Barbu. Romanian lexical databases: Inflected and syllabic forms dictionaries. In Sixth International Language Resources and Evaluation (LREC’08), 2008.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Angelo Roth Costanzo</author>
</authors>
<title>Romance Conjugational Classes: Learning from the Peripheries. PhD thesis,</title>
<date>2011</date>
<institution>Ohio State University,</institution>
<contexts>
<context position="1696" citStr="Costanzo, 2011" startWordPosition="264" endWordPosition="265"> can be learnt automatically so that, given the infinitive of a verb, its correct conjugation for the indicative present tense can be produced. In this paper, we extend our investigation to the whole dataset described in (Barbu, 2008) and attempt to capture, beside the general ending patterns during conjugation, as much of the phonological alternations occuring in the stem of verbs (apophony) from the dataset as we can. Traditionally, Romanian has received a Latininspired classification of verbs into 4 (or sometimes 5) conjugational classes based on the ending of their infinitival form alone (Costanzo, 2011). However, this infinitive-based classification has proved itself inadequate due to its inability to account for the behavior of partially irregular verbs (whose stems have a smaller number of allomorphs than the completely irregular) during their conjugation. There have been, thus, numerous attempts throughout the history of Romanian Linguistics to give other conjugational classifications based on the way the verb actually conjugates. Lombard (1955), looking at a corpus of 667 verbs, combined the traditional 4 classes with the way in which the biggest two subgroups conjugate (one using the su</context>
</contexts>
<marker>Costanzo, 2011</marker>
<rawString>Angelo Roth Costanzo. Romance Conjugational Classes: Learning from the Peripheries. PhD thesis, Ohio State University, 2011.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Liviu P Dinu</author>
<author>Emil Ionescu</author>
<author>Vlad Niculae</author>
<author>Octavia-Maria S¸ulea</author>
</authors>
<title>Can alternations be learned? a machine learning approach to verb alternations.</title>
<date>2011</date>
<booktitle>In Recent Advances in Natural Language Processing</booktitle>
<marker>Dinu, Ionescu, Niculae, S¸ulea, 2011</marker>
<rawString>Liviu P. Dinu, Emil Ionescu, Vlad Niculae, and Octavia-Maria S¸ulea. Can alternations be learned? a machine learning approach to verb alternations. In Recent Advances in Natural Language Processing 2011, September 2011.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Rong-En Fan</author>
<author>Kai-Wei Chang</author>
<author>Cho-Jui Hsieh</author>
<author>Xiang-Rui Wang</author>
<author>Chih-Jen Lin</author>
</authors>
<title>Liblinear: A library for large linear classification.</title>
<date>2008</date>
<journal>Journal of Machine Learning Research,</journal>
<volume>9</volume>
<pages>1532--4435</pages>
<contexts>
<context position="12458" citStr="Fan et al., 2008" startWordPosition="2102" endWordPosition="2105"> 23 7 9 89 24 41 10 4 25 51 11 5 26 185 12 4 27 1554 13 106 28 486 14 13 29 5 15 5 30 27 Table 2: Number of verbs captured by each of our rules features because all of the n-grams of this short verb occur only once. But for a verb such as (to) tantalize, the feature corresponding to the 2-gram ta would get a value of 2 in a count reprezentation, but only a value of 1 in a binary one. The system was put together using the scikitlearn machine learning library for Python (Pedregosa et al., 2011), which provides a fast, scalable implementation of linear support vector machines based on liblinear (Fan et al., 2008), along with n-gram extraction and grid search functionality. 3 Results Tabel 2 shows how well the rules fitted the dataset. Out of 7,295 verbs in the dataset, 349 were uncaptured by our rules. As expected, the rule capturing the most verbs (3,330) is the one modelling those from the 1st conjugational class (whose infinitives end in ”a”) which conjugate with the ”ez” suffix and are regular, namely rule 7, created for verbs like ”a dansa”. The second largest class, also as expected, is the one belonging to verbs from the 4th conjugational group (whose infinitives end in ”i”), which are regular,</context>
</contexts>
<marker>Fan, Chang, Hsieh, Wang, Lin, 2008</marker>
<rawString>Rong-En Fan, Kai-Wei Chang, Cho-Jui Hsieh, Xiang-Rui Wang, and Chih-Jen Lin. Liblinear: A library for large linear classification. Journal of Machine Learning Research, 9:1871–1874, June 2008. ISSN 1532-4435.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jiˇri Felix</author>
</authors>
<title>Classification des verbes roumains, volume VII. Philosophica Pragensia,</title>
<date>1964</date>
<contexts>
<context position="2453" citStr="Felix (1964)" startWordPosition="382" endWordPosition="383">lar verbs (whose stems have a smaller number of allomorphs than the completely irregular) during their conjugation. There have been, thus, numerous attempts throughout the history of Romanian Linguistics to give other conjugational classifications based on the way the verb actually conjugates. Lombard (1955), looking at a corpus of 667 verbs, combined the traditional 4 classes with the way in which the biggest two subgroups conjugate (one using the suffix ”ez”, the other ”esc”) and arrived at 6 classes. Ciompec (Ciompec et. al., 1985 in Costanzo, 2011) proposed 10 conjugational classes, while Felix (1964) proposed 12, both of them looking at the inflection of the verbs and number of allomorphs of the stem. Romalo (1968, p. 5-203) produced a list of 38 verb types, which she eventually reduced to 10. For the purpose of machine translation, Moisil (1960) proposed 5 regrouped classes of verbs, with numerous subgroups, and introduced the method of letters with variable values, while Papastergiou et al. (2007) have recently developed a classification from a (second) language acquisition point of view, dividing the 1st and 4th traditional classes into 3 and respectively 5 subclasses, each with a diff</context>
</contexts>
<marker>Felix, 1964</marker>
<rawString>Jiˇri Felix. Classification des verbes roumains, volume VII. Philosophica Pragensia, 1964.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Alf Lombard</author>
</authors>
<title>Le verbe roumain. Etude morphologique,</title>
<date>1955</date>
<volume>1</volume>
<contexts>
<context position="2150" citStr="Lombard (1955)" startWordPosition="329" endWordPosition="331">eived a Latininspired classification of verbs into 4 (or sometimes 5) conjugational classes based on the ending of their infinitival form alone (Costanzo, 2011). However, this infinitive-based classification has proved itself inadequate due to its inability to account for the behavior of partially irregular verbs (whose stems have a smaller number of allomorphs than the completely irregular) during their conjugation. There have been, thus, numerous attempts throughout the history of Romanian Linguistics to give other conjugational classifications based on the way the verb actually conjugates. Lombard (1955), looking at a corpus of 667 verbs, combined the traditional 4 classes with the way in which the biggest two subgroups conjugate (one using the suffix ”ez”, the other ”esc”) and arrived at 6 classes. Ciompec (Ciompec et. al., 1985 in Costanzo, 2011) proposed 10 conjugational classes, while Felix (1964) proposed 12, both of them looking at the inflection of the verbs and number of allomorphs of the stem. Romalo (1968, p. 5-203) produced a list of 38 verb types, which she eventually reduced to 10. For the purpose of machine translation, Moisil (1960) proposed 5 regrouped classes of verbs, with n</context>
</contexts>
<marker>Lombard, 1955</marker>
<rawString>Alf Lombard. Le verbe roumain. Etude morphologique, volume 1. Lund, C. W. K. Gleerup, 1955.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Grigore C Moisil</author>
</authors>
<title>Probleme puse de traducerea automat˘a. conjugarea verbelor in limba romˆan˘a. Studii si cercet˘ari lingvistice, XI(1): 7–29,</title>
<date>1960</date>
<contexts>
<context position="2704" citStr="Moisil (1960)" startWordPosition="426" endWordPosition="427">sed on the way the verb actually conjugates. Lombard (1955), looking at a corpus of 667 verbs, combined the traditional 4 classes with the way in which the biggest two subgroups conjugate (one using the suffix ”ez”, the other ”esc”) and arrived at 6 classes. Ciompec (Ciompec et. al., 1985 in Costanzo, 2011) proposed 10 conjugational classes, while Felix (1964) proposed 12, both of them looking at the inflection of the verbs and number of allomorphs of the stem. Romalo (1968, p. 5-203) produced a list of 38 verb types, which she eventually reduced to 10. For the purpose of machine translation, Moisil (1960) proposed 5 regrouped classes of verbs, with numerous subgroups, and introduced the method of letters with variable values, while Papastergiou et al. (2007) have recently developed a classification from a (second) language acquisition point of view, dividing the 1st and 4th traditional classes into 3 and respectively 5 subclasses, each with a different conjugational pattern, and offering rules for alternations in the stem. Of the more extensive classifications, Barbu (2007) distinguished 41 conjugational classes for all tenses and 30 for the indicative present alone, covering a whole corpus of</context>
</contexts>
<marker>Moisil, 1960</marker>
<rawString>Grigore C. Moisil. Probleme puse de traducerea automat˘a. conjugarea verbelor in limba romˆan˘a. Studii si cercet˘ari lingvistice, XI(1): 7–29, 1960.</rawString>
</citation>
<citation valid="true">
<authors>
<author>I Papastergiou</author>
<author>N Papastergiou</author>
<author>L Mandeki</author>
</authors>
<title>Verbul romˆanesc - reguli pentru inlesnirea insus¸irii indicativului prezent.</title>
<date>2007</date>
<booktitle>In Romanian National Symposium ”Directions in Romanian Philological Research”, 7th Edition,</booktitle>
<contexts>
<context position="2860" citStr="Papastergiou et al. (2007)" startWordPosition="447" endWordPosition="451">in which the biggest two subgroups conjugate (one using the suffix ”ez”, the other ”esc”) and arrived at 6 classes. Ciompec (Ciompec et. al., 1985 in Costanzo, 2011) proposed 10 conjugational classes, while Felix (1964) proposed 12, both of them looking at the inflection of the verbs and number of allomorphs of the stem. Romalo (1968, p. 5-203) produced a list of 38 verb types, which she eventually reduced to 10. For the purpose of machine translation, Moisil (1960) proposed 5 regrouped classes of verbs, with numerous subgroups, and introduced the method of letters with variable values, while Papastergiou et al. (2007) have recently developed a classification from a (second) language acquisition point of view, dividing the 1st and 4th traditional classes into 3 and respectively 5 subclasses, each with a different conjugational pattern, and offering rules for alternations in the stem. Of the more extensive classifications, Barbu (2007) distinguished 41 conjugational classes for all tenses and 30 for the indicative present alone, covering a whole corpus of more that 7000 contemporary Romanian verbs, a corpus which was also used in the present paper. However, her classes were developed on the basis of the suff</context>
<context position="4519" citStr="Papastergiou et al., 2007" startWordPosition="714" endWordPosition="717">onference of the European Chapter of the Association for Computational Linguistics, pages 524–528, Avignon, France, April 23 - 27 2012. c�2012 Association for Computational Linguistics dict the labels. 2 Approach The problem which we are aiming to solve is to determine how to conjugate a verb, given its infinitive form. The traditional infinitive-based classification taught in school does not take one all the way to solving this problem. Many conjugational patterns exist within each of these four classes. 2.1 Labeling the dataset Following our own observations, the alternations identified in (Papastergiou et al., 2007) and the classes of suffix patterns given in (Barbu, 2007), we developed a number of conjugational rules which were narrowed down to the 30 most productive in relation to the dataset. Each of these 30 rules (or patterns) contains 6 regular expressions through which the rule models how a (different) type of Romanian verb conjugates in the indicative present. They each consist of 6 regular expressions because there are three persons (first, second, and third) times two numbers (singular and plural). Rule 10, for example, models, as stated in the list that follows, how verbs of the type ”a c&amp;quot;anta</context>
</contexts>
<marker>Papastergiou, Papastergiou, Mandeki, 2007</marker>
<rawString>I. Papastergiou, N. Papastergiou, and L. Mandeki. Verbul romˆanesc - reguli pentru inlesnirea insus¸irii indicativului prezent. In Romanian National Symposium ”Directions in Romanian Philological Research”, 7th Edition, May 2007.</rawString>
</citation>
<citation valid="true">
<authors>
<author>F Pedregosa</author>
<author>G Varoquaux</author>
<author>A Gramfort</author>
<author>V Michel</author>
<author>B Thirion</author>
<author>O Grisel</author>
<author>M Blondel</author>
<author>P Prettenhofer</author>
<author>R Weiss</author>
<author>V Dubourg</author>
<author>J Vanderplas</author>
<author>A Passos</author>
<author>D Cournapeau</author>
<author>M Brucher</author>
<author>M Perrot</author>
<author>E Duchesnay</author>
</authors>
<title>Scikit-learn: Machine learning in Python.</title>
<date>2011</date>
<journal>Journal of Machine Learning Research,</journal>
<volume>12</volume>
<pages>2830</pages>
<contexts>
<context position="12338" citStr="Pedregosa et al., 2011" startWordPosition="2081" endWordPosition="2085"> and count 526 rule no. verbs rule no. verbs 1 547 16 13 2 8 17 6 3 18 18 4 4 5 19 14 5 8 20 124 6 16 21 25 7 3330 22 15 8 273 23 7 9 89 24 41 10 4 25 51 11 5 26 185 12 4 27 1554 13 106 28 486 14 13 29 5 15 5 30 27 Table 2: Number of verbs captured by each of our rules features because all of the n-grams of this short verb occur only once. But for a verb such as (to) tantalize, the feature corresponding to the 2-gram ta would get a value of 2 in a count reprezentation, but only a value of 1 in a binary one. The system was put together using the scikitlearn machine learning library for Python (Pedregosa et al., 2011), which provides a fast, scalable implementation of linear support vector machines based on liblinear (Fan et al., 2008), along with n-gram extraction and grid search functionality. 3 Results Tabel 2 shows how well the rules fitted the dataset. Out of 7,295 verbs in the dataset, 349 were uncaptured by our rules. As expected, the rule capturing the most verbs (3,330) is the one modelling those from the 1st conjugational class (whose infinitives end in ”a”) which conjugate with the ”ez” suffix and are regular, namely rule 7, created for verbs like ”a dansa”. The second largest class, also as exp</context>
</contexts>
<marker>Pedregosa, Varoquaux, Gramfort, Michel, Thirion, Grisel, Blondel, Prettenhofer, Weiss, Dubourg, Vanderplas, Passos, Cournapeau, Brucher, Perrot, Duchesnay, 2011</marker>
<rawString>F. Pedregosa, G. Varoquaux, A. Gramfort, V. Michel, B. Thirion, O. Grisel, M. Blondel, P. Prettenhofer, R. Weiss, V. Dubourg, J. Vanderplas, A. Passos, D. Cournapeau, M. Brucher, M. Perrot, and E. Duchesnay. Scikit-learn: Machine learning in Python. Journal of Machine Learning Research, 12:2825– 2830, Oct 2011.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Valeria Guju</author>
</authors>
<title>Romalo. Morfologie Structural˘a a limbii romˆane. Editura Academiei Republicii Socialiste Romˆania,</title>
<date>1968</date>
<marker>Guju, 1968</marker>
<rawString>Valeria Guju Romalo. Morfologie Structural˘a a limbii romˆane. Editura Academiei Republicii Socialiste Romˆania, 1968.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>