<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<title confidence="0.97032">
SEMHE: A Generalised Two-Level System
</title>
<author confidence="0.968997">
George Anton Kiraz*
</author>
<affiliation confidence="0.987072">
Computer Laboratory
University of Cambridge (St John&apos;s College)
</affiliation>
<address confidence="0.542681">
Email: George .Kiraz@c1 . cam. ac .uk
</address>
<email confidence="0.894432">
URL: http://www.cl.cam.ac.uk/users/gkl05
</email>
<sectionHeader confidence="0.993863" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.99993175">
This paper presents a generalised two-
level implementation which can handle lin-
ear and non-linear morphological opera-
tions. An algorithm for the interpretation
of multi-tape two-level rules is described.
In addition, a number of issues which arise
when developing non-linear grammars are
discussed with examples from Syriac.
</bodyText>
<sectionHeader confidence="0.999394" genericHeader="introduction">
1 Introduction
</sectionHeader>
<bodyText confidence="0.991226">
The introduction of two-level morphology (Kosken-
niemi, 1983) and subsequent developments has made
implementing computational-morphology models a
feasible task. Yet, two-level formalisms fell short
from providing elegant means for the description of
non-linear operations such as infixation, circumfix-
ation and root-and-pattern morphology.1 As a re-
sult, two-level implementations — e.g. (Antworth,
1990; Karttunen, 1983; Karttunen and Beesley,
1992; Ritchie et al., 1992) — have always been bi-
ased towards linear morphology.
The past decade has seen a number of proposals
for handling non-linear morphology;2 however, none
* Supported by a Benefactor Studentship from St
John&apos;s College. This research was done under the super-
vision of Dr Stephen G. Pulman. Thanks to the anony-
mous reviewers for their comments. All mistakes remain
mine.
1 Although it is possible to express some classes of
non-linear rules using standard two-level formalisms by
means of ad hoc diacritics, e.g., infixation in (Antworth,
1990, p. 156), there are no means for expressing other
classes as root-and-pattern phenomena.
2(Kay, 1987), (Kataja and Koskenniemi, 1988),
(Beesley et al., 1989), (Lavie et al., 1990), (Beesley,
1990), (Beesley, 1991), (Kornai, 1991), (Wiebe, 1992),
(Pulman and Hepple, 1993), (Narayanan and Hashem,
1993), and (Bird and Ellison, 1994). See (Kiraz, 1996)
for a review.
(apart from Beesley&apos;s work) seem to have been im-
plemented over large descriptions, nor have they pro-
vided means by which the grammarian can develop
non-linear descriptions using higher level notation.
To test the validity of one&apos;s proposal or formalism,
minimally a medium-scale description is a desider-
atum. SemHe3 fulfils this requirement. It is a gen-
eralised multi-tape two-level system which is being
used in developing non-linear grammars.
This paper (1) presents the algorithms behind
SemHe; (2) discusses the issues involved in compil-
ing non-linear descriptions; and (3) proposes exten-
sion/solutions to make writing non-linear rules eas-
ier and more elegant. The paper assumes knowledge
of multi-tape two-level morphology (Kay, 1987; Ki-
raz, 1994c).
</bodyText>
<sectionHeader confidence="0.996815" genericHeader="method">
2 Linguistic Descriptions
</sectionHeader>
<bodyText confidence="0.999917833333333">
The linguist provides SemHe with three pieces of
data: a lexicon, two-level rules and word formation
grammar. All entries take the form of Prolog terms.&apos;
(Identifiers starting with an uppercase letter denote
variables, otherwise they are instantiated symbols.)
A lexical entry is described by the term
</bodyText>
<equation confidence="0.75657125">
synword( (morpheme) , (category)).
Categories are of the form
(category _symbol) : [(f eature_attri = value].),
(f eature_attrn =- value)]
</equation>
<bodyText confidence="0.941038">
a notational variant of the PATR-II category formal-
ism (Shieber, 1986).
</bodyText>
<footnote confidence="0.998877714285714">
3The name SemHe (Syriac seintte &apos;rays&apos;) is not an
acronym, but the title of a grammatical treatise writ-
ten by the Syriac polymath (inter a/ia mathematician
and grammarian) Bar `Ebreiyo (1225-1286), viz. ktobo
dsernite &apos;The Book of Rays&apos;.
4We describe here the terms which are relevant to this
paper. For a full description, see (Kiraz, 1996).
</footnote>
<page confidence="0.995332">
159
</page>
<table confidence="0.876423666666667">
thalphabet(0, [k,t,b,a,e]). % surface alphabet
thalphabet (1, Eci , c2 , c3 , v ,b1). thalphabet (2, [k , t ,b , b] ). thalphabet (3, [a, e , f]). % lexical alphabets
tl_set (radical , [k , t , b] ) tl_set (vowel , , e] ) tl_set (c 1c3 , , c3] ). % variable sets
tl_rule(R1, [ [1 , , 0] , [[L] , [b] , [b]] , [ 0 , 0 , 0], =&gt;, [1, , 0 ,
, [ , LI, [U). , , []] , =&gt;, 0 , [C], 0 ,
tl_rule(R2, [ , , 0], [[P] , [C] , ] , [
Ec1c3(P) , radical (C)] , [ , , [7]). =&gt;, , [v] , ,
tl_rule(R3, [ E] , [] , , [ [v] , 0 , [V] 1 , [ , , 0] ,
[vowel (V)], [ 0 , 0 , 0 ] ).
tl_rule(R4, [[] , , 0], 1[v] , , [V]] , [ [c2,v] , 0 , [3], &lt;=&gt;, , [1, 0,
tl_rule(R5, [vowel (V)] , , , 0]). , , [] , []] , &lt;=&gt;, , [C] , ,
tl_rule(R6, [0 , [] , [3], [[c2] , [C] , [measure=p al]] , 0]).
[radical (C)] , [[3, [root: , [ , , 0], &lt;=&gt;, , [c,c],
[ , , 0] , [ [c2] , [C] , []] [measure=pa&amp;quot; el]] ,[3]).
[radical (C)] , [ [] , [root:
</table>
<subsectionHeader confidence="0.438946">
Listing 1
</subsectionHeader>
<bodyText confidence="0.9160165">
A two-level rule is described using a syntactic vari-
ant of the formalism described by (Ruessink, 1989;
Pulman and Hepple, 1993), including the extensions
by (Kiraz, 1994c),
</bodyText>
<construct confidence="0.891917333333333">
ti_rule((id),(LLC), (Lex), (RLC), (Op),
(LSC), (Surf), (RSC),
(variables), (features)).
</construct>
<bodyText confidence="0.997476">
The arguments are: (1) a rule identifier, id; (2) the
left-lexical-context, LLC, the lexical center, Lex, and
the right-lexical-context, RLC, each in the form of a
list-of-lists, where the ith list represents the ith lex-
ical tape; (3) an operator, =&gt; for optional rules or
&lt;=&gt; for obligatory rules; (4) the left-surface-context,
LSC, the surface center, Surf, and the right-surface-
context, RSC, each in the form of a list; (5) a list
of the variables used in the lexical and surface ex-
pressions, each member in the form of a predicate
indicating the set identifier (see infra) and an argu-
ment indicating the variable in question; and (6) a
set of features (i.e. category forms) in the form of a
list-of-lists, where the ith item must unify with the
feature-structure of the morpheme affected by the
rule on the ith lexical tape.
A lexical string maps to a surface string iff (1)
they can be partitioned into pairs of lexical-surface
subsequences, where each pair is licenced by a rule,
and (2) no partition violates an obligatory rule.
Alphabet declarations take the form
tl_alphabet ((tape), (symbol_list)), and variable
sets are described by the predicate tl_set ((id),
(symbol_list)). Word formation rules take the form of
unification-based CFG rules, synrule((identifier),
(mother), Rclaug hteri), . • , (daughtern)D•
The following example illustrates the derivation
of Syriac /ktab/5 &apos;he wrote&apos; (in the simple p &apos;al
measurer from the pattern morpheme {cvcvc} &apos;ver-
bal pattern&apos;, root {ktb} &apos;notion of writing&apos;, and vo-
calism {a}. The three morphemes produce the un-
derlying form */katab/, which surfaces as /ktab/
since short vowels in open unstressed syllables are
deleted. The process is illustrated in (1).7
</bodyText>
<equation confidence="0.9204814">
a
(1) cvc vc
*/tab/ /ktab/
I I I
k t b
</equation>
<bodyText confidence="0.999362636363636">
The pa &amp;quot;el measure of the same verb, viz. /katteb/, is
derived by the gemination of the middle consonant
(i.e. t) and applying the appropriate vocalism lael.
The two-level grammar (Listing 1) assumes three
lexical tapes. Uninstantiated contexts are denoted
by an empty list. R1 is the morpheme boundary
b) rule. R2 and R3 sanction stem consonants
and vowels, respectively. R4 is the obligatory vowel
deletion rule. R5 and R6 map the second radical,
[t], for p &apos;al and pa &amp;quot;el forms, respectively. In this
example, the lexicon contains the entries in (2).8
</bodyText>
<listItem confidence="0.92067775">
(2) synword(c1vc2vc3, pattern :
synword(ktb, root: [measure = M]).
synword(aa, vocalism : [measure =- p`a11).
synword(ae, vocalism : [measure = pa&amp;quot;e1]).
</listItem>
<bodyText confidence="0.72202">
Note that the value of &apos;measure&apos; in the root entry is
</bodyText>
<footnote confidence="0.99698375">
5Spirantization is ignored here; for a discussion on
Syriac spirantization, see (Kiraz, 1995).
8Syriac verbs are classified under various measures
(forms). The basic ones are: p`al, pa&amp;quot;el and &apos;eel.
7This analysis is along the lines of (McCarthy, 1981)
— based on autosegrnental phonology (Goldsmith, 1976).
8Spreading is ignored here; for a discussion, see (Ki-
raz, 1994c).
</footnote>
<page confidence="0.995311">
160
</page>
<bodyText confidence="0.999436">
uninstantiated; it is determined from the feature val-
ues in R5, R6 and/or the word grammar (see infra,
§4.3).
affairs holds. Rules are then reasserted in the or-
der of their precedence value. This ensures that
rules which contain the most specified expressions
are tested first resulting in better performance.
</bodyText>
<sectionHeader confidence="0.996135" genericHeader="method">
3 Implementation
</sectionHeader>
<bodyText confidence="0.983015142857143">
There are two current methods for implement-
ing two-level rules (both implemented in SemHe):
(1) compiling rules into finite-state automata (multi-
tape transducers in our case), and (2) interpreting
rules directly. The former provides better perfor-
mance, while the latter facilitates the debugging of
grammars (by tracing and by providing debugging
utilities along the lines of (Carter, 1995)). Addi-
tionally, the interpreter facilitates the incremental
compilation of rules by simply allowing the user to
toggle rules on and off.
The compilation of the above formalism into au-
tomata is described by (Grimley-Evans et al., 1996).
The following is a description of the interpreter.
</bodyText>
<subsectionHeader confidence="0.995521">
3.1 Internal Representation
</subsectionHeader>
<bodyText confidence="0.999746666666667">
The word grammar is compiled into a shift-reduce
parser. In addition, a first-and-follow algorithm,
based on (Aho and Ullman, 1977), is applied to
compute the feasible follow categories for each cat-
egory type. The set of feasible follow categories,
NextCats, of a particular category Cat is returned
by the predicate FOLLow(+ Cat, —NextCats). Ad-
ditionally, FOLLOW(bos, NextCats) returns the set
of category symbols at the beginning of strings, and
eos E NextCats indicates that Cat may occur at the
end of strings.
The lexical component is implemented as charac-
ter tries (Knuth, 1973), one per tape. Given a list
of lexical strings, Lex, and a list of lexical pointers,
LexPtrs, the predicate
</bodyText>
<equation confidence="0.6298715">
LEXICAL-TRANSITIONS (+Lex, +LexPtrs,
—NewLexPtrs, —LexCats)
</equation>
<bodyText confidence="0.958629">
succeeds if there are transitions on Lex from LexP-
trs; it returns NewLexPtrs, and the categories, Lex-
Cats, at the end of morphemes, if any.
Two-level predicates are converted into an inter-
nal representation: (1) every left-context expression
is reversed and appended to an uninstantiated tail;
</bodyText>
<listItem confidence="0.650690888888889">
(2) every right-context expression is appended to an
uninstantiated tail; and (3) each rule is assigned a
6-bit &apos;precedence value&apos; where every bit represents
one of the six lexical and surface expressions. If an
expression is not an empty list (i.e. context is spec-
ified), the relevant bit is set. In analysis, surface
expressions are assigned the most significant bits,
while lexical expressions are assigned the least sig-
nificant ones. In generation, the opposite state of
</listItem>
<subsectionHeader confidence="0.999845">
3.2 The Interpreter Algorithm
</subsectionHeader>
<bodyText confidence="0.980444621621622">
The algorithms presented below are given in terms
of prolog-like non-deterministic operations. A clause
is satisfied if all the conditions under it are satisfied.
The predicates are depicted top-down in (3). (SemHe
makes use of an earlier implementation by (Pulman
and Hepple, 1993).)
In order to minimise accumulator-passing ar-
guments, we assume the following initially-empty
stacks: Pars eStack accumulates the category struc-
tures of the morphemes identified, and FeatureStack
maintains the rule features encountered so far. (`+&apos;
indicates concatenation.)
PARTITION partitions a two-level analysis into se-
quences of lexical-surface pairs, each licenced by a
rule. The base case of the predicate is given in List-
ing 2,9 and the recursive case in Listing 3.
The recursive COERCE predicate ensures that no
partition is violated by an obligatory rule. It takes
three arguments: Result is the output of PARTITION
(usually reversed by the calling predicate, hence,
COERCE deals with the last partition first), PreyCats
is a register which keeps track of the last morpheme
category encountered, and Partition returns selected
elements from Result. The base case of the predicate
is simply COERCE( -, ) — i.e., no more par-
titions. The recursive case is shown in Listing 4.
CurrentCats keeps track of the category of the mor-
pheme which occures in the current partition. The
invalidity of a partition is determined by INVALID-
PARTITION (Listing 5).
TWO-LEVEL-ANALYSIS (Listing 6) is the main
predicate. It takes a surface string or lexical
string(s) and returns a list of partitions and a
9For efficiency, variables appearing in left-context
and centre expressions are evaluated after LEXICAL-
TRANSITIONS since they will be fully instantiated then;
only right-contexts are evaluated after the recursion.
</bodyText>
<figure confidence="0.960616829787234">
Two-Level-Analysis
Shift-Reduce
Invalid-Partition
161
PARTITION(SurfDone, Surf ToDo, LexDone, LexToDo, LexPtrs, NextCats, Result)
Surf ToDo -= &amp; % surface string exhausted
LexToDo = ED , , • • &amp;c % all lexical strings exhausted
LexPtrs = [rt ,rt • • , rt] % all lexical pointers are at the root node
eos E NextCats &amp; % end-of-string
Result = 0. % output: no more results
Listing 2
PARTITION (SurfDone, Surf ToDo, LexDone, LexToDo, LexPtrs, NextCats,
[ResultHead I Result Tail])
there is thrule(id, LLC, Lex, RLC, Op, LSC, Surf, RSC, Variables, Features) such that
(Op = (=&gt; or &lt;=&gt;), LexDone = LLC, SurfDone LSC,
Surf ToDo = Surf + RSC and LexToDo = Lex + RLC) &amp;
LEXICAL-TRANSITIONS(Lex, LexPtrs, NewLexPtrs, LexCats) &amp;
push Features onto FeatureStack &amp; % keep track of rule features
if LexCats 0 nil then % found a morpheme boundary?
while FeatureStack is not empty % unify rule and lexical features
unify LexCats with (pop FeatureStack) &amp;
push LexCats onto ParseStack &amp; % update the parse stack
if LexCats E NextCats then % get next category
FoLLOW(LexCats, NewNextCats)
end if &amp;
ResultHead = Id/SurfDone/Surf/RSC/
LexDone/Lex/RLC/LexCats &amp;
NewSurfDone = SurfDone + reverse Surf &amp; % make new arguments.
NewSurfToDo = RSC &amp; % ... and recurse
NewLexDone = LexDone + reverse Lex &amp;
NewLexToDo = RLC &amp;
PARTITION(NewSurfDone, NewSurfToDo,
NewLexDone, NewLexToDo,
NewLexPtrs, NewNextCats, Result Tail) &amp;
for all SetId(Var) E Variables % check variables
there is tl_set(Set/d, Set) such that Var E Set.
Listing 3
CoERcE([1d/LSC/Surf/RSCALC/Lex/RLC/LexCats I Result Tail], PrevCats,
[Id/Surf/Lex I Partition Tail])
if LexCats 0 nil then
CurrentCats = LexCats
else
CurrentCats = Prey Cats &amp;
not INVALID-PARTITIoN(LSC, Surf, RSC, LLC, Lex, RLC, CurrentCats) &amp;
CoERcE(ResultTail, CurrentCats, Partition Tail).
Listing 4
INVALID-PARTITIoN(LSC, Surf, RSC, LLC, Lex, RLC, Cats)
</figure>
<footnote confidence="0.824486">
there is tl_rule(id, LLC, Lex, RLC, &lt;=&gt;, LSC, NotSurf, RSC, Variables, Features) such that
NotSurf 0 Surf &amp;
for all SetId(Var) E Variables % check variables
there is tl_set(Set/d, Set) such that Var E Set &amp;
unify Cats with Features &amp;
</footnote>
<note confidence="0.447517">
fail.
Listing 5
</note>
<page confidence="0.956475">
162
</page>
<table confidence="0.8106015">
Two-LEVEL-ANALYsis(?Surf, ?Lex, -Partition, -Parse)
FonoW(bos, NextCats) &amp;
PARTITION( 0, Surf, [1] , • • , , Lex, [rt ,rt , • • • , rt] , NextCats, Result) &amp;
CoERoE(reverse Result, nil, Partition) &amp;
SHIFT-REDucE(ParseStack, Parse).
Listing 6
</table>
<bodyText confidence="0.9146066">
morphosyntactic parse tree. To analyse a sur-
face form, one calls Two-LEvEL-ANALYsis(+Surf,
-Lex, -Partition, -Parse). To generate a surface
form, one calls Two-LEVEL-ANALYSIS(-Surf, +Lex,
-Partition, -Parse).
</bodyText>
<sectionHeader confidence="0.985246" genericHeader="method">
4 Developing Non-Linear Grammars
</sectionHeader>
<bodyText confidence="0.999899875">
When developing Semitic grammars, one comes
across various issues and problems which normally
do not arise with linear grammars. Some can be
solved by known methods or `tricks&apos;; others require
extensions in order to make developing grammars
easier and more elegant. This section discuss issues
which normally do not arise when compiling linear
grammars.
</bodyText>
<subsectionHeader confidence="0.9986">
4.1 Linearity vs. Non-Linearity
</subsectionHeader>
<bodyText confidence="0.995668481481481">
In Semitic languages, non-linearity occurs only in
stems. Hence, lexical descriptions of stems make
use of three lexical tapes (pattern, root &amp; vocalism),
while those of prefixes and suffixes use the first lexi-
cal tape. This requires duplicating rules when stat-
ing lexical constraints. Consider rule R4 (Listing 1).
It allows the deletion of the first stem vowel by the
virtue of RLC (even if c2 was not indexed); hence
/katab/ —&gt; /ktab/. Now consider adding the suffix
{eh} &apos;him/it&apos;: /katab/+{eh} /katbeh/, where the
second stem vowel is deleted since deletion applies
right-to-left; however, RLC can only cope with stem
vowels. Rule R7 (Listing 7) is required. One might
suggest placing constraints on surface expressions in-
stead. However, doing so causes surface expressions
to be dependent on other rules.
Additionally, Lex in R4 and R7 deletes stem vow-
els. Consider adding the prefix {wa} &apos;and&apos;: {wa}
/Icatab/ -I- {eh} -4 /wkatbeh/, where the prefix
vowel is also deleted. To cope with this, two addi-
tional rules like R4 and R7 are required, but with
Lex = [ [V] , , ] •
We resolve this by allowing the user to write ex-
pansion rules of the from
expand((symbo/), (expansion), (variables)).
In our example, the expansion rules in (4) are
needed.
</bodyText>
<listItem confidence="0.519179">
(4) expand(C, [ [C] , [1, ] , [radical (C)] ).
</listItem>
<bodyText confidence="0.991800428571429">
expand(C, [Cc] , [C] , [radical (C)] ).
expand(V, 1[V] , 0 ,C]], [vowel (V)] ).
expand(V, [[v], , [V]] , [vowel (V)] ).
The linguist can then rewrite R4 as R8 (Listing 7),
and expand it with the command expand (R8) . This
produces four rules of the form of R4, but with the
following expressions for Lex and RLC:1°
</bodyText>
<equation confidence="0.780801">
Lex RLC
[[U] [[C ,V2] , ,
[[V1] , 1] , [Cc,v] , [C] , [V2]]
[[vi, [] ,[Vi]] [CC, V2] , ,
</equation>
<bodyText confidence="0.848882">
[v] , 0 , EV1] [c , v] , [C] , [V2] ]
</bodyText>
<subsectionHeader confidence="0.984411">
4.2 Vocalisation
</subsectionHeader>
<bodyText confidence="0.995311916666667">
Orthographically, Semitic texts are written without
short vowels. It was suggested by (Beesley et al.,
1989, et. seq.) and (Kiraz, 1994c) to allow short
vowels to be optionally deleted. This, however, puts
a constraint on the grammar: no surface expres-
sion can contain a vowel, lest the vowel is optionally
deleted.
We assume full vocalisation in writing rules. A
second set of rules can allow the deletion of vowels.
The whole grammar can be taken as the composition
of the two grammars: e.g. {cvcvc},{ktb},{aa}
/ktab/ [ktab, ktb].
</bodyText>
<subsectionHeader confidence="0.998875">
4.3 Morphosyntactic Issues
</subsectionHeader>
<bodyText confidence="0.999954375">
Finite-state models of two-level morphology im-
plement morphotactics in two ways: using &apos;con-
tinuation patterns/classes&apos; (Koskenniemi, 1983;
Antworth, 1990; Karttunen, 1993) or unification-
based grammars (Bear, 1986; Ritchie et al., 1992).
The former fails to provide elegant morphosyntactic
parsing for Semitic languages, as will be illustrated
in this section.
</bodyText>
<subsubsectionHeader confidence="0.65407">
4.3.1 Stems and X-Theory
</subsubsectionHeader>
<bodyText confidence="0.9996758">
A pattern, a root and a vocalism do not alway
produce a free stem which can stand on its own. In
Syriac, for example, some verbal forms are bound:
they require a stem morpheme which indicates the
measure in question, e.g. the prefix {Pa} for eel
</bodyText>
<footnote confidence="0.624916">
&apos;Note, however, that the expand command does not
insert b randomly in context expressions.
</footnote>
<page confidence="0.980297">
163
</page>
<equation confidence="0.82927725">
tl_rule(R7, [ , [] , ] , [ [v] , , [V] ] , [ [c3 , b , e] , [] , [] ] , &lt;=&gt;, [] , 0, C],
[vowel (V)] , [C], , ] ).
tl_rule(R8, , [V1], [C , V2] , &lt;=&gt;, [1, 1] , [1,
[vowel (V1) , vowel (V2) , radical (C) ] , [[1, , ] ).
</equation>
<table confidence="0.909667238095238">
Listing 7
synrule(rulel, stem: [X=-2 ,measure=M ,measure=p al I pa&amp;quot; el] ,
[pattern: 0 , root : [measure=M,measure=p al I pa&amp;quot; el] ,
vocalism: [measure=M,measure=p al I pa&amp;quot; el] D.
synrule(rule2, stem: [X=-2 ,measure=M] ,
[stem_af f ix : [measure=M] ,
pattern: [] , root : [measure=M] , vocalism: [measure=M]]).
synrule(rule3, stem: [X=-1,measure=M,mood=act] ,
[stem: [bar=-2 ,measure=M , mood=act]
synrule(rule4, stem: [X=-1 ,measure=M ,mood=pass] ,
[reflexive: [3, stem: [X=-2 ,measure=M , mood=pas s] ])
synrule(rule5, stem: [X_=0 ,measure=M ,mood=MD ,npg=s8akm] ,
[stem: [X=-1 ,measure=M,mood=MD]]).
synrule(rule6, stem: [X=0 ,measure=M ,mood=MD , npg=NPG] ,
[stem: [X=-1,measure=M ,mood=MD] , vim: [type=suf f , circum=no , npg=NPG]]).
synrule(rule7, stem: [X=0 ,measure=M,mood=MD ,npg=NPG] ,
[vim: [type=pref , circum=no ,npg=NPG] , stem: [X=-1 ,measure=M ,mood=MD] I).
synrule(rule8, stem: [X=0 ,measure=M ,mood=MD , npg=NPG] ,
[vim: [type=pref , circum=yes ,npg=NPG] , stem: [X=-1 ,measure=M ,mood=MD]
vim: [type=suf f , circum=yes , npg=NPG] 1).
Listing 8
</table>
<bodyText confidence="0.999267333333333">
stems. Additionally, passive forms are marked by
the reflexive morpheme {Pet}, while active forms
are not marked at all.
This structure of stems can be handled hierarchi-
cally using X-theory. A stem whose stem morpheme
is known is assigned Y=-2 (Rules 1-2 in Listing 8).
Rules which indicate mood can apply only to stems
whose measure has been identified (i.e. they have
X=-2). The resulting stems are assigned X=-1 (Rules
3-4 in Listing 8). The parsing of Syriac petkteb/
(from {et}±/kateb/ after the deletion of /a/ by R4)
appears in (5).11
</bodyText>
<listItem confidence="0.5256615">
(5) stem: X.-1]
reflexive stem: X=-2)
</listItem>
<bodyText confidence="0.910619875">
Pet pattern root vocalism
cvcvc ktb ae
Now free stems which may stand on their own
can be assigned X=0. However, some stems require
111n the remaining examples, it is assumed that the
lexicon and two-level rules are expanded to cater for the
new material.
verbal inflectional markers.
</bodyText>
<subsectionHeader confidence="0.921679">
4.3.2 Verbal Inflectional Markers
</subsectionHeader>
<bodyText confidence="0.9434785">
With respect to verbal inflexional markers
(VIMs), there are various types of Semitic verbs:
those which do not require a VIM (e.g. sing. 3rd
masc.), and those which require a VIM in the form
of a prefix (e.g. perfect), suffix (e.g. some imperfect
forms), or circumfix (e.g. other imperfect forms).
Each VIM is lexically marked inter alia with two
features: &apos;type&apos; which states whether it is a prefix or
a suffix, and &apos;circum&apos; which denotes whether it is a
circumfix. Rules 5-8 (Listing 8) handle this.
The parsing of Syriac /netkatbun/ (from Inel+
{Pet}±/katab/-1-{un}) appears in (6).
(6)
stem: X=0]
Pet pattern root vocalism
cvcvc ktb aa
vim stem: 5C=-1] vim
ne reflexive stem:[X.-=-2] un
</bodyText>
<page confidence="0.919836">
164
</page>
<table confidence="0.998735714285714">
Verb Class Inflections Analysed 1st Analysis Subsequent Analysis Mean
(sec/word) (sec/word) (sec/word)
Strong 78 5.053 0.028 2.539
Initial min 52 6.756 0.048 3.404
Initial tilaph 57 4.379 0.077 2.228
Middle alaph 67 5.107 0.061 2.584
Overall mean 63.5 5.324 0.054 2.689
</table>
<tableCaption confidence="0.999018">
Table 1
</tableCaption>
<bodyText confidence="0.997976857142857">
(Beesley et al., 1989) handle this problem by find-
ing a logical expression for the prefix and suffix por-
tions of circumfix morphemes, and use unification to
generate only the correct forms — see (Sproat, 1992,
p. 158). This approach, however, cannot be used
here since, unlike Arabic, not all Syriac VIMs are in
the form of circumfixes.
</bodyText>
<subsectionHeader confidence="0.918863">
4.3.3 Interfacing with a Syntactic Parser
</subsectionHeader>
<bodyText confidence="0.999944875">
A Semitic &apos;word&apos; (string separated by word bound-
ary) may in fact be a clause or a sentence. There-
fore, a morphosyntactic parsing of a &apos;word&apos; may be a
(partial) syntactic parsing of a sentence in the form
of a (partial) tree. The output of a morphologi-
cal analyser can be structured in a manner suitable
for syntactic processing. Using tree-adjoining gram-
mars (Joshi, 1985) might be a possibility.
</bodyText>
<sectionHeader confidence="0.998898" genericHeader="evaluation">
5 Performance
</sectionHeader>
<bodyText confidence="0.973423342105263">
To test the integrity, robustness and performance
of the implementation, a two-level grammar of the
most frequent words in the Syriac New Testament
was compiled based on the data in (Kiraz, 1994b).
The grammar covers most classes of verbal and nom-
inal forms, in addition to prepositions, proper nouns
and words of Greek origin. A wider coverage would
involve enlarging the lexicon (currently there are 165
entries) and might triple the number of two-level
rules (currently there are c. 50 rules).
Table 1 provides the results of analysing verbal
classes. The test for each class represents analysing
most of its inflexions. The test was executed on a
Sparc ELC computer.
By constructing a corpus which consists only of
the most frequent words, one can estimate the per-
formance of analysing the corpus as follows,
p 5.324n + Ein_i 0.054(fi — 1)
Ell fi
where n is the number of distinct words in the corpus
and fi is the frequency of occurrence of the ith word.
The SEDRA database (Kiraz, 1994a) provides such
data. All occurrences of the 100 most frequent lex-
emes in their various inflections (a total of 72,240
occurrences) can be analysed at the rate of 16.35
words/sec. (Performance will be less if additional
rules are added for larger coverage.)
The results may not seem satisfactory when com-
pared with other prolog implementations of the same
formalism (cf. 50 words/sec, in (Carter, 1995)). One
should, however, keep in mind the complexity of Syr-
iac morphology. In addition to morphological non-
linearity, phonological conditional changes — conso-
nantal and vocalic — occur in all stems, and it is
not unusual to have more than five such changes
per word. Once developed, a grammar is usually
compiled into automata which provides better per-
formance.
</bodyText>
<sectionHeader confidence="0.999233" genericHeader="conclusions">
6 Conclusion
</sectionHeader>
<bodyText confidence="0.999994666666667">
This paper has presented a computational morphol-
ogy system which is adequate for handling non-linear
grammars. We are currently expanding the gram-
mar to cover the whole of New Testament Syriac.
One of our future goals is to optimise the prolog im-
plementation for speedy processing and to add de-
bugging facilities along the lines of (Carter, 1995).
For useful results, a Semitic morphological anal-
yser needs to interact with a syntactic parser in order
to resolve ambiguities. Most non-vocalised strings
give more than one solution, and some inflectional
forms are homographs even if fully vocalised (e.g. in
Syriac imperfect verbs: sing. 3rd masc. = plural 1st
common, and sing. 3rd fern. = sing. 2nd masc.). We
mentioned earlier the possibility of using TAGs.
</bodyText>
<sectionHeader confidence="0.998875" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.988494666666667">
Aho, A. and Ullman, J. (1977). Principles of Com-
piler Design. Addison-Wesley.
Antworth, E. (1990). PC-KIMMO: A two-Level
Processor for Morphological Analysis. Occasional
Publications in Academic Computing 16. Summer
Institute of Linguistics, Dallas.
Bear, J. (1986). A morphological recognizer with
syntactic and phonological rules. In COLING-86,
pages 272-6.
</reference>
<page confidence="0.8082765">
sec/word
165
</page>
<reference confidence="0.9990163814433">
Beesley, K. (1990). Finite-state description of Ara-
bic morphology. In Proceedings of the Second
Cambridge Conference: Bilingual Computing in
Arabic and English.
Beesley, K. (1991). Computer analysis of Arabic
morphology. In Comrie, B. and Eid, M., edi-
tors, Perspectives on Arabic Linguistics III: Pa-
pers from the Third Annual Symposium on Arabic
Linguistics. Benjamins, Amsterdam.
Beesley, K., Buckwalter, T., and Newton, S. (1989).
Two-level finite-state analysis of Arabic morphol-
ogy. In Proceedings of the Seminar on Bilingual
Computing in Arabic and English. The Literary
and Linguistic Computing Centre, Cambridge.
Bird, S. and Ellison, T. (1994). One-level phonology.
Computational Linguistics, 20(455-90.
Carter, D. (1995). Rapid development of morpho-
logical descriptions for full language processing
systems. In EA CL-95, pages 202-9.
Goldsmith, J. (1976). Autosegmental Phonology.
PhD thesis, MIT. Published as Autosegmental
and Metrical Phonology, Oxford 1990.
Grimley-Evans, E., Kiraz, G., and Pulman, S.
(1996). Compiling a partition-based two-level for-
malism. In COLING-96. Forthcoming.
Joshi, A. (1985). Tree-adjoining grammars: How
much context sensitivity is required to provide
reasonable structural descriptions. In Dowty, D.,
Karttunen, L., and Zwicky, A., editors, Natural
Language Parsing. Cambridge University Press.
Karttunen, L. (1983). Kimmo: A general mor-
phological processor. Texas Linguistic Forum,
22:165-86.
Karttunen, L. (1993). Finite-state lexicon compiler.
Technical report, Palo Alto Research Center, Xe-
rox Corporation.
Karttunen, L. and Beesley, K. (1992). Two-level rule
compiler. Technical report, Palo Alto Research
Center, Xerox Corporation.
Kataja, L. and Koskenniemi, K. (1988). Finite state
description of Semitic morphology. In COLING-
88, volume 1, pages 313-15.
Kay, M. (1987). Nonconcatenative finite-state mor-
phology. In EACL-87, pages 2-10.
Kiraz, G. (1994a). Automatic concordance genera-
tion of Syriac texts. In Lavenant, R., editor, VI
Symposium Syriacum 1992, Orientalia Christiana
Analecta 247, pages 461-75. Pontificio Institutum
Studiorum Orientalium.
Kiraz, G. (1994b). Lexical Tools to the Syriac New
Testament. JSOT Manuals 7. Sheffield Academic
Press.
Kiraz, G. (1994c). Multi-tape two-level morphology:
a case study in Semitic non-linear morphology. In
COLING-94, volume 1, pages 180-6.
Kiraz, G. (1995). Introduction to Syriac Spirantiza-
tion. Bar Hebraeus Verlag, The Netherlands.
Kiraz, G. (1996). Computational Approach to Non-
Linear Morphology. PhD thesis, University of
Cambridge.
Knuth, D. (1973). The Art of Computer Program-
ming, volume 3. Addison-Wesley.
Kornai, A. (1991). Formal Phonology. PhD thesis,
Stanford Univers ity.
Koskenniemi, K. (1983). Two-Level Morphology.
PhD thesis, University of Helsinki.
Lavie, A., Itai, A., and Oman, U. (1990). On the
applicability of two level morphology to the in-
flection of Hebrew verbs. In Choueka, Y., editor,
Literary and Linguistic Computing 1988: Proceed-
ings of the 15th International Conference, pages
246-60.
McCarthy, J. (1981). A prosodic theory of non-
concatenative morphology. Linguistic Inquiry,
12(3):373-418.
Narayanan, A. and Hashem, L. (1993). On abstract
finite-state morphology. In EACL-93, pages 297-
304.
Pulman, S. and Hepple, M. (1993). A feature-based
formalism for two-level phonology: a description
and implementation. Computer Speech and Lan-
guage, 7:333-58.
Ritchie, G., Black, A., Russell, G., and Pulman,
S. (1992). Computational Morphology: Practical
Mechanisms for the English Lexicon. MIT Press,
Cambridge Mass.
Ruessink, H. (1989). Two level formalisms. Techni-
cal Report 5, Utrecht Working Papers in NLP.
Shieber, S. (1986). An Introduction to Unification-
Based Approaches to Grammar. CSLI Lecture
Notes Number 4. Center for the Study of Lan-
guage and Information, Stanford.
Sproat, R. (1992). Morphology and Computation.
MIT Press, Cambridge Mass.
Wiebe, B. (1992). Modelling autosegmental phonol-
ogy with multi-tape finite state transducers. Mas-
ter&apos;s thesis, Simon Fraser University.
</reference>
<page confidence="0.998748">
166
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.736882">
<title confidence="0.999846">SEMHE: A Generalised Two-Level System</title>
<author confidence="0.999536">George Anton Kiraz</author>
<affiliation confidence="0.9999095">Computer Laboratory University of Cambridge (St John&apos;s College)</affiliation>
<address confidence="0.82577">Kiraz@c1 . cam. ac .uk</address>
<abstract confidence="0.986727888888889">This paper presents a generalised twolevel implementation which can handle linear and non-linear morphological operations. An algorithm for the interpretation of multi-tape two-level rules is described. In addition, a number of issues which arise when developing non-linear grammars are discussed with examples from Syriac.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>A Aho</author>
<author>J Ullman</author>
</authors>
<date>1977</date>
<booktitle>Principles of Compiler Design.</booktitle>
<publisher>Addison-Wesley.</publisher>
<contexts>
<context position="8790" citStr="Aho and Ullman, 1977" startWordPosition="1450" endWordPosition="1453"> former provides better performance, while the latter facilitates the debugging of grammars (by tracing and by providing debugging utilities along the lines of (Carter, 1995)). Additionally, the interpreter facilitates the incremental compilation of rules by simply allowing the user to toggle rules on and off. The compilation of the above formalism into automata is described by (Grimley-Evans et al., 1996). The following is a description of the interpreter. 3.1 Internal Representation The word grammar is compiled into a shift-reduce parser. In addition, a first-and-follow algorithm, based on (Aho and Ullman, 1977), is applied to compute the feasible follow categories for each category type. The set of feasible follow categories, NextCats, of a particular category Cat is returned by the predicate FOLLow(+ Cat, —NextCats). Additionally, FOLLOW(bos, NextCats) returns the set of category symbols at the beginning of strings, and eos E NextCats indicates that Cat may occur at the end of strings. The lexical component is implemented as character tries (Knuth, 1973), one per tape. Given a list of lexical strings, Lex, and a list of lexical pointers, LexPtrs, the predicate LEXICAL-TRANSITIONS (+Lex, +LexPtrs, —</context>
</contexts>
<marker>Aho, Ullman, 1977</marker>
<rawString>Aho, A. and Ullman, J. (1977). Principles of Compiler Design. Addison-Wesley.</rawString>
</citation>
<citation valid="true">
<authors>
<author>E Antworth</author>
</authors>
<title>PC-KIMMO: A two-Level Processor for Morphological Analysis.</title>
<date>1990</date>
<booktitle>Occasional Publications in Academic Computing 16. Summer Institute of Linguistics,</booktitle>
<location>Dallas.</location>
<contexts>
<context position="950" citStr="Antworth, 1990" startWordPosition="125" endWordPosition="126">algorithm for the interpretation of multi-tape two-level rules is described. In addition, a number of issues which arise when developing non-linear grammars are discussed with examples from Syriac. 1 Introduction The introduction of two-level morphology (Koskenniemi, 1983) and subsequent developments has made implementing computational-morphology models a feasible task. Yet, two-level formalisms fell short from providing elegant means for the description of non-linear operations such as infixation, circumfixation and root-and-pattern morphology.1 As a result, two-level implementations — e.g. (Antworth, 1990; Karttunen, 1983; Karttunen and Beesley, 1992; Ritchie et al., 1992) — have always been biased towards linear morphology. The past decade has seen a number of proposals for handling non-linear morphology;2 however, none * Supported by a Benefactor Studentship from St John&apos;s College. This research was done under the supervision of Dr Stephen G. Pulman. Thanks to the anonymous reviewers for their comments. All mistakes remain mine. 1 Although it is possible to express some classes of non-linear rules using standard two-level formalisms by means of ad hoc diacritics, e.g., infixation in (Antwort</context>
<context position="17461" citStr="Antworth, 1990" startWordPosition="2841" endWordPosition="2842">l., 1989, et. seq.) and (Kiraz, 1994c) to allow short vowels to be optionally deleted. This, however, puts a constraint on the grammar: no surface expression can contain a vowel, lest the vowel is optionally deleted. We assume full vocalisation in writing rules. A second set of rules can allow the deletion of vowels. The whole grammar can be taken as the composition of the two grammars: e.g. {cvcvc},{ktb},{aa} /ktab/ [ktab, ktb]. 4.3 Morphosyntactic Issues Finite-state models of two-level morphology implement morphotactics in two ways: using &apos;continuation patterns/classes&apos; (Koskenniemi, 1983; Antworth, 1990; Karttunen, 1993) or unificationbased grammars (Bear, 1986; Ritchie et al., 1992). The former fails to provide elegant morphosyntactic parsing for Semitic languages, as will be illustrated in this section. 4.3.1 Stems and X-Theory A pattern, a root and a vocalism do not alway produce a free stem which can stand on its own. In Syriac, for example, some verbal forms are bound: they require a stem morpheme which indicates the measure in question, e.g. the prefix {Pa} for eel &apos;Note, however, that the expand command does not insert b randomly in context expressions. 163 tl_rule(R7, [ , [] , ] , [ </context>
</contexts>
<marker>Antworth, 1990</marker>
<rawString>Antworth, E. (1990). PC-KIMMO: A two-Level Processor for Morphological Analysis. Occasional Publications in Academic Computing 16. Summer Institute of Linguistics, Dallas.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Bear</author>
</authors>
<title>A morphological recognizer with syntactic and phonological rules.</title>
<date>1986</date>
<booktitle>In COLING-86,</booktitle>
<pages>272--6</pages>
<contexts>
<context position="17520" citStr="Bear, 1986" startWordPosition="2849" endWordPosition="2850"> be optionally deleted. This, however, puts a constraint on the grammar: no surface expression can contain a vowel, lest the vowel is optionally deleted. We assume full vocalisation in writing rules. A second set of rules can allow the deletion of vowels. The whole grammar can be taken as the composition of the two grammars: e.g. {cvcvc},{ktb},{aa} /ktab/ [ktab, ktb]. 4.3 Morphosyntactic Issues Finite-state models of two-level morphology implement morphotactics in two ways: using &apos;continuation patterns/classes&apos; (Koskenniemi, 1983; Antworth, 1990; Karttunen, 1993) or unificationbased grammars (Bear, 1986; Ritchie et al., 1992). The former fails to provide elegant morphosyntactic parsing for Semitic languages, as will be illustrated in this section. 4.3.1 Stems and X-Theory A pattern, a root and a vocalism do not alway produce a free stem which can stand on its own. In Syriac, for example, some verbal forms are bound: they require a stem morpheme which indicates the measure in question, e.g. the prefix {Pa} for eel &apos;Note, however, that the expand command does not insert b randomly in context expressions. 163 tl_rule(R7, [ , [] , ] , [ [v] , , [V] ] , [ [c3 , b , e] , [] , [] ] , &lt;=&gt;, [] , 0, C</context>
</contexts>
<marker>Bear, 1986</marker>
<rawString>Bear, J. (1986). A morphological recognizer with syntactic and phonological rules. In COLING-86, pages 272-6.</rawString>
</citation>
<citation valid="true">
<authors>
<author>K Beesley</author>
</authors>
<title>Finite-state description of Arabic morphology.</title>
<date>1990</date>
<booktitle>In Proceedings of the Second Cambridge Conference: Bilingual Computing in Arabic and English.</booktitle>
<contexts>
<context position="1754" citStr="Beesley, 1990" startWordPosition="251" endWordPosition="252">ear morphology;2 however, none * Supported by a Benefactor Studentship from St John&apos;s College. This research was done under the supervision of Dr Stephen G. Pulman. Thanks to the anonymous reviewers for their comments. All mistakes remain mine. 1 Although it is possible to express some classes of non-linear rules using standard two-level formalisms by means of ad hoc diacritics, e.g., infixation in (Antworth, 1990, p. 156), there are no means for expressing other classes as root-and-pattern phenomena. 2(Kay, 1987), (Kataja and Koskenniemi, 1988), (Beesley et al., 1989), (Lavie et al., 1990), (Beesley, 1990), (Beesley, 1991), (Kornai, 1991), (Wiebe, 1992), (Pulman and Hepple, 1993), (Narayanan and Hashem, 1993), and (Bird and Ellison, 1994). See (Kiraz, 1996) for a review. (apart from Beesley&apos;s work) seem to have been implemented over large descriptions, nor have they provided means by which the grammarian can develop non-linear descriptions using higher level notation. To test the validity of one&apos;s proposal or formalism, minimally a medium-scale description is a desideratum. SemHe3 fulfils this requirement. It is a generalised multi-tape two-level system which is being used in developing non-lin</context>
</contexts>
<marker>Beesley, 1990</marker>
<rawString>Beesley, K. (1990). Finite-state description of Arabic morphology. In Proceedings of the Second Cambridge Conference: Bilingual Computing in Arabic and English.</rawString>
</citation>
<citation valid="true">
<authors>
<author>K Beesley</author>
</authors>
<title>Computer analysis of Arabic morphology.</title>
<date>1991</date>
<booktitle>Perspectives on Arabic Linguistics III: Papers from the Third Annual Symposium on Arabic Linguistics. Benjamins,</booktitle>
<editor>In Comrie, B. and Eid, M., editors,</editor>
<location>Amsterdam.</location>
<contexts>
<context position="1771" citStr="Beesley, 1991" startWordPosition="253" endWordPosition="254">however, none * Supported by a Benefactor Studentship from St John&apos;s College. This research was done under the supervision of Dr Stephen G. Pulman. Thanks to the anonymous reviewers for their comments. All mistakes remain mine. 1 Although it is possible to express some classes of non-linear rules using standard two-level formalisms by means of ad hoc diacritics, e.g., infixation in (Antworth, 1990, p. 156), there are no means for expressing other classes as root-and-pattern phenomena. 2(Kay, 1987), (Kataja and Koskenniemi, 1988), (Beesley et al., 1989), (Lavie et al., 1990), (Beesley, 1990), (Beesley, 1991), (Kornai, 1991), (Wiebe, 1992), (Pulman and Hepple, 1993), (Narayanan and Hashem, 1993), and (Bird and Ellison, 1994). See (Kiraz, 1996) for a review. (apart from Beesley&apos;s work) seem to have been implemented over large descriptions, nor have they provided means by which the grammarian can develop non-linear descriptions using higher level notation. To test the validity of one&apos;s proposal or formalism, minimally a medium-scale description is a desideratum. SemHe3 fulfils this requirement. It is a generalised multi-tape two-level system which is being used in developing non-linear grammars. Thi</context>
</contexts>
<marker>Beesley, 1991</marker>
<rawString>Beesley, K. (1991). Computer analysis of Arabic morphology. In Comrie, B. and Eid, M., editors, Perspectives on Arabic Linguistics III: Papers from the Third Annual Symposium on Arabic Linguistics. Benjamins, Amsterdam.</rawString>
</citation>
<citation valid="true">
<authors>
<author>K Beesley</author>
<author>T Buckwalter</author>
<author>S Newton</author>
</authors>
<title>Two-level finite-state analysis of Arabic morphology.</title>
<date>1989</date>
<booktitle>In Proceedings of the Seminar on Bilingual Computing in Arabic and English. The Literary and Linguistic Computing Centre,</booktitle>
<location>Cambridge.</location>
<contexts>
<context position="1715" citStr="Beesley et al., 1989" startWordPosition="243" endWordPosition="246">een a number of proposals for handling non-linear morphology;2 however, none * Supported by a Benefactor Studentship from St John&apos;s College. This research was done under the supervision of Dr Stephen G. Pulman. Thanks to the anonymous reviewers for their comments. All mistakes remain mine. 1 Although it is possible to express some classes of non-linear rules using standard two-level formalisms by means of ad hoc diacritics, e.g., infixation in (Antworth, 1990, p. 156), there are no means for expressing other classes as root-and-pattern phenomena. 2(Kay, 1987), (Kataja and Koskenniemi, 1988), (Beesley et al., 1989), (Lavie et al., 1990), (Beesley, 1990), (Beesley, 1991), (Kornai, 1991), (Wiebe, 1992), (Pulman and Hepple, 1993), (Narayanan and Hashem, 1993), and (Bird and Ellison, 1994). See (Kiraz, 1996) for a review. (apart from Beesley&apos;s work) seem to have been implemented over large descriptions, nor have they provided means by which the grammarian can develop non-linear descriptions using higher level notation. To test the validity of one&apos;s proposal or formalism, minimally a medium-scale description is a desideratum. SemHe3 fulfils this requirement. It is a generalised multi-tape two-level system wh</context>
<context position="16855" citStr="Beesley et al., 1989" startWordPosition="2746" endWordPosition="2749">eeded. (4) expand(C, [ [C] , [1, ] , [radical (C)] ). expand(C, [Cc] , [C] , [radical (C)] ). expand(V, 1[V] , 0 ,C]], [vowel (V)] ). expand(V, [[v], , [V]] , [vowel (V)] ). The linguist can then rewrite R4 as R8 (Listing 7), and expand it with the command expand (R8) . This produces four rules of the form of R4, but with the following expressions for Lex and RLC:1° Lex RLC [[U] [[C ,V2] , , [[V1] , 1] , [Cc,v] , [C] , [V2]] [[vi, [] ,[Vi]] [CC, V2] , , [v] , 0 , EV1] [c , v] , [C] , [V2] ] 4.2 Vocalisation Orthographically, Semitic texts are written without short vowels. It was suggested by (Beesley et al., 1989, et. seq.) and (Kiraz, 1994c) to allow short vowels to be optionally deleted. This, however, puts a constraint on the grammar: no surface expression can contain a vowel, lest the vowel is optionally deleted. We assume full vocalisation in writing rules. A second set of rules can allow the deletion of vowels. The whole grammar can be taken as the composition of the two grammars: e.g. {cvcvc},{ktb},{aa} /ktab/ [ktab, ktb]. 4.3 Morphosyntactic Issues Finite-state models of two-level morphology implement morphotactics in two ways: using &apos;continuation patterns/classes&apos; (Koskenniemi, 1983; Antworth</context>
<context position="21210" citStr="Beesley et al., 1989" startWordPosition="3458" endWordPosition="3461">es whether it is a prefix or a suffix, and &apos;circum&apos; which denotes whether it is a circumfix. Rules 5-8 (Listing 8) handle this. The parsing of Syriac /netkatbun/ (from Inel+ {Pet}±/katab/-1-{un}) appears in (6). (6) stem: X=0] Pet pattern root vocalism cvcvc ktb aa vim stem: 5C=-1] vim ne reflexive stem:[X.-=-2] un 164 Verb Class Inflections Analysed 1st Analysis Subsequent Analysis Mean (sec/word) (sec/word) (sec/word) Strong 78 5.053 0.028 2.539 Initial min 52 6.756 0.048 3.404 Initial tilaph 57 4.379 0.077 2.228 Middle alaph 67 5.107 0.061 2.584 Overall mean 63.5 5.324 0.054 2.689 Table 1 (Beesley et al., 1989) handle this problem by finding a logical expression for the prefix and suffix portions of circumfix morphemes, and use unification to generate only the correct forms — see (Sproat, 1992, p. 158). This approach, however, cannot be used here since, unlike Arabic, not all Syriac VIMs are in the form of circumfixes. 4.3.3 Interfacing with a Syntactic Parser A Semitic &apos;word&apos; (string separated by word boundary) may in fact be a clause or a sentence. Therefore, a morphosyntactic parsing of a &apos;word&apos; may be a (partial) syntactic parsing of a sentence in the form of a (partial) tree. The output of a mo</context>
</contexts>
<marker>Beesley, Buckwalter, Newton, 1989</marker>
<rawString>Beesley, K., Buckwalter, T., and Newton, S. (1989). Two-level finite-state analysis of Arabic morphology. In Proceedings of the Seminar on Bilingual Computing in Arabic and English. The Literary and Linguistic Computing Centre, Cambridge.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S Bird</author>
<author>T Ellison</author>
</authors>
<title>One-level phonology.</title>
<date>1994</date>
<journal>Computational Linguistics,</journal>
<pages>20--455</pages>
<contexts>
<context position="1889" citStr="Bird and Ellison, 1994" startWordPosition="268" endWordPosition="271">e supervision of Dr Stephen G. Pulman. Thanks to the anonymous reviewers for their comments. All mistakes remain mine. 1 Although it is possible to express some classes of non-linear rules using standard two-level formalisms by means of ad hoc diacritics, e.g., infixation in (Antworth, 1990, p. 156), there are no means for expressing other classes as root-and-pattern phenomena. 2(Kay, 1987), (Kataja and Koskenniemi, 1988), (Beesley et al., 1989), (Lavie et al., 1990), (Beesley, 1990), (Beesley, 1991), (Kornai, 1991), (Wiebe, 1992), (Pulman and Hepple, 1993), (Narayanan and Hashem, 1993), and (Bird and Ellison, 1994). See (Kiraz, 1996) for a review. (apart from Beesley&apos;s work) seem to have been implemented over large descriptions, nor have they provided means by which the grammarian can develop non-linear descriptions using higher level notation. To test the validity of one&apos;s proposal or formalism, minimally a medium-scale description is a desideratum. SemHe3 fulfils this requirement. It is a generalised multi-tape two-level system which is being used in developing non-linear grammars. This paper (1) presents the algorithms behind SemHe; (2) discusses the issues involved in compiling non-linear descriptio</context>
</contexts>
<marker>Bird, Ellison, 1994</marker>
<rawString>Bird, S. and Ellison, T. (1994). One-level phonology. Computational Linguistics, 20(455-90.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D Carter</author>
</authors>
<title>Rapid development of morphological descriptions for full language processing systems.</title>
<date>1995</date>
<booktitle>In EA CL-95,</booktitle>
<pages>202--9</pages>
<contexts>
<context position="8343" citStr="Carter, 1995" startWordPosition="1384" endWordPosition="1385">4.3). affairs holds. Rules are then reasserted in the order of their precedence value. This ensures that rules which contain the most specified expressions are tested first resulting in better performance. 3 Implementation There are two current methods for implementing two-level rules (both implemented in SemHe): (1) compiling rules into finite-state automata (multitape transducers in our case), and (2) interpreting rules directly. The former provides better performance, while the latter facilitates the debugging of grammars (by tracing and by providing debugging utilities along the lines of (Carter, 1995)). Additionally, the interpreter facilitates the incremental compilation of rules by simply allowing the user to toggle rules on and off. The compilation of the above formalism into automata is described by (Grimley-Evans et al., 1996). The following is a description of the interpreter. 3.1 Internal Representation The word grammar is compiled into a shift-reduce parser. In addition, a first-and-follow algorithm, based on (Aho and Ullman, 1977), is applied to compute the feasible follow categories for each category type. The set of feasible follow categories, NextCats, of a particular category </context>
<context position="23372" citStr="Carter, 1995" startWordPosition="3826" endWordPosition="3827">nalysing the corpus as follows, p 5.324n + Ein_i 0.054(fi — 1) Ell fi where n is the number of distinct words in the corpus and fi is the frequency of occurrence of the ith word. The SEDRA database (Kiraz, 1994a) provides such data. All occurrences of the 100 most frequent lexemes in their various inflections (a total of 72,240 occurrences) can be analysed at the rate of 16.35 words/sec. (Performance will be less if additional rules are added for larger coverage.) The results may not seem satisfactory when compared with other prolog implementations of the same formalism (cf. 50 words/sec, in (Carter, 1995)). One should, however, keep in mind the complexity of Syriac morphology. In addition to morphological nonlinearity, phonological conditional changes — consonantal and vocalic — occur in all stems, and it is not unusual to have more than five such changes per word. Once developed, a grammar is usually compiled into automata which provides better performance. 6 Conclusion This paper has presented a computational morphology system which is adequate for handling non-linear grammars. We are currently expanding the grammar to cover the whole of New Testament Syriac. One of our future goals is to op</context>
</contexts>
<marker>Carter, 1995</marker>
<rawString>Carter, D. (1995). Rapid development of morphological descriptions for full language processing systems. In EA CL-95, pages 202-9.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Goldsmith</author>
</authors>
<title>Autosegmental Phonology.</title>
<date>1976</date>
<booktitle>PhD thesis, MIT. Published as Autosegmental and Metrical Phonology,</booktitle>
<location>Oxford</location>
<contexts>
<context position="7554" citStr="Goldsmith, 1976" startWordPosition="1262" endWordPosition="1263">], for p &apos;al and pa &amp;quot;el forms, respectively. In this example, the lexicon contains the entries in (2).8 (2) synword(c1vc2vc3, pattern : synword(ktb, root: [measure = M]). synword(aa, vocalism : [measure =- p`a11). synword(ae, vocalism : [measure = pa&amp;quot;e1]). Note that the value of &apos;measure&apos; in the root entry is 5Spirantization is ignored here; for a discussion on Syriac spirantization, see (Kiraz, 1995). 8Syriac verbs are classified under various measures (forms). The basic ones are: p`al, pa&amp;quot;el and &apos;eel. 7This analysis is along the lines of (McCarthy, 1981) — based on autosegrnental phonology (Goldsmith, 1976). 8Spreading is ignored here; for a discussion, see (Kiraz, 1994c). 160 uninstantiated; it is determined from the feature values in R5, R6 and/or the word grammar (see infra, §4.3). affairs holds. Rules are then reasserted in the order of their precedence value. This ensures that rules which contain the most specified expressions are tested first resulting in better performance. 3 Implementation There are two current methods for implementing two-level rules (both implemented in SemHe): (1) compiling rules into finite-state automata (multitape transducers in our case), and (2) interpreting rule</context>
</contexts>
<marker>Goldsmith, 1976</marker>
<rawString>Goldsmith, J. (1976). Autosegmental Phonology. PhD thesis, MIT. Published as Autosegmental and Metrical Phonology, Oxford 1990.</rawString>
</citation>
<citation valid="true">
<authors>
<author>E Grimley-Evans</author>
<author>G Kiraz</author>
<author>S Pulman</author>
</authors>
<title>Compiling a partition-based two-level formalism.</title>
<date>1996</date>
<booktitle>In COLING-96. Forthcoming.</booktitle>
<contexts>
<context position="8578" citStr="Grimley-Evans et al., 1996" startWordPosition="1419" endWordPosition="1422">n There are two current methods for implementing two-level rules (both implemented in SemHe): (1) compiling rules into finite-state automata (multitape transducers in our case), and (2) interpreting rules directly. The former provides better performance, while the latter facilitates the debugging of grammars (by tracing and by providing debugging utilities along the lines of (Carter, 1995)). Additionally, the interpreter facilitates the incremental compilation of rules by simply allowing the user to toggle rules on and off. The compilation of the above formalism into automata is described by (Grimley-Evans et al., 1996). The following is a description of the interpreter. 3.1 Internal Representation The word grammar is compiled into a shift-reduce parser. In addition, a first-and-follow algorithm, based on (Aho and Ullman, 1977), is applied to compute the feasible follow categories for each category type. The set of feasible follow categories, NextCats, of a particular category Cat is returned by the predicate FOLLow(+ Cat, —NextCats). Additionally, FOLLOW(bos, NextCats) returns the set of category symbols at the beginning of strings, and eos E NextCats indicates that Cat may occur at the end of strings. The </context>
</contexts>
<marker>Grimley-Evans, Kiraz, Pulman, 1996</marker>
<rawString>Grimley-Evans, E., Kiraz, G., and Pulman, S. (1996). Compiling a partition-based two-level formalism. In COLING-96. Forthcoming.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Joshi</author>
</authors>
<title>Tree-adjoining grammars: How much context sensitivity is required to provide reasonable structural descriptions.</title>
<date>1985</date>
<editor>In Dowty, D., Karttunen, L., and Zwicky, A., editors,</editor>
<publisher>Cambridge University Press.</publisher>
<contexts>
<context position="21939" citStr="Joshi, 1985" startWordPosition="3585" endWordPosition="3586">se unification to generate only the correct forms — see (Sproat, 1992, p. 158). This approach, however, cannot be used here since, unlike Arabic, not all Syriac VIMs are in the form of circumfixes. 4.3.3 Interfacing with a Syntactic Parser A Semitic &apos;word&apos; (string separated by word boundary) may in fact be a clause or a sentence. Therefore, a morphosyntactic parsing of a &apos;word&apos; may be a (partial) syntactic parsing of a sentence in the form of a (partial) tree. The output of a morphological analyser can be structured in a manner suitable for syntactic processing. Using tree-adjoining grammars (Joshi, 1985) might be a possibility. 5 Performance To test the integrity, robustness and performance of the implementation, a two-level grammar of the most frequent words in the Syriac New Testament was compiled based on the data in (Kiraz, 1994b). The grammar covers most classes of verbal and nominal forms, in addition to prepositions, proper nouns and words of Greek origin. A wider coverage would involve enlarging the lexicon (currently there are 165 entries) and might triple the number of two-level rules (currently there are c. 50 rules). Table 1 provides the results of analysing verbal classes. The te</context>
</contexts>
<marker>Joshi, 1985</marker>
<rawString>Joshi, A. (1985). Tree-adjoining grammars: How much context sensitivity is required to provide reasonable structural descriptions. In Dowty, D., Karttunen, L., and Zwicky, A., editors, Natural Language Parsing. Cambridge University Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>L Karttunen</author>
</authors>
<title>Kimmo: A general morphological processor. Texas Linguistic Forum,</title>
<date>1983</date>
<pages>22--165</pages>
<contexts>
<context position="967" citStr="Karttunen, 1983" startWordPosition="127" endWordPosition="128">e interpretation of multi-tape two-level rules is described. In addition, a number of issues which arise when developing non-linear grammars are discussed with examples from Syriac. 1 Introduction The introduction of two-level morphology (Koskenniemi, 1983) and subsequent developments has made implementing computational-morphology models a feasible task. Yet, two-level formalisms fell short from providing elegant means for the description of non-linear operations such as infixation, circumfixation and root-and-pattern morphology.1 As a result, two-level implementations — e.g. (Antworth, 1990; Karttunen, 1983; Karttunen and Beesley, 1992; Ritchie et al., 1992) — have always been biased towards linear morphology. The past decade has seen a number of proposals for handling non-linear morphology;2 however, none * Supported by a Benefactor Studentship from St John&apos;s College. This research was done under the supervision of Dr Stephen G. Pulman. Thanks to the anonymous reviewers for their comments. All mistakes remain mine. 1 Although it is possible to express some classes of non-linear rules using standard two-level formalisms by means of ad hoc diacritics, e.g., infixation in (Antworth, 1990, p. 156),</context>
</contexts>
<marker>Karttunen, 1983</marker>
<rawString>Karttunen, L. (1983). Kimmo: A general morphological processor. Texas Linguistic Forum, 22:165-86.</rawString>
</citation>
<citation valid="true">
<authors>
<author>L Karttunen</author>
</authors>
<title>Finite-state lexicon compiler.</title>
<date>1993</date>
<tech>Technical report,</tech>
<institution>Palo Alto Research Center, Xerox Corporation.</institution>
<contexts>
<context position="17479" citStr="Karttunen, 1993" startWordPosition="2843" endWordPosition="2844">q.) and (Kiraz, 1994c) to allow short vowels to be optionally deleted. This, however, puts a constraint on the grammar: no surface expression can contain a vowel, lest the vowel is optionally deleted. We assume full vocalisation in writing rules. A second set of rules can allow the deletion of vowels. The whole grammar can be taken as the composition of the two grammars: e.g. {cvcvc},{ktb},{aa} /ktab/ [ktab, ktb]. 4.3 Morphosyntactic Issues Finite-state models of two-level morphology implement morphotactics in two ways: using &apos;continuation patterns/classes&apos; (Koskenniemi, 1983; Antworth, 1990; Karttunen, 1993) or unificationbased grammars (Bear, 1986; Ritchie et al., 1992). The former fails to provide elegant morphosyntactic parsing for Semitic languages, as will be illustrated in this section. 4.3.1 Stems and X-Theory A pattern, a root and a vocalism do not alway produce a free stem which can stand on its own. In Syriac, for example, some verbal forms are bound: they require a stem morpheme which indicates the measure in question, e.g. the prefix {Pa} for eel &apos;Note, however, that the expand command does not insert b randomly in context expressions. 163 tl_rule(R7, [ , [] , ] , [ [v] , , [V] ] , [ </context>
</contexts>
<marker>Karttunen, 1993</marker>
<rawString>Karttunen, L. (1993). Finite-state lexicon compiler. Technical report, Palo Alto Research Center, Xerox Corporation.</rawString>
</citation>
<citation valid="true">
<authors>
<author>L Karttunen</author>
<author>K Beesley</author>
</authors>
<title>Two-level rule compiler.</title>
<date>1992</date>
<tech>Technical report,</tech>
<institution>Palo Alto Research Center, Xerox Corporation.</institution>
<contexts>
<context position="996" citStr="Karttunen and Beesley, 1992" startWordPosition="129" endWordPosition="132">of multi-tape two-level rules is described. In addition, a number of issues which arise when developing non-linear grammars are discussed with examples from Syriac. 1 Introduction The introduction of two-level morphology (Koskenniemi, 1983) and subsequent developments has made implementing computational-morphology models a feasible task. Yet, two-level formalisms fell short from providing elegant means for the description of non-linear operations such as infixation, circumfixation and root-and-pattern morphology.1 As a result, two-level implementations — e.g. (Antworth, 1990; Karttunen, 1983; Karttunen and Beesley, 1992; Ritchie et al., 1992) — have always been biased towards linear morphology. The past decade has seen a number of proposals for handling non-linear morphology;2 however, none * Supported by a Benefactor Studentship from St John&apos;s College. This research was done under the supervision of Dr Stephen G. Pulman. Thanks to the anonymous reviewers for their comments. All mistakes remain mine. 1 Although it is possible to express some classes of non-linear rules using standard two-level formalisms by means of ad hoc diacritics, e.g., infixation in (Antworth, 1990, p. 156), there are no means for expre</context>
</contexts>
<marker>Karttunen, Beesley, 1992</marker>
<rawString>Karttunen, L. and Beesley, K. (1992). Two-level rule compiler. Technical report, Palo Alto Research Center, Xerox Corporation.</rawString>
</citation>
<citation valid="true">
<authors>
<author>L Kataja</author>
<author>K Koskenniemi</author>
</authors>
<title>Finite state description of Semitic morphology.</title>
<date>1988</date>
<booktitle>In COLING88,</booktitle>
<volume>1</volume>
<pages>313--15</pages>
<contexts>
<context position="1691" citStr="Kataja and Koskenniemi, 1988" startWordPosition="239" endWordPosition="242">orphology. The past decade has seen a number of proposals for handling non-linear morphology;2 however, none * Supported by a Benefactor Studentship from St John&apos;s College. This research was done under the supervision of Dr Stephen G. Pulman. Thanks to the anonymous reviewers for their comments. All mistakes remain mine. 1 Although it is possible to express some classes of non-linear rules using standard two-level formalisms by means of ad hoc diacritics, e.g., infixation in (Antworth, 1990, p. 156), there are no means for expressing other classes as root-and-pattern phenomena. 2(Kay, 1987), (Kataja and Koskenniemi, 1988), (Beesley et al., 1989), (Lavie et al., 1990), (Beesley, 1990), (Beesley, 1991), (Kornai, 1991), (Wiebe, 1992), (Pulman and Hepple, 1993), (Narayanan and Hashem, 1993), and (Bird and Ellison, 1994). See (Kiraz, 1996) for a review. (apart from Beesley&apos;s work) seem to have been implemented over large descriptions, nor have they provided means by which the grammarian can develop non-linear descriptions using higher level notation. To test the validity of one&apos;s proposal or formalism, minimally a medium-scale description is a desideratum. SemHe3 fulfils this requirement. It is a generalised multi-</context>
</contexts>
<marker>Kataja, Koskenniemi, 1988</marker>
<rawString>Kataja, L. and Koskenniemi, K. (1988). Finite state description of Semitic morphology. In COLING88, volume 1, pages 313-15.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Kay</author>
</authors>
<title>Nonconcatenative finite-state morphology.</title>
<date>1987</date>
<booktitle>In EACL-87,</booktitle>
<pages>2--10</pages>
<contexts>
<context position="1659" citStr="Kay, 1987" startWordPosition="237" endWordPosition="238">ards linear morphology. The past decade has seen a number of proposals for handling non-linear morphology;2 however, none * Supported by a Benefactor Studentship from St John&apos;s College. This research was done under the supervision of Dr Stephen G. Pulman. Thanks to the anonymous reviewers for their comments. All mistakes remain mine. 1 Although it is possible to express some classes of non-linear rules using standard two-level formalisms by means of ad hoc diacritics, e.g., infixation in (Antworth, 1990, p. 156), there are no means for expressing other classes as root-and-pattern phenomena. 2(Kay, 1987), (Kataja and Koskenniemi, 1988), (Beesley et al., 1989), (Lavie et al., 1990), (Beesley, 1990), (Beesley, 1991), (Kornai, 1991), (Wiebe, 1992), (Pulman and Hepple, 1993), (Narayanan and Hashem, 1993), and (Bird and Ellison, 1994). See (Kiraz, 1996) for a review. (apart from Beesley&apos;s work) seem to have been implemented over large descriptions, nor have they provided means by which the grammarian can develop non-linear descriptions using higher level notation. To test the validity of one&apos;s proposal or formalism, minimally a medium-scale description is a desideratum. SemHe3 fulfils this require</context>
</contexts>
<marker>Kay, 1987</marker>
<rawString>Kay, M. (1987). Nonconcatenative finite-state morphology. In EACL-87, pages 2-10.</rawString>
</citation>
<citation valid="true">
<authors>
<author>G Kiraz</author>
</authors>
<title>Automatic concordance generation of Syriac texts.</title>
<date>1994</date>
<booktitle>VI Symposium Syriacum 1992, Orientalia Christiana Analecta 247,</booktitle>
<pages>461--75</pages>
<editor>In Lavenant, R., editor,</editor>
<contexts>
<context position="2674" citStr="Kiraz, 1994" startWordPosition="389" endWordPosition="391">develop non-linear descriptions using higher level notation. To test the validity of one&apos;s proposal or formalism, minimally a medium-scale description is a desideratum. SemHe3 fulfils this requirement. It is a generalised multi-tape two-level system which is being used in developing non-linear grammars. This paper (1) presents the algorithms behind SemHe; (2) discusses the issues involved in compiling non-linear descriptions; and (3) proposes extension/solutions to make writing non-linear rules easier and more elegant. The paper assumes knowledge of multi-tape two-level morphology (Kay, 1987; Kiraz, 1994c). 2 Linguistic Descriptions The linguist provides SemHe with three pieces of data: a lexicon, two-level rules and word formation grammar. All entries take the form of Prolog terms.&apos; (Identifiers starting with an uppercase letter denote variables, otherwise they are instantiated symbols.) A lexical entry is described by the term synword( (morpheme) , (category)). Categories are of the form (category _symbol) : [(f eature_attri = value].), (f eature_attrn =- value)] a notational variant of the PATR-II category formalism (Shieber, 1986). 3The name SemHe (Syriac seintte &apos;rays&apos;) is not an acronym</context>
<context position="4644" citStr="Kiraz, 1994" startWordPosition="795" endWordPosition="796"> , tl_rule(R3, [ E] , [] , , [ [v] , 0 , [V] 1 , [ , , 0] , [vowel (V)], [ 0 , 0 , 0 ] ). tl_rule(R4, [[] , , 0], 1[v] , , [V]] , [ [c2,v] , 0 , [3], &lt;=&gt;, , [1, 0, tl_rule(R5, [vowel (V)] , , , 0]). , , [] , []] , &lt;=&gt;, , [C] , , tl_rule(R6, [0 , [] , [3], [[c2] , [C] , [measure=p al]] , 0]). [radical (C)] , [[3, [root: , [ , , 0], &lt;=&gt;, , [c,c], [ , , 0] , [ [c2] , [C] , []] [measure=pa&amp;quot; el]] ,[3]). [radical (C)] , [ [] , [root: Listing 1 A two-level rule is described using a syntactic variant of the formalism described by (Ruessink, 1989; Pulman and Hepple, 1993), including the extensions by (Kiraz, 1994c), ti_rule((id),(LLC), (Lex), (RLC), (Op), (LSC), (Surf), (RSC), (variables), (features)). The arguments are: (1) a rule identifier, id; (2) the left-lexical-context, LLC, the lexical center, Lex, and the right-lexical-context, RLC, each in the form of a list-of-lists, where the ith list represents the ith lexical tape; (3) an operator, =&gt; for optional rules or &lt;=&gt; for obligatory rules; (4) the left-surface-context, LSC, the surface center, Surf, and the right-surfacecontext, RSC, each in the form of a list; (5) a list of the variables used in the lexical and surface expressions, each member </context>
<context position="7618" citStr="Kiraz, 1994" startWordPosition="1272" endWordPosition="1274">icon contains the entries in (2).8 (2) synword(c1vc2vc3, pattern : synword(ktb, root: [measure = M]). synword(aa, vocalism : [measure =- p`a11). synword(ae, vocalism : [measure = pa&amp;quot;e1]). Note that the value of &apos;measure&apos; in the root entry is 5Spirantization is ignored here; for a discussion on Syriac spirantization, see (Kiraz, 1995). 8Syriac verbs are classified under various measures (forms). The basic ones are: p`al, pa&amp;quot;el and &apos;eel. 7This analysis is along the lines of (McCarthy, 1981) — based on autosegrnental phonology (Goldsmith, 1976). 8Spreading is ignored here; for a discussion, see (Kiraz, 1994c). 160 uninstantiated; it is determined from the feature values in R5, R6 and/or the word grammar (see infra, §4.3). affairs holds. Rules are then reasserted in the order of their precedence value. This ensures that rules which contain the most specified expressions are tested first resulting in better performance. 3 Implementation There are two current methods for implementing two-level rules (both implemented in SemHe): (1) compiling rules into finite-state automata (multitape transducers in our case), and (2) interpreting rules directly. The former provides better performance, while the la</context>
<context position="16883" citStr="Kiraz, 1994" startWordPosition="2753" endWordPosition="2754">[radical (C)] ). expand(C, [Cc] , [C] , [radical (C)] ). expand(V, 1[V] , 0 ,C]], [vowel (V)] ). expand(V, [[v], , [V]] , [vowel (V)] ). The linguist can then rewrite R4 as R8 (Listing 7), and expand it with the command expand (R8) . This produces four rules of the form of R4, but with the following expressions for Lex and RLC:1° Lex RLC [[U] [[C ,V2] , , [[V1] , 1] , [Cc,v] , [C] , [V2]] [[vi, [] ,[Vi]] [CC, V2] , , [v] , 0 , EV1] [c , v] , [C] , [V2] ] 4.2 Vocalisation Orthographically, Semitic texts are written without short vowels. It was suggested by (Beesley et al., 1989, et. seq.) and (Kiraz, 1994c) to allow short vowels to be optionally deleted. This, however, puts a constraint on the grammar: no surface expression can contain a vowel, lest the vowel is optionally deleted. We assume full vocalisation in writing rules. A second set of rules can allow the deletion of vowels. The whole grammar can be taken as the composition of the two grammars: e.g. {cvcvc},{ktb},{aa} /ktab/ [ktab, ktb]. 4.3 Morphosyntactic Issues Finite-state models of two-level morphology implement morphotactics in two ways: using &apos;continuation patterns/classes&apos; (Koskenniemi, 1983; Antworth, 1990; Karttunen, 1993) or </context>
<context position="22172" citStr="Kiraz, 1994" startWordPosition="3623" endWordPosition="3624">arser A Semitic &apos;word&apos; (string separated by word boundary) may in fact be a clause or a sentence. Therefore, a morphosyntactic parsing of a &apos;word&apos; may be a (partial) syntactic parsing of a sentence in the form of a (partial) tree. The output of a morphological analyser can be structured in a manner suitable for syntactic processing. Using tree-adjoining grammars (Joshi, 1985) might be a possibility. 5 Performance To test the integrity, robustness and performance of the implementation, a two-level grammar of the most frequent words in the Syriac New Testament was compiled based on the data in (Kiraz, 1994b). The grammar covers most classes of verbal and nominal forms, in addition to prepositions, proper nouns and words of Greek origin. A wider coverage would involve enlarging the lexicon (currently there are 165 entries) and might triple the number of two-level rules (currently there are c. 50 rules). Table 1 provides the results of analysing verbal classes. The test for each class represents analysing most of its inflexions. The test was executed on a Sparc ELC computer. By constructing a corpus which consists only of the most frequent words, one can estimate the performance of analysing the </context>
</contexts>
<marker>Kiraz, 1994</marker>
<rawString>Kiraz, G. (1994a). Automatic concordance generation of Syriac texts. In Lavenant, R., editor, VI Symposium Syriacum 1992, Orientalia Christiana Analecta 247, pages 461-75. Pontificio Institutum Studiorum Orientalium.</rawString>
</citation>
<citation valid="true">
<authors>
<author>G Kiraz</author>
</authors>
<title>Lexical Tools to the Syriac New Testament.</title>
<date>1994</date>
<journal>JSOT Manuals</journal>
<volume>7</volume>
<publisher>Sheffield Academic Press.</publisher>
<contexts>
<context position="2674" citStr="Kiraz, 1994" startWordPosition="389" endWordPosition="391">develop non-linear descriptions using higher level notation. To test the validity of one&apos;s proposal or formalism, minimally a medium-scale description is a desideratum. SemHe3 fulfils this requirement. It is a generalised multi-tape two-level system which is being used in developing non-linear grammars. This paper (1) presents the algorithms behind SemHe; (2) discusses the issues involved in compiling non-linear descriptions; and (3) proposes extension/solutions to make writing non-linear rules easier and more elegant. The paper assumes knowledge of multi-tape two-level morphology (Kay, 1987; Kiraz, 1994c). 2 Linguistic Descriptions The linguist provides SemHe with three pieces of data: a lexicon, two-level rules and word formation grammar. All entries take the form of Prolog terms.&apos; (Identifiers starting with an uppercase letter denote variables, otherwise they are instantiated symbols.) A lexical entry is described by the term synword( (morpheme) , (category)). Categories are of the form (category _symbol) : [(f eature_attri = value].), (f eature_attrn =- value)] a notational variant of the PATR-II category formalism (Shieber, 1986). 3The name SemHe (Syriac seintte &apos;rays&apos;) is not an acronym</context>
<context position="4644" citStr="Kiraz, 1994" startWordPosition="795" endWordPosition="796"> , tl_rule(R3, [ E] , [] , , [ [v] , 0 , [V] 1 , [ , , 0] , [vowel (V)], [ 0 , 0 , 0 ] ). tl_rule(R4, [[] , , 0], 1[v] , , [V]] , [ [c2,v] , 0 , [3], &lt;=&gt;, , [1, 0, tl_rule(R5, [vowel (V)] , , , 0]). , , [] , []] , &lt;=&gt;, , [C] , , tl_rule(R6, [0 , [] , [3], [[c2] , [C] , [measure=p al]] , 0]). [radical (C)] , [[3, [root: , [ , , 0], &lt;=&gt;, , [c,c], [ , , 0] , [ [c2] , [C] , []] [measure=pa&amp;quot; el]] ,[3]). [radical (C)] , [ [] , [root: Listing 1 A two-level rule is described using a syntactic variant of the formalism described by (Ruessink, 1989; Pulman and Hepple, 1993), including the extensions by (Kiraz, 1994c), ti_rule((id),(LLC), (Lex), (RLC), (Op), (LSC), (Surf), (RSC), (variables), (features)). The arguments are: (1) a rule identifier, id; (2) the left-lexical-context, LLC, the lexical center, Lex, and the right-lexical-context, RLC, each in the form of a list-of-lists, where the ith list represents the ith lexical tape; (3) an operator, =&gt; for optional rules or &lt;=&gt; for obligatory rules; (4) the left-surface-context, LSC, the surface center, Surf, and the right-surfacecontext, RSC, each in the form of a list; (5) a list of the variables used in the lexical and surface expressions, each member </context>
<context position="7618" citStr="Kiraz, 1994" startWordPosition="1272" endWordPosition="1274">icon contains the entries in (2).8 (2) synword(c1vc2vc3, pattern : synword(ktb, root: [measure = M]). synword(aa, vocalism : [measure =- p`a11). synword(ae, vocalism : [measure = pa&amp;quot;e1]). Note that the value of &apos;measure&apos; in the root entry is 5Spirantization is ignored here; for a discussion on Syriac spirantization, see (Kiraz, 1995). 8Syriac verbs are classified under various measures (forms). The basic ones are: p`al, pa&amp;quot;el and &apos;eel. 7This analysis is along the lines of (McCarthy, 1981) — based on autosegrnental phonology (Goldsmith, 1976). 8Spreading is ignored here; for a discussion, see (Kiraz, 1994c). 160 uninstantiated; it is determined from the feature values in R5, R6 and/or the word grammar (see infra, §4.3). affairs holds. Rules are then reasserted in the order of their precedence value. This ensures that rules which contain the most specified expressions are tested first resulting in better performance. 3 Implementation There are two current methods for implementing two-level rules (both implemented in SemHe): (1) compiling rules into finite-state automata (multitape transducers in our case), and (2) interpreting rules directly. The former provides better performance, while the la</context>
<context position="16883" citStr="Kiraz, 1994" startWordPosition="2753" endWordPosition="2754">[radical (C)] ). expand(C, [Cc] , [C] , [radical (C)] ). expand(V, 1[V] , 0 ,C]], [vowel (V)] ). expand(V, [[v], , [V]] , [vowel (V)] ). The linguist can then rewrite R4 as R8 (Listing 7), and expand it with the command expand (R8) . This produces four rules of the form of R4, but with the following expressions for Lex and RLC:1° Lex RLC [[U] [[C ,V2] , , [[V1] , 1] , [Cc,v] , [C] , [V2]] [[vi, [] ,[Vi]] [CC, V2] , , [v] , 0 , EV1] [c , v] , [C] , [V2] ] 4.2 Vocalisation Orthographically, Semitic texts are written without short vowels. It was suggested by (Beesley et al., 1989, et. seq.) and (Kiraz, 1994c) to allow short vowels to be optionally deleted. This, however, puts a constraint on the grammar: no surface expression can contain a vowel, lest the vowel is optionally deleted. We assume full vocalisation in writing rules. A second set of rules can allow the deletion of vowels. The whole grammar can be taken as the composition of the two grammars: e.g. {cvcvc},{ktb},{aa} /ktab/ [ktab, ktb]. 4.3 Morphosyntactic Issues Finite-state models of two-level morphology implement morphotactics in two ways: using &apos;continuation patterns/classes&apos; (Koskenniemi, 1983; Antworth, 1990; Karttunen, 1993) or </context>
<context position="22172" citStr="Kiraz, 1994" startWordPosition="3623" endWordPosition="3624">arser A Semitic &apos;word&apos; (string separated by word boundary) may in fact be a clause or a sentence. Therefore, a morphosyntactic parsing of a &apos;word&apos; may be a (partial) syntactic parsing of a sentence in the form of a (partial) tree. The output of a morphological analyser can be structured in a manner suitable for syntactic processing. Using tree-adjoining grammars (Joshi, 1985) might be a possibility. 5 Performance To test the integrity, robustness and performance of the implementation, a two-level grammar of the most frequent words in the Syriac New Testament was compiled based on the data in (Kiraz, 1994b). The grammar covers most classes of verbal and nominal forms, in addition to prepositions, proper nouns and words of Greek origin. A wider coverage would involve enlarging the lexicon (currently there are 165 entries) and might triple the number of two-level rules (currently there are c. 50 rules). Table 1 provides the results of analysing verbal classes. The test for each class represents analysing most of its inflexions. The test was executed on a Sparc ELC computer. By constructing a corpus which consists only of the most frequent words, one can estimate the performance of analysing the </context>
</contexts>
<marker>Kiraz, 1994</marker>
<rawString>Kiraz, G. (1994b). Lexical Tools to the Syriac New Testament. JSOT Manuals 7. Sheffield Academic Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>G Kiraz</author>
</authors>
<title>Multi-tape two-level morphology: a case study in Semitic non-linear morphology.</title>
<date>1994</date>
<booktitle>In COLING-94,</booktitle>
<volume>1</volume>
<pages>180--6</pages>
<contexts>
<context position="2674" citStr="Kiraz, 1994" startWordPosition="389" endWordPosition="391">develop non-linear descriptions using higher level notation. To test the validity of one&apos;s proposal or formalism, minimally a medium-scale description is a desideratum. SemHe3 fulfils this requirement. It is a generalised multi-tape two-level system which is being used in developing non-linear grammars. This paper (1) presents the algorithms behind SemHe; (2) discusses the issues involved in compiling non-linear descriptions; and (3) proposes extension/solutions to make writing non-linear rules easier and more elegant. The paper assumes knowledge of multi-tape two-level morphology (Kay, 1987; Kiraz, 1994c). 2 Linguistic Descriptions The linguist provides SemHe with three pieces of data: a lexicon, two-level rules and word formation grammar. All entries take the form of Prolog terms.&apos; (Identifiers starting with an uppercase letter denote variables, otherwise they are instantiated symbols.) A lexical entry is described by the term synword( (morpheme) , (category)). Categories are of the form (category _symbol) : [(f eature_attri = value].), (f eature_attrn =- value)] a notational variant of the PATR-II category formalism (Shieber, 1986). 3The name SemHe (Syriac seintte &apos;rays&apos;) is not an acronym</context>
<context position="4644" citStr="Kiraz, 1994" startWordPosition="795" endWordPosition="796"> , tl_rule(R3, [ E] , [] , , [ [v] , 0 , [V] 1 , [ , , 0] , [vowel (V)], [ 0 , 0 , 0 ] ). tl_rule(R4, [[] , , 0], 1[v] , , [V]] , [ [c2,v] , 0 , [3], &lt;=&gt;, , [1, 0, tl_rule(R5, [vowel (V)] , , , 0]). , , [] , []] , &lt;=&gt;, , [C] , , tl_rule(R6, [0 , [] , [3], [[c2] , [C] , [measure=p al]] , 0]). [radical (C)] , [[3, [root: , [ , , 0], &lt;=&gt;, , [c,c], [ , , 0] , [ [c2] , [C] , []] [measure=pa&amp;quot; el]] ,[3]). [radical (C)] , [ [] , [root: Listing 1 A two-level rule is described using a syntactic variant of the formalism described by (Ruessink, 1989; Pulman and Hepple, 1993), including the extensions by (Kiraz, 1994c), ti_rule((id),(LLC), (Lex), (RLC), (Op), (LSC), (Surf), (RSC), (variables), (features)). The arguments are: (1) a rule identifier, id; (2) the left-lexical-context, LLC, the lexical center, Lex, and the right-lexical-context, RLC, each in the form of a list-of-lists, where the ith list represents the ith lexical tape; (3) an operator, =&gt; for optional rules or &lt;=&gt; for obligatory rules; (4) the left-surface-context, LSC, the surface center, Surf, and the right-surfacecontext, RSC, each in the form of a list; (5) a list of the variables used in the lexical and surface expressions, each member </context>
<context position="7618" citStr="Kiraz, 1994" startWordPosition="1272" endWordPosition="1274">icon contains the entries in (2).8 (2) synword(c1vc2vc3, pattern : synword(ktb, root: [measure = M]). synword(aa, vocalism : [measure =- p`a11). synword(ae, vocalism : [measure = pa&amp;quot;e1]). Note that the value of &apos;measure&apos; in the root entry is 5Spirantization is ignored here; for a discussion on Syriac spirantization, see (Kiraz, 1995). 8Syriac verbs are classified under various measures (forms). The basic ones are: p`al, pa&amp;quot;el and &apos;eel. 7This analysis is along the lines of (McCarthy, 1981) — based on autosegrnental phonology (Goldsmith, 1976). 8Spreading is ignored here; for a discussion, see (Kiraz, 1994c). 160 uninstantiated; it is determined from the feature values in R5, R6 and/or the word grammar (see infra, §4.3). affairs holds. Rules are then reasserted in the order of their precedence value. This ensures that rules which contain the most specified expressions are tested first resulting in better performance. 3 Implementation There are two current methods for implementing two-level rules (both implemented in SemHe): (1) compiling rules into finite-state automata (multitape transducers in our case), and (2) interpreting rules directly. The former provides better performance, while the la</context>
<context position="16883" citStr="Kiraz, 1994" startWordPosition="2753" endWordPosition="2754">[radical (C)] ). expand(C, [Cc] , [C] , [radical (C)] ). expand(V, 1[V] , 0 ,C]], [vowel (V)] ). expand(V, [[v], , [V]] , [vowel (V)] ). The linguist can then rewrite R4 as R8 (Listing 7), and expand it with the command expand (R8) . This produces four rules of the form of R4, but with the following expressions for Lex and RLC:1° Lex RLC [[U] [[C ,V2] , , [[V1] , 1] , [Cc,v] , [C] , [V2]] [[vi, [] ,[Vi]] [CC, V2] , , [v] , 0 , EV1] [c , v] , [C] , [V2] ] 4.2 Vocalisation Orthographically, Semitic texts are written without short vowels. It was suggested by (Beesley et al., 1989, et. seq.) and (Kiraz, 1994c) to allow short vowels to be optionally deleted. This, however, puts a constraint on the grammar: no surface expression can contain a vowel, lest the vowel is optionally deleted. We assume full vocalisation in writing rules. A second set of rules can allow the deletion of vowels. The whole grammar can be taken as the composition of the two grammars: e.g. {cvcvc},{ktb},{aa} /ktab/ [ktab, ktb]. 4.3 Morphosyntactic Issues Finite-state models of two-level morphology implement morphotactics in two ways: using &apos;continuation patterns/classes&apos; (Koskenniemi, 1983; Antworth, 1990; Karttunen, 1993) or </context>
<context position="22172" citStr="Kiraz, 1994" startWordPosition="3623" endWordPosition="3624">arser A Semitic &apos;word&apos; (string separated by word boundary) may in fact be a clause or a sentence. Therefore, a morphosyntactic parsing of a &apos;word&apos; may be a (partial) syntactic parsing of a sentence in the form of a (partial) tree. The output of a morphological analyser can be structured in a manner suitable for syntactic processing. Using tree-adjoining grammars (Joshi, 1985) might be a possibility. 5 Performance To test the integrity, robustness and performance of the implementation, a two-level grammar of the most frequent words in the Syriac New Testament was compiled based on the data in (Kiraz, 1994b). The grammar covers most classes of verbal and nominal forms, in addition to prepositions, proper nouns and words of Greek origin. A wider coverage would involve enlarging the lexicon (currently there are 165 entries) and might triple the number of two-level rules (currently there are c. 50 rules). Table 1 provides the results of analysing verbal classes. The test for each class represents analysing most of its inflexions. The test was executed on a Sparc ELC computer. By constructing a corpus which consists only of the most frequent words, one can estimate the performance of analysing the </context>
</contexts>
<marker>Kiraz, 1994</marker>
<rawString>Kiraz, G. (1994c). Multi-tape two-level morphology: a case study in Semitic non-linear morphology. In COLING-94, volume 1, pages 180-6.</rawString>
</citation>
<citation valid="true">
<authors>
<author>G Kiraz</author>
</authors>
<title>Introduction to Syriac Spirantization. Bar Hebraeus Verlag, The Netherlands.</title>
<date>1995</date>
<contexts>
<context position="7342" citStr="Kiraz, 1995" startWordPosition="1230" endWordPosition="1231">s are denoted by an empty list. R1 is the morpheme boundary b) rule. R2 and R3 sanction stem consonants and vowels, respectively. R4 is the obligatory vowel deletion rule. R5 and R6 map the second radical, [t], for p &apos;al and pa &amp;quot;el forms, respectively. In this example, the lexicon contains the entries in (2).8 (2) synword(c1vc2vc3, pattern : synword(ktb, root: [measure = M]). synword(aa, vocalism : [measure =- p`a11). synword(ae, vocalism : [measure = pa&amp;quot;e1]). Note that the value of &apos;measure&apos; in the root entry is 5Spirantization is ignored here; for a discussion on Syriac spirantization, see (Kiraz, 1995). 8Syriac verbs are classified under various measures (forms). The basic ones are: p`al, pa&amp;quot;el and &apos;eel. 7This analysis is along the lines of (McCarthy, 1981) — based on autosegrnental phonology (Goldsmith, 1976). 8Spreading is ignored here; for a discussion, see (Kiraz, 1994c). 160 uninstantiated; it is determined from the feature values in R5, R6 and/or the word grammar (see infra, §4.3). affairs holds. Rules are then reasserted in the order of their precedence value. This ensures that rules which contain the most specified expressions are tested first resulting in better performance. 3 Impl</context>
</contexts>
<marker>Kiraz, 1995</marker>
<rawString>Kiraz, G. (1995). Introduction to Syriac Spirantization. Bar Hebraeus Verlag, The Netherlands.</rawString>
</citation>
<citation valid="true">
<authors>
<author>G Kiraz</author>
</authors>
<title>Computational Approach to NonLinear Morphology.</title>
<date>1996</date>
<tech>PhD thesis,</tech>
<institution>University of Cambridge.</institution>
<contexts>
<context position="1908" citStr="Kiraz, 1996" startWordPosition="273" endWordPosition="274"> Pulman. Thanks to the anonymous reviewers for their comments. All mistakes remain mine. 1 Although it is possible to express some classes of non-linear rules using standard two-level formalisms by means of ad hoc diacritics, e.g., infixation in (Antworth, 1990, p. 156), there are no means for expressing other classes as root-and-pattern phenomena. 2(Kay, 1987), (Kataja and Koskenniemi, 1988), (Beesley et al., 1989), (Lavie et al., 1990), (Beesley, 1990), (Beesley, 1991), (Kornai, 1991), (Wiebe, 1992), (Pulman and Hepple, 1993), (Narayanan and Hashem, 1993), and (Bird and Ellison, 1994). See (Kiraz, 1996) for a review. (apart from Beesley&apos;s work) seem to have been implemented over large descriptions, nor have they provided means by which the grammarian can develop non-linear descriptions using higher level notation. To test the validity of one&apos;s proposal or formalism, minimally a medium-scale description is a desideratum. SemHe3 fulfils this requirement. It is a generalised multi-tape two-level system which is being used in developing non-linear grammars. This paper (1) presents the algorithms behind SemHe; (2) discusses the issues involved in compiling non-linear descriptions; and (3) propose</context>
<context position="3558" citStr="Kiraz, 1996" startWordPosition="526" endWordPosition="527">antiated symbols.) A lexical entry is described by the term synword( (morpheme) , (category)). Categories are of the form (category _symbol) : [(f eature_attri = value].), (f eature_attrn =- value)] a notational variant of the PATR-II category formalism (Shieber, 1986). 3The name SemHe (Syriac seintte &apos;rays&apos;) is not an acronym, but the title of a grammatical treatise written by the Syriac polymath (inter a/ia mathematician and grammarian) Bar `Ebreiyo (1225-1286), viz. ktobo dsernite &apos;The Book of Rays&apos;. 4We describe here the terms which are relevant to this paper. For a full description, see (Kiraz, 1996). 159 thalphabet(0, [k,t,b,a,e]). % surface alphabet thalphabet (1, Eci , c2 , c3 , v ,b1). thalphabet (2, [k , t ,b , b] ). thalphabet (3, [a, e , f]). % lexical alphabets tl_set (radical , [k , t , b] ) tl_set (vowel , , e] ) tl_set (c 1c3 , , c3] ). % variable sets tl_rule(R1, [ [1 , , 0] , [[L] , [b] , [b]] , [ 0 , 0 , 0], =&gt;, [1, , 0 , , [ , LI, [U). , , []] , =&gt;, 0 , [C], 0 , tl_rule(R2, [ , , 0], [[P] , [C] , ] , [ Ec1c3(P) , radical (C)] , [ , , [7]). =&gt;, , [v] , , tl_rule(R3, [ E] , [] , , [ [v] , 0 , [V] 1 , [ , , 0] , [vowel (V)], [ 0 , 0 , 0 ] ). tl_rule(R4, [[] , , 0], 1[v] , , [V</context>
</contexts>
<marker>Kiraz, 1996</marker>
<rawString>Kiraz, G. (1996). Computational Approach to NonLinear Morphology. PhD thesis, University of Cambridge.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D Knuth</author>
</authors>
<title>The Art of Computer Programming,</title>
<date>1973</date>
<volume>3</volume>
<publisher>Addison-Wesley.</publisher>
<contexts>
<context position="9243" citStr="Knuth, 1973" startWordPosition="1525" endWordPosition="1526">3.1 Internal Representation The word grammar is compiled into a shift-reduce parser. In addition, a first-and-follow algorithm, based on (Aho and Ullman, 1977), is applied to compute the feasible follow categories for each category type. The set of feasible follow categories, NextCats, of a particular category Cat is returned by the predicate FOLLow(+ Cat, —NextCats). Additionally, FOLLOW(bos, NextCats) returns the set of category symbols at the beginning of strings, and eos E NextCats indicates that Cat may occur at the end of strings. The lexical component is implemented as character tries (Knuth, 1973), one per tape. Given a list of lexical strings, Lex, and a list of lexical pointers, LexPtrs, the predicate LEXICAL-TRANSITIONS (+Lex, +LexPtrs, —NewLexPtrs, —LexCats) succeeds if there are transitions on Lex from LexPtrs; it returns NewLexPtrs, and the categories, LexCats, at the end of morphemes, if any. Two-level predicates are converted into an internal representation: (1) every left-context expression is reversed and appended to an uninstantiated tail; (2) every right-context expression is appended to an uninstantiated tail; and (3) each rule is assigned a 6-bit &apos;precedence value&apos; where </context>
</contexts>
<marker>Knuth, 1973</marker>
<rawString>Knuth, D. (1973). The Art of Computer Programming, volume 3. Addison-Wesley.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Kornai</author>
</authors>
<title>Formal Phonology.</title>
<date>1991</date>
<tech>PhD thesis,</tech>
<institution>Stanford Univers ity.</institution>
<contexts>
<context position="1787" citStr="Kornai, 1991" startWordPosition="255" endWordPosition="256">upported by a Benefactor Studentship from St John&apos;s College. This research was done under the supervision of Dr Stephen G. Pulman. Thanks to the anonymous reviewers for their comments. All mistakes remain mine. 1 Although it is possible to express some classes of non-linear rules using standard two-level formalisms by means of ad hoc diacritics, e.g., infixation in (Antworth, 1990, p. 156), there are no means for expressing other classes as root-and-pattern phenomena. 2(Kay, 1987), (Kataja and Koskenniemi, 1988), (Beesley et al., 1989), (Lavie et al., 1990), (Beesley, 1990), (Beesley, 1991), (Kornai, 1991), (Wiebe, 1992), (Pulman and Hepple, 1993), (Narayanan and Hashem, 1993), and (Bird and Ellison, 1994). See (Kiraz, 1996) for a review. (apart from Beesley&apos;s work) seem to have been implemented over large descriptions, nor have they provided means by which the grammarian can develop non-linear descriptions using higher level notation. To test the validity of one&apos;s proposal or formalism, minimally a medium-scale description is a desideratum. SemHe3 fulfils this requirement. It is a generalised multi-tape two-level system which is being used in developing non-linear grammars. This paper (1) pres</context>
</contexts>
<marker>Kornai, 1991</marker>
<rawString>Kornai, A. (1991). Formal Phonology. PhD thesis, Stanford Univers ity.</rawString>
</citation>
<citation valid="true">
<authors>
<author>K Koskenniemi</author>
</authors>
<title>Two-Level Morphology.</title>
<date>1983</date>
<tech>PhD thesis,</tech>
<institution>University of Helsinki.</institution>
<contexts>
<context position="17445" citStr="Koskenniemi, 1983" startWordPosition="2839" endWordPosition="2840">ed by (Beesley et al., 1989, et. seq.) and (Kiraz, 1994c) to allow short vowels to be optionally deleted. This, however, puts a constraint on the grammar: no surface expression can contain a vowel, lest the vowel is optionally deleted. We assume full vocalisation in writing rules. A second set of rules can allow the deletion of vowels. The whole grammar can be taken as the composition of the two grammars: e.g. {cvcvc},{ktb},{aa} /ktab/ [ktab, ktb]. 4.3 Morphosyntactic Issues Finite-state models of two-level morphology implement morphotactics in two ways: using &apos;continuation patterns/classes&apos; (Koskenniemi, 1983; Antworth, 1990; Karttunen, 1993) or unificationbased grammars (Bear, 1986; Ritchie et al., 1992). The former fails to provide elegant morphosyntactic parsing for Semitic languages, as will be illustrated in this section. 4.3.1 Stems and X-Theory A pattern, a root and a vocalism do not alway produce a free stem which can stand on its own. In Syriac, for example, some verbal forms are bound: they require a stem morpheme which indicates the measure in question, e.g. the prefix {Pa} for eel &apos;Note, however, that the expand command does not insert b randomly in context expressions. 163 tl_rule(R7,</context>
</contexts>
<marker>Koskenniemi, 1983</marker>
<rawString>Koskenniemi, K. (1983). Two-Level Morphology. PhD thesis, University of Helsinki.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Lavie</author>
<author>A Itai</author>
<author>U Oman</author>
</authors>
<title>On the applicability of two level morphology to the inflection of Hebrew verbs.</title>
<date>1990</date>
<booktitle>Literary and Linguistic Computing 1988: Proceedings of the 15th International Conference,</booktitle>
<pages>246--60</pages>
<editor>In Choueka, Y., editor,</editor>
<contexts>
<context position="1737" citStr="Lavie et al., 1990" startWordPosition="247" endWordPosition="250">s for handling non-linear morphology;2 however, none * Supported by a Benefactor Studentship from St John&apos;s College. This research was done under the supervision of Dr Stephen G. Pulman. Thanks to the anonymous reviewers for their comments. All mistakes remain mine. 1 Although it is possible to express some classes of non-linear rules using standard two-level formalisms by means of ad hoc diacritics, e.g., infixation in (Antworth, 1990, p. 156), there are no means for expressing other classes as root-and-pattern phenomena. 2(Kay, 1987), (Kataja and Koskenniemi, 1988), (Beesley et al., 1989), (Lavie et al., 1990), (Beesley, 1990), (Beesley, 1991), (Kornai, 1991), (Wiebe, 1992), (Pulman and Hepple, 1993), (Narayanan and Hashem, 1993), and (Bird and Ellison, 1994). See (Kiraz, 1996) for a review. (apart from Beesley&apos;s work) seem to have been implemented over large descriptions, nor have they provided means by which the grammarian can develop non-linear descriptions using higher level notation. To test the validity of one&apos;s proposal or formalism, minimally a medium-scale description is a desideratum. SemHe3 fulfils this requirement. It is a generalised multi-tape two-level system which is being used in d</context>
</contexts>
<marker>Lavie, Itai, Oman, 1990</marker>
<rawString>Lavie, A., Itai, A., and Oman, U. (1990). On the applicability of two level morphology to the inflection of Hebrew verbs. In Choueka, Y., editor, Literary and Linguistic Computing 1988: Proceedings of the 15th International Conference, pages 246-60.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J McCarthy</author>
</authors>
<title>A prosodic theory of nonconcatenative morphology.</title>
<date>1981</date>
<journal>Linguistic Inquiry,</journal>
<pages>12--3</pages>
<contexts>
<context position="7500" citStr="McCarthy, 1981" startWordPosition="1255" endWordPosition="1256">l deletion rule. R5 and R6 map the second radical, [t], for p &apos;al and pa &amp;quot;el forms, respectively. In this example, the lexicon contains the entries in (2).8 (2) synword(c1vc2vc3, pattern : synword(ktb, root: [measure = M]). synword(aa, vocalism : [measure =- p`a11). synword(ae, vocalism : [measure = pa&amp;quot;e1]). Note that the value of &apos;measure&apos; in the root entry is 5Spirantization is ignored here; for a discussion on Syriac spirantization, see (Kiraz, 1995). 8Syriac verbs are classified under various measures (forms). The basic ones are: p`al, pa&amp;quot;el and &apos;eel. 7This analysis is along the lines of (McCarthy, 1981) — based on autosegrnental phonology (Goldsmith, 1976). 8Spreading is ignored here; for a discussion, see (Kiraz, 1994c). 160 uninstantiated; it is determined from the feature values in R5, R6 and/or the word grammar (see infra, §4.3). affairs holds. Rules are then reasserted in the order of their precedence value. This ensures that rules which contain the most specified expressions are tested first resulting in better performance. 3 Implementation There are two current methods for implementing two-level rules (both implemented in SemHe): (1) compiling rules into finite-state automata (multita</context>
</contexts>
<marker>McCarthy, 1981</marker>
<rawString>McCarthy, J. (1981). A prosodic theory of nonconcatenative morphology. Linguistic Inquiry, 12(3):373-418.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Narayanan</author>
<author>L Hashem</author>
</authors>
<title>On abstract finite-state morphology.</title>
<date>1993</date>
<booktitle>In EACL-93,</booktitle>
<pages>297--304</pages>
<contexts>
<context position="1859" citStr="Narayanan and Hashem, 1993" startWordPosition="263" endWordPosition="266">e. This research was done under the supervision of Dr Stephen G. Pulman. Thanks to the anonymous reviewers for their comments. All mistakes remain mine. 1 Although it is possible to express some classes of non-linear rules using standard two-level formalisms by means of ad hoc diacritics, e.g., infixation in (Antworth, 1990, p. 156), there are no means for expressing other classes as root-and-pattern phenomena. 2(Kay, 1987), (Kataja and Koskenniemi, 1988), (Beesley et al., 1989), (Lavie et al., 1990), (Beesley, 1990), (Beesley, 1991), (Kornai, 1991), (Wiebe, 1992), (Pulman and Hepple, 1993), (Narayanan and Hashem, 1993), and (Bird and Ellison, 1994). See (Kiraz, 1996) for a review. (apart from Beesley&apos;s work) seem to have been implemented over large descriptions, nor have they provided means by which the grammarian can develop non-linear descriptions using higher level notation. To test the validity of one&apos;s proposal or formalism, minimally a medium-scale description is a desideratum. SemHe3 fulfils this requirement. It is a generalised multi-tape two-level system which is being used in developing non-linear grammars. This paper (1) presents the algorithms behind SemHe; (2) discusses the issues involved in c</context>
</contexts>
<marker>Narayanan, Hashem, 1993</marker>
<rawString>Narayanan, A. and Hashem, L. (1993). On abstract finite-state morphology. In EACL-93, pages 297-304.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S Pulman</author>
<author>M Hepple</author>
</authors>
<title>A feature-based formalism for two-level phonology: a description and implementation.</title>
<date>1993</date>
<journal>Computer Speech and Language,</journal>
<pages>7--333</pages>
<contexts>
<context position="1829" citStr="Pulman and Hepple, 1993" startWordPosition="259" endWordPosition="262">tship from St John&apos;s College. This research was done under the supervision of Dr Stephen G. Pulman. Thanks to the anonymous reviewers for their comments. All mistakes remain mine. 1 Although it is possible to express some classes of non-linear rules using standard two-level formalisms by means of ad hoc diacritics, e.g., infixation in (Antworth, 1990, p. 156), there are no means for expressing other classes as root-and-pattern phenomena. 2(Kay, 1987), (Kataja and Koskenniemi, 1988), (Beesley et al., 1989), (Lavie et al., 1990), (Beesley, 1990), (Beesley, 1991), (Kornai, 1991), (Wiebe, 1992), (Pulman and Hepple, 1993), (Narayanan and Hashem, 1993), and (Bird and Ellison, 1994). See (Kiraz, 1996) for a review. (apart from Beesley&apos;s work) seem to have been implemented over large descriptions, nor have they provided means by which the grammarian can develop non-linear descriptions using higher level notation. To test the validity of one&apos;s proposal or formalism, minimally a medium-scale description is a desideratum. SemHe3 fulfils this requirement. It is a generalised multi-tape two-level system which is being used in developing non-linear grammars. This paper (1) presents the algorithms behind SemHe; (2) disc</context>
<context position="4602" citStr="Pulman and Hepple, 1993" startWordPosition="787" endWordPosition="790">] , [ Ec1c3(P) , radical (C)] , [ , , [7]). =&gt;, , [v] , , tl_rule(R3, [ E] , [] , , [ [v] , 0 , [V] 1 , [ , , 0] , [vowel (V)], [ 0 , 0 , 0 ] ). tl_rule(R4, [[] , , 0], 1[v] , , [V]] , [ [c2,v] , 0 , [3], &lt;=&gt;, , [1, 0, tl_rule(R5, [vowel (V)] , , , 0]). , , [] , []] , &lt;=&gt;, , [C] , , tl_rule(R6, [0 , [] , [3], [[c2] , [C] , [measure=p al]] , 0]). [radical (C)] , [[3, [root: , [ , , 0], &lt;=&gt;, , [c,c], [ , , 0] , [ [c2] , [C] , []] [measure=pa&amp;quot; el]] ,[3]). [radical (C)] , [ [] , [root: Listing 1 A two-level rule is described using a syntactic variant of the formalism described by (Ruessink, 1989; Pulman and Hepple, 1993), including the extensions by (Kiraz, 1994c), ti_rule((id),(LLC), (Lex), (RLC), (Op), (LSC), (Surf), (RSC), (variables), (features)). The arguments are: (1) a rule identifier, id; (2) the left-lexical-context, LLC, the lexical center, Lex, and the right-lexical-context, RLC, each in the form of a list-of-lists, where the ith list represents the ith lexical tape; (3) an operator, =&gt; for optional rules or &lt;=&gt; for obligatory rules; (4) the left-surface-context, LSC, the surface center, Surf, and the right-surfacecontext, RSC, each in the form of a list; (5) a list of the variables used in the lex</context>
<context position="10493" citStr="Pulman and Hepple, 1993" startWordPosition="1716" endWordPosition="1719">f the six lexical and surface expressions. If an expression is not an empty list (i.e. context is specified), the relevant bit is set. In analysis, surface expressions are assigned the most significant bits, while lexical expressions are assigned the least significant ones. In generation, the opposite state of 3.2 The Interpreter Algorithm The algorithms presented below are given in terms of prolog-like non-deterministic operations. A clause is satisfied if all the conditions under it are satisfied. The predicates are depicted top-down in (3). (SemHe makes use of an earlier implementation by (Pulman and Hepple, 1993).) In order to minimise accumulator-passing arguments, we assume the following initially-empty stacks: Pars eStack accumulates the category structures of the morphemes identified, and FeatureStack maintains the rule features encountered so far. (`+&apos; indicates concatenation.) PARTITION partitions a two-level analysis into sequences of lexical-surface pairs, each licenced by a rule. The base case of the predicate is given in Listing 2,9 and the recursive case in Listing 3. The recursive COERCE predicate ensures that no partition is violated by an obligatory rule. It takes three arguments: Result</context>
</contexts>
<marker>Pulman, Hepple, 1993</marker>
<rawString>Pulman, S. and Hepple, M. (1993). A feature-based formalism for two-level phonology: a description and implementation. Computer Speech and Language, 7:333-58.</rawString>
</citation>
<citation valid="true">
<authors>
<author>G Ritchie</author>
<author>A Black</author>
<author>G Russell</author>
<author>S Pulman</author>
</authors>
<title>Computational Morphology: Practical Mechanisms for the English Lexicon.</title>
<date>1992</date>
<publisher>MIT Press,</publisher>
<location>Cambridge Mass.</location>
<contexts>
<context position="1019" citStr="Ritchie et al., 1992" startWordPosition="133" endWordPosition="136"> is described. In addition, a number of issues which arise when developing non-linear grammars are discussed with examples from Syriac. 1 Introduction The introduction of two-level morphology (Koskenniemi, 1983) and subsequent developments has made implementing computational-morphology models a feasible task. Yet, two-level formalisms fell short from providing elegant means for the description of non-linear operations such as infixation, circumfixation and root-and-pattern morphology.1 As a result, two-level implementations — e.g. (Antworth, 1990; Karttunen, 1983; Karttunen and Beesley, 1992; Ritchie et al., 1992) — have always been biased towards linear morphology. The past decade has seen a number of proposals for handling non-linear morphology;2 however, none * Supported by a Benefactor Studentship from St John&apos;s College. This research was done under the supervision of Dr Stephen G. Pulman. Thanks to the anonymous reviewers for their comments. All mistakes remain mine. 1 Although it is possible to express some classes of non-linear rules using standard two-level formalisms by means of ad hoc diacritics, e.g., infixation in (Antworth, 1990, p. 156), there are no means for expressing other classes as </context>
<context position="17543" citStr="Ritchie et al., 1992" startWordPosition="2851" endWordPosition="2854">ly deleted. This, however, puts a constraint on the grammar: no surface expression can contain a vowel, lest the vowel is optionally deleted. We assume full vocalisation in writing rules. A second set of rules can allow the deletion of vowels. The whole grammar can be taken as the composition of the two grammars: e.g. {cvcvc},{ktb},{aa} /ktab/ [ktab, ktb]. 4.3 Morphosyntactic Issues Finite-state models of two-level morphology implement morphotactics in two ways: using &apos;continuation patterns/classes&apos; (Koskenniemi, 1983; Antworth, 1990; Karttunen, 1993) or unificationbased grammars (Bear, 1986; Ritchie et al., 1992). The former fails to provide elegant morphosyntactic parsing for Semitic languages, as will be illustrated in this section. 4.3.1 Stems and X-Theory A pattern, a root and a vocalism do not alway produce a free stem which can stand on its own. In Syriac, for example, some verbal forms are bound: they require a stem morpheme which indicates the measure in question, e.g. the prefix {Pa} for eel &apos;Note, however, that the expand command does not insert b randomly in context expressions. 163 tl_rule(R7, [ , [] , ] , [ [v] , , [V] ] , [ [c3 , b , e] , [] , [] ] , &lt;=&gt;, [] , 0, C], [vowel (V)] , [C], ,</context>
</contexts>
<marker>Ritchie, Black, Russell, Pulman, 1992</marker>
<rawString>Ritchie, G., Black, A., Russell, G., and Pulman, S. (1992). Computational Morphology: Practical Mechanisms for the English Lexicon. MIT Press, Cambridge Mass.</rawString>
</citation>
<citation valid="true">
<authors>
<author>H Ruessink</author>
</authors>
<title>Two level formalisms.</title>
<date>1989</date>
<tech>Technical Report 5,</tech>
<institution>Utrecht Working</institution>
<note>Papers in NLP.</note>
<contexts>
<context position="4576" citStr="Ruessink, 1989" startWordPosition="785" endWordPosition="786">], [[P] , [C] , ] , [ Ec1c3(P) , radical (C)] , [ , , [7]). =&gt;, , [v] , , tl_rule(R3, [ E] , [] , , [ [v] , 0 , [V] 1 , [ , , 0] , [vowel (V)], [ 0 , 0 , 0 ] ). tl_rule(R4, [[] , , 0], 1[v] , , [V]] , [ [c2,v] , 0 , [3], &lt;=&gt;, , [1, 0, tl_rule(R5, [vowel (V)] , , , 0]). , , [] , []] , &lt;=&gt;, , [C] , , tl_rule(R6, [0 , [] , [3], [[c2] , [C] , [measure=p al]] , 0]). [radical (C)] , [[3, [root: , [ , , 0], &lt;=&gt;, , [c,c], [ , , 0] , [ [c2] , [C] , []] [measure=pa&amp;quot; el]] ,[3]). [radical (C)] , [ [] , [root: Listing 1 A two-level rule is described using a syntactic variant of the formalism described by (Ruessink, 1989; Pulman and Hepple, 1993), including the extensions by (Kiraz, 1994c), ti_rule((id),(LLC), (Lex), (RLC), (Op), (LSC), (Surf), (RSC), (variables), (features)). The arguments are: (1) a rule identifier, id; (2) the left-lexical-context, LLC, the lexical center, Lex, and the right-lexical-context, RLC, each in the form of a list-of-lists, where the ith list represents the ith lexical tape; (3) an operator, =&gt; for optional rules or &lt;=&gt; for obligatory rules; (4) the left-surface-context, LSC, the surface center, Surf, and the right-surfacecontext, RSC, each in the form of a list; (5) a list of the</context>
</contexts>
<marker>Ruessink, 1989</marker>
<rawString>Ruessink, H. (1989). Two level formalisms. Technical Report 5, Utrecht Working Papers in NLP.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S Shieber</author>
</authors>
<title>An Introduction to UnificationBased Approaches to Grammar.</title>
<date>1986</date>
<booktitle>CSLI Lecture Notes Number 4. Center for the Study of Language and Information,</booktitle>
<location>Stanford.</location>
<contexts>
<context position="3215" citStr="Shieber, 1986" startWordPosition="470" endWordPosition="471">umes knowledge of multi-tape two-level morphology (Kay, 1987; Kiraz, 1994c). 2 Linguistic Descriptions The linguist provides SemHe with three pieces of data: a lexicon, two-level rules and word formation grammar. All entries take the form of Prolog terms.&apos; (Identifiers starting with an uppercase letter denote variables, otherwise they are instantiated symbols.) A lexical entry is described by the term synword( (morpheme) , (category)). Categories are of the form (category _symbol) : [(f eature_attri = value].), (f eature_attrn =- value)] a notational variant of the PATR-II category formalism (Shieber, 1986). 3The name SemHe (Syriac seintte &apos;rays&apos;) is not an acronym, but the title of a grammatical treatise written by the Syriac polymath (inter a/ia mathematician and grammarian) Bar `Ebreiyo (1225-1286), viz. ktobo dsernite &apos;The Book of Rays&apos;. 4We describe here the terms which are relevant to this paper. For a full description, see (Kiraz, 1996). 159 thalphabet(0, [k,t,b,a,e]). % surface alphabet thalphabet (1, Eci , c2 , c3 , v ,b1). thalphabet (2, [k , t ,b , b] ). thalphabet (3, [a, e , f]). % lexical alphabets tl_set (radical , [k , t , b] ) tl_set (vowel , , e] ) tl_set (c 1c3 , , c3] ). % va</context>
</contexts>
<marker>Shieber, 1986</marker>
<rawString>Shieber, S. (1986). An Introduction to UnificationBased Approaches to Grammar. CSLI Lecture Notes Number 4. Center for the Study of Language and Information, Stanford.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Sproat</author>
</authors>
<title>Morphology and Computation.</title>
<date>1992</date>
<publisher>MIT Press,</publisher>
<location>Cambridge Mass.</location>
<contexts>
<context position="21396" citStr="Sproat, 1992" startWordPosition="3492" endWordPosition="3493"> appears in (6). (6) stem: X=0] Pet pattern root vocalism cvcvc ktb aa vim stem: 5C=-1] vim ne reflexive stem:[X.-=-2] un 164 Verb Class Inflections Analysed 1st Analysis Subsequent Analysis Mean (sec/word) (sec/word) (sec/word) Strong 78 5.053 0.028 2.539 Initial min 52 6.756 0.048 3.404 Initial tilaph 57 4.379 0.077 2.228 Middle alaph 67 5.107 0.061 2.584 Overall mean 63.5 5.324 0.054 2.689 Table 1 (Beesley et al., 1989) handle this problem by finding a logical expression for the prefix and suffix portions of circumfix morphemes, and use unification to generate only the correct forms — see (Sproat, 1992, p. 158). This approach, however, cannot be used here since, unlike Arabic, not all Syriac VIMs are in the form of circumfixes. 4.3.3 Interfacing with a Syntactic Parser A Semitic &apos;word&apos; (string separated by word boundary) may in fact be a clause or a sentence. Therefore, a morphosyntactic parsing of a &apos;word&apos; may be a (partial) syntactic parsing of a sentence in the form of a (partial) tree. The output of a morphological analyser can be structured in a manner suitable for syntactic processing. Using tree-adjoining grammars (Joshi, 1985) might be a possibility. 5 Performance To test the integr</context>
</contexts>
<marker>Sproat, 1992</marker>
<rawString>Sproat, R. (1992). Morphology and Computation. MIT Press, Cambridge Mass.</rawString>
</citation>
<citation valid="true">
<authors>
<author>B Wiebe</author>
</authors>
<title>Modelling autosegmental phonology with multi-tape finite state transducers. Master&apos;s thesis,</title>
<date>1992</date>
<institution>Simon Fraser University.</institution>
<contexts>
<context position="1802" citStr="Wiebe, 1992" startWordPosition="257" endWordPosition="258">nefactor Studentship from St John&apos;s College. This research was done under the supervision of Dr Stephen G. Pulman. Thanks to the anonymous reviewers for their comments. All mistakes remain mine. 1 Although it is possible to express some classes of non-linear rules using standard two-level formalisms by means of ad hoc diacritics, e.g., infixation in (Antworth, 1990, p. 156), there are no means for expressing other classes as root-and-pattern phenomena. 2(Kay, 1987), (Kataja and Koskenniemi, 1988), (Beesley et al., 1989), (Lavie et al., 1990), (Beesley, 1990), (Beesley, 1991), (Kornai, 1991), (Wiebe, 1992), (Pulman and Hepple, 1993), (Narayanan and Hashem, 1993), and (Bird and Ellison, 1994). See (Kiraz, 1996) for a review. (apart from Beesley&apos;s work) seem to have been implemented over large descriptions, nor have they provided means by which the grammarian can develop non-linear descriptions using higher level notation. To test the validity of one&apos;s proposal or formalism, minimally a medium-scale description is a desideratum. SemHe3 fulfils this requirement. It is a generalised multi-tape two-level system which is being used in developing non-linear grammars. This paper (1) presents the algori</context>
</contexts>
<marker>Wiebe, 1992</marker>
<rawString>Wiebe, B. (1992). Modelling autosegmental phonology with multi-tape finite state transducers. Master&apos;s thesis, Simon Fraser University.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>