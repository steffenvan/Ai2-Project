<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000018">
<title confidence="0.987816">
Forest-based Tree Sequence to String Translation Model
</title>
<author confidence="0.994859">
Hui Zhang1, 2 Min Zhang1 Haizhou Li1 Aiti Aw1 Chew Lim Tan2
</author>
<affiliation confidence="0.98586">
1Institute for Infocomm Research 2National University of Singapore
</affiliation>
<email confidence="0.967828">
zhangh1982@gmail.com {mzhang, hli, aaiti}@i2r.a-star.edu.sg tancl@comp.nus.edu.sg
</email>
<sectionHeader confidence="0.992622" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999776631578947">
This paper proposes a forest-based tree se-
quence to string translation model for syntax-
based statistical machine translation, which
automatically learns tree sequence to string
translation rules from word-aligned source-
side-parsed bilingual texts. The proposed
model leverages on the strengths of both tree
sequence-based and forest-based translation
models. Therefore, it can not only utilize forest
structure that compactly encodes exponential
number of parse trees but also capture non-
syntactic translation equivalences with linguis-
tically structured information through tree se-
quence. This makes our model potentially
more robust to parse errors and structure di-
vergence. Experimental results on the NIST
MT-2003 Chinese-English translation task
show that our method statistically significantly
outperforms the four baseline systems.
</bodyText>
<sectionHeader confidence="0.998989" genericHeader="keywords">
1 Introduction
</sectionHeader>
<bodyText confidence="0.999907587301588">
Recently syntax-based statistical machine trans-
lation (SMT) methods have achieved very prom-
ising results and attracted more and more inter-
ests in the SMT research community. Fundamen-
tally, syntax-based SMT views translation as a
structural transformation process. Therefore,
structure divergence and parse errors are two of
the major issues that may largely compromise
the performance of syntax-based SMT (Zhang et
al., 2008a; Mi et al., 2008).
Many solutions have been proposed to address
the above two issues. Among these advances,
forest-based modeling (Mi et al., 2008; Mi and
Huang, 2008) and tree sequence-based modeling
(Liu et al., 2007; Zhang et al., 2008a) are two
interesting modeling methods with promising
results reported. Forest-based modeling aims to
improve translation accuracy through digging the
potential better parses from n-bests (i.e. forest)
while tree sequence-based modeling aims to
model non-syntactic translations with structured
syntactic knowledge. In nature, the two methods
would be complementary to each other since
they manage to solve the negative impacts of
monolingual parse errors and cross-lingual struc-
ture divergence on translation results from dif-
ferent viewpoints. Therefore, one natural way is
to combine the strengths of the two modeling
methods for better performance of syntax-based
SMT. However, there are many challenges in
combining the two methods into a single model
from both theoretical and implementation engi-
neering viewpoints. In theory, one may worry
about whether the advantage of tree sequence has
already been covered by forest because forest
encodes implicitly a huge number of parse trees
and these parse trees may generate many differ-
ent phrases and structure segmentations given a
source sentence. In system implementation, the
exponential combinations of tree sequences with
forest structures make the rule extraction and
decoding tasks much more complicated than that
of the two individual methods.
In this paper, we propose a forest-based tree
sequence to string model, which is designed to
integrate the strengths of the forest-based and the
tree sequence-based modeling methods. We pre-
sent our solutions that are able to extract transla-
tion rules and decode translation results for our
model very efficiently. A general, configurable
platform was designed for our model. With this
platform, we can easily implement our method
and many previous syntax-based methods by
simple parameter setting. We evaluate our
method on the NIST MT-2003 Chinese-English
translation tasks. Experimental results show that
our method significantly outperforms the two
individual methods and other baseline methods.
Our study shows that the proposed method is
able to effectively combine the strengths of the
forest-based and tree sequence-based methods,
and thus having great potential to address the
issues of parse errors and non-syntactic transla-
</bodyText>
<page confidence="0.963848">
172
</page>
<note confidence="0.999612">
Proceedings of the 47th Annual Meeting of the ACL and the 4th IJCNLP of the AFNLP, pages 172–180,
Suntec, Singapore, 2-7 August 2009. c�2009 ACL and AFNLP
</note>
<bodyText confidence="0.999448181818182">
tions resulting from structure divergence. It also
indicates that tree sequence and forest play dif-
ferent roles and make contributions to our model
in different ways.
The remainder of the paper is organized as fol-
lows. Section 2 describes related work while sec-
tion 3 defines our translation model. In section 4
and section 5, the key rule extraction and decod-
ing algorithms are elaborated. Experimental re-
sults are reported in section 6 and the paper is
concluded in section 7.
</bodyText>
<sectionHeader confidence="0.999622" genericHeader="introduction">
2 Related work
</sectionHeader>
<bodyText confidence="0.999973779661017">
As discussed in section 1, two of the major chal-
lenges to syntax-based SMT are structure diver-
gence and parse errors. Many techniques have
been proposed to address the structure diver-
gence issue while only fewer studies are reported
in addressing the parse errors in the SMT re-
search community.
To address structure divergence issue, many
researchers (Eisner, 2003; Zhang et al., 2007)
propose using the Synchronous Tree Substitution
Grammar (STSG) grammar in syntax-based
SMT since the STSG uses larger tree fragment as
translation unit. Although promising results have
been reported, STSG only uses one single sub-
tree as translation unit which is still committed to
the syntax strictly. Motivated by the fact that
non-syntactic phrases make non-trivial contribu-
tion to phrase-based SMT, the tree sequence-
based translation model is proposed (Liu et al.,
2007; Zhang et al., 2008a) that uses tree se-
quence as the basic translation unit, rather than
using single sub-tree as in the STSG. Here, a tree
sequence refers to a sequence of consecutive
sub-trees that are embedded in a full parse tree.
For any given phrase in a sentence, there is at
least one tree sequence covering it. Thus the tree
sequence-based model has great potential to ad-
dress the structure divergence issue by using tree
sequence-based non-syntactic translation rules.
Liu et al. (2007) propose the tree sequence con-
cept and design a tree sequence to string transla-
tion model. Zhang et al. (2008a) propose a tree
sequence-based tree to tree translation model and
Zhang et al. (2008b) demonstrate that the tree
sequence-based modelling method can well ad-
dress the structure divergence issue for syntax-
based SMT.
To overcome the parse errors for SMT, Mi et
al. (2008) propose a forest-based translation
method that uses forest instead of one best tree as
translation input, where a forest is a compact rep-
resentation of exponentially number of n-best
parse trees. Mi and Huang (2008) propose a for-
est-based rule extraction algorithm, which learn
tree to string rules from source forest and target
string. By using forest in rule extraction and de-
coding, their methods are able to well address the
parse error issue.
From the above discussion, we can see that
traditional tree sequence-based method uses sin-
gle tree as translation input while the forest-
based model uses single sub-tree as the basic
translation unit that can only learn tree-to-string
(Galley et al. 2004; Liu et al., 2006) rules. There-
fore, the two methods display different strengths,
and which would be complementary to each
other. To integrate their strengths, in this paper,
we propose a forest-based tree sequence to string
translation model.
</bodyText>
<sectionHeader confidence="0.982136" genericHeader="method">
3 Forest-based tree sequence to string
model
</sectionHeader>
<bodyText confidence="0.99994625">
In this section, we first explain what a packed
forest is and then define the concept of the tree
sequence in the context of forest followed by the
discussion on our proposed model.
</bodyText>
<subsectionHeader confidence="0.994708">
3.1 Packed Forest
</subsectionHeader>
<bodyText confidence="0.999889222222222">
A packed forest (forest in short) is a special kind
of hyper-graph (Klein and Manning, 2001;
Huang and Chiang, 2005), which is used to rep-
resent all derivations (i.e. parse trees) for a given
sentence under a context free grammar (CFG). A
forest F is defined as a triple &lt; V, E, S &gt;, where
V is non-terminal node set, E is hyper-edge set
and S is leaf node set (i.e. all sentence words). A
forest F satisfies the following two conditions:
</bodyText>
<listItem confidence="0.973955">
1) Each node n in V should cover a phrase,
which is a continuous word sub-sequence in S.
2) Each hyper-edge a in E is defined as
</listItem>
<bodyText confidence="0.997677125">
vf :* vl ... vi ... vn, (vi E (V U S), vf E V) ,
where vl ... vi ... vn covers a sequence of conti-
nuous and non-overlap phrases, vf is the father
node of the children sequence vl ... vi ... vn. The
phrase covered by vf is just the sum of all the
phrases covered by each child node vi.
We here introduce another concept that is used
in our subsequent discussions. A complete forest
CF is a general forest with one additional condi-
tion that there is only one root node N in CF, i.e.,
all nodes except the root N in a CF must have at
least one father node.
Fig. 1 is a complete forest while Fig. 7 is a
non-complete forest due to the virtual node
“VV+VV” introduced in Fig. 7. Fig. 2 is a hyper-
edge (IP =&gt; NP VP) of Fig. 1, where NP covers
</bodyText>
<page confidence="0.998286">
173
</page>
<bodyText confidence="0.999699692307692">
the phrase “Xinhuashe”, VP covers the phrase
“shengming youguan guiding” and IP covers the
entire sentence. In Fig.1, only root IP has no fa-
ther node, so it is a complete forest. The two
parse trees T1 and T2 encoded in Fig. 1 are
shown separately in Fig. 3 and Fig. 41.
Different parse tree represents different deri-
vations and explanations for a given sentence.
For example, for the same input sentence in Fig.
1, T1 interprets it as “XNA (Xinhua News
Agency) declares some regulations.” while T2
interprets it as “XNA declaration is related to
some regulations.”.
</bodyText>
<figureCaption confidence="0.996223">
Figure 1. A packed forest for sentence “Vff*�f
</figureCaption>
<figure confidence="0.7944595">
/Xinhuashe � HJJ /shengming � � /youguan � �
/guiding”
</figure>
<figureCaption confidence="0.9994585">
Figure 2. A hyper-edge used in Fig. 1
Figure 3. Tree 1 (T1) Figure 4. Tree 2 (T2)
</figureCaption>
<subsectionHeader confidence="0.999514">
3.2 Tree sequence in packed forest
</subsectionHeader>
<bodyText confidence="0.974637552631579">
Similar to the definition of tree sequence used in
a single parse tree defined in Liu et al. (2007)
and Zhang et al. (2008a), a tree sequence in a
forest also refers to an ordered sub-tree sequence
that covers a continuous phrase without overlap-
ping. However, the major difference between
1 Please note that a single tree (as T1 and T2 shown in Fig.
3 and Fig. 4) is represented by edges instead of hyper-edges.
A hyper-edge is a group of edges satisfying the 2nd condi-
tion as shown in the forest definition.
them lies in that the sub-trees of a tree sequence
in forest may belongs to different single parse
trees while, in a single parse tree-based model,
all the sub-trees in a tree sequence are committed
to the same parse tree.
The forest-based tree sequence enables our
model to have the potential of exploring addi-
tional parse trees that may be wrongly pruned out
by the parser and thus are not encoded in the for-
est. This is because that a tree sequence in a for-
est allows its sub-trees coming from different
parse trees, where these sub-trees may not be
merged finally to form a complete parse tree in
the forest. Take the forest in Fig. 1 as an exam-
ple, where ((VV shengming) (JJ youguan)) is a
tree sequence that all sub-trees appear in T1
while ((VV shengming) (VV youguan)) is a tree
sequence whose sub-trees do not belong to any
single tree in the forest. But, indeed the two sub-
trees (VV shengming) and (VV youguan) can be
merged together and further lead to a complete
single parse tree which may offer a correct inter-
pretation to the input sentence (as shown in Fig.
5). In addition, please note that, on the other
hand, more parse trees may introduce more noisy
structures. In this paper, we leave this problem to
our model and let the model decide which sub-
structures are noisy features.
</bodyText>
<figureCaption confidence="0.996704333333333">
Figure 5. A parse tree that was wrongly
pruned out
Figure 6. A tree sequence to string rule
</figureCaption>
<page confidence="0.987947">
174
</page>
<bodyText confidence="0.9999494">
A tree-sequence to string translation rule in a
forest is a triple &lt;L, R, A&gt;, where L is the tree
sequence in source language, R is the string con-
taining words and variables in target language,
and A is the alignment between the leaf nodes of
L and R. This definition is similar to that of (Liu
et al. 2007, Zhang et al. 2008a) except our tree-
sequence is defined in forest. The shaded area of
Fig. 6 exemplifies a tree sequence to string trans-
lation rule in the forest.
</bodyText>
<subsectionHeader confidence="0.960259">
3.3 Forest-based tree-sequence to string
translation model
</subsectionHeader>
<bodyText confidence="0.999915666666667">
Given a source forest F and target translation TS
as well as word alignment A, our translation
model is formulated as:
</bodyText>
<equation confidence="0.885474">
Pr(F, 7s, A) = Eeie 0,c(0)=(F,TS,A) F11iE0i P(ri)
</equation>
<bodyText confidence="0.99992825">
By the above Eq., translation becomes a tree
sequence structure to string mapping issue. Giv-
en the F, TS and A, there are multiple derivations
that could map F to TS under the constraint A.
The mapping probability Pr(F, TS, A) in our
study is obtained by summing over the probabili-
ties of all derivations 0. The probability of each
derivation Bi is given as the product of the prob-
abilities of all the rules p(ri ) used in the deriva-
tion (here we assume that each rule is applied
independently in a derivation).
Our model is implemented under log-linear
framework (Och and Ney, 2002). We use seven
basic features that are analogous to the common-
ly used features in phrase-based systems (Koehn,
2003): 1) bidirectional rule mapping probabilities,
2) bidirectional lexical rule translation probabili-
ties, 3) target language model, 4) number of rules
used and 5) number of target words. In addition,
we define two new features: 1) number of leaf
nodes in auxiliary rules (the auxiliary rule will be
explained later in this paper) and 2) product of
the probabilities of all hyper-edges of the tree
sequences in forest.
</bodyText>
<sectionHeader confidence="0.99345" genericHeader="method">
4 Training
</sectionHeader>
<bodyText confidence="0.992514083333333">
This section discusses how to extract our transla-
tion rules given a triple &lt; F, TS, A &gt; . As we
know, the traditional tree-to-string rules can be
easily extracted from &lt; F, TS, A &gt; using the algo-
rithm of Mi and Huang (2008)2. We would like
2 Mi and Huang (2008) extend the tree-based rule extraction
algorithm (Galley et al., 2004) to forest-based by introduc-
ing non-deterministic mechanism. Their algorithm consists
of two steps, minimal rule extraction and composed rule
generation.
to leverage on their algorithm in our study. Un-
fortunately, their algorithm is not directly appli-
cable to our problem because tree rules have only
one root while tree sequence rules have multiple
roots. This makes the tree sequence rule extrac-
tion very complex due to its interaction with for-
est structure. To address this issue, we introduce
the concepts of virtual node and virtual hyper-
edge to convert a complete parse forest F to a
non-complete forest F which is designed to en-
code all the tree sequences that we want. There-
fore, by doing so, the tree sequence rules can be
extracted from a forest in the following two
steps:
</bodyText>
<listItem confidence="0.980868722222222">
1) Convert the complete parse forest F into a
non-complete forest F in order to cover those
tree sequences that cannot be covered by a single
tree node.
2) Employ the forest-based tree rule extraction
algorithm (Mi and Huang, 2008) to extract our
rules from the non-complete forest.
To facilitate our discussion, here we introduce
two notations:
• Alignable: A consecutive source phrase is
an alignable phrase if and only if it can be
aligned with at least one consecutive target
phrase under the word-alignment con-
straint. The covered source span is called
alignable span.
• Node sequence: a sequence of nodes (ei-
ther leaf or internal nodes) in a forest cov-
ering a consecutive span.
</listItem>
<bodyText confidence="0.983041714285714">
Algorithm 1 illustrates the first step of our rule
extraction algorithm, which is a CKY-style Dy-
namic Programming (DP) algorithm to add vir-
tual nodes into forest. It includes the following
steps:
1) We traverse the forest to visit each span in
bottom-up fashion (line 1-2),
1.1) for each span [u,v] that is covered by
single tree nodes3, we put these tree
nodes into the set NSS(u,v) and go
back to step 1 (line 4-6).
1.2) otherwise we concatenate the tree se-
quences of sub-spans to generate the
set of tree sequences covering the cur-
rent larger span (line 8-13). Then, we
prune the set of node sequences (line
14). If this span is alignable, we
create virtual father nodes and corres-
ponding virtual hyper-edges to link
the node sequences with the virtual
father nodes (line 15-20).
</bodyText>
<footnote confidence="0.950301">
3 Note that in a forest, there would be multiple single tree
nodes covering the same span as shown Fig.1.
</footnote>
<page confidence="0.996603">
175
</page>
<bodyText confidence="0.999517611111111">
2) Finally we obtain a forest with each align-
able span covered by either original tree
nodes or the newly-created tree sequence
virtual nodes.
Theoretically, there is exponential number of
node sequences in a forest. Take Fig. 7 as an ex-
ample. The NSS of span [1,2] only contains “NP”
since it is alignable and covered by the single
tree node NP. However, span [2,3] cannot be
covered by any single tree node, so we have to
create the NSS of span[2,3] by concatenating the
NSSs of span [2,2] and span [3,3]. Since NSS of
span [2,2] contains 4 element {“NN”, “NP”,
“VV”, “VP”} and NSS of span [3, 3] also con-
tains 4 element {“VV”, “VP”, “JJ”, “ADJP”},
NSS of span [2,3] contains 16=4*4 elements. To
make the NSS manageable, we prune it with the
following thresholds:
</bodyText>
<listItem confidence="0.992480444444444">
• each node sequence should contain less
than n nodes
• each node sequence set should contain less
than m node sequences
• sort node sequences according to their
lengths and only keep the k shortest ones
Each virtual node is simply labeled by the
concatenation of all its children’s labels as
shown in Fig. 7.
</listItem>
<figure confidence="0.307232714285714">
Algorithm 1. add virtual nodes into forest
Input: packed forest F, alignment A
Notation:
L: length of source sentence
NSS(u,v): the set of node sequences covering span [u,v]
VN(ns): virtual father node for node sequence ns.
Output: modified forest F with virtual nodes
</figure>
<listItem confidence="0.956146">
1. for length := 0 to L - 1 do
2. for start := 1 to L - length do
3. stop := start + length
4. if span[start, stop] covered by tree nodes then
5. for each node n of span [start, stop] do
6. add n into NSS(start, stop)
7. else
8. for pivot := start to stop - 1
9. for each ns1 in NSS(start, pivot) do
10. for each ns2 in NSS(pivot+1, stop) do
</listItem>
<figure confidence="0.8260631">
11. create ns := ns1 O ns2
12. if ns is not in NSS(start, stop) then
13. add ns into NSS(start, stop)
14. do pruning on NSS(start, stop)
15. if the span[start, stop] is alignable then
16. for each ns of NSS(start, stop) do
17. if node VN(ns) is not in F then
18. add node VN(ns) into F
19. add a hyper-edge h into F,
20. let lhs(h) := VN(ns), rhs(h) := ns
</figure>
<bodyText confidence="0.977076055555556">
Algorithm 1 outputs a non-complete forest CF
with each alignable span covered by either tree
nodes or virtual nodes. Then we can easily ex-
tract our rules from the CF using the tree rule
extraction algorithm (Mi and Huang, 2008).
Finally, to calculate rule feature probabilities
for our model, we need to calculate the fractional
counts (it is a kind of probability defined in Mi
and Huang, 2008) of each translation rule in a
parse forest. In the tree case, we can use the in-
side-outside-based methods (Mi and Huang
2008) to do it. In the tree sequence case, since
the previous method cannot be used directly, we
provide another solution by making an indepen-
dent assumption that each tree in a tree sequence
is independent to each other. With this assump-
tion, the fractional counts of both tree and tree
sequence can be calculated as follows:
</bodyText>
<equation confidence="0.99878225">
c(r) = a/3(Ihs(r))
J a/3(TOP)
afl(frag) = F1 a(v) * F1 P(h) * F1 fl(v)
vrroot(frag) hrfrag
</equation>
<bodyText confidence="0.999743111111111">
where c(r) is the fractional counts to be calcu-
lated for rule r, a frag is either lhs(r) (excluding
virtual nodes and virtual hyper-edges) or any tree
node in a forest, TOP is the root of the forest,
a(.) and fl(.) are the outside and inside probabil-
ities of nodes, root(.) returns the root nodes of a
tree sequence fragment, leaves(.) returns the
leaf nodes of a tree sequence fragment, p(h) is
the hyper-edge probability.
</bodyText>
<figureCaption confidence="0.998211">
Figure 7. A virtual node in forest
</figureCaption>
<sectionHeader confidence="0.996787" genericHeader="method">
5 Decoding
</sectionHeader>
<bodyText confidence="0.988631875">
We benefit from the same strategy as used in our
rule extraction algorithm in designing our decod-
ing algorithm, recasting the forest-based tree se-
quence-to-string decoding problem as a forest-
based tree-to-string decoding problem. Our de-
coding algorithm consists of four steps:
1) Convert the complete parse forest to a non-
complete one by introducing virtual nodes.
</bodyText>
<page confidence="0.99526">
176
</page>
<listItem confidence="0.9500295">
2) Convert the non-complete parse forest into
a translation forest4 TF by using the translation
rules and the pattern-matching algorithm pre-
sented in Mi et al. (2008).
3) Prune out redundant nodes and add auxil-
iary hyper-edge into the translation forest for
those nodes that have either no child or no father.
By this step, the translation forest TF becomes a
complete forest.
4) Decode the translation forest using our
translation model and a dynamic search algo-
rithm.
</listItem>
<bodyText confidence="0.999162764705883">
The process of step 1 is similar to Algorithm 1
except no alignment constraint used here. This
may generate a large number of additional virtual
nodes; however, all redundant nodes will be fil-
tered out in step 3. In step 2, we employ the tree-
to-string pattern match algorithm (Mi et al.,
2008) to convert a parse forest to a translation
forest. In step 3, all those nodes not covered by
any translation rules are removed. In addition,
please note that the translation forest is already
not a complete forest due to the virtual nodes and
the pruning of rule-unmatchable nodes. We,
therefore, propose Algorithm 2 to add auxiliary
hyper-edges to make the translation forest com-
plete.
In Algorithm 2, we travel the forest in bottom-
up fashion (line 4-5). For each span, we do:
</bodyText>
<listItem confidence="0.85157425">
1) generate all the NSS for this span (line 7-12)
2) filter the NSS to a manageable size (line 13)
3) add auxiliary hyper-edges for the current
span (line 15-19) if it can be covered by at least
</listItem>
<bodyText confidence="0.960866842105263">
one single tree node, otherwise go to step 1 . This
is the key step in our Algorithm 2. For each tree
node and each node sequences covering the same
span (stored in the current NSS), if the tree node
has no children or at least one node in the node
sequence has no father, we add an auxiliary hy-
per-edge to connect the tree node as father node
with the node sequence as children. Since Algo-
rithm 2 is DP-based and traverses the forest in a
bottom-up way, all the nodes in a node sequence
should already have children node after the lower
level process in a small span. Finally, we re-build
the NSS of current span for upper level NSS
combination use (line 20-22).
In Fig. 8, the hyper-edge “IP=&gt;NP VV+VV
NP” is an auxiliary hyper-edge introduced by
Algorithm 2. By Algorithm 2, we convert the
translation forest into a complete translation for-
est. We then use a bottom-up node-based search
</bodyText>
<footnote confidence="0.305994">
4 The concept of translation forest is proposed in Mi et
al. (2008). It is a forest that consists of only the hyper-
edges induced from translation rules.
</footnote>
<bodyText confidence="0.87480525">
algorithm to do decoding on the complete trans-
lation forest. We also use Cube Pruning algo-
rithm (Huang and Chiang 2007) to speed up the
translation process.
</bodyText>
<figureCaption confidence="0.965623">
Figure 8. Auxiliary hyper-edge in a translation
forest
</figureCaption>
<construct confidence="0.887542333333333">
Algorithm 2. add auxiliary hyper-edges into mt forest F
Input: mt forest F
Output: complete forest F with auxiliary hyper-edges
</construct>
<listItem confidence="0.855178291666667">
1. for i := 1 to L do
2. for each node n of span [i, i] do
3. add n into NSS(i, i)
4. for length := 1 to L - 1 do
5. for start := 1 to L - length do
6. stop := start + length
7. for pivot := start to stop-1 do
8. for each ns1 in NSS (start, pivot) do
9. for each ns2 in NSS (pivot+1,stop) do
10. create ns := ns1 6 ns2
11. if ns is not in NSS(start, stop) then
12. add ns into NSS (start, stop)
13. do pruning on NSS(start, stop)
14. if there is tree node cover span [start, stop] then
15. for each tree node n of span [start,stop] do
16. for each ns of NSS(start, stop) do
17. if node n have no children or
there is node in ns with no father
then
18. add auxiliary hyper-edge h into F
19. let lhs(h) := n, rhs(h) := ns
20. empty NSS(start, stop)
21. for each node n of span [start, stop] do
22. add n into NSS(start, stop)
</listItem>
<sectionHeader confidence="0.993378" genericHeader="evaluation">
6 Experiment
</sectionHeader>
<subsectionHeader confidence="0.999559">
6.1 Experimental Settings
</subsectionHeader>
<bodyText confidence="0.9999815">
We evaluate our method on Chinese-English
translation task. We use the FBIS corpus as train-
ing set, the NIST MT-2002 test set as develop-
ment (dev) set and the NIST MT-2003 test set as
test set. We train Charniak’s parser (Charniak
2000) on CTB5 to do Chinese parsing, and modi-
fy it to output packed forest. We tune the parser
on section 301-325 and test it on section 271-
300. The F-measure on all sentences is 80.85%.
A 3-gram language model is trained on the Xin-
</bodyText>
<page confidence="0.994657">
177
</page>
<bodyText confidence="0.999973787878788">
hua portion of the English Gigaword3 corpus and
the target side of the FBIS corpus using the
SRILM Toolkits (Stolcke, 2002) with modified
Kneser-Ney smoothing (Kenser and Ney, 1995).
GIZA++ (Och and Ney, 2003) and the heuristics
“grow-diag-final-and” are used to generate m-to-
n word alignments. For the MER training (Och,
2003), Koehn’s MER trainer (Koehn, 2007) is
modified for our system. For significance test,
we use Zhang et al.’s implementation (Zhang et
al, 2004). Our evaluation metrics is case-
sensitive BLEU-4 (Papineni et al., 2002).
For parse forest pruning (Mi et al., 2008), we
utilize the Margin-based pruning algorithm pre-
sented in (Huang, 2008). Different from Mi et al.
(2008) that use a static pruning threshold, our
threshold is sentence-depended. For each sen-
tence, we compute the Margin between the n-th
best and the top 1 parse tree, then use the Mar-
gin-based pruning algorithm presented in
(Huang, 2008) to do pruning. By doing so, we
can guarantee to use at least all the top n best
parse trees in the forest. However, please note
that even after pruning there is still exponential
number of additional trees embedded in the for-
est because of the sharing structure of forest.
Other parameters are set as follows: maximum
number of roots in a tree sequence is 3, maxi-
mum height of a translation rule is 3, maximum
number of leaf nodes is 7, maximum number of
node sequences on each span is 10, and maxi-
mum number of rules extracted from one node is
10000.
</bodyText>
<subsectionHeader confidence="0.999195">
6.2 Experimental Results
</subsectionHeader>
<bodyText confidence="0.999989">
We implement our proposed methods as a gen-
eral, configurable platform for syntax-based
SMT study. Based on this platform, we are able
to easily implement most of the state-of-the-art
syntax-based x-to-string SMT methods via sim-
ple parameter setting. For training, we set forest
pruning threshold to 1 best for tree-based me-
thods and 100 best for forest-based methods. For
decoding, we set:
</bodyText>
<listItem confidence="0.969947857142857">
1) TT2S: tree-based tree-to-string model by
setting the forest pruning threshold to 1 best and
the number of sub-trees in a tree sequence to 1.
2) TTS2S: tree-based tree-sequence to string
system by setting the forest pruning threshold to
1 best and the maximum number of sub-trees in a
tree sequence to 3.
3) FT2S: forest-based tree-to-string system by
setting the forest pruning threshold to 500 best,
the number of sub-trees in a tree sequence to 1.
4) FTS2S: forest-based tree-sequence to string
system by setting the forest pruning threshold to
500 best and the maximum number of sub-trees
in a tree sequence to 3.
</listItem>
<note confidence="0.623256333333333">
Model BLEU(%)
Moses 25.68
TT2S 26.08
TTS2S 26.95
FT2S 27.66
FTS2S 28.83
</note>
<tableCaption confidence="0.99861">
Table 1. Performance Comparison
</tableCaption>
<bodyText confidence="0.993780622222222">
We use the first three syntax-based systems
(TT2S, TTS2S, FT2S) and Moses (Koehn et al.,
2007), the state-of-the-art phrase-based system,
as our baseline systems. Table 1 compares the
performance of the five methods, all of which are
fine-tuned. It shows that:
1) FTS2S significantly outperforms (p&lt;0.05)
FT2S. This shows that tree sequence is very use-
ful to forest-based model. Although a forest can
cover much more phrases than a single tree does,
there are still many non-syntactic phrases that
cannot be captured by a forest due to structure
divergence issue. On the other hand, tree se-
quence is a good solution to non-syntactic trans-
lation equivalence modeling. This is mainly be-
cause tree sequence rules are only sensitive to
word alignment while tree rules, even extracted
from a forest (like in FT2S), are also limited by
syntax according to grammar parsing rules.
2) FTS2S shows significant performance im-
provement (p&lt;0.05) over TTS2S due to the con-
tribution of forest. This is mainly due to the fact
that forest can offer very large number of parse
trees for rule extraction and decoder.
3) Our model statistically significantly outper-
forms all the baselines system. This clearly de-
monstrates the effectiveness of our proposed
model for syntax-based SMT. It also shows that
the forest-based method and tree sequence-based
method are complementary to each other and our
proposed method is able to effectively integrate
their strengths.
4) All the four syntax-based systems show bet-
ter performance than Moses and three of them
significantly outperforms (p&lt;0.05) Moses. This
suggests that syntax is very useful to SMT and
translation can be viewed as a structure mapping
issue as done in the four syntax-based systems.
Table 2 and Table 3 report the distribution of
different kinds of translation rules in our model
(training forest pruning threshold is set to 100
best) and in our decoding (decoding forest prun-
ing threshold is set to 500 best) for one best
translation generation. From the two tables, we
can find that:
</bodyText>
<page confidence="0.991759">
178
</page>
<table confidence="0.9632785">
Rule Type Tree Tree Sequence
to String to String
L 4,854,406 20,526,674
P 37,360,684 58,826,261
U 3,297,302 3,775,734
All 45,512,392 83,128,669
</table>
<tableCaption confidence="0.980299666666667">
Table 2. # of rules extracted from training cor-
pus. L means fully lexicalized, P means partially
lexicalized, U means unlexicalized.
</tableCaption>
<table confidence="0.9996315">
Rule Type Tree Tree Sequence
to String to String
L 10,592 1,161
P 7,132 742
U 4,874 278
All 22,598 2,181
</table>
<tableCaption confidence="0.9515305">
Table 3. # of rules used to generate one-best
translation result in testing
</tableCaption>
<bodyText confidence="0.98917076">
1) In Table 2, the number of tree sequence
rules is much larger than that of tree rules al-
though our rule extraction algorithm only ex-
tracts those tree sequence rules over the spans
that tree rules cannot cover. This suggests that
the non-syntactic structure mapping is still a big
challenge to syntax-based SMT.
2) Table 3 shows that the tree sequence rules
is around 9% of the tree rules when generating
the one-best translation. This suggests that
around 9% of translation equivalences in the test
set can be better modeled by tree sequence to
string rules than by tree to string rules. The 9%
tree sequence rules contribute 1.17 BLEU score
improvement (28.83-27.66 in Table 1) to FTS2S
over FT2S.
3) In Table 3, the fully-lexicalized rules are
the major part (around 60%), followed by the
partially-lexicalized (around 35%) and un-
lexicalized (around 15%). However, in Table 2,
partially-lexicalized rules extracted from training
corpus are the major part (more than 70%). This
suggests that most partially-lexicalized rules are
less effective in our model. This clearly directs
our future work in model optimization.
</bodyText>
<table confidence="0.995722">
BLEU (%)
N-best \ model FT2S FTS2S
100 Best 27.40 28.61
500 Best 27.66 28.83
2500 Best 27.66 28.96
5000 Best 27.79 28.89
</table>
<tableCaption confidence="0.999623">
Table 4. Impact of the forest pruning
</tableCaption>
<bodyText confidence="0.9937889">
Forest pruning is a key step for forest-based
method. Table 4 reports the performance of the
two forest-based models using different values of
the forest pruning threshold for decoding. It
shows that:
1) FTS2S significantly outperforms (p&lt;0.05)
FT2S consistently in all test cases. This again
demonstrates the effectiveness of our proposed
model. Even if in the 5000 Best case, tree se-
quence is still able to contribute 1.1 BLEU score
improvement (28.89-27.79). It indicates the ad-
vantage of tree sequence cannot be covered by
forest even if we utilize a very large forest.
2) The BLEU scores are very similar to each
other when we increase the forest pruning thre-
shold. Moreover, in one case the performance
even drops. This suggests that although more
parse trees in a forest can offer more structure
information, they may also introduce more noise
that may confuse the decoder.
</bodyText>
<sectionHeader confidence="0.999045" genericHeader="conclusions">
7 Conclusion
</sectionHeader>
<bodyText confidence="0.999939869565218">
In this paper, we propose a forest-based tree-
sequence to string translation model to combine
the strengths of forest-based methods and tree-
sequence based methods. This enables our model
to have the great potential to address the issues
of structure divergence and parse errors for syn-
tax-based SMT. We convert our forest-based tree
sequence rule extraction and decoding issues to
tree-based by introducing virtual nodes, virtual
hyper-edges and auxiliary rules (hyper-edges). In
our system implementation, we design a general
and configurable platform for our method, based
on which we can easily realize many previous
syntax-based methods. Finally, we examine our
methods on the FBIS corpus and the NIST MT-
2003 Chinese-English translation task. Experi-
mental results show that our model greatly out-
performs the four baseline systems. Our study
demonstrates that forest-based method and tree
sequence-based method are complementary to
each other and our proposed method is able to
effectively combine the strengths of the two in-
dividual methods for syntax-based SMT.
</bodyText>
<sectionHeader confidence="0.986852" genericHeader="acknowledgments">
Acknowledgement
</sectionHeader>
<bodyText confidence="0.999334285714286">
We would like to thank Huang Yun for preparing
the pictures in this paper; Run Yan for providing
the java version modified MERT program and
discussion on the details of MOSES; Mi Haitao
for his help and discussion on re-implementing
the FT2S model; Sun Jun and Xiong Deyi for
their valuable suggestions.
</bodyText>
<page confidence="0.998337">
179
</page>
<sectionHeader confidence="0.994486" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999834520547946">
Eugene Charniak. 2000. A maximum-entropy inspired
parser. NAACL-00.
Jason Eisner. 2003. Learning non-isomorphic tree
mappings for MT. ACL-03 (companion volume).
Michel Galley, Mark Hopkins, Kevin Knight and Da-
niel Marcu. 2004. What’s in a translation rule?
HLT-NAACL-04. 273-280.
Liang Huang. 2008. Forest Reranking: Discriminative
Parsing with Non-Local Features. ACL-HLT-08.
586-594
Liang Huang and David Chiang. 2005. Better k-best
Parsing. IWPT-05.
Liang Huang and David Chiang. 2007. Forest rescor-
ing: Faster decoding with integrated language
models. ACL-07. 144–151
Liang Huang, Kevin Knight and Aravind Joshi. 2006.
Statistical Syntax-Directed Translation with Ex-
tended Domain of Locality. AMTA-06. (poster)
Reinhard Kenser and Hermann Ney. 1995. Improved
backing-off for M-gram language modeling.
ICASSP-95. 181-184
Dan Klein and Christopher D. Manning. 2001. Pars-
ing and Hypergraphs. IWPT-2001.
Philipp Koehn, F. J. Och and D. Marcu. 2003. Statis-
tical phrase-based translation. HLT-NAACL-03.
127-133.
Philipp Koehn, Hieu Hoang, Alexandra Birch, Chris
Callison-Burch, Marcello Federico, Nicola Bertol-
di, Brooke Cowan, Wade Shen, Christine Moran,
Richard Zens, Chris Dyer, Ondrej Bojar, Alexandra
Constantin and Evan Herbst. 2007. Moses: Open
Source Toolkit for Statistical Machine Translation.
ACL-07. 177-180. (poster)
Yang Liu, Qun Liu and Shouxun Lin. 2006. Tree-to-
String Alignment Template for Statistical Machine
Translation. COLING-ACL-06. 609-616.
Yang Liu, Yun Huang, Qun Liu and Shouxun Lin.
2007. Forest-to-String Statistical Translation
Rules. ACL-07. 704-711.
Haitao Mi, Liang Huang, and Qun Liu. 2008. Forest-
based translation. ACL-HLT-08. 192-199.
Haitao Mi and Liang Huang. 2008. Forest-based
Translation Rule Extraction. EMNLP-08. 206-214.
Franz J. Och and Hermann Ney. 2002. Discriminative
training and maximum entropy models for statis-
tical machine translation. ACL-02. 295-302.
Franz J. Och. 2003. Minimum error rate training in
statistical machine translation. ACL-03. 160-167.
Franz Josef Och and Hermann Ney. 2003. A Syste-
matic Comparison of Various Statistical Alignment
Models. Computational Linguistics. 29(1) 19-51.
Kishore Papineni, Salim Roukos, ToddWard and
Wei-Jing Zhu. 2002. BLEU: a method for automat-
ic evaluation of machine translation. ACL-02. 311-
318.
Andreas Stolcke. 2002. SRILM - an extensible lan-
guage modeling toolkit. ICSLP-02. 901-904.
Min Zhang, Hongfei Jiang, Ai Ti Aw, Jun Sun, Sheng
Li and Chew Lim Tan. 2007. A Tree-to-Tree
Alignment-based Model for Statistical Machine
Translation. MT-Summit-07. 535-542.
Min Zhang, Hongfei Jiang, Aiti Aw, Haizhou Li,
Chew Lim Tan, Sheng Li. 2008a. A Tree Sequence
Alignment-based Tree-to-Tree Translation Model.
ACL-HLT-08. 559-567.
Min Zhang, Hongfei Jiang, Haizhou Li, Aiti Aw,
Sheng Li. 2008b. Grammar Comparison Study for
Translational Equivalence Modeling and Statistic-
al Machine Translation. COLING-08. 1097-1104.
Ying Zhang, Stephan Vogel, Alex Waibel. 2004. In-
terpreting BLEU/NIST scores: How much im-
provement do we need to have a better system?
LREC-04. 2051-2054.
</reference>
<page confidence="0.99774">
180
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.692029">
<title confidence="0.937389">Forest-based Tree Sequence to String Translation Model</title>
<author confidence="0.740972">Min Haizhou Aiti Chew Lim</author>
<affiliation confidence="0.797106">for Infocomm Research University of Singapore</affiliation>
<email confidence="0.935819">zhangh1982@gmail.com{mzhang,hli,aaiti}@i2r.a-star.edu.sgtancl@comp.nus.edu.sg</email>
<abstract confidence="0.9998827">This paper proposes a forest-based tree sequence to string translation model for syntaxbased statistical machine translation, which automatically learns tree sequence to string translation rules from word-aligned sourceside-parsed bilingual texts. The proposed model leverages on the strengths of both tree sequence-based and forest-based translation models. Therefore, it can not only utilize forest structure that compactly encodes exponential number of parse trees but also capture nonsyntactic translation equivalences with linguistically structured information through tree sequence. This makes our model potentially more robust to parse errors and structure divergence. Experimental results on the NIST MT-2003 Chinese-English translation task show that our method statistically significantly outperforms the four baseline systems.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Eugene Charniak</author>
</authors>
<date>2000</date>
<note>A maximum-entropy inspired parser. NAACL-00.</note>
<contexts>
<context position="23854" citStr="Charniak 2000" startWordPosition="4134" endWordPosition="4135"> 15. for each tree node n of span [start,stop] do 16. for each ns of NSS(start, stop) do 17. if node n have no children or there is node in ns with no father then 18. add auxiliary hyper-edge h into F 19. let lhs(h) := n, rhs(h) := ns 20. empty NSS(start, stop) 21. for each node n of span [start, stop] do 22. add n into NSS(start, stop) 6 Experiment 6.1 Experimental Settings We evaluate our method on Chinese-English translation task. We use the FBIS corpus as training set, the NIST MT-2002 test set as development (dev) set and the NIST MT-2003 test set as test set. We train Charniak’s parser (Charniak 2000) on CTB5 to do Chinese parsing, and modify it to output packed forest. We tune the parser on section 301-325 and test it on section 271- 300. The F-measure on all sentences is 80.85%. A 3-gram language model is trained on the Xin177 hua portion of the English Gigaword3 corpus and the target side of the FBIS corpus using the SRILM Toolkits (Stolcke, 2002) with modified Kneser-Ney smoothing (Kenser and Ney, 1995). GIZA++ (Och and Ney, 2003) and the heuristics “grow-diag-final-and” are used to generate m-ton word alignments. For the MER training (Och, 2003), Koehn’s MER trainer (Koehn, 2007) is m</context>
</contexts>
<marker>Charniak, 2000</marker>
<rawString>Eugene Charniak. 2000. A maximum-entropy inspired parser. NAACL-00.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jason Eisner</author>
</authors>
<title>Learning non-isomorphic tree mappings for MT.</title>
<date>2003</date>
<note>ACL-03 (companion volume).</note>
<contexts>
<context position="5043" citStr="Eisner, 2003" startWordPosition="750" endWordPosition="751"> work while section 3 defines our translation model. In section 4 and section 5, the key rule extraction and decoding algorithms are elaborated. Experimental results are reported in section 6 and the paper is concluded in section 7. 2 Related work As discussed in section 1, two of the major challenges to syntax-based SMT are structure divergence and parse errors. Many techniques have been proposed to address the structure divergence issue while only fewer studies are reported in addressing the parse errors in the SMT research community. To address structure divergence issue, many researchers (Eisner, 2003; Zhang et al., 2007) propose using the Synchronous Tree Substitution Grammar (STSG) grammar in syntax-based SMT since the STSG uses larger tree fragment as translation unit. Although promising results have been reported, STSG only uses one single subtree as translation unit which is still committed to the syntax strictly. Motivated by the fact that non-syntactic phrases make non-trivial contribution to phrase-based SMT, the tree sequencebased translation model is proposed (Liu et al., 2007; Zhang et al., 2008a) that uses tree sequence as the basic translation unit, rather than using single su</context>
</contexts>
<marker>Eisner, 2003</marker>
<rawString>Jason Eisner. 2003. Learning non-isomorphic tree mappings for MT. ACL-03 (companion volume).</rawString>
</citation>
<citation valid="true">
<authors>
<author>Michel Galley</author>
<author>Mark Hopkins</author>
<author>Kevin Knight</author>
<author>Daniel Marcu</author>
</authors>
<title>What’s in a translation rule?</title>
<date>2004</date>
<pages>04--273</pages>
<contexts>
<context position="7116" citStr="Galley et al. 2004" startWordPosition="1087" endWordPosition="1090"> as translation input, where a forest is a compact representation of exponentially number of n-best parse trees. Mi and Huang (2008) propose a forest-based rule extraction algorithm, which learn tree to string rules from source forest and target string. By using forest in rule extraction and decoding, their methods are able to well address the parse error issue. From the above discussion, we can see that traditional tree sequence-based method uses single tree as translation input while the forestbased model uses single sub-tree as the basic translation unit that can only learn tree-to-string (Galley et al. 2004; Liu et al., 2006) rules. Therefore, the two methods display different strengths, and which would be complementary to each other. To integrate their strengths, in this paper, we propose a forest-based tree sequence to string translation model. 3 Forest-based tree sequence to string model In this section, we first explain what a packed forest is and then define the concept of the tree sequence in the context of forest followed by the discussion on our proposed model. 3.1 Packed Forest A packed forest (forest in short) is a special kind of hyper-graph (Klein and Manning, 2001; Huang and Chiang,</context>
<context position="13758" citStr="Galley et al., 2004" startWordPosition="2302" endWordPosition="2305">r of rules used and 5) number of target words. In addition, we define two new features: 1) number of leaf nodes in auxiliary rules (the auxiliary rule will be explained later in this paper) and 2) product of the probabilities of all hyper-edges of the tree sequences in forest. 4 Training This section discusses how to extract our translation rules given a triple &lt; F, TS, A &gt; . As we know, the traditional tree-to-string rules can be easily extracted from &lt; F, TS, A &gt; using the algorithm of Mi and Huang (2008)2. We would like 2 Mi and Huang (2008) extend the tree-based rule extraction algorithm (Galley et al., 2004) to forest-based by introducing non-deterministic mechanism. Their algorithm consists of two steps, minimal rule extraction and composed rule generation. to leverage on their algorithm in our study. Unfortunately, their algorithm is not directly applicable to our problem because tree rules have only one root while tree sequence rules have multiple roots. This makes the tree sequence rule extraction very complex due to its interaction with forest structure. To address this issue, we introduce the concepts of virtual node and virtual hyperedge to convert a complete parse forest F to a non-comple</context>
</contexts>
<marker>Galley, Hopkins, Knight, Marcu, 2004</marker>
<rawString>Michel Galley, Mark Hopkins, Kevin Knight and Daniel Marcu. 2004. What’s in a translation rule? HLT-NAACL-04. 273-280.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Liang Huang</author>
</authors>
<title>Forest Reranking: Discriminative Parsing with Non-Local Features.</title>
<date>2008</date>
<pages>08--586</pages>
<contexts>
<context position="1719" citStr="Huang, 2008" startWordPosition="237" endWordPosition="238">ms. 1 Introduction Recently syntax-based statistical machine translation (SMT) methods have achieved very promising results and attracted more and more interests in the SMT research community. Fundamentally, syntax-based SMT views translation as a structural transformation process. Therefore, structure divergence and parse errors are two of the major issues that may largely compromise the performance of syntax-based SMT (Zhang et al., 2008a; Mi et al., 2008). Many solutions have been proposed to address the above two issues. Among these advances, forest-based modeling (Mi et al., 2008; Mi and Huang, 2008) and tree sequence-based modeling (Liu et al., 2007; Zhang et al., 2008a) are two interesting modeling methods with promising results reported. Forest-based modeling aims to improve translation accuracy through digging the potential better parses from n-bests (i.e. forest) while tree sequence-based modeling aims to model non-syntactic translations with structured syntactic knowledge. In nature, the two methods would be complementary to each other since they manage to solve the negative impacts of monolingual parse errors and cross-lingual structure divergence on translation results from differ</context>
<context position="6630" citStr="Huang (2008)" startWordPosition="1009" endWordPosition="1010">Liu et al. (2007) propose the tree sequence concept and design a tree sequence to string translation model. Zhang et al. (2008a) propose a tree sequence-based tree to tree translation model and Zhang et al. (2008b) demonstrate that the tree sequence-based modelling method can well address the structure divergence issue for syntaxbased SMT. To overcome the parse errors for SMT, Mi et al. (2008) propose a forest-based translation method that uses forest instead of one best tree as translation input, where a forest is a compact representation of exponentially number of n-best parse trees. Mi and Huang (2008) propose a forest-based rule extraction algorithm, which learn tree to string rules from source forest and target string. By using forest in rule extraction and decoding, their methods are able to well address the parse error issue. From the above discussion, we can see that traditional tree sequence-based method uses single tree as translation input while the forestbased model uses single sub-tree as the basic translation unit that can only learn tree-to-string (Galley et al. 2004; Liu et al., 2006) rules. Therefore, the two methods display different strengths, and which would be complementar</context>
<context position="13650" citStr="Huang (2008)" startWordPosition="2286" endWordPosition="2287">ilities, 2) bidirectional lexical rule translation probabilities, 3) target language model, 4) number of rules used and 5) number of target words. In addition, we define two new features: 1) number of leaf nodes in auxiliary rules (the auxiliary rule will be explained later in this paper) and 2) product of the probabilities of all hyper-edges of the tree sequences in forest. 4 Training This section discusses how to extract our translation rules given a triple &lt; F, TS, A &gt; . As we know, the traditional tree-to-string rules can be easily extracted from &lt; F, TS, A &gt; using the algorithm of Mi and Huang (2008)2. We would like 2 Mi and Huang (2008) extend the tree-based rule extraction algorithm (Galley et al., 2004) to forest-based by introducing non-deterministic mechanism. Their algorithm consists of two steps, minimal rule extraction and composed rule generation. to leverage on their algorithm in our study. Unfortunately, their algorithm is not directly applicable to our problem because tree rules have only one root while tree sequence rules have multiple roots. This makes the tree sequence rule extraction very complex due to its interaction with forest structure. To address this issue, we intro</context>
<context position="18389" citStr="Huang, 2008" startWordPosition="3139" endWordPosition="3140">ns2 in NSS(pivot+1, stop) do 11. create ns := ns1 O ns2 12. if ns is not in NSS(start, stop) then 13. add ns into NSS(start, stop) 14. do pruning on NSS(start, stop) 15. if the span[start, stop] is alignable then 16. for each ns of NSS(start, stop) do 17. if node VN(ns) is not in F then 18. add node VN(ns) into F 19. add a hyper-edge h into F, 20. let lhs(h) := VN(ns), rhs(h) := ns Algorithm 1 outputs a non-complete forest CF with each alignable span covered by either tree nodes or virtual nodes. Then we can easily extract our rules from the CF using the tree rule extraction algorithm (Mi and Huang, 2008). Finally, to calculate rule feature probabilities for our model, we need to calculate the fractional counts (it is a kind of probability defined in Mi and Huang, 2008) of each translation rule in a parse forest. In the tree case, we can use the inside-outside-based methods (Mi and Huang 2008) to do it. In the tree sequence case, since the previous method cannot be used directly, we provide another solution by making an independent assumption that each tree in a tree sequence is independent to each other. With this assumption, the fractional counts of both tree and tree sequence can be calcula</context>
<context position="24747" citStr="Huang, 2008" startWordPosition="4284" endWordPosition="4285">the target side of the FBIS corpus using the SRILM Toolkits (Stolcke, 2002) with modified Kneser-Ney smoothing (Kenser and Ney, 1995). GIZA++ (Och and Ney, 2003) and the heuristics “grow-diag-final-and” are used to generate m-ton word alignments. For the MER training (Och, 2003), Koehn’s MER trainer (Koehn, 2007) is modified for our system. For significance test, we use Zhang et al.’s implementation (Zhang et al, 2004). Our evaluation metrics is casesensitive BLEU-4 (Papineni et al., 2002). For parse forest pruning (Mi et al., 2008), we utilize the Margin-based pruning algorithm presented in (Huang, 2008). Different from Mi et al. (2008) that use a static pruning threshold, our threshold is sentence-depended. For each sentence, we compute the Margin between the n-th best and the top 1 parse tree, then use the Margin-based pruning algorithm presented in (Huang, 2008) to do pruning. By doing so, we can guarantee to use at least all the top n best parse trees in the forest. However, please note that even after pruning there is still exponential number of additional trees embedded in the forest because of the sharing structure of forest. Other parameters are set as follows: maximum number of roots</context>
</contexts>
<marker>Huang, 2008</marker>
<rawString>Liang Huang. 2008. Forest Reranking: Discriminative Parsing with Non-Local Features. ACL-HLT-08. 586-594</rawString>
</citation>
<citation valid="true">
<authors>
<author>Liang Huang</author>
<author>David Chiang</author>
</authors>
<date>2005</date>
<note>Better k-best Parsing. IWPT-05.</note>
<contexts>
<context position="7722" citStr="Huang and Chiang, 2005" startWordPosition="1188" endWordPosition="1191">alley et al. 2004; Liu et al., 2006) rules. Therefore, the two methods display different strengths, and which would be complementary to each other. To integrate their strengths, in this paper, we propose a forest-based tree sequence to string translation model. 3 Forest-based tree sequence to string model In this section, we first explain what a packed forest is and then define the concept of the tree sequence in the context of forest followed by the discussion on our proposed model. 3.1 Packed Forest A packed forest (forest in short) is a special kind of hyper-graph (Klein and Manning, 2001; Huang and Chiang, 2005), which is used to represent all derivations (i.e. parse trees) for a given sentence under a context free grammar (CFG). A forest F is defined as a triple &lt; V, E, S &gt;, where V is non-terminal node set, E is hyper-edge set and S is leaf node set (i.e. all sentence words). A forest F satisfies the following two conditions: 1) Each node n in V should cover a phrase, which is a continuous word sub-sequence in S. 2) Each hyper-edge a in E is defined as vf :* vl ... vi ... vn, (vi E (V U S), vf E V) , where vl ... vi ... vn covers a sequence of continuous and non-overlap phrases, vf is the father no</context>
</contexts>
<marker>Huang, Chiang, 2005</marker>
<rawString>Liang Huang and David Chiang. 2005. Better k-best Parsing. IWPT-05.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Liang Huang</author>
<author>David Chiang</author>
</authors>
<title>Forest rescoring: Faster decoding with integrated language models.</title>
<date>2007</date>
<pages>07--144</pages>
<contexts>
<context position="22534" citStr="Huang and Chiang 2007" startWordPosition="3866" endWordPosition="3869">vel process in a small span. Finally, we re-build the NSS of current span for upper level NSS combination use (line 20-22). In Fig. 8, the hyper-edge “IP=&gt;NP VV+VV NP” is an auxiliary hyper-edge introduced by Algorithm 2. By Algorithm 2, we convert the translation forest into a complete translation forest. We then use a bottom-up node-based search 4 The concept of translation forest is proposed in Mi et al. (2008). It is a forest that consists of only the hyperedges induced from translation rules. algorithm to do decoding on the complete translation forest. We also use Cube Pruning algorithm (Huang and Chiang 2007) to speed up the translation process. Figure 8. Auxiliary hyper-edge in a translation forest Algorithm 2. add auxiliary hyper-edges into mt forest F Input: mt forest F Output: complete forest F with auxiliary hyper-edges 1. for i := 1 to L do 2. for each node n of span [i, i] do 3. add n into NSS(i, i) 4. for length := 1 to L - 1 do 5. for start := 1 to L - length do 6. stop := start + length 7. for pivot := start to stop-1 do 8. for each ns1 in NSS (start, pivot) do 9. for each ns2 in NSS (pivot+1,stop) do 10. create ns := ns1 6 ns2 11. if ns is not in NSS(start, stop) then 12. add ns into NS</context>
</contexts>
<marker>Huang, Chiang, 2007</marker>
<rawString>Liang Huang and David Chiang. 2007. Forest rescoring: Faster decoding with integrated language models. ACL-07. 144–151</rawString>
</citation>
<citation valid="true">
<authors>
<author>Liang Huang</author>
<author>Kevin Knight</author>
<author>Aravind Joshi</author>
</authors>
<date>2006</date>
<booktitle>Statistical Syntax-Directed Translation with Extended Domain of Locality. AMTA-06.</booktitle>
<pages>(poster)</pages>
<marker>Huang, Knight, Joshi, 2006</marker>
<rawString>Liang Huang, Kevin Knight and Aravind Joshi. 2006. Statistical Syntax-Directed Translation with Extended Domain of Locality. AMTA-06. (poster)</rawString>
</citation>
<citation valid="true">
<authors>
<author>Reinhard Kenser</author>
<author>Hermann Ney</author>
</authors>
<title>Improved backing-off for M-gram language modeling.</title>
<date>1995</date>
<pages>95--181</pages>
<contexts>
<context position="24268" citStr="Kenser and Ney, 1995" startWordPosition="4206" endWordPosition="4209">nese-English translation task. We use the FBIS corpus as training set, the NIST MT-2002 test set as development (dev) set and the NIST MT-2003 test set as test set. We train Charniak’s parser (Charniak 2000) on CTB5 to do Chinese parsing, and modify it to output packed forest. We tune the parser on section 301-325 and test it on section 271- 300. The F-measure on all sentences is 80.85%. A 3-gram language model is trained on the Xin177 hua portion of the English Gigaword3 corpus and the target side of the FBIS corpus using the SRILM Toolkits (Stolcke, 2002) with modified Kneser-Ney smoothing (Kenser and Ney, 1995). GIZA++ (Och and Ney, 2003) and the heuristics “grow-diag-final-and” are used to generate m-ton word alignments. For the MER training (Och, 2003), Koehn’s MER trainer (Koehn, 2007) is modified for our system. For significance test, we use Zhang et al.’s implementation (Zhang et al, 2004). Our evaluation metrics is casesensitive BLEU-4 (Papineni et al., 2002). For parse forest pruning (Mi et al., 2008), we utilize the Margin-based pruning algorithm presented in (Huang, 2008). Different from Mi et al. (2008) that use a static pruning threshold, our threshold is sentence-depended. For each sente</context>
</contexts>
<marker>Kenser, Ney, 1995</marker>
<rawString>Reinhard Kenser and Hermann Ney. 1995. Improved backing-off for M-gram language modeling. ICASSP-95. 181-184</rawString>
</citation>
<citation valid="true">
<authors>
<author>Dan Klein</author>
<author>Christopher D Manning</author>
</authors>
<title>Parsing and Hypergraphs.</title>
<date>2001</date>
<contexts>
<context position="7697" citStr="Klein and Manning, 2001" startWordPosition="1184" endWordPosition="1187">y learn tree-to-string (Galley et al. 2004; Liu et al., 2006) rules. Therefore, the two methods display different strengths, and which would be complementary to each other. To integrate their strengths, in this paper, we propose a forest-based tree sequence to string translation model. 3 Forest-based tree sequence to string model In this section, we first explain what a packed forest is and then define the concept of the tree sequence in the context of forest followed by the discussion on our proposed model. 3.1 Packed Forest A packed forest (forest in short) is a special kind of hyper-graph (Klein and Manning, 2001; Huang and Chiang, 2005), which is used to represent all derivations (i.e. parse trees) for a given sentence under a context free grammar (CFG). A forest F is defined as a triple &lt; V, E, S &gt;, where V is non-terminal node set, E is hyper-edge set and S is leaf node set (i.e. all sentence words). A forest F satisfies the following two conditions: 1) Each node n in V should cover a phrase, which is a continuous word sub-sequence in S. 2) Each hyper-edge a in E is defined as vf :* vl ... vi ... vn, (vi E (V U S), vf E V) , where vl ... vi ... vn covers a sequence of continuous and non-overlap phr</context>
</contexts>
<marker>Klein, Manning, 2001</marker>
<rawString>Dan Klein and Christopher D. Manning. 2001. Parsing and Hypergraphs. IWPT-2001.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Philipp Koehn</author>
<author>F J Och</author>
<author>D Marcu</author>
</authors>
<title>Statistical phrase-based translation.</title>
<date>2003</date>
<pages>03--127</pages>
<marker>Koehn, Och, Marcu, 2003</marker>
<rawString>Philipp Koehn, F. J. Och and D. Marcu. 2003. Statistical phrase-based translation. HLT-NAACL-03. 127-133.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Philipp Koehn</author>
<author>Hieu Hoang</author>
<author>Alexandra Birch</author>
<author>Chris Callison-Burch</author>
<author>Marcello Federico</author>
<author>Nicola Bertoldi</author>
<author>Brooke Cowan</author>
<author>Wade Shen</author>
</authors>
<title>Moses: Open Source Toolkit for Statistical Machine Translation.</title>
<date>2007</date>
<volume>07</volume>
<pages>177--180</pages>
<location>Christine Moran, Richard Zens, Chris Dyer, Ondrej Bojar, Alexandra</location>
<contexts>
<context position="26799" citStr="Koehn et al., 2007" startWordPosition="4633" endWordPosition="4636">setting the forest pruning threshold to 1 best and the maximum number of sub-trees in a tree sequence to 3. 3) FT2S: forest-based tree-to-string system by setting the forest pruning threshold to 500 best, the number of sub-trees in a tree sequence to 1. 4) FTS2S: forest-based tree-sequence to string system by setting the forest pruning threshold to 500 best and the maximum number of sub-trees in a tree sequence to 3. Model BLEU(%) Moses 25.68 TT2S 26.08 TTS2S 26.95 FT2S 27.66 FTS2S 28.83 Table 1. Performance Comparison We use the first three syntax-based systems (TT2S, TTS2S, FT2S) and Moses (Koehn et al., 2007), the state-of-the-art phrase-based system, as our baseline systems. Table 1 compares the performance of the five methods, all of which are fine-tuned. It shows that: 1) FTS2S significantly outperforms (p&lt;0.05) FT2S. This shows that tree sequence is very useful to forest-based model. Although a forest can cover much more phrases than a single tree does, there are still many non-syntactic phrases that cannot be captured by a forest due to structure divergence issue. On the other hand, tree sequence is a good solution to non-syntactic translation equivalence modeling. This is mainly because tree</context>
</contexts>
<marker>Koehn, Hoang, Birch, Callison-Burch, Federico, Bertoldi, Cowan, Shen, 2007</marker>
<rawString>Philipp Koehn, Hieu Hoang, Alexandra Birch, Chris Callison-Burch, Marcello Federico, Nicola Bertoldi, Brooke Cowan, Wade Shen, Christine Moran, Richard Zens, Chris Dyer, Ondrej Bojar, Alexandra Constantin and Evan Herbst. 2007. Moses: Open Source Toolkit for Statistical Machine Translation. ACL-07. 177-180. (poster)</rawString>
</citation>
<citation valid="true">
<authors>
<author>Yang Liu</author>
<author>Qun Liu</author>
<author>Shouxun Lin</author>
</authors>
<title>Tree-toString Alignment Template for Statistical Machine Translation.</title>
<date>2006</date>
<volume>06</volume>
<pages>609--616</pages>
<contexts>
<context position="7135" citStr="Liu et al., 2006" startWordPosition="1091" endWordPosition="1094">t, where a forest is a compact representation of exponentially number of n-best parse trees. Mi and Huang (2008) propose a forest-based rule extraction algorithm, which learn tree to string rules from source forest and target string. By using forest in rule extraction and decoding, their methods are able to well address the parse error issue. From the above discussion, we can see that traditional tree sequence-based method uses single tree as translation input while the forestbased model uses single sub-tree as the basic translation unit that can only learn tree-to-string (Galley et al. 2004; Liu et al., 2006) rules. Therefore, the two methods display different strengths, and which would be complementary to each other. To integrate their strengths, in this paper, we propose a forest-based tree sequence to string translation model. 3 Forest-based tree sequence to string model In this section, we first explain what a packed forest is and then define the concept of the tree sequence in the context of forest followed by the discussion on our proposed model. 3.1 Packed Forest A packed forest (forest in short) is a special kind of hyper-graph (Klein and Manning, 2001; Huang and Chiang, 2005), which is us</context>
</contexts>
<marker>Liu, Liu, Lin, 2006</marker>
<rawString>Yang Liu, Qun Liu and Shouxun Lin. 2006. Tree-toString Alignment Template for Statistical Machine Translation. COLING-ACL-06. 609-616.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Yang Liu</author>
<author>Yun Huang</author>
<author>Qun Liu</author>
<author>Shouxun Lin</author>
</authors>
<title>Forest-to-String Statistical Translation Rules.</title>
<date>2007</date>
<volume>07</volume>
<pages>704--711</pages>
<contexts>
<context position="1770" citStr="Liu et al., 2007" startWordPosition="243" endWordPosition="246">tical machine translation (SMT) methods have achieved very promising results and attracted more and more interests in the SMT research community. Fundamentally, syntax-based SMT views translation as a structural transformation process. Therefore, structure divergence and parse errors are two of the major issues that may largely compromise the performance of syntax-based SMT (Zhang et al., 2008a; Mi et al., 2008). Many solutions have been proposed to address the above two issues. Among these advances, forest-based modeling (Mi et al., 2008; Mi and Huang, 2008) and tree sequence-based modeling (Liu et al., 2007; Zhang et al., 2008a) are two interesting modeling methods with promising results reported. Forest-based modeling aims to improve translation accuracy through digging the potential better parses from n-bests (i.e. forest) while tree sequence-based modeling aims to model non-syntactic translations with structured syntactic knowledge. In nature, the two methods would be complementary to each other since they manage to solve the negative impacts of monolingual parse errors and cross-lingual structure divergence on translation results from different viewpoints. Therefore, one natural way is to co</context>
<context position="5538" citStr="Liu et al., 2007" startWordPosition="824" endWordPosition="827">ing the parse errors in the SMT research community. To address structure divergence issue, many researchers (Eisner, 2003; Zhang et al., 2007) propose using the Synchronous Tree Substitution Grammar (STSG) grammar in syntax-based SMT since the STSG uses larger tree fragment as translation unit. Although promising results have been reported, STSG only uses one single subtree as translation unit which is still committed to the syntax strictly. Motivated by the fact that non-syntactic phrases make non-trivial contribution to phrase-based SMT, the tree sequencebased translation model is proposed (Liu et al., 2007; Zhang et al., 2008a) that uses tree sequence as the basic translation unit, rather than using single sub-tree as in the STSG. Here, a tree sequence refers to a sequence of consecutive sub-trees that are embedded in a full parse tree. For any given phrase in a sentence, there is at least one tree sequence covering it. Thus the tree sequence-based model has great potential to address the structure divergence issue by using tree sequence-based non-syntactic translation rules. Liu et al. (2007) propose the tree sequence concept and design a tree sequence to string translation model. Zhang et al.</context>
<context position="9800" citStr="Liu et al. (2007)" startWordPosition="1592" endWordPosition="1595">1. Different parse tree represents different derivations and explanations for a given sentence. For example, for the same input sentence in Fig. 1, T1 interprets it as “XNA (Xinhua News Agency) declares some regulations.” while T2 interprets it as “XNA declaration is related to some regulations.”. Figure 1. A packed forest for sentence “Vff*�f /Xinhuashe � HJJ /shengming � � /youguan � � /guiding” Figure 2. A hyper-edge used in Fig. 1 Figure 3. Tree 1 (T1) Figure 4. Tree 2 (T2) 3.2 Tree sequence in packed forest Similar to the definition of tree sequence used in a single parse tree defined in Liu et al. (2007) and Zhang et al. (2008a), a tree sequence in a forest also refers to an ordered sub-tree sequence that covers a continuous phrase without overlapping. However, the major difference between 1 Please note that a single tree (as T1 and T2 shown in Fig. 3 and Fig. 4) is represented by edges instead of hyper-edges. A hyper-edge is a group of edges satisfying the 2nd condition as shown in the forest definition. them lies in that the sub-trees of a tree sequence in forest may belongs to different single parse trees while, in a single parse tree-based model, all the sub-trees in a tree sequence are c</context>
<context position="11909" citStr="Liu et al. 2007" startWordPosition="1980" endWordPosition="1983">ition, please note that, on the other hand, more parse trees may introduce more noisy structures. In this paper, we leave this problem to our model and let the model decide which substructures are noisy features. Figure 5. A parse tree that was wrongly pruned out Figure 6. A tree sequence to string rule 174 A tree-sequence to string translation rule in a forest is a triple &lt;L, R, A&gt;, where L is the tree sequence in source language, R is the string containing words and variables in target language, and A is the alignment between the leaf nodes of L and R. This definition is similar to that of (Liu et al. 2007, Zhang et al. 2008a) except our treesequence is defined in forest. The shaded area of Fig. 6 exemplifies a tree sequence to string translation rule in the forest. 3.3 Forest-based tree-sequence to string translation model Given a source forest F and target translation TS as well as word alignment A, our translation model is formulated as: Pr(F, 7s, A) = Eeie 0,c(0)=(F,TS,A) F11iE0i P(ri) By the above Eq., translation becomes a tree sequence structure to string mapping issue. Given the F, TS and A, there are multiple derivations that could map F to TS under the constraint A. The mapping probab</context>
</contexts>
<marker>Liu, Huang, Liu, Lin, 2007</marker>
<rawString>Yang Liu, Yun Huang, Qun Liu and Shouxun Lin. 2007. Forest-to-String Statistical Translation Rules. ACL-07. 704-711.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Haitao Mi</author>
<author>Liang Huang</author>
<author>Qun Liu</author>
</authors>
<title>Forestbased translation.</title>
<date>2008</date>
<pages>08--192</pages>
<contexts>
<context position="1569" citStr="Mi et al., 2008" startWordPosition="211" endWordPosition="214">rimental results on the NIST MT-2003 Chinese-English translation task show that our method statistically significantly outperforms the four baseline systems. 1 Introduction Recently syntax-based statistical machine translation (SMT) methods have achieved very promising results and attracted more and more interests in the SMT research community. Fundamentally, syntax-based SMT views translation as a structural transformation process. Therefore, structure divergence and parse errors are two of the major issues that may largely compromise the performance of syntax-based SMT (Zhang et al., 2008a; Mi et al., 2008). Many solutions have been proposed to address the above two issues. Among these advances, forest-based modeling (Mi et al., 2008; Mi and Huang, 2008) and tree sequence-based modeling (Liu et al., 2007; Zhang et al., 2008a) are two interesting modeling methods with promising results reported. Forest-based modeling aims to improve translation accuracy through digging the potential better parses from n-bests (i.e. forest) while tree sequence-based modeling aims to model non-syntactic translations with structured syntactic knowledge. In nature, the two methods would be complementary to each other</context>
<context position="6414" citStr="Mi et al. (2008)" startWordPosition="972" endWordPosition="975">a sentence, there is at least one tree sequence covering it. Thus the tree sequence-based model has great potential to address the structure divergence issue by using tree sequence-based non-syntactic translation rules. Liu et al. (2007) propose the tree sequence concept and design a tree sequence to string translation model. Zhang et al. (2008a) propose a tree sequence-based tree to tree translation model and Zhang et al. (2008b) demonstrate that the tree sequence-based modelling method can well address the structure divergence issue for syntaxbased SMT. To overcome the parse errors for SMT, Mi et al. (2008) propose a forest-based translation method that uses forest instead of one best tree as translation input, where a forest is a compact representation of exponentially number of n-best parse trees. Mi and Huang (2008) propose a forest-based rule extraction algorithm, which learn tree to string rules from source forest and target string. By using forest in rule extraction and decoding, their methods are able to well address the parse error issue. From the above discussion, we can see that traditional tree sequence-based method uses single tree as translation input while the forestbased model use</context>
<context position="20101" citStr="Mi et al. (2008)" startWordPosition="3430" endWordPosition="3433">(h) is the hyper-edge probability. Figure 7. A virtual node in forest 5 Decoding We benefit from the same strategy as used in our rule extraction algorithm in designing our decoding algorithm, recasting the forest-based tree sequence-to-string decoding problem as a forestbased tree-to-string decoding problem. Our decoding algorithm consists of four steps: 1) Convert the complete parse forest to a noncomplete one by introducing virtual nodes. 176 2) Convert the non-complete parse forest into a translation forest4 TF by using the translation rules and the pattern-matching algorithm presented in Mi et al. (2008). 3) Prune out redundant nodes and add auxiliary hyper-edge into the translation forest for those nodes that have either no child or no father. By this step, the translation forest TF becomes a complete forest. 4) Decode the translation forest using our translation model and a dynamic search algorithm. The process of step 1 is similar to Algorithm 1 except no alignment constraint used here. This may generate a large number of additional virtual nodes; however, all redundant nodes will be filtered out in step 3. In step 2, we employ the treeto-string pattern match algorithm (Mi et al., 2008) to</context>
<context position="22329" citStr="Mi et al. (2008)" startWordPosition="3830" endWordPosition="3833">de with the node sequence as children. Since Algorithm 2 is DP-based and traverses the forest in a bottom-up way, all the nodes in a node sequence should already have children node after the lower level process in a small span. Finally, we re-build the NSS of current span for upper level NSS combination use (line 20-22). In Fig. 8, the hyper-edge “IP=&gt;NP VV+VV NP” is an auxiliary hyper-edge introduced by Algorithm 2. By Algorithm 2, we convert the translation forest into a complete translation forest. We then use a bottom-up node-based search 4 The concept of translation forest is proposed in Mi et al. (2008). It is a forest that consists of only the hyperedges induced from translation rules. algorithm to do decoding on the complete translation forest. We also use Cube Pruning algorithm (Huang and Chiang 2007) to speed up the translation process. Figure 8. Auxiliary hyper-edge in a translation forest Algorithm 2. add auxiliary hyper-edges into mt forest F Input: mt forest F Output: complete forest F with auxiliary hyper-edges 1. for i := 1 to L do 2. for each node n of span [i, i] do 3. add n into NSS(i, i) 4. for length := 1 to L - 1 do 5. for start := 1 to L - length do 6. stop := start + length</context>
<context position="24673" citStr="Mi et al., 2008" startWordPosition="4271" endWordPosition="4274">odel is trained on the Xin177 hua portion of the English Gigaword3 corpus and the target side of the FBIS corpus using the SRILM Toolkits (Stolcke, 2002) with modified Kneser-Ney smoothing (Kenser and Ney, 1995). GIZA++ (Och and Ney, 2003) and the heuristics “grow-diag-final-and” are used to generate m-ton word alignments. For the MER training (Och, 2003), Koehn’s MER trainer (Koehn, 2007) is modified for our system. For significance test, we use Zhang et al.’s implementation (Zhang et al, 2004). Our evaluation metrics is casesensitive BLEU-4 (Papineni et al., 2002). For parse forest pruning (Mi et al., 2008), we utilize the Margin-based pruning algorithm presented in (Huang, 2008). Different from Mi et al. (2008) that use a static pruning threshold, our threshold is sentence-depended. For each sentence, we compute the Margin between the n-th best and the top 1 parse tree, then use the Margin-based pruning algorithm presented in (Huang, 2008) to do pruning. By doing so, we can guarantee to use at least all the top n best parse trees in the forest. However, please note that even after pruning there is still exponential number of additional trees embedded in the forest because of the sharing structu</context>
</contexts>
<marker>Mi, Huang, Liu, 2008</marker>
<rawString>Haitao Mi, Liang Huang, and Qun Liu. 2008. Forestbased translation. ACL-HLT-08. 192-199.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Haitao Mi</author>
<author>Liang Huang</author>
</authors>
<title>Forest-based Translation Rule Extraction.</title>
<date>2008</date>
<volume>08</volume>
<pages>206--214</pages>
<contexts>
<context position="1719" citStr="Mi and Huang, 2008" startWordPosition="235" endWordPosition="238">e systems. 1 Introduction Recently syntax-based statistical machine translation (SMT) methods have achieved very promising results and attracted more and more interests in the SMT research community. Fundamentally, syntax-based SMT views translation as a structural transformation process. Therefore, structure divergence and parse errors are two of the major issues that may largely compromise the performance of syntax-based SMT (Zhang et al., 2008a; Mi et al., 2008). Many solutions have been proposed to address the above two issues. Among these advances, forest-based modeling (Mi et al., 2008; Mi and Huang, 2008) and tree sequence-based modeling (Liu et al., 2007; Zhang et al., 2008a) are two interesting modeling methods with promising results reported. Forest-based modeling aims to improve translation accuracy through digging the potential better parses from n-bests (i.e. forest) while tree sequence-based modeling aims to model non-syntactic translations with structured syntactic knowledge. In nature, the two methods would be complementary to each other since they manage to solve the negative impacts of monolingual parse errors and cross-lingual structure divergence on translation results from differ</context>
<context position="6630" citStr="Mi and Huang (2008)" startWordPosition="1007" endWordPosition="1010">rules. Liu et al. (2007) propose the tree sequence concept and design a tree sequence to string translation model. Zhang et al. (2008a) propose a tree sequence-based tree to tree translation model and Zhang et al. (2008b) demonstrate that the tree sequence-based modelling method can well address the structure divergence issue for syntaxbased SMT. To overcome the parse errors for SMT, Mi et al. (2008) propose a forest-based translation method that uses forest instead of one best tree as translation input, where a forest is a compact representation of exponentially number of n-best parse trees. Mi and Huang (2008) propose a forest-based rule extraction algorithm, which learn tree to string rules from source forest and target string. By using forest in rule extraction and decoding, their methods are able to well address the parse error issue. From the above discussion, we can see that traditional tree sequence-based method uses single tree as translation input while the forestbased model uses single sub-tree as the basic translation unit that can only learn tree-to-string (Galley et al. 2004; Liu et al., 2006) rules. Therefore, the two methods display different strengths, and which would be complementar</context>
<context position="13650" citStr="Mi and Huang (2008)" startWordPosition="2284" endWordPosition="2287"> probabilities, 2) bidirectional lexical rule translation probabilities, 3) target language model, 4) number of rules used and 5) number of target words. In addition, we define two new features: 1) number of leaf nodes in auxiliary rules (the auxiliary rule will be explained later in this paper) and 2) product of the probabilities of all hyper-edges of the tree sequences in forest. 4 Training This section discusses how to extract our translation rules given a triple &lt; F, TS, A &gt; . As we know, the traditional tree-to-string rules can be easily extracted from &lt; F, TS, A &gt; using the algorithm of Mi and Huang (2008)2. We would like 2 Mi and Huang (2008) extend the tree-based rule extraction algorithm (Galley et al., 2004) to forest-based by introducing non-deterministic mechanism. Their algorithm consists of two steps, minimal rule extraction and composed rule generation. to leverage on their algorithm in our study. Unfortunately, their algorithm is not directly applicable to our problem because tree rules have only one root while tree sequence rules have multiple roots. This makes the tree sequence rule extraction very complex due to its interaction with forest structure. To address this issue, we intro</context>
<context position="18389" citStr="Mi and Huang, 2008" startWordPosition="3137" endWordPosition="3140">r each ns2 in NSS(pivot+1, stop) do 11. create ns := ns1 O ns2 12. if ns is not in NSS(start, stop) then 13. add ns into NSS(start, stop) 14. do pruning on NSS(start, stop) 15. if the span[start, stop] is alignable then 16. for each ns of NSS(start, stop) do 17. if node VN(ns) is not in F then 18. add node VN(ns) into F 19. add a hyper-edge h into F, 20. let lhs(h) := VN(ns), rhs(h) := ns Algorithm 1 outputs a non-complete forest CF with each alignable span covered by either tree nodes or virtual nodes. Then we can easily extract our rules from the CF using the tree rule extraction algorithm (Mi and Huang, 2008). Finally, to calculate rule feature probabilities for our model, we need to calculate the fractional counts (it is a kind of probability defined in Mi and Huang, 2008) of each translation rule in a parse forest. In the tree case, we can use the inside-outside-based methods (Mi and Huang 2008) to do it. In the tree sequence case, since the previous method cannot be used directly, we provide another solution by making an independent assumption that each tree in a tree sequence is independent to each other. With this assumption, the fractional counts of both tree and tree sequence can be calcula</context>
</contexts>
<marker>Mi, Huang, 2008</marker>
<rawString>Haitao Mi and Liang Huang. 2008. Forest-based Translation Rule Extraction. EMNLP-08. 206-214.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Franz J Och</author>
<author>Hermann Ney</author>
</authors>
<title>Discriminative training and maximum entropy models for statistical machine translation.</title>
<date>2002</date>
<pages>02--295</pages>
<contexts>
<context position="12884" citStr="Och and Ney, 2002" startWordPosition="2151" endWordPosition="2154">Eeie 0,c(0)=(F,TS,A) F11iE0i P(ri) By the above Eq., translation becomes a tree sequence structure to string mapping issue. Given the F, TS and A, there are multiple derivations that could map F to TS under the constraint A. The mapping probability Pr(F, TS, A) in our study is obtained by summing over the probabilities of all derivations 0. The probability of each derivation Bi is given as the product of the probabilities of all the rules p(ri ) used in the derivation (here we assume that each rule is applied independently in a derivation). Our model is implemented under log-linear framework (Och and Ney, 2002). We use seven basic features that are analogous to the commonly used features in phrase-based systems (Koehn, 2003): 1) bidirectional rule mapping probabilities, 2) bidirectional lexical rule translation probabilities, 3) target language model, 4) number of rules used and 5) number of target words. In addition, we define two new features: 1) number of leaf nodes in auxiliary rules (the auxiliary rule will be explained later in this paper) and 2) product of the probabilities of all hyper-edges of the tree sequences in forest. 4 Training This section discusses how to extract our translation rul</context>
</contexts>
<marker>Och, Ney, 2002</marker>
<rawString>Franz J. Och and Hermann Ney. 2002. Discriminative training and maximum entropy models for statistical machine translation. ACL-02. 295-302.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Franz J Och</author>
</authors>
<title>Minimum error rate training in statistical machine translation.</title>
<date>2003</date>
<pages>03--160</pages>
<contexts>
<context position="24414" citStr="Och, 2003" startWordPosition="4231" endWordPosition="4232">st set. We train Charniak’s parser (Charniak 2000) on CTB5 to do Chinese parsing, and modify it to output packed forest. We tune the parser on section 301-325 and test it on section 271- 300. The F-measure on all sentences is 80.85%. A 3-gram language model is trained on the Xin177 hua portion of the English Gigaword3 corpus and the target side of the FBIS corpus using the SRILM Toolkits (Stolcke, 2002) with modified Kneser-Ney smoothing (Kenser and Ney, 1995). GIZA++ (Och and Ney, 2003) and the heuristics “grow-diag-final-and” are used to generate m-ton word alignments. For the MER training (Och, 2003), Koehn’s MER trainer (Koehn, 2007) is modified for our system. For significance test, we use Zhang et al.’s implementation (Zhang et al, 2004). Our evaluation metrics is casesensitive BLEU-4 (Papineni et al., 2002). For parse forest pruning (Mi et al., 2008), we utilize the Margin-based pruning algorithm presented in (Huang, 2008). Different from Mi et al. (2008) that use a static pruning threshold, our threshold is sentence-depended. For each sentence, we compute the Margin between the n-th best and the top 1 parse tree, then use the Margin-based pruning algorithm presented in (Huang, 2008) </context>
</contexts>
<marker>Och, 2003</marker>
<rawString>Franz J. Och. 2003. Minimum error rate training in statistical machine translation. ACL-03. 160-167.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Franz Josef Och</author>
<author>Hermann Ney</author>
</authors>
<title>A Systematic Comparison of Various Statistical Alignment Models. Computational Linguistics.</title>
<date>2003</date>
<volume>29</volume>
<issue>1</issue>
<contexts>
<context position="24296" citStr="Och and Ney, 2003" startWordPosition="4211" endWordPosition="4214">We use the FBIS corpus as training set, the NIST MT-2002 test set as development (dev) set and the NIST MT-2003 test set as test set. We train Charniak’s parser (Charniak 2000) on CTB5 to do Chinese parsing, and modify it to output packed forest. We tune the parser on section 301-325 and test it on section 271- 300. The F-measure on all sentences is 80.85%. A 3-gram language model is trained on the Xin177 hua portion of the English Gigaword3 corpus and the target side of the FBIS corpus using the SRILM Toolkits (Stolcke, 2002) with modified Kneser-Ney smoothing (Kenser and Ney, 1995). GIZA++ (Och and Ney, 2003) and the heuristics “grow-diag-final-and” are used to generate m-ton word alignments. For the MER training (Och, 2003), Koehn’s MER trainer (Koehn, 2007) is modified for our system. For significance test, we use Zhang et al.’s implementation (Zhang et al, 2004). Our evaluation metrics is casesensitive BLEU-4 (Papineni et al., 2002). For parse forest pruning (Mi et al., 2008), we utilize the Margin-based pruning algorithm presented in (Huang, 2008). Different from Mi et al. (2008) that use a static pruning threshold, our threshold is sentence-depended. For each sentence, we compute the Margin b</context>
</contexts>
<marker>Och, Ney, 2003</marker>
<rawString>Franz Josef Och and Hermann Ney. 2003. A Systematic Comparison of Various Statistical Alignment Models. Computational Linguistics. 29(1) 19-51.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kishore Papineni</author>
<author>Salim Roukos</author>
<author>ToddWard</author>
<author>Wei-Jing Zhu</author>
</authors>
<title>BLEU: a method for automatic evaluation of machine translation.</title>
<date>2002</date>
<pages>02--311</pages>
<contexts>
<context position="24629" citStr="Papineni et al., 2002" startWordPosition="4263" endWordPosition="4266">re on all sentences is 80.85%. A 3-gram language model is trained on the Xin177 hua portion of the English Gigaword3 corpus and the target side of the FBIS corpus using the SRILM Toolkits (Stolcke, 2002) with modified Kneser-Ney smoothing (Kenser and Ney, 1995). GIZA++ (Och and Ney, 2003) and the heuristics “grow-diag-final-and” are used to generate m-ton word alignments. For the MER training (Och, 2003), Koehn’s MER trainer (Koehn, 2007) is modified for our system. For significance test, we use Zhang et al.’s implementation (Zhang et al, 2004). Our evaluation metrics is casesensitive BLEU-4 (Papineni et al., 2002). For parse forest pruning (Mi et al., 2008), we utilize the Margin-based pruning algorithm presented in (Huang, 2008). Different from Mi et al. (2008) that use a static pruning threshold, our threshold is sentence-depended. For each sentence, we compute the Margin between the n-th best and the top 1 parse tree, then use the Margin-based pruning algorithm presented in (Huang, 2008) to do pruning. By doing so, we can guarantee to use at least all the top n best parse trees in the forest. However, please note that even after pruning there is still exponential number of additional trees embedded </context>
</contexts>
<marker>Papineni, Roukos, ToddWard, Zhu, 2002</marker>
<rawString>Kishore Papineni, Salim Roukos, ToddWard and Wei-Jing Zhu. 2002. BLEU: a method for automatic evaluation of machine translation. ACL-02. 311-318.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Andreas Stolcke</author>
</authors>
<title>SRILM - an extensible language modeling toolkit.</title>
<date>2002</date>
<pages>02--901</pages>
<contexts>
<context position="24210" citStr="Stolcke, 2002" startWordPosition="4200" endWordPosition="4201">Experimental Settings We evaluate our method on Chinese-English translation task. We use the FBIS corpus as training set, the NIST MT-2002 test set as development (dev) set and the NIST MT-2003 test set as test set. We train Charniak’s parser (Charniak 2000) on CTB5 to do Chinese parsing, and modify it to output packed forest. We tune the parser on section 301-325 and test it on section 271- 300. The F-measure on all sentences is 80.85%. A 3-gram language model is trained on the Xin177 hua portion of the English Gigaword3 corpus and the target side of the FBIS corpus using the SRILM Toolkits (Stolcke, 2002) with modified Kneser-Ney smoothing (Kenser and Ney, 1995). GIZA++ (Och and Ney, 2003) and the heuristics “grow-diag-final-and” are used to generate m-ton word alignments. For the MER training (Och, 2003), Koehn’s MER trainer (Koehn, 2007) is modified for our system. For significance test, we use Zhang et al.’s implementation (Zhang et al, 2004). Our evaluation metrics is casesensitive BLEU-4 (Papineni et al., 2002). For parse forest pruning (Mi et al., 2008), we utilize the Margin-based pruning algorithm presented in (Huang, 2008). Different from Mi et al. (2008) that use a static pruning thr</context>
</contexts>
<marker>Stolcke, 2002</marker>
<rawString>Andreas Stolcke. 2002. SRILM - an extensible language modeling toolkit. ICSLP-02. 901-904.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Min Zhang</author>
<author>Hongfei Jiang</author>
</authors>
<title>Ai Ti Aw, Jun Sun, Sheng Li and Chew Lim Tan.</title>
<date>2007</date>
<volume>07</volume>
<pages>535--542</pages>
<marker>Zhang, Jiang, 2007</marker>
<rawString>Min Zhang, Hongfei Jiang, Ai Ti Aw, Jun Sun, Sheng Li and Chew Lim Tan. 2007. A Tree-to-Tree Alignment-based Model for Statistical Machine Translation. MT-Summit-07. 535-542.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Min Zhang</author>
</authors>
<title>Hongfei Jiang, Aiti Aw,</title>
<date>2008</date>
<volume>08</volume>
<pages>559--567</pages>
<location>Haizhou Li, Chew Lim Tan, Sheng Li.</location>
<marker>Zhang, 2008</marker>
<rawString>Min Zhang, Hongfei Jiang, Aiti Aw, Haizhou Li, Chew Lim Tan, Sheng Li. 2008a. A Tree Sequence Alignment-based Tree-to-Tree Translation Model. ACL-HLT-08. 559-567.</rawString>
</citation>
<citation valid="false">
<authors>
<author>Min Zhang</author>
<author>Hongfei Jiang</author>
<author>Haizhou Li</author>
</authors>
<title>Aiti Aw, Sheng Li.</title>
<booktitle>2008b. Grammar Comparison Study for Translational Equivalence Modeling and Statistical Machine Translation. COLING-08.</booktitle>
<pages>1097--1104</pages>
<marker>Zhang, Jiang, Li, </marker>
<rawString>Min Zhang, Hongfei Jiang, Haizhou Li, Aiti Aw, Sheng Li. 2008b. Grammar Comparison Study for Translational Equivalence Modeling and Statistical Machine Translation. COLING-08. 1097-1104.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ying Zhang</author>
<author>Stephan Vogel</author>
<author>Alex Waibel</author>
</authors>
<title>Interpreting BLEU/NIST scores: How much improvement do we need to have a better system?</title>
<date>2004</date>
<pages>04--2051</pages>
<contexts>
<context position="24557" citStr="Zhang et al, 2004" startWordPosition="4252" endWordPosition="4255">rser on section 301-325 and test it on section 271- 300. The F-measure on all sentences is 80.85%. A 3-gram language model is trained on the Xin177 hua portion of the English Gigaword3 corpus and the target side of the FBIS corpus using the SRILM Toolkits (Stolcke, 2002) with modified Kneser-Ney smoothing (Kenser and Ney, 1995). GIZA++ (Och and Ney, 2003) and the heuristics “grow-diag-final-and” are used to generate m-ton word alignments. For the MER training (Och, 2003), Koehn’s MER trainer (Koehn, 2007) is modified for our system. For significance test, we use Zhang et al.’s implementation (Zhang et al, 2004). Our evaluation metrics is casesensitive BLEU-4 (Papineni et al., 2002). For parse forest pruning (Mi et al., 2008), we utilize the Margin-based pruning algorithm presented in (Huang, 2008). Different from Mi et al. (2008) that use a static pruning threshold, our threshold is sentence-depended. For each sentence, we compute the Margin between the n-th best and the top 1 parse tree, then use the Margin-based pruning algorithm presented in (Huang, 2008) to do pruning. By doing so, we can guarantee to use at least all the top n best parse trees in the forest. However, please note that even after</context>
</contexts>
<marker>Zhang, Vogel, Waibel, 2004</marker>
<rawString>Ying Zhang, Stephan Vogel, Alex Waibel. 2004. Interpreting BLEU/NIST scores: How much improvement do we need to have a better system? LREC-04. 2051-2054.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>