<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.012731">
<title confidence="0.967089">
Efficient solving and exploration of scope ambiguities
</title>
<author confidence="0.997351">
Alexander Koller and Stefan Thater
</author>
<affiliation confidence="0.9443005">
Department of Computational Linguistics
Saarland University, Saarbrücken, Germany
</affiliation>
<email confidence="0.998129">
{koller,stth}@coli.uni-sb.de
</email>
<sectionHeader confidence="0.997378" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999738625">
We present the currently most efficient
solver for scope underspecification; it also
converts between different underspecifica-
tion formalisms and counts readings. Our
tool makes the practical use of large-scale
grammars with (underspecified) semantic
output more feasible, and can be used in
grammar debugging.
</bodyText>
<sectionHeader confidence="0.999394" genericHeader="introduction">
1 Introduction
</sectionHeader>
<bodyText confidence="0.997979911111111">
One of the most exciting recent developments in
computational linguistics is that large-scale gram-
mars which compute semantic representations are
becoming available. Examples for such grammars
are the HPSG English Resource Grammar (ERG)
(Copestake and Flickinger, 2000) and the LFG Par-
Gram grammars (Butt et al., 2002); a similar re-
source is being developed for the XTAG grammar
(Kallmeyer and Romero, 2004).
But with the advent of such grammars, a phe-
nomenon that is sometimes considered a some-
what artificial toy problem of theoretical semanti-
cists becomes a very practical challenge: the pres-
ence of scope ambiguities. Because grammars of-
ten uniformly treat noun phrases as quantifiers, even
harmless-looking sentences can have surprisingly
many readings. The median number of scope read-
ings for the sentences in the Rondane Treebank (dis-
tributed with the ERG) is 55, but the treebank also
contains extreme cases such as (1) below, which ac-
cording to the ERG has about 2.4 trillion (1012) read-
ings:
(1) Myrdal is the mountain terminus of the Flåm
rail line (or Flåmsbana) which makes its way
down the lovely Flåm Valley (Flåmsdalen) to
its sea-level terminus at Flåm. (Rondane 650)
In order to control such an explosion of readings
(and also to simplify the grammar design process),
the developers of large-scale grammars typically use
methods of packing or underspecification to spec-
ify the syntax-semantics interface. The general idea
is that the parser doesn’t compute all the individual
scope readings, but only a compact underspecified
description, from which the individual readings can
then be extracted at a later stage of processing – but
the underspecified description could also be used as
a platform for the integration of lexical and context
information, so as to restrict the set of possible read-
ings without enumerating the wrong ones.
Such an approach is only feasible if we have ac-
cess to efficient tools that support the most impor-
tant operations on underspecified descriptions. We
present utool, the Swiss Army Knife of Underspec-
ification, which sets out to do exactly this. It sup-
ports the following operations:
</bodyText>
<listItem confidence="0.946388833333333">
1. enumerate all scope readings represented by an
underspecified description;
2. check whether a description has any readings,
and compute how many readings it has without
explicitly enumerating them;
3. convert underspecified descriptions between
different underspecification formalisms (at this
point, Minimal Recursion Semantics (Copes-
take et al., 2003), Hole Semantics (Bos, 1996),
and dominance constraints/graphs (Egg et al.,
2001; Althaus et al., 2003)).
9
</listItem>
<subsubsectionHeader confidence="0.268556">
Proceedings of the ACL Interactive Poster and Demonstration Sessions,
</subsubsectionHeader>
<bodyText confidence="0.960165058823529">
pages 9–12, Ann Arbor, June 2005. c�2005 Association for Computational Linguistics
Our system is the fastest solver for underspecifi-
cied description available today; that is, it is fastest
at solving Task 1 above (about 100.000 readings per
second on a modern PC). It achieves this by im-
plementing an efficient algorithm for solving dom-
inance graphs (Bodirsky et al., 2004) and caching
intermediate results in a chart data structure. To our
knowledge, it is the only system that can do Tasks
2 and 3. It is only because utool can compute the
number of readings without enumerating them that
we even know that (1) has trillions of readings; even
utool would take about a year to enumerate and
count the readings individually.
utool is implemented in C++, efficient and
portable, open source, and freely downloadable from
http://utool.sourceforge.net.
</bodyText>
<sectionHeader confidence="0.998585" genericHeader="method">
2 Technical Description
</sectionHeader>
<subsectionHeader confidence="0.999604">
2.1 Solving dominance graphs
</subsectionHeader>
<bodyText confidence="0.999987356164384">
At the core of utool is a solver for dominance
graphs (Bodirsky et al., 2004) – graph represen-
tations of weakly normal dominance constraints,
which constitute one of the main formalisms used
in scope underspecification (Egg et al., 2001; Al-
thaus et al., 2003). Dominance graphs are directed
graphs with two kinds of edges, tree edges and dom-
inance edges. They can be used to describe the set
of all trees into which their tree edges can be embed-
ded, in such a way that every dominance edge in the
graph is realised as reachability in the tree. Domi-
nance graphs are used as underspecified descriptions
by describing sets of trees that are encodings of the
formulas of some language of semantic representa-
tions, such as predicate logic.
Fig. 1 shows an example of a constraint graph for
the sentence “every student reads a book.” It con-
sists of five tree fragments – sets of nodes that are
connected by (solid) tree edges – which are con-
nected by dominance edges (dotted lines). Two of
the fragments have two holes each, into which other
fragments can be “plugged”. The graph can be em-
bedded into the two trees shown in the middle of
Fig. 1, which correspond to the two readings of the
sentence. By contrast, the graph cannot be embed-
ded into the tree shown on the right: a dominance
edge stipulates that “readx,,,” must be reachable from
“somey”, but it is not reachable from “somey” in the
tree. We call the two trees into which the graph can
be embedded its solutions.
The Bodirsky et al. algorithm enumerates the so-
lutions of a dominance graph (technically, its solved
forms) by computing the set of its free fragments,
which are the fragments that can occur at the root of
some solution. Then it picks one of these fragments
as the root and removes it from the graph. This splits
the graph into several connected subgraphs, which
are then solved recursively.
This algorithm can call itself for the same sub-
graph several times, which can waste a lot of time
because the set of all solutions was already com-
puted for the subgraph on the first recursive call.
For this reason, our implementation caches interme-
diate results in a chart-like data structure. This data
structure maps each subgraph G to a set of splits,
each of which records which fragment of G should
be placed at the root of the solution, what the sub-
graphs after removal of this fragment are, and how
their solutions should be plugged into the holes of
the fragment. In the worst case, the chart can have
exponential size; but in practice, it is much smaller
than the set of all solutions. For example, the chart
for (1) contains 74.960 splits, which is a tiny num-
ber compared to the 2.4 trillion readings, and can be
computed in a few seconds.
Now solving becomes a two-phase process. In the
first phase, the chart data structure is filled by a run
of the algorithm. In the second phase, the complete
solutions are extracted from the chart. Although the
first phase is conceptually much more complex than
the second one because it involves interesting graph
algorithms whose correctness isn’t trivial to prove,
it takes only a small fraction of the entire runtime in
practice.
Instead of enumerating all readings from the
chart, we can also compute the number of solutions
represented by the chart. For each split, we compute
the numbers of solutions of the fragment sets in the
split. Then we multiply these numbers (choices for
the children can be combined freely). Finally, we
obtain the number of solutions for a subgraph by
adding the numbers of solutions of all its splits. This
computation takes linear time in the size of the chart.
</bodyText>
<page confidence="0.989248">
10
</page>
<figureCaption confidence="0.999538">
Figure 1: A dominance graph (left), two solutions (middle) and a non-solution (right).
</figureCaption>
<figure confidence="0.999551277777778">
booky
booky studentx
readx,y
everyx
somey
everyx
somey
everyx somey
somey
everyx
studentx
readx,y
booky
studentx readx,y
✓ ✓ ×
studentx
readx,y
booky
</figure>
<subsectionHeader confidence="0.997113">
2.2 Translating between formalisms
</subsectionHeader>
<bodyText confidence="0.999901857142857">
One of the most significant obstacles in the develop-
ment of tools and resources for scope underspecifi-
cation is that different resources (such as grammars
and solvers) are built for different underspecification
formalisms. To help alleviate this problem, utool
can read and write underspecified descriptions and
write out solutions in a variety of different formats:
</bodyText>
<listItem confidence="0.999670666666667">
• dominance graphs;
• descriptions of Minimal Recursion Semantics;
• descriptions of Hole Semantics.
</listItem>
<bodyText confidence="0.9998955">
The input and output functionality is provided
by codecs, which translate between descriptions in
one of these formalisms and the internal dominance
graph format. The codecs for MRS and Hole Se-
mantics are based on the (non-trivial) translations
in (Koller et al., 2003; Niehren and Thater, 2003)
and are only defined on nets, i.e. constraints whose
graphs satisfy certain structural restrictions. This is
not a very limiting restriction in practice (Flickinger
et al., 2005). utool also allows the user to test effi-
ciently whether a description is a net.
In practice, utool can be used to convert de-
scriptions between the three underspecification for-
malisms. Because the codecs work with concrete
syntaxes that are used in existing systems, utool
can be used as a drop-in replacement e.g. in the
LKB grammar development system (Copestake and
Flickinger, 2000).
</bodyText>
<subsectionHeader confidence="0.997265">
2.3 Runtime comparison
</subsectionHeader>
<bodyText confidence="0.9998456">
To illustrate utool’s performance, we compare its
runtimes for the enumeration task with the (already
quite efficient) MRS constraint solver of the LKB
system (Copestake and Flickinger, 2000). Our data
set consists of the 850 MRS-nets extracted from the
</bodyText>
<figure confidence="0.913275">
0 5 10 15 20 25 30 35 40
</figure>
<figureCaption confidence="0.9662865">
Figure 2: Distribution of constraints in Rondane over
different sizes. The solid line shows the constraints
</figureCaption>
<bodyText confidence="0.978583681818182">
in the data set, and the dashed line shows the con-
straints that the LKB solver could solve.
Rondane treebank which have less than one million
solutions (see Fig. 2). Fig. 3 displays the runtimes
for enumerating all solutions, divided by the num-
ber of solutions, for both solvers. The horizontal axis
shows the description sizes (number of tree frag-
ments), and the (logarithmic!) vertical axis shows
the average runtime per solution for descriptions of
this size.
Due to memory limitations, the LKB solver could
only solve descriptions with up to 21 tree fragments,
which account for 80% of the test data. utool solved
all descriptions in the test set. The evaluation was
done using a 1.2 GHz PC with 2 GB of memory.
The figure shows that utool is generally faster
than the LKB solver, up to a factor of approx. 1000.
We should note that the LKB solver displays a dra-
matically higher variation in runtimes for constraints
of the same size. Note that for small constraints, the
runtimes tend to be too small to measure them accu-
rately.
</bodyText>
<figure confidence="0.947632">
70
60
50
40
30
20
10
0
.utool.
.MRS.
11
0 5 10 15 20 25 30 35 40
</figure>
<figureCaption confidence="0.9856665">
Figure 3: Runtimes per solution (in ms) for the MRS
nets in the Rondane treebank for LKB and utool.
</figureCaption>
<sectionHeader confidence="0.99677" genericHeader="conclusions">
3 Conclusion
</sectionHeader>
<bodyText confidence="0.9947280625">
We have presented utool, a tool that supports a va-
riety of operations related to scope underspecifica-
tion. It is the most efficient solver for underspecifi-
cation available today, and provides functionality for
counting readings, testing whether a description is a
net, and converting between different underspecifi-
cation formalisms. It collects the results of several
years of formal and computational research on dom-
inance graphs into one convenient system.
The most obvious use of utool is the enumeration
of readings of underspecified descriptions produced
by large-scale grammars. This means that a user can
realistically map the semantic output of these gram-
mars into actual semantic representations. However,
the tool is also useful for developers of such gram-
mars. It can be used to count and explore the read-
ings of the underspecified descriptions the grammar
computes, and has already been used in the debug-
ging of the syntax-semantics interface of the ERG
(Flickinger et al., 2005).
From a more general perspective, the real ap-
peal of underspecification is that it could allow us
to eliminate readings that contradict the context or
our world knowledge, without having to enumerate
these readings first. Such inferences could already
take place on the level of the underspecified descrip-
tion (Koller and Niehren, 2000). But the new chart
data structure that utool computes is a more explicit
packed representation of the possible readings, and
still relatively small in practice. Thus it could open
up avenues for more theoretical future research as
well.
</bodyText>
<sectionHeader confidence="0.994494" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999374086956522">
Ernst Althaus, Denys Duchier, Alexander Koller, Kurt
Mehlhorn, Joachim Niehren, and Sven Thiel. 2003.
An efficient graph algorithm for dominance con-
straints. Journal ofAlgorithms, 48:194–219.
Manuel Bodirsky, Denys Duchier, Joachim Niehren, and
Sebastian Miele. 2004. An efficient algorithm for
weakly normal dominance constraints. In ACM-SIAM
Symposium on Discrete Algorithms. The ACM Press.
Johan Bos. 1996. Predicate logic unplugged. In Pro-
ceedings of the Tenth Amsterdam Colloquium, pages
133–143.
Miriam Butt, Helge Dyvik, Tracey Holloway King, Hi-
roshi Masuichi, and Christian Rohrer. 2002. The par-
allel grammar project. In Proceedings of the COLING
2002 Workshop on Grammar engeneering and evalua-
tion.
Ann Copestake and Dan Flickinger. 2000. An open-
source grammar development environment and broad-
coverage English grammar using HPSG. In Confer-
ence on Language Resources and Evaluation.
Ann Copestake, Dan Flickinger, Carl Pollard, and Ivan
Sag. 2003. Minimal recursion semantics: An in-
troduction. Available at http://lingo.stanford.
edu/sag/papers/copestake.pdf.
Markus Egg, Alexander Koller, and Joachim Niehren.
2001. The Constraint Language for Lambda Struc-
tures. Logic, Language, and Information, 10:457–485.
Dan Flickinger, Alexander Koller, and Stefan Thater.
2005. A new well-formedness criterion for semantics
debugging. In Proceedings of the 12th HPSG Confer-
ence, Lisbon.
Laura Kallmeyer and Maribel Romero. 2004. LTAG se-
mantics with semantic unification. In Proceedings of
the TAG+7 Workshop, Vancouver.
Alexander Koller and Joachim Niehren. 2000. On un-
derspecified processing of dynamic semantics. In Pro-
ceedings of COLING-2000, Saarbrücken.
Alexander Koller, Joachim Niehren, and Stefan Thater.
2003. Bridging the gap between underspecification
formalisms: Hole semantics as dominance constraints.
In Proceedings of the 10th EACL, Budapest.
Joachim Niehren and Stefan Thater. 2003. Bridging the
gap between underspecification formalisms: Minimal
recursion semantics as dominance constraints. In Pro-
ceedings of the 41st Annual Meeting of the Association
for Computational Linguistics.
</reference>
<figure confidence="0.99651125">
1000
100
10
1
0. 1
0.01
&amp;quot;utool&amp;quot;
&amp;quot;MRS&amp;quot;
</figure>
<page confidence="0.898287">
12
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.823307">
<title confidence="0.999758">Efficient solving and exploration of scope ambiguities</title>
<author confidence="0.994908">Koller Thater</author>
<affiliation confidence="0.9564045">Department of Computational Linguistics Saarland University, Saarbrücken, Germany</affiliation>
<email confidence="0.998179">koller@coli.uni-sb.de</email>
<email confidence="0.998179">stth@coli.uni-sb.de</email>
<abstract confidence="0.989752888888889">We present the currently most efficient solver for scope underspecification; it also converts between different underspecification formalisms and counts readings. Our tool makes the practical use of large-scale grammars with (underspecified) semantic output more feasible, and can be used in grammar debugging.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Ernst Althaus</author>
<author>Denys Duchier</author>
<author>Alexander Koller</author>
<author>Kurt Mehlhorn</author>
<author>Joachim Niehren</author>
<author>Sven Thiel</author>
</authors>
<title>An efficient graph algorithm for dominance constraints.</title>
<date>2003</date>
<journal>Journal ofAlgorithms,</journal>
<pages>48--194</pages>
<contexts>
<context position="3130" citStr="Althaus et al., 2003" startWordPosition="469" endWordPosition="472">derspecified descriptions. We present utool, the Swiss Army Knife of Underspecification, which sets out to do exactly this. It supports the following operations: 1. enumerate all scope readings represented by an underspecified description; 2. check whether a description has any readings, and compute how many readings it has without explicitly enumerating them; 3. convert underspecified descriptions between different underspecification formalisms (at this point, Minimal Recursion Semantics (Copestake et al., 2003), Hole Semantics (Bos, 1996), and dominance constraints/graphs (Egg et al., 2001; Althaus et al., 2003)). 9 Proceedings of the ACL Interactive Poster and Demonstration Sessions, pages 9–12, Ann Arbor, June 2005. c�2005 Association for Computational Linguistics Our system is the fastest solver for underspecificied description available today; that is, it is fastest at solving Task 1 above (about 100.000 readings per second on a modern PC). It achieves this by implementing an efficient algorithm for solving dominance graphs (Bodirsky et al., 2004) and caching intermediate results in a chart data structure. To our knowledge, it is the only system that can do Tasks 2 and 3. It is only because utool</context>
<context position="4367" citStr="Althaus et al., 2003" startWordPosition="666" endWordPosition="670"> number of readings without enumerating them that we even know that (1) has trillions of readings; even utool would take about a year to enumerate and count the readings individually. utool is implemented in C++, efficient and portable, open source, and freely downloadable from http://utool.sourceforge.net. 2 Technical Description 2.1 Solving dominance graphs At the core of utool is a solver for dominance graphs (Bodirsky et al., 2004) – graph representations of weakly normal dominance constraints, which constitute one of the main formalisms used in scope underspecification (Egg et al., 2001; Althaus et al., 2003). Dominance graphs are directed graphs with two kinds of edges, tree edges and dominance edges. They can be used to describe the set of all trees into which their tree edges can be embedded, in such a way that every dominance edge in the graph is realised as reachability in the tree. Dominance graphs are used as underspecified descriptions by describing sets of trees that are encodings of the formulas of some language of semantic representations, such as predicate logic. Fig. 1 shows an example of a constraint graph for the sentence “every student reads a book.” It consists of five tree fragme</context>
</contexts>
<marker>Althaus, Duchier, Koller, Mehlhorn, Niehren, Thiel, 2003</marker>
<rawString>Ernst Althaus, Denys Duchier, Alexander Koller, Kurt Mehlhorn, Joachim Niehren, and Sven Thiel. 2003. An efficient graph algorithm for dominance constraints. Journal ofAlgorithms, 48:194–219.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Manuel Bodirsky</author>
<author>Denys Duchier</author>
<author>Joachim Niehren</author>
<author>Sebastian Miele</author>
</authors>
<title>An efficient algorithm for weakly normal dominance constraints.</title>
<date>2004</date>
<booktitle>In ACM-SIAM Symposium on Discrete Algorithms. The</booktitle>
<publisher>ACM Press.</publisher>
<contexts>
<context position="3578" citStr="Bodirsky et al., 2004" startWordPosition="539" endWordPosition="542">ms (at this point, Minimal Recursion Semantics (Copestake et al., 2003), Hole Semantics (Bos, 1996), and dominance constraints/graphs (Egg et al., 2001; Althaus et al., 2003)). 9 Proceedings of the ACL Interactive Poster and Demonstration Sessions, pages 9–12, Ann Arbor, June 2005. c�2005 Association for Computational Linguistics Our system is the fastest solver for underspecificied description available today; that is, it is fastest at solving Task 1 above (about 100.000 readings per second on a modern PC). It achieves this by implementing an efficient algorithm for solving dominance graphs (Bodirsky et al., 2004) and caching intermediate results in a chart data structure. To our knowledge, it is the only system that can do Tasks 2 and 3. It is only because utool can compute the number of readings without enumerating them that we even know that (1) has trillions of readings; even utool would take about a year to enumerate and count the readings individually. utool is implemented in C++, efficient and portable, open source, and freely downloadable from http://utool.sourceforge.net. 2 Technical Description 2.1 Solving dominance graphs At the core of utool is a solver for dominance graphs (Bodirsky et al.</context>
</contexts>
<marker>Bodirsky, Duchier, Niehren, Miele, 2004</marker>
<rawString>Manuel Bodirsky, Denys Duchier, Joachim Niehren, and Sebastian Miele. 2004. An efficient algorithm for weakly normal dominance constraints. In ACM-SIAM Symposium on Discrete Algorithms. The ACM Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Johan Bos</author>
</authors>
<title>Predicate logic unplugged.</title>
<date>1996</date>
<booktitle>In Proceedings of the Tenth Amsterdam Colloquium,</booktitle>
<pages>133--143</pages>
<contexts>
<context position="3055" citStr="Bos, 1996" startWordPosition="460" endWordPosition="461">efficient tools that support the most important operations on underspecified descriptions. We present utool, the Swiss Army Knife of Underspecification, which sets out to do exactly this. It supports the following operations: 1. enumerate all scope readings represented by an underspecified description; 2. check whether a description has any readings, and compute how many readings it has without explicitly enumerating them; 3. convert underspecified descriptions between different underspecification formalisms (at this point, Minimal Recursion Semantics (Copestake et al., 2003), Hole Semantics (Bos, 1996), and dominance constraints/graphs (Egg et al., 2001; Althaus et al., 2003)). 9 Proceedings of the ACL Interactive Poster and Demonstration Sessions, pages 9–12, Ann Arbor, June 2005. c�2005 Association for Computational Linguistics Our system is the fastest solver for underspecificied description available today; that is, it is fastest at solving Task 1 above (about 100.000 readings per second on a modern PC). It achieves this by implementing an efficient algorithm for solving dominance graphs (Bodirsky et al., 2004) and caching intermediate results in a chart data structure. To our knowledge</context>
</contexts>
<marker>Bos, 1996</marker>
<rawString>Johan Bos. 1996. Predicate logic unplugged. In Proceedings of the Tenth Amsterdam Colloquium, pages 133–143.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Miriam Butt</author>
<author>Helge Dyvik</author>
<author>Tracey Holloway King</author>
<author>Hiroshi Masuichi</author>
<author>Christian Rohrer</author>
</authors>
<title>The parallel grammar project.</title>
<date>2002</date>
<booktitle>In Proceedings of the COLING 2002 Workshop on Grammar engeneering and evaluation.</booktitle>
<contexts>
<context position="854" citStr="Butt et al., 2002" startWordPosition="110" endWordPosition="113">ost efficient solver for scope underspecification; it also converts between different underspecification formalisms and counts readings. Our tool makes the practical use of large-scale grammars with (underspecified) semantic output more feasible, and can be used in grammar debugging. 1 Introduction One of the most exciting recent developments in computational linguistics is that large-scale grammars which compute semantic representations are becoming available. Examples for such grammars are the HPSG English Resource Grammar (ERG) (Copestake and Flickinger, 2000) and the LFG ParGram grammars (Butt et al., 2002); a similar resource is being developed for the XTAG grammar (Kallmeyer and Romero, 2004). But with the advent of such grammars, a phenomenon that is sometimes considered a somewhat artificial toy problem of theoretical semanticists becomes a very practical challenge: the presence of scope ambiguities. Because grammars often uniformly treat noun phrases as quantifiers, even harmless-looking sentences can have surprisingly many readings. The median number of scope readings for the sentences in the Rondane Treebank (distributed with the ERG) is 55, but the treebank also contains extreme cases su</context>
</contexts>
<marker>Butt, Dyvik, King, Masuichi, Rohrer, 2002</marker>
<rawString>Miriam Butt, Helge Dyvik, Tracey Holloway King, Hiroshi Masuichi, and Christian Rohrer. 2002. The parallel grammar project. In Proceedings of the COLING 2002 Workshop on Grammar engeneering and evaluation.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ann Copestake</author>
<author>Dan Flickinger</author>
</authors>
<title>An opensource grammar development environment and broadcoverage English grammar using HPSG.</title>
<date>2000</date>
<booktitle>In Conference on Language Resources and Evaluation.</booktitle>
<contexts>
<context position="805" citStr="Copestake and Flickinger, 2000" startWordPosition="100" endWordPosition="103">oller,stth}@coli.uni-sb.de Abstract We present the currently most efficient solver for scope underspecification; it also converts between different underspecification formalisms and counts readings. Our tool makes the practical use of large-scale grammars with (underspecified) semantic output more feasible, and can be used in grammar debugging. 1 Introduction One of the most exciting recent developments in computational linguistics is that large-scale grammars which compute semantic representations are becoming available. Examples for such grammars are the HPSG English Resource Grammar (ERG) (Copestake and Flickinger, 2000) and the LFG ParGram grammars (Butt et al., 2002); a similar resource is being developed for the XTAG grammar (Kallmeyer and Romero, 2004). But with the advent of such grammars, a phenomenon that is sometimes considered a somewhat artificial toy problem of theoretical semanticists becomes a very practical challenge: the presence of scope ambiguities. Because grammars often uniformly treat noun phrases as quantifiers, even harmless-looking sentences can have surprisingly many readings. The median number of scope readings for the sentences in the Rondane Treebank (distributed with the ERG) is 55</context>
<context position="9319" citStr="Copestake and Flickinger, 2000" startWordPosition="1507" endWordPosition="1510">al) translations in (Koller et al., 2003; Niehren and Thater, 2003) and are only defined on nets, i.e. constraints whose graphs satisfy certain structural restrictions. This is not a very limiting restriction in practice (Flickinger et al., 2005). utool also allows the user to test efficiently whether a description is a net. In practice, utool can be used to convert descriptions between the three underspecification formalisms. Because the codecs work with concrete syntaxes that are used in existing systems, utool can be used as a drop-in replacement e.g. in the LKB grammar development system (Copestake and Flickinger, 2000). 2.3 Runtime comparison To illustrate utool’s performance, we compare its runtimes for the enumeration task with the (already quite efficient) MRS constraint solver of the LKB system (Copestake and Flickinger, 2000). Our data set consists of the 850 MRS-nets extracted from the 0 5 10 15 20 25 30 35 40 Figure 2: Distribution of constraints in Rondane over different sizes. The solid line shows the constraints in the data set, and the dashed line shows the constraints that the LKB solver could solve. Rondane treebank which have less than one million solutions (see Fig. 2). Fig. 3 displays the ru</context>
</contexts>
<marker>Copestake, Flickinger, 2000</marker>
<rawString>Ann Copestake and Dan Flickinger. 2000. An opensource grammar development environment and broadcoverage English grammar using HPSG. In Conference on Language Resources and Evaluation.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ann Copestake</author>
<author>Dan Flickinger</author>
<author>Carl Pollard</author>
<author>Ivan Sag</author>
</authors>
<title>Minimal recursion semantics: An introduction. Available at http://lingo.stanford.</title>
<date>2003</date>
<note>edu/sag/papers/copestake.pdf.</note>
<contexts>
<context position="3027" citStr="Copestake et al., 2003" startWordPosition="453" endWordPosition="457">ch is only feasible if we have access to efficient tools that support the most important operations on underspecified descriptions. We present utool, the Swiss Army Knife of Underspecification, which sets out to do exactly this. It supports the following operations: 1. enumerate all scope readings represented by an underspecified description; 2. check whether a description has any readings, and compute how many readings it has without explicitly enumerating them; 3. convert underspecified descriptions between different underspecification formalisms (at this point, Minimal Recursion Semantics (Copestake et al., 2003), Hole Semantics (Bos, 1996), and dominance constraints/graphs (Egg et al., 2001; Althaus et al., 2003)). 9 Proceedings of the ACL Interactive Poster and Demonstration Sessions, pages 9–12, Ann Arbor, June 2005. c�2005 Association for Computational Linguistics Our system is the fastest solver for underspecificied description available today; that is, it is fastest at solving Task 1 above (about 100.000 readings per second on a modern PC). It achieves this by implementing an efficient algorithm for solving dominance graphs (Bodirsky et al., 2004) and caching intermediate results in a chart data</context>
</contexts>
<marker>Copestake, Flickinger, Pollard, Sag, 2003</marker>
<rawString>Ann Copestake, Dan Flickinger, Carl Pollard, and Ivan Sag. 2003. Minimal recursion semantics: An introduction. Available at http://lingo.stanford. edu/sag/papers/copestake.pdf.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Markus Egg</author>
<author>Alexander Koller</author>
<author>Joachim Niehren</author>
</authors>
<title>The Constraint Language for Lambda Structures. Logic, Language, and Information,</title>
<date>2001</date>
<pages>10--457</pages>
<contexts>
<context position="3107" citStr="Egg et al., 2001" startWordPosition="465" endWordPosition="468">t operations on underspecified descriptions. We present utool, the Swiss Army Knife of Underspecification, which sets out to do exactly this. It supports the following operations: 1. enumerate all scope readings represented by an underspecified description; 2. check whether a description has any readings, and compute how many readings it has without explicitly enumerating them; 3. convert underspecified descriptions between different underspecification formalisms (at this point, Minimal Recursion Semantics (Copestake et al., 2003), Hole Semantics (Bos, 1996), and dominance constraints/graphs (Egg et al., 2001; Althaus et al., 2003)). 9 Proceedings of the ACL Interactive Poster and Demonstration Sessions, pages 9–12, Ann Arbor, June 2005. c�2005 Association for Computational Linguistics Our system is the fastest solver for underspecificied description available today; that is, it is fastest at solving Task 1 above (about 100.000 readings per second on a modern PC). It achieves this by implementing an efficient algorithm for solving dominance graphs (Bodirsky et al., 2004) and caching intermediate results in a chart data structure. To our knowledge, it is the only system that can do Tasks 2 and 3. I</context>
<context position="4344" citStr="Egg et al., 2001" startWordPosition="662" endWordPosition="665">ol can compute the number of readings without enumerating them that we even know that (1) has trillions of readings; even utool would take about a year to enumerate and count the readings individually. utool is implemented in C++, efficient and portable, open source, and freely downloadable from http://utool.sourceforge.net. 2 Technical Description 2.1 Solving dominance graphs At the core of utool is a solver for dominance graphs (Bodirsky et al., 2004) – graph representations of weakly normal dominance constraints, which constitute one of the main formalisms used in scope underspecification (Egg et al., 2001; Althaus et al., 2003). Dominance graphs are directed graphs with two kinds of edges, tree edges and dominance edges. They can be used to describe the set of all trees into which their tree edges can be embedded, in such a way that every dominance edge in the graph is realised as reachability in the tree. Dominance graphs are used as underspecified descriptions by describing sets of trees that are encodings of the formulas of some language of semantic representations, such as predicate logic. Fig. 1 shows an example of a constraint graph for the sentence “every student reads a book.” It consi</context>
</contexts>
<marker>Egg, Koller, Niehren, 2001</marker>
<rawString>Markus Egg, Alexander Koller, and Joachim Niehren. 2001. The Constraint Language for Lambda Structures. Logic, Language, and Information, 10:457–485.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Dan Flickinger</author>
<author>Alexander Koller</author>
<author>Stefan Thater</author>
</authors>
<title>A new well-formedness criterion for semantics debugging.</title>
<date>2005</date>
<booktitle>In Proceedings of the 12th HPSG Conference,</booktitle>
<location>Lisbon.</location>
<contexts>
<context position="8934" citStr="Flickinger et al., 2005" startWordPosition="1444" endWordPosition="1447">out solutions in a variety of different formats: • dominance graphs; • descriptions of Minimal Recursion Semantics; • descriptions of Hole Semantics. The input and output functionality is provided by codecs, which translate between descriptions in one of these formalisms and the internal dominance graph format. The codecs for MRS and Hole Semantics are based on the (non-trivial) translations in (Koller et al., 2003; Niehren and Thater, 2003) and are only defined on nets, i.e. constraints whose graphs satisfy certain structural restrictions. This is not a very limiting restriction in practice (Flickinger et al., 2005). utool also allows the user to test efficiently whether a description is a net. In practice, utool can be used to convert descriptions between the three underspecification formalisms. Because the codecs work with concrete syntaxes that are used in existing systems, utool can be used as a drop-in replacement e.g. in the LKB grammar development system (Copestake and Flickinger, 2000). 2.3 Runtime comparison To illustrate utool’s performance, we compare its runtimes for the enumeration task with the (already quite efficient) MRS constraint solver of the LKB system (Copestake and Flickinger, 2000</context>
</contexts>
<marker>Flickinger, Koller, Thater, 2005</marker>
<rawString>Dan Flickinger, Alexander Koller, and Stefan Thater. 2005. A new well-formedness criterion for semantics debugging. In Proceedings of the 12th HPSG Conference, Lisbon.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Laura Kallmeyer</author>
<author>Maribel Romero</author>
</authors>
<title>LTAG semantics with semantic unification.</title>
<date>2004</date>
<booktitle>In Proceedings of the TAG+7 Workshop,</booktitle>
<location>Vancouver.</location>
<contexts>
<context position="943" citStr="Kallmeyer and Romero, 2004" startWordPosition="125" endWordPosition="128">erent underspecification formalisms and counts readings. Our tool makes the practical use of large-scale grammars with (underspecified) semantic output more feasible, and can be used in grammar debugging. 1 Introduction One of the most exciting recent developments in computational linguistics is that large-scale grammars which compute semantic representations are becoming available. Examples for such grammars are the HPSG English Resource Grammar (ERG) (Copestake and Flickinger, 2000) and the LFG ParGram grammars (Butt et al., 2002); a similar resource is being developed for the XTAG grammar (Kallmeyer and Romero, 2004). But with the advent of such grammars, a phenomenon that is sometimes considered a somewhat artificial toy problem of theoretical semanticists becomes a very practical challenge: the presence of scope ambiguities. Because grammars often uniformly treat noun phrases as quantifiers, even harmless-looking sentences can have surprisingly many readings. The median number of scope readings for the sentences in the Rondane Treebank (distributed with the ERG) is 55, but the treebank also contains extreme cases such as (1) below, which according to the ERG has about 2.4 trillion (1012) readings: (1) M</context>
</contexts>
<marker>Kallmeyer, Romero, 2004</marker>
<rawString>Laura Kallmeyer and Maribel Romero. 2004. LTAG semantics with semantic unification. In Proceedings of the TAG+7 Workshop, Vancouver.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Alexander Koller</author>
<author>Joachim Niehren</author>
</authors>
<title>On underspecified processing of dynamic semantics.</title>
<date>2000</date>
<booktitle>In Proceedings of COLING-2000,</booktitle>
<location>Saarbrücken.</location>
<marker>Koller, Niehren, 2000</marker>
<rawString>Alexander Koller and Joachim Niehren. 2000. On underspecified processing of dynamic semantics. In Proceedings of COLING-2000, Saarbrücken.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Alexander Koller</author>
<author>Joachim Niehren</author>
<author>Stefan Thater</author>
</authors>
<title>Bridging the gap between underspecification formalisms: Hole semantics as dominance constraints.</title>
<date>2003</date>
<booktitle>In Proceedings of the 10th EACL,</booktitle>
<location>Budapest.</location>
<contexts>
<context position="8728" citStr="Koller et al., 2003" startWordPosition="1413" endWordPosition="1416">different resources (such as grammars and solvers) are built for different underspecification formalisms. To help alleviate this problem, utool can read and write underspecified descriptions and write out solutions in a variety of different formats: • dominance graphs; • descriptions of Minimal Recursion Semantics; • descriptions of Hole Semantics. The input and output functionality is provided by codecs, which translate between descriptions in one of these formalisms and the internal dominance graph format. The codecs for MRS and Hole Semantics are based on the (non-trivial) translations in (Koller et al., 2003; Niehren and Thater, 2003) and are only defined on nets, i.e. constraints whose graphs satisfy certain structural restrictions. This is not a very limiting restriction in practice (Flickinger et al., 2005). utool also allows the user to test efficiently whether a description is a net. In practice, utool can be used to convert descriptions between the three underspecification formalisms. Because the codecs work with concrete syntaxes that are used in existing systems, utool can be used as a drop-in replacement e.g. in the LKB grammar development system (Copestake and Flickinger, 2000). 2.3 Run</context>
</contexts>
<marker>Koller, Niehren, Thater, 2003</marker>
<rawString>Alexander Koller, Joachim Niehren, and Stefan Thater. 2003. Bridging the gap between underspecification formalisms: Hole semantics as dominance constraints. In Proceedings of the 10th EACL, Budapest.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Joachim Niehren</author>
<author>Stefan Thater</author>
</authors>
<title>Bridging the gap between underspecification formalisms: Minimal recursion semantics as dominance constraints.</title>
<date>2003</date>
<booktitle>In Proceedings of the 41st Annual Meeting of the Association for Computational Linguistics.</booktitle>
<contexts>
<context position="8755" citStr="Niehren and Thater, 2003" startWordPosition="1417" endWordPosition="1420">such as grammars and solvers) are built for different underspecification formalisms. To help alleviate this problem, utool can read and write underspecified descriptions and write out solutions in a variety of different formats: • dominance graphs; • descriptions of Minimal Recursion Semantics; • descriptions of Hole Semantics. The input and output functionality is provided by codecs, which translate between descriptions in one of these formalisms and the internal dominance graph format. The codecs for MRS and Hole Semantics are based on the (non-trivial) translations in (Koller et al., 2003; Niehren and Thater, 2003) and are only defined on nets, i.e. constraints whose graphs satisfy certain structural restrictions. This is not a very limiting restriction in practice (Flickinger et al., 2005). utool also allows the user to test efficiently whether a description is a net. In practice, utool can be used to convert descriptions between the three underspecification formalisms. Because the codecs work with concrete syntaxes that are used in existing systems, utool can be used as a drop-in replacement e.g. in the LKB grammar development system (Copestake and Flickinger, 2000). 2.3 Runtime comparison To illustra</context>
</contexts>
<marker>Niehren, Thater, 2003</marker>
<rawString>Joachim Niehren and Stefan Thater. 2003. Bridging the gap between underspecification formalisms: Minimal recursion semantics as dominance constraints. In Proceedings of the 41st Annual Meeting of the Association for Computational Linguistics.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>