<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.082221">
<title confidence="0.699379">
Morphology and Computation
</title>
<figure confidence="0.677781">
Richard Sproat
(AT&amp;T Bell Laboratories)
Cambridge, MA: The MIT Press (The
ACL—MIT Press Series in Natural
Language Processing), 1992, xv
295 pp.
Hardbound, ISBN 0-262-19314-0, $35.00
Reviewed by
Scott Stethem
Pacific Bell
</figure>
<bodyText confidence="0.999845740740741">
This book undertakes the task of explaining the importance of an often-neglected field,
computational morphology, while illustrating the field&apos;s large potential contribution
to natural language applications. The intended audience is those with backgrounds
in computer science, including automata and complexity theory, and linguistics, espe-
cially phonology and syntax. Familiarity with morphological concepts is not required,
as Sproat includes a nice introduction to word structure and word formation. He draws
upon a plethora of languages, using English to illustrate morphological phenomena
where possible. The presentation varies from quite theoretical, with discussions of
NP-hardness and finite-state machines, to highly &apos;commercial&apos; (runs on machine ABC
with operating system XYZ in t seconds).
Sproat begins with a motivation for studying computational morphology. Since
most natural language systems work on limited subsets of just one language, system
developers make numerous limiting assumptions about word formation and structure.
The author mentions numerous applications (e.g., text-to-speech, word processing,
document retrieval, machine translation) where morphology can contribute. I would
have liked more detailed presentations of applications, emphasizing the practicality
of morphological processing.
Seemingly simple questions like &amp;quot;What is a word?&amp;quot; have surprisingly complex
answers. Chapter 2 nicely introduces the field of morphology, serving as a review for
some, while being a fast-paced introduction for novices (listing excellent references for
further study). Sproat gives due consideration to how morphological processes relate
to orthography, phonology, syntax, and semantics.
Sproat&apos;s survey of morphology leads us through examples and theories of word
structure and word formation. Word formation can be inflectional (i.e., using syntac-
tic information like part of speech), derivational (e.g., edit into editor), and/or com-
pounding (dog house). Additionally, the author goes beyond mundane examples of
prefix/suffix concatenation, delving into infixes and such &amp;quot;exotic&amp;quot; phenomena as:
</bodyText>
<listItem confidence="0.999934666666667">
• circumfixation (i.e., discontinuous affixes);
• templates (e.g., the root-and-pattern of Semitic languages); and
• reduplication.
</listItem>
<bodyText confidence="0.927650333333333">
Chapter 3&apos;s discussion of computational morphology (CM) systems should have
presented an objective comparison of how each system handles the various morpho-
logical phenomena of Chapter 2. Instead, the author spends the majority of this chap-
</bodyText>
<page confidence="0.984797">
552
</page>
<subsectionHeader confidence="0.815092">
Book Reviews
</subsectionHeader>
<bodyText confidence="0.999578">
ter presenting highly detailed descriptions of two-level finite-state morphology sys-
tems (collectively called URKIMMO). Despite the inordinate attention, however, he
acknowledges the limitations of this approach to morphology. Sproat goes on record
as saying &amp;quot;I do not believe for a moment that KIMMO-type systems are particularly
psychologically realistic&amp;quot; (p. 183). Also, Sproat is dissatisfied with URKIMMO&apos;s con-
catenative premise; that is, the system&apos;s tremendous bias toward prefixes and suffixes.
The details about finite-state morphotactics and phonology should have been relegated
to an appendix. The computational complexity of CM systems like URKIMMO, while
informative, belongs in an appendix as well.
The latter part of Chapter 3 discusses non-KIMMO morphology systems, includ-
ing:
</bodyText>
<listItem confidence="0.996181">
• a text-to-speech word decomposition module;
• Turkish spelling checking;
• a Spanish morphological analyzer; and
• word-based systems for on-line dictionaries.
</listItem>
<bodyText confidence="0.999990903225807">
The author goes on to identify major trends within computational morphology, and
the areas needing more attention (i.e., the boundaries between morphology and other
fields). For morphology&apos;s interaction with cyclic and lexical phonology, Sproat&apos;s com-
ment on URKIMMO is &amp;quot;I do not see any straightforward solution to [cyclic rule appli-
cation] within the two-level framework&amp;quot; (p. 211). Collaboration between morphology
and syntax will be needed when &amp;quot;serious morphological analyzers are integrated into
serious parsing systems&amp;quot; (p. 212).
The first part of the next chapter deals with morphological acquisition, determining
the rules that govern word structure and word formation. Sproat discusses whether
connectionism is contributing to this branch of computational morphology, mentioning
a connectionist network that &amp;quot;learns&amp;quot; past-tense forms of English verbs. Sproat states
&amp;quot;Rumelhart and McClelland 1986 is one of the better-known, and arguably one of the
more successful, applications of connectionist models to natural language&amp;quot; (p. 216).
Yet after presenting their system, he concludes that &amp;quot;there are a number of reasons to
doubt that Rumelhart and McClelland&apos;s model is really doing what it is claimed to be
doing&amp;quot; (p. 230). One reason cited that their system does not realistically model human
language learning is that it sometimes produces bizarre past-tense verb forms, such
as membled for mail.
The second part of this chapter revisits compound nominals, showing how CM
systems can handle constructs like life insurance company employee. Representing knowl-
edge about the world (or a domain) allows a powerful interaction between morphol-
ogy and semantics. Examples are given of a CM system that allows compounds in
database queries and a program that decides where to assign stress in a text-to-speech
system.
The book Morphology and Computation shows that computational morphologists
have only begun to explore the field. With new understandings in morphology and
the related disciplines (e.g., syntax, semantics, phonology, psychology, and computer
science), more systems are needed &amp;quot;to verify the adequacy of particular theoretical
models&amp;quot; (p. 19). To create more robust CM systems, partnerships are needed with
researchers having diverse backgrounds. Evolving from these collaborations, the next
generation of morphological processing systems looks promising indeed.
</bodyText>
<page confidence="0.996657">
553
</page>
<reference confidence="0.927666">
Computational Linguistics Volume 18, Number 4
Reference of Cognition, Volume 2, edited by James
Rumelhart, David E., and McClelland, James L. McClelland, David E. Rumelhart, and
L. (1986). &amp;quot;On learning the past tenses of the PDP Research Group, 216-271. The
English verbs.&amp;quot; In Parallel Distributed MIT Press.
Processing: Explorations in the Microstructure
Scott Stethem is a systems analyst at Pacific Bell, where he develops intelligent front-ends to
databases. He has degrees in computer science from the University of Pennsylvania and the
Johns Hopkins University. He presented the paper &amp;quot;Explanation-based learning from rule-
governed features in phonological representations&amp;quot; at the 1991 AAAI Spring Symposium on
Machine Learning of Natural Language and Ontology. Stethem&apos;s address is: 2600 Camino Ramon,
Pacific Bell 4s450, San Ramon, CA 94583. E-mail: sesteth@srv.pacbell.com
</reference>
<page confidence="0.998707">
554
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.172531">
<title confidence="0.999957">Morphology and Computation</title>
<author confidence="0.999991">Richard Sproat</author>
<affiliation confidence="0.999742">(AT&amp;T Bell Laboratories)</affiliation>
<address confidence="0.96776">Cambridge, MA: The MIT Press (The</address>
<note confidence="0.9913044">ACL—MIT Press Series in Natural Language Processing), 1992, xv 295 pp. Hardbound, ISBN 0-262-19314-0, $35.00 Reviewed by</note>
<author confidence="0.861521">Scott Stethem</author>
<affiliation confidence="0.476728">Pacific Bell</affiliation>
<abstract confidence="0.6140898">This book undertakes the task of explaining the importance of an often-neglected field, computational morphology, while illustrating the field&apos;s large potential contribution to natural language applications. The intended audience is those with backgrounds in computer science, including automata and complexity theory, and linguistics, especially phonology and syntax. Familiarity with morphological concepts is not required,</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Reference Rumelhart</author>
<author>E David</author>
<author>James L McClelland</author>
</authors>
<title>On learning the past tenses of English verbs.&amp;quot;</title>
<date>1986</date>
<journal>and the PDP Research Group,</journal>
<booktitle>In Parallel Distributed Processing: Explorations in the Microstructure of Cognition,</booktitle>
<volume>18</volume>
<pages>216--271</pages>
<publisher>The MIT Press.</publisher>
<institution>Computational Linguistics</institution>
<note>edited by</note>
<marker>Rumelhart, David, McClelland, 1986</marker>
<rawString>Computational Linguistics Volume 18, Number 4 Reference Rumelhart, David E., and McClelland, James L. (1986). &amp;quot;On learning the past tenses of English verbs.&amp;quot; In Parallel Distributed Processing: Explorations in the Microstructure of Cognition, Volume 2, edited by James L. McClelland, David E. Rumelhart, and the PDP Research Group, 216-271. The MIT Press.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>