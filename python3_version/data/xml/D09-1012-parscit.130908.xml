<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000006">
<title confidence="0.920651">
Reverse Engineering of Tree Kernel Feature Spaces
</title>
<author confidence="0.701235">
Daniele Pighin
</author>
<note confidence="0.5220235">
FBK-Irst, HLT
Via di Sommarive, 18 I-38100 Povo (TN) Italy
</note>
<email confidence="0.857593">
pighin@fbk.eu
</email>
<author confidence="0.9868">
Alessandro Moschitti
</author>
<affiliation confidence="0.994759">
University of Trento, DISI
</affiliation>
<note confidence="0.498857">
Via di Sommarive, 14 I-38100 Povo (TN) Italy
</note>
<email confidence="0.920699">
moschitti@disi.unitn.it
</email>
<sectionHeader confidence="0.996238" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999985833333333">
We present a framework to extract the
most important features (tree fragments)
from a Tree Kernel (TK) space according
to their importance in the target kernel-
based machine, e.g. Support Vector Ma-
chines (SVMs). In particular, our min-
ing algorithm selects the most relevant fea-
tures based on SVM estimated weights
and uses this information to automatically
infer an explicit representation of the in-
put data. The explicit features (a) improve
our knowledge on the target problem do-
main and (b) make large-scale learning
practical, improving training and test time,
while yielding accuracy in line with tradi-
tional TK classifiers. Experiments on se-
mantic role labeling and question classifi-
cation illustrate the above claims.
</bodyText>
<sectionHeader confidence="0.999517" genericHeader="keywords">
1 Introduction
</sectionHeader>
<bodyText confidence="0.999979616666667">
The last decade has seen a massive use of Support
Vector Machines (SVMs) for carrying out NLP
tasks. Indeed, their appealing properties such as
1) solid theoretical foundations, 2) robustness to
irrelevant features and 3) outperforming accuracy
have been exploited to design state-of-the-art lan-
guage applications.
More recently, kernel functions, which im-
plicitly represent data in some high dimensional
space, have been employed to study and fur-
ther improve many natural language systems, e.g.
(Collins and Duffy, 2002), (Kudo and Matsumoto,
2003), (Cumby and Roth, 2003), (Cancedda et al.,
2003), (Culotta and Sorensen, 2004), (Toutanova
et al., 2004), (Kazama and Torisawa, 2005), (Shen
et al., 2003), (Gliozzo et al., 2005), (Kudo et al.,
2005), (Moschitti et al., 2008), (Diab et al., 2008).
Unfortunately, the benefit to easily and effectively
model the target linguistic phenomena is reduced
by the the implicit nature of the kernel space,
which prevents to directly observe the most rele-
vant features. As a consequence, even very accu-
rate models generally fail in providing useful feed-
back for improving our understanding of the prob-
lems at study. Moreover, the computational bur-
den induced by high dimensional kernels makes
the application of SVMs to large corpora still more
problematic.
In (Pighin and Moschitti, 2009), we proposed a
feature extraction algorithm for Tree Kernel (TK)
spaces, which selects the most relevant features
(tree fragments) according to the gradient compo-
nents (weight vector) of the hyperplane learnt by
an SVM, in line with current research, e.g. (Rako-
tomamonjy, 2003; Weston et al., 2003; Kudo and
Matsumoto, 2003). In particular, we provided al-
gorithmic solutions to deal with the huge dimen-
sionality and, consequently, high computational
complexity of the fragment space. Our experimen-
tal results showed that our approach reduces learn-
ing and classification processing time leaving the
accuracy unchanged.
In this paper, we present a new version of such
algorithm which, under the same parameteriza-
tion, is almost three times as fast while produc-
ing the same results. Most importantly, we ex-
plored tree fragment spaces for two interesting
natural language tasks: Semantic Role Labeling
(SRL) and Question Classification (QC). The re-
sults show that: (a) on large data sets, our ap-
proach can improve training and test time while
yielding almost unaffected classification accuracy,
and (b) our framework can effectively exploit the
ability of TKs and SVMs to, respectively, gener-
ate and recognize relevant structured features. In
particular, we (i) study in more detail the relevant
fragments identfied for the boundary classification
task of SRL, (ii) closely observe the most relevant
fragments for each QC class and (iii) look at the di-
verse syntactic patterns characterizing each ques-
</bodyText>
<page confidence="0.98336">
111
</page>
<note confidence="0.9966165">
Proceedings of the 2009 Conference on Empirical Methods in Natural Language Processing, pages 111–120,
Singapore, 6-7 August 2009. c�2009 ACL and AFNLP
</note>
<bodyText confidence="0.9968337">
tion category.
The rest of the paper is structured as follows:
Section 2 will briefly review SVMs and TK func-
tions; Section 3 will detail our proposal for the lin-
earization of a TK feature space; Section 4 will
review previous work on related subjects; Section
5 will detail the outcome of our experiments, and
Section 6 will discuss some relevant aspects of the
evaluation; finally, in Section 7 we will draw our
conclusions.
</bodyText>
<sectionHeader confidence="0.991837" genericHeader="introduction">
2 Tree Kernel Functions
</sectionHeader>
<bodyText confidence="0.996638">
The decision function of an SVM is:
</bodyText>
<equation confidence="0.979645">
n
f(x) = w· x+ b = αiyiei · x + b (1)
i=1
</equation>
<bodyText confidence="0.999883285714286">
where x is a classifying example and w and b are
the separating hyperplane’s gradient and its bias,
respectively. The gradient is a linear combination
of the training points xz, their labels yi and their
weights αi. Applying the so-called kernel trick it
is possible to replace the scalar product with a ker-
nel function defined over pairs of objects:
</bodyText>
<equation confidence="0.982832">
n
f(o) = αiyik(oi, o) + b
i=1
</equation>
<bodyText confidence="0.99965304">
with the advantage that we do not need to provide
an explicit mapping 0(·) of our examples in a vec-
tor space.
A Tree Kernel function is a convolution ker-
nel (Haussler, 1999) defined over pairs of trees.
Practically speaking, the kernel between two trees
evaluates the number of substructures (or frag-
ments) they have in common, i.e. it is a measure
of their overlap. The function can be computed re-
cursively in closed form, and quite efficient imple-
mentations are available (Moschitti, 2006). Dif-
ferent TK functions are characterized by alterna-
tive fragment definitions, e.g. (Collins and Duffy,
2002) and (Kashima and Koyanagi, 2002). In the
context of this paper we will be focusing on the
SubSet Tree (SST) kernel described in (Collins
and Duffy, 2002), which relies on a fragment defi-
nition that does not allow to break production rules
(i.e. if any child of a node is included in a frag-
ment, then also all the other children have to). As
such, it is especially indicated for tasks involving
constituency parsed texts.
Implicitly, a TK function establishes a corre-
spondence between distinct fragments and dimen-
sions in some fragment space, i.e. the space of all
</bodyText>
<figureCaption confidence="0.968259">
Figure 1: Esemplification of a fragment space and
the kernel product between two trees.
</figureCaption>
<bodyText confidence="0.9995">
the possible fragments. To simplify, a tree t can
be represented as a vector whose attributes count
the occurrences of each fragment within the tree.
The kernel between two trees is then equivalent to
the scalar product between pairs of such vectors,
as exemplified in Figure 1.
</bodyText>
<sectionHeader confidence="0.569609" genericHeader="method">
3 Linearization of a TK function
</sectionHeader>
<bodyText confidence="0.999978285714286">
Our objective is to efficiently mine the most rele-
vant fragments from the huge fragment space, so
that we can explicitly represent our input trees in
terms of these fragments and learn fast and accu-
rate linear classifiers.
The framework defines five distinct activities,
detailed in the following paragraphs.
</bodyText>
<subsectionHeader confidence="0.999474">
3.1 Kernel Space Learning (KSL)
</subsectionHeader>
<bodyText confidence="0.999979315789474">
The first step involves the generation of an approx-
imation of the whole fragment space, i.e. we can
consider only the trees that encode the most rele-
vant fragments. To this end, we can partition our
training data into 5 smaller sets, and use the SVM
and the SST kernel to learn 5 models. We will
only consider the fragments encoded by the sup-
port vectors of the 5 models. In the next stage, we
will use the SVM estimated weights to drive our
feature selection process.
Since time complexity of SVM training is ap-
proximately quadratic in the number of examples,
by breaking training data into smaller sets we
can considerably accelerate the process of filtering
trees and estimating support vector weights. Ac-
cording to statistical learning theory, being trained
on smaller subsets of the available data these mod-
els will be less robust with respect to the min-
imization of the empirical risk (Vapnik, 1998).
</bodyText>
<figure confidence="0.981874290322581">
K(T1, T2) = (φ(T1), φ(T2)) = 1
C
A
A B A
B A B A
T1
1 2 3 4 5 6 7
A
B A
C
A
B A
B A
C
Fragment space
A
C
B A
D
D
B A
C
T2
A
B A
B A
φ(T1) = [2, 1, 1, 1, 1, 0, 0] B
φ(T2) = [0, 0, 0, 0, 1, 1, 1]
D
A
C
</figure>
<page confidence="0.896588">
112
</page>
<construct confidence="0.604004">
Algorithm 3.1: MINE MODEL(M, L, A)
</construct>
<equation confidence="0.9640524">
global maxexp
prev +— 0 ; CLEAR INDEX()
for each (αy, t) G M
 Ti +— α · y/IItII
for each n G Art
(f +— FRAG(n) ; rel = A · Ti
do 
do prev +— prev U {f, rel}
PUT(f, rel)
best pr +— BEST(L) ;
while true
next +— 0
for each (f, rel) G prev if f G best pr
FL +— best pr
return (FL)
</equation>
<bodyText confidence="0.9999635">
Nonetheless, since we do not need to employ them
for classification (but just to direct our feature se-
lection process, as we will describe shortly), we
can accept to rely on sub-optimal weights. Fur-
thermore, research results in the field of SVM par-
allelization using cascades of SVMs (Graf et al.,
2004) suggest that support vectors collected from
locally learnt models can encode many of the rel-
evant features retained by models learnt globally.
Henceforth, let Ms be the model associated with
the s-th split, and Fs the fragment space that can
describe all the trees in Ms.
</bodyText>
<subsectionHeader confidence="0.999987">
3.2 Fragment Mining and Indexing (FMI)
</subsectionHeader>
<bodyText confidence="0.998762">
In Equation 1 it is possible to isolate the gradient
</bodyText>
<equation confidence="0.999824">
w~ = Pn a x with xi = [x�1) x&apos;N)] N
i=1 zyi z� z z , ... , z ,
</equation>
<bodyText confidence="0.9799985">
being the dimensionality of the feature space. For
a tree kernel function, we can rewrite x(j) ias:
</bodyText>
<equation confidence="0.999111666666667">
ti,jλℓ(fj) ti,jλℓ(fj)
x(j)
i = ktik = qPN k=1(ti,kλℓ(fk))2 (2)
</equation>
<bodyText confidence="0.917594166666667">
where: ti,j is the number of occurrences of the
fragment fj, associated with the j-th dimension of
the feature space, in the tree ti; λ is the kernel de-
cay factor; and ℓ(fj) is the depth of the fragment.
The relevance |w(j) |of the fragment fj can be
measured as:
</bodyText>
<equation confidence="0.925561">
���Pni=1 αiyiti,jλℓ(fj)���
=
.
ktik
(3)
</equation>
<bodyText confidence="0.99608675">
We fix a threshold L and from each model Ms
(learnt during KSL) we select the L most relevant
fragments, i.e. we build the set Fs,L = ∪k{fk} so
that:
</bodyText>
<subsectionHeader confidence="0.814559">
|Fs,L |= L and |w(k) |≥ |w(i)|∀fi ∈ F \ Fs,L .
</subsectionHeader>
<bodyText confidence="0.99979355">
To generate all the fragments encoded in a
model, we adopt the greedy strategy described in
Algorithm 3.1. Its arguments are: an SVM model
M represented as hαy, ti pairs, where t is a tree
structure; the threshold value L; and the kernel de-
cay factor λ.
The function FRAG(n) generates the smallest
fragment rooted in node n (i.e. for an SST kernel,
the fragment consisting of n and its direct chil-
dren). We call such fragment a base fragment. The
function EXPAND(f, maxexp) generates all the
fragments that can be derived from the fragment
f by expanding, i.e. including in the fragment the
direct children of some of its nodes. These frag-
ments are derived from f. The parameter maxexp
limits fragment proliferation by setting the maxi-
mum number of nodes which can be expanded in
a fragment expansion operation. For example, if
there are 10 nodes which can be expanded in frag-
ment f, then only the fragments where at most 3
of the 10 nodes are expanded will be generated by
a call to EXPAND(f, 3).
Every time we generate a fragment f, the func-
tion PUT(f, rel) saves the fragment along with its
relevance rel in an index. The index keeps track
of the cumulative relevance of a fragment, and its
implementation has been optimized for fast inser-
tions and spatial compactness.
A whole cycle of expansions is considered as
an iteration of the mining process: we take into
account all the fragments that have undergone k
expansions and produce all the fragments that re-
sult from a further expansion, i.e. all the fragments
expanded k + 1 times.
We keep iterating until we reach a stop crite-
rion, which we base on the threshold value L, i.e.
the limit on the number of fragments that we are
interested in mining from a model. During each it-
eration k+1, we only expand the best L fragments
identified during the previous iteration k. When
</bodyText>
<figure confidence="0.989454954545455">
do 
 

X = EXPAND(f, maxexp)
rel exp +— A · rel
for each frag G X
(temp = {frag, rel exp}
do next +— next U temp
PUT(frag,rel exp)
best +— BEST(L)
if not CHANGED()
then break
best pr +— best
prev +— next



do
|w(j) |= n ��
~X αiyix(j) ~~
�� i ~
i=1
</figure>
<page confidence="0.996601">
113
</page>
<bodyText confidence="0.999956428571429">
the iteration is complete we re-evaluate the set of
L best fragments in the index, and we stop only if
the worst of them, i.e. the L-th ranked fragment
at the step k + 1, and its score are the same as at
the end of the previous iteration. That is, we as-
sume that if none of the fragments mined during
the (k + 1)-th iteration managed to affect the bot-
tom of the pool of the L most relevant fragments,
then none of their expansions is likely to succeed.
In the algorithm, Nt is the set of nodes of the tree
t; BEST(L) returns the L highest ranked fragments
in the index; CHANGED() verifies whether the bot-
tom of the L-best set has been affected by the last
iteration or not.
We call MINE MODEL(·) on each of the mod-
els Ms that we learnt from the S initial splits. For
each model, the function returns the set of L-best
fragments in the model. The union of all the frag-
ments harvested from each model is then saved
into a dictionary DL which will be used by the next
stage.
</bodyText>
<subsectionHeader confidence="0.800498">
3.2.1 Discussion on FNH algorithm
</subsectionHeader>
<bodyText confidence="0.997297666666667">
With respect to the algorithm presented in (Pighin
and Moschitti, 2009), the one presented here has
the following advantages:
</bodyText>
<listItem confidence="0.953618">
• the process of building fragments is strictly
small-to-large: fragments that span n+1 lev-
els of the tree may be generated only after all
those spanning n levels;
• the threshold value L is a parameter of the
mining process, and it is used to prevent the
algorithm from generating more fragments
than necessary, thus making it more efficient;
• it has one less parameter (maxdepth) which
was used to force fragments to span at-most
a given number of levels. The new algorithm
does not need it since the maximum number
of iterations is implicitly set via L.
</listItem>
<bodyText confidence="0.999973857142857">
These differences result in improved efficiency for
the FMI stage. For example, on the data for the
boundary classification task (see Section 5), using
comparable parameters the old algorithm required
85 minutes to mine the most relevant fragments,
whereas the new one only takes 31, i.e. it is 2.74
times as fast.
</bodyText>
<subsectionHeader confidence="0.993607">
3.3 Tree Fragment Extraction (TFX)
</subsectionHeader>
<bodyText confidence="0.999979222222222">
During this phase we actually linearize our data:
a file encoding label-tree pairs (yi7 ti) is trans-
formed to encode label-vector pairs (yi7 vz). To
do so, we generate the fragment space of ti, us-
ing a variant of the mining algorithm described in
Algorithm 3.1, and encode in vz all and only the
fragments ti,j so that ti,j E DL. The algorithm
exploits labels and production rules found in the
fragments listed in the dictionary to generate only
the fragments that may be in the dictionary. For
example, if the dictionary does not contain a frag-
ment whose root is labeled N, then if a node N is
encountered during TFX neither its base fragment
nor its expansions are generated. The process is
applied to the whole training (TFX-train) and test
(TFX-test) sets. The fragment space is now ex-
plicit, as there is a mapping between the input vec-
tors and the fragments they encode.
</bodyText>
<subsectionHeader confidence="0.985407">
3.4 Explicit Space Learning (ESL)
</subsectionHeader>
<bodyText confidence="0.999741666666667">
Linearized training data is used to learn a very fast
model by using all the available data and a linear
kernel.
</bodyText>
<subsectionHeader confidence="0.974626">
3.5 Explicit Space Classification (ESC)
</subsectionHeader>
<bodyText confidence="0.999863666666667">
The linear model is used to classify linearized test
data and evaluate the accuracy of the resulting
classifier.
</bodyText>
<sectionHeader confidence="0.999125" genericHeader="method">
4 Previous work
</sectionHeader>
<bodyText confidence="0.999743">
A rather comprehensive overview of feature se-
lection techniques is carried out in (Guyon and
Elisseeff, 2003). Non-filter approaches for SVMs
and kernel machines are often concerned with
polynomial and Gaussian kernels, e.g. (Weston et
al., 2001) and (Neumann et al., 2005). Weston
et al. (2003) use the ℓ0 norm in the SVM opti-
mizer to stress the feature selection capabilities
of the learning algorithm. In (Kudo and Mat-
sumoto, 2003), an extension of the PrefixSpan al-
gorithm (Pei et al., 2001) is used to efficiently
mine the features in a low degree polynomial ker-
nel space. The authors discuss an approximation
of their method that allows them to handle high
degree polynomial kernels.
Suzuki and Isozaki (2005) present an embed-
ded approach to feature selection for convolution
kernels based on χ2-driven relevance assessment.
To our knowledge, this is the only published work
clearly focusing on feature selection for tree ker-
nel functions, and indeed has been one of the
major sources of inspiration for our methodol-
ogy. With respect to their work, the difference
</bodyText>
<page confidence="0.994596">
114
</page>
<bodyText confidence="0.999945944444445">
in our approach is that we want to exploit the
SVM optimizer to select the most relevant fea-
tures instead of a relevance assessment measure
that moves from different statistical assumptions
than the learning algorithm.
In (Graf et al., 2004), an approach to SVM
parallelization is presented which is based on a
divide-et-impera strategy to reduce optimization
time. The idea of using a compact graph rep-
resentation to represent the support vectors of a
TK function is explored in (Aiolli et al., 2006),
where a Direct Acyclic Graph (DAG) is employed.
In (Moschitti, 2006; Bloehdorn and Moschitti,
2007a; Bloehdorn and Moschitti, 2007b; Mos-
chitti et al., 2007), the SST kernel along with other
tree and combined kernels are employed for ques-
tion classification and semantic role labeling with
interesting results.
</bodyText>
<sectionHeader confidence="0.999847" genericHeader="method">
5 Experiments
</sectionHeader>
<bodyText confidence="0.99994976">
We evaluated the capability of our model to ex-
tract relevant features on two data sets: the
CoNLL 2005 shared task on Semantic Role Label-
ing (SRL) (Carreras and M`arquez, 2005), and the
Question Classification (QC) task based on data
from the TREC 10 QA competition (Voorhees,
2001). The next sections will detail the setup and
outcome of the two sets of experiments.
All the experiments were run on a machine
equipped with 4 Intel ® Xeon® CPUs clocked at
1.6 GHz and 4 GB of RAM. As a supervised learn-
ing framework we used SVM-Light-TK1, which
extends the SVM-Light optimizer (Joachims,
2000) with tree kernel support. For each classi-
fication task, we compare the accuracy of a vanilla
SST classifier against the corresponding linearized
SST classifier (SSTs). For KSL and SST training
we used the default decay factor A = 0.4. For
ESL, we use a non-normalized, linear kernel. No
further parametrization of the learning algorithms
is carried out. Indeed, our focus is on showing
that, under the same conditions, our linearized tree
kernel can be as accurate as the original kernel,
and choosing of parameters may just bias such
test.
</bodyText>
<subsectionHeader confidence="0.98821">
5.1 Semantic Role Labeling
</subsectionHeader>
<bodyText confidence="0.9609545">
For our experiments on semantic role labeling we
used PropBank annotations (Palmer et al., 2005)
</bodyText>
<footnote confidence="0.9775995">
1http://disi.unitn.it/˜moschitt/
Tree-Kernel.htm
</footnote>
<figureCaption confidence="0.999193">
Figure 2: Examples of AST,,, structured features.
</figureCaption>
<bodyText confidence="0.9991315">
and automatic Charniak parse trees (Charniak,
2000) as provided for the CoNLL 2005 evaluation
campaign (Carreras and M`arquez, 2005). SRL can
be decomposed into two tasks: boundary detec-
tion, where the word sequences that are arguments
of a predicate word w are identified, and role clas-
sification, where each argument is assigned the
proper role. The former task requires a binary
Boundary Classifier (BC), whereas the second in-
volves a Role Multi-class Classifier (RM).
</bodyText>
<subsubsectionHeader confidence="0.660162">
5.1.1 Setup
</subsubsectionHeader>
<bodyText confidence="0.999983125">
If the constituency parse tree t of a sentence s
is available, we can look at all the pairs (p, nz),
where nz is any node in the tree and p is the node
dominating w, and decide whether nz is an argu-
ment node or not, i.e. whether it exactly dominates
all and only the words encoding any of w’s argu-
ments. The objects that we classify are subsets
of the input parse tree that encompass both p and
nz. Namely, we use the AST,,, structure defined
in (Moschitti et al., 2008), which is the minimal
tree that covers all and only the words of p and nz.
In the AST,,,, p and nz are marked so that they can
be distinguished from the other nodes. An AST,,,
is regarded as a positive example for BC if nz is an
argument node, otherwise it is considered a nega-
tive example. Positive BC examples can be used to
train an efficient RM: for each role r we can train
a classifier whose positive examples are argument
nodes whose label is exactly r, whereas negative
examples are argument nodes labeled r′ =� r. Two
AST,,,s extracted from an example parse tree are
shown in Figure 2: the first structure is a negative
example for BC and is not part of the data set of
RM, whereas the second is a positive instance for
BC and A1.
To train BC we used PropBank sections 1
through 6, extracting AST,,, structures out of the
first 1 million (p, nz) pairs from the corresponding
parse trees. As a test set we used the 149,140 in-
stance collected from the annotations in Section
24. There are 61,062 positive examples in the
training set (i.e. 6.1%) and 8,515 in the test set
</bodyText>
<figure confidence="0.999355875">
S VP VP
(A0)
(A1)
NNP
VB
NP
⇒
bought
D-B
bought D
NN
Mary
bought
NN
a a cat
a cat -1: BC +1: BC,A1
-1: A0,A2,A3,A4,A5
D
NP
VP
VB-P
NP-B
VB-P
NP
</figure>
<page confidence="0.98959">
115
</page>
<bodyText confidence="0.998627024390244">
(i.e. 5.7%).
For RM we considered all the argument nodes
of any of the six PropBank core roles (i.e. A0,
... , A5) from all the available training sections,
i.e. 2 through 21, for a total of 179,091 train-
ing instances. Similarly, we collected 5,928 test
instances from the annotations of Section 24.
Columns Tr+ and Te+ of Table 1 show the num-
ber of positive training and test examples, respec-
tively, for BC and the role classifiers.
For all the linearized classifiers, we used 50
splits for the FMI stage and we set the threshold
value L = 50k and maxexp = 1 during FMI and
TFX. We did not validate these parameters, which
we know to be sub-optimal. These values were
selected during the development of the software
because, on a very small test bed, they resulted in
a responsive and accurate system.
We should point out that other experiments have
shown that linearization is very robust with re-
spect to parametrization: due to the huge num-
ber and variety of fragments in the TK space, dif-
ferent choices of the parameters result in differ-
ent explicit spaces and more or less efficient solu-
tions, but in most cases the final accuracy of the
linearized classifiers is affected only marginally.
For example, it could be expected that reducing
the number of splits during KSL would improve
the final accuracy of a linearized classifier, as the
weights used for FMI would then converge to the
global optimum. Instead, we have observed that
increasing the number of splits does not necessar-
ily decrease the accuracy of the linearized classi-
fier.
The evaluation on the whole SRL task using
the official CoNLL’05 evaluator was not carried
out because producing complete annotations re-
quires several steps (e.g. overlap resolution, OvA
or Pairwise combination of individual role classi-
fiers) that would shade off the actual impact of the
methodology on classification.
</bodyText>
<sectionHeader confidence="0.849141" genericHeader="method">
5.1.2 Results
</sectionHeader>
<bodyText confidence="0.999106111111111">
The left side of Table 1 shows the distribution of
positive data points in the training and test sets of
each classifier. Columns SST and SSTP compare
side by side the F1 measure of the non-linearized
and linearized classifier for each class. The accu-
racy of the RM classifier is the percentage of cor-
rect class assignments.
We can see that the accuracy of linearized clas-
sifiers is always in line with vanilla SST, even
</bodyText>
<table confidence="0.9995943">
Data set Accuracy
Class Tr+ Te+ SST SSTℓ
BC 61,062 8,515 81.8 81.3
A0 60,900 2,014 91.6 91.1
A1 90,636 3,041 89.0 89.4
A2 21,291 697 73.1 73.0
A3 3,481 105 56.8 53.0
A4 2,713 69 69.1 67.9
A5 69 2 66.7 0.0
RM 87.8 87.8
</table>
<tableCaption confidence="0.998131">
Table 1: Number of positive training (Tr+) and test
</tableCaption>
<bodyText confidence="0.990002536585366">
(Te+) examples in the SRL dataset. Accuracy of
the non-linearized (SST) and linearized (SSTP) bi-
nary classifiers (i.e. BC, A0, ... A5) is F1 measure.
Accuracy of RM is the percentage of correct class
assignments.
if the selected linearization parameters generate
a very rough approximation of the original frag-
ment space, generally consisting of billions of
fragments. BCP (i.e. the linearized BC) has an
F1 of 81.3, just 0.5% less than BC, i.e. 81.8. Con-
cerning RMP, its accuracy is the same as the non
linearized classifier, i.e. 87.8.
We should consider that the linearization frame-
work can drastically improve the efficiency of
learning and classification when dealing with large
amounts of data. For a linearized classifier, we
consider training time to be the overall time re-
quired to carry out the following activities: KSL,
FMI, TFX on training data and ESL. Similarly,
we consider test time the time necessary to per-
form TFX on test data and ESC. Training BC took
more than two days of CPU time and testing about
4 hours, while training and testing the linearized
boundary classifier required only 381 and 25 min-
utes, respectively. That is, on the same amount
of data we can train a linearized classifier about
8 times as fast, and test it in about 1 tenth of the
time. Concerning RM, sequential training of the
6 models took 2,596 minutes, while testing took
27 minutes. The linearized role multi classifier re-
quired 448 and 24 minutes for training and test-
ing, respectively, i.e. training is about 5 times as
fast while testing time is about the same. If com-
pared with the boundary classifier, the improve-
ment in efficiency is less evident: indeed, the rel-
atively small size of the role classifiers data sets
limits the positive effect of splitting training data
into smaller chunks.
SRL fragment space. Table 3 lists the best frag-
ments identified for the Boundary Classifier. We
should remember that we are using ASTm struc-
</bodyText>
<page confidence="0.997955">
116
</page>
<bodyText confidence="0.999916045454545">
tures as input to our classifiers: nodes whose la-
bel end with “-P” are predicate nodes, while nodes
whose label ends with “-B” are candidate argu-
ment nodes.
All the most relevant fragments encode the min-
imum sub-tree encompassing the predicate and the
argument node. This kind of structured feature
subsumes several features traditionally employed
for explicit SRL models: the Path (i.e. the se-
quence of nodes connecting the predicate and the
candidate argument node), Phrase Type (i.e. the
label of the candidate argument node), Predicate
POS (i.e. the POS of the predicate word), Posi-
tion (i.e. whether the argument is to the left or to
the right of the predicate) and Governing Category
(i.e. the label of the common ancestor) defined
in (Gildea and Jurafsky, 2002).
The linearized model for BC contains about 160
thousand fragments. Of these, about 70 and 33
thousand encompass the candidate argument or the
predicate node, respectively. About 16 thousand
fragments contain both.
</bodyText>
<subsectionHeader confidence="0.998206">
5.2 Question Classification
</subsectionHeader>
<bodyText confidence="0.999978666666667">
For question classification we used the data set
from the TREC 10 QA evaluation campaign2, con-
sisting of 5,500 training and 500 test questions.
</bodyText>
<subsectionHeader confidence="0.618395">
5.2.1 Setup
</subsectionHeader>
<bodyText confidence="0.999979631578948">
Given a question, the QC task consists in selecting
the most appropriate expected answer type from a
given set of possibilities. We adopted the question
taxonomy known as coarse grained, which has
been described in (Zhang and Lee, 2003) and (Li
and Roth, 2006), consisting of six non overlap-
ping classes: Abbreviations (ABBR), Descrip-
tions (DESC, e.g. definitions or explanations), En-
tity (ENTY, e.g. animal, body or color), Human
(HUM, e.g. group or individual), Location (LOC,
e.g. cities or countries) and Numeric (NUM, e.g.
amounts or dates).
For each question, we generate the full parse
of the sentence and use it to train SST and (lin-
earized) SSTℓ models. The automatic parses are
obtained with the Stanford parser3 (Klein and
Manning, 2003). We actually have only 5,483 sen-
tences in our training set, due to parsing issues
with a few of them.
</bodyText>
<footnote confidence="0.98485175">
2http://l2r.cs.uiuc.edu/cogcomp/Data/
QA/QC/
3http://nlp.stanford.edu/software/
lex-parser.shtml
</footnote>
<table confidence="0.999668888888889">
Data set Accuracy
Class Tr+ Te+ SST SSTℓ
ABBR 89 9 80.0 87.5
DESC 1,164 138 96.0 94.5
ENTY 1,269 94 63.9 63.5
HUM 1,231 65 88.1 87.2
LOC 834 81 77.6 77.9
NUM 896 113 80.4 80.8
Overall 86.2 86.6
</table>
<tableCaption confidence="0.98773">
Table 2: Number of positive training (Tr+) and test
</tableCaption>
<bodyText confidence="0.9910745">
(Te+) examples in the QA dataset. Accuracy of
the non-linearized (SST) and linearized (SSTℓ) bi-
nary classifiers is F1 measure. Overall accuracy is
the percentage of correct class assignments.
The classifiers are arranged in a one-vs.-all
(OvA) configuration, where each sentence is a
positive example for one of the six classes, and
negative for the other five. Given the very small
size of the data set, we used S = 1 during KSL
for the linearized classifier (i.e. we didn’t parti-
tion training data). We carried out no validation of
the parameters, and we used maxexp = 4 and
L = 50k in order to generate a rich fragment
space.
</bodyText>
<sectionHeader confidence="0.744397" genericHeader="evaluation">
5.2.2 Results
</sectionHeader>
<bodyText confidence="0.9998365">
Table 2 shows the number of positive examples
in the training and test set of each individual bi-
nary classifiers. Columns SST and SSTℓ compare
the F1 measure of the vanilla and linearized classi-
fiers on the individual classes, and the accuracy of
the complete QC task (Row Overall) in terms of
percentage of correct class assignments. Also in
this case, we can notice that the accuracy of the
linearized classifiers is always in line with non-
linearized ones, e.g. 86.6 vs. 86.2 for the multi-
classifiers. These results are lower than those de-
rived in (Moschitti, 2006; Moschitti et al., 2007),
i.e. 88.2 and 90.4, respectively, where the param-
eters for each classifier were carefully optimized.
QC Fragment space. Tables from 4 to 9 list the
top fragments identified for each class 4.
As expected, for all the categories the domain
lexical information is very relevant. For example,
film, color, book, novel and sport for ENTY or
city, country, state and capital for LOC. Of the six
classes, ENTY (Table 6) is mostly characterized
by lexical features. Interestingly, function words,
which would have been eliminated by a pure In-
formation Retrieval approach (i.e. by means of
</bodyText>
<footnote confidence="0.855045">
4Some categories show meaningful syntactic fragments
after the first 10, so for them we report more subtrees.
</footnote>
<page confidence="0.996284">
117
</page>
<bodyText confidence="0.9999624">
standard stop-list), are in the top positions, e.g.:
why and how for DESC, what for ENTY, who for
HUM, where for LOC and when for NUM. For the
latter, also how seems to be important suggesting
that features may strongly characterize more than
one given class.
Characteristic syntactic features appear in the
top positions for each class, for example: (VP (VB
(stand)) (PP)), which suggests that stand should
be followed by a prepositional phrase to character-
ize ABBR; or (NP (NP (DT) (NN (abbreviation)))
(PP)), which suggests that, to be in a relevant pat-
tern, abbreviation should be preceded by an article
and followed by a PP. Also, the syntactic struc-
ture is useful to differentiate the use of the same
important words, e.g. (SBARQ (WHADVP (WRB
(How))) (SQ) (.)) for DESC better characterizes
the use of how with respect to NUM, in which a
relevant use is (WHADJP (WRB (How)) (JJ)).
In (Moschitti et al., 2007) it was shown that the
use of TK improves QC of 1.2 percent points, i.e.
from 90.6 to 91.8: further analysis of these frag-
ments may help us to device compact, less sparse
syntactic features and design more accurate mod-
els for the task.
</bodyText>
<sectionHeader confidence="0.998828" genericHeader="discussions">
6 Discussion
</sectionHeader>
<bodyText confidence="0.999977625">
The fact that our model doesn’t always improve
the accuracy of a standard SST model might be
related to the process of splitting training data and
employing locally estimated weights during FMI.
Concerning the experiments presented in this
paper, this objection might apply to the results on
SRL, where we used 50 splits to identify the most
relevant fragments, but not to those on QC, where
given the limited size of the data set we decided
not to split training data at all as explained in Sec-
tion 5.2. Furthermore, as we already discussed,
we have evidence that there is no direct correlation
between the number of splits used for KSL and
the accuracy of the resulting classifier. After all,
the optimization carried out during ESL is global,
and we can assume that, if we mined enough frag-
ments during FMI, than those actually retained by
the global linear model would be by and large the
same, regardless of the split configuration.
More in general, feature selection may give an
improvement to some learning algorithm but if it
can help SVMs is debatable, since its related the-
ory show that they are robust to irrelevant fea-
tures. In our specific case, we remove features
</bodyText>
<figure confidence="0.975874389830509">
(ADJP(RB-B)(VBN-P))
(NP(VBN-P)(NNS-B))
(S(NP-B)(VP))
(VP(VBD-P(said))(SBAR))
(VP(VB-P)(NP-B))
(NP(VBG-P)(NNS-B))
(VP(VBD-P)(NP-B))
(VP(VBG-P)(NP-B))
(VP(VBZ-P)(NP-B))
(VP(VBN-P)(NP-B))
(VP(VBP-P)(NP-B))
(NP(NP-B)(VP))
(NP(VBG-P)(NN-B))
(S(S(VP(VBG-P)))(NP-B))
Table 3: Best fragments for SRL BC.
(NN(abbreviation))
(NP(DT)(NN(abbreviation)))
(NP(DT(the))(NN(abbreviation)))
(IN(for))
(VB(stand))
(VBZ(does))
(PP(IN))
(VP(VB(stand))(PP))
(NP(NP(DT)(NN(abbreviation)))(PP))
(SQ(VBZ)(NP)(VP(VB(stand))(PP)))
(SBARQ(WHNP)(SQ(VBZ)(NP)(VP(VB(stand))(PP)))(.))
(SQ(VBZ(does))(NP)(VP(VB(stand))(PP)))
(VP(VBZ)(NP(NP(DT)(NN(abbreviation)))(PP)))
Table 4: Best fragments for the ABBR class.
(WRB(Why))
(WHADVP(WRB(Why)))
(WHADVP(WRB(How)))
(WHADVP(WRB))
(VB(mean))
(VBZ(causes))
(VB(do))
(ROOT(SBARQ(WHADVP(WRB(How)))(SQ)(.)))
(ROOT(SBARQ(WHADVP(WRB(How)))(SQ)(.(?))))
(SBARQ(WHADVP(WRB(How)))(SQ))
(WRB(How))
(SBARQ(WHADVP(WRB(How)))(SQ)(.))
(SBARQ(WHADVP(WRB(How)))(SQ)(.(?)))
(SBARQ(WHADVP(WRB(Why)))(SQ))
(ROOT(SBARQ(WHADVP(WRB(Why)))(SQ)))
(SBARQ(WHADVP(WRB))(SQ))
Table 5: Best fragments for the DESC class.
(NN(film))
(NN(color))
(NN(book))
(NN(novel))
(NN(sport))
(WP(What))
(NN(fear))
(NN(movie))
(NN(word))
(VP(VBN(called)))
(NN(game))
(NP(DT)(NN(fear)))
(NP(NP(DT)(NN(fear)))(PP))
</figure>
<tableCaption confidence="0.9027">
Table 6: Best fragments for the ENTY class.
</tableCaption>
<page confidence="0.945541">
118
</page>
<figure confidence="0.984952245901639">
(NN(company))
(WP(Who))
(WHNP(WP(Who)))
(NN(name))
(NN(team))
(NN(baseball))
(WHNP(WP))
(NN(character))
(NNP(President))
(NN(leader))
(NN(actor))
(NN(president))
(JJ(Whose))
(VP(VBD)(NP))
(NP(NP)(JJ)(NN(name)))
(VP(VBD)(VP))
(NN(organization))
(VP(VBD)(NP)(PP(IN)(NP)))
(SBARQ(WHNP(WP(Who)))(SQ)(.))
(ROOT(SBARQ(WHNP(WP(Who)))(SQ)(.)))
(ROOT(SBARQ(WHNP(WP(Who)))(SQ)(.(?))))
(SBARQ(WHNP(WP(Who)))(SQ)(.(?)))
Table 7: Best fragments for the HUM class.
(NN(city))
(NN(country))
(WRB(Where))
(NN(state))
(WHADVP(WRB(Where)))
(NN(capital))
(NP(NN(city)))
(NNS(countries))
(NP(NN(state)))
(PP(IN(in)))
(SBARQ(WHADVP(WRB(Where)))(SQ)(.(?)))
(SBARQ(WHADVP(WRB(Where)))(SQ)(.))
(ROOT(SBARQ(WHADVP(WRB(Where)))(SQ)(.)))
(ROOT(SBARQ(WHADVP(WRB(Where)))(SQ)(.(?))))
(NN(island))
(NN(address))
(NN(river))
(NN(mountain))
(ROOT(SBARQ(WHADVP(WRB(Where)))(SQ)))
(SBARQ(WHADVP(WRB(Where)))(SQ))
Table 8: Best fragments for the LOC class.
(WRB(How))
(WHADVP(WRB(When)))
(WRB(When))
(JJ(many))
(NN(year))
(WHADJP(WRB)(JJ))
(NP(NN(year)))
(WHADJP(WRB(How))(JJ))
(NN(date))
(SBARQ(WHADVP(WRB(When)))(SQ)(.(?)))
(SBARQ(WHADVP(WRB(When)))(SQ)(.))
(NN(day))
(NN(population))
(ROOT(SBARQ(WHADVP(WRB(When)))(SQ)(.)))
(ROOT(SBARQ(WHADVP(WRB(When)))(SQ)(.(?))))
(JJ(average))
(NN(number))
</figure>
<tableCaption confidence="0.968655">
Table 9: Best fragments for the NUM class.
</tableCaption>
<bodyText confidence="0.999728454545455">
whose SVM weights are the lowest, i.e. those
that are (almost) irrelevant for the SVM. There-
fore, the chance of this resulting in an improve-
ment is rather low.
With respect to cases where our model is less
accurate than a standard SST, we should consider
that our choice of parameters is sub-optimal and
we adopt a very aggressive feature selection strat-
egy, that only retains a few thousand features from
a space where there are hundreds of millions of
different features.
</bodyText>
<sectionHeader confidence="0.999205" genericHeader="conclusions">
7 Conclusions
</sectionHeader>
<bodyText confidence="0.999994684210527">
We introduced a novel framework for support vec-
tor classification that combines advantages of con-
volution kernels, i.e. the generation of a very high
dimensional structure space, with the efficiency
and clarity of explicit representations in a linear
space.
For this paper, we focused on the SubSet Tree
kernel and verified the potential of the proposed
solution on two NLP tasks, i.e. semantic role
labeling and question classification. The exper-
iments show that our framework drastically re-
duces processing time, e.g. boundary classifica-
tion for SRL, while preserving the accuracy.
We presented a selection of the most relevant
fragments identified for the SRL boundary classi-
fier as well as for each class of the coarse grained
QC task. Our analysis shows that our frame-
work can discover state-of-the-art features, e.g.
the Path feature for SRL. We believe that shar-
ing these fragments with the NLP community and
studying them in more depth will be useful to
identify new, relevant features for the character-
ization of several learning problems. For this
purpose, we made available the fragment spaces
at http://danielepighin.net and we will keep
them updated with new set of experiments on new
tasks, e.g. SRL based on FrameNet and VerbNet,
e.g. (Giuglea and Moschitti, 2004).
In our future work, we plan to widen the list
of covered tasks and to extend our algorithm to
cope with different kernel families, such as the
partial tree kernel and kernels defined over pairs
of trees, e.g. the ones used for textual entailment
in (Moschitti and Zanzotto, 2007). We also plan to
move from mining fragments to mining classes of
fragments, i.e. to identify prototypical fragments
in the fragment space that generalize topological
sub-classes of the most relevant fragments.
</bodyText>
<page confidence="0.998709">
119
</page>
<sectionHeader confidence="0.998332" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999952434426229">
Fabio Aiolli, Giovanni Da San Martino, Alessandro Sper-
duti, and Alessandro Moschitti. 2006. Fast on-line kernel
learning for trees. In Proceedings ofICDM’06.
Stephan Bloehdorn and Alessandro Moschitti. 2007a. Com-
bined syntactic and semantic kernels for text classification.
In Proceedings ofECIR 2007, Rome, Italy.
Stephan Bloehdorn and Alessandro Moschitti. 2007b. Struc-
ture and semantics for expressive text kernels. In In Pro-
ceedings of CIKM ’07.
Nicola Cancedda, Eric Gaussier, Cyril Goutte, and
Jean Michel Renders. 2003. Word sequence kernels.
Journal ofMachine Learning Research, 3:1059–1082.
Xavier Carreras and Lluis M`arquez. 2005. Introduction to
the CoNLL-2005 Shared Task: Semantic Role Labeling.
In Proceedings of CoNLL’05.
Eugene Charniak. 2000. A maximum-entropy-inspired
parser. In Proceedings ofNAACL’00.
Michael Collins and Nigel Duffy. 2002. New Ranking Al-
gorithms for Parsing and Tagging: Kernels over Discrete
Structures, and the Voted Perceptron. In Proceedings of
ACL’02.
Aron Culotta and Jeffrey Sorensen. 2004. Dependency
Tree Kernels for Relation Extraction. In Proceedings of
ACL’04.
Chad Cumby and Dan Roth. 2003. Kernel Methods for Re-
lational Learning. In Proceedings ofICML 2003.
Mona Diab, Alessandro Moschitti, and Daniele Pighin. 2008.
Semantic role labeling systems for Arabic using kernel
methods. In Proceedings of ACL-08: HLT, pages 798–
806.
Daniel Gildea and Daniel Jurafsky. 2002. Automatic label-
ing of semantic roles. Computational Linguistics, 28:245–
288.
Ana-Maria Giuglea and Alessandro Moschitti. 2004.
Knowledge discovery using framenet, verbnet and prop-
bank. In A. Meyers, editor, Workshop on Ontology and
Knowledge Discovering at ECML 2004, Pisa, Italy.
Alfio Gliozzo, Claudio Giuliano, and Carlo Strapparava.
2005. Domain kernels for word sense disambiguation. In
Proceedings ofACL’05, pages 403–410.
Hans P. Graf, Eric Cosatto, Leon Bottou, Igor Durdanovic,
and Vladimir Vapnik. 2004. Parallel support vector ma-
chines: The cascade svm. In Neural Information Process-
ing Systems.
Isabelle Guyon and Andr´e Elisseeff. 2003. An introduc-
tion to variable and feature selection. Journal ofMachine
Learning Research, 3:1157–1182.
David Haussler. 1999. Convolution kernels on discrete struc-
tures. Technical report, Dept. of Computer Science, Uni-
versity of California at Santa Cruz.
T. Joachims. 2000. Estimating the generalization perfor-
mance of a SVM efficiently. In Proceedings ofICML’00.
Hisashi Kashima and Teruo Koyanagi. 2002. Kernels for
semi-structured data. In Proceedings ofICML’02.
Jun’ichi Kazama and Kentaro Torisawa. 2005. Speeding up
training with tree kernels for node relation labeling. In
Proceedings of HLT-EMNLP’05.
Dan Klein and Christopher D. Manning. 2003. Accurate
unlexicalized parsing. In Proceedings of ACL’03, pages
423–430.
Taku Kudo and Yuji Matsumoto. 2003. Fast methods for
kernel-based text analysis. In Proceedings ofACL’03.
Taku Kudo, Jun Suzuki, and Hideki Isozaki. 2005. Boosting-
based parse reranking with subtree features. In Proceed-
ings ofACL’05.
Xin Li and Dan Roth. 2006. Learning question classifiers:
the role of semantic information. Natural Language En-
gineering, 12(3):229–249.
Alessandro Moschitti and Fabio Massimo Zanzotto. 2007.
Fast and effective kernels for relational learning from
texts. In ICML’07.
Alessandro Moschitti, Silvia Quarteroni, Roberto Basili, and
Suresh Manandhar. 2007. Exploiting syntactic and shal-
low semantic kernels for question/answer classification.
In Proceedings ofACL’07.
Alessandro Moschitti, Daniele Pighin, and Roberto Basili.
2008. Tree kernels for semantic role labeling. Compu-
tational Linguistics, 34(2):193–224.
Alessandro Moschitti. 2006. Efficient convolution kernels
for dependency and constituent syntactic trees. In Pro-
ceedings of ECML’06, pages 318–329.
Julia Neumann, Christoph Schnorr, and Gabriele Steidl.
2005. Combined SVM-Based Feature Selection and Clas-
sification. Machine Learning, 61(1-3):129–150.
Martha Palmer, Daniel Gildea, and Paul Kingsbury. 2005.
The proposition bank: An annotated corpus of semantic
roles. Comput. Linguist., 31(1):71–106.
J. Pei, J. Han, Mortazavi B. Asl, H. Pinto, Q. Chen, U. Dayal,
and M. C. Hsu. 2001. PrefixSpan Mining Sequential Pat-
terns Efficiently by Prefix Projected Pattern Growth. In
Proceedings ofICDE’01.
Daniele Pighin and Alessandro Moschitti. 2009. Efficient
linearization of tree kernel functions. In Proceedings of
CoNLL’09.
Alain Rakotomamonjy. 2003. Variable selection using SVM
based criteria. Journal of Machine Learning Research,
3:1357–1370.
Libin Shen, Anoop Sarkar, and Aravind k. Joshi. 2003. Us-
ing LTAG Based Features in Parse Reranking. In Proceed-
ings of EMNLP’06.
Jun Suzuki and Hideki Isozaki. 2005. Sequence and Tree
Kernels with Statistical Feature Mining. In Proceedings
ofNIPS’05.
Kristina Toutanova, Penka Markova, and Christopher Man-
ning. 2004. The Leaf Path Projection View of Parse
Trees: Exploring String Kernels for HPSG Parse Selec-
tion. In Proceedings ofEMNLP 2004.
Vladimir N. Vapnik. 1998. Statistical Learning Theory.
Wiley-Interscience.
Ellen M. Voorhees. 2001. Overview of the trec 2001 ques-
tion answering track. In In Proceedings of the Tenth Text
REtrieval Conference (TREC, pages 42–51.
Jason Weston, Sayan Mukherjee, Olivier Chapelle, Massimil-
iano Pontil, Tomaso Poggio, and Vladimir Vapnik. 2001.
Feature Selection for SVMs. In Proceedings ofNIPS’01.
Jason Weston, Andr´e Elisseeff, Bernhard Sch¨olkopf, and
Mike Tipping. 2003. Use of the zero norm with lin-
ear models and kernel methods. J. Mach. Learn. Res.,
3:1439–1461.
Dell Zhang and Wee Sun Lee. 2003. Question classifica-
tion using support vector machines. In Proceedings of SI-
GIR’03, pages 26–32.
</reference>
<page confidence="0.996284">
120
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.227974">
<title confidence="0.999574">Reverse Engineering of Tree Kernel Feature Spaces</title>
<author confidence="0.876962">Daniele</author>
<email confidence="0.617553">FBK-Irst,HLT</email>
<author confidence="0.546344">Via di_Sommarive</author>
<author confidence="0.546344">I- Povo Italy</author>
<email confidence="0.986854">pighin@fbk.eu</email>
<author confidence="0.96001">Alessandro</author>
<affiliation confidence="0.832368">University of Trento, DISI Via di Sommarive, 14 I-38100 Povo (TN) Italy</affiliation>
<email confidence="0.998025">moschitti@disi.unitn.it</email>
<abstract confidence="0.998323315789473">We present a framework to extract the most important features (tree fragments) from a Tree Kernel (TK) space according to their importance in the target kernelbased machine, e.g. Support Vector Machines (SVMs). In particular, our mining algorithm selects the most relevant features based on SVM estimated weights and uses this information to automatically infer an explicit representation of the input data. The explicit features (a) improve our knowledge on the target problem domain and (b) make large-scale learning practical, improving training and test time, while yielding accuracy in line with traditional TK classifiers. Experiments on semantic role labeling and question classification illustrate the above claims.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Fabio Aiolli</author>
<author>Giovanni Da San Martino</author>
<author>Alessandro Sperduti</author>
<author>Alessandro Moschitti</author>
</authors>
<title>Fast on-line kernel learning for trees.</title>
<date>2006</date>
<booktitle>In Proceedings ofICDM’06.</booktitle>
<contexts>
<context position="16565" citStr="Aiolli et al., 2006" startWordPosition="2894" endWordPosition="2897">d has been one of the major sources of inspiration for our methodology. With respect to their work, the difference 114 in our approach is that we want to exploit the SVM optimizer to select the most relevant features instead of a relevance assessment measure that moves from different statistical assumptions than the learning algorithm. In (Graf et al., 2004), an approach to SVM parallelization is presented which is based on a divide-et-impera strategy to reduce optimization time. The idea of using a compact graph representation to represent the support vectors of a TK function is explored in (Aiolli et al., 2006), where a Direct Acyclic Graph (DAG) is employed. In (Moschitti, 2006; Bloehdorn and Moschitti, 2007a; Bloehdorn and Moschitti, 2007b; Moschitti et al., 2007), the SST kernel along with other tree and combined kernels are employed for question classification and semantic role labeling with interesting results. 5 Experiments We evaluated the capability of our model to extract relevant features on two data sets: the CoNLL 2005 shared task on Semantic Role Labeling (SRL) (Carreras and M`arquez, 2005), and the Question Classification (QC) task based on data from the TREC 10 QA competition (Voorhee</context>
</contexts>
<marker>Aiolli, Martino, Sperduti, Moschitti, 2006</marker>
<rawString>Fabio Aiolli, Giovanni Da San Martino, Alessandro Sperduti, and Alessandro Moschitti. 2006. Fast on-line kernel learning for trees. In Proceedings ofICDM’06.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Stephan Bloehdorn</author>
<author>Alessandro Moschitti</author>
</authors>
<title>Combined syntactic and semantic kernels for text classification.</title>
<date>2007</date>
<booktitle>In Proceedings ofECIR 2007,</booktitle>
<location>Rome, Italy.</location>
<contexts>
<context position="16665" citStr="Bloehdorn and Moschitti, 2007" startWordPosition="2909" endWordPosition="2912">ir work, the difference 114 in our approach is that we want to exploit the SVM optimizer to select the most relevant features instead of a relevance assessment measure that moves from different statistical assumptions than the learning algorithm. In (Graf et al., 2004), an approach to SVM parallelization is presented which is based on a divide-et-impera strategy to reduce optimization time. The idea of using a compact graph representation to represent the support vectors of a TK function is explored in (Aiolli et al., 2006), where a Direct Acyclic Graph (DAG) is employed. In (Moschitti, 2006; Bloehdorn and Moschitti, 2007a; Bloehdorn and Moschitti, 2007b; Moschitti et al., 2007), the SST kernel along with other tree and combined kernels are employed for question classification and semantic role labeling with interesting results. 5 Experiments We evaluated the capability of our model to extract relevant features on two data sets: the CoNLL 2005 shared task on Semantic Role Labeling (SRL) (Carreras and M`arquez, 2005), and the Question Classification (QC) task based on data from the TREC 10 QA competition (Voorhees, 2001). The next sections will detail the setup and outcome of the two sets of experiments. All th</context>
</contexts>
<marker>Bloehdorn, Moschitti, 2007</marker>
<rawString>Stephan Bloehdorn and Alessandro Moschitti. 2007a. Combined syntactic and semantic kernels for text classification. In Proceedings ofECIR 2007, Rome, Italy.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Stephan Bloehdorn</author>
<author>Alessandro Moschitti</author>
</authors>
<title>Structure and semantics for expressive text kernels. In</title>
<date>2007</date>
<booktitle>In Proceedings of CIKM ’07.</booktitle>
<contexts>
<context position="16665" citStr="Bloehdorn and Moschitti, 2007" startWordPosition="2909" endWordPosition="2912">ir work, the difference 114 in our approach is that we want to exploit the SVM optimizer to select the most relevant features instead of a relevance assessment measure that moves from different statistical assumptions than the learning algorithm. In (Graf et al., 2004), an approach to SVM parallelization is presented which is based on a divide-et-impera strategy to reduce optimization time. The idea of using a compact graph representation to represent the support vectors of a TK function is explored in (Aiolli et al., 2006), where a Direct Acyclic Graph (DAG) is employed. In (Moschitti, 2006; Bloehdorn and Moschitti, 2007a; Bloehdorn and Moschitti, 2007b; Moschitti et al., 2007), the SST kernel along with other tree and combined kernels are employed for question classification and semantic role labeling with interesting results. 5 Experiments We evaluated the capability of our model to extract relevant features on two data sets: the CoNLL 2005 shared task on Semantic Role Labeling (SRL) (Carreras and M`arquez, 2005), and the Question Classification (QC) task based on data from the TREC 10 QA competition (Voorhees, 2001). The next sections will detail the setup and outcome of the two sets of experiments. All th</context>
</contexts>
<marker>Bloehdorn, Moschitti, 2007</marker>
<rawString>Stephan Bloehdorn and Alessandro Moschitti. 2007b. Structure and semantics for expressive text kernels. In In Proceedings of CIKM ’07.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Nicola Cancedda</author>
<author>Eric Gaussier</author>
<author>Cyril Goutte</author>
<author>Jean Michel Renders</author>
</authors>
<title>Word sequence kernels.</title>
<date>2003</date>
<journal>Journal ofMachine Learning Research,</journal>
<pages>3--1059</pages>
<contexts>
<context position="1601" citStr="Cancedda et al., 2003" startWordPosition="238" endWordPosition="241"> claims. 1 Introduction The last decade has seen a massive use of Support Vector Machines (SVMs) for carrying out NLP tasks. Indeed, their appealing properties such as 1) solid theoretical foundations, 2) robustness to irrelevant features and 3) outperforming accuracy have been exploited to design state-of-the-art language applications. More recently, kernel functions, which implicitly represent data in some high dimensional space, have been employed to study and further improve many natural language systems, e.g. (Collins and Duffy, 2002), (Kudo and Matsumoto, 2003), (Cumby and Roth, 2003), (Cancedda et al., 2003), (Culotta and Sorensen, 2004), (Toutanova et al., 2004), (Kazama and Torisawa, 2005), (Shen et al., 2003), (Gliozzo et al., 2005), (Kudo et al., 2005), (Moschitti et al., 2008), (Diab et al., 2008). Unfortunately, the benefit to easily and effectively model the target linguistic phenomena is reduced by the the implicit nature of the kernel space, which prevents to directly observe the most relevant features. As a consequence, even very accurate models generally fail in providing useful feedback for improving our understanding of the problems at study. Moreover, the computational burden induce</context>
</contexts>
<marker>Cancedda, Gaussier, Goutte, Renders, 2003</marker>
<rawString>Nicola Cancedda, Eric Gaussier, Cyril Goutte, and Jean Michel Renders. 2003. Word sequence kernels. Journal ofMachine Learning Research, 3:1059–1082.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Xavier Carreras</author>
<author>Lluis M`arquez</author>
</authors>
<title>Introduction to the CoNLL-2005 Shared Task: Semantic Role Labeling.</title>
<date>2005</date>
<booktitle>In Proceedings of CoNLL’05.</booktitle>
<marker>Carreras, M`arquez, 2005</marker>
<rawString>Xavier Carreras and Lluis M`arquez. 2005. Introduction to the CoNLL-2005 Shared Task: Semantic Role Labeling. In Proceedings of CoNLL’05.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Eugene Charniak</author>
</authors>
<title>A maximum-entropy-inspired parser.</title>
<date>2000</date>
<booktitle>In Proceedings ofNAACL’00.</booktitle>
<contexts>
<context position="18300" citStr="Charniak, 2000" startWordPosition="3172" endWordPosition="3173"> the default decay factor A = 0.4. For ESL, we use a non-normalized, linear kernel. No further parametrization of the learning algorithms is carried out. Indeed, our focus is on showing that, under the same conditions, our linearized tree kernel can be as accurate as the original kernel, and choosing of parameters may just bias such test. 5.1 Semantic Role Labeling For our experiments on semantic role labeling we used PropBank annotations (Palmer et al., 2005) 1http://disi.unitn.it/˜moschitt/ Tree-Kernel.htm Figure 2: Examples of AST,,, structured features. and automatic Charniak parse trees (Charniak, 2000) as provided for the CoNLL 2005 evaluation campaign (Carreras and M`arquez, 2005). SRL can be decomposed into two tasks: boundary detection, where the word sequences that are arguments of a predicate word w are identified, and role classification, where each argument is assigned the proper role. The former task requires a binary Boundary Classifier (BC), whereas the second involves a Role Multi-class Classifier (RM). 5.1.1 Setup If the constituency parse tree t of a sentence s is available, we can look at all the pairs (p, nz), where nz is any node in the tree and p is the node dominating w, a</context>
</contexts>
<marker>Charniak, 2000</marker>
<rawString>Eugene Charniak. 2000. A maximum-entropy-inspired parser. In Proceedings ofNAACL’00.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Michael Collins</author>
<author>Nigel Duffy</author>
</authors>
<title>New Ranking Algorithms for Parsing and Tagging: Kernels over Discrete Structures, and the Voted Perceptron.</title>
<date>2002</date>
<booktitle>In Proceedings of ACL’02.</booktitle>
<contexts>
<context position="1524" citStr="Collins and Duffy, 2002" startWordPosition="226" endWordPosition="229">ents on semantic role labeling and question classification illustrate the above claims. 1 Introduction The last decade has seen a massive use of Support Vector Machines (SVMs) for carrying out NLP tasks. Indeed, their appealing properties such as 1) solid theoretical foundations, 2) robustness to irrelevant features and 3) outperforming accuracy have been exploited to design state-of-the-art language applications. More recently, kernel functions, which implicitly represent data in some high dimensional space, have been employed to study and further improve many natural language systems, e.g. (Collins and Duffy, 2002), (Kudo and Matsumoto, 2003), (Cumby and Roth, 2003), (Cancedda et al., 2003), (Culotta and Sorensen, 2004), (Toutanova et al., 2004), (Kazama and Torisawa, 2005), (Shen et al., 2003), (Gliozzo et al., 2005), (Kudo et al., 2005), (Moschitti et al., 2008), (Diab et al., 2008). Unfortunately, the benefit to easily and effectively model the target linguistic phenomena is reduced by the the implicit nature of the kernel space, which prevents to directly observe the most relevant features. As a consequence, even very accurate models generally fail in providing useful feedback for improving our unde</context>
<context position="5498" citStr="Collins and Duffy, 2002" startWordPosition="877" endWordPosition="880">= αiyik(oi, o) + b i=1 with the advantage that we do not need to provide an explicit mapping 0(·) of our examples in a vector space. A Tree Kernel function is a convolution kernel (Haussler, 1999) defined over pairs of trees. Practically speaking, the kernel between two trees evaluates the number of substructures (or fragments) they have in common, i.e. it is a measure of their overlap. The function can be computed recursively in closed form, and quite efficient implementations are available (Moschitti, 2006). Different TK functions are characterized by alternative fragment definitions, e.g. (Collins and Duffy, 2002) and (Kashima and Koyanagi, 2002). In the context of this paper we will be focusing on the SubSet Tree (SST) kernel described in (Collins and Duffy, 2002), which relies on a fragment definition that does not allow to break production rules (i.e. if any child of a node is included in a fragment, then also all the other children have to). As such, it is especially indicated for tasks involving constituency parsed texts. Implicitly, a TK function establishes a correspondence between distinct fragments and dimensions in some fragment space, i.e. the space of all Figure 1: Esemplification of a frag</context>
</contexts>
<marker>Collins, Duffy, 2002</marker>
<rawString>Michael Collins and Nigel Duffy. 2002. New Ranking Algorithms for Parsing and Tagging: Kernels over Discrete Structures, and the Voted Perceptron. In Proceedings of ACL’02.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Aron Culotta</author>
<author>Jeffrey Sorensen</author>
</authors>
<title>Dependency Tree Kernels for Relation Extraction.</title>
<date>2004</date>
<booktitle>In Proceedings of ACL’04.</booktitle>
<contexts>
<context position="1631" citStr="Culotta and Sorensen, 2004" startWordPosition="242" endWordPosition="245">he last decade has seen a massive use of Support Vector Machines (SVMs) for carrying out NLP tasks. Indeed, their appealing properties such as 1) solid theoretical foundations, 2) robustness to irrelevant features and 3) outperforming accuracy have been exploited to design state-of-the-art language applications. More recently, kernel functions, which implicitly represent data in some high dimensional space, have been employed to study and further improve many natural language systems, e.g. (Collins and Duffy, 2002), (Kudo and Matsumoto, 2003), (Cumby and Roth, 2003), (Cancedda et al., 2003), (Culotta and Sorensen, 2004), (Toutanova et al., 2004), (Kazama and Torisawa, 2005), (Shen et al., 2003), (Gliozzo et al., 2005), (Kudo et al., 2005), (Moschitti et al., 2008), (Diab et al., 2008). Unfortunately, the benefit to easily and effectively model the target linguistic phenomena is reduced by the the implicit nature of the kernel space, which prevents to directly observe the most relevant features. As a consequence, even very accurate models generally fail in providing useful feedback for improving our understanding of the problems at study. Moreover, the computational burden induced by high dimensional kernels </context>
</contexts>
<marker>Culotta, Sorensen, 2004</marker>
<rawString>Aron Culotta and Jeffrey Sorensen. 2004. Dependency Tree Kernels for Relation Extraction. In Proceedings of ACL’04.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Chad Cumby</author>
<author>Dan Roth</author>
</authors>
<title>Kernel Methods for Relational Learning.</title>
<date>2003</date>
<booktitle>In Proceedings ofICML</booktitle>
<contexts>
<context position="1576" citStr="Cumby and Roth, 2003" startWordPosition="234" endWordPosition="237">ion illustrate the above claims. 1 Introduction The last decade has seen a massive use of Support Vector Machines (SVMs) for carrying out NLP tasks. Indeed, their appealing properties such as 1) solid theoretical foundations, 2) robustness to irrelevant features and 3) outperforming accuracy have been exploited to design state-of-the-art language applications. More recently, kernel functions, which implicitly represent data in some high dimensional space, have been employed to study and further improve many natural language systems, e.g. (Collins and Duffy, 2002), (Kudo and Matsumoto, 2003), (Cumby and Roth, 2003), (Cancedda et al., 2003), (Culotta and Sorensen, 2004), (Toutanova et al., 2004), (Kazama and Torisawa, 2005), (Shen et al., 2003), (Gliozzo et al., 2005), (Kudo et al., 2005), (Moschitti et al., 2008), (Diab et al., 2008). Unfortunately, the benefit to easily and effectively model the target linguistic phenomena is reduced by the the implicit nature of the kernel space, which prevents to directly observe the most relevant features. As a consequence, even very accurate models generally fail in providing useful feedback for improving our understanding of the problems at study. Moreover, the co</context>
</contexts>
<marker>Cumby, Roth, 2003</marker>
<rawString>Chad Cumby and Dan Roth. 2003. Kernel Methods for Relational Learning. In Proceedings ofICML 2003.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Mona Diab</author>
<author>Alessandro Moschitti</author>
<author>Daniele Pighin</author>
</authors>
<title>Semantic role labeling systems for Arabic using kernel methods.</title>
<date>2008</date>
<booktitle>In Proceedings of ACL-08: HLT,</booktitle>
<pages>798--806</pages>
<contexts>
<context position="1799" citStr="Diab et al., 2008" startWordPosition="270" endWordPosition="273">2) robustness to irrelevant features and 3) outperforming accuracy have been exploited to design state-of-the-art language applications. More recently, kernel functions, which implicitly represent data in some high dimensional space, have been employed to study and further improve many natural language systems, e.g. (Collins and Duffy, 2002), (Kudo and Matsumoto, 2003), (Cumby and Roth, 2003), (Cancedda et al., 2003), (Culotta and Sorensen, 2004), (Toutanova et al., 2004), (Kazama and Torisawa, 2005), (Shen et al., 2003), (Gliozzo et al., 2005), (Kudo et al., 2005), (Moschitti et al., 2008), (Diab et al., 2008). Unfortunately, the benefit to easily and effectively model the target linguistic phenomena is reduced by the the implicit nature of the kernel space, which prevents to directly observe the most relevant features. As a consequence, even very accurate models generally fail in providing useful feedback for improving our understanding of the problems at study. Moreover, the computational burden induced by high dimensional kernels makes the application of SVMs to large corpora still more problematic. In (Pighin and Moschitti, 2009), we proposed a feature extraction algorithm for Tree Kernel (TK) </context>
</contexts>
<marker>Diab, Moschitti, Pighin, 2008</marker>
<rawString>Mona Diab, Alessandro Moschitti, and Daniele Pighin. 2008. Semantic role labeling systems for Arabic using kernel methods. In Proceedings of ACL-08: HLT, pages 798– 806.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Daniel Gildea</author>
<author>Daniel Jurafsky</author>
</authors>
<title>Automatic labeling of semantic roles.</title>
<date>2002</date>
<journal>Computational Linguistics,</journal>
<volume>28</volume>
<pages>288</pages>
<contexts>
<context position="25706" citStr="Gildea and Jurafsky, 2002" startWordPosition="4478" endWordPosition="4481">rgument nodes. All the most relevant fragments encode the minimum sub-tree encompassing the predicate and the argument node. This kind of structured feature subsumes several features traditionally employed for explicit SRL models: the Path (i.e. the sequence of nodes connecting the predicate and the candidate argument node), Phrase Type (i.e. the label of the candidate argument node), Predicate POS (i.e. the POS of the predicate word), Position (i.e. whether the argument is to the left or to the right of the predicate) and Governing Category (i.e. the label of the common ancestor) defined in (Gildea and Jurafsky, 2002). The linearized model for BC contains about 160 thousand fragments. Of these, about 70 and 33 thousand encompass the candidate argument or the predicate node, respectively. About 16 thousand fragments contain both. 5.2 Question Classification For question classification we used the data set from the TREC 10 QA evaluation campaign2, consisting of 5,500 training and 500 test questions. 5.2.1 Setup Given a question, the QC task consists in selecting the most appropriate expected answer type from a given set of possibilities. We adopted the question taxonomy known as coarse grained, which has bee</context>
</contexts>
<marker>Gildea, Jurafsky, 2002</marker>
<rawString>Daniel Gildea and Daniel Jurafsky. 2002. Automatic labeling of semantic roles. Computational Linguistics, 28:245– 288.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ana-Maria Giuglea</author>
<author>Alessandro Moschitti</author>
</authors>
<title>Knowledge discovery using framenet, verbnet and propbank.</title>
<date>2004</date>
<booktitle>Workshop on Ontology and Knowledge Discovering at ECML 2004,</booktitle>
<editor>In A. Meyers, editor,</editor>
<location>Pisa, Italy.</location>
<marker>Giuglea, Moschitti, 2004</marker>
<rawString>Ana-Maria Giuglea and Alessandro Moschitti. 2004. Knowledge discovery using framenet, verbnet and propbank. In A. Meyers, editor, Workshop on Ontology and Knowledge Discovering at ECML 2004, Pisa, Italy.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Alfio Gliozzo</author>
<author>Claudio Giuliano</author>
<author>Carlo Strapparava</author>
</authors>
<title>Domain kernels for word sense disambiguation.</title>
<date>2005</date>
<booktitle>In Proceedings ofACL’05,</booktitle>
<pages>403--410</pages>
<contexts>
<context position="1731" citStr="Gliozzo et al., 2005" startWordPosition="258" endWordPosition="261">, their appealing properties such as 1) solid theoretical foundations, 2) robustness to irrelevant features and 3) outperforming accuracy have been exploited to design state-of-the-art language applications. More recently, kernel functions, which implicitly represent data in some high dimensional space, have been employed to study and further improve many natural language systems, e.g. (Collins and Duffy, 2002), (Kudo and Matsumoto, 2003), (Cumby and Roth, 2003), (Cancedda et al., 2003), (Culotta and Sorensen, 2004), (Toutanova et al., 2004), (Kazama and Torisawa, 2005), (Shen et al., 2003), (Gliozzo et al., 2005), (Kudo et al., 2005), (Moschitti et al., 2008), (Diab et al., 2008). Unfortunately, the benefit to easily and effectively model the target linguistic phenomena is reduced by the the implicit nature of the kernel space, which prevents to directly observe the most relevant features. As a consequence, even very accurate models generally fail in providing useful feedback for improving our understanding of the problems at study. Moreover, the computational burden induced by high dimensional kernels makes the application of SVMs to large corpora still more problematic. In (Pighin and Moschitti, 200</context>
</contexts>
<marker>Gliozzo, Giuliano, Strapparava, 2005</marker>
<rawString>Alfio Gliozzo, Claudio Giuliano, and Carlo Strapparava. 2005. Domain kernels for word sense disambiguation. In Proceedings ofACL’05, pages 403–410.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Hans P Graf</author>
<author>Eric Cosatto</author>
<author>Leon Bottou</author>
<author>Igor Durdanovic</author>
<author>Vladimir Vapnik</author>
</authors>
<title>Parallel support vector machines: The cascade svm.</title>
<date>2004</date>
<booktitle>In Neural Information Processing Systems.</booktitle>
<contexts>
<context position="8537" citStr="Graf et al., 2004" startWordPosition="1457" endWordPosition="1460">rithm 3.1: MINE MODEL(M, L, A) global maxexp prev +— 0 ; CLEAR INDEX() for each (αy, t) G M  Ti +— α · y/IItII for each n G Art (f +— FRAG(n) ; rel = A · Ti do  do prev +— prev U {f, rel} PUT(f, rel) best pr +— BEST(L) ; while true next +— 0 for each (f, rel) G prev if f G best pr FL +— best pr return (FL) Nonetheless, since we do not need to employ them for classification (but just to direct our feature selection process, as we will describe shortly), we can accept to rely on sub-optimal weights. Furthermore, research results in the field of SVM parallelization using cascades of SVMs (Graf et al., 2004) suggest that support vectors collected from locally learnt models can encode many of the relevant features retained by models learnt globally. Henceforth, let Ms be the model associated with the s-th split, and Fs the fragment space that can describe all the trees in Ms. 3.2 Fragment Mining and Indexing (FMI) In Equation 1 it is possible to isolate the gradient w~ = Pn a x with xi = [x�1) x&apos;N)] N i=1 zyi z� z z , ... , z , being the dimensionality of the feature space. For a tree kernel function, we can rewrite x(j) ias: ti,jλℓ(fj) ti,jλℓ(fj) x(j) i = ktik = qPN k=1(ti,kλℓ(fk))2 (2) where: ti</context>
<context position="16305" citStr="Graf et al., 2004" startWordPosition="2851" endWordPosition="2854">and Isozaki (2005) present an embedded approach to feature selection for convolution kernels based on χ2-driven relevance assessment. To our knowledge, this is the only published work clearly focusing on feature selection for tree kernel functions, and indeed has been one of the major sources of inspiration for our methodology. With respect to their work, the difference 114 in our approach is that we want to exploit the SVM optimizer to select the most relevant features instead of a relevance assessment measure that moves from different statistical assumptions than the learning algorithm. In (Graf et al., 2004), an approach to SVM parallelization is presented which is based on a divide-et-impera strategy to reduce optimization time. The idea of using a compact graph representation to represent the support vectors of a TK function is explored in (Aiolli et al., 2006), where a Direct Acyclic Graph (DAG) is employed. In (Moschitti, 2006; Bloehdorn and Moschitti, 2007a; Bloehdorn and Moschitti, 2007b; Moschitti et al., 2007), the SST kernel along with other tree and combined kernels are employed for question classification and semantic role labeling with interesting results. 5 Experiments We evaluated t</context>
</contexts>
<marker>Graf, Cosatto, Bottou, Durdanovic, Vapnik, 2004</marker>
<rawString>Hans P. Graf, Eric Cosatto, Leon Bottou, Igor Durdanovic, and Vladimir Vapnik. 2004. Parallel support vector machines: The cascade svm. In Neural Information Processing Systems.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Isabelle Guyon</author>
<author>Andr´e Elisseeff</author>
</authors>
<title>An introduction to variable and feature selection.</title>
<date>2003</date>
<journal>Journal ofMachine Learning Research,</journal>
<pages>3--1157</pages>
<contexts>
<context position="15099" citStr="Guyon and Elisseeff, 2003" startWordPosition="2652" endWordPosition="2655">d. The process is applied to the whole training (TFX-train) and test (TFX-test) sets. The fragment space is now explicit, as there is a mapping between the input vectors and the fragments they encode. 3.4 Explicit Space Learning (ESL) Linearized training data is used to learn a very fast model by using all the available data and a linear kernel. 3.5 Explicit Space Classification (ESC) The linear model is used to classify linearized test data and evaluate the accuracy of the resulting classifier. 4 Previous work A rather comprehensive overview of feature selection techniques is carried out in (Guyon and Elisseeff, 2003). Non-filter approaches for SVMs and kernel machines are often concerned with polynomial and Gaussian kernels, e.g. (Weston et al., 2001) and (Neumann et al., 2005). Weston et al. (2003) use the ℓ0 norm in the SVM optimizer to stress the feature selection capabilities of the learning algorithm. In (Kudo and Matsumoto, 2003), an extension of the PrefixSpan algorithm (Pei et al., 2001) is used to efficiently mine the features in a low degree polynomial kernel space. The authors discuss an approximation of their method that allows them to handle high degree polynomial kernels. Suzuki and Isozaki </context>
</contexts>
<marker>Guyon, Elisseeff, 2003</marker>
<rawString>Isabelle Guyon and Andr´e Elisseeff. 2003. An introduction to variable and feature selection. Journal ofMachine Learning Research, 3:1157–1182.</rawString>
</citation>
<citation valid="true">
<authors>
<author>David Haussler</author>
</authors>
<title>Convolution kernels on discrete structures.</title>
<date>1999</date>
<tech>Technical report,</tech>
<institution>Dept. of Computer Science, University of California at Santa Cruz.</institution>
<contexts>
<context position="5070" citStr="Haussler, 1999" startWordPosition="812" endWordPosition="813">tion of an SVM is: n f(x) = w· x+ b = αiyiei · x + b (1) i=1 where x is a classifying example and w and b are the separating hyperplane’s gradient and its bias, respectively. The gradient is a linear combination of the training points xz, their labels yi and their weights αi. Applying the so-called kernel trick it is possible to replace the scalar product with a kernel function defined over pairs of objects: n f(o) = αiyik(oi, o) + b i=1 with the advantage that we do not need to provide an explicit mapping 0(·) of our examples in a vector space. A Tree Kernel function is a convolution kernel (Haussler, 1999) defined over pairs of trees. Practically speaking, the kernel between two trees evaluates the number of substructures (or fragments) they have in common, i.e. it is a measure of their overlap. The function can be computed recursively in closed form, and quite efficient implementations are available (Moschitti, 2006). Different TK functions are characterized by alternative fragment definitions, e.g. (Collins and Duffy, 2002) and (Kashima and Koyanagi, 2002). In the context of this paper we will be focusing on the SubSet Tree (SST) kernel described in (Collins and Duffy, 2002), which relies on </context>
</contexts>
<marker>Haussler, 1999</marker>
<rawString>David Haussler. 1999. Convolution kernels on discrete structures. Technical report, Dept. of Computer Science, University of California at Santa Cruz.</rawString>
</citation>
<citation valid="true">
<authors>
<author>T Joachims</author>
</authors>
<title>Estimating the generalization performance of a SVM efficiently.</title>
<date>2000</date>
<booktitle>In Proceedings ofICML’00.</booktitle>
<contexts>
<context position="17484" citStr="Joachims, 2000" startWordPosition="3048" endWordPosition="3049">esults. 5 Experiments We evaluated the capability of our model to extract relevant features on two data sets: the CoNLL 2005 shared task on Semantic Role Labeling (SRL) (Carreras and M`arquez, 2005), and the Question Classification (QC) task based on data from the TREC 10 QA competition (Voorhees, 2001). The next sections will detail the setup and outcome of the two sets of experiments. All the experiments were run on a machine equipped with 4 Intel ® Xeon® CPUs clocked at 1.6 GHz and 4 GB of RAM. As a supervised learning framework we used SVM-Light-TK1, which extends the SVM-Light optimizer (Joachims, 2000) with tree kernel support. For each classification task, we compare the accuracy of a vanilla SST classifier against the corresponding linearized SST classifier (SSTs). For KSL and SST training we used the default decay factor A = 0.4. For ESL, we use a non-normalized, linear kernel. No further parametrization of the learning algorithms is carried out. Indeed, our focus is on showing that, under the same conditions, our linearized tree kernel can be as accurate as the original kernel, and choosing of parameters may just bias such test. 5.1 Semantic Role Labeling For our experiments on semantic</context>
</contexts>
<marker>Joachims, 2000</marker>
<rawString>T. Joachims. 2000. Estimating the generalization performance of a SVM efficiently. In Proceedings ofICML’00.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Hisashi Kashima</author>
<author>Teruo Koyanagi</author>
</authors>
<title>Kernels for semi-structured data. In</title>
<date>2002</date>
<booktitle>Proceedings ofICML’02.</booktitle>
<contexts>
<context position="5531" citStr="Kashima and Koyanagi, 2002" startWordPosition="882" endWordPosition="885">e advantage that we do not need to provide an explicit mapping 0(·) of our examples in a vector space. A Tree Kernel function is a convolution kernel (Haussler, 1999) defined over pairs of trees. Practically speaking, the kernel between two trees evaluates the number of substructures (or fragments) they have in common, i.e. it is a measure of their overlap. The function can be computed recursively in closed form, and quite efficient implementations are available (Moschitti, 2006). Different TK functions are characterized by alternative fragment definitions, e.g. (Collins and Duffy, 2002) and (Kashima and Koyanagi, 2002). In the context of this paper we will be focusing on the SubSet Tree (SST) kernel described in (Collins and Duffy, 2002), which relies on a fragment definition that does not allow to break production rules (i.e. if any child of a node is included in a fragment, then also all the other children have to). As such, it is especially indicated for tasks involving constituency parsed texts. Implicitly, a TK function establishes a correspondence between distinct fragments and dimensions in some fragment space, i.e. the space of all Figure 1: Esemplification of a fragment space and the kernel product</context>
</contexts>
<marker>Kashima, Koyanagi, 2002</marker>
<rawString>Hisashi Kashima and Teruo Koyanagi. 2002. Kernels for semi-structured data. In Proceedings ofICML’02.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jun’ichi Kazama</author>
<author>Kentaro Torisawa</author>
</authors>
<title>Speeding up training with tree kernels for node relation labeling.</title>
<date>2005</date>
<booktitle>In Proceedings of HLT-EMNLP’05.</booktitle>
<contexts>
<context position="1686" citStr="Kazama and Torisawa, 2005" startWordPosition="250" endWordPosition="253">Machines (SVMs) for carrying out NLP tasks. Indeed, their appealing properties such as 1) solid theoretical foundations, 2) robustness to irrelevant features and 3) outperforming accuracy have been exploited to design state-of-the-art language applications. More recently, kernel functions, which implicitly represent data in some high dimensional space, have been employed to study and further improve many natural language systems, e.g. (Collins and Duffy, 2002), (Kudo and Matsumoto, 2003), (Cumby and Roth, 2003), (Cancedda et al., 2003), (Culotta and Sorensen, 2004), (Toutanova et al., 2004), (Kazama and Torisawa, 2005), (Shen et al., 2003), (Gliozzo et al., 2005), (Kudo et al., 2005), (Moschitti et al., 2008), (Diab et al., 2008). Unfortunately, the benefit to easily and effectively model the target linguistic phenomena is reduced by the the implicit nature of the kernel space, which prevents to directly observe the most relevant features. As a consequence, even very accurate models generally fail in providing useful feedback for improving our understanding of the problems at study. Moreover, the computational burden induced by high dimensional kernels makes the application of SVMs to large corpora still mo</context>
</contexts>
<marker>Kazama, Torisawa, 2005</marker>
<rawString>Jun’ichi Kazama and Kentaro Torisawa. 2005. Speeding up training with tree kernels for node relation labeling. In Proceedings of HLT-EMNLP’05.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Dan Klein</author>
<author>Christopher D Manning</author>
</authors>
<title>Accurate unlexicalized parsing.</title>
<date>2003</date>
<booktitle>In Proceedings of ACL’03,</booktitle>
<pages>423--430</pages>
<contexts>
<context position="26854" citStr="Klein and Manning, 2003" startWordPosition="4661" endWordPosition="4664">ies. We adopted the question taxonomy known as coarse grained, which has been described in (Zhang and Lee, 2003) and (Li and Roth, 2006), consisting of six non overlapping classes: Abbreviations (ABBR), Descriptions (DESC, e.g. definitions or explanations), Entity (ENTY, e.g. animal, body or color), Human (HUM, e.g. group or individual), Location (LOC, e.g. cities or countries) and Numeric (NUM, e.g. amounts or dates). For each question, we generate the full parse of the sentence and use it to train SST and (linearized) SSTℓ models. The automatic parses are obtained with the Stanford parser3 (Klein and Manning, 2003). We actually have only 5,483 sentences in our training set, due to parsing issues with a few of them. 2http://l2r.cs.uiuc.edu/cogcomp/Data/ QA/QC/ 3http://nlp.stanford.edu/software/ lex-parser.shtml Data set Accuracy Class Tr+ Te+ SST SSTℓ ABBR 89 9 80.0 87.5 DESC 1,164 138 96.0 94.5 ENTY 1,269 94 63.9 63.5 HUM 1,231 65 88.1 87.2 LOC 834 81 77.6 77.9 NUM 896 113 80.4 80.8 Overall 86.2 86.6 Table 2: Number of positive training (Tr+) and test (Te+) examples in the QA dataset. Accuracy of the non-linearized (SST) and linearized (SSTℓ) binary classifiers is F1 measure. Overall accuracy is the per</context>
</contexts>
<marker>Klein, Manning, 2003</marker>
<rawString>Dan Klein and Christopher D. Manning. 2003. Accurate unlexicalized parsing. In Proceedings of ACL’03, pages 423–430.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Taku Kudo</author>
<author>Yuji Matsumoto</author>
</authors>
<title>Fast methods for kernel-based text analysis.</title>
<date>2003</date>
<booktitle>In Proceedings ofACL’03.</booktitle>
<contexts>
<context position="1552" citStr="Kudo and Matsumoto, 2003" startWordPosition="230" endWordPosition="233">ing and question classification illustrate the above claims. 1 Introduction The last decade has seen a massive use of Support Vector Machines (SVMs) for carrying out NLP tasks. Indeed, their appealing properties such as 1) solid theoretical foundations, 2) robustness to irrelevant features and 3) outperforming accuracy have been exploited to design state-of-the-art language applications. More recently, kernel functions, which implicitly represent data in some high dimensional space, have been employed to study and further improve many natural language systems, e.g. (Collins and Duffy, 2002), (Kudo and Matsumoto, 2003), (Cumby and Roth, 2003), (Cancedda et al., 2003), (Culotta and Sorensen, 2004), (Toutanova et al., 2004), (Kazama and Torisawa, 2005), (Shen et al., 2003), (Gliozzo et al., 2005), (Kudo et al., 2005), (Moschitti et al., 2008), (Diab et al., 2008). Unfortunately, the benefit to easily and effectively model the target linguistic phenomena is reduced by the the implicit nature of the kernel space, which prevents to directly observe the most relevant features. As a consequence, even very accurate models generally fail in providing useful feedback for improving our understanding of the problems at</context>
<context position="15424" citStr="Kudo and Matsumoto, 2003" startWordPosition="2705" endWordPosition="2709"> and a linear kernel. 3.5 Explicit Space Classification (ESC) The linear model is used to classify linearized test data and evaluate the accuracy of the resulting classifier. 4 Previous work A rather comprehensive overview of feature selection techniques is carried out in (Guyon and Elisseeff, 2003). Non-filter approaches for SVMs and kernel machines are often concerned with polynomial and Gaussian kernels, e.g. (Weston et al., 2001) and (Neumann et al., 2005). Weston et al. (2003) use the ℓ0 norm in the SVM optimizer to stress the feature selection capabilities of the learning algorithm. In (Kudo and Matsumoto, 2003), an extension of the PrefixSpan algorithm (Pei et al., 2001) is used to efficiently mine the features in a low degree polynomial kernel space. The authors discuss an approximation of their method that allows them to handle high degree polynomial kernels. Suzuki and Isozaki (2005) present an embedded approach to feature selection for convolution kernels based on χ2-driven relevance assessment. To our knowledge, this is the only published work clearly focusing on feature selection for tree kernel functions, and indeed has been one of the major sources of inspiration for our methodology. With re</context>
</contexts>
<marker>Kudo, Matsumoto, 2003</marker>
<rawString>Taku Kudo and Yuji Matsumoto. 2003. Fast methods for kernel-based text analysis. In Proceedings ofACL’03.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Taku Kudo</author>
<author>Jun Suzuki</author>
<author>Hideki Isozaki</author>
</authors>
<title>Boostingbased parse reranking with subtree features.</title>
<date>2005</date>
<booktitle>In Proceedings ofACL’05.</booktitle>
<contexts>
<context position="1752" citStr="Kudo et al., 2005" startWordPosition="262" endWordPosition="265">ties such as 1) solid theoretical foundations, 2) robustness to irrelevant features and 3) outperforming accuracy have been exploited to design state-of-the-art language applications. More recently, kernel functions, which implicitly represent data in some high dimensional space, have been employed to study and further improve many natural language systems, e.g. (Collins and Duffy, 2002), (Kudo and Matsumoto, 2003), (Cumby and Roth, 2003), (Cancedda et al., 2003), (Culotta and Sorensen, 2004), (Toutanova et al., 2004), (Kazama and Torisawa, 2005), (Shen et al., 2003), (Gliozzo et al., 2005), (Kudo et al., 2005), (Moschitti et al., 2008), (Diab et al., 2008). Unfortunately, the benefit to easily and effectively model the target linguistic phenomena is reduced by the the implicit nature of the kernel space, which prevents to directly observe the most relevant features. As a consequence, even very accurate models generally fail in providing useful feedback for improving our understanding of the problems at study. Moreover, the computational burden induced by high dimensional kernels makes the application of SVMs to large corpora still more problematic. In (Pighin and Moschitti, 2009), we proposed a fea</context>
</contexts>
<marker>Kudo, Suzuki, Isozaki, 2005</marker>
<rawString>Taku Kudo, Jun Suzuki, and Hideki Isozaki. 2005. Boostingbased parse reranking with subtree features. In Proceedings ofACL’05.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Xin Li</author>
<author>Dan Roth</author>
</authors>
<title>Learning question classifiers: the role of semantic information.</title>
<date>2006</date>
<journal>Natural Language Engineering,</journal>
<volume>12</volume>
<issue>3</issue>
<contexts>
<context position="26366" citStr="Li and Roth, 2006" startWordPosition="4583" endWordPosition="4586">ut 160 thousand fragments. Of these, about 70 and 33 thousand encompass the candidate argument or the predicate node, respectively. About 16 thousand fragments contain both. 5.2 Question Classification For question classification we used the data set from the TREC 10 QA evaluation campaign2, consisting of 5,500 training and 500 test questions. 5.2.1 Setup Given a question, the QC task consists in selecting the most appropriate expected answer type from a given set of possibilities. We adopted the question taxonomy known as coarse grained, which has been described in (Zhang and Lee, 2003) and (Li and Roth, 2006), consisting of six non overlapping classes: Abbreviations (ABBR), Descriptions (DESC, e.g. definitions or explanations), Entity (ENTY, e.g. animal, body or color), Human (HUM, e.g. group or individual), Location (LOC, e.g. cities or countries) and Numeric (NUM, e.g. amounts or dates). For each question, we generate the full parse of the sentence and use it to train SST and (linearized) SSTℓ models. The automatic parses are obtained with the Stanford parser3 (Klein and Manning, 2003). We actually have only 5,483 sentences in our training set, due to parsing issues with a few of them. 2http://l</context>
</contexts>
<marker>Li, Roth, 2006</marker>
<rawString>Xin Li and Dan Roth. 2006. Learning question classifiers: the role of semantic information. Natural Language Engineering, 12(3):229–249.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Alessandro Moschitti</author>
<author>Fabio Massimo Zanzotto</author>
</authors>
<title>Fast and effective kernels for relational learning from texts.</title>
<date>2007</date>
<booktitle>In ICML’07.</booktitle>
<marker>Moschitti, Zanzotto, 2007</marker>
<rawString>Alessandro Moschitti and Fabio Massimo Zanzotto. 2007. Fast and effective kernels for relational learning from texts. In ICML’07.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Alessandro Moschitti</author>
<author>Silvia Quarteroni</author>
<author>Roberto Basili</author>
<author>Suresh Manandhar</author>
</authors>
<title>Exploiting syntactic and shallow semantic kernels for question/answer classification.</title>
<date>2007</date>
<booktitle>In Proceedings ofACL’07.</booktitle>
<contexts>
<context position="16723" citStr="Moschitti et al., 2007" startWordPosition="2917" endWordPosition="2921">xploit the SVM optimizer to select the most relevant features instead of a relevance assessment measure that moves from different statistical assumptions than the learning algorithm. In (Graf et al., 2004), an approach to SVM parallelization is presented which is based on a divide-et-impera strategy to reduce optimization time. The idea of using a compact graph representation to represent the support vectors of a TK function is explored in (Aiolli et al., 2006), where a Direct Acyclic Graph (DAG) is employed. In (Moschitti, 2006; Bloehdorn and Moschitti, 2007a; Bloehdorn and Moschitti, 2007b; Moschitti et al., 2007), the SST kernel along with other tree and combined kernels are employed for question classification and semantic role labeling with interesting results. 5 Experiments We evaluated the capability of our model to extract relevant features on two data sets: the CoNLL 2005 shared task on Semantic Role Labeling (SRL) (Carreras and M`arquez, 2005), and the Question Classification (QC) task based on data from the TREC 10 QA competition (Voorhees, 2001). The next sections will detail the setup and outcome of the two sets of experiments. All the experiments were run on a machine equipped with 4 Intel </context>
<context position="28534" citStr="Moschitti et al., 2007" startWordPosition="4949" endWordPosition="4952">h fragment space. 5.2.2 Results Table 2 shows the number of positive examples in the training and test set of each individual binary classifiers. Columns SST and SSTℓ compare the F1 measure of the vanilla and linearized classifiers on the individual classes, and the accuracy of the complete QC task (Row Overall) in terms of percentage of correct class assignments. Also in this case, we can notice that the accuracy of the linearized classifiers is always in line with nonlinearized ones, e.g. 86.6 vs. 86.2 for the multiclassifiers. These results are lower than those derived in (Moschitti, 2006; Moschitti et al., 2007), i.e. 88.2 and 90.4, respectively, where the parameters for each classifier were carefully optimized. QC Fragment space. Tables from 4 to 9 list the top fragments identified for each class 4. As expected, for all the categories the domain lexical information is very relevant. For example, film, color, book, novel and sport for ENTY or city, country, state and capital for LOC. Of the six classes, ENTY (Table 6) is mostly characterized by lexical features. Interestingly, function words, which would have been eliminated by a pure Information Retrieval approach (i.e. by means of 4Some categories </context>
<context position="30145" citStr="Moschitti et al., 2007" startWordPosition="5219" endWordPosition="5222">es appear in the top positions for each class, for example: (VP (VB (stand)) (PP)), which suggests that stand should be followed by a prepositional phrase to characterize ABBR; or (NP (NP (DT) (NN (abbreviation))) (PP)), which suggests that, to be in a relevant pattern, abbreviation should be preceded by an article and followed by a PP. Also, the syntactic structure is useful to differentiate the use of the same important words, e.g. (SBARQ (WHADVP (WRB (How))) (SQ) (.)) for DESC better characterizes the use of how with respect to NUM, in which a relevant use is (WHADJP (WRB (How)) (JJ)). In (Moschitti et al., 2007) it was shown that the use of TK improves QC of 1.2 percent points, i.e. from 90.6 to 91.8: further analysis of these fragments may help us to device compact, less sparse syntactic features and design more accurate models for the task. 6 Discussion The fact that our model doesn’t always improve the accuracy of a standard SST model might be related to the process of splitting training data and employing locally estimated weights during FMI. Concerning the experiments presented in this paper, this objection might apply to the results on SRL, where we used 50 splits to identify the most relevant </context>
</contexts>
<marker>Moschitti, Quarteroni, Basili, Manandhar, 2007</marker>
<rawString>Alessandro Moschitti, Silvia Quarteroni, Roberto Basili, and Suresh Manandhar. 2007. Exploiting syntactic and shallow semantic kernels for question/answer classification. In Proceedings ofACL’07.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Alessandro Moschitti</author>
<author>Daniele Pighin</author>
<author>Roberto Basili</author>
</authors>
<title>Tree kernels for semantic role labeling.</title>
<date>2008</date>
<journal>Computational Linguistics,</journal>
<volume>34</volume>
<issue>2</issue>
<contexts>
<context position="1778" citStr="Moschitti et al., 2008" startWordPosition="266" endWordPosition="269"> theoretical foundations, 2) robustness to irrelevant features and 3) outperforming accuracy have been exploited to design state-of-the-art language applications. More recently, kernel functions, which implicitly represent data in some high dimensional space, have been employed to study and further improve many natural language systems, e.g. (Collins and Duffy, 2002), (Kudo and Matsumoto, 2003), (Cumby and Roth, 2003), (Cancedda et al., 2003), (Culotta and Sorensen, 2004), (Toutanova et al., 2004), (Kazama and Torisawa, 2005), (Shen et al., 2003), (Gliozzo et al., 2005), (Kudo et al., 2005), (Moschitti et al., 2008), (Diab et al., 2008). Unfortunately, the benefit to easily and effectively model the target linguistic phenomena is reduced by the the implicit nature of the kernel space, which prevents to directly observe the most relevant features. As a consequence, even very accurate models generally fail in providing useful feedback for improving our understanding of the problems at study. Moreover, the computational burden induced by high dimensional kernels makes the application of SVMs to large corpora still more problematic. In (Pighin and Moschitti, 2009), we proposed a feature extraction algorithm </context>
<context position="19203" citStr="Moschitti et al., 2008" startWordPosition="3332" endWordPosition="3335">the proper role. The former task requires a binary Boundary Classifier (BC), whereas the second involves a Role Multi-class Classifier (RM). 5.1.1 Setup If the constituency parse tree t of a sentence s is available, we can look at all the pairs (p, nz), where nz is any node in the tree and p is the node dominating w, and decide whether nz is an argument node or not, i.e. whether it exactly dominates all and only the words encoding any of w’s arguments. The objects that we classify are subsets of the input parse tree that encompass both p and nz. Namely, we use the AST,,, structure defined in (Moschitti et al., 2008), which is the minimal tree that covers all and only the words of p and nz. In the AST,,,, p and nz are marked so that they can be distinguished from the other nodes. An AST,,, is regarded as a positive example for BC if nz is an argument node, otherwise it is considered a negative example. Positive BC examples can be used to train an efficient RM: for each role r we can train a classifier whose positive examples are argument nodes whose label is exactly r, whereas negative examples are argument nodes labeled r′ =� r. Two AST,,,s extracted from an example parse tree are shown in Figure 2: the </context>
</contexts>
<marker>Moschitti, Pighin, Basili, 2008</marker>
<rawString>Alessandro Moschitti, Daniele Pighin, and Roberto Basili. 2008. Tree kernels for semantic role labeling. Computational Linguistics, 34(2):193–224.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Alessandro Moschitti</author>
</authors>
<title>Efficient convolution kernels for dependency and constituent syntactic trees.</title>
<date>2006</date>
<booktitle>In Proceedings of ECML’06,</booktitle>
<pages>318--329</pages>
<contexts>
<context position="5388" citStr="Moschitti, 2006" startWordPosition="863" endWordPosition="864">s possible to replace the scalar product with a kernel function defined over pairs of objects: n f(o) = αiyik(oi, o) + b i=1 with the advantage that we do not need to provide an explicit mapping 0(·) of our examples in a vector space. A Tree Kernel function is a convolution kernel (Haussler, 1999) defined over pairs of trees. Practically speaking, the kernel between two trees evaluates the number of substructures (or fragments) they have in common, i.e. it is a measure of their overlap. The function can be computed recursively in closed form, and quite efficient implementations are available (Moschitti, 2006). Different TK functions are characterized by alternative fragment definitions, e.g. (Collins and Duffy, 2002) and (Kashima and Koyanagi, 2002). In the context of this paper we will be focusing on the SubSet Tree (SST) kernel described in (Collins and Duffy, 2002), which relies on a fragment definition that does not allow to break production rules (i.e. if any child of a node is included in a fragment, then also all the other children have to). As such, it is especially indicated for tasks involving constituency parsed texts. Implicitly, a TK function establishes a correspondence between disti</context>
<context position="16634" citStr="Moschitti, 2006" startWordPosition="2907" endWordPosition="2908">th respect to their work, the difference 114 in our approach is that we want to exploit the SVM optimizer to select the most relevant features instead of a relevance assessment measure that moves from different statistical assumptions than the learning algorithm. In (Graf et al., 2004), an approach to SVM parallelization is presented which is based on a divide-et-impera strategy to reduce optimization time. The idea of using a compact graph representation to represent the support vectors of a TK function is explored in (Aiolli et al., 2006), where a Direct Acyclic Graph (DAG) is employed. In (Moschitti, 2006; Bloehdorn and Moschitti, 2007a; Bloehdorn and Moschitti, 2007b; Moschitti et al., 2007), the SST kernel along with other tree and combined kernels are employed for question classification and semantic role labeling with interesting results. 5 Experiments We evaluated the capability of our model to extract relevant features on two data sets: the CoNLL 2005 shared task on Semantic Role Labeling (SRL) (Carreras and M`arquez, 2005), and the Question Classification (QC) task based on data from the TREC 10 QA competition (Voorhees, 2001). The next sections will detail the setup and outcome of the </context>
<context position="28509" citStr="Moschitti, 2006" startWordPosition="4947" endWordPosition="4948">to generate a rich fragment space. 5.2.2 Results Table 2 shows the number of positive examples in the training and test set of each individual binary classifiers. Columns SST and SSTℓ compare the F1 measure of the vanilla and linearized classifiers on the individual classes, and the accuracy of the complete QC task (Row Overall) in terms of percentage of correct class assignments. Also in this case, we can notice that the accuracy of the linearized classifiers is always in line with nonlinearized ones, e.g. 86.6 vs. 86.2 for the multiclassifiers. These results are lower than those derived in (Moschitti, 2006; Moschitti et al., 2007), i.e. 88.2 and 90.4, respectively, where the parameters for each classifier were carefully optimized. QC Fragment space. Tables from 4 to 9 list the top fragments identified for each class 4. As expected, for all the categories the domain lexical information is very relevant. For example, film, color, book, novel and sport for ENTY or city, country, state and capital for LOC. Of the six classes, ENTY (Table 6) is mostly characterized by lexical features. Interestingly, function words, which would have been eliminated by a pure Information Retrieval approach (i.e. by m</context>
</contexts>
<marker>Moschitti, 2006</marker>
<rawString>Alessandro Moschitti. 2006. Efficient convolution kernels for dependency and constituent syntactic trees. In Proceedings of ECML’06, pages 318–329.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Julia Neumann</author>
<author>Christoph Schnorr</author>
<author>Gabriele Steidl</author>
</authors>
<date>2005</date>
<booktitle>Combined SVM-Based Feature Selection and Classification. Machine Learning,</booktitle>
<pages>61--1</pages>
<contexts>
<context position="15263" citStr="Neumann et al., 2005" startWordPosition="2677" endWordPosition="2680"> and the fragments they encode. 3.4 Explicit Space Learning (ESL) Linearized training data is used to learn a very fast model by using all the available data and a linear kernel. 3.5 Explicit Space Classification (ESC) The linear model is used to classify linearized test data and evaluate the accuracy of the resulting classifier. 4 Previous work A rather comprehensive overview of feature selection techniques is carried out in (Guyon and Elisseeff, 2003). Non-filter approaches for SVMs and kernel machines are often concerned with polynomial and Gaussian kernels, e.g. (Weston et al., 2001) and (Neumann et al., 2005). Weston et al. (2003) use the ℓ0 norm in the SVM optimizer to stress the feature selection capabilities of the learning algorithm. In (Kudo and Matsumoto, 2003), an extension of the PrefixSpan algorithm (Pei et al., 2001) is used to efficiently mine the features in a low degree polynomial kernel space. The authors discuss an approximation of their method that allows them to handle high degree polynomial kernels. Suzuki and Isozaki (2005) present an embedded approach to feature selection for convolution kernels based on χ2-driven relevance assessment. To our knowledge, this is the only publish</context>
</contexts>
<marker>Neumann, Schnorr, Steidl, 2005</marker>
<rawString>Julia Neumann, Christoph Schnorr, and Gabriele Steidl. 2005. Combined SVM-Based Feature Selection and Classification. Machine Learning, 61(1-3):129–150.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Martha Palmer</author>
<author>Daniel Gildea</author>
<author>Paul Kingsbury</author>
</authors>
<title>The proposition bank: An annotated corpus of semantic roles.</title>
<date>2005</date>
<journal>Comput. Linguist.,</journal>
<volume>31</volume>
<issue>1</issue>
<contexts>
<context position="18149" citStr="Palmer et al., 2005" startWordPosition="3154" endWordPosition="3157">ation task, we compare the accuracy of a vanilla SST classifier against the corresponding linearized SST classifier (SSTs). For KSL and SST training we used the default decay factor A = 0.4. For ESL, we use a non-normalized, linear kernel. No further parametrization of the learning algorithms is carried out. Indeed, our focus is on showing that, under the same conditions, our linearized tree kernel can be as accurate as the original kernel, and choosing of parameters may just bias such test. 5.1 Semantic Role Labeling For our experiments on semantic role labeling we used PropBank annotations (Palmer et al., 2005) 1http://disi.unitn.it/˜moschitt/ Tree-Kernel.htm Figure 2: Examples of AST,,, structured features. and automatic Charniak parse trees (Charniak, 2000) as provided for the CoNLL 2005 evaluation campaign (Carreras and M`arquez, 2005). SRL can be decomposed into two tasks: boundary detection, where the word sequences that are arguments of a predicate word w are identified, and role classification, where each argument is assigned the proper role. The former task requires a binary Boundary Classifier (BC), whereas the second involves a Role Multi-class Classifier (RM). 5.1.1 Setup If the constitue</context>
</contexts>
<marker>Palmer, Gildea, Kingsbury, 2005</marker>
<rawString>Martha Palmer, Daniel Gildea, and Paul Kingsbury. 2005. The proposition bank: An annotated corpus of semantic roles. Comput. Linguist., 31(1):71–106.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Pei</author>
<author>J Han</author>
<author>Mortazavi B Asl</author>
<author>H Pinto</author>
<author>Q Chen</author>
<author>U Dayal</author>
<author>M C Hsu</author>
</authors>
<title>PrefixSpan Mining Sequential Patterns Efficiently by Prefix Projected Pattern Growth.</title>
<date>2001</date>
<booktitle>In Proceedings ofICDE’01.</booktitle>
<contexts>
<context position="15485" citStr="Pei et al., 2001" startWordPosition="2717" endWordPosition="2720">ear model is used to classify linearized test data and evaluate the accuracy of the resulting classifier. 4 Previous work A rather comprehensive overview of feature selection techniques is carried out in (Guyon and Elisseeff, 2003). Non-filter approaches for SVMs and kernel machines are often concerned with polynomial and Gaussian kernels, e.g. (Weston et al., 2001) and (Neumann et al., 2005). Weston et al. (2003) use the ℓ0 norm in the SVM optimizer to stress the feature selection capabilities of the learning algorithm. In (Kudo and Matsumoto, 2003), an extension of the PrefixSpan algorithm (Pei et al., 2001) is used to efficiently mine the features in a low degree polynomial kernel space. The authors discuss an approximation of their method that allows them to handle high degree polynomial kernels. Suzuki and Isozaki (2005) present an embedded approach to feature selection for convolution kernels based on χ2-driven relevance assessment. To our knowledge, this is the only published work clearly focusing on feature selection for tree kernel functions, and indeed has been one of the major sources of inspiration for our methodology. With respect to their work, the difference 114 in our approach is th</context>
</contexts>
<marker>Pei, Han, Asl, Pinto, Chen, Dayal, Hsu, 2001</marker>
<rawString>J. Pei, J. Han, Mortazavi B. Asl, H. Pinto, Q. Chen, U. Dayal, and M. C. Hsu. 2001. PrefixSpan Mining Sequential Patterns Efficiently by Prefix Projected Pattern Growth. In Proceedings ofICDE’01.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Daniele Pighin</author>
<author>Alessandro Moschitti</author>
</authors>
<title>Efficient linearization of tree kernel functions.</title>
<date>2009</date>
<booktitle>In Proceedings of CoNLL’09.</booktitle>
<contexts>
<context position="2333" citStr="Pighin and Moschitti, 2009" startWordPosition="354" endWordPosition="357">), (Gliozzo et al., 2005), (Kudo et al., 2005), (Moschitti et al., 2008), (Diab et al., 2008). Unfortunately, the benefit to easily and effectively model the target linguistic phenomena is reduced by the the implicit nature of the kernel space, which prevents to directly observe the most relevant features. As a consequence, even very accurate models generally fail in providing useful feedback for improving our understanding of the problems at study. Moreover, the computational burden induced by high dimensional kernels makes the application of SVMs to large corpora still more problematic. In (Pighin and Moschitti, 2009), we proposed a feature extraction algorithm for Tree Kernel (TK) spaces, which selects the most relevant features (tree fragments) according to the gradient components (weight vector) of the hyperplane learnt by an SVM, in line with current research, e.g. (Rakotomamonjy, 2003; Weston et al., 2003; Kudo and Matsumoto, 2003). In particular, we provided algorithmic solutions to deal with the huge dimensionality and, consequently, high computational complexity of the fragment space. Our experimental results showed that our approach reduces learning and classification processing time leaving the a</context>
<context position="12835" citStr="Pighin and Moschitti, 2009" startWordPosition="2264" endWordPosition="2267">d. In the algorithm, Nt is the set of nodes of the tree t; BEST(L) returns the L highest ranked fragments in the index; CHANGED() verifies whether the bottom of the L-best set has been affected by the last iteration or not. We call MINE MODEL(·) on each of the models Ms that we learnt from the S initial splits. For each model, the function returns the set of L-best fragments in the model. The union of all the fragments harvested from each model is then saved into a dictionary DL which will be used by the next stage. 3.2.1 Discussion on FNH algorithm With respect to the algorithm presented in (Pighin and Moschitti, 2009), the one presented here has the following advantages: • the process of building fragments is strictly small-to-large: fragments that span n+1 levels of the tree may be generated only after all those spanning n levels; • the threshold value L is a parameter of the mining process, and it is used to prevent the algorithm from generating more fragments than necessary, thus making it more efficient; • it has one less parameter (maxdepth) which was used to force fragments to span at-most a given number of levels. The new algorithm does not need it since the maximum number of iterations is implicitl</context>
</contexts>
<marker>Pighin, Moschitti, 2009</marker>
<rawString>Daniele Pighin and Alessandro Moschitti. 2009. Efficient linearization of tree kernel functions. In Proceedings of CoNLL’09.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Alain Rakotomamonjy</author>
</authors>
<title>Variable selection using SVM based criteria.</title>
<date>2003</date>
<journal>Journal of Machine Learning Research,</journal>
<pages>3--1357</pages>
<contexts>
<context position="2610" citStr="Rakotomamonjy, 2003" startWordPosition="398" endWordPosition="400">ost relevant features. As a consequence, even very accurate models generally fail in providing useful feedback for improving our understanding of the problems at study. Moreover, the computational burden induced by high dimensional kernels makes the application of SVMs to large corpora still more problematic. In (Pighin and Moschitti, 2009), we proposed a feature extraction algorithm for Tree Kernel (TK) spaces, which selects the most relevant features (tree fragments) according to the gradient components (weight vector) of the hyperplane learnt by an SVM, in line with current research, e.g. (Rakotomamonjy, 2003; Weston et al., 2003; Kudo and Matsumoto, 2003). In particular, we provided algorithmic solutions to deal with the huge dimensionality and, consequently, high computational complexity of the fragment space. Our experimental results showed that our approach reduces learning and classification processing time leaving the accuracy unchanged. In this paper, we present a new version of such algorithm which, under the same parameterization, is almost three times as fast while producing the same results. Most importantly, we explored tree fragment spaces for two interesting natural language tasks: S</context>
</contexts>
<marker>Rakotomamonjy, 2003</marker>
<rawString>Alain Rakotomamonjy. 2003. Variable selection using SVM based criteria. Journal of Machine Learning Research, 3:1357–1370.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Libin Shen</author>
<author>Anoop Sarkar</author>
<author>Aravind k Joshi</author>
</authors>
<title>Using LTAG Based Features in Parse Reranking.</title>
<date>2003</date>
<booktitle>In Proceedings of EMNLP’06.</booktitle>
<contexts>
<context position="1707" citStr="Shen et al., 2003" startWordPosition="254" endWordPosition="257">out NLP tasks. Indeed, their appealing properties such as 1) solid theoretical foundations, 2) robustness to irrelevant features and 3) outperforming accuracy have been exploited to design state-of-the-art language applications. More recently, kernel functions, which implicitly represent data in some high dimensional space, have been employed to study and further improve many natural language systems, e.g. (Collins and Duffy, 2002), (Kudo and Matsumoto, 2003), (Cumby and Roth, 2003), (Cancedda et al., 2003), (Culotta and Sorensen, 2004), (Toutanova et al., 2004), (Kazama and Torisawa, 2005), (Shen et al., 2003), (Gliozzo et al., 2005), (Kudo et al., 2005), (Moschitti et al., 2008), (Diab et al., 2008). Unfortunately, the benefit to easily and effectively model the target linguistic phenomena is reduced by the the implicit nature of the kernel space, which prevents to directly observe the most relevant features. As a consequence, even very accurate models generally fail in providing useful feedback for improving our understanding of the problems at study. Moreover, the computational burden induced by high dimensional kernels makes the application of SVMs to large corpora still more problematic. In (P</context>
</contexts>
<marker>Shen, Sarkar, Joshi, 2003</marker>
<rawString>Libin Shen, Anoop Sarkar, and Aravind k. Joshi. 2003. Using LTAG Based Features in Parse Reranking. In Proceedings of EMNLP’06.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jun Suzuki</author>
<author>Hideki Isozaki</author>
</authors>
<title>Sequence and Tree Kernels with Statistical Feature Mining.</title>
<date>2005</date>
<booktitle>In Proceedings ofNIPS’05.</booktitle>
<contexts>
<context position="15705" citStr="Suzuki and Isozaki (2005)" startWordPosition="2753" endWordPosition="2756">nd Elisseeff, 2003). Non-filter approaches for SVMs and kernel machines are often concerned with polynomial and Gaussian kernels, e.g. (Weston et al., 2001) and (Neumann et al., 2005). Weston et al. (2003) use the ℓ0 norm in the SVM optimizer to stress the feature selection capabilities of the learning algorithm. In (Kudo and Matsumoto, 2003), an extension of the PrefixSpan algorithm (Pei et al., 2001) is used to efficiently mine the features in a low degree polynomial kernel space. The authors discuss an approximation of their method that allows them to handle high degree polynomial kernels. Suzuki and Isozaki (2005) present an embedded approach to feature selection for convolution kernels based on χ2-driven relevance assessment. To our knowledge, this is the only published work clearly focusing on feature selection for tree kernel functions, and indeed has been one of the major sources of inspiration for our methodology. With respect to their work, the difference 114 in our approach is that we want to exploit the SVM optimizer to select the most relevant features instead of a relevance assessment measure that moves from different statistical assumptions than the learning algorithm. In (Graf et al., 2004)</context>
</contexts>
<marker>Suzuki, Isozaki, 2005</marker>
<rawString>Jun Suzuki and Hideki Isozaki. 2005. Sequence and Tree Kernels with Statistical Feature Mining. In Proceedings ofNIPS’05.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kristina Toutanova</author>
<author>Penka Markova</author>
<author>Christopher Manning</author>
</authors>
<title>The Leaf Path Projection View of Parse Trees: Exploring String Kernels for HPSG Parse Selection.</title>
<date>2004</date>
<booktitle>In Proceedings ofEMNLP</booktitle>
<contexts>
<context position="1657" citStr="Toutanova et al., 2004" startWordPosition="246" endWordPosition="249">ive use of Support Vector Machines (SVMs) for carrying out NLP tasks. Indeed, their appealing properties such as 1) solid theoretical foundations, 2) robustness to irrelevant features and 3) outperforming accuracy have been exploited to design state-of-the-art language applications. More recently, kernel functions, which implicitly represent data in some high dimensional space, have been employed to study and further improve many natural language systems, e.g. (Collins and Duffy, 2002), (Kudo and Matsumoto, 2003), (Cumby and Roth, 2003), (Cancedda et al., 2003), (Culotta and Sorensen, 2004), (Toutanova et al., 2004), (Kazama and Torisawa, 2005), (Shen et al., 2003), (Gliozzo et al., 2005), (Kudo et al., 2005), (Moschitti et al., 2008), (Diab et al., 2008). Unfortunately, the benefit to easily and effectively model the target linguistic phenomena is reduced by the the implicit nature of the kernel space, which prevents to directly observe the most relevant features. As a consequence, even very accurate models generally fail in providing useful feedback for improving our understanding of the problems at study. Moreover, the computational burden induced by high dimensional kernels makes the application of S</context>
</contexts>
<marker>Toutanova, Markova, Manning, 2004</marker>
<rawString>Kristina Toutanova, Penka Markova, and Christopher Manning. 2004. The Leaf Path Projection View of Parse Trees: Exploring String Kernels for HPSG Parse Selection. In Proceedings ofEMNLP 2004.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Vladimir N Vapnik</author>
</authors>
<title>Statistical Learning Theory.</title>
<date>1998</date>
<publisher>Wiley-Interscience.</publisher>
<contexts>
<context position="7709" citStr="Vapnik, 1998" startWordPosition="1255" endWordPosition="1256">ill only consider the fragments encoded by the support vectors of the 5 models. In the next stage, we will use the SVM estimated weights to drive our feature selection process. Since time complexity of SVM training is approximately quadratic in the number of examples, by breaking training data into smaller sets we can considerably accelerate the process of filtering trees and estimating support vector weights. According to statistical learning theory, being trained on smaller subsets of the available data these models will be less robust with respect to the minimization of the empirical risk (Vapnik, 1998). K(T1, T2) = (φ(T1), φ(T2)) = 1 C A A B A B A B A T1 1 2 3 4 5 6 7 A B A C A B A B A C Fragment space A C B A D D B A C T2 A B A B A φ(T1) = [2, 1, 1, 1, 1, 0, 0] B φ(T2) = [0, 0, 0, 0, 1, 1, 1] D A C 112 Algorithm 3.1: MINE MODEL(M, L, A) global maxexp prev +— 0 ; CLEAR INDEX() for each (αy, t) G M  Ti +— α · y/IItII for each n G Art (f +— FRAG(n) ; rel = A · Ti do  do prev +— prev U {f, rel} PUT(f, rel) best pr +— BEST(L) ; while true next +— 0 for each (f, rel) G prev if f G best pr FL +— best pr return (FL) Nonetheless, since we do not need to employ them for classification (but ju</context>
</contexts>
<marker>Vapnik, 1998</marker>
<rawString>Vladimir N. Vapnik. 1998. Statistical Learning Theory. Wiley-Interscience.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ellen M Voorhees</author>
</authors>
<title>Overview of the trec</title>
<date>2001</date>
<booktitle>In Proceedings of the Tenth Text REtrieval Conference (TREC,</booktitle>
<pages>42--51</pages>
<contexts>
<context position="17173" citStr="Voorhees, 2001" startWordPosition="2993" endWordPosition="2994">, 2006), where a Direct Acyclic Graph (DAG) is employed. In (Moschitti, 2006; Bloehdorn and Moschitti, 2007a; Bloehdorn and Moschitti, 2007b; Moschitti et al., 2007), the SST kernel along with other tree and combined kernels are employed for question classification and semantic role labeling with interesting results. 5 Experiments We evaluated the capability of our model to extract relevant features on two data sets: the CoNLL 2005 shared task on Semantic Role Labeling (SRL) (Carreras and M`arquez, 2005), and the Question Classification (QC) task based on data from the TREC 10 QA competition (Voorhees, 2001). The next sections will detail the setup and outcome of the two sets of experiments. All the experiments were run on a machine equipped with 4 Intel ® Xeon® CPUs clocked at 1.6 GHz and 4 GB of RAM. As a supervised learning framework we used SVM-Light-TK1, which extends the SVM-Light optimizer (Joachims, 2000) with tree kernel support. For each classification task, we compare the accuracy of a vanilla SST classifier against the corresponding linearized SST classifier (SSTs). For KSL and SST training we used the default decay factor A = 0.4. For ESL, we use a non-normalized, linear kernel. No f</context>
</contexts>
<marker>Voorhees, 2001</marker>
<rawString>Ellen M. Voorhees. 2001. Overview of the trec 2001 question answering track. In In Proceedings of the Tenth Text REtrieval Conference (TREC, pages 42–51.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jason Weston</author>
<author>Sayan Mukherjee</author>
<author>Olivier Chapelle</author>
<author>Massimiliano Pontil</author>
<author>Tomaso Poggio</author>
<author>Vladimir Vapnik</author>
</authors>
<title>Feature Selection for SVMs.</title>
<date>2001</date>
<booktitle>In Proceedings ofNIPS’01.</booktitle>
<contexts>
<context position="15236" citStr="Weston et al., 2001" startWordPosition="2672" endWordPosition="2675"> between the input vectors and the fragments they encode. 3.4 Explicit Space Learning (ESL) Linearized training data is used to learn a very fast model by using all the available data and a linear kernel. 3.5 Explicit Space Classification (ESC) The linear model is used to classify linearized test data and evaluate the accuracy of the resulting classifier. 4 Previous work A rather comprehensive overview of feature selection techniques is carried out in (Guyon and Elisseeff, 2003). Non-filter approaches for SVMs and kernel machines are often concerned with polynomial and Gaussian kernels, e.g. (Weston et al., 2001) and (Neumann et al., 2005). Weston et al. (2003) use the ℓ0 norm in the SVM optimizer to stress the feature selection capabilities of the learning algorithm. In (Kudo and Matsumoto, 2003), an extension of the PrefixSpan algorithm (Pei et al., 2001) is used to efficiently mine the features in a low degree polynomial kernel space. The authors discuss an approximation of their method that allows them to handle high degree polynomial kernels. Suzuki and Isozaki (2005) present an embedded approach to feature selection for convolution kernels based on χ2-driven relevance assessment. To our knowledg</context>
</contexts>
<marker>Weston, Mukherjee, Chapelle, Pontil, Poggio, Vapnik, 2001</marker>
<rawString>Jason Weston, Sayan Mukherjee, Olivier Chapelle, Massimiliano Pontil, Tomaso Poggio, and Vladimir Vapnik. 2001. Feature Selection for SVMs. In Proceedings ofNIPS’01.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jason Weston</author>
<author>Andr´e Elisseeff</author>
<author>Bernhard Sch¨olkopf</author>
<author>Mike Tipping</author>
</authors>
<title>Use of the zero norm with linear models and kernel methods.</title>
<date>2003</date>
<journal>J. Mach. Learn. Res.,</journal>
<pages>3--1439</pages>
<marker>Weston, Elisseeff, Sch¨olkopf, Tipping, 2003</marker>
<rawString>Jason Weston, Andr´e Elisseeff, Bernhard Sch¨olkopf, and Mike Tipping. 2003. Use of the zero norm with linear models and kernel methods. J. Mach. Learn. Res., 3:1439–1461.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Dell Zhang</author>
<author>Wee Sun Lee</author>
</authors>
<title>Question classification using support vector machines.</title>
<date>2003</date>
<booktitle>In Proceedings of SIGIR’03,</booktitle>
<pages>26--32</pages>
<contexts>
<context position="26342" citStr="Zhang and Lee, 2003" startWordPosition="4578" endWordPosition="4581"> model for BC contains about 160 thousand fragments. Of these, about 70 and 33 thousand encompass the candidate argument or the predicate node, respectively. About 16 thousand fragments contain both. 5.2 Question Classification For question classification we used the data set from the TREC 10 QA evaluation campaign2, consisting of 5,500 training and 500 test questions. 5.2.1 Setup Given a question, the QC task consists in selecting the most appropriate expected answer type from a given set of possibilities. We adopted the question taxonomy known as coarse grained, which has been described in (Zhang and Lee, 2003) and (Li and Roth, 2006), consisting of six non overlapping classes: Abbreviations (ABBR), Descriptions (DESC, e.g. definitions or explanations), Entity (ENTY, e.g. animal, body or color), Human (HUM, e.g. group or individual), Location (LOC, e.g. cities or countries) and Numeric (NUM, e.g. amounts or dates). For each question, we generate the full parse of the sentence and use it to train SST and (linearized) SSTℓ models. The automatic parses are obtained with the Stanford parser3 (Klein and Manning, 2003). We actually have only 5,483 sentences in our training set, due to parsing issues with </context>
</contexts>
<marker>Zhang, Lee, 2003</marker>
<rawString>Dell Zhang and Wee Sun Lee. 2003. Question classification using support vector machines. In Proceedings of SIGIR’03, pages 26–32.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>