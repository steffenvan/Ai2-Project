<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<title confidence="0.968339">
Coreference handling in XMG
</title>
<author confidence="0.780557">
Claire Gardent
</author>
<affiliation confidence="0.405711">
CNRS/LORIA
</affiliation>
<address confidence="0.468351666666667">
615, rue du jardin botanique, B.P. 101
54602 Villers l`es Nancy CEDEX
France
</address>
<email confidence="0.98181">
Claire.Gardent@loria.fr
</email>
<author confidence="0.45097">
Yannick Parmentier
</author>
<affiliation confidence="0.273154">
INRIA Lorraine
</affiliation>
<address confidence="0.475399666666667">
615, rue du jardin botanique, B.P. 101
54602 Villers l`es Nancy CEDEX
France
</address>
<email confidence="0.99023">
Yannick.Parmentier@loria.fr
</email>
<sectionHeader confidence="0.99722" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999819125">
We claim that existing specification lan-
guages for tree based grammars fail to
adequately support identifier managment.
We then show that XMG (eXtensible Meta-
Grammar) provides a sophisticated treat-
ment of identifiers which is effective in
supporting a linguist-friendly grammar de-
sign.
</bodyText>
<sectionHeader confidence="0.703479" genericHeader="method">
1 Specifying tree-based grammars
</sectionHeader>
<bodyText confidence="0.999174969230769">
Whilst the development of standard unification-
based grammars is well supported by the design of
formalisms such as PATR-II, Ale or TDL (Krieger
and Schafer, 1994), the situation is less well es-
tablished for Tree-Based Grammars such as Tree
Adjoining Grammars (Joshi and Schabes, 1997),
Tree Description Grammars (Kallmeyer, 1996) or
Interaction Grammars (Perrier, 2003).
Roughly, two main types of specification for-
malism for Tree-Based Grammars can be distin-
guished: formalisms based on tree fragments and
non monotonic inheritance and formalisms based
on tree descriptions and monotonic inheritance.
The tree fragment approach is advocated in
(Evans et al., 1995) which proposes to encode lex-
icalised TAGs using the DATR representation lan-
guage&apos;. In this approach, tree fragments are com-
bined within a non monotonic inheritance hierar-
chy. Furthermore, new fragments can be derived
from existing ones by means of lexical rules. This
first approach suffers from the procedural char-
acter of non-monotonic inheritance. In specify-
ing the grammar, the grammar writer must keep
&apos;A tree based approach is also used in(Becker, 2000) but
this time in combination with metarules. In that particular
approach, procedural aspects also come into play as the order
in which metarules apply affect the results.
in mind the order in which non-monotonic state-
ments have been made so as to be able to pre-
dict how explicit statements interact with defaults
and non-monotonic inheritance in determining the
final output. When developing a large coverage
grammar, this rapidly become extremely cumber-
some. Moreover, as (Candito, 1996) remarks, non-
monotonicity may result in an information loss
which makes it impossible to express the relation
existing for instance between an active object and
the corresponding passive subject.
The approach based on tree descriptions (of-
ten called, the metagrammar approach) obviates
the procedural character of the non-monotonic
approach by taking tree descriptions rather than
trees to be the basic units (Candito, 1996; Xia et
al., 1999; Vijay-Shanker and Schabes, 1992). In
essence, tree fragments are described using tree
descriptions and tree descriptions are combined
through conjunction or inheritance. The idea is
that the minimal models satisfying the resulting
descriptions are TAG elementary trees. In some
cases, lexical rules are also used to derive new
trees from existing ones.
One main drawback with this second type of
approach concerns the management of node iden-
tifiers. Either nodes are represented by name-
less variables and node identification is forced by
well-formedness constraints e.g., wff-constraints
on trees and wff-constraints given by the input
tree description (cf. e.g., (Duchier and Gardent,
1999)) or nodes are named and nodes with iden-
tical names are forced to denote the same entity.
The first option is unrealistic when developing a
large core grammar as it is easy to omit a neces-
sary constraint and thereby permit overgeneration
(the description will be satisfied by more trees than
intended). The second option greatly degrades
</bodyText>
<page confidence="0.966073">
247
</page>
<note confidence="0.722729">
Proceedings of the COLING/ACL 2006 Main Conference Poster Sessions, pages 247–254,
Sydney, July 2006. c�2006 Association for Computational Linguistics
</note>
<bodyText confidence="0.999981096774193">
modularity as the grammar writer must remem-
ber which names were used where and with which
interpretation. As we shall see below, it also has
the undesirable effect that the same tree fragment
cannot be used twice in a given tree description.
Nevertheless, this is the option that is adopted in
most grammar formalisms and grammar compil-
ers (Candito, 1996; Xia et al., 1999; Gaiffe et al.,
2002).
In this paper, we present an approach which
remedies these shortcomings by combining mono-
tonic inheritance of tree descriptions with an ex-
plicit management of identifier scope and identi-
fiers equality2. The proposed approach thus es-
chews both the inconvenients induced by a non
monotonic framework (by using tree descriptions
rather than trees) and those resulting from a global
treatment of identifiers (by providing greater ex-
pressivity wrt identifiers).
Specifically, we show that the proposed ap-
proach supports several ways of identifying (node
or feature) values, we motivate this multiplicity
and we identify the linguistic and/or technical cri-
teria for choosing among the various possibilities.
The paper starts in section 2 by introducing the
syntax of the XMG formalism. In section 3, we
show that XMG provides four different ways of
identifying two (node or variable) identifiers. In
section 4, we motivate each of these four differ-
ent ways and indicate when each of them can and
should be used.
</bodyText>
<sectionHeader confidence="0.962661" genericHeader="method">
2 The XMG formalism
</sectionHeader>
<bodyText confidence="0.999938">
We start by briefly introducing XMG (eXtended
MetaGrammar). First, we show that it supports the
description and the combination of blocks consist-
ing of tree fragments and/or semantic representa-
tions. Then, we show that it supports a sophisti-
cated treatment of identifiers.
</bodyText>
<subsectionHeader confidence="0.99473">
2.1 Defining blocks
</subsectionHeader>
<bodyText confidence="0.993094222222222">
At the syntactic level, the basic units are tree de-
scriptions which are specified using the following
tree logic:
2Recently, (Villemonte de la Clergerie, 2005) has pro-
posed a highly compact representation formalism for tree-
based grammars which also features explicit identifier man-
agement. His approach differs from ours in that it includes
neither a colouring mechanism (cf. section 3.4) nor interfaces
(cf. section 3.3).
</bodyText>
<equation confidence="0.941335">
Description ::= x --+ y  |x --++ y  |x --+* y  |(1)
x � y  |x +y  |x �* y |
x[f:El  |x = y |
Description n Description
</equation>
<bodyText confidence="0.999831846153846">
where x, y represent node variables, —* immediate
dominance (x is directly above y), —*+ strict dom-
inance (x is above y), and —** large dominance3
(x is above or equal to y). Similarly � denotes
immediate precedence, �+ strict precedence, and
--&lt;* large precedence. Finally x[f:E] constrains
feature f with associated expression E on node
x, and x = y indicates node identification.
The XMG formalism also supports the associa-
tion of semantic representations with elementary
trees. The semantic representation language is a
flat semantic representation language (Bos, 1995)
with the following syntax:
</bodyText>
<equation confidence="0.900177666666667">
Description ::= f:p(E1, ..., Ems) |
-f:p(E1, ..., E+)  |Ei « Ej (2)
Description n Description
</equation>
<bodyText confidence="0.99938125">
where E is a label, p is a predicate and E1,.., En
are parameters. Further, -, denotes negation and
Ei « Ej expresses a scope constraint between Ei
and Ej (Ej is in the scope of Ei).
</bodyText>
<subsectionHeader confidence="0.999671">
2.2 Combining blocks
</subsectionHeader>
<bodyText confidence="0.984353833333333">
As in other existing tree-based formalisms, in
XMG, blocks can be combined using inheritance.
However, XMG additionally supports block con-
junction and block disjunction.
Specifically, a Class associates a name with a
content:
</bodyText>
<subsectionHeader confidence="0.505026">
Class ::= Name --+ { Content } (3)
</subsectionHeader>
<bodyText confidence="0.98237425">
A Content is either a Description (i.e., a tree
description, a semantic formula or both), a class
name, a conjunction or a disjunction of class
name:
</bodyText>
<subsubsectionHeader confidence="0.3205025">
Content ::= Description  |Name  |(4)
Name V Name  |Name n Name
</subsubsectionHeader>
<bodyText confidence="0.514506666666667">
Further, XMG allows multiple inheritance: a given
class can import or inherit one or more classes
(written Ci here):
</bodyText>
<footnote confidence="0.9966085">
3By large, we mean the transitive reflexive closure of
dominance.
</footnote>
<page confidence="0.982814">
248
</page>
<bodyText confidence="0.893338666666667">
Class Name/ C1 n ... n C� --+ { Content} (5)
The semantic of the import instruction is to in-
clude the description of the imported class within
the current one. This makes it possible to refine a
class e.g., by adding information to a node or by
adding new nodes4.
</bodyText>
<subsectionHeader confidence="0.999563">
2.3 Managing identifiers
</subsectionHeader>
<bodyText confidence="0.725430333333333">
We now introduce the treatment of identifiers sup-
ported by XMG. We show in particular, that it in-
tegrates:
</bodyText>
<listItem confidence="0.995498571428571">
• a convenient way of managing identifier
scope based on import/export declarations
inspired from standard Object Oriented Pro-
gramming techniques (section 2.3.1);
• an alternative means of identifying feature
values based on the use of unification
• polarity- (here called colour-) based node
</listItem>
<bodyText confidence="0.976753833333333">
identification as first proposed in (Muskens
and Krahmer, 1998) and later used in
(Duchier and Thater, 1999; Perrier, 2000).
The next sections will detail the linguistic and
technical motivations behind this variety of identi-
fier handling techniques.
</bodyText>
<subsubsectionHeader confidence="0.627344">
2.3.1 Import/Export declaration
</subsubsectionHeader>
<bodyText confidence="0.999958">
In XMG, the default scope of an identifier is the
class in which it is declared. However, export
specifications can be used to extend the scope of
a given identifier outside its declaration class. The
export of identifier ?X ouside class A is written :5
</bodyText>
<equation confidence="0.897453">
A?x --+ { ... ?X ... }
</equation>
<bodyText confidence="0.990267840909091">
Export declarations interact with inheritance,
conjunction and disjunction specifications as fol-
lows (where A,B,C are classes):
Inheritance: if the class A is imported either di-
rectly or indirectly by a class B, then ?X is
visible in B. In case of multiple inheritance
4Note that disjunctive inheritance is not supported which
would allow a block to be defined as importing one or more
classes from a given set of imported classes
5Similarly, import declaration can be used to restrict the
set of accessible identifiers to a subset of it.
e.g., if B/ C1 ∧ ... ∧ Cr,, , then all identi-
fiers exported by C1 ∧ ... ∧ C,,, are visible
from B provided they have distinct names.
In other words, if two (or more) classes in
C1 ∧ ... ∧ Cr,, export the same identifier ?X,
then ?X is not directly visible from B. It can
be accessed though using the dot operator.
First A is identified with a local identifier
(e.g., ?T = A), then ?T.?X can be used to
refer to the identifier ?X exported by A.
Conjunction: if classes A and B are conjoined in-
side a class C, then all the identifiers exported
by A or B are visible within C using the dot
operator.
Disjunction: if classes A and B are disjoined in-
side a class C, then all the identifiers exported
by A or B are visible within C using the dot
operator. However in this case, both A and
B have to be associated with the same local
identifier.
In sum, export/import declarations permit ex-
tending/restricting the scope of an identifier within
a branch of the inheritance hierarchy whilst the
dot operator allows explicit access to an inherited
identifier in case the inheriting class either dis-
plays multiple inheritance or is combined by con-
junction or disjunction with other classes. More
specifically, inheritance allows implicit corefer-
ence (the use of an imported name ensures coref-
erence with the object referred to when declaring
this name) and the dot operator explicit corefer-
ence (through an explicit equality statement e.g.,
?A.?X=?B.?Y).
</bodyText>
<subsectionHeader confidence="0.686169">
2.3.2 Class interface
</subsectionHeader>
<bodyText confidence="0.99154575">
In XMG, a class can be associated with a class
interface i.e., with a feature structure. Further-
more, when two classes are related either by in-
heritance or by combination (conjunction or dis-
junction), their interfaces are unified. Hence class
interfaces can be used to ensure the unification of
identifiers across classes.
Here is an illustrating example:
A { ... ?X ... }* = [n1 = ?X]
B { ... ?Y ... }* = [n1 = ?Y]
In A (resp. B), the local identifier ?X (resp. ?Y) is
associated with an interface feature named n1. If
</bodyText>
<page confidence="0.99151">
249
</page>
<bodyText confidence="0.999969928571429">
these two classes are combined either by conjunc-
tion or by inheritance, their interfaces are unified
and as a result, the local identifiers ?X and ?Y are
unified. In the case of a disjunction, the interface
of the current class (C here) is non deterministi-
cally unified with that of A or B.
In practice, interface-based identification of val-
ues is particularly useful when two distinct fea-
tures need to be assigned the same value. In (Gar-
dent, 2006) for instance, it is used to identify the
semantic index associated with e.g., the subject
node of a verbal tree and the corresponding seman-
tic index in the semantic representation associated
with that tree.
</bodyText>
<subsectionHeader confidence="0.855679">
2.3.3 Colouring nodes
</subsectionHeader>
<bodyText confidence="0.999969571428571">
Finally, XMG provides a very economical way
of identifying node variables based on the use of
colours (also called polarities in the literature).
The idea is that node variables are associated with
a specific colour and that this colouring will either
prevent or trigger node identifications based on the
following identification rules:
</bodyText>
<equation confidence="0.907624">
•B •R ◦W ⊥
•B ⊥ ⊥ •B ⊥
•R ⊥ ⊥ ⊥ ⊥
◦W •B ⊥ ◦W ⊥
⊥ ⊥ ⊥ ⊥ ⊥
</equation>
<bodyText confidence="0.999969916666667">
and on the requirement that valid trees only
have red or black nodes. In effect, node colour-
ing enforces the following constraints : (i) a white
node must be identified with a black node, (ii) a
red node cannot be identified with any other node
and (iii) a black node may be identified with one
or more white nodes.
Contrary to other means of value identification,
colours are restricted to node identifiers. Hence
they are best used to induce node identification in
those contexts where neither inheritance nor ex-
plicit identification are appropriate (see section 4).
</bodyText>
<sectionHeader confidence="0.993248" genericHeader="method">
3 XMG at work
</sectionHeader>
<bodyText confidence="0.999283166666667">
Recall (section 1) that one main problem when de-
veloping a factorised specification of tree based
grammars is to ensure a consistent treatment of
identifiers and in particular, of identifier unifica-
tion. That is, when combining two units of infor-
mation, the grammar writer must ensure that her
specification correctly states which objects are the
same and which are distinct.
In what follows, we show that XMG supports
four different ways of identifying objects. We il-
lustrate this by demonstrating that the following
tree can be obtained in four different ways:
</bodyText>
<figure confidence="0.9441575">
s
n v
</figure>
<figureCaption confidence="0.999903">
Figure 1: A tree that can be derived in four ways
</figureCaption>
<bodyText confidence="0.99984775">
In section 4, we will show that these four ways
of identifying nodes and/or features values support
both explicitness and economy thereby reducing
the risks of specification errors.
</bodyText>
<subsectionHeader confidence="0.999656">
3.1 Using explicit identification
</subsectionHeader>
<bodyText confidence="0.999910333333333">
The most basic way to identify two identifiers is to
explicitly state their identity. Thus the above tree
can be produced by combining the following two
</bodyText>
<equation confidence="0.988832">
classes6 :
A?X,?r → { ?X [cat s] → ?Y [cat n] }
B1 → { ?U [cat s] → ?Z [cat v]
∧ A ∧ ?U = A.?X ∧ A.?Y ≺ ?Z }
</equation>
<bodyText confidence="0.9983802">
To improve readability, we use from now on a
graphical representation. For instance, the classes
above are represented as follows (exported identi-
fiers are underlined and boxed letters indicate class
names):
</bodyText>
<equation confidence="0.893307166666667">
� ✞☎
✂ A✁ s ?X ✝B1 s ?U
✆
n ?r v ?Z
∧ A ∧ ?U = A.?X
∧ A.?Y ≺ ?Z
</equation>
<bodyText confidence="0.9997995">
Thus, the class A describes the left branch of the
tree in Figure 1 and the class B1 its right branch.
The root of A and B are named ?X and ?U re-
spectively. Since ?X is exported, ?X is visible in
B1. The explicit identification ?U=A.?X then en-
forces that the two roots are identified thus con-
straining the solution to be the tree given in Fig-
ure 1.
</bodyText>
<subsectionHeader confidence="0.999765">
3.2 Using inheritance
</subsectionHeader>
<bodyText confidence="0.9996915">
Using inheritance instead of conjunction, the same
nodes identification can be obtained in a more eco-
nomical way. We reuse the same class A as before,
but we now define a class B 2 as a sub-class of A:
</bodyText>
<equation confidence="0.9653">
� ✞
n ?r v ?Z
∧ ?Y ≺ ?Z
</equation>
<footnote confidence="0.79047">
6Here and in what follows, we abbreviate the conjunction
of a class identification ?T = A and a dot notation T.?X to
A.?X. That is,
</footnote>
<figure confidence="0.961206285714286">
?T = A ∧ T.?X →abb,,, A.?X
☎
✝B2 / A s ?X
✆
✄
✂ A✁ s ?X
✄
</figure>
<page confidence="0.981027">
250
</page>
<bodyText confidence="0.999978272727273">
Since the identifiers ?X and ?Y are exported by A,
they are visible in B2. Thus, in the latter we only
have to indicate the precedence relation between
?Y and ?Z.
In sum, the main difference between explicit
identification and identification through simple ex-
ports, is that whilst inheritance of exported identi-
fiers gives direct access to these identifiers, class
combination requires the use of a prefix and dot
statement. Note nevertheless that with the latter,
identifiers conflicts are a lot less likely to appear.
</bodyText>
<subsectionHeader confidence="0.998789">
3.3 Using interfaces
</subsectionHeader>
<bodyText confidence="0.9998335">
A third possibility is to use interfaces to force node
identifications as illustrated in figure 2.
</bodyText>
<equation confidence="0.641653">
n ?Y n ?W � v ?V
∧ A
[root = ?X, [root = ?U,
nNode = ?Y] nNode = ?W]
</equation>
<figureCaption confidence="0.998552">
Figure 2: Structure sharing using interfaces
</figureCaption>
<bodyText confidence="0.990538888888889">
Class A is the same as before except that the
identifiers ?X and ?Y are no longer exported. In-
stead they are associated with the interface fea-
tures root and nNode respectively. Similarly,
class B3 associates the identifiers (?U and ?V) with
the interface features root and nNode. As the tree
fragment of class B3 is conjoined with A, the inter-
face features of A and B3 are unified so that ?X is
identified with ?U and ?Y with ?V.
</bodyText>
<subsectionHeader confidence="0.996645">
3.4 Using node colours
</subsectionHeader>
<bodyText confidence="0.6603905">
Finally, colours can be used as illustrated in the
Figure below:
</bodyText>
<equation confidence="0.5842195">
n 9 n o � v 9
∧ A
</equation>
<bodyText confidence="0.999826928571429">
Now, class B4 contains three nodes: two white
ones whose categories are s and n and which must
be identified with compatible black nodes in A;
and a black node that may but need not be identi-
fied with a white one. To satisfy these constraints,
the black s node in A must be identified with the
white s node in B and similarly for the n nodes.
The result is again the tree given in Figure 1.
Note that in this case, none of the identifiers
need to be exported. Importantly, the use of
colours supports a very economical way of forcing
nodes identification. Indeed, nodes that are identi-
fied through colouration need neither be exported
nor even be named.
</bodyText>
<sectionHeader confidence="0.978267" genericHeader="method">
4 Which choice when?
</sectionHeader>
<bodyText confidence="0.999910333333333">
As shown in the previous section, XMG allows
four ways of identifying values (i.e., nodes or fea-
ture values): through simple exports, through ex-
plicit identification, through colour constraints and
through the interface. We now identify when each
of these four possibilities is best used.
</bodyText>
<subsectionHeader confidence="0.934998">
4.1 Exports
</subsectionHeader>
<bodyText confidence="0.999978115384615">
As shown in section 2.3, an identifier ?X can be
explicitly exported by a class C with the effect that,
within all classes that inherit from C, all occur-
rences of ?X denote the same object.
In essence, exports supports variable naming
that is global to a branch of the inheritance hier-
archy. It is possible to name an identifier within
a given class C and to reuse it within any other
class that inherits from C. Thus the empirical dif-
ficulty associated with the use of exported iden-
tifiers is that associated with global names. That
is, the grammar writer must remember the names
used and their intended interpretation. When de-
veloping a large size grammar, this rapidly makes
grammar writing, maintenance and debugging an
extremely difficult task. Hence global identifiers
should be use sparingly.
But although non trivial (this was in fact one
of the main motivations for developing XMG), this
empirical limitation is not the only one. There are
two additional formal restrictions which prevent a
general use of exported identifiers.
First, as remarked upon in (Crabbe and Duchier,
2004), global names do not support multiple use
of the same class within a class. For instance, con-
sider the case illustrated in Figure 3.
</bodyText>
<figure confidence="0.955353333333333">
s s s
v pp v pp pp
p n p n p n
</figure>
<figureCaption confidence="0.999959">
Figure 3: Case of double prepositional phrase.
</figureCaption>
<bodyText confidence="0.9994196">
In this case, the aim is to produce the elemen-
tary tree for a verb taking two prepositional argu-
ments such as parler a� quelqu’un de quelque chose
(to tell someone about something). Ideally, this is
done by combining the verbal fragment on the left
</bodyText>
<figure confidence="0.934018692307692">
☎
✝B3 s ?U
✆
✄
�A s ?X
✞
✄A s 9
✞
✂ ✁
✝
☎
B4 so
✆
</figure>
<page confidence="0.99511">
251
</page>
<bodyText confidence="0.992779571428571">
with two occurrences of the PP class in the mid-
dle to yield the tree on the right. However if, as is
likely in a large size metagrammar, any of the pp,
the p or the n node bears an exported identifier,
then the two occurrences of this node will be iden-
tified so that the resulting tree will be that given in
(4).
</bodyText>
<figure confidence="0.987305666666667">
s
v pp
p n
</figure>
<figureCaption confidence="0.9984335">
Figure 4: Double prepositional phrase with ex-
ported identifiers.
</figureCaption>
<bodyText confidence="0.999056538461539">
We will see below how colours permit a natural
account of such cases.
Second, exported modifiers do not support iden-
tifier unification in cases of conjunction, disjunc-
tion and multiple inheritance. That is, in each of
the three cases below, the various occurrences of
?X are not identified.
an adjective, a preposition or a predicative noun)
needs to be projected from the anchor to the root
node as illustrated in Figure 5. This can be done,
as shown in the figure by conjoining CSem with CV
or CA and letting the colour unify the appropriate
nodes.
</bodyText>
<figure confidence="0.758353625">
s • s • oi2
np•vp•np• np • ap • np • o
oi1
v • cop • adj •
v  |adj
✞☎ ✞ ☎ ✞ ☎
CSem
✝ CV✆ ✝CA✆ ✝ ✆
</figure>
<figureCaption confidence="0.999658">
Figure 5: Case of semantic projections.
</figureCaption>
<bodyText confidence="0.999919857142857">
Colouring also solves the problem raised by the
multiple reuse of the same class in the definition
of a given class. The colouring will be as shown
in Figure 6. Since the pp, p and n nodes are black,
their two occurrences cannot be identified. The
two white s nodes however will both be unified
with the black one thus yielding the expected tree.
</bodyText>
<equation confidence="0.9951282">
i2
i1
C1 ?X ∧ C2 ?X
C1 ?X V C2 ?X s • s o s •
Cg ?X / C1 ?X ∧ C2 ?X
</equation>
<bodyText confidence="0.998352">
In such cases, the multiple occurrences of ?X
need to be explicitly identified (see below).
In practice then, the safest use of simple exports
(ie without explicit identifier equalities) consists in
using them
</bodyText>
<listItem confidence="0.994222666666667">
• in combination with inheritance only and
• within a linguistically motivated subpart of
the inheritance hierarchy
</listItem>
<subsectionHeader confidence="0.993955">
4.2 Colours
</subsectionHeader>
<bodyText confidence="0.999841">
As discussed in section 2.3, node identifications
can be based on colours. In particular, if a node is
white, it must be identified with a black node.
The main advantage of this particular identifica-
tion mechanism is that it is extremely economical.
Not only is there no longer any need to remember
names, there is in fact no need to chose a name.
When developing a metagrammar containing sev-
eral hundreds of nodes, this is a welcome feature.
This “no-name” aspect of the colour mecha-
nism is in particular very useful when a given class
needs to be combined with many other classes.
For instance, in SEMFRAG (Gardent, 2006), the
semantic index of a semantic functor (i.e., a verb,
</bodyText>
<figure confidence="0.4902955">
v • pp • v • pp • pp •
p • n • p • n • p • n •
</figure>
<figureCaption confidence="0.98781">
Figure 6: Case of double prepositional phrase with
coloured descriptions.
</figureCaption>
<bodyText confidence="0.99840625">
As for exports however, colours cannot always
be used to force identifications.
First, colours can only be used in combination
with conjunction or inheritance of non exported
identifiers. Indeed, inheritance does not allow the
identification of two different objects. Hence if a
class C containing a white node named ?X inherits
from another class C’ exporting a black node also
named ?X, compilation will fail as a given identi-
fier can only have one colour7. In contrast, when
solving a description containing the conjunction of
a black and a white node (where these two nodes
have either no names or distinct names), the well
formedness constraint on coloured tree will ensure
that these two nodes are in fact the same (since a
tree containing a white node is ill formed).
Second, colour based identification is non de-
terministic. For instance, in Figure 5, if the lowest
However, different occurrences of the same unnamed
node can have distinct colours.
</bodyText>
<page confidence="0.988276">
252
</page>
<bodyText confidence="0.972100772727273">
node b of CS,,,, was not labelled cat = v  |adj,
CA∧ CS,,,, would yield not one but two trees: one
where b is identified with the cop node and the
other where it is identified with the adj one. In
other words, colour based unification is only pos-
sible in cases where node decorations (or explicit
node identifications) are sufficiently rich to con-
strain the possible unifications.
To sum up, colours are useful in situations
where:
• a given class needs to be combined with
many other classes – in this case it is unlikely
that the names used in all classes to be com-
bined are consistent (ie that they are the same
for information that must be unified and that
they are different for information that must
not) and
• the nodes to be identified are unambigu-
ous (the white and the black nodes contain
enough information so that it is clear which
white node must be identified with which
black one)
</bodyText>
<subsectionHeader confidence="0.938284">
4.3 Interfaces
</subsectionHeader>
<bodyText confidence="0.999971653846154">
Interfaces provide another mechanism for global
naming. They are particularly useful in cases
where two fundamentally different objects contain
non-node identifiers that must be unified.
Recall (cf. section 4.2) that exported identifiers
are best used within restricted, linguistically well
defined hierarchies. In a case where the objects
containing the two identifiers to be identified are
different, these will belong to distinct part of the
inheritance hierarchy hence identifier export is not
a good option.
Node colouring is another possibility but as the
name indicates, it only works for nodes, not for
feature values.
In such a situation then, interfaces come in
handy. This is the case for instance, when com-
bining a semantic representation with a tree. The
semantic formula and the tree are distinct objects
but in the approach to semantic construction de-
scribed in (Gardent and Kallmeyer, 2003), they
share some semantic indices. For instance, the
subject node in the tree is labelled with an index
feature whose value must be (in an active form
tree) that of the first argument occurring in the
semantic representation. The encoding of the re-
quired coreference can be sketched as follows:
</bodyText>
<equation confidence="0.898736">
Subj { ... ?X ...}* = [subjectIdx = ?X]
Sem { ... ?Y ...}* = [arg1 = ?Y]
Tree Subj* = [subjectIdx = ?Z] n
Sem* = [arg1 = ?Z]
</equation>
<bodyText confidence="0.999373857142857">
The first two lines show the naming of the iden-
tifiers ?X and ?Y through the interface, the third
illustrates how unification can be used to identify
the values named by the interface: since the same
variable ?Z is the value of the two features arg1
and subjectIdx, the corresponding values in the
Subj and Sem classes are identified.
</bodyText>
<sectionHeader confidence="0.655189" genericHeader="method">
4.4 Explicit identification of exported
identifiers
</sectionHeader>
<bodyText confidence="0.979377117647058">
The explicit identification of exported identifiers is
the last resort solution. It is not subject to any of
the restrictions listed above and can be combined
with conjunction, disjunction and inheritance. It
is however uneconomical and complexifies gram-
mar writing (since every node identification must
be explicitly declared). Hence it should be used as
little as possible.
In practice, explicit identification of exported
identifiers is useful :
• to further constrain colour based identifica-
tion (when the feature information present in
the nodes does not suffice to force identifica-
tion of the appropriate nodes)
• to model general principles that apply to sev-
eral subtrees in a given hierarchy
The second point is illustrated by Subject/Verb
agreement. Suppose that in the metagrammar,
we want to have a separate class to enforce this
agreement. This class consists of a subject node
?SubjAgr bearing agreement feature ?X and of
a verb node ?VerbAgr bearing the same agree-
ment feature. It must then be combined with all
verbal elementary trees described by the meta-
grammar whereby in each such combination the
nodes ?SubjAgr, ?VerbAgr must be identi-
fied with the subject and the verb node respec-
tively. This is a typical case of multiple inheri-
tance because both the subject and the verb nodes
are specified by inheritance and ?SubjAgr,
?VerbAgr must be further inherited. Since
nodes must be identified and multiple inheritance
occur, simple identifier exports cannot be used (cf.
section 2.3.1). If colours cannot be sufficiently
</bodyText>
<page confidence="0.997707">
253
</page>
<table confidence="0.994982909090909">
Pros Cons Practice
Export Economy Name management Use in linguistically motivated
Not with multiple inheritance sub-hierarchy
Not with conjunction
Not with disjunction
Not with multiple reuse
Colours Economy ++ Non deterministic Use when a given class
Multiple reuse OK Not with inheritance combines with many classes
and identically named identifiers
Interface Global Name management Use for Syntax/Semantic interface
Explicit identification Usable in all cases Uneconomical Last Resort solution
</table>
<figureCaption confidence="0.9862458">
Figure 7: Summary of the pros and cons of sharing mechanisms.
constrained by features, then the only solution left
is explicit node identification.
Figure 7 summarises the pros and the cons of
each approach.
</figureCaption>
<sectionHeader confidence="0.999336" genericHeader="conclusions">
5 Conclusion
</sectionHeader>
<bodyText confidence="0.999812428571429">
In this paper, we have introduced a specification
formalism for Tree-Based Grammars and shown
that its expressivity helps solving specification
problems which might be encountered when de-
velopping a large scale tree-based grammar.
This formalism has been implemented within
the XMG system and successfully used to encode
both a core TAG for French (Crabbe, 2005; Gar-
dent, 2006) and a core Interaction Grammar (Per-
rier, 2003). We are currently exploring ways
in which the XMG formalism could be extended
to automatically enforce linguistically-based well-
formedness principles such as for instance, a kind
of Head Feature Principle for TAG.
</bodyText>
<sectionHeader confidence="0.99954" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999697293103448">
T. Becker. 2000. Patterns in metarules. In A. Abeille and
O. Rambow, editors, Tree Adjoining Grammars: formal,
computational and linguistic aspects. CSLI publications,
Stanford.
J. Bos. 1995. Predicate Logic Unplugged. In Proceedings of
the 10th Amsterdam Colloquium, Amsterdam.
M.H. Candito. 1996. A principle-based hierarchical rep-
resentation of LTAGs. In Proceedings of COLING’96,
Kopenhagen.
B. Crabbe and D. Duchier. 2004. Metagrammar Redux. In
Proceedings of CSLP 2004, Copenhagen.
B. Crabbe. 2005. Repr´esentation informatique de gram-
maires fortement lexicalis´ees : Application a` la gram-
maire d’arbres adjoints. Ph.D. thesis, Universit´e Nancy
2.
D. Duchier and C. Gardent. 1999. A constraint based treat-
ment of descriptions. In Proceedings of the 3rd IWCS,
Tilburg.
Denys Duchier and Stefan Thater. 1999. Parsing with tree
descriptions: a constraint-based approach. In NLULP,
pages 17–32, Las Cruces, New Mexico.
R. Evans, G. Gazdar, and D. Weir. 1995. Encoding lexi-
calized tree adjoining grammars with a nonmonotonic in-
heritance hierarchy. In Proceedings of the 33rd Annual
Meeting of the ACL, 77-84.
B. Gaiffe, B. Crabbe, and A. Roussanaly. 2002. A new meta-
grammar compiler. In Proceedings of TAG+6, Venice.
C. Gardent and L. Kallmeyer. 2003. Semantic construction
in FTAG. In Proceedings of EACL’03, Budapest.
C. Gardent. 2006. Int´egration d’une dimension s´emantique
dans les grammaires d’arbres adjoints. In Actes de La
13`eme ´edition de la conf´erence sur le TALN (TALN2006).
A. Joshi and Y. Schabes. 1997. Tree-adjoining grammars.
In G. Rozenberg and A. Salomaa, editors, Handbook of
Formal Languages, volume 3, pages 69 – 124. Springer,
Berlin, New York.
L. Kallmeyer. 1996. Tree description grammars. In Results
of the 3rd KONVENS Conference, pages 330 – 341. Mou-
ton de Gruyter ed., Hawthorne, NY, USA.
H.-U. Krieger and U. Schafer. 1994. TDL – a type descrip-
tion language for constraint-based grammars. In Proceed-
ings of COLING-94, pp. 893–899.
R. Muskens and E. Krahmer. 1998. Description theory, ltags
and underspecified semantics. In TAG’4.
G. Perrier. 2000. Interaction grammars. In Proceedings of
18th International Conference on Computational Linguis-
tics (CoLing 2000), Sarrebrcken.
G. Perrier. 2003. Les grammaires d’interaction. HDR en
informatique, Universit´e Nancy 2.
K. Vijay-Shanker and Y. Schabes. 1992. Structure sharing
in lexicalized tree adjoining grammars. In Proceedings of
COLING’92, Nantes, pp. 205 - 212.
E. Villemonte de la Clergerie. 2005. DyALog: a tabular
logic programming based environment for NLP. In Pro-
ceedings of CSLP’05, Barcelona.
F. Xia, M. Palmer, and K. Vijay-Shanker. 1999. To-
ward semi-automating grammar development. In Proc. of
NLPRS-99, Beijing, China.
</reference>
<page confidence="0.998639">
254
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.000146">
<title confidence="0.998551">Coreference handling in XMG</title>
<author confidence="0.998424">Claire Gardent</author>
<affiliation confidence="0.977053">CNRS/LORIA</affiliation>
<address confidence="0.8948575">615, rue du jardin botanique, B.P. 101 54602 Villers l`es Nancy CEDEX</address>
<title confidence="0.574114">France Claire.Gardent@loria.fr</title>
<author confidence="0.992162">Yannick Parmentier</author>
<affiliation confidence="0.998941">INRIA Lorraine</affiliation>
<address confidence="0.876999666666667">615, rue du jardin botanique, B.P. 101 54602 Villers l`es Nancy CEDEX France</address>
<email confidence="0.892403">Yannick.Parmentier@loria.fr</email>
<abstract confidence="0.997536944805196">We claim that existing specification languages for tree based grammars fail to adequately support identifier managment. then show that Metaprovides a sophisticated treatment of identifiers which is effective in supporting a linguist-friendly grammar design. 1 Specifying tree-based grammars Whilst the development of standard unificationbased grammars is well supported by the design of formalisms such as PATR-II, Ale or TDL (Krieger and Schafer, 1994), the situation is less well established for Tree-Based Grammars such as Tree Adjoining Grammars (Joshi and Schabes, 1997), Tree Description Grammars (Kallmeyer, 1996) or Interaction Grammars (Perrier, 2003). Roughly, two main types of specification formalism for Tree-Based Grammars can be distinguished: formalisms based on tree fragments and non monotonic inheritance and formalisms based on tree descriptions and monotonic inheritance. The tree fragment approach is advocated in (Evans et al., 1995) which proposes to encode lexusing the DATR representation lan- In this approach, tree fragments are combined within a non monotonic inheritance hierarchy. Furthermore, new fragments can be derived from existing ones by means of lexical rules. This first approach suffers from the procedural character of non-monotonic inheritance. In specifying the grammar, the grammar writer must keep tree based approach is also used in(Becker, 2000) but this time in combination with metarules. In that particular approach, procedural aspects also come into play as the order in which metarules apply affect the results. in mind the order in which non-monotonic statements have been made so as to be able to predict how explicit statements interact with defaults and non-monotonic inheritance in determining the final output. When developing a large coverage grammar, this rapidly become extremely cumbersome. Moreover, as (Candito, 1996) remarks, nonmonotonicity may result in an information loss which makes it impossible to express the relation existing for instance between an active object and the corresponding passive subject. The approach based on tree descriptions (ofcalled, the obviates the procedural character of the non-monotonic approach by taking tree descriptions rather than trees to be the basic units (Candito, 1996; Xia et al., 1999; Vijay-Shanker and Schabes, 1992). In essence, tree fragments are described using tree descriptions and tree descriptions are combined through conjunction or inheritance. The idea is that the minimal models satisfying the resulting descriptions are TAG elementary trees. In some cases, lexical rules are also used to derive new trees from existing ones. One main drawback with this second type of approach concerns the management of node identifiers. Either nodes are represented by nameless variables and node identification is forced by constraints e.g., trees and given by the input tree description (cf. e.g., (Duchier and Gardent, 1999)) or nodes are named and nodes with identical names are forced to denote the same entity. The first option is unrealistic when developing a large core grammar as it is easy to omit a necessary constraint and thereby permit overgeneration (the description will be satisfied by more trees than intended). The second option greatly degrades 247 of the COLING/ACL 2006 Main Conference Poster pages 247–254, July 2006. Association for Computational Linguistics modularity as the grammar writer must remember which names were used where and with which interpretation. As we shall see below, it also has the undesirable effect that the same tree fragment cannot be used twice in a given tree description. Nevertheless, this is the option that is adopted in most grammar formalisms and grammar compilers (Candito, 1996; Xia et al., 1999; Gaiffe et al., 2002). In this paper, we present an approach which remedies these shortcomings by combining monoinheritance of tree descriptions with an explicit management of identifier scope and identi- The proposed approach thus eschews both the inconvenients induced by a non monotonic framework (by using tree descriptions rather than trees) and those resulting from a global treatment of identifiers (by providing greater expressivity wrt identifiers). Specifically, we show that the proposed approach supports several ways of identifying (node or feature) values, we motivate this multiplicity and we identify the linguistic and/or technical criteria for choosing among the various possibilities. The paper starts in section 2 by introducing the of the In section 3, we that four different ways of identifying two (node or variable) identifiers. In section 4, we motivate each of these four different ways and indicate when each of them can and should be used. The start by briefly introducing MetaGrammar). First, we show that it supports the and the combination of consisting of tree fragments and/or semantic representations. Then, we show that it supports a sophisticated treatment of identifiers. 2.1 Defining blocks At the syntactic level, the basic units are tree descriptions which are specified using the following tree logic: (Villemonte de la Clergerie, 2005) has proposed a highly compact representation formalism for treebased grammars which also features explicit identifier management. His approach differs from ours in that it includes neither a colouring mechanism (cf. section 3.4) nor interfaces (cf. section 3.3). (1) y node variables, directly above domabove and above or equal to Similarly precedence, precedence, and precedence. Finally associated expression node and node identification. also supports the association of semantic representations with elementary trees. The semantic representation language is a flat semantic representation language (Bos, 1995) with the following syntax: ..., ..., (2) a label, a predicate and parameters. Further, negation and a scope constraint between in the scope of 2.2 Combining blocks As in other existing tree-based formalisms, in blocks can be combined using inheritance. supports block conjunction and block disjunction. a a name with a content: { either a a tree description, a semantic formula or both), a class name, a conjunction or a disjunction of class name: a given can inherit one or more classes large, we mean the transitive reflexive closure of dominance. 248 { semantic of the is to inthe description of the within the current one. This makes it possible to refine a class e.g., by adding information to a node or by new 2.3 Managing identifiers We now introduce the treatment of identifiers supby We show in particular, that it integrates: • a convenient way of managing identifier based on declarations inspired from standard Object Oriented Programming techniques (section 2.3.1); • an alternative means of identifying feature based on the use of polaritycalled based node identification as first proposed in (Muskens and Krahmer, 1998) and later used in (Duchier and Thater, 1999; Perrier, 2000). The next sections will detail the linguistic and technical motivations behind this variety of identifier handling techniques. 2.3.1 Import/Export declaration the default scope of an identifier is the in which it is declared. However, specifications can be used to extend the scope of a given identifier outside its declaration class. The of identifier class written { Export declarations interact with inheritance, conjunction and disjunction specifications as fol- (where classes): the class dior indirectly by a class then in In case of multiple inheritance that disjunctive inheritance is not supported which would allow a block to be defined as importing one or more classes from a given set of imported classes can be used to restrict the set of accessible identifiers to a subset of it. if then all identiexported by visible they have distinct In other words, if two (or more) classes in the not directly visible from It can be accessed though using the dot operator. identified with a local identifier then be used to to the identifier by classes ina class then all the identifiers exported visible within the operator. classes ina class then all the identifiers exported visible within the However in this case, both to be associated with the same local identifier. In sum, export/import declarations permit extending/restricting the scope of an identifier within a branch of the inheritance hierarchy whilst the dot operator allows explicit access to an inherited identifier in case the inheriting class either displays multiple inheritance or is combined by conjunction or disjunction with other classes. More specifically, inheritance allows implicit coreference (the use of an imported name ensures coreference with the object referred to when declaring this name) and the dot operator explicit coreference (through an explicit equality statement e.g., 2.3.2 Class interface a class can be associated with a with a feature structure. Furthermore, when two classes are related either by inheritance or by combination (conjunction or distheir interfaces are Hence class interfaces can be used to ensure the unification of identifiers across classes. Here is an illustrating example: A { }* = B { }* = the is with an interface feature named If 249 these two classes are combined either by conjunction or by inheritance, their interfaces are unified as a result, the local identifiers unified. In the case of a disjunction, the interface the current class is non deterministiunified with that of In practice, interface-based identification of values is particularly useful when two distinct features need to be assigned the same value. In (Gardent, 2006) for instance, it is used to identify the semantic index associated with e.g., the subject node of a verbal tree and the corresponding semantic index in the semantic representation associated with that tree. 2.3.3 Colouring nodes a very economical way of identifying node variables based on the use of called the literature). The idea is that node variables are associated with a specific colour and that this colouring will either prevent or trigger node identifications based on the following identification rules: •B •R ⊥ •B ⊥ ⊥ •B ⊥ •R ⊥ ⊥ ⊥ ⊥ •B ⊥ ⊥ ⊥ ⊥ ⊥ ⊥ ⊥ and on the requirement that valid trees only have red or black nodes. In effect, node colouring enforces the following constraints : (i) a white node must be identified with a black node, (ii) a red node cannot be identified with any other node and (iii) a black node may be identified with one or more white nodes. Contrary to other means of value identification, colours are restricted to node identifiers. Hence they are best used to induce node identification in those contexts where neither inheritance nor explicit identification are appropriate (see section 4). work Recall (section 1) that one main problem when developing a factorised specification of tree based grammars is to ensure a consistent treatment of identifiers and in particular, of identifier unification. That is, when combining two units of information, the grammar writer must ensure that her specification correctly states which objects are the same and which are distinct. what follows, we show that four different ways of identifying objects. We illustrate this by demonstrating that the following tree can be obtained in four different ways: s n v Figure 1: A tree that can be derived in four ways In section 4, we will show that these four ways of identifying nodes and/or features values support both explicitness and economy thereby reducing the risks of specification errors. 3.1 Using explicit identification The most basic way to identify two identifiers is to explicitly state their identity. Thus the above tree can be produced by combining the following two { { To improve readability, we use from now on a graphical representation. For instance, the classes above are represented as follows (exported identifiers are underlined and boxed letters indicate class names): ✞☎ ✆ the class the left branch of the in Figure 1 and the class right branch. root of named re- Since exported, visible in The explicit identification enforces that the two roots are identified thus constraining the solution to be the tree given in Figure 1. 3.2 Using inheritance Using inheritance instead of conjunction, the same nodes identification can be obtained in a more ecoway. We reuse the same class before, we now define a class a sub-class of ✞ and in what follows, we abbreviate the conjunction a class identification = A a dot notation That is, = A ☎ ✆ ✄ ✄ 250 the identifiers exported by are visible in Thus, in the latter we only have to indicate the precedence relation between In sum, the main difference between explicit identification and identification through simple exports, is that whilst inheritance of exported identifiers gives direct access to these identifiers, class combination requires the use of a prefix and dot statement. Note nevertheless that with the latter, identifiers conflicts are a lot less likely to appear. 3.3 Using interfaces A third possibility is to use interfaces to force node identifications as illustrated in figure 2. Figure 2: Structure sharing using interfaces the same as before except that the no longer exported. Instead they are associated with the interface fea- Similarly, the identifiers with interface features As the tree of class conjoined with the interfeatures of unified so that with 3.4 Using node colours Finally, colours can be used as illustrated in the Figure below: � class three nodes: two white whose categories are which must identified with compatible black nodes in and a black node that may but need not be identified with a white one. To satisfy these constraints, black in be identified with the in similarly for the The result is again the tree given in Figure 1. Note that in this case, none of the identifiers need to be exported. Importantly, the use of colours supports a very economical way of forcing nodes identification. Indeed, nodes that are identified through colouration need neither be exported nor even be named. 4 Which choice when? shown in the previous section, four ways of identifying values (i.e., nodes or feature values): through simple exports, through explicit identification, through colour constraints and through the interface. We now identify when each of these four possibilities is best used. 4.1 Exports shown in section 2.3, an identifier be exported by a class the effect that, all classes that inherit from all occurof the same object. In essence, exports supports variable naming that is global to a branch of the inheritance hierarchy. It is possible to name an identifier within given class to reuse it within any other that inherits from Thus the empirical difficulty associated with the use of exported identifiers is that associated with global names. That is, the grammar writer must remember the names used and their intended interpretation. When developing a large size grammar, this rapidly makes grammar writing, maintenance and debugging an extremely difficult task. Hence global identifiers should be use sparingly. But although non trivial (this was in fact one the main motivations for developing this empirical limitation is not the only one. There are two additional formal restrictions which prevent a general use of exported identifiers. First, as remarked upon in (Crabbe and Duchier, 2004), global names do not support multiple use of the same class within a class. For instance, consider the case illustrated in Figure 3. s s s v pp v pp pp p n p n p n Figure 3: Case of double prepositional phrase. In this case, the aim is to produce the elementary tree for a verb taking two prepositional argusuch as a� quelqu’un de quelque chose tell someone about Ideally, this is done by combining the verbal fragment on the left ☎ ✆ ✄ ✁ ✝ ☎ ✆ 251 with two occurrences of the PP class in the middle to yield the tree on the right. However if, as is in a large size metagrammar, any of the the bears an exported identifier, then the two occurrences of this node will be identified so that the resulting tree will be that given in (4). s v pp p n Figure 4: Double prepositional phrase with exported identifiers. We will see below how colours permit a natural account of such cases. Second, exported modifiers do not support identifier unification in cases of conjunction, disjunction and multiple inheritance. That is, in each of the three cases below, the various occurrences of not identified. an adjective, a preposition or a predicative noun) needs to be projected from the anchor to the root node as illustrated in Figure 5. This can be done, shown in the figure by conjoining letting the colour unify the appropriate nodes. o ✞☎ ✞ ☎ ✞ ☎ ✝ ✆ Figure 5: Case of semantic projections. Colouring also solves the problem raised by the multiple reuse of the same class in the definition of a given class. The colouring will be as shown Figure 6. Since the are black, their two occurrences cannot be identified. The white however will both be unified with the black one thus yielding the expected tree. such cases, the multiple occurrences of need to be explicitly identified (see below). In practice then, the safest use of simple exports (ie without explicit identifier equalities) consists in using them • in combination with inheritance only and • within a linguistically motivated subpart of the inheritance hierarchy 4.2 Colours As discussed in section 2.3, node identifications can be based on colours. In particular, if a node is it identified with a black node. The main advantage of this particular identification mechanism is that it is extremely economical. Not only is there no longer any need to remember names, there is in fact no need to chose a name. When developing a metagrammar containing several hundreds of nodes, this is a welcome feature. This “no-name” aspect of the colour mechanism is in particular very useful when a given class needs to be combined with many other classes. instance, in 2006), the index of a semantic functor a verb, Figure 6: Case of double prepositional phrase with coloured descriptions. As for exports however, colours cannot always be used to force identifications. First, colours can only be used in combination with conjunction or inheritance of non exported identifiers. Indeed, inheritance does not allow the identification of two different objects. Hence if a C containing a white node named from another class C’ exporting a black node also compilation will fail as a given identican only have one In contrast, when solving a description containing the conjunction of a black and a white node (where these two nodes have either no names or distinct names), the well formedness constraint on coloured tree will ensure that these two nodes are in fact the same (since a tree containing a white node is ill formed). Second, colour based identification is non deterministic. For instance, in Figure 5, if the lowest However, different occurrences of the same unnamed node can have distinct colours. 252 was not labelled would yield not one but two trees: one identified with the and the where it is identified with the In other words, colour based unification is only possible in cases where node decorations (or explicit node identifications) are sufficiently rich to constrain the possible unifications. To sum up, colours are useful in situations where: • a given class needs to be combined with many other classes – in this case it is unlikely that the names used in all classes to be combined are consistent (ie that they are the same for information that must be unified and that they are different for information that must not) and • the nodes to be identified are unambiguous (the white and the black nodes contain enough information so that it is clear which white node must be identified with which black one) 4.3 Interfaces Interfaces provide another mechanism for global naming. They are particularly useful in cases where two fundamentally different objects contain non-node identifiers that must be unified. Recall (cf. section 4.2) that exported identifiers are best used within restricted, linguistically well defined hierarchies. In a case where the objects containing the two identifiers to be identified are different, these will belong to distinct part of the inheritance hierarchy hence identifier export is not a good option. Node colouring is another possibility but as the indicates, it only works for not for feature values. In such a situation then, interfaces come in handy. This is the case for instance, when combining a semantic representation with a tree. The semantic formula and the tree are distinct objects but in the approach to semantic construction described in (Gardent and Kallmeyer, 2003), they share some semantic indices. For instance, the subject node in the tree is labelled with an index feature whose value must be (in an active form tree) that of the first argument occurring in the semantic representation. The encoding of the required coreference can be sketched as follows: Subj Sem = n = The first two lines show the naming of the identhe interface, the third illustrates how unification can be used to identify the values named by the interface: since the same the value of the two features the corresponding values in the are identified. 4.4 Explicit identification of exported identifiers The explicit identification of exported identifiers is the last resort solution. It is not subject to any of the restrictions listed above and can be combined with conjunction, disjunction and inheritance. It is however uneconomical and complexifies grammar writing (since every node identification must be explicitly declared). Hence it should be used as little as possible. In practice, explicit identification of exported identifiers is useful : • to further constrain colour based identification (when the feature information present in the nodes does not suffice to force identification of the appropriate nodes) • to model general principles that apply to several subtrees in a given hierarchy The second point is illustrated by Subject/Verb agreement. Suppose that in the metagrammar, we want to have a separate class to enforce this agreement. This class consists of a subject node agreement feature of verb node the same agreement feature. It must then be combined with all verbal elementary trees described by the metagrammar whereby in each such combination the ?VerbAgr be identified with the subject and the verb node respectively. This is a typical case of multiple inheritance because both the subject and the verb nodes specified by inheritance and be further inherited. Since nodes must be identified and multiple inheritance occur, simple identifier exports cannot be used (cf. section 2.3.1). If colours cannot be sufficiently 253</abstract>
<title confidence="0.649044636363636">Pros Cons Practice Export Economy Name management Use in linguistically motivated Not with multiple inheritance sub-hierarchy Not with conjunction Not with disjunction Not with multiple reuse Colours Economy ++ Non deterministic Use when a given class Multiple reuse OK Not with inheritance combines with many classes and identically named identifiers Interface Global Name management Use for Syntax/Semantic interface Explicit identification Usable in all cases Uneconomical Last Resort solution</title>
<abstract confidence="0.9952314">Figure 7: Summary of the pros and cons of sharing mechanisms. constrained by features, then the only solution left is explicit node identification. Figure 7 summarises the pros and the cons of each approach. 5 Conclusion In this paper, we have introduced a specification formalism for Tree-Based Grammars and shown that its expressivity helps solving specification problems which might be encountered when developping a large scale tree-based grammar. This formalism has been implemented within and successfully used to encode a core French (Crabbe, 2005; Gardent, 2006) and a core Interaction Grammar (Perrier, 2003). We are currently exploring ways which the could be extended to automatically enforce linguistically-based wellformedness principles such as for instance, a kind of Head Feature Principle for TAG.</abstract>
<title confidence="0.788313">References</title>
<author confidence="0.656958">Patterns in metarules In A Abeille</author>
<author confidence="0.656958">editors Rambow</author>
<author confidence="0.656958">Adjoining Grammars formal</author>
<affiliation confidence="0.830561">and linguistic CSLI publications,</affiliation>
<address confidence="0.794835">Stanford.</address>
<note confidence="0.832986">Bos. 1995. Predicate Logic Unplugged. In of 10th Amsterdam Colloquium, M.H. Candito. 1996. A principle-based hierarchical repof LTAGs. In of COLING’96, B. Crabbe and D. Duchier. 2004. Metagrammar Redux. In of CSLP 2004,</note>
<abstract confidence="0.926014956521739">Crabbe. 2005. informatique de grammaires fortement lexicalis´ees : Application a` la gramd’arbres Ph.D. thesis, Universit´e Nancy 2. D. Duchier and C. Gardent. 1999. A constraint based treatof descriptions. In of the 3rd IWCS, Denys Duchier and Stefan Thater. 1999. Parsing with tree a constraint-based approach. In pages 17–32, Las Cruces, New Mexico. R. Evans, G. Gazdar, and D. Weir. 1995. Encoding lexicalized tree adjoining grammars with a nonmonotonic inhierarchy. In of the 33rd Annual of the ACL, B. Gaiffe, B. Crabbe, and A. Roussanaly. 2002. A new metacompiler. In of TAG+6, C. Gardent and L. Kallmeyer. 2003. Semantic construction FTAG. In of EACL’03, C. Gardent. 2006. Int´egration d’une dimension s´emantique les grammaires d’arbres adjoints. In de La ´edition de la conf´erence sur le TALN A. Joshi and Y. Schabes. 1997. Tree-adjoining grammars. G. Rozenberg and A. Salomaa, editors, of volume 3, pages 69 – 124. Springer,</abstract>
<address confidence="0.645952">Berlin, New York.</address>
<note confidence="0.897064047619047">Kallmeyer. 1996. Tree description grammars. In the 3rd KONVENS pages 330 – 341. Mouton de Gruyter ed., Hawthorne, NY, USA. H.-U. Krieger and U. Schafer. 1994. TDL – a type descriplanguage for constraint-based grammars. In Proceedof COLING-94, pp. R. Muskens and E. Krahmer. 1998. Description theory, ltags underspecified semantics. In Perrier. 2000. Interaction grammars. In of 18th International Conference on Computational Linguis- (CoLing Sarrebrcken. G. Perrier. 2003. Les grammaires d’interaction. HDR en informatique, Universit´e Nancy 2. K. Vijay-Shanker and Y. Schabes. 1992. Structure sharing lexicalized tree adjoining grammars. In of Nantes, pp. 205 - E. Villemonte de la Clergerie. 2005. DyALog: a tabular programming based environment for NLP. In Proof Barcelona. F. Xia, M. Palmer, and K. Vijay-Shanker. 1999. Tosemi-automating grammar development. In of</note>
<affiliation confidence="0.636118">Beijing,</affiliation>
<address confidence="0.894325">254</address>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>T Becker</author>
</authors>
<title>Patterns in metarules.</title>
<date>2000</date>
<booktitle>Tree Adjoining Grammars: formal, computational and linguistic aspects. CSLI publications,</booktitle>
<editor>In A. Abeille and O. Rambow, editors,</editor>
<location>Stanford.</location>
<contexts>
<context position="1747" citStr="Becker, 2000" startWordPosition="256" endWordPosition="257">onotonic inheritance and formalisms based on tree descriptions and monotonic inheritance. The tree fragment approach is advocated in (Evans et al., 1995) which proposes to encode lexicalised TAGs using the DATR representation language&apos;. In this approach, tree fragments are combined within a non monotonic inheritance hierarchy. Furthermore, new fragments can be derived from existing ones by means of lexical rules. This first approach suffers from the procedural character of non-monotonic inheritance. In specifying the grammar, the grammar writer must keep &apos;A tree based approach is also used in(Becker, 2000) but this time in combination with metarules. In that particular approach, procedural aspects also come into play as the order in which metarules apply affect the results. in mind the order in which non-monotonic statements have been made so as to be able to predict how explicit statements interact with defaults and non-monotonic inheritance in determining the final output. When developing a large coverage grammar, this rapidly become extremely cumbersome. Moreover, as (Candito, 1996) remarks, nonmonotonicity may result in an information loss which makes it impossible to express the relation e</context>
</contexts>
<marker>Becker, 2000</marker>
<rawString>T. Becker. 2000. Patterns in metarules. In A. Abeille and O. Rambow, editors, Tree Adjoining Grammars: formal, computational and linguistic aspects. CSLI publications, Stanford.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Bos</author>
</authors>
<title>Predicate Logic Unplugged.</title>
<date>1995</date>
<booktitle>In Proceedings of the 10th Amsterdam Colloquium,</booktitle>
<location>Amsterdam.</location>
<contexts>
<context position="6687" citStr="Bos, 1995" startWordPosition="1040" endWordPosition="1041">l |x = y | Description n Description where x, y represent node variables, —* immediate dominance (x is directly above y), —*+ strict dominance (x is above y), and —** large dominance3 (x is above or equal to y). Similarly � denotes immediate precedence, �+ strict precedence, and --&lt;* large precedence. Finally x[f:E] constrains feature f with associated expression E on node x, and x = y indicates node identification. The XMG formalism also supports the association of semantic representations with elementary trees. The semantic representation language is a flat semantic representation language (Bos, 1995) with the following syntax: Description ::= f:p(E1, ..., Ems) | -f:p(E1, ..., E+) |Ei « Ej (2) Description n Description where E is a label, p is a predicate and E1,.., En are parameters. Further, -, denotes negation and Ei « Ej expresses a scope constraint between Ei and Ej (Ej is in the scope of Ei). 2.2 Combining blocks As in other existing tree-based formalisms, in XMG, blocks can be combined using inheritance. However, XMG additionally supports block conjunction and block disjunction. Specifically, a Class associates a name with a content: Class ::= Name --+ { Content } (3) A Content is e</context>
</contexts>
<marker>Bos, 1995</marker>
<rawString>J. Bos. 1995. Predicate Logic Unplugged. In Proceedings of the 10th Amsterdam Colloquium, Amsterdam.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M H Candito</author>
</authors>
<title>A principle-based hierarchical representation of LTAGs.</title>
<date>1996</date>
<booktitle>In Proceedings of COLING’96, Kopenhagen.</booktitle>
<contexts>
<context position="2236" citStr="Candito, 1996" startWordPosition="333" endWordPosition="334">nic inheritance. In specifying the grammar, the grammar writer must keep &apos;A tree based approach is also used in(Becker, 2000) but this time in combination with metarules. In that particular approach, procedural aspects also come into play as the order in which metarules apply affect the results. in mind the order in which non-monotonic statements have been made so as to be able to predict how explicit statements interact with defaults and non-monotonic inheritance in determining the final output. When developing a large coverage grammar, this rapidly become extremely cumbersome. Moreover, as (Candito, 1996) remarks, nonmonotonicity may result in an information loss which makes it impossible to express the relation existing for instance between an active object and the corresponding passive subject. The approach based on tree descriptions (often called, the metagrammar approach) obviates the procedural character of the non-monotonic approach by taking tree descriptions rather than trees to be the basic units (Candito, 1996; Xia et al., 1999; Vijay-Shanker and Schabes, 1992). In essence, tree fragments are described using tree descriptions and tree descriptions are combined through conjunction or </context>
<context position="4217" citStr="Candito, 1996" startWordPosition="639" endWordPosition="640">ion (the description will be satisfied by more trees than intended). The second option greatly degrades 247 Proceedings of the COLING/ACL 2006 Main Conference Poster Sessions, pages 247–254, Sydney, July 2006. c�2006 Association for Computational Linguistics modularity as the grammar writer must remember which names were used where and with which interpretation. As we shall see below, it also has the undesirable effect that the same tree fragment cannot be used twice in a given tree description. Nevertheless, this is the option that is adopted in most grammar formalisms and grammar compilers (Candito, 1996; Xia et al., 1999; Gaiffe et al., 2002). In this paper, we present an approach which remedies these shortcomings by combining monotonic inheritance of tree descriptions with an explicit management of identifier scope and identifiers equality2. The proposed approach thus eschews both the inconvenients induced by a non monotonic framework (by using tree descriptions rather than trees) and those resulting from a global treatment of identifiers (by providing greater expressivity wrt identifiers). Specifically, we show that the proposed approach supports several ways of identifying (node or featur</context>
</contexts>
<marker>Candito, 1996</marker>
<rawString>M.H. Candito. 1996. A principle-based hierarchical representation of LTAGs. In Proceedings of COLING’96, Kopenhagen.</rawString>
</citation>
<citation valid="true">
<authors>
<author>B Crabbe</author>
<author>D Duchier</author>
</authors>
<title>Metagrammar Redux.</title>
<date>2004</date>
<booktitle>In Proceedings of CSLP 2004,</booktitle>
<location>Copenhagen.</location>
<contexts>
<context position="18620" citStr="Crabbe and Duchier, 2004" startWordPosition="3163" endWordPosition="3166">e of exported identifiers is that associated with global names. That is, the grammar writer must remember the names used and their intended interpretation. When developing a large size grammar, this rapidly makes grammar writing, maintenance and debugging an extremely difficult task. Hence global identifiers should be use sparingly. But although non trivial (this was in fact one of the main motivations for developing XMG), this empirical limitation is not the only one. There are two additional formal restrictions which prevent a general use of exported identifiers. First, as remarked upon in (Crabbe and Duchier, 2004), global names do not support multiple use of the same class within a class. For instance, consider the case illustrated in Figure 3. s s s v pp v pp pp p n p n p n Figure 3: Case of double prepositional phrase. In this case, the aim is to produce the elementary tree for a verb taking two prepositional arguments such as parler a� quelqu’un de quelque chose (to tell someone about something). Ideally, this is done by combining the verbal fragment on the left ☎ ✝B3 s ?U ✆ ✄ �A s ?X ✞ ✄A s 9 ✞ ✂ ✁ ✝ ☎ B4 so ✆ 251 with two occurrences of the PP class in the middle to yield the tree on the right. Ho</context>
</contexts>
<marker>Crabbe, Duchier, 2004</marker>
<rawString>B. Crabbe and D. Duchier. 2004. Metagrammar Redux. In Proceedings of CSLP 2004, Copenhagen.</rawString>
</citation>
<citation valid="true">
<authors>
<author>B Crabbe</author>
</authors>
<title>Repr´esentation informatique de grammaires fortement lexicalis´ees : Application a` la grammaire d’arbres adjoints.</title>
<date>2005</date>
<tech>Ph.D. thesis,</tech>
<institution>Universit´e Nancy 2.</institution>
<marker>Crabbe, 2005</marker>
<rawString>B. Crabbe. 2005. Repr´esentation informatique de grammaires fortement lexicalis´ees : Application a` la grammaire d’arbres adjoints. Ph.D. thesis, Universit´e Nancy 2.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D Duchier</author>
<author>C Gardent</author>
</authors>
<title>A constraint based treatment of descriptions.</title>
<date>1999</date>
<booktitle>In Proceedings of the 3rd IWCS,</booktitle>
<location>Tilburg.</location>
<contexts>
<context position="3370" citStr="Duchier and Gardent, 1999" startWordPosition="500" endWordPosition="503">described using tree descriptions and tree descriptions are combined through conjunction or inheritance. The idea is that the minimal models satisfying the resulting descriptions are TAG elementary trees. In some cases, lexical rules are also used to derive new trees from existing ones. One main drawback with this second type of approach concerns the management of node identifiers. Either nodes are represented by nameless variables and node identification is forced by well-formedness constraints e.g., wff-constraints on trees and wff-constraints given by the input tree description (cf. e.g., (Duchier and Gardent, 1999)) or nodes are named and nodes with identical names are forced to denote the same entity. The first option is unrealistic when developing a large core grammar as it is easy to omit a necessary constraint and thereby permit overgeneration (the description will be satisfied by more trees than intended). The second option greatly degrades 247 Proceedings of the COLING/ACL 2006 Main Conference Poster Sessions, pages 247–254, Sydney, July 2006. c�2006 Association for Computational Linguistics modularity as the grammar writer must remember which names were used where and with which interpretation. A</context>
</contexts>
<marker>Duchier, Gardent, 1999</marker>
<rawString>D. Duchier and C. Gardent. 1999. A constraint based treatment of descriptions. In Proceedings of the 3rd IWCS, Tilburg.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Denys Duchier</author>
<author>Stefan Thater</author>
</authors>
<title>Parsing with tree descriptions: a constraint-based approach.</title>
<date>1999</date>
<booktitle>In NLULP,</booktitle>
<pages>17--32</pages>
<location>Las Cruces, New Mexico.</location>
<contexts>
<context position="8466" citStr="Duchier and Thater, 1999" startWordPosition="1339" endWordPosition="1342">t possible to refine a class e.g., by adding information to a node or by adding new nodes4. 2.3 Managing identifiers We now introduce the treatment of identifiers supported by XMG. We show in particular, that it integrates: • a convenient way of managing identifier scope based on import/export declarations inspired from standard Object Oriented Programming techniques (section 2.3.1); • an alternative means of identifying feature values based on the use of unification • polarity- (here called colour-) based node identification as first proposed in (Muskens and Krahmer, 1998) and later used in (Duchier and Thater, 1999; Perrier, 2000). The next sections will detail the linguistic and technical motivations behind this variety of identifier handling techniques. 2.3.1 Import/Export declaration In XMG, the default scope of an identifier is the class in which it is declared. However, export specifications can be used to extend the scope of a given identifier outside its declaration class. The export of identifier ?X ouside class A is written :5 A?x --+ { ... ?X ... } Export declarations interact with inheritance, conjunction and disjunction specifications as follows (where A,B,C are classes): Inheritance: if the</context>
</contexts>
<marker>Duchier, Thater, 1999</marker>
<rawString>Denys Duchier and Stefan Thater. 1999. Parsing with tree descriptions: a constraint-based approach. In NLULP, pages 17–32, Las Cruces, New Mexico.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Evans</author>
<author>G Gazdar</author>
<author>D Weir</author>
</authors>
<title>Encoding lexicalized tree adjoining grammars with a nonmonotonic inheritance hierarchy.</title>
<date>1995</date>
<booktitle>In Proceedings of the 33rd Annual Meeting of the ACL,</booktitle>
<pages>77--84</pages>
<contexts>
<context position="1287" citStr="Evans et al., 1995" startWordPosition="181" endWordPosition="184">based grammars is well supported by the design of formalisms such as PATR-II, Ale or TDL (Krieger and Schafer, 1994), the situation is less well established for Tree-Based Grammars such as Tree Adjoining Grammars (Joshi and Schabes, 1997), Tree Description Grammars (Kallmeyer, 1996) or Interaction Grammars (Perrier, 2003). Roughly, two main types of specification formalism for Tree-Based Grammars can be distinguished: formalisms based on tree fragments and non monotonic inheritance and formalisms based on tree descriptions and monotonic inheritance. The tree fragment approach is advocated in (Evans et al., 1995) which proposes to encode lexicalised TAGs using the DATR representation language&apos;. In this approach, tree fragments are combined within a non monotonic inheritance hierarchy. Furthermore, new fragments can be derived from existing ones by means of lexical rules. This first approach suffers from the procedural character of non-monotonic inheritance. In specifying the grammar, the grammar writer must keep &apos;A tree based approach is also used in(Becker, 2000) but this time in combination with metarules. In that particular approach, procedural aspects also come into play as the order in which meta</context>
</contexts>
<marker>Evans, Gazdar, Weir, 1995</marker>
<rawString>R. Evans, G. Gazdar, and D. Weir. 1995. Encoding lexicalized tree adjoining grammars with a nonmonotonic inheritance hierarchy. In Proceedings of the 33rd Annual Meeting of the ACL, 77-84.</rawString>
</citation>
<citation valid="true">
<authors>
<author>B Gaiffe</author>
<author>B Crabbe</author>
<author>A Roussanaly</author>
</authors>
<title>A new metagrammar compiler.</title>
<date>2002</date>
<journal>C. Gardent</journal>
<booktitle>In Proceedings of TAG+6,</booktitle>
<location>Venice.</location>
<contexts>
<context position="4257" citStr="Gaiffe et al., 2002" startWordPosition="645" endWordPosition="648">sfied by more trees than intended). The second option greatly degrades 247 Proceedings of the COLING/ACL 2006 Main Conference Poster Sessions, pages 247–254, Sydney, July 2006. c�2006 Association for Computational Linguistics modularity as the grammar writer must remember which names were used where and with which interpretation. As we shall see below, it also has the undesirable effect that the same tree fragment cannot be used twice in a given tree description. Nevertheless, this is the option that is adopted in most grammar formalisms and grammar compilers (Candito, 1996; Xia et al., 1999; Gaiffe et al., 2002). In this paper, we present an approach which remedies these shortcomings by combining monotonic inheritance of tree descriptions with an explicit management of identifier scope and identifiers equality2. The proposed approach thus eschews both the inconvenients induced by a non monotonic framework (by using tree descriptions rather than trees) and those resulting from a global treatment of identifiers (by providing greater expressivity wrt identifiers). Specifically, we show that the proposed approach supports several ways of identifying (node or feature) values, we motivate this multiplicity</context>
</contexts>
<marker>Gaiffe, Crabbe, Roussanaly, 2002</marker>
<rawString>B. Gaiffe, B. Crabbe, and A. Roussanaly. 2002. A new metagrammar compiler. In Proceedings of TAG+6, Venice. C. Gardent and L. Kallmeyer. 2003. Semantic construction in FTAG. In Proceedings of EACL’03, Budapest.</rawString>
</citation>
<citation valid="true">
<authors>
<author>C Gardent</author>
</authors>
<title>Int´egration d’une dimension s´emantique dans les grammaires d’arbres adjoints.</title>
<date>2006</date>
<booktitle>In Actes de La 13`eme ´edition de la conf´erence sur le TALN (TALN2006).</booktitle>
<contexts>
<context position="11897" citStr="Gardent, 2006" startWordPosition="1941" endWordPosition="1943"> ... ?X ... }* = [n1 = ?X] B { ... ?Y ... }* = [n1 = ?Y] In A (resp. B), the local identifier ?X (resp. ?Y) is associated with an interface feature named n1. If 249 these two classes are combined either by conjunction or by inheritance, their interfaces are unified and as a result, the local identifiers ?X and ?Y are unified. In the case of a disjunction, the interface of the current class (C here) is non deterministically unified with that of A or B. In practice, interface-based identification of values is particularly useful when two distinct features need to be assigned the same value. In (Gardent, 2006) for instance, it is used to identify the semantic index associated with e.g., the subject node of a verbal tree and the corresponding semantic index in the semantic representation associated with that tree. 2.3.3 Colouring nodes Finally, XMG provides a very economical way of identifying node variables based on the use of colours (also called polarities in the literature). The idea is that node variables are associated with a specific colour and that this colouring will either prevent or trigger node identifications based on the following identification rules: •B •R ◦W ⊥ •B ⊥ ⊥ •B ⊥ •R ⊥ ⊥ ⊥ ⊥</context>
<context position="21588" citStr="Gardent, 2006" startWordPosition="3741" endWordPosition="3742">sed in section 2.3, node identifications can be based on colours. In particular, if a node is white, it must be identified with a black node. The main advantage of this particular identification mechanism is that it is extremely economical. Not only is there no longer any need to remember names, there is in fact no need to chose a name. When developing a metagrammar containing several hundreds of nodes, this is a welcome feature. This “no-name” aspect of the colour mechanism is in particular very useful when a given class needs to be combined with many other classes. For instance, in SEMFRAG (Gardent, 2006), the semantic index of a semantic functor (i.e., a verb, v • pp • v • pp • pp • p • n • p • n • p • n • Figure 6: Case of double prepositional phrase with coloured descriptions. As for exports however, colours cannot always be used to force identifications. First, colours can only be used in combination with conjunction or inheritance of non exported identifiers. Indeed, inheritance does not allow the identification of two different objects. Hence if a class C containing a white node named ?X inherits from another class C’ exporting a black node also named ?X, compilation will fail as a given</context>
</contexts>
<marker>Gardent, 2006</marker>
<rawString>C. Gardent. 2006. Int´egration d’une dimension s´emantique dans les grammaires d’arbres adjoints. In Actes de La 13`eme ´edition de la conf´erence sur le TALN (TALN2006).</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Joshi</author>
<author>Y Schabes</author>
</authors>
<title>Tree-adjoining grammars.</title>
<date>1997</date>
<booktitle>Handbook of Formal Languages,</booktitle>
<volume>3</volume>
<pages>69--124</pages>
<editor>In G. Rozenberg and A. Salomaa, editors,</editor>
<publisher>Springer,</publisher>
<location>Berlin, New York.</location>
<contexts>
<context position="906" citStr="Joshi and Schabes, 1997" startWordPosition="127" endWordPosition="130">er@loria.fr Abstract We claim that existing specification languages for tree based grammars fail to adequately support identifier managment. We then show that XMG (eXtensible MetaGrammar) provides a sophisticated treatment of identifiers which is effective in supporting a linguist-friendly grammar design. 1 Specifying tree-based grammars Whilst the development of standard unificationbased grammars is well supported by the design of formalisms such as PATR-II, Ale or TDL (Krieger and Schafer, 1994), the situation is less well established for Tree-Based Grammars such as Tree Adjoining Grammars (Joshi and Schabes, 1997), Tree Description Grammars (Kallmeyer, 1996) or Interaction Grammars (Perrier, 2003). Roughly, two main types of specification formalism for Tree-Based Grammars can be distinguished: formalisms based on tree fragments and non monotonic inheritance and formalisms based on tree descriptions and monotonic inheritance. The tree fragment approach is advocated in (Evans et al., 1995) which proposes to encode lexicalised TAGs using the DATR representation language&apos;. In this approach, tree fragments are combined within a non monotonic inheritance hierarchy. Furthermore, new fragments can be derived f</context>
</contexts>
<marker>Joshi, Schabes, 1997</marker>
<rawString>A. Joshi and Y. Schabes. 1997. Tree-adjoining grammars. In G. Rozenberg and A. Salomaa, editors, Handbook of Formal Languages, volume 3, pages 69 – 124. Springer, Berlin, New York.</rawString>
</citation>
<citation valid="true">
<authors>
<author>L Kallmeyer</author>
</authors>
<title>Tree description grammars.</title>
<date>1996</date>
<booktitle>In Results of the 3rd KONVENS Conference, pages 330 – 341. Mouton de Gruyter ed.,</booktitle>
<location>Hawthorne, NY, USA.</location>
<contexts>
<context position="951" citStr="Kallmeyer, 1996" startWordPosition="134" endWordPosition="135">tion languages for tree based grammars fail to adequately support identifier managment. We then show that XMG (eXtensible MetaGrammar) provides a sophisticated treatment of identifiers which is effective in supporting a linguist-friendly grammar design. 1 Specifying tree-based grammars Whilst the development of standard unificationbased grammars is well supported by the design of formalisms such as PATR-II, Ale or TDL (Krieger and Schafer, 1994), the situation is less well established for Tree-Based Grammars such as Tree Adjoining Grammars (Joshi and Schabes, 1997), Tree Description Grammars (Kallmeyer, 1996) or Interaction Grammars (Perrier, 2003). Roughly, two main types of specification formalism for Tree-Based Grammars can be distinguished: formalisms based on tree fragments and non monotonic inheritance and formalisms based on tree descriptions and monotonic inheritance. The tree fragment approach is advocated in (Evans et al., 1995) which proposes to encode lexicalised TAGs using the DATR representation language&apos;. In this approach, tree fragments are combined within a non monotonic inheritance hierarchy. Furthermore, new fragments can be derived from existing ones by means of lexical rules. </context>
</contexts>
<marker>Kallmeyer, 1996</marker>
<rawString>L. Kallmeyer. 1996. Tree description grammars. In Results of the 3rd KONVENS Conference, pages 330 – 341. Mouton de Gruyter ed., Hawthorne, NY, USA.</rawString>
</citation>
<citation valid="true">
<authors>
<author>H-U Krieger</author>
<author>U Schafer</author>
</authors>
<title>TDL – a type description language for constraint-based grammars.</title>
<date>1994</date>
<booktitle>In Proceedings of COLING-94,</booktitle>
<pages>893--899</pages>
<contexts>
<context position="784" citStr="Krieger and Schafer, 1994" startWordPosition="108" endWordPosition="111">nick Parmentier INRIA Lorraine 615, rue du jardin botanique, B.P. 101 54602 Villers l`es Nancy CEDEX France Yannick.Parmentier@loria.fr Abstract We claim that existing specification languages for tree based grammars fail to adequately support identifier managment. We then show that XMG (eXtensible MetaGrammar) provides a sophisticated treatment of identifiers which is effective in supporting a linguist-friendly grammar design. 1 Specifying tree-based grammars Whilst the development of standard unificationbased grammars is well supported by the design of formalisms such as PATR-II, Ale or TDL (Krieger and Schafer, 1994), the situation is less well established for Tree-Based Grammars such as Tree Adjoining Grammars (Joshi and Schabes, 1997), Tree Description Grammars (Kallmeyer, 1996) or Interaction Grammars (Perrier, 2003). Roughly, two main types of specification formalism for Tree-Based Grammars can be distinguished: formalisms based on tree fragments and non monotonic inheritance and formalisms based on tree descriptions and monotonic inheritance. The tree fragment approach is advocated in (Evans et al., 1995) which proposes to encode lexicalised TAGs using the DATR representation language&apos;. In this appro</context>
</contexts>
<marker>Krieger, Schafer, 1994</marker>
<rawString>H.-U. Krieger and U. Schafer. 1994. TDL – a type description language for constraint-based grammars. In Proceedings of COLING-94, pp. 893–899.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Muskens</author>
<author>E Krahmer</author>
</authors>
<title>Description theory, ltags and underspecified semantics.</title>
<date>1998</date>
<booktitle>In TAG’4.</booktitle>
<contexts>
<context position="8422" citStr="Muskens and Krahmer, 1998" startWordPosition="1331" endWordPosition="1334">ted class within the current one. This makes it possible to refine a class e.g., by adding information to a node or by adding new nodes4. 2.3 Managing identifiers We now introduce the treatment of identifiers supported by XMG. We show in particular, that it integrates: • a convenient way of managing identifier scope based on import/export declarations inspired from standard Object Oriented Programming techniques (section 2.3.1); • an alternative means of identifying feature values based on the use of unification • polarity- (here called colour-) based node identification as first proposed in (Muskens and Krahmer, 1998) and later used in (Duchier and Thater, 1999; Perrier, 2000). The next sections will detail the linguistic and technical motivations behind this variety of identifier handling techniques. 2.3.1 Import/Export declaration In XMG, the default scope of an identifier is the class in which it is declared. However, export specifications can be used to extend the scope of a given identifier outside its declaration class. The export of identifier ?X ouside class A is written :5 A?x --+ { ... ?X ... } Export declarations interact with inheritance, conjunction and disjunction specifications as follows (w</context>
</contexts>
<marker>Muskens, Krahmer, 1998</marker>
<rawString>R. Muskens and E. Krahmer. 1998. Description theory, ltags and underspecified semantics. In TAG’4.</rawString>
</citation>
<citation valid="true">
<authors>
<author>G Perrier</author>
</authors>
<title>Interaction grammars.</title>
<date>2000</date>
<booktitle>In Proceedings of 18th International Conference on Computational Linguistics (CoLing</booktitle>
<location>Sarrebrcken.</location>
<contexts>
<context position="8482" citStr="Perrier, 2000" startWordPosition="1343" endWordPosition="1344">ss e.g., by adding information to a node or by adding new nodes4. 2.3 Managing identifiers We now introduce the treatment of identifiers supported by XMG. We show in particular, that it integrates: • a convenient way of managing identifier scope based on import/export declarations inspired from standard Object Oriented Programming techniques (section 2.3.1); • an alternative means of identifying feature values based on the use of unification • polarity- (here called colour-) based node identification as first proposed in (Muskens and Krahmer, 1998) and later used in (Duchier and Thater, 1999; Perrier, 2000). The next sections will detail the linguistic and technical motivations behind this variety of identifier handling techniques. 2.3.1 Import/Export declaration In XMG, the default scope of an identifier is the class in which it is declared. However, export specifications can be used to extend the scope of a given identifier outside its declaration class. The export of identifier ?X ouside class A is written :5 A?x --+ { ... ?X ... } Export declarations interact with inheritance, conjunction and disjunction specifications as follows (where A,B,C are classes): Inheritance: if the class A is impo</context>
</contexts>
<marker>Perrier, 2000</marker>
<rawString>G. Perrier. 2000. Interaction grammars. In Proceedings of 18th International Conference on Computational Linguistics (CoLing 2000), Sarrebrcken.</rawString>
</citation>
<citation valid="true">
<authors>
<author>G Perrier</author>
</authors>
<title>Les grammaires d’interaction. HDR en informatique,</title>
<date>2003</date>
<journal>Universit´e Nancy</journal>
<volume>2</volume>
<contexts>
<context position="991" citStr="Perrier, 2003" startWordPosition="139" endWordPosition="140">l to adequately support identifier managment. We then show that XMG (eXtensible MetaGrammar) provides a sophisticated treatment of identifiers which is effective in supporting a linguist-friendly grammar design. 1 Specifying tree-based grammars Whilst the development of standard unificationbased grammars is well supported by the design of formalisms such as PATR-II, Ale or TDL (Krieger and Schafer, 1994), the situation is less well established for Tree-Based Grammars such as Tree Adjoining Grammars (Joshi and Schabes, 1997), Tree Description Grammars (Kallmeyer, 1996) or Interaction Grammars (Perrier, 2003). Roughly, two main types of specification formalism for Tree-Based Grammars can be distinguished: formalisms based on tree fragments and non monotonic inheritance and formalisms based on tree descriptions and monotonic inheritance. The tree fragment approach is advocated in (Evans et al., 1995) which proposes to encode lexicalised TAGs using the DATR representation language&apos;. In this approach, tree fragments are combined within a non monotonic inheritance hierarchy. Furthermore, new fragments can be derived from existing ones by means of lexical rules. This first approach suffers from the pro</context>
</contexts>
<marker>Perrier, 2003</marker>
<rawString>G. Perrier. 2003. Les grammaires d’interaction. HDR en informatique, Universit´e Nancy 2.</rawString>
</citation>
<citation valid="true">
<authors>
<author>K Vijay-Shanker</author>
<author>Y Schabes</author>
</authors>
<title>Structure sharing in lexicalized tree adjoining grammars.</title>
<date>1992</date>
<booktitle>In Proceedings of COLING’92, Nantes,</booktitle>
<pages>205--212</pages>
<contexts>
<context position="2711" citStr="Vijay-Shanker and Schabes, 1992" startWordPosition="402" endWordPosition="405">inheritance in determining the final output. When developing a large coverage grammar, this rapidly become extremely cumbersome. Moreover, as (Candito, 1996) remarks, nonmonotonicity may result in an information loss which makes it impossible to express the relation existing for instance between an active object and the corresponding passive subject. The approach based on tree descriptions (often called, the metagrammar approach) obviates the procedural character of the non-monotonic approach by taking tree descriptions rather than trees to be the basic units (Candito, 1996; Xia et al., 1999; Vijay-Shanker and Schabes, 1992). In essence, tree fragments are described using tree descriptions and tree descriptions are combined through conjunction or inheritance. The idea is that the minimal models satisfying the resulting descriptions are TAG elementary trees. In some cases, lexical rules are also used to derive new trees from existing ones. One main drawback with this second type of approach concerns the management of node identifiers. Either nodes are represented by nameless variables and node identification is forced by well-formedness constraints e.g., wff-constraints on trees and wff-constraints given by the in</context>
</contexts>
<marker>Vijay-Shanker, Schabes, 1992</marker>
<rawString>K. Vijay-Shanker and Y. Schabes. 1992. Structure sharing in lexicalized tree adjoining grammars. In Proceedings of COLING’92, Nantes, pp. 205 - 212.</rawString>
</citation>
<citation valid="true">
<authors>
<author>E Villemonte de la Clergerie</author>
</authors>
<title>DyALog: a tabular logic programming based environment for NLP.</title>
<date>2005</date>
<booktitle>In Proceedings of CSLP’05,</booktitle>
<location>Barcelona.</location>
<contexts>
<context position="5737" citStr="Clergerie, 2005" startWordPosition="881" endWordPosition="882">de or variable) identifiers. In section 4, we motivate each of these four different ways and indicate when each of them can and should be used. 2 The XMG formalism We start by briefly introducing XMG (eXtended MetaGrammar). First, we show that it supports the description and the combination of blocks consisting of tree fragments and/or semantic representations. Then, we show that it supports a sophisticated treatment of identifiers. 2.1 Defining blocks At the syntactic level, the basic units are tree descriptions which are specified using the following tree logic: 2Recently, (Villemonte de la Clergerie, 2005) has proposed a highly compact representation formalism for treebased grammars which also features explicit identifier management. His approach differs from ours in that it includes neither a colouring mechanism (cf. section 3.4) nor interfaces (cf. section 3.3). Description ::= x --+ y |x --++ y |x --+* y |(1) x � y |x +y |x �* y | x[f:El |x = y | Description n Description where x, y represent node variables, —* immediate dominance (x is directly above y), —*+ strict dominance (x is above y), and —** large dominance3 (x is above or equal to y). Similarly � denotes immediate precedence, �+ str</context>
</contexts>
<marker>Clergerie, 2005</marker>
<rawString>E. Villemonte de la Clergerie. 2005. DyALog: a tabular logic programming based environment for NLP. In Proceedings of CSLP’05, Barcelona.</rawString>
</citation>
<citation valid="true">
<authors>
<author>F Xia</author>
<author>M Palmer</author>
<author>K Vijay-Shanker</author>
</authors>
<title>Toward semi-automating grammar development.</title>
<date>1999</date>
<booktitle>In Proc. of NLPRS-99,</booktitle>
<location>Beijing, China.</location>
<contexts>
<context position="2677" citStr="Xia et al., 1999" startWordPosition="398" endWordPosition="401">and non-monotonic inheritance in determining the final output. When developing a large coverage grammar, this rapidly become extremely cumbersome. Moreover, as (Candito, 1996) remarks, nonmonotonicity may result in an information loss which makes it impossible to express the relation existing for instance between an active object and the corresponding passive subject. The approach based on tree descriptions (often called, the metagrammar approach) obviates the procedural character of the non-monotonic approach by taking tree descriptions rather than trees to be the basic units (Candito, 1996; Xia et al., 1999; Vijay-Shanker and Schabes, 1992). In essence, tree fragments are described using tree descriptions and tree descriptions are combined through conjunction or inheritance. The idea is that the minimal models satisfying the resulting descriptions are TAG elementary trees. In some cases, lexical rules are also used to derive new trees from existing ones. One main drawback with this second type of approach concerns the management of node identifiers. Either nodes are represented by nameless variables and node identification is forced by well-formedness constraints e.g., wff-constraints on trees a</context>
<context position="4235" citStr="Xia et al., 1999" startWordPosition="641" endWordPosition="644">ption will be satisfied by more trees than intended). The second option greatly degrades 247 Proceedings of the COLING/ACL 2006 Main Conference Poster Sessions, pages 247–254, Sydney, July 2006. c�2006 Association for Computational Linguistics modularity as the grammar writer must remember which names were used where and with which interpretation. As we shall see below, it also has the undesirable effect that the same tree fragment cannot be used twice in a given tree description. Nevertheless, this is the option that is adopted in most grammar formalisms and grammar compilers (Candito, 1996; Xia et al., 1999; Gaiffe et al., 2002). In this paper, we present an approach which remedies these shortcomings by combining monotonic inheritance of tree descriptions with an explicit management of identifier scope and identifiers equality2. The proposed approach thus eschews both the inconvenients induced by a non monotonic framework (by using tree descriptions rather than trees) and those resulting from a global treatment of identifiers (by providing greater expressivity wrt identifiers). Specifically, we show that the proposed approach supports several ways of identifying (node or feature) values, we moti</context>
</contexts>
<marker>Xia, Palmer, Vijay-Shanker, 1999</marker>
<rawString>F. Xia, M. Palmer, and K. Vijay-Shanker. 1999. Toward semi-automating grammar development. In Proc. of NLPRS-99, Beijing, China.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>