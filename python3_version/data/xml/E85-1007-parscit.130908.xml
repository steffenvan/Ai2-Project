<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<title confidence="0.535437857142857">
SAUMER : SENTENCE ANALYSIS USING METARULES
Fred Popowich
Natural Language Group
Laboratory for Computer and Communications Research
Department of Computing Science
Simon Fraser University
Burnaby. B.C., CANADA V5A 1S6
</title>
<sectionHeader confidence="0.853739" genericHeader="abstract">
ABSTRACT
</sectionHeader>
<bodyText confidence="0.99936675">
The SAUMER system uses specifications of natural
language grammars. which consist of rules and metarules.
to provide a semantic interpretation of an input sentence.
The SAUMER &apos; Specification Language (SSL) is a
programming language which combines some of the
features of generalised phrase structure grammars (Gazdar.
1981). like the correspondence between syntactic and
semantic rules, with definite clause grammars (DCGs)
(Pereira and Warren, 1980) to create an executable
grammar specification. SSL rules are similar to DCG rules
except that they contain a semantic component and may
also be left recursive. Metarules are used to generate new
rules from existing rules before any parsing is attempted.
An implementation is tested which can provide semantic
interpretations for sentences containing topicalisation.
relative clauses. passivisation, and questions.
</bodyText>
<sectionHeader confidence="0.999303" genericHeader="introduction">
1. INTRODUCTION
</sectionHeader>
<bodyText confidence="0.9997535">
The SAUMER system allows the user to specify a
grammar for a natural language using rules and metarules
This grammar can then be used to obtain a semantic
interpretation of an Input sentence. The SAUMER
Specification I anguage (SSL). which is a variation of
definite clause grammars (DCGs) (Pereira and Warren.
1980). captures some of the features of generalised phrase
structure grammars (GPSGs) (Gazdar. 1981) (Gazdar and
Pullum. 1982), like rule schemata, rule transformations.
structured categories. slash categories, and the
correspondence between syntactic and semantic rules. The
semantics currently used in the system are based on
Schubert and Pelletier s description in (Schubert and
Pelletier. 1982). which adapts the intensional logic
interpretation associated with GPSGs. into a more
conventional logical notation.
</bodyText>
<sectionHeader confidence="0.998737" genericHeader="method">
2. THE SEMANTIC LOGICAL NOTATION
</sectionHeader>
<bodyText confidence="0.993552666666667">
The logical notation associated with the grammar
differs from. the usual notation of intensional logic_since it
captures some intuitive aspects. of natural language.&apos;
</bodyText>
<note confidence="0.486721">
1It should abo be noted that, due to the separability of the semantic
component from the grammar rule, a different semantic notation could
easily be introduced as long as the appropriate semantic processing
</note>
<bodyText confidence="0.987543048780488">
Thus, individuals and objects are treated as entities.
instead of collections of properties, and actions are n-ary
relations between these entities. Many of the problems
that the intensional notation would solve are handled by
allowing ambiguity to be represented in the logical
notation. Consequently. as is common in other approaches.
(e.g.. Gawron. 1982). much of the processing is deferred to
the pragmatic stage. The structure of the lexicon. and the
appearance of post processing markers (sharp angle
brackets) are designed to reflect this ambiguity. The
lexicon is organised into two levels. For the semantic
interpretation, the first level gives each word a tentative
interpretation. During the pragmatic analysis. more
complete processing information will result in the final
interpretation being obtained from the second level of the
lexicon. For example. the sentence John misses John could
be given an initial interpretation of:
(2.1) [ Johnl miss2 John3
with John!, miss2 and John3 obtained from the first level
of the two level lexicon. The pragmatic stage will
determine if John] and John3 both refer to the same
entry, say JOHN_SMITH1. of the second level of the
lexicon, or if they correspond to different entries, say
JOHN_JONESI and JOHN_EVANS1. During the
pragmatic stage. the entry of MISS which is referred to
by miss2 will be determined (if possible). For example.
does John miss John because he has been away for a long
time, or is it because he is a poor shot with a rifle?
Any interpretation contained in sharp angle brackets.
&lt;...&gt;. may require post processing. This is apparent in
interpretations containing determiners and co-ordinators.
The proverb:
(2.2) every man loves some woman
could be given the interpretation:
(2.3) [ &lt;everyl man2&gt; love3 &lt;some4 woman5 &gt;1
without explicitly stating which of the two readings is
intended. During pragmatic analysis. the scope of every
and some would presumably be determined.
routines were replaced. The use of SAUMER with an &apos;Al-adapted&apos;
version of Montagues Intensional Logic* is being examined by Fawcett
(1984).
</bodyText>
<page confidence="0.998561">
48
</page>
<bodyText confidence="0.904199714285714">
The syntax of this logical notation can be summarised
as follows. Sentences and compound predicate formulas
are contained within square brackets. So. (2.4) states that
John wants to kiss Mary:
(2.4) [Johnl want2 (Johnl kiss3 Mary4D
These formulas can also be expressed equivalently in a
more functional form according to the equivalence
(2.5) 1 tn P t1 . . . tn_ )
( . . . ( (P t1) t2) . . . tn )
( P t . tn )
Consequently. (2.4) could also be represented as:
(2.6) ((want2 ( (kiss3 Mary4) Johnl)) Johnl)
However, this notation is usually used for incomplete
phrases. with the square brackets used to obtain a
conventional final reading Modified predicate formulas
are contained in braces. Thus, a little dog likes Fido could
be expressed as:
(2.7) [&lt;al I little2 dog3) &gt; likes4 Fido5)
The lambda calculus operations of lambda abstraction and
elimination are also allowed. When a variable is
abstracted from an expression as in:
</bodyText>
<figure confidence="0.968698">
(2.8) Xx I x want2 [ x love3 Mary4 )
application of this new expression to an argument. say
John):
(2.9) ( Ax [ x want2 ( x love3 Mary4 ) ) Johnl )
</figure>
<bodyText confidence="0.9294675">
will result in an interpretation of John wants to love Mary:
(2.10) [ Johnl want2 [ Johnl love3 Mary4
Further details on this notation are available in (Schubert
and Pelletier, 1982).
</bodyText>
<sectionHeader confidence="0.995228" genericHeader="method">
3. THE SAUMER SPECIFICATION LANGUAGE
</sectionHeader>
<bodyText confidence="0.998847444444445">
The SA UMER Specification Language (SSL) is a
programming _ language that. allows the user to define a
grammar of a natural language in terms of rules, and
metarules. Metarules operate on rules to produce new
rules. The language is basically a GPSG realised in a
DCG setting. Unlike GPSGs. the grammars defined by
this system are not required to be context-free since
procedure calls are allowed within the rules, and since
logic variables are allowed in the grammar symbols.
The basic objects of the language are atoms, variables.
terms, and lists. Any word starting with a lower case
letter, or enclosed in single quotes is an atom. Variables
start with a capital letter or an underscore. A term is an
atom, optionally followed by a series of objects
(arguments). which are enclosed in parentheses and
separated by commas. Lastly. a list is a series of one or
more objects. separated by commas, that are enclosed in
square brackets
</bodyText>
<subsectionHeader confidence="0.998421">
3.1 Rules
</subsectionHeader>
<bodyText confidence="0.999871571428571">
The rules are presented in a variation of the DCG
notation, augmented with a semantic rule corresponding to
each synta‘ tic rule. Each rule is of the form
&amp;quot;A —&gt; 0 : y* where A is a term which denotes a
nonterminal symbol, is either an atom list representing
a terminal symbol or a conjunction of terms (separated by
commas) corresponding to nonterminal symbols. and y is a
semantic rule which may reference the interpretation of
the components of 0 in determining the semantics of A.
The rule arrow. — &gt; . separates the two sides of the rule.
with the colon. :. separating the syntactic component from
the semantic component. If the rule is preceded by the
word add, it can be subjected to the transformations
described in section 3.2. The nonterminal symbols can
</bodyText>
<listItem confidence="0.959865333333333">
• possess arguments. which may be used to capture the
• flavour of the structured categories of GPSGs. 0 may also
possess arbitrary procedural restrictions contained in braces.
</listItem>
<bodyText confidence="0.988271848484849">
y consists of expressions in the semantic notation.
The different terms of this semantic expression are joined
by the semantic connector, the ampersand &amp;quot;&amp;&amp;quot;. The
ampersand differ p from the syntactic connector, the
comma since the former associates to the right while the
latter associates to the left. The logical and symbol.
which traditionally may also be denoted by the
ampersand. must be entered as &amp;quot;&amp;&amp;&amp;quot;. Due to constraints
imposed by the current implementation. &amp;quot;&lt; expr must
be entered as &amp;quot;&lt;I expr I&amp;quot;. • &lt; expr &gt;• as • &lt;&lt;[ expr r.
and &amp;quot;X x expr&amp;quot; as &amp;quot;a lmda expr.&amp;quot; An expression may
contain references to the interpretations of the elements of
0 by stating the appropriate nonterminal followed by the
left quote, &apos;. To prevent ambiguity in &apos;these references
that may arise when two identical symbols appear in 0. a
nonterminal may be appended with a minus sign followed
by a unique integer.
Unlike standard Prolog implementations of DCGs. left
recursion is allowed in rules, thus permitting more natural
descriptions of certain phenomena ( like co-ordination).
Since the left recursive rules are interpreted, rather than
converted into rules that are not left recursive, the
number of rules in the database will not be affected.
However, the efficiency of the sentence analysis may be
affected due to the extra processing required. Rules of
the form &amp;quot;A - -&gt; A. A&amp;quot; are not accepted.
An example of a production that derives John from a
proper noun. /yr. is shown in (3.1):
(3.1) npr —&gt; [&apos;John&apos;] : *John&apos;#
The semantic interpretation of this npr will be John#.
with &amp;quot;*&amp;quot; replaced by a unique integer during evaluation.
(3.2) illustrates a verb phrase rule that could be used in
sentences like John wants to walk:
</bodyText>
<listItem confidence="0.567370666666667">
(3.2) vp( Num) —&gt;
v(Num.Root) with Root in [wantlike]. vp(inf )
x## lmda [ x## &amp; &amp; [x## &amp; v1:11)
</listItem>
<page confidence="0.997492">
49
</page>
<bodyText confidence="0.992052285714285">
First notice that a restriction on the verb appears within
the with statement. In the GPSG formalism, this type of
restriction would be obtained by naming the rules and
associating a list of valid rule names with each lexical
entry. Although the with restriction may contain any
valid procedure. typically the in operation (for determining
list membership) is used. The double pound. #*, is
replaced by the same unique integer in the entire
expression when the expression is evaluated. If &apos;*&amp;quot; were
used instead, each instance of x# would be different. For
the above example. if v&apos; is want2 and vp&apos; is ritn3. then
the semantic expression could evaluate to:
(3.3) x4 lmda [x4 &amp; want2 &amp; [x4 &amp; run3]]
Furthermore, if np&apos; is Johnl. then:
</bodyText>
<listItem confidence="0.761873333333333">
(3.4) [rip&apos; &amp; VP.]
could result in:
(3.5) [John 1 &amp; want2 &amp; [Johnl &amp; run3]]
</listItem>
<subsectionHeader confidence="0.998826">
3.2 The Metarules
</subsectionHeader>
<bodyText confidence="0.9995148">
Traditional transformational grammars provide
transformations that operate on parse trees, or similar
structures, and often require the transformations to be
used in sentence recognition rather than in generation
(Radford. 1981). However, the approach suggested by
(Gazdar. 1981) uses the transformations generatively and
applies them to the grammar. Thus, the grammar can
remain context-free by compiling this transformational
knowledge into the grammar. Transformations and rule
schemata form the metarides of SSL.2
Rule schemata allow the user to specify entire classes
of rules by permitting variables which range over a
selection of categories to appear in the rule. To control
the values of the variables, the fora control structure can
be used in the schema declaration. The schema
forall X in List, Body will execute Body for each element
of List. with X instantiated to the current element. The
use of this statement is illustrated in the following
metarule that generates the terminal productions for proper
nouns:
</bodyText>
<listItem confidence="0.537088">
(3.6) forall Terminal in r
</listItem>
<bodyText confidence="0.987415296296297">
(epr —&gt; [Terminal] : Terminal#) .
The syntactic pattern. a —&gt; 03. contains nonterminals.
which correspond to symbols that must appear in the
matched rule, and free variables, which represent don&apos;t
care- regions of zero or more nonterminals. The pattern
nonterminals may also possess arguments. For each rule
symbol. a matching pattern symbol describes properties
that must exist, but not all the properties that may exist.
Thus, if vp appeared in the pattern, it would match any
of vp. vp(Iihan). or vp(Num,Type) with Type in &apos;trans].
However. pp(to) would not match pp or pp(from). but it
would match pp(to,_). The matching conditions are
summarised in Figures 3-1 and 3-2. In Figure 3-1. A and
B are nonterminals. X is a free variable, and a and 0 are
conjunctions of one or more symbols. y and 8 of Figure
3-2 are also conjunctions of one or more symbols. is
defined as unification (Clocksin and Mellish. 1981). Parts
of the rule contained in braces are ignored by the pattern
matcher. The syntactic pattern may also contain arbitrary
restrictions.3 enclosed in braces, that are evaluated during
the pattern match. The semantic pattern. y. is very
primitive. It may contain a free variable, which will
bind to the entire semantics field of the matched rule, or
it may contain the structure &lt;[? x]. which will bind to
the entire structure containing the symbol x. If &lt;[? y]
then appears in y&apos;. the result will be the semantic
component of the matched rule with x replaced by y.
</bodyText>
<subsectionHeader confidence="0.485466">
Rule
</subsectionHeader>
<bodyText confidence="0.913946857142857">
(B4O)
A matches B A matches B and
and a matches /3 a is a free variable
(X. a) matches a matches B
or a matches (B. P)
No A matches B
Yes Yes
</bodyText>
<figureCaption confidence="0.816329">
Figure 3-12, Pattern Matching for Conjunctions
</figureCaption>
<figure confidence="0.989148">
Rule
b(131. b($.....$) with 8
Pattern
(A. a)
(X. ot)
A
X
</figure>
<bodyText confidence="0.9929955">
Transformations match with grammar rules in the
database, using a rule pattern that may be augmented
with arbitrary procedures, and produce new rules from
the old rules. A transformation is of the form:
</bodyText>
<figure confidence="0.384681333333333">
Pattern
a(c4i. a = b. znn. a = b. m n.
1im = I i m
(3.7) a —&gt; : y a&apos; —&gt; : y&apos;
The metarule arrow. separates the pattern.
a —&gt; : y. from the template. a&apos; —&gt; 0&apos; :
</figure>
<figureCaption confidence="0.28306275">
20f ten. metarules are considered to consist of transformations only,
while schemata are put into a category of their own. However, since
they can both be considered as part of a metagrammar, they are called
metarules in this discussion.
</figureCaption>
<figure confidence="0.415767666666667">
a(csi. No a = b. m n.
with y a$1. 1im.
y matches 8
</figure>
<figureCaption confidence="0.826384">
Figure Pattern Matching for Nonterminals
</figureCaption>
<footnote confidence="0.8914045">
3Apparently not present in the Hewlett Packard system (Gawron,
1982) or the ProGram system (Evans and GaMar, 1984)
</footnote>
<page confidence="0.994094">
50
</page>
<bodyText confidence="0.993728857142857">
The behaviour of patterns can be seen in the following
examples. Consider the sentence rule:
(3.8) s(decl) —&gt; np(nom.Numb).
vp(„Numb) with agreement(Numb)
: I np&apos; &amp; vp&apos;
The patterns shown in (3.9a) will match (3.8). while
those of (3.9b) will not match it.
</bodyText>
<listItem confidence="0.7356375">
(3.9) (a) s(A) —&gt; Inot element(A.Ifoopl. X. vp : Sem
s --&gt; np(nom). X. vp(pass). Y : Sem
(b) s(inter) —&gt; fly. vp : Sem
s —&gt; vp : Sem
</listItem>
<bodyText confidence="0.953128847826087">
For the verb phrase rule shown in (3.10):
(3.10) vp(active.[M1N]) —&gt;
v(IMINLRoot.Type.....) with (intrans in Type)
: v*
the patterns of (3.11a) will result in a successful match.
will those of (3.11b) will not:
With external modification, any nonterminal. or
variable instantiated to a nonterminal. may be followed
by the sequence @mod. This will result in mod being
inserted into the argument list following the specified
arguments. Thus. if N@jstrik appeared in a rule when N
was instantiated to np(Incre). it would be expanded as
np(ntore Junk). Similarly, if the pattern symbol vp
matched vp( Numb) in a rule, then the appearance of
vp@ foo in the template would result in vp( foo ,Numb
appearing in the new rule. This extra argument.
introduced by the modifier, can be useful when dealing
with the missing components of slash or derived categories
(Gazdar. 1981).
Internal modification allows the modifier to be put
directly into the argument list. If an argument is
followed by @mod . it will be replaced by mod. In the
case where @mod appears as an argument by itself. mod is
added as a new argument. For example. if
v( Numb@ pastpart ) were contained in a template. it would
IT-match v( Nuntb) in the pattern, and would result in the
appearance of v( pastpart ) in the new rule.
For every rule that matches the pattern. the template
of the transformation is executed, resulting the creation of
a new rule. Any nonterminal. N. that matches a symbol
(3; on the left side of the transformation, will appear in
the new rule if there is a symbol pi. in /3&apos; that
intra-transfarmaticn (IT) matches with If there are
several symbols in ft&apos; that IT-match 8i. the leftmost
symbol will be selected. No symbol on one side of the
transformation may IT-match with more than one symbol
on the other side. Two symbols will IT-match only if
they have the same number of arguments. and those
arguments are identical. Any with expressions and
modifiers associated with symbols are ignored during IT-
matching. 3. may also contain extra symbols that do not
correspond to anything in 3. In this case, they are
inserted directly into the new rule. Once again, if the
transformation is preceded by the command add, then the
resulting rules can be subjected to subsequent
transformations.
</bodyText>
<subsectionHeader confidence="0.995466">
3.3 Modifiers
</subsectionHeader>
<bodyText confidence="0.99970075">
Both rules and rnetaniles may contains modifiers that
alter the structure of the nonterminal symbols. There are
two types of modification, which have been dubbed
external and internal modification.
</bodyText>
<sectionHeader confidence="0.999684" genericHeader="method">
4. IMPLEMENTATION
</sectionHeader>
<bodyText confidence="0.999908125">
The SAUMER system is currently implemented in
highly portable C-Prolog (Pereira. 1984), and runs on a
Motorola 68000 based SUN Workstation supporting UNIX°.
Calls to Prolog are allowed by the system, thus providing
useful tools for debugging grammars and tracing
derivations. However, due to the highly declarative
nature of SSL. it is not restricted to a Prolog
implementation. Implementations in other languages would
differ externally only in the syntax of the procedure calls
that may appear in each rule. Use of the system is
described in detail in (Popowich. 1985).
The current implementation converts the grammar as
specified by the rules and metarules into Prolog clauses.
This conversion can be examined in terms of how rules
are processed. and how the schemata and transformations
are processed.
</bodyText>
<subsectionHeader confidence="0.992457">
4.1 Rule Processing
</subsectionHeader>
<bodyText confidence="0.9999025">
The syntactic component of the rule processor is based
on Clocksin and Mellish&apos;s definite clause grammar
processor (Clocksin and Mellish. 1981) which has been
implemented in C-Prolog. For a DCG rule, each
nonterminal is converted into a Prolog predicate. with two
additional arguments, that can be processed by a top-down
parser. These extra arguments correspond to the list to be
parsed. and the remainder of the list after the predicate
has parsed the desired category. With the addition of
semantics to each rule, another argument is required to
represent the semantic interpretation of the current
symbol. Thus, whenever a left quoted category name. x&apos;.
</bodyText>
<footnote confidence="0.931586">
4UNDC is a trademark of Bell Laboratories
</footnote>
<figure confidence="0.98722">
(3.11) (a) vp —&gt; v : &lt;[? VI
vp —&gt; v(_._.Type._)
with (X. intrans in Type. Y).
Z: Sem
(b) vP
with (X. trans in Type)
:Sem
vp —&gt;
with (Root in [fool. X)
:Sem
</figure>
<page confidence="0.992172">
51
</page>
<bodyText confidence="0.978523857142857">
appears in the semantics of the rule. it is replaced by a
variable bound to the semantic argument of the
corresponding symbol. x. in the rule. The semantic
expression is then evaluated by the eval routine with the
result bound to the semantic argument of the nonterminal
on the left hand side of the production. For example. the
sentence rule:
</bodyText>
<figure confidence="0.685692923076923">
(4.1) add s(decl) &gt;
np(nom.Numb).
vp(_.Numb) with agreement(Numb)
: np° &amp; vp.
will result in a Prolog expression of the form:
(4.2) s(SemS.decl._1._3) :-
np(SemNP.nom.Numb._1._2).
vp(SemVP._.Numb._2._3).
agreement(Numb).
evalaemNP &amp; SemVPI.SemS).
Consequently. to process the sentence John runs. one
would try to satisfy:
(4.3) :- s(Seln, Type. Vlohn&apos;suns]. (I).
</figure>
<bodyText confidence="0.971096878787879">
The first argument returns the interpretation, the second
argument returns the type of sentence, the third is the
initial input list, and the final argument corresponds to
the list remaining after finding a sentence. Any rule R.
that is preceded by add will have the axiom rule(R)
inserted into the database. These axioms are used by the
transformations during pattern matching.
The evil/ routine processes the suffix symbols. * and
#* along with the lambda expressions. and may perform
some- reorganisation of the given expression- before
returning a new semantic form. For each expression of
the form name*. a unique integer N is created and
name-N is returned. With &amp;quot;**&amp;quot;. the procedure is the
same except that the first occurrence of ***° will generate
a unique integer that will be saved for all subsequent
occurrences. To evaluate an expression of the form:
(4.4) ( expri Linda exprj &amp; X)
every subexpression of expri is recursively searched for an
occurrence of expri, which is then replaced by X.
Left recursion is removed with the aid of a gap
predicate identical to the one defined to process gapping
grammars (Dahl and Abramson 1984) and unrestricted
gapping grammars (Popowich. forthcoming). For any rule
of the form:
(4.5) A -&gt; A. B. a
where A does not equal B. the result of the translation is:
(4.6) A(_I .Nn) gap(G._1._2). B(_.2.N0). A(G.0).
cr1(N0,N1). . . an(Nn_i.Na).
According to (4.6). a phrase is processed by skipping over
a region to find a B - the first non-terminal that does
not equal A. The skipped region is then examined to
ensure that it corresponds to an A before the rest of the
phrase is processed.
</bodyText>
<subsectionHeader confidence="0.989537">
4.2 Schema Processing
</subsectionHeader>
<bodyText confidence="0.964489">
To process the metarule control structures used by
schemata, a fail predicate is inserted to force Prolog to try
all possible alternatives. The simple recursive definition
of forall X in List:
(4.7) forall(X in O. Body).
forall(X in WIRestiBody) :-
(X-Y. calll(Body), fail) :
forall(X. Rest. Body).
uses fail to undo the binding of Y. the first element of
the list. to X before calling ford ll with the remainder of
the list. The predicate calll is used to evaluate Body
since it will prevent the fail predicate from causing
backtracking into Body.
</bodyText>
<subsectionHeader confidence="0.993193">
4.3 Transformation Processing
</subsectionHeader>
<bodyText confidence="0.9889185">
Execution of transformations requires the most
complex processing of all of the metagrammatical
operations. This processing can be divided into the three
stages of transformation creation, pattern matching. and rule
creation.5
During the transformation creation phase, the predicate
trans(M,X,Y) is created for the metarule. M. This
predicate will transform a list of elements. X; into
another list. Y. according to the syntax specification of the
metarule. Elements that IT-match will be represented by
the same free variable in both lists. This binding will be
one to one, since an element cannot match with more than
one element on the other side. Symbols that appear on
only one side will not have their free variable appearing
on the opposite side. Expressions in braces are ignored
during this stage. If a transformation like:
(4.8) a -&gt; b. c. X a@foo b. X. c(foo)
appears, then a predicate of the form:
(4.9) trans(M.
will be created. Notice that the appearance of a modifier
does not cause a@fai to be distinguished from a, since all
modifiers are removed before the pattern-template match is
attempted. However. c and c(foo) are considered to be
different symbols. M is a unique integer associated with
the transformation.
The pattern match phase determines if a rule matches
the pattern, and produces a list for each successful match
which will be transformed by the trans predicate. Each
element of the list is either one of the matched symbols
from the rule, or a list of symbols corresponding to the
don&apos;t care region of the pattern. Any predicates that
5(Popowich, forthcoming) examines a method of transformation
processing that uses the transformations during the parse, instead of using
them to generate new rules.
</bodyText>
<page confidence="0.996581">
52
</page>
<bodyText confidence="0.954134666666667">
appear in braces in the Pattern are evaluated during the
pattern match. Consider the operation of an active-passive
verb phrase transformation:
</bodyText>
<figure confidence="0.686703222222222">
(4.10) vp(active.Numb) —&gt;
v(Numb.R.Type.SType)
with (X.trans in Type.?).
np. Z
&lt;(? rip&apos;]
vp(pass.Numb) —&gt;
v(Numb.be.TS)-1 with aux in T.
v(Numb@pastpart.R.Type.SType)
with (X.trans in Type.?).
Z. pp(by._)
: x** hada Ipp(by). &amp; &lt;[? x**]]
on the following verb phrase:
(4.11) vp(active.Numb) —&gt;
v(Numb.R.Type._) with trans in Type.
: &lt;I v* &amp; np.
The list produced by the pattern match would resemble:
&apos;.12) vp(active.Numb).
v(Numb.R.Type._) with [(].trans in Type.[]].
</figure>
<bodyText confidence="0.947215322580645">
Notice that there was nothing in the rule to bind with X.
Y or Z. Consequently. these variables were assigned the
null list. (1. The pattern match of the semantics of the
rule will result in an expression which lambda abstracts
np&apos; out the of semantics:
(4.13) &lt;( np&apos; Imcla &lt;( v* &amp; np1
Finally, the rule creation phase applies the
transformation to the list produced by the pattern match.
and then uses the new list and the template to obtain a
new rule. This phase includes conversion of the new list
back into rule form, the application of modifiers, and the
addition of any extra symbols that appear on the right
hand side only. To continue with our example. the trans
predicate associated with (4.10) would be:
(4.14) trans(N.
Notice that the two vp&apos;s on opposite sides of the metarule
do not match. So the transformed list would resemble:
(4.15) _3.
_4.
v(Numb.R.Type._) with Martins in Type.[)].
I].
_5 ]
The rule generated by the rule creation phase would be:
(4.16) vp(pass.Numb) —&gt;
v(Numb.be.T.S)-1 with aux in T.
v(pastpart.R.Type._) with trans in Type.
pp(by._)
: a** lmda pp(by)* &amp; &lt;[v&apos; &amp; x** ]
. Notice that the expression &amp;quot;&lt;( V &amp; z## r. which is
. contained in the semantics of (4.16) was obtained by the
application of (4.13) to x##.
</bodyText>
<sectionHeader confidence="0.997671" genericHeader="method">
5. APPLICATIONS
</sectionHeader>
<bodyText confidence="0.9957875">
To examine the usefulness of this type of grammar
specification, as well as the adequacy of the
implementation. a grammar was developed that uses the
domain of the Automated Academic Advisor (AAA)
(Cercone et.al.. 1984). The AAA is an interactive
information system under development at Simon Fraser
University. It is intended to act as an aid in &amp;quot;curriculum
planning and management&amp;quot;. that accepts natural language
queries and generates the appropriate responses. Routines
for performing some morphological analysis. and for
retrieving lexical information were also provided.
The SSL grammar allows questions to be posed.
permits some possessive forms, and allows auxiliaries to
appear in the sentences. From the base of twenty six
rules, eighty additional rules were produced by three
metarules in about eighty-five seconds. Ten more rules
were needed to link the lexicon and the grammar. A
selection of the rules and metarules appears in Figure 5-1.
The complete grammar and lexicon is provided in
(Popowich. 1985).
In the interpretations of some sample sentences. which
can be found in Figure 5-2. some liberties are taken with
the semantic notation. Variables of the form wN. where
N is any integer. represent entities that are to be
instantiated from some database. Thus, any interpretation
containing wN will be a question. Possessives. like John&apos;s
table are represented as:
(5.1) &lt;table &amp; [John pass table]&gt;
Although multiple possessives which associate from left to
right are allowed, group possessives as seen in:
</bodyText>
<listItem confidence="0.831403666666667">
(5.2) the man who passed the course&apos;s book
and in phrases like:
(5.3) John&apos;s driver&apos;s licence
</listItem>
<bodyText confidence="0.998678866666667">
can not be interpreted correctly by the grammar.
Inverted sentences are preceded by the word Query in the
output. Also, proper nouns are assumed to unambiguously
refer to sonic object. and thus are no longer followed by
a unique integer. Analysis times for obtaining an
interpretation are given in CPU seconds. The total time
includes the time spent looking for all other possible
parses.
Results obtained with SAUMER compare favourably to
those obtained from the ProGram system (Evans and
Gazdar. 1984). ProGram operates on grammars _defined
according to the current GPSG formalism (Gazdar and
Pullum. 1982). but was not developed with efficiency as a
major consideration. The grammar used with ProGram.
which is given in (Popowich. 1985). is similar to the AAA
</bodyText>
<page confidence="0.997933">
53
</page>
<table confidence="0.97381423255814">
/. Case is des,:ribed by a mask. [N.A.G]. with free variables for Nom.. Acc. and Gen. ./
add vp(active.Numb) --&gt; v(Numb. Root. T. _) with (Root in [pass.give.teach,offer], indobj in T. trans in 7),
np([x.C.x].—.—). np((x.A,x]._,_) —1 : v&apos; &amp; np&apos; &amp; np-1&apos; ] .
ko 0N—questions in inverted sentences ./ eval(4. Var), NP np(Case.Numb.Fecit)
. ( NPONP --&gt; []. jogreement(Cose)1 : Var )
. ( s(inv) --&gt; np((x.A.x].Numb.Feat) with aword in Feat. s(inv)Onp((x.A.x],Numb,Feat)
: &lt;[ (Var lode s&apos;) &amp; np&apos; ] ).
/s passive transformation ./
add vp(octive.Numb) --&gt; v(Numb.R.Type.Subtype) with (X. trans in Type. Y). np, Z : np&apos;]
..&gt; vp(pass.Numb) --&gt; v(Numb,be.T.S)-1 with aux in T.
v(Numbippastport. R. Type. Subtype) with (X, trans in Type, Y).
Z. optional(pp(by,_)) : xhl &apos;oda [ optional&apos; &amp; &lt;[ ? sf4] ]
/* sentence inversion ./
add vp(7.[MIND --&gt; v((MINI.R.Type.S) with (X, aux in Type. Y).. Z : Sem
..&gt; s(inv) --&gt; v((MIN].R.Type,S) with (X.aux in Type.Y). np([N1,x,x].[RIN].—). Z :Eno&apos; &amp; Sem].
metaruls for the propagation of &amp;quot;holes&amp;quot; in the &amp;quot;slash&amp;quot; categories ./
feral&apos; Hole in [pp(Prep.Feat).np(Cose,Numb.F4100]
. ( forall Cott in [s(Type).vp.pp(Prep.Feat).optional]
. ( foroll Cat2 in [vp.PP(Prep.Feat).np(Cose.Numb.Feat).optioncil]
. ( Cat&apos; --&gt; X. Cot2, Y : Sem iv.&gt; CatleNolt --&gt; X. Cat211Nole. Y : Sem ) ) )
Figure 5-1: Excerpt from Grammar
Sentence did Fred take cmpt101.
Query. [Fred take5 cmpt101]
Analysis:. 2.25 sec. Total: 4.28334 sec.
Sentence: who wants to teach Fred&apos;s professor&apos;s course.
Semantics: [ &lt;w1 &amp; [0 animate&gt;
wont4
[ &lt;1.1 &amp; [w1 animate&gt;
teach13
&lt;course14 &amp; [ &lt;prof 15 &amp; [Fred pose prof 15]&gt; poss course14&gt;
Analysis: 6.58337 sec. Total: 18.9834 sec.
Sentence whose course does the student whom John likes want to be taking.
Query. [ &lt;&lt;the38 student39&gt; &amp; [John like45 &lt;the38 student39&gt;]&gt;
wont46
[ &lt;&lt;the38 student39&gt; &amp; [John 1ike45 &lt;the38 student39&gt;]&gt;
take56
&lt;course29 &amp; [&lt;w30 &amp; [w30 animate]&gt; pose course29]&gt;
Analysis: 21.9999 sec. Total: 39.4 sec.
Sentence: to whom does the professor want which paper to be given.
Query: [ &lt;the14 professor15&gt;
want 17
( x39 give38 &lt;w7 &amp; [w7 animate&gt; &lt;w21 &amp; [w21 paper22]&gt; ]
Analysis: 14.3167 sec. Total: 29.5167 sec.
</table>
<figureCaption confidence="0.49006">
Figure Summary of Test Results
</figureCaption>
<page confidence="0.994477">
54
</page>
<bodyText confidence="0.999924764705883">
grammar Used by SAUMER. except that it has a much
smaller lexicon, and allows neither relative clauses nor
possessive forms. Running on the same machine as
SAUMER. ProGram required about 35 seconds to parse the
sentence does John take cmptI01. with a total processing
time of abont 140 seconds. SAUMER required just over 2
seconds to parse this phrase. and had a total processing
time of about 4 seconds.
As it stands, the semantic notation used by SAUMER
does not contain much of the relevant information that
would be required by a real system. Tense, number and
adverbial information. including concepts like location and
time, would be required in the AAA. If the SSL
description were to be extended, with the resulting system
behaving as a natural language interface of the AAA. a
more database directed semantic notation would prove
invaluable.
</bodyText>
<sectionHeader confidence="0.999664" genericHeader="method">
6. PRESENT LIMITATIONS
</sectionHeader>
<bodyText confidence="0.999536230769231">
Although this application of metarules allows succinct
descriptions of a grammar. several problems have been
observed.
Since each metarule is applied to the rule base only
once, the order of the metarules is very important. In
our sample grammar. the passive verb phrases were
generated before the sentence inversion transformation was
processed, and then the slash category propagation
transformations were executed. For the current
implementation. if a rule generated by transformation Ti
is to be subjected to transformation T2. then Ti must
appear before T2. Moreover, no rule that is the result of
T2- can be operated on by Ti. It would be preferable to
remove this restriction and impose one that is less severe.
such as the finite closure restriction which is described in
(Thompson. 1982) and used by ProGram. With this
improvement, the only restriction would be that a
transformation could only be applied once in the
derivation of a rule.
• The system can not currently process rules expressed
in the Immediate Dominance/ Linear Precedence (ID/LP)
format. (Gazdar and Pullum. 1982). With this format, a
production rule is expressed with an unordered right hand
side with the ordering determined by a separate
declaration of linear precedence. For example. a passive
verb phrase rule could appear something like:
</bodyText>
<reference confidence="0.8520067">
(6.1) vp(pass.[MIND —&gt;
v(EMINL be.
v(_. Root. Type. with
(Root in [pass.carry.give].
indobj in Type.
trans in Type).
pp(to).
optional(pp(by))
: x## lmda
[optional&apos; &amp; &lt;[v&apos; &amp; pp(to)&apos; &amp; x##]]
</reference>
<bodyText confidence="0.968816555555555">
with the components having a linear precedence of:
(6.2) v(_.be) &lt; v &lt; pp
The result would be that the pp(by) could appear before
or after the pp(to). since there is no restriction on &apos; their
relative positions. If this format were implemented. only
one passive metarule would have to be explicitly stated.
The direct processing of ID/LP grammars is discussed in
(Shieber. 1982). (Evans and Gazdar. 1984). and (Popowich.
forthcoming).
</bodyText>
<sectionHeader confidence="0.999829" genericHeader="conclusions">
7. CONCLUSIONS
</sectionHeader>
<bodyText confidence="0.999920869565217">
SSL appears to adequately capture the flavour of
GPSG descriptions while allowing more procedural control.
Investigation into a relationship between SSL and GPSG
grammars could result in a method for translating GPSG
grammars into SSL for execution by SAUMER. Further
research could also provide a relationship between SSL and
other grammar formalisms, such as lexical-functional
grammars (Kaplan and Bresnan. 1982). The Prolog
implementation of SAUMER. allowing left recursion in
rules, should facilitate a more detailed study of the
specification language. and of some problems associated
with metarule specifications. Due to the easy separability
of the semantic rules, one could attempt to introduce a
more database oriented semantic notation and develop an
interface to a real database. One could then examine
system behaviour with a larger rule base and more
involved transformations in an applications environment
like that of the AAA. However, as is apparent from the
application presented here and from preliminary
experimentation (Popowich. 1984) (Popowich. 1985).
further investigation of the efficient operation of this
Prolog implementation with large grammars will be
required.
</bodyText>
<sectionHeader confidence="0.998717" genericHeader="acknowledgments">
ACKNOWLEDGEMENTS
</sectionHeader>
<bodyText confidence="0.996631111111111">
I would like to thank Nick Cercone for reading an
earlier version of this paper and providing some useful
suggestions. The comments of the referees were also
helpful. Facilities for this research were provided by the
Laboratory for Computer and Communications Research.
This work was supported by the Natural Sciences and
Engineering Research Council of Canada under Operating
Grant no. A4309. Installation Grant no. SMI-74 and
Postgraduate Scholarship #800.
</bodyText>
<sectionHeader confidence="0.999194" genericHeader="references">
REFERENCES
</sectionHeader>
<reference confidence="0.99930575">
Cercone. N.. Hadley. R.. Martin F.. McFetridge P. and
Strzalkowski. T. Designing and automating the
quality assessment of a knowledge-based system: the
initial automated academic advisor experience. pages
193-205. IEEE Principles of Knowledge-Based Systems
Proceedings. Denver. Colorado. 1984.
Clocksin. W.F. and Mellish. C.S. Program.ming in Prolog.
Berlin-Heidelberg-NewYork:Springer-Verlag. 1981.
</reference>
<page confidence="0.978938">
55
</page>
<reference confidence="0.99667223076923">
Dahl. V. and Abramson. H. On Gapping Grammars.
Proceedings of the Second International Joint Conference
on Logic. University of Uppsala. Sweden. 1984.
Evans. R. and Gazdar. G. The ProGram ManuaL
Cognitive Science Programme. University of Sussex.
1984.
Fawcett. B. personal communication. Dept. of
Computing Science. University of Toronto. 1984.
Gawron. J.M. et.al. Processing English with a
Generalized Phrase Structure Grammar. pages 74-81.
Proceedings of the 20th Annual Meeting of the
Association for Computational Linguistics. June. 1982.
Gazdar. G. Phrase Structure Grammar In P. Jacobson
and G.K. Pullum (Ed.). The Nature of Syntactic
Representation, D.Reidel. Dortrecht. 1981.
Gazdar. G. and Pullum. G.K. Generalized Phrase
Structure Grammar: A Theoretical Synopsis.
Technical Report. Indiana University Linguistics Club.
Bloomington Indiana. August 1982.
Kaplan. R. and Bresnan. J. Lexical-Functional Grammar
A Formal System for Grammatical Representation. In
J. Bresnan (Ed.). Mental Representation of
Grammatical Relations, MIT Press. 1982.
Pereira. F.C.N.(ed). C-Prolog User&apos;s Man
Report. SRI International. Menlo Park.
Pereira. F.C.N. and Warren. D.H.D.
Grammars for Language Analysis
Intelligence. 1980. 13. 231-278.
Popowich. F. SAUMER: Sentence Analysis Using
MEtaRules (Preliminary Report). Technical
Report TR-84-10 and LCCR TR-84-2. Department of
Computing Science. Simon Fraser University. August
1984.
Popowich. F. The SAUMER User&apos;s Manual. Technical
Report TR-85-3 and LCCR TR-85-4. Department of
Computing Science. Simon Fraser University. 1985.
Popowich. F. Effective Implementation and Application
of Unrestricted Gapping Grammars. Master&apos;s thesis.
Department of Computing Science. Simon Fraser
University. forthcoming.
Radford. A. Transformational Syntax. Cambridge
University Press. 1981.
Schubert. L.K. and Pelletier. FJ. From English to Logic:
Context-Free Computation of &apos;Conventionar Logical
Translation. American Journal of Computational
Linguistics. January-March 1982. 8(1). 26-44.
Shieber. S.M. Direct Parsing of ID/LP Grammars.
draft. 1982.
Thompson. H. Handling Metarules in a Parser for
GPSG. Technical Report D.A.I. No. 175. Department
of Artificial Intelligence. University of Edinburgh.
1982.
</reference>
<figure confidence="0.97679025">
nal. Technical
California. 1984.
Definite Clause
Artificial
</figure>
<page confidence="0.923293">
56
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.697704">
<title confidence="0.999702">SAUMER : SENTENCE ANALYSIS USING METARULES</title>
<author confidence="0.998607">Fred Popowich</author>
<affiliation confidence="0.99640225">Natural Language Group Laboratory for Computer and Communications Research Department of Computing Science Simon Fraser University</affiliation>
<address confidence="0.967444">Burnaby. B.C., CANADA V5A 1S6</address>
<abstract confidence="0.984136823529412">The SAUMER system uses specifications of natural language grammars. which consist of rules and metarules. to provide a semantic interpretation of an input sentence. The SAUMER &apos; Specification Language (SSL) is a programming language which combines some of the of phrase structure grammars 1981). like the correspondence between syntactic and rules, with clause grammars (DCGs) (Pereira and Warren, 1980) to create an executable grammar specification. SSL rules are similar to DCG rules except that they contain a semantic component and may also be left recursive. Metarules are used to generate new rules from existing rules before any parsing is attempted. An implementation is tested which can provide semantic interpretations for sentences containing topicalisation. relative clauses. passivisation, and questions.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="false">
<note>(6.1) vp(pass.[MIND —&gt; v(EMINL be.</note>
<marker></marker>
<rawString>(6.1) vp(pass.[MIND —&gt; v(EMINL be.</rawString>
</citation>
<citation valid="false">
<authors>
<author>v</author>
</authors>
<title>Type. with (Root in [pass.carry.give]. indobj in Type.</title>
<note>trans in Type). pp(to).</note>
<marker>v, </marker>
<rawString>v(_. Root. Type. with (Root in [pass.carry.give]. indobj in Type. trans in Type). pp(to).</rawString>
</citation>
<citation valid="false">
<title>x## lmda [optional&apos; &amp; &lt;[v&apos; &amp; pp(to)&apos;</title>
<note>x##</note>
<marker></marker>
<rawString>optional(pp(by)) : x## lmda [optional&apos; &amp; &lt;[v&apos; &amp; pp(to)&apos; &amp; x##]]</rawString>
</citation>
<citation valid="true">
<authors>
<author>N Hadley R Martin F McFetridge P</author>
<author>T Strzalkowski</author>
</authors>
<title>Designing and automating the quality assessment of a knowledge-based system: the initial automated academic advisor experience.</title>
<date>1984</date>
<booktitle>IEEE Principles of Knowledge-Based Systems Proceedings.</booktitle>
<pages>193--205</pages>
<location>Denver. Colorado.</location>
<marker>P, Strzalkowski, 1984</marker>
<rawString>Cercone. N.. Hadley. R.. Martin F.. McFetridge P. and Strzalkowski. T. Designing and automating the quality assessment of a knowledge-based system: the initial automated academic advisor experience. pages 193-205. IEEE Principles of Knowledge-Based Systems Proceedings. Denver. Colorado. 1984.</rawString>
</citation>
<citation valid="true">
<authors>
<author>W F</author>
<author>C S Mellish</author>
</authors>
<date>1981</date>
<booktitle>Program.ming in Prolog. Berlin-Heidelberg-NewYork:Springer-Verlag.</booktitle>
<marker>F, Mellish, 1981</marker>
<rawString>Clocksin. W.F. and Mellish. C.S. Program.ming in Prolog. Berlin-Heidelberg-NewYork:Springer-Verlag. 1981.</rawString>
</citation>
<citation valid="true">
<authors>
<author>V</author>
<author>H Abramson</author>
</authors>
<title>On Gapping Grammars.</title>
<date>1984</date>
<booktitle>Proceedings of the Second International Joint Conference on Logic.</booktitle>
<institution>University of Uppsala.</institution>
<marker>V, Abramson, 1984</marker>
<rawString>Dahl. V. and Abramson. H. On Gapping Grammars. Proceedings of the Second International Joint Conference on Logic. University of Uppsala. Sweden. 1984.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R</author>
<author>G Gazdar</author>
</authors>
<date>1984</date>
<institution>The ProGram ManuaL Cognitive Science Programme. University of Sussex.</institution>
<marker>R, Gazdar, 1984</marker>
<rawString>Evans. R. and Gazdar. G. The ProGram ManuaL Cognitive Science Programme. University of Sussex. 1984.</rawString>
</citation>
<citation valid="true">
<authors>
<author>B</author>
</authors>
<title>personal communication.</title>
<date>1984</date>
<institution>Dept. of Computing Science. University of Toronto.</institution>
<marker>B, 1984</marker>
<rawString>Fawcett. B. personal communication. Dept. of Computing Science. University of Toronto. 1984.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J M et al</author>
</authors>
<title>Processing English with a Generalized Phrase Structure Grammar.</title>
<date>1982</date>
<booktitle>Proceedings of the 20th Annual Meeting of the Association for Computational Linguistics.</booktitle>
<pages>74--81</pages>
<marker>al, 1982</marker>
<rawString>Gawron. J.M. et.al. Processing English with a Generalized Phrase Structure Grammar. pages 74-81. Proceedings of the 20th Annual Meeting of the Association for Computational Linguistics. June. 1982.</rawString>
</citation>
<citation valid="true">
<authors>
<author>G</author>
</authors>
<title>Phrase Structure Grammar In</title>
<date>1981</date>
<booktitle>The Nature of Syntactic Representation, D.Reidel. Dortrecht.</booktitle>
<marker>G, 1981</marker>
<rawString>Gazdar. G. Phrase Structure Grammar In P. Jacobson and G.K. Pullum (Ed.). The Nature of Syntactic Representation, D.Reidel. Dortrecht. 1981.</rawString>
</citation>
<citation valid="true">
<authors>
<author>G</author>
<author>G K Pullum</author>
</authors>
<title>Generalized Phrase Structure Grammar: A Theoretical Synopsis.</title>
<date>1982</date>
<tech>Technical</tech>
<institution>Report. Indiana University Linguistics Club. Bloomington Indiana.</institution>
<marker>G, Pullum, 1982</marker>
<rawString>Gazdar. G. and Pullum. G.K. Generalized Phrase Structure Grammar: A Theoretical Synopsis. Technical Report. Indiana University Linguistics Club. Bloomington Indiana. August 1982.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R</author>
<author>J Bresnan</author>
</authors>
<title>Lexical-Functional Grammar A Formal System for Grammatical Representation. In</title>
<date>1982</date>
<publisher>MIT Press.</publisher>
<marker>R, Bresnan, 1982</marker>
<rawString>Kaplan. R. and Bresnan. J. Lexical-Functional Grammar A Formal System for Grammatical Representation. In J. Bresnan (Ed.). Mental Representation of Grammatical Relations, MIT Press. 1982.</rawString>
</citation>
<citation valid="false">
<authors>
<author>F C N</author>
</authors>
<title>C-Prolog User&apos;s Man Report.</title>
<publisher>SRI International. Menlo Park.</publisher>
<marker>N, </marker>
<rawString>Pereira. F.C.N.(ed). C-Prolog User&apos;s Man Report. SRI International. Menlo Park.</rawString>
</citation>
<citation valid="true">
<authors>
<author>F C N</author>
<author>D H D Warren</author>
</authors>
<title>Grammars for Language Analysis Intelligence.</title>
<date>1980</date>
<volume>13</volume>
<pages>231--278</pages>
<marker>N, Warren, 1980</marker>
<rawString>Pereira. F.C.N. and Warren. D.H.D. Grammars for Language Analysis Intelligence. 1980. 13. 231-278.</rawString>
</citation>
<citation valid="true">
<authors>
<author>F</author>
</authors>
<title>SAUMER: Sentence Analysis Using MEtaRules (Preliminary Report).</title>
<date>1984</date>
<tech>Technical Report TR-84-10 and LCCR TR-84-2.</tech>
<institution>Department of Computing Science. Simon Fraser University.</institution>
<marker>F, 1984</marker>
<rawString>Popowich. F. SAUMER: Sentence Analysis Using MEtaRules (Preliminary Report). Technical Report TR-84-10 and LCCR TR-84-2. Department of Computing Science. Simon Fraser University. August 1984.</rawString>
</citation>
<citation valid="true">
<authors>
<author>F</author>
</authors>
<title>The SAUMER User&apos;s Manual.</title>
<date>1985</date>
<tech>Technical Report TR-85-3 and LCCR TR-85-4.</tech>
<institution>Department of Computing Science. Simon Fraser University.</institution>
<marker>F, 1985</marker>
<rawString>Popowich. F. The SAUMER User&apos;s Manual. Technical Report TR-85-3 and LCCR TR-85-4. Department of Computing Science. Simon Fraser University. 1985.</rawString>
</citation>
<citation valid="false">
<authors>
<author>F</author>
</authors>
<title>Effective Implementation and Application of Unrestricted Gapping Grammars. Master&apos;s thesis.</title>
<institution>Department of Computing Science. Simon Fraser University. forthcoming.</institution>
<marker>F, </marker>
<rawString>Popowich. F. Effective Implementation and Application of Unrestricted Gapping Grammars. Master&apos;s thesis. Department of Computing Science. Simon Fraser University. forthcoming.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A</author>
</authors>
<title>Transformational Syntax.</title>
<date>1981</date>
<publisher>Cambridge University Press.</publisher>
<marker>A, 1981</marker>
<rawString>Radford. A. Transformational Syntax. Cambridge University Press. 1981.</rawString>
</citation>
<citation valid="true">
<authors>
<author>L K</author>
<author>Pelletier FJ</author>
</authors>
<title>From English to Logic: Context-Free Computation of &apos;Conventionar Logical Translation.</title>
<date>1982</date>
<journal>American Journal of Computational Linguistics. January-March</journal>
<volume>8</volume>
<issue>1</issue>
<pages>26--44</pages>
<marker>K, FJ, 1982</marker>
<rawString>Schubert. L.K. and Pelletier. FJ. From English to Logic: Context-Free Computation of &apos;Conventionar Logical Translation. American Journal of Computational Linguistics. January-March 1982. 8(1). 26-44.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S M</author>
</authors>
<title>Direct Parsing of ID/LP Grammars.</title>
<date>1982</date>
<location>draft.</location>
<marker>M, 1982</marker>
<rawString>Shieber. S.M. Direct Parsing of ID/LP Grammars. draft. 1982.</rawString>
</citation>
<citation valid="true">
<authors>
<author>H</author>
</authors>
<title>Handling Metarules in a Parser for GPSG.</title>
<date>1982</date>
<tech>Technical Report D.A.I. No. 175.</tech>
<institution>Department of Artificial Intelligence. University of Edinburgh.</institution>
<marker>H, 1982</marker>
<rawString>Thompson. H. Handling Metarules in a Parser for GPSG. Technical Report D.A.I. No. 175. Department of Artificial Intelligence. University of Edinburgh. 1982.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>