<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.015648">
<title confidence="0.828685">
Syntactic Graphs and Constraint Satisfaction
</title>
<author confidence="0.747837">
Jeff Martin
</author>
<affiliation confidence="0.819441">
Department of Linguistics, University of Maryland
</affiliation>
<address confidence="0.61539">
College Park, MD 20742
</address>
<email confidence="0.742274">
jeffmar@umiacs.umd.edu
</email>
<bodyText confidence="0.999496545454545">
In this paper I will consider parsing as a discrete
combinatorial problem which consists in constructing a
labeled graph that satisfies a set of linguistic
constraints. I will identify some properties of linguistic
constraints which allow this problem to be solved
efficiently using constraint satisfaction algorithms. I
then describe briefly a modular parsing algorithm
which constructs a syntactic graph using a set of
generative operations and applies a filtering algorithm
to eliminate inconsistent nodes and edges.
The model of grammar I will assume is not a monolithic
rule system, but instead decomposes grammatical
problems into multiple constraints, each describing a
certain dimension of linguistic knowledge. The
grammar is partitioned into operations and constraints.
Some of these are given in (1); note that many
constraints, including linear precedence, are not
discussed here. I assume also that the grammar
specifies a lexicon, which is a list of complex categories
or attribute-value structures (Johnson 1988), along with
a set of partial functions which define the possible
categories of the grammar.
</bodyText>
<listItem confidence="0.733239">
(1) Operations Constraints
PROJECT-X CASEMARK(X,Y)
ADJOIN-X THETAMARK(X,Y)
</listItem>
<sectionHeader confidence="0.538493" genericHeader="abstract">
MOVE-X AGREE(X,Y)
INDEX-X ANTECEDE(X,Y)
</sectionHeader>
<bodyText confidence="0.9989044">
This cluster of modules incorporates operations and
constraints from both GB theory (Chomsky 1981) and
TAG (Johsi 1985). PROJECT-X is a category-neutral X-
bar grammar consisting of three context-free metarules
which yield a small set of unordered elementary trees.
ADJOIN-X, which consists of a single adjunction
schema, is a restricted type of tree adjunction which
takes two trees and adjoins one to a projection of the
head of the other. The combined schema are given in
(2):
</bodyText>
<equation confidence="0.96856275">
(2) X2 = ( Xl, Y2) specifier axiom
X1 = ( XO, Y2) complement axiom
Xn = co (a lexical category) labeling axiom
Xn = (Xn, Yn) adjunction axiom
</equation>
<bodyText confidence="0.9544055">
MOVE-X constructs chains which link gaps to
antecedents, while INDEX-X assigns indices to nodes
from the set of natural numbers. In the parsing model
to be discussed below, these make up the four basic
operations of a nondeterministic automaton that
generates sets of cantidate structures. Although these
sets are finite, their size is not bounded above by a
polynomial function in the size of the input. I showed in
Martin(1989) that if X-bar and adjunction rules together
allow four attachment levels, then the number of
possible (unordered) trees formed by unconstrained
application of these rules to a string of n terminals is
0(4n). Also, Fong(1989) has shown that the number of
distinct indodngs for n noun phrases is bn= Emn_i
whose closed form solution is exponential.
Unconstrained use of these operations therefore results
in massive overgeneration, caused by the fact that they
encode only a fragment of the knowledge in a grammar.
Unlike operations, the constraints in (1) crucially
depend on the attributes of lexical items and
nonterminal nodes. Three key properties of the
constraints can be exploited to achieve an efficient
filtering algorithm:
(i) they apply in local government configurations
(ii) they depend on node attributes whose domain of
values is small
(iii) they are binary
For example, agreement holds between a phrase YP
and a head Xo if and only if YP governs Xo, and YP and
Xo share a designated agreement vector, such as
Eaperson, finumber]; case marking holds between a
head Xo and a phrase YP if and only if Xo governs YP,
and Xo and YP share a designated case feature; and so
forth. Lebeaux (1989) argues that only closed classes of
features can enter into government relations. Unlike
open lexical classes such as (3a), it is feasible to list the
members of closed classes extensionally, for example
the case features in (3b):
</bodyText>
<listItem confidence="0.962546">
(3)a. Verb: (eat, sing, cry,...)
b. Case: (Nom,Acc,Dat,Gen)
</listItem>
<bodyText confidence="0.9998">
Constraints express the different types of attribute
dependency which may hold between a governor and a
governed node in a government domain. Each
constraint can be represented as a binary predicate
P(X,Y) which yields True if and only if a designated
subset of attributes do not have distinct values in the
categories X and Y. We may picture such predicates as
specifying a path which must be unifiable in the
directed acyclic graphs representing the categories X
and Y.
Before presenting the outline of a parsing algorithm
incorporating such constraints, it is necessary to
introduce the notion of boolean constraint satisfaction
</bodyText>
<page confidence="0.99553">
355
</page>
<bodyText confidence="0.984997277777778">
problem (BCSP) as defined in Mackworth (1987). Given
a finite set of variables (V1,V2,...,Vn) with associated
domains (D1,D2,...,Dn), constraint relations are stated
on certain subsets of the variables; the constraints
denote subsets of the cartesian product of the domains
of those variables. The solution set is the largest subset
of the cartesian product Dl x D2 x x Dn such that
each n-tuple in that set satisfies all the constraints.
Binary CSP&apos;s can be represented as a graph by
associating a pair (Vi,Di) with each node. An edge
between nodes i and j denotes a binary constraint
between the corresponding variables, while loops at a
node i denote unary constraints Pi which restrict the
domain of the node. Consistency is defined as follows:
(4) Node i is consistent if Vx[xE Di] =P(x).
Arc i,j is consistent if Vx[xE Di] 3y[yE Di APii(x,y)].
A path of length 2 from node i through node m to
node j is consistent if
</bodyText>
<subsectionHeader confidence="0.332716">
VxVzIPii(x,z)] 3-3,1y€ Dm A Pirn(X,DA Prni(y,Z)].
</subsectionHeader>
<bodyText confidence="0.99981624">
A network is node, arc, and path consistent iff all its
nodes, arcs and paths are consistent. Path consistency
can be generalized to paths of arbitrary length.
The parsing algorithm tries to find a consistent labeling
for a syntactic graph representing the set of all syntactic
analyses of an input string (see Seo &amp; Simmons 1989 for
a similar packed representation). The graph is
constructed from left to right by the operations Project-
Adjoin-X, Move-X and Index-X, which generate new
nodes and arcs. In this scheme, overgeneration does
not result in an abundance of parallel structures, but
rather in the presence of superfluous nodes and arcs in
a single graph. Each new node and arc generated is
associated with a set of constraints; these associations
are defined statically by the grammar. For example,
complement arcs are associated with thetamarking
constraints, specifier arcs are associated with
agreement constraints, and indexing arcs are
associated with coreference constraints. On each cycle
the parser attempts to connect two consistently labeled
subgraphs Cl and G2, where Cl represents the
analyses of a leftmost portion of the input string, and G2
represents the analyses of the rightmost substring
under consideration. The parse cycle contains three
basic steps:
</bodyText>
<listItem confidence="0.962776">
(a) select an operation
(b) apply the operation to graphs G1 and G2, yielding G3
(c) apply node, arc and path consistency to the
extended graph G3.
</listItem>
<bodyText confidence="0.999272066666667">
Step (c) deletes inconsistent values from the domain at
a node; also, if a node or arc is inconsistent, it is deleted.
Note that nodes in syntactic graphs are labeled by
linguistic categories which may contain many attribute-
value pairs. Thus, a node typically represents not one
but a set of variables whose values are relevant to the
constraint predicates. The properties of locality and
finite domains mentioned above turn out to be useful in
the filtering step. Locality guarantees that the algorithm
need only apply in a government domain. Therefore, it
is not necessary to make the entire graph consistent
after each extension, but only the largest subgraph
which is a government domain and contains the nodes
and edges most recently connected. The fact that the
domains of attributes have a limited range is useful
when the value of an attribute is unknown or
ambiguous. In such cases, the number of possible
solutions obtained by choosing an exact value for the
attribute is small.
In this paper I have sketched the design of a parsing
algorithm which makes direct use of a modular system
of grammatical principles. The problem of
overgeneration is solved by performing a limited
amount of local computation after each generation
step. This approach is quite different from one which
preprocesses the grammar by folding together
grammatical rules and constraints off-line. While this
latter approach can achieve an a priori pruning of the
search space by eliminating overgeneration entirely, it
may do so at the cost of an explosion in grammar size.
</bodyText>
<sectionHeader confidence="0.998143" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.99905948">
Chomsky, N. (1981) Lectures on Government and
Binding. Foris, Dordrecht.
Fong, S. (1990) &amp;quot;Free Indexation: Combinatorial
Analysis and a Compositional Algorithm. Proceedings
of the ACL 1990.
Johnson, M. (1988) Attribute-Value Logic and the
Theory of Grammar. CSLI Lecture Notes Series,
Chicago University Press.
Johsi, A. (1985) &amp;quot;Tree Adjoining Grammars,&amp;quot; In D.
Dowty, L. Karttunen &amp; A. Zwicky (eds.), Natural
Language Processing. Cambridge U. Press, Cambridge,
England.
Lebeaux, D. (1989) Language Acquisition and the Form
of Grammar. Doctoral dissertation, U. of
Massachusetts, Amherst, Mass.
Mackworth, A. (1987) &amp;quot;Constraint Satisfaction,&amp;quot; In: S
Shapiro (ed.), Encyclopedia of Artificial Intelligence,
Wiley, New York
Mackworth, A. (1977) &amp;quot;Consistency in networks of
relations,&amp;quot; ArtifIntell. 8(1), 99-118.
Martin, J. (1989) &amp;quot;Complexity of Decision Problems in
GB Theory,&amp;quot; ms., U. of Maryland.
Seo, J. &amp; R. Simmons (1989). &amp;quot;Syntactic Graphs: A
Representation for the Union of All Ambiguous Parse
Trees,&amp;quot; Computational Linguistics 15:1.
</reference>
<page confidence="0.998994">
356
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.000239">
<title confidence="0.999927">Syntactic Graphs and Constraint Satisfaction</title>
<author confidence="0.999943">Jeff Martin</author>
<affiliation confidence="0.999975">Department of Linguistics, University of Maryland</affiliation>
<address confidence="0.999941">College Park, MD 20742</address>
<email confidence="0.996006">jeffmar@umiacs.umd.edu</email>
<abstract confidence="0.969187826589595">In this paper I will consider parsing as a discrete combinatorial problem which consists in constructing a labeled graph that satisfies a set of linguistic constraints. I will identify some properties of linguistic constraints which allow this problem to be solved efficiently using constraint satisfaction algorithms. I then describe briefly a modular parsing algorithm which constructs a syntactic graph using a set of generative operations and applies a filtering algorithm to eliminate inconsistent nodes and edges. The model of grammar I will assume is not a monolithic rule system, but instead decomposes grammatical problems into multiple constraints, each describing a certain dimension of linguistic knowledge. The is partitioned into Some of these are given in (1); note that many constraints, including linear precedence, are not discussed here. I assume also that the grammar specifies a lexicon, which is a list of complex categories structures 1988), along with a set of partial functions which define the possible categories of the grammar. (1) Operations Constraints PROJECT-X CASEMARK(X,Y) ADJOIN-X THETAMARK(X,Y) MOVE-X AGREE(X,Y) INDEX-X ANTECEDE(X,Y) This cluster of modules incorporates operations and constraints from both GB theory (Chomsky 1981) and TAG (Johsi 1985). PROJECT-X is a category-neutral Xbar grammar consisting of three context-free metarules which yield a small set of unordered elementary trees. ADJOIN-X, which consists of a single adjunction schema, is a restricted type of tree adjunction which takes two trees and adjoins one to a projection of the head of the other. The combined schema are given in (2): (2) X2 = ( Xl, Y2) specifier axiom X1 = ( XO, Y2) complement axiom Xn = co (a lexical category) labeling axiom Xn = (Xn, Yn) adjunction axiom MOVE-X constructs chains which link gaps to antecedents, while INDEX-X assigns indices to nodes from the set of natural numbers. In the parsing model to be discussed below, these make up the four basic operations of a nondeterministic automaton that generates sets of cantidate structures. Although these sets are finite, their size is not bounded above by a polynomial function in the size of the input. I showed in Martin(1989) that if X-bar and adjunction rules together allow four attachment levels, then the number of possible (unordered) trees formed by unconstrained application of these rules to a string of n terminals is 0(4n). Also, Fong(1989) has shown that the number of indodngs for n noun phrases is whose closed form solution is exponential. Unconstrained use of these operations therefore results in massive overgeneration, caused by the fact that they encode only a fragment of the knowledge in a grammar. Unlike operations, the constraints in (1) crucially depend on the attributes of lexical items and nonterminal nodes. Three key properties of the constraints can be exploited to achieve an efficient filtering algorithm: (i) they apply in local government configurations (ii) they depend on node attributes whose domain of values is small (iii) they are binary For example, agreement holds between a phrase YP and a head Xo if and only if YP governs Xo, and YP and Xo share a designated agreement vector, such as Eaperson, finumber]; case marking holds between a head Xo and a phrase YP if and only if Xo governs YP, and Xo and YP share a designated case feature; and so forth. Lebeaux (1989) argues that only closed classes of features can enter into government relations. Unlike open lexical classes such as (3a), it is feasible to list the members of closed classes extensionally, for example the case features in (3b): (eat, sing, cry,...) b. Case: (Nom,Acc,Dat,Gen) Constraints express the different types of attribute dependency which may hold between a governor and a governed node in a government domain. Each constraint can be represented as a binary predicate P(X,Y) which yields True if and only if a designated subset of attributes do not have distinct values in the categories X and Y. We may picture such predicates as a path which must be the directed acyclic graphs representing the categories X and Y. Before presenting the outline of a parsing algorithm incorporating such constraints, it is necessary to the notion of constraint satisfaction 355 in Mackworth (1987). Given finite set of variables with associated domains (D1,D2,...,Dn), constraint relations are stated on certain subsets of the variables; the constraints denote subsets of the cartesian product of the domains of those variables. The solution set is the largest subset of the cartesian product Dl x D2 x x Dn such that each n-tuple in that set satisfies all the constraints. Binary CSP&apos;s can be represented as a graph by associating a pair (Vi,Di) with each node. An edge between nodes i and j denotes a binary constraint between the corresponding variables, while loops at a node i denote unary constraints Pi which restrict the domain of the node. Consistency is defined as follows: (4) Node i is consistent if Vx[xE Di] =P(x). Arc i,j is consistent if Vx[xE Di] 3y[yE Di APii(x,y)]. A path of length 2 from node i through node m to node j is consistent if A Pirn(X,DA Prni(y,Z)]. A network is node, arc, and path consistent iff all its nodes, arcs and paths are consistent. Path consistency can be generalized to paths of arbitrary length. The parsing algorithm tries to find a consistent labeling for a syntactic graph representing the set of all syntactic analyses of an input string (see Seo &amp; Simmons 1989 for a similar packed representation). The graph is from left to right by the operations Project- Adjoin-X, Move-X and Index-X, which generate new nodes and arcs. In this scheme, overgeneration does not result in an abundance of parallel structures, but rather in the presence of superfluous nodes and arcs in a single graph. Each new node and arc generated is associated with a set of constraints; these associations are defined statically by the grammar. For example, complement arcs are associated with thetamarking constraints, specifier arcs are associated with agreement constraints, and indexing arcs are associated with coreference constraints. On each cycle the parser attempts to connect two consistently labeled Cl and G2, where Cl represents analyses of a leftmost portion of the input string, and G2 represents the analyses of the rightmost substring under consideration. The parse cycle contains three basic steps: (a) select an operation apply the operation to graphs G1 and (c) apply node, arc and path consistency to the graph deletes inconsistent values from the domain at a node; also, if a node or arc is inconsistent, it is deleted. Note that nodes in syntactic graphs are labeled by linguistic categories which may contain many attributevalue pairs. Thus, a node typically represents not one but a set of variables whose values are relevant to the constraint predicates. The properties of locality and domains mentioned above turn out to be in the filtering step. Locality guarantees that the algorithm need only apply in a government domain. Therefore, it is not necessary to make the entire graph consistent after each extension, but only the largest subgraph which is a government domain and contains the nodes and edges most recently connected. The fact that the domains of attributes have a limited range is useful when the value of an attribute is unknown or ambiguous. In such cases, the number of possible solutions obtained by choosing an exact value for the attribute is small. this paper have the design of a parsing algorithm which makes direct use of a modular system grammatical principles. The of overgeneration is solved by performing a limited amount of local computation after each generation step. This approach is quite different from one which preprocesses the grammar by folding together grammatical rules and constraints off-line. While this latter approach can achieve an a priori pruning of the search space by eliminating overgeneration entirely, it may do so at the cost of an explosion in grammar size.</abstract>
<note confidence="0.971405285714286">References N. (1981) on Government and Dordrecht. Fong, S. (1990) &amp;quot;Free Indexation: Combinatorial and a Compositional Algorithm. of the ACL 1990. M. (1988) Logic and the</note>
<affiliation confidence="0.8597205">of Grammar. Lecture Series, Chicago University Press.</affiliation>
<address confidence="0.703416">Johsi, A. (1985) &amp;quot;Tree Adjoining Grammars,&amp;quot; In D.</address>
<affiliation confidence="0.4131765">L. Karttunen &amp; A. Zwicky (eds.), Processing. U. Press, Cambridge,</affiliation>
<address confidence="0.6874">England.</address>
<note confidence="0.689363">D. (1989) Acquisition and the Form Doctoral dissertation, of Massachusetts, Amherst, Mass. Mackworth, A. (1987) &amp;quot;Constraint Satisfaction,&amp;quot; In: S</note>
<affiliation confidence="0.889976">(ed.), of Artificial Intelligence,</affiliation>
<address confidence="0.9355915">Wiley, New York Mackworth, A. (1977) &amp;quot;Consistency in networks of</address>
<phone confidence="0.196449">99-118.</phone>
<author confidence="0.905683">J Complexity of Decision Problems in Martin</author>
<affiliation confidence="0.9505">GB Theory,&amp;quot; ms., U. of Maryland.</affiliation>
<address confidence="0.916178">Seo, J. &amp; R. Simmons (1989). &amp;quot;Syntactic Graphs: A</address>
<note confidence="0.568944333333333">for the Union of Ambiguous Parse Linguistics 356</note>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>N Chomsky</author>
</authors>
<date>1981</date>
<booktitle>Lectures on Government and Binding. Foris,</booktitle>
<location>Dordrecht.</location>
<contexts>
<context position="1486" citStr="Chomsky 1981" startWordPosition="208" endWordPosition="209">The grammar is partitioned into operations and constraints. Some of these are given in (1); note that many constraints, including linear precedence, are not discussed here. I assume also that the grammar specifies a lexicon, which is a list of complex categories or attribute-value structures (Johnson 1988), along with a set of partial functions which define the possible categories of the grammar. (1) Operations Constraints PROJECT-X CASEMARK(X,Y) ADJOIN-X THETAMARK(X,Y) MOVE-X AGREE(X,Y) INDEX-X ANTECEDE(X,Y) This cluster of modules incorporates operations and constraints from both GB theory (Chomsky 1981) and TAG (Johsi 1985). PROJECT-X is a category-neutral Xbar grammar consisting of three context-free metarules which yield a small set of unordered elementary trees. ADJOIN-X, which consists of a single adjunction schema, is a restricted type of tree adjunction which takes two trees and adjoins one to a projection of the head of the other. The combined schema are given in (2): (2) X2 = ( Xl, Y2) specifier axiom X1 = ( XO, Y2) complement axiom Xn = co (a lexical category) labeling axiom Xn = (Xn, Yn) adjunction axiom MOVE-X constructs chains which link gaps to antecedents, while INDEX-X assigns</context>
</contexts>
<marker>Chomsky, 1981</marker>
<rawString>Chomsky, N. (1981) Lectures on Government and Binding. Foris, Dordrecht.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S Fong</author>
</authors>
<title>Free Indexation: Combinatorial Analysis and a Compositional Algorithm.</title>
<date>1990</date>
<booktitle>Proceedings of the ACL</booktitle>
<marker>Fong, 1990</marker>
<rawString>Fong, S. (1990) &amp;quot;Free Indexation: Combinatorial Analysis and a Compositional Algorithm. Proceedings of the ACL 1990.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Johnson</author>
</authors>
<title>Attribute-Value Logic and the Theory of Grammar.</title>
<date>1988</date>
<booktitle>CSLI Lecture Notes Series,</booktitle>
<publisher>Chicago University Press.</publisher>
<contexts>
<context position="1180" citStr="Johnson 1988" startWordPosition="168" endWordPosition="169">set of generative operations and applies a filtering algorithm to eliminate inconsistent nodes and edges. The model of grammar I will assume is not a monolithic rule system, but instead decomposes grammatical problems into multiple constraints, each describing a certain dimension of linguistic knowledge. The grammar is partitioned into operations and constraints. Some of these are given in (1); note that many constraints, including linear precedence, are not discussed here. I assume also that the grammar specifies a lexicon, which is a list of complex categories or attribute-value structures (Johnson 1988), along with a set of partial functions which define the possible categories of the grammar. (1) Operations Constraints PROJECT-X CASEMARK(X,Y) ADJOIN-X THETAMARK(X,Y) MOVE-X AGREE(X,Y) INDEX-X ANTECEDE(X,Y) This cluster of modules incorporates operations and constraints from both GB theory (Chomsky 1981) and TAG (Johsi 1985). PROJECT-X is a category-neutral Xbar grammar consisting of three context-free metarules which yield a small set of unordered elementary trees. ADJOIN-X, which consists of a single adjunction schema, is a restricted type of tree adjunction which takes two trees and adjoin</context>
</contexts>
<marker>Johnson, 1988</marker>
<rawString>Johnson, M. (1988) Attribute-Value Logic and the Theory of Grammar. CSLI Lecture Notes Series, Chicago University Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Johsi</author>
</authors>
<title>Tree Adjoining Grammars,&amp;quot; In</title>
<date>1985</date>
<booktitle>Natural Language Processing. Cambridge U.</booktitle>
<editor>D. Dowty, L. Karttunen &amp; A. Zwicky (eds.),</editor>
<publisher>Press,</publisher>
<location>Cambridge, England.</location>
<contexts>
<context position="1507" citStr="Johsi 1985" startWordPosition="212" endWordPosition="213">ned into operations and constraints. Some of these are given in (1); note that many constraints, including linear precedence, are not discussed here. I assume also that the grammar specifies a lexicon, which is a list of complex categories or attribute-value structures (Johnson 1988), along with a set of partial functions which define the possible categories of the grammar. (1) Operations Constraints PROJECT-X CASEMARK(X,Y) ADJOIN-X THETAMARK(X,Y) MOVE-X AGREE(X,Y) INDEX-X ANTECEDE(X,Y) This cluster of modules incorporates operations and constraints from both GB theory (Chomsky 1981) and TAG (Johsi 1985). PROJECT-X is a category-neutral Xbar grammar consisting of three context-free metarules which yield a small set of unordered elementary trees. ADJOIN-X, which consists of a single adjunction schema, is a restricted type of tree adjunction which takes two trees and adjoins one to a projection of the head of the other. The combined schema are given in (2): (2) X2 = ( Xl, Y2) specifier axiom X1 = ( XO, Y2) complement axiom Xn = co (a lexical category) labeling axiom Xn = (Xn, Yn) adjunction axiom MOVE-X constructs chains which link gaps to antecedents, while INDEX-X assigns indices to nodes fro</context>
</contexts>
<marker>Johsi, 1985</marker>
<rawString>Johsi, A. (1985) &amp;quot;Tree Adjoining Grammars,&amp;quot; In D. Dowty, L. Karttunen &amp; A. Zwicky (eds.), Natural Language Processing. Cambridge U. Press, Cambridge, England.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D Lebeaux</author>
</authors>
<title>Language Acquisition and the Form of Grammar. Doctoral dissertation, U. of Massachusetts,</title>
<date>1989</date>
<location>Amherst, Mass.</location>
<contexts>
<context position="3641" citStr="Lebeaux (1989)" startWordPosition="571" endWordPosition="572"> of lexical items and nonterminal nodes. Three key properties of the constraints can be exploited to achieve an efficient filtering algorithm: (i) they apply in local government configurations (ii) they depend on node attributes whose domain of values is small (iii) they are binary For example, agreement holds between a phrase YP and a head Xo if and only if YP governs Xo, and YP and Xo share a designated agreement vector, such as Eaperson, finumber]; case marking holds between a head Xo and a phrase YP if and only if Xo governs YP, and Xo and YP share a designated case feature; and so forth. Lebeaux (1989) argues that only closed classes of features can enter into government relations. Unlike open lexical classes such as (3a), it is feasible to list the members of closed classes extensionally, for example the case features in (3b): (3)a. Verb: (eat, sing, cry,...) b. Case: (Nom,Acc,Dat,Gen) Constraints express the different types of attribute dependency which may hold between a governor and a governed node in a government domain. Each constraint can be represented as a binary predicate P(X,Y) which yields True if and only if a designated subset of attributes do not have distinct values in the c</context>
</contexts>
<marker>Lebeaux, 1989</marker>
<rawString>Lebeaux, D. (1989) Language Acquisition and the Form of Grammar. Doctoral dissertation, U. of Massachusetts, Amherst, Mass.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Mackworth</author>
</authors>
<title>Constraint Satisfaction,&amp;quot; In:</title>
<date>1987</date>
<booktitle>Encyclopedia of Artificial Intelligence,</booktitle>
<editor>S Shapiro (ed.),</editor>
<publisher>Wiley,</publisher>
<location>New York</location>
<contexts>
<context position="4613" citStr="Mackworth (1987)" startWordPosition="725" endWordPosition="726">hich may hold between a governor and a governed node in a government domain. Each constraint can be represented as a binary predicate P(X,Y) which yields True if and only if a designated subset of attributes do not have distinct values in the categories X and Y. We may picture such predicates as specifying a path which must be unifiable in the directed acyclic graphs representing the categories X and Y. Before presenting the outline of a parsing algorithm incorporating such constraints, it is necessary to introduce the notion of boolean constraint satisfaction 355 problem (BCSP) as defined in Mackworth (1987). Given a finite set of variables (V1,V2,...,Vn) with associated domains (D1,D2,...,Dn), constraint relations are stated on certain subsets of the variables; the constraints denote subsets of the cartesian product of the domains of those variables. The solution set is the largest subset of the cartesian product Dl x D2 x x Dn such that each n-tuple in that set satisfies all the constraints. Binary CSP&apos;s can be represented as a graph by associating a pair (Vi,Di) with each node. An edge between nodes i and j denotes a binary constraint between the corresponding variables, while loops at a node </context>
</contexts>
<marker>Mackworth, 1987</marker>
<rawString>Mackworth, A. (1987) &amp;quot;Constraint Satisfaction,&amp;quot; In: S Shapiro (ed.), Encyclopedia of Artificial Intelligence, Wiley, New York</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Mackworth</author>
</authors>
<title>Consistency in networks of relations,&amp;quot;</title>
<date>1977</date>
<journal>ArtifIntell.</journal>
<volume>8</volume>
<issue>1</issue>
<pages>99--118</pages>
<marker>Mackworth, 1977</marker>
<rawString>Mackworth, A. (1977) &amp;quot;Consistency in networks of relations,&amp;quot; ArtifIntell. 8(1), 99-118.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Martin</author>
</authors>
<title>Complexity of Decision Problems in GB Theory,&amp;quot;</title>
<date>1989</date>
<journal>ms., U. of Maryland.</journal>
<marker>Martin, 1989</marker>
<rawString>Martin, J. (1989) &amp;quot;Complexity of Decision Problems in GB Theory,&amp;quot; ms., U. of Maryland.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Seo</author>
<author>R Simmons</author>
</authors>
<title>Syntactic Graphs: A Representation for the Union of All Ambiguous Parse Trees,&amp;quot;</title>
<date>1989</date>
<journal>Computational Linguistics</journal>
<volume>15</volume>
<contexts>
<context position="5870" citStr="Seo &amp; Simmons 1989" startWordPosition="937" endWordPosition="940">trict the domain of the node. Consistency is defined as follows: (4) Node i is consistent if Vx[xE Di] =P(x). Arc i,j is consistent if Vx[xE Di] 3y[yE Di APii(x,y)]. A path of length 2 from node i through node m to node j is consistent if VxVzIPii(x,z)] 3-3,1y€ Dm A Pirn(X,DA Prni(y,Z)]. A network is node, arc, and path consistent iff all its nodes, arcs and paths are consistent. Path consistency can be generalized to paths of arbitrary length. The parsing algorithm tries to find a consistent labeling for a syntactic graph representing the set of all syntactic analyses of an input string (see Seo &amp; Simmons 1989 for a similar packed representation). The graph is constructed from left to right by the operations ProjectAdjoin-X, Move-X and Index-X, which generate new nodes and arcs. In this scheme, overgeneration does not result in an abundance of parallel structures, but rather in the presence of superfluous nodes and arcs in a single graph. Each new node and arc generated is associated with a set of constraints; these associations are defined statically by the grammar. For example, complement arcs are associated with thetamarking constraints, specifier arcs are associated with agreement constraints, </context>
</contexts>
<marker>Seo, Simmons, 1989</marker>
<rawString>Seo, J. &amp; R. Simmons (1989). &amp;quot;Syntactic Graphs: A Representation for the Union of All Ambiguous Parse Trees,&amp;quot; Computational Linguistics 15:1.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>