<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000002">
<title confidence="0.401868857142857">
XMG - An expressive formalism for describing tree-based grammars
Yannick Parmentier
INRIA / LORIA
Universit´e Henri Poincar´e
615, Rue du Jardin Botanique
54 600 Villers-Les-Nancy
France
</title>
<email confidence="0.993096">
parmenti@loria.fr
</email>
<note confidence="0.599296">
Joseph Le Roux
LORIA
Institut National
Polytechnique de Lorraine
</note>
<address confidence="0.487489">
615, Rue du Jardin Botanique
54 600 Villers-Les-Nancy
France
</address>
<email confidence="0.991576">
leroux@loria.fr
</email>
<author confidence="0.425067">
Benoit Crabb´e
HCRC / ICCS
</author>
<affiliation confidence="0.704334">
University of Edinburgh
</affiliation>
<address confidence="0.773502666666667">
2 Buccleuch Place
EH8 9LW,
Edinburgh, Scotland
</address>
<email confidence="0.999057">
bcrabbe@inf.ed.ac.uk
</email>
<sectionHeader confidence="0.998602" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999811666666667">
In this paper1 we introduce eXtensible
MetaGrammar, a system that facilitates
the development of tree based grammars.
This system includes both (1) a formal lan-
guage adapted to the description of lin-
guistic information and (2) a compiler for
this language. It applies techniques of
logic programming (e.g. Warren’s Ab-
stract Machine), thus providing an effi-
cient and theoretically motivated frame-
work for the processing of linguistic meta-
descriptions.
</bodyText>
<sectionHeader confidence="0.999516" genericHeader="introduction">
1 Introduction
</sectionHeader>
<bodyText confidence="0.983831148148148">
It is well known that grammar engineering is a
complex task and that factorizing grammar in-
formation is crucial for the rapid development,
the maintenance and the debugging of large scale
grammars. While much work has been deployed
into producing such factorizing environments for
standard unification grammars, less attention has
been paid to the issue of developing such environ-
ments for “tree based grammars” that is, grammars
like Tree Adjoining Grammars (TAG) or Tree De-
scription Grammars where the basic unit of infor-
mation is a tree rather than a category encoded in
a feature structure.
For these grammars, two trends have emerged
to automatize tree-based grammar production:
systems based on lexical rules (see (Becker,
2000)) and systems based on combination of
classes (also called metagrammar systems, see
(Candito, 1999), (Gaiffe et al., 2002)).
1We are grateful to Claire Gardent for useful comments
on this work. This work is partially supported by an INRIA
grant.
In this paper, we present a metagrammar system
for tree-based grammars which differs from com-
parable existing approaches both linguistically and
computationally.
Linguistically, the formalism we introduce is
both expressive and extensible. In particularly, we
show that it supports the description and factor-
ization both of trees and of tree descriptions; that
it allows the synchronized description of several
linguistic dimensions (e.g., syntax and semantics)
and that it includes a sophisticated treatment of
the interaction between inheritance and identifier
naming.
Computationally, the production of a grammar
from a metagrammar is handled using power-
ful and well-understood logic programming tech-
niques. A metagrammar is viewed as an extended
definite clause grammar and compiled using a vir-
tual machine closely resembling the Warren’s Ab-
stract Machine. The generation of the trees satisfy-
ing a given tree description is furthermore handled
using a tree description solver.
The paper is structured as follows. We begin
(section 2) by introducing the linguistic formal-
ism used for describing and factorizing tree based
grammars. We then sketch the logic program-
ming techniques used by the metagrammar com-
piler (section 3). Section 4 presents some evalu-
ation results concerning the use of the system for
implementing different types of tree based gram-
mars. Section 5 concludes with pointers for fur-
ther research and improvements.
</bodyText>
<sectionHeader confidence="0.979691" genericHeader="method">
2 Linguistic formalism
</sectionHeader>
<bodyText confidence="0.9989415">
As mentioned above, the XMG system produces a
grammar from a linguistic meta-description called
a metagrammar. This description is specified us-
ing the XMG metagrammar formalism which sup-
</bodyText>
<page confidence="0.996602">
103
</page>
<bodyText confidence="0.939963">
ports three main features:
</bodyText>
<listItem confidence="0.9935916">
1. the reuse of tree fragments
2. the specialization of fragments via in-
heritance
3. the combination of fragments by
means of conjunctions and disjunctions
</listItem>
<bodyText confidence="0.999970153846154">
These features reflect the idea that a metagrammar
should allow the description of two main axes: (i)
the specification of elementary pieces of informa-
tion (fragments), and (ii) the combination of these
to represent alternative syntactic structures.
Describing syntax In a tree-based metagram-
mar, the basic informational units to be handled
are tree fragments. In the XMG formalism, these
units are put into classes. A class associates a
name with a content. At the syntactic level, a con-
tent is a tree description2. The tree descriptions
supported by the XMG formalism are defined by
the following tree description language:
</bodyText>
<equation confidence="0.995269333333333">
Description ::= x → y  |x →+ y  |x →* y |
x ≺ y  |x ≺+ y  |x ≺* y |
x[f:E] (1)
</equation>
<bodyText confidence="0.999978722222222">
where x, y represent node variables, → immediate
dominance (x is directly above y), →+ strict dom-
inance (x is above y), →* large dominance (x is
above or equal to y), ≺ is immediate precedence,
≺+ strict precedence, and ≺* large precedence3.
x[f:E] constrains feature f with associated ex-
pression E on node x (a feature can for instance
refer to the syntactic category of the node)4.
Tree fragments can furthermore be combined
using conjunction and/or disjunction. These
two operators allow the metagrammar designer to
achieve a high degree of factorization. Moreover
the XMG system also supports inheritance be-
tween classes, thus offering more flexibility and
structure sharing by allowing one to reuse and
specialize classes.
Identifiers’ scope When describing a broad-
coverage grammar, dealing with identifiers scope
is a non-trivial issue.
In previous approaches to metagrammar com-
pilation ((Candito, 1999), (Gaiffe et al., 2002)),
node identifiers had global scope. When design-
ing broad-coverage metagrammars however, such
a strategy quickly reduces modularity and com-
plexifies grammar maintenance. To start with, the
grammar writer must remember each node name
and its interpretation and in a large coverage gram-
mar the number of these node names amounts to
several hundreds. Further it is easy to use twice
the same name erroneously or on the contrary, to
mistype a name identifier, in both cases introduc-
ing errors in the metagrammar
In XMG, identifiers are local to a class and can
thus be reused freely. Global and semi-global (i.e.,
global to a subbranch in the inheritance hierar-
chy) naming is also supported however through a
system of import / export inspired from Object
Oriented Programming. When defining a class as
being a sub-class of another one, the XMG user
can specify which are the viewable identifiers (i.e.
which identifiers have been exported in the super-
class).
Extension to semantics The XMG formalism
further supports the integration in the grammar of
semantic information. More generally, the lan-
guage manages dimensions of descriptions so that
the content of a class can consists of several ele-
ments belonging to different dimensions. Each di-
mension is then processed differently according to
the output that is expected (trees, set of predicates,
etc).
Currently, XMG includes a semantic represen-
tation language based on Flat Semantics (see (Gar-
dent and Kallmeyer, 2003)):
</bodyText>
<equation confidence="0.981617">
Description ::= `:p(E1, ..., En)
|
¬`:p(E1, ..., En)  |Ei « Ej (2)
</equation>
<bodyText confidence="0.9998383">
where `:p(E1, ..., En) represents the predicate p
with parameters E1,.., En, and labeled `. ¬ is the
logical negation, and Ei « Ej is the scope be-
tween Ei and Ej (used to deal with quantifiers).
Thus, one can write classes whose content con-
sists of tree description and/or of semantic formu-
las. The XMG formalism furthermore supports the
sharing of identifiers across dimension hence al-
lowing for a straightforward encoding of the syn-
tax/semantics interface (see figure 1).
</bodyText>
<footnote confidence="0.832950857142857">
2As we shall later see, a content can in fact be multi-
dimensional and integrate for instance both semantic and syn-
tax/semantics interface information.
3We call strict the transitive closure of a relation and large
the reflexive and transitive one.
4E is an expression, so it can be a feature structure: that’s
how top and bottom are encoded in TAG.
</footnote>
<sectionHeader confidence="0.910219" genericHeader="method">
3 Compiling a MetaGrammar into a
Grammar
</sectionHeader>
<bodyText confidence="0.9994715">
We now focus on the compilation process and on
the constraint logic programming techniques we
</bodyText>
<page confidence="0.998655">
104
</page>
<figureCaption confidence="0.99943">
Figure 1: Tree with syntax/semantics interface
</figureCaption>
<bodyText confidence="0.995369916666667">
draw upon.
As we have seen, an XMG metagrammar con-
sists of classes that are combined. Provided these
classes can be referred to by means of names, we
can view a class as a Clause associating a name
with a content or Goal to borrow vocabulary from
Logic Programming. In XMG, this Goal will be
either a tree Description, a semantic Description,
a Name (class call) or a combination of classes
(conjunction or disjunction). Finally, the valua-
tion of a specific class can be seen as being trig-
gered by a query.
</bodyText>
<figure confidence="0.71959425">
Clause ::= Name → Goal (3)
Goal ::= Description  |Name
 |Goal ∨ Goal  |Goal ∧ Goal (4)
Query ::= Name (5)
</figure>
<bodyText confidence="0.999665571428571">
In other words, we view our metagrammar lan-
guage as a specific kind of Logic Program namely,
a Definite Clause Grammar (or DCG). In this
DCG, the terminal symbols are descriptions.
To extend the approach to the representation of
semantic information as introduced in 2, clause (4)
is modified as follows:
</bodyText>
<subsectionHeader confidence="0.500320666666667">
Goal ::= Dimension+=Description |
Name |
Goal ∨ Goal  |Goal ∧ Goal
</subsectionHeader>
<bodyText confidence="0.998506739130435">
Note that, with this modification, the XMG lan-
guage no longer correspond to a Definite Clause
Grammar but to an Extended Definite Clause
Grammar (see (Van Roy, 1990)) where the sym-
bol += represents the accumulation of information
for each dimension.
Virtual Machine The evaluation of a query is
done by a specific Virtual Machine inspired by
the Warren’s Abstract Machine (see (Ait-Kaci,
1991)). First, it computes the derivations con-
tained in the description, i.e. in the Extended Def-
inite Clause Grammar, and secondly it performs
unification of non standard data-types (nodes,
node features for TAG). Eventually it produces
as an output a description, more precisely one de-
scription per dimension (syntax, semantics).
In the case of TAG, the virtual machine produces
a tree description. We still need to solve this de-
scription in order to obtain trees (i.e. the items of
the resulting grammar).
Constraint-based tree description solver The
tree description solver we use is inspired by
(Duchier and Niehren, 2000). The idea is to:
</bodyText>
<listItem confidence="0.687205777777778">
1. associate to each node x in the description an
integer,
2. then refer to x by means of the tuple
(Eqx, Upx, Downx, Leftx, Rightx) where Eqx
(respectively Upx, Downx, Leftx, Rightx) de-
notes the set of nodes in the description which
are equal, (respectively above, below, left, and
right) of x (see picture 2). Note that these sets
are set of integers.
</listItem>
<figure confidence="0.527268">
Down
</figure>
<figureCaption confidence="0.994635">
Figure 2: node regions
</figureCaption>
<bodyText confidence="0.999365571428571">
The operations supported by the XMG language
(i.e. dominance, precedence, etc) are then con-
verted into constraints on these sets. For instance,
let us consider 2 nodes x and y of the description.
Assuming we associate x with the integer i and
y with j, we can translate the dominance relation
x → y the following way5:
</bodyText>
<equation confidence="0.687901166666667">
Ni → Nj ≡ MqUp ⊆ Nj ∧
Up
Ni Down ⊇ Nj EqDown ∧
Ni ⊆ Nj Left ∧
Left
NiRight ⊆ Nj Right]
</equation>
<bodyText confidence="0.8435855">
This means that if x dominates y, then in a model,
(1) the set of integers representing nodes that are
equal or above x is included in the set of inte-
gers representing nodes that are strictly above y,
</bodyText>
<footnote confidence="0.8477755">
5NiEqUp corresponds to the disjoint union of NiEq and
NiUp, similarly for NjEqDown with NiEq and NiDown.
</footnote>
<figure confidence="0.971274">
Eq
Right
Up
Left
</figure>
<page confidence="0.996834">
105
</page>
<bodyText confidence="0.99996293939394">
(2) the dual holds, i.e. the set of integers repre-
senting nodes that are below x contains the set of
integers representing nodes that are equal or be-
low y, (3) the set of integers representing nodes
that are on the left of x is included in the set of
integers representing those on the left of y, and (4)
symmetrically for the nodes on the right6.
Parameterized constraint solver To recap 3
from a grammar-designer’s point of view, a
queried class needs not define complete trees but
rather a set of tree descriptions. The solver is then
called to generate all the matching valid minimal
trees from those descriptions. This feature pro-
vides the users with a way to concentrate on what
is relevant in the grammar, thus taking advantage
of underspecification, and to delegate the tiresome
work to the solver.
Actually, the solver can be parameterized to per-
form various checks or constraints on the tree de-
scriptions besides tree-shaping them. These pa-
rameters are called principles in the XMG termi-
nology. Some are specific to a target formalism
(e.g. TAG trees must have at most one foot node)
while others are independent. The most interesting
one is a resources/needs mechanism for node uni-
fication called color principle, see (Crabb´e and
Duchier, 2004).
At the end of this tree description solving pro-
cess we obtain the trees of the grammar. Note that
the use of constraint programming techniques to
solve tree descriptions allows us to compute gram-
mars faster than the previous approaches (see sec-
tion 4).
</bodyText>
<sectionHeader confidence="0.999462" genericHeader="evaluation">
4 Evaluation
</sectionHeader>
<bodyText confidence="0.999816833333333">
The XMG system has been successfully used by
linguists to develop a core TAG for French contain-
ing more than 6.000 trees. This grammar has been
evaluated on the TSNLP test-suite, with a cover-
age rate of 75 % (see (Crabb´e, 2005)). The meta-
grammar used to produce that grammar consists of
290 classes and is compiled by the XMG system
in about 16 minutes with a Pentium 4, 2.6 GHz
and 1 GB of RAM.7
XMG has also been used to produce a core
size Interaction Grammar for French (see (Perrier,
2003)).
</bodyText>
<footnote confidence="0.86191225">
6See (Duchier and Niehren, 2000) for details .
7Because this metagrammar is highly unspecified, con-
straint solving takes about 12 min. Of course, subsets of the
grammar may be rebuilt separately.
</footnote>
<bodyText confidence="0.990971">
Finally, XMG is currently used to develop a
TAG that includes a semantic dimension along the
line described in (Gardent and Kallmeyer, 2003).
</bodyText>
<sectionHeader confidence="0.980536" genericHeader="conclusions">
5 Conclusion and Future Work
</sectionHeader>
<bodyText confidence="0.999990666666667">
We have presented a system, XMG8, for produc-
ing broad-coverage grammars, system that offers
an expressive description language along with an
efficient compiler taking advantages from logic
and constraint programming techniques.
Besides, we aim at extending XMG to a generic
tool. That is to say, we now would like to obtain
a compiler which would propose a library of lan-
guages (each associated with a specific process-
ing) that the user would load dynamically accord-
ing to his/her target formalism (not only tree-based
formalisms, but others such as HPSG or LFG).
</bodyText>
<sectionHeader confidence="0.99944" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999913566666667">
H. Ait-Kaci. 1991. Warren’s abstract machine: A tu-
torial reconstruction. In Proc. of the Eighth Interna-
tional Conference of Logic Programming.
T. Becker. 2000. Patterns in metarules. In A. Abeille
and O. Rambow, editors, Tree Adjoining Grammars:
formal, computational and linguistic aspects. CSLI
publications, Stanford.
M.H. Candito. 1999. Repr´esentation modulaire
et param´etrable de grammaires ´electroniques lex-
icalis´ees : application au franc¸ais et a` l’italien.
Ph.D. thesis, Universit´e Paris 7.
B. Crabb´e and D. Duchier. 2004. Metagrammar redux.
In CSLP 2004, Copenhagen.
B. Crabb´e. 2005. Repr´esentation informatique de
grammaires fortement lexicalis´ees : Application a`
la grammaire d’arbres adjoints. Ph.D. thesis, Uni-
versit´e Nancy 2.
D. Duchier and J. Niehren. 2000. Dominance
constraints with set operators. In Proceedings of
CL2000.
B. Gaiffe, B. Crabb´e, and A. Roussanaly. 2002. A new
metagrammar compiler. In Proceedings of TAG+6.
C. Gardent and L. Kallmeyer. 2003. Semantic con-
struction in ftag. In Proceedings of EACL’03.
Guy Perrier. 2003. Les grammaires d’interaction.
HDR en informatique, Universit´e Nancy 2.
P. Van Roy. 1990. Extended dcg notation: A tool for
applicative programming in prolog. Technical re-
port, Technical Report UCB/CSD 90/583, Computer
Science Division, UC Berkeley.
</reference>
<footnote confidence="0.6005395">
8XMG is freely available at http://sourcesup.
cru.fr/xmg.
</footnote>
<page confidence="0.99427">
106
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.123816">
<title confidence="0.999428">XMG - An expressive formalism for describing tree-based grammars</title>
<author confidence="0.996483">Yannick Parmentier</author>
<affiliation confidence="0.870445">INRIA / LORIA Universit´e Henri Poincar´e</affiliation>
<address confidence="0.878823333333333">615, Rue du Jardin Botanique 54 600 Villers-Les-Nancy France</address>
<email confidence="0.986402">parmenti@loria.fr</email>
<author confidence="0.9994">Joseph Le_Roux</author>
<affiliation confidence="0.986354333333333">LORIA Institut National Polytechnique de Lorraine</affiliation>
<address confidence="0.893194333333333">615, Rue du Jardin Botanique 54 600 Villers-Les-Nancy France</address>
<email confidence="0.989486">leroux@loria.fr</email>
<author confidence="0.999606">Benoit Crabb´e</author>
<affiliation confidence="0.900845666666667">HCRC / ICCS University of Edinburgh 2 Buccleuch Place</affiliation>
<address confidence="0.816457">EH8 9LW, Edinburgh, Scotland</address>
<email confidence="0.999401">bcrabbe@inf.ed.ac.uk</email>
<abstract confidence="0.981167384615385">this we introduce a system that facilitates the development of tree based grammars. This system includes both (1) a formal language adapted to the description of linguistic information and (2) a compiler for this language. It applies techniques of programming Abstract Machine), thus providing an efficient and theoretically motivated framework for the processing of linguistic metadescriptions.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>H Ait-Kaci</author>
</authors>
<title>Warren’s abstract machine: A tutorial reconstruction.</title>
<date>1991</date>
<booktitle>In Proc. of the Eighth International Conference of Logic Programming.</booktitle>
<contexts>
<context position="9307" citStr="Ait-Kaci, 1991" startWordPosition="1491" endWordPosition="1492">minal symbols are descriptions. To extend the approach to the representation of semantic information as introduced in 2, clause (4) is modified as follows: Goal ::= Dimension+=Description | Name | Goal ∨ Goal |Goal ∧ Goal Note that, with this modification, the XMG language no longer correspond to a Definite Clause Grammar but to an Extended Definite Clause Grammar (see (Van Roy, 1990)) where the symbol += represents the accumulation of information for each dimension. Virtual Machine The evaluation of a query is done by a specific Virtual Machine inspired by the Warren’s Abstract Machine (see (Ait-Kaci, 1991)). First, it computes the derivations contained in the description, i.e. in the Extended Definite Clause Grammar, and secondly it performs unification of non standard data-types (nodes, node features for TAG). Eventually it produces as an output a description, more precisely one description per dimension (syntax, semantics). In the case of TAG, the virtual machine produces a tree description. We still need to solve this description in order to obtain trees (i.e. the items of the resulting grammar). Constraint-based tree description solver The tree description solver we use is inspired by (Duch</context>
</contexts>
<marker>Ait-Kaci, 1991</marker>
<rawString>H. Ait-Kaci. 1991. Warren’s abstract machine: A tutorial reconstruction. In Proc. of the Eighth International Conference of Logic Programming.</rawString>
</citation>
<citation valid="true">
<authors>
<author>T Becker</author>
</authors>
<title>Patterns in metarules.</title>
<date>2000</date>
<booktitle>Tree Adjoining Grammars: formal, computational and linguistic aspects. CSLI publications,</booktitle>
<editor>In A. Abeille and O. Rambow, editors,</editor>
<location>Stanford.</location>
<contexts>
<context position="1675" citStr="Becker, 2000" startWordPosition="248" endWordPosition="249">apid development, the maintenance and the debugging of large scale grammars. While much work has been deployed into producing such factorizing environments for standard unification grammars, less attention has been paid to the issue of developing such environments for “tree based grammars” that is, grammars like Tree Adjoining Grammars (TAG) or Tree Description Grammars where the basic unit of information is a tree rather than a category encoded in a feature structure. For these grammars, two trends have emerged to automatize tree-based grammar production: systems based on lexical rules (see (Becker, 2000)) and systems based on combination of classes (also called metagrammar systems, see (Candito, 1999), (Gaiffe et al., 2002)). 1We are grateful to Claire Gardent for useful comments on this work. This work is partially supported by an INRIA grant. In this paper, we present a metagrammar system for tree-based grammars which differs from comparable existing approaches both linguistically and computationally. Linguistically, the formalism we introduce is both expressive and extensible. In particularly, we show that it supports the description and factorization both of trees and of tree descriptions</context>
</contexts>
<marker>Becker, 2000</marker>
<rawString>T. Becker. 2000. Patterns in metarules. In A. Abeille and O. Rambow, editors, Tree Adjoining Grammars: formal, computational and linguistic aspects. CSLI publications, Stanford.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M H Candito</author>
</authors>
<title>Repr´esentation modulaire et param´etrable de grammaires ´electroniques lexicalis´ees : application au franc¸ais et a` l’italien.</title>
<date>1999</date>
<tech>Ph.D. thesis,</tech>
<institution>Universit´e Paris</institution>
<contexts>
<context position="1774" citStr="Candito, 1999" startWordPosition="262" endWordPosition="263">een deployed into producing such factorizing environments for standard unification grammars, less attention has been paid to the issue of developing such environments for “tree based grammars” that is, grammars like Tree Adjoining Grammars (TAG) or Tree Description Grammars where the basic unit of information is a tree rather than a category encoded in a feature structure. For these grammars, two trends have emerged to automatize tree-based grammar production: systems based on lexical rules (see (Becker, 2000)) and systems based on combination of classes (also called metagrammar systems, see (Candito, 1999), (Gaiffe et al., 2002)). 1We are grateful to Claire Gardent for useful comments on this work. This work is partially supported by an INRIA grant. In this paper, we present a metagrammar system for tree-based grammars which differs from comparable existing approaches both linguistically and computationally. Linguistically, the formalism we introduce is both expressive and extensible. In particularly, we show that it supports the description and factorization both of trees and of tree descriptions; that it allows the synchronized description of several linguistic dimensions (e.g., syntax and se</context>
<context position="5362" citStr="Candito, 1999" startWordPosition="829" endWordPosition="830">n E on node x (a feature can for instance refer to the syntactic category of the node)4. Tree fragments can furthermore be combined using conjunction and/or disjunction. These two operators allow the metagrammar designer to achieve a high degree of factorization. Moreover the XMG system also supports inheritance between classes, thus offering more flexibility and structure sharing by allowing one to reuse and specialize classes. Identifiers’ scope When describing a broadcoverage grammar, dealing with identifiers scope is a non-trivial issue. In previous approaches to metagrammar compilation ((Candito, 1999), (Gaiffe et al., 2002)), node identifiers had global scope. When designing broad-coverage metagrammars however, such a strategy quickly reduces modularity and complexifies grammar maintenance. To start with, the grammar writer must remember each node name and its interpretation and in a large coverage grammar the number of these node names amounts to several hundreds. Further it is easy to use twice the same name erroneously or on the contrary, to mistype a name identifier, in both cases introducing errors in the metagrammar In XMG, identifiers are local to a class and can thus be reused free</context>
</contexts>
<marker>Candito, 1999</marker>
<rawString>M.H. Candito. 1999. Repr´esentation modulaire et param´etrable de grammaires ´electroniques lexicalis´ees : application au franc¸ais et a` l’italien. Ph.D. thesis, Universit´e Paris 7.</rawString>
</citation>
<citation valid="true">
<authors>
<author>B Crabb´e</author>
<author>D Duchier</author>
</authors>
<title>Metagrammar redux.</title>
<date>2004</date>
<booktitle>In CSLP 2004,</booktitle>
<location>Copenhagen.</location>
<marker>Crabb´e, Duchier, 2004</marker>
<rawString>B. Crabb´e and D. Duchier. 2004. Metagrammar redux. In CSLP 2004, Copenhagen.</rawString>
</citation>
<citation valid="true">
<authors>
<author>B Crabb´e</author>
</authors>
<title>Repr´esentation informatique de grammaires fortement lexicalis´ees : Application a` la grammaire d’arbres adjoints.</title>
<date>2005</date>
<tech>Ph.D. thesis,</tech>
<institution>Universit´e Nancy 2.</institution>
<marker>Crabb´e, 2005</marker>
<rawString>B. Crabb´e. 2005. Repr´esentation informatique de grammaires fortement lexicalis´ees : Application a` la grammaire d’arbres adjoints. Ph.D. thesis, Universit´e Nancy 2.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D Duchier</author>
<author>J Niehren</author>
</authors>
<title>Dominance constraints with set operators.</title>
<date>2000</date>
<booktitle>In Proceedings of CL2000.</booktitle>
<contexts>
<context position="9929" citStr="Duchier and Niehren, 2000" startWordPosition="1587" endWordPosition="1590">991)). First, it computes the derivations contained in the description, i.e. in the Extended Definite Clause Grammar, and secondly it performs unification of non standard data-types (nodes, node features for TAG). Eventually it produces as an output a description, more precisely one description per dimension (syntax, semantics). In the case of TAG, the virtual machine produces a tree description. We still need to solve this description in order to obtain trees (i.e. the items of the resulting grammar). Constraint-based tree description solver The tree description solver we use is inspired by (Duchier and Niehren, 2000). The idea is to: 1. associate to each node x in the description an integer, 2. then refer to x by means of the tuple (Eqx, Upx, Downx, Leftx, Rightx) where Eqx (respectively Upx, Downx, Leftx, Rightx) denotes the set of nodes in the description which are equal, (respectively above, below, left, and right) of x (see picture 2). Note that these sets are set of integers. Down Figure 2: node regions The operations supported by the XMG language (i.e. dominance, precedence, etc) are then converted into constraints on these sets. For instance, let us consider 2 nodes x and y of the description. Assu</context>
<context position="13116" citStr="Duchier and Niehren, 2000" startWordPosition="2162" endWordPosition="2165">allows us to compute grammars faster than the previous approaches (see section 4). 4 Evaluation The XMG system has been successfully used by linguists to develop a core TAG for French containing more than 6.000 trees. This grammar has been evaluated on the TSNLP test-suite, with a coverage rate of 75 % (see (Crabb´e, 2005)). The metagrammar used to produce that grammar consists of 290 classes and is compiled by the XMG system in about 16 minutes with a Pentium 4, 2.6 GHz and 1 GB of RAM.7 XMG has also been used to produce a core size Interaction Grammar for French (see (Perrier, 2003)). 6See (Duchier and Niehren, 2000) for details . 7Because this metagrammar is highly unspecified, constraint solving takes about 12 min. Of course, subsets of the grammar may be rebuilt separately. Finally, XMG is currently used to develop a TAG that includes a semantic dimension along the line described in (Gardent and Kallmeyer, 2003). 5 Conclusion and Future Work We have presented a system, XMG8, for producing broad-coverage grammars, system that offers an expressive description language along with an efficient compiler taking advantages from logic and constraint programming techniques. Besides, we aim at extending XMG to a</context>
</contexts>
<marker>Duchier, Niehren, 2000</marker>
<rawString>D. Duchier and J. Niehren. 2000. Dominance constraints with set operators. In Proceedings of CL2000.</rawString>
</citation>
<citation valid="true">
<authors>
<author>B Gaiffe</author>
<author>B Crabb´e</author>
<author>A Roussanaly</author>
</authors>
<title>A new metagrammar compiler.</title>
<date>2002</date>
<booktitle>In Proceedings of TAG+6.</booktitle>
<marker>Gaiffe, Crabb´e, Roussanaly, 2002</marker>
<rawString>B. Gaiffe, B. Crabb´e, and A. Roussanaly. 2002. A new metagrammar compiler. In Proceedings of TAG+6.</rawString>
</citation>
<citation valid="true">
<authors>
<author>C Gardent</author>
<author>L Kallmeyer</author>
</authors>
<title>Semantic construction in ftag.</title>
<date>2003</date>
<booktitle>In Proceedings of EACL’03.</booktitle>
<contexts>
<context position="6855" citStr="Gardent and Kallmeyer, 2003" startWordPosition="1066" endWordPosition="1070">user can specify which are the viewable identifiers (i.e. which identifiers have been exported in the superclass). Extension to semantics The XMG formalism further supports the integration in the grammar of semantic information. More generally, the language manages dimensions of descriptions so that the content of a class can consists of several elements belonging to different dimensions. Each dimension is then processed differently according to the output that is expected (trees, set of predicates, etc). Currently, XMG includes a semantic representation language based on Flat Semantics (see (Gardent and Kallmeyer, 2003)): Description ::= `:p(E1, ..., En) | ¬`:p(E1, ..., En) |Ei « Ej (2) where `:p(E1, ..., En) represents the predicate p with parameters E1,.., En, and labeled `. ¬ is the logical negation, and Ei « Ej is the scope between Ei and Ej (used to deal with quantifiers). Thus, one can write classes whose content consists of tree description and/or of semantic formulas. The XMG formalism furthermore supports the sharing of identifiers across dimension hence allowing for a straightforward encoding of the syntax/semantics interface (see figure 1). 2As we shall later see, a content can in fact be multidim</context>
<context position="13420" citStr="Gardent and Kallmeyer, 2003" startWordPosition="2211" endWordPosition="2214">% (see (Crabb´e, 2005)). The metagrammar used to produce that grammar consists of 290 classes and is compiled by the XMG system in about 16 minutes with a Pentium 4, 2.6 GHz and 1 GB of RAM.7 XMG has also been used to produce a core size Interaction Grammar for French (see (Perrier, 2003)). 6See (Duchier and Niehren, 2000) for details . 7Because this metagrammar is highly unspecified, constraint solving takes about 12 min. Of course, subsets of the grammar may be rebuilt separately. Finally, XMG is currently used to develop a TAG that includes a semantic dimension along the line described in (Gardent and Kallmeyer, 2003). 5 Conclusion and Future Work We have presented a system, XMG8, for producing broad-coverage grammars, system that offers an expressive description language along with an efficient compiler taking advantages from logic and constraint programming techniques. Besides, we aim at extending XMG to a generic tool. That is to say, we now would like to obtain a compiler which would propose a library of languages (each associated with a specific processing) that the user would load dynamically according to his/her target formalism (not only tree-based formalisms, but others such as HPSG or LFG). Refer</context>
</contexts>
<marker>Gardent, Kallmeyer, 2003</marker>
<rawString>C. Gardent and L. Kallmeyer. 2003. Semantic construction in ftag. In Proceedings of EACL’03.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Guy Perrier</author>
</authors>
<title>Les grammaires d’interaction. HDR en informatique,</title>
<date>2003</date>
<journal>Universit´e Nancy</journal>
<volume>2</volume>
<contexts>
<context position="13081" citStr="Perrier, 2003" startWordPosition="2159" endWordPosition="2160">olve tree descriptions allows us to compute grammars faster than the previous approaches (see section 4). 4 Evaluation The XMG system has been successfully used by linguists to develop a core TAG for French containing more than 6.000 trees. This grammar has been evaluated on the TSNLP test-suite, with a coverage rate of 75 % (see (Crabb´e, 2005)). The metagrammar used to produce that grammar consists of 290 classes and is compiled by the XMG system in about 16 minutes with a Pentium 4, 2.6 GHz and 1 GB of RAM.7 XMG has also been used to produce a core size Interaction Grammar for French (see (Perrier, 2003)). 6See (Duchier and Niehren, 2000) for details . 7Because this metagrammar is highly unspecified, constraint solving takes about 12 min. Of course, subsets of the grammar may be rebuilt separately. Finally, XMG is currently used to develop a TAG that includes a semantic dimension along the line described in (Gardent and Kallmeyer, 2003). 5 Conclusion and Future Work We have presented a system, XMG8, for producing broad-coverage grammars, system that offers an expressive description language along with an efficient compiler taking advantages from logic and constraint programming techniques. Be</context>
</contexts>
<marker>Perrier, 2003</marker>
<rawString>Guy Perrier. 2003. Les grammaires d’interaction. HDR en informatique, Universit´e Nancy 2.</rawString>
</citation>
<citation valid="true">
<authors>
<author>P Van Roy</author>
</authors>
<title>Extended dcg notation: A tool for applicative programming in prolog.</title>
<date>1990</date>
<tech>Technical report, Technical Report UCB/CSD 90/583,</tech>
<institution>Computer Science Division, UC Berkeley.</institution>
<marker>Van Roy, 1990</marker>
<rawString>P. Van Roy. 1990. Extended dcg notation: A tool for applicative programming in prolog. Technical report, Technical Report UCB/CSD 90/583, Computer Science Division, UC Berkeley.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>