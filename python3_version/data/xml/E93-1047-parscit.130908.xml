<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<title confidence="0.890668">
[Type-Driven Semantic Interpretation of f-Structures
</title>
<note confidence="0.656279">
(.7,W),(R,K))
</note>
<author confidence="0.989893">
Jürgen Wedekind
</author>
<affiliation confidence="0.996318">
Institute for Natural Language Processing
University of Stuttgart
</affiliation>
<address confidence="0.957429">
Azenbergstr. 12
D-7000 Stuttgart 1, FRG
</address>
<email confidence="0.989467">
juergen@ims.uni-stuttgart.de
</email>
<author confidence="0.982722">
Ronald M. Kaplan
</author>
<affiliation confidence="0.922289">
Xerox Palo Alto Research Center
</affiliation>
<address confidence="0.8643255">
3333 Coyote Hill Road
Palo Alto, California 94304 USA
</address>
<email confidence="0.996427">
Kaplan.Parc@Xerox.Com
</email>
<sectionHeader confidence="0.998578" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999979714285715">
The formal architecture of Lexical Func-
tional Grammar offers a particular formal
device, the structural correspondence, for
modularizing the mapping between the sur-
face forms of a language and representa-
tions of their underlying meanings. This
approach works well when the structural
discrepancies between form and meaning
representations are finitely bounded, but
there are some phenomena in natural lan-
guage, e.g. adverbs in English, where this
restriction does not hold. In this paper, we
describe rule-based type-driven interpreta-
tion algorithms which cover cases of such
a structural misalignment by exploiting a
new descriptive device, the &amp;quot;restriction op-
erator&amp;quot;. The algorithms are set up in such
a way that recursive rules can be derived
for the interpretation of adjunct sets within
a codescription approach (see [Kaplan and
Wedekind, 1993] for details).
</bodyText>
<sectionHeader confidence="0.999471" genericHeader="keywords">
1 Introduction
</sectionHeader>
<bodyText confidence="0.999935258064516">
In [Kaplan and Bresnan, 1982] Lexical Functional
Grammar (LFG) was introduced as a grammatical
formalism that assigns to a sentence entities of two
different levels of representation: a c-structure rep-
resenting information on the structure of the phrases
of a sentence and an f-structure which represents its
underlying predicate-argument structure. The struc-
tures are set in correspondence by a function from
the c-structure nodes (constituents) into the sub-
structures of the f-structure. The f-structure is iden-
tified with the smallest structure that satisfies the
f-description, a description of the f-structure which
is built up by instantiation of the annotations of the
context-free rules and projected off the c-structure
by the correspondence mapping.
This architecture was then extended by Kaplan
[1987] and Halvorsen [1987] to structures represent-
ing information on other levels of linguistic repre-
sentation. These structures (called projections) are
codescribed by the annotations of the context-free
grammar and set in correspondence by additional
projectors. Furthermore, Kaplan et al. [1989] applied
the general correspondence architecture to the prob-
lem of translation by projecting from the f-structure
of a sentence of a given source language an addi-
tional f-structure of its translation into some target
language.
Within the domain of semantic interpretation,
which is the topic here, the semantic structures are
the range of the or-projector which maps substruc-
tures of the f-structure into corresponding substruc-
</bodyText>
<table confidence="0.840681666666667">
tures of the semantic structure. PRED In figure 1, the
S ----- sji„ &apos;arrive(suBJ)&apos; cr
NP VP , [PEED `john&apos;s0
N FtEL arrive
John arrived ARG1 john
[1
</table>
<figureCaption confidence="0.89962">
Figure 1
</figureCaption>
<bodyText confidence="0.9765622">
Structural correspondences between c-, f- and
a-structure.
semantic structure (a-structure) and the structural
correspondence between f- and a-structure for the
sentence John arrived are codescribed by additional
</bodyText>
<page confidence="0.997432">
404
</page>
<bodyText confidence="0.645183">
annotations of the lexical entry for arrived in (1).
</bodyText>
<equation confidence="0.427567">
(1) arrived: V, (1 PRED) = &apos;arrive(SUBJ)&apos;
(a I REL) = arrive
(cr I ARG1) = a(j suBJ)
</equation>
<bodyText confidence="0.996363444444444">
Within the domain of translation, Wedekind [1988],
and Sadler and Thompson [1991] recognized some
problems of the correspondence approach which con-
cern data of head-switching. These difficulties also
arise in the domain of semantic interpretation. In
the latter domain we find constructions where the
syntactic head (the predicate) does not correspond
to the semantic head as, e.g., in adverbially-modified
sentences like (2)
</bodyText>
<listItem confidence="0.579485">
(2) John arrived late
whose f- and cr-structure are given in figure 2. In
</listItem>
<figure confidence="0.40208925">
[
ADJ {a:[PRED latel}
f: PRED `arrive(suro)&apos;
SUBJ [PRED &apos;john&apos;]
</figure>
<figureCaption confidence="0.950303">
Figure 2
</figureCaption>
<bodyText confidence="0.917604619047619">
Head-switching between f- and a-structure.
this diagram, the semantic-structure corresponding
to the entire f-structure has the adverb &amp;quot;late&amp;quot; as its
top-level relation, even though this does not corre-
spond to the syntactic (f-structure) head &amp;quot;arrive&amp;quot;.
Intuitively, the semantic argument (ARG1) of the ad-
verb corresponds to the information coded in the par-
tial f-structure (3), which comprises only the infor-
mation concerning the subject and the predicate of
the sentence.
(3)[
PRED 4arrive(sual)&apos; I
SUBJ [PRED &apos;john&apos;]
The formal difficulty is that this is not an isolated
unit of the f-structure and hence cannot be in the
domain of a. However, the f-structure description
language can be extended by introducing a restric-
tion operator which allows explicit reference to such
smaller f-structures. The restriction operator &amp;quot;\&amp;quot;
which is defined in (4) below&apos; allows us then to refer
to the partial structure (3) by the term f \ (ADJ a).
</bodyText>
<listItem confidence="0.7358256">
(4) The restriction operator is defined for an f-
structure f and an attribute A by:
(i) f\A = fi Do m ( f ) — {A} if the value of (f A)
a structure, and
(ii) if g E (f A) (i.e. if (f A) is set-valued) by
</listItem>
<equation confidence="0.3205775">
f f \ A if (f — {g} =
U {(A, (f A) — {g})} else.
</equation>
<bodyText confidence="0.993594173076923">
&apos;Cf. [Kaplan and Wedekind, 1993] for more details.
On the other hand, it becomes clear by examples
with more than one adjunct that in addition a new
source for recursion is needed, since it must in prin-
ciple be possible to construct a multiple nesting for
adjunct sets whose size is not bounded by any fixed
finite upper bound.&apos;
In order to identify this additional recursive de-
vice and to test our extended description language
for adequacy, we picked out Montague semantics as
a well-known semantic theory and tried to specify the
syntax-semantics interface by a rule-based semantic
interpretation mechanism. Our goal is to derive the
semantic representation by analyzing the f-structure
recursively. We assume an interpretation mechanism
that operates on f-structures (possibly extended by
information on the linear precedence of the predi-
cates) and can be stated by very general composi-
tionality principles without relying on any kind of
transformations. This is because an f-structure of
a sentence represents its deep structure in terms of
predicate-argument relations where all information
relevant for the interpretation is locally available.
Furthermore, we want to ensure the &amp;quot;completeness&amp;quot;
of the interpretation and to specify conditions which
allow us to control the &amp;quot;conservativity&amp;quot; of the exten-
sion (for those who require that a theory of gram-
mar such as LFG be strong enough to ensure the
(semantic) well-formedness of the strings accepted
by a particular grammar). On the other hand, we
want the semantic structure to be accessible from
the f-structure by an explicit interpretation function
(a-projector) in order to be able to formulate con-
straints, e.g. binding and scoping principles, which
constrain the interpretation of the f-structures.
In this paper, we give three different type-driven
interpretation mechanisms which fulfill the require-
ments given above. The first one is a rather simple
top-down algorithm that can be described by our ex-
tended description language but cannot be used for
all type systems. The second algorithm is a more
powerful bottom-up algorithm which can be used for
all type systems but not formulated in our descrip-
tion language. The third one, finally, is a top-down
simulation of the second algorithm which is again de-
scribable in our description language. The fact that
the third algorithm can be described by our extended
description language seems to confirm the adequacy
of our extension by the restriction operator. Further-
more, this investigation indicates that an additional
description-by-analysis mechanism is needed within
a codescription approach in order to handle cases
</bodyText>
<equation confidence="0.915536625">
late
[
REL arrive]
ARG1 john
[REL
ARG1
f\(Ag) =
is 2This situation, where the recursion given by the
</equation>
<bodyText confidence="0.993394">
context-free rule system turns out not to be the adequate
or at least desirable carrier for specific (recursive) descrip-
tion purposes, is not unusual. Functional uncertainty was
e.g. introduced as a new recursive device operating on f-
structures, since unbounded dependencies could be more
adequately handled by this new mechanism than by ex-
ploiting the recursive phrase structure rule system alone.
</bodyText>
<page confidence="0.998542">
405
</page>
<bodyText confidence="0.999659">
where the interpretation recursion is completely in-
dependent of the recursion given by the context-free
grammar (cf. [Kaplan and Wedekind, 19931).
</bodyText>
<sectionHeader confidence="0.8977215" genericHeader="introduction">
2 A Simple Top-down Type-driven
Interpretation Algorithm
</sectionHeader>
<bodyText confidence="0.999891307692308">
In order to sketch how we can achieve a decompo-
sition of an f-structure which is sufficient for its in-
terpretation, we first introduce a simple top-down
interpretation procedure which is restricted to cer-
tain special type systems. For the interpretation
we generally assume from now on that types are as-
signed to all grammatical function values and seman-
tically relevant atomic-valued features by a type as-
signment TY. Aside from the fact that grammatical
functions and values and not c-structure constituents
are typed, this assignment is similar to the one used
in Montague grammar. The structure in figure 3 e.g.
is an oversimplified typed f-structure3 of the sentence
</bodyText>
<listItem confidence="0.69919">
(5) John arrived late today.
</listItem>
<figureCaption confidence="0.73047">
Figure 3
</figureCaption>
<bodyText confidence="0.9884712">
The typed f-structure of sentence (5).
The typing of the f-structures can e.g. be established
by additional type-assigning annotations within a
grammar. Examples of such augmented rules and
lexical entries are given in (6).
</bodyText>
<equation confidence="0.963122">
(6) S NP VP
sum)
TY(1) = e TY(1). t
arrived: V, (1 PEED) = &apos;arrive&apos;
• • •
PRED ) = (e,i)
</equation>
<bodyText confidence="0.999761814814815">
It is of course possible to think of more sophisti-
cated type inheritance mechanisms for the specifi-
cation of the f-structure typing. The investigation
of such mechanisms, however, is beyond our present
concerns.
The restrictedness of the algorithm results from
the fact that it operates under the assumption that
we can recursively decompose each f-structure f into
&apos;We drop the subcategorization frames in the
following.
a substructure or set element which corresponds to
a one-place main functor and the rest structure of f
which is interpreted as the argument of that functor.
Although this restriction seems to be rather strong,
this algorithm gives the right hierarchical semantic
structures for the problematic flat f-structures con-
taining sentence modifiers. And if we assume the
usual type-raising for the subcategorized functions,
it also describes all possible structural ambiguities
for predicate modifiers, quantifiers, etc.4 In detail,
the algorithm works as follows.
Proceeding from an initial mapping of a given f-
structure f into an empty semantic structure the in-
terpretation works top-down according to the follow-
ing two principles:
If ow is defined and h is a substructure (h = (g A))
or an element of a set-value of g (h E (g A)) and
</bodyText>
<equation confidence="0.88514">
(Al) TY(g)= r and TY(h) = (r&apos;, r) then
(i) (g A) = h (erg Fu) = A
(crg ARG) = cr(g\A) A TY(g \A) =
(ii) h E (g A) —+ (erg FU) = ohA
(ag ARG) = cr(g\(A h))A TY(g\(A h )) =
(A2) TY(g)= r A TY(h) = r crg =
</equation>
<bodyText confidence="0.999987045454545">
The principle (Al) allows us to select a substructure
or an element of a set value of type (r&apos;, r) from a
structure g of type T, which is already mapped into
the semantic representation, as a functor and inter-
pret the rest of g as its argument which becomes
then of type r&apos;.5 If we apply principle (Alii) to
the structure in figure 3 and choose b as the func-
tor we end up with the constellation in figure 4.
For an interpreted structure g containing an imme-
diate substructure or a set element h, principle (A2)
drops the interpretation downwards if g and h are
of the same type. This principle can then be ap-
plied e.g. to b of figure 4 and achieves the mapping
in figure 5. Figure 6 gives a complete type-driven
derivation of the functor-argument structure of (5)
with wide scope of &apos;late&apos;. One gets the other reading
by first selecting b as described above.
Note that the meanings are not constructed by our
procedure. The complete semantic representation re-
sults then from the insertion of the meanings of the
basic expressions which are assumed to be specified
in the lexicon via equations like the following:
</bodyText>
<equation confidence="0.719881">
late: ADV, PEED) = &apos;late&apos;
cra PEED) = Ap(L(p)).
</equation>
<bodyText confidence="0.972248285714286">
4 For further illustration of the algorithms we give ex-
amples involving transitive verbs in the appendix.
&apos;Note that a distinct re-interpretation of an already
interpreted structure always fails, since predicates and
predicate projections do not unify in LFG. Without this
assumption, one would have to add to the principles the
condition that g has no interpreted part.
</bodyText>
<figure confidence="0.998104083333333">
Ia: [FRED
(t,i)
b:[PEED
(gm
[&apos;arrive&apos;
[FRED [john}}
ADJ
PEED
SUB.&apos;
[&apos;late&apos;ll
Lo.1)
[(today 11
</figure>
<page confidence="0.946048">
406
407
</page>
<figure confidence="0.9997044">
ADJ
{a: [PRED [late]]
0.0 0.0
b: [PRED [&apos;today I]
I.() (&amp;quot;)
[&apos;arrive]
(0,0
FRED
f:
ADJ
FRED
SUBJ
f\ (ADJ a):
ft:[PREmp (t.
[&apos;arrive]
L(e,e) j
[&apos;RED NOW]
1.6
Ag(T(g))
FU AX(A(Z))1
ARG j
A(j)
FU Ap(L(p))
ARG [FU
ARG
T(A(j))
L(T(A(j)))
SUBJ
f\ (ADJ b):
SUBJ
ADJ
f:
PRED
SUBJ
f\ (ADJ b)
So, we end up with the expression L(T(A(j))) which
a corresponds to the wide scope reading of &apos;late&apos;.
[FAL
[PRED Al]
PRED
f\ (ADJ
a) \ (ADJ b):
[PLIED
SUBJ
[&apos;arrive&apos;
[pRED Pjohn&apos;ll
ADJ a: PRED
{
(4)
[&apos;arrive
]
(C4)
[PRED rjohnl
[&apos;late]]
04) j
</figure>
<figureCaption confidence="0.963456">
Figure 4
</figureCaption>
<bodyText confidence="0.71862975">
The result of applying principle (Alii) to b E (f ADJ)
in figure 3.
Figure 5
The result of applying principle (A2) to b in figure 4.
The result is then the following structure
FU
and the meaning of the sentence can be calculated
bottom-up by )-conversion in the usual way
</bodyText>
<figure confidence="0.5420388">
[f\ (ADJ a) \ (ADJ b)\PRED: SUBJ
Figure 6
A complete derivation of one reading of (5).
3 A Bottom-up Type-driven
Interpretation Algorithm
</figure>
<bodyText confidence="0.999553375">
In the following we sketch a more powerful mecha-
nism which can also handle cases where the functor
is not given by a substructure (f A) or a set ele-
ment g E (f A) but by a partial structure g sub-
sumed by f (g C f) as e.g. in the typed structure
for sentence (7) in figure 7. Here the part of the f-
structure that comprises the modifiers and the predi-
cate has to be interpreted as the main functor (either
</bodyText>
<figure confidence="0.997547552631579">
AP(L(P))
FU Ag(T(q))
ARG ARG [FU AX(A(X))1
ARG j
[FRED
f:
jarrive]]
AR ohn
today
late
PU
{
a: [Pam
(.4)
b: [FRED
(14)
[&apos;arrive
]
(.4)
[&apos;late]]
(Ct.&apos;) j
[&apos;today&apos;i
((4)
{pRE— johnl
[b: Ia: [FRED
1(&amp;quot;)
FRED
(1,0
[&apos;arrive
]
(.4) J
{PRED Pjohnl
Le
ADJ
PRED
SUBJ
Stimes(twice(knock)) or twice(Stimes(knock))).
(7) John knocked twice three times.
</figure>
<figureCaption confidence="0.999809">
Figure 7
</figureCaption>
<bodyText confidence="0.930073466666667">
The typed f-structure of sentence (7).
Let &amp;quot;i&amp;quot; be a new operator which is defined for a sub-
structure (f A) off by f IA = fl{A} and for a set ele-
ment g E (f A) by fl(A g) = VA,{g})}. The value is
simply the f-structure subsumed by f which has only
attribute A with its value in f or with the singleton
set-value g. For every attribute or attribute-element
pair x, f\x and flx are in fact complementary with
respect to f, that is, f\x 11 fix = 0.
Proceeding from the interpretations of the basic
expressions introduced by the lexical entries the al-
gorithm works bottom-up according to the following
principles:
(B1) If crh and crk are defined, h C g, k C g and
hn k = 0 and TY (h) = (r, TI) and
</bodyText>
<equation confidence="0.982870666666667">
TY (k) = r, then
uh = (cr(h U k) FU) A crk = (cr(h U k) ARG) A
TY (hU k) = Ti
</equation>
<listItem confidence="0.893891">
(B2) If ch is defined and TY (h) = T, then
(i) (g A) = h TY (g I A) = r A crh =
and
(ii) h E (g A) TY (gRA h)) = 7A
crh = cr(g(A h)).
</listItem>
<bodyText confidence="0.998941">
Principle (B2) pushes the interpretation from an in-
terpreted structure h one level upwards to the partial
structure of the given structure which contains only h
as an attribute- or set-value and assigns to that par-
tial structure the type of h. Note that principle (B2)
can only be applied if g IA resp. gl(A h) has no type
assignment or is of the same type as h (otherwise the
type assignment would not be a function).
If a structure g contains two disjoint partial struc-
tures h and k, one of them being an appropriate
argument for the other, then the structures are in-
terpreted according to principle (B1) as the functor
resp. argument of the interpretation of their unifi-
cation. This is then assigned the value-type of the
functor. Figure 8 shows how the semantic represen-
tation of one reading of sentence (7) is constructed.
We represent here attribute-value paths in DAG form
</bodyText>
<figureCaption confidence="0.637375">
Figure 8
The bottom-up construction of one reading of (7).
</figureCaption>
<bodyText confidence="0.9999015">
and depict the decomposition of the f-structure as a
graph where each subtree dominated by a branching
node represents the partial f-structure which com-
prises the attribute-value paths contained in that
subtree. The construction starts with the mapping of
the terminal nodes provided by the lexical entries of
the basic expressions. Each mapping of a structure
dominated by a non-branching non-terminal node
results from an application of principle (82). The
interpretation of a partial substructure (a structure
dominated by a branching node) is constructed by
principle (B1).
</bodyText>
<sectionHeader confidence="0.992377666666667" genericHeader="method">
4 A Top-down Simulation of the
Bottom-up Interpretation
Algorithm
</sectionHeader>
<bodyText confidence="0.99904125">
The restrictedness of the simple top-down algorithm
results from the fact that the main functor was al-
ways assumed to take exactly one argument which
is represented by the semantics of the rest of the
f-structure. The algorithm fails in cases where the
type of the substructure representing the main func-
tor indicates that more than one argument is needed
by the main functor in order to yield a meaning of the
type of the entire f-structure. If we choose e.g. the
`3times&apos; modifier in the structure of figure 7 as the
main functor (having widest scope), then we need a
first argument of type (e, t) and a second argument
of type e to get a meaning of type t. So, the rest
of the structure corresponds in the general case to a
list or set of arguments.
In order to overcome this difficulty, we assign to
</bodyText>
<figure confidence="0.999093096774193">
SUBJ
PRED
&apos;john&apos;
((,t),(e,t))
ADJ
PRED
&apos;twice&apos; `3times
(a,t)
PRED
0,0
&apos;knock&apos;
[FU
ARG
ARG john
twice
rAR&amp;line
G knock
FU
1 a: {PRED
((*.,),(..0)
b: [FRED
((4..),(.4))
[PRED rjohnl ]
[&apos;knock&apos;
(.,t)
AD3
SUBJ
PRED
F3times&apos; 11
,e) ,(e ,t))
r‘twice&apos;
</figure>
<page confidence="0.997026">
408
</page>
<bodyText confidence="0.999869833333333">
the rest structure now a separate semantic structure.
This structure is a set that contains typed variables
for all those arguments which are still needed to sat-
urate previously processed (complex) functors. If we
start with the `3times&apos; modifier this set contains the
typed variables ae and a(0). In detail the algorithm
works as follows.
If TY(f) = r the algorithm starts from the initial
assignment of = f, and proceeds top-down accord-
ing to the following principles:
If crg is defined and h is a substructure (h = (g A))
or an element of a set-value of g (h E (g A)),
</bodyText>
<equation confidence="0.870255153846154">
TY(h) = (rn, r)..)) and
(Cl) ag = k, and n &gt; 0, or there is a k, E crg and
n &gt; 0, then
ah = (k, FUR) =
(k, FUi-1 ARG) = 4, (for each i = 1, n)
and
if (g A) = h then
, } if kr = crg
a(g\A)=
(erg - fk,DU „K.} else,6
(ii) if h E (g A) then cr(g\(A h)) is determined as
in case (i),
(C2) ag = k, and n = 0, then ug = ah.
</equation>
<bodyText confidence="0.999981470588235">
In contrast to the simple top-down algorithm, each
application of (Cl) creates a new semantic structure
which includes typed variables for all missing argu-
ments. The new structure is linked to structures pre-
viously constructed either by explicit reentrancies or
because they share common substructures. (The lat-
ter is enforced, since all those arguments (typed vari-
ables) which remain to be found after selecting k, are
passed on to the semantic representation of the next
restriction by (Cli,ii).) Reentrancies are used to link
the (new) arguments to their right positions which
are encoded in a functor-argument matrix in ug by
applying (Cl). Figure 9 gives three steps of a deriva-
tion of one reading of (7). (We omit in the example
the upper indices of the typed variables provided by
(Cl), since no functor needs more than one argument
of the same type.)
</bodyText>
<sectionHeader confidence="0.957437" genericHeader="method">
5 Completeness, Conservativity,
Constraints and Compositionality
</sectionHeader>
<bodyText confidence="0.997889090909091">
Since the meaning of a sentence with an f-structure
f is given by the formula described by the seman-
tic representation of, the bottom-up construction
is successful if we have constructed a value for of.
Within the top-down approaches the meaning of each
basic expression represented in the f-structure has
to be connected with the root crf, otherwise the se-
mantic representation would not be a description of
a well-formed formula.
°I.e., if kr E crg.
In LFG, we can ensure that all syntactically well-
formed utterances are also semantically well-formed
by mechanisms which are already part of the theory.
By the completeness and coherence conditions it can
first be guaranteed that the different kinds of nuclei
(consisting of a predicate and the functions it sub-
categorizes for) will get an interpretation of the right
type. Since all free grammatical functions (ADJ) are
homogeneous functors (argument and value are of
the same type) and it is clear from the c-structure
rules which type of argument they modify (a modifier
on S-level is either a sentence or predicate modifier,
</bodyText>
<figure confidence="0.9735415">
4--.—,.......„N
ab: IfrpuRERE..ti)):, 0) dc:: iff,:3:::initi)c,:es.:0) 11 i 1
1
g: fr.::::: it;ohn Ili i
1: r knock&apos;l
(.4)
rPU b((e,t),(e,t)):
61°4 LARG
fb: [FRED d: rtvvice&apos;
((),0,0) (
g: {PRED h:Pohnli
[&apos;knock&apos;l
j
[
FU
ARG
{ARGFU a ((e,e),(e,e)):
ADJ
1:
SUBJ
PRED
r
[
SUBJ
PEED
ae:
Ih:Ljohnli
f \ (AD J a) \ (ADJ b):
g: [PEED
Pknock&apos;l
L(.t)
Figure 9
Some steps of the interpretation of (7).
(i)
</figure>
<page confidence="0.997625">
409
</page>
<bodyText confidence="0.993538387755102">
etc.), f-structures with free functions can also be en-
sured to be interpreted.
On the other hand particular readings can be ex-
cluded by global binding and/or scoping principles,
similar to the ones formulated in [Dalrymple et al.,
19901. These principles constrain the interpretation
of the f-structures and their parts if special con-
ditions are satisfied. By combining outside-in and
inside-out functional uncertainty we can express by
the following constraint e.g. that under some condi-
tions E the substructure (t A) of an f-structure has
wide scope over (1 B):
E ((Fu a.(t A)) ARG+ FU) =, cr(i B).
Due to the interpretation function (a) between a
typed f-structure and its semantic representation it
is also possible to formulate a compositionality prin-
ciple very similar to the classical one. The classi-
cal compositionality principle (Frege principle) says
roughly that the meaning of an expression is a func-
tion of the meaning of its components and their mode
of combination and is normally specified in terms
of c-structure categories and their immediate con-
stituents. As is well-known, the attractiveness of this
principle gets lost to some degree if we have to handle
phenomena which can only be described by assuming
transformations on the constituent structures.
In LFG, the f-structures describe explicitly the
underlying predicate-argument structures of well-
formed expressions, and the components of an ex-
pression are taken to be the sets of string elements
that are mapped via 0 (the structural correspon-
dence between c- and f-structure) to the units of
its type-driven decomposed f-structure. On this
view, the meaning of an expression remains a func-
tion of the meaning of its components. Thus,
the reading of sentence (5) given in figure 6, e.g.,
is composed of the meanings of the components
{(1, John), (2, arrived), (4, today)} and (3, late)} as-
sociated with f (ADJ a) and a by 0, respectively.
Their mode of combination (determined by the type
assignment) is encoded in the functor-argument ma-
trix as function-application of cra to cr(f\ (ADJ a))
(i.e. the meaning is cra(c(f \ (ADJ a)))). Ambigui-
ties result then from the indeterminism of the type-
driven decomposition of the f-structure of a sentence.
Thus, we can state for LFG a compositionality prin-
ciple without assuming any kind of transformations,
since all information relevant for the interpretation
is locally available (cf. e.g. [Bresnan et al., 1982]).
</bodyText>
<sectionHeader confidence="0.999603" genericHeader="conclusions">
6 Conclusion
</sectionHeader>
<bodyText confidence="0.999158133333333">
In this paper and in [Kaplan and Wedekind, 1993]
we introduced a new formal device, the &amp;quot;restriction
operator&amp;quot;, into the language of functional descrip-
tions. This operator provides a natural account of
the misalignment between f-structures and semantic
structures in cases where semantic units correspond
intuitively to subsets of functional information. We
tested this new descriptive device by formulating uni-
versal interpretation principles that derive represen-
tations of a Montagovian semantics by recursively
analyzing typed f-structures. We outlined three in-
terpretation algorithms, all of which depend on a
description-by-analysis recursion that is independent
of the recursion of the phrase-structure grammar.
The first algorithm is formulated in terms of the
f-designators provided by our extended description
language, but is restricted to special type systems.
In order to cover arbitrary type systems, we intro-
duced a more powerful bottom-up algorithm which
we were then able to simulate in a top-down fashion
using again only the f-designators of our extended
description language. This provides some support
for the adequacy of our extended description lan-
guage and reinforces the results reported by Kaplan
and Wedekind [1993]. They combined the restric-
tion operator with description-by-analysis rules for
the interpretation of sentential and VP-adjuncts in a
codescription approach which, although not explic-
itly driven by types, is patterned after the top-down
algorithms presented here.
</bodyText>
<sectionHeader confidence="0.992995" genericHeader="acknowledgments">
Appendix
</sectionHeader>
<bodyText confidence="0.9997865625">
Because of the particularly interesting cases of mis-
alignment that they present, we concentrated in the
main part of this paper almost exclusively on the
interpretation of modifiers. Also, modifiers are in-
volved in the head-switching translation problems
discussed by Kaplan and Wedekind [1993], and the
algorithms proposed here underlie the description-
by-analysis approach that we developed in that pa-
per. As suggested by the reviewers, we briefly sketch
in this appendix how our approach extends to exam-
ples involving transitive verbs. Although their inter-
pretation depends crucially on the type system and
the actual meaning assigned to transitive verbs in
the lexicon, we assume here a type system which is
well-known from PTQ. This type system allows us
to cover quantifier scope ambiguities as in (8)
</bodyText>
<listItem confidence="0.677064">
(8) Every man loves a woman.
</listItem>
<bodyText confidence="0.999984818181818">
If we apply the simple top-down algorithm to the
typed f-structure of (8) we get both readings due to
an indeterminism in picking out the functors. Fig-
ure 10 shows some steps of a derivation where the
universal quantifier has wide scope. (The other read-
ing would be the result if (f ow) were selected first.)
Although the given type system would, of course, al-
ways yield SUBJ/OBJ scope ambiguities, specific read-
ings can be excluded by a system of interacting scop-
ing constraints, since the semantic structure is ac-
cessible via the cr-projector.7 The functional uncer-
</bodyText>
<footnote confidence="0.71542725">
7In the few cases where the the scope is determined
by the transitive verb itself, e.g. some passive forms in
English, the appropriate reading can be enforced directly
by using A-expressions which refer explicitly to the mean-
</footnote>
<page confidence="0.993546">
410
</page>
<figure confidence="0.87957265">
(f suBJ) \ SPEC: FRED
(e,t) [man]
OM
revery&apos;
(..i),((..,),0)]
SUBJ [SPEC
PRED [&apos;man&apos;l
1: PRED [&apos;love&apos;
SPEC [&apos;a&apos;
[((.t)
OBJ [PRED
[&apos;woman&apos;
(e,t)
\ PRED
f\suBJ:
OBJ
Figure 10
Some steps in the derivation of one reading of (8).
tainty constraint
((FU er(T SUBJ)) ARG+ FU) =c 0(T OBJ)
</figure>
<bodyText confidence="0.94791625">
which can, appropriately annotated, be used in the
grammar to enforce directly wide scope of the subject
is just a simple example of the form of a constraint
contained in such a system.
</bodyText>
<sectionHeader confidence="0.999203" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.997827581395349">
[Bresnan et at., 1982] Bresnan, J., R. Kaplan, S. Pe-
ters, and A. Zaenen. Cross-serial Dependencies in
Dutch. Linguistic Inquiry 13, 613-635, 1982.
[Dalrymple et al., 1990] Dalrymple, M., J. Maxwell,
and A. Zaenen. Modeling Syntactic Constraints
on Anaphoric Binding. In Proceedings of the 13th
International Conference on Computational Lin-
guistics. Helsinki, 1990.
[Halvorsen, 1987] Halvorsen, P.-K. Situation Seman-
tics and Semantic Interpretation in Constraint-
based Grammars. CSLI Report No. 87-101. Stan-
ford University, 1987.
ings of the grammatical functions. (If we would e.g. use
)tx(OBY(love1(x))) as the a-value for &apos;love&apos;, we would al-
ways get wide scope of the subject.)
[Kaplan, 1987] Kaplan, R. Three Seductions of
Computational Psycholinguistics. In P. Whitelock
et al., eds., Linguistic Theory and Computer Ap-
plications. London: Academic Press, 1987.
[Kaplan and Bresnan, 1982] Kaplan, R., and J.
Bresnan. Lexical-Functional Grammar: A For-
mal System for Grammatical Representation. In
J. Bresnan, ed., The Mental Representation of
Grammatical Relations. Cambridge, Mass.: The
MIT Press, 1982.
[Kaplan et al., 1989] Kaplan, R., K. Netter, J.
Wedekind, and A. Zaenen. Translation by Struc-
tural Correspondences. In Proceedings of the 4th
Conference of the European Chapter of the Associ-
ation for Computational Linguistics. Manchester,
1989.
[Kaplan and Wedekind, 1993] Kaplan, R., and J.
Wedekind. Restriction and Correspondence-based
Translation. In Proceedings of the 6th Conference
of the European Chapter of the Association for
Computational Linguistics. Utrecht, 1993.
[Sadler and Thompson, 1991] Sadler, L., and H.
Thompson. Structural Non-Correspondence in
Translation. In Proceedings of the 5th Confer-
ence of the European Chapter of the Association
for Computational Linguistics. Berlin, 1991.
[Wedekind, 1988] Wedekind, J. Transfer by Projec-
tion. Ms., University of Stuttgart, 1988.
</reference>
<figure confidence="0.9943385">
[&apos;love&apos; 1
[SPEC [&apos;a&apos;
((...),((.0.0)]
PRED [woman&apos;l
0,0
((.4),f)
</figure>
<page confidence="0.981422">
411
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.104231">
<title confidence="0.827432">Semantic Interpretation of f-Structures</title>
<web confidence="0.249186">(.7,W),(R,K</web>
<author confidence="0.905471">Jürgen Wedekind</author>
<affiliation confidence="0.99618">Institute for Natural Language Processing University of Stuttgart</affiliation>
<address confidence="0.9880155">Azenbergstr. 12 D-7000 Stuttgart 1, FRG</address>
<email confidence="0.988509">juergen@ims.uni-stuttgart.de</email>
<author confidence="0.999904">Ronald M Kaplan</author>
<affiliation confidence="0.997693">Xerox Palo Alto Research Center</affiliation>
<address confidence="0.9985545">3333 Coyote Hill Road Palo Alto, California 94304 USA</address>
<email confidence="0.982397">Kaplan.Parc@Xerox.Com</email>
<abstract confidence="0.971835227272727">The formal architecture of Lexical Functional Grammar offers a particular formal device, the structural correspondence, for modularizing the mapping between the surface forms of a language and representations of their underlying meanings. This approach works well when the structural discrepancies between form and meaning representations are finitely bounded, but there are some phenomena in natural language, e.g. adverbs in English, where this restriction does not hold. In this paper, we describe rule-based type-driven interpretation algorithms which cover cases of such a structural misalignment by exploiting a new descriptive device, the &amp;quot;restriction operator&amp;quot;. The algorithms are set up in such a way that recursive rules can be derived for the interpretation of adjunct sets within (see [Kaplan and Wedekind, 1993] for details).</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>J Bresnan</author>
<author>R Kaplan</author>
<author>S Peters</author>
<author>A Zaenen</author>
</authors>
<title>Cross-serial Dependencies in Dutch.</title>
<date>1982</date>
<journal>Linguistic Inquiry</journal>
<volume>13</volume>
<pages>613--635</pages>
<marker>[Bresnan et at., 1982]</marker>
<rawString>Bresnan, J., R. Kaplan, S. Peters, and A. Zaenen. Cross-serial Dependencies in Dutch. Linguistic Inquiry 13, 613-635, 1982.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Dalrymple</author>
<author>J Maxwell</author>
<author>A Zaenen</author>
</authors>
<title>Modeling Syntactic Constraints on Anaphoric Binding.</title>
<date>1990</date>
<booktitle>In Proceedings of the 13th International Conference on Computational Linguistics.</booktitle>
<location>Helsinki,</location>
<marker>[Dalrymple et al., 1990]</marker>
<rawString>Dalrymple, M., J. Maxwell, and A. Zaenen. Modeling Syntactic Constraints on Anaphoric Binding. In Proceedings of the 13th International Conference on Computational Linguistics. Helsinki, 1990.</rawString>
</citation>
<citation valid="true">
<authors>
<author>P-K Halvorsen</author>
</authors>
<title>Situation Semantics and Semantic Interpretation in Constraintbased Grammars.</title>
<date>1987</date>
<tech>CSLI Report No. 87-101.</tech>
<institution>Stanford University,</institution>
<marker>[Halvorsen, 1987]</marker>
<rawString>Halvorsen, P.-K. Situation Semantics and Semantic Interpretation in Constraintbased Grammars. CSLI Report No. 87-101. Stanford University, 1987. ings of the grammatical functions. (If we would e.g. use )tx(OBY(love1(x))) as the a-value for &apos;love&apos;, we would always get wide scope of the subject.)</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Kaplan</author>
</authors>
<title>Three Seductions of Computational Psycholinguistics.</title>
<date>1987</date>
<booktitle>Linguistic Theory and Computer Applications.</booktitle>
<editor>In P. Whitelock et al., eds.,</editor>
<publisher>Academic Press,</publisher>
<location>London:</location>
<marker>[Kaplan, 1987]</marker>
<rawString>Kaplan, R. Three Seductions of Computational Psycholinguistics. In P. Whitelock et al., eds., Linguistic Theory and Computer Applications. London: Academic Press, 1987.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Kaplan</author>
<author>J Bresnan</author>
</authors>
<title>Lexical-Functional Grammar: A Formal System for Grammatical Representation. In</title>
<date>1982</date>
<booktitle>The Mental Representation of Grammatical Relations.</booktitle>
<editor>J. Bresnan, ed.,</editor>
<publisher>The MIT Press,</publisher>
<location>Cambridge, Mass.:</location>
<marker>[Kaplan and Bresnan, 1982]</marker>
<rawString>Kaplan, R., and J. Bresnan. Lexical-Functional Grammar: A Formal System for Grammatical Representation. In J. Bresnan, ed., The Mental Representation of Grammatical Relations. Cambridge, Mass.: The MIT Press, 1982.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Kaplan</author>
<author>K Netter</author>
<author>J Wedekind</author>
<author>A Zaenen</author>
</authors>
<title>Translation by Structural Correspondences.</title>
<date>1989</date>
<booktitle>In Proceedings of the 4th Conference of the European Chapter of the Association for Computational Linguistics.</booktitle>
<location>Manchester,</location>
<marker>[Kaplan et al., 1989]</marker>
<rawString>Kaplan, R., K. Netter, J. Wedekind, and A. Zaenen. Translation by Structural Correspondences. In Proceedings of the 4th Conference of the European Chapter of the Association for Computational Linguistics. Manchester, 1989.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Kaplan</author>
<author>J Wedekind</author>
</authors>
<title>Restriction and Correspondence-based Translation.</title>
<date>1993</date>
<booktitle>In Proceedings of the 6th Conference of the European Chapter of the Association for Computational Linguistics.</booktitle>
<location>Utrecht,</location>
<marker>[Kaplan and Wedekind, 1993]</marker>
<rawString>Kaplan, R., and J. Wedekind. Restriction and Correspondence-based Translation. In Proceedings of the 6th Conference of the European Chapter of the Association for Computational Linguistics. Utrecht, 1993.</rawString>
</citation>
<citation valid="true">
<authors>
<author>L Sadler</author>
<author>H Thompson</author>
</authors>
<title>Structural Non-Correspondence in Translation.</title>
<date>1991</date>
<booktitle>In Proceedings of the 5th Conference of the European Chapter of the Association for Computational Linguistics.</booktitle>
<location>Berlin,</location>
<marker>[Sadler and Thompson, 1991]</marker>
<rawString>Sadler, L., and H. Thompson. Structural Non-Correspondence in Translation. In Proceedings of the 5th Conference of the European Chapter of the Association for Computational Linguistics. Berlin, 1991.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Wedekind</author>
</authors>
<title>Transfer by Projection. Ms.,</title>
<date>1988</date>
<institution>University of Stuttgart,</institution>
<marker>[Wedekind, 1988]</marker>
<rawString>Wedekind, J. Transfer by Projection. Ms., University of Stuttgart, 1988.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>