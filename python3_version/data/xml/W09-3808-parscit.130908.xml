<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.004787">
<title confidence="0.993732">
An Incremental Earley Parser for Simple Range Concatenation Grammar
</title>
<author confidence="0.992524">
Laura Kallmeyer and Wolfgang Maier
</author>
<affiliation confidence="0.867349">
Collaborative Research Center 833
University of T¨ubingen
T¨ubingen, Germany
</affiliation>
<email confidence="0.995154">
{lk,wmaier}@sfs.uni-tuebingen.de
</email>
<sectionHeader confidence="0.99382" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999792444444444">
We present an Earley-style parser for
simple range concatenation grammar, a
formalism strongly equivalent to linear
context-free rewriting systems. Further-
more, we present different filters which
reduce the number of items in the pars-
ing chart. An implementation shows that
parses can be obtained in a reasonable
time.
</bodyText>
<sectionHeader confidence="0.998758" genericHeader="introduction">
1 Introduction
</sectionHeader>
<bodyText confidence="0.999637114285714">
Linear context-free rewriting systems (LCFRS)
(Vijay-Shanker et al., 1987), the equivalent mul-
tiple context-free grammars (MCFG) (Seki et al.,
1991) and simple range concatenation grammars
(sRCG) (Boullier, 1998) have recently attracted
an increasing interest in the context of natu-
ral language processing. For example, Maier
and Søgaard (2008) propose to extract simple
RCGs from constituency treebanks with crossing
branches while Kuhlmann and Satta (2009) pro-
pose to extract LCFRS from non-projective depen-
dency treebanks. Another application area of this
class of formalisms is biological computing (Kato
et al., 2006).
This paper addresses the symbolic parsing of
sRCG/LCFRS. Starting from the parsing algo-
rithms presented in Burden and Ljungl¨of (2005)
and Villemonte de la Clergerie (2002), we pro-
pose an incremental Earley algorithm for simple
RCG. The strategy is roughly like the one pur-
sued in Villemonte de la Clergerie (2002). How-
ever, instead of the automaton-based formalization
in Villemonte de la Clergerie’s work, we give a
general formulation of an incremental Earley al-
gorithm, using the framework of parsing as de-
duction. In order to reduce the search space, we
introduce different types of filters on our items.
We have implemented this algorithm and tested it
on simple RCGs extracted from the German tree-
banks Negra and Tiger.
In the following section, we introduce simple
RCG and in section 3, we present an algorithm for
symbolic parsing of simple RCG. Section 4 then
presents different filtering techniques to reduce the
number of items. We close discussing future work.
</bodyText>
<sectionHeader confidence="0.980884" genericHeader="method">
2 Grammar Formalism
</sectionHeader>
<bodyText confidence="0.826534096774194">
A range concatenation grammar (RCG) is a 5-
tuple G = (N, T, V, P, S). N is a finite set of non-
terminals (predicate names) with an arity function
dim: N —* N+, T and V are disjoint finite sets of
terminals and variables. P is a finite set of clauses
of the form ψ0 —* ψ1 ... ψm, where m &gt; 0 and
each of the ψi, 0 &lt; i &lt; m, is a predicate of the
form Ai(αi1, ... , αidim(A)). Each αij E (T U V )∗,
1 &lt; j &lt; dim(A) and 0 &lt; i &lt; k, is an argument.
As a shorthand notation for Ai(α1, ... , αdim(A)),
we use Ai(~α). S E N is the start predicate name
with dim(S) = 1.
Note that the order of right-hand side (RHS)
predicates in a clause is of no importance. Sub-
classes of RCGs are introduced for further ref-
erence: An RCG G = (N, T, V, P, S) is sim-
ple if for all c E P, it holds that every variable
X occurring in c occurs exactly once in the left-
hand side (LHS) and exactly once in the RHS, and
each argument in the RHS of c contains exactly
one variable. A simple RCG is ordered if for all
ψ0 —* ψ1 · · · ψm E P, it holds that if a variable X1
precedes a variable X2 in a ψi, 1 &lt; i &lt; m, then
X1 also precedes X2 in ψ0. The ordering require-
ment does not change the expressive power, i.e.,
ordered simple RCG is equivalent to simple RCG
(Villemonte de la Clergerie, 2002). An RCG is
ε-free if it either contains no ε-rules or there is ex-
actly one rule S(ε) —* ε and S does not appear in
any of the righthand sides of the rules in the gram-
mar. A rule is an ε-rule if one of the arguments
</bodyText>
<page confidence="0.987118">
61
</page>
<bodyText confidence="0.990981339622642">
Proceedings of the 11th International Conference on Parsing Technologies (IWPT), pages 61–64,
Paris, October 2009. c�2009 Association for Computational Linguistics
of the lefthand side is the empty string ε. (Boul-
lier, 1998) shows that for every simple RCG, one
can construct an equivalent ε-free simple RCG. An
RCG G = (N, T, V, P, 5) is a k-RCG if for all
A ∈ N, dim(A) ≤ k.
The language of RCGs is based on the notion
of range. For a string w1 · · · wn a range is a pair
of indices hi, ji with 0 ≤ i ≤ j ≤ n, i.e., a
string span, which denotes a substring wi+1 · · · wj
in the source string or a substring vi+1 · · · vj in
the target string. Only consecutive ranges can be
concatenated into new ranges. Terminals, vari-
ables and arguments in a clause are bound to
ranges by a substitution mechanism. An instan-
tiated clause is a clause in which variables and ar-
guments are consistently replaced by ranges; its
components are instantiated predicates. For ex-
ample A(hg ··· hi) → B(hg + 1··· hi) is an in-
stantiation of the clause A(aX1) → B(X1) if
the target string is such that wg+1 = a. A de-
rive relation ⇒ is defined on strings of instanti-
ated predicates. If an instantiated predicate is the
LHS of some instantiated clause, it can be replaced
by the RHS of that instantiated clause. The lan-
guage of an RCG G = (N, T, V, P, 5) is the set
L(G) = {w1 · · · wn  |5(h0, ni) ⇒∗ ε}, i.e., an in-
put string w1 · · · wn is recognized if and only if the
empty string can be derived from 5(h0, ni). In this
paper, we are dealing only with ordered simple
RCGs. The ordering requirement does not change
the expressive power (Villemonte de la Clergerie,
2002). Furthermore, without loss of generality, we
assume that for every clause, there is a k ≥ 0 such
that the variables occurring in the clause are ex-
actly X1, ... , Xk.
We define derivation trees for simple RCGs as
unordered trees whose internal nodes are labelled
with predicate names and whose leaves are la-
belled with ranges such that all internal nodes
are licensed by RCG clause instantiations: given
a simple RCG G and a string w, a tree D =
hV, E, ri is a derivation tree of w = a1 ... an
iff 1. there are exactly n leaves in D labelled
h0, 1i, ... , hn − 1, ni and 2. for all v0 ∈ V with
v1, ... , vn ∈ V , n ≥ 1 being all vertices with
hv0, vii ∈ E (1 ≤ i ≤ n) such that the leftmost
range dominated by vi precedes the leftmost range
dominated by vi+1 (1 ≤ i &lt; n): there is a clause
instantiation A0(po) → A1(�ρ1) . . . An( pn) such
that a) l(vi) = Ai for 0 ≤ i ≤ n and b) the yield
of the leaves dominates by vi is pz.
</bodyText>
<sectionHeader confidence="0.982871" genericHeader="method">
3 Parsing
</sectionHeader>
<bodyText confidence="0.9999194">
Our parsing algorithm is a modification of the
“incremental algorithm” of Burden and Ljungl¨of
(2005) with a strategy very similar to the strategy
adopted by Thread Automata (Villemonte de la
Clergerie, 2002). It assumes the grammar to be
ordered and ε-free. We refrain from supporting
non-ε-free grammars since the treebank grammars
used with our implementation are all ε-free. How-
ever, note that only minor modifications would be
necessary in order to support non-ε-free grammars
(see below).
We process the arguments of LHS of clauses in-
crementally, starting from an 5-clause. Whenever
we reach a variable, we move into the clause of
the corresponding RHS predicate (predict or re-
sume). Whenever we reach the end of an argu-
ment, we suspend this clause and move into the
parent clause that has called the current one. In
addition, we treat the case where we reach the end
of the last argument and move into the parent as a
special case. Here, we first convert the item into
a passive one and then complete the parent item
with this passive item. This allows for some addi-
tional factorization.
The item form for passive items is [A, pl where
A a predicate of some arity k, ρ�is a range vector of
arity k. The item form for active items: [A(�φ) →
A1( �φ1) . . . Am( �φm), pos, hi, ji, P� where A(�φ) →
A1( �φ1) . . . Am(�φm) ∈ P; pos ∈ {0,. . . , n} is the
position up to which we have processed the input;
hi, ji ∈ N2 marks the position of our dot in the
arguments of the predicate A: hi, ji indicates that
we have processed the arguments up to the jth ele-
ment of the ith argument; ρ� is an range vector con-
taining the bindings of the variables and terminals
occurring in the lefthand side of the clause (�ρ(i)
is the range the ith element is bound to). When
first predicting a clause, it is initialized with a vec-
tor containing only symbols “?” for “unknown”.
We call such a vector (of appropriate arity) Anit.
We introduce an additional piece of notation. We
write p(X) for the range bound to the variable X
in p. Furthermore, we write p(hi, ji) for the range
bound to the jth element in the ith argument of the
clause lefthand side.
Applying a range vector ρ� containing variable
bindings for a given clause c to the argument vec-
tor of the lefthand side of c means mapping the ith
element in the arguments to -ρ(i) and concatenat-
ing adjacent ranges. The result is defined iff every
</bodyText>
<page confidence="0.996237">
62
</page>
<bodyText confidence="0.978867545454546">
argument is thereby mapped to a range.
We start by predicting the S-predicate:
~Φ, 0,h1, 0i, ~ρinit] S(~φ) → Φ~ ∈ P
Scan: Whenever the next symbol after the dot
is the next terminal in the input, we can scan it:
~ξ(m)). ρ~is ~ρA updated with ~ρA( ~ξ(|~ρB|)) =
(pos, pos′).
Resume: Whenever we are left of a variable
that is not the first argument of one of the RHS
predicates, we resume the clause of the RHS pred-
icate.
</bodyText>
<equation confidence="0.999542777777778">
[S( ~φ) →
~ρA(
~φ) →~Φ,pos, hi,ji, ~ρ]
~Φ, pos + 1, hi, j + 1i, ~ρ′]
~φ(i, j+1) = wpos+1
[A(~φ) → ... B(~ξ) ..., pos, hi, ji, ~ρA],
[B( ~ψ) → ~Ψ, pos′, hk − 1, li, ~ρB]
[A(
[A( ~φ) →
</equation>
<bodyText confidence="0.993354636363636">
where ~ρ′ is ρ~ updated with ~ρ(i, j + 1) =
(pos, pos + 1).
In order to support ε-free grammars, one would
need to store the pair of indices a ε is mapped to
in the range vector, along with the mappings of
terminals and variables. The indices could be ob-
tained through a Scan-ε operation, parallel to the
Scan operation.
Predict: Whenever our dot is left of a variable
that is the first argument of some RHS predicate
B, we predict new B-clauses:
</bodyText>
<equation confidence="0.9881025">
~φ) → ... B(X, ... ) ..., pos, hi, ji, ~ρA]
[B( ~ψ) →~Ψ,pos, h1, 0i, ~ρinit]
</equation>
<bodyText confidence="0.978184833333333">
with the side condition ~φ(i, j + 1) = X, B( ~ψ) �
ΨE P.
Suspend: Whenever we arrive at the end of an
argument that is not the last argument, we suspend
the processing of this clause and we go back to the
item that was used to predict it.
</bodyText>
<equation confidence="0.997064333333333">
[B( ~ψ) → ~Ψ, pos′, hi, ji, ~ρB],
[A( ~φ) → ... B(~ξ) ..., pos, hk, li, ~ρA]
[A(~φ) → ... B(~ξ) ... ,pos′, hk, l + 1i, ~ρ]
</equation>
<bodyText confidence="0.9989472">
where the dot in the antecedent A-item precedes
the variable ~ξ(i),  |~ψ(i) |= j (the ith argument has
Convert: Whenever we arrive at the end of the
last argument, we convert the item into a passive
one:
</bodyText>
<equation confidence="0.994067">
[B( ~ψ) → ~Ψ, pos, hi, ji, ~ρB] |~ψ(i) |= j, |~ψ |= i,
[B, ρ] ~ρB( ~ψ) = ρ
</equation>
<bodyText confidence="0.9980345">
Complete: Whenever we have a passive B item
we can use it to move the dot over the variable of
the last argument of B in a parent A-clause that
was used to predict it.
</bodyText>
<equation confidence="0.6981445">
[B, ~ρB], [A( ~φ) → ... B(~ξ) ... , pos, hk, li, ~ρA]
[A(~φ) → ... B(~ξ) ... ,pos′, hk, l + 1i, ~ρ]
</equation>
<bodyText confidence="0.963227384615385">
where the dot in the antecedent A-item precedes
the variable ~ξ(|~ρB|), the last range in ~ρB is
(pos, pos′), and for all 1 &lt; m &lt; |~ρB|: ~ρB(m) =
~ψ) → ~Ψ, pos, hk, 0i, ~ρB]
where ~φ(i)(j + 1) = ~ξ(k), k &gt; 1 (the next el-
ement is a variable that is the kth element in ~ξ,
i.e., the kth argument of B), |~ψ(k − 1) |= l, and
~ψ)(m) for all 1 &lt; m &lt; k − 1.
The goal item has the form [S, (0, n)].
Note that, in contrast to a purely bottom-up
CYK algorithm, the Earley algorithm presented
here is prefix valid, provided that the grammar
does not contain useless symbols.
</bodyText>
<sectionHeader confidence="0.997437" genericHeader="method">
4 Filters
</sectionHeader>
<bodyText confidence="0.999976291666666">
During parsing, various optimizations known from
(P)CFG parsing can be applied. More concretely,
because of the particular form of our simple
RCGs, we can use several filters to reject items
very early that cannot lead to a valid parse tree for
a given input w = w1 ... wn.
Since our grammars are ε-free, we know that
each variable or occurrence of a terminal in the
clause must cover at least one terminal in the in-
put. Furthermore, since separations between ar-
guments are generated only in cases where be-
tween two terminals belonging to the yield of a
non-terminal, there is at least one other terminals
that is not part of the yield, we know that between
different arguments of a predicate, there must be at
least one terminal in the input. Consequently, we
obtain as a filtering condition on the validity of an
active item that the length of the remaining input
must be greater or equal to the number of variables
and terminal occurrences plus the number of argu-
ment separations to the right of the dot in the left-
hand side of the clause. More formally, an active
item [A(~φ) — A1(~φ1) ... Am(~φm),pos, (i,j), ~ρ]
satisfies the length filter iff
</bodyText>
<equation confidence="0.964062333333333">
(n − pos)
� (|~φ(i) |− j) + Σdim(A)
k=i+1 |~φ(k) |+ (dim(A) − i)
</equation>
<bodyText confidence="0.99978625">
The length filter is applied to results of predict,
resume, suspend and complete.
A second filter, first proposed in Klein and
Manning (2003), checks for the presence of re-
quired preterminals. In our case, we assume the
length j and has therefore been completely pro-
cessed), |~ψ |&lt; i (the ith argument is not the last
argument of B), ~ρB(~ψ(i)) = (pos, pos′) and for
</bodyText>
<equation confidence="0.993756222222222">
all 1 &lt; m &lt; i: ~ρ pA
( ( )) (~ξ(m)). ρ~is ~ρA
updated with ~ρA(
~ =
�(i)) = (pos, pos′).
[A(
[B(
~ρA(
~ξ(m)) = ~ρB(
</equation>
<page confidence="0.992288">
63
</page>
<bodyText confidence="0.932908153846154">
preterminals to be treated as terminals, so this fil-
ter amounts to checking for the presence of all
terminals in the predicted part of a clause (the
part to the right of the dot) in the remaining in-
put. Furthermore, we check that the terminals
appear in the predicted order and that the dis-
tance between two of them is at least the num-
ber of variables/terminals and argument separa-
tions in between. In other words, an active item
[A(0) → A1( �01) ... Am( �0m), pos, hi, ji, pl satis-
fies the terminal filter iff we can find an injec-
tive mapping fT : Term = {hk, li  |0(k)(l) ∈ T
and either k &gt; i or (k = i and l &gt; j)} →
</bodyText>
<equation confidence="0.581377222222222">
{pos + 1, ... , n} such that
1. wf, ((k,l)) = �0(k)(l) for all hk, li ∈ Term;
2. for all hk1, l1i, hk2,l2i ∈ Term with k1 = k2
and l1 &lt; l2: fT(hk2,l2i) ≥ fT(hk1,l1i) +
(l2 − l1);
3. for all hk1, l1i, hk2,l2i ∈ Term with k1 &lt;
k2: fT(hk2, l2i) ≥ fT(hk1,l1i) + (|�0(k1) |−
l1) + Σk2−1
k=k1+1|�0(k) |+ l2 + (k2 − k1).
</equation>
<bodyText confidence="0.999934208333333">
Checking this filter amounts to a linear traversal
of the part of the lefthand side of the clause that
is to the right of the dot. We start with index i =
pos + 1, for every variable or gap we increment
i by 1. For every terminal a, we search the next
a in the input, starting at position i. If it occurs
at position j, then we set i = j and continue our
traversal of the remaining parts of the lefthand side
of the clause.
The preterminal filter is applied to results of the
predict and resume operations.
We have implemented the incremental Earley
parser with the filtering conditions on items. In
order to test it, we have extracted simple RCGs
from the first 1000 sentences of Negra and Tiger
(with removed punctuation) using the algorithm
described in Maier and Søgaard (2008) and parsed
the sentences 1001-1100 with it. The grammars
contained 2474 clauses (Negra) and 2554 clauses
(Tiger). The following table contains the to-
tal number of sentences for different length and
resp. the number of sentences for which a parse
was found, along with the average parsing times
of those that had a parse:
</bodyText>
<table confidence="0.8273858">
Negra Tiger
parse/tot av. t. parse/tot av. t.
JwJ &lt; 20 73/84 0.40 sec. 50/79 0.32
20 &lt; 14/16 2.14 sec. 10/19 2.16
JwJ &lt; 35
</table>
<sectionHeader confidence="0.985665" genericHeader="conclusions">
5 Conclusion and Future Work
</sectionHeader>
<bodyText confidence="0.9999645">
We have presented an Earley-style algorithm for
simple range concatenation grammar, formulated
as deduction system. Furthermore, we have pre-
sented a set of filters on the chart reducing the
number of items. An implementation and a test
with grammars extracted from treebanks showed
that reasonable parsing times can be achieved.
We are currently working on a probabilistic
k-best extension of our parser which resumes
comparable work for PCFG (Huang and Chiang,
2005). Unfortunately, experiments with the Ear-
ley algorithm have shown that with grammars of a
reasonable size for data-driven parsing (&gt; 15, 000
clauses), an exhaustive parsing is no longer ef-
ficient, due to the highly ambiguous grammars.
Algorithms using only passive items seem more
promising in this context since they facilitate the
application of A∗ parsing techniques.
</bodyText>
<sectionHeader confidence="0.999085" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999587103448276">
Pierre Boullier. 1998. Proposal for a natural lan-
guage processing syntactic backbone. Rapport de
Recherche RR-3342, INRIA.
H˚akan Burden and Peter Ljungl¨of. 2005. Parsing lin-
ear context-free rewriting systems. In Proceedings
ofIWPT 2005.
Liang Huang and David Chiang. 2005. Better k-best
parsing. In Proceedings ofIWPT 2005.
Yuki Kato, Hiroyuki Seki, and Tadao Kasami. 2006.
Stochastic multiple context-free grammar for RNA
pseudoknot modeling. In Proceedings of TAG+8.
Dan Klein and Christopher D. Manning. 2003. A*
Parsing: Fast Exact Viterbi Parse Selection. In Pro-
ceedings ofHLT-NAACL.
Marco Kuhlmann and Giorgio Satta. 2009. Treebank
grammar techniques for non-projective dependency
parsing. In Proceedings of EACL.
Wolfgang Maier and Anders Søgaard. 2008. Tree-
banks and mild context-sensitivity. In Proceedings
ofFormal Grammar 2008.
Hiroyuki Seki, Takahashi Matsumura, Mamoru Fujii,
and Tadao Kasami. 1991. On multiple context-free
grammars. Theoretical Computer Science.
K. Vijay-Shanker, David Weir, and Aravind Joshi.
1987. Characterising structural descriptions used by
various formalisms. In Proceedings ofACL.
Eric Villemonte de la Clergerie. 2002. Parsing mildly
context-sensitive languages with thread automata.
In Proceedings of COLING.
</reference>
<page confidence="0.999417">
64
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.331944">
<title confidence="0.997688">An Incremental Earley Parser for Simple Range Concatenation Grammar</title>
<author confidence="0.954298">Kallmeyer</author>
<affiliation confidence="0.999037">Collaborative Research Center University of</affiliation>
<email confidence="0.360742">T¨ubingen,</email>
<abstract confidence="0.996705">We present an Earley-style parser for simple range concatenation grammar, a formalism strongly equivalent to linear context-free rewriting systems. Furthermore, we present different filters which reduce the number of items in the parsing chart. An implementation shows that parses can be obtained in a reasonable time.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Pierre Boullier</author>
</authors>
<title>Proposal for a natural language processing syntactic backbone.</title>
<date>1998</date>
<booktitle>Rapport de Recherche RR-3342, INRIA.</booktitle>
<contexts>
<context position="768" citStr="Boullier, 1998" startWordPosition="101" endWordPosition="102">ubingen T¨ubingen, Germany {lk,wmaier}@sfs.uni-tuebingen.de Abstract We present an Earley-style parser for simple range concatenation grammar, a formalism strongly equivalent to linear context-free rewriting systems. Furthermore, we present different filters which reduce the number of items in the parsing chart. An implementation shows that parses can be obtained in a reasonable time. 1 Introduction Linear context-free rewriting systems (LCFRS) (Vijay-Shanker et al., 1987), the equivalent multiple context-free grammars (MCFG) (Seki et al., 1991) and simple range concatenation grammars (sRCG) (Boullier, 1998) have recently attracted an increasing interest in the context of natural language processing. For example, Maier and Søgaard (2008) propose to extract simple RCGs from constituency treebanks with crossing branches while Kuhlmann and Satta (2009) propose to extract LCFRS from non-projective dependency treebanks. Another application area of this class of formalisms is biological computing (Kato et al., 2006). This paper addresses the symbolic parsing of sRCG/LCFRS. Starting from the parsing algorithms presented in Burden and Ljungl¨of (2005) and Villemonte de la Clergerie (2002), we propose an </context>
<context position="3878" citStr="Boullier, 1998" startWordPosition="680" endWordPosition="682">so precedes X2 in ψ0. The ordering requirement does not change the expressive power, i.e., ordered simple RCG is equivalent to simple RCG (Villemonte de la Clergerie, 2002). An RCG is ε-free if it either contains no ε-rules or there is exactly one rule S(ε) —* ε and S does not appear in any of the righthand sides of the rules in the grammar. A rule is an ε-rule if one of the arguments 61 Proceedings of the 11th International Conference on Parsing Technologies (IWPT), pages 61–64, Paris, October 2009. c�2009 Association for Computational Linguistics of the lefthand side is the empty string ε. (Boullier, 1998) shows that for every simple RCG, one can construct an equivalent ε-free simple RCG. An RCG G = (N, T, V, P, 5) is a k-RCG if for all A ∈ N, dim(A) ≤ k. The language of RCGs is based on the notion of range. For a string w1 · · · wn a range is a pair of indices hi, ji with 0 ≤ i ≤ j ≤ n, i.e., a string span, which denotes a substring wi+1 · · · wj in the source string or a substring vi+1 · · · vj in the target string. Only consecutive ranges can be concatenated into new ranges. Terminals, variables and arguments in a clause are bound to ranges by a substitution mechanism. An instantiated clause</context>
</contexts>
<marker>Boullier, 1998</marker>
<rawString>Pierre Boullier. 1998. Proposal for a natural language processing syntactic backbone. Rapport de Recherche RR-3342, INRIA.</rawString>
</citation>
<citation valid="true">
<authors>
<author>H˚akan Burden</author>
<author>Peter Ljungl¨of</author>
</authors>
<title>Parsing linear context-free rewriting systems.</title>
<date>2005</date>
<booktitle>In Proceedings ofIWPT</booktitle>
<marker>Burden, Ljungl¨of, 2005</marker>
<rawString>H˚akan Burden and Peter Ljungl¨of. 2005. Parsing linear context-free rewriting systems. In Proceedings ofIWPT 2005.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Liang Huang</author>
<author>David Chiang</author>
</authors>
<title>Better k-best parsing.</title>
<date>2005</date>
<booktitle>In Proceedings ofIWPT</booktitle>
<marker>Huang, Chiang, 2005</marker>
<rawString>Liang Huang and David Chiang. 2005. Better k-best parsing. In Proceedings ofIWPT 2005.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Yuki Kato</author>
<author>Hiroyuki Seki</author>
<author>Tadao Kasami</author>
</authors>
<title>Stochastic multiple context-free grammar for RNA pseudoknot modeling.</title>
<date>2006</date>
<booktitle>In Proceedings of TAG+8.</booktitle>
<contexts>
<context position="1178" citStr="Kato et al., 2006" startWordPosition="160" endWordPosition="163">ar context-free rewriting systems (LCFRS) (Vijay-Shanker et al., 1987), the equivalent multiple context-free grammars (MCFG) (Seki et al., 1991) and simple range concatenation grammars (sRCG) (Boullier, 1998) have recently attracted an increasing interest in the context of natural language processing. For example, Maier and Søgaard (2008) propose to extract simple RCGs from constituency treebanks with crossing branches while Kuhlmann and Satta (2009) propose to extract LCFRS from non-projective dependency treebanks. Another application area of this class of formalisms is biological computing (Kato et al., 2006). This paper addresses the symbolic parsing of sRCG/LCFRS. Starting from the parsing algorithms presented in Burden and Ljungl¨of (2005) and Villemonte de la Clergerie (2002), we propose an incremental Earley algorithm for simple RCG. The strategy is roughly like the one pursued in Villemonte de la Clergerie (2002). However, instead of the automaton-based formalization in Villemonte de la Clergerie’s work, we give a general formulation of an incremental Earley algorithm, using the framework of parsing as deduction. In order to reduce the search space, we introduce different types of filters on</context>
</contexts>
<marker>Kato, Seki, Kasami, 2006</marker>
<rawString>Yuki Kato, Hiroyuki Seki, and Tadao Kasami. 2006. Stochastic multiple context-free grammar for RNA pseudoknot modeling. In Proceedings of TAG+8.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Dan Klein</author>
<author>Christopher D Manning</author>
</authors>
<title>A* Parsing: Fast Exact Viterbi Parse Selection.</title>
<date>2003</date>
<booktitle>In Proceedings ofHLT-NAACL.</booktitle>
<contexts>
<context position="12591" citStr="Klein and Manning (2003)" startWordPosition="2397" endWordPosition="2400"> the input. Consequently, we obtain as a filtering condition on the validity of an active item that the length of the remaining input must be greater or equal to the number of variables and terminal occurrences plus the number of argument separations to the right of the dot in the lefthand side of the clause. More formally, an active item [A(~φ) — A1(~φ1) ... Am(~φm),pos, (i,j), ~ρ] satisfies the length filter iff (n − pos) � (|~φ(i) |− j) + Σdim(A) k=i+1 |~φ(k) |+ (dim(A) − i) The length filter is applied to results of predict, resume, suspend and complete. A second filter, first proposed in Klein and Manning (2003), checks for the presence of required preterminals. In our case, we assume the length j and has therefore been completely processed), |~ψ |&lt; i (the ith argument is not the last argument of B), ~ρB(~ψ(i)) = (pos, pos′) and for all 1 &lt; m &lt; i: ~ρ pA ( ( )) (~ξ(m)). ρ~is ~ρA updated with ~ρA( ~ = �(i)) = (pos, pos′). [A( [B( ~ρA( ~ξ(m)) = ~ρB( 63 preterminals to be treated as terminals, so this filter amounts to checking for the presence of all terminals in the predicted part of a clause (the part to the right of the dot) in the remaining input. Furthermore, we check that the terminals appear in t</context>
</contexts>
<marker>Klein, Manning, 2003</marker>
<rawString>Dan Klein and Christopher D. Manning. 2003. A* Parsing: Fast Exact Viterbi Parse Selection. In Proceedings ofHLT-NAACL.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Marco Kuhlmann</author>
<author>Giorgio Satta</author>
</authors>
<title>Treebank grammar techniques for non-projective dependency parsing.</title>
<date>2009</date>
<booktitle>In Proceedings of EACL.</booktitle>
<contexts>
<context position="1014" citStr="Kuhlmann and Satta (2009)" startWordPosition="135" endWordPosition="138">sent different filters which reduce the number of items in the parsing chart. An implementation shows that parses can be obtained in a reasonable time. 1 Introduction Linear context-free rewriting systems (LCFRS) (Vijay-Shanker et al., 1987), the equivalent multiple context-free grammars (MCFG) (Seki et al., 1991) and simple range concatenation grammars (sRCG) (Boullier, 1998) have recently attracted an increasing interest in the context of natural language processing. For example, Maier and Søgaard (2008) propose to extract simple RCGs from constituency treebanks with crossing branches while Kuhlmann and Satta (2009) propose to extract LCFRS from non-projective dependency treebanks. Another application area of this class of formalisms is biological computing (Kato et al., 2006). This paper addresses the symbolic parsing of sRCG/LCFRS. Starting from the parsing algorithms presented in Burden and Ljungl¨of (2005) and Villemonte de la Clergerie (2002), we propose an incremental Earley algorithm for simple RCG. The strategy is roughly like the one pursued in Villemonte de la Clergerie (2002). However, instead of the automaton-based formalization in Villemonte de la Clergerie’s work, we give a general formulat</context>
</contexts>
<marker>Kuhlmann, Satta, 2009</marker>
<rawString>Marco Kuhlmann and Giorgio Satta. 2009. Treebank grammar techniques for non-projective dependency parsing. In Proceedings of EACL.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Wolfgang Maier</author>
<author>Anders Søgaard</author>
</authors>
<title>Treebanks and mild context-sensitivity.</title>
<date>2008</date>
<booktitle>In Proceedings ofFormal Grammar</booktitle>
<contexts>
<context position="900" citStr="Maier and Søgaard (2008)" startWordPosition="119" endWordPosition="122">catenation grammar, a formalism strongly equivalent to linear context-free rewriting systems. Furthermore, we present different filters which reduce the number of items in the parsing chart. An implementation shows that parses can be obtained in a reasonable time. 1 Introduction Linear context-free rewriting systems (LCFRS) (Vijay-Shanker et al., 1987), the equivalent multiple context-free grammars (MCFG) (Seki et al., 1991) and simple range concatenation grammars (sRCG) (Boullier, 1998) have recently attracted an increasing interest in the context of natural language processing. For example, Maier and Søgaard (2008) propose to extract simple RCGs from constituency treebanks with crossing branches while Kuhlmann and Satta (2009) propose to extract LCFRS from non-projective dependency treebanks. Another application area of this class of formalisms is biological computing (Kato et al., 2006). This paper addresses the symbolic parsing of sRCG/LCFRS. Starting from the parsing algorithms presented in Burden and Ljungl¨of (2005) and Villemonte de la Clergerie (2002), we propose an incremental Earley algorithm for simple RCG. The strategy is roughly like the one pursued in Villemonte de la Clergerie (2002). Howe</context>
<context position="14649" citStr="Maier and Søgaard (2008)" startWordPosition="2811" endWordPosition="2814">s + 1, for every variable or gap we increment i by 1. For every terminal a, we search the next a in the input, starting at position i. If it occurs at position j, then we set i = j and continue our traversal of the remaining parts of the lefthand side of the clause. The preterminal filter is applied to results of the predict and resume operations. We have implemented the incremental Earley parser with the filtering conditions on items. In order to test it, we have extracted simple RCGs from the first 1000 sentences of Negra and Tiger (with removed punctuation) using the algorithm described in Maier and Søgaard (2008) and parsed the sentences 1001-1100 with it. The grammars contained 2474 clauses (Negra) and 2554 clauses (Tiger). The following table contains the total number of sentences for different length and resp. the number of sentences for which a parse was found, along with the average parsing times of those that had a parse: Negra Tiger parse/tot av. t. parse/tot av. t. JwJ &lt; 20 73/84 0.40 sec. 50/79 0.32 20 &lt; 14/16 2.14 sec. 10/19 2.16 JwJ &lt; 35 5 Conclusion and Future Work We have presented an Earley-style algorithm for simple range concatenation grammar, formulated as deduction system. Furthermor</context>
</contexts>
<marker>Maier, Søgaard, 2008</marker>
<rawString>Wolfgang Maier and Anders Søgaard. 2008. Treebanks and mild context-sensitivity. In Proceedings ofFormal Grammar 2008.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Hiroyuki Seki</author>
<author>Takahashi Matsumura</author>
<author>Mamoru Fujii</author>
<author>Tadao Kasami</author>
</authors>
<title>On multiple context-free grammars. Theoretical Computer Science.</title>
<date>1991</date>
<contexts>
<context position="704" citStr="Seki et al., 1991" startWordPosition="91" endWordPosition="94">d Wolfgang Maier Collaborative Research Center 833 University of T¨ubingen T¨ubingen, Germany {lk,wmaier}@sfs.uni-tuebingen.de Abstract We present an Earley-style parser for simple range concatenation grammar, a formalism strongly equivalent to linear context-free rewriting systems. Furthermore, we present different filters which reduce the number of items in the parsing chart. An implementation shows that parses can be obtained in a reasonable time. 1 Introduction Linear context-free rewriting systems (LCFRS) (Vijay-Shanker et al., 1987), the equivalent multiple context-free grammars (MCFG) (Seki et al., 1991) and simple range concatenation grammars (sRCG) (Boullier, 1998) have recently attracted an increasing interest in the context of natural language processing. For example, Maier and Søgaard (2008) propose to extract simple RCGs from constituency treebanks with crossing branches while Kuhlmann and Satta (2009) propose to extract LCFRS from non-projective dependency treebanks. Another application area of this class of formalisms is biological computing (Kato et al., 2006). This paper addresses the symbolic parsing of sRCG/LCFRS. Starting from the parsing algorithms presented in Burden and Ljungl</context>
</contexts>
<marker>Seki, Matsumura, Fujii, Kasami, 1991</marker>
<rawString>Hiroyuki Seki, Takahashi Matsumura, Mamoru Fujii, and Tadao Kasami. 1991. On multiple context-free grammars. Theoretical Computer Science.</rawString>
</citation>
<citation valid="true">
<authors>
<author>K Vijay-Shanker</author>
<author>David Weir</author>
<author>Aravind Joshi</author>
</authors>
<title>Characterising structural descriptions used by various formalisms.</title>
<date>1987</date>
<booktitle>In Proceedings ofACL.</booktitle>
<contexts>
<context position="630" citStr="Vijay-Shanker et al., 1987" startWordPosition="80" endWordPosition="83">Incremental Earley Parser for Simple Range Concatenation Grammar Laura Kallmeyer and Wolfgang Maier Collaborative Research Center 833 University of T¨ubingen T¨ubingen, Germany {lk,wmaier}@sfs.uni-tuebingen.de Abstract We present an Earley-style parser for simple range concatenation grammar, a formalism strongly equivalent to linear context-free rewriting systems. Furthermore, we present different filters which reduce the number of items in the parsing chart. An implementation shows that parses can be obtained in a reasonable time. 1 Introduction Linear context-free rewriting systems (LCFRS) (Vijay-Shanker et al., 1987), the equivalent multiple context-free grammars (MCFG) (Seki et al., 1991) and simple range concatenation grammars (sRCG) (Boullier, 1998) have recently attracted an increasing interest in the context of natural language processing. For example, Maier and Søgaard (2008) propose to extract simple RCGs from constituency treebanks with crossing branches while Kuhlmann and Satta (2009) propose to extract LCFRS from non-projective dependency treebanks. Another application area of this class of formalisms is biological computing (Kato et al., 2006). This paper addresses the symbolic parsing of sRCG/</context>
</contexts>
<marker>Vijay-Shanker, Weir, Joshi, 1987</marker>
<rawString>K. Vijay-Shanker, David Weir, and Aravind Joshi. 1987. Characterising structural descriptions used by various formalisms. In Proceedings ofACL.</rawString>
</citation>
<citation valid="true">
<title>Eric Villemonte de la Clergerie.</title>
<date>2002</date>
<booktitle>In Proceedings of COLING.</booktitle>
<contexts>
<context position="1352" citStr="(2002)" startWordPosition="189" endWordPosition="189">sRCG) (Boullier, 1998) have recently attracted an increasing interest in the context of natural language processing. For example, Maier and Søgaard (2008) propose to extract simple RCGs from constituency treebanks with crossing branches while Kuhlmann and Satta (2009) propose to extract LCFRS from non-projective dependency treebanks. Another application area of this class of formalisms is biological computing (Kato et al., 2006). This paper addresses the symbolic parsing of sRCG/LCFRS. Starting from the parsing algorithms presented in Burden and Ljungl¨of (2005) and Villemonte de la Clergerie (2002), we propose an incremental Earley algorithm for simple RCG. The strategy is roughly like the one pursued in Villemonte de la Clergerie (2002). However, instead of the automaton-based formalization in Villemonte de la Clergerie’s work, we give a general formulation of an incremental Earley algorithm, using the framework of parsing as deduction. In order to reduce the search space, we introduce different types of filters on our items. We have implemented this algorithm and tested it on simple RCGs extracted from the German treebanks Negra and Tiger. In the following section, we introduce simple</context>
</contexts>
<marker>2002</marker>
<rawString>Eric Villemonte de la Clergerie. 2002. Parsing mildly context-sensitive languages with thread automata. In Proceedings of COLING.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>