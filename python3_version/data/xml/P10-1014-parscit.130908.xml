<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000005">
<title confidence="0.947419">
SystemT: An Algebraic Approach to Declarative Information Extraction
</title>
<author confidence="0.7732235">
Laura Chiticariu Rajasekar Krishnamurthy Yunyao Li
Sriram Raghavan Frederick R. Reiss Shivakumar Vaithyanathan
</author>
<affiliation confidence="0.736135">
IBM Research – Almaden
</affiliation>
<address confidence="0.631532">
San Jose, CA, USA
</address>
<email confidence="0.996898">
{chiti,sekar,yunyaoli,rsriram,frreiss,vaithyan}@us.ibm.com
</email>
<sectionHeader confidence="0.997369" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999926368421053">
As information extraction (IE) becomes
more central to enterprise applications,
rule-based IE engines have become in-
creasingly important. In this paper, we
describe SystemT, a rule-based IE sys-
tem whose basic design removes the ex-
pressivity and performance limitations of
current systems based on cascading gram-
mars. SystemT uses a declarative rule
language, AQL, and an optimizer that
generates high-performance algebraic ex-
ecution plans for AQL rules. We com-
pare SystemT’s approach against cascad-
ing grammars, both theoretically and with
a thorough experimental evaluation. Our
results show that SystemT can deliver re-
sult quality comparable to the state-of-the-
art and an order of magnitude higher an-
notation throughput.
</bodyText>
<sectionHeader confidence="0.999517" genericHeader="introduction">
1 Introduction
</sectionHeader>
<bodyText confidence="0.999955542372882">
In recent years, enterprises have seen the emer-
gence of important text analytics applications like
compliance and data redaction. This increase,
combined with the inclusion of text into traditional
applications like Business Intelligence, has dra-
matically increased the use of information extrac-
tion (IE) within the enterprise. While the tradi-
tional requirement of extraction quality remains
critical, enterprise applications also demand ef-
ficiency, transparency, customizability and main-
tainability. In recent years, these systemic require-
ments have led to renewed interest in rule-based
IE systems (Doan et al., 2008; SAP, 2010; IBM,
2010; SAS, 2010).
Until recently, rule-based IE systems (Cunning-
ham et al., 2000; Boguraev, 2003; Drozdzynski
et al., 2004) were predominantly based on the
cascading grammar formalism exemplified by the
Common Pattern Specification Language (CPSL)
specification (Appelt and Onyshkevych, 1998). In
CPSL, the input text is viewed as a sequence of an-
notations, and extraction rules are written as pat-
tern/action rules over the lexical features of these
annotations. In a single phase of the grammar, a
set of rules are evaluated in a left-to-right fash-
ion over the input annotations. Multiple grammar
phases are cascaded together, with the evaluation
proceeding in a bottom-up fashion.
As demonstrated by prior work (Grishman and
Sundheim, 1996), grammar-based IE systems can
be effective in many scenarios. However, these
systems suffer from two severe drawbacks. First,
the expressivity of CPSL falls short when used
for complex IE tasks over increasingly pervasive
informal text (emails, blogs, discussion forums
etc.). To address this limitation, grammar-based
IE systems resort to significant amounts of user-
defined code in the rules, combined with pre-
and post-processing stages beyond the scope of
CPSL (Cunningham et al., 2010). Second, the
rigid evaluation order imposed in these systems
has significant performance implications.
Three decades ago, the database community
faced similar expressivity and efficiency chal-
lenges in accessing structured information. The
community addressed these problems by introduc-
ing a relational algebra formalism and an associ-
ated declarative query language SQL. The ground-
breaking work on System R (Chamberlin et al.,
1981) demonstrated how the expressivity of SQL
can be efficiently realized in practice by means of
a query optimizer that translates an SQL query into
an optimized query execution plan.
Borrowing ideas from the database community,
we have developed SystemT, a declarative IE sys-
tem based on an algebraic framework, to address
both expressivity and performance issues. In Sys-
temT, extraction rules are expressed in a declar-
ative language called AQL. At compilation time,
</bodyText>
<page confidence="0.961494">
128
</page>
<note confidence="0.971902">
Proceedings of the 48th Annual Meeting of the Association for Computational Linguistics, pages 128–137,
Uppsala, Sweden, 11-16 July 2010. c�2010 Association for Computational Linguistics
</note>
<figure confidence="0.98935695652174">
Document d1
... Tomorrow, we will meet Mark Scott, Howard Smith and ...
Gazetteers containing first names and last names
Phase Types RuleId Rule Patterns Priority
P1 Input P1R1 ({Lookup.majorType = FirstGaz}) : fn 4 :fn.First 50
Lookup
Token P1R2 ({Lookup.majorType = LastGaz}) : ln 4 :ln.Last 50
Output P1R3 ({Token.orth = upperInitial}  |10
{Token.orth = mixedCaps } ) :cw 4 :cw.Caps
First
Last
Caps
P2 Input P2R1 ({First} {Last} ) :full 4:full.Person 50
First
({Caps} {Last} ) :full 4:full.Person 20
Last P2R2
Caps P2R3 ({Last} {Token.orth = comma} {Caps  |First}) : reverse 10
Token 4:reverse.Person
Output P2R4 ({First}) : fn 4 :fn.Person 10
Person
P2R5 ({Last}) : ln 4 :ln.Person 10
Rule part Action part
P2R3 ({Last} {Token.orth = comma} {Caps  |First}) : reverse 4 :reverse.Person
Last followed by Token whose orth attribute has value
comma followed by Caps or First
Bind match
to variables
Create Person
annotation
Syntax:
CPSL
Phase P1
CPSL
Phase P2
JAPE
First(P1R1) First(P1R1) First(P1R1)
Phase P1
(Brill) Caps(P1R3) Last(P1R2) Last(P1R2)
Caps(P1R3) Caps(P1R3)
Person(P2R4)
... Mark Scott , Howard Smith ...
... Mark Scott , Howard Smith ...
First(P1R1) First(P1R1) First(P1R1) Last(P1R2)
... Mark Scott , Howard Smith ...
Last(P1R2) Last(P1R2)
Person(P2R4)
Person (P2R4)
Person(P2R1)
Last(P1R2)
Caps(P1R3)
Person (P2R5)
3 persons
identified
Rule skipped
due to priority
semantics
Legend
Rule fired
Some discarded
Person (P2R2) Person (P2R4, P2R5) matches omitted
for clarity
... Mark Scott , Howard Smith ...
Person(P2R1)
JAPE
Phase P2
(Appelt)
Person(P2R1)
2 persons
identified
</figure>
<figureCaption confidence="0.996439">
Figure 2: Sample output of CPSL and JAPE
Figure 1: Cascading grammar for identifying Person names
</figureCaption>
<bodyText confidence="0.999442409090909">
SystemT translates AQL statements into an al-
gebraic expression called an operator graph that
implements the semantics of the statements. The
SystemT optimizer then picks a fast execution
plan from many logically equivalent plans. Sys-
temT is currently deployed in a multitude of real-
world applications and commercial products1.
We formally demonstrate the superiority of
AQL and SystemT in terms of both expressivity
and efficiency (Section 4). Specifically, we show
that 1) the expressivity of AQL is a strict superset
of CPSL grammars not using external functions
and 2) the search space explored by the SystemT
optimizer includes operator graphs correspond-
ing to efficient finite state transducer implemen-
tations. Finally, we present an extensive experi-
mental evaluation that validates that high-quality
annotators can be developed with SystemT, and
that their runtime performance is an order of mag-
nitude better when compared to annotators devel-
oped with a state-of-the-art grammar-based IE sys-
tem (Section 5).
</bodyText>
<sectionHeader confidence="0.714296" genericHeader="method">
2 Grammar-based Systems and CPSL
</sectionHeader>
<bodyText confidence="0.9997222">
A cascading grammar consists of a sequence of
phases, each of which consists of one or more
rules. Each phase applies its rules from left to
right over an input sequence of annotations and
generates an output sequence of annotations that
the next phase consumes. Most cascading gram-
mar systems today adhere to the CPSL standard.
Fig. 1 shows a sample CPSL grammar that iden-
tifies person names from text in two phases. The
first phase, P1, operates over the results of the tok-
</bodyText>
<footnote confidence="0.630426">
1A trial version is available at
http://www.alphaworks.ibm.com/tech/systemt
</footnote>
<bodyText confidence="0.9940208">
enizer and gazetteer (input types Token and Lookup,
respectively) to identify words that may be part of
a person name. The second phase, P2, identifies
complete names using the results of phase P1.
Applying the above grammar to document d1
(Fig. 2), one would expect that to match “Mark
Scott” and “Howard Smith” as Person. However,
as shown in Fig. 2(a), the grammar actually finds
three Person annotations, instead of two. CPSL has
several limitations that lead to such discrepancies:
</bodyText>
<listItem confidence="0.881284821428571">
L1. Lossy sequencing. In a CPSL grammar,
each phase operates on a sequence of annotations
from left to right. If the input annotations to a
phase may overlap with each other, the CPSL en-
gine must drop some of them to create a non-
overlapping sequence. For instance, in phase P1
(Fig. 2(a)), “Scott” has both a Lookup and a To-
ken annotation. The system has made an arbitrary
choice to retain the Lookup annotation and discard
the Token annotation. Consequently, no Caps anno-
tations are output by phase P1.
L2. Rigid matching priority. CPSL specifies
that, for each input annotation, only one rule can
actually match. When multiple rules match at the
same start position, the following tie-breaker con-
ditions are applied (in order): (a) the rule match-
ing the most annotations in the input stream; (b)
the rule with highest priority; and (c) the rule de-
clared earlier in the grammar. This rigid match-
ing priority can lead to mistakes. For instance,
as illustrated in Fig. 2(a), phase P1 only identi-
fies “Scott” as a First. Matching priority causes
the grammar to skip the corresponding match for
“Scott” as a Last. Consequently, phase P2 fails to
identify “Mark Scott” as one single Person.
L3. Limited expressivity in rule patterns. It is
not possible to express rules that compare annota-
tions overlapping with each other. E.g., “Identify
</listItem>
<page confidence="0.992103">
129
</page>
<figure confidence="0.573654666666667">
of SystemT, starting with the algebraic formalism
behind SystemT’s operators.
Caps
</figure>
<figureCaption confidence="0.995935">
Figure 3: Regular Expression Extraction Operator
</figureCaption>
<bodyText confidence="0.892620666666667">
words that are both capitalized and present in the
FirstGaz gazetteer” or “Identify Person annotations
that occur within an EmailAddress”.
</bodyText>
<subsectionHeader confidence="0.536171">
Extensions to CPSL
</subsectionHeader>
<bodyText confidence="0.998510166666667">
In order to address the above limitations, several
extensions to CPSL have been proposed in JAPE,
AFst and XTDL (Cunningham et al., 2000; Bogu-
raev, 2003; Drozdzynski et al., 2004). The exten-
sions are summarized as below, where each solu-
tion Si corresponds to limitation Li.
</bodyText>
<listItem confidence="0.996437222222222">
• S1. Grammar rules are allowed to operate on
graphs of input annotations in JAPE and AFst.
• S2. JAPE introduces more matching regimes
besides the CPSL’s matching priority and thus
allows more flexibility when multiple rules
match at the same starting position.
• S3. The rule part of a pattern has been ex-
panded to allow more expressivity in JAPE,
AFst and XTDL.
</listItem>
<bodyText confidence="0.998165666666667">
Fig. 2(b) illustrates how the above extensions
help in identifying the correct matches ‘Mark Scott’
and ‘Howard Smith’ in JAPE. Phase P1 uses a match-
ing regime (denoted by Brill) that allows multiple
rules to match at the same starting position, and
phase P2 uses CPSL’s matching priority, Appelt.
</bodyText>
<sectionHeader confidence="0.996736" genericHeader="method">
3 SystemT
</sectionHeader>
<bodyText confidence="0.999696230769231">
SystemT is a declarative IE system based on an
algebraic framework. In SystemT, developers
write rules in a language called AQL. The system
then generates a graph of operators that imple-
ment the semantics of the AQL rules. This decou-
pling allows for greater rule expressivity, because
the rule language is not constrained by the need to
compile to a finite state transducer. Likewise, the
decoupled approach leads to greater flexibility in
choosing an efficient execution strategy, because
many possible operator graphs may exist for the
same AQL annotator.
In the rest of the section, we describe the parts
</bodyText>
<figure confidence="0.997229">
[A-Z]{\w|-}+
Output Tuple 1
Output Tuple 2
Input Tuple
Document
Document
Document
Regex
Span 1
Span 2
we will meet Mark
Scott, ...
...
</figure>
<subsectionHeader confidence="0.51635">
3.1 Algebraic Foundation of SystemT
</subsectionHeader>
<bodyText confidence="0.921023384615385">
SystemT executes IE rules using graphs of op-
erators. The formal definition of these operators
takes the form of an algebra that is similar to the
relational algebra, but with extensions for text pro-
cessing.
The algebra operates over a simple relational
data model with three data types: span, tuple, and
relation. In this data model, a span is a region of
text within a document identified by its “begin”
and “end” positions; a tuple is a fixed-size list of
spans. A relation is a multiset of tuples, where ev-
ery tuple in the relation must be of the same size.
Each operator in our algebra implements a single
basic atomic IE operation, producing and consum-
ing sets of tuples.
Fig. 3 illustrates the regular expression ex-
traction operator in the algebra, which per-
forms character-level regular expression match-
ing. Overall, the algebra contains 12 different op-
erators, a full description of which can be found
in (Reiss et al., 2008). The following four oper-
ators are necessary to understand the examples in
this paper:
• The Extract operator (£) performs character-
level operations such as regular expression and
dictionary matching over text, creating a tuple
for each match.
• The Select operator (Q) takes as input a set of
tuples and a predicate to apply to the tuples. It
outputs all tuples that satisfy the predicate.
• The Join operator (⊲⊳) takes as input two sets
of tuples and a predicate to apply to pairs of
tuples from the input sets. It outputs all pairs
of input tuples that satisfy the predicate.
• The consolidate operator (Q) takes as input a
set of tuples and the index of a particular col-
umn in those tuples. It removes selected over-
lapping spans from the indicated column, ac-
cording to the specified policy.
</bodyText>
<subsectionHeader confidence="0.987499">
3.2 AQL
</subsectionHeader>
<bodyText confidence="0.999864333333333">
Extraction rules in SystemT are written in AQL,
a declarative relational language similar in syn-
tax to the database language SQL. We chose SQL
as a basis for our language due to its expres-
sivity and its familiarity. The expressivity of
SQL, which consists of first-order logic predicates
</bodyText>
<page confidence="0.993979">
130
</page>
<figureCaption confidence="0.999411">
Figure 4: Person annotator as AQL query
</figureCaption>
<bodyText confidence="0.953148857142857">
over sets of tuples, is well-documented and well-
understood (Codd, 1990). As SQL is the pri-
mary interface to most relational database sys-
tems, the language’s syntax and semantics are
common knowledge among enterprise application
programmers. Similar to SQL terminology, we
call a collection of AQL rules an AQL query.
</bodyText>
<figureCaption confidence="0.903109">
Fig. 4 shows portions of an AQL query. As
can be seen, the basic building block of AQL is
a view: A logical description of a set of tuples in
terms of either the document text (denoted by a
special view called Document) or the contents of
other views. Every SystemT annotator consists
of at least one view. The output view statement in-
dicates that the tuples in a view are part of the final
results of the annotator.
Fig. 4 also illustrates three of the basic con-
structs that can be used to define a view.
</figureCaption>
<listItem confidence="0.958940555555556">
• The extract statement specifies basic
character-level extraction primitives to be
applied directly to a tuple.
• The select statement is similar to the SQL
select statement but it contains an additional
consolidate on clause, along with an exten-
sive collection of text-specific predicates.
• The union all statement merges the outputs
of one or more select or extract statements.
</listItem>
<bodyText confidence="0.933927">
To keep rules compact, AQL also provides a
shorthand sequence pattern notation similar to the
syntax of CPSL. For example, the CapsLast
view in Figure 4 could have been written as:
create view CapsLast as
extract pattern &lt;C.name&gt; &lt;L.name&gt;
from Caps C, Last L;
Internally, SystemT translates each of these ex-
tract pattern statements into one or more select
and extract statements.
</bodyText>
<figureCaption confidence="0.996738">
Figure 5: The compilation process in SystemT
Figure 6: Execution strategies for the CapsLast rule
in Fig. 4
</figureCaption>
<bodyText confidence="0.999429214285714">
SystemT has built-in multilingual support in-
cluding tokenization, part of speech and gazetteer
matching for over 20 languages using Language-
Ware (IBM, 2010). Rule developers can utilize
the multilingual support via AQL without hav-
ing to configure or manage any additional re-
sources. In addition, AQL allows user-defined
functions to be used in a restricted context in or-
der to support operations such as validation (e.g.
for extracted credit card numbers), or normaliza-
tion (e.g., compute abbreviations of multi-token
organization candidates that are useful in gener-
ating additional candidates). More details on AQL
can be found in the AQL manual (SystemT, 2010).
</bodyText>
<subsectionHeader confidence="0.982209">
3.3 Optimizer and Operator Graph
</subsectionHeader>
<bodyText confidence="0.99991805">
Grammar-based IE engines place rigid restrictions
on the order in which rules can be executed. Due
to the semantics of the CPSL standard, systems
that implement the standard must use a finite state
transducer that evaluates each level of the cascade
with one or more left to right passes over the entire
token stream.
In contrast, SystemT places no explicit con-
straints on the order of rule evaluation, nor does
it require that intermediate results of an annota-
tor collapse to a fixed-size sequence. As shown in
Fig. 5, the SystemT engine does not execute AQL
directly; instead, the SystemT optimizer compiles
AQL into a graph of operators. By tying a collec-
tion of operators together by their inputs and out-
puts, the system can implement a wide variety of
different execution strategies. Different execution
strategies are associated with different evaluation
costs. The optimizer chooses the execution strat-
egy with the lowest estimated evaluation cost.
</bodyText>
<figure confidence="0.989260375">
AQL
SystemT
Runtime
SystemT
Optimizer
Compiled
Operator
Graph
</figure>
<page confidence="0.977621">
131
</page>
<bodyText confidence="0.999492514285714">
Fig. 6 presents three possible execution strate-
gies for the CapsLast rule in Fig. 4. If the opti-
mizer estimates that the evaluation cost of Last is
much lower than that of Caps, then it can deter-
mine that Plan C has the lowest evaluation cost
among the three, because Plan C only evaluates
Caps in the “left” neighborhood for each instance
of Last. More details of our algorithms for enumer-
ating plans can be found in (Reiss et al., 2008).
The optimizer in SystemT chooses the best ex-
ecution plan from a large number of different al-
gebra graphs available to it. Many of these graphs
implement strategies that a transducer could not
express: such as evaluating rules from right to left,
sharing work across different rules, or selectively
skipping rule evaluations. Within this large search
space, there generally exists an execution strategy
that implements the rule semantics far more effi-
ciently than the fastest transducer could. We refer
the reader to (Reiss et al., 2008) for a detailed de-
scription of the types of plan the optimizer consid-
ers, as well as an experimental analysis of the per-
formance benefits of different parts of this search
space.
Several parallel efforts have been made recently
to improve the efficiency of IE tasks by optimiz-
ing low-level feature extraction (Ramakrishnan et
al., 2006; Ramakrishnan et al., 2008; Chandel et
al., 2006) or by reordering operations at a macro-
scopic level (Ipeirotis et al., 2006; Shen et al.,
2007; Jain et al., 2009). However, to the best of
our knowledge, SystemT is the only IE system
in which the optimizer generates a full end-to-end
plan, beginning with low-level extraction primi-
tives and ending with the final output tuples.
</bodyText>
<subsectionHeader confidence="0.987819">
3.4 Deployment Scenarios
</subsectionHeader>
<bodyText confidence="0.999977">
SystemT is designed to be usable in various de-
ployment scenarios. It can be used as a stand-
alone system with its own development and run-
time environment. Furthermore, SystemT ex-
poses a generic Java API that enables the integra-
tion of its runtime environment with other applica-
tions. For example, a specific instantiation of this
API allows SystemT annotators to be seamlessly
embedded in applications using the UIMA analyt-
ics framework (UIMA, 2010).
</bodyText>
<sectionHeader confidence="0.996083" genericHeader="method">
4 Grammar vs. Algebra
</sectionHeader>
<bodyText confidence="0.9945295">
Having described both the traditional cascading
grammar approach and the declarative approach
</bodyText>
<figureCaption confidence="0.998787">
Figure 7: Supporting Complex Rule Interactions
</figureCaption>
<bodyText confidence="0.936832">
used in SystemT, we now compare the two in
terms of expressivity and performance.
</bodyText>
<subsectionHeader confidence="0.86434">
4.1 Expressivity
</subsectionHeader>
<bodyText confidence="0.999977944444444">
In Section 2, we described three expressivity lim-
itations of CPSL grammars: Lossy sequencing,
rigid matching priority, and limited expressivity in
rule patterns. As we noted, cascading grammar
systems extend the CPSL specification in various
ways to provide workarounds for these limitations.
In SystemT, the basic design of the AQL lan-
guage eliminates these three problems without the
need for any special workaround. The key design
difference is that AQL views operate over sets of
tuples, not sequences of tokens. The input or out-
put tuples of a view can contain spans that overlap
in arbitrary ways, so the lossy sequencing prob-
lem never occurs. The annotator will retain these
overlapping spans across any number of views un-
til a view definition explicitly removes the over-
lap. Likewise, the tuples that a given view pro-
duces are in no way constrained by the outputs of
other, unrelated views, so the rigid matching prior-
ity problem never occurs. Finally, the select state-
ment in AQL allows arbitrary predicates over the
cross-product of its input tuple sets, eliminating
the limited expressivity in rule patterns problem.
Beyond eliminating the major limitations of
CPSL grammars, AQL provides a number of other
information extraction operations that even ex-
tended CPSL cannot express without custom code.
Complex rule interactions. Consider an exam-
ple document from the Enron corpus (Minkov et
al., 2005), shown in Fig. 7, which contains a list
of person names. Because the first person in the
list (‘Skilling’) is referred to by only a last name,
rule P2R3 in Fig. 1 incorrectly identifies ‘Skilling,
Cindy’ as a person. Consequently, the output of
phase P2 of the cascading grammar contains sev-
eral mistakes as shown in the figure. This problem
</bodyText>
<page confidence="0.983787">
132
</page>
<figure confidence="0.921659">
MusicReviewSnippet
</figure>
<figureCaption confidence="0.999861">
Figure 8: Extracting informal band reviews from web logs
</figureCaption>
<bodyText confidence="0.998783903225807">
occurs because CPSL only evaluates rules over
the input sequence in a strict left-to-right fashion.
On the other hand, the AQL query Q1 shown in
the figure applies the following condition: “Al-
ways discard matches to Rule P2R3 if they overlap
with matches to rules P2R1 or P2R2” (even if the
match to Rule P2R3 starts earlier). Applying this
rule ensures that the person names in the list are
identified correctly. Obtaining the same effect in
grammar-based systems would require the use of
custom code (as recommended by (Cunningham
et al., 2010)).
Counting and Aggregation. Complex extraction
tasks sometimes require operations such as count-
ing and aggregation that go beyond the expressiv-
ity of regular languages, and thus can be expressed
in CPSL only using external functions. One such
task is that of identifying informal concert reviews
embedded within blog entries. Fig. 8 describes, by
example, how these reviews consist of reference
to a live concert followed by several review snip-
pets, some specific to musical performances and
others that are more general review expressions.
An example rule to identify informal reviews is
also shown in the figure. Notice how implement-
ing this rule requires counting the number of Mu-
sicReviewSnippet and GenericReviewSnippet annotations
within a region of text and aggregating this occur-
rence count across the two review types. While
this rule can be written in AQL, it can only be ap-
proximated in CPSL grammars.
</bodyText>
<sectionHeader confidence="0.569163" genericHeader="method">
Character-Level Regular Expression CPSL
</sectionHeader>
<bodyText confidence="0.964767326530612">
cannot specify character-level regular expressions
that span multiple tokens. In contrast, the extract
regex statement in AQL fully supports these ex-
pressions.
We have described above several cases where
AQL can express concepts that can only be ex-
pressed through external functions in a cascad-
ing grammar. These examples naturally raise the
question of whether similar cases exist where a
cascading grammar can express patterns that can-
not be expressed in AQL.
It turns out that we can make a strong statement
that such examples do not exist. In the absence
of an escape to arbitrary procedural code, AQL is
strictly more expressive than a CPSL grammar. To
state this relationship formally, we first introduce
the following definitions.
We refer to a grammar conforming to the CPSL
specification as a CPSL grammar. When a CPSL
grammar contains no external functions, we refer
to it as a Code-free CPSL grammar. Finally, we
refer to a grammar that conforms to one of the
CPSL, JAPE, AFst and XTDL specifications as an
expanded CPSL grammar.
Ambiguous Grammar Specification An ex-
panded CPSL grammar may be under-specified in
some cases. For example, a single rule contain-
ing the disjunction operator (|) may match a given
region of text in multiple ways. Consider the eval-
uation of Rule P2R3 over the text fragment “Scott,
Howard” from document d1 (Fig. 1). If “Howard”
is identified both as Caps and First, then there are
two evaluations for Rule P2R3 over this text frag-
ment. Since the system has to arbitrarily choose
one evaluation, the results of the grammar can be
non-deterministic (as pointed out in (Cunning-
ham et al., 2010)). We refer to a grammar G as
an ambiguous grammar specification for a docu-
ment collection D if the system makes an arbitrary
choice while evaluating G over D.
Definition 1(UnambigEquiv) A query Q is Un-
ambigEquiv to a cascading grammar !9 if and only
iffor every document collection D, where G is not
an ambiguous grammar specification for D, the
results of the grammar invocation and the query
evaluation are identical.
We now formally compare the expressivity of
AQL and expanded CPSL grammars. The detailed
proof is omitted due to space limitations.
</bodyText>
<construct confidence="0.969197">
Theorem 1 The class of extraction tasks express-
ible as AQL queries is a strict superset of that ex-
pressible through expanded code-free CPSL gram-
mars. Specifically,
</construct>
<listItem confidence="0.9619728">
(a) Every expanded code-free CPSL grammar can
be expressed as an UnambigEquiv AQL query.
(b) AQL supports information extraction opera-
tions that cannot be expressed in expanded code-
free CPSL grammars.
</listItem>
<figure confidence="0.919560333333333">
Informal Band Review
ConcertMention
GenericReviewSnippet
</figure>
<bodyText confidence="0.5882465">
went to the Switchfoot concert at the Roxy. It was pretty fun,... The lead singer/guitarist
was really good, and even though there was another guitarist (an Asian guy), he ended up
playing most of the guitar parts, which was really impressive. The biggest surprise though is
that I actually liked the opening bands. ...I especially liked the first band
</bodyText>
<figure confidence="0.953501333333333">
At least 4 occurrences of MusicReviewSnippet or GenericReviewSnippet
At least 3 of them should be MusicReviewSnippets
Review ends with one of these.
Complete review is
within 200 tokens
Example Rule
Start with
ConcertMention
Consecutive review snippets are within 25 tokens
</figure>
<page confidence="0.996374">
133
</page>
<bodyText confidence="0.996500482758621">
Proof Outline: (a) A single CPSL grammar can
be expressed in AQL as follows. First, each rule
r in the grammar is translated into a set of AQL
statements. If r does not contain the disjunct (|)
operator, then it is translated into a single AQL
select statement. Otherwise, a set of AQL state-
ments are generated, one for each disjunct opera-
tor in rule r, and the results merged using union
all statements. Then, a union all statement is used
to combine the results of individual rules in the
grammar phase. Finally, the AQL statements for
multiple phases are combined in the same order as
the cascading grammar specification.
The main extensions to CPSL supported by ex-
panded CPSL grammars (listed in Sec. 2) are han-
dled as follows. AQL queries operate on graphs
on annotations just like expanded CPSL gram-
mars. In addition, AQL supports different match-
ing regimes through consolidation operators, span
predicates through selection predicates and co-
references through join operators.
(b) Example operations supported in AQL that
cannot be expressed in expanded code-free CPSL
grammars include (i) character-level regular ex-
pressions spanning multiple tokens, (ii) count-
ing the number of annotations occurring within a
given bounded window and (iii) deleting annota-
tions if they overlap with other annotations start-
ing later in the document. ❑
</bodyText>
<subsectionHeader confidence="0.981047">
4.2 Performance
</subsectionHeader>
<bodyText confidence="0.984896825">
For the annotators we test in our experiments
(See Section 5), the SystemT optimizer is able to
choose algebraic plans that are faster than a com-
parable transducer-based implementation. The
question arises as to whether there are other an-
notators for which the traditional transducer ap-
proach is superior. That is, for a given annota-
tor, might there exist a finite state transducer that
is combinatorially faster than any possible algebra
graph? It turns out that this scenario is not possi-
ble, as the theorem below shows.
Definition 2 (Token-Based FST) A token-based
finite state transducer (FST) is a nondeterministic
finite state machine in which state transitions are
triggered by predicates on tokens. A token-based
FST is acyclic if its state graph does not contain
any cycles and has exactly one “accept” state.
Definition 3 (Thompson’s Algorithm)
Thompson’s algorithm is a common strategy
for evaluating a token-based FST (based on
(Thompson, 1968)). This algorithm processes the
input tokens from left to right, keeping track of the
set of states that are currently active.
Theorem 2 For any acyclic token-based finite
state transducer T, there exists an UnambigEquiv
operator graph G, such that evaluating G has the
same computational complexity as evaluating T
with Thompson’s algorithm starting from each to-
ken position in the input document.
Proof Outline: The proof constructs G by struc-
tural induction over the transducer T. The base
case converts transitions out of the start state into
Extract operators. The inductive case adds a Se-
lect operator to G for each of the remaining state
transitions, with each selection predicate being the
same as the predicate that drives the corresponding
state transition. For each state transition predicate
that T would evaluate when processing a given
document, G performs a constant amount of work
on a single tuple. ❑
</bodyText>
<sectionHeader confidence="0.993784" genericHeader="method">
5 Experimental Evaluation
</sectionHeader>
<bodyText confidence="0.9999166">
In this section we present an extensive comparison
study between SystemT and implementations of
expanded CPSL grammar in terms of quality, run-
time performance and resource requirements.
Tasks We chose two tasks for our evaluation:
</bodyText>
<listItem confidence="0.9946034">
• NER : named-entity recognition for Person,
Organization, Location, Address, PhoneNumber,
EmailAddress, URL and DateTime.
• BandReview : identify informal reviews in
blogs (Fig. 8).
</listItem>
<bodyText confidence="0.996420142857143">
We chose NER primarily because named-entity
recognition is a well-studied problem and standard
datasets are available for evaluation. For this task
we use GATE and ANNIE for comparison3. We
chose BandReview to conduct performance evalu-
ation for a more complex extraction task.
Datasets. For quality evaluation, we use:
</bodyText>
<listItem confidence="0.997205833333333">
• EnronMeetings (Minkov et al., 2005): collec-
tion of emails with meeting information from
the Enron corpus4 with Person labeled data;
• ACE (NIST, 2005): collection of newswire re-
ports and broadcast news/conversations with
Person, Organization, Location labeled data5.
</listItem>
<footnote confidence="0.998255">
3To the best of our knowledge, ANNIE (Cunningham et
al., 2002) is the only publicly available NER library imple-
mented in a grammar-based system (JAPE in GATE).
4http://www.cs.cmu.edu/ enron/
5Only entities of type NAM have been considered.
</footnote>
<page confidence="0.997867">
134
</page>
<tableCaption confidence="0.988645">
Table 1: Datasets for performance evaluation.
</tableCaption>
<table confidence="0.998566571428571">
Dataset Description of the Content Number of Document size
documents
range average
Enron, Emails randomly sampled from the Enron corpus of average size xKB (0.5 &lt; x &lt; 100)2 1000 xKB +/ − 10% xKB
WebCrawl Small to medium size web pages representing company news, with HTML tags removed 1931 68b - 388.6KB 8.8KB
Financem Medium size financial regulatory filings 100 240KB - 0.9MB 401KB
FinanceL Large size financial regulatory filings 30 1MB - 3.4MB 1.54MB
</table>
<tableCaption confidence="0.99117">
Table 2: Quality of Person on test datasets.
</tableCaption>
<figure confidence="0.598930333333333">
F1 measure (%)
(Exact/Partial)
EnronMeetings
</figure>
<table confidence="0.996915333333333">
ANNIE 57.05/76.84 48.59/65.46 52.48/70.69
T-NE 88.41/92.99 82.39/86.65 85.29/89.71
Minkov 81.1/NA 74.9/NA 77.9/NA
ACE
ANNIE 39.41/78.15 30.39/60.27 34.32/68.06
T-NE 93.90/95.82 90.90/92.76 92.38/94.27
</table>
<bodyText confidence="0.946724076923077">
Table 1 lists the datasets used for performance
evaluation. The size of FinanceLis purposely
small because GATE takes a significant amount of
time processing large documents (see Sec. 5.2).
Set Up. The experiments were run on a server
with two 2.4 GHz 4-core Intel Xeon CPUs and
64GB of memory. We use GATE 5.1 (build 3431)
and two configurations for ANNIE: 1) the default
configuration, and 2) an optimized configuration
where the Ontotext Japec Transducer6 replaces the
default NE transducer for optimized performance.
We refer to these configurations as ANNIE and
ANNIE-Optimized, respectively.
</bodyText>
<subsectionHeader confidence="0.999635">
5.1 Quality Evaluation
</subsectionHeader>
<bodyText confidence="0.999825611111111">
The goal of our quality evaluation is two-fold:
to validate that annotators can be built in Sys-
temT with quality comparable to those built in
a grammar-based system; and to ensure a fair
performance comparison between SystemT and
GATE by verifying that the annotators used in the
study are comparable.
Table 2 shows results of our comparison study
for Person annotators. We report the classical
(exact) precision, recall, and F1 measures that
credit only exact matches, and corresponding par-
tial measures that credit partial matches in a fash-
ion similar to (NIST, 2005). As can be seen, T-
NE produced results of significantly higher quality
than ANNIE on both datasets, for the same Person
extraction task. In fact, on EnronMeetings, the F1
measure of T-NE is 7.4% higher than the best pub-
lished result (Minkov et al., 2005). Similar results
</bodyText>
<footnote confidence="0.582827">
6http://www.ontotext.com/gate/japec.html
</footnote>
<figure confidence="0.999027">
0 20 40 60 80 100
Average document size (KB)
0 20 40 60 80 100
Average document size (KB)
</figure>
<figureCaption confidence="0.985897">
Figure 9: Throughput (a) and memory consump-
tion (b) comparisons on Enron, datasets.
</figureCaption>
<bodyText confidence="0.998646923076923">
can be observed for Organization and Location on
ACE (exact numbers omitted in interest of space).
Clearly, considering the large gap between
ANNIE’s F1 and partial F1 measures on both
datasets, ANNIE’s quality can be improved via
dataset-specific tuning as demonstrated in (May-
nard et al., 2003). However, dataset-specific tun-
ing for ANNIE is beyond the scope of this paper.
Based on the experimental results above and our
previous formal comparison in Sec. 4, we believe
it is reasonable to conclude that annotators can be
built in SystemT of quality at least comparable to
those built in a grammar-based system.
</bodyText>
<subsectionHeader confidence="0.999291">
5.2 Performance Evaluation
</subsectionHeader>
<bodyText confidence="0.999933">
We now focus our attention on the throughput and
memory behavior of SystemT, and draw a com-
parison with GATE. For this purpose, we have con-
figured both ANNIE and T-NE to identify only the
same eight types of entities listed for NER task.
Throughput. Fig. 9(a) plots the throughput of
the two systems on multiple Enron, datasets with
average document sizes of between 0.5KB and
100KB. For this experiment, both systems ran
with a maximum Java heap size of 1GB.
</bodyText>
<figure confidence="0.99979524137931">
a) Throughput on Enron,,
ANNIE
ANNIE-Optimized
T-NE
0
700
Throughput (KB/sec)
600
500
400
300
200
100
b) Memory Utilization on Enron
Avg Heap size (MB)
400
200
600
0
ANNIE
ANNIE-Optimized
T-NE
Error bars show
25th and 75th
percentile
Precision (%)
(Exact/Partial)
Recall (%)
(Exact/Partial)
</figure>
<page confidence="0.994506">
135
</page>
<tableCaption confidence="0.999508">
Table 3: Throughput and mean heap size.
</tableCaption>
<table confidence="0.9987565">
ANNIE ANNIE-Optimized T-NE
Dataset ThroughputMemoryThroughput Memory ThroughputMemory
(KB/s) (MB) (KB/s) (MB) (KB/s) (MB)
WebCrawl 23.9 212.6 42.8 201.8 498.9 77.2
FinanceM 18.82 715.1 26.3 601.8 703.5 143.7
FinanceL 19.2 2586.2 21.1 2683.5 954.5 189.6
</table>
<bodyText confidence="0.999801923076923">
As shown in Fig. 9(a), even though the through-
put of ANNIE-Optimized (using the optimized trans-
ducer) increases two-fold compared to ANNIE un-
der default configuration, T-NE is between 8 and
24 times faster compared to ANNIE-Optimized. For
both systems, throughput varied with document
size. For T-NE, the relatively low throughput on
very small document sizes (less than 1KB) is due
to fixed overhead in setting up operators to pro-
cess a document. As document size increases, the
overhead becomes less noticeable.
We have observed similar trends on the rest
of the test collections. Table 3 shows that T-
NE is at least an order of magnitude faster than
ANNIE-Optimized across all datasets. In partic-
ular, on FinanceL T-NE’s throughput remains
high, whereas the performance of both ANNIE and
ANNIE-Optimized degraded significantly.
To ascertain whether the difference in perfor-
mance in the two systems is due to low-level com-
ponents such as dictionary evaluation, we per-
formed detailed profiling of the systems. The pro-
filing revealed that 8.2%, 16.2% and respectively
14.2% of the execution time was spent on aver-
age on low-level components in the case of ANNIE,
ANNIE-Optimized and T-NE, respectively, thus lead-
ing us to conclude that the observed differences
are due to SystemT’s efficient use of resources at
a macroscopic level.
Memory utilization. In theory, grammar based
systems can stream tuples through each stage
for minimal memory consumption, whereas Sys-
temT operator graphs may need to materialize in-
termediate results for the full document at certain
points to evaluate the constraints in the original
AQL. The goal of this study is to evaluate whether
this potential problem does occur in practice.
In this experiment we ran both systems with a
maximum heap size of 2GB, and used the Java
garbage collector’s built-in telemetry to measure
the total quantity of live objects in the heap over
time while annotating the different test corpora.
Fig. 9(b) plots the minimum, maximum, and mean
heap sizes with the Enron,, datasets. On small doc-
uments of size up to 15KB, memory consumption
is dominated by the fixed size of the data struc-
tures used (e.g., dictionaries, FST/operator graph),
and is comparable for both systems. As docu-
ments get larger, memory consumption increases
for both systems. However, the increase is much
smaller for T-NE compared to that for both AN-
NIE and ANNIE-Optimized. A similar trend can be
observed on the other datasets as shown in Ta-
ble 3. In particular, for FinanceL, both ANNIE and
ANNIE-Optimized required 8GB of Java heap size to
achieve reasonable throughput7, in contrast to T-
NE which utilized at most 300MB out of the 2GB
of maximum Java heap size allocation.
SystemT requires much less memory than
GATE in general due to its runtime, which monitors
data dependencies between operators and clears
out low-level results when they are no longer
needed. Although a streaming CPSL implemen-
tation is theoretically possible, in practice mecha-
nisms that allow an escape to custom code make it
difficult to decide when an intermediate result will
no longer be used, hence GATE keeps most inter-
mediate data in memory until it is done analyzing
the current document.
The BandReview Task. We conclude by briefly dis-
cussing our experience with the BandReview task
from Fig. 8. We built two versions of this anno-
tator, one in AQL, and the other using expanded
CPSL grammar. The grammar implementation
processed a 4.5GB collection of 1.05 million blogs
in 5.6 hours and output 280 reviews. In contrast,
the SystemT version (85 AQL statements) ex-
tracted 323 reviews in only 10 minutes!
</bodyText>
<sectionHeader confidence="0.999657" genericHeader="conclusions">
6 Conclusion
</sectionHeader>
<bodyText confidence="0.999949230769231">
In this paper, we described SystemT, a declar-
ative IE system based on an algebraic frame-
work. We presented both formal and empirical
arguments for the benefits of our approach to IE.
Our extensive experimental results show that high-
quality annotators can be built using SystemT,
with an order of magnitude throughput improve-
ment compared to state-of-the-art grammar-based
systems. Going forward, SystemT opens up sev-
eral new areas of research, including implement-
ing better optimization strategies and augmenting
the algebra with additional operators to support
advanced features such as coreference resolution.
</bodyText>
<footnote confidence="0.9119495">
7GATE ran out of memory when using less than 5GB of
Java heap size, and thrashed when run with 5GB to 7GB
</footnote>
<page confidence="0.996618">
136
</page>
<bodyText confidence="0.88869325">
Diana Maynard, Kalina Bontcheva, and Hamish Cun-
ningham. 2003. Towards a semantic extraction of
named entities. In Recent Advances in Natural Lan-
guage Processing.
</bodyText>
<sectionHeader confidence="0.831498" genericHeader="references">
References
</sectionHeader>
<bodyText confidence="0.900456333333333">
Douglas E. Appelt and Boyan Onyshkevych. 1998.
The common pattern specification language. In TIP-
STER workshop.
</bodyText>
<reference confidence="0.9989415">
Branimir Boguraev. 2003. Annotation-based finite
state processing in a large-scale nlp arhitecture. In
RANLP, pages 61–80.
D. D. Chamberlin, A. M. Gilbert, and Robert A. Yost.
1981. A history of System R and SQL/data system.
In vldb.
Amit Chandel, P. C. Nagesh, and Sunita Sarawagi.
2006. Efficient batch top-k search for dictionary-
based entity recognition. In ICDE.
E. F. Codd. 1990. The relational model for database
management: version 2. Addison-Wesley Longman
Publishing Co., Inc., Boston, MA, USA.
H. Cunningham, D. Maynard, and V. Tablan. 2000.
JAPE: a Java Annotation Patterns Engine (Sec-
ond Edition). Research Memorandum CS–00–10,
Department of Computer Science, University of
Sheffield, November.
H. Cunningham, D. Maynard, K. Bontcheva, and
V. Tablan. 2002. GATE: A framework and graphical
development environment for robust NLP tools and
applications. In Proceedings of the 40th Anniver-
sary Meeting of the Association for Computational
Linguistics, pages 168 – 175.
Hamish Cunningham, Diana Maynard, Kalina
Bontcheva, Valentin Tablan, Marin Dimitrov, Mike
Dowman, Niraj Aswani, Ian Roberts, Yaoyong
Li, and Adam Funk. 2010. Developing language
processing components with gate version 5 (a user
guide).
AnHai Doan, Luis Gravano, Raghu Ramakrishnan, and
Shivakumar Vaithyanathan. 2008. Special issue on
managing information extraction. SIGMOD Record,
37(4).
Witold Drozdzynski, Hans-Ulrich Krieger, Jakub
Piskorski, Ulrich Sch¨afer, and Feiyu Xu. 2004.
Shallow processing with unification and typed fea-
ture structures — foundations and applications.
K¨unstliche Intelligenz, 1:17–23.
Ralph Grishman and Beth Sundheim. 1996. Message
understanding conference - 6: A brief history. In
COLING, pages 466–471.
IBM. 2010. IBM LanguageWare.
P. G. Ipeirotis, E. Agichtein, P. Jain, and L. Gravano.
2006. To search or to crawl?: towards a query opti-
mizer for text-centric tasks. In SIGMOD.
Alpa Jain, Panagiotis G. Ipeirotis, AnHai Doan, and
Luis Gravano. 2009. Join optimization of informa-
tion extraction output: Quality matters! In ICDE.
Einat Minkov, Richard C. Wang, and William W. Co-
hen. 2005. Extracting personal names from emails:
Applying named entity recognition to informal text.
In HLT/EMNLP.
NIST. 2005. The ACE evaluation plan.
Ganesh Ramakrishnan, Sreeram Balakrishnan, and
Sachindra Joshi. 2006. Entity annotation based on
inverse index operations. In EMNLP.
Ganesh Ramakrishnan, Sachindra Joshi, Sanjeet Khai-
tan, and Sreeram Balakrishnan. 2008. Optimization
issues in inverted index-based entity annotation. In
InfoScale.
Frederick Reiss, Sriram Raghavan, Rajasekar Kr-
ishnamurthy, Huaiyu Zhu, and Shivakumar
Vaithyanathan. 2008. An algebraic approach to
rule-based information extraction. In ICDE, pages
933–942.
SAP. 2010. Inxight ThingFinder.
SAS. 2010. Text Mining with SAS Text Miner.
Warren Shen, AnHai Doan, Jeffrey F. Naughton, and
Raghu Ramakrishnan. 2007. Declarative informa-
tion extraction using datalog with embedded extrac-
tion predicates. In vldb.
SystemT. 2010. AQL Manual.
http://www.alphaworks.ibm.com/tech/systemt.
Ken Thompson. 1968. Regular expression search al-
gorithm. pages 419–422.
UIMA. 2010. Unstructured Information Management
Architecture.
http://uima.apache.org.
</reference>
<page confidence="0.99746">
137
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.891366">
<title confidence="0.9999">SystemT: An Algebraic Approach to Declarative Information Extraction</title>
<author confidence="0.9740375">Laura Chiticariu Rajasekar Krishnamurthy Yunyao Li Sriram Raghavan Frederick R Reiss Shivakumar Vaithyanathan</author>
<affiliation confidence="0.99876">IBM Research – Almaden</affiliation>
<address confidence="0.999257">San Jose, CA, USA</address>
<abstract confidence="0.99707655">As information extraction (IE) becomes more central to enterprise applications, rule-based IE engines have become increasingly important. In this paper, we a rule-based IE system whose basic design removes the expressivity and performance limitations of current systems based on cascading grama declarative rule language, AQL, and an optimizer that generates high-performance algebraic execution plans for AQL rules. We comapproach against cascading grammars, both theoretically and with a thorough experimental evaluation. Our show that deliver result quality comparable to the state-of-theart and an order of magnitude higher annotation throughput.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Branimir Boguraev</author>
</authors>
<title>Annotation-based finite state processing in a large-scale nlp arhitecture.</title>
<date>2003</date>
<booktitle>In RANLP,</booktitle>
<pages>61--80</pages>
<contexts>
<context position="1759" citStr="Boguraev, 2003" startWordPosition="245" endWordPosition="246"> redaction. This increase, combined with the inclusion of text into traditional applications like Business Intelligence, has dramatically increased the use of information extraction (IE) within the enterprise. While the traditional requirement of extraction quality remains critical, enterprise applications also demand efficiency, transparency, customizability and maintainability. In recent years, these systemic requirements have led to renewed interest in rule-based IE systems (Doan et al., 2008; SAP, 2010; IBM, 2010; SAS, 2010). Until recently, rule-based IE systems (Cunningham et al., 2000; Boguraev, 2003; Drozdzynski et al., 2004) were predominantly based on the cascading grammar formalism exemplified by the Common Pattern Specification Language (CPSL) specification (Appelt and Onyshkevych, 1998). In CPSL, the input text is viewed as a sequence of annotations, and extraction rules are written as pattern/action rules over the lexical features of these annotations. In a single phase of the grammar, a set of rules are evaluated in a left-to-right fashion over the input annotations. Multiple grammar phases are cascaded together, with the evaluation proceeding in a bottom-up fashion. As demonstrat</context>
<context position="9536" citStr="Boguraev, 2003" startWordPosition="1459" endWordPosition="1461">one single Person. L3. Limited expressivity in rule patterns. It is not possible to express rules that compare annotations overlapping with each other. E.g., “Identify 129 of SystemT, starting with the algebraic formalism behind SystemT’s operators. Caps Figure 3: Regular Expression Extraction Operator words that are both capitalized and present in the FirstGaz gazetteer” or “Identify Person annotations that occur within an EmailAddress”. Extensions to CPSL In order to address the above limitations, several extensions to CPSL have been proposed in JAPE, AFst and XTDL (Cunningham et al., 2000; Boguraev, 2003; Drozdzynski et al., 2004). The extensions are summarized as below, where each solution Si corresponds to limitation Li. • S1. Grammar rules are allowed to operate on graphs of input annotations in JAPE and AFst. • S2. JAPE introduces more matching regimes besides the CPSL’s matching priority and thus allows more flexibility when multiple rules match at the same starting position. • S3. The rule part of a pattern has been expanded to allow more expressivity in JAPE, AFst and XTDL. Fig. 2(b) illustrates how the above extensions help in identifying the correct matches ‘Mark Scott’ and ‘Howard S</context>
</contexts>
<marker>Boguraev, 2003</marker>
<rawString>Branimir Boguraev. 2003. Annotation-based finite state processing in a large-scale nlp arhitecture. In RANLP, pages 61–80.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D D Chamberlin</author>
<author>A M Gilbert</author>
<author>Robert A Yost</author>
</authors>
<title>A history of System R and SQL/data system.</title>
<date>1981</date>
<booktitle>In vldb.</booktitle>
<contexts>
<context position="3326" citStr="Chamberlin et al., 1981" startWordPosition="476" endWordPosition="479">itation, grammar-based IE systems resort to significant amounts of userdefined code in the rules, combined with preand post-processing stages beyond the scope of CPSL (Cunningham et al., 2010). Second, the rigid evaluation order imposed in these systems has significant performance implications. Three decades ago, the database community faced similar expressivity and efficiency challenges in accessing structured information. The community addressed these problems by introducing a relational algebra formalism and an associated declarative query language SQL. The groundbreaking work on System R (Chamberlin et al., 1981) demonstrated how the expressivity of SQL can be efficiently realized in practice by means of a query optimizer that translates an SQL query into an optimized query execution plan. Borrowing ideas from the database community, we have developed SystemT, a declarative IE system based on an algebraic framework, to address both expressivity and performance issues. In SystemT, extraction rules are expressed in a declarative language called AQL. At compilation time, 128 Proceedings of the 48th Annual Meeting of the Association for Computational Linguistics, pages 128–137, Uppsala, Sweden, 11-16 July</context>
</contexts>
<marker>Chamberlin, Gilbert, Yost, 1981</marker>
<rawString>D. D. Chamberlin, A. M. Gilbert, and Robert A. Yost. 1981. A history of System R and SQL/data system. In vldb.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Amit Chandel</author>
<author>P C Nagesh</author>
<author>Sunita Sarawagi</author>
</authors>
<title>Efficient batch top-k search for dictionarybased entity recognition.</title>
<date>2006</date>
<booktitle>In ICDE.</booktitle>
<contexts>
<context position="17952" citStr="Chandel et al., 2006" startWordPosition="2870" endWordPosition="2873">ipping rule evaluations. Within this large search space, there generally exists an execution strategy that implements the rule semantics far more efficiently than the fastest transducer could. We refer the reader to (Reiss et al., 2008) for a detailed description of the types of plan the optimizer considers, as well as an experimental analysis of the performance benefits of different parts of this search space. Several parallel efforts have been made recently to improve the efficiency of IE tasks by optimizing low-level feature extraction (Ramakrishnan et al., 2006; Ramakrishnan et al., 2008; Chandel et al., 2006) or by reordering operations at a macroscopic level (Ipeirotis et al., 2006; Shen et al., 2007; Jain et al., 2009). However, to the best of our knowledge, SystemT is the only IE system in which the optimizer generates a full end-to-end plan, beginning with low-level extraction primitives and ending with the final output tuples. 3.4 Deployment Scenarios SystemT is designed to be usable in various deployment scenarios. It can be used as a standalone system with its own development and runtime environment. Furthermore, SystemT exposes a generic Java API that enables the integration of its runtime</context>
</contexts>
<marker>Chandel, Nagesh, Sarawagi, 2006</marker>
<rawString>Amit Chandel, P. C. Nagesh, and Sunita Sarawagi. 2006. Efficient batch top-k search for dictionarybased entity recognition. In ICDE.</rawString>
</citation>
<citation valid="true">
<authors>
<author>E F Codd</author>
</authors>
<title>The relational model for database management: version 2.</title>
<date>1990</date>
<publisher>Addison-Wesley Longman Publishing Co., Inc.,</publisher>
<location>Boston, MA, USA.</location>
<contexts>
<context position="13250" citStr="Codd, 1990" startWordPosition="2094" endWordPosition="2095">e operator (Q) takes as input a set of tuples and the index of a particular column in those tuples. It removes selected overlapping spans from the indicated column, according to the specified policy. 3.2 AQL Extraction rules in SystemT are written in AQL, a declarative relational language similar in syntax to the database language SQL. We chose SQL as a basis for our language due to its expressivity and its familiarity. The expressivity of SQL, which consists of first-order logic predicates 130 Figure 4: Person annotator as AQL query over sets of tuples, is well-documented and wellunderstood (Codd, 1990). As SQL is the primary interface to most relational database systems, the language’s syntax and semantics are common knowledge among enterprise application programmers. Similar to SQL terminology, we call a collection of AQL rules an AQL query. Fig. 4 shows portions of an AQL query. As can be seen, the basic building block of AQL is a view: A logical description of a set of tuples in terms of either the document text (denoted by a special view called Document) or the contents of other views. Every SystemT annotator consists of at least one view. The output view statement indicates that the tu</context>
</contexts>
<marker>Codd, 1990</marker>
<rawString>E. F. Codd. 1990. The relational model for database management: version 2. Addison-Wesley Longman Publishing Co., Inc., Boston, MA, USA.</rawString>
</citation>
<citation valid="true">
<authors>
<author>H Cunningham</author>
<author>D Maynard</author>
<author>V Tablan</author>
</authors>
<title>JAPE: a Java Annotation Patterns Engine (Second Edition). Research Memorandum CS–00–10,</title>
<date>2000</date>
<institution>Department of Computer Science, University of Sheffield,</institution>
<contexts>
<context position="1743" citStr="Cunningham et al., 2000" startWordPosition="240" endWordPosition="244"> like compliance and data redaction. This increase, combined with the inclusion of text into traditional applications like Business Intelligence, has dramatically increased the use of information extraction (IE) within the enterprise. While the traditional requirement of extraction quality remains critical, enterprise applications also demand efficiency, transparency, customizability and maintainability. In recent years, these systemic requirements have led to renewed interest in rule-based IE systems (Doan et al., 2008; SAP, 2010; IBM, 2010; SAS, 2010). Until recently, rule-based IE systems (Cunningham et al., 2000; Boguraev, 2003; Drozdzynski et al., 2004) were predominantly based on the cascading grammar formalism exemplified by the Common Pattern Specification Language (CPSL) specification (Appelt and Onyshkevych, 1998). In CPSL, the input text is viewed as a sequence of annotations, and extraction rules are written as pattern/action rules over the lexical features of these annotations. In a single phase of the grammar, a set of rules are evaluated in a left-to-right fashion over the input annotations. Multiple grammar phases are cascaded together, with the evaluation proceeding in a bottom-up fashio</context>
<context position="9520" citStr="Cunningham et al., 2000" startWordPosition="1455" endWordPosition="1458">identify “Mark Scott” as one single Person. L3. Limited expressivity in rule patterns. It is not possible to express rules that compare annotations overlapping with each other. E.g., “Identify 129 of SystemT, starting with the algebraic formalism behind SystemT’s operators. Caps Figure 3: Regular Expression Extraction Operator words that are both capitalized and present in the FirstGaz gazetteer” or “Identify Person annotations that occur within an EmailAddress”. Extensions to CPSL In order to address the above limitations, several extensions to CPSL have been proposed in JAPE, AFst and XTDL (Cunningham et al., 2000; Boguraev, 2003; Drozdzynski et al., 2004). The extensions are summarized as below, where each solution Si corresponds to limitation Li. • S1. Grammar rules are allowed to operate on graphs of input annotations in JAPE and AFst. • S2. JAPE introduces more matching regimes besides the CPSL’s matching priority and thus allows more flexibility when multiple rules match at the same starting position. • S3. The rule part of a pattern has been expanded to allow more expressivity in JAPE, AFst and XTDL. Fig. 2(b) illustrates how the above extensions help in identifying the correct matches ‘Mark Scot</context>
</contexts>
<marker>Cunningham, Maynard, Tablan, 2000</marker>
<rawString>H. Cunningham, D. Maynard, and V. Tablan. 2000. JAPE: a Java Annotation Patterns Engine (Second Edition). Research Memorandum CS–00–10, Department of Computer Science, University of Sheffield, November.</rawString>
</citation>
<citation valid="true">
<authors>
<author>H Cunningham</author>
<author>D Maynard</author>
<author>K Bontcheva</author>
<author>V Tablan</author>
</authors>
<title>GATE: A framework and graphical development environment for robust NLP tools and applications.</title>
<date>2002</date>
<booktitle>In Proceedings of the 40th Anniversary Meeting of the Association for Computational Linguistics,</booktitle>
<pages>168--175</pages>
<contexts>
<context position="29913" citStr="Cunningham et al., 2002" startWordPosition="4792" endWordPosition="4795">ause named-entity recognition is a well-studied problem and standard datasets are available for evaluation. For this task we use GATE and ANNIE for comparison3. We chose BandReview to conduct performance evaluation for a more complex extraction task. Datasets. For quality evaluation, we use: • EnronMeetings (Minkov et al., 2005): collection of emails with meeting information from the Enron corpus4 with Person labeled data; • ACE (NIST, 2005): collection of newswire reports and broadcast news/conversations with Person, Organization, Location labeled data5. 3To the best of our knowledge, ANNIE (Cunningham et al., 2002) is the only publicly available NER library implemented in a grammar-based system (JAPE in GATE). 4http://www.cs.cmu.edu/ enron/ 5Only entities of type NAM have been considered. 134 Table 1: Datasets for performance evaluation. Dataset Description of the Content Number of Document size documents range average Enron, Emails randomly sampled from the Enron corpus of average size xKB (0.5 &lt; x &lt; 100)2 1000 xKB +/ − 10% xKB WebCrawl Small to medium size web pages representing company news, with HTML tags removed 1931 68b - 388.6KB 8.8KB Financem Medium size financial regulatory filings 100 240KB - </context>
</contexts>
<marker>Cunningham, Maynard, Bontcheva, Tablan, 2002</marker>
<rawString>H. Cunningham, D. Maynard, K. Bontcheva, and V. Tablan. 2002. GATE: A framework and graphical development environment for robust NLP tools and applications. In Proceedings of the 40th Anniversary Meeting of the Association for Computational Linguistics, pages 168 – 175.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Hamish Cunningham</author>
<author>Diana Maynard</author>
<author>Kalina Bontcheva</author>
<author>Valentin Tablan</author>
<author>Marin Dimitrov</author>
<author>Mike Dowman</author>
<author>Niraj Aswani</author>
<author>Ian Roberts</author>
<author>Yaoyong Li</author>
<author>Adam Funk</author>
</authors>
<title>Developing language processing components with gate version 5 (a user guide).</title>
<date>2010</date>
<contexts>
<context position="2894" citStr="Cunningham et al., 2010" startWordPosition="415" endWordPosition="418">e cascaded together, with the evaluation proceeding in a bottom-up fashion. As demonstrated by prior work (Grishman and Sundheim, 1996), grammar-based IE systems can be effective in many scenarios. However, these systems suffer from two severe drawbacks. First, the expressivity of CPSL falls short when used for complex IE tasks over increasingly pervasive informal text (emails, blogs, discussion forums etc.). To address this limitation, grammar-based IE systems resort to significant amounts of userdefined code in the rules, combined with preand post-processing stages beyond the scope of CPSL (Cunningham et al., 2010). Second, the rigid evaluation order imposed in these systems has significant performance implications. Three decades ago, the database community faced similar expressivity and efficiency challenges in accessing structured information. The community addressed these problems by introducing a relational algebra formalism and an associated declarative query language SQL. The groundbreaking work on System R (Chamberlin et al., 1981) demonstrated how the expressivity of SQL can be efficiently realized in practice by means of a query optimizer that translates an SQL query into an optimized query exe</context>
<context position="21399" citStr="Cunningham et al., 2010" startWordPosition="3430" endWordPosition="3433">2 MusicReviewSnippet Figure 8: Extracting informal band reviews from web logs occurs because CPSL only evaluates rules over the input sequence in a strict left-to-right fashion. On the other hand, the AQL query Q1 shown in the figure applies the following condition: “Always discard matches to Rule P2R3 if they overlap with matches to rules P2R1 or P2R2” (even if the match to Rule P2R3 starts earlier). Applying this rule ensures that the person names in the list are identified correctly. Obtaining the same effect in grammar-based systems would require the use of custom code (as recommended by (Cunningham et al., 2010)). Counting and Aggregation. Complex extraction tasks sometimes require operations such as counting and aggregation that go beyond the expressivity of regular languages, and thus can be expressed in CPSL only using external functions. One such task is that of identifying informal concert reviews embedded within blog entries. Fig. 8 describes, by example, how these reviews consist of reference to a live concert followed by several review snippets, some specific to musical performances and others that are more general review expressions. An example rule to identify informal reviews is also shown</context>
<context position="23985" citStr="Cunningham et al., 2010" startWordPosition="3851" endWordPosition="3855">ons as an expanded CPSL grammar. Ambiguous Grammar Specification An expanded CPSL grammar may be under-specified in some cases. For example, a single rule containing the disjunction operator (|) may match a given region of text in multiple ways. Consider the evaluation of Rule P2R3 over the text fragment “Scott, Howard” from document d1 (Fig. 1). If “Howard” is identified both as Caps and First, then there are two evaluations for Rule P2R3 over this text fragment. Since the system has to arbitrarily choose one evaluation, the results of the grammar can be non-deterministic (as pointed out in (Cunningham et al., 2010)). We refer to a grammar G as an ambiguous grammar specification for a document collection D if the system makes an arbitrary choice while evaluating G over D. Definition 1(UnambigEquiv) A query Q is UnambigEquiv to a cascading grammar !9 if and only iffor every document collection D, where G is not an ambiguous grammar specification for D, the results of the grammar invocation and the query evaluation are identical. We now formally compare the expressivity of AQL and expanded CPSL grammars. The detailed proof is omitted due to space limitations. Theorem 1 The class of extraction tasks express</context>
</contexts>
<marker>Cunningham, Maynard, Bontcheva, Tablan, Dimitrov, Dowman, Aswani, Roberts, Li, Funk, 2010</marker>
<rawString>Hamish Cunningham, Diana Maynard, Kalina Bontcheva, Valentin Tablan, Marin Dimitrov, Mike Dowman, Niraj Aswani, Ian Roberts, Yaoyong Li, and Adam Funk. 2010. Developing language processing components with gate version 5 (a user guide).</rawString>
</citation>
<citation valid="true">
<authors>
<author>AnHai Doan</author>
<author>Luis Gravano</author>
<author>Raghu Ramakrishnan</author>
<author>Shivakumar Vaithyanathan</author>
</authors>
<title>Special issue on managing information extraction.</title>
<date>2008</date>
<journal>SIGMOD Record,</journal>
<volume>37</volume>
<issue>4</issue>
<contexts>
<context position="1645" citStr="Doan et al., 2008" startWordPosition="225" endWordPosition="228">n recent years, enterprises have seen the emergence of important text analytics applications like compliance and data redaction. This increase, combined with the inclusion of text into traditional applications like Business Intelligence, has dramatically increased the use of information extraction (IE) within the enterprise. While the traditional requirement of extraction quality remains critical, enterprise applications also demand efficiency, transparency, customizability and maintainability. In recent years, these systemic requirements have led to renewed interest in rule-based IE systems (Doan et al., 2008; SAP, 2010; IBM, 2010; SAS, 2010). Until recently, rule-based IE systems (Cunningham et al., 2000; Boguraev, 2003; Drozdzynski et al., 2004) were predominantly based on the cascading grammar formalism exemplified by the Common Pattern Specification Language (CPSL) specification (Appelt and Onyshkevych, 1998). In CPSL, the input text is viewed as a sequence of annotations, and extraction rules are written as pattern/action rules over the lexical features of these annotations. In a single phase of the grammar, a set of rules are evaluated in a left-to-right fashion over the input annotations. M</context>
</contexts>
<marker>Doan, Gravano, Ramakrishnan, Vaithyanathan, 2008</marker>
<rawString>AnHai Doan, Luis Gravano, Raghu Ramakrishnan, and Shivakumar Vaithyanathan. 2008. Special issue on managing information extraction. SIGMOD Record, 37(4).</rawString>
</citation>
<citation valid="true">
<authors>
<author>Witold Drozdzynski</author>
<author>Hans-Ulrich Krieger</author>
<author>Jakub Piskorski</author>
<author>Ulrich Sch¨afer</author>
<author>Feiyu Xu</author>
</authors>
<title>Shallow processing with unification and typed feature structures — foundations and applications. K¨unstliche Intelligenz,</title>
<date>2004</date>
<pages>1--17</pages>
<marker>Drozdzynski, Krieger, Piskorski, Sch¨afer, Xu, 2004</marker>
<rawString>Witold Drozdzynski, Hans-Ulrich Krieger, Jakub Piskorski, Ulrich Sch¨afer, and Feiyu Xu. 2004. Shallow processing with unification and typed feature structures — foundations and applications. K¨unstliche Intelligenz, 1:17–23.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ralph Grishman</author>
<author>Beth Sundheim</author>
</authors>
<title>Message understanding conference - 6: A brief history.</title>
<date>1996</date>
<booktitle>In COLING,</booktitle>
<pages>466--471</pages>
<contexts>
<context position="2405" citStr="Grishman and Sundheim, 1996" startWordPosition="342" endWordPosition="345">l., 2004) were predominantly based on the cascading grammar formalism exemplified by the Common Pattern Specification Language (CPSL) specification (Appelt and Onyshkevych, 1998). In CPSL, the input text is viewed as a sequence of annotations, and extraction rules are written as pattern/action rules over the lexical features of these annotations. In a single phase of the grammar, a set of rules are evaluated in a left-to-right fashion over the input annotations. Multiple grammar phases are cascaded together, with the evaluation proceeding in a bottom-up fashion. As demonstrated by prior work (Grishman and Sundheim, 1996), grammar-based IE systems can be effective in many scenarios. However, these systems suffer from two severe drawbacks. First, the expressivity of CPSL falls short when used for complex IE tasks over increasingly pervasive informal text (emails, blogs, discussion forums etc.). To address this limitation, grammar-based IE systems resort to significant amounts of userdefined code in the rules, combined with preand post-processing stages beyond the scope of CPSL (Cunningham et al., 2010). Second, the rigid evaluation order imposed in these systems has significant performance implications. Three d</context>
</contexts>
<marker>Grishman, Sundheim, 1996</marker>
<rawString>Ralph Grishman and Beth Sundheim. 1996. Message understanding conference - 6: A brief history. In COLING, pages 466–471.</rawString>
</citation>
<citation valid="true">
<authors>
<author>IBM LanguageWare P G Ipeirotis</author>
<author>E Agichtein</author>
<author>P Jain</author>
<author>L Gravano</author>
</authors>
<title>To search or to crawl?: towards a query optimizer for text-centric tasks.</title>
<date>2006</date>
<booktitle>In SIGMOD.</booktitle>
<contexts>
<context position="18027" citStr="Ipeirotis et al., 2006" startWordPosition="2883" endWordPosition="2886">xists an execution strategy that implements the rule semantics far more efficiently than the fastest transducer could. We refer the reader to (Reiss et al., 2008) for a detailed description of the types of plan the optimizer considers, as well as an experimental analysis of the performance benefits of different parts of this search space. Several parallel efforts have been made recently to improve the efficiency of IE tasks by optimizing low-level feature extraction (Ramakrishnan et al., 2006; Ramakrishnan et al., 2008; Chandel et al., 2006) or by reordering operations at a macroscopic level (Ipeirotis et al., 2006; Shen et al., 2007; Jain et al., 2009). However, to the best of our knowledge, SystemT is the only IE system in which the optimizer generates a full end-to-end plan, beginning with low-level extraction primitives and ending with the final output tuples. 3.4 Deployment Scenarios SystemT is designed to be usable in various deployment scenarios. It can be used as a standalone system with its own development and runtime environment. Furthermore, SystemT exposes a generic Java API that enables the integration of its runtime environment with other applications. For example, a specific instantiation</context>
</contexts>
<marker>Ipeirotis, Agichtein, Jain, Gravano, 2006</marker>
<rawString>IBM. 2010. IBM LanguageWare. P. G. Ipeirotis, E. Agichtein, P. Jain, and L. Gravano. 2006. To search or to crawl?: towards a query optimizer for text-centric tasks. In SIGMOD.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Alpa Jain</author>
<author>Panagiotis G Ipeirotis</author>
<author>AnHai Doan</author>
<author>Luis Gravano</author>
</authors>
<title>Join optimization of information extraction output: Quality matters!</title>
<date>2009</date>
<booktitle>In ICDE.</booktitle>
<contexts>
<context position="18066" citStr="Jain et al., 2009" startWordPosition="2891" endWordPosition="2894"> the rule semantics far more efficiently than the fastest transducer could. We refer the reader to (Reiss et al., 2008) for a detailed description of the types of plan the optimizer considers, as well as an experimental analysis of the performance benefits of different parts of this search space. Several parallel efforts have been made recently to improve the efficiency of IE tasks by optimizing low-level feature extraction (Ramakrishnan et al., 2006; Ramakrishnan et al., 2008; Chandel et al., 2006) or by reordering operations at a macroscopic level (Ipeirotis et al., 2006; Shen et al., 2007; Jain et al., 2009). However, to the best of our knowledge, SystemT is the only IE system in which the optimizer generates a full end-to-end plan, beginning with low-level extraction primitives and ending with the final output tuples. 3.4 Deployment Scenarios SystemT is designed to be usable in various deployment scenarios. It can be used as a standalone system with its own development and runtime environment. Furthermore, SystemT exposes a generic Java API that enables the integration of its runtime environment with other applications. For example, a specific instantiation of this API allows SystemT annotators </context>
</contexts>
<marker>Jain, Ipeirotis, Doan, Gravano, 2009</marker>
<rawString>Alpa Jain, Panagiotis G. Ipeirotis, AnHai Doan, and Luis Gravano. 2009. Join optimization of information extraction output: Quality matters! In ICDE.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Einat Minkov</author>
<author>Richard C Wang</author>
<author>William W Cohen</author>
</authors>
<title>Extracting personal names from emails: Applying named entity recognition to informal text.</title>
<date>2005</date>
<booktitle>In HLT/EMNLP.</booktitle>
<contexts>
<context position="20430" citStr="Minkov et al., 2005" startWordPosition="3267" endWordPosition="3270">, the tuples that a given view produces are in no way constrained by the outputs of other, unrelated views, so the rigid matching priority problem never occurs. Finally, the select statement in AQL allows arbitrary predicates over the cross-product of its input tuple sets, eliminating the limited expressivity in rule patterns problem. Beyond eliminating the major limitations of CPSL grammars, AQL provides a number of other information extraction operations that even extended CPSL cannot express without custom code. Complex rule interactions. Consider an example document from the Enron corpus (Minkov et al., 2005), shown in Fig. 7, which contains a list of person names. Because the first person in the list (‘Skilling’) is referred to by only a last name, rule P2R3 in Fig. 1 incorrectly identifies ‘Skilling, Cindy’ as a person. Consequently, the output of phase P2 of the cascading grammar contains several mistakes as shown in the figure. This problem 132 MusicReviewSnippet Figure 8: Extracting informal band reviews from web logs occurs because CPSL only evaluates rules over the input sequence in a strict left-to-right fashion. On the other hand, the AQL query Q1 shown in the figure applies the following</context>
<context position="29619" citStr="Minkov et al., 2005" startWordPosition="4748" endWordPosition="4751">formance and resource requirements. Tasks We chose two tasks for our evaluation: • NER : named-entity recognition for Person, Organization, Location, Address, PhoneNumber, EmailAddress, URL and DateTime. • BandReview : identify informal reviews in blogs (Fig. 8). We chose NER primarily because named-entity recognition is a well-studied problem and standard datasets are available for evaluation. For this task we use GATE and ANNIE for comparison3. We chose BandReview to conduct performance evaluation for a more complex extraction task. Datasets. For quality evaluation, we use: • EnronMeetings (Minkov et al., 2005): collection of emails with meeting information from the Enron corpus4 with Person labeled data; • ACE (NIST, 2005): collection of newswire reports and broadcast news/conversations with Person, Organization, Location labeled data5. 3To the best of our knowledge, ANNIE (Cunningham et al., 2002) is the only publicly available NER library implemented in a grammar-based system (JAPE in GATE). 4http://www.cs.cmu.edu/ enron/ 5Only entities of type NAM have been considered. 134 Table 1: Datasets for performance evaluation. Dataset Description of the Content Number of Document size documents range ave</context>
<context position="32331" citStr="Minkov et al., 2005" startWordPosition="5169" endWordPosition="5172">arison between SystemT and GATE by verifying that the annotators used in the study are comparable. Table 2 shows results of our comparison study for Person annotators. We report the classical (exact) precision, recall, and F1 measures that credit only exact matches, and corresponding partial measures that credit partial matches in a fashion similar to (NIST, 2005). As can be seen, TNE produced results of significantly higher quality than ANNIE on both datasets, for the same Person extraction task. In fact, on EnronMeetings, the F1 measure of T-NE is 7.4% higher than the best published result (Minkov et al., 2005). Similar results 6http://www.ontotext.com/gate/japec.html 0 20 40 60 80 100 Average document size (KB) 0 20 40 60 80 100 Average document size (KB) Figure 9: Throughput (a) and memory consumption (b) comparisons on Enron, datasets. can be observed for Organization and Location on ACE (exact numbers omitted in interest of space). Clearly, considering the large gap between ANNIE’s F1 and partial F1 measures on both datasets, ANNIE’s quality can be improved via dataset-specific tuning as demonstrated in (Maynard et al., 2003). However, dataset-specific tuning for ANNIE is beyond the scope of thi</context>
</contexts>
<marker>Minkov, Wang, Cohen, 2005</marker>
<rawString>Einat Minkov, Richard C. Wang, and William W. Cohen. 2005. Extracting personal names from emails: Applying named entity recognition to informal text. In HLT/EMNLP.</rawString>
</citation>
<citation valid="true">
<authors>
<author>NIST</author>
</authors>
<title>The ACE evaluation plan.</title>
<date>2005</date>
<contexts>
<context position="29734" citStr="NIST, 2005" startWordPosition="4769" endWordPosition="4770">, Organization, Location, Address, PhoneNumber, EmailAddress, URL and DateTime. • BandReview : identify informal reviews in blogs (Fig. 8). We chose NER primarily because named-entity recognition is a well-studied problem and standard datasets are available for evaluation. For this task we use GATE and ANNIE for comparison3. We chose BandReview to conduct performance evaluation for a more complex extraction task. Datasets. For quality evaluation, we use: • EnronMeetings (Minkov et al., 2005): collection of emails with meeting information from the Enron corpus4 with Person labeled data; • ACE (NIST, 2005): collection of newswire reports and broadcast news/conversations with Person, Organization, Location labeled data5. 3To the best of our knowledge, ANNIE (Cunningham et al., 2002) is the only publicly available NER library implemented in a grammar-based system (JAPE in GATE). 4http://www.cs.cmu.edu/ enron/ 5Only entities of type NAM have been considered. 134 Table 1: Datasets for performance evaluation. Dataset Description of the Content Number of Document size documents range average Enron, Emails randomly sampled from the Enron corpus of average size xKB (0.5 &lt; x &lt; 100)2 1000 xKB +/ − 10% xK</context>
<context position="32077" citStr="NIST, 2005" startWordPosition="5126" endWordPosition="5127">zed, respectively. 5.1 Quality Evaluation The goal of our quality evaluation is two-fold: to validate that annotators can be built in SystemT with quality comparable to those built in a grammar-based system; and to ensure a fair performance comparison between SystemT and GATE by verifying that the annotators used in the study are comparable. Table 2 shows results of our comparison study for Person annotators. We report the classical (exact) precision, recall, and F1 measures that credit only exact matches, and corresponding partial measures that credit partial matches in a fashion similar to (NIST, 2005). As can be seen, TNE produced results of significantly higher quality than ANNIE on both datasets, for the same Person extraction task. In fact, on EnronMeetings, the F1 measure of T-NE is 7.4% higher than the best published result (Minkov et al., 2005). Similar results 6http://www.ontotext.com/gate/japec.html 0 20 40 60 80 100 Average document size (KB) 0 20 40 60 80 100 Average document size (KB) Figure 9: Throughput (a) and memory consumption (b) comparisons on Enron, datasets. can be observed for Organization and Location on ACE (exact numbers omitted in interest of space). Clearly, consi</context>
</contexts>
<marker>NIST, 2005</marker>
<rawString>NIST. 2005. The ACE evaluation plan.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ganesh Ramakrishnan</author>
<author>Sreeram Balakrishnan</author>
<author>Sachindra Joshi</author>
</authors>
<title>Entity annotation based on inverse index operations.</title>
<date>2006</date>
<booktitle>In EMNLP.</booktitle>
<contexts>
<context position="17902" citStr="Ramakrishnan et al., 2006" startWordPosition="2862" endWordPosition="2865">sharing work across different rules, or selectively skipping rule evaluations. Within this large search space, there generally exists an execution strategy that implements the rule semantics far more efficiently than the fastest transducer could. We refer the reader to (Reiss et al., 2008) for a detailed description of the types of plan the optimizer considers, as well as an experimental analysis of the performance benefits of different parts of this search space. Several parallel efforts have been made recently to improve the efficiency of IE tasks by optimizing low-level feature extraction (Ramakrishnan et al., 2006; Ramakrishnan et al., 2008; Chandel et al., 2006) or by reordering operations at a macroscopic level (Ipeirotis et al., 2006; Shen et al., 2007; Jain et al., 2009). However, to the best of our knowledge, SystemT is the only IE system in which the optimizer generates a full end-to-end plan, beginning with low-level extraction primitives and ending with the final output tuples. 3.4 Deployment Scenarios SystemT is designed to be usable in various deployment scenarios. It can be used as a standalone system with its own development and runtime environment. Furthermore, SystemT exposes a generic Ja</context>
</contexts>
<marker>Ramakrishnan, Balakrishnan, Joshi, 2006</marker>
<rawString>Ganesh Ramakrishnan, Sreeram Balakrishnan, and Sachindra Joshi. 2006. Entity annotation based on inverse index operations. In EMNLP.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ganesh Ramakrishnan</author>
<author>Sachindra Joshi</author>
<author>Sanjeet Khaitan</author>
<author>Sreeram Balakrishnan</author>
</authors>
<title>Optimization issues in inverted index-based entity annotation. In InfoScale.</title>
<date>2008</date>
<contexts>
<context position="17929" citStr="Ramakrishnan et al., 2008" startWordPosition="2866" endWordPosition="2869">nt rules, or selectively skipping rule evaluations. Within this large search space, there generally exists an execution strategy that implements the rule semantics far more efficiently than the fastest transducer could. We refer the reader to (Reiss et al., 2008) for a detailed description of the types of plan the optimizer considers, as well as an experimental analysis of the performance benefits of different parts of this search space. Several parallel efforts have been made recently to improve the efficiency of IE tasks by optimizing low-level feature extraction (Ramakrishnan et al., 2006; Ramakrishnan et al., 2008; Chandel et al., 2006) or by reordering operations at a macroscopic level (Ipeirotis et al., 2006; Shen et al., 2007; Jain et al., 2009). However, to the best of our knowledge, SystemT is the only IE system in which the optimizer generates a full end-to-end plan, beginning with low-level extraction primitives and ending with the final output tuples. 3.4 Deployment Scenarios SystemT is designed to be usable in various deployment scenarios. It can be used as a standalone system with its own development and runtime environment. Furthermore, SystemT exposes a generic Java API that enables the int</context>
</contexts>
<marker>Ramakrishnan, Joshi, Khaitan, Balakrishnan, 2008</marker>
<rawString>Ganesh Ramakrishnan, Sachindra Joshi, Sanjeet Khaitan, and Sreeram Balakrishnan. 2008. Optimization issues in inverted index-based entity annotation. In InfoScale.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Frederick Reiss</author>
<author>Sriram Raghavan</author>
<author>Rajasekar Krishnamurthy</author>
<author>Huaiyu Zhu</author>
<author>Shivakumar Vaithyanathan</author>
</authors>
<title>An algebraic approach to rule-based information extraction.</title>
<date>2008</date>
<booktitle>In ICDE,</booktitle>
<pages>933--942</pages>
<contexts>
<context position="12043" citStr="Reiss et al., 2008" startWordPosition="1882" endWordPosition="1885">In this data model, a span is a region of text within a document identified by its “begin” and “end” positions; a tuple is a fixed-size list of spans. A relation is a multiset of tuples, where every tuple in the relation must be of the same size. Each operator in our algebra implements a single basic atomic IE operation, producing and consuming sets of tuples. Fig. 3 illustrates the regular expression extraction operator in the algebra, which performs character-level regular expression matching. Overall, the algebra contains 12 different operators, a full description of which can be found in (Reiss et al., 2008). The following four operators are necessary to understand the examples in this paper: • The Extract operator (£) performs characterlevel operations such as regular expression and dictionary matching over text, creating a tuple for each match. • The Select operator (Q) takes as input a set of tuples and a predicate to apply to the tuples. It outputs all tuples that satisfy the predicate. • The Join operator (⊲⊳) takes as input two sets of tuples and a predicate to apply to pairs of tuples from the input sets. It outputs all pairs of input tuples that satisfy the predicate. • The consolidate op</context>
<context position="17029" citStr="Reiss et al., 2008" startWordPosition="2720" endWordPosition="2723">ifferent evaluation costs. The optimizer chooses the execution strategy with the lowest estimated evaluation cost. AQL SystemT Runtime SystemT Optimizer Compiled Operator Graph 131 Fig. 6 presents three possible execution strategies for the CapsLast rule in Fig. 4. If the optimizer estimates that the evaluation cost of Last is much lower than that of Caps, then it can determine that Plan C has the lowest evaluation cost among the three, because Plan C only evaluates Caps in the “left” neighborhood for each instance of Last. More details of our algorithms for enumerating plans can be found in (Reiss et al., 2008). The optimizer in SystemT chooses the best execution plan from a large number of different algebra graphs available to it. Many of these graphs implement strategies that a transducer could not express: such as evaluating rules from right to left, sharing work across different rules, or selectively skipping rule evaluations. Within this large search space, there generally exists an execution strategy that implements the rule semantics far more efficiently than the fastest transducer could. We refer the reader to (Reiss et al., 2008) for a detailed description of the types of plan the optimizer</context>
</contexts>
<marker>Reiss, Raghavan, Krishnamurthy, Zhu, Vaithyanathan, 2008</marker>
<rawString>Frederick Reiss, Sriram Raghavan, Rajasekar Krishnamurthy, Huaiyu Zhu, and Shivakumar Vaithyanathan. 2008. An algebraic approach to rule-based information extraction. In ICDE, pages 933–942.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Inxight ThingFinder SAS</author>
</authors>
<date>2010</date>
<journal>Text Mining with SAS Text Miner.</journal>
<contexts>
<context position="1679" citStr="SAS, 2010" startWordPosition="233" endWordPosition="234"> emergence of important text analytics applications like compliance and data redaction. This increase, combined with the inclusion of text into traditional applications like Business Intelligence, has dramatically increased the use of information extraction (IE) within the enterprise. While the traditional requirement of extraction quality remains critical, enterprise applications also demand efficiency, transparency, customizability and maintainability. In recent years, these systemic requirements have led to renewed interest in rule-based IE systems (Doan et al., 2008; SAP, 2010; IBM, 2010; SAS, 2010). Until recently, rule-based IE systems (Cunningham et al., 2000; Boguraev, 2003; Drozdzynski et al., 2004) were predominantly based on the cascading grammar formalism exemplified by the Common Pattern Specification Language (CPSL) specification (Appelt and Onyshkevych, 1998). In CPSL, the input text is viewed as a sequence of annotations, and extraction rules are written as pattern/action rules over the lexical features of these annotations. In a single phase of the grammar, a set of rules are evaluated in a left-to-right fashion over the input annotations. Multiple grammar phases are cascade</context>
</contexts>
<marker>SAS, 2010</marker>
<rawString>SAP. 2010. Inxight ThingFinder. SAS. 2010. Text Mining with SAS Text Miner.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Warren Shen</author>
<author>AnHai Doan</author>
<author>Jeffrey F Naughton</author>
<author>Raghu Ramakrishnan</author>
</authors>
<title>Declarative information extraction using datalog with embedded extraction predicates.</title>
<date>2007</date>
<booktitle>In vldb.</booktitle>
<contexts>
<context position="18046" citStr="Shen et al., 2007" startWordPosition="2887" endWordPosition="2890">egy that implements the rule semantics far more efficiently than the fastest transducer could. We refer the reader to (Reiss et al., 2008) for a detailed description of the types of plan the optimizer considers, as well as an experimental analysis of the performance benefits of different parts of this search space. Several parallel efforts have been made recently to improve the efficiency of IE tasks by optimizing low-level feature extraction (Ramakrishnan et al., 2006; Ramakrishnan et al., 2008; Chandel et al., 2006) or by reordering operations at a macroscopic level (Ipeirotis et al., 2006; Shen et al., 2007; Jain et al., 2009). However, to the best of our knowledge, SystemT is the only IE system in which the optimizer generates a full end-to-end plan, beginning with low-level extraction primitives and ending with the final output tuples. 3.4 Deployment Scenarios SystemT is designed to be usable in various deployment scenarios. It can be used as a standalone system with its own development and runtime environment. Furthermore, SystemT exposes a generic Java API that enables the integration of its runtime environment with other applications. For example, a specific instantiation of this API allows</context>
</contexts>
<marker>Shen, Doan, Naughton, Ramakrishnan, 2007</marker>
<rawString>Warren Shen, AnHai Doan, Jeffrey F. Naughton, and Raghu Ramakrishnan. 2007. Declarative information extraction using datalog with embedded extraction predicates. In vldb.</rawString>
</citation>
<citation valid="true">
<authors>
<author>SystemT</author>
</authors>
<date>2010</date>
<note>AQL Manual. http://www.alphaworks.ibm.com/tech/systemt.</note>
<contexts>
<context position="15534" citStr="SystemT, 2010" startWordPosition="2472" endWordPosition="2473">ing tokenization, part of speech and gazetteer matching for over 20 languages using LanguageWare (IBM, 2010). Rule developers can utilize the multilingual support via AQL without having to configure or manage any additional resources. In addition, AQL allows user-defined functions to be used in a restricted context in order to support operations such as validation (e.g. for extracted credit card numbers), or normalization (e.g., compute abbreviations of multi-token organization candidates that are useful in generating additional candidates). More details on AQL can be found in the AQL manual (SystemT, 2010). 3.3 Optimizer and Operator Graph Grammar-based IE engines place rigid restrictions on the order in which rules can be executed. Due to the semantics of the CPSL standard, systems that implement the standard must use a finite state transducer that evaluates each level of the cascade with one or more left to right passes over the entire token stream. In contrast, SystemT places no explicit constraints on the order of rule evaluation, nor does it require that intermediate results of an annotator collapse to a fixed-size sequence. As shown in Fig. 5, the SystemT engine does not execute AQL direc</context>
</contexts>
<marker>SystemT, 2010</marker>
<rawString>SystemT. 2010. AQL Manual. http://www.alphaworks.ibm.com/tech/systemt.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ken Thompson</author>
</authors>
<title>Regular expression search algorithm.</title>
<date>1968</date>
<pages>419--422</pages>
<contexts>
<context position="27905" citStr="Thompson, 1968" startWordPosition="4484" endWordPosition="4485">ht there exist a finite state transducer that is combinatorially faster than any possible algebra graph? It turns out that this scenario is not possible, as the theorem below shows. Definition 2 (Token-Based FST) A token-based finite state transducer (FST) is a nondeterministic finite state machine in which state transitions are triggered by predicates on tokens. A token-based FST is acyclic if its state graph does not contain any cycles and has exactly one “accept” state. Definition 3 (Thompson’s Algorithm) Thompson’s algorithm is a common strategy for evaluating a token-based FST (based on (Thompson, 1968)). This algorithm processes the input tokens from left to right, keeping track of the set of states that are currently active. Theorem 2 For any acyclic token-based finite state transducer T, there exists an UnambigEquiv operator graph G, such that evaluating G has the same computational complexity as evaluating T with Thompson’s algorithm starting from each token position in the input document. Proof Outline: The proof constructs G by structural induction over the transducer T. The base case converts transitions out of the start state into Extract operators. The inductive case adds a Select o</context>
</contexts>
<marker>Thompson, 1968</marker>
<rawString>Ken Thompson. 1968. Regular expression search algorithm. pages 419–422.</rawString>
</citation>
<citation valid="true">
<authors>
<author>UIMA</author>
</authors>
<date>2010</date>
<journal>Unstructured Information Management Architecture.</journal>
<contexts>
<context position="18755" citStr="UIMA, 2010" startWordPosition="3005" endWordPosition="3006">h the optimizer generates a full end-to-end plan, beginning with low-level extraction primitives and ending with the final output tuples. 3.4 Deployment Scenarios SystemT is designed to be usable in various deployment scenarios. It can be used as a standalone system with its own development and runtime environment. Furthermore, SystemT exposes a generic Java API that enables the integration of its runtime environment with other applications. For example, a specific instantiation of this API allows SystemT annotators to be seamlessly embedded in applications using the UIMA analytics framework (UIMA, 2010). 4 Grammar vs. Algebra Having described both the traditional cascading grammar approach and the declarative approach Figure 7: Supporting Complex Rule Interactions used in SystemT, we now compare the two in terms of expressivity and performance. 4.1 Expressivity In Section 2, we described three expressivity limitations of CPSL grammars: Lossy sequencing, rigid matching priority, and limited expressivity in rule patterns. As we noted, cascading grammar systems extend the CPSL specification in various ways to provide workarounds for these limitations. In SystemT, the basic design of the AQL lan</context>
</contexts>
<marker>UIMA, 2010</marker>
<rawString>UIMA. 2010. Unstructured Information Management Architecture.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>