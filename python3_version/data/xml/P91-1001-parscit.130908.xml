<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<sectionHeader confidence="0.9923085" genericHeader="method">
RESOLUTION OF COLLECTIVE-DISTRIBUTIVE AMBIGUITY
USING MODEL-BASED REASONING
</sectionHeader>
<note confidence="0.373493">
Chinatsu Aone*
MCC
</note>
<address confidence="0.730051">
3500 West Balcones Center Dr.
Austin, TX 78759
</address>
<email confidence="0.996621">
aone@mcc.com
</email>
<sectionHeader confidence="0.993897" genericHeader="method">
Abstract
</sectionHeader>
<bodyText confidence="0.999823692307692">
I present a semantic analysis of collective-
distributive ambiguity, and resolution of such am-
biguity by model-based reasoning. This approach
goes beyond Scha and Stallard [17], whose reasoning
capability was limited to checking semantic types.
My semantic analysis is based on Link [14, 13] and
Roberts [15], where distributivity comes uniformly
from a quantificational operator, either explicit (e.g.
each) or implicit (e.g. the D operator). I view
the semantics module of the natural language sys-
tem as a hypothesis generator and the reasoner in
the pragmatics module as a hypothesis filter (cf.
Simmons and Davis [18]). The reasoner utilizes a
model consisting of domain-dependent constraints
and domain-independent axioms for disambiguation.
There are two kinds of constraints, type constraints
and numerical constraints, and they are associated
with predicates in the knowledge base. Whenever
additional information is derived from the model,
the Contradiction Checker is invoked to detect any
contradiction in a hypothesis using simple mathe-
matical knowledge. CDCL (Collective-Distributive
Constraint Language) is used to represent hypothe-
ses, constraints, and axioms in a way isomorphic
to diagram representations of collective-distributive
ambiguity.
</bodyText>
<sectionHeader confidence="0.9135505" genericHeader="method">
1 Semantics of Collective-
Distributive Ambiguity
</sectionHeader>
<bodyText confidence="0.8884545">
Collective-distributive ambiguity can be illustrated
by the following sentence.
</bodyText>
<listItem confidence="0.782302666666667">
(1) Two students moved a desk upstairs.
(1) means either that two students TOGETHER
moved one desk (a collective reading) or that each
</listItem>
<bodyText confidence="0.9957858">
The work described in this paper was done as a part of
the author&apos;s doctoral dissertation at The University of Texas
at Austin.
of them moved a desk SEPARATELY (a distributive
reading). Following Link [14, 13] and Roberts [15],
distributivity comes from either an explicit quantifi-
cational operator like each or an implicit distributive
operator called the D operator. The D operator
was motivated by the equivalence in the semantics
of the following sentences.
</bodyText>
<listItem confidence="0.9832155">
(2) a. Every student in this class lifted the piano.
b. Students in this class each lifted the piano.
c. Students in this class lifted the piano.
(the distributive reading)
</listItem>
<bodyText confidence="0.999843217391304">
Thus, the distributive readings of (1) and (2c) result
from applying the D operator to the subjects.
Now, look at another sentence &amp;quot;Five students ate
four slices of pizza.&amp;quot; It has 8 POSSIBLE readings be-
cause the D operator may apply to each of the two
arguments of eat, and the two NPs can take scope
over each other. Thus, 2 x 2 x 2 = 8.1 I have extended
Link&apos;s and Roberts&apos;s theories to quantify over events
in Discourse Representation Theory (cf. Kamp [14
Heim [9], Aone [2]) so that these readings can be sys-
tematically generated and represented in the seman-
tics module. However, the most PLAUSIBLE reading
is the &amp;quot;distributive-distributive reading&amp;quot;, where each
of the five students ate four slices one at a time, as
represented in a discourse representation structure
(DRS) in Figure 12. Such plausibility comes partly
from the lexical semantics of eat. From our &amp;quot;common
sense&amp;quot;, we know that &amp;quot;eating&amp;quot; is an individual activ-
ity unlike &amp;quot;moving a desk&amp;quot;, which can be done either
individually or in a group. However, such plausi-
bility should not be a part of the semantic theory,
but should be dealt with in pragmatics where world
knowledge is available. In section 2, I&apos;ll identify the
</bodyText>
<footnote confidence="0.9836884">
&apos;Actually the two collective-collective readings are equiv-
alent, so there are 7 distinct readings.
2(i-part x&apos; x) says &amp;quot;x&apos; is an atomic individual-part of x&amp;quot;
(cf. Link [12]), and CU, i.e. &amp;quot;Count-Unit&amp;quot;, stands for a natural
measure unit for students (cf. Krifka [11]).
</footnote>
<page confidence="0.941483">
1
</page>
<figureCaption confidence="0.99864">
Figure 1: DRS for &amp;quot;Five students ate four slices of pizza&amp;quot;
</figureCaption>
<equation confidence="0.962194090909091">
(student x)
(amount x 5)
(measure x CU)
x&apos;
(i-part x&apos; x)
(pizza y)
(amount y 4)
(measure y slice)
Y&apos;
(i-part y&apos; y)
=-- (eat e x&apos; y&apos;)
</equation>
<bodyText confidence="0.9586082">
necessary knowledge and develop a reasoner, which
goes beyond Scha and Stallard [17].
There is a special reading called a cumulative
reading (cf. Scha [16]).
(3) 500 students ate 1200 slices of pizza.
The cumulative reading of (3) says &amp;quot;there were 500
students and each student ate some slices of pizza,
totaling 1200 slices.&amp;quot; The semantics of a cumulative
reading is UNDERSPECIFIED and is represented as a
collective-collective reading at the semantic level (cf.
Link [13], Roberts [15], Aone [2]). This means that a
cumulative reading should have a more specific rep-
resentation at the pragmatics level for inferencing.
Reasoning about cumulative readings is particularly
interesting, and I will discuss it in detail.
</bodyText>
<sectionHeader confidence="0.9776835" genericHeader="method">
2 Model-Based Reasoning for
Disambiguation
</sectionHeader>
<bodyText confidence="0.998337791666667">
Although scope ambiguity has been worked on by
many researchers (e.g. Grosz et al. [8]), the main
problem addressed has been how to generate all the
scope choices and order them according to some
heuristics. This approach might be sufficient as
far as scope ambiguity goes. However, collective-
distributive ambiguity subsumes scope ambiguity
and a heuristics strategy would not be a strong
method. I argue that the reason why some of the
readings are implausible (and even do not occur to
some people) is because we have access to domain-
dependent knowledge (e.g. constraints on predi-
cates) along with domain-independent knowledge
(e.g. mathematical knowledge). I have developed a
reasoner based on the theory of model-based reason-
ing (cf. Simmons and Davis [18], Fink and Lusth [6],
Davis and Hamscher [5]) for collective-distributive
ambiguity resolution. The model that the reasoner
uses consists of four kinds of knowledge, namely
predicate constraints, two types of axioms, and sim-
ple mathematical knowledge. First, I will discuss the
representation language CDCL3. Then, I will discuss
how these four kinds of knowledge are utilized during
reasoning.
</bodyText>
<subsectionHeader confidence="0.908186">
2.1 CDCL
</subsectionHeader>
<bodyText confidence="0.99959">
CDCL is used to represent collective-distributive
readings, constraints and axioms for reasoning.
There are three types of CDCL clauses as in (4),
and I will explain them as I proceed4.
</bodyText>
<listItem confidence="0.997536333333333">
(4) Core clause: (1 ((5) a0 4 al))
Number-of clause: (number-of al ?q:num)
Number comparison clause: (&lt;= ?q:num 1)
</listItem>
<subsectionHeader confidence="0.971943">
2.1.1 Expressing Collective and Distributive
Readings in CDCL
</subsectionHeader>
<bodyText confidence="0.908645">
CDCL is used to express collective and distributive
readings. Below, a&apos;s are example sentences, b&apos;s are
the most plausible readings of the sentences, and c&apos;s
are representations of b&apos;s in CDCL.
</bodyText>
<listItem confidence="0.99806025">
(5) a. &amp;quot;5 students ate 4 slices of pizza.&amp;quot;
b. Each of the 5 students ate 4 slices of pizza
one at a time.
c. (eat a0 al): (5 (1 a0 4 al))
</listItem>
<footnote confidence="0.970164">
3CDCL stands for &amp;quot;Collective-Distributive Constraint
Language&amp;quot;.
4Though not described in this paper, CDCL has been ex-
tended to deal with sentences with explicit quantifiers as in
&amp;quot;Every student ate 4 slices of pizza&amp;quot; and sentences with n-ary
predicates as in &amp;quot;2 companies donated 3 PC&apos;s to 5 schools&amp;quot;.
For example:
</footnote>
<listItem confidence="0.963853">
(i) (eat a0 al): (every (1 a0 --+ 4 al))
(ii) (donate a0 al a2): (2 (1 a0 (5 (1 a2 —■ (3) al))))
</listItem>
<bodyText confidence="0.5341595">
See Aone [2] for details of CDCL expressed in a context-free
grammar.
</bodyText>
<page confidence="0.980314">
2
</page>
<bodyText confidence="0.722251285714286">
(6) a. &amp;quot;5 dogs had (a litter of) 4 puppies.&amp;quot;
b. Each of the 5 mother dogs delivered a litter
of 4 puppies.
c. (deliver-offspring a0 al): (5 (1 a0 —+ (4) al))
may differ from student to student. Thus, anynum0
represents any positive integer which can vary with
the value of a0.
</bodyText>
<listItem confidence="0.9446808">
2.1.2 Constraints in CDCL
(7) a. &amp;quot;5 alarms were installed in 6 buildings.&amp;quot;
b. Each of the 6 buildings was installed with 5
alarms one at a time.
c. (installed-in a0 al): (6 (1 al 5 a0))
</listItem>
<bodyText confidence="0.9993715">
First, consider (5c). The representation should
capture three pieces of information: scope relations,
distributive-collective distinctions, and numerical re-
lations between objects denoted by NP arguments.
In CDCL, a0 and al signify the arguments of a pred-
icate, e.g. (eat a0 al). The scope relation is repre-
sented by the relative position of those arguments.
That is, the argument on the left hand side of an ar-
row takes wide scope over the one on the right hand
side (cf. (5) vs. (7)). The numerical relation such as
&amp;quot;there is an eating relation from EACH student to 4
slices of pizza&amp;quot; is represented by the numbers before
each argument. The number outside the parenthe-
ses indicates how many instances of such a numerical
relation there are. Thus, (5c) says there are five in-
stances of one-to-four relation from students to slices
of pizza. CDCL is designed to be isomorphic to a di-
agram representation as in Figure 2.
</bodyText>
<figure confidence="0.6004252">
—p s s
\-
\- \-
S = a student
p = a slice of pizza
</figure>
<figureCaption confidence="0.989969">
Figure 2: &amp;quot;5 students ate 4 slices of pizza.&amp;quot;
</figureCaption>
<bodyText confidence="0.9999388">
As for the collective-distributive information in
CDCL, it was implicitly assumed in (5c) that both
arguments were read DISTRIBUTIVELY. To mark that
an argument is read COLLECTIVELY, a number be-
fore an argument is written in parentheses where the
number indicates cardinality, as in (6c).
There are two additional symbols, anynum and
anyset for representing cumulative readings. The
cumulative reading of (3) is represented in CDCL
as follows.
</bodyText>
<equation confidence="0.498368">
(8) (500 (1 a0 —+ anynum0 al)) icz
(1200 (1 al anynuml a0))
</equation>
<bodyText confidence="0.993502692307692">
In (8), the situation is one in which each student (a0)
ate a certain number of pizza slices, and the number
CDCL is also used to express constraints. Each pred-
icate, defined in the knowledge base, has its associ-
ated constraints that reflect our &amp;quot;common sense&amp;quot;.
Thus, constraints are domain-dependent. There
are two kinds of constraints: type constraints (i.e.
constraints on whether the arguments should be read
collectively or distributively) and numerical con-
straints (i.e. constraints on numerical relations be-
tween arguments of predicates.) There are 6 type
constraints (Cl - C6) and 6 numerical constraints
(C7 - C12) as in Figure 3.
</bodyText>
<figure confidence="0.422750458333333">
Cl. (?p:num (1 ?a:arg --■ ?q:num ?b:arg))
:* inconsistent
&amp;quot;Both arguments are distributive.&amp;quot;
C2. (1 (?p:set ?a:arg ?q:set ?b:arg))
inconsistent
&amp;quot;Both arguments are collective.&amp;quot;
C3. (?p:num (1 a0 ?r:set al)) inconsistent
C4. (1 (?q:set al 7r:num a0)) inconsistent
&amp;quot;1st argument distributive and 2nd collective.&amp;quot;
C5. (1 (?p:set a0 ?q:num al)) inconsistent
C6. (?p:num (1 al ?q:set a0)) inconsistent
&amp;quot;1st argument collective and 2nd distributive.&amp;quot;
C7. (?p:num (1 ?a:arg ?q:num ?b:arg))
(&lt;= ?q:num ?nnum)
C8. (?p:num (1 ?a:arg ?q:num ?b:arg))
(&lt;= ?r:num ?q:num)
C9. (?p:num (1 a0 -+ 1 al)) :* inconsistent
&amp;quot;A relation from a0 to al is a function.&amp;quot;
C10. (?p:num (1 al 1 a0)) inconsistent
&amp;quot;A relation from al to a0 is a function.&amp;quot;
Cll. (1 (?p:set a0 1 al)) inconsistent
&amp;quot;Like C9, the domain is a set of sets.&amp;quot;
C12. (1 (?p:set al --0 1 a0)) inconsistent
&amp;quot;Like C10, the domain is a set of sets.&amp;quot;
</figure>
<figureCaption confidence="0.999109">
Figure 3: Constraints
</figureCaption>
<bodyText confidence="0.999736222222222">
Predicate constraints are represented as rules.
Those except C7 and C8 are represented as &amp;quot;anti-
rules&amp;quot;. That is, if a reading does not meet a con-
straint in the antecedent, the reading is considered
inconsistent. C7 and C8 are ordinary rules in that
if they succeed, the consequents are asserted and if
they fail, nothing happens.
The notation needs some explanation. Any sym-
bol with a ?-prefix is a variable. There are 4 variable
</bodyText>
<table confidence="0.9808715">
—p s —p
\- P
\-
\- \-
</table>
<page confidence="0.994545">
3
</page>
<bodyText confidence="0.997618461538462">
types, which can be specified after the colon of each
variable:
(9) ?a:arg argument type (e.g. a0, al, etc.)
?b:num positive integer type
?c:set non-empty set type
?d:n-s either num type or set type
If an argument type variable is preceded by a set
type variable, the argument should be read collec-
tively while if an argument type variable is preceded
by a number type variable, it should be read dis-
tributively.
To explain type constraints, look at sentence (6).
The predicate (deliver-offspring a0 al) requires its
first argument to be distributive and its second to
be collective, since delivering offspring is an individ-
ual activity but offspring come in a group. So, the
predicate is associated with constraints C3 and C4.
As for constraints on numerical relations between
arguments of a predicate, there are four useful con-
straints (C9 - C12), i.e. constraints that a given re-
lation must be a FUNCTION. For example, the pred-
icate deliver-offspring in (6) has a constraint of a
biological nature: offspring have one and only one
mother. Therefore, the relation from al (i.e. off-
spring) to a0 (i.e. mothers) is a function whose do-
main is a set of sets. Thus, the predicate is associ-
ated with C12. Another example is (7). This time,
the predicate (installed-in a0 al) has a constraint of
a physical nature: one and the same object cannot
be installed in greater than one place at the same
time. Thus, the relation from a0 (i.e. alarms) to al
(i.e. buildings) is a many-to-one function. The pred-
icate is therefore associated with C9.
In addition, more specific numerical constraints
are defined for specific domains. For example, the
constraint &amp;quot;each client machine (al) has at most
one diskserver (a0)&amp;quot; is expressed as in (10), given
(disk-used-by a0 al). It is an instance of a general
constraint C7.
</bodyText>
<equation confidence="0.820410333333333">
(10) (?p:num (1 al ?q:num a0))
(&lt;= ?q:num 1)
2.1.3 Axioms in CDCL
</equation>
<bodyText confidence="0.999724428571429">
While constraints are associated only with particular
predicates, axioms hold regardless of predicates (i.e.
are domain-independent). There are two kinds
of axioms as in Figure 4. The first two are con-
straint axioms, i.e. axioms about predicate con-
straints. Constraint axioms derive more constraints
if a predicate is associated with certain constraints.
</bodyText>
<table confidence="0.996241055555556">
CAL (?m:num (1 ?a:arg 1 ?b:arg))
(number-of ?a:arg ?m:num) Az
(number-of ?b:arg ?n:num) Sz
((= ?n:num ?m:num)
CA2. (?1:num (?s:set ?a:arg 1 ?b:arg))
(number-of ?a:arg ?m:num) 8z
(number-of ?b:arg ?n:num) 8z
(&lt;= ?n:num ?m:num)
RA1. (?m:num (1 ?a:arg ?y:n-s ?b:arg))
(number-of ?a:arg ?m:num)
RA2. (?m:num (1 ?a:arg --+ ?y:num ?b:arg))
(&lt;= ?y:num ?z:num)
(number-of ?b:arg ?n:num) 8z
(&lt;= ?n:num (* ?m:num ?z:num))
RA3. (?m:num (1 ?a:arg ?y:num ?b:arg))
(&lt;= ?z:num ?y:num)
(number-of ?b:arg ?n:num) Sz
(&lt;= ?z:num ?n:num)
</table>
<figureCaption confidence="0.996293">
Figure 4: Axioms
</figureCaption>
<bodyText confidence="0.9998085">
The others are reading axioms. They are ax-
ioms about certain assertions representing particu-
lar readings. Reading axioms derive more assertions
from existing assertions.
The constraint axiom CA1 derives an additional
numerical constraint. It says that if a relation is a
function, the number of the objects in the range is
less than or equal to the number of the objects in the
domain. This axiom applies when constraints C9 or
C10 is present. For example:
</bodyText>
<equation confidence="0.99422125">
(11) C9. (?p:num (1 a0 1 al))
CAL (?m:num (1 ?a:arg 1 ?b:arg))
(number-of ?a:arg ?m:num) Sz
(number-of ?b:arg ?n:num) lz
(&lt;= ?n:num ?m:num)
(number-of a0 ?m:num)
(number-of al ?n:num)
(&lt;= ?n:num ?m:num)
</equation>
<bodyText confidence="0.9999225">
The constraint axiom CA2 is similar to CAI except
that the domain is a set of sets.
The reading axiom RA1 asserts the number of all
objects in the domain of a relation. For example:
</bodyText>
<equation confidence="0.995734">
(12) Al. (5 (1 a0 --.. 6 al))
RA 1. (?m:num (1 ?a:arg ?y:n-s ?b:arg))
(number-of ?a:arg ?m:num)
(number-of a0 5)
</equation>
<page confidence="0.958337">
4
</page>
<bodyText confidence="0.999132">
Given an assertion Al, RA1 asserts that the number
of objects in the domain is 5.
The reading axiom RA2 is for a relation where
each object in the domain is related to less than
or equal to n objects in the range. In such a case,
the number of the objects in the range is less than
or equal to the number of objects in the domain
multiplied by n. For example:
</bodyText>
<equation confidence="0.9916505">
(13) A2. (5 (1 a0 ?x:num al))
&amp; (&lt;= ?x:num 2)
RA2. (?m:num (1 ?a:arg ?y:num ?b:arg))
&amp; (&lt;= ?y:num ?z:num)
(number-of ?b:arg ?n:num) &amp;
(&lt;= ?n:num (s ?m:num ?z:num))
(number-of al ?n:num)
(&lt;= ?n:num (* 5 2))
</equation>
<bodyText confidence="0.999691166666667">
The last axiom RA3 is similar to RA2.
These axioms are necessary to reason about con-
sistency of cumulative readings when numerical con-
straints are associated with the predicates. For ex-
ample, given &amp;quot;5 alarms were installed in 6 buildings&amp;quot;,
intuitively we eliminate its cumulative reading be-
cause the number of buildings is more than the num-
ber of alarms. I claim that behind this intuition is a
calculation and comparison of the number of build-
ings and the number of alarms given what we know
about &amp;quot;being installed in&amp;quot;. The constraint axioms
above are intended to simulate how humans make
such comparisons between two groups of objects re-
lated by a predicate that has a numerical constraint.
The reading axioms, on the other hand, are intended
to simulate how we do such calculations of the num-
ber of objects from what we know about the reading
(cf. 2.2.2).
</bodyText>
<subsectionHeader confidence="0.998437">
2.2 Model-Based Reasoner
</subsectionHeader>
<bodyText confidence="0.99982825">
In this section, I describe how the reasoner per-
forms disambiguation. But first I will describe spe-
cial &amp;quot;unification&amp;quot; which is the basic operation of the
reasoner5.
</bodyText>
<subsectionHeader confidence="0.586752">
2.2.1 Unification
</subsectionHeader>
<bodyText confidence="0.5156376">
&amp;quot;Unification&amp;quot; is used to unify CDCL clauses during
the reasoning process. However, it is not standard
unification. It consists of three sequential matching
operations: Syntax Match, ARG Match, and Value
Match. First, Syntax Match tests if the syntax of
</bodyText>
<footnote confidence="0.637675666666667">
5The reasoner has been implemented in Common Lisp.
Unification and forward chaining rule codes are based on
Ableson and Sussman [1] and Winston and Horn [19].
</footnote>
<bodyText confidence="0.790455777777778">
two expressions matches. The syntax of two expres-
sions matches when they belong to the same type of
CDCL clauses (cf. (4)). If Syntax Match succeeds,
ARG Match tests if the argument constants (i.e. a0,
al) in the two expressions match. If this operation is
successful, Value Match is performed. There are two
ways Value Match fails. First, it fails when types do
not match. For example, (14a) fails to unify with
(14b) because ?r:set does not match the integer 4.
</bodyText>
<listItem confidence="0.5849355">
(14) a. (?p:num (?q:num a0 ?r:set al))
b. (5 (1 a0 4 al))
</listItem>
<bodyText confidence="0.985351">
The second way Value Match fails is two values of
the same type are simply not the same.
</bodyText>
<listItem confidence="0.9394875">
(15) a. (1 (?p:set al —0. 1 a0))
b. (1 ((4) al --+ 5 aO))
</listItem>
<bodyText confidence="0.5590182">
Unification fails only when the first and second
operations succeed and the third one fails, and uni-
fication succeeds only when all the three operations
succeed. Otherwise, unification neither succeeds nor
fails.
</bodyText>
<subsubsectionHeader confidence="0.599982">
2.2.2 Inferences Using A Model
</subsubsectionHeader>
<bodyText confidence="0.999724388888889">
Each reading (i.e. a hypothesis) generated by the se-
mantics module is stored in what I call a reading
record (RR). Initially, it just stores assertions that
represent the reading. As reasoning proceeds, more
information is added to it. When the RR is updated
and inconsistency arises, the RR is marked as incon-
sistent and the hypothesis is filtered out.
The reasoner uses a model consisting of four
kinds of knowledge. Inferences that use these four
(namely Predicate-Constraint inference, Constraint-
Axiom inference, Reading-Axiom inference, and the
Contradiction Checker) are controlled as in Figure
5.
First, Predicate-Constraint inference tests if each
hypothesis satisfies predicate constraints. This is
done by unifying each CDCL clause in the hypoth-
esis with predicate constraints. For example, take a
type constraint Cl and a hypothesis Hl.
</bodyText>
<listItem confidence="0.704404">
(16) Hl. (eat a0 al): (5 (1 a0 (4) al))
</listItem>
<bodyText confidence="0.868185625">
Cl. (?p:num (1 ?a:arg ?q:num ?b:arg))
inconsistent
inconsistent
When a predicate constraint is an anti-rule like Cl,
a hypothesis is filtered out if it fails to unify with
the constraint. When a predicate constraint is a rule
like C7, the consequent is asserted into the RR if the
hypothesis successfully unifies with the antecedent.
</bodyText>
<page confidence="0.910814">
5
</page>
<figure confidence="0.9351509">
RR1 RR2 RRn
Predl Predl Predl
Pred2
constraint:
C3,C4,C12
Predl
constraint:
Cl,C10
!Constraint Axioms&apos;
Reading Axioms
</figure>
<figureCaption confidence="0.999914">
Figure 5: Control Structure
</figureCaption>
<bodyText confidence="0.999573217391304">
Second, Constraint-Axiom inference derives addi-
tional CONSTRAINTS by unifying antecedents of con-
straint axioms with predicate constraints. If the uni-
fication is successful, the consequent is stored in each
RR (cf. (11)).
Third, Reading-Axiom inference derives more AS-
SERTIONS by unifying reading axioms with assertions
in each RR (cf. (12) and (13)).
While these three inferences are performed, the
fourth kind, the Contradiction Checker, constantly
monitors consistency of each RR. Each RR contains
a consistency database. Every time new infor-
mation is derived through any other inference, the
Contradiction Checker updates this database. If, at
any point, the Contradiction Checker finds the new
information inconsistent by itself or with other infor-
mation in the database, the RR that contains this
database is filtered out.
For example, take the cumulative reading of (7a),
which is implausible because there should be at
least 6 alarms even when each building has only one
alarm. The reading is represented in CDCL as fol-
lows.
</bodyText>
<equation confidence="0.8472385">
(17) (5 (1 a0 anynum0 al)) &amp;
(6 (1 al anynuml a0))
</equation>
<bodyText confidence="0.887030078947368">
The Contradiction Checker has simple mathematical
knowledge and works as follows. Initially, the con-
sistency database records that the upper and lower
bounds on the number of objects denoted by each
argument are plus infinity and zero respectively.
(18) Number-of-a0 [0 +inf]
Number-of-al [0 +inf]
Constraint NIL
Consistent?
Then, when the constraint axiom CA1 applies to the
predicate constraint C9 associated with installed-in
(cf. (11)), a new numerical constraint &amp;quot;the number
of buildings (al) should be less than or equal to the
number of alarms (a0)&amp;quot; is added to the database.
(19) Number-of-a0 [0 +inf.]
Number-of-al [0 +inf]
Constraint (&lt;= al a0)
Consistent?
Now, the reading axiom RA1 applies to the first
clause of (17) and adds an assertion (number-of a0
5) to the database (cf. (12)). The database is up-
dated so that both upper and lower bounds on a0
are 5. Also, because of the constraint (&lt;= al a0),
the upper bound on al is updated to 5.
(20) Number-of-a0 [5 5]
Number-of-al [0 5]
Constraint (&lt;= al a0)
Consistent?
Finally, RA1 applies to the second clause of (17) and
derives (number-of al 6). However, the Contradic-
tion Checker detects that this assertion is inconsis-
tent with the information in the database, i.e. the
number of al must be at most 5. Thus, the cumula-
tive reading is filtered out.
(21) Number-of-a0 [5 5]
Number-of-al [0 5] =[66]
Constraint (&lt;= al a0)
Consistent? NIL
</bodyText>
<subsectionHeader confidence="0.409991">
2.2.3 Example
</subsectionHeader>
<bodyText confidence="0.96972875">
I illustrate how the reasoner disambiguates among
possible collective and distributive readings of a sen-
tence. The sentence (7a) &amp;quot;5 alarms were installed in
6 buildings&amp;quot; generates 7 hypotheses as in (22).
</bodyText>
<page confidence="0.998491">
6
</page>
<note confidence="0.898347375">
(22) R1 (5 (1 a0 6 al))
R2 (1 ((5) a0 —* 6 al))
R3 (5 (1 a0 (6) al))
R4 (6 (1 al 5 a0))
R5 (1 ((6) al 5 a0))
R6 (6 (1 al (5) a0))
R7 (5 (1 a0 anynum0 al)) &amp;
(6 (1 al anynuml a0))
</note>
<sectionHeader confidence="0.99677" genericHeader="evaluation">
Acknowledgments
</sectionHeader>
<bodyText confidence="0.76198264">
I would like to thank Prof. Manfred Krifka and Prof.
Benjamin Kuipers for their useful comments. The
prototype of the reasoner was originally built using
Algernon (cf. Crawford [3], Crawford and Kuipers
[4]). Many thanks go to Dr. James Crawford, who
gave me much useful help and advice.
The predicate (be-installed a0 al) is associated with
two constraints Cl and C9. Predicate-Constraint
inference, using the type constraint Cl (i.e. both ar-
guments should be read distributively), filters out [1]
R2, R3, R5, and R6. The numerical constraint, C9,
requires that the relation from alarms to buildings
be a function. This eliminates R1, which says that
each alarm was installed in 6 buildings. The cumu-
lative reading R7 is filtered out by the other three
inferences, as described in section 2.2.2. Thus, only
R4 is consistent, which is what we want.
[2]
Harold Abelson and Gerald Sussman. Structure
and Interpretation of Computer Programs. The
MIT Press, Cambridge, Massachusetts, 1985.
Chinatsu Aone. Treatment of Plurals and
Collective-Distributive Ambiguity in Natural
Language Understanding. PhD thesis, The Uni-
versity of Texas at Austin, 1991.
</bodyText>
<sectionHeader confidence="0.767059" genericHeader="conclusions">
References
3 Conclusion
</sectionHeader>
<bodyText confidence="0.999850483870968">
The work described in this paper improves upon
previous works on collective-distributive ambiguity
(cf. Scha and Stallard [17], Gardiner et al. [7]),
since they do not fully explore the necessary reason-
ing. I believe that the reasoning method described
in this paper is general enough to solve collective-
distributive problems because 1) any special con-
straints can be added as new predicates are added
to the KB, and 2) intuitively simple reasoning to
solve numerical problems is done by using domain-
independent axioms.
However, the current reasoning capability should
be extended further to include different kinds of
knowledge. For example, while the cumulative read-
ings of &amp;quot;5 alarms were installed in 6 building&amp;quot; is
implausible and is successfully filtered out by the
reasoner, that of &amp;quot;5 students ate 4 slices of pizza&amp;quot;
is less implausible because a slice of pizza can be
shared by 2 students. The difference between the
two cases is that an alarm is not divisible but a slice
of pizza is. Thus knowledge about divisibility of ob-
jects must be exploited. Further, if an object is divis-
ible, knowledge about its &amp;quot;normal size&amp;quot; with respect
to the predicate must be available with some prob-
ability. For example, the cumulative reading of &amp;quot;5
students ate 4 large pizzas&amp;quot; is very plausible because
a large pizza is UNLIKELY to be a normal size for an
individual to eat. On the other hand, the cumula-
tive reading of &amp;quot;5 students ate 4 slices of pizza&amp;quot; is
less plausible because a slice of pizza is more LIKELY
to be a normal size for an individual consumption.
</bodyText>
<reference confidence="0.999818655172414">
[3] James Crawford. Access-Limited Logic - A Lan-
guage for Knowledge Representation. PhD the-
sis, The University of Texas at Austin, 1990.
[4] James Crawford and Benjamin Kuipers. To-
wards a theory of access-limited logic for knowl-
edge representation. In Proceedings of the
First International Conference on Principles of
Knowledge Representation and Reasoning, Los
Altos, California, 1989. Morgan Kaufmann.
[5] Randall Davis and Walter Hamscher. Model-
based reasoning: troubleshooting. In H. E.
Shrobe, editor, Exploring Artificial Intelligence.
Morgan Kaufmann, Los Altos, California, 1988.
[6] Pamela Fink and John Lusth. A general expert
system design for diagnostic problem solving.
IEEE Transactions on Systems, Man, and Cy-
bernetics, 17(3), 1987.
[7] David Gardiner, Bosco Tjan, and James Slagle.
Extended conceptual structures notation. Tech-
nical Report TR 89-88, Department of Com-
puter Science, University of Minnesota, Min-
neapolis, Minnesota, 1989.
[8] Barbara Grosz, Douglas Appelt, Paul Martin,
and Fernando Pereira. Team: An experiment
in the design of transportable natural-language
interfaces. Artificial Intelligence, 32, 1987.
[9] Irene Heim. The Semantics of Definite and In-
definite Noun Phrases. PhD thesis, University
of Massachusetts at Amherst, 1982.
</reference>
<page confidence="0.9901">
7
</page>
<reference confidence="0.999935825">
[10] Hans Kamp. A theory of truth and semantic
representation. In Groenendijk et al., editor,
Truth, Interpretation, and Information. Foris,
1981.
[11] Manfred, Krifka. Nominal reference and tempo-
ral constitution: Towards a semantics of quan-
tity. In Proceedings of the Sixth Amsterdam Col-
loquium, pages 153-173, University of Amster-
dam, Institute for Language, Logic and Infor-
mation, 1987.
[12] Godehard Link. The logical analysis of plurals
and mass terms: Lattice-theoretical approach.
In Rainer Bauerle, Christoph Schwarze, and
Arnim von Stechow, editors, Meaning, Use, and
Interpretations of Language. de Gruyter, 1983.
[13] Godehard Link. Plural. In Dieter Wunderlich
and Arnim von Stechow, editors, To appear in:
Handbook of Semantics. 1984.
[14] Godehard Link. Generalized quantifiers and
plurals. In P. Gaerdenfors, editor, General-
ized Quantifiers: Linguistics and Logical Ap-
proaches. Reidel, 1987.
[15] Craige Roberts. Modal Subordina-
tion, Anaphora, and Distributivity. PhD thesis,
University of Massachusetts at Amherst, 1987.
[16] Remko Scha. Distributive, collective, and
cumulative quantification. In Janssen and
Stokhof, editors, Truth, Interpretation and In-
formation. Foris, 1984.
[17] Remko Scha and David Stallard. Multi-level
plural and distributivity. In Proceedings of 26th
Annual Meeting of the ACL, 1988.
[18] Reid Simmons and Randall Davis. Generate,
test and debug: Combining associational rules
and causal models. In Proceedings of the Tenth
International Joint Conference on Artificial In-
telligence, Los Altos, California, 1987.
[19] Patrick Winston and Berthold Horn. LISP
3rd Edition. Addison-Wesley, Reading, Mas-
sachusetts, 1989.
</reference>
<page confidence="0.998494">
8
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.000001">
<title confidence="0.9677655">RESOLUTION OF COLLECTIVE-DISTRIBUTIVE AMBIGUITY USING MODEL-BASED REASONING</title>
<author confidence="0.806158">Chinatsu Aone</author>
<affiliation confidence="0.842157">MCC</affiliation>
<address confidence="0.987121">3500 West Balcones Center Dr. Austin, TX 78759</address>
<email confidence="0.999627">aone@mcc.com</email>
<abstract confidence="0.995345244988864">I present a semantic analysis of collectivedistributive ambiguity, and resolution of such ambiguity by model-based reasoning. This approach goes beyond Scha and Stallard [17], whose reasoning capability was limited to checking semantic types. My semantic analysis is based on Link [14, 13] and Roberts [15], where distributivity comes uniformly from a quantificational operator, either explicit (e.g. implicit (e.g. the D operator). I view the semantics module of the natural language system as a hypothesis generator and the reasoner in the pragmatics module as a hypothesis filter (cf. Simmons and Davis [18]). The reasoner utilizes a model consisting of domain-dependent constraints and domain-independent axioms for disambiguation. There are two kinds of constraints, type constraints and numerical constraints, and they are associated with predicates in the knowledge base. Whenever additional information is derived from the model, the Contradiction Checker is invoked to detect any contradiction in a hypothesis using simple mathematical knowledge. CDCL (Collective-Distributive Constraint Language) is used to represent hypotheses, constraints, and axioms in a way isomorphic to diagram representations of collective-distributive ambiguity. 1 Semantics of Collective- Distributive Ambiguity Collective-distributive ambiguity can be illustrated by the following sentence. (1) Two students moved a desk upstairs. means either that two students moved one desk (a collective reading) or that each The work described in this paper was done as a part of the author&apos;s doctoral dissertation at The University of Texas at Austin. them moved a desk distributive Following Link [14, 13] and Roberts distributivity comes from either an explicit quantifioperator like an implicit distributive called the The operator was motivated by the equivalence in the semantics of the following sentences. a. in this class lifted the piano. Students in this class the piano. c. Students in this class lifted the piano. (the distributive reading) the distributive readings of (1) result from applying the D operator to the subjects. Now, look at another sentence &amp;quot;Five students ate slices of pizza.&amp;quot; It has 8 because the D operator may apply to each of the two of the two NPs can take scope each other. Thus, 2 x 2 x 2 = I have extended Link&apos;s and Roberts&apos;s theories to quantify over events Discourse Representation Theory (cf. Kamp Heim [9], Aone [2]) so that these readings can be systematically generated and represented in the semanmodule. However, the most is the &amp;quot;distributive-distributive reading&amp;quot;, where each of the five students ate four slices one at a time, as represented in a discourse representation structure in Figure Such plausibility comes partly the lexical semantics of our &amp;quot;common sense&amp;quot;, we know that &amp;quot;eating&amp;quot; is an individual activity unlike &amp;quot;moving a desk&amp;quot;, which can be done either individually or in a group. However, such plausibility should not be a part of the semantic theory, but should be dealt with in pragmatics where world knowledge is available. In section 2, I&apos;ll identify the &apos;Actually the two collective-collective readings are equivalent, so there are 7 distinct readings. x&apos; x) says &amp;quot;x&apos; is an atomic individual-part of x&amp;quot; (cf. Link [12]), and CU, i.e. &amp;quot;Count-Unit&amp;quot;, stands for a natural measure unit for students (cf. Krifka [11]). 1 Figure 1: DRS for &amp;quot;Five students ate four slices of pizza&amp;quot; (student x) (amount x 5) (measure x CU) x&apos; (i-part x&apos; x) (pizza y) y (measure y slice) Y&apos; (i-part y&apos; y) e x&apos; y&apos;) necessary knowledge and develop a reasoner, which goes beyond Scha and Stallard [17]. is a special reading called a reading (cf. Scha [16]). 500 ate 1200 slices of pizza. The cumulative reading of (3) says &amp;quot;there were 500 students and each student ate some slices of pizza, totaling 1200 slices.&amp;quot; The semantics of a cumulative is is represented as a collective-collective reading at the semantic level (cf. Link [13], Roberts [15], Aone [2]). This means that a cumulative reading should have a more specific representation at the pragmatics level for inferencing. Reasoning about cumulative readings is particularly and discuss it in detail. 2 Model-Based Reasoning for Disambiguation Although scope ambiguity has been worked on by researchers (e.g. Grosz [8]), the main problem addressed has been how to generate all the scope choices and order them according to some heuristics. This approach might be sufficient as far as scope ambiguity goes. However, collectivedistributive ambiguity subsumes scope ambiguity and a heuristics strategy would not be a strong method. I argue that the reason why some of the readings are implausible (and even do not occur to people) is because we have access to domain- (e.g. constraints on predialong with mathematical knowledge). developed a reasoner based on the theory of model-based reasoning (cf. Simmons and Davis [18], Fink and Lusth [6], Davis and Hamscher [5]) for collective-distributive ambiguity resolution. The model that the reasoner uses consists of four kinds of knowledge, namely predicate constraints, two types of axioms, and simmathematical knowledge. First, discuss the language Then, discuss how these four kinds of knowledge are utilized during reasoning. 2.1 CDCL used to represent collective-distributive readings, constraints and axioms for reasoning. There are three types of CDCL clauses as in (4), explain them as (4) Core clause: (1 ((5) a0 4 al)) Number-of clause: (number-of al ?q:num) Number comparison clause: (&lt;= ?q:num 1) 2.1.1 Expressing Collective and Distributive Readings in CDCL used to express collective and distributive readings. Below, a&apos;s are example sentences, b&apos;s are the most plausible readings of the sentences, and c&apos;s are representations of b&apos;s in CDCL. (5) a. &amp;quot;5 students ate 4 slices of pizza.&amp;quot; b. Each of the 5 students ate 4 slices of pizza one at a time. c. (eat a0 al): (5 (1 a0 4 al)) stands for &amp;quot;Collective-Distributive Constraint Language&amp;quot;. not described in this paper, CDCL has been extended to deal with sentences with explicit quantifiers as in student ate of pizza&amp;quot; and sentences with n-ary predicates as in &amp;quot;2 companies donated 3 PC&apos;s to 5 schools&amp;quot;. For example: (eat a0 al): (every (1 a0 --+ (ii) (donate a0 al a2): (2 (1 a0 (5 (1 a2 —■ (3) al)))) See Aone [2] for details of CDCL expressed in a context-free grammar. 2 (6) a. &amp;quot;5 dogs had (a litter of) 4 puppies.&amp;quot; b. Each of the 5 mother dogs delivered a litter of 4 puppies. c. (deliver-offspring a0 al): (5 (1 a0 —+ (4) al)) differ from student to student. Thus, represents any positive integer which can vary with the value of a0. 2.1.2 Constraints in CDCL (7) a. &amp;quot;5 alarms were installed in 6 buildings.&amp;quot; b. Each of the 6 buildings was installed with 5 alarms one at a time. c. (installed-in a0 al): (6 (1 al 5 a0)) First, consider (5c). The representation should capture three pieces of information: scope relations, distributive-collective distinctions, and numerical relations between objects denoted by NP arguments. In CDCL, a0 and al signify the arguments of a predicate, e.g. (eat a0 al). The scope relation is represented by the relative position of those arguments. That is, the argument on the left hand side of an arrow takes wide scope over the one on the right hand side (cf. (5) vs. (7)). The numerical relation such as is an eating relation from to 4 slices of pizza&amp;quot; is represented by the numbers before each argument. The number outside the parentheses indicates how many instances of such a numerical relation there are. Thus, (5c) says there are five instances of one-to-four relation from students to slices of pizza. CDCL is designed to be isomorphic to a diagram representation as in Figure 2. —p s s \- \- \- S = a student p = a slice of pizza Figure 2: &amp;quot;5 students ate 4 slices of pizza.&amp;quot; As for the collective-distributive information in CDCL, it was implicitly assumed in (5c) that both were read mark that argument is read number before an argument is written in parentheses where the number indicates cardinality, as in (6c). are two additional symbols, representing cumulative readings. The cumulative reading of (3) is represented in CDCL as follows. (8) (500 (1 a0 —+ anynum0 al)) icz (1200 (1 al anynuml a0)) In (8), the situation is one in which each student (a0) ate a certain number of pizza slices, and the number CDCL is also used to express constraints. Each predicate, defined in the knowledge base, has its associated constraints that reflect our &amp;quot;common sense&amp;quot;. Thus, constraints are domain-dependent. There are two kinds of constraints: type constraints (i.e. constraints on whether the arguments should be read collectively or distributively) and numerical constraints (i.e. constraints on numerical relations between arguments of predicates.) There are 6 type constraints (Cl - C6) and 6 numerical constraints (C7 - C12) as in Figure 3. (?p:num (1 ?a:arg --■ ?b:arg)) &amp;quot;Both arguments are distributive.&amp;quot; C2. (1 (?p:set ?a:arg ?q:set ?b:arg)) inconsistent &amp;quot;Both arguments are collective.&amp;quot; C3. (?p:num (1 a0 ?r:set al)) inconsistent (1 (?q:set 7r:num a0)) inconsistent argument and 2nd C5. (1 (?p:set a0 ?q:num al)) inconsistent (?p:num (1 al a0)) inconsistent &amp;quot;1st argument collective and 2nd distributive.&amp;quot; (?p:num (1 ?a:arg ?b:arg)) (&lt;= ?q:num ?nnum) (?p:num (1 ?q:num ?b:arg)) (&lt;= ?r:num ?q:num) C9. (?p:num (1 a0 -+ 1 al)) :* inconsistent relation from to al is a function.&amp;quot; C10. (?p:num (1 al 1 a0)) inconsistent relation from al to a0 is a Cll. (1 (?p:set a0 1 al)) inconsistent &amp;quot;Like C9, the domain is a set of sets.&amp;quot; C12. (1 (?p:set al --0 1 a0)) inconsistent &amp;quot;Like C10, the domain is a set of sets.&amp;quot; Figure 3: Constraints Predicate constraints are represented as rules. Those except C7 and C8 are represented as &amp;quot;antirules&amp;quot;. That is, if a reading does not meet a constraint in the antecedent, the reading is considered inconsistent. C7 and C8 are ordinary rules in that if they succeed, the consequents are asserted and if they fail, nothing happens. The notation needs some explanation. Any symbol with a ?-prefix is a variable. There are 4 variable s —p \- P \- \- \- 3 types, which can be specified after the colon of each variable: (9) argument type (e.g. a0, al, etc.) ?b:num positive integer type ?c:set non-empty set type ?d:n-s either num type or set type If an argument type variable is preceded by a set type variable, the argument should be read collectively while if an argument type variable is preceded by a number type variable, it should be read distributively. To explain type constraints, look at sentence (6). The predicate (deliver-offspring a0 al) requires its first argument to be distributive and its second to be collective, since delivering offspring is an individual activity but offspring come in a group. So, the predicate is associated with constraints C3 and C4. As for constraints on numerical relations between arguments of a predicate, there are four useful constraints (C9 - C12), i.e. constraints that a given remust be a example, the pred- (6) has a constraint of a biological nature: offspring have one and only one mother. Therefore, the relation from al (i.e. offspring) to a0 (i.e. mothers) is a function whose domain is a set of sets. Thus, the predicate is associated with C12. Another example is (7). This time, the predicate (installed-in a0 al) has a constraint of a physical nature: one and the same object cannot be installed in greater than one place at the same time. Thus, the relation from a0 (i.e. alarms) to al (i.e. buildings) is a many-to-one function. The predicate is therefore associated with C9. In addition, more specific numerical constraints are defined for specific domains. For example, the constraint &amp;quot;each client machine (al) has at most one diskserver (a0)&amp;quot; is expressed as in (10), given (disk-used-by a0 al). It is an instance of a general constraint C7. (10) (?p:num (1 al ?q:num a0)) (&lt;= ?q:num 1) 2.1.3 Axioms in CDCL While constraints are associated only with particular predicates, axioms hold regardless of predicates (i.e. are domain-independent). There are two kinds of axioms as in Figure 4. The first two are constraint axioms, i.e. axioms about predicate constraints. Constraint axioms derive more constraints if a predicate is associated with certain constraints. CAL (?m:num (1 ?a:arg 1 ?b:arg)) (number-of ?a:arg ?m:num) Az (number-of ?b:arg ?n:num) Sz ((= ?n:num ?m:num) CA2. (?1:num (?s:set ?a:arg 1 ?b:arg)) (number-of ?a:arg ?m:num) 8z (number-of ?b:arg ?n:num) 8z (&lt;= ?n:num ?m:num) RA1. (?m:num (1 ?a:arg ?y:n-s ?b:arg)) (number-of ?a:arg ?m:num) RA2. (?m:num (1 ?a:arg --+ ?y:num ?b:arg)) (&lt;= ?y:num ?z:num) (number-of ?b:arg ?n:num) 8z (&lt;= ?n:num (* ?m:num ?z:num)) RA3. (?m:num (1 ?a:arg ?y:num ?b:arg)) (&lt;= ?z:num ?y:num) ?b:arg ?n:num) (&lt;= ?z:num ?n:num) Figure 4: Axioms The others are reading axioms. They are axioms about certain assertions representing particular readings. Reading axioms derive more assertions from existing assertions. The constraint axiom CA1 derives an additional numerical constraint. It says that if a relation is a function, the number of the objects in the range is less than or equal to the number of the objects in the domain. This axiom applies when constraints C9 or C10 is present. For example: (?p:num (1 a0 1 al)) CAL (?m:num (1 ?a:arg 1 ?b:arg)) (number-of ?a:arg ?m:num) Sz (number-of ?b:arg ?n:num) lz (&lt;= ?n:num ?m:num) (number-of a0 ?m:num) (number-of al ?n:num) (&lt;= ?n:num ?m:num) The constraint axiom CA2 is similar to CAI except that the domain is a set of sets. The reading axiom RA1 asserts the number of all objects in the domain of a relation. For example: (5 (1 a0 --.. 6 al)) RA 1. (?m:num (1 ?a:arg ?y:n-s ?b:arg)) (number-of ?a:arg ?m:num) (number-of a0 5) 4 Given an assertion Al, RA1 asserts that the number of objects in the domain is 5. The reading axiom RA2 is for a relation where each object in the domain is related to less than or equal to n objects in the range. In such a case, the number of the objects in the range is less than or equal to the number of objects in the domain by For example: (13) A2. (5 (1 a0 ?x:num al)) &amp; (&lt;= ?x:num 2) RA2. (?m:num (1 ?a:arg ?y:num ?b:arg)) &amp; (&lt;= ?y:num ?z:num) (number-of ?b:arg ?n:num) &amp; (&lt;= ?n:num (s ?m:num ?z:num)) (number-of al ?n:num) (&lt;= ?n:num (* 5 2)) The last axiom RA3 is similar to RA2. These axioms are necessary to reason about consistency of cumulative readings when numerical constraints are associated with the predicates. For example, given &amp;quot;5 alarms were installed in 6 buildings&amp;quot;, intuitively we eliminate its cumulative reading because the number of buildings is more than the number of alarms. I claim that behind this intuition is a calculation and comparison of the number of buildings and the number of alarms given what we know about &amp;quot;being installed in&amp;quot;. The constraint axioms above are intended to simulate how humans make such comparisons between two groups of objects related by a predicate that has a numerical constraint. The reading axioms, on the other hand, are intended to simulate how we do such calculations of the number of objects from what we know about the reading (cf. 2.2.2). Reasoner In this section, I describe how the reasoner performs disambiguation. But first I will describe special &amp;quot;unification&amp;quot; which is the basic operation of the 2.2.1 Unification &amp;quot;Unification&amp;quot; is used to unify CDCL clauses during the reasoning process. However, it is not standard unification. It consists of three sequential matching operations: Syntax Match, ARG Match, and Value Match. First, Syntax Match tests if the syntax of reasoner has been implemented in Common Lisp. Unification and forward chaining rule codes are based on Ableson and Sussman [1] and Winston and Horn [19]. two expressions matches. The syntax of two expressions matches when they belong to the same type of CDCL clauses (cf. (4)). If Syntax Match succeeds, ARG Match tests if the argument constants (i.e. a0, al) in the two expressions match. If this operation is successful, Value Match is performed. There are two ways Value Match fails. First, it fails when types do not match. For example, (14a) fails to unify with (14b) because ?r:set does not match the integer 4. (14) a. (?p:num (?q:num a0 ?r:set al)) b. (5 (1 a0 4 al)) The second way Value Match fails is two values of the same type are simply not the same. a. (1 (?p:set al —0. a0)) (1 al --+ 5 aO)) Unification fails only when the first and second operations succeed and the third one fails, and unification succeeds only when all the three operations succeed. Otherwise, unification neither succeeds nor fails. 2.2.2 Inferences Using A Model Each reading (i.e. a hypothesis) generated by the semodule is stored in what I call a (RR). it just stores assertions that represent the reading. As reasoning proceeds, more information is added to it. When the RR is updated and inconsistency arises, the RR is marked as inconsistent and the hypothesis is filtered out. The reasoner uses a model consisting of four kinds of knowledge. Inferences that use these four (namely Predicate-Constraint inference, Constraint- Axiom inference, Reading-Axiom inference, and the Contradiction Checker) are controlled as in Figure 5. First, Predicate-Constraint inference tests if each hypothesis satisfies predicate constraints. This is done by unifying each CDCL clause in the hypothesis with predicate constraints. For example, take a constraint Cl and a hypothesis Hl. (eat a0 al): (5 a0 Cl. (?p:num (1 ?a:arg ?q:num ?b:arg)) inconsistent inconsistent a predicate constraint is like Cl, a hypothesis is filtered out if it fails to unify with the constraint. When a predicate constraint is a rule like C7, the consequent is asserted into the RR if the hypothesis successfully unifies with the antecedent.</abstract>
<note confidence="0.83203">5 RR1 Predl RR2 Predl RRn Predl Pred2 constraint: C3,C4,C12 Predl constraint: Cl,C10 !Constraint Axioms&apos; Reading Axioms Figure 5: Control Structure</note>
<abstract confidence="0.920005205128205">Second, Constraint-Axiom inference derives addiunifying antecedents of constraint axioms with predicate constraints. If the unification is successful, the consequent is stored in each RR (cf. (11)). Reading-Axiom inference derives more ASunifying reading axioms with assertions in each RR (cf. (12) and (13)). While these three inferences are performed, the fourth kind, the Contradiction Checker, constantly monitors consistency of each RR. Each RR contains a consistency database. Every time new information is derived through any other inference, the Contradiction Checker updates this database. If, at any point, the Contradiction Checker finds the new information inconsistent by itself or with other information in the database, the RR that contains this database is filtered out. For example, take the cumulative reading of (7a), which is implausible because there should be at least 6 alarms even when each building has only one alarm. The reading is represented in CDCL as follows. (17) (5 (1 a0 anynum0 al)) &amp; (6 (1 al anynuml a0)) The Contradiction Checker has simple mathematical knowledge and works as follows. Initially, the consistency database records that the upper and lower bounds on the number of objects denoted by each argument are plus infinity and zero respectively. (18) Number-of-a0 [0 +inf] Number-of-al [0 +inf] Constraint NIL Consistent? Then, when the constraint axiom CA1 applies to the constraint C9 associated with (cf. (11)), a new numerical constraint &amp;quot;the number of buildings (al) should be less than or equal to the number of alarms (a0)&amp;quot; is added to the database.</abstract>
<note confidence="0.895737875">Number-of-a0 [0 Number-of-al [0 +inf] Constraint (&lt;= al a0) Consistent? Now, the reading axiom RA1 applies to the first clause of (17) and adds an assertion (number-of a0 5) to the database (cf. (12)). The database is updated so that both upper and lower bounds on a0 are 5. Also, because of the constraint (&lt;= al a0), the upper bound on al is updated to 5. (20) Number-of-a0 [5 5] Number-of-al [0 5] Constraint (&lt;= al a0) Consistent? Finally, RA1 applies to the second clause of (17) and derives (number-of al 6). However, the Contradic-</note>
<abstract confidence="0.832774230769231">tion Checker detects that this assertion is inconsistent with the information in the database, i.e. the number of al must be at most 5. Thus, the cumulative reading is filtered out. (21) Number-of-a0 [5 5] Number-of-al [0 5] =[66] Constraint (&lt;= al a0) Consistent? NIL 2.2.3 Example I illustrate how the reasoner disambiguates among possible collective and distributive readings of a sentence. The sentence (7a) &amp;quot;5 alarms were installed in 6 buildings&amp;quot; generates 7 hypotheses as in (22).</abstract>
<note confidence="0.912942181818182">6 (22) R1 (5 (1 a0 6 al)) R2 (1 ((5) a0 —* 6 al)) R3 (5 (1 a0 (6) al)) R4 (6 (1 al 5 a0)) R5 (1 ((6) al 5 a0)) R6 (6 (1 al (5) a0)) R7 (5 (1 a0 anynum0 al)) &amp; (6 (1 al anynuml a0)) Acknowledgments I would like to thank Prof. Manfred Krifka and Prof.</note>
<author confidence="0.624927">The</author>
<abstract confidence="0.963424133333333">prototype of the reasoner was originally built using Algernon (cf. Crawford [3], Crawford and Kuipers [4]). Many thanks go to Dr. James Crawford, who gave me much useful help and advice. The predicate (be-installed a0 al) is associated with two constraints Cl and C9. Predicate-Constraint using the type constraint Cl (i.e. both arguments should be read distributively), filters out [1] R2, R3, R5, and R6. The numerical constraint, C9, requires that the relation from alarms to buildings be a function. This eliminates R1, which says that each alarm was installed in 6 buildings. The cumulative reading R7 is filtered out by the other three inferences, as described in section 2.2.2. Thus, only R4 is consistent, which is what we want.</abstract>
<note confidence="0.810431818181818">[2] Abelson and Gerald Sussman. Interpretation of Computer Programs. MIT Press, Cambridge, Massachusetts, 1985. Aone. of Plurals and Collective-Distributive Ambiguity in Natural Understanding. thesis, The University of Texas at Austin, 1991. References 3 Conclusion The work described in this paper improves upon</note>
<abstract confidence="0.992403433333333">previous works on collective-distributive ambiguity Scha and Stallard [17], Gardiner al. since they do not fully explore the necessary reasoning. I believe that the reasoning method described in this paper is general enough to solve collectivedistributive problems because 1) any special constraints can be added as new predicates are added to the KB, and 2) intuitively simple reasoning to solve numerical problems is done by using domainindependent axioms. However, the current reasoning capability should be extended further to include different kinds of knowledge. For example, while the cumulative readings of &amp;quot;5 alarms were installed in 6 building&amp;quot; is implausible and is successfully filtered out by the reasoner, that of &amp;quot;5 students ate 4 slices of pizza&amp;quot; is less implausible because a slice of pizza can be shared by 2 students. The difference between the two cases is that an alarm is not divisible but a slice of pizza is. Thus knowledge about divisibility of objects must be exploited. Further, if an object is divisible, knowledge about its &amp;quot;normal size&amp;quot; with respect to the predicate must be available with some probability. For example, the cumulative reading of &amp;quot;5 students ate 4 large pizzas&amp;quot; is very plausible because large pizza is be a normal size for an individual to eat. On the other hand, the cumulative reading of &amp;quot;5 students ate 4 slices of pizza&amp;quot; is plausible because a slice of pizza is more to be a normal size for an individual consumption.</abstract>
<author confidence="0.835089">A Lan-</author>
<note confidence="0.851571785714286">for Knowledge Representation. thesis, The University of Texas at Austin, 1990. [4] James Crawford and Benjamin Kuipers. Towards a theory of access-limited logic for knowlrepresentation. In of the First International Conference on Principles of Representation and Reasoning, Altos, California, 1989. Morgan Kaufmann. [5] Randall Davis and Walter Hamscher. Modelbased reasoning: troubleshooting. In H. E. editor, Artificial Intelligence. Morgan Kaufmann, Los Altos, California, 1988. [6] Pamela Fink and John Lusth. A general expert system design for diagnostic problem solving. IEEE Transactions on Systems, Man, and Cy- 1987. [7] David Gardiner, Bosco Tjan, and James Slagle. Extended conceptual structures notation. Technical Report TR 89-88, Department of Computer Science, University of Minnesota, Minneapolis, Minnesota, 1989. [8] Barbara Grosz, Douglas Appelt, Paul Martin, and Fernando Pereira. Team: An experiment in the design of transportable natural-language Intelligence, 1987. Irene Heim. Semantics of Definite and In- Noun Phrases. thesis, University of Massachusetts at Amherst, 1982. 7 [10] Hans Kamp. A theory of truth and semantic representation. In Groenendijk et al., editor, Interpretation, and Information. 1981. [11] Manfred, Krifka. Nominal reference and temporal constitution: Towards a semantics of quan- In of the Sixth Amsterdam Col- 153-173, University of Amsterdam, Institute for Language, Logic and Information, 1987. [12] Godehard Link. The logical analysis of plurals and mass terms: Lattice-theoretical approach. In Rainer Bauerle, Christoph Schwarze, and von Stechow, editors, Use, and of Language. Gruyter, 1983. [13] Godehard Link. Plural. In Dieter Wunderlich and Arnim von Stechow, editors, To appear in: of Semantics. [14] Godehard Link. Generalized quantifiers and In P. Gaerdenfors, editor, Generalized Quantifiers: Linguistics and Logical Ap- 1987. Craige Roberts. Anaphora, and Distributivity. thesis, University of Massachusetts at Amherst, 1987. [16] Remko Scha. Distributive, collective, and cumulative quantification. In Janssen and editors, Interpretation and In- 1984. [17] Remko Scha and David Stallard. Multi-level and distributivity. In of 26th Meeting of the ACL, [18] Reid Simmons and Randall Davis. Generate, test and debug: Combining associational rules causal models. In of the Tenth International Joint Conference on Artificial In- Altos, California, 1987. Patrick Winston and Berthold Horn. Edition. Reading, Massachusetts, 1989. 8</note>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>James Crawford</author>
</authors>
<title>Access-Limited Logic - A Language for Knowledge Representation.</title>
<date>1990</date>
<tech>PhD thesis,</tech>
<institution>The University of Texas at Austin,</institution>
<contexts>
<context position="22188" citStr="[3]" startWordPosition="3707" endWordPosition="3707">t? NIL 2.2.3 Example I illustrate how the reasoner disambiguates among possible collective and distributive readings of a sentence. The sentence (7a) &amp;quot;5 alarms were installed in 6 buildings&amp;quot; generates 7 hypotheses as in (22). 6 (22) R1 (5 (1 a0 6 al)) R2 (1 ((5) a0 —* 6 al)) R3 (5 (1 a0 (6) al)) R4 (6 (1 al 5 a0)) R5 (1 ((6) al 5 a0)) R6 (6 (1 al (5) a0)) R7 (5 (1 a0 anynum0 al)) &amp; (6 (1 al anynuml a0)) Acknowledgments I would like to thank Prof. Manfred Krifka and Prof. Benjamin Kuipers for their useful comments. The prototype of the reasoner was originally built using Algernon (cf. Crawford [3], Crawford and Kuipers [4]). Many thanks go to Dr. James Crawford, who gave me much useful help and advice. The predicate (be-installed a0 al) is associated with two constraints Cl and C9. Predicate-Constraint inference, using the type constraint Cl (i.e. both arguments should be read distributively), filters out [1] R2, R3, R5, and R6. The numerical constraint, C9, requires that the relation from alarms to buildings be a function. This eliminates R1, which says that each alarm was installed in 6 buildings. The cumulative reading R7 is filtered out by the other three inferences, as described i</context>
</contexts>
<marker>[3]</marker>
<rawString>James Crawford. Access-Limited Logic - A Language for Knowledge Representation. PhD thesis, The University of Texas at Austin, 1990.</rawString>
</citation>
<citation valid="true">
<authors>
<author>James Crawford</author>
<author>Benjamin Kuipers</author>
</authors>
<title>Towards a theory of access-limited logic for knowledge representation.</title>
<date>1989</date>
<booktitle>In Proceedings of the First International Conference on Principles of Knowledge Representation and Reasoning,</booktitle>
<publisher>Morgan Kaufmann.</publisher>
<location>Los Altos, California,</location>
<contexts>
<context position="22214" citStr="[4]" startWordPosition="3711" endWordPosition="3711">ustrate how the reasoner disambiguates among possible collective and distributive readings of a sentence. The sentence (7a) &amp;quot;5 alarms were installed in 6 buildings&amp;quot; generates 7 hypotheses as in (22). 6 (22) R1 (5 (1 a0 6 al)) R2 (1 ((5) a0 —* 6 al)) R3 (5 (1 a0 (6) al)) R4 (6 (1 al 5 a0)) R5 (1 ((6) al 5 a0)) R6 (6 (1 al (5) a0)) R7 (5 (1 a0 anynum0 al)) &amp; (6 (1 al anynuml a0)) Acknowledgments I would like to thank Prof. Manfred Krifka and Prof. Benjamin Kuipers for their useful comments. The prototype of the reasoner was originally built using Algernon (cf. Crawford [3], Crawford and Kuipers [4]). Many thanks go to Dr. James Crawford, who gave me much useful help and advice. The predicate (be-installed a0 al) is associated with two constraints Cl and C9. Predicate-Constraint inference, using the type constraint Cl (i.e. both arguments should be read distributively), filters out [1] R2, R3, R5, and R6. The numerical constraint, C9, requires that the relation from alarms to buildings be a function. This eliminates R1, which says that each alarm was installed in 6 buildings. The cumulative reading R7 is filtered out by the other three inferences, as described in section 2.2.2. Thus, onl</context>
</contexts>
<marker>[4]</marker>
<rawString>James Crawford and Benjamin Kuipers. Towards a theory of access-limited logic for knowledge representation. In Proceedings of the First International Conference on Principles of Knowledge Representation and Reasoning, Los Altos, California, 1989. Morgan Kaufmann.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Randall Davis</author>
<author>Walter Hamscher</author>
</authors>
<title>Modelbased reasoning: troubleshooting.</title>
<date>1988</date>
<booktitle>Exploring Artificial Intelligence.</booktitle>
<editor>In H. E. Shrobe, editor,</editor>
<publisher>Morgan Kaufmann,</publisher>
<location>Los Altos, California,</location>
<contexts>
<context position="5536" citStr="[5]" startWordPosition="878" endWordPosition="878">stics. This approach might be sufficient as far as scope ambiguity goes. However, collectivedistributive ambiguity subsumes scope ambiguity and a heuristics strategy would not be a strong method. I argue that the reason why some of the readings are implausible (and even do not occur to some people) is because we have access to domaindependent knowledge (e.g. constraints on predicates) along with domain-independent knowledge (e.g. mathematical knowledge). I have developed a reasoner based on the theory of model-based reasoning (cf. Simmons and Davis [18], Fink and Lusth [6], Davis and Hamscher [5]) for collective-distributive ambiguity resolution. The model that the reasoner uses consists of four kinds of knowledge, namely predicate constraints, two types of axioms, and simple mathematical knowledge. First, I will discuss the representation language CDCL3. Then, I will discuss how these four kinds of knowledge are utilized during reasoning. 2.1 CDCL CDCL is used to represent collective-distributive readings, constraints and axioms for reasoning. There are three types of CDCL clauses as in (4), and I will explain them as I proceed4. (4) Core clause: (1 ((5) a0 4 al)) Number-of clause: (</context>
</contexts>
<marker>[5]</marker>
<rawString>Randall Davis and Walter Hamscher. Modelbased reasoning: troubleshooting. In H. E. Shrobe, editor, Exploring Artificial Intelligence. Morgan Kaufmann, Los Altos, California, 1988.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Pamela Fink</author>
<author>John Lusth</author>
</authors>
<title>A general expert system design for diagnostic problem solving.</title>
<date>1987</date>
<journal>IEEE Transactions on Systems, Man, and Cybernetics,</journal>
<volume>17</volume>
<issue>3</issue>
<contexts>
<context position="5512" citStr="[6]" startWordPosition="874" endWordPosition="874"> according to some heuristics. This approach might be sufficient as far as scope ambiguity goes. However, collectivedistributive ambiguity subsumes scope ambiguity and a heuristics strategy would not be a strong method. I argue that the reason why some of the readings are implausible (and even do not occur to some people) is because we have access to domaindependent knowledge (e.g. constraints on predicates) along with domain-independent knowledge (e.g. mathematical knowledge). I have developed a reasoner based on the theory of model-based reasoning (cf. Simmons and Davis [18], Fink and Lusth [6], Davis and Hamscher [5]) for collective-distributive ambiguity resolution. The model that the reasoner uses consists of four kinds of knowledge, namely predicate constraints, two types of axioms, and simple mathematical knowledge. First, I will discuss the representation language CDCL3. Then, I will discuss how these four kinds of knowledge are utilized during reasoning. 2.1 CDCL CDCL is used to represent collective-distributive readings, constraints and axioms for reasoning. There are three types of CDCL clauses as in (4), and I will explain them as I proceed4. (4) Core clause: (1 ((5) a0 4 </context>
</contexts>
<marker>[6]</marker>
<rawString>Pamela Fink and John Lusth. A general expert system design for diagnostic problem solving. IEEE Transactions on Systems, Man, and Cybernetics, 17(3), 1987.</rawString>
</citation>
<citation valid="true">
<authors>
<author>David Gardiner</author>
<author>Bosco Tjan</author>
<author>James Slagle</author>
</authors>
<title>Extended conceptual structures notation.</title>
<date>1989</date>
<tech>Technical Report TR 89-88,</tech>
<institution>Department of Computer Science, University of Minnesota,</institution>
<location>Minneapolis, Minnesota,</location>
<contexts>
<context position="23327" citStr="[7]" startWordPosition="3883" endWordPosition="3883">R7 is filtered out by the other three inferences, as described in section 2.2.2. Thus, only R4 is consistent, which is what we want. [2] Harold Abelson and Gerald Sussman. Structure and Interpretation of Computer Programs. The MIT Press, Cambridge, Massachusetts, 1985. Chinatsu Aone. Treatment of Plurals and Collective-Distributive Ambiguity in Natural Language Understanding. PhD thesis, The University of Texas at Austin, 1991. References 3 Conclusion The work described in this paper improves upon previous works on collective-distributive ambiguity (cf. Scha and Stallard [17], Gardiner et al. [7]), since they do not fully explore the necessary reasoning. I believe that the reasoning method described in this paper is general enough to solve collectivedistributive problems because 1) any special constraints can be added as new predicates are added to the KB, and 2) intuitively simple reasoning to solve numerical problems is done by using domainindependent axioms. However, the current reasoning capability should be extended further to include different kinds of knowledge. For example, while the cumulative readings of &amp;quot;5 alarms were installed in 6 building&amp;quot; is implausible and is successfu</context>
</contexts>
<marker>[7]</marker>
<rawString>David Gardiner, Bosco Tjan, and James Slagle. Extended conceptual structures notation. Technical Report TR 89-88, Department of Computer Science, University of Minnesota, Minneapolis, Minnesota, 1989.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Barbara Grosz</author>
<author>Douglas Appelt</author>
<author>Paul Martin</author>
<author>Fernando Pereira</author>
</authors>
<title>Team: An experiment in the design of transportable natural-language interfaces.</title>
<date>1987</date>
<journal>Artificial Intelligence,</journal>
<volume>32</volume>
<contexts>
<context position="4818" citStr="[8]" startWordPosition="763" endWordPosition="763">re 500 students and each student ate some slices of pizza, totaling 1200 slices.&amp;quot; The semantics of a cumulative reading is UNDERSPECIFIED and is represented as a collective-collective reading at the semantic level (cf. Link [13], Roberts [15], Aone [2]). This means that a cumulative reading should have a more specific representation at the pragmatics level for inferencing. Reasoning about cumulative readings is particularly interesting, and I will discuss it in detail. 2 Model-Based Reasoning for Disambiguation Although scope ambiguity has been worked on by many researchers (e.g. Grosz et al. [8]), the main problem addressed has been how to generate all the scope choices and order them according to some heuristics. This approach might be sufficient as far as scope ambiguity goes. However, collectivedistributive ambiguity subsumes scope ambiguity and a heuristics strategy would not be a strong method. I argue that the reason why some of the readings are implausible (and even do not occur to some people) is because we have access to domaindependent knowledge (e.g. constraints on predicates) along with domain-independent knowledge (e.g. mathematical knowledge). I have developed a reasone</context>
</contexts>
<marker>[8]</marker>
<rawString>Barbara Grosz, Douglas Appelt, Paul Martin, and Fernando Pereira. Team: An experiment in the design of transportable natural-language interfaces. Artificial Intelligence, 32, 1987.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Irene Heim</author>
</authors>
<title>The Semantics of Definite and Indefinite Noun Phrases.</title>
<date>1982</date>
<tech>PhD thesis,</tech>
<institution>University of Massachusetts at Amherst,</institution>
<contexts>
<context position="2787" citStr="[9]" startWordPosition="427" endWordPosition="427">fted the piano. b. Students in this class each lifted the piano. c. Students in this class lifted the piano. (the distributive reading) Thus, the distributive readings of (1) and (2c) result from applying the D operator to the subjects. Now, look at another sentence &amp;quot;Five students ate four slices of pizza.&amp;quot; It has 8 POSSIBLE readings because the D operator may apply to each of the two arguments of eat, and the two NPs can take scope over each other. Thus, 2 x 2 x 2 = 8.1 I have extended Link&apos;s and Roberts&apos;s theories to quantify over events in Discourse Representation Theory (cf. Kamp [14 Heim [9], Aone [2]) so that these readings can be systematically generated and represented in the semantics module. However, the most PLAUSIBLE reading is the &amp;quot;distributive-distributive reading&amp;quot;, where each of the five students ate four slices one at a time, as represented in a discourse representation structure (DRS) in Figure 12. Such plausibility comes partly from the lexical semantics of eat. From our &amp;quot;common sense&amp;quot;, we know that &amp;quot;eating&amp;quot; is an individual activity unlike &amp;quot;moving a desk&amp;quot;, which can be done either individually or in a group. However, such plausibility should not be a part of the sem</context>
</contexts>
<marker>[9]</marker>
<rawString>Irene Heim. The Semantics of Definite and Indefinite Noun Phrases. PhD thesis, University of Massachusetts at Amherst, 1982.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Hans Kamp</author>
</authors>
<title>A theory of truth and semantic representation.</title>
<date>1981</date>
<booktitle>In Groenendijk</booktitle>
<editor>et al., editor,</editor>
<marker>[10]</marker>
<rawString>Hans Kamp. A theory of truth and semantic representation. In Groenendijk et al., editor, Truth, Interpretation, and Information. Foris, 1981.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Krifka Manfred</author>
</authors>
<title>Nominal reference and temporal constitution: Towards a semantics of quantity.</title>
<date>1987</date>
<booktitle>In Proceedings of the Sixth Amsterdam Colloquium,</booktitle>
<pages>153--173</pages>
<institution>University of Amsterdam, Institute for Language, Logic and Information,</institution>
<contexts>
<context position="3773" citStr="[11]" startWordPosition="589" endWordPosition="589">s of eat. From our &amp;quot;common sense&amp;quot;, we know that &amp;quot;eating&amp;quot; is an individual activity unlike &amp;quot;moving a desk&amp;quot;, which can be done either individually or in a group. However, such plausibility should not be a part of the semantic theory, but should be dealt with in pragmatics where world knowledge is available. In section 2, I&apos;ll identify the &apos;Actually the two collective-collective readings are equivalent, so there are 7 distinct readings. 2(i-part x&apos; x) says &amp;quot;x&apos; is an atomic individual-part of x&amp;quot; (cf. Link [12]), and CU, i.e. &amp;quot;Count-Unit&amp;quot;, stands for a natural measure unit for students (cf. Krifka [11]). 1 Figure 1: DRS for &amp;quot;Five students ate four slices of pizza&amp;quot; (student x) (amount x 5) (measure x CU) x&apos; (i-part x&apos; x) (pizza y) (amount y 4) (measure y slice) Y&apos; (i-part y&apos; y) =-- (eat e x&apos; y&apos;) necessary knowledge and develop a reasoner, which goes beyond Scha and Stallard [17]. There is a special reading called a cumulative reading (cf. Scha [16]). (3) 500 students ate 1200 slices of pizza. The cumulative reading of (3) says &amp;quot;there were 500 students and each student ate some slices of pizza, totaling 1200 slices.&amp;quot; The semantics of a cumulative reading is UNDERSPECIFIED and is represented a</context>
</contexts>
<marker>[11]</marker>
<rawString>Manfred, Krifka. Nominal reference and temporal constitution: Towards a semantics of quantity. In Proceedings of the Sixth Amsterdam Colloquium, pages 153-173, University of Amsterdam, Institute for Language, Logic and Information, 1987.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Godehard Link</author>
</authors>
<title>The logical analysis of plurals and mass terms: Lattice-theoretical approach.</title>
<date>1983</date>
<booktitle>Meaning, Use, and Interpretations of Language. de Gruyter,</booktitle>
<editor>In Rainer Bauerle, Christoph Schwarze, and Arnim von Stechow, editors,</editor>
<contexts>
<context position="3680" citStr="[12]" startWordPosition="574" endWordPosition="574">tation structure (DRS) in Figure 12. Such plausibility comes partly from the lexical semantics of eat. From our &amp;quot;common sense&amp;quot;, we know that &amp;quot;eating&amp;quot; is an individual activity unlike &amp;quot;moving a desk&amp;quot;, which can be done either individually or in a group. However, such plausibility should not be a part of the semantic theory, but should be dealt with in pragmatics where world knowledge is available. In section 2, I&apos;ll identify the &apos;Actually the two collective-collective readings are equivalent, so there are 7 distinct readings. 2(i-part x&apos; x) says &amp;quot;x&apos; is an atomic individual-part of x&amp;quot; (cf. Link [12]), and CU, i.e. &amp;quot;Count-Unit&amp;quot;, stands for a natural measure unit for students (cf. Krifka [11]). 1 Figure 1: DRS for &amp;quot;Five students ate four slices of pizza&amp;quot; (student x) (amount x 5) (measure x CU) x&apos; (i-part x&apos; x) (pizza y) (amount y 4) (measure y slice) Y&apos; (i-part y&apos; y) =-- (eat e x&apos; y&apos;) necessary knowledge and develop a reasoner, which goes beyond Scha and Stallard [17]. There is a special reading called a cumulative reading (cf. Scha [16]). (3) 500 students ate 1200 slices of pizza. The cumulative reading of (3) says &amp;quot;there were 500 students and each student ate some slices of pizza, totali</context>
</contexts>
<marker>[12]</marker>
<rawString>Godehard Link. The logical analysis of plurals and mass terms: Lattice-theoretical approach. In Rainer Bauerle, Christoph Schwarze, and Arnim von Stechow, editors, Meaning, Use, and Interpretations of Language. de Gruyter, 1983.</rawString>
</citation>
<citation valid="true">
<date>1984</date>
<booktitle>Handbook of Semantics.</booktitle>
<editor>Godehard Link. Plural. In Dieter Wunderlich and Arnim von Stechow, editors,</editor>
<note>To appear in:</note>
<contexts>
<context position="1894" citStr="[14, 13]" startWordPosition="271" endWordPosition="272">d to represent hypotheses, constraints, and axioms in a way isomorphic to diagram representations of collective-distributive ambiguity. 1 Semantics of CollectiveDistributive Ambiguity Collective-distributive ambiguity can be illustrated by the following sentence. (1) Two students moved a desk upstairs. (1) means either that two students TOGETHER moved one desk (a collective reading) or that each The work described in this paper was done as a part of the author&apos;s doctoral dissertation at The University of Texas at Austin. of them moved a desk SEPARATELY (a distributive reading). Following Link [14, 13] and Roberts [15], distributivity comes from either an explicit quantificational operator like each or an implicit distributive operator called the D operator. The D operator was motivated by the equivalence in the semantics of the following sentences. (2) a. Every student in this class lifted the piano. b. Students in this class each lifted the piano. c. Students in this class lifted the piano. (the distributive reading) Thus, the distributive readings of (1) and (2c) result from applying the D operator to the subjects. Now, look at another sentence &amp;quot;Five students ate four slices of pizza.&amp;quot; I</context>
<context position="4443" citStr="[13]" startWordPosition="706" endWordPosition="706">tudent x) (amount x 5) (measure x CU) x&apos; (i-part x&apos; x) (pizza y) (amount y 4) (measure y slice) Y&apos; (i-part y&apos; y) =-- (eat e x&apos; y&apos;) necessary knowledge and develop a reasoner, which goes beyond Scha and Stallard [17]. There is a special reading called a cumulative reading (cf. Scha [16]). (3) 500 students ate 1200 slices of pizza. The cumulative reading of (3) says &amp;quot;there were 500 students and each student ate some slices of pizza, totaling 1200 slices.&amp;quot; The semantics of a cumulative reading is UNDERSPECIFIED and is represented as a collective-collective reading at the semantic level (cf. Link [13], Roberts [15], Aone [2]). This means that a cumulative reading should have a more specific representation at the pragmatics level for inferencing. Reasoning about cumulative readings is particularly interesting, and I will discuss it in detail. 2 Model-Based Reasoning for Disambiguation Although scope ambiguity has been worked on by many researchers (e.g. Grosz et al. [8]), the main problem addressed has been how to generate all the scope choices and order them according to some heuristics. This approach might be sufficient as far as scope ambiguity goes. However, collectivedistributive ambig</context>
</contexts>
<marker>[13]</marker>
<rawString>Godehard Link. Plural. In Dieter Wunderlich and Arnim von Stechow, editors, To appear in: Handbook of Semantics. 1984.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Godehard Link</author>
</authors>
<title>Generalized quantifiers and plurals.</title>
<date>1987</date>
<booktitle>Generalized Quantifiers: Linguistics and Logical Approaches.</booktitle>
<editor>In P. Gaerdenfors, editor,</editor>
<location>Reidel,</location>
<contexts>
<context position="1894" citStr="[14, 13]" startWordPosition="271" endWordPosition="272">d to represent hypotheses, constraints, and axioms in a way isomorphic to diagram representations of collective-distributive ambiguity. 1 Semantics of CollectiveDistributive Ambiguity Collective-distributive ambiguity can be illustrated by the following sentence. (1) Two students moved a desk upstairs. (1) means either that two students TOGETHER moved one desk (a collective reading) or that each The work described in this paper was done as a part of the author&apos;s doctoral dissertation at The University of Texas at Austin. of them moved a desk SEPARATELY (a distributive reading). Following Link [14, 13] and Roberts [15], distributivity comes from either an explicit quantificational operator like each or an implicit distributive operator called the D operator. The D operator was motivated by the equivalence in the semantics of the following sentences. (2) a. Every student in this class lifted the piano. b. Students in this class each lifted the piano. c. Students in this class lifted the piano. (the distributive reading) Thus, the distributive readings of (1) and (2c) result from applying the D operator to the subjects. Now, look at another sentence &amp;quot;Five students ate four slices of pizza.&amp;quot; I</context>
</contexts>
<marker>[14]</marker>
<rawString>Godehard Link. Generalized quantifiers and plurals. In P. Gaerdenfors, editor, Generalized Quantifiers: Linguistics and Logical Approaches. Reidel, 1987.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Craige Roberts</author>
</authors>
<title>Modal Subordination, Anaphora, and Distributivity.</title>
<date>1987</date>
<tech>PhD thesis,</tech>
<institution>University of Massachusetts at Amherst,</institution>
<contexts>
<context position="1911" citStr="[15]" startWordPosition="275" endWordPosition="275">eses, constraints, and axioms in a way isomorphic to diagram representations of collective-distributive ambiguity. 1 Semantics of CollectiveDistributive Ambiguity Collective-distributive ambiguity can be illustrated by the following sentence. (1) Two students moved a desk upstairs. (1) means either that two students TOGETHER moved one desk (a collective reading) or that each The work described in this paper was done as a part of the author&apos;s doctoral dissertation at The University of Texas at Austin. of them moved a desk SEPARATELY (a distributive reading). Following Link [14, 13] and Roberts [15], distributivity comes from either an explicit quantificational operator like each or an implicit distributive operator called the D operator. The D operator was motivated by the equivalence in the semantics of the following sentences. (2) a. Every student in this class lifted the piano. b. Students in this class each lifted the piano. c. Students in this class lifted the piano. (the distributive reading) Thus, the distributive readings of (1) and (2c) result from applying the D operator to the subjects. Now, look at another sentence &amp;quot;Five students ate four slices of pizza.&amp;quot; It has 8 POSSIBLE </context>
<context position="4457" citStr="[15]" startWordPosition="708" endWordPosition="708">unt x 5) (measure x CU) x&apos; (i-part x&apos; x) (pizza y) (amount y 4) (measure y slice) Y&apos; (i-part y&apos; y) =-- (eat e x&apos; y&apos;) necessary knowledge and develop a reasoner, which goes beyond Scha and Stallard [17]. There is a special reading called a cumulative reading (cf. Scha [16]). (3) 500 students ate 1200 slices of pizza. The cumulative reading of (3) says &amp;quot;there were 500 students and each student ate some slices of pizza, totaling 1200 slices.&amp;quot; The semantics of a cumulative reading is UNDERSPECIFIED and is represented as a collective-collective reading at the semantic level (cf. Link [13], Roberts [15], Aone [2]). This means that a cumulative reading should have a more specific representation at the pragmatics level for inferencing. Reasoning about cumulative readings is particularly interesting, and I will discuss it in detail. 2 Model-Based Reasoning for Disambiguation Although scope ambiguity has been worked on by many researchers (e.g. Grosz et al. [8]), the main problem addressed has been how to generate all the scope choices and order them according to some heuristics. This approach might be sufficient as far as scope ambiguity goes. However, collectivedistributive ambiguity subsumes </context>
</contexts>
<marker>[15]</marker>
<rawString>Craige Roberts. Modal Subordination, Anaphora, and Distributivity. PhD thesis, University of Massachusetts at Amherst, 1987.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Remko Scha</author>
</authors>
<title>Distributive, collective, and cumulative quantification.</title>
<date>1984</date>
<booktitle>In Janssen and Stokhof, editors, Truth, Interpretation and Information. Foris,</booktitle>
<contexts>
<context position="4125" citStr="[16]" startWordPosition="655" endWordPosition="655"> two collective-collective readings are equivalent, so there are 7 distinct readings. 2(i-part x&apos; x) says &amp;quot;x&apos; is an atomic individual-part of x&amp;quot; (cf. Link [12]), and CU, i.e. &amp;quot;Count-Unit&amp;quot;, stands for a natural measure unit for students (cf. Krifka [11]). 1 Figure 1: DRS for &amp;quot;Five students ate four slices of pizza&amp;quot; (student x) (amount x 5) (measure x CU) x&apos; (i-part x&apos; x) (pizza y) (amount y 4) (measure y slice) Y&apos; (i-part y&apos; y) =-- (eat e x&apos; y&apos;) necessary knowledge and develop a reasoner, which goes beyond Scha and Stallard [17]. There is a special reading called a cumulative reading (cf. Scha [16]). (3) 500 students ate 1200 slices of pizza. The cumulative reading of (3) says &amp;quot;there were 500 students and each student ate some slices of pizza, totaling 1200 slices.&amp;quot; The semantics of a cumulative reading is UNDERSPECIFIED and is represented as a collective-collective reading at the semantic level (cf. Link [13], Roberts [15], Aone [2]). This means that a cumulative reading should have a more specific representation at the pragmatics level for inferencing. Reasoning about cumulative readings is particularly interesting, and I will discuss it in detail. 2 Model-Based Reasoning for Disambig</context>
</contexts>
<marker>[16]</marker>
<rawString>Remko Scha. Distributive, collective, and cumulative quantification. In Janssen and Stokhof, editors, Truth, Interpretation and Information. Foris, 1984.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Remko Scha</author>
<author>David Stallard</author>
</authors>
<title>Multi-level plural and distributivity.</title>
<date>1988</date>
<booktitle>In Proceedings of 26th Annual Meeting of the ACL,</booktitle>
<contexts>
<context position="4054" citStr="[17]" startWordPosition="643" endWordPosition="643">d knowledge is available. In section 2, I&apos;ll identify the &apos;Actually the two collective-collective readings are equivalent, so there are 7 distinct readings. 2(i-part x&apos; x) says &amp;quot;x&apos; is an atomic individual-part of x&amp;quot; (cf. Link [12]), and CU, i.e. &amp;quot;Count-Unit&amp;quot;, stands for a natural measure unit for students (cf. Krifka [11]). 1 Figure 1: DRS for &amp;quot;Five students ate four slices of pizza&amp;quot; (student x) (amount x 5) (measure x CU) x&apos; (i-part x&apos; x) (pizza y) (amount y 4) (measure y slice) Y&apos; (i-part y&apos; y) =-- (eat e x&apos; y&apos;) necessary knowledge and develop a reasoner, which goes beyond Scha and Stallard [17]. There is a special reading called a cumulative reading (cf. Scha [16]). (3) 500 students ate 1200 slices of pizza. The cumulative reading of (3) says &amp;quot;there were 500 students and each student ate some slices of pizza, totaling 1200 slices.&amp;quot; The semantics of a cumulative reading is UNDERSPECIFIED and is represented as a collective-collective reading at the semantic level (cf. Link [13], Roberts [15], Aone [2]). This means that a cumulative reading should have a more specific representation at the pragmatics level for inferencing. Reasoning about cumulative readings is particularly interesting</context>
<context position="23306" citStr="[17]" startWordPosition="3879" endWordPosition="3879">he cumulative reading R7 is filtered out by the other three inferences, as described in section 2.2.2. Thus, only R4 is consistent, which is what we want. [2] Harold Abelson and Gerald Sussman. Structure and Interpretation of Computer Programs. The MIT Press, Cambridge, Massachusetts, 1985. Chinatsu Aone. Treatment of Plurals and Collective-Distributive Ambiguity in Natural Language Understanding. PhD thesis, The University of Texas at Austin, 1991. References 3 Conclusion The work described in this paper improves upon previous works on collective-distributive ambiguity (cf. Scha and Stallard [17], Gardiner et al. [7]), since they do not fully explore the necessary reasoning. I believe that the reasoning method described in this paper is general enough to solve collectivedistributive problems because 1) any special constraints can be added as new predicates are added to the KB, and 2) intuitively simple reasoning to solve numerical problems is done by using domainindependent axioms. However, the current reasoning capability should be extended further to include different kinds of knowledge. For example, while the cumulative readings of &amp;quot;5 alarms were installed in 6 building&amp;quot; is implaus</context>
</contexts>
<marker>[17]</marker>
<rawString>Remko Scha and David Stallard. Multi-level plural and distributivity. In Proceedings of 26th Annual Meeting of the ACL, 1988.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Reid Simmons</author>
<author>Randall Davis</author>
</authors>
<title>Generate, test and debug: Combining associational rules and causal models.</title>
<date>1987</date>
<booktitle>In Proceedings of the Tenth International Joint Conference on Artificial Intelligence,</booktitle>
<location>Los Altos, California,</location>
<contexts>
<context position="783" citStr="[18]" startWordPosition="115" endWordPosition="115">antic analysis of collectivedistributive ambiguity, and resolution of such ambiguity by model-based reasoning. This approach goes beyond Scha and Stallard [17], whose reasoning capability was limited to checking semantic types. My semantic analysis is based on Link [14, 13] and Roberts [15], where distributivity comes uniformly from a quantificational operator, either explicit (e.g. each) or implicit (e.g. the D operator). I view the semantics module of the natural language system as a hypothesis generator and the reasoner in the pragmatics module as a hypothesis filter (cf. Simmons and Davis [18]). The reasoner utilizes a model consisting of domain-dependent constraints and domain-independent axioms for disambiguation. There are two kinds of constraints, type constraints and numerical constraints, and they are associated with predicates in the knowledge base. Whenever additional information is derived from the model, the Contradiction Checker is invoked to detect any contradiction in a hypothesis using simple mathematical knowledge. CDCL (Collective-Distributive Constraint Language) is used to represent hypotheses, constraints, and axioms in a way isomorphic to diagram representations</context>
<context position="5492" citStr="[18]" startWordPosition="870" endWordPosition="870">hoices and order them according to some heuristics. This approach might be sufficient as far as scope ambiguity goes. However, collectivedistributive ambiguity subsumes scope ambiguity and a heuristics strategy would not be a strong method. I argue that the reason why some of the readings are implausible (and even do not occur to some people) is because we have access to domaindependent knowledge (e.g. constraints on predicates) along with domain-independent knowledge (e.g. mathematical knowledge). I have developed a reasoner based on the theory of model-based reasoning (cf. Simmons and Davis [18], Fink and Lusth [6], Davis and Hamscher [5]) for collective-distributive ambiguity resolution. The model that the reasoner uses consists of four kinds of knowledge, namely predicate constraints, two types of axioms, and simple mathematical knowledge. First, I will discuss the representation language CDCL3. Then, I will discuss how these four kinds of knowledge are utilized during reasoning. 2.1 CDCL CDCL is used to represent collective-distributive readings, constraints and axioms for reasoning. There are three types of CDCL clauses as in (4), and I will explain them as I proceed4. (4) Core c</context>
</contexts>
<marker>[18]</marker>
<rawString>Reid Simmons and Randall Davis. Generate, test and debug: Combining associational rules and causal models. In Proceedings of the Tenth International Joint Conference on Artificial Intelligence, Los Altos, California, 1987.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Patrick Winston</author>
<author>Berthold Horn</author>
</authors>
<date>1989</date>
<booktitle>LISP 3rd Edition.</booktitle>
<publisher>Addison-Wesley,</publisher>
<location>Reading, Massachusetts,</location>
<contexts>
<context position="16823" citStr="[19]" startWordPosition="2805" endWordPosition="2805">d Reasoner In this section, I describe how the reasoner performs disambiguation. But first I will describe special &amp;quot;unification&amp;quot; which is the basic operation of the reasoner5. 2.2.1 Unification &amp;quot;Unification&amp;quot; is used to unify CDCL clauses during the reasoning process. However, it is not standard unification. It consists of three sequential matching operations: Syntax Match, ARG Match, and Value Match. First, Syntax Match tests if the syntax of 5The reasoner has been implemented in Common Lisp. Unification and forward chaining rule codes are based on Ableson and Sussman [1] and Winston and Horn [19]. two expressions matches. The syntax of two expressions matches when they belong to the same type of CDCL clauses (cf. (4)). If Syntax Match succeeds, ARG Match tests if the argument constants (i.e. a0, al) in the two expressions match. If this operation is successful, Value Match is performed. There are two ways Value Match fails. First, it fails when types do not match. For example, (14a) fails to unify with (14b) because ?r:set does not match the integer 4. (14) a. (?p:num (?q:num a0 ?r:set al)) b. (5 (1 a0 4 al)) The second way Value Match fails is two values of the same type are simply n</context>
</contexts>
<marker>[19]</marker>
<rawString>Patrick Winston and Berthold Horn. LISP 3rd Edition. Addison-Wesley, Reading, Massachusetts, 1989.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>