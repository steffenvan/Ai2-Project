<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<title confidence="0.9978155">
Data-Driven Parsing using Probabilistic
Linear Context-Free Rewriting Systems
</title>
<author confidence="0.984466">
Laura Kallmeyer*
</author>
<affiliation confidence="0.537751">
Heinrich-Heine-Universit¨at D¨usseldorf
</affiliation>
<author confidence="0.979129">
Wolfgang Maier**
</author>
<affiliation confidence="0.440029">
Heinrich-Heine-Universit¨at D¨usseldorf
</affiliation>
<subsubsectionHeader confidence="0.5588145">
This paper presents the first efficient implementation of a weighted deductive CYK parser for
Probabilistic Linear Context-Free Rewriting Systems (PLCFRSs). LCFRS, an extension of CFG,
</subsubsectionHeader>
<bodyText confidence="0.9924418">
can describe discontinuities in a straightforward way and is therefore a natural candidate to be
used for data-driven parsing. To speed up parsing, we use different context-summary estimates
of parse items, some of them allowing for A∗ parsing. We evaluate our parser with grammars
extracted from the German NeGra treebank. Our experiments show that data-driven LCFRS
parsing is feasible and yields output of competitive quality.
</bodyText>
<sectionHeader confidence="0.995128" genericHeader="abstract">
1. Introduction
</sectionHeader>
<bodyText confidence="0.9998719">
Recently, the challenges that a rich morphology poses for data-driven parsing have
received growing interest. A direct effect of morphological richness is, for instance, data
sparseness on a lexical level (Candito and Seddah 2010). A rather indirect effect is that
morphological richness often relaxes word order constraints. The principal intuition is
that a rich morphology encodes information that otherwise has to be conveyed by a
particular word order. If, for instance, the case of a nominal complement is not provided
by morphology, it has to be provided by the position of the complement relative to other
complements in the sentence. Example (1) provides an example of case marking and free
word order in German. In turn, in free word order languages, word order can encode
information structure (Hoffman 1995).
</bodyText>
<figure confidence="0.92157535">
(1) a. der
the
kleine
little
Jungenom
boy
schickt
sends
seiner
his
Schwesterdat
sister
Briefacc
letter
den
the
b. Other possible word orders:
(i) der kleine Jungenom schickt den Briefacc seiner Schwesterdat
(ii) seiner Schwesterdat schickt der kleine Jungenom den Briefacc
(iii) den Briefacc schickt der kleine Jungenom seiner Schwesterdat
</figure>
<footnote confidence="0.902641166666667">
* Institut f¨ur Sprache und Information, Universit¨atsstr. 1, D-40225 D¨usseldorf, Germany.
E-mail: kallmeyer®phil.uni-duesseldorf.de.
** Institut f¨ur Sprache und Information, Universit¨atsstr. 1, D-40225 D¨usseldorf, Germany.
E-mail: maierw®hhu.de.
Submission received: September 29, 2011; revised submission received: May 20, 2012; accepted for publication:
August 3, 2012.
</footnote>
<note confidence="0.8214265">
© 2013 Association for Computational Linguistics
Computational Linguistics Volume 39, Number 1
</note>
<bodyText confidence="0.999955944444445">
It is assumed that this relation between a rich morphology and free word order does
not hold in both directions. Although it is generally the case that languages with a rich
morphology exhibit a high degree of freedom in word order, languages with a free word
order do not necessarily have a rich morphology. Two examples for languages with a
very free word order are Turkish and Bulgarian. The former has a very rich and the
latter a sparse morphology. See M¨uller (2002) for a survey of the linguistics literature on
this discussion.
With a rather free word order, constituents and single parts of them can be displaced
freely within the sentence. German, for instance, has a rich inflectional system and
allows for a free word order, as we have already seen in Example (1): Arguments can
be scrambled, and topicalizations and extrapositions underlie few restrictions. Conse-
quently, discontinuous constituents occur frequently. This is challenging for syntactic
description in general (Uszkoreit 1986; Becker, Joshi, and Rambow 1991; Bunt 1996;
M¨uller 2004), and for treebank annotation in particular (Skut et al. 1997).
In this paper, we address the problem of data-driven parsing of discontinuous constit-
uents on the basis of German. In this section, we inspect the type of data we have to deal
with, and we describe the way such data are annotated in treebanks. We briefly discuss
different parsing strategies for the data in question and motivate our own approach.
</bodyText>
<subsectionHeader confidence="0.985333">
1.1 Discontinuous Constituents
</subsectionHeader>
<bodyText confidence="0.99995025">
Consider the sentences in Example (2) as examples for discontinuous constituents
(taken from the German NeGra [Skut et al. 1997] and TIGER [Brants et al. 2002] tree-
banks). Example (2a) shows several instances of discontinuous VPs and Example (2b)
shows a discontinuous NP. The relevant constituent is printed in italics.
</bodyText>
<listItem confidence="0.966654">
(2) a. Fronting:
(i) Dar¨uber muss nachgedacht werden. (NeGra)
</listItem>
<bodyText confidence="0.615731">
Thereof must thought be
“One must think of that” k¨onne sich Bonn von dem Denkmal nicht
(ii) Ohne internationalen Schaden could itself Bonn from the monument not
Without international damage
distanzieren, ... (TIGER)
</bodyText>
<figure confidence="0.982613764705882">
distance
“Bonn could not distance itself from the monument without international
damage.”
(iii) Auch
Also
w¨urden durch die Regelung nur
would through the regulation only
“st¨andig neue
“constantly new
Altf¨alle
old cases
entstehen”. (TIGER)
emerge”
“Apartfrom that, the regulation would only constantly produce new old cases.”
b. Extraposed relative clauses:
(i) ... ob auf deren Gel¨ande der Typ von Abstellanlage gebaut
... whether on their terrain the type of parking facility built
</figure>
<footnote confidence="0.94570825">
werden k¨onne, der ... (NeGra)
get could, which ...
“...whether one could build on their premises the type of parking facility,
which... ”
</footnote>
<page confidence="0.994503">
88
</page>
<note confidence="0.957849">
Kallmeyer and Maier PLCFRS Parsing
</note>
<bodyText confidence="0.9833714">
Examples of other such languages are Bulgarian and Korean. Both show discontin-
uous constituents as well. Example (3a) is a Bulgarian example of a PP extracted out of
an NP, taken from the BulTreebank (Osenova and Simov 2004), and Example (3b) is an
example of fronting in Korean, taken from the Penn Korean Treebank (Han, Han, and
Ko 2001).
</bodyText>
<figure confidence="0.645829833333333">
(3) a. Na kyshtata toi popravi pokriva.
Of house-DET he repaired roof.
“It is the roof of the house he repairs.”
b. Gwon.han-˘ul nu.ga ka.ji.go iss.ji?
Authority-OBJ who has not?
“Who has no authority?”
</figure>
<bodyText confidence="0.978103166666667">
Discontinuous constituents are by no means limited to languages with freedom
in word order. They also occur in languages with a rather fixed word order such
as English, resulting from, for instance, long-distance movements. Examples (4a) and
(4b) are examples from the Penn Treebank for long extractions resulting in discontin-
uous S categories and for discontinuous NPs arising from extraposed relative clauses,
respectively (Marcus et al. 1994).
</bodyText>
<listItem confidence="0.957252111111111">
(4) a. Long Extraction in English:
(i) Those chains include Bloomingdale’s, which Campeau recently said it
will sell.
(ii) What should I do.
b. Extraposed nominal modifiers (relative clauses and PPs) in English:
(i) They sow a row of male-fertile plants nearby, which then pollinate the male-
sterile plants.
(ii) Prices fell marginally for fuel and electricity.
1.2 Treebank Annotation and Data-Driven Parsing
</listItem>
<bodyText confidence="0.999037444444445">
Most constituency treebanks rely on an annotation backbone based on Context-Free
Grammar (CFG). Discontinuities cannot be modeled with CFG, because they require a
larger domain of locality than the one offered by CFG. Therefore, the annotation back-
bone based on CFG is generally augmented with a separate mechanism that accounts
for the non-local dependencies. In the Penn Treebank (PTB), for example, trace nodes
and co-indexation markers are used in order to establish additional implicit edges in the
tree beyond the overt phrase structure. In T¨uBa-D/Z (Telljohann et al. 2012), a German
Treebank, non-local dependencies are expressed via an annotation of topological fields
(H¨ohle 1986) and special edge labels. In contrast, some other treebanks, among them
NeGra and TIGER, give up the annotation backbone based on CFG and allow annota-
tion with crossing branches (Skut et al. 1997). In such an annotation, non-local depen-
dencies can be expressed directly by grouping all dependent elements under a single
node. Note that both crossing branches and traces annotate long-distance dependencies
in a linguistically meaningful way. A difference is, however, that crossing branches
are less theory-dependent because they do not make any assumptions about the base
positions of “moved” elements.
Examples for the different approaches of annotating discontinuities are given in
Figures 1 and 2. Figure 1 shows the NeGra annotation of Example (2a-i) (left), and an
</bodyText>
<page confidence="0.998168">
89
</page>
<figure confidence="0.589132">
Computational Linguistics Volume 39, Number 1
</figure>
<figureCaption confidence="0.782178">
Figure 1
</figureCaption>
<figure confidence="0.817857">
A discontinuous constituent. Original NeGra annotation (left) and a T¨uBa-D/Z-style annotation
(right).
</figure>
<figureCaption confidence="0.93302">
Figure 2
</figureCaption>
<bodyText confidence="0.992362">
A discontinuous wh-movement. Original PTB annotation (left) and NeGra-style annotation
(right).
annotation of the same sentence in the style of the T¨uBa-D/Z treebank (right). Figure 2
shows the PTB annotation of Example (4a-ii) (on the left, note that the directed edge
from the trace to the WHNP element visualizes the co-indexation) together with a
NeGra-style annotation of the same sentence (right).
In the past, data-driven parsing has largely been dominated by Probabilistic
Context-Free Grammar (PCFG). In order to extract a PCFG from a treebank, the trees
need to be interpretable as CFG derivations. Consequently, most work has excluded
non-local dependencies; either (in PTB-like treebanks) by discarding labeling conven-
tions such as the co-indexation of the trace nodes in the PTB, or (in NeGra/TIGER-like
treebanks) by applying tree transformations, which resolve the crossing branches (e.g.,
K¨ubler 2005; Boyd 2007). Especially for the latter treebanks, such a transformation is
problematic, because it generally is non-reversible and implies information loss.
Discontinuities are no minor phenomenon: Approximately 25% of all sentences
in NeGra and TIGER have crossing branches (Maier and Lichte 2011). In the Penn
Treebank, this holds for approximately 20% of all sentences (Evang and Kallmeyer
2011). This shows that it is important to properly treat such structures.
</bodyText>
<subsectionHeader confidence="0.98577">
1.3 Extending the Domain of Locality
</subsectionHeader>
<bodyText confidence="0.9996302">
In the literature, different methods have been explored that allow for the use of non-
local information in data-driven parsing. We distinguish two classes of approaches.
The first class consists of approaches that aim at using formalisms which produce
trees without crossing branches but provide a larger domain of locality than CFG—
for instance, through complex labels (Hockenmaier 2003) or through the derivation
</bodyText>
<figure confidence="0.99922775">
What should I do *r* ? What should I do
WP MD PRP VB -NONE- . WP MD PRP VB .
WHNP
NP
SBJ
*r*
SQ
SBARQ
VP
NP
VP
SQ
NP
SBJ
SBARQ
WHNP
</figure>
<page confidence="0.778363">
90
</page>
<note confidence="0.6738175">
Kallmeyer and Maier PLCFRS Parsing
CFG:
</note>
<figureCaption confidence="0.745421">
Figure 3
</figureCaption>
<subsectionHeader confidence="0.533596">
Different domains of locality.
</subsectionHeader>
<bodyText confidence="0.999621485714286">
mechanism (Chiang 2003). The second class, to which we contribute in this paper,
consists of approaches that aim at producing trees which contain non-local information.
Some methods realize the reconstruction of non-local information in a post- or pre-
processing step to PCFG parsing (Johnson 2002; Dienes 2003; Levy and Manning 2004;
Cai, Chiang, and Goldberg 2011). Other work uses formalisms that accommodate the
direct encoding of non-local information (Plaehn 2004; Levy 2005). We pursue the latter
approach.
Our work is motivated by the following recent developments. Linear Context-Free
Rewriting Systems (LCFRSs) (Vijay-Shanker, Weir, and Joshi 1987) have been estab-
lished as a candidate for modeling both discontinuous constituents and non-projective
dependency trees as they occur in treebanks (Maier and Søgaard 2008; Kuhlmann and
Satta 2009; Maier and Lichte 2011). LCFRSs are a natural extension of CFGs where
the non-terminals can span tuples of possibly non-adjacent strings (see Figure 3). Be-
cause LCFRSs allow for binarization and CYK chart parsing in a way similar to CFGs,
PCFG techniques, such as best-first parsing (Caraballo and Charniak 1998), weighted
deductive parsing (Nederhof 2003), and A* parsing (Klein and Manning 2003a) can
be transferred to LCFRS. Finally, as mentioned before, languages such as German
have recently attracted the interest of the parsing community (K¨ubler and Penn 2008;
Seddah, K¨ubler, and Tsarfaty 2010).
We bring together these developments by presenting a parser for Probabilistic
LCFRS (PLCFRS), continuing the promising work of Levy (2005). Our parser pro-
duces trees with crossing branches and thereby accounts for syntactic long-distance
dependencies while not making any additional assumptions concerning the position
of hypothetical traces. We have implemented a CYK parser and we present several
methods for context summary estimation of parse items. The estimates either act as
figures-of-merit in a best-first parsing context or as estimates for A* parsing. A test on
a real-world-sized data set shows that our parser achieves competitive results. To our
knowledge, our parser is the first for the entire class of PLCFRS that has successfully
been used for data-driven parsing.1
The paper is structured as follows. Section 2 introduces probabilistic LCFRS. Sec-
tions 3 and 4 present the binarization algorithm, the parser, and the outside estimates
which we use to speed up parsing. In Section 5 we explain how to extract an LCFRS from
a treebank and we present grammar refinement methods for these specific treebank
grammars. Finally, Section 6 presents evaluation results and Section 7 compares our
work to other approaches.
</bodyText>
<footnote confidence="0.9375288">
1 Parts of the results presented in this paper have been presented earlier. More precisely, in Kallmeyer and
Maier (2010), we presented the general architecture of the parser and all outside estimates except the LN
estimate from Section 4.4 which is presented in Maier, Kaeshammer, and Kallmeyer (2012). In Maier and
Kallmeyer (2010) we have presented experiments with the relative clause split from Section 3.2. Finally,
Maier (2010) contains the evaluation of the baseline (together with an evaluation using other metrics).
</footnote>
<figure confidence="0.823279777777778">
Y
A
LCFRS: •
A
• •
Y1 Y2 Y3
91
Computational Linguistics Volume 39, Number 1
2. Probabilistic Linear Context-Free Rewriting Systems
</figure>
<subsectionHeader confidence="0.897246">
2.1 Definition of PLCFRS
</subsectionHeader>
<listItem confidence="0.5989935">
LCFRS (Vijay-Shanker, Weir, and Joshi 1987) is an extension of CFG in which a non-
terminal can span not only a single string but a tuple of strings of size k &gt; 1. k is thereby
called its fan-out. We will notate LCFRS with the syntax of Simple Range Concate-
nation Grammars (SRCG) (Boullier 1998b), a formalism that is equivalent to LCFRS.
A third formalism that is equivalent to LCFRS is Multiple Context-Free Grammar
(MCFG) (Seki et al. 1991).
</listItem>
<equation confidence="0.862454647058823">
Definition 1(LCFRS)
A Linear Context-Free Rewriting System (LCFRS) is a tuple (N, T, V, P, S) where
a) N is a finite set of non-terminals with a function dim: N -+ N that
determines the fan-out of each A E N;
b) T and V are disjoint finite sets of terminals and variables;
c) S E N is the start symbol with dim(S) = 1;
d) P is a finite set of rules
A(α1, ... , αdim(A)) -+ A1(X(1)
1 , . . . , X(1)
dim(A1)) ··· Am(X(m)
1 , . . . , X(m)
dim(Am))
for m &gt; 0 where A, A1,..., Am E N, X(i)
j E V for 1 &lt; i &lt; m,1 &lt; j &lt; dim(Ai)
and αi E (T U V)∗ for 1 &lt; i &lt; dim(A). For all r E P, it holds that every
variable X occurring in r occurs exactly once in the left-hand side and
exactly once in the right-hand side of r.
</equation>
<bodyText confidence="0.791655">
A rewriting rule describes how the yield of the left-hand side non-terminal can be
computed from the yields of the right-hand side non-terminals. The rules A(ab, cd) -+ ε
</bodyText>
<listItem confidence="0.7573355">
and A(aXb, cYd) -+ A(X, Y) from Figure 4 for instance specify that (1) (ab, cd) is in the
yield of A and (2) one can compute a new tuple in the yield of A from an already existing
</listItem>
<equation confidence="0.855870222222222">
one by wrapping a and b around the first component and c and d around the second.
A CFG rule A -+ BC would be written A(XY) -+ B(X)C(Y) as an LCFRS rule.
Definition 2 (Yield, language)
Let G = (N, T, V, P, S) be an LCFRS.
1. For every A E N, we define the yield of A, yield(A) as follows:
a) For every rule A(a) -+ ε, α� E yield(A);
A(ab, cd) -+ ε
A(aXb,cYd) -+ A(X,Y)
S(XY) -+ A(X,Y)
</equation>
<figureCaption confidence="0.673838">
Figure 4
</figureCaption>
<footnote confidence="0.745026">
Sample LCFRS for {anbncndn  |n &gt; 1}.
</footnote>
<page confidence="0.925944">
92
</page>
<equation confidence="0.938038181818182">
Kallmeyer and Maier PLCFRS Parsing
b) For every rule A(α1, ... , αdim(A)) -+ A1(X(1)
1 , . . . , X(1)
dim(A1)) � � �
Am(X(m)
1 ,...,X(m)
dim(Am)) and for all Ti E yield(Ai) (1 &lt; i &lt; m):
(f (α1), ... ,f (αdim(A))) E yield(A) where f is defined as follows:
(i) f (t) = t for all t E T,
(ii) f (X(i)
j ) = Ti(j) for all 1 &lt; i &lt; m, 1 &lt; j &lt; dim(Ai) and
</equation>
<bodyText confidence="0.810215666666667">
(iii) f (xy) = f(x)f(y) for all x, y E (T U V)+.
We call f the composition function of the rule.
c) Nothing else is in yield(A).
</bodyText>
<sectionHeader confidence="0.422371" genericHeader="method">
2. The language of G is then L(G) = {w  |(w) E yield(S)}.
</sectionHeader>
<bodyText confidence="0.9257699">
As an example, consider again the LCFRS in Figure 4. The last rule tells us that,
given a pair in the yield of A, we can obtain an element in the yield of S by concate-
nating the two components. Consequently, the language generated by this grammar is
{anbncndn  |n &gt; 1}.
The terms of grammar fan-out and rank and the properties of monotonicity and
ε-freeness will be referred to later and are therefore introduced in the following defini-
tion. They are taken from the LCFRS/MCFG terminology; the SRCG term for fan-out is
arity and the property of being monotone is called ordered in the context of SRCG.
Definition 3
Let G = (N, T, V, P, S) be an LCFRS.
</bodyText>
<listItem confidence="0.997508285714286">
1. The fan-out of G is the maximal fan-out of all non-terminals in G.
2. Furthermore, the right-hand side length of a rewriting rule r E P is called
the rank of r and the maximal rank of all rules in P is called the rank of G.
3. G is monotone if for every r E P and every right-hand side non-terminal A
in r and each pair X1, X2 of arguments of A in the right-hand side of r, X1
precedes X2 in the right-hand side iff X1 precedes X2 in the left-hand side.
4. A rule r E P is called an ε-rule if one of the left-hand side components of r
</listItem>
<equation confidence="0.928699333333333">
is ε.
G is ε-free if it either contains no ε-rules or there is exactly one ε-rule
S(ε) -+ ε and S does not appear in any of the right-hand sides of the rules
</equation>
<bodyText confidence="0.765967">
in the grammar.
For every LCFRS there exists an equivalent LCFRS that is ε-free (Seki et al. 1991;
Boullier 1998a) and monotone (Michaelis 2001; Kracht 2003; Kallmeyer 2010).
The definition of a probabilistic LCFRS is a straightforward extension of the defini-
tion of PCFG and thus it follows (Levy 2005; Kato, Seki, and Kasami 2006) that:
</bodyText>
<subsectionHeader confidence="0.382897">
Definition 4 (PLCFRS)
</subsectionHeader>
<bodyText confidence="0.6630865">
A probabilistic LCFRS (PLCFRS) is a tuple (N, T, V, P, S, p) such that (N, T, V, P, S) is an
LCFRS and p : P -+ [0..1] a function such that for all A E N:
</bodyText>
<equation confidence="0.998553">
ΣA(,)→6∈Pp(A(-) -+ -6) = 1
</equation>
<page confidence="0.950082">
93
</page>
<figure confidence="0.756529">
Computational Linguistics Volume 39, Number 1
PLCFRS with non-terminals {S, A, B}, terminals {a} and start symbol S:
0.2 : S(X) -+ A(X) 0.8 : S(XY) -+ B(X,Y)
0.7 : A(aX) -+ A(X) 0.3 : A(a) -+ e
0.8 : B(aX,aY) -+ B(X,Y) 0.2 : B(a,a) -+ e
</figure>
<figureCaption confidence="0.836449">
Figure 5
</figureCaption>
<subsectionHeader confidence="0.788427">
Sample PLCFRS.
</subsectionHeader>
<bodyText confidence="0.999908">
As an example, consider the PLCFRS in Figure 5. This grammar simply generates
a+. Words with an even number of as and nested dependencies are more probable
than words with a right-linear dependency structure. For instance, the word aa receives
the two analyses in Figure 6. The analysis (a) displaying nested dependencies has
probability 0.16 and (b) (right-linear dependencies) has probability 0.042.
</bodyText>
<sectionHeader confidence="0.864379" genericHeader="method">
3. Parsing PLCFRS
</sectionHeader>
<subsectionHeader confidence="0.907785">
3.1 Binarization
</subsectionHeader>
<bodyText confidence="0.8334677">
Similarly to the transformation of a CFG into Chomsky normal form, an LCFRS can be
binarized, resulting in an LCFRS of rank 2. As in the CFG case, in the transformation,
we introduce a non-terminal for each right-hand side longer than 2 and split the rule
into two rules, using this new intermediate non-terminal. This is repeated until all
right-hand sides are of length 2. The transformation algorithm is inspired by G´omez-
Rodr´ıguez et al. (2009) and it is also specified in Kallmeyer (2010).
3.1.1 General Binarization. In order to give the algorithm for this transformation, we
need the notion of a reduction of a vector α� E [(T U V)*]i by a vector x� E Vj where all
variables in x� occur in o. A reduction is, roughly, obtained by keeping all variables in α�
that are not in z. This is defined as follows:
</bodyText>
<subsectionHeader confidence="0.588063">
Definition 5 (Reduction)
</subsectionHeader>
<bodyText confidence="0.993477222222222">
Let (N, T, V, P, S) be an LCFRS, α� E [(T U V)*]i and x� E Vj for some i,j E IN.
Let w = a1$ ... $&amp;i be the string obtained from concatenating the components of o,
separated by a new symbol $ E/ (V U T).
Let w&apos; be the image of w under a homomorphism h defined as follows: h(a) = $ for
all a E T, h(X) = $ for all X E {z1, ...zj} and h(y) = y in all other cases.
Let y1, ... ym E V+ such that w&apos; E $*y1$+y2$+ ... $+ym$*. Then the vector
(y1,. . . ym) is the reduction of α� by z.
For instance, (aX1,X2,bX3) reduced with (X2) yields (X1,X3) and (aX1X2bX3) re-
duced with (X2) yields (X1, X3) as well.
</bodyText>
<figure confidence="0.999420111111111">
S
B
a a
(a)
S
A
a A
a
(b)
</figure>
<figureCaption confidence="0.970403">
Figure 6
</figureCaption>
<bodyText confidence="0.962743">
The two derivations of aa.
</bodyText>
<page confidence="0.990323">
94
</page>
<equation confidence="0.59431175">
Kallmeyer and Maier PLCFRS Parsing
for all rules r = A(&amp;) A0( cc0) ... Am( 4) in P with m &gt; 1 do
remove r from P
R := O
</equation>
<bodyText confidence="0.8015575">
pick new non-terminals C1,..., Cm−1
add the rule A(&amp;) A0( 4)C1( yl) to R where yl is obtained by reducing α~ with rα0
for all i, 1 &lt; i &lt; m − 2 do
add the rule Ci(Yi) Ai(ai)Ci+1( Yi+1) to R where yi+1 is obtained by reducing yl with oZi
</bodyText>
<subsectionHeader confidence="0.966851">
end for
</subsectionHeader>
<bodyText confidence="0.98009075">
add the rule Cm−1( ym−2) Am−1( oGm−1)Am( 4) to R
for every rule r&apos; E R do
replace right-hand side arguments of length &gt; 1 with new variables (in both sides) and
add the result to P
</bodyText>
<subsectionHeader confidence="0.698619">
end for
end for
</subsectionHeader>
<figureCaption confidence="0.959237">
Figure 7
</figureCaption>
<bodyText confidence="0.934963588235294">
Algorithm for binarizing an LCFRS.
The binarization algorithm is given in Figure 7. As already mentioned, it proceeds
like the CFG binarization algorithm in the sense that for right-hand sides longer than
2, we introduce a new non-terminal that covers the right-hand side without the first
element. Figure 8 shows an example. In this example, there is only one rule with a right-
hand side longer than 2. In a first step, we introduce the new non-terminals and rules
that binarize the right-hand side. This leads to the set R. In a second step, before adding
the rules from R to the grammar, whenever a right-hand side argument contains several
variables, these are collapsed into a single new variable.
The equivalence of the original LCFRS and the binarized grammar is rather straight-
forward. Note, however, that the fan-out of the LCFRS can increase.
The binarization depicted in Figure 7 is deterministic in the sense that for every rule
that needs to be binarized, we choose unique new non-terminals. Later, in Section 5.3.1,
we will introduce additional factorization into the grammar rules that reduces the set
of new non-terminals.
3.1.2 Minimizing Fan-Out and Number of Variables. In LCFRS, in contrast to CFG, the order
of the right-hand side elements of a rule does not matter for the result of a derivation.
</bodyText>
<equation confidence="0.903588857142857">
Original LCFRS:
S(XYZUVW) A(X, U)B(Y,V)C(Z,W)
A(aX,aY) A(X, Y) A(a,a) ε
B(bX,bY) B(X,Y) B(b,b) ε
C(cX,cY) C(X,Y) C(c,c) ε
Rule with right-hand side of length &gt; 2: S(XYZUVW) A(X, U)B(Y,V)C(Z,W)
For this rule, we obtain
R = {S(XYZUVW) A(X,U)C1(YZ, VW),C1(YZ, VW) B(Y, V)C(Z, W)}
Equivalent binarized LCFRS:
S(XPUQ) A(X, U)C1(P, Q)
C1(YZ, VW) B(Y,V)C(Z,W)
A(aX,aY) A(X, Y) A(a,a) ε
B(bX,bY) B(X,Y) B(b,b) ε
C(cX,cY) C(X,Y) C(c,c) ε
</equation>
<figureCaption confidence="0.789113">
Figure 8
</figureCaption>
<bodyText confidence="0.279931">
Sample binarization of an LCFRS.
</bodyText>
<page confidence="0.989774">
95
</page>
<note confidence="0.294584">
Computational Linguistics Volume 39, Number 1
</note>
<bodyText confidence="0.99993805">
Therefore, we can reorder the right-hand side of a rule before binarizing it. In the
following, we present a binarization order that yields a minimal fan-out and a minimal
variable number per production and binarization step. The algorithm is inspired by
G´omez-Rodr´ıguez et al. (2009) and has first been published in this version in Kallmeyer
(2010). We assume that we are only considering partitions of right-hand sides where one
of the sets contains only a single non-terminal.
For a given rule c = A0(*x0) → A1(*x1) ... Ak(zk), we define the characteristic string
s(c, Ai) of the Ai-reduction of c as follows: Concatenate the elements of *x0, separated with
new additional symbols $ while replacing every component from i with a $. We then
define the arity of the characteristic string, dim(s(c,Ai)), as the number of maximal sub-
strings x E V+ in s(Ai). Take, for example, a rule c = VP(X, YZU) → VP(X, Z)V(Y)N(U).
Then s(c, VP) =$$Y$U, s(c, V) = X$$ZU.
Figure 9 shows how in a first step, for a given rule r with right-hand side length &gt; 2,
we determine the optimal candidate for binarization based on the characteristic string
s(r,B) of some right-hand side non-terminal B and on the fan-out of B: On all right-
hand side predicates B we check for the maximal fan-out (given by dim(s(r, B))) and the
number of variables (dim(s(r, B)) + dim(B)) we would obtain when binarizing with this
predicate. This check provides the optimal candidate. In a second step we then perform
the same binarization as before, except that we use the optimal candidate now instead
of the first element of the right-hand side.
</bodyText>
<subsectionHeader confidence="0.99978">
3.2 The Parser
</subsectionHeader>
<bodyText confidence="0.998938666666667">
We can assume without loss of generality that our grammars are e-free and monotone
(the treebank grammars with which we are concerned all have these properties) and that
they contain only binary and unary rules. Furthermore, we assume POS tagging to be
done before parsing. POS tags are non-terminals of fan-out 1. Finally, according to our
grammar extraction algorithm (see Section 5.1), a separation between two components
always means that there is actually a non-empty gap in between them. Consequently,
two different components in a right-hand side can never be adjacent in the same
component of the left-hand side. The rules are then either of the form A(a) → e with A a
POS tag and a E T or of the form A(�x) → B(�x) or A(a) → B(z)C(-y) where α~ E (V+)dim(A),
</bodyText>
<equation confidence="0.941838266666667">
x~ E Vdim(B), y~ E Vdim(C), that is, only the rules for POS tags contain terminals in their left-
hand sides.
cand = 0
fan-out = number of variables in r
vars = number of variables in r
for all i = 0 to m do
cand-fan-out = dim(s(r,Ai));
if cand-fan-out &lt; fan-out and dim(Ai) &lt; fan-out then
fan-out = max({cand-fan-out,dim(Ai)});
vars = cand-fan-out + dim(Ai);
cand = i;
else if cand-fan-out &lt; fan-out, dim(Ai) &lt; fan-out and cand-fan-out + dim(Ai) &lt; vars then
fan-out = max({cand-fan-out,dim(Ai)});
vars = cand-fan-out + dim(Ai);
cand = i
</equation>
<footnote confidence="0.472811">
end if
end for
Figure 9
Optimized version of the binarization algorithm, determining binarization order.
</footnote>
<page confidence="0.990913">
96
</page>
<note confidence="0.706024">
Kallmeyer and Maier PLCFRS Parsing
</note>
<bodyText confidence="0.999505285714286">
During parsing we have to link the terminals and variables in our LCFRS rules
to portions of the input string. For this purpose we need the notions of ranges, range
vectors, and rule instantiations. A range is a pair of indices that characterizes the span
of a component within the input. A range vector characterizes a tuple in the yield of a
non-terminal. A rule instantiation specifies the computation of an element from the left-
hand side yield from elements in the yields of the right-hand side non-terminals based
on the corresponding range vectors.
</bodyText>
<subsectionHeader confidence="0.525041">
Definition 6 (Range)
</subsectionHeader>
<bodyText confidence="0.850977">
Let w E T∗ with w = w1 ... wn where wi E T for 1 &lt; i &lt; n.
</bodyText>
<listItem confidence="0.985760428571429">
1. Pos(w) := {0,...,n}.
2. We call a pair (l, r) E Pos(w) x Pos(w) with l &lt; r a range in w. Its yield
(l, r)(w) is the substring wl+1 ... wr.
3. For two ranges p1 = (l1, r1), p2 = (l2, r2), if r1 = l2, then the concatenation
of p1 and p2 is p1 · p2 = (l1, r2); otherwise p1 · p2 is undefined.
4. A p~ E (Pos(w) x Pos(w))k is a k-dimensional range vector for w iff
p� = ((l1, r1), ... , (lk, rk)) where (li, ri) is a range in w for 1 &lt; i &lt; k.
</listItem>
<bodyText confidence="0.9863782">
We now define instantiations of rules with respect to a given input string. This
definition follows the definition of clause instantiations from Boullier (2000). An in-
stantiated rule is a rule in which variables are consistently replaced by ranges. Because
we need this definition only for parsing our specific grammars, we restrict ourselves to
F--free rules containing only variables.
</bodyText>
<construct confidence="0.403581">
Definition 7 (Rule instantiation)
</construct>
<listItem confidence="0.940949571428571">
Let G = (N, T, V, P, S) be an F--free monotone LCFRS. For a given rule r = A(a) -+
A1(*x1) · · · Am( &apos;xm) E P (0 &lt; m) that does not contain any terminals,
1. an instantiation with respect to a string w = t1 ... tn consists of a function
f : V -+ {(i, j) J1 &lt; i &lt; j &lt; JwJ} such that for all x, y adjacent in one of the
elements of &amp;, f(x) · f(y) must be defined; we then define f (xy) = f(x) · f (y),
2. if f is an instantiation of r, then A(f (a)) -+ A1( f (z1)) · · · Am(f (x&apos;m)) is an
instantiated rule where f ((x1, ... , xk)) = (f (x1), ... ,f (xk)).
</listItem>
<bodyText confidence="0.979374384615385">
We use a probabilistic version of the CYK parser from Seki et al. (1991). The algo-
rithm is formulated using the framework of parsing as deduction (Pereira and Warren
1983; Shieber, Schabes, and Pereira 1995; Sikkel 1997), extended with weights (Nederhof
2003). In this framework, a set of weighted items representing partial parsing results is
characterized via a set of deduction rules, and certain items (the goal items) represent
successful parses.
During parsing, we have to match components in the rules we use with portions of
the input string. For a given input w, our items have the form [A, -p] where A E N and p~
is a range vector that characterizes the span of A. Each item has a weight in that encodes
the Viterbi inside score of its best parse tree. More precisely, we use the log probability
log(p) where p is the probability.
The first rule (scan) tells us that the POS tags that we receive as inputs are given.
Consequently, they are axioms; their probability is 1 and their weight therefore 0. The
</bodyText>
<page confidence="0.992396">
97
</page>
<figure confidence="0.978400125">
Computational Linguistics Volume 39, Number 1
Scan: 0 : [A, ((i, i + 1))] A is the POS tag of wi+1
Unary: in : [B, A(a) → B(a) ∈ P
y in + log(p) : [A, I p
inB : [B, ��B], inC : [C, ��C] p : A( �pA) → B( �pB)C( �pC)
Binary:
inB + inC + log(p) : [A, PA] is an instantiated rule
Goal: [S, ((0,n))]
</figure>
<figureCaption confidence="0.6268705">
Figure 10
Weighted CYK deduction system.
</figureCaption>
<bodyText confidence="0.992301846153846">
second rule, unary, is applied whenever we have found the right-hand side of an
instantiation of a unary rule. In our grammar, terminals only occur in rules with POS
tags and the grammar is ordered and F--free. Therefore, the components of the yield of
the right-hand side non-terminal and of the left-hand side terminals are the same. The
rule binary applies an instantiated rule of rank 2. If we already have the two elements
of the right-hand side, we can infer the left-hand side element. In both cases, unary
and binary, the probability p of the new rule is multiplied with the probabilities of the
antecedent items (which amounts to summing up the antecedent weights and log(p)).
We perform weighted deductive parsing, based on the deduction system from
Figure 10. We use a chart C and an agenda A, both initially empty, and we proceed
as in Figure 11. Because for all our deduction rules, the weight functions f that compute
the weight of a consequent item from the weights of the antecedent items are monotone
non-increasing in each variable, the algorithm will always find the best parse without
the need of exhaustive parsing. All new items that we deduce involve at least one of
the agenda items as an antecedent item. Therefore, whenever an item is the best in the
agenda, we can be sure that we will never find an item with a better (i.e., higher) weight.
Consequently, we can safely store this item in the chart and, if it is a goal item, we have
found the best parse.
As an example consider the development of the agenda and the chart in Figure 12
when parsing aa with the PLCFRS from Figure 5, transformed into a PLCFRS with
pre-terminals and binarization (i.e., with a POS tag Ta and a new binarization non-
terminal B&apos;). The new PLCFRS is given in Figure 13.
In this example, we find a first analysis for the input (a goal item) when combining
an A with span ((0,2)) into an S. This S has however a rather low probability and is
therefore not on top of the agenda. Later, when finding the better analysis, the weight
add SCAN results to A
</bodyText>
<construct confidence="0.8229575">
while A =� ∅
remove best item x : I from A
add x : I to C
if I goal item
then stop and output true
else
for all y : I~ deduced from x : I and items in C:
if there is no z with z : I&apos; E C U A
then add y : I~ to A
else if z : I~ E A for some z
</construct>
<bodyText confidence="0.644967">
then update weight of I~ in A to max(y, z)
</bodyText>
<figureCaption confidence="0.704515">
Figure 11
</figureCaption>
<bodyText confidence="0.704627">
Weighted deductive parsing.
</bodyText>
<page confidence="0.992079">
98
</page>
<figure confidence="0.996792875">
Kallmeyer and Maier PLCFRS Parsing
chart agenda
0 : [Ta, (0,1)],0 : [Ta, (1,2)]
0 : [Ta, (0, 1)] 0 : [Ta, (1,2)], −0.5 : [A, (0, 1)]
0 : [Ta, (0,1)], 0 : [Ta, (1, 2)] −0.5 : [A, (0,1)], −0.5 : [A, (1,2)],
−0.7 : [B, (0, 1), (1,2)]
0 : [Ta, (0,1)], 0 : [Ta, (1,2)], −0.5 : [A, (1,2)],−0.7 : [B, (0, 1), (1,2)],
−0.5 : [A, (0, 1)] −1.2 : [S, (0, 1)]
0 : [Ta, (0,1)], 0 : [Ta, (1,2)], −0.65 : [A, (0,2)],−0.7 : [B, (0, 1), (1,2)],
0.5 : [A, (0,1)], −0.5 : [A, (1,2)] −1.2 : [S, (0,1)], −1.2 : [S, (1, 2)]
0 : [Ta, (0,1)], 0 : [Ta, (1,2)], −0.7 : [B, (0, 1), (1,2)],−1.2 : [S, (0,1)],
−0.5 : [A,(0,1)],−0.5 : [A,(1,2)], −1.2 : [S, (1, 2)], −1.35 : [S, (0, 2)]
−0.65 : [A, (0,2)]
0 : [Ta, (0,1)], 0 : [Ta, (1,2)], (1, 2)] −0.8 : [S, (0,2)],−1.2 : [S, (0,1)],
−0.5 : [A, (0,1)], −0.5 : [A, (1,2)], −1.2 : [S, (1, 2)]
−0.65 : [A, (0,2)], −0.7 : [B, (0, 1),
</figure>
<figureCaption confidence="0.934172">
Figure 12
</figureCaption>
<bodyText confidence="0.641365">
Parsing of aa with the grammar from Figure 5.
</bodyText>
<equation confidence="0.944854">
PLCFRS with non-terminals {S, A, B, B&apos;, Ta}, terminals {a} and start symbol S:
0.2 : S(X) -+ A(X) 0.8 : S(XY) -+ B(X,Y)
0.7 : A(XY) -+ Ta(X)A(Y) 0.3 : A(X) -+ Ta(X)
0.8 : B(ZX,Y) -+ Ta(Z)B&apos;(X, Y) 1 : B&apos;(X, UY) -+ B(X,Y)Ta(U)
0.2 : B(X,Y) -+ Ta(X)Ta(Y) 1 : Ta(a) -+ e
</equation>
<figureCaption confidence="0.570567">
Figure 13
</figureCaption>
<bodyText confidence="0.964961222222222">
Sample binarized PLCFRS (with pre-terminal Ta).
of the S item in the agenda is updated and then the goal item is the top agenda item and
therefore parsing has been successful.
Note that, so far, we have only presented the recognizer. In order to extend it to a
parser, we do the following: Whenever we generate a new item, we store it not only with
its weight but also with backpointers to its antecedent items. Furthermore, whenever
we update the weight of an item in the agenda, we also update the backpointers. In
order to read off the best parse tree, we have to start from the goal item and follow the
backpointers.
</bodyText>
<sectionHeader confidence="0.976646" genericHeader="method">
4. Outside Estimates
</sectionHeader>
<bodyText confidence="0.999798125">
So far, the weights we use give us only the Viterbi inside score of an item. In order
to speed up parsing, we add the estimate of the costs for completing the item into a
goal item to its weight—that is, to the weight of each item in the agenda, we add an
estimate of its Viterbi outside score2 (i.e., the logarithm of the estimate). We use context
summary estimates. A context summary is an equivalence class of items for which we
can compute the actual outside scores. Those scores are then used as estimates. The
challenge is to choose the estimate general enough to be efficiently computable and
specific enough to be helpful for discriminating items in the agenda.
</bodyText>
<footnote confidence="0.915533">
2 Note that just as Klein and Manning (2003a), we use the terms inside score and outside score to
denote the Viterbi inside and outside scores. They are not to be confused with the actual inside or
outside probability.
</footnote>
<page confidence="0.992414">
99
</page>
<note confidence="0.285002">
Computational Linguistics Volume 39, Number 1
</note>
<bodyText confidence="0.999444866666667">
Admissibility and monotonicity are two important conditions on estimates. All
our outside estimates are admissible (Klein and Manning 2003a), which means that
they never underestimate the actual outside score of an item. In other words, they
are too optimistic about the costs of completing the item into an S item spanning the
entire input. For the full SX estimate described in Section 4.1 and the SX estimate with
span and sentence length in Section 4.4, the monotonicity is guaranteed and we can do
true A* parsing as described by Klein and Manning. Monotonicity means that for each
antecedent item of a rule it holds that its weight is greater than or equal to the weight
of the consequent item. The estimates from Sections 4.2 and 4.3 are not monotonic. This
means that it can happen that we deduce an item I2 from an item I1 where the weight of
I2 is greater than the weight of I1. The parser can therefore end up in a local maximum
that is not the global maximum we are searching for. In other words, those estimates are
only figures of merit (FOM).
All outside estimates are computed off-line for a certain maximal sentence length
lenmax.
</bodyText>
<subsectionHeader confidence="0.981415">
4.1 Full SX Estimate
</subsectionHeader>
<bodyText confidence="0.999960555555556">
The full SX estimate is a PLCFRS adaption of the SX estimate of Klein and Manning
(2003a) (hence the name). For a given sentence length n, the estimate gives the maximal
probability of completing a category X with a span p into an S with span ((0, n)).
For its computation, we need an estimate of the inside score of a category C with a
span p, regardless of the actual terminals in our input. This inside estimate is computed
as shown in Figure 14. Here, we do not need to consider the number of terminals outside
the span of C (to the left or right or in the gaps), because they are not relevant for the
inside score. Therefore the items have the form [A, (l1,...,ldim(A))], where A is a non-
terminal and li gives the length of its ith component. It holds that
</bodyText>
<equation confidence="0.633441">
Σ1&lt;i&lt;dim(A)li &lt; lenmax − dim(A) + 1
</equation>
<bodyText confidence="0.999727125">
because our grammar extraction algorithm ensures that the different components in
the yield of a non-terminal are never adjacent. There is always at least one terminal in
between two different components that does not belong to the yield of the non-terminal.
The first rule in Figure 14 tells us that POS tags always have a single component
of length 1; therefore this case has probability 1 (weight 0). The rules unary and binary
are roughly like the ones in the CYK parser, except that they combine items with length
information. The rule unary for instance tells us that if the log of the probability of
building [B,11 is greater or equal to in and if there is a rule that allows to deduce an
</bodyText>
<equation confidence="0.747535875">
POS tags: 0 : [A, (1)] A a POS tag Unary: in + log(p) : [A,
1] p : A(&amp;) -+ B(a) E P
in : [B,11
�lB], inC : [C, �lC]
�lA]
where p : A( aA) -+ B( 6B)C( %) E P and the following holds: we define B(i) as
{1 &lt; j &lt; dim(B)  |aB(j) occurs in oA(i)} and C(i) as {1 &lt; j &lt; dim(C)  |aC(j) occurs in OA(i)}.
Then for all i, 1 &lt; i &lt; dim(A): IA(i) = ΣjEB(i)IB(j) + ΣjEC(i)�lC(j).
</equation>
<figureCaption confidence="0.844957">
Figure 14
</figureCaption>
<bodyText confidence="0.867128">
Estimate of the Viterbi inside score.
</bodyText>
<equation confidence="0.933284615384615">
inB : [B,
Binary:
inB + inC + log(p) : [A,
100
Kallmeyer and Maier PLCFRS Parsing
out: [A, 1] 1] p : A(&amp;) → B(a) E P
Axiom : 1 &lt; len &lt; len.. Unary: g(p) . [
0 : [S, (0, len, 0)] — — out + lo B,
out : [X,�lX]
Binary-right:
out + in(A,�l�A) + log(p) : [B,&apos;lB]
out: [X,
Binary-left: out + in(B,IB) + log(p) : [A,&apos;lA]
</equation>
<bodyText confidence="0.642264">
where, for both binary rules, there is an instantiated rule p : X(p- A( pA)B( pB) such that
</bodyText>
<equation confidence="0.934251">
�l�A = lin(ρA), lB = lout(ρB), PB = lin(ρB).
lX
ρ
,l
t
ρ
,
= lout(
)
A = lou
(
A)
Figure 15
Full SX estimate first version (top–down).
~l]
</equation>
<bodyText confidence="0.905619489795918">
where the
(
us about the lengths of the string to the left of the first component,
the first component, the string in between the first and second component, and so on.
The algorithm proceeds
The outside estimate of completing an S with
component length len and no terminals to the left or to the right of the S component
(item [S, (0, len,
is 0. If we expand with a unary rule (unary), then the outside
estimate of the right-hand side item is greater or equal to the outside estimate of the
left-hand side item plus the log of the probability of the rule. In the case of binary rules,
we have to further add the inside estimate of the other daughter. For this, we need a
different length vector (without the lengths of the parts in between the components).
Therefore, for a given range vector
=
r1), ... , (lk, rk)) and a sentence length n,
we distinguish between the inside length vector
lk) and the
outside length vector
r1
,
rk
n
rk).
This algorithm has two major problems: Because it proceeds
in the
binary rules we must compute all splits of the antecedent X span into the spans of
A and B, which is very expensive. Furthermore, for a category A with a certain number
of terminals in the components and the gaps, we compute the lower part of the outside
estimate several times, namely, for every combination of number of terminals to the left
and to the right (first and last element in the outside length vector). In order to avoid
these problems, we now abstract away from the lengths of the part to the left and the
right, modifying our items such as to allow
strategy.
The idea is to compute the weights of items representing the derivations from a
certain lower C up to some A (C is a kind of
in the yield of A) while summing up
the inside costs of off-spine nodes and the log of the probabilities of the corresponding
rules. We use items [A, C,
shift] where A, C E N and
are range vectors, both
with a first component starting at position 0. The integer shift &lt;
tells us how many
positions to the right the C span is shifted, compared to the starting position of the A.
and
represent the spans of C and A while disregarding the number of terminals
to the left and the right (i.e., only the lengths of the components and of the gaps are
encoded). This means in particular that the length n of the sentence does not play a
role here. The right boundary of the last range in the vectors is limited to
</bodyText>
<equation confidence="0.9727017">
vector
tells
top–down.
0)])
ρ
((l1,
lin(ρ)=(r1 − l1,...,rk−
lout(ρ)=(l1,
− l1,l2−r1,...
lk−rk−1,
− lk,
−
top–down,
a bottom–up
“gap”
ρA,ρC,
ρA,ρC
lenmax
ρA
ρC
</equation>
<bodyText confidence="0.982441142857143">
lenmax. For
A item from [B,11 with probability p, then the log of the probability of [A,11 is greater
or equal to in + log(p). For each item, we record its maximal weight (i.e., its maximal
probability). The rule binary is slightly more complicated because we have to compute
the length vector of the left-hand side of the rule from the right-hand side length vectors.
A straightforward extension of the CFG algorithm from Klein and Manning (2003a)
for computing the SX estimate is given in Figure 15. Here, the items have the form [A,
</bodyText>
<page confidence="0.985716">
101
</page>
<figure confidence="0.8990095">
�lX]
Computational Linguistics Volume 39, Number 1
</figure>
<bodyText confidence="0.9974133">
any i, 0 &lt; i &lt; lenmax, and any range vector ρ, we define shift(ρ, i) as the range vector one
obtains from adding i to all range boundaries in ρ and shift(ρ,−i) as the range vector
one obtains from subtracting i from all boundaries in ρ.
The weight of [A, C, ρA, ρC, i] estimates the log of the probability of completing a
C tree with yield ρC into an A tree with yield ρA such that, if the span of A starts at
position j, the span of C starts at position i + j. Figure 16 gives the computation. The
value of in(A,0 is the inside estimate of [A, 11.
The SX-estimate for some predicate C with span ρ where i is the left boundary of the
first component of ρ and with sentence length n is then given by the maximal weight of
[S, C, (0, n), shift(ρ, −i), i].
</bodyText>
<subsectionHeader confidence="0.988737">
4.2 SX with Left, Gaps, Right, Length
</subsectionHeader>
<bodyText confidence="0.987042">
A problem of the previous estimate is that with a large number of non-terminals (for
treebank parsing, approximately 12,000 after binarization and markovization), the com-
putation of the estimate requires too much space. We therefore turn to simpler estimates
with only a single non-terminal per item. We now estimate the outside score of a non-
terminal A with a span of a length length (the sum of the lengths of all the components
of the span), with left terminals to the left of the first component, right terminals to the
right of the last component, and gaps terminals in between the components of the A
span (i.e., filling the gaps). Our items have the form [X, len, left, right, gaps] with X E N,
len + left + right + gaps &lt; lenmax, len &gt; dim(X), gaps &gt; dim(X) − 1.
Let us assume that, in the rule X(a) -+ A( oA)B( 6αB), when looking at the vector ot,
we have leftA variables for A-components preceding the first variable of a B component,
rightA variables for A-components following the last variable of a B component, and
rightB variables for B-components following the last variable of an A component. (In our
grammars, the first left-hand side argument always starts with the first variable from A.)
Furthermore, we set gapsA = dim(A) − leftA − rightA and gapsB = dim(B) − rightB.
Figure 17 gives the computation of the estimate. It proceeds top–down, as the
computation of the full SX estimate in Figure 15, except that now the items are simpler.
</bodyText>
<equation confidence="0.994289444444445">
POS tags: 0 : [C, C, (0, 1), (0, 1), 0] C a POS tag
0 : [B, B, ρB, ρB, 0] Unary: log(p) : [A, B, ρB, ρB, 0]
p : A(Yα) → B(Yα) ∈ P
0 : [A, A, ρA, ρA, 0], 0 : [B, B, ρB, ρB, 0]
Binary-right:
in(A, lin(ρA)) + log(p) : [X, B, ρX, ρB, i]
0 : [A, A, ρA, ρA, 0], 0 : [B, B, ρB, ρB, 0]
Binary-left:
in(B, lin(ρB)) + log(p) : [X, A, ρX, ρA, i]
</equation>
<bodyText confidence="0.913501">
where i is such that for shift(ρB, i) = ρB p : X(ρX) -+ A(ρA)B(ρB) is an instantiated rule.
Starting sub-trees with larger gaps: out : [B, C, ρB, ρC, i]0 : [B, B, ρB, ρB, 0]
Transitive closure of sub-tree combination: out1 : [A, B, ρA, ρB, i], out2 : [B, C, ρB, ρC,j] out1 + out2 : [A, C, ρA, ρC, i + j]
</bodyText>
<footnote confidence="0.3833735">
Figure 16
Full SX estimate second version (bottom–up).
</footnote>
<page confidence="0.97547">
102
</page>
<equation confidence="0.807872375">
Kallmeyer and Maier PLCFRS Parsing
Axiom: 0 : [S, len, 0, 0, 0] 1 &lt; len &lt; lenmax
out: [X, len, l, r, g]
Unary: out + log(p) : [A, len, l, r, g]
p : X(Yα) -+ A(Yα) E P
out : [X, len, l, r, g]
Binary-right: out + in(A, len − lenB) + log(p) : [B, lenB, lB, rB,gB]
out : [X, len, l, r, g]
</equation>
<bodyText confidence="0.895872333333333">
Binary-left: out + in(B, len − lenA) + log(p) : [A, lenA, lA, rA,gA]
where, for both binary rules, p : X(a) -+ A( aA)B( dB) E P.
Further side conditions for Binary-right:
</bodyText>
<equation confidence="0.6749532">
a) len + l + r + g = lenB + lB + rB + gB, b) lB &gt; l + leftA,
c) if rightA &gt; 0, then rB &gt; r + rightA, else (rightA = 0), rB = r, d) gB &gt; gapsA.
Further side conditions for Binary-left:
a) len + l + r + g = lenA + lA + rA + gA, b) lA = l,
c) if rightB &gt; 0, then rA &gt; r + rightB, else (rightB = 0), rA = r d) gA &gt; gapsB.
</equation>
<figureCaption confidence="0.710546">
Figure 17
</figureCaption>
<bodyText confidence="0.895086666666667">
SX estimate depending on length, left, right, gaps.
The value in(X,l) for a non-terminal X and a length l, 0 &lt; l &lt; lenmax is an estimate
of the probability of an X category with a span of length l. Its computation is specified
in Figure 18.
The SX-estimate for a sentence length n and for some predicate C with a range
characterized by ρ� = ((l1, r1),... , (ldim(C), rdim(C))) where len = Edi(C
</bodyText>
<equation confidence="0.8081295">
) (ri − li) and r =
n − rdim(C) is then given by the maximal weight of the item [C, len, l1, r, n − len − l1 − r].
</equation>
<subsectionHeader confidence="0.788714">
4.3 SX with LR, Gaps, Length
</subsectionHeader>
<bodyText confidence="0.990576166666667">
In order to further decrease the space complexity of the computation of the outside
estimate, we can simplify the previous estimate by subsuming the two lengths left and
right in a single length lr. The items now have the form [X, len, lr, gaps] with X E N,
len + lr + gaps &lt; lenmax, len &gt; dim(X), gaps &gt; dim(X) − 1.
The computation is given in Figure 19. Again, we define leftA, gapsA, rightA and
gapsB, rightB for a rule X(a) -+ A( otA)B( CαB) as before. Furthermore, in both Binary-left
and Binary-right, we have limited lr in the consequent item to the lr of the antecedent
plus the length of the sister (lenB, resp. lenA). This results in a further reduction of the
number of items while having only little effect on the parsing results.
The SX-estimate for a sentence length n and for some predicate C with a span
ρ� = ((l1, r1), . . . , (ldim(C), rdim(C))) where len = Edim(C) i=1(ri − li) and r = n − rdim(C) is then the
maximal weight of [C, len, l1 + r, n − len − l1 − r].
</bodyText>
<equation confidence="0.9543362">
POS tags: A a POS tag Unary: in : [B, l] p : A(Yα) -+ B(Yα) E P
0 : [A, 1] in + log(p) : [A, l]
inB : [B, lB], inC : [C, lC]
Binary:
inB + inC + log(p) : [A, lB + lC]
</equation>
<bodyText confidence="0.952234">
where either p : A( oA) -+ B( 6B)C( %) E P or p : A( aA) -+ C( aC)B( 6B) E P.
</bodyText>
<figureCaption confidence="0.602811">
Figure 18
</figureCaption>
<bodyText confidence="0.795458">
Estimate of the inside score with total span length.
</bodyText>
<page confidence="0.989505">
103
</page>
<figure confidence="0.735144230769231">
Computational Linguistics Volume 39, Number 1
Axiom: 0 : [S, len, 0, 0] 1 &lt; len &lt; lenmax
out : [X, len, lr, g]
Unary: out + log(p) : [A, len, lr, g] p : X(a) A(a) E P
out : [X, len, lr,g]
Binary-right: p : X(a) A( aA)B( aB) E P
out + in(A, len − lenB) + log(p) : [B, lenB, lrB,gB]
Bina left: out : [X, len, lr, g] X( a) A( aA)B( aB) E P
Binary -left: + in(B, len − lenA) + log(p) : [A, lenA, lrA,gA] p :
Further side conditions for Binary-right:
a) len + lr + g = lenB + lrB + gB b) lr &lt; lrB c) gB &gt; gapsA
Further side conditions for Binary-left:
a) len + lr + g = lenA + lrA + gA b) if rightB = 0 then lr = lrA, else lr &lt; lrA c) gA &gt; gapsB
</figure>
<figureCaption confidence="0.974468">
Figure 19
</figureCaption>
<bodyText confidence="0.877785">
SX estimate depending on length, LR, gaps.
</bodyText>
<subsectionHeader confidence="0.997798">
4.4 SX with Span and Sentence Length
</subsectionHeader>
<bodyText confidence="0.990362705882353">
We will now present a further simplification of the last estimate that records only the
span length and the length of the entire sentence. The items have the form [X, len, slen]
with X E N, dim(X) &lt; len &lt; slen. The computation is given in Figure 20. This last esti-
mate is actually monotonic and allows for true A* parsing.
The SX-estimate for a sentence length n and for some predicate C with a span
p = ((l1,r1), . . ., (ldim(C), rdim(C))) where len = Σdim(C) i=1(ri − li) is then the maximal weight
of [C, len, n].
In order to prove that this estimate allows for monotonic weighted deductive pars-
ing and therefore guarantees that the best parse will be found, let us have a look at the
CYK deduction rules when being augmented with the estimate. Only Unary and Binary
are relevant because Scan does not have antecedent items. The two rules, augmented
with the outside estimate, are shown in Figure 21.
We have to show that for every rule, if this rule has an antecedent item with weight
w and a consequent item with weight w&apos;, then w &gt; w&apos;.
Let us start with Unary. To show: inB + outB &gt; inB + log(p) + outA. Because of the
Unary rule for computing the outside estimate and because of the unary production,
Axiom: 0 : [S, len, len] 1 &lt; len &lt; lenmax
</bodyText>
<equation confidence="0.976410166666667">
out: [X, lX, slen]
Unary: out + log(p) : [A, lX, slen] p : X(a) A(a) E P
out: [X, lX, slen]
Binary-right: out + in(A, lX − lB) + log(p) : [B, lB, slen] p : X(a) A(aA)B(aB) E P
Binary-left: out : [X, lX,slen]p : X(a) A( aA)B( aB) E P
out + in(B, lX − lA) + log(p) : [A, lA, slen]
</equation>
<figureCaption confidence="0.64158">
Figure 20
</figureCaption>
<bodyText confidence="0.556081">
SX estimate depending on span and sentence length.
</bodyText>
<page confidence="0.96177">
104
</page>
<note confidence="0.594289">
Kallmeyer and Maier PLCFRS Parsing
</note>
<equation confidence="0.9069924">
inB + outB : [B, pj
Unary: inB + log(p) + outA : [A, p : A(a) → B(a) ∈ P
inB + outB : [B, ��B], inC + outC : [C, ��C] p : A( �PA) → B( �PB)C( �PC)
Binary:
inB + inC + log(p) + outA : [A, pA] is an instantiated rule
</equation>
<bodyText confidence="0.331161">
(Here, outA, outB, and outC are the respective outside estimates of [A, pA], [B, pB] and [C, pc].)
</bodyText>
<figureCaption confidence="0.698895">
Figure 21
</figureCaption>
<bodyText confidence="0.900176090909091">
Parsing rules including outside estimate.
we obtain that, given the outside estimate outA of [A, pj the outside estimate outB of the
item [B, pj is at least outA + log(p), namely, outB &gt; log(p) + outA.
Now let us consider the rule Binary. We treat only the relation between the weight
of the C antecedent item and the consequent. The treatment of the antecedent B is
symmetric. To show: inC + outC &gt; inB + inC + log(p) + outA. Assume that lB is the length
of the components of the B item and n is the sentence length. Then, because of the
Binary-right rule in the computation of the outside estimate and because of our in-
stantiated rule p : A( WA) -+ B( pB)C( Wc), we have that the outside estimate outC of the
C-item is at least outA + in(B, lB) + log(p). Furthermore, in(B, lB) &gt; inB. Consequently
outC &gt; inB + log(p) + outA.
</bodyText>
<subsectionHeader confidence="0.699246">
4.5 Integration into the Parser
</subsectionHeader>
<bodyText confidence="0.999946307692308">
Before parsing, the outside estimates of all items up to a certain maximal sentence length
lenmax are precomputed. Then, when performing the weighted deductive parsing as
explained in Section 3.2, whenever a new item is stored in the agenda, we add its outside
estimate to its weight.
Because the outside estimate is always greater than or equal to the actual outside
score, given the input, the weight of an item in the agenda is always greater than or
equal to the log of the actual product of the inside and outside score of the item. In this
sense, the outside estimates given earlier are admissible.
Additionally, as already mentioned, note that the full SX estimate and the SX esti-
mate with span and sentence length are monotonic and allow for A∗ parsing. The other
two estimates, which are both not monotonic, act as FOMs in a best-first parsing context.
Consequently, they contribute to speeding up parsing but they decrease the quality of
the parsing output. For further evaluation details see Section 6.
</bodyText>
<sectionHeader confidence="0.750066" genericHeader="method">
5. Grammars for Discontinuous Constituents
5.1 Grammar Extraction
</sectionHeader>
<bodyText confidence="0.9992404">
The algorithm we use for extracting an LCFRS from a constituency treebank with cross-
ing branches has originally been presented in Maier and Søgaard (2008). It interprets
the treebank trees as LCFRS derivation trees. Consider for instance the tree in Figure 22.
The S node has two daughters, a VMFIN node and a VP node. This yields a rule
S -+ VP VMFIN. The VP is discontinuous with two components that wrap around the
yield of the VMFIN. Consequently, the LCFRS rule is S(XYZ) -+ VP(X,Z) VMFIN(Y).
The extraction of an LCFRS from treebanks with crossing branches is almost im-
mediate, except for the fan-out of the non-terminal categories: In the treebank, we can
have the same non-terminal with different fan-outs, for instance a VP without a gap
(fan-out 1), a VP with a single gap (fan-out 2), and so on. In the corresponding LCFRS,
</bodyText>
<page confidence="0.981638">
105
</page>
<figure confidence="0.972599">
Computational Linguistics Volume 39, Number 1
VP
S
VP
PROAV VMFIN VVPP VAINF
dar¨uber muß nachgedacht werden
about it must thought be
“It must be thought about it”
</figure>
<figureCaption confidence="0.928504">
Figure 22
</figureCaption>
<bodyText confidence="0.9836580625">
A sample tree from NeGra.
we have to distinguish these different non-terminals by mapping them to different
predicates.
The algorithm first creates a so-called lexical clause P(a) -+ e for each pre-terminal
P dominating some terminal a. Then for all other non-terminals A0 with the children
A1 · · · Am, a clause A0 -+ A1 · · · Am is created. The number of components of the A1 · · · Am
is the number of discontinuous parts in their yields. The components of A0 are concate-
nations of variables that describe how the discontinuous parts of the yield of A0 are
obtained from the yields of its daughters.
More precisely, the non-terminals in our LCFRS are all Ak where A is a non-terminal
label in the treebank and k is a possible fan-out for A. For a given treebank tree (V, E, r,l)
where V is the set of nodes, E C V x V the set of immediate dominance edges, r E V
the root node, and l : V -+ N U T the labeling function, the algorithm constructs the
following rules. Let us assume that w1, ... , wn are the terminal labels of the leaves
in (V, E, r) with a linear precedence relation wi � wj for 1 &lt; i &lt; j &lt; n. We introduce a
variable Xi for every wi, 1 &lt; i &lt; n.
</bodyText>
<listItem confidence="0.9199102">
• For every pair of nodes v1, v2 E V with (v2, v2) E E, l(v2) E T, we add
l(v1)(l(v2)) -+ e to the rules of the grammar. (We omit the fan-out subscript
here because pre-terminals are always of fan-out 1.)
• For every node v E V with l(v) = A0 E/ T such that there are exactly m
nodes v1, ... , vm E V (m &gt; 1) with (v, vi) E E and l(vi) = Ai E/ T for all
</listItem>
<equation confidence="0.995883444444444">
1 &lt; i &lt; m, we now create a rule
A0(x(0)
1 ,...,x(0)
dim(A0))
-+ A1(x(1)
1 , ... , x(1)
dim(A1)) ... Am(x(m)
1 , ... , x(m)
dim(Am))
</equation>
<bodyText confidence="0.999384">
where for the predicate Ai, 0 &lt; i &lt; m, the following must hold:
</bodyText>
<listItem confidence="0.639518125">
1. The concatenation of all arguments of Ai, x(i)
1 ... x(i)
dim(Ai) is the
concatenation of all X E {Xi  |(vi, vl) E E* with l(vl) = wi} such that
Xi precedes Xj if i &lt; j, and
2. a variable Xj with 1 &lt; j &lt; n is the right boundary of an argument of
Ai if and only if Xj+1 E/ {Xi  |(vi, vl) E E* with l(vl) = wi}, that is, an
argument boundary is introduced at each discontinuity.
</listItem>
<bodyText confidence="0.9992875">
As a further step, in this new rule, all right-hand side arguments of length
&gt; 1 are replaced in both sides of the rule with a single new variable.
Finally, all non-terminals A in the rule are equipped with an additional
subscript dim(A), which gives us the final non-terminal in our LCFRS.
</bodyText>
<page confidence="0.97834">
106
</page>
<note confidence="0.598652">
Kallmeyer and Maier PLCFRS Parsing
</note>
<equation confidence="0.999108">
PROAV(Dar¨uber) → e
VMFIN(muB) → e
VVPP(nachgedacht) → e
VAINF(werden) → e
S1(X1X2X3) → VP2(X1,X3)VMFIN(X2)
VP2(X1,X2X3) → VP2(X1,X2)VAINF(X3)
VP2(X1,X2) → PROAV(X1)VVPP(X2)
</equation>
<figureCaption confidence="0.618225">
Figure 23
</figureCaption>
<bodyText confidence="0.88803675">
LCFRS rules extracted from the tree in Figure 22.
For the tree in Figure 22, the algorithm produces for instance the rules in Figure 23.
As standard for PCFG, the probabilities are computed using Maximum Likelihood
Estimation.
</bodyText>
<subsectionHeader confidence="0.981792">
5.2 Head-Outward Binarization
</subsectionHeader>
<bodyText confidence="0.9998209">
As previously mentioned, in contrast to CFG the order of the right-hand side elements
of a rule does not matter for the result of an LCFRS derivation. Therefore, we can reorder
the right-hand side of a rule before binarizing it.
The following, treebank-specific reordering results in a head-outward binarization
where the head is the lowest subtree and it is extended by adding first all sisters to its
left and then all sisters to its right. It consists of reordering the right-hand side of the
rules extracted from the treebank such that first, all elements to the right of the head are
listed in reverse order, then all elements to the left of the head in their original order, and
then the head itself. Figure 24 shows the effect this reordering and binarization has on
the form of the syntactic trees. In addition to this, we also use a variant of this reordering
</bodyText>
<figure confidence="0.483289">
S
VP
Tree in NeGra format: NN VMFIN NN AV VAINF
das muB man jetzt machen
that must one now do
“One has to do that now”
Rule extracted for the S node: S(XYZU) → VP(X, U)VMFIN(Y)NN(Z)
Reordering for head-outward binarization: S(XYZU) → NN(Z)VP(X, U)VMFIN(Y)
New rules resulting from binarizing this rule:
S(XYZ) → Sbin1(X, Z)NN(Y) Sbin1(XY, Z) → VP(X, Z)VMFIN(Y)
Rule extracted for the VP node: VP(X,YZ) → NN(X)AV(Y)VAINF(Z)
New rules resulting from binarizing this rule:
VP(X,Y) → NN(X)VPbin1(Y) VPbin1(XY) → AV(X)VAINF(Y)
</figure>
<figureCaption confidence="0.752707">
Figure 24
</figureCaption>
<figure confidence="0.872028">
Sample head-outward binarization.
Sbin1
S
Tree after binarization:
NN VMFIN NN AV VAINF
VPbin1
VP
107
Computational Linguistics Volume 39, Number 1
</figure>
<bodyText confidence="0.9999565">
where we add first the sisters to the right and then the ones to the left. This is what Klein
and Manning (2003b) do. To mark the heads of phrases, we use the head rules that the
Stanford parser (Klein and Manning 2003c) uses for NeGra.
In all binarizations, there exists the possibility of adding additional unary rules
when deriving the head. This allows for a further factorization. In the experiments,
however, we do not insert unary rules, neither at the highest nor at the lowest new
binarization non-terminal, because this was neither beneficial for parsing times nor for
the parsing results.
</bodyText>
<subsectionHeader confidence="0.997043">
5.3 Incorporating Additional Context
</subsectionHeader>
<bodyText confidence="0.9945172">
5.3.1 Markovization. As already mentioned in Section 3.1, a binarization that introduces
unique new non-terminals for every single rule that needs to be binarized produces
a large amount of non-terminals and fails to capture certain generalizations. For this
reason, we introduce markovization (Collins 1999; Klein and Manning 2003b).
Markovization is achieved by introducing only a single new non-terminal for the
new rules introduced during binarization and adding vertical and horizontal context
from the original trees to each occurrence of this new non-terminal. As vertical context,
we add the first v labels on the path from the root node of the tree that we want to
binarize to the root of the entire treebank tree. The vertical context is collected during
grammar extraction and then taken into account during binarization of the rules. As
horizontal context, during binarization of a rule A(:α) → A0( :α0) ... Am( :αm), for the new
non-terminal that comprises the right-hand side elements Ai ... Am (for some 1 &lt; i &lt;
m), we add the first h elements of Ai, Ai−1, . . . , A0.
Figure 25 shows an example of a markovization of the tree from Figure 24 with v = 1
and h = 2. Here, the superscript is the vertical context and the subscript the horizontal
context of the new non-terminal X. Note that in this example we have disregarded the
fan-out of the context categories. The VP, for instance, is actually a VP2 because it has
fan-out 2. For the context symbols, one can either use the categories from the original
treebank (without fan-out) or the ones from the LCFRS rules (with fan-out). We chose
the latter approach because it delivered better parsing results.
</bodyText>
<subsubsectionHeader confidence="0.791663">
5.3.2 Further Category Splitting. Grammar annotation (i.e., manual enhancement of an-
</subsubsectionHeader>
<bodyText confidence="0.976486666666667">
notation information through category splitting) has previously been successfully used
in parsing German (Versley 2005). In order to see if such modifications can have a
beneficial effect in PLCFRS parsing as well, we perform different category splits on the
(unbinarized) NeGra constituency data.
We split the category S (“sentence”) into SRC (“relative clause”) and S (all other
categories S). Relative clauses mostly occur in a very specific context, namely, as the
</bodyText>
<figure confidence="0.978819428571428">
S
XVP,NN
VP
S
XVP
ADV,NN
NN VMFIN NN ADV VAINF
</figure>
<figureCaption confidence="0.930121">
Figure 25
</figureCaption>
<bodyText confidence="0.577205">
Sample markovization with v = 1, h = 2.
</bodyText>
<page confidence="0.995663">
108
</page>
<note confidence="0.935617">
Kallmeyer and Maier PLCFRS Parsing
</note>
<tableCaption confidence="0.985803">
Table 1
</tableCaption>
<figure confidence="0.360373">
NeGra: Properties of the data with crossing branches.
training test
</figure>
<figureCaption confidence="0.927388625">
number of sentences
average sentence length
average tree height
average children per node
sentences without gaps
sentences with one gap
sentences with ≥ 2 gaps
maximum gap degree
</figureCaption>
<table confidence="0.979241714285714">
16,502 1,833
14.56 14.62
4.62 4.72
2.96 2.94
12,481 (75.63%) 1,361 (74.25%)
3,320 (20.12%) 387 (21.11%)
701 (4.25%) 85 (4.64%)
</table>
<page confidence="0.363593">
6 5
</page>
<bodyText confidence="0.9994325">
right part of an NP or a PP. This splitting should therefore speed up parsing and increase
precision. Furthermore, we distinguish NPs by their case. More precisely, to all nodes
with categories N, we append the grammatical function label to the category label. We
finally experiment with the combination of both splits.
</bodyText>
<sectionHeader confidence="0.997938" genericHeader="evaluation">
6. Experiments
</sectionHeader>
<subsectionHeader confidence="0.588206">
6.1 Data
</subsectionHeader>
<bodyText confidence="0.9998383">
Our data source is the NeGra treebank (Skut et al. 1997). We create two different data
sets for constituency parsing. For the first one, we start out with the unmodified NeGra
treebank and remove all sentences with a length of more than 30 words. We pre-process
the treebank following common practice (K¨ubler and Penn 2008), attaching all nodes
which are attached to the virtual root node to nodes within the tree such that, ideally,
no new crossing edges are created. In a second pass, we attach punctuation which
comes in pairs (parentheses, quotation marks) to the same nodes. For the second data
set we create a copy of the pre-processed first data set, in which we apply the usual
tree transformations for NeGra PCFG parsing (i.e., moving nodes to higher positions
until all crossing branches are resolved). The first 90% of both data sets are used as the
training set and the remaining 10% as test set. The first data set is called NeGraLCFxS
and the second is called NeGraCFG.
Table 1 lists some properties of the training and test (respectively, gold) parts of
NeGraLCFxS, namely, the total number of sentences, the average sentence length, the
average tree height (the height of a tree being the length of the longest of all paths
from the terminals to the root node), and the average number of children per node
(excluding terminals). Furthermore, gap degrees (i.e., the number of gaps in the spans
of non-terminal nodes) are listed (Maier and Lichte 2011).
Our findings correspond to those of Maier and Lichte except for small differences
due to the fact that, unlike us, they removed the punctuation from the trees.
</bodyText>
<subsectionHeader confidence="0.993578">
6.2 Parser Implementation
</subsectionHeader>
<bodyText confidence="0.997917">
We have implemented the CYK parser described in the previous section in a system
called rparse. The implementation is realized in Java.3
</bodyText>
<footnote confidence="0.936144">
3 rparse is available under the GNU General Public License 2.0 at http://www.phil.hhu.de/rparse.
</footnote>
<page confidence="0.994542">
109
</page>
<table confidence="0.427617">
Computational Linguistics Volume 39, Number 1
</table>
<tableCaption confidence="0.992081">
Table 2
</tableCaption>
<table confidence="0.994498375">
NeGraLCFRS: PLCFRS parsing results for different binarizations.
Head-driven KM L-to-R Optimal Deterministic
LP 74.00 74.00 75.08 74.92 72.40
LR 74.24 74.13 74.69 74.88 71.80
LF1 74.12 74.07 74.88 74.90 72.10
UP 77.09 77.20 77.95 77.77 75.67
UR 77.34 77.33 77.54 77.73 75.04
UF1 77.22 77.26 77.75 77.75 75.35
</table>
<subsectionHeader confidence="0.955106">
6.3 Evaluation
</subsectionHeader>
<bodyText confidence="0.999964125">
For the evaluation of the constituency parses, we use an EVALB-style metric. For a tree
over a string w, a single constituency is represented by a tuple (A, p) with A being a
node label and ρ� E (Pos(w) x Pos(w))dim(A). We compute precision, recall, and F1 based
on these tuples from gold and de-binarized parsed test data from which all category
splits have been removed. This metric is equivalent to the corresponding PCFG metric
for dim(A) = 1. Despite the shortcomings of such a measure (Rehbein and van Genabith
2007), it still allows to some extent a comparison to previous work in PCFG parsing (see
also Section 7). Note that we provide the parser with gold POS tags in all experiments.
</bodyText>
<subsectionHeader confidence="0.997577">
6.4 Markovization and Binarization
</subsectionHeader>
<bodyText confidence="0.972767416666667">
We use the markovization settings v = 1 and h = 2 for all further experiments. The
setting which has been reported to yield the best results for PCFG parsing of NeGra,
v = 2 and h = 1 (Rafferty and Manning 2008), required a parsing time which was too
high.4
Table 2 contains the parsing results for NeGraLCFRS using five different binariza-
tions: Head-driven and KM are the two head-outward binarizations that use a head
chosen on linguistic grounds (described in Section 5.2); L-to-R is another variant in
which we always choose the rightmost daughter of a node as its head.5 Optimal reorders
the left-hand side such that the fan-out of the binarized rules is optimized (described in
Section 3.1.2). Finally, we also try a deterministic binarization (Deterministic) in which
we binarize strictly from left to right (i.e., we do not reorder the right-hand sides of
productions, and choose unique binarization labels).
The results of the head-driven binarizations and the optimal binarization lie close
together; the results for the deterministic binarization are worse. This indicates that the
presence or absence of markovization has more impact on parsing results than the actual
binarization order. Furthermore, the non-optimal binarizations did not yield a binarized
grammar of a higher fan-out than the optimal binarization: For all five binarizations,
the fan-out was 7 (caused by a VP interrupted by punctuation).
4 Older versions of rparse contained a bug that kept the priority queue from being updated correctly
(i.e., during an update, the corresponding node in the priority queue was not moved to its top, and
therefore the best parse was not guaranteed to be found); however, higher parsing speeds were achieved.
The current version of rparse implements the update operation correctly, using a Fibonacci queue to
ensure efficiency (Cormen et al. 2003). Thanks to Andreas van Cranenburgh for pointing this out.
5 The term head is not used in its proper linguistic sense here.
</bodyText>
<page confidence="0.97481">
110
</page>
<figure confidence="0.998810444444444">
Kallmeyer and Maier PLCFRS Parsing
items (in 1000)
350
15 17 19 21 23 25 27 29
sentence length
400
OFF
LR
LN
300
250
200
150
100
50
15 17 19 21 23 25 27 29
sentence length
items (in 1000)
700
600
500
400
300
200
100
0
15 17 19 21 23 25 27 29
sentence length
Head-driven
KM
L-to-R
Optimal
Deterministic
items (in 1000) 400
350
300
250
200
150
100
50
Baseline
NP
S
NP+S
</figure>
<figureCaption confidence="0.934681">
Figure 26
</figureCaption>
<bodyText confidence="0.9324072">
NeGraLCFRS: Items for PLCFRS parsing (left-to-right): binarizations, baseline and category splits,
and estimates.
The different binarizations result in different numbers of items, and therefore allow
for different parsing speeds. The respective leftmost graph in Figures 26 and 27 show
a visual representation of the number of items produced by all binarizations, and the
corresponding parsing times. Note that when choosing the head with head rules the
number of items is almost not affected by the choice of adding first the children to
the left of the head and then to the right of the head or vice versa. The optimal bina-
rization produces the best results. Therefore we will use it in all further experiments,
in spite of its higher parsing time.
</bodyText>
<subsectionHeader confidence="0.999109">
6.5 Baseline Evaluation and Category Splits
</subsectionHeader>
<bodyText confidence="0.999475">
Table 3 presents the constituency parsing results for NeGraLCFRS and NeGraCFG, both
with and without the different category splits. Recall that NeGraLCFRS has crossing
branches and consequently leads to a PLCFRS of fan-out &gt; 1 whereas NeGraCFG does
not contain crossing branches and consequently leads to a 1-PLCFRS—in other words,
</bodyText>
<figure confidence="0.99442946875">
time (sec.)
100
0.1
15 17 19 21 23 25 27 29
sentence length
OFF
LR
LN
100
10
1
0.1
15 17 19 21 23 25 27 29
sentence length
15 17 19 21 23 25 27 29
sentence length
time (sec.)
100
0.1
10
1
Head-driven
KM
L-to-R
Optimal
Deterministic
time (sec.) 10
1
Baseline
NP
S
NP+S
</figure>
<figureCaption confidence="0.847231">
Figure 27
</figureCaption>
<footnote confidence="0.8301075">
NeGraLCFRS: Parsing times for PLCFRS parsing (left-to-right): binarizations, baseline and
category splits, and estimates (log scale).
</footnote>
<page confidence="0.988225">
111
</page>
<note confidence="0.442836">
Computational Linguistics Volume 39, Number 1
</note>
<tableCaption confidence="0.994851">
Table 3
</tableCaption>
<table confidence="0.960404222222222">
NeGraLCFRS and NeGraCFC: baseline and category splits.
w/ category splits w/ category splits
NeGraLCFRS NP S NP ◦ S NeGraCFC NP S NP ◦ S
LP 74.92 75.21 75.81 75.93 76.32 76.79 77.39 77.58
LR 74.88 74.95 75.65 75.57 76.36 77.23 77.35 77.99
LF1 74.90 75.08 75.73 75.75 76.34 77.01 77.37 77.79
UP 77.77 78.16 78.31 78.60 79.12 79.62 79.84 80.09
UR 78.73 77.88 78.15 78.22 79.17 80.08 79.80 80.52
UF1 77.75 78.02 78.23 78.41 79.14 79.85 79.82 80.30
</table>
<bodyText confidence="0.997895368421053">
a PCFG. We evaluate the parser output against the unmodified gold data; that is,
before we evaluate the experiments with category splits, we replace all split labels in
the parser output with the corresponding original labels.
We take a closer look at the properties of the trees in the parser output for
NeGraLCFRS. Twenty-nine sentences had no parse, therefore, the parser output has 1,804
sentences. The average tree height is 4.72, and the average number of children per node
(excluding terminals) is 2.91. These values are almost identical to the values for the gold
data. As for the gap degree, we get 1,401 sentences with no gaps (1,361 in the gold set),
334 with gap degree 1 (387 in the gold set), and 69 with 2 or 3 gaps (85 in the gold set).
Even though the difference is only small, one can see that fewer gaps are preferred. This
is not surprising, since constituents with many gaps are rare events and therefore end
up with a probability which is too low.
We see that the quality of the PLCFRS parser output on NeGraLCFRS (which contains
more information than the output of a PCFG parser) does not lag far behind the quality
of the PCFG parsing results on NeGraCFC. With respect to the category splits, the results
show furthermore that category splitting is indeed beneficial for the quality of the
PLCFRS parser output. The gains in speed are particularly visible for sentences with
a length greater than 20 words (cf. the number of produced items and parsing times in
Figures 26 and 27 [middle]).
</bodyText>
<subsectionHeader confidence="0.999568">
6.6 Evaluating Outside Estimates
</subsectionHeader>
<bodyText confidence="0.999886">
We compare the parser performance without estimates (OFF) with its performance
with the estimates described in Sections 4.3 (LR) and 4.4 (LN).
Unfortunately, the full estimates seem to be only of theoretical interest because they
were too expensive to compute both in terms of time and space, given the restrictions
imposed by our hardware. We could, however, compute the LN and the LR estimate.
Unlike the LN estimate, which allows for true A∗ parsing, the LR estimate lets the
quality of the parsing results deteriorate: Compared with the baseline, labeled F1 drops
from 74.90 to 73.76 and unlabeled F1 drops from 77.91 to 76.89. The respective rightmost
graphs in Figures 26 and 27 show the average number of items produced by the
parser and the parsing times for different sentence lengths. The results indicate that the
estimates have the desired effect of preventing unnecessary items from being produced.
This is reflected in a significantly lower parsing time.
The different behavior of the LR and the LN estimate raises the question of the
trade-off between maintaining optimality and obtaining a higher parsing speed. In
</bodyText>
<page confidence="0.994026">
112
</page>
<note confidence="0.896721">
Kallmeyer and Maier PLCFRS Parsing
</note>
<bodyText confidence="0.999635230769231">
other words, it raises the question of whether techniques such as pruning or coarse-
to-fine parsing (Charniak et al. 2006) would probably be superior to A∗ parsing. A first
implementation of a coarse-to-fine approach has been presented by van Cranenburgh
(2012). He generates a CFG from the treebank PLCFRS, based on the idea of Barth´elemy
et al. (2001). This grammar, which can be seen as a coarser version of the actual PLCFRS,
is then used for pruning of the search space. The problem that van Cranenburgh tackles
is specific to PLCFRS: His PCFG stage generalizes over the distinction of labels by their
fan-out. The merit of his work is an enormous increase in efficiency: Sentences with a
length of up to 40 words can now be parsed in a reasonable time. For a comparison of
the results of van Cranenburgh (2012) with our work, the same version of evaluation
parameters would have to be used. The applicability and effectiveness of other coarse-
to-fine approaches (Charniak et al. 2006; Petrov and Klein 2007) on PLCFRS remain to
be seen.
</bodyText>
<listItem confidence="0.551048">
7. Comparison to Other Approaches
</listItem>
<bodyText confidence="0.999926785714286">
Comparing our results with results from the literature is a difficult endeavor, because
PLCFRS parsing of NeGra is an entirely new task that has no direct equivalent in
previous work. In particular, it is a harder task than PCFG parsing. What we can
provide in this section is a comparison of the performance of our parser on NeGraCFC
to the performance of previously presented PCFG parsers on the same data set and
an overview on previous work on parsing which aims at reconstructing crossing
branches.
For the comparison of the performance of our parser on NeGraCFC, we have per-
formed experiments with Helmut Schmid’s LoPar (Schmid 2000) and with the Stanford
Parser (Klein and Manning 2003c) on NeGraCFC.6 For the experiments both parsers
were provided with gold POS tags. Recall that our parser produced labeled precision,
recall, and F1 of 76.32, 76.46, and 76.34, respectively. The plain PCFG provided by LoPar
delivers lower results (LP 72.86, LR 74.43, and LF1 73.63). The Stanford Parser results
(markovization setting v = 2, h = 1 [Rafferty and Manning 2008], otherwise default
parameters) lie in the vicinity of the results of our parser (LP 74.27, LR 76.19, LF1 75.45).
Although the results for LoPar are no surprise, given the similarity of the models
implemented by our parser and the Stanford parser, it remains to be investigated why
the lexicalization component of the Stanford parser does not lead to better results. In
any case the comparison shows that on a data set without crossing branches, our parser
obtains the results one would expect. A further data set to which we can provide a
comparison is the PaGe workshop experimental data (K¨ubler and Penn 2008).7 Table 4
lists the results of some of the papers in K¨ubler and Penn (2008) on TIGER, namely,
for Petrov and Klein (2008) (P&amp;K), who use the Berkeley Parser (Petrov and Klein
2007); Rafferty and Manning (2008) (R&amp;M), who use the Stanford parser (see above);
and Hall and Nivre (2008) (H&amp;N), who use a dependency-based approach (see next
paragraph). The comparison again shows that our system produces good results. Again
the performance gap between the Stanford parser and our parser warrants further
investigation.
</bodyText>
<footnote confidence="0.950872">
6 We have obtained the former parser from http://www.ims.uni-stuttgart.de/tcl/SOFTWARE/
LoPar.html and the latter (Version 2.0.1) from http://nlp.stanford.edu/software/lex-parser.shtml.
7 Thanks to Sandra K¨ubler for providing us with the experimental data.
</footnote>
<page confidence="0.995367">
113
</page>
<note confidence="0.44626">
Computational Linguistics Volume 39, Number 1
</note>
<tableCaption confidence="0.998083">
Table 4
</tableCaption>
<table confidence="0.9957766">
PaGe workshop data.
here P&amp;K R&amp;M H&amp;N
LP 66.93 69.23 58.52 67.06
LR 60.79 70.41 57.63 58.07
LF1 63.71 69.81 58.07 65.18
</table>
<bodyText confidence="0.99993315">
As for the work that aims to create crossing branches, Plaehn (2004) obtains 73.16
Labeled F1 using Probabilistic Discontinuous Phrase Structure Grammar (DPSG), albeit
only on sentences with a length of up to 15 words. On those sentences, we obtain 83.97.
The crucial difference between DPSG rules and LCFRS rules is that the former explicitly
specify the material that can occur in gaps whereas LCFRS does not. Levy (2005), like us,
proposes to use LCFRS but does not provide any evaluation results of his work. Very
recently, Evang and Kallmeyer (2011) followed up on our work. They transform the
Penn Treebank such that the trace nodes and co-indexations are converted into crossing
branches and parse them with the parser presented in this article, obtaining promising
results. Furthermore, van Cranenburgh, Scha, and Sangati (2011) and van Cranenburgh
(2012) have also followed up on our work, introducing an integration of our approach
with Data-Oriented Parsing (DOP). The former article introduces an LCFRS adaption
of Goodman’s PCFG-DOP (Goodman 2003). For their evaluation, the authors use the
same data as we do in Maier (2010), and obtain an improvement of roughly 1.5 points
F-measure. They are also confronted with the same efficiency issues, however, and
encounter a bottleneck in terms of parsing time. In van Cranenburgh (2012), a coarse-
to-fine approach is presented (see Section 6.6). With this approach much faster parsing
is made possible and sentences with a length of up to 40 words can be parsed. The cost
of the speed, however, is that the results lie well below the baseline results for standard
PLCFRS parsing.
A comparison with non-projective dependency parsers (McDonald et al. 2005;
Nivre et al. 2007) might be interesting as well, given that non-projectivity is the
dependency-counterpart to discontinuity in constituency parsing. A meaningful com-
parison is difficult to do for the following reasons, however. Firstly, dependency parsing
deals with relations between words, whereas in our case words are not considered in
the parsing task. Our grammars take POS tags for a given and construct syntactic trees.
Also, dependency conversion algorithms generally depend on the correct identification
of linguistic head words (Lin 1995). We cannot rely on grammatical function labels, such
as, for example, Boyd and Meurers (2008). Therefore we would have to use heuristics for
the dependency conversion of the parser output. This would introduce additional noise.
Secondly, the resources one obtains from our PLCFRS parser and from dependency
parsers (the probabilistic LCFRS and the trained dependency parser) are quite different
because the former contains non-lexicalized internal phrase structure identifying mean-
ingful syntactic categories such as VP or NP while the latter is only concerned with rela-
tions between lexical items. A comparison would concentrate only on relations between
lexical items and the rich phrase structure provided by a constituency parser would
not be taken into account. To achieve some comparison, one could of course transform
the discontinuous constituency trees into dependency trees with dependencies between
heads and with edge labels that encode enough of the syntactic structure to retrieve
the original constituency tree (Hall and Nivre 2008). The result could then be used for
</bodyText>
<page confidence="0.996377">
114
</page>
<note confidence="0.896808">
Kallmeyer and Maier PLCFRS Parsing
</note>
<bodyText confidence="0.9989395">
a dependency evaluation. It is not clear what is to gain by this evaluation because
the head-to-head dependencies one would obtain are not necessarily the predicate-
argument dependencies one would aim at when doing direct dependency parsing
(Rambow 2010).8
</bodyText>
<sectionHeader confidence="0.676703" genericHeader="conclusions">
8. Conclusion
</sectionHeader>
<bodyText confidence="0.999955111111111">
We have presented the first efficient implementation of a weighted deductive CYK
parser for Probabilistic Linear Context-Free Rewriting Systems (PLCFRS), showing
that LCFRS indeed allows for data-driven parsing while modeling discontinuities in
a straightforward way. To speed up parsing, we have introduced different context-
summary estimates of parse items, some acting as figures-of-merit, others allowing for
A∗ parsing. We have implemented the parser and we have evaluated it with grammars
extracted from the German NeGra treebank. Our experiments show that data-driven
LCFRS parsing is feasible and yields output of competitive quality.
There are three main directions for future work on this subject.
</bodyText>
<listItem confidence="0.9044005">
• On the symbolic side, LCFRS seems to offer more power than necessary.
By removing symbolic expressivity, a lower parsing complexity can be
achieved. One possibility is to disallow the use of so-called ill-nested
LCFRS rules. These are rules where, roughly, the spans of two right-hand
side non-terminals interleave in a cross-serial way. See the parsing
algorithm in G´omez-Rodr´ıguez, Kuhlmann, and Satta (2010).
</listItem>
<bodyText confidence="0.9159588">
Nevertheless, this seems to be too restrictive for linguistic modeling
(Chen-Main and Joshi 2010; Maier and Lichte 2011). Our goal for future
work is therefore to define reduced forms of ill-nested rules with which we
get a lower parsing complexity.
Another possibility is to reduce the fan-out of the extracted grammar. We
have pursued the question whether the fan-out of the trees in the treebank
can be reduced in a linguistically meaningful way in Maier, Kaeshammer,
and Kallmeyer (2012).
• On the side of the probabilistic model, there are certain independence
assumptions made in our model that are too strong. The main problem in
respect is that, due to the definition of LCFRS, we have to distinguish
between occurrences of the same category with different fan-outs. For
instance, VP1 (no gaps), VP2 (one gap), and so on, are different
non-terminals. Consequently, the way they expand are considered
independent from each other. This is of course not true, however.
Furthermore, some of these non-terminals are rather rare; we therefore
have a sparse data problem here. This leads to the idea to separate the
development of a category (independent from its fan-out) and the fan-out
and position of gaps. We plan to integrate this into our probabilistic model
in future work.
</bodyText>
<footnote confidence="0.609667666666667">
8 A way to overcome this difference in the content of the dependency annotation would be to use
an evaluation along the lines of Tsarfaty, Nivre, and Andersson (2011); this is not available yet for
annotations with crossing branches, however.
</footnote>
<page confidence="0.990564">
115
</page>
<note confidence="0.435067">
Computational Linguistics Volume 39, Number 1
</note>
<listItem confidence="0.688344">
• Last, it is clear that a more informative evaluation of the parser output is
</listItem>
<bodyText confidence="0.884862">
still necessary, particularly with respect to its performance at the task of
finding long distance dependencies and with respect to its behavior when
not provided with gold POS tags.
</bodyText>
<sectionHeader confidence="0.997542" genericHeader="acknowledgments">
Acknowledgments
</sectionHeader>
<bodyText confidence="0.999935875">
We are particularly grateful to Giorgio Satta
for extensive discussions of the details of the
probabilistic treebank model presented in
this paper. Furthermore, we owe a debt to
Kilian Evang who participated in the
implementation of the parser. Thanks to
Andreas van Cranenburgh for helpful
feedback on the parser implementation.
Finally, we are grateful to our three
anonymous reviewers for many valuable
and helpful comments and suggestions.
A part of the work on this paper was funded
by the German Research Foundation DFG
(Deutsche Forschungsgemeinschaft) in the
form of an Emmy Noether Grant and a
subsequent DFG research project.
</bodyText>
<sectionHeader confidence="0.998364" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.998468120481928">
Barth´elemy, Franc¸ois, Pierre Boullier,
Philippe Deschamp, and ´Eric Villemonte
de la Clergerie. 2001. Guided parsing
of range concatenation languages.
In Proceedings of the 39th Annual Meeting
of the Association for Computational
Linguistics, pages 42–49, Toulouse.
Becker, Tilman, Aravind K. Joshi, and
Owen Rambow.1991. Long-distance
scrambling and tree-adjoining grammars.
In Proceedings of the Fifth Conference of the
European Chapter of the Association for
Computational Linguistics, pages 21–26,
Berlin.
Boullier, Pierre. 1998a. A generalization of
mildly context-sensitive formalisms.
In Proceedings of the Fourth International
Workshop on Tree Adjoining Grammars and
Related Formalisms (TAG+4), pages 17–20,
Philadelphia, PA.
Boullier, Pierre. 1998b. A proposal for a
natural language processing syntactic
backbone. Technical Report 3342, INRIA,
Roquencourt.
Boullier, Pierre. 2000. Range concatenation
grammars. In Proceedings of the Sixth
International Workshop on Parsing
Technologies (IWPT2000), pages 53–64,
Trento.
Boyd, Adriane. 2007. Discontinuity revisited:
An improved conversion to context-free
representations. In the Linguistic
Annotation Workshop at ACL 2007,
pages 41–44, Prague.
Boyd, Adriane and Detmar Meurers.
2008. Revisiting the impact of different
annotation schemes on PCFG parsing:
A grammatical dependency evaluation.
In Proceedings of the Workshop on Parsing
German at ACL 2008, pages 24–32,
Columbus, OH.
Brants, Sabine, Stefanie Dipper, Silvia
Hansen, Wolfgang Lezius, and George
Smith. 2002. The TIGER Treebank.
In Proceedings of the 1st Workshop on
Treebanks and Linguistic Theories,
pages 24–42, Sozopol.
Bunt, Harry. 1996. Formal tools for
describing and processing discontinuous
constituency structure. In Harry Bunt and
Arthur van Horck, editors, Discontinuous
Constituency, volume 6 of Natural Language
Processing. Mouton de Gruyter, Berlin,
pages 63–83.
Cai, Shu, David Chiang, and Yoav Goldberg.
2011. Language-independent parsing
with empty elements. In Proceedings of the
49th Annual Meeting of the Association for
Computational Linguistics: Human Language
Technologies, pages 212–216, Portland, OR.
Candito, Marie and Djam´e Seddah. 2010.
Parsing word clusters. In Proceedings of the
First Workshop on Statistical Parsing of
Morphologically-Rich Languages at NAACL
HLT 2010, pages 76–84, Los Angeles, CA.
Caraballo, Sharon A. and Eugene Charniak.
1998. New figures of merit for best-first
probabilistic chart parsing. Computational
Linguistics, 24(2):275–298.
Charniak, Eugene, Mark Johnson, Micha
Elsner, Joseph Austerweil, David Ellis,
Isaac Haxton, Catherine Hill, R. Shrivaths,
Jeremy Moore, Michael Pozar, and Theresa
Vu. 2006. Multilevel coarse-to-fine PCFG
parsing. In Proceedings of the Human
Language Technology Conference of the
NAACL, Main Conference, pages 168–175,
New York, NY.
Chen-Main, Joan and Aravind Joshi. 2010.
Unavoidable ill-nestedness in natural
language and the adequacy of tree
local-MCTAG induced dependency
structures. In Proceedings of the Tenth
</reference>
<page confidence="0.99854">
116
</page>
<note confidence="0.935646">
Kallmeyer and Maier PLCFRS Parsing
</note>
<reference confidence="0.986136186440677">
International Workshop on Tree Adjoining
Grammar and Related Formalisms (TAG+10),
pages 119–126, New Haven, CT.
Chiang, David. 2003. Statistical parsing with
an automatically extracted tree adjoining
grammar. In Rens Bod, Remko Scha, and
Khalil Sima’an, editors, Data-Oriented
Parsing, CSLI Studies in Computational
Linguistics. CSLI Publications, Stanford,
CA, pages 299–316.
Collins, Michael. 1999. Head-Driven Statistical
Models for Natural Language Parsing. Ph.D.
thesis, University of Pennsylvania.
Cormen, Thomas H., Charles E. Leiserson,
Ronald L. Rivest, and Clifford Stein. 2003.
Introduction to Algorithms. MIT Press,
Cambridge, 2nd edition.
Dienes, P´eter. 2003. Statistical Parsing with
Non-local Dependencies. Ph.D. thesis,
Saarland University.
Evang, Kilian and Laura Kallmeyer. 2011.
PLCFRS parsing of English discontinuous
constituents. In Proceedings of the 12th
International Conference on Parsing
Technologies, pages 104–116, Dublin.
G´omez-Rodriguez, Carlos, Marco
Kuhlmann, and Giorgio Satta. 2010.
Efficient parsing of well-nested linear
context-free rewriting systems. In Human
Language Technologies: The 2010 Annual
Conference of the North American Chapter of
the Association for Computational Linguistics,
pages 276–284, Los Angeles, CA.
G´omez-Rodriguez, Carlos, Marco
Kuhlmann, Giorgio Satta, and David Weir.
2009. Optimal reduction of rule length in
linear context-free rewriting systems. In
Proceedings of Human Language Technologies:
The 2009 Annual Conference of the North
American Chapter of the Association for
Computational Linguistics, pages 539–547,
Boulder, CO.
Goodman, Joshua. 2003. Efficient parsing of
DOP with PCFG-reductions. In Rens Bod,
Remko Scha, and Khalil Sima’an, editors,
Data-Oriented Parsing, CSLI Studies in
Computational Linguistics. CSLI
Publications, Stanford, CA, pages 125–146.
Hall, Johan and Joakim Nivre. 2008.
A dependency-driven parser for
German dependency and constituency
representations. In Proceedings of the
Workshop on Parsing German at ACL 2008,
pages 47–54, Columbus, OH.
Han, Chung-hye, Na-Rae Han, and
Eon-Suk Ko. 2001. Bracketing guidelines
for Penn Korean TreeBank. Technical
Report 01-10, IRCS, University of
Pennsylvania, Philadelphia, PA.
Hockenmaier, Julia. 2003. Data and models
for Statistical Parsing with Combinatory
Categorial Grammar. Ph.D. thesis,
University of Edinburgh.
Hoffman, Beryl. 1995. Integrating “free”
word order syntax and information
structure. In Seventh Conference of the
European Chapter of the Association for
Computational Linguistics, pages 245–251,
Dublin.
H¨ohle, Tilman. 1986. Der Begriff
“Mittelfeld”—Anmerkungen ¨uber die
Theorie der topologischen Felder.
In Akten des Siebten Internationalen
Germanistenkongresses 1985, G¨ottingen,
Germany.
Johnson, Mark. 2002. A simple
pattern-matching algorithm for recovering
empty nodes and their antecedents. In
Proceedings of the 40th Annual Meeting of the
Association for Computational Linguistics,
pages 136–143, Philadelphia, PA.
Kallmeyer, Laura. 2010. Parsing Beyond
Context-Free Grammars. Springer, Berlin.
Kallmeyer, Laura and Wolfgang Maier. 2010.
Data-driven parsing with probabilistic
linear context-free rewriting systems.
In Proceedings of the 23rd International
Conference on Computational Linguistics
(COLING 2010), pages 537–545, Beijing.
Kato, Yuki, Hiroyuki Seki, and Tadao
Kasami. 2006. Stochastic multiple
context-free grammar for RNA
pseudoknot modeling. In Proceedings
of the Eighth International Workshop
on Tree Adjoining Grammar and Related
Formalisms (TAG+8), pages 57–64,
Sydney.
Klein, Dan and Christopher D. Manning.
2003a. A* Parsing: Fast exact viterbi parse
selection. In Proceedings of the 2003 Human
Language Technology Conference of the North
American Chapter of the Association for
Computational Linguistics, pages 40–47,
Edmonton.
Klein, Dan and Christopher D. Manning.
2003b. Accurate unlexicalized parsing.
In Proceedings of the 41st Annual Meeting of
the Association for Computational Linguistics,
pages 423–430, Sapporo.
Klein, Dan and Christopher D. Manning.
2003c. Fast exact inference with a factored
model for natural language parsing. In
Advances in Neural Information Processing
Systems 15 (NIPS), pages 3–10, Vancouver.
Kracht, Marcus. 2003. The Mathematics
of Language. Number 63 in Studies in
Generative Grammar. Mouton de Gruyter,
Berlin.
</reference>
<page confidence="0.95403">
117
</page>
<reference confidence="0.994896831932773">
Computational Linguistics Volume 39, Number 1
K¨ubler, Sandra. 2005. How do treebank
annotation schemes influence parsing
results? Or how not to compare apples
and oranges. In Recent Advances in Natural
Language Processing 2005 (RANLP 2005),
pages 293–300, Borovets.
K¨ubler, Sandra and Gerald Penn, editors.
2008. Proceedings of the Workshop on
Parsing German at ACL 2008. Association
for Computational Linguistics,
Columbus, OH.
Kuhlmann, Marco and Giorgio Satta.
2009. Treebank grammar techniques for
non-projective dependency parsing.
In Proceedings of the 12th Conference
of the European Chapter of the Association
for Computational Linguistics,
pages 478–486, Athens.
Levy, Roger. 2005. Probabilistic Models of
Word Order and Syntactic Discontinuity.
Ph.D. thesis, Stanford University.
Levy, Roger and Christopher D. Manning.
2004. Deep dependencies from context-free
statistical parsers: Correcting the surface
dependency approximation. In Proceedings
of the 42nd Meeting of the Association for
Computational Linguistics (ACL’04), Main
Volume, pages 328–335, Barcelona.
Lin, Dekang. 1995. A dependency-based
method for evaluating broad-coverage
parsers. In Proceedings of the 14th
International Joint Conference on Artificial
Intelligence (IJCAI 95), pages 1420–1427,
Montreal.
Maier, Wolfgang. 2010. Direct parsing of
discontinuous constituents in German.
In Proceedings of the First Workshop on
Statistical Parsing of Morphologically-Rich
Languages at NAACL HLT 2010,
pages 58–66, Los Angeles, CA.
Maier, Wolfgang, Miriam Kaeshammer,
and Laura Kallmeyer. 2012. Data-driven
PLCFRS parsing revisited: Restricting
the fan-out to two. In Proceedings of the
Eleventh International Conference on Tree
Adjoining Grammars and Related Formalisms
(TAG+11), pages 126–134, Paris.
Maier, Wolfgang and Laura Kallmeyer. 2010.
Discontinuity and non-projectivity: Using
mildly context-sensitive formalisms for
data-driven parsing. In Proceedings of the
Tenth International Workshop on Tree
Adjoining Grammars and Related
Formalisms (TAG+10), New Haven, CT.
Maier, Wolfgang and Timm Lichte. 2011.
Characterizing discontinuity in constituent
treebanks. In Formal Grammar. 14th
International Conference, FG 2009. Bordeaux,
France, July 25-26, 2009. Revised Selected
Papers, volume 5591 of Lecture Notes in
Artificial Intelligence, pages 167–182,
Springer-Verlag, Berlin/Heidelberg/
New York.
Maier, Wolfgang and Anders Søgaard. 2008.
Treebanks and mild context-sensitivity.
In Proceedings of the 13th Conference on
Formal Grammar (FG-2008), pages 61–76,
Hamburg.
Marcus, Mitchell, Grace Kim, Mary Ann
Marcinkiewicz, Robert MacIntyre,
Ann Bies, Mark Ferguson, Karen Katz,
and Britta Schasberger. 1994. The Penn
Treebank: Annotating predicate argument
structure. In Proceedings of the Human
Language Technology Conference,
pages 114–119.
McDonald, Ryan, Fernando Pereira,
Kiril Ribarov, and Jan Hajiˇc. 2005.
Non-projective dependency parsing using
spanning tree algorithms. In Proceedings of
Human Language Technology Conference and
Conference on Empirical Methods in Natural
Language Processing (HLT/EMNLP),
pages 523–530, Vancouver.
Michaelis, Jens. 2001. On Formal Properties
of Minimalist Grammars. Ph.D. thesis,
Universit¨at Potsdam.
M¨uller, Gereon. 2002. Free word order,
morphological case, and sympathy theory.
In Gisbert Fanselow and Caroline Fery,
editors, Resolving Conflicts in Grammars:
Optimality Theory in Syntax, Morphology,
and Phonology. Buske Verlag, Hamburg,
pages 265–397.
M¨uller, Stefan. 2004. Continuous or
discontinuous constituents? Research on
Language &amp; Computation, 2(2):209–257.
Nederhof, Mark-Jan. 2003. Weighted
deductive parsing and knuth’s algorithm.
Computational Linguistics, 29(1):135–143.
Nivre, Joakim, Johan Hall, Jens Nilsson,
Atanas Chanev, G¨ulsen Eryigit,
Sandra K¨ubler, Svetoslav Marinov,
and Erwin Marsi. 2007. MaltParser:
A language-independent system for
data-driven dependency parsing. Natural
Language Engineering, 13(2):95–135.
Osenova, Petya and Kiril Simov. 2004.
BTB-TR05: BulTreebank Stylebook.
Technical Report 05, BulTreeBank
Project, Sofia, Bulgaria.
Pereira, Fernando C. N. and David Warren.
1983. Parsing as deduction. In Proceedings
of the 21st Annual Meeting of the Association
for Computational Linguistics, pages 137–144,
Cambridge, MA.
Petrov, Slav and Dan Klein. 2007. Improved
inference for unlexicalized parsing.
</reference>
<page confidence="0.98903">
118
</page>
<note confidence="0.791566">
Kallmeyer and Maier PLCFRS Parsing
</note>
<reference confidence="0.999816605263158">
In Human Language Technologies 2007: The
Conference of the North American Chapter of
the Association for Computational Linguistics;
Proceedings of the Main Conference,
pages 404–411, Rochester, NY.
Petrov, Slav and Dan Klein. 2008. Parsing
German with latent variable grammars.
In Proceedings of the Workshop on Parsing
German at ACL 2008, pages 24–32,
Columbus, OH.
Plaehn, Oliver. 2004. Computing the most
probable parse for a discontinuous
phrase-structure grammar. In Harry Bunt,
John Carroll, and Giorgio Satta, editors,
New Developments in Parsing Technology,
volume 23 of Text, Speech And Language
Technology. Kluwer, Dordrecht,
pages 91–106.
Rafferty, Anna and Christopher D. Manning.
2008. Parsing three German treebanks:
Lexicalized and unlexicalized baselines.
In Proceedings of the Workshop on Parsing
German at ACL 2008, pages 40–46,
Columbus, OH.
Rambow, Owen. 2010. The simple
truth about dependency and phrase
structure representations: An opinion
piece. In Human Language Technologies:
The 2010 Annual Conference of the North
American Chapter of the Association for
Computational Linguistics, pages 337–340,
Los Angeles, CA.
Rehbein, Ines and Josef van Genabith.
2007. Evaluating evaluation measures.
In Proceedings of the 16th Nordic
Conference of Computational Linguistics,
pages 372–379, Tartu.
Schmid, Helmut. 2000. LoPar: Design and
implementation. Arbeitspapiere des
Sonderforschungsbereiches 340 149,
IMS, University of Stuttgart, Stuttgart,
Germany.
Seddah, Djame, Sandra K¨ubler, and Reut
Tsarfaty, editors. 2010. Proceedings of the
First Workshop on Statistical Parsing of
Morphologically-Rich Languages at
NAACL HLT 2010. Association for
Computational Linguistics,
Los Angeles, CA.
Seki, Hiroyuki, Takahashi Matsumura,
Mamoru Fujii, and Tadao Kasami.1991.
On multiple context-free grammars.
Theoretical Computer Science, 88(2):191–229.
Shieber, Stuart M., Yves Schabes, and
Fernando C. N. Pereira. 1995. Principles
and implementation of deductive parsing.
Journal of Logic Programming, 24(1–2):3–36.
Sikkel, Klaas. 1997. Parsing Schemata. Texts in
Theoretical Computer Science. Springer,
Berlin, Heidelberg, New York.
Skut, Wojciech, Brigitte Krenn, Thorten
Brants, and Hans Uszkoreit.1997. An
annotation scheme for free word order
languages. In Proceedings of the Fifth
Conference on Applied Natural Language
Processing (ANLP), pages 88–95,
Washington, DC.
Telljohann, Heike, Erhard W. Hinrichs,
Sandra K¨ubler, Heike Zinsmeister, and
Kathrin Beck. 2012. Stylebook for the
T¨ubingen Treebank of Written German
(T¨uBa-D/Z). Technical report, Seminar f¨ur
Sprachwissenschaft, Universit¨at T¨ubingen,
T¨ubingen, Germany. http://www.sfs.
uni.tuebingen.de/resources/tuebadz-
stylebook-1201.pdf.
Tsarfaty, Reut, Joakim Nivre, and Evelina
Andersson. 2011. Evaluating dependency
parsing: Robust and heuristics-free
cross-annotation evaluation. In Proceedings
of the 2011 Conference on Empirical Methods
in Natural Language Processing,
pages 385–396, Edinburgh.
Uszkoreit, Hans. 1986. Linear precedence
in discontinuous constituents: Complex
fronting in German. CSLI report
CSLI-86-47, Center for the Study of
Language and Information, Stanford
University, Stanford, CA.
van Cranenburgh, Andreas. 2012. Efficient
parsing with linear context-free rewriting
systems. In Proceedings of the 13th
Conference of the European Chapter of the
Association for Computational Linguistics,
pages 460–470, Avignon.
van Cranenburgh, Andreas, Remko Scha,
and Federico Sangati. 2011. Discontinuous
data-oriented parsing: A mildly
context-sensitive all-fragments grammar.
In Proceedings of the Second Workshop on
Statistical Parsing of Morphologically Rich
Languages (SPMRL 2011), pages 34–44,
Dublin.
Versley, Yannick. 2005. Parser evaluation
across text types. In Proceedings of the
Fourth Workshop on Treebanks and Linguistic
Theories, pages 209–220, Barcelona, Spain.
Vijay-Shanker, K., David J. Weir, and
Aravind K. Joshi. 1987. Characterizing
structural descriptions produced by
various grammatical formalisms. In
Proceedings of the 25th Annual Meeting of the
Association for Computational Linguistics,
pages 104–111, Stanford, CA.
</reference>
<page confidence="0.99909">
119
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.447181">
<title confidence="0.907651">Data-Driven Parsing using Probabilistic Linear Context-Free Rewriting Systems Heinrich-Heine-Universit¨at D¨usseldorf Heinrich-Heine-Universit¨at D¨usseldorf</title>
<abstract confidence="0.926964714285714">This paper presents the first efficient implementation of a weighted deductive CYK parser for Probabilistic Linear Context-Free Rewriting Systems (PLCFRSs). LCFRS, an extension of CFG, can describe discontinuities in a straightforward way and is therefore a natural candidate to be used for data-driven parsing. To speed up parsing, we use different context-summary estimates parse items, some of them allowing for parsing. We evaluate our parser with grammars extracted from the German NeGra treebank. Our experiments show that data-driven LCFRS parsing is feasible and yields output of competitive quality.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Franc¸ois Barth´elemy</author>
<author>Pierre Boullier</author>
<author>Philippe Deschamp</author>
</authors>
<title>and ´Eric Villemonte de la Clergerie.</title>
<date>2001</date>
<booktitle>In Proceedings of the 39th Annual Meeting of the Association for Computational Linguistics,</booktitle>
<pages>42--49</pages>
<location>Toulouse.</location>
<marker>Barth´elemy, Boullier, Deschamp, 2001</marker>
<rawString>Barth´elemy, Franc¸ois, Pierre Boullier, Philippe Deschamp, and ´Eric Villemonte de la Clergerie. 2001. Guided parsing of range concatenation languages. In Proceedings of the 39th Annual Meeting of the Association for Computational Linguistics, pages 42–49, Toulouse.</rawString>
</citation>
<citation valid="false">
<authors>
<author>Tilman Becker</author>
<author>Aravind K Joshi</author>
<author>Owen Rambow 1991</author>
</authors>
<title>Long-distance scrambling and tree-adjoining grammars.</title>
<booktitle>In Proceedings of the Fifth Conference of the European Chapter of the Association for Computational Linguistics,</booktitle>
<pages>21--26</pages>
<location>Berlin.</location>
<marker>Becker, Joshi, 1991, </marker>
<rawString>Becker, Tilman, Aravind K. Joshi, and Owen Rambow.1991. Long-distance scrambling and tree-adjoining grammars. In Proceedings of the Fifth Conference of the European Chapter of the Association for Computational Linguistics, pages 21–26, Berlin.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Pierre Boullier</author>
</authors>
<title>A generalization of mildly context-sensitive formalisms.</title>
<date>1998</date>
<booktitle>In Proceedings of the Fourth International Workshop on Tree Adjoining Grammars and Related Formalisms (TAG+4),</booktitle>
<pages>17--20</pages>
<location>Philadelphia, PA.</location>
<contexts>
<context position="13975" citStr="Boullier 1998" startWordPosition="2139" endWordPosition="2140">s with the relative clause split from Section 3.2. Finally, Maier (2010) contains the evaluation of the baseline (together with an evaluation using other metrics). Y A LCFRS: • A • • Y1 Y2 Y3 91 Computational Linguistics Volume 39, Number 1 2. Probabilistic Linear Context-Free Rewriting Systems 2.1 Definition of PLCFRS LCFRS (Vijay-Shanker, Weir, and Joshi 1987) is an extension of CFG in which a nonterminal can span not only a single string but a tuple of strings of size k &gt; 1. k is thereby called its fan-out. We will notate LCFRS with the syntax of Simple Range Concatenation Grammars (SRCG) (Boullier 1998b), a formalism that is equivalent to LCFRS. A third formalism that is equivalent to LCFRS is Multiple Context-Free Grammar (MCFG) (Seki et al. 1991). Definition 1(LCFRS) A Linear Context-Free Rewriting System (LCFRS) is a tuple (N, T, V, P, S) where a) N is a finite set of non-terminals with a function dim: N -+ N that determines the fan-out of each A E N; b) T and V are disjoint finite sets of terminals and variables; c) S E N is the start symbol with dim(S) = 1; d) P is a finite set of rules A(α1, ... , αdim(A)) -+ A1(X(1) 1 , . . . , X(1) dim(A1)) ··· Am(X(m) 1 , . . . , X(m) dim(Am)) for </context>
<context position="17611" citStr="Boullier 1998" startWordPosition="2902" endWordPosition="2903">s in P is called the rank of G. 3. G is monotone if for every r E P and every right-hand side non-terminal A in r and each pair X1, X2 of arguments of A in the right-hand side of r, X1 precedes X2 in the right-hand side iff X1 precedes X2 in the left-hand side. 4. A rule r E P is called an ε-rule if one of the left-hand side components of r is ε. G is ε-free if it either contains no ε-rules or there is exactly one ε-rule S(ε) -+ ε and S does not appear in any of the right-hand sides of the rules in the grammar. For every LCFRS there exists an equivalent LCFRS that is ε-free (Seki et al. 1991; Boullier 1998a) and monotone (Michaelis 2001; Kracht 2003; Kallmeyer 2010). The definition of a probabilistic LCFRS is a straightforward extension of the definition of PCFG and thus it follows (Levy 2005; Kato, Seki, and Kasami 2006) that: Definition 4 (PLCFRS) A probabilistic LCFRS (PLCFRS) is a tuple (N, T, V, P, S, p) such that (N, T, V, P, S) is an LCFRS and p : P -+ [0..1] a function such that for all A E N: ΣA(,)→6∈Pp(A(-) -+ -6) = 1 93 Computational Linguistics Volume 39, Number 1 PLCFRS with non-terminals {S, A, B}, terminals {a} and start symbol S: 0.2 : S(X) -+ A(X) 0.8 : S(XY) -+ B(X,Y) 0.7 : A(</context>
</contexts>
<marker>Boullier, 1998</marker>
<rawString>Boullier, Pierre. 1998a. A generalization of mildly context-sensitive formalisms. In Proceedings of the Fourth International Workshop on Tree Adjoining Grammars and Related Formalisms (TAG+4), pages 17–20, Philadelphia, PA.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Pierre Boullier</author>
</authors>
<title>A proposal for a natural language processing syntactic backbone.</title>
<date>1998</date>
<tech>Technical Report 3342, INRIA, Roquencourt.</tech>
<contexts>
<context position="13975" citStr="Boullier 1998" startWordPosition="2139" endWordPosition="2140">s with the relative clause split from Section 3.2. Finally, Maier (2010) contains the evaluation of the baseline (together with an evaluation using other metrics). Y A LCFRS: • A • • Y1 Y2 Y3 91 Computational Linguistics Volume 39, Number 1 2. Probabilistic Linear Context-Free Rewriting Systems 2.1 Definition of PLCFRS LCFRS (Vijay-Shanker, Weir, and Joshi 1987) is an extension of CFG in which a nonterminal can span not only a single string but a tuple of strings of size k &gt; 1. k is thereby called its fan-out. We will notate LCFRS with the syntax of Simple Range Concatenation Grammars (SRCG) (Boullier 1998b), a formalism that is equivalent to LCFRS. A third formalism that is equivalent to LCFRS is Multiple Context-Free Grammar (MCFG) (Seki et al. 1991). Definition 1(LCFRS) A Linear Context-Free Rewriting System (LCFRS) is a tuple (N, T, V, P, S) where a) N is a finite set of non-terminals with a function dim: N -+ N that determines the fan-out of each A E N; b) T and V are disjoint finite sets of terminals and variables; c) S E N is the start symbol with dim(S) = 1; d) P is a finite set of rules A(α1, ... , αdim(A)) -+ A1(X(1) 1 , . . . , X(1) dim(A1)) ··· Am(X(m) 1 , . . . , X(m) dim(Am)) for </context>
<context position="17611" citStr="Boullier 1998" startWordPosition="2902" endWordPosition="2903">s in P is called the rank of G. 3. G is monotone if for every r E P and every right-hand side non-terminal A in r and each pair X1, X2 of arguments of A in the right-hand side of r, X1 precedes X2 in the right-hand side iff X1 precedes X2 in the left-hand side. 4. A rule r E P is called an ε-rule if one of the left-hand side components of r is ε. G is ε-free if it either contains no ε-rules or there is exactly one ε-rule S(ε) -+ ε and S does not appear in any of the right-hand sides of the rules in the grammar. For every LCFRS there exists an equivalent LCFRS that is ε-free (Seki et al. 1991; Boullier 1998a) and monotone (Michaelis 2001; Kracht 2003; Kallmeyer 2010). The definition of a probabilistic LCFRS is a straightforward extension of the definition of PCFG and thus it follows (Levy 2005; Kato, Seki, and Kasami 2006) that: Definition 4 (PLCFRS) A probabilistic LCFRS (PLCFRS) is a tuple (N, T, V, P, S, p) such that (N, T, V, P, S) is an LCFRS and p : P -+ [0..1] a function such that for all A E N: ΣA(,)→6∈Pp(A(-) -+ -6) = 1 93 Computational Linguistics Volume 39, Number 1 PLCFRS with non-terminals {S, A, B}, terminals {a} and start symbol S: 0.2 : S(X) -+ A(X) 0.8 : S(XY) -+ B(X,Y) 0.7 : A(</context>
</contexts>
<marker>Boullier, 1998</marker>
<rawString>Boullier, Pierre. 1998b. A proposal for a natural language processing syntactic backbone. Technical Report 3342, INRIA, Roquencourt.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Pierre Boullier</author>
</authors>
<title>Range concatenation grammars.</title>
<date>2000</date>
<booktitle>In Proceedings of the Sixth International Workshop on Parsing Technologies (IWPT2000),</booktitle>
<pages>53--64</pages>
<location>Trento.</location>
<contexts>
<context position="26957" citStr="Boullier (2000)" startWordPosition="4609" endWordPosition="4610">r 1 &lt; i &lt; n. 1. Pos(w) := {0,...,n}. 2. We call a pair (l, r) E Pos(w) x Pos(w) with l &lt; r a range in w. Its yield (l, r)(w) is the substring wl+1 ... wr. 3. For two ranges p1 = (l1, r1), p2 = (l2, r2), if r1 = l2, then the concatenation of p1 and p2 is p1 · p2 = (l1, r2); otherwise p1 · p2 is undefined. 4. A p~ E (Pos(w) x Pos(w))k is a k-dimensional range vector for w iff p� = ((l1, r1), ... , (lk, rk)) where (li, ri) is a range in w for 1 &lt; i &lt; k. We now define instantiations of rules with respect to a given input string. This definition follows the definition of clause instantiations from Boullier (2000). An instantiated rule is a rule in which variables are consistently replaced by ranges. Because we need this definition only for parsing our specific grammars, we restrict ourselves to F--free rules containing only variables. Definition 7 (Rule instantiation) Let G = (N, T, V, P, S) be an F--free monotone LCFRS. For a given rule r = A(a) -+ A1(*x1) · · · Am( &apos;xm) E P (0 &lt; m) that does not contain any terminals, 1. an instantiation with respect to a string w = t1 ... tn consists of a function f : V -+ {(i, j) J1 &lt; i &lt; j &lt; JwJ} such that for all x, y adjacent in one of the elements of &amp;, f(x) ·</context>
</contexts>
<marker>Boullier, 2000</marker>
<rawString>Boullier, Pierre. 2000. Range concatenation grammars. In Proceedings of the Sixth International Workshop on Parsing Technologies (IWPT2000), pages 53–64, Trento.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Adriane Boyd</author>
</authors>
<title>Discontinuity revisited: An improved conversion to context-free representations.</title>
<date>2007</date>
<booktitle>In the Linguistic Annotation Workshop at ACL</booktitle>
<pages>41--44</pages>
<location>Prague.</location>
<contexts>
<context position="9188" citStr="Boyd 2007" startWordPosition="1384" endWordPosition="1385"> co-indexation) together with a NeGra-style annotation of the same sentence (right). In the past, data-driven parsing has largely been dominated by Probabilistic Context-Free Grammar (PCFG). In order to extract a PCFG from a treebank, the trees need to be interpretable as CFG derivations. Consequently, most work has excluded non-local dependencies; either (in PTB-like treebanks) by discarding labeling conventions such as the co-indexation of the trace nodes in the PTB, or (in NeGra/TIGER-like treebanks) by applying tree transformations, which resolve the crossing branches (e.g., K¨ubler 2005; Boyd 2007). Especially for the latter treebanks, such a transformation is problematic, because it generally is non-reversible and implies information loss. Discontinuities are no minor phenomenon: Approximately 25% of all sentences in NeGra and TIGER have crossing branches (Maier and Lichte 2011). In the Penn Treebank, this holds for approximately 20% of all sentences (Evang and Kallmeyer 2011). This shows that it is important to properly treat such structures. 1.3 Extending the Domain of Locality In the literature, different methods have been explored that allow for the use of nonlocal information in d</context>
</contexts>
<marker>Boyd, 2007</marker>
<rawString>Boyd, Adriane. 2007. Discontinuity revisited: An improved conversion to context-free representations. In the Linguistic Annotation Workshop at ACL 2007, pages 41–44, Prague.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Adriane Boyd</author>
<author>Detmar Meurers</author>
</authors>
<title>Revisiting the impact of different annotation schemes on PCFG parsing: A grammatical dependency evaluation.</title>
<date>2008</date>
<booktitle>In Proceedings of the Workshop on Parsing German at ACL</booktitle>
<pages>24--32</pages>
<location>Columbus, OH.</location>
<contexts>
<context position="76582" citStr="Boyd and Meurers (2008)" startWordPosition="13684" endWordPosition="13687">ight be interesting as well, given that non-projectivity is the dependency-counterpart to discontinuity in constituency parsing. A meaningful comparison is difficult to do for the following reasons, however. Firstly, dependency parsing deals with relations between words, whereas in our case words are not considered in the parsing task. Our grammars take POS tags for a given and construct syntactic trees. Also, dependency conversion algorithms generally depend on the correct identification of linguistic head words (Lin 1995). We cannot rely on grammatical function labels, such as, for example, Boyd and Meurers (2008). Therefore we would have to use heuristics for the dependency conversion of the parser output. This would introduce additional noise. Secondly, the resources one obtains from our PLCFRS parser and from dependency parsers (the probabilistic LCFRS and the trained dependency parser) are quite different because the former contains non-lexicalized internal phrase structure identifying meaningful syntactic categories such as VP or NP while the latter is only concerned with relations between lexical items. A comparison would concentrate only on relations between lexical items and the rich phrase str</context>
</contexts>
<marker>Boyd, Meurers, 2008</marker>
<rawString>Boyd, Adriane and Detmar Meurers. 2008. Revisiting the impact of different annotation schemes on PCFG parsing: A grammatical dependency evaluation. In Proceedings of the Workshop on Parsing German at ACL 2008, pages 24–32, Columbus, OH.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Sabine Brants</author>
<author>Stefanie Dipper</author>
<author>Silvia Hansen</author>
<author>Wolfgang Lezius</author>
<author>George Smith</author>
</authors>
<title>The TIGER Treebank.</title>
<date>2002</date>
<booktitle>In Proceedings of the 1st Workshop on Treebanks and Linguistic Theories,</booktitle>
<pages>24--42</pages>
<contexts>
<context position="4117" citStr="Brants et al. 2002" startWordPosition="608" endWordPosition="611">96; M¨uller 2004), and for treebank annotation in particular (Skut et al. 1997). In this paper, we address the problem of data-driven parsing of discontinuous constituents on the basis of German. In this section, we inspect the type of data we have to deal with, and we describe the way such data are annotated in treebanks. We briefly discuss different parsing strategies for the data in question and motivate our own approach. 1.1 Discontinuous Constituents Consider the sentences in Example (2) as examples for discontinuous constituents (taken from the German NeGra [Skut et al. 1997] and TIGER [Brants et al. 2002] treebanks). Example (2a) shows several instances of discontinuous VPs and Example (2b) shows a discontinuous NP. The relevant constituent is printed in italics. (2) a. Fronting: (i) Dar¨uber muss nachgedacht werden. (NeGra) Thereof must thought be “One must think of that” k¨onne sich Bonn von dem Denkmal nicht (ii) Ohne internationalen Schaden could itself Bonn from the monument not Without international damage distanzieren, ... (TIGER) distance “Bonn could not distance itself from the monument without international damage.” (iii) Auch Also w¨urden durch die Regelung nur would through the re</context>
</contexts>
<marker>Brants, Dipper, Hansen, Lezius, Smith, 2002</marker>
<rawString>Brants, Sabine, Stefanie Dipper, Silvia Hansen, Wolfgang Lezius, and George Smith. 2002. The TIGER Treebank. In Proceedings of the 1st Workshop on Treebanks and Linguistic Theories, pages 24–42, Sozopol.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Harry Bunt</author>
</authors>
<title>Formal tools for describing and processing discontinuous constituency structure.</title>
<date>1996</date>
<booktitle>Discontinuous Constituency,</booktitle>
<volume>6</volume>
<pages>63--83</pages>
<editor>In Harry Bunt and Arthur van Horck, editors,</editor>
<location>Berlin,</location>
<contexts>
<context position="3501" citStr="Bunt 1996" startWordPosition="509" endWordPosition="510">parse morphology. See M¨uller (2002) for a survey of the linguistics literature on this discussion. With a rather free word order, constituents and single parts of them can be displaced freely within the sentence. German, for instance, has a rich inflectional system and allows for a free word order, as we have already seen in Example (1): Arguments can be scrambled, and topicalizations and extrapositions underlie few restrictions. Consequently, discontinuous constituents occur frequently. This is challenging for syntactic description in general (Uszkoreit 1986; Becker, Joshi, and Rambow 1991; Bunt 1996; M¨uller 2004), and for treebank annotation in particular (Skut et al. 1997). In this paper, we address the problem of data-driven parsing of discontinuous constituents on the basis of German. In this section, we inspect the type of data we have to deal with, and we describe the way such data are annotated in treebanks. We briefly discuss different parsing strategies for the data in question and motivate our own approach. 1.1 Discontinuous Constituents Consider the sentences in Example (2) as examples for discontinuous constituents (taken from the German NeGra [Skut et al. 1997] and TIGER [Br</context>
</contexts>
<marker>Bunt, 1996</marker>
<rawString>Bunt, Harry. 1996. Formal tools for describing and processing discontinuous constituency structure. In Harry Bunt and Arthur van Horck, editors, Discontinuous Constituency, volume 6 of Natural Language Processing. Mouton de Gruyter, Berlin, pages 63–83.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Shu Cai</author>
<author>David Chiang</author>
<author>Yoav Goldberg</author>
</authors>
<title>Language-independent parsing with empty elements.</title>
<date>2011</date>
<booktitle>In Proceedings of the 49th Annual Meeting of the Association for Computational Linguistics: Human Language Technologies,</booktitle>
<pages>212--216</pages>
<location>Portland, OR.</location>
<marker>Cai, Chiang, Goldberg, 2011</marker>
<rawString>Cai, Shu, David Chiang, and Yoav Goldberg. 2011. Language-independent parsing with empty elements. In Proceedings of the 49th Annual Meeting of the Association for Computational Linguistics: Human Language Technologies, pages 212–216, Portland, OR.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Marie Candito</author>
<author>Djam´e Seddah</author>
</authors>
<title>Parsing word clusters.</title>
<date>2010</date>
<booktitle>In Proceedings of the First Workshop on Statistical Parsing of Morphologically-Rich Languages at NAACL HLT 2010,</booktitle>
<pages>76--84</pages>
<location>Los Angeles, CA.</location>
<contexts>
<context position="1053" citStr="Candito and Seddah 2010" startWordPosition="138" endWordPosition="141">y and is therefore a natural candidate to be used for data-driven parsing. To speed up parsing, we use different context-summary estimates of parse items, some of them allowing for A∗ parsing. We evaluate our parser with grammars extracted from the German NeGra treebank. Our experiments show that data-driven LCFRS parsing is feasible and yields output of competitive quality. 1. Introduction Recently, the challenges that a rich morphology poses for data-driven parsing have received growing interest. A direct effect of morphological richness is, for instance, data sparseness on a lexical level (Candito and Seddah 2010). A rather indirect effect is that morphological richness often relaxes word order constraints. The principal intuition is that a rich morphology encodes information that otherwise has to be conveyed by a particular word order. If, for instance, the case of a nominal complement is not provided by morphology, it has to be provided by the position of the complement relative to other complements in the sentence. Example (1) provides an example of case marking and free word order in German. In turn, in free word order languages, word order can encode information structure (Hoffman 1995). (1) a. de</context>
</contexts>
<marker>Candito, Seddah, 2010</marker>
<rawString>Candito, Marie and Djam´e Seddah. 2010. Parsing word clusters. In Proceedings of the First Workshop on Statistical Parsing of Morphologically-Rich Languages at NAACL HLT 2010, pages 76–84, Los Angeles, CA.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Sharon A Caraballo</author>
<author>Eugene Charniak</author>
</authors>
<title>New figures of merit for best-first probabilistic chart parsing.</title>
<date>1998</date>
<journal>Computational Linguistics,</journal>
<volume>24</volume>
<issue>2</issue>
<contexts>
<context position="11475" citStr="Caraballo and Charniak 1998" startWordPosition="1741" endWordPosition="1744">y the following recent developments. Linear Context-Free Rewriting Systems (LCFRSs) (Vijay-Shanker, Weir, and Joshi 1987) have been established as a candidate for modeling both discontinuous constituents and non-projective dependency trees as they occur in treebanks (Maier and Søgaard 2008; Kuhlmann and Satta 2009; Maier and Lichte 2011). LCFRSs are a natural extension of CFGs where the non-terminals can span tuples of possibly non-adjacent strings (see Figure 3). Because LCFRSs allow for binarization and CYK chart parsing in a way similar to CFGs, PCFG techniques, such as best-first parsing (Caraballo and Charniak 1998), weighted deductive parsing (Nederhof 2003), and A* parsing (Klein and Manning 2003a) can be transferred to LCFRS. Finally, as mentioned before, languages such as German have recently attracted the interest of the parsing community (K¨ubler and Penn 2008; Seddah, K¨ubler, and Tsarfaty 2010). We bring together these developments by presenting a parser for Probabilistic LCFRS (PLCFRS), continuing the promising work of Levy (2005). Our parser produces trees with crossing branches and thereby accounts for syntactic long-distance dependencies while not making any additional assumptions concerning </context>
</contexts>
<marker>Caraballo, Charniak, 1998</marker>
<rawString>Caraballo, Sharon A. and Eugene Charniak. 1998. New figures of merit for best-first probabilistic chart parsing. Computational Linguistics, 24(2):275–298.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Eugene Charniak</author>
<author>Mark Johnson</author>
<author>Micha Elsner</author>
<author>Joseph Austerweil</author>
<author>David Ellis</author>
<author>Isaac Haxton</author>
<author>Catherine Hill</author>
<author>R Shrivaths</author>
<author>Jeremy Moore</author>
<author>Michael Pozar</author>
<author>Theresa Vu</author>
</authors>
<title>Multilevel coarse-to-fine PCFG parsing.</title>
<date>2006</date>
<booktitle>In Proceedings of the Human Language Technology Conference of the NAACL, Main Conference,</booktitle>
<pages>168--175</pages>
<location>New York, NY.</location>
<contexts>
<context position="70638" citStr="Charniak et al. 2006" startWordPosition="12728" endWordPosition="12731">ures 26 and 27 show the average number of items produced by the parser and the parsing times for different sentence lengths. The results indicate that the estimates have the desired effect of preventing unnecessary items from being produced. This is reflected in a significantly lower parsing time. The different behavior of the LR and the LN estimate raises the question of the trade-off between maintaining optimality and obtaining a higher parsing speed. In 112 Kallmeyer and Maier PLCFRS Parsing other words, it raises the question of whether techniques such as pruning or coarseto-fine parsing (Charniak et al. 2006) would probably be superior to A∗ parsing. A first implementation of a coarse-to-fine approach has been presented by van Cranenburgh (2012). He generates a CFG from the treebank PLCFRS, based on the idea of Barth´elemy et al. (2001). This grammar, which can be seen as a coarser version of the actual PLCFRS, is then used for pruning of the search space. The problem that van Cranenburgh tackles is specific to PLCFRS: His PCFG stage generalizes over the distinction of labels by their fan-out. The merit of his work is an enormous increase in efficiency: Sentences with a length of up to 40 words ca</context>
</contexts>
<marker>Charniak, Johnson, Elsner, Austerweil, Ellis, Haxton, Hill, Shrivaths, Moore, Pozar, Vu, 2006</marker>
<rawString>Charniak, Eugene, Mark Johnson, Micha Elsner, Joseph Austerweil, David Ellis, Isaac Haxton, Catherine Hill, R. Shrivaths, Jeremy Moore, Michael Pozar, and Theresa Vu. 2006. Multilevel coarse-to-fine PCFG parsing. In Proceedings of the Human Language Technology Conference of the NAACL, Main Conference, pages 168–175, New York, NY.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Joan Chen-Main</author>
<author>Aravind Joshi</author>
</authors>
<title>Unavoidable ill-nestedness in natural language and the adequacy of tree local-MCTAG induced dependency structures.</title>
<date>2010</date>
<booktitle>In Proceedings of the Tenth International Workshop on Tree Adjoining Grammar and Related Formalisms (TAG+10),</booktitle>
<pages>119--126</pages>
<location>New Haven, CT.</location>
<contexts>
<context position="79100" citStr="Chen-Main and Joshi 2010" startWordPosition="14058" endWordPosition="14061">ible and yields output of competitive quality. There are three main directions for future work on this subject. • On the symbolic side, LCFRS seems to offer more power than necessary. By removing symbolic expressivity, a lower parsing complexity can be achieved. One possibility is to disallow the use of so-called ill-nested LCFRS rules. These are rules where, roughly, the spans of two right-hand side non-terminals interleave in a cross-serial way. See the parsing algorithm in G´omez-Rodr´ıguez, Kuhlmann, and Satta (2010). Nevertheless, this seems to be too restrictive for linguistic modeling (Chen-Main and Joshi 2010; Maier and Lichte 2011). Our goal for future work is therefore to define reduced forms of ill-nested rules with which we get a lower parsing complexity. Another possibility is to reduce the fan-out of the extracted grammar. We have pursued the question whether the fan-out of the trees in the treebank can be reduced in a linguistically meaningful way in Maier, Kaeshammer, and Kallmeyer (2012). • On the side of the probabilistic model, there are certain independence assumptions made in our model that are too strong. The main problem in respect is that, due to the definition of LCFRS, we have to</context>
</contexts>
<marker>Chen-Main, Joshi, 2010</marker>
<rawString>Chen-Main, Joan and Aravind Joshi. 2010. Unavoidable ill-nestedness in natural language and the adequacy of tree local-MCTAG induced dependency structures. In Proceedings of the Tenth International Workshop on Tree Adjoining Grammar and Related Formalisms (TAG+10), pages 119–126, New Haven, CT.</rawString>
</citation>
<citation valid="true">
<authors>
<author>David Chiang</author>
</authors>
<title>Statistical parsing with an automatically extracted tree adjoining grammar.</title>
<date>2003</date>
<booktitle>In Rens Bod, Remko Scha, and Khalil Sima’an, editors, Data-Oriented Parsing, CSLI Studies in Computational Linguistics. CSLI Publications,</booktitle>
<pages>299--316</pages>
<location>Stanford, CA,</location>
<contexts>
<context position="10334" citStr="Chiang 2003" startWordPosition="1571" endWordPosition="1572"> been explored that allow for the use of nonlocal information in data-driven parsing. We distinguish two classes of approaches. The first class consists of approaches that aim at using formalisms which produce trees without crossing branches but provide a larger domain of locality than CFG— for instance, through complex labels (Hockenmaier 2003) or through the derivation What should I do *r* ? What should I do WP MD PRP VB -NONE- . WP MD PRP VB . WHNP NP SBJ *r* SQ SBARQ VP NP VP SQ NP SBJ SBARQ WHNP 90 Kallmeyer and Maier PLCFRS Parsing CFG: Figure 3 Different domains of locality. mechanism (Chiang 2003). The second class, to which we contribute in this paper, consists of approaches that aim at producing trees which contain non-local information. Some methods realize the reconstruction of non-local information in a post- or preprocessing step to PCFG parsing (Johnson 2002; Dienes 2003; Levy and Manning 2004; Cai, Chiang, and Goldberg 2011). Other work uses formalisms that accommodate the direct encoding of non-local information (Plaehn 2004; Levy 2005). We pursue the latter approach. Our work is motivated by the following recent developments. Linear Context-Free Rewriting Systems (LCFRSs) (Vi</context>
</contexts>
<marker>Chiang, 2003</marker>
<rawString>Chiang, David. 2003. Statistical parsing with an automatically extracted tree adjoining grammar. In Rens Bod, Remko Scha, and Khalil Sima’an, editors, Data-Oriented Parsing, CSLI Studies in Computational Linguistics. CSLI Publications, Stanford, CA, pages 299–316.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Michael Collins</author>
</authors>
<title>Head-Driven Statistical Models for Natural Language Parsing.</title>
<date>1999</date>
<tech>Ph.D. thesis,</tech>
<institution>University of Pennsylvania.</institution>
<contexts>
<context position="57607" citStr="Collins 1999" startWordPosition="10537" endWordPosition="10538">ng the head. This allows for a further factorization. In the experiments, however, we do not insert unary rules, neither at the highest nor at the lowest new binarization non-terminal, because this was neither beneficial for parsing times nor for the parsing results. 5.3 Incorporating Additional Context 5.3.1 Markovization. As already mentioned in Section 3.1, a binarization that introduces unique new non-terminals for every single rule that needs to be binarized produces a large amount of non-terminals and fails to capture certain generalizations. For this reason, we introduce markovization (Collins 1999; Klein and Manning 2003b). Markovization is achieved by introducing only a single new non-terminal for the new rules introduced during binarization and adding vertical and horizontal context from the original trees to each occurrence of this new non-terminal. As vertical context, we add the first v labels on the path from the root node of the tree that we want to binarize to the root of the entire treebank tree. The vertical context is collected during grammar extraction and then taken into account during binarization of the rules. As horizontal context, during binarization of a rule A(:α) → </context>
</contexts>
<marker>Collins, 1999</marker>
<rawString>Collins, Michael. 1999. Head-Driven Statistical Models for Natural Language Parsing. Ph.D. thesis, University of Pennsylvania.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Thomas H Cormen</author>
<author>Charles E Leiserson</author>
<author>Ronald L Rivest</author>
<author>Clifford Stein</author>
</authors>
<title>Introduction to Algorithms.</title>
<date>2003</date>
<publisher>MIT Press,</publisher>
<location>Cambridge, 2nd</location>
<note>edition.</note>
<contexts>
<context position="65252" citStr="Cormen et al. 2003" startWordPosition="11802" endWordPosition="11805">did not yield a binarized grammar of a higher fan-out than the optimal binarization: For all five binarizations, the fan-out was 7 (caused by a VP interrupted by punctuation). 4 Older versions of rparse contained a bug that kept the priority queue from being updated correctly (i.e., during an update, the corresponding node in the priority queue was not moved to its top, and therefore the best parse was not guaranteed to be found); however, higher parsing speeds were achieved. The current version of rparse implements the update operation correctly, using a Fibonacci queue to ensure efficiency (Cormen et al. 2003). Thanks to Andreas van Cranenburgh for pointing this out. 5 The term head is not used in its proper linguistic sense here. 110 Kallmeyer and Maier PLCFRS Parsing items (in 1000) 350 15 17 19 21 23 25 27 29 sentence length 400 OFF LR LN 300 250 200 150 100 50 15 17 19 21 23 25 27 29 sentence length items (in 1000) 700 600 500 400 300 200 100 0 15 17 19 21 23 25 27 29 sentence length Head-driven KM L-to-R Optimal Deterministic items (in 1000) 400 350 300 250 200 150 100 50 Baseline NP S NP+S Figure 26 NeGraLCFRS: Items for PLCFRS parsing (left-to-right): binarizations, baseline and category spl</context>
</contexts>
<marker>Cormen, Leiserson, Rivest, Stein, 2003</marker>
<rawString>Cormen, Thomas H., Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein. 2003. Introduction to Algorithms. MIT Press, Cambridge, 2nd edition.</rawString>
</citation>
<citation valid="true">
<authors>
<author>P´eter Dienes</author>
</authors>
<title>Statistical Parsing with Non-local Dependencies.</title>
<date>2003</date>
<tech>Ph.D. thesis,</tech>
<institution>Saarland University.</institution>
<contexts>
<context position="10620" citStr="Dienes 2003" startWordPosition="1615" endWordPosition="1616">CFG— for instance, through complex labels (Hockenmaier 2003) or through the derivation What should I do *r* ? What should I do WP MD PRP VB -NONE- . WP MD PRP VB . WHNP NP SBJ *r* SQ SBARQ VP NP VP SQ NP SBJ SBARQ WHNP 90 Kallmeyer and Maier PLCFRS Parsing CFG: Figure 3 Different domains of locality. mechanism (Chiang 2003). The second class, to which we contribute in this paper, consists of approaches that aim at producing trees which contain non-local information. Some methods realize the reconstruction of non-local information in a post- or preprocessing step to PCFG parsing (Johnson 2002; Dienes 2003; Levy and Manning 2004; Cai, Chiang, and Goldberg 2011). Other work uses formalisms that accommodate the direct encoding of non-local information (Plaehn 2004; Levy 2005). We pursue the latter approach. Our work is motivated by the following recent developments. Linear Context-Free Rewriting Systems (LCFRSs) (Vijay-Shanker, Weir, and Joshi 1987) have been established as a candidate for modeling both discontinuous constituents and non-projective dependency trees as they occur in treebanks (Maier and Søgaard 2008; Kuhlmann and Satta 2009; Maier and Lichte 2011). LCFRSs are a natural extension o</context>
</contexts>
<marker>Dienes, 2003</marker>
<rawString>Dienes, P´eter. 2003. Statistical Parsing with Non-local Dependencies. Ph.D. thesis, Saarland University.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kilian Evang</author>
<author>Laura Kallmeyer</author>
</authors>
<title>PLCFRS parsing of English discontinuous constituents.</title>
<date>2011</date>
<booktitle>In Proceedings of the 12th International Conference on Parsing Technologies,</booktitle>
<pages>104--116</pages>
<location>Dublin.</location>
<contexts>
<context position="9575" citStr="Evang and Kallmeyer 2011" startWordPosition="1438" endWordPosition="1441">reebanks) by discarding labeling conventions such as the co-indexation of the trace nodes in the PTB, or (in NeGra/TIGER-like treebanks) by applying tree transformations, which resolve the crossing branches (e.g., K¨ubler 2005; Boyd 2007). Especially for the latter treebanks, such a transformation is problematic, because it generally is non-reversible and implies information loss. Discontinuities are no minor phenomenon: Approximately 25% of all sentences in NeGra and TIGER have crossing branches (Maier and Lichte 2011). In the Penn Treebank, this holds for approximately 20% of all sentences (Evang and Kallmeyer 2011). This shows that it is important to properly treat such structures. 1.3 Extending the Domain of Locality In the literature, different methods have been explored that allow for the use of nonlocal information in data-driven parsing. We distinguish two classes of approaches. The first class consists of approaches that aim at using formalisms which produce trees without crossing branches but provide a larger domain of locality than CFG— for instance, through complex labels (Hockenmaier 2003) or through the derivation What should I do *r* ? What should I do WP MD PRP VB -NONE- . WP MD PRP VB . WH</context>
<context position="74781" citStr="Evang and Kallmeyer (2011)" startWordPosition="13405" endWordPosition="13408">9.23 58.52 67.06 LR 60.79 70.41 57.63 58.07 LF1 63.71 69.81 58.07 65.18 As for the work that aims to create crossing branches, Plaehn (2004) obtains 73.16 Labeled F1 using Probabilistic Discontinuous Phrase Structure Grammar (DPSG), albeit only on sentences with a length of up to 15 words. On those sentences, we obtain 83.97. The crucial difference between DPSG rules and LCFRS rules is that the former explicitly specify the material that can occur in gaps whereas LCFRS does not. Levy (2005), like us, proposes to use LCFRS but does not provide any evaluation results of his work. Very recently, Evang and Kallmeyer (2011) followed up on our work. They transform the Penn Treebank such that the trace nodes and co-indexations are converted into crossing branches and parse them with the parser presented in this article, obtaining promising results. Furthermore, van Cranenburgh, Scha, and Sangati (2011) and van Cranenburgh (2012) have also followed up on our work, introducing an integration of our approach with Data-Oriented Parsing (DOP). The former article introduces an LCFRS adaption of Goodman’s PCFG-DOP (Goodman 2003). For their evaluation, the authors use the same data as we do in Maier (2010), and obtain an </context>
</contexts>
<marker>Evang, Kallmeyer, 2011</marker>
<rawString>Evang, Kilian and Laura Kallmeyer. 2011. PLCFRS parsing of English discontinuous constituents. In Proceedings of the 12th International Conference on Parsing Technologies, pages 104–116, Dublin.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Carlos G´omez-Rodriguez</author>
<author>Marco Kuhlmann</author>
<author>Giorgio Satta</author>
</authors>
<title>Efficient parsing of well-nested linear context-free rewriting systems.</title>
<date>2010</date>
<booktitle>In Human Language Technologies: The 2010 Annual Conference of the North American Chapter of the Association for Computational Linguistics,</booktitle>
<pages>276--284</pages>
<location>Los Angeles, CA.</location>
<marker>G´omez-Rodriguez, Kuhlmann, Satta, 2010</marker>
<rawString>G´omez-Rodriguez, Carlos, Marco Kuhlmann, and Giorgio Satta. 2010. Efficient parsing of well-nested linear context-free rewriting systems. In Human Language Technologies: The 2010 Annual Conference of the North American Chapter of the Association for Computational Linguistics, pages 276–284, Los Angeles, CA.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Carlos G´omez-Rodriguez</author>
<author>Marco Kuhlmann</author>
<author>Giorgio Satta</author>
<author>David Weir</author>
</authors>
<title>Optimal reduction of rule length in linear context-free rewriting systems.</title>
<date>2009</date>
<booktitle>In Proceedings of Human Language Technologies: The 2009 Annual Conference of the North American Chapter of the Association for Computational Linguistics,</booktitle>
<pages>539--547</pages>
<location>Boulder, CO.</location>
<marker>G´omez-Rodriguez, Kuhlmann, Satta, Weir, 2009</marker>
<rawString>G´omez-Rodriguez, Carlos, Marco Kuhlmann, Giorgio Satta, and David Weir. 2009. Optimal reduction of rule length in linear context-free rewriting systems. In Proceedings of Human Language Technologies: The 2009 Annual Conference of the North American Chapter of the Association for Computational Linguistics, pages 539–547, Boulder, CO.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Joshua Goodman</author>
</authors>
<title>Efficient parsing of DOP with PCFG-reductions.</title>
<date>2003</date>
<booktitle>In Rens Bod, Remko Scha, and Khalil Sima’an, editors, Data-Oriented Parsing, CSLI Studies in Computational Linguistics. CSLI Publications,</booktitle>
<pages>125--146</pages>
<location>Stanford, CA,</location>
<contexts>
<context position="75287" citStr="Goodman 2003" startWordPosition="13482" endWordPosition="13483">se LCFRS but does not provide any evaluation results of his work. Very recently, Evang and Kallmeyer (2011) followed up on our work. They transform the Penn Treebank such that the trace nodes and co-indexations are converted into crossing branches and parse them with the parser presented in this article, obtaining promising results. Furthermore, van Cranenburgh, Scha, and Sangati (2011) and van Cranenburgh (2012) have also followed up on our work, introducing an integration of our approach with Data-Oriented Parsing (DOP). The former article introduces an LCFRS adaption of Goodman’s PCFG-DOP (Goodman 2003). For their evaluation, the authors use the same data as we do in Maier (2010), and obtain an improvement of roughly 1.5 points F-measure. They are also confronted with the same efficiency issues, however, and encounter a bottleneck in terms of parsing time. In van Cranenburgh (2012), a coarseto-fine approach is presented (see Section 6.6). With this approach much faster parsing is made possible and sentences with a length of up to 40 words can be parsed. The cost of the speed, however, is that the results lie well below the baseline results for standard PLCFRS parsing. A comparison with non-p</context>
</contexts>
<marker>Goodman, 2003</marker>
<rawString>Goodman, Joshua. 2003. Efficient parsing of DOP with PCFG-reductions. In Rens Bod, Remko Scha, and Khalil Sima’an, editors, Data-Oriented Parsing, CSLI Studies in Computational Linguistics. CSLI Publications, Stanford, CA, pages 125–146.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Johan Hall</author>
<author>Joakim Nivre</author>
</authors>
<title>A dependency-driven parser for German dependency and constituency representations.</title>
<date>2008</date>
<booktitle>In Proceedings of the Workshop on Parsing German at ACL</booktitle>
<pages>47--54</pages>
<location>Columbus, OH.</location>
<contexts>
<context position="73559" citStr="Hall and Nivre (2008)" startWordPosition="13221" endWordPosition="13224"> why the lexicalization component of the Stanford parser does not lead to better results. In any case the comparison shows that on a data set without crossing branches, our parser obtains the results one would expect. A further data set to which we can provide a comparison is the PaGe workshop experimental data (K¨ubler and Penn 2008).7 Table 4 lists the results of some of the papers in K¨ubler and Penn (2008) on TIGER, namely, for Petrov and Klein (2008) (P&amp;K), who use the Berkeley Parser (Petrov and Klein 2007); Rafferty and Manning (2008) (R&amp;M), who use the Stanford parser (see above); and Hall and Nivre (2008) (H&amp;N), who use a dependency-based approach (see next paragraph). The comparison again shows that our system produces good results. Again the performance gap between the Stanford parser and our parser warrants further investigation. 6 We have obtained the former parser from http://www.ims.uni-stuttgart.de/tcl/SOFTWARE/ LoPar.html and the latter (Version 2.0.1) from http://nlp.stanford.edu/software/lex-parser.shtml. 7 Thanks to Sandra K¨ubler for providing us with the experimental data. 113 Computational Linguistics Volume 39, Number 1 Table 4 PaGe workshop data. here P&amp;K R&amp;M H&amp;N LP 66.93 69.23</context>
<context position="77536" citStr="Hall and Nivre 2008" startWordPosition="13825" endWordPosition="13828">lexicalized internal phrase structure identifying meaningful syntactic categories such as VP or NP while the latter is only concerned with relations between lexical items. A comparison would concentrate only on relations between lexical items and the rich phrase structure provided by a constituency parser would not be taken into account. To achieve some comparison, one could of course transform the discontinuous constituency trees into dependency trees with dependencies between heads and with edge labels that encode enough of the syntactic structure to retrieve the original constituency tree (Hall and Nivre 2008). The result could then be used for 114 Kallmeyer and Maier PLCFRS Parsing a dependency evaluation. It is not clear what is to gain by this evaluation because the head-to-head dependencies one would obtain are not necessarily the predicateargument dependencies one would aim at when doing direct dependency parsing (Rambow 2010).8 8. Conclusion We have presented the first efficient implementation of a weighted deductive CYK parser for Probabilistic Linear Context-Free Rewriting Systems (PLCFRS), showing that LCFRS indeed allows for data-driven parsing while modeling discontinuities in a straight</context>
</contexts>
<marker>Hall, Nivre, 2008</marker>
<rawString>Hall, Johan and Joakim Nivre. 2008. A dependency-driven parser for German dependency and constituency representations. In Proceedings of the Workshop on Parsing German at ACL 2008, pages 47–54, Columbus, OH.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Chung-hye Han</author>
<author>Na-Rae Han</author>
<author>Eon-Suk Ko</author>
</authors>
<title>Bracketing guidelines for Penn Korean TreeBank.</title>
<date>2001</date>
<tech>Technical Report 01-10,</tech>
<institution>IRCS, University of Pennsylvania,</institution>
<location>Philadelphia, PA.</location>
<marker>Han, Han, Ko, 2001</marker>
<rawString>Han, Chung-hye, Na-Rae Han, and Eon-Suk Ko. 2001. Bracketing guidelines for Penn Korean TreeBank. Technical Report 01-10, IRCS, University of Pennsylvania, Philadelphia, PA.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Julia Hockenmaier</author>
</authors>
<title>Data and models for Statistical Parsing with Combinatory Categorial Grammar.</title>
<date>2003</date>
<tech>Ph.D. thesis,</tech>
<institution>University of Edinburgh.</institution>
<contexts>
<context position="10069" citStr="Hockenmaier 2003" startWordPosition="1516" endWordPosition="1517">(Maier and Lichte 2011). In the Penn Treebank, this holds for approximately 20% of all sentences (Evang and Kallmeyer 2011). This shows that it is important to properly treat such structures. 1.3 Extending the Domain of Locality In the literature, different methods have been explored that allow for the use of nonlocal information in data-driven parsing. We distinguish two classes of approaches. The first class consists of approaches that aim at using formalisms which produce trees without crossing branches but provide a larger domain of locality than CFG— for instance, through complex labels (Hockenmaier 2003) or through the derivation What should I do *r* ? What should I do WP MD PRP VB -NONE- . WP MD PRP VB . WHNP NP SBJ *r* SQ SBARQ VP NP VP SQ NP SBJ SBARQ WHNP 90 Kallmeyer and Maier PLCFRS Parsing CFG: Figure 3 Different domains of locality. mechanism (Chiang 2003). The second class, to which we contribute in this paper, consists of approaches that aim at producing trees which contain non-local information. Some methods realize the reconstruction of non-local information in a post- or preprocessing step to PCFG parsing (Johnson 2002; Dienes 2003; Levy and Manning 2004; Cai, Chiang, and Goldber</context>
</contexts>
<marker>Hockenmaier, 2003</marker>
<rawString>Hockenmaier, Julia. 2003. Data and models for Statistical Parsing with Combinatory Categorial Grammar. Ph.D. thesis, University of Edinburgh.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Beryl Hoffman</author>
</authors>
<title>Integrating “free” word order syntax and information structure.</title>
<date>1995</date>
<booktitle>In Seventh Conference of the European Chapter of the Association for Computational Linguistics,</booktitle>
<pages>245--251</pages>
<location>Dublin.</location>
<contexts>
<context position="1642" citStr="Hoffman 1995" startWordPosition="235" endWordPosition="236">Candito and Seddah 2010). A rather indirect effect is that morphological richness often relaxes word order constraints. The principal intuition is that a rich morphology encodes information that otherwise has to be conveyed by a particular word order. If, for instance, the case of a nominal complement is not provided by morphology, it has to be provided by the position of the complement relative to other complements in the sentence. Example (1) provides an example of case marking and free word order in German. In turn, in free word order languages, word order can encode information structure (Hoffman 1995). (1) a. der the kleine little Jungenom boy schickt sends seiner his Schwesterdat sister Briefacc letter den the b. Other possible word orders: (i) der kleine Jungenom schickt den Briefacc seiner Schwesterdat (ii) seiner Schwesterdat schickt der kleine Jungenom den Briefacc (iii) den Briefacc schickt der kleine Jungenom seiner Schwesterdat * Institut f¨ur Sprache und Information, Universit¨atsstr. 1, D-40225 D¨usseldorf, Germany. E-mail: kallmeyer®phil.uni-duesseldorf.de. ** Institut f¨ur Sprache und Information, Universit¨atsstr. 1, D-40225 D¨usseldorf, Germany. E-mail: maierw®hhu.de. Submiss</context>
</contexts>
<marker>Hoffman, 1995</marker>
<rawString>Hoffman, Beryl. 1995. Integrating “free” word order syntax and information structure. In Seventh Conference of the European Chapter of the Association for Computational Linguistics, pages 245–251, Dublin.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Tilman H¨ohle</author>
</authors>
<title>Der Begriff “Mittelfeld”—Anmerkungen ¨uber die Theorie der topologischen Felder.</title>
<date>1986</date>
<booktitle>In Akten des Siebten Internationalen Germanistenkongresses</booktitle>
<location>G¨ottingen, Germany.</location>
<marker>H¨ohle, 1986</marker>
<rawString>H¨ohle, Tilman. 1986. Der Begriff “Mittelfeld”—Anmerkungen ¨uber die Theorie der topologischen Felder. In Akten des Siebten Internationalen Germanistenkongresses 1985, G¨ottingen, Germany.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Mark Johnson</author>
</authors>
<title>A simple pattern-matching algorithm for recovering empty nodes and their antecedents.</title>
<date>2002</date>
<booktitle>In Proceedings of the 40th Annual Meeting of the Association for Computational Linguistics,</booktitle>
<pages>136--143</pages>
<location>Philadelphia, PA.</location>
<contexts>
<context position="10607" citStr="Johnson 2002" startWordPosition="1613" endWordPosition="1614">locality than CFG— for instance, through complex labels (Hockenmaier 2003) or through the derivation What should I do *r* ? What should I do WP MD PRP VB -NONE- . WP MD PRP VB . WHNP NP SBJ *r* SQ SBARQ VP NP VP SQ NP SBJ SBARQ WHNP 90 Kallmeyer and Maier PLCFRS Parsing CFG: Figure 3 Different domains of locality. mechanism (Chiang 2003). The second class, to which we contribute in this paper, consists of approaches that aim at producing trees which contain non-local information. Some methods realize the reconstruction of non-local information in a post- or preprocessing step to PCFG parsing (Johnson 2002; Dienes 2003; Levy and Manning 2004; Cai, Chiang, and Goldberg 2011). Other work uses formalisms that accommodate the direct encoding of non-local information (Plaehn 2004; Levy 2005). We pursue the latter approach. Our work is motivated by the following recent developments. Linear Context-Free Rewriting Systems (LCFRSs) (Vijay-Shanker, Weir, and Joshi 1987) have been established as a candidate for modeling both discontinuous constituents and non-projective dependency trees as they occur in treebanks (Maier and Søgaard 2008; Kuhlmann and Satta 2009; Maier and Lichte 2011). LCFRSs are a natura</context>
</contexts>
<marker>Johnson, 2002</marker>
<rawString>Johnson, Mark. 2002. A simple pattern-matching algorithm for recovering empty nodes and their antecedents. In Proceedings of the 40th Annual Meeting of the Association for Computational Linguistics, pages 136–143, Philadelphia, PA.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Laura Kallmeyer</author>
</authors>
<title>Parsing Beyond Context-Free Grammars.</title>
<date>2010</date>
<publisher>Springer,</publisher>
<location>Berlin.</location>
<contexts>
<context position="13333" citStr="Kallmeyer (2010)" startWordPosition="2029" endWordPosition="2030">ates which we use to speed up parsing. In Section 5 we explain how to extract an LCFRS from a treebank and we present grammar refinement methods for these specific treebank grammars. Finally, Section 6 presents evaluation results and Section 7 compares our work to other approaches. 1 Parts of the results presented in this paper have been presented earlier. More precisely, in Kallmeyer and Maier (2010), we presented the general architecture of the parser and all outside estimates except the LN estimate from Section 4.4 which is presented in Maier, Kaeshammer, and Kallmeyer (2012). In Maier and Kallmeyer (2010) we have presented experiments with the relative clause split from Section 3.2. Finally, Maier (2010) contains the evaluation of the baseline (together with an evaluation using other metrics). Y A LCFRS: • A • • Y1 Y2 Y3 91 Computational Linguistics Volume 39, Number 1 2. Probabilistic Linear Context-Free Rewriting Systems 2.1 Definition of PLCFRS LCFRS (Vijay-Shanker, Weir, and Joshi 1987) is an extension of CFG in which a nonterminal can span not only a single string but a tuple of strings of size k &gt; 1. k is thereby called its fan-out. We will notate LCFRS with the syntax of Simple Range Co</context>
<context position="17672" citStr="Kallmeyer 2010" startWordPosition="2910" endWordPosition="2911">ry r E P and every right-hand side non-terminal A in r and each pair X1, X2 of arguments of A in the right-hand side of r, X1 precedes X2 in the right-hand side iff X1 precedes X2 in the left-hand side. 4. A rule r E P is called an ε-rule if one of the left-hand side components of r is ε. G is ε-free if it either contains no ε-rules or there is exactly one ε-rule S(ε) -+ ε and S does not appear in any of the right-hand sides of the rules in the grammar. For every LCFRS there exists an equivalent LCFRS that is ε-free (Seki et al. 1991; Boullier 1998a) and monotone (Michaelis 2001; Kracht 2003; Kallmeyer 2010). The definition of a probabilistic LCFRS is a straightforward extension of the definition of PCFG and thus it follows (Levy 2005; Kato, Seki, and Kasami 2006) that: Definition 4 (PLCFRS) A probabilistic LCFRS (PLCFRS) is a tuple (N, T, V, P, S, p) such that (N, T, V, P, S) is an LCFRS and p : P -+ [0..1] a function such that for all A E N: ΣA(,)→6∈Pp(A(-) -+ -6) = 1 93 Computational Linguistics Volume 39, Number 1 PLCFRS with non-terminals {S, A, B}, terminals {a} and start symbol S: 0.2 : S(X) -+ A(X) 0.8 : S(XY) -+ B(X,Y) 0.7 : A(aX) -+ A(X) 0.3 : A(a) -+ e 0.8 : B(aX,aY) -+ B(X,Y) 0.2 : B(</context>
<context position="19237" citStr="Kallmeyer (2010)" startWordPosition="3188" endWordPosition="3189">encies has probability 0.16 and (b) (right-linear dependencies) has probability 0.042. 3. Parsing PLCFRS 3.1 Binarization Similarly to the transformation of a CFG into Chomsky normal form, an LCFRS can be binarized, resulting in an LCFRS of rank 2. As in the CFG case, in the transformation, we introduce a non-terminal for each right-hand side longer than 2 and split the rule into two rules, using this new intermediate non-terminal. This is repeated until all right-hand sides are of length 2. The transformation algorithm is inspired by G´omezRodr´ıguez et al. (2009) and it is also specified in Kallmeyer (2010). 3.1.1 General Binarization. In order to give the algorithm for this transformation, we need the notion of a reduction of a vector α� E [(T U V)*]i by a vector x� E Vj where all variables in x� occur in o. A reduction is, roughly, obtained by keeping all variables in α� that are not in z. This is defined as follows: Definition 5 (Reduction) Let (N, T, V, P, S) be an LCFRS, α� E [(T U V)*]i and x� E Vj for some i,j E IN. Let w = a1$ ... $&amp;i be the string obtained from concatenating the components of o, separated by a new symbol $ E/ (V U T). Let w&apos; be the image of w under a homomorphism h defi</context>
<context position="23002" citStr="Kallmeyer (2010)" startWordPosition="3888" endWordPosition="3889">, VW) B(Y, V)C(Z, W)} Equivalent binarized LCFRS: S(XPUQ) A(X, U)C1(P, Q) C1(YZ, VW) B(Y,V)C(Z,W) A(aX,aY) A(X, Y) A(a,a) ε B(bX,bY) B(X,Y) B(b,b) ε C(cX,cY) C(X,Y) C(c,c) ε Figure 8 Sample binarization of an LCFRS. 95 Computational Linguistics Volume 39, Number 1 Therefore, we can reorder the right-hand side of a rule before binarizing it. In the following, we present a binarization order that yields a minimal fan-out and a minimal variable number per production and binarization step. The algorithm is inspired by G´omez-Rodr´ıguez et al. (2009) and has first been published in this version in Kallmeyer (2010). We assume that we are only considering partitions of right-hand sides where one of the sets contains only a single non-terminal. For a given rule c = A0(*x0) → A1(*x1) ... Ak(zk), we define the characteristic string s(c, Ai) of the Ai-reduction of c as follows: Concatenate the elements of *x0, separated with new additional symbols $ while replacing every component from i with a $. We then define the arity of the characteristic string, dim(s(c,Ai)), as the number of maximal substrings x E V+ in s(Ai). Take, for example, a rule c = VP(X, YZU) → VP(X, Z)V(Y)N(U). Then s(c, VP) =$$Y$U, s(c, V) =</context>
</contexts>
<marker>Kallmeyer, 2010</marker>
<rawString>Kallmeyer, Laura. 2010. Parsing Beyond Context-Free Grammars. Springer, Berlin.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Laura Kallmeyer</author>
<author>Wolfgang Maier</author>
</authors>
<title>Data-driven parsing with probabilistic linear context-free rewriting systems.</title>
<date>2010</date>
<booktitle>In Proceedings of the 23rd International Conference on Computational Linguistics (COLING 2010),</booktitle>
<pages>537--545</pages>
<location>Beijing.</location>
<contexts>
<context position="13121" citStr="Kallmeyer and Maier (2010)" startWordPosition="1994" endWordPosition="1997">that has successfully been used for data-driven parsing.1 The paper is structured as follows. Section 2 introduces probabilistic LCFRS. Sections 3 and 4 present the binarization algorithm, the parser, and the outside estimates which we use to speed up parsing. In Section 5 we explain how to extract an LCFRS from a treebank and we present grammar refinement methods for these specific treebank grammars. Finally, Section 6 presents evaluation results and Section 7 compares our work to other approaches. 1 Parts of the results presented in this paper have been presented earlier. More precisely, in Kallmeyer and Maier (2010), we presented the general architecture of the parser and all outside estimates except the LN estimate from Section 4.4 which is presented in Maier, Kaeshammer, and Kallmeyer (2012). In Maier and Kallmeyer (2010) we have presented experiments with the relative clause split from Section 3.2. Finally, Maier (2010) contains the evaluation of the baseline (together with an evaluation using other metrics). Y A LCFRS: • A • • Y1 Y2 Y3 91 Computational Linguistics Volume 39, Number 1 2. Probabilistic Linear Context-Free Rewriting Systems 2.1 Definition of PLCFRS LCFRS (Vijay-Shanker, Weir, and Joshi </context>
</contexts>
<marker>Kallmeyer, Maier, 2010</marker>
<rawString>Kallmeyer, Laura and Wolfgang Maier. 2010. Data-driven parsing with probabilistic linear context-free rewriting systems. In Proceedings of the 23rd International Conference on Computational Linguistics (COLING 2010), pages 537–545, Beijing.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Yuki Kato</author>
<author>Hiroyuki Seki</author>
<author>Tadao Kasami</author>
</authors>
<title>Stochastic multiple context-free grammar for RNA pseudoknot modeling.</title>
<date>2006</date>
<booktitle>In Proceedings of the Eighth International Workshop on Tree Adjoining Grammar and Related Formalisms (TAG+8),</booktitle>
<pages>57--64</pages>
<location>Sydney.</location>
<marker>Kato, Seki, Kasami, 2006</marker>
<rawString>Kato, Yuki, Hiroyuki Seki, and Tadao Kasami. 2006. Stochastic multiple context-free grammar for RNA pseudoknot modeling. In Proceedings of the Eighth International Workshop on Tree Adjoining Grammar and Related Formalisms (TAG+8), pages 57–64, Sydney.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Dan Klein</author>
<author>Christopher D Manning</author>
</authors>
<title>A* Parsing: Fast exact viterbi parse selection.</title>
<date>2003</date>
<booktitle>In Proceedings of the 2003 Human Language Technology Conference of the North American Chapter of the Association for Computational Linguistics,</booktitle>
<pages>40--47</pages>
<location>Edmonton.</location>
<contexts>
<context position="11559" citStr="Klein and Manning 2003" startWordPosition="1753" endWordPosition="1756">-Shanker, Weir, and Joshi 1987) have been established as a candidate for modeling both discontinuous constituents and non-projective dependency trees as they occur in treebanks (Maier and Søgaard 2008; Kuhlmann and Satta 2009; Maier and Lichte 2011). LCFRSs are a natural extension of CFGs where the non-terminals can span tuples of possibly non-adjacent strings (see Figure 3). Because LCFRSs allow for binarization and CYK chart parsing in a way similar to CFGs, PCFG techniques, such as best-first parsing (Caraballo and Charniak 1998), weighted deductive parsing (Nederhof 2003), and A* parsing (Klein and Manning 2003a) can be transferred to LCFRS. Finally, as mentioned before, languages such as German have recently attracted the interest of the parsing community (K¨ubler and Penn 2008; Seddah, K¨ubler, and Tsarfaty 2010). We bring together these developments by presenting a parser for Probabilistic LCFRS (PLCFRS), continuing the promising work of Levy (2005). Our parser produces trees with crossing branches and thereby accounts for syntactic long-distance dependencies while not making any additional assumptions concerning the position of hypothetical traces. We have implemented a CYK parser and we present</context>
<context position="34046" citStr="Klein and Manning (2003" startWordPosition="5993" endWordPosition="5996">peed up parsing, we add the estimate of the costs for completing the item into a goal item to its weight—that is, to the weight of each item in the agenda, we add an estimate of its Viterbi outside score2 (i.e., the logarithm of the estimate). We use context summary estimates. A context summary is an equivalence class of items for which we can compute the actual outside scores. Those scores are then used as estimates. The challenge is to choose the estimate general enough to be efficiently computable and specific enough to be helpful for discriminating items in the agenda. 2 Note that just as Klein and Manning (2003a), we use the terms inside score and outside score to denote the Viterbi inside and outside scores. They are not to be confused with the actual inside or outside probability. 99 Computational Linguistics Volume 39, Number 1 Admissibility and monotonicity are two important conditions on estimates. All our outside estimates are admissible (Klein and Manning 2003a), which means that they never underestimate the actual outside score of an item. In other words, they are too optimistic about the costs of completing the item into an S item spanning the entire input. For the full SX estimate describe</context>
<context position="35527" citStr="Klein and Manning (2003" startWordPosition="6252" endWordPosition="6255">ight is greater than or equal to the weight of the consequent item. The estimates from Sections 4.2 and 4.3 are not monotonic. This means that it can happen that we deduce an item I2 from an item I1 where the weight of I2 is greater than the weight of I1. The parser can therefore end up in a local maximum that is not the global maximum we are searching for. In other words, those estimates are only figures of merit (FOM). All outside estimates are computed off-line for a certain maximal sentence length lenmax. 4.1 Full SX Estimate The full SX estimate is a PLCFRS adaption of the SX estimate of Klein and Manning (2003a) (hence the name). For a given sentence length n, the estimate gives the maximal probability of completing a category X with a span p into an S with span ((0, n)). For its computation, we need an estimate of the inside score of a category C with a span p, regardless of the actual terminals in our input. This inside estimate is computed as shown in Figure 14. Here, we do not need to consider the number of terminals outside the span of C (to the left or right or in the gaps), because they are not relevant for the inside score. Therefore the items have the form [A, (l1,...,ldim(A))], where A is</context>
<context position="40905" citStr="Klein and Manning (2003" startWordPosition="7284" endWordPosition="7287">ors is limited to vector tells top–down. 0)]) ρ ((l1, lin(ρ)=(r1 − l1,...,rk− lout(ρ)=(l1, − l1,l2−r1,... lk−rk−1, − lk, − top–down, a bottom–up “gap” ρA,ρC, ρA,ρC lenmax ρA ρC lenmax. For A item from [B,11 with probability p, then the log of the probability of [A,11 is greater or equal to in + log(p). For each item, we record its maximal weight (i.e., its maximal probability). The rule binary is slightly more complicated because we have to compute the length vector of the left-hand side of the rule from the right-hand side length vectors. A straightforward extension of the CFG algorithm from Klein and Manning (2003a) for computing the SX estimate is given in Figure 15. Here, the items have the form [A, 101 �lX] Computational Linguistics Volume 39, Number 1 any i, 0 &lt; i &lt; lenmax, and any range vector ρ, we define shift(ρ, i) as the range vector one obtains from adding i to all range boundaries in ρ and shift(ρ,−i) as the range vector one obtains from subtracting i from all boundaries in ρ. The weight of [A, C, ρA, ρC, i] estimates the log of the probability of completing a C tree with yield ρC into an A tree with yield ρA such that, if the span of A starts at position j, the span of C starts at position </context>
<context position="56774" citStr="Klein and Manning (2003" startWordPosition="10408" endWordPosition="10411">VMFIN(Y)NN(Z) Reordering for head-outward binarization: S(XYZU) → NN(Z)VP(X, U)VMFIN(Y) New rules resulting from binarizing this rule: S(XYZ) → Sbin1(X, Z)NN(Y) Sbin1(XY, Z) → VP(X, Z)VMFIN(Y) Rule extracted for the VP node: VP(X,YZ) → NN(X)AV(Y)VAINF(Z) New rules resulting from binarizing this rule: VP(X,Y) → NN(X)VPbin1(Y) VPbin1(XY) → AV(X)VAINF(Y) Figure 24 Sample head-outward binarization. Sbin1 S Tree after binarization: NN VMFIN NN AV VAINF VPbin1 VP 107 Computational Linguistics Volume 39, Number 1 where we add first the sisters to the right and then the ones to the left. This is what Klein and Manning (2003b) do. To mark the heads of phrases, we use the head rules that the Stanford parser (Klein and Manning 2003c) uses for NeGra. In all binarizations, there exists the possibility of adding additional unary rules when deriving the head. This allows for a further factorization. In the experiments, however, we do not insert unary rules, neither at the highest nor at the lowest new binarization non-terminal, because this was neither beneficial for parsing times nor for the parsing results. 5.3 Incorporating Additional Context 5.3.1 Markovization. As already mentioned in Section 3.1, a binarization t</context>
<context position="72285" citStr="Klein and Manning 2003" startWordPosition="13007" endWordPosition="13010">endeavor, because PLCFRS parsing of NeGra is an entirely new task that has no direct equivalent in previous work. In particular, it is a harder task than PCFG parsing. What we can provide in this section is a comparison of the performance of our parser on NeGraCFC to the performance of previously presented PCFG parsers on the same data set and an overview on previous work on parsing which aims at reconstructing crossing branches. For the comparison of the performance of our parser on NeGraCFC, we have performed experiments with Helmut Schmid’s LoPar (Schmid 2000) and with the Stanford Parser (Klein and Manning 2003c) on NeGraCFC.6 For the experiments both parsers were provided with gold POS tags. Recall that our parser produced labeled precision, recall, and F1 of 76.32, 76.46, and 76.34, respectively. The plain PCFG provided by LoPar delivers lower results (LP 72.86, LR 74.43, and LF1 73.63). The Stanford Parser results (markovization setting v = 2, h = 1 [Rafferty and Manning 2008], otherwise default parameters) lie in the vicinity of the results of our parser (LP 74.27, LR 76.19, LF1 75.45). Although the results for LoPar are no surprise, given the similarity of the models implemented by our parser a</context>
</contexts>
<marker>Klein, Manning, 2003</marker>
<rawString>Klein, Dan and Christopher D. Manning. 2003a. A* Parsing: Fast exact viterbi parse selection. In Proceedings of the 2003 Human Language Technology Conference of the North American Chapter of the Association for Computational Linguistics, pages 40–47, Edmonton.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Dan Klein</author>
<author>Christopher D Manning</author>
</authors>
<title>Accurate unlexicalized parsing.</title>
<date>2003</date>
<booktitle>In Proceedings of the 41st Annual Meeting of the Association for Computational Linguistics,</booktitle>
<pages>423--430</pages>
<location>Sapporo.</location>
<contexts>
<context position="11559" citStr="Klein and Manning 2003" startWordPosition="1753" endWordPosition="1756">-Shanker, Weir, and Joshi 1987) have been established as a candidate for modeling both discontinuous constituents and non-projective dependency trees as they occur in treebanks (Maier and Søgaard 2008; Kuhlmann and Satta 2009; Maier and Lichte 2011). LCFRSs are a natural extension of CFGs where the non-terminals can span tuples of possibly non-adjacent strings (see Figure 3). Because LCFRSs allow for binarization and CYK chart parsing in a way similar to CFGs, PCFG techniques, such as best-first parsing (Caraballo and Charniak 1998), weighted deductive parsing (Nederhof 2003), and A* parsing (Klein and Manning 2003a) can be transferred to LCFRS. Finally, as mentioned before, languages such as German have recently attracted the interest of the parsing community (K¨ubler and Penn 2008; Seddah, K¨ubler, and Tsarfaty 2010). We bring together these developments by presenting a parser for Probabilistic LCFRS (PLCFRS), continuing the promising work of Levy (2005). Our parser produces trees with crossing branches and thereby accounts for syntactic long-distance dependencies while not making any additional assumptions concerning the position of hypothetical traces. We have implemented a CYK parser and we present</context>
<context position="34046" citStr="Klein and Manning (2003" startWordPosition="5993" endWordPosition="5996">peed up parsing, we add the estimate of the costs for completing the item into a goal item to its weight—that is, to the weight of each item in the agenda, we add an estimate of its Viterbi outside score2 (i.e., the logarithm of the estimate). We use context summary estimates. A context summary is an equivalence class of items for which we can compute the actual outside scores. Those scores are then used as estimates. The challenge is to choose the estimate general enough to be efficiently computable and specific enough to be helpful for discriminating items in the agenda. 2 Note that just as Klein and Manning (2003a), we use the terms inside score and outside score to denote the Viterbi inside and outside scores. They are not to be confused with the actual inside or outside probability. 99 Computational Linguistics Volume 39, Number 1 Admissibility and monotonicity are two important conditions on estimates. All our outside estimates are admissible (Klein and Manning 2003a), which means that they never underestimate the actual outside score of an item. In other words, they are too optimistic about the costs of completing the item into an S item spanning the entire input. For the full SX estimate describe</context>
<context position="35527" citStr="Klein and Manning (2003" startWordPosition="6252" endWordPosition="6255">ight is greater than or equal to the weight of the consequent item. The estimates from Sections 4.2 and 4.3 are not monotonic. This means that it can happen that we deduce an item I2 from an item I1 where the weight of I2 is greater than the weight of I1. The parser can therefore end up in a local maximum that is not the global maximum we are searching for. In other words, those estimates are only figures of merit (FOM). All outside estimates are computed off-line for a certain maximal sentence length lenmax. 4.1 Full SX Estimate The full SX estimate is a PLCFRS adaption of the SX estimate of Klein and Manning (2003a) (hence the name). For a given sentence length n, the estimate gives the maximal probability of completing a category X with a span p into an S with span ((0, n)). For its computation, we need an estimate of the inside score of a category C with a span p, regardless of the actual terminals in our input. This inside estimate is computed as shown in Figure 14. Here, we do not need to consider the number of terminals outside the span of C (to the left or right or in the gaps), because they are not relevant for the inside score. Therefore the items have the form [A, (l1,...,ldim(A))], where A is</context>
<context position="40905" citStr="Klein and Manning (2003" startWordPosition="7284" endWordPosition="7287">ors is limited to vector tells top–down. 0)]) ρ ((l1, lin(ρ)=(r1 − l1,...,rk− lout(ρ)=(l1, − l1,l2−r1,... lk−rk−1, − lk, − top–down, a bottom–up “gap” ρA,ρC, ρA,ρC lenmax ρA ρC lenmax. For A item from [B,11 with probability p, then the log of the probability of [A,11 is greater or equal to in + log(p). For each item, we record its maximal weight (i.e., its maximal probability). The rule binary is slightly more complicated because we have to compute the length vector of the left-hand side of the rule from the right-hand side length vectors. A straightforward extension of the CFG algorithm from Klein and Manning (2003a) for computing the SX estimate is given in Figure 15. Here, the items have the form [A, 101 �lX] Computational Linguistics Volume 39, Number 1 any i, 0 &lt; i &lt; lenmax, and any range vector ρ, we define shift(ρ, i) as the range vector one obtains from adding i to all range boundaries in ρ and shift(ρ,−i) as the range vector one obtains from subtracting i from all boundaries in ρ. The weight of [A, C, ρA, ρC, i] estimates the log of the probability of completing a C tree with yield ρC into an A tree with yield ρA such that, if the span of A starts at position j, the span of C starts at position </context>
<context position="56774" citStr="Klein and Manning (2003" startWordPosition="10408" endWordPosition="10411">VMFIN(Y)NN(Z) Reordering for head-outward binarization: S(XYZU) → NN(Z)VP(X, U)VMFIN(Y) New rules resulting from binarizing this rule: S(XYZ) → Sbin1(X, Z)NN(Y) Sbin1(XY, Z) → VP(X, Z)VMFIN(Y) Rule extracted for the VP node: VP(X,YZ) → NN(X)AV(Y)VAINF(Z) New rules resulting from binarizing this rule: VP(X,Y) → NN(X)VPbin1(Y) VPbin1(XY) → AV(X)VAINF(Y) Figure 24 Sample head-outward binarization. Sbin1 S Tree after binarization: NN VMFIN NN AV VAINF VPbin1 VP 107 Computational Linguistics Volume 39, Number 1 where we add first the sisters to the right and then the ones to the left. This is what Klein and Manning (2003b) do. To mark the heads of phrases, we use the head rules that the Stanford parser (Klein and Manning 2003c) uses for NeGra. In all binarizations, there exists the possibility of adding additional unary rules when deriving the head. This allows for a further factorization. In the experiments, however, we do not insert unary rules, neither at the highest nor at the lowest new binarization non-terminal, because this was neither beneficial for parsing times nor for the parsing results. 5.3 Incorporating Additional Context 5.3.1 Markovization. As already mentioned in Section 3.1, a binarization t</context>
<context position="72285" citStr="Klein and Manning 2003" startWordPosition="13007" endWordPosition="13010">endeavor, because PLCFRS parsing of NeGra is an entirely new task that has no direct equivalent in previous work. In particular, it is a harder task than PCFG parsing. What we can provide in this section is a comparison of the performance of our parser on NeGraCFC to the performance of previously presented PCFG parsers on the same data set and an overview on previous work on parsing which aims at reconstructing crossing branches. For the comparison of the performance of our parser on NeGraCFC, we have performed experiments with Helmut Schmid’s LoPar (Schmid 2000) and with the Stanford Parser (Klein and Manning 2003c) on NeGraCFC.6 For the experiments both parsers were provided with gold POS tags. Recall that our parser produced labeled precision, recall, and F1 of 76.32, 76.46, and 76.34, respectively. The plain PCFG provided by LoPar delivers lower results (LP 72.86, LR 74.43, and LF1 73.63). The Stanford Parser results (markovization setting v = 2, h = 1 [Rafferty and Manning 2008], otherwise default parameters) lie in the vicinity of the results of our parser (LP 74.27, LR 76.19, LF1 75.45). Although the results for LoPar are no surprise, given the similarity of the models implemented by our parser a</context>
</contexts>
<marker>Klein, Manning, 2003</marker>
<rawString>Klein, Dan and Christopher D. Manning. 2003b. Accurate unlexicalized parsing. In Proceedings of the 41st Annual Meeting of the Association for Computational Linguistics, pages 423–430, Sapporo.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Dan Klein</author>
<author>Christopher D Manning</author>
</authors>
<title>Fast exact inference with a factored model for natural language parsing.</title>
<date>2003</date>
<booktitle>In Advances in Neural Information Processing Systems 15 (NIPS),</booktitle>
<pages>3--10</pages>
<location>Vancouver.</location>
<contexts>
<context position="11559" citStr="Klein and Manning 2003" startWordPosition="1753" endWordPosition="1756">-Shanker, Weir, and Joshi 1987) have been established as a candidate for modeling both discontinuous constituents and non-projective dependency trees as they occur in treebanks (Maier and Søgaard 2008; Kuhlmann and Satta 2009; Maier and Lichte 2011). LCFRSs are a natural extension of CFGs where the non-terminals can span tuples of possibly non-adjacent strings (see Figure 3). Because LCFRSs allow for binarization and CYK chart parsing in a way similar to CFGs, PCFG techniques, such as best-first parsing (Caraballo and Charniak 1998), weighted deductive parsing (Nederhof 2003), and A* parsing (Klein and Manning 2003a) can be transferred to LCFRS. Finally, as mentioned before, languages such as German have recently attracted the interest of the parsing community (K¨ubler and Penn 2008; Seddah, K¨ubler, and Tsarfaty 2010). We bring together these developments by presenting a parser for Probabilistic LCFRS (PLCFRS), continuing the promising work of Levy (2005). Our parser produces trees with crossing branches and thereby accounts for syntactic long-distance dependencies while not making any additional assumptions concerning the position of hypothetical traces. We have implemented a CYK parser and we present</context>
<context position="34046" citStr="Klein and Manning (2003" startWordPosition="5993" endWordPosition="5996">peed up parsing, we add the estimate of the costs for completing the item into a goal item to its weight—that is, to the weight of each item in the agenda, we add an estimate of its Viterbi outside score2 (i.e., the logarithm of the estimate). We use context summary estimates. A context summary is an equivalence class of items for which we can compute the actual outside scores. Those scores are then used as estimates. The challenge is to choose the estimate general enough to be efficiently computable and specific enough to be helpful for discriminating items in the agenda. 2 Note that just as Klein and Manning (2003a), we use the terms inside score and outside score to denote the Viterbi inside and outside scores. They are not to be confused with the actual inside or outside probability. 99 Computational Linguistics Volume 39, Number 1 Admissibility and monotonicity are two important conditions on estimates. All our outside estimates are admissible (Klein and Manning 2003a), which means that they never underestimate the actual outside score of an item. In other words, they are too optimistic about the costs of completing the item into an S item spanning the entire input. For the full SX estimate describe</context>
<context position="35527" citStr="Klein and Manning (2003" startWordPosition="6252" endWordPosition="6255">ight is greater than or equal to the weight of the consequent item. The estimates from Sections 4.2 and 4.3 are not monotonic. This means that it can happen that we deduce an item I2 from an item I1 where the weight of I2 is greater than the weight of I1. The parser can therefore end up in a local maximum that is not the global maximum we are searching for. In other words, those estimates are only figures of merit (FOM). All outside estimates are computed off-line for a certain maximal sentence length lenmax. 4.1 Full SX Estimate The full SX estimate is a PLCFRS adaption of the SX estimate of Klein and Manning (2003a) (hence the name). For a given sentence length n, the estimate gives the maximal probability of completing a category X with a span p into an S with span ((0, n)). For its computation, we need an estimate of the inside score of a category C with a span p, regardless of the actual terminals in our input. This inside estimate is computed as shown in Figure 14. Here, we do not need to consider the number of terminals outside the span of C (to the left or right or in the gaps), because they are not relevant for the inside score. Therefore the items have the form [A, (l1,...,ldim(A))], where A is</context>
<context position="40905" citStr="Klein and Manning (2003" startWordPosition="7284" endWordPosition="7287">ors is limited to vector tells top–down. 0)]) ρ ((l1, lin(ρ)=(r1 − l1,...,rk− lout(ρ)=(l1, − l1,l2−r1,... lk−rk−1, − lk, − top–down, a bottom–up “gap” ρA,ρC, ρA,ρC lenmax ρA ρC lenmax. For A item from [B,11 with probability p, then the log of the probability of [A,11 is greater or equal to in + log(p). For each item, we record its maximal weight (i.e., its maximal probability). The rule binary is slightly more complicated because we have to compute the length vector of the left-hand side of the rule from the right-hand side length vectors. A straightforward extension of the CFG algorithm from Klein and Manning (2003a) for computing the SX estimate is given in Figure 15. Here, the items have the form [A, 101 �lX] Computational Linguistics Volume 39, Number 1 any i, 0 &lt; i &lt; lenmax, and any range vector ρ, we define shift(ρ, i) as the range vector one obtains from adding i to all range boundaries in ρ and shift(ρ,−i) as the range vector one obtains from subtracting i from all boundaries in ρ. The weight of [A, C, ρA, ρC, i] estimates the log of the probability of completing a C tree with yield ρC into an A tree with yield ρA such that, if the span of A starts at position j, the span of C starts at position </context>
<context position="56774" citStr="Klein and Manning (2003" startWordPosition="10408" endWordPosition="10411">VMFIN(Y)NN(Z) Reordering for head-outward binarization: S(XYZU) → NN(Z)VP(X, U)VMFIN(Y) New rules resulting from binarizing this rule: S(XYZ) → Sbin1(X, Z)NN(Y) Sbin1(XY, Z) → VP(X, Z)VMFIN(Y) Rule extracted for the VP node: VP(X,YZ) → NN(X)AV(Y)VAINF(Z) New rules resulting from binarizing this rule: VP(X,Y) → NN(X)VPbin1(Y) VPbin1(XY) → AV(X)VAINF(Y) Figure 24 Sample head-outward binarization. Sbin1 S Tree after binarization: NN VMFIN NN AV VAINF VPbin1 VP 107 Computational Linguistics Volume 39, Number 1 where we add first the sisters to the right and then the ones to the left. This is what Klein and Manning (2003b) do. To mark the heads of phrases, we use the head rules that the Stanford parser (Klein and Manning 2003c) uses for NeGra. In all binarizations, there exists the possibility of adding additional unary rules when deriving the head. This allows for a further factorization. In the experiments, however, we do not insert unary rules, neither at the highest nor at the lowest new binarization non-terminal, because this was neither beneficial for parsing times nor for the parsing results. 5.3 Incorporating Additional Context 5.3.1 Markovization. As already mentioned in Section 3.1, a binarization t</context>
<context position="72285" citStr="Klein and Manning 2003" startWordPosition="13007" endWordPosition="13010">endeavor, because PLCFRS parsing of NeGra is an entirely new task that has no direct equivalent in previous work. In particular, it is a harder task than PCFG parsing. What we can provide in this section is a comparison of the performance of our parser on NeGraCFC to the performance of previously presented PCFG parsers on the same data set and an overview on previous work on parsing which aims at reconstructing crossing branches. For the comparison of the performance of our parser on NeGraCFC, we have performed experiments with Helmut Schmid’s LoPar (Schmid 2000) and with the Stanford Parser (Klein and Manning 2003c) on NeGraCFC.6 For the experiments both parsers were provided with gold POS tags. Recall that our parser produced labeled precision, recall, and F1 of 76.32, 76.46, and 76.34, respectively. The plain PCFG provided by LoPar delivers lower results (LP 72.86, LR 74.43, and LF1 73.63). The Stanford Parser results (markovization setting v = 2, h = 1 [Rafferty and Manning 2008], otherwise default parameters) lie in the vicinity of the results of our parser (LP 74.27, LR 76.19, LF1 75.45). Although the results for LoPar are no surprise, given the similarity of the models implemented by our parser a</context>
</contexts>
<marker>Klein, Manning, 2003</marker>
<rawString>Klein, Dan and Christopher D. Manning. 2003c. Fast exact inference with a factored model for natural language parsing. In Advances in Neural Information Processing Systems 15 (NIPS), pages 3–10, Vancouver.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Marcus Kracht</author>
</authors>
<title>The Mathematics of Language.</title>
<date>2003</date>
<journal>Number</journal>
<booktitle>in Studies in Generative Grammar. Mouton de Gruyter,</booktitle>
<volume>63</volume>
<location>Berlin.</location>
<contexts>
<context position="17655" citStr="Kracht 2003" startWordPosition="2908" endWordPosition="2909">ne if for every r E P and every right-hand side non-terminal A in r and each pair X1, X2 of arguments of A in the right-hand side of r, X1 precedes X2 in the right-hand side iff X1 precedes X2 in the left-hand side. 4. A rule r E P is called an ε-rule if one of the left-hand side components of r is ε. G is ε-free if it either contains no ε-rules or there is exactly one ε-rule S(ε) -+ ε and S does not appear in any of the right-hand sides of the rules in the grammar. For every LCFRS there exists an equivalent LCFRS that is ε-free (Seki et al. 1991; Boullier 1998a) and monotone (Michaelis 2001; Kracht 2003; Kallmeyer 2010). The definition of a probabilistic LCFRS is a straightforward extension of the definition of PCFG and thus it follows (Levy 2005; Kato, Seki, and Kasami 2006) that: Definition 4 (PLCFRS) A probabilistic LCFRS (PLCFRS) is a tuple (N, T, V, P, S, p) such that (N, T, V, P, S) is an LCFRS and p : P -+ [0..1] a function such that for all A E N: ΣA(,)→6∈Pp(A(-) -+ -6) = 1 93 Computational Linguistics Volume 39, Number 1 PLCFRS with non-terminals {S, A, B}, terminals {a} and start symbol S: 0.2 : S(X) -+ A(X) 0.8 : S(XY) -+ B(X,Y) 0.7 : A(aX) -+ A(X) 0.3 : A(a) -+ e 0.8 : B(aX,aY) -</context>
</contexts>
<marker>Kracht, 2003</marker>
<rawString>Kracht, Marcus. 2003. The Mathematics of Language. Number 63 in Studies in Generative Grammar. Mouton de Gruyter, Berlin.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Sandra K¨ubler</author>
</authors>
<title>How do treebank annotation schemes influence parsing results? Or how not to compare apples and oranges.</title>
<date>2005</date>
<booktitle>In Recent Advances in Natural Language Processing</booktitle>
<pages>293--300</pages>
<location>Borovets.</location>
<marker>K¨ubler, 2005</marker>
<rawString>K¨ubler, Sandra. 2005. How do treebank annotation schemes influence parsing results? Or how not to compare apples and oranges. In Recent Advances in Natural Language Processing 2005 (RANLP 2005), pages 293–300, Borovets.</rawString>
</citation>
<citation valid="true">
<date>2008</date>
<booktitle>Proceedings of the Workshop on Parsing German at ACL 2008. Association for Computational Linguistics,</booktitle>
<editor>K¨ubler, Sandra and Gerald Penn, editors.</editor>
<location>Columbus, OH.</location>
<contexts>
<context position="51393" citStr="(2008)" startWordPosition="9412" endWordPosition="9412">y mentioned, note that the full SX estimate and the SX estimate with span and sentence length are monotonic and allow for A∗ parsing. The other two estimates, which are both not monotonic, act as FOMs in a best-first parsing context. Consequently, they contribute to speeding up parsing but they decrease the quality of the parsing output. For further evaluation details see Section 6. 5. Grammars for Discontinuous Constituents 5.1 Grammar Extraction The algorithm we use for extracting an LCFRS from a constituency treebank with crossing branches has originally been presented in Maier and Søgaard (2008). It interprets the treebank trees as LCFRS derivation trees. Consider for instance the tree in Figure 22. The S node has two daughters, a VMFIN node and a VP node. This yields a rule S -+ VP VMFIN. The VP is discontinuous with two components that wrap around the yield of the VMFIN. Consequently, the LCFRS rule is S(XYZ) -+ VP(X,Z) VMFIN(Y). The extraction of an LCFRS from treebanks with crossing branches is almost immediate, except for the fan-out of the non-terminal categories: In the treebank, we can have the same non-terminal with different fan-outs, for instance a VP without a gap (fan-ou</context>
<context position="73351" citStr="(2008)" startWordPosition="13189" endWordPosition="13189"> 74.27, LR 76.19, LF1 75.45). Although the results for LoPar are no surprise, given the similarity of the models implemented by our parser and the Stanford parser, it remains to be investigated why the lexicalization component of the Stanford parser does not lead to better results. In any case the comparison shows that on a data set without crossing branches, our parser obtains the results one would expect. A further data set to which we can provide a comparison is the PaGe workshop experimental data (K¨ubler and Penn 2008).7 Table 4 lists the results of some of the papers in K¨ubler and Penn (2008) on TIGER, namely, for Petrov and Klein (2008) (P&amp;K), who use the Berkeley Parser (Petrov and Klein 2007); Rafferty and Manning (2008) (R&amp;M), who use the Stanford parser (see above); and Hall and Nivre (2008) (H&amp;N), who use a dependency-based approach (see next paragraph). The comparison again shows that our system produces good results. Again the performance gap between the Stanford parser and our parser warrants further investigation. 6 We have obtained the former parser from http://www.ims.uni-stuttgart.de/tcl/SOFTWARE/ LoPar.html and the latter (Version 2.0.1) from http://nlp.stanford.edu/</context>
<context position="76582" citStr="(2008)" startWordPosition="13687" endWordPosition="13687">ng as well, given that non-projectivity is the dependency-counterpart to discontinuity in constituency parsing. A meaningful comparison is difficult to do for the following reasons, however. Firstly, dependency parsing deals with relations between words, whereas in our case words are not considered in the parsing task. Our grammars take POS tags for a given and construct syntactic trees. Also, dependency conversion algorithms generally depend on the correct identification of linguistic head words (Lin 1995). We cannot rely on grammatical function labels, such as, for example, Boyd and Meurers (2008). Therefore we would have to use heuristics for the dependency conversion of the parser output. This would introduce additional noise. Secondly, the resources one obtains from our PLCFRS parser and from dependency parsers (the probabilistic LCFRS and the trained dependency parser) are quite different because the former contains non-lexicalized internal phrase structure identifying meaningful syntactic categories such as VP or NP while the latter is only concerned with relations between lexical items. A comparison would concentrate only on relations between lexical items and the rich phrase str</context>
</contexts>
<marker>2008</marker>
<rawString>K¨ubler, Sandra and Gerald Penn, editors. 2008. Proceedings of the Workshop on Parsing German at ACL 2008. Association for Computational Linguistics, Columbus, OH.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Marco Kuhlmann</author>
<author>Giorgio Satta</author>
</authors>
<title>Treebank grammar techniques for non-projective dependency parsing.</title>
<date>2009</date>
<booktitle>In Proceedings of the 12th Conference of the European Chapter of the Association for Computational Linguistics,</booktitle>
<pages>478--486</pages>
<location>Athens.</location>
<contexts>
<context position="11162" citStr="Kuhlmann and Satta 2009" startWordPosition="1691" endWordPosition="1694">ation in a post- or preprocessing step to PCFG parsing (Johnson 2002; Dienes 2003; Levy and Manning 2004; Cai, Chiang, and Goldberg 2011). Other work uses formalisms that accommodate the direct encoding of non-local information (Plaehn 2004; Levy 2005). We pursue the latter approach. Our work is motivated by the following recent developments. Linear Context-Free Rewriting Systems (LCFRSs) (Vijay-Shanker, Weir, and Joshi 1987) have been established as a candidate for modeling both discontinuous constituents and non-projective dependency trees as they occur in treebanks (Maier and Søgaard 2008; Kuhlmann and Satta 2009; Maier and Lichte 2011). LCFRSs are a natural extension of CFGs where the non-terminals can span tuples of possibly non-adjacent strings (see Figure 3). Because LCFRSs allow for binarization and CYK chart parsing in a way similar to CFGs, PCFG techniques, such as best-first parsing (Caraballo and Charniak 1998), weighted deductive parsing (Nederhof 2003), and A* parsing (Klein and Manning 2003a) can be transferred to LCFRS. Finally, as mentioned before, languages such as German have recently attracted the interest of the parsing community (K¨ubler and Penn 2008; Seddah, K¨ubler, and Tsarfaty </context>
</contexts>
<marker>Kuhlmann, Satta, 2009</marker>
<rawString>Kuhlmann, Marco and Giorgio Satta. 2009. Treebank grammar techniques for non-projective dependency parsing. In Proceedings of the 12th Conference of the European Chapter of the Association for Computational Linguistics, pages 478–486, Athens.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Roger Levy</author>
</authors>
<title>Probabilistic Models of Word Order and Syntactic Discontinuity.</title>
<date>2005</date>
<tech>Ph.D. thesis,</tech>
<institution>Stanford University.</institution>
<contexts>
<context position="10791" citStr="Levy 2005" startWordPosition="1640" endWordPosition="1641">SBJ *r* SQ SBARQ VP NP VP SQ NP SBJ SBARQ WHNP 90 Kallmeyer and Maier PLCFRS Parsing CFG: Figure 3 Different domains of locality. mechanism (Chiang 2003). The second class, to which we contribute in this paper, consists of approaches that aim at producing trees which contain non-local information. Some methods realize the reconstruction of non-local information in a post- or preprocessing step to PCFG parsing (Johnson 2002; Dienes 2003; Levy and Manning 2004; Cai, Chiang, and Goldberg 2011). Other work uses formalisms that accommodate the direct encoding of non-local information (Plaehn 2004; Levy 2005). We pursue the latter approach. Our work is motivated by the following recent developments. Linear Context-Free Rewriting Systems (LCFRSs) (Vijay-Shanker, Weir, and Joshi 1987) have been established as a candidate for modeling both discontinuous constituents and non-projective dependency trees as they occur in treebanks (Maier and Søgaard 2008; Kuhlmann and Satta 2009; Maier and Lichte 2011). LCFRSs are a natural extension of CFGs where the non-terminals can span tuples of possibly non-adjacent strings (see Figure 3). Because LCFRSs allow for binarization and CYK chart parsing in a way simila</context>
<context position="17801" citStr="Levy 2005" startWordPosition="2932" endWordPosition="2933">X2 in the right-hand side iff X1 precedes X2 in the left-hand side. 4. A rule r E P is called an ε-rule if one of the left-hand side components of r is ε. G is ε-free if it either contains no ε-rules or there is exactly one ε-rule S(ε) -+ ε and S does not appear in any of the right-hand sides of the rules in the grammar. For every LCFRS there exists an equivalent LCFRS that is ε-free (Seki et al. 1991; Boullier 1998a) and monotone (Michaelis 2001; Kracht 2003; Kallmeyer 2010). The definition of a probabilistic LCFRS is a straightforward extension of the definition of PCFG and thus it follows (Levy 2005; Kato, Seki, and Kasami 2006) that: Definition 4 (PLCFRS) A probabilistic LCFRS (PLCFRS) is a tuple (N, T, V, P, S, p) such that (N, T, V, P, S) is an LCFRS and p : P -+ [0..1] a function such that for all A E N: ΣA(,)→6∈Pp(A(-) -+ -6) = 1 93 Computational Linguistics Volume 39, Number 1 PLCFRS with non-terminals {S, A, B}, terminals {a} and start symbol S: 0.2 : S(X) -+ A(X) 0.8 : S(XY) -+ B(X,Y) 0.7 : A(aX) -+ A(X) 0.3 : A(a) -+ e 0.8 : B(aX,aY) -+ B(X,Y) 0.2 : B(a,a) -+ e Figure 5 Sample PLCFRS. As an example, consider the PLCFRS in Figure 5. This grammar simply generates a+. Words with an</context>
<context position="74650" citStr="Levy (2005)" startWordPosition="13385" endWordPosition="13386">ntal data. 113 Computational Linguistics Volume 39, Number 1 Table 4 PaGe workshop data. here P&amp;K R&amp;M H&amp;N LP 66.93 69.23 58.52 67.06 LR 60.79 70.41 57.63 58.07 LF1 63.71 69.81 58.07 65.18 As for the work that aims to create crossing branches, Plaehn (2004) obtains 73.16 Labeled F1 using Probabilistic Discontinuous Phrase Structure Grammar (DPSG), albeit only on sentences with a length of up to 15 words. On those sentences, we obtain 83.97. The crucial difference between DPSG rules and LCFRS rules is that the former explicitly specify the material that can occur in gaps whereas LCFRS does not. Levy (2005), like us, proposes to use LCFRS but does not provide any evaluation results of his work. Very recently, Evang and Kallmeyer (2011) followed up on our work. They transform the Penn Treebank such that the trace nodes and co-indexations are converted into crossing branches and parse them with the parser presented in this article, obtaining promising results. Furthermore, van Cranenburgh, Scha, and Sangati (2011) and van Cranenburgh (2012) have also followed up on our work, introducing an integration of our approach with Data-Oriented Parsing (DOP). The former article introduces an LCFRS adaption</context>
</contexts>
<marker>Levy, 2005</marker>
<rawString>Levy, Roger. 2005. Probabilistic Models of Word Order and Syntactic Discontinuity. Ph.D. thesis, Stanford University.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Roger Levy</author>
<author>Christopher D Manning</author>
</authors>
<title>Deep dependencies from context-free statistical parsers: Correcting the surface dependency approximation.</title>
<date>2004</date>
<booktitle>In Proceedings of the 42nd Meeting of the Association for Computational Linguistics (ACL’04), Main Volume,</booktitle>
<pages>328--335</pages>
<location>Barcelona.</location>
<contexts>
<context position="10643" citStr="Levy and Manning 2004" startWordPosition="1617" endWordPosition="1620">ance, through complex labels (Hockenmaier 2003) or through the derivation What should I do *r* ? What should I do WP MD PRP VB -NONE- . WP MD PRP VB . WHNP NP SBJ *r* SQ SBARQ VP NP VP SQ NP SBJ SBARQ WHNP 90 Kallmeyer and Maier PLCFRS Parsing CFG: Figure 3 Different domains of locality. mechanism (Chiang 2003). The second class, to which we contribute in this paper, consists of approaches that aim at producing trees which contain non-local information. Some methods realize the reconstruction of non-local information in a post- or preprocessing step to PCFG parsing (Johnson 2002; Dienes 2003; Levy and Manning 2004; Cai, Chiang, and Goldberg 2011). Other work uses formalisms that accommodate the direct encoding of non-local information (Plaehn 2004; Levy 2005). We pursue the latter approach. Our work is motivated by the following recent developments. Linear Context-Free Rewriting Systems (LCFRSs) (Vijay-Shanker, Weir, and Joshi 1987) have been established as a candidate for modeling both discontinuous constituents and non-projective dependency trees as they occur in treebanks (Maier and Søgaard 2008; Kuhlmann and Satta 2009; Maier and Lichte 2011). LCFRSs are a natural extension of CFGs where the non-te</context>
</contexts>
<marker>Levy, Manning, 2004</marker>
<rawString>Levy, Roger and Christopher D. Manning. 2004. Deep dependencies from context-free statistical parsers: Correcting the surface dependency approximation. In Proceedings of the 42nd Meeting of the Association for Computational Linguistics (ACL’04), Main Volume, pages 328–335, Barcelona.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Dekang Lin</author>
</authors>
<title>A dependency-based method for evaluating broad-coverage parsers.</title>
<date>1995</date>
<booktitle>In Proceedings of the 14th International Joint Conference on Artificial Intelligence (IJCAI 95),</booktitle>
<pages>1420--1427</pages>
<location>Montreal.</location>
<contexts>
<context position="76488" citStr="Lin 1995" startWordPosition="13671" endWordPosition="13672">th non-projective dependency parsers (McDonald et al. 2005; Nivre et al. 2007) might be interesting as well, given that non-projectivity is the dependency-counterpart to discontinuity in constituency parsing. A meaningful comparison is difficult to do for the following reasons, however. Firstly, dependency parsing deals with relations between words, whereas in our case words are not considered in the parsing task. Our grammars take POS tags for a given and construct syntactic trees. Also, dependency conversion algorithms generally depend on the correct identification of linguistic head words (Lin 1995). We cannot rely on grammatical function labels, such as, for example, Boyd and Meurers (2008). Therefore we would have to use heuristics for the dependency conversion of the parser output. This would introduce additional noise. Secondly, the resources one obtains from our PLCFRS parser and from dependency parsers (the probabilistic LCFRS and the trained dependency parser) are quite different because the former contains non-lexicalized internal phrase structure identifying meaningful syntactic categories such as VP or NP while the latter is only concerned with relations between lexical items. </context>
</contexts>
<marker>Lin, 1995</marker>
<rawString>Lin, Dekang. 1995. A dependency-based method for evaluating broad-coverage parsers. In Proceedings of the 14th International Joint Conference on Artificial Intelligence (IJCAI 95), pages 1420–1427, Montreal.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Wolfgang Maier</author>
</authors>
<title>Direct parsing of discontinuous constituents in German.</title>
<date>2010</date>
<booktitle>In Proceedings of the First Workshop on Statistical Parsing of Morphologically-Rich Languages at NAACL HLT 2010,</booktitle>
<pages>58--66</pages>
<location>Los Angeles, CA.</location>
<contexts>
<context position="13121" citStr="Maier (2010)" startWordPosition="1996" endWordPosition="1997">ssfully been used for data-driven parsing.1 The paper is structured as follows. Section 2 introduces probabilistic LCFRS. Sections 3 and 4 present the binarization algorithm, the parser, and the outside estimates which we use to speed up parsing. In Section 5 we explain how to extract an LCFRS from a treebank and we present grammar refinement methods for these specific treebank grammars. Finally, Section 6 presents evaluation results and Section 7 compares our work to other approaches. 1 Parts of the results presented in this paper have been presented earlier. More precisely, in Kallmeyer and Maier (2010), we presented the general architecture of the parser and all outside estimates except the LN estimate from Section 4.4 which is presented in Maier, Kaeshammer, and Kallmeyer (2012). In Maier and Kallmeyer (2010) we have presented experiments with the relative clause split from Section 3.2. Finally, Maier (2010) contains the evaluation of the baseline (together with an evaluation using other metrics). Y A LCFRS: • A • • Y1 Y2 Y3 91 Computational Linguistics Volume 39, Number 1 2. Probabilistic Linear Context-Free Rewriting Systems 2.1 Definition of PLCFRS LCFRS (Vijay-Shanker, Weir, and Joshi </context>
<context position="75365" citStr="Maier (2010)" startWordPosition="13497" endWordPosition="13498">, Evang and Kallmeyer (2011) followed up on our work. They transform the Penn Treebank such that the trace nodes and co-indexations are converted into crossing branches and parse them with the parser presented in this article, obtaining promising results. Furthermore, van Cranenburgh, Scha, and Sangati (2011) and van Cranenburgh (2012) have also followed up on our work, introducing an integration of our approach with Data-Oriented Parsing (DOP). The former article introduces an LCFRS adaption of Goodman’s PCFG-DOP (Goodman 2003). For their evaluation, the authors use the same data as we do in Maier (2010), and obtain an improvement of roughly 1.5 points F-measure. They are also confronted with the same efficiency issues, however, and encounter a bottleneck in terms of parsing time. In van Cranenburgh (2012), a coarseto-fine approach is presented (see Section 6.6). With this approach much faster parsing is made possible and sentences with a length of up to 40 words can be parsed. The cost of the speed, however, is that the results lie well below the baseline results for standard PLCFRS parsing. A comparison with non-projective dependency parsers (McDonald et al. 2005; Nivre et al. 2007) might b</context>
</contexts>
<marker>Maier, 2010</marker>
<rawString>Maier, Wolfgang. 2010. Direct parsing of discontinuous constituents in German. In Proceedings of the First Workshop on Statistical Parsing of Morphologically-Rich Languages at NAACL HLT 2010, pages 58–66, Los Angeles, CA.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Wolfgang Maier</author>
<author>Miriam Kaeshammer</author>
<author>Laura Kallmeyer</author>
</authors>
<title>Data-driven PLCFRS parsing revisited: Restricting the fan-out to two.</title>
<date>2012</date>
<booktitle>In Proceedings of the Eleventh International Conference on Tree Adjoining Grammars and Related Formalisms (TAG+11),</booktitle>
<pages>126--134</pages>
<location>Paris.</location>
<marker>Maier, Kaeshammer, Kallmeyer, 2012</marker>
<rawString>Maier, Wolfgang, Miriam Kaeshammer, and Laura Kallmeyer. 2012. Data-driven PLCFRS parsing revisited: Restricting the fan-out to two. In Proceedings of the Eleventh International Conference on Tree Adjoining Grammars and Related Formalisms (TAG+11), pages 126–134, Paris.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Wolfgang Maier</author>
<author>Laura Kallmeyer</author>
</authors>
<title>Discontinuity and non-projectivity: Using mildly context-sensitive formalisms for data-driven parsing.</title>
<date>2010</date>
<booktitle>In Proceedings of the Tenth International Workshop on Tree Adjoining Grammars and Related Formalisms (TAG+10),</booktitle>
<location>New Haven, CT.</location>
<contexts>
<context position="13333" citStr="Maier and Kallmeyer (2010)" startWordPosition="2027" endWordPosition="2030">side estimates which we use to speed up parsing. In Section 5 we explain how to extract an LCFRS from a treebank and we present grammar refinement methods for these specific treebank grammars. Finally, Section 6 presents evaluation results and Section 7 compares our work to other approaches. 1 Parts of the results presented in this paper have been presented earlier. More precisely, in Kallmeyer and Maier (2010), we presented the general architecture of the parser and all outside estimates except the LN estimate from Section 4.4 which is presented in Maier, Kaeshammer, and Kallmeyer (2012). In Maier and Kallmeyer (2010) we have presented experiments with the relative clause split from Section 3.2. Finally, Maier (2010) contains the evaluation of the baseline (together with an evaluation using other metrics). Y A LCFRS: • A • • Y1 Y2 Y3 91 Computational Linguistics Volume 39, Number 1 2. Probabilistic Linear Context-Free Rewriting Systems 2.1 Definition of PLCFRS LCFRS (Vijay-Shanker, Weir, and Joshi 1987) is an extension of CFG in which a nonterminal can span not only a single string but a tuple of strings of size k &gt; 1. k is thereby called its fan-out. We will notate LCFRS with the syntax of Simple Range Co</context>
</contexts>
<marker>Maier, Kallmeyer, 2010</marker>
<rawString>Maier, Wolfgang and Laura Kallmeyer. 2010. Discontinuity and non-projectivity: Using mildly context-sensitive formalisms for data-driven parsing. In Proceedings of the Tenth International Workshop on Tree Adjoining Grammars and Related Formalisms (TAG+10), New Haven, CT.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Wolfgang Maier</author>
<author>Timm Lichte</author>
</authors>
<title>Characterizing discontinuity in constituent treebanks.</title>
<date>2011</date>
<booktitle>In Formal Grammar. 14th International Conference, FG 2009.</booktitle>
<volume>5591</volume>
<pages>167--182</pages>
<publisher>Springer-Verlag,</publisher>
<location>Bordeaux, France,</location>
<contexts>
<context position="9475" citStr="Maier and Lichte 2011" startWordPosition="1422" endWordPosition="1425">G derivations. Consequently, most work has excluded non-local dependencies; either (in PTB-like treebanks) by discarding labeling conventions such as the co-indexation of the trace nodes in the PTB, or (in NeGra/TIGER-like treebanks) by applying tree transformations, which resolve the crossing branches (e.g., K¨ubler 2005; Boyd 2007). Especially for the latter treebanks, such a transformation is problematic, because it generally is non-reversible and implies information loss. Discontinuities are no minor phenomenon: Approximately 25% of all sentences in NeGra and TIGER have crossing branches (Maier and Lichte 2011). In the Penn Treebank, this holds for approximately 20% of all sentences (Evang and Kallmeyer 2011). This shows that it is important to properly treat such structures. 1.3 Extending the Domain of Locality In the literature, different methods have been explored that allow for the use of nonlocal information in data-driven parsing. We distinguish two classes of approaches. The first class consists of approaches that aim at using formalisms which produce trees without crossing branches but provide a larger domain of locality than CFG— for instance, through complex labels (Hockenmaier 2003) or th</context>
<context position="11186" citStr="Maier and Lichte 2011" startWordPosition="1695" endWordPosition="1698">ocessing step to PCFG parsing (Johnson 2002; Dienes 2003; Levy and Manning 2004; Cai, Chiang, and Goldberg 2011). Other work uses formalisms that accommodate the direct encoding of non-local information (Plaehn 2004; Levy 2005). We pursue the latter approach. Our work is motivated by the following recent developments. Linear Context-Free Rewriting Systems (LCFRSs) (Vijay-Shanker, Weir, and Joshi 1987) have been established as a candidate for modeling both discontinuous constituents and non-projective dependency trees as they occur in treebanks (Maier and Søgaard 2008; Kuhlmann and Satta 2009; Maier and Lichte 2011). LCFRSs are a natural extension of CFGs where the non-terminals can span tuples of possibly non-adjacent strings (see Figure 3). Because LCFRSs allow for binarization and CYK chart parsing in a way similar to CFGs, PCFG techniques, such as best-first parsing (Caraballo and Charniak 1998), weighted deductive parsing (Nederhof 2003), and A* parsing (Klein and Manning 2003a) can be transferred to LCFRS. Finally, as mentioned before, languages such as German have recently attracted the interest of the parsing community (K¨ubler and Penn 2008; Seddah, K¨ubler, and Tsarfaty 2010). We bring together</context>
<context position="61857" citStr="Maier and Lichte 2011" startWordPosition="11253" endWordPosition="11256"> are used as the training set and the remaining 10% as test set. The first data set is called NeGraLCFxS and the second is called NeGraCFG. Table 1 lists some properties of the training and test (respectively, gold) parts of NeGraLCFxS, namely, the total number of sentences, the average sentence length, the average tree height (the height of a tree being the length of the longest of all paths from the terminals to the root node), and the average number of children per node (excluding terminals). Furthermore, gap degrees (i.e., the number of gaps in the spans of non-terminal nodes) are listed (Maier and Lichte 2011). Our findings correspond to those of Maier and Lichte except for small differences due to the fact that, unlike us, they removed the punctuation from the trees. 6.2 Parser Implementation We have implemented the CYK parser described in the previous section in a system called rparse. The implementation is realized in Java.3 3 rparse is available under the GNU General Public License 2.0 at http://www.phil.hhu.de/rparse. 109 Computational Linguistics Volume 39, Number 1 Table 2 NeGraLCFRS: PLCFRS parsing results for different binarizations. Head-driven KM L-to-R Optimal Deterministic LP 74.00 74.</context>
<context position="79124" citStr="Maier and Lichte 2011" startWordPosition="14062" endWordPosition="14065">competitive quality. There are three main directions for future work on this subject. • On the symbolic side, LCFRS seems to offer more power than necessary. By removing symbolic expressivity, a lower parsing complexity can be achieved. One possibility is to disallow the use of so-called ill-nested LCFRS rules. These are rules where, roughly, the spans of two right-hand side non-terminals interleave in a cross-serial way. See the parsing algorithm in G´omez-Rodr´ıguez, Kuhlmann, and Satta (2010). Nevertheless, this seems to be too restrictive for linguistic modeling (Chen-Main and Joshi 2010; Maier and Lichte 2011). Our goal for future work is therefore to define reduced forms of ill-nested rules with which we get a lower parsing complexity. Another possibility is to reduce the fan-out of the extracted grammar. We have pursued the question whether the fan-out of the trees in the treebank can be reduced in a linguistically meaningful way in Maier, Kaeshammer, and Kallmeyer (2012). • On the side of the probabilistic model, there are certain independence assumptions made in our model that are too strong. The main problem in respect is that, due to the definition of LCFRS, we have to distinguish between occ</context>
</contexts>
<marker>Maier, Lichte, 2011</marker>
<rawString>Maier, Wolfgang and Timm Lichte. 2011. Characterizing discontinuity in constituent treebanks. In Formal Grammar. 14th International Conference, FG 2009. Bordeaux, France, July 25-26, 2009. Revised Selected Papers, volume 5591 of Lecture Notes in Artificial Intelligence, pages 167–182, Springer-Verlag, Berlin/Heidelberg/ New York.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Wolfgang Maier</author>
<author>Anders Søgaard</author>
</authors>
<title>Treebanks and mild context-sensitivity.</title>
<date>2008</date>
<booktitle>In Proceedings of the 13th Conference on Formal Grammar (FG-2008),</booktitle>
<pages>61--76</pages>
<location>Hamburg.</location>
<contexts>
<context position="11137" citStr="Maier and Søgaard 2008" startWordPosition="1687" endWordPosition="1690">tion of non-local information in a post- or preprocessing step to PCFG parsing (Johnson 2002; Dienes 2003; Levy and Manning 2004; Cai, Chiang, and Goldberg 2011). Other work uses formalisms that accommodate the direct encoding of non-local information (Plaehn 2004; Levy 2005). We pursue the latter approach. Our work is motivated by the following recent developments. Linear Context-Free Rewriting Systems (LCFRSs) (Vijay-Shanker, Weir, and Joshi 1987) have been established as a candidate for modeling both discontinuous constituents and non-projective dependency trees as they occur in treebanks (Maier and Søgaard 2008; Kuhlmann and Satta 2009; Maier and Lichte 2011). LCFRSs are a natural extension of CFGs where the non-terminals can span tuples of possibly non-adjacent strings (see Figure 3). Because LCFRSs allow for binarization and CYK chart parsing in a way similar to CFGs, PCFG techniques, such as best-first parsing (Caraballo and Charniak 1998), weighted deductive parsing (Nederhof 2003), and A* parsing (Klein and Manning 2003a) can be transferred to LCFRS. Finally, as mentioned before, languages such as German have recently attracted the interest of the parsing community (K¨ubler and Penn 2008; Sedda</context>
<context position="51393" citStr="Maier and Søgaard (2008)" startWordPosition="9409" endWordPosition="9412">ionally, as already mentioned, note that the full SX estimate and the SX estimate with span and sentence length are monotonic and allow for A∗ parsing. The other two estimates, which are both not monotonic, act as FOMs in a best-first parsing context. Consequently, they contribute to speeding up parsing but they decrease the quality of the parsing output. For further evaluation details see Section 6. 5. Grammars for Discontinuous Constituents 5.1 Grammar Extraction The algorithm we use for extracting an LCFRS from a constituency treebank with crossing branches has originally been presented in Maier and Søgaard (2008). It interprets the treebank trees as LCFRS derivation trees. Consider for instance the tree in Figure 22. The S node has two daughters, a VMFIN node and a VP node. This yields a rule S -+ VP VMFIN. The VP is discontinuous with two components that wrap around the yield of the VMFIN. Consequently, the LCFRS rule is S(XYZ) -+ VP(X,Z) VMFIN(Y). The extraction of an LCFRS from treebanks with crossing branches is almost immediate, except for the fan-out of the non-terminal categories: In the treebank, we can have the same non-terminal with different fan-outs, for instance a VP without a gap (fan-ou</context>
</contexts>
<marker>Maier, Søgaard, 2008</marker>
<rawString>Maier, Wolfgang and Anders Søgaard. 2008. Treebanks and mild context-sensitivity. In Proceedings of the 13th Conference on Formal Grammar (FG-2008), pages 61–76, Hamburg.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Mitchell Marcus</author>
<author>Grace Kim</author>
<author>Mary Ann Marcinkiewicz</author>
<author>Robert MacIntyre</author>
<author>Ann Bies</author>
<author>Mark Ferguson</author>
<author>Karen Katz</author>
<author>Britta Schasberger</author>
</authors>
<title>The Penn Treebank: Annotating predicate argument structure.</title>
<date>1994</date>
<booktitle>In Proceedings of the Human Language Technology Conference,</booktitle>
<pages>114--119</pages>
<contexts>
<context position="6213" citStr="Marcus et al. 1994" startWordPosition="935" endWordPosition="938">i pokriva. Of house-DET he repaired roof. “It is the roof of the house he repairs.” b. Gwon.han-˘ul nu.ga ka.ji.go iss.ji? Authority-OBJ who has not? “Who has no authority?” Discontinuous constituents are by no means limited to languages with freedom in word order. They also occur in languages with a rather fixed word order such as English, resulting from, for instance, long-distance movements. Examples (4a) and (4b) are examples from the Penn Treebank for long extractions resulting in discontinuous S categories and for discontinuous NPs arising from extraposed relative clauses, respectively (Marcus et al. 1994). (4) a. Long Extraction in English: (i) Those chains include Bloomingdale’s, which Campeau recently said it will sell. (ii) What should I do. b. Extraposed nominal modifiers (relative clauses and PPs) in English: (i) They sow a row of male-fertile plants nearby, which then pollinate the malesterile plants. (ii) Prices fell marginally for fuel and electricity. 1.2 Treebank Annotation and Data-Driven Parsing Most constituency treebanks rely on an annotation backbone based on Context-Free Grammar (CFG). Discontinuities cannot be modeled with CFG, because they require a larger domain of locality </context>
</contexts>
<marker>Marcus, Kim, Marcinkiewicz, MacIntyre, Bies, Ferguson, Katz, Schasberger, 1994</marker>
<rawString>Marcus, Mitchell, Grace Kim, Mary Ann Marcinkiewicz, Robert MacIntyre, Ann Bies, Mark Ferguson, Karen Katz, and Britta Schasberger. 1994. The Penn Treebank: Annotating predicate argument structure. In Proceedings of the Human Language Technology Conference, pages 114–119.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ryan McDonald</author>
<author>Fernando Pereira</author>
<author>Kiril Ribarov</author>
<author>Jan Hajiˇc</author>
</authors>
<title>Non-projective dependency parsing using spanning tree algorithms.</title>
<date>2005</date>
<booktitle>In Proceedings of Human Language Technology Conference and Conference on Empirical Methods in Natural Language Processing (HLT/EMNLP),</booktitle>
<pages>523--530</pages>
<location>Vancouver.</location>
<marker>McDonald, Pereira, Ribarov, Hajiˇc, 2005</marker>
<rawString>McDonald, Ryan, Fernando Pereira, Kiril Ribarov, and Jan Hajiˇc. 2005. Non-projective dependency parsing using spanning tree algorithms. In Proceedings of Human Language Technology Conference and Conference on Empirical Methods in Natural Language Processing (HLT/EMNLP), pages 523–530, Vancouver.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jens Michaelis</author>
</authors>
<title>On Formal Properties of Minimalist Grammars.</title>
<date>2001</date>
<tech>Ph.D. thesis,</tech>
<institution>Universit¨at Potsdam.</institution>
<contexts>
<context position="17642" citStr="Michaelis 2001" startWordPosition="2906" endWordPosition="2907">. 3. G is monotone if for every r E P and every right-hand side non-terminal A in r and each pair X1, X2 of arguments of A in the right-hand side of r, X1 precedes X2 in the right-hand side iff X1 precedes X2 in the left-hand side. 4. A rule r E P is called an ε-rule if one of the left-hand side components of r is ε. G is ε-free if it either contains no ε-rules or there is exactly one ε-rule S(ε) -+ ε and S does not appear in any of the right-hand sides of the rules in the grammar. For every LCFRS there exists an equivalent LCFRS that is ε-free (Seki et al. 1991; Boullier 1998a) and monotone (Michaelis 2001; Kracht 2003; Kallmeyer 2010). The definition of a probabilistic LCFRS is a straightforward extension of the definition of PCFG and thus it follows (Levy 2005; Kato, Seki, and Kasami 2006) that: Definition 4 (PLCFRS) A probabilistic LCFRS (PLCFRS) is a tuple (N, T, V, P, S, p) such that (N, T, V, P, S) is an LCFRS and p : P -+ [0..1] a function such that for all A E N: ΣA(,)→6∈Pp(A(-) -+ -6) = 1 93 Computational Linguistics Volume 39, Number 1 PLCFRS with non-terminals {S, A, B}, terminals {a} and start symbol S: 0.2 : S(X) -+ A(X) 0.8 : S(XY) -+ B(X,Y) 0.7 : A(aX) -+ A(X) 0.3 : A(a) -+ e 0.8</context>
</contexts>
<marker>Michaelis, 2001</marker>
<rawString>Michaelis, Jens. 2001. On Formal Properties of Minimalist Grammars. Ph.D. thesis, Universit¨at Potsdam.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Gereon M¨uller</author>
</authors>
<title>Free word order, morphological case, and sympathy theory.</title>
<date>2002</date>
<booktitle>In Gisbert Fanselow and Caroline Fery, editors, Resolving Conflicts in Grammars: Optimality Theory in Syntax, Morphology, and Phonology. Buske Verlag,</booktitle>
<pages>265--397</pages>
<location>Hamburg,</location>
<marker>M¨uller, 2002</marker>
<rawString>M¨uller, Gereon. 2002. Free word order, morphological case, and sympathy theory. In Gisbert Fanselow and Caroline Fery, editors, Resolving Conflicts in Grammars: Optimality Theory in Syntax, Morphology, and Phonology. Buske Verlag, Hamburg, pages 265–397.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Stefan M¨uller</author>
</authors>
<title>Continuous or discontinuous constituents?</title>
<date>2004</date>
<journal>Research on Language &amp; Computation,</journal>
<volume>2</volume>
<issue>2</issue>
<marker>M¨uller, 2004</marker>
<rawString>M¨uller, Stefan. 2004. Continuous or discontinuous constituents? Research on Language &amp; Computation, 2(2):209–257.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Mark-Jan Nederhof</author>
</authors>
<title>Weighted deductive parsing and knuth’s algorithm.</title>
<date>2003</date>
<journal>Computational Linguistics,</journal>
<volume>29</volume>
<issue>1</issue>
<contexts>
<context position="11519" citStr="Nederhof 2003" startWordPosition="1748" endWordPosition="1749">ewriting Systems (LCFRSs) (Vijay-Shanker, Weir, and Joshi 1987) have been established as a candidate for modeling both discontinuous constituents and non-projective dependency trees as they occur in treebanks (Maier and Søgaard 2008; Kuhlmann and Satta 2009; Maier and Lichte 2011). LCFRSs are a natural extension of CFGs where the non-terminals can span tuples of possibly non-adjacent strings (see Figure 3). Because LCFRSs allow for binarization and CYK chart parsing in a way similar to CFGs, PCFG techniques, such as best-first parsing (Caraballo and Charniak 1998), weighted deductive parsing (Nederhof 2003), and A* parsing (Klein and Manning 2003a) can be transferred to LCFRS. Finally, as mentioned before, languages such as German have recently attracted the interest of the parsing community (K¨ubler and Penn 2008; Seddah, K¨ubler, and Tsarfaty 2010). We bring together these developments by presenting a parser for Probabilistic LCFRS (PLCFRS), continuing the promising work of Levy (2005). Our parser produces trees with crossing branches and thereby accounts for syntactic long-distance dependencies while not making any additional assumptions concerning the position of hypothetical traces. We have</context>
<context position="28032" citStr="Nederhof 2003" startWordPosition="4824" endWordPosition="4825">w = t1 ... tn consists of a function f : V -+ {(i, j) J1 &lt; i &lt; j &lt; JwJ} such that for all x, y adjacent in one of the elements of &amp;, f(x) · f(y) must be defined; we then define f (xy) = f(x) · f (y), 2. if f is an instantiation of r, then A(f (a)) -+ A1( f (z1)) · · · Am(f (x&apos;m)) is an instantiated rule where f ((x1, ... , xk)) = (f (x1), ... ,f (xk)). We use a probabilistic version of the CYK parser from Seki et al. (1991). The algorithm is formulated using the framework of parsing as deduction (Pereira and Warren 1983; Shieber, Schabes, and Pereira 1995; Sikkel 1997), extended with weights (Nederhof 2003). In this framework, a set of weighted items representing partial parsing results is characterized via a set of deduction rules, and certain items (the goal items) represent successful parses. During parsing, we have to match components in the rules we use with portions of the input string. For a given input w, our items have the form [A, -p] where A E N and p~ is a range vector that characterizes the span of A. Each item has a weight in that encodes the Viterbi inside score of its best parse tree. More precisely, we use the log probability log(p) where p is the probability. The first rule (sc</context>
</contexts>
<marker>Nederhof, 2003</marker>
<rawString>Nederhof, Mark-Jan. 2003. Weighted deductive parsing and knuth’s algorithm. Computational Linguistics, 29(1):135–143.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Joakim Nivre</author>
<author>Johan Hall</author>
<author>Jens Nilsson</author>
</authors>
<title>Atanas Chanev, G¨ulsen Eryigit, Sandra K¨ubler, Svetoslav Marinov, and Erwin Marsi.</title>
<date>2007</date>
<journal>Natural Language Engineering,</journal>
<volume>13</volume>
<issue>2</issue>
<contexts>
<context position="75957" citStr="Nivre et al. 2007" startWordPosition="13592" endWordPosition="13595">a as we do in Maier (2010), and obtain an improvement of roughly 1.5 points F-measure. They are also confronted with the same efficiency issues, however, and encounter a bottleneck in terms of parsing time. In van Cranenburgh (2012), a coarseto-fine approach is presented (see Section 6.6). With this approach much faster parsing is made possible and sentences with a length of up to 40 words can be parsed. The cost of the speed, however, is that the results lie well below the baseline results for standard PLCFRS parsing. A comparison with non-projective dependency parsers (McDonald et al. 2005; Nivre et al. 2007) might be interesting as well, given that non-projectivity is the dependency-counterpart to discontinuity in constituency parsing. A meaningful comparison is difficult to do for the following reasons, however. Firstly, dependency parsing deals with relations between words, whereas in our case words are not considered in the parsing task. Our grammars take POS tags for a given and construct syntactic trees. Also, dependency conversion algorithms generally depend on the correct identification of linguistic head words (Lin 1995). We cannot rely on grammatical function labels, such as, for example</context>
</contexts>
<marker>Nivre, Hall, Nilsson, 2007</marker>
<rawString>Nivre, Joakim, Johan Hall, Jens Nilsson, Atanas Chanev, G¨ulsen Eryigit, Sandra K¨ubler, Svetoslav Marinov, and Erwin Marsi. 2007. MaltParser: A language-independent system for data-driven dependency parsing. Natural Language Engineering, 13(2):95–135.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Petya Osenova</author>
<author>Kiril Simov</author>
</authors>
<title>BTB-TR05: BulTreebank Stylebook.</title>
<date>2004</date>
<tech>Technical Report 05, BulTreeBank Project,</tech>
<location>Sofia, Bulgaria.</location>
<contexts>
<context position="5448" citStr="Osenova and Simov 2004" startWordPosition="813" endWordPosition="816">, the regulation would only constantly produce new old cases.” b. Extraposed relative clauses: (i) ... ob auf deren Gel¨ande der Typ von Abstellanlage gebaut ... whether on their terrain the type of parking facility built werden k¨onne, der ... (NeGra) get could, which ... “...whether one could build on their premises the type of parking facility, which... ” 88 Kallmeyer and Maier PLCFRS Parsing Examples of other such languages are Bulgarian and Korean. Both show discontinuous constituents as well. Example (3a) is a Bulgarian example of a PP extracted out of an NP, taken from the BulTreebank (Osenova and Simov 2004), and Example (3b) is an example of fronting in Korean, taken from the Penn Korean Treebank (Han, Han, and Ko 2001). (3) a. Na kyshtata toi popravi pokriva. Of house-DET he repaired roof. “It is the roof of the house he repairs.” b. Gwon.han-˘ul nu.ga ka.ji.go iss.ji? Authority-OBJ who has not? “Who has no authority?” Discontinuous constituents are by no means limited to languages with freedom in word order. They also occur in languages with a rather fixed word order such as English, resulting from, for instance, long-distance movements. Examples (4a) and (4b) are examples from the Penn Treeba</context>
</contexts>
<marker>Osenova, Simov, 2004</marker>
<rawString>Osenova, Petya and Kiril Simov. 2004. BTB-TR05: BulTreebank Stylebook. Technical Report 05, BulTreeBank Project, Sofia, Bulgaria.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Fernando C N Pereira</author>
<author>David Warren</author>
</authors>
<title>Parsing as deduction.</title>
<date>1983</date>
<booktitle>In Proceedings of the 21st Annual Meeting of the Association for Computational Linguistics,</booktitle>
<pages>137--144</pages>
<location>Cambridge, MA.</location>
<contexts>
<context position="27943" citStr="Pereira and Warren 1983" startWordPosition="4810" endWordPosition="4813">xm) E P (0 &lt; m) that does not contain any terminals, 1. an instantiation with respect to a string w = t1 ... tn consists of a function f : V -+ {(i, j) J1 &lt; i &lt; j &lt; JwJ} such that for all x, y adjacent in one of the elements of &amp;, f(x) · f(y) must be defined; we then define f (xy) = f(x) · f (y), 2. if f is an instantiation of r, then A(f (a)) -+ A1( f (z1)) · · · Am(f (x&apos;m)) is an instantiated rule where f ((x1, ... , xk)) = (f (x1), ... ,f (xk)). We use a probabilistic version of the CYK parser from Seki et al. (1991). The algorithm is formulated using the framework of parsing as deduction (Pereira and Warren 1983; Shieber, Schabes, and Pereira 1995; Sikkel 1997), extended with weights (Nederhof 2003). In this framework, a set of weighted items representing partial parsing results is characterized via a set of deduction rules, and certain items (the goal items) represent successful parses. During parsing, we have to match components in the rules we use with portions of the input string. For a given input w, our items have the form [A, -p] where A E N and p~ is a range vector that characterizes the span of A. Each item has a weight in that encodes the Viterbi inside score of its best parse tree. More pr</context>
</contexts>
<marker>Pereira, Warren, 1983</marker>
<rawString>Pereira, Fernando C. N. and David Warren. 1983. Parsing as deduction. In Proceedings of the 21st Annual Meeting of the Association for Computational Linguistics, pages 137–144, Cambridge, MA.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Slav Petrov</author>
<author>Dan Klein</author>
</authors>
<date>2007</date>
<note>Improved inference for unlexicalized parsing.</note>
<contexts>
<context position="71529" citStr="Petrov and Klein 2007" startWordPosition="12880" endWordPosition="12883">a coarser version of the actual PLCFRS, is then used for pruning of the search space. The problem that van Cranenburgh tackles is specific to PLCFRS: His PCFG stage generalizes over the distinction of labels by their fan-out. The merit of his work is an enormous increase in efficiency: Sentences with a length of up to 40 words can now be parsed in a reasonable time. For a comparison of the results of van Cranenburgh (2012) with our work, the same version of evaluation parameters would have to be used. The applicability and effectiveness of other coarseto-fine approaches (Charniak et al. 2006; Petrov and Klein 2007) on PLCFRS remain to be seen. 7. Comparison to Other Approaches Comparing our results with results from the literature is a difficult endeavor, because PLCFRS parsing of NeGra is an entirely new task that has no direct equivalent in previous work. In particular, it is a harder task than PCFG parsing. What we can provide in this section is a comparison of the performance of our parser on NeGraCFC to the performance of previously presented PCFG parsers on the same data set and an overview on previous work on parsing which aims at reconstructing crossing branches. For the comparison of the perfor</context>
<context position="73456" citStr="Petrov and Klein 2007" startWordPosition="13204" endWordPosition="13207">imilarity of the models implemented by our parser and the Stanford parser, it remains to be investigated why the lexicalization component of the Stanford parser does not lead to better results. In any case the comparison shows that on a data set without crossing branches, our parser obtains the results one would expect. A further data set to which we can provide a comparison is the PaGe workshop experimental data (K¨ubler and Penn 2008).7 Table 4 lists the results of some of the papers in K¨ubler and Penn (2008) on TIGER, namely, for Petrov and Klein (2008) (P&amp;K), who use the Berkeley Parser (Petrov and Klein 2007); Rafferty and Manning (2008) (R&amp;M), who use the Stanford parser (see above); and Hall and Nivre (2008) (H&amp;N), who use a dependency-based approach (see next paragraph). The comparison again shows that our system produces good results. Again the performance gap between the Stanford parser and our parser warrants further investigation. 6 We have obtained the former parser from http://www.ims.uni-stuttgart.de/tcl/SOFTWARE/ LoPar.html and the latter (Version 2.0.1) from http://nlp.stanford.edu/software/lex-parser.shtml. 7 Thanks to Sandra K¨ubler for providing us with the experimental data. 113 Co</context>
</contexts>
<marker>Petrov, Klein, 2007</marker>
<rawString>Petrov, Slav and Dan Klein. 2007. Improved inference for unlexicalized parsing.</rawString>
</citation>
<citation valid="false">
<booktitle>In Human Language Technologies 2007: The Conference of the North American Chapter of the Association for Computational Linguistics; Proceedings of the Main Conference,</booktitle>
<pages>404--411</pages>
<location>Rochester, NY.</location>
<marker></marker>
<rawString>In Human Language Technologies 2007: The Conference of the North American Chapter of the Association for Computational Linguistics; Proceedings of the Main Conference, pages 404–411, Rochester, NY.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Slav Petrov</author>
<author>Dan Klein</author>
</authors>
<title>Parsing German with latent variable grammars.</title>
<date>2008</date>
<booktitle>In Proceedings of the Workshop on Parsing German at ACL</booktitle>
<pages>24--32</pages>
<location>Columbus, OH.</location>
<contexts>
<context position="73397" citStr="Petrov and Klein (2008)" startWordPosition="13194" endWordPosition="13197"> Although the results for LoPar are no surprise, given the similarity of the models implemented by our parser and the Stanford parser, it remains to be investigated why the lexicalization component of the Stanford parser does not lead to better results. In any case the comparison shows that on a data set without crossing branches, our parser obtains the results one would expect. A further data set to which we can provide a comparison is the PaGe workshop experimental data (K¨ubler and Penn 2008).7 Table 4 lists the results of some of the papers in K¨ubler and Penn (2008) on TIGER, namely, for Petrov and Klein (2008) (P&amp;K), who use the Berkeley Parser (Petrov and Klein 2007); Rafferty and Manning (2008) (R&amp;M), who use the Stanford parser (see above); and Hall and Nivre (2008) (H&amp;N), who use a dependency-based approach (see next paragraph). The comparison again shows that our system produces good results. Again the performance gap between the Stanford parser and our parser warrants further investigation. 6 We have obtained the former parser from http://www.ims.uni-stuttgart.de/tcl/SOFTWARE/ LoPar.html and the latter (Version 2.0.1) from http://nlp.stanford.edu/software/lex-parser.shtml. 7 Thanks to Sandra </context>
</contexts>
<marker>Petrov, Klein, 2008</marker>
<rawString>Petrov, Slav and Dan Klein. 2008. Parsing German with latent variable grammars. In Proceedings of the Workshop on Parsing German at ACL 2008, pages 24–32, Columbus, OH.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Oliver Plaehn</author>
</authors>
<title>Computing the most probable parse for a discontinuous phrase-structure grammar.</title>
<date>2004</date>
<booktitle>New Developments in Parsing Technology, volume 23 of Text, Speech And Language Technology.</booktitle>
<pages>91--106</pages>
<editor>In Harry Bunt, John Carroll, and Giorgio Satta, editors,</editor>
<publisher>Kluwer,</publisher>
<location>Dordrecht,</location>
<contexts>
<context position="10779" citStr="Plaehn 2004" startWordPosition="1638" endWordPosition="1639">VB . WHNP NP SBJ *r* SQ SBARQ VP NP VP SQ NP SBJ SBARQ WHNP 90 Kallmeyer and Maier PLCFRS Parsing CFG: Figure 3 Different domains of locality. mechanism (Chiang 2003). The second class, to which we contribute in this paper, consists of approaches that aim at producing trees which contain non-local information. Some methods realize the reconstruction of non-local information in a post- or preprocessing step to PCFG parsing (Johnson 2002; Dienes 2003; Levy and Manning 2004; Cai, Chiang, and Goldberg 2011). Other work uses formalisms that accommodate the direct encoding of non-local information (Plaehn 2004; Levy 2005). We pursue the latter approach. Our work is motivated by the following recent developments. Linear Context-Free Rewriting Systems (LCFRSs) (Vijay-Shanker, Weir, and Joshi 1987) have been established as a candidate for modeling both discontinuous constituents and non-projective dependency trees as they occur in treebanks (Maier and Søgaard 2008; Kuhlmann and Satta 2009; Maier and Lichte 2011). LCFRSs are a natural extension of CFGs where the non-terminals can span tuples of possibly non-adjacent strings (see Figure 3). Because LCFRSs allow for binarization and CYK chart parsing in </context>
<context position="74295" citStr="Plaehn (2004)" startWordPosition="13328" endWordPosition="13329">results. Again the performance gap between the Stanford parser and our parser warrants further investigation. 6 We have obtained the former parser from http://www.ims.uni-stuttgart.de/tcl/SOFTWARE/ LoPar.html and the latter (Version 2.0.1) from http://nlp.stanford.edu/software/lex-parser.shtml. 7 Thanks to Sandra K¨ubler for providing us with the experimental data. 113 Computational Linguistics Volume 39, Number 1 Table 4 PaGe workshop data. here P&amp;K R&amp;M H&amp;N LP 66.93 69.23 58.52 67.06 LR 60.79 70.41 57.63 58.07 LF1 63.71 69.81 58.07 65.18 As for the work that aims to create crossing branches, Plaehn (2004) obtains 73.16 Labeled F1 using Probabilistic Discontinuous Phrase Structure Grammar (DPSG), albeit only on sentences with a length of up to 15 words. On those sentences, we obtain 83.97. The crucial difference between DPSG rules and LCFRS rules is that the former explicitly specify the material that can occur in gaps whereas LCFRS does not. Levy (2005), like us, proposes to use LCFRS but does not provide any evaluation results of his work. Very recently, Evang and Kallmeyer (2011) followed up on our work. They transform the Penn Treebank such that the trace nodes and co-indexations are conver</context>
</contexts>
<marker>Plaehn, 2004</marker>
<rawString>Plaehn, Oliver. 2004. Computing the most probable parse for a discontinuous phrase-structure grammar. In Harry Bunt, John Carroll, and Giorgio Satta, editors, New Developments in Parsing Technology, volume 23 of Text, Speech And Language Technology. Kluwer, Dordrecht, pages 91–106.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Anna Rafferty</author>
<author>Christopher D Manning</author>
</authors>
<title>Parsing three German treebanks: Lexicalized and unlexicalized baselines.</title>
<date>2008</date>
<booktitle>In Proceedings of the Workshop on Parsing German at ACL</booktitle>
<pages>40--46</pages>
<location>Columbus, OH.</location>
<contexts>
<context position="63600" citStr="Rafferty and Manning 2008" startWordPosition="11546" endWordPosition="11549">est data from which all category splits have been removed. This metric is equivalent to the corresponding PCFG metric for dim(A) = 1. Despite the shortcomings of such a measure (Rehbein and van Genabith 2007), it still allows to some extent a comparison to previous work in PCFG parsing (see also Section 7). Note that we provide the parser with gold POS tags in all experiments. 6.4 Markovization and Binarization We use the markovization settings v = 1 and h = 2 for all further experiments. The setting which has been reported to yield the best results for PCFG parsing of NeGra, v = 2 and h = 1 (Rafferty and Manning 2008), required a parsing time which was too high.4 Table 2 contains the parsing results for NeGraLCFRS using five different binarizations: Head-driven and KM are the two head-outward binarizations that use a head chosen on linguistic grounds (described in Section 5.2); L-to-R is another variant in which we always choose the rightmost daughter of a node as its head.5 Optimal reorders the left-hand side such that the fan-out of the binarized rules is optimized (described in Section 3.1.2). Finally, we also try a deterministic binarization (Deterministic) in which we binarize strictly from left to ri</context>
<context position="72660" citStr="Rafferty and Manning 2008" startWordPosition="13068" endWordPosition="13071">rk on parsing which aims at reconstructing crossing branches. For the comparison of the performance of our parser on NeGraCFC, we have performed experiments with Helmut Schmid’s LoPar (Schmid 2000) and with the Stanford Parser (Klein and Manning 2003c) on NeGraCFC.6 For the experiments both parsers were provided with gold POS tags. Recall that our parser produced labeled precision, recall, and F1 of 76.32, 76.46, and 76.34, respectively. The plain PCFG provided by LoPar delivers lower results (LP 72.86, LR 74.43, and LF1 73.63). The Stanford Parser results (markovization setting v = 2, h = 1 [Rafferty and Manning 2008], otherwise default parameters) lie in the vicinity of the results of our parser (LP 74.27, LR 76.19, LF1 75.45). Although the results for LoPar are no surprise, given the similarity of the models implemented by our parser and the Stanford parser, it remains to be investigated why the lexicalization component of the Stanford parser does not lead to better results. In any case the comparison shows that on a data set without crossing branches, our parser obtains the results one would expect. A further data set to which we can provide a comparison is the PaGe workshop experimental data (K¨ubler </context>
</contexts>
<marker>Rafferty, Manning, 2008</marker>
<rawString>Rafferty, Anna and Christopher D. Manning. 2008. Parsing three German treebanks: Lexicalized and unlexicalized baselines. In Proceedings of the Workshop on Parsing German at ACL 2008, pages 40–46, Columbus, OH.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Owen Rambow</author>
</authors>
<title>The simple truth about dependency and phrase structure representations: An opinion piece.</title>
<date>2010</date>
<booktitle>In Human Language Technologies: The 2010 Annual Conference of the North American Chapter of the Association for Computational Linguistics,</booktitle>
<pages>337--340</pages>
<location>Los Angeles, CA.</location>
<contexts>
<context position="77864" citStr="Rambow 2010" startWordPosition="13879" endWordPosition="13880">nt. To achieve some comparison, one could of course transform the discontinuous constituency trees into dependency trees with dependencies between heads and with edge labels that encode enough of the syntactic structure to retrieve the original constituency tree (Hall and Nivre 2008). The result could then be used for 114 Kallmeyer and Maier PLCFRS Parsing a dependency evaluation. It is not clear what is to gain by this evaluation because the head-to-head dependencies one would obtain are not necessarily the predicateargument dependencies one would aim at when doing direct dependency parsing (Rambow 2010).8 8. Conclusion We have presented the first efficient implementation of a weighted deductive CYK parser for Probabilistic Linear Context-Free Rewriting Systems (PLCFRS), showing that LCFRS indeed allows for data-driven parsing while modeling discontinuities in a straightforward way. To speed up parsing, we have introduced different contextsummary estimates of parse items, some acting as figures-of-merit, others allowing for A∗ parsing. We have implemented the parser and we have evaluated it with grammars extracted from the German NeGra treebank. Our experiments show that data-driven LCFRS par</context>
</contexts>
<marker>Rambow, 2010</marker>
<rawString>Rambow, Owen. 2010. The simple truth about dependency and phrase structure representations: An opinion piece. In Human Language Technologies: The 2010 Annual Conference of the North American Chapter of the Association for Computational Linguistics, pages 337–340, Los Angeles, CA.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ines Rehbein</author>
<author>Josef van Genabith</author>
</authors>
<title>Evaluating evaluation measures.</title>
<date>2007</date>
<booktitle>In Proceedings of the 16th Nordic Conference of Computational Linguistics,</booktitle>
<pages>372--379</pages>
<location>Tartu.</location>
<marker>Rehbein, van Genabith, 2007</marker>
<rawString>Rehbein, Ines and Josef van Genabith. 2007. Evaluating evaluation measures. In Proceedings of the 16th Nordic Conference of Computational Linguistics, pages 372–379, Tartu.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Helmut Schmid</author>
</authors>
<title>LoPar: Design and implementation.</title>
<date>2000</date>
<booktitle>Arbeitspapiere des Sonderforschungsbereiches 340 149, IMS,</booktitle>
<institution>University of Stuttgart,</institution>
<location>Stuttgart, Germany.</location>
<contexts>
<context position="72232" citStr="Schmid 2000" startWordPosition="13000" endWordPosition="13001">results from the literature is a difficult endeavor, because PLCFRS parsing of NeGra is an entirely new task that has no direct equivalent in previous work. In particular, it is a harder task than PCFG parsing. What we can provide in this section is a comparison of the performance of our parser on NeGraCFC to the performance of previously presented PCFG parsers on the same data set and an overview on previous work on parsing which aims at reconstructing crossing branches. For the comparison of the performance of our parser on NeGraCFC, we have performed experiments with Helmut Schmid’s LoPar (Schmid 2000) and with the Stanford Parser (Klein and Manning 2003c) on NeGraCFC.6 For the experiments both parsers were provided with gold POS tags. Recall that our parser produced labeled precision, recall, and F1 of 76.32, 76.46, and 76.34, respectively. The plain PCFG provided by LoPar delivers lower results (LP 72.86, LR 74.43, and LF1 73.63). The Stanford Parser results (markovization setting v = 2, h = 1 [Rafferty and Manning 2008], otherwise default parameters) lie in the vicinity of the results of our parser (LP 74.27, LR 76.19, LF1 75.45). Although the results for LoPar are no surprise, given the</context>
</contexts>
<marker>Schmid, 2000</marker>
<rawString>Schmid, Helmut. 2000. LoPar: Design and implementation. Arbeitspapiere des Sonderforschungsbereiches 340 149, IMS, University of Stuttgart, Stuttgart, Germany.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Djame Seddah</author>
</authors>
<title>Sandra K¨ubler, and Reut Tsarfaty, editors.</title>
<date>2010</date>
<booktitle>Proceedings of the First Workshop on Statistical Parsing of Morphologically-Rich Languages at NAACL HLT 2010. Association for Computational Linguistics,</booktitle>
<location>Los Angeles, CA.</location>
<contexts>
<context position="1053" citStr="Seddah 2010" startWordPosition="140" endWordPosition="141">refore a natural candidate to be used for data-driven parsing. To speed up parsing, we use different context-summary estimates of parse items, some of them allowing for A∗ parsing. We evaluate our parser with grammars extracted from the German NeGra treebank. Our experiments show that data-driven LCFRS parsing is feasible and yields output of competitive quality. 1. Introduction Recently, the challenges that a rich morphology poses for data-driven parsing have received growing interest. A direct effect of morphological richness is, for instance, data sparseness on a lexical level (Candito and Seddah 2010). A rather indirect effect is that morphological richness often relaxes word order constraints. The principal intuition is that a rich morphology encodes information that otherwise has to be conveyed by a particular word order. If, for instance, the case of a nominal complement is not provided by morphology, it has to be provided by the position of the complement relative to other complements in the sentence. Example (1) provides an example of case marking and free word order in German. In turn, in free word order languages, word order can encode information structure (Hoffman 1995). (1) a. de</context>
</contexts>
<marker>Seddah, 2010</marker>
<rawString>Seddah, Djame, Sandra K¨ubler, and Reut Tsarfaty, editors. 2010. Proceedings of the First Workshop on Statistical Parsing of Morphologically-Rich Languages at NAACL HLT 2010. Association for Computational Linguistics, Los Angeles, CA.</rawString>
</citation>
<citation valid="false">
<authors>
<author>Hiroyuki Seki</author>
<author>Takahashi Matsumura</author>
</authors>
<title>Mamoru Fujii, and Tadao Kasami.1991. On multiple context-free grammars.</title>
<journal>Theoretical Computer Science,</journal>
<volume>88</volume>
<issue>2</issue>
<marker>Seki, Matsumura, </marker>
<rawString>Seki, Hiroyuki, Takahashi Matsumura, Mamoru Fujii, and Tadao Kasami.1991. On multiple context-free grammars. Theoretical Computer Science, 88(2):191–229.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Stuart M Shieber</author>
<author>Yves Schabes</author>
<author>Fernando C N Pereira</author>
</authors>
<title>Principles and implementation of deductive parsing.</title>
<date>1995</date>
<journal>Journal of Logic Programming,</journal>
<pages>24--1</pages>
<marker>Shieber, Schabes, Pereira, 1995</marker>
<rawString>Shieber, Stuart M., Yves Schabes, and Fernando C. N. Pereira. 1995. Principles and implementation of deductive parsing. Journal of Logic Programming, 24(1–2):3–36.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Klaas Sikkel</author>
</authors>
<title>Parsing Schemata. Texts in Theoretical Computer Science.</title>
<date>1997</date>
<publisher>Springer,</publisher>
<location>Berlin, Heidelberg, New York.</location>
<contexts>
<context position="27993" citStr="Sikkel 1997" startWordPosition="4819" endWordPosition="4820">stantiation with respect to a string w = t1 ... tn consists of a function f : V -+ {(i, j) J1 &lt; i &lt; j &lt; JwJ} such that for all x, y adjacent in one of the elements of &amp;, f(x) · f(y) must be defined; we then define f (xy) = f(x) · f (y), 2. if f is an instantiation of r, then A(f (a)) -+ A1( f (z1)) · · · Am(f (x&apos;m)) is an instantiated rule where f ((x1, ... , xk)) = (f (x1), ... ,f (xk)). We use a probabilistic version of the CYK parser from Seki et al. (1991). The algorithm is formulated using the framework of parsing as deduction (Pereira and Warren 1983; Shieber, Schabes, and Pereira 1995; Sikkel 1997), extended with weights (Nederhof 2003). In this framework, a set of weighted items representing partial parsing results is characterized via a set of deduction rules, and certain items (the goal items) represent successful parses. During parsing, we have to match components in the rules we use with portions of the input string. For a given input w, our items have the form [A, -p] where A E N and p~ is a range vector that characterizes the span of A. Each item has a weight in that encodes the Viterbi inside score of its best parse tree. More precisely, we use the log probability log(p) where p</context>
</contexts>
<marker>Sikkel, 1997</marker>
<rawString>Sikkel, Klaas. 1997. Parsing Schemata. Texts in Theoretical Computer Science. Springer, Berlin, Heidelberg, New York.</rawString>
</citation>
<citation valid="false">
<authors>
<author>Wojciech Skut</author>
<author>Brigitte Krenn</author>
</authors>
<title>Thorten Brants, and Hans Uszkoreit.1997. An annotation scheme for free word order languages.</title>
<booktitle>In Proceedings of the Fifth Conference on Applied Natural Language Processing (ANLP),</booktitle>
<pages>88--95</pages>
<location>Washington, DC.</location>
<marker>Skut, Krenn, </marker>
<rawString>Skut, Wojciech, Brigitte Krenn, Thorten Brants, and Hans Uszkoreit.1997. An annotation scheme for free word order languages. In Proceedings of the Fifth Conference on Applied Natural Language Processing (ANLP), pages 88–95, Washington, DC.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Heike Telljohann</author>
<author>Erhard W Hinrichs</author>
<author>Sandra K¨ubler</author>
<author>Heike Zinsmeister</author>
<author>Kathrin Beck</author>
</authors>
<title>Stylebook for the T¨ubingen Treebank of Written German (T¨uBa-D/Z).</title>
<date>2012</date>
<tech>Technical report, Seminar f¨ur Sprachwissenschaft,</tech>
<institution>Universit¨at T¨ubingen, T¨ubingen,</institution>
<note>http://www.sfs. uni.tuebingen.de/resources/tuebadzstylebook-1201.pdf.</note>
<marker>Telljohann, Hinrichs, K¨ubler, Zinsmeister, Beck, 2012</marker>
<rawString>Telljohann, Heike, Erhard W. Hinrichs, Sandra K¨ubler, Heike Zinsmeister, and Kathrin Beck. 2012. Stylebook for the T¨ubingen Treebank of Written German (T¨uBa-D/Z). Technical report, Seminar f¨ur Sprachwissenschaft, Universit¨at T¨ubingen, T¨ubingen, Germany. http://www.sfs. uni.tuebingen.de/resources/tuebadzstylebook-1201.pdf.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Reut Tsarfaty</author>
<author>Joakim Nivre</author>
<author>Evelina Andersson</author>
</authors>
<title>Evaluating dependency parsing: Robust and heuristics-free cross-annotation evaluation.</title>
<date>2011</date>
<booktitle>In Proceedings of the 2011 Conference on Empirical Methods in Natural Language Processing,</booktitle>
<pages>385--396</pages>
<location>Edinburgh.</location>
<marker>Tsarfaty, Nivre, Andersson, 2011</marker>
<rawString>Tsarfaty, Reut, Joakim Nivre, and Evelina Andersson. 2011. Evaluating dependency parsing: Robust and heuristics-free cross-annotation evaluation. In Proceedings of the 2011 Conference on Empirical Methods in Natural Language Processing, pages 385–396, Edinburgh.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Hans Uszkoreit</author>
</authors>
<title>Linear precedence in discontinuous constituents: Complex fronting in German.</title>
<date>1986</date>
<tech>CSLI report CSLI-86-47,</tech>
<institution>Center for the Study of Language and Information, Stanford University,</institution>
<location>Stanford, CA.</location>
<contexts>
<context position="3458" citStr="Uszkoreit 1986" startWordPosition="502" endWordPosition="503">n. The former has a very rich and the latter a sparse morphology. See M¨uller (2002) for a survey of the linguistics literature on this discussion. With a rather free word order, constituents and single parts of them can be displaced freely within the sentence. German, for instance, has a rich inflectional system and allows for a free word order, as we have already seen in Example (1): Arguments can be scrambled, and topicalizations and extrapositions underlie few restrictions. Consequently, discontinuous constituents occur frequently. This is challenging for syntactic description in general (Uszkoreit 1986; Becker, Joshi, and Rambow 1991; Bunt 1996; M¨uller 2004), and for treebank annotation in particular (Skut et al. 1997). In this paper, we address the problem of data-driven parsing of discontinuous constituents on the basis of German. In this section, we inspect the type of data we have to deal with, and we describe the way such data are annotated in treebanks. We briefly discuss different parsing strategies for the data in question and motivate our own approach. 1.1 Discontinuous Constituents Consider the sentences in Example (2) as examples for discontinuous constituents (taken from the Ge</context>
</contexts>
<marker>Uszkoreit, 1986</marker>
<rawString>Uszkoreit, Hans. 1986. Linear precedence in discontinuous constituents: Complex fronting in German. CSLI report CSLI-86-47, Center for the Study of Language and Information, Stanford University, Stanford, CA.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Andreas van Cranenburgh</author>
</authors>
<title>Efficient parsing with linear context-free rewriting systems.</title>
<date>2012</date>
<booktitle>In Proceedings of the 13th Conference of the European Chapter of the Association for Computational Linguistics,</booktitle>
<pages>460--470</pages>
<location>Avignon.</location>
<marker>van Cranenburgh, 2012</marker>
<rawString>van Cranenburgh, Andreas. 2012. Efficient parsing with linear context-free rewriting systems. In Proceedings of the 13th Conference of the European Chapter of the Association for Computational Linguistics, pages 460–470, Avignon.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Andreas van Cranenburgh</author>
<author>Remko Scha</author>
<author>Federico Sangati</author>
</authors>
<title>Discontinuous data-oriented parsing: A mildly context-sensitive all-fragments grammar.</title>
<date>2011</date>
<booktitle>In Proceedings of the Second Workshop on Statistical Parsing of Morphologically Rich Languages (SPMRL 2011),</booktitle>
<pages>34--44</pages>
<location>Dublin.</location>
<marker>van Cranenburgh, Scha, Sangati, 2011</marker>
<rawString>van Cranenburgh, Andreas, Remko Scha, and Federico Sangati. 2011. Discontinuous data-oriented parsing: A mildly context-sensitive all-fragments grammar. In Proceedings of the Second Workshop on Statistical Parsing of Morphologically Rich Languages (SPMRL 2011), pages 34–44, Dublin.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Yannick Versley</author>
</authors>
<title>Parser evaluation across text types.</title>
<date>2005</date>
<booktitle>In Proceedings of the Fourth Workshop on Treebanks and Linguistic Theories,</booktitle>
<pages>209--220</pages>
<location>Barcelona,</location>
<contexts>
<context position="59174" citStr="Versley 2005" startWordPosition="10803" endWordPosition="10804">text of the new non-terminal X. Note that in this example we have disregarded the fan-out of the context categories. The VP, for instance, is actually a VP2 because it has fan-out 2. For the context symbols, one can either use the categories from the original treebank (without fan-out) or the ones from the LCFRS rules (with fan-out). We chose the latter approach because it delivered better parsing results. 5.3.2 Further Category Splitting. Grammar annotation (i.e., manual enhancement of annotation information through category splitting) has previously been successfully used in parsing German (Versley 2005). In order to see if such modifications can have a beneficial effect in PLCFRS parsing as well, we perform different category splits on the (unbinarized) NeGra constituency data. We split the category S (“sentence”) into SRC (“relative clause”) and S (all other categories S). Relative clauses mostly occur in a very specific context, namely, as the S XVP,NN VP S XVP ADV,NN NN VMFIN NN ADV VAINF Figure 25 Sample markovization with v = 1, h = 2. 108 Kallmeyer and Maier PLCFRS Parsing Table 1 NeGra: Properties of the data with crossing branches. training test number of sentences average sentence l</context>
</contexts>
<marker>Versley, 2005</marker>
<rawString>Versley, Yannick. 2005. Parser evaluation across text types. In Proceedings of the Fourth Workshop on Treebanks and Linguistic Theories, pages 209–220, Barcelona, Spain.</rawString>
</citation>
<citation valid="true">
<authors>
<author>K Vijay-Shanker</author>
<author>David J Weir</author>
<author>Aravind K Joshi</author>
</authors>
<title>Characterizing structural descriptions produced by various grammatical formalisms.</title>
<date>1987</date>
<booktitle>In Proceedings of the 25th Annual Meeting of the Association for Computational Linguistics,</booktitle>
<pages>104--111</pages>
<location>Stanford, CA.</location>
<marker>Vijay-Shanker, Weir, Joshi, 1987</marker>
<rawString>Vijay-Shanker, K., David J. Weir, and Aravind K. Joshi. 1987. Characterizing structural descriptions produced by various grammatical formalisms. In Proceedings of the 25th Annual Meeting of the Association for Computational Linguistics, pages 104–111, Stanford, CA.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>