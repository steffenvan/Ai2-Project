<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000001">
<title confidence="0.951631">
Inheritance and the CCG Lexicon
</title>
<author confidence="0.947969">
Mark McConville
</author>
<affiliation confidence="0.8989535">
Institute for Communicating and Collaborative Systems
School of Informatics
University of Edinburgh
2 Buccleuch Place, Edinburgh, EH8 9LW, Scotland
</affiliation>
<email confidence="0.995661">
Mark.McConville@ed.ac.uk
</email>
<sectionHeader confidence="0.996588" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999927157894737">
I propose a uniform approach to the elim-
ination of redundancy in CCG lexicons,
where grammars incorporate inheritance
hierarchies of lexical types, defined over
a simple, feature-based category descrip-
tion language. The resulting formalism is
partially ‘constraint-based’, in that the cat-
egory notation is interpreted against an un-
derlying set of tree-like feature structures.
I argue that this version of CCG subsumes
a number of other proposed category no-
tations devised to allow for the construc-
tion of more efficient lexicons. The for-
malism retains desirable properties such
as tractability and strong competence, and
provides a way of approaching the prob-
lem of how to generalise CCG lexicons
which have been automatically induced
from treebanks.
</bodyText>
<sectionHeader confidence="0.975457" genericHeader="keywords">
1 The CCG formalism
</sectionHeader>
<bodyText confidence="0.999651454545454">
In its most basic conception, a CCG over alpha-
bet E of terminal symbols is an ordered triple
(A, S, L), where A is an alphabet of saturated cat-
egory symbols, S is a distinguished element of A,
and L is a lexicon, i.e. a mapping from E to cate-
gories over A. The set of categories over alphabet
A is the closure of A under the binary infix con-
nectives / and \ and the associated ‘modalities’ of
Baldridge (2002). For example, assuming the sat-
urated category symbols ‘S’ and ‘NP’, here is a
simple CCG lexicon (modalities omitted):
</bodyText>
<sectionHeader confidence="0.473114666666667" genericHeader="introduction">
(1) John NP
Mary NP
loves (S\NP)/NP
</sectionHeader>
<bodyText confidence="0.9997432">
The combinatory projection of a CCG lexicon is
its closure under a finite set of resource-sensitive
combinatory operations such as forward applica-
tion (2), backward application (3), forward type
raising (4), and forward composition (5):
</bodyText>
<listItem confidence="0.740786833333333">
(2) X/Y Y ==&gt;. X
(3) Y X\Y ==&gt;. X
(4) X ==&gt;. Y/(Y \X)
(5) X/Y Y/Z ==&gt;. X/Z
CCG (A, S, L) over alphabet E generates string
s E E∗ just in case (s, S) is in the combinatory
projection of lexicon L. The derivation in Figure
1 shows that CCG (1) generates the sentence John
loves Mary, assuming that ‘S’ is the distinguished
symbol, and where &gt; T, &gt; B and &gt; denote in-
stances of forward raising, forward composition
and forward application respectively:
</listItem>
<figure confidence="0.687030666666667">
John loves Mary
NP (S\NP)/NP NP
&gt;T
S/(S\NP)
S/NP
&gt;
</figure>
<figureCaption confidence="0.998924">
Figure 1: A CCG derivation
</figureCaption>
<sectionHeader confidence="0.775706" genericHeader="method">
2 Lexical redundancy in CCG
</sectionHeader>
<bodyText confidence="0.999753444444444">
CCG has many advantages both as a theory of
human linguistic competence and as a tool for
practical natural language processing applications
(Steedman, 2000). However, in many cases de-
velopment has been hindered by the absence of
an agreed uniform approach to eliminating redun-
dancy in CCG lexicons. This poses a particular
problem for a radically lexicalised formalism such
as CCG, where it is customary to handle bounded
</bodyText>
<figure confidence="0.691839">
&gt;B
S
</figure>
<page confidence="0.888119">
1
</page>
<bodyText confidence="0.999310833333333">
dependency constructions such as case, agreement
and binding by means of multiple lexical cate-
gory assignments. Take for example, the language
schematised in Table 1. This fragment of English,
though small, exemplifies certain non-trivial as-
pects of case and number agreement:
</bodyText>
<figure confidence="0.958882111111111">
John John
he loves me
the girl you
girls him
I us
you love them
we the girl
they girls
girls girls
</figure>
<tableCaption confidence="0.993584">
Table 1: A fragment of English
</tableCaption>
<bodyText confidence="0.915071">
The simplest CCG lexicon for this fragment is pre-
sented in Table 2:
</bodyText>
<equation confidence="0.99786045">
John �- NPsg
sbj, NPobj
girl �- Nsg
s �- Npl\Nsg, NPpl
sbj\Nsg, NPobj\Nsg
the �- NPsg
sbj/Nsg, NPobj/Nsg,
NPpl
sbj/Npl, NPobj/Npl
I, we, they �- NPpl
sbj
me, us,them, him � NPobj
you � N Psbj, N Pobj
he �- NPsg
sbj
love �- (S\NPpl
sbj)/NPobj
s �- ((S\NPsg
sbj)/NPobj)\((S\NPpl
sbj)/NPobj)
</equation>
<tableCaption confidence="0.964171">
Table 2: A CCG lexicon
</tableCaption>
<bodyText confidence="0.992556075">
This lexicon exhibits a number of multiple cate-
gory assignments: (a) the proper noun John and
the second person pronoun you are each assigned
to two categories, one for each case distinction;
(b) the plural suffix -s is assigned to three cate-
gories, depending on both the case and ‘bar level’
of the resulting nominal; and (c) the definite arti-
cle the is assigned to four categories, one for each
combination of case and number agreement dis-
tinctions. Since in each of these three cases there
is no pretheoretical ambiguity involved, it is clear
that this lexicon violates the following efficiency-
motivated ideal on human language lexicons, in
the Chomskyan sense of locus of non-systematic
information:
ideal of functionality a lexicon is ideally a func-
tion from morphemes to category labels, modulo
genuine ambiguity
Another efficiency-motivated ideal which the
CCG lexicon in Table 2 can be argued to violate
is the following:
ideal of atomicity a lexicon is a mapping from
morphemes ideally to atomic category labels
In the above example, the transitive verb love is
mapped to the decidedly non-atomic category la-
bel (S\NPpl
sbj)/NPobj. Lexicons which violate the
criteria of functionality and atomicity are not just
inefficient in terms of storage space and develop-
ment time. They also fail to capture linguistically
significant generalisations about the behaviour of
the relevant words or morphemes.
The functionality and atomicity of a CCG lexi-
con can be easily quantified. The functionality ra-
tio of the lexicon in Table 2, with 22 lexical entries
for 14 distinct morphemes, is 22
14 = 1.6. The atom-
icity ratio is calculated by dividing the number of
saturated category symbol-tokens by the number
of lexical entries, i.e. 36
</bodyText>
<equation confidence="0.574748">
22 = 1.6.
</equation>
<bodyText confidence="0.999535677419355">
Various, more or less ad hoc generalisations of
the basic CCG category notation have been pro-
posed with a view to eliminating these kinds of
lexical redundancy. One area of interest has in-
volved the nature of the saturated category sym-
bols themselves. Bozsahin (2002) presents a ver-
sion of CCG where saturated category symbols
are modified by unary modalities annotated with
morphosyntactic features. The features are them-
selves ordered according to a language-particular
join semi-lattice. This technique, along with the
insistence that lexicons of agglutinating languages
are necessarily morphemic, allows generalisations
involving the morphological structure of nouns
and verbs in Turkish to be captured in an elegant,
non-redundant format. Erkan (2003) generalises
this approach, modelling saturated category labels
as typed feature structures, constrained by under-
specified feature structure descriptions in the usual
manner.
Hoffman (1995) resolves other violations of the
ideal of functionality in CCG lexicons for lan-
guages with ‘local scrambling’ constructions by
means of ‘multiset’ notation for unsaturated cat-
egories, where scope and direction of arguments
can be underspecified. For example, a multiset
category label like S{\NPsbj, \NPobj} is to be un-
derstood as incorporating both (S\NPsbj)\NPobj
and (S\NPobj)\NPsbj.
Computational implementations of the CCG
formalism, including successive versions of the
</bodyText>
<page confidence="0.988283">
2
</page>
<bodyText confidence="0.999707166666667">
Grok/OpenCCG system1, have generally dealt
with violations of the ideal of atomicity by allow-
ing for the definition of macro-style abbreviations
for unsaturated categories, e.g. using the macro
‘TV’ as an abbreviation for (S\NPsbj)/NPobj.
One final point of note involves the project re-
ported in Beavers (2004), who implements CCG
within the LKB system, i.e. as an application of
the Typed Feature Structure Grammar formalism
of Copestake (2002), with the full apparatus of un-
restricted typed feature structures, default inheri-
tance hierarchies, and lexical rules.
</bodyText>
<sectionHeader confidence="0.998653" genericHeader="method">
3 Type-hierarchical CCG
</sectionHeader>
<bodyText confidence="0.999961619047619">
One of the aims of the project reported here has
been to take a bottom-up approach to the prob-
lem of redundancy in CCG lexicons, adding just
enough formal machinery to allow the relevant
generalisations to be formulated, whilst retaining a
restrictive theory of human linguistic competence
which satisfies the ‘strong competence’ require-
ment, i.e. the competence grammar and the pro-
cessing grammar are identical.
I start with a generalisation of the CCG for-
malism where the alphabet of saturated category
symbols is organised into a ‘type hierarchy’ in
the sense of Carpenter (1992), i.e. a weak order
(A, CA), where A is an alphabet of types, CA is
the ‘subsumption’ ordering on A (with a least ele-
ment), and every subset of A with an upper bound
has a least upper bound. An example type hi-
erarchy is in Figure 2, where for example types
‘Nomsg’ and ‘NP’ are compatible since they have
a non-empty set of upper bounds, the least upper
bound (or ‘unifier’) being ‘NPsg’.
</bodyText>
<equation confidence="0.937588153846154">
top
✦✦✦✦ PPP �
SNom
✏✏✏✏✏✏ ��
�� ❅ ❅ ��
� �
NP Nomsg Nompl N
��
★★ ▲ ❍
❍❍ ❍ �� � ❍❍
☎☎ �� PPP
☞☞ � ❍ �
▲ � � ❍
</equation>
<bodyText confidence="0.425932">
NPsbj NPobj NPsg NPpl Nsg Npl
</bodyText>
<figure confidence="0.952064">
◗ ✏✏✏✏✏✏
◗ ✏✏✏✏✏✏
��
◗ ◗ ��
◗ ◗ ��
sg pl sg pl
NPsbj NPsbj NPobj NPobj
</figure>
<figureCaption confidence="0.998832">
Figure 2: Type hierarchy of saturated categories
</figureCaption>
<bodyText confidence="0.899771">
A type-hierarchical CCG (T-CCG) over alpha-
bet E is an ordered 4-tuple (A, CA, S, L), where
</bodyText>
<footnote confidence="0.64638">
1http://openccg.sourceforge.net
</footnote>
<equation confidence="0.991077">
(A, CA) is a type hierarchy of saturated category
symbols, S is a distinguished element of A, and
lexicon L is a mapping from E to categories over
</equation>
<bodyText confidence="0.994178">
A. Given an appropriate CA-compatibility rela-
tion on the categories over A, the combinatory
projection of T-CCG (A, CA, S, L) can again be
defined as the closure of L under the CCG com-
binatory operations, assuming that variable Y in
the type raising rule (4) is restricted to maximally
specified categories.
The T-CCG lexicon in Table 3, in tandem with
the type hierarchy in Figure 2, generates the frag-
ment of English in Table 1:
</bodyText>
<equation confidence="0.996903411764706">
John �- NPsg
girl �- Nsg
s �- Nompl\Nsg
the �- NPsg/Nsg, NPpl/Npl
I, we, they �- NPpl
sbj
me, us, them �_ NPpl
obj
you �- NPpl
he �- NPsg
sbj
him NPsgobj
love (S\NPpl
sbj)/NPobj
s �- ((S\NPsg
sbj)/NPobj)\((S\NPpl
sbj)/NPobj)
</equation>
<tableCaption confidence="0.983508">
Table 3: A T-CCG lexicon
</tableCaption>
<bodyText confidence="0.9606965">
Using this lexicon, the sentence girls love John is
derived as in Figure 3:
</bodyText>
<figure confidence="0.951917142857143">
girl s love John
Nsg Nompl\Nsg (S\NPpl
Nompl &lt; sbj)/NPobj NPsg
&gt;T &gt;B
S/(S\Nompl)
S/NPobj
&gt;
</figure>
<figureCaption confidence="0.999895">
Figure 3: A T-CCG derivation
</figureCaption>
<bodyText confidence="0.99871025">
The T-CCG lexicon in Table 3 comes closer to sat-
isfying the ideal of functionality than does the lex-
icon in Table 2. While the latter has a functionality
ratio of 1.6, the former’s is 16
</bodyText>
<equation confidence="0.673049">
14 = 1.1.
</equation>
<bodyText confidence="0.982350666666667">
This improved functionality ratio results from
the underspecification of saturated category sym-
bols inherent in the subsumption relation. For ex-
ample, whereas the proper noun John is assigned
to two distinct categories in the lexicon in Table
2, in the T-CCG lexicon it is assigned to a sin-
gle non-maximal type ‘NPsg’ which subsumes the
two maximal types ‘NPsg
sbj’ and ‘NPsgobj’. In other
</bodyText>
<equation confidence="0.57426">
S
</equation>
<page confidence="0.976254">
3
</page>
<bodyText confidence="0.999955823529412">
words, the phenomenon of case syncretism in En-
glish proper nouns is captured by having a general
singular noun phrase type, which subsumes a plu-
rality of case distinctions.
The T-CCG formalism is equivalent to the ‘mor-
phosyntactic CCG’ formalism of Bozsahin (2002),
where features are ordered in a join semi-lattice.
Any generalisation which can be expressed in a
morphosyntactic CCG can also be expressed in a
T-CCG, since any lattice of morphosyntactic fea-
tures can be converted into a type hierarchy. In
addition, T-CCG is equivalent to the formalism
described in Erkan (2003), where saturated cat-
egories are modelled as typed feature structures.
Any lexicon from either of these formalisms can
be translated into a T-CCG lexicon whose func-
tionality ratio is either equivalent or lower.
</bodyText>
<sectionHeader confidence="0.999826" genericHeader="method">
4 Inheritance-driven CCG
</sectionHeader>
<bodyText confidence="0.999170222222222">
A second generalisation of the CCG formalism in-
volves adding a second alphabet of non-terminals,
in this case a set of ‘lexical types’. The lexical
types are organised into an ‘inheritance hierarchy’,
constrained by expressions of a simple feature-
based category description language, inspired by
previous attempts to integrate categorial grammars
and unification-based grammars, e.g. Uszkoreit
(1986) and Zeevat et al. (1987).
</bodyText>
<subsectionHeader confidence="0.994485">
4.1 Simple category descriptions
</subsectionHeader>
<bodyText confidence="0.999616666666667">
The set of simple category descriptions over al-
phabet A of saturated category symbols is defined
as the smallest set Φ such that:
</bodyText>
<listItem confidence="0.9991135">
1. A C Φ
2. for all 6 E If, b}, (SLASH 6) E Φ
3. for all 0 E Φ, (ARG 0) E Φ
4. for all 0 E Φ, (RES 0) E Φ
</listItem>
<bodyText confidence="0.9998365">
Note that category descriptions may be infinitely
embedded, in which case they are considered to
be right-associative, e.g. RES ARG RES SLASH f.
A simple category description like (SLASH f) or
(SLASH b) denotes the set of all expressions which
seek their argument to the right/left. A description
of the form (ARG 0) denotes the set of expressions
which take an argument of category 0, and one
like (RES 0) denotes the set of expressions which
combine with an argument to yield an expression
of category 0.
Complex category descriptions are simply sets
of simple category descriptions, where the as-
sumed semantics is simply that of conjunction.
</bodyText>
<subsectionHeader confidence="0.987911">
4.2 Lexical inheritance hierarchies
</subsectionHeader>
<bodyText confidence="0.999846571428572">
Lexical inheritance hierarchies (Flickinger, 1987)
are type hierarchies where each type is associated
with a set of expressions drawn from some cate-
gory description language Φ. Formally, they are
ordered triples (B, EB, b), where (B, EB) is a
type hierarchy, and b is a function from B to ℘(Φ).
An example lexical inheritance hierarchy over
the set of category descriptions over the alpha-
bet of saturated category symbols in Table 2 is
presented in Figure 4. The intuition underlying
these (monotonic) inheritance hierarchies is that
instances of a type must satisfy all the constraints
associated with that type, as well as all the con-
straints it inherits from its supertypes.
</bodyText>
<figure confidence="0.940784">
top
✘✘✘✘✘ ❍ ❍ ❍ ❍ ❍
suffix
SLASH b
</figure>
<figureCaption confidence="0.999954">
Figure 4: A lexical inheritance hierarchy
</figureCaption>
<bodyText confidence="0.999904166666667">
This example hierarchy is a single inheritance hi-
erarchy, since every lexical type has no more than
one immediate supertype. However, multiple in-
heritance hierarchies are also allowed, where a
given type can inherit constraints from two super-
types, neither of which subsumes the other.
</bodyText>
<subsectionHeader confidence="0.994918">
4.3 I-CCGs
</subsectionHeader>
<bodyText confidence="0.999412181818182">
An inheritance-driven CCG (I-CCG) over alpha-
bet E is an ordered 7-tuple (A, EA, B, EB, b,
S, L), where (A, EA) is a type hierarchy of sat-
urated category symbols, (B, EB, b) is an inheri-
tance hierarchy of lexical types over the set of cat-
egory descriptions over AUB, S is a distinguished
symbol in A, and lexicon L is a function from E to
A U B. Given an appropriate LA,B-compatibility
relation on the categories over AUB, the combina-
tory projection of I-CCG (A, EA, B, EB, b, S, L)
can again be defined as the closure of L under the
</bodyText>
<figure confidence="0.9967001">
verb
SLASH f
ARG NPobj
RES SLASH b
RES ARG NPsbj
RES RES S
det
SLASH f
ARG N
RES NP
� ✁✁ ❈❈
verbpl suffixsg ARG verbpl ❈
RES ARG Nompl RES verbsg ❈
✡ ❇
detsg ❇
ARG Nomsg ❇
RES Nomsg
verbsg detpl suffixpl
RES ARG Nomsg ARG Nompl ARG Nsg
RES Nompl RES Nompl
</figure>
<page confidence="0.976119">
4
</page>
<bodyText confidence="0.987053166666667">
CCG combinatory operations.
The I-CCG lexicon in Table 4, along with the
type hierarchy of saturated category symbols in
Figure 2 and the inheritance hierarchy of lexical
types in Figure 4, generates the fragment of En-
glish in Table 1. Using this lexicon, the sentence
</bodyText>
<figure confidence="0.8164435">
John ` NPsg
girl ` Nsg
s ` suffix
the ` det
I, we, they ` NPpl
sbj
me, us, them ` NPpl
obj
you ` NPpl
he ` NPsg
sbj
him ` NPsg
obj
love ` verbpl
</figure>
<tableCaption confidence="0.976544">
Table 4: An I-CCG lexicon
</tableCaption>
<bodyText confidence="0.886143">
girls love John is derived as in Figure 5, where
derivational steps involve ‘cache-ing out’ sets of
constraints from lexical types.
</bodyText>
<figure confidence="0.983761916666667">
girl s love John
Nsg suffix verbpl NPsg
RES S
SLASH f
ARG RES S
ARG ARG Nompl
ARG SLASH b
&gt;B
RES S
ARG NPobj
SLASHf
&gt;
</figure>
<figureCaption confidence="0.99975">
Figure 5: An I-CCG derivation
</figureCaption>
<bodyText confidence="0.999674857142857">
This derivation relies on a version of the CCG
combinatory rules defined in terms of the I-CCG
category description language. For example, for-
ward application is expressed as follows — for all
compex category descriptions Φ and Ψ such that
(SLASH b) ∈6 Φ, and {0  |(ARG 0) ∈ Φ} ∪ Ψ is
compatible, the following is a valid inference:
</bodyText>
<equation confidence="0.9961135">
Φ Ψ
{0  |(RES 0) ∈ Φ}
</equation>
<bodyText confidence="0.931942">
The functionality ratio of the I-CCG lexicon in Ta-
ble 4 is 14 14= 1 and the atomicity ratio is 14
</bodyText>
<equation confidence="0.482539">
14 = 1.
</equation>
<bodyText confidence="0.999720763157895">
In other words, the lexicon is maximally non-
redundant, since all the linguistically significant
generalisations are encodable within the lexical in-
heritance hierarchy.
The optimal atomicity ratio of the I-CCG lexi-
con is a direct result of the introduction of lexical
types. In the T-CCG lexicon in Table 3, the transi-
tive verb love was assigned to a non-atomically la-
belled category (S\NPpl
sbj)/NPobj. In the I-CCG’s
inheritance hierarchy in Figure 4, there is a lexical
type ‘verbpl’ which inherits six constraints whose
conjunction picks out exactly the same category.
It is with this atomic label that the verb is paired
in the I-CCG lexicon in Table 4.
The lexical inheritance hierarchy also has a role
to play in constructing lexicons with optimal func-
tionality ratios. The T-CCG lexicon in Table 3
assigned the definite article to two distinct cate-
gories, one for each grammatical number distinc-
tion. The I-CCG utilises the disjunction inherent
in inheritance hierarchies to give each of these a
common supertype ‘det’, which is associated with
the properties all determiners share.
Finally, the I-CCG formalism can be argued
to subsume the multiset category notation of
Hoffman (1995), in the sense that every mul-
tiset CCG lexicon can be converted into an I-
CCG lexicon with an equivalent or better func-
tionality ratio. Recall that Hoffman uses gener-
alised category notation like S{\NPsbj, \NPobj}
to subsume two standard CCG category labels
(S\NPsbj)\NPobj and (S\NPobj)\NPsbj. Again it
should be clear that this is just another way of
representing disjunction in a categorial lexicon,
and can be straightforwardly converted into a lexi-
cal inheritance hierarchy over I-CCG category de-
scriptions.
</bodyText>
<subsectionHeader confidence="0.492031">
5 Semantics of the category notation
</subsectionHeader>
<bodyText confidence="0.9999269">
In the categorial grammar tradition initiated by
Lambek (1958), the standard way of providing a
semantics for category notation defines the deno-
tation of a category description as a set of strings
of terminal symbols. Thus, assuming an alphabet
E and a denotation function [[...]] from the sat-
urated category symbols to p(E), the denotata of
unsaturated category descriptions can be defined
as follows, assuming that the underlying logic is
simply that of string concatenation:
</bodyText>
<equation confidence="0.8991655">
(6) [[0/ψ]] = {s  |∀s&apos; ∈ [[ψ]], ss&apos; ∈ [[0]]}
[[0\ψ]] = {s  |∀s&apos; ∈ [[ψ]], s&apos;s ∈ [[0]]}
</equation>
<bodyText confidence="0.5071485">
This suggests an obvious way of interpreting the
I-CCG category notation defined above. Let’s
</bodyText>
<table confidence="0.90391825">
SLASH b RES ARG Nompl
suffixpl verb
ARG Nsg SLASH f
RES Nompl ARG NPobj
&lt; RES SLASH b
Nompl RES ARG NPsbj
&gt;T RES RES S
S
</table>
<page confidence="0.989407">
5
</page>
<bodyText confidence="0.865449090909091">
start by assuming that, given some I-CCG (A, EA,
B, EB, b, S, L) over alphabet E, there is a deno-
tation function [[...]] from the maximal types in
the hierarchy of saturated categories (A, EA) to
p(E). For all non-maximal saturated category
symbols 0 in A, the denotation of 0 is then the
set of all strings in any of 0’s subcategories, i.e.
[[0]] = UφE:Aψ[[ψ]]. The denotata of the simple
category descriptions can be defined by universal
quantification over the set of simple category de-
scriptions Φ:
</bodyText>
<listItem confidence="0.9997655">
• [[SLASH f]] = Uφ,ψEΦ[[0/ψ]]
• [[SLASH b]] = Uφ,ψEΦ[[0\ψ]]
• [[ARG 0]] = UψEΦ[[ψ/0]] U [[ψ\0]]
• [[RES 0]] = UψEΦ[[0/ψ]] U [[0\ψ]]
</listItem>
<bodyText confidence="0.996089966666667">
.
Unfortunately, this approach to interpreting I-
CCG category descriptions is insufficient, since
the logic underlying CCG is not simply the logic
of string concatenation, i.e. CCG allows a limited
degree of permutation by dint of the crossed com-
position and substitution operations. In fact, there
appears to be no categorial type logic, in the sense
of Moortgat (1997), for which the CCG combi-
natory operations provide a sound and complete
derivation system, even in the resource-sensitive
system of Baldridge (2002). An alternative ap-
proach involves interpreting I-CCG category de-
scriptions against totally well-typed, sort-resolved
feature structures, as in the HPSG formalism of
Pollard and Sag (1994).
Given some type hierarchy (A, EA) of saturated
category symbols and some lexical inheritance hi-
erarchy (B, EB, b), we define a class of ‘category
models’, i.e. binary trees where every leaf node
carries a maximal saturated category symbol in A,
every non-leaf node carries a directional slash, and
every branch is labelled as either a ‘result’ or an
‘argument’. In addition, nodes are optionally la-
belled with maximal lexical types from B. Note
that since only maximal types are permitted in a
model, they are by definition sort-resolved. As-
suming the hierarchies in Tables 2 and 4, an ex-
ample category model is given in Figure 6, where
arcs by convention point downwards:
</bodyText>
<figure confidence="0.8331372">
/ : verbpl
✑✑✑
R �
�
S
</figure>
<figureCaption confidence="0.999827">
Figure 6: A category model
</figureCaption>
<bodyText confidence="0.999841583333334">
Given some inheritance hierarchy (B, EB, b) of
lexical types, not all category models whose nodes
are labelled with maximal types from B are ‘well-
typed’. In fact, this property is restricted to those
models where, if node n carries lexical type 0,
then every category description in the constraint
set of 0 is satisfied from n. Note that the root
of the model in Figure 6 carries the lexical type
‘verbpl’. Since all six constraints inherited by this
type in Figure 4 are satisfied from the root, and
since no other lexical types appear in the model,
we can state that the model is well-typed.
In sum, given an appropriate satisfaction rela-
tion between well-typed category models and I-
CCG category descriptions, along with a definition
of the CCG combinatory operations in terms of
category models, it is possible to provide a formal
interpretation of the language of I-CCG category
descriptions, in the same way as unification-based
formalisms like HPSG ground attribute-value no-
tation in terms of underlying totally well-typed,
sort-resolved feature structure models. Such a se-
mantics is necessary in order to prove the correct-
ness of eventual I-CCG implementations.
</bodyText>
<sectionHeader confidence="0.988416" genericHeader="method">
6 Extending the description language
</sectionHeader>
<bodyText confidence="0.996131368421053">
The I-CCG formalism described here involves a
generalisation of the CCG category notation to in-
corporate the concept of lexical inheritance. The
primary motivation for this concerns the ideal of
non-redundant encoding of lexical information in
human language grammars, so that all kinds of lin-
guistically significant generalisation can be cap-
tured somewhere in the grammar. In order to fulfil
this goal, the simple category description language
defined above will need to be extended somewhat.
For example, imagine that we want to specify the
This just leaves the simple descrip-
tions which consist of a type in the
lexical inheritance hierarchy (B, EB,
b). If we define the constraint set of some
lexical type 0 E B as the set Φ of all category
descriptions either associated with or inherited
by 0, ,t/hen the denotation of 0 is defined as
nψEΦ [[4&apos;]]
</bodyText>
<figure confidence="0.995221">
❅ A
❅
pl
N Psbj
◗ ◗ ◗
NPsg
obj
</figure>
<page confidence="0.981045">
6
</page>
<bodyText confidence="0.997847333333333">
set of all expressions which take an NPobj argu-
ment, but not necessarily as their first argument,
i.e. the set of all ‘transitive’ expressions:
</bodyText>
<equation confidence="0.87720475">
(7) ARG NPobj
U RES ARG NPobj
U RES RES ARG NPobj
U ...
</equation>
<bodyText confidence="0.999788384615385">
It should be clear that this category is not finitely
specifiable using the I-CCG category notation.
One way to allow such generalisations to be
made involves incorporating the ∗ modal itera-
tion operator used in Propositional Dynamic Logic
(Harel, 1984) to denote an unbounded number
of arc traversals in a Kripke structure. In other
words, category description (RES&amp;quot; 0) is satisfied
from node n in a model just in case some finite se-
quence of result arcs leads from n to a node where
0 is satisfied. In this way, the set of expressions
taking an NPobj argument is specified by means of
the category description RES&amp;quot; ARG NPobj.
</bodyText>
<sectionHeader confidence="0.990788" genericHeader="method">
7 Computational aspects
</sectionHeader>
<bodyText confidence="0.999959866666667">
At least as far as the I-CCG category notation de-
fined in section 4.1 is concerned, it is a straight-
forward task to take the standard CKY approach
to parsing with CCGs (Steedman, 2000), and gen-
eralise it to take a functional, atomic I-CCG lex-
icon and ‘cache out’ the inherited constraints on-
line. As long as the inheritance hierarchy is non-
recursive and can thus be theoretically cached out
into a finite lexicon, the parsing problem remains
worst-case polynomial.
In addition, the I-CCG formalism satisfies
the ‘strong competence’ requirement of Bresnan
(1982), according to which the grammar used by
or implicit in the human sentence processor is
the competence grammar itself. In other words,
although the result of cache-ing out particularly
common lexical entries will undoubtedly be part
of a statistically optimised parser, it is not essen-
tial to the tractability of the formalism.
One obvious practical problem for which the
work reported here provides at least the germ of
a solution involves the question of how to gener-
alise CCG lexicons which have been automatically
induced from treebanks (Hockenmaier, 2003). To
take a concrete example, Cakici (2005) induces a
wide coverage CCG lexicon from a 6000 sentence
dependency treebank of Turkish. Since Turkish is
apro-drop language, every transitive verb belongs
to both categories (S\NPsbj)\NPobj and S\NPobj.
However, data sparsity means that the automati-
cally induced lexicon assigns only a small minor-
ity of transitive verbs to both classes. One possi-
ble way of resolving this problem would involve
translating the automatically induced lexicon into
sets of fully specified I-CCG category descrip-
tions, generating an inheritance hierarchy of lex-
ical types from this lexicon (Sporleder, 2004), and
applying some more precise version of the follow-
ing heuristic: if a critical mass of words in the au-
tomatically induced lexicon belong to both CCG
categories X and Y , then in the derived I-CCG
lexicon assign all words belonging to either X or
Y to the lexical type which functions as the great-
est lower bound of X and Y in the lexical inheri-
tance hierarchy.
</bodyText>
<sectionHeader confidence="0.999007" genericHeader="conclusions">
8 Acknowledgements
</sectionHeader>
<bodyText confidence="0.97154825">
The author is indebted to the following people for
providing feedback on various drafts of this paper:
Mark Steedman, Cem Bozsahin, Jason Baldridge,
and three anonymous EACL reviewers.
</bodyText>
<sectionHeader confidence="0.996375" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.99985804">
Baldridge, J. (2002). Lexically Specified Deriva-
tional Control in Combinatory Categorial
Grammar. PhD thesis, University of Edinburgh.
Beavers, J. (2004). Type-inheritance Combina-
tory Categorial Grammar. In Proceedings of
the 20th International Conference on Compu-
tational Linguistics, University of Geneva.
Bozsahin, C. (2002). The combinatory morphemic
lexicon. Computational Linguistics, 28(2):145–
186.
Bresnan, J., editor (1982). The Mental Represen-
tation of Grammatical Relations. MIT Press,
Cambridge MA.
Cakici, R. (2005). Automatic induction of a CCG
grammar for Turkish. In Proceedings of the Stu-
dent Research Workshop, 43rd Annual Meeting
of the Association for Computational Linguis-
tics, University of Michigan, pages 73–78.
Carpenter, B. (1992). The Logic of Typed Fea-
ture Structures. Cambridge Tracts in Theoret-
ical Computer Science. Cambridge University
Press.
Copestake, A. (2002). Implementing Typed Fea-
ture Structure Grammars. CSLI Publications,
Stanford CA.
</reference>
<page confidence="0.990137">
7
</page>
<reference confidence="0.998010863636363">
Erkan, G. (2003). A Type System for Combina-
tory Categorial Grammar. Master’s thesis, Mid-
dle East Technical University, Ankara.
Flickinger, D. P. (1987). Lexical Rules in the Hi-
erarchical Lexicon. PhD thesis, Stanford Uni-
versity.
Harel, D. (1984). Dynamic logic. In Gabbay, D.
and Guenthner, F., editors, Handbook of Philo-
sophical Logic, Volume 2, pages 497–604. Rei-
del, Dordrecht.
Hockenmaier, J. (2003). Data and Models for
Statistical Parsing with Combinatory Catego-
rial Grammar. PhD thesis, University of Ed-
inburgh.
Hoffman, B. (1995). The Computational Analy-
sis of the Syntax and Interpretation of ”Free”
Word Order in Turkish. PhD thesis, University
of Pennsylvania.
Lambek, J. (1958). The Mathematics of Sentence
Structure. American Mathematical Monthly,
65:154–170.
Moortgat, M. (1997). Categorial type logics. In
van Benthem, J. and ter Meulen, A., editors,
Handbook of Logic and Language, pages 93–
177. North Holland, Amsterdam, NL.
Pollard, C. J. and Sag, I. A. (1994). Head-Driven
Phrase Structure Grammar. The University of
Chicago Press.
Sporleder, C. (2004). Discovering Lexical Gener-
alisations: A Supervised Machine Learning Ap-
proach to Inheritance Hierarchy Construction.
PhD thesis, University of Edinburgh.
Steedman, M. (2000). The Syntactic Process. MIT
Press, Cambridge MA.
Uszkoreit, H. (1986). Categorial Unification
Grammars. In Proceedings of the 11th Inter-
national Conference on Computational Linguis-
tics, Bonn, pages 187–194.
Zeevat, H., Klein, E., and Calder, J. (1987). Uni-
fication Categorial Grammar. In Haddock, N.,
Klein, E., and Morrill, G., editors, Categorial
Grammar, Unification Grammar and Parsing,
Working Papers in Cognitive Science. Centre
for Cognitive Science, University of Edinburgh.
</reference>
<page confidence="0.998526">
8
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.010561">
<title confidence="0.999798">Inheritance and the CCG Lexicon</title>
<author confidence="0.999975">Mark McConville</author>
<affiliation confidence="0.999338333333333">Institute for Communicating and Collaborative Systems School of Informatics University of Edinburgh</affiliation>
<address confidence="0.965774">2 Buccleuch Place, Edinburgh, EH8 9LW, Scotland</address>
<email confidence="0.995113">Mark.McConville@ed.ac.uk</email>
<abstract confidence="0.9931936875">I propose a uniform approach to the elimination of redundancy in CCG lexicons, where grammars incorporate inheritance hierarchies of lexical types, defined over a simple, feature-based category description language. The resulting formalism is partially ‘constraint-based’, in that the category notation is interpreted against an underlying set of tree-like feature structures. I argue that this version of CCG subsumes a number of other proposed category notations devised to allow for the construction of more efficient lexicons. The formalism retains desirable properties such as tractability and strong competence, and provides a way of approaching the problem of how to generalise CCG lexicons which have been automatically induced from treebanks. 1 The CCG formalism In its most basic conception, a CCG over alphaterminal symbols is an ordered triple S, where an alphabet of saturated catsymbols, a distinguished element of a lexicon, i.e. a mapping from cateover The set of categories over alphabet the closure of the binary infix conthe associated ‘modalities’ of Baldridge (2002). For example, assuming the satcategory symbols and here is a simple CCG lexicon (modalities omitted):</abstract>
<title confidence="0.565673">NP</title>
<author confidence="0.731249">Mary NP</author>
<abstract confidence="0.96973139944134">The combinatory projection of a CCG lexicon is its closure under a finite set of resource-sensitive combinatory operations such as forward application (2), backward application (3), forward type raising (4), and forward composition (5): X/Y Y Y X X/Y Y/Z S, alphabet string just in case in the combinatory of lexicon The derivation in Figure shows that CCG (1) generates the sentence assuming that is the distinguished and where instances of forward raising, forward composition and forward application respectively: John loves Mary NP &gt; Figure 1: A CCG derivation 2 Lexical redundancy in CCG CCG has many advantages both as a theory of human linguistic competence and as a tool for practical natural language processing applications (Steedman, 2000). However, in many cases development has been hindered by the absence of an agreed uniform approach to eliminating redundancy in CCG lexicons. This poses a particular problem for a radically lexicalised formalism such as CCG, where it is customary to handle bounded S 1 dependency constructions such as case, agreement and binding by means of multiple lexical category assignments. Take for example, the language schematised in Table 1. This fragment of English, though small, exemplifies certain non-trivial aspects of case and number agreement: John John he loves me the girl you girls him I us you love them we the girl they girls girls girls Table 1: A fragment of English simplest CCG lexicon for this fragment is presented in Table 2: sbj sbj Table 2: A CCG lexicon lexicon exhibits a number of multiple cateassignments: (a) the proper noun second person pronoun each assigned one for each case distinction; the plural suffix assigned to categories, depending on both the case and ‘bar level’ the resulting nominal; and (c) the definite artiassigned to one for each of case and number agreement distinctions. Since in each of these three cases there is no pretheoretical ambiguity involved, it is clear this lexicon violates the following efficiencymotivated ideal on human language lexicons, in the Chomskyan sense of locus of non-systematic information: of functionality a lexicon is ideally a funcmorphemes to category labels, modulo genuine ambiguity Another efficiency-motivated ideal which the CCG lexicon in Table 2 can be argued to violate is the following: ideal of atomicity a lexicon is a mapping from ideally to labels the above example, the transitive verb mapped to the decidedly non-atomic category la- Lexicons which violate the criteria of functionality and atomicity are not just inefficient in terms of storage space and development time. They also fail to capture linguistically significant generalisations about the behaviour of the relevant words or morphemes. The functionality and atomicity of a CCG lexicon can be easily quantified. The functionality raof the lexicon in Table 2, with entries morphemes, is The atomicity ratio is calculated by dividing the number of saturated category symbol-tokens by the number lexical entries, i.e. more or less hoc of the basic CCG category notation have been proposed with a view to eliminating these kinds of lexical redundancy. One area of interest has involved the nature of the saturated category symbols themselves. Bozsahin (2002) presents a version of CCG where saturated category symbols are modified by unary modalities annotated with morphosyntactic features. The features are themselves ordered according to a language-particular join semi-lattice. This technique, along with the insistence that lexicons of agglutinating languages necessarily allows generalisations involving the morphological structure of nouns and verbs in Turkish to be captured in an elegant, non-redundant format. Erkan (2003) generalises this approach, modelling saturated category labels as typed feature structures, constrained by underspecified feature structure descriptions in the usual manner. Hoffman (1995) resolves other violations of the ideal of functionality in CCG lexicons for languages with ‘local scrambling’ constructions by means of ‘multiset’ notation for unsaturated categories, where scope and direction of arguments can be underspecified. For example, a multiset label like to be unas incorporating both Computational implementations of the CCG formalism, including successive versions of the 2 have generally dealt with violations of the ideal of atomicity by allowing for the definition of macro-style abbreviations for unsaturated categories, e.g. using the macro as an abbreviation for One final point of note involves the project reported in Beavers (2004), who implements CCG within the LKB system, i.e. as an application of the Typed Feature Structure Grammar formalism of Copestake (2002), with the full apparatus of unrestricted typed feature structures, default inheritance hierarchies, and lexical rules. 3 Type-hierarchical CCG One of the aims of the project reported here has been to take a bottom-up approach to the problem of redundancy in CCG lexicons, adding just enough formal machinery to allow the relevant generalisations to be formulated, whilst retaining a restrictive theory of human linguistic competence which satisfies the ‘strong competence’ requirement, i.e. the competence grammar and the processing grammar are identical. I start with a generalisation of the CCG formalism where the alphabet of saturated category symbols is organised into a ‘type hierarchy’ in the sense of Carpenter (1992), i.e. a weak order where an alphabet of types, ‘subsumption’ ordering on a least eleand every subset of an upper bound has a least upper bound. An example type hierarchy is in Figure 2, where for example types and are compatible since they have a non-empty set of upper bounds, the least upper (or ‘unifier’) being top ✦✦✦✦ PPP � SNom ✏✏✏✏✏✏ �� �� ❅ ❅ �� � � �� ▲ ❍ ❍ �� � ❍❍ �� ☞☞ � ❍ � ▲ � � ❍ ✏✏✏✏✏✏ ◗ ✏✏✏✏✏✏ �� ◗ ◗ �� ◗ ◗ �� sg pl sg pl Figure 2: Type hierarchy of saturated categories A type-hierarchical CCG (T-CCG) over alphaan ordered 4-tuple S, where a type hierarchy of saturated category a distinguished element of and a mapping from categories over Given an appropriate relaon the categories over the combinatory of T-CCG S, L) again be as the closure of the CCG comoperations, assuming that variable the type raising rule (4) is restricted to maximally specified categories. The T-CCG lexicon in Table 3, in tandem with type hierarchy in Figure 2, generates the fragment of English in Table 1: sbj obj sbj Table 3: A T-CCG lexicon this lexicon, the sentence love John derived as in Figure 3: girl s love John &gt; Figure 3: A T-CCG derivation The T-CCG lexicon in Table 3 comes closer to satisfying the ideal of functionality than does the lexicon in Table 2. While the latter has a functionality of the former’s is This improved functionality ratio results from the underspecification of saturated category symbols inherent in the subsumption relation. For exwhereas the proper noun assigned to two distinct categories in the lexicon in Table 2, in the T-CCG lexicon it is assigned to a sinwhich subsumes the maximal types and In other S 3 words, the phenomenon of case syncretism in English proper nouns is captured by having a general singular noun phrase type, which subsumes a plurality of case distinctions. The T-CCG formalism is equivalent to the ‘morphosyntactic CCG’ formalism of Bozsahin (2002), where features are ordered in a join semi-lattice. Any generalisation which can be expressed in a morphosyntactic CCG can also be expressed in a T-CCG, since any lattice of morphosyntactic features can be converted into a type hierarchy. In addition, T-CCG is equivalent to the formalism described in Erkan (2003), where saturated categories are modelled as typed feature structures. Any lexicon from either of these formalisms can be translated into a T-CCG lexicon whose functionality ratio is either equivalent or lower. 4 Inheritance-driven CCG A second generalisation of the CCG formalism involves adding a second alphabet of non-terminals, in this case a set of ‘lexical types’. The lexical types are organised into an ‘inheritance hierarchy’, constrained by expressions of a simple featurebased category description language, inspired by previous attempts to integrate categorial grammars and unification-based grammars, e.g. Uszkoreit (1986) and Zeevat et al. (1987). 4.1 Simple category descriptions The set of simple category descriptions over alsaturated category symbols is defined the smallest set that: A for all for all for all Note that category descriptions may be infinitely embedded, in which case they are considered to right-associative, e.g. ARG RES SLASH simple category description like the set of all expressions which seek their argument to the right/left. A description the form the set of expressions take an argument of category and one the set of expressions which combine with an argument to yield an expression category Complex category descriptions are simply sets of simple category descriptions, where the assumed semantics is simply that of conjunction. 4.2 Lexical inheritance hierarchies Lexical inheritance hierarchies (Flickinger, 1987) are type hierarchies where each type is associated with a set of expressions drawn from some catedescription language Formally, they are triples where a hierarchy, and a function from An example lexical inheritance hierarchy over the set of category descriptions over the alphabet of saturated category symbols in Table 2 is presented in Figure 4. The intuition underlying these (monotonic) inheritance hierarchies is that instances of a type must satisfy all the constraints associated with that type, as well as all the constraints it inherits from its supertypes. top ✘✘✘✘✘ ❍ ❍ ❍ ❍ ❍ suffix SLASH b Figure 4: A lexical inheritance hierarchy example hierarchy is a hierarchy, since every lexical type has no more than immediate supertype. However, inheritance hierarchies are also allowed, where a given type can inherit constraints from two supertypes, neither of which subsumes the other. 4.3 I-CCGs An inheritance-driven CCG (I-CCG) over alphaan ordered 7-tuple B, b, where a type hierarchy of satcategory symbols, an inheritance hierarchy of lexical types over the set of catdescriptions over a distinguished in and lexicon a function from Given an appropriate on the categories over the combinaprojection of I-CCG B, b, S, again be defined as the closure of the verb SLASH f RES SLASH b ARG RES RES S det SLASH f ARG N RES NP � ✁✁ ❈❈ ARG ARG ❈ ❈ ✡ ❇ ❇ ❇ ARG 4 CCG combinatory operations. The I-CCG lexicon in Table 4, along with the type hierarchy of saturated category symbols in Figure 2 and the inheritance hierarchy of lexical types in Figure 4, generates the fragment of English in Table 1. Using this lexicon, the sentence sbj obj sbj obj Table 4: An I-CCG lexicon love John derived as in Figure 5, where derivational steps involve ‘cache-ing out’ sets of constraints from lexical types. girl s love John S SLASH f RES S ARG ARG SLASH b S SLASHf &gt; Figure 5: An I-CCG derivation This derivation relies on a version of the CCG combinatory rules defined in terms of the I-CCG category description language. For example, forward application is expressed as follows — for all category descriptions that and ∪ compatible, the following is a valid inference: Φ Ψ functionality ratio of the I-CCG lexicon in Ta- 4 is 1 the atomicity ratio is In other words, the lexicon is maximally nonredundant, since all the linguistically significant generalisations are encodable within the lexical inheritance hierarchy.</abstract>
<intro confidence="0.845621">The optimal atomicity ratio of the I-CCG lexi-</intro>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>J Baldridge</author>
</authors>
<title>Lexically Specified Derivational Control in Combinatory Categorial Grammar.</title>
<date>2002</date>
<tech>PhD thesis,</tech>
<institution>University of Edinburgh.</institution>
<contexts>
<context position="1411" citStr="Baldridge (2002)" startWordPosition="226" endWordPosition="227">operties such as tractability and strong competence, and provides a way of approaching the problem of how to generalise CCG lexicons which have been automatically induced from treebanks. 1 The CCG formalism In its most basic conception, a CCG over alphabet E of terminal symbols is an ordered triple (A, S, L), where A is an alphabet of saturated category symbols, S is a distinguished element of A, and L is a lexicon, i.e. a mapping from E to categories over A. The set of categories over alphabet A is the closure of A under the binary infix connectives / and \ and the associated ‘modalities’ of Baldridge (2002). For example, assuming the saturated category symbols ‘S’ and ‘NP’, here is a simple CCG lexicon (modalities omitted): (1) John NP Mary NP loves (S\NP)/NP The combinatory projection of a CCG lexicon is its closure under a finite set of resource-sensitive combinatory operations such as forward application (2), backward application (3), forward type raising (4), and forward composition (5): (2) X/Y Y ==&gt;. X (3) Y X\Y ==&gt;. X (4) X ==&gt;. Y/(Y \X) (5) X/Y Y/Z ==&gt;. X/Z CCG (A, S, L) over alphabet E generates string s E E∗ just in case (s, S) is in the combinatory projection of lexicon L. The derivat</context>
<context position="19189" citStr="Baldridge (2002)" startWordPosition="3271" endWordPosition="3272">[SLASH b]] = Uφ,ψEΦ[[0\ψ]] • [[ARG 0]] = UψEΦ[[ψ/0]] U [[ψ\0]] • [[RES 0]] = UψEΦ[[0/ψ]] U [[0\ψ]] . Unfortunately, this approach to interpreting ICCG category descriptions is insufficient, since the logic underlying CCG is not simply the logic of string concatenation, i.e. CCG allows a limited degree of permutation by dint of the crossed composition and substitution operations. In fact, there appears to be no categorial type logic, in the sense of Moortgat (1997), for which the CCG combinatory operations provide a sound and complete derivation system, even in the resource-sensitive system of Baldridge (2002). An alternative approach involves interpreting I-CCG category descriptions against totally well-typed, sort-resolved feature structures, as in the HPSG formalism of Pollard and Sag (1994). Given some type hierarchy (A, EA) of saturated category symbols and some lexical inheritance hierarchy (B, EB, b), we define a class of ‘category models’, i.e. binary trees where every leaf node carries a maximal saturated category symbol in A, every non-leaf node carries a directional slash, and every branch is labelled as either a ‘result’ or an ‘argument’. In addition, nodes are optionally labelled with </context>
</contexts>
<marker>Baldridge, 2002</marker>
<rawString>Baldridge, J. (2002). Lexically Specified Derivational Control in Combinatory Categorial Grammar. PhD thesis, University of Edinburgh.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Beavers</author>
</authors>
<title>Type-inheritance Combinatory Categorial Grammar.</title>
<date>2004</date>
<booktitle>In Proceedings of the 20th International Conference on Computational Linguistics,</booktitle>
<institution>University of Geneva.</institution>
<contexts>
<context position="7054" citStr="Beavers (2004)" startWordPosition="1141" endWordPosition="1142">tegories, where scope and direction of arguments can be underspecified. For example, a multiset category label like S{\NPsbj, \NPobj} is to be understood as incorporating both (S\NPsbj)\NPobj and (S\NPobj)\NPsbj. Computational implementations of the CCG formalism, including successive versions of the 2 Grok/OpenCCG system1, have generally dealt with violations of the ideal of atomicity by allowing for the definition of macro-style abbreviations for unsaturated categories, e.g. using the macro ‘TV’ as an abbreviation for (S\NPsbj)/NPobj. One final point of note involves the project reported in Beavers (2004), who implements CCG within the LKB system, i.e. as an application of the Typed Feature Structure Grammar formalism of Copestake (2002), with the full apparatus of unrestricted typed feature structures, default inheritance hierarchies, and lexical rules. 3 Type-hierarchical CCG One of the aims of the project reported here has been to take a bottom-up approach to the problem of redundancy in CCG lexicons, adding just enough formal machinery to allow the relevant generalisations to be formulated, whilst retaining a restrictive theory of human linguistic competence which satisfies the ‘strong com</context>
</contexts>
<marker>Beavers, 2004</marker>
<rawString>Beavers, J. (2004). Type-inheritance Combinatory Categorial Grammar. In Proceedings of the 20th International Conference on Computational Linguistics, University of Geneva.</rawString>
</citation>
<citation valid="true">
<authors>
<author>C Bozsahin</author>
</authors>
<title>The combinatory morphemic lexicon.</title>
<date>2002</date>
<journal>Computational Linguistics,</journal>
<volume>28</volume>
<issue>2</issue>
<pages>186</pages>
<contexts>
<context position="5587" citStr="Bozsahin (2002)" startWordPosition="935" endWordPosition="936">orphemes. The functionality and atomicity of a CCG lexicon can be easily quantified. The functionality ratio of the lexicon in Table 2, with 22 lexical entries for 14 distinct morphemes, is 22 14 = 1.6. The atomicity ratio is calculated by dividing the number of saturated category symbol-tokens by the number of lexical entries, i.e. 36 22 = 1.6. Various, more or less ad hoc generalisations of the basic CCG category notation have been proposed with a view to eliminating these kinds of lexical redundancy. One area of interest has involved the nature of the saturated category symbols themselves. Bozsahin (2002) presents a version of CCG where saturated category symbols are modified by unary modalities annotated with morphosyntactic features. The features are themselves ordered according to a language-particular join semi-lattice. This technique, along with the insistence that lexicons of agglutinating languages are necessarily morphemic, allows generalisations involving the morphological structure of nouns and verbs in Turkish to be captured in an elegant, non-redundant format. Erkan (2003) generalises this approach, modelling saturated category labels as typed feature structures, constrained by und</context>
<context position="10567" citStr="Bozsahin (2002)" startWordPosition="1771" endWordPosition="1772">rom the underspecification of saturated category symbols inherent in the subsumption relation. For example, whereas the proper noun John is assigned to two distinct categories in the lexicon in Table 2, in the T-CCG lexicon it is assigned to a single non-maximal type ‘NPsg’ which subsumes the two maximal types ‘NPsg sbj’ and ‘NPsgobj’. In other S 3 words, the phenomenon of case syncretism in English proper nouns is captured by having a general singular noun phrase type, which subsumes a plurality of case distinctions. The T-CCG formalism is equivalent to the ‘morphosyntactic CCG’ formalism of Bozsahin (2002), where features are ordered in a join semi-lattice. Any generalisation which can be expressed in a morphosyntactic CCG can also be expressed in a T-CCG, since any lattice of morphosyntactic features can be converted into a type hierarchy. In addition, T-CCG is equivalent to the formalism described in Erkan (2003), where saturated categories are modelled as typed feature structures. Any lexicon from either of these formalisms can be translated into a T-CCG lexicon whose functionality ratio is either equivalent or lower. 4 Inheritance-driven CCG A second generalisation of the CCG formalism invo</context>
</contexts>
<marker>Bozsahin, 2002</marker>
<rawString>Bozsahin, C. (2002). The combinatory morphemic lexicon. Computational Linguistics, 28(2):145– 186.</rawString>
</citation>
<citation valid="true">
<title>The Mental Representation of Grammatical Relations.</title>
<date>1982</date>
<editor>Bresnan, J., editor</editor>
<publisher>MIT Press,</publisher>
<location>Cambridge MA.</location>
<contexts>
<context position="23607" citStr="(1982)" startWordPosition="4019" endWordPosition="4019">tion RES&amp;quot; ARG NPobj. 7 Computational aspects At least as far as the I-CCG category notation defined in section 4.1 is concerned, it is a straightforward task to take the standard CKY approach to parsing with CCGs (Steedman, 2000), and generalise it to take a functional, atomic I-CCG lexicon and ‘cache out’ the inherited constraints online. As long as the inheritance hierarchy is nonrecursive and can thus be theoretically cached out into a finite lexicon, the parsing problem remains worst-case polynomial. In addition, the I-CCG formalism satisfies the ‘strong competence’ requirement of Bresnan (1982), according to which the grammar used by or implicit in the human sentence processor is the competence grammar itself. In other words, although the result of cache-ing out particularly common lexical entries will undoubtedly be part of a statistically optimised parser, it is not essential to the tractability of the formalism. One obvious practical problem for which the work reported here provides at least the germ of a solution involves the question of how to generalise CCG lexicons which have been automatically induced from treebanks (Hockenmaier, 2003). To take a concrete example, Cakici (20</context>
</contexts>
<marker>1982</marker>
<rawString>Bresnan, J., editor (1982). The Mental Representation of Grammatical Relations. MIT Press, Cambridge MA.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Cakici</author>
</authors>
<title>Automatic induction of a CCG grammar for Turkish.</title>
<date>2005</date>
<booktitle>In Proceedings of the Student Research Workshop, 43rd Annual Meeting of the Association</booktitle>
<pages>73--78</pages>
<institution>for Computational Linguistics, University of Michigan,</institution>
<contexts>
<context position="24210" citStr="Cakici (2005)" startWordPosition="4114" endWordPosition="4115">nan (1982), according to which the grammar used by or implicit in the human sentence processor is the competence grammar itself. In other words, although the result of cache-ing out particularly common lexical entries will undoubtedly be part of a statistically optimised parser, it is not essential to the tractability of the formalism. One obvious practical problem for which the work reported here provides at least the germ of a solution involves the question of how to generalise CCG lexicons which have been automatically induced from treebanks (Hockenmaier, 2003). To take a concrete example, Cakici (2005) induces a wide coverage CCG lexicon from a 6000 sentence dependency treebank of Turkish. Since Turkish is apro-drop language, every transitive verb belongs to both categories (S\NPsbj)\NPobj and S\NPobj. However, data sparsity means that the automatically induced lexicon assigns only a small minority of transitive verbs to both classes. One possible way of resolving this problem would involve translating the automatically induced lexicon into sets of fully specified I-CCG category descriptions, generating an inheritance hierarchy of lexical types from this lexicon (Sporleder, 2004), and apply</context>
</contexts>
<marker>Cakici, 2005</marker>
<rawString>Cakici, R. (2005). Automatic induction of a CCG grammar for Turkish. In Proceedings of the Student Research Workshop, 43rd Annual Meeting of the Association for Computational Linguistics, University of Michigan, pages 73–78.</rawString>
</citation>
<citation valid="true">
<authors>
<author>B Carpenter</author>
</authors>
<title>The Logic of Typed Feature Structures. Cambridge Tracts in Theoretical Computer Science.</title>
<date>1992</date>
<publisher>Cambridge University Press.</publisher>
<contexts>
<context position="7915" citStr="Carpenter (1992)" startWordPosition="1276" endWordPosition="1277">al rules. 3 Type-hierarchical CCG One of the aims of the project reported here has been to take a bottom-up approach to the problem of redundancy in CCG lexicons, adding just enough formal machinery to allow the relevant generalisations to be formulated, whilst retaining a restrictive theory of human linguistic competence which satisfies the ‘strong competence’ requirement, i.e. the competence grammar and the processing grammar are identical. I start with a generalisation of the CCG formalism where the alphabet of saturated category symbols is organised into a ‘type hierarchy’ in the sense of Carpenter (1992), i.e. a weak order (A, CA), where A is an alphabet of types, CA is the ‘subsumption’ ordering on A (with a least element), and every subset of A with an upper bound has a least upper bound. An example type hierarchy is in Figure 2, where for example types ‘Nomsg’ and ‘NP’ are compatible since they have a non-empty set of upper bounds, the least upper bound (or ‘unifier’) being ‘NPsg’. top ✦✦✦✦ PPP � SNom ✏✏✏✏✏✏ �� �� ❅ ❅ �� � � NP Nomsg Nompl N �� ★★ ▲ ❍ ❍❍ ❍ �� � ❍❍ ☎☎ �� PPP ☞☞ � ❍ � ▲ � � ❍ NPsbj NPobj NPsg NPpl Nsg Npl ◗ ✏✏✏✏✏✏ ◗ ✏✏✏✏✏✏ �� ◗ ◗ �� ◗ ◗ �� sg pl sg pl NPsbj NPsbj NPobj NPobj</context>
</contexts>
<marker>Carpenter, 1992</marker>
<rawString>Carpenter, B. (1992). The Logic of Typed Feature Structures. Cambridge Tracts in Theoretical Computer Science. Cambridge University Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Copestake</author>
</authors>
<title>Implementing Typed Feature Structure Grammars.</title>
<date>2002</date>
<publisher>CSLI Publications,</publisher>
<location>Stanford CA.</location>
<contexts>
<context position="7189" citStr="Copestake (2002)" startWordPosition="1162" endWordPosition="1163"> is to be understood as incorporating both (S\NPsbj)\NPobj and (S\NPobj)\NPsbj. Computational implementations of the CCG formalism, including successive versions of the 2 Grok/OpenCCG system1, have generally dealt with violations of the ideal of atomicity by allowing for the definition of macro-style abbreviations for unsaturated categories, e.g. using the macro ‘TV’ as an abbreviation for (S\NPsbj)/NPobj. One final point of note involves the project reported in Beavers (2004), who implements CCG within the LKB system, i.e. as an application of the Typed Feature Structure Grammar formalism of Copestake (2002), with the full apparatus of unrestricted typed feature structures, default inheritance hierarchies, and lexical rules. 3 Type-hierarchical CCG One of the aims of the project reported here has been to take a bottom-up approach to the problem of redundancy in CCG lexicons, adding just enough formal machinery to allow the relevant generalisations to be formulated, whilst retaining a restrictive theory of human linguistic competence which satisfies the ‘strong competence’ requirement, i.e. the competence grammar and the processing grammar are identical. I start with a generalisation of the CCG fo</context>
</contexts>
<marker>Copestake, 2002</marker>
<rawString>Copestake, A. (2002). Implementing Typed Feature Structure Grammars. CSLI Publications, Stanford CA.</rawString>
</citation>
<citation valid="true">
<authors>
<author>G Erkan</author>
</authors>
<title>A Type System for Combinatory Categorial Grammar. Master’s thesis,</title>
<date>2003</date>
<institution>Middle East Technical University,</institution>
<location>Ankara.</location>
<contexts>
<context position="6076" citStr="Erkan (2003)" startWordPosition="1002" endWordPosition="1003">ical redundancy. One area of interest has involved the nature of the saturated category symbols themselves. Bozsahin (2002) presents a version of CCG where saturated category symbols are modified by unary modalities annotated with morphosyntactic features. The features are themselves ordered according to a language-particular join semi-lattice. This technique, along with the insistence that lexicons of agglutinating languages are necessarily morphemic, allows generalisations involving the morphological structure of nouns and verbs in Turkish to be captured in an elegant, non-redundant format. Erkan (2003) generalises this approach, modelling saturated category labels as typed feature structures, constrained by underspecified feature structure descriptions in the usual manner. Hoffman (1995) resolves other violations of the ideal of functionality in CCG lexicons for languages with ‘local scrambling’ constructions by means of ‘multiset’ notation for unsaturated categories, where scope and direction of arguments can be underspecified. For example, a multiset category label like S{\NPsbj, \NPobj} is to be understood as incorporating both (S\NPsbj)\NPobj and (S\NPobj)\NPsbj. Computational implement</context>
<context position="10882" citStr="Erkan (2003)" startWordPosition="1822" endWordPosition="1823">sbj’ and ‘NPsgobj’. In other S 3 words, the phenomenon of case syncretism in English proper nouns is captured by having a general singular noun phrase type, which subsumes a plurality of case distinctions. The T-CCG formalism is equivalent to the ‘morphosyntactic CCG’ formalism of Bozsahin (2002), where features are ordered in a join semi-lattice. Any generalisation which can be expressed in a morphosyntactic CCG can also be expressed in a T-CCG, since any lattice of morphosyntactic features can be converted into a type hierarchy. In addition, T-CCG is equivalent to the formalism described in Erkan (2003), where saturated categories are modelled as typed feature structures. Any lexicon from either of these formalisms can be translated into a T-CCG lexicon whose functionality ratio is either equivalent or lower. 4 Inheritance-driven CCG A second generalisation of the CCG formalism involves adding a second alphabet of non-terminals, in this case a set of ‘lexical types’. The lexical types are organised into an ‘inheritance hierarchy’, constrained by expressions of a simple featurebased category description language, inspired by previous attempts to integrate categorial grammars and unification-b</context>
</contexts>
<marker>Erkan, 2003</marker>
<rawString>Erkan, G. (2003). A Type System for Combinatory Categorial Grammar. Master’s thesis, Middle East Technical University, Ankara.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D P Flickinger</author>
</authors>
<title>Lexical Rules in the Hierarchical Lexicon. PhD thesis,</title>
<date>1987</date>
<institution>Stanford University.</institution>
<contexts>
<context position="12545" citStr="Flickinger, 1987" startWordPosition="2098" endWordPosition="2099">ive, e.g. RES ARG RES SLASH f. A simple category description like (SLASH f) or (SLASH b) denotes the set of all expressions which seek their argument to the right/left. A description of the form (ARG 0) denotes the set of expressions which take an argument of category 0, and one like (RES 0) denotes the set of expressions which combine with an argument to yield an expression of category 0. Complex category descriptions are simply sets of simple category descriptions, where the assumed semantics is simply that of conjunction. 4.2 Lexical inheritance hierarchies Lexical inheritance hierarchies (Flickinger, 1987) are type hierarchies where each type is associated with a set of expressions drawn from some category description language Φ. Formally, they are ordered triples (B, EB, b), where (B, EB) is a type hierarchy, and b is a function from B to ℘(Φ). An example lexical inheritance hierarchy over the set of category descriptions over the alphabet of saturated category symbols in Table 2 is presented in Figure 4. The intuition underlying these (monotonic) inheritance hierarchies is that instances of a type must satisfy all the constraints associated with that type, as well as all the constraints it in</context>
</contexts>
<marker>Flickinger, 1987</marker>
<rawString>Flickinger, D. P. (1987). Lexical Rules in the Hierarchical Lexicon. PhD thesis, Stanford University.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D Harel</author>
</authors>
<title>Dynamic logic.</title>
<date>1984</date>
<booktitle>Handbook of Philosophical Logic,</booktitle>
<volume>2</volume>
<pages>497--604</pages>
<editor>In Gabbay, D. and Guenthner, F., editors,</editor>
<location>Reidel, Dordrecht.</location>
<contexts>
<context position="22647" citStr="Harel, 1984" startWordPosition="3853" endWordPosition="3854">Φ of all category descriptions either associated with or inherited by 0, ,t/hen the denotation of 0 is defined as nψEΦ [[4&apos;]] ❅ A ❅ pl N Psbj ◗ ◗ ◗ NPsg obj 6 set of all expressions which take an NPobj argument, but not necessarily as their first argument, i.e. the set of all ‘transitive’ expressions: (7) ARG NPobj U RES ARG NPobj U RES RES ARG NPobj U ... It should be clear that this category is not finitely specifiable using the I-CCG category notation. One way to allow such generalisations to be made involves incorporating the ∗ modal iteration operator used in Propositional Dynamic Logic (Harel, 1984) to denote an unbounded number of arc traversals in a Kripke structure. In other words, category description (RES&amp;quot; 0) is satisfied from node n in a model just in case some finite sequence of result arcs leads from n to a node where 0 is satisfied. In this way, the set of expressions taking an NPobj argument is specified by means of the category description RES&amp;quot; ARG NPobj. 7 Computational aspects At least as far as the I-CCG category notation defined in section 4.1 is concerned, it is a straightforward task to take the standard CKY approach to parsing with CCGs (Steedman, 2000), and generalise </context>
</contexts>
<marker>Harel, 1984</marker>
<rawString>Harel, D. (1984). Dynamic logic. In Gabbay, D. and Guenthner, F., editors, Handbook of Philosophical Logic, Volume 2, pages 497–604. Reidel, Dordrecht.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Hockenmaier</author>
</authors>
<title>Data and Models for Statistical Parsing with Combinatory Categorial Grammar.</title>
<date>2003</date>
<tech>PhD thesis,</tech>
<institution>University of Edinburgh.</institution>
<contexts>
<context position="24167" citStr="Hockenmaier, 2003" startWordPosition="4107" endWordPosition="4108">fies the ‘strong competence’ requirement of Bresnan (1982), according to which the grammar used by or implicit in the human sentence processor is the competence grammar itself. In other words, although the result of cache-ing out particularly common lexical entries will undoubtedly be part of a statistically optimised parser, it is not essential to the tractability of the formalism. One obvious practical problem for which the work reported here provides at least the germ of a solution involves the question of how to generalise CCG lexicons which have been automatically induced from treebanks (Hockenmaier, 2003). To take a concrete example, Cakici (2005) induces a wide coverage CCG lexicon from a 6000 sentence dependency treebank of Turkish. Since Turkish is apro-drop language, every transitive verb belongs to both categories (S\NPsbj)\NPobj and S\NPobj. However, data sparsity means that the automatically induced lexicon assigns only a small minority of transitive verbs to both classes. One possible way of resolving this problem would involve translating the automatically induced lexicon into sets of fully specified I-CCG category descriptions, generating an inheritance hierarchy of lexical types fro</context>
</contexts>
<marker>Hockenmaier, 2003</marker>
<rawString>Hockenmaier, J. (2003). Data and Models for Statistical Parsing with Combinatory Categorial Grammar. PhD thesis, University of Edinburgh.</rawString>
</citation>
<citation valid="true">
<authors>
<author>B Hoffman</author>
</authors>
<title>The Computational Analysis of the Syntax and Interpretation of ”Free” Word Order in Turkish.</title>
<date>1995</date>
<tech>PhD thesis,</tech>
<institution>University of Pennsylvania.</institution>
<contexts>
<context position="6265" citStr="Hoffman (1995)" startWordPosition="1026" endWordPosition="1027">modified by unary modalities annotated with morphosyntactic features. The features are themselves ordered according to a language-particular join semi-lattice. This technique, along with the insistence that lexicons of agglutinating languages are necessarily morphemic, allows generalisations involving the morphological structure of nouns and verbs in Turkish to be captured in an elegant, non-redundant format. Erkan (2003) generalises this approach, modelling saturated category labels as typed feature structures, constrained by underspecified feature structure descriptions in the usual manner. Hoffman (1995) resolves other violations of the ideal of functionality in CCG lexicons for languages with ‘local scrambling’ constructions by means of ‘multiset’ notation for unsaturated categories, where scope and direction of arguments can be underspecified. For example, a multiset category label like S{\NPsbj, \NPobj} is to be understood as incorporating both (S\NPsbj)\NPobj and (S\NPobj)\NPsbj. Computational implementations of the CCG formalism, including successive versions of the 2 Grok/OpenCCG system1, have generally dealt with violations of the ideal of atomicity by allowing for the definition of ma</context>
<context position="16709" citStr="Hoffman (1995)" startWordPosition="2854" endWordPosition="2855">with this atomic label that the verb is paired in the I-CCG lexicon in Table 4. The lexical inheritance hierarchy also has a role to play in constructing lexicons with optimal functionality ratios. The T-CCG lexicon in Table 3 assigned the definite article to two distinct categories, one for each grammatical number distinction. The I-CCG utilises the disjunction inherent in inheritance hierarchies to give each of these a common supertype ‘det’, which is associated with the properties all determiners share. Finally, the I-CCG formalism can be argued to subsume the multiset category notation of Hoffman (1995), in the sense that every multiset CCG lexicon can be converted into an ICCG lexicon with an equivalent or better functionality ratio. Recall that Hoffman uses generalised category notation like S{\NPsbj, \NPobj} to subsume two standard CCG category labels (S\NPsbj)\NPobj and (S\NPobj)\NPsbj. Again it should be clear that this is just another way of representing disjunction in a categorial lexicon, and can be straightforwardly converted into a lexical inheritance hierarchy over I-CCG category descriptions. 5 Semantics of the category notation In the categorial grammar tradition initiated by La</context>
</contexts>
<marker>Hoffman, 1995</marker>
<rawString>Hoffman, B. (1995). The Computational Analysis of the Syntax and Interpretation of ”Free” Word Order in Turkish. PhD thesis, University of Pennsylvania.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Lambek</author>
</authors>
<title>The Mathematics of Sentence Structure.</title>
<date>1958</date>
<pages>65--154</pages>
<publisher>American Mathematical Monthly,</publisher>
<contexts>
<context position="17320" citStr="Lambek (1958)" startWordPosition="2949" endWordPosition="2950">5), in the sense that every multiset CCG lexicon can be converted into an ICCG lexicon with an equivalent or better functionality ratio. Recall that Hoffman uses generalised category notation like S{\NPsbj, \NPobj} to subsume two standard CCG category labels (S\NPsbj)\NPobj and (S\NPobj)\NPsbj. Again it should be clear that this is just another way of representing disjunction in a categorial lexicon, and can be straightforwardly converted into a lexical inheritance hierarchy over I-CCG category descriptions. 5 Semantics of the category notation In the categorial grammar tradition initiated by Lambek (1958), the standard way of providing a semantics for category notation defines the denotation of a category description as a set of strings of terminal symbols. Thus, assuming an alphabet E and a denotation function [[...]] from the saturated category symbols to p(E), the denotata of unsaturated category descriptions can be defined as follows, assuming that the underlying logic is simply that of string concatenation: (6) [[0/ψ]] = {s |∀s&apos; ∈ [[ψ]], ss&apos; ∈ [[0]]} [[0\ψ]] = {s |∀s&apos; ∈ [[ψ]], s&apos;s ∈ [[0]]} This suggests an obvious way of interpreting the I-CCG category notation defined above. Let’s SLASH </context>
</contexts>
<marker>Lambek, 1958</marker>
<rawString>Lambek, J. (1958). The Mathematics of Sentence Structure. American Mathematical Monthly, 65:154–170.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Moortgat</author>
</authors>
<title>Categorial type logics. In</title>
<date>1997</date>
<booktitle>Handbook of Logic and Language,</booktitle>
<pages>93--177</pages>
<editor>van Benthem, J. and ter Meulen, A., editors,</editor>
<publisher>North</publisher>
<location>Holland, Amsterdam, NL.</location>
<contexts>
<context position="19041" citStr="Moortgat (1997)" startWordPosition="3249" endWordPosition="3250"> category descriptions can be defined by universal quantification over the set of simple category descriptions Φ: • [[SLASH f]] = Uφ,ψEΦ[[0/ψ]] • [[SLASH b]] = Uφ,ψEΦ[[0\ψ]] • [[ARG 0]] = UψEΦ[[ψ/0]] U [[ψ\0]] • [[RES 0]] = UψEΦ[[0/ψ]] U [[0\ψ]] . Unfortunately, this approach to interpreting ICCG category descriptions is insufficient, since the logic underlying CCG is not simply the logic of string concatenation, i.e. CCG allows a limited degree of permutation by dint of the crossed composition and substitution operations. In fact, there appears to be no categorial type logic, in the sense of Moortgat (1997), for which the CCG combinatory operations provide a sound and complete derivation system, even in the resource-sensitive system of Baldridge (2002). An alternative approach involves interpreting I-CCG category descriptions against totally well-typed, sort-resolved feature structures, as in the HPSG formalism of Pollard and Sag (1994). Given some type hierarchy (A, EA) of saturated category symbols and some lexical inheritance hierarchy (B, EB, b), we define a class of ‘category models’, i.e. binary trees where every leaf node carries a maximal saturated category symbol in A, every non-leaf no</context>
</contexts>
<marker>Moortgat, 1997</marker>
<rawString>Moortgat, M. (1997). Categorial type logics. In van Benthem, J. and ter Meulen, A., editors, Handbook of Logic and Language, pages 93– 177. North Holland, Amsterdam, NL.</rawString>
</citation>
<citation valid="true">
<authors>
<author>C J Pollard</author>
<author>I A Sag</author>
</authors>
<title>Head-Driven Phrase Structure Grammar.</title>
<date>1994</date>
<publisher>The University of Chicago Press.</publisher>
<contexts>
<context position="19377" citStr="Pollard and Sag (1994)" startWordPosition="3295" endWordPosition="3298">icient, since the logic underlying CCG is not simply the logic of string concatenation, i.e. CCG allows a limited degree of permutation by dint of the crossed composition and substitution operations. In fact, there appears to be no categorial type logic, in the sense of Moortgat (1997), for which the CCG combinatory operations provide a sound and complete derivation system, even in the resource-sensitive system of Baldridge (2002). An alternative approach involves interpreting I-CCG category descriptions against totally well-typed, sort-resolved feature structures, as in the HPSG formalism of Pollard and Sag (1994). Given some type hierarchy (A, EA) of saturated category symbols and some lexical inheritance hierarchy (B, EB, b), we define a class of ‘category models’, i.e. binary trees where every leaf node carries a maximal saturated category symbol in A, every non-leaf node carries a directional slash, and every branch is labelled as either a ‘result’ or an ‘argument’. In addition, nodes are optionally labelled with maximal lexical types from B. Note that since only maximal types are permitted in a model, they are by definition sort-resolved. Assuming the hierarchies in Tables 2 and 4, an example cate</context>
</contexts>
<marker>Pollard, Sag, 1994</marker>
<rawString>Pollard, C. J. and Sag, I. A. (1994). Head-Driven Phrase Structure Grammar. The University of Chicago Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>C Sporleder</author>
</authors>
<title>Discovering Lexical Generalisations: A Supervised Machine Learning Approach to Inheritance Hierarchy Construction.</title>
<date>2004</date>
<tech>PhD thesis,</tech>
<institution>University of Edinburgh.</institution>
<marker>Sporleder, 2004</marker>
<rawString>Sporleder, C. (2004). Discovering Lexical Generalisations: A Supervised Machine Learning Approach to Inheritance Hierarchy Construction. PhD thesis, University of Edinburgh.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Steedman</author>
</authors>
<title>The Syntactic Process.</title>
<date>2000</date>
<publisher>MIT Press,</publisher>
<location>Cambridge MA.</location>
<contexts>
<context position="2516" citStr="Steedman, 2000" startWordPosition="418" endWordPosition="419">habet E generates string s E E∗ just in case (s, S) is in the combinatory projection of lexicon L. The derivation in Figure 1 shows that CCG (1) generates the sentence John loves Mary, assuming that ‘S’ is the distinguished symbol, and where &gt; T, &gt; B and &gt; denote instances of forward raising, forward composition and forward application respectively: John loves Mary NP (S\NP)/NP NP &gt;T S/(S\NP) S/NP &gt; Figure 1: A CCG derivation 2 Lexical redundancy in CCG CCG has many advantages both as a theory of human linguistic competence and as a tool for practical natural language processing applications (Steedman, 2000). However, in many cases development has been hindered by the absence of an agreed uniform approach to eliminating redundancy in CCG lexicons. This poses a particular problem for a radically lexicalised formalism such as CCG, where it is customary to handle bounded &gt;B S 1 dependency constructions such as case, agreement and binding by means of multiple lexical category assignments. Take for example, the language schematised in Table 1. This fragment of English, though small, exemplifies certain non-trivial aspects of case and number agreement: John John he loves me the girl you girls him I us </context>
<context position="23230" citStr="Steedman, 2000" startWordPosition="3959" endWordPosition="3960">onal Dynamic Logic (Harel, 1984) to denote an unbounded number of arc traversals in a Kripke structure. In other words, category description (RES&amp;quot; 0) is satisfied from node n in a model just in case some finite sequence of result arcs leads from n to a node where 0 is satisfied. In this way, the set of expressions taking an NPobj argument is specified by means of the category description RES&amp;quot; ARG NPobj. 7 Computational aspects At least as far as the I-CCG category notation defined in section 4.1 is concerned, it is a straightforward task to take the standard CKY approach to parsing with CCGs (Steedman, 2000), and generalise it to take a functional, atomic I-CCG lexicon and ‘cache out’ the inherited constraints online. As long as the inheritance hierarchy is nonrecursive and can thus be theoretically cached out into a finite lexicon, the parsing problem remains worst-case polynomial. In addition, the I-CCG formalism satisfies the ‘strong competence’ requirement of Bresnan (1982), according to which the grammar used by or implicit in the human sentence processor is the competence grammar itself. In other words, although the result of cache-ing out particularly common lexical entries will undoubtedl</context>
</contexts>
<marker>Steedman, 2000</marker>
<rawString>Steedman, M. (2000). The Syntactic Process. MIT Press, Cambridge MA.</rawString>
</citation>
<citation valid="true">
<authors>
<author>H Uszkoreit</author>
</authors>
<title>Categorial Unification Grammars.</title>
<date>1986</date>
<booktitle>In Proceedings of the 11th International Conference on Computational Linguistics,</booktitle>
<pages>187--194</pages>
<location>Bonn,</location>
<contexts>
<context position="11518" citStr="Uszkoreit (1986)" startWordPosition="1915" endWordPosition="1916">tegories are modelled as typed feature structures. Any lexicon from either of these formalisms can be translated into a T-CCG lexicon whose functionality ratio is either equivalent or lower. 4 Inheritance-driven CCG A second generalisation of the CCG formalism involves adding a second alphabet of non-terminals, in this case a set of ‘lexical types’. The lexical types are organised into an ‘inheritance hierarchy’, constrained by expressions of a simple featurebased category description language, inspired by previous attempts to integrate categorial grammars and unification-based grammars, e.g. Uszkoreit (1986) and Zeevat et al. (1987). 4.1 Simple category descriptions The set of simple category descriptions over alphabet A of saturated category symbols is defined as the smallest set Φ such that: 1. A C Φ 2. for all 6 E If, b}, (SLASH 6) E Φ 3. for all 0 E Φ, (ARG 0) E Φ 4. for all 0 E Φ, (RES 0) E Φ Note that category descriptions may be infinitely embedded, in which case they are considered to be right-associative, e.g. RES ARG RES SLASH f. A simple category description like (SLASH f) or (SLASH b) denotes the set of all expressions which seek their argument to the right/left. A description of the </context>
</contexts>
<marker>Uszkoreit, 1986</marker>
<rawString>Uszkoreit, H. (1986). Categorial Unification Grammars. In Proceedings of the 11th International Conference on Computational Linguistics, Bonn, pages 187–194.</rawString>
</citation>
<citation valid="true">
<authors>
<author>H Zeevat</author>
<author>E Klein</author>
<author>J Calder</author>
</authors>
<title>Unification Categorial Grammar.</title>
<date>1987</date>
<booktitle>Categorial Grammar, Unification Grammar and Parsing, Working Papers in Cognitive Science. Centre</booktitle>
<editor>In Haddock, N., Klein, E., and Morrill, G., editors,</editor>
<institution>for Cognitive Science, University of Edinburgh.</institution>
<contexts>
<context position="11543" citStr="Zeevat et al. (1987)" startWordPosition="1918" endWordPosition="1921"> as typed feature structures. Any lexicon from either of these formalisms can be translated into a T-CCG lexicon whose functionality ratio is either equivalent or lower. 4 Inheritance-driven CCG A second generalisation of the CCG formalism involves adding a second alphabet of non-terminals, in this case a set of ‘lexical types’. The lexical types are organised into an ‘inheritance hierarchy’, constrained by expressions of a simple featurebased category description language, inspired by previous attempts to integrate categorial grammars and unification-based grammars, e.g. Uszkoreit (1986) and Zeevat et al. (1987). 4.1 Simple category descriptions The set of simple category descriptions over alphabet A of saturated category symbols is defined as the smallest set Φ such that: 1. A C Φ 2. for all 6 E If, b}, (SLASH 6) E Φ 3. for all 0 E Φ, (ARG 0) E Φ 4. for all 0 E Φ, (RES 0) E Φ Note that category descriptions may be infinitely embedded, in which case they are considered to be right-associative, e.g. RES ARG RES SLASH f. A simple category description like (SLASH f) or (SLASH b) denotes the set of all expressions which seek their argument to the right/left. A description of the form (ARG 0) denotes the </context>
</contexts>
<marker>Zeevat, Klein, Calder, 1987</marker>
<rawString>Zeevat, H., Klein, E., and Calder, J. (1987). Unification Categorial Grammar. In Haddock, N., Klein, E., and Morrill, G., editors, Categorial Grammar, Unification Grammar and Parsing, Working Papers in Cognitive Science. Centre for Cognitive Science, University of Edinburgh.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>