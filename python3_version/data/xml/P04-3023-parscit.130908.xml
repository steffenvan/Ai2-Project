<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.042879">
<title confidence="0.975887">
On the Equivalence of Weighted Finite-state Transducers
</title>
<author confidence="0.981138">
Julien Quint
</author>
<affiliation confidence="0.96236">
National Institute of Informatics
</affiliation>
<address confidence="0.622831">
Hitotsubashi 2-1-2
Chiyoda-ku
Tokyo 101-8430
Japan
</address>
<email confidence="0.970441">
quint@nii.ac.jp
</email>
<sectionHeader confidence="0.992703" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.9997021">
Although they can be topologically different, two
distinct transducers may actually recognize the
same rational relation. Being able to test the equiv-
alence of transducers allows to implement such op-
erations as incremental minimization and iterative
composition. This paper presents an algorithm for
testing the equivalence of deterministic weighted
finite-state transducers, and outlines an implemen-
tation of its applications in a prototype weighted
finite-state calculus tool.
</bodyText>
<sectionHeader confidence="0.959675" genericHeader="introduction">
Introduction
</sectionHeader>
<bodyText confidence="0.999821055555556">
The addition of weights in finite-state devices
(where transitions, initial states and final states are
weighted) introduced the need to reevaluate many
of the techniques and algorithms used in classical
finite-state calculus. Interesting consequences are,
for instance, that not all non-deterministic weighted
automata can be made deterministic (Buchsbaum
et al., 2000); or that epsilon transitions may offset
the weights in the result of the composition of two
transducers (Pereira and Riley, 1997).
A fundamental operation on finite-state transduc-
ers in equivalence testing, which leads to applica-
tions such as incremental minimization and itera-
tive composition. Here, we present an algorithm
for equivalence testing in the weighted case, and
describe its application to these applications. We
also describe a prototype implementation, which is
demonstrated.
</bodyText>
<sectionHeader confidence="0.996892" genericHeader="method">
1 Definitions
</sectionHeader>
<bodyText confidence="0.996652964285714">
We define a weightedfinite-state automata (WFST)
T over a set of weights K by an 8-tuple
(E, Q, Q, I, F, E, A, p) where E and Q are two fi-
nite sets of symbols (alphabets), Q is a finite set of
states, I ⊆ Q is the set of initial states, F ⊆ Q is the
set of final states,E ⊆ Q×E∪{ε}×Q∪{ε}×K×Q
is the set of transitions, and A : I → K and
p : F → K are the initial and final weight func-
tions.
A transition e ∈ E has a label l(e) ∈ E∪{E}×Q∪
{E}, a weight w(e) ∈ K and a destination S(e) ∈ Q.
The set of weights is a semi-ring, that is a system
(K, ⊕, ⊗, ¯0,¯1) where 0¯ is the identity element for
⊕, 1 is the identity element for ⊗, and ⊕ is com-
mutative (Berstel and Reteunauer, 1988). The cost
of a path in a WFST is the product (⊗) of the initial
weight of the initial state, the weight of all the tran-
sitions, and the final weight of the final state. When
several paths in the WFST match the same relation,
the total cost is the sum (⊕) of the costs of all the
paths.
In NLP, the tropical semi-ring (R+ ∪
{∞}, min, +, ∞, 0) is very often used: weights
are added along a path, and if several paths match
the same relation, the total cost is the cost of the
path with minimal cost. The following discussion
will apply to any semi-ring, with examples using
the tropical semi-ring.
</bodyText>
<sectionHeader confidence="0.931143" genericHeader="method">
2 The Equivalence Testing Algorithm
</sectionHeader>
<bodyText confidence="0.993254121212121">
Several algorithms testing the equivalence of two
states are presented in (Watson and Daciuk, 2003),
from which we will derive ours. Two states are
equivalent if and only if their respective right lan-
guage are equivalent. The right language of a state
is the set of words originating from this state. Two
deterministic finite-state automata are equivalent if
and only if they recognize the same language, that
is, if their initial states have the same right language.
Hence, it is possible to test the equivalence of two
automata by applying the equivalence algorithm on
their initial states.
In order to test the equivalence of two WFSTs, we
need to extend the state equivalence test algorithm
in two ways: first, it must apply to transducers, and
second, it must take weights into account. Handling
transducers is easily achieved as the labels of transi-
tions defined above are equivalent to symbols in an
alphabet (i.e. we consider the underlying automaton
of the transducer).
Taking weights into account means that for
two WFSTs to be equivalent, they must recog-
nize the same relation (or their underlying au-
tomata must recognize the same language), with the
same weights. However, as illustrated by figure 1,
two WFSTs can be equivalent but have a different
weight distribution. States 1 and 5 have the same
right language, but words have different costs (for
example, abad has a cost of 6 in the top automaton,
and 5 in the bottom one). We notice however that
the difference of weights between words is constant,
so states 1 and 5 are really equivalent modulo a cost
of 1.
</bodyText>
<figureCaption confidence="0.927753222222222">
Figure 1: Two equivalent weighted finite-state
transducers (using the tropical semi-ring).
Figure 2 shows the weighted equivalence algo-
rithm. Given two states p and q, it returns a true
value if they are equivalent, and a false value other-
wise. Remainder weights are also passed as param-
eters wp and wQ. The last parameter is an associative
array 5 that we use to keep track of states that were
already visited.
</figureCaption>
<bodyText confidence="0.986918592592593">
The algorithm works as follows: given two states,
compare their signature. The signature of a state is
a string encoding its class (final or not) and the list
of labels on outgoing transition. In the case of de-
terministic transducers, if the signature for the two
states do not match, then they cannot have the same
right language and therefore cannot be equivalent.
Otherwise, if the two states are final, then their
weights (taking into account the remainder weights)
must be the same (lines 6–7). Then, all their outgo-
ing transitions have to be checked: the states will
be equivalent if matching transitions lead to equiva-
lent states (lines 8–12). The destination states are
recursively checked. The REMAINDER function
computes the remainder weights for the destination
states. Given two weights x and y, it returns {¯1,
x ⊗ y−1} if x &lt; y, and {x−1 ⊗ y,¯1} otherwise.
If there is a cycle, then we will see the same pair
of states twice. The weight of the cycle must be the
same in both transducers, so the remainder weights
must be unchanged. This is tested in lines 2–4.
The algorithm applies to deterministic WFSTs,
which can have only one initial state. To test the
equivalence of two WFSTs, we call EQUIV on the
respective initial states of the the WFSTs with their
initial weights as the remainder weights, and 5 is
initially empty.
</bodyText>
<sectionHeader confidence="0.99793" genericHeader="method">
3 Incremental minimization
</sectionHeader>
<bodyText confidence="0.999851925925926">
An application of this equivalence algorithm is the
incremental minimization algorithm of (Watson and
Daciuk, 2003). For every deterministic WFST T
there exists at least one equivalent WFST M such
that no other equivalent WFST has fewer states (i.e.
|QM |is minimal). In the unweighted case, this
means that there cannot be two distinct states that
are equivalent in the minimized transducer.
It follows that a way to build this transducer M
is to compare every pair of distinct states in QA and
merge pairs of equivalent states until there are no
two equivalent states in the transducer. An advan-
tage of this method is that at any time of the appli-
cation of the algorithm, the transducer is in a consis-
tent state; if the process has to finish under a certain
time limit, it can simply be stopped (the number of
states will have decreased, even though the mini-
mality of the result cannot be guaranteed then).
In the weighted case, merging two equivalent
states is not as easy because edges with the same la-
bel may have a different weight. In figure 3, we see
that states 1 and 2 are equivalent and can be merged,
but outgoing transitions have different weights. The
remainder weights have to be pushed to the follow-
ing states, which can then be merged if they are
equivalent modulo the remainder weights. This ap-
plies to states 3 and 4 here.
</bodyText>
<figureCaption confidence="0.948982">
Figure 3: Non-minimal transducer and its mini-
mized equivalent.
</figureCaption>
<sectionHeader confidence="0.991479" genericHeader="method">
4 Generic Composition with Filter
</sectionHeader>
<bodyText confidence="0.999915333333333">
As shown previously (Pereira and Riley, 1997), a
special algorithm is needed for the composition of
WFSTs. A filter is introduced, whose role is to han-
dle epsilon transitions on the lower side of the top
transducer and the upper side of the lower trans-
ducer (it is also useful in the unweighted case). In
our implementation described in section 5 we have
generalized the use of this epsilon-free composition
operation to handle two operations that are defined
</bodyText>
<figure confidence="0.998146958333333">
c/2 a/2
4 5 6
b/1
c/1
0 1
a/1
b/2
2
d/2
d/0
3/0
7/0
a/2
a/1
1
c/1
b/0 3 5/0
0
b/1
2
a/1
c/2
b/0 4 6/0
b/0
a/1
0 1
a/2
2
c/1
3/0
b/1
EQUIV(p, wp, q, wq, S)
1 equiv ← FALSE
2 if S[{p, q}] =6 NIL
3 then {w0p, w0q} ← S[{p, q}]
4 equiv ← w0
=
p
wp ∧ w0q = wq
5 else if SIGNATURE(p) = SIGNATURE(q)
6 then if FINAL(p)
7 then equiv ← wp ⊗ ρ(p) = wq ⊗ ρ(q)
8 S[{p, q}] ← {wp, wq}
9 for ep ∈ E(p), eq ∈ E(q), l(ep) = l(eq)
10 do {w0p, w0q} ← REMAINDER(wp ⊗ w(ep), wq ⊗ w(eq))
11 equiv ← equiv ∧EQUIV(δ(ep), w0p, δ(eq), w0q, S)
12 DELETE(S[{p, q}])
13 return equiv
</figure>
<figureCaption confidence="0.999915">
Figure 2: The equivalence algorithm
</figureCaption>
<bodyText confidence="0.999951571428571">
on automata only, that is intersection and cross-
product. Intersection is a simple variant of the com-
position of the identity transducers corresponding to
the operand automata.
Cross-product uses the exact same algorithm but
a different filter, shown in figure 4. The prepro-
cessing stage for both operand automata consists of
adding a transition with a special symbol x at every
final state, going to itself, and with a weight of ¯1.
This will allow to match words of different lengths,
as when one of the automata is “exhausted,” the x
symbol will be added as long as the other automa-
ton is not. After the composition, the x symbol is
replaced everywhere by E.
</bodyText>
<figureCaption confidence="0.5000585">
Figure 4: Cross-product filter. The symbol “?”
matches any symbol; “x” is a special espilon-
symbol introduced in the final states of the operand
automata at preprocessing.
</figureCaption>
<bodyText confidence="0.9999325">
The equivalence algorithm that is the subject of
this paper is used in conjunction with composition
of WFSTs in order to provide an iterative com-
position operator. Given two transducers A and
B, it composes A with B, then composes the re-
sult with B again, and again, until a fixed-point
is reached. This can be determined by testing the
equivalence of the last two iterations. Roche and
Schabes (1994) have shown that in the unweighted
case this allows to parse context-free grammars with
finite-state transducers; in our case, a cost can be
added to the parse.
</bodyText>
<sectionHeader confidence="0.997858" genericHeader="method">
5 A Prototype Implementation
</sectionHeader>
<bodyText confidence="0.999874318181818">
The algorithms described above have all been im-
plemented in a prototype weighted finite-state tool,
called wfst, inspired from the Xerox tool xfst
(Beesley and Karttunen, 2003) and the FSM library
from AT&amp;T (Mohri et al., 1997). From the former, it
borrows a similar command-line interface and reg-
ular expression syntax, and from the latter, the ad-
dition of weights. The system will be demonstrated
and should be available for download soon.
The operations described above are all avail-
able in wfst, in addition to classical opera-
tions like union, intersection (only defined on
automata), concatenation, etc. The regular ex-
pression syntax is inspired from xfst and Perl
(the implementation language). For instance, the
automaton of figure 3 was compiled from the
regular expression (a/1 a/2 b/0* c/1)
|
(b/2 a/1 b/0* c/2) and the iterative compo-
sition of two previously defined WFSTs A and B is
written $A %+ $B (we chose % as the composition
operator, and + refers to the Kleene plus operator).
</bodyText>
<sectionHeader confidence="0.941958" genericHeader="conclusions">
Conclusion
</sectionHeader>
<bodyText confidence="0.999848">
We demonstrate a simple and powerful experimen-
tal weighted finite state calculus tool and have de-
scribed an algorithm at the core of its operation for
</bodyText>
<figure confidence="0.955803">
7:x/0
7:7/0 1/0
7:x/0
0/0
x:7/0
x:7/0
2/0
</figure>
<bodyText confidence="0.999846444444445">
the equivalence of weighted transducers. There are
two major limitations to the weighted equivalence
algorithm. The first one is that it works only on de-
terministic WFSTs; however, not all WFSTs can be
determinized. An algorithm with backtracking may
be a solution to this problem, but its running time
would increase, and it remains to be seen if such
an algorithm could apply to undeterminizable trans-
ducers.
The other limitation is that two transducers rec-
ognizing the same rational relation may have non-
equivalent underlying automata, and some labels
will not match (e.g. {a, E}{b, c} vs. {a, c}{b, E}).
A possible solution to this problem is to consider
the shortest string on both sides and have “remain-
der strings” like we have remainder weights in the
weighted case. If successful, this technique could
yield interesting results in determinization as well.
</bodyText>
<sectionHeader confidence="0.999427" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.99970075">
Kenneth R. Beesley and Lauri Karttunen. 2003. Fi-
nite State Morphology. CSLI Publications, Stan-
ford, California.
Jean Berstel and Christophe Reteunauer. 1988. Ra-
tional Series and their Languages. Springer Ver-
lag, Berlin, Germany.
Adam L. Buchsbaum, Raffaele Giancarlo, and Jef-
fery R. Westbrook. 2000. On the determiniza-
tion of weighted finite automata. SIAM Journal
on Computing, 30(5):1502–1531.
Mehryar Mohri, Fernando C. N. Pereira, and
Michael Riley. 1997. A rational design for a
weighted finite-state transducer library. In Work-
shop on Implementing Automata, pages 144–158,
London, Ontario.
Fernando C. N. Pereira and Michael Riley. 1997.
Speech recognition by composition of weighted
finite state automata. In Emmanuel Roche and
Yves Schabes, editors, Finite-State Language
Processing, pages 431–453. MIT Press, Cam-
bridge, Massachusetts.
Emmanuel Roche and Yves Schabes. 1994. Two
parsing algorithms by means of finite state trans-
ducers. In Proceedings of COLING’94, pages
431–435, Ky¯ot¯o, Japan.
Bruce W. Watson and Jan Daciuk. 2003. An effi-
cient incremental DFA minimization algorithm.
Natural Language Engineering, 9(1):49–64.
</reference>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.093398">
<title confidence="0.999961">On the Equivalence of Weighted Finite-state Transducers</title>
<author confidence="0.999188">Julien Quint</author>
<affiliation confidence="0.998138">National Institute of Informatics</affiliation>
<address confidence="0.650023">Hitotsubashi 2-1-2</address>
<email confidence="0.565131">Chiyoda-ku</email>
<address confidence="0.3645835">Tokyo 101-8430 Japan</address>
<email confidence="0.90233">quint@nii.ac.jp</email>
<abstract confidence="0.999170454545455">Although they can be topologically different, two distinct transducers may actually recognize the same rational relation. Being able to test the equivalence of transducers allows to implement such operations as incremental minimization and iterative composition. This paper presents an algorithm for testing the equivalence of deterministic weighted finite-state transducers, and outlines an implementation of its applications in a prototype weighted finite-state calculus tool.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Kenneth R Beesley</author>
<author>Lauri Karttunen</author>
</authors>
<title>Finite State Morphology.</title>
<date>2003</date>
<publisher>CSLI Publications,</publisher>
<location>Stanford, California.</location>
<contexts>
<context position="10308" citStr="Beesley and Karttunen, 2003" startWordPosition="1797" endWordPosition="1800">ve composition operator. Given two transducers A and B, it composes A with B, then composes the result with B again, and again, until a fixed-point is reached. This can be determined by testing the equivalence of the last two iterations. Roche and Schabes (1994) have shown that in the unweighted case this allows to parse context-free grammars with finite-state transducers; in our case, a cost can be added to the parse. 5 A Prototype Implementation The algorithms described above have all been implemented in a prototype weighted finite-state tool, called wfst, inspired from the Xerox tool xfst (Beesley and Karttunen, 2003) and the FSM library from AT&amp;T (Mohri et al., 1997). From the former, it borrows a similar command-line interface and regular expression syntax, and from the latter, the addition of weights. The system will be demonstrated and should be available for download soon. The operations described above are all available in wfst, in addition to classical operations like union, intersection (only defined on automata), concatenation, etc. The regular expression syntax is inspired from xfst and Perl (the implementation language). For instance, the automaton of figure 3 was compiled from the regular expre</context>
</contexts>
<marker>Beesley, Karttunen, 2003</marker>
<rawString>Kenneth R. Beesley and Lauri Karttunen. 2003. Finite State Morphology. CSLI Publications, Stanford, California.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jean Berstel</author>
<author>Christophe Reteunauer</author>
</authors>
<title>Rational Series and their Languages.</title>
<date>1988</date>
<publisher>Springer Verlag,</publisher>
<location>Berlin, Germany.</location>
<contexts>
<context position="2229" citStr="Berstel and Reteunauer, 1988" startWordPosition="359" endWordPosition="362">er a set of weights K by an 8-tuple (E, Q, Q, I, F, E, A, p) where E and Q are two finite sets of symbols (alphabets), Q is a finite set of states, I ⊆ Q is the set of initial states, F ⊆ Q is the set of final states,E ⊆ Q×E∪{ε}×Q∪{ε}×K×Q is the set of transitions, and A : I → K and p : F → K are the initial and final weight functions. A transition e ∈ E has a label l(e) ∈ E∪{E}×Q∪ {E}, a weight w(e) ∈ K and a destination S(e) ∈ Q. The set of weights is a semi-ring, that is a system (K, ⊕, ⊗, ¯0,¯1) where 0¯ is the identity element for ⊕, 1 is the identity element for ⊗, and ⊕ is commutative (Berstel and Reteunauer, 1988). The cost of a path in a WFST is the product (⊗) of the initial weight of the initial state, the weight of all the transitions, and the final weight of the final state. When several paths in the WFST match the same relation, the total cost is the sum (⊕) of the costs of all the paths. In NLP, the tropical semi-ring (R+ ∪ {∞}, min, +, ∞, 0) is very often used: weights are added along a path, and if several paths match the same relation, the total cost is the cost of the path with minimal cost. The following discussion will apply to any semi-ring, with examples using the tropical semi-ring. 2 T</context>
</contexts>
<marker>Berstel, Reteunauer, 1988</marker>
<rawString>Jean Berstel and Christophe Reteunauer. 1988. Rational Series and their Languages. Springer Verlag, Berlin, Germany.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Adam L Buchsbaum</author>
<author>Raffaele Giancarlo</author>
<author>Jeffery R Westbrook</author>
</authors>
<title>On the determinization of weighted finite automata.</title>
<date>2000</date>
<journal>SIAM Journal on Computing,</journal>
<volume>30</volume>
<issue>5</issue>
<contexts>
<context position="1041" citStr="Buchsbaum et al., 2000" startWordPosition="135" endWordPosition="138"> iterative composition. This paper presents an algorithm for testing the equivalence of deterministic weighted finite-state transducers, and outlines an implementation of its applications in a prototype weighted finite-state calculus tool. Introduction The addition of weights in finite-state devices (where transitions, initial states and final states are weighted) introduced the need to reevaluate many of the techniques and algorithms used in classical finite-state calculus. Interesting consequences are, for instance, that not all non-deterministic weighted automata can be made deterministic (Buchsbaum et al., 2000); or that epsilon transitions may offset the weights in the result of the composition of two transducers (Pereira and Riley, 1997). A fundamental operation on finite-state transducers in equivalence testing, which leads to applications such as incremental minimization and iterative composition. Here, we present an algorithm for equivalence testing in the weighted case, and describe its application to these applications. We also describe a prototype implementation, which is demonstrated. 1 Definitions We define a weightedfinite-state automata (WFST) T over a set of weights K by an 8-tuple (E, Q</context>
</contexts>
<marker>Buchsbaum, Giancarlo, Westbrook, 2000</marker>
<rawString>Adam L. Buchsbaum, Raffaele Giancarlo, and Jeffery R. Westbrook. 2000. On the determinization of weighted finite automata. SIAM Journal on Computing, 30(5):1502–1531.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Mehryar Mohri</author>
<author>Fernando C N Pereira</author>
<author>Michael Riley</author>
</authors>
<title>A rational design for a weighted finite-state transducer library.</title>
<date>1997</date>
<booktitle>In Workshop on Implementing Automata,</booktitle>
<pages>144--158</pages>
<location>London, Ontario.</location>
<contexts>
<context position="10359" citStr="Mohri et al., 1997" startWordPosition="1807" endWordPosition="1810">omposes A with B, then composes the result with B again, and again, until a fixed-point is reached. This can be determined by testing the equivalence of the last two iterations. Roche and Schabes (1994) have shown that in the unweighted case this allows to parse context-free grammars with finite-state transducers; in our case, a cost can be added to the parse. 5 A Prototype Implementation The algorithms described above have all been implemented in a prototype weighted finite-state tool, called wfst, inspired from the Xerox tool xfst (Beesley and Karttunen, 2003) and the FSM library from AT&amp;T (Mohri et al., 1997). From the former, it borrows a similar command-line interface and regular expression syntax, and from the latter, the addition of weights. The system will be demonstrated and should be available for download soon. The operations described above are all available in wfst, in addition to classical operations like union, intersection (only defined on automata), concatenation, etc. The regular expression syntax is inspired from xfst and Perl (the implementation language). For instance, the automaton of figure 3 was compiled from the regular expression (a/1 a/2 b/0* c/1) | (b/2 a/1 b/0* c/2) and t</context>
</contexts>
<marker>Mohri, Pereira, Riley, 1997</marker>
<rawString>Mehryar Mohri, Fernando C. N. Pereira, and Michael Riley. 1997. A rational design for a weighted finite-state transducer library. In Workshop on Implementing Automata, pages 144–158, London, Ontario.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Fernando C N Pereira</author>
<author>Michael Riley</author>
</authors>
<title>Speech recognition by composition of weighted finite state automata.</title>
<date>1997</date>
<booktitle>In Emmanuel Roche and Yves Schabes, editors, Finite-State Language Processing,</booktitle>
<pages>431--453</pages>
<publisher>MIT Press,</publisher>
<location>Cambridge, Massachusetts.</location>
<contexts>
<context position="1171" citStr="Pereira and Riley, 1997" startWordPosition="156" endWordPosition="159">ducers, and outlines an implementation of its applications in a prototype weighted finite-state calculus tool. Introduction The addition of weights in finite-state devices (where transitions, initial states and final states are weighted) introduced the need to reevaluate many of the techniques and algorithms used in classical finite-state calculus. Interesting consequences are, for instance, that not all non-deterministic weighted automata can be made deterministic (Buchsbaum et al., 2000); or that epsilon transitions may offset the weights in the result of the composition of two transducers (Pereira and Riley, 1997). A fundamental operation on finite-state transducers in equivalence testing, which leads to applications such as incremental minimization and iterative composition. Here, we present an algorithm for equivalence testing in the weighted case, and describe its application to these applications. We also describe a prototype implementation, which is demonstrated. 1 Definitions We define a weightedfinite-state automata (WFST) T over a set of weights K by an 8-tuple (E, Q, Q, I, F, E, A, p) where E and Q are two finite sets of symbols (alphabets), Q is a finite set of states, I ⊆ Q is the set of ini</context>
<context position="7704" citStr="Pereira and Riley, 1997" startWordPosition="1314" endWordPosition="1317">mality of the result cannot be guaranteed then). In the weighted case, merging two equivalent states is not as easy because edges with the same label may have a different weight. In figure 3, we see that states 1 and 2 are equivalent and can be merged, but outgoing transitions have different weights. The remainder weights have to be pushed to the following states, which can then be merged if they are equivalent modulo the remainder weights. This applies to states 3 and 4 here. Figure 3: Non-minimal transducer and its minimized equivalent. 4 Generic Composition with Filter As shown previously (Pereira and Riley, 1997), a special algorithm is needed for the composition of WFSTs. A filter is introduced, whose role is to handle epsilon transitions on the lower side of the top transducer and the upper side of the lower transducer (it is also useful in the unweighted case). In our implementation described in section 5 we have generalized the use of this epsilon-free composition operation to handle two operations that are defined c/2 a/2 4 5 6 b/1 c/1 0 1 a/1 b/2 2 d/2 d/0 3/0 7/0 a/2 a/1 1 c/1 b/0 3 5/0 0 b/1 2 a/1 c/2 b/0 4 6/0 b/0 a/1 0 1 a/2 2 c/1 3/0 b/1 EQUIV(p, wp, q, wq, S) 1 equiv ← FALSE 2 if S[{p, q}]</context>
</contexts>
<marker>Pereira, Riley, 1997</marker>
<rawString>Fernando C. N. Pereira and Michael Riley. 1997. Speech recognition by composition of weighted finite state automata. In Emmanuel Roche and Yves Schabes, editors, Finite-State Language Processing, pages 431–453. MIT Press, Cambridge, Massachusetts.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Emmanuel Roche</author>
<author>Yves Schabes</author>
</authors>
<title>Two parsing algorithms by means of finite state transducers.</title>
<date>1994</date>
<booktitle>In Proceedings of COLING’94,</booktitle>
<pages>431--435</pages>
<location>Ky¯ot¯o, Japan.</location>
<contexts>
<context position="9942" citStr="Roche and Schabes (1994)" startWordPosition="1739" endWordPosition="1742">position, the x symbol is replaced everywhere by E. Figure 4: Cross-product filter. The symbol “?” matches any symbol; “x” is a special espilonsymbol introduced in the final states of the operand automata at preprocessing. The equivalence algorithm that is the subject of this paper is used in conjunction with composition of WFSTs in order to provide an iterative composition operator. Given two transducers A and B, it composes A with B, then composes the result with B again, and again, until a fixed-point is reached. This can be determined by testing the equivalence of the last two iterations. Roche and Schabes (1994) have shown that in the unweighted case this allows to parse context-free grammars with finite-state transducers; in our case, a cost can be added to the parse. 5 A Prototype Implementation The algorithms described above have all been implemented in a prototype weighted finite-state tool, called wfst, inspired from the Xerox tool xfst (Beesley and Karttunen, 2003) and the FSM library from AT&amp;T (Mohri et al., 1997). From the former, it borrows a similar command-line interface and regular expression syntax, and from the latter, the addition of weights. The system will be demonstrated and should </context>
</contexts>
<marker>Roche, Schabes, 1994</marker>
<rawString>Emmanuel Roche and Yves Schabes. 1994. Two parsing algorithms by means of finite state transducers. In Proceedings of COLING’94, pages 431–435, Ky¯ot¯o, Japan.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Bruce W Watson</author>
<author>Jan Daciuk</author>
</authors>
<title>An efficient incremental DFA minimization algorithm.</title>
<date>2003</date>
<journal>Natural Language Engineering,</journal>
<volume>9</volume>
<issue>1</issue>
<contexts>
<context position="2961" citStr="Watson and Daciuk, 2003" startWordPosition="494" endWordPosition="497">all the transitions, and the final weight of the final state. When several paths in the WFST match the same relation, the total cost is the sum (⊕) of the costs of all the paths. In NLP, the tropical semi-ring (R+ ∪ {∞}, min, +, ∞, 0) is very often used: weights are added along a path, and if several paths match the same relation, the total cost is the cost of the path with minimal cost. The following discussion will apply to any semi-ring, with examples using the tropical semi-ring. 2 The Equivalence Testing Algorithm Several algorithms testing the equivalence of two states are presented in (Watson and Daciuk, 2003), from which we will derive ours. Two states are equivalent if and only if their respective right language are equivalent. The right language of a state is the set of words originating from this state. Two deterministic finite-state automata are equivalent if and only if they recognize the same language, that is, if their initial states have the same right language. Hence, it is possible to test the equivalence of two automata by applying the equivalence algorithm on their initial states. In order to test the equivalence of two WFSTs, we need to extend the state equivalence test algorithm in t</context>
<context position="6335" citStr="Watson and Daciuk, 2003" startWordPosition="1070" endWordPosition="1073"> otherwise. If there is a cycle, then we will see the same pair of states twice. The weight of the cycle must be the same in both transducers, so the remainder weights must be unchanged. This is tested in lines 2–4. The algorithm applies to deterministic WFSTs, which can have only one initial state. To test the equivalence of two WFSTs, we call EQUIV on the respective initial states of the the WFSTs with their initial weights as the remainder weights, and 5 is initially empty. 3 Incremental minimization An application of this equivalence algorithm is the incremental minimization algorithm of (Watson and Daciuk, 2003). For every deterministic WFST T there exists at least one equivalent WFST M such that no other equivalent WFST has fewer states (i.e. |QM |is minimal). In the unweighted case, this means that there cannot be two distinct states that are equivalent in the minimized transducer. It follows that a way to build this transducer M is to compare every pair of distinct states in QA and merge pairs of equivalent states until there are no two equivalent states in the transducer. An advantage of this method is that at any time of the application of the algorithm, the transducer is in a consistent state; </context>
</contexts>
<marker>Watson, Daciuk, 2003</marker>
<rawString>Bruce W. Watson and Jan Daciuk. 2003. An efficient incremental DFA minimization algorithm. Natural Language Engineering, 9(1):49–64.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>