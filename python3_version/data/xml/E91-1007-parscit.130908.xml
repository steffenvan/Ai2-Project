<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000002">
<title confidence="0.8476725">
HORN EXTENDED FEATURE STRUCTURES:
FAST UNIFICATION WITH NEGATION AND LIMITED DISJUNCTIONt
</title>
<author confidence="0.950513">
Stephen J. IIegner
</author>
<affiliation confidence="0.976464666666667">
Department of Computer Science and Electrical Engineering
Votey Building
University of Vermont
</affiliation>
<address confidence="0.8926565">
Burlington, VT 05405 USA
telephone: (802)656-3330
</address>
<email confidence="0.8190855">
internet: hegner@uvm.edu
uucp: ..uunet!uvm-gen!hegner
</email>
<sectionHeader confidence="0.967622" genericHeader="abstract">
ABSTRACT
</sectionHeader>
<bodyText confidence="0.999871181818182">
The notion of a Horn extended feature structure
(11oXF) is introduced, which is a feature structure
constrained so that its only allowable extensions are
those satisfying some set of Horn clauses in feature-
term logic. 11oXF&apos;s greatly generalize ordinary fea-
ture structures in admitting explicit representation of
negative and implicational constraints. In contradis-
tinction to the general case in which arbitrary logical
constraints are allowed (for which the best known al-
gorithms are exponential), there is a highly tractable
algorithm for the unification of HoXF&apos;s.
</bodyText>
<sectionHeader confidence="0.997031" genericHeader="categories and subject descriptors">
1. PRELIMINARY CONCEPTS
</sectionHeader>
<subsectionHeader confidence="0.997548">
1.1 Unification-based grammar formalisms
</subsectionHeader>
<bodyText confidence="0.99988405">
Unification-based grammar formalisms constitute a
cornerstone of many of the most important approaches
to natural-language understanding (Shieber, 1986),
(Colban, 1988), (Fenstad et al., 1989). The basic idea
is that the parser generates a number of partial repre-
sentations of the total parse, which are subsequently
checked for consistency and combined by a second pro-
cess known as a unifier. A common form of represen-
tation for the partial representations is that of feature
structures, which are record-like data structures which
are allowed to grow in three distinct ways: by adding
missing values, by adding attributes, and by coalescing
existing attributes (forcing them to be the same). The
last operation may lead to cyclic structures, which we
do not exclude. If the feature structure S2 is an ex-
tension of Si (i.e., Si grows into S2 by application of
some sequence of the above rules), we write .91 C S2
and say that Si subsumes S2. Intuitively, if S1 C S2,
S2 contains more information than does Si. It is easy
to show that C is a partial order on the class of all
feature structures.
Each feature structure represents partial informa-
tion generated during the parse. To obtain the total
picture, these partial components must be combined
t The research reported herein was performed while the
author was visiting the COSMOS Computational Linguistics
Group of the Mathematics Department at the University of
Oslo. He wishes to thank Jens Erik Fenstad and the members
of that group for providing a stimulating research environment.
Particular thanks are due Tore Langholm for many invaluable
discussions regarding the interplay of logic, feature structures,
and unification.
into one consistent piece of knowledge. The formal
process of unification is precisely this operation of com-
bination. The most general unifier (mgu) S1 U S2 of
feature structures Si and S2 is the least feature struc-
ture (under C) which is larger than both S1 and S2.
Such an mgu exists if and only if S1 and S2 are con-
sistent; that is, if and only if they subsume a common
feature structure.
</bodyText>
<subsectionHeader confidence="0.986052">
1.2 Unification algorithms and this paper
</subsectionHeader>
<bodyText confidence="0.999601">
While the idea of a most general unifier is a pleasing
theoretical notion, its real utility rest with the fact
that there are efficient algorithms for its computation.
The fastest known algorithm, identified by Ait-Kaci
(1984), runs in time which is, for all practical pur-
poses, linear in the size of the input (i.e., the combined
sizes of the structures to be unified). In proposing any
extension to the basic framework, a primary considera-
tion must be the complexity of the ensuing unification
algorithm. The principal contribution of the research
summarized here is to provide an extension of ordinary
feature structures, admitting negation and limited dis-
junction, while at the same time continuing to admit
a provably efficient unification algorithm.
Due to space limitations, we must omit substan-
tial background material from this paper. Specifically,
we assume that the reader is familiar with the no-
tation and definitions surrounding feature structures
(Shieber, 1986; Fenstad et at., 1989), as well as the
traditional unification algorithm (Colban, 1990). We
also have been forced to omit much detail from the
description and verification of our algorithm. A full
report on this work will be available in the near fu-
ture.
</bodyText>
<sectionHeader confidence="0.9997765" genericHeader="method">
2. UNIFICATION IN THE PRESENCE
OF CONSTRAINTS
</sectionHeader>
<subsectionHeader confidence="0.989572">
2.1 Constraints on feature structures Not ev-
</subsectionHeader>
<bodyText confidence="0.997918208333333">
ery feature structure is a possibility as the ultimate
output of the parsing mechanism. Typically, there are
constraints which must be observed. One way of en-
suring this sort of consistency is to build the checks
right into the grammar, so that the feature structures
generated are always legitimate substructures of the
final output. The CLO formalism (Damas and Var-
ile, 1989) is an example of such a philosophy. In many
ways, this is an attractive option, because it provides a
- 33.
unified context for expressing all aspects of the gram-
mar. However, this approach has the disadvantage
that it limits the use of independent parsing subalgo-
rithms whose results are subsequently unified, since
the consistency checks must be performed before the
feature structures are presented to the unifier. There-
fore, to maintain such independence, it would be a
distinct advantage if some of the constraint checking
could be relegated to the unification process.
To establish a formal framework in which this is
possible, we must start by extending our notion of a
feature structure. Following the ideas of Moshier and
Rounds (1987) and Langholm (1989), we define an ex-
tended feature structure to be a pair (N, K) in which
</bodyText>
<listItem confidence="0.581117">
K is a set of feature structures and N is the least ek-
ment of K under the ordering C. (Thus, by definition,
K has a least element, and K determines N.) Think of
N as the &amp;quot;current&amp;quot; feature structure, and K as the set
of all structures into which N is allowed to grow. We
define (N1, K1) C. (N2, K2) to mean precisely that
K2 C /C1. In other words, the set of all structures
which N2 can grow into is a subset of those which N1
can grow into. (It follows necessarily that N1 C N2
in this case.) Note that if we identify the ordinary
feature structure N with the pair (N, {M N C M)),
we precisely recapture ordinary subsumption. Finally,
the notion of unification associated with C. is given
by
</listItem>
<equation confidence="0.4324545">
(MI , Kt) U. (M2, /C2) =-
1 (M,Ki n /C2) if /Ci n tc2
</equation>
<bodyText confidence="0.851449">
has a least element M;
undefined otherwise.
</bodyText>
<subsectionHeader confidence="0.999065">
2.2 Logical feature structures with con-
</subsectionHeader>
<bodyText confidence="0.998180216216216">
straints To operate on pairs of the form (N, K) al-
gorithmically, we must have in place an appropriate
representation for the set K. There are many possible
choices; ours is to let it be the set of all structures
satisfying a. set of sentences in a particular logic. The
logic which we use is a simple modification of the lan-
guage of Rounds and Kasper (1986) (see also (Kasper
and Rounds, 1990)) admitting negation but only bi-
nary path equivalences. Specifically, an atomic feature
term is one of the following.
In (a : a), the label a may be T, denoting a miss-
ing value. The notation (a x 13) is borrowed from
(Langholm, 1989), and has the same semantics as
{a,13) of (Rounds and Kasper, 1986). A (general) fea-
ture term is built up from atomic feature terms using
the connectives A, v, and with the usual semantics.
In particular, the negation we use is the classical no-
tion; a structure satisfies (-y) if and only if it does
not satisfy v. For any set 4) of feature terms, Mod(l))
denotes the set of all feature structures for which each
co E 4&apos; is true. For a formal definition of satisfaction,
we refer the reader to the above-cited references. In-
tuitively, any set of terms which defines a consistent
rooted, directed graph is satisfiable. However, let us
specifically remark that only nodes with no outgoing
edges may have labels other than T, that labels other
than T may occur at at most one end point, that no
two outgoing edges from the same node may have the
same label, and that any term of the form (a : 1) is
equivalent to .1, and so inconsistent.
Now we define a logical extended feature structure
(LoXF) to be an extended feature structure (N,K)
in which K = Mod(41) for some consistent finite
set 4&apos; of feature terms. In particular, Mod(4&apos;) must
have a least model. We also denote this pair by
.7*(41) = (N+, Mod(4))). Now Y(4&apos;1) C. F(4&apos;2) re-
duces to Mod(4&apos;2) C Mod(4/2 ), and
</bodyText>
<equation confidence="0.835046">
.7-(4), ) u, F(4&apos;2) =
{ F(411 U 4,2) if Mod(ll&apos; U 4&apos;2)
</equation>
<bodyText confidence="0.771527">
has a least element under C;
undefined otherwise.
</bodyText>
<subsectionHeader confidence="0.918817">
2.3 Remark on negation A full discussion of the
</subsectionHeader>
<bodyText confidence="0.999896666666667">
nature of negation in LoXF&apos;s is complex, and will be
the focus of a separate paper. However, because this
topic has received a great deal of attention (Moshier
and Rounds, 1987), (Langholm, 1989), (Dawar and
Vijay-Shanker, 1990), we feel it essential to remark
here that F(l)) does not have the &amp;quot;classical&amp;quot; nega-
tion semantics which can be determined by looking
solely at the least element. Indeed, the appropriate
definition is that F(t)) satisfies precisely when no
member of Mod(4&apos;) satisfies co; in other words, the
structure N. is not allowed to be extended to satisfy
(P.
</bodyText>
<subsectionHeader confidence="0.944083">
2.4 Unification algorithms for logical ex-
</subsectionHeader>
<bodyText confidence="0.9996828">
tended feature structures In view of the defini-
tion immediately above, it is easy to see that that any
unification algorithm for LoXF&amp;quot;s must solve the fol-
lowing two problems in the course of attempting to
unify .F(4&apos;1) and .F(4&apos;2).
</bodyText>
<listItem confidence="0.928752666666667">
(u1) It must decide whether or not 411 U 4&apos;2 is consis-
tent; i.e., whether or not there is a feature struc-
ture satisfying all sentences of both 401 and 4&apos;2.
(u2) In case that cloi U4&apos;2 is satisfiable, it must also de-
termine if there is a least model, and if so, identify
it.
</listItem>
<bodyText confidence="0.997017363636363">
Now it is well known that (Ul) is an NP-complete
problem, even if we disallow negation and path equiva-
lence (Rounds and Kasper, 1986, Thm. 4). Therefore,
barring the eventuality that P = NP, we cannot ex-
pect to allow Os and 4&apos;2 to be arbitrary finite sets of
feature terms and still have a tractable algorithm for
unification. One solution, which has been taken by a
number of authors, such as Kasper (1989) and Eisele
and Dorre (1988), is to devise clever algorithms which
apply to the general case and appear empirically to
work well on &amp;quot;typical&amp;quot; inputs, but still are provably
</bodyText>
<figure confidence="0.99187">
For Semantics
1
(a : a)
/3)
</figure>
<bodyText confidence="0.9804925">
The identically true term.
The identically false term.
The path (nesting of attributes) a exists
and terminates with label a.
The paths a and 13 have a common end
point (coalesced end points).
- 34 -
exponential in the worst case. While such work is un-
deniably of great value, we here propose a companion
strategy; namely, we restrict attention to pairs (N, 4&apos;)
such that the very nature of tlo guarantees a tractable
algorithm.
</bodyText>
<sectionHeader confidence="0.9759" genericHeader="method">
3. HORN FEATURE LOGIC
</sectionHeader>
<bodyText confidence="0.976524368421053">
In the field of mathematical logic in general, and
in the computational logic relevant to computer sci-
ence in particular, Horn clauses play a very special role
(Makowsky, 1987). Indeed, they form the basis for the
programming language Prolog (Sterling and Shapiro,
1986) and the database language Datalog (Geri et at.,
1989). This is due to the fact that while they possess
substantial representational power, tractable inference
algorithms are well known. It is perhaps the main the-
sis of this work that the utility of llorn clauses carries
over to computational linguistics as well.
3.1 Horn feature clauses A feature literal is ei-
ther an atomic feature term (e.g., (a : a), (a x 19),
or 1.) or its negation. A feature clause is a finite
disjunction ti vf2v vt,„ of feature literals. A fea-
ture clause is Horn if at most one of the i&apos;s&apos;s is not
negated. A Horn extended feature structure (HoXF)
is a LoXF ./(4&apos;) such that 4&apos; is a finite set of Horn
feature clauses.
</bodyText>
<subsectionHeader confidence="0.999343">
3.2 A taxonomy of Horn feature clauses Be-
</subsectionHeader>
<bodyText confidence="0.949986275">
fore moving on to a presentation of algorithms on
lIoXF&apos;s, it is appropriate to provide a brief sketch of
the utility and limits of restricting our attention to col-
lections of Horn clauses. Implication here is classical;
as in the case of ordinary propositional logic, we use
the notation a1na2A nam p to denote the clause
-teri v-,a2V v-v:rnavp. Horn feature clauses may then
be thought of as falling into one of the following four
categories.
(111) A clause of the form a, consisting of a single
positive literal, is just a fact.
(II2) A clause of the form consisting of a single
negative literal, is a negated fact. In terms of
11oXF&apos;s, if --qx E 4&apos;, this means that within 1(4&apos;),
no extension of N. in which a is true is permit-
ted. As a concrete example, a constraint stating
that a subject may not have an attribute named
&amp;quot;tense&amp;quot; would be of this form.
(H3) A clause of the form aim:72 ... ani p is called a
rule or an implication. Numerous examples of the
utility of implication in linguistics are identified in
(Wedekind, 1990, Sec. 1.3). Kasper&apos;s conditional
descriptions (Kasper, 1988) are also a form of im-
plication. More concretely, the requirement that
a transitive verb requires a direct object is easily
expressed in this form.
(114) A clause of the form ai nay% .. .Aam I is
called a compound negation. The formalization
of the constraint that a verb cannot be both in-
transitive and take a direct object is an example
of the use of such a clause.
The type of knowledge which is not recapturable using
Horn feature logic is positive disjunction; i.e., formu-
las of the form cri vcr2, with both cri and a2 feature
terms. Of course, this has nothing in particular to
do with feature-term logic, but is well-known limita-
tion of Horn clauses in general. However, in accepting
this limitation, we also obtain many key properties,
including tractable inference and the following impor-
tant property of genericity.
</bodyText>
<subsectionHeader confidence="0.968144">
3.3 Totally generic LoXF&apos;s Let now 4&apos; be any
</subsectionHeader>
<bodyText confidence="0.99673525">
finite set of feature terms. We say that (II is totally
generic if, for any set ‘11 of facts (see (H1) above),
if Mod(l) U 4i) is nonempty then it contains a least
element under C. Intuitively, if we use to define
the LoXF 1(4&apos;), total genericity says that however
we extend the base feature structure N* (consistently
with 4&apos;), we will continue to have a LoXF. Remarkably,
we have the following.
</bodyText>
<listItem confidence="0.661126666666667">
3.4 Theorem A set of feature terms (1) is totally
generic if and only if it is equivalent to a set of Horn
feature clauses.
</listItem>
<bodyText confidence="0.9716405">
Proof outline: This result is essentially a translation
of (Makowsky, 1987, Thm. 1.9) to the logic of feature
structures. In words, it says that if (and only if) we
work with IloXF&apos;s, condition (u2) on page 4 becomes
superfluous (except for explicitly identifying the least
model.) 0
</bodyText>
<sectionHeader confidence="0.9998345" genericHeader="method">
4. THE EXTENDED UNIFICATION
ALGORITHM
</sectionHeader>
<bodyText confidence="0.999931142857143">
It has been shown by Dowling and Gallier (1984)
that satisfiability for finite sets of propositional Horn
formulas can be tested in time linear in the length of
the formulas. Their algorithms can easily be modified
to deliver the least model as well. Since unification
of HoXF&apos;s is essentially testing for satisfiability plus
identifying the least model (see (u1)-u(2) on the previ-
ous page), a natural approach would be to adapt one
of their algorithms. Essentially, this is what we do.
Like theirs, our algorithm is forward chaining, we start
with the facts and &amp;quot;fire&amp;quot; rules until no more can be
fired, or until a contradiction appears. However, the
adaptation is not trivial, because feature-term logic is
more expressive than propositional logic. In particu-
lar, feature-term logic contains countably many tau-
tologies which have no correlates in ordinary proposi-
tional logic. The main contribution of our algorithm
is to implicitly recapture the full semantics of these
tautologies while keeping the time complexity within
reasonable bounds. Due to space limitations, we can-
not present the full formality of the rather complex
data structures. Rather, to highlight the key features,
we step through an annotated example. We focus only
upon the special problems inherent in the extension
to feature-term logic, and assume familiarity with the
forward-chaining algorithm in (Dowling and Gallier,
1984) and the graph unification algorithm in (Colban,
1990).
</bodyText>
<subsectionHeader confidence="0.952504">
4.1 An example theory and extended feature
</subsectionHeader>
<bodyText confidence="0.9979555">
graphs The set E contains the following eight Horn
feature clauses.
</bodyText>
<listItem confidence="0.997206">
(6) (AA : a).
(6) (I3: a).
</listItem>
<equation confidence="0.890738714285714">
- 35 -
(6) (AA :a)A(B : a) (CCDDG : t).
(6) (A :T)A(C : T) (ABDDG : T).
(es) (AA x B)A(ABDDG : T) (ABDDEF : T).
(es) (ABDD: T)A(B : T) (CCD x ADD).
(T) (CCDD x ABDD)#. (AC : T).
(es) (ACD: T) = (ACC :1).
</equation>
<bodyText confidence="0.9966545">
Just as we may represent a set of atomic feature terms
with a feature graph, so too may we represent, in part,
a set of horn feature clauses with an extended feature
graph. Shown in Figure I below is the initial extended
feature graph for the set Z-F., representing the state of
inference before any deductions are made.
</bodyText>
<figure confidence="0.992017833333333">
a
a • • • --.- • •
• o
•
• -41.-
• --I.- • -b.
</figure>
<figureCaption confidence="0.998983">
Figure I: Initial extended feature structure for E.
</figureCaption>
<bodyText confidence="0.999215470588235">
Every path and every node label which occurs in
some literal of Z-3 is represented. The labels of all edges,
as well as all non-T node labels, are underscored, de-
noting that they are virtual, which means that they
are only possibilities for the minimal model, and not
yet actually part of it. The root node is denoted by
0, and nodes with value T are denoted with a s. Note
that paths with common virtual end labels (e.g., AA
and /1) are not coalesced; virtual nodes and edges are
never unified. As a result, the predecessors (along any
directed path) of any actual node or edge is itself ac-
tual. As inferences are made, edges and nodes become
actual (depicted by deleting underscores), and actual
nodes with common labels are ultimately coalesced.
The final extended feature graph is shown in Figure
2 below. For easier visibility, actual edges are also
highlighted with heavier lines.
</bodyText>
<figureCaption confidence="0.97583">
Figure 2: Final extended feature structure for a
</figureCaption>
<bodyText confidence="0.99994">
If we delete the remaining virtual nodes and edges,
we obtain the graphical representation of the least
model of E.
</bodyText>
<subsectionHeader confidence="0.957489">
4.2 Computing the minimal model of the ex-
</subsectionHeader>
<bodyText confidence="0.999299692307692">
ample Now let us consider the process of actually
obtaining the structure of Figure 2 from a In the
propositional forward chaining approach, we start by
pooling the facts that we know — in this case
We then look for rules whose left-hand sides have been
satisfied. In the example, the left-hand side of3 is sat-
isfied, so we may fire that rule and add (CCDDG : t)
to our list of known facts, exactly as in the proposi-
tional case. We may also conclude that (AA x B),
because both are actual paths which terminate with
the same label a, and non-T labels are unique. The
representative extended feature graph at this point is
shown in Figure 3 below.
</bodyText>
<figureCaption confidence="0.997783">
Figure 3: Intermediate structure for E.
</figureCaption>
<bodyText confidence="0.99619225">
There are other things which we may implicitly con-
clude, and which we must conclude to fire the other
rules. For example, we may fire rule e4 at this point,
because (AA : a) (A : T) and (B : a) (B : T)
are both tautologies in the logic of feature terms, and
so its left-hand side is satisfied. Thus, we may add
(ABDDG : T) to our list of known facts. Similarly,
since, as noted above, (AA x B) holds, we may fire
rule t5 to conclude (ABDDEF : T). Likewise, we
may now fire rule 6 and conclude (CCD ADD).
The representative extended graph structure at this
point is shown in Figure 4 below.
</bodyText>
<figure confidence="0.9978968">
A
a• ---o- • --o- ----o- •
\E
• —o- •
•
</figure>
<figureCaption confidence="0.999981">
Figure 4: Intermediate structure for E.
</figureCaption>
<bodyText confidence="0.999985">
We must eventually invoke a unification at the com-
mon end point of CCD and ADD. Such unification
implicitly entails the tautology (CCD x ADD)
(CCDD ABDD) and permits us to conclude that
rule t7 should fire and add (AC: T) to the set of facts
of the least model. The result represented by the final
extended feature graph of Figure 2. Note that rule 4.8
never fires, and that there are virtual edges and nodes
left at the conclusion of the process.
</bodyText>
<subsectionHeader confidence="0.980346">
4.3 A taxonomy of implicit rules for sets of
</subsectionHeader>
<bodyText confidence="0.994636875">
Horn feature clauses As we remarked in the in-
troduction to this section, to correctly adapt forward
chaining to the context of 11oXF&apos;s, we must implicitly
include the semantics of countably many tautologies.
These fall into three classes.
(ii) Whenever an atomic term of the form (aft : a)
is determined to be true (c0 denotes the concate-
nation of a and fi), and another term of the form
</bodyText>
<figure confidence="0.898762">
•
• —o-
o • —0- • —0- 2
•
—0- • • - • ---,- •
•
•
• —o- • ----o- • —o-
- 36 -
</figure>
<bodyText confidence="0.926267428571429">
: T) occurs as an antecedent of a horn feature
clause, (with either ft not the empty string or else
a T), we must be able to automatically make
the deduction of the tautology (a() : a) = (a : T)
to conclude that (a : T) is now true. We call this
node and path subsumption. In computing the least
model of E, the deductions (A fl : a) (A : T) and
(B : a) = (B : T) are examples of such rules.
(i2) Whenever we deduce two terms of the form (a : a)
and (fi : a) to be true, with a T, we must implic-
itly realize the semantics of the rule (a :
a) = (a x fl), due to the constraint that non-
T labels are unique. We call this label matching.
In computing the least model of E, the deduction
</bodyText>
<equation confidence="0.685428">
(AA : a)A(B : a) (AA x B) is a specific example.
</equation>
<bodyText confidence="0.694660833333333">
(13) Whenever we coalesce two paths, we must per-
form local unification on the subgraph rooted at the
point of coalescence. More precisely, if we coalesce
the paths a and fl, and the atom (ay : a) is true, we
must deduce that both (ay x fly) and (fly: a) are
true; i.e., we must implicitly realize the compound
</bodyText>
<listItem confidence="0.603286">
rule (a x MA(a-y : a) (ay x fl-y)A(f/y : a). This
is just a logical representation of local unification. In
computing the least model of E, a specific example
is the deduction (CCD x AB D)A(CCDDG : t)
(CCDDG ABDDG)A(ABDDG : I).
4.4 Data structures To support these inferences,
several specific data structures are supported. They
are sketched below.
</listItem>
<bodyText confidence="0.988405615384615">
(dl) There is the list of clauses. Each clause has a
counter associated with it, indicating the number of
literals which remain to be fired before its left-hand
side is satisfied. When this count drops to zero, the
clause fires and its consequent becomes true.
012) There is a list of atoms which occur in the an-
tecedents of clauses. With each literal is associated
a set of pointers, one to each clause of which it is
an antecedent literal. When an atom becomes true,
the appropriate clauses are notified, so they may
decrement their counters.
(d3) The working extended feature structure, as illus-
trated in Figures 1-4, is maintained throughout.
</bodyText>
<listItem confidence="0.960153727272727">
(d4) For each node in the working extended feature
structure, a list of atoms is maintained. If the node
label is a, then each such atom in the list is of the
form (a : a), with a a path from the root node to the
node under consideration. When that node becomes
actual, that atom is notified that is is now satisfied.
(d5) For each non-T node label a which occurs in
some atom, a list of all virtual nodes with that la-
bel is maintained. When one such node becomes
actual, the other are checked to see if an inference
of the form (i2) should be made.
</listItem>
<bodyText confidence="0.97500225862069">
(d6) For each atom of the fo:m (a x /3) occurring
as an antecedent in sonic clause, the nodes at the
ends of these paths in the working extended feature
structure are endowed with a common tag. When-
ever nodes are coalesced, a check for such common
tags is made, so the appropriate atom may he noti-
fied that it is now true.
4.5 Independent processes and unification
The algorithm also maintains a ready queue of avail-
able processes. These processes are of three types.
A process of the form Actual(a : a), when exe-
cuted, makes the identified path and label actual in
the extended feature graph. A process of the form
Coalesce(ni , n2) coalesces the end points of the two
nodes nm and na in the extended feature graph. A pro-
cess of the form Unify(n) performs a local unification
at the subgraph rooted at node n, using an algorithm
such as identified in (Colban, 1990). All processes in
the ready queue commute; they may be executed in
any order.
To unify two distinct sets of terms (perhaps gener-
ated by independent parts of a parser), we join their
two extended feature graphs at the root, merge the
corresponding data structures, and add the command
Unify(root) to the merged process queue. In other
words, we perform a unification to match common in-
formation, and then continue with the inference pro-
cess.
4.6 The complexity of the unification algo-
rithm Define the length of a literal to be the number
of attribute name and attribute value occurrences in
it. Thus, for example, length((AB x CD)) = 4 and
leugth((ABCD : a)) = 5. For a set 4) of horn feature
clauses, we further define the following quantities.
L = The length of 4); i.e., the sum of the lengths of
all literals occurring in 40.
P = The number of distinct terms of the form (a x
fl) which occur as the right-hand side of a rule in 4).
(Facts are not considered to be rules here.)
m = The number of distinct attributes in the in-
put. (If we collect all of the literals occurring in
the clauses of 4) and discard any negation to yield a
large pool of facts, then m is the number of edges in
the graph representing the associated feature struc-
ture. If 4) is a set of positive literals to begin with,
and hence represents an ordinary feature structure,
then m represents the size of this feature structure.)
We then have the following theorem.
4.7 Theorem The worst-case time complexity
of our HoXF unification algorithm is 0(L
(P +1) • m w(m)), where co(m) is an inverse Acker-
mann function (which grows more slowly than than
any primitive recursive function — for all practical pur-
poses w(n) &lt; 5). 0
This may be compared to the worst-case complex-
ity of the usual algorithm for unifying ordinary feature
structures, which is 0(m•w(m)). The increase in com-
plexity over this simpler case is due to two factors.
</bodyText>
<listItem confidence="0.583466142857143">
(c1) We must read the entire input; since literals may
be repeated, it is possible that L &gt; m; hence the L
term.
(c2) Each time that we deduce that two nodes must
be coalesced, we must perform a unification. This
can occur at most P times — the number of times
that a rule can assert a distinct coalescing of nodes.
</listItem>
<bodyText confidence="0.9868515">
- 37
4,8 Further remarks on the algorithm Note in
particular that there are no restrictions on where path
equivalences (e.g., (a x /3)) may occur in Horn feature
clauses. In particular, unlike (Kasper, 1988), we do
allow negated path equivalences. However, if we dis-
allow path equivalences as consequents of rules, then
the complexity of our algorithm becomes essentially
that of the traditional unification algorithm (see (c2)
above). It is primarily deducing path equivalences on
the fly which results in the additional computational
burden.
</bodyText>
<sectionHeader confidence="0.9999575" genericHeader="method">
5. CONCLUSIONS, FURTHER DIREC-
TIONS, AND PROJECT STATUS
</sectionHeader>
<bodyText confidence="0.982459863636364">
5.1 Conclusions and further directions We
have identified lloXF&apos;s as an attractive compromise
between ordinary feature structures (in which there is
no way to express constraints on growth) and full logi-
cal feature theories (for which the unification problem
is NP-complete). We view HoXF&apos;s not as the &amp;quot;best&amp;quot;
approach, but rather as a tool to be used to build
better overall unification-based grammar formalisms.
The obvious next step is to develop an integrated
framework in which HoXF&apos;s are employed to handle
negation and the disjunction arising from implication,
while other techniques handle more general disjunc-
tion and term subsumption (Smolka, 1988). Such an
optimized approach could lead to much faster overall
handling of negation and disjunction, but, further work
is clearly needed to bear this out.
5.2 Status of the project While the algorithm
has been spelled out in considerable detail, we have
just begun to build an actual implementation of the
IloXF unifier in the programming language Scheme.
We expect to complete the implementation by the
summer of 1991.
</bodyText>
<sectionHeader confidence="0.998723" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.989645364864865">
Ait-Kaci, Hassan (1984), A lattice-theoretic ap-
proach to computation based on a calculus of partially-
ordered type structures, PhD thesis, University of
Pennsylvania, Philadelphia.
Ceri, Stefano; Gottlob, Georg; and Tanca, Letizia
(1989), &amp;quot;What you always wanted to know about Dat-
alog (and never dared to ask),&amp;quot; IEEE Trans. Knowl-
edge Data Engrg., 1, 146-166.
Colban, Erik A. (1988), Simplified unification based
grammar formalisms, COSMOS Report No. 05, Uni-
versity of Oslo, Department of Mathematics.
Colban, Erik A. (1990), Unification algorithms, COS-
MOS Report No. 16, University of Oslo, Department
of Mathematics.
Damas, Luis and Varile, Giovanni B. (1989), &amp;quot;CLG:
a grammar formalism based on constraint resolution,&amp;quot;
in: Martins, Joao P. and Morgado, Ernesto M., eds.,
EPIA 89: 4th Portugese Conference on Artificial In-
telligence, Lisbon, Portugal, September 1989, Proceed-
ings, 175-186, Springer-Verlag.
Dawar, A. and Vijay-Shanker, K. (1990), &amp;quot;An in-
terpretation of negation in feature structure descrip-
tions,&amp;quot; Computational Linguistics, 16, 11-21.
Dowling, William F. and Gallier, Jean II. (1984),
&amp;quot;Linear-time algorithms for testing the satisfiability of
propositional Horn clauses,&amp;quot; J. Logic Programming, 3,
267-284.
Eisele, Andreas and Done, Jochen (1988), &amp;quot;Unifica-
tion of disjunctive feature descriptions,&amp;quot; in: Proceed-
ings of the 26th Annual Meeting of the ACL.
Fenstad, Jens Erik; Langholm, Tore; and Vestre,
Espen (1989), Representations and interpretations,
COSMOS Report No. 09, University of Oslo, Depart-
ment of Mathematics, To appear in Proceedings of the
Workshop on Computational Linguistics and Formal
Semantics, Lugano, August-September 1988.
Kasper, Robert T. (1988), &amp;quot;Conditional descriptions
in functional unification grammar,&amp;quot; in: Proceedings
of the 26th Annual Meeting of the ACL, Buffalo, 233-
240.
Kasper, Robert T. (1989), &amp;quot;A unification method for
disjunctive feature descriptions,&amp;quot; in: Proceedings of
the 25th Annual Meeting of the ACL, 235-242.
Kasper, Robert T. and Rounds, William C. (1990),
&amp;quot;The logic of unification in grammar,&amp;quot; Linguistics and
Phil., 13, 35-58.
Langholm, Tore (1989), How to say no with feature
structures, COSMOS Report No. 13, University of
Oslo, Department of Mathematics.
Makowsky, Johann A. (1987), &amp;quot;Why Horn formu-
las matter in computer science: initial structures and
generic examples,&amp;quot; J. Comput. System Sci., 34, 266-
292.
Moshier, M. Drew and Rounds, William C. (1987),
&amp;quot;A logic for partially specified data structures,&amp;quot; in:
Conference Record of the 14th Annual ACM POPL
Symposium, 155-167.
Rounds, William C. and Kasper, Robert (1986), &amp;quot;A
complete logical calculus for record structures repre-
senting linguistic information,&amp;quot; in: Proceedings of the
First IEEE Symposium on Logic in Computer Science,
38-43.
Shieber, Stuart M. (1986), An Introduction to
Unification-Based Approaches to Grammar, Univer-
sity of Chicago Press.
Smolka, Gert (1988), A feature logic with sub-
sorts, LILOG-Report 33, IBM Deutschland GmbH,
Stuttgart.
Sterling, Leon and Shapiro, Ehud (1986), The Art of
Prolog, MIT Press.
Wedekind, Jürgen (1990), A survey of linguistically
motivated extensions to unification-based formalisms,
Deliverable R3,1.A, DYANA.
- 38 -
</reference>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.002386">
<title confidence="0.9935665">HORN EXTENDED FEATURE STRUCTURES: FAST UNIFICATION WITH NEGATION AND LIMITED DISJUNCTIONt</title>
<author confidence="0.999994">Stephen J IIegner</author>
<affiliation confidence="0.999334">Department of Computer Science and Electrical Engineering</affiliation>
<address confidence="0.609569">Votey Building</address>
<affiliation confidence="0.999307">University of Vermont</affiliation>
<address confidence="0.999692">Burlington, VT 05405 USA</address>
<phone confidence="0.997478">telephone: (802)656-3330</phone>
<email confidence="0.7935925">internet:hegner@uvm.eduuucp:..uunet!uvm-gen!hegner</email>
<abstract confidence="0.992939232081912">notion of a Horn feature structure introduced, which is a feature structure constrained so that its only allowable extensions are those satisfying some set of Horn clauses in featureterm logic. 11oXF&apos;s greatly generalize ordinary feature structures in admitting explicit representation of negative and implicational constraints. In contradistinction to the general case in which arbitrary logical constraints are allowed (for which the best known algorithms are exponential), there is a highly tractable algorithm for the unification of HoXF&apos;s. 1. PRELIMINARY CONCEPTS 1.1 Unification-based grammar formalisms Unification-based grammar formalisms constitute a cornerstone of many of the most important approaches to natural-language understanding (Shieber, 1986), 1988), (Fenstad 1989). The basic idea is that the parser generates a number of partial representations of the total parse, which are subsequently checked for consistency and combined by a second process known as a unifier. A common form of representation for the partial representations is that of feature are record-like data structures which are allowed to grow in three distinct ways: by adding values, by adding attributes, and by existing attributes (forcing them to be the same). The last operation may lead to cyclic structures, which we If the feature structure is an exof (i.e., Si into application of sequence of the above rules), we write .91 C say that subsumes if S1 C S2, more information than does It is easy to show that C is a partial order on the class of all feature structures. Each feature structure represents partial information generated during the parse. To obtain the total picture, these partial components must be combined t The research reported herein was performed while the author was visiting the COSMOS Computational Linguistics Group of the Mathematics Department at the University of Oslo. He wishes to thank Jens Erik Fenstad and the members of that group for providing a stimulating research environment. thanks are due Tore Langholm for invaluable discussions regarding the interplay of logic, feature structures, and unification. into one consistent piece of knowledge. The formal of precisely this operation of com- The general unifier (mgu) S1 U structures Si and the least feature struc- (under C) which is larger than both and an mgu exists if and only if and are conis, if and only if they subsume a common feature structure. algorithms and this paper the idea of a most unifier is a pleasing theoretical notion, its real utility rest with the fact that there are efficient algorithms for its computation. The fastest known algorithm, identified by Ait-Kaci (1984), runs in time which is, for all practical purposes, linear in the size of the input (i.e., the combined sizes of the structures to be unified). In proposing any extension to the basic framework, a primary consideration must be the complexity of the ensuing unification algorithm. The principal contribution of the research summarized here is to provide an extension of ordinary feature structures, admitting negation and limited disjunction, while at the same time continuing to admit unification algorithm. Due to space limitations, we must omit substantial background material from this paper. Specifically, we assume that the reader is familiar with the notation and definitions surrounding feature structures 1986; Fenstad et as well as the traditional unification algorithm (Colban, 1990). We also have been forced to omit much detail from the description and verification of our algorithm. A full report on this work will be available in the near future. 2. UNIFICATION IN THE PRESENCE OF CONSTRAINTS feature structures every feature structure is a possibility as the ultimate output of the parsing mechanism. Typically, there are constraints which must be observed. One way of ensuring this sort of consistency is to build the checks right into the grammar, so that the feature structures generated are always legitimate substructures of the The CLO formalism (Damas and Varan of such a philosophy. In ways, this is an attractive option, because it provides a - 33. unified context for expressing all aspects of the grammar. However, this approach has the disadvantage that it limits the use of independent parsing subalgorithms whose results are subsequently unified, since the consistency checks must be performed before the feature structures are presented to the unifier. Therefore, to maintain such independence, it would be a distinct advantage if some of the constraint checking could be relegated to the unification process. To establish a formal framework in which this is possible, we must start by extending our notion of a feature structure. Following the ideas of Moshier and Langholm define an exfeature structure be a pair which is a set of feature structures and the least ekof the ordering C. (Thus, by definition, has least element, and of as the &amp;quot;current&amp;quot; feature structure, and the set all structures into which allowed to grow. We define (N1, K1) C. (N2, K2) to mean precisely that In other words, the set of all structures N2 can grow into is a subset of those which grow into. (It follows necessarily that C in this case.) Note that if we identify the ordinary structure the pair N C M)), we precisely recapture ordinary subsumption. Finally, the notion of unification associated with C. is given by Kt) /C2) =- (M,Ki /Ci a least element undefined otherwise. 2.2 Logical feature structures with conoperate on pairs of the form K) algorithmically, we must have in place an appropriate for the set are many possible choices; ours is to let it be the set of all structures satisfying a. set of sentences in a particular logic. The logic which we use is a simple modification of the lanof Rounds and Kasper also (Kasper Rounds, negation but only bipath equivalences. Specifically, an feature one of the following. In (a : a), the label a may be T, denoting a missvalue. The notation (a x borrowed from has the same semantics as of (Rounds and Kasper, (general) featerm is up from atomic feature terms and with the usual semantics. In particular, the negation we use is the classical notion; a structure satisfies (-y) if and only if it does not satisfy v. For any set 4) of feature terms, Mod(l)) the set of structures for which each 4&apos; is true. For a formal definition of satisfaction, we refer the reader to the above-cited references. Intuitively, any set of terms which defines a consistent rooted, directed graph is satisfiable. However, let us specifically remark that only nodes with no outgoing may have labels other than labels other than T may occur at at most one end point, that no two outgoing edges from the same node may have the same label, and that any term of the form (a : 1) is equivalent to .1, and so inconsistent. we define a extended feature structure be an extended feature structure which = Mod(41) some consistent finite set 4&apos; of feature terms. In particular, Mod(4&apos;) must have a least model. We also denote this pair by = Now Y(4&apos;1) C. reto ), and = F(411 if Mod(ll&apos; has a least element under C; undefined otherwise. Remark on negation A discussion of the nature of negation in LoXF&apos;s is complex, and will be the focus of a separate paper. However, because this topic has received a great deal of attention (Moshier Rounds, and feel it essential to remark here that F(l)) does not have the &amp;quot;classical&amp;quot; negation semantics which can be determined by looking solely at the least element. Indeed, the appropriate definition is that F(t)) satisfies precisely when no of satisfies co; other words, the not allowed to be extended to satisfy (P. 2.4 Unification algorithms for logical exfeature structures view of the definition immediately above, it is easy to see that that any unification algorithm for LoXF&amp;quot;s must solve the following two problems in the course of attempting to and .F(4&apos;2). (u1) It must decide whether or not 411 U 4&apos;2 is consistent; i.e., whether or not there is a feature strucsatisfying of both and 4&apos;2. (u2) In case that cloi U4&apos;2 is satisfiable, it must also determine if there is a least model, and if so, identify it. Now it is well known that (Ul) is an NP-complete problem, even if we disallow negation and path equiva- (Rounds and Kasper, 4). Therefore, the eventuality that = NP, cannot exto allow and 4&apos;2to be arbitrary finite sets of feature terms and still have a tractable algorithm for unification. One solution, which has been taken by a of authors, such as Kasper Eisele and Dorre (1988), is to devise clever algorithms which apply to the general case and appear empirically to work well on &amp;quot;typical&amp;quot; inputs, but still are provably Semantics 1 (a : a) The identically true term. The identically false term. The path (nesting of attributes) a exists and terminates with label a. paths a and a common end point (coalesced end points). exponential in the worst case. While such work is undeniably of great value, we here propose a companion namely, we restrict attention to pairs such that the very nature of tlo guarantees a tractable algorithm. FEATURE LOGIC In the field of mathematical logic in general, and in the computational logic relevant to computer science in particular, Horn clauses play a very special role (Makowsky, 1987). Indeed, they form the basis for the language and Shapiro, and the database language et at., 1989). This is due to the fact that while they possess substantial representational power, tractable inference are well known. It is perhaps thesis of this work that the utility of llorn clauses carries over to computational linguistics as well. Horn feature clauses literal eian atomic feature term (a : a), (a x 19), 1.) or its negation. A clause is a vf2v feature literals. A clause is at most one of the is not A extended feature structure (HoXF) is a LoXF ./(4&apos;) such that 4&apos; is a finite set of Horn feature clauses. A taxonomy of Horn feature clauses Before moving on to a presentation of algorithms on lIoXF&apos;s, it is appropriate to provide a brief sketch of the utility and limits of restricting our attention to collections of Horn clauses. Implication here is classical; as in the case of ordinary propositional logic, we use notation a1na2A p denote the clause Horn feature clauses may then be thought of as falling into one of the following four categories. (111) A clause of the form a, consisting of a single literal, is just fact. (II2) A clause of the form consisting of a single literal, is negated fact. terms of if 4&apos;, means that within 1(4&apos;), extension of N. in which true is permitted. As a concrete example, a constraint stating that a subject may not have an attribute named &amp;quot;tense&amp;quot; would be of this form. A clause of the form aim:72 ... p called implication. examples of the utility of implication in linguistics are identified in 1990, Sec. 1.3). Kasper&apos;s 1988) are also a form of implication. More concretely, the requirement that a transitive verb requires a direct object is easily expressed in this form. A clause of the form nay% .Aam I is compound negation. formalization of the constraint that a verb cannot be both intransitive and take a direct object is an example of the use of such a clause. The type of knowledge which is not recapturable using logic is positive disjunction; formuof the form cri with both and feature terms. Of course, this has nothing in particular to do with feature-term logic, but is well-known limitation of Horn clauses in general. However, in accepting this limitation, we also obtain many key properties, including tractable inference and the following important property of genericity. 3.3 Totally generic LoXF&apos;s Let now 4&apos; be any set of feature terms. We say that (II is for any set of facts (see (H1) above), if Mod(l) U 4i) is nonempty then it contains a least element under C. Intuitively, if we use to define LoXF 1(4&apos;), total genericity however extend the base feature structure with 4&apos;), we will continue to have a LoXF. Remarkably, we have the following. Theorem set of feature terms (1) is totally generic if and only if it is equivalent to a set of Horn feature clauses. outline: result is essentially a translation of (Makowsky, 1987, Thm. 1.9) to the logic of feature structures. In words, it says that if (and only if) we work with IloXF&apos;s, condition (u2) on page 4 becomes superfluous (except for explicitly identifying the least model.) 0 4. THE EXTENDED UNIFICATION ALGORITHM It has been shown by Dowling and Gallier (1984) that satisfiability for finite sets of propositional Horn formulas can be tested in time linear in the length of the formulas. Their algorithms can easily be modified to deliver the least model as well. Since unification HoXF&apos;s testing for satisfiability plus identifying the least model (see (u1)-u(2) on the previous page), a natural approach would be to adapt one of their algorithms. Essentially, this is what we do. theirs, our algorithm is chaining, we with the facts and &amp;quot;fire&amp;quot; rules until no more can be fired, or until a contradiction appears. However, the adaptation is not trivial, because feature-term logic is more expressive than propositional logic. In particular, feature-term logic contains countably many tautologies which have no correlates in ordinary propositional logic. The main contribution of our algorithm is to implicitly recapture the full semantics of these tautologies while keeping the time complexity within reasonable bounds. Due to space limitations, we cannot present the full formality of the rather complex data structures. Rather, to highlight the key features, we step through an annotated example. We focus only upon the special problems inherent in the extension to feature-term logic, and assume familiarity with the forward-chaining algorithm in (Dowling and Gallier, 1984) and the graph unification algorithm in (Colban, 1990). 4.1 An example theory and extended feature set E contains the following eight Horn feature clauses. a). (6) (I3: a). - 35 - (6) (AA :a)A(B : a) (CCDDG : t). (A :T)A(C : : x B)A(ABDDG : : : T) x ADD). (CCDD x ABDD)#. (AC : = :1). Just as we may represent a set of atomic feature terms a so too may we represent, in part, set of horn feature clauses with an feature in Figure I below is the initial extended graph for the set the state of inference before any deductions are made. a a • • • --.- • • • o • • -41.- --I.- Figure I: Initial extended feature structure for E. Every path and every node label which occurs in some literal of Z-3 is represented. The labels of all edges, as well as all non-T node labels, are underscored, denoting that they are virtual, which means that they are only possibilities for the minimal model, and not yet actually part of it. The root node is denoted by 0, and nodes with value T are denoted with a s. Note paths with common virtual end labels AA and /1) are not coalesced; virtual nodes and edges are never unified. As a result, the predecessors (along any directed path) of any actual node or edge is itself actual. As inferences are made, edges and nodes become actual (depicted by deleting underscores), and actual nodes with common labels are ultimately coalesced. The final extended feature graph is shown in Figure 2 below. For easier visibility, actual edges are also highlighted with heavier lines. 2: Final extended feature structure for If we delete the remaining virtual nodes and edges, we obtain the graphical representation of the least model of E. 4.2 Computing the minimal model of the exlet us consider the process of actually the structure of Figure 2 from the propositional forward chaining approach, we start by pooling the facts that we know — in this case We then look for rules whose left-hand sides have been In the example, the left-hand side is satso we may fire that rule and add : t) to our list of known facts, exactly as in the proposicase. We may also conclude that x B), because both are actual paths which terminate with the same label a, and non-T labels are unique. The representative extended feature graph at this point is shown in Figure 3 below. Figure 3: Intermediate structure for E. There are other things which we may implicitly conclude, and which we must conclude to fire the other For example, we may fire rule at this point, : a) (A : and : a) (B : T) are both tautologies in the logic of feature terms, and so its left-hand side is satisfied. Thus, we may add : to our list of known facts. Similarly, as noted above, x B) we may fire to conclude : Likewise, we now fire rule 6 and conclude ADD). The representative extended graph structure at this point is shown in Figure 4 below. A ---o- • --o- ----o- • \E • —o- • • Figure 4: Intermediate structure for E. We must eventually invoke a unification at the comend point of unification entails the tautology x ADD) ABDD) permits us to conclude that fire and add to the set of facts of the least model. The result represented by the final feature graph of Figure 2. Note that rule never fires, and that there are virtual edges and nodes left at the conclusion of the process. 4.3 A taxonomy of implicit rules for sets of feature clauses we remarked in the introduction to this section, to correctly adapt forward chaining to the context of 11oXF&apos;s, we must implicitly include the semantics of countably many tautologies. These fall into three classes. Whenever an atomic term of the form a) determined to be true the concatea and fi), and another term of the form • • —oo • —0- • —0- 2 • • • ---,- • • • —o- • ----o- • —ooccurs as an antecedent of a horn feature clause, (with either ft not the empty string or else a T), we must be able to automatically make deduction of the tautology : a) = (a : to conclude that (a : T) is now true. We call this and path In computing the least of E, the deductions fl : a) (A : and : a) = (B : are examples of such rules. (i2) Whenever we deduce two terms of the form (a : a) (fi : a) to be true, with a T, we must itly realize the semantics of the rule (a : = (a x fl), to the constraint that nonlabels are unique. We call this matching. In computing the least model of E, the deduction : a)A(B : a) (AA x B) is specific example. (13) Whenever we coalesce two paths, we must perform local unification on the subgraph rooted at the point of coalescence. More precisely, if we coalesce the paths a and fl, and the atom (ay : a) is true, we deduce that both (ay x a) are true; i.e., we must implicitly realize the compound (a x MA(a-y : a) (ay x a). This just a logical representation of unification. computing the least model of E, a specific example the deduction x AB D)A(CCDDG : t) ABDDG)A(ABDDG : 4.4 Data structures To support these inferences, several specific data structures are supported. They are sketched below. (dl) There is the list of clauses. Each clause has a counter associated with it, indicating the number of literals which remain to be fired before its left-hand side is satisfied. When this count drops to zero, the clause fires and its consequent becomes true. 012) There is a list of atoms which occur in the antecedents of clauses. With each literal is associated a set of pointers, one to each clause of which it is an antecedent literal. When an atom becomes true, the appropriate clauses are notified, so they may decrement their counters. The extended as illustrated in Figures 1-4, is maintained throughout. (d4) For each node in the working extended feature structure, a list of atoms is maintained. If the node label is a, then each such atom in the list is of the form (a : a), with a a path from the root node to the node under consideration. When that node becomes actual, that atom is notified that is is now satisfied. (d5) For each non-T node label a which occurs in some atom, a list of all virtual nodes with that label is maintained. When one such node becomes actual, the other are checked to see if an inference of the form (i2) should be made. (d6) For each atom of the fo:m (a x /3) occurring as an antecedent in sonic clause, the nodes at the ends of these paths in the working extended feature structure are endowed with a common tag. Whenever nodes are coalesced, a check for such common is made, the appropriate atom may he notified that it is now true. processes and unification algorithm also maintains ready queue available processes. These processes are of three types. A process of the form Actual(a : a), when executed, makes the identified path and label actual in the extended feature graph. A process of the form , n2) coalesces the end points of the two nodes nm and na in the extended feature graph. A process of the form Unify(n) performs a local unification at the subgraph rooted at node n, using an algorithm such as identified in (Colban, 1990). All processes in the ready queue commute; they may be executed in any order. To unify two distinct sets of terms (perhaps generated by independent parts of a parser), we join their two extended feature graphs at the root, merge the corresponding data structures, and add the command Unify(root) to the merged process queue. In other words, we perform a unification to match common information, and then continue with the inference process. 4.6 The complexity of the unification algorithm Define the length of a literal to be the number of attribute name and attribute value occurrences in Thus, for example, length((AB x = and leugth((ABCD : a)) = 5. For a set 4) of horn feature clauses, we further define the following quantities. = length of 4); sum of the lengths of all literals occurring in 40. = number of of the form (a x fl) which occur as the right-hand side of a rule in 4). (Facts are not considered to be rules here.) m = The number of distinct attributes in the input. (If we collect all of the literals occurring in the clauses of 4) and discard any negation to yield a large pool of facts, then m is the number of edges in the graph representing the associated feature structure. If 4) is a set of positive literals to begin with, and hence represents an ordinary feature structure, then m represents the size of this feature structure.) We then have the following theorem. Theorem worst-case time complexity of our HoXF unification algorithm is 0(L +1) • m w(m)), where an inverse Ackermann function (which grows more slowly than than any primitive recursive function — for all practical pur- &lt; 5). 0 This may be compared to the worst-case complexity of the usual algorithm for unifying ordinary feature which is increase in complexity over this simpler case is due to two factors. (c1) We must read the entire input; since literals may repeated, it is possible that &gt; hence the term. (c2) Each time that we deduce that two nodes must be coalesced, we must perform a unification. This occur at most — the number of times that a rule can assert a distinct coalescing of nodes. - 37 4,8 Further remarks on the algorithm Note in particular that there are no restrictions on where path (a /3)) may occur in Horn feature clauses. In particular, unlike (Kasper, 1988), we do allow negated path equivalences. However, if we disallow path equivalences as consequents of rules, then the complexity of our algorithm becomes essentially that of the traditional unification algorithm (see (c2) It is primarily equivalences on the fly which results in the additional computational burden. FURTHER DIREC- TIONS, AND PROJECT STATUS 5.1 Conclusions and further directions We have identified lloXF&apos;s as an attractive compromise between ordinary feature structures (in which there is no way to express constraints on growth) and full logical feature theories (for which the unification problem is NP-complete). We view HoXF&apos;s not as the &amp;quot;best&amp;quot; approach, but rather as a tool to be used to build better overall unification-based grammar formalisms. The obvious next step is to develop an integrated framework in which HoXF&apos;s are employed to handle negation and the disjunction arising from implication, while other techniques handle more general disjunction and term subsumption (Smolka, 1988). Such an optimized approach could lead to much faster overall handling of negation and disjunction, but, further work is clearly needed to bear this out. 5.2 Status of the project While the algorithm has been spelled out in considerable detail, we have just begun to build an actual implementation of the IloXF unifier in the programming language Scheme. We expect to complete the implementation by the summer of 1991. References Hassan (1984), A lattice-theoretic approach to computation based on a calculus of partiallyordered type structures, PhD thesis, University of</abstract>
<address confidence="0.8259195">Pennsylvania, Philadelphia. Ceri, Stefano; Gottlob, Georg; and Tanca, Letizia</address>
<note confidence="0.851392735294117">(1989), &amp;quot;What you always wanted to know about Dat- (and never dared to ask),&amp;quot; Trans. Knowl- Data Engrg., 1, Colban, Erik A. (1988), Simplified unification based grammar formalisms, COSMOS Report No. 05, University of Oslo, Department of Mathematics. Colban, Erik A. (1990), Unification algorithms, COS- MOS Report No. 16, University of Oslo, Department of Mathematics. Damas, Luis and Varile, Giovanni B. (1989), &amp;quot;CLG: a grammar formalism based on constraint resolution,&amp;quot; in: Martins, Joao P. and Morgado, Ernesto M., eds., EPIA 89: 4th Portugese Conference on Artificial Intelligence, Lisbon, Portugal, September 1989, Proceed- Springer-Verlag. Dawar, A. and Vijay-Shanker, K. (1990), &amp;quot;An interpretation of negation in feature structure descrip- Linguistics, 11-21. Dowling, William F. and Gallier, Jean II. (1984), &amp;quot;Linear-time algorithms for testing the satisfiability of Horn clauses,&amp;quot; Logic Programming, 267-284. Eisele, Andreas and Done, Jochen (1988), &amp;quot;Unificaof disjunctive feature descriptions,&amp;quot; Proceedings of the 26th Annual Meeting of the ACL. Fenstad, Jens Erik; Langholm, Tore; and Vestre, Espen (1989), Representations and interpretations, COSMOS Report No. 09, University of Oslo, Departof Mathematics, To appear Proceedings of the Workshop on Computational Linguistics and Formal Semantics, Lugano, August-September 1988. Kasper, Robert T. (1988), &amp;quot;Conditional descriptions functional unification grammar,&amp;quot; Proceedings the 26th Annual Meeting of the ACL, Buffalo, 233- 240. Kasper, Robert T. (1989), &amp;quot;A unification method for feature descriptions,&amp;quot; Proceedings of 25th Annual Meeting of the ACL, Kasper, Robert T. and Rounds, William C. (1990), logic of unification in grammar,&amp;quot; and 35-58. Langholm, Tore (1989), How to say no with feature structures, COSMOS Report No. 13, University of Oslo, Department of Mathematics. Makowsky, Johann A. (1987), &amp;quot;Why Horn formulas matter in computer science: initial structures and examples,&amp;quot; Comput. System Sci., 266- 292. Moshier, M. Drew and Rounds, William C. (1987), logic for partially specified data structures,&amp;quot; Conference Record of the 14th Annual ACM POPL Rounds, William C. and Kasper, Robert (1986), &amp;quot;A complete logical calculus for record structures reprelinguistic information,&amp;quot; Proceedings of the First IEEE Symposium on Logic in Computer Science, 38-43. Stuart M. (1986), An Approaches to University of Chicago Press. Smolka, Gert (1988), A feature logic with subsorts, LILOG-Report 33, IBM Deutschland GmbH, Stuttgart. Leon and Shapiro, Ehud (1986), Art of Press. Wedekind, Jürgen (1990), A survey of linguistically motivated extensions to unification-based formalisms, Deliverable R3,1.A, DYANA. - 38 -</note>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Hassan Ait-Kaci</author>
</authors>
<title>A lattice-theoretic approach to computation based on a calculus of partiallyordered type structures,</title>
<date>1984</date>
<tech>PhD thesis,</tech>
<institution>University of Pennsylvania,</institution>
<location>Philadelphia.</location>
<contexts>
<context position="3295" citStr="Ait-Kaci (1984)" startWordPosition="514" endWordPosition="515">ormal process of unification is precisely this operation of combination. The most general unifier (mgu) S1 U S2 of feature structures Si and S2 is the least feature structure (under C) which is larger than both S1 and S2. Such an mgu exists if and only if S1 and S2 are consistent; that is, if and only if they subsume a common feature structure. 1.2 Unification algorithms and this paper While the idea of a most general unifier is a pleasing theoretical notion, its real utility rest with the fact that there are efficient algorithms for its computation. The fastest known algorithm, identified by Ait-Kaci (1984), runs in time which is, for all practical purposes, linear in the size of the input (i.e., the combined sizes of the structures to be unified). In proposing any extension to the basic framework, a primary consideration must be the complexity of the ensuing unification algorithm. The principal contribution of the research summarized here is to provide an extension of ordinary feature structures, admitting negation and limited disjunction, while at the same time continuing to admit a provably efficient unification algorithm. Due to space limitations, we must omit substantial background material</context>
</contexts>
<marker>Ait-Kaci, 1984</marker>
<rawString>Ait-Kaci, Hassan (1984), A lattice-theoretic approach to computation based on a calculus of partiallyordered type structures, PhD thesis, University of Pennsylvania, Philadelphia.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Stefano Ceri</author>
<author>Georg Gottlob</author>
<author>Letizia Tanca</author>
</authors>
<title>What you always wanted to know about Datalog (and never dared to ask),&amp;quot;</title>
<date>1989</date>
<journal>IEEE Trans. Knowledge Data Engrg.,</journal>
<volume>1</volume>
<pages>146--166</pages>
<marker>Ceri, Gottlob, Tanca, 1989</marker>
<rawString>Ceri, Stefano; Gottlob, Georg; and Tanca, Letizia (1989), &amp;quot;What you always wanted to know about Datalog (and never dared to ask),&amp;quot; IEEE Trans. Knowledge Data Engrg., 1, 146-166.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Erik A Colban</author>
</authors>
<title>Simplified unification based grammar formalisms,</title>
<date>1988</date>
<tech>COSMOS Report No. 05,</tech>
<institution>University of Oslo, Department of Mathematics.</institution>
<contexts>
<context position="1119" citStr="Colban, 1988" startWordPosition="147" endWordPosition="148">lauses in featureterm logic. 11oXF&apos;s greatly generalize ordinary feature structures in admitting explicit representation of negative and implicational constraints. In contradistinction to the general case in which arbitrary logical constraints are allowed (for which the best known algorithms are exponential), there is a highly tractable algorithm for the unification of HoXF&apos;s. 1. PRELIMINARY CONCEPTS 1.1 Unification-based grammar formalisms Unification-based grammar formalisms constitute a cornerstone of many of the most important approaches to natural-language understanding (Shieber, 1986), (Colban, 1988), (Fenstad et al., 1989). The basic idea is that the parser generates a number of partial representations of the total parse, which are subsequently checked for consistency and combined by a second process known as a unifier. A common form of representation for the partial representations is that of feature structures, which are record-like data structures which are allowed to grow in three distinct ways: by adding missing values, by adding attributes, and by coalescing existing attributes (forcing them to be the same). The last operation may lead to cyclic structures, which we do not exclude.</context>
</contexts>
<marker>Colban, 1988</marker>
<rawString>Colban, Erik A. (1988), Simplified unification based grammar formalisms, COSMOS Report No. 05, University of Oslo, Department of Mathematics.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Erik A Colban</author>
</authors>
<title>Unification algorithms,</title>
<date>1990</date>
<tech>COSMOS Report No. 16,</tech>
<institution>University of Oslo, Department of Mathematics.</institution>
<contexts>
<context position="4132" citStr="Colban, 1990" startWordPosition="644" endWordPosition="645"> be the complexity of the ensuing unification algorithm. The principal contribution of the research summarized here is to provide an extension of ordinary feature structures, admitting negation and limited disjunction, while at the same time continuing to admit a provably efficient unification algorithm. Due to space limitations, we must omit substantial background material from this paper. Specifically, we assume that the reader is familiar with the notation and definitions surrounding feature structures (Shieber, 1986; Fenstad et at., 1989), as well as the traditional unification algorithm (Colban, 1990). We also have been forced to omit much detail from the description and verification of our algorithm. A full report on this work will be available in the near future. 2. UNIFICATION IN THE PRESENCE OF CONSTRAINTS 2.1 Constraints on feature structures Not every feature structure is a possibility as the ultimate output of the parsing mechanism. Typically, there are constraints which must be observed. One way of ensuring this sort of consistency is to build the checks right into the grammar, so that the feature structures generated are always legitimate substructures of the final output. The CLO</context>
<context position="15932" citStr="Colban, 1990" startWordPosition="2720" endWordPosition="2721">es in ordinary propositional logic. The main contribution of our algorithm is to implicitly recapture the full semantics of these tautologies while keeping the time complexity within reasonable bounds. Due to space limitations, we cannot present the full formality of the rather complex data structures. Rather, to highlight the key features, we step through an annotated example. We focus only upon the special problems inherent in the extension to feature-term logic, and assume familiarity with the forward-chaining algorithm in (Dowling and Gallier, 1984) and the graph unification algorithm in (Colban, 1990). 4.1 An example theory and extended feature graphs The set E contains the following eight Horn feature clauses. (6) (AA : a). (6) (I3: a). - 35 - (6) (AA :a)A(B : a) (CCDDG : t). (6) (A :T)A(C : T) (ABDDG : T). (es) (AA x B)A(ABDDG : T) (ABDDEF : T). (es) (ABDD: T)A(B : T) (CCD x ADD). (T) (CCDD x ABDD)#. (AC : T). (es) (ACD: T) = (ACC :1). Just as we may represent a set of atomic feature terms with a feature graph, so too may we represent, in part, a set of horn feature clauses with an extended feature graph. Shown in Figure I below is the initial extended feature graph for the set Z-F., rep</context>
<context position="23556" citStr="Colban, 1990" startWordPosition="4177" endWordPosition="4178">is made, so the appropriate atom may he notified that it is now true. 4.5 Independent processes and unification The algorithm also maintains a ready queue of available processes. These processes are of three types. A process of the form Actual(a : a), when executed, makes the identified path and label actual in the extended feature graph. A process of the form Coalesce(ni , n2) coalesces the end points of the two nodes nm and na in the extended feature graph. A process of the form Unify(n) performs a local unification at the subgraph rooted at node n, using an algorithm such as identified in (Colban, 1990). All processes in the ready queue commute; they may be executed in any order. To unify two distinct sets of terms (perhaps generated by independent parts of a parser), we join their two extended feature graphs at the root, merge the corresponding data structures, and add the command Unify(root) to the merged process queue. In other words, we perform a unification to match common information, and then continue with the inference process. 4.6 The complexity of the unification algorithm Define the length of a literal to be the number of attribute name and attribute value occurrences in it. Thus,</context>
</contexts>
<marker>Colban, 1990</marker>
<rawString>Colban, Erik A. (1990), Unification algorithms, COSMOS Report No. 16, University of Oslo, Department of Mathematics.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Luis Damas</author>
<author>Giovanni B Varile</author>
</authors>
<title>CLG: a grammar formalism based on constraint resolution,&amp;quot;</title>
<date>1989</date>
<booktitle>EPIA 89: 4th Portugese Conference on Artificial Intelligence,</booktitle>
<pages>175--186</pages>
<editor>in: Martins, Joao P. and Morgado, Ernesto M., eds.,</editor>
<publisher>Springer-Verlag.</publisher>
<location>Lisbon, Portugal,</location>
<contexts>
<context position="4767" citStr="Damas and Varile, 1989" startWordPosition="748" endWordPosition="752">ve been forced to omit much detail from the description and verification of our algorithm. A full report on this work will be available in the near future. 2. UNIFICATION IN THE PRESENCE OF CONSTRAINTS 2.1 Constraints on feature structures Not every feature structure is a possibility as the ultimate output of the parsing mechanism. Typically, there are constraints which must be observed. One way of ensuring this sort of consistency is to build the checks right into the grammar, so that the feature structures generated are always legitimate substructures of the final output. The CLO formalism (Damas and Varile, 1989) is an example of such a philosophy. In many ways, this is an attractive option, because it provides a - 33. unified context for expressing all aspects of the grammar. However, this approach has the disadvantage that it limits the use of independent parsing subalgorithms whose results are subsequently unified, since the consistency checks must be performed before the feature structures are presented to the unifier. Therefore, to maintain such independence, it would be a distinct advantage if some of the constraint checking could be relegated to the unification process. To establish a formal fr</context>
</contexts>
<marker>Damas, Varile, 1989</marker>
<rawString>Damas, Luis and Varile, Giovanni B. (1989), &amp;quot;CLG: a grammar formalism based on constraint resolution,&amp;quot; in: Martins, Joao P. and Morgado, Ernesto M., eds., EPIA 89: 4th Portugese Conference on Artificial Intelligence, Lisbon, Portugal, September 1989, Proceedings, 175-186, Springer-Verlag.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Dawar</author>
<author>K Vijay-Shanker</author>
</authors>
<title>An interpretation of negation in feature structure descriptions,&amp;quot;</title>
<date>1990</date>
<journal>Computational Linguistics,</journal>
<volume>16</volume>
<pages>11--21</pages>
<contexts>
<context position="8706" citStr="Dawar and Vijay-Shanker, 1990" startWordPosition="1468" endWordPosition="1471"> structure (N,K) in which K = Mod(41) for some consistent finite set 4&apos; of feature terms. In particular, Mod(4&apos;) must have a least model. We also denote this pair by .7*(41) = (N+, Mod(4))). Now Y(4&apos;1) C. F(4&apos;2) reduces to Mod(4&apos;2) C Mod(4/2 ), and .7-(4), ) u, F(4&apos;2) = { F(411 U 4,2) if Mod(ll&apos; U 4&apos;2) has a least element under C; undefined otherwise. 2.3 Remark on negation A full discussion of the nature of negation in LoXF&apos;s is complex, and will be the focus of a separate paper. However, because this topic has received a great deal of attention (Moshier and Rounds, 1987), (Langholm, 1989), (Dawar and Vijay-Shanker, 1990), we feel it essential to remark here that F(l)) does not have the &amp;quot;classical&amp;quot; negation semantics which can be determined by looking solely at the least element. Indeed, the appropriate definition is that F(t)) satisfies precisely when no member of Mod(4&apos;) satisfies co; in other words, the structure N. is not allowed to be extended to satisfy (P. 2.4 Unification algorithms for logical extended feature structures In view of the definition immediately above, it is easy to see that that any unification algorithm for LoXF&amp;quot;s must solve the following two problems in the course of attempting to unify</context>
</contexts>
<marker>Dawar, Vijay-Shanker, 1990</marker>
<rawString>Dawar, A. and Vijay-Shanker, K. (1990), &amp;quot;An interpretation of negation in feature structure descriptions,&amp;quot; Computational Linguistics, 16, 11-21.</rawString>
</citation>
<citation valid="true">
<authors>
<author>William F Dowling</author>
<author>Jean Gallier</author>
</authors>
<title>Linear-time algorithms for testing the satisfiability of propositional Horn clauses,&amp;quot;</title>
<date>1984</date>
<journal>J. Logic Programming,</journal>
<volume>3</volume>
<pages>267--284</pages>
<contexts>
<context position="14524" citStr="Dowling and Gallier (1984)" startWordPosition="2499" endWordPosition="2502"> we extend the base feature structure N* (consistently with 4&apos;), we will continue to have a LoXF. Remarkably, we have the following. 3.4 Theorem A set of feature terms (1) is totally generic if and only if it is equivalent to a set of Horn feature clauses. Proof outline: This result is essentially a translation of (Makowsky, 1987, Thm. 1.9) to the logic of feature structures. In words, it says that if (and only if) we work with IloXF&apos;s, condition (u2) on page 4 becomes superfluous (except for explicitly identifying the least model.) 0 4. THE EXTENDED UNIFICATION ALGORITHM It has been shown by Dowling and Gallier (1984) that satisfiability for finite sets of propositional Horn formulas can be tested in time linear in the length of the formulas. Their algorithms can easily be modified to deliver the least model as well. Since unification of HoXF&apos;s is essentially testing for satisfiability plus identifying the least model (see (u1)-u(2) on the previous page), a natural approach would be to adapt one of their algorithms. Essentially, this is what we do. Like theirs, our algorithm is forward chaining, we start with the facts and &amp;quot;fire&amp;quot; rules until no more can be fired, or until a contradiction appears. However, </context>
<context position="15878" citStr="Dowling and Gallier, 1984" startWordPosition="2710" endWordPosition="2713">rm logic contains countably many tautologies which have no correlates in ordinary propositional logic. The main contribution of our algorithm is to implicitly recapture the full semantics of these tautologies while keeping the time complexity within reasonable bounds. Due to space limitations, we cannot present the full formality of the rather complex data structures. Rather, to highlight the key features, we step through an annotated example. We focus only upon the special problems inherent in the extension to feature-term logic, and assume familiarity with the forward-chaining algorithm in (Dowling and Gallier, 1984) and the graph unification algorithm in (Colban, 1990). 4.1 An example theory and extended feature graphs The set E contains the following eight Horn feature clauses. (6) (AA : a). (6) (I3: a). - 35 - (6) (AA :a)A(B : a) (CCDDG : t). (6) (A :T)A(C : T) (ABDDG : T). (es) (AA x B)A(ABDDG : T) (ABDDEF : T). (es) (ABDD: T)A(B : T) (CCD x ADD). (T) (CCDD x ABDD)#. (AC : T). (es) (ACD: T) = (ACC :1). Just as we may represent a set of atomic feature terms with a feature graph, so too may we represent, in part, a set of horn feature clauses with an extended feature graph. Shown in Figure I below is th</context>
</contexts>
<marker>Dowling, Gallier, 1984</marker>
<rawString>Dowling, William F. and Gallier, Jean II. (1984), &amp;quot;Linear-time algorithms for testing the satisfiability of propositional Horn clauses,&amp;quot; J. Logic Programming, 3, 267-284.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Andreas Eisele</author>
<author>Jochen Done</author>
</authors>
<title>Unification of disjunctive feature descriptions,&amp;quot; in:</title>
<date>1988</date>
<booktitle>Proceedings of the 26th Annual Meeting of the ACL.</booktitle>
<marker>Eisele, Done, 1988</marker>
<rawString>Eisele, Andreas and Done, Jochen (1988), &amp;quot;Unification of disjunctive feature descriptions,&amp;quot; in: Proceedings of the 26th Annual Meeting of the ACL.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jens Erik Fenstad</author>
<author>Tore Langholm</author>
<author>Espen Vestre</author>
</authors>
<title>Representations and interpretations,</title>
<date>1989</date>
<booktitle>Proceedings of the Workshop on Computational Linguistics and Formal Semantics,</booktitle>
<tech>COSMOS Report No. 09,</tech>
<institution>University of Oslo, Department of Mathematics,</institution>
<location>Lugano, August-September</location>
<note>To appear in</note>
<contexts>
<context position="1143" citStr="Fenstad et al., 1989" startWordPosition="149" endWordPosition="152">eterm logic. 11oXF&apos;s greatly generalize ordinary feature structures in admitting explicit representation of negative and implicational constraints. In contradistinction to the general case in which arbitrary logical constraints are allowed (for which the best known algorithms are exponential), there is a highly tractable algorithm for the unification of HoXF&apos;s. 1. PRELIMINARY CONCEPTS 1.1 Unification-based grammar formalisms Unification-based grammar formalisms constitute a cornerstone of many of the most important approaches to natural-language understanding (Shieber, 1986), (Colban, 1988), (Fenstad et al., 1989). The basic idea is that the parser generates a number of partial representations of the total parse, which are subsequently checked for consistency and combined by a second process known as a unifier. A common form of representation for the partial representations is that of feature structures, which are record-like data structures which are allowed to grow in three distinct ways: by adding missing values, by adding attributes, and by coalescing existing attributes (forcing them to be the same). The last operation may lead to cyclic structures, which we do not exclude. If the feature structur</context>
</contexts>
<marker>Fenstad, Langholm, Vestre, 1989</marker>
<rawString>Fenstad, Jens Erik; Langholm, Tore; and Vestre, Espen (1989), Representations and interpretations, COSMOS Report No. 09, University of Oslo, Department of Mathematics, To appear in Proceedings of the Workshop on Computational Linguistics and Formal Semantics, Lugano, August-September 1988.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Robert T Kasper</author>
</authors>
<title>Conditional descriptions in functional unification grammar,&amp;quot; in:</title>
<date>1988</date>
<booktitle>Proceedings of the 26th Annual Meeting of the ACL,</booktitle>
<pages>233--240</pages>
<location>Buffalo,</location>
<contexts>
<context position="12763" citStr="Kasper, 1988" startWordPosition="2191" endWordPosition="2192">ting of a single positive literal, is just a fact. (II2) A clause of the form consisting of a single negative literal, is a negated fact. In terms of 11oXF&apos;s, if --qx E 4&apos;, this means that within 1(4&apos;), no extension of N. in which a is true is permitted. As a concrete example, a constraint stating that a subject may not have an attribute named &amp;quot;tense&amp;quot; would be of this form. (H3) A clause of the form aim:72 ... ani p is called a rule or an implication. Numerous examples of the utility of implication in linguistics are identified in (Wedekind, 1990, Sec. 1.3). Kasper&apos;s conditional descriptions (Kasper, 1988) are also a form of implication. More concretely, the requirement that a transitive verb requires a direct object is easily expressed in this form. (114) A clause of the form ai nay% .. .Aam I is called a compound negation. The formalization of the constraint that a verb cannot be both intransitive and take a direct object is an example of the use of such a clause. The type of knowledge which is not recapturable using Horn feature logic is positive disjunction; i.e., formulas of the form cri vcr2, with both cri and a2 feature terms. Of course, this has nothing in particular to do with feature-</context>
<context position="25984" citStr="Kasper, 1988" startWordPosition="4619" endWordPosition="4620">ch is 0(m•w(m)). The increase in complexity over this simpler case is due to two factors. (c1) We must read the entire input; since literals may be repeated, it is possible that L &gt; m; hence the L term. (c2) Each time that we deduce that two nodes must be coalesced, we must perform a unification. This can occur at most P times — the number of times that a rule can assert a distinct coalescing of nodes. - 37 4,8 Further remarks on the algorithm Note in particular that there are no restrictions on where path equivalences (e.g., (a x /3)) may occur in Horn feature clauses. In particular, unlike (Kasper, 1988), we do allow negated path equivalences. However, if we disallow path equivalences as consequents of rules, then the complexity of our algorithm becomes essentially that of the traditional unification algorithm (see (c2) above). It is primarily deducing path equivalences on the fly which results in the additional computational burden. 5. CONCLUSIONS, FURTHER DIRECTIONS, AND PROJECT STATUS 5.1 Conclusions and further directions We have identified lloXF&apos;s as an attractive compromise between ordinary feature structures (in which there is no way to express constraints on growth) and full logical f</context>
</contexts>
<marker>Kasper, 1988</marker>
<rawString>Kasper, Robert T. (1988), &amp;quot;Conditional descriptions in functional unification grammar,&amp;quot; in: Proceedings of the 26th Annual Meeting of the ACL, Buffalo, 233-240.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Robert T Kasper</author>
</authors>
<title>A unification method for disjunctive feature descriptions,&amp;quot; in:</title>
<date>1989</date>
<booktitle>Proceedings of the 25th Annual Meeting of the ACL,</booktitle>
<pages>235--242</pages>
<contexts>
<context position="10009" citStr="Kasper (1989)" startWordPosition="1704" endWordPosition="1705">ether or not there is a feature structure satisfying all sentences of both 401 and 4&apos;2. (u2) In case that cloi U4&apos;2 is satisfiable, it must also determine if there is a least model, and if so, identify it. Now it is well known that (Ul) is an NP-complete problem, even if we disallow negation and path equivalence (Rounds and Kasper, 1986, Thm. 4). Therefore, barring the eventuality that P = NP, we cannot expect to allow Os and 4&apos;2 to be arbitrary finite sets of feature terms and still have a tractable algorithm for unification. One solution, which has been taken by a number of authors, such as Kasper (1989) and Eisele and Dorre (1988), is to devise clever algorithms which apply to the general case and appear empirically to work well on &amp;quot;typical&amp;quot; inputs, but still are provably For Semantics 1 (a : a) /3) The identically true term. The identically false term. The path (nesting of attributes) a exists and terminates with label a. The paths a and 13 have a common end point (coalesced end points). - 34 - exponential in the worst case. While such work is undeniably of great value, we here propose a companion strategy; namely, we restrict attention to pairs (N, 4&apos;) such that the very nature of tlo guar</context>
</contexts>
<marker>Kasper, 1989</marker>
<rawString>Kasper, Robert T. (1989), &amp;quot;A unification method for disjunctive feature descriptions,&amp;quot; in: Proceedings of the 25th Annual Meeting of the ACL, 235-242.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Robert T Kasper</author>
<author>William C Rounds</author>
</authors>
<title>The logic of unification in grammar,&amp;quot;</title>
<date>1990</date>
<journal>Linguistics and Phil.,</journal>
<volume>13</volume>
<pages>35--58</pages>
<contexts>
<context position="6825" citStr="Kasper and Rounds, 1990" startWordPosition="1126" endWordPosition="1129">pture ordinary subsumption. Finally, the notion of unification associated with C. is given by (MI , Kt) U. (M2, /C2) =- 1 (M,Ki n /C2) if /Ci n tc2 has a least element M; undefined otherwise. 2.2 Logical feature structures with constraints To operate on pairs of the form (N, K) algorithmically, we must have in place an appropriate representation for the set K. There are many possible choices; ours is to let it be the set of all structures satisfying a. set of sentences in a particular logic. The logic which we use is a simple modification of the language of Rounds and Kasper (1986) (see also (Kasper and Rounds, 1990)) admitting negation but only binary path equivalences. Specifically, an atomic feature term is one of the following. In (a : a), the label a may be T, denoting a missing value. The notation (a x 13) is borrowed from (Langholm, 1989), and has the same semantics as {a,13) of (Rounds and Kasper, 1986). A (general) feature term is built up from atomic feature terms using the connectives A, v, and with the usual semantics. In particular, the negation we use is the classical notion; a structure satisfies (-y) if and only if it does not satisfy v. For any set 4) of feature terms, Mod(l)) denotes the</context>
</contexts>
<marker>Kasper, Rounds, 1990</marker>
<rawString>Kasper, Robert T. and Rounds, William C. (1990), &amp;quot;The logic of unification in grammar,&amp;quot; Linguistics and Phil., 13, 35-58.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Tore Langholm</author>
</authors>
<title>How to say no with feature structures,</title>
<date>1989</date>
<tech>COSMOS Report No. 13,</tech>
<institution>University of Oslo, Department of Mathematics.</institution>
<contexts>
<context position="5532" citStr="Langholm (1989)" startWordPosition="876" endWordPosition="877">s of the grammar. However, this approach has the disadvantage that it limits the use of independent parsing subalgorithms whose results are subsequently unified, since the consistency checks must be performed before the feature structures are presented to the unifier. Therefore, to maintain such independence, it would be a distinct advantage if some of the constraint checking could be relegated to the unification process. To establish a formal framework in which this is possible, we must start by extending our notion of a feature structure. Following the ideas of Moshier and Rounds (1987) and Langholm (1989), we define an extended feature structure to be a pair (N, K) in which K is a set of feature structures and N is the least ekment of K under the ordering C. (Thus, by definition, K has a least element, and K determines N.) Think of N as the &amp;quot;current&amp;quot; feature structure, and K as the set of all structures into which N is allowed to grow. We define (N1, K1) C. (N2, K2) to mean precisely that K2 C /C1. In other words, the set of all structures which N2 can grow into is a subset of those which N1 can grow into. (It follows necessarily that N1 C N2 in this case.) Note that if we identify the ordinar</context>
<context position="7058" citStr="Langholm, 1989" startWordPosition="1171" endWordPosition="1172"> operate on pairs of the form (N, K) algorithmically, we must have in place an appropriate representation for the set K. There are many possible choices; ours is to let it be the set of all structures satisfying a. set of sentences in a particular logic. The logic which we use is a simple modification of the language of Rounds and Kasper (1986) (see also (Kasper and Rounds, 1990)) admitting negation but only binary path equivalences. Specifically, an atomic feature term is one of the following. In (a : a), the label a may be T, denoting a missing value. The notation (a x 13) is borrowed from (Langholm, 1989), and has the same semantics as {a,13) of (Rounds and Kasper, 1986). A (general) feature term is built up from atomic feature terms using the connectives A, v, and with the usual semantics. In particular, the negation we use is the classical notion; a structure satisfies (-y) if and only if it does not satisfy v. For any set 4) of feature terms, Mod(l)) denotes the set of all feature structures for which each co E 4&apos; is true. For a formal definition of satisfaction, we refer the reader to the above-cited references. Intuitively, any set of terms which defines a consistent rooted, directed grap</context>
<context position="8673" citStr="Langholm, 1989" startWordPosition="1466" endWordPosition="1467">n extended feature structure (N,K) in which K = Mod(41) for some consistent finite set 4&apos; of feature terms. In particular, Mod(4&apos;) must have a least model. We also denote this pair by .7*(41) = (N+, Mod(4))). Now Y(4&apos;1) C. F(4&apos;2) reduces to Mod(4&apos;2) C Mod(4/2 ), and .7-(4), ) u, F(4&apos;2) = { F(411 U 4,2) if Mod(ll&apos; U 4&apos;2) has a least element under C; undefined otherwise. 2.3 Remark on negation A full discussion of the nature of negation in LoXF&apos;s is complex, and will be the focus of a separate paper. However, because this topic has received a great deal of attention (Moshier and Rounds, 1987), (Langholm, 1989), (Dawar and Vijay-Shanker, 1990), we feel it essential to remark here that F(l)) does not have the &amp;quot;classical&amp;quot; negation semantics which can be determined by looking solely at the least element. Indeed, the appropriate definition is that F(t)) satisfies precisely when no member of Mod(4&apos;) satisfies co; in other words, the structure N. is not allowed to be extended to satisfy (P. 2.4 Unification algorithms for logical extended feature structures In view of the definition immediately above, it is easy to see that that any unification algorithm for LoXF&amp;quot;s must solve the following two problems in </context>
</contexts>
<marker>Langholm, 1989</marker>
<rawString>Langholm, Tore (1989), How to say no with feature structures, COSMOS Report No. 13, University of Oslo, Department of Mathematics.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Johann A Makowsky</author>
</authors>
<title>Why Horn formulas matter in computer science: initial structures and generic examples,&amp;quot;</title>
<date>1987</date>
<journal>J. Comput. System Sci.,</journal>
<volume>34</volume>
<pages>266--292</pages>
<contexts>
<context position="10837" citStr="Makowsky, 1987" startWordPosition="1848" endWordPosition="1849">lly true term. The identically false term. The path (nesting of attributes) a exists and terminates with label a. The paths a and 13 have a common end point (coalesced end points). - 34 - exponential in the worst case. While such work is undeniably of great value, we here propose a companion strategy; namely, we restrict attention to pairs (N, 4&apos;) such that the very nature of tlo guarantees a tractable algorithm. 3. HORN FEATURE LOGIC In the field of mathematical logic in general, and in the computational logic relevant to computer science in particular, Horn clauses play a very special role (Makowsky, 1987). Indeed, they form the basis for the programming language Prolog (Sterling and Shapiro, 1986) and the database language Datalog (Geri et at., 1989). This is due to the fact that while they possess substantial representational power, tractable inference algorithms are well known. It is perhaps the main thesis of this work that the utility of llorn clauses carries over to computational linguistics as well. 3.1 Horn feature clauses A feature literal is either an atomic feature term (e.g., (a : a), (a x 19), or 1.) or its negation. A feature clause is a finite disjunction ti vf2v vt,„ of feature </context>
<context position="14229" citStr="Makowsky, 1987" startWordPosition="2451" endWordPosition="2452"> Let now 4&apos; be any finite set of feature terms. We say that (II is totally generic if, for any set ‘11 of facts (see (H1) above), if Mod(l) U 4i) is nonempty then it contains a least element under C. Intuitively, if we use to define the LoXF 1(4&apos;), total genericity says that however we extend the base feature structure N* (consistently with 4&apos;), we will continue to have a LoXF. Remarkably, we have the following. 3.4 Theorem A set of feature terms (1) is totally generic if and only if it is equivalent to a set of Horn feature clauses. Proof outline: This result is essentially a translation of (Makowsky, 1987, Thm. 1.9) to the logic of feature structures. In words, it says that if (and only if) we work with IloXF&apos;s, condition (u2) on page 4 becomes superfluous (except for explicitly identifying the least model.) 0 4. THE EXTENDED UNIFICATION ALGORITHM It has been shown by Dowling and Gallier (1984) that satisfiability for finite sets of propositional Horn formulas can be tested in time linear in the length of the formulas. Their algorithms can easily be modified to deliver the least model as well. Since unification of HoXF&apos;s is essentially testing for satisfiability plus identifying the least mode</context>
</contexts>
<marker>Makowsky, 1987</marker>
<rawString>Makowsky, Johann A. (1987), &amp;quot;Why Horn formulas matter in computer science: initial structures and generic examples,&amp;quot; J. Comput. System Sci., 34, 266-292.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Drew Moshier</author>
<author>William C Rounds</author>
</authors>
<title>A logic for partially specified data structures,&amp;quot; in:</title>
<date>1987</date>
<booktitle>Conference Record of the 14th Annual ACM POPL Symposium,</booktitle>
<pages>155--167</pages>
<contexts>
<context position="5512" citStr="Moshier and Rounds (1987)" startWordPosition="871" endWordPosition="874">text for expressing all aspects of the grammar. However, this approach has the disadvantage that it limits the use of independent parsing subalgorithms whose results are subsequently unified, since the consistency checks must be performed before the feature structures are presented to the unifier. Therefore, to maintain such independence, it would be a distinct advantage if some of the constraint checking could be relegated to the unification process. To establish a formal framework in which this is possible, we must start by extending our notion of a feature structure. Following the ideas of Moshier and Rounds (1987) and Langholm (1989), we define an extended feature structure to be a pair (N, K) in which K is a set of feature structures and N is the least ekment of K under the ordering C. (Thus, by definition, K has a least element, and K determines N.) Think of N as the &amp;quot;current&amp;quot; feature structure, and K as the set of all structures into which N is allowed to grow. We define (N1, K1) C. (N2, K2) to mean precisely that K2 C /C1. In other words, the set of all structures which N2 can grow into is a subset of those which N1 can grow into. (It follows necessarily that N1 C N2 in this case.) Note that if we </context>
<context position="8655" citStr="Moshier and Rounds, 1987" startWordPosition="1462" endWordPosition="1465">ure structure (LoXF) to be an extended feature structure (N,K) in which K = Mod(41) for some consistent finite set 4&apos; of feature terms. In particular, Mod(4&apos;) must have a least model. We also denote this pair by .7*(41) = (N+, Mod(4))). Now Y(4&apos;1) C. F(4&apos;2) reduces to Mod(4&apos;2) C Mod(4/2 ), and .7-(4), ) u, F(4&apos;2) = { F(411 U 4,2) if Mod(ll&apos; U 4&apos;2) has a least element under C; undefined otherwise. 2.3 Remark on negation A full discussion of the nature of negation in LoXF&apos;s is complex, and will be the focus of a separate paper. However, because this topic has received a great deal of attention (Moshier and Rounds, 1987), (Langholm, 1989), (Dawar and Vijay-Shanker, 1990), we feel it essential to remark here that F(l)) does not have the &amp;quot;classical&amp;quot; negation semantics which can be determined by looking solely at the least element. Indeed, the appropriate definition is that F(t)) satisfies precisely when no member of Mod(4&apos;) satisfies co; in other words, the structure N. is not allowed to be extended to satisfy (P. 2.4 Unification algorithms for logical extended feature structures In view of the definition immediately above, it is easy to see that that any unification algorithm for LoXF&amp;quot;s must solve the followin</context>
</contexts>
<marker>Moshier, Rounds, 1987</marker>
<rawString>Moshier, M. Drew and Rounds, William C. (1987), &amp;quot;A logic for partially specified data structures,&amp;quot; in: Conference Record of the 14th Annual ACM POPL Symposium, 155-167.</rawString>
</citation>
<citation valid="true">
<authors>
<author>William C Rounds</author>
<author>Robert Kasper</author>
</authors>
<title>A complete logical calculus for record structures representing linguistic information,&amp;quot; in:</title>
<date>1986</date>
<booktitle>Proceedings of the First IEEE Symposium on Logic in Computer Science,</booktitle>
<pages>38--43</pages>
<contexts>
<context position="6789" citStr="Rounds and Kasper (1986)" startWordPosition="1120" endWordPosition="1123">ir (N, {M N C M)), we precisely recapture ordinary subsumption. Finally, the notion of unification associated with C. is given by (MI , Kt) U. (M2, /C2) =- 1 (M,Ki n /C2) if /Ci n tc2 has a least element M; undefined otherwise. 2.2 Logical feature structures with constraints To operate on pairs of the form (N, K) algorithmically, we must have in place an appropriate representation for the set K. There are many possible choices; ours is to let it be the set of all structures satisfying a. set of sentences in a particular logic. The logic which we use is a simple modification of the language of Rounds and Kasper (1986) (see also (Kasper and Rounds, 1990)) admitting negation but only binary path equivalences. Specifically, an atomic feature term is one of the following. In (a : a), the label a may be T, denoting a missing value. The notation (a x 13) is borrowed from (Langholm, 1989), and has the same semantics as {a,13) of (Rounds and Kasper, 1986). A (general) feature term is built up from atomic feature terms using the connectives A, v, and with the usual semantics. In particular, the negation we use is the classical notion; a structure satisfies (-y) if and only if it does not satisfy v. For any set 4) o</context>
<context position="9734" citStr="Rounds and Kasper, 1986" startWordPosition="1652" endWordPosition="1655">structures In view of the definition immediately above, it is easy to see that that any unification algorithm for LoXF&amp;quot;s must solve the following two problems in the course of attempting to unify .F(4&apos;1) and .F(4&apos;2). (u1) It must decide whether or not 411 U 4&apos;2 is consistent; i.e., whether or not there is a feature structure satisfying all sentences of both 401 and 4&apos;2. (u2) In case that cloi U4&apos;2 is satisfiable, it must also determine if there is a least model, and if so, identify it. Now it is well known that (Ul) is an NP-complete problem, even if we disallow negation and path equivalence (Rounds and Kasper, 1986, Thm. 4). Therefore, barring the eventuality that P = NP, we cannot expect to allow Os and 4&apos;2 to be arbitrary finite sets of feature terms and still have a tractable algorithm for unification. One solution, which has been taken by a number of authors, such as Kasper (1989) and Eisele and Dorre (1988), is to devise clever algorithms which apply to the general case and appear empirically to work well on &amp;quot;typical&amp;quot; inputs, but still are provably For Semantics 1 (a : a) /3) The identically true term. The identically false term. The path (nesting of attributes) a exists and terminates with label a</context>
</contexts>
<marker>Rounds, Kasper, 1986</marker>
<rawString>Rounds, William C. and Kasper, Robert (1986), &amp;quot;A complete logical calculus for record structures representing linguistic information,&amp;quot; in: Proceedings of the First IEEE Symposium on Logic in Computer Science, 38-43.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Stuart M Shieber</author>
</authors>
<title>An Introduction to Unification-Based Approaches to Grammar,</title>
<date>1986</date>
<publisher>University of Chicago Press.</publisher>
<contexts>
<context position="1103" citStr="Shieber, 1986" startWordPosition="145" endWordPosition="146">ome set of Horn clauses in featureterm logic. 11oXF&apos;s greatly generalize ordinary feature structures in admitting explicit representation of negative and implicational constraints. In contradistinction to the general case in which arbitrary logical constraints are allowed (for which the best known algorithms are exponential), there is a highly tractable algorithm for the unification of HoXF&apos;s. 1. PRELIMINARY CONCEPTS 1.1 Unification-based grammar formalisms Unification-based grammar formalisms constitute a cornerstone of many of the most important approaches to natural-language understanding (Shieber, 1986), (Colban, 1988), (Fenstad et al., 1989). The basic idea is that the parser generates a number of partial representations of the total parse, which are subsequently checked for consistency and combined by a second process known as a unifier. A common form of representation for the partial representations is that of feature structures, which are record-like data structures which are allowed to grow in three distinct ways: by adding missing values, by adding attributes, and by coalescing existing attributes (forcing them to be the same). The last operation may lead to cyclic structures, which we</context>
<context position="4044" citStr="Shieber, 1986" startWordPosition="631" endWordPosition="632">nified). In proposing any extension to the basic framework, a primary consideration must be the complexity of the ensuing unification algorithm. The principal contribution of the research summarized here is to provide an extension of ordinary feature structures, admitting negation and limited disjunction, while at the same time continuing to admit a provably efficient unification algorithm. Due to space limitations, we must omit substantial background material from this paper. Specifically, we assume that the reader is familiar with the notation and definitions surrounding feature structures (Shieber, 1986; Fenstad et at., 1989), as well as the traditional unification algorithm (Colban, 1990). We also have been forced to omit much detail from the description and verification of our algorithm. A full report on this work will be available in the near future. 2. UNIFICATION IN THE PRESENCE OF CONSTRAINTS 2.1 Constraints on feature structures Not every feature structure is a possibility as the ultimate output of the parsing mechanism. Typically, there are constraints which must be observed. One way of ensuring this sort of consistency is to build the checks right into the grammar, so that the featu</context>
</contexts>
<marker>Shieber, 1986</marker>
<rawString>Shieber, Stuart M. (1986), An Introduction to Unification-Based Approaches to Grammar, University of Chicago Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Gert Smolka</author>
</authors>
<title>A feature logic with subsorts, LILOG-Report 33, IBM Deutschland GmbH,</title>
<date>1988</date>
<location>Stuttgart.</location>
<marker>Smolka, 1988</marker>
<rawString>Smolka, Gert (1988), A feature logic with subsorts, LILOG-Report 33, IBM Deutschland GmbH, Stuttgart.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Leon Sterling</author>
<author>Ehud Shapiro</author>
</authors>
<title>The Art of Prolog,</title>
<date>1986</date>
<publisher>MIT Press.</publisher>
<contexts>
<context position="10931" citStr="Sterling and Shapiro, 1986" startWordPosition="1860" endWordPosition="1863">ts and terminates with label a. The paths a and 13 have a common end point (coalesced end points). - 34 - exponential in the worst case. While such work is undeniably of great value, we here propose a companion strategy; namely, we restrict attention to pairs (N, 4&apos;) such that the very nature of tlo guarantees a tractable algorithm. 3. HORN FEATURE LOGIC In the field of mathematical logic in general, and in the computational logic relevant to computer science in particular, Horn clauses play a very special role (Makowsky, 1987). Indeed, they form the basis for the programming language Prolog (Sterling and Shapiro, 1986) and the database language Datalog (Geri et at., 1989). This is due to the fact that while they possess substantial representational power, tractable inference algorithms are well known. It is perhaps the main thesis of this work that the utility of llorn clauses carries over to computational linguistics as well. 3.1 Horn feature clauses A feature literal is either an atomic feature term (e.g., (a : a), (a x 19), or 1.) or its negation. A feature clause is a finite disjunction ti vf2v vt,„ of feature literals. A feature clause is Horn if at most one of the i&apos;s&apos;s is not negated. A Horn extended</context>
</contexts>
<marker>Sterling, Shapiro, 1986</marker>
<rawString>Sterling, Leon and Shapiro, Ehud (1986), The Art of Prolog, MIT Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jürgen Wedekind</author>
</authors>
<title>A survey of linguistically motivated extensions to unification-based formalisms,</title>
<date>1990</date>
<location>Deliverable R3,1.A, DYANA.</location>
<contexts>
<context position="12702" citStr="Wedekind, 1990" startWordPosition="2184" endWordPosition="2185">ollowing four categories. (111) A clause of the form a, consisting of a single positive literal, is just a fact. (II2) A clause of the form consisting of a single negative literal, is a negated fact. In terms of 11oXF&apos;s, if --qx E 4&apos;, this means that within 1(4&apos;), no extension of N. in which a is true is permitted. As a concrete example, a constraint stating that a subject may not have an attribute named &amp;quot;tense&amp;quot; would be of this form. (H3) A clause of the form aim:72 ... ani p is called a rule or an implication. Numerous examples of the utility of implication in linguistics are identified in (Wedekind, 1990, Sec. 1.3). Kasper&apos;s conditional descriptions (Kasper, 1988) are also a form of implication. More concretely, the requirement that a transitive verb requires a direct object is easily expressed in this form. (114) A clause of the form ai nay% .. .Aam I is called a compound negation. The formalization of the constraint that a verb cannot be both intransitive and take a direct object is an example of the use of such a clause. The type of knowledge which is not recapturable using Horn feature logic is positive disjunction; i.e., formulas of the form cri vcr2, with both cri and a2 feature terms. </context>
</contexts>
<marker>Wedekind, 1990</marker>
<rawString>Wedekind, Jürgen (1990), A survey of linguistically motivated extensions to unification-based formalisms, Deliverable R3,1.A, DYANA.</rawString>
</citation>
<citation valid="false">
<pages>38</pages>
<marker></marker>
<rawString>- 38 -</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>