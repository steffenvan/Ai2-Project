<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<title confidence="0.988571">
Two monolingual parses are better than one (synchronous parse)*
</title>
<author confidence="0.990917">
Chris Dyer
</author>
<affiliation confidence="0.998124333333333">
UMIACS Laboratory for Computational Linguistics and Information Processing
Department of Linguistics
University of Maryland, College Park, MD 20742, USA
</affiliation>
<email confidence="0.481508">
redpony AT umd.edu
</email>
<sectionHeader confidence="0.988394" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.9999105">
We describe a synchronous parsing algorithm
that is based on two successive monolingual
parses of an input sentence pair. Although
the worst-case complexity of this algorithm
is and must be O(n6) for binary SCFGs,
its average-case run-time is far better. We
demonstrate that for a number of common
synchronous parsing problems, the two-parse
algorithm substantially outperforms alterna-
tive synchronous parsing strategies, making it
efficient enough to be utilized without resort-
ing to a pruned search.
</bodyText>
<sectionHeader confidence="0.999394" genericHeader="introduction">
1 Introduction
</sectionHeader>
<bodyText confidence="0.902679142857143">
Synchronous context free grammars (SCFGs) gener-
alize monolingual context-free grammars to gener-
ate strings concurrently in pairs of languages (Lewis
and Stearns, 1968) in much the same way that fi-
nite state transducers (FSTs) generalize finite state
automata (FSAs).1 Synchronous parsing is the prob-
lem of finding the best derivation, or forest of deriva-
tions, of a source and target sentence pair (f, e) under
an SCFG, g.2 Solving this problem is necessary for
several applications, for example, optimizing how
well an SCFG translation model fits parallel train-
ing data. Wu (1997) describes a bottom-up O(n6)
synchronous parsing algorithm for ITGs, a binary
SCFG with a restricted form. For general grammars,
the situation is even worse: the problem has been
shown to be NP-hard (Satta and Peserico, 2005).
Even if we restrict ourselves to binary ITGs, the
*This work was supported in part by the GALE program of
DARPA, Contract No. HR0011-06-2-001. The author wishes
to thank Philip Rensik, Adam Lopez, Phil Blunsom, and Jason
Eisner for helpful discussions.
</bodyText>
<footnote confidence="0.99867">
1SCFGs have enjoyed a resurgence in popularity as the for-
mal basis for a number of statistical translation systems, e.g.
Chiang (2007). However, translation requires only the manipu-
lation of SCFGs using monolingual parsing algorithms.
2It is assumed that n = |f |Pz� |e|.
</footnote>
<bodyText confidence="0.999331764705883">
O(n6) run-time makes large-scale learning applica-
tions infeasible. The usual solution is to use a heuris-
tic search that avoids exploring edges that are likely
(but not guaranteed) to be low probability (Zhang et
al., 2008; Haghighi et al., 2009). In this paper, we
derive an alternative synchronous parsing algorithm
starting from a conception of parsing with SCFGs as
a composition of binary relations. This enables us
to factor the synchronous parsing problem into two
successive monolingual parses. Our algorithm runs
more efficiently than O(n6) with many grammars
(including those that required using heuristic search
with other parsers), making it possible to take ad-
vantage of synchronous parsing without developing
search heuristics; and the SCFGs are not required
to be in a normal form, making it possible to easily
parse with more complex SCFG types.
</bodyText>
<sectionHeader confidence="0.968426" genericHeader="method">
2 Synchronous parsing
</sectionHeader>
<bodyText confidence="0.966229">
Before presenting our algorithm, we review the
O(n6) synchronous parser for binary ITGs.3
</bodyText>
<subsectionHeader confidence="0.923098">
2.1 ITG synchronous parsing algorithm
</subsectionHeader>
<bodyText confidence="0.999537">
Wu (1997) describes a bottom-up synchronous pars-
ing algorithm that can be understood as a generaliza-
tion of the CKY algorithm. CKY defines a table con-
sisting of n2 cells, with each cell corresponding to a
span [i, j] in the input sentence; and the synchronous
variant defines a table in 4 dimensions, with cells
corresponding to a source span [s, t] and a target
span [u, v]. The bottom of the chart is initialized
first, and pairs of items are combined from bottom
to top. Since combining items from the n4 cells in-
volves considering two split points (one source, one
target), it is not hard to see that this algorithm runs
in time O(n6).
</bodyText>
<footnote confidence="0.591033166666667">
3Generalizing the algorithm to higher rank grammars is pos-
sible (Wu, 1997), as is converting a grammar to a weakly equiv-
alent binary form in some cases (Huang et al., 2009).
263
Human Language Technologies: The 2010 Annual Conference of the North American Chapter of the ACL, pages 263–266,
Los Angeles, California, June 2010. c�2010 Association for Computational Linguistics
</footnote>
<equation confidence="0.4088395">
rucure r ,
g prblemssince it
</equation>
<subsectionHeader confidence="0.958482">
2.2 Parsing, intersection, and composition
</subsectionHeader>
<bodyText confidence="0.952754666666667">
l
miz stastics bou
We motivate an alternative conception of the syn-
</bodyText>
<equation confidence="0.653349">
pasing whch is our focus for the
hi pp is the prbl of fidig
</equation>
<bodyText confidence="0.985987785714286">
chronous parsing problem as follows. It has long
ata In the MT li-
as been appeciated that monolingual parsing computes
io, or h fst f deriios, of
constrained de-
the inersection of an FSA and a CFG (Bar-Hillel et
a bottom-up algo-
al., 1961; van Noord, 1995). That is, if S is an FSA
g sentece pa �f e�. Tis foret
st gven a sentence
encoding some sentence s,mintersection of S with a
CFG,ug,aresults in a parse forest which contains all th ru
pralel training data In he MT lit-
and only derivations of s, that is L(S) ∩ L(G) ∈
</bodyText>
<equation confidence="0.238494">
k i also known as
{{s}, ∅}.4 Crucially for ou purposs, the resulting
constrained de-
(1997) dcbes a bottomup alg-
</equation>
<bodyText confidence="0.864361666666667">
parse forest is also itself a CFG.5 Figure 1 illus-
ructing ths forest given a sentence
trates, giving two equivalent representations of the
forest S ∩ g, once as a directedfhypergraph and once
llows It has long
as a CFG. While S ∩ G appears similar to G, the
</bodyText>
<equation confidence="0.5998025">
ssume ha � |f e |the run
mputes the intersec-
non-terminals (NTs) of the resulting CFG are a cross
-Hillel et al., 1961
product of pairs of states from S and NTs from G.6
9
v conce
S NP VP of he
DT a
stg i
NP NN
m s fo
PRN
B it It aslo
forest
NP DT NN NN tree
</equation>
<figureCaption confidence="0.9291585">
Figure 1: A CFG, G, an FSA, S, encoding a sentence, and
of synchronous trees; however,
</figureCaption>
<bodyText confidence="0.904041666666667">
two equivalent representations of the parse forest S ∩ G,
gorithm is too slow to deal with
(a) as a directed hypergraph and (b) as a CFG.
</bodyText>
<equation confidence="0.5489215">
t th h d uni
etal. 2008) uggest tic-tctoe
</equation>
<bodyText confidence="0.95452425">
When dealing with SCFGs, rather than intersec-
4L(x) denotes the set of strings generated by the gram-
mar/automaton x. In future mentions of intersection
position operations, thisowill be implicit.
</bodyText>
<footnote confidence="0.98317575">
5The forest grammar derivesionly s, but using possibly y
derivations.
6Each pair of states from the FSA corresponds to a span [i, A
inxa CKY table.
</footnote>
<bodyText confidence="0.981137037037037">
position
tion, parsing computes a related operation, composi-
tion .7 The standard MT decoding-by-parsing task
can be understood as computing the composition
of an FST,8 F, which encodes the source sentence
f with the SCFG, G, representing the translation
model. The result is the translation forest, F ◦ G,
which encodes all translations of f licensed by the
translation model. While G can generate a poten-
tially infinite set of strings in the source and target
languages, F ◦ G generates only f in the source lan-
guage (albeit with possibly infinitely many deriva-
tions), but any number of different strings in the tar-
get language. It is not hard to see that a second com-
position operation of an FST, E, encoding the target
string e with the e-side of F ◦G (again using a mono-
lingual parsing algorithm), will result in a parse for-
est that exactly derives hf, ei, which is the goal of
synchronous composition. Figure 2 shows an exam-
ple. In F ◦ G ◦ E the NTs (nodes) are the cross
product of pairs of states from E, the NTs from G,
and pairs of states in F.
Thus, synchronous parsing is the task of comput-
ing F ◦ G ◦ E. Since composition is associative, we
can compute this quantity either as (F ◦ G) ◦ E or
F ◦ (G ◦ E). Alternatively, we can use an algorithm
that performs 3-way composition directly.
</bodyText>
<subsectionHeader confidence="0.978877">
2.3 The two-parse algorithm9
</subsectionHeader>
<bodyText confidence="0.963323894736842">
The two -parse algorithm refers to performing a syn-
chronous parse by computing either (F ◦ G) ◦ E or
F ◦ (G ◦ E). Each composition operation is carried
out using a standard monolingual parsing algorithm,
such as Earley’s or CKY. In the experiments below,
since we use c-free grammars, we use a variant of
CKY for unrestricted CFGs (Chiang, 2007).
Once the first composition is done, the resulting
parse forest must be converted into a CFG repre-
sentation that the second parser can utilize. This is
straightforward to do: each node becomes a unique
non-terminal symbol, with its incoming edges cor-
responding to different ways of rewriting it. Tails
of edges are non-terminal variables in the RHS of
these rewrites. A single bottom-up traversal of the
forest is sufficient to perform the conversion. Since
Intersection is a special case offcompositionfwhere the in-
put and output labels on the transducers are identical (Mohri,
2009).
</bodyText>
<footnote confidence="0.971836666666667">
8FSTs used to represent the source and target sentences have
identical input and output labels on every transition.
9Satta (submitted) has independently derived this algorithm.
</footnote>
<figure confidence="0.989696272727273">
(b)
(a)
va
i saw
the forest
ndva
0 1 t ofis
2 3
4
�,
lp
ind h
� � �
0PRN1
is teristi ear
1V2 2DT3 3NN4
0
b e
2NP4
rs
NP1 a
0S4
1VP4
ts
i saw the forest
0NP1 1VP4
0PRN1
2DT3 3NN4
1V2 2NP4
tion
2DT3
3NN4 forest
0PRN1
1V2 saw
the
i
i
PRN
V saw
paefo
VP V NP
FG Ba
es rin
DT the
0S4
0NP1
ik
4
hm2NP
a1
VP4
re n
and com-
ossibl man
nfred
</figure>
<page confidence="0.983757">
264
</page>
<bodyText confidence="0.900272833333333">
ploy is geallyassumed to b fied,
r Figure 2: An SCFG, G, two FSAs, E and F, and two
equivalent representations of F ◦ G. The synchronous
parse forest of the pair hab, cdi with G is given under F ◦
ing has been widely used to com
ents
</bodyText>
<equation confidence="0.989947">
G ◦ E
i i
</equation>
<bodyText confidence="0.975958">
fthe Arabic sentence lngth o an
lgorithm is too slow t dal with
our parser operates more efficiently with a deter-
ost authors have poposd pruning
minized grammar, w left-factor the grammar dur-
phrasal ITG alignment task.
ing his traversal as wll.
g et al (2008) suggest
m being computed Blunsom et al
Analysis. Monolingual parsing runs in worst case
lingual parse with of one language
arsing has been widely used to com-
O(|G |· n3) time, where n is the length of the in-
er tt by th string yldd by
put beng pased and |G |is a measure of the size
statistics for a variety of machine
of the grammar (Graham et al., 1980). Since the
ls of synchronous trees however
, pruig ny de tha yid
</bodyText>
<equation confidence="0.9249135">
e algorithm is too slow o deal with
grammar term is constant for most typical parsing
t exist in the target. Haghighi et al.
applications, it is generally not considered carefully;
</equation>
<bodyText confidence="0.979726416666667">
ibe a pruning heuritic that results
most authors have propoed pruning
hng et al (2008) suggest tictatoe
however, in the two-parse algorithm, the size of the
gramar term for the second parse i
ntime of ����.
us Mdel 1 to to xlud
p
forest F ◦ G
will be O(|N |· n2). This can be shown easily since
by stipulation, we are able to use CKY+ to per-
form the parse, and there will be maximally as many
nodes in the forest as there are cells in the CKY chart
times the number of NTs. The number of edges will
be O(|N |· n3), which occurs when every node can
be derived from all possible splits. This bound on
the number of edges implies that |F ◦G |∈ O(n3).10
Therefore, the worst case run-time of the two-parse
algorithm is O(|N|·n3·n3+|G|·n3) = O(|N|·n6),
the same as the bound on the ITG algorithm. We
note that while the ITG algorithm requires that the
SCFGs be rank-2 and in a normal form, the two-
parse algorithm analysis holds as long as the gram-
mars are rank-2 and c-free.11
</bodyText>
<sectionHeader confidence="0.999674" genericHeader="method">
3 Experiments
</sectionHeader>
<bodyText confidence="0.972232972972973">
We now describe two different synchronous parsing
applications, with different classes of SCFGs, and
compare the performance of the two-parse algorithm
with that of previously used algorithms.
Phrasal ITGs. Here we compare performance of
the two-parse algorithm and the O(n6) ITG parsing
algorithm on an Arabic-English phrasal ITG align-
ment task. We used a variant of the phrasal ITG de-
scribed by Zhang et al. (2008).12 Figure 3 plots the
average run-time of the two algorithms as a function
of the Arabic sentence length. The two-parse ap-
proach is far more efficient. In total, aligning the 80k
sentence pairs in the corpus completed in less than
4 hours with the two-parse algorithm but required
more than 1 week with the baseline algorithm.13
“Hiero” grammars. An alternative approach to
computing a synchronous parse forest is based on
cube pruning (Huang and Chiang, 2007). While
more commonly used to integrate a target m-gram
LM during decoding, Blunsom et al. (2008), who re-
quired synchronous parses to discriminatively train
10How tight these bounds are depends on the ambiguity in
the grammar w.r.t. the input: to generate n3 edges, every item
in every cell must be derivable by every combination of its sub-
spans. Most grammars are substantially less ambiguous.
11Since many widely used SCFGs meet these criteria, in-
cluding hierarchical phrase-based translation grammars (Chi-
ang, 2007), SAMT grammars (Zollmann and Venugopal, 2006),
and phrasal ITGs (Zhang et al., 2008), a detailed analysis of e-
containing and higher rank grammars is left to future work.
12The restriction that phrases contain exactly a single align-
ment point was relaxed, resulting in much larger and more am-
biguous grammars than those used in the original work.
13A note on implementation: our ITG aligner was minimal; it
only computed the probability of the sentence pair using the in-
side algorithm. With the two-parse aligner, we stored the com-
plete forest during both the first and second parses.
</bodyText>
<figure confidence="0.981532196969697">
ti9
S &lt; X , X &gt;
ier s gs i
X &lt; X b , c X &gt;
w can use
, i is
oion dire
X &lt; X b , X d &gt;
F �
a b
0 1
t 2
el� p
� �
ful
FogoEneally as
a : d a : c
os
0S2
natively can use a
0X1 b : c 0X1
is commy though
0X1 b : 0X1 d
os
0X1
a : c a : d
&lt; 0X1 b , c 0X1 &gt;
E or
&lt; 0X1 b , 0X1 d &gt;
thm
&lt; a , c &gt;
n ao-
, sh
0X1 &lt;
a , d &gt;
as
0S2
0S2�
f
alg
0X1
0S2
0 2
0X1 b : c 0X1
1 2 1 2 0 1 0 1
0X1 b : 0X1 d
1 2 0 1
ev 0X1
en ng 0X1 k
ll sut i
pse or
X &lt; a , c &gt;
X &lt; a , d &gt;
e string
rives
h e
c d
0 1 2
llE
.
s not |G |but
|F ◦ G|, which clearly depends on the size of the in-
fombegpudBlso
put F; and so understanding the impact of this term
l
is keyto understanding the algorithm’s run-time.
</figure>
<bodyText confidence="0.886704230769231">
nolingual parse with of one language
ser states by the string yielded by
Mehryar Mohri 2008 3way
If G is an ~-free SCFG with non-terminals N and
vations, pruning any nodes that yield
weighted finitetate ransduces In
maximally two NTs in a rule’s right hand side, and
ot exist in th target Haghighi et al
n is the number of states in F (corresponding to the
postion algoithms tat oprate ony on
scribe a pruning heuristc tht rsults
number of words in the f in a sentence pair hf, ei),
then theenumbern of nodes in0the parse
</bodyText>
<page confidence="0.932421">
265
</page>
<figure confidence="0.998397666666667">
60 Wu (1997)
this work
40
20
0
10 20 30 40 50 60
</figure>
<figureCaption confidence="0.987916">
Figure 3: Average synchronous parser run-time (in sec-
onds) as a function of Arabic sentence length (in words).
</figureCaption>
<bodyText confidence="0.9999503">
an SCFG translation model, repurposed this algo-
rithm to discard partial derivations during transla-
tion of f if the derivation yielded a target m-gram
not found in e (p.c.). We replicated their BTEC
Chinese-English baseline system and compared the
speed of their ‘cube-parsing’ technique and our two-
parse algorithm.14 The SCFG used here was ex-
tracted from a word-aligned corpus, as described in
Chiang (2007).15 The following table compares the
average per sentence synchronous parse time.
</bodyText>
<sectionHeader confidence="0.99988" genericHeader="conclusions">
4 Discussion
</sectionHeader>
<bodyText confidence="0.9995248">
Thinking of synchronous parsing as two composi-
tion operations has both conceptual and practical
benefits. The two-parse strategy can outperform
both the ITG parsing algorithm (Wu, 1997), as well
as the ‘cube-parsing’ technique (Blunsom et al.,
2008). The latter result points to a connection with
recent work showing that determinization of edges
before LM integration leads to fewer search errors
during decoding (Iglesias et al., 2009).
Our results are somewhat surprising in light of
work showing that 3-way composition algorithms
for FSTs operate far more efficiently than perform-
ing successive pairwise compositions (Allauzen and
Mohri, 2009). This is certainly because the 3-way
algorithm used here (the ITG algorithm) does an ex-
14To the extent possible, the two experiments were carried
out using the exact same code base, which was a C++ imple-
mentation of an SCFG-based decoder.
15Because of the mix of terminal and non-terminal symbols,
such grammars cannot be used by the ITG synchronous parsing
algorithm.
haustive search over all n4 span pairs without aware-
ness of any top-down constraints. This suggests that
faster composition algorithms that incorporate top-
down filtering may still be discovered.
</bodyText>
<sectionHeader confidence="0.998473" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.998918957446809">
C. Allauzen and M. Mohri. 2009. N-way composition of
weighted finite-state transducers. International Jour-
nal of Foundations of Comp. Sci., 20(4):613–627.
Y. Bar-Hillel, M. Perles, and E. Shamir. 1961. On for-
mal properties of simple phrase structure grammars.
Zeitschriftf¨ur Phonetik, Sprachwissenschaft und Kom-
munikationsforschung, 14:143–172.
P. Blunsom, T. Cohn, and M. Osborne. 2008. Probalistic
inference for machine translation. In EMNLP.
D. Chiang. 2007. Hierarchical phrase-based translation.
Computational Linguistics, 33(2):201–228.
S. L. Graham, W. L. Ruzzo, and M. Harrison. 1980. An
improved context-free recognizer. ACM Trans. Pro-
gram. Lang. Syst., 2(3):415–462.
A. Haghighi, J. Blitzer, J. DeNero, and D. Klein. 2009.
Better word alignments with supervised ITG models.
In Proc. of ACL/IJCNLP, pages 923–931.
L. Huang and D. Chiang. 2007. Forest rescoring: Faster
decoding with integrated language models. In ACL.
L. Huang, H. Zhang, D. Gildea, and K. Knight. 2009.
Binarization of synchronous context-free grammars.
Computational Linguistics, 35(4).
G. Iglesias, A. de Gispert, E. R. Banga, and W. Byrne.
2009. Hierarchical phrase-based translation with
weighted finite state transducers. In Proc. NAACL.
P. M. Lewis, II and R. E. Stearns. 1968. Syntax-directed
transduction. J. ACM, 15(3):465–488.
M. Mohri. 2009. Weighted automata algorithms. In
M. Droste, W. Kuich, and H. Vogler, editors, Hand-
book of Weighted Automata, Monographs in Theoreti-
cal Computer Science, pages 213–254. Springer.
G. Satta and E. Peserico. 2005. Some computational
complexity results for synchronous context-free gram-
mars. In Proceedings of NAACL.
G. Satta. submitted. Translation algorithms by means of
language intersection.
G. van Noord. 1995. The intersection of finite state au-
tomata and definite clause grammars. In Proc. ofACL.
D. Wu. 1997. Stochastic inversion transduction gram-
mars and bilingual parsing of parallel corpora. Com-
putational Linguistics, 23(3):377–404.
H. Zhang, C. Quirk, R. C. Moore, and D. Gildea. 2008.
Bayesian learning of non-compositional phrases with
synchronous parsing. In Proceedings of ACL.
A. Zollmann and A. Venugopal. 2006. Syntax aug-
mented machine translation via chart parsing. In Proc.
of the Workshop on SMT.
</reference>
<figure confidence="0.9976905">
Algorithm
avg. run-time (sec)
Blunsom et al. (2008)
this work
7.31
0.20
</figure>
<page confidence="0.978613">
266
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.740816">
<title confidence="0.985767">monolingual parses are better than one (synchronous</title>
<author confidence="0.965481">Chris</author>
<affiliation confidence="0.936983333333333">UMIACS Laboratory for Computational Linguistics and Information Department of University of Maryland, College Park, MD 20742,</affiliation>
<email confidence="0.988831">redponyATumd.edu</email>
<abstract confidence="0.995083230769231">We describe a synchronous parsing algorithm is based on two successive parses of an input sentence pair. Although the worst-case complexity of this algorithm and must be binary SCFGs, its average-case run-time is far better. We demonstrate that for a number of common synchronous parsing problems, the two-parse algorithm substantially outperforms alternative synchronous parsing strategies, making it efficient enough to be utilized without resorting to a pruned search.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>C Allauzen</author>
<author>M Mohri</author>
</authors>
<title>N-way composition of weighted finite-state transducers.</title>
<date>2009</date>
<journal>International Journal of Foundations of Comp. Sci.,</journal>
<volume>20</volume>
<issue>4</issue>
<marker>Allauzen, Mohri, 2009</marker>
<rawString>C. Allauzen and M. Mohri. 2009. N-way composition of weighted finite-state transducers. International Journal of Foundations of Comp. Sci., 20(4):613–627.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Y Bar-Hillel</author>
<author>M Perles</author>
<author>E Shamir</author>
</authors>
<title>On formal properties of simple phrase structure grammars. Zeitschriftf¨ur Phonetik, Sprachwissenschaft und Kommunikationsforschung,</title>
<date>1961</date>
<pages>14--143</pages>
<marker>Bar-Hillel, Perles, Shamir, 1961</marker>
<rawString>Y. Bar-Hillel, M. Perles, and E. Shamir. 1961. On formal properties of simple phrase structure grammars. Zeitschriftf¨ur Phonetik, Sprachwissenschaft und Kommunikationsforschung, 14:143–172.</rawString>
</citation>
<citation valid="true">
<authors>
<author>P Blunsom</author>
<author>T Cohn</author>
<author>M Osborne</author>
</authors>
<title>Probalistic inference for machine translation. In</title>
<date>2008</date>
<journal>Computational Linguistics,</journal>
<volume>33</volume>
<issue>2</issue>
<contexts>
<context position="11923" citStr="Blunsom et al. (2008)" startWordPosition="2099" endWordPosition="2102">d a variant of the phrasal ITG described by Zhang et al. (2008).12 Figure 3 plots the average run-time of the two algorithms as a function of the Arabic sentence length. The two-parse approach is far more efficient. In total, aligning the 80k sentence pairs in the corpus completed in less than 4 hours with the two-parse algorithm but required more than 1 week with the baseline algorithm.13 “Hiero” grammars. An alternative approach to computing a synchronous parse forest is based on cube pruning (Huang and Chiang, 2007). While more commonly used to integrate a target m-gram LM during decoding, Blunsom et al. (2008), who required synchronous parses to discriminatively train 10How tight these bounds are depends on the ambiguity in the grammar w.r.t. the input: to generate n3 edges, every item in every cell must be derivable by every combination of its subspans. Most grammars are substantially less ambiguous. 11Since many widely used SCFGs meet these criteria, including hierarchical phrase-based translation grammars (Chiang, 2007), SAMT grammars (Zollmann and Venugopal, 2006), and phrasal ITGs (Zhang et al., 2008), a detailed analysis of econtaining and higher rank grammars is left to future work. 12The re</context>
<context position="15035" citStr="Blunsom et al., 2008" startWordPosition="2720" endWordPosition="2723">ded a target m-gram not found in e (p.c.). We replicated their BTEC Chinese-English baseline system and compared the speed of their ‘cube-parsing’ technique and our twoparse algorithm.14 The SCFG used here was extracted from a word-aligned corpus, as described in Chiang (2007).15 The following table compares the average per sentence synchronous parse time. 4 Discussion Thinking of synchronous parsing as two composition operations has both conceptual and practical benefits. The two-parse strategy can outperform both the ITG parsing algorithm (Wu, 1997), as well as the ‘cube-parsing’ technique (Blunsom et al., 2008). The latter result points to a connection with recent work showing that determinization of edges before LM integration leads to fewer search errors during decoding (Iglesias et al., 2009). Our results are somewhat surprising in light of work showing that 3-way composition algorithms for FSTs operate far more efficiently than performing successive pairwise compositions (Allauzen and Mohri, 2009). This is certainly because the 3-way algorithm used here (the ITG algorithm) does an ex14To the extent possible, the two experiments were carried out using the exact same code base, which was a C++ imp</context>
</contexts>
<marker>Blunsom, Cohn, Osborne, 2008</marker>
<rawString>P. Blunsom, T. Cohn, and M. Osborne. 2008. Probalistic inference for machine translation. In EMNLP. D. Chiang. 2007. Hierarchical phrase-based translation. Computational Linguistics, 33(2):201–228.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S L Graham</author>
<author>W L Ruzzo</author>
<author>M Harrison</author>
</authors>
<title>An improved context-free recognizer.</title>
<date>1980</date>
<journal>ACM Trans. Program. Lang. Syst.,</journal>
<volume>2</volume>
<issue>3</issue>
<contexts>
<context position="9716" citStr="Graham et al., 1980" startWordPosition="1710" endWordPosition="1713"> E i i fthe Arabic sentence lngth o an lgorithm is too slow t dal with our parser operates more efficiently with a deterost authors have poposd pruning minized grammar, w left-factor the grammar durphrasal ITG alignment task. ing his traversal as wll. g et al (2008) suggest m being computed Blunsom et al Analysis. Monolingual parsing runs in worst case lingual parse with of one language arsing has been widely used to comO(|G |· n3) time, where n is the length of the iner tt by th string yldd by put beng pased and |G |is a measure of the size statistics for a variety of machine of the grammar (Graham et al., 1980). Since the ls of synchronous trees however , pruig ny de tha yid e algorithm is too slow o deal with grammar term is constant for most typical parsing t exist in the target. Haghighi et al. applications, it is generally not considered carefully; ibe a pruning heuritic that results most authors have propoed pruning hng et al (2008) suggest tictatoe however, in the two-parse algorithm, the size of the gramar term for the second parse i ntime of ����. us Mdel 1 to to xlud p forest F ◦ G will be O(|N |· n2). This can be shown easily since by stipulation, we are able to use CKY+ to perform the par</context>
</contexts>
<marker>Graham, Ruzzo, Harrison, 1980</marker>
<rawString>S. L. Graham, W. L. Ruzzo, and M. Harrison. 1980. An improved context-free recognizer. ACM Trans. Program. Lang. Syst., 2(3):415–462.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Haghighi</author>
<author>J Blitzer</author>
<author>J DeNero</author>
<author>D Klein</author>
</authors>
<title>Better word alignments with supervised ITG models.</title>
<date>2009</date>
<booktitle>In Proc. of ACL/IJCNLP,</booktitle>
<pages>923--931</pages>
<contexts>
<context position="2351" citStr="Haghighi et al., 2009" startWordPosition="360" endWordPosition="363">uthor wishes to thank Philip Rensik, Adam Lopez, Phil Blunsom, and Jason Eisner for helpful discussions. 1SCFGs have enjoyed a resurgence in popularity as the formal basis for a number of statistical translation systems, e.g. Chiang (2007). However, translation requires only the manipulation of SCFGs using monolingual parsing algorithms. 2It is assumed that n = |f |Pz� |e|. O(n6) run-time makes large-scale learning applications infeasible. The usual solution is to use a heuristic search that avoids exploring edges that are likely (but not guaranteed) to be low probability (Zhang et al., 2008; Haghighi et al., 2009). In this paper, we derive an alternative synchronous parsing algorithm starting from a conception of parsing with SCFGs as a composition of binary relations. This enables us to factor the synchronous parsing problem into two successive monolingual parses. Our algorithm runs more efficiently than O(n6) with many grammars (including those that required using heuristic search with other parsers), making it possible to take advantage of synchronous parsing without developing search heuristics; and the SCFGs are not required to be in a normal form, making it possible to easily parse with more comp</context>
</contexts>
<marker>Haghighi, Blitzer, DeNero, Klein, 2009</marker>
<rawString>A. Haghighi, J. Blitzer, J. DeNero, and D. Klein. 2009. Better word alignments with supervised ITG models. In Proc. of ACL/IJCNLP, pages 923–931.</rawString>
</citation>
<citation valid="true">
<authors>
<author>L Huang</author>
<author>D Chiang</author>
</authors>
<title>Forest rescoring: Faster decoding with integrated language models.</title>
<date>2007</date>
<booktitle>In ACL.</booktitle>
<contexts>
<context position="11826" citStr="Huang and Chiang, 2007" startWordPosition="2083" endWordPosition="2086">gorithm and the O(n6) ITG parsing algorithm on an Arabic-English phrasal ITG alignment task. We used a variant of the phrasal ITG described by Zhang et al. (2008).12 Figure 3 plots the average run-time of the two algorithms as a function of the Arabic sentence length. The two-parse approach is far more efficient. In total, aligning the 80k sentence pairs in the corpus completed in less than 4 hours with the two-parse algorithm but required more than 1 week with the baseline algorithm.13 “Hiero” grammars. An alternative approach to computing a synchronous parse forest is based on cube pruning (Huang and Chiang, 2007). While more commonly used to integrate a target m-gram LM during decoding, Blunsom et al. (2008), who required synchronous parses to discriminatively train 10How tight these bounds are depends on the ambiguity in the grammar w.r.t. the input: to generate n3 edges, every item in every cell must be derivable by every combination of its subspans. Most grammars are substantially less ambiguous. 11Since many widely used SCFGs meet these criteria, including hierarchical phrase-based translation grammars (Chiang, 2007), SAMT grammars (Zollmann and Venugopal, 2006), and phrasal ITGs (Zhang et al., 20</context>
</contexts>
<marker>Huang, Chiang, 2007</marker>
<rawString>L. Huang and D. Chiang. 2007. Forest rescoring: Faster decoding with integrated language models. In ACL.</rawString>
</citation>
<citation valid="true">
<authors>
<author>L Huang</author>
<author>H Zhang</author>
<author>D Gildea</author>
<author>K Knight</author>
</authors>
<title>Binarization of synchronous context-free grammars.</title>
<date>2009</date>
<journal>Computational Linguistics,</journal>
<volume>35</volume>
<issue>4</issue>
<contexts>
<context position="3929" citStr="Huang et al., 2009" startWordPosition="623" endWordPosition="626">onding to a span [i, j] in the input sentence; and the synchronous variant defines a table in 4 dimensions, with cells corresponding to a source span [s, t] and a target span [u, v]. The bottom of the chart is initialized first, and pairs of items are combined from bottom to top. Since combining items from the n4 cells involves considering two split points (one source, one target), it is not hard to see that this algorithm runs in time O(n6). 3Generalizing the algorithm to higher rank grammars is possible (Wu, 1997), as is converting a grammar to a weakly equivalent binary form in some cases (Huang et al., 2009). 263 Human Language Technologies: The 2010 Annual Conference of the North American Chapter of the ACL, pages 263–266, Los Angeles, California, June 2010. c�2010 Association for Computational Linguistics rucure r , g prblemssince it 2.2 Parsing, intersection, and composition l miz stastics bou We motivate an alternative conception of the synpasing whch is our focus for the hi pp is the prbl of fidig chronous parsing problem as follows. It has long ata In the MT lias been appeciated that monolingual parsing computes io, or h fst f deriios, of constrained dethe inersection of an FSA and a CFG (B</context>
</contexts>
<marker>Huang, Zhang, Gildea, Knight, 2009</marker>
<rawString>L. Huang, H. Zhang, D. Gildea, and K. Knight. 2009. Binarization of synchronous context-free grammars. Computational Linguistics, 35(4).</rawString>
</citation>
<citation valid="true">
<authors>
<author>G Iglesias</author>
<author>A de Gispert</author>
<author>E R Banga</author>
<author>W Byrne</author>
</authors>
<title>Hierarchical phrase-based translation with weighted finite state transducers. In</title>
<date>2009</date>
<booktitle>Proc. NAACL.</booktitle>
<marker>Iglesias, de Gispert, Banga, Byrne, 2009</marker>
<rawString>G. Iglesias, A. de Gispert, E. R. Banga, and W. Byrne. 2009. Hierarchical phrase-based translation with weighted finite state transducers. In Proc. NAACL.</rawString>
</citation>
<citation valid="true">
<authors>
<author>P M Lewis</author>
<author>R E Stearns</author>
</authors>
<title>Syntax-directed transduction.</title>
<date>1968</date>
<journal>J. ACM,</journal>
<volume>15</volume>
<issue>3</issue>
<contexts>
<context position="940" citStr="Lewis and Stearns, 1968" startWordPosition="130" endWordPosition="133"> two successive monolingual parses of an input sentence pair. Although the worst-case complexity of this algorithm is and must be O(n6) for binary SCFGs, its average-case run-time is far better. We demonstrate that for a number of common synchronous parsing problems, the two-parse algorithm substantially outperforms alternative synchronous parsing strategies, making it efficient enough to be utilized without resorting to a pruned search. 1 Introduction Synchronous context free grammars (SCFGs) generalize monolingual context-free grammars to generate strings concurrently in pairs of languages (Lewis and Stearns, 1968) in much the same way that finite state transducers (FSTs) generalize finite state automata (FSAs).1 Synchronous parsing is the problem of finding the best derivation, or forest of derivations, of a source and target sentence pair (f, e) under an SCFG, g.2 Solving this problem is necessary for several applications, for example, optimizing how well an SCFG translation model fits parallel training data. Wu (1997) describes a bottom-up O(n6) synchronous parsing algorithm for ITGs, a binary SCFG with a restricted form. For general grammars, the situation is even worse: the problem has been shown t</context>
</contexts>
<marker>Lewis, Stearns, 1968</marker>
<rawString>P. M. Lewis, II and R. E. Stearns. 1968. Syntax-directed transduction. J. ACM, 15(3):465–488.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Mohri</author>
</authors>
<title>Weighted automata algorithms.</title>
<date>2009</date>
<booktitle>Handbook of Weighted Automata, Monographs in Theoretical Computer Science,</booktitle>
<pages>213--254</pages>
<editor>In M. Droste, W. Kuich, and H. Vogler, editors,</editor>
<publisher>Springer.</publisher>
<contexts>
<context position="8345" citStr="Mohri, 2009" startWordPosition="1429" endWordPosition="1430">tricted CFGs (Chiang, 2007). Once the first composition is done, the resulting parse forest must be converted into a CFG representation that the second parser can utilize. This is straightforward to do: each node becomes a unique non-terminal symbol, with its incoming edges corresponding to different ways of rewriting it. Tails of edges are non-terminal variables in the RHS of these rewrites. A single bottom-up traversal of the forest is sufficient to perform the conversion. Since Intersection is a special case offcompositionfwhere the input and output labels on the transducers are identical (Mohri, 2009). 8FSTs used to represent the source and target sentences have identical input and output labels on every transition. 9Satta (submitted) has independently derived this algorithm. (b) (a) va i saw the forest ndva 0 1 t ofis 2 3 4 �, lp ind h � � � 0PRN1 is teristi ear 1V2 2DT3 3NN4 0 b e 2NP4 rs NP1 a 0S4 1VP4 ts i saw the forest 0NP1 1VP4 0PRN1 2DT3 3NN4 1V2 2NP4 tion 2DT3 3NN4 forest 0PRN1 1V2 saw the i i PRN V saw paefo VP V NP FG Ba es rin DT the 0S4 0NP1 ik 4 hm2NP a1 VP4 re n and comossibl man nfred 264 ploy is geallyassumed to b fied, r Figure 2: An SCFG, G, two FSAs, E and F, and two eq</context>
</contexts>
<marker>Mohri, 2009</marker>
<rawString>M. Mohri. 2009. Weighted automata algorithms. In M. Droste, W. Kuich, and H. Vogler, editors, Handbook of Weighted Automata, Monographs in Theoretical Computer Science, pages 213–254. Springer.</rawString>
</citation>
<citation valid="true">
<authors>
<author>G Satta</author>
<author>E Peserico</author>
</authors>
<title>Some computational complexity results for synchronous context-free grammars.</title>
<date>2005</date>
<booktitle>In Proceedings of NAACL.</booktitle>
<contexts>
<context position="1579" citStr="Satta and Peserico, 2005" startWordPosition="235" endWordPosition="238">ame way that finite state transducers (FSTs) generalize finite state automata (FSAs).1 Synchronous parsing is the problem of finding the best derivation, or forest of derivations, of a source and target sentence pair (f, e) under an SCFG, g.2 Solving this problem is necessary for several applications, for example, optimizing how well an SCFG translation model fits parallel training data. Wu (1997) describes a bottom-up O(n6) synchronous parsing algorithm for ITGs, a binary SCFG with a restricted form. For general grammars, the situation is even worse: the problem has been shown to be NP-hard (Satta and Peserico, 2005). Even if we restrict ourselves to binary ITGs, the *This work was supported in part by the GALE program of DARPA, Contract No. HR0011-06-2-001. The author wishes to thank Philip Rensik, Adam Lopez, Phil Blunsom, and Jason Eisner for helpful discussions. 1SCFGs have enjoyed a resurgence in popularity as the formal basis for a number of statistical translation systems, e.g. Chiang (2007). However, translation requires only the manipulation of SCFGs using monolingual parsing algorithms. 2It is assumed that n = |f |Pz� |e|. O(n6) run-time makes large-scale learning applications infeasible. The us</context>
</contexts>
<marker>Satta, Peserico, 2005</marker>
<rawString>G. Satta and E. Peserico. 2005. Some computational complexity results for synchronous context-free grammars. In Proceedings of NAACL.</rawString>
</citation>
<citation valid="false">
<authors>
<author>submitted</author>
</authors>
<title>Translation algorithms by means of language intersection.</title>
<marker>submitted, </marker>
<rawString>G. Satta. submitted. Translation algorithms by means of language intersection.</rawString>
</citation>
<citation valid="true">
<authors>
<author>G van Noord</author>
</authors>
<title>The intersection of finite state automata and definite clause grammars.</title>
<date>1995</date>
<booktitle>In Proc. ofACL.</booktitle>
<marker>van Noord, 1995</marker>
<rawString>G. van Noord. 1995. The intersection of finite state automata and definite clause grammars. In Proc. ofACL.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D Wu</author>
</authors>
<title>Stochastic inversion transduction grammars and bilingual parsing of parallel corpora.</title>
<date>1997</date>
<journal>Computational Linguistics,</journal>
<volume>23</volume>
<issue>3</issue>
<contexts>
<context position="1354" citStr="Wu (1997)" startWordPosition="201" endWordPosition="202">uned search. 1 Introduction Synchronous context free grammars (SCFGs) generalize monolingual context-free grammars to generate strings concurrently in pairs of languages (Lewis and Stearns, 1968) in much the same way that finite state transducers (FSTs) generalize finite state automata (FSAs).1 Synchronous parsing is the problem of finding the best derivation, or forest of derivations, of a source and target sentence pair (f, e) under an SCFG, g.2 Solving this problem is necessary for several applications, for example, optimizing how well an SCFG translation model fits parallel training data. Wu (1997) describes a bottom-up O(n6) synchronous parsing algorithm for ITGs, a binary SCFG with a restricted form. For general grammars, the situation is even worse: the problem has been shown to be NP-hard (Satta and Peserico, 2005). Even if we restrict ourselves to binary ITGs, the *This work was supported in part by the GALE program of DARPA, Contract No. HR0011-06-2-001. The author wishes to thank Philip Rensik, Adam Lopez, Phil Blunsom, and Jason Eisner for helpful discussions. 1SCFGs have enjoyed a resurgence in popularity as the formal basis for a number of statistical translation systems, e.g.</context>
<context position="3126" citStr="Wu (1997)" startWordPosition="480" endWordPosition="481">ables us to factor the synchronous parsing problem into two successive monolingual parses. Our algorithm runs more efficiently than O(n6) with many grammars (including those that required using heuristic search with other parsers), making it possible to take advantage of synchronous parsing without developing search heuristics; and the SCFGs are not required to be in a normal form, making it possible to easily parse with more complex SCFG types. 2 Synchronous parsing Before presenting our algorithm, we review the O(n6) synchronous parser for binary ITGs.3 2.1 ITG synchronous parsing algorithm Wu (1997) describes a bottom-up synchronous parsing algorithm that can be understood as a generalization of the CKY algorithm. CKY defines a table consisting of n2 cells, with each cell corresponding to a span [i, j] in the input sentence; and the synchronous variant defines a table in 4 dimensions, with cells corresponding to a source span [s, t] and a target span [u, v]. The bottom of the chart is initialized first, and pairs of items are combined from bottom to top. Since combining items from the n4 cells involves considering two split points (one source, one target), it is not hard to see that this</context>
<context position="14136" citStr="Wu (1997)" startWordPosition="2578" endWordPosition="2579">impact of this term l is keyto understanding the algorithm’s run-time. nolingual parse with of one language ser states by the string yielded by Mehryar Mohri 2008 3way If G is an ~-free SCFG with non-terminals N and vations, pruning any nodes that yield weighted finitetate ransduces In maximally two NTs in a rule’s right hand side, and ot exist in th target Haghighi et al n is the number of states in F (corresponding to the postion algoithms tat oprate ony on scribe a pruning heuristc tht rsults number of words in the f in a sentence pair hf, ei), then theenumbern of nodes in0the parse 265 60 Wu (1997) this work 40 20 0 10 20 30 40 50 60 Figure 3: Average synchronous parser run-time (in seconds) as a function of Arabic sentence length (in words). an SCFG translation model, repurposed this algorithm to discard partial derivations during translation of f if the derivation yielded a target m-gram not found in e (p.c.). We replicated their BTEC Chinese-English baseline system and compared the speed of their ‘cube-parsing’ technique and our twoparse algorithm.14 The SCFG used here was extracted from a word-aligned corpus, as described in Chiang (2007).15 The following table compares the average </context>
</contexts>
<marker>Wu, 1997</marker>
<rawString>D. Wu. 1997. Stochastic inversion transduction grammars and bilingual parsing of parallel corpora. Computational Linguistics, 23(3):377–404.</rawString>
</citation>
<citation valid="true">
<authors>
<author>H Zhang</author>
<author>C Quirk</author>
<author>R C Moore</author>
<author>D Gildea</author>
</authors>
<title>Bayesian learning of non-compositional phrases with synchronous parsing.</title>
<date>2008</date>
<booktitle>In Proceedings of ACL.</booktitle>
<contexts>
<context position="2327" citStr="Zhang et al., 2008" startWordPosition="356" endWordPosition="359">0011-06-2-001. The author wishes to thank Philip Rensik, Adam Lopez, Phil Blunsom, and Jason Eisner for helpful discussions. 1SCFGs have enjoyed a resurgence in popularity as the formal basis for a number of statistical translation systems, e.g. Chiang (2007). However, translation requires only the manipulation of SCFGs using monolingual parsing algorithms. 2It is assumed that n = |f |Pz� |e|. O(n6) run-time makes large-scale learning applications infeasible. The usual solution is to use a heuristic search that avoids exploring edges that are likely (but not guaranteed) to be low probability (Zhang et al., 2008; Haghighi et al., 2009). In this paper, we derive an alternative synchronous parsing algorithm starting from a conception of parsing with SCFGs as a composition of binary relations. This enables us to factor the synchronous parsing problem into two successive monolingual parses. Our algorithm runs more efficiently than O(n6) with many grammars (including those that required using heuristic search with other parsers), making it possible to take advantage of synchronous parsing without developing search heuristics; and the SCFGs are not required to be in a normal form, making it possible to eas</context>
<context position="11365" citStr="Zhang et al. (2008)" startWordPosition="2007" endWordPosition="2010">gorithm. We note that while the ITG algorithm requires that the SCFGs be rank-2 and in a normal form, the twoparse algorithm analysis holds as long as the grammars are rank-2 and c-free.11 3 Experiments We now describe two different synchronous parsing applications, with different classes of SCFGs, and compare the performance of the two-parse algorithm with that of previously used algorithms. Phrasal ITGs. Here we compare performance of the two-parse algorithm and the O(n6) ITG parsing algorithm on an Arabic-English phrasal ITG alignment task. We used a variant of the phrasal ITG described by Zhang et al. (2008).12 Figure 3 plots the average run-time of the two algorithms as a function of the Arabic sentence length. The two-parse approach is far more efficient. In total, aligning the 80k sentence pairs in the corpus completed in less than 4 hours with the two-parse algorithm but required more than 1 week with the baseline algorithm.13 “Hiero” grammars. An alternative approach to computing a synchronous parse forest is based on cube pruning (Huang and Chiang, 2007). While more commonly used to integrate a target m-gram LM during decoding, Blunsom et al. (2008), who required synchronous parses to discr</context>
</contexts>
<marker>Zhang, Quirk, Moore, Gildea, 2008</marker>
<rawString>H. Zhang, C. Quirk, R. C. Moore, and D. Gildea. 2008. Bayesian learning of non-compositional phrases with synchronous parsing. In Proceedings of ACL.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Zollmann</author>
<author>A Venugopal</author>
</authors>
<title>Syntax augmented machine translation via chart parsing.</title>
<date>2006</date>
<booktitle>In Proc. of the Workshop on SMT.</booktitle>
<contexts>
<context position="12390" citStr="Zollmann and Venugopal, 2006" startWordPosition="2170" endWordPosition="2173">us parse forest is based on cube pruning (Huang and Chiang, 2007). While more commonly used to integrate a target m-gram LM during decoding, Blunsom et al. (2008), who required synchronous parses to discriminatively train 10How tight these bounds are depends on the ambiguity in the grammar w.r.t. the input: to generate n3 edges, every item in every cell must be derivable by every combination of its subspans. Most grammars are substantially less ambiguous. 11Since many widely used SCFGs meet these criteria, including hierarchical phrase-based translation grammars (Chiang, 2007), SAMT grammars (Zollmann and Venugopal, 2006), and phrasal ITGs (Zhang et al., 2008), a detailed analysis of econtaining and higher rank grammars is left to future work. 12The restriction that phrases contain exactly a single alignment point was relaxed, resulting in much larger and more ambiguous grammars than those used in the original work. 13A note on implementation: our ITG aligner was minimal; it only computed the probability of the sentence pair using the inside algorithm. With the two-parse aligner, we stored the complete forest during both the first and second parses. ti9 S &lt; X , X &gt; ier s gs i X &lt; X b , c X &gt; w can use , i is o</context>
</contexts>
<marker>Zollmann, Venugopal, 2006</marker>
<rawString>A. Zollmann and A. Venugopal. 2006. Syntax augmented machine translation via chart parsing. In Proc. of the Workshop on SMT.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>