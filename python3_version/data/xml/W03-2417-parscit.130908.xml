<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000310">
<title confidence="0.996538">
The MetaGrammar: a cross-framework and cross-language test-suite
generation tool
</title>
<author confidence="0.996892">
Alexandra Kinyon and Owen Rambow
</author>
<affiliation confidence="0.998505">
University of Pennsylvania
</affiliation>
<email confidence="0.987338">
kinyon@linc.cis.upenn.edu
</email>
<sectionHeader confidence="0.984404" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999927478260869">
In this paper, we present a novel ap-
proach for building parallel syntacti-
cally annotated sentences for different
frameworks and languages. These syn-
tactically annotated sentences are au-
tomatically generated from a compact
higher level of syntactic abstraction, a
MetaGrammar hierarchy, which min-
imizes the need for human intervention
in building annotated test-suites. With
a single hierarchy, each sentence gen-
erated is automatically mapped to sev-
eral annotations (traditional constituent
structure, LFG F-structure, dependency
structure and constraint grammar rep-
resentation) thus allowing one to di-
rectly compare the coverage of gram-
mars based on different frameworks.
Furthermore, also with that same sin-
gle compact hierarchy, the tool gener-
ates parallel annotated sentences for dif-
ferent languages, which may prove use-
ful for Machine Translation evaluation.
</bodyText>
<sectionHeader confidence="0.998783" genericHeader="introduction">
1 Introduction
</sectionHeader>
<bodyText confidence="0.998516867924528">
A large number of grammar formalisms exist for
which expensive dedicated tools such as wide-
coverage grammars, parsers etc. have been de-
veloped. All these grammar formalisms have
the same goal: formalize the syntax of natural
language so that it can be processed by a com-
puter. However, they resort to very different means
and to very different formats of representations to
achieve this goal. Broadly speaking, some for-
malisms rely on the notion of Phrase Structure,
others rely on the notion of syntactic function, oth-
ers on the notion of dependency, and yet again oth-
ers on the notion of &amp;quot;constraint&amp;quot; or on a hybrid
type of syntactic information.1
&apos;Sometimes, the dichotomy phrase-structure versus de-
pendency structure is deemed language dependent because
As pointed out in (Sutcliffe et al., 1996), this
variety of formats becomes a problem when one
wants to directly compare grammars. One stan-
dard way to evaluate the coverage of a grammar
consists in comparing the analysis of the gram-
mar to a gold standard analysis i.e. hand-corrected
syntactically annotated data. Traditionally, when
talking about syntactically annotated data, one dis-
tinguishes treebanks, such as the Penn Treebank
(Marcus et al., 1993), which consist of naturally
occurring text and often contain complex syn-
tactic phenomena and a large lexicon, from test-
suites, such as TSNLP (Lehman and al, 1996).
A test suite is a set of artificially built sentences,
which are sorted by linguistic phenomena, and
designed to contain a limited lexicon.2 Evalu-
ation approaches which rely on treebanks tend
to be favored by the statistical parsing commu-
nity because of their empirical flavor. However,
rather than opposing treebanks to test-suites, it
seems more fruitful to see both as complementary
tools, each having its advantages and drawbacks
for evaluation purpose. When evaluating the per-
formance of a grammar against a treebank, one
can obtain quantitative measures by computing
metrics such as precision, recall, crossing brack-
ets etc.3 However, one can not obtain qualitative
measures i.e. which syntactic phenomena are han-
dled by the grammar. Since test-suite sentences
are sorted by phenomena (e.g. wh-questioned ob-
ject, passive with no agent, ... ), when evaluating
phrase structure representations are thought to be less ade-
quate to formalize the syntax of so-called free word order
languages, but even this is not to be taken for granted since
there are, for instance, dependency grammars for English and
phrase structure grammars for Japanese, such as the HPSG
grammar of (Y.Mitsuishi et al., 1998).
</bodyText>
<footnote confidence="0.944100333333333">
2Another characteristic of test-suite is that they may con-
tain ungrammatical sentences on purpose, but we do not ad-
dress this issue here.
3For an overview of the various metrics used with their
respective advantages and drawbacks, see e.g. (Carroll et al.,
1998)
</footnote>
<page confidence="0.997611">
125
</page>
<bodyText confidence="0.999926860465116">
the performance of a grammar against a test-suite,
one may find, in addition to the metrics above,
which syntactic phenomena are badly handled (or
not handled at all) by the grammar, thus giving a
clear indication as to which grammar rules need
to be added or improved. Moreover, when devel-
oping a grammar within a given framework, for
a given domain and a given language, more of-
ten than not, an annotated treebank for this spe-
cific &lt;framework,domain,language&gt; triplet will
not be available. For applications requiring par-
allel grammars for several languages, the problem
is even more acute since virtually no treebank cur-
rently exists with parallel annotations for naturally
occurring text in more than one language.4
However, both Treebanks and test-suites are
costly to build: usually, once the data to be an-
notated is chosen (be it real world-data or artificial
data), it is then parsed and hand-corrected. The
hand-correction phase requires extensive human
intervention. We propose to depart from this 2-
phase scheme of annotation. Instead, we encode a
compact higher level of syntactic abstraction, the
MetaGrammar (MG), from which annotated data
is generated. This allows us to make the develop-
ment of test-suites faster by reducing the need for
human intervention, and also by making it possi-
ble to generate, from a single MG hierarchy, par-
allel test-suites for different languages and frame-
works.5
In the first part of this paper, we introduce the
notion of MetaGrammar and explain how it can be
used to classify and generate syntactically anno-
tated sentences.
In the second part of this paper, we explain
how the abstract level allows to &amp;quot;share&amp;quot; syntac-
tic knowledge among different languages, and dis-
cuss how we have generated parallel annotated
data for English and German.
In the third part of this paper, we explain how
this approach has allowed us to generate in par-
allel the same data annotated for different syntac-
tic frameworks. More specifically, we focus on
</bodyText>
<footnote confidence="0.9870485">
4This may partly explain why industrial research project,
such as Xerox XLE, still develop large hand-crafted gram-
mars instead of inducing them from treebanks.
5Another advantage of our approach is that there is not
need for a parser, and for disambiguation (manual or auto-
matic) in order to build a test-suite.
</footnote>
<bodyText confidence="0.999225625">
phrase structure annotation, dependency annota-
tion, LFG F-structure annotation and constraint
grammar annotation.
Finally, in the last part of this paper, we discuss
directions for future work, including the question
of extending the approach to naturally occurring
text in order to bridge the gap between treebanks
and test-suites.
</bodyText>
<sectionHeader confidence="0.350997" genericHeader="method">
2 What is a MetaGrammar?
</sectionHeader>
<subsectionHeader confidence="0.933389">
2.1 Theoretical Issues
</subsectionHeader>
<bodyText confidence="0.9988718">
The notion of MetaGrammar was originally pre-
sented in (Candito, 1996).6 Her goal was to au-
tomatically generate a wide-coverage Tree Ad-
joining Grammar (TAG)7 while minimizing hu-
man intervention in the grammar writing process,
and thus easing grammar development and main-
tenance. The idea is to add a higher-level and com-
pact layer of linguistic description, which imposes
a general organization for syntactic information in
a three-dimensional hierarchy:
</bodyText>
<listItem confidence="0.9976914">
• Dimension 1: initial subcategorization
• Dimension 2: valency alternations and redis-
tribution of functions
• Dimension 3: surface realization of argu-
ments.
</listItem>
<bodyText confidence="0.997510111111111">
Each terminal class in dimension 1 describes a
possible initial subcategorization (i.e. transitive,
ditransitive etc...). Each terminal class in dimen-
sion 2 describes a list of ordered redistributions of
functions (e.g. it allows to add an argument for
causatives, to erase one for passive with no agents
...). Each terminal class in dimension 3 represents
the surface realization of a surface function (ex:
declares if a direct-object is pronominalized, wh-
extracted, etc.). Each class in the hierarchy is as-
sociated to the partial description of a tree (Rogers
and Vijay-Shanker, 1994) which encodes father,
dominance, equality and precedence relations be-
tween nodes. A well-formed tree is generated by
inheriting from exactly one terminal class from di-
mension 1, one terminal class from dimension 2,
and n terminal classes from dimension 3 (where
n is the number of arguments of the elementary
</bodyText>
<footnote confidence="0.9976208">
6A similar metagrammar tool for TAGs may be found in
(Xia, 2001)
7We do not present TAGs here, since it is orthogonal to
our concern. Suffi cc it to say that the basic rules are phrase-
structure trees.
</footnote>
<page confidence="0.998196">
126
</page>
<bodyText confidence="0.948370094339623">
tree being generated). For instance the elemen-
tary tree for Par qui sera accompagnee Marie
(By whom will Mary be accompanied) is gener-
ated by inheriting from transitive in dimension 1,
from passive-no-agent in dimension 2 and subject-
nominal-inverted for its subject and questioned-
object for its object in dimension 3. This compact
representation allows one to generate a 5000 tree
grammar from a hand-crafted hierarchy of a few
dozens of nodes, esp. since nodes are explicitly
defined only for simple syntactic phenomena.8
This particular MG tool was used to develop
a wide-coverage TAG for French (Abeille et al.,
1999) (5000 grammar rules), as well as a medium-
size TAG for Italian (Candito, 1999). It is worth
mentioning that in addition to proposing a com-
pact representation of syntactic knowledge, (Can-
dito, 1999) began exploring whether some com-
ponents of the hierarchy could be re-used across
similar languages (French and Italian). However,
she developed two distinct hierarchies to generate
grammars for these two languages and generated
only grammars for the TAG framework 9. We ex-
tend the use of the MetaGrammar, whose basic
role is to generate trees, in order to generate anno-
tated strings i.e. sentences in a test-suite. In order
to achieve this, we simply add one dimension to
the organization above: a Lexicalization dimen-
sion which allows us to specify lexical items i.e.
the words which will appear in the annotated sen-
tence. We also push further the cross-language and
cross-framework potential of a MetaGrammar or-
ganization by generating annotated sentences for
English and German from one single hierarchy
and for different frameworks: traditional phrase
structure, LFG F-structure, Dependency tree, con-
straint grammar annotation.
In addition to that, the syntactically annotated
sentences we generate are classified by syntac-
tic phenomena, thanks to the notion of Hypertag,
which was introduced in (Kinyon, 2000). The
main idea behind hypertags is to keep track, when
trees are generated from a MG hierarchy, of their
8Nodes for complex syntactic phenomena are generated
by automatic crossings of nodes for simple phenomena
9For croos-language grammar development, one can also
cite the LFG Parallel Grammar project (Butt et al., 2002), but
to the best of our knowledge, this project does not explicitly
explore rule-sharing across languages.
salient syntactic characteristics i.e. the terminal
classes used for generating the tree10. For in-
stance, the verb give in A book was given to May
could be assigned the hypertag:
</bodyText>
<figure confidence="0.326710666666667">
-Subcat: Ditransitive
Valency alternations: Passive no Agent
[Subject:
</figure>
<subsectionHeader confidence="0.754426">
Argument Realization Object:
</subsectionHeader>
<bodyText confidence="0.999913888888889">
Although we retain the linguistic insights pre-
sented in (Candito, 1996), that is the notions of
multi-dimensions to model syntax, with one di-
mension for subcategorization, one dimension for
valency alternation, one dimension for the realiza-
tion of syntactic argument, and one dimension for
the realization of lexical items, we use a differ-
ent MetaGrammar tool which is less framework-
dependent and supports the notion of hypertag.
</bodyText>
<subsectionHeader confidence="0.996594">
2.2 Practical Issues
</subsectionHeader>
<bodyText confidence="0.967868">
The MG compiler we use for generating test-suites
is presented in (Gaiffe et al., 2002).11 In the
(Gaiffe et al., 2002) tool, each class in the MG hi-
erarchy encodes:
</bodyText>
<listItem confidence="0.99990175">
• Its SuperClasse(s)
• A Hypertag which captures the salient lin-
guistic characteristics of the class.
• What the class needs and provides
• A set a quasi-nodes
• Constraints between quasi-nodes (father,
dominates, precedes, equals)
• Traditional feature equations for agreement.
</listItem>
<bodyText confidence="0.943502842105263">
The MG tool automatically crosses the nodes
in the hierarchy, looking to create &amp;quot;balanced&amp;quot;
classes, that is classes that do not need nor pro-
vide anything 12 Then, for each balanced terminal
classes, the structural constraints on quasi-nodes
are unified, and if the unification succeeds, a pair
&lt;description,tree&gt; is generated. Figure 1 shows
a simple example of how one can generate the an-
notated sentences The boy sees a duck for phrase
structure.
10The notion of hypertag was inspired by that of supertags
presented in (Srinivas, 1997), which consists in assigning a
TAG elementary tree to each lexical item in a sentence, hence
emiching traditional POS tagging information. However, hy-
pertags are framework-independent.
11This compiler is freely available on
http://www.loria.fr/equipesiled/outils/mgc/mgc.html
12Another way to view this is by analogy to the notion of
resource allocation graphs.
</bodyText>
<figure confidence="0.84270075">
1
Canonical NP1
Canonical NP
127
</figure>
<figureCaption confidence="0.999932">
Figure 1: Generation of sentence The boy sees a duck
</figureCaption>
<figure confidence="0.998643426829268">
Provides: &lt;empty&gt;
Provides: subcat
Quaorree
detOld father a
nObj father duck
QuasiTree :
detSubj father the
uSubj father boy
((lass Declarative 0.\ ((lass TransitiveCunonicaINN Class NPSubj
Needs. lesSubj
Needy: SubjoiRealization
(ibititRealization
QuasiTree
S dominates V
Clays NPObj
Hypertag object: NT
Needs: lesObj
Provides:
ObjectRealization
QuasiTree
Obj equals NP
Ohj father detObj
Old father nOhj
detObj precedes nOttj
Class
LexVEnglish
Hypertag
tense:simple
english
german =-
Needs: &lt;empty&gt;
Provides:
lmV
QuasiTree :
father sees
\ Klass LexSubjEnglish&apos;\ (-Class LexObjEnglish
Hypertag:
english
german
Neols: &lt;empty&gt;
Provides:
lecSubj
Hypertag
english
german
Needs: subcat
lexV
Provides:
SubjoiRealization
Needs: &lt;empty&gt;
Provides:
lexObj
QuasiTree :
Sub] equals NP
Subj father &amp;Alibi
Sub] father nObj
detSuld precedes nSubj
Hypertag Ilypertag ITypertag subject: NP
constructitm: reheat :transtitive
declarative
QuasiTric :
S father VP
S dominat. Subj
VP father Obj
VP father V
Subj precedes V
V priced. Obj
AN
NPSubj VP GENERATED
OUTPUT
da drt
II
the boy van det n
a duck
Ilypertag
construction: declarative
subcat transitive
subject: NP
object: NP
tense:simple
english
german :-
</figure>
<bodyText confidence="0.999913764705882">
Note that with the same hierarchy, but with
slightly different dominance and precedence con-
straints on the hierarchy nodes, one obtains a sen-
tence annotated for phrase-structure, but with dif-
ferent linguistic choices (e.g. an X-bar representa-
tion of the sentence).
A first advantage of the approach is that the syn-
tactic phenomena covered are quite systematic and
the annotation coherent: if sentences are generated
for &amp;quot;transitive-passive-whExtractedB yPhrase&amp;quot;
(e.g. By whom was the mouse eaten?), and if
the hierarchy includes ditransitive verbs, then
the automatic crossing of phenomena ensures
that sentences will be generated for &amp;quot;ditransitive-
passive-whExtractedByPhrase&amp;quot; (i.e. By whom
was Peter given a present).
A second advantage of the approach is to min-
imize the need for human intervention in the test-
suite building process. Human intervention is
needed to &amp;quot;organize&amp;quot; the linguistic knowledge i.e.
encode the hierarchy, and then to verify that the
output sentences are valid. There is no annota-
tion phase after the generation. If the generation is
not satisfactory, either because some sentences are
ungrammatical, or some syntactic structures are
deemed incorrect, then changes are made directly
in the MG hierarchy and never in a post-generation
phase. This ensures a homogeneity of the annota-
tion which is not necessarily present with tradi-
tional hand-annotation approaches.
A third and essential advantage is that it is
straightforward to have parallel annotations gen-
erated from a single hierarchy. We devote the next
two sections to this topic.
</bodyText>
<sectionHeader confidence="0.9708535" genericHeader="method">
3 Generating Cross-Language
Annotated Data
</sectionHeader>
<bodyText confidence="0.999955583333333">
Traditionally, phrase-structure grammars are
deemed not well suited for languages such as
German which exhibit a relative free-word order.
The English sentence today the boy sees a duck
has only 3 possible orders (with today at the
beginning or at the end of the sentence, or,
felicitous in some contexts, just before the verb).
The same sentence in German, heute sieht der
Junge eine Ente, has 6 possible word orders, since
all the combinatorics between the constituents
are allowed as long as the finite verb is in second
position (the &amp;quot;V2&amp;quot; effect). Moreover, German
also allows an expletive construction: es sieht
der Junge eine Ente heute, thus doubling the
number of possible word orders to 12. However,
the MG tool allows us to generate all the possible
word-orders, simply by leaving some precedence
relations unspecified. In the appendix, we show
how 18 English sentences sorted by syntactic
phenomena correspond to 82 sentences in German
because of word order variations. This total of
100 sentences covers for English and German
declarative sentences, sentences with subordinate
clauses with or without a complementizer, sen-
</bodyText>
<page confidence="0.992817">
128
</page>
<figureCaption confidence="0.999606">
Figure 2: Generation of four word orders for Der Junge sieht eine Ente
</figureCaption>
<figure confidence="0.998846277372263">
Large plain arrows indicate inheritance links in the hierarchy. Smaller arrows indicate a crossing of fi nal classes which produces
an output
del n
I I
Expi NPAR
I let
55 siebt der -lunge eine Ente
Declarative
Hypertag
construction:
declarative
Needs: subcat
tray
Provides: &lt;empty&gt;
QuasiTri,
dominates V
Class VorFeld
Hypertm :
german
English—
Nersis:mmpty&gt;
Class Transitive
Hyperiag :
subcal :transtilive
SubielRealmation
ObjectRealization
VVRealization
Provtdes: wheat
Quasirree
S dominates !MIR
S dominates Obi
S dominates VP
VP precedes V
Class NI&apos;Snbj
Hyperlag : Sub] :NP
Needs: 1,Stihj
Proxides:
SubjectRealization
Huss tT ree
Subj equals NP
Subj father detObj
Subj father nObj
detSubj precedes nSubj
Class NPObj
Hypertag : Oby NP
Needs: lexObi
Provides:
ObjectRealinitim
Quasirree •
Obj equals NP
Oh] father detObj
Obj father nObj
detObj precedes nObj
Class
LexVGerm.
Hypertag :
tense:simple
owlish =-
german =,
Needs: mmpty&gt;
Proxides:
lexV
QuasiTree :
V father sieht
Class LesSubjGerman
Hypertag :
english
genunn .-t-
Needs: &lt;empty&gt;
Provides:
lexSubj
QuasiTree :
detSubj father der
nSubj father lunge
Class limObjGerman
Hypertag :
english =-
german
Needs: &lt;empty&gt;
Provides:
MAORI
QuasiTree :
detObj father eine
nObj father Ente
ProvIde, VERealeanon
QuasiTree xempty&gt;
Class
ITisExpletive
Need,&lt;empty&gt;
Provides: &lt;empty&gt;
Hypertag :
VP :expl
QuasiTrin
VT equals Expl
Expl father in
Class
VPRObj
Needs:&lt;empty&gt;
Provides: &lt;empty&gt;
Pennies: &lt;empty&gt;
Quasirree :
VP equals eibi
QuasiTree
VP equals Subj
Hypertags :
construction: declarative
subcat :transitive
subject: NP
object: NP
tensmimple
mulish
german &gt;
VE•lixpl / Subject/ Object
Expl v NPObj
I let it Id
r
es snit eine Fine der junge
NPSubj V
NPObj V
det n
sieht
eine Ent
NPOlsj
del n
eine Ente
NPSubj
del n
der hinge
GENERATED
OUTPUT
Class
VidsSubj
let it
der Junge
Neods:&lt;empty&gt;
Hypertag :
VP:Subject
</figure>
<bodyText confidence="0.99773108">
tences with or without a temporal modifier, and
for German sentences with or without an expletive
es. This constitutes a sample of the annotated
sentences generated by our hierarchy. Because of
space constraints, we are not able to reproduce
here the syntactic annotations, but the data is
available upon request to the authors.
Figure 2 illustrates how we generate the Ger-
man version of our sentence from Figure 1 (the
boy sees the duck). We retain the English hier-
archy, but add a special class for V2, called Vor-
feld (at the left in Figure 2). Of course, the lex-
ical items (at the right in both Figures 1 and 2)
are different as well. This hierarchy correctly gen-
erates the four possible word-orders: Der Junge
sieht eine Ente, eine Ente sieht der Junge, es sieht
der Junge eine Ente, es sieht eine Ente der Junge.
All the sentences have the same hypertag, except
for the Vorfeld value, which is Expletive ,Subject,
or Object. Except for the classes in the lexical-
ization dimension, which are language dependent,
classes are the same as for English, with the excep-
tion of the Vorfeld realization class and its descen-
dants. (The figures omit some details for reasons
of space.)
In using a single hierarchy for multiple lan-
guages, one of course is immediately faced with
the question of what level of granularity one
should use in expressing the categories of the
metagrammar. For example, in describing a verb-
second language such as German, one could opt to
&amp;quot;bury&amp;quot; the syntax of verb-second in the language-
specific partial description associated with the
classes of the hierarchy. Alternatively, one could
introduce (as we have done in Figure 2) a Vor-
feld class which the German main-clause sentence
(but not the English verb or the German embedded
verb) obligatorily inherits. It is clear that this ap-
proach is interesting when several languages are
to be modelled, some of which are verb-second,
and others of which are not. Furthermore, one can
might model the occupation of the Vorfeld either
as subclasses of Vorfeld (as we have done), or us-
ing argument realization classes (in fact, the same
as for English topicalization). Finally, if one is
modelling a large number of V2 languages, one
needs to consider the variety of V2 behavior found
cross-linguistically with respect to the location of
the non-finite verb (VO or OV), the occurrence of
V2 in embedded clauses (see the complex behav-
</bodyText>
<page confidence="0.997143">
129
</page>
<bodyText confidence="0.999876142857143">
ior in Mainland Scandinavian), or the occasional
V3 effect (Kashmiri). Thus, we see that our ap-
proach does not impose a linguistic choice for the
cross-linguistic modelling of syntax, but it allows
for a wide variety of approaches which can be
chosen as a function of research and application
needs.
</bodyText>
<sectionHeader confidence="0.999495" genericHeader="method">
4 Generating Cross-Framework
</sectionHeader>
<subsectionHeader confidence="0.853523">
Annotated Data
</subsectionHeader>
<bodyText confidence="0.969854897959184">
So far, we have explained how we produce sen-
tences annotated for phrase-structure. We now ex-
plain how we produce other types of syntactic an-
notation: LFG F-structures, dependency annota-
tions, and constraint grammar annotation.13
As we&apos;ve seen in the previous section, the
MG generator outputs pairs of &lt;FeatureStructure-
Tree&gt;. When the MG is used to generate a gram-
mar, then the tree is interpreted as a grammar rule
(notion of &amp;quot;elementary tree&amp;quot; in the TAG frame-
work) and Feature structure is meant to repre-
sent a description of this tree. However, the &lt;
Feature Structure — Tree &gt; pair can be inter-
preted differently. In the previous section, we have
seen that the trees generated by the MG may repre-
sent a whole Phrase-structure annotated sentence,
and the feature structure represents a description
of that sentence. But the generated tree does not
have to represent a Phrase structure tree: it can
as well represent a dependency tree, an LFG F-
structure (with co-indices to account for reentrant
features), or a flat tree consisting of only one root
node and daughter leaves (with one leaf for each
word in the sentence), where each leaf is annotated
with constraint grammar annotation.
So, by using the the exact same MG hierar-
chy used for generating Phrase-structure annota-
tion, we have generated the very same sentences
for English and German, but this time annotated
with dependency structures.
Figure 3 shows how we generate annotations
for The boy sees the duck, for dependency. Note
that the hierarchy is identical to the one on fig-
ure 1, except for the constraints for building the
I3For the constraint grammar annotation, we have used the
output for English of the ENCCG demo available online at
www.connexor.com/demos.html. For LFG, and dependency
annotations, we produce &apos;standard&amp;quot; analysis, but as we have
seen in the previous section, different linguistic choices could
be made.
Quasi-tree. We use the same technique (changing
the constraints on quasi-trees) to generate LFG F-
structures, and constraint grammar annotations.
Of course, all the sentences in the appendix are
generated in a similar fashion using 26 classes.
The cross-language and -framework parallelism of
the sentences is ensured by the hypertag. For in-
stance, all the examples presented on figures 1, 2
and 3 have a common hypertag kernel:
</bodyText>
<table confidence="0.922217166666667">
construction: Declarative-
Sucat: Transitive
tense: simple english:+/-
german:+/-
Subject: NP
Object: NP
</table>
<sectionHeader confidence="0.942083" genericHeader="method">
5 Conclusion and Future Work
</sectionHeader>
<bodyText confidence="0.94451009375">
We have shown a new way to produce cross-
language and cross-framework test-suites, using a
common MetaGrammar hierarchy, which reduces
the need for human intervention in the develop-
ment process. The same technique may be ap-
plied for generating cross-languages and cross-
framework grammars, which is a problem we are
currently investigating. We plan to expand the hi-
erarchy to generate larger test-suites 14
Moreover, in future work, we plan to apply the
same technique to naturally occurring text, which
would prove promising for producing parallel tree-
banks for various frameworks. If we assume that
a treebank already exists (such as the Penn Tree-
bank), our task would be to extract hypertags from
the existing annotation (which, in the case of the
Penn Treebank, can be done, using some heuris-
tics), and then use the hypertags to generate an-
notations for the same corpus in different frame-
works. If no treebank exists, we have to do the hy-
pertagging by hand, and assign a dependency-style
structure to the sentence. We can then proceed in
the same manner as before, using a single hand-
annotation to derive the treebanks for the different
frameworks. Thus, we believe that the use of hy-
pertags as a framework-neutral representation of
relevant syntactic features can greatly reduce the
dependence of treebanks on particular formalisms
&amp;quot;Scaling up has not been a problem to generate grammars
of more than 5000 rules (see (Kinyon and Prolo, 2002) for a
detailed discussion), and presents no intrinsic diffi culties for
test-suite generation.
</bodyText>
<page confidence="0.98113">
130
</page>
<table confidence="0.991214">
Hypertag : V:sees GENERATED
construction: declarative
submit :transitive
subject: NP
object: NP nSubj : boy nObj :duck OUTPUT
tense:simple det:the det :a
english :-v
german :-
</table>
<figureCaption confidence="0.998584">
Figure 3: Generation of dependencies for The boy sees a duck
</figureCaption>
<figure confidence="0.990633123076923">
1-Class LexObjEnglisil
LexSu n
bjEglish
Hypertag :
english
german =.
c Clam
1Class Declarative
Class NPObj
lass TransitiveCanonical
Class NPSubj
Hypertag object NI
Hypertag : subject: SP
Hy,p.egart:t
german
Hypertag
construction:
declarative
Hypertag :
mbcat Aranstitive
Needs: lexObj
Needs: lexSubj
Provides:
ObjectRealintion
LexVEnglish
Hypertag :
tense:simple
english
german
Needs: submit
lacy
Needs: SubjectRealm:Mon
rhijectRealimtion
Needs: &lt;empty&gt;
Provides: subcat
Needs: &lt;empty&gt;
Provides:
SubjectRealiration
Provides: &lt;empty&gt;
Needs: &lt;empty&gt;
Provides:
lext/bj
QmsiTree :
Obj equals nObj
Qmsff ree :
Subj equals &amp;Subject
Quasffree :
nObj equals nObj :duck
nObj lather detO :a
QuasiTree :
nSubj equals nSubj :boy
nSubj father deLS the
Provides:
levy
Qumffree :
&lt;empty&gt;
QuasiTree :
Root dominates Subj
Root dominates Obj
Subj precedes Obj
Provides:
lexSubj
Quasffree :
Root equals v:sees
and frameworks.
</figure>
<sectionHeader confidence="0.953234" genericHeader="method">
References
</sectionHeader>
<reference confidence="0.999682047619048">
A. Abeille, M. Candito, and A. Kinyon. 1999. FTAG:
current status and parsing scheme. In Proc. Vextal-
99, Venice.
M. Butt, H. Dyvik, T.H. King, H. Masuichi, and
C. Rohrer. 2002. The parallel grammar project. In
proc. GEE-COLING, Taipei.
M.H. Candito. 1996. A principle-based hierarchical
representation of LTAGs. In COLING-96, Copen-
hagen.
M.H. Candito. 1999. Representation modulaire
et parametrable de grammaires electron iques lexi-
calisees. Ph.D. thesis, Univ. Paris 7.
J. Carroll, E. Briscoe, and A. Sanfi lippo. 1998. Parser
evaluation: a survey and a new proposal. In LREC-
98, Grenada.
B. Gaiffe, B. Crabbe, and A. Roussanaly. 2002. A new
metagrammar compiler. In Proc. TAG+6, Venice.
A. Kinyon and C. Prolo. 2002. A classifi cation of
grammar development strategies. In Proc. GEE-
COLING, Taipei.
A. Kinyon. 2000. Hypertags. In COLING-00, Sar-
rebrucken.
S. Lehman and al. 1996. Tsnlp — test suites for natural
language processing. In Proc. COLING-96, Copen-
hagen.
M. Marcus, B. Santorini, and M. Marcinkiewicz. 1993.
Building a large annotated corpus of English : the
penn treeban. In Computational Linguistics, Vol 19.
J. Rogers and K. Vijay-Shanker. 1994. Obtaining trees
from their description: an application to TAGS. In
Computational Intelligence 10:4.
B. Srinivas. 1997. Complexity of lexical descriptions
and its relevance for partial parsing. Ph.D. thesis,
Univ. of Pennsylvania.
R. Sutcliffe, H. Koch, and A. McElligot, editors. 1996.
Industrial Parsing of Software Manuals. Rodopi,
Amsterdam.
F. Xia. 2001. Automatic grammar generation from two
perspectives. Ph.D. thesis, Univ. of Pennsylvania.
Y.Mitsuishi, K. Torisawa, and T. Tsujii. 1998. HPSG-
Style underspecifi ed japanese grammar with wide
coverage. In COLING-ACL-98, Montreal.
</reference>
<page confidence="0.998678">
131
</page>
<sectionHeader confidence="0.540116" genericHeader="method">
Appendix 1: Sample of Parallel English-German sentences we generate.
</sectionHeader>
<bodyText confidence="0.998460925925927">
Syntactic Phenomena # Engl-Germ. English German
Declarative-NoModif-SimpleTense 1-4 The boy sees a duck Der lunge sieht eine Ente
Eine Ente sieht der Junge
Es sieht der hinge eine Eine
Es sieht eine Ente der lunge
Declarative-NoModif-CoumpoundTense 1-4 The boy has seen a duck Der lunge hat eine Eine gesehen
Eine Este hat der Jorge gesehen
Es hat der Junge eine Ente gesehen
Es hat eine Ente der hinge gesehen
Declaratiye-Modif-SimpleTense 2-12 Today the boy sees a duck Heute sieht der hinge eine Ente
The boy sees a duck today Heine sieht eine Ente der Junge
Der Junge sieht eine Este heute
Eine Ente sieht der Junge heute
Es sieht der Junge eine Ente heute
Es sieht eine Ente der Junge heute
Der Jungc sieht heutc eine Ente
Eine Ente sieht heute der lunge
Es sieht heute der hinge eine Eine
Es sieht heute eine Ente der lunge
Es sieht der lunge heine eine Ente
Es sicht eine Ente heute der lunge
Declaratiye-Modif-CoumpoundTense 2-12 Today the boy has seen a duck Heute hat der Junge eine Ente gesehen
The boy has seen a duck today Heute hat eine Erne der lunge geschen
Der Junge hat eine Ente heute gesehen
Eine Ente hat der Junge hcute geschen
Es hat der Jimge eine Ente brute gesehen
Es hat eine Ente der Junge brute gesehen
Der Jungc hat heute eine Entc geschen
Eine Ente hat heute der Junge gesehen
Es hat heute der Junge eine Ente gesehen
Es hat heute eine Ente der lunge gesehen
Es hat der Junge heute eine Ente gesehen
Es hat eine Ente brute der Junge gesehen
SubordinateWithCompl-NoModif-SimpleTense 1-2 He says that the boy sees a duck Er sagt, doss der Jimge eine Ente sieht
Er sagt, dass eine Ente der lunge sieht
SU bordinateWithCompl-NoModif-CoumpoundTense 1-2 He says that the boy has seen a cluck Er sagt, doss der Junge eine Untte gesehen hat
Er sagt, dass eine Ente der lunge gcschen hat
S ubord i nateWithCom pl -Mod if-S im pleTe n se 2-6 He says that today the boy sees a duck Er sagt, dass heute der Junge eine Ente sieht
He says that the boy sees a duck today Er sagt, dass heute eine Ente der lunge sieht
Er sagt, dass der lunge eine Ente heute sieht
Er sagt, class eine Ente der Junge hcute sieht
Er sagt, dass eine Ente heute der lunge sieht
Er sagt, class der Junge heute eine Ente sieht
SubordinateWithCompl-Modif-CoumpoundTense 2-6 He says that today the boy has seen a duck Er sagt, class heute der lunge eine Ente gesehen hat
He says that the boy has seen a duck today Er sagt, class heine eine Eine der lunge gesehen hat
Er sagt, dass der lunge chic Ente heute gesehen hat
Er sagt, dass eine Ente der lunge heute gesehen hat
Er sagt, class eine Ente heute der lunge gcseheil hat
Er sagt, dass der Junge heute eine Ente gesehen hat
SubordinateNoCompl-NoModif-SimpleTense 2-6 He says the boy sees a duck Er sagt der lunge sieht eine Ente
Er sagt eine Ente sieht der lunge
Er sagt es sieht der Junge eine Eine
Er sagt es sieht eine Ente der lunge
SubordinateNoCompl-NoModif-CoumpoundTense 1-4 He says the boy has seen a duck Er sagt der lunge hat eine Eine gesehen
Er sagt eine Eine hat der hinge gesehen
he sagt es hat der Junge eine Ente gesehen
Er sagt es hat eine Ente der hinge gesehen
SubordinateNoCompl-Modif-SimpleTense 2-12 Ile says today the boy sees a duck Er sagt heute sieht der Junge eine Ente
He says the boy sees a duck today Er sagt heute sieht eine Ente der Junge
Er sagt der Junge sieht eine Ente heute
Er sagt eine Ente sieht der Junge heute
Er sagt der lunge sieht heute eine Ente
Er sagt eine Ente sieht heute der lunge
Er sagt es sieht der hinge eine Ente heute
Er sagt es sieht eine Ente der lunge heute
Er sagt es sieht der Junge heute eine Ente
Er sagt es sieht eine Ente heute der lunge
Er sagt es sieht heute der Junge eine Ente
Er sagt es sieht heute eine Ente der &apos;tinge
SubordinateNoCompl-Modif-CoumpoundTense 2-12 He says today the boy has seen a duck Er sagt heute hat der lunge eine Ente gesehen
He says the boy sees a duck today Er sagt heute hat eine Este der Junge gesehen
Er sagt der Junge hat eine Ente heute gesehen
Er sagt eine Ente has der Junge brute gesehen
Er sagt der lunge hat heute eine Eine gesehen
Er sagt eine Ente hat heute der Junge gesehen
Er sagt es hat der hinge eine Eine hence gesehen
Er sagt es hat eine Ente der hinge heute gesehen
Be sagt es hat der Junge heute eine Ente gesehen
Er sagt es hat eine Ente heute der Junge gesehen
Er sagt es hat heute der lunge eine Ente gesehen
he sagt es hat heute eine Ente der Junge gesehen
</bodyText>
<page confidence="0.98831">
132
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.853323">
<title confidence="0.975154">The MetaGrammar: a cross-framework and cross-language generation tool</title>
<author confidence="0.999245">Alexandra Kinyon</author>
<author confidence="0.999245">Owen</author>
<affiliation confidence="0.999917">University of Pennsylvania</affiliation>
<email confidence="0.999844">kinyon@linc.cis.upenn.edu</email>
<abstract confidence="0.995620541666667">In this paper, we present a novel approach for building parallel syntactically annotated sentences for different frameworks and languages. These syntactically annotated sentences are automatically generated from a compact level of syntactic abstraction, hierarchy, minimizes the need for human intervention in building annotated test-suites. With a single hierarchy, each sentence generated is automatically mapped to several annotations (traditional constituent structure, LFG F-structure, dependency structure and constraint grammar representation) thus allowing one to directly compare the coverage of grammars based on different frameworks. Furthermore, also with that same single compact hierarchy, the tool generates parallel annotated sentences for different languages, which may prove useful for Machine Translation evaluation.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>A Abeille</author>
<author>M Candito</author>
<author>A Kinyon</author>
</authors>
<title>FTAG: current status and parsing scheme.</title>
<date>1999</date>
<booktitle>In Proc. Vextal99,</booktitle>
<location>Venice.</location>
<contexts>
<context position="8905" citStr="Abeille et al., 1999" startWordPosition="1401" endWordPosition="1404"> tree being generated). For instance the elementary tree for Par qui sera accompagnee Marie (By whom will Mary be accompanied) is generated by inheriting from transitive in dimension 1, from passive-no-agent in dimension 2 and subjectnominal-inverted for its subject and questionedobject for its object in dimension 3. This compact representation allows one to generate a 5000 tree grammar from a hand-crafted hierarchy of a few dozens of nodes, esp. since nodes are explicitly defined only for simple syntactic phenomena.8 This particular MG tool was used to develop a wide-coverage TAG for French (Abeille et al., 1999) (5000 grammar rules), as well as a mediumsize TAG for Italian (Candito, 1999). It is worth mentioning that in addition to proposing a compact representation of syntactic knowledge, (Candito, 1999) began exploring whether some components of the hierarchy could be re-used across similar languages (French and Italian). However, she developed two distinct hierarchies to generate grammars for these two languages and generated only grammars for the TAG framework 9. We extend the use of the MetaGrammar, whose basic role is to generate trees, in order to generate annotated strings i.e. sentences in a</context>
</contexts>
<marker>Abeille, Candito, Kinyon, 1999</marker>
<rawString>A. Abeille, M. Candito, and A. Kinyon. 1999. FTAG: current status and parsing scheme. In Proc. Vextal99, Venice.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Butt</author>
<author>H Dyvik</author>
<author>T H King</author>
<author>H Masuichi</author>
<author>C Rohrer</author>
</authors>
<title>The parallel grammar project.</title>
<date>2002</date>
<booktitle>In proc. GEE-COLING,</booktitle>
<location>Taipei.</location>
<contexts>
<context position="10540" citStr="Butt et al., 2002" startWordPosition="1657" endWordPosition="1660">erent frameworks: traditional phrase structure, LFG F-structure, Dependency tree, constraint grammar annotation. In addition to that, the syntactically annotated sentences we generate are classified by syntactic phenomena, thanks to the notion of Hypertag, which was introduced in (Kinyon, 2000). The main idea behind hypertags is to keep track, when trees are generated from a MG hierarchy, of their 8Nodes for complex syntactic phenomena are generated by automatic crossings of nodes for simple phenomena 9For croos-language grammar development, one can also cite the LFG Parallel Grammar project (Butt et al., 2002), but to the best of our knowledge, this project does not explicitly explore rule-sharing across languages. salient syntactic characteristics i.e. the terminal classes used for generating the tree10. For instance, the verb give in A book was given to May could be assigned the hypertag: -Subcat: Ditransitive Valency alternations: Passive no Agent [Subject: Argument Realization Object: Although we retain the linguistic insights presented in (Candito, 1996), that is the notions of multi-dimensions to model syntax, with one dimension for subcategorization, one dimension for valency alternation, on</context>
</contexts>
<marker>Butt, Dyvik, King, Masuichi, Rohrer, 2002</marker>
<rawString>M. Butt, H. Dyvik, T.H. King, H. Masuichi, and C. Rohrer. 2002. The parallel grammar project. In proc. GEE-COLING, Taipei.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M H Candito</author>
</authors>
<title>A principle-based hierarchical representation of LTAGs.</title>
<date>1996</date>
<booktitle>In COLING-96,</booktitle>
<location>Copenhagen.</location>
<contexts>
<context position="6641" citStr="Candito, 1996" startWordPosition="1042" endWordPosition="1043"> treebanks. 5Another advantage of our approach is that there is not need for a parser, and for disambiguation (manual or automatic) in order to build a test-suite. phrase structure annotation, dependency annotation, LFG F-structure annotation and constraint grammar annotation. Finally, in the last part of this paper, we discuss directions for future work, including the question of extending the approach to naturally occurring text in order to bridge the gap between treebanks and test-suites. 2 What is a MetaGrammar? 2.1 Theoretical Issues The notion of MetaGrammar was originally presented in (Candito, 1996).6 Her goal was to automatically generate a wide-coverage Tree Adjoining Grammar (TAG)7 while minimizing human intervention in the grammar writing process, and thus easing grammar development and maintenance. The idea is to add a higher-level and compact layer of linguistic description, which imposes a general organization for syntactic information in a three-dimensional hierarchy: • Dimension 1: initial subcategorization • Dimension 2: valency alternations and redistribution of functions • Dimension 3: surface realization of arguments. Each terminal class in dimension 1 describes a possible i</context>
<context position="10998" citStr="Candito, 1996" startWordPosition="1727" endWordPosition="1728">atic crossings of nodes for simple phenomena 9For croos-language grammar development, one can also cite the LFG Parallel Grammar project (Butt et al., 2002), but to the best of our knowledge, this project does not explicitly explore rule-sharing across languages. salient syntactic characteristics i.e. the terminal classes used for generating the tree10. For instance, the verb give in A book was given to May could be assigned the hypertag: -Subcat: Ditransitive Valency alternations: Passive no Agent [Subject: Argument Realization Object: Although we retain the linguistic insights presented in (Candito, 1996), that is the notions of multi-dimensions to model syntax, with one dimension for subcategorization, one dimension for valency alternation, one dimension for the realization of syntactic argument, and one dimension for the realization of lexical items, we use a different MetaGrammar tool which is less frameworkdependent and supports the notion of hypertag. 2.2 Practical Issues The MG compiler we use for generating test-suites is presented in (Gaiffe et al., 2002).11 In the (Gaiffe et al., 2002) tool, each class in the MG hierarchy encodes: • Its SuperClasse(s) • A Hypertag which captures the s</context>
</contexts>
<marker>Candito, 1996</marker>
<rawString>M.H. Candito. 1996. A principle-based hierarchical representation of LTAGs. In COLING-96, Copenhagen.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M H Candito</author>
</authors>
<title>Representation modulaire et parametrable de grammaires electron iques lexicalisees.</title>
<date>1999</date>
<tech>Ph.D. thesis,</tech>
<institution>Univ. Paris</institution>
<contexts>
<context position="8983" citStr="Candito, 1999" startWordPosition="1417" endWordPosition="1418"> Marie (By whom will Mary be accompanied) is generated by inheriting from transitive in dimension 1, from passive-no-agent in dimension 2 and subjectnominal-inverted for its subject and questionedobject for its object in dimension 3. This compact representation allows one to generate a 5000 tree grammar from a hand-crafted hierarchy of a few dozens of nodes, esp. since nodes are explicitly defined only for simple syntactic phenomena.8 This particular MG tool was used to develop a wide-coverage TAG for French (Abeille et al., 1999) (5000 grammar rules), as well as a mediumsize TAG for Italian (Candito, 1999). It is worth mentioning that in addition to proposing a compact representation of syntactic knowledge, (Candito, 1999) began exploring whether some components of the hierarchy could be re-used across similar languages (French and Italian). However, she developed two distinct hierarchies to generate grammars for these two languages and generated only grammars for the TAG framework 9. We extend the use of the MetaGrammar, whose basic role is to generate trees, in order to generate annotated strings i.e. sentences in a test-suite. In order to achieve this, we simply add one dimension to the orga</context>
</contexts>
<marker>Candito, 1999</marker>
<rawString>M.H. Candito. 1999. Representation modulaire et parametrable de grammaires electron iques lexicalisees. Ph.D. thesis, Univ. Paris 7.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Carroll</author>
<author>E Briscoe</author>
<author>A Sanfi lippo</author>
</authors>
<title>Parser evaluation: a survey and a new proposal.</title>
<date>1998</date>
<booktitle>In LREC98,</booktitle>
<contexts>
<context position="3895" citStr="Carroll et al., 1998" startWordPosition="596" endWordPosition="599">.. ), when evaluating phrase structure representations are thought to be less adequate to formalize the syntax of so-called free word order languages, but even this is not to be taken for granted since there are, for instance, dependency grammars for English and phrase structure grammars for Japanese, such as the HPSG grammar of (Y.Mitsuishi et al., 1998). 2Another characteristic of test-suite is that they may contain ungrammatical sentences on purpose, but we do not address this issue here. 3For an overview of the various metrics used with their respective advantages and drawbacks, see e.g. (Carroll et al., 1998) 125 the performance of a grammar against a test-suite, one may find, in addition to the metrics above, which syntactic phenomena are badly handled (or not handled at all) by the grammar, thus giving a clear indication as to which grammar rules need to be added or improved. Moreover, when developing a grammar within a given framework, for a given domain and a given language, more often than not, an annotated treebank for this specific &lt;framework,domain,language&gt; triplet will not be available. For applications requiring parallel grammars for several languages, the problem is even more acute sin</context>
</contexts>
<marker>Carroll, Briscoe, lippo, 1998</marker>
<rawString>J. Carroll, E. Briscoe, and A. Sanfi lippo. 1998. Parser evaluation: a survey and a new proposal. In LREC98, Grenada.</rawString>
</citation>
<citation valid="true">
<authors>
<author>B Gaiffe</author>
<author>B Crabbe</author>
<author>A Roussanaly</author>
</authors>
<title>A new metagrammar compiler.</title>
<date>2002</date>
<booktitle>In Proc. TAG+6,</booktitle>
<location>Venice.</location>
<contexts>
<context position="11465" citStr="Gaiffe et al., 2002" startWordPosition="1799" endWordPosition="1802">ive Valency alternations: Passive no Agent [Subject: Argument Realization Object: Although we retain the linguistic insights presented in (Candito, 1996), that is the notions of multi-dimensions to model syntax, with one dimension for subcategorization, one dimension for valency alternation, one dimension for the realization of syntactic argument, and one dimension for the realization of lexical items, we use a different MetaGrammar tool which is less frameworkdependent and supports the notion of hypertag. 2.2 Practical Issues The MG compiler we use for generating test-suites is presented in (Gaiffe et al., 2002).11 In the (Gaiffe et al., 2002) tool, each class in the MG hierarchy encodes: • Its SuperClasse(s) • A Hypertag which captures the salient linguistic characteristics of the class. • What the class needs and provides • A set a quasi-nodes • Constraints between quasi-nodes (father, dominates, precedes, equals) • Traditional feature equations for agreement. The MG tool automatically crosses the nodes in the hierarchy, looking to create &amp;quot;balanced&amp;quot; classes, that is classes that do not need nor provide anything 12 Then, for each balanced terminal classes, the structural constraints on quasi-nodes a</context>
</contexts>
<marker>Gaiffe, Crabbe, Roussanaly, 2002</marker>
<rawString>B. Gaiffe, B. Crabbe, and A. Roussanaly. 2002. A new metagrammar compiler. In Proc. TAG+6, Venice.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Kinyon</author>
<author>C Prolo</author>
</authors>
<title>A classifi cation of grammar development strategies.</title>
<date>2002</date>
<booktitle>In Proc. GEECOLING,</booktitle>
<location>Taipei.</location>
<contexts>
<context position="25309" citStr="Kinyon and Prolo, 2002" startWordPosition="3998" endWordPosition="4001">ertags to generate annotations for the same corpus in different frameworks. If no treebank exists, we have to do the hypertagging by hand, and assign a dependency-style structure to the sentence. We can then proceed in the same manner as before, using a single handannotation to derive the treebanks for the different frameworks. Thus, we believe that the use of hypertags as a framework-neutral representation of relevant syntactic features can greatly reduce the dependence of treebanks on particular formalisms &amp;quot;Scaling up has not been a problem to generate grammars of more than 5000 rules (see (Kinyon and Prolo, 2002) for a detailed discussion), and presents no intrinsic diffi culties for test-suite generation. 130 Hypertag : V:sees GENERATED construction: declarative submit :transitive subject: NP object: NP nSubj : boy nObj :duck OUTPUT tense:simple det:the det :a english :-v german :- Figure 3: Generation of dependencies for The boy sees a duck 1-Class LexObjEnglisil LexSu n bjEglish Hypertag : english german =. c Clam 1Class Declarative Class NPObj lass TransitiveCanonical Class NPSubj Hypertag object NI Hypertag : subject: SP Hy,p.egart:t german Hypertag construction: declarative Hypertag : mbcat Aran</context>
</contexts>
<marker>Kinyon, Prolo, 2002</marker>
<rawString>A. Kinyon and C. Prolo. 2002. A classifi cation of grammar development strategies. In Proc. GEECOLING, Taipei.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Kinyon</author>
</authors>
<date>2000</date>
<booktitle>Hypertags. In COLING-00, Sarrebrucken.</booktitle>
<contexts>
<context position="10217" citStr="Kinyon, 2000" startWordPosition="1608" endWordPosition="1609">icalization dimension which allows us to specify lexical items i.e. the words which will appear in the annotated sentence. We also push further the cross-language and cross-framework potential of a MetaGrammar organization by generating annotated sentences for English and German from one single hierarchy and for different frameworks: traditional phrase structure, LFG F-structure, Dependency tree, constraint grammar annotation. In addition to that, the syntactically annotated sentences we generate are classified by syntactic phenomena, thanks to the notion of Hypertag, which was introduced in (Kinyon, 2000). The main idea behind hypertags is to keep track, when trees are generated from a MG hierarchy, of their 8Nodes for complex syntactic phenomena are generated by automatic crossings of nodes for simple phenomena 9For croos-language grammar development, one can also cite the LFG Parallel Grammar project (Butt et al., 2002), but to the best of our knowledge, this project does not explicitly explore rule-sharing across languages. salient syntactic characteristics i.e. the terminal classes used for generating the tree10. For instance, the verb give in A book was given to May could be assigned the </context>
</contexts>
<marker>Kinyon, 2000</marker>
<rawString>A. Kinyon. 2000. Hypertags. In COLING-00, Sarrebrucken.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S Lehman</author>
<author>al</author>
</authors>
<title>Tsnlp — test suites for natural language processing.</title>
<date>1996</date>
<booktitle>In Proc. COLING-96,</booktitle>
<location>Copenhagen.</location>
<contexts>
<context position="2429" citStr="Lehman and al, 1996" startWordPosition="364" endWordPosition="367">se As pointed out in (Sutcliffe et al., 1996), this variety of formats becomes a problem when one wants to directly compare grammars. One standard way to evaluate the coverage of a grammar consists in comparing the analysis of the grammar to a gold standard analysis i.e. hand-corrected syntactically annotated data. Traditionally, when talking about syntactically annotated data, one distinguishes treebanks, such as the Penn Treebank (Marcus et al., 1993), which consist of naturally occurring text and often contain complex syntactic phenomena and a large lexicon, from testsuites, such as TSNLP (Lehman and al, 1996). A test suite is a set of artificially built sentences, which are sorted by linguistic phenomena, and designed to contain a limited lexicon.2 Evaluation approaches which rely on treebanks tend to be favored by the statistical parsing community because of their empirical flavor. However, rather than opposing treebanks to test-suites, it seems more fruitful to see both as complementary tools, each having its advantages and drawbacks for evaluation purpose. When evaluating the performance of a grammar against a treebank, one can obtain quantitative measures by computing metrics such as precision</context>
</contexts>
<marker>Lehman, al, 1996</marker>
<rawString>S. Lehman and al. 1996. Tsnlp — test suites for natural language processing. In Proc. COLING-96, Copenhagen.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Marcus</author>
<author>B Santorini</author>
<author>M Marcinkiewicz</author>
</authors>
<title>Building a large annotated corpus of English : the penn treeban.</title>
<date>1993</date>
<journal>In Computational Linguistics, Vol</journal>
<volume>19</volume>
<contexts>
<context position="2266" citStr="Marcus et al., 1993" startWordPosition="337" endWordPosition="340">onstraint&amp;quot; or on a hybrid type of syntactic information.1 &apos;Sometimes, the dichotomy phrase-structure versus dependency structure is deemed language dependent because As pointed out in (Sutcliffe et al., 1996), this variety of formats becomes a problem when one wants to directly compare grammars. One standard way to evaluate the coverage of a grammar consists in comparing the analysis of the grammar to a gold standard analysis i.e. hand-corrected syntactically annotated data. Traditionally, when talking about syntactically annotated data, one distinguishes treebanks, such as the Penn Treebank (Marcus et al., 1993), which consist of naturally occurring text and often contain complex syntactic phenomena and a large lexicon, from testsuites, such as TSNLP (Lehman and al, 1996). A test suite is a set of artificially built sentences, which are sorted by linguistic phenomena, and designed to contain a limited lexicon.2 Evaluation approaches which rely on treebanks tend to be favored by the statistical parsing community because of their empirical flavor. However, rather than opposing treebanks to test-suites, it seems more fruitful to see both as complementary tools, each having its advantages and drawbacks f</context>
</contexts>
<marker>Marcus, Santorini, Marcinkiewicz, 1993</marker>
<rawString>M. Marcus, B. Santorini, and M. Marcinkiewicz. 1993. Building a large annotated corpus of English : the penn treeban. In Computational Linguistics, Vol 19.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Rogers</author>
<author>K Vijay-Shanker</author>
</authors>
<title>Obtaining trees from their description: an application to TAGS.</title>
<date>1994</date>
<journal>In Computational Intelligence</journal>
<volume>10</volume>
<contexts>
<context position="7770" citStr="Rogers and Vijay-Shanker, 1994" startWordPosition="1212" endWordPosition="1215">mension 3: surface realization of arguments. Each terminal class in dimension 1 describes a possible initial subcategorization (i.e. transitive, ditransitive etc...). Each terminal class in dimension 2 describes a list of ordered redistributions of functions (e.g. it allows to add an argument for causatives, to erase one for passive with no agents ...). Each terminal class in dimension 3 represents the surface realization of a surface function (ex: declares if a direct-object is pronominalized, whextracted, etc.). Each class in the hierarchy is associated to the partial description of a tree (Rogers and Vijay-Shanker, 1994) which encodes father, dominance, equality and precedence relations between nodes. A well-formed tree is generated by inheriting from exactly one terminal class from dimension 1, one terminal class from dimension 2, and n terminal classes from dimension 3 (where n is the number of arguments of the elementary 6A similar metagrammar tool for TAGs may be found in (Xia, 2001) 7We do not present TAGs here, since it is orthogonal to our concern. Suffi cc it to say that the basic rules are phrasestructure trees. 126 tree being generated). For instance the elementary tree for Par qui sera accompagnee </context>
</contexts>
<marker>Rogers, Vijay-Shanker, 1994</marker>
<rawString>J. Rogers and K. Vijay-Shanker. 1994. Obtaining trees from their description: an application to TAGS. In Computational Intelligence 10:4.</rawString>
</citation>
<citation valid="true">
<authors>
<author>B Srinivas</author>
</authors>
<title>Complexity of lexical descriptions and its relevance for partial parsing.</title>
<date>1997</date>
<tech>Ph.D. thesis,</tech>
<institution>Univ. of Pennsylvania.</institution>
<contexts>
<context position="12360" citStr="Srinivas, 1997" startWordPosition="1945" endWordPosition="1946">, dominates, precedes, equals) • Traditional feature equations for agreement. The MG tool automatically crosses the nodes in the hierarchy, looking to create &amp;quot;balanced&amp;quot; classes, that is classes that do not need nor provide anything 12 Then, for each balanced terminal classes, the structural constraints on quasi-nodes are unified, and if the unification succeeds, a pair &lt;description,tree&gt; is generated. Figure 1 shows a simple example of how one can generate the annotated sentences The boy sees a duck for phrase structure. 10The notion of hypertag was inspired by that of supertags presented in (Srinivas, 1997), which consists in assigning a TAG elementary tree to each lexical item in a sentence, hence emiching traditional POS tagging information. However, hypertags are framework-independent. 11This compiler is freely available on http://www.loria.fr/equipesiled/outils/mgc/mgc.html 12Another way to view this is by analogy to the notion of resource allocation graphs. 1 Canonical NP1 Canonical NP 127 Figure 1: Generation of sentence The boy sees a duck Provides: &lt;empty&gt; Provides: subcat Quaorree detOld father a nObj father duck QuasiTree : detSubj father the uSubj father boy ((lass Declarative 0.\ ((l</context>
</contexts>
<marker>Srinivas, 1997</marker>
<rawString>B. Srinivas. 1997. Complexity of lexical descriptions and its relevance for partial parsing. Ph.D. thesis, Univ. of Pennsylvania.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Sutcliffe</author>
<author>H Koch</author>
<author>A McElligot</author>
<author>editors</author>
</authors>
<date>1996</date>
<booktitle>Industrial Parsing of Software Manuals. Rodopi,</booktitle>
<location>Amsterdam.</location>
<contexts>
<context position="1854" citStr="Sutcliffe et al., 1996" startWordPosition="273" endWordPosition="276"> the same goal: formalize the syntax of natural language so that it can be processed by a computer. However, they resort to very different means and to very different formats of representations to achieve this goal. Broadly speaking, some formalisms rely on the notion of Phrase Structure, others rely on the notion of syntactic function, others on the notion of dependency, and yet again others on the notion of &amp;quot;constraint&amp;quot; or on a hybrid type of syntactic information.1 &apos;Sometimes, the dichotomy phrase-structure versus dependency structure is deemed language dependent because As pointed out in (Sutcliffe et al., 1996), this variety of formats becomes a problem when one wants to directly compare grammars. One standard way to evaluate the coverage of a grammar consists in comparing the analysis of the grammar to a gold standard analysis i.e. hand-corrected syntactically annotated data. Traditionally, when talking about syntactically annotated data, one distinguishes treebanks, such as the Penn Treebank (Marcus et al., 1993), which consist of naturally occurring text and often contain complex syntactic phenomena and a large lexicon, from testsuites, such as TSNLP (Lehman and al, 1996). A test suite is a set o</context>
</contexts>
<marker>Sutcliffe, Koch, McElligot, editors, 1996</marker>
<rawString>R. Sutcliffe, H. Koch, and A. McElligot, editors. 1996. Industrial Parsing of Software Manuals. Rodopi, Amsterdam.</rawString>
</citation>
<citation valid="true">
<authors>
<author>F Xia</author>
</authors>
<title>Automatic grammar generation from two perspectives.</title>
<date>2001</date>
<tech>Ph.D. thesis,</tech>
<institution>Univ. of Pennsylvania.</institution>
<contexts>
<context position="8144" citStr="Xia, 2001" startWordPosition="1276" endWordPosition="1277">esents the surface realization of a surface function (ex: declares if a direct-object is pronominalized, whextracted, etc.). Each class in the hierarchy is associated to the partial description of a tree (Rogers and Vijay-Shanker, 1994) which encodes father, dominance, equality and precedence relations between nodes. A well-formed tree is generated by inheriting from exactly one terminal class from dimension 1, one terminal class from dimension 2, and n terminal classes from dimension 3 (where n is the number of arguments of the elementary 6A similar metagrammar tool for TAGs may be found in (Xia, 2001) 7We do not present TAGs here, since it is orthogonal to our concern. Suffi cc it to say that the basic rules are phrasestructure trees. 126 tree being generated). For instance the elementary tree for Par qui sera accompagnee Marie (By whom will Mary be accompanied) is generated by inheriting from transitive in dimension 1, from passive-no-agent in dimension 2 and subjectnominal-inverted for its subject and questionedobject for its object in dimension 3. This compact representation allows one to generate a 5000 tree grammar from a hand-crafted hierarchy of a few dozens of nodes, esp. since nod</context>
</contexts>
<marker>Xia, 2001</marker>
<rawString>F. Xia. 2001. Automatic grammar generation from two perspectives. Ph.D. thesis, Univ. of Pennsylvania.</rawString>
</citation>
<citation valid="true">
<authors>
<author>K Torisawa Y Mitsuishi</author>
<author>T Tsujii</author>
</authors>
<title>HPSGStyle underspecifi ed japanese grammar with wide coverage.</title>
<date>1998</date>
<booktitle>In COLING-ACL-98,</booktitle>
<location>Montreal.</location>
<marker>Mitsuishi, Tsujii, 1998</marker>
<rawString>Y.Mitsuishi, K. Torisawa, and T. Tsujii. 1998. HPSGStyle underspecifi ed japanese grammar with wide coverage. In COLING-ACL-98, Montreal.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>