<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000043">
<title confidence="0.913282">
Terminal-Aware Synchronous Binarization
</title>
<author confidence="0.996432">
Licheng Fang, Tagyoung Chung and Daniel Gildea
</author>
<affiliation confidence="0.998121">
Department of Computer Science
University of Rochester
</affiliation>
<address confidence="0.391544">
Rochester, NY 14627
</address>
<sectionHeader confidence="0.962043" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.998936875">
We present an SCFG binarization algorithm
that combines the strengths of early termi-
nal matching on the source language side and
early language model integration on the tar-
get language side. We also examine how dif-
ferent strategies of target-side terminal attach-
ment during binarization can significantly af-
fect translation quality.
</bodyText>
<sectionHeader confidence="0.998431" genericHeader="introduction">
1 Introduction
</sectionHeader>
<bodyText confidence="0.999754384615385">
Synchronous context-free grammars (SCFG) are be-
hind most syntax-based machine translation mod-
els. Efficient machine translation decoding with an
SCFG requires converting the grammar into a bina-
rized form, either explicitly, as in synchronous bina-
rization (Zhang et al., 2006), where virtual nontermi-
nals are generated for binarization, or implicitly, as
in Earley parsing (Earley, 1970), where dotted items
are used.
Given a source-side binarized SCFG with termi-
nal set T and nonterminal set N, the time complex-
ity of decoding a sentence of length n with a m-gram
language model is (Venugopal et al., 2007):
</bodyText>
<equation confidence="0.966888">
O(n3(|N |· |T |2(m−1))K)
</equation>
<bodyText confidence="0.859186333333333">
where K is the maximum number of right-hand-side
nonterminals. SCFG binarization serves two impor-
tant goals:
</bodyText>
<listItem confidence="0.936121727272727">
• Parsing complexity for unbinarized SCFG
grows exponentially with the number of non-
terminals on the right-hand side of grammar
rules. Binarization ensures cubic time decod-
ing in terms of input sentence length.
• In machine translation, integrating language
model states as early as possible is essential to
reducing search errors. Synchronous binariza-
tion (Zhang et al., 2006) enables the decoder to
incorporate language model scores as soon as a
binarized rule is applied.
</listItem>
<bodyText confidence="0.999800928571428">
In this paper, we examine a CYK-like syn-
chronous binarization algorithm that integrates a
novel criterion in a unified semiring parsing frame-
work. The criterion we present has explicit consider-
ation of source-side terminals. In general, terminals
in a rule have a lower probability of being matched
given a sentence, and therefore have the effect of
“anchoring” a rule and limiting its possible applica-
tion points. Hopkins and Langmead (2010) formal-
ized this concept as the scope of a rule. A rule of
scope of k can be parsed in O(nk). The scope of a
rule can be calculated by counting the number of ad-
jacent nonterminal pairs and boundary nonterminals.
For example,
</bodyText>
<equation confidence="0.474916">
A → w1BCw2D
</equation>
<bodyText confidence="0.999852416666667">
has scope two. Building on the concept of scope,
we define a cost function that estimates the expected
number of hyperedges to be built when a particular
binarization tree is applied to unseen data. This ef-
fectively puts hard-to-match derivations at the bot-
tom of the binarization tree, which enables the de-
coder to decide early on whether an unbinarized rule
can be built or not.
We also investigate a better way to handle target-
side terminals during binarization. In theory, differ-
ent strategies should produce equivalent translation
results. However, because decoding always involves
</bodyText>
<page confidence="0.982918">
401
</page>
<note confidence="0.777841">
Proceedings of the 49th Annual Meeting of the Association for Computational Linguistics:shortpapers, pages 401–406,
Portland, Oregon, June 19-24, 2011. c�2011 Association for Computational Linguistics
</note>
<figure confidence="0.952036">
1 2 3 4 5 6 7
Number of right-hand-side nonterminals
</figure>
<figureCaption confidence="0.999896">
Figure 1: Rule Statistics
</figureCaption>
<bodyText confidence="0.999933961538462">
pruning, we show that different strategies do have a
significant effect in translation quality.
Other works investigating alternative binarization
methods mostly focus on the effect of nonterminal
sharing. Xiao et al. (2009) also proposed a CYK-
like algorithm for synchronous binarization. Appar-
ently the lack of virtual nonterminal sharing in their
decoder caused heavy competition between virtual
nonterminals, and they created a cost function to
“diversify” binarization trees, which is equivalent to
minimizing nonterminal sharing.
DeNero et al. (2009b) used a greedy method to
maximize virtual nonterminal sharing on the source
side during the -LM parsing phase. They show that
effective source-side binarization can improve the ef-
ficiency of parsing SCFG. However, their method
works only on the source side, and synchronous bina-
rization is put off to the +LM decoding phase (DeN-
ero et al., 2009a).
Although these ideas all lead to faster decoding
and reduced search errors, there can be conflicts in
the constraints each of them has on the form of rules
and accommodating all of them can be a challenge.
In this paper, we present a cubic time algorithm to
find the best binarization tree, given the conflicting
constraints.
</bodyText>
<sectionHeader confidence="0.945752" genericHeader="method">
2 The Binarization Algorithm
</sectionHeader>
<bodyText confidence="0.8897642">
An SCFG rule is synchronously binarizable if when
simultaneously binarizing source and target sides,
virtual nonterminals created by binarizations always
have contiguous spans on both sides (Huang, 2007).
Algorithm 1 The CYK binarization algorithm.
</bodyText>
<equation confidence="0.948469444444444">
CYK-BINARIZE(X -* (γ, α))
for i = 0...|γ |− 1 do
T[i, i + 1] &lt;-- cinit(i)
for s = 2 ... |γ |do
for i = 0 ... |γ|-1 do
j &lt;-- i + s
for k = i + 1 ... j − 1 do
t &lt;-- T[i, k] + T[k, j] + c((i, k, j))
T[i, j] &lt;-- min(T[i, j], t)
</equation>
<bodyText confidence="0.9998004">
Even with the synchronous binarization constraint,
many possible binarizations exist. Analysis of our
Chinese-English parallel corpus has shown that the
majority of synchronously binarizable rules with ar-
ity smaller than 4 are monotonic, i.e., the target-side
nonterminal permutation is either strictly increasing
or decreasing (See Figure 1). For monotonic rules,
any source-side binarization is also a permissible
synchronous binarization.
The binarization problem can be formulated as a
semiring parsing (Goodman, 1999) problem. We
define a cost function that considers different bina-
rization criteria. A CYK-like algorithm can be used
to find the best binarization tree according to the
cost function. Consider an SCFG rule X -* (γ, α),
where γ and α stand for the source side and the tar-
get side. Let B(γ) be the set of all possible bina-
rization trees for γ. With the cost function c defined
over hyperedges in a binarization tree t, the optimal
binarization tree t is
</bodyText>
<equation confidence="0.988670333333333">
1:
t� = argmin c(h)
t∈B(γ) h∈t
</equation>
<bodyText confidence="0.999633857142857">
where c(h) is the cost of a hyperedge h in t.
The optimization problem can be solved by Al-
gorithm 1. (i, k, j) denotes a hyperedge h that con-
nects the spans (i, k) and (k, j) to the span (i, j).
ci,,it is the initialization for the cost function c. We
can recover the optimal source-side binarization tree
by augmenting the algorithm with back pointers.
Binarized rules are generated by iterating over the
nodes in the optimal binarization tree, while attach-
ing unaligned target-side terminals. At each tree
node, we generate a virtual nonterminal symbol by
concatenating the source span it dominates.
We define the cost function c(h) to be a
tuple of component cost functions: c(h) =
</bodyText>
<figure confidence="0.998024230769231">
Total
Binarizable
Monotonic
Number of rules 18000
16000
14000
12000
10000
8000
6000
4000
2000
0
</figure>
<page confidence="0.983186">
402
</page>
<equation confidence="0.553529333333333">
(c1(h), c2(h), ...). When two costs a and b are com-
pared, the components are compared piecewise, i.e.
c &lt; c� �? c1 &lt; ci V (c1 = ci ∧ c2 &lt; c2) V ...
</equation>
<bodyText confidence="0.9989385">
If the (min, +) operators on each component cost
satisfy the semiring properties, the cost tuple is also
a semiring. Next, we describe our cost functions and
how we handle target-side terminals.
</bodyText>
<subsectionHeader confidence="0.992316">
2.1 Synchronous Binarization as a Cost
</subsectionHeader>
<bodyText confidence="0.999888466666667">
We use a binary cost b to indicate whether a binariza-
tion tree is a permissible synchronous binarization.
Given a hyperedge (i, k, j), we say k is apermissible
split of the span (i, j) if and only if the spans (i, k)
and (k, j) are both synchronously binarizable and
the span (i, j) covers a consecutive sequence of non-
terminals on the target side. A span is synchronously
binarizable if and only if the span is of length one,
or a permissible split of the span exists. The cost b
is defined as:
Under this configuration, the semiring operators
(min, +) defined for the cost b are (V, ∧). Using b as
the first cost function in the cost function tuple guar-
antees that we will find a tree that is a synchronously
binarized if one exists.
</bodyText>
<subsectionHeader confidence="0.985613">
2.2 Early Source-Side Terminal Matching
</subsectionHeader>
<bodyText confidence="0.999866166666667">
When a rule is being applied while parsing a sen-
tence, terminals in the rule have less chance of be-
ing matched. We can exploit this fact by taking ter-
minals into account during binarization and placing
terminals lower in the binarization tree. Consider the
following SCFG rule:
</bodyText>
<equation confidence="0.814488666666667">
PP VM JJ NN,
VP �
propose a JJ NN PP
</equation>
<bodyText confidence="0.995418333333333">
The synchronous binarization algorithm of Zhang et
al. (2006) binarizes the rule1 by finding the right-
most binarizable points on the source side:
</bodyText>
<footnote confidence="0.950948666666667">
1We follow Wu (1997) and use square brackets for straight
rules and pointed brackets for inverted rules. We also mark
brackets with indices to represent virtual nonterminals.
</footnote>
<equation confidence="0.847176666666667">
PP [VM [JJ NN]1]2,
VP �
[[propose a JJ NN]1]2 PP
</equation>
<bodyText confidence="0.999503333333333">
The source side of the first binarized rule “[]1 → JJ
NN, propose a JJ NN” contains a very frequent non-
terminal sequence “JJ NN”. If one were to parse
with the binarized rule, and if the virtual nontermi-
nal []1 has been built, the parser needs to continue
following the binarization tree in order to determine
whether the original rule would be matched. Further-
more, having two consecutive nonterminals adds to
complexity since the parser needs to test each split
point.
The following binarization is equally valid but in-
tegrates terminals early:
</bodyText>
<equation confidence="0.9406505">
PP [[VM JJ]1 NN]2,
VP �
</equation>
<bodyText confidence="0.976361066666667">
[[propose a JJ]1 NN]2 PP
Here, the first binarized rule “[]1 → VM JJ, pro-
pose a JJ” anchors on a terminal and enables earlier
pruning of the original rule.
We formulate this intuition by asking the ques-
tion: given a source-side string γ, what binarization
tree, on average, builds the smallest number of hy-
peredges when the rule is applied? This is realized
by defining a cost function e which estimates the
probability of a hyperedge (i, k, j) being built. We
use a simple model: assume each terminal or non-
terminal in γ is matched independently with a fixed
probability, then a hyperedge (i, k, j) is derived if
and only if all symbols in the source span (i, j) are
matched. The cost e is thus defined as2
</bodyText>
<equation confidence="0.999860666666667">
e((i,k,j)) = � p(γℓ)
i&lt;ℓ&lt;j
einit(i) = 0
</equation>
<bodyText confidence="0.999929285714286">
For terminals, p(γℓ) can be estimated by counting
the source side of the training corpus. For nontermi-
nals, we simply assume p(γℓ) = 1.
With the hyperedge cost e, the cost of a binariza-
tion tree t is EhEt e(h), i.e., the expected number of
hyperedges to be built when a particular binarization
of a rule is applied to unseen data.3 The operators
</bodyText>
<footnote confidence="0.9434814">
2In this definition, k does not appear on the right-hand side
of the equation because all edges leading to the same span share
the same cost value.
3Although this cost function is defined as an expectation, it
does not form an expectation semiring (Eisner, 2001) because
</footnote>
<equation confidence="0.93946525">
k _ f T if k is a permissible split of (i, j)
b((i
, ,�)) F otherwise
binit(i) = T
</equation>
<page confidence="0.994929">
403
</page>
<bodyText confidence="0.9993745">
for the cost a are the usual (min, +) operators on
real numbers.
</bodyText>
<subsectionHeader confidence="0.999222">
2.3 Maximizing Nonterminal Sharing
</subsectionHeader>
<bodyText confidence="0.999985">
During binarization, newly created virtual nontermi-
nals are named according to the symbols (terminals
and nonterminals) that they generate. For example, a
new virtual nonterminal covering two nonterminals
NP and VP is named NP+VP. To achieve maximum
virtual nonterminal sharing, we also define a cost
function n to count the number new nonterminals
generated by a binarization tree. We keep track of
all the nonterminals that have been generated when
binarizing a rule set. When the i’th rule is being
binarized, a nonterminal is considered new if it is
previously unseen in binarizing rules 1 to i−1. This
greedy approach is similar to that of DeNero et al.
(2009b). The cost function is thus defined as:
</bodyText>
<equation confidence="0.964084333333333">
� _ 1 if the VT for span (i, j) is new
n ((i, k, j)) 0 otherwise
ninit(i) = 0
</equation>
<bodyText confidence="0.9921045">
The semiring operators for this cost are also
(min, +) on real numbers.
</bodyText>
<subsectionHeader confidence="0.991887">
2.4 Late Target-Side Terminal Attachment
</subsectionHeader>
<bodyText confidence="0.996016111111111">
Once the optimal source-side binarization tree is
found, we have a good deal of freedom to attach
target-side terminals to adjacent nonterminals, as
long as the bracketing of nonterminals is not vio-
lated. The following example is taken from Zhang
et al. (2006):
With the source-side binarization fixed, we can pro-
duce distinct binarized rules by choosing different
ways of attaching target-side terminals:
</bodyText>
<equation confidence="0.28870525">
ADJP [RB :ft*]1 ( [PP 的]3 NN )2,
[RB]1 ( resp. for the NN [PP]3 )2
ADJP [RB :ft*]1 ( [PP 的]3 NN )2,
[RB]1 resp. for the ( NN [PP]3 )2
</equation>
<bodyText confidence="0.98075375">
The first binarization is generated by attaching the
target-side terminals as low as possible in a post-
it is defined as an expectation over input strings, instead of an
expectation over trees.
order traversal of the binarization tree. The conven-
tional wisdom is that early consideration of target-
side terminals promotes early language model score
integration (Huang et al., 2009). The second bina-
rization, on the contrary, attaches the target-side ter-
minals as high as possible in the binarization tree.
We argue that this late target-side terminal attach-
ment is in fact better for two reasons.
First, as in the example above, compare the fol-
lowing two rules resulting from early attachment of
target terminals and late attachment of target termi-
nals:
</bodyText>
<equation confidence="0.823724">
()2 []3 NN, resp. for the NN []3
()2 []3 NN, NN []3
</equation>
<bodyText confidence="0.999938125">
The former has a much smaller chance of sharing
the same target side with other binarized rules be-
cause on the target side, many nonterminals will be
attached without any lexical evidence. We are more
likely to have a smaller set of rules with the latter
binarization.
Second, with the presence of pruning, dynamic
programming states that are generated by rules with
many target-side terminals are disadvantaged when
competing with others in the same bin because of
the language model score. As a result, these would
be discarded earlier, even if the original unbinarized
rule has a high probability. Consequently, we lose
the benefit of using larger rules, which have more
contextual information. We show in our experiment
that late target side terminal attachment significantly
outperforms early target side terminal attachment.
Although the problem can be alleviated by pre-
computing a language model score for the original
unbinarized rule and applying the heuristic to its bi-
narized rules, this still grants no benefit over late ter-
minal attachment. We show in our experiment that
late target-side terminal attachment significantly out-
performs early target side terminal attachment.
</bodyText>
<sectionHeader confidence="0.998329" genericHeader="method">
3 Experiments
</sectionHeader>
<subsectionHeader confidence="0.994839">
3.1 Setup
</subsectionHeader>
<bodyText confidence="0.9996615">
We test our binarization algorithm on an Chinese-
English translation task. We extract a GHKM gram-
mar (Galley et al., 2004) from a parallel corpus with
the parsed English side with some modification so
</bodyText>
<table confidence="0.349908">
ADJP RB responsible for the NN PP
RB :ft* PP 的 NN,
</table>
<page confidence="0.97555">
404
</page>
<figure confidence="0.9922325">
10 100
Seconds / Sentence (log scale)
10 100
Seconds / Sentence (log scale)
</figure>
<figureCaption confidence="0.999909">
Figure 3: BLEU Scores vs Decoding Time
</figureCaption>
<bodyText confidence="0.999987">
as not to extract unary rules (Chung et al., 2011).
The corpus consists of 250K sentence pairs, which
is 6.3M words on the English side. A 392-sentence
test set was to evaluate different binarizations.
Decoding is performed by a general CYK SCFG
decoder developed in-house and a trigram language
model is used. The decoder runs the CYK algorithm
with cube-pruning (Chiang, 2007). In all our exper-
iments, we discard unbinarizable rules, which have
been shown by Zhang et al. (2006) to have no signif-
icant effect on translation accuracy.
</bodyText>
<subsectionHeader confidence="0.935449">
3.2 Results
</subsectionHeader>
<bodyText confidence="0.999918121212121">
We first discuss effects of maximizing nonterminal
sharing. Having nonterminal sharing maximization
as a part of the cost function for binarization did
yield slightly smaller grammars. However, we could
not discern any noticeable difference or trend in
terms of BLEU score, decoding speed, or model
score when comparing translation results that used
grammars that employed nonterminal sharing max-
imization and ones that did not. In the rest of this
section, all the results we discuss use nonterminal
sharing maximization as a part of the cost function.
We then compare the effects of early target-side
terminal attachment and late attachment. Figure 2
shows model scores of each decoder run with vary-
ing bin sizes, and Figure 3 shows BLEU scores
for corresponding runs of the experiments. (b,n)-
early is conventional synchronous binarization with
early target-side terminal attachment and nontermi-
nal sharing maximization, (b,n)-late is the same set-
ting with late target-side terminal attachment. The
tuples represent cost functions that are discussed in
Section 2. The figures clearly show that late attach-
ment of target-side terminals is better. Although
Figure 3 does not show perfect correlation with Fig-
ure 2, it exhibits the same trend. The same goes for
(b,e,n)-early and (b,e,n)-late.
Finally, we examine the effect of including the
source-side terminal-aware cost function, denoted
“e” in our cost tuples. Comparing (b,e,n)-late with
(b,n)-late, we see that terminal-aware binarization
gives better model scores and BLEU scores. The
trend is the same when one compares (b,e,n)-early
and (b,n)-early.
</bodyText>
<sectionHeader confidence="0.999286" genericHeader="conclusions">
4 Conclusion
</sectionHeader>
<bodyText confidence="0.999796411764706">
We examined binarizing synchronous context-free
grammars within a semiring parsing framework. We
proposed binarization methods that explicitly take
terminals into consideration. We have found that al-
though binarized rules are already scope 3, we can
still do better by putting infrequent derivations as
low as possible in a binarization tree to promote
early pruning. We have also found that attaching
target side terminals as late as possible promotes
smarter pruning of rules thereby improving model
score and translation quality at decoding time. Im-
provements we discuss in this paper result in better
search, and hence better translation.
Acknowledgments We thank Hao Zhang for use-
ful discussions and the anonymous reviewers for
their helpful comments. This work was supported
by NSF grants IIS-0546554 and IIS-0910611.
</bodyText>
<figure confidence="0.97620975">
(b,n)-early
(b,n)-late
(b,e,n)-early
(b,e,n)-late
</figure>
<figureCaption confidence="0.935321">
Figure 2: Model Scores vs. Decoding Time
</figureCaption>
<figure confidence="0.998571318181818">
BLEU
20.5
19.5
18.5
17.5
20
19
18
(b,n)-early
(b,n)-late
(b,e,n)-early
(b,e,n)-late
-355
-360
Model Score (log-probability)
-365
-370
-375
-380
-385
-390
-395
</figure>
<page confidence="0.997481">
405
</page>
<sectionHeader confidence="0.983511" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999907507692308">
David Chiang. 2007. Hierarchical phrase-based transla-
tion. Computational Linguistics, 33(2):201–228.
Tagyoung Chung, Licheng Fang, and Daniel Gildea.
2011. Issues concerning decoding with synchronous
context-free grammar. In Proceedings of the ACL
2011 Conference Short Papers, Portland, Oregon, June.
Association for Computational Linguistics.
J. DeNero, A. Pauls, and D. Klein. 2009a. Asynchronous
binarization for synchronous grammars. In Proceed-
ings of the ACL-IJCNLP 2009 Conference Short Pa-
pers, pages 141–144. Association for Computational
Linguistics.
John DeNero, Mohit Bansal, Adam Pauls, and Dan Klein.
2009b. Efficient parsing for transducer grammars. In
Proceedings of Human Language Technologies: The
2009 Annual Conference of the North American Chap-
ter of the Association for Computational Linguistics,
pages 227–235, Boulder, Colorado, June. Association
for Computational Linguistics.
Jay Earley. 1970. An efficient context-free parsing algo-
rithm. Communications of the ACM, 6(8):451–455.
J. Eisner. 2001. Expectation semirings: Flexible EM
for learning finite-state transducers. In Proceedings of
the ESSLLI workshop on finite-state methods in NLP.
Citeseer.
Michel Galley, Mark Hopkins, Kevin Knight, and Daniel
Marcu. 2004. What’s in a translation rule? In Pro-
ceedings of the 2004 Meeting of the North American
chapter of the Association for Computational Linguis-
tics (NAACL-04), pages 273–280.
Joshua Goodman. 1999. Semiring parsing. Computa-
tional Linguistics, 25(4):573–605.
Mark Hopkins and Greg Langmead. 2010. SCFG decod-
ing without binarization. In Proceedings of the 2010
Conference on Empirical Methods in Natural Lan-
guage Processing, pages 646–655, Cambridge, MA,
October. Association for Computational Linguistics.
Liang Huang, Hao Zhang, Daniel Gildea, and Kevin
Knight. 2009. Binarization of synchronous
context-free grammars. Computational Linguistics,
35(4):559–595.
Liang Huang. 2007. Binarization, synchronous bina-
rization, and target-side binarization. In Proceedings
of the NAACL/AMTA Workshop on Syntax and Struc-
ture in Statistical Translation (SSST), pages 33–40,
Rochester, NY.
Ashish Venugopal, Andreas Zollmann, and Stephan Vo-
gel. 2007. An efficient two-pass approach to
synchronous-CFG driven statistical MT. In NAACL07,
Rochester, NY, April.
Dekai Wu. 1997. Stochastic inversion transduction gram-
mars and bilingual parsing of parallel corpora. Compu-
tational Linguistics, 23(3):377–403.
T. Xiao, M. Li, D. Zhang, J. Zhu, and M. Zhou. 2009.
Better synchronous binarization for machine transla-
tion. In Proceedings of the 2009 Conference on Em-
pirical Methods in Natural Language Processing: Vol-
ume 1-Volume 1, pages 362–370. Association for Com-
putational Linguistics.
Hao Zhang, Liang Huang, Daniel Gildea, and Kevin
Knight. 2006. Synchronous binarization for machine
translation. In Proceedings of the 2006 Meeting of the
North American chapter of the Association for Compu-
tational Linguistics (NAACL-06), pages 256–263, New
York, NY.
</reference>
<page confidence="0.999047">
406
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.944229">
<title confidence="0.998941">Terminal-Aware Synchronous Binarization</title>
<author confidence="0.96673">Chung</author>
<affiliation confidence="0.999807">Department of Computer University of</affiliation>
<address confidence="0.999061">Rochester, NY 14627</address>
<abstract confidence="0.997625444444444">We present an SCFG binarization algorithm that combines the strengths of early terminal matching on the source language side and early language model integration on the target language side. We also examine how different strategies of target-side terminal attachment during binarization can significantly affect translation quality.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>David Chiang</author>
</authors>
<title>Hierarchical phrase-based translation.</title>
<date>2007</date>
<journal>Computational Linguistics,</journal>
<volume>33</volume>
<issue>2</issue>
<contexts>
<context position="14974" citStr="Chiang, 2007" startWordPosition="2533" endWordPosition="2534">el corpus with the parsed English side with some modification so ADJP RB responsible for the NN PP RB :ft* PP 的 NN, 404 10 100 Seconds / Sentence (log scale) 10 100 Seconds / Sentence (log scale) Figure 3: BLEU Scores vs Decoding Time as not to extract unary rules (Chung et al., 2011). The corpus consists of 250K sentence pairs, which is 6.3M words on the English side. A 392-sentence test set was to evaluate different binarizations. Decoding is performed by a general CYK SCFG decoder developed in-house and a trigram language model is used. The decoder runs the CYK algorithm with cube-pruning (Chiang, 2007). In all our experiments, we discard unbinarizable rules, which have been shown by Zhang et al. (2006) to have no significant effect on translation accuracy. 3.2 Results We first discuss effects of maximizing nonterminal sharing. Having nonterminal sharing maximization as a part of the cost function for binarization did yield slightly smaller grammars. However, we could not discern any noticeable difference or trend in terms of BLEU score, decoding speed, or model score when comparing translation results that used grammars that employed nonterminal sharing maximization and ones that did not. I</context>
</contexts>
<marker>Chiang, 2007</marker>
<rawString>David Chiang. 2007. Hierarchical phrase-based translation. Computational Linguistics, 33(2):201–228.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Tagyoung Chung</author>
<author>Licheng Fang</author>
<author>Daniel Gildea</author>
</authors>
<title>Issues concerning decoding with synchronous context-free grammar.</title>
<date>2011</date>
<booktitle>In Proceedings of the ACL 2011 Conference Short Papers,</booktitle>
<publisher>Association</publisher>
<institution>for Computational Linguistics.</institution>
<location>Portland, Oregon,</location>
<contexts>
<context position="14646" citStr="Chung et al., 2011" startWordPosition="2479" endWordPosition="2482">no benefit over late terminal attachment. We show in our experiment that late target-side terminal attachment significantly outperforms early target side terminal attachment. 3 Experiments 3.1 Setup We test our binarization algorithm on an ChineseEnglish translation task. We extract a GHKM grammar (Galley et al., 2004) from a parallel corpus with the parsed English side with some modification so ADJP RB responsible for the NN PP RB :ft* PP 的 NN, 404 10 100 Seconds / Sentence (log scale) 10 100 Seconds / Sentence (log scale) Figure 3: BLEU Scores vs Decoding Time as not to extract unary rules (Chung et al., 2011). The corpus consists of 250K sentence pairs, which is 6.3M words on the English side. A 392-sentence test set was to evaluate different binarizations. Decoding is performed by a general CYK SCFG decoder developed in-house and a trigram language model is used. The decoder runs the CYK algorithm with cube-pruning (Chiang, 2007). In all our experiments, we discard unbinarizable rules, which have been shown by Zhang et al. (2006) to have no significant effect on translation accuracy. 3.2 Results We first discuss effects of maximizing nonterminal sharing. Having nonterminal sharing maximization as</context>
</contexts>
<marker>Chung, Fang, Gildea, 2011</marker>
<rawString>Tagyoung Chung, Licheng Fang, and Daniel Gildea. 2011. Issues concerning decoding with synchronous context-free grammar. In Proceedings of the ACL 2011 Conference Short Papers, Portland, Oregon, June. Association for Computational Linguistics.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J DeNero</author>
<author>A Pauls</author>
<author>D Klein</author>
</authors>
<title>Asynchronous binarization for synchronous grammars.</title>
<date>2009</date>
<booktitle>In Proceedings of the ACL-IJCNLP 2009 Conference Short Papers,</booktitle>
<pages>141--144</pages>
<publisher>Association</publisher>
<institution>for Computational Linguistics.</institution>
<contexts>
<context position="3840" citStr="DeNero et al. (2009" startWordPosition="589" endWordPosition="592">Number of right-hand-side nonterminals Figure 1: Rule Statistics pruning, we show that different strategies do have a significant effect in translation quality. Other works investigating alternative binarization methods mostly focus on the effect of nonterminal sharing. Xiao et al. (2009) also proposed a CYKlike algorithm for synchronous binarization. Apparently the lack of virtual nonterminal sharing in their decoder caused heavy competition between virtual nonterminals, and they created a cost function to “diversify” binarization trees, which is equivalent to minimizing nonterminal sharing. DeNero et al. (2009b) used a greedy method to maximize virtual nonterminal sharing on the source side during the -LM parsing phase. They show that effective source-side binarization can improve the efficiency of parsing SCFG. However, their method works only on the source side, and synchronous binarization is put off to the +LM decoding phase (DeNero et al., 2009a). Although these ideas all lead to faster decoding and reduced search errors, there can be conflicts in the constraints each of them has on the form of rules and accommodating all of them can be a challenge. In this paper, we present a cubic time algor</context>
<context position="11438" citStr="DeNero et al. (2009" startWordPosition="1935" endWordPosition="1938">nterminals are named according to the symbols (terminals and nonterminals) that they generate. For example, a new virtual nonterminal covering two nonterminals NP and VP is named NP+VP. To achieve maximum virtual nonterminal sharing, we also define a cost function n to count the number new nonterminals generated by a binarization tree. We keep track of all the nonterminals that have been generated when binarizing a rule set. When the i’th rule is being binarized, a nonterminal is considered new if it is previously unseen in binarizing rules 1 to i−1. This greedy approach is similar to that of DeNero et al. (2009b). The cost function is thus defined as: � _ 1 if the VT for span (i, j) is new n ((i, k, j)) 0 otherwise ninit(i) = 0 The semiring operators for this cost are also (min, +) on real numbers. 2.4 Late Target-Side Terminal Attachment Once the optimal source-side binarization tree is found, we have a good deal of freedom to attach target-side terminals to adjacent nonterminals, as long as the bracketing of nonterminals is not violated. The following example is taken from Zhang et al. (2006): With the source-side binarization fixed, we can produce distinct binarized rules by choosing different wa</context>
</contexts>
<marker>DeNero, Pauls, Klein, 2009</marker>
<rawString>J. DeNero, A. Pauls, and D. Klein. 2009a. Asynchronous binarization for synchronous grammars. In Proceedings of the ACL-IJCNLP 2009 Conference Short Papers, pages 141–144. Association for Computational Linguistics.</rawString>
</citation>
<citation valid="true">
<authors>
<author>John DeNero</author>
<author>Mohit Bansal</author>
<author>Adam Pauls</author>
<author>Dan Klein</author>
</authors>
<title>Efficient parsing for transducer grammars.</title>
<date>2009</date>
<booktitle>In Proceedings of Human Language Technologies: The 2009 Annual Conference of the North American Chapter of the Association for Computational Linguistics,</booktitle>
<pages>227--235</pages>
<publisher>Association</publisher>
<institution>for Computational Linguistics.</institution>
<location>Boulder, Colorado,</location>
<contexts>
<context position="3840" citStr="DeNero et al. (2009" startWordPosition="589" endWordPosition="592">Number of right-hand-side nonterminals Figure 1: Rule Statistics pruning, we show that different strategies do have a significant effect in translation quality. Other works investigating alternative binarization methods mostly focus on the effect of nonterminal sharing. Xiao et al. (2009) also proposed a CYKlike algorithm for synchronous binarization. Apparently the lack of virtual nonterminal sharing in their decoder caused heavy competition between virtual nonterminals, and they created a cost function to “diversify” binarization trees, which is equivalent to minimizing nonterminal sharing. DeNero et al. (2009b) used a greedy method to maximize virtual nonterminal sharing on the source side during the -LM parsing phase. They show that effective source-side binarization can improve the efficiency of parsing SCFG. However, their method works only on the source side, and synchronous binarization is put off to the +LM decoding phase (DeNero et al., 2009a). Although these ideas all lead to faster decoding and reduced search errors, there can be conflicts in the constraints each of them has on the form of rules and accommodating all of them can be a challenge. In this paper, we present a cubic time algor</context>
<context position="11438" citStr="DeNero et al. (2009" startWordPosition="1935" endWordPosition="1938">nterminals are named according to the symbols (terminals and nonterminals) that they generate. For example, a new virtual nonterminal covering two nonterminals NP and VP is named NP+VP. To achieve maximum virtual nonterminal sharing, we also define a cost function n to count the number new nonterminals generated by a binarization tree. We keep track of all the nonterminals that have been generated when binarizing a rule set. When the i’th rule is being binarized, a nonterminal is considered new if it is previously unseen in binarizing rules 1 to i−1. This greedy approach is similar to that of DeNero et al. (2009b). The cost function is thus defined as: � _ 1 if the VT for span (i, j) is new n ((i, k, j)) 0 otherwise ninit(i) = 0 The semiring operators for this cost are also (min, +) on real numbers. 2.4 Late Target-Side Terminal Attachment Once the optimal source-side binarization tree is found, we have a good deal of freedom to attach target-side terminals to adjacent nonterminals, as long as the bracketing of nonterminals is not violated. The following example is taken from Zhang et al. (2006): With the source-side binarization fixed, we can produce distinct binarized rules by choosing different wa</context>
</contexts>
<marker>DeNero, Bansal, Pauls, Klein, 2009</marker>
<rawString>John DeNero, Mohit Bansal, Adam Pauls, and Dan Klein. 2009b. Efficient parsing for transducer grammars. In Proceedings of Human Language Technologies: The 2009 Annual Conference of the North American Chapter of the Association for Computational Linguistics, pages 227–235, Boulder, Colorado, June. Association for Computational Linguistics.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jay Earley</author>
</authors>
<title>An efficient context-free parsing algorithm.</title>
<date>1970</date>
<journal>Communications of the ACM,</journal>
<volume>6</volume>
<issue>8</issue>
<contexts>
<context position="905" citStr="Earley, 1970" startWordPosition="128" endWordPosition="129">ide and early language model integration on the target language side. We also examine how different strategies of target-side terminal attachment during binarization can significantly affect translation quality. 1 Introduction Synchronous context-free grammars (SCFG) are behind most syntax-based machine translation models. Efficient machine translation decoding with an SCFG requires converting the grammar into a binarized form, either explicitly, as in synchronous binarization (Zhang et al., 2006), where virtual nonterminals are generated for binarization, or implicitly, as in Earley parsing (Earley, 1970), where dotted items are used. Given a source-side binarized SCFG with terminal set T and nonterminal set N, the time complexity of decoding a sentence of length n with a m-gram language model is (Venugopal et al., 2007): O(n3(|N |· |T |2(m−1))K) where K is the maximum number of right-hand-side nonterminals. SCFG binarization serves two important goals: • Parsing complexity for unbinarized SCFG grows exponentially with the number of nonterminals on the right-hand side of grammar rules. Binarization ensures cubic time decoding in terms of input sentence length. • In machine translation, integra</context>
</contexts>
<marker>Earley, 1970</marker>
<rawString>Jay Earley. 1970. An efficient context-free parsing algorithm. Communications of the ACM, 6(8):451–455.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Eisner</author>
</authors>
<title>Expectation semirings: Flexible EM for learning finite-state transducers.</title>
<date>2001</date>
<booktitle>In Proceedings of the ESSLLI workshop on finite-state methods in NLP. Citeseer.</booktitle>
<contexts>
<context position="10578" citStr="Eisner, 2001" startWordPosition="1788" endWordPosition="1789"> = 0 For terminals, p(γℓ) can be estimated by counting the source side of the training corpus. For nonterminals, we simply assume p(γℓ) = 1. With the hyperedge cost e, the cost of a binarization tree t is EhEt e(h), i.e., the expected number of hyperedges to be built when a particular binarization of a rule is applied to unseen data.3 The operators 2In this definition, k does not appear on the right-hand side of the equation because all edges leading to the same span share the same cost value. 3Although this cost function is defined as an expectation, it does not form an expectation semiring (Eisner, 2001) because k _ f T if k is a permissible split of (i, j) b((i , ,�)) F otherwise binit(i) = T 403 for the cost a are the usual (min, +) operators on real numbers. 2.3 Maximizing Nonterminal Sharing During binarization, newly created virtual nonterminals are named according to the symbols (terminals and nonterminals) that they generate. For example, a new virtual nonterminal covering two nonterminals NP and VP is named NP+VP. To achieve maximum virtual nonterminal sharing, we also define a cost function n to count the number new nonterminals generated by a binarization tree. We keep track of all </context>
</contexts>
<marker>Eisner, 2001</marker>
<rawString>J. Eisner. 2001. Expectation semirings: Flexible EM for learning finite-state transducers. In Proceedings of the ESSLLI workshop on finite-state methods in NLP. Citeseer.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Michel Galley</author>
<author>Mark Hopkins</author>
<author>Kevin Knight</author>
<author>Daniel Marcu</author>
</authors>
<title>What’s in a translation rule?</title>
<date>2004</date>
<booktitle>In Proceedings of the 2004 Meeting of the North American chapter of the Association for Computational Linguistics (NAACL-04),</booktitle>
<pages>273--280</pages>
<contexts>
<context position="14347" citStr="Galley et al., 2004" startWordPosition="2422" endWordPosition="2425"> experiment that late target side terminal attachment significantly outperforms early target side terminal attachment. Although the problem can be alleviated by precomputing a language model score for the original unbinarized rule and applying the heuristic to its binarized rules, this still grants no benefit over late terminal attachment. We show in our experiment that late target-side terminal attachment significantly outperforms early target side terminal attachment. 3 Experiments 3.1 Setup We test our binarization algorithm on an ChineseEnglish translation task. We extract a GHKM grammar (Galley et al., 2004) from a parallel corpus with the parsed English side with some modification so ADJP RB responsible for the NN PP RB :ft* PP 的 NN, 404 10 100 Seconds / Sentence (log scale) 10 100 Seconds / Sentence (log scale) Figure 3: BLEU Scores vs Decoding Time as not to extract unary rules (Chung et al., 2011). The corpus consists of 250K sentence pairs, which is 6.3M words on the English side. A 392-sentence test set was to evaluate different binarizations. Decoding is performed by a general CYK SCFG decoder developed in-house and a trigram language model is used. The decoder runs the CYK algorithm with </context>
</contexts>
<marker>Galley, Hopkins, Knight, Marcu, 2004</marker>
<rawString>Michel Galley, Mark Hopkins, Kevin Knight, and Daniel Marcu. 2004. What’s in a translation rule? In Proceedings of the 2004 Meeting of the North American chapter of the Association for Computational Linguistics (NAACL-04), pages 273–280.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Joshua Goodman</author>
</authors>
<title>Semiring parsing.</title>
<date>1999</date>
<journal>Computational Linguistics,</journal>
<volume>25</volume>
<issue>4</issue>
<contexts>
<context position="5540" citStr="Goodman, 1999" startWordPosition="878" endWordPosition="879">r k = i + 1 ... j − 1 do t &lt;-- T[i, k] + T[k, j] + c((i, k, j)) T[i, j] &lt;-- min(T[i, j], t) Even with the synchronous binarization constraint, many possible binarizations exist. Analysis of our Chinese-English parallel corpus has shown that the majority of synchronously binarizable rules with arity smaller than 4 are monotonic, i.e., the target-side nonterminal permutation is either strictly increasing or decreasing (See Figure 1). For monotonic rules, any source-side binarization is also a permissible synchronous binarization. The binarization problem can be formulated as a semiring parsing (Goodman, 1999) problem. We define a cost function that considers different binarization criteria. A CYK-like algorithm can be used to find the best binarization tree according to the cost function. Consider an SCFG rule X -* (γ, α), where γ and α stand for the source side and the target side. Let B(γ) be the set of all possible binarization trees for γ. With the cost function c defined over hyperedges in a binarization tree t, the optimal binarization tree t is 1: t� = argmin c(h) t∈B(γ) h∈t where c(h) is the cost of a hyperedge h in t. The optimization problem can be solved by Algorithm 1. (i, k, j) denote</context>
</contexts>
<marker>Goodman, 1999</marker>
<rawString>Joshua Goodman. 1999. Semiring parsing. Computational Linguistics, 25(4):573–605.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Mark Hopkins</author>
<author>Greg Langmead</author>
</authors>
<title>SCFG decoding without binarization.</title>
<date>2010</date>
<booktitle>In Proceedings of the 2010 Conference on Empirical Methods in Natural Language Processing,</booktitle>
<pages>646--655</pages>
<publisher>Association</publisher>
<institution>for Computational Linguistics.</institution>
<location>Cambridge, MA,</location>
<contexts>
<context position="2178" citStr="Hopkins and Langmead (2010)" startWordPosition="330" endWordPosition="333">e is essential to reducing search errors. Synchronous binarization (Zhang et al., 2006) enables the decoder to incorporate language model scores as soon as a binarized rule is applied. In this paper, we examine a CYK-like synchronous binarization algorithm that integrates a novel criterion in a unified semiring parsing framework. The criterion we present has explicit consideration of source-side terminals. In general, terminals in a rule have a lower probability of being matched given a sentence, and therefore have the effect of “anchoring” a rule and limiting its possible application points. Hopkins and Langmead (2010) formalized this concept as the scope of a rule. A rule of scope of k can be parsed in O(nk). The scope of a rule can be calculated by counting the number of adjacent nonterminal pairs and boundary nonterminals. For example, A → w1BCw2D has scope two. Building on the concept of scope, we define a cost function that estimates the expected number of hyperedges to be built when a particular binarization tree is applied to unseen data. This effectively puts hard-to-match derivations at the bottom of the binarization tree, which enables the decoder to decide early on whether an unbinarized rule can</context>
</contexts>
<marker>Hopkins, Langmead, 2010</marker>
<rawString>Mark Hopkins and Greg Langmead. 2010. SCFG decoding without binarization. In Proceedings of the 2010 Conference on Empirical Methods in Natural Language Processing, pages 646–655, Cambridge, MA, October. Association for Computational Linguistics.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Liang Huang</author>
<author>Hao Zhang</author>
<author>Daniel Gildea</author>
<author>Kevin Knight</author>
</authors>
<title>Binarization of synchronous context-free grammars.</title>
<date>2009</date>
<journal>Computational Linguistics,</journal>
<volume>35</volume>
<issue>4</issue>
<contexts>
<context position="12590" citStr="Huang et al., 2009" startWordPosition="2136" endWordPosition="2139">d, we can produce distinct binarized rules by choosing different ways of attaching target-side terminals: ADJP [RB :ft*]1 ( [PP 的]3 NN )2, [RB]1 ( resp. for the NN [PP]3 )2 ADJP [RB :ft*]1 ( [PP 的]3 NN )2, [RB]1 resp. for the ( NN [PP]3 )2 The first binarization is generated by attaching the target-side terminals as low as possible in a postit is defined as an expectation over input strings, instead of an expectation over trees. order traversal of the binarization tree. The conventional wisdom is that early consideration of targetside terminals promotes early language model score integration (Huang et al., 2009). The second binarization, on the contrary, attaches the target-side terminals as high as possible in the binarization tree. We argue that this late target-side terminal attachment is in fact better for two reasons. First, as in the example above, compare the following two rules resulting from early attachment of target terminals and late attachment of target terminals: ()2 []3 NN, resp. for the NN []3 ()2 []3 NN, NN []3 The former has a much smaller chance of sharing the same target side with other binarized rules because on the target side, many nonterminals will be attached without any lexi</context>
</contexts>
<marker>Huang, Zhang, Gildea, Knight, 2009</marker>
<rawString>Liang Huang, Hao Zhang, Daniel Gildea, and Kevin Knight. 2009. Binarization of synchronous context-free grammars. Computational Linguistics, 35(4):559–595.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Liang Huang</author>
</authors>
<title>Binarization, synchronous binarization, and target-side binarization.</title>
<date>2007</date>
<booktitle>In Proceedings of the NAACL/AMTA Workshop on Syntax and Structure in Statistical Translation (SSST),</booktitle>
<pages>33--40</pages>
<location>Rochester, NY.</location>
<contexts>
<context position="4748" citStr="Huang, 2007" startWordPosition="737" endWordPosition="738">off to the +LM decoding phase (DeNero et al., 2009a). Although these ideas all lead to faster decoding and reduced search errors, there can be conflicts in the constraints each of them has on the form of rules and accommodating all of them can be a challenge. In this paper, we present a cubic time algorithm to find the best binarization tree, given the conflicting constraints. 2 The Binarization Algorithm An SCFG rule is synchronously binarizable if when simultaneously binarizing source and target sides, virtual nonterminals created by binarizations always have contiguous spans on both sides (Huang, 2007). Algorithm 1 The CYK binarization algorithm. CYK-BINARIZE(X -* (γ, α)) for i = 0...|γ |− 1 do T[i, i + 1] &lt;-- cinit(i) for s = 2 ... |γ |do for i = 0 ... |γ|-1 do j &lt;-- i + s for k = i + 1 ... j − 1 do t &lt;-- T[i, k] + T[k, j] + c((i, k, j)) T[i, j] &lt;-- min(T[i, j], t) Even with the synchronous binarization constraint, many possible binarizations exist. Analysis of our Chinese-English parallel corpus has shown that the majority of synchronously binarizable rules with arity smaller than 4 are monotonic, i.e., the target-side nonterminal permutation is either strictly increasing or decreasing (S</context>
</contexts>
<marker>Huang, 2007</marker>
<rawString>Liang Huang. 2007. Binarization, synchronous binarization, and target-side binarization. In Proceedings of the NAACL/AMTA Workshop on Syntax and Structure in Statistical Translation (SSST), pages 33–40, Rochester, NY.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ashish Venugopal</author>
<author>Andreas Zollmann</author>
<author>Stephan Vogel</author>
</authors>
<title>An efficient two-pass approach to synchronous-CFG driven statistical MT.</title>
<date>2007</date>
<booktitle>In NAACL07,</booktitle>
<location>Rochester, NY,</location>
<contexts>
<context position="1125" citStr="Venugopal et al., 2007" startWordPosition="166" endWordPosition="169">. 1 Introduction Synchronous context-free grammars (SCFG) are behind most syntax-based machine translation models. Efficient machine translation decoding with an SCFG requires converting the grammar into a binarized form, either explicitly, as in synchronous binarization (Zhang et al., 2006), where virtual nonterminals are generated for binarization, or implicitly, as in Earley parsing (Earley, 1970), where dotted items are used. Given a source-side binarized SCFG with terminal set T and nonterminal set N, the time complexity of decoding a sentence of length n with a m-gram language model is (Venugopal et al., 2007): O(n3(|N |· |T |2(m−1))K) where K is the maximum number of right-hand-side nonterminals. SCFG binarization serves two important goals: • Parsing complexity for unbinarized SCFG grows exponentially with the number of nonterminals on the right-hand side of grammar rules. Binarization ensures cubic time decoding in terms of input sentence length. • In machine translation, integrating language model states as early as possible is essential to reducing search errors. Synchronous binarization (Zhang et al., 2006) enables the decoder to incorporate language model scores as soon as a binarized rule i</context>
</contexts>
<marker>Venugopal, Zollmann, Vogel, 2007</marker>
<rawString>Ashish Venugopal, Andreas Zollmann, and Stephan Vogel. 2007. An efficient two-pass approach to synchronous-CFG driven statistical MT. In NAACL07, Rochester, NY, April.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Dekai Wu</author>
</authors>
<title>Stochastic inversion transduction grammars and bilingual parsing of parallel corpora.</title>
<date>1997</date>
<journal>Computational Linguistics,</journal>
<volume>23</volume>
<issue>3</issue>
<contexts>
<context position="8447" citStr="Wu (1997)" startWordPosition="1408" endWordPosition="1409">le guarantees that we will find a tree that is a synchronously binarized if one exists. 2.2 Early Source-Side Terminal Matching When a rule is being applied while parsing a sentence, terminals in the rule have less chance of being matched. We can exploit this fact by taking terminals into account during binarization and placing terminals lower in the binarization tree. Consider the following SCFG rule: PP VM JJ NN, VP � propose a JJ NN PP The synchronous binarization algorithm of Zhang et al. (2006) binarizes the rule1 by finding the rightmost binarizable points on the source side: 1We follow Wu (1997) and use square brackets for straight rules and pointed brackets for inverted rules. We also mark brackets with indices to represent virtual nonterminals. PP [VM [JJ NN]1]2, VP � [[propose a JJ NN]1]2 PP The source side of the first binarized rule “[]1 → JJ NN, propose a JJ NN” contains a very frequent nonterminal sequence “JJ NN”. If one were to parse with the binarized rule, and if the virtual nonterminal []1 has been built, the parser needs to continue following the binarization tree in order to determine whether the original rule would be matched. Furthermore, having two consecutive nonter</context>
</contexts>
<marker>Wu, 1997</marker>
<rawString>Dekai Wu. 1997. Stochastic inversion transduction grammars and bilingual parsing of parallel corpora. Computational Linguistics, 23(3):377–403.</rawString>
</citation>
<citation valid="true">
<authors>
<author>T Xiao</author>
<author>M Li</author>
<author>D Zhang</author>
<author>J Zhu</author>
<author>M Zhou</author>
</authors>
<title>Better synchronous binarization for machine translation.</title>
<date>2009</date>
<booktitle>In Proceedings of the 2009 Conference on Empirical Methods in Natural Language Processing: Volume</booktitle>
<volume>1</volume>
<pages>362--370</pages>
<publisher>Association</publisher>
<institution>for Computational Linguistics.</institution>
<contexts>
<context position="3510" citStr="Xiao et al. (2009)" startWordPosition="542" endWordPosition="545">different strategies should produce equivalent translation results. However, because decoding always involves 401 Proceedings of the 49th Annual Meeting of the Association for Computational Linguistics:shortpapers, pages 401–406, Portland, Oregon, June 19-24, 2011. c�2011 Association for Computational Linguistics 1 2 3 4 5 6 7 Number of right-hand-side nonterminals Figure 1: Rule Statistics pruning, we show that different strategies do have a significant effect in translation quality. Other works investigating alternative binarization methods mostly focus on the effect of nonterminal sharing. Xiao et al. (2009) also proposed a CYKlike algorithm for synchronous binarization. Apparently the lack of virtual nonterminal sharing in their decoder caused heavy competition between virtual nonterminals, and they created a cost function to “diversify” binarization trees, which is equivalent to minimizing nonterminal sharing. DeNero et al. (2009b) used a greedy method to maximize virtual nonterminal sharing on the source side during the -LM parsing phase. They show that effective source-side binarization can improve the efficiency of parsing SCFG. However, their method works only on the source side, and synchr</context>
</contexts>
<marker>Xiao, Li, Zhang, Zhu, Zhou, 2009</marker>
<rawString>T. Xiao, M. Li, D. Zhang, J. Zhu, and M. Zhou. 2009. Better synchronous binarization for machine translation. In Proceedings of the 2009 Conference on Empirical Methods in Natural Language Processing: Volume 1-Volume 1, pages 362–370. Association for Computational Linguistics.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Hao Zhang</author>
<author>Liang Huang</author>
<author>Daniel Gildea</author>
<author>Kevin Knight</author>
</authors>
<title>Synchronous binarization for machine translation.</title>
<date>2006</date>
<booktitle>In Proceedings of the 2006 Meeting of the North American chapter of the Association for Computational Linguistics (NAACL-06),</booktitle>
<pages>256--263</pages>
<location>New York, NY.</location>
<contexts>
<context position="794" citStr="Zhang et al., 2006" startWordPosition="110" endWordPosition="113">resent an SCFG binarization algorithm that combines the strengths of early terminal matching on the source language side and early language model integration on the target language side. We also examine how different strategies of target-side terminal attachment during binarization can significantly affect translation quality. 1 Introduction Synchronous context-free grammars (SCFG) are behind most syntax-based machine translation models. Efficient machine translation decoding with an SCFG requires converting the grammar into a binarized form, either explicitly, as in synchronous binarization (Zhang et al., 2006), where virtual nonterminals are generated for binarization, or implicitly, as in Earley parsing (Earley, 1970), where dotted items are used. Given a source-side binarized SCFG with terminal set T and nonterminal set N, the time complexity of decoding a sentence of length n with a m-gram language model is (Venugopal et al., 2007): O(n3(|N |· |T |2(m−1))K) where K is the maximum number of right-hand-side nonterminals. SCFG binarization serves two important goals: • Parsing complexity for unbinarized SCFG grows exponentially with the number of nonterminals on the right-hand side of grammar rules</context>
<context position="8342" citStr="Zhang et al. (2006)" startWordPosition="1388" endWordPosition="1391">g operators (min, +) defined for the cost b are (V, ∧). Using b as the first cost function in the cost function tuple guarantees that we will find a tree that is a synchronously binarized if one exists. 2.2 Early Source-Side Terminal Matching When a rule is being applied while parsing a sentence, terminals in the rule have less chance of being matched. We can exploit this fact by taking terminals into account during binarization and placing terminals lower in the binarization tree. Consider the following SCFG rule: PP VM JJ NN, VP � propose a JJ NN PP The synchronous binarization algorithm of Zhang et al. (2006) binarizes the rule1 by finding the rightmost binarizable points on the source side: 1We follow Wu (1997) and use square brackets for straight rules and pointed brackets for inverted rules. We also mark brackets with indices to represent virtual nonterminals. PP [VM [JJ NN]1]2, VP � [[propose a JJ NN]1]2 PP The source side of the first binarized rule “[]1 → JJ NN, propose a JJ NN” contains a very frequent nonterminal sequence “JJ NN”. If one were to parse with the binarized rule, and if the virtual nonterminal []1 has been built, the parser needs to continue following the binarization tree in </context>
<context position="11931" citStr="Zhang et al. (2006)" startWordPosition="2024" endWordPosition="2027">ed new if it is previously unseen in binarizing rules 1 to i−1. This greedy approach is similar to that of DeNero et al. (2009b). The cost function is thus defined as: � _ 1 if the VT for span (i, j) is new n ((i, k, j)) 0 otherwise ninit(i) = 0 The semiring operators for this cost are also (min, +) on real numbers. 2.4 Late Target-Side Terminal Attachment Once the optimal source-side binarization tree is found, we have a good deal of freedom to attach target-side terminals to adjacent nonterminals, as long as the bracketing of nonterminals is not violated. The following example is taken from Zhang et al. (2006): With the source-side binarization fixed, we can produce distinct binarized rules by choosing different ways of attaching target-side terminals: ADJP [RB :ft*]1 ( [PP 的]3 NN )2, [RB]1 ( resp. for the NN [PP]3 )2 ADJP [RB :ft*]1 ( [PP 的]3 NN )2, [RB]1 resp. for the ( NN [PP]3 )2 The first binarization is generated by attaching the target-side terminals as low as possible in a postit is defined as an expectation over input strings, instead of an expectation over trees. order traversal of the binarization tree. The conventional wisdom is that early consideration of targetside terminals promotes </context>
<context position="15076" citStr="Zhang et al. (2006)" startWordPosition="2549" endWordPosition="2552">PP RB :ft* PP 的 NN, 404 10 100 Seconds / Sentence (log scale) 10 100 Seconds / Sentence (log scale) Figure 3: BLEU Scores vs Decoding Time as not to extract unary rules (Chung et al., 2011). The corpus consists of 250K sentence pairs, which is 6.3M words on the English side. A 392-sentence test set was to evaluate different binarizations. Decoding is performed by a general CYK SCFG decoder developed in-house and a trigram language model is used. The decoder runs the CYK algorithm with cube-pruning (Chiang, 2007). In all our experiments, we discard unbinarizable rules, which have been shown by Zhang et al. (2006) to have no significant effect on translation accuracy. 3.2 Results We first discuss effects of maximizing nonterminal sharing. Having nonterminal sharing maximization as a part of the cost function for binarization did yield slightly smaller grammars. However, we could not discern any noticeable difference or trend in terms of BLEU score, decoding speed, or model score when comparing translation results that used grammars that employed nonterminal sharing maximization and ones that did not. In the rest of this section, all the results we discuss use nonterminal sharing maximization as a part </context>
</contexts>
<marker>Zhang, Huang, Gildea, Knight, 2006</marker>
<rawString>Hao Zhang, Liang Huang, Daniel Gildea, and Kevin Knight. 2006. Synchronous binarization for machine translation. In Proceedings of the 2006 Meeting of the North American chapter of the Association for Computational Linguistics (NAACL-06), pages 256–263, New York, NY.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>