<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<title confidence="0.994648">
Computing with Features as Formulae
</title>
<author confidence="0.998677">
Mark Johnson&apos;
</author>
<affiliation confidence="0.835209">
Brown University
</affiliation>
<bodyText confidence="0.998621375">
This paper extends the approach to feature structures developed in Johnson (1991a), which uses
Schtinfinkel-Bernays&apos; formulae to express feature structure constraints. These are shown to be a
disjunctive generalization of Data log clauses, as used in database theory. This paper provides a
fixed-point characterization of the minimal models of these formulae that serves as the theoretical
foundation of a forward-chaining algorithm for determining their satisfiability. This algorithm,
which generalizes the standard attribute-value unification algorithm, is also recognizable as a
nondeterministic variant of the semi-naive bottom-up algorithm for evaluating Datalog programs.
further strengthening the connection between the theory of feature structures and databases.
</bodyText>
<sectionHeader confidence="0.990269" genericHeader="abstract">
1. Introduction
</sectionHeader>
<bodyText confidence="0.999945333333333">
Despite their simplicity, a surprisingly wide range of linguistic phenomena can be de-
scribed in terms of simple equality constraints on values in attribute-value structures,
which are a particularly simple kind of feature structure (see Shieber 1986; Johnson
1988; Uszkoreit 1986; and Bresnan 1982 for examples of some of these analyses). But
some phenomena do not seem to be able to be described in such a pure &apos;unification&apos;
framework. For example, the analysis of conjunctions in LFG (Kaplan and Maxwell
1988b) and the formalizations of Discourse Representation Theory (Kamp 1981) pre-
sented in Johnson and Klein (1986) and Johnson and Kay (1990) require additional
mechanisms for representing and manipulating aggregates or sets of values in ways
that are beyond the capability of such &amp;quot;pure&amp;quot; attribute-value systems. Further, sortal
constraints (which also cannot be expressed as simple equality constraints) can be used
to formulate simpler and more comprehensible grammars (Carpenter 1992; Carpenter
and Pollard 1991; Pollard and Sag 1987, 1992).
Versions of both of these kinds of constraint, as well as the familiar attribute-value
constraints, can be expressed as Schonfinkel-Bernays&apos; formulae (as demonstrated in John-
son 1991a, 1991b), so that the problem of determining the satisfiability of a system of
such constraints is reduced to the satisfiability problem for the corresponding formula.
This class of formulae (defined in Section 3.1) seems to be expressive enough for most
linguistic purposes when used with an external phrase-structure backbone. That is,
these formulae are used as annotations on phrase structure rules in the manner de-
scribed in, e.g., Kaplan and Bresnan (1982), Shieber (1986), and Johnson (1988). This
paper extends the author&apos;s previous paper on the topic (Johnson 1991a) by sketch-
ing several other linguistic applications of Schonfinkel-Bernays&apos; formulae (including a
version of D-theory [Marcus, Hindle, and Fleck 1983; Vijay-Shanker 1992]), and pre-
senting a least-fixed-point theorem that serves as the theoretical basis for a &amp;quot;forward-
chaining&amp;quot; algorithm for determining satisfiabiIity of Schonfinkel-Bernays&apos; formulae.
Interestingly, this algorithm can be viewed both as a straightforward generalization
</bodyText>
<note confidence="0.584351">
* Cognitive and Linguistic Sciences, Box 1978, Brown University, Providence, RI.
</note>
<email confidence="0.515707">
Mark_Johnson@brown.edu
</email>
<note confidence="0.947823">
(j) 1994 Association for Computational Linguistics
Computational Linguistics Volume 20, Number 1
</note>
<bodyText confidence="0.992849">
of the standard attribute-value unification algorithm and also as a nondeterministic
variant of the semi-naive evaluation method for Datalog clauses.
Several extended &amp;quot;unification-based&amp;quot; constraint formalisms have been developed.
In this paper, the term &amp;quot;feature structure&amp;quot; denotes any kind of structured entity used as
a component of a category label. An attribute-value structure is a particularly simple
kind of feature structure of the kind used in &amp;quot;pure&amp;quot; unification-based frameworks
(Shieber 1986). Some extensions to the basic attribute-value framework are rather weak,
e.g., allowing disjunctive and negative constraints and preserving decidability.1 Such
systems require an &amp;quot;off-line&amp;quot; phrase structure backbone to which these constraints are
attached. It seems that most of the constraints that can be expressed in these formalisms
can be expressed as Schonfinkel-Bernays&apos; formulae, the constraint formalism described
below.
A second class of extended constraint formalisms has been devised to be capable
of expressing the entire grammar as systems of constraints and as far as I know, for all
of these systems the problem of determining the satisfiability of an arbitrary system
of constraints that they can express is undecidable.2 This is because the recognition
problem for an arbitrary &amp;quot;unification-based&amp;quot; grammar is undecidable unless the size
of the phrase structure tree is constrained somehow, e.g., by the offline parsability
constraint (Johnson 1988; Kaplan and Bresnan 1982; Pereira 1982; Shieber 1992), but
there seems to be no natural way to impose such constraints in these systems because
the encoding of the phrase structure tree in the feature structure is not distinguished
from other features.&apos; Thus in order to maintain decidability the system described
here is not designed to be capable of expressing phrase structure constraints directly,
and must be used with an external phrase-structure component, as in LFG (Bresnan
1982). (However, Bob Carpenter [p.c.1 points out that one can impose a bound on the
size of the feature structure that can serve as an analysis [say, some polynomial of
the length of the input], and so ensure decidability.) Interestingly, a first-order logic-
based approach similar to the one presented in this paper can also be developed for
extended constraint formalisms capable of expressing the entire grammar, but this is
not discussed further here; see Johnson (in press b) for details.
In the approach developed here Schonfinkel-Bernays&apos; formulae are used to express
a variety of feature structure constraints. Previous work has shown that these formulae
are expressive enough to define arbitrary disjunctions and negations of constraints
(Johnson 1990a, 1990b), a kind of &apos;set-valued&apos; entity (Johnson 1991a), and they can be
used to impose useful sort constraints (Johnson 1991b). The expression of D-theory
constraints on nodes in trees is discussed in this paper.
This paper extends the ideas in these earlier papers with theoretical results that
suggest a forward-chaining algorithm for determining the satisfiability of an arbi-
trary Schonfinkel-Bernays&apos; formula. This generalizes the standard feature-graph uni-
fication algorithm and is closely related to the semi-naive bottom-up algorithm used
in database theory.
I For examples of this approach see Dawar and Vijay-Shanker (1990), Dorre and Eisele (1990), Johnson
(1988, 1990a, 1990b, 1991a, 1991b, in press a), Karttunen (1984), Kasper (1987a, 19871), 1986), Kasper and
Rounds (1986, 1990), Langholm (1989), Pereira (1987), and Smolka (1992).
</bodyText>
<footnote confidence="0.993112875">
2 Examples of this approach are Carpenter, Pollard, and Franz (1991), Dorre (1991), Done and Eisele
(1991), Johnson (in press b), Kay (1979, 1985a, 1985b), Pollard and Sag (1987), Rounds and
Manaster-Ramer (1987), Smolka (1988), and Zajac (1992).
3 While it may well be that the universal recognition and parsing problems for natural language are
undecidable (Chomsky [1986, 1988] points out that there is no contrary evidence), I know of no
evidence that this is actually the case. It seems reasonable then to also investigate formalisms that can
only express decidable systems of constraints (and for which there exist satisfiability-testing algorithms)
if linguistically adequate systems can be found.
</footnote>
<page confidence="0.974998">
2
</page>
<bodyText confidence="0.927285875">
Mark Johnson Computing with Features as Formulae
Specifically, it is shown that the satisfying Herbrand models of an arbitrary Sefton-
finkel-Bernays&apos; formula are the fix points of certain functions, and that the least fixed
points of these functions are all of the models of the formula that are &amp;quot;minimal&amp;quot; in
a certain sense. This leads to a forward-chaining algorithm for computing all of the
atomic consequences of a Schonfinkel-Bernays&apos; formula; the fixed-point theorem shows
that this suffices to determine the satisfiability of an arbitrary Schonfinkel-Bernays&apos;
formula.
</bodyText>
<sectionHeader confidence="0.675915" genericHeader="method">
2. Constraints, Partial Information, and Feature Structures
</sectionHeader>
<bodyText confidence="0.999984375">
This approach exploits the fact that constraints on well-formed linguistic structures
(e.g., well-formedness constraints imposed by the grammar) do not need to be isomor-
phic to the structures that satisfy them. Although the distinction between constraints
and structures that satisfy them might seem too obvious to warrant comment, it is not
made in most work on feature structures.
A common view holds that feature structures are inherently &amp;quot;partially specified&amp;quot;
entities, which &amp;quot;unify&amp;quot; or merge with other feature structures to yield more instan-
tiated feature structures in an &amp;quot;information-preserving&amp;quot; way (Shieber 1986). If two
feature structures contain &amp;quot;contradictory information,&amp;quot; then it is impossible to merge
them to produce a consistent object; unification is then said to fail. The feature struc-
ture for an utterance is the result (if one exists) of unifying all of the feature structures
for the lexical entries and syntactic rules in appropriate ways. Thus in this view fea-
ture structures play two roles; not only do they serve as linguistic structures, but they
are also used to encode constraints that the linguistic structures must satisfy (see Sec-
tion 2.10 of Johnson (1988) for an extended discussion).
That is, under this view feature structures serve not only as linguistic structures
that may or may not satisfy a constraint, but are also interpreted as &apos;representing&apos; or
&apos;describing&apos; all of the feature structures that they subsume. Given this dual role for
feature structures, it is important in this approach that if a feature structure S satis-
fies a constraint a, then every feature structure subsumed by S should also satisfy a
(Pereira 1987). If this &amp;quot;upward closure&amp;quot; property holds, then the set of feature struc-
tures satisfying any constraint can be represented by the set of its &amp;quot;minimal models.&amp;quot;
Unfortunately, many useful constraints do not have this property. For example, un-
der a classical interpretation, the set of feature structures satisfying negated feature
structure constraints are not upward-closed (Moshier and Rounds 1987).
The work described in this paper pursues a different approach. Following Kaplan
and Bresnan (1982), feature structures are only (components of) linguistic structures,
and not partial descriptions of (other) linguistic structures. As such, a feature struc-
ture either does or does not satisfy any particular set of constraints. An utterance is
well-formed just in case there is some linguistic structure that satisfies all of the con-
straints imposed by the grammar and has the phonological form of that utterance as
its phonological form (which itself is just another constraint that the structure must
satisfy). Since the relationship between a feature structure and a constraint that it satis-
fies is essentially the same as the relationship between an interpretation and a formula
that is true under that interpretation, it seems natural to conceive of a constraint as
a kind of formula (in a format that allows efficient computational manipulation) that
has feature structures as its intended interpretations.
This approach is more general in that it does not rely on the upward-closure
property, and it allows constraints on feature structures to have a structure quite
different from the feature structures that they constrain. The subsurription relation on
</bodyText>
<page confidence="0.997956">
3
</page>
<note confidence="0.925039">
Computational Linguistics Volume 20, Number 1
</note>
<bodyText confidence="0.999870653846154">
feature structures plays no special role in this approach; specifically, it is not required
that the set of structures that satisfy a constraint be upward-closed.
In general, a linguistic structure S must satisfy several constraints, say al, ,
in order to be well formed, so in order to solve the recognition and parsing problems,
all we need do is determine if there are any S that satisfy al, , a„, and if so, describe
them somehow.
It is convenient to devise a language for expressing constraints, so that the al
are well-formed formulae of this language, and its satisfaction relation is exactly the
satisfaction relation mentioned above. Viewed from this perspective, the problem of
determining if there is a structure S that satisfies the constraints at, ..., a, is the same
as the problem of determining if the formula a is satisfiable, where a is al A • • &apos; A an
and conjunction is given the standard interpretation. Algorithms for deciding the sat-
isfiability of arbitrary formulae in this language (if they exist) can therefore be used to
determine the satisfiability of the linguistic constraints. Moreover, if a a&apos; then a&apos; is
a true description of every model of a, i.e., the logical consequences of a are descrip-
tions of every well-formed linguistic structure that satisfies the constraints. Thus the
logic of the constraint language provides in principle all the necessary tools for deter-
mining if a set of constraints are satisfiable, and if they are, providing descriptions of
the satisfying structures.
From this perspective, an &amp;quot;information state&amp;quot; is a kind of formula, and &amp;quot;unify-
ing&amp;quot; two such information states is accomplished by conjoining them and simplifying
the resulting formula, not by some manipulation of their models. Partial information
states are those that are satisfied by more than one interpretation. The consequence
relation corresponds to the subsumption relation of traditional unification grammar (a
formula a &amp;quot;contains more information&amp;quot; than formula a&apos; iff a a`), and unsatisfiability
corresponds to unification failure.
</bodyText>
<sectionHeader confidence="0.966509" genericHeader="method">
3. Languages for Expressing Feature Structure Constraints
</sectionHeader>
<bodyText confidence="0.999279923076923">
There are many different possible constraint languages. Specialized languages can be
constructed specifically for the task of expressing feature structure constraints (such
as Kasper and Rounds&apos;s FDL [Kasper and Rounds 19901 and Johnson&apos;s attribute-value
languages [Johnson 19881). Alternatively, the constraints may be able to be expressed
in some standard language, so that the satisfiability problem for linguistic constraints
is reduced to the satisfiability problem for that language, as is done here.&apos;
Johnson (1990a), following a suggestion first made in Kaplan and Bresnan (1982),
showed how attribute-value constraints could be formalized in the quantifier-free sub-
set of first-order logic, while later work (Johnson 1991a, 1991b) proposed a different
formalization in the Schanfinkel-Bernays&apos; subset of first-order formulae.&apos;
Roughly speaking, there is a trade-off between the expressive power of a language
and its computational tractability. For example, the satisfiability problem for the lan-
guage consisting of conjunctions of equalities and inequalities of first-order terms can
</bodyText>
<footnote confidence="0.968280555555556">
4 A third approach, developed by Smolka (1992), is to define a specialized language tailored for
expressing attribute-value constraints and note its translation into some standard language, in this case,
also the Schonfinkel-Bernays&apos; class.
5 Of course, there is no a priori reason for these subsets of first-order logic to be optimally suited for
expressing feature structure constraints. Kasper and Rounds (1990) and more recently Blackburn (1991)
and Blackburn and Spam (1992) have suggested that it may be useful to express feature structure
constraints in a special kind of modal logic. Johnson (1991b) also discusses the application of general
first-order logic and nonmonotic logics to the specification of more complex constraints on feature
structures.
</footnote>
<page confidence="0.963548">
4
</page>
<bodyText confidence="0.966868071428571">
Mark Johnson Computing with Features as Formulae
be decided in quasi-linear time using the congruence-closure algorithm, but this lan-
guage can only express conjunctions of feature-value equalities and inequalities. If
this language is extended to allow disjunctions (so that disjunctive feature-value con-
straints can be expressed), the satisfiability problem becomes NP-complete (Gallier
1986; Kasper and Rounds 1990; Nelson and Oppen 1980).
Since disjunctive constraints seem to be a practical necessity for describing natural
languages (Barton, Berwick, and Ristad 1987; Karthinen 1984), most practical feature
structure systems will probably have NP-hard satisfiability problems. Given that we
have to solve an NP-hard problem anyway, it seems reasonable to investigate the most
expressive feature structure constraint language that has an NP-complete satisfiability
problem. The Schonfinkel-Bernays&apos; class, used in the manner described here, appears
to be the most expressive language for feature structure constraints proposed in the
literature so far whose satisfiability problem is no harder than NP.
</bodyText>
<subsectionHeader confidence="0.999936">
3.1 The Schonfinkel-Bernays&apos; Class
</subsectionHeader>
<bodyText confidence="0.9997205">
The Schonfinkel-Bernays&apos; class (hereafter 513) is the class of first-order closed prenex
formulae without function symbols in which no existential quantifier occurs in the
scope of any universal quantifier. That is, a formula is in SB iff it has no free variables
and is of the form
</bodyText>
<equation confidence="0.588486">
\ix] Vx„ce,
</equation>
<bodyText confidence="0.999978142857143">
where a contains no quantifier symbols or function symbols. SB formulae are a proper
subset of first-order formulae, and they are interpreted in exactly the same way as first-
order formulae. The body a may contain boolean connectives (including negation),
which can be used to express arbitrary boolean combinations of constraints.
Unlike the satisfiability problem for full first-order logic, which is undecidable
(co-recursively enumerable), the satisfiability problem for SB is decidable; in fact it is
PSPACE-complete (Lewis and Papadimitriou 1981). Further, if SB„ is the class of SB
formulae with n or fewer universal quantifiers, then for any fixed n the satisfiability
problem for 513n is NP-complete (Lewis 1980). In the applications described here, the
number of universal quantifiers is fixed (i.e., it does not vary with the utterance or even
with the grammar), so the corresponding satisfiability problems are all NP-complete.
The class of SB formulae is interesting for other reasons besides its ability to express
a wide range of linguistic constraints. As shown below, the class of SB formulae in
clausal form constitute an extension of Datalog that allows disjunctive consequents.
</bodyText>
<subsectionHeader confidence="0.999979">
3.2 Formalizing Attribute-Value Structures Using SIB
</subsectionHeader>
<bodyText confidence="0.999878416666667">
SB is both simple and expressive enough that grammar designers might choose to
state linguistic constraints directly in SB, rather than in terms of attributes and val-
ues. Nevertheless, it is important to understand how the properties of attribute-value
structures can be stated in SB, since many of the techniques used to formalize them
can be applied to other linguistically interesting structures as well.
In fact there are several ways of formalizing attribute-value structures in SB, all of
which seem to be linguistically equivalent. What follows is a formalization in SB that
allows values to be used as attributes and allows attributes to be quantified over (this
is handy for stating &amp;quot;sort constraints&amp;quot;), but no special claims are made for it over and
above any other SB formalization.
Following Johnson (1991b), attribute-value feature structures can be specified in
SB in the following way. We can conceptualize of attribute-value arcs as instances of
</bodyText>
<page confidence="0.977216">
5
</page>
<note confidence="0.540903">
Computational Linguistics Volume 20, Number 1
</note>
<bodyText confidence="0.981485428571429">
a three-place relation arc, where arc(x,a, y) means that there is an arc leaving node x
labeled a pointing to node y.6
Of course, not all interpretations qualify as attribute-value structures; e.g., those
which satisfy both arc(x,a,y) and arc(x,a,z) for some y z violate the requirement
that there is at most one arc with any given label leaving any node. We can express
this requirement as an SB formula that is true in the intended interpretations (namely
attribute-value feature structures).
</bodyText>
<subsectionHeader confidence="0.766088">
Vx Va Vy Vz arc(x,a,y) A arc(x,a,z) y =Z. (1)
</subsectionHeader>
<bodyText confidence="0.99994425">
Similarly, we can express the properties of the &amp;quot;attribute-value constants&amp;quot; with SB
formulae. Let con be a property (i.e., a one-place relation) true of the &amp;quot;attribute-value
constant&amp;quot; elements. These elements are required to have no arcs leaving them. The
following formula expresses this requirement.
</bodyText>
<equation confidence="0.869889">
Vx Va Vy (con(x) A arc(x.a,y)). (2)
</equation>
<bodyText confidence="0.999873">
Note that the word &amp;quot;constant&amp;quot; in the name &amp;quot;attribute-value constant&amp;quot; is misleading
here, since in this framework not all SB constant symbols will denote attribute-value
&amp;quot;constants.&amp;quot; More precisely, being an &apos;attribute-value constant&apos; is a property of an
individual in an interpretation (i.e., an element of a feature structure), whereas being
a constant is a property of a symbol in a formula. Constants can be used to denote
complex attribute-value entities as well as attribute-value constants.
Finally, we require that the names of attribute-value constants denote distinct
attribute-value constants. We reserve a finite subset N of the constants of our language
for use as the names of attribute-value constants, and require that they satisfy the
following schemata.&apos;
</bodyText>
<equation confidence="0.8073545">
For each c in N, con(c). (3)
For each distinct pair c1, C2 in N, c1 c2. (4)
</equation>
<bodyText confidence="0.9961502">
Schema (3) requires each symbol in N to denote an attribute-value constant, and
schema (4) enforces distinctness in essentially the same manner as that used in the
specification systems of algebraic data-type theory (Kapur and Musser 1987).
Formulas (1) and (2) and the instances of schemata (3) and (4) can be regarded
as defining attribute-value feature structures. These axioms are quite permissive: in
</bodyText>
<footnote confidence="0.65474725">
6 Johnson (1991a) and Smolka (1992) propose that an attribute-value arc labeled a from x to y be
conceptualized as an instance of a two-place relation a(x, y). For most applications there is little
substantive difference between these two approaches; the approach taken here allows attributes to be
quantified over, e.g., to state sortal constraints, and permits values to be used as attributes, as in e.g.,
T,FG (Kaplan and Bresnan 1982); for discussion and linguistic applications see also Johnson (1988).
7 As Patrick Blackburn (p.c.) points out, one consequence of this is that every model of these constraints
will contain individuals corresponding to each attribute-value constant (since each constant symbol
will be assigned a denotation). Whether this is desirable or problematic is debatable, but as he pointed
out, it is easy to devise a conceptualization in which each attribute-value constant c, is conceptualized
as a one-place predicate ci(•) that is true of at most one element. Under such a conceptualization
(which can be formalized in SB as shown below) attribute-value constants would be the unique
members of one-element sorts.
</footnote>
<listItem confidence="0.842068333333333">
(i) For each c in N, Vi Vy c(x) A c(y) x y. (Uniqueness)
(ii) For each c in N, Vi c(x) con(x). (Constant property)
(iii) For each distinct pair c1,c2 in N, Vx (cl(x) A c2(x)). (Disjointness)
</listItem>
<page confidence="0.977114">
6
</page>
<figure confidence="0.997827875">
Mark Johnson Computing with Features as Formulae
arc(n,ai,bi)
al
arc(n,a1,0 A arc(n,a2,n)
12
a2
arc(n,a2,b2)
a2
</figure>
<figureCaption confidence="0.99648">
Figure 1
</figureCaption>
<bodyText confidence="0.9775052">
Three constraints expressed as formulae and also depicted graphically.
addition to the usual finite acyclic feature structures, they allow infinite structures,
cyclic structures, structures in which complex values serve as attributes, etc. While
ruled out by fiat in standard treatments, admitting these additional structures causes
no linguistic difficulties that I am aware of (in fact, some analyses crucially depend
on their existence, as described in section 2.1.3 of Johnson [19881), so in the interests
of parsimony additional constraints that forbid them are not stipulated.
In fact, because SB formulae possess the finite model property (i.e., if an SB formula
has a model, then it has a finite model), restricting attention to finite models does not
change the set of satisfiable SB formulae. Therefore it could have no effect on the set of
well-formed utterances. Cyclic feature structures can be prohibited with a constraint
formalizable in SB, as described in Johnson (1991b), and one can express a constraint
in SB that requires that all attributes are &amp;quot;attribute-value constants&amp;quot; (even though there
appears to be no linguistic motivation for such a constraint, and indeed, some analyses
crucially depend on this not being the case, as pointed out in Johnson [19881).
To summarize, the simplest SB axioms defining attribute-value structures are quite
permissive, allowing a wider range of structures to count as attribute-value structures
than many other formalizations. However, all of the major restrictions on attribute-
value structures discussed in the literature either have no effect whatsoever in this
framework, or else can be directly stated as additional SB constraints.
</bodyText>
<subsectionHeader confidence="0.999981">
3.3 Expressing Feature Structure Constraints with SB
</subsectionHeader>
<bodyText confidence="0.9918356">
In this approach, simple attribute-value constraints are represented by quantifier-free
atomic formulae. For example, a constraint that the value of n&apos;s ai arc is 111 would be
represented by the atom arc(n, a1, b1), a constraint that the value of n&apos;s az arc is bz is
represented by arc(n, a2, b2), and a constraint that the value of n&apos;s a arc is the same
as the value of its az arc is represented by the conjunction arc(re , al, rit) A arc(n, a2, 11&apos;)
</bodyText>
<figureCaption confidence="0.940964333333333">
(ri&apos; is the single value of both arcs). These three constraints are depicted graphically in
Figure 1. Note that the graphs in this figure are (depictions of) formulae, not attribute-
value feature structures.
Attribute-value &amp;quot;unification&amp;quot; is the conjunction and simplification of the formu-
lae expressing the constraints to be unified. If all three constraints in the example of
Figure 1 are conjoined together with axioms (1-3) above, then by (1) it follows that
</figureCaption>
<bodyText confidence="0.9886294">
bi = b2. Further, if b1 and b2 are distinct constant symbols in N (thus they name
attribute-value constants), then 171 b2 is an instance of (4), and the conjunction is
therefore unsatisfiable. For further examples and a discussion of how the disjunc-
tion and negation of attribute-value constraints are transparently representable as SB
formulae, see Johnson (1991a, 1991b).
</bodyText>
<page confidence="0.998533">
7
</page>
<note confidence="0.566041">
Computational Linguistics Volume 20, Number .1
</note>
<bodyText confidence="0.9992887">
A major motivation for using SB is that a wide variety of constraints, in addi-
tion to standard attribute-value constraints, can be expressed using it. This allows a
grammar developer to introduce a wide variety of &amp;quot;designer features&amp;quot; with possibly
idiosyncratic, customized properties, while guaranteeing that the composite system is
decidable (usually in NP-time, as noted above).
For example, suppose we want to impose sort restrictions of the following kind.
To abbreviate the lexical entries of verbs we might introduce the one-place predicate
3rd-sg, where 3rd-sg(x) indicates that the value of x&apos;s person attribute is 3rd and x&apos;s
number attribute is singular. This constraint can be expressed using the following SB
formula.
</bodyText>
<equation confidence="0.982199">
V x 3rd-sg(x) arc (x , person, 3rd) A arc(x, number, singular). (5)
</equation>
<bodyText confidence="0.9752477">
Similarly, constraints that restrict the possible values of certain attributes can be im-
posed. For example, one might want to require that the value of every arc labeled
number is either singular or plural. This constraint can be expressed as the following
SB formula.
Vx Vy arc(x , number , y) y = singular V y plural. (6)
These examples demonstrate only a small fraction of the variety of the feature structure
constraints that can be expressed in SB. Even though all of these examples are based
on attribute-value features, other sorts of features can be described in SB as well. For
example, Johnson (1991a) shows how to formulate a variety of constraints on `set-
valued&apos; features in SB.
</bodyText>
<subsectionHeader confidence="0.999646">
3.4 Expressing Tree Structure Constraints with SB Formulae
</subsectionHeader>
<bodyText confidence="0.9997925">
Inspired by the work on description theory or &apos;D-theory&apos; (Marcus, Hindle, and Fleck
1983; Vijay-Shanker 1992), this section shows how some elementary constraints on
precedence and dominance in a tree can be expressed as SB formulae. It differs from
that work in that different kinds of constraints are expressible (Vijay-Shanker was
concerned with the formalization of a different kind of grammar), and that all of the
constraints expressible in the system described below are decidable (this follows from
the fact that they are defined and expressed using SchOnfinkeI-Bernays&apos; formulae).
These constraints are intended to appear as annotations on phrase structure rules (in
the same way that attribute-value constraints do) and could be used to enforce a va-
riety of &amp;quot;long-distance&amp;quot; relationships, such as the co- and contra-indexing constraints
of binding theory (i.e., equality and inequality constraints on the values of index at-
tributes).
The axiomatization begins by defining the primitive tree structure relations precedes
and dominates. Once these primitive tree structure relations are defined, they can be
used to approximate more complex relationships such as c-commands, as described
below. All of these axioms are in the Schonfinkel-Bernays&apos; class, so the satisfiability of
arbitrary boolean combinations of such constraints is decidable.
First, note that the standard definition of trees in terms of the binary relations
&lt; (linear precedence) and D (domination) can be expressed directly as Schonfinkel-
Bernays&apos; formulae. The axioms presented below are just the definitions of trees given
in Partee, ter Meulen, and Wall (1990) and Wall (1972) using the syntax of first-order
logic. Axioms (7a-c) require that &lt; is a strict partial order, and axioms (8a-c) require
</bodyText>
<page confidence="0.930877">
8
</page>
<bodyText confidence="0.297841">
Mark Johnson Computing with Features as Formulae
</bodyText>
<equation confidence="0.92491925">
that D is a weak partial order over the nodes in a tree. In what follows, N(x) is
interpreted as meaning that x is a tree node.
Vx -x &lt; x (irreflexivity) (7a)
Vx Vy x &lt; y -- —iy &lt; x (asymmetry) (7b)
VxVyVzx&lt;yAy&lt;z --+ x &lt;z (transitive closure) (7c)
Vx D(x,x) i-4 N(x) (reflexivity) (8a)
Vx Vy D(x,y) A D(y, x) —&gt; x = y (antisymmetry) (8b)
Vx Vy Vz D(x,y) A D(y, z) .— D(x, z) (transitive closure) (Sc)
</equation>
<bodyText confidence="0.660361">
Axiom (9) requires that there is a node that dominates all other nodes, and axiom
(10) requires that for each pair of nodes either one precedes the other or one dominates
the other. Axiom (11) enforces the &amp;quot;no tangling&amp;quot; constraint.
</bodyText>
<equation confidence="0.992044">
x N(x) A by N(y) D(x,y) (single root condition) (9)
Vx Vy N(x) A N(y) ((x &lt; y V y &lt;
y) V D(y, x))) (exclusivity) (10)
Vw Vx Vy Vz w &lt;x A D(w, y) A D(x, z) y &lt; z (nontangling condition) (11)
</equation>
<bodyText confidence="0.999389">
Finally, the following axioms (implicit in the standard treatments cited above)
require the precedence and dominance relations to range over tree nodes.
</bodyText>
<equation confidence="0.970644">
Vx Vy x &lt; y N(x) A N(y) (12a)
Vx by D(x, y) —4 N(x) A N(y) (12b)
</equation>
<bodyText confidence="0.999783">
This concludes the specification of linear precedence and dominance relations over
nodes. We now turn to the specification of other relations in terms of these. The proper
dominance relation F can be defined in terms of dominance as follows.
</bodyText>
<subsubsectionHeader confidence="0.71572">
Vx Vy P(x,y) y A D(x,y). (13)
</subsubsectionHeader>
<bodyText confidence="0.99979775">
However, many interesting linguistic relations cannot be defined by Schonfinkel-Ber-
nays&apos; axioms. For example, the c-commands relation C is defined by the following
formula (which says that x c-commands y iff x does not dominate y, and every node
z that properly dominates x also properly dominates y).
</bodyText>
<equation confidence="0.635069">
Vx Vy C(x, y) -.D(x,y) A Vz P(z, x) P(z, y). (14)
</equation>
<bodyText confidence="0.998446">
It is easy to see that this definition is not equivalent to a Schenfinkel-Bernays&apos; for-
mula by expanding the equivalence into two implications and moving the embedded
quantifier out.
</bodyText>
<subsubsectionHeader confidence="0.4387105">
Vx Vy Vz C(x,y) —+ (-13(x , y) A (P(z, x) P(z, y))). (14a)
Vx Vy Hz (—D (x , y) A P(z, x) P(z, y)) C (x, y). (14b)
</subsubsectionHeader>
<bodyText confidence="0.9647928">
Formula (14b) is not in S13 because it contains an existential quantifier inside the scope
of a universal quantifier. There are a number of ways to respond to this problem.
First, we can abandon the attempt to work within the Schonfinkel-Bernays&apos; class,
and work with some other language. Rounds (1988) describes such a language called
up, whose decidability follows from the fact that the domain of quantification is
</bodyText>
<page confidence="0.981013">
9
</page>
<note confidence="0.552805">
Computational Linguistics Volume 20, Number 1
</note>
<bodyText confidence="0.999297777777778">
restricted (just as in SB). However, it seems to be difficult to devise a decidable system
capable of simultaneously expressing both tree structure and the variety of feature
structure constraints that the SB approach described here can. Blackburn, Gardent,
and Meyer-viol (1993) introduce a modal language LT for describing trees decorated
with feature structures, whose satisfiability problem is undecidable. In the long run,
such specialized &amp;quot;designer logics&amp;quot; may provide the most satisfying integration of tree
structure and feature structure constraints.
Second, the &apos;one-sided&apos; approximation (14a) can be used in place of the correct
axiom (14). The effect of using such one-sided approximations was investigated in
Johnson (1991a). It was shown there that if is a formula such as the one in (14) and
is the one-sided approximation (14a), then for any formula yg+ (C) in which C only
appears positively, A (p+ (C) is satisfiable iff A co+ (C) is satisfiable. That is, if we are
concerned only with positively occurring constraints, we can simplify (14) to (14a),
i.e., ignore (14b), without affecting constraint satisfiability.
Third, we can regard formulae such as (14) as the &amp;quot;macro&amp;quot; (15), used to expand
constraints at the interface between the syntactic rules and the constraint solver. This
&amp;quot;macro expansion&amp;quot; rewrites c-commands constraints into boolean combinations of con-
straints that the constraint solver can handle.
</bodyText>
<equation confidence="0.99878">
C(x, y) —D(x, y) A Vz P(z, x) P(z, y). (15a)
—C(x, y) D(x, y) V 7z (P(z, x) A --,P(z y)). (15b)
</equation>
<bodyText confidence="0.999955333333333">
The second and the third approaches differ in important ways. In the second ap-
proach, c-commands is a relation that is &amp;quot;understood&amp;quot; by the constraint solver (albeit
only in its one-sided form), so it can be used to define other relations. In the third
approach, c-commands constraints are not primitive constraints, so relations defined in
terms of c-commands must also be expressible in terms of &amp;quot;macro expansion.&amp;quot; In the
second approach, constraints are quantifier-free formulae (quantifiers appear only in
the axioms), so the satisfiability problem is in NP. But in the third approach, macro
expansion produces formulae that contain additional quantifiers, so the satisfiability
problem may be PSPACE-complete.
</bodyText>
<subsectionHeader confidence="0.999814">
3.5 Limitations on Constraints Expressible with SB Formulae
</subsectionHeader>
<bodyText confidence="0.963562333333333">
Of course, SB is not as expressive as full first-order logic. It is incapable of expressing
functional relationships, since these require an existential quantifier inside the scope of
a universal quantifier. This means, among other things, that it is impossible to state a
constraint in SB requiring that a certain node must exist (as was noted in the discussion
of c-command in the previous section) or that all nodes possess certain attributes. Thus
for example, the following constraint, which requires that every tensed entity possess
number and person attributes, is a first-order formula that is not in SB, since it requires
a functional relationship between entities with tense attributes and the values of their
number and person attributes.
Vx Vy arc (x, tense, y) (z arc(x , number, z)) A (7z arc(x, person, z)) (16)
Similarly, a number of other extensions to the basic attribute-value framework dis-
cussed in the literature cannot be formalized in SB. Subsumption constraints, used in
the treatment of (natural language) conjunction, are not expressible as SB formulae
because the satisfiability problem for conjunctions of subsumption and attribute-value
constraints is undecidable (Dorre and Rounds 1992). Positively occurring functional
</bodyText>
<page confidence="0.888171">
10
</page>
<figure confidence="0.968587">
Mark Johnson Computing with Features as Formulae
(El) Vx x x.
(E2) Vy x y y = x.
(E3) Vxo Vx x1 = X0 A P(xi , , x),
for] 1, 1, ... ,71, for every predicate symbol P appearing in 42.
(E4) Vxo . Vx x1= f (X1- • • •xi,.• 7 x73 ) f X0. xn)
</figure>
<figureCaption confidence="0.833337">
for] 1, ,n, for every function symbol f appearing in cp.
Figure 2
</figureCaption>
<bodyText confidence="0.953625">
Equality axiom schemata for a first-order formula cp.
uncertainty constraints, used in the LFG treatment of long-distance dependencies (Kap-
lan and Zaenen 1989) appear to have a decidable satisfiability problem (Kaplan and
Maxwell 1988a), but the satisfiability problem for arbitrary boolean combinations of
functional uncertainty constraints is undecidable (Keller 1991), so these cannot be ex-
pressed using SB formulae either (since the quantifier-free subclass of SB is closed
under boolean operations).
</bodyText>
<subsectionHeader confidence="0.964001">
3.6 The Equality Relation
</subsectionHeader>
<bodyText confidence="0.997246">
In this paper the intended interpretation of the equality relation is identity; i.e., a = b
if and only if a and h denote the same individual. However, for some purposes (e.g.,
in the least-fixed-point characterization of minimal models given below) this &amp;quot;special&amp;quot;
interpretation of the equality complicates matters, and it is more convenient to treat
the equality relation as a &amp;quot;normal&amp;quot; relation that is defined by a set of axioms E.
The idea is that E has the property that a formula c,a is satisfiable under the identity
interpretation of equality if and only if {y} U E is satisfiable in an interpretation in
which equality is not given any special treatment. In effect, the axioms E require
that the equality relation denotes an equivalence relation, and permit the substitution
of equals for equals. Together these imply that no predicate can distinguish equal
individuals. This means that in terms of satisfiability and the consequence relation,
exactly the same results are obtained irrespective of whether equality is treated as
identity or defined by the axioms E.
Such treatments of equality in first-order logic are well known and described in
standard texts. For example, Chang and Lee (1973) give the axiom schemata in Figure 2,
which generates syntactic equality axioms E for a first-order formula co, and prove that
E has the properties just described.&apos;
What is important here is that for an SB formula co the instances of the axiom
schemata are all SB formulae, and there are only finitely many instances of these
schemata.
This means that for an arbitrary SB formula cp there is another SB formula such
that co is satisfiable with respect to an identity interpretation of equality if and only if
cp/14. is satisfiable with respect to an interpretation in which equality is treated like any
other relation. Thus a method for determining the satisfiability of SB formulae without
equality can be used to determine satisfiability of SB formulae in which equality is
interpreted as identity.
</bodyText>
<footnote confidence="0.6025605">
8 Of course, (E4) has no instances if is an SB formula, since SB formulae do not contain function
symbols.
</footnote>
<page confidence="0.988269">
11
</page>
<note confidence="0.472122">
Computational Linguistics Volume 20, Number 1
</note>
<listItem confidence="0.883557142857143">
(17) Vx x = x.
(18) Vx Vyx=y—&gt;y=x.
(19) Vx Va Vy Vx1 x = x1 A arc(x , a, y) arc(xi, a, y).
(20) Vx Va Vy Val a = al A arc(x, , y) arc(x, y) •
(21) Vx \fa Vy Vyi y ---= yi A arc(x, a y) arc(x, a, yi).
(22) Vci Vc2 c = Cl A con(c) car(ci).
(23) Vx Vy x y A 3rd-sg(x) 3rd-sg(y).
</listItem>
<bodyText confidence="0.916552833333333">
Figure 3
The equality axioms for arc, con, and 3rd-sg predicates.
For example, consider the 513 formulae in (1-4) and (5-16). These contain the
three-place relation symbol arc and the one-place relation symbols con and 3rd-sg. The
equality axioms obtained from schemata (E1—E4) for any system of constraints that
mention just these relations are given in Figure 3.
</bodyText>
<sectionHeader confidence="0.482491" genericHeader="method">
4. Clausal Form and Disjunctive Datalog
</sectionHeader>
<bodyText confidence="0.958025666666667">
It is technically easier to work with a syntactically restricted class of SB formulae
where the body of each formula has a particular syntactic form known as clausal form
or Skotem standard form.
</bodyText>
<subsectionHeader confidence="0.71616">
Definition
</subsectionHeader>
<bodyText confidence="0.988202368421053">
A clause is a formula of the form oi V •V—n:V,q1V••VO„, where each ai and
13i is an atomic formula (i.e., is of the form n(ti, , ti,)), and m, n &gt; 0. A formula cp is
in clausal form iff it is a conjunction of clauses.
The ai are called negative literals and the Of are called positive literals. A clause
for which m 0 (i.e., one that consists solely of positive literals) is called a positive
clause, and one for which n = 0 (i.e., one that consists solely of negative literals) is
called a negative clause. A clause for which n = 1 is called a definite clause. A Horn
clause is a clause for which n &lt;1, i.e., either a negative clause or a definite clause.
Abusing notation somewhat, a formula y in clausal form will sometimes also be
treated as the set of the clauses that make up the conjunction ;o. Similarly, because
clauses are used as rewriting rules below, the clause —
will sometimes be written as the equivalent implication ozi A • A ci,n ,(31 V • • • V Ow
A formula ;a in clausal form does not contain any quantifier symbols. As is stan-
dard, all variables in y are treated as implicitly universally quantified at the clausal
level. Existentially quantified variables in SB formulae are inessential, in that they can
always be directly replaced by Skolem constants.
Restricting attention to SB formulae in clausal form imposes no real restriction on
the class of constraints expressible. Standard procedures for transforming first-order
formulae into clausal form, such as the ones described in Chang and Lee (1973), Duffy
</bodyText>
<page confidence="0.970083">
12
</page>
<bodyText confidence="0.96313280952381">
Mark Johnson Computing with Features as Formulae
(1991), or Genesereth and Nilsson (1987), transform SB formulae into SB formulae in
clausal form.
Interestingly, clausal form SB formulae correspond one-to-one with an extension
to Datalog (Ullman 1988) that allows disjunctive &amp;quot;heads&amp;quot; or consequences. In notation
borrowed from disjunctive logic programming (Kowalski 1979; Lobo, Minker, and
Rajasekar 1992; Loveland 1987), the clauses above would be written as listed in the
appendix. While the connection between logic programming and feature structures is
well known (Alt-Kaci 1984; Ait-Kaci and Podelski 1993; Carpenter 1991,1992; Hiihfeld
and Smolka 1988; Pereira 1987; Shieber 1992; Smolka 1992), this shows that the theory
of feature structure constraints is also related to database theory as well.
Negative clauses correspond to Datalog integrity constraints, and clauses with a
single positive literal are definite clauses. Simple assertions, e.g., about the existence
of arcs, consisting of exactly one positive literal are Datalog atomic clauses. Clauses
with two or more positive literals cannot be expressed in Datalog itself, but require
the disjunctive extension of Datalog. The appendix displays all of the SB formulae
mentioned in this paper so far in clausal form in Datalog notation; (El), (10&apos;) and
(7&amp;quot;) are expressed in the disjunctive extension to Datalog. In fact, the axioms defining
attribute-value structures (1-4) and syntactic equality (E1—E3) are all Horn Datalog
clauses; i.e., the disjunctive extension is not needed for defining attribute-value feature
structures.
</bodyText>
<sectionHeader confidence="0.509599" genericHeader="method">
5. Determining the Satisfiability of SB Formulae
</sectionHeader>
<bodyText confidence="0.99980425">
This section describes a forward-chaining algorithm for determining the satisfiability of
SB formulae in clausal form. This algorithm is a nondeterministic variant of the semi-
naive evaluation method for Datalog clauses in which the union-find algorithm is used
to efficiently maintain equivalence classes of equal terms. It is also recognizable as a
generalization of the standard unification algorithm for feature structures to arbitrary
Horn SB constraints.&apos; The treatment is informal because the goal of the section is
to point out several important standard implementation techniques rather than to
advance a totally new algorithm.
The key intuition behind the algorithm is this. To demonstrate the satisfiability of
a set S of clauses, it is sufficient to exhibit a set A of ground atoms drawn from the
Herbrand base of S such that the following conditions hold (the next section proves
this assertion).
</bodyText>
<listItem confidence="0.996752333333333">
(a) For no ground instance — ai V • • v ci,c, of any negative clause in S are
all of a, ... , ar, in A. (If they were, then that clause would be falsified
by A.)
(b) For each ground instance 3/1 V • • • V of a positive clause in S. at least
one of the 811 is in A.
(c) For each ground instance a; A • • A ce V • • V of an implication in
</listItem>
<bodyText confidence="0.4610145">
5, if all of the a; , are in A then so is at least one of the O.; ,
(In fact, the other two conditions are just special cases of this condition.)
</bodyText>
<footnote confidence="0.733767">
9 It is a generalization of the algorithm described in Hegner (1991), which treats Horn combinations of
attribute-value constraints.
</footnote>
<page confidence="0.995829">
13
</page>
<note confidence="0.833015">
Computational Linguistics Volume 20, Number I
</note>
<subsectionHeader confidence="0.988109">
5.1 Naive Evaluation
</subsectionHeader>
<bodyText confidence="0.9999266">
One could attempt to find such a set A in the following manner. First, one nondeter-
ministically selects a a; from each of the ground instances of the positive clauses in
S and adds these to A. Then one attempts to close A with respect to condition (c); if
all of the antecedentsat,... am of some (ground instance of an) implication are in A,
then one of the consequents f, ,,(3„/ is nondeterministically selected and added to
A, unless at least one of them is already present. (Of course, all such nondeterministic
paths might have to be investigated.) Periodically, condition (a) is checked; if it fails
to hold, then this nondeterministic path on the search for A must be abandoned. Non-
determinism arises solely from the presence of disjunction in consequents of clauses;
if S is a set of Horn clauses then the fixed-point calculation proceeds deterministically.
Ignoring the checking of condition (a), the method is essentially computing a fixed-
point of the nonnegative clauses in S via a kind of iterative approximation known as
naive evaluation. Naive evaluation is unnecessarily computationally inefficient. Once
the set A is large enough to require an atom a to be added to A, naive evaluation
&amp;quot;rediscovers&amp;quot; this requirement on all subsequent passes.
</bodyText>
<subsectionHeader confidence="0.997527">
5.2 Semi-Naive Evaluation
</subsectionHeader>
<bodyText confidence="0.999925285714286">
Semi-naive evaluation avoids rediscovering the same fact in the same way by insisting
that each time a clause is applied at least one of the antecedents was just discovered
on the previous round (Ullman 1988, 1989). This is done by maintaining two sets
of atoms, A and AA, where A is the set of atoms discovered one or more iterations
ago, and AA is the set of atoms discovered at the last iteration. The nondeterministic
semi-naive algorithm for computing a set A (if it exists) is sketched in Figure 4. In
that algorithm choose is a &amp;quot;function&amp;quot; that nondeterministically picks one member from
its set argument; it can be implemented using, e.g., backtracking. Ullman describes
methods of matching clauses in S against the sets A and AA that avoids calculating
all of the ground instances of the clauses in S.
The semi-naive algorithm can be used directly with the syntactic equality axioms
given in Section 3.4 as a decision procedure for SB formulae, and hence for systems
of feature structure constraints. However, the resulting system is inefficient because
the equality axioms, specifically the instances of schemata (E2) and (E3), cause the
&amp;quot;copying&amp;quot; of any atom containing an argument that appears in an equality atom to
all members of the equivalence class containing that argument.
For example, if p(a),q(b) and a = b are atoms in A, then instances of (E2) and (F3)
ensure that p(b),q(a) and b ---= a will be added to AA and thence to A. In general, if it
is discovered that n constants al, ... a, are equal, then A will ultimately contain the n2
equalities ai ar 1 &lt; i &lt; n, 1 &lt; j &lt; n, as well as at least n &amp;quot;copies&amp;quot; of any predicate
containing any a„
</bodyText>
<subsectionHeader confidence="0.998053">
5.3 Union-Find and Equality
</subsectionHeader>
<bodyText confidence="0.999974888888889">
As noted above, the equality axioms ensure that the relation that the equality symbol
denotes is an equivalence relation and the substitutivity of equals for equals. in general,
the union-find algorithm (Corman, Leiserson, and Rivest 1990; Gallier 1986; Nelson
and Oppen 1980) maintains the equivalence classes of the equality relation far more
efficiently than an approach that uses the syntactic equality axioms.
The equivalence classes are encoded by associating each constant with a pointer
that is either null or points to another constant, where a points to b only if a =-- b. These
pointer correspond exactly to the &amp;quot;invisible pointers&amp;quot; used in standard implementa-
tions of the attribute-value unification algorithm.
</bodyText>
<page confidence="0.97192">
14
</page>
<figure confidence="0.5949472">
Mark Johnson Computing with Features as Formulae
Input: A set of SB clauses S.
Output: A set of ground clauses A iff S is satisfiable.
A
AA := {choose(113, ,13,c1): V . • V is a ground instance of a positive clause
in Sl,
until AA 0 do
A := AU AA,
if {ce!,, , } C A, where a V•••V ctim is a ground instance of a negative
clause in S and at least one of the a: is in AA,
then fail,
AA {choose({4 3,1) : al A••Act/ ,gv•••\(,e,c is a ground instance
of an implication in S such that Icei , a,c1 C A, at least one of the tt: is in AA
and no 131 is in A},
return A.
</figure>
<figureCaption confidence="0.88562">
Figure 4
</figureCaption>
<bodyText confidence="0.9970253125">
The semi-naive algorithm for computing A.
The find operation dereferences its argument, i.e., it follows these pointers until it
reaches a constant with a null pointer, which is the equivalence classes&apos; representative.
Just as in the standard attribute-value unification algorithm, all arguments are always
dereferenced before they are used.
The union operation, called whenever an atom a = b is added to the set A, merges
their equivalence classes by redirecting the pointer associated with the representative
of one of them to point to the representative of the other.&apos;
In this approach, only atoms that contain the redirected constant need to be added
to AA and thence to A. For example, if p(a) and q(b) are atoms in A and the equality
a = b is discovered, causing a to be redirected to b, then only p(b) is added to AA,
and thence to A. Further, the &amp;quot;original&amp;quot; atom p(a) is no longer required; indeed, the
new atom p(b) is exactly an argument-dereferenced variant of the old atom, so it is
not necessary to copy the atom at all. In general, equalities between n items are repre-
sented by n — 1 nonnull pointers, and copying of atoms can be avoided by argument
dereferencing.
</bodyText>
<subsectionHeader confidence="0.998384">
5.4 An Example
</subsectionHeader>
<bodyText confidence="0.840417">
This section presents a very simple example that demonstrates the semi-naive algo-
rithm and the union-find techniques. The clauses used are the attribute-value axiom
schemata (1-4) and the axioms defining the sort 3rd-sg (5), as well as the additional
10 The union-find algorithm achieves quasi-linear running time when it incorporates path compression
and union by rank (Corman, Leiserson, and Rivest 1990).
</bodyText>
<page confidence="0.937872">
15
</page>
<figure confidence="0.945724">
Computational Linguistics Volume 20, Number 1
3rd-sg(u), arc(a , number , v),v sg, constraints
Vx Vu Vy V z arc(x, a, y) A arc(x, a, z) y = z, AV axioms
Vx Vu Vy con(x)V arc(x, a, y),
con (5g), con(p1), con (3rd),
sg pl, sg 4 3rd, pl 0 3rd,
Vx 3rd-sg(x) arc(x, person, 3rd) ,
Vx 3rd-sg(x) arc(x, number, sg) sort defn.
S=
</figure>
<figureCaption confidence="0.909809">
Figure 5
Input clauses.
constraints 3rd-sg(u), arc(u, number, v) and v sg. These latter constraints assert the
existence of an entity (denoted by u) with the property 3rd-sg and with a number arc
whose value v is something other than pl. The complete set of clauses is given in
Figure 5. In practice the attribute-value axioms would probably not be explicitly enu-
merated but &amp;quot;built in,&amp;quot; so that appropriate instances are generated only when needed.
Now we proceed to iteratively calculate the sets AA and A using the algorithm in
Figure 4. We calculate the first initial set of new atoms, AA0. Ao = 0, of course.
</figureCaption>
<equation confidence="0.499692">
AA° = {3rd-sg(u), arc(u, number, v), con (sg) , con(p1), con (3rd)}
</equation>
<bodyText confidence="0.9646915">
On the first iteration we note that the antecedents of both clauses defining the sort
3rd-sg are satisfied (with x bound to u), so Ayll is given as follows.
</bodyText>
<equation confidence="0.9656745">
A1 = {3rd-sg(u), arc(u , number, v), con(sg), con (p1), con(3rd)}
AA1 = {arc(u, person, 3rd), arc (u , number, sg)}
</equation>
<bodyText confidence="0.991672">
In the second iteration the antecedents of the first attribute-value axiom are satisfied,
so AA2 contains an equality atom.
</bodyText>
<equation confidence="0.99538125">
A = 3rd-sg(u), arc (u , number, v), con(sg), con(p1), con(3rd),
2
arc(u , person, 3rd), arc(u, number , sg)
AA2 = v = sg}
</equation>
<bodyText confidence="0.999801666666667">
The equality atom causes v to be redirected to sg, and at this stage the inconsistency
of the derived atom v = sg in ,AA2 with the input constraint v 0 sg in S is detected. (It
may be helpful to think of the constraint v 0 sg as the equivalent clause v = sg -- false).
The algorithm therefore returns with failure, indicating that the set S is unsatisfiable.
At the point at which the inconsistency is detected, the set A contains the following
atoms, where v sg indicates that v is redirected to sg.
</bodyText>
<equation confidence="0.97169725">
{
3rd-sg(u), arc(u, number, v), con (sg) , con (p1), con(3rd),
A3 = arc(u, person, 3rd), arc(u , number, sg),
v sg
</equation>
<bodyText confidence="0.996580666666667">
The correspondence of this procedure to the standard attribute-value unification algo-
rithm is quite strong. In this procedure, the attribute-value axiom (I) detects situations
in which some node has two arcs with the same label pointing to, say, y and z. If such
</bodyText>
<page confidence="0.974387">
16
</page>
<bodyText confidence="0.9306912">
Mark Johnson Computing with Features as Formulae
a situation arises, the equality y = z is inferred, which results in y being redirected
to z and causes all of the arcs leaving y to be added to AA, where they will be com-
pared with the arcs leaving z. The other attribute-value axiom schemata (2-4) detect
constant—constant and constant—complex clashes, causing failure if one is found.
Efficient processing demands that the atoms in A be indexed by their arguments
to speed up the matching atoms with the antecedents of clauses. One way of doing
this is to store on each constant a list of the atoms in which that constant appears. Such
an index has the same structure as the standard graph encoding of feature structure
constraints.
</bodyText>
<sectionHeader confidence="0.942947" genericHeader="method">
6. A Fixed-Point Theorem
</sectionHeader>
<bodyText confidence="0.999244714285714">
We now turn to the theoretical justification of the bottom-up forward-chaining proce-
dures sketched in the last section, and show that such methods will find a model for
a set of SB formulae in clausal form if one exists. This section demonstrates that an
SB formula in clausal form is satisfiable if and only if a bottom-up forward-chaining
procedure finds a deductively closed set of atoms A. A similar theorem for the case
in which all the clauses are Horn clauses is presented in Lloyd (1984); this section
extends that work to arbitrary clauses.
It presents a characterization of the models of an arbitrary first-order formula co
in clausal form in terms of the least-fixed points of a set {T;,, x} of partial functions
from Herbrand interpretations to Herbrand interpretations. These functions have the
property that A is a Herbrand interpretation that satisfies if and only if the least-fixed
point of at least one of them is a submodel of A.
For SB formulae this set of functions is finite and the least-fixed points are reached
in a finitely bounded number of iterations. Since the procedures described in the
last section calculate the least-fixed points of these functions, they can be used to
determine the satisfiability of an arbitrary SB formula as well as all of its ground
atomic consequences.
The functions T, x play a similiar role here to one that the transformation Tp plays
in the least-fixed-point semantics of Horn clause programs. Informally, each function
in the set {T} corresponds to one whole sequence of nondeterministic choices of
disjuncts in non-Horn clauses that could be made during an iterative approximation
of the least-fixed point. This section is based on Sections 5 and 6 of Chapter 1 of Lloyd
(1984), to which the reader should turn for further details.
The fixed-point theorem holds for arbitrary first-order formulae in clausal form,
but the set {Tx1 is finite if and only if does not contain any function symbols, i.e.,
cp is an SB formula. Equality is not treated specially, so the formula co must contain
appropriate equality axioms, as mentioned above.
Let U be the Herbrand universe with respect to (i.e., the set of all terms that
can be constructed using the constant and function symbols appearing in co),&apos;&apos; and let
B, be the set of all ground atoms that can be formed using the predicate symbols of
,p with elements of U as arguments. A Herbrand interpretation A is a subset of B.
Note that the set of Herbrand interpretations 2B,&apos; partially ordered by the subset
relation forms a complete lattice. Further, U and hence B are finite iff (,.0 is an SB
formula. (If is in clausal form but is not an SB formula then it must contain a
function symbol, so its Herbrand universe LI is infinite.)
</bodyText>
<footnote confidence="0.96123">
11 As is standard, if cp has no constant symbols then it is necessary to take U to be a set consisting of a
single constant, say fal. See, e.g., Chang and Lee (1973) for details.
</footnote>
<page confidence="0.996257">
17
</page>
<figure confidence="0.7723692">
Computational Linguistics Volume 20, Number I
Definition
A Herbrand interpretation A trivially falsifies a set of clauses cp iff there is a ground
instance —c V - - V ce,t, of a negative clause — ai V • V oem in cp such that
• - • , „} C A-
</figure>
<bodyText confidence="0.993151448275862">
That is, a Herbrand interpretation trivially falsifies a set of clauses yo just in case some
negative clause in y is false in that interpretation. Clearly, any such interpretation
cannot satisfy y, but the converse does not hold: there are interpretations that do not
trivially falsify y but still do not satisfy cp because they do not satisfy one or more of
the nonnegative clauses in y.
We turn now to the nonnegative clauses in cp. The idea is that even if A does not
satisfy a ground instance cti A - - - A cri V v v • V /3:, of some nonnegative clause
in cp, we can extend A so that it does so by adding one of the 0. The chief technical
difficulty here is caused by the nondeterminism involved in deciding which of the 0: to
add, and a device called a &amp;quot;choice function&amp;quot; is introduced to choose, for each ground
instance of a clause, which of the atoms in its consequent will be added to A if its
antecedent is contained in A. A choice function for a clause cri A V A am —&gt; 01 V • • • V 3,
is therefore a function from all possible ways of grounding that clause to one of the A.
Definition
A choice function for a clause c = (cri A•vv A cym 01 V - • V On) is any function in
(V,- U) [1,...,n1, where 17, is the set of variables in the clause c.
That is, a choice function for a clause is a function from variable assignments to an
integer representing one of the clause&apos;s consequents. It is so named because for each
variable assignment (i.e., each way of grounding the variables in yo) it &amp;quot;chooses&amp;quot; an
atom from the consequent of the clause. Horn clauses have only one choice function,
and negative clauses have no choice functions at all. Note that since U is finite for SB
formulae, there are a finite number of variable assignment functions for any SB clause
and hence only a finite number of choice functions for any 5B clause.
A choice function x for a set of clauses (p is a function from yo to choice functions
such that for each nonnegative clause c in co, x(c) is a choice function for c (the value
that x takes on negative clauses is ignored). Clearly, a choice function exists for every
set of clauses.
Given a set of clauses y and a choice function x for yo, we define a function F
from Herbrand interpretations to Herbrand interpretations as follows.
</bodyText>
<subsectionHeader confidence="0.836055">
Definition
</subsectionHeader>
<bodyText confidence="0.946295">
Fc, is a function in 213,, n, that is defined as follows.
</bodyText>
<equation confidence="0.729928">
x(A) = {6(3) : for all nonnegative clauses
c (o/ c • - cy„, —&gt; 01 V • c cV 0,,) in cp
</equation>
<listItem confidence="0.701595">
and for all variable assignments 0 : Li such that
(nen) E A and i = X(c)(0)}
</listItem>
<bodyText confidence="0.998700166666667">
Intuitively, F,, corresponds to one nondeterministic step in the &apos;bottom-up&apos; construc-
tion of a Herbrand model for yo described in the previous section. If A makes the
antecedent of some ground instance of some clause in true, then we use the choice
function x to pick an atom in the consequent of that ground clause and add it to the
interpretation. Different choice functions x represent different sequences of nondeter-
ministic choices, and result in the construction of possibly different interpretations.
</bodyText>
<page confidence="0.992201">
18
</page>
<bodyText confidence="0.762162">
Mark Johnson Computing with Features as Formulae
The following lemma, based directly on proposition 6.3 of Lloyd (1984), notes the
continuity (and therefore the monotonicity) of
</bodyText>
<subsectionHeader confidence="0.488825">
Lemma 1
</subsectionHeader>
<bodyText confidence="0.990238">
The function F is continuous. That is, if X is a directed subset of 2&apos; (i.e., every
finite subset of X has an upper bound in X) then F„„0„(lub(X)) = (X)).
</bodyText>
<equation confidence="0.8637084">
Proof
Let X be any directed subset of 2&apos;. Then C lub(X) if and only if
, arul C A for some A E X. Then
E (lub(X))
iff c = (cri A - A am lit V &apos; • • V (in) is a nonnegative clause in
Nal), ,O(o„)} C lub(X), and /3
iff c (al A • • • A am 01 V • &apos; • V ,(1,2) is a nonnegative clause in
, 9(0)} C A for some A E X, and ,0 = 00x(c)(e))
if /3 E Fv,x (A) for some A c X
iff j3 E lub(F,,x (X)). El
</equation>
<bodyText confidence="0.997434833333333">
The continuity of F c,,x immediately implies the convergence of the sequence (0));
the value that it converges to is called the least-fixed point of F„, written Ifp(F,x).
Note that if co is in 93 then there is an integer k such that lfp(F,x) = Fk7, x(0); this
follows directly from the monotonicity of F„,,,x and the finiteness of B.
The function F,„,x and a condition requiring that the interpretation produced does
not trivially falsify the set of clauses cp together define the partial function
</bodyText>
<subsectionHeader confidence="0.799251">
Definition
</subsectionHeader>
<bodyText confidence="0.986848">
is a partial function in 2B‘, 2Bw that is defined as follows.
T = F ,,,(A) if F,(A) does not trivially falsify (p, and is undefined other-
wise.
Note that if the sequence (T,, (A)) is defined for all i then (7;,x(A)) = (Pw,x (A)).
enjoys the following kind of monotonicity.
</bodyText>
<subsectionHeader confidence="0.860929">
Lemma 2
</subsectionHeader>
<bodyText confidence="0.801786">
Suppose A C A&apos;. Then T,( A) is defined if T ,x(A&apos;) is defined, and T,( A) C rp,x(A&apos;).
</bodyText>
<subsectionHeader confidence="0.946715">
Proof
</subsectionHeader>
<bodyText confidence="0.99591275">
If A trivially falsifies y then A&apos; does too, so T,,,x (A) is defined if Ts„,x(A&apos;) is defined.
If T(A&apos;) is defined then T,p,x(A) F w,x(A) C Fc,,,x(A&apos;) = (A&apos;).
The following lemma shows that Herbrand models of y contain fixed points of
for some choice function x for yo
</bodyText>
<subsectionHeader confidence="0.654534">
Lemma 3
</subsectionHeader>
<bodyText confidence="0.98">
For all Herbrand interpretations A, A J= p iff there exists a choice function x for y
such that T(A) c A.
</bodyText>
<page confidence="0.997605">
19
</page>
<note confidence="0.791934">
Computational Linguistics Volume 20, Number 1
</note>
<subsectionHeader confidence="0.702273">
Proof
</subsectionHeader>
<bodyText confidence="0.975920619047619">
We begin first with the left-to-right component of the proof. If A cp, then A does not
trivially falsify (p, so Tv„,,(A) is defined. Now we show how to find for each satisfying
interpretation A a choice function x such that T,,,x(A) = A. Since A satisfies (p, for
every nonnegative clause c = A • - A ct,,, 81V.. - V N) in yo and for every variable
assignment function 8 for the variables in c, if (01),..., 0(an) E A, then by the truth
conditions for implication and disjunction, some (9(0,) E A as well. Thus, for all 8 such
that 19(ai),... AN) E A let x (c)(8) be any i such that OW E A, and let x(c)(0) take
any permissible value otherwise. Hence T„,,x(A) = F,x(A) = A.
Now suppose Tcp,x (A) C A. Since (A) is defined, A does not trivially falsify
any negative clause in cc . Let c foi A••Act,,-4 v • v ) be any nonnegative
clause in cp, and let 0 E V, U be any variable assignment function for the variables
inc. If 8(ai), .,0() E A then 0(A) E T(A) C A as well, where i = x(c)(8), so
A c and hence A = co. 0
The following theorem shows that a formula is satisfiable if and only if the least-fixed
point of at least one of the exists. It justifies the decision procedures presented in
the previous section, which operate by searching for such least-fixed points.
The proof actually establishes something stronger, viz., that every Herbrand model
of co is an extension of the least-fixed points of one or more of the T„,,x. Thus an
enumeration of all of the least-fixed points of the T yields all of the &amp;quot;minimal
models&amp;quot; of p (although it is not clear that these are in fact necessary for recognition
or parsing, as discussed above).
</bodyText>
<subsectionHeader confidence="0.912754">
Theorem
</subsectionHeader>
<bodyText confidence="0.998036">
cp is satisfiable if and only if there exists a choice function x for (p such that Ifp(T,x)
exists.
</bodyText>
<subsectionHeader confidence="0.922389">
Proof
</subsectionHeader>
<bodyText confidence="0.9994354">
If Ifp(T„,x) exists then by Lemma 3, Ifp(T) w. Now suppose A is a Herbrand
interpretation that satisfies Lemma 3 asserts the existence of a choice function x
such that Tvo, (A) exists and T (A) C A. By Lemma 2 and the fixed point property
noted above lfp(T) exists, since lfp(T„,,x) Tc,&apos;,x (0) C Tx(A) C A.
It is important to recognize that these &amp;quot;minimal models&amp;quot; are in general not upward-
closed: an extension A&apos; of a model A can trivially falsify even though A does not. This
is essentially Moshier&apos;s (1988) and Pereira&apos;s (1987) observation that in the presence of
negation the set of models is not upwardly closed.
We conclude this section with the observation that the positive consequences of a
formula co can be &amp;quot;read off&amp;quot; its least-fixed points.
</bodyText>
<subsectionHeader confidence="0.821283">
Corollary
</subsectionHeader>
<bodyText confidence="0.973824333333333">
co is satisfiable iff for some choice function x for (p, lfp(T,po„) exists. Moreover, if
01 V • • • V is any disjunction of ground atoms, j3 iff for all choice functions x
for ca such that lfp(T,x) exists, at least one of the is in Ifp(T„,,x).
</bodyText>
<sectionHeader confidence="0.751273" genericHeader="conclusions">
7. Conclusion
</sectionHeader>
<bodyText confidence="0.965297">
The main goal of this paper was to demonstrate from a computational perspective
that Schonfinkel-Bernays&apos; formulae are a natural generalization of (boolean. combina-
</bodyText>
<page confidence="0.939701">
20
</page>
<note confidence="0.278982">
Mark Johnson Computing with Features as Formulae
</note>
<bodyText confidence="0.999922674418605">
tions of) attribute-value feature structure constraints. From a computational complexity
perspective we noted that the satisfiability problem for 513 formulae with a bounded
number of quantifiers is NP-complete, so it is no harder than the satisfiability problem
for disjunctive attribute-value constraints.
From a more practical perspective, a semi-naive bottom-up evaluation strategy
using union-find methods to handle equality generalizes the standard attribute-value
&amp;quot;unification&amp;quot; algorithm to arbitrary SB constraints in clausal form. Because it treats
standard attribute-value constraints in approximately the same way as the standard
unification algorithm, and because it can incorporate the same kinds of indexing that
the latter algorithm employs, the generalized algorithm should be able to determine
the satisfiability of attribute-value constraints with approximately the same efficiency
as the standard attribute-value unification algorithm.
In generalizing attribute-value constraints to SB formulae, we noted that in clausal
form the SB formulae constitute a disjunctive extension to Datalog, and that the stan-
dard attribute-value unification algorithm is closely related to a version of semi-naive
evaluation algorithm used to evaluate Datalog clauses. This offers another perspective
on feature structure constraints; they can be seen as kinds of databases containing
information about the linguistic structures they describe.
Perhaps the greatest weakness of this work is the lack of an efficient method
for treating disjunctive constraints. The backtracking strategy suggested in the body
of the paper can be extremely inefficient, even with &apos;toy&apos; grammars. This problem
is not unique to this approach; rather, it is endemic to most complex feature-based
approaches to natural language processing, as evidenced by the volume of literature
on the subject.
As discussed in Section 3, the satisfiability problem for SB formula with a fixed
number of universal quantifiers is NP-hard, so all known algorithms require exponen-
tial time in the worst case, and unless P=NP no tractable general-purpose algorithm for
determining the satisfiability of SB formulae exists. With present technology, the best
we can hope for is an algorithm that performs adequately on the types of problems
that we actually encounter.
Sometimes disjunctive constraints can be (automatically) transformed into nondis-
junctive ones, thus avoiding the problem entirely. For example, Alshawi (1992) de-
scribes a technique attributed to Colmerauer for transforming disjunctions of finite-
domain feature-value constraints into conjunctions. Kasper (1988) and Hegner (1991)
point out that Horn clauses, although technically disjunctions, can be handled con-
siderably more efficiently than general disjunctive constraints. The forward-chaining
mechanisms that they propose for treating these constraints appear to be special cases
of the semi-naive algorithm sketched in this paper.
Unfortunately, I know of no general adequate method for handling the disjunc-
tive constraints that arise in real grammars with acceptable efficiency. The techniques
discussed by Maxwell and Kaplan (1991, 1992) seem most directly compatible with
the approach described in this paper, and the methods described by Kasper (1987b),
Eisele and Dorre (1988), and Ernele (1991) might have important applications as well.
</bodyText>
<footnote confidence="0.550544857142857">
Acknowledgment for their suggestions and comments. All
I would like to thank Johan van Benthem, responsibility for errors rests with me, of
Bob Carpenter, Stephen Hegner, Ronald course.
M. Kaplan, Edward Stabler and the References
participants of the feature structures Alt-Kaci, Hassan (1984). A lattice theoretic
seminar at the Institut fiir maschinelle approach to computation based on a calculus of
Sprachverarbeitung, Universitat Stuttgart,
</footnote>
<page confidence="0.993407">
21
</page>
<note confidence="0.786941">
Computational Linguistics Volume 20, Number 1
</note>
<reference confidence="0.996729532786885">
partially ordered type structures. Doctoral
dissertation, University of Pennsylvania.
AII-Kaci, Hassan, and Podelski, Andreas
(1993). &amp;quot;Towards a meaning of LIFE.&amp;quot; The
Journal of Logic Programming 16(3,4),
195-234.
Alshawi„ Hiyan (1992). &amp;quot;Categories and
rules.&amp;quot; In The Core Language Engine, edited
by Hiyan Alshawi, 41-60. MIT Press.
Barton, G. Edward; Berwick, Robert C.; and
Ristad, Eric S. (1987). Computational
Complexity and Natural Language. MIT
Press.
Blackburn, Patrick (1991). &amp;quot;Modal logic and
attribute-value structures.&amp;quot; In Modal Logic
Colloquium &apos;91, edited by Maarten de
Rijke. Dutch Project for Language, Logic
and Information, Amsterdam.
Blackburn, Patrick, and Spaan, Edith (1992).
&amp;quot;A modal perspective on the
computational complexity of attribute
value grammar.&amp;quot; Logic Group Preprint
Series No. 77, Department of Philosophy,
University of Utrecht.
Blackburn, Patrick; Gardent, Claire; and
Meyer-viol, Wilfried (1993). &amp;quot;Talking
about trees.&amp;quot; In Proceedings, 6th European
Meeting of the Asssociation for Computational
Linguistics. Utrecht, Holland.
Bresnan, Joan (1982). The Mental
Representation of Grammatical Relations. MIT
Press.
Carpenter, Bob (1991). &amp;quot;Typed feature
structures: A generalization of first-order
terms.&amp;quot; In Logic Programming, Proceedings
of the 1991 International Symposium, edited
by Vijay Saraswat and Kazunori Ueda,
187-201. MIT Press.
Carpenter, Bob (1992). The Logic of Typed
Feature Structures. Cambridge Tracts in
Theoretical Computer Science 32.
Cambridge University Press, Cambridge,
England.
Carpenter, Bob, and Pollard, Carl (1991).
&amp;quot;Inclusion, disjointness and choice: The
logic of linguistic classification.&amp;quot; In
Proceedings, 29th Annual Meeting of the
Association for Computational Linguistics,
9-16. Berkeley, CA.
Carpenter, Bob; Pollard, Carl; and Franz,
Alex (1991). &amp;quot;The specification and
implementation of constraint-based
unification grammars.&amp;quot; In Proceedings,
Second International Workshop on Parsing
Technologies. Cancun, Mexico.
Chang, Chin-Liang, and Lee, Richard
Char-Tung (1973). Symbolic Logic and
Mechanical Theorem Proving. Academic
Press.
Chomsky, Noam (1986). Knowledge of
Language, Its Nature, Origins and Use.
Praeger.
Chomsky, Noam (1988). Some Notes on
Economy of Derivation and
Representation. ms. Massachusetts
Institute of Technology.
Corman, Thomas H.; Leiserson, Charles E.;
and Rivest, Ronald L. (1990). Introduction
to Algorithms. MIT Press,
Dawar, Anuj, arid Vijay-Shanker, K. (1990).
&amp;quot;An interpretation of negation in feature
structures.&amp;quot; Computational Linguistics 16(1),
11-21.
Dorre, Jochen (1991). &amp;quot;The language of
STUF.&amp;quot; ha Text Understanding in LILOG:
Integrating Computational Linguistics and
Artificial Intelligence, edited by Otthein
Herzog and Claus-Rainer Rollinger,
39-50. Springer-Verlag.
DOrre, Jochen, and Eisele, Andreas (1990).
&amp;quot;Feature logic with disjunctive
unification.&amp;quot; In Proceedings, 13th
International Conference on Computational
Linguistics (COLING-90), 100-105.
Helsinki, Finland.
Dorre, Jochen, and Eisele, Andreas (1991).
&amp;quot;A comprehensive unification-based
grammar formalism.&amp;quot; DYANA
Deliverable R3.1B, ESPRIT Basic Research
Action BR3175.
Dorre, Jochen, and Rounds, William C.
(1992). &amp;quot;On subsumption and
semiunification in feature algebras.&amp;quot;
Journal of Symbolic Computation 13,441-461.
Duffy, David (1991). Principles of Automated
Theorem Proving. John Wiley and Sons.
Eisele, A., and Done, J. (19813). &amp;quot;Unification
of disjunctive feature descriptions.&amp;quot; In
Proceedings, 26th Annual Meeting of the
Association for Computational Linguistics,
286-294. Buffalo, New York.
Emele, Martin (1991). &amp;quot;Unification with lazy
non-redundant copying.&apos; In Proceedings,
29th Annual Meeting of the Association for
Computational Linguistics, 323-330.
Berkeley, CA.
Gallier, J. H. (1986). Logic for Computer
Science. Harper and Row.
Genesereth, M., and Nilsson, N. (1987).
Logical Foundations of Artificial Intelligence.
Morgan Kaufmann.
Hegner, Stephen J. (1991). &amp;quot;Horn extended
feature structures: Fast unification with
negation and limited disjunction.&amp;quot; In
Proceedings, Fifth Conference of the European
Chapter of the Association for Computational
Linguistics, 33-38. Berlin.
Hafeld, Markus, and Srnolka, Gert. (1988).
&amp;quot;Definite relations over constraint
languages.&amp;quot; LILOG Report No. 53, IBM
Deutschland.
Johnson, Mark (1988). Attribute-Value Logic
</reference>
<page confidence="0.996638">
22
</page>
<note confidence="0.605468">
Mark Johnson Computing with Features as Formulae
and the Theory of Grammar. CSLI Lecture
Notes Series. University of Chicago Press.
</note>
<reference confidence="0.997210325">
Johnson, Mark (1990a). &amp;quot;Expressing
disjunctive and negative feature
constraints with classical first-order
logic.&amp;quot; In Proceedings, 28th Annual Meeting
of the Association for Computational
Linguistics, 173-179. Pittsburgh, PA.
Johnson, Mark (1990b). &amp;quot;Features, frames
and quantifier-free formulae.&amp;quot; In Logic and
Logic Grammars for Language Processing,
edited by Patrick Saint-Dizier and Stan
Szpakowicz, 94-107. Ellis Horwood.
Johnson, Mark (1991a). &amp;quot;Features and
formulae.&amp;quot; Computational Linguistics 17(2),
131-152.
Johnson, Mark (1991b). &amp;quot;Logic and feature
structures.&amp;quot; In Proceedings, International
Joint Conference on Artificial Intelligence.
Sydney.
Johnson, Mark (in press a) &amp;quot;Attribute-value
logic and natural language processing.&amp;quot;
In Unification in Grammar, edited by
Jurgen Wedekind and Christian Rohrer.
MIT Press.
Johnson, Mark (in press b) &amp;quot;Two ways of
formalizing grammars.&amp;quot; Linguistics and
Philosophy.
Johnson, Mark, and Kay, Martin (1990).
&amp;quot;Semantic operators and anaphora.&amp;quot; In
Proceedings, 13th International Conference on
Computational Linguistics (COLING-90),
17-27. Helsinki.
Johnson, Mark, and Klein, Ewan (1986).
&amp;quot;Discourse, parsing and anaphora.&amp;quot; In
Proceedings, 17th International Conference on
Computational Linguistics. Bonn.
Kamp, Hans (1981). &amp;quot;A theory of truth and
semantic representation.&amp;quot; In Formal
Methods in the Study of Language, edited by
J. A. G. Groenendijk, T. M. V. Janssem,
and M. B. J. Stokhof, 277-322.
Mathematical Centre Tracts, Amsterdam.
Kaplan, Ronald M., and Bresnan, Joan
(1982). &amp;quot;Lexical-functional grammar, a
formal system for grammatical
representation.&amp;quot; In The Mental
Representation of Grammatical Relations,
edited by Joan Bresnan, 173-281. MIT
Press.
Kaplan, Ronald M., and Maxwell, John T.
(1988a). &amp;quot;An algorithm for functional
uncertainty.&amp;quot; In Proceedings, 12th
International Conference on Computational
Linguistics, 297-302. Budapest, Hungary.
Kaplan, Ronald M., and Maxwell, John T.
(1988b). &amp;quot;Constituent coordination in
lexical-functional grammar.&amp;quot; In
Proceedings, 12th International Conference on
Computational Linguistics, 297-302.
Budapest, I lungary.
Kaplan, Ronald M., and Zaenen, Annie.
(1989). &amp;quot;Long-distance dependencies,
constituent structure and functional
uncertainty.&amp;quot; In Alternative Conceptions of
Phrase Structure, edited by Mark Baltin
and Anthony Krock, 17-42. Chicago
University Press.
Kapur, D., and Musser, D. R. (1987). &amp;quot;Proof
by consistency.&amp;quot; Artificial Intelligence 31,
125-157.
Karttunen, Lauri (1984). &amp;quot;Features and
values.&amp;quot; In Proceedings, International
Conference on Computational Linguistics
(COLING-1984), 28-33. Stanford
University.
Kasper, Robert T. (1987a). Feature structures:
A logical theory with application to language
analysis. Doctoral dissertation, University
of Michigan.
Kasper, Robert T. (1987b). &amp;quot;A unification
method for disjunctive feature
structures.&amp;quot; In Proceedings, 25th Annual
Meeting of the Association for Computational
Linguistics, 235-242. Stanford University.
Kasper, Robert T. (1988). &amp;quot;Conditional
descriptions in functional unification
grammar.&amp;quot; In Proceedings, 26th Annual
Meeting of the Association for Computational
Linguistics, 233-240. Buffalo, N.Y.
Kasper, Robert T., and Rounds, William C.
(1986). &amp;quot;A logical semantics for feature
structures.&amp;quot; In Proceedings, 24th Annual
Meeting of the Association for Computational
Linguistics, 257-266. Columbia University,
New York.
Kasper, Robert T., and Rounds, William C.
(1990). &amp;quot;The logic of unification in
grammar.&amp;quot; Linguistics and Philosophy 13(1),
35-58.
Kay, Martin (1979). &amp;quot;Functional unification
grammar.&amp;quot; In Proceedings, Fifth Annual
Meeting of the Berkeley Linguistics
Association. Berkeley, CA.
Kay, Martin (1985a). &amp;quot;Parsing in functional
unification grammar.&amp;quot; In Natural Language
Parsing, edited by D. R. Dowty,
L. Karttunen, and A. M. Zwicky.
Cambridge University Press.
Kay, Martin (1985b). &amp;quot;Unification in
grammar.&amp;quot; In Natural Language
Understanding and Logic Programming,
edited by V. Dahl and P. Saint-Dizier,
233-240. North Holland.
Keller, Bill (1991). Feature logics, infinitary
descriptions and the logical treatment of
grammar. Doctoral dissertation, University
of Sussex.
Kowalski, Robert (1979). Logic for Problem
Solving. North Holland.
Langholm, Tore (1989). &amp;quot;How to say no
with feature structures.&amp;quot; COSMOS Report
</reference>
<page confidence="0.951794">
23
</page>
<note confidence="0.465967">
Computational Linguistics Volume 20, Number 1
</note>
<reference confidence="0.999874409090909">
No. 13, Department of Mathematics,
University of Oslo.
Lewis, Harry (1980). &amp;quot;Complexity results for
classes of quantificational formulae.&amp;quot; JCSS
21,317-353.
Lewis, Harry, and Papadimitriou, Christos
(1981). Elements of the Theory of
Computation. Prentice-Hall, NJ.
Lloyd, John W. (1984). Foundations of Logic
Programming. Springer-Verlag.
Lobo, Jorge; Minker, Jack; and Rajasekar,
Arcot (1992). Foundations of Disjunctive
Logic Programming. MIT Press.
Loveland, D. W. (1987). &amp;quot;Near-Horn
Prolog.&amp;quot; In Logic Programming: Papers for
the Fourth International Conference on Logic
Programming, edited by Jean-Louis Lassez,
456-469. MIT Press.
Marcus, Mitch; Hindle, Donald; and Fleck,
Margaret M. (1983). &amp;quot;D-theory--talking
about talking about trees.&amp;quot; In Proceedings,
21st Annual Meeting of the Association for
Computational Linguistics, 129-136.
Cambridge, MA.
Maxwell, John T., and Kaplan, Ronald M.
(1991). &amp;quot;A method for disjunctive
constraint satisfaction.&amp;quot; In Current Issues
in Parsing Technology, edited by Masaru
Tomita„ 173-190. Kluwer Academic
Publishers.
Maxwell, John T., and Kaplan, Ronald M.
(1992). &amp;quot;The interface between phrasal
and functional constraints.&amp;quot; Computational
Linguistics 19(4), 571-590.
Moshier, M. Drew (1988). Extensions to
unification grammar for the description of
programming languages. Doctoral
dissertation, University of Michigan.
Mushier, M. Drew, and Rounds, William C.
(1987). &amp;quot;A logic for partially specified
data structures.&amp;quot; In The ACM Symposium
on the Principles of Programming Languages.
Association for Computing Machinery,
Munich, Germany.
Nelson, G., and Oppen, D. C. (1980). &amp;quot;Fast
decision procedures based on congruence
closure.&amp;quot; J. ACM 27(2), 245-257.
Partee, Barbara H.; ter Meulen, Alice; and
Wall, Robert E. (1990). Mathematical
Methods in Linguistics. Kluwer Academic
Publishers.
Pereira, Fernando C. N. (1982). Logic for
natural language analysis. Doctoral
dissertation, University of Edinburgh.
Pereira, Fernando C. N. (1987). &amp;quot;Grammars
and logics of partial information.&amp;quot; In
Proceedings, International Conference on Logic
Programming, 989-1013. Melbourne,
Australia.
Pollard, Carl, and Sag, Ivan A. (1987).
Information-Based Syntax and Semantics.
CSLI Lecture Notes Series. Chicago
University Press.
Pollard, Carl, and Sag, Ivan A. (1992).
1-lead-Driven Phrase Structure Grammar.
CSLI Lecture Notes Series. Chicago
University Press.
Rounds, William C. (1988). &amp;quot;LFP: A logic for
linguistic descriptions and an analysis of
its complexity&amp;quot; Computational Linguistics
14(4), 1-9.
Rounds, William C., and Manaster-Ramer,
Alexis (1987). &amp;quot;A logical version of
functional grammar.&amp;quot; In Proceedings, 25th
Annual Meeting of the Association for
Computational Linguistics, 89-96. Stanford,
CA.
Shieber, Stuart M. (1986). An Introduction to
Unification-Based Approaches to Grammar.
CSLI Lecture Notes Series. University of
Chicago Press.
Shieber, Stuart M. (1992). Constraint-Based
Grammar Formalisms: Parsing and Type
Inference for Natural and Computer
Languages. MIT Press.
Smolka, Gert. (1988). &amp;quot;A feature logic with
subsorts.&amp;quot; LILOG Report No. 33, IBM
Deutschland GmbH.
Smolka, Gert. (1992). &amp;quot;Feature constraint
logics for unification grammars.&amp;quot; The
Journal of Logic Programming 12(1,2), 51-87.
Ullman, Jeffrey D. (1988). Principles of
Database and Knowledge-Base Systems, Vol. I.
Computer Science Press.
Ullman, Jeffrey D. (1989). Principles of
Database and Knowledge-Base Systems,
Vol. II: The New Technologies. Computer
Science Press.
Uszkoreit, Hans (1986). &amp;quot;Categorial
unification grammar.&amp;quot; In Proceedings, 11th
International Conference on Computational
Linguistics, 187-194. Bonn.
Vijay-Shanker, K. (1992). &amp;quot;Using descriptions
of trees in a tree adjoining grammar.&amp;quot;
Computational Linguistics 18(4), 481-517.
Wall, Robert (1972). Introduction to
Mathematical Linguistics. Prentice-Hall.
Zajac, Reini (1992). &amp;quot;Inheritance and
constraint-based grammar formalisms.&amp;quot;
Computational Linguistics 18(2), 159-182.
</reference>
<page confidence="0.987255">
24
</page>
<bodyText confidence="0.173525">
Mark Johnson Computing with Features as Formulae
</bodyText>
<equation confidence="0.9595506875">
Appendix A: SB Formulae in Disjunctive Datalog Format
(1&apos;) Y = Z arc(X, A, Y), arc(X, A, Z).
(2&apos;) :- con(X), arc(X, A, Y).
(3&apos;) con(c) . (for each c in N)
(4&apos;) = C2 - (for each distinct pair cl,c2 in N)
(5&apos;) arc(X, person, 3rd) :- 3rd_sg(X).
(5&amp;quot;) arc(X, number, singular) :- 3rd_sg(X).
(5&amp;quot;) 3rd_sg(X) arc(X, person, 3rd), arc(X, number, singular).
(6&apos;) Y = singular; Y = plural :- arc(X, number, Y).
(7a&apos;) :- X &lt; X.
(71D&apos;) :- X &lt; Y, Y &lt; X.
(7e) X &lt; Z :- X &lt; Y, Y &lt; Z.
(8d) d(X, X) :- n(X).
(8a&amp;quot;) n(X) d(X, X).
(813&apos;) X = Y d(X, Y), d(Y, X).
(Sc&apos;) d(X, Z) d(X, Y), d(Y, Z),
(9&apos;) n(root).
(9&amp;quot;) d(root, Y) n(Y).
(10&apos;) X &lt; Y; Y &lt; X; d(X, Y); d(Y, X) :- n(X), n(Y).
(10&amp;quot;) :- n(X), n(Y), X &lt; Y, d(X, Y).
(10&amp;quot;) n(X), n(Y), X &lt; Y, d(Y, X).
(12a&apos;) n(X) X &lt; Y.
(12a&amp;quot;) n(Y) :- X &lt; Y.
(12W) n(X) d(X, Y).
(12b&amp;quot;) n(Y) d(X, Y).
(r) d(X, Y) p(X, Y).
(7&amp;quot;) :- p(X, r), X= Y.
(7&amp;quot;) p(x, y); x = Y d(X, Y).
(14&apos;) c(X, Y), d(X, Y).
(14&amp;quot;) p(Z, Y) c(X, Y), p(Z, X).
(17&apos;) X = X.
(18&apos;) Y = X : - X = r.
</equation>
<reference confidence="0.9721202">
(19&apos;) arc(Xl, A, Y) X = Xl, arc(X, A, Y).
(20&apos;) arc(X, Al, Y) :- A = Al, arc(X, A, Y),
(21&apos;) arc(X, A, Yl) Y = Yl, arc(X, A, Y).
(22&apos;) con(C1) C = Cl, con(C).
(23&apos;) 3rd_sg(Y) :- X = Y, 3rd_sg(X).
</reference>
<page confidence="0.99856">
25
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.751809">
<title confidence="0.998853">Computing with Features as Formulae</title>
<author confidence="0.999993">Mark Johnson&apos;</author>
<affiliation confidence="0.999748">Brown University</affiliation>
<abstract confidence="0.964608375">This paper extends the approach to feature structures developed in Johnson (1991a), which uses Schtinfinkel-Bernays&apos; formulae to express feature structure constraints. These are shown to be a disjunctive generalization of Data log clauses, as used in database theory. This paper provides a fixed-point characterization of the minimal models of these formulae that serves as the theoretical foundation of a forward-chaining algorithm for determining their satisfiability. This algorithm, which generalizes the standard attribute-value unification algorithm, is also recognizable as a nondeterministic variant of the semi-naive bottom-up algorithm for evaluating Datalog programs. further strengthening the connection between the theory of feature structures and databases.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="false">
<title>partially ordered type structures. Doctoral dissertation,</title>
<institution>University of Pennsylvania.</institution>
<marker></marker>
<rawString>partially ordered type structures. Doctoral dissertation, University of Pennsylvania.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Hassan AII-Kaci</author>
<author>Andreas Podelski</author>
</authors>
<title>Towards a meaning of LIFE.&amp;quot;</title>
<date>1993</date>
<journal>The Journal of Logic Programming</journal>
<volume>16</volume>
<issue>3</issue>
<pages>195--234</pages>
<marker>AII-Kaci, Podelski, 1993</marker>
<rawString>AII-Kaci, Hassan, and Podelski, Andreas (1993). &amp;quot;Towards a meaning of LIFE.&amp;quot; The Journal of Logic Programming 16(3,4), 195-234.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Alshawi„ Hiyan</author>
</authors>
<title>Categories and rules.&amp;quot; In The Core Language Engine, edited by Hiyan Alshawi,</title>
<date>1992</date>
<pages>41--60</pages>
<publisher>MIT Press.</publisher>
<marker>Hiyan, 1992</marker>
<rawString>Alshawi„ Hiyan (1992). &amp;quot;Categories and rules.&amp;quot; In The Core Language Engine, edited by Hiyan Alshawi, 41-60. MIT Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>G Edward Barton</author>
<author>Robert C Berwick</author>
<author>Eric S Ristad</author>
</authors>
<date>1987</date>
<booktitle>Computational Complexity and Natural Language.</booktitle>
<publisher>MIT Press.</publisher>
<marker>Barton, Berwick, Ristad, 1987</marker>
<rawString>Barton, G. Edward; Berwick, Robert C.; and Ristad, Eric S. (1987). Computational Complexity and Natural Language. MIT Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Patrick Blackburn</author>
</authors>
<title>Modal logic and attribute-value structures.&amp;quot; In Modal Logic Colloquium &apos;91, edited by Maarten de Rijke. Dutch Project for Language, Logic and Information,</title>
<date>1991</date>
<location>Amsterdam.</location>
<contexts>
<context position="15244" citStr="Blackburn (1991)" startWordPosition="2278" endWordPosition="2279">omputational tractability. For example, the satisfiability problem for the language consisting of conjunctions of equalities and inequalities of first-order terms can 4 A third approach, developed by Smolka (1992), is to define a specialized language tailored for expressing attribute-value constraints and note its translation into some standard language, in this case, also the Schonfinkel-Bernays&apos; class. 5 Of course, there is no a priori reason for these subsets of first-order logic to be optimally suited for expressing feature structure constraints. Kasper and Rounds (1990) and more recently Blackburn (1991) and Blackburn and Spam (1992) have suggested that it may be useful to express feature structure constraints in a special kind of modal logic. Johnson (1991b) also discusses the application of general first-order logic and nonmonotic logics to the specification of more complex constraints on feature structures. 4 Mark Johnson Computing with Features as Formulae be decided in quasi-linear time using the congruence-closure algorithm, but this language can only express conjunctions of feature-value equalities and inequalities. If this language is extended to allow disjunctions (so that disjunctiv</context>
</contexts>
<marker>Blackburn, 1991</marker>
<rawString>Blackburn, Patrick (1991). &amp;quot;Modal logic and attribute-value structures.&amp;quot; In Modal Logic Colloquium &apos;91, edited by Maarten de Rijke. Dutch Project for Language, Logic and Information, Amsterdam.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Patrick Blackburn</author>
<author>Edith Spaan</author>
</authors>
<title>A modal perspective on the computational complexity of attribute value grammar.&amp;quot;</title>
<date>1992</date>
<booktitle>Logic Group Preprint Series No.</booktitle>
<volume>77</volume>
<institution>Department of Philosophy, University of Utrecht.</institution>
<marker>Blackburn, Spaan, 1992</marker>
<rawString>Blackburn, Patrick, and Spaan, Edith (1992). &amp;quot;A modal perspective on the computational complexity of attribute value grammar.&amp;quot; Logic Group Preprint Series No. 77, Department of Philosophy, University of Utrecht.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Patrick Blackburn</author>
<author>Claire Gardent</author>
<author>Wilfried Meyer-viol</author>
</authors>
<title>Talking about trees.&amp;quot;</title>
<date>1993</date>
<booktitle>In Proceedings, 6th European Meeting of the Asssociation for Computational Linguistics.</booktitle>
<location>Utrecht, Holland.</location>
<marker>Blackburn, Gardent, Meyer-viol, 1993</marker>
<rawString>Blackburn, Patrick; Gardent, Claire; and Meyer-viol, Wilfried (1993). &amp;quot;Talking about trees.&amp;quot; In Proceedings, 6th European Meeting of the Asssociation for Computational Linguistics. Utrecht, Holland.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Joan Bresnan</author>
</authors>
<title>The Mental Representation of Grammatical Relations.</title>
<date>1982</date>
<publisher>MIT Press.</publisher>
<contexts>
<context position="1152" citStr="Bresnan 1982" startWordPosition="155" endWordPosition="156">is algorithm, which generalizes the standard attribute-value unification algorithm, is also recognizable as a nondeterministic variant of the semi-naive bottom-up algorithm for evaluating Datalog programs. further strengthening the connection between the theory of feature structures and databases. 1. Introduction Despite their simplicity, a surprisingly wide range of linguistic phenomena can be described in terms of simple equality constraints on values in attribute-value structures, which are a particularly simple kind of feature structure (see Shieber 1986; Johnson 1988; Uszkoreit 1986; and Bresnan 1982 for examples of some of these analyses). But some phenomena do not seem to be able to be described in such a pure &apos;unification&apos; framework. For example, the analysis of conjunctions in LFG (Kaplan and Maxwell 1988b) and the formalizations of Discourse Representation Theory (Kamp 1981) presented in Johnson and Klein (1986) and Johnson and Kay (1990) require additional mechanisms for representing and manipulating aggregates or sets of values in ways that are beyond the capability of such &amp;quot;pure&amp;quot; attribute-value systems. Further, sortal constraints (which also cannot be expressed as simple equalit</context>
<context position="2552" citStr="Bresnan (1982)" startWordPosition="369" endWordPosition="370"> of constraint, as well as the familiar attribute-value constraints, can be expressed as Schonfinkel-Bernays&apos; formulae (as demonstrated in Johnson 1991a, 1991b), so that the problem of determining the satisfiability of a system of such constraints is reduced to the satisfiability problem for the corresponding formula. This class of formulae (defined in Section 3.1) seems to be expressive enough for most linguistic purposes when used with an external phrase-structure backbone. That is, these formulae are used as annotations on phrase structure rules in the manner described in, e.g., Kaplan and Bresnan (1982), Shieber (1986), and Johnson (1988). This paper extends the author&apos;s previous paper on the topic (Johnson 1991a) by sketching several other linguistic applications of Schonfinkel-Bernays&apos; formulae (including a version of D-theory [Marcus, Hindle, and Fleck 1983; Vijay-Shanker 1992]), and presenting a least-fixed-point theorem that serves as the theoretical basis for a &amp;quot;forwardchaining&amp;quot; algorithm for determining satisfiabiIity of Schonfinkel-Bernays&apos; formulae. Interestingly, this algorithm can be viewed both as a straightforward generalization * Cognitive and Linguistic Sciences, Box 1978, Bro</context>
<context position="4797" citStr="Bresnan 1982" startWordPosition="681" endWordPosition="682">formulae, the constraint formalism described below. A second class of extended constraint formalisms has been devised to be capable of expressing the entire grammar as systems of constraints and as far as I know, for all of these systems the problem of determining the satisfiability of an arbitrary system of constraints that they can express is undecidable.2 This is because the recognition problem for an arbitrary &amp;quot;unification-based&amp;quot; grammar is undecidable unless the size of the phrase structure tree is constrained somehow, e.g., by the offline parsability constraint (Johnson 1988; Kaplan and Bresnan 1982; Pereira 1982; Shieber 1992), but there seems to be no natural way to impose such constraints in these systems because the encoding of the phrase structure tree in the feature structure is not distinguished from other features.&apos; Thus in order to maintain decidability the system described here is not designed to be capable of expressing phrase structure constraints directly, and must be used with an external phrase-structure component, as in LFG (Bresnan 1982). (However, Bob Carpenter [p.c.1 points out that one can impose a bound on the size of the feature structure that can serve as an analys</context>
<context position="10372" citStr="Bresnan (1982)" startWordPosition="1534" endWordPosition="1535">tructure S satisfies a constraint a, then every feature structure subsumed by S should also satisfy a (Pereira 1987). If this &amp;quot;upward closure&amp;quot; property holds, then the set of feature structures satisfying any constraint can be represented by the set of its &amp;quot;minimal models.&amp;quot; Unfortunately, many useful constraints do not have this property. For example, under a classical interpretation, the set of feature structures satisfying negated feature structure constraints are not upward-closed (Moshier and Rounds 1987). The work described in this paper pursues a different approach. Following Kaplan and Bresnan (1982), feature structures are only (components of) linguistic structures, and not partial descriptions of (other) linguistic structures. As such, a feature structure either does or does not satisfy any particular set of constraints. An utterance is well-formed just in case there is some linguistic structure that satisfies all of the constraints imposed by the grammar and has the phonological form of that utterance as its phonological form (which itself is just another constraint that the structure must satisfy). Since the relationship between a feature structure and a constraint that it satisfies i</context>
<context position="14288" citStr="Bresnan (1982)" startWordPosition="2142" endWordPosition="2143">ture Structure Constraints There are many different possible constraint languages. Specialized languages can be constructed specifically for the task of expressing feature structure constraints (such as Kasper and Rounds&apos;s FDL [Kasper and Rounds 19901 and Johnson&apos;s attribute-value languages [Johnson 19881). Alternatively, the constraints may be able to be expressed in some standard language, so that the satisfiability problem for linguistic constraints is reduced to the satisfiability problem for that language, as is done here.&apos; Johnson (1990a), following a suggestion first made in Kaplan and Bresnan (1982), showed how attribute-value constraints could be formalized in the quantifier-free subset of first-order logic, while later work (Johnson 1991a, 1991b) proposed a different formalization in the Schanfinkel-Bernays&apos; subset of first-order formulae.&apos; Roughly speaking, there is a trade-off between the expressive power of a language and its computational tractability. For example, the satisfiability problem for the language consisting of conjunctions of equalities and inequalities of first-order terms can 4 A third approach, developed by Smolka (1992), is to define a specialized language tailored </context>
<context position="21828" citStr="Bresnan 1982" startWordPosition="3290" endWordPosition="3291">er 1987). Formulas (1) and (2) and the instances of schemata (3) and (4) can be regarded as defining attribute-value feature structures. These axioms are quite permissive: in 6 Johnson (1991a) and Smolka (1992) propose that an attribute-value arc labeled a from x to y be conceptualized as an instance of a two-place relation a(x, y). For most applications there is little substantive difference between these two approaches; the approach taken here allows attributes to be quantified over, e.g., to state sortal constraints, and permits values to be used as attributes, as in e.g., T,FG (Kaplan and Bresnan 1982); for discussion and linguistic applications see also Johnson (1988). 7 As Patrick Blackburn (p.c.) points out, one consequence of this is that every model of these constraints will contain individuals corresponding to each attribute-value constant (since each constant symbol will be assigned a denotation). Whether this is desirable or problematic is debatable, but as he pointed out, it is easy to devise a conceptualization in which each attribute-value constant c, is conceptualized as a one-place predicate ci(•) that is true of at most one element. Under such a conceptualization (which can be</context>
</contexts>
<marker>Bresnan, 1982</marker>
<rawString>Bresnan, Joan (1982). The Mental Representation of Grammatical Relations. MIT Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Bob Carpenter</author>
</authors>
<title>Typed feature structures: A generalization of first-order terms.&amp;quot;</title>
<date>1991</date>
<booktitle>In Logic Programming, Proceedings of the 1991 International Symposium, edited by Vijay Saraswat and Kazunori Ueda,</booktitle>
<pages>187--201</pages>
<publisher>MIT Press.</publisher>
<contexts>
<context position="41340" citStr="Carpenter 1991" startWordPosition="6508" endWordPosition="6509">Computing with Features as Formulae (1991), or Genesereth and Nilsson (1987), transform SB formulae into SB formulae in clausal form. Interestingly, clausal form SB formulae correspond one-to-one with an extension to Datalog (Ullman 1988) that allows disjunctive &amp;quot;heads&amp;quot; or consequences. In notation borrowed from disjunctive logic programming (Kowalski 1979; Lobo, Minker, and Rajasekar 1992; Loveland 1987), the clauses above would be written as listed in the appendix. While the connection between logic programming and feature structures is well known (Alt-Kaci 1984; Ait-Kaci and Podelski 1993; Carpenter 1991,1992; Hiihfeld and Smolka 1988; Pereira 1987; Shieber 1992; Smolka 1992), this shows that the theory of feature structure constraints is also related to database theory as well. Negative clauses correspond to Datalog integrity constraints, and clauses with a single positive literal are definite clauses. Simple assertions, e.g., about the existence of arcs, consisting of exactly one positive literal are Datalog atomic clauses. Clauses with two or more positive literals cannot be expressed in Datalog itself, but require the disjunctive extension of Datalog. The appendix displays all of the SB f</context>
</contexts>
<marker>Carpenter, 1991</marker>
<rawString>Carpenter, Bob (1991). &amp;quot;Typed feature structures: A generalization of first-order terms.&amp;quot; In Logic Programming, Proceedings of the 1991 International Symposium, edited by Vijay Saraswat and Kazunori Ueda, 187-201. MIT Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Bob Carpenter</author>
</authors>
<title>The Logic of Typed Feature Structures. Cambridge Tracts in Theoretical Computer Science 32.</title>
<date>1992</date>
<publisher>Cambridge University Press,</publisher>
<location>Cambridge, England.</location>
<contexts>
<context position="1848" citStr="Carpenter 1992" startWordPosition="261" endWordPosition="262">e to be described in such a pure &apos;unification&apos; framework. For example, the analysis of conjunctions in LFG (Kaplan and Maxwell 1988b) and the formalizations of Discourse Representation Theory (Kamp 1981) presented in Johnson and Klein (1986) and Johnson and Kay (1990) require additional mechanisms for representing and manipulating aggregates or sets of values in ways that are beyond the capability of such &amp;quot;pure&amp;quot; attribute-value systems. Further, sortal constraints (which also cannot be expressed as simple equality constraints) can be used to formulate simpler and more comprehensible grammars (Carpenter 1992; Carpenter and Pollard 1991; Pollard and Sag 1987, 1992). Versions of both of these kinds of constraint, as well as the familiar attribute-value constraints, can be expressed as Schonfinkel-Bernays&apos; formulae (as demonstrated in Johnson 1991a, 1991b), so that the problem of determining the satisfiability of a system of such constraints is reduced to the satisfiability problem for the corresponding formula. This class of formulae (defined in Section 3.1) seems to be expressive enough for most linguistic purposes when used with an external phrase-structure backbone. That is, these formulae are u</context>
</contexts>
<marker>Carpenter, 1992</marker>
<rawString>Carpenter, Bob (1992). The Logic of Typed Feature Structures. Cambridge Tracts in Theoretical Computer Science 32. Cambridge University Press, Cambridge, England.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Bob Carpenter</author>
<author>Carl Pollard</author>
</authors>
<title>Inclusion, disjointness and choice: The logic of linguistic classification.&amp;quot;</title>
<date>1991</date>
<booktitle>In Proceedings, 29th Annual Meeting of the Association for Computational Linguistics,</booktitle>
<pages>9--16</pages>
<location>Berkeley, CA.</location>
<contexts>
<context position="1876" citStr="Carpenter and Pollard 1991" startWordPosition="263" endWordPosition="266">d in such a pure &apos;unification&apos; framework. For example, the analysis of conjunctions in LFG (Kaplan and Maxwell 1988b) and the formalizations of Discourse Representation Theory (Kamp 1981) presented in Johnson and Klein (1986) and Johnson and Kay (1990) require additional mechanisms for representing and manipulating aggregates or sets of values in ways that are beyond the capability of such &amp;quot;pure&amp;quot; attribute-value systems. Further, sortal constraints (which also cannot be expressed as simple equality constraints) can be used to formulate simpler and more comprehensible grammars (Carpenter 1992; Carpenter and Pollard 1991; Pollard and Sag 1987, 1992). Versions of both of these kinds of constraint, as well as the familiar attribute-value constraints, can be expressed as Schonfinkel-Bernays&apos; formulae (as demonstrated in Johnson 1991a, 1991b), so that the problem of determining the satisfiability of a system of such constraints is reduced to the satisfiability problem for the corresponding formula. This class of formulae (defined in Section 3.1) seems to be expressive enough for most linguistic purposes when used with an external phrase-structure backbone. That is, these formulae are used as annotations on phrase</context>
</contexts>
<marker>Carpenter, Pollard, 1991</marker>
<rawString>Carpenter, Bob, and Pollard, Carl (1991). &amp;quot;Inclusion, disjointness and choice: The logic of linguistic classification.&amp;quot; In Proceedings, 29th Annual Meeting of the Association for Computational Linguistics, 9-16. Berkeley, CA.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Bob Carpenter</author>
<author>Carl Pollard</author>
<author>Alex Franz</author>
</authors>
<title>The specification and implementation of constraint-based unification grammars.&amp;quot;</title>
<date>1991</date>
<booktitle>In Proceedings, Second International Workshop on Parsing Technologies. Cancun,</booktitle>
<location>Mexico.</location>
<marker>Carpenter, Pollard, Franz, 1991</marker>
<rawString>Carpenter, Bob; Pollard, Carl; and Franz, Alex (1991). &amp;quot;The specification and implementation of constraint-based unification grammars.&amp;quot; In Proceedings, Second International Workshop on Parsing Technologies. Cancun, Mexico.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Chin-Liang Chang</author>
<author>Richard Char-Tung Lee</author>
</authors>
<title>Symbolic Logic and Mechanical Theorem Proving.</title>
<date>1973</date>
<publisher>Academic Press.</publisher>
<contexts>
<context position="37333" citStr="Chang and Lee (1973)" startWordPosition="5811" endWordPosition="5814">ble in an interpretation in which equality is not given any special treatment. In effect, the axioms E require that the equality relation denotes an equivalence relation, and permit the substitution of equals for equals. Together these imply that no predicate can distinguish equal individuals. This means that in terms of satisfiability and the consequence relation, exactly the same results are obtained irrespective of whether equality is treated as identity or defined by the axioms E. Such treatments of equality in first-order logic are well known and described in standard texts. For example, Chang and Lee (1973) give the axiom schemata in Figure 2, which generates syntactic equality axioms E for a first-order formula co, and prove that E has the properties just described.&apos; What is important here is that for an SB formula co the instances of the axiom schemata are all SB formulae, and there are only finitely many instances of these schemata. This means that for an arbitrary SB formula cp there is another SB formula such that co is satisfiable with respect to an identity interpretation of equality if and only if cp/14. is satisfiable with respect to an interpretation in which equality is treated like a</context>
<context position="40702" citStr="Chang and Lee (1973)" startWordPosition="6415" endWordPosition="6418">s the equivalent implication ozi A • A ci,n ,(31 V • • • V Ow A formula ;a in clausal form does not contain any quantifier symbols. As is standard, all variables in y are treated as implicitly universally quantified at the clausal level. Existentially quantified variables in SB formulae are inessential, in that they can always be directly replaced by Skolem constants. Restricting attention to SB formulae in clausal form imposes no real restriction on the class of constraints expressible. Standard procedures for transforming first-order formulae into clausal form, such as the ones described in Chang and Lee (1973), Duffy 12 Mark Johnson Computing with Features as Formulae (1991), or Genesereth and Nilsson (1987), transform SB formulae into SB formulae in clausal form. Interestingly, clausal form SB formulae correspond one-to-one with an extension to Datalog (Ullman 1988) that allows disjunctive &amp;quot;heads&amp;quot; or consequences. In notation borrowed from disjunctive logic programming (Kowalski 1979; Lobo, Minker, and Rajasekar 1992; Loveland 1987), the clauses above would be written as listed in the appendix. While the connection between logic programming and feature structures is well known (Alt-Kaci 1984; Ait-</context>
<context position="55898" citStr="Chang and Lee (1973)" startWordPosition="9034" endWordPosition="9037"> ground atoms that can be formed using the predicate symbols of ,p with elements of U as arguments. A Herbrand interpretation A is a subset of B. Note that the set of Herbrand interpretations 2B,&apos; partially ordered by the subset relation forms a complete lattice. Further, U and hence B are finite iff (,.0 is an SB formula. (If is in clausal form but is not an SB formula then it must contain a function symbol, so its Herbrand universe LI is infinite.) 11 As is standard, if cp has no constant symbols then it is necessary to take U to be a set consisting of a single constant, say fal. See, e.g., Chang and Lee (1973) for details. 17 Computational Linguistics Volume 20, Number I Definition A Herbrand interpretation A trivially falsifies a set of clauses cp iff there is a ground instance —c V - - V ce,t, of a negative clause — ai V • V oem in cp such that • - • , „} C AThat is, a Herbrand interpretation trivially falsifies a set of clauses yo just in case some negative clause in y is false in that interpretation. Clearly, any such interpretation cannot satisfy y, but the converse does not hold: there are interpretations that do not trivially falsify y but still do not satisfy cp because they do not satisfy </context>
</contexts>
<marker>Chang, Lee, 1973</marker>
<rawString>Chang, Chin-Liang, and Lee, Richard Char-Tung (1973). Symbolic Logic and Mechanical Theorem Proving. Academic Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Noam Chomsky</author>
</authors>
<title>Knowledge of Language, Its Nature, Origins and Use.</title>
<date>1986</date>
<publisher>Praeger.</publisher>
<marker>Chomsky, 1986</marker>
<rawString>Chomsky, Noam (1986). Knowledge of Language, Its Nature, Origins and Use. Praeger.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Noam Chomsky</author>
</authors>
<title>Some Notes on Economy of Derivation and Representation. ms.</title>
<date>1988</date>
<institution>Massachusetts Institute of Technology.</institution>
<marker>Chomsky, 1988</marker>
<rawString>Chomsky, Noam (1988). Some Notes on Economy of Derivation and Representation. ms. Massachusetts Institute of Technology.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Thomas H Corman</author>
<author>Charles E Leiserson</author>
<author>Ronald L Rivest</author>
</authors>
<title>Introduction to Algorithms.</title>
<date>1990</date>
<publisher>MIT Press,</publisher>
<marker>Corman, Leiserson, Rivest, 1990</marker>
<rawString>Corman, Thomas H.; Leiserson, Charles E.; and Rivest, Ronald L. (1990). Introduction to Algorithms. MIT Press,</rawString>
</citation>
<citation valid="true">
<authors>
<author>Anuj Dawar</author>
<author>arid Vijay-Shanker</author>
<author>K</author>
</authors>
<title>An interpretation of negation in feature structures.&amp;quot;</title>
<date>1990</date>
<journal>Computational Linguistics</journal>
<volume>16</volume>
<issue>1</issue>
<pages>11--21</pages>
<marker>Dawar, Vijay-Shanker, K, 1990</marker>
<rawString>Dawar, Anuj, arid Vijay-Shanker, K. (1990). &amp;quot;An interpretation of negation in feature structures.&amp;quot; Computational Linguistics 16(1), 11-21.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jochen Dorre</author>
</authors>
<title>The language of STUF.&amp;quot; ha Text Understanding</title>
<date>1991</date>
<booktitle>in LILOG: Integrating Computational Linguistics and Artificial Intelligence, edited by Otthein Herzog and Claus-Rainer Rollinger,</booktitle>
<pages>39--50</pages>
<publisher>Springer-Verlag.</publisher>
<contexts>
<context position="6946" citStr="Dorre (1991)" startWordPosition="1008" endWordPosition="1009">ining algorithm for determining the satisfiability of an arbitrary Schonfinkel-Bernays&apos; formula. This generalizes the standard feature-graph unification algorithm and is closely related to the semi-naive bottom-up algorithm used in database theory. I For examples of this approach see Dawar and Vijay-Shanker (1990), Dorre and Eisele (1990), Johnson (1988, 1990a, 1990b, 1991a, 1991b, in press a), Karttunen (1984), Kasper (1987a, 19871), 1986), Kasper and Rounds (1986, 1990), Langholm (1989), Pereira (1987), and Smolka (1992). 2 Examples of this approach are Carpenter, Pollard, and Franz (1991), Dorre (1991), Done and Eisele (1991), Johnson (in press b), Kay (1979, 1985a, 1985b), Pollard and Sag (1987), Rounds and Manaster-Ramer (1987), Smolka (1988), and Zajac (1992). 3 While it may well be that the universal recognition and parsing problems for natural language are undecidable (Chomsky [1986, 1988] points out that there is no contrary evidence), I know of no evidence that this is actually the case. It seems reasonable then to also investigate formalisms that can only express decidable systems of constraints (and for which there exist satisfiability-testing algorithms) if linguistically adequate</context>
</contexts>
<marker>Dorre, 1991</marker>
<rawString>Dorre, Jochen (1991). &amp;quot;The language of STUF.&amp;quot; ha Text Understanding in LILOG: Integrating Computational Linguistics and Artificial Intelligence, edited by Otthein Herzog and Claus-Rainer Rollinger, 39-50. Springer-Verlag.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jochen DOrre</author>
<author>Andreas Eisele</author>
</authors>
<title>Feature logic with disjunctive unification.&amp;quot;</title>
<date>1990</date>
<booktitle>In Proceedings, 13th International Conference on Computational Linguistics (COLING-90),</booktitle>
<pages>100--105</pages>
<location>Helsinki, Finland.</location>
<marker>DOrre, Eisele, 1990</marker>
<rawString>DOrre, Jochen, and Eisele, Andreas (1990). &amp;quot;Feature logic with disjunctive unification.&amp;quot; In Proceedings, 13th International Conference on Computational Linguistics (COLING-90), 100-105. Helsinki, Finland.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jochen Dorre</author>
<author>Andreas Eisele</author>
</authors>
<title>A comprehensive unification-based grammar formalism.&amp;quot;</title>
<date>1991</date>
<booktitle>DYANA Deliverable R3.1B, ESPRIT Basic Research Action BR3175.</booktitle>
<marker>Dorre, Eisele, 1991</marker>
<rawString>Dorre, Jochen, and Eisele, Andreas (1991). &amp;quot;A comprehensive unification-based grammar formalism.&amp;quot; DYANA Deliverable R3.1B, ESPRIT Basic Research Action BR3175.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jochen Dorre</author>
<author>William C Rounds</author>
</authors>
<title>On subsumption and semiunification in feature algebras.&amp;quot;</title>
<date>1992</date>
<journal>Journal of Symbolic Computation</journal>
<pages>13--441</pages>
<contexts>
<context position="35258" citStr="Dorre and Rounds 1992" startWordPosition="5464" endWordPosition="5467">that is not in SB, since it requires a functional relationship between entities with tense attributes and the values of their number and person attributes. Vx Vy arc (x, tense, y) (z arc(x , number, z)) A (7z arc(x, person, z)) (16) Similarly, a number of other extensions to the basic attribute-value framework discussed in the literature cannot be formalized in SB. Subsumption constraints, used in the treatment of (natural language) conjunction, are not expressible as SB formulae because the satisfiability problem for conjunctions of subsumption and attribute-value constraints is undecidable (Dorre and Rounds 1992). Positively occurring functional 10 Mark Johnson Computing with Features as Formulae (El) Vx x x. (E2) Vy x y y = x. (E3) Vxo Vx x1 = X0 A P(xi , , x), for] 1, 1, ... ,71, for every predicate symbol P appearing in 42. (E4) Vxo . Vx x1= f (X1- • • •xi,.• 7 x73 ) f X0. xn) for] 1, ,n, for every function symbol f appearing in cp. Figure 2 Equality axiom schemata for a first-order formula cp. uncertainty constraints, used in the LFG treatment of long-distance dependencies (Kaplan and Zaenen 1989) appear to have a decidable satisfiability problem (Kaplan and Maxwell 1988a), but the satisfiability </context>
</contexts>
<marker>Dorre, Rounds, 1992</marker>
<rawString>Dorre, Jochen, and Rounds, William C. (1992). &amp;quot;On subsumption and semiunification in feature algebras.&amp;quot; Journal of Symbolic Computation 13,441-461.</rawString>
</citation>
<citation valid="true">
<authors>
<author>David Duffy</author>
</authors>
<title>Principles of Automated Theorem Proving.</title>
<date>1991</date>
<publisher>John Wiley and Sons.</publisher>
<marker>Duffy, 1991</marker>
<rawString>Duffy, David (1991). Principles of Automated Theorem Proving. John Wiley and Sons.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Eisele</author>
<author>J Done</author>
</authors>
<title>Unification of disjunctive feature descriptions.&amp;quot;</title>
<date>1981</date>
<booktitle>In Proceedings, 26th Annual Meeting of the Association for Computational Linguistics,</booktitle>
<pages>286--294</pages>
<location>Buffalo, New York.</location>
<marker>Eisele, Done, 1981</marker>
<rawString>Eisele, A., and Done, J. (19813). &amp;quot;Unification of disjunctive feature descriptions.&amp;quot; In Proceedings, 26th Annual Meeting of the Association for Computational Linguistics, 286-294. Buffalo, New York.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Martin Emele</author>
</authors>
<title>Unification with lazy non-redundant copying.&apos;</title>
<date>1991</date>
<booktitle>In Proceedings, 29th Annual Meeting of the Association for Computational Linguistics,</booktitle>
<pages>323--330</pages>
<location>Berkeley, CA.</location>
<marker>Emele, 1991</marker>
<rawString>Emele, Martin (1991). &amp;quot;Unification with lazy non-redundant copying.&apos; In Proceedings, 29th Annual Meeting of the Association for Computational Linguistics, 323-330. Berkeley, CA.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J H Gallier</author>
</authors>
<date>1986</date>
<institution>Logic for Computer Science. Harper and Row.</institution>
<contexts>
<context position="15951" citStr="Gallier 1986" startWordPosition="2379" endWordPosition="2380">e constraints in a special kind of modal logic. Johnson (1991b) also discusses the application of general first-order logic and nonmonotic logics to the specification of more complex constraints on feature structures. 4 Mark Johnson Computing with Features as Formulae be decided in quasi-linear time using the congruence-closure algorithm, but this language can only express conjunctions of feature-value equalities and inequalities. If this language is extended to allow disjunctions (so that disjunctive feature-value constraints can be expressed), the satisfiability problem becomes NP-complete (Gallier 1986; Kasper and Rounds 1990; Nelson and Oppen 1980). Since disjunctive constraints seem to be a practical necessity for describing natural languages (Barton, Berwick, and Ristad 1987; Karthinen 1984), most practical feature structure systems will probably have NP-hard satisfiability problems. Given that we have to solve an NP-hard problem anyway, it seems reasonable to investigate the most expressive feature structure constraint language that has an NP-complete satisfiability problem. The Schonfinkel-Bernays&apos; class, used in the manner described here, appears to be the most expressive language for</context>
<context position="47179" citStr="Gallier 1986" startWordPosition="7493" endWordPosition="7494">e atoms in A, then instances of (E2) and (F3) ensure that p(b),q(a) and b ---= a will be added to AA and thence to A. In general, if it is discovered that n constants al, ... a, are equal, then A will ultimately contain the n2 equalities ai ar 1 &lt; i &lt; n, 1 &lt; j &lt; n, as well as at least n &amp;quot;copies&amp;quot; of any predicate containing any a„ 5.3 Union-Find and Equality As noted above, the equality axioms ensure that the relation that the equality symbol denotes is an equivalence relation and the substitutivity of equals for equals. in general, the union-find algorithm (Corman, Leiserson, and Rivest 1990; Gallier 1986; Nelson and Oppen 1980) maintains the equivalence classes of the equality relation far more efficiently than an approach that uses the syntactic equality axioms. The equivalence classes are encoded by associating each constant with a pointer that is either null or points to another constant, where a points to b only if a =-- b. These pointer correspond exactly to the &amp;quot;invisible pointers&amp;quot; used in standard implementations of the attribute-value unification algorithm. 14 Mark Johnson Computing with Features as Formulae Input: A set of SB clauses S. Output: A set of ground clauses A iff S is sati</context>
</contexts>
<marker>Gallier, 1986</marker>
<rawString>Gallier, J. H. (1986). Logic for Computer Science. Harper and Row.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Genesereth</author>
<author>N Nilsson</author>
</authors>
<title>Logical Foundations of Artificial Intelligence.</title>
<date>1987</date>
<publisher>Morgan Kaufmann.</publisher>
<contexts>
<context position="40802" citStr="Genesereth and Nilsson (1987)" startWordPosition="6430" endWordPosition="6433">does not contain any quantifier symbols. As is standard, all variables in y are treated as implicitly universally quantified at the clausal level. Existentially quantified variables in SB formulae are inessential, in that they can always be directly replaced by Skolem constants. Restricting attention to SB formulae in clausal form imposes no real restriction on the class of constraints expressible. Standard procedures for transforming first-order formulae into clausal form, such as the ones described in Chang and Lee (1973), Duffy 12 Mark Johnson Computing with Features as Formulae (1991), or Genesereth and Nilsson (1987), transform SB formulae into SB formulae in clausal form. Interestingly, clausal form SB formulae correspond one-to-one with an extension to Datalog (Ullman 1988) that allows disjunctive &amp;quot;heads&amp;quot; or consequences. In notation borrowed from disjunctive logic programming (Kowalski 1979; Lobo, Minker, and Rajasekar 1992; Loveland 1987), the clauses above would be written as listed in the appendix. While the connection between logic programming and feature structures is well known (Alt-Kaci 1984; Ait-Kaci and Podelski 1993; Carpenter 1991,1992; Hiihfeld and Smolka 1988; Pereira 1987; Shieber 1992; S</context>
</contexts>
<marker>Genesereth, Nilsson, 1987</marker>
<rawString>Genesereth, M., and Nilsson, N. (1987). Logical Foundations of Artificial Intelligence. Morgan Kaufmann.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Stephen J Hegner</author>
</authors>
<title>Horn extended feature structures: Fast unification with negation and limited disjunction.&amp;quot;</title>
<date>1991</date>
<booktitle>In Proceedings, Fifth Conference of the European Chapter of the Association for Computational Linguistics,</booktitle>
<pages>33--38</pages>
<location>Berlin.</location>
<contexts>
<context position="43819" citStr="Hegner (1991)" startWordPosition="6927" endWordPosition="6928">ing conditions hold (the next section proves this assertion). (a) For no ground instance — ai V • • v ci,c, of any negative clause in S are all of a, ... , ar, in A. (If they were, then that clause would be falsified by A.) (b) For each ground instance 3/1 V • • • V of a positive clause in S. at least one of the 811 is in A. (c) For each ground instance a; A • • A ce V • • V of an implication in 5, if all of the a; , are in A then so is at least one of the O.; , (In fact, the other two conditions are just special cases of this condition.) 9 It is a generalization of the algorithm described in Hegner (1991), which treats Horn combinations of attribute-value constraints. 13 Computational Linguistics Volume 20, Number I 5.1 Naive Evaluation One could attempt to find such a set A in the following manner. First, one nondeterministically selects a a; from each of the ground instances of the positive clauses in S and adds these to A. Then one attempts to close A with respect to condition (c); if all of the antecedentsat,... am of some (ground instance of an) implication are in A, then one of the consequents f, ,,(3„/ is nondeterministically selected and added to A, unless at least one of them is alrea</context>
<context position="66857" citStr="Hegner (1991)" startWordPosition="10987" endWordPosition="10988">ial time in the worst case, and unless P=NP no tractable general-purpose algorithm for determining the satisfiability of SB formulae exists. With present technology, the best we can hope for is an algorithm that performs adequately on the types of problems that we actually encounter. Sometimes disjunctive constraints can be (automatically) transformed into nondisjunctive ones, thus avoiding the problem entirely. For example, Alshawi (1992) describes a technique attributed to Colmerauer for transforming disjunctions of finitedomain feature-value constraints into conjunctions. Kasper (1988) and Hegner (1991) point out that Horn clauses, although technically disjunctions, can be handled considerably more efficiently than general disjunctive constraints. The forward-chaining mechanisms that they propose for treating these constraints appear to be special cases of the semi-naive algorithm sketched in this paper. Unfortunately, I know of no general adequate method for handling the disjunctive constraints that arise in real grammars with acceptable efficiency. The techniques discussed by Maxwell and Kaplan (1991, 1992) seem most directly compatible with the approach described in this paper, and the me</context>
</contexts>
<marker>Hegner, 1991</marker>
<rawString>Hegner, Stephen J. (1991). &amp;quot;Horn extended feature structures: Fast unification with negation and limited disjunction.&amp;quot; In Proceedings, Fifth Conference of the European Chapter of the Association for Computational Linguistics, 33-38. Berlin.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Markus Hafeld</author>
<author>Gert Srnolka</author>
</authors>
<title>Definite relations over constraint languages.&amp;quot;</title>
<date>1988</date>
<tech>LILOG Report No. 53, IBM Deutschland.</tech>
<marker>Hafeld, Srnolka, 1988</marker>
<rawString>Hafeld, Markus, and Srnolka, Gert. (1988). &amp;quot;Definite relations over constraint languages.&amp;quot; LILOG Report No. 53, IBM Deutschland.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Mark Johnson</author>
</authors>
<date>1988</date>
<journal>Attribute-Value Logic</journal>
<contexts>
<context position="1118" citStr="Johnson 1988" startWordPosition="150" endWordPosition="151">termining their satisfiability. This algorithm, which generalizes the standard attribute-value unification algorithm, is also recognizable as a nondeterministic variant of the semi-naive bottom-up algorithm for evaluating Datalog programs. further strengthening the connection between the theory of feature structures and databases. 1. Introduction Despite their simplicity, a surprisingly wide range of linguistic phenomena can be described in terms of simple equality constraints on values in attribute-value structures, which are a particularly simple kind of feature structure (see Shieber 1986; Johnson 1988; Uszkoreit 1986; and Bresnan 1982 for examples of some of these analyses). But some phenomena do not seem to be able to be described in such a pure &apos;unification&apos; framework. For example, the analysis of conjunctions in LFG (Kaplan and Maxwell 1988b) and the formalizations of Discourse Representation Theory (Kamp 1981) presented in Johnson and Klein (1986) and Johnson and Kay (1990) require additional mechanisms for representing and manipulating aggregates or sets of values in ways that are beyond the capability of such &amp;quot;pure&amp;quot; attribute-value systems. Further, sortal constraints (which also can</context>
<context position="2588" citStr="Johnson (1988)" startWordPosition="374" endWordPosition="375">iar attribute-value constraints, can be expressed as Schonfinkel-Bernays&apos; formulae (as demonstrated in Johnson 1991a, 1991b), so that the problem of determining the satisfiability of a system of such constraints is reduced to the satisfiability problem for the corresponding formula. This class of formulae (defined in Section 3.1) seems to be expressive enough for most linguistic purposes when used with an external phrase-structure backbone. That is, these formulae are used as annotations on phrase structure rules in the manner described in, e.g., Kaplan and Bresnan (1982), Shieber (1986), and Johnson (1988). This paper extends the author&apos;s previous paper on the topic (Johnson 1991a) by sketching several other linguistic applications of Schonfinkel-Bernays&apos; formulae (including a version of D-theory [Marcus, Hindle, and Fleck 1983; Vijay-Shanker 1992]), and presenting a least-fixed-point theorem that serves as the theoretical basis for a &amp;quot;forwardchaining&amp;quot; algorithm for determining satisfiabiIity of Schonfinkel-Bernays&apos; formulae. Interestingly, this algorithm can be viewed both as a straightforward generalization * Cognitive and Linguistic Sciences, Box 1978, Brown University, Providence, RI. Mark_</context>
<context position="4772" citStr="Johnson 1988" startWordPosition="677" endWordPosition="678"> as Schonfinkel-Bernays&apos; formulae, the constraint formalism described below. A second class of extended constraint formalisms has been devised to be capable of expressing the entire grammar as systems of constraints and as far as I know, for all of these systems the problem of determining the satisfiability of an arbitrary system of constraints that they can express is undecidable.2 This is because the recognition problem for an arbitrary &amp;quot;unification-based&amp;quot; grammar is undecidable unless the size of the phrase structure tree is constrained somehow, e.g., by the offline parsability constraint (Johnson 1988; Kaplan and Bresnan 1982; Pereira 1982; Shieber 1992), but there seems to be no natural way to impose such constraints in these systems because the encoding of the phrase structure tree in the feature structure is not distinguished from other features.&apos; Thus in order to maintain decidability the system described here is not designed to be capable of expressing phrase structure constraints directly, and must be used with an external phrase-structure component, as in LFG (Bresnan 1982). (However, Bob Carpenter [p.c.1 points out that one can impose a bound on the size of the feature structure th</context>
<context position="6689" citStr="Johnson (1988" startWordPosition="970" endWordPosition="971"> they can be used to impose useful sort constraints (Johnson 1991b). The expression of D-theory constraints on nodes in trees is discussed in this paper. This paper extends the ideas in these earlier papers with theoretical results that suggest a forward-chaining algorithm for determining the satisfiability of an arbitrary Schonfinkel-Bernays&apos; formula. This generalizes the standard feature-graph unification algorithm and is closely related to the semi-naive bottom-up algorithm used in database theory. I For examples of this approach see Dawar and Vijay-Shanker (1990), Dorre and Eisele (1990), Johnson (1988, 1990a, 1990b, 1991a, 1991b, in press a), Karttunen (1984), Kasper (1987a, 19871), 1986), Kasper and Rounds (1986, 1990), Langholm (1989), Pereira (1987), and Smolka (1992). 2 Examples of this approach are Carpenter, Pollard, and Franz (1991), Dorre (1991), Done and Eisele (1991), Johnson (in press b), Kay (1979, 1985a, 1985b), Pollard and Sag (1987), Rounds and Manaster-Ramer (1987), Smolka (1988), and Zajac (1992). 3 While it may well be that the universal recognition and parsing problems for natural language are undecidable (Chomsky [1986, 1988] points out that there is no contrary evidenc</context>
<context position="9397" citStr="Johnson (1988)" startWordPosition="1382" endWordPosition="1383">n &amp;quot;information-preserving&amp;quot; way (Shieber 1986). If two feature structures contain &amp;quot;contradictory information,&amp;quot; then it is impossible to merge them to produce a consistent object; unification is then said to fail. The feature structure for an utterance is the result (if one exists) of unifying all of the feature structures for the lexical entries and syntactic rules in appropriate ways. Thus in this view feature structures play two roles; not only do they serve as linguistic structures, but they are also used to encode constraints that the linguistic structures must satisfy (see Section 2.10 of Johnson (1988) for an extended discussion). That is, under this view feature structures serve not only as linguistic structures that may or may not satisfy a constraint, but are also interpreted as &apos;representing&apos; or &apos;describing&apos; all of the feature structures that they subsume. Given this dual role for feature structures, it is important in this approach that if a feature structure S satisfies a constraint a, then every feature structure subsumed by S should also satisfy a (Pereira 1987). If this &amp;quot;upward closure&amp;quot; property holds, then the set of feature structures satisfying any constraint can be represented </context>
<context position="13979" citStr="Johnson 1988" startWordPosition="2096" endWordPosition="2097">hat are satisfied by more than one interpretation. The consequence relation corresponds to the subsumption relation of traditional unification grammar (a formula a &amp;quot;contains more information&amp;quot; than formula a&apos; iff a a`), and unsatisfiability corresponds to unification failure. 3. Languages for Expressing Feature Structure Constraints There are many different possible constraint languages. Specialized languages can be constructed specifically for the task of expressing feature structure constraints (such as Kasper and Rounds&apos;s FDL [Kasper and Rounds 19901 and Johnson&apos;s attribute-value languages [Johnson 19881). Alternatively, the constraints may be able to be expressed in some standard language, so that the satisfiability problem for linguistic constraints is reduced to the satisfiability problem for that language, as is done here.&apos; Johnson (1990a), following a suggestion first made in Kaplan and Bresnan (1982), showed how attribute-value constraints could be formalized in the quantifier-free subset of first-order logic, while later work (Johnson 1991a, 1991b) proposed a different formalization in the Schanfinkel-Bernays&apos; subset of first-order formulae.&apos; Roughly speaking, there is a trade-off bet</context>
<context position="21896" citStr="Johnson (1988)" startWordPosition="3299" endWordPosition="3300">d (4) can be regarded as defining attribute-value feature structures. These axioms are quite permissive: in 6 Johnson (1991a) and Smolka (1992) propose that an attribute-value arc labeled a from x to y be conceptualized as an instance of a two-place relation a(x, y). For most applications there is little substantive difference between these two approaches; the approach taken here allows attributes to be quantified over, e.g., to state sortal constraints, and permits values to be used as attributes, as in e.g., T,FG (Kaplan and Bresnan 1982); for discussion and linguistic applications see also Johnson (1988). 7 As Patrick Blackburn (p.c.) points out, one consequence of this is that every model of these constraints will contain individuals corresponding to each attribute-value constant (since each constant symbol will be assigned a denotation). Whether this is desirable or problematic is debatable, but as he pointed out, it is easy to devise a conceptualization in which each attribute-value constant c, is conceptualized as a one-place predicate ci(•) that is true of at most one element. Under such a conceptualization (which can be formalized in SB as shown below) attribute-value constants would be</context>
</contexts>
<marker>Johnson, 1988</marker>
<rawString>Johnson, Mark (1988). Attribute-Value Logic</rawString>
</citation>
<citation valid="true">
<authors>
<author>Mark Johnson</author>
</authors>
<title>Expressing disjunctive and negative feature constraints with classical first-order logic.&amp;quot;</title>
<date>1990</date>
<booktitle>In Proceedings, 28th Annual Meeting of the Association for Computational Linguistics,</booktitle>
<pages>173--179</pages>
<location>Pittsburgh, PA.</location>
<contexts>
<context position="6015" citStr="Johnson 1990" startWordPosition="871" endWordPosition="872">y, some polynomial of the length of the input], and so ensure decidability.) Interestingly, a first-order logicbased approach similar to the one presented in this paper can also be developed for extended constraint formalisms capable of expressing the entire grammar, but this is not discussed further here; see Johnson (in press b) for details. In the approach developed here Schonfinkel-Bernays&apos; formulae are used to express a variety of feature structure constraints. Previous work has shown that these formulae are expressive enough to define arbitrary disjunctions and negations of constraints (Johnson 1990a, 1990b), a kind of &apos;set-valued&apos; entity (Johnson 1991a), and they can be used to impose useful sort constraints (Johnson 1991b). The expression of D-theory constraints on nodes in trees is discussed in this paper. This paper extends the ideas in these earlier papers with theoretical results that suggest a forward-chaining algorithm for determining the satisfiability of an arbitrary Schonfinkel-Bernays&apos; formula. This generalizes the standard feature-graph unification algorithm and is closely related to the semi-naive bottom-up algorithm used in database theory. I For examples of this approach </context>
<context position="14222" citStr="Johnson (1990" startWordPosition="2132" endWordPosition="2133">rresponds to unification failure. 3. Languages for Expressing Feature Structure Constraints There are many different possible constraint languages. Specialized languages can be constructed specifically for the task of expressing feature structure constraints (such as Kasper and Rounds&apos;s FDL [Kasper and Rounds 19901 and Johnson&apos;s attribute-value languages [Johnson 19881). Alternatively, the constraints may be able to be expressed in some standard language, so that the satisfiability problem for linguistic constraints is reduced to the satisfiability problem for that language, as is done here.&apos; Johnson (1990a), following a suggestion first made in Kaplan and Bresnan (1982), showed how attribute-value constraints could be formalized in the quantifier-free subset of first-order logic, while later work (Johnson 1991a, 1991b) proposed a different formalization in the Schanfinkel-Bernays&apos; subset of first-order formulae.&apos; Roughly speaking, there is a trade-off between the expressive power of a language and its computational tractability. For example, the satisfiability problem for the language consisting of conjunctions of equalities and inequalities of first-order terms can 4 A third approach, develop</context>
</contexts>
<marker>Johnson, 1990</marker>
<rawString>Johnson, Mark (1990a). &amp;quot;Expressing disjunctive and negative feature constraints with classical first-order logic.&amp;quot; In Proceedings, 28th Annual Meeting of the Association for Computational Linguistics, 173-179. Pittsburgh, PA.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Mark Johnson</author>
</authors>
<title>Features, frames and quantifier-free formulae.&amp;quot;</title>
<date>1990</date>
<booktitle>In Logic and Logic Grammars for Language Processing, edited by Patrick Saint-Dizier and Stan Szpakowicz,</booktitle>
<pages>94--107</pages>
<publisher>Ellis Horwood.</publisher>
<contexts>
<context position="6015" citStr="Johnson 1990" startWordPosition="871" endWordPosition="872">y, some polynomial of the length of the input], and so ensure decidability.) Interestingly, a first-order logicbased approach similar to the one presented in this paper can also be developed for extended constraint formalisms capable of expressing the entire grammar, but this is not discussed further here; see Johnson (in press b) for details. In the approach developed here Schonfinkel-Bernays&apos; formulae are used to express a variety of feature structure constraints. Previous work has shown that these formulae are expressive enough to define arbitrary disjunctions and negations of constraints (Johnson 1990a, 1990b), a kind of &apos;set-valued&apos; entity (Johnson 1991a), and they can be used to impose useful sort constraints (Johnson 1991b). The expression of D-theory constraints on nodes in trees is discussed in this paper. This paper extends the ideas in these earlier papers with theoretical results that suggest a forward-chaining algorithm for determining the satisfiability of an arbitrary Schonfinkel-Bernays&apos; formula. This generalizes the standard feature-graph unification algorithm and is closely related to the semi-naive bottom-up algorithm used in database theory. I For examples of this approach </context>
<context position="14222" citStr="Johnson (1990" startWordPosition="2132" endWordPosition="2133">rresponds to unification failure. 3. Languages for Expressing Feature Structure Constraints There are many different possible constraint languages. Specialized languages can be constructed specifically for the task of expressing feature structure constraints (such as Kasper and Rounds&apos;s FDL [Kasper and Rounds 19901 and Johnson&apos;s attribute-value languages [Johnson 19881). Alternatively, the constraints may be able to be expressed in some standard language, so that the satisfiability problem for linguistic constraints is reduced to the satisfiability problem for that language, as is done here.&apos; Johnson (1990a), following a suggestion first made in Kaplan and Bresnan (1982), showed how attribute-value constraints could be formalized in the quantifier-free subset of first-order logic, while later work (Johnson 1991a, 1991b) proposed a different formalization in the Schanfinkel-Bernays&apos; subset of first-order formulae.&apos; Roughly speaking, there is a trade-off between the expressive power of a language and its computational tractability. For example, the satisfiability problem for the language consisting of conjunctions of equalities and inequalities of first-order terms can 4 A third approach, develop</context>
</contexts>
<marker>Johnson, 1990</marker>
<rawString>Johnson, Mark (1990b). &amp;quot;Features, frames and quantifier-free formulae.&amp;quot; In Logic and Logic Grammars for Language Processing, edited by Patrick Saint-Dizier and Stan Szpakowicz, 94-107. Ellis Horwood.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Mark Johnson</author>
</authors>
<title>Features and formulae.&amp;quot;</title>
<date>1991</date>
<journal>Computational Linguistics</journal>
<volume>17</volume>
<issue>2</issue>
<pages>131--152</pages>
<contexts>
<context position="2089" citStr="Johnson 1991" startWordPosition="296" endWordPosition="298">nd Johnson and Kay (1990) require additional mechanisms for representing and manipulating aggregates or sets of values in ways that are beyond the capability of such &amp;quot;pure&amp;quot; attribute-value systems. Further, sortal constraints (which also cannot be expressed as simple equality constraints) can be used to formulate simpler and more comprehensible grammars (Carpenter 1992; Carpenter and Pollard 1991; Pollard and Sag 1987, 1992). Versions of both of these kinds of constraint, as well as the familiar attribute-value constraints, can be expressed as Schonfinkel-Bernays&apos; formulae (as demonstrated in Johnson 1991a, 1991b), so that the problem of determining the satisfiability of a system of such constraints is reduced to the satisfiability problem for the corresponding formula. This class of formulae (defined in Section 3.1) seems to be expressive enough for most linguistic purposes when used with an external phrase-structure backbone. That is, these formulae are used as annotations on phrase structure rules in the manner described in, e.g., Kaplan and Bresnan (1982), Shieber (1986), and Johnson (1988). This paper extends the author&apos;s previous paper on the topic (Johnson 1991a) by sketching several ot</context>
<context position="6069" citStr="Johnson 1991" startWordPosition="879" endWordPosition="880"> ensure decidability.) Interestingly, a first-order logicbased approach similar to the one presented in this paper can also be developed for extended constraint formalisms capable of expressing the entire grammar, but this is not discussed further here; see Johnson (in press b) for details. In the approach developed here Schonfinkel-Bernays&apos; formulae are used to express a variety of feature structure constraints. Previous work has shown that these formulae are expressive enough to define arbitrary disjunctions and negations of constraints (Johnson 1990a, 1990b), a kind of &apos;set-valued&apos; entity (Johnson 1991a), and they can be used to impose useful sort constraints (Johnson 1991b). The expression of D-theory constraints on nodes in trees is discussed in this paper. This paper extends the ideas in these earlier papers with theoretical results that suggest a forward-chaining algorithm for determining the satisfiability of an arbitrary Schonfinkel-Bernays&apos; formula. This generalizes the standard feature-graph unification algorithm and is closely related to the semi-naive bottom-up algorithm used in database theory. I For examples of this approach see Dawar and Vijay-Shanker (1990), Dorre and Eisele (</context>
<context position="14431" citStr="Johnson 1991" startWordPosition="2162" endWordPosition="2163">task of expressing feature structure constraints (such as Kasper and Rounds&apos;s FDL [Kasper and Rounds 19901 and Johnson&apos;s attribute-value languages [Johnson 19881). Alternatively, the constraints may be able to be expressed in some standard language, so that the satisfiability problem for linguistic constraints is reduced to the satisfiability problem for that language, as is done here.&apos; Johnson (1990a), following a suggestion first made in Kaplan and Bresnan (1982), showed how attribute-value constraints could be formalized in the quantifier-free subset of first-order logic, while later work (Johnson 1991a, 1991b) proposed a different formalization in the Schanfinkel-Bernays&apos; subset of first-order formulae.&apos; Roughly speaking, there is a trade-off between the expressive power of a language and its computational tractability. For example, the satisfiability problem for the language consisting of conjunctions of equalities and inequalities of first-order terms can 4 A third approach, developed by Smolka (1992), is to define a specialized language tailored for expressing attribute-value constraints and note its translation into some standard language, in this case, also the Schonfinkel-Bernays&apos; cl</context>
<context position="19064" citStr="Johnson (1991" startWordPosition="2853" endWordPosition="2854">understand how the properties of attribute-value structures can be stated in SB, since many of the techniques used to formalize them can be applied to other linguistically interesting structures as well. In fact there are several ways of formalizing attribute-value structures in SB, all of which seem to be linguistically equivalent. What follows is a formalization in SB that allows values to be used as attributes and allows attributes to be quantified over (this is handy for stating &amp;quot;sort constraints&amp;quot;), but no special claims are made for it over and above any other SB formalization. Following Johnson (1991b), attribute-value feature structures can be specified in SB in the following way. We can conceptualize of attribute-value arcs as instances of 5 Computational Linguistics Volume 20, Number 1 a three-place relation arc, where arc(x,a, y) means that there is an arc leaving node x labeled a pointing to node y.6 Of course, not all interpretations qualify as attribute-value structures; e.g., those which satisfy both arc(x,a,y) and arc(x,a,z) for some y z violate the requirement that there is at most one arc with any given label leaving any node. We can express this requirement as an SB formula th</context>
<context position="21405" citStr="Johnson (1991" startWordPosition="3222" endWordPosition="3223"> language for use as the names of attribute-value constants, and require that they satisfy the following schemata.&apos; For each c in N, con(c). (3) For each distinct pair c1, C2 in N, c1 c2. (4) Schema (3) requires each symbol in N to denote an attribute-value constant, and schema (4) enforces distinctness in essentially the same manner as that used in the specification systems of algebraic data-type theory (Kapur and Musser 1987). Formulas (1) and (2) and the instances of schemata (3) and (4) can be regarded as defining attribute-value feature structures. These axioms are quite permissive: in 6 Johnson (1991a) and Smolka (1992) propose that an attribute-value arc labeled a from x to y be conceptualized as an instance of a two-place relation a(x, y). For most applications there is little substantive difference between these two approaches; the approach taken here allows attributes to be quantified over, e.g., to state sortal constraints, and permits values to be used as attributes, as in e.g., T,FG (Kaplan and Bresnan 1982); for discussion and linguistic applications see also Johnson (1988). 7 As Patrick Blackburn (p.c.) points out, one consequence of this is that every model of these constraints </context>
<context position="23838" citStr="Johnson (1991" startWordPosition="3606" endWordPosition="3607">re of (in fact, some analyses crucially depend on their existence, as described in section 2.1.3 of Johnson [19881), so in the interests of parsimony additional constraints that forbid them are not stipulated. In fact, because SB formulae possess the finite model property (i.e., if an SB formula has a model, then it has a finite model), restricting attention to finite models does not change the set of satisfiable SB formulae. Therefore it could have no effect on the set of well-formed utterances. Cyclic feature structures can be prohibited with a constraint formalizable in SB, as described in Johnson (1991b), and one can express a constraint in SB that requires that all attributes are &amp;quot;attribute-value constants&amp;quot; (even though there appears to be no linguistic motivation for such a constraint, and indeed, some analyses crucially depend on this not being the case, as pointed out in Johnson [19881). To summarize, the simplest SB axioms defining attribute-value structures are quite permissive, allowing a wider range of structures to count as attribute-value structures than many other formalizations. However, all of the major restrictions on attributevalue structures discussed in the literature eithe</context>
<context position="25875" citStr="Johnson (1991" startWordPosition="3934" endWordPosition="3935">ibute-value &amp;quot;unification&amp;quot; is the conjunction and simplification of the formulae expressing the constraints to be unified. If all three constraints in the example of Figure 1 are conjoined together with axioms (1-3) above, then by (1) it follows that bi = b2. Further, if b1 and b2 are distinct constant symbols in N (thus they name attribute-value constants), then 171 b2 is an instance of (4), and the conjunction is therefore unsatisfiable. For further examples and a discussion of how the disjunction and negation of attribute-value constraints are transparently representable as SB formulae, see Johnson (1991a, 1991b). 7 Computational Linguistics Volume 20, Number .1 A major motivation for using SB is that a wide variety of constraints, in addition to standard attribute-value constraints, can be expressed using it. This allows a grammar developer to introduce a wide variety of &amp;quot;designer features&amp;quot; with possibly idiosyncratic, customized properties, while guaranteeing that the composite system is decidable (usually in NP-time, as noted above). For example, suppose we want to impose sort restrictions of the following kind. To abbreviate the lexical entries of verbs we might introduce the one-place pr</context>
<context position="27343" citStr="Johnson (1991" startWordPosition="4172" endWordPosition="4173">(5) Similarly, constraints that restrict the possible values of certain attributes can be imposed. For example, one might want to require that the value of every arc labeled number is either singular or plural. This constraint can be expressed as the following SB formula. Vx Vy arc(x , number , y) y = singular V y plural. (6) These examples demonstrate only a small fraction of the variety of the feature structure constraints that can be expressed in SB. Even though all of these examples are based on attribute-value features, other sorts of features can be described in SB as well. For example, Johnson (1991a) shows how to formulate a variety of constraints on `setvalued&apos; features in SB. 3.4 Expressing Tree Structure Constraints with SB Formulae Inspired by the work on description theory or &apos;D-theory&apos; (Marcus, Hindle, and Fleck 1983; Vijay-Shanker 1992), this section shows how some elementary constraints on precedence and dominance in a tree can be expressed as SB formulae. It differs from that work in that different kinds of constraints are expressible (Vijay-Shanker was concerned with the formalization of a different kind of grammar), and that all of the constraints expressible in the system de</context>
<context position="32475" citStr="Johnson (1991" startWordPosition="5025" endWordPosition="5026">ssing both tree structure and the variety of feature structure constraints that the SB approach described here can. Blackburn, Gardent, and Meyer-viol (1993) introduce a modal language LT for describing trees decorated with feature structures, whose satisfiability problem is undecidable. In the long run, such specialized &amp;quot;designer logics&amp;quot; may provide the most satisfying integration of tree structure and feature structure constraints. Second, the &apos;one-sided&apos; approximation (14a) can be used in place of the correct axiom (14). The effect of using such one-sided approximations was investigated in Johnson (1991a). It was shown there that if is a formula such as the one in (14) and is the one-sided approximation (14a), then for any formula yg+ (C) in which C only appears positively, A (p+ (C) is satisfiable iff A co+ (C) is satisfiable. That is, if we are concerned only with positively occurring constraints, we can simplify (14) to (14a), i.e., ignore (14b), without affecting constraint satisfiability. Third, we can regard formulae such as (14) as the &amp;quot;macro&amp;quot; (15), used to expand constraints at the interface between the syntactic rules and the constraint solver. This &amp;quot;macro expansion&amp;quot; rewrites c-comm</context>
</contexts>
<marker>Johnson, 1991</marker>
<rawString>Johnson, Mark (1991a). &amp;quot;Features and formulae.&amp;quot; Computational Linguistics 17(2), 131-152.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Mark Johnson</author>
</authors>
<title>Logic and feature structures.&amp;quot;</title>
<date>1991</date>
<booktitle>In Proceedings, International Joint Conference on Artificial Intelligence.</booktitle>
<location>Sydney.</location>
<contexts>
<context position="2089" citStr="Johnson 1991" startWordPosition="296" endWordPosition="298">nd Johnson and Kay (1990) require additional mechanisms for representing and manipulating aggregates or sets of values in ways that are beyond the capability of such &amp;quot;pure&amp;quot; attribute-value systems. Further, sortal constraints (which also cannot be expressed as simple equality constraints) can be used to formulate simpler and more comprehensible grammars (Carpenter 1992; Carpenter and Pollard 1991; Pollard and Sag 1987, 1992). Versions of both of these kinds of constraint, as well as the familiar attribute-value constraints, can be expressed as Schonfinkel-Bernays&apos; formulae (as demonstrated in Johnson 1991a, 1991b), so that the problem of determining the satisfiability of a system of such constraints is reduced to the satisfiability problem for the corresponding formula. This class of formulae (defined in Section 3.1) seems to be expressive enough for most linguistic purposes when used with an external phrase-structure backbone. That is, these formulae are used as annotations on phrase structure rules in the manner described in, e.g., Kaplan and Bresnan (1982), Shieber (1986), and Johnson (1988). This paper extends the author&apos;s previous paper on the topic (Johnson 1991a) by sketching several ot</context>
<context position="6069" citStr="Johnson 1991" startWordPosition="879" endWordPosition="880"> ensure decidability.) Interestingly, a first-order logicbased approach similar to the one presented in this paper can also be developed for extended constraint formalisms capable of expressing the entire grammar, but this is not discussed further here; see Johnson (in press b) for details. In the approach developed here Schonfinkel-Bernays&apos; formulae are used to express a variety of feature structure constraints. Previous work has shown that these formulae are expressive enough to define arbitrary disjunctions and negations of constraints (Johnson 1990a, 1990b), a kind of &apos;set-valued&apos; entity (Johnson 1991a), and they can be used to impose useful sort constraints (Johnson 1991b). The expression of D-theory constraints on nodes in trees is discussed in this paper. This paper extends the ideas in these earlier papers with theoretical results that suggest a forward-chaining algorithm for determining the satisfiability of an arbitrary Schonfinkel-Bernays&apos; formula. This generalizes the standard feature-graph unification algorithm and is closely related to the semi-naive bottom-up algorithm used in database theory. I For examples of this approach see Dawar and Vijay-Shanker (1990), Dorre and Eisele (</context>
<context position="14431" citStr="Johnson 1991" startWordPosition="2162" endWordPosition="2163">task of expressing feature structure constraints (such as Kasper and Rounds&apos;s FDL [Kasper and Rounds 19901 and Johnson&apos;s attribute-value languages [Johnson 19881). Alternatively, the constraints may be able to be expressed in some standard language, so that the satisfiability problem for linguistic constraints is reduced to the satisfiability problem for that language, as is done here.&apos; Johnson (1990a), following a suggestion first made in Kaplan and Bresnan (1982), showed how attribute-value constraints could be formalized in the quantifier-free subset of first-order logic, while later work (Johnson 1991a, 1991b) proposed a different formalization in the Schanfinkel-Bernays&apos; subset of first-order formulae.&apos; Roughly speaking, there is a trade-off between the expressive power of a language and its computational tractability. For example, the satisfiability problem for the language consisting of conjunctions of equalities and inequalities of first-order terms can 4 A third approach, developed by Smolka (1992), is to define a specialized language tailored for expressing attribute-value constraints and note its translation into some standard language, in this case, also the Schonfinkel-Bernays&apos; cl</context>
<context position="19064" citStr="Johnson (1991" startWordPosition="2853" endWordPosition="2854">understand how the properties of attribute-value structures can be stated in SB, since many of the techniques used to formalize them can be applied to other linguistically interesting structures as well. In fact there are several ways of formalizing attribute-value structures in SB, all of which seem to be linguistically equivalent. What follows is a formalization in SB that allows values to be used as attributes and allows attributes to be quantified over (this is handy for stating &amp;quot;sort constraints&amp;quot;), but no special claims are made for it over and above any other SB formalization. Following Johnson (1991b), attribute-value feature structures can be specified in SB in the following way. We can conceptualize of attribute-value arcs as instances of 5 Computational Linguistics Volume 20, Number 1 a three-place relation arc, where arc(x,a, y) means that there is an arc leaving node x labeled a pointing to node y.6 Of course, not all interpretations qualify as attribute-value structures; e.g., those which satisfy both arc(x,a,y) and arc(x,a,z) for some y z violate the requirement that there is at most one arc with any given label leaving any node. We can express this requirement as an SB formula th</context>
<context position="21405" citStr="Johnson (1991" startWordPosition="3222" endWordPosition="3223"> language for use as the names of attribute-value constants, and require that they satisfy the following schemata.&apos; For each c in N, con(c). (3) For each distinct pair c1, C2 in N, c1 c2. (4) Schema (3) requires each symbol in N to denote an attribute-value constant, and schema (4) enforces distinctness in essentially the same manner as that used in the specification systems of algebraic data-type theory (Kapur and Musser 1987). Formulas (1) and (2) and the instances of schemata (3) and (4) can be regarded as defining attribute-value feature structures. These axioms are quite permissive: in 6 Johnson (1991a) and Smolka (1992) propose that an attribute-value arc labeled a from x to y be conceptualized as an instance of a two-place relation a(x, y). For most applications there is little substantive difference between these two approaches; the approach taken here allows attributes to be quantified over, e.g., to state sortal constraints, and permits values to be used as attributes, as in e.g., T,FG (Kaplan and Bresnan 1982); for discussion and linguistic applications see also Johnson (1988). 7 As Patrick Blackburn (p.c.) points out, one consequence of this is that every model of these constraints </context>
<context position="23838" citStr="Johnson (1991" startWordPosition="3606" endWordPosition="3607">re of (in fact, some analyses crucially depend on their existence, as described in section 2.1.3 of Johnson [19881), so in the interests of parsimony additional constraints that forbid them are not stipulated. In fact, because SB formulae possess the finite model property (i.e., if an SB formula has a model, then it has a finite model), restricting attention to finite models does not change the set of satisfiable SB formulae. Therefore it could have no effect on the set of well-formed utterances. Cyclic feature structures can be prohibited with a constraint formalizable in SB, as described in Johnson (1991b), and one can express a constraint in SB that requires that all attributes are &amp;quot;attribute-value constants&amp;quot; (even though there appears to be no linguistic motivation for such a constraint, and indeed, some analyses crucially depend on this not being the case, as pointed out in Johnson [19881). To summarize, the simplest SB axioms defining attribute-value structures are quite permissive, allowing a wider range of structures to count as attribute-value structures than many other formalizations. However, all of the major restrictions on attributevalue structures discussed in the literature eithe</context>
<context position="25875" citStr="Johnson (1991" startWordPosition="3934" endWordPosition="3935">ibute-value &amp;quot;unification&amp;quot; is the conjunction and simplification of the formulae expressing the constraints to be unified. If all three constraints in the example of Figure 1 are conjoined together with axioms (1-3) above, then by (1) it follows that bi = b2. Further, if b1 and b2 are distinct constant symbols in N (thus they name attribute-value constants), then 171 b2 is an instance of (4), and the conjunction is therefore unsatisfiable. For further examples and a discussion of how the disjunction and negation of attribute-value constraints are transparently representable as SB formulae, see Johnson (1991a, 1991b). 7 Computational Linguistics Volume 20, Number .1 A major motivation for using SB is that a wide variety of constraints, in addition to standard attribute-value constraints, can be expressed using it. This allows a grammar developer to introduce a wide variety of &amp;quot;designer features&amp;quot; with possibly idiosyncratic, customized properties, while guaranteeing that the composite system is decidable (usually in NP-time, as noted above). For example, suppose we want to impose sort restrictions of the following kind. To abbreviate the lexical entries of verbs we might introduce the one-place pr</context>
<context position="27343" citStr="Johnson (1991" startWordPosition="4172" endWordPosition="4173">(5) Similarly, constraints that restrict the possible values of certain attributes can be imposed. For example, one might want to require that the value of every arc labeled number is either singular or plural. This constraint can be expressed as the following SB formula. Vx Vy arc(x , number , y) y = singular V y plural. (6) These examples demonstrate only a small fraction of the variety of the feature structure constraints that can be expressed in SB. Even though all of these examples are based on attribute-value features, other sorts of features can be described in SB as well. For example, Johnson (1991a) shows how to formulate a variety of constraints on `setvalued&apos; features in SB. 3.4 Expressing Tree Structure Constraints with SB Formulae Inspired by the work on description theory or &apos;D-theory&apos; (Marcus, Hindle, and Fleck 1983; Vijay-Shanker 1992), this section shows how some elementary constraints on precedence and dominance in a tree can be expressed as SB formulae. It differs from that work in that different kinds of constraints are expressible (Vijay-Shanker was concerned with the formalization of a different kind of grammar), and that all of the constraints expressible in the system de</context>
<context position="32475" citStr="Johnson (1991" startWordPosition="5025" endWordPosition="5026">ssing both tree structure and the variety of feature structure constraints that the SB approach described here can. Blackburn, Gardent, and Meyer-viol (1993) introduce a modal language LT for describing trees decorated with feature structures, whose satisfiability problem is undecidable. In the long run, such specialized &amp;quot;designer logics&amp;quot; may provide the most satisfying integration of tree structure and feature structure constraints. Second, the &apos;one-sided&apos; approximation (14a) can be used in place of the correct axiom (14). The effect of using such one-sided approximations was investigated in Johnson (1991a). It was shown there that if is a formula such as the one in (14) and is the one-sided approximation (14a), then for any formula yg+ (C) in which C only appears positively, A (p+ (C) is satisfiable iff A co+ (C) is satisfiable. That is, if we are concerned only with positively occurring constraints, we can simplify (14) to (14a), i.e., ignore (14b), without affecting constraint satisfiability. Third, we can regard formulae such as (14) as the &amp;quot;macro&amp;quot; (15), used to expand constraints at the interface between the syntactic rules and the constraint solver. This &amp;quot;macro expansion&amp;quot; rewrites c-comm</context>
</contexts>
<marker>Johnson, 1991</marker>
<rawString>Johnson, Mark (1991b). &amp;quot;Logic and feature structures.&amp;quot; In Proceedings, International Joint Conference on Artificial Intelligence. Sydney.</rawString>
</citation>
<citation valid="false">
<authors>
<author>Mark Johnson</author>
</authors>
<title>(in press a) &amp;quot;Attribute-value logic and natural language processing.&amp;quot; In Unification</title>
<publisher>MIT Press.</publisher>
<note>in Grammar, edited by Jurgen Wedekind</note>
<marker>Johnson, </marker>
<rawString>Johnson, Mark (in press a) &amp;quot;Attribute-value logic and natural language processing.&amp;quot; In Unification in Grammar, edited by Jurgen Wedekind and Christian Rohrer. MIT Press.</rawString>
</citation>
<citation valid="false">
<authors>
<author>Mark Johnson</author>
</authors>
<title>(in press b) &amp;quot;Two ways of formalizing grammars.&amp;quot; Linguistics and Philosophy.</title>
<marker>Johnson, </marker>
<rawString>Johnson, Mark (in press b) &amp;quot;Two ways of formalizing grammars.&amp;quot; Linguistics and Philosophy.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Mark Johnson</author>
<author>Martin Kay</author>
</authors>
<title>Semantic operators and anaphora.&amp;quot;</title>
<date>1990</date>
<booktitle>In Proceedings, 13th International Conference on Computational Linguistics (COLING-90),</booktitle>
<pages>17--27</pages>
<location>Helsinki.</location>
<contexts>
<context position="1502" citStr="Johnson and Kay (1990)" startWordPosition="211" endWordPosition="214"> a surprisingly wide range of linguistic phenomena can be described in terms of simple equality constraints on values in attribute-value structures, which are a particularly simple kind of feature structure (see Shieber 1986; Johnson 1988; Uszkoreit 1986; and Bresnan 1982 for examples of some of these analyses). But some phenomena do not seem to be able to be described in such a pure &apos;unification&apos; framework. For example, the analysis of conjunctions in LFG (Kaplan and Maxwell 1988b) and the formalizations of Discourse Representation Theory (Kamp 1981) presented in Johnson and Klein (1986) and Johnson and Kay (1990) require additional mechanisms for representing and manipulating aggregates or sets of values in ways that are beyond the capability of such &amp;quot;pure&amp;quot; attribute-value systems. Further, sortal constraints (which also cannot be expressed as simple equality constraints) can be used to formulate simpler and more comprehensible grammars (Carpenter 1992; Carpenter and Pollard 1991; Pollard and Sag 1987, 1992). Versions of both of these kinds of constraint, as well as the familiar attribute-value constraints, can be expressed as Schonfinkel-Bernays&apos; formulae (as demonstrated in Johnson 1991a, 1991b), so</context>
</contexts>
<marker>Johnson, Kay, 1990</marker>
<rawString>Johnson, Mark, and Kay, Martin (1990). &amp;quot;Semantic operators and anaphora.&amp;quot; In Proceedings, 13th International Conference on Computational Linguistics (COLING-90), 17-27. Helsinki.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Mark Johnson</author>
<author>Ewan Klein</author>
</authors>
<title>Discourse, parsing and anaphora.&amp;quot;</title>
<date>1986</date>
<booktitle>In Proceedings, 17th International Conference on Computational Linguistics.</booktitle>
<location>Bonn.</location>
<contexts>
<context position="1475" citStr="Johnson and Klein (1986)" startWordPosition="206" endWordPosition="209">ion Despite their simplicity, a surprisingly wide range of linguistic phenomena can be described in terms of simple equality constraints on values in attribute-value structures, which are a particularly simple kind of feature structure (see Shieber 1986; Johnson 1988; Uszkoreit 1986; and Bresnan 1982 for examples of some of these analyses). But some phenomena do not seem to be able to be described in such a pure &apos;unification&apos; framework. For example, the analysis of conjunctions in LFG (Kaplan and Maxwell 1988b) and the formalizations of Discourse Representation Theory (Kamp 1981) presented in Johnson and Klein (1986) and Johnson and Kay (1990) require additional mechanisms for representing and manipulating aggregates or sets of values in ways that are beyond the capability of such &amp;quot;pure&amp;quot; attribute-value systems. Further, sortal constraints (which also cannot be expressed as simple equality constraints) can be used to formulate simpler and more comprehensible grammars (Carpenter 1992; Carpenter and Pollard 1991; Pollard and Sag 1987, 1992). Versions of both of these kinds of constraint, as well as the familiar attribute-value constraints, can be expressed as Schonfinkel-Bernays&apos; formulae (as demonstrated i</context>
</contexts>
<marker>Johnson, Klein, 1986</marker>
<rawString>Johnson, Mark, and Klein, Ewan (1986). &amp;quot;Discourse, parsing and anaphora.&amp;quot; In Proceedings, 17th International Conference on Computational Linguistics. Bonn.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Hans Kamp</author>
</authors>
<title>A theory of truth and semantic representation.&amp;quot;</title>
<date>1981</date>
<booktitle>In Formal Methods in the Study of Language,</booktitle>
<pages>277--322</pages>
<institution>Mathematical Centre Tracts,</institution>
<location>Amsterdam.</location>
<note>edited by</note>
<contexts>
<context position="1437" citStr="Kamp 1981" startWordPosition="201" endWordPosition="202"> databases. 1. Introduction Despite their simplicity, a surprisingly wide range of linguistic phenomena can be described in terms of simple equality constraints on values in attribute-value structures, which are a particularly simple kind of feature structure (see Shieber 1986; Johnson 1988; Uszkoreit 1986; and Bresnan 1982 for examples of some of these analyses). But some phenomena do not seem to be able to be described in such a pure &apos;unification&apos; framework. For example, the analysis of conjunctions in LFG (Kaplan and Maxwell 1988b) and the formalizations of Discourse Representation Theory (Kamp 1981) presented in Johnson and Klein (1986) and Johnson and Kay (1990) require additional mechanisms for representing and manipulating aggregates or sets of values in ways that are beyond the capability of such &amp;quot;pure&amp;quot; attribute-value systems. Further, sortal constraints (which also cannot be expressed as simple equality constraints) can be used to formulate simpler and more comprehensible grammars (Carpenter 1992; Carpenter and Pollard 1991; Pollard and Sag 1987, 1992). Versions of both of these kinds of constraint, as well as the familiar attribute-value constraints, can be expressed as Schonfinke</context>
</contexts>
<marker>Kamp, 1981</marker>
<rawString>Kamp, Hans (1981). &amp;quot;A theory of truth and semantic representation.&amp;quot; In Formal Methods in the Study of Language, edited by J. A. G. Groenendijk, T. M. V. Janssem, and M. B. J. Stokhof, 277-322. Mathematical Centre Tracts, Amsterdam.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ronald M Kaplan</author>
<author>Joan Bresnan</author>
</authors>
<title>Lexical-functional grammar, a formal system for grammatical representation.&amp;quot;</title>
<date>1982</date>
<booktitle>In The Mental Representation of Grammatical Relations, edited by Joan Bresnan,</booktitle>
<pages>173--281</pages>
<publisher>MIT Press.</publisher>
<contexts>
<context position="2552" citStr="Kaplan and Bresnan (1982)" startWordPosition="367" endWordPosition="370">these kinds of constraint, as well as the familiar attribute-value constraints, can be expressed as Schonfinkel-Bernays&apos; formulae (as demonstrated in Johnson 1991a, 1991b), so that the problem of determining the satisfiability of a system of such constraints is reduced to the satisfiability problem for the corresponding formula. This class of formulae (defined in Section 3.1) seems to be expressive enough for most linguistic purposes when used with an external phrase-structure backbone. That is, these formulae are used as annotations on phrase structure rules in the manner described in, e.g., Kaplan and Bresnan (1982), Shieber (1986), and Johnson (1988). This paper extends the author&apos;s previous paper on the topic (Johnson 1991a) by sketching several other linguistic applications of Schonfinkel-Bernays&apos; formulae (including a version of D-theory [Marcus, Hindle, and Fleck 1983; Vijay-Shanker 1992]), and presenting a least-fixed-point theorem that serves as the theoretical basis for a &amp;quot;forwardchaining&amp;quot; algorithm for determining satisfiabiIity of Schonfinkel-Bernays&apos; formulae. Interestingly, this algorithm can be viewed both as a straightforward generalization * Cognitive and Linguistic Sciences, Box 1978, Bro</context>
<context position="4797" citStr="Kaplan and Bresnan 1982" startWordPosition="679" endWordPosition="682">l-Bernays&apos; formulae, the constraint formalism described below. A second class of extended constraint formalisms has been devised to be capable of expressing the entire grammar as systems of constraints and as far as I know, for all of these systems the problem of determining the satisfiability of an arbitrary system of constraints that they can express is undecidable.2 This is because the recognition problem for an arbitrary &amp;quot;unification-based&amp;quot; grammar is undecidable unless the size of the phrase structure tree is constrained somehow, e.g., by the offline parsability constraint (Johnson 1988; Kaplan and Bresnan 1982; Pereira 1982; Shieber 1992), but there seems to be no natural way to impose such constraints in these systems because the encoding of the phrase structure tree in the feature structure is not distinguished from other features.&apos; Thus in order to maintain decidability the system described here is not designed to be capable of expressing phrase structure constraints directly, and must be used with an external phrase-structure component, as in LFG (Bresnan 1982). (However, Bob Carpenter [p.c.1 points out that one can impose a bound on the size of the feature structure that can serve as an analys</context>
<context position="10372" citStr="Kaplan and Bresnan (1982)" startWordPosition="1532" endWordPosition="1535">a feature structure S satisfies a constraint a, then every feature structure subsumed by S should also satisfy a (Pereira 1987). If this &amp;quot;upward closure&amp;quot; property holds, then the set of feature structures satisfying any constraint can be represented by the set of its &amp;quot;minimal models.&amp;quot; Unfortunately, many useful constraints do not have this property. For example, under a classical interpretation, the set of feature structures satisfying negated feature structure constraints are not upward-closed (Moshier and Rounds 1987). The work described in this paper pursues a different approach. Following Kaplan and Bresnan (1982), feature structures are only (components of) linguistic structures, and not partial descriptions of (other) linguistic structures. As such, a feature structure either does or does not satisfy any particular set of constraints. An utterance is well-formed just in case there is some linguistic structure that satisfies all of the constraints imposed by the grammar and has the phonological form of that utterance as its phonological form (which itself is just another constraint that the structure must satisfy). Since the relationship between a feature structure and a constraint that it satisfies i</context>
<context position="14288" citStr="Kaplan and Bresnan (1982)" startWordPosition="2140" endWordPosition="2143">ressing Feature Structure Constraints There are many different possible constraint languages. Specialized languages can be constructed specifically for the task of expressing feature structure constraints (such as Kasper and Rounds&apos;s FDL [Kasper and Rounds 19901 and Johnson&apos;s attribute-value languages [Johnson 19881). Alternatively, the constraints may be able to be expressed in some standard language, so that the satisfiability problem for linguistic constraints is reduced to the satisfiability problem for that language, as is done here.&apos; Johnson (1990a), following a suggestion first made in Kaplan and Bresnan (1982), showed how attribute-value constraints could be formalized in the quantifier-free subset of first-order logic, while later work (Johnson 1991a, 1991b) proposed a different formalization in the Schanfinkel-Bernays&apos; subset of first-order formulae.&apos; Roughly speaking, there is a trade-off between the expressive power of a language and its computational tractability. For example, the satisfiability problem for the language consisting of conjunctions of equalities and inequalities of first-order terms can 4 A third approach, developed by Smolka (1992), is to define a specialized language tailored </context>
<context position="21828" citStr="Kaplan and Bresnan 1982" startWordPosition="3288" endWordPosition="3291">ur and Musser 1987). Formulas (1) and (2) and the instances of schemata (3) and (4) can be regarded as defining attribute-value feature structures. These axioms are quite permissive: in 6 Johnson (1991a) and Smolka (1992) propose that an attribute-value arc labeled a from x to y be conceptualized as an instance of a two-place relation a(x, y). For most applications there is little substantive difference between these two approaches; the approach taken here allows attributes to be quantified over, e.g., to state sortal constraints, and permits values to be used as attributes, as in e.g., T,FG (Kaplan and Bresnan 1982); for discussion and linguistic applications see also Johnson (1988). 7 As Patrick Blackburn (p.c.) points out, one consequence of this is that every model of these constraints will contain individuals corresponding to each attribute-value constant (since each constant symbol will be assigned a denotation). Whether this is desirable or problematic is debatable, but as he pointed out, it is easy to devise a conceptualization in which each attribute-value constant c, is conceptualized as a one-place predicate ci(•) that is true of at most one element. Under such a conceptualization (which can be</context>
</contexts>
<marker>Kaplan, Bresnan, 1982</marker>
<rawString>Kaplan, Ronald M., and Bresnan, Joan (1982). &amp;quot;Lexical-functional grammar, a formal system for grammatical representation.&amp;quot; In The Mental Representation of Grammatical Relations, edited by Joan Bresnan, 173-281. MIT Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ronald M Kaplan</author>
<author>John T Maxwell</author>
</authors>
<title>An algorithm for functional uncertainty.&amp;quot;</title>
<date>1988</date>
<booktitle>In Proceedings, 12th International Conference on Computational Linguistics,</booktitle>
<pages>297--302</pages>
<location>Budapest, Hungary.</location>
<contexts>
<context position="1365" citStr="Kaplan and Maxwell 1988" startWordPosition="190" endWordPosition="193">ms. further strengthening the connection between the theory of feature structures and databases. 1. Introduction Despite their simplicity, a surprisingly wide range of linguistic phenomena can be described in terms of simple equality constraints on values in attribute-value structures, which are a particularly simple kind of feature structure (see Shieber 1986; Johnson 1988; Uszkoreit 1986; and Bresnan 1982 for examples of some of these analyses). But some phenomena do not seem to be able to be described in such a pure &apos;unification&apos; framework. For example, the analysis of conjunctions in LFG (Kaplan and Maxwell 1988b) and the formalizations of Discourse Representation Theory (Kamp 1981) presented in Johnson and Klein (1986) and Johnson and Kay (1990) require additional mechanisms for representing and manipulating aggregates or sets of values in ways that are beyond the capability of such &amp;quot;pure&amp;quot; attribute-value systems. Further, sortal constraints (which also cannot be expressed as simple equality constraints) can be used to formulate simpler and more comprehensible grammars (Carpenter 1992; Carpenter and Pollard 1991; Pollard and Sag 1987, 1992). Versions of both of these kinds of constraint, as well as </context>
<context position="35831" citStr="Kaplan and Maxwell 1988" startWordPosition="5573" endWordPosition="5576">constraints is undecidable (Dorre and Rounds 1992). Positively occurring functional 10 Mark Johnson Computing with Features as Formulae (El) Vx x x. (E2) Vy x y y = x. (E3) Vxo Vx x1 = X0 A P(xi , , x), for] 1, 1, ... ,71, for every predicate symbol P appearing in 42. (E4) Vxo . Vx x1= f (X1- • • •xi,.• 7 x73 ) f X0. xn) for] 1, ,n, for every function symbol f appearing in cp. Figure 2 Equality axiom schemata for a first-order formula cp. uncertainty constraints, used in the LFG treatment of long-distance dependencies (Kaplan and Zaenen 1989) appear to have a decidable satisfiability problem (Kaplan and Maxwell 1988a), but the satisfiability problem for arbitrary boolean combinations of functional uncertainty constraints is undecidable (Keller 1991), so these cannot be expressed using SB formulae either (since the quantifier-free subclass of SB is closed under boolean operations). 3.6 The Equality Relation In this paper the intended interpretation of the equality relation is identity; i.e., a = b if and only if a and h denote the same individual. However, for some purposes (e.g., in the least-fixed-point characterization of minimal models given below) this &amp;quot;special&amp;quot; interpretation of the equality complic</context>
</contexts>
<marker>Kaplan, Maxwell, 1988</marker>
<rawString>Kaplan, Ronald M., and Maxwell, John T. (1988a). &amp;quot;An algorithm for functional uncertainty.&amp;quot; In Proceedings, 12th International Conference on Computational Linguistics, 297-302. Budapest, Hungary.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ronald M Kaplan</author>
<author>John T Maxwell</author>
</authors>
<title>Constituent coordination in lexical-functional grammar.&amp;quot;</title>
<date>1988</date>
<booktitle>In Proceedings, 12th International Conference on Computational Linguistics,</booktitle>
<pages>297--302</pages>
<note>Budapest, I lungary.</note>
<contexts>
<context position="1365" citStr="Kaplan and Maxwell 1988" startWordPosition="190" endWordPosition="193">ms. further strengthening the connection between the theory of feature structures and databases. 1. Introduction Despite their simplicity, a surprisingly wide range of linguistic phenomena can be described in terms of simple equality constraints on values in attribute-value structures, which are a particularly simple kind of feature structure (see Shieber 1986; Johnson 1988; Uszkoreit 1986; and Bresnan 1982 for examples of some of these analyses). But some phenomena do not seem to be able to be described in such a pure &apos;unification&apos; framework. For example, the analysis of conjunctions in LFG (Kaplan and Maxwell 1988b) and the formalizations of Discourse Representation Theory (Kamp 1981) presented in Johnson and Klein (1986) and Johnson and Kay (1990) require additional mechanisms for representing and manipulating aggregates or sets of values in ways that are beyond the capability of such &amp;quot;pure&amp;quot; attribute-value systems. Further, sortal constraints (which also cannot be expressed as simple equality constraints) can be used to formulate simpler and more comprehensible grammars (Carpenter 1992; Carpenter and Pollard 1991; Pollard and Sag 1987, 1992). Versions of both of these kinds of constraint, as well as </context>
<context position="35831" citStr="Kaplan and Maxwell 1988" startWordPosition="5573" endWordPosition="5576">constraints is undecidable (Dorre and Rounds 1992). Positively occurring functional 10 Mark Johnson Computing with Features as Formulae (El) Vx x x. (E2) Vy x y y = x. (E3) Vxo Vx x1 = X0 A P(xi , , x), for] 1, 1, ... ,71, for every predicate symbol P appearing in 42. (E4) Vxo . Vx x1= f (X1- • • •xi,.• 7 x73 ) f X0. xn) for] 1, ,n, for every function symbol f appearing in cp. Figure 2 Equality axiom schemata for a first-order formula cp. uncertainty constraints, used in the LFG treatment of long-distance dependencies (Kaplan and Zaenen 1989) appear to have a decidable satisfiability problem (Kaplan and Maxwell 1988a), but the satisfiability problem for arbitrary boolean combinations of functional uncertainty constraints is undecidable (Keller 1991), so these cannot be expressed using SB formulae either (since the quantifier-free subclass of SB is closed under boolean operations). 3.6 The Equality Relation In this paper the intended interpretation of the equality relation is identity; i.e., a = b if and only if a and h denote the same individual. However, for some purposes (e.g., in the least-fixed-point characterization of minimal models given below) this &amp;quot;special&amp;quot; interpretation of the equality complic</context>
</contexts>
<marker>Kaplan, Maxwell, 1988</marker>
<rawString>Kaplan, Ronald M., and Maxwell, John T. (1988b). &amp;quot;Constituent coordination in lexical-functional grammar.&amp;quot; In Proceedings, 12th International Conference on Computational Linguistics, 297-302. Budapest, I lungary.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ronald M Kaplan</author>
<author>Annie Zaenen</author>
</authors>
<title>Long-distance dependencies, constituent structure and functional uncertainty.&amp;quot;</title>
<date>1989</date>
<booktitle>In Alternative Conceptions of Phrase Structure, edited by Mark Baltin and Anthony Krock,</booktitle>
<pages>17--42</pages>
<publisher>Chicago University Press.</publisher>
<contexts>
<context position="35756" citStr="Kaplan and Zaenen 1989" startWordPosition="5561" endWordPosition="5565">satisfiability problem for conjunctions of subsumption and attribute-value constraints is undecidable (Dorre and Rounds 1992). Positively occurring functional 10 Mark Johnson Computing with Features as Formulae (El) Vx x x. (E2) Vy x y y = x. (E3) Vxo Vx x1 = X0 A P(xi , , x), for] 1, 1, ... ,71, for every predicate symbol P appearing in 42. (E4) Vxo . Vx x1= f (X1- • • •xi,.• 7 x73 ) f X0. xn) for] 1, ,n, for every function symbol f appearing in cp. Figure 2 Equality axiom schemata for a first-order formula cp. uncertainty constraints, used in the LFG treatment of long-distance dependencies (Kaplan and Zaenen 1989) appear to have a decidable satisfiability problem (Kaplan and Maxwell 1988a), but the satisfiability problem for arbitrary boolean combinations of functional uncertainty constraints is undecidable (Keller 1991), so these cannot be expressed using SB formulae either (since the quantifier-free subclass of SB is closed under boolean operations). 3.6 The Equality Relation In this paper the intended interpretation of the equality relation is identity; i.e., a = b if and only if a and h denote the same individual. However, for some purposes (e.g., in the least-fixed-point characterization of minima</context>
</contexts>
<marker>Kaplan, Zaenen, 1989</marker>
<rawString>Kaplan, Ronald M., and Zaenen, Annie. (1989). &amp;quot;Long-distance dependencies, constituent structure and functional uncertainty.&amp;quot; In Alternative Conceptions of Phrase Structure, edited by Mark Baltin and Anthony Krock, 17-42. Chicago University Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D Kapur</author>
<author>D R Musser</author>
</authors>
<title>Proof by consistency.&amp;quot;</title>
<date>1987</date>
<journal>Artificial Intelligence</journal>
<volume>31</volume>
<pages>125--157</pages>
<contexts>
<context position="21223" citStr="Kapur and Musser 1987" startWordPosition="3191" endWordPosition="3194">l as attribute-value constants. Finally, we require that the names of attribute-value constants denote distinct attribute-value constants. We reserve a finite subset N of the constants of our language for use as the names of attribute-value constants, and require that they satisfy the following schemata.&apos; For each c in N, con(c). (3) For each distinct pair c1, C2 in N, c1 c2. (4) Schema (3) requires each symbol in N to denote an attribute-value constant, and schema (4) enforces distinctness in essentially the same manner as that used in the specification systems of algebraic data-type theory (Kapur and Musser 1987). Formulas (1) and (2) and the instances of schemata (3) and (4) can be regarded as defining attribute-value feature structures. These axioms are quite permissive: in 6 Johnson (1991a) and Smolka (1992) propose that an attribute-value arc labeled a from x to y be conceptualized as an instance of a two-place relation a(x, y). For most applications there is little substantive difference between these two approaches; the approach taken here allows attributes to be quantified over, e.g., to state sortal constraints, and permits values to be used as attributes, as in e.g., T,FG (Kaplan and Bresnan </context>
</contexts>
<marker>Kapur, Musser, 1987</marker>
<rawString>Kapur, D., and Musser, D. R. (1987). &amp;quot;Proof by consistency.&amp;quot; Artificial Intelligence 31, 125-157.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Lauri Karttunen</author>
</authors>
<title>Features and values.&amp;quot;</title>
<date>1984</date>
<booktitle>In Proceedings, International Conference on Computational Linguistics (COLING-1984),</booktitle>
<pages>28--33</pages>
<institution>Stanford University.</institution>
<contexts>
<context position="6748" citStr="Karttunen (1984)" startWordPosition="979" endWordPosition="980">nson 1991b). The expression of D-theory constraints on nodes in trees is discussed in this paper. This paper extends the ideas in these earlier papers with theoretical results that suggest a forward-chaining algorithm for determining the satisfiability of an arbitrary Schonfinkel-Bernays&apos; formula. This generalizes the standard feature-graph unification algorithm and is closely related to the semi-naive bottom-up algorithm used in database theory. I For examples of this approach see Dawar and Vijay-Shanker (1990), Dorre and Eisele (1990), Johnson (1988, 1990a, 1990b, 1991a, 1991b, in press a), Karttunen (1984), Kasper (1987a, 19871), 1986), Kasper and Rounds (1986, 1990), Langholm (1989), Pereira (1987), and Smolka (1992). 2 Examples of this approach are Carpenter, Pollard, and Franz (1991), Dorre (1991), Done and Eisele (1991), Johnson (in press b), Kay (1979, 1985a, 1985b), Pollard and Sag (1987), Rounds and Manaster-Ramer (1987), Smolka (1988), and Zajac (1992). 3 While it may well be that the universal recognition and parsing problems for natural language are undecidable (Chomsky [1986, 1988] points out that there is no contrary evidence), I know of no evidence that this is actually the case. I</context>
</contexts>
<marker>Karttunen, 1984</marker>
<rawString>Karttunen, Lauri (1984). &amp;quot;Features and values.&amp;quot; In Proceedings, International Conference on Computational Linguistics (COLING-1984), 28-33. Stanford University.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Robert T Kasper</author>
</authors>
<title>Feature structures: A logical theory with application to language analysis. Doctoral dissertation,</title>
<date>1987</date>
<institution>University of Michigan.</institution>
<contexts>
<context position="6762" citStr="Kasper (1987" startWordPosition="981" endWordPosition="982">xpression of D-theory constraints on nodes in trees is discussed in this paper. This paper extends the ideas in these earlier papers with theoretical results that suggest a forward-chaining algorithm for determining the satisfiability of an arbitrary Schonfinkel-Bernays&apos; formula. This generalizes the standard feature-graph unification algorithm and is closely related to the semi-naive bottom-up algorithm used in database theory. I For examples of this approach see Dawar and Vijay-Shanker (1990), Dorre and Eisele (1990), Johnson (1988, 1990a, 1990b, 1991a, 1991b, in press a), Karttunen (1984), Kasper (1987a, 19871), 1986), Kasper and Rounds (1986, 1990), Langholm (1989), Pereira (1987), and Smolka (1992). 2 Examples of this approach are Carpenter, Pollard, and Franz (1991), Dorre (1991), Done and Eisele (1991), Johnson (in press b), Kay (1979, 1985a, 1985b), Pollard and Sag (1987), Rounds and Manaster-Ramer (1987), Smolka (1988), and Zajac (1992). 3 While it may well be that the universal recognition and parsing problems for natural language are undecidable (Chomsky [1986, 1988] points out that there is no contrary evidence), I know of no evidence that this is actually the case. It seems reason</context>
</contexts>
<marker>Kasper, 1987</marker>
<rawString>Kasper, Robert T. (1987a). Feature structures: A logical theory with application to language analysis. Doctoral dissertation, University of Michigan.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Robert T Kasper</author>
</authors>
<title>A unification method for disjunctive feature structures.&amp;quot;</title>
<date>1987</date>
<booktitle>In Proceedings, 25th Annual Meeting of the Association for Computational Linguistics,</booktitle>
<pages>235--242</pages>
<institution>Stanford University.</institution>
<contexts>
<context position="6762" citStr="Kasper (1987" startWordPosition="981" endWordPosition="982">xpression of D-theory constraints on nodes in trees is discussed in this paper. This paper extends the ideas in these earlier papers with theoretical results that suggest a forward-chaining algorithm for determining the satisfiability of an arbitrary Schonfinkel-Bernays&apos; formula. This generalizes the standard feature-graph unification algorithm and is closely related to the semi-naive bottom-up algorithm used in database theory. I For examples of this approach see Dawar and Vijay-Shanker (1990), Dorre and Eisele (1990), Johnson (1988, 1990a, 1990b, 1991a, 1991b, in press a), Karttunen (1984), Kasper (1987a, 19871), 1986), Kasper and Rounds (1986, 1990), Langholm (1989), Pereira (1987), and Smolka (1992). 2 Examples of this approach are Carpenter, Pollard, and Franz (1991), Dorre (1991), Done and Eisele (1991), Johnson (in press b), Kay (1979, 1985a, 1985b), Pollard and Sag (1987), Rounds and Manaster-Ramer (1987), Smolka (1988), and Zajac (1992). 3 While it may well be that the universal recognition and parsing problems for natural language are undecidable (Chomsky [1986, 1988] points out that there is no contrary evidence), I know of no evidence that this is actually the case. It seems reason</context>
</contexts>
<marker>Kasper, 1987</marker>
<rawString>Kasper, Robert T. (1987b). &amp;quot;A unification method for disjunctive feature structures.&amp;quot; In Proceedings, 25th Annual Meeting of the Association for Computational Linguistics, 235-242. Stanford University.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Robert T Kasper</author>
</authors>
<title>Conditional descriptions in functional unification grammar.&amp;quot;</title>
<date>1988</date>
<booktitle>In Proceedings, 26th Annual Meeting of the Association for Computational Linguistics,</booktitle>
<pages>233--240</pages>
<location>Buffalo, N.Y.</location>
<contexts>
<context position="66839" citStr="Kasper (1988)" startWordPosition="10984" endWordPosition="10985">s require exponential time in the worst case, and unless P=NP no tractable general-purpose algorithm for determining the satisfiability of SB formulae exists. With present technology, the best we can hope for is an algorithm that performs adequately on the types of problems that we actually encounter. Sometimes disjunctive constraints can be (automatically) transformed into nondisjunctive ones, thus avoiding the problem entirely. For example, Alshawi (1992) describes a technique attributed to Colmerauer for transforming disjunctions of finitedomain feature-value constraints into conjunctions. Kasper (1988) and Hegner (1991) point out that Horn clauses, although technically disjunctions, can be handled considerably more efficiently than general disjunctive constraints. The forward-chaining mechanisms that they propose for treating these constraints appear to be special cases of the semi-naive algorithm sketched in this paper. Unfortunately, I know of no general adequate method for handling the disjunctive constraints that arise in real grammars with acceptable efficiency. The techniques discussed by Maxwell and Kaplan (1991, 1992) seem most directly compatible with the approach described in this</context>
</contexts>
<marker>Kasper, 1988</marker>
<rawString>Kasper, Robert T. (1988). &amp;quot;Conditional descriptions in functional unification grammar.&amp;quot; In Proceedings, 26th Annual Meeting of the Association for Computational Linguistics, 233-240. Buffalo, N.Y.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Robert T Kasper</author>
<author>William C Rounds</author>
</authors>
<title>A logical semantics for feature structures.&amp;quot;</title>
<date>1986</date>
<booktitle>In Proceedings, 24th Annual Meeting of the Association for Computational Linguistics,</booktitle>
<pages>257--266</pages>
<institution>Columbia University,</institution>
<location>New York.</location>
<contexts>
<context position="6803" citStr="Kasper and Rounds (1986" startWordPosition="985" endWordPosition="988">nts on nodes in trees is discussed in this paper. This paper extends the ideas in these earlier papers with theoretical results that suggest a forward-chaining algorithm for determining the satisfiability of an arbitrary Schonfinkel-Bernays&apos; formula. This generalizes the standard feature-graph unification algorithm and is closely related to the semi-naive bottom-up algorithm used in database theory. I For examples of this approach see Dawar and Vijay-Shanker (1990), Dorre and Eisele (1990), Johnson (1988, 1990a, 1990b, 1991a, 1991b, in press a), Karttunen (1984), Kasper (1987a, 19871), 1986), Kasper and Rounds (1986, 1990), Langholm (1989), Pereira (1987), and Smolka (1992). 2 Examples of this approach are Carpenter, Pollard, and Franz (1991), Dorre (1991), Done and Eisele (1991), Johnson (in press b), Kay (1979, 1985a, 1985b), Pollard and Sag (1987), Rounds and Manaster-Ramer (1987), Smolka (1988), and Zajac (1992). 3 While it may well be that the universal recognition and parsing problems for natural language are undecidable (Chomsky [1986, 1988] points out that there is no contrary evidence), I know of no evidence that this is actually the case. It seems reasonable then to also investigate formalisms </context>
</contexts>
<marker>Kasper, Rounds, 1986</marker>
<rawString>Kasper, Robert T., and Rounds, William C. (1986). &amp;quot;A logical semantics for feature structures.&amp;quot; In Proceedings, 24th Annual Meeting of the Association for Computational Linguistics, 257-266. Columbia University, New York.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Robert T Kasper</author>
<author>William C Rounds</author>
</authors>
<title>The logic of unification in grammar.&amp;quot;</title>
<date>1990</date>
<journal>Linguistics and Philosophy</journal>
<volume>13</volume>
<issue>1</issue>
<pages>35--58</pages>
<contexts>
<context position="13924" citStr="Kasper and Rounds 1990" startWordPosition="2088" endWordPosition="2091">ipulation of their models. Partial information states are those that are satisfied by more than one interpretation. The consequence relation corresponds to the subsumption relation of traditional unification grammar (a formula a &amp;quot;contains more information&amp;quot; than formula a&apos; iff a a`), and unsatisfiability corresponds to unification failure. 3. Languages for Expressing Feature Structure Constraints There are many different possible constraint languages. Specialized languages can be constructed specifically for the task of expressing feature structure constraints (such as Kasper and Rounds&apos;s FDL [Kasper and Rounds 19901 and Johnson&apos;s attribute-value languages [Johnson 19881). Alternatively, the constraints may be able to be expressed in some standard language, so that the satisfiability problem for linguistic constraints is reduced to the satisfiability problem for that language, as is done here.&apos; Johnson (1990a), following a suggestion first made in Kaplan and Bresnan (1982), showed how attribute-value constraints could be formalized in the quantifier-free subset of first-order logic, while later work (Johnson 1991a, 1991b) proposed a different formalization in the Schanfinkel-Bernays&apos; subset of first-orde</context>
<context position="15209" citStr="Kasper and Rounds (1990)" startWordPosition="2271" endWordPosition="2274">he expressive power of a language and its computational tractability. For example, the satisfiability problem for the language consisting of conjunctions of equalities and inequalities of first-order terms can 4 A third approach, developed by Smolka (1992), is to define a specialized language tailored for expressing attribute-value constraints and note its translation into some standard language, in this case, also the Schonfinkel-Bernays&apos; class. 5 Of course, there is no a priori reason for these subsets of first-order logic to be optimally suited for expressing feature structure constraints. Kasper and Rounds (1990) and more recently Blackburn (1991) and Blackburn and Spam (1992) have suggested that it may be useful to express feature structure constraints in a special kind of modal logic. Johnson (1991b) also discusses the application of general first-order logic and nonmonotic logics to the specification of more complex constraints on feature structures. 4 Mark Johnson Computing with Features as Formulae be decided in quasi-linear time using the congruence-closure algorithm, but this language can only express conjunctions of feature-value equalities and inequalities. If this language is extended to all</context>
</contexts>
<marker>Kasper, Rounds, 1990</marker>
<rawString>Kasper, Robert T., and Rounds, William C. (1990). &amp;quot;The logic of unification in grammar.&amp;quot; Linguistics and Philosophy 13(1), 35-58.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Martin Kay</author>
</authors>
<title>Functional unification grammar.&amp;quot;</title>
<date>1979</date>
<booktitle>In Proceedings, Fifth Annual Meeting of the Berkeley Linguistics Association.</booktitle>
<location>Berkeley, CA.</location>
<contexts>
<context position="7003" citStr="Kay (1979" startWordPosition="1018" endWordPosition="1019">itrary Schonfinkel-Bernays&apos; formula. This generalizes the standard feature-graph unification algorithm and is closely related to the semi-naive bottom-up algorithm used in database theory. I For examples of this approach see Dawar and Vijay-Shanker (1990), Dorre and Eisele (1990), Johnson (1988, 1990a, 1990b, 1991a, 1991b, in press a), Karttunen (1984), Kasper (1987a, 19871), 1986), Kasper and Rounds (1986, 1990), Langholm (1989), Pereira (1987), and Smolka (1992). 2 Examples of this approach are Carpenter, Pollard, and Franz (1991), Dorre (1991), Done and Eisele (1991), Johnson (in press b), Kay (1979, 1985a, 1985b), Pollard and Sag (1987), Rounds and Manaster-Ramer (1987), Smolka (1988), and Zajac (1992). 3 While it may well be that the universal recognition and parsing problems for natural language are undecidable (Chomsky [1986, 1988] points out that there is no contrary evidence), I know of no evidence that this is actually the case. It seems reasonable then to also investigate formalisms that can only express decidable systems of constraints (and for which there exist satisfiability-testing algorithms) if linguistically adequate systems can be found. 2 Mark Johnson Computing with Feat</context>
</contexts>
<marker>Kay, 1979</marker>
<rawString>Kay, Martin (1979). &amp;quot;Functional unification grammar.&amp;quot; In Proceedings, Fifth Annual Meeting of the Berkeley Linguistics Association. Berkeley, CA.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Martin Kay</author>
</authors>
<title>Parsing in functional unification grammar.&amp;quot; In Natural Language Parsing, edited by</title>
<date>1985</date>
<publisher>Cambridge University Press.</publisher>
<marker>Kay, 1985</marker>
<rawString>Kay, Martin (1985a). &amp;quot;Parsing in functional unification grammar.&amp;quot; In Natural Language Parsing, edited by D. R. Dowty, L. Karttunen, and A. M. Zwicky. Cambridge University Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Martin Kay</author>
</authors>
<title>Unification in grammar.&amp;quot;</title>
<date>1985</date>
<booktitle>In Natural Language Understanding and Logic Programming, edited</booktitle>
<pages>233--240</pages>
<publisher>North Holland.</publisher>
<marker>Kay, 1985</marker>
<rawString>Kay, Martin (1985b). &amp;quot;Unification in grammar.&amp;quot; In Natural Language Understanding and Logic Programming, edited by V. Dahl and P. Saint-Dizier, 233-240. North Holland.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Bill Keller</author>
</authors>
<title>Feature logics, infinitary descriptions and the logical treatment of grammar. Doctoral dissertation,</title>
<date>1991</date>
<institution>University of Sussex.</institution>
<contexts>
<context position="35967" citStr="Keller 1991" startWordPosition="5591" endWordPosition="5592">. (E2) Vy x y y = x. (E3) Vxo Vx x1 = X0 A P(xi , , x), for] 1, 1, ... ,71, for every predicate symbol P appearing in 42. (E4) Vxo . Vx x1= f (X1- • • •xi,.• 7 x73 ) f X0. xn) for] 1, ,n, for every function symbol f appearing in cp. Figure 2 Equality axiom schemata for a first-order formula cp. uncertainty constraints, used in the LFG treatment of long-distance dependencies (Kaplan and Zaenen 1989) appear to have a decidable satisfiability problem (Kaplan and Maxwell 1988a), but the satisfiability problem for arbitrary boolean combinations of functional uncertainty constraints is undecidable (Keller 1991), so these cannot be expressed using SB formulae either (since the quantifier-free subclass of SB is closed under boolean operations). 3.6 The Equality Relation In this paper the intended interpretation of the equality relation is identity; i.e., a = b if and only if a and h denote the same individual. However, for some purposes (e.g., in the least-fixed-point characterization of minimal models given below) this &amp;quot;special&amp;quot; interpretation of the equality complicates matters, and it is more convenient to treat the equality relation as a &amp;quot;normal&amp;quot; relation that is defined by a set of axioms E. The </context>
</contexts>
<marker>Keller, 1991</marker>
<rawString>Keller, Bill (1991). Feature logics, infinitary descriptions and the logical treatment of grammar. Doctoral dissertation, University of Sussex.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Robert Kowalski</author>
</authors>
<title>Logic for Problem Solving. North Holland.</title>
<date>1979</date>
<contexts>
<context position="41084" citStr="Kowalski 1979" startWordPosition="6470" endWordPosition="6471">ion to SB formulae in clausal form imposes no real restriction on the class of constraints expressible. Standard procedures for transforming first-order formulae into clausal form, such as the ones described in Chang and Lee (1973), Duffy 12 Mark Johnson Computing with Features as Formulae (1991), or Genesereth and Nilsson (1987), transform SB formulae into SB formulae in clausal form. Interestingly, clausal form SB formulae correspond one-to-one with an extension to Datalog (Ullman 1988) that allows disjunctive &amp;quot;heads&amp;quot; or consequences. In notation borrowed from disjunctive logic programming (Kowalski 1979; Lobo, Minker, and Rajasekar 1992; Loveland 1987), the clauses above would be written as listed in the appendix. While the connection between logic programming and feature structures is well known (Alt-Kaci 1984; Ait-Kaci and Podelski 1993; Carpenter 1991,1992; Hiihfeld and Smolka 1988; Pereira 1987; Shieber 1992; Smolka 1992), this shows that the theory of feature structure constraints is also related to database theory as well. Negative clauses correspond to Datalog integrity constraints, and clauses with a single positive literal are definite clauses. Simple assertions, e.g., about the exi</context>
</contexts>
<marker>Kowalski, 1979</marker>
<rawString>Kowalski, Robert (1979). Logic for Problem Solving. North Holland.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Tore Langholm</author>
</authors>
<title>How to say no with feature structures.&amp;quot;</title>
<date>1989</date>
<tech>COSMOS Report No. 13,</tech>
<institution>Department of Mathematics, University of Oslo.</institution>
<contexts>
<context position="6827" citStr="Langholm (1989)" startWordPosition="990" endWordPosition="991">ed in this paper. This paper extends the ideas in these earlier papers with theoretical results that suggest a forward-chaining algorithm for determining the satisfiability of an arbitrary Schonfinkel-Bernays&apos; formula. This generalizes the standard feature-graph unification algorithm and is closely related to the semi-naive bottom-up algorithm used in database theory. I For examples of this approach see Dawar and Vijay-Shanker (1990), Dorre and Eisele (1990), Johnson (1988, 1990a, 1990b, 1991a, 1991b, in press a), Karttunen (1984), Kasper (1987a, 19871), 1986), Kasper and Rounds (1986, 1990), Langholm (1989), Pereira (1987), and Smolka (1992). 2 Examples of this approach are Carpenter, Pollard, and Franz (1991), Dorre (1991), Done and Eisele (1991), Johnson (in press b), Kay (1979, 1985a, 1985b), Pollard and Sag (1987), Rounds and Manaster-Ramer (1987), Smolka (1988), and Zajac (1992). 3 While it may well be that the universal recognition and parsing problems for natural language are undecidable (Chomsky [1986, 1988] points out that there is no contrary evidence), I know of no evidence that this is actually the case. It seems reasonable then to also investigate formalisms that can only express de</context>
</contexts>
<marker>Langholm, 1989</marker>
<rawString>Langholm, Tore (1989). &amp;quot;How to say no with feature structures.&amp;quot; COSMOS Report No. 13, Department of Mathematics, University of Oslo.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Harry Lewis</author>
</authors>
<title>Complexity results for classes of quantificational formulae.&amp;quot;</title>
<date>1980</date>
<journal>JCSS</journal>
<pages>21--317</pages>
<contexts>
<context position="17717" citStr="Lewis 1980" startWordPosition="2642" endWordPosition="2643">rmulae, and they are interpreted in exactly the same way as firstorder formulae. The body a may contain boolean connectives (including negation), which can be used to express arbitrary boolean combinations of constraints. Unlike the satisfiability problem for full first-order logic, which is undecidable (co-recursively enumerable), the satisfiability problem for SB is decidable; in fact it is PSPACE-complete (Lewis and Papadimitriou 1981). Further, if SB„ is the class of SB formulae with n or fewer universal quantifiers, then for any fixed n the satisfiability problem for 513n is NP-complete (Lewis 1980). In the applications described here, the number of universal quantifiers is fixed (i.e., it does not vary with the utterance or even with the grammar), so the corresponding satisfiability problems are all NP-complete. The class of SB formulae is interesting for other reasons besides its ability to express a wide range of linguistic constraints. As shown below, the class of SB formulae in clausal form constitute an extension of Datalog that allows disjunctive consequents. 3.2 Formalizing Attribute-Value Structures Using SIB SB is both simple and expressive enough that grammar designers might c</context>
</contexts>
<marker>Lewis, 1980</marker>
<rawString>Lewis, Harry (1980). &amp;quot;Complexity results for classes of quantificational formulae.&amp;quot; JCSS 21,317-353.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Harry Lewis</author>
<author>Christos Papadimitriou</author>
</authors>
<title>Elements of the Theory of Computation.</title>
<date>1981</date>
<publisher>Prentice-Hall, NJ.</publisher>
<contexts>
<context position="17548" citStr="Lewis and Papadimitriou 1981" startWordPosition="2611" endWordPosition="2614"> formula is in SB iff it has no free variables and is of the form \ix] Vx„ce, where a contains no quantifier symbols or function symbols. SB formulae are a proper subset of first-order formulae, and they are interpreted in exactly the same way as firstorder formulae. The body a may contain boolean connectives (including negation), which can be used to express arbitrary boolean combinations of constraints. Unlike the satisfiability problem for full first-order logic, which is undecidable (co-recursively enumerable), the satisfiability problem for SB is decidable; in fact it is PSPACE-complete (Lewis and Papadimitriou 1981). Further, if SB„ is the class of SB formulae with n or fewer universal quantifiers, then for any fixed n the satisfiability problem for 513n is NP-complete (Lewis 1980). In the applications described here, the number of universal quantifiers is fixed (i.e., it does not vary with the utterance or even with the grammar), so the corresponding satisfiability problems are all NP-complete. The class of SB formulae is interesting for other reasons besides its ability to express a wide range of linguistic constraints. As shown below, the class of SB formulae in clausal form constitute an extension of</context>
</contexts>
<marker>Lewis, Papadimitriou, 1981</marker>
<rawString>Lewis, Harry, and Papadimitriou, Christos (1981). Elements of the Theory of Computation. Prentice-Hall, NJ.</rawString>
</citation>
<citation valid="true">
<authors>
<author>John W Lloyd</author>
</authors>
<title>Foundations of Logic Programming.</title>
<date>1984</date>
<publisher>Springer-Verlag.</publisher>
<contexts>
<context position="53486" citStr="Lloyd (1984)" startWordPosition="8619" endWordPosition="8620">dex has the same structure as the standard graph encoding of feature structure constraints. 6. A Fixed-Point Theorem We now turn to the theoretical justification of the bottom-up forward-chaining procedures sketched in the last section, and show that such methods will find a model for a set of SB formulae in clausal form if one exists. This section demonstrates that an SB formula in clausal form is satisfiable if and only if a bottom-up forward-chaining procedure finds a deductively closed set of atoms A. A similar theorem for the case in which all the clauses are Horn clauses is presented in Lloyd (1984); this section extends that work to arbitrary clauses. It presents a characterization of the models of an arbitrary first-order formula co in clausal form in terms of the least-fixed points of a set {T;,, x} of partial functions from Herbrand interpretations to Herbrand interpretations. These functions have the property that A is a Herbrand interpretation that satisfies if and only if the least-fixed point of at least one of them is a submodel of A. For SB formulae this set of functions is finite and the least-fixed points are reached in a finitely bounded number of iterations. Since the proce</context>
<context position="54731" citStr="Lloyd (1984)" startWordPosition="8824" endWordPosition="8825">on calculate the least-fixed points of these functions, they can be used to determine the satisfiability of an arbitrary SB formula as well as all of its ground atomic consequences. The functions T, x play a similiar role here to one that the transformation Tp plays in the least-fixed-point semantics of Horn clause programs. Informally, each function in the set {T} corresponds to one whole sequence of nondeterministic choices of disjuncts in non-Horn clauses that could be made during an iterative approximation of the least-fixed point. This section is based on Sections 5 and 6 of Chapter 1 of Lloyd (1984), to which the reader should turn for further details. The fixed-point theorem holds for arbitrary first-order formulae in clausal form, but the set {Tx1 is finite if and only if does not contain any function symbols, i.e., cp is an SB formula. Equality is not treated specially, so the formula co must contain appropriate equality axioms, as mentioned above. Let U be the Herbrand universe with respect to (i.e., the set of all terms that can be constructed using the constant and function symbols appearing in co),&apos;&apos; and let B, be the set of all ground atoms that can be formed using the predicate </context>
<context position="59286" citStr="Lloyd (1984)" startWordPosition="9677" endWordPosition="9678">orresponds to one nondeterministic step in the &apos;bottom-up&apos; construction of a Herbrand model for yo described in the previous section. If A makes the antecedent of some ground instance of some clause in true, then we use the choice function x to pick an atom in the consequent of that ground clause and add it to the interpretation. Different choice functions x represent different sequences of nondeterministic choices, and result in the construction of possibly different interpretations. 18 Mark Johnson Computing with Features as Formulae The following lemma, based directly on proposition 6.3 of Lloyd (1984), notes the continuity (and therefore the monotonicity) of Lemma 1 The function F is continuous. That is, if X is a directed subset of 2&apos; (i.e., every finite subset of X has an upper bound in X) then F„„0„(lub(X)) = (X)). Proof Let X be any directed subset of 2&apos;. Then C lub(X) if and only if , arul C A for some A E X. Then E (lub(X)) iff c = (cri A - A am lit V &apos; • • V (in) is a nonnegative clause in Nal), ,O(o„)} C lub(X), and /3 iff c (al A • • • A am 01 V • &apos; • V ,(1,2) is a nonnegative clause in , 9(0)} C A for some A E X, and ,0 = 00x(c)(e)) if /3 E Fv,x (A) for some A c X iff j3 E lub(F,</context>
</contexts>
<marker>Lloyd, 1984</marker>
<rawString>Lloyd, John W. (1984). Foundations of Logic Programming. Springer-Verlag.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jorge Lobo</author>
<author>Jack Minker</author>
<author>Rajasekar</author>
</authors>
<title>Foundations of Disjunctive Logic Programming.</title>
<date>1992</date>
<publisher>MIT Press.</publisher>
<location>Arcot</location>
<marker>Lobo, Minker, Rajasekar, 1992</marker>
<rawString>Lobo, Jorge; Minker, Jack; and Rajasekar, Arcot (1992). Foundations of Disjunctive Logic Programming. MIT Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D W Loveland</author>
</authors>
<title>Near-Horn Prolog.&amp;quot; In Logic Programming: Papers for the</title>
<date>1987</date>
<booktitle>Fourth International Conference on Logic Programming, edited by Jean-Louis Lassez,</booktitle>
<pages>456--469</pages>
<publisher>MIT Press.</publisher>
<contexts>
<context position="41134" citStr="Loveland 1987" startWordPosition="6477" endWordPosition="6478">l restriction on the class of constraints expressible. Standard procedures for transforming first-order formulae into clausal form, such as the ones described in Chang and Lee (1973), Duffy 12 Mark Johnson Computing with Features as Formulae (1991), or Genesereth and Nilsson (1987), transform SB formulae into SB formulae in clausal form. Interestingly, clausal form SB formulae correspond one-to-one with an extension to Datalog (Ullman 1988) that allows disjunctive &amp;quot;heads&amp;quot; or consequences. In notation borrowed from disjunctive logic programming (Kowalski 1979; Lobo, Minker, and Rajasekar 1992; Loveland 1987), the clauses above would be written as listed in the appendix. While the connection between logic programming and feature structures is well known (Alt-Kaci 1984; Ait-Kaci and Podelski 1993; Carpenter 1991,1992; Hiihfeld and Smolka 1988; Pereira 1987; Shieber 1992; Smolka 1992), this shows that the theory of feature structure constraints is also related to database theory as well. Negative clauses correspond to Datalog integrity constraints, and clauses with a single positive literal are definite clauses. Simple assertions, e.g., about the existence of arcs, consisting of exactly one positive</context>
</contexts>
<marker>Loveland, 1987</marker>
<rawString>Loveland, D. W. (1987). &amp;quot;Near-Horn Prolog.&amp;quot; In Logic Programming: Papers for the Fourth International Conference on Logic Programming, edited by Jean-Louis Lassez, 456-469. MIT Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Mitch Marcus</author>
<author>Donald Hindle</author>
<author>Margaret M Fleck</author>
</authors>
<title>D-theory--talking about talking about trees.&amp;quot;</title>
<date>1983</date>
<booktitle>In Proceedings, 21st Annual Meeting of the Association for Computational Linguistics,</booktitle>
<pages>129--136</pages>
<location>Cambridge, MA.</location>
<marker>Marcus, Hindle, Fleck, 1983</marker>
<rawString>Marcus, Mitch; Hindle, Donald; and Fleck, Margaret M. (1983). &amp;quot;D-theory--talking about talking about trees.&amp;quot; In Proceedings, 21st Annual Meeting of the Association for Computational Linguistics, 129-136. Cambridge, MA.</rawString>
</citation>
<citation valid="true">
<authors>
<author>John T Maxwell</author>
<author>Ronald M Kaplan</author>
</authors>
<title>A method for disjunctive constraint satisfaction.&amp;quot;</title>
<date>1991</date>
<booktitle>In Current Issues in Parsing Technology, edited by Masaru Tomita„</booktitle>
<pages>173--190</pages>
<publisher>Kluwer Academic Publishers.</publisher>
<contexts>
<context position="67366" citStr="Maxwell and Kaplan (1991" startWordPosition="11057" endWordPosition="11060">nsforming disjunctions of finitedomain feature-value constraints into conjunctions. Kasper (1988) and Hegner (1991) point out that Horn clauses, although technically disjunctions, can be handled considerably more efficiently than general disjunctive constraints. The forward-chaining mechanisms that they propose for treating these constraints appear to be special cases of the semi-naive algorithm sketched in this paper. Unfortunately, I know of no general adequate method for handling the disjunctive constraints that arise in real grammars with acceptable efficiency. The techniques discussed by Maxwell and Kaplan (1991, 1992) seem most directly compatible with the approach described in this paper, and the methods described by Kasper (1987b), Eisele and Dorre (1988), and Ernele (1991) might have important applications as well. Acknowledgment for their suggestions and comments. All I would like to thank Johan van Benthem, responsibility for errors rests with me, of Bob Carpenter, Stephen Hegner, Ronald course. M. Kaplan, Edward Stabler and the References participants of the feature structures Alt-Kaci, Hassan (1984). A lattice theoretic seminar at the Institut fiir maschinelle approach to computation based on</context>
</contexts>
<marker>Maxwell, Kaplan, 1991</marker>
<rawString>Maxwell, John T., and Kaplan, Ronald M. (1991). &amp;quot;A method for disjunctive constraint satisfaction.&amp;quot; In Current Issues in Parsing Technology, edited by Masaru Tomita„ 173-190. Kluwer Academic Publishers.</rawString>
</citation>
<citation valid="true">
<authors>
<author>John T Maxwell</author>
<author>Ronald M Kaplan</author>
</authors>
<title>The interface between phrasal and functional constraints.&amp;quot;</title>
<date>1992</date>
<journal>Computational Linguistics</journal>
<volume>19</volume>
<issue>4</issue>
<pages>571--590</pages>
<marker>Maxwell, Kaplan, 1992</marker>
<rawString>Maxwell, John T., and Kaplan, Ronald M. (1992). &amp;quot;The interface between phrasal and functional constraints.&amp;quot; Computational Linguistics 19(4), 571-590.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Drew Moshier</author>
</authors>
<title>Extensions to unification grammar for the description of programming languages. Doctoral dissertation,</title>
<date>1988</date>
<institution>University of Michigan.</institution>
<marker>Moshier, 1988</marker>
<rawString>Moshier, M. Drew (1988). Extensions to unification grammar for the description of programming languages. Doctoral dissertation, University of Michigan.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Drew Mushier</author>
<author>William C Rounds</author>
</authors>
<title>A logic for partially specified data structures.&amp;quot;</title>
<date>1987</date>
<booktitle>In The ACM Symposium on the Principles of Programming Languages. Association for Computing Machinery,</booktitle>
<location>Munich, Germany.</location>
<marker>Mushier, Rounds, 1987</marker>
<rawString>Mushier, M. Drew, and Rounds, William C. (1987). &amp;quot;A logic for partially specified data structures.&amp;quot; In The ACM Symposium on the Principles of Programming Languages. Association for Computing Machinery, Munich, Germany.</rawString>
</citation>
<citation valid="true">
<authors>
<author>G Nelson</author>
<author>D C Oppen</author>
</authors>
<title>Fast decision procedures based on congruence closure.&amp;quot;</title>
<date>1980</date>
<journal>J. ACM</journal>
<volume>27</volume>
<issue>2</issue>
<pages>245--257</pages>
<contexts>
<context position="15999" citStr="Nelson and Oppen 1980" startWordPosition="2385" endWordPosition="2388">al logic. Johnson (1991b) also discusses the application of general first-order logic and nonmonotic logics to the specification of more complex constraints on feature structures. 4 Mark Johnson Computing with Features as Formulae be decided in quasi-linear time using the congruence-closure algorithm, but this language can only express conjunctions of feature-value equalities and inequalities. If this language is extended to allow disjunctions (so that disjunctive feature-value constraints can be expressed), the satisfiability problem becomes NP-complete (Gallier 1986; Kasper and Rounds 1990; Nelson and Oppen 1980). Since disjunctive constraints seem to be a practical necessity for describing natural languages (Barton, Berwick, and Ristad 1987; Karthinen 1984), most practical feature structure systems will probably have NP-hard satisfiability problems. Given that we have to solve an NP-hard problem anyway, it seems reasonable to investigate the most expressive feature structure constraint language that has an NP-complete satisfiability problem. The Schonfinkel-Bernays&apos; class, used in the manner described here, appears to be the most expressive language for feature structure constraints proposed in the l</context>
<context position="47203" citStr="Nelson and Oppen 1980" startWordPosition="7495" endWordPosition="7498">then instances of (E2) and (F3) ensure that p(b),q(a) and b ---= a will be added to AA and thence to A. In general, if it is discovered that n constants al, ... a, are equal, then A will ultimately contain the n2 equalities ai ar 1 &lt; i &lt; n, 1 &lt; j &lt; n, as well as at least n &amp;quot;copies&amp;quot; of any predicate containing any a„ 5.3 Union-Find and Equality As noted above, the equality axioms ensure that the relation that the equality symbol denotes is an equivalence relation and the substitutivity of equals for equals. in general, the union-find algorithm (Corman, Leiserson, and Rivest 1990; Gallier 1986; Nelson and Oppen 1980) maintains the equivalence classes of the equality relation far more efficiently than an approach that uses the syntactic equality axioms. The equivalence classes are encoded by associating each constant with a pointer that is either null or points to another constant, where a points to b only if a =-- b. These pointer correspond exactly to the &amp;quot;invisible pointers&amp;quot; used in standard implementations of the attribute-value unification algorithm. 14 Mark Johnson Computing with Features as Formulae Input: A set of SB clauses S. Output: A set of ground clauses A iff S is satisfiable. A AA := {choose</context>
</contexts>
<marker>Nelson, Oppen, 1980</marker>
<rawString>Nelson, G., and Oppen, D. C. (1980). &amp;quot;Fast decision procedures based on congruence closure.&amp;quot; J. ACM 27(2), 245-257.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Barbara H Partee</author>
<author>ter Meulen</author>
<author>Alice</author>
<author>Robert E Wall</author>
</authors>
<date>1990</date>
<booktitle>Mathematical Methods in Linguistics.</booktitle>
<publisher>Kluwer Academic Publishers.</publisher>
<marker>Partee, Meulen, Alice, Wall, 1990</marker>
<rawString>Partee, Barbara H.; ter Meulen, Alice; and Wall, Robert E. (1990). Mathematical Methods in Linguistics. Kluwer Academic Publishers.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Fernando C N Pereira</author>
</authors>
<title>Logic for natural language analysis. Doctoral dissertation,</title>
<date>1982</date>
<institution>University of Edinburgh.</institution>
<contexts>
<context position="4811" citStr="Pereira 1982" startWordPosition="683" endWordPosition="684">constraint formalism described below. A second class of extended constraint formalisms has been devised to be capable of expressing the entire grammar as systems of constraints and as far as I know, for all of these systems the problem of determining the satisfiability of an arbitrary system of constraints that they can express is undecidable.2 This is because the recognition problem for an arbitrary &amp;quot;unification-based&amp;quot; grammar is undecidable unless the size of the phrase structure tree is constrained somehow, e.g., by the offline parsability constraint (Johnson 1988; Kaplan and Bresnan 1982; Pereira 1982; Shieber 1992), but there seems to be no natural way to impose such constraints in these systems because the encoding of the phrase structure tree in the feature structure is not distinguished from other features.&apos; Thus in order to maintain decidability the system described here is not designed to be capable of expressing phrase structure constraints directly, and must be used with an external phrase-structure component, as in LFG (Bresnan 1982). (However, Bob Carpenter [p.c.1 points out that one can impose a bound on the size of the feature structure that can serve as an analysis [say, some </context>
</contexts>
<marker>Pereira, 1982</marker>
<rawString>Pereira, Fernando C. N. (1982). Logic for natural language analysis. Doctoral dissertation, University of Edinburgh.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Fernando C N Pereira</author>
</authors>
<title>Grammars and logics of partial information.&amp;quot;</title>
<date>1987</date>
<booktitle>In Proceedings, International Conference on Logic Programming,</booktitle>
<pages>989--1013</pages>
<location>Melbourne, Australia.</location>
<contexts>
<context position="6843" citStr="Pereira (1987)" startWordPosition="992" endWordPosition="993"> This paper extends the ideas in these earlier papers with theoretical results that suggest a forward-chaining algorithm for determining the satisfiability of an arbitrary Schonfinkel-Bernays&apos; formula. This generalizes the standard feature-graph unification algorithm and is closely related to the semi-naive bottom-up algorithm used in database theory. I For examples of this approach see Dawar and Vijay-Shanker (1990), Dorre and Eisele (1990), Johnson (1988, 1990a, 1990b, 1991a, 1991b, in press a), Karttunen (1984), Kasper (1987a, 19871), 1986), Kasper and Rounds (1986, 1990), Langholm (1989), Pereira (1987), and Smolka (1992). 2 Examples of this approach are Carpenter, Pollard, and Franz (1991), Dorre (1991), Done and Eisele (1991), Johnson (in press b), Kay (1979, 1985a, 1985b), Pollard and Sag (1987), Rounds and Manaster-Ramer (1987), Smolka (1988), and Zajac (1992). 3 While it may well be that the universal recognition and parsing problems for natural language are undecidable (Chomsky [1986, 1988] points out that there is no contrary evidence), I know of no evidence that this is actually the case. It seems reasonable then to also investigate formalisms that can only express decidable systems </context>
<context position="9874" citStr="Pereira 1987" startWordPosition="1460" endWordPosition="1461">structures, but they are also used to encode constraints that the linguistic structures must satisfy (see Section 2.10 of Johnson (1988) for an extended discussion). That is, under this view feature structures serve not only as linguistic structures that may or may not satisfy a constraint, but are also interpreted as &apos;representing&apos; or &apos;describing&apos; all of the feature structures that they subsume. Given this dual role for feature structures, it is important in this approach that if a feature structure S satisfies a constraint a, then every feature structure subsumed by S should also satisfy a (Pereira 1987). If this &amp;quot;upward closure&amp;quot; property holds, then the set of feature structures satisfying any constraint can be represented by the set of its &amp;quot;minimal models.&amp;quot; Unfortunately, many useful constraints do not have this property. For example, under a classical interpretation, the set of feature structures satisfying negated feature structure constraints are not upward-closed (Moshier and Rounds 1987). The work described in this paper pursues a different approach. Following Kaplan and Bresnan (1982), feature structures are only (components of) linguistic structures, and not partial descriptions of (</context>
<context position="41385" citStr="Pereira 1987" startWordPosition="6514" endWordPosition="6515">Genesereth and Nilsson (1987), transform SB formulae into SB formulae in clausal form. Interestingly, clausal form SB formulae correspond one-to-one with an extension to Datalog (Ullman 1988) that allows disjunctive &amp;quot;heads&amp;quot; or consequences. In notation borrowed from disjunctive logic programming (Kowalski 1979; Lobo, Minker, and Rajasekar 1992; Loveland 1987), the clauses above would be written as listed in the appendix. While the connection between logic programming and feature structures is well known (Alt-Kaci 1984; Ait-Kaci and Podelski 1993; Carpenter 1991,1992; Hiihfeld and Smolka 1988; Pereira 1987; Shieber 1992; Smolka 1992), this shows that the theory of feature structure constraints is also related to database theory as well. Negative clauses correspond to Datalog integrity constraints, and clauses with a single positive literal are definite clauses. Simple assertions, e.g., about the existence of arcs, consisting of exactly one positive literal are Datalog atomic clauses. Clauses with two or more positive literals cannot be expressed in Datalog itself, but require the disjunctive extension of Datalog. The appendix displays all of the SB formulae mentioned in this paper so far in cla</context>
</contexts>
<marker>Pereira, 1987</marker>
<rawString>Pereira, Fernando C. N. (1987). &amp;quot;Grammars and logics of partial information.&amp;quot; In Proceedings, International Conference on Logic Programming, 989-1013. Melbourne, Australia.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Carl Pollard</author>
<author>Ivan A Sag</author>
</authors>
<title>Information-Based Syntax and Semantics.</title>
<date>1987</date>
<booktitle>CSLI Lecture Notes Series.</booktitle>
<publisher>Chicago University Press.</publisher>
<contexts>
<context position="1898" citStr="Pollard and Sag 1987" startWordPosition="267" endWordPosition="270">n&apos; framework. For example, the analysis of conjunctions in LFG (Kaplan and Maxwell 1988b) and the formalizations of Discourse Representation Theory (Kamp 1981) presented in Johnson and Klein (1986) and Johnson and Kay (1990) require additional mechanisms for representing and manipulating aggregates or sets of values in ways that are beyond the capability of such &amp;quot;pure&amp;quot; attribute-value systems. Further, sortal constraints (which also cannot be expressed as simple equality constraints) can be used to formulate simpler and more comprehensible grammars (Carpenter 1992; Carpenter and Pollard 1991; Pollard and Sag 1987, 1992). Versions of both of these kinds of constraint, as well as the familiar attribute-value constraints, can be expressed as Schonfinkel-Bernays&apos; formulae (as demonstrated in Johnson 1991a, 1991b), so that the problem of determining the satisfiability of a system of such constraints is reduced to the satisfiability problem for the corresponding formula. This class of formulae (defined in Section 3.1) seems to be expressive enough for most linguistic purposes when used with an external phrase-structure backbone. That is, these formulae are used as annotations on phrase structure rules in th</context>
<context position="7042" citStr="Pollard and Sag (1987)" startWordPosition="1022" endWordPosition="1025">&apos; formula. This generalizes the standard feature-graph unification algorithm and is closely related to the semi-naive bottom-up algorithm used in database theory. I For examples of this approach see Dawar and Vijay-Shanker (1990), Dorre and Eisele (1990), Johnson (1988, 1990a, 1990b, 1991a, 1991b, in press a), Karttunen (1984), Kasper (1987a, 19871), 1986), Kasper and Rounds (1986, 1990), Langholm (1989), Pereira (1987), and Smolka (1992). 2 Examples of this approach are Carpenter, Pollard, and Franz (1991), Dorre (1991), Done and Eisele (1991), Johnson (in press b), Kay (1979, 1985a, 1985b), Pollard and Sag (1987), Rounds and Manaster-Ramer (1987), Smolka (1988), and Zajac (1992). 3 While it may well be that the universal recognition and parsing problems for natural language are undecidable (Chomsky [1986, 1988] points out that there is no contrary evidence), I know of no evidence that this is actually the case. It seems reasonable then to also investigate formalisms that can only express decidable systems of constraints (and for which there exist satisfiability-testing algorithms) if linguistically adequate systems can be found. 2 Mark Johnson Computing with Features as Formulae Specifically, it is sh</context>
</contexts>
<marker>Pollard, Sag, 1987</marker>
<rawString>Pollard, Carl, and Sag, Ivan A. (1987). Information-Based Syntax and Semantics. CSLI Lecture Notes Series. Chicago University Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Carl Pollard</author>
<author>Ivan A Sag</author>
</authors>
<title>1-lead-Driven Phrase Structure Grammar. CSLI Lecture Notes Series.</title>
<date>1992</date>
<publisher>Chicago University Press.</publisher>
<marker>Pollard, Sag, 1992</marker>
<rawString>Pollard, Carl, and Sag, Ivan A. (1992). 1-lead-Driven Phrase Structure Grammar. CSLI Lecture Notes Series. Chicago University Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>William C Rounds</author>
</authors>
<title>LFP: A logic for linguistic descriptions and an analysis of its complexity&amp;quot;</title>
<date>1988</date>
<journal>Computational Linguistics</journal>
<volume>14</volume>
<issue>4</issue>
<pages>1--9</pages>
<contexts>
<context position="31576" citStr="Rounds (1988)" startWordPosition="4893" endWordPosition="4894">P(z, y). (14) It is easy to see that this definition is not equivalent to a Schenfinkel-Bernays&apos; formula by expanding the equivalence into two implications and moving the embedded quantifier out. Vx Vy Vz C(x,y) —+ (-13(x , y) A (P(z, x) P(z, y))). (14a) Vx Vy Hz (—D (x , y) A P(z, x) P(z, y)) C (x, y). (14b) Formula (14b) is not in S13 because it contains an existential quantifier inside the scope of a universal quantifier. There are a number of ways to respond to this problem. First, we can abandon the attempt to work within the Schonfinkel-Bernays&apos; class, and work with some other language. Rounds (1988) describes such a language called up, whose decidability follows from the fact that the domain of quantification is 9 Computational Linguistics Volume 20, Number 1 restricted (just as in SB). However, it seems to be difficult to devise a decidable system capable of simultaneously expressing both tree structure and the variety of feature structure constraints that the SB approach described here can. Blackburn, Gardent, and Meyer-viol (1993) introduce a modal language LT for describing trees decorated with feature structures, whose satisfiability problem is undecidable. In the long run, such spe</context>
</contexts>
<marker>Rounds, 1988</marker>
<rawString>Rounds, William C. (1988). &amp;quot;LFP: A logic for linguistic descriptions and an analysis of its complexity&amp;quot; Computational Linguistics 14(4), 1-9.</rawString>
</citation>
<citation valid="true">
<authors>
<author>William C Rounds</author>
<author>Alexis Manaster-Ramer</author>
</authors>
<title>A logical version of functional grammar.&amp;quot;</title>
<date>1987</date>
<booktitle>In Proceedings, 25th Annual Meeting of the Association for Computational Linguistics,</booktitle>
<pages>89--96</pages>
<location>Stanford, CA.</location>
<contexts>
<context position="7076" citStr="Rounds and Manaster-Ramer (1987)" startWordPosition="1026" endWordPosition="1029">zes the standard feature-graph unification algorithm and is closely related to the semi-naive bottom-up algorithm used in database theory. I For examples of this approach see Dawar and Vijay-Shanker (1990), Dorre and Eisele (1990), Johnson (1988, 1990a, 1990b, 1991a, 1991b, in press a), Karttunen (1984), Kasper (1987a, 19871), 1986), Kasper and Rounds (1986, 1990), Langholm (1989), Pereira (1987), and Smolka (1992). 2 Examples of this approach are Carpenter, Pollard, and Franz (1991), Dorre (1991), Done and Eisele (1991), Johnson (in press b), Kay (1979, 1985a, 1985b), Pollard and Sag (1987), Rounds and Manaster-Ramer (1987), Smolka (1988), and Zajac (1992). 3 While it may well be that the universal recognition and parsing problems for natural language are undecidable (Chomsky [1986, 1988] points out that there is no contrary evidence), I know of no evidence that this is actually the case. It seems reasonable then to also investigate formalisms that can only express decidable systems of constraints (and for which there exist satisfiability-testing algorithms) if linguistically adequate systems can be found. 2 Mark Johnson Computing with Features as Formulae Specifically, it is shown that the satisfying Herbrand m</context>
</contexts>
<marker>Rounds, Manaster-Ramer, 1987</marker>
<rawString>Rounds, William C., and Manaster-Ramer, Alexis (1987). &amp;quot;A logical version of functional grammar.&amp;quot; In Proceedings, 25th Annual Meeting of the Association for Computational Linguistics, 89-96. Stanford, CA.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Stuart M Shieber</author>
</authors>
<title>An Introduction to Unification-Based Approaches to Grammar. CSLI Lecture Notes Series.</title>
<date>1986</date>
<publisher>University of Chicago Press.</publisher>
<contexts>
<context position="1104" citStr="Shieber 1986" startWordPosition="148" endWordPosition="149">gorithm for determining their satisfiability. This algorithm, which generalizes the standard attribute-value unification algorithm, is also recognizable as a nondeterministic variant of the semi-naive bottom-up algorithm for evaluating Datalog programs. further strengthening the connection between the theory of feature structures and databases. 1. Introduction Despite their simplicity, a surprisingly wide range of linguistic phenomena can be described in terms of simple equality constraints on values in attribute-value structures, which are a particularly simple kind of feature structure (see Shieber 1986; Johnson 1988; Uszkoreit 1986; and Bresnan 1982 for examples of some of these analyses). But some phenomena do not seem to be able to be described in such a pure &apos;unification&apos; framework. For example, the analysis of conjunctions in LFG (Kaplan and Maxwell 1988b) and the formalizations of Discourse Representation Theory (Kamp 1981) presented in Johnson and Klein (1986) and Johnson and Kay (1990) require additional mechanisms for representing and manipulating aggregates or sets of values in ways that are beyond the capability of such &amp;quot;pure&amp;quot; attribute-value systems. Further, sortal constraints (</context>
<context position="2568" citStr="Shieber (1986)" startWordPosition="371" endWordPosition="372">as well as the familiar attribute-value constraints, can be expressed as Schonfinkel-Bernays&apos; formulae (as demonstrated in Johnson 1991a, 1991b), so that the problem of determining the satisfiability of a system of such constraints is reduced to the satisfiability problem for the corresponding formula. This class of formulae (defined in Section 3.1) seems to be expressive enough for most linguistic purposes when used with an external phrase-structure backbone. That is, these formulae are used as annotations on phrase structure rules in the manner described in, e.g., Kaplan and Bresnan (1982), Shieber (1986), and Johnson (1988). This paper extends the author&apos;s previous paper on the topic (Johnson 1991a) by sketching several other linguistic applications of Schonfinkel-Bernays&apos; formulae (including a version of D-theory [Marcus, Hindle, and Fleck 1983; Vijay-Shanker 1992]), and presenting a least-fixed-point theorem that serves as the theoretical basis for a &amp;quot;forwardchaining&amp;quot; algorithm for determining satisfiabiIity of Schonfinkel-Bernays&apos; formulae. Interestingly, this algorithm can be viewed both as a straightforward generalization * Cognitive and Linguistic Sciences, Box 1978, Brown University, P</context>
<context position="3806" citStr="Shieber 1986" startWordPosition="536" endWordPosition="537">on@brown.edu (j) 1994 Association for Computational Linguistics Computational Linguistics Volume 20, Number 1 of the standard attribute-value unification algorithm and also as a nondeterministic variant of the semi-naive evaluation method for Datalog clauses. Several extended &amp;quot;unification-based&amp;quot; constraint formalisms have been developed. In this paper, the term &amp;quot;feature structure&amp;quot; denotes any kind of structured entity used as a component of a category label. An attribute-value structure is a particularly simple kind of feature structure of the kind used in &amp;quot;pure&amp;quot; unification-based frameworks (Shieber 1986). Some extensions to the basic attribute-value framework are rather weak, e.g., allowing disjunctive and negative constraints and preserving decidability.1 Such systems require an &amp;quot;off-line&amp;quot; phrase structure backbone to which these constraints are attached. It seems that most of the constraints that can be expressed in these formalisms can be expressed as Schonfinkel-Bernays&apos; formulae, the constraint formalism described below. A second class of extended constraint formalisms has been devised to be capable of expressing the entire grammar as systems of constraints and as far as I know, for all </context>
<context position="8828" citStr="Shieber 1986" startWordPosition="1288" endWordPosition="1289">oach exploits the fact that constraints on well-formed linguistic structures (e.g., well-formedness constraints imposed by the grammar) do not need to be isomorphic to the structures that satisfy them. Although the distinction between constraints and structures that satisfy them might seem too obvious to warrant comment, it is not made in most work on feature structures. A common view holds that feature structures are inherently &amp;quot;partially specified&amp;quot; entities, which &amp;quot;unify&amp;quot; or merge with other feature structures to yield more instantiated feature structures in an &amp;quot;information-preserving&amp;quot; way (Shieber 1986). If two feature structures contain &amp;quot;contradictory information,&amp;quot; then it is impossible to merge them to produce a consistent object; unification is then said to fail. The feature structure for an utterance is the result (if one exists) of unifying all of the feature structures for the lexical entries and syntactic rules in appropriate ways. Thus in this view feature structures play two roles; not only do they serve as linguistic structures, but they are also used to encode constraints that the linguistic structures must satisfy (see Section 2.10 of Johnson (1988) for an extended discussion). T</context>
</contexts>
<marker>Shieber, 1986</marker>
<rawString>Shieber, Stuart M. (1986). An Introduction to Unification-Based Approaches to Grammar. CSLI Lecture Notes Series. University of Chicago Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Stuart M Shieber</author>
</authors>
<title>Constraint-Based Grammar Formalisms: Parsing and Type Inference for Natural and Computer Languages.</title>
<date>1992</date>
<publisher>MIT Press.</publisher>
<contexts>
<context position="4826" citStr="Shieber 1992" startWordPosition="685" endWordPosition="686">malism described below. A second class of extended constraint formalisms has been devised to be capable of expressing the entire grammar as systems of constraints and as far as I know, for all of these systems the problem of determining the satisfiability of an arbitrary system of constraints that they can express is undecidable.2 This is because the recognition problem for an arbitrary &amp;quot;unification-based&amp;quot; grammar is undecidable unless the size of the phrase structure tree is constrained somehow, e.g., by the offline parsability constraint (Johnson 1988; Kaplan and Bresnan 1982; Pereira 1982; Shieber 1992), but there seems to be no natural way to impose such constraints in these systems because the encoding of the phrase structure tree in the feature structure is not distinguished from other features.&apos; Thus in order to maintain decidability the system described here is not designed to be capable of expressing phrase structure constraints directly, and must be used with an external phrase-structure component, as in LFG (Bresnan 1982). (However, Bob Carpenter [p.c.1 points out that one can impose a bound on the size of the feature structure that can serve as an analysis [say, some polynomial of t</context>
<context position="41399" citStr="Shieber 1992" startWordPosition="6516" endWordPosition="6517"> Nilsson (1987), transform SB formulae into SB formulae in clausal form. Interestingly, clausal form SB formulae correspond one-to-one with an extension to Datalog (Ullman 1988) that allows disjunctive &amp;quot;heads&amp;quot; or consequences. In notation borrowed from disjunctive logic programming (Kowalski 1979; Lobo, Minker, and Rajasekar 1992; Loveland 1987), the clauses above would be written as listed in the appendix. While the connection between logic programming and feature structures is well known (Alt-Kaci 1984; Ait-Kaci and Podelski 1993; Carpenter 1991,1992; Hiihfeld and Smolka 1988; Pereira 1987; Shieber 1992; Smolka 1992), this shows that the theory of feature structure constraints is also related to database theory as well. Negative clauses correspond to Datalog integrity constraints, and clauses with a single positive literal are definite clauses. Simple assertions, e.g., about the existence of arcs, consisting of exactly one positive literal are Datalog atomic clauses. Clauses with two or more positive literals cannot be expressed in Datalog itself, but require the disjunctive extension of Datalog. The appendix displays all of the SB formulae mentioned in this paper so far in clausal form in D</context>
</contexts>
<marker>Shieber, 1992</marker>
<rawString>Shieber, Stuart M. (1992). Constraint-Based Grammar Formalisms: Parsing and Type Inference for Natural and Computer Languages. MIT Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Gert Smolka</author>
</authors>
<title>A feature logic with subsorts.&amp;quot;</title>
<date>1988</date>
<tech>LILOG Report No. 33,</tech>
<institution>IBM Deutschland GmbH.</institution>
<contexts>
<context position="7091" citStr="Smolka (1988)" startWordPosition="1030" endWordPosition="1031">fication algorithm and is closely related to the semi-naive bottom-up algorithm used in database theory. I For examples of this approach see Dawar and Vijay-Shanker (1990), Dorre and Eisele (1990), Johnson (1988, 1990a, 1990b, 1991a, 1991b, in press a), Karttunen (1984), Kasper (1987a, 19871), 1986), Kasper and Rounds (1986, 1990), Langholm (1989), Pereira (1987), and Smolka (1992). 2 Examples of this approach are Carpenter, Pollard, and Franz (1991), Dorre (1991), Done and Eisele (1991), Johnson (in press b), Kay (1979, 1985a, 1985b), Pollard and Sag (1987), Rounds and Manaster-Ramer (1987), Smolka (1988), and Zajac (1992). 3 While it may well be that the universal recognition and parsing problems for natural language are undecidable (Chomsky [1986, 1988] points out that there is no contrary evidence), I know of no evidence that this is actually the case. It seems reasonable then to also investigate formalisms that can only express decidable systems of constraints (and for which there exist satisfiability-testing algorithms) if linguistically adequate systems can be found. 2 Mark Johnson Computing with Features as Formulae Specifically, it is shown that the satisfying Herbrand models of an arb</context>
<context position="41371" citStr="Smolka 1988" startWordPosition="6512" endWordPosition="6513">e (1991), or Genesereth and Nilsson (1987), transform SB formulae into SB formulae in clausal form. Interestingly, clausal form SB formulae correspond one-to-one with an extension to Datalog (Ullman 1988) that allows disjunctive &amp;quot;heads&amp;quot; or consequences. In notation borrowed from disjunctive logic programming (Kowalski 1979; Lobo, Minker, and Rajasekar 1992; Loveland 1987), the clauses above would be written as listed in the appendix. While the connection between logic programming and feature structures is well known (Alt-Kaci 1984; Ait-Kaci and Podelski 1993; Carpenter 1991,1992; Hiihfeld and Smolka 1988; Pereira 1987; Shieber 1992; Smolka 1992), this shows that the theory of feature structure constraints is also related to database theory as well. Negative clauses correspond to Datalog integrity constraints, and clauses with a single positive literal are definite clauses. Simple assertions, e.g., about the existence of arcs, consisting of exactly one positive literal are Datalog atomic clauses. Clauses with two or more positive literals cannot be expressed in Datalog itself, but require the disjunctive extension of Datalog. The appendix displays all of the SB formulae mentioned in this paper</context>
</contexts>
<marker>Smolka, 1988</marker>
<rawString>Smolka, Gert. (1988). &amp;quot;A feature logic with subsorts.&amp;quot; LILOG Report No. 33, IBM Deutschland GmbH.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Gert Smolka</author>
</authors>
<title>Feature constraint logics for unification grammars.&amp;quot;</title>
<date>1992</date>
<journal>The Journal of Logic Programming</journal>
<volume>12</volume>
<issue>1</issue>
<pages>51--87</pages>
<contexts>
<context position="6862" citStr="Smolka (1992)" startWordPosition="995" endWordPosition="996">the ideas in these earlier papers with theoretical results that suggest a forward-chaining algorithm for determining the satisfiability of an arbitrary Schonfinkel-Bernays&apos; formula. This generalizes the standard feature-graph unification algorithm and is closely related to the semi-naive bottom-up algorithm used in database theory. I For examples of this approach see Dawar and Vijay-Shanker (1990), Dorre and Eisele (1990), Johnson (1988, 1990a, 1990b, 1991a, 1991b, in press a), Karttunen (1984), Kasper (1987a, 19871), 1986), Kasper and Rounds (1986, 1990), Langholm (1989), Pereira (1987), and Smolka (1992). 2 Examples of this approach are Carpenter, Pollard, and Franz (1991), Dorre (1991), Done and Eisele (1991), Johnson (in press b), Kay (1979, 1985a, 1985b), Pollard and Sag (1987), Rounds and Manaster-Ramer (1987), Smolka (1988), and Zajac (1992). 3 While it may well be that the universal recognition and parsing problems for natural language are undecidable (Chomsky [1986, 1988] points out that there is no contrary evidence), I know of no evidence that this is actually the case. It seems reasonable then to also investigate formalisms that can only express decidable systems of constraints (and</context>
<context position="14841" citStr="Smolka (1992)" startWordPosition="2219" endWordPosition="2220">llowing a suggestion first made in Kaplan and Bresnan (1982), showed how attribute-value constraints could be formalized in the quantifier-free subset of first-order logic, while later work (Johnson 1991a, 1991b) proposed a different formalization in the Schanfinkel-Bernays&apos; subset of first-order formulae.&apos; Roughly speaking, there is a trade-off between the expressive power of a language and its computational tractability. For example, the satisfiability problem for the language consisting of conjunctions of equalities and inequalities of first-order terms can 4 A third approach, developed by Smolka (1992), is to define a specialized language tailored for expressing attribute-value constraints and note its translation into some standard language, in this case, also the Schonfinkel-Bernays&apos; class. 5 Of course, there is no a priori reason for these subsets of first-order logic to be optimally suited for expressing feature structure constraints. Kasper and Rounds (1990) and more recently Blackburn (1991) and Blackburn and Spam (1992) have suggested that it may be useful to express feature structure constraints in a special kind of modal logic. Johnson (1991b) also discusses the application of gene</context>
<context position="21425" citStr="Smolka (1992)" startWordPosition="3225" endWordPosition="3226"> the names of attribute-value constants, and require that they satisfy the following schemata.&apos; For each c in N, con(c). (3) For each distinct pair c1, C2 in N, c1 c2. (4) Schema (3) requires each symbol in N to denote an attribute-value constant, and schema (4) enforces distinctness in essentially the same manner as that used in the specification systems of algebraic data-type theory (Kapur and Musser 1987). Formulas (1) and (2) and the instances of schemata (3) and (4) can be regarded as defining attribute-value feature structures. These axioms are quite permissive: in 6 Johnson (1991a) and Smolka (1992) propose that an attribute-value arc labeled a from x to y be conceptualized as an instance of a two-place relation a(x, y). For most applications there is little substantive difference between these two approaches; the approach taken here allows attributes to be quantified over, e.g., to state sortal constraints, and permits values to be used as attributes, as in e.g., T,FG (Kaplan and Bresnan 1982); for discussion and linguistic applications see also Johnson (1988). 7 As Patrick Blackburn (p.c.) points out, one consequence of this is that every model of these constraints will contain individ</context>
<context position="41413" citStr="Smolka 1992" startWordPosition="6518" endWordPosition="6519">), transform SB formulae into SB formulae in clausal form. Interestingly, clausal form SB formulae correspond one-to-one with an extension to Datalog (Ullman 1988) that allows disjunctive &amp;quot;heads&amp;quot; or consequences. In notation borrowed from disjunctive logic programming (Kowalski 1979; Lobo, Minker, and Rajasekar 1992; Loveland 1987), the clauses above would be written as listed in the appendix. While the connection between logic programming and feature structures is well known (Alt-Kaci 1984; Ait-Kaci and Podelski 1993; Carpenter 1991,1992; Hiihfeld and Smolka 1988; Pereira 1987; Shieber 1992; Smolka 1992), this shows that the theory of feature structure constraints is also related to database theory as well. Negative clauses correspond to Datalog integrity constraints, and clauses with a single positive literal are definite clauses. Simple assertions, e.g., about the existence of arcs, consisting of exactly one positive literal are Datalog atomic clauses. Clauses with two or more positive literals cannot be expressed in Datalog itself, but require the disjunctive extension of Datalog. The appendix displays all of the SB formulae mentioned in this paper so far in clausal form in Datalog notatio</context>
</contexts>
<marker>Smolka, 1992</marker>
<rawString>Smolka, Gert. (1992). &amp;quot;Feature constraint logics for unification grammars.&amp;quot; The Journal of Logic Programming 12(1,2), 51-87.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jeffrey D Ullman</author>
</authors>
<date>1988</date>
<booktitle>Principles of Database and Knowledge-Base Systems, Vol. I.</booktitle>
<publisher>Computer Science Press.</publisher>
<contexts>
<context position="40964" citStr="Ullman 1988" startWordPosition="6455" endWordPosition="6456">es in SB formulae are inessential, in that they can always be directly replaced by Skolem constants. Restricting attention to SB formulae in clausal form imposes no real restriction on the class of constraints expressible. Standard procedures for transforming first-order formulae into clausal form, such as the ones described in Chang and Lee (1973), Duffy 12 Mark Johnson Computing with Features as Formulae (1991), or Genesereth and Nilsson (1987), transform SB formulae into SB formulae in clausal form. Interestingly, clausal form SB formulae correspond one-to-one with an extension to Datalog (Ullman 1988) that allows disjunctive &amp;quot;heads&amp;quot; or consequences. In notation borrowed from disjunctive logic programming (Kowalski 1979; Lobo, Minker, and Rajasekar 1992; Loveland 1987), the clauses above would be written as listed in the appendix. While the connection between logic programming and feature structures is well known (Alt-Kaci 1984; Ait-Kaci and Podelski 1993; Carpenter 1991,1992; Hiihfeld and Smolka 1988; Pereira 1987; Shieber 1992; Smolka 1992), this shows that the theory of feature structure constraints is also related to database theory as well. Negative clauses correspond to Datalog integr</context>
<context position="45445" citStr="Ullman 1988" startWordPosition="7191" endWordPosition="7192">ecking of condition (a), the method is essentially computing a fixedpoint of the nonnegative clauses in S via a kind of iterative approximation known as naive evaluation. Naive evaluation is unnecessarily computationally inefficient. Once the set A is large enough to require an atom a to be added to A, naive evaluation &amp;quot;rediscovers&amp;quot; this requirement on all subsequent passes. 5.2 Semi-Naive Evaluation Semi-naive evaluation avoids rediscovering the same fact in the same way by insisting that each time a clause is applied at least one of the antecedents was just discovered on the previous round (Ullman 1988, 1989). This is done by maintaining two sets of atoms, A and AA, where A is the set of atoms discovered one or more iterations ago, and AA is the set of atoms discovered at the last iteration. The nondeterministic semi-naive algorithm for computing a set A (if it exists) is sketched in Figure 4. In that algorithm choose is a &amp;quot;function&amp;quot; that nondeterministically picks one member from its set argument; it can be implemented using, e.g., backtracking. Ullman describes methods of matching clauses in S against the sets A and AA that avoids calculating all of the ground instances of the clauses in </context>
</contexts>
<marker>Ullman, 1988</marker>
<rawString>Ullman, Jeffrey D. (1988). Principles of Database and Knowledge-Base Systems, Vol. I. Computer Science Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jeffrey D Ullman</author>
</authors>
<title>New Technologies.</title>
<date>1989</date>
<booktitle>Principles of Database and Knowledge-Base Systems,</booktitle>
<publisher>The</publisher>
<location>Vol. II:</location>
<marker>Ullman, 1989</marker>
<rawString>Ullman, Jeffrey D. (1989). Principles of Database and Knowledge-Base Systems, Vol. II: The New Technologies. Computer Science Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Hans Uszkoreit</author>
</authors>
<title>Categorial unification grammar.&amp;quot;</title>
<date>1986</date>
<booktitle>In Proceedings, 11th International Conference on Computational Linguistics,</booktitle>
<pages>187--194</pages>
<location>Bonn.</location>
<contexts>
<context position="1134" citStr="Uszkoreit 1986" startWordPosition="152" endWordPosition="153">r satisfiability. This algorithm, which generalizes the standard attribute-value unification algorithm, is also recognizable as a nondeterministic variant of the semi-naive bottom-up algorithm for evaluating Datalog programs. further strengthening the connection between the theory of feature structures and databases. 1. Introduction Despite their simplicity, a surprisingly wide range of linguistic phenomena can be described in terms of simple equality constraints on values in attribute-value structures, which are a particularly simple kind of feature structure (see Shieber 1986; Johnson 1988; Uszkoreit 1986; and Bresnan 1982 for examples of some of these analyses). But some phenomena do not seem to be able to be described in such a pure &apos;unification&apos; framework. For example, the analysis of conjunctions in LFG (Kaplan and Maxwell 1988b) and the formalizations of Discourse Representation Theory (Kamp 1981) presented in Johnson and Klein (1986) and Johnson and Kay (1990) require additional mechanisms for representing and manipulating aggregates or sets of values in ways that are beyond the capability of such &amp;quot;pure&amp;quot; attribute-value systems. Further, sortal constraints (which also cannot be expressed</context>
</contexts>
<marker>Uszkoreit, 1986</marker>
<rawString>Uszkoreit, Hans (1986). &amp;quot;Categorial unification grammar.&amp;quot; In Proceedings, 11th International Conference on Computational Linguistics, 187-194. Bonn.</rawString>
</citation>
<citation valid="true">
<authors>
<author>K Vijay-Shanker</author>
</authors>
<title>Using descriptions of trees in a tree adjoining grammar.&amp;quot;</title>
<date>1992</date>
<journal>Computational Linguistics</journal>
<volume>18</volume>
<issue>4</issue>
<pages>481--517</pages>
<contexts>
<context position="2834" citStr="Vijay-Shanker 1992" startWordPosition="408" endWordPosition="409">ty problem for the corresponding formula. This class of formulae (defined in Section 3.1) seems to be expressive enough for most linguistic purposes when used with an external phrase-structure backbone. That is, these formulae are used as annotations on phrase structure rules in the manner described in, e.g., Kaplan and Bresnan (1982), Shieber (1986), and Johnson (1988). This paper extends the author&apos;s previous paper on the topic (Johnson 1991a) by sketching several other linguistic applications of Schonfinkel-Bernays&apos; formulae (including a version of D-theory [Marcus, Hindle, and Fleck 1983; Vijay-Shanker 1992]), and presenting a least-fixed-point theorem that serves as the theoretical basis for a &amp;quot;forwardchaining&amp;quot; algorithm for determining satisfiabiIity of Schonfinkel-Bernays&apos; formulae. Interestingly, this algorithm can be viewed both as a straightforward generalization * Cognitive and Linguistic Sciences, Box 1978, Brown University, Providence, RI. Mark_Johnson@brown.edu (j) 1994 Association for Computational Linguistics Computational Linguistics Volume 20, Number 1 of the standard attribute-value unification algorithm and also as a nondeterministic variant of the semi-naive evaluation method fo</context>
<context position="27593" citStr="Vijay-Shanker 1992" startWordPosition="4210" endWordPosition="4211">as the following SB formula. Vx Vy arc(x , number , y) y = singular V y plural. (6) These examples demonstrate only a small fraction of the variety of the feature structure constraints that can be expressed in SB. Even though all of these examples are based on attribute-value features, other sorts of features can be described in SB as well. For example, Johnson (1991a) shows how to formulate a variety of constraints on `setvalued&apos; features in SB. 3.4 Expressing Tree Structure Constraints with SB Formulae Inspired by the work on description theory or &apos;D-theory&apos; (Marcus, Hindle, and Fleck 1983; Vijay-Shanker 1992), this section shows how some elementary constraints on precedence and dominance in a tree can be expressed as SB formulae. It differs from that work in that different kinds of constraints are expressible (Vijay-Shanker was concerned with the formalization of a different kind of grammar), and that all of the constraints expressible in the system described below are decidable (this follows from the fact that they are defined and expressed using SchOnfinkeI-Bernays&apos; formulae). These constraints are intended to appear as annotations on phrase structure rules (in the same way that attribute-value </context>
</contexts>
<marker>Vijay-Shanker, 1992</marker>
<rawString>Vijay-Shanker, K. (1992). &amp;quot;Using descriptions of trees in a tree adjoining grammar.&amp;quot; Computational Linguistics 18(4), 481-517.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Robert Wall</author>
</authors>
<title>Introduction to Mathematical Linguistics.</title>
<date>1972</date>
<publisher>Prentice-Hall.</publisher>
<contexts>
<context position="29139" citStr="Wall (1972)" startWordPosition="4443" endWordPosition="4444">Once these primitive tree structure relations are defined, they can be used to approximate more complex relationships such as c-commands, as described below. All of these axioms are in the Schonfinkel-Bernays&apos; class, so the satisfiability of arbitrary boolean combinations of such constraints is decidable. First, note that the standard definition of trees in terms of the binary relations &lt; (linear precedence) and D (domination) can be expressed directly as SchonfinkelBernays&apos; formulae. The axioms presented below are just the definitions of trees given in Partee, ter Meulen, and Wall (1990) and Wall (1972) using the syntax of first-order logic. Axioms (7a-c) require that &lt; is a strict partial order, and axioms (8a-c) require 8 Mark Johnson Computing with Features as Formulae that D is a weak partial order over the nodes in a tree. In what follows, N(x) is interpreted as meaning that x is a tree node. Vx -x &lt; x (irreflexivity) (7a) Vx Vy x &lt; y -- —iy &lt; x (asymmetry) (7b) VxVyVzx&lt;yAy&lt;z --+ x &lt;z (transitive closure) (7c) Vx D(x,x) i-4 N(x) (reflexivity) (8a) Vx Vy D(x,y) A D(y, x) —&gt; x = y (antisymmetry) (8b) Vx Vy Vz D(x,y) A D(y, z) .— D(x, z) (transitive closure) (Sc) Axiom (9) requires that th</context>
</contexts>
<marker>Wall, 1972</marker>
<rawString>Wall, Robert (1972). Introduction to Mathematical Linguistics. Prentice-Hall.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Reini Zajac</author>
</authors>
<title>Inheritance and constraint-based grammar formalisms.&amp;quot;</title>
<date>1992</date>
<journal>Computational Linguistics</journal>
<volume>18</volume>
<issue>2</issue>
<pages>159--182</pages>
<contexts>
<context position="7109" citStr="Zajac (1992)" startWordPosition="1033" endWordPosition="1034">and is closely related to the semi-naive bottom-up algorithm used in database theory. I For examples of this approach see Dawar and Vijay-Shanker (1990), Dorre and Eisele (1990), Johnson (1988, 1990a, 1990b, 1991a, 1991b, in press a), Karttunen (1984), Kasper (1987a, 19871), 1986), Kasper and Rounds (1986, 1990), Langholm (1989), Pereira (1987), and Smolka (1992). 2 Examples of this approach are Carpenter, Pollard, and Franz (1991), Dorre (1991), Done and Eisele (1991), Johnson (in press b), Kay (1979, 1985a, 1985b), Pollard and Sag (1987), Rounds and Manaster-Ramer (1987), Smolka (1988), and Zajac (1992). 3 While it may well be that the universal recognition and parsing problems for natural language are undecidable (Chomsky [1986, 1988] points out that there is no contrary evidence), I know of no evidence that this is actually the case. It seems reasonable then to also investigate formalisms that can only express decidable systems of constraints (and for which there exist satisfiability-testing algorithms) if linguistically adequate systems can be found. 2 Mark Johnson Computing with Features as Formulae Specifically, it is shown that the satisfying Herbrand models of an arbitrary Seftonfinke</context>
</contexts>
<marker>Zajac, 1992</marker>
<rawString>Zajac, Reini (1992). &amp;quot;Inheritance and constraint-based grammar formalisms.&amp;quot; Computational Linguistics 18(2), 159-182.</rawString>
</citation>
<citation valid="false">
<authors>
<author>arc X Xl</author>
<author>arc</author>
</authors>
<title>(20&apos;) arc(X,</title>
<journal>Al, Y) :- A = Al, arc(X, A, Y), (21&apos;) arc(X, A, Yl) Y = Yl, arc(X, A, Y). (22&apos;) con(C1) C = Cl, con(C). (23&apos;) 3rd_sg(Y) :- X = Y,</journal>
<volume>3</volume>
<marker>Xl, arc, </marker>
<rawString>(19&apos;) arc(Xl, A, Y) X = Xl, arc(X, A, Y). (20&apos;) arc(X, Al, Y) :- A = Al, arc(X, A, Y), (21&apos;) arc(X, A, Yl) Y = Yl, arc(X, A, Y). (22&apos;) con(C1) C = Cl, con(C). (23&apos;) 3rd_sg(Y) :- X = Y, 3rd_sg(X).</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>