<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.006593">
<title confidence="0.998383">
A Generic Approach to Parallel Chart Parsing with an
Application to LinGO
</title>
<author confidence="0.991745">
Marcel van Lohuizen
</author>
<affiliation confidence="0.9714665">
Faculty of Information Technology and Systems Delft University of Technology
Delft, The Netherlands
</affiliation>
<email confidence="0.995802">
mpvl@acm.org
</email>
<sectionHeader confidence="0.979938" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999930928571429">
Multi-processor systems are becom-
ing more commonplace and afford-
able. Based on analyses of ac-
tual parsings, we argue that to ex-
ploit the capabilities of such ma-
chines, unification-based grammar
parsers should distribute work at the
level of individual unification oper-
ations. We present a generic ap-
proach to parallel chart parsing that
meets this requirement, and show
that an implementation of this tech-
nique for LinGO achieves consider-
able speedups.
</bodyText>
<sectionHeader confidence="0.996303" genericHeader="introduction">
1 Introduction
</sectionHeader>
<bodyText confidence="0.999954022222222">
The increasing demand for accuracy and ro-
bustness for today’s unification-based gram-
mar parsers brings on an increasing demand
for computing power. In addition, as these
systems are increasingly used in applications
that require direct user interaction, e.g. web-
based applications, responsiveness is of major
concern. In the mean time, small-scale desk-
top multiprocessor systems (e.g. dual or even
quad Pentium machines) are becoming more
commonplace and affordable. In this paper
we will show that exploiting the capabilities
of these machines can speed up parsers con-
siderably, and can be of major importance in
achieving the required performance.
There are certain requirements the design
of a parallel parser should meet. Over the
past years, many improvements to existing
parsing techniques have boosted the perfor-
mance of parsers by many factors (Oepen and
Callmeier, 2000). If a design of a parallel
parser is tied too much to a particular ap-
proach to parsing, it may be hard to incorpo-
rate such improvements as they become avail-
able. For this reason, a solution to parallel
parsing should be as general as possible. One
obvious way to ensure that optimizations for
sequential parsers can be used in a parallel
parser as well is to let a parallel parser mimic
a sequential parser as much as possible. This
is basically the approach we will take.
The parser that we will present in this pa-
per uses the LinGO grammar. LinGO is an
HPSG-based grammar which was developed
at Stanford (Copestake, 2000). It is currently
used by many research institutions. This al-
lows our results to be compared with that of
other research groups.
In Section 2, we explore the possibilities for
parallelism in natural language parsing by an-
alyzing the computational structure of pars-
ings. Section 3 and 4 discuss respectively the
design and the performance of our system.
Finally, we compare our work with other re-
search on parallel parsing.
</bodyText>
<sectionHeader confidence="0.598763" genericHeader="method">
2 Analysis of Parsings
</sectionHeader>
<bodyText confidence="0.999754714285714">
To analyze the possibilities for parallelism in
computations they are often represented as
task graphs. A task graph is a directed acyclic
graph, where the nodes represent some unit
of computation, called a task, and the arcs
represent the execution dependencies between
the tasks. Task graphs can be used to an-
alyze the critical path, which is the mini-
mal time required to complete a computa-
tion, given an infinite amount of processors.
From Brent (1974) and Graham (1969) we
know that there exist P-processor schedulings
where the execution time Tp is bound as fol-
lows:
</bodyText>
<equation confidence="0.985375">
Tp ≤ T1/P + T∞, (1)
</equation>
<bodyText confidence="0.999960363636364">
where T1 is the total work, or the execution
time for the one processor case, and T∞ is
the critical path. Furthermore, to effectively
use P processors, the average parallelism P¯ =
T1/T∞ should be larger than P.
The first step of the analysis is to find an
appropriate graph representation for parsing
computations. According to Caroll (1994),
performing a complexity analysis solely at the
level of grammars and parsing schemata can
give a distorted image of the parsing pro-
cess in practice. For this reason, we based
our analysis on actual parsings. The experi-
ments were based on the fuse test suite, which
is a balanced extract from four appointment
scheduling (spoken) dialogue corpora (incl.
VerbMobil). Fuse contains over 2000 sen-
tences with an average length of 11.6.
We define a task graph for a single pars-
ing computation as follows. First, we distin-
guish two types of tasks: unification tasks and
match tasks. A unification task executes a
single unification operation. A match task is
responsible for all the actions that are taken
when a unification succeeds: matching the
resulting edge with other edges in the chart
and putting resulting unification tasks on the
agenda. The match task is also responsible
for applying filtering techniques like the quick
check (Malouf et al., 2000). The tasks are
connected by directed arcs that indicate the
execution dependencies.
We define the cost of each unification task
as the number of nodes visited during the
unification and successive copying operation.
Unification operations are typically responsi-
ble for over 90% of the total work. In addi-
tion, the cost of the match tasks are spread
out over succeeding unification tasks. We
therefore simply neglect the cost for match op-
erations, and assume that this does not have a
significant impact on our measurements. The
length of a path in the graph can now be de-
fined as the sum of the costs of all nodes on
</bodyText>
<figureCaption confidence="0.9973425">
Figure 1: Task graphs for two different ap-
proaches to parallel chart parsing.
</figureCaption>
<table confidence="0.988713">
T1 T∞ P¯
Type 1 1014247 3487 187
Average type 2 1014247 11004 54
Worst case type 2 1014247 69300 13
</table>
<tableCaption confidence="0.8518415">
Table 1: Critical path analysis for type 1 and
type 2 task graphs (average and worst case).
</tableCaption>
<bodyText confidence="0.999654666666667">
the path. The critical path length T∞ can be
defined as the longest path between any two
nodes in the graph.
The presented model resembles a very fine-
grained scheme for distributing work, where
each single unification tasks to be scheduled
independently. In a straightforward imple-
mentation of such a scheme, the scheduling
overhead can become significant. Limiting
the scheduling overhead is crucial in obtaining
considerable speedup. It might therefore be
tempting to group related tasks into a single
unit of execution to mitigate this overhead.
For this reason we also analyzed a task graph
representation where only match tasks spawn
a new unit of execution. The top graph in
Figure 1 shows an example of a task graph
for the first approach. The bottom graph of
Figure 1 shows the corresponding task graph
for the second approach. Note that because
a unification task may depend on more than
one match task, a choice has to be made in
which unit of execution the unification task is
put.
Table 1 shows the results of the critical path
analysis of both approaches. For the first ap-
proach, the critical path is uniquely defined.
For the second approach we show both the
worst case, considering all possible schedul-
ings, and an average case. The results for T1,
T∞, and P¯ are averaged over all sentences.1
The results show that, using the first ap-
proach, there is a considerable amount of par-
allelism in the parsing computations. The re-
sults also show that a small change in the de-
sign of a parallel parser can have a signifi-
cant impact on the value for P¯. To obtain a
speedup of P, in practice, there should be a
safety margin between P and P¯. This sug-
gests that the first approach is a considerably
saver choice, especially when one is consider-
ing using more than a dozen of processors.
</bodyText>
<sectionHeader confidence="0.990802" genericHeader="method">
3 Design and Implementation
</sectionHeader>
<bodyText confidence="0.980590848484849">
Based on the discussion in the preceding sec-
tions, we can derive two requirements for the
design of a parallel parser: it should be close
in design to a sequential parser and it should
allow each single unification operation to be
scheduled dynamically. The parallel parser we
will present in this section meets both require-
ments.
Let us first focus on how to meet the first
requirement. Basically, we let each processor,
run a regular sequential parser augmented
with a mechanism to combine the results of
the different parsers. Each sequential parser
component is contained in a different thread.
By using threads, we allow each parser to
share the same memory space. Initially, each
thread is assigned a different set of work, for
example, resembling a different part of the in-
put string. A thread will process the unifica-
tion tasks on the agenda and, on success, will
perform the resulting match task to match the
new edge with the edges on its chart. After
completing the work on its agenda, a thread
will match the edges on its chart with the
edges derived so far by the other threads. This
may produce new unification tasks, which the
thread puts on its agenda. After the commu-
nication phase is completed, it returns to nor-
mal parsing mode to execute the work on its
agenda. This process continues until all edges
1Note that since E T1/ E T. =� E T1/T., the re-
sults for P¯ turn out slightly lower than might have
been expected from the values of T1 and T..
</bodyText>
<figureCaption confidence="0.999067">
Figure 2: Architecture of MACAMBA.
</figureCaption>
<bodyText confidence="0.862485">
of all threads have been matched against each
other and all work has been completed.
</bodyText>
<subsectionHeader confidence="0.997834">
3.1 Data Structures
</subsectionHeader>
<bodyText confidence="0.945579675">
Figure 2 shows an outline of our approach in
terms of data structures. Each thread con-
tains an agenda, which can be seen as a queue
of unification tasks, a chart, which stores the
derived edges, and a heap, which is used to
store the typed-feature structures that are ref-
erenced by the edges. Each thread has full ac-
cess to its own agenda, chart, and heap, and
has read-only access to the respective struc-
tures of all other threads. Grammars are
read-only and can be read by all threads.
In the communication phase, threads need
read-only access to the edges derived by other
threads. This is especially problematic for
the feature structures. Many unification al-
gorithms need write access to scratch fields
in the graph structures. Such algorithms are
therefore not thread-safe.2 For this reason we
use the thread-safe unification algorithm pre-
sented by Van Lohuizen (2000), which is com-
parable in performance to Tomabechi’s algo-
rithm (Tomabechi, 1991).
Note that each thread also has its own
agenda. Some parsing systems require strict
control over the order of evaluation of tasks.
The distributed agendas that we use in our
approach may make it hard to implement such
a strict control. One solution to the problem
would be to use a centralized agenda. The dis-
advantage of such a solution is that it might
increase the synchronization overhead. Tech-
niques to reduce the synchronization overhead
2In this context, thread safe means that the same
data structure can be involved in more than one op-
eration, of more than one thread, simultaneously.
global shared NrThreadsIdle, Generation, IdleGen
SCHED()
var threadGen, newWork, isIdle
threadGen←Generation←Generation+1
while NrThreadsIdle =6 P do
</bodyText>
<listItem confidence="0.950700882352941">
1. newWork ← not IsEMPTY(agenda).
2. Process the agenda as in the sequential
case. In addition, stamp each newly de-
rived I edge by setting I.generation to the
current value for threadGen and add I to this
thread’s edge list.
3. Examine all the other threads for newly
derived edges. For each new edge I and for
each edge J on the chart for which holds
I.generation &gt; J.generation, add the cor-
responding task to the agenda if it passes
the filter. If any edge was processed, set
newWork to true.
4. if not newWork then
newWork ←STEAL()
5. lock GlobalLock
6. if newWork then
</listItem>
<figure confidence="0.993459733333333">
Generation ← Generation + 1
threadGen ← Generation
NrThreadsIdle ← 0
7. else
if Generation =6 IdleGen then
isIdle ← false
Generation ← Generation + 1
threadGen ← IdleGen ← Generation
elseif threadGen =6 IdleGen then
isIdle ← false
threadGen ← IdleGen
elseif not isIdle then
isIdle ← true
NrThreadsIdle ← NrThreadsIdle + 1
8. unlock GlobalLock
</figure>
<figureCaption confidence="0.999984">
Figure 3: Scheduling algorithm.
</figureCaption>
<bodyText confidence="0.976657">
in such a setup can be found in (Markatos and
LeBlanc, 1992).
</bodyText>
<subsectionHeader confidence="0.999422">
3.2 Scheduling Algorithm
</subsectionHeader>
<bodyText confidence="0.999984769230769">
At startup, each thread calls the scheduling
algorithm shown in Figure 3. This algorithm
can be seen as a wrapper around an existing
sequential parser that takes care of combin-
ing the results of the individual threads. The
functionality of the sequential parser is em-
bedded in step 2. After this step, the agenda
will be empty. The communication between
threads takes place in step 3. Each time a
thread executes this step, it will proceed over
all the newly derived edges of other threads
(foreign edges) and match them with the
edges on its own chart (local edges). Checking
the newly derived edges of other threads can
simply be done by proceeding over a linked list
of derived edges maintained by the respective
threads. Threads record the last visited edge
of the list of each other thread. This ensures
that each newly derived item needs to be vis-
ited only once by each thread.
As a result of step 3, the agenda may be-
come non-empty. In this case, newWork will
be set and step 2 is executed again. This cycle
continues until all work is completed.
The remaining steps serve several purposes:
load balancing, preventing double work, and
detecting termination. We will explain each of
these aspects in the following sections. Note
that step 6 and 7 are protected by a lock.
This ensures that no two threads can execute
this code simultaneously. This is necessary
because Step 6 and 7 write to variables that
are shared amongst threads. The overhead
incurred by this synchronization is minimal,
as a thread typically iterates over this part
only a small number of times. This is because
the depth of the derivation graph of any edge
is limited (average 14, maximum 37 for the
fuse test set).
</bodyText>
<subsectionHeader confidence="0.998146">
3.3 Work Stealing
</subsectionHeader>
<bodyText confidence="0.999977534482759">
In the design as presented so far, each thread
exclusively executes the unification tasks on
its agenda. Obviously, this violates the re-
quirement that each unification task should
be scheduled dynamically.
In (Blumofe and Leiserson, 1993), it is
shown that for any multi-threaded compu-
tation with work Ti and task graph depth
T∞, and for any number P of processors, a
scheduling will achieve Tp ≤ T1/P +T∞ if for
the scheduling holds that whenever there are
more than P tasks ready, all P threads are
executing work. In other words, as long as
there is work on any queue, no thread should
be idle.
An effective technique to ensure the above
requirement is met is work stealing (Frigo et
al., 1998). With this technique, a thread will
first attempt to steal work from the queue
of another thread before denouncing itself to
be idle. If it succeeds, it will resume nor-
mal execution as if the stolen tasks were its
own. Work stealing incurs less synchroniza-
tion overhead than, for example, a centralized
work queue.
In our implementation, a thread becomes a
thief by calling STEAL, at step 4 of SCHED.
STEAL allows stealing from two types of
queues: the agendas, which contain outstand-
ing unification tasks, and the unchecked for-
eign edges, which resemble outstanding match
tasks between threads.
A thief first picks a random victim to steal
from. It first attempts to steal the victim’s
match tasks. If it succeeds, it will perform
the matches and put any resulting unification
tasks on its own agenda. If it cannot gain
exclusive access to the lists of unchecked for-
eign edges, or if there were no matches to be
performed, it will attempt to steal work from
the victim’s agenda. A thief will steal half of
the work on the agenda. This balances the
load between the two threads and minimizes
the chance that either thread will have to call
the expensive steal operation soon thereafter.
Note that idle threads will keep calling STEAL
until they either obtain new work or all other
threads become idle.
Obviously, stealing eliminates the exclusive
ownership of the agenda and unchecked for-
eign edge lists of the respective threads. As a
consequence, a thread needs to lock its agenda
and edge lists each time it needs to access
it. We use an asymmetric mutual exclusion
scheme, as presented in (Frigo et al., 1998), to
minimize the cost of locking for normal pro-
cessing and move more of the overhead to the
side of the thief.
</bodyText>
<subsectionHeader confidence="0.996033">
3.4 Preventing Duplicate Matches
</subsectionHeader>
<bodyText confidence="0.99985376">
When two matching edges are stored on the
charts of two different threads, it should be
prevented that both threads will perform the
corresponding match. Failing to do so can
cause the derivation of duplicate edges and
eventually a combinatorial explosion of work.
Our solution is based on a generation scheme.
Each newly derived edge is stamped with the
current generation of the respective thread,
threadGen (see step 2). In addition, a thread
will only perform the match for two edges if
the edge on its chart has a lower generation
than the foreign edge (see step 3). Obviously,
because the value of threadGen is unique for
the thread (see step 6), this scheme prevents
two edges from being matched twice.
SCHED also ensures that two matching
edges will always be matched by at least one
thread. After a thread completes step 3, it
will always raise its generation. The new gen-
eration will be greater than that of any for-
eign edge processed before. This ensures that
when an edge is put on the chart, no for-
eign edge with a higher generation has been
matched against the respective chart before.
</bodyText>
<subsectionHeader confidence="0.578089">
3.5 Termination
</subsectionHeader>
<bodyText confidence="0.999783838709677">
A thread may terminate when all work is com-
pleted, that is, if and only if the following
conditions hold simultaneously: all agendas
of all threads are empty, all possible matches
between edges have been processed, and all
threads are idle. Step 7 of SCHED enforces
that these conditions hold before any thread
leaves SCHED. Basically, each thread deter-
mines for itself whether its queues are empty
and raises the global counter NrThreadsIdle
accordingly. When all threads are idle simul-
taneously, the parser is finished.
A thread’s agenda is guaranteed to be
empty whenever newWork is false at step 7.
The same does not hold for the unchecked
foreign edges. Whenever a thread derives a
new edge, all other edges need to perform the
corresponding matches. The following mecha-
nism enforces this. The first thread to become
idle raises the global generation and records
it in IdleGen. Subsequent idle threads will
adopt this as their idle generation. When-
ever a thread derives a new edge, it will raise
Generation and reset NrThreadsIdle (step 6).
This invalidates IdleGen which implicitly re-
moves the idle status from all threads. Note
that step 7 lets each thread perform an addi-
tional iteration before raising NrThreadsIdle.
This allows a thread to check for foreign edges
that were derived after step 3 and before 7.
Once all work is done, detecting termination
</bodyText>
<table confidence="0.872311571428572">
P Tp (s) speedup
1 1599.8 1
2 817.5 1.96
3 578.2 2.77
4 455.9 3.51
5 390.3 4.10
6 338.0 4.73
</table>
<tableCaption confidence="0.875712666666667">
Table 2: Execution times for the fuse test
suite for various number of processors.
requires at most 2P synchronization steps.3
</tableCaption>
<subsectionHeader confidence="0.818708">
3.6 Implementation
</subsectionHeader>
<bodyText confidence="0.999985523809524">
The implementation of the system con-
sists of two parts: MACAMBA and CaLi.
MACAMBA stands for Multi-threading Ar-
chitecture for Chart And Memoization-Based
Applications. The MACAMBA framework
provides a set of objects that implement the
scheduling technique presented in the previ-
ous section. It also includes a set of sup-
port objects like charts and a thread-safe uni-
fication algorithm. CaLi is an instance of a
MACAMBA application that implements a
Chart parser for the LinGO grammar. The
design of CaLi was based on PET (Callmeier,
2000), one of the fastest parsers for LinGO.
It implements the quick check (Malouf et al.,
2000), which, together with the rule check,
takes care of filtering over 90% of the failing
unification tasks before they are put on the
agenda. MACAMBA and CaLi were both im-
plemented in Objective-C and currently run
on Windows NT, Linux, and Solaris.
</bodyText>
<sectionHeader confidence="0.983021" genericHeader="method">
4 Performance Results
</sectionHeader>
<bodyText confidence="0.999494">
The performance of the sequential version of
CaLi is comparable to that of PET.4 In ad-
dition, for the single-processor parallel ver-
sion of CaLi the total overhead incurred by
scheduling is less than 1%.
The first set of experiments consisted of
running the fuse test suite on a SUN Ultra
Enterprise with 8 nodes, each with a 400 MHz
</bodyText>
<footnote confidence="0.953188666666667">
3No locking is required once a thread is idle.
4Respectively, 1231s and 1339s on a 500MHz P-III,
where both parsers used the same parsing schema.
</footnote>
<bodyText confidence="0.999791234042553">
UltraSparc processor, for a varying number of
processors. Table 2 shows the results of these
experiments.5 The execution times for each
parse are measured in wall clock time. The
time measurement of a parse is started be-
fore the first thread starts working and ends
only when all threads have stopped. The fuse
test suite contains a large number of small
sentences that are hard to parallelize. These
results indicate that deploying multiple pro-
cessors on all input sentences unconditionally
still gives a considerable overall speedup.
The second set of experiments were run on
a SUN Enterprise10000 with 64 250 MHz Ul-
traSparc II processors. To limit the amount of
data generated by the experiments, and to in-
crease the accuracy of the measurements, we
selected a subset of the sentences in the fuse
suite. The parser is able to parse many sen-
tences in the fuse suite in fewer than several
milliseconds. Measuring speedup is inaccu-
rate in these cases. We therefore eliminated
such sentences from the test suite. From the
remaining sentences we made a selection of
500 sentences of various lengths.
The results are shown in Figure 4. The fig-
ure includes a graph for the maximum, mini-
mum, and average speedup obtained over all
sentences. The maximum speedup of 31.4 is
obtained at 48 processors. The overall peak
is reached at 32 processors where the average
speedup is 17.3. One of the reasons for the
decline in speedup after 32 processors is the
overhead in the scheduling algorithm. Most
notably, the total number of top-level itera-
tions of ScHED increases for larger P. The
minimum speedups of around 1 are obtained
for, often small, sentences that contain too lit-
tle inherent parallelism to be parallelized ef-
fectively.
Figure 4 shows a graph of the parallel ef-
ficiency, which is defined as speedup divided
by the number of processors. The average ef-
ficiency remains close to 80% up till 16 pro-
cessors. Note that super linear speedup is
achieved with up to 12 processors, repeat-
edly for the same set of sentences. Super lin-
</bodyText>
<footnote confidence="0.998658">
5Because the system was shared with other users,
only 6 processors could be utilized.
</footnote>
<figureCaption confidence="0.891168">
Figure 4: Average, maximum, and minimum
speedup and parallel efficiency based on wall
clock time.
</figureCaption>
<bodyText confidence="0.99946625">
ear speedup can occur because increasing the
number of processors also reduces the amount
of data handled by each node. This reduces
the chance of cache misses.
</bodyText>
<sectionHeader confidence="0.999435" genericHeader="evaluation">
5 Related Work
</sectionHeader>
<bodyText confidence="0.999982083333334">
Parallel parsing for NLP has been researched
extensively. For example, Thompson (1994)
presented some implementations of parallel
chart parsers. Nijholt (1994) gives a more the-
oretical overview of parallel chart parsers. A
survey of parallel processing in NLP is given
by Adriaens and Hahn (1994).
Nevertheless, many of the presented solu-
tions either did not yield acceptable speedup
or were very specific to one application. Re-
cently, several NLP systems have been par-
allelized successfully. Pontelli et al. (1998)
show how two existing NLP applications were
successfully parallelized using the parallel
Prolog environment ACE. The disadvantage
of this approach, though, is that it can only
be applied to parsers developed in Prolog.
Manousopoulou et al. (1997) discuss a par-
allel parser generator based on the Eu-PAGE
system. This solution exploits coarse-grained
parallelism of the kind that is unusable for
many parsing applications, including our own
(see also G¨orz et. al. (1996)).
Nurkkala et al. (1994) presented a parallel
parser for the UPenn TAG grammar, imple-
mented on the nCUBE. Although their best
results were obtained with random grammars,
speedups for the English grammar were also
considerable.
Yoshida et. al. (Yoshida et al., 1999) pre-
sented a 2-phase parallel FB-LTAG parser,
where the operations on feature structures
are all performed in the second phase. The
speedup ranged up to 8.8 for 20 processors,
Parallelism is mainly thwarted by a lack of
parallelism in the first phase.
Finally, Ninomiya et al. (2001) developed
an agent-based parallel parser that achieves
speedups of up to 13.2. It is implemented
in ABCL/f and LiLFeS. They also provide a
generic solution that could be applied to many
parsers. The main difference with our system
is the distribution of work. This system uses
a tabular chart like distribution of matches
and a randomized distribution of unification
tasks. Experiments we conducted show that
the choice of distribution scheme can have a
significant influence on the cache utilization.
It should be mentioned, though, that it is
in general hard to compare the performance
of systems when different grammars are used.
On the scheduling side, our approach shows
close resemblance to the Cilk-5 system (Frigo
et al., 1998). It implements work stealing
using similar techniques. An important dif-
ference, though, is that our scheduler was
designed for chart parsers and tabular algo-
rithms in general. These types of applications
fall outside the class of applications that Cilk
is capable of handling efficiently.
</bodyText>
<sectionHeader confidence="0.999532" genericHeader="conclusions">
6 Conclusions
</sectionHeader>
<bodyText confidence="0.99997">
We showed that there is sufficient parallelism
in parsing computations and presented a par-
allel chart parser for LinGO that can effec-
tively exploit this parallelism by achieving
considerable speedups. Also, the presented
techniques do not rely on a particular parsing
schema or grammar formalism, and can there-
fore be useful for other parsing applications.
</bodyText>
<sectionHeader confidence="0.97036" genericHeader="acknowledgments">
Acknowledgements
</sectionHeader>
<bodyText confidence="0.9997698">
Thanks to Makino Takaki and Takashi Ni-
nomiya of the Department of Information Sci-
ence, University of Tokyo, for running the
1–64 processor experiments at their depart-
ment’s computer.
</bodyText>
<sectionHeader confidence="0.997604" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999796645454545">
[Adriaens and Hahn1994] Geert Adriaens and Udo
Hahn, editors. 1994. Parallel Natural Lan-
guage Processing. Ablex Publishing Corpora-
tion, Norwood, New Jersey.
[Blumofe and Leiserson1993] Robert D. Blumofe
and Charles E. Leiserson. 1993. Space-
efficient scheduling of multithreaded computa-
tions. In Proceedings of the Twenty-Fifth An-
nual ACM Symposium on the Theory of Com-
puting (STOC ’93), pages 362–371, San Diego,
CA, USA, May. Also submitted to SIAM Jour-
nal on Computing.
[Brent1974] Richard P. Brent. 1974. The paral-
lel evaluation of general arithmetic expressions.
Journal of the ACM, 21(2):201–206, April.
[Callmeier2000] Ulrich Callmeier. 2000. PET –
A platform for experimentation with efficient
HPSG. Natural Language Engineering, 6(1):1–
18.
[Caroll1994] John Caroll. 1994. Relating complex-
ity to practical performance in parsing with
wide-coverage unification grammars. In Proc.
of the 32nd Annual Meeting of the Association
for Computational Linguistics, pages 287–294,
Las Cruces, NM, June27–30.
[Copestake2000] Ann Copestake, 2000. The (new)
LKB system, version 5.2. from Stanford site.
[Frigo et al.1998] Matteo Frigo, Charles E. Leiser-
son, and Keigh H. Randall. 1998. The im-
plementation of the Cilk-5 multithreaded lan-
guage. ACM SIGPLAN Notices, 33(5):212–
223, May.
[G¨orz et al.1996] G¨unther G¨orz, Marcus Kesseler,
J¨org Spilker, and Hans Weber. 1996. Research
on architectures for integrated speech/language
systems in Verbmobil. In The 16th Interna-
tional Conference on Computational Linguis-
tics, volume 1, pages 484–489, Copenhagen,
Danmark, August5–9.
[Graham1969] R.L. Graham. 1969. Bounds on
multiprocessing timing anomalies. SIAM J.
Appl. Math., 17(2):416–429.
[Malouf et al.2000] Robert Malouf, John Carroll,
and Ann Copestake. 2000. Efficient feature
structure operations witout compilation. Natu-
ral Language Engineering, 6(1):1–18.
[Manousopoulou et al.1997] A.G. Manousopoulou,
G. Manis, P. Tsanakas, and G. Papakonstanti-
nou. 1997. Automatic generation of portable
parallel natural language parsers. In Proceed-
ings of the 9th Conference on Tools with Arti-
ficial Intelligence (ICTAI ’97), pages 174–177.
IEEE Computer Society Press.
[Markatos and LeBlanc1992] E. P. Markatos and
T. J. LeBlanc. 1992. Using processor affinity
in loop scheduling on shared-memory multipro-
cessors. In IEEE Computer Society. Technical
Committee on Computer Architecture, editor,
Proceedings, Supercomputing ’92: Minneapo-
lis, Minnesota, November 16-20, 1992, pages
104–113, 1109 Spring Street, Suite 300, Silver
Spring, MD 20910, USA. IEEE Computer So-
ciety Press.
[Nijholt1994] Anton Nijholt. 1994. Parallel ap-
proaches to context-free language parsing. In
Adriaens and Hahn (1994).
[Ninomiya et al.2001] Takashi Ninomiya, Kentaro
Torisawa, and Jun’ichi Tsujii. 2001. An agent-
based parallel HPSG parser for shared-memory
parallel machines. Journal of Natural Language
Processing, 8(1), January.
[Nurkkala and Kumar1994] Tom Nurkkala and
Vipin Kumar. 1994. A parallel parsing algo-
rithm for natural language using tree adjoining
grammar. In Howard Jay Siegel, editor, Pro-
ceedings of the 8th International Symposium
on Parallel Processing, pages 820–829, Los
Alamitos, CA, USA, April. IEEE Computer
Society Press.
[Oepen and Callmeier2000] Stephan Oepen and
Ulrich Callmeier. 2000. Measure for mea-
sure: Parser cross-fertilization. In Proceedings
sixth International Workshop on Parsing Tech-
nologies (IWPT’2000), pages 183–194, Trento,
Italy.
[Pontelli et al.1998] Enrico Pontelli, Gopal Gupta,
Janyce Wiebe, and David Farwell. 1998. Natu-
ral language multiprocessing: A case study. In
Proceedings of the 15th National Conference on
Artifical Intelligence (AAAI ’98), July.
[Thompson1994] Henry S. Thompson. 1994. Par-
allel parsers for context-free grammars–two ac-
tual implementations compared. In Adriaens
and Hahn (1994).
[Tomabechi1991] H. Tomabechi. 1991. Quasi-
destructive graph unifications. In Proceedings
of the 29th Annual Meeting of the ACL, Berke-
ley, CA.
[van Lohuizen2000] Marcel P. van Lohuizen.
2000. Memory-efficient and thread-safe quasi-
destructive graph unification. In Proceedings
of the 38th Meeting of the Association for
Computational Linguistics, Hong Kong, China.
[Yoshida et al.1999] Minoru Yoshida, Takashi Ni-
nomiya, Kentaro Torisawa, Takaki Makino, and
Jun’ichi Tsujii. 1999. Proceedings of efficient
FB-LTAG parser and its parallelization. In Pro-
ceedings of Pacific Association for Computa-
tional Linguistics ’99, pages 90–103, Waterloo,
Canada, August.
</reference>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.899010">
<title confidence="0.9859485">A Generic Approach to Parallel Chart Parsing with an Application to LinGO</title>
<author confidence="0.999827">Marcel van_Lohuizen</author>
<affiliation confidence="0.999495">Faculty of Information Technology and Systems Delft University of Technology</affiliation>
<address confidence="0.943794">Delft, The Netherlands</address>
<email confidence="0.997161">mpvl@acm.org</email>
<abstract confidence="0.998296466666666">Multi-processor systems are becoming more commonplace and affordable. Based on analyses of actual parsings, we argue that to exploit the capabilities of such machines, unification-based grammar parsers should distribute work at the level of individual unification operations. We present a generic approach to parallel chart parsing that meets this requirement, and show that an implementation of this technique for LinGO achieves considerable speedups.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<date>1994</date>
<booktitle>Parallel Natural Language Processing. Ablex Publishing Corporation,</booktitle>
<editor>Geert Adriaens and Udo Hahn, editors.</editor>
<location>Norwood, New Jersey.</location>
<marker>[Adriaens and Hahn1994]</marker>
<rawString>Geert Adriaens and Udo Hahn, editors. 1994. Parallel Natural Language Processing. Ablex Publishing Corporation, Norwood, New Jersey.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Robert D Blumofe</author>
<author>Charles E Leiserson</author>
</authors>
<title>Spaceefficient scheduling of multithreaded computations.</title>
<date>1993</date>
<booktitle>In Proceedings of the Twenty-Fifth Annual ACM Symposium on the Theory of Computing (STOC ’93),</booktitle>
<pages>362--371</pages>
<location>San Diego, CA, USA,</location>
<note>Also submitted to SIAM Journal on Computing.</note>
<marker>[Blumofe and Leiserson1993]</marker>
<rawString>Robert D. Blumofe and Charles E. Leiserson. 1993. Spaceefficient scheduling of multithreaded computations. In Proceedings of the Twenty-Fifth Annual ACM Symposium on the Theory of Computing (STOC ’93), pages 362–371, San Diego, CA, USA, May. Also submitted to SIAM Journal on Computing.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Richard P Brent</author>
</authors>
<title>The parallel evaluation of general arithmetic expressions.</title>
<date>1974</date>
<journal>Journal of the ACM,</journal>
<volume>21</volume>
<issue>2</issue>
<marker>[Brent1974]</marker>
<rawString>Richard P. Brent. 1974. The parallel evaluation of general arithmetic expressions. Journal of the ACM, 21(2):201–206, April.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ulrich Callmeier</author>
</authors>
<title>PET – A platform for experimentation with efficient HPSG.</title>
<date>2000</date>
<journal>Natural Language Engineering,</journal>
<volume>6</volume>
<issue>1</issue>
<pages>18</pages>
<marker>[Callmeier2000]</marker>
<rawString>Ulrich Callmeier. 2000. PET – A platform for experimentation with efficient HPSG. Natural Language Engineering, 6(1):1– 18.</rawString>
</citation>
<citation valid="true">
<authors>
<author>John Caroll</author>
</authors>
<title>Relating complexity to practical performance in parsing with wide-coverage unification grammars.</title>
<date>1994</date>
<booktitle>In Proc. of the 32nd Annual Meeting of the Association for Computational Linguistics,</booktitle>
<pages>287--294</pages>
<location>Las Cruces, NM, June27–30.</location>
<marker>[Caroll1994]</marker>
<rawString>John Caroll. 1994. Relating complexity to practical performance in parsing with wide-coverage unification grammars. In Proc. of the 32nd Annual Meeting of the Association for Computational Linguistics, pages 287–294, Las Cruces, NM, June27–30.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ann Copestake</author>
</authors>
<title>The (new) LKB system, version 5.2. from Stanford site.</title>
<date>2000</date>
<marker>[Copestake2000]</marker>
<rawString>Ann Copestake, 2000. The (new) LKB system, version 5.2. from Stanford site.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Matteo Frigo</author>
<author>Charles E Leiserson</author>
<author>Keigh H Randall</author>
</authors>
<title>The implementation of the Cilk-5 multithreaded language.</title>
<date>1998</date>
<journal>ACM SIGPLAN Notices,</journal>
<volume>33</volume>
<issue>5</issue>
<pages>223</pages>
<marker>[Frigo et al.1998]</marker>
<rawString>Matteo Frigo, Charles E. Leiserson, and Keigh H. Randall. 1998. The implementation of the Cilk-5 multithreaded language. ACM SIGPLAN Notices, 33(5):212– 223, May.</rawString>
</citation>
<citation valid="true">
<authors>
<author>G¨unther G¨orz</author>
<author>Marcus Kesseler</author>
<author>J¨org Spilker</author>
<author>Hans Weber</author>
</authors>
<title>Research on architectures for integrated speech/language systems in Verbmobil.</title>
<date>1996</date>
<booktitle>In The 16th International Conference on Computational Linguistics,</booktitle>
<volume>1</volume>
<pages>484--489</pages>
<location>Copenhagen, Danmark, August5–9.</location>
<marker>[G¨orz et al.1996]</marker>
<rawString>G¨unther G¨orz, Marcus Kesseler, J¨org Spilker, and Hans Weber. 1996. Research on architectures for integrated speech/language systems in Verbmobil. In The 16th International Conference on Computational Linguistics, volume 1, pages 484–489, Copenhagen, Danmark, August5–9.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R L Graham</author>
</authors>
<title>Bounds on multiprocessing timing anomalies.</title>
<date>1969</date>
<journal>SIAM J. Appl. Math.,</journal>
<volume>17</volume>
<issue>2</issue>
<marker>[Graham1969]</marker>
<rawString>R.L. Graham. 1969. Bounds on multiprocessing timing anomalies. SIAM J. Appl. Math., 17(2):416–429.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Robert Malouf</author>
<author>John Carroll</author>
<author>Ann Copestake</author>
</authors>
<title>Efficient feature structure operations witout compilation.</title>
<date>2000</date>
<journal>Natural Language Engineering,</journal>
<volume>6</volume>
<issue>1</issue>
<marker>[Malouf et al.2000]</marker>
<rawString>Robert Malouf, John Carroll, and Ann Copestake. 2000. Efficient feature structure operations witout compilation. Natural Language Engineering, 6(1):1–18.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A G Manousopoulou</author>
<author>G Manis</author>
<author>P Tsanakas</author>
<author>G Papakonstantinou</author>
</authors>
<title>Automatic generation of portable parallel natural language parsers.</title>
<date>1997</date>
<booktitle>In Proceedings of the 9th Conference on Tools with Artificial Intelligence (ICTAI ’97),</booktitle>
<pages>174--177</pages>
<publisher>IEEE Computer Society Press.</publisher>
<marker>[Manousopoulou et al.1997]</marker>
<rawString>A.G. Manousopoulou, G. Manis, P. Tsanakas, and G. Papakonstantinou. 1997. Automatic generation of portable parallel natural language parsers. In Proceedings of the 9th Conference on Tools with Artificial Intelligence (ICTAI ’97), pages 174–177. IEEE Computer Society Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>E P Markatos</author>
<author>T J LeBlanc</author>
</authors>
<title>Using processor affinity in loop scheduling on shared-memory multiprocessors.</title>
<date>1992</date>
<booktitle>In IEEE Computer Society. Technical Committee on Computer Architecture, editor, Proceedings, Supercomputing ’92:</booktitle>
<pages>104--113</pages>
<publisher>IEEE Computer Society Press.</publisher>
<location>Minneapolis, Minnesota,</location>
<marker>[Markatos and LeBlanc1992]</marker>
<rawString>E. P. Markatos and T. J. LeBlanc. 1992. Using processor affinity in loop scheduling on shared-memory multiprocessors. In IEEE Computer Society. Technical Committee on Computer Architecture, editor, Proceedings, Supercomputing ’92: Minneapolis, Minnesota, November 16-20, 1992, pages 104–113, 1109 Spring Street, Suite 300, Silver Spring, MD 20910, USA. IEEE Computer Society Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Anton Nijholt</author>
</authors>
<title>Parallel approaches to context-free language parsing.</title>
<date>1994</date>
<booktitle>In Adriaens and Hahn</booktitle>
<marker>[Nijholt1994]</marker>
<rawString>Anton Nijholt. 1994. Parallel approaches to context-free language parsing. In Adriaens and Hahn (1994).</rawString>
</citation>
<citation valid="true">
<authors>
<author>Takashi Ninomiya</author>
<author>Kentaro Torisawa</author>
<author>Jun’ichi Tsujii</author>
</authors>
<title>An agentbased parallel HPSG parser for shared-memory parallel machines.</title>
<date>2001</date>
<journal>Journal of Natural Language Processing,</journal>
<volume>8</volume>
<issue>1</issue>
<marker>[Ninomiya et al.2001]</marker>
<rawString>Takashi Ninomiya, Kentaro Torisawa, and Jun’ichi Tsujii. 2001. An agentbased parallel HPSG parser for shared-memory parallel machines. Journal of Natural Language Processing, 8(1), January.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Tom Nurkkala</author>
<author>Vipin Kumar</author>
</authors>
<title>A parallel parsing algorithm for natural language using tree adjoining grammar. In</title>
<date>1994</date>
<booktitle>Proceedings of the 8th International Symposium on Parallel Processing,</booktitle>
<pages>820--829</pages>
<editor>Howard Jay Siegel, editor,</editor>
<publisher>IEEE Computer Society Press.</publisher>
<location>Los Alamitos, CA, USA,</location>
<marker>[Nurkkala and Kumar1994]</marker>
<rawString>Tom Nurkkala and Vipin Kumar. 1994. A parallel parsing algorithm for natural language using tree adjoining grammar. In Howard Jay Siegel, editor, Proceedings of the 8th International Symposium on Parallel Processing, pages 820–829, Los Alamitos, CA, USA, April. IEEE Computer Society Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Stephan Oepen</author>
<author>Ulrich Callmeier</author>
</authors>
<title>Measure for measure: Parser cross-fertilization.</title>
<date>2000</date>
<booktitle>In Proceedings sixth International Workshop on Parsing Technologies (IWPT’2000),</booktitle>
<pages>183--194</pages>
<location>Trento, Italy.</location>
<marker>[Oepen and Callmeier2000]</marker>
<rawString>Stephan Oepen and Ulrich Callmeier. 2000. Measure for measure: Parser cross-fertilization. In Proceedings sixth International Workshop on Parsing Technologies (IWPT’2000), pages 183–194, Trento, Italy.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Enrico Pontelli</author>
<author>Gopal Gupta</author>
<author>Janyce Wiebe</author>
<author>David Farwell</author>
</authors>
<title>Natural language multiprocessing: A case study.</title>
<date>1998</date>
<booktitle>In Proceedings of the 15th National Conference on Artifical Intelligence (AAAI ’98),</booktitle>
<marker>[Pontelli et al.1998]</marker>
<rawString>Enrico Pontelli, Gopal Gupta, Janyce Wiebe, and David Farwell. 1998. Natural language multiprocessing: A case study. In Proceedings of the 15th National Conference on Artifical Intelligence (AAAI ’98), July.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Henry S Thompson</author>
</authors>
<title>Parallel parsers for context-free grammars–two actual implementations compared.</title>
<date>1994</date>
<booktitle>In Adriaens and Hahn</booktitle>
<marker>[Thompson1994]</marker>
<rawString>Henry S. Thompson. 1994. Parallel parsers for context-free grammars–two actual implementations compared. In Adriaens and Hahn (1994).</rawString>
</citation>
<citation valid="true">
<authors>
<author>H Tomabechi</author>
</authors>
<title>Quasidestructive graph unifications.</title>
<date>1991</date>
<booktitle>In Proceedings of the 29th Annual Meeting of the ACL,</booktitle>
<location>Berkeley, CA.</location>
<marker>[Tomabechi1991]</marker>
<rawString>H. Tomabechi. 1991. Quasidestructive graph unifications. In Proceedings of the 29th Annual Meeting of the ACL, Berkeley, CA.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Marcel P van Lohuizen</author>
</authors>
<title>Memory-efficient and thread-safe quasidestructive graph unification.</title>
<date>2000</date>
<booktitle>In Proceedings of the 38th Meeting of the Association for Computational Linguistics,</booktitle>
<location>Hong Kong, China.</location>
<marker>[van Lohuizen2000]</marker>
<rawString>Marcel P. van Lohuizen. 2000. Memory-efficient and thread-safe quasidestructive graph unification. In Proceedings of the 38th Meeting of the Association for Computational Linguistics, Hong Kong, China.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Minoru Yoshida</author>
<author>Takashi Ninomiya</author>
<author>Kentaro Torisawa</author>
<author>Takaki Makino</author>
<author>Jun’ichi Tsujii</author>
</authors>
<title>and its parallelization.</title>
<date>1999</date>
<booktitle>Proceedings of efficient FB-LTAG parser</booktitle>
<pages>90--103</pages>
<location>Waterloo, Canada,</location>
<marker>[Yoshida et al.1999]</marker>
<rawString>Minoru Yoshida, Takashi Ninomiya, Kentaro Torisawa, Takaki Makino, and Jun’ichi Tsujii. 1999. Proceedings of efficient FB-LTAG parser and its parallelization. In Proceedings of Pacific Association for Computational Linguistics ’99, pages 90–103, Waterloo, Canada, August.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>