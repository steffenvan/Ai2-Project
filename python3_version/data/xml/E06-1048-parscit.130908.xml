<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000167">
<title confidence="0.9989745">
Unifying Synchronous Tree-Adjoining Grammars and
Tree Transducers via Bimorphisms
</title>
<author confidence="0.883406">
Stuart M. Shieber
</author>
<affiliation confidence="0.855438">
Division of Engineering and Applied Sciences
Harvard University
</affiliation>
<address confidence="0.930278">
Cambridge, MA, USA
</address>
<email confidence="0.99939">
shieber@deas.harvard.edu
</email>
<sectionHeader confidence="0.996669" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999949451612903">
We place synchronous tree-adjoining
grammars and tree transducers in the
single overarching framework of bimor-
phisms, continuing the unification of
synchronous grammars and tree transduc-
ers initiated by Shieber (2004). Along the
way, we present a new definition of the
tree-adjoining grammar derivation relation
based on a novel direct inter-reduction of
TAG and monadic macro tree transducers.
Tree transformation systems such as tree trans-
ducers and synchronous grammars have seen re-
newed interest, based on a perceived relevance
to new applications, such as importing syntactic
structure into statistical machine translation mod-
els or founding a formalism for speech command
and control.
The exact relationship among a variety of for-
malisms has been unclear, with a large number
of seemingly unrelated formalisms being inde-
pendently proposed or characterized. An initial
step toward unifying the formalisms was taken
(Shieber, 2004) in making use of the formal-
language-theoretic device of bimorphisms, previ-
ously used to characterize the tree relations defin-
able by tree transducers. In particular, the tree re-
lations definable by synchronous tree-substitution
grammars (STSG) were shown to be just those de-
finable by linear complete bimorphisms, thereby
providing for the first time a clear relationship be-
tween synchronous grammars and tree transduc-
ers.
In this work, we show how the bimorphism
framework can be used to capture a more powerful
formalism, synchronous tree-adjoining grammars,
providing a further uniting of the various and dis-
parate formalisms.
After some preliminaries (Section 1), we be-
gin by recalling the definition of tree-adjoining
grammars and synchronous tree-adjoining gram-
mars (Section 2). We turn then to a set of known
results relating context-free languages, tree homo-
morphisms, tree automata, and tree transducers
to extend them for the tree-adjoining languages
(Section 3), presenting these in terms of restricted
kinds of functional programs over trees, using a
simple grammatical notation for describing the
programs. This allows us to easily express gener-
alizations of the notions: monadic macro tree ho-
momorphisms, automata, and transducers, which
bear (at least some of) the same interrelationships
that their traditional simpler counterparts do (Sec-
tion 4). Finally, we use this characterization to
place the synchronous TAG formalism in the bi-
morphism framework (Section 5), further unify-
ing tree transducers and other synchronous gram-
mar formalisms. We also, in passing, provide a
new characterization of the relation between TAG
derivation and derived trees, and a new simpler
and more direct proof of the equivalence of TALs
and the output languages of monadic macro tree
transducers.
</bodyText>
<sectionHeader confidence="0.991369" genericHeader="keywords">
1 Preliminaries
</sectionHeader>
<bodyText confidence="0.999878461538461">
We will notate sequences with angle brackets, e.g.,
(a,b,c), or where no confusion results, simply as
abc, with the empty string written e.
Trees will have nodes labeled with elements of
a RANKED ALPHABET, a set of symbols T, each
with a non-negative integer RANK or ARITY as-
signed to it, determining the number of children
for nodes so labeled. To emphasize the arity of
a symbol, we will write it as a parenthesized su-
perscript, for instance f(n) for a symbol f of ar-
ity n. Analogously, we write T(n) for the set of
symbols in T with arity n. Symbols with arity
zero (T(0)) are called NULLARY symbols or CON-
</bodyText>
<page confidence="0.995764">
377
</page>
<bodyText confidence="0.982666444444444">
STANTS. The set of nonconstants is written F(≥1).
To express incomplete trees, trees with “holes”
waiting to be filled, we will allow leaves to be la-
beled with variables, in addition to nullary sym-
bols. The set of TREES OVER A RANKED AL-
PHABET F AND VARIABLES X, notated T(F,X),
is the smallest set such that (i) f ∈ T(F,X) for
all f ∈ F(0); (ii) x ∈ T(F,X) for all x ∈ X; and
(iii) f (t1,...,tn) ∈ T(F,X) for all f ∈ F(≥1), and
t1,...,tn ∈ T(F,X). We abbreviate T(F, /0), where
the set of variables is empty, as T(F), the set
of GROUND TREES over F. We will also make
use of the set of n numerically ordered variables
Xn = {x1,...,xn}, and write x, y, z as synonyms
for x1, x2, x3, respectively.
Trees can also be viewed as mappings from
TREE ADDRESSES, sequences of integers, to the
labels of nodes at those addresses. The address E
is the address of the root, 1 the address of the first
child, 12 the address of the second child of the first
child, and so forth. We will use the notation t/p to
pick out the subtree of the node at address p in the
tree t. Replacing the subtree of t at address p by
a tree t0, written t[p 7→ t0] is defined as (using · for
the insertion of an element on a list)
The HEIGHT of a tree t, notated height(t), is de-
fined as follows: height(x) = 0 for all x ∈ X and
height(f (t1,...,tn)) = 1+maxni=1 height(ti) for all
f ∈ F.
We can use trees with variables as CONTEXTS
in which to place other trees. A tree in T(F,Xn)
will be called a context, typically denoted with the
symbol C. For a context C ∈ T(F,Xn) and a se-
quence of n trees t1,...,tn ∈ T(F), the SUBSTITU-
TION OF t1,...,tn INTO C, notated C[t1,...,tn], is
defined inductively as follows:
</bodyText>
<equation confidence="0.553147333333333">
(f(u1,...,um))[t1,...,tn]
= f(u1[t1,...,tn],...,um[t1,...,tn])
xi[t1,...,tn]=ti .
</equation>
<bodyText confidence="0.987275625">
A tree t ∈ T(F,X) is LINEAR if and only if no
variable in X occurs more than once in t.
We will use a notation akin to BNF to specify
equations defining functional programs of various
sorts. As an introduction to the notation we will
use, here is a grammar defining trees over a ranked
alphabet and variables (essentially identically to
the definition given above):
</bodyText>
<equation confidence="0.98436725">
f (n) ∈ F(n)
x ∈ X ::= x0  |x1  |x2 |···
t ∈ T(F,X) ::= f (m)(t1,...,tm)
|x
</equation>
<bodyText confidence="0.9999053125">
The notation allows definition of classes of ex-
pressions (e.g., F(n)) and specifies metavariables
over them (f (n)). These classes can be primitive
(F(n)) or defined (X), even inductively in terms
of other classes or themselves (T(F,X)). We use
the metavariables and subscripted variants on the
right-hand side to represent an arbitrary element
of the corresponding class. Thus, the elements
t1,...,tm stand for arbitrary trees in T(F,X), and
x an arbitrary variable in X. Because numerically
subscripted versions of x appear explicitly on the
right hand side of the rule defining variables, nu-
merically subscripted variables (e.g., x1) on the
right-hand side of all rules are taken to refer to
the specific elements of x, whereas otherwise sub-
scripted elements (e.g., xi) are taken generically.
</bodyText>
<sectionHeader confidence="0.97909" genericHeader="introduction">
2 Tree-Adjoining Grammars
</sectionHeader>
<bodyText confidence="0.999955172413793">
Tree adjoining grammar (TAG) is a tree gram-
mar formalism distinguished by its use of a tree
adjunction operation. Traditional presentations
of TAG, which we will assume familiarity with,
take the symbols in elementary and derived trees
to be unranked; nodes labeled with a given non-
terminal symbol may have differing numbers of
children. (Joshi and Schabes (1997) present a
good overview.) For example, foot nodes of aux-
iliary trees and substitution nodes have no chil-
dren, whereas the similarly labeled root nodes
must have at least one. Similarly, two nodes with
the same label but differing numbers of children
may match for the purpose of allowing an ad-
junction (as the root nodes of a1 and b1 in Fig-
ure 1). In order to integrate TAG with tree trans-
ducers, however, we move to a ranked alphabet,
which presents some problems and opportunities.
(In some ways, the ranked alphabet definition of
TAGs is slightly more elegant than the traditional
one.) Although the bulk of the later discussion
integrating TAGs and transducers assumes (with-
out loss of expressivity (Joshi and Schabes, 1997,
fn. 6)) a limited form of TAG that includes adjunc-
tion but not substitution, we define the more com-
plete form here.
We will thus take the nodes of TAG trees to be
labeled with symbols from a ranked alphabet F;
a given symbol then has a fixed arity and a fixed
</bodyText>
<equation confidence="0.991298666666667">
t[E 7→ t0] = t0
f(t1,...,tn)[(i· p) 7→ t0] =
f(t1,...,ti[p 7→ t0],...,tn) for 1 ≤ i ≤ n .
</equation>
<page confidence="0.997352">
378
</page>
<figureCaption confidence="0.83993825">
Figure 1: Sample TAG for the copy language
{wcw  |w ∈ {a,b}∗ }.
Figure 2: Sample core-restricted TAG for the copy
language {wcw  |w ∈ {a,b}∗ }.
</figureCaption>
<figure confidence="0.99772225">
α1 : S α2 : T β1 : Se β2 : SO
C a S
S∗
b S
a S∗
T↓
b
β1 :
S0 β2 : SO
S*
a
c
b
S*
α1 : 1
εS : S*
S
T
a 1S
b 1S
</figure>
<bodyText confidence="0.999108">
number of children. However, in order to main-
tain information about which symbols may match
for the purpose of adjunction and substitution, we
take the elements of F to be explicitly formed as
pairs of an unranked label e and an arity n. (For
notational consistency, we will use e for unranked
and f for ranked symbols.) We will notate these
elements, abusing notation, as e(n), and make use
of a function |· |to unrank symbols in F, so that
|e(n) |= e.
To handle foot nodes, for each non-nullary sym-
bol e(i) ∈F(≥1), we will associate a new nullary
symbol e∗, which one can take to be the pair of e
and ∗; the set of such symbols will be notated F∗.
Similarly, for substitution nodes, F↓ will be the set
of nullary symbols e↓ for all e(i) ∈F(≥1). These
additional symbols, since they are nullary, will
necessarily appear only at the frontier of trees. Fi-
nally, to allow null adjoining constraints, for each
f ∈ F(i), we introduce a symbol f/0 also of arity i,
and take F/0 to be the set of all such symbols. We
will extend the function |· |to provide the unranked
symbol associated with these symbols as well, so
|e↓ |= |e∗ |= |e(i) /0 |= e.
A TAG is then a quadruple hF,S,I,Ai, where F
is a ranked alphabet; S ∈ F is a distinguished initial
symbol; I is the set of initial trees, a finite subset of
T(F∪ F/0 ∪ F↓); and A is the set of auxiliary trees,
a finite subset of T(F∪F/0 ∪F↓ ∪F∗). An auxiliary
tree β whose root is labeled f must have exactly
one node labeled with |f |∗ ∈ F∗ and no other nodes
labeled in F∗; this node is its foot node, its address
notated foot(β). In Figure 1, α1 and α2 are initial
trees; β1 and β2 are auxiliary trees.
In order to allow reference to a particular tree in
the set P, we associate with each tree in P a unique
index, conventionally notated with a subscripted
α or β for initial and auxiliary trees respectively.
This further allows us to have multiple instances
of a tree in I or A, distinguished by their index.
(We will abuse notation by using the index and the
tree that it names interchangably.)
The trees are combined by two operations, sub-
stitution and adjunction. Under substitution, a
node labeled e↓ (at address p) in a tree α can
be replaced by an initial tree α0 with the corre-
sponding label f at the root when |f  |= e. The
resulting tree, the substitution of α0 at p in α, is
α[p 7→ α0]. Under adjunction, an internal node of
α at p labeled f ∈ F is split apart, replaced by
an auxiliary tree β rooted in f0 when |f  |=  |f0|.
The resulting tree, the adjunction of β at p in α,
is α[p 7→ β[foot(β) 7→ α/p]]. This definition (by
requiring f to be in F, not F∗ or F↓) maintains
the standard convention, without loss of expres-
sivity, that adjunction is disallowed at foot nodes
and substitution nodes.
The TAG in Figure 1 generates a tree set
whose yield is the non-context-free copy language
{wcw  |w ∈ {a,b}∗ }. The arities of the nodes are
suppressed, as they are clear from context.
A derivation tree D records the operations over
the elementary trees used to derive a given derived
tree. Each node in the derivation tree specifies
an elementary tree α, the node’s child subtrees Di
recording the derivations for trees that are adjoined
or substituted into that tree. A method is required
to record at which node in α the tree specified
by child subtree Di operates. For trees recording
derivations in context-free grammars, there are ex-
actly as many substitution operations as nontermi-
nals on the right-hand side of the rule used. Thus,
child order in the derivation tree can be used to
record the identity of the substitution node. But for
TAG trees, operations occur throughout the tree,
and some, namely adjunctions, can be optional, so
a simple convention using child order is not pos-
sible. Traditionally, the branches in the derivation
tree have been notated with the address of the node
in the parent tree at which the child node oper-
ates. Figure 4 presents a derivation tree (a) us-
ing this notation, along with the corresponding de-
rived tree (b) for the string abcab.
For simplicity below, we use a stripped down
TAG formalism, one that loses no expressivity in
weak generative capacity but is easier for analysis
purposes.
First, we make all adjunction obligatory, in the
</bodyText>
<page confidence="0.998078">
379
</page>
<figureCaption confidence="0.967812">
Figure 3: Sample TAG tree marked with diacritics
to show the permutation of operable nodes.
</figureCaption>
<bodyText confidence="0.999988545454546">
sense that if a node in a tree allows adjunction, an
adjunction must occur there. To get the effect of
optional adjunction, for instance at a node labeled
B, we add a vestigial tree of a single node εB = B*,
which has no adjunction sites and does not itself
modify any tree that it adjoins into. It thus founds
the recursive structure of derivations.
Second, now that it is determinate whether an
operation must occur at a node, the number of
children of a node in a derivation tree is deter-
mined by the elementary tree at that node; it is just
the number of adjunction or substitution nodes in
the tree, the OPERABLE NODES. All that is left
to determine is the mapping between child order
in the derivation tree and node in the elementary
tree labeling the parent, that is, a permutation π
on the operable nodes (or equivalently, their ad-
dresses), so that the i-th child of a node labeled α
in a derivation tree is taken to specify the tree that
operates at the node πi in α. This permutation can
be thought of as specified as part of the elemen-
tary tree itself. For example, the tree in Figure 3,
which requires operations at the nodes at addresses
ε, 12, and 2, may be associated with the permuta-
tion (12,2,ε). This permutation can be marked on
the tree itself with numeric diacritics i, as shown
in the figure.
Finally, as mentioned before, we eliminate sub-
stitution (Joshi and Schabes, 1997, fn. 6). With
these changes, the sample TAG grammar and
derivation tree of Figures 1 and 4(a) might be ex-
pressed with the core TAG grammar and deriva-
tion tree of Figures 2 and 4(c).
</bodyText>
<sectionHeader confidence="0.954045" genericHeader="method">
3 Tree Transducers, Homomorphisms,
and Automata
</sectionHeader>
<subsectionHeader confidence="0.999487">
3.1 Tree Transducers
</subsectionHeader>
<bodyText confidence="0.999824272727273">
Informally, a TREE TRANSDUCER is a function
from T(F) to T(G) defined such that the symbol
at the root ofthe input tree and a current state de-
termines an output context in which the recursive
images of the subtrees are placed. Formally, we
can define a transducer as a kind of functional pro-
gram, that is, a set of equations characterized by
the following grammar for equations Eqn. (The
set of states is conventionally notated Q, with
members notated q. One of the states is distin-
guished as the INITIAL STATE of the transducer.)1
</bodyText>
<equation confidence="0.99606425">
qEQ
f(n) E F(n)
g(n) E G(n)
xiEX ::= x0  |x1  |x2 |···
Eqn ::= q(f(n)(x1,...,xn)) = τ(n)
τ(n) E R(n) ::= g(m)(τ(n)
1 ,...,τ(n) m)
 |qj(xi) where 1 &lt; i &lt; n
</equation>
<bodyText confidence="0.998208666666667">
Intuitively speaking, the expressions in R(n) are
right-hand-side terms using variables limited to
the first n.
For example, the grammar allows definition of
the following set of equations defining a tree trans-
ducer:2
</bodyText>
<equation confidence="0.999957">
q(f(x)) = g(q�(x),q(x))
q(a) = a
q&apos;(f(x)) = f(q�(x))
q&apos;(a) = a
</equation>
<bodyText confidence="0.9803105">
This transducer allows for the following deriva-
tion:
</bodyText>
<equation confidence="0.985492">
q(f(f(a)) = g(q�(f(a),q(f(a))))
= g(f(q�(a)),g(q�(a),q(a)))
= g(f(a),g(a,a))
</equation>
<bodyText confidence="0.992106">
The relation defined by a tree transducer with
initial state q is {(t,u)  |q(t) = u}. By virtue of
nondeterminism in the equations, multiple equa-
tions for a given state q and symbol f, tree trans-
ducers define true relations rather than merely
functions.
TREE HOMOMORPHISMS are a subtype of tree
transducers, those with only a single state, hence
essentially stateless. Other subtypes of tree trans-
ducers can be defined by restricting the trees τ
</bodyText>
<tableCaption confidence="0.923182615384615">
1Strictly speaking, what we define here are nondetermin-
istic top-down tree transducers.
2Full definitions of tree transducers typically describe a
transducer in terms of a set of states, an input and output
ranked alphabet, and an initial state, in addition to the set of
transitions, that is, defining equations. We will leave off these
details, in the expectation that the sets of states and symbols
can be inferred from the equations, and the initial state de-
termined under a convention that it is the state defined in the
textually first equation.
Note also that we avail ourselves of consistent renaming
of the variables x1, x2, and so forth, where convenient for
readability.
</tableCaption>
<figure confidence="0.998339285714286">
A
3
a B↓ A∗
1 b
2
B0
B
</figure>
<page confidence="0.982575">
380
</page>
<bodyText confidence="0.9999054">
that form the right-hand sides of equations, the
elements of R(n) used. A transducer is LINEAR
if all such τ are linear; is COMPLETE if τ con-
tains every variable in Xn; is ε-FREE if τ E� Xn; is
SYMBOL-TO-SYMBOL if height(τ) = 1; and is a
DELABELING if τ is complete, linear, and symbol-
to-symbol.
Another subcase is TREE AUTOMATA, tree
transducers that compute a partial identity func-
tion; these are delabeling tree transducers that pre-
serve the label and the order of arguments. Be-
cause they compute only the identity function, tree
automata are of interest for their domains, not the
mappings they compute. Their domains define
tree languages, in particular, the so-called REGU-
</bodyText>
<sectionHeader confidence="0.762191" genericHeader="method">
LAR TREE LANGUAGES.
</sectionHeader>
<subsectionHeader confidence="0.9941115">
3.2 The Bimorphism Characterization of
Tree Transducers
</subsectionHeader>
<bodyText confidence="0.999973933333333">
Tree transducers can be characterized directly in
terms of equations defining a simple kind of func-
tional program, as above. There is an elegant alter-
native characterization of tree transducers in terms
of a constellation of elements of the various sub-
types of transducers — homomorphisms and au-
tomata — we have introduced, called a bimor-
phism.
A bimorphism is a triple (L,hi,ho), consisting
of a regular tree language L (or, equivalently, a
tree automaton) and two tree homomorphisms hi
and ho. The tree relation defined by a bimor-
phism is the set of tree pairs that are generable
from elements of the tree language by the homo-
morphisms, that is,
</bodyText>
<equation confidence="0.988134">
L((L,hi,ho)) = {(hi(t),ho(t))  |t E L} .
</equation>
<bodyText confidence="0.999439763157895">
We can limit attention to bimorphisms in which
the input or output homomorphisms are restricted
to a certain type, linear (L), complete (C), epsilon-
free (F), symbol-to-symbol (S), delabeling (D), or
unrestricted (M). We will write B(I,O) where I
and O characterize a subclass of homomorphisms
for the set of bimorphisms for which the input ho-
momorphism is in the subclass indicated by I and
the output homomorphism is in the subclass indi-
cated by O. Thus, B(D,M) is the set of bimor-
phisms for which the input homomorphism is a
delabeling but the output homomorphism can be
arbitrary.
The tree relations definable by tree transducers
turn out to be exactly this class B(D,M) (Comon
et al., 1997). The bimorphism notion thus allows
us to characterize the tree transductions purely in
terms of tree automata and tree homomorphisms.
We have shown (Shieber, 2004) that the tree
relations defined by synchronous tree-substitution
grammars were exactly the relations B(LC,LC).
Intuitively speaking, the tree language in such a
bimorphism represents the set of derivation trees
for the synchronous grammar, and each homomor-
phism represents the relation between the deriva-
tion tree and the derived tree for one of the pro-
jected tree-substitution grammars. The homomor-
phisms are linear and complete because the tree re-
lation between a tree-substitution grammar deriva-
tion tree and its associated derived tree is exactly
a linear complete tree homomorphism. To charac-
terize the tree relations defined by a synchronous
tree-adjoining grammar, it similary suffices to find
a simple homomorphism-like characterization of
the tree relation between TAG derivation trees and
derived trees. In Section 5 below, we show that
linear complete embedded tree homomorphisms,
which we introduce next, serve this purpose.
</bodyText>
<sectionHeader confidence="0.997515" genericHeader="method">
4 Embedded Tree Transducers
</sectionHeader>
<bodyText confidence="0.993629727272727">
Embedded tree transducers are a generalization
of tree transducers in which states are allowed
to take a single additional argument in a re-
stricted manner. They correspond to a restric-
tive subcase of macro tree transducers with one
recursion variable. We use the term “embed-
ded tree transducer” rather than the more cumber-
some “monadic macro tree transducer” for brevity
and by analogy with embedded pushdown au-
tomata (Schabes and Vijay-Shanker, 1990), an-
other automata-theoretic characterization of the
tree-adjoining languages.
We modify the grammar of transducer equations
to add an extra argument to each occurrence of a
state q. To highlight the special nature of the extra
argument, it is written in angle brackets before the
input tree argument. We uniformly use the other-
wise unused variable x0 for this argument in the
left-hand side, and add x0 as a possible right-hand
side itself. Finally, right-hand-side occurrences
of states may be passed an arbitrary further right-
hand-side tree in this argument.
</bodyText>
<equation confidence="0.99497">
qEQ
f(n) E F(n)
xi E X ::= x0  |x1  |x2  |(•
Eqn ::= q([x0])(f(n)(x1,...,xn)) = τ(n)
τ(n) E R(n) ::=f(m)(τ(n) 1 ,...,τ(n) m)
 |x0
 |qj�τ(n)
</equation>
<bodyText confidence="0.765547">
j )(xi) where 1 &lt; i &lt; n
</bodyText>
<page confidence="0.992768">
381
</page>
<bodyText confidence="0.999904777777778">
Embedded transducers are strictly more expres-
sive than traditional transducers, because the extra
argument allows unbounded communication be-
tween positions unboundedly distant in depth in
the output tree. For example, a simple embedded
transducer can compute the reversal of a string,
e.g., 1(2(2(nil))) reverses to 2(2(1(nil))). (This
is not computable by a traditional tree transducer.)
It is given by the following equations:
</bodyText>
<equation confidence="0.9999945">
rhi(x) = r0hnili(x) (1)
r0hx0i(nil) = x0
r0hx0i(1(x)) = r0h1(x0)i(x)
r0hx0i(2(x)) = r0h2(x0)i(x)
</equation>
<bodyText confidence="0.999977605263158">
This is, of course, just the normal accumulating
reverse functional program, expressed as an em-
bedded transducer. The additional power of em-
bedded transducers is, we will show in this sec-
tion, exactly what is needed to characterize the ad-
ditional power that TAGs represent over CFGs in
describing tree languages. In particular, we show
that the relation between a TAG derivation tree
and derived tree is characterized by a determinis-
tic linear complete embedded tree transducer (DL-
CETT).
The relation between tree-adjoining languages
and embedded tree transducers may be implicit in
a series of previous results in the formal-language
theory literature.3 For instance, Fujiyoshi and
Kasai (2000) show that linear, complete monadic
context-free tree grammars generate exactly the
tree-adjoining languages via a normal form for
spine grammars. Separately, the relation between
context-free tree grammars and macro tree trans-
ducers has been described, where the relation-
ship between the monadic variants of each is im-
plicit. Thus, taken together, an equivalence be-
tween the tree-adjoining languages and the im-
age languages of monadic macro tree transducers
might be pieced together. In the present work,
we define the relation between tree-adjoining lan-
guages and linear complete monadic tree trans-
ducers directly, simply, and transparently, by giv-
ing explicit constructions in both directions, care-
fully handling the distinction between the un-
ranked trees of tree-adjoining grammars and the
ranked trees of macro tree transducers and other
important issues of detail in the constructions.
The proof requires reductions in both directions.
First, we show that for any TAG we can construct
a DLCETT that specifies the tree relation between
the derivation trees for the TAG and the derived
</bodyText>
<subsectionHeader confidence="0.372303">
3We are indebted to Uwe M¨onnich for this observation.
</subsectionHeader>
<bodyText confidence="0.9950048">
trees. Then, we show that for any DLCETT we
can construct a TAG such that the tree relation be-
tween the derivation trees and derived trees is re-
lated through a simple homomorphism to the DL-
CETT tree relation.
</bodyText>
<subsectionHeader confidence="0.98612">
4.1 From TAG to Transducer
</subsectionHeader>
<bodyText confidence="0.999830666666667">
Given an elementary tree α with the label A at its
root, let the sequence π = hπ1,...,πni be a per-
mutation on the nodes in α at which adjunction
occurs. (We use this ordering by means of the dia-
critic representation below.) Then, if α is an aux-
iliary tree, construct the equation
</bodyText>
<equation confidence="0.938788333333333">
qAhx0i(α(x1,...,xn)) = bαc
and if α is an initial tree, construct the equation
qAhi(α(x1,...,xn)) = bαc
</equation>
<bodyText confidence="0.9952975">
where the right-hand-side transformation b·c is de-
fined by4
</bodyText>
<equation confidence="0.99020425">
bA/0(t1,...,tn)c = A(bt1c,...,btnc)
bk A(t1,...,tn)c = qAhbA/0(t1,...,tn)ci(xk)
bA∗c = x0
bac = a
</equation>
<bodyText confidence="0.998551818181818">
(2)
Note that the equations are linear and complete,
because each variable xi is generated once as the
tree α is traversed, namely at position πi in the
traversal (marked with i), and the variable x0 is
generated at the foot node only. Thus, the gener-
ated embedded tree transducer is linear and com-
plete. Because only one equation is generated per
tree, the transducer is trivially deterministic.
By way of example, we consider the core TAG
grammar given by the following trees:
</bodyText>
<equation confidence="0.999586666666667">
α : 1 A(e)
βA : A/0(1 B(a), 2 C(3 D(A∗)))
βB : 1 B(b,B∗)
εB : B∗
εC : C∗
εD : D∗
</equation>
<bodyText confidence="0.962792428571429">
4It may seem like trickery to use the diacritics in this way,
as they are not really components of the tree being traversed,
but merely reflexes of an extrinsic ordering. But their use is
benign. The same transformation can be defined, a bit more
cumbersomely, keeping the permutation π separate, by track-
ing the permutation and the current address p in a revised
transformation b·cπ,p defined as follows:
</bodyText>
<equation confidence="0.98887275">
bA/0(t1,...,tn)cπ,p = A(bt1cπ,p·1,...,btncπ,p·n)
bA(t1,...,tn)cπ,p = qAhbA/0(t1,...,tn)cπ,pi(xπ−1(p))
bA∗cπ,p = x0
bacπ,p = a
</equation>
<bodyText confidence="0.980472">
We then use bαcπ,ε for the transformation of the tree α.
</bodyText>
<page confidence="0.992373">
382
</page>
<figure confidence="0.856420333333333">
2
β2 εS
(a) (b) (c)
</figure>
<figureCaption confidence="0.999355">
Figure 4: Derivation and derived trees for the sam-
</figureCaption>
<bodyText confidence="0.9458542">
ple grammars: (a) derivation tree for the gram-
mar of Figure 1; (b) corresponding derived tree;
(c) corresponding derivation tree for the core TAG
version of the grammar in Figure 2.
Starting with the auxiliary tree βA =
A/0(1 B(a), 2 C(3 D(A∗))), the adjunction sites,
corresponding to the nodes labeled B, C, and D at
addresses 1, 2, and 21, have been arbitrarily given
a preorder permutation. We therefore construct
the equation as follows:
</bodyText>
<equation confidence="0.847196666666667">
qAhx0i(βA(x1,x2,x3)) I
= bA/0(1 B(a), 2 C(3 D(A∗)))J
= A(b1 B(a)c,b2 C(3 D(A∗))c)
= A(qBhbB/0(a)ci(x1),b2 C(3 D(A∗))c)
= A(qBhB(bac)i(x1),
= A(qBhB(a)i(x1),qChC(qDhD(x0)i(x3))i(x2))
</equation>
<bodyText confidence="0.9994335">
Similar derivations for the remaining trees yield
the (deterministic linear complete) embedded tree
transducer defined by the following set of equa-
tions:
</bodyText>
<equation confidence="0.999986857142857">
qAhi(α(x1)) = qAhA(e)i(x1)
qAhx0i(βA(x1,x2,x3)) =
A(qBhB(a)i(x1),qChC(qDhD(x0)i(x3))i(x2))
qBhx0i(βB(x1)) = qBhB(b,x0)i(x1)
qBhx0i(εB()) = x0
qChx0i(εC()) = x0
qDhx0i(εD()) = x0
</equation>
<bodyText confidence="0.999433">
We can use this transducer to compute the derived
tree for the derivation tree α(βA(βB(εB),εC,εD)).
</bodyText>
<equation confidence="0.926934333333333">
qAhi(α(βA(βB(εB),εC,εD)))
= qAhA(e)i(βA(βB(εB),εC,εD))
= A( qBhB(a)i(βB(εB)),
qChC(qDhD(A(e))i(εD))i(εC))
= A(qBhB(b,B(a))i(εB),C(qDhD(A(e))i(εD)))
= A(B(b,B(a)),C(D(A(e))))
</equation>
<bodyText confidence="0.999617">
As a final step, useful later for the bimor-
phism characterization of synchronous TAG, it is
straightforward to show that the transducer so con-
structed is the composition of a regular tree lan-
guage and a linear complete embedded tree homo-
morphism.
</bodyText>
<subsectionHeader confidence="0.989201">
4.2 From Transducer to TAG
</subsectionHeader>
<bodyText confidence="0.999924">
Given a linear complete embedded tree transducer,
we construct a corresponding TAG as follows: For
each rule of the form
</bodyText>
<equation confidence="0.98789">
qih[x0]i(f(m)(x1,...,xm)) = τ
</equation>
<bodyText confidence="0.998784090909091">
we build a tree named hqi, f,τi. Where this tree
appears is determined solely by the state qi, so
we take the root node of the tree to be the state.
Any foot node in the tree will also need to be
marked with the same label, so we pass this infor-
mation down as the tree is built inductively. The
tree is therefore of the form qi /0(dτei) where the
right-hand-side transformation d·ei constructs the
remainder of the tree by the inductive walk of τ,
with the subscript noting that the root is labeled
qi.
</bodyText>
<equation confidence="0.990323">
df(t1,...,tm)ei = f/0(dt1ei,...,dtmei)
dqjhτi(xk)ei = k qj(dτei)
dx0ei = qi∗
daei = a
</equation>
<bodyText confidence="0.999975208333333">
Note that at x0, a foot node is generated of the
proper label. (Because the equation is linear, only
one foot node is generated, and it is labeled ap-
propriately by construction.) Where recursive pro-
cessing of the input tree occurs (qjhτi(xl)), we
generate a tree that admits adjunctions at qj. The
role of the diacritic k is merely to specify the per-
mutation of operable nodes for interpreting deriva-
tion trees; it says that the k-th child in a derivation
tree rooted in the current elementary tree is taken
to specify adjunctions at this node.
The trees generated by this TAG are intended
to correspond to the outputs of the corresponding
tree transducer. Because of the more severe con-
straints on TAG, in particular that all combinato-
rial limitations on putting subtrees together must
be manifest in the labels in the trees themselves,
the outputs actually contain more structure than
the corresponding transducer output. In particu-
lar, the state-labeled nodes are merely for book-
keeping. A homomorphism removing these nodes
gives the desired transducer output. Most impor-
tantly, then, the weak generative capacity of TAGs
and LCETTs are identical.
</bodyText>
<figure confidence="0.999687666666667">
1 ε
b
S
α2
α1
b
α1
β1
β2
S
a
S
T
β1
S
a
S
b2 C(3 D(A∗))c)
</figure>
<page confidence="0.997692">
383
</page>
<bodyText confidence="0.999882833333333">
Some examples may clarify the construction.
Recall the reversal embedded transducer in (1)
above. The construction above generates a TAG
containing the following trees. We have given
them indicative names rather than the cumbersome
ones of the form (qi, f,i).
</bodyText>
<equation confidence="0.99798175">
/a� : r/0 (1 : r1(nil))
Nnil : r1 /0(r1*)
P1: r1 /0(1 : r1(1/0(r1*)))
/32 : r1 /0(1 : r1(2/0(r1*)))
</equation>
<bodyText confidence="0.951622">
It is simple to verify that the derivation tree
</bodyText>
<equation confidence="0.504473">
a(le1(1�2(1�2(Enil))))
derives the tree
r(r16(2(r1(2(r1(1(r1(nil))))))))
</equation>
<bodyText confidence="0.9994664">
Simple homomorphisms that extract the input
function symbols on the input and drop the book-
keeping states on the output reduce these trees to
1(2(2(nil))) and 2(2(1(nil))) respectively, just as
for the corresponding tree transducer.
</bodyText>
<sectionHeader confidence="0.949245" genericHeader="method">
5 Synchronous TAGs as Bimorphisms
</sectionHeader>
<bodyText confidence="0.999978340909091">
The major advantage of characterizing TAG
derivation in terms of tree transducers (via the
compilation (2)) is the integration of synchronous
TAGs into the bimorphism framework. A syn-
chronous TAG (Shieber, 1994) is composed of a
set of triples (tL,tR,_) where the two trees tL and
tR are elementary trees and _ is a set of links spec-
ifying pairs of linked operable nodes from tL and
tR. Without loss of generality, we can stipulate that
each operable node in each tree is impinged upon
by exactly one link in _. (If a node is unlinked,
the triple can never be used; if overlinked, a set
of replacement triples can be “multiplied out”.) In
this case, a projection of the triples on first or sec-
ond component, with a permutation defined by the
corresponding projections on the links, is exactly a
TAG as defined above. Thus, derivations proceed
just as in a single TAG except that nodes linked by
some link in _ are simultaneously operated on by
paired trees derived by the grammar.
In order to model a synchronous grammar for-
malism as a bimorphism, the well-formed deriva-
tions of the synchronous formalism must be char-
acterizable as a regular tree language and the rela-
tion between such derivation trees and each of the
paired derived trees as a homomorphism of some
sort. For synchronous tree-substitution grammars,
derivation trees are regular tree languages, and the
map from derivation to each of the paired derived
trees is a linear complete tree homomorphism.
Thus, synchronous tree-substitution grammars fall
in the class of bimorphisms B(LC,LC). The other
direction can be shown as well; all bimorphisms
in B(LC,LC) define tree relations expressible by
an STSG.
A similar result follows immediately for STAG.
Crucially relying on the result above that the
derivation relation is a DLCETT, we can use
the method of Shieber (2004) directly to char-
acterize the synchronous TAG tree relations as
just B(ELC,ELC). We have thus integrated syn-
chronous TAG with the other transducer and syn-
chronous grammar formalisms falling under the
bimorphism umbrella.
</bodyText>
<sectionHeader confidence="0.99797" genericHeader="acknowledgments">
Acknowledgements
</sectionHeader>
<bodyText confidence="0.9998268">
We wish to thank Mark Dras, Uwe M¨onnich, Re-
becca Nesson, James Rogers, and Ken Shan for
helpful discussions on the topic of this paper. This
work was supported in part by grant IIS-0329089
from the National Science Foundation.
</bodyText>
<sectionHeader confidence="0.998744" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999507576923077">
H. Comon, M. Dauchet, R. Gilleron, F. Jacquemard,
D. Lugiez, S. Tison, and M. Tommasi. 1997.
Tree automata techniques and applications. Avail-
able at: http://www.grappa.univ-lille3.fr/
tata. Release of October 1, 2002.
A. Fujiyoshi and T. Kasai. 2000. Spinal-formed
context-free tree grammars. Theory of Computing
Systems, 33:59–83.
Aravind Joshi and Yves Schabes. 1997. Tree-
adjoining grammars. In G. Rozenberg and A. Salo-
maa, editors, Handbook of Formal Languages, vol-
ume 3, pages 69–124. Springer, Berlin.
Yves Schabes and K. Vijay-Shanker. 1990. Determin-
istic left to right parsing of tree adjoining languages.
In Proceedings of the 28th Annual Meeting of the As-
sociation for Computational Linguistics, pages 276–
283, Pittsburgh, Pennsylvania, 6–9 June.
Stuart M. Shieber. 1994. Restricting the weak-
generative capacity of synchronous tree-adjoining
grammars. Computational Intelligence, 10(4):371–
385, November. Also available as cmp-lg/9404003.
Stuart M. Shieber. 2004. Synchronous grammars
as tree transducers. In Proceedings of the Seventh
International Workshop on Tree Adjoining Gram-
mar and Related Formalisms (TAG+7), pages 88–
95, Vancouver, Canada, May 20-22.
</reference>
<page confidence="0.998979">
384
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.597441">
<title confidence="0.998048">Unifying Synchronous Tree-Adjoining Grammars and Tree Transducers via Bimorphisms</title>
<author confidence="0.999993">Stuart M Shieber</author>
<affiliation confidence="0.999702">Division of Engineering and Applied Sciences Harvard University</affiliation>
<address confidence="0.999979">Cambridge, MA, USA</address>
<email confidence="0.999865">shieber@deas.harvard.edu</email>
<abstract confidence="0.996345837606838">We place synchronous tree-adjoining grammars and tree transducers in the single overarching framework of bimorphisms, continuing the unification of synchronous grammars and tree transducers initiated by Shieber (2004). Along the way, we present a new definition of the tree-adjoining grammar derivation relation based on a novel direct inter-reduction of TAG and monadic macro tree transducers. Tree transformation systems such as tree transducers and synchronous grammars have seen renewed interest, based on a perceived relevance to new applications, such as importing syntactic structure into statistical machine translation models or founding a formalism for speech command and control. The exact relationship among a variety of formalisms has been unclear, with a large number of seemingly unrelated formalisms being independently proposed or characterized. An initial step toward unifying the formalisms was taken (Shieber, 2004) in making use of the formallanguage-theoretic device of bimorphisms, previously used to characterize the tree relations definable by tree transducers. In particular, the tree relations definable by synchronous tree-substitution grammars (STSG) were shown to be just those definable by linear complete bimorphisms, thereby providing for the first time a clear relationship between synchronous grammars and tree transducers. In this work, we show how the bimorphism framework can be used to capture a more powerful formalism, synchronous tree-adjoining grammars, providing a further uniting of the various and disparate formalisms. After some preliminaries (Section 1), we begin by recalling the definition of tree-adjoining grammars and synchronous tree-adjoining grammars (Section 2). We turn then to a set of known results relating context-free languages, tree homomorphisms, tree automata, and tree transducers to extend them for the tree-adjoining languages (Section 3), presenting these in terms of restricted kinds of functional programs over trees, using a simple grammatical notation for describing the programs. This allows us to easily express generalizations of the notions: monadic macro tree homomorphisms, automata, and transducers, which bear (at least some of) the same interrelationships that their traditional simpler counterparts do (Section 4). Finally, we use this characterization to place the synchronous TAG formalism in the bimorphism framework (Section 5), further unifying tree transducers and other synchronous grammar formalisms. We also, in passing, provide a new characterization of the relation between TAG derivation and derived trees, and a new simpler and more direct proof of the equivalence of TALs and the output languages of monadic macro tree transducers. 1 Preliminaries We will notate sequences with angle brackets, e.g., or where no confusion results, simply as with the empty string written Trees will have nodes labeled with elements of a set of symbols each a non-negative integer assigned to it, determining the number of children for nodes so labeled. To emphasize the arity of a symbol, we will write it as a parenthesized sufor instance a symbol ar- Analogously, we write for the set of in arity Symbols with arity are called or 377 The set of nonconstants is written To express incomplete trees, trees with “holes” waiting to be filled, we will allow leaves to be labeled with variables, in addition to nullary sym- The set of OVER A RANKED VARIABLES notated the smallest set such that (i) (ii) all and all and ∈ We abbreviate where set of variables is empty, as the set TREES We will also make of the set of ordered variables = and write synonyms respectively. Trees can also be viewed as mappings from sequences of integers, to the of nodes at those addresses. The address is the address of the root, 1 the address of the first child, 12 the address of the second child of the first and so forth. We will use the notation out the subtree of the node at address the Replacing the subtree of address tree written defined as (using the insertion of an element on a list) a tree notated is deas follows: = for all = all can use trees with variables as which to place other trees. A tree in will be called a context, typically denoted with the For a context a seof ∈ the OF INTO notated is defined inductively as follows: tree and only if no in more than once in We will use a notation akin to BNF to specify equations defining functional programs of various</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>H Comon</author>
<author>M Dauchet</author>
<author>R Gilleron</author>
<author>F Jacquemard</author>
<author>D Lugiez</author>
<author>S Tison</author>
<author>M Tommasi</author>
</authors>
<title>Tree automata techniques and applications. Available at: http://www.grappa.univ-lille3.fr/ tata.</title>
<date>1997</date>
<journal>Release of October</journal>
<volume>1</volume>
<contexts>
<context position="18659" citStr="Comon et al., 1997" startWordPosition="3265" endWordPosition="3268">hisms are restricted to a certain type, linear (L), complete (C), epsilonfree (F), symbol-to-symbol (S), delabeling (D), or unrestricted (M). We will write B(I,O) where I and O characterize a subclass of homomorphisms for the set of bimorphisms for which the input homomorphism is in the subclass indicated by I and the output homomorphism is in the subclass indicated by O. Thus, B(D,M) is the set of bimorphisms for which the input homomorphism is a delabeling but the output homomorphism can be arbitrary. The tree relations definable by tree transducers turn out to be exactly this class B(D,M) (Comon et al., 1997). The bimorphism notion thus allows us to characterize the tree transductions purely in terms of tree automata and tree homomorphisms. We have shown (Shieber, 2004) that the tree relations defined by synchronous tree-substitution grammars were exactly the relations B(LC,LC). Intuitively speaking, the tree language in such a bimorphism represents the set of derivation trees for the synchronous grammar, and each homomorphism represents the relation between the derivation tree and the derived tree for one of the projected tree-substitution grammars. The homomorphisms are linear and complete becau</context>
</contexts>
<marker>Comon, Dauchet, Gilleron, Jacquemard, Lugiez, Tison, Tommasi, 1997</marker>
<rawString>H. Comon, M. Dauchet, R. Gilleron, F. Jacquemard, D. Lugiez, S. Tison, and M. Tommasi. 1997. Tree automata techniques and applications. Available at: http://www.grappa.univ-lille3.fr/ tata. Release of October 1, 2002.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Fujiyoshi</author>
<author>T Kasai</author>
</authors>
<title>Spinal-formed context-free tree grammars.</title>
<date>2000</date>
<journal>Theory of Computing Systems,</journal>
<pages>33--59</pages>
<contexts>
<context position="22186" citStr="Fujiyoshi and Kasai (2000)" startWordPosition="3812" endWordPosition="3815">rogram, expressed as an embedded transducer. The additional power of embedded transducers is, we will show in this section, exactly what is needed to characterize the additional power that TAGs represent over CFGs in describing tree languages. In particular, we show that the relation between a TAG derivation tree and derived tree is characterized by a deterministic linear complete embedded tree transducer (DLCETT). The relation between tree-adjoining languages and embedded tree transducers may be implicit in a series of previous results in the formal-language theory literature.3 For instance, Fujiyoshi and Kasai (2000) show that linear, complete monadic context-free tree grammars generate exactly the tree-adjoining languages via a normal form for spine grammars. Separately, the relation between context-free tree grammars and macro tree transducers has been described, where the relationship between the monadic variants of each is implicit. Thus, taken together, an equivalence between the tree-adjoining languages and the image languages of monadic macro tree transducers might be pieced together. In the present work, we define the relation between tree-adjoining languages and linear complete monadic tree trans</context>
</contexts>
<marker>Fujiyoshi, Kasai, 2000</marker>
<rawString>A. Fujiyoshi and T. Kasai. 2000. Spinal-formed context-free tree grammars. Theory of Computing Systems, 33:59–83.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Aravind Joshi</author>
<author>Yves Schabes</author>
</authors>
<title>Treeadjoining grammars.</title>
<date>1997</date>
<booktitle>Handbook of Formal Languages,</booktitle>
<volume>3</volume>
<pages>69--124</pages>
<editor>In G. Rozenberg and A. Salomaa, editors,</editor>
<publisher>Springer,</publisher>
<location>Berlin.</location>
<contexts>
<context position="6960" citStr="Joshi and Schabes (1997)" startWordPosition="1153" endWordPosition="1156">f the rule defining variables, numerically subscripted variables (e.g., x1) on the right-hand side of all rules are taken to refer to the specific elements of x, whereas otherwise subscripted elements (e.g., xi) are taken generically. 2 Tree-Adjoining Grammars Tree adjoining grammar (TAG) is a tree grammar formalism distinguished by its use of a tree adjunction operation. Traditional presentations of TAG, which we will assume familiarity with, take the symbols in elementary and derived trees to be unranked; nodes labeled with a given nonterminal symbol may have differing numbers of children. (Joshi and Schabes (1997) present a good overview.) For example, foot nodes of auxiliary trees and substitution nodes have no children, whereas the similarly labeled root nodes must have at least one. Similarly, two nodes with the same label but differing numbers of children may match for the purpose of allowing an adjunction (as the root nodes of a1 and b1 in Figure 1). In order to integrate TAG with tree transducers, however, we move to a ranked alphabet, which presents some problems and opportunities. (In some ways, the ranked alphabet definition of TAGs is slightly more elegant than the traditional one.) Although </context>
<context position="14022" citStr="Joshi and Schabes, 1997" startWordPosition="2474" endWordPosition="2477">s, a permutation π on the operable nodes (or equivalently, their addresses), so that the i-th child of a node labeled α in a derivation tree is taken to specify the tree that operates at the node πi in α. This permutation can be thought of as specified as part of the elementary tree itself. For example, the tree in Figure 3, which requires operations at the nodes at addresses ε, 12, and 2, may be associated with the permutation (12,2,ε). This permutation can be marked on the tree itself with numeric diacritics i, as shown in the figure. Finally, as mentioned before, we eliminate substitution (Joshi and Schabes, 1997, fn. 6). With these changes, the sample TAG grammar and derivation tree of Figures 1 and 4(a) might be expressed with the core TAG grammar and derivation tree of Figures 2 and 4(c). 3 Tree Transducers, Homomorphisms, and Automata 3.1 Tree Transducers Informally, a TREE TRANSDUCER is a function from T(F) to T(G) defined such that the symbol at the root ofthe input tree and a current state determines an output context in which the recursive images of the subtrees are placed. Formally, we can define a transducer as a kind of functional program, that is, a set of equations characterized by the fo</context>
</contexts>
<marker>Joshi, Schabes, 1997</marker>
<rawString>Aravind Joshi and Yves Schabes. 1997. Treeadjoining grammars. In G. Rozenberg and A. Salomaa, editors, Handbook of Formal Languages, volume 3, pages 69–124. Springer, Berlin.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Yves Schabes</author>
<author>K Vijay-Shanker</author>
</authors>
<title>Deterministic left to right parsing of tree adjoining languages.</title>
<date>1990</date>
<booktitle>In Proceedings of the 28th Annual Meeting of the Association for Computational Linguistics,</booktitle>
<pages>276--283</pages>
<location>Pittsburgh, Pennsylvania, 6–9</location>
<contexts>
<context position="20240" citStr="Schabes and Vijay-Shanker, 1990" startWordPosition="3505" endWordPosition="3508">tion trees and derived trees. In Section 5 below, we show that linear complete embedded tree homomorphisms, which we introduce next, serve this purpose. 4 Embedded Tree Transducers Embedded tree transducers are a generalization of tree transducers in which states are allowed to take a single additional argument in a restricted manner. They correspond to a restrictive subcase of macro tree transducers with one recursion variable. We use the term “embedded tree transducer” rather than the more cumbersome “monadic macro tree transducer” for brevity and by analogy with embedded pushdown automata (Schabes and Vijay-Shanker, 1990), another automata-theoretic characterization of the tree-adjoining languages. We modify the grammar of transducer equations to add an extra argument to each occurrence of a state q. To highlight the special nature of the extra argument, it is written in angle brackets before the input tree argument. We uniformly use the otherwise unused variable x0 for this argument in the left-hand side, and add x0 as a possible right-hand side itself. Finally, right-hand-side occurrences of states may be passed an arbitrary further righthand-side tree in this argument. qEQ f(n) E F(n) xi E X ::= x0 |x1 |x2 </context>
</contexts>
<marker>Schabes, Vijay-Shanker, 1990</marker>
<rawString>Yves Schabes and K. Vijay-Shanker. 1990. Deterministic left to right parsing of tree adjoining languages. In Proceedings of the 28th Annual Meeting of the Association for Computational Linguistics, pages 276– 283, Pittsburgh, Pennsylvania, 6–9 June.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Stuart M Shieber</author>
</authors>
<title>Restricting the weakgenerative capacity of synchronous tree-adjoining grammars.</title>
<date>1994</date>
<journal>Computational Intelligence,</journal>
<volume>10</volume>
<issue>4</issue>
<pages>385</pages>
<note>Also available as cmp-lg/9404003.</note>
<contexts>
<context position="29749" citStr="Shieber, 1994" startWordPosition="5040" endWordPosition="5041"> r1(2/0(r1*))) It is simple to verify that the derivation tree a(le1(1�2(1�2(Enil)))) derives the tree r(r16(2(r1(2(r1(1(r1(nil)))))))) Simple homomorphisms that extract the input function symbols on the input and drop the bookkeeping states on the output reduce these trees to 1(2(2(nil))) and 2(2(1(nil))) respectively, just as for the corresponding tree transducer. 5 Synchronous TAGs as Bimorphisms The major advantage of characterizing TAG derivation in terms of tree transducers (via the compilation (2)) is the integration of synchronous TAGs into the bimorphism framework. A synchronous TAG (Shieber, 1994) is composed of a set of triples (tL,tR,_) where the two trees tL and tR are elementary trees and _ is a set of links specifying pairs of linked operable nodes from tL and tR. Without loss of generality, we can stipulate that each operable node in each tree is impinged upon by exactly one link in _. (If a node is unlinked, the triple can never be used; if overlinked, a set of replacement triples can be “multiplied out”.) In this case, a projection of the triples on first or second component, with a permutation defined by the corresponding projections on the links, is exactly a TAG as defined a</context>
</contexts>
<marker>Shieber, 1994</marker>
<rawString>Stuart M. Shieber. 1994. Restricting the weakgenerative capacity of synchronous tree-adjoining grammars. Computational Intelligence, 10(4):371– 385, November. Also available as cmp-lg/9404003.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Stuart M Shieber</author>
</authors>
<title>Synchronous grammars as tree transducers.</title>
<date>2004</date>
<booktitle>In Proceedings of the Seventh International Workshop on Tree Adjoining Grammar and Related Formalisms (TAG+7),</booktitle>
<pages>88--95</pages>
<location>Vancouver, Canada,</location>
<contexts>
<context position="1152" citStr="Shieber, 2004" startWordPosition="161" endWordPosition="162">a novel direct inter-reduction of TAG and monadic macro tree transducers. Tree transformation systems such as tree transducers and synchronous grammars have seen renewed interest, based on a perceived relevance to new applications, such as importing syntactic structure into statistical machine translation models or founding a formalism for speech command and control. The exact relationship among a variety of formalisms has been unclear, with a large number of seemingly unrelated formalisms being independently proposed or characterized. An initial step toward unifying the formalisms was taken (Shieber, 2004) in making use of the formallanguage-theoretic device of bimorphisms, previously used to characterize the tree relations definable by tree transducers. In particular, the tree relations definable by synchronous tree-substitution grammars (STSG) were shown to be just those definable by linear complete bimorphisms, thereby providing for the first time a clear relationship between synchronous grammars and tree transducers. In this work, we show how the bimorphism framework can be used to capture a more powerful formalism, synchronous tree-adjoining grammars, providing a further uniting of the var</context>
<context position="18823" citStr="Shieber, 2004" startWordPosition="3292" endWordPosition="3293">I and O characterize a subclass of homomorphisms for the set of bimorphisms for which the input homomorphism is in the subclass indicated by I and the output homomorphism is in the subclass indicated by O. Thus, B(D,M) is the set of bimorphisms for which the input homomorphism is a delabeling but the output homomorphism can be arbitrary. The tree relations definable by tree transducers turn out to be exactly this class B(D,M) (Comon et al., 1997). The bimorphism notion thus allows us to characterize the tree transductions purely in terms of tree automata and tree homomorphisms. We have shown (Shieber, 2004) that the tree relations defined by synchronous tree-substitution grammars were exactly the relations B(LC,LC). Intuitively speaking, the tree language in such a bimorphism represents the set of derivation trees for the synchronous grammar, and each homomorphism represents the relation between the derivation tree and the derived tree for one of the projected tree-substitution grammars. The homomorphisms are linear and complete because the tree relation between a tree-substitution grammar derivation tree and its associated derived tree is exactly a linear complete tree homomorphism. To characte</context>
</contexts>
<marker>Shieber, 2004</marker>
<rawString>Stuart M. Shieber. 2004. Synchronous grammars as tree transducers. In Proceedings of the Seventh International Workshop on Tree Adjoining Grammar and Related Formalisms (TAG+7), pages 88– 95, Vancouver, Canada, May 20-22.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>