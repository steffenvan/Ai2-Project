<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000001">
<title confidence="0.644681">
Using Mazurkiewicz Trace Languages for Partition-Based Morphology
</title>
<author confidence="0.331682">
Franc¸ois Barth´elemy
</author>
<note confidence="0.7032475">
CNAM Cedric, 292 rue Saint-Martin, 75003 Paris (France)
INRIA Atoll, domaine de Voluceau, 78153 Le Chesnay cedex (France)
</note>
<email confidence="0.991906">
barthe@cnam.fr
</email>
<sectionHeader confidence="0.99854" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999807294117647">
Partition-based morphology is an approach
of finite-state morphology where a grammar
describes a special kind of regular relations,
which split all the strings of a given tuple
into the same number of substrings. They
are compiled in finite-state machines. In this
paper, we address the question of merging
grammars using different partitionings into
a single finite-state machine. A morphologi-
cal description may then be obtained by par-
allel or sequential application of constraints
expressed on different partition notions (e.g.
morpheme, phoneme, grapheme). The the-
ory of Mazurkiewicz Trace Languages, a
well known semantics of parallel systems,
provides a way of representing and compil-
ing such a description.
</bodyText>
<sectionHeader confidence="0.996208" genericHeader="method">
1 Partition-Based Morphology
</sectionHeader>
<bodyText confidence="0.956048">
Finite-State Morphology is based on the idea that
regular relations are an appropriate formalism to de-
scribe the morphology of a natural language. Such a
relation is a set of pairs, the first component being an
actual form called surface form, the second compo-
nent being an abstract description of this form called
lexical form. It is usually implemented by a finite-
state transducer. Relations are not oriented, so the
same transducer may be used both for analysis and
generation. They may be non-deterministic, when
the same form belongs to several pairs. Further-
more, finite state machines have interesting proper-
ties, they are composable and efficient.
There are two main trends in Finite-State Mor-
phology: rewrite-rule systems and two-level rule
systems. Rewrite-rule systems describe the mor-
phology of languages using contextual rewrite rules
which are easily applied in cascade. Rules are com-
piled into finite-state transducers and merged using
transducer composition (Kaplan and Kay, 1994).
The other important trend of Finite-State Mor-
phology is Two-Level Morphology (Koskenniemi,
1983). In this approach, not only pairs of lexical and
surface strings are related, but there is a one-to-one
correspondence between their symbols. It means
that the two strings of a given pair must have the
same length. Whenever a symbol of one side does
not have an actual counterpart in the other string,
a special symbol 0 is inserted at the relevant po-
sition in order to fulfill the same-length constraint.
For example, the correspondence between the sur-
face form spies and the morpheme concatenation
s p y 0 + s
spy+s is given as follows:
s p i e 0 s
Same-length relations are closed under intersection,
so two-level grammars describe a system as the si-
multaneous application of local constraints.
A third approach, Partition-Based Morphology,
consists in splitting the strings of a pair into the same
number of substrings. The same-length constraint
does not hold on symbols but on substrings. For ex-
ample, spies and spy+s may be partitioned as
s p y + s
follows:
s p ie c s
The partition-based approach was first proposed
by (Black et al., 1987) and further improved by (Pul-
man and Hepple, 1993) and (Grimley-Evans et al.,
</bodyText>
<page confidence="0.955773">
928
</page>
<note confidence="0.927052">
Proceedings of the 45th Annual Meeting of the Association of Computational Linguistics, pages 928–935,
Prague, Czech Republic, June 2007. c�2007 Association for Computational Linguistics
</note>
<bodyText confidence="0.985611666666667">
1996). It has been used to describe the morphol-
ogy of Syriac (Kiraz, 2000), Akkadian (Barth´elemy,
2006) and Arabic Dialects (Habash et al., 2005).
These works use multi-tape transducers instead of
usual two tape transducers, describing a special case
of n-ary relations instead of binary relations.
</bodyText>
<subsectionHeader confidence="0.569256">
Definition 1 Partitioned n-relation
</subsectionHeader>
<bodyText confidence="0.999067931818182">
A partitioned n-relation is a set of finite sequences
of string n-tuples.
For instance, the n-tuple sequence of
the example (spy, spies) given above is
(s, s)(p, p)(y, ie)(+, E)(s, s). Of course, all
the partitioned n-relations are not recognizable
using a finite-state machine. Grimley-Evans and
al. propose a partition-based formalism with a
strong restriction: the string n-tuples used in the
sequences belong to a finite set of such n-tuples (the
centers of context-restriction rules). They describe
an algorithm which compiles a set of contextual
rules describing a partitioned n-relation into an
epsilon-free letter transducer. (Barth´elemy, 2005)
proposed a more powerful framework, where the
relations are defined by concatenating tuples of
independent regular expressions and operations
on partitioned n-relations such as intersection and
complementation are considered.
In this paper, we propose to use Mazurkiewicz
Trace Languages instead of partitioned relation as
the semantics of partition-based morphological for-
malisms. The benefits are twofold: firstly, there is
an extension of the formal power which allows the
combination of morphological description using dif-
ferent partitionings of forms. Secondly, the compi-
lation of such languages into finite-state machines
has been exhaustively studied. Their closure prop-
erties provide operations useful for morphological
purposes.
They include the concatenation (for instance for
compound words), the intersection used to merge
local constraints, the union (modular lexicon), the
composition (cascading descriptions, form recogni-
tion and generation), the projection (to extract one
level of the relation), the complementation and set
difference, used to compile contextual rules fol-
lowing the algorithms in (Kaplan and Kay, 1994),
(Grimley-Evans et al., 1996) and (Yli-Jyr¨a and
Koskenniemi, 2004).
The use of the new semantics does not imply
any change of the user-level formalisms, thanks to
a straightforward homomorphism from partitioned
n-relations to Mazurkiewicz Trace Languages.
</bodyText>
<sectionHeader confidence="0.796009" genericHeader="method">
2 Mazurkiewicz Trace Languages
</sectionHeader>
<bodyText confidence="0.999913545454545">
Within a given n-tuple, there is no meaningful
order between symbols of the different levels.
Mazurkiewicz trace languages is a theory which ex-
presses partial ordering between symbols. They
have been defined and studied in the realm of par-
allel computing. In this section, we recall their
definition and some classical results. (Diekert and
M´etivier, 1997) gives an exhaustive presentation on
the subject with a detailed bibliography. It contains
all the results mentioned here and refers to their orig-
inal publication.
</bodyText>
<subsectionHeader confidence="0.926765">
2.1 Definitions
</subsectionHeader>
<bodyText confidence="0.999908375">
A Partially Commutative Monoid is defined on an
alphabet E with an independence binary relation I
over E x E which is symmetric and irreflexive. Two
independent symbols commute freely whereas non-
independent symbols do not. I defines an equiva-
lence relation -I on E*: two words are equivalent if
one is the result of a series of commutation of pairs
of successive symbols which belong to I. The nota-
tion [x] is used to denote the equivalence class of a
string x with respect to -I.
The Partially Commutative Monoid M(E, I) is
the quotient of the free monoid E* by the equiva-
lence relation -I.
The binary relation D = (E x E) − I is called the
dependence relation. It is reflexive and symmetric.
cp is the canonical homomorphism defined by:
</bodyText>
<equation confidence="0.8523415">
cp : E* —* M(E, I)
x H [x]
</equation>
<bodyText confidence="0.984901333333333">
A Mazurkiewicz trace language (abbreviation:
trace language) is a subset of a partially commuta-
tive monoid M(E, I).
</bodyText>
<subsectionHeader confidence="0.999605">
2.2 Recognizable Trace Languages
</subsectionHeader>
<bodyText confidence="0.9990716">
A trace language T is said recognizable if there
exists an homomorphism v from M(E, I) to a fi-
nite monoid S such that T = v−&apos;(F) for some
F C_ S. A recognizable Trace Language may be
implemented by a Finite-State Automaton.
</bodyText>
<page confidence="0.997609">
929
</page>
<bodyText confidence="0.95911125">
A trace [x] is said to be connected if the depen-
dence relation restricted to the alphabet of [x] is a
connected graph. A trace language is connected if
all its traces are connected.
A string x is said to be in lexicographic normal
form if x is the smallest string of its equivalence
class [x] with respect to the lexicographic ordering
induced by an ordering on E. The set of strings in
lexicographic normal form is written LexNF. This
set is a regular language which is described by the
following regular expression:
LexNF = E* − U(a,b)EI,a&lt;b E*b(I(a))*aE*
where I(a) denotes the set of symbols independent
from a.
Property 1 Let T C_ M(E, I) be a trace language.
The following assertions are equivalent:
</bodyText>
<listItem confidence="0.973185166666667">
• T is recognizable
• T is expressible as a rational expression where
the Kleene star is used only on connected lan-
guages.
• The set Min(T) = {x E LexNF |[x] E T} is
a regular language over E*.
</listItem>
<bodyText confidence="0.999886875">
Recognizability is closely related to the notion of
iterative factor, which is the language-level equiva-
lent of a loop in a finite-state machine. If two sym-
bols a and b such that a &lt; b belong to a loop, and if
the loop is traversed several times, then occurrences
of a and b are interlaced. For such a string to be
in lexicographic normal form, a dependent symbol
must appear in the loop between b and a.
</bodyText>
<subsectionHeader confidence="0.999176">
2.3 Operations and closure properties
</subsectionHeader>
<bodyText confidence="0.98964762962963">
Recognizable trace languages are closed under in-
tersection and union. Furthermore, Min(T1) U
Min(T2) = Min(T1UT2) and Min(T1)nMin(T2) =
Min(T1 n T2). It comes from the fact that intersec-
tion and union do not create new iterative factor. The
property on lexicographic normal form comes from
the fact that all the traces in the result of the opera-
tion belong to at least one of the operands which are
in normal form.
Recognizable trace language are closed under
concatenation. Concatenation do not create new it-
erative factors. The concatenation Min(T1)Min(T2)
is not necessarily in lexicographic normal form. For
instance, suppose that a &gt; b. Then {[a]}.{[b]} =
{[ab]}, but Min({[a]}) = a, Min({[b]}) = b, and
Min({[ab]}) = ba.
Recognizable trace languages are closed under
complementation.
Recognizable Trace Languages are not closed un-
der Kleene star. For instance, a &lt; b, Min([ab]*) =
anbn which is known not to be regular.
The projection on a subset 5 of E is the opera-
tion written 7rS, which deletes all the occurrences
of symbols in E − 5 from the traces. Recogniz-
able trace languages are not closed under projection.
The reason is that the projection may delete symbols
which makes the languages of loops connected.
</bodyText>
<sectionHeader confidence="0.87358" genericHeader="method">
3 Partitioned relations and trace languages
</sectionHeader>
<bodyText confidence="0.9997395">
It is possible to convert a partitioned relation into a
trace language as follows:
</bodyText>
<listItem confidence="0.9933135">
• represent the partition boundaries using a sym-
bol w not in E.
• distinguish the symbols according to the com-
ponent (tape) of the n-tuple they belong to. For
this purpose, we will use a subscript.
• define the dependence relation D by:
</listItem>
<bodyText confidence="0.97642980952381">
– w is dependent from all the other symbols
– symbols in E sharing the same subscript
are mutually dependent whereas symbols
having different subscript are mutually in-
dependent.
For instance, the spy n-tuple sequence
(s, s)(p, p)(y, ie)(+, E)(s, s) is translated into
the trace ws1s2wp1p2wy1i2e2w+1ws1s2w. The
figure 1 gives the partial order between symbols of
this trace.
The dependence relation is intuitively sound. For
instance, in the third n-tuple, there is a dependency
between i and e which cannot be permuted, but there
is no dependency between i (resp. e) and y: i is nei-
ther before nor after y. There are three equivalent
permutations: y1i2e2, i2y1e2 and i2e2y1. In an im-
plementation, one canonical representation must be
chosen, in order to ensure that set operations, such as
intersection, are correct. The notion of lexicographic
normal form, based on any arbitrary but fixed order
on symbols, gives such a canonical form.
</bodyText>
<page confidence="0.958466">
930
</page>
<figure confidence="0.9966152">
+1
s1
s1
p1
y1
w
w
w
w w
w
s2
s2
tape 1
tape 2
p2 i2 e2
</figure>
<figureCaption confidence="0.999929">
Figure 1: Partially ordered symbols
</figureCaption>
<bodyText confidence="0.999841097560976">
The compilation of the trace language into a
finite-state automaton has been studied through the
notion of recognizability. This automaton is very
similar to an n-tape transducer. The Trace Lan-
guage theory gives properties such as closure under
intersection and soundness of the lexicographic nor-
mal form, which do not hold for usual transducers
classes. It also provides a criterion to restrict the de-
scription of languages through regular expressions.
This restriction is that the closure operator (Kleene
star) must occur on connected languages only. In the
translation of a partition-based regular expression, a
star may appear either on a string of symbols of a
given tape or on a string with at least one occurrence
of W.
Another benefit of Mazurkiewicz trace languages
with respect to partitioned relations is their ability
to represent the segmentation of the same form us-
ing two different partitionings. The example of fig-
ure 2 uses two partitionings of the form spy+s,
one based on the notion of morpheme, the other on
the notion of phoneme. The notation &lt;pos=noun&gt;
and &lt;number=pl&gt; stands for two single symbols.
Flat feature structures over (small) finite domains
are easily represented by a string of such symbols.
N-tuples are not very convenient to represent such a
system.
Partition-based formalism are especially adapted
to express relations between different representation
such as feature structures and affixes, with respect
to two-level morphology which imposes an artificial
symbol-to-symbol mapping.
A multi-partitioned relation may be obtained by
merging the translation of two partition-based gram-
mars which share one or more common tapes. Such
a merging is performed by the join operator of the
relational algebra. Using a partition-based grammar
for recognition or generation implies such an oper-
ation: the grammar is joined with a 1-tape machine
without partitioning representing the form to be rec-
ognized (surface level) or generated (lexical level).
</bodyText>
<sectionHeader confidence="0.976105" genericHeader="method">
4 Multi-Tape Trace Languages
</sectionHeader>
<bodyText confidence="0.906331428571429">
In this section, we define a subclass of
Mazurkiewicz Trace Languages especially adapted
to partition-based morphology, thanks to an explicit
notion of tape partially synchronized by partition
boundaries.
Definition 2 A multi-tape partially commutative
monoid is defined by a tuple (E, O, Q, µ) where
</bodyText>
<listItem confidence="0.991923">
• E is a finite set of symbols called the alphabet.
• O is a finite set of symbols called the tapes.
• Q is a finite set of symbols which do not belong
to E, called the partition boundaries.
• µ is a mapping from E U Q to 20 such that µ(x)
is a singleton for any x E E.
</listItem>
<bodyText confidence="0.958281611111111">
It is the Partially Commutative Monoid M(E U
Q, Iµ) where the independence relation is defined by
Iµ = {(x, y) E E U Q x E U Q|µ(x) n µ(y) = 01.
Notation: MPM(E, O, Q, µ).
A Multi-Tape Trace Language is a subset of a
Multi-Tape partially commutative monoid.
We now address the problem of relational op-
erations over Recognizable Multi-Tape Trace Lan-
guages. Recognizable languages may be imple-
mented by finite-state automata in lexicographic
normal form, using the morphism cp−1. Operations
on trace languages are implemented by operations
on finite-state automata. We are looking for imple-
mentations preserving the normal form property, be-
cause changing the order in regular languages is not
a standard operation.
Some set operations are very simple to imple-
ment, namely union, intersection and difference.
</bodyText>
<page confidence="0.993655">
931
</page>
<figureCaption confidence="0.986708">
Figure 2: Two partitions of the same tape
</figureCaption>
<figure confidence="0.9664223">
tape 1
&lt;numbei=pl&gt;
&lt;pos=noun&gt;
w1
w1
w1
s3
i3 e3
s3
tape 3
p3
tape 2
w2
s2
p2
y2
s2
w2 w2
w2
w2
</figure>
<bodyText confidence="0.996651833333333">
The elements of the result of such an operation be-
longs to one or both operands, and are therefore in
lexicographic normal form. If we write Min(T) the
set Min(T) = {x E LexNF |[x] E T}, where T is
a Multi-Tape Trace Language, we have trivially the
properties:
</bodyText>
<listItem confidence="0.999412">
• Min(T1 U T2) = Min(T1) U Min(T2)
• Min(T1 n T2) = Min(T1) n Min(T2)
• Min(T1 − T2) = Min(T1) − Min(T2)
</listItem>
<bodyText confidence="0.999686">
Implementing the complementation is not so
straightforward because Min(T) is usually not
equal to Min(T). The later set contains strings not
in lexical normal forms which may belong to the
equivalence class of a member of T with respect to
-I. The complementation must not be computed
with respect to regular languages but to LexNF.
</bodyText>
<equation confidence="0.996223">
Min(T) = LexNF − Min(T)
</equation>
<bodyText confidence="0.995609166666667">
As already mentioned, the concatenation of two
regular languages in lexicographic normal form is
not necessarily in normal form. We do not have a
general solution to the problem but two partial so-
lutions. Firstly, it is easy to test whether the re-
sult is actually in normal form or not. Secondly,
the result is in normal form whenever a synchro-
nization point belonging to all the levels is inserted
between the strings of the two languages. Let
Wg E Q,µ(Wg) = O. Then, Min(T1.{Wg}.T2) =
Min(T1).Min(Wg).Min(T2).
The closure (Kleene star) operation creates a new
iterative factor and therefore, the result may be a
non recognizable trace language. Here again, con-
catenating a global synchronization point at the end
of the language gives a trace language closed under
Kleene star. By definition, such a language is con-
nected. Furthermore, the result is in normal form.
So far, operations have operands and the result be-
longing to the same Multi-tape Monoid. It is not the
case of the last two operations: projection and join.
We use the the operators Dom, Range, and the
relations Id and Insert as defined in (Kaplan and Kay,
1994):
</bodyText>
<listItem confidence="0.997126714285714">
• Dom(R) = {x|ly, (x, y) E R}
• Range(R) = {y|]x, (x, y) E R}
• Id(L) = {(x,x)|x E L}
• Insert(5) = (Id(E) U ({E} x 5))*. It is used
to insert freely symbols from 5 in a string from
E*. Conversely, Insert(5)−1 removes all the
occurrences of symbols from 5, if 5 n E = 0.
</listItem>
<bodyText confidence="0.999963">
The result of a projection operation may not be
recognizable if it deletes symbols making iterative
factors connected. Furthermore, when the result is
recognizable, the projection on Min(T) is not nec-
essarily in normal form. Both phenomena come
from the deletion of synchronization points. There-
fore, a projection which deletes only symbols from
E is safe. The deletion of synchronization points is
also possible whenever they do not synchronize any-
thing more in the result of the projection because all
but possibly one of its tapes have been deleted.
In the tape-oriented computation system, we are
mainly interested in the projection which deletes
some tapes and possibly some related synchroniza-
tion points.
</bodyText>
<equation confidence="0.827741714285714">
Property 2 Projection
Let T be a trace language over the MTM
M = (E, O, w, µ). Let Q1 C Q and O1 C O. If
932
∀w ∈ Ω − Ω1, |µ(w) ∩ Θ1 |≤ 1, then
Min(7rΘ1,Ω1(T)) = Range(Insert({x ∈
Σ|µ(x) ∈� Θ1} ∪ Ω − Ω1)−1 ◦ Min(T))
</equation>
<bodyText confidence="0.999957">
The join operation is named by analogy with the
operator of the relational algebra. It has been defined
on finite-state transducers (Kempe et al., 2004).
</bodyText>
<subsectionHeader confidence="0.472073">
Definition 3 Multi-tape join
</subsectionHeader>
<bodyText confidence="0.899268333333333">
Let T1 ⊂ MTM(Σ1, Θ1, Ω1,µ1) and T2 ⊂
TM(Σ2, Θ2,Ω2, µ2) be two multi-tape trace lan-
guages. T1 ✶ T2 is defined if and only if
</bodyText>
<listItem confidence="0.9947655">
• ∀U ∈ Σ1 ∩ Σ2, µ1(U) ∩ Θ2 = µ2(U) ∩ Θ1
• ∀w ∈ Ω1 ∩ Ω2, µ1(w) ∩ Θ2 = µ2(w) ∩ Θ1
</listItem>
<bodyText confidence="0.973221">
The Multi-tape Trace Language T1 ✶ T2 is defined
on the Multi-tape Partially Commutative Monoid
</bodyText>
<equation confidence="0.774297666666667">
MTM(Σ1∪Σ2, Θ1∪Θ2, Ω1∪Ω2, µ) where µ(x) =
µ1(x) ∪ µ2(x). It is defined by 7rΣ1uΘ1uΩ1(T1 ✶
T2) = T1 and 7rΣ2uΘ2uΩ2(T1 ✶ T2) = T2.
</equation>
<bodyText confidence="0.9892215">
If the two operands T1 and T2 belong to the same
MTM, then T1 ✶ T2 = T1 ∩ T2. If the operands
belong to disjoint monoids (which do not share any
symbol), then the join is a Cartesian product.
The implementation of the join relies on the finite-
state intersection algorithm. This algorithm works
whenever the common symbols of the two languages
appear in the same order in the two operands. The
normal form does not ensure this property, because
symbols in the common part of the join may be syn-
chronized by tapes not in the common part, by tran-
sitivity, like in the example of the figure 3. In this
example, c on tape 3 and f on tape 1 are ordered
c &lt; f by transitivity using tape 2.
</bodyText>
<figureCaption confidence="0.992784">
Figure 3: indirect tape synchronization
</figureCaption>
<bodyText confidence="0.999640222222222">
Let T ⊆ MPM(Σ, Θ, Ω, µ) a multi-partition
trace language. Let GT be the labeled graph where
the nodes are the tape symbols from Θ and the
edges are the set {(x,w,y) ∈ Θ × Ω × Θ|x ∈
µ(w) and y ∈ µ(w)}. Let Sync(Θ) be the set de-
fined by Sync(Θ) = {w ∈ Ω|w appears in GT on a
path between two tapes of Θ}.
The GT graph for example of the figure 3 is given
in figure 4 and Sync({1, 3}) = {w0, w1, w2}.
</bodyText>
<figureCaption confidence="0.987011">
Figure 4: the GT graph
</figureCaption>
<bodyText confidence="0.967408451612903">
Sync(Θ) is different from µ−1(Θ) ∩ Ω because
some synchronization points may induce an order
between two tapes by transitivity, using other tapes.
Property 3 Let T1 ⊆ MPM(Σ1, Θ1, Ω1, µ1)
and T2 ⊆ MPM(Σ2, Θ2,Ω2, µ2) be two multi-
partition trace languages. Let Σ = Σ1 ∩ Σ2
and Ω = Ω1 ∩ Ω2. If Sync(Θ1 ∩ Θ2) ⊆
Ω, then 7rΣuΩ(Min(T1)) ∩ 7rΣuΩ(Min(T2)) =
Min(7rΣuΩ(T1) ∩ 7rΣuΩ(T2)
This property expresses the fact that symbols be-
longing to both languages appear in the same order
in lexicographic normal forms whenever all the di-
rect and indirect synchronization symbols belong to
the two languages too.
Property 4 Let T1 ⊆ MPM(Σ1, Θ1, Ω1, µ1)
and T2 ⊆ MPM(Σ2, Θ2,Ω2, µ2) be two multi-
partition trace languages. If Θ1 ∩ Θ2 is a
singleton {0} and if ∀w ∈ Ω1 ∩ Ω2,0 ∈
µ(w), then 7rΣuΩ(Min(T1)) ∩ 7rΣuΩ(Min(T2)) =
Min(7rΣuΩ(T1) ∩ 7rΣuΩ(T2)
This second property expresses the fact that sym-
bols appear necessarily in the same order in the two
operands if the intersection of the two languages is
restricted to symbols of a single tape. This property
is straightforward since symbols of a given tape are
mutually dependent.
We now define a computation over (Σ∪Ω)* which
computes Min(T1 ✶ T2).
Let T1 ⊂ MTM(Σ1,Θ1,w1,µ1) and T2 ⊂
MTM(Σ2, Θ2, Ω2, µ2) be two recognizable multi-
tape trace languages.
</bodyText>
<figure confidence="0.927476380952381">
If Sync(Θ1 ∩ Θ2) ⊆ Ω, then Min(T1 ✶ T2) =
Range(Min(T1 ◦ Insert(Σ2 − Σ1) ◦ Id(LexNF)) ∩
Range(Min(T2) ◦ Insert(Σ1 − Σ2) ◦ Id(LexNF)).
f
w2
b d g
w0 w0
w1
e
tape 1
tape 2
tape 3
c
a
tape 2
tape 1 w2
w0
w1
tape 3
w0
w0
</figure>
<page confidence="0.997537">
933
</page>
<sectionHeader confidence="0.968028" genericHeader="method">
5 A short example
</sectionHeader>
<bodyText confidence="0.999962166666667">
We have written a morphological description of
Turkish verbal morphology using two different par-
titionings. The first one corresponds to the notion
of affix (morpheme). It is used to describe the mor-
photactics of the language using rules such as the
following context-restriction rule:
</bodyText>
<equation confidence="0.863317">
(y?I4m,1 sing) ==&gt;.
(I?yor,prog)|(y?E2cE2k,future)
</equation>
<bodyText confidence="0.985999666666667">
In this rule, y? stands for an optional y, I4 and E2
for abstract vowels which realizations are subject to
vowel harmony and I? is an optional occurrence of
the first vowel. The rule may be read: the suffix
y?I4m denoting a first person singular may appear
only after the suffix of progressive or the suffix of
future1. Such rules describe simply affix order in
verbal forms.
The second partitioning is a symbol-to-symbol
correspondence similar to the one used in standard
two-level morphology. This partitioning is more
convenient to express the constraints of vowel har-
mony which occurs anywhere in the affixes and does
not depend on affix boundaries.
Here are two of the rules implementing vowel har-
mony:
(I4,i) ==&gt;. (Vow,e|i) (Cons,Cons)*
(I4,u) ==&gt;. (Vow,o|u) (Cons,Cons)*
Vow and Cons denote respectively the sets of vowels
and consonants. These rules may be read: a symbol
I4 is realized as i (resp. u) whenever the closest pre-
ceding vowel is realized as e or i (resp. o or u).
The realization or not of an optional letter may be
expressed using one or the other partitioning. These
optional letters always appear in the first position of
an affix and depends only on the last letter of the
preceding affix.
</bodyText>
<equation confidence="0.514325">
(y?,y) ==&gt;. (Vow,Vow)
</equation>
<bodyText confidence="0.987923770833334">
Here is an example of a verbal form given as a 3-
tape relation partitioned using the two partitionings.
verbal root prog 1 sing
g e l I? y o r Y? I4 m
g e l i y o r E u m
The translation of each rule into a Multi-tape
Trace Language involves two tasks: introducing par-
1The actual rule has 5 other alternative tenses. It has been
shortened for clarity.
tition boundary symbols at each frontier between
partitions. A different symbol is used for each kind
of partitioning. Distinguishing symbols from differ-
ent tapes in order to ensure that µ(x) is a singleton
for each x E E. Symbols of E are therefore pairs
with the symbol appearing in the rule as first com-
ponent and the tape identifier, a number, as second
component.
Any complete order between symbols would
define a lexicographic normal form. The order
used by our system orders symbol with respect
to tapes: symbols of the first tape are smaller
than the symbols of tape 2, and so on. The or-
der between symbols of a same tape is not impor-
tant because these symbols are mutually dependent.
The translation of a tuple (a1 ... a, b1 ... bm) is
(a1, 1) ... (a.,1)(b1, 2) ... (bm, 2)w1. Such a string
is in lexicographic normal form. Furthermore, this
expression is connected, thanks to the partition
boundary which synchronizes all the tapes, so its
closure is recognizable. The concatenation too is
safe.
All contextual rules are compiled following the
algorithm in (Yli-Jyr¨a and Koskenniemi, 2004) 2.
Then all the rules describing affixes are intersected
in an automaton, and all the rules describing surface
transformation are intersected in another automaton.
Then a join is performed to obtain the final machine.
This join is possible because the intersection of the
two languages consists in one tape (cf. property 4).
Using it either for recognition or generation is also
done by a join, possibly followed by a projection.
For instance, to recognize a surface form
geliyorum, first compile it in the multi-tape trace
language (g, 3)(e, 3)(l, 3) ... (m, 3), join it with the
morphological description, and then project the re-
sult on tape 1 to obtain an abstract form (verbal
root,1)(prog,1)(1 sing,1). Finally ex-
tract the first component of each pair.
</bodyText>
<sectionHeader confidence="0.999459" genericHeader="conclusions">
6 Conclusion
</sectionHeader>
<bodyText confidence="0.999769">
Partition-oriented rules are a convenient way to de-
scribe some of the constraints involved in the mor-
phology of the language, but not all the constraints
refer to the same partition notion. Describing a rule
</bodyText>
<footnote confidence="0.672678666666667">
2Two other compilation algorithm also work on the rules of
this example (Kaplan and Kay, 1994), (Grimley-Evans et al.,
1996). (Yli-Jyr¨a and Koskenniemi, 2004) is more general.
</footnote>
<page confidence="0.996264">
934
</page>
<bodyText confidence="0.999804342105263">
with an irrelevant one is sometimes difficult and in-
elegant. For instance, describing vowel harmony us-
ing a partitioning based on morphemes takes neces-
sarily several rules corresponding to the cases where
the harmony is within a morpheme or across several
morphemes.
Previous partition-based formalisms use a unique
partitioning which is used in all the contextual rules.
Our proposition is to use several partitionings in or-
der to express constraints with the proper granular-
ity. Typically, these partitionings correspond to the
notions of morphemes, phonemes and graphemes.
Partition-based grammars have the same theoret-
ical power as two-level morphology, which is the
power of regular languages. It was designed to re-
main finite-state and closed under intersection. It is
compiled in finite-state automata which are formally
equivalent to the epsilon-free letter transducers used
by two-level morphology. It is simply more easy to
use in some cases, just like two-level rules are more
convenient than simple regular expressions for some
applications.
Partition-Based morphology is convenient when-
ever the different levels use very different represen-
tations, like feature structures and strings, or dif-
ferent writing systems (e.g. Japanese hiragana and
transcription). Two-level rules on the other hand
are convenient whenever the related strings are vari-
ants of the same representation like in the example
(spy+s,spies). Note that multi-partition morphology
may use a one-to-one correspondence as one of its
partitionings, and therefore is compatible with usual
two-level morphology.
With respect to rewrite rule systems, partition-
based morphology gives better support to parallel
rule application and context definition may involve
several levels. The counterpart is a risk of conflicts
between contextual rules.
</bodyText>
<sectionHeader confidence="0.986603" genericHeader="acknowledgments">
Acknowledgement
</sectionHeader>
<bodyText confidence="0.999702">
We would like to thank an anonymous referee of this
paper for his/her helpful comments.
</bodyText>
<sectionHeader confidence="0.999259" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.99987825">
Franc¸ois Barth´elemy. 2005. Partitioning multitape trans-
ducers. In International Workshop on Finite State
Methods in Natural Language Processing (FSMNLP),
Helsinki, Finland.
Franc¸ois Barth´elemy. 2006. Un analyseur mor-
phologique utilisant la jointure. In Traitement Au-
tomatique de la Langue Naturelle (TALN), Leuven,
Belgium.
Alan Black, Graeme Ritchie, Steve Pulman, and Graham
Russell. 1987. Formalisms for morphographemic
description. In Proceedings of the third conference
on European chapter of the Association for Compu-
tational Linguistics (EACL), pages 11–18.
Volker Diekert and Yves M´etivier. 1997. Partial commu-
tation and traces. In G. Rozenberg and A. Salomaa,
editors, Handbook of Formal Languages, Vol. 3, pages
457–534. Springer-Verlag, Berlin.
Edmund Grimley-Evans, George Kiraz, and Stephen Pul-
man. 1996. Compiling a partition-based two-level
formalism. In COLING, pages 454–459, Copenhagen,
Denmark.
Nizar Habash, Owen Rambow, and George Kiraz. 2005.
Morphological analysis and generation for arabic di-
alects. In Proceedings of the ACL Workshop on
Semitic Languages, Ann Harbour, Michigan.
Ronald M. Kaplan and Martin Kay. 1994. Regular mod-
els of phonological rule systems. Computational Lin-
guistics, 20:3:331–378.
Andr´e Kempe, Jean-Marc Champarnaud, and Jason Eis-
ner. 2004. A note on join and auto-intersection of n-
ary rational relations. In B. Watson and L. Cleophas,
editors, Proc. Eindhoven FASTAR Days, Eindhoven,
Netherlands.
George Anton Kiraz. 2000. Multitiered nonlinear mor-
phology using multitape finite automata: a case study
on syriac and arabic. Comput. Linguist., 26(1):77–
105.
Kimmo Koskenniemi. 1983. Two-level model for mor-
phological analysis. In IJCAI-83, pages 683–685,
Karlsruhe, Germany.
Stephen G. Pulman and Mark R. Hepple. 1993.
A feature-based formalism for two-level phonology.
Computer Speech and Language, 7:333–358.
Anssi Yli-Jyr¨a and Kimmo Koskenniemi. 2004. Compil-
ing contextual restrictions on strings into finite-state
automata. In B. Watson and L. Cleophas, editors,
Proc. Eindhoven FASTAR Days, Eindhoven, Nether-
lands.
</reference>
<page confidence="0.9987">
935
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.000056">
<title confidence="0.998267">Using Mazurkiewicz Trace Languages for Partition-Based Morphology</title>
<author confidence="0.889956">Barth´elemy</author>
<address confidence="0.64278">CNAM Cedric, 292 rue Saint-Martin, 75003 Paris (France) INRIA Atoll, domaine de Voluceau, 78153 Le Chesnay cedex (France)</address>
<email confidence="0.995853">barthe@cnam.fr</email>
<abstract confidence="0.992680898305084">Partition-based morphology is an approach of finite-state morphology where a grammar describes a special kind of regular relations, which split all the strings of a given tuple into the same number of substrings. They are compiled in finite-state machines. In this paper, we address the question of merging grammars using different partitionings into a single finite-state machine. A morphological description may then be obtained by parallel or sequential application of constraints expressed on different partition notions (e.g. morpheme, phoneme, grapheme). The theory of Mazurkiewicz Trace Languages, a well known semantics of parallel systems, provides a way of representing and compiling such a description. 1 Partition-Based Morphology Finite-State Morphology is based on the idea that regular relations are an appropriate formalism to describe the morphology of a natural language. Such a relation is a set of pairs, the first component being an form called the second component being an abstract description of this form called It is usually implemented by a finitestate transducer. Relations are not oriented, so the same transducer may be used both for analysis and generation. They may be non-deterministic, when the same form belongs to several pairs. Furthermore, finite state machines have interesting properties, they are composable and efficient. There are two main trends in Finite-State Morphology: rewrite-rule systems and two-level rule systems. Rewrite-rule systems describe the morphology of languages using contextual rewrite rules which are easily applied in cascade. Rules are compiled into finite-state transducers and merged using transducer composition (Kaplan and Kay, 1994). The other important trend of Finite-State Morphology is Two-Level Morphology (Koskenniemi, 1983). In this approach, not only pairs of lexical and surface strings are related, but there is a one-to-one correspondence between their symbols. It means that the two strings of a given pair must have the same length. Whenever a symbol of one side does not have an actual counterpart in the other string, a special symbol 0 is inserted at the relevant position in order to fulfill the same-length constraint. For example, the correspondence between the surform the morpheme concatenation s p y 0 + s given as follows: s p i e 0 s Same-length relations are closed under intersection, so two-level grammars describe a system as the simultaneous application of local constraints. A third approach, Partition-Based Morphology, consists in splitting the strings of a pair into the same number of substrings. The same-length constraint does not hold on symbols but on substrings. For exbe partitioned as s p y + s follows: p ie The partition-based approach was first proposed by (Black et al., 1987) and further improved by (Pulman and Hepple, 1993) and (Grimley-Evans et al., 928 of the 45th Annual Meeting of the Association of Computational pages 928–935, Czech Republic, June 2007. Association for Computational Linguistics 1996). It has been used to describe the morphology of Syriac (Kiraz, 2000), Akkadian (Barth´elemy, 2006) and Arabic Dialects (Habash et al., 2005). These works use multi-tape transducers instead of usual two tape transducers, describing a special case of n-ary relations instead of binary relations. 1 n-relation A partitioned n-relation is a set of finite sequences of string n-tuples. For instance, the n-tuple sequence of example above is Of course, all the partitioned n-relations are not recognizable using a finite-state machine. Grimley-Evans and al. propose a partition-based formalism with a strong restriction: the string n-tuples used in the sequences belong to a finite set of such n-tuples (the centers of context-restriction rules). They describe an algorithm which compiles a set of contextual rules describing a partitioned n-relation into an epsilon-free letter transducer. (Barth´elemy, 2005) proposed a more powerful framework, where the relations are defined by concatenating tuples of independent regular expressions and operations on partitioned n-relations such as intersection and complementation are considered. In this paper, we propose to use Mazurkiewicz Trace Languages instead of partitioned relation as the semantics of partition-based morphological formalisms. The benefits are twofold: firstly, there is an extension of the formal power which allows the combination of morphological description using different partitionings of forms. Secondly, the compilation of such languages into finite-state machines has been exhaustively studied. Their closure properties provide operations useful for morphological purposes. They include the concatenation (for instance for compound words), the intersection used to merge local constraints, the union (modular lexicon), the composition (cascading descriptions, form recognition and generation), the projection (to extract one level of the relation), the complementation and set difference, used to compile contextual rules following the algorithms in (Kaplan and Kay, 1994), (Grimley-Evans et al., 1996) and (Yli-Jyr¨a and Koskenniemi, 2004). The use of the new semantics does not imply any change of the user-level formalisms, thanks to a straightforward homomorphism from partitioned n-relations to Mazurkiewicz Trace Languages. 2 Mazurkiewicz Trace Languages Within a given n-tuple, there is no meaningful order between symbols of the different levels. Mazurkiewicz trace languages is a theory which expresses partial ordering between symbols. They have been defined and studied in the realm of parallel computing. In this section, we recall their definition and some classical results. (Diekert and M´etivier, 1997) gives an exhaustive presentation on the subject with a detailed bibliography. It contains all the results mentioned here and refers to their original publication. 2.1 Definitions A Partially Commutative Monoid is defined on an an independence binary relation is symmetric and irreflexive. Two independent symbols commute freely whereas nonsymbols do not. an equivarelation two words are equivalent if one is the result of a series of commutation of pairs of successive symbols which belong to I. The notaused to denote the equivalence class of a respect to Partially Commutative Monoid quotient of the free monoid by the equivarelation binary relation (E called the dependence relation. It is reflexive and symmetric. the canonical homomorphism defined by: —* A Mazurkiewicz trace language (abbreviation: trace language) is a subset of a partially commutamonoid 2.2 Recognizable Trace Languages trace language said there an homomorphism a fimonoid S such that some A recognizable Trace Language may be implemented by a Finite-State Automaton. 929 trace said to be connected if the depenrelation restricted to the alphabet of a connected graph. A trace language is connected if all its traces are connected. string said to be in lexicographic normal if the smallest string of its equivalence respect to the lexicographic ordering by an ordering on The set of strings in normal form is written This set is a regular language which is described by the following regular expression: the set of symbols independent 1 a trace language. The following assertions are equivalent: T recognizable T expressible as a rational expression where the Kleene star is used only on connected languages. The set = regular language over Recognizability is closely related to the notion of iterative factor, which is the language-level equivalent of a loop in a finite-state machine. If two symthat &lt; b to a loop, and if the loop is traversed several times, then occurrences interlaced. For such a string to be in lexicographic normal form, a dependent symbol must appear in the loop between b and a. 2.3 Operations and closure properties Recognizable trace languages are closed under inand union. Furthermore, = = It comes from the fact that intersection and union do not create new iterative factor. The property on lexicographic normal form comes from the fact that all the traces in the result of the operation belong to at least one of the operands which are in normal form. Recognizable trace language are closed under concatenation. Concatenation do not create new itfactors. The concatenation is not necessarily in lexicographic normal form. For suppose that &gt; Then but = = = Recognizable trace languages are closed under complementation. Recognizable Trace Languages are not closed un- Kleene star. For instance, &lt; = is known not to be regular. projection on a subset the operawritten which deletes all the occurrences symbols in the traces. Recognizable trace languages are not closed under projection. The reason is that the projection may delete symbols which makes the languages of loops connected. 3 Partitioned relations and trace languages It is possible to convert a partitioned relation into a trace language as follows: • represent the partition boundaries using a symin • distinguish the symbols according to the component (tape) of the n-tuple they belong to. For this purpose, we will use a subscript. define the dependence relation dependent from all the other symbols symbols in the same subscript are mutually dependent whereas symbols having different subscript are mutually independent. instance, the sequence translated into trace figure 1 gives the partial order between symbols of this trace. The dependence relation is intuitively sound. For instance, in the third n-tuple, there is a dependency between i and e which cannot be permuted, but there is no dependency between i (resp. e) and y: i is neither before nor after y. There are three equivalent an implementation, one canonical representation must be chosen, in order to ensure that set operations, such as intersection, are correct. The notion of lexicographic normal form, based on any arbitrary but fixed order on symbols, gives such a canonical form. 930 +1 s1 s1 p1 y1 w w w w w w s2 s2 tape 1 tape 2 p2 i2 e2 Figure 1: Partially ordered symbols The compilation of the trace language into a finite-state automaton has been studied through the notion of recognizability. This automaton is very similar to an n-tape transducer. The Trace Language theory gives properties such as closure under intersection and soundness of the lexicographic normal form, which do not hold for usual transducers classes. It also provides a criterion to restrict the description of languages through regular expressions. This restriction is that the closure operator (Kleene star) must occur on connected languages only. In the translation of a partition-based regular expression, a star may appear either on a string of symbols of a given tape or on a string with at least one occurrence Another benefit of Mazurkiewicz trace languages with respect to partitioned relations is their ability to represent the segmentation of the same form using two different partitionings. The example of fig- 2 uses two partitionings of the form one based on the notion of morpheme, the other on notion of phoneme. The notation for two single symbols. Flat feature structures over (small) finite domains are easily represented by a string of such symbols. N-tuples are not very convenient to represent such a system. Partition-based formalism are especially adapted to express relations between different representation such as feature structures and affixes, with respect to two-level morphology which imposes an artificial symbol-to-symbol mapping. A multi-partitioned relation may be obtained by merging the translation of two partition-based grammars which share one or more common tapes. Such a merging is performed by the join operator of the relational algebra. Using a partition-based grammar for recognition or generation implies such an operation: the grammar is joined with a 1-tape machine without partitioning representing the form to be recognized (surface level) or generated (lexical level). 4 Multi-Tape Trace Languages In this section, we define a subclass of Mazurkiewicz Trace Languages especially adapted to partition-based morphology, thanks to an explicit notion of tape partially synchronized by partition boundaries. 2 multi-tape partially commutative is defined by a tuple E a finite set of symbols called the alphabet. O a finite set of symbols called the tapes. Q a finite set of symbols which do not belong called the partition boundaries. µ a mapping from such that a singleton for any is the Partially Commutative Monoid the independence relation is defined by = = A Multi-Tape Trace Language is a subset of a Multi-Tape partially commutative monoid. We now address the problem of relational operations over Recognizable Multi-Tape Trace Languages. Recognizable languages may be implemented by finite-state automata in lexicographic form, using the morphism Operations on trace languages are implemented by operations on finite-state automata. We are looking for implementations preserving the normal form property, because changing the order in regular languages is not a standard operation. Some set operations are very simple to implement, namely union, intersection and difference. 931 Figure 2: Two partitions of the same tape tape 1 &lt;numbei=pl&gt; &lt;pos=noun&gt; w1 w1 w1 s3 i3 e3 s3 tape 3 p3 tape 2 w2 s2 p2 y2 s2 w2 w2 w2 w2 The elements of the result of such an operation belongs to one or both operands, and are therefore in normal form. If we write = where T is a Multi-Tape Trace Language, we have trivially the properties: • = • = • = Implementing the complementation is not so because usually not to The later set contains strings not in lexical normal forms which may belong to the class of a member of respect to The complementation must not be computed with respect to regular languages but to LexNF. = As already mentioned, the concatenation of two regular languages in lexicographic normal form is not necessarily in normal form. We do not have a general solution to the problem but two partial solutions. Firstly, it is easy to test whether the result is actually in normal form or not. Secondly, the result is in normal form whenever a synchronization point belonging to all the levels is inserted between the strings of the two languages. Let E = Then, = The closure (Kleene star) operation creates a new iterative factor and therefore, the result may be a non recognizable trace language. Here again, concatenating a global synchronization point at the end of the language gives a trace language closed under Kleene star. By definition, such a language is connected. Furthermore, the result is in normal form. So far, operations have operands and the result belonging to the same Multi-tape Monoid. It is not the case of the last two operations: projection and join. We use the the operators Dom, Range, and the relations Id and Insert as defined in (Kaplan and Kay, 1994): • = • = • = • = x It is used insert freely symbols from a string from Conversely, removes all the of symbols from if = The result of a projection operation may not be recognizable if it deletes symbols making iterative factors connected. Furthermore, when the result is the projection on not necessarily in normal form. Both phenomena come from the deletion of synchronization points. Therefore, a projection which deletes only symbols from safe. The deletion of synchronization points is also possible whenever they do not synchronize anything more in the result of the projection because all but possibly one of its tapes have been deleted. In the tape-oriented computation system, we are mainly interested in the projection which deletes some tapes and possibly some related synchronization points. 2 a trace language over the MTM w, Let If 932 ≤ = ∪ ◦ The join operation is named by analogy with the operator of the relational algebra. It has been defined on finite-state transducers (Kempe et al., 2004). 3 join two multi-tape trace landefined if and only if • • Multi-tape Trace Language defined on the Multi-tape Partially Commutative Monoid = It is defined by = = the two operands to the same then If the operands belong to disjoint monoids (which do not share any symbol), then the join is a Cartesian product. The implementation of the join relies on the finitestate intersection algorithm. This algorithm works whenever the common symbols of the two languages appear in the same order in the two operands. The normal form does not ensure this property, because symbols in the common part of the join may be synchronized by tapes not in the common part, by transitivity, like in the example of the figure 3. In this tape 3 and tape 1 are ordered &lt; f transitivity using tape 2. Figure 3: indirect tape synchronization multi-partition language. Let the labeled graph where nodes are the tape symbols from the are the set Let the set deby = in a between two tapes of for example of the figure 3 is given figure 4 and = 4: the different from some synchronization points may induce an order between two tapes by transitivity, using other tapes. 3 two multitrace languages. Let = = If then = This property expresses the fact that symbols belonging to both languages appear in the same order in lexicographic normal forms whenever all the direct and indirect synchronization symbols belong to the two languages too. 4 two multitrace languages. If a if then = This second property expresses the fact that symbols appear necessarily in the same order in the two operands if the intersection of the two languages is restricted to symbols of a single tape. This property is straightforward since symbols of a given tape are mutually dependent. now define a computation over which two recognizable multitape trace languages. then = f w2 b d g w0 w0 w1 e tape 1 tape 2 tape 3 c a tape 2 tape 1 w2 w0 w1 tape 3 w0 w0 933 5 A short example We have written a morphological description of Turkish verbal morphology using two different partitionings. The first one corresponds to the notion of affix (morpheme). It is used to describe the morphotactics of the language using rules such as the following context-restriction rule: sing) this rule, stands for an optional y, and for abstract vowels which realizations are subject to harmony and is an optional occurrence of the first vowel. The rule may be read: the suffix a first person singular may appear only after the suffix of progressive or the suffix of Such rules describe simply affix order in verbal forms. The second partitioning is a symbol-to-symbol correspondence similar to the one used in standard two-level morphology. This partitioning is more convenient to express the constraints of vowel harmony which occurs anywhere in the affixes and does not depend on affix boundaries. Here are two of the rules implementing vowel harmony: (Cons,Cons)* (Cons,Cons)* Vow and Cons denote respectively the sets of vowels consonants. These rules may be read: symbol realized as i (resp. u) whenever the closest prevowel is realized as e or i (resp. o or The realization or not of an optional letter may be expressed using one or the other partitioning. These optional letters always appear in the first position of an affix and depends only on the last letter of the preceding affix. Here is an example of a verbal form given as a 3tape relation partitioned using the two partitionings. verbal root prog 1 sing g e l y o r m g e l i y o r E u m The translation of each rule into a Multi-tape Language involves two tasks: introducing paractual rule has 5 other alternative tenses. It has been shortened for clarity. tition boundary symbols at each frontier between partitions. A different symbol is used for each kind of partitioning. Distinguishing symbols from differtapes in order to ensure that a singleton each Symbols of therefore pairs with the symbol appearing in the rule as first component and the tape identifier, a number, as second component. Any complete order between symbols would define a lexicographic normal form. The order used by our system orders symbol with respect to tapes: symbols of the first tape are smaller than the symbols of tape 2, and so on. The order between symbols of a same tape is not important because these symbols are mutually dependent. translation of a tuple Such a string is in lexicographic normal form. Furthermore, this expression is connected, thanks to the partition boundary which synchronizes all the tapes, so its closure is recognizable. The concatenation too is safe. All contextual rules are compiled following the in (Yli-Jyr¨a and Koskenniemi, 2004) Then all the rules describing affixes are intersected in an automaton, and all the rules describing surface transformation are intersected in another automaton. Then a join is performed to obtain the final machine. This join is possible because the intersection of the two languages consists in one tape (cf. property 4). Using it either for recognition or generation is also done by a join, possibly followed by a projection. For instance, to recognize a surface form first compile it in the multi-tape trace join it with the morphological description, and then project the reon tape 1 to obtain an abstract form Finally extract the first component of each pair. 6 Conclusion Partition-oriented rules are a convenient way to describe some of the constraints involved in the morphology of the language, but not all the constraints refer to the same partition notion. Describing a rule other compilation algorithm also work on the rules of this example (Kaplan and Kay, 1994), (Grimley-Evans et al., 1996). (Yli-Jyr¨a and Koskenniemi, 2004) is more general. 934 with an irrelevant one is sometimes difficult and inelegant. For instance, describing vowel harmony using a partitioning based on morphemes takes necessarily several rules corresponding to the cases where the harmony is within a morpheme or across several morphemes. Previous partition-based formalisms use a unique partitioning which is used in all the contextual rules. Our proposition is to use several partitionings in order to express constraints with the proper granularity. Typically, these partitionings correspond to the notions of morphemes, phonemes and graphemes. Partition-based grammars have the same theoretical power as two-level morphology, which is the power of regular languages. It was designed to remain finite-state and closed under intersection. It is compiled in finite-state automata which are formally equivalent to the epsilon-free letter transducers used by two-level morphology. It is simply more easy to use in some cases, just like two-level rules are more convenient than simple regular expressions for some applications. Partition-Based morphology is convenient whenever the different levels use very different representations, like feature structures and strings, or different writing systems (e.g. Japanese hiragana and transcription). Two-level rules on the other hand are convenient whenever the related strings are variants of the same representation like in the example (spy+s,spies). Note that multi-partition morphology may use a one-to-one correspondence as one of its partitionings, and therefore is compatible with usual two-level morphology. With respect to rewrite rule systems, partitionbased morphology gives better support to parallel rule application and context definition may involve several levels. The counterpart is a risk of conflicts between contextual rules. Acknowledgement We would like to thank an anonymous referee of this paper for his/her helpful comments. References Barth´elemy. 2005. Partitioning multitape trans- In Workshop on Finite State in Natural Language Processing</abstract>
<address confidence="0.743732">Helsinki, Finland. Barth´elemy. 2006. Un analyseur mor-</address>
<affiliation confidence="0.771341">utilisant la jointure. In Aude la Langue Naturelle Leuven,</affiliation>
<address confidence="0.699837">Belgium. Alan Black, Graeme Ritchie, Steve Pulman, and Graham</address>
<note confidence="0.865421272727273">Russell. 1987. Formalisms for morphographemic In of the third conference on European chapter of the Association for Compu- Linguistics pages 11–18. Volker Diekert and Yves M´etivier. 1997. Partial commutation and traces. In G. Rozenberg and A. Salomaa, of Formal Languages, Vol. pages 457–534. Springer-Verlag, Berlin. Edmund Grimley-Evans, George Kiraz, and Stephen Pulman. 1996. Compiling a partition-based two-level In pages 454–459, Copenhagen, Denmark. Nizar Habash, Owen Rambow, and George Kiraz. 2005. Morphological analysis and generation for arabic di- In of the ACL Workshop on Ann Harbour, Michigan. Ronald M. Kaplan and Martin Kay. 1994. Regular modof phonological rule systems. Lin- 20:3:331–378. Andr´e Kempe, Jean-Marc Champarnaud, and Jason Eis- 2004. A note on join and auto-intersection of ary rational relations. In B. Watson and L. Cleophas,</note>
<affiliation confidence="0.701212">Eindhoven FASTAR Eindhoven,</affiliation>
<address confidence="0.794233">Netherlands.</address>
<author confidence="0.405011">Multitiered nonlinear mor-</author>
<abstract confidence="0.8139502">phology using multitape finite automata: a case study syriac and arabic. 26(1):77– 105. Kimmo Koskenniemi. 1983. Two-level model for moranalysis. In pages 683–685,</abstract>
<address confidence="0.8439">Karlsruhe, Germany.</address>
<note confidence="0.881920666666667">Stephen G. Pulman and Mark R. Hepple. 1993. A feature-based formalism for two-level phonology. Speech and 7:333–358. Anssi Yli-Jyr¨a and Kimmo Koskenniemi. 2004. Compiling contextual restrictions on strings into finite-state automata. In B. Watson and L. Cleophas, editors, Eindhoven FASTAR Eindhoven, Netherlands. 935</note>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Franc¸ois Barth´elemy</author>
</authors>
<title>Partitioning multitape transducers.</title>
<date>2005</date>
<booktitle>In International Workshop on Finite State Methods in Natural Language Processing (FSMNLP),</booktitle>
<location>Helsinki, Finland.</location>
<marker>Barth´elemy, 2005</marker>
<rawString>Franc¸ois Barth´elemy. 2005. Partitioning multitape transducers. In International Workshop on Finite State Methods in Natural Language Processing (FSMNLP), Helsinki, Finland.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Franc¸ois Barth´elemy</author>
</authors>
<title>Un analyseur morphologique utilisant la jointure.</title>
<date>2006</date>
<booktitle>In Traitement Automatique de la Langue Naturelle (TALN),</booktitle>
<location>Leuven, Belgium.</location>
<marker>Barth´elemy, 2006</marker>
<rawString>Franc¸ois Barth´elemy. 2006. Un analyseur morphologique utilisant la jointure. In Traitement Automatique de la Langue Naturelle (TALN), Leuven, Belgium.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Alan Black</author>
<author>Graeme Ritchie</author>
<author>Steve Pulman</author>
<author>Graham Russell</author>
</authors>
<title>Formalisms for morphographemic description.</title>
<date>1987</date>
<booktitle>In Proceedings of the third conference on European chapter of the Association for Computational Linguistics (EACL),</booktitle>
<pages>11--18</pages>
<contexts>
<context position="3119" citStr="Black et al., 1987" startWordPosition="487" endWordPosition="490">spondence between the surface form spies and the morpheme concatenation s p y 0 + s spy+s is given as follows: s p i e 0 s Same-length relations are closed under intersection, so two-level grammars describe a system as the simultaneous application of local constraints. A third approach, Partition-Based Morphology, consists in splitting the strings of a pair into the same number of substrings. The same-length constraint does not hold on symbols but on substrings. For example, spies and spy+s may be partitioned as s p y + s follows: s p ie c s The partition-based approach was first proposed by (Black et al., 1987) and further improved by (Pulman and Hepple, 1993) and (Grimley-Evans et al., 928 Proceedings of the 45th Annual Meeting of the Association of Computational Linguistics, pages 928–935, Prague, Czech Republic, June 2007. c�2007 Association for Computational Linguistics 1996). It has been used to describe the morphology of Syriac (Kiraz, 2000), Akkadian (Barth´elemy, 2006) and Arabic Dialects (Habash et al., 2005). These works use multi-tape transducers instead of usual two tape transducers, describing a special case of n-ary relations instead of binary relations. Definition 1 Partitioned n-rela</context>
</contexts>
<marker>Black, Ritchie, Pulman, Russell, 1987</marker>
<rawString>Alan Black, Graeme Ritchie, Steve Pulman, and Graham Russell. 1987. Formalisms for morphographemic description. In Proceedings of the third conference on European chapter of the Association for Computational Linguistics (EACL), pages 11–18.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Volker Diekert</author>
<author>Yves M´etivier</author>
</authors>
<title>Partial commutation and traces.</title>
<date>1997</date>
<booktitle>Handbook of Formal Languages,</booktitle>
<volume>3</volume>
<pages>457--534</pages>
<editor>In G. Rozenberg and A. Salomaa, editors,</editor>
<publisher>Springer-Verlag,</publisher>
<location>Berlin.</location>
<marker>Diekert, M´etivier, 1997</marker>
<rawString>Volker Diekert and Yves M´etivier. 1997. Partial commutation and traces. In G. Rozenberg and A. Salomaa, editors, Handbook of Formal Languages, Vol. 3, pages 457–534. Springer-Verlag, Berlin.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Edmund Grimley-Evans</author>
<author>George Kiraz</author>
<author>Stephen Pulman</author>
</authors>
<title>Compiling a partition-based two-level formalism.</title>
<date>1996</date>
<booktitle>In COLING,</booktitle>
<pages>454--459</pages>
<location>Copenhagen, Denmark.</location>
<contexts>
<context position="5544" citStr="Grimley-Evans et al., 1996" startWordPosition="834" endWordPosition="837">ionings of forms. Secondly, the compilation of such languages into finite-state machines has been exhaustively studied. Their closure properties provide operations useful for morphological purposes. They include the concatenation (for instance for compound words), the intersection used to merge local constraints, the union (modular lexicon), the composition (cascading descriptions, form recognition and generation), the projection (to extract one level of the relation), the complementation and set difference, used to compile contextual rules following the algorithms in (Kaplan and Kay, 1994), (Grimley-Evans et al., 1996) and (Yli-Jyr¨a and Koskenniemi, 2004). The use of the new semantics does not imply any change of the user-level formalisms, thanks to a straightforward homomorphism from partitioned n-relations to Mazurkiewicz Trace Languages. 2 Mazurkiewicz Trace Languages Within a given n-tuple, there is no meaningful order between symbols of the different levels. Mazurkiewicz trace languages is a theory which expresses partial ordering between symbols. They have been defined and studied in the realm of parallel computing. In this section, we recall their definition and some classical results. (Diekert and </context>
<context position="25432" citStr="Grimley-Evans et al., 1996" startWordPosition="4335" endWordPosition="4338">yorum, first compile it in the multi-tape trace language (g, 3)(e, 3)(l, 3) ... (m, 3), join it with the morphological description, and then project the result on tape 1 to obtain an abstract form (verbal root,1)(prog,1)(1 sing,1). Finally extract the first component of each pair. 6 Conclusion Partition-oriented rules are a convenient way to describe some of the constraints involved in the morphology of the language, but not all the constraints refer to the same partition notion. Describing a rule 2Two other compilation algorithm also work on the rules of this example (Kaplan and Kay, 1994), (Grimley-Evans et al., 1996). (Yli-Jyr¨a and Koskenniemi, 2004) is more general. 934 with an irrelevant one is sometimes difficult and inelegant. For instance, describing vowel harmony using a partitioning based on morphemes takes necessarily several rules corresponding to the cases where the harmony is within a morpheme or across several morphemes. Previous partition-based formalisms use a unique partitioning which is used in all the contextual rules. Our proposition is to use several partitionings in order to express constraints with the proper granularity. Typically, these partitionings correspond to the notions of mo</context>
</contexts>
<marker>Grimley-Evans, Kiraz, Pulman, 1996</marker>
<rawString>Edmund Grimley-Evans, George Kiraz, and Stephen Pulman. 1996. Compiling a partition-based two-level formalism. In COLING, pages 454–459, Copenhagen, Denmark.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Nizar Habash</author>
<author>Owen Rambow</author>
<author>George Kiraz</author>
</authors>
<title>Morphological analysis and generation for arabic dialects.</title>
<date>2005</date>
<booktitle>In Proceedings of the ACL Workshop on Semitic Languages,</booktitle>
<location>Ann Harbour, Michigan.</location>
<contexts>
<context position="3534" citStr="Habash et al., 2005" startWordPosition="549" endWordPosition="552">nstraint does not hold on symbols but on substrings. For example, spies and spy+s may be partitioned as s p y + s follows: s p ie c s The partition-based approach was first proposed by (Black et al., 1987) and further improved by (Pulman and Hepple, 1993) and (Grimley-Evans et al., 928 Proceedings of the 45th Annual Meeting of the Association of Computational Linguistics, pages 928–935, Prague, Czech Republic, June 2007. c�2007 Association for Computational Linguistics 1996). It has been used to describe the morphology of Syriac (Kiraz, 2000), Akkadian (Barth´elemy, 2006) and Arabic Dialects (Habash et al., 2005). These works use multi-tape transducers instead of usual two tape transducers, describing a special case of n-ary relations instead of binary relations. Definition 1 Partitioned n-relation A partitioned n-relation is a set of finite sequences of string n-tuples. For instance, the n-tuple sequence of the example (spy, spies) given above is (s, s)(p, p)(y, ie)(+, E)(s, s). Of course, all the partitioned n-relations are not recognizable using a finite-state machine. Grimley-Evans and al. propose a partition-based formalism with a strong restriction: the string n-tuples used in the sequences belo</context>
</contexts>
<marker>Habash, Rambow, Kiraz, 2005</marker>
<rawString>Nizar Habash, Owen Rambow, and George Kiraz. 2005. Morphological analysis and generation for arabic dialects. In Proceedings of the ACL Workshop on Semitic Languages, Ann Harbour, Michigan.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ronald M Kaplan</author>
<author>Martin Kay</author>
</authors>
<title>Regular models of phonological rule systems.</title>
<date>1994</date>
<journal>Computational Linguistics,</journal>
<pages>20--3</pages>
<contexts>
<context position="1973" citStr="Kaplan and Kay, 1994" startWordPosition="290" endWordPosition="293">nsducer. Relations are not oriented, so the same transducer may be used both for analysis and generation. They may be non-deterministic, when the same form belongs to several pairs. Furthermore, finite state machines have interesting properties, they are composable and efficient. There are two main trends in Finite-State Morphology: rewrite-rule systems and two-level rule systems. Rewrite-rule systems describe the morphology of languages using contextual rewrite rules which are easily applied in cascade. Rules are compiled into finite-state transducers and merged using transducer composition (Kaplan and Kay, 1994). The other important trend of Finite-State Morphology is Two-Level Morphology (Koskenniemi, 1983). In this approach, not only pairs of lexical and surface strings are related, but there is a one-to-one correspondence between their symbols. It means that the two strings of a given pair must have the same length. Whenever a symbol of one side does not have an actual counterpart in the other string, a special symbol 0 is inserted at the relevant position in order to fulfill the same-length constraint. For example, the correspondence between the surface form spies and the morpheme concatenation s</context>
<context position="5514" citStr="Kaplan and Kay, 1994" startWordPosition="830" endWordPosition="833">n using different partitionings of forms. Secondly, the compilation of such languages into finite-state machines has been exhaustively studied. Their closure properties provide operations useful for morphological purposes. They include the concatenation (for instance for compound words), the intersection used to merge local constraints, the union (modular lexicon), the composition (cascading descriptions, form recognition and generation), the projection (to extract one level of the relation), the complementation and set difference, used to compile contextual rules following the algorithms in (Kaplan and Kay, 1994), (Grimley-Evans et al., 1996) and (Yli-Jyr¨a and Koskenniemi, 2004). The use of the new semantics does not imply any change of the user-level formalisms, thanks to a straightforward homomorphism from partitioned n-relations to Mazurkiewicz Trace Languages. 2 Mazurkiewicz Trace Languages Within a given n-tuple, there is no meaningful order between symbols of the different levels. Mazurkiewicz trace languages is a theory which expresses partial ordering between symbols. They have been defined and studied in the realm of parallel computing. In this section, we recall their definition and some cl</context>
<context position="16825" citStr="Kaplan and Kay, 1994" startWordPosition="2766" endWordPosition="2769">). The closure (Kleene star) operation creates a new iterative factor and therefore, the result may be a non recognizable trace language. Here again, concatenating a global synchronization point at the end of the language gives a trace language closed under Kleene star. By definition, such a language is connected. Furthermore, the result is in normal form. So far, operations have operands and the result belonging to the same Multi-tape Monoid. It is not the case of the last two operations: projection and join. We use the the operators Dom, Range, and the relations Id and Insert as defined in (Kaplan and Kay, 1994): • Dom(R) = {x|ly, (x, y) E R} • Range(R) = {y|]x, (x, y) E R} • Id(L) = {(x,x)|x E L} • Insert(5) = (Id(E) U ({E} x 5))*. It is used to insert freely symbols from 5 in a string from E*. Conversely, Insert(5)−1 removes all the occurrences of symbols from 5, if 5 n E = 0. The result of a projection operation may not be recognizable if it deletes symbols making iterative factors connected. Furthermore, when the result is recognizable, the projection on Min(T) is not necessarily in normal form. Both phenomena come from the deletion of synchronization points. Therefore, a projection which deletes</context>
<context position="25402" citStr="Kaplan and Kay, 1994" startWordPosition="4331" endWordPosition="4334">nize a surface form geliyorum, first compile it in the multi-tape trace language (g, 3)(e, 3)(l, 3) ... (m, 3), join it with the morphological description, and then project the result on tape 1 to obtain an abstract form (verbal root,1)(prog,1)(1 sing,1). Finally extract the first component of each pair. 6 Conclusion Partition-oriented rules are a convenient way to describe some of the constraints involved in the morphology of the language, but not all the constraints refer to the same partition notion. Describing a rule 2Two other compilation algorithm also work on the rules of this example (Kaplan and Kay, 1994), (Grimley-Evans et al., 1996). (Yli-Jyr¨a and Koskenniemi, 2004) is more general. 934 with an irrelevant one is sometimes difficult and inelegant. For instance, describing vowel harmony using a partitioning based on morphemes takes necessarily several rules corresponding to the cases where the harmony is within a morpheme or across several morphemes. Previous partition-based formalisms use a unique partitioning which is used in all the contextual rules. Our proposition is to use several partitionings in order to express constraints with the proper granularity. Typically, these partitionings c</context>
</contexts>
<marker>Kaplan, Kay, 1994</marker>
<rawString>Ronald M. Kaplan and Martin Kay. 1994. Regular models of phonological rule systems. Computational Linguistics, 20:3:331–378.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Andr´e Kempe</author>
<author>Jean-Marc Champarnaud</author>
<author>Jason Eisner</author>
</authors>
<title>A note on join and auto-intersection of nary rational relations.</title>
<date>2004</date>
<editor>In B. Watson and L. Cleophas, editors, Proc. Eindhoven FASTAR Days,</editor>
<location>Eindhoven, Netherlands.</location>
<contexts>
<context position="18178" citStr="Kempe et al., 2004" startWordPosition="3015" endWordPosition="3018">n the result of the projection because all but possibly one of its tapes have been deleted. In the tape-oriented computation system, we are mainly interested in the projection which deletes some tapes and possibly some related synchronization points. Property 2 Projection Let T be a trace language over the MTM M = (E, O, w, µ). Let Q1 C Q and O1 C O. If 932 ∀w ∈ Ω − Ω1, |µ(w) ∩ Θ1 |≤ 1, then Min(7rΘ1,Ω1(T)) = Range(Insert({x ∈ Σ|µ(x) ∈� Θ1} ∪ Ω − Ω1)−1 ◦ Min(T)) The join operation is named by analogy with the operator of the relational algebra. It has been defined on finite-state transducers (Kempe et al., 2004). Definition 3 Multi-tape join Let T1 ⊂ MTM(Σ1, Θ1, Ω1,µ1) and T2 ⊂ TM(Σ2, Θ2,Ω2, µ2) be two multi-tape trace languages. T1 ✶ T2 is defined if and only if • ∀U ∈ Σ1 ∩ Σ2, µ1(U) ∩ Θ2 = µ2(U) ∩ Θ1 • ∀w ∈ Ω1 ∩ Ω2, µ1(w) ∩ Θ2 = µ2(w) ∩ Θ1 The Multi-tape Trace Language T1 ✶ T2 is defined on the Multi-tape Partially Commutative Monoid MTM(Σ1∪Σ2, Θ1∪Θ2, Ω1∪Ω2, µ) where µ(x) = µ1(x) ∪ µ2(x). It is defined by 7rΣ1uΘ1uΩ1(T1 ✶ T2) = T1 and 7rΣ2uΘ2uΩ2(T1 ✶ T2) = T2. If the two operands T1 and T2 belong to the same MTM, then T1 ✶ T2 = T1 ∩ T2. If the operands belong to disjoint monoids (which do not share </context>
</contexts>
<marker>Kempe, Champarnaud, Eisner, 2004</marker>
<rawString>Andr´e Kempe, Jean-Marc Champarnaud, and Jason Eisner. 2004. A note on join and auto-intersection of nary rational relations. In B. Watson and L. Cleophas, editors, Proc. Eindhoven FASTAR Days, Eindhoven, Netherlands.</rawString>
</citation>
<citation valid="true">
<authors>
<author>George Anton Kiraz</author>
</authors>
<title>Multitiered nonlinear morphology using multitape finite automata: a case study on syriac and arabic.</title>
<date>2000</date>
<journal>Comput. Linguist.,</journal>
<volume>26</volume>
<issue>1</issue>
<pages>105</pages>
<contexts>
<context position="3462" citStr="Kiraz, 2000" startWordPosition="541" endWordPosition="542">of a pair into the same number of substrings. The same-length constraint does not hold on symbols but on substrings. For example, spies and spy+s may be partitioned as s p y + s follows: s p ie c s The partition-based approach was first proposed by (Black et al., 1987) and further improved by (Pulman and Hepple, 1993) and (Grimley-Evans et al., 928 Proceedings of the 45th Annual Meeting of the Association of Computational Linguistics, pages 928–935, Prague, Czech Republic, June 2007. c�2007 Association for Computational Linguistics 1996). It has been used to describe the morphology of Syriac (Kiraz, 2000), Akkadian (Barth´elemy, 2006) and Arabic Dialects (Habash et al., 2005). These works use multi-tape transducers instead of usual two tape transducers, describing a special case of n-ary relations instead of binary relations. Definition 1 Partitioned n-relation A partitioned n-relation is a set of finite sequences of string n-tuples. For instance, the n-tuple sequence of the example (spy, spies) given above is (s, s)(p, p)(y, ie)(+, E)(s, s). Of course, all the partitioned n-relations are not recognizable using a finite-state machine. Grimley-Evans and al. propose a partition-based formalism w</context>
</contexts>
<marker>Kiraz, 2000</marker>
<rawString>George Anton Kiraz. 2000. Multitiered nonlinear morphology using multitape finite automata: a case study on syriac and arabic. Comput. Linguist., 26(1):77– 105.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kimmo Koskenniemi</author>
</authors>
<title>Two-level model for morphological analysis.</title>
<date>1983</date>
<booktitle>In IJCAI-83,</booktitle>
<pages>683--685</pages>
<location>Karlsruhe, Germany.</location>
<contexts>
<context position="2071" citStr="Koskenniemi, 1983" startWordPosition="305" endWordPosition="306">ion. They may be non-deterministic, when the same form belongs to several pairs. Furthermore, finite state machines have interesting properties, they are composable and efficient. There are two main trends in Finite-State Morphology: rewrite-rule systems and two-level rule systems. Rewrite-rule systems describe the morphology of languages using contextual rewrite rules which are easily applied in cascade. Rules are compiled into finite-state transducers and merged using transducer composition (Kaplan and Kay, 1994). The other important trend of Finite-State Morphology is Two-Level Morphology (Koskenniemi, 1983). In this approach, not only pairs of lexical and surface strings are related, but there is a one-to-one correspondence between their symbols. It means that the two strings of a given pair must have the same length. Whenever a symbol of one side does not have an actual counterpart in the other string, a special symbol 0 is inserted at the relevant position in order to fulfill the same-length constraint. For example, the correspondence between the surface form spies and the morpheme concatenation s p y 0 + s spy+s is given as follows: s p i e 0 s Same-length relations are closed under intersect</context>
</contexts>
<marker>Koskenniemi, 1983</marker>
<rawString>Kimmo Koskenniemi. 1983. Two-level model for morphological analysis. In IJCAI-83, pages 683–685, Karlsruhe, Germany.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Stephen G Pulman</author>
<author>Mark R Hepple</author>
</authors>
<title>A feature-based formalism for two-level phonology. Computer Speech and Language,</title>
<date>1993</date>
<pages>7--333</pages>
<contexts>
<context position="3169" citStr="Pulman and Hepple, 1993" startWordPosition="495" endWordPosition="499">the morpheme concatenation s p y 0 + s spy+s is given as follows: s p i e 0 s Same-length relations are closed under intersection, so two-level grammars describe a system as the simultaneous application of local constraints. A third approach, Partition-Based Morphology, consists in splitting the strings of a pair into the same number of substrings. The same-length constraint does not hold on symbols but on substrings. For example, spies and spy+s may be partitioned as s p y + s follows: s p ie c s The partition-based approach was first proposed by (Black et al., 1987) and further improved by (Pulman and Hepple, 1993) and (Grimley-Evans et al., 928 Proceedings of the 45th Annual Meeting of the Association of Computational Linguistics, pages 928–935, Prague, Czech Republic, June 2007. c�2007 Association for Computational Linguistics 1996). It has been used to describe the morphology of Syriac (Kiraz, 2000), Akkadian (Barth´elemy, 2006) and Arabic Dialects (Habash et al., 2005). These works use multi-tape transducers instead of usual two tape transducers, describing a special case of n-ary relations instead of binary relations. Definition 1 Partitioned n-relation A partitioned n-relation is a set of finite s</context>
</contexts>
<marker>Pulman, Hepple, 1993</marker>
<rawString>Stephen G. Pulman and Mark R. Hepple. 1993. A feature-based formalism for two-level phonology. Computer Speech and Language, 7:333–358.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Anssi Yli-Jyr¨a</author>
<author>Kimmo Koskenniemi</author>
</authors>
<title>Compiling contextual restrictions on strings into finite-state automata.</title>
<date>2004</date>
<editor>In B. Watson and L. Cleophas, editors, Proc. Eindhoven FASTAR Days,</editor>
<location>Eindhoven, Netherlands.</location>
<marker>Yli-Jyr¨a, Koskenniemi, 2004</marker>
<rawString>Anssi Yli-Jyr¨a and Kimmo Koskenniemi. 2004. Compiling contextual restrictions on strings into finite-state automata. In B. Watson and L. Cleophas, editors, Proc. Eindhoven FASTAR Days, Eindhoven, Netherlands.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>