<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000014">
<title confidence="0.946728">
Describing Syntax with Star-Free Regular Expressions
</title>
<author confidence="0.987921">
Anssi Yli-Jyra
</author>
<affiliation confidence="0.984163">
Department of General Linguistics, P.O. Box 9, FIN-00014 Univ. of Helsinki, Finland
</affiliation>
<email confidence="0.457044">
anssi .yli—jyra@helsinki fi
</email>
<sectionHeader confidence="0.981952" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.996339368421053">
Syntactic constraints in Koskenniemi&apos;s
Finite-State Intersection Grammar
(FSIG) are logically less complex than
their formalism (Koskenniemi et al.,
1992) would suggest: It turns out that
although the constraints in Voutilainen&apos;s
(1994) FSIG description of English
make use of several extensions to
regular expressions, the description as a
whole reduces to a finite combination of
union, complement and concatenation.
This is an essential improvement to the
descriptive complexity of ENGFSIG.
The result opens a door for further anal-
ysis of logical properties and possible
optimizations in the FSIG descriptions.
The proof contains a new formula for
compiling Koskenniemi&apos;s restriction
operation without any marker symbols.
</bodyText>
<sectionHeader confidence="0.998882" genericHeader="keywords">
1 Introduction
</sectionHeader>
<bodyText confidence="0.999821803921569">
For many years, various finite-state models of
language (Roche and Schabes, 1997) have been
used in surface-syntactic parsing. These mod-
els can process local syntactic ambiguity effi-
ciently. However, because the formalism of Finite-
State Intersection Grammar (Koskenniemi, 1990;
Koskenniemi et al., 1992) allows full regular
expressions, its parsing is sometimes inefficient
(Tapanainen, 1997); many FSIG constraint au-
tomata can reduce ambiguity only after they have
scanned the whole sentence.
Regular expressions in FSIG can be viewed as
a grammar-writing tool that should be as flexible
as possible. This viewpoint has led to introduction
of new features into the formalism (Koskenniemi
et al., 1992). It is, however, very difficult to make
any a priori generalizations of the structural prop-
erties of automata as long as we allow unrestricted
use of regular expressions.
A complementary view is to analyze the prop-
erties of languages described by FSIG regular
expressions. We can carry out the analysis by
checking whether the languages can be described
with a restricted class of regular expressions. For
many such classes of expressions, there also ex-
ists a group-theoretic characterization (Pin, 1986).
Moreover, if the analyzed regular language has
favorable properties, some problems, e.g. the
string membership problem, can be solved faster
by means of specialized algorithms.
A language can be described with a star-free
regular expression if it can be constructed from
alphabet symbols by application of union (A U
B), complementation (A) and finite concatena-
tion (AB), that is, without the Kleene closure
(A*). The theoretical importance of this class
of languages is supported by its characterization
in terms of finite aperiodic syntactic monoids
(Schiitzenberger, 1965) and by its definability in
first-order logic over strings (McNaughton and Pa-
pert, 1971). The class has also a lot of practical
importance, because many languages in it admit
extremely simple implementations (ibid.).
The question of the star-freeness restriction on
FSIG constraints has not been studied before, pos-
sibly because of the following observations:
(i) An acyclic automaton representing readings
of the sentence has a central role in FSIG
parsing (Tapanainen, 1997). Star-freeness of
the constraints is a minor restriction when
compared to the finiteness of this language.
</bodyText>
<page confidence="0.998139">
379
</page>
<bodyText confidence="0.972286018867925">
(ii) If automata states are encoded as &amp;quot;traces&amp;quot;
into strings, any regular language can be rep-
resented as a homomorphic image of a (local)
star-free language (Medvedev, 1964). Such
an encoding is possible in a two-level view
of the FSIG framework (Koskenniemi, 1997),
where the morphological reading of the sen-
tence is a homomorphic image of a level rep-
resenting syntactically annotated readings.
(iii) Given a finite automaton or a regular expres-
sion, checking star-freeness of the described
language is an intractable (see 2.2) problem.
(iv) Automatical methods to derive star-free reg-
ular expressions from another representa-
tions procuce long and unintuitive expres-
sions (Matz et al., 1995).
From my point of view, these observations miss
some important perspectives: Firstly (i), it is im-
portant to understand that a finite-state intersection
grammar is also a description of a language with
a structure of its own, independent of the acyclic
sentence automaton. Secondly (ii), a realistic
FSIG description is linguistically motivated and
leaves little room for encoding of traces that could
technically make the grammar star-free. Thirdly
(iii), heuristic methods can be used to solve many
large star-freeness problems in practice. Fourthly
(iv), it is often possible to find star-free regular ex-
pressions that are short and illustrative, as it turns
out in this paper.
Any automaton recognizing a non-star-free lan-
guage has a factor that induces a nontrivial per-
mutation of the state space. For example, the par-
ity language 0* (10*10*)* contains strings with an
even number of occurrences of the factor &amp;quot;1&amp;quot;. In-
tuitively, it seems improbable that similar counting
constraints occur in natural language grammars
However, many regular expressions in Vouti-
lainen&apos;s ENGFSIG (1994) involve the Kleene star.
If we can explain why this does not affect the star-
freeness of the language, we probably know more
about the grammar itself.
A significant contribution of this paper is the
human-readable construction that rephrases ENG-
FSIG (Voutilainen, 1994) constraints without the
Kleene star. To make the construction more sys-
tematic I first outline the framework of FSIG and
define its star-freeness problem. After this I ex-
plore stars in the ENGFSIG description and reduce
regular expressions in the description into their
star-free equivalents. This approach extends to a
closure property of the star-free regular languages
under the restriction operator (of FSIG).
</bodyText>
<sectionHeader confidence="0.975506" genericHeader="introduction">
2 Finite-State Intersection Grammar
</sectionHeader>
<bodyText confidence="0.9997768">
In this section I define a class of finite-state in-
tersection grammars and explain the star-freeness
problem specific to them. The FSIG framework
developed here is based on the work of Kosken-
niemi, Tapanainen and Voutilainen (1992).
</bodyText>
<subsectionHeader confidence="0.842158">
2.1 Definitions
</subsectionHeader>
<bodyText confidence="0.99105612">
I start by making my terminology on the strings
described precise. In FSIG, a sentence is seen as
a syntactically annotated string that is exemplified
in the following string:
II @@ time N NOM SG @SUBJ @
fly ✓ PRES SG3 @MV @
like PREP @ADVL @
an DET ART SG @&gt;N @
arrow N NOM SG @P« @@&amp;quot;
This string of tags represents a possible syntac-
tic structure for the sentence &apos;time flies like an ar-
row&apos;. In the example, all the tags that start with an
-sign contribute to the syntactic analysis. In this
example, the tags @@ and @ denote sentence and
word boundaries, respectively. They delimit word
analyses. For each word, the morphological anal-
ysis like &amp;quot;time N NOM SG&amp;quot; precedes the tags that
denote the syntactic function of the word. Syn-
tactic tags specify, in this example, that the word
&apos;time&apos; functions as the subject (@suBJ), and the
word &apos;arrow&apos; is the complement for a preposition
on the left (@p«).
An (unweighted) finite-state intersection gram-
mar is a tuple G = (EB, w, EF, B, W, F, C.
d), in which
</bodyText>
<listItem confidence="0.996810142857143">
• EB, Ew EF c E are disjoint alphabets,
• B C EB is a set of delimiters that can appear
before and after word analyses,
• W c EiFv, is a finite lexicon of morphologi-
cal analyses,
• F C EIEF, is a finite set of tag strings that
denote syntactic functions, and,
</listItem>
<page confidence="0.877765">
380
</page>
<listItem confidence="0.9948852">
• C = fefi, is a set of finite-state
constraints (regular languages) with the al-
phabet E, where
• d C N is a finite bound for the maximum
center-embedding depth in the constraints.
</listItem>
<bodyText confidence="0.996614666666667">
The regular set D = B(W F B)± is the domain of
annotated strings. The language described by the
grammar G is defined by the set L(C) = D n
cfl fl cY ckl, c1 1-1 end. The first k con-
straints apply locally to each word, matching mor-
phological analyses with potential syntactic func-
tions. I call them local lexical constraints. All the
constraints are expressed by means of FSIG regu-
lar expressions.
Any symbol a E E, as well as any symbol set
{al, a2, , arn}, al, a2.... , e E, are valid
FSIG regular expressions. The language consist-
ing of the empty string is denoted with E (or [] in
the FSIG notation). In addition to the simple op-
erators (Table 1) that combine expressions A and
B, FSIG regular expressions make use of the re-
striction operator (Koskenniemi, 1983). It has the
following syntax:
</bodyText>
<equation confidence="0.942027">
X LC i _ RC1, LC2 _ RC2. • • • , LC n _ RCn
</equation>
<bodyText confidence="0.931739142857143">
The operands X, LCi, , RC, are FSIG regular
expressions. The semantics of the whole expres-
sion is as follows: Whenever a substring x C X oc-
curs in the string w, its context must match at least
one of the patterns LC, _ RC,, i = 1..n. When
there are overlapping occurrences of the center X,
the string w is rejected if any of the occurrences
infringes the restriction (this is the strict interpre-
tation of the operator).
A center-embedded clause is an embedded
clause that is not the leftmost neither the rightmost
constituent in its matrix clause. In the ENGFSIG
The FSIG The current Preced- Semantics of
notation notation ence the expression
</bodyText>
<figure confidence="0.9532511">
[A[ [A] (6) A
(A) A (6) A U
—A A or --A 5 {,xxEE*Axi}
A+ 4 AA* i
A* A* 4 Ui7c, AA...A
\A SA or —SA 3
AB AB 2 {xylxEAAyEB}
A B A U B 1 {xhreAVxeB}
A &amp; B AnB I TA u—B]
N/A A — B 1 A n—B
</figure>
<tableCaption confidence="0.977618">
Table 1: Combinations of expressions A and B.
</tableCaption>
<bodyText confidence="0.995407894736842">
representation, a finite center-embedded clause is
separated from its matrix clause with a pair of
delimiters @&lt;c B and @&gt;E B. Sequential clause
boundaries are denoted (ambiguously) with the
delimiter @/ EB. Special constants (Koskenniemi
et al., 1992) are used to facilitate description of
complex patterns involving the delimiter symbols
EB, Eg B,B = {@,@&lt;,@&gt;,@/,@@}. The in-
tuitive meaning of the constants in Table 2 is as
follows: The dot H accepts tag sequences of
and EF inside word analyses, the expression
accepts tag sequences of Ew, EF and @, and the
constant @&lt;&gt; accepts a center-embedded clause
with possible nested center-embeddings. The dot-
dotl I differs from the expression &gt;••&lt; by ac-
cepting anything within the same clause, includ-
ing center-embedded clauses. Finally, the dots
I • • • accepts anything at the same level of center-
embedding.
</bodyText>
<figure confidence="0.725925166666667">
FS1G Current Semantics
Eg
[H ]-] {@}]*
(explained in the text)
[H u {@} U @&lt;&gt;1*
[E u {@, @/} @&lt;&gt;]*
</figure>
<tableCaption confidence="0.96409">
Table 2: The special constant expressions.
</tableCaption>
<bodyText confidence="0.9996245">
The parameter d specifying the maximum
depth of center-embedding is an essential element
of the FSIG regular expressions. The bound is
needed to compile constraints that contain the
constant @ &lt;&gt;, because the idealized language
described by the constant @&lt;&gt; is context-
free, in fact, a counter language in terms of
Schtitzenberger (1962). In a practical implemen-
tation (Koskenniemi et al., 1992), the language
1&lt;&gt; is approximated with a regular language. I
denote the approximation using the parameterized
expression @ &lt;&gt;d (Figure 1). The generic expres-
sions @&lt;&gt;&apos;, i C 1, 2, 3, ... , as well as the con-
stants I •• Id and i• • • d are defined as follows:
</bodyText>
<equation confidence="0.9154378">
=6
.@&lt; [ [ E U {@,@/}1* @&lt;&gt; 1*
[H u {@, @/}]* @&gt;
[H u {@} @&lt;›dr
= [El U {@,@/} U@&lt;&gt;dr
</equation>
<bodyText confidence="0.99879375">
Finally, FSIG regular expressions may contain
user-defined macros as subexpressions. They can
have a constant value or take other expressions as
arguments.
</bodyText>
<figure confidence="0.954895454545455">
&gt; • • &lt;
&gt;..&lt; I&gt;•-‹
@&lt;&gt; @&lt;&gt;
I I
• ••
e&lt;&gt; 0
@&lt;&gt;
•• I
i • ••
381
Owipl 1
</figure>
<figureCaption confidence="0.989951">
Figure 1: A finite automaton (? = E— {@&lt;, @&gt;})
that visualizes the semantics of 8&lt;&gt; d.
</figureCaption>
<subsectionHeader confidence="0.952771">
2.2 Star-freeness problem for an FSIG
</subsectionHeader>
<bodyText confidence="0.997110375">
The problem I want to solve for an FSIG is the
star-freeness problem. It is, given a grammar G, to
determine whether the language L(G) is star-free
i.e. whether it can be constructed from alphabet
symbols by application of the boolean operators
(U, and concatenation.
Proposition 1. For a regular language L, the fol-
lowing properties are equivalent:
</bodyText>
<listItem confidence="0.996635818181818">
• the language L is star-free,
• there is a starfree regular expression, based
on concatenation and the boolean operators,
that describes the language L,
• the syntactic monoid (McNaughton and Pa-
pert, 1968) that is canonically assigned to
the language L is aperiodic (Schiitzenberger,
1965),
• the language L is definable in propositional
linear temporal logic (Kamp, 1968), and,
• the language L is definable in a first-order
</listItem>
<bodyText confidence="0.927102">
logic that is interpreted over finite strings
(McNaughton and Papert, 1971).
Sometimes star-freeness of a language can be
shown by means of closure properties of star-free
languages. To start with, finite regular languages
are star-free (especially 0, 6, a, and F, where 0 de-
notes the empty set of strings, a CE, and F C E)
The Kleene closure of any subset F C E is also
star-free, because I&apos; = 0[E — F10. If A and
B are star-free languages, then we know that at
least the following languages are star-free (Mc-
Naughton and Papert, 1971):
</bodyText>
<sectionHeader confidence="0.74008" genericHeader="method">
AB A $A AuB AnB A- B
</sectionHeader>
<bodyText confidence="0.987952263157895">
It is also possible that the language of a regu-
lar expression is star-free although the expression
contains the Kleene star operator. Therefore, the
method based on the properties of the syntactic
monoid of the language is important. The syntac-
tic monoid is usually difficult to compute manu-
ally, and some programs, e.g. AMoRe (Matz et
al., 1995) are designed to facilitate these compu-
tations and aperiodicity testing. The aperiodicity
problem is, however, computationally intractable
(PSPACE-complete) both for regular expressions
(Bernatsky, 1997) and for deterministic automata
(Cho and Huynh, 1991).
It is often possible to heuristically prove the
star-freeness property by inventing an equivalent
star-free expression.
Proposition 2. In order to show that a finite-state
intersection grammar G is star-free, it is sufficient
to show that:
</bodyText>
<listItem confidence="0.99917075">
• the domain B(WFB)± is star-free,
• the local lexical constraints , ck!
are star-free,
• the constants El , .• I , ,&gt;••&lt;[ , @&lt;&gt; and
other subexpressions in the constraints are
star-free, and,
• the star-free languages are closed under the
operators that combine the subexpressions
</listItem>
<bodyText confidence="0.864125">
into the constraints c4d,±1, . . . , cmd.
</bodyText>
<sectionHeader confidence="0.86089" genericHeader="method">
3 The reduction of ENGFSIG into
star-free expressions
</sectionHeader>
<subsectionHeader confidence="0.983231">
3.1 The domain of annotated strings
</subsectionHeader>
<bodyText confidence="0.989332538461538">
Because the alphabets EB, Ew and EF are dis-
joint and the sets B, W and F do not contain
an empty string, the set S = E-MEiFvEIFF,*+
can be expressed as [E-Ew n [E*EFEL] n
-EB n -$[Ew[E-Ew —EF1] n
-$[EF[ -EF —EB]] . The remaining question
is, whether the sets B, W and F are star-free
languages. In the case of ENGFSIG they are
finite, and therefore, each of them is express-
ible with a star-free regular expression. Hence
the iteration in B(WFB)± translates to S n
[BET47 n [E*EFB] n—S[EB[Ei&apos;v —WIEF] n
— F] EB] n $[F[ -B]7]
</bodyText>
<subsectionHeader confidence="0.99591">
3.2 The local lexical constraints
</subsectionHeader>
<bodyText confidence="0.999972">
The relation between the morphological analyses
and the allowed syntactic functions can be im-
plemented either with one or two levels (Kosken-
niemi, 1997) in a practical FSIG parser. In the
grammar G, this relation corresponds to a set of
lexical constraints efi,d,. , c.
</bodyText>
<page confidence="0.992362">
382
</page>
<bodyText confidence="0.9999628">
In the case of ENGFSIG, the local lexical con-
straints reduce to a boolean combination of lan-
guages of the form St, t CEw U EF , because the
tag positions in the strings of W and F are fixed
by a convention that partly reflects the simple mor-
pheme structure of English words. Let the lexi-
cal constraints in conjunction with the domain D
describe the set B (LwFB)± , LITT, C WF. The
conformance to this property is enforced by the
following star-free constraint:
</bodyText>
<equation confidence="0.397839">
D flE*EB [Ei1P,vE1, — Im/F] EBE*
</equation>
<subsectionHeader confidence="0.922838">
3.3 The constant expressions
</subsectionHeader>
<bodyText confidence="0.999140666666667">
It is pretty easy to see that the expressions @&lt;&gt;
and @&lt;&gt;1 are star-free. I managed to find an
inductive derivation for general case @&lt;&gt;z. i E
</bodyText>
<figure confidence="0.832377266666667">
1.2 3 The following defines the dependent
constants @&lt;&gt; and I • • 11, as well as the
constant &gt;• • &lt; with star-free operators:
=
• • ° ${@&lt;, @&gt;, @@}
e&lt;&gt;0 c
i-1
[ @&lt;] [ [06&lt;1
&gt;i 0 e&gt;1
U... @&gt;I
= $@@ n $[@&lt; @&lt;i] n $[@&gt; 6&gt;
• • I —16&gt;E* n E* e&lt; • • • I 2-1
@&lt;&gt;&apos; = @&lt; @&gt;
•• I • • n @/
I&gt;..&lt; = —$[Es — @1
</figure>
<subsectionHeader confidence="0.447982">
3.4 The subexpressions with the Kleene star
</subsectionHeader>
<bodyText confidence="0.9996477">
The version of ENGFSIG studied contains 983
subexpressions (of 221 types) containing the
Kleene star operator. Each iterated subexpression
seems to have two components: (i) a domain of
iteration which specifies what kind of unit is iter-
ated, and (ii) a condition which specifies the neces-
sary property for each unit. By unifying every left-
oriented domain of iteration (e.g. Li @) with the
corresponding right-oriented domain (e.g. @ H ), I
identified four variants of domains (Table 3).
</bodyText>
<table confidence="0.9947864">
Domain Freq. Iterated unit (R) Conditions
R/Lword 938 @H 196
R/Lclause 42 @/ I •• I 22
_Wafter 2 {@/,@&lt;} 2
R/Lembelled @&lt; I -• I 1
</table>
<tableCaption confidence="0.999887">
Table 3: The four domains of iteration.
</tableCaption>
<bodyText confidence="0.999810090909091">
The domain and the condition are seldom sepa-
rated in a ENGFSIG regular expression. Instead,
the condition is usually inside the Kleene closure
that specifies the domain. For example in the
subexpression [@H 6&gt;A ]*, the domain is a word
preceded by a word boundary (@ 17), and the con-
dition is that each word must be an adjective-pre-
modifier.
Iteration of the right-oriented domains corre-
sponds to the following star-free regular expres-
sions:
</bodyText>
<equation confidence="0.965244714285714">
d]
/Clause = U [@/ d]
• I d@, E* n
$@@ n $[@&gt; @&gt;d] [1
Re*mbedded = U [ @ &lt; [
E @/ ...1d6&gt;E* n $@@ n $[@&gt;@&gt;d] n
$@&lt; n E&apos; @/ $@&gt; 11
</equation>
<bodyText confidence="0.966100133333333">
ENGFSIG associates typically very simple con-
ditions with the domain of iteration. In the star-
free form of a starred expression, the domain of
iteration and the associated condition are defined
separately and then combined under the intersec-
tion operator. In the following, I give some exam-
ples of possible conditions and how they are rep-
resented in separation from the domain:
• The phrase &amp;quot;every @&gt;N 6, 000 @&gt;N miles N
@ADVL&amp;quot; satisfies the constraint &amp;quot;N H @ADVL
every IE 6&gt;N 6 [IE @&gt;NIE @]x E 9.
In [H @&gt;N @1*, the domain of iteration
is Lword, a reverse counterpart to Rword.
The corresponding condition is as follows:
—[ ${@, e&gt;N} e E&apos;] n —$[@ $ @&gt;N @].
</bodyText>
<listItem confidence="0.994676">
• Conditions often specify the absence of
</listItem>
<bodyText confidence="0.874109">
a word (or a tag). The closure [[H n
$pET] @&gt;N[111 n$DET] 61* can be simplified as
follows: [H @&gt;N @]* n $DET.
</bodyText>
<listItem confidence="0.964696">
• If the domain of iteration is the clause
//clause, then the condition may require that
each clause contains a main verb (@mv).
Such a condition translates as follows:
—[E* ${@ /, my}} n —$[@/ $mv @/1.
• Sometimes the iterated clause Rclause is not
allowed to contain center-embeddings. This
condition reads: —${@&lt;, @&gt;}.
</listItem>
<equation confidence="0.996507">
RLrd = c U [6 &gt;••&lt;
I • • • d@, E* n
</equation>
<page confidence="0.994545">
383
</page>
<bodyText confidence="0.971763166666667">
ENGFSIG contains only 12 examples of nested
Kleene stars. One example is in the following:
[@/ [@commalcc]H @]* H @cc ]- 1]*
In all these cases, the inner application of
Kleene star can be expressed as a condition ap-
plying to the domain of the outer iteration level.
</bodyText>
<subsectionHeader confidence="0.958307">
3.5 The restriction operator
</subsectionHeader>
<bodyText confidence="0.999958523809524">
In Section 3.2, I have described how the lo-
cal lexical constraints can be represented with-
out the Kleene star operator. In addition to these,
there are 2657 more complicated constraints. The
schematic equivalences presented in Sections 3.3
— 3.4 can transform 1554 of these into a star-free
form. However, there still remain 1103 constraints
that use the restriction operator To complete
the proof of the star-freeness of ENGFSIG, I show
that star-free languages are closed under the re-
striction operation (as in FSIG).
Compilation of the restriction operator (as
in Two-Level Morphology) has been solved by
means of marker symbols and transducers (Kart-
tunen et al., 1987; Kaplan and Kay, 1994). To
compile the restriction as in FSIG, Tapanainen
(1992) used also a method that is perhaps most
easily described with transducers. When there is
only one context LC1 _ RC1, the restriction oper-
ator (as in TWOL and in FSIG) reduces to the fol-
lowing star-free formula (Karttunen et al., 1987):
</bodyText>
<equation confidence="0.942141">
E*LCi X 0 n 0 X Rci E*
I generalize this special case in the following
new formula for n contexts LC i _ i = 1..n:
71
n [ nn _,) LCi ] X n RCi(i.F)
i=1 i=1
where S = {1, 2,... , n} and
E*
ificF
0 otherwise;
</equation>
<bodyText confidence="0.996407222222222">
The above formula does not use markers, trans-
ducers, nor the Kleene star. Intuitively, it says that
the string is rejected on the basis of the match of
X, if each of the n contexts around a match of X
fails at least on one side (0(i, S — ,F) 05(i, Jr)).
There are 2n different ways (.T = {}, {1}, {2},
{1,2},..{1, 2,... , n}) to choose a failing side for
every member in the set of contexts LC i, _
i = 1..n.
</bodyText>
<sectionHeader confidence="0.987492" genericHeader="method">
4 Experiments
</sectionHeader>
<bodyText confidence="0.999945644444444">
I initially extracted the starry subexpressions from
the ENGFSIG grammar and classified them using
a Perl script. At a later stage, I developed a reg-
ular expression preprocessor that automated many
tasks. The results were compared across different
formulas in order to find possible differences.
The preprocessor could output a script where
operands for each restriction operator were de-
fined (and compiled into automata) before the op-
erator was applied. Every bunch of operand defini-
tions was followed by a formula that implemented
the restriction operator with a required number of
contexts. In order to reduce the number of con-
texts, I gathered unilateral contexts with the pre-
processor.
I developed and tested the presented equiva-
lences using the Xerox Finite-State Tool (v.7.4.0).
My new formula for the restriction operator pro-
duced automata that were equivalent to the output
of Tapanainen&apos;s rule compiler (Koskenniemi et al.,
1992), which was actually used during the devel-
opment of ENGFSIG.
I also compared these automata to the ones that
would result from using Kaplan and Kay&apos;s (1994)
method and some variants of it. Some differences
in the results suggest that they use another inter-
pretation for the (compound) restriction operator.
According to that interpretation, overlapping cen-
ters are not restricted conjunctively, sometimes re-
sulting in a bigger language.
Simple optimizations in the formula for an n-
context restriction made a notable difference in
compilation time. When I compiled a 7-context
restriction (this was a striking exception in ENG-
FSIG), an unoptimized version of my formula was
very slow (9 min.) compared to a transducer-based
method (34.8 sec.), while an optimized version
was roughly as efficient (35.5 sec.). In this exam-
ple, the number of (outer) conjuncts in my formula
was quite high (27). The new formula is at its best
in the typical case when the number of contexts is
smaller than seven.
I did not make experiments with starry subex-
pressions because they are relatively small and fast
to compile anyway.
</bodyText>
<page confidence="0.998633">
384
</page>
<sectionHeader confidence="0.992911" genericHeader="method">
5 Discussion
</sectionHeader>
<bodyText confidence="0.999939121621622">
The schematic equivalences presented suggest al-
ternative ways to compile some special cases of
Kleene star. The compilation of Kleene closures
into deterministic automata involves determiniza-
tion that is based on the subset construction. On
the basis of the equivalences presented here it may
be possible to identify more cases for which we
can find specialized determinization algorithms
(Mohri, 1995).
The new formula for the restriction operator
has one extra advantage over compilation meth-
ods that are based on marker symbols and trans-
ducers (Kaplan and Kay, 1994). In these meth-
ods, the markers have to be eliminated from the
final language. Usually this requires determiniza-
tion using the costly subset construction. The new
formula does not involve markers and it there-
fore only needs to apply determinization at smaller
sub-formulas.
Methods that reduce the size of constraint au-
tomata can contribute to an efficient solution for
the FSIG parsing problem (Koskenniemi, 1997)
by producing a smaller representation for the
grammar. Tapanainen (1992) has developed spe-
cial optimizations that apply to automata during
their construction. The current paper suggests ma-
nipulation of FSIG regular expressions before they
are compiled into deterministic automata. The
value of this approach is based on the fact that the
construction of a deterministic automaton from a
regular expression is, in the worst-case, exponen-
tial.
The current paper provides the FSIG frame-
work with a grammar semantics that is completely
based on regular languages and a one-level rep-
resentation. Our new formula for an n-context
restriction operator does not make use of trans-
ducers (Tapanainen, 1992) nor markers. In the
absence of such complications, axioms for regu-
lar expressions (Antimirov and Mosses, 1994) be-
come much more usable and may lead to essential
simplifications in the individual constraints (see
Section 4) and in the grammar altogether.
The new formula for the restriction operator en-
ables us to split an n-context restriction into 2&amp;quot;
separate constraints (under intersection), each of
which can be simplified, compiled and applied
separately. It is also possible to compile the FSIG
regular expressions directly into a single alternat-
ing finite automaton where intersection and com-
plementation can occur inside the grammar au-
tomaton. Manipulation of alternating automata
(Vardi, 1995) may help us to avoid the state explo-
sion that is the main problem with deterministic
automata in FSIG parsing (Tapanainen, 1997).
Finally, the main contribution of this paper is
to show that ENGFSIG describes a star-free set
of strings. It seems probable that this narrowing
could be added to the FSIG framework in general.
The computational complexity of many impor-
tant decision problems for the FSIG grammars
remains intractable in spite of the star-freeness
property (Sistla and Clarke, 1985). Neverthe-
less, the improved descriptive complexity allows
us to simplify some algorithms; we can, for ex-
ample, implement the grammar with the class of
loop-free alternating automata (Salomaa and Yu,
2000). Moreover, the restriction also means that
the grammar is definable in a first-order logic
that is interpreted over finite strings (McNaughton
and Papert, 1971). This simplification is relevant
to reconstruction of FSIG and similar finite-state
models with logical specifications (Vaillette, 2001;
Lager and Nivre, 2001).
</bodyText>
<sectionHeader confidence="0.998363" genericHeader="conclusions">
6 Conclusion
</sectionHeader>
<bodyText confidence="0.999940875">
In this paper, the ENGFSIG description as a whole
is shown to be a regular expression that reduces
to a combination of union, complementation and
finite concatenation. The current work has the-
oretical and practical consequences in process-
ing of ENGFSIG (or similar) descriptions, context
restrictions in the Two-Level Morphology, and
Kleene closures in wider domains.
</bodyText>
<sectionHeader confidence="0.996863" genericHeader="acknowledgments">
Acknowledgments
</sectionHeader>
<bodyText confidence="0.999799">
This work was supported by NorFA Ph.D. pro-
gramme. I am grateful to Atro Voutilainen (and
Connexor) for putting to my disposal the ENG-
FSIG description. I would also like to thank es-
pecially Lauri Carlson, as well as Voutilainen,
Kimmo Koskenniemi, and the referees for useful
comments on this paper.
</bodyText>
<page confidence="0.998317">
385
</page>
<sectionHeader confidence="0.946049" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.99880334375">
Valentin M. Antimirov and Peter D. Mosses. 1994.
Rewriting extended regular expressions. In
G. Rozenberg and A. Salomaa, editors, Develop-
ments in Language Theory, - at the Crossroads of-
Mathematics, Computer Science and Biology, pages
195-209. World Scientific.
Laszlo Bernatsky. 1997. Regular expression star-
freeness is PSPACE-complete. Acta Cybemetica,
13(1):1-21.
Sang Cho and Dung T. Huynh. 1991. Finite-
automaton aperiodicity is PSPACE-complete. The-
oretical Computer Science, 88:99-116.
Johan A.W. Kamp. 1968. Tense Logic and the Theory
of Linear Order. Ph.D. thesis, Univ. of California,
Los Angeles.
Ronald M. Kaplan and Martin Kay. 1994. Regu-
lar models of phonological rule systems. Compu-
tational Linguistics, 20(3):331-378.
Lauri Karttunen, Kimmo Koskenniemi, and Ronald M.
Kaplan. 1987. A compiler for two-level phono-
logical rules. Technical Report CSLI-87-108, CSLI,
Stanford University.
Kimmo Koskenniemi, Pasi Tapanainen, and Atro
Voutilainen. 1992. Compiling and using finite-state
syntactic rules. In Proc. COLING&apos;92, volume I,
pages 156-162. Nantes, France.
Kimmo Koskenniemi. 1983. Two-level morphology: a
general computational model for word-form recog-
nition and production. Nr. 11 in Publications of the
Dept. of General Linguistics. University of Helsinki.
Kimmo Koskenniemi. 1990. Finite-state parsing and
disambiguation. In Proc. COLING&apos;90, volume 2,
pages 229-232, Helsinki.
Kimmo Koskenniemi. 1997. Representations and
finite-state components in natural language. In
(Roche and Schabes, /997), pages 99-116.
Torbjorn Lager and Joakim Nivre. 2001. Part of
speech tagging from a logical point of view. In
P. de Groote, G. Morrill, and C. Retore, editors, Log-
ical Aspects of Cotnput. Linguistics, volume 2099 of
Lecture Notes in Artificial Intelligence, pages 212-
227. Springer-Verlag.
0. Matz, A. Miller, A. Potthoff, W. Thomas, and
E. Valkema. 1995. Report on the program AMo RE.
Bericht Nr. 9507, Institut fiir Informatik und Prac-
tische Mathematik, Christian-Albrects-Universitt,
Kiel.
Robert McNaughton and Seymour Papert. 1968. The
syntactic monoid of a regular event. In M.A. Arbib,
editor, Algebraic Theory of Machines, Languages,
and Semi groups, pages 297-312. Academic Press.
Robert McNaughton and Seymour Papert. 1971.
Counter-free Automata. Research Monograph No.
65. MIT Press.
Yu. T. Medvedev. 1964. On the class of events repre-
sentable in a finite automaton. In E.F. Moore, editor,
Sequential Machines, pages 215-227. Addison Wes-
ley.
Mehryar Mohri. 1995. Matching patterns of an au-
tomaton. In Proc. Combinatorial Pattern Matching
(CPM&apos;95), volume 937 of LNCS, pages 286-297,
Espoo, Finland. Springer-Verlag.
Jean-Eric Pin. 1986. Varieties of Formal Languages.
Foundations of Computer Science. North Oxford.
Emmanuel Roche and Yves Schabes, editors. 1997.
Finite-state language processing. A Bradford Book,
MIT Press, Cambridge, MA.
Kai Salomaa and Sheng Yu. 2000. Alternating finite
automata and star-free languages. Theoretical Com-
puter Science, 234:167-176.
Marcel Paul Schazenberger. 1962. Finite counting
automata. Information and Control, 5(2):91-107.
Marcel Paul Schiitzenberger. 1965. On finite monoids
having only trivial subgroups. Information and Con-
trol, 8(2):190-194.
A. Prasad Sistla and Edmund M. Clarke. 1985. The
complexity of propositional linear temporal logic.
Journal of ACM, 32:733-749.
Pasi Tapanainen. 1992. Aeirellisiin automaatteihin pe-
rustuva luonnollisen kielen jeisennin. Licentiate the-
sis, Department of Computer Science, University of
Helsinki, Finland.
Pasi Tapanainen. 1997. Applying a finite-state inter-
section grammar. In (Roche and Schabes, 1997),
pages 311-327.
Nathan Vaillette. 2001. Logical specification of trans-
ducers for NLP. In Finite State Methods in Natural
Language Processing 2001 (FSMNLP 2001), ESS-
LU I Workshop, pages 20-24, Helsinki.
Moshe Y. Vardi. 1995. Alternating automata and pro-
gram verification. In Computer Science Today -
Recent Trends and Developments, volume 1000 of
LNCS, pages 471-485. Springer-Verlag.
Atro Voutilainen. 1994. Designing a Parsing Gram-
mar. Nr. 22 in Publications of the Department of
General Linguistics. University of Helsinki.
</reference>
<page confidence="0.999026">
386
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.834508">
<title confidence="0.999941">Describing Syntax with Star-Free Regular Expressions</title>
<author confidence="0.996128">Anssi Yli-Jyra</author>
<affiliation confidence="0.872007">Department of General Linguistics, P.O. Box 9, FIN-00014 Univ. of Helsinki, Finland</affiliation>
<email confidence="0.995096">fi</email>
<abstract confidence="0.99794285">Syntactic constraints in Koskenniemi&apos;s Finite-State Intersection Grammar (FSIG) are logically less complex than their formalism (Koskenniemi et al., 1992) would suggest: It turns out that although the constraints in Voutilainen&apos;s (1994) FSIG description of English make use of several extensions to regular expressions, the description as a whole reduces to a finite combination of union, complement and concatenation. This is an essential improvement to the complexity ENGFSIG. The result opens a door for further analysis of logical properties and possible optimizations in the FSIG descriptions. The proof contains a new formula for compiling Koskenniemi&apos;s restriction operation without any marker symbols.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Valentin M Antimirov</author>
<author>Peter D Mosses</author>
</authors>
<title>Rewriting extended regular expressions.</title>
<date>1994</date>
<booktitle>Developments in Language Theory, - at the Crossroads ofMathematics, Computer Science and Biology,</booktitle>
<pages>195--209</pages>
<editor>In G. Rozenberg and A. Salomaa, editors,</editor>
<publisher>World Scientific.</publisher>
<contexts>
<context position="23906" citStr="Antimirov and Mosses, 1994" startWordPosition="4088" endWordPosition="4091">gests manipulation of FSIG regular expressions before they are compiled into deterministic automata. The value of this approach is based on the fact that the construction of a deterministic automaton from a regular expression is, in the worst-case, exponential. The current paper provides the FSIG framework with a grammar semantics that is completely based on regular languages and a one-level representation. Our new formula for an n-context restriction operator does not make use of transducers (Tapanainen, 1992) nor markers. In the absence of such complications, axioms for regular expressions (Antimirov and Mosses, 1994) become much more usable and may lead to essential simplifications in the individual constraints (see Section 4) and in the grammar altogether. The new formula for the restriction operator enables us to split an n-context restriction into 2&amp;quot; separate constraints (under intersection), each of which can be simplified, compiled and applied separately. It is also possible to compile the FSIG regular expressions directly into a single alternating finite automaton where intersection and complementation can occur inside the grammar automaton. Manipulation of alternating automata (Vardi, 1995) may hel</context>
</contexts>
<marker>Antimirov, Mosses, 1994</marker>
<rawString>Valentin M. Antimirov and Peter D. Mosses. 1994. Rewriting extended regular expressions. In G. Rozenberg and A. Salomaa, editors, Developments in Language Theory, - at the Crossroads ofMathematics, Computer Science and Biology, pages 195-209. World Scientific.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Laszlo Bernatsky</author>
</authors>
<title>Regular expression starfreeness is PSPACE-complete.</title>
<date>1997</date>
<journal>Acta Cybemetica,</journal>
<pages>13--1</pages>
<contexts>
<context position="13182" citStr="Bernatsky, 1997" startWordPosition="2211" endWordPosition="2212"> are star-free (McNaughton and Papert, 1971): AB A $A AuB AnB A- B It is also possible that the language of a regular expression is star-free although the expression contains the Kleene star operator. Therefore, the method based on the properties of the syntactic monoid of the language is important. The syntactic monoid is usually difficult to compute manually, and some programs, e.g. AMoRe (Matz et al., 1995) are designed to facilitate these computations and aperiodicity testing. The aperiodicity problem is, however, computationally intractable (PSPACE-complete) both for regular expressions (Bernatsky, 1997) and for deterministic automata (Cho and Huynh, 1991). It is often possible to heuristically prove the star-freeness property by inventing an equivalent star-free expression. Proposition 2. In order to show that a finite-state intersection grammar G is star-free, it is sufficient to show that: • the domain B(WFB)± is star-free, • the local lexical constraints , ck! are star-free, • the constants El , .• I , ,&gt;••&lt;[ , @&lt;&gt; and other subexpressions in the constraints are star-free, and, • the star-free languages are closed under the operators that combine the subexpressions into the constraints c4</context>
</contexts>
<marker>Bernatsky, 1997</marker>
<rawString>Laszlo Bernatsky. 1997. Regular expression starfreeness is PSPACE-complete. Acta Cybemetica, 13(1):1-21.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Sang Cho</author>
<author>Dung T Huynh</author>
</authors>
<title>Finiteautomaton aperiodicity is PSPACE-complete.</title>
<date>1991</date>
<journal>Theoretical Computer Science,</journal>
<pages>88--99</pages>
<contexts>
<context position="13235" citStr="Cho and Huynh, 1991" startWordPosition="2217" endWordPosition="2220">A $A AuB AnB A- B It is also possible that the language of a regular expression is star-free although the expression contains the Kleene star operator. Therefore, the method based on the properties of the syntactic monoid of the language is important. The syntactic monoid is usually difficult to compute manually, and some programs, e.g. AMoRe (Matz et al., 1995) are designed to facilitate these computations and aperiodicity testing. The aperiodicity problem is, however, computationally intractable (PSPACE-complete) both for regular expressions (Bernatsky, 1997) and for deterministic automata (Cho and Huynh, 1991). It is often possible to heuristically prove the star-freeness property by inventing an equivalent star-free expression. Proposition 2. In order to show that a finite-state intersection grammar G is star-free, it is sufficient to show that: • the domain B(WFB)± is star-free, • the local lexical constraints , ck! are star-free, • the constants El , .• I , ,&gt;••&lt;[ , @&lt;&gt; and other subexpressions in the constraints are star-free, and, • the star-free languages are closed under the operators that combine the subexpressions into the constraints c4d,±1, . . . , cmd. 3 The reduction of ENGFSIG into st</context>
</contexts>
<marker>Cho, Huynh, 1991</marker>
<rawString>Sang Cho and Dung T. Huynh. 1991. Finiteautomaton aperiodicity is PSPACE-complete. Theoretical Computer Science, 88:99-116.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Johan A W Kamp</author>
</authors>
<title>Tense Logic and the Theory of Linear Order.</title>
<date>1968</date>
<tech>Ph.D. thesis,</tech>
<institution>Univ. of California,</institution>
<location>Los Angeles.</location>
<contexts>
<context position="12020" citStr="Kamp, 1968" startWordPosition="2015" endWordPosition="2016">ther the language L(G) is star-free i.e. whether it can be constructed from alphabet symbols by application of the boolean operators (U, and concatenation. Proposition 1. For a regular language L, the following properties are equivalent: • the language L is star-free, • there is a starfree regular expression, based on concatenation and the boolean operators, that describes the language L, • the syntactic monoid (McNaughton and Papert, 1968) that is canonically assigned to the language L is aperiodic (Schiitzenberger, 1965), • the language L is definable in propositional linear temporal logic (Kamp, 1968), and, • the language L is definable in a first-order logic that is interpreted over finite strings (McNaughton and Papert, 1971). Sometimes star-freeness of a language can be shown by means of closure properties of star-free languages. To start with, finite regular languages are star-free (especially 0, 6, a, and F, where 0 denotes the empty set of strings, a CE, and F C E) The Kleene closure of any subset F C E is also star-free, because I&apos; = 0[E — F10. If A and B are star-free languages, then we know that at least the following languages are star-free (McNaughton and Papert, 1971): AB A $A </context>
</contexts>
<marker>Kamp, 1968</marker>
<rawString>Johan A.W. Kamp. 1968. Tense Logic and the Theory of Linear Order. Ph.D. thesis, Univ. of California, Los Angeles.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ronald M Kaplan</author>
<author>Martin Kay</author>
</authors>
<title>Regular models of phonological rule systems.</title>
<date>1994</date>
<journal>Computational Linguistics,</journal>
<pages>20--3</pages>
<contexts>
<context position="19124" citStr="Kaplan and Kay, 1994" startWordPosition="3290" endWordPosition="3293"> represented without the Kleene star operator. In addition to these, there are 2657 more complicated constraints. The schematic equivalences presented in Sections 3.3 — 3.4 can transform 1554 of these into a star-free form. However, there still remain 1103 constraints that use the restriction operator To complete the proof of the star-freeness of ENGFSIG, I show that star-free languages are closed under the restriction operation (as in FSIG). Compilation of the restriction operator (as in Two-Level Morphology) has been solved by means of marker symbols and transducers (Karttunen et al., 1987; Kaplan and Kay, 1994). To compile the restriction as in FSIG, Tapanainen (1992) used also a method that is perhaps most easily described with transducers. When there is only one context LC1 _ RC1, the restriction operator (as in TWOL and in FSIG) reduces to the following star-free formula (Karttunen et al., 1987): E*LCi X 0 n 0 X Rci E* I generalize this special case in the following new formula for n contexts LC i _ i = 1..n: 71 n [ nn _,) LCi ] X n RCi(i.F) i=1 i=1 where S = {1, 2,... , n} and E* ificF 0 otherwise; The above formula does not use markers, transducers, nor the Kleene star. Intuitively, it says tha</context>
<context position="22684" citStr="Kaplan and Kay, 1994" startWordPosition="3899" endWordPosition="3902"> small and fast to compile anyway. 384 5 Discussion The schematic equivalences presented suggest alternative ways to compile some special cases of Kleene star. The compilation of Kleene closures into deterministic automata involves determinization that is based on the subset construction. On the basis of the equivalences presented here it may be possible to identify more cases for which we can find specialized determinization algorithms (Mohri, 1995). The new formula for the restriction operator has one extra advantage over compilation methods that are based on marker symbols and transducers (Kaplan and Kay, 1994). In these methods, the markers have to be eliminated from the final language. Usually this requires determinization using the costly subset construction. The new formula does not involve markers and it therefore only needs to apply determinization at smaller sub-formulas. Methods that reduce the size of constraint automata can contribute to an efficient solution for the FSIG parsing problem (Koskenniemi, 1997) by producing a smaller representation for the grammar. Tapanainen (1992) has developed special optimizations that apply to automata during their construction. The current paper suggests</context>
</contexts>
<marker>Kaplan, Kay, 1994</marker>
<rawString>Ronald M. Kaplan and Martin Kay. 1994. Regular models of phonological rule systems. Computational Linguistics, 20(3):331-378.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Lauri Karttunen</author>
<author>Kimmo Koskenniemi</author>
<author>Ronald M Kaplan</author>
</authors>
<title>A compiler for two-level phonological rules.</title>
<date>1987</date>
<tech>Technical Report CSLI-87-108,</tech>
<institution>CSLI, Stanford University.</institution>
<contexts>
<context position="19101" citStr="Karttunen et al., 1987" startWordPosition="3285" endWordPosition="3289">xical constraints can be represented without the Kleene star operator. In addition to these, there are 2657 more complicated constraints. The schematic equivalences presented in Sections 3.3 — 3.4 can transform 1554 of these into a star-free form. However, there still remain 1103 constraints that use the restriction operator To complete the proof of the star-freeness of ENGFSIG, I show that star-free languages are closed under the restriction operation (as in FSIG). Compilation of the restriction operator (as in Two-Level Morphology) has been solved by means of marker symbols and transducers (Karttunen et al., 1987; Kaplan and Kay, 1994). To compile the restriction as in FSIG, Tapanainen (1992) used also a method that is perhaps most easily described with transducers. When there is only one context LC1 _ RC1, the restriction operator (as in TWOL and in FSIG) reduces to the following star-free formula (Karttunen et al., 1987): E*LCi X 0 n 0 X Rci E* I generalize this special case in the following new formula for n contexts LC i _ i = 1..n: 71 n [ nn _,) LCi ] X n RCi(i.F) i=1 i=1 where S = {1, 2,... , n} and E* ificF 0 otherwise; The above formula does not use markers, transducers, nor the Kleene star. I</context>
</contexts>
<marker>Karttunen, Koskenniemi, Kaplan, 1987</marker>
<rawString>Lauri Karttunen, Kimmo Koskenniemi, and Ronald M. Kaplan. 1987. A compiler for two-level phonological rules. Technical Report CSLI-87-108, CSLI, Stanford University.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kimmo Koskenniemi</author>
<author>Pasi Tapanainen</author>
<author>Atro Voutilainen</author>
</authors>
<title>Compiling and using finite-state syntactic rules.</title>
<date>1992</date>
<booktitle>In Proc. COLING&apos;92, volume I,</booktitle>
<pages>156--162</pages>
<location>Nantes, France.</location>
<contexts>
<context position="1232" citStr="Koskenniemi et al., 1992" startWordPosition="168" endWordPosition="171"> This is an essential improvement to the descriptive complexity of ENGFSIG. The result opens a door for further analysis of logical properties and possible optimizations in the FSIG descriptions. The proof contains a new formula for compiling Koskenniemi&apos;s restriction operation without any marker symbols. 1 Introduction For many years, various finite-state models of language (Roche and Schabes, 1997) have been used in surface-syntactic parsing. These models can process local syntactic ambiguity efficiently. However, because the formalism of FiniteState Intersection Grammar (Koskenniemi, 1990; Koskenniemi et al., 1992) allows full regular expressions, its parsing is sometimes inefficient (Tapanainen, 1997); many FSIG constraint automata can reduce ambiguity only after they have scanned the whole sentence. Regular expressions in FSIG can be viewed as a grammar-writing tool that should be as flexible as possible. This viewpoint has led to introduction of new features into the formalism (Koskenniemi et al., 1992). It is, however, very difficult to make any a priori generalizations of the structural properties of automata as long as we allow unrestricted use of regular expressions. A complementary view is to an</context>
<context position="9461" citStr="Koskenniemi et al., 1992" startWordPosition="1564" endWordPosition="1567">the rightmost constituent in its matrix clause. In the ENGFSIG The FSIG The current Preced- Semantics of notation notation ence the expression [A[ [A] (6) A (A) A (6) A U —A A or --A 5 {,xxEE*Axi} A+ 4 AA* i A* A* 4 Ui7c, AA...A \A SA or —SA 3 AB AB 2 {xylxEAAyEB} A B A U B 1 {xhreAVxeB} A &amp; B AnB I TA u—B] N/A A — B 1 A n—B Table 1: Combinations of expressions A and B. representation, a finite center-embedded clause is separated from its matrix clause with a pair of delimiters @&lt;c B and @&gt;E B. Sequential clause boundaries are denoted (ambiguously) with the delimiter @/ EB. Special constants (Koskenniemi et al., 1992) are used to facilitate description of complex patterns involving the delimiter symbols EB, Eg B,B = {@,@&lt;,@&gt;,@/,@@}. The intuitive meaning of the constants in Table 2 is as follows: The dot H accepts tag sequences of and EF inside word analyses, the expression accepts tag sequences of Ew, EF and @, and the constant @&lt;&gt; accepts a center-embedded clause with possible nested center-embeddings. The dotdotl I differs from the expression &gt;••&lt; by accepting anything within the same clause, including center-embedded clauses. Finally, the dots I • • • accepts anything at the same level of centerembeddi</context>
<context position="20988" citStr="Koskenniemi et al., 1992" startWordPosition="3626" endWordPosition="3629">ould output a script where operands for each restriction operator were defined (and compiled into automata) before the operator was applied. Every bunch of operand definitions was followed by a formula that implemented the restriction operator with a required number of contexts. In order to reduce the number of contexts, I gathered unilateral contexts with the preprocessor. I developed and tested the presented equivalences using the Xerox Finite-State Tool (v.7.4.0). My new formula for the restriction operator produced automata that were equivalent to the output of Tapanainen&apos;s rule compiler (Koskenniemi et al., 1992), which was actually used during the development of ENGFSIG. I also compared these automata to the ones that would result from using Kaplan and Kay&apos;s (1994) method and some variants of it. Some differences in the results suggest that they use another interpretation for the (compound) restriction operator. According to that interpretation, overlapping centers are not restricted conjunctively, sometimes resulting in a bigger language. Simple optimizations in the formula for an ncontext restriction made a notable difference in compilation time. When I compiled a 7-context restriction (this was a </context>
</contexts>
<marker>Koskenniemi, Tapanainen, Voutilainen, 1992</marker>
<rawString>Kimmo Koskenniemi, Pasi Tapanainen, and Atro Voutilainen. 1992. Compiling and using finite-state syntactic rules. In Proc. COLING&apos;92, volume I, pages 156-162. Nantes, France.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kimmo Koskenniemi</author>
</authors>
<title>Two-level morphology: a general computational model for word-form recognition and production.</title>
<date>1983</date>
<journal>Nr.</journal>
<volume>11</volume>
<institution>Dept. of General Linguistics. University of Helsinki.</institution>
<note>in Publications of the</note>
<contexts>
<context position="8261" citStr="Koskenniemi, 1983" startWordPosition="1331" endWordPosition="1332">Y ckl, c1 1-1 end. The first k constraints apply locally to each word, matching morphological analyses with potential syntactic functions. I call them local lexical constraints. All the constraints are expressed by means of FSIG regular expressions. Any symbol a E E, as well as any symbol set {al, a2, , arn}, al, a2.... , e E, are valid FSIG regular expressions. The language consisting of the empty string is denoted with E (or [] in the FSIG notation). In addition to the simple operators (Table 1) that combine expressions A and B, FSIG regular expressions make use of the restriction operator (Koskenniemi, 1983). It has the following syntax: X LC i _ RC1, LC2 _ RC2. • • • , LC n _ RCn The operands X, LCi, , RC, are FSIG regular expressions. The semantics of the whole expression is as follows: Whenever a substring x C X occurs in the string w, its context must match at least one of the patterns LC, _ RC,, i = 1..n. When there are overlapping occurrences of the center X, the string w is rejected if any of the occurrences infringes the restriction (this is the strict interpretation of the operator). A center-embedded clause is an embedded clause that is not the leftmost neither the rightmost constituent</context>
</contexts>
<marker>Koskenniemi, 1983</marker>
<rawString>Kimmo Koskenniemi. 1983. Two-level morphology: a general computational model for word-form recognition and production. Nr. 11 in Publications of the Dept. of General Linguistics. University of Helsinki.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kimmo Koskenniemi</author>
</authors>
<title>Finite-state parsing and disambiguation.</title>
<date>1990</date>
<booktitle>In Proc. COLING&apos;90,</booktitle>
<volume>2</volume>
<pages>229--232</pages>
<location>Helsinki.</location>
<contexts>
<context position="1205" citStr="Koskenniemi, 1990" startWordPosition="166" endWordPosition="167"> and concatenation. This is an essential improvement to the descriptive complexity of ENGFSIG. The result opens a door for further analysis of logical properties and possible optimizations in the FSIG descriptions. The proof contains a new formula for compiling Koskenniemi&apos;s restriction operation without any marker symbols. 1 Introduction For many years, various finite-state models of language (Roche and Schabes, 1997) have been used in surface-syntactic parsing. These models can process local syntactic ambiguity efficiently. However, because the formalism of FiniteState Intersection Grammar (Koskenniemi, 1990; Koskenniemi et al., 1992) allows full regular expressions, its parsing is sometimes inefficient (Tapanainen, 1997); many FSIG constraint automata can reduce ambiguity only after they have scanned the whole sentence. Regular expressions in FSIG can be viewed as a grammar-writing tool that should be as flexible as possible. This viewpoint has led to introduction of new features into the formalism (Koskenniemi et al., 1992). It is, however, very difficult to make any a priori generalizations of the structural properties of automata as long as we allow unrestricted use of regular expressions. A </context>
</contexts>
<marker>Koskenniemi, 1990</marker>
<rawString>Kimmo Koskenniemi. 1990. Finite-state parsing and disambiguation. In Proc. COLING&apos;90, volume 2, pages 229-232, Helsinki.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kimmo Koskenniemi</author>
</authors>
<title>Representations and finite-state components in natural language.</title>
<date>1997</date>
<journal>In (Roche and Schabes,</journal>
<volume>997</volume>
<pages>99--116</pages>
<contexts>
<context position="3566" citStr="Koskenniemi, 1997" startWordPosition="529" endWordPosition="530">e star-freeness restriction on FSIG constraints has not been studied before, possibly because of the following observations: (i) An acyclic automaton representing readings of the sentence has a central role in FSIG parsing (Tapanainen, 1997). Star-freeness of the constraints is a minor restriction when compared to the finiteness of this language. 379 (ii) If automata states are encoded as &amp;quot;traces&amp;quot; into strings, any regular language can be represented as a homomorphic image of a (local) star-free language (Medvedev, 1964). Such an encoding is possible in a two-level view of the FSIG framework (Koskenniemi, 1997), where the morphological reading of the sentence is a homomorphic image of a level representing syntactically annotated readings. (iii) Given a finite automaton or a regular expression, checking star-freeness of the described language is an intractable (see 2.2) problem. (iv) Automatical methods to derive star-free regular expressions from another representations procuce long and unintuitive expressions (Matz et al., 1995). From my point of view, these observations miss some important perspectives: Firstly (i), it is important to understand that a finite-state intersection grammar is also a d</context>
<context position="14601" citStr="Koskenniemi, 1997" startWordPosition="2455" endWordPosition="2457">mpty string, the set S = E-MEiFvEIFF,*+ can be expressed as [E-Ew n [E*EFEL] n -EB n -$[Ew[E-Ew —EF1] n -$[EF[ -EF —EB]] . The remaining question is, whether the sets B, W and F are star-free languages. In the case of ENGFSIG they are finite, and therefore, each of them is expressible with a star-free regular expression. Hence the iteration in B(WFB)± translates to S n [BET47 n [E*EFB] n—S[EB[Ei&apos;v —WIEF] n — F] EB] n $[F[ -B]7] 3.2 The local lexical constraints The relation between the morphological analyses and the allowed syntactic functions can be implemented either with one or two levels (Koskenniemi, 1997) in a practical FSIG parser. In the grammar G, this relation corresponds to a set of lexical constraints efi,d,. , c. 382 In the case of ENGFSIG, the local lexical constraints reduce to a boolean combination of languages of the form St, t CEw U EF , because the tag positions in the strings of W and F are fixed by a convention that partly reflects the simple morpheme structure of English words. Let the lexical constraints in conjunction with the domain D describe the set B (LwFB)± , LITT, C WF. The conformance to this property is enforced by the following star-free constraint: D flE*EB [Ei1P,vE</context>
<context position="23098" citStr="Koskenniemi, 1997" startWordPosition="3966" endWordPosition="3967">erminization algorithms (Mohri, 1995). The new formula for the restriction operator has one extra advantage over compilation methods that are based on marker symbols and transducers (Kaplan and Kay, 1994). In these methods, the markers have to be eliminated from the final language. Usually this requires determinization using the costly subset construction. The new formula does not involve markers and it therefore only needs to apply determinization at smaller sub-formulas. Methods that reduce the size of constraint automata can contribute to an efficient solution for the FSIG parsing problem (Koskenniemi, 1997) by producing a smaller representation for the grammar. Tapanainen (1992) has developed special optimizations that apply to automata during their construction. The current paper suggests manipulation of FSIG regular expressions before they are compiled into deterministic automata. The value of this approach is based on the fact that the construction of a deterministic automaton from a regular expression is, in the worst-case, exponential. The current paper provides the FSIG framework with a grammar semantics that is completely based on regular languages and a one-level representation. Our new </context>
</contexts>
<marker>Koskenniemi, 1997</marker>
<rawString>Kimmo Koskenniemi. 1997. Representations and finite-state components in natural language. In (Roche and Schabes, /997), pages 99-116.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Torbjorn Lager</author>
<author>Joakim Nivre</author>
</authors>
<title>Part of speech tagging from a logical point of view.</title>
<date>2001</date>
<booktitle>Logical Aspects of Cotnput. Linguistics, volume 2099 of Lecture Notes in Artificial Intelligence,</booktitle>
<pages>212--227</pages>
<editor>In P. de Groote, G. Morrill, and C. Retore, editors,</editor>
<publisher>Springer-Verlag.</publisher>
<contexts>
<context position="25520" citStr="Lager and Nivre, 2001" startWordPosition="4334" endWordPosition="4337">IG grammars remains intractable in spite of the star-freeness property (Sistla and Clarke, 1985). Nevertheless, the improved descriptive complexity allows us to simplify some algorithms; we can, for example, implement the grammar with the class of loop-free alternating automata (Salomaa and Yu, 2000). Moreover, the restriction also means that the grammar is definable in a first-order logic that is interpreted over finite strings (McNaughton and Papert, 1971). This simplification is relevant to reconstruction of FSIG and similar finite-state models with logical specifications (Vaillette, 2001; Lager and Nivre, 2001). 6 Conclusion In this paper, the ENGFSIG description as a whole is shown to be a regular expression that reduces to a combination of union, complementation and finite concatenation. The current work has theoretical and practical consequences in processing of ENGFSIG (or similar) descriptions, context restrictions in the Two-Level Morphology, and Kleene closures in wider domains. Acknowledgments This work was supported by NorFA Ph.D. programme. I am grateful to Atro Voutilainen (and Connexor) for putting to my disposal the ENGFSIG description. I would also like to thank especially Lauri Carlso</context>
</contexts>
<marker>Lager, Nivre, 2001</marker>
<rawString>Torbjorn Lager and Joakim Nivre. 2001. Part of speech tagging from a logical point of view. In P. de Groote, G. Morrill, and C. Retore, editors, Logical Aspects of Cotnput. Linguistics, volume 2099 of Lecture Notes in Artificial Intelligence, pages 212-227. Springer-Verlag.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Miller Matz</author>
<author>A Potthoff</author>
<author>W Thomas</author>
<author>E Valkema</author>
</authors>
<title>Report on the program AMo RE.</title>
<date>1995</date>
<booktitle>Bericht Nr. 9507, Institut fiir Informatik und Practische Mathematik,</booktitle>
<location>Christian-Albrects-Universitt, Kiel.</location>
<contexts>
<context position="3993" citStr="Matz et al., 1995" startWordPosition="592" endWordPosition="595">language can be represented as a homomorphic image of a (local) star-free language (Medvedev, 1964). Such an encoding is possible in a two-level view of the FSIG framework (Koskenniemi, 1997), where the morphological reading of the sentence is a homomorphic image of a level representing syntactically annotated readings. (iii) Given a finite automaton or a regular expression, checking star-freeness of the described language is an intractable (see 2.2) problem. (iv) Automatical methods to derive star-free regular expressions from another representations procuce long and unintuitive expressions (Matz et al., 1995). From my point of view, these observations miss some important perspectives: Firstly (i), it is important to understand that a finite-state intersection grammar is also a description of a language with a structure of its own, independent of the acyclic sentence automaton. Secondly (ii), a realistic FSIG description is linguistically motivated and leaves little room for encoding of traces that could technically make the grammar star-free. Thirdly (iii), heuristic methods can be used to solve many large star-freeness problems in practice. Fourthly (iv), it is often possible to find star-free re</context>
<context position="12979" citStr="Matz et al., 1995" startWordPosition="2185" endWordPosition="2188">pty set of strings, a CE, and F C E) The Kleene closure of any subset F C E is also star-free, because I&apos; = 0[E — F10. If A and B are star-free languages, then we know that at least the following languages are star-free (McNaughton and Papert, 1971): AB A $A AuB AnB A- B It is also possible that the language of a regular expression is star-free although the expression contains the Kleene star operator. Therefore, the method based on the properties of the syntactic monoid of the language is important. The syntactic monoid is usually difficult to compute manually, and some programs, e.g. AMoRe (Matz et al., 1995) are designed to facilitate these computations and aperiodicity testing. The aperiodicity problem is, however, computationally intractable (PSPACE-complete) both for regular expressions (Bernatsky, 1997) and for deterministic automata (Cho and Huynh, 1991). It is often possible to heuristically prove the star-freeness property by inventing an equivalent star-free expression. Proposition 2. In order to show that a finite-state intersection grammar G is star-free, it is sufficient to show that: • the domain B(WFB)± is star-free, • the local lexical constraints , ck! are star-free, • the constant</context>
</contexts>
<marker>Matz, Potthoff, Thomas, Valkema, 1995</marker>
<rawString>0. Matz, A. Miller, A. Potthoff, W. Thomas, and E. Valkema. 1995. Report on the program AMo RE. Bericht Nr. 9507, Institut fiir Informatik und Practische Mathematik, Christian-Albrects-Universitt, Kiel.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Robert McNaughton</author>
<author>Seymour Papert</author>
</authors>
<title>The syntactic monoid of a regular event.</title>
<date>1968</date>
<booktitle>Algebraic Theory of Machines, Languages, and Semi groups,</booktitle>
<pages>297--312</pages>
<editor>In M.A. Arbib, editor,</editor>
<publisher>Academic Press.</publisher>
<contexts>
<context position="11853" citStr="McNaughton and Papert, 1968" startWordPosition="1987" endWordPosition="1991">isualizes the semantics of 8&lt;&gt; d. 2.2 Star-freeness problem for an FSIG The problem I want to solve for an FSIG is the star-freeness problem. It is, given a grammar G, to determine whether the language L(G) is star-free i.e. whether it can be constructed from alphabet symbols by application of the boolean operators (U, and concatenation. Proposition 1. For a regular language L, the following properties are equivalent: • the language L is star-free, • there is a starfree regular expression, based on concatenation and the boolean operators, that describes the language L, • the syntactic monoid (McNaughton and Papert, 1968) that is canonically assigned to the language L is aperiodic (Schiitzenberger, 1965), • the language L is definable in propositional linear temporal logic (Kamp, 1968), and, • the language L is definable in a first-order logic that is interpreted over finite strings (McNaughton and Papert, 1971). Sometimes star-freeness of a language can be shown by means of closure properties of star-free languages. To start with, finite regular languages are star-free (especially 0, 6, a, and F, where 0 denotes the empty set of strings, a CE, and F C E) The Kleene closure of any subset F C E is also star-fre</context>
</contexts>
<marker>McNaughton, Papert, 1968</marker>
<rawString>Robert McNaughton and Seymour Papert. 1968. The syntactic monoid of a regular event. In M.A. Arbib, editor, Algebraic Theory of Machines, Languages, and Semi groups, pages 297-312. Academic Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Robert McNaughton</author>
<author>Seymour Papert</author>
</authors>
<date>1971</date>
<journal>Counter-free Automata. Research Monograph</journal>
<volume>65</volume>
<publisher>MIT Press.</publisher>
<contexts>
<context position="2801" citStr="McNaughton and Papert, 1971" startWordPosition="408" endWordPosition="412">anguage has favorable properties, some problems, e.g. the string membership problem, can be solved faster by means of specialized algorithms. A language can be described with a star-free regular expression if it can be constructed from alphabet symbols by application of union (A U B), complementation (A) and finite concatenation (AB), that is, without the Kleene closure (A*). The theoretical importance of this class of languages is supported by its characterization in terms of finite aperiodic syntactic monoids (Schiitzenberger, 1965) and by its definability in first-order logic over strings (McNaughton and Papert, 1971). The class has also a lot of practical importance, because many languages in it admit extremely simple implementations (ibid.). The question of the star-freeness restriction on FSIG constraints has not been studied before, possibly because of the following observations: (i) An acyclic automaton representing readings of the sentence has a central role in FSIG parsing (Tapanainen, 1997). Star-freeness of the constraints is a minor restriction when compared to the finiteness of this language. 379 (ii) If automata states are encoded as &amp;quot;traces&amp;quot; into strings, any regular language can be represente</context>
<context position="12149" citStr="McNaughton and Papert, 1971" startWordPosition="2034" endWordPosition="2037">he boolean operators (U, and concatenation. Proposition 1. For a regular language L, the following properties are equivalent: • the language L is star-free, • there is a starfree regular expression, based on concatenation and the boolean operators, that describes the language L, • the syntactic monoid (McNaughton and Papert, 1968) that is canonically assigned to the language L is aperiodic (Schiitzenberger, 1965), • the language L is definable in propositional linear temporal logic (Kamp, 1968), and, • the language L is definable in a first-order logic that is interpreted over finite strings (McNaughton and Papert, 1971). Sometimes star-freeness of a language can be shown by means of closure properties of star-free languages. To start with, finite regular languages are star-free (especially 0, 6, a, and F, where 0 denotes the empty set of strings, a CE, and F C E) The Kleene closure of any subset F C E is also star-free, because I&apos; = 0[E — F10. If A and B are star-free languages, then we know that at least the following languages are star-free (McNaughton and Papert, 1971): AB A $A AuB AnB A- B It is also possible that the language of a regular expression is star-free although the expression contains the Klee</context>
<context position="25360" citStr="McNaughton and Papert, 1971" startWordPosition="4313" endWordPosition="4316">gs. It seems probable that this narrowing could be added to the FSIG framework in general. The computational complexity of many important decision problems for the FSIG grammars remains intractable in spite of the star-freeness property (Sistla and Clarke, 1985). Nevertheless, the improved descriptive complexity allows us to simplify some algorithms; we can, for example, implement the grammar with the class of loop-free alternating automata (Salomaa and Yu, 2000). Moreover, the restriction also means that the grammar is definable in a first-order logic that is interpreted over finite strings (McNaughton and Papert, 1971). This simplification is relevant to reconstruction of FSIG and similar finite-state models with logical specifications (Vaillette, 2001; Lager and Nivre, 2001). 6 Conclusion In this paper, the ENGFSIG description as a whole is shown to be a regular expression that reduces to a combination of union, complementation and finite concatenation. The current work has theoretical and practical consequences in processing of ENGFSIG (or similar) descriptions, context restrictions in the Two-Level Morphology, and Kleene closures in wider domains. Acknowledgments This work was supported by NorFA Ph.D. pr</context>
</contexts>
<marker>McNaughton, Papert, 1971</marker>
<rawString>Robert McNaughton and Seymour Papert. 1971. Counter-free Automata. Research Monograph No. 65. MIT Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>T Medvedev</author>
</authors>
<title>On the class of events representable in a finite automaton.</title>
<date>1964</date>
<booktitle>Sequential Machines,</booktitle>
<pages>215--227</pages>
<editor>In E.F. Moore, editor,</editor>
<publisher>Addison Wesley.</publisher>
<contexts>
<context position="3474" citStr="Medvedev, 1964" startWordPosition="514" endWordPosition="515">e many languages in it admit extremely simple implementations (ibid.). The question of the star-freeness restriction on FSIG constraints has not been studied before, possibly because of the following observations: (i) An acyclic automaton representing readings of the sentence has a central role in FSIG parsing (Tapanainen, 1997). Star-freeness of the constraints is a minor restriction when compared to the finiteness of this language. 379 (ii) If automata states are encoded as &amp;quot;traces&amp;quot; into strings, any regular language can be represented as a homomorphic image of a (local) star-free language (Medvedev, 1964). Such an encoding is possible in a two-level view of the FSIG framework (Koskenniemi, 1997), where the morphological reading of the sentence is a homomorphic image of a level representing syntactically annotated readings. (iii) Given a finite automaton or a regular expression, checking star-freeness of the described language is an intractable (see 2.2) problem. (iv) Automatical methods to derive star-free regular expressions from another representations procuce long and unintuitive expressions (Matz et al., 1995). From my point of view, these observations miss some important perspectives: Fir</context>
</contexts>
<marker>Medvedev, 1964</marker>
<rawString>Yu. T. Medvedev. 1964. On the class of events representable in a finite automaton. In E.F. Moore, editor, Sequential Machines, pages 215-227. Addison Wesley.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Mehryar Mohri</author>
</authors>
<title>Matching patterns of an automaton.</title>
<date>1995</date>
<booktitle>In Proc. Combinatorial Pattern Matching (CPM&apos;95),</booktitle>
<volume>937</volume>
<pages>286--297</pages>
<publisher>Springer-Verlag.</publisher>
<location>Espoo,</location>
<contexts>
<context position="22517" citStr="Mohri, 1995" startWordPosition="3873" endWordPosition="3874"> best in the typical case when the number of contexts is smaller than seven. I did not make experiments with starry subexpressions because they are relatively small and fast to compile anyway. 384 5 Discussion The schematic equivalences presented suggest alternative ways to compile some special cases of Kleene star. The compilation of Kleene closures into deterministic automata involves determinization that is based on the subset construction. On the basis of the equivalences presented here it may be possible to identify more cases for which we can find specialized determinization algorithms (Mohri, 1995). The new formula for the restriction operator has one extra advantage over compilation methods that are based on marker symbols and transducers (Kaplan and Kay, 1994). In these methods, the markers have to be eliminated from the final language. Usually this requires determinization using the costly subset construction. The new formula does not involve markers and it therefore only needs to apply determinization at smaller sub-formulas. Methods that reduce the size of constraint automata can contribute to an efficient solution for the FSIG parsing problem (Koskenniemi, 1997) by producing a sma</context>
</contexts>
<marker>Mohri, 1995</marker>
<rawString>Mehryar Mohri. 1995. Matching patterns of an automaton. In Proc. Combinatorial Pattern Matching (CPM&apos;95), volume 937 of LNCS, pages 286-297, Espoo, Finland. Springer-Verlag.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jean-Eric Pin</author>
</authors>
<title>Varieties of Formal Languages. Foundations of Computer Science.</title>
<date>1986</date>
<publisher>North</publisher>
<location>Oxford.</location>
<contexts>
<context position="2136" citStr="Pin, 1986" startWordPosition="311" endWordPosition="312">ble. This viewpoint has led to introduction of new features into the formalism (Koskenniemi et al., 1992). It is, however, very difficult to make any a priori generalizations of the structural properties of automata as long as we allow unrestricted use of regular expressions. A complementary view is to analyze the properties of languages described by FSIG regular expressions. We can carry out the analysis by checking whether the languages can be described with a restricted class of regular expressions. For many such classes of expressions, there also exists a group-theoretic characterization (Pin, 1986). Moreover, if the analyzed regular language has favorable properties, some problems, e.g. the string membership problem, can be solved faster by means of specialized algorithms. A language can be described with a star-free regular expression if it can be constructed from alphabet symbols by application of union (A U B), complementation (A) and finite concatenation (AB), that is, without the Kleene closure (A*). The theoretical importance of this class of languages is supported by its characterization in terms of finite aperiodic syntactic monoids (Schiitzenberger, 1965) and by its definabilit</context>
</contexts>
<marker>Pin, 1986</marker>
<rawString>Jean-Eric Pin. 1986. Varieties of Formal Languages. Foundations of Computer Science. North Oxford.</rawString>
</citation>
<citation valid="true">
<title>Finite-state language processing.</title>
<date>1997</date>
<editor>Emmanuel Roche and Yves Schabes, editors.</editor>
<publisher>A Bradford Book, MIT Press,</publisher>
<location>Cambridge, MA.</location>
<marker>1997</marker>
<rawString>Emmanuel Roche and Yves Schabes, editors. 1997. Finite-state language processing. A Bradford Book, MIT Press, Cambridge, MA.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kai Salomaa</author>
<author>Sheng Yu</author>
</authors>
<title>Alternating finite automata and star-free languages.</title>
<date>2000</date>
<journal>Theoretical Computer Science,</journal>
<pages>234--167</pages>
<contexts>
<context position="25199" citStr="Salomaa and Yu, 2000" startWordPosition="4289" endWordPosition="4292">istic automata in FSIG parsing (Tapanainen, 1997). Finally, the main contribution of this paper is to show that ENGFSIG describes a star-free set of strings. It seems probable that this narrowing could be added to the FSIG framework in general. The computational complexity of many important decision problems for the FSIG grammars remains intractable in spite of the star-freeness property (Sistla and Clarke, 1985). Nevertheless, the improved descriptive complexity allows us to simplify some algorithms; we can, for example, implement the grammar with the class of loop-free alternating automata (Salomaa and Yu, 2000). Moreover, the restriction also means that the grammar is definable in a first-order logic that is interpreted over finite strings (McNaughton and Papert, 1971). This simplification is relevant to reconstruction of FSIG and similar finite-state models with logical specifications (Vaillette, 2001; Lager and Nivre, 2001). 6 Conclusion In this paper, the ENGFSIG description as a whole is shown to be a regular expression that reduces to a combination of union, complementation and finite concatenation. The current work has theoretical and practical consequences in processing of ENGFSIG (or similar</context>
</contexts>
<marker>Salomaa, Yu, 2000</marker>
<rawString>Kai Salomaa and Sheng Yu. 2000. Alternating finite automata and star-free languages. Theoretical Computer Science, 234:167-176.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Marcel Paul Schazenberger</author>
</authors>
<title>Finite counting automata.</title>
<date>1962</date>
<journal>Information and Control,</journal>
<pages>5--2</pages>
<marker>Schazenberger, 1962</marker>
<rawString>Marcel Paul Schazenberger. 1962. Finite counting automata. Information and Control, 5(2):91-107.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Marcel Paul Schiitzenberger</author>
</authors>
<title>On finite monoids having only trivial subgroups.</title>
<date>1965</date>
<journal>Information and Control,</journal>
<pages>8--2</pages>
<contexts>
<context position="2713" citStr="Schiitzenberger, 1965" startWordPosition="397" endWordPosition="398"> group-theoretic characterization (Pin, 1986). Moreover, if the analyzed regular language has favorable properties, some problems, e.g. the string membership problem, can be solved faster by means of specialized algorithms. A language can be described with a star-free regular expression if it can be constructed from alphabet symbols by application of union (A U B), complementation (A) and finite concatenation (AB), that is, without the Kleene closure (A*). The theoretical importance of this class of languages is supported by its characterization in terms of finite aperiodic syntactic monoids (Schiitzenberger, 1965) and by its definability in first-order logic over strings (McNaughton and Papert, 1971). The class has also a lot of practical importance, because many languages in it admit extremely simple implementations (ibid.). The question of the star-freeness restriction on FSIG constraints has not been studied before, possibly because of the following observations: (i) An acyclic automaton representing readings of the sentence has a central role in FSIG parsing (Tapanainen, 1997). Star-freeness of the constraints is a minor restriction when compared to the finiteness of this language. 379 (ii) If auto</context>
<context position="11937" citStr="Schiitzenberger, 1965" startWordPosition="2002" endWordPosition="2003"> to solve for an FSIG is the star-freeness problem. It is, given a grammar G, to determine whether the language L(G) is star-free i.e. whether it can be constructed from alphabet symbols by application of the boolean operators (U, and concatenation. Proposition 1. For a regular language L, the following properties are equivalent: • the language L is star-free, • there is a starfree regular expression, based on concatenation and the boolean operators, that describes the language L, • the syntactic monoid (McNaughton and Papert, 1968) that is canonically assigned to the language L is aperiodic (Schiitzenberger, 1965), • the language L is definable in propositional linear temporal logic (Kamp, 1968), and, • the language L is definable in a first-order logic that is interpreted over finite strings (McNaughton and Papert, 1971). Sometimes star-freeness of a language can be shown by means of closure properties of star-free languages. To start with, finite regular languages are star-free (especially 0, 6, a, and F, where 0 denotes the empty set of strings, a CE, and F C E) The Kleene closure of any subset F C E is also star-free, because I&apos; = 0[E — F10. If A and B are star-free languages, then we know that at </context>
</contexts>
<marker>Schiitzenberger, 1965</marker>
<rawString>Marcel Paul Schiitzenberger. 1965. On finite monoids having only trivial subgroups. Information and Control, 8(2):190-194.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Prasad Sistla</author>
<author>Edmund M Clarke</author>
</authors>
<title>The complexity of propositional linear temporal logic.</title>
<date>1985</date>
<journal>Journal of ACM,</journal>
<pages>32--733</pages>
<contexts>
<context position="24994" citStr="Sistla and Clarke, 1985" startWordPosition="4258" endWordPosition="4261">here intersection and complementation can occur inside the grammar automaton. Manipulation of alternating automata (Vardi, 1995) may help us to avoid the state explosion that is the main problem with deterministic automata in FSIG parsing (Tapanainen, 1997). Finally, the main contribution of this paper is to show that ENGFSIG describes a star-free set of strings. It seems probable that this narrowing could be added to the FSIG framework in general. The computational complexity of many important decision problems for the FSIG grammars remains intractable in spite of the star-freeness property (Sistla and Clarke, 1985). Nevertheless, the improved descriptive complexity allows us to simplify some algorithms; we can, for example, implement the grammar with the class of loop-free alternating automata (Salomaa and Yu, 2000). Moreover, the restriction also means that the grammar is definable in a first-order logic that is interpreted over finite strings (McNaughton and Papert, 1971). This simplification is relevant to reconstruction of FSIG and similar finite-state models with logical specifications (Vaillette, 2001; Lager and Nivre, 2001). 6 Conclusion In this paper, the ENGFSIG description as a whole is shown </context>
</contexts>
<marker>Sistla, Clarke, 1985</marker>
<rawString>A. Prasad Sistla and Edmund M. Clarke. 1985. The complexity of propositional linear temporal logic. Journal of ACM, 32:733-749.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Pasi Tapanainen</author>
</authors>
<title>Aeirellisiin automaatteihin perustuva luonnollisen kielen jeisennin. Licentiate thesis,</title>
<date>1992</date>
<institution>Department of Computer Science, University of Helsinki,</institution>
<contexts>
<context position="19182" citStr="Tapanainen (1992)" startWordPosition="3301" endWordPosition="3302">these, there are 2657 more complicated constraints. The schematic equivalences presented in Sections 3.3 — 3.4 can transform 1554 of these into a star-free form. However, there still remain 1103 constraints that use the restriction operator To complete the proof of the star-freeness of ENGFSIG, I show that star-free languages are closed under the restriction operation (as in FSIG). Compilation of the restriction operator (as in Two-Level Morphology) has been solved by means of marker symbols and transducers (Karttunen et al., 1987; Kaplan and Kay, 1994). To compile the restriction as in FSIG, Tapanainen (1992) used also a method that is perhaps most easily described with transducers. When there is only one context LC1 _ RC1, the restriction operator (as in TWOL and in FSIG) reduces to the following star-free formula (Karttunen et al., 1987): E*LCi X 0 n 0 X Rci E* I generalize this special case in the following new formula for n contexts LC i _ i = 1..n: 71 n [ nn _,) LCi ] X n RCi(i.F) i=1 i=1 where S = {1, 2,... , n} and E* ificF 0 otherwise; The above formula does not use markers, transducers, nor the Kleene star. Intuitively, it says that the string is rejected on the basis of the match of X, i</context>
<context position="23171" citStr="Tapanainen (1992)" startWordPosition="3976" endWordPosition="3977"> operator has one extra advantage over compilation methods that are based on marker symbols and transducers (Kaplan and Kay, 1994). In these methods, the markers have to be eliminated from the final language. Usually this requires determinization using the costly subset construction. The new formula does not involve markers and it therefore only needs to apply determinization at smaller sub-formulas. Methods that reduce the size of constraint automata can contribute to an efficient solution for the FSIG parsing problem (Koskenniemi, 1997) by producing a smaller representation for the grammar. Tapanainen (1992) has developed special optimizations that apply to automata during their construction. The current paper suggests manipulation of FSIG regular expressions before they are compiled into deterministic automata. The value of this approach is based on the fact that the construction of a deterministic automaton from a regular expression is, in the worst-case, exponential. The current paper provides the FSIG framework with a grammar semantics that is completely based on regular languages and a one-level representation. Our new formula for an n-context restriction operator does not make use of transd</context>
</contexts>
<marker>Tapanainen, 1992</marker>
<rawString>Pasi Tapanainen. 1992. Aeirellisiin automaatteihin perustuva luonnollisen kielen jeisennin. Licentiate thesis, Department of Computer Science, University of Helsinki, Finland.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Pasi Tapanainen</author>
</authors>
<title>Applying a finite-state intersection grammar.</title>
<date>1997</date>
<booktitle>In (Roche and Schabes,</booktitle>
<pages>311--327</pages>
<contexts>
<context position="1321" citStr="Tapanainen, 1997" startWordPosition="181" endWordPosition="182">or for further analysis of logical properties and possible optimizations in the FSIG descriptions. The proof contains a new formula for compiling Koskenniemi&apos;s restriction operation without any marker symbols. 1 Introduction For many years, various finite-state models of language (Roche and Schabes, 1997) have been used in surface-syntactic parsing. These models can process local syntactic ambiguity efficiently. However, because the formalism of FiniteState Intersection Grammar (Koskenniemi, 1990; Koskenniemi et al., 1992) allows full regular expressions, its parsing is sometimes inefficient (Tapanainen, 1997); many FSIG constraint automata can reduce ambiguity only after they have scanned the whole sentence. Regular expressions in FSIG can be viewed as a grammar-writing tool that should be as flexible as possible. This viewpoint has led to introduction of new features into the formalism (Koskenniemi et al., 1992). It is, however, very difficult to make any a priori generalizations of the structural properties of automata as long as we allow unrestricted use of regular expressions. A complementary view is to analyze the properties of languages described by FSIG regular expressions. We can carry out</context>
<context position="3189" citStr="Tapanainen, 1997" startWordPosition="469" endWordPosition="470">rtance of this class of languages is supported by its characterization in terms of finite aperiodic syntactic monoids (Schiitzenberger, 1965) and by its definability in first-order logic over strings (McNaughton and Papert, 1971). The class has also a lot of practical importance, because many languages in it admit extremely simple implementations (ibid.). The question of the star-freeness restriction on FSIG constraints has not been studied before, possibly because of the following observations: (i) An acyclic automaton representing readings of the sentence has a central role in FSIG parsing (Tapanainen, 1997). Star-freeness of the constraints is a minor restriction when compared to the finiteness of this language. 379 (ii) If automata states are encoded as &amp;quot;traces&amp;quot; into strings, any regular language can be represented as a homomorphic image of a (local) star-free language (Medvedev, 1964). Such an encoding is possible in a two-level view of the FSIG framework (Koskenniemi, 1997), where the morphological reading of the sentence is a homomorphic image of a level representing syntactically annotated readings. (iii) Given a finite automaton or a regular expression, checking star-freeness of the descri</context>
<context position="24627" citStr="Tapanainen, 1997" startWordPosition="4202" endWordPosition="4203">ction 4) and in the grammar altogether. The new formula for the restriction operator enables us to split an n-context restriction into 2&amp;quot; separate constraints (under intersection), each of which can be simplified, compiled and applied separately. It is also possible to compile the FSIG regular expressions directly into a single alternating finite automaton where intersection and complementation can occur inside the grammar automaton. Manipulation of alternating automata (Vardi, 1995) may help us to avoid the state explosion that is the main problem with deterministic automata in FSIG parsing (Tapanainen, 1997). Finally, the main contribution of this paper is to show that ENGFSIG describes a star-free set of strings. It seems probable that this narrowing could be added to the FSIG framework in general. The computational complexity of many important decision problems for the FSIG grammars remains intractable in spite of the star-freeness property (Sistla and Clarke, 1985). Nevertheless, the improved descriptive complexity allows us to simplify some algorithms; we can, for example, implement the grammar with the class of loop-free alternating automata (Salomaa and Yu, 2000). Moreover, the restriction </context>
</contexts>
<marker>Tapanainen, 1997</marker>
<rawString>Pasi Tapanainen. 1997. Applying a finite-state intersection grammar. In (Roche and Schabes, 1997), pages 311-327.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Nathan Vaillette</author>
</authors>
<title>Logical specification of transducers for NLP.</title>
<date>2001</date>
<booktitle>In Finite State Methods in Natural Language Processing 2001 (FSMNLP 2001), ESSLU I Workshop,</booktitle>
<pages>20--24</pages>
<location>Helsinki.</location>
<contexts>
<context position="25496" citStr="Vaillette, 2001" startWordPosition="4332" endWordPosition="4333">oblems for the FSIG grammars remains intractable in spite of the star-freeness property (Sistla and Clarke, 1985). Nevertheless, the improved descriptive complexity allows us to simplify some algorithms; we can, for example, implement the grammar with the class of loop-free alternating automata (Salomaa and Yu, 2000). Moreover, the restriction also means that the grammar is definable in a first-order logic that is interpreted over finite strings (McNaughton and Papert, 1971). This simplification is relevant to reconstruction of FSIG and similar finite-state models with logical specifications (Vaillette, 2001; Lager and Nivre, 2001). 6 Conclusion In this paper, the ENGFSIG description as a whole is shown to be a regular expression that reduces to a combination of union, complementation and finite concatenation. The current work has theoretical and practical consequences in processing of ENGFSIG (or similar) descriptions, context restrictions in the Two-Level Morphology, and Kleene closures in wider domains. Acknowledgments This work was supported by NorFA Ph.D. programme. I am grateful to Atro Voutilainen (and Connexor) for putting to my disposal the ENGFSIG description. I would also like to thank</context>
</contexts>
<marker>Vaillette, 2001</marker>
<rawString>Nathan Vaillette. 2001. Logical specification of transducers for NLP. In Finite State Methods in Natural Language Processing 2001 (FSMNLP 2001), ESSLU I Workshop, pages 20-24, Helsinki.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Moshe Y Vardi</author>
</authors>
<title>Alternating automata and program verification.</title>
<date>1995</date>
<booktitle>In Computer Science Today -Recent Trends and Developments,</booktitle>
<volume>1000</volume>
<pages>471--485</pages>
<publisher>Springer-Verlag.</publisher>
<contexts>
<context position="24498" citStr="Vardi, 1995" startWordPosition="4180" endWordPosition="4181">ov and Mosses, 1994) become much more usable and may lead to essential simplifications in the individual constraints (see Section 4) and in the grammar altogether. The new formula for the restriction operator enables us to split an n-context restriction into 2&amp;quot; separate constraints (under intersection), each of which can be simplified, compiled and applied separately. It is also possible to compile the FSIG regular expressions directly into a single alternating finite automaton where intersection and complementation can occur inside the grammar automaton. Manipulation of alternating automata (Vardi, 1995) may help us to avoid the state explosion that is the main problem with deterministic automata in FSIG parsing (Tapanainen, 1997). Finally, the main contribution of this paper is to show that ENGFSIG describes a star-free set of strings. It seems probable that this narrowing could be added to the FSIG framework in general. The computational complexity of many important decision problems for the FSIG grammars remains intractable in spite of the star-freeness property (Sistla and Clarke, 1985). Nevertheless, the improved descriptive complexity allows us to simplify some algorithms; we can, for e</context>
</contexts>
<marker>Vardi, 1995</marker>
<rawString>Moshe Y. Vardi. 1995. Alternating automata and program verification. In Computer Science Today -Recent Trends and Developments, volume 1000 of LNCS, pages 471-485. Springer-Verlag.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Atro Voutilainen</author>
</authors>
<title>Designing a Parsing Grammar.</title>
<date>1994</date>
<journal>Nr.</journal>
<volume>22</volume>
<institution>Department of General Linguistics. University of Helsinki.</institution>
<note>in Publications of the</note>
<contexts>
<context position="5350" citStr="Voutilainen, 1994" startWordPosition="806" endWordPosition="807">factor that induces a nontrivial permutation of the state space. For example, the parity language 0* (10*10*)* contains strings with an even number of occurrences of the factor &amp;quot;1&amp;quot;. Intuitively, it seems improbable that similar counting constraints occur in natural language grammars However, many regular expressions in Voutilainen&apos;s ENGFSIG (1994) involve the Kleene star. If we can explain why this does not affect the starfreeness of the language, we probably know more about the grammar itself. A significant contribution of this paper is the human-readable construction that rephrases ENGFSIG (Voutilainen, 1994) constraints without the Kleene star. To make the construction more systematic I first outline the framework of FSIG and define its star-freeness problem. After this I explore stars in the ENGFSIG description and reduce regular expressions in the description into their star-free equivalents. This approach extends to a closure property of the star-free regular languages under the restriction operator (of FSIG). 2 Finite-State Intersection Grammar In this section I define a class of finite-state intersection grammars and explain the star-freeness problem specific to them. The FSIG framework deve</context>
</contexts>
<marker>Voutilainen, 1994</marker>
<rawString>Atro Voutilainen. 1994. Designing a Parsing Grammar. Nr. 22 in Publications of the Department of General Linguistics. University of Helsinki.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>