<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.001129">
<title confidence="0.983765">
Plot Induction and Evolutionary Search for Story Generation
</title>
<author confidence="0.997457">
Neil McIntyre and Mirella Lapata
</author>
<affiliation confidence="0.999902">
School of Informatics, University of Edinburgh
</affiliation>
<address confidence="0.980222">
10 Crichton Street, Edinburgh, EH8 9AB, UK
</address>
<email confidence="0.994428">
n.d.mcintyre@sms.ed.ac.uk,mlap@inf.ed.ac.uk
</email>
<sectionHeader confidence="0.993811" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999117823529412">
In this paper we develop a story genera-
tor that leverages knowledge inherent in
corpora without requiring extensive man-
ual involvement. A key feature in our ap-
proach is the reliance on a story planner
which we acquire automatically by record-
ing events, their participants, and their
precedence relationships in a training cor-
pus. Contrary to previous work our system
does not follow a generate-and-rank archi-
tecture. Instead, we employ evolutionary
search techniques to explore the space of
possible stories which we argue are well
suited to the story generation task. Experi-
ments on generating simple children’s sto-
ries show that our system outperforms pre-
vious data-driven approaches.
</bodyText>
<sectionHeader confidence="0.998994" genericHeader="introduction">
1 Introduction
</sectionHeader>
<bodyText confidence="0.999950786885246">
Computer story generation has met with fasci-
nation since the early days of artificial intelli-
gence. Indeed, over the years, several genera-
tors have been developed capable of creating sto-
ries that resemble human output. To name only
a few, TALE-SPIN (Meehan, 1977) generates sto-
ries through problem solving, MINSTREL (Turner,
1992) relies on an episodic memory scheme, es-
sentially a repository of previous hand-coded sto-
ries, to solve the problems in the current story,
and MAKEBELIEVE (Liu and Singh, 2002) uses
commonsense knowledge to generate short stories
from an initial seed story (supplied by the user). A
large body of more recent work views story gener-
ation as a form of agent-based planning (Swartjes
and Theune, 2008; Pizzi et al., 2007). The agents
act as characters with a list of goals. They form
plans of action and try to fulfill them. Interesting
stories emerge as plans interact and cause failures
and possible replanning.
The broader appeal of computational story gen-
eration lies in its application potential. Examples
include the entertainment industry and the devel-
opment of tools that produce large numbers of
plots automatically that might provide inspiration
to professional screen writers (Agudo et al., 2004);
rendering video games more interesting by allow-
ing the plot to adapt dynamically to the players’
actions (Barros and Musse, 2007); and assisting
teachers to create or personalize stories for their
students (Riedl and Young, 2004).
A major stumbling block for the widespread use
of computational story generators is their reliance
on expensive, manually created resources. A typi-
cal story generator will make use of a knowledge
base for providing detailed domain-specific infor-
mation about the characters and objects involved
in the story and their relations. It will also have a
story planner that specifies how these characters
interact, what their goals are and how their ac-
tions result in different story plots. Finally, a sen-
tence planner (coupled with a surface realizer) will
render an abstract story specification into natural
language text. Traditionally, most of this knowl-
edge is created by hand, and the effort must be re-
peated for new domains, new characters and plot
elements.
Fortunately, recent work in natural language
processing has taken significant steps towards de-
veloping algorithms that learn some of this knowl-
edge automatically from natural language cor-
pora. Chambers and Jurafsky (2009, 2008) pro-
pose an unsupervised method for learning narra-
tive schemas, chains of events whose arguments
are filled with participant semantic roles defined
over words. An example schema is {X arrest, X
charge, X raid, X seize, X confiscate, X detain, X
deport}, where X stands for the argument types
{police, agent, authority, government}. Their ap-
proach relies on the intuition that in a coherent
text events that are about the same participants are
</bodyText>
<page confidence="0.951517">
1562
</page>
<note confidence="0.9432365">
Proceedings of the 48th Annual Meeting of the Association for Computational Linguistics, pages 1562–1572,
Uppsala, Sweden, 11-16 July 2010. c�2010 Association for Computational Linguistics
</note>
<bodyText confidence="0.999706304347826">
likely to be part of the same story or narrative.
Their model extracts narrative chains, essentially
events that share argument slots and merges them
into schemas. The latter could be used to construct
or enrich the knowledge base of a story generator.
In McIntyre and Lapata (2009) we presented a
story generator that leverages knowledge inherent
in corpora without requiring extensive manual in-
volvement. The generator operates over predicate-
argument and predicate-predicate co-occurrence
tuples gathered from training data. These are used
to produce a large set of candidate stories which
are subsequently ranked based on their interest-
ingness and coherence. The approach is unusual
in that it does not involve an explicit story plan-
ning component. Stories are created stochastically
by selecting entities and the events they are most
frequently attested with.
In this work we develop a story generator that
is also data-driven but crucially relies on a story
planner for creating meaningful stories. Inspired
by Chambers and Jurafsky (2009) we acquire story
plots automatically by recording events, their par-
ticipants, and their precedence relationships as at-
tested in a training corpus. Entities give rise to
different potential plots which in turn generate
multiple stories. Contrary to our previous work
(McIntyre and Lapata, 2009), we do not follow a
generate-and-rank architecture. Instead, we search
the space of possible stories using Genetic Algo-
rithms (GAs) which we argue are advantageous
in the story generation setting, as they can search
large fitness landscapes while greatly reducing the
risk of getting stuck in local optima. By virtue of
exploring the search space more broadly, we are
able to generate creative stories without an explicit
interest scoring module.
In the remainder of this paper we give a brief
overview of the system described in McIntyre and
Lapata (2009) and discuss previous applications of
GAs in natural language generation (Section 2).
Next, we detail our approach, specifically how
plots are created and used in conjunction with ge-
netic search (Sections 3 and 4). Finally, we present
our experimental results (Sections 6 and 7) and
conclude the paper with discussion of future work.
</bodyText>
<sectionHeader confidence="0.999803" genericHeader="related work">
2 Related Work
</sectionHeader>
<bodyText confidence="0.9999826">
Our work builds on and extends the story genera-
tor developed in McIntyre and Lapata (2009). The
system creates simple children’s stories in an in-
teractive context: the user supplies the topic of the
story and its desired length (number of sentences).
The generator creates a story following a pipeline
architecture typical of natural language generation
systems (Reiter and Dale, 2000) consisting of con-
tent selection, sentence planning, and surface real-
ization.
The content of a story is determined by consult-
ing a data-driven knowledge base that records the
entities (i.e., nouns) appearing in a corpus and the
actions they perform. These are encoded as depen-
dency relations (e.g., subj-verb, verb-obj). In order
to promote between-sentence coherence the gen-
erator also make use of an action graph that con-
tains action-role pairs and the likelihood of tran-
sitioning from one to another. The sentence plan-
ner aggregates together entities and their actions
into a sentence using phrase structure rules. Fi-
nally, surface realization is performed by interfac-
ing RealPro (Lavoie and Rambow, 1997) with a
language model. The system searches for the best
story overall as well as the best sentences that can
be generated from the knowledge base. Unlikely
stories are pruned using beam search. In addition,
stories are reranked using two scoring functions
based on coherence and interest. These are learnt
from training data, i.e., stories labeled with nu-
meric values for interest and coherence.
Evolutionary search techniques have been pre-
viously employed in natural language generation,
especially in the context of document planning.
Structuring a set of facts into a coherent text is ef-
fectively a search problem that may lead to com-
binatorial explosion for large domains. Mellish
et al. (1998) (and subsequently Karamanis and
Manurung 2002) advocate genetic algorithms as
an alternative to exhaustively searching for the op-
timal ordering of descriptions of museum arte-
facts. Rather than requiring a global optimum to
be found, the genetic algorithm selects an order
(based on coherence) that is good enough for peo-
ple to understand. Cheng and Mellish (2000) focus
on the interaction of aggregation and text planning
and use genetic algorithms to search for the best
aggregated document that satisfies coherence con-
straints.
The application of genetic algorithms to story
generation is novel to our knowledge. Our work
also departs from McIntyre and Lapata (2009) in
two important ways. Firstly, our generator does
not rely on a knowledge base of seemingly un-
related entities and relations. Rather, we employ
</bodyText>
<page confidence="0.946857">
1563
</page>
<bodyText confidence="0.9998789">
a document planner to create and structure a plot
for a story. The planner is built automatically from
a training corpus and creates plots dynamically
depending on the protagonists of the story. Sec-
ondly, our search procedure is simpler and more
global; instead of searching for the best story twice
(i.e., by first finding the n-best stories and then
subsequently reranking them based on coherence
and interest), our genetic algorithm explores the
space of possible stories once.
</bodyText>
<sectionHeader confidence="0.973968" genericHeader="method">
3 Plot Generation
</sectionHeader>
<bodyText confidence="0.999934476190476">
Following previous work (e.g., Shim and Kim
2002; McIntyre and Lapata 2009) we assume that
the user supplies a sentence (e.g., the princess
loves the prince) from which the system creates
a story. Each entity in this sentence (e.g., princess,
prince) is associated with its own narrative
schema, a set of key events and actors co-
occurring with it in the training corpus. Our nar-
rative schemas differ slightly from Chambers and
Jurafsky (2009). They acquire schematic represen-
tations of situations akin to FrameNet (Fillmore
et al., 2003): schemas consists of semantically
similar predicates and the entities evoked by them.
In our setting, every entity has its own schema, and
predicates associated with it are ordered. Plots are
generated by merging the entity-specific narrative
schemas which subsequently serve as the input to
the genetic algorithm. In the following we describe
how the narrative schemas are extracted and plots
merged, and then discuss our evolutionary search
procedure.
</bodyText>
<subsectionHeader confidence="0.646156">
Entity-based Schema Extraction Before we
</subsectionHeader>
<bodyText confidence="0.999608076923077">
can generate a plot for a story we must have an
idea of the actions associated with the entities in
the story, the order in which these actions are per-
formed and also which other entities can partici-
pate. This information is stored in a directed graph
which we explain below. Our algorithm processes
each document at a time, it operates over depen-
dency structures and assumes that entity mentions
have been resolved. In our experiments we used
Rasp (Briscoe and Carroll, 2002), a broad cover-
age dependency parser, and the OpenNLP1 coref-
erence resolution engine.2 However, any depen-
dency parser or coreference tool could serve our
</bodyText>
<footnote confidence="0.9944892">
1See http://opennlp.sourceforge.net/.
2The coreference resolution tool we employ is not
error-free and on occasion will fail to resolve a pronoun. We
map unresolved pronouns to the generic labels person or ob-
ject.
</footnote>
<bodyText confidence="0.980292673076923">
purpose. We also assume that the actions associ-
ated with a given entity are ordered and that lin-
ear order corresponds to temporal order. This is a
gross simplification as it is well known that tem-
poral relationships between events are not limited
to precedence, they may overlap, occur simultane-
ously, or be temporally unrelated. We could have
obtained a more accurate ordering using a tempo-
ral classifier (see Chambers and Jurafsky 2008),
however we leave this to future work.
For each entity e in the corpus we build a di-
rected graph G = (V,E) whose nodes V denote
predicate argument relationships, and edges E rep-
resent transitions from node Vi to node Vj. As
an example of our schema construction process,
consider a very small corpus consisting of the
two documents shown in Figure 1. The schema
for princess after processing the first document is
given on the left hand side. Each node in this graph
corresponds to an action attested with princess (we
also record who performs it and where or how).
Nodes are themselves dependency trees (see Fig-
ure 4a), but are linearized in the figure for the
sake of brevity. Edges in the graph indicate order-
ing and are weighted using the mutual informa-
tion metric proposed in Lin (1998) (the weights
are omitted from the example).3 The first sentence
in the text gives rise to the first node in the graph,
the second sentence to the second node, and so on.
Note that the third sentence is not present in the
graph as it is not about the princess.
When processing the second document, we sim-
ply expand this graph. Before inserting a new
node, we check if it can be merged with an al-
ready existing one. Nodes are merged only if they
have the same verb and similar arguments, with
the focal entity (i.e., princess) appearing in the
same argument slot. In our example, the nodes
“prince marry princess in castle” and “prince
marry princess in temple” can be merged as they
contain the same verb and number of similar ar-
guments. The nodes “princess have influence”
and “princess have baby” cannot be merged as
influence and baby are semantically unrelated.
We compute argument similarity using WordNet
(Fellbaum, 1998) and the measure proposed by
Wu and Palmer (1994) which is based on path
length. We merge nodes with related arguments
only if their similarity exceeds a threshold (deter-
mined empirically).
3We use mutual information to identify event sequences
strongly associated with the graph entity.
</bodyText>
<page confidence="0.982756">
1564
</page>
<bodyText confidence="0.985584733333333">
The goblin holds the princess in a lair.
The prince rescues the princess and
marries her in a castle. The ceremony
is beautiful. The princess has influence
as the prince rules the country.
goblin hold princess in lair
prince rescue princess
prince marry princess in castle
princess have influence
The dragon holds the princess in a
cave. The prince slays the dragon. The
princess loves the prince. The prince
asks the king’s permission. The prince
marries the princess in the temple. The
princess has a baby.
</bodyText>
<figure confidence="0.861534571428571">
� goblin � � lair~
hold princess in
dragon cave
prince rescue princess princess love prince
� castle �
prince marry princess in temple
princess have influence princess have baby
</figure>
<figureCaption confidence="0.999987">
Figure 1: Example of schema construction for the entity princess
</figureCaption>
<bodyText confidence="0.999795214285714">
The schema construction algorithm terminates
when graphs like the ones shown in Figure 1 (right
hand side) have been created for all entities in the
corpus.
Building a Story Plot Our generator takes an in-
put sentence and uses it to instantiate several plots.
We achieve this by merging the schemas associ-
ated with the entities in the sentence into a plot
graph. As an example, consider again the sentence
the princess loves the prince which requires comb-
ing the schemas representing prince and princess
shown in Figures 2 and 1 (right hand side), re-
spectively. Again, we look for nodes that can be
merged based on the identity of the actions in-
volved and the (WordNet) similarity of their ar-
guments. However, we disallow the merging of
nodes with focal entities appearing in the same ar-
gument slot (e.g., “[prince, princess] cries”).
Once the plot graph is created, a depth first
search starting from the node corresponding to
the input sentence, finds all paths with length
matching the desired story length (cycles are dis-
allowed). Assuming we wish to generate a story
consisting of three sentences, the graph in Figure 3
would create four plots. These are (princess love
prince, prince marry princess in [castle, temple],
princess have influence), (princess love prince,
prince marry princess in [castle, temple], princess
have baby), (princess love prince, prince marry
princess in [castle, temple], prince rule country),
and (princess love prince, prince ask king’s per-
mission prince marry princess in [castle, temple]).
Each of these plots represents two different stories
one with castle and one with temple in it.
Sentence Planning The sentence planner is in-
terleaved with the story planner and influences
the final structure of each sentence in the story.
To avoid generating short sentences — note that
nodes in the plot graph consist of a single ac-
tion and would otherwise correspond to a sentence
with a single clause — we combine pairs of nodes
within the same graph by looking at intrasenten-
tial verb-verb co-occurrences in the training cor-
pus. For example, the nodes (prince have prob-
lem, prince keep secret) could become the sen-
tence the prince has a problem keeping a secret.
We leave it up to the sentence planner to decide
how the two actions should be combined.4 The
sentence planner will also insert adverbs and ad-
jectives, using co-occurrence likelihoods acquired
from the training corpus. It is essentially a phrase
structure grammar compiled from the lexical re-
sources made available by Korhonen and Briscoe
(2006) and Grishman et al. (1994). The grammar
rules act as templates for combining clauses and
filling argument slots.
</bodyText>
<footnote confidence="0.9993615">
4We only turn an action into a subclause if its subject en-
tity is same as that of the previous action.
</footnote>
<page confidence="0.936883">
1565
</page>
<figure confidence="0.7905562">
prince slay dragon
princess love prince
� goblin � � lair �
hold princess in
dragon cave
prince slay dragon
prince rescue princess prince ask king’s permission prince rescue princess princess love prince
~ castle
prince marry princess in temple
prince rule country
</figure>
<figureCaption confidence="0.97791">
Figure 2: Narrative schema for the entity prince.
</figureCaption>
<sectionHeader confidence="0.996846" genericHeader="method">
4 Genetic Algorithms
</sectionHeader>
<bodyText confidence="0.999958194444445">
The example shown in Figure 3 is a simplified ver-
sion of a plot graph. The latter would normally
contain hundreds of nodes and give rise to thou-
sands of stories once lexical variables have been
expanded. Searching the story space is a difficult
optimization problem, that must satisfy several
constraints: the story should be of a certain length,
overall coherent, creative, display some form of
event progression, and generally make sense. We
argue that evolutionary search is appealing here, as
it can find global optimal solutions in a more effi-
cient way than traditional optimization methods.
In this study we employ genetic algorithms
(GAs) a well-known search technique for finding
approximate (or exact) solutions to optimization
problems. The basic idea behind GAs is based
on “natural selection” and the Darwinian princi-
ple of the survival of the fittest (Mitchell, 1998).
An initial population is randomly created contain-
ing a predefined number of individuals (or solu-
tions), each represented by a genetic string (e.g., a
population of chromosomes). Each individual is
evaluated according to an objective function (also
called a fitness function). A number of individu-
als are then chosen as parents from the population
according to their fitness, and undergo crossover
(also called recombination) and mutation in order
to develop the new population. Offspring with bet-
ter fitness are then inserted into the population,
replacing the inferior individuals in the previous
generation.
The algorithm thus identifies the individuals
with the optimizing fitness values, and those with
lower fitness will naturally get discarded from the
population. This cycle is repeated for a given num-
ber of generations, or stopped when the solution
</bodyText>
<figure confidence="0.311255">
princess have baby
</figure>
<figureCaption confidence="0.980684">
Figure 3: Plot graph for the input sentence the
princess loves the prince.
</figureCaption>
<bodyText confidence="0.995841034482759">
obtained is considered optimal. This process leads
to the evolution of a population in which the in-
dividuals are more and more suited to their envi-
ronment, just as natural adaptation. We describe
below how we developed a genetic algorithm for
our story generation problem.
Initial Population Rather than start with a ran-
dom population, we seed the initial population
with story plots generated from our plot graph.
For an input sentence, we generate all possible
plots. The latter are then randomly sampled until a
population of the desired size is created. Contrary
to McIntyre and Lapata (2009), we initialize the
search with complete stories, rather than generate
one sentence at a time. The genetic algorithm will
thus avoid the pitfall of selecting early on a solu-
tion that will later prove detrimental.
Crossover Each plot is represented as an or-
dered graph of dependency trees (corresponding
to sentences). We have decided to use crossover of
a single point between two selected parents. The
children will therefore contain sentences up to the
crossover point of the first parent and sentences
after that point of the second. Figure 4a shows
two parents (prince rescue princess, prince marry
princess in castle, princess have baby) and (prince
rescue princess, prince love princess, princess kiss
prince) and how two new plots are created by
swapping their last nodes.
</bodyText>
<figure confidence="0.988883417910447">
� castle �
prince marry princess in temple
prince ask king’s
permission
princess have influence
prince rule country
1566
rescue
prince princess
love
prince princess
have
princess baby
prince princess castle
kiss
prince princess
prince princess castle
have
princess baby
prince princess
marry
love
rescue
prince princess
in marry in
rescue
prince princess
prince princess
kiss
princess prince
a) rescue
b) marry c) rescue rescue
castle
prince princess
kiss
prince princess
in
prince princess castle
marry
��
escape
princess dragon
��
prince princess
prince princess
d) rescue
prince princess
in
prince princess castle
kiss
prince princess
e) knows
prince
marry
kiss
prince princess
hall
temple
forest
kingdom
marry
in
prince princess castle
hold
prince princess
loves
princess child
</figure>
<figureCaption confidence="0.998878">
Figure 4: Example of genetic algorithm operators as they are applied to plot structures: a) crossover of
</figureCaption>
<bodyText confidence="0.996028782608696">
two plots on a single point, indicated by the dashed line, resulting in two children which are a recombi-
nation of the parents; b) mutation of a lexical node, church can be replaced from a list of semantically
related candidates; c) sentences can be switched under mutation to create a potentially more coherent
structure; d) if the matrix verb undergoes mutation then, a random sentence is generated to replace it; e)
if the verb chosen for mutation is the head of a subclause, then a random subclause replaces it.
Mutation Mutation can occur on any verb,
noun, adverb, or adjective in the plot. If a noun,
adverb or adjective is chosen to undergo mutation,
then we simply substitute it with a new lexical item
that is sufficiently similar (see Figure 4b for an
example). Verbs, however, have structural impor-
tance in the stories and we cannot simply replace
them without taking account of their arguments.
If a matrix verb is chosen to undergo mutation,
then a new random sentence is generated to re-
place the entire sentence (see Figure 4d). If it is
a subclause, then it is replaced with a randomly
generated clause, headed by a verb that has been
seen in the corpus to co-occur with the matrix verb
(Figure 4e). The sentence planner selects and fills
template trees for generating random clauses. Mu-
tation may also change the order of any two nodes
in the graph in the hope that this will increase the
story’s coherence or create some element of sur-
prise (see Figure 4c).
Selection To choose the plots for the next gener-
ation, we used fitness proportional selection (also
know as roulette-wheel selection, Goldberg 1989)
which chooses candidates randomly but with a
bias towards those with a larger proportion of the
population’s combined fitness. We do not want to
always select the fittest candidates as there may
be valid partial solutions held within less fit mem-
bers of the population. However, we did employ
some elitism by allowing the top 1% of solutions
to be copied straight from one generation to the
next. Note that our candidates may also represent
invalid solutions. For instance, through crossover
it is possible to create a plot in which all or some
nodes are identical. If any such candidates are
identified, they are assigned a low fitness, without
however being eliminated from the population as
some could be used to create fitter solutions.
In a traditional GA, the fitness function deals
with one optimization objective. It is possible to
optimize several objectives either using a vot-
</bodyText>
<page confidence="0.987371">
1567
</page>
<bodyText confidence="0.999989333333333">
ing model or more sophisticated methods such as
Pareto ranking (Goldberg, 1989). Following previ-
ous work (Mellish et al., 1998) we used a single fit-
ness function that scored candidates based on their
coherence. Our function was learned from training
data using the Entity Grid document representa-
tion proposed in Barzilay and Lapata (2007). An
entity grid is a two-dimensional array in which
columns correspond to entities and rows to sen-
tences. Each cell indicates whether an entity ap-
pears in a given sentence or not and whether it is a
subject, object or neither. For training, this repre-
sentation is converted into a feature vector of en-
tity transition sequences and a model is learnt from
examples of coherent and incoherent stories. The
latter can be easily created by permuting the sen-
tences of coherent stories (assuming that the orig-
inal story is more coherent than its permutations).
In addition to coherence, in McIntyre and La-
pata (2009) we used a scoring function based on
interest which we approximated with lexical and
syntactic features such as the number of noun/verb
tokens/types, the number of subjects/objects, the
number of letters, word familiarity, imagery, and
so on. An interest-based scoring function made
sense in our previous setup as a means of selecting
unusual stories. However, in the context of genetic
search such a function seems redundant as inter-
esting stories emerge naturally through the opera-
tions of crossover and mutation.
</bodyText>
<sectionHeader confidence="0.981367" genericHeader="method">
5 Surface Realization
</sectionHeader>
<bodyText confidence="0.9999665">
Once the final generation of the population has
been reached, the fittest story is selected for sur-
face realization. The realizer takes each sentence
in the story and reformulates it into input com-
patible with the RealPro (Lavoie and Rambow,
1997) text generation engine. Realpro creates sev-
eral variants of the same story differing in the
choice of determiners, number (singular or plural),
and prepositions. A language model is then used
to select the most probable realization (Knight
and Hatzivassiloglou, 1995). Ideally, the realizer
should also select an appropriate tense for the sen-
tence. However, we make the simplifying assump-
tion that all sentences are in the present tense.
</bodyText>
<sectionHeader confidence="0.996516" genericHeader="method">
6 Experimental Setup
</sectionHeader>
<bodyText confidence="0.9999613125">
In this section we present our experimental set-up
for assessing the performance of our story genera-
tor. We give details on our training corpus, system,
parameters (such as the population size for the GA
search), the baselines used for comparison, and ex-
plain how our system output was evaluated.
Corpus The generator was trained on the same
corpus used in McIntyre and Lapata (2009), 437
stories from the Andrew Lang fairy tales collec-
tion.5 The average story length is 125.18 sen-
tences. The corpus contains 15,789 word tokens.
Following McIntyre and Lapata, we discarded to-
kens that did not appear in the Children’s Printed
Word Database6, a database of printed word fre-
quencies as read by children aged between five
and nine. From this corpus we extracted narrative
schemas for 667 entities in total. We disregarded
any graph that contained less than 10 nodes as too
small. The graphs had on average 61.04 nodes,
with an average clustering rate7 of 0.027 which in-
dicates that they are substantially connected.
Parameter Setting Considerable latitude is
available when selecting parameters for the GA.
These involve the population size, crossover, and
mutation rates. To evaluate which setting was best,
we asked two human evaluators to rate (on a 1–5
scale) stories produced with a population size
ranging from 1,000 to 10,000, crossover rate of 0.1
to 0.6 and mutation rate of 0.001 to 0.1. For each
run of the system a limit was set to 5,000 genera-
tions. The human ratings revealed that the best sto-
ries were produced for a population size of 10,000,
a crossover rate of 0.1% and a mutation rate
of 0.1%. Compared to previous work (e.g., Kara-
manis and Manurung 2002) our crossover rate
may seem low and the mutation rate high. How-
ever, it makes intuitively sense, as high crossover
may lead to incoherence by disrupting canonical
action sequences found in the plots. On the other
hand, a higher mutation will raise the likelihood of
a lexical item being swapped for another and may
improve overall coherence and interest. The fit-
ness function was trained on 200 documents from
the fairy tales collection using Joachims’s (2002)
SVMlight package and entity transition sequences
of length 2. The realizer was interfaced with a tri-
gram language model trained on the British Na-
tional Corpus with the SRI toolkit.
</bodyText>
<footnote confidence="0.999381166666667">
5Available from http://homepages.inf.ed.ac.uk/
s0233364/McIntyreLapata09/.
6http://www.essex.ac.uk/psychology/cpwd/
7Clustering rate (or transitivity) is the number of triangles
in the graph — sets of three vertices each of which is con-
nected to each of the others.
</footnote>
<page confidence="0.995051">
1568
</page>
<bodyText confidence="0.999829146341463">
Evaluation We compared the stories gener-
ated by the GA against those produced by the
rank-based system described in McIntyre and La-
pata (2009) and a system that creates stories from
the plot graph, without any stochastic search.
Since plot graphs are weighted, we can simply se-
lect the graph with the highest weight. After ex-
panding all lexical variables, the chosen plot graph
will give rise to different stories (e.g., castle or
temple in the example above). We select the story
ranked highest according to our coherence func-
tion. In addition, we included a baseline which
randomly selects sentences from the training cor-
pus provided they contain either of the story pro-
tagonists (i.e., entities in the input sentence). Sen-
tence length was limited to 12 words or less as this
was on average the length of the sentences gener-
ated by our GA system.
Each system created stories for 12 input sen-
tences, resulting in 48 (4x12) stories for eval-
uation. The sentences used commonly occurring
entities in the fairy tales corpus (e.g., The child
watches the bird, The emperor rules the kingdom.,
The wizard casts the spell.). The stories were split
into three sets containing four stories from each
system but with only one story from each input
sentence. All stories had the same length, namely
five sentences. Human judges were presented with
one of the three sets and asked to rate the stories
on a scale of 1 to 5 for fluency (was the sentence
grammatical?), coherence (does the story make
sense overall?) and interest (how interesting is the
story?). The stories were presented in random or-
der and participants were told that all of them
were generated by a computer program. They were
instructed to rate more favorably interesting sto-
ries, stories that were comprehensible and overall
grammatical. The study was conducted over the
Internet using WebExp (Keller et al., 2009) and
was completed by 56 volunteers, all self reported
native English speakers.
</bodyText>
<sectionHeader confidence="0.999805" genericHeader="conclusions">
7 Results
</sectionHeader>
<bodyText confidence="0.99935525">
Our results are summarized in Table 1 which lists
the average human ratings for the four systems.
We performed an Analysis of Variance (ANOVA)
to examine the effect of system type on the story
generation task. Statistical tests were carried out
on the mean of the ratings shown in Table 1 for
fluency, coherence, and interest.
In terms of interest, the GA-based system is sig-
</bodyText>
<table confidence="0.99947">
System Fluency Coherence Interest
GA-based 3.09 2.48 2.36
Plot-based 3.03 2.36 2.14*
Rank-based 1.96** 1.65* 1.85*
Random 3.10 2.23* 2.20*
</table>
<tableCaption confidence="0.96271225">
Table 1: Human evaluation results: mean story
ratings for four story generators; * : p &lt; 0.05,
** : p &lt; 0.01, significantly different from
GA-based system.
</tableCaption>
<bodyText confidence="0.9993237">
nificantly better than the Rank-based, Plot-based
and Random ones (using a Post-hoc Tukey test,
a&lt; 0.05). With regard to fluency, the Rank-
based system is significantly worse than the rest
(a &lt; 0.01). Interestingly, the sentences generated
by the GA and Plot-based systems are as fluent as
those created by humans. Recall that the Random
system, simply selects sentences from the train-
ing corpus. Finally, the GA system is significantly
more coherent than the Rank-based and Random
systems (a &lt; 0.05), but not the Plot-based one.
This is not surprising, the GA and Plot-based sys-
tems rely on similar plots to create a coherent
story. The performance of the Random system is
also inferior as it does not have any explicit coher-
ence enforcing mechanism. The Rank-based sys-
tem is perceived overall worse. As this system is
also the least fluent, we conjecture that partici-
pants are influenced in their coherence judgments
by the grammaticality of the stories.
Overall our results indicate that an explicit story
planner improves the quality of the generated sto-
ries, especially when coupled with a search mech-
anism that advantageously explores the search
space. It is worth noting that the Plot-based sys-
tem is relatively simple, however the explicit use
of a story plot, seems to make up for the lack of
sophisticated search and more elaborate linguis-
tic information. Example stories generated by the
four systems are shown in Table 2 for the input
sentences The emperor rules the kingdom and The
child watches the bird.
Possible extensions and improvements to the
current work are many and varied. Firstly, we
could improve the quality of our plot graphs by
taking temporal knowledge into account and mak-
ing use of knowledge bases such as WordNet
and ConceptNet (Liu and Davenport, 2004), a
freely available commonsense knowledge base.
Secondly, our fitness function optimizes one ob-
</bodyText>
<page confidence="0.874358">
1569
</page>
<bodyText confidence="0.967203255319149">
The emperor rules the kingdom. The kingdom The child watches the bird. The bird weeps
holds on to the emperor. The emperor rides for the child. The child begs the bird to lis-
out of the kingdom. The kingdom speaks out ten.The bird dresses up the child. The child
against the emperor. The emperor lies. grows up.
The emperor rules the kingdom. The emperor The child watches the bird. The bird comes
takes over. The emperor goes on to feel for the oughly. The bird sees the child. The child sits
Plot down.
kingdom. Possibly the emperor sleeps. The
emperor steals.
to eat away at the child. The child does thor-
lGAPto The emperor rules the kingdom. The kingdom The child watches the bird. The bird lives
kRna lives from the reign to the emperor. The em- from the reign to the child. The child thanks
peror feels that the brothers tempt a beauty the victory for blessing the thought. The child
into the game. The kingdom saves the life loves to hate the sun with the thought. The
from crumbling the earth into the bird. The child hopes to delay the duty from the happi-
kingdom forces the whip into wiping the tears ness.
on the towel.
Random Exclaimed the emperor when Petru had put They cried, “what a beautiful child!” “No,
his question. In the meantime, mind you take that I cannot do, my child” he said at last.
good care of our kingdom. At first the em- “What is the matter, dear child?” “You wicked
peror felt rather distressed. The dinner of an child,” cried the Witch. Well, I will watch till
emperor! Thus they arrived at the court of the the bird comes.
emperor.
Table 2: Stories generated by a system that uses plots and genetic search (PlotGA), a system that uses
only plots (Plot), McIntyre and Lapata (2009)’s rank-based system (Rank) and a system that randomly
pastes together sentences from the training corpus (Random).
jective, namely coherence. In the future we plan to
explore multiple objectives, such as whether the
story is verbose, readable (using existing readabil-
ity metrics), has two many or two few protago-
nists, and so on.
Thirdly, our stories would benefit from some ex-
plicit modeling of discourse structure. Although
the plot graph captures the progression of the ac-
tions in a story, we would also like to know where
in the story these actions are likely to occur—
some tend to appear in the beginning and others in
the end. Such information would allow us to struc-
ture the stories better and render them more natu-
ral sounding. For example, an improvement would
be the inclusion of proper endings, as the stories
are currently cut off at an arbitrary point when the
desired maximum length is reached.
Finally, the fluency of the stories would bene-
fit from generating referring expressions, multiple
tense forms, indirect speech, aggregation and gen-
erally more elaborate syntactic structure.
</bodyText>
<sectionHeader confidence="0.982072" genericHeader="references">
References
</sectionHeader>
<bodyText confidence="0.891151038461539">
Agudo, Bel´en Di´az, Pablo Gerv´as, and Fred-
erico Peinado. 2004. A case based reason-
ing approach to story plot generation. In
Proceedings of the 7th European Conference
on Case-Based Reasoning. Springer, Madrid,
Spain, pages 142–156.
Barros, Leandro Motta and Soraia Raupp Musse.
2007. Planning algorithms for interactive story-
telling. In Computers in Entertainment (CIE),
Association for Computing Machinery (ACM),
volume 5.
Barzilay, Regina and Mirella Lapata. 2007. Mod-
eling local coherence: An entity-based ap-
proach. Computational Linguistics 34(1):1–34.
Briscoe, E. and J. Carroll. 2002. Robust accurate
statistical annotation of general text. In Pro-
ceedings of the 3rd International Conference on
Language Resources and Evaluation. Las Pal-
mas, Gran Canaria, pages 1499–1504.
Chambers, Nathanael and Dan Jurafsky. 2008.
Unsupervised learning of narrative event chains.
In Proceedings of 46th Annual Meeting of the
Association for Computational Linguistics: Hu-
man Language Technologies. Columbus, Ohio,
pages 789–797.
Chambers, Nathanael and Dan Jurafsky. 2009.
</bodyText>
<page confidence="0.972765">
1570
</page>
<bodyText confidence="0.844399333333333">
Unsupervised learning of narrative schemas and
their participants. In Proceedings of the Joint
Conference of the 47th Annual Meeting of the
ACL and the 4th International Joint Conference
on Natural Language Processing of the AFNLP.
Singapore, pages 602–610.
</bodyText>
<reference confidence="0.987113150537634">
Cheng, Hua and Chris Mellish. 2000. Captur-
ing the interaction between aggregation and text
planning in two generation systems. In Pro-
ceedings of the 1st International Conference on
Natural Language Generation. Mitzpe Ramon,
Israel, pages 186–193.
Fellbaum. 1998. WordNet: An Electronic Lexi-
cal Database (Language, Speech, and Commu-
nication). The MIT Press, Cambridge, Mas-
sachusetts.
Fillmore, Charles J., Christopher R. Johnson, and
Miriam R. L. Petruck. 2003. Background to
FrameNet. International Journal of Lexicogra-
phy 16:235–250.
Goldberg, David E. 1989. Genetic Algorithms
in Search, Optimization and Machine Learning.
Addison-Wesley Longman Publishing Co., Inc.,
Boston, Massachusetts.
Grishman, Ralph, Catherine Macleod, and Adam
Meyers. 1994. COMLEX syntax: Building a
computational lexicon. In Proceedings of the
15th COLING. Kyoto, Japan, pages 268–272.
Joachims, Thorsten. 2002. Optimizing search en-
gines using clickthrough data. In Proceed-
ings of the 8th Proceedings of the eighth ACM
SIGKDD international conference on Knowl-
edge discovery and data mining. Edmonton, Al-
berta, pages 133–142.
Karamanis, Nikiforos and Hisar Maruli Manu-
rung. 2002. Stochastic text structuring using
the principle of continuity. In Proceedings of
the 2nd International Natural Language Gener-
ation Conference (INLG’02). pages 81–88.
Keller, Frank, Subahshini Gunasekharan, Neil
Mayo, and Martin Corley. 2009. Timing accu-
racy of web experiments: A case study using the
WebExp software package. Behavior Research
Methods 41(1):1–12.
Knight, Kevin and Vasileios Hatzivassiloglou.
1995. Two-level, many-paths generation. In
Proceedings of the 33rd Annual Meeting of
the Association for Computational Linguistics
(ACL’95). Cambridge, Massachusetts, pages
252–260.
Korhonen, Y. Krymolowski, A. and E.J. Briscoe.
2006. A large subcategorization lexicon for nat-
ural language processing applications. In Pro-
ceedings of the 5th LREC. Genova, Italy.
Lavoie, Benoit and Owen Rambow. 1997. A fast
and portable realizer for text generation sys-
tems. In Proceedings of the 5th Conference on
Applied Natural Language Processing. Wash-
ington, D.C., pages 265–268.
Lin, Dekang. 1998. Automatic retrieval and clus-
tering of similar words. In Proceedings of
the 17th International Conference on Compu-
tational Linguistic. Montreal, Quebec, pages
768–774.
Liu, Hugo and Glorianna Davenport. 2004. Con-
ceptNet: a practical commonsense reasoning
toolkit. BT Technology Journal 22(4):211–226.
Liu, Hugo and Push Singh. 2002. Using com-
monsense reasoning to generate stories. In Pro-
ceedings of the 18th National Conference on Ar-
tificial Intelligence. Edmonton, Alberta, pages
957–958.
McIntyre, Neil and Mirella Lapata. 2009. Learn-
ing to tell tales: A data-driven approach to story
generation. In Proceedings of the Joint Confer-
ence of the 47th Annual Meeting of the ACL and
the 4th International Joint Conference on Natu-
ral Language Processing of the AFNLP. Singa-
pore, pages 217–225.
Meehan, James. 1977. An interactive program that
writes stories. In Proceedings of the 5th In-
ternational Joint Conference on Artificial Intel-
ligence. Cambridge, Massachusetts, pages 91–
98.
Mellish, Chris, Alisdair Knott, Jon Oberlander,
and Mick O’Donnell. 1998. Experiments using
stochastic search for text planning. In Proceed-
ings of the 9th International Conference on Nat-
ural Language Generation. New Brunswick,
New Jersey, pages 98–107.
Mitchell, Melanie. 1998. An Introduction to Ge-
netic Algorithms. MIT Press, Cambridge, Mas-
sachusetts.
Pizzi, David, Fred Charles, Jean-Luc Lugrin, and
Marc Cavazza. 2007. Interactive storytelling
with literary feelings. In Proceedings of the 2nd
International Conference on Affective Comput-
ing and Intelligent Interaction. Lisbon, Portu-
gal, pages 630–641.
</reference>
<page confidence="0.804916">
1571
</page>
<reference confidence="0.960006178571429">
Reiter, E and R Dale. 2000. Building Natural-
Language Generation Systems. Cambridge
University Press, Cambridge, UK.
Riedl, Mark O. and R. Michael Young. 2004. A
planning approach to story generation and his-
tory education. In Proceedings of the 3rd In-
ternational Conference on Narrative and Inter-
active Learning Environments. Edinburgh, UK,
pages 41–48.
Shim, Yunju and Minkoo Kim. 2002. Automatic
short story generator based on autonomous
agents. In Proceedings of the 5th Pacific Rim In-
ternational Workshop on Multi Agents. Tokyo,
pages 151–162.
Swartjes, I.M.T. and M. Theune. 2008. The vir-
tual storyteller: story generation by simulation.
In Proceedings of the 20th Belgian-Netherlands
Conference on Artificial Intelligence, BNAIC
2008. Enschede, the Netherlands, pages 257–
264.
Turner, Scott R. 1992. Ministrel: A Computer
Model of Creativity and Sotrytelling. University
of California, Los Angeles, California.
Wu, Zhibiao and Martha Palmer. 1994. Verb se-
mantics and lexical selection. In Proceedings
of the 32nd Annual Meeting of the Associa-
tion for Computational Linguistics. Las Cruces,
New Mexico, pages 133–138.
</reference>
<page confidence="0.993651">
1572
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.962164">
<title confidence="0.999701">Plot Induction and Evolutionary Search for Story Generation</title>
<author confidence="0.977613">McIntyre Lapata</author>
<affiliation confidence="0.999959">School of Informatics, University of Edinburgh</affiliation>
<address confidence="0.999422">10 Crichton Street, Edinburgh, EH8 9AB, UK</address>
<abstract confidence="0.999159833333333">In this paper we develop a story generator that leverages knowledge inherent in corpora without requiring extensive manual involvement. A key feature in our approach is the reliance on a story planner which we acquire automatically by recording events, their participants, and their precedence relationships in a training corpus. Contrary to previous work our system does not follow a generate-and-rank architecture. Instead, we employ evolutionary search techniques to explore the space of possible stories which we argue are well suited to the story generation task. Experiments on generating simple children’s stories show that our system outperforms previous data-driven approaches.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Hua Cheng</author>
<author>Chris Mellish</author>
</authors>
<title>Capturing the interaction between aggregation and text planning in two generation systems.</title>
<date>2000</date>
<booktitle>In Proceedings of the 1st International Conference on Natural Language Generation. Mitzpe</booktitle>
<pages>186--193</pages>
<location>Ramon,</location>
<contexts>
<context position="8428" citStr="Cheng and Mellish (2000)" startWordPosition="1313" endWordPosition="1316">reviously employed in natural language generation, especially in the context of document planning. Structuring a set of facts into a coherent text is effectively a search problem that may lead to combinatorial explosion for large domains. Mellish et al. (1998) (and subsequently Karamanis and Manurung 2002) advocate genetic algorithms as an alternative to exhaustively searching for the optimal ordering of descriptions of museum artefacts. Rather than requiring a global optimum to be found, the genetic algorithm selects an order (based on coherence) that is good enough for people to understand. Cheng and Mellish (2000) focus on the interaction of aggregation and text planning and use genetic algorithms to search for the best aggregated document that satisfies coherence constraints. The application of genetic algorithms to story generation is novel to our knowledge. Our work also departs from McIntyre and Lapata (2009) in two important ways. Firstly, our generator does not rely on a knowledge base of seemingly unrelated entities and relations. Rather, we employ 1563 a document planner to create and structure a plot for a story. The planner is built automatically from a training corpus and creates plots dynam</context>
</contexts>
<marker>Cheng, Mellish, 2000</marker>
<rawString>Cheng, Hua and Chris Mellish. 2000. Capturing the interaction between aggregation and text planning in two generation systems. In Proceedings of the 1st International Conference on Natural Language Generation. Mitzpe Ramon, Israel, pages 186–193.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Fellbaum</author>
</authors>
<title>WordNet: An Electronic Lexical Database (Language, Speech, and Communication).</title>
<date>1998</date>
<publisher>The MIT Press,</publisher>
<location>Cambridge, Massachusetts.</location>
<contexts>
<context position="13417" citStr="Fellbaum, 1998" startWordPosition="2144" endWordPosition="2145">nd this graph. Before inserting a new node, we check if it can be merged with an already existing one. Nodes are merged only if they have the same verb and similar arguments, with the focal entity (i.e., princess) appearing in the same argument slot. In our example, the nodes “prince marry princess in castle” and “prince marry princess in temple” can be merged as they contain the same verb and number of similar arguments. The nodes “princess have influence” and “princess have baby” cannot be merged as influence and baby are semantically unrelated. We compute argument similarity using WordNet (Fellbaum, 1998) and the measure proposed by Wu and Palmer (1994) which is based on path length. We merge nodes with related arguments only if their similarity exceeds a threshold (determined empirically). 3We use mutual information to identify event sequences strongly associated with the graph entity. 1564 The goblin holds the princess in a lair. The prince rescues the princess and marries her in a castle. The ceremony is beautiful. The princess has influence as the prince rules the country. goblin hold princess in lair prince rescue princess prince marry princess in castle princess have influence The dragon</context>
</contexts>
<marker>Fellbaum, 1998</marker>
<rawString>Fellbaum. 1998. WordNet: An Electronic Lexical Database (Language, Speech, and Communication). The MIT Press, Cambridge, Massachusetts.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Charles J Fillmore</author>
<author>Christopher R Johnson</author>
<author>Miriam R L Petruck</author>
</authors>
<title>Background to FrameNet.</title>
<date>2003</date>
<journal>International Journal of Lexicography</journal>
<pages>16--235</pages>
<contexts>
<context position="9920" citStr="Fillmore et al., 2003" startWordPosition="1553" endWordPosition="1556">our genetic algorithm explores the space of possible stories once. 3 Plot Generation Following previous work (e.g., Shim and Kim 2002; McIntyre and Lapata 2009) we assume that the user supplies a sentence (e.g., the princess loves the prince) from which the system creates a story. Each entity in this sentence (e.g., princess, prince) is associated with its own narrative schema, a set of key events and actors cooccurring with it in the training corpus. Our narrative schemas differ slightly from Chambers and Jurafsky (2009). They acquire schematic representations of situations akin to FrameNet (Fillmore et al., 2003): schemas consists of semantically similar predicates and the entities evoked by them. In our setting, every entity has its own schema, and predicates associated with it are ordered. Plots are generated by merging the entity-specific narrative schemas which subsequently serve as the input to the genetic algorithm. In the following we describe how the narrative schemas are extracted and plots merged, and then discuss our evolutionary search procedure. Entity-based Schema Extraction Before we can generate a plot for a story we must have an idea of the actions associated with the entities in the </context>
</contexts>
<marker>Fillmore, Johnson, Petruck, 2003</marker>
<rawString>Fillmore, Charles J., Christopher R. Johnson, and Miriam R. L. Petruck. 2003. Background to FrameNet. International Journal of Lexicography 16:235–250.</rawString>
</citation>
<citation valid="true">
<authors>
<author>David E Goldberg</author>
</authors>
<title>Genetic Algorithms in Search, Optimization and Machine Learning.</title>
<date>1989</date>
<publisher>Addison-Wesley Longman Publishing Co., Inc.,</publisher>
<location>Boston, Massachusetts.</location>
<contexts>
<context position="23278" citStr="Goldberg 1989" startWordPosition="3758" endWordPosition="3759"> entire sentence (see Figure 4d). If it is a subclause, then it is replaced with a randomly generated clause, headed by a verb that has been seen in the corpus to co-occur with the matrix verb (Figure 4e). The sentence planner selects and fills template trees for generating random clauses. Mutation may also change the order of any two nodes in the graph in the hope that this will increase the story’s coherence or create some element of surprise (see Figure 4c). Selection To choose the plots for the next generation, we used fitness proportional selection (also know as roulette-wheel selection, Goldberg 1989) which chooses candidates randomly but with a bias towards those with a larger proportion of the population’s combined fitness. We do not want to always select the fittest candidates as there may be valid partial solutions held within less fit members of the population. However, we did employ some elitism by allowing the top 1% of solutions to be copied straight from one generation to the next. Note that our candidates may also represent invalid solutions. For instance, through crossover it is possible to create a plot in which all or some nodes are identical. If any such candidates are identi</context>
</contexts>
<marker>Goldberg, 1989</marker>
<rawString>Goldberg, David E. 1989. Genetic Algorithms in Search, Optimization and Machine Learning. Addison-Wesley Longman Publishing Co., Inc., Boston, Massachusetts.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ralph Grishman</author>
<author>Catherine Macleod</author>
<author>Adam Meyers</author>
</authors>
<title>COMLEX syntax: Building a computational lexicon.</title>
<date>1994</date>
<booktitle>In Proceedings of the 15th COLING. Kyoto, Japan,</booktitle>
<pages>268--272</pages>
<contexts>
<context position="17027" citStr="Grishman et al. (1994)" startWordPosition="2739" endWordPosition="2742">pairs of nodes within the same graph by looking at intrasentential verb-verb co-occurrences in the training corpus. For example, the nodes (prince have problem, prince keep secret) could become the sentence the prince has a problem keeping a secret. We leave it up to the sentence planner to decide how the two actions should be combined.4 The sentence planner will also insert adverbs and adjectives, using co-occurrence likelihoods acquired from the training corpus. It is essentially a phrase structure grammar compiled from the lexical resources made available by Korhonen and Briscoe (2006) and Grishman et al. (1994). The grammar rules act as templates for combining clauses and filling argument slots. 4We only turn an action into a subclause if its subject entity is same as that of the previous action. 1565 prince slay dragon princess love prince � goblin � � lair � hold princess in dragon cave prince slay dragon prince rescue princess prince ask king’s permission prince rescue princess princess love prince ~ castle prince marry princess in temple prince rule country Figure 2: Narrative schema for the entity prince. 4 Genetic Algorithms The example shown in Figure 3 is a simplified version of a plot graph</context>
</contexts>
<marker>Grishman, Macleod, Meyers, 1994</marker>
<rawString>Grishman, Ralph, Catherine Macleod, and Adam Meyers. 1994. COMLEX syntax: Building a computational lexicon. In Proceedings of the 15th COLING. Kyoto, Japan, pages 268–272.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Thorsten Joachims</author>
</authors>
<title>Optimizing search engines using clickthrough data.</title>
<date>2002</date>
<booktitle>In Proceedings of the 8th Proceedings of the eighth ACM SIGKDD international conference on Knowledge discovery and data mining.</booktitle>
<pages>133--142</pages>
<location>Edmonton, Alberta,</location>
<marker>Joachims, 2002</marker>
<rawString>Joachims, Thorsten. 2002. Optimizing search engines using clickthrough data. In Proceedings of the 8th Proceedings of the eighth ACM SIGKDD international conference on Knowledge discovery and data mining. Edmonton, Alberta, pages 133–142.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Nikiforos Karamanis</author>
<author>Hisar Maruli Manurung</author>
</authors>
<title>Stochastic text structuring using the principle of continuity.</title>
<date>2002</date>
<booktitle>In Proceedings of the 2nd International Natural Language Generation Conference (INLG’02).</booktitle>
<pages>81--88</pages>
<contexts>
<context position="8111" citStr="Karamanis and Manurung 2002" startWordPosition="1262" endWordPosition="1265">ated from the knowledge base. Unlikely stories are pruned using beam search. In addition, stories are reranked using two scoring functions based on coherence and interest. These are learnt from training data, i.e., stories labeled with numeric values for interest and coherence. Evolutionary search techniques have been previously employed in natural language generation, especially in the context of document planning. Structuring a set of facts into a coherent text is effectively a search problem that may lead to combinatorial explosion for large domains. Mellish et al. (1998) (and subsequently Karamanis and Manurung 2002) advocate genetic algorithms as an alternative to exhaustively searching for the optimal ordering of descriptions of museum artefacts. Rather than requiring a global optimum to be found, the genetic algorithm selects an order (based on coherence) that is good enough for people to understand. Cheng and Mellish (2000) focus on the interaction of aggregation and text planning and use genetic algorithms to search for the best aggregated document that satisfies coherence constraints. The application of genetic algorithms to story generation is novel to our knowledge. Our work also departs from McIn</context>
<context position="28035" citStr="Karamanis and Manurung 2002" startWordPosition="4540" endWordPosition="4544"> latitude is available when selecting parameters for the GA. These involve the population size, crossover, and mutation rates. To evaluate which setting was best, we asked two human evaluators to rate (on a 1–5 scale) stories produced with a population size ranging from 1,000 to 10,000, crossover rate of 0.1 to 0.6 and mutation rate of 0.001 to 0.1. For each run of the system a limit was set to 5,000 generations. The human ratings revealed that the best stories were produced for a population size of 10,000, a crossover rate of 0.1% and a mutation rate of 0.1%. Compared to previous work (e.g., Karamanis and Manurung 2002) our crossover rate may seem low and the mutation rate high. However, it makes intuitively sense, as high crossover may lead to incoherence by disrupting canonical action sequences found in the plots. On the other hand, a higher mutation will raise the likelihood of a lexical item being swapped for another and may improve overall coherence and interest. The fitness function was trained on 200 documents from the fairy tales collection using Joachims’s (2002) SVMlight package and entity transition sequences of length 2. The realizer was interfaced with a trigram language model trained on the Bri</context>
</contexts>
<marker>Karamanis, Manurung, 2002</marker>
<rawString>Karamanis, Nikiforos and Hisar Maruli Manurung. 2002. Stochastic text structuring using the principle of continuity. In Proceedings of the 2nd International Natural Language Generation Conference (INLG’02). pages 81–88.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Frank Keller</author>
<author>Subahshini Gunasekharan</author>
<author>Neil Mayo</author>
<author>Martin Corley</author>
</authors>
<title>Timing accuracy of web experiments: A case study using the WebExp software package.</title>
<date>2009</date>
<journal>Behavior Research Methods</journal>
<volume>41</volume>
<issue>1</issue>
<contexts>
<context position="30821" citStr="Keller et al., 2009" startWordPosition="4997" endWordPosition="5000">stories had the same length, namely five sentences. Human judges were presented with one of the three sets and asked to rate the stories on a scale of 1 to 5 for fluency (was the sentence grammatical?), coherence (does the story make sense overall?) and interest (how interesting is the story?). The stories were presented in random order and participants were told that all of them were generated by a computer program. They were instructed to rate more favorably interesting stories, stories that were comprehensible and overall grammatical. The study was conducted over the Internet using WebExp (Keller et al., 2009) and was completed by 56 volunteers, all self reported native English speakers. 7 Results Our results are summarized in Table 1 which lists the average human ratings for the four systems. We performed an Analysis of Variance (ANOVA) to examine the effect of system type on the story generation task. Statistical tests were carried out on the mean of the ratings shown in Table 1 for fluency, coherence, and interest. In terms of interest, the GA-based system is sigSystem Fluency Coherence Interest GA-based 3.09 2.48 2.36 Plot-based 3.03 2.36 2.14* Rank-based 1.96** 1.65* 1.85* Random 3.10 2.23* 2.</context>
</contexts>
<marker>Keller, Gunasekharan, Mayo, Corley, 2009</marker>
<rawString>Keller, Frank, Subahshini Gunasekharan, Neil Mayo, and Martin Corley. 2009. Timing accuracy of web experiments: A case study using the WebExp software package. Behavior Research Methods 41(1):1–12.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kevin Knight</author>
<author>Vasileios Hatzivassiloglou</author>
</authors>
<title>Two-level, many-paths generation.</title>
<date>1995</date>
<booktitle>In Proceedings of the 33rd Annual Meeting of the Association for Computational Linguistics (ACL’95).</booktitle>
<pages>252--260</pages>
<location>Cambridge, Massachusetts,</location>
<contexts>
<context position="26172" citStr="Knight and Hatzivassiloglou, 1995" startWordPosition="4227" endWordPosition="4230">undant as interesting stories emerge naturally through the operations of crossover and mutation. 5 Surface Realization Once the final generation of the population has been reached, the fittest story is selected for surface realization. The realizer takes each sentence in the story and reformulates it into input compatible with the RealPro (Lavoie and Rambow, 1997) text generation engine. Realpro creates several variants of the same story differing in the choice of determiners, number (singular or plural), and prepositions. A language model is then used to select the most probable realization (Knight and Hatzivassiloglou, 1995). Ideally, the realizer should also select an appropriate tense for the sentence. However, we make the simplifying assumption that all sentences are in the present tense. 6 Experimental Setup In this section we present our experimental set-up for assessing the performance of our story generator. We give details on our training corpus, system, parameters (such as the population size for the GA search), the baselines used for comparison, and explain how our system output was evaluated. Corpus The generator was trained on the same corpus used in McIntyre and Lapata (2009), 437 stories from the An</context>
</contexts>
<marker>Knight, Hatzivassiloglou, 1995</marker>
<rawString>Knight, Kevin and Vasileios Hatzivassiloglou. 1995. Two-level, many-paths generation. In Proceedings of the 33rd Annual Meeting of the Association for Computational Linguistics (ACL’95). Cambridge, Massachusetts, pages 252–260.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Y Krymolowski Korhonen</author>
<author>A</author>
<author>E J Briscoe</author>
</authors>
<title>A large subcategorization lexicon for natural language processing applications.</title>
<date>2006</date>
<booktitle>In Proceedings of the 5th LREC.</booktitle>
<location>Genova, Italy.</location>
<marker>Korhonen, A, Briscoe, 2006</marker>
<rawString>Korhonen, Y. Krymolowski, A. and E.J. Briscoe. 2006. A large subcategorization lexicon for natural language processing applications. In Proceedings of the 5th LREC. Genova, Italy.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Benoit Lavoie</author>
<author>Owen Rambow</author>
</authors>
<title>A fast and portable realizer for text generation systems.</title>
<date>1997</date>
<booktitle>In Proceedings of the 5th Conference on Applied Natural Language Processing.</booktitle>
<pages>265--268</pages>
<location>Washington, D.C.,</location>
<contexts>
<context position="7365" citStr="Lavoie and Rambow, 1997" startWordPosition="1144" endWordPosition="1147">ntent of a story is determined by consulting a data-driven knowledge base that records the entities (i.e., nouns) appearing in a corpus and the actions they perform. These are encoded as dependency relations (e.g., subj-verb, verb-obj). In order to promote between-sentence coherence the generator also make use of an action graph that contains action-role pairs and the likelihood of transitioning from one to another. The sentence planner aggregates together entities and their actions into a sentence using phrase structure rules. Finally, surface realization is performed by interfacing RealPro (Lavoie and Rambow, 1997) with a language model. The system searches for the best story overall as well as the best sentences that can be generated from the knowledge base. Unlikely stories are pruned using beam search. In addition, stories are reranked using two scoring functions based on coherence and interest. These are learnt from training data, i.e., stories labeled with numeric values for interest and coherence. Evolutionary search techniques have been previously employed in natural language generation, especially in the context of document planning. Structuring a set of facts into a coherent text is effectively</context>
<context position="25904" citStr="Lavoie and Rambow, 1997" startWordPosition="4187" endWordPosition="4190">of subjects/objects, the number of letters, word familiarity, imagery, and so on. An interest-based scoring function made sense in our previous setup as a means of selecting unusual stories. However, in the context of genetic search such a function seems redundant as interesting stories emerge naturally through the operations of crossover and mutation. 5 Surface Realization Once the final generation of the population has been reached, the fittest story is selected for surface realization. The realizer takes each sentence in the story and reformulates it into input compatible with the RealPro (Lavoie and Rambow, 1997) text generation engine. Realpro creates several variants of the same story differing in the choice of determiners, number (singular or plural), and prepositions. A language model is then used to select the most probable realization (Knight and Hatzivassiloglou, 1995). Ideally, the realizer should also select an appropriate tense for the sentence. However, we make the simplifying assumption that all sentences are in the present tense. 6 Experimental Setup In this section we present our experimental set-up for assessing the performance of our story generator. We give details on our training cor</context>
</contexts>
<marker>Lavoie, Rambow, 1997</marker>
<rawString>Lavoie, Benoit and Owen Rambow. 1997. A fast and portable realizer for text generation systems. In Proceedings of the 5th Conference on Applied Natural Language Processing. Washington, D.C., pages 265–268.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Dekang Lin</author>
</authors>
<title>Automatic retrieval and clustering of similar words.</title>
<date>1998</date>
<booktitle>In Proceedings of the 17th International Conference on Computational Linguistic.</booktitle>
<pages>768--774</pages>
<location>Montreal, Quebec,</location>
<contexts>
<context position="12490" citStr="Lin (1998)" startWordPosition="1982" endWordPosition="1983">nt transitions from node Vi to node Vj. As an example of our schema construction process, consider a very small corpus consisting of the two documents shown in Figure 1. The schema for princess after processing the first document is given on the left hand side. Each node in this graph corresponds to an action attested with princess (we also record who performs it and where or how). Nodes are themselves dependency trees (see Figure 4a), but are linearized in the figure for the sake of brevity. Edges in the graph indicate ordering and are weighted using the mutual information metric proposed in Lin (1998) (the weights are omitted from the example).3 The first sentence in the text gives rise to the first node in the graph, the second sentence to the second node, and so on. Note that the third sentence is not present in the graph as it is not about the princess. When processing the second document, we simply expand this graph. Before inserting a new node, we check if it can be merged with an already existing one. Nodes are merged only if they have the same verb and similar arguments, with the focal entity (i.e., princess) appearing in the same argument slot. In our example, the nodes “prince mar</context>
</contexts>
<marker>Lin, 1998</marker>
<rawString>Lin, Dekang. 1998. Automatic retrieval and clustering of similar words. In Proceedings of the 17th International Conference on Computational Linguistic. Montreal, Quebec, pages 768–774.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Hugo Liu</author>
<author>Glorianna Davenport</author>
</authors>
<title>ConceptNet: a practical commonsense reasoning toolkit.</title>
<date>2004</date>
<journal>BT Technology Journal</journal>
<volume>22</volume>
<issue>4</issue>
<contexts>
<context position="33366" citStr="Liu and Davenport, 2004" startWordPosition="5419" endWordPosition="5422">is worth noting that the Plot-based system is relatively simple, however the explicit use of a story plot, seems to make up for the lack of sophisticated search and more elaborate linguistic information. Example stories generated by the four systems are shown in Table 2 for the input sentences The emperor rules the kingdom and The child watches the bird. Possible extensions and improvements to the current work are many and varied. Firstly, we could improve the quality of our plot graphs by taking temporal knowledge into account and making use of knowledge bases such as WordNet and ConceptNet (Liu and Davenport, 2004), a freely available commonsense knowledge base. Secondly, our fitness function optimizes one ob1569 The emperor rules the kingdom. The kingdom The child watches the bird. The bird weeps holds on to the emperor. The emperor rides for the child. The child begs the bird to lisout of the kingdom. The kingdom speaks out ten.The bird dresses up the child. The child against the emperor. The emperor lies. grows up. The emperor rules the kingdom. The emperor The child watches the bird. The bird comes takes over. The emperor goes on to feel for the oughly. The bird sees the child. The child sits Plot d</context>
</contexts>
<marker>Liu, Davenport, 2004</marker>
<rawString>Liu, Hugo and Glorianna Davenport. 2004. ConceptNet: a practical commonsense reasoning toolkit. BT Technology Journal 22(4):211–226.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Hugo Liu</author>
<author>Push Singh</author>
</authors>
<title>Using commonsense reasoning to generate stories.</title>
<date>2002</date>
<booktitle>In Proceedings of the 18th National Conference on Artificial Intelligence.</booktitle>
<pages>957--958</pages>
<location>Edmonton, Alberta,</location>
<contexts>
<context position="1444" citStr="Liu and Singh, 2002" startWordPosition="215" endWordPosition="218">rating simple children’s stories show that our system outperforms previous data-driven approaches. 1 Introduction Computer story generation has met with fascination since the early days of artificial intelligence. Indeed, over the years, several generators have been developed capable of creating stories that resemble human output. To name only a few, TALE-SPIN (Meehan, 1977) generates stories through problem solving, MINSTREL (Turner, 1992) relies on an episodic memory scheme, essentially a repository of previous hand-coded stories, to solve the problems in the current story, and MAKEBELIEVE (Liu and Singh, 2002) uses commonsense knowledge to generate short stories from an initial seed story (supplied by the user). A large body of more recent work views story generation as a form of agent-based planning (Swartjes and Theune, 2008; Pizzi et al., 2007). The agents act as characters with a list of goals. They form plans of action and try to fulfill them. Interesting stories emerge as plans interact and cause failures and possible replanning. The broader appeal of computational story generation lies in its application potential. Examples include the entertainment industry and the development of tools that</context>
</contexts>
<marker>Liu, Singh, 2002</marker>
<rawString>Liu, Hugo and Push Singh. 2002. Using commonsense reasoning to generate stories. In Proceedings of the 18th National Conference on Artificial Intelligence. Edmonton, Alberta, pages 957–958.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Neil McIntyre</author>
<author>Mirella Lapata</author>
</authors>
<title>Learning to tell tales: A data-driven approach to story generation.</title>
<date>2009</date>
<booktitle>In Proceedings of the Joint Conference of the 47th Annual Meeting of the ACL and the 4th International Joint Conference on Natural Language Processing of the AFNLP. Singapore,</booktitle>
<pages>217--225</pages>
<contexts>
<context position="4310" citStr="McIntyre and Lapata (2009)" startWordPosition="667" endWordPosition="670">police, agent, authority, government}. Their approach relies on the intuition that in a coherent text events that are about the same participants are 1562 Proceedings of the 48th Annual Meeting of the Association for Computational Linguistics, pages 1562–1572, Uppsala, Sweden, 11-16 July 2010. c�2010 Association for Computational Linguistics likely to be part of the same story or narrative. Their model extracts narrative chains, essentially events that share argument slots and merges them into schemas. The latter could be used to construct or enrich the knowledge base of a story generator. In McIntyre and Lapata (2009) we presented a story generator that leverages knowledge inherent in corpora without requiring extensive manual involvement. The generator operates over predicateargument and predicate-predicate co-occurrence tuples gathered from training data. These are used to produce a large set of candidate stories which are subsequently ranked based on their interestingness and coherence. The approach is unusual in that it does not involve an explicit story planning component. Stories are created stochastically by selecting entities and the events they are most frequently attested with. In this work we de</context>
<context position="5923" citStr="McIntyre and Lapata (2009)" startWordPosition="915" endWordPosition="918">le stories. Contrary to our previous work (McIntyre and Lapata, 2009), we do not follow a generate-and-rank architecture. Instead, we search the space of possible stories using Genetic Algorithms (GAs) which we argue are advantageous in the story generation setting, as they can search large fitness landscapes while greatly reducing the risk of getting stuck in local optima. By virtue of exploring the search space more broadly, we are able to generate creative stories without an explicit interest scoring module. In the remainder of this paper we give a brief overview of the system described in McIntyre and Lapata (2009) and discuss previous applications of GAs in natural language generation (Section 2). Next, we detail our approach, specifically how plots are created and used in conjunction with genetic search (Sections 3 and 4). Finally, we present our experimental results (Sections 6 and 7) and conclude the paper with discussion of future work. 2 Related Work Our work builds on and extends the story generator developed in McIntyre and Lapata (2009). The system creates simple children’s stories in an interactive context: the user supplies the topic of the story and its desired length (number of sentences). </context>
<context position="8733" citStr="McIntyre and Lapata (2009)" startWordPosition="1360" endWordPosition="1363">002) advocate genetic algorithms as an alternative to exhaustively searching for the optimal ordering of descriptions of museum artefacts. Rather than requiring a global optimum to be found, the genetic algorithm selects an order (based on coherence) that is good enough for people to understand. Cheng and Mellish (2000) focus on the interaction of aggregation and text planning and use genetic algorithms to search for the best aggregated document that satisfies coherence constraints. The application of genetic algorithms to story generation is novel to our knowledge. Our work also departs from McIntyre and Lapata (2009) in two important ways. Firstly, our generator does not rely on a knowledge base of seemingly unrelated entities and relations. Rather, we employ 1563 a document planner to create and structure a plot for a story. The planner is built automatically from a training corpus and creates plots dynamically depending on the protagonists of the story. Secondly, our search procedure is simpler and more global; instead of searching for the best story twice (i.e., by first finding the n-best stories and then subsequently reranking them based on coherence and interest), our genetic algorithm explores the </context>
<context position="19988" citStr="McIntyre and Lapata (2009)" startWordPosition="3214" endWordPosition="3217">he princess loves the prince. obtained is considered optimal. This process leads to the evolution of a population in which the individuals are more and more suited to their environment, just as natural adaptation. We describe below how we developed a genetic algorithm for our story generation problem. Initial Population Rather than start with a random population, we seed the initial population with story plots generated from our plot graph. For an input sentence, we generate all possible plots. The latter are then randomly sampled until a population of the desired size is created. Contrary to McIntyre and Lapata (2009), we initialize the search with complete stories, rather than generate one sentence at a time. The genetic algorithm will thus avoid the pitfall of selecting early on a solution that will later prove detrimental. Crossover Each plot is represented as an ordered graph of dependency trees (corresponding to sentences). We have decided to use crossover of a single point between two selected parents. The children will therefore contain sentences up to the crossover point of the first parent and sentences after that point of the second. Figure 4a shows two parents (prince rescue princess, prince mar</context>
<context position="25119" citStr="McIntyre and Lapata (2009)" startWordPosition="4062" endWordPosition="4066">nd Lapata (2007). An entity grid is a two-dimensional array in which columns correspond to entities and rows to sentences. Each cell indicates whether an entity appears in a given sentence or not and whether it is a subject, object or neither. For training, this representation is converted into a feature vector of entity transition sequences and a model is learnt from examples of coherent and incoherent stories. The latter can be easily created by permuting the sentences of coherent stories (assuming that the original story is more coherent than its permutations). In addition to coherence, in McIntyre and Lapata (2009) we used a scoring function based on interest which we approximated with lexical and syntactic features such as the number of noun/verb tokens/types, the number of subjects/objects, the number of letters, word familiarity, imagery, and so on. An interest-based scoring function made sense in our previous setup as a means of selecting unusual stories. However, in the context of genetic search such a function seems redundant as interesting stories emerge naturally through the operations of crossover and mutation. 5 Surface Realization Once the final generation of the population has been reached, </context>
<context position="26747" citStr="McIntyre and Lapata (2009)" startWordPosition="4322" endWordPosition="4325">ble realization (Knight and Hatzivassiloglou, 1995). Ideally, the realizer should also select an appropriate tense for the sentence. However, we make the simplifying assumption that all sentences are in the present tense. 6 Experimental Setup In this section we present our experimental set-up for assessing the performance of our story generator. We give details on our training corpus, system, parameters (such as the population size for the GA search), the baselines used for comparison, and explain how our system output was evaluated. Corpus The generator was trained on the same corpus used in McIntyre and Lapata (2009), 437 stories from the Andrew Lang fairy tales collection.5 The average story length is 125.18 sentences. The corpus contains 15,789 word tokens. Following McIntyre and Lapata, we discarded tokens that did not appear in the Children’s Printed Word Database6, a database of printed word frequencies as read by children aged between five and nine. From this corpus we extracted narrative schemas for 667 entities in total. We disregarded any graph that contained less than 10 nodes as too small. The graphs had on average 61.04 nodes, with an average clustering rate7 of 0.027 which indicates that they</context>
<context position="29091" citStr="McIntyre and Lapata (2009)" startWordPosition="4704" endWordPosition="4708">lection using Joachims’s (2002) SVMlight package and entity transition sequences of length 2. The realizer was interfaced with a trigram language model trained on the British National Corpus with the SRI toolkit. 5Available from http://homepages.inf.ed.ac.uk/ s0233364/McIntyreLapata09/. 6http://www.essex.ac.uk/psychology/cpwd/ 7Clustering rate (or transitivity) is the number of triangles in the graph — sets of three vertices each of which is connected to each of the others. 1568 Evaluation We compared the stories generated by the GA against those produced by the rank-based system described in McIntyre and Lapata (2009) and a system that creates stories from the plot graph, without any stochastic search. Since plot graphs are weighted, we can simply select the graph with the highest weight. After expanding all lexical variables, the chosen plot graph will give rise to different stories (e.g., castle or temple in the example above). We select the story ranked highest according to our coherence function. In addition, we included a baseline which randomly selects sentences from the training corpus provided they contain either of the story protagonists (i.e., entities in the input sentence). Sentence length was </context>
<context position="35182" citStr="McIntyre and Lapata (2009)" startWordPosition="5746" endWordPosition="5749">to wiping the tears ness. on the towel. Random Exclaimed the emperor when Petru had put They cried, “what a beautiful child!” “No, his question. In the meantime, mind you take that I cannot do, my child” he said at last. good care of our kingdom. At first the em- “What is the matter, dear child?” “You wicked peror felt rather distressed. The dinner of an child,” cried the Witch. Well, I will watch till emperor! Thus they arrived at the court of the the bird comes. emperor. Table 2: Stories generated by a system that uses plots and genetic search (PlotGA), a system that uses only plots (Plot), McIntyre and Lapata (2009)’s rank-based system (Rank) and a system that randomly pastes together sentences from the training corpus (Random). jective, namely coherence. In the future we plan to explore multiple objectives, such as whether the story is verbose, readable (using existing readability metrics), has two many or two few protagonists, and so on. Thirdly, our stories would benefit from some explicit modeling of discourse structure. Although the plot graph captures the progression of the actions in a story, we would also like to know where in the story these actions are likely to occur— some tend to appear in th</context>
</contexts>
<marker>McIntyre, Lapata, 2009</marker>
<rawString>McIntyre, Neil and Mirella Lapata. 2009. Learning to tell tales: A data-driven approach to story generation. In Proceedings of the Joint Conference of the 47th Annual Meeting of the ACL and the 4th International Joint Conference on Natural Language Processing of the AFNLP. Singapore, pages 217–225.</rawString>
</citation>
<citation valid="true">
<authors>
<author>James Meehan</author>
</authors>
<title>An interactive program that writes stories.</title>
<date>1977</date>
<booktitle>In Proceedings of the 5th International Joint Conference on Artificial Intelligence.</booktitle>
<pages>91--98</pages>
<location>Cambridge, Massachusetts,</location>
<contexts>
<context position="1201" citStr="Meehan, 1977" startWordPosition="179" endWordPosition="180">ork our system does not follow a generate-and-rank architecture. Instead, we employ evolutionary search techniques to explore the space of possible stories which we argue are well suited to the story generation task. Experiments on generating simple children’s stories show that our system outperforms previous data-driven approaches. 1 Introduction Computer story generation has met with fascination since the early days of artificial intelligence. Indeed, over the years, several generators have been developed capable of creating stories that resemble human output. To name only a few, TALE-SPIN (Meehan, 1977) generates stories through problem solving, MINSTREL (Turner, 1992) relies on an episodic memory scheme, essentially a repository of previous hand-coded stories, to solve the problems in the current story, and MAKEBELIEVE (Liu and Singh, 2002) uses commonsense knowledge to generate short stories from an initial seed story (supplied by the user). A large body of more recent work views story generation as a form of agent-based planning (Swartjes and Theune, 2008; Pizzi et al., 2007). The agents act as characters with a list of goals. They form plans of action and try to fulfill them. Interesting</context>
</contexts>
<marker>Meehan, 1977</marker>
<rawString>Meehan, James. 1977. An interactive program that writes stories. In Proceedings of the 5th International Joint Conference on Artificial Intelligence. Cambridge, Massachusetts, pages 91– 98.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Chris Mellish</author>
<author>Alisdair Knott</author>
<author>Jon Oberlander</author>
<author>Mick O’Donnell</author>
</authors>
<title>Experiments using stochastic search for text planning.</title>
<date>1998</date>
<booktitle>In Proceedings of the 9th International Conference on Natural Language Generation.</booktitle>
<pages>98--107</pages>
<location>New Brunswick, New Jersey,</location>
<marker>Mellish, Knott, Oberlander, O’Donnell, 1998</marker>
<rawString>Mellish, Chris, Alisdair Knott, Jon Oberlander, and Mick O’Donnell. 1998. Experiments using stochastic search for text planning. In Proceedings of the 9th International Conference on Natural Language Generation. New Brunswick, New Jersey, pages 98–107.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Melanie Mitchell</author>
</authors>
<title>An Introduction to Genetic Algorithms.</title>
<date>1998</date>
<publisher>MIT Press,</publisher>
<location>Cambridge, Massachusetts.</location>
<contexts>
<context position="18438" citStr="Mitchell, 1998" startWordPosition="2971" endWordPosition="2972">, that must satisfy several constraints: the story should be of a certain length, overall coherent, creative, display some form of event progression, and generally make sense. We argue that evolutionary search is appealing here, as it can find global optimal solutions in a more efficient way than traditional optimization methods. In this study we employ genetic algorithms (GAs) a well-known search technique for finding approximate (or exact) solutions to optimization problems. The basic idea behind GAs is based on “natural selection” and the Darwinian principle of the survival of the fittest (Mitchell, 1998). An initial population is randomly created containing a predefined number of individuals (or solutions), each represented by a genetic string (e.g., a population of chromosomes). Each individual is evaluated according to an objective function (also called a fitness function). A number of individuals are then chosen as parents from the population according to their fitness, and undergo crossover (also called recombination) and mutation in order to develop the new population. Offspring with better fitness are then inserted into the population, replacing the inferior individuals in the previous </context>
</contexts>
<marker>Mitchell, 1998</marker>
<rawString>Mitchell, Melanie. 1998. An Introduction to Genetic Algorithms. MIT Press, Cambridge, Massachusetts.</rawString>
</citation>
<citation valid="true">
<authors>
<author>David Pizzi</author>
<author>Fred Charles</author>
<author>Jean-Luc Lugrin</author>
<author>Marc Cavazza</author>
</authors>
<title>Interactive storytelling with literary feelings.</title>
<date>2007</date>
<booktitle>In Proceedings of the 2nd International Conference on Affective Computing and Intelligent Interaction.</booktitle>
<pages>630--641</pages>
<location>Lisbon, Portugal,</location>
<contexts>
<context position="1686" citStr="Pizzi et al., 2007" startWordPosition="256" endWordPosition="259">al generators have been developed capable of creating stories that resemble human output. To name only a few, TALE-SPIN (Meehan, 1977) generates stories through problem solving, MINSTREL (Turner, 1992) relies on an episodic memory scheme, essentially a repository of previous hand-coded stories, to solve the problems in the current story, and MAKEBELIEVE (Liu and Singh, 2002) uses commonsense knowledge to generate short stories from an initial seed story (supplied by the user). A large body of more recent work views story generation as a form of agent-based planning (Swartjes and Theune, 2008; Pizzi et al., 2007). The agents act as characters with a list of goals. They form plans of action and try to fulfill them. Interesting stories emerge as plans interact and cause failures and possible replanning. The broader appeal of computational story generation lies in its application potential. Examples include the entertainment industry and the development of tools that produce large numbers of plots automatically that might provide inspiration to professional screen writers (Agudo et al., 2004); rendering video games more interesting by allowing the plot to adapt dynamically to the players’ actions (Barros</context>
</contexts>
<marker>Pizzi, Charles, Lugrin, Cavazza, 2007</marker>
<rawString>Pizzi, David, Fred Charles, Jean-Luc Lugrin, and Marc Cavazza. 2007. Interactive storytelling with literary feelings. In Proceedings of the 2nd International Conference on Affective Computing and Intelligent Interaction. Lisbon, Portugal, pages 630–641.</rawString>
</citation>
<citation valid="true">
<authors>
<author>E Reiter</author>
<author>R Dale</author>
</authors>
<title>Building NaturalLanguage Generation Systems.</title>
<date>2000</date>
<publisher>Cambridge University Press,</publisher>
<location>Cambridge, UK.</location>
<contexts>
<context position="6657" citStr="Reiter and Dale, 2000" startWordPosition="1032" endWordPosition="1035">ch, specifically how plots are created and used in conjunction with genetic search (Sections 3 and 4). Finally, we present our experimental results (Sections 6 and 7) and conclude the paper with discussion of future work. 2 Related Work Our work builds on and extends the story generator developed in McIntyre and Lapata (2009). The system creates simple children’s stories in an interactive context: the user supplies the topic of the story and its desired length (number of sentences). The generator creates a story following a pipeline architecture typical of natural language generation systems (Reiter and Dale, 2000) consisting of content selection, sentence planning, and surface realization. The content of a story is determined by consulting a data-driven knowledge base that records the entities (i.e., nouns) appearing in a corpus and the actions they perform. These are encoded as dependency relations (e.g., subj-verb, verb-obj). In order to promote between-sentence coherence the generator also make use of an action graph that contains action-role pairs and the likelihood of transitioning from one to another. The sentence planner aggregates together entities and their actions into a sentence using phrase</context>
</contexts>
<marker>Reiter, Dale, 2000</marker>
<rawString>Reiter, E and R Dale. 2000. Building NaturalLanguage Generation Systems. Cambridge University Press, Cambridge, UK.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Mark O Riedl</author>
<author>R Michael Young</author>
</authors>
<title>A planning approach to story generation and history education.</title>
<date>2004</date>
<booktitle>In Proceedings of the 3rd International Conference on Narrative and Interactive Learning Environments.</booktitle>
<pages>41--48</pages>
<location>Edinburgh, UK,</location>
<contexts>
<context position="2403" citStr="Riedl and Young, 2004" startWordPosition="367" endWordPosition="370">ll them. Interesting stories emerge as plans interact and cause failures and possible replanning. The broader appeal of computational story generation lies in its application potential. Examples include the entertainment industry and the development of tools that produce large numbers of plots automatically that might provide inspiration to professional screen writers (Agudo et al., 2004); rendering video games more interesting by allowing the plot to adapt dynamically to the players’ actions (Barros and Musse, 2007); and assisting teachers to create or personalize stories for their students (Riedl and Young, 2004). A major stumbling block for the widespread use of computational story generators is their reliance on expensive, manually created resources. A typical story generator will make use of a knowledge base for providing detailed domain-specific information about the characters and objects involved in the story and their relations. It will also have a story planner that specifies how these characters interact, what their goals are and how their actions result in different story plots. Finally, a sentence planner (coupled with a surface realizer) will render an abstract story specification into nat</context>
</contexts>
<marker>Riedl, Young, 2004</marker>
<rawString>Riedl, Mark O. and R. Michael Young. 2004. A planning approach to story generation and history education. In Proceedings of the 3rd International Conference on Narrative and Interactive Learning Environments. Edinburgh, UK, pages 41–48.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Yunju Shim</author>
<author>Minkoo Kim</author>
</authors>
<title>Automatic short story generator based on autonomous agents.</title>
<date>2002</date>
<booktitle>In Proceedings of the 5th Pacific Rim International Workshop on Multi Agents.</booktitle>
<pages>151--162</pages>
<location>Tokyo,</location>
<contexts>
<context position="9431" citStr="Shim and Kim 2002" startWordPosition="1473" endWordPosition="1476">of seemingly unrelated entities and relations. Rather, we employ 1563 a document planner to create and structure a plot for a story. The planner is built automatically from a training corpus and creates plots dynamically depending on the protagonists of the story. Secondly, our search procedure is simpler and more global; instead of searching for the best story twice (i.e., by first finding the n-best stories and then subsequently reranking them based on coherence and interest), our genetic algorithm explores the space of possible stories once. 3 Plot Generation Following previous work (e.g., Shim and Kim 2002; McIntyre and Lapata 2009) we assume that the user supplies a sentence (e.g., the princess loves the prince) from which the system creates a story. Each entity in this sentence (e.g., princess, prince) is associated with its own narrative schema, a set of key events and actors cooccurring with it in the training corpus. Our narrative schemas differ slightly from Chambers and Jurafsky (2009). They acquire schematic representations of situations akin to FrameNet (Fillmore et al., 2003): schemas consists of semantically similar predicates and the entities evoked by them. In our setting, every en</context>
</contexts>
<marker>Shim, Kim, 2002</marker>
<rawString>Shim, Yunju and Minkoo Kim. 2002. Automatic short story generator based on autonomous agents. In Proceedings of the 5th Pacific Rim International Workshop on Multi Agents. Tokyo, pages 151–162.</rawString>
</citation>
<citation valid="true">
<authors>
<author>I M T Swartjes</author>
<author>M Theune</author>
</authors>
<title>The virtual storyteller: story generation by simulation.</title>
<date>2008</date>
<booktitle>In Proceedings of the 20th Belgian-Netherlands Conference on Artificial Intelligence, BNAIC 2008. Enschede, the Netherlands,</booktitle>
<pages>257--264</pages>
<contexts>
<context position="1665" citStr="Swartjes and Theune, 2008" startWordPosition="252" endWordPosition="255">deed, over the years, several generators have been developed capable of creating stories that resemble human output. To name only a few, TALE-SPIN (Meehan, 1977) generates stories through problem solving, MINSTREL (Turner, 1992) relies on an episodic memory scheme, essentially a repository of previous hand-coded stories, to solve the problems in the current story, and MAKEBELIEVE (Liu and Singh, 2002) uses commonsense knowledge to generate short stories from an initial seed story (supplied by the user). A large body of more recent work views story generation as a form of agent-based planning (Swartjes and Theune, 2008; Pizzi et al., 2007). The agents act as characters with a list of goals. They form plans of action and try to fulfill them. Interesting stories emerge as plans interact and cause failures and possible replanning. The broader appeal of computational story generation lies in its application potential. Examples include the entertainment industry and the development of tools that produce large numbers of plots automatically that might provide inspiration to professional screen writers (Agudo et al., 2004); rendering video games more interesting by allowing the plot to adapt dynamically to the pla</context>
</contexts>
<marker>Swartjes, Theune, 2008</marker>
<rawString>Swartjes, I.M.T. and M. Theune. 2008. The virtual storyteller: story generation by simulation. In Proceedings of the 20th Belgian-Netherlands Conference on Artificial Intelligence, BNAIC 2008. Enschede, the Netherlands, pages 257– 264.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Scott R Turner</author>
</authors>
<title>Ministrel: A Computer Model of Creativity and Sotrytelling.</title>
<date>1992</date>
<location>University of California, Los Angeles, California.</location>
<contexts>
<context position="1268" citStr="Turner, 1992" startWordPosition="188" endWordPosition="189">stead, we employ evolutionary search techniques to explore the space of possible stories which we argue are well suited to the story generation task. Experiments on generating simple children’s stories show that our system outperforms previous data-driven approaches. 1 Introduction Computer story generation has met with fascination since the early days of artificial intelligence. Indeed, over the years, several generators have been developed capable of creating stories that resemble human output. To name only a few, TALE-SPIN (Meehan, 1977) generates stories through problem solving, MINSTREL (Turner, 1992) relies on an episodic memory scheme, essentially a repository of previous hand-coded stories, to solve the problems in the current story, and MAKEBELIEVE (Liu and Singh, 2002) uses commonsense knowledge to generate short stories from an initial seed story (supplied by the user). A large body of more recent work views story generation as a form of agent-based planning (Swartjes and Theune, 2008; Pizzi et al., 2007). The agents act as characters with a list of goals. They form plans of action and try to fulfill them. Interesting stories emerge as plans interact and cause failures and possible r</context>
</contexts>
<marker>Turner, 1992</marker>
<rawString>Turner, Scott R. 1992. Ministrel: A Computer Model of Creativity and Sotrytelling. University of California, Los Angeles, California.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Zhibiao Wu</author>
<author>Martha Palmer</author>
</authors>
<title>Verb semantics and lexical selection.</title>
<date>1994</date>
<booktitle>In Proceedings of the 32nd Annual Meeting of the Association for Computational Linguistics. Las</booktitle>
<pages>133--138</pages>
<location>Cruces, New</location>
<contexts>
<context position="13466" citStr="Wu and Palmer (1994)" startWordPosition="2151" endWordPosition="2154">we check if it can be merged with an already existing one. Nodes are merged only if they have the same verb and similar arguments, with the focal entity (i.e., princess) appearing in the same argument slot. In our example, the nodes “prince marry princess in castle” and “prince marry princess in temple” can be merged as they contain the same verb and number of similar arguments. The nodes “princess have influence” and “princess have baby” cannot be merged as influence and baby are semantically unrelated. We compute argument similarity using WordNet (Fellbaum, 1998) and the measure proposed by Wu and Palmer (1994) which is based on path length. We merge nodes with related arguments only if their similarity exceeds a threshold (determined empirically). 3We use mutual information to identify event sequences strongly associated with the graph entity. 1564 The goblin holds the princess in a lair. The prince rescues the princess and marries her in a castle. The ceremony is beautiful. The princess has influence as the prince rules the country. goblin hold princess in lair prince rescue princess prince marry princess in castle princess have influence The dragon holds the princess in a cave. The prince slays t</context>
</contexts>
<marker>Wu, Palmer, 1994</marker>
<rawString>Wu, Zhibiao and Martha Palmer. 1994. Verb semantics and lexical selection. In Proceedings of the 32nd Annual Meeting of the Association for Computational Linguistics. Las Cruces, New Mexico, pages 133–138.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>