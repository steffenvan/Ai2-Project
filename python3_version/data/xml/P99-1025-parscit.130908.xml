<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<title confidence="0.957197">
Construct Algebra: Analytical Dialog Management
Alicia Abella and Allen L. Gorin
</title>
<note confidence="0.625709">
AT&amp;T Labs Research
180 Park Ave. Bldg 103 Florham Park, NJ 07932
</note>
<sectionHeader confidence="0.97366" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.99936">
In this paper we describe a systematic
approach for creating a dialog management
system based on a Construct Algebra, a
collection of relations and operations on
a task representation. These relations
and operations are analytical components
for building higher level abstractions called
dialog motivators. The dialog manager, con-
sisting of a collection of dialog motivators,
is entirely built using the Construct Algebra.
</bodyText>
<sectionHeader confidence="0.999658" genericHeader="introduction">
1 INTRODUCTION
</sectionHeader>
<bodyText confidence="0.999926274193549">
The dialog manager described in this paper
implements a novel approach to the problem
of dialog management. There are three ma-
jor contributions: the task knowledge repre-
sentation, a Construct Algebra and a collec-
tion of dialog motivators. The task knowl-
edge representation exploits object-oriented
paradigms. The dialog motivators provide
the dialog manager with the dialog strate-
gies that govern its behavior. The Construct
Algebra provides the building blocks needed
to create new dialog motivators and analyze
them.
The first main component of this dialog
manager is the task knowledge representa-
tion. The task knowledge is encoded in ob-
jects. These objects form an inheritance hi-
erarchy that defines the relationships that
exists among these objects. The dialog man-
ager exploits this inheritance hierarchy in de-
termining what queries to pose to the user.
No explicit states and transitions need to be
defined using this framework (Bennacef et
al., 1996; Meng and et. al., 1996; Sadek et
al., 1996). A change to the dialog does not
require a change to the dialog manager, but
more simply, a change to the inheritance hi-
erarchy.
The second main component of this dia-
log manager is the collection of dialog mo-
tivators. The dialog motivators determine
what actions need to be taken (e.g. ask a
confirmation question). The dialog motiva-
tors are founded on a theoretical framework
called a Construct Algebra. The Construct
Algebra allows a designer to add new moti-
vators in a principled way. Creating a new
application requires defining the inheritance
hierarchy and perhaps additional dialog mo-
tivators not encompassed in the existing col-
lection.
This dialog manager has been used for two
applications. The first is a spoken dialog sys-
tem that enables a user to respond to the
open-ended prompt How may I help you?
(HMIHY) (Gorin et al., 1997). The sys-
tem recognizes the words the customer has
said (Riccardi and Bangalore, 1998) and ex-
tracts the meaning of these words (Wright
et al., 1998) to determine what service
they want, conducting a dialog (Abella and
Gorin, 1997; Abella et al., 1996) to effec-
tively engage the customer in a conversa-
tion that will result in providing the service
they requested. The second application is
to Voice Post Query (VPQ) (Buntschuh et
al., 1998) which provides spoken access to
the information in large personnel database
(&gt; 120,000 entries). A user can ask for em-
ployee information such as phone number,
fax number, work location, or ask to call
an employee. These applications are signifi-
</bodyText>
<page confidence="0.997441">
191
</page>
<bodyText confidence="0.9931735">
cantly different but they both use the same
dialog manager.
</bodyText>
<sectionHeader confidence="0.959495" genericHeader="method">
2 Task Representation
</sectionHeader>
<bodyText confidence="0.999973027027027">
Information about the task is defined us-
ing an object inheritance hierarchy. The in-
heritance hierarchy defines the relationships
that exist amongst the task knowledge. Ob-
jects are defined to encode the hierarchy.
This representation adheres to the princi-
ples of object-oriented design as described
in (Booch, 1994). Each of the objects has
three partitions. The first partition contains
the name of the object, the second contains
a list of variables with associated values that
are specific to the object, and the third par-
tition contains any methods associated with
the object. For simplicity of illustration we
will not include any of the methods. Each
of the objects inherits its methods from a
higher level object called the Construct. The
Construct&apos;s methods are the relations and
operations that will be described in section 4.
The result of the speech recognizer is
sent to the spoken language understanding
(SLU) module. The SLU module extracts
the meaning of the user&apos;s utterance and pro-
duces a list of possible objects with asso-
ciated confidence scores that is interpreted
by the dialog manager. The dialog manager
then uses the inheritance hierarchy and an
algorithm&apos; fully described in (Abella and
Gorin, 1997) to produce a set of semanti-
cally consistent inputs to be used by the di-
alog manager. The input is represented as
a boolean expression of constructs extracted
from the utterance. This input is then ma-
nipulated by the dialog motivators to pro-
duce an appropriate action, which most of-
ten consists of playing a prompt to the user
or generating a query to a database.
</bodyText>
<sectionHeader confidence="0.99346" genericHeader="method">
3 The Construct
</sectionHeader>
<bodyText confidence="0.971886">
A construct is the dialog manager&apos;s general
knowledge representation vehicle. The task
An understanding of this algorithm is not nec-
essary for the understanding of the work described
in this paper.
</bodyText>
<figure confidence="0.6964485">
DIAL_FOR_ME
NULL
BILLING
NULL
</figure>
<figureCaption confidence="0.999635">
Figure 1: A construct example for HMIHY
</figureCaption>
<bodyText confidence="0.99776945">
knowledge is encoded as a hierarchy of con-
structs. The construct itself is represented as
a tree structure which allows for the build-
ing of a containment hierarchy. It consists
of two parts, a head and a body. Figure 1
illustrates a construct example for HMIHY.
The DIAL_FOR_ME construct is the head
and it has two constructs for its body, FOR-
WARD_NUMBER and BILLING. These two
constructs represent the two pieces of in-
formation necessary to complete a call. If
a user calls requesting to place a call it is
the DIAL_FOR_ME construct that is created
with the generic BILLING construct and
the FORWARD_NUMBER construct with
its value set to empty. The dialog manager
will then ask for the forward number and for
the type of billing method. In figure 1 the
dialog manager has received a response to
the forward number request.
</bodyText>
<sectionHeader confidence="0.985781" genericHeader="method">
4 Construct Algebra
</sectionHeader>
<bodyText confidence="0.999922">
The construct algebra defines a collection of
elementary relations and operations on a set
of constructs. These relations and opera-
tions are then used to build the larger pro-
cessing units that we call the dialog moti-
vators. The set of dialog motivators defines
the application. In this section we formally
define these relations and operations.
</bodyText>
<subsectionHeader confidence="0.732909">
4.1 The Construct
Definition 1 Head
</subsectionHeader>
<bodyText confidence="0.9998365">
A head is an ordered pair &lt;narne,value&gt;,
where name belongs to some set of prede-
</bodyText>
<equation confidence="0.461276">
FORWARD_NUMBER
555-1234
</equation>
<page confidence="0.991394">
192
</page>
<bodyText confidence="0.998328">
fined names, N, and value belongs to some
set of predefined values, V. A value may be
NULL (not assigned a value).
</bodyText>
<subsectionHeader confidence="0.605932">
Definition 2 Construct
</subsectionHeader>
<bodyText confidence="0.999685333333333">
A construct is defined recursively as an or-
dered pair &lt;head,body&gt; where body is a (pos-
sibly empty) set of constructs.
</bodyText>
<subsectionHeader confidence="0.96238">
4.2 Relations
</subsectionHeader>
<bodyText confidence="0.999724285714286">
The Construct Algebra defines six relations
in the set of constructs. In each of the
definitions, c1 and c2 are constructs. Note
that the symbols C and c, introduced here,
should not be understood in their usual
&amp;quot;subset&amp;quot; and &amp;quot;proper subset&amp;quot; interpretation
but will be described in definitions 4 and 5.
</bodyText>
<subsectionHeader confidence="0.350228">
Definition 3 Equality
</subsectionHeader>
<bodyText confidence="0.717963">
Two constructs are equal, denoted c1 = c2
when
</bodyText>
<equation confidence="0.999737">
head(ci) = head(c2) and
body(ci) = body(c2)
</equation>
<bodyText confidence="0.998173">
Definition 3 requires that the heads of c1
and c2 be equal. Recall that the head of a
construct is an ordered pair &lt;name,value&gt;
which means that their names and values
must be equal. A value may be empty
(NULL) and by definition be equal to any
other value. The equality of bodies means
that a bijective mapping exists from the
body of c1 into the body of c2 such that
elements associated with this mapping are
equal.
</bodyText>
<subsectionHeader confidence="0.55573">
Definition 4 Restriction
</subsectionHeader>
<bodyText confidence="0.9518445">
c1 is a restriction of c2, denoted c1 C c2,
when
</bodyText>
<equation confidence="0.996416">
head(ci) = head(c2) and
(3f : body(ci) .â€” body(c2))(f is 1 to 1 A
(Vbi E body(ci))(bi C f(bi))
</equation>
<bodyText confidence="0.999506833333333">
Intuitively, c1 can be obtained by &amp;quot;pruning&amp;quot;
elements of c2. The second part of the def-
inition, (3f : ...) is what differentiates C
from =. It is required that a mapping f be-
tween the bodies of c1 and c2 exist with the
following properties:
</bodyText>
<figure confidence="0.998628">
PERSON
C2
00
ADDRESS
-
NAME
ADDRESS
NAME
PH(NE_NUMBEP
Cl
C
STREET
PERSON
</figure>
<figureCaption confidence="0.99283">
Figure 2: STREET and PHONE_NUMBER
are &amp;quot;pruned&amp;quot; from c2 to obtain cl.
</figureCaption>
<bodyText confidence="0.961825">
â€¢ f is 1 to 1. In other words, different
elements of the body of cl, call them b1,
are associated with different elements of
the body of c2, call them b2
â€¢ The elements of the body of c1 are re-
strictions of the elements of the body of
c2. In other words, b1 C b2, where b1 are
elements from the body of c1 and b2 are
elements from the body of c2.
Figure 2 illustrates an example.
</bodyText>
<equation confidence="0.455380333333333">
Definition 5 Containment
c1 is contained in c2, denoted c1 C c2, when
Cl C c2 or (3b2 E body(c2))(ci C b2)
</equation>
<bodyText confidence="0.999951666666667">
We assume that c1 C c2 either if c1 is a
restriction of c2 or if c1 is contained in any
element of the body of c2. Figure 3 gives
an example. The AMBIGUITY construct
represents the fact that the system is not
sure whether the user has requested a
COLLECT call or a CALLING_CARD call.
This would trigger a clarifying question
from the dialog manager.
</bodyText>
<page confidence="0.993126">
193
</page>
<figure confidence="0.998302">
DIAL_FOR_ME
COLLECT
CI
&apos;C2
Cl
</figure>
<figureCaption confidence="0.98977">
Figure 4: e1câ€”c2
</figureCaption>
<figure confidence="0.999590166666667">
CALL1NG_CARD
0
CARD_NUMBER
8485417
BILLING
C2
</figure>
<figureCaption confidence="0.922686">
Figure 3: c1 C c2
</figureCaption>
<figure confidence="0.957522538461539">
Definition 6 Generalization
c2 is a generalization of el, denoted c1câ€”e2,
when
head(ci)c-4.head(c2) and
(3f : body(c2) body(ci))
(fis 1 to 1 A (Vb2 E bodY(c2)))(f(b2)b2)
CALL1NG_CARD
CARD_NUMBER
8485417
DIAL_FOR_ME
0
BILLING
Cl C2
</figure>
<bodyText confidence="0.997219444444445">
The generalization of heads means that
the name of c2 is on the inheritance path
of c1 and their values are equal. Intuitively,
c2 is an ancestor of el or in object-oriented
terms &amp;quot;c1 is-a c2&amp;quot;. Note the similarity of
this relation to C. Figure 4 illustrates an
example. BILLING is a generalization of
CALLING_CARD, or in other words CALL-
ING_CARD is-a BILLING.
</bodyText>
<figureCaption confidence="0.324999">
Definition 7 Symmetric Generalization
el is a symmetric generalization of c2, de-
noted c1 C2 when
</figureCaption>
<bodyText confidence="0.729224">
cic2 or c2t--*ci
This definition simply removes the direction-
ality of In other words, either &amp;quot;c1 is-a c2&amp;quot;
</bodyText>
<figureCaption confidence="0.917108">
Figure 5: c1 c--Ã· c2
</figureCaption>
<equation confidence="0.8069116">
Or &amp;quot;C2 is-a c1&amp;quot;.
Definition 8 Containment Generalization
el is a containment generalization of c2, de-
noted c1 c2, when
(3b2)(b2 C c2 A b2
</equation>
<bodyText confidence="0.9859408">
b2 is contained in c2 and ci is a symmet-
ric generalization of b2. An example is illus-
trated in figure 5. BILLING is contained in
DIAL_FOR_ME and is a symmetric general-
ization of CALLING_CARD.
</bodyText>
<page confidence="0.993756">
194
</page>
<subsectionHeader confidence="0.973169">
4.3 Operations
</subsectionHeader>
<bodyText confidence="0.9456595">
The Construct Algebra consists of two
operations union, U and projection, \
</bodyText>
<equation confidence="0.322271">
Definition 9 Union (U)
</equation>
<bodyText confidence="0.999609666666667">
We will define this operation in several
steps. Each step is a progression towards a
more general definition.
</bodyText>
<subsectionHeader confidence="0.530849">
9.1 Union of values (vi U v2)
</subsectionHeader>
<equation confidence="0.775885">
v1 = v2 and v1 NULL
V1 = v2 and v1 = NULL
defined, v1 v2
by definition, NULL is equal to
alue.
Definition 9.2 Union of heads
</equation>
<bodyText confidence="0.996865333333333">
We define head(ci) U head(c2) only in the
case c1c-Ã·c2, which is all that is needed for a
definition of U.
</bodyText>
<equation confidence="0.998955222222222">
head(ci) U head(c2) =
(name(ci), value(ci) U value(c2))
Definition 9.3 (ci U c)
If cic-c2,
C1 U C2 =
(head(ci) U head(c2),
{ f (b2) U b21b2 E body (c2)} U
E body(ci) A
(Vb2 E body(c2))(bi f (b2))})
</equation>
<bodyText confidence="0.999704666666667">
In this definition the head of the resulting
construct is the union of the heads of
the operands. The body of the resulting
construct consists of two parts. The first
part is a set of unions (denoted (b2) U b2
in the definition above) where b2 spans the
body of the second operand c2 and f is
a mapping from Definition 6. Recall that
the mapping f associates elements of the
body (ci) with elements of the body (c2) such
that f(b2),-4b2 for b2 E body (c2) so the
union f(b2) U b2 is (recursively) defined in
Definition 9.3. The second part of the body
of the resulting construct consists of those
elements b1 of the body (ci) that no element
from the body (c2) maps into through the
mapping f. In other words, the second part
of the body consists of those elements &amp;quot;left
</bodyText>
<figure confidence="0.602915">
Cl
</figure>
<figureCaption confidence="0.992069">
Figure 6: c1 U c2 if c1c-4c2
</figureCaption>
<bodyText confidence="0.999234909090909">
behind&amp;quot; in the body (ci) after the mapping
f. Figure 6 illustrates an example. The
union operations results in a construct
with the head CALLING_CARD and a
body that contains both CARD_NUMBER
and EXPIRATION. The CARD_NUMBER
construct from c1 and c2 can be combined
because the value of CARD_NUMBER from
c1 is NULL. The construct EXPIRATION
is added because it does not exist on the
body of c2.
</bodyText>
<equation confidence="0.997610083333333">
Definition 9.4 c1 U e2
If c1 c2,
Cl U C2 =
{ C1 U C2, C1 c-&gt;. C2
C2 U CI, C2 L--+
Definition 9.5 c1 U c2
If c1 ,-- c2,
C1 U C2 =
1 Cl U C2,
(head(c2),
{c1 U b21b2 E body (c2) A c1 c-. b2}U
{b21b2 E body(c2) A c1 &apos;74 b2}), c1 c2
</equation>
<figureCaption confidence="0.999055">
Figure 7 illustrates this union. The head
</figureCaption>
<bodyText confidence="0.861290666666667">
of the resulting construct is the head of
c2 which is DIAL_FOR_ME. The resulting
construct no longer has BILLING but
</bodyText>
<figure confidence="0.993880084745763">
CALLINO_CARD
00
CALLINO_CARD
00
CALLING_CARD
0
CARD_NUMBER
NULL
CARD_NUMBER
1239834
EXPIRATION
299
C2
EXPIRATION
299
CARD_NUMBER
1239834
Definition
U 2/2 =
vi,
notV2,
Recall that
any other v
Cl C2
195
00
CALLING_CARD
DIAL_FOR_ME
DIAL_FOR_ME
AMBICUIT
PERSON
PERSON
PERSON
__,9_1_1_â€¢ I
FIRST NANC&apos; LAST NAME DEPT.
FIRST NAME LAST NAM
DEPT.
FIRST NAME LAST NAME DEPT.
CARD_NUMBER
EXPIRATION
Paul
00
CI C2
EXPIRATION
BILLING
Walter
Jones
6151
John
Smith
C1
6151
Smith
6151
FoRWARD_NuMBER
0
CALLING_CARD
0
FoRWARD_NUMBER
</figure>
<figureCaption confidence="0.918617">
Figure 7: c1 U c2 if c1 c2
</figureCaption>
<figure confidence="0.998502636363636">
PERSON
PERSON
John
Smith
6151
Paul
South
6151
FIRST NAME LAST NAME DEPT. FIRST NAME LAST NAM
00 00
CARD_NUMBER
</figure>
<figureCaption confidence="0.7870604">
rather CALLING_CARD since BILLING is
a generalization of CALLING_CARD. In
addition the resulting construct contains the
construct FORWARD NUMBER because it
remains from DIAL_FOR_ME.
</figureCaption>
<bodyText confidence="0.848801">
Definition 9.6 c1 U e2
In the general case,
</bodyText>
<equation confidence="0.991775285714286">
C1 U C2 =
1 Cl U C2)
C2 U C11
((REP, NULL), fel, e21), CI
C2 &apos;4 C1
CI `74 C2 and
C2 cl
</equation>
<bodyText confidence="0.996611333333333">
In this definition REP is a construct used to
represent the union of those constructs that
do not satisfy any of the aforementioned
conditions. By definition REP has a value
of NULL and the body consists of the
constructs c1 and c2.
</bodyText>
<equation confidence="0.9235118">
Definition 10 Projection (\)
\ c2 =
((AMBIGUITY, NULL),
{b1 U c2Ibi C c1 A b1r=j c2}) C2 L-* CI
Cl C2 &apos;714 C1
</equation>
<figureCaption confidence="0.6914075">
Figure 8 illustrates an example of an am-
biguous construct and the result of the
</figureCaption>
<figure confidence="0.797098">
c2 CI \ C2
</figure>
<figureCaption confidence="0.999817">
Figure 8: Projection operation example
</figureCaption>
<bodyText confidence="0.956849090909091">
projection operation. The construct is
AMBIGUITY because all the elements of
its body have the value of 6151 for DEPT.
In this example, c2 contains the construct
LAST_NAME with the value of Smith.
There are 2 constructs on the body of c1
that are in the relation b2 C ci, in other
words have value for LAST_NAME of Smith.
Therefore the result is an AMBIGUITY
construct with two elements on its body,
both with the LAST_NAME value of Smith.
</bodyText>
<sectionHeader confidence="0.991031" genericHeader="method">
5 Dialog Motivators
</sectionHeader>
<bodyText confidence="0.9999194">
A dialog motivator determines what action
the dialog manager needs to take in con-
ducting its dialog with a user. The di-
alog manager for HMIHY currently con-
sists of 5 dialog motivators. They are dis-
ambiguation , confirmation, error handling
(recovery from misrecognition or misunder-
standing and silence), missing information
and context switching. VPQ uses two addi-
tional motivators, they are continuation and
</bodyText>
<page confidence="0.997184">
196
</page>
<table confidence="0.729226777777778">
ccj: Construct used for disambiguation,
ccj E c
CA: User response
Dk (c, cum() =
C, c AMBIGUITY
Dk44(C, CIDK), cAERROR
Dk+i(C, CIDK U CO, cA = IDK
c\cA, CA C
CA CA V+ C
</table>
<figureCaption confidence="0.998919">
Figure 9: Disambiguation Motivator
</figureCaption>
<bodyText confidence="0.99892808">
database querying.
The disambiguation motivator determines
when there is ambiguous semantic informa-
tion, like conflicting billing methods. Con-
firmation is used when the SLU returns a
result with low confidence. Error handling
takes on three forms. There is error recovery
when the speech recognizer has likely misrec-
ognized what the user has said (low confi-
dence scores associated with the recognition
results), when the user falls silent, and when
the user says something the SLU does not
expect or does not handle. Missing infor-
mation determines what information to ask
about in order to complete a transaction.
Context switching is the ability of the sys-
tem to realize when the user has changed
his/her mind or realizes that it has mis-
understood and allows the user to correct
it. The continuation motivator determines
when it is valid to offer the user the choice to
query the system for additional information.
Database querying decides when the system
has acquired enough information to query a
database for the requested information.
</bodyText>
<subsectionHeader confidence="0.997997">
5.1 Disambiguation Motivator
</subsectionHeader>
<bodyText confidence="0.999533555555555">
Figure 9 illustrate how the disambiguation
motivator is created using the Construct
Algebra. The disambiguation motivator is
called with the current construct c and a
set of constructs called cmic that represents
information that the user does not know
(IDK - &amp;quot;I Don&apos;t Know&amp;quot;), in other words,
the user explicitly responds to a prompt with
the phrase &amp;quot;I don&apos;t know&amp;quot; or its equivalent2.
</bodyText>
<footnote confidence="0.69185">
2The phrases chosen are based on trials
</footnote>
<bodyText confidence="0.83078725">
Input: A sequence of semantic input from
the SLU module in response to a prompt
Output: Complete construct c (no need for
further dialog)
</bodyText>
<subsectionHeader confidence="0.437648">
Repeat
</subsectionHeader>
<bodyText confidence="0.628334">
For all dialog motivators DM;
if DM; applies to c
</bodyText>
<figure confidence="0.569136833333333">
Perform action(DM;,c)
Apply Dialog Manager to get CA
Using Construct Algebra,
combine c and CA into c
Until no motivator applies
Return c
</figure>
<figureCaption confidence="0.97557">
Figure 10: Dialog Manager algorithm
</figureCaption>
<bodyText confidence="0.99995275862069">
The motivator runs through several checks
on the construct c. The first is to check to see
if in fact the motivator applies, or in other
words if c is a restriction of AMBIGUITY.
If it is not then the motivator simply return
C without changing it. The second step is
to check to see if the ERROR construct is a
generalization of CA where CA represents the
user&apos;s response. The ERROR construct rep-
resents an error condition like silence or mis-
recognition. If it is, then it goes on to next
motivator because this motivator does not
apply to error conditions. If CA equals the
IDK construct then this means that the user
did not know the answer to our query and we
add the construct used for disambiguation,
ccj to the set of constructs c/DK. If however,
CA is in the containment generalization rela-
tion with c then the projection operation is
applied and the result is returned. If CA is
not in this relation then this indicates a con-
text switch on the part of the user and the
disambiguation motivator returns CA as the
result.
All other motivators are constructed in a
similar fashion. An application can use these
motivators or create new ones that are ap-
plication specific using the operations and
relations of the Construct Algebra.
</bodyText>
<page confidence="0.996575">
197
</page>
<tableCaption confidence="0.85075825">
System: VPQ. What can I do for you?
User: I need the phone number for Klein.
System: I have more than 20 listings for
Klein. Can you please say the first name?
User: William.
System: I have 2 listings for William Klein.
Can you tell me the person&apos;s work location?
User: Bedminster
</tableCaption>
<table confidence="0.3381362">
System: The phone number for William
Klein is 973 345 5432. Would you like more
information?
User: No.
System: Thank you for using VPQ.
</table>
<figureCaption confidence="0.983462">
Figure 11: A sample dialog for VPQ
</figureCaption>
<sectionHeader confidence="0.992994" genericHeader="method">
6 Dialog Manager
</sectionHeader>
<bodyText confidence="0.999950818181818">
The input to the dialog manager is a collec-
tion of semantic input generated by the SLU.
Figure 10 illustrates the algorithm used by
the dialog manager. The output is the com-
plete construct c which no longer requires
further dialog. The algorithm loops through
all the dialog motivators determining which
one needs to be applied to c. If it finds a mo-
tivator that applies then it will perform the
necessary action (e.g. play a prompt or do
a database lookup). The algorithm repeats
itself to obtain CA (the construct answer). In
other words, the construct that results from
the action is subject to the dialog motiva-
tors starting from the beginning. Once CA
has been found to be complete it is combined
with c using Construct Algebra to produce
a new construct. This new construct c also
goes through the loop of dialog motivators
and the procedure continues until no moti-
vator applies and the algorithm returns the
final construct c.
</bodyText>
<subsectionHeader confidence="0.898813">
6.1 Example
</subsectionHeader>
<bodyText confidence="0.999937577777778">
To illustrate how the dialog manager func-
tions we will use an example from VPQ.
Figure 11 illustrates a sample dialog with
the system. The sequence of motivators for
VPQ is error handling, confirmation, miss-
ing information, database querying and dis-
ambiguation. The construct that is created
as a result of the user&apos;s initial utterance
is shown in figure 12. All the information
needed to do a database lookup is found in
the user&apos;s utterance, namely the piece of in-
formation the user is seeking and the name
of the person. Therefore the first motivator
that applies is database querying. This moti-
vator creates the database query and based
on the result creates the construct CA. The
construct CA is then searched by each of the
motivators beginning again with error han-
dling. The motivator that applies to CA is
the disambiguation motivator because there
are more than 20 people in the database
whose last name is pronounced Klein, in-
cluding Klein, Cline and Kline. The dis-
ambiguation motivator searches through CA
to determine, based on preset parameters,
which piece of information is most useful for
the disambiguation process as well as which
piece of information the user is likely to
know, which is selected when the inheritance
hierarchy is designed. For VPQ this includes
asking about the first name and work loca-
tion. In this example the dialog manager
searches the database entries and determines
that the most discriminating piece of infor-
mation is the first name. Once the user re-
sponds with the first name there are still 2
possible candidates and it asks for the next
piece of information which is work location.
Had the user not known the work location
the system would have read out the phone
number of both people since the total num-
ber of matches is less than 3. If the num-
ber of entries after disambiguation remains
greater than 3 the system refers the user to
a live operator during work hours.
</bodyText>
<sectionHeader confidence="0.999245" genericHeader="conclusions">
7 Conclusion
</sectionHeader>
<bodyText confidence="0.9994566">
In this paper we have described a novel ap-
proach to dialog management. The task
knowledge representation defined intuitively
and without the need to define call flows in
the traditional finite-state approach. The
Construct Algebra serves as the building
blocks from which the dialog motivators
that drive the dialog system are comprised.
Building a new application will only require
the designer to define the objects (e.g. COL-
</bodyText>
<page confidence="0.986598">
198
</page>
<figure confidence="0.450934833333333">
FIND
INFORMATION PERSON
PHONE
FIRST NAME LAST NAME
NULL KLEIN
NULL
</figure>
<figureCaption confidence="0.991275">
Figure 12: Sample construct for VPQ.
</figureCaption>
<bodyText confidence="0.9985144">
LECT, CREDIT etc.) and the inheritance
hierarchy. The Construct Algebra serves as
an analytical tool that allows the dialog mo-
tivators to be formally defined and analyzed
and provides an abstraction hierarchy that
hides the low-level details of the implemen-
tation and pieces together the dialog motiva-
tors. This same dialog manager is currently
being used by two very different applications
(HMIHY and VPQ).
</bodyText>
<sectionHeader confidence="0.998877" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.994095212765957">
Alicia Abella and Allen L. Gorin. 1997.
Generating semantically consistent inputs
to a dialog manager. In Proc. EuroSpeech
Rhodes, Greece.
A. Abella, M. K. Brown, and B. Buntschuh.
1996. Development principles for dialog-
based interfaces. European Conference on
Artificial Intelligence.
S. Bennacef, L. Devillers, S. Rosset, and
L. Lamel. 1996. Dialog in the rail-
tel telephone-based system. International
Conference on Spoken Language Process-
ing.
Grady Booch. 1994. Object-Oriented Anal-
ysis and Design with Applications. Ben-
jamin Cummings.
B. Buntschuh, C. Kamm, G. DiFabbrizio,
A. Abella, M. Mohri, S. Narayan, I. Zelj-
vokic, R.D. Sharp, J. Wright, S. Marcus,
J. Shaffer, R. Duncan, and J.G. Wilpon.
1998. VPQ: A spoken language interface
to large scale directory information. In
Proc. ICSLP Sydney.
A.L. Gorin, G. Riccardi, and J.H. Wright.
1997. How May I Help You? Speech Com-
munciation.
Helen Meng and Senis Busayapongchai et.
al. 1996. Wheels: A conversational sys-
tem in the automobile classifieds domain.
International Conference on Spoken Lan-
guage Processing.
G. Riccardi and S. Bangalore. 1998. Au-
tomatic acquisision of phrase grammars
for stochastic language modeling. In Proc.
ACL Workshop on Very Large Corpora,
Montreal.
M.D. Sadek, A. Ferrieux, A. Cozannet,
P. Bretier, F. Panaget, and J. Simonin.
1996. Effective Human-Computer Co-
operative Spoken Dialogue: the AGS
Demonstrator. International Conference
on Spoken Language Processing.
Jerry Wright, Allen L. Gorin, and Alicia
Abella. 1998. Spoken language under-
standing within dialogs using a graphical
model of task structure. In Proc. ICSLP
Sydney.
</reference>
<page confidence="0.998849">
199
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.737312">
<title confidence="0.995008">Construct Algebra: Analytical Dialog Management</title>
<author confidence="0.999946">Alicia Abella</author>
<author confidence="0.999946">Allen L Gorin</author>
<affiliation confidence="0.99781">AT&amp;T Labs Research</affiliation>
<address confidence="0.999192">180 Park Ave. Bldg 103 Florham Park, NJ 07932</address>
<abstract confidence="0.975393727272727">In this paper we describe a systematic approach for creating a dialog management system based on a Construct Algebra, a collection of relations and operations on a task representation. These relations and operations are analytical components for building higher level abstractions called dialog motivators. The dialog manager, consisting of a collection of dialog motivators, is entirely built using the Construct Algebra.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Alicia Abella</author>
<author>Allen L Gorin</author>
</authors>
<title>Generating semantically consistent inputs to a dialog manager.</title>
<date>1997</date>
<booktitle>In Proc. EuroSpeech Rhodes,</booktitle>
<location>Greece.</location>
<contexts>
<context position="2664" citStr="Abella and Gorin, 1997" startWordPosition="425" endWordPosition="428"> add new motivators in a principled way. Creating a new application requires defining the inheritance hierarchy and perhaps additional dialog motivators not encompassed in the existing collection. This dialog manager has been used for two applications. The first is a spoken dialog system that enables a user to respond to the open-ended prompt How may I help you? (HMIHY) (Gorin et al., 1997). The system recognizes the words the customer has said (Riccardi and Bangalore, 1998) and extracts the meaning of these words (Wright et al., 1998) to determine what service they want, conducting a dialog (Abella and Gorin, 1997; Abella et al., 1996) to effectively engage the customer in a conversation that will result in providing the service they requested. The second application is to Voice Post Query (VPQ) (Buntschuh et al., 1998) which provides spoken access to the information in large personnel database (&gt; 120,000 entries). A user can ask for employee information such as phone number, fax number, work location, or ask to call an employee. These applications are signifi191 cantly different but they both use the same dialog manager. 2 Task Representation Information about the task is defined using an object inher</context>
<context position="4428" citStr="Abella and Gorin, 1997" startWordPosition="712" endWordPosition="715">lustration we will not include any of the methods. Each of the objects inherits its methods from a higher level object called the Construct. The Construct&apos;s methods are the relations and operations that will be described in section 4. The result of the speech recognizer is sent to the spoken language understanding (SLU) module. The SLU module extracts the meaning of the user&apos;s utterance and produces a list of possible objects with associated confidence scores that is interpreted by the dialog manager. The dialog manager then uses the inheritance hierarchy and an algorithm&apos; fully described in (Abella and Gorin, 1997) to produce a set of semantically consistent inputs to be used by the dialog manager. The input is represented as a boolean expression of constructs extracted from the utterance. This input is then manipulated by the dialog motivators to produce an appropriate action, which most often consists of playing a prompt to the user or generating a query to a database. 3 The Construct A construct is the dialog manager&apos;s general knowledge representation vehicle. The task An understanding of this algorithm is not necessary for the understanding of the work described in this paper. DIAL_FOR_ME NULL BILLI</context>
</contexts>
<marker>Abella, Gorin, 1997</marker>
<rawString>Alicia Abella and Allen L. Gorin. 1997. Generating semantically consistent inputs to a dialog manager. In Proc. EuroSpeech Rhodes, Greece.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Abella</author>
<author>M K Brown</author>
<author>B Buntschuh</author>
</authors>
<title>Development principles for dialogbased interfaces.</title>
<date>1996</date>
<booktitle>European Conference on Artificial Intelligence.</booktitle>
<contexts>
<context position="2686" citStr="Abella et al., 1996" startWordPosition="429" endWordPosition="432"> principled way. Creating a new application requires defining the inheritance hierarchy and perhaps additional dialog motivators not encompassed in the existing collection. This dialog manager has been used for two applications. The first is a spoken dialog system that enables a user to respond to the open-ended prompt How may I help you? (HMIHY) (Gorin et al., 1997). The system recognizes the words the customer has said (Riccardi and Bangalore, 1998) and extracts the meaning of these words (Wright et al., 1998) to determine what service they want, conducting a dialog (Abella and Gorin, 1997; Abella et al., 1996) to effectively engage the customer in a conversation that will result in providing the service they requested. The second application is to Voice Post Query (VPQ) (Buntschuh et al., 1998) which provides spoken access to the information in large personnel database (&gt; 120,000 entries). A user can ask for employee information such as phone number, fax number, work location, or ask to call an employee. These applications are signifi191 cantly different but they both use the same dialog manager. 2 Task Representation Information about the task is defined using an object inheritance hierarchy. The </context>
</contexts>
<marker>Abella, Brown, Buntschuh, 1996</marker>
<rawString>A. Abella, M. K. Brown, and B. Buntschuh. 1996. Development principles for dialogbased interfaces. European Conference on Artificial Intelligence.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S Bennacef</author>
<author>L Devillers</author>
<author>S Rosset</author>
<author>L Lamel</author>
</authors>
<title>Dialog in the railtel telephone-based system.</title>
<date>1996</date>
<booktitle>International Conference on Spoken Language Processing.</booktitle>
<contexts>
<context position="1549" citStr="Bennacef et al., 1996" startWordPosition="234" endWordPosition="237">ide the dialog manager with the dialog strategies that govern its behavior. The Construct Algebra provides the building blocks needed to create new dialog motivators and analyze them. The first main component of this dialog manager is the task knowledge representation. The task knowledge is encoded in objects. These objects form an inheritance hierarchy that defines the relationships that exists among these objects. The dialog manager exploits this inheritance hierarchy in determining what queries to pose to the user. No explicit states and transitions need to be defined using this framework (Bennacef et al., 1996; Meng and et. al., 1996; Sadek et al., 1996). A change to the dialog does not require a change to the dialog manager, but more simply, a change to the inheritance hierarchy. The second main component of this dialog manager is the collection of dialog motivators. The dialog motivators determine what actions need to be taken (e.g. ask a confirmation question). The dialog motivators are founded on a theoretical framework called a Construct Algebra. The Construct Algebra allows a designer to add new motivators in a principled way. Creating a new application requires defining the inheritance hiera</context>
</contexts>
<marker>Bennacef, Devillers, Rosset, Lamel, 1996</marker>
<rawString>S. Bennacef, L. Devillers, S. Rosset, and L. Lamel. 1996. Dialog in the railtel telephone-based system. International Conference on Spoken Language Processing.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Grady Booch</author>
</authors>
<title>Object-Oriented Analysis and Design with Applications. Benjamin Cummings.</title>
<date>1994</date>
<contexts>
<context position="3519" citStr="Booch, 1994" startWordPosition="565" endWordPosition="566">the information in large personnel database (&gt; 120,000 entries). A user can ask for employee information such as phone number, fax number, work location, or ask to call an employee. These applications are signifi191 cantly different but they both use the same dialog manager. 2 Task Representation Information about the task is defined using an object inheritance hierarchy. The inheritance hierarchy defines the relationships that exist amongst the task knowledge. Objects are defined to encode the hierarchy. This representation adheres to the principles of object-oriented design as described in (Booch, 1994). Each of the objects has three partitions. The first partition contains the name of the object, the second contains a list of variables with associated values that are specific to the object, and the third partition contains any methods associated with the object. For simplicity of illustration we will not include any of the methods. Each of the objects inherits its methods from a higher level object called the Construct. The Construct&apos;s methods are the relations and operations that will be described in section 4. The result of the speech recognizer is sent to the spoken language understandin</context>
</contexts>
<marker>Booch, 1994</marker>
<rawString>Grady Booch. 1994. Object-Oriented Analysis and Design with Applications. Benjamin Cummings.</rawString>
</citation>
<citation valid="true">
<authors>
<author>B Buntschuh</author>
<author>C Kamm</author>
<author>G DiFabbrizio</author>
<author>A Abella</author>
<author>M Mohri</author>
<author>S Narayan</author>
<author>I Zeljvokic</author>
<author>R D Sharp</author>
<author>J Wright</author>
<author>S Marcus</author>
<author>J Shaffer</author>
<author>R Duncan</author>
<author>J G Wilpon</author>
</authors>
<title>VPQ: A spoken language interface to large scale directory information.</title>
<date>1998</date>
<booktitle>In Proc. ICSLP Sydney.</booktitle>
<contexts>
<context position="2874" citStr="Buntschuh et al., 1998" startWordPosition="461" endWordPosition="464">manager has been used for two applications. The first is a spoken dialog system that enables a user to respond to the open-ended prompt How may I help you? (HMIHY) (Gorin et al., 1997). The system recognizes the words the customer has said (Riccardi and Bangalore, 1998) and extracts the meaning of these words (Wright et al., 1998) to determine what service they want, conducting a dialog (Abella and Gorin, 1997; Abella et al., 1996) to effectively engage the customer in a conversation that will result in providing the service they requested. The second application is to Voice Post Query (VPQ) (Buntschuh et al., 1998) which provides spoken access to the information in large personnel database (&gt; 120,000 entries). A user can ask for employee information such as phone number, fax number, work location, or ask to call an employee. These applications are signifi191 cantly different but they both use the same dialog manager. 2 Task Representation Information about the task is defined using an object inheritance hierarchy. The inheritance hierarchy defines the relationships that exist amongst the task knowledge. Objects are defined to encode the hierarchy. This representation adheres to the principles of object-</context>
</contexts>
<marker>Buntschuh, Kamm, DiFabbrizio, Abella, Mohri, Narayan, Zeljvokic, Sharp, Wright, Marcus, Shaffer, Duncan, Wilpon, 1998</marker>
<rawString>B. Buntschuh, C. Kamm, G. DiFabbrizio, A. Abella, M. Mohri, S. Narayan, I. Zeljvokic, R.D. Sharp, J. Wright, S. Marcus, J. Shaffer, R. Duncan, and J.G. Wilpon. 1998. VPQ: A spoken language interface to large scale directory information. In Proc. ICSLP Sydney.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A L Gorin</author>
<author>G Riccardi</author>
<author>J H Wright</author>
</authors>
<title>How May I Help You? Speech Communciation.</title>
<date>1997</date>
<contexts>
<context position="2435" citStr="Gorin et al., 1997" startWordPosition="386" endWordPosition="389"> dialog motivators determine what actions need to be taken (e.g. ask a confirmation question). The dialog motivators are founded on a theoretical framework called a Construct Algebra. The Construct Algebra allows a designer to add new motivators in a principled way. Creating a new application requires defining the inheritance hierarchy and perhaps additional dialog motivators not encompassed in the existing collection. This dialog manager has been used for two applications. The first is a spoken dialog system that enables a user to respond to the open-ended prompt How may I help you? (HMIHY) (Gorin et al., 1997). The system recognizes the words the customer has said (Riccardi and Bangalore, 1998) and extracts the meaning of these words (Wright et al., 1998) to determine what service they want, conducting a dialog (Abella and Gorin, 1997; Abella et al., 1996) to effectively engage the customer in a conversation that will result in providing the service they requested. The second application is to Voice Post Query (VPQ) (Buntschuh et al., 1998) which provides spoken access to the information in large personnel database (&gt; 120,000 entries). A user can ask for employee information such as phone number, f</context>
</contexts>
<marker>Gorin, Riccardi, Wright, 1997</marker>
<rawString>A.L. Gorin, G. Riccardi, and J.H. Wright. 1997. How May I Help You? Speech Communciation.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Helen Meng</author>
<author>Senis Busayapongchai</author>
</authors>
<title>Wheels: A conversational system in the automobile classifieds domain.</title>
<date>1996</date>
<booktitle>International Conference on Spoken Language Processing.</booktitle>
<marker>Meng, Busayapongchai, 1996</marker>
<rawString>Helen Meng and Senis Busayapongchai et. al. 1996. Wheels: A conversational system in the automobile classifieds domain. International Conference on Spoken Language Processing.</rawString>
</citation>
<citation valid="true">
<authors>
<author>G Riccardi</author>
<author>S Bangalore</author>
</authors>
<title>Automatic acquisision of phrase grammars for stochastic language modeling.</title>
<date>1998</date>
<booktitle>In Proc. ACL Workshop on Very Large Corpora,</booktitle>
<location>Montreal.</location>
<contexts>
<context position="2521" citStr="Riccardi and Bangalore, 1998" startWordPosition="400" endWordPosition="403">rmation question). The dialog motivators are founded on a theoretical framework called a Construct Algebra. The Construct Algebra allows a designer to add new motivators in a principled way. Creating a new application requires defining the inheritance hierarchy and perhaps additional dialog motivators not encompassed in the existing collection. This dialog manager has been used for two applications. The first is a spoken dialog system that enables a user to respond to the open-ended prompt How may I help you? (HMIHY) (Gorin et al., 1997). The system recognizes the words the customer has said (Riccardi and Bangalore, 1998) and extracts the meaning of these words (Wright et al., 1998) to determine what service they want, conducting a dialog (Abella and Gorin, 1997; Abella et al., 1996) to effectively engage the customer in a conversation that will result in providing the service they requested. The second application is to Voice Post Query (VPQ) (Buntschuh et al., 1998) which provides spoken access to the information in large personnel database (&gt; 120,000 entries). A user can ask for employee information such as phone number, fax number, work location, or ask to call an employee. These applications are signifi19</context>
</contexts>
<marker>Riccardi, Bangalore, 1998</marker>
<rawString>G. Riccardi and S. Bangalore. 1998. Automatic acquisision of phrase grammars for stochastic language modeling. In Proc. ACL Workshop on Very Large Corpora, Montreal.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M D Sadek</author>
<author>A Ferrieux</author>
<author>A Cozannet</author>
<author>P Bretier</author>
<author>F Panaget</author>
<author>J Simonin</author>
</authors>
<date>1996</date>
<booktitle>Effective Human-Computer Cooperative Spoken Dialogue: the AGS Demonstrator. International Conference on Spoken Language Processing.</booktitle>
<contexts>
<context position="1594" citStr="Sadek et al., 1996" startWordPosition="243" endWordPosition="246">es that govern its behavior. The Construct Algebra provides the building blocks needed to create new dialog motivators and analyze them. The first main component of this dialog manager is the task knowledge representation. The task knowledge is encoded in objects. These objects form an inheritance hierarchy that defines the relationships that exists among these objects. The dialog manager exploits this inheritance hierarchy in determining what queries to pose to the user. No explicit states and transitions need to be defined using this framework (Bennacef et al., 1996; Meng and et. al., 1996; Sadek et al., 1996). A change to the dialog does not require a change to the dialog manager, but more simply, a change to the inheritance hierarchy. The second main component of this dialog manager is the collection of dialog motivators. The dialog motivators determine what actions need to be taken (e.g. ask a confirmation question). The dialog motivators are founded on a theoretical framework called a Construct Algebra. The Construct Algebra allows a designer to add new motivators in a principled way. Creating a new application requires defining the inheritance hierarchy and perhaps additional dialog motivators</context>
</contexts>
<marker>Sadek, Ferrieux, Cozannet, Bretier, Panaget, Simonin, 1996</marker>
<rawString>M.D. Sadek, A. Ferrieux, A. Cozannet, P. Bretier, F. Panaget, and J. Simonin. 1996. Effective Human-Computer Cooperative Spoken Dialogue: the AGS Demonstrator. International Conference on Spoken Language Processing.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jerry Wright</author>
<author>Allen L Gorin</author>
<author>Alicia Abella</author>
</authors>
<title>Spoken language understanding within dialogs using a graphical model of task structure.</title>
<date>1998</date>
<booktitle>In Proc. ICSLP Sydney.</booktitle>
<contexts>
<context position="2583" citStr="Wright et al., 1998" startWordPosition="412" endWordPosition="415">ramework called a Construct Algebra. The Construct Algebra allows a designer to add new motivators in a principled way. Creating a new application requires defining the inheritance hierarchy and perhaps additional dialog motivators not encompassed in the existing collection. This dialog manager has been used for two applications. The first is a spoken dialog system that enables a user to respond to the open-ended prompt How may I help you? (HMIHY) (Gorin et al., 1997). The system recognizes the words the customer has said (Riccardi and Bangalore, 1998) and extracts the meaning of these words (Wright et al., 1998) to determine what service they want, conducting a dialog (Abella and Gorin, 1997; Abella et al., 1996) to effectively engage the customer in a conversation that will result in providing the service they requested. The second application is to Voice Post Query (VPQ) (Buntschuh et al., 1998) which provides spoken access to the information in large personnel database (&gt; 120,000 entries). A user can ask for employee information such as phone number, fax number, work location, or ask to call an employee. These applications are signifi191 cantly different but they both use the same dialog manager. </context>
</contexts>
<marker>Wright, Gorin, Abella, 1998</marker>
<rawString>Jerry Wright, Allen L. Gorin, and Alicia Abella. 1998. Spoken language understanding within dialogs using a graphical model of task structure. In Proc. ICSLP Sydney.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>