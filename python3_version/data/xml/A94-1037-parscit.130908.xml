<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.007506">
<title confidence="0.994545">
Spelling Correction in Agglutinative Languages
</title>
<author confidence="0.965594">
Kemal Oflazer and Cemaleddin Giizey
</author>
<affiliation confidence="0.9953225">
Department of Computer Engineering and Information Science
Bilkent University
</affiliation>
<address confidence="0.456347">
Ankara, 06533, Turkey
</address>
<email confidence="0.760508">
koOcs.bilkent.edu.tr
</email>
<sectionHeader confidence="0.999577" genericHeader="abstract">
1 Introduction
</sectionHeader>
<bodyText confidence="0.990710363636364">
Spelling correction is an important component of
any system for processing text. Agglutinative lan-
guages such as Turkish or Finnish, differ from lan-
guages like English in the way lexical forms are gen-
erated. Typical nominal or a verbal root may gener-
ate thousands (or even millions) of valid forms which
never appear in the dictionary. For instance, we
can give the following (rather exaggerated) exam-
ple from Turkish:
uygarla§taramayabileeeklerimizdenmivinizcesinel
whose morpheme breakdown is:
</bodyText>
<table confidence="0.989018833333333">
uygar -1a§ -tar -ama
civilized +BECOME CAUS +NEG
-yabil -ecek -ler -irniz
+POT +FUT +3PL +POSS-1SG
-den -mi § -siniz -cesine
+ABL +NARR +2PL +AS-IF
</table>
<bodyText confidence="0.996160888888889">
Methods developed for spelling correction for lan-
guages like English (see the review by Kukich (Ku-
kich, 1992)) are not readily applicable to agglutina-
tive languages. This poster presents an approach to
spelling correction in agglutinative languages that
is based on two-level morphology and a dynamic-
programming based search algorithm. After an
overview of our approach, we present results from
experiments with spelling correction in Turkish.
</bodyText>
<sectionHeader confidence="0.853393" genericHeader="categories and subject descriptors">
2 Spelling correction algorithm
</sectionHeader>
<bodyText confidence="0.999856">
Our approach comprises two-steps: (1) determining
all the roots from the dictionary that can be the root
of the misspelled word, and (2) generating (system-
atically) all the possible words that &amp;quot;resemble&amp;quot; the
given character string, from these roots. The first
step of the problem is relatively easy because of the
static structure of the root dictionary. Techniques
developed for spelling correction, say, in English can
usually be applied here. The second step involves
producing all the possible words from the selected
roots and requires a generate and test search proce-
dure.
</bodyText>
<footnote confidence="0.8651505">
1This is an adverb meaning roughly &amp;quot;(behaving) as
if you were one of those whom we might not be able
</footnote>
<bodyText confidence="0.972916590909091">
We denote the set of the surface forms of the roots
in the language by R. We denote by X and Y
strings formed using the alphabet of the language.
X will denote the surface form of the incorrect or
misspelled string, and Y will typically denote the
surface string that is a (possibly partial) candidate
word. Yiex will denote the lexical form of this candi-
date string.2 We assume the existence of a function,
sur f ace() to generate surface strings from lexical st-
rings, i.e., sur f ace(Yier) = Y. The edit distance
metric ed(X ,Y) (Du and Chang, 1992) measures
how many unit operations (insertion, deletion, re-
placement of single character and transposition of
two adjacent characters) are necessary to convert
one string X into another Y.
We would like to abstract the behavior of a mor-
phological generator and analyzer for the given lan-
guage by two finite state automata. A finite state
generator Mg = (P, b, V, S, F) where P is a set of
states, .5 is the state transition function, V is the
output alphabet, S is the starting state, and F is
a set of final states, generates, all correctly formed
words of the language. The transitions of Mg are
of the form (pi) = pi (pi and pi E P), with an
output vk E V which denotes the lexical form of
a morpheme in the language and also labels the
transition. It should be noted that it is possible to
go from one state pi to another pi by more than one
transition, outputting a different morpheme. We say
a string Yie, is generated by M9, if Y1ex is formed
by concatenating, in order, the outputs of the ma-
chine as we traverse starting from S to one of the
states in F. We denote by L(M9) as the set of all
lexical strings generated by M9. We also assume a
finite state recognizer Mr which recognizes whether
a given surface string is in the language or not.
The spelling correction problem can now be for-
mulated as follows: Given an incorrect word X
(rejected by Mr), and an edit distance threshold
t, find the solution set of possible correct words
S(X, t) = {Y jed(X ,Y) &lt;I and Y = surf ace(Yi„)
and Vie, E L(Mg)} in viable time and space.
&apos;Lexical and surface are used in the two-level mor-
phology sense.
</bodyText>
<page confidence="0.996201">
194
</page>
<bodyText confidence="0.999859551724138">
The set of all the possible roots for the incorrect
word X is defined as PR(X,t) = fr I ed(X[i], r) &lt;
t and 1 &lt; i &lt; m and r E R1.3 We assume that
PR(X, t) can be computed by a standard q—gram
technique. Using a small number (3 - 5) of 2-grams,
gives satisfactory solutions in our case.
Assuming that we have a set of root words found
as described above, we now have to generate words in
the language having these roots, that do not deviate
from the given misspelled string by more than the
threshold. The solution requires a generate and test
probing of the finite-state automaton Mg, starting
with the start state S. We now have to find all the
paths from this state to one of the final states using
the roots in PR(X,1), so that when the morphemes
along this path are concatenated and surface string
is generated, it is within an edit distance t of X.
When the search starts morphemes are concate-
nated to root and the length of the candidate lexical
string Yiex increases. After one step of the search,
the partial surface string Y is compared with a suit-
able prefix of X. In most of the cases the candidate
Y will deviate from these prefixes of X by more than
the threshold without reaching a final state, so that
we can no longer get to a viable solution. In such
cases we do not consider any further transitions from
that state. Special attention has to paid when a suf-
fixation changes the surface realization of morpheme
immediately to the left.
</bodyText>
<sectionHeader confidence="0.952284" genericHeader="evaluation">
3 Results from experiments with
</sectionHeader>
<bodyText confidence="0.822002727272727">
spelling correction in Turkish
We first present a spelling correction example from
our implementation where we used bigrams (q = 2),
and we chose the number of bigrams to use for deter-
mining the root, k, as 3 (see Figure 1). We tested
yatismalanyla
yakismalanyla
kasismalanyla gikismalarlyla
Candidate Roots:4gag gaki gal gall gam can gap gar gat gati
gag gak gakis gal galls gap gat gatis gav
gav gay
</bodyText>
<subsectionHeader confidence="0.442508">
Solutions:5 Lexical Surface
</subsectionHeader>
<bodyText confidence="0.317309">
Edit distance 1 gati-Hs+mA-FIArH-l-y1A
</bodyText>
<figure confidence="0.91039175">
gap+Hs-FmA1-1ArH-1-y1A
galisi-mA-FlArHA-y1A
Edit Distance 2 gav-i-mAi-lArHi-y1A
gat+mA+1ArHi-y1A
</figure>
<figureCaption confidence="0.998651">
Figure 1: Spelling correction example
</figureCaption>
<footnote confidence="0.985786833333333">
3X[i] denotes the string of the first i characters of X.
&apos;The duplicate entries in the list of candidate roots
in fact have different part-of-speech categories andhence
different morphotactics.
5.A small subset of the whole solution set is given, due
to space limitations.
</footnote>
<tableCaption confidence="0.9847035">
Table 1: Average number of operations per mis-
spelled word.
</tableCaption>
<table confidence="0.9318722">
Rec. Gen. Ed. Ms. Soln. % Accuracy
Ed.Dis. Oper
2498.4
30.9 311.2 3.6 95.1
2 108.4 4462.0 20680.4 52.0 95.1
</table>
<bodyText confidence="0.99861815">
our algorithm on a set of 141 randomly selected in-
correct words from Turkish text with edit distances
1 (86%) and 2 (14%) to their correct form. The
morphological analyzer and generator that we used
was our two-level specification for Turkish (Oflazer,
1993), developed using the PC-KIMMO system. It
is, however, rather slow and can analyze only about
2 forms per second and can generate about 50 forms
a second on Sun Sparcstations. So, instead of using
timings, we counted the number of times certain ex-
pensive operations we called. The statistics shown in
Table 1 show the average number of morphological
recognitions and generations, and the edit distance
operations required, and the number of correct solu-
tions offered per misspelled input word. The last col-
umn indicates the percentage of cases the intended
correct form was found. We also have developed a
algorithm for ranking the solutions which offers the
intended correct form as the first in 74% of the cases
when t = 1.
</bodyText>
<sectionHeader confidence="0.999387" genericHeader="conclusions">
4 Conclusions
</sectionHeader>
<bodyText confidence="0.9999225">
This poster has presented a spelling correction algo-
rithm for agglutinative languages that is based on a
two-level morphological generator and analyzer, and
a intelligent generate and test search procedure.
</bodyText>
<sectionHeader confidence="0.996973" genericHeader="acknowledgments">
5 Acknowledgement
</sectionHeader>
<bodyText confidence="0.9603815">
The research was supported in part by a NATO Sci-
ence for Stability Grant, TU-LANGUAGE.
</bodyText>
<sectionHeader confidence="0.997554" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.995769666666667">
M .W. Du and S. C. Chang. 1992 A model and a fast
algorithm for multiple errors spelling correction.
Acta Informatica, 29:281-302.
K. Kukich. 1992 Techniques for automatically cor-
recting words in text. ACM Computing Surveys,
24:377-439.
K. Oflazer. 1993 Two-level description of Turkish
morphology. In Proceedings of the Sixth Confer-
ence of the European Chapter of the Association
for Computational Linguistics, April. A full ver-
sion appear in Literary and Linguistic Computing,
Vol.9 No.2, 1994.
</reference>
<figure confidence="0.9942869">
EXAMPLE
Misspelled word: gaismalanyla
Threshold t: 2
Solutions: yazismalariyla
on left edge yapismalartyla
gatismalanyla
gapismalarlyla
galismalanyla (corr.)
gavmalanyla
gatmalarlyla
</figure>
<page confidence="0.969821">
195
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.723403">
<title confidence="0.999962">Spelling Correction in Agglutinative Languages</title>
<author confidence="0.986785">Oflazer Giizey</author>
<affiliation confidence="0.9999255">Department of Computer Engineering and Information Science Bilkent University</affiliation>
<address confidence="0.99993">Ankara, 06533, Turkey</address>
<email confidence="0.733227">koOcs.bilkent.edu.tr</email>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>M W Du</author>
<author>S C Chang</author>
</authors>
<title>A model and a fast algorithm for multiple errors spelling correction.</title>
<date>1992</date>
<journal>Acta Informatica,</journal>
<pages>29--281</pages>
<contexts>
<context position="2570" citStr="Du and Chang, 1992" startWordPosition="404" endWordPosition="407">y &amp;quot;(behaving) as if you were one of those whom we might not be able We denote the set of the surface forms of the roots in the language by R. We denote by X and Y strings formed using the alphabet of the language. X will denote the surface form of the incorrect or misspelled string, and Y will typically denote the surface string that is a (possibly partial) candidate word. Yiex will denote the lexical form of this candidate string.2 We assume the existence of a function, sur f ace() to generate surface strings from lexical strings, i.e., sur f ace(Yier) = Y. The edit distance metric ed(X ,Y) (Du and Chang, 1992) measures how many unit operations (insertion, deletion, replacement of single character and transposition of two adjacent characters) are necessary to convert one string X into another Y. We would like to abstract the behavior of a morphological generator and analyzer for the given language by two finite state automata. A finite state generator Mg = (P, b, V, S, F) where P is a set of states, .5 is the state transition function, V is the output alphabet, S is the starting state, and F is a set of final states, generates, all correctly formed words of the language. The transitions of Mg are of</context>
</contexts>
<marker>Du, Chang, 1992</marker>
<rawString>M .W. Du and S. C. Chang. 1992 A model and a fast algorithm for multiple errors spelling correction. Acta Informatica, 29:281-302.</rawString>
</citation>
<citation valid="true">
<authors>
<author>K Kukich</author>
</authors>
<title>Techniques for automatically correcting words in text.</title>
<date>1992</date>
<journal>ACM Computing Surveys,</journal>
<pages>24--377</pages>
<contexts>
<context position="972" citStr="Kukich, 1992" startWordPosition="139" endWordPosition="141">from languages like English in the way lexical forms are generated. Typical nominal or a verbal root may generate thousands (or even millions) of valid forms which never appear in the dictionary. For instance, we can give the following (rather exaggerated) example from Turkish: uygarla§taramayabileeeklerimizdenmivinizcesinel whose morpheme breakdown is: uygar -1a§ -tar -ama civilized +BECOME CAUS +NEG -yabil -ecek -ler -irniz +POT +FUT +3PL +POSS-1SG -den -mi § -siniz -cesine +ABL +NARR +2PL +AS-IF Methods developed for spelling correction for languages like English (see the review by Kukich (Kukich, 1992)) are not readily applicable to agglutinative languages. This poster presents an approach to spelling correction in agglutinative languages that is based on two-level morphology and a dynamicprogramming based search algorithm. After an overview of our approach, we present results from experiments with spelling correction in Turkish. 2 Spelling correction algorithm Our approach comprises two-steps: (1) determining all the roots from the dictionary that can be the root of the misspelled word, and (2) generating (systematically) all the possible words that &amp;quot;resemble&amp;quot; the given character string, f</context>
</contexts>
<marker>Kukich, 1992</marker>
<rawString>K. Kukich. 1992 Techniques for automatically correcting words in text. ACM Computing Surveys, 24:377-439.</rawString>
</citation>
<citation valid="true">
<authors>
<author>K Oflazer</author>
</authors>
<title>Two-level description of Turkish morphology.</title>
<date>1993</date>
<booktitle>In Proceedings of the Sixth Conference of the European Chapter of the Association for Computational Linguistics, April. A full version appear in Literary and Linguistic Computing, Vol.9 No.2,</booktitle>
<contexts>
<context position="6961" citStr="Oflazer, 1993" startWordPosition="1191" endWordPosition="1192">he list of candidate roots in fact have different part-of-speech categories andhence different morphotactics. 5.A small subset of the whole solution set is given, due to space limitations. Table 1: Average number of operations per misspelled word. Rec. Gen. Ed. Ms. Soln. % Accuracy Ed.Dis. Oper 2498.4 30.9 311.2 3.6 95.1 2 108.4 4462.0 20680.4 52.0 95.1 our algorithm on a set of 141 randomly selected incorrect words from Turkish text with edit distances 1 (86%) and 2 (14%) to their correct form. The morphological analyzer and generator that we used was our two-level specification for Turkish (Oflazer, 1993), developed using the PC-KIMMO system. It is, however, rather slow and can analyze only about 2 forms per second and can generate about 50 forms a second on Sun Sparcstations. So, instead of using timings, we counted the number of times certain expensive operations we called. The statistics shown in Table 1 show the average number of morphological recognitions and generations, and the edit distance operations required, and the number of correct solutions offered per misspelled input word. The last column indicates the percentage of cases the intended correct form was found. We also have develo</context>
</contexts>
<marker>Oflazer, 1993</marker>
<rawString>K. Oflazer. 1993 Two-level description of Turkish morphology. In Proceedings of the Sixth Conference of the European Chapter of the Association for Computational Linguistics, April. A full version appear in Literary and Linguistic Computing, Vol.9 No.2, 1994.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>