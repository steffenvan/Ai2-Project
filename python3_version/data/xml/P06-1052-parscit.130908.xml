<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000137">
<title confidence="0.9996115">
An Improved Redundancy Elimination Algorithm
for Underspecified Representations
</title>
<author confidence="0.998018">
Alexander Koller and Stefan Thater
</author>
<affiliation confidence="0.974376">
Dept. of Computational Linguistics
Universität des Saarlandes, Saarbrücken, Germany
</affiliation>
<email confidence="0.990531">
{koller,stth}@coli.uni-sb.de
</email>
<sectionHeader confidence="0.997312" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999812538461538">
We present an efficient algorithm for the
redundancy elimination problem: Given
an underspecified semantic representation
(USR) of a scope ambiguity, compute an
USR with fewer mutually equivalent read-
ings. The algorithm operates on underspec-
ified chart representations which are de-
rived from dominance graphs; it can be ap-
plied to the USRs computed by large-scale
grammars. We evaluate the algorithm on
a corpus, and show that it reduces the de-
gree of ambiguity significantly while tak-
ing negligible runtime.
</bodyText>
<sectionHeader confidence="0.999394" genericHeader="introduction">
1 Introduction
</sectionHeader>
<bodyText confidence="0.999247625">
Underspecification is nowadays the standard ap-
proach to dealing with scope ambiguities in com-
putational semantics (van Deemter and Peters,
1996; Copestake et al., 2004; Egg et al., 2001;
Blackburn and Bos, 2005). The basic idea be-
hind it is to not enumerate all possible semantic
representations for each syntactic analysis, but to
derive a single compact underspecified represen-
tation (USR). This simplifies semantics construc-
tion, and current algorithms support the efficient
enumeration of the individual semantic representa-
tions from an USR (Koller and Thater, 2005b).
A major promise of underspecification is that it
makes it possible, in principle, to rule out entire
subsets of readings that we are not interested in
wholesale, without even enumerating them. For in-
stance, real-world sentences with scope ambigui-
ties often have many readings that are semantically
equivalent. Subsequent modules (e.g. for doing in-
ference) will typically only be interested in one
reading from each equivalence class, and all oth-
ers could be deleted. This situation is illustrated
by the following two (out of many) sentences from
the Rondane treebank, which is distributed with
</bodyText>
<listItem confidence="0.712268375">
the English Resource Grammar (ERG; Flickinger
(2002)), a large-scale HPSG grammar of English.
(1) For travellers going to Finnmark there is a
bus service from Oslo to Alta through Swe-
den. (Rondane 1262)
(2) We quickly put up the tents in the lee of a
small hillside and cook for the first time in
the open. (Rondane 892)
</listItem>
<bodyText confidence="0.999871161290323">
For the annotated syntactic analysis of (1), the
ERG derives an USR with eight scope bearing op-
erators, which results in a total of 3960 readings.
These readings are all semantically equivalent to
each other. On the other hand, the USR for (2) has
480 readings, which fall into two classes of mutu-
ally equivalent readings, characterised by the rela-
tive scope of “the lee of” and “a small hillside.”
In this paper, we present an algorithm for the
redundancy elimination problem: Given an USR,
compute an USR which has fewer readings, but
still describes at least one representative of each
equivalence class – without enumerating any read-
ings. This algorithm makes it possible to compute
the one or two representatives of the semantic
equivalence classes in the examples, so subsequent
modules don’t have to deal with all the other equiv-
alent readings. It also closes the gap between the
large number of readings predicted by the gram-
mar and the intuitively perceived much lower de-
gree of ambiguity of these sentences. Finally, it
can be helpful for a grammar designer because it
is much more feasible to check whether two read-
ings are linguistically reasonable than 480. Our al-
gorithm is applicable to arbitrary USRs (not just
those computed by the ERG). While its effect is
particularly significant on the ERG, which uni-
formly treats all kinds of noun phrases, including
proper names and pronouns, as generalised quanti-
fiers, it will generally help deal with spurious ambi-
guities (such as scope ambiguities between indef-
</bodyText>
<page confidence="0.98807">
409
</page>
<note confidence="0.532497">
Proceedings of the 21st International Conference on Computational Linguistics and 44th Annual Meeting of the ACL, pages 409–416,
Sydney, July 2006. c�2006 Association for Computational Linguistics
</note>
<bodyText confidence="0.999979">
inites), which have been a ubiquitous problem in
most theories of scope since Montague Grammar.
We model equivalence in terms of rewrite rules
that permute quantifiers without changing the se-
mantics of the readings. The particular USRs we
work with are underspecified chart representations,
which can be computed from dominance graphs
(or USRs in some other underspecification for-
malisms) efficiently (Koller and Thater, 2005b).
We evaluate the performance of the algorithm on
the Rondane treebank and show that it reduces the
median number of readings from 56 to 4, by up
to a factor of 666.240 for individual USRs, while
running in negligible time.
To our knowledge, our algorithm and its less
powerful predecessor (Koller and Thater, 2006)
are the first redundancy elimination algorithms in
the literature that operate on the level of USRs.
There has been previous research on enumerating
only some representatives of each equivalence
class (Vestre, 1991; Chaves, 2003), but these
approaches don’t maintain underspecification:
After running their algorithms, they are left with
a set of readings rather than an underspecified
representation, i.e. we could no longer run other
algorithms on an USR.
The paper is structured as follows. We will first de-
fine dominance graphs and review the necessary
background theory in Section 2. We will then intro-
duce our notion of equivalence in Section 3, and
present the redundancy elimination algorithm in
Section 4. In Section 5, we describe the evaluation
of the algorithm on the Rondane corpus. Finally,
Section 6 concludes and points to further work.
</bodyText>
<sectionHeader confidence="0.963811" genericHeader="method">
2 Dominance graphs
</sectionHeader>
<bodyText confidence="0.996862666666667">
The basic underspecification formalism we as-
sume here is that of (labelled) dominance graphs
(Althaus et al., 2003). Dominance graphs are
equivalent to leaf-labelled normal dominance con-
straints (Egg et al., 2001), which have been dis-
cussed extensively in previous literature.
</bodyText>
<listItem confidence="0.886957625">
Definition 1. A (compact) dominance graph is a
directed graph (V,E U+ D) with two kinds of edges,
tree edges E and dominance edges D, such that:
1. The graph (V,E) defines a collection of node
disjoint trees of height 0 or 1. We call the
trees in (V,E) the fragments of the graph.
2. If (v,v&apos;) is a dominance edge in D, then v is
a hole and v&apos; is a root. A node v is a root if v
</listItem>
<bodyText confidence="0.99467975">
does not have incoming tree edges; otherwise,
v is a hole.
A labelled dominance graph over a ranked sig-
nature Σ is a triple G = (V,E U+ D,L) such that
(V,E U+ D) is a dominance graph and L : V --� Σ
is a partial labelling function which assigns a node
v a label with arity n iff v is a root with n outgoing
tree edges. Nodes without labels (i.e. holes) must
have outgoing dominance edges.
We will write R(F) for the root of the fragment
F, and we will typically just say “graph” instead
of “labelled dominance graph”.
An example of a labelled dominance graph is
shown to the left of Fig. 1. Tree edges are drawn
as solid lines, and dominance edges as dotted lines,
directed from top to bottom. This graph can serve
as an USR for the sentence “a representative of
a company saw a sample” if we demand that the
holes are “plugged” by roots while realising the
dominance edges as dominance, as in the two con-
figurations (of five) shown to the right. These con-
figurations are trees that encode semantic represen-
tations of the sentence. We will freely read config-
urations as ground terms over the signature Σ.
</bodyText>
<subsectionHeader confidence="0.997702">
2.1 Hypernormally connected graphs
</subsectionHeader>
<bodyText confidence="0.998831083333333">
Throughout this paper, we will only consider hy-
pernormally connected (hnc) dominance graphs.
Hnc graphs are equivalent to chain-connected
dominance constraints (Koller et al., 2003), and
are closely related to dominance nets (Niehren and
Thater, 2003). Fuchss et al. (2004) have presented
a corpus study that strongly suggests that all dom-
inance graphs that are generated by current large-
scale grammars are (or should be) hnc.
Technically, a graph G is hypernormally con-
nected iff each pair of nodes is connected by a sim-
ple hypernormal path in G. A hypernormal path
(Althaus et al., 2003) in G is a path in the undi-
rected version Gu of G that does not use two dom-
inance edges that are incident to the same hole.
Hnc graphs have a number of very useful struc-
tural properties on which this paper rests. One
which is particularly relevant here is that we can
predict in which way different fragments can dom-
inate each other.
Definition 2. Let G be a hnc dominance graph. A
fragment F1 in G is called a possible dominator
of another fragment F2 in G iff it has exactly one
hole h which is connected to R(F2) by a simple hy-
</bodyText>
<page confidence="0.997959">
410
</page>
<figureCaption confidence="0.95815">
Figure 1: A dominance graph that represents the five readings of the sentence “a representative of a
company saw a sample” (left) and two of its five configurations.
</figureCaption>
<figure confidence="0.897779416666667">
sampley seex,y
seex,y
ax
repr-ofx,z
ay
sampley
7
ax
az
compz repr-ofx,z sampley seex,y
az
2
compz
repr-ofx,z
az
compz
1 2 3
4 5 6
2
1
ay
3
1
ax
3
ay
11,2,3,4,5,6,7} :(1,h1 H 14},h2 H 12,3,5,6,7})
(2,h3 H 11,4,5},h4 H 13,6,7})
(3,h5 H 15},h6 H 11,2,4,5,7})
12,3,5,6,7} :(2,h3 H 15},h4 H 13,6,7})
(3,h5 H 16},h6 H 12,5,7})
13,6,7} :(3,h5 H 16},h6 H 17})
12,5,7} :(2,h3 H 15},h4 H 17})
11,4,5} :(1,h1 H 14},h2 H 15})
11,2,4,5,7} :(1,h1 H 14},h2 H 12,5,7})
(2,h3 H 11,4,5},h4 H 17})
</figure>
<figureCaption confidence="0.999275">
Figure 2: The chart for the graph in Fig. 1.
</figureCaption>
<bodyText confidence="0.999581888888889">
pernormal path which doesn’t use R(F1). We write
ch(F1,F2) for this unique h.
Lemma 1 (Koller and Thater (2006)). Let F1, F2
be fragments in a hnc dominance graph G. If there
is a configuration C of G in which R(F1) dominates
R(F2), then F1 is a possible dominator of F2, and
in particular ch(F1,F2) dominates R(F2) in C.
By applying this rather abstract result, we can
derive a number of interesting facts about the ex-
ample graph in Fig. 1. The fragments 1, 2, and 3
are possible dominators of all other fragments (and
of each other), while the fragments 4 through 7
aren’t possible dominators of anything (they have
no holes); so 4 through 7 must be leaves in any con-
figuration of the graph. In addition, if fragment 2
dominates fragment 3 in any configuration, then in
particular the right hole of 2 will dominate the root
of 3; and so on.
</bodyText>
<subsectionHeader confidence="0.999153">
2.2 Dominance charts
</subsectionHeader>
<bodyText confidence="0.999955775510204">
Below we will not work with dominance graphs
directly. Rather, we will use dominance charts
(Koller and Thater, 2005b) as our USRs: they are
more explicit USRs, which support a more fine-
grained deletion of reading sets than graphs.
A dominance chart for the graph G is a mapping
of weakly connected subgraphs of G to sets of
splits (see Fig. 2), which describe possible ways
of constructing configurations of the subgraph.
A subgraph G&apos; is assigned one split for each
fragment F in G&apos; which can be at the root of a
configuration of G&apos;. If the graph is hnc, removing
F from the graph splits G&apos; into a set of weakly
connected components (wccs), each of which is
connected to exactly one hole of F. We also record
the wccs, and the hole to which each wcc belongs,
in the split. In order to compute all configurations
represented by a split, we can first compute
recursively the configurations of each component;
then we plug each combination of these sub-
configurations into the appropriate holes of the
root fragment. We define the configurations asso-
ciated with a subgraph as the union over its splits,
and those of the entire chart as the configurations
associated with the complete graph.
Fig. 2 shows the dominance chart correspond-
ing to the graph in Fig. 1. The chart represents
exactly the configuration set of the graph, and is
minimal in the sense that every subgraph and ev-
ery split in the chart can be used in constructing
some configuration. Such charts can be computed
efficiently (Koller and Thater, 2005b) from a dom-
inance graph, and can also be used to compute the
configurations of a graph efficiently.
The example chart expresses that three frag-
ments can be at the root of a configuration of the
complete graph: 1, 2, and 3. The entry for the split
with root fragment 2 tells us that removing 2 splits
the graph into the subgraphs 11,4,5} and 13,6,7}
(see Fig. 3). If we configure these two subgraphs
recursively, we obtain the configurations shown in
the third column of Fig. 3; we can then plug these
sub-configurations into the appropriate holes of 2
and obtain a configuration for the entire graph.
Notice that charts can be exponentially larger
than the original graph, but they are still expo-
nentially smaller than the entire set of readings
because common subgraphs (such as the graph
12,5,7} in the example) are represented only once,
</bodyText>
<page confidence="0.988795">
411
</page>
<figure confidence="0.997376846153846">
1 2 3
h1 h2 h3 h4 h5 h6
h1 h2 h5 h6
→ →
1 3
1 3
→
2
1 3
4 5 6 7
4 5 6 7
4 5 6 7
4 5 6 7
</figure>
<figureCaption confidence="0.998865">
Figure 3: Extracting a configuration from a chart.
</figureCaption>
<bodyText confidence="0.999882">
and are small in practice (see (Koller and Thater,
2005b) for an analysis). Thus the chart can still
serve as an underspecified representation.
</bodyText>
<sectionHeader confidence="0.999266" genericHeader="method">
3 Equivalence
</sectionHeader>
<bodyText confidence="0.999978666666667">
Now let’s define equivalence of readings more
precisely. Equivalence of semantic representations
is traditionally defined as the relation between
formulas (say, of first-order logic) which have
the same interpretation. However, even first-order
equivalence is an undecidable problem, and broad-
coverage semantic representations such as those
computed by the ERG usually have no well-
defined model-theoretic semantics and therefore
no concept of semantic equivalence.
On the other hand, we do not need to solve
the full semantic equivalence problem, as we only
want to compare formulas that are readings of the
same sentence, i.e. different configurations of the
same USR. Such formulas only differ in the way
that the fragments are combined. We can therefore
approximate equivalence by using a rewrite system
that permutes fragments and defining equivalence
of configurations as mutual rewritability as usual.
By way of example, consider again the two con-
figurations shown in Fig. 1. We can obtain the sec-
ond configuration from the (semantically equiva-
lent) first one by applying the following rewrite
rule, which rotates the fragments 1 and 2:
</bodyText>
<equation confidence="0.998178">
ax(az(P,Q),R) → az(P,ax(Q,R)) (3)
</equation>
<bodyText confidence="0.970789111111111">
Thus we take these two configurations to be
equivalent with respect to the rewrite rule. (We
could also have argued that the second configura-
tion can be rewritten into the first by using the in-
verted rule.)
We formalise this rewriting-based notion of
equivalence as follows. The definition uses the ab-
breviation x[1,k) for the sequence x1,...,xk−1, and
x(k,n] for xk+1,...,xn.
</bodyText>
<listItem confidence="0.349235333333333">
Definition 3. A permutation system R is a system
of rewrite rules over the signature Σ of the follow-
ing form:
</listItem>
<equation confidence="0.9011765">
f1(x[1,i), f2(y[1,k),z,y(k,m]),x(i,n]) →
f2(y[1,k), f1(x[1,i),z,x(i,n]),y(k,m])
</equation>
<bodyText confidence="0.995620607142857">
The permutability relation P(R) is the binary rela-
tion P(R) ⊆ (Σ × 1`x)2 which contains exactly the
tuples ((f1,i),(f2,k)) and ((f2,k),(f1,i)) for each
such rewrite rule. Two terms are equivalent with re-
spect to R, s ≈R t, iff there is a sequence of rewrite
steps and inverse rewrite steps that rewrite s into t.
If G is a graph over Σ and R a permutation sys-
tem, then we write SCR(G) for the set of equiva-
lence classes Conf(G)/≈R, where Conf(G) is the
set of configurations of G.
The rewrite rule (3) above is an instance of this
schema, as are the other three permutations of ex-
istential quantifiers. These rules approximate clas-
sical semantic equivalence of first-order logic, as
they rewrite formulas into classically equivalent
ones. Indeed, all five configurations of the graph
in Fig. 1 are rewriting-equivalent to each other.
In the case of the semantic representations gen-
erated by the ERG, we don’t have access to an
underlying interpretation. But we can capture lin-
guistic intuitions about the equivalence of readings
in permutation rules. For instance, proper names
and pronouns (which the ERG analyses as scope-
bearers, although they can be reduced to constants
without scope) can be permuted with anything. In-
definites and definites permute with each other if
they occur in each other’s scope, but not if they
occur in each other’s restriction; and so on.
</bodyText>
<sectionHeader confidence="0.998216" genericHeader="method">
4 Redundancy elimination
</sectionHeader>
<bodyText confidence="0.99995575">
Given a permutation system, we can now try to get
rid of readings that are equivalent to other readings.
One way to formalise this is to enumerate exactly
one representative of each equivalence class. How-
ever, after such a step we would be left with a col-
lection of semantic representations rather than an
USR, and could not use the USR for ruling out
further readings. Besides, a naive algorithm which
</bodyText>
<page confidence="0.994013">
412
</page>
<bodyText confidence="0.999251666666667">
first enumerates all configurations would be pro-
hibitively slow.
We will instead tackle the following underspec-
ified redundancy elimination problem: Given an
USR G, compute an USR G&apos; with Conf(G&apos;) C
Conf(G) and SCR(G) = SCR(G&apos;). We want
Conf(G&apos;) to be as small as possible. Ideally, it
would contain no two equivalent readings, but in
practice we won’t always achieve this kind of com-
pleteness. Our redundancy elimination algorithm
will operate on a dominance chart and successively
delete splits and subgraphs from the chart.
</bodyText>
<subsectionHeader confidence="0.995269">
4.1 Permutable fragments
</subsectionHeader>
<bodyText confidence="0.993608071428571">
Because the algorithm must operate on USRs
rather than configurations, it needs a way to pre-
dict from the USR alone which fragments can be
permuted in configurations. This is not generally
possible in unrestricted graphs, but for hnc graphs
it is captured by the following criterion.
Definition 4. Let R be a permutation system. Two
fragments F1 and F2 with root labels f1 and f2
in a hnc graph G are called R-permutable iff
they are possible dominators of each other and
((f1,ch(F1,F2)),(f2,ch(F2,F1))) E P(R).
For example, in Fig. 1, the fragments 1 and 2
are permutable, and indeed they can be permuted
in any configuration in which one is the parent of
the other. This is true more generally:
Lemma 2 (Koller and Thater (2006)). Let G be a
hnc graph, F1 and F2 be R-permutable fragments
with root labels f1 and f2, and C1 any config-
uration of G of the form C(f1(..., f2(...),...))
(where C is the context of the subterm). Then
C1 can be R-rewritten into a tree C2 of the form
C(f2(..., f1(...),...)) which is also a configura-
tion of G.
The proof uses the hn connectedness of G in two
ways: in order to ensure that C2 is still a configu-
ration of G, and to make sure that F2 is plugged
into the correct hole of F1 for a rule application
(cf. Lemma 1). Note that C2 ^R C1 by definition.
</bodyText>
<subsectionHeader confidence="0.996554">
4.2 The redundancy elimination algorithm
</subsectionHeader>
<bodyText confidence="0.96405555">
Now we can use permutability of fragments to
define eliminable splits. Intuitively, a split of a
subgraph G is eliminable if each of its configura-
tions is equivalent to a configuration of some other
split of G. Removing such a split from the chart
will rule out some configurations; but it does not
change the set of equivalence classes.
Definition 5. Let R be a permutation system. A
split S = (F,...,hi H Gi,...) of a graph G is called
eliminable in a chart Ch if some Gi contains a frag-
ment F&apos; such that (a) Ch contains a split S&apos; of G
with root fragment F&apos;, and (b) F&apos; is R-permutable
with F and all possible dominators of F&apos; in Gi.
In Fig. 1, each of the three splits is eliminable.
For example, the split with root fragment 1 is elim-
inable because the fragment 3 permutes both with
2 (which is the only possible dominator of 3 in the
same wcc) and with 1 itself.
Proposition 3. Let Ch be a dominance chart, and
let S be an eliminable split of a hnc subgraph. Then
</bodyText>
<equation confidence="0.550959">
SC(Ch) = SC(Ch − S).
Proof. Let C be an arbitrary configuration of S =
(F,h1 H G1,...,hn H Gn), and let F&apos; E Gi be the
</equation>
<bodyText confidence="0.999476333333333">
root fragment of the assumed second split S&apos;.
Let F1,...,Fn be those fragments in C that are
properly dominated by F and properly dominate
F&apos;. All of these fragments must be possible domi-
nators of F&apos;, and all of them must be in Gi as well,
so F&apos; is permutable with each of them. F&apos; must
also be permutable with F. This means that we can
apply Lemma 2 repeatedly to move F&apos; to the root
of the configuration, obtaining a configuration of
S&apos; which is equivalent to C.
Notice that we didn’t require that Ch must be
the complete chart of a dominance graph. This
means we can remove eliminable splits from a
chart repeatedly, i.e. we can apply the following
redundancy elimination algorithm:
</bodyText>
<equation confidence="0.5168545">
REDUNDANCY-ELIMINATION(Ch,R)
1 for each split S in Ch
2 do if S is eliminable with respect to R
3 then remove S from Ch
</equation>
<bodyText confidence="0.999576769230769">
Prop. 3 shows that the algorithm is a correct
algorithm for the underspecified redundancy
elimination problem. The particular order in
which eliminable splits are removed doesn’t
affect the correctness of the algorithm, but it may
change the number of remaining configurations.
The algorithm generalises an earlier elimination
algorithm (Koller and Thater, 2006) in that the
earlier algorithm required the existence of a single
split which could be used to establish eliminability
of all other splits of the same subgraph.
We can further optimise this algorithm by keep-
ing track of how often each subgraph is referenced
</bodyText>
<page confidence="0.999405">
413
</page>
<figureCaption confidence="0.9924025">
Figure 4: A graph for which the algorithm is not
complete.
</figureCaption>
<bodyText confidence="0.998920181818182">
by the splits in the chart. Once a reference count
drops to zero, we can remove the entry for this
subgraph and all of its splits from the chart. This
doesn’t change the set of configurations of the
chart, but may further reduce the chart size. The
overall runtime for the algorithm is O(n2S), where
S is the number of splits in Ch and n is the num-
ber of nodes in the graph. This is asymptotically
not much slower than the runtime O((n+m)S) it
takes to compute the chart in the first place (where
m is the number of edges in the graph).
</bodyText>
<subsectionHeader confidence="0.999583">
4.3 Examples and discussion
</subsectionHeader>
<bodyText confidence="0.977976243902439">
Let’s look at a run of the algorithm on the chart
in Fig. 2. The algorithm can first delete the elim-
inable split with root 1 for the entire graph G. After
this deletion, the splits for G with root fragments
2 and 3 are still eliminable; so we can e.g. delete
the split for 3. At this point, only one split is left
for G. The last split for a subgraph can never be
eliminable, so we are finished with the splits for
G. This reduces the reference count of some sub-
graphs (e.g. {2,3,5,6,7}) to 0, so we can remove
these subgraphs too. The output of the algorithm is
the chart shown below, which represents a single
configuration (the one shown in Fig. 3).
{1,2,3,4,5,6,7} :h2,h2 7→ {1,4},h4 7→ {3,6,7}i
{1,4} :h1,h1 7→ {4}i
{3,6,7} :h3,h5 7→ {6},h6 7→ {7}i
In this case, the algorithm achieves complete re-
duction, in the sense that the final chart has no two
equivalent configurations. It remains complete for
all variations of the graph in Fig. 1 in which some
or all existential quantifiers are replaces by univer-
sal quantifiers. This is an improvement over our
earlier algorithm (Koller and Thater, 2006), which
computed a chart with four configurations for the
graph in which 1 and 2 are existential and 3 is uni-
versal, as opposed to the three equivalence classes
of this graph’s configurations.
However, the present algorithm still doesn’t
achieve complete reduction for all USRs. One ex-
ample is shown in Fig. 4. This graph has six config-
urations in four equivalence classes, but no split of
the whole graph is eliminable. The algorithm will
delete a split for the subgraph {1,2,4,5,7}, but the
final chart will still have five, rather than four, con-
figurations. A complete algorithm would have to
recognise that {1,3,4,6,7} and {2,3,5,6,7} have
splits (for 1 and 2, respectively) that lead to equiv-
alent configurations and delete one of them. But
it is far from obvious how such a non-local deci-
sion could be made efficiently, and we leave this
for future work.
</bodyText>
<sectionHeader confidence="0.998282" genericHeader="evaluation">
5 Evaluation
</sectionHeader>
<bodyText confidence="0.999945705882353">
In this final section, we evaluate the the effective-
ness and efficiency of the elimination algorithm:
We run it on USRs from a treebank and measure
how many readings are redundant, to what extent
the algorithm eliminates this redundancy, and how
much time it takes to do this.
Resources. The experiments are based on the
Rondane corpus, a Redwoods (Oepen et al., 2002)
style corpus which is distributed with the English
Resource Grammar (Flickinger, 2002). The cor-
pus contains analyses for 1076 sentences from the
tourism domain, which are associated with USRs
based upon Minimal Recursion Semantics (MRS).
The MRS representations are translated into dom-
inance graphs using the open-source utool tool
(Koller and Thater, 2005a), which is restricted to
MRS representations whose translations are hnc.
By restricting ourselves to such MRSs, we end up
with a data set of 999 dominance graphs. The aver-
age number of scope bearing operators in the data
set is 6.5, and the median number of readings is 56.
We then defined a (rather conservative) rewrite
system RERG for capturing the permutability rela-
tion of the quantifiers in the ERG. This amounted
to 34 rule schemata, which are automatically ex-
panded to 494 rewrite rules.
Experiment: Reduction. We first analysed the
extent to which our algorithm eliminated the re-
dundancy of the USRs in the corpus. We com-
puted dominance charts for all USRs, ran the al-
gorithm on them, and counted the number of con-
figurations of the reduced charts. We then com-
pared these numbers against a baseline and an up-
per bound. The upper bound is the true number of
</bodyText>
<figure confidence="0.973242625">
4 5 6
Ax By CZ
ay
1 2 3
ax
everyZ
Dx,y,Z
7
</figure>
<page confidence="0.766481">
414
</page>
<figure confidence="0.99942525">
0 1 2 3 4 5 6 7 8 9 10 11 12 13
log(#configurations)
0 1 2 3 4 5 6 7 8 9 10 11 12 13
log(#configurations)
100000
10000
1000
100
10
1
Factor
10000
1000
100
10
0
1
time (ms)
Full Chart Reduced Chart Enumeration
Algorithm Baseline Classes
</figure>
<figureCaption confidence="0.999948">
Figure 5: Mean reduction factor on Rondane. Figure 7: Mean runtimes.
</figureCaption>
<bodyText confidence="0.999927666666667">
equivalence classes with respect to RERC; for effi-
ciency reasons we could only compute this num-
ber for USRs with up to 500.000 configurations
(95 % of the data set). The baseline is given by
the number of readings that remain if we replace
proper names and pronouns by constants and vari-
ables, respectively. This simple heuristic is easy to
compute, and still achieves nontrivial redundancy
elimination because proper names and pronouns
are quite frequent (28% of the noun phrase occur-
rences in the data set). It also shows the degree of
non-trivial scope ambiguity in the corpus.
For each measurement, we sorted the USRs ac-
cording to the number N of configurations, and
grouped USRs according to the natural logarithm
of N (rounded down) to obtain a logarithmic scale.
First, we measured the mean reduction factor
for each log(N) class, i.e. the ratio of the num-
ber of all configurations to the number of remain-
ing configurations after redundancy elimination
(Fig. 5). The upper-bound line in the figure shows
that there is a great deal of redundancy in the USRs
in the data set. The average performance of our
algorithm is close to the upper bound and much
</bodyText>
<figure confidence="0.997287333333333">
100%
80%
60%
40%
20%
0%
</figure>
<figureCaption confidence="0.9196705">
Figure 6: Percentage of USRs for which the algo-
rithm and the baseline achieve complete reduction.
</figureCaption>
<bodyText confidence="0.999932289473684">
better than the baseline. For USRs with fewer than
e8 = 2980 configurations (83 % of the data set), the
mean reduction factor of our algorithm is above
86 % of the upper bound. The median number
of configurations for the USRs in the whole data
set is 56, and the median number of equivalence
classes is 3; again, the median number of config-
urations of the reduced charts is very close to the
upper bound, at 4 (baseline: 8). The highest reduc-
tion factor for an individual USR is 666.240.
We also measured the ratio of USRs for which
the algorithm achieves complete reduction (Fig. 6):
The algorithm is complete for 56 % of the USRs
in the data set. It is complete for 78 % of the USRs
with fewer than e5 = 148 configurations (64 % of
the data set), and still complete for 66 % of the
USRs with fewer than e8 configurations.
Experiment: Efficiency. Finally, we measured
the runtime of the elimination algorithm. The run-
time of the elimination algorithm is generally com-
parable to the runtime for computing the chart in
the first place. However, in our experiments we
used an optimised version of the elimination algo-
rithm, which computes the reduced chart directly
from a dominance graph by checking each split
for eliminability before it is added to the chart.
We compare the performance of this algorithm to
the baseline of computing the complete chart. For
comparison, we have also added the time it takes
to enumerate all configurations of the graph, as a
lower bound for any algorithm that computes the
equivalence classes based on the full set of config-
urations. Fig. 7 shows the mean runtimes for each
log(N) class, on the USRs with less than one mil-
lion configurations (958 USRs).
As the figure shows, the asymptotic runtimes
for computing the complete chart and the reduced
chart are about the same, whereas the time for
</bodyText>
<figure confidence="0.991742666666667">
0 1 2 3 4 5 6 7 8 9 10 11 12 13
log(#configurations)
Algorithm Baseline
</figure>
<page confidence="0.997878">
415
</page>
<bodyText confidence="0.999901384615385">
enumerating all configurations grows much faster.
(Note that the runtime is reported on a logarithmic
scale.) For USRs with many configurations, com-
puting the reduced chart actually takes less time
on average than computing the complete chart
because the chart-filling algorithm is called on
fewer subgraphs. While the reduced-chart algo-
rithm seems to be slower than the complete-chart
one for USRs with less than e5 configurations,
these runtimes remain below 20 milliseconds on
average, and the measurements are thus quite un-
reliable. In summary, we can say that there is no
overhead for redundancy elimination in practice.
</bodyText>
<sectionHeader confidence="0.999817" genericHeader="conclusions">
6 Conclusion
</sectionHeader>
<bodyText confidence="0.999995651162791">
We presented an algorithm for redundancy elimina-
tion on underspecified chart representations. This
algorithm successively deletes eliminable splits
from the chart, which reduces the set of described
readings while making sure that at least one rep-
resentative of each original equivalence class re-
mains. Equivalence is defined with respect to a cer-
tain class of rewriting systems; this definition ap-
proximates semantic equivalence of the described
formulas and fits well with the underspecification
setting. The algorithm runs in polynomial time in
the size of the chart.
We then evaluated the algorithm on the Ron-
dane corpus and showed that it is useful in practice:
the median number of readings drops from 56 to
4, and the maximum individual reduction factor is
666.240. The algorithm achieves complete reduc-
tion for 56% of all sentences. It does this in neg-
ligible runtime; even the most difficult sentences
in the corpus are reduced in a matter of seconds,
whereas the enumeration of all readings would
take about a year. This is the first corpus evalua-
tion of a redundancy elimination in the literature.
The algorithm improves upon previous work
(Koller and Thater, 2006) in that it eliminates more
splits from the chart. It is an improvement over ear-
lier algorithms for enumerating irredundant read-
ings (Vestre, 1991; Chaves, 2003) in that it main-
tains underspecifiedness; note that these earlier pa-
pers never made any claims with respect to, or eval-
uated, completeness.
There are a number of directions in which the
present algorithm could be improved. We are cur-
rently pursuing some ideas on how to improve the
completeness of the algorithm further. It would
also be worthwhile to explore heuristics for the or-
der in which splits of the same subgraph are elim-
inated. The present work could be extended to al-
low equivalence with respect to arbitrary rewrite
systems. Most generally, we hope that the methods
developed here will be useful for defining other
elimination algorithms, which take e.g. full world
knowledge into account.
</bodyText>
<sectionHeader confidence="0.999434" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999955956521739">
E. Althaus, D. Duchier, A. Koller, K. Mehlhorn, J. Niehren,
and S. Thiel. 2003. An efficient graph algorithm for dom-
inance constraints. Journal of Algorithms, 48:194–219.
P. Blackburn and J. Bos. 2005. Representation and Inference
for Natural Language. A First Course in Computational
Semantics. CSLI Publications.
R. P. Chaves. 2003. Non-redundant scope disambiguation
in underspecified semantics. In Proc. 8th ESSLLI Student
Session.
A. Copestake, D. Flickinger, C. Pollard, and I. Sag. 2004.
Minimal recursion semantics: An introduction. Journal of
Language and Computation. To appear.
M. Egg, A. Koller, and J. Niehren. 2001. The Constraint
Language for Lambda Structures. Logic, Language, and
Information, 10.
D. Flickinger. 2002. On building a more efficient grammar
by exploiting types. In J. Tsujii S. Oepen, D. Flickinger
and H. Uszkoreit, editors, Collaborative Language Engi-
neering. CSLI Publications, Stanford.
R. Fuchss, A. Koller, J. Niehren, and S. Thater. 2004. Mini-
mal recursion semantics as dominance constraints: Trans-
lation, evaluation, and analysis. In Proc. of the 42nd ACL.
A. Koller and S. Thater. 2005a. Efficient solving and ex-
ploration of scope ambiguities. In ACL-05 Demonstration
Notes, Ann Arbor.
A. Koller and S. Thater. 2005b. The evolution of dominance
constraint solvers. In Proceedings of the ACL-05 Work-
shop on Software, Ann Arbor.
A. Koller and S. Thater. 2006. Towards a redundancy elimi-
nation algorithm for underspecified descriptions. In Proc.
5th Intl. Workshop on Inference in Computational Seman-
tics (ICoS-5).
A. Koller, J. Niehren, and S. Thater. 2003. Bridging the gap
between underspecification formalisms: Hole semantics as
dominance constraints. In Proc. 10th EACL.
J. Niehren and S. Thater. 2003. Bridging the gap between
underspecification formalisms: Minimal recursion seman-
tics as dominance constraints. In Proc. of the 41st ACL.
S. Oepen, K. Toutanova, S. Shieber, C. Manning,
D. Flickinger, and T. Brants. 2002. The LinGO Red-
woods treebank: Motivation and preliminary applications.
In Proceedings of COLING’02.
K. van Deemter and S. Peters. 1996. Semantic Ambiguity
and Underspecification. CSLI, Stanford.
E. Vestre. 1991. An algorithm for generating non-redundant
quantifier scopings. In Proc. of the Fifth EACL, Berlin.
</reference>
<page confidence="0.998595">
416
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.534083">
<title confidence="0.999631">An Improved Redundancy Elimination Algorithm for Underspecified Representations</title>
<author confidence="0.990442">Koller Thater</author>
<affiliation confidence="0.998761">Dept. of Computational Linguistics</affiliation>
<address confidence="0.549852">Universität des Saarlandes, Saarbrücken, Germany</address>
<email confidence="0.99867">koller@coli.uni-sb.de</email>
<email confidence="0.99867">stth@coli.uni-sb.de</email>
<abstract confidence="0.998606642857143">We present an efficient algorithm for the elimination Given an underspecified semantic representation (USR) of a scope ambiguity, compute an USR with fewer mutually equivalent readings. The algorithm operates on underspecified chart representations which are derived from dominance graphs; it can be applied to the USRs computed by large-scale grammars. We evaluate the algorithm on a corpus, and show that it reduces the degree of ambiguity significantly while taking negligible runtime.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>E Althaus</author>
<author>D Duchier</author>
<author>A Koller</author>
<author>K Mehlhorn</author>
<author>J Niehren</author>
<author>S Thiel</author>
</authors>
<title>An efficient graph algorithm for dominance constraints.</title>
<date>2003</date>
<journal>Journal of Algorithms,</journal>
<pages>48--194</pages>
<contexts>
<context position="5702" citStr="Althaus et al., 2003" startWordPosition="894" endWordPosition="897">n an underspecified representation, i.e. we could no longer run other algorithms on an USR. The paper is structured as follows. We will first define dominance graphs and review the necessary background theory in Section 2. We will then introduce our notion of equivalence in Section 3, and present the redundancy elimination algorithm in Section 4. In Section 5, we describe the evaluation of the algorithm on the Rondane corpus. Finally, Section 6 concludes and points to further work. 2 Dominance graphs The basic underspecification formalism we assume here is that of (labelled) dominance graphs (Althaus et al., 2003). Dominance graphs are equivalent to leaf-labelled normal dominance constraints (Egg et al., 2001), which have been discussed extensively in previous literature. Definition 1. A (compact) dominance graph is a directed graph (V,E U+ D) with two kinds of edges, tree edges E and dominance edges D, such that: 1. The graph (V,E) defines a collection of node disjoint trees of height 0 or 1. We call the trees in (V,E) the fragments of the graph. 2. If (v,v&apos;) is a dominance edge in D, then v is a hole and v&apos; is a root. A node v is a root if v does not have incoming tree edges; otherwise, v is a hole. </context>
<context position="7972" citStr="Althaus et al., 2003" startWordPosition="1306" endWordPosition="1309"> Hypernormally connected graphs Throughout this paper, we will only consider hypernormally connected (hnc) dominance graphs. Hnc graphs are equivalent to chain-connected dominance constraints (Koller et al., 2003), and are closely related to dominance nets (Niehren and Thater, 2003). Fuchss et al. (2004) have presented a corpus study that strongly suggests that all dominance graphs that are generated by current largescale grammars are (or should be) hnc. Technically, a graph G is hypernormally connected iff each pair of nodes is connected by a simple hypernormal path in G. A hypernormal path (Althaus et al., 2003) in G is a path in the undirected version Gu of G that does not use two dominance edges that are incident to the same hole. Hnc graphs have a number of very useful structural properties on which this paper rests. One which is particularly relevant here is that we can predict in which way different fragments can dominate each other. Definition 2. Let G be a hnc dominance graph. A fragment F1 in G is called a possible dominator of another fragment F2 in G iff it has exactly one hole h which is connected to R(F2) by a simple hy410 Figure 1: A dominance graph that represents the five readings of t</context>
</contexts>
<marker>Althaus, Duchier, Koller, Mehlhorn, Niehren, Thiel, 2003</marker>
<rawString>E. Althaus, D. Duchier, A. Koller, K. Mehlhorn, J. Niehren, and S. Thiel. 2003. An efficient graph algorithm for dominance constraints. Journal of Algorithms, 48:194–219.</rawString>
</citation>
<citation valid="true">
<authors>
<author>P Blackburn</author>
<author>J Bos</author>
</authors>
<title>Representation and Inference for Natural Language. A First Course in Computational Semantics.</title>
<date>2005</date>
<publisher>CSLI Publications.</publisher>
<contexts>
<context position="972" citStr="Blackburn and Bos, 2005" startWordPosition="134" endWordPosition="137">esentation (USR) of a scope ambiguity, compute an USR with fewer mutually equivalent readings. The algorithm operates on underspecified chart representations which are derived from dominance graphs; it can be applied to the USRs computed by large-scale grammars. We evaluate the algorithm on a corpus, and show that it reduces the degree of ambiguity significantly while taking negligible runtime. 1 Introduction Underspecification is nowadays the standard approach to dealing with scope ambiguities in computational semantics (van Deemter and Peters, 1996; Copestake et al., 2004; Egg et al., 2001; Blackburn and Bos, 2005). The basic idea behind it is to not enumerate all possible semantic representations for each syntactic analysis, but to derive a single compact underspecified representation (USR). This simplifies semantics construction, and current algorithms support the efficient enumeration of the individual semantic representations from an USR (Koller and Thater, 2005b). A major promise of underspecification is that it makes it possible, in principle, to rule out entire subsets of readings that we are not interested in wholesale, without even enumerating them. For instance, real-world sentences with scope</context>
</contexts>
<marker>Blackburn, Bos, 2005</marker>
<rawString>P. Blackburn and J. Bos. 2005. Representation and Inference for Natural Language. A First Course in Computational Semantics. CSLI Publications.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R P Chaves</author>
</authors>
<title>Non-redundant scope disambiguation in underspecified semantics.</title>
<date>2003</date>
<booktitle>In Proc. 8th ESSLLI Student Session.</booktitle>
<contexts>
<context position="4944" citStr="Chaves, 2003" startWordPosition="775" endWordPosition="776">nderspecification formalisms) efficiently (Koller and Thater, 2005b). We evaluate the performance of the algorithm on the Rondane treebank and show that it reduces the median number of readings from 56 to 4, by up to a factor of 666.240 for individual USRs, while running in negligible time. To our knowledge, our algorithm and its less powerful predecessor (Koller and Thater, 2006) are the first redundancy elimination algorithms in the literature that operate on the level of USRs. There has been previous research on enumerating only some representatives of each equivalence class (Vestre, 1991; Chaves, 2003), but these approaches don’t maintain underspecification: After running their algorithms, they are left with a set of readings rather than an underspecified representation, i.e. we could no longer run other algorithms on an USR. The paper is structured as follows. We will first define dominance graphs and review the necessary background theory in Section 2. We will then introduce our notion of equivalence in Section 3, and present the redundancy elimination algorithm in Section 4. In Section 5, we describe the evaluation of the algorithm on the Rondane corpus. Finally, Section 6 concludes and </context>
<context position="30372" citStr="Chaves, 2003" startWordPosition="5246" endWordPosition="5247"> maximum individual reduction factor is 666.240. The algorithm achieves complete reduction for 56% of all sentences. It does this in negligible runtime; even the most difficult sentences in the corpus are reduced in a matter of seconds, whereas the enumeration of all readings would take about a year. This is the first corpus evaluation of a redundancy elimination in the literature. The algorithm improves upon previous work (Koller and Thater, 2006) in that it eliminates more splits from the chart. It is an improvement over earlier algorithms for enumerating irredundant readings (Vestre, 1991; Chaves, 2003) in that it maintains underspecifiedness; note that these earlier papers never made any claims with respect to, or evaluated, completeness. There are a number of directions in which the present algorithm could be improved. We are currently pursuing some ideas on how to improve the completeness of the algorithm further. It would also be worthwhile to explore heuristics for the order in which splits of the same subgraph are eliminated. The present work could be extended to allow equivalence with respect to arbitrary rewrite systems. Most generally, we hope that the methods developed here will be</context>
</contexts>
<marker>Chaves, 2003</marker>
<rawString>R. P. Chaves. 2003. Non-redundant scope disambiguation in underspecified semantics. In Proc. 8th ESSLLI Student Session.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Copestake</author>
<author>D Flickinger</author>
<author>C Pollard</author>
<author>I Sag</author>
</authors>
<title>Minimal recursion semantics: An introduction.</title>
<date>2004</date>
<journal>Journal of Language and Computation.</journal>
<note>To appear.</note>
<contexts>
<context position="928" citStr="Copestake et al., 2004" startWordPosition="126" endWordPosition="129">lem: Given an underspecified semantic representation (USR) of a scope ambiguity, compute an USR with fewer mutually equivalent readings. The algorithm operates on underspecified chart representations which are derived from dominance graphs; it can be applied to the USRs computed by large-scale grammars. We evaluate the algorithm on a corpus, and show that it reduces the degree of ambiguity significantly while taking negligible runtime. 1 Introduction Underspecification is nowadays the standard approach to dealing with scope ambiguities in computational semantics (van Deemter and Peters, 1996; Copestake et al., 2004; Egg et al., 2001; Blackburn and Bos, 2005). The basic idea behind it is to not enumerate all possible semantic representations for each syntactic analysis, but to derive a single compact underspecified representation (USR). This simplifies semantics construction, and current algorithms support the efficient enumeration of the individual semantic representations from an USR (Koller and Thater, 2005b). A major promise of underspecification is that it makes it possible, in principle, to rule out entire subsets of readings that we are not interested in wholesale, without even enumerating them. F</context>
</contexts>
<marker>Copestake, Flickinger, Pollard, Sag, 2004</marker>
<rawString>A. Copestake, D. Flickinger, C. Pollard, and I. Sag. 2004. Minimal recursion semantics: An introduction. Journal of Language and Computation. To appear.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Egg</author>
<author>A Koller</author>
<author>J Niehren</author>
</authors>
<title>The Constraint Language for Lambda Structures.</title>
<date>2001</date>
<journal>Logic, Language, and Information,</journal>
<volume>10</volume>
<contexts>
<context position="946" citStr="Egg et al., 2001" startWordPosition="130" endWordPosition="133">fied semantic representation (USR) of a scope ambiguity, compute an USR with fewer mutually equivalent readings. The algorithm operates on underspecified chart representations which are derived from dominance graphs; it can be applied to the USRs computed by large-scale grammars. We evaluate the algorithm on a corpus, and show that it reduces the degree of ambiguity significantly while taking negligible runtime. 1 Introduction Underspecification is nowadays the standard approach to dealing with scope ambiguities in computational semantics (van Deemter and Peters, 1996; Copestake et al., 2004; Egg et al., 2001; Blackburn and Bos, 2005). The basic idea behind it is to not enumerate all possible semantic representations for each syntactic analysis, but to derive a single compact underspecified representation (USR). This simplifies semantics construction, and current algorithms support the efficient enumeration of the individual semantic representations from an USR (Koller and Thater, 2005b). A major promise of underspecification is that it makes it possible, in principle, to rule out entire subsets of readings that we are not interested in wholesale, without even enumerating them. For instance, real-</context>
<context position="5800" citStr="Egg et al., 2001" startWordPosition="908" endWordPosition="911">is structured as follows. We will first define dominance graphs and review the necessary background theory in Section 2. We will then introduce our notion of equivalence in Section 3, and present the redundancy elimination algorithm in Section 4. In Section 5, we describe the evaluation of the algorithm on the Rondane corpus. Finally, Section 6 concludes and points to further work. 2 Dominance graphs The basic underspecification formalism we assume here is that of (labelled) dominance graphs (Althaus et al., 2003). Dominance graphs are equivalent to leaf-labelled normal dominance constraints (Egg et al., 2001), which have been discussed extensively in previous literature. Definition 1. A (compact) dominance graph is a directed graph (V,E U+ D) with two kinds of edges, tree edges E and dominance edges D, such that: 1. The graph (V,E) defines a collection of node disjoint trees of height 0 or 1. We call the trees in (V,E) the fragments of the graph. 2. If (v,v&apos;) is a dominance edge in D, then v is a hole and v&apos; is a root. A node v is a root if v does not have incoming tree edges; otherwise, v is a hole. A labelled dominance graph over a ranked signature Σ is a triple G = (V,E U+ D,L) such that (V,E U</context>
</contexts>
<marker>Egg, Koller, Niehren, 2001</marker>
<rawString>M. Egg, A. Koller, and J. Niehren. 2001. The Constraint Language for Lambda Structures. Logic, Language, and Information, 10.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D Flickinger</author>
</authors>
<title>On building a more efficient grammar by exploiting types.</title>
<date>2002</date>
<editor>In J. Tsujii S. Oepen, D. Flickinger and H. Uszkoreit, editors,</editor>
<publisher>CSLI Publications, Stanford.</publisher>
<contexts>
<context position="1981" citStr="Flickinger (2002)" startWordPosition="290" endWordPosition="291">ication is that it makes it possible, in principle, to rule out entire subsets of readings that we are not interested in wholesale, without even enumerating them. For instance, real-world sentences with scope ambiguities often have many readings that are semantically equivalent. Subsequent modules (e.g. for doing inference) will typically only be interested in one reading from each equivalence class, and all others could be deleted. This situation is illustrated by the following two (out of many) sentences from the Rondane treebank, which is distributed with the English Resource Grammar (ERG; Flickinger (2002)), a large-scale HPSG grammar of English. (1) For travellers going to Finnmark there is a bus service from Oslo to Alta through Sweden. (Rondane 1262) (2) We quickly put up the tents in the lee of a small hillside and cook for the first time in the open. (Rondane 892) For the annotated syntactic analysis of (1), the ERG derives an USR with eight scope bearing operators, which results in a total of 3960 readings. These readings are all semantically equivalent to each other. On the other hand, the USR for (2) has 480 readings, which fall into two classes of mutually equivalent readings, characte</context>
<context position="23720" citStr="Flickinger, 2002" startWordPosition="4094" endWordPosition="4095">tions and delete one of them. But it is far from obvious how such a non-local decision could be made efficiently, and we leave this for future work. 5 Evaluation In this final section, we evaluate the the effectiveness and efficiency of the elimination algorithm: We run it on USRs from a treebank and measure how many readings are redundant, to what extent the algorithm eliminates this redundancy, and how much time it takes to do this. Resources. The experiments are based on the Rondane corpus, a Redwoods (Oepen et al., 2002) style corpus which is distributed with the English Resource Grammar (Flickinger, 2002). The corpus contains analyses for 1076 sentences from the tourism domain, which are associated with USRs based upon Minimal Recursion Semantics (MRS). The MRS representations are translated into dominance graphs using the open-source utool tool (Koller and Thater, 2005a), which is restricted to MRS representations whose translations are hnc. By restricting ourselves to such MRSs, we end up with a data set of 999 dominance graphs. The average number of scope bearing operators in the data set is 6.5, and the median number of readings is 56. We then defined a (rather conservative) rewrite system</context>
</contexts>
<marker>Flickinger, 2002</marker>
<rawString>D. Flickinger. 2002. On building a more efficient grammar by exploiting types. In J. Tsujii S. Oepen, D. Flickinger and H. Uszkoreit, editors, Collaborative Language Engineering. CSLI Publications, Stanford.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Fuchss</author>
<author>A Koller</author>
<author>J Niehren</author>
<author>S Thater</author>
</authors>
<title>Minimal recursion semantics as dominance constraints: Translation, evaluation, and analysis.</title>
<date>2004</date>
<booktitle>In Proc. of the 42nd ACL.</booktitle>
<contexts>
<context position="7656" citStr="Fuchss et al. (2004)" startWordPosition="1250" endWordPosition="1253">demand that the holes are “plugged” by roots while realising the dominance edges as dominance, as in the two configurations (of five) shown to the right. These configurations are trees that encode semantic representations of the sentence. We will freely read configurations as ground terms over the signature Σ. 2.1 Hypernormally connected graphs Throughout this paper, we will only consider hypernormally connected (hnc) dominance graphs. Hnc graphs are equivalent to chain-connected dominance constraints (Koller et al., 2003), and are closely related to dominance nets (Niehren and Thater, 2003). Fuchss et al. (2004) have presented a corpus study that strongly suggests that all dominance graphs that are generated by current largescale grammars are (or should be) hnc. Technically, a graph G is hypernormally connected iff each pair of nodes is connected by a simple hypernormal path in G. A hypernormal path (Althaus et al., 2003) in G is a path in the undirected version Gu of G that does not use two dominance edges that are incident to the same hole. Hnc graphs have a number of very useful structural properties on which this paper rests. One which is particularly relevant here is that we can predict in which</context>
</contexts>
<marker>Fuchss, Koller, Niehren, Thater, 2004</marker>
<rawString>R. Fuchss, A. Koller, J. Niehren, and S. Thater. 2004. Minimal recursion semantics as dominance constraints: Translation, evaluation, and analysis. In Proc. of the 42nd ACL.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Koller</author>
<author>S Thater</author>
</authors>
<title>Efficient solving and exploration of scope ambiguities.</title>
<date>2005</date>
<booktitle>In ACL-05 Demonstration Notes,</booktitle>
<location>Ann Arbor.</location>
<contexts>
<context position="1330" citStr="Koller and Thater, 2005" startWordPosition="187" endWordPosition="190">antly while taking negligible runtime. 1 Introduction Underspecification is nowadays the standard approach to dealing with scope ambiguities in computational semantics (van Deemter and Peters, 1996; Copestake et al., 2004; Egg et al., 2001; Blackburn and Bos, 2005). The basic idea behind it is to not enumerate all possible semantic representations for each syntactic analysis, but to derive a single compact underspecified representation (USR). This simplifies semantics construction, and current algorithms support the efficient enumeration of the individual semantic representations from an USR (Koller and Thater, 2005b). A major promise of underspecification is that it makes it possible, in principle, to rule out entire subsets of readings that we are not interested in wholesale, without even enumerating them. For instance, real-world sentences with scope ambiguities often have many readings that are semantically equivalent. Subsequent modules (e.g. for doing inference) will typically only be interested in one reading from each equivalence class, and all others could be deleted. This situation is illustrated by the following two (out of many) sentences from the Rondane treebank, which is distributed with t</context>
<context position="4397" citStr="Koller and Thater, 2005" startWordPosition="685" endWordPosition="688"> Proceedings of the 21st International Conference on Computational Linguistics and 44th Annual Meeting of the ACL, pages 409–416, Sydney, July 2006. c�2006 Association for Computational Linguistics inites), which have been a ubiquitous problem in most theories of scope since Montague Grammar. We model equivalence in terms of rewrite rules that permute quantifiers without changing the semantics of the readings. The particular USRs we work with are underspecified chart representations, which can be computed from dominance graphs (or USRs in some other underspecification formalisms) efficiently (Koller and Thater, 2005b). We evaluate the performance of the algorithm on the Rondane treebank and show that it reduces the median number of readings from 56 to 4, by up to a factor of 666.240 for individual USRs, while running in negligible time. To our knowledge, our algorithm and its less powerful predecessor (Koller and Thater, 2006) are the first redundancy elimination algorithms in the literature that operate on the level of USRs. There has been previous research on enumerating only some representatives of each equivalence class (Vestre, 1991; Chaves, 2003), but these approaches don’t maintain underspecificat</context>
<context position="10176" citStr="Koller and Thater, 2005" startWordPosition="1718" endWordPosition="1721">sult, we can derive a number of interesting facts about the example graph in Fig. 1. The fragments 1, 2, and 3 are possible dominators of all other fragments (and of each other), while the fragments 4 through 7 aren’t possible dominators of anything (they have no holes); so 4 through 7 must be leaves in any configuration of the graph. In addition, if fragment 2 dominates fragment 3 in any configuration, then in particular the right hole of 2 will dominate the root of 3; and so on. 2.2 Dominance charts Below we will not work with dominance graphs directly. Rather, we will use dominance charts (Koller and Thater, 2005b) as our USRs: they are more explicit USRs, which support a more finegrained deletion of reading sets than graphs. A dominance chart for the graph G is a mapping of weakly connected subgraphs of G to sets of splits (see Fig. 2), which describe possible ways of constructing configurations of the subgraph. A subgraph G&apos; is assigned one split for each fragment F in G&apos; which can be at the root of a configuration of G&apos;. If the graph is hnc, removing F from the graph splits G&apos; into a set of weakly connected components (wccs), each of which is connected to exactly one hole of F. We also record the w</context>
<context position="11574" citStr="Koller and Thater, 2005" startWordPosition="1965" endWordPosition="1968">f each component; then we plug each combination of these subconfigurations into the appropriate holes of the root fragment. We define the configurations associated with a subgraph as the union over its splits, and those of the entire chart as the configurations associated with the complete graph. Fig. 2 shows the dominance chart corresponding to the graph in Fig. 1. The chart represents exactly the configuration set of the graph, and is minimal in the sense that every subgraph and every split in the chart can be used in constructing some configuration. Such charts can be computed efficiently (Koller and Thater, 2005b) from a dominance graph, and can also be used to compute the configurations of a graph efficiently. The example chart expresses that three fragments can be at the root of a configuration of the complete graph: 1, 2, and 3. The entry for the split with root fragment 2 tells us that removing 2 splits the graph into the subgraphs 11,4,5} and 13,6,7} (see Fig. 3). If we configure these two subgraphs recursively, we obtain the configurations shown in the third column of Fig. 3; we can then plug these sub-configurations into the appropriate holes of 2 and obtain a configuration for the entire grap</context>
<context position="23990" citStr="Koller and Thater, 2005" startWordPosition="4133" endWordPosition="4136">We run it on USRs from a treebank and measure how many readings are redundant, to what extent the algorithm eliminates this redundancy, and how much time it takes to do this. Resources. The experiments are based on the Rondane corpus, a Redwoods (Oepen et al., 2002) style corpus which is distributed with the English Resource Grammar (Flickinger, 2002). The corpus contains analyses for 1076 sentences from the tourism domain, which are associated with USRs based upon Minimal Recursion Semantics (MRS). The MRS representations are translated into dominance graphs using the open-source utool tool (Koller and Thater, 2005a), which is restricted to MRS representations whose translations are hnc. By restricting ourselves to such MRSs, we end up with a data set of 999 dominance graphs. The average number of scope bearing operators in the data set is 6.5, and the median number of readings is 56. We then defined a (rather conservative) rewrite system RERG for capturing the permutability relation of the quantifiers in the ERG. This amounted to 34 rule schemata, which are automatically expanded to 494 rewrite rules. Experiment: Reduction. We first analysed the extent to which our algorithm eliminated the redundancy o</context>
</contexts>
<marker>Koller, Thater, 2005</marker>
<rawString>A. Koller and S. Thater. 2005a. Efficient solving and exploration of scope ambiguities. In ACL-05 Demonstration Notes, Ann Arbor.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Koller</author>
<author>S Thater</author>
</authors>
<title>The evolution of dominance constraint solvers.</title>
<date>2005</date>
<booktitle>In Proceedings of the ACL-05 Workshop on Software,</booktitle>
<location>Ann Arbor.</location>
<contexts>
<context position="1330" citStr="Koller and Thater, 2005" startWordPosition="187" endWordPosition="190">antly while taking negligible runtime. 1 Introduction Underspecification is nowadays the standard approach to dealing with scope ambiguities in computational semantics (van Deemter and Peters, 1996; Copestake et al., 2004; Egg et al., 2001; Blackburn and Bos, 2005). The basic idea behind it is to not enumerate all possible semantic representations for each syntactic analysis, but to derive a single compact underspecified representation (USR). This simplifies semantics construction, and current algorithms support the efficient enumeration of the individual semantic representations from an USR (Koller and Thater, 2005b). A major promise of underspecification is that it makes it possible, in principle, to rule out entire subsets of readings that we are not interested in wholesale, without even enumerating them. For instance, real-world sentences with scope ambiguities often have many readings that are semantically equivalent. Subsequent modules (e.g. for doing inference) will typically only be interested in one reading from each equivalence class, and all others could be deleted. This situation is illustrated by the following two (out of many) sentences from the Rondane treebank, which is distributed with t</context>
<context position="4397" citStr="Koller and Thater, 2005" startWordPosition="685" endWordPosition="688"> Proceedings of the 21st International Conference on Computational Linguistics and 44th Annual Meeting of the ACL, pages 409–416, Sydney, July 2006. c�2006 Association for Computational Linguistics inites), which have been a ubiquitous problem in most theories of scope since Montague Grammar. We model equivalence in terms of rewrite rules that permute quantifiers without changing the semantics of the readings. The particular USRs we work with are underspecified chart representations, which can be computed from dominance graphs (or USRs in some other underspecification formalisms) efficiently (Koller and Thater, 2005b). We evaluate the performance of the algorithm on the Rondane treebank and show that it reduces the median number of readings from 56 to 4, by up to a factor of 666.240 for individual USRs, while running in negligible time. To our knowledge, our algorithm and its less powerful predecessor (Koller and Thater, 2006) are the first redundancy elimination algorithms in the literature that operate on the level of USRs. There has been previous research on enumerating only some representatives of each equivalence class (Vestre, 1991; Chaves, 2003), but these approaches don’t maintain underspecificat</context>
<context position="10176" citStr="Koller and Thater, 2005" startWordPosition="1718" endWordPosition="1721">sult, we can derive a number of interesting facts about the example graph in Fig. 1. The fragments 1, 2, and 3 are possible dominators of all other fragments (and of each other), while the fragments 4 through 7 aren’t possible dominators of anything (they have no holes); so 4 through 7 must be leaves in any configuration of the graph. In addition, if fragment 2 dominates fragment 3 in any configuration, then in particular the right hole of 2 will dominate the root of 3; and so on. 2.2 Dominance charts Below we will not work with dominance graphs directly. Rather, we will use dominance charts (Koller and Thater, 2005b) as our USRs: they are more explicit USRs, which support a more finegrained deletion of reading sets than graphs. A dominance chart for the graph G is a mapping of weakly connected subgraphs of G to sets of splits (see Fig. 2), which describe possible ways of constructing configurations of the subgraph. A subgraph G&apos; is assigned one split for each fragment F in G&apos; which can be at the root of a configuration of G&apos;. If the graph is hnc, removing F from the graph splits G&apos; into a set of weakly connected components (wccs), each of which is connected to exactly one hole of F. We also record the w</context>
<context position="11574" citStr="Koller and Thater, 2005" startWordPosition="1965" endWordPosition="1968">f each component; then we plug each combination of these subconfigurations into the appropriate holes of the root fragment. We define the configurations associated with a subgraph as the union over its splits, and those of the entire chart as the configurations associated with the complete graph. Fig. 2 shows the dominance chart corresponding to the graph in Fig. 1. The chart represents exactly the configuration set of the graph, and is minimal in the sense that every subgraph and every split in the chart can be used in constructing some configuration. Such charts can be computed efficiently (Koller and Thater, 2005b) from a dominance graph, and can also be used to compute the configurations of a graph efficiently. The example chart expresses that three fragments can be at the root of a configuration of the complete graph: 1, 2, and 3. The entry for the split with root fragment 2 tells us that removing 2 splits the graph into the subgraphs 11,4,5} and 13,6,7} (see Fig. 3). If we configure these two subgraphs recursively, we obtain the configurations shown in the third column of Fig. 3; we can then plug these sub-configurations into the appropriate holes of 2 and obtain a configuration for the entire grap</context>
<context position="23990" citStr="Koller and Thater, 2005" startWordPosition="4133" endWordPosition="4136">We run it on USRs from a treebank and measure how many readings are redundant, to what extent the algorithm eliminates this redundancy, and how much time it takes to do this. Resources. The experiments are based on the Rondane corpus, a Redwoods (Oepen et al., 2002) style corpus which is distributed with the English Resource Grammar (Flickinger, 2002). The corpus contains analyses for 1076 sentences from the tourism domain, which are associated with USRs based upon Minimal Recursion Semantics (MRS). The MRS representations are translated into dominance graphs using the open-source utool tool (Koller and Thater, 2005a), which is restricted to MRS representations whose translations are hnc. By restricting ourselves to such MRSs, we end up with a data set of 999 dominance graphs. The average number of scope bearing operators in the data set is 6.5, and the median number of readings is 56. We then defined a (rather conservative) rewrite system RERG for capturing the permutability relation of the quantifiers in the ERG. This amounted to 34 rule schemata, which are automatically expanded to 494 rewrite rules. Experiment: Reduction. We first analysed the extent to which our algorithm eliminated the redundancy o</context>
</contexts>
<marker>Koller, Thater, 2005</marker>
<rawString>A. Koller and S. Thater. 2005b. The evolution of dominance constraint solvers. In Proceedings of the ACL-05 Workshop on Software, Ann Arbor.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Koller</author>
<author>S Thater</author>
</authors>
<title>Towards a redundancy elimination algorithm for underspecified descriptions.</title>
<date>2006</date>
<booktitle>In Proc. 5th Intl. Workshop on Inference in Computational Semantics (ICoS-5).</booktitle>
<contexts>
<context position="4714" citStr="Koller and Thater, 2006" startWordPosition="739" endWordPosition="742">n terms of rewrite rules that permute quantifiers without changing the semantics of the readings. The particular USRs we work with are underspecified chart representations, which can be computed from dominance graphs (or USRs in some other underspecification formalisms) efficiently (Koller and Thater, 2005b). We evaluate the performance of the algorithm on the Rondane treebank and show that it reduces the median number of readings from 56 to 4, by up to a factor of 666.240 for individual USRs, while running in negligible time. To our knowledge, our algorithm and its less powerful predecessor (Koller and Thater, 2006) are the first redundancy elimination algorithms in the literature that operate on the level of USRs. There has been previous research on enumerating only some representatives of each equivalence class (Vestre, 1991; Chaves, 2003), but these approaches don’t maintain underspecification: After running their algorithms, they are left with a set of readings rather than an underspecified representation, i.e. we could no longer run other algorithms on an USR. The paper is structured as follows. We will first define dominance graphs and review the necessary background theory in Section 2. We will th</context>
<context position="9307" citStr="Koller and Thater (2006)" startWordPosition="1560" endWordPosition="1563">x,y seex,y ax repr-ofx,z ay sampley 7 ax az compz repr-ofx,z sampley seex,y az 2 compz repr-ofx,z az compz 1 2 3 4 5 6 2 1 ay 3 1 ax 3 ay 11,2,3,4,5,6,7} :(1,h1 H 14},h2 H 12,3,5,6,7}) (2,h3 H 11,4,5},h4 H 13,6,7}) (3,h5 H 15},h6 H 11,2,4,5,7}) 12,3,5,6,7} :(2,h3 H 15},h4 H 13,6,7}) (3,h5 H 16},h6 H 12,5,7}) 13,6,7} :(3,h5 H 16},h6 H 17}) 12,5,7} :(2,h3 H 15},h4 H 17}) 11,4,5} :(1,h1 H 14},h2 H 15}) 11,2,4,5,7} :(1,h1 H 14},h2 H 12,5,7}) (2,h3 H 11,4,5},h4 H 17}) Figure 2: The chart for the graph in Fig. 1. pernormal path which doesn’t use R(F1). We write ch(F1,F2) for this unique h. Lemma 1 (Koller and Thater (2006)). Let F1, F2 be fragments in a hnc dominance graph G. If there is a configuration C of G in which R(F1) dominates R(F2), then F1 is a possible dominator of F2, and in particular ch(F1,F2) dominates R(F2) in C. By applying this rather abstract result, we can derive a number of interesting facts about the example graph in Fig. 1. The fragments 1, 2, and 3 are possible dominators of all other fragments (and of each other), while the fragments 4 through 7 aren’t possible dominators of anything (they have no holes); so 4 through 7 must be leaves in any configuration of the graph. In addition, if f</context>
<context position="17545" citStr="Koller and Thater (2006)" startWordPosition="2972" endWordPosition="2975">USR alone which fragments can be permuted in configurations. This is not generally possible in unrestricted graphs, but for hnc graphs it is captured by the following criterion. Definition 4. Let R be a permutation system. Two fragments F1 and F2 with root labels f1 and f2 in a hnc graph G are called R-permutable iff they are possible dominators of each other and ((f1,ch(F1,F2)),(f2,ch(F2,F1))) E P(R). For example, in Fig. 1, the fragments 1 and 2 are permutable, and indeed they can be permuted in any configuration in which one is the parent of the other. This is true more generally: Lemma 2 (Koller and Thater (2006)). Let G be a hnc graph, F1 and F2 be R-permutable fragments with root labels f1 and f2, and C1 any configuration of G of the form C(f1(..., f2(...),...)) (where C is the context of the subterm). Then C1 can be R-rewritten into a tree C2 of the form C(f2(..., f1(...),...)) which is also a configuration of G. The proof uses the hn connectedness of G in two ways: in order to ensure that C2 is still a configuration of G, and to make sure that F2 is plugged into the correct hole of F1 for a rule application (cf. Lemma 1). Note that C2 ^R C1 by definition. 4.2 The redundancy elimination algorithm N</context>
<context position="20401" citStr="Koller and Thater, 2006" startWordPosition="3504" endWordPosition="3507"> graph. This means we can remove eliminable splits from a chart repeatedly, i.e. we can apply the following redundancy elimination algorithm: REDUNDANCY-ELIMINATION(Ch,R) 1 for each split S in Ch 2 do if S is eliminable with respect to R 3 then remove S from Ch Prop. 3 shows that the algorithm is a correct algorithm for the underspecified redundancy elimination problem. The particular order in which eliminable splits are removed doesn’t affect the correctness of the algorithm, but it may change the number of remaining configurations. The algorithm generalises an earlier elimination algorithm (Koller and Thater, 2006) in that the earlier algorithm required the existence of a single split which could be used to establish eliminability of all other splits of the same subgraph. We can further optimise this algorithm by keeping track of how often each subgraph is referenced 413 Figure 4: A graph for which the algorithm is not complete. by the splits in the chart. Once a reference count drops to zero, we can remove the entry for this subgraph and all of its splits from the chart. This doesn’t change the set of configurations of the chart, but may further reduce the chart size. The overall runtime for the algori</context>
<context position="22391" citStr="Koller and Thater, 2006" startWordPosition="3868" endWordPosition="3871">5,6,7}) to 0, so we can remove these subgraphs too. The output of the algorithm is the chart shown below, which represents a single configuration (the one shown in Fig. 3). {1,2,3,4,5,6,7} :h2,h2 7→ {1,4},h4 7→ {3,6,7}i {1,4} :h1,h1 7→ {4}i {3,6,7} :h3,h5 7→ {6},h6 7→ {7}i In this case, the algorithm achieves complete reduction, in the sense that the final chart has no two equivalent configurations. It remains complete for all variations of the graph in Fig. 1 in which some or all existential quantifiers are replaces by universal quantifiers. This is an improvement over our earlier algorithm (Koller and Thater, 2006), which computed a chart with four configurations for the graph in which 1 and 2 are existential and 3 is universal, as opposed to the three equivalence classes of this graph’s configurations. However, the present algorithm still doesn’t achieve complete reduction for all USRs. One example is shown in Fig. 4. This graph has six configurations in four equivalence classes, but no split of the whole graph is eliminable. The algorithm will delete a split for the subgraph {1,2,4,5,7}, but the final chart will still have five, rather than four, configurations. A complete algorithm would have to reco</context>
<context position="30211" citStr="Koller and Thater, 2006" startWordPosition="5218" endWordPosition="5221">size of the chart. We then evaluated the algorithm on the Rondane corpus and showed that it is useful in practice: the median number of readings drops from 56 to 4, and the maximum individual reduction factor is 666.240. The algorithm achieves complete reduction for 56% of all sentences. It does this in negligible runtime; even the most difficult sentences in the corpus are reduced in a matter of seconds, whereas the enumeration of all readings would take about a year. This is the first corpus evaluation of a redundancy elimination in the literature. The algorithm improves upon previous work (Koller and Thater, 2006) in that it eliminates more splits from the chart. It is an improvement over earlier algorithms for enumerating irredundant readings (Vestre, 1991; Chaves, 2003) in that it maintains underspecifiedness; note that these earlier papers never made any claims with respect to, or evaluated, completeness. There are a number of directions in which the present algorithm could be improved. We are currently pursuing some ideas on how to improve the completeness of the algorithm further. It would also be worthwhile to explore heuristics for the order in which splits of the same subgraph are eliminated. T</context>
</contexts>
<marker>Koller, Thater, 2006</marker>
<rawString>A. Koller and S. Thater. 2006. Towards a redundancy elimination algorithm for underspecified descriptions. In Proc. 5th Intl. Workshop on Inference in Computational Semantics (ICoS-5).</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Koller</author>
<author>J Niehren</author>
<author>S Thater</author>
</authors>
<title>Bridging the gap between underspecification formalisms: Hole semantics as dominance constraints.</title>
<date>2003</date>
<booktitle>In Proc. 10th EACL.</booktitle>
<contexts>
<context position="7564" citStr="Koller et al., 2003" startWordPosition="1235" endWordPosition="1238">aph can serve as an USR for the sentence “a representative of a company saw a sample” if we demand that the holes are “plugged” by roots while realising the dominance edges as dominance, as in the two configurations (of five) shown to the right. These configurations are trees that encode semantic representations of the sentence. We will freely read configurations as ground terms over the signature Σ. 2.1 Hypernormally connected graphs Throughout this paper, we will only consider hypernormally connected (hnc) dominance graphs. Hnc graphs are equivalent to chain-connected dominance constraints (Koller et al., 2003), and are closely related to dominance nets (Niehren and Thater, 2003). Fuchss et al. (2004) have presented a corpus study that strongly suggests that all dominance graphs that are generated by current largescale grammars are (or should be) hnc. Technically, a graph G is hypernormally connected iff each pair of nodes is connected by a simple hypernormal path in G. A hypernormal path (Althaus et al., 2003) in G is a path in the undirected version Gu of G that does not use two dominance edges that are incident to the same hole. Hnc graphs have a number of very useful structural properties on whi</context>
</contexts>
<marker>Koller, Niehren, Thater, 2003</marker>
<rawString>A. Koller, J. Niehren, and S. Thater. 2003. Bridging the gap between underspecification formalisms: Hole semantics as dominance constraints. In Proc. 10th EACL.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Niehren</author>
<author>S Thater</author>
</authors>
<title>Bridging the gap between underspecification formalisms: Minimal recursion semantics as dominance constraints.</title>
<date>2003</date>
<booktitle>In Proc. of the 41st ACL.</booktitle>
<contexts>
<context position="7634" citStr="Niehren and Thater, 2003" startWordPosition="1246" endWordPosition="1249">ompany saw a sample” if we demand that the holes are “plugged” by roots while realising the dominance edges as dominance, as in the two configurations (of five) shown to the right. These configurations are trees that encode semantic representations of the sentence. We will freely read configurations as ground terms over the signature Σ. 2.1 Hypernormally connected graphs Throughout this paper, we will only consider hypernormally connected (hnc) dominance graphs. Hnc graphs are equivalent to chain-connected dominance constraints (Koller et al., 2003), and are closely related to dominance nets (Niehren and Thater, 2003). Fuchss et al. (2004) have presented a corpus study that strongly suggests that all dominance graphs that are generated by current largescale grammars are (or should be) hnc. Technically, a graph G is hypernormally connected iff each pair of nodes is connected by a simple hypernormal path in G. A hypernormal path (Althaus et al., 2003) in G is a path in the undirected version Gu of G that does not use two dominance edges that are incident to the same hole. Hnc graphs have a number of very useful structural properties on which this paper rests. One which is particularly relevant here is that w</context>
</contexts>
<marker>Niehren, Thater, 2003</marker>
<rawString>J. Niehren and S. Thater. 2003. Bridging the gap between underspecification formalisms: Minimal recursion semantics as dominance constraints. In Proc. of the 41st ACL.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S Oepen</author>
<author>K Toutanova</author>
<author>S Shieber</author>
<author>C Manning</author>
<author>D Flickinger</author>
<author>T Brants</author>
</authors>
<title>The LinGO Redwoods treebank: Motivation and preliminary applications.</title>
<date>2002</date>
<booktitle>In Proceedings of COLING’02.</booktitle>
<contexts>
<context position="23633" citStr="Oepen et al., 2002" startWordPosition="4080" endWordPosition="4083">and {2,3,5,6,7} have splits (for 1 and 2, respectively) that lead to equivalent configurations and delete one of them. But it is far from obvious how such a non-local decision could be made efficiently, and we leave this for future work. 5 Evaluation In this final section, we evaluate the the effectiveness and efficiency of the elimination algorithm: We run it on USRs from a treebank and measure how many readings are redundant, to what extent the algorithm eliminates this redundancy, and how much time it takes to do this. Resources. The experiments are based on the Rondane corpus, a Redwoods (Oepen et al., 2002) style corpus which is distributed with the English Resource Grammar (Flickinger, 2002). The corpus contains analyses for 1076 sentences from the tourism domain, which are associated with USRs based upon Minimal Recursion Semantics (MRS). The MRS representations are translated into dominance graphs using the open-source utool tool (Koller and Thater, 2005a), which is restricted to MRS representations whose translations are hnc. By restricting ourselves to such MRSs, we end up with a data set of 999 dominance graphs. The average number of scope bearing operators in the data set is 6.5, and the </context>
</contexts>
<marker>Oepen, Toutanova, Shieber, Manning, Flickinger, Brants, 2002</marker>
<rawString>S. Oepen, K. Toutanova, S. Shieber, C. Manning, D. Flickinger, and T. Brants. 2002. The LinGO Redwoods treebank: Motivation and preliminary applications. In Proceedings of COLING’02.</rawString>
</citation>
<citation valid="true">
<authors>
<author>K van Deemter</author>
<author>S Peters</author>
</authors>
<title>Semantic Ambiguity and Underspecification.</title>
<date>1996</date>
<location>CSLI, Stanford.</location>
<marker>van Deemter, Peters, 1996</marker>
<rawString>K. van Deemter and S. Peters. 1996. Semantic Ambiguity and Underspecification. CSLI, Stanford.</rawString>
</citation>
<citation valid="true">
<authors>
<author>E Vestre</author>
</authors>
<title>An algorithm for generating non-redundant quantifier scopings.</title>
<date>1991</date>
<booktitle>In Proc. of the Fifth EACL,</booktitle>
<location>Berlin.</location>
<contexts>
<context position="4929" citStr="Vestre, 1991" startWordPosition="773" endWordPosition="774">n some other underspecification formalisms) efficiently (Koller and Thater, 2005b). We evaluate the performance of the algorithm on the Rondane treebank and show that it reduces the median number of readings from 56 to 4, by up to a factor of 666.240 for individual USRs, while running in negligible time. To our knowledge, our algorithm and its less powerful predecessor (Koller and Thater, 2006) are the first redundancy elimination algorithms in the literature that operate on the level of USRs. There has been previous research on enumerating only some representatives of each equivalence class (Vestre, 1991; Chaves, 2003), but these approaches don’t maintain underspecification: After running their algorithms, they are left with a set of readings rather than an underspecified representation, i.e. we could no longer run other algorithms on an USR. The paper is structured as follows. We will first define dominance graphs and review the necessary background theory in Section 2. We will then introduce our notion of equivalence in Section 3, and present the redundancy elimination algorithm in Section 4. In Section 5, we describe the evaluation of the algorithm on the Rondane corpus. Finally, Section 6</context>
<context position="30357" citStr="Vestre, 1991" startWordPosition="5244" endWordPosition="5245"> to 4, and the maximum individual reduction factor is 666.240. The algorithm achieves complete reduction for 56% of all sentences. It does this in negligible runtime; even the most difficult sentences in the corpus are reduced in a matter of seconds, whereas the enumeration of all readings would take about a year. This is the first corpus evaluation of a redundancy elimination in the literature. The algorithm improves upon previous work (Koller and Thater, 2006) in that it eliminates more splits from the chart. It is an improvement over earlier algorithms for enumerating irredundant readings (Vestre, 1991; Chaves, 2003) in that it maintains underspecifiedness; note that these earlier papers never made any claims with respect to, or evaluated, completeness. There are a number of directions in which the present algorithm could be improved. We are currently pursuing some ideas on how to improve the completeness of the algorithm further. It would also be worthwhile to explore heuristics for the order in which splits of the same subgraph are eliminated. The present work could be extended to allow equivalence with respect to arbitrary rewrite systems. Most generally, we hope that the methods develop</context>
</contexts>
<marker>Vestre, 1991</marker>
<rawString>E. Vestre. 1991. An algorithm for generating non-redundant quantifier scopings. In Proc. of the Fifth EACL, Berlin.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>