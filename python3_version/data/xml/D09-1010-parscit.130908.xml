<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<title confidence="0.989008">
Efficient kernels for sentence pair classification
</title>
<author confidence="0.829811">
Fabio Massimo Zanzotto
</author>
<affiliation confidence="0.7915825">
DISP
University of Rome “Tor Vergata”
</affiliation>
<address confidence="0.909109">
Via del Politecnico 1
00133 Roma, Italy
</address>
<email confidence="0.996499">
zanzotto@info.uniroma2.it
</email>
<sectionHeader confidence="0.994724" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999860181818182">
In this paper, we propose a novel class
of graphs, the tripartite directed acyclic
graphs (tDAGs), to model first-order rule
feature spaces for sentence pair classifi-
cation. We introduce a novel algorithm
for computing the similarity in first-order
rewrite rule feature spaces. Our algorithm
is extremely efficient and, as it computes
the similarity of instances that can be rep-
resented in explicit feature spaces, it is a
valid kernel function.
</bodyText>
<sectionHeader confidence="0.998429" genericHeader="keywords">
1 Introduction
</sectionHeader>
<bodyText confidence="0.999857888888889">
Natural language processing models are generally
positive combinations between linguistic models
and automatically learnt classifiers. As trees are
extremely important in many linguistic theories, a
large amount of works exploiting machine learn-
ing algorithms for NLP tasks has been developed
for this class of data structures (Collins and Duffy,
2002; Moschitti, 2004). These works propose ef-
ficient algorithms for determining the similarity
among two trees in tree fragment feature spaces.
Yet, some NLP tasks such as textual entail-
ment recognition (Dagan and Glickman, 2004;
Dagan et al., 2006) and some linguistic theories
such as HPSG (Pollard and Sag, 1994) require
more general graphs and, then, more general al-
gorithms for computing similarity among graphs.
Unfortunately, algorithms for computing similar-
ity among two general graphs in term of com-
mon subgraphs are still exponential (Ramon and
G¨artner, 2003). In these cases, approximated al-
gorithms have been proposed. For example, the
one proposed in (G¨artner, 2003) counts the num-
ber of subpaths in common. The same happens for
the one proposed in (Suzuki et al., 2003) that is
applicable to a particular class of graphs, i.e. the
hierarchical directed acyclic graphs. These algo-
rithms do not compute the number of subgraphs
</bodyText>
<note confidence="0.9503395">
Lorenzo Dell’Arciprete
University of Rome “Tor Vergata”
Via del Politecnico 1
00133 Roma, Italy
</note>
<email confidence="0.96298">
lorenzo.dellarciprete@gmail.com
</email>
<bodyText confidence="0.999958365853658">
in common between two graphs. Then, these al-
gorithms approximate the feature spaces we need
in these NLP tasks. For computing similarities in
these feature spaces, we have to investigate if we
can define a particular class of graphs for the class
of tasks we want to solve. Once we focused the
class of graph, we can explore efficient similarity
algorithms.
A very important class of graphs can be de-
fined for tasks involving sentence pairs. In these
cases, an important class of feature spaces is the
one that represents first-order rewrite rules. For
example, in textual entailment recognition (Da-
gan et al., 2006), we need to determine whether
a text T implies a hypothesis H, e.g., whether or
not “Farmers feed cows animal extracts” entails
“Cows eat animal extracts” (T1, H1). If we want
to learn textual entailment classifiers, we need
to exploit first-order rules hidden in training in-
stances. To positively exploit the training instance
“Pediatricians suggest women to feed newborns
breast milk” entails “Pediatricians suggest that
newborns eat breast milk” (T2, H2) for classify-
ing the above example, learning algorithms should
learn that the two instances hide the first-order rule
. The first-order
rule feature space, introduced by (Zanzotto and
Moschitti, 2006), gives high performances in term
of accuracy for textual entailment recognition with
respect to other features spaces.
In this paper, we propose a novel class of
graphs, the tripartite directed acyclic graphs
(tDAGs), that model first-order rule feature spaces
and, using this class of graphs, we introduce a
novel algorithm for computing the similarity in
first-order rewrite rule feature spaces. The possi-
bility of explicitly representing the first-order fea-
ture space as subgraphs of tDAGs makes the de-
rived similarity function a valid kernel. With re-
spect to the algorithm proposed in (Moschitti and
Zanzotto, 2007), our algorithm is more efficient
</bodyText>
<equation confidence="0.9903082">
p = feedY
Z
Z
→
Y eat
</equation>
<page confidence="0.988065">
91
</page>
<note confidence="0.996607">
Proceedings of the 2009 Conference on Empirical Methods in Natural Language Processing, pages 91–100,
Singapore, 6-7 August 2009. c�2009 ACL and AFNLP
</note>
<bodyText confidence="0.969135659090909">
and it is a valid kernel function.
The paper is organized as follows. In Sec. 2,
we firstly describe tripartite directed acyclic
graphs (tDAGs) to model first-order feature (FOR)
spaces. In Sec. 3, we then present the related
work. In Sec. 4, we introduce the similarity func-
tion for these FOR spaces. This can be used as ker-
nel function in kernel-based machines (e.g., sup-
port vector machines (Cortes and Vapnik, 1995)).
We then introduce our efficient algorithm for com-
puting the similarity among tDAGs. In Sec. 5,
we analyze the computational efficiency of our
algorithm showing that it is extremely more ef-
ficient than the algorithm proposed in (Moschitti
and Zanzotto, 2007). Finally, in Sec. 6, we draw
conclusions and plan the future work.
2 Representing first-order rules and
sentence pairs as tripartite directed
acyclic graphs
As first step, we want to define the tripartite di-
rected acyclic graphs (tDAGs). This is an ex-
tremely important class of graphs for the first-
order rule feature spaces we want to model. We
want here to intuitively show that, if we model
first-order rules and sentence pairs as tDAGs, de-
termining whether or not a sentence pair can be
unified with a first-order rewrite rule is a graph
matching problem. This intuitive idea helps in
determining our efficient algorithm for exploiting
first-order rules in learning examples.
To illustrate the above idea we will use an ex-
and the above sentence pair (T1, H1).
The rule p encodes the entailment relation of the
verb to feed and the verb to eat. If represented
over a syntactic interpretation, the rule has the fol-
lowing aspect:
eat
As in the case of feature structures (Carpenter,
1992), we can observe this rule as a graph. As
we are not interested in the variable names but we
need to know the relation between the right hand
side and the left hand side of the rule, we can
substitute each variable with an unlabelled node.
We then connect tree nodes having variables with
</bodyText>
<note confidence="0.453797">
eat
</note>
<figureCaption confidence="0.9999915">
Figure 1: A simple rewrite rule seen as a graph
Figure 2: A sample pair seen as a graph
</figureCaption>
<bodyText confidence="0.9985695">
the corresponding unlabelled node. The result is a
graph as the one in Fig. 1. The variables Y and Z
are represented by the unlabelled nodes between
the trees.
In the same way we can represent the sentence
pair (T1, H1) using graph with explicit links be-
tween related words and nodes (see Fig. 2). We
can link words using anchoring methods as in
(Raina et al., 2005). These links can then be prop-
agated in the syntactic tree using semantic heads
of the constituents (Pollard and Sag, 1994). The
rule p1 matches over the pair (T1, H1) if the graph
p1 is among the subgraphs of the graph in Fig. 2.
Both rules and sentence pairs are graphs of the
same type. These graphs are basically two trees
connected through an intermediate set of nodes
representing variables in the rules and relations be-
tween nodes in the sentence pairs. We will here-
after call these graphs tripartite directed acyclic
graphs (tDAGs). The formal definition follows.
</bodyText>
<listItem confidence="0.984323833333333">
Definition tDAG: A tripartite directed acyclic
graph is a graph G = (N, E) where
• the set of nodes N is partitioned in three sets
Nt, Ng, and A
• the set of edges is partitioned in four sets Et,
Eg, EAt, and EA9
</listItem>
<bodyText confidence="0.936828125">
such that t = (Nt, Et) and g = (Ng, Eg) are two
trees and EAt = {(x, y)|x E Nt and y E Al and
EA9 = {(x, y)|x E Ng and y E Al are the edges
connecting the two trees.
A tDAG is a partially labeled graph. The label-
ing function L only applies to the subsets of nodes
related to the two trees, i.e., L : Nt U Ng —* L.
Nodes in the set A are not labeled.
</bodyText>
<figure confidence="0.977420285714286">
ample based on the above rule p= feedY
Z
—*
·
NP
VB
feed
VP
S
VB
NP NP ·
NP VP
·
DT
·
NP
VB
NNS
NP
VB
NN
NP
S
S
NP
VP
VP
NP
cows
animal
animal
extracts
extracts
The
farmer
feed
NNS
NNS
NN
NNS
·
Cows
</figure>
<equation confidence="0.799483454545455">
eat
NN
Z
Y eat
VP
p1 = VB NP Y NP Z —*
feed
S
NP Y VP
VB
NP Z
</equation>
<page confidence="0.903688">
92
</page>
<bodyText confidence="0.99639625">
The explicit representation of the tDAG in Fig. 2
has been useful to show that the unification of a
rule and a sentence pair is a graph matching prob-
lem. Yet, it is complex to follow. We will then de-
scribe a tDAG with an alternative and more con-
venient representation. A tDAG G = (N, E)
can be seen as pair G = (T, -y) of extended trees
T and -y where T = (Nt U A, Et U EAt) and
-y = (Ng U A, Eg U EAg). These are extended
trees as each tree contains the relations with the
other tree.
As for the feature structures, we will graphically
represent a (x, y) E EAt and a (z, y) E EAg as
boxes y respectively on the node x and on the
node z. These nodes will then appear as L(x) y
and L(z)y, e.g., NP 1. The name y is not a label
but a placeholder representing an unlabelled node.
This representation is used for rules and for sen-
tence pairs. The sentence pair in Fig. 2 is then
represented as reported in Fig. 3.
</bodyText>
<sectionHeader confidence="0.999944" genericHeader="introduction">
3 Related work
</sectionHeader>
<bodyText confidence="0.999961363636363">
Automatically learning classifiers for sentence
pairs is extremely important for applications like
textual entailment recognition, question answer-
ing, and machine translation.
In textual entailment recognition, it is not hard
to see graphs similar to tripartite directed acyclic
graphs as ways of extracting features from exam-
ples to feed automatic classifiers. Yet, these graphs
are generally not tripartite in the sense described
in the previous section and they are not used to ex-
tract features representing first-order rewrite rules.
In (Raina et al., 2005; Haghighi et al., 2005; Hickl
et al., 2006), two connected graphs representing
the two sentences s1 and s2 are used to compute
distance features, i.e., features representing the
distance between s1 and s2. The underlying idea
is that lexical, syntactic, and semantic similarities
between sentences in a pair are relevant features
to classify sentence pairs in classes such as entail
and not-entail.
In (de Marneffe et al., 2006), first-order rewrite
rule feature spaces have been explored. Yet, these
spaces are extremely small. Only some features
representing first-order rules have been explored.
Pairs of graphs are used here to determine if a fea-
ture is active or not, i.e., the rule fires or not. A
larger feature space of rewrite rules has been im-
plicitly explored in (Wang and Neumann, 2007)
but this work considers only ground rewrite rules.
In (Zanzotto and Moschitti, 2006), tripartite di-
rected acyclic graphs are implicitly introduced and
exploited to build first-order rule feature spaces.
Yet, both in (Zanzotto and Moschitti, 2006) and
in (Moschitti and Zanzotto, 2007), the model pro-
posed has two major limitations: it can represent
rules with less than 7 variables and the proposed
kernel is not a completely valid kernel as it uses
the max function.
In machine translation, some methods such as
(Eisner, 2003) learn graph based rewrite rules for
generative purposes. Yet, the method presented in
(Eisner, 2003) can model first-order rewrite rules
only with a very small amount of variables, i.e.,
two or three variables.
</bodyText>
<sectionHeader confidence="0.519995" genericHeader="method">
4 An efficient algorithm for computing
the first-order rule space kernel
</sectionHeader>
<bodyText confidence="0.99988075">
In this section, we present our idea for an effi-
cient algorithm for exploiting first-order rule fea-
ture spaces. In Sec. 4.1, we firstly define the simi-
larity function, i.e., the kernel K(G1, G2), that we
need to determine for correctly using first-order
rules feature spaces. This kernel is strongly based
on the isomorphism between graphs. A relevant
idea of this paper is the observation that we can
define an efficient way to detect the isomorphism
between the tDAGs (Sec. 4.2). This algorithm ex-
ploits the efficient algorithms of tree isomorphism
as the one implicitly used in (Collins and Duffy,
2002). After describing the isomorphism between
tDAGs, We can present the idea of our efficient al-
gorithm for computing K(G1, G2) (Sec. 4.3). We
introduce the algorithms to make it a viable solu-
tion (Sec. 4.4). Finally, in Sec. 4.5, we report the
kernel computation we compare against presented
by (Zanzotto and Moschitti, 2006; Moschitti and
Zanzotto, 2007).
</bodyText>
<subsectionHeader confidence="0.8657165">
4.1 Kernel functions over first-order rule
feature spaces
</subsectionHeader>
<bodyText confidence="0.9999715">
The first-order rule feature space we want to model
is huge. If we use kernel-based machine learning
models such as SVM (Cortes and Vapnik, 1995),
we can implicitly define the space by defining its
similarity functions, i.e., its kernel functions. We
firstly introduce the first-order rule feature space
and we then define the prototypical kernel function
over this space.
The first-order rule feature space (FOR) is in
general the space of all the possible first-order
</bodyText>
<page confidence="0.989066">
93
</page>
<figure confidence="0.999620367088608">
S
S
NP 1
NP
VP
VP
NNS
NP 3
NP 1
P1 = h
, NNS1
NP 3
i
VB
VB
Farmers
feed
NNS1
NNS3
Cows
NN 2
eat
NNS3
NN 2
animal
extracts
animal
cows
extracts
S 2
S 2
NP 1
VP 2
NP 1
VP 2
NNS1
VB 2
NNS1
VB 2
SBAR
S
Pediatricians
S
IN
suggest
Pediatricians
NP
VP
suggest
P2 = h
i
,
that
NP 3
TO
NNS
VP
VP
to
NP 3
NP 4
women
VB
NNS3
NP 4
VB
feed
NNS3
NN 5
NN 4
newborns
eat
NN 5
NN 4
newborns
breast
milk
breast
milk
</figure>
<figureCaption confidence="0.999494">
Figure 3: Two tripartite DAGs
</figureCaption>
<bodyText confidence="0.996838692307692">
function is using the intersection operator, i.e., the
kernel K(G1, G2) is the following:
rules defined as tDAGs. Within this space it is pos-
sible to define the function S(G) that determines
all the possible active features of the tDAG G in
FOR. The function S(G) determines all the pos-
sible and meaningful subgraphs of G. We want
that these subgraphs represent first-order rules that
can be matched with the pair G. Then, meaningful
subgraphs of G = (τ, γ) are graphs as (t, g) where
t and g are subtrees of τ and γ. For example, the
subgraphs of P1 and P2 in Fig. 3 are hereafter par-
tially represented:
</bodyText>
<equation confidence="0.963828">
S
S
NP 1
NP 1
K(G1,G2) = |S(G1) fl S(G2) |(1)
</equation>
<bodyText confidence="0.99990125">
This is very simple to write and it is in principle
correct. A graph g in the intersection S(G1) fl
S(G2) is a graph that belongs to both S(G1) and
S(G2). Yet, this hides a very important fact: de-
termining whether two graphs, g1 and g2, are the
same graph g1 = g2 is not trivial. For example,
it is not sufficient to superficially compare graphs
to determine that ρ1 belongs both to S1 and S2.
We need to use the correct property for g1 = g2,
i.e., the isomorphism between two graphs. We can
call the operator Iso(g1, g2). When two graphs
verify the property Iso(g1, g2), both g1 and g2
can be taken as the graph g representing the two
graphs. Detecting Iso(g1, g2) has an exponential
complexity (K¨obler et al., 1993).
This complexity of the intersection operator be-
tween sets of graphs deserves a different way to
represent the operation. We will use the same sym-
bol but we will use the prefix notation. The opera-
tor is hereafter re-defined:
</bodyText>
<equation confidence="0.7471835">
,
S(P1) = { h
i , h
i ,
</equation>
<figure confidence="0.980762620689655">
,
NP 1 VP
NP VP
NNS1
NNS1
S
NP 1 VP
S
NP VP
h
i ,
,
NP 1 NP 3
NP 3
VB
VB
feed
eat
S
VP
NP 1 VP
h
i , ... }
NP 1 NP 3 ,
VB
NP 3
VB
feed
and
S(P2) = { h
eat
S 2
S 2
,
NP 1
NP 1
,
i , h
i ,
NP 1 VP 2
NP 1 VP 2
NNS1
NNS1
VP
S
NP 3 VP
VB
feed
NP 3 NP 4 ,
VB
NP 4
fl (S(G1),S(G2)) =
= {g1|g1 E S(G1), ∃g2 E S(G2), Iso(g1, g2)}
h
i , ... }
eat 4.2 Isomorphism between tDAGs
eat
4.2 Isomorphism between tDAGs
</figure>
<bodyText confidence="0.967462555555555">
As isomorphism between graphs is an essential ac-
In the FOR space, the kernel function K should
In the FOR space, the kernel function K should As isomorphism between graphs is an essential ac-
tivity for learning from structured data, we here
then compute the number of subgraphs in com-
then compute the number of subgraphs in com- tivity for learning from structured data, we here
review its definition and we adapt it to tDAGs.
mon. The trivial way to describe the former kernel
mon. The trivial way to describe the former kernel review its definition and we adapt it to tDAGs.
</bodyText>
<page confidence="0.989727">
94
</page>
<figure confidence="0.991681545454545">
B 1
A 1
C 1
,
M 1
I 1
N 1
B 1 B 2
B 1
A 1
C 1 C 2
C 1
,
M 2 M 1
M 1
I 1
N 2 N 1
N 1
B 1 B 2
C 1 C 3
M 3 M 1
N 2 N 1
</figure>
<bodyText confidence="0.9749775">
We then observe that isomorphism between two
tDAGs can be divided in two sub-problems:
</bodyText>
<listItem confidence="0.897157">
• finding the isomorphism between two pairs
of extended trees
• checking whether the partial isomorphism
found between the two pairs of extended trees
are compatible.
</listItem>
<bodyText confidence="0.8166956">
In general, two tDAGs, G1 = (N1, E1) and
G2 = (N2, E2) are isomorphic (or match) if
|N1 |= |N2|, |E1 |= |E2|, and abijective func-
tion f : N1 → N2 exists such that these properties
hold:
</bodyText>
<listItem confidence="0.893890666666667">
• for each node n ∈ N1, L(f(n)) = L(n)
• for each edge (n1, n2) ∈ E1 an edge
(f(n1), f(n2)) is in E2
</listItem>
<bodyText confidence="0.999850466666667">
The bijective function f is a member of the combi-
natorial set F of all the possible bijective functions
between the two sets N1 and N2.
The trivial algorithm for detecting if two graphs
are isomorphic is exponential (K¨obler et al.,
1993). It explores all the set F. It is still unde-
termined if the general graph isomorphism prob-
lem is NP-complete. Yet, we can use the fact that
tDAGs are two extended trees for building a bet-
ter algorithm. There is an efficient algorithm for
computing isomorphism between trees (as the one
implicitly used in (Collins and Duffy, 2002)).
Given two tDAGs G1 = (τ1, γ1) and G2 =
(τ2, γ2) the isomorphism problem can be divided
in detecting two properties:
</bodyText>
<listItem confidence="0.993196666666667">
1. Partial isomorphism. Two tDAGs G1 and G2
are partially isomorphic, if τ1 and τ2 are iso-
morphic and if γ1 and γ2 are isomorphic. The
partial isomorphism produces two bijective
functions fT and fy.
2. Constraint compatibility. Two bijective func-
tions fT and fy are compatible on the sets of
nodes A1 and A2, if for each n ∈ A1, it hap-
pens that fT(n) = fy(n).
</listItem>
<bodyText confidence="0.99933">
We can rephrase the second property, i.e., the
constraint compatibility, as follows. We de-
fine two constraints c(τ1,τ2) and c(γ1,γ2) rep-
resenting the functions fT and fy on the sets
A1 and A2. The two constraints are defined as
</bodyText>
<equation confidence="0.704135666666667">
c(τ1,τ2) = {(n, fT(n))|n ∈ A1} and c(γ1,γ2) =
{(n, fy(n))|n ∈ A1}. Two partially isomorphic
tDAGs are isomorphic if the constraints match,
i.e., c(τ1,τ2) = c(γ1,γ2).
Pa = (Ta, 7a) = (
Pb = (Tb, 7b) = (
</equation>
<figureCaption confidence="0.997787">
Figure 5: Simple non-linguistic tDAGs
</figureCaption>
<bodyText confidence="0.983312076923077">
For example, the third pair of S(P1) and the
second pair of S(P2) are isomorphic as: (1) these
are partially isomorphic, i.e., the right hand sides
τ and the left hand sides γ are isomorphic; (2)
both pairs of extended trees generate the constraint
)}. In the same way, the
fourth pair of S(P1) and the third pair of S(P2)
generate c2 = {( 1
4.3 General idea for an efficient kernel
function
As above discussed, two tDAGs are isomorphic if
the two properties, the partial isomorphism and
the constraint compatibility, hold. To compute the
kernel function K(G1, G2) defined in Sec. 4.1, we
can exploit these properties in the reverse order.
Given a constraint c, we can select all the graphs
that meet the constraint c (constraint compatibil-
ity). Having the two set of all the tDAGs meeting
the constraint, we can detect the partial isomor-
phism. We split each pair of tDAGs in the four
extended trees and we determine if these extended
trees are compatible.
We introduce this innovative method to com-
pute the kernel K(G1, G2) in the FOR space in
two steps. Firstly, we give an intuitive explanation
and, secondly, we formally define the kernel.
</bodyText>
<subsectionHeader confidence="0.36908">
4.3.1 Intuitive explanation
</subsectionHeader>
<bodyText confidence="0.997820923076923">
To give an intuition of the kernel computation,
without loss of generality and for sake of simplic-
ity, we use two non-linguistic tDAGs, Pa and Pb
(see Fig. 5), and the subgraph function �S(θ). This
latter is an approximated version of S(θ) that gen-
erates tDAGs with subtrees rooted in the root of
the initial trees of θ.
To exploit the constraint compatibility
property, we define C as the set of all the
relevant alternative constraints, i.e., the con-
straints c that are likely to be generated
when detecting the partial isomorphism.
For Pa and Pb, this set is C = {c1, c2} =
</bodyText>
<equation confidence="0.986095">
, 3
, 4
), ( 3
c1 = {(1
)}
, 1
</equation>
<page confidence="0.509229">
95
</page>
<figure confidence="0.898593593406594">
= ∩( _S(τa), _S(τb))|c1 × ∩( _S(γa), _S(γb))|c1
_S(Pa),
_S(Pb))|c1 = { h
A 1
I 1
M 1 N 1
N 2 N 1
i , h
B 1
C 1 ,
i ,
B 1 B 2
M 1 N 1
I 1
I 1
, M 1 N 1
N 2 N 1
} =
B 1 C 1
M 1 N 1
M 1 N 1
B 1 B 2
A 1
A 1
A 1
h
B 1 C 1
i } = {
C 1 } × {
B 1
,
,
B 1 C 1
B 1 B 2
I 1
M 1 N 1
N 2 N 1
A 1
I 1
A 1
,
i , h
B 1
I 1
C 1 ,
_S(Pa),_S(Pb))|c2 = { h
I 1
A 1
,
i , h
A 1
B 1 C 1
,
I 1
i , h
N 1 i ,
B 1 C 1
,
M 1
I 1
A 1
∩(
∩(
h
B 1 C 1
A 1
B 1 C 1
,
M 2 M 1
M 1
I 1
M 1 N 1
N 1 i } = {
B 1 C 1
A 1
C 1 C 2
A 1
, B 1 C 1
C 1 C 2
M 1 N 1
} × {
I 1
M 1 N 1
C 1 C 2
,
M 2 M 1
M 1
I 1
M 2 M 1
N 1 }=
= ∩( _S(τa), _S(τb))|c2 × ∩( _S(γa), _S(γb))|c2
</figure>
<figureCaption confidence="0.941709">
Figure 4: Intuitive idea for the kernel computation
</figureCaption>
<equation confidence="0.466733666666667">
∩(_S(Pa),
∩(_S(τa),
{{(1, 1 ), ( 2 , 2 )},{(1 , 1 ), (2 , 3 )}}. We can
</equation>
<bodyText confidence="0.78737">
then determine the kernel K(Pa, Pb) as:
</bodyText>
<equation confidence="0.991994">
K(Pa,Pb)= |n(_S(Pa), _S(Pb))|=
= |n(_S(Pa),_S(Pb))|c1 U n(_S(Pa),_S(Pb))|c2|
</equation>
<bodyText confidence="0.960966424242424">
where ∩( _S(Pa),_S(Pb))|c are the common sub-
graphs that meet the constraint c. A tDAG g&apos; =
_S(Pa), _S(Pb))|c if g&apos;&apos; =
(τ&apos;&apos;,γ&apos;&apos;) in S(Pb) exists, g&apos; is partially isomorphic
to g&apos;&apos;, and c&apos; = c(τ&apos;, τ&apos;&apos;) = c(γ&apos;, γ&apos;&apos;) is covered by
and compatible with the constraint c, i.e., c&apos; ⊆ c.
For example in Fig. 4, the first tDAG of the set
∩( _S(Pa), _S(Pb))|c1 belongs to the set as its con-
straint c&apos; = {( 1 , 1 )} is a subset of c1.
Observing the kernel computation in this way
is important. Elements in ∩(_S(Pa), _S(Pb))|c
already satisfy the property of constraint com-
patibility. We only need to determine if the
partially isomorphic properties hold for elements
_S(Pb))|c. Then, we can write the
following equivalence:
Figure 4 reports this equivalence for the two
sets derived using the constraints c1 and c2.
Note that this equivalence is not valid if a con-
straint isnot applied, i.e., ∩(_S_(Pa),_S_(Pb))
=6 ∩(S(τa), S(τb)) × ∩(S(γa), S(γb)).
The pair Pa itself does not belong to
_S(Pb)) but it _does belong to
S(τb)) × ∩(_S(γa),S(γb)).
The equivalence (2) allows to compute the car-
dinality of ∩(S(PJ,_S(Pb))|c using the c_a(rdinal-
ities of ∩(_S(τa),S(τb))|c and ∩(_S(γa),S(γb))|c.
These latter sets contain only extended trees where
the equivalences between unlabelled nodes are
given by c. We can then compute the cardinali-
ties of these two sets using methods developed for
trees (e.g., the kernel function KS(θ1, θ2) intro-
duced in (Collins and Duffy, 2002)).
</bodyText>
<subsectionHeader confidence="0.594234">
4.3.2 Formal definition
</subsectionHeader>
<bodyText confidence="0.999831666666667">
Given the idea of the previous section, it is easy
to demonstrate that the kernel K(G1, G2) can be
written as follows:
</bodyText>
<equation confidence="0.834656">
K(G1,G2)=|Uc∈C n(S(τ1),S(τ2))|cxn(S(γ1),S(γ2))|c|
</equation>
<bodyText confidence="0.998595">
where C is set of alternative constraints and
∩(S(θ1),S(θ2))|c are all the common extended
trees compatible with the constraint c.
We can compute the above kernel using the
inclusion-exclusion property, i.e.,
</bodyText>
<equation confidence="0.9716465">
|A1 ∪ · · · ∪ An |= � (−1)|J|−1|AJ |(3)
JE2{1,...,n}
</equation>
<bodyText confidence="0.99670075">
where 211,...,n} is the set of all the subsets of
{1, . . . ,n} and AJ = niEJ Ai.
To describe the application of the inclusion-
exclusion model in our case, let firstly define:
</bodyText>
<equation confidence="0.966623777777778">
KS(θ1,θ2,c) = |∩(S(θ1),S(θ2))|c |(4)
n( _S(Pa), _S(Pb))|c=
=n(_S(τa),_S(τb))|cxn(_S(γa),
_
S(γb))|c
(2)
(τ&apos;, γ&apos;) in _S(Pa) is in ∩(
_
in ∩( _S(Pa),
</equation>
<page confidence="0.982228">
96
</page>
<bodyText confidence="0.9990105">
where θ1 can be both τ1 and γ1 and θ2 can be both
τ2 and γ2. Trivially, we can demonstrate that:
</bodyText>
<equation confidence="0.987028333333333">
K(G1, G2) =
=E JE2{1,...,|C|}(−1)|J|−1KS(τ1,τ2,c(J))KS(γ1,γ2,c(J))
(5)
</equation>
<bodyText confidence="0.9968956">
where c(J) = niEJ ci.
Given the nature of the constraint set C, we
can compute efficiently the previous equation as
it often happens that two different J1 and J2 in
211,...,IC11 generate the same c, i.e.
</bodyText>
<equation confidence="0.999032">
�c = �ci = ci (6)
iEJ1 iEJ2
</equation>
<bodyText confidence="0.989174">
Then, we can define C* as the set of all intersec-
tions of constraints in C, i.e. C* = {c(J)|J ∈
211,...,IC11}. We can rewrite the equation as:
</bodyText>
<equation confidence="0.993910333333333">
K(G1, G2) =
�= KS(τ1,τ2,c)KS(γ1,γ2,c)N(c) (7)
cEC*
</equation>
<bodyText confidence="0.715802">
where
</bodyText>
<equation confidence="0.998010333333333">
N(c) = � (−1)jJj−1 (8)
JE2{1,...,|C|}
c=c(J)
</equation>
<bodyText confidence="0.99994725">
The complexity of the above kernel strongly de-
pends on the cardinality of C and the related cardi-
nality of C*. The worst-case computational com-
plexity is still exponential with respect to the size
of A1 and A2. Yet, the average case complexity
(Wang, 1997) is promising.
The set C is generally very small with re-
spect to the worst case. If F(A1,A2) are all the
possible correspondences between the nodes
A1 and A2, it happens that |C |&lt;&lt; |F(A1,A2)|
where |F(A1,A2) |is the worst case. For example,
in the case of P1 and P2, the cardinality of
</bodyText>
<equation confidence="0.9705035">
C = {{(1 , 1 )},{(1 , 3 ), (3 , 4 ), ( 2 , 5 )}}
is extremely smaller than the one of
F(A1,A2) = {{( 1 ,1 ),( 2 ,2 ),( 3 ,3 )},
{(1,2 ),(2,1 ),( 3 ,3 )}, {(1 ,2 ),( 2 ,3 ),( 3 ,1 )},
</equation>
<bodyText confidence="0.99903275">
)}}. In Sec. 4.5 we argue
that the algorithm presented in (Moschitti and
Zanzotto, 2007) has the worst-case complexity.
Moreover, the set C* is extremely smaller than
211,...,IC11 due to the above property (6).
We will analyze the average-case complex-
ity with respect to the worst-case complexity in
Sec. 5.
</bodyText>
<subsectionHeader confidence="0.995645">
4.4 Enabling the efficient kernel function
</subsectionHeader>
<bodyText confidence="0.9998995">
The above idea for computing the kernel function
is extremely interesting. Yet, we need to make it
viable by describing the way we can determine ef-
ficiently the three main parts of the equation (7):
</bodyText>
<listItem confidence="0.98479225">
1) the set of alternative constraints C (Sec. 4.4.1);
2) the set C* of all the possible intersections of
constraints in C (Sec. 4.4.2); and, finally, 3) the
numbers N(c) (Sec. 4.4.3).
</listItem>
<subsectionHeader confidence="0.7108685">
4.4.1 Determining the set of alternative
constraints
</subsectionHeader>
<bodyText confidence="0.998509090909091">
The first step of equation (7) is to determine the
alternative constraints C. We can here strongly
use the possibility of dividing tDAGs in two trees.
We build C as Cτ ∪ Cγ where: 1) Cτ are the
constraints obtained from pairs of isomorphic ex-
tended trees t1 ∈ S(τ1) and t2 ∈ S(τ2); 2) Cγ are
the constraints obtained from pairs of isomorphic
extended trees t1 ∈ S(γ1) and t2 ∈ S(γ2).
The idea for an efficient algorithm is that we
can compute the C without explicitly looking
at all the subgraphs involved. We instead use
and combine the constraints derived comparing
the productions of the extended trees. We can
compute then Cτ with the productions of τ1 and
τ2 and Cγ with the productions of γ1 and γ2.
For example (see Fig. 3), focusing on the τ, the
rule NP 3 → NN 2 NNS 3 of G1 and
NP 4 → NN 5 NNS 4 of G2 generates the
constraint c = {( 3
Using the above intuition it is possible to define
an algorithm that builds an alternative constraint
set C with the following two properties:
</bodyText>
<listItem confidence="0.99352625">
1. for each common subtree according to a set
of constraints c, ∃c&apos; ∈ C such that c ⊆ c&apos;;
2. �c&apos;, c&apos;&apos; ∈ C such that c&apos; ⊂ c&apos;&apos; and c&apos; =6 ∅.
4.4.2 Determining the set C*
</listItem>
<bodyText confidence="0.999681857142857">
The set C* is defined as the set of all possible in-
tersections of alternative constraints in C. Figure
6 presents the algorithm determining C*. Due to
the property (6) discussed in Sec. 4.3, we can em-
pirically demonstrate that the average complexity
of the algorithm is not bigger than O(|C|2). Yet,
again, the worst case complexity is exponential.
</bodyText>
<subsectionHeader confidence="0.78449">
4.4.3 Determining the values of N(c)
</subsectionHeader>
<bodyText confidence="0.999807333333333">
The multiplier N(c) (Eq. 8) represents the num-
ber of times the constraint c is considered in the
sum of equation 5, keeping into account the sign of
</bodyText>
<figure confidence="0.949933444444444">
,3
,5
),( 3
),( 2 , 4
..., {(1
, 5
, 4
)}.
), (2
</figure>
<page confidence="0.746739">
97
</page>
<construct confidence="0.224239">
Algorithm Build the set C* from the set C
</construct>
<equation confidence="0.858686625">
C+ ← C ; C1 ← C ; C2 ← ∅
WHILE |C1 |&gt; 1
FORALL c&apos; ∈ C1
FORALL c&apos;&apos; ∈ C1 such that c&apos; =6 c&apos;&apos;
c ← c&apos; ∩ c&apos;&apos;
IF c ∈/ C+ add c to C2
C+ ← C+ ∪ C2 ; C1 ← C2; C2 ← ∅
C* ← C ∪ C+ ∪ {∅}
</equation>
<figureCaption confidence="0.997736">
Figure 6: Algorithm for computing C*
</figureCaption>
<figure confidence="0.9942336">
40
30
50
20
10
0
K(G1, G2)
Kmax(G1, G2)
ms
0 10 20 30 40 50
</figure>
<bodyText confidence="0.836487">
the corresponding addend. It is possible to demon-
strate that:
</bodyText>
<equation confidence="0.796681333333333">
N(c) = 1 − � Nc&apos; (9)
c&apos;EC*
c&apos;Dc
</equation>
<bodyText confidence="0.9999542">
This recursive formulation of the equation allows
us to easily determine the value of N(c) for every
c belonging to C*. It is possible to prove this prop-
erty using set properties and the binomial theorem.
The proof is omitted for lack of space.
</bodyText>
<subsectionHeader confidence="0.983654">
4.5 Reviewing the strictly related work
</subsectionHeader>
<bodyText confidence="0.999949818181818">
To understand if ours is an efficient algorithm, we
compare it with the algorithm presented by (Mos-
chitti and Zanzotto, 2007). We will hereafter call
this algorithm Kmax. The Kmax algorithm and
kernel is an approximation of what is a kernel
needed for a FOR space as it is not difficult to
demonstrate that Kmax(G1, G2) ≤ K(G1, G2).
The Kmax approximation is based on maximiza-
tion over the set of possible correspondences of
the placeholders. Following our formulation, this
kernel appears as:
</bodyText>
<equation confidence="0.998813333333333">
Kmax(G1,G2) =
= max
cE.T(A1,A2) KS(τ1,τ2,c)KS(γ1,γ2,c) (10)
</equation>
<bodyText confidence="0.953138454545455">
where F(A1,A2) are all the possible correspon-
dences between the nodes A1 and A2 of the two
tDAGs as the one presented in Sec. 4.3. This for-
mulation of the kernel has the worst case complex-
ity of our formulation, i.e., Eq. 7.
For computing the basic kernel for the extended
trees, i.e. KS(01, 02, c) we use the model algo-
rithm presented by (Zanzotto and Moschitti, 2006)
and refined by (Moschitti and Zanzotto, 2007)
based on the algorithm for tree fragment feature
n × m placeholders
</bodyText>
<figureCaption confidence="0.807028">
Figure 7: Mean execution time in milliseconds
</figureCaption>
<bodyText confidence="0.7724995">
(ms) of the two algorithms wrt. n × m where n
and m are the number of placeholders of the two
tDAGs
spaces (Collins and Duffy, 2002). As we are using
the same basic kernel, we can empirically compare
the two methods.
</bodyText>
<sectionHeader confidence="0.997188" genericHeader="evaluation">
5 Experimental evaluation
</sectionHeader>
<bodyText confidence="0.999990619047619">
In this section we want to empirically estimate the
benefits on the computational cost of our novel al-
gorithm with respect to the algorithm proposed by
(Moschitti and Zanzotto, 2007). Our algorithm is
in principle exponential with respect to the set of
alternative constraints C. Yet, due to what pre-
sented in Sec. 4.4 and as the set C* is usually
very small, the average complexity is extremely
low. Following the theory on the average-cost
computational complexity (Wang, 1997), we es-
timated the behavior of the algorithms on a large
distribution of cases. We then compared the com-
puting times of the two algorithms. Finally, as
K and Kmax compute slightly different kernels,
we compare the accuracy of the two methods.
We implemented both algorithms K(G1, G2) and
Kmax(G1, G2) in support vector machine classi-
fier (Joachims, 1999) and we experimented with
both implementations on the same machine. We
hereafter analyze the results in term of execution
time (Sec. 5.1) and in term of accuracy (Sec. 5.2).
</bodyText>
<subsectionHeader confidence="0.992985">
5.1 Average computing time analysis
</subsectionHeader>
<bodyText confidence="0.994754333333333">
For this first set of experiments, the source of ex-
amples is the one of the recognizing textual en-
tailment challenge, i.e., RTE2 (Bar-Haim et al.,
</bodyText>
<page confidence="0.985882">
98
</page>
<figure confidence="0.625528">
#ofplaceholders
</figure>
<figureCaption confidence="0.86303">
Figure 8: Total execution time in seconds (s) of
</figureCaption>
<bodyText confidence="0.979858617647059">
the training phase on RTE2 wrt. different numbers
of allowed placeholders
2006). The dataset of the challenge has 1,600 sen-
tence pairs.
The computational cost of both K(G1, G2) and
Kmax(G1, G2) depends on the number of place-
holders n = |A1 |of G1 and on m = |A2 |the
number of placeholders of G2. Then, in the first
experiment we want to determine the relation be-
tween the computational time and the factor n×m.
Results are reported in Fig. 7 where the computa-
tion times are plotted with respect to n × m. Each
point in the curve represents the average execu-
tion time for the pairs of instances having n × m
placeholders. As expected, the computation of the
function K is more efficient than the computation
Kmax. The difference between the two execution
times increases with n × m.
We then performed a second experiment that
wants to determine the relation of the total exe-
cution with the maximum number of placeholders
in the examples. This is useful to estimate the be-
havior of the algorithm with respect to its applica-
tion in learning models. Using the RTE2 data, we
artificially build different versions with increasing
number of placeholders. We then have RTE2 with
1 placeholder at most in each pair, RTE2 with 2
placeholders, etc. The number of pairs in each set
is the same. What changes is the maximal num-
ber of placeholders. Results are reported in Fig. 8
where the execution time of the training phase in
seconds (s) is plotted for each different set. We
see that the computation of Kmax is exponential
with respect to the number of placeholders and
</bodyText>
<table confidence="0.998886">
Kernel Accuracy Used training Support
examples Vectors
Kmaa 59.32 4223 4206
K 60.04 4567 4544
</table>
<tableCaption confidence="0.999943">
Table 1: Comparative performances of Kmaa and K
</tableCaption>
<bodyText confidence="0.9996395">
it becomes intractable after 7 placeholders. The
computation of K is instead more flat. This can
be explained as the computation of K is related
to the real alternative constraints that appears in
the dataset. The computation of the kernel K then
outperforms the computation of the kernel Kmax.
</bodyText>
<subsectionHeader confidence="0.99985">
5.2 Accuracy analysis
</subsectionHeader>
<bodyText confidence="0.999985941176471">
As Kmax that has been demonstrated very effec-
tive in term of accuracy for RTE and K compute
a slightly different similarity function, we want to
show that the performance of our more computa-
tionally efficient K is comparable, and even better,
to the performances of Kmax. We then performed
an experiment taking as training all the data de-
rived from RTE1, RTE2, and RTE3, (i.e., 4567
training examples) and taking as testing RTE-4
(i.e., 1000 testing examples). The results are re-
ported in Tab. 1. As the table shows, the accuracy
of K is higher than the accuracy of Kmax. There
are two main reasons. The first is that Kmax is
an approximation of K. The second is that we
can now consider sentence pairs with more than
7 placeholders. Then, we can use the complete
training set as the third column of the table shows.
</bodyText>
<sectionHeader confidence="0.996832" genericHeader="conclusions">
6 Conclusions and future work
</sectionHeader>
<bodyText confidence="0.999888076923077">
We presented an interpretation of first order rule
feature spaces as tripartite directed acyclic graphs
(tDAGs). This view on the problem gave us the
possibility of defining a novel and efficient algo-
rithm for computing the kernel function for first
order rule feature spaces. Moreover, the resulting
algorithm is a valid kernel as it can be written as
dot product in the explicit space of the tDAG frag-
ments. We demonstrated that our algorithm out-
performs in term of average complexity the previ-
ous algorithm and it yields to better accuracies for
the final task. We are investigating if this is a valid
algorithm for two general directed acyclic graphs.
</bodyText>
<figure confidence="0.999465076923077">
0 2 4 6 8 10 12 14
1600
1400
1200
1000
800
600
400
200
0
K(G1, G2)
Kmax(G1, G2)
s
</figure>
<page confidence="0.986291">
99
</page>
<sectionHeader confidence="0.992325" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999949747474747">
Roy Bar-Haim, Ido Dagan, Bill Dolan, Lisa
Ferro, Danilo Giampiccolo, and Idan Magnini,
Bernardo Szpektor. 2006. The second pascal recog-
nising textual entailment challenge. In Proceedings
of the Second PASCAL Challenges Workshop on
Recognising Textual Entailment. Venice, Italy.
Bob Carpenter. 1992. The Logic of Typed Fea-
ture Structures. Cambridge University Press, Cam-
bridge, England.
Michael Collins and Nigel Duffy. 2002. New rank-
ing algorithms for parsing and tagging: Kernels over
discrete structures, and the voted perceptron. In Pro-
ceedings ofACL02.
C. Cortes and V. Vapnik. 1995. Support vector net-
works. Machine Learning, 20:1–25.
Ido Dagan and Oren Glickman. 2004. Probabilistic
textual entailment: Generic applied modeling of lan-
guage variability. In Proceedings of the Workshop
on Learning Methods for Text Understanding and
Mining, Grenoble, France.
Ido Dagan, Oren Glickman, and Bernardo Magnini.
2006. The pascal recognising textual entailment
challenge. In Quionero-Candela et al., editor, LNAI
3944: MLCW 2005, pages 177–190, Milan, Italy.
Springer-Verlag.
Marie-Catherine de Marneffe, Bill MacCartney, Trond
Grenager, Daniel Cer, Anna Rafferty, and Christo-
pher D. Manning. 2006. Learning to distinguish
valid textual entailments. In Proceedings of the Sec-
ond PASCAL Challenges Workshop on Recognising
Textual Entailment, Venice, Italy.
Jason Eisner. 2003. Learning non-isomorphic tree
mappings for machine translation. In Proceedings
of the 41st Annual Meeting of the Association for
Computational Linguistics (ACL), Companion Vol-
ume, pages 205–208, Sapporo, July.
Thomas G¨artner. 2003. A survey of kernels for struc-
tured data. SIGKDD Explorations.
Aria D. Haghighi, Andrew Y. Ng, and Christopher D.
Manning. 2005. Robust textual inference via graph
matching. In HLT ’05: Proceedings of the con-
ference on Human Language Technology and Em-
pirical Methods in Natural Language Processing,
pages 387–394, Morristown, NJ, USA. Association
for Computational Linguistics.
Andrew Hickl, John Williams, Jeremy Bensley, Kirk
Roberts, Bryan Rink, and Ying Shi. 2006. Rec-
ognizing textual entailment with LCCs GROUND-
HOG system. In Bernardo Magnini and Ido Dagan,
editors, Proceedings of the Second PASCAL Recog-
nizing Textual Entailment Challenge, Venice, Italy.
Springer-Verlag.
Thorsten Joachims. 1999. Making large-scale svm
learning practical. In B. Schlkopf, C. Burges, and
A. Smola, editors, Advances in Kernel Methods-
Support Vector Learning. MIT Press.
Johannes K¨obler, Uwe Sch¨oning, and Jacobo Tor´an.
1993. The graph isomorphism problem: its struc-
tural complexity. Birkhauser Verlag, Basel, Switzer-
land, Switzerland.
Alessandro Moschitti and Fabio Massimo Zanzotto.
2007. Fast and effective kernels for relational learn-
ing from texts. In Proceedings of the International
Conference ofMachine Learning (ICML). Corvallis,
Oregon.
Alessandro Moschitti. 2004. A study on convolution
kernels for shallow semantic parsing. In proceed-
ings of the ACL, Barcelona, Spain.
C. Pollard and I.A. Sag. 1994. Head-driven Phrase
Structured Grammar. Chicago CSLI, Stanford.
Rajat Raina, Aria Haghighi, Christopher Cox, Jenny
Finkel, Jeff Michels, Kristina Toutanova, Bill Mac-
Cartney, Marie-Catherine de Marneffe, Manning
Christopher, and Andrew Y. Ng. 2005. Robust tex-
tual inference using diverse knowledge sources. In
Proceedings of the 1st Pascal Challenge Workshop,
Southampton, UK.
Jan Ramon and Thomas G¨artner. 2003. Expressivity
versus efficiency of graph kernels. In First Interna-
tional Workshop on Mining Graphs, Trees and Se-
quences.
Jun Suzuki, Tsutomu Hirao, Yutaka Sasaki, and Eisaku
Maeda. 2003. Hierarchical directed acyclic graph
kernel: Methods for structured natural language
data. In In Proceedings of the 41st Annual Meet-
ing of the Association for Computational Linguis-
tics, pages 32–39.
Rui Wang and G¨unter Neumann. 2007. Recog-
nizing textual entailment using a subsequence ker-
nel method. In Proceedings of the Twenty-Second
AAAI Conference on Artificial Intelligence (AAAI-
07), July 22-26, Vancouver, Canada.
Jie Wang. 1997. Average-case computational com-
plexity theory. pages 295–328.
Fabio Massimo Zanzotto and Alessandro Moschitti.
2006. Automatic learning of textual entailments
with cross-pair similarities. In Proceedings of the
21st Coling and 44th ACL, pages 401–408. Sydney,
Australia, July.
</reference>
<page confidence="0.990746">
100
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.478994">
<title confidence="0.999848">Efficient kernels for sentence pair classification</title>
<author confidence="0.999984">Fabio Massimo</author>
<affiliation confidence="0.997732">University of Rome “Tor</affiliation>
<address confidence="0.7452865">Via del Politecnico 00133 Roma, Italy</address>
<email confidence="0.993099">zanzotto@info.uniroma2.it</email>
<abstract confidence="0.998447916666667">In this paper, we propose a novel class of graphs, the tripartite directed acyclic graphs (tDAGs), to model first-order rule feature spaces for sentence pair classification. We introduce a novel algorithm for computing the similarity in first-order rewrite rule feature spaces. Our algorithm is extremely efficient and, as it computes the similarity of instances that can be represented in explicit feature spaces, it is a valid kernel function.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Roy Bar-Haim</author>
<author>Ido Dagan</author>
<author>Bill Dolan</author>
<author>Lisa Ferro</author>
<author>Danilo Giampiccolo</author>
<author>Idan Magnini</author>
<author>Bernardo Szpektor</author>
</authors>
<title>The second pascal recognising textual entailment challenge.</title>
<date>2006</date>
<booktitle>In Proceedings of the Second PASCAL Challenges Workshop on Recognising Textual Entailment.</booktitle>
<location>Venice, Italy.</location>
<marker>Bar-Haim, Dagan, Dolan, Ferro, Giampiccolo, Magnini, Szpektor, 2006</marker>
<rawString>Roy Bar-Haim, Ido Dagan, Bill Dolan, Lisa Ferro, Danilo Giampiccolo, and Idan Magnini, Bernardo Szpektor. 2006. The second pascal recognising textual entailment challenge. In Proceedings of the Second PASCAL Challenges Workshop on Recognising Textual Entailment. Venice, Italy.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Bob Carpenter</author>
</authors>
<title>The Logic of Typed Feature Structures.</title>
<date>1992</date>
<publisher>Cambridge University Press,</publisher>
<location>Cambridge, England.</location>
<contexts>
<context position="5837" citStr="Carpenter, 1992" startWordPosition="927" endWordPosition="928">ow that, if we model first-order rules and sentence pairs as tDAGs, determining whether or not a sentence pair can be unified with a first-order rewrite rule is a graph matching problem. This intuitive idea helps in determining our efficient algorithm for exploiting first-order rules in learning examples. To illustrate the above idea we will use an exand the above sentence pair (T1, H1). The rule p encodes the entailment relation of the verb to feed and the verb to eat. If represented over a syntactic interpretation, the rule has the following aspect: eat As in the case of feature structures (Carpenter, 1992), we can observe this rule as a graph. As we are not interested in the variable names but we need to know the relation between the right hand side and the left hand side of the rule, we can substitute each variable with an unlabelled node. We then connect tree nodes having variables with eat Figure 1: A simple rewrite rule seen as a graph Figure 2: A sample pair seen as a graph the corresponding unlabelled node. The result is a graph as the one in Fig. 1. The variables Y and Z are represented by the unlabelled nodes between the trees. In the same way we can represent the sentence pair (T1, H1)</context>
</contexts>
<marker>Carpenter, 1992</marker>
<rawString>Bob Carpenter. 1992. The Logic of Typed Feature Structures. Cambridge University Press, Cambridge, England.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Michael Collins</author>
<author>Nigel Duffy</author>
</authors>
<title>New ranking algorithms for parsing and tagging: Kernels over discrete structures, and the voted perceptron.</title>
<date>2002</date>
<booktitle>In Proceedings ofACL02.</booktitle>
<contexts>
<context position="999" citStr="Collins and Duffy, 2002" startWordPosition="142" endWordPosition="145">novel algorithm for computing the similarity in first-order rewrite rule feature spaces. Our algorithm is extremely efficient and, as it computes the similarity of instances that can be represented in explicit feature spaces, it is a valid kernel function. 1 Introduction Natural language processing models are generally positive combinations between linguistic models and automatically learnt classifiers. As trees are extremely important in many linguistic theories, a large amount of works exploiting machine learning algorithms for NLP tasks has been developed for this class of data structures (Collins and Duffy, 2002; Moschitti, 2004). These works propose efficient algorithms for determining the similarity among two trees in tree fragment feature spaces. Yet, some NLP tasks such as textual entailment recognition (Dagan and Glickman, 2004; Dagan et al., 2006) and some linguistic theories such as HPSG (Pollard and Sag, 1994) require more general graphs and, then, more general algorithms for computing similarity among graphs. Unfortunately, algorithms for computing similarity among two general graphs in term of common subgraphs are still exponential (Ramon and G¨artner, 2003). In these cases, approximated al</context>
<context position="11686" citStr="Collins and Duffy, 2002" startWordPosition="2002" endWordPosition="2005">rule space kernel In this section, we present our idea for an efficient algorithm for exploiting first-order rule feature spaces. In Sec. 4.1, we firstly define the similarity function, i.e., the kernel K(G1, G2), that we need to determine for correctly using first-order rules feature spaces. This kernel is strongly based on the isomorphism between graphs. A relevant idea of this paper is the observation that we can define an efficient way to detect the isomorphism between the tDAGs (Sec. 4.2). This algorithm exploits the efficient algorithms of tree isomorphism as the one implicitly used in (Collins and Duffy, 2002). After describing the isomorphism between tDAGs, We can present the idea of our efficient algorithm for computing K(G1, G2) (Sec. 4.3). We introduce the algorithms to make it a viable solution (Sec. 4.4). Finally, in Sec. 4.5, we report the kernel computation we compare against presented by (Zanzotto and Moschitti, 2006; Moschitti and Zanzotto, 2007). 4.1 Kernel functions over first-order rule feature spaces The first-order rule feature space we want to model is huge. If we use kernel-based machine learning models such as SVM (Cortes and Vapnik, 1995), we can implicitly define the space by de</context>
<context position="16825" citStr="Collins and Duffy, 2002" startWordPosition="3047" endWordPosition="3050">ach edge (n1, n2) ∈ E1 an edge (f(n1), f(n2)) is in E2 The bijective function f is a member of the combinatorial set F of all the possible bijective functions between the two sets N1 and N2. The trivial algorithm for detecting if two graphs are isomorphic is exponential (K¨obler et al., 1993). It explores all the set F. It is still undetermined if the general graph isomorphism problem is NP-complete. Yet, we can use the fact that tDAGs are two extended trees for building a better algorithm. There is an efficient algorithm for computing isomorphism between trees (as the one implicitly used in (Collins and Duffy, 2002)). Given two tDAGs G1 = (τ1, γ1) and G2 = (τ2, γ2) the isomorphism problem can be divided in detecting two properties: 1. Partial isomorphism. Two tDAGs G1 and G2 are partially isomorphic, if τ1 and τ2 are isomorphic and if γ1 and γ2 are isomorphic. The partial isomorphism produces two bijective functions fT and fy. 2. Constraint compatibility. Two bijective functions fT and fy are compatible on the sets of nodes A1 and A2, if for each n ∈ A1, it happens that fT(n) = fy(n). We can rephrase the second property, i.e., the constraint compatibility, as follows. We define two constraints c(τ1,τ2) a</context>
<context position="21880" citStr="Collins and Duffy, 2002" startWordPosition="4096" endWordPosition="4099"> is not valid if a constraint isnot applied, i.e., ∩(_S_(Pa),_S_(Pb)) =6 ∩(S(τa), S(τb)) × ∩(S(γa), S(γb)). The pair Pa itself does not belong to _S(Pb)) but it _does belong to S(τb)) × ∩(_S(γa),S(γb)). The equivalence (2) allows to compute the cardinality of ∩(S(PJ,_S(Pb))|c using the c_a(rdinalities of ∩(_S(τa),S(τb))|c and ∩(_S(γa),S(γb))|c. These latter sets contain only extended trees where the equivalences between unlabelled nodes are given by c. We can then compute the cardinalities of these two sets using methods developed for trees (e.g., the kernel function KS(θ1, θ2) introduced in (Collins and Duffy, 2002)). 4.3.2 Formal definition Given the idea of the previous section, it is easy to demonstrate that the kernel K(G1, G2) can be written as follows: K(G1,G2)=|Uc∈C n(S(τ1),S(τ2))|cxn(S(γ1),S(γ2))|c| where C is set of alternative constraints and ∩(S(θ1),S(θ2))|c are all the common extended trees compatible with the constraint c. We can compute the above kernel using the inclusion-exclusion property, i.e., |A1 ∪ · · · ∪ An |= � (−1)|J|−1|AJ |(3) JE2{1,...,n} where 211,...,n} is the set of all the subsets of {1, . . . ,n} and AJ = niEJ Ai. To describe the application of the inclusionexclusion model </context>
<context position="28475" citStr="Collins and Duffy, 2002" startWordPosition="5331" endWordPosition="5334">rrespondences between the nodes A1 and A2 of the two tDAGs as the one presented in Sec. 4.3. This formulation of the kernel has the worst case complexity of our formulation, i.e., Eq. 7. For computing the basic kernel for the extended trees, i.e. KS(01, 02, c) we use the model algorithm presented by (Zanzotto and Moschitti, 2006) and refined by (Moschitti and Zanzotto, 2007) based on the algorithm for tree fragment feature n × m placeholders Figure 7: Mean execution time in milliseconds (ms) of the two algorithms wrt. n × m where n and m are the number of placeholders of the two tDAGs spaces (Collins and Duffy, 2002). As we are using the same basic kernel, we can empirically compare the two methods. 5 Experimental evaluation In this section we want to empirically estimate the benefits on the computational cost of our novel algorithm with respect to the algorithm proposed by (Moschitti and Zanzotto, 2007). Our algorithm is in principle exponential with respect to the set of alternative constraints C. Yet, due to what presented in Sec. 4.4 and as the set C* is usually very small, the average complexity is extremely low. Following the theory on the average-cost computational complexity (Wang, 1997), we estim</context>
</contexts>
<marker>Collins, Duffy, 2002</marker>
<rawString>Michael Collins and Nigel Duffy. 2002. New ranking algorithms for parsing and tagging: Kernels over discrete structures, and the voted perceptron. In Proceedings ofACL02.</rawString>
</citation>
<citation valid="true">
<authors>
<author>C Cortes</author>
<author>V Vapnik</author>
</authors>
<title>Support vector networks.</title>
<date>1995</date>
<booktitle>Machine Learning,</booktitle>
<pages>20--1</pages>
<contexts>
<context position="4588" citStr="Cortes and Vapnik, 1995" startWordPosition="715" endWordPosition="718"> algorithm is more efficient p = feedY Z Z → Y eat 91 Proceedings of the 2009 Conference on Empirical Methods in Natural Language Processing, pages 91–100, Singapore, 6-7 August 2009. c�2009 ACL and AFNLP and it is a valid kernel function. The paper is organized as follows. In Sec. 2, we firstly describe tripartite directed acyclic graphs (tDAGs) to model first-order feature (FOR) spaces. In Sec. 3, we then present the related work. In Sec. 4, we introduce the similarity function for these FOR spaces. This can be used as kernel function in kernel-based machines (e.g., support vector machines (Cortes and Vapnik, 1995)). We then introduce our efficient algorithm for computing the similarity among tDAGs. In Sec. 5, we analyze the computational efficiency of our algorithm showing that it is extremely more efficient than the algorithm proposed in (Moschitti and Zanzotto, 2007). Finally, in Sec. 6, we draw conclusions and plan the future work. 2 Representing first-order rules and sentence pairs as tripartite directed acyclic graphs As first step, we want to define the tripartite directed acyclic graphs (tDAGs). This is an extremely important class of graphs for the firstorder rule feature spaces we want to mode</context>
<context position="12244" citStr="Cortes and Vapnik, 1995" startWordPosition="2092" endWordPosition="2095">somorphism as the one implicitly used in (Collins and Duffy, 2002). After describing the isomorphism between tDAGs, We can present the idea of our efficient algorithm for computing K(G1, G2) (Sec. 4.3). We introduce the algorithms to make it a viable solution (Sec. 4.4). Finally, in Sec. 4.5, we report the kernel computation we compare against presented by (Zanzotto and Moschitti, 2006; Moschitti and Zanzotto, 2007). 4.1 Kernel functions over first-order rule feature spaces The first-order rule feature space we want to model is huge. If we use kernel-based machine learning models such as SVM (Cortes and Vapnik, 1995), we can implicitly define the space by defining its similarity functions, i.e., its kernel functions. We firstly introduce the first-order rule feature space and we then define the prototypical kernel function over this space. The first-order rule feature space (FOR) is in general the space of all the possible first-order 93 S S NP 1 NP VP VP NNS NP 3 NP 1 P1 = h , NNS1 NP 3 i VB VB Farmers feed NNS1 NNS3 Cows NN 2 eat NNS3 NN 2 animal extracts animal cows extracts S 2 S 2 NP 1 VP 2 NP 1 VP 2 NNS1 VB 2 NNS1 VB 2 SBAR S Pediatricians S IN suggest Pediatricians NP VP suggest P2 = h i , that NP </context>
</contexts>
<marker>Cortes, Vapnik, 1995</marker>
<rawString>C. Cortes and V. Vapnik. 1995. Support vector networks. Machine Learning, 20:1–25.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ido Dagan</author>
<author>Oren Glickman</author>
</authors>
<title>Probabilistic textual entailment: Generic applied modeling of language variability.</title>
<date>2004</date>
<booktitle>In Proceedings of the Workshop on Learning Methods for Text Understanding and Mining,</booktitle>
<location>Grenoble, France.</location>
<contexts>
<context position="1224" citStr="Dagan and Glickman, 2004" startWordPosition="176" endWordPosition="179">, it is a valid kernel function. 1 Introduction Natural language processing models are generally positive combinations between linguistic models and automatically learnt classifiers. As trees are extremely important in many linguistic theories, a large amount of works exploiting machine learning algorithms for NLP tasks has been developed for this class of data structures (Collins and Duffy, 2002; Moschitti, 2004). These works propose efficient algorithms for determining the similarity among two trees in tree fragment feature spaces. Yet, some NLP tasks such as textual entailment recognition (Dagan and Glickman, 2004; Dagan et al., 2006) and some linguistic theories such as HPSG (Pollard and Sag, 1994) require more general graphs and, then, more general algorithms for computing similarity among graphs. Unfortunately, algorithms for computing similarity among two general graphs in term of common subgraphs are still exponential (Ramon and G¨artner, 2003). In these cases, approximated algorithms have been proposed. For example, the one proposed in (G¨artner, 2003) counts the number of subpaths in common. The same happens for the one proposed in (Suzuki et al., 2003) that is applicable to a particular class o</context>
</contexts>
<marker>Dagan, Glickman, 2004</marker>
<rawString>Ido Dagan and Oren Glickman. 2004. Probabilistic textual entailment: Generic applied modeling of language variability. In Proceedings of the Workshop on Learning Methods for Text Understanding and Mining, Grenoble, France.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ido Dagan</author>
<author>Oren Glickman</author>
<author>Bernardo Magnini</author>
</authors>
<title>The pascal recognising textual entailment challenge.</title>
<date>2006</date>
<booktitle>LNAI 3944: MLCW 2005,</booktitle>
<pages>177--190</pages>
<editor>In Quionero-Candela et al., editor,</editor>
<publisher>Springer-Verlag.</publisher>
<location>Milan, Italy.</location>
<contexts>
<context position="1245" citStr="Dagan et al., 2006" startWordPosition="180" endWordPosition="183">ction. 1 Introduction Natural language processing models are generally positive combinations between linguistic models and automatically learnt classifiers. As trees are extremely important in many linguistic theories, a large amount of works exploiting machine learning algorithms for NLP tasks has been developed for this class of data structures (Collins and Duffy, 2002; Moschitti, 2004). These works propose efficient algorithms for determining the similarity among two trees in tree fragment feature spaces. Yet, some NLP tasks such as textual entailment recognition (Dagan and Glickman, 2004; Dagan et al., 2006) and some linguistic theories such as HPSG (Pollard and Sag, 1994) require more general graphs and, then, more general algorithms for computing similarity among graphs. Unfortunately, algorithms for computing similarity among two general graphs in term of common subgraphs are still exponential (Ramon and G¨artner, 2003). In these cases, approximated algorithms have been proposed. For example, the one proposed in (G¨artner, 2003) counts the number of subpaths in common. The same happens for the one proposed in (Suzuki et al., 2003) that is applicable to a particular class of graphs, i.e. the hi</context>
<context position="2681" citStr="Dagan et al., 2006" startWordPosition="409" endWordPosition="413">om in common between two graphs. Then, these algorithms approximate the feature spaces we need in these NLP tasks. For computing similarities in these feature spaces, we have to investigate if we can define a particular class of graphs for the class of tasks we want to solve. Once we focused the class of graph, we can explore efficient similarity algorithms. A very important class of graphs can be defined for tasks involving sentence pairs. In these cases, an important class of feature spaces is the one that represents first-order rewrite rules. For example, in textual entailment recognition (Dagan et al., 2006), we need to determine whether a text T implies a hypothesis H, e.g., whether or not “Farmers feed cows animal extracts” entails “Cows eat animal extracts” (T1, H1). If we want to learn textual entailment classifiers, we need to exploit first-order rules hidden in training instances. To positively exploit the training instance “Pediatricians suggest women to feed newborns breast milk” entails “Pediatricians suggest that newborns eat breast milk” (T2, H2) for classifying the above example, learning algorithms should learn that the two instances hide the first-order rule . The first-order rule f</context>
</contexts>
<marker>Dagan, Glickman, Magnini, 2006</marker>
<rawString>Ido Dagan, Oren Glickman, and Bernardo Magnini. 2006. The pascal recognising textual entailment challenge. In Quionero-Candela et al., editor, LNAI 3944: MLCW 2005, pages 177–190, Milan, Italy. Springer-Verlag.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Marie-Catherine de Marneffe</author>
<author>Bill MacCartney</author>
<author>Trond Grenager</author>
<author>Daniel Cer</author>
<author>Anna Rafferty</author>
<author>Christopher D Manning</author>
</authors>
<title>Learning to distinguish valid textual entailments.</title>
<date>2006</date>
<booktitle>In Proceedings of the Second PASCAL Challenges Workshop on Recognising Textual Entailment,</booktitle>
<location>Venice, Italy.</location>
<marker>de Marneffe, MacCartney, Grenager, Cer, Rafferty, Manning, 2006</marker>
<rawString>Marie-Catherine de Marneffe, Bill MacCartney, Trond Grenager, Daniel Cer, Anna Rafferty, and Christopher D. Manning. 2006. Learning to distinguish valid textual entailments. In Proceedings of the Second PASCAL Challenges Workshop on Recognising Textual Entailment, Venice, Italy.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jason Eisner</author>
</authors>
<title>Learning non-isomorphic tree mappings for machine translation.</title>
<date>2003</date>
<booktitle>In Proceedings of the 41st Annual Meeting of the Association for Computational Linguistics (ACL), Companion Volume,</booktitle>
<pages>205--208</pages>
<location>Sapporo,</location>
<contexts>
<context position="10795" citStr="Eisner, 2003" startWordPosition="1859" endWordPosition="1860">ature space of rewrite rules has been implicitly explored in (Wang and Neumann, 2007) but this work considers only ground rewrite rules. In (Zanzotto and Moschitti, 2006), tripartite directed acyclic graphs are implicitly introduced and exploited to build first-order rule feature spaces. Yet, both in (Zanzotto and Moschitti, 2006) and in (Moschitti and Zanzotto, 2007), the model proposed has two major limitations: it can represent rules with less than 7 variables and the proposed kernel is not a completely valid kernel as it uses the max function. In machine translation, some methods such as (Eisner, 2003) learn graph based rewrite rules for generative purposes. Yet, the method presented in (Eisner, 2003) can model first-order rewrite rules only with a very small amount of variables, i.e., two or three variables. 4 An efficient algorithm for computing the first-order rule space kernel In this section, we present our idea for an efficient algorithm for exploiting first-order rule feature spaces. In Sec. 4.1, we firstly define the similarity function, i.e., the kernel K(G1, G2), that we need to determine for correctly using first-order rules feature spaces. This kernel is strongly based on the is</context>
</contexts>
<marker>Eisner, 2003</marker>
<rawString>Jason Eisner. 2003. Learning non-isomorphic tree mappings for machine translation. In Proceedings of the 41st Annual Meeting of the Association for Computational Linguistics (ACL), Companion Volume, pages 205–208, Sapporo, July.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Thomas G¨artner</author>
</authors>
<title>A survey of kernels for structured data. SIGKDD Explorations.</title>
<date>2003</date>
<marker>G¨artner, 2003</marker>
<rawString>Thomas G¨artner. 2003. A survey of kernels for structured data. SIGKDD Explorations.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Aria D Haghighi</author>
<author>Andrew Y Ng</author>
<author>Christopher D Manning</author>
</authors>
<title>Robust textual inference via graph matching.</title>
<date>2005</date>
<booktitle>In HLT ’05: Proceedings of the conference on Human Language Technology and Empirical Methods in Natural Language Processing,</booktitle>
<pages>387--394</pages>
<publisher>Association</publisher>
<institution>for Computational Linguistics.</institution>
<location>Morristown, NJ, USA.</location>
<contexts>
<context position="9491" citStr="Haghighi et al., 2005" startWordPosition="1647" endWordPosition="1650">as reported in Fig. 3. 3 Related work Automatically learning classifiers for sentence pairs is extremely important for applications like textual entailment recognition, question answering, and machine translation. In textual entailment recognition, it is not hard to see graphs similar to tripartite directed acyclic graphs as ways of extracting features from examples to feed automatic classifiers. Yet, these graphs are generally not tripartite in the sense described in the previous section and they are not used to extract features representing first-order rewrite rules. In (Raina et al., 2005; Haghighi et al., 2005; Hickl et al., 2006), two connected graphs representing the two sentences s1 and s2 are used to compute distance features, i.e., features representing the distance between s1 and s2. The underlying idea is that lexical, syntactic, and semantic similarities between sentences in a pair are relevant features to classify sentence pairs in classes such as entail and not-entail. In (de Marneffe et al., 2006), first-order rewrite rule feature spaces have been explored. Yet, these spaces are extremely small. Only some features representing first-order rules have been explored. Pairs of graphs are use</context>
</contexts>
<marker>Haghighi, Ng, Manning, 2005</marker>
<rawString>Aria D. Haghighi, Andrew Y. Ng, and Christopher D. Manning. 2005. Robust textual inference via graph matching. In HLT ’05: Proceedings of the conference on Human Language Technology and Empirical Methods in Natural Language Processing, pages 387–394, Morristown, NJ, USA. Association for Computational Linguistics.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Andrew Hickl</author>
<author>John Williams</author>
<author>Jeremy Bensley</author>
<author>Kirk Roberts</author>
<author>Bryan Rink</author>
<author>Ying Shi</author>
</authors>
<title>Recognizing textual entailment with LCCs GROUNDHOG system.</title>
<date>2006</date>
<booktitle>In Bernardo Magnini and Ido Dagan, editors, Proceedings of the Second PASCAL Recognizing Textual Entailment Challenge,</booktitle>
<publisher>Springer-Verlag.</publisher>
<location>Venice, Italy.</location>
<contexts>
<context position="9512" citStr="Hickl et al., 2006" startWordPosition="1651" endWordPosition="1654">3 Related work Automatically learning classifiers for sentence pairs is extremely important for applications like textual entailment recognition, question answering, and machine translation. In textual entailment recognition, it is not hard to see graphs similar to tripartite directed acyclic graphs as ways of extracting features from examples to feed automatic classifiers. Yet, these graphs are generally not tripartite in the sense described in the previous section and they are not used to extract features representing first-order rewrite rules. In (Raina et al., 2005; Haghighi et al., 2005; Hickl et al., 2006), two connected graphs representing the two sentences s1 and s2 are used to compute distance features, i.e., features representing the distance between s1 and s2. The underlying idea is that lexical, syntactic, and semantic similarities between sentences in a pair are relevant features to classify sentence pairs in classes such as entail and not-entail. In (de Marneffe et al., 2006), first-order rewrite rule feature spaces have been explored. Yet, these spaces are extremely small. Only some features representing first-order rules have been explored. Pairs of graphs are used here to determine i</context>
</contexts>
<marker>Hickl, Williams, Bensley, Roberts, Rink, Shi, 2006</marker>
<rawString>Andrew Hickl, John Williams, Jeremy Bensley, Kirk Roberts, Bryan Rink, and Ying Shi. 2006. Recognizing textual entailment with LCCs GROUNDHOG system. In Bernardo Magnini and Ido Dagan, editors, Proceedings of the Second PASCAL Recognizing Textual Entailment Challenge, Venice, Italy. Springer-Verlag.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Thorsten Joachims</author>
</authors>
<title>Making large-scale svm learning practical.</title>
<date>1999</date>
<booktitle>Advances in Kernel MethodsSupport Vector Learning.</booktitle>
<editor>In B. Schlkopf, C. Burges, and A. Smola, editors,</editor>
<publisher>MIT Press.</publisher>
<contexts>
<context position="29419" citStr="Joachims, 1999" startWordPosition="5489" endWordPosition="5490">nential with respect to the set of alternative constraints C. Yet, due to what presented in Sec. 4.4 and as the set C* is usually very small, the average complexity is extremely low. Following the theory on the average-cost computational complexity (Wang, 1997), we estimated the behavior of the algorithms on a large distribution of cases. We then compared the computing times of the two algorithms. Finally, as K and Kmax compute slightly different kernels, we compare the accuracy of the two methods. We implemented both algorithms K(G1, G2) and Kmax(G1, G2) in support vector machine classifier (Joachims, 1999) and we experimented with both implementations on the same machine. We hereafter analyze the results in term of execution time (Sec. 5.1) and in term of accuracy (Sec. 5.2). 5.1 Average computing time analysis For this first set of experiments, the source of examples is the one of the recognizing textual entailment challenge, i.e., RTE2 (Bar-Haim et al., 98 #ofplaceholders Figure 8: Total execution time in seconds (s) of the training phase on RTE2 wrt. different numbers of allowed placeholders 2006). The dataset of the challenge has 1,600 sentence pairs. The computational cost of both K(G1, G2</context>
</contexts>
<marker>Joachims, 1999</marker>
<rawString>Thorsten Joachims. 1999. Making large-scale svm learning practical. In B. Schlkopf, C. Burges, and A. Smola, editors, Advances in Kernel MethodsSupport Vector Learning. MIT Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Johannes K¨obler</author>
<author>Uwe Sch¨oning</author>
<author>Jacobo Tor´an</author>
</authors>
<title>The graph isomorphism problem: its structural complexity.</title>
<date>1993</date>
<publisher>Birkhauser Verlag,</publisher>
<location>Basel, Switzerland, Switzerland.</location>
<marker>K¨obler, Sch¨oning, Tor´an, 1993</marker>
<rawString>Johannes K¨obler, Uwe Sch¨oning, and Jacobo Tor´an. 1993. The graph isomorphism problem: its structural complexity. Birkhauser Verlag, Basel, Switzerland, Switzerland.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Alessandro Moschitti</author>
<author>Fabio Massimo Zanzotto</author>
</authors>
<title>Fast and effective kernels for relational learning from texts.</title>
<date>2007</date>
<booktitle>In Proceedings of the International Conference ofMachine Learning (ICML).</booktitle>
<location>Corvallis, Oregon.</location>
<contexts>
<context position="3959" citStr="Moschitti and Zanzotto, 2007" startWordPosition="607" endWordPosition="610">ti, 2006), gives high performances in term of accuracy for textual entailment recognition with respect to other features spaces. In this paper, we propose a novel class of graphs, the tripartite directed acyclic graphs (tDAGs), that model first-order rule feature spaces and, using this class of graphs, we introduce a novel algorithm for computing the similarity in first-order rewrite rule feature spaces. The possibility of explicitly representing the first-order feature space as subgraphs of tDAGs makes the derived similarity function a valid kernel. With respect to the algorithm proposed in (Moschitti and Zanzotto, 2007), our algorithm is more efficient p = feedY Z Z → Y eat 91 Proceedings of the 2009 Conference on Empirical Methods in Natural Language Processing, pages 91–100, Singapore, 6-7 August 2009. c�2009 ACL and AFNLP and it is a valid kernel function. The paper is organized as follows. In Sec. 2, we firstly describe tripartite directed acyclic graphs (tDAGs) to model first-order feature (FOR) spaces. In Sec. 3, we then present the related work. In Sec. 4, we introduce the similarity function for these FOR spaces. This can be used as kernel function in kernel-based machines (e.g., support vector machi</context>
<context position="10552" citStr="Moschitti and Zanzotto, 2007" startWordPosition="1815" endWordPosition="1818"> feature spaces have been explored. Yet, these spaces are extremely small. Only some features representing first-order rules have been explored. Pairs of graphs are used here to determine if a feature is active or not, i.e., the rule fires or not. A larger feature space of rewrite rules has been implicitly explored in (Wang and Neumann, 2007) but this work considers only ground rewrite rules. In (Zanzotto and Moschitti, 2006), tripartite directed acyclic graphs are implicitly introduced and exploited to build first-order rule feature spaces. Yet, both in (Zanzotto and Moschitti, 2006) and in (Moschitti and Zanzotto, 2007), the model proposed has two major limitations: it can represent rules with less than 7 variables and the proposed kernel is not a completely valid kernel as it uses the max function. In machine translation, some methods such as (Eisner, 2003) learn graph based rewrite rules for generative purposes. Yet, the method presented in (Eisner, 2003) can model first-order rewrite rules only with a very small amount of variables, i.e., two or three variables. 4 An efficient algorithm for computing the first-order rule space kernel In this section, we present our idea for an efficient algorithm for expl</context>
<context position="12039" citStr="Moschitti and Zanzotto, 2007" startWordPosition="2059" endWordPosition="2062">en graphs. A relevant idea of this paper is the observation that we can define an efficient way to detect the isomorphism between the tDAGs (Sec. 4.2). This algorithm exploits the efficient algorithms of tree isomorphism as the one implicitly used in (Collins and Duffy, 2002). After describing the isomorphism between tDAGs, We can present the idea of our efficient algorithm for computing K(G1, G2) (Sec. 4.3). We introduce the algorithms to make it a viable solution (Sec. 4.4). Finally, in Sec. 4.5, we report the kernel computation we compare against presented by (Zanzotto and Moschitti, 2006; Moschitti and Zanzotto, 2007). 4.1 Kernel functions over first-order rule feature spaces The first-order rule feature space we want to model is huge. If we use kernel-based machine learning models such as SVM (Cortes and Vapnik, 1995), we can implicitly define the space by defining its similarity functions, i.e., its kernel functions. We firstly introduce the first-order rule feature space and we then define the prototypical kernel function over this space. The first-order rule feature space (FOR) is in general the space of all the possible first-order 93 S S NP 1 NP VP VP NNS NP 3 NP 1 P1 = h , NNS1 NP 3 i VB VB Farmers </context>
<context position="24123" citStr="Moschitti and Zanzotto, 2007" startWordPosition="4504" endWordPosition="4507">to the size of A1 and A2. Yet, the average case complexity (Wang, 1997) is promising. The set C is generally very small with respect to the worst case. If F(A1,A2) are all the possible correspondences between the nodes A1 and A2, it happens that |C |&lt;&lt; |F(A1,A2)| where |F(A1,A2) |is the worst case. For example, in the case of P1 and P2, the cardinality of C = {{(1 , 1 )},{(1 , 3 ), (3 , 4 ), ( 2 , 5 )}} is extremely smaller than the one of F(A1,A2) = {{( 1 ,1 ),( 2 ,2 ),( 3 ,3 )}, {(1,2 ),(2,1 ),( 3 ,3 )}, {(1 ,2 ),( 2 ,3 ),( 3 ,1 )}, )}}. In Sec. 4.5 we argue that the algorithm presented in (Moschitti and Zanzotto, 2007) has the worst-case complexity. Moreover, the set C* is extremely smaller than 211,...,IC11 due to the above property (6). We will analyze the average-case complexity with respect to the worst-case complexity in Sec. 5. 4.4 Enabling the efficient kernel function The above idea for computing the kernel function is extremely interesting. Yet, we need to make it viable by describing the way we can determine efficiently the three main parts of the equation (7): 1) the set of alternative constraints C (Sec. 4.4.1); 2) the set C* of all the possible intersections of constraints in C (Sec. 4.4.2); an</context>
<context position="27384" citStr="Moschitti and Zanzotto, 2007" startWordPosition="5140" endWordPosition="5144">2; C2 ← ∅ C* ← C ∪ C+ ∪ {∅} Figure 6: Algorithm for computing C* 40 30 50 20 10 0 K(G1, G2) Kmax(G1, G2) ms 0 10 20 30 40 50 the corresponding addend. It is possible to demonstrate that: N(c) = 1 − � Nc&apos; (9) c&apos;EC* c&apos;Dc This recursive formulation of the equation allows us to easily determine the value of N(c) for every c belonging to C*. It is possible to prove this property using set properties and the binomial theorem. The proof is omitted for lack of space. 4.5 Reviewing the strictly related work To understand if ours is an efficient algorithm, we compare it with the algorithm presented by (Moschitti and Zanzotto, 2007). We will hereafter call this algorithm Kmax. The Kmax algorithm and kernel is an approximation of what is a kernel needed for a FOR space as it is not difficult to demonstrate that Kmax(G1, G2) ≤ K(G1, G2). The Kmax approximation is based on maximization over the set of possible correspondences of the placeholders. Following our formulation, this kernel appears as: Kmax(G1,G2) = = max cE.T(A1,A2) KS(τ1,τ2,c)KS(γ1,γ2,c) (10) where F(A1,A2) are all the possible correspondences between the nodes A1 and A2 of the two tDAGs as the one presented in Sec. 4.3. This formulation of the kernel has the w</context>
<context position="28768" citStr="Moschitti and Zanzotto, 2007" startWordPosition="5379" endWordPosition="5382">presented by (Zanzotto and Moschitti, 2006) and refined by (Moschitti and Zanzotto, 2007) based on the algorithm for tree fragment feature n × m placeholders Figure 7: Mean execution time in milliseconds (ms) of the two algorithms wrt. n × m where n and m are the number of placeholders of the two tDAGs spaces (Collins and Duffy, 2002). As we are using the same basic kernel, we can empirically compare the two methods. 5 Experimental evaluation In this section we want to empirically estimate the benefits on the computational cost of our novel algorithm with respect to the algorithm proposed by (Moschitti and Zanzotto, 2007). Our algorithm is in principle exponential with respect to the set of alternative constraints C. Yet, due to what presented in Sec. 4.4 and as the set C* is usually very small, the average complexity is extremely low. Following the theory on the average-cost computational complexity (Wang, 1997), we estimated the behavior of the algorithms on a large distribution of cases. We then compared the computing times of the two algorithms. Finally, as K and Kmax compute slightly different kernels, we compare the accuracy of the two methods. We implemented both algorithms K(G1, G2) and Kmax(G1, G2) in</context>
</contexts>
<marker>Moschitti, Zanzotto, 2007</marker>
<rawString>Alessandro Moschitti and Fabio Massimo Zanzotto. 2007. Fast and effective kernels for relational learning from texts. In Proceedings of the International Conference ofMachine Learning (ICML). Corvallis, Oregon.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Alessandro Moschitti</author>
</authors>
<title>A study on convolution kernels for shallow semantic parsing.</title>
<date>2004</date>
<booktitle>In proceedings of the ACL,</booktitle>
<location>Barcelona,</location>
<contexts>
<context position="1017" citStr="Moschitti, 2004" startWordPosition="146" endWordPosition="147">ting the similarity in first-order rewrite rule feature spaces. Our algorithm is extremely efficient and, as it computes the similarity of instances that can be represented in explicit feature spaces, it is a valid kernel function. 1 Introduction Natural language processing models are generally positive combinations between linguistic models and automatically learnt classifiers. As trees are extremely important in many linguistic theories, a large amount of works exploiting machine learning algorithms for NLP tasks has been developed for this class of data structures (Collins and Duffy, 2002; Moschitti, 2004). These works propose efficient algorithms for determining the similarity among two trees in tree fragment feature spaces. Yet, some NLP tasks such as textual entailment recognition (Dagan and Glickman, 2004; Dagan et al., 2006) and some linguistic theories such as HPSG (Pollard and Sag, 1994) require more general graphs and, then, more general algorithms for computing similarity among graphs. Unfortunately, algorithms for computing similarity among two general graphs in term of common subgraphs are still exponential (Ramon and G¨artner, 2003). In these cases, approximated algorithms have been</context>
</contexts>
<marker>Moschitti, 2004</marker>
<rawString>Alessandro Moschitti. 2004. A study on convolution kernels for shallow semantic parsing. In proceedings of the ACL, Barcelona, Spain.</rawString>
</citation>
<citation valid="true">
<authors>
<author>C Pollard</author>
<author>I A Sag</author>
</authors>
<title>Head-driven Phrase Structured Grammar.</title>
<date>1994</date>
<location>Chicago CSLI, Stanford.</location>
<contexts>
<context position="1311" citStr="Pollard and Sag, 1994" startWordPosition="191" endWordPosition="194">nerally positive combinations between linguistic models and automatically learnt classifiers. As trees are extremely important in many linguistic theories, a large amount of works exploiting machine learning algorithms for NLP tasks has been developed for this class of data structures (Collins and Duffy, 2002; Moschitti, 2004). These works propose efficient algorithms for determining the similarity among two trees in tree fragment feature spaces. Yet, some NLP tasks such as textual entailment recognition (Dagan and Glickman, 2004; Dagan et al., 2006) and some linguistic theories such as HPSG (Pollard and Sag, 1994) require more general graphs and, then, more general algorithms for computing similarity among graphs. Unfortunately, algorithms for computing similarity among two general graphs in term of common subgraphs are still exponential (Ramon and G¨artner, 2003). In these cases, approximated algorithms have been proposed. For example, the one proposed in (G¨artner, 2003) counts the number of subpaths in common. The same happens for the one proposed in (Suzuki et al., 2003) that is applicable to a particular class of graphs, i.e. the hierarchical directed acyclic graphs. These algorithms do not comput</context>
<context position="6707" citStr="Pollard and Sag, 1994" startWordPosition="1088" endWordPosition="1091">connect tree nodes having variables with eat Figure 1: A simple rewrite rule seen as a graph Figure 2: A sample pair seen as a graph the corresponding unlabelled node. The result is a graph as the one in Fig. 1. The variables Y and Z are represented by the unlabelled nodes between the trees. In the same way we can represent the sentence pair (T1, H1) using graph with explicit links between related words and nodes (see Fig. 2). We can link words using anchoring methods as in (Raina et al., 2005). These links can then be propagated in the syntactic tree using semantic heads of the constituents (Pollard and Sag, 1994). The rule p1 matches over the pair (T1, H1) if the graph p1 is among the subgraphs of the graph in Fig. 2. Both rules and sentence pairs are graphs of the same type. These graphs are basically two trees connected through an intermediate set of nodes representing variables in the rules and relations between nodes in the sentence pairs. We will hereafter call these graphs tripartite directed acyclic graphs (tDAGs). The formal definition follows. Definition tDAG: A tripartite directed acyclic graph is a graph G = (N, E) where • the set of nodes N is partitioned in three sets Nt, Ng, and A • the </context>
</contexts>
<marker>Pollard, Sag, 1994</marker>
<rawString>C. Pollard and I.A. Sag. 1994. Head-driven Phrase Structured Grammar. Chicago CSLI, Stanford.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Rajat Raina</author>
<author>Aria Haghighi</author>
<author>Christopher Cox</author>
<author>Jenny Finkel</author>
<author>Jeff Michels</author>
<author>Kristina Toutanova</author>
<author>Bill MacCartney</author>
<author>Marie-Catherine de Marneffe</author>
<author>Manning Christopher</author>
<author>Andrew Y Ng</author>
</authors>
<title>Robust textual inference using diverse knowledge sources.</title>
<date>2005</date>
<booktitle>In Proceedings of the 1st Pascal Challenge Workshop,</booktitle>
<location>Southampton, UK.</location>
<marker>Raina, Haghighi, Cox, Finkel, Michels, Toutanova, MacCartney, de Marneffe, Christopher, Ng, 2005</marker>
<rawString>Rajat Raina, Aria Haghighi, Christopher Cox, Jenny Finkel, Jeff Michels, Kristina Toutanova, Bill MacCartney, Marie-Catherine de Marneffe, Manning Christopher, and Andrew Y. Ng. 2005. Robust textual inference using diverse knowledge sources. In Proceedings of the 1st Pascal Challenge Workshop, Southampton, UK.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jan Ramon</author>
<author>Thomas G¨artner</author>
</authors>
<title>Expressivity versus efficiency of graph kernels.</title>
<date>2003</date>
<booktitle>In First International Workshop on Mining Graphs, Trees and Sequences.</booktitle>
<marker>Ramon, G¨artner, 2003</marker>
<rawString>Jan Ramon and Thomas G¨artner. 2003. Expressivity versus efficiency of graph kernels. In First International Workshop on Mining Graphs, Trees and Sequences.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jun Suzuki</author>
<author>Tsutomu Hirao</author>
<author>Yutaka Sasaki</author>
<author>Eisaku Maeda</author>
</authors>
<title>Hierarchical directed acyclic graph kernel: Methods for structured natural language data. In</title>
<date>2003</date>
<booktitle>In Proceedings of the 41st Annual Meeting of the Association for Computational Linguistics,</booktitle>
<pages>32--39</pages>
<contexts>
<context position="1781" citStr="Suzuki et al., 2003" startWordPosition="266" endWordPosition="269">uch as textual entailment recognition (Dagan and Glickman, 2004; Dagan et al., 2006) and some linguistic theories such as HPSG (Pollard and Sag, 1994) require more general graphs and, then, more general algorithms for computing similarity among graphs. Unfortunately, algorithms for computing similarity among two general graphs in term of common subgraphs are still exponential (Ramon and G¨artner, 2003). In these cases, approximated algorithms have been proposed. For example, the one proposed in (G¨artner, 2003) counts the number of subpaths in common. The same happens for the one proposed in (Suzuki et al., 2003) that is applicable to a particular class of graphs, i.e. the hierarchical directed acyclic graphs. These algorithms do not compute the number of subgraphs Lorenzo Dell’Arciprete University of Rome “Tor Vergata” Via del Politecnico 1 00133 Roma, Italy lorenzo.dellarciprete@gmail.com in common between two graphs. Then, these algorithms approximate the feature spaces we need in these NLP tasks. For computing similarities in these feature spaces, we have to investigate if we can define a particular class of graphs for the class of tasks we want to solve. Once we focused the class of graph, we can</context>
</contexts>
<marker>Suzuki, Hirao, Sasaki, Maeda, 2003</marker>
<rawString>Jun Suzuki, Tsutomu Hirao, Yutaka Sasaki, and Eisaku Maeda. 2003. Hierarchical directed acyclic graph kernel: Methods for structured natural language data. In In Proceedings of the 41st Annual Meeting of the Association for Computational Linguistics, pages 32–39.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Rui Wang</author>
<author>G¨unter Neumann</author>
</authors>
<title>Recognizing textual entailment using a subsequence kernel method.</title>
<date>2007</date>
<booktitle>In Proceedings of the Twenty-Second AAAI Conference on Artificial Intelligence (AAAI07),</booktitle>
<location>Vancouver, Canada.</location>
<contexts>
<context position="10267" citStr="Wang and Neumann, 2007" startWordPosition="1773" endWordPosition="1776">he distance between s1 and s2. The underlying idea is that lexical, syntactic, and semantic similarities between sentences in a pair are relevant features to classify sentence pairs in classes such as entail and not-entail. In (de Marneffe et al., 2006), first-order rewrite rule feature spaces have been explored. Yet, these spaces are extremely small. Only some features representing first-order rules have been explored. Pairs of graphs are used here to determine if a feature is active or not, i.e., the rule fires or not. A larger feature space of rewrite rules has been implicitly explored in (Wang and Neumann, 2007) but this work considers only ground rewrite rules. In (Zanzotto and Moschitti, 2006), tripartite directed acyclic graphs are implicitly introduced and exploited to build first-order rule feature spaces. Yet, both in (Zanzotto and Moschitti, 2006) and in (Moschitti and Zanzotto, 2007), the model proposed has two major limitations: it can represent rules with less than 7 variables and the proposed kernel is not a completely valid kernel as it uses the max function. In machine translation, some methods such as (Eisner, 2003) learn graph based rewrite rules for generative purposes. Yet, the metho</context>
</contexts>
<marker>Wang, Neumann, 2007</marker>
<rawString>Rui Wang and G¨unter Neumann. 2007. Recognizing textual entailment using a subsequence kernel method. In Proceedings of the Twenty-Second AAAI Conference on Artificial Intelligence (AAAI07), July 22-26, Vancouver, Canada.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jie Wang</author>
</authors>
<title>Average-case computational complexity theory.</title>
<date>1997</date>
<pages>295--328</pages>
<contexts>
<context position="23565" citStr="Wang, 1997" startWordPosition="4386" endWordPosition="4387">en happens that two different J1 and J2 in 211,...,IC11 generate the same c, i.e. �c = �ci = ci (6) iEJ1 iEJ2 Then, we can define C* as the set of all intersections of constraints in C, i.e. C* = {c(J)|J ∈ 211,...,IC11}. We can rewrite the equation as: K(G1, G2) = �= KS(τ1,τ2,c)KS(γ1,γ2,c)N(c) (7) cEC* where N(c) = � (−1)jJj−1 (8) JE2{1,...,|C|} c=c(J) The complexity of the above kernel strongly depends on the cardinality of C and the related cardinality of C*. The worst-case computational complexity is still exponential with respect to the size of A1 and A2. Yet, the average case complexity (Wang, 1997) is promising. The set C is generally very small with respect to the worst case. If F(A1,A2) are all the possible correspondences between the nodes A1 and A2, it happens that |C |&lt;&lt; |F(A1,A2)| where |F(A1,A2) |is the worst case. For example, in the case of P1 and P2, the cardinality of C = {{(1 , 1 )},{(1 , 3 ), (3 , 4 ), ( 2 , 5 )}} is extremely smaller than the one of F(A1,A2) = {{( 1 ,1 ),( 2 ,2 ),( 3 ,3 )}, {(1,2 ),(2,1 ),( 3 ,3 )}, {(1 ,2 ),( 2 ,3 ),( 3 ,1 )}, )}}. In Sec. 4.5 we argue that the algorithm presented in (Moschitti and Zanzotto, 2007) has the worst-case complexity. Moreover, </context>
<context position="29065" citStr="Wang, 1997" startWordPosition="5430" endWordPosition="5431">lins and Duffy, 2002). As we are using the same basic kernel, we can empirically compare the two methods. 5 Experimental evaluation In this section we want to empirically estimate the benefits on the computational cost of our novel algorithm with respect to the algorithm proposed by (Moschitti and Zanzotto, 2007). Our algorithm is in principle exponential with respect to the set of alternative constraints C. Yet, due to what presented in Sec. 4.4 and as the set C* is usually very small, the average complexity is extremely low. Following the theory on the average-cost computational complexity (Wang, 1997), we estimated the behavior of the algorithms on a large distribution of cases. We then compared the computing times of the two algorithms. Finally, as K and Kmax compute slightly different kernels, we compare the accuracy of the two methods. We implemented both algorithms K(G1, G2) and Kmax(G1, G2) in support vector machine classifier (Joachims, 1999) and we experimented with both implementations on the same machine. We hereafter analyze the results in term of execution time (Sec. 5.1) and in term of accuracy (Sec. 5.2). 5.1 Average computing time analysis For this first set of experiments, t</context>
</contexts>
<marker>Wang, 1997</marker>
<rawString>Jie Wang. 1997. Average-case computational complexity theory. pages 295–328.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Fabio Massimo Zanzotto</author>
<author>Alessandro Moschitti</author>
</authors>
<title>Automatic learning of textual entailments with cross-pair similarities.</title>
<date>2006</date>
<booktitle>In Proceedings of the 21st Coling and 44th ACL,</booktitle>
<pages>401--408</pages>
<location>Sydney, Australia,</location>
<contexts>
<context position="3339" citStr="Zanzotto and Moschitti, 2006" startWordPosition="511" endWordPosition="514">r a text T implies a hypothesis H, e.g., whether or not “Farmers feed cows animal extracts” entails “Cows eat animal extracts” (T1, H1). If we want to learn textual entailment classifiers, we need to exploit first-order rules hidden in training instances. To positively exploit the training instance “Pediatricians suggest women to feed newborns breast milk” entails “Pediatricians suggest that newborns eat breast milk” (T2, H2) for classifying the above example, learning algorithms should learn that the two instances hide the first-order rule . The first-order rule feature space, introduced by (Zanzotto and Moschitti, 2006), gives high performances in term of accuracy for textual entailment recognition with respect to other features spaces. In this paper, we propose a novel class of graphs, the tripartite directed acyclic graphs (tDAGs), that model first-order rule feature spaces and, using this class of graphs, we introduce a novel algorithm for computing the similarity in first-order rewrite rule feature spaces. The possibility of explicitly representing the first-order feature space as subgraphs of tDAGs makes the derived similarity function a valid kernel. With respect to the algorithm proposed in (Moschitti</context>
<context position="10352" citStr="Zanzotto and Moschitti, 2006" startWordPosition="1786" endWordPosition="1789">and semantic similarities between sentences in a pair are relevant features to classify sentence pairs in classes such as entail and not-entail. In (de Marneffe et al., 2006), first-order rewrite rule feature spaces have been explored. Yet, these spaces are extremely small. Only some features representing first-order rules have been explored. Pairs of graphs are used here to determine if a feature is active or not, i.e., the rule fires or not. A larger feature space of rewrite rules has been implicitly explored in (Wang and Neumann, 2007) but this work considers only ground rewrite rules. In (Zanzotto and Moschitti, 2006), tripartite directed acyclic graphs are implicitly introduced and exploited to build first-order rule feature spaces. Yet, both in (Zanzotto and Moschitti, 2006) and in (Moschitti and Zanzotto, 2007), the model proposed has two major limitations: it can represent rules with less than 7 variables and the proposed kernel is not a completely valid kernel as it uses the max function. In machine translation, some methods such as (Eisner, 2003) learn graph based rewrite rules for generative purposes. Yet, the method presented in (Eisner, 2003) can model first-order rewrite rules only with a very sm</context>
<context position="12008" citStr="Zanzotto and Moschitti, 2006" startWordPosition="2055" endWordPosition="2058">based on the isomorphism between graphs. A relevant idea of this paper is the observation that we can define an efficient way to detect the isomorphism between the tDAGs (Sec. 4.2). This algorithm exploits the efficient algorithms of tree isomorphism as the one implicitly used in (Collins and Duffy, 2002). After describing the isomorphism between tDAGs, We can present the idea of our efficient algorithm for computing K(G1, G2) (Sec. 4.3). We introduce the algorithms to make it a viable solution (Sec. 4.4). Finally, in Sec. 4.5, we report the kernel computation we compare against presented by (Zanzotto and Moschitti, 2006; Moschitti and Zanzotto, 2007). 4.1 Kernel functions over first-order rule feature spaces The first-order rule feature space we want to model is huge. If we use kernel-based machine learning models such as SVM (Cortes and Vapnik, 1995), we can implicitly define the space by defining its similarity functions, i.e., its kernel functions. We firstly introduce the first-order rule feature space and we then define the prototypical kernel function over this space. The first-order rule feature space (FOR) is in general the space of all the possible first-order 93 S S NP 1 NP VP VP NNS NP 3 NP 1 P1 =</context>
<context position="28182" citStr="Zanzotto and Moschitti, 2006" startWordPosition="5278" endWordPosition="5281">nstrate that Kmax(G1, G2) ≤ K(G1, G2). The Kmax approximation is based on maximization over the set of possible correspondences of the placeholders. Following our formulation, this kernel appears as: Kmax(G1,G2) = = max cE.T(A1,A2) KS(τ1,τ2,c)KS(γ1,γ2,c) (10) where F(A1,A2) are all the possible correspondences between the nodes A1 and A2 of the two tDAGs as the one presented in Sec. 4.3. This formulation of the kernel has the worst case complexity of our formulation, i.e., Eq. 7. For computing the basic kernel for the extended trees, i.e. KS(01, 02, c) we use the model algorithm presented by (Zanzotto and Moschitti, 2006) and refined by (Moschitti and Zanzotto, 2007) based on the algorithm for tree fragment feature n × m placeholders Figure 7: Mean execution time in milliseconds (ms) of the two algorithms wrt. n × m where n and m are the number of placeholders of the two tDAGs spaces (Collins and Duffy, 2002). As we are using the same basic kernel, we can empirically compare the two methods. 5 Experimental evaluation In this section we want to empirically estimate the benefits on the computational cost of our novel algorithm with respect to the algorithm proposed by (Moschitti and Zanzotto, 2007). Our algorith</context>
</contexts>
<marker>Zanzotto, Moschitti, 2006</marker>
<rawString>Fabio Massimo Zanzotto and Alessandro Moschitti. 2006. Automatic learning of textual entailments with cross-pair similarities. In Proceedings of the 21st Coling and 44th ACL, pages 401–408. Sydney, Australia, July.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>