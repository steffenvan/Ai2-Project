<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<sectionHeader confidence="0.503585857142857" genericHeader="method">
PROBLEMS IN NATURAL-LANGUAGE INTERFACE TO DBMS
WITH EXAMPLES FROM EUFID
Marjorie Templeton
John Burger
System Development Corporation
Santa Monica, California
ABSTRACT
</sectionHeader>
<bodyText confidence="0.999824333333333">
For five years the End-User Friendly
Interface to Data management (EUFID) pro-
ject team at System Development Corpora-
tion worked on the design and implementa-
tion of a Natural-Language Interface
(NLI) system that was to be independent
of both the application and the database
management system. In this paper we
describe application, natural-language
and database management problems involved
in NLI development, with specific refer-
ence to the EUFID system as an example.
</bodyText>
<sectionHeader confidence="0.985036" genericHeader="method">
I INTRODUCTION
</sectionHeader>
<bodyText confidence="0.99812918292683">
From 1976 to 1981 SDC was involved
in the development of the End-User
Friendly Interface to Data management
(EUFID) system, a natural-language inter-
face (NLI) that is designed to be
independent of both the application and
the underlying database management system
(DBMS). [TEMP79, TEMP80, BURG80,
BURG82]. The EUFID system permits users
to communicate with database management
systems in natural English rather than
formal query languages. It is assumed
that the application domain is well
defined and bounded, that users share a
common language to address the applica-
tion, and that users may have little
experience with computers or DBMSs but
are competent in the application area.
At least three broad categories of
issues had to be addressed during EUFID
development, and it is apparent that they
are common to any general natural-
language interface to database management
systems.
The first category involves the
application: how to characterize the
requirements of the human-machine dialo-
gue and interaction, capture that infor-
mation efficiently, formalize the infor-
mation and incorporate that knowledge
into a framework that can be used by the
system. The major problems in this area
are knowledge acquisition and representa-
tion. For many NLI systems, bringing up
a new application requires extensive
effort by system designers with coopera-
tion from a representative set of end-
users. Tools that could assist in
automating this process are badly needed.
The second set of issues involves
language processing techniques: how to
assign constituent structure and
interpretation to queries using robust
and general methods that allow extension
to additional lexical items, sentence
types and semantic relationships. Some
NLI systems distinguish the assignment of
syntactic structure, or parsing, from the
interpretation. Other systems, including
EUFID, combine information about consti-
tuent and semantic structure into an
Integrated semantic grammar.
The third class involves database
issues: how to actually perform the
intent of the natural-language question
by formulating the correct structured
query and efficiently navigating through
the database to retrieve the right
answer. This involves a thorough under-
standing of the DBMS structure underlying
the application, the operations and func-
tions the query language supports, and
the nature and volatility of the data-
base.
Obviously issues in these three
areas are related, and the knowledge
needed to deal with them may be distri-
buted throughout a natural-language
interface system. The purpose of this
paper is to show how such issues might be
addressed in NLI development, with illus-
trations from EUFID.
The next section includes a brief
review of related work, and an overview
of the EUFID system. The third section
describes the goals that EUFID achieved,
and section four discusses in detail some
of the major application, language, and
database problems that arose. Section
five suggests guidelines for determining
whether an application is an appropriate
target for a natural-language interface.
</bodyText>
<page confidence="0.998077">
3
</page>
<sectionHeader confidence="0.783516" genericHeader="method">
II BACKGROUND
</sectionHeader>
<bodyText confidence="0.994812055555555">
Over the past two decades a consid-
erable amount of work has gone into the
development of natural-language systems.
Early developments were in the areas of
text processing, syntactic parsing tech-
niques, machine translation, and early
attempts at English-language question
answering systems. Several early
question-answering experiments are
reviewed by R. F. Simmons in (SIMM65].
Waltz has edited a collection of short
papers on topics related to natural-
language and artificial intelligence in a
survey of NLI research (WALT77]. A sur-
vey of NLIs and evaluation of several
systems with respect to their applicabil-
ity to command and control environments
can be found in (05179].
</bodyText>
<sectionHeader confidence="0.881273" genericHeader="method">
A. RELATED WORK
</sectionHeader>
<bodyText confidence="0.931032333333333">
While few NLIs have reached the com-
mercial marketplace, many systems have
contributed to advancing the state of the
art. Several representative systems and
the problems they addressed are described
in this section.
</bodyText>
<listItem confidence="0.8816548">
1. CONVERSE [KELL71] used formal syn-
tactic analysis to generate surface-
and deep-structure parsings together
with formal semantic transformation
rules to produce queries for a
</listItem>
<bodyText confidence="0.8980535">
built-in relational DBMS. It was
written in SDC LISP and ran on IBM
370 computers. Started in 1968, it
was one of the first natural-
language processors to be built for
the purpose of querying a separate
data management system.
2. LADDER [HEND77] was designed to
access large distributed databases.
It is implemented in INTERLISP, runs
on a PDP-10, and can interface to
different DBMSs with proper confi-
guration. It uses a semantic gram-
mar and, like EUFID and most NLIs, a
different grammar must be defined
for each application.
</bodyText>
<listItem confidence="0.81777125">
3. The Lunar Rocks system LSNLIS
[W00072] was the first to use the
Augmented Transition Network (ATN)
grammar. Written in LISP, it
transformed formally parsed ques-
tions into representations of the
first-order predicate calculus for
deductive processing against a
built-in DBMS.
4. PHLIQA1 (SCHA771 uses a syntactic
parser which runs as a separate pass
from the semantic understanding
</listItem>
<bodyText confidence="0.746938772727273">
passes. This system is mainly
involved with problems of semantics
and has three separate layers of
semantic understanding. The layers
are called &amp;quot;English Formal
Language&amp;quot;, &amp;quot;World Model Language&amp;quot;,
and &amp;quot;Data Base Language&amp;quot; and appear
to correspond roughly to the &amp;quot;exter-
nal&amp;quot;, &amp;quot;conceptual&amp;quot;, and &amp;quot;internal&amp;quot;
views of data as described by C. J.
Date (DATE771. PHLIQA1 can inter-
face to a variety of database struc-
tures and DBMSs.
5. The Programmed LANguage-based
Enquiry System (PLANES) [WALT78]
uses an ATN based parser and a
semantic case frame analysis to
understand questions. Case frames
are used to handle pronominal and
elliptical reference and to generate
responses to clarify partially
interpreted questions.
6 REL (THOM69], initially written
entirely in assembler code for an
IBM360, has been in continuous
development since 1967. REL allows
a user to make interactive exten-
sions to the grammar and semantics
of the system. It uses a formal
grammar expressed as a set of gen-
eral re-write rules with semantic
transformations attached to each
rule. Answers are obtained from a
built-in database.
7. RENDEZVOUS (CODD74] addresses the
problem of certainty regarding the
machine&apos;s understanding of the
user&apos;s question. It engages the
user in dialogue to specify and
disambiguate the question and will
not route the formal query to the
relational DBMS until the user is
satisfied with the machine&apos;s
interpretation.
</bodyText>
<listItem confidence="0.993361888888889">
8. ROBOT (HARR78] is one of the few NLI
systems currently available on the
commercial market. It is the basis
for Cullinane&apos;s OnLine English
[CULL80] and Artificial Intelligence
Corporation&apos;s Intellect (EDP82). It
uses an extracted version of the
database for lexical data to assist
the ATN parser.
9. TORUS (MYL0761, like RENDEZVOUS,
engages the user in a dialogue to
specify and disambiguate the user&apos;s
question. It is a research oriented
system looking at the problems of
knowledge representation, and some
effort has been spent on the under-
standing of text as well as ques-
tions.
</listItem>
<page confidence="0.99234">
4
</page>
<sectionHeader confidence="0.69719" genericHeader="method">
B. OVERVIEW OF EUFID
</sectionHeader>
<bodyText confidence="0.967717515789474">
EUFID is a general purpose natural-
language front-end for database manage-
ment. The original design goals for
EUFID were:
- to be application independent. This
means that the program must be table
driven. The tables contain the dic-
tionary and semantic information and
are loaded with application-specific
data. It was desired that the
tables could be constructed by some-
one other than the EUFID staff, so
that users could build new applica-
tions on their own.
- to be database independent. This
means that the organization of the
data in the database must be
representable in tables that drive
the query generator.* A database
reorganization that does not change
the semantics of the application
should be transparent to the user.
- to be DBMS independent. This means
that it must be able to generate
requests to different DBMSs in the
DBMS&apos;s query language and that the
interface of EUFID to a different
DBMS should not require changes to
the NLI modules. Transferring the
same database with the same semantic
content to another DBMS should be
transparent to the natural-language
users.
- to run on a mini-computer that might
possibly be different from the com-
puter with the DBMS.
- to have a fast response time, even
when the question cannot be inter-
preted. This means it must be able
quickly to recognize unanalyzable
constructs.
- to handle nonstandard or poorly-
formed (but, nevertheless, meaning-
ful) questions.
- to be portable to various machines.
This means that the system had to be
* We make a technical distinction
between the words &amp;quot;question&amp;quot; and
&amp;quot;query&amp;quot;. A question is any string
entered by the user to the EUFID
analyzer, regardless of the
terminating punctuation. This is
consistent with the design since
EUFID treats all input as a request
for information. A query is a formal
representation of a question in
either the EUFID intermediate
language IL, or in the formal query
language of a DBMS.
written in a high level language;
initially a customer required code
to be written in FORTRAN, later we
were able to use the &amp;quot;C&amp;quot; programming
language.
- to support different views of the
data for security purposes.
The design which met these requirements
is a modular system which uses an Inter-
mediate Language (IL) as the output of
the natural-language analysis system
(BURG821. This language represents, in
many ways, the union of the capabilities
of many &amp;quot;target&amp;quot; DBMS query languages.
The EUFID system consists of three
major modules, not counting the DBMS (see
Figure 1). The analyzer (parser) module
is table driven. It is necessary only to
properly build and load the tables to
interface EUFID to a new application.
Mapping a question from its dictionary
(user) representation to DBMS representa-
tion is handled by mapping functions con-
tained in a table and applied by a
separate module, the &amp;quot;mapper&amp;quot;. Each con-
tent (application dependent) word in the
dictionary has one or more mapping func-
tions defined for it. A final stage of
the mapper is a query-language generator
containing the syntax of IL. This stage
writes a query in IL using the
group/field names found by the mapper to
represent the user&apos;s concepts and the
structural relationships between them.
This design satisfies the requirement of
application independence.
</bodyText>
<figureCaption confidence="0.992984">
Figure 1: EUFID Block Diagram
</figureCaption>
<bodyText confidence="0.981527666666667">
For each different DBMS used by a
EUFID application, a &amp;quot;translator&amp;quot; module
needs to be written to convert a query in
IL to the equivalent in the DBMS query
language. This design satisfies the
requirement of DBMS independence.
Other modules are the system con-
troller, a &amp;quot;help&amp;quot; module, and a &amp;quot;synonym
editor&amp;quot;. An &amp;quot;Application Definition
Module&amp;quot; is used off-line to assist in the
creation of the run-time application
description tables.
</bodyText>
<figure confidence="0.996578052631579">
RESPONSE
DBMS
QUERY
) DATABASE
ENGLISH
QUES;ION
IL
IL
MAPPER
ANALYZER
A
TRANS-
LATOR
MAPPING
FUNCTION
DICTIONARY
CAN
REL
DBMS I
</figure>
<page confidence="0.969853">
5
</page>
<bodyText confidence="0.999431333333333">
The following subsections descrie
each of the modules of the EUFID system,
and give our motivation for design.
</bodyText>
<sectionHeader confidence="0.905828" genericHeader="method">
1. Application Definitions
</sectionHeader>
<bodyText confidence="0.999801757575758">
Bringing up a new application is a
long and complex process. The database
definition must be transmitted to EUFID.
A large corpus of &amp;quot;typical&amp;quot; user ques-
tions must be collected from a represen-
tative set of users and from these the
dictionary and mapping tables are
designed. A &amp;quot;semantic graph&amp;quot; is defined
for the application. This graph is
implicitly realized in the dictionary
where the nodes of the graph are the
definitions of English content words and
the connectivity of the graph is implied
by the case-structure relationships
defined for the nodes.
All dictionary and mapping-function
data are then entered into computer files
which are processed by the Application
Definition Module (ADM) to produce the
run-time tables. These final tables are
complex structures of pointers, character
strings, and index tables, designed to
decrease access time to the information
required by the analyzer and mapper
modules.
The ADM, typically, needs to be run
several times to &amp;quot;debug&amp;quot; the tables.
EUFID interfaces to three applications
currently exist, and building tables for
each new application took less time than
the previous one, but it still requires
several staff-months to bring up a new
application.
</bodyText>
<subsectionHeader confidence="0.911533">
a. User-View Representation
</subsectionHeader>
<bodyText confidence="0.939241421052632">
All information on the user&apos;s view
of the database is kept in the diction-
ary. The dictionary consists of two
kinds of words and definitions. Function
words, such as prepositions and conjunc-
tions, are pre-stored in each
application&apos;s dictionary and are used by
the analyzer for direction on how to con-
nect the semantic-graph nodes during
analysis. Content words are application
dependent. The definitions of content
words are semantic-graph nodes. The con-
nectivity of the graph is indicated by
semantic case slots and pointers con-
tained in the nodes. A form of
semantic-case is used to indicate the
attributes of an entity (e.g., adjec-
tives, prepositional phrases, and other
modifiers of a noun).
</bodyText>
<subsectionHeader confidence="0.487339">
b. Mapping Functions
</subsectionHeader>
<bodyText confidence="0.9757656">
The list of mapping functions is
derived from the dictionary. Every pos-
sible connection of every node has to be
considered. Frequently, desig: 11-
siderations in the mapping-function list
necessitate going back and modifying the
content of the dictionary. This is an
example of the overlap of the linguistic
and database issues in assigning an
interpretation to a question.
</bodyText>
<listItem confidence="0.406702">
c. Database Representation
</listItem>
<bodyText confidence="0.999915484848485">
The structure of the data in the
user&apos;s database is represented in two
tables, called the CAN (for canonical)
and REL (for relationships) tables. Tak-
ing advantage of the fact that any data-
base can be represented in relational
form, EUFID lists each database group as
if it were a relation. Group-to-group
linkage (represented in the REL table) is
dealt with as if a join* were necessary
to implement the link. For hierarchical
and network DBmSs the join will not be
needed: the link is &amp;quot;wired in&amp;quot; to the
database structure. EUFID nevertheless
assumes a join mainly in order to facili-
tate the writing of group-to-group links
in IL, which is a relational language.
The CAN table includes database-specific
information for each field (attribute) of
each group (relation), such as field
name, containing group, name of domain
from which attributed gets its values,
and a pointer to a set of conversion
functions for numeric values which can be
be used to convert from one unit of meas-
ure to another (e.g., feet to meters).
These data are used by the run-time
modules which map and translate the
tree-structured output of the analyzer to
IL on the actual group/field names of the
database, and then to the language of the
DBMS. These modules are discussed in the
next sections.
</bodyText>
<sectionHeader confidence="0.880649" genericHeader="method">
2. The EUFID Analyzer
</sectionHeader>
<bodyText confidence="0.998055952380952">
The current version of the EUFID
analyzer employs a variant of the Cooke-
Kasami-Younger algorithm for parsing its
input. This classical nonpredictive
bottom-up algorithm has been used in a
family of &amp;quot;chart parsers&amp;quot; developed by
Kay, Earley, and others (A072]. The
main features of these parsers are: (1)
They use arbitrary context-free grammars.
There are no restrictions on rules which
have left-recursion or other characteris-
tics which sometimes cause difficulty.
(2) They produce all possible parses of a
given input string. The grammars they
use may be ambiguous at either the
nonterminal- or terminal-symbol levels.
In natural-language processing, this
allows for a precise representation of
* The term &amp;quot;join&amp;quot; refers to a composite
operation between two relations in a
relational DBMS.
</bodyText>
<page confidence="0.996733">
6
</page>
<bodyText confidence="0.999982384615384">
both the syntactic and lexical ambigui-
ties which may be present in an input
sentence. (3) They provide partial
parses of the input. Each non-terminal
symbol derives some input substring.
Even if no such substring spans the
entire sentence, i.e., no complete parse
is achieved, analyses of various regions
of the sentence are available. (4) They
are conceptually straightforward and easy
to implement. The speed and storage con-
siderations which have kept such parsers
from being widely used in compilers are
less relevant in the analysis of short
strings such as queries to a DBMS.
The grammar used by the EUFID parser
is essentially semantic. The symbols of
the grammar represent the concepts under-
lying lexical items, and the rules
specify the ways in which these concepts
can be combined. More specifically, the
concepts are organized into a case sys-
tem. Each rule states that a given pair
of constituents can be linked if the con-
ceptual head of one constituent fills a
case on the conceptual head of the other.
A degree of context sensitivity is
achieved by attaching predicates to the
rules. These predicates block applica-
tion of the rules unless certain (usually
syntactic) conditions hold true. The
parser uses syntactic information only
on demand&amp;quot;, that is, only when such
information is necessary to resolve
semantic ambiguities. This adds to its
coverage and robustness, and makes it
relatively insensitive to the phrasing
variations which must be explicitly
accounted for in many other systems.
</bodyText>
<sectionHeader confidence="0.951954" genericHeader="method">
3. Mapping
</sectionHeader>
<bodyText confidence="0.998431230769231">
The mapper module converts the out-
put of the analyzer to input for the
translator module. Analyzer output is a
tree structure where the nodes are
semantic-graph nodes corresponding to the
content words in the user&apos;s question and
obtained from the dictionary.
Input to the translator module is a
string in the syntax of IL which contains
the names of actual groups and fields in
the database. The mapping algorithm,
thus, has to make several levels of
conversion simultaneously:
</bodyText>
<listItem confidence="0.728566777777778">
- it must convert a tree structure
into a linear string of tokens,
- it must convert semantic-graph nodes
Into database group- and field-
names, and
- it must convert the connectivity of
the tree (representing concept-to-
concept linkage in English) into the
(frequently very different) group-
</listItem>
<bodyText confidence="0.999143590909091">
to-field and group-to-group connec-
tions of the database.
The mapper makes use of a table of
mapping functions. The table contains at
least one mapping function for every con-
tent word in the dictionary. The
analyzer&apos;s tree is traversed bottom up,
applying mapping functions to each node
on the way. Mapping functions are con-
text sensitive with respect to those
nodes below it in the tree: nodes that
have already been mapped. A new tree is
gradually formed and connected this way.
Mapping functions may indicate that the
map of a semantic-graph node is a data-
base node (that is, a group or field
name), or a pre-connected sub-tree of
database nodes. The mapping function may
also indicate removal of a database node
or modification to the existing structure
of the tree being constructed.
The new tree is created in terms of
the database groups and fields and its
structure reflects the connectivity of
the database. A final stage of the
mapper traverses this new tree and gen-
erates the IL statement of the query
using a table of the syntax and keywords
of IL and the database names from the
tree.
An alternative method of mapping
that is now being investigated involves
breaking the process into two basic
parts. The first step would be to map
the tree output of the analyzer to an IL
query on what C. J. Date calls the &amp;quot;con-
ceptual schema&amp;quot; of the database (DATE77].
A second step would take this IL input
and re-arrange the schema connectivity
(and names of groups and fields) from
that of the conceptual schema to that of
the actual target database, generating
another IL query as input to the current
translators.
</bodyText>
<sectionHeader confidence="0.912283" genericHeader="method">
4. Translating,
</sectionHeader>
<bodyText confidence="0.955428315789474">
The final run-time module in EUFID
is a syntax translator that converts IL
to the actual DBMS query language. If
necessary, the translator can also add
access-path information related to data-
base search. Currently, two translators
have been written. One converts It. to
QUEL, a relatively simple conversion into
the language of the relational database
management system INGRES (STON76). The
other translator converts IL into the
query language of the World-Wide Data
Management System (WWDMS) [H0NE761 used
by the Department of Defense, and also
handles additional access path informa-
tion. This translator was quite diffi-
cult to design and build because of the
highly procedural nature of the WWDMS
query system.
</bodyText>
<page confidence="0.997121">
7
</page>
<bodyText confidence="0.999842">
The output of a translator is sent
to the appropriate DBMS. In the EUFID
system running at SDC, a QUEL query is
submitted directly to INGRES running on
the same PDP-11/70 as EUFID. For testing
purposes, queries generated by the WWDMS
translator were transmitted from a PDP-
11/70 to a Honeywell 116000 with a WWDMS
database.
</bodyText>
<sectionHeader confidence="0.947825" genericHeader="method">
5. Application Description
</sectionHeader>
<bodyText confidence="0.98756774137931">
EUFID runs on three different appli-
cation databases. The METRO application
involves monitoring of shipping transac-
tions between companies in a city called
&amp;quot;Metropolis&amp;quot;. There are ten companies
located in any one of three neighbor-
hoods. Each company rents warehouse
space for shipping/receiving transac-
tions, and has local offices which
receive goods. The data is organized
relationally using the INGRES database
management system. That means that there
are no navigational links stored in the
records (called &amp;quot;relations&amp;quot;) and there is
no predefined &amp;quot;root&amp;quot; to the database
structure. Access may be made from any
relation to any other relation as long as
there is a field in each of the two rela-
tions which has the same &amp;quot;domain&amp;quot; (set of
values).
AIREP (ADP Incident REPorting) is a
network database, implemented in WWDMS.
It contains reports about hardware and
software failures and resolution of the
problems in a large computer system.
Active problems are maintained in an
active file and old, solved problems are
moved to an historical file. If a prob-
lem is reported more than once, an abbre-
viated record is made for the additional
report, called the &amp;quot;duplicate incident&amp;quot;
record. This means that there are four
basic type of report: active incidents,
duplicate incidents, historical
incidents, and historical duplicate
incidents. In addition, there are
records about sites, problems, and solu-
tions.
The APPLICANT database is a rela-
tional database implemented in INGRES
that contains information about job
applicants and their backgrounds. The
central entity is the &amp;quot;applicant&amp;quot;, while
other relations describe the applicant&apos;s
specialties, education, previous employ-
ment, computer experience, and inter-
views.
Each database has different features
that may present problems for a natural-
language interface but which are typical
of &apos;real-world&apos; applications. METRO has
relatively few entities but has complex
relationships among them. APPLICANT has
many updates and many different values,
some coming from open-ended domains.
AIREP has a network database structure
and contains the same data structure in
four different files.
</bodyText>
<sectionHeader confidence="0.662403" genericHeader="method">
III LEVEL OF SUCCESS
</sectionHeader>
<subsectionHeader confidence="0.772855">
Most of the EUFID design goals were
</subsectionHeader>
<bodyText confidence="0.951304714285715">
actually met. EUFID runs on a mini-
computer, a DEC PDP 11/70. It is appli-
cation, database, and DBMS independent.
A typical question is analyzed, mapped
and translated in five to fifteen seconds
even with grammatically incorrect input.
The analyzer contains a good spel-
ling corrector and a good morphology
algorithm that strips inflectional end-
ings so that all inflected forms of words
need not be stored explicitly. A
&amp;quot;synonym editor&amp;quot; permits the user to
replace any word or string of words in
the dicionary with another word or
string, to accommodate personal jargon
and expressability. A &amp;quot;Concept Graph
Editor&amp;quot; allows a database administrator
to modify tables and define user profiles
so that different users may have limited
views of the data for security purposes.
The analysis strategy, based on a
semantic grammar, permits easy and
natural paraphrase recognition, although
there are linguistic constructs it cannot
handle. These are discussed below.
An English word may have more than
one definition without complicating the
analysis strategy. For example, &amp;quot;ship&amp;quot;
as a vessel and as a verb meaning &amp;quot;to
send&amp;quot; can be defined in the same diction-
ary. Words used as database values, such
as names, may also have multiple defini-
tions, e.g., &amp;quot;New York&amp;quot; used as the name
of both a city and a state.
The mapper, despite its many limita-
tions, can correctly map almost all trees
output by the analyzer. It is able to
handle English conjunctions, mapping them
appropriately to logical ANDs or ORs, and
understanding that some &amp;quot;ands&amp;quot; may need
to be interpreted as OR and vice-versa
under certain circumstances. It is able
to generate calls on DBMS calculations
(e.g., average) and user-defined func-
tions (e.g., marine great-circle jis-
tance) if the user-function exists and is
supported by the DBMS.
Questions involving time are inter-
preted in a reasonable way. Functions
are defined for &amp;quot;between&amp;quot; and &amp;quot;during&amp;quot; in
the METRO application. The AIREP appli-
cation allows time comparisons such as
&amp;quot;What system was running when incident
3123 occurred&amp;quot; which require a test to
see if a point in time is within an
interval.
</bodyText>
<page confidence="0.99165">
8
</page>
<bodyText confidence="0.999909166666667">
The mapper can translate &amp;quot;user
values&amp;quot; (e.g., &amp;quot;Russian&amp;quot;) to database
values (e.g., &amp;quot;USSR&amp;quot;), and convert one
unit of measure (e.g., feet) to another
(e.g., meters).
EUFID can interface to very complex
relational and CODASYL-type databases
having difficult navigation and parallel
structures. In the AIREP application a
consistent WWDMS navigational methodology
is used to access non-key records. The
system can also map to the parallel, but
not identical, structures for duplicate
and historical incidents.
In the INGRES applications, EUFID is
able to use and correctly map to &amp;quot;rela-
tionship relations&amp;quot; which relate two or
more other relations. For example, the
METRO relation &amp;quot;cw&amp;quot; contains a company
name, a warehouse name, and a date. This
represents the initial business contact.
A user might ask, &amp;quot;When did Colonial
start to do business with Superior?&amp;quot; or
&amp;quot;When did business begin between Colonial
and Superior?&amp;quot;, either of which must join
both the company (&amp;quot;c&amp;quot;) and the warehouse
(&amp;quot;w&amp;quot;) relations to the &amp;quot;cw&apos; relation.
The system control module keeps a
journal of all user-system interaction
together with internal module-to-module
data such as the IL for the user&apos;s ques-
tion and the generated DBMS query. The
system also employs a very effective HELP
module which, under certain cir-
cumstances, is context sensitive to the
problem affecting the user.
</bodyText>
<sectionHeader confidence="0.987266" genericHeader="method">
IV PROBLEMS
</sectionHeader>
<bodyText confidence="0.999851181818182">
This section describes problems
associated with EUFID development that
appear to be common to natural-language
Interfaces to database management sys-
tems. They are loosely classified into
the major areas of application, language
and database management issues, although
there may be overlap. Criteria for
evaluating whether an application is
appropriate for a natural-language
front-end are also described.
</bodyText>
<sectionHeader confidence="0.85107" genericHeader="method">
A. APPLICATION DEFINITION PROBLEMS
</sectionHeader>
<bodyText confidence="0.999880142857143">
The primary issue in this area is
concerned with problems of defining,
creating, and bringing up the necessary
data for a new application. The discus-
sion points out the difficulties associ-
ated with systematic knowledge acquisi-
tion.
</bodyText>
<sectionHeader confidence="0.956196" genericHeader="method">
1. User Model
</sectionHeader>
<bodyText confidence="0.998876285714286">
A single database may be used by
different groups of users for different
purposes. For example, some users of the
APPLICANT database may wish to fill a
specific job opening while others may
collect statistics on types of appli-
cants. The language used for these two
functions can be quite different, and it
is necessary to have extensive interac-
tion with cooperative users in order to
characterize the kinds of dialogues they
will have with the system.
Not only must representative
language protocols be collected, but
desired responses must be understood.
For example, to answer a question such as
&amp;quot;What is the status of our forces in
Europe&amp;quot;, the system must know whether
&apos;our&apos; refers to U.S. or NATO or some
other unit.
The importance of this interaction
between potential users and system
developers should not be underestimated,
as it is the basis for defining much of
the knowledge base needed by the system,
and may also be the basis for eventual
user acceptance or rejection of the NI.!
system.
</bodyText>
<sectionHeader confidence="0.867781" genericHeader="method">
2. Value Recognition
</sectionHeader>
<bodyText confidence="0.999978513513514">
A &amp;quot;value&amp;quot; is a specific datum stored
in the database, and is the smallest
piece of data obtainable as the result of
a database query. For example, in
response to the question &amp;quot;What companies
in North Hills shipped light freight to
Superior?&amp;quot; the METRO DBMS returns two
values: &amp;quot;Colonial&amp;quot; and &amp;quot;Supreme&amp;quot;. Values
can also be used in a query to qualify or
select certain records for output, e.g.,
in the above question &amp;quot;North Hills&amp;quot; and
&amp;quot;Superior&amp;quot; are values that must be
represented in the query to the DBMS. As
long as the alphanumeric values used in a
particular database field are the same as
words in the English questions, there are
no difficult problems involved in recog-
nizing values as selectors in a query.
There are three basic ways to recog-
nize these value words in a question.
They can be explicitly listed in the dic-
tionary, recognized by a pattern or con-
text, or found in the database itself.
If the value words are stored in the
dictionary, they can be subject to spel-
ling correction because the spelling
corrector uses the dictionary to locate
words which are a close match to unrecog-
nized words in a question. This means,
though, that all possible values and
variant legitimate spellings of values
for a concept must be put either into the
dictionary or into the synonym list.
This is reasonable for concepts which
have a small and controlled set of
values* such as the names of the
), A set of values is called a &amp;quot;domain&apos; .
</bodyText>
<page confidence="0.995347">
9
</page>
<bodyText confidence="0.996801472222222">
companies in METRO, but may become
unwieldy for large sets of values.
If a value can be recognized by a
pattern, it is not necessary to itemize
all instances in the dictionary. For
example, a date may be entered as
&amp;quot;yy/mm/dd&amp;quot; so that any input matching the
pattern &amp;quot;nn/nn/nn&amp;quot; is recognized as a
date. This is the approach used for
dates and for names of applicants in the
APPLICANT database, where names of people
match the pattern &amp;quot;I.I.Lastname&amp;quot;.
In another approach, OnLine English
(CULL80) and Intellect (HARR7B, EDP82]
(two variations of ROBOT) used the data-
base to recognize values. This is a
satisfactory solution if the database is
small or if the small number of different
values is stored in an index accessible
to the NLI, and if the values in the
database are suitable for use in English
questions.
Each of these solutions has disad-
vantages. If values are stored in the
dictionary there may be many different
ways to spell each particular value. For
example, the company name for &amp;quot;System
Development Corporation&amp;quot; may also be
given as &amp;quot;S.D.C.&amp;quot;, &amp;quot;S D C&amp;quot;, or &amp;quot;System
Development Corp&amp;quot;. While each different
spelling could be entered as a synonym
for the &amp;quot;correct&amp;quot; spelling in the data-
base, this would result in an enormous
proliferation of the dictionary entries
and problems with concurrency control
between the updates directed to the data
management system and the updates to the
dictionary. A creative solution might be
to define rules for synonym generation
and apply them to database updates.
A somewhat different example is from
the APPLICANT application which has many
open ended domains, such as names of
applicants and previous employers. In
this case, the application designer may
have to treat certain fields as
&amp;quot;retrieve-only&amp;quot;, meaning that the data
can be asked for but not used as a selec-
tion criterion. A database with a large
number of retrieve-only fields may be a
poor candidate for an NLI.
Patterns can be used only if they
can be enforced, and probably few values
really fit the patterns nicely. Proper
names are a poor choice for patterns
because of variations such as middle ini-
tial or title such as &amp;quot;Dr.&amp;quot; or &amp;quot;Jr.&amp;quot;.
Also, spelling correction cannot be per-
formed unless the value is stored in the
dictionary.
Finally, the solution of using the
database itself to recognize values is
unsatisfactory to a general NLI for any-
thing other than trivial databases,
unless an inverted index of values is
easily accessible. There are the prob-
lems of spelling correction and synonyms
for database values, the inefficiency
involved in accessing the DBMS for
every unrecognized word, and the diffi-
culty of knowing which fields in the
database to search.
</bodyText>
<sectionHeader confidence="0.760833" genericHeader="method">
3. Semantic Variation Ix Value
</sectionHeader>
<bodyText confidence="0.99947138">
Databases are generally designed
with a minimum number of different record
types. When there are entities which are
similar, but possibly have a small number
of attributes which are not shared, the
entities will be stored in the same
record type with null values for the
attributes that do not apply. The user,
in his questions, may view these similar
entities as very different entities and
talk about them differently.
We did not encounter the problem
with METRO or AIREP. For example, in
METRO, the user asks the same type of
questions about the company named &amp;quot;Colo-
nial&amp;quot; as about the company named
&amp;quot;Supreme&amp;quot;. In APPLICANT, however, each
applicant has a set of &amp;quot;specialties&amp;quot; such
as &amp;quot;computer programmer&amp;quot;, &amp;quot;accounting
clerk&amp;quot;, or &amp;quot;gardener&amp;quot;. These are all
stored as values of the specialty field
in the database. Unfortunately, in this
case different specialties evoke com-
pletely different concepts to the end
user. The user may ask questions such
as, &amp;quot;What programmers know COBOL?&amp;quot;, &amp;quot;Who
can program in COBOL?&amp;quot;, and &amp;quot;How many
applicants with a specialty in computer
programming applied in 1982?&amp;quot;. Notice
the new nouns and verbs that are intro-
duced by this specialty name.
A value domain such as specialties
should be handled with an ISA hierarchy.
Each different type of specialty such as
gardener or programmer could have a dif-
ferent concept that is a subset of the
concept &amp;quot;specialty&amp;quot;. Some questions
could be asked about all specialties and
others could be directed only to certain
subconcepts. However, there is no ISA
hierarchy in EUFID, and it would have
been inefficient to treat each specialty
and subspecialty as a separate concept
since there are 30 specialties and 196
subspecialties. Therefore, we required
the users to know the exact values, to
know which values are for specialties and
which are for subspecialties, and to ask
questions using the values only as nouns.
This is not &amp;quot;user friendly&amp;quot;.
</bodyText>
<page confidence="0.996806">
10
</page>
<bodyText confidence="0.999963333333333">
Even if it were possible to build a
different concept for each different
skill, there is an update problem. When
a new value is added to a value domain
where there are uniform semantics (as in
adding a new company name in METRO), the
new value is simply attached to the
existing concept. When the new value has
different semantics, the newly associated
concepts, nouns, and verbs cannot be
added automatically. If the NLI supports
an ISA hierarchy, someone will need to
categorize the new value and add a new
node to the hierarchy or specify a posi-
tion in the hierarchy.
</bodyText>
<sectionHeader confidence="0.778111" genericHeader="method">
4. Automation of Definition
</sectionHeader>
<bodyText confidence="0.9998737">
A natural-language interface system
will not be practical until a new appli-
cation can be installed easily. &amp;quot;Easily&amp;quot;
means that the end-user organization must
be able to create and modify the driving
tables for the application relatively
quickly without the help of the NLI
developer, and must be able to use the
NLI without restructuring the database.
Each EUFID application required
&amp;quot;handcrafted&amp;quot; tables that were built by
the development staff. Each new applica-
tion was done in less time than the pre-
vious one, but still required several
staff-months to bring up. Clearly, the
goal of facilitating the building of the
tables by end users was not met.
Computer-assisted tools for defining new
applications are a prerequisite for prac-
tical NLIs.
</bodyText>
<subsectionHeader confidence="0.870485">
B. LANGUAGE PROBLEMS
</subsectionHeader>
<bodyText confidence="0.998675916666667">
The basic approach to language
analysis in EUFID involves a bottom up
parser using a semantic grammar. The
symbols of the grammar are concepts
underlying lexical items, and the rules
of the grammar are based on a case frame-
work. Essentially syntactic information
is used only when needed to resolve ambi-
guity. The language features that this
technique has to handle are common to any
NLI, and some of the problem areas are
described in the following sections.
</bodyText>
<sectionHeader confidence="0.54478" genericHeader="method">
1. Anaphora and Ellipsis
</sectionHeader>
<bodyText confidence="0.996445964285714">
To support natural interaction it is
desirable to allow the use of anaphoric
reference and elliptical constructions
across sentence sequences, such as &amp;quot;What
applicants know Fortran and C7&amp;quot;, &amp;quot;Which
of them live in California?&amp;quot;, &amp;quot;In
Nevada?&amp;quot;, &amp;quot;How many know Pascal?&amp;quot;. One
of the biggest problems is to define the
scope of the reference in such cases. In
the example, it is not clear whether the
user wishes to retrieve the set of all
applicants who know Pascal or only the
subset who live in Nevada.
One solution is to provide commands
that allow users to define subsets of the
database to which to address questions.
This removes the ambiguity and speeds up
retrieval time on a large database. How-
ever, it moves the NLI interaction toward
that of a structured query language, and
forces the user to be aware of the level
of subset being accessed. It is also
difficult to implement because a subset
may involve projections and joins to
build a new relation containing the sub-
set. The NLI must be able dynamically
and temporarily to change the mapping
tables to map to this new relation.
</bodyText>
<sectionHeader confidence="0.986596" genericHeader="method">
2. Intelligent Interaction
</sectionHeader>
<bodyText confidence="0.999510416666666">
One of the EUFID design goals was to
respond promptly either with an answer or
with a message that the question could
not be interpreted. The system handles
spelling or typographical errors by
interacting with the user to select the
correct word. However, when all of the
words are recognized but do not connect
semantically, it is difficult to identify
a single point in analysis which caused
the failure.
It is in this area that the absence
of a syntactic mechanism for determining
well-formedness was most noticeable.
There are times when a question has a
proper syntactic structure, but contains
semantic relationships unrecognizable to
the application as in &amp;quot;What is the loca-
tion of North Hills?&amp;quot;. A response of
&amp;quot;Location is not defined for North Hills
in this application&amp;quot; should be derivable
from the recognizable semantic failure.
Similarly, it would be useful to have a
framework for interpreting partial trees,
as in the question &amp;quot;What companies does
Mohawk ship to?&amp;quot; where Mohawk is not a
recognized word within the application.
An appropriate response might be &amp;quot;Com-
panies ship to receiving offices and com-
panies; Mohawk is neither a receiving
office nor a company. The names of
offices and companies are
.
Interpretation of partial analyses is not
possible within the EUFID system; it
either succeeds or fails completely.
</bodyText>
<sectionHeader confidence="0.932988" genericHeader="method">
3. Yes/No Questions
</sectionHeader>
<bodyText confidence="0.9415353">
In normal NLI interaction users may
wish to ask &amp;quot;yes/no&amp;quot; questions, yet no
DBMS has the ability to answer &amp;quot;yes&amp;quot; or
&amp;quot;no&amp;quot; explicitly. The EUFID mapper maps a
yes/no question into a query which will
retrieve some data, such as an &amp;quot;output
Identifier&amp;quot; or default name for a con-
cept, if the answer is &amp;quot;yes&amp;quot; and no data
If the answer if &amp;quot;no&amp;quot;. However, the
answer may be &amp;quot;no&amp;quot; for several reasons.
</bodyText>
<page confidence="0.99805">
11
</page>
<bodyText confidence="0.997001071428572">
For example, a &amp;quot;no&amp;quot; response to the ques-
tion &amp;quot;Has John Smith been interviewed?&amp;quot;
may mean that the database has knowledge
about John Smith and about interviews and
Smith is not listed as having had an
interview*, or the database knows about
John Smith and no data about interviews
is available. A third possibility could
be that the database has information
about John Smith and his employment
situation (already hired), and the
response might include that information,
as in &amp;quot;No, but he has already been
hired&amp;quot;.
</bodyText>
<subsectionHeader confidence="0.671273">
4. Con&apos;unctions
</subsectionHeader>
<bodyText confidence="0.99873245">
The scope of conjunctions is a dif-
ficult problem for any parsing or analyz-
ing algorithm. The natural-language use
of &amp;quot;and&amp;quot; and &amp;quot;or&amp;quot; does not necessarily
correspond to the logical meaning, as in
the question &amp;quot;List the applicants who
live in California and Arizona.&amp;quot;. Multi-
ple conjunctions in a single question can
be ambiguous as in &amp;quot;Which minority and
female applicants know Fortran and
Cobol?&amp;quot;. This could be interpreted with
logical &amp;quot;and&amp;quot; or with logical &amp;quot;or&amp;quot; as in
&amp;quot;Which applicants who are minority or
female know either Fortran or Cobol?&amp;quot;.
The EUFID mapper will change English
&amp;quot;and&amp;quot; to logical &amp;quot;or&amp;quot; when the two
phrases within the scope of the conjunc-
tion are values for the same field. In
the example above, an applicant has only
one state of residence.
</bodyText>
<sectionHeader confidence="0.933776" genericHeader="method">
5. Negation
</sectionHeader>
<bodyText confidence="0.98076102">
Negative requests may contain expli-
cit negative words such as &amp;quot;not&amp;quot; and
&amp;quot;never&amp;quot; or may contain implicit negatives
such as &amp;quot;only&amp;quot;, &amp;quot;except&amp;quot; and &amp;quot;other than&amp;quot;
(OLNE781. The interpretation of nega-
tives can be very difficult. For exam-
ple, &amp;quot;Which companies did not ship any
perishable freight in 1976&amp;quot; could mean
either &amp;quot;Which (of all the companies)
shipped no perishable freight in 1976?&amp;quot;
or &amp;quot;Which (of the companies that ship
perishable freight) shipped none in
1976?&amp;quot;. Moreover, if some companies were
only receivers and never shippers it is
nnere Is the important distinction
between a &amp;quot;closed world&amp;quot; database in
which the assumption is that the
database covers the whole world (of
the application) and an &amp;quot;open world&amp;quot;
database in which it is understood
that the database does not represent
all there is to the real world of the
application. In the open world
database, which we encounter most of
the time, a response of &amp;quot;not that
this database knows of&amp;quot; might be more
appropriate.
uncertain whether they should be returned
in the answer. It is also difficult to
take a complement of a set of data using
the many data management systems that do
not support set operators between rela-
tions.
Questions which require a &amp;quot;yes&amp;quot; or
&amp;quot;no&amp;quot; response are difficult to answer
because often the &amp;quot;no&amp;quot; is due to a
presupposition which is invalid. This is
especially true with negation. For exam-
ple, if the user asks, &amp;quot;Does every com-
pany in North Hills except Supreme use
NH2?&amp;quot;, the answer may be &amp;quot;no&amp;quot; because
Supreme is not in North Hills.
The current implementation of EUFID
does not allow explicit negation,
although some negative concepts are han-
dled such as &amp;quot;What companies ship to com-
panies other than Colonial?&amp;quot;. &amp;quot;Other
than&amp;quot; is interpreted as the &amp;quot;!=&amp;quot; operator
in exactly the same way that &amp;quot;greater
than&amp;quot; is interpreted as &amp;quot;&gt;&amp;quot;.
</bodyText>
<subsectionHeader confidence="0.515961">
C. INTERPRETATION AND DATABASE ISSUES
</subsectionHeader>
<bodyText confidence="0.9973627">
Many questions make perfect sense
semantically but are difficult to map
Into DBMS queries because of the database
structure. The problems become worse
when access is through an NLI because of
increased expectations on the part of the
user and because it may be difficult for
a help system adequately to describe the
problem to the user who is unaware of the
database structure.
</bodyText>
<sectionHeader confidence="0.83306" genericHeader="method">
1. IL Limitations
</sectionHeader>
<bodyText confidence="0.975264769230769">
The design of the IL is critical.
It must be rich enough to support
retrieval from all the underlying DBMSs.
However, if it contains capabilities that
do not exist in a specific DBMS, it is
difficult to describe this deficiency to
the user.
In APPLICANT, the user cannot get
both the major and minor fields of study
by asking &amp;quot;List applicants and field of
study&amp;quot;, because a limitation in the EUFID
IL prevents making two joins between edu-
cation and subject records. This problem
was corrected in a subsequent version of
IL with the addition of 3 &amp;quot;range&amp;quot; state-
ment similar to that used by QUEL
(STON76].
The current IL does not contain an
&amp;quot;EXISTS&amp;quot; or &amp;quot;FAILS&amp;quot; operator which can
test for the existence of a record. Such
an operator is frequently used to test an
interrecord link in a network or
hierarchical DBMS. It is needed to
express &amp;quot;What problems are unsolved?&amp;quot; to
the AIREP application, which requires a
test for a database link between a
</bodyText>
<page confidence="0.997079">
12
</page>
<bodyText confidence="0.97290275">
problem set and a solution set.
2. Mixed Case Values
EUFID allows a value in the database
to be upper or lower case and will con-
vert a value in the question either to
all upper or all lower case in the IL, or
leave it as input by the user. If the
database values are mixed case, it is not
possible to convert the user&apos;s input to a
single case. If the user does not enter
each letter in the proper case, the value
will not match.
</bodyText>
<sectionHeader confidence="0.941767" genericHeader="method">
3. Granularity Differences
</sectionHeader>
<bodyText confidence="0.999908352941177">
The NLI user is not expected to
understand exactly how data is stored,
and yet must understand something about
the granularity of the data. Time fields
often cause problems because time may be
given by year or by fractions of a
second. Users may make time comparisons
that require more granularity than is
stored in the database. For example, the
user can ask &amp;quot;What incidents were
reported at SAC while system release 3.4
was installed?&amp;quot;. If incidents were
reported by day but system release dates
were given by month, the system would
return incidents which occurred in the
days of the month before the system
release was installed.
</bodyText>
<sectionHeader confidence="0.95016" genericHeader="method">
4. Nested Queries
</sectionHeader>
<bodyText confidence="0.996194351851852">
A very simple question in English
can turn into a very complicated request
in the query language if it involves
retrieval of data which must be used for
qualification in another part of the same
query. In IL these are called &amp;quot;nested
queries&amp;quot;. Most often some qualification
needs to be done both &amp;quot;inside&amp;quot; and &amp;quot;out-
side&amp;quot; the clause of the query that does
the internal retrieve. For example, the
question &amp;quot;What incident at SAC had the
longest downtime?&amp;quot; from our AIREP appli-
cation is expressed in IL as
retrieve [INCA.ID1
where (INCA.SITENAME = &amp;quot;SAC&amp;quot;)
and (INCA.DNTM =
(retrieve ( max (INCA.DNTM))
where (INCA.SITENAME = &amp;quot;SAC&amp;quot;)))
The nested part of the query is enclosed
in braces. &amp;quot;INCA&amp;quot; is the database name
of the active incident records. Notice
that removing the &amp;quot;INCA.SITENAME = &apos;SAC&apos;&amp;quot;
clause from either the inner or outer
query would result in an incorrect formu-
lation of the question.
A similar example from the METRO
application is the question, &amp;quot;What com-
pany shipped more than the average amount
of light freight in 1980?&amp;quot; which will
generate the IL query
retrieve [cct.scname]
where (cct.date = 1980)
and (cct.lf &gt;=
(retrieve (avg (cct.lf))
where (cct.date = 1980)))
Here, &amp;quot;cot&amp;quot; is the name of the company-
to-company transaction relation.
&amp;quot;Scname. is the name of a shipping com-
pany in this relation. Note again that
the qualification on &amp;quot;1980&amp;quot; needs to be
done both inside and outside the nested
part of the query.
In the query language for INGRES
such a request is expressed in a manner
very Similiar to the IL expressions. For
WWDMS a very complex procedure is gen-
erated. In all cases, the DBMS needs to
answer the inner request and save the
result for use in qualifying the outer
request. There are many database manage-
ment systems that cannot handle such
questions and these IL statements cannot
be translated into the system&apos;s query
language.
</bodyText>
<sectionHeader confidence="0.993602" genericHeader="method">
5. Inconsistency In Retrieval
</sectionHeader>
<bodyText confidence="0.999970848484849">
The NLI presents a uniform view of
all databases and DBMSs, but it is diffi-
cult to truly mask all differences in the
behavior of the DBMSs because they do not
all process the equivalent query in the
same way. For example, when data are
retrieved from two relations in a rela-
tional database, the two relations must
be joined on a common attribute. The
answer forms a new relation which may be
displayed to the user or stored. Since
the join clause acts as qualification, a
record (tuple) in either relation which
has no corresponding tuple in the other
relation does not participate in the
result. This is a different concept from
the hierarchical and network models where
the system retrieves all records from a
master record and then retrieves
corresponding records from a subfile.
This difference can cause anomalies with
retrieval. For example, in a pure rela-
tional system &amp;quot;List applicants and their
interviews&amp;quot; would be treated as &amp;quot;List
applicants who have had interviews
together with their interview informa-
tion.&amp;quot; A hierarchical or network DBMS
would treat it as &amp;quot;List all applicants
(whether or not they have been inter-
viewed) plus any interview information
that exists.&amp;quot;. This second interpreta-
tion is more likely to be the correct
one.
</bodyText>
<page confidence="0.998731">
13
</page>
<sectionHeader confidence="0.94564" genericHeader="method">
D. OVERALL NLI DESIGN
</sectionHeader>
<bodyText confidence="0.9999965">
There are several problems that
affect the selection of applications for
the NLI. Some databases and data manage-
ment systems may not be appropriate tar-
gets for natural-language interfaces.
Some DBMS functions may be difficult to
support. It is important to have a clear
understanding of these problems so that
the NLI can mediate between the user
view, as represented by the natural-
language questions, and the underlying
database structure.
</bodyText>
<sectionHeader confidence="0.817664" genericHeader="method">
1. A Design Consideration
</sectionHeader>
<bodyText confidence="0.999927029411765">
For any database there are natural-
language questions that cannot be inter-
preted because the concepts involved lie
outside the world of the database. Ques-
tions can also involve structural com-
plexity that is not representable in the
DBMS query language. A particularly dif-
ficult decision in the overall design of
an NLI is the issue of where in the chain
of events of processing a user&apos;s question
into a DBMS query to trap these questions
and stop processing.
One approach is to decide that if a
question is not meaningful to the world
of the database it should not be meaning-
ful to the NLI and, therefore, not
analyzable on semantic grounds. Another
assumes that if the NLI can analyze a
question that cannot be asked of the
database, it has a much better chance of
describing to the user what is wrong with
the question and how it might be
rephrased to get the desired information.
Codd made good use of the dialogue
procedures of the RENDEZVOUS [C0DD741
system to avoid questions that the DBMS
could not handle, as well as avoiding
generation of DBMS queries that did not
represent the user&apos;s intent. Such a sys-
tem, however, requires a very large
semantic base (much larger than that of
the database) in order to make meaningful
communication with the user during the
dialogue.
</bodyText>
<sectionHeader confidence="0.807847" genericHeader="method">
2. Class of Database to Support
</sectionHeader>
<bodyText confidence="0.999875">
Some databases are simply not good
candidates for an NLI because of charac-
teristics mentioned in previous sections
such as many retrieve-only fields, or
domains that have a high update rate but
cannot be recognized by a pattern.
There are also some structural prob-
lems that must be recognized. If the
database contains &amp;quot;flat&amp;quot; files about one
basic entity, it is reasonably easy to
map queries and to explain problems to
the user when the mapping cannot be made.
However, there can be &amp;quot;reasonable&amp;quot;
queries that cannot be answered directly
because of the database structure.
Hierarchical DBMSs present the most prob-
lems with navigation because access must
start from the root. For example, if the
APPLICANT database were under an
hierarchical DBMS, the question &amp;quot;List the
specialties for each applicant&amp;quot; could be
answered directly but not &amp;quot;What are the
specialties?&amp;quot; as there would be no way to
get to the specialty records except via
particular applicant records.
An array allows more than one
instance of a field or set of fields in a
single record. There may be arrays of
values or even arrays of sets of values
in nonrelational databases. When the
user retrieves a field that is an array
the DBMS requires a subscript into the
array. Either the user must specifiy
this subscript or the NLI must map to all
members of the array with a test for
missing data.
</bodyText>
<listItem confidence="0.645518">
3. Class of DBMS to Support
</listItem>
<bodyText confidence="0.999789027777778">
For systems such as EUFID, the data-
base must be organized within a data
management system so that the data is
structured and individual fields are
named. If the data is just text, the
EUFID approach cannot be used.
Current NLI systems are designed to
be used interactively by a user, which
means that the DBMS should also have an
interactive query language. However, not
all data management systems are interac-
tive. WWDMS (HONE76] has a user query
language, but queries are entered into a
batch job queue and answers may not
return for many minutes. If an NLI front
end is to be added to such a DBMS, it
must have the capability to generate
query programs without any access to the
database for parsing or for processing
the returned answer.
The query language should support
operations equivalent to the relational
operations of select, project, and join.
Also, the query language should support
some arithmetic capability. Most have
aggregate functions such as SUM and
COUNT. WWDmS does not have an easy-to-
use average operation, but it does have a
procedural language with arithmetic
operators so that EUFID can produce a
&amp;quot;query&amp;quot; that procedurally calculates an
average.
Basic calculations should be sup-
ported such as &amp;quot;age=today-birthdate&amp;quot;. It
is also desirable to be able to call spe-
cial functions to do complex calculations
</bodyText>
<page confidence="0.996629">
14
</page>
<bodyText confidence="0.9560245">
such as navigational calculations
required in a naval database.
4. the input must be controlled to
standardize values,
</bodyText>
<sectionHeader confidence="0.908253" genericHeader="method">
4. Support for Metadata
</sectionHeader>
<bodyText confidence="0.991136555555556">
Metadata is data about the data in
the database. It would be able to tell
the user of the METRO application, for
example, the kind of information the
database has for warehouses and other .
entities in the application. Such meta-
data might be extensions of active
integrated data dictionaries now avail-
able in some DBMSs.
In an application-level system the
user should be able to query the metadata
to learn about the structure of the data-
base. A different mode, such as the
menus used by the EUFID help system,
could be used to access metadata, or
English language questions to both meta
information and the database could be
supported.
</bodyText>
<sectionHeader confidence="0.993466" genericHeader="evaluation">
5. Updates
</sectionHeader>
<bodyText confidence="0.999850111111111">
Some potential users would like a
natural-language interface to include the
capability to update the database.
Currently, updating through any high
level view of the database should be
avoided, especially when the view con-
tains joins or derived data, because of
the risk of inadvertently entering
incorrectly-interpreted data.
</bodyText>
<sectionHeader confidence="0.935309" genericHeader="conclusions">
V SUMMARY AND CONCLUSIONS
</sectionHeader>
<bodyText confidence="0.993691588235294">
For many years, researchers have
been attempting to build robust systems
for natural-language access to databases.
It is not clear that such a system exists
for general use [OSI79]. There are prob-
lems that need to be solved on both the
front end, the parsing of the English
question, and the back end, the transla-
tion of the question into a data manage-
ment system query. It is important to
understand the types of requests, types
of functions, and types of databases that
can be supported by a specific NLI.
Some general guidelines that can be
applied to the selection of applications
for current NLI front ends are suggested
below:
</bodyText>
<reference confidence="0.975449125">
1. the underlying DBMS should have an
interactive query language,
2. the DMS view should be relational or
at least support multiple access
paths,
3. the database should not contain
arrays either of values or of struc-
tures,
</reference>
<bodyText confidence="0.9281330625">
5. there should be few fields that have
values that change rapidly, cannot
be recognized by a pattern, and that
must be used in qualification,
6. the users of the NLI should have a
common use for the data and a common
view of the data, and
7. there must be some user who under-
stands the questions that will be
asked and is available to work with
the developers of the NLI.
We believe that current system
development is limited by the need for
good semantic modelling techniques and
the length of time needed to build the
knowledge base required to interface with
a new application. When the knowledge
base for the NLI is developed, the data-
base as well as sample input must be con-
sidered in the design. Parsing of ques-
tions to a database cannot be divorced
from the database contents since semantic
interpretation can only be determined in
the context of that database. On the
other hand, a robust system cannot be
developed by considering only database
structure and content, because the range
of the questions allowed would not accu-
rately reflect the user view of the
application and also would not account
for all the information that is inferred
at some level.
</bodyText>
<sectionHeader confidence="0.997327" genericHeader="acknowledgments">
ACKNOWLEDGEMENTS
</sectionHeader>
<bodyText confidence="0.7148285">
We would like to acknowledge the
many people who have contributed to EUFID
</bodyText>
<reference confidence="0.90116175">
development: David Brill, Marilyn Cril-
ley, Dolores Dawson, LeRoy Gates, Iris
Kameny, Philip Klahr, Antonio Leal, Char-
lotte Linde, Eric Lund, Filip Machi, Ken-
neth Miller, Eileen Lepoff, Beatrice
Oshika, Roberta Peeler, Douglas Pintar,
Arie Shoshani, Martin Vago, and Jim
We
</reference>
<sectionHeader confidence="0.914635" genericHeader="references">
REFERENCES
</sectionHeader>
<reference confidence="0.999515272727273">
(AH072] Aho, A. V. and J. D. Ullman, &amp;quot;The
Theory of Parsing, Translation, and
Compiling&amp;quot;, Vol. Parsing,
Prentice-Hall, 1972, pp. 314-230.
(BURG80] Burger, J. F., &amp;quot;Semantic Data-
base Mapping in EUFID&amp;quot;, Proceedings
of the 1980 ACM/SIGMOD Conference,
MFFica7--cTriT77 May 14-lb,
1980.
(BURG821 Burger, J. F. and Marjorie Tem-
pleton, &amp;quot;Recommendations for an
</reference>
<page confidence="0.960176">
15
</page>
<reference confidence="0.999737027272727">
Internal Input Language for the
Knowledge-Based System&amp;quot;, System
Development Corporation internal
paper N-(L)-24890/021/00, January 5,
1982.
(C00074] Codd, E. F., &amp;quot;Seven Steps to
Rendezvous with the Casual User&amp;quot;,
Proc. IFIP TC-2 Working Conference
3F-ffatITTae-RaFagement Systems,=7=
gese, Corsica, April 1-5, 1974, in
J. W. Kimble and K. I. Koffeman
(Eds.), &amp;quot;Data Base Management&amp;quot;
North-Holland, 1974.
[CULL801 Cullinane Corporation, &amp;quot;IQS Sum-
mary Description&amp;quot;, May 1980.
[DATE77] Date, C. J., &amp;quot;An Introduction to
Database Systems&amp;quot;, second edition,
Addison-Wesley Publishing, Menlo
Park, CA, 1977.
[EDP82] &amp;quot;Query Systems for End Users&amp;quot;,
EDP Analyzer, Vol. 20, No. 9, Sep-
tember, 1982.
(HARR78] Harris, L. R., &amp;quot;The ROBOT Sys-
tem: Natural Language Processing
Applied to Data Base Query&amp;quot;,
Proceedings ACM 78 Annual Confer-
ence, 1978. --
(HEND771 Hendrix, G. G., E. D. Sacerdoti,
D. Sagalowicz, and J. Slocum,
&amp;quot;Developing a Natural Language
Interface to Complex Data&amp;quot; SRI
Report 78-305, August 1977.
(HONE761 Honeywell, WWMCCS: World Wide
Data Management System User&apos;s Guide,
Honeywell DB97 Rev.3, April 1976.
[KELL71] Kellogg, C. H., J. F. Burger, T.
Diller, and K. Fogt, &amp;quot;The CONVERSE
Natural Language Data management
System: Current Status and Plans&amp;quot;,
Proceedings of the ACM Symposium on
Information -7torage and Retrievar,
University of mary13Ta, College
Park, MD, 1971, pp. 33-46.
[MYL076] Mylopoulos, J., A. Borgida, P.
Cohen, N. Roussopoulos, J. Tsotsos,
and H. Wong, &amp;quot;TORUS: A Step Towards
Bridging the Gap between Data Bases
and the Casual User&amp;quot;, in Information
Systems Volume 2 19767-7F71707
Press, pp 49-64.
[OLNE78] Olney, John, &amp;quot;Enabling EUFID to
Handle Negative Expressions&amp;quot;, SDC
SP-3996, August 1978.
[0SI791 Operating Systems, Inc., &amp;quot;An
Assessment of Natural Language
Interfaces for Command and Control
Database Query&amp;quot;, Logicon/OSI Divi-
sion report for WWMCCS System
Engineering, OSI Report R79-026, 29
June 1979.
[SCHA77] Scha, R. J. H., &amp;quot;Phillips
Question-Answering System PHLIQA1&amp;quot;,
in SIGART Newsletter Number 61,
February 1977, Association for Com-
puting machinery, New York.
[SIMM65] Simmons, R. F., &amp;quot;Answering
English Questions by Computer -- a
Survey&amp;quot;, Comm. ACM 8,1, January
1965, 53-70.
[STON76] Stonebraker, M., et. al., &amp;quot;The
Design and Implementation of
INGRES&amp;quot;, Electronics Research
Laboratory, College of Engineering,
University of California at Berke-
ley, Memorandum No. ERL-M577, 27
January 1976.
[TEMP79] Templeton, M. P., &amp;quot;EUFID: A
Friendly and Flexible Frontend for
Data Management Systems&amp;quot;, Proceed-
ings of the 1979 National Conference
of thi-A7g6cTITTOF-E67-C7Mputationa
ringuistics, August7-T979.
[TEMP801 Templeton, M. P., &amp;quot;A Natural
Language User Interface&amp;quot;, Proceed-
ings of &amp;quot;Pathways to ---g7FgiTt
TWETgri7&amp;quot;, Washington 117C. Chapter
of ACM, 1980.
[THOM69], Thompson, F. B., P. C. Lock-
emann, B. H. Dostert, and R.
Deverill, &amp;quot;REL: A Rapidly Extensible
Language System&amp;quot;, in Proceedings of
the 24th ACM National Conference,
A.76.6173Tiorl-Tor-737671Fing machinery,
New York, 1969, pp 399-417.
[WALT771 Waltz, D. L., &amp;quot;Natural Language
Interfaces&amp;quot;, in SIGART Newsletter
Number 61, February 1977, Associa-
tion for Computing machinery, New
York.
[WALT78] Waltz, D. L., &amp;quot;An English
language Question Answering System
for a Large Relational Database&amp;quot;,
Communications of the ACM 21, 7(July
1978). PP 526-539.
(W00D72] Woods, W. A., R. M. Kaplan, H.
Nash-Webber, The Lunar Sciences
Natural Languag=nformation --T7TFFN
Final Report, Report number 2378,
Bolt, Beranek, and Newman, Inc.,
Cambridge, MA, 15 June 1972.
</reference>
<page confidence="0.998702">
16
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.822549">
<title confidence="0.9381815">PROBLEMS IN NATURAL-LANGUAGE INTERFACE TO DBMS WITH EXAMPLES FROM EUFID</title>
<author confidence="0.988836">Marjorie Templeton John Burger</author>
<affiliation confidence="0.996658">System Development Corporation</affiliation>
<address confidence="0.991801">Santa Monica, California</address>
<abstract confidence="0.997641">For five years the End-User Friendly Interface to Data management (EUFID) project team at System Development Corporation worked on the design and implementation of a Natural-Language Interface (NLI) system that was to be independent of both the application and the database management system. In this paper we describe application, natural-language and database management problems involved in NLI development, with specific reference to the EUFID system as an example.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="false">
<title>the underlying DBMS should have an interactive query language, 2. the DMS view should be relational or at least support multiple access paths,</title>
<marker></marker>
<rawString>1. the underlying DBMS should have an interactive query language, 2. the DMS view should be relational or at least support multiple access paths,</rawString>
</citation>
<citation valid="false">
<title>the database should not contain arrays either of values or of structures,</title>
<marker></marker>
<rawString>3. the database should not contain arrays either of values or of structures,</rawString>
</citation>
<citation valid="false">
<authors>
<author>development David Brill</author>
<author>Marilyn Crilley</author>
<author>Dolores Dawson</author>
<author>LeRoy Gates</author>
<author>Iris Kameny</author>
<author>Philip Klahr</author>
</authors>
<location>Antonio Leal, Charlotte Linde, Eric Lund, Filip Machi, Kenneth Miller, Eileen Lepoff, Beatrice Oshika, Roberta Peeler, Douglas</location>
<marker>Brill, Crilley, Dawson, Gates, Kameny, Klahr, </marker>
<rawString>development: David Brill, Marilyn Crilley, Dolores Dawson, LeRoy Gates, Iris Kameny, Philip Klahr, Antonio Leal, Charlotte Linde, Eric Lund, Filip Machi, Kenneth Miller, Eileen Lepoff, Beatrice Oshika, Roberta Peeler, Douglas Pintar, Arie Shoshani, Martin Vago, and Jim We</rawString>
</citation>
<citation valid="true">
<title>The Theory of Parsing,</title>
<date>1972</date>
<journal>Translation, and Compiling&amp;quot;,</journal>
<volume>Vol.</volume>
<pages>314--230</pages>
<location>Parsing, Prentice-Hall,</location>
<marker>1972</marker>
<rawString>(AH072] Aho, A. V. and J. D. Ullman, &amp;quot;The Theory of Parsing, Translation, and Compiling&amp;quot;, Vol. Parsing, Prentice-Hall, 1972, pp. 314-230.</rawString>
</citation>
<citation valid="true">
<title>Semantic Database Mapping in EUFID&amp;quot;,</title>
<date>1980</date>
<booktitle>Proceedings of the 1980 ACM/SIGMOD Conference, MFFica7--cTriT77</booktitle>
<marker>1980</marker>
<rawString>(BURG80] Burger, J. F., &amp;quot;Semantic Database Mapping in EUFID&amp;quot;, Proceedings of the 1980 ACM/SIGMOD Conference, MFFica7--cTriT77 May 14-lb, 1980.</rawString>
</citation>
<citation valid="true">
<title>Recommendations for an Internal Input Language for the Knowledge-Based System&amp;quot;,</title>
<date>1982</date>
<booktitle>System Development Corporation internal paper N-(L)-24890/021/00,</booktitle>
<marker>1982</marker>
<rawString>(BURG821 Burger, J. F. and Marjorie Templeton, &amp;quot;Recommendations for an Internal Input Language for the Knowledge-Based System&amp;quot;, System Development Corporation internal paper N-(L)-24890/021/00, January 5, 1982.</rawString>
</citation>
<citation valid="true">
<title>Seven Steps to Rendezvous with the Casual User&amp;quot;,</title>
<date>1974</date>
<booktitle>Proc. IFIP TC-2 Working Conference 3F-ffatITTae-RaFagement Systems,=7= gese, Corsica,</booktitle>
<note>in</note>
<marker>1974</marker>
<rawString>(C00074] Codd, E. F., &amp;quot;Seven Steps to Rendezvous with the Casual User&amp;quot;, Proc. IFIP TC-2 Working Conference 3F-ffatITTae-RaFagement Systems,=7= gese, Corsica, April 1-5, 1974, in J. W. Kimble and K. I. Koffeman (Eds.), &amp;quot;Data Base Management&amp;quot; North-Holland, 1974.</rawString>
</citation>
<citation valid="true">
<title>Corporation, &amp;quot;IQS Summary Description&amp;quot;,</title>
<date>1980</date>
<marker>1980</marker>
<rawString>[CULL801 Cullinane Corporation, &amp;quot;IQS Summary Description&amp;quot;, May 1980.</rawString>
</citation>
<citation valid="true">
<authors>
<author>C J Date</author>
</authors>
<title>An Introduction to Database Systems&amp;quot;,</title>
<date>1977</date>
<publisher>Addison-Wesley Publishing,</publisher>
<location>Menlo Park, CA,</location>
<note>second edition,</note>
<marker>Date, 1977</marker>
<rawString>[DATE77] Date, C. J., &amp;quot;An Introduction to Database Systems&amp;quot;, second edition, Addison-Wesley Publishing, Menlo Park, CA, 1977.</rawString>
</citation>
<citation valid="true">
<title>[EDP82] &amp;quot;Query Systems for End Users&amp;quot;,</title>
<date>1982</date>
<journal>EDP Analyzer,</journal>
<volume>20</volume>
<marker>1982</marker>
<rawString>[EDP82] &amp;quot;Query Systems for End Users&amp;quot;, EDP Analyzer, Vol. 20, No. 9, September, 1982.</rawString>
</citation>
<citation valid="true">
<title>The ROBOT System: Natural Language Processing Applied to Data Base Query&amp;quot;,</title>
<date>1978</date>
<booktitle>Proceedings ACM 78 Annual Conference,</booktitle>
<publisher></publisher>
<marker>1978</marker>
<rawString>(HARR78] Harris, L. R., &amp;quot;The ROBOT System: Natural Language Processing Applied to Data Base Query&amp;quot;, Proceedings ACM 78 Annual Conference, 1978. --</rawString>
</citation>
<citation valid="true">
<title>Developing a Natural Language Interface to Complex Data&amp;quot;</title>
<date>1977</date>
<tech>SRI Report 78-305,</tech>
<marker>1977</marker>
<rawString>(HEND771 Hendrix, G. G., E. D. Sacerdoti, D. Sagalowicz, and J. Slocum, &amp;quot;Developing a Natural Language Interface to Complex Data&amp;quot; SRI Report 78-305, August 1977.</rawString>
</citation>
<citation valid="true">
<title>WWMCCS: World Wide Data Management System User&apos;s Guide,</title>
<date>1976</date>
<booktitle>Honeywell DB97 Rev.3,</booktitle>
<marker>1976</marker>
<rawString>(HONE761 Honeywell, WWMCCS: World Wide Data Management System User&apos;s Guide, Honeywell DB97 Rev.3, April 1976.</rawString>
</citation>
<citation valid="true">
<authors>
<author>C H Kellogg</author>
<author>J F Burger</author>
<author>T Diller</author>
<author>K Fogt</author>
</authors>
<title>The CONVERSE Natural Language Data management System: Current Status and Plans&amp;quot;,</title>
<date>1971</date>
<booktitle>Proceedings of the ACM Symposium on Information -7torage and Retrievar, University of mary13Ta,</booktitle>
<pages>33--46</pages>
<location>College Park, MD,</location>
<marker>Kellogg, Burger, Diller, Fogt, 1971</marker>
<rawString>[KELL71] Kellogg, C. H., J. F. Burger, T. Diller, and K. Fogt, &amp;quot;The CONVERSE Natural Language Data management System: Current Status and Plans&amp;quot;, Proceedings of the ACM Symposium on Information -7torage and Retrievar, University of mary13Ta, College Park, MD, 1971, pp. 33-46.</rawString>
</citation>
<citation valid="false">
<authors>
<author>J Mylopoulos</author>
<author>A Borgida</author>
<author>P Cohen</author>
<author>N Roussopoulos</author>
<author>J Tsotsos</author>
<author>H Wong</author>
</authors>
<title>TORUS: A Step Towards Bridging the Gap between Data Bases and the Casual User&amp;quot;,</title>
<booktitle>in Information Systems Volume</booktitle>
<volume>2</volume>
<pages>19767--7</pages>
<publisher>Press,</publisher>
<marker>Mylopoulos, Borgida, Cohen, Roussopoulos, Tsotsos, Wong, </marker>
<rawString>[MYL076] Mylopoulos, J., A. Borgida, P. Cohen, N. Roussopoulos, J. Tsotsos, and H. Wong, &amp;quot;TORUS: A Step Towards Bridging the Gap between Data Bases and the Casual User&amp;quot;, in Information Systems Volume 2 19767-7F71707 Press, pp 49-64.</rawString>
</citation>
<citation valid="true">
<authors>
<author>John Olney</author>
</authors>
<title>Enabling EUFID to Handle Negative Expressions&amp;quot;,</title>
<date>1978</date>
<booktitle>SDC SP-3996,</booktitle>
<marker>Olney, 1978</marker>
<rawString>[OLNE78] Olney, John, &amp;quot;Enabling EUFID to Handle Negative Expressions&amp;quot;, SDC SP-3996, August 1978.</rawString>
</citation>
<citation valid="true">
<title>0SI791 Operating Systems, Inc., &amp;quot;An Assessment of Natural Language Interfaces for Command and Control Database Query&amp;quot;, Logicon/OSI Division report for WWMCCS System Engineering,</title>
<date>1979</date>
<tech>OSI Report R79-026, 29</tech>
<marker>1979</marker>
<rawString>[0SI791 Operating Systems, Inc., &amp;quot;An Assessment of Natural Language Interfaces for Command and Control Database Query&amp;quot;, Logicon/OSI Division report for WWMCCS System Engineering, OSI Report R79-026, 29 June 1979.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R J H Scha</author>
</authors>
<title>Phillips Question-Answering System PHLIQA1&amp;quot;,</title>
<date>1977</date>
<journal>in SIGART Newsletter Number</journal>
<volume>61</volume>
<location>New York.</location>
<marker>Scha, 1977</marker>
<rawString>[SCHA77] Scha, R. J. H., &amp;quot;Phillips Question-Answering System PHLIQA1&amp;quot;, in SIGART Newsletter Number 61, February 1977, Association for Computing machinery, New York.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R F Simmons</author>
</authors>
<title>Answering English Questions by Computer -- a Survey&amp;quot;,</title>
<date>1965</date>
<journal>Comm. ACM</journal>
<volume>8</volume>
<pages>53--70</pages>
<marker>Simmons, 1965</marker>
<rawString>[SIMM65] Simmons, R. F., &amp;quot;Answering English Questions by Computer -- a Survey&amp;quot;, Comm. ACM 8,1, January 1965, 53-70.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Stonebraker</author>
</authors>
<title>The Design and Implementation of INGRES&amp;quot;,</title>
<date>1976</date>
<volume>577</volume>
<pages>27</pages>
<institution>Electronics Research Laboratory, College of Engineering, University of California at Berkeley, Memorandum</institution>
<marker>Stonebraker, 1976</marker>
<rawString>[STON76] Stonebraker, M., et. al., &amp;quot;The Design and Implementation of INGRES&amp;quot;, Electronics Research Laboratory, College of Engineering, University of California at Berkeley, Memorandum No. ERL-M577, 27 January 1976.</rawString>
</citation>
<citation valid="false">
<authors>
<author>M P Templeton</author>
</authors>
<title>EUFID: A Friendly and Flexible Frontend for Data Management Systems&amp;quot;,</title>
<booktitle>Proceedings of the 1979 National Conference of thi-A7g6cTITTOF-E67-C7Mputationa ringuistics, August7-T979.</booktitle>
<marker>Templeton, </marker>
<rawString>[TEMP79] Templeton, M. P., &amp;quot;EUFID: A Friendly and Flexible Frontend for Data Management Systems&amp;quot;, Proceedings of the 1979 National Conference of thi-A7g6cTITTOF-E67-C7Mputationa ringuistics, August7-T979.</rawString>
</citation>
<citation valid="true">
<title>A Natural Language User Interface&amp;quot;,</title>
<date>1980</date>
<booktitle>Proceedings of &amp;quot;Pathways to ---g7FgiTt TWETgri7&amp;quot;, Washington 117C. Chapter of ACM,</booktitle>
<marker>1980</marker>
<rawString>[TEMP801 Templeton, M. P., &amp;quot;A Natural Language User Interface&amp;quot;, Proceedings of &amp;quot;Pathways to ---g7FgiTt TWETgri7&amp;quot;, Washington 117C. Chapter of ACM, 1980.</rawString>
</citation>
<citation valid="true">
<authors>
<author>F B Thompson</author>
<author>P C Lockemann</author>
<author>B H Dostert</author>
<author>R Deverill</author>
</authors>
<title>REL: A Rapidly Extensible Language System&amp;quot;,</title>
<date>1969</date>
<booktitle>in Proceedings of the 24th ACM National Conference, A.76.6173Tiorl-Tor-737671Fing machinery,</booktitle>
<pages>399--417</pages>
<location>New York,</location>
<marker>Thompson, Lockemann, Dostert, Deverill, 1969</marker>
<rawString>[THOM69], Thompson, F. B., P. C. Lockemann, B. H. Dostert, and R. Deverill, &amp;quot;REL: A Rapidly Extensible Language System&amp;quot;, in Proceedings of the 24th ACM National Conference, A.76.6173Tiorl-Tor-737671Fing machinery, New York, 1969, pp 399-417.</rawString>
</citation>
<citation valid="true">
<title>Natural Language Interfaces&amp;quot;,</title>
<date>1977</date>
<journal>in SIGART Newsletter Number</journal>
<volume>61</volume>
<location>New York.</location>
<marker>1977</marker>
<rawString>[WALT771 Waltz, D. L., &amp;quot;Natural Language Interfaces&amp;quot;, in SIGART Newsletter Number 61, February 1977, Association for Computing machinery, New York.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D L Waltz</author>
</authors>
<title>An English language Question Answering System for a Large Relational Database&amp;quot;,</title>
<date>1978</date>
<journal>Communications of the ACM</journal>
<volume>21</volume>
<pages>526--539</pages>
<marker>Waltz, 1978</marker>
<rawString>[WALT78] Waltz, D. L., &amp;quot;An English language Question Answering System for a Large Relational Database&amp;quot;, Communications of the ACM 21, 7(July 1978). PP 526-539.</rawString>
</citation>
<citation valid="true">
<title>The Lunar Sciences Natural Languag=nformation</title>
<date>1972</date>
<tech>T7TFFN Final Report, Report number 2378,</tech>
<location>Bolt, Beranek, and Newman, Inc., Cambridge, MA,</location>
<marker>1972</marker>
<rawString>(W00D72] Woods, W. A., R. M. Kaplan, H. Nash-Webber, The Lunar Sciences Natural Languag=nformation --T7TFFN Final Report, Report number 2378, Bolt, Beranek, and Newman, Inc., Cambridge, MA, 15 June 1972.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>