<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.003014">
<title confidence="0.986437">
Learning Efficient Parsing
</title>
<author confidence="0.900454">
Gertjan van Noord
</author>
<affiliation confidence="0.969397">
University of Groningen
</affiliation>
<email confidence="0.981099">
G.J.M.van.noord@rug.nl
</email>
<sectionHeader confidence="0.994408" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.99983075">
A corpus-based technique is described to
improve the efficiency of wide-coverage
high-accuracy parsers. By keeping track
of the derivation steps which lead to the
best parse for a very large collection of
sentences, the parser learns which parse
steps can be filtered without significant
loss in parsing accuracy, but with an im-
portant increase in parsing efficiency. An
interesting characteristic of our approach
is that it is self-learning, in the sense that
it uses unannotated corpora.
</bodyText>
<sectionHeader confidence="0.998429" genericHeader="keywords">
1 Introduction
</sectionHeader>
<bodyText confidence="0.999975227272727">
We consider wide-coverage high-accuracy pars-
ing systems such as Alpino, a parser for Dutch
which contains a grammar based on HPSG and
a maximum entropy disambiguation component
trained on a treebank. Even if such parsing sys-
tems now obtain satisfactory accuracy for a vari-
ety of text types, a drawback concerns the compu-
tational properties of such parsers: they typically
require lots of memory and are often very slow for
longer and very ambiguous sentences.
We present a very simple, fairly general,
corpus-based method to improve upon the prac-
tical efficiency of such parsers. We use the accu-
rate, slow, parser to parse many (unannotated) in-
put sentences. For each sentence, we keep track of
sequences of derivation steps that were required to
find the best parse of that sentence (i.e., the parse
that obtained the best score, highest probability,
according to the parser itself).
Given a large set of successful derivation step
sequences, we experimented with a variety of
simple heuristics to filter unpromising derivation
steps. A heuristic that works remarkably well
simply states that for a new input sentence, the
parser can only consider derivation step sequences
in which any sub-sequence of length N has been
observed at least once in the training data. Exper-
imental results are provided for various heuristics
and amounts of training data.
It is hard to compare fast, accurate, parsers with
slow, slightly more accurate parsers. In section 3
we propose both an on-line and an off-line appli-
cation scenario, introducing a time-out per sen-
tence, which leads to metrics for choosing be-
tween parser variants.
In the experimental part we show that, in an on-
line scenario, the most successful heuristic leads
to a parser that is more accurate than the baseline
system, except for unrealistic time-outs per sen-
tence of more than 15 minutes. Furthermore, we
show that, in an off-line scenario, the most suc-
cessful heuristic leads to a parser that is more than
four times faster than the base-line variant with the
same accuracy.
</bodyText>
<sectionHeader confidence="0.9254805" genericHeader="introduction">
2 Background: the Alpino parser for
Dutch
</sectionHeader>
<bodyText confidence="0.984368263157895">
The experiments are performed using the Alpino
parser for Dutch. The Alpino system is a linguis-
tically motivated, wide-coverage grammar and
parser for Dutch in the tradition of HPSG. It con-
sists of about 800 grammar rules and a large lexi-
con of over 300,000 lexemes and various rules to
recognize special constructs such as named enti-
ties, temporal expressions, etc. Heuristics have
been implemented to deal with unknown words
and word sequences. Based on the categories as-
signed to words, and the set of grammar rules
compiled from the HPSG grammar, a left-corner
parser finds the set of all parses, and stores this set
compactly in a packed parse forest. In order to se-
lect the best parse from the parse forest, a best-first
search algorithm is applied. The algorithm con-
sults a Maximum Entropy disambiguation model
to judge the quality of (partial) parses.
Although Alpino is not a dependency grammar
</bodyText>
<note confidence="0.932904">
Proceedings of the 12th Conference of the European Chapter of the ACL, pages 817–825,
Athens, Greece, 30 March – 3 April 2009. c�2009 Association for Computational Linguistics
</note>
<page confidence="0.99532">
817
</page>
<bodyText confidence="0.999787285714286">
in the traditional sense, dependency structures are
generated by the lexicon and grammar rules as the
value of a dedicated attribute. The dependency
structures are based on CGN (Corpus Gesproken
Nederlands, Corpus of Spoken Dutch) (Hoekstra
et al., 2003), D-Coi and LASSY (van Noord et al.,
2006).
</bodyText>
<sectionHeader confidence="0.996266" genericHeader="method">
3 Methodology: balancing efficiency and
accuracy
</sectionHeader>
<subsectionHeader confidence="0.999038">
3.1 On-line and off-line parsing scenarios
</subsectionHeader>
<bodyText confidence="0.999817">
We focus on the speed of parsing, ignoring other
computational properties such as memory usage.
Problems with respect to parsing are twofold: on
the one hand, parsing simply is too slow for many
input sentences. On the other hand, the rela-
tion between input sentence and expected speed
of parsing is typically unknown. For simple pars-
ing systems based on finite-state, context-free or
mildly context-sensitive grammars, it is possible
to establish an upper-bound of required CPU-time
based on the length of an input sentence. For the
very powerful constraint-based formalisms con-
sidered here, such upper-bounds are not avail-
able. In practice, shorter sentences typically can
be parsed fairly quickly, whereas longer sentences
sometimes can take a very very long time indeed.
As a consequence, measures such as number of
words parsed per minute, or mean parsing time per
sentence are somewhat meaningless. We therefore
introduce two slightly different scenarios which
include a time-out per sentence.
On-line scenario. In some applications, a parser
is applied on-line: an actual user is waiting for the
response of the system, and if the parser required
minutes of CPU-time, the application would not
be successful. In such a scenario, we assume that
it is possible to determine a maximum amount of
CPU-time (a time-out) per sentence, depending on
other factors such as speed of the other system
components, expected patience of users, etc. If
the parser does not finish before the time-out, it is
assumed to have not produced anything. In depen-
dency parsing, the parser produces the empty set
of dependencies in such cases, and hence such an
event has an important negative effect on the ac-
curacy of the system. By studying the relation be-
tween different time-outs and accuracy, it is possi-
ble to choose the most effective parser variant for
a particular application.
Off-line scenario. For other applications, an
off-line parsing scenario might be more appropri-
ate. For instance, if we build a question answering
system for a medical encyclopedia, and we wish to
parse all sentences of that encyclopedia once and
for all, then we are not interested in the amount of
CPU-time the parser spends on a single sentence,
but we want to know how much time it will cost to
parse everything.
In such a scenario, it often still is very useful to
set a time-out for each sentence, but in this case the
time-out can be expected to be (much) higher than
in the on-line scenario. In this scenario, we pro-
pose to study the relation between mean CPU-time
and accuracy – for various settings of the time-
out parameter. This allows us to determine, for
instance, the mean CPU-time requirements for a
given target accuracy level?
</bodyText>
<subsectionHeader confidence="0.9953075">
3.2 Accuracy: comparing sets of
dependencies
</subsectionHeader>
<bodyText confidence="0.999924166666667">
Let Dip be the number of dependencies produced
by the parser for sentence i, Dig is the number of
dependencies in the treebank parse, and Dio is the
number of correct dependencies produced by the
parser. If no superscript is used, we aggregate over
all sentences of the test set, i.e.,:
</bodyText>
<equation confidence="0.989049333333333">
� �
Di p Do = Di o Dg =
i i
</equation>
<bodyText confidence="0.999806">
We define precision (P = Do/Dp), (R =
Do/Dg) and f-score: 2P · R/(P + R).
An alternative similarity score is based on the
observation that for a given sentence of n words,
a parser would be expected to return (about) n de-
pendencies. In such cases, we can simply use the
percentage of correct dependencies as a measure
of accuracy. To allow for some discrepancies be-
tween the number of expected and returned depen-
dencies, we divide by the maximum (per sentence)
of both. This leads to the following definition of
named dependency accuracy.
If time-outs are introduced, the difference be-
tween f-score and accuracy becomes important.
Consider the example in table 1. Here, the parser
produces reasonable results for the first three,
short, sentences, but for the final, long, sentence
no result is produced because of a time-out.
</bodyText>
<equation confidence="0.986160833333333">
�Dp =
i
Di
g
Acc = Do
Ei max(Dig, Dip)
</equation>
<page confidence="0.986101">
818
</page>
<table confidence="0.9958862">
i Do DP D9 prec rec f-sc Acc
1 8 10 11 80 73 76 73
2 8 11 10 76 76 76 73
3 8 9 9 80 80 80 77
4 0 0 30 80 40 53 39
</table>
<tableCaption confidence="0.977941">
Table 1: Hypothetical result of parser on a test set
</tableCaption>
<bodyText confidence="0.99680865">
of four sentences. The columns labeled precision,
recall, f-score and accuracy represent aggregates
over sentences 1... i.
The precision, recall and f-score after the first
three sentences is 80%. After the – much longer
– fourth sentence, recall drops considerably, but
precision remains the same. As a consequence,
the f-score is quite a bit higher than 40%: it is over
53%. The accuracy score after three sentences is
77%. Including the fourth sentence leads to a drop
in accuracy to 39%.
As this example illustrates, the f-score metric is
less sensitive to parse failures than the accuracy
score. Also, it appears that the accuracy score is
a much better characterization of the success of
this parser: after all, the parser only got 24 cor-
rect dependencies out of 60 expected dependen-
cies. The f-score measure, on the other hand, can
easily be misunderstood to suggest that the parser
does a good job for more than 50%.
</bodyText>
<sectionHeader confidence="0.954306" genericHeader="method">
4 Learning Efficient Parsing
</sectionHeader>
<bodyText confidence="0.9996752">
In this section a method is defined for filtering
derivation step sequences, based on previous expe-
rience of the parser. In a training phase, the parser
is fed with thousands of sentences. For each sen-
tence it finds the best parse, and it stores the rel-
evant sequences of derivation steps, that were re-
quired to find that best parse. After the training
phase, the parser filters those sequences of deriva-
tion steps that are unlikely to be useful. By fil-
tering out unlikely derivation step sequences, effi-
ciency is expected to improve. Since certain parses
now become impossible, a drop in accuracy is ex-
pected as well.
Although the idea of filtering derivation step
sequences based on previous experience is fairly
general, we define the method in more detail with
respect to an actual parsing algorithm: the left-
corner parser along the lines of Matsumoto et al.
(1983), Pereira and Shieber (1987, section 6.5)
and van Noord (1997).
</bodyText>
<subsectionHeader confidence="0.99745">
4.1 Left-corner parsing
</subsectionHeader>
<bodyText confidence="0.999989916666667">
A left-corner parser is a bottom-up parser with
top-down guidance, which is most easily ex-
plained as a non-deterministic search procedure.
A specification of the left-corner algorithm can
be provided in DCG as in figure 2 (Pereira and
Shieber, 1987, section 6.5), where the filter/2
goals should be ignored for the moment. Here,
we assume that dictionary look-up is performed
by the word/3 predicate, with the first argument
a given word, and the second argument its cate-
gory; and that rules are accessible via the predi-
cate rule/3, where the first argument represents
the mother category, and the second argument is
the possibly empty list of daughter categories. The
third argument of both the word/3 and rule/3
predicates are identifiers we need later.
In order to analyze a given sentence as an in-
stance of the top category, we look up the first
word of the string, and show that this lexical cat-
egory is a left-corner of the goal category. To
show that a given category is a left-corner of a
given goal category, a rule is selected. The left-
most daughter node of that rule is identified with
the left-corner. The other daughters of the rule are
parsed recursively. If this succeeds, it remains to
show that the mother node of the rule is a left-
corner of the goal category. The recursion stops
if a left-corner category can be identified with the
goal category.
This simple algorithm is improved and extended
in a variety of ways, as in Matsumoto et al. (1983)
and van Noord (1997), to make it efficient and
practical. The extensions include a memoization
of the parse/1 predicate and the construction of a
shared parse forest (a compact representation of
all parses).
</bodyText>
<subsectionHeader confidence="0.99136">
4.2 Left-corner splines
</subsectionHeader>
<bodyText confidence="0.999975">
For the left-corner parser, the derivation step
sequences that are of interested are left-corner
splines. Such a spline consists of a goal category,
and the rules and lexical entries which were used
in the left-corner, in the order from the top to the
bottom.
A spline consists of a goal category, followed
by a sequence of derivation step names. A deriva-
tion step name is typically a rule identifier, but it
can also be a lexical type, indicating the lexical
category of a word that is the left-corner. A spe-
cial derivation step name is the reserved symbol
</bodyText>
<page confidence="0.988288">
819
</page>
<table confidence="0.787069555555556">
top parse(Phrase) --&gt;
top cat leaf(SubPhrase,Id),
{ filter(Phrase,[Id]) },
lc(SubPhrase,Phrase,[Id]).
max xp(np)
leaf(Cat,Id) --&gt;
[Word], { word(Word,Cat,Id) }.
leaf(Cat,Id) --&gt; { rule(Cat,[],Id) }.
np det n
</table>
<figure confidence="0.91938352173913">
det(de) n
de n n rel
noun(de,both,sg) rel
wijn rel arg(np)
rel pron(de,no obl)
die
vp
vp vpx
vpx vproj
vp arg v(np)
np pn
pn(sg,PER)
Elvis
vp-j
vproj vc
vc v
lc(Phrase,Phrase,Spline) --&gt;
{ filter(Phrase,[finish|Spline]) }.
lc(SubPhrase,SuperPhrase,Spline) --&gt;
rule(Phrase,[SubPhrase|Rest],Id),
{ filter(SuperPhrase,[Id|Spline]) },
parse_rest(Rest),
lc(Phrase,SuperPhrase,[Id|Spline]).
</figure>
<figureCaption confidence="0.892568333333333">
Figure 2: DCG Specification of a non-
deterministic left-corner parser, including spline
filtering.
</figureCaption>
<bodyText confidence="0.7835395">
techniques we develop to learn to parse new sen-
tences more efficiently.
</bodyText>
<figure confidence="0.668226285714286">
verb(past(sg),transitive)
dronk
(top,[finish,top_cat,max_xp(np),np_det_n,det(de)]).
(n,[finish,n_n_rel,noun(de,both,sg)]).
(rel,[finish,rel_arg(np),rel_pron(de,no_obl)]).
(vp,[finish,vp_vpx,vpx_vproj,vp_arg_v(np),np_pn,pn(sg,PER),]).
(vproj,[finish,vproj_vc,vc_v,verb(past(sg),transitive)]).
</figure>
<figureCaption confidence="0.693658333333333">
Figure 1: Annotated derivation tree of the sentence
De wijn die Elvis dronk (The wine which Elvis
drank).
</figureCaption>
<bodyText confidence="0.9999132">
finish which is used to indicate that the cur-
rent category is identified with the goal category
(and no further rules are applied). A spline is writ-
ten (g, rn ... r1) for goal category g and deriva-
tion step names r1 ... rn. (g, ri ... r1) is a partial
spline of (g, rn ... ri ... r1).
Consider the annotated derivation tree for the
sentence De wijn die Elvis dronk (The wine which
Elvis drank) in figure 1. Boxed leaf nodes con-
tain the lexical category as well as the corre-
sponding word. Boxed non-leaf nodes contain the
goal category (italic) and the rule-name. Non-
boxed non-leaf nodes only list the rule name. The
first left-corner spline consists of the goal cate-
gory top and the identifiers finish, top cat,
max xp(np), np det n, and the lexical type
det(de). All five left-corner splines of the ex-
ample are listed at the bottom of figure 1.
Left-corner splines of best parses of a large set
of sentences constitute the training data for the
</bodyText>
<subsectionHeader confidence="0.999883">
4.3 Filtering left-corner splines
</subsectionHeader>
<bodyText confidence="0.999024379310345">
The left-corner parser builds left-corner splines
one step at the time. For a given goal, it first se-
lects a potential left-corner, and then continues ap-
plying rules from the bottom to the top until the
left-corner is identified with the goal category. At
every step where the algorithm attempts to extend
a left-corner spline, we now introduce a filter. The
purpose of this filter is to consider only those par-
tial left-corner splines that look promising - based
on the parser’s previous experience on the train-
ing data. The specification of the left-corner parser
given in figure 2 includes calls to this filter.
The purpose of the filter is, that at any time
the parser considers extending a left-corner spline
(g, ri−1 ... r1) to (g, ri ... r1), such an extension
only is allowed in promising cases. Obviously,
there are many ways such a filter could be defined.
We identify the following dimensions:
Context size. A filter for (g, ri ... r1) will typ-
ically ignore at least some of the derivation step
names from the context. We experiment with fil-
ters which take into consideration g, ri, ri−1 (bi-
gram filter); g, ri, ri−1, ri−2 (trigram filter); and
g, ri, ri−1, ri−2, ri−3 (fourgram filter). A further
filter, labeled prefix filter, takes the full history into
account: g, ri ... r1. The prefix filter thus ensures
that the parser only considers left-corner splines
that are partial splines of splines observed in the
training data.
</bodyText>
<page confidence="0.989592">
820
</page>
<bodyText confidence="0.999777142857143">
Required evidence. For the various filters, what
kind of evidence from the training data do we re-
quire in order for the filter to accept this particular
derivation step? In initial experiments, we used
relative frequencies. For instance, the trigram fil-
ter would allow any tuple g, ri−2, ri−1, ri for some
constant threshold τ, provided:
</bodyText>
<equation confidence="0.952094">
C(g,... riri−1ri−2 ...) &gt; τ
C(g,... ri−1ri−2 ...)
</equation>
<bodyText confidence="0.9977315">
However, we found that filters are more effective
(and require much less space – see below), which
simply require that every step has been observed
often enough in the training data:
</bodyText>
<equation confidence="0.880983">
C(g,... riri−1ri−2 ...) &gt; τ
</equation>
<bodyText confidence="0.9995635">
In particular, the case where τ = 0 gave surpris-
ingly good results.
</bodyText>
<subsectionHeader confidence="0.998943">
4.4 Comparison with link table
</subsectionHeader>
<bodyText confidence="0.9999665">
The filter we developed is reminiscent of the link
predicate of (Pereira and Shieber, 1987). An im-
portant difference with the filter developed here
is that the link predicate removes derivation steps
which cannot lead to a successful parse (by an off-
line global analysis of the grammar), whereas we
filter out derivation steps which can lead to a full
parse, but which are not expected to lead to a best
parse. In our implementation, a variant of the link
predicate is used as well.
</bodyText>
<subsectionHeader confidence="0.990191">
4.5 Implementation detail
</subsectionHeader>
<bodyText confidence="0.999967189189189">
The definition of the filter predicate depends on
our choices with respect to the dimensions identi-
fied above. For instance, if we chose the trigram
filter as our context size, then the training data can
be preprocessed in order to store all goal-trigram-
pairs with frequency above the threshold τ. Dur-
ing parsing, if the filter is given the partial spline
(g, riri−1ri−2 ...), then a simple table look-up for
the tuple (g, ri−2ri−1ri) is sufficient (this suffices,
because each of the preceding trigrams will have
been checked earlier). In general, the filter pred-
icate needs access to a table containing a pair of
goal category and context, where the context con-
sists of sequences of derivation step names. The
table contains items for those pairs that occurred
with frequency &gt; τ in the training data.
To access such tables efficiently, an obvious
choice is to use a hash table. The additional stor-
age requirements for such a hash table are consid-
erable. For instance, for the prefix filter four years
of newspaper text lead to a table with 941,723 en-
tries - stored as text the data takes 103Mb. To save
space, we experimented with a set-up in which
only the hash keys are stored, but the original in-
formation that the hash key was computed from, is
removed. During parsing, in order to check that a
given tuple is allowable, we compute its hash key,
and check if the hash key is in the table. If so,
the computation continues. The drawback of this
method is, that in the case a hash collision would
have occurred in an ordinary hash table, we now
simply assume that the input tuple was in the ta-
ble. In other words: the filter is potentially too
permissive in such cases. In actual practice, we did
not observe a difference with respect to accuracy
or CPU-time requirements, but the storage costs
dropped considerably.
</bodyText>
<sectionHeader confidence="0.997608" genericHeader="evaluation">
5 Experimental Results
</sectionHeader>
<bodyText confidence="0.99993196">
Some of the experiments have been performed
with the Alpino Treebank. The Alpino Treebank
(van der Beek et al., 2002) consists of manu-
ally verified dependency structures for the cdbl
(newspaper) part of the Eindhoven corpus (den
Boogaart, 1975). The treebank contains 7137 sen-
tences. Average sentence length is about 20 to-
kens.
Some further experiments are performed on the
basis of the D-Coi corpus (van Noord et al., 2006).
From this corpus, we used the manually veri-
fied syntactic annotations of the P-P-H and P-P-
L parts. The P-P-H part consists of over 2200
sentences from the Dutch daily newspaper Trouw
from 2001. Average sentence length is about 16.5
tokens. The P-P-L part contains 1115 sentences
taken from information brochures of Dutch Min-
istries. Average sentence length is about 18.5 to-
kens.
For training data, we used newspaper text from
the TwNC (Twente Newspaper) corpus (Ordelman
et al., 2007). We used Volkskrant 2001, NRC
2000, Algemeen Dagblad 1999. In addition, we
used Volkskrant 1997 newspaper data extracted
from the Volkskrant 1997 CDROM.
</bodyText>
<subsectionHeader confidence="0.876322">
5.1 Results on Alpino Treebank
</subsectionHeader>
<bodyText confidence="0.999955">
Figure 3 presents results obtained on the Alpino
Treebank. In the graphs, the various filters are
compared with the baseline variant of the parser.
Each of the filters outperforms the default model
for all given time-out values. In fact, the base-
</bodyText>
<page confidence="0.99214">
821
</page>
<figure confidence="0.997430555555555">
timeout (sec)
mean cputime (sec)
1 5 10 50 500
bigram
trigram
fourgram
prefix
baseline
20 40 60 80
accuracy (%CA)
5 10 15 20 25
accuracy (%CA)
20 40 60 80
bigram
trigram
fourgram
prefix
baseline
</figure>
<figureCaption confidence="0.830002333333333">
Figure 3: Accuracy versus time-out (on-line scenario), and accuracy versus mean CPU-time (off-line
scenario) for various time-outs. The graphs compare the default setting of Alpino with the effect of the
various filters based on all available training data. Evaluation on the Alpino treebank.
</figureCaption>
<bodyText confidence="0.9982838125">
line parser improves upon the prefix filter only for
unrealistic time-outs larger than fifteen minutes of
CPU-time. The difference in accuracy for a given
time-out value can be considerable: as much as
12% for time-outs around 30 seconds of CPU-
time.
If we focus on mean CPU-time (off-line sce-
nario), differences are even more pronounced.
Without the filter, an accuracy of about 63% is ob-
tained for a mean CPU-time of 6 seconds. The pre-
fix filtering method obtains accuracy of more than
86% for the same mean CPU-time. For that level
of accuracy, the base-line model requires a mean
CPU-time of about 25 seconds. In other words, for
the same level of accuracy, the prefix filter leads to
a parser that is more than four times faster.
</bodyText>
<subsectionHeader confidence="0.999668">
5.2 Effect of the amount of training data
</subsectionHeader>
<bodyText confidence="0.999858136363637">
In the first two graphs of figure 4 we observe the
effect of the amount of training data. As can be ex-
pected, increasing the amount of data increases the
accuracy, and decreases efficiency (because more
derivation steps have been observed, hence fewer
derivations are filtered out). Generally, models
that take into account larger parts of the history re-
quire more data to obtain good accuracy, but they
are also faster. For each of the variants, adding
more training data after about 40 million words
does not lead to much further improvement; the
little improvement that is observed, is balanced by
a slight increase in parse times too.
It is interesting to note that the accuracy of some
of the filters improves slightly upon the baseline
parser (without any filtering). This can be ex-
plained by the fact that the Alpino parser includes
a best-first beam search to select the best parse
from the parse forest. Apparently, in some cases
the filter throws away candidate parses which
would otherwise confuse this heuristic best search
procedure.
</bodyText>
<subsectionHeader confidence="0.999244">
5.3 Experiment with D-Coi data
</subsectionHeader>
<bodyText confidence="0.999964388888889">
In this section, we confirm the experimental re-
sults obtained on the Alpino Treebank by perform-
ing similar experiments on the D-Coi data. The
purpose of this confirmation is twofold. On the
one hand, the Alpino Treebank might not be a
reliable test set for the Alpino parser, because it
has been used quite intensively during the devel-
opment of various components of the system. On
the other hand, we might regard the experiments in
the previous section as development experiments
from which we learn the best parameters of the
approach. The real evaluation of the technique is
now performed using only the best method found
on the development set, which is the prefix filter
with T = 0.
We performed experiments with two parts of the
D-Coi corpus. The first data set, P-P-H, contains
newspaper data, and is therefore comparable both
</bodyText>
<page confidence="0.994088">
822
</page>
<bodyText confidence="0.999972181818182">
with the Alpino Treebank, and more importantly,
with the training data that we used to develop the
filters. In order to check if the success of the fil-
tering methods requires that training data and test
data need to be taken from similar texts, we also
provide experimental results on a test set consist-
ing of different material: the P-P-L part of the
D-Coi corpus, which contains text extracted from
information brochures published by Dutch Min-
istries.
The third and fourth graphs in figure 4 provide
results obtained on the P-P-H corpus. The in-
creased efficiency of the prefix filter is slightly less
pronounced. This may be due to the smaller mean
sentence length of this data set. Still, the prefix fil-
tering method performs much better for a large va-
riety of time-outs. Only for very high, unrealistic,
time-outs, the baseline parser obtains better accu-
racy. The same general trend is observed in the
P-P-L data-set. From these results we tentatively
conclude that the proposed technique is applicable
across text types and domains.
</bodyText>
<sectionHeader confidence="0.999682" genericHeader="discussions">
6 Discussion
</sectionHeader>
<bodyText confidence="0.999983567164179">
One may wonder how the technique introduced in
this paper relates to techniques in which the dis-
ambiguation model is used directly during parsing
to eliminate unlikely partial parses. An example
in the context of wide coverage unification-based
parsing is the beam thresholding technique em-
ployed in the Enju HPSG parser for English (Tsu-
ruoka et al., 2004; Ninomiya et al., 2005).
In a beam-search parser, unlikely partial analy-
ses are constructed, and then - based on the proba-
bility assigned to these partial analyses - removed
from further consideration. One potential advan-
tage of the use of our filters may be, that many of
these partial analyses will not even be constructed
in the first place, and therefore no time is spent on
these alternatives at all.
We have not performed a detailed comparison,
because the statistical model employed in Alpino
contains some features which refer to arbitrary
large parts of a parse. Such non-local features are
not allowed in the Enju approach.
A parsing system may also combine both types
of techniques. In that case there is room for
further experimentation. For instance, during
the learning phase, it may be beneficial to allow
for a wider beam, to obtain more reliable filters.
During testing, the beam can perhaps be smaller
than usual, since the filters already rule out many
of the competing parses.
The idea that corpora can be used to improve
parsing efficiency was an important ingredient of
a technique that was called grammar specializa-
tion. An overview of grammar specialization tech-
niques is given in (Sima’an, 1999). For instance,
Rayner and Carter (1996) use explanation-based
learning to specialize a given general grammar to a
specific domain. They report important efficiency
gains (the parser is about three times faster), cou-
pled with a mild reduction of coverage (5% loss).
In contrast to our approach in which no manual
annotation is required, Rayner and Carter (1996)
report that for each sentence in the training data,
the best parse was selected manually from the set
of parses generated by the parser. For the exper-
iments described in the paper, this constituted an
effort of two and a half person-months. As a con-
sequence, they use only 15.000 training examples
(taken from ATIS, so presumably relatively short
sentences). In our experiments, we used up to 4
million sentences.
A further difference is related to the pruning
strategies. Our pruning strategies are extremely
simple. The cutting criteria employed in grammar
specialization either require carefully manually
tuning, or require more complicated statistical
techniques (Samuelsson, 1994); automatically
derived cutting criteria, however, perform consid-
erably worse.
A possible improvement of our approach con-
sists of predicting whether for a given input sen-
tence the filter should be used, or whether the sen-
tence appears to be ‘easy’ enough to allow for a
full parse. For instance, one may chose to use
the filter only for sentences of a given minimum
length. Initial experiments indicate that such a
setup may improve somewhat over the results pre-
sented here.
</bodyText>
<sectionHeader confidence="0.998028" genericHeader="acknowledgments">
Acknowledgments
</sectionHeader>
<bodyText confidence="0.99984225">
This research was carried out in part in the
context of the STEVIN programme which is
funded by the Dutch and Flemish governments
(http://taalunieversum.org/taal/technologie/stevin/).
</bodyText>
<page confidence="0.993859">
823
</page>
<figure confidence="0.999638238095238">
Accuracy (%CA)
20 40 60 80
Mean cputime (sec)
0 5 10 15
bigram
trigram
fourgram
prefix
no filter
Million words
20 40 60 80
Million words
bigram
trigram
fourgram
prefix
no filter
85 86 87 88
timeout (sec)
mean cputime (sec)
1 5 10 50 500
accuracy (%CA)
20 40 60 80
prefix filter
default
2 4 6 8 10
accuracy (%CA)
20 40 60 80
prefix filter
default
timeout (sec)
mean cputime (sec)
20 40 60 80
accuracy (%CA)
prefix filter
default
1 5 10 50 500
5 10 15
accuracy (%CA)
20 40 60 80
prefix filter
default
</figure>
<figureCaption confidence="0.998837">
Figure 4: The first two graphs present accuracy (left) and mean CPU-time (right) as a function of the
</figureCaption>
<bodyText confidence="0.5639778">
amount of training data used. Evaluation on 10% of the Alpino Treebank. The third and fourth graph
present accuracy versus time-out, and accuracy versus mean CPU-time for various time-outs. The graph
compares the baseline system with the parser which uses the prefix filter based on all available training
data. Evaluation on the D-Coi P-P-H 1-109 data-set (newspaper text). The two last graphs are similar,
based on the D-Coi P-P-L data-set (brochures).
</bodyText>
<page confidence="0.997159">
824
</page>
<sectionHeader confidence="0.993324" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999733038461538">
P. C. Uit den Boogaart. 1975. Woordfrequenties
in geschreven en gesproken Nederlands. Oost-
hoek, Scheltema &amp; Holkema, Utrecht. Werkgroep
Frequentie-onderzoek van het Nederlands.
Heleen Hoekstra, Michael Moortgat, Bram Renmans,
Machteld Schouppe, Ineke Schuurman, and Ton
van der Wouden, 2003. CGN Syntactische Anno-
tatie, December.
Y. Matsumoto, H. Tanaka, H. Hirakawa, H. Miyoshi,
and H. Yasukawa. 1983. BUP: a bottom up parser
embedded in Prolog. New Generation Computing,
1(2).
Takashi Ninomiya, Yoshimasa Tsuruoka, Yusuke
Miyao, and Jun’ichi Tsujii. 2005. Efficacy of beam
thresholding, unification filtering and hybrid pars-
ing. In Proceedings of the International Workshop
on Parsing Technologies (IWPT).
Roeland Ordelman, Franciska de Jong, Arjan van Hes-
sen, and Hendri Hondorp. 2007. Twnc: a mul-
tifaceted Dutch news corpus. ELRA Newsletter,
12(3/4):4–7.
Fernando C. N. Pereira and Stuart M. Shieber. 1987.
Prolog and Natural Language Analysis. Center for
the Study of Language and Information Stanford.
Manny Rayner and David Carter. 1996. Fast pars-
ing using pruning and grammar specialization. In
34th Annual Meeting of the Association for Compu-
tational Linguistics, Santa Cruz.
Christer Samuelsson. 1994. Grammar specialization
through entropy thresholds. In 32th Annual Meet-
ing of the Association for Computational Linguis-
tics, New Mexico. ACL.
Khalil Sima’an. 1999. Learning Efficient Disambigua-
tion. Ph.D. thesis, University of Utrecht.
Yoshimasa Tsuruoka, Yusuke Miyao, and Jun’ichi Tsu-
jii. 2004. Towards efficient probabilistic hpsg pars-
ing: integrating semantic and syntactic preference
to guide the parsing. In Beyond Shallow Analyses -
Formalisms and statistical modeling for deep analy-
ses, Hainan China. IJCNLP.
Leonoor van der Beek, Gosse Bouma, Robert Malouf,
and Gertjan van Noord. 2002. The Alpino depen-
dency treebank. In Computational Linguistics in the
Netherlands.
Gertjan van Noord, Ineke Schuurman, and Vincent
Vandeghinste. 2006. Syntactic annotation of large
corpora in STEVIN. In Proceedings of the 5th In-
ternational Conference on Language Resources and
Evaluation (LREC), Genoa, Italy.
Gertjan van Noord. 1997. An efficient implementation
of the head corner parser. Computational Linguis-
tics, 23(3):425–456. cmp-lg/9701004.
</reference>
<page confidence="0.998871">
825
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.986861">
<title confidence="0.999993">Learning Efficient Parsing</title>
<author confidence="0.99861">Gertjan van_Noord</author>
<affiliation confidence="0.999248">University of Groningen</affiliation>
<email confidence="0.990907">G.J.M.van.noord@rug.nl</email>
<abstract confidence="0.999842461538462">A corpus-based technique is described to improve the efficiency of wide-coverage high-accuracy parsers. By keeping track of the derivation steps which lead to the best parse for a very large collection of sentences, the parser learns which parse steps can be filtered without significant loss in parsing accuracy, but with an important increase in parsing efficiency. An interesting characteristic of our approach is that it is self-learning, in the sense that it uses unannotated corpora.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>P C Uit den Boogaart</author>
</authors>
<title>Woordfrequenties in geschreven en gesproken Nederlands. Oosthoek, Scheltema &amp; Holkema, Utrecht. Werkgroep Frequentie-onderzoek van het Nederlands.</title>
<date>1975</date>
<marker>den Boogaart, 1975</marker>
<rawString>P. C. Uit den Boogaart. 1975. Woordfrequenties in geschreven en gesproken Nederlands. Oosthoek, Scheltema &amp; Holkema, Utrecht. Werkgroep Frequentie-onderzoek van het Nederlands.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Heleen Hoekstra</author>
<author>Michael Moortgat</author>
<author>Bram Renmans</author>
</authors>
<date>2003</date>
<booktitle>Machteld Schouppe, Ineke Schuurman, and Ton</booktitle>
<contexts>
<context position="4021" citStr="Hoekstra et al., 2003" startWordPosition="646" endWordPosition="649">best-first search algorithm is applied. The algorithm consults a Maximum Entropy disambiguation model to judge the quality of (partial) parses. Although Alpino is not a dependency grammar Proceedings of the 12th Conference of the European Chapter of the ACL, pages 817–825, Athens, Greece, 30 March – 3 April 2009. c�2009 Association for Computational Linguistics 817 in the traditional sense, dependency structures are generated by the lexicon and grammar rules as the value of a dedicated attribute. The dependency structures are based on CGN (Corpus Gesproken Nederlands, Corpus of Spoken Dutch) (Hoekstra et al., 2003), D-Coi and LASSY (van Noord et al., 2006). 3 Methodology: balancing efficiency and accuracy 3.1 On-line and off-line parsing scenarios We focus on the speed of parsing, ignoring other computational properties such as memory usage. Problems with respect to parsing are twofold: on the one hand, parsing simply is too slow for many input sentences. On the other hand, the relation between input sentence and expected speed of parsing is typically unknown. For simple parsing systems based on finite-state, context-free or mildly context-sensitive grammars, it is possible to establish an upper-bound o</context>
</contexts>
<marker>Hoekstra, Moortgat, Renmans, 2003</marker>
<rawString>Heleen Hoekstra, Michael Moortgat, Bram Renmans, Machteld Schouppe, Ineke Schuurman, and Ton van der Wouden, 2003. CGN Syntactische Annotatie, December.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Y Matsumoto</author>
<author>H Tanaka</author>
<author>H Hirakawa</author>
<author>H Miyoshi</author>
<author>H Yasukawa</author>
</authors>
<title>BUP: a bottom up parser embedded in Prolog.</title>
<date>1983</date>
<journal>New Generation Computing,</journal>
<volume>1</volume>
<issue>2</issue>
<contexts>
<context position="10089" citStr="Matsumoto et al. (1983)" startWordPosition="1696" endWordPosition="1699">the relevant sequences of derivation steps, that were required to find that best parse. After the training phase, the parser filters those sequences of derivation steps that are unlikely to be useful. By filtering out unlikely derivation step sequences, efficiency is expected to improve. Since certain parses now become impossible, a drop in accuracy is expected as well. Although the idea of filtering derivation step sequences based on previous experience is fairly general, we define the method in more detail with respect to an actual parsing algorithm: the leftcorner parser along the lines of Matsumoto et al. (1983), Pereira and Shieber (1987, section 6.5) and van Noord (1997). 4.1 Left-corner parsing A left-corner parser is a bottom-up parser with top-down guidance, which is most easily explained as a non-deterministic search procedure. A specification of the left-corner algorithm can be provided in DCG as in figure 2 (Pereira and Shieber, 1987, section 6.5), where the filter/2 goals should be ignored for the moment. Here, we assume that dictionary look-up is performed by the word/3 predicate, with the first argument a given word, and the second argument its category; and that rules are accessible via t</context>
<context position="11641" citStr="Matsumoto et al. (1983)" startWordPosition="1964" endWordPosition="1967">he first word of the string, and show that this lexical category is a left-corner of the goal category. To show that a given category is a left-corner of a given goal category, a rule is selected. The leftmost daughter node of that rule is identified with the left-corner. The other daughters of the rule are parsed recursively. If this succeeds, it remains to show that the mother node of the rule is a leftcorner of the goal category. The recursion stops if a left-corner category can be identified with the goal category. This simple algorithm is improved and extended in a variety of ways, as in Matsumoto et al. (1983) and van Noord (1997), to make it efficient and practical. The extensions include a memoization of the parse/1 predicate and the construction of a shared parse forest (a compact representation of all parses). 4.2 Left-corner splines For the left-corner parser, the derivation step sequences that are of interested are left-corner splines. Such a spline consists of a goal category, and the rules and lexical entries which were used in the left-corner, in the order from the top to the bottom. A spline consists of a goal category, followed by a sequence of derivation step names. A derivation step na</context>
</contexts>
<marker>Matsumoto, Tanaka, Hirakawa, Miyoshi, Yasukawa, 1983</marker>
<rawString>Y. Matsumoto, H. Tanaka, H. Hirakawa, H. Miyoshi, and H. Yasukawa. 1983. BUP: a bottom up parser embedded in Prolog. New Generation Computing, 1(2).</rawString>
</citation>
<citation valid="true">
<authors>
<author>Takashi Ninomiya</author>
<author>Yoshimasa Tsuruoka</author>
<author>Yusuke Miyao</author>
<author>Jun’ichi Tsujii</author>
</authors>
<title>Efficacy of beam thresholding, unification filtering and hybrid parsing.</title>
<date>2005</date>
<booktitle>In Proceedings of the International Workshop on Parsing Technologies (IWPT).</booktitle>
<contexts>
<context position="25028" citStr="Ninomiya et al., 2005" startWordPosition="4173" endWordPosition="4176">time-outs, the baseline parser obtains better accuracy. The same general trend is observed in the P-P-L data-set. From these results we tentatively conclude that the proposed technique is applicable across text types and domains. 6 Discussion One may wonder how the technique introduced in this paper relates to techniques in which the disambiguation model is used directly during parsing to eliminate unlikely partial parses. An example in the context of wide coverage unification-based parsing is the beam thresholding technique employed in the Enju HPSG parser for English (Tsuruoka et al., 2004; Ninomiya et al., 2005). In a beam-search parser, unlikely partial analyses are constructed, and then - based on the probability assigned to these partial analyses - removed from further consideration. One potential advantage of the use of our filters may be, that many of these partial analyses will not even be constructed in the first place, and therefore no time is spent on these alternatives at all. We have not performed a detailed comparison, because the statistical model employed in Alpino contains some features which refer to arbitrary large parts of a parse. Such non-local features are not allowed in the Enju</context>
</contexts>
<marker>Ninomiya, Tsuruoka, Miyao, Tsujii, 2005</marker>
<rawString>Takashi Ninomiya, Yoshimasa Tsuruoka, Yusuke Miyao, and Jun’ichi Tsujii. 2005. Efficacy of beam thresholding, unification filtering and hybrid parsing. In Proceedings of the International Workshop on Parsing Technologies (IWPT).</rawString>
</citation>
<citation valid="true">
<authors>
<author>Roeland Ordelman</author>
<author>Franciska de Jong</author>
<author>Arjan van Hessen</author>
<author>Hendri Hondorp</author>
</authors>
<title>Twnc: a multifaceted Dutch news corpus.</title>
<date>2007</date>
<journal>ELRA Newsletter,</journal>
<pages>12--3</pages>
<marker>Ordelman, de Jong, van Hessen, Hondorp, 2007</marker>
<rawString>Roeland Ordelman, Franciska de Jong, Arjan van Hessen, and Hendri Hondorp. 2007. Twnc: a multifaceted Dutch news corpus. ELRA Newsletter, 12(3/4):4–7.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Fernando C N Pereira</author>
<author>Stuart M Shieber</author>
</authors>
<title>Prolog and Natural Language Analysis. Center for the Study of Language and Information Stanford.</title>
<date>1987</date>
<contexts>
<context position="10116" citStr="Pereira and Shieber (1987" startWordPosition="1700" endWordPosition="1703"> derivation steps, that were required to find that best parse. After the training phase, the parser filters those sequences of derivation steps that are unlikely to be useful. By filtering out unlikely derivation step sequences, efficiency is expected to improve. Since certain parses now become impossible, a drop in accuracy is expected as well. Although the idea of filtering derivation step sequences based on previous experience is fairly general, we define the method in more detail with respect to an actual parsing algorithm: the leftcorner parser along the lines of Matsumoto et al. (1983), Pereira and Shieber (1987, section 6.5) and van Noord (1997). 4.1 Left-corner parsing A left-corner parser is a bottom-up parser with top-down guidance, which is most easily explained as a non-deterministic search procedure. A specification of the left-corner algorithm can be provided in DCG as in figure 2 (Pereira and Shieber, 1987, section 6.5), where the filter/2 goals should be ignored for the moment. Here, we assume that dictionary look-up is performed by the word/3 predicate, with the first argument a given word, and the second argument its category; and that rules are accessible via the predicate rule/3, where </context>
<context position="16810" citStr="Pereira and Shieber, 1987" startWordPosition="2780" endWordPosition="2783"> step? In initial experiments, we used relative frequencies. For instance, the trigram filter would allow any tuple g, ri−2, ri−1, ri for some constant threshold τ, provided: C(g,... riri−1ri−2 ...) &gt; τ C(g,... ri−1ri−2 ...) However, we found that filters are more effective (and require much less space – see below), which simply require that every step has been observed often enough in the training data: C(g,... riri−1ri−2 ...) &gt; τ In particular, the case where τ = 0 gave surprisingly good results. 4.4 Comparison with link table The filter we developed is reminiscent of the link predicate of (Pereira and Shieber, 1987). An important difference with the filter developed here is that the link predicate removes derivation steps which cannot lead to a successful parse (by an offline global analysis of the grammar), whereas we filter out derivation steps which can lead to a full parse, but which are not expected to lead to a best parse. In our implementation, a variant of the link predicate is used as well. 4.5 Implementation detail The definition of the filter predicate depends on our choices with respect to the dimensions identified above. For instance, if we chose the trigram filter as our context size, then </context>
</contexts>
<marker>Pereira, Shieber, 1987</marker>
<rawString>Fernando C. N. Pereira and Stuart M. Shieber. 1987. Prolog and Natural Language Analysis. Center for the Study of Language and Information Stanford.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Manny Rayner</author>
<author>David Carter</author>
</authors>
<title>Fast parsing using pruning and grammar specialization.</title>
<date>1996</date>
<booktitle>In 34th Annual Meeting of the Association for Computational Linguistics,</booktitle>
<location>Santa Cruz.</location>
<contexts>
<context position="26265" citStr="Rayner and Carter (1996)" startWordPosition="4378" endWordPosition="4381">parsing system may also combine both types of techniques. In that case there is room for further experimentation. For instance, during the learning phase, it may be beneficial to allow for a wider beam, to obtain more reliable filters. During testing, the beam can perhaps be smaller than usual, since the filters already rule out many of the competing parses. The idea that corpora can be used to improve parsing efficiency was an important ingredient of a technique that was called grammar specialization. An overview of grammar specialization techniques is given in (Sima’an, 1999). For instance, Rayner and Carter (1996) use explanation-based learning to specialize a given general grammar to a specific domain. They report important efficiency gains (the parser is about three times faster), coupled with a mild reduction of coverage (5% loss). In contrast to our approach in which no manual annotation is required, Rayner and Carter (1996) report that for each sentence in the training data, the best parse was selected manually from the set of parses generated by the parser. For the experiments described in the paper, this constituted an effort of two and a half person-months. As a consequence, they use only 15.00</context>
</contexts>
<marker>Rayner, Carter, 1996</marker>
<rawString>Manny Rayner and David Carter. 1996. Fast parsing using pruning and grammar specialization. In 34th Annual Meeting of the Association for Computational Linguistics, Santa Cruz.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Christer Samuelsson</author>
</authors>
<title>Grammar specialization through entropy thresholds.</title>
<date>1994</date>
<booktitle>In 32th Annual Meeting of the Association for Computational Linguistics,</booktitle>
<publisher>ACL.</publisher>
<location>New Mexico.</location>
<contexts>
<context position="27272" citStr="Samuelsson, 1994" startWordPosition="4536" endWordPosition="4537">as selected manually from the set of parses generated by the parser. For the experiments described in the paper, this constituted an effort of two and a half person-months. As a consequence, they use only 15.000 training examples (taken from ATIS, so presumably relatively short sentences). In our experiments, we used up to 4 million sentences. A further difference is related to the pruning strategies. Our pruning strategies are extremely simple. The cutting criteria employed in grammar specialization either require carefully manually tuning, or require more complicated statistical techniques (Samuelsson, 1994); automatically derived cutting criteria, however, perform considerably worse. A possible improvement of our approach consists of predicting whether for a given input sentence the filter should be used, or whether the sentence appears to be ‘easy’ enough to allow for a full parse. For instance, one may chose to use the filter only for sentences of a given minimum length. Initial experiments indicate that such a setup may improve somewhat over the results presented here. Acknowledgments This research was carried out in part in the context of the STEVIN programme which is funded by the Dutch and</context>
</contexts>
<marker>Samuelsson, 1994</marker>
<rawString>Christer Samuelsson. 1994. Grammar specialization through entropy thresholds. In 32th Annual Meeting of the Association for Computational Linguistics, New Mexico. ACL.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Khalil Sima’an</author>
</authors>
<title>Learning Efficient Disambiguation.</title>
<date>1999</date>
<tech>Ph.D. thesis,</tech>
<institution>University of Utrecht.</institution>
<marker>Sima’an, 1999</marker>
<rawString>Khalil Sima’an. 1999. Learning Efficient Disambiguation. Ph.D. thesis, University of Utrecht.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Yoshimasa Tsuruoka</author>
<author>Yusuke Miyao</author>
<author>Jun’ichi Tsujii</author>
</authors>
<title>Towards efficient probabilistic hpsg parsing: integrating semantic and syntactic preference to guide the parsing. In Beyond Shallow Analyses -Formalisms and statistical modeling for deep analyses,</title>
<date>2004</date>
<publisher>IJCNLP.</publisher>
<location>Hainan</location>
<contexts>
<context position="25004" citStr="Tsuruoka et al., 2004" startWordPosition="4168" endWordPosition="4172">ery high, unrealistic, time-outs, the baseline parser obtains better accuracy. The same general trend is observed in the P-P-L data-set. From these results we tentatively conclude that the proposed technique is applicable across text types and domains. 6 Discussion One may wonder how the technique introduced in this paper relates to techniques in which the disambiguation model is used directly during parsing to eliminate unlikely partial parses. An example in the context of wide coverage unification-based parsing is the beam thresholding technique employed in the Enju HPSG parser for English (Tsuruoka et al., 2004; Ninomiya et al., 2005). In a beam-search parser, unlikely partial analyses are constructed, and then - based on the probability assigned to these partial analyses - removed from further consideration. One potential advantage of the use of our filters may be, that many of these partial analyses will not even be constructed in the first place, and therefore no time is spent on these alternatives at all. We have not performed a detailed comparison, because the statistical model employed in Alpino contains some features which refer to arbitrary large parts of a parse. Such non-local features are</context>
</contexts>
<marker>Tsuruoka, Miyao, Tsujii, 2004</marker>
<rawString>Yoshimasa Tsuruoka, Yusuke Miyao, and Jun’ichi Tsujii. 2004. Towards efficient probabilistic hpsg parsing: integrating semantic and syntactic preference to guide the parsing. In Beyond Shallow Analyses -Formalisms and statistical modeling for deep analyses, Hainan China. IJCNLP.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Leonoor van der Beek</author>
<author>Gosse Bouma</author>
<author>Robert Malouf</author>
<author>Gertjan van Noord</author>
</authors>
<title>The Alpino dependency treebank.</title>
<date>2002</date>
<booktitle>In Computational Linguistics in the Netherlands.</booktitle>
<marker>van der Beek, Bouma, Malouf, van Noord, 2002</marker>
<rawString>Leonoor van der Beek, Gosse Bouma, Robert Malouf, and Gertjan van Noord. 2002. The Alpino dependency treebank. In Computational Linguistics in the Netherlands.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Gertjan van Noord</author>
<author>Ineke Schuurman</author>
<author>Vincent Vandeghinste</author>
</authors>
<title>Syntactic annotation of large corpora in STEVIN.</title>
<date>2006</date>
<booktitle>In Proceedings of the 5th International Conference on Language Resources and Evaluation (LREC),</booktitle>
<location>Genoa, Italy.</location>
<marker>van Noord, Schuurman, Vandeghinste, 2006</marker>
<rawString>Gertjan van Noord, Ineke Schuurman, and Vincent Vandeghinste. 2006. Syntactic annotation of large corpora in STEVIN. In Proceedings of the 5th International Conference on Language Resources and Evaluation (LREC), Genoa, Italy.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Gertjan van Noord</author>
</authors>
<title>An efficient implementation of the head corner parser.</title>
<date>1997</date>
<journal>Computational Linguistics,</journal>
<volume>23</volume>
<issue>3</issue>
<pages>9701004</pages>
<marker>van Noord, 1997</marker>
<rawString>Gertjan van Noord. 1997. An efficient implementation of the head corner parser. Computational Linguistics, 23(3):425–456. cmp-lg/9701004.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>