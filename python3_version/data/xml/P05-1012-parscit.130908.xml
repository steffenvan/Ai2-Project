<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000467">
<title confidence="0.997088">
Online Large-Margin Training of Dependency Parsers
</title>
<author confidence="0.997421">
Ryan McDonald Koby Crammer Fernando Pereira
</author>
<affiliation confidence="0.9989185">
Department of Computer and Information Science
University of Pennsylvania
</affiliation>
<address confidence="0.609347">
Philadelphia, PA
</address>
<email confidence="0.998585">
{ryantm,crammer,pereira}@cis.upenn.edu
</email>
<sectionHeader confidence="0.998599" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.9999739">
We present an effective training al-
gorithm for linearly-scored dependency
parsers that implements online large-
margin multi-class training (Crammer and
Singer, 2003; Crammer et al., 2003) on
top of efficient parsing techniques for de-
pendency trees (Eisner, 1996). The trained
parsers achieve a competitive dependency
accuracy for both English and Czech with
no language specific enhancements.
</bodyText>
<sectionHeader confidence="0.999515" genericHeader="introduction">
1 Introduction
</sectionHeader>
<bodyText confidence="0.999959641509434">
Research on training parsers from annotated data
has for the most part focused on models and train-
ing algorithms for phrase structure parsing. The
best phrase-structure parsing models represent gen-
eratively the joint probability P(x, y) of sentence
x having the structure y (Collins, 1999; Charniak,
2000). Generative parsing models are very conve-
nient because training consists of computing proba-
bility estimates from counts of parsing events in the
training set. However, generative models make com-
plicated and poorly justified independence assump-
tions and estimations, so we might expect better per-
formance from discriminatively trained models, as
has been shown for other tasks like document classi-
fication (Joachims, 2002) and shallow parsing (Sha
and Pereira, 2003). Ratnaparkhi’s conditional max-
imum entropy model (Ratnaparkhi, 1999), trained
to maximize conditional likelihood P(y|x) of the
training data, performed nearly as well as generative
models of the same vintage even though it scores
parsing decisions in isolation and thus may suffer
from the label bias problem (Lafferty et al., 2001).
Discriminatively trained parsers that score entire
trees for a given sentence have only recently been
investigated (Riezler et al., 2002; Clark and Curran,
2004; Collins and Roark, 2004; Taskar et al., 2004).
The most likely reason for this is that discrimina-
tive training requires repeatedly reparsing the train-
ing corpus with the current model to determine the
parameter updates that will improve the training cri-
terion. The reparsing cost is already quite high
for simple context-free models with O(n3) parsing
complexity, but it becomes prohibitive for lexical-
ized grammars with O(n5) parsing complexity.
Dependency trees are an alternative syntactic rep-
resentation with a long history (Hudson, 1984). De-
pendency trees capture important aspects of func-
tional relationships between words and have been
shown to be useful in many applications includ-
ing relation extraction (Culotta and Sorensen, 2004),
paraphrase acquisition (Shinyama et al., 2002) and
machine translation (Ding and Palmer, 2005). Yet,
they can be parsed in O(n3) time (Eisner, 1996).
Therefore, dependency parsing is a potential “sweet
spot” that deserves investigation. We focus here on
projective dependency trees in which a word is the
parent of all of its arguments, and dependencies are
non-crossing with respect to word order (see Fig-
ure 1). However, there are cases where crossing
dependencies may occur, as is the case for Czech
(Hajiˇc, 1998). Edges in a dependency tree may be
typed (for instance to indicate grammatical func-
tion). Though we focus on the simpler non-typed
</bodyText>
<page confidence="0.984951">
91
</page>
<note confidence="0.831275666666667">
Proceedings of the 43rd Annual Meeting of the ACL, pages 91–98,
Ann Arbor, June 2005. c�2005 Association for Computational Linguistics
root John hit the ball with the bat
</note>
<figureCaption confidence="0.997659">
Figure 1: An example dependency tree.
</figureCaption>
<bodyText confidence="0.997766">
case, all algorithms are easily extendible to typed
structures.
The following work on dependency parsing is
most relevant to our research. Eisner (1996) gave
a generative model with a cubic parsing algorithm
based on an edge factorization of trees. Yamada and
Matsumoto (2003) trained support vector machines
(SVM) to make parsing decisions in a shift-reduce
dependency parser. As in Ratnaparkhi’s parser, the
classifiers are trained on individual decisions rather
than on the overall quality of the parse. Nivre and
Scholz (2004) developed a history-based learning
model. Their parser uses a hybrid bottom-up/top-
down linear-time heuristic parser and the ability to
label edges with semantic types. The accuracy of
their parser is lower than that of Yamada and Mat-
sumoto (2003).
We present a new approach to training depen-
dency parsers, based on the online large-margin
learning algorithms of Crammer and Singer (2003)
and Crammer et al. (2003). Unlike the SVM
parser of Yamada and Matsumoto (2003) and Ratna-
parkhi’s parser, our parsers are trained to maximize
the accuracy of the overall tree.
Our approach is related to those of Collins and
Roark (2004) and Taskar et al. (2004) for phrase
structure parsing. Collins and Roark (2004) pre-
sented a linear parsing model trained with an aver-
aged perceptron algorithm. However, to use parse
features with sufficient history, their parsing algo-
rithm must prune heuristically most of the possible
parses. Taskar et al. (2004) formulate the parsing
problem in the large-margin structured classification
setting (Taskar et al., 2003), but are limited to pars-
ing sentences of 15 words or less due to computation
time. Though these approaches represent good first
steps towards discriminatively-trained parsers, they
have not yet been able to display the benefits of dis-
criminative training that have been seen in named-
entity extraction and shallow parsing.
Besides simplicity, our method is efficient and ac-
curate, as we demonstrate experimentally on English
and Czech treebank data.
</bodyText>
<sectionHeader confidence="0.99304" genericHeader="method">
2 System Description
</sectionHeader>
<subsectionHeader confidence="0.998935">
2.1 Definitions and Background
</subsectionHeader>
<bodyText confidence="0.999976363636364">
In what follows, the generic sentence is denoted by
x (possibly subscripted); the ith word of x is de-
noted by xi. The generic dependency tree is denoted
by y. If y is a dependency tree for sentence x, we
write (i, j) E y to indicate that there is a directed
edge from word xi to word xj in the tree, that is, xi
is the parent of xj. T = {(xt, yt)}t_1 denotes the
training data.
We follow the edge based factorization method of
Eisner (1996) and define the score of a dependency
tree as the sum of the score of all edges in the tree,
</bodyText>
<equation confidence="0.9930005">
s(x, y) = � s(i, j) = � w · f(i, j)
(i,j)Ey (i,j)Ey
</equation>
<bodyText confidence="0.9999595">
where f(i, j) is a high-dimensional binary feature
representation of the edge from xi to xj. For exam-
ple, in the dependency tree of Figure 1, the following
feature would have a value of 1:
</bodyText>
<equation confidence="0.997994">
� = 1 if xi=‘hit’ and xj=‘ball’
f (i, j) 0 otherwise.
</equation>
<bodyText confidence="0.999925222222222">
In general, any real-valued feature may be used, but
we use binary features for simplicity. The feature
weights in the weight vector w are the parameters
that will be learned during training. Our training al-
gorithms are iterative. We denote by w(i) the weight
vector after the ith training iteration.
Finally we define dt(x) as the set of possi-
ble dependency trees for the input sentence x and
bestk(x; w) as the set of k dependency trees in dt(x)
that are given the highest scores by weight vector w,
with ties resolved by an arbitrary but fixed rule.
Three basic questions must be answered for mod-
els of this form: how to find the dependency tree y
with highest score for sentence x; how to learn an
appropriate weight vector w from the training data;
and finally, what feature representation f(i, j) should
be used. The following sections address each of
these questions.
</bodyText>
<subsectionHeader confidence="0.998881">
2.2 Parsing Algorithm
</subsectionHeader>
<bodyText confidence="0.794943">
Given a feature representation for edges and a
weight vector w, we seek the dependency tree or
</bodyText>
<page confidence="0.818051">
92
</page>
<equation confidence="0.87069725">
h1
h1 h2 h2
�
�
h1
h1
h1 h1 h2 h2
s h1 h1 r r+1 h2 h2 t s h1 h1 h2 h2 t s h1 h1 t
</equation>
<figureCaption confidence="0.92356">
Figure 2: O(n3) algorithm of Eisner (1996), needs to keep 3 indices at any given stage.
</figureCaption>
<bodyText confidence="0.9999694375">
trees that maximize the score function, s(x, y). The
primary difficulty is that for a given sentence of
length n there are exponentially many possible de-
pendency trees. Using a slightly modified version of
a lexicalized CKY chart parsing algorithm, it is pos-
sible to generate and represent these sentences in a
forest that is O(n5) in size and takes O(n5) time to
create.
Eisner (1996) made the observation that if the
head of each chart item is on the left or right periph-
ery, then it is possible to parse in O(n3). The idea is
to parse the left and right dependents of a word inde-
pendently and combine them at a later stage. This re-
moves the need for the additional head indices of the
O(n5) algorithm and requires only two additional
binary variables that specify the direction of the item
(either gathering left dependents or gathering right
dependents) and whether an item is complete (avail-
able to gather more dependents). Figure 2 shows
the algorithm schematically. As with normal CKY
parsing, larger elements are created bottom-up from
pairs of smaller elements.
Eisner showed that his algorithm is sufficient for
both searching the space of dependency parses and,
with slight modification, finding the highest scoring
tree y for a given sentence x under the edge fac-
torization assumption. Eisner and Satta (1999) give
a cubic algorithm for lexicalized phrase structures.
However, it only works for a limited class of lan-
guages in which tree spines are regular. Further-
more, there is a large grammar constant, which is
typically in the thousands for treebank parsers.
</bodyText>
<subsectionHeader confidence="0.994395">
2.3 Online Learning
</subsectionHeader>
<bodyText confidence="0.9153715">
Figure 3 gives pseudo-code for the generic online
learning setting. A single training instance is con-
sidered on each iteration, and parameters updated
by applying an algorithm-specific update rule to the
instance under consideration. The algorithm in Fig-
ure 3 returns an averaged weight vector: an auxil-
iary weight vector v is maintained that accumulates
Training data: T = {(xt, yt)}Tt�1
</bodyText>
<listItem confidence="0.935063142857143">
1. w0 = 0; v = 0; i = 0
2. for n : 1..N
3. fort : 1..T
4. w(i+1) = update w(i) according to instance (xt, yt)
5. v = v + w(i+1)
6. i = i + 1
7.w=v/(N*T)
</listItem>
<figureCaption confidence="0.998284">
Figure 3: Generic online learning algorithm.
</figureCaption>
<bodyText confidence="0.99070625">
the values of w after each iteration, and the returned
weight vector is the average of all the weight vec-
tors throughout training. Averaging has been shown
to help reduce overfitting (Collins, 2002).
</bodyText>
<subsectionHeader confidence="0.655184">
2.3.1 MIRA
</subsectionHeader>
<bodyText confidence="0.9963265">
Crammer and Singer (2001) developed a natural
method for large-margin multi-class classification,
which was later extended by Taskar et al. (2003) to
structured classification:
</bodyText>
<construct confidence="0.674977666666667">
min IwII
s.t. s(x, y) − s(x, y&apos;) &gt; L(y, y&apos;)
b(x, y) E T, y&apos; E dt(x)
</construct>
<bodyText confidence="0.999947571428571">
where L(y, y&apos;) is a real-valued loss for the tree y&apos;
relative to the correct tree y. We define the loss of
a dependency tree as the number of words that have
the incorrect parent. Thus, the largest loss a depen-
dency tree can have is the length of the sentence.
Informally, this update looks to create a margin
between the correct dependency tree and each incor-
rect dependency tree at least as large as the loss of
the incorrect tree. The more errors a tree has, the
farther away its score will be from the score of the
correct tree. In order to avoid a blow-up in the norm
of the weight vector we minimize it subject to con-
straints that enforce the desired margin between the
correct and incorrect trees1.
</bodyText>
<footnote confidence="0.987267">
1The constraints may be unsatisfiable, in which case we can
relax them with slack variables as in SVM training.
</footnote>
<page confidence="0.998601">
93
</page>
<bodyText confidence="0.999721636363636">
The Margin Infused Relaxed Algorithm
(MIRA) (Crammer and Singer, 2003; Cram-
mer et al., 2003) employs this optimization directly
within the online framework. On each update,
MIRA attempts to keep the norm of the change to
the parameter vector as small as possible, subject to
correctly classifying the instance under considera-
tion with a margin at least as large as the loss of the
incorrect classifications. This can be formalized by
substituting the following update into line 4 of the
generic online algorithm,
</bodyText>
<equation confidence="0.92020875">
�
min �w(Z+1) − w(Z)II
s.t. s(xt, yt) − s(xt, y&apos;) ≥ L(yt, y&apos;) (1)
∀y&apos; ∈ dt(xt)
</equation>
<bodyText confidence="0.999891454545455">
This is a standard quadratic programming prob-
lem that can be easily solved using Hildreth’s al-
gorithm (Censor and Zenios, 1997). Crammer and
Singer (2003) and Crammer et al. (2003) provide
an analysis of both the online generalization error
and convergence properties of MIRA. In equation
(1), s(x, y) is calculated with respect to the weight
vector after optimization, w(Z+1).
To apply MIRA to dependency parsing, we can
simply see parsing as a multi-class classification
problem in which each dependency tree is one of
many possible classes for a sentence. However, that
interpretation fails computationally because a gen-
eral sentence has exponentially many possible de-
pendency trees and thus exponentially many margin
constraints.
To circumvent this problem we make the assump-
tion that the constraints that matter for large margin
optimization are those involving the incorrect trees
y&apos; with the highest scores s(x, y&apos;). The resulting
optimization made by MIRA (see Figure 3, line 4)
would then be:
</bodyText>
<equation confidence="0.93768375">
�
min �w(Z+1) − w(Z)II
s.t. s(xt, yt) − s(xt, y&apos;) ≥ L(yt, y&apos;)
∀y&apos; ∈ bestk(xt; w(Z))
</equation>
<bodyText confidence="0.9999424">
reducing the number of constraints to the constant k.
We tested various values of k on a development data
set and found that small values of k are sufficient to
achieve close to best performance, justifying our as-
sumption. In fact, as k grew we began to observe a
slight degradation of performance, indicating some
overfitting to the training data. All the experiments
presented here use k = 5. The Eisner (1996) algo-
rithm can be modified to find the k-best trees while
only adding an additional O(k log k) factor to the
runtime (Huang and Chiang, 2005).
A more common approach is to factor the struc-
ture of the output space to yield a polynomial set of
local constraints (Taskar et al., 2003; Taskar et al.,
2004). One such factorization for dependency trees
</bodyText>
<equation confidence="0.96583">
is
�
min �w(Z+1) − w(Z)II
s.t. s(l, j) − s(k, j) ≥ 1
∀(l, j) ∈ yt, (k, j) ∈� yt
</equation>
<bodyText confidence="0.999988666666667">
It is trivial to show that if these O(n2) constraints
are satisfied, then so are those in (1). We imple-
mented this model, but found that the required train-
ing time was much larger than the k-best formu-
lation and typically did not improve performance.
Furthermore, the k-best formulation is more flexi-
ble with respect to the loss function since it does not
assume the loss function can be factored into a sum
of terms for each dependency.
</bodyText>
<subsectionHeader confidence="0.991212">
2.4 Feature Set
</subsectionHeader>
<bodyText confidence="0.999942608695652">
Finally, we need a suitable feature representation
f(i, j) for each dependency. The basic features in
our model are outlined in Table 1a and b. All fea-
tures are conjoined with the direction of attachment
as well as the distance between the two words being
attached. These features represent a system of back-
off from very specific features over words and part-
of-speech tags to less sparse features over just part-
of-speech tags. These features are added for both the
entire words as well as the 5-gram prefix if the word
is longer than 5 characters.
Using just features over the parent-child node
pairs in the tree was not enough for high accuracy,
because all attachment decisions were made outside
of the context in which the words occurred. To solve
this problem, we added two other types of features,
which can be seen in Table 1c. Features of the first
type look at words that occur between a child and
its parent. These features take the form of a POS
trigram: the POS of the parent, of the child, and of
a word in between, for all words linearly between
the parent and the child. This feature was particu-
larly helpful for nouns identifying their parent, since
</bodyText>
<page confidence="0.994826">
94
</page>
<table confidence="0.97862356">
a)
Basic Uni-gram Features
p-word, p-pos
p-word
p-pos
c-word, c-pos
c-word
c-pos
b)
Basic Big-ram Features
p-word, p-pos, c-word, c-pos
p-pos, c-word, c-pos
p-word, c-word, c-pos
p-word, p-pos, c-pos
p-word, p-pos, c-word
p-word, c-word
p-pos, c-pos
c)
In Between POS Features
p-pos, b-pos, c-pos
Surrounding Word POS Features
p-pos, p-pos+1, c-pos-1, c-pos
p-pos-1, p-pos, c-pos-1, c-pos
p-pos, p-pos+1, c-pos, c-pos+1
p-pos-1, p-pos, c-pos, c-pos+1
</table>
<tableCaption confidence="0.998236">
Table 1: Features used by system. p-word: word of parent node in dependency tree. c-word: word of child
</tableCaption>
<bodyText confidence="0.9242114375">
node. p-pos: POS of parent node. c-pos: POS of child node. p-pos+1: POS to the right of parent in sentence.
p-pos-1: POS to the left of parent. c-pos+1: POS to the right of child. c-pos-1: POS to the left of child.
b-pos: POS of a word in between parent and child nodes.
it would typically rule out situations when a noun
attached to another noun with a verb in between,
which is a very uncommon phenomenon.
The second type of feature provides the local con-
text of the attachment, that is, the words before and
after the parent-child pair. This feature took the form
of a POS 4-gram: The POS of the parent, child,
word before/after parent and word before/after child.
The system also used back-off features to various tri-
grams where one of the local context POS tags was
removed. Adding these two features resulted in a
large improvement in performance and brought the
system to state-of-the-art accuracy.
</bodyText>
<subsectionHeader confidence="0.991075">
2.5 System Summary
</subsectionHeader>
<bodyText confidence="0.99979528">
Besides performance (see Section 3), the approach
to dependency parsing we described has several
other advantages. The system is very general and
contains no language specific enhancements. In fact,
the results we report for English and Czech use iden-
tical features, though are obviously trained on differ-
ent data. The online learning algorithms themselves
are intuitive and easy to implement.
The efficient O(n3) parsing algorithm of Eisner
allows the system to search the entire space of de-
pendency trees while parsing thousands of sentences
in a few minutes, which is crucial for discriminative
training. We compare the speed of our model to a
standard lexicalized phrase structure parser in Sec-
tion 3.1 and show a significant improvement in pars-
ing times on the testing data.
The major limiting factor of the system is its re-
striction to features over single dependency attach-
ments. Often, when determining the next depen-
dent for a word, it would be useful to know previ-
ous attachment decisions and incorporate these into
the features. It is fairly straightforward to modify
the parsing algorithm to store previous attachments.
However, any modification would result in an as-
ymptotic increase in parsing complexity.
</bodyText>
<sectionHeader confidence="0.999709" genericHeader="method">
3 Experiments
</sectionHeader>
<bodyText confidence="0.999952384615385">
We tested our methods experimentally on the Eng-
lish Penn Treebank (Marcus et al., 1993) and on the
Czech Prague Dependency Treebank (Hajiˇc, 1998).
All experiments were run on a dual 64-bit AMD
Opteron 2.4GHz processor.
To create dependency structures from the Penn
Treebank, we used the extraction rules of Yamada
and Matsumoto (2003), which are an approximation
to the lexicalization rules of Collins (1999). We split
the data into three parts: sections 02-21 for train-
ing, section 22 for development and section 23 for
evaluation. Currently the system has 6, 998, 447 fea-
tures. Each instance only uses a tiny fraction of these
features making sparse vector calculations possible.
Our system assumes POS tags as input and uses the
tagger of Ratnaparkhi (1996) to provide tags for the
development and evaluation sets.
Table 2 shows the performance of the systems
that were compared. Y&amp;M2003 is the SVM-shift-
reduce parsing model of Yamada and Matsumoto
(2003), N&amp;S2004 is the memory-based learner of
Nivre and Scholz (2004) and MIRA is the the sys-
tem we have described. We also implemented an av-
eraged perceptron system (Collins, 2002) (another
online learning algorithm) for comparison. This ta-
ble compares only pure dependency parsers that do
</bodyText>
<page confidence="0.994968">
95
</page>
<table confidence="0.999083333333333">
English Czech
Accuracy Root Complete Accuracy Root Complete
Y&amp;M2003 90.3 91.6 38.4 - - -
N&amp;S2004 87.3 84.3 30.4 - - -
Avg. Perceptron 90.6 94.0 36.5 82.9 88.0 30.3
MIRA 90.9 94.2 37.5 83.3 88.6 31.3
</table>
<tableCaption confidence="0.990064">
Table 2: Dependency parsing results for English and Czech. Accuracy is the number of words that correctly
</tableCaption>
<bodyText confidence="0.994183566666667">
identified their parent in the tree. Root is the number of trees in which the root word was correctly identified.
For Czech this is f-measure since a sentence may have multiple roots. Complete is the number of sentences
for which the entire dependency tree was correct.
not exploit phrase structure. We ensured that the
gold standard dependencies of all systems compared
were identical.
Table 2 shows that the model described here per-
forms as well or better than previous comparable
systems, including that of Yamada and Matsumoto
(2003). Their method has the potential advantage
that SVM batch training takes into account all of
the constraints from all training instances in the op-
timization, whereas online training only considers
constraints from one instance at a time. However,
they are fundamentally limited by their approximate
search algorithm. In contrast, our system searches
the entire space of dependency trees and most likely
benefits greatly from this. This difference is am-
plified when looking at the percentage of trees that
correctly identify the root word. The models that
search the entire space will not suffer from bad ap-
proximations made early in the search and thus are
more likely to identify the correct root, whereas the
approximate algorithms are prone to error propaga-
tion, which culminates with attachment decisions at
the top of the tree. When comparing the two online
learning models, it can be seen that MIRA outper-
forms the averaged perceptron method. This differ-
ence is statistically significant, p &lt; 0.005 (McNe-
mar test on head selection accuracy).
In our Czech experiments, we used the depen-
dency trees annotated in the Prague Treebank, and
the predefined training, development and evaluation
sections of this data. The number of sentences in
this data set is nearly twice that of the English tree-
bank, leading to a very large number of features —
13, 450, 672. But again, each instance uses just a
handful of these features. For POS tags we used the
automatically generated tags in the data set. Though
we made no language specific model changes, we
did need to make some data specific changes. In par-
ticular, we used the method of Collins et al. (1999) to
simplify part-of-speech tags since the rich tags used
by Czech would have led to a large but rarely seen
set of POS features.
The model based on MIRA also performs well on
Czech, again slightly outperforming averaged per-
ceptron. Unfortunately, we do not know of any other
parsing systems tested on the same data set. The
Czech parser of Collins et al. (1999) was run on a
different data set and most other dependency parsers
are evaluated using English. Learning a model from
the Czech training data is somewhat problematic
since it contains some crossing dependencies which
cannot be parsed by the Eisner algorithm. One trick
is to rearrange the words in the training set so that
all trees are nested. This at least allows the train-
ing algorithm to obtain reasonably low error on the
training set. We found that this did improve perfor-
mance slightly to 83.6% accuracy.
</bodyText>
<subsectionHeader confidence="0.998908">
3.1 Lexicalized Phrase Structure Parsers
</subsectionHeader>
<bodyText confidence="0.9999688">
It is well known that dependency trees extracted
from lexicalized phrase structure parsers (Collins,
1999; Charniak, 2000) typically are more accurate
than those produced by pure dependency parsers
(Yamada and Matsumoto, 2003). We compared
our system to the Bikel re-implementation of the
Collins parser (Bikel, 2004; Collins, 1999) trained
with the same head rules of our system. There are
two ways to extract dependencies from lexicalized
phrase structure. The first is to use the automatically
generated dependencies that are explicit in the lex-
icalization of the trees, we call this system Collins-
auto. The second is to take just the phrase structure
output of the parser and run the automatic head rules
over it to extract the dependencies, we call this sys-
</bodyText>
<page confidence="0.99047">
96
</page>
<table confidence="0.998345333333333">
English
Accuracy Root Complete Complexity Time
Collins-auto 88.2 92.3 36.1 O(n5) 98m 21s
Collins-rules 91.4 95.1 42.6 O(n5) 98m 21s
MIRA-Normal 90.9 94.2 37.5 O(n3) 5m 52s
MIRA-Collins 92.2 95.8 42.9 O(n5) 105m 08s
</table>
<tableCaption confidence="0.969711">
Table 3: Results comparing our system to those based on the Collins parser. Complexity represents the
computational complexity of each parser and Time the CPU time to parse sec. 23 of the Penn Treebank.
</tableCaption>
<bodyText confidence="0.998528894736842">
tem Collins-rules. Table 3 shows the results compar-
ing our system, MIRA-Normal, to the Collins parser
for English. All systems are implemented in Java
and run on the same machine.
Interestingly, the dependencies that are automati-
cally produced by the Collins parser are worse than
those extracted statically using the head rules. Ar-
guably, this displays the artificialness of English de-
pendency parsing using dependencies automatically
extracted from treebank phrase-structure trees. Our
system falls in-between, better than the automati-
cally generated dependency trees and worse than the
head-rule extracted trees.
Since the dependencies returned from our system
are better than those actually learnt by the Collins
parser, one could argue that our model is actu-
ally learning to parse dependencies more accurately.
However, phrase structure parsers are built to max-
imize the accuracy of the phrase structure and use
lexicalization as just an additional source of infor-
mation. Thus it is not too surprising that the de-
pendencies output by the Collins parser are not as
accurate as our system, which is trained and built to
maximize accuracy on dependency trees. In com-
plexity and run-time, our system is a huge improve-
ment over the Collins parser.
The final system in Table 3 takes the output of
Collins-rules and adds a feature to MIRA-Normal
that indicates for given edge, whether the Collins
parser believed this dependency actually exists, we
call this system MIRA-Collins. This is a well known
discriminative training trick — using the sugges-
tions of a generative system to influence decisions.
This system can essentially be considered a correc-
tor of the Collins parser and represents a significant
improvement over it. However, there is an added
complexity with such a model as it requires the out-
put of the O(n5) Collins parser.
</bodyText>
<table confidence="0.959401666666667">
k=1 k=2 k=5 k=10 k=20
90.73 90.82 90.88 90.92 90.91
183m 235m 627m 1372m 2491m
</table>
<tableCaption confidence="0.999799">
Table 4: Evaluation of k-best MIRA approximation.
</tableCaption>
<subsectionHeader confidence="0.996137">
3.2 k-best NIRA Approximation
</subsectionHeader>
<bodyText confidence="0.99983575">
One question that can be asked is how justifiable is
the k-best MIRA approximation. Table 4 indicates
the accuracy on testing and the time it took to train
models with k = 1, 2, 5, 10, 20 for the English data
set. Even though the parsing algorithm is propor-
tional to O(k log k), empirically, the training times
scale linearly with k. Peak performance is achieved
very early with a slight degradation around k=20.
The most likely reason for this phenomenon is that
the model is overfitting by ensuring that even un-
likely trees are separated from the correct tree pro-
portional to their loss.
</bodyText>
<sectionHeader confidence="0.999466" genericHeader="method">
4 Summary
</sectionHeader>
<bodyText confidence="0.999970470588235">
We described a successful new method for training
dependency parsers. We use simple linear parsing
models trained with margin-sensitive online training
algorithms, achieving state-of-the-art performance
with relatively modest training times and no need
for pruning heuristics. We evaluated the system on
both English and Czech data to display state-of-the-
art performance without any language specific en-
hancements. Furthermore, the model can be aug-
mented to include features over lexicalized phrase
structure parsing decisions to increase dependency
accuracy over those parsers.
We plan on extending our parser in two ways.
First, we would add labels to dependencies to rep-
resent grammatical roles. Those labels are very im-
portant for using parser output in tasks like infor-
mation extraction or machine translation. Second,
</bodyText>
<figure confidence="0.629347">
Accuracy
Train Time
</figure>
<page confidence="0.994749">
97
</page>
<bodyText confidence="0.999562538461538">
we are looking at model extensions to allow non-
projective dependencies, which occur in languages
such as Czech, German and Dutch.
J. Eisner and G. Satta. 1999. Efficient parsing for bilexi-
cal context-free grammars and head-automaton gram-
mars. In Proc. ACL.
Acknowledgments: We thank Jan Hajiˇc for an-
swering queries on the Prague treebank, and Joakim
Nivre for providing the Yamada and Matsumoto
(2003) head rules for English that allowed for a di-
rect comparison with our systems. This work was
supported by NSF ITR grants 0205456, 0205448,
and 0428193.
</bodyText>
<sectionHeader confidence="0.99968" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999850263888889">
D.M. Bikel. 2004. Intricacies of Collins parsing model.
Computational Linguistics.
Y. Censor and S.A. Zenios. 1997. Parallel optimization :
theory, algorithms, and applications. Oxford Univer-
sity Press.
E. Charniak. 2000. A maximum-entropy-inspired parser.
In Proc. NAACL.
S. Clark and J.R. Curran. 2004. Parsing the WSJ using
CCG and log-linear models. In Proc. ACL.
M. Collins and B. Roark. 2004. Incremental parsing with
the perceptron algorithm. In Proc. ACL.
M. Collins, J. Hajiˇc, L. Ramshaw, and C. Tillmann. 1999.
A statistical parser for Czech. In Proc. ACL.
M. Collins. 1999. Head-Driven Statistical Models for
Natural Language Parsing. Ph.D. thesis, University
of Pennsylvania.
M. Collins. 2002. Discriminative training methods for
hidden Markov models: Theory and experiments with
perceptron algorithms. In Proc. EMNLP.
K. Crammer and Y. Singer. 2001. On the algorithmic
implementation of multiclass kernel based vector ma-
chines. JMLR.
K. Crammer and Y. Singer. 2003. Ultraconservative on-
line algorithms for multiclass problems. JMLR.
K. Crammer, O. Dekel, S. Shalev-Shwartz, and Y. Singer.
2003. Online passive aggressive algorithms. In Proc.
NIPS.
A. Culotta and J. Sorensen. 2004. Dependency tree ker-
nels for relation extraction. In Proc. ACL.
Y. Ding and M. Palmer. 2005. Machine translation using
probabilistic synchronous dependency insertion gram-
mars. In Proc. ACL.
J. Eisner. 1996. Three new probabilistic models for de-
pendency parsing: An exploration. In Proc. COLING.
J. Hajiˇc. 1998. Building a syntactically annotated cor-
pus: The Prague dependency treebank. Issues of Va-
lency and Meaning.
L. Huang and D. Chiang. 2005. Better k-best parsing.
Technical Report MS-CIS-05-08, University of Penn-
sylvania.
Richard Hudson. 1984. Word Grammar. Blackwell.
T. Joachims. 2002. Learning to Classify Text using Sup-
port Vector Machines. Kluwer.
J. Lafferty, A. McCallum, and F. Pereira. 2001. Con-
ditional random fields: Probabilistic models for seg-
menting and labeling sequence data. In Proc. ICML.
M. Marcus, B. Santorini, and M. Marcinkiewicz. 1993.
Building a large annotated corpus of english: the penn
treebank. Computational Linguistics.
J. Nivre and M. Scholz. 2004. Deterministic dependency
parsing of english text. In Proc. COLING.
A. Ratnaparkhi. 1996. A maximum entropy model for
part-of-speech tagging. In Proc. EMNLP.
A. Ratnaparkhi. 1999. Learning to parse natural
language with maximum entropy models. Machine
Learning.
S. Riezler, T. King, R. Kaplan, R. Crouch, J. Maxwell,
and M. Johnson. 2002. Parsing the Wall Street Journal
using a lexical-functional grammar and discriminative
estimation techniques. In Proc. ACL.
F. Sha and F. Pereira. 2003. Shallow parsing with condi-
tional random fields. In Proc. HLT-NAACL.
Y. Shinyama, S. Sekine, K. Sudo, and R. Grishman.
2002. Automatic paraphrase acquisition from news ar-
ticles. In Proc. HLT.
B. Taskar, C. Guestrin, and D. Koller. 2003. Max-margin
Markov networks. In Proc. NIPS.
B. Taskar, D. Klein, M. Collins, D. Koller, and C. Man-
ning. 2004. Max-margin parsing. In Proc. EMNLP.
H. Yamada and Y. Matsumoto. 2003. Statistical depen-
dency analysis with support vector machines. In Proc.
IWPT.
</reference>
<page confidence="0.996228">
98
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.987489">
<title confidence="0.999976">Online Large-Margin Training of Dependency Parsers</title>
<author confidence="0.999935">Ryan McDonald Koby Crammer Fernando Pereira</author>
<affiliation confidence="0.9999025">Department of Computer and Information Science University of Pennsylvania</affiliation>
<address confidence="0.992346">Philadelphia, PA</address>
<abstract confidence="0.999567818181818">We present an effective training algorithm for linearly-scored dependency parsers that implements online largemargin multi-class training (Crammer and Singer, 2003; Crammer et al., 2003) on top of efficient parsing techniques for dependency trees (Eisner, 1996). The trained parsers achieve a competitive dependency accuracy for both English and Czech with no language specific enhancements.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>D M Bikel</author>
</authors>
<title>Intricacies of Collins parsing model. Computational Linguistics.</title>
<date>2004</date>
<contexts>
<context position="22873" citStr="Bikel, 2004" startWordPosition="3830" endWordPosition="3831"> One trick is to rearrange the words in the training set so that all trees are nested. This at least allows the training algorithm to obtain reasonably low error on the training set. We found that this did improve performance slightly to 83.6% accuracy. 3.1 Lexicalized Phrase Structure Parsers It is well known that dependency trees extracted from lexicalized phrase structure parsers (Collins, 1999; Charniak, 2000) typically are more accurate than those produced by pure dependency parsers (Yamada and Matsumoto, 2003). We compared our system to the Bikel re-implementation of the Collins parser (Bikel, 2004; Collins, 1999) trained with the same head rules of our system. There are two ways to extract dependencies from lexicalized phrase structure. The first is to use the automatically generated dependencies that are explicit in the lexicalization of the trees, we call this system Collinsauto. The second is to take just the phrase structure output of the parser and run the automatic head rules over it to extract the dependencies, we call this sys96 English Accuracy Root Complete Complexity Time Collins-auto 88.2 92.3 36.1 O(n5) 98m 21s Collins-rules 91.4 95.1 42.6 O(n5) 98m 21s MIRA-Normal 90.9 94</context>
</contexts>
<marker>Bikel, 2004</marker>
<rawString>D.M. Bikel. 2004. Intricacies of Collins parsing model. Computational Linguistics.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Y Censor</author>
<author>S A Zenios</author>
</authors>
<title>Parallel optimization : theory, algorithms, and applications.</title>
<date>1997</date>
<publisher>Oxford University Press.</publisher>
<contexts>
<context position="11763" citStr="Censor and Zenios, 1997" startWordPosition="1964" endWordPosition="1967">ploys this optimization directly within the online framework. On each update, MIRA attempts to keep the norm of the change to the parameter vector as small as possible, subject to correctly classifying the instance under consideration with a margin at least as large as the loss of the incorrect classifications. This can be formalized by substituting the following update into line 4 of the generic online algorithm, � min �w(Z+1) − w(Z)II s.t. s(xt, yt) − s(xt, y&apos;) ≥ L(yt, y&apos;) (1) ∀y&apos; ∈ dt(xt) This is a standard quadratic programming problem that can be easily solved using Hildreth’s algorithm (Censor and Zenios, 1997). Crammer and Singer (2003) and Crammer et al. (2003) provide an analysis of both the online generalization error and convergence properties of MIRA. In equation (1), s(x, y) is calculated with respect to the weight vector after optimization, w(Z+1). To apply MIRA to dependency parsing, we can simply see parsing as a multi-class classification problem in which each dependency tree is one of many possible classes for a sentence. However, that interpretation fails computationally because a general sentence has exponentially many possible dependency trees and thus exponentially many margin constr</context>
</contexts>
<marker>Censor, Zenios, 1997</marker>
<rawString>Y. Censor and S.A. Zenios. 1997. Parallel optimization : theory, algorithms, and applications. Oxford University Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>E Charniak</author>
</authors>
<title>A maximum-entropy-inspired parser.</title>
<date>2000</date>
<booktitle>In Proc. NAACL.</booktitle>
<contexts>
<context position="946" citStr="Charniak, 2000" startWordPosition="128" endWordPosition="129"> online largemargin multi-class training (Crammer and Singer, 2003; Crammer et al., 2003) on top of efficient parsing techniques for dependency trees (Eisner, 1996). The trained parsers achieve a competitive dependency accuracy for both English and Czech with no language specific enhancements. 1 Introduction Research on training parsers from annotated data has for the most part focused on models and training algorithms for phrase structure parsing. The best phrase-structure parsing models represent generatively the joint probability P(x, y) of sentence x having the structure y (Collins, 1999; Charniak, 2000). Generative parsing models are very convenient because training consists of computing probability estimates from counts of parsing events in the training set. However, generative models make complicated and poorly justified independence assumptions and estimations, so we might expect better performance from discriminatively trained models, as has been shown for other tasks like document classification (Joachims, 2002) and shallow parsing (Sha and Pereira, 2003). Ratnaparkhi’s conditional maximum entropy model (Ratnaparkhi, 1999), trained to maximize conditional likelihood P(y|x) of the traini</context>
<context position="22679" citStr="Charniak, 2000" startWordPosition="3801" endWordPosition="3802">arsers are evaluated using English. Learning a model from the Czech training data is somewhat problematic since it contains some crossing dependencies which cannot be parsed by the Eisner algorithm. One trick is to rearrange the words in the training set so that all trees are nested. This at least allows the training algorithm to obtain reasonably low error on the training set. We found that this did improve performance slightly to 83.6% accuracy. 3.1 Lexicalized Phrase Structure Parsers It is well known that dependency trees extracted from lexicalized phrase structure parsers (Collins, 1999; Charniak, 2000) typically are more accurate than those produced by pure dependency parsers (Yamada and Matsumoto, 2003). We compared our system to the Bikel re-implementation of the Collins parser (Bikel, 2004; Collins, 1999) trained with the same head rules of our system. There are two ways to extract dependencies from lexicalized phrase structure. The first is to use the automatically generated dependencies that are explicit in the lexicalization of the trees, we call this system Collinsauto. The second is to take just the phrase structure output of the parser and run the automatic head rules over it to ex</context>
</contexts>
<marker>Charniak, 2000</marker>
<rawString>E. Charniak. 2000. A maximum-entropy-inspired parser. In Proc. NAACL.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S Clark</author>
<author>J R Curran</author>
</authors>
<title>Parsing the WSJ using CCG and log-linear models.</title>
<date>2004</date>
<booktitle>In Proc. ACL.</booktitle>
<contexts>
<context position="1907" citStr="Clark and Curran, 2004" startWordPosition="269" endWordPosition="272">ls, as has been shown for other tasks like document classification (Joachims, 2002) and shallow parsing (Sha and Pereira, 2003). Ratnaparkhi’s conditional maximum entropy model (Ratnaparkhi, 1999), trained to maximize conditional likelihood P(y|x) of the training data, performed nearly as well as generative models of the same vintage even though it scores parsing decisions in isolation and thus may suffer from the label bias problem (Lafferty et al., 2001). Discriminatively trained parsers that score entire trees for a given sentence have only recently been investigated (Riezler et al., 2002; Clark and Curran, 2004; Collins and Roark, 2004; Taskar et al., 2004). The most likely reason for this is that discriminative training requires repeatedly reparsing the training corpus with the current model to determine the parameter updates that will improve the training criterion. The reparsing cost is already quite high for simple context-free models with O(n3) parsing complexity, but it becomes prohibitive for lexicalized grammars with O(n5) parsing complexity. Dependency trees are an alternative syntactic representation with a long history (Hudson, 1984). Dependency trees capture important aspects of function</context>
</contexts>
<marker>Clark, Curran, 2004</marker>
<rawString>S. Clark and J.R. Curran. 2004. Parsing the WSJ using CCG and log-linear models. In Proc. ACL.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Collins</author>
<author>B Roark</author>
</authors>
<title>Incremental parsing with the perceptron algorithm.</title>
<date>2004</date>
<booktitle>In Proc. ACL.</booktitle>
<contexts>
<context position="1932" citStr="Collins and Roark, 2004" startWordPosition="273" endWordPosition="276">r other tasks like document classification (Joachims, 2002) and shallow parsing (Sha and Pereira, 2003). Ratnaparkhi’s conditional maximum entropy model (Ratnaparkhi, 1999), trained to maximize conditional likelihood P(y|x) of the training data, performed nearly as well as generative models of the same vintage even though it scores parsing decisions in isolation and thus may suffer from the label bias problem (Lafferty et al., 2001). Discriminatively trained parsers that score entire trees for a given sentence have only recently been investigated (Riezler et al., 2002; Clark and Curran, 2004; Collins and Roark, 2004; Taskar et al., 2004). The most likely reason for this is that discriminative training requires repeatedly reparsing the training corpus with the current model to determine the parameter updates that will improve the training criterion. The reparsing cost is already quite high for simple context-free models with O(n3) parsing complexity, but it becomes prohibitive for lexicalized grammars with O(n5) parsing complexity. Dependency trees are an alternative syntactic representation with a long history (Hudson, 1984). Dependency trees capture important aspects of functional relationships between </context>
<context position="4668" citStr="Collins and Roark (2004)" startWordPosition="705" endWordPosition="708">developed a history-based learning model. Their parser uses a hybrid bottom-up/topdown linear-time heuristic parser and the ability to label edges with semantic types. The accuracy of their parser is lower than that of Yamada and Matsumoto (2003). We present a new approach to training dependency parsers, based on the online large-margin learning algorithms of Crammer and Singer (2003) and Crammer et al. (2003). Unlike the SVM parser of Yamada and Matsumoto (2003) and Ratnaparkhi’s parser, our parsers are trained to maximize the accuracy of the overall tree. Our approach is related to those of Collins and Roark (2004) and Taskar et al. (2004) for phrase structure parsing. Collins and Roark (2004) presented a linear parsing model trained with an averaged perceptron algorithm. However, to use parse features with sufficient history, their parsing algorithm must prune heuristically most of the possible parses. Taskar et al. (2004) formulate the parsing problem in the large-margin structured classification setting (Taskar et al., 2003), but are limited to parsing sentences of 15 words or less due to computation time. Though these approaches represent good first steps towards discriminatively-trained parsers, th</context>
</contexts>
<marker>Collins, Roark, 2004</marker>
<rawString>M. Collins and B. Roark. 2004. Incremental parsing with the perceptron algorithm. In Proc. ACL.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Collins</author>
<author>J Hajiˇc</author>
<author>L Ramshaw</author>
<author>C Tillmann</author>
</authors>
<title>A statistical parser for Czech. In</title>
<date>1999</date>
<booktitle>Proc. ACL.</booktitle>
<marker>Collins, Hajiˇc, Ramshaw, Tillmann, 1999</marker>
<rawString>M. Collins, J. Hajiˇc, L. Ramshaw, and C. Tillmann. 1999. A statistical parser for Czech. In Proc. ACL.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Collins</author>
</authors>
<title>Head-Driven Statistical Models for Natural Language Parsing.</title>
<date>1999</date>
<tech>Ph.D. thesis,</tech>
<institution>University of Pennsylvania.</institution>
<contexts>
<context position="929" citStr="Collins, 1999" startWordPosition="126" endWordPosition="127">that implements online largemargin multi-class training (Crammer and Singer, 2003; Crammer et al., 2003) on top of efficient parsing techniques for dependency trees (Eisner, 1996). The trained parsers achieve a competitive dependency accuracy for both English and Czech with no language specific enhancements. 1 Introduction Research on training parsers from annotated data has for the most part focused on models and training algorithms for phrase structure parsing. The best phrase-structure parsing models represent generatively the joint probability P(x, y) of sentence x having the structure y (Collins, 1999; Charniak, 2000). Generative parsing models are very convenient because training consists of computing probability estimates from counts of parsing events in the training set. However, generative models make complicated and poorly justified independence assumptions and estimations, so we might expect better performance from discriminatively trained models, as has been shown for other tasks like document classification (Joachims, 2002) and shallow parsing (Sha and Pereira, 2003). Ratnaparkhi’s conditional maximum entropy model (Ratnaparkhi, 1999), trained to maximize conditional likelihood P(y</context>
<context position="18307" citStr="Collins (1999)" startWordPosition="3072" endWordPosition="3073"> features. It is fairly straightforward to modify the parsing algorithm to store previous attachments. However, any modification would result in an asymptotic increase in parsing complexity. 3 Experiments We tested our methods experimentally on the English Penn Treebank (Marcus et al., 1993) and on the Czech Prague Dependency Treebank (Hajiˇc, 1998). All experiments were run on a dual 64-bit AMD Opteron 2.4GHz processor. To create dependency structures from the Penn Treebank, we used the extraction rules of Yamada and Matsumoto (2003), which are an approximation to the lexicalization rules of Collins (1999). We split the data into three parts: sections 02-21 for training, section 22 for development and section 23 for evaluation. Currently the system has 6, 998, 447 features. Each instance only uses a tiny fraction of these features making sparse vector calculations possible. Our system assumes POS tags as input and uses the tagger of Ratnaparkhi (1996) to provide tags for the development and evaluation sets. Table 2 shows the performance of the systems that were compared. Y&amp;M2003 is the SVM-shiftreduce parsing model of Yamada and Matsumoto (2003), N&amp;S2004 is the memory-based learner of Nivre and</context>
<context position="22662" citStr="Collins, 1999" startWordPosition="3799" endWordPosition="3800">er dependency parsers are evaluated using English. Learning a model from the Czech training data is somewhat problematic since it contains some crossing dependencies which cannot be parsed by the Eisner algorithm. One trick is to rearrange the words in the training set so that all trees are nested. This at least allows the training algorithm to obtain reasonably low error on the training set. We found that this did improve performance slightly to 83.6% accuracy. 3.1 Lexicalized Phrase Structure Parsers It is well known that dependency trees extracted from lexicalized phrase structure parsers (Collins, 1999; Charniak, 2000) typically are more accurate than those produced by pure dependency parsers (Yamada and Matsumoto, 2003). We compared our system to the Bikel re-implementation of the Collins parser (Bikel, 2004; Collins, 1999) trained with the same head rules of our system. There are two ways to extract dependencies from lexicalized phrase structure. The first is to use the automatically generated dependencies that are explicit in the lexicalization of the trees, we call this system Collinsauto. The second is to take just the phrase structure output of the parser and run the automatic head ru</context>
</contexts>
<marker>Collins, 1999</marker>
<rawString>M. Collins. 1999. Head-Driven Statistical Models for Natural Language Parsing. Ph.D. thesis, University of Pennsylvania.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Collins</author>
</authors>
<title>Discriminative training methods for hidden Markov models: Theory and experiments with perceptron algorithms.</title>
<date>2002</date>
<booktitle>In Proc. EMNLP.</booktitle>
<contexts>
<context position="9965" citStr="Collins, 2002" startWordPosition="1648" endWordPosition="1649">ithm-specific update rule to the instance under consideration. The algorithm in Figure 3 returns an averaged weight vector: an auxiliary weight vector v is maintained that accumulates Training data: T = {(xt, yt)}Tt�1 1. w0 = 0; v = 0; i = 0 2. for n : 1..N 3. fort : 1..T 4. w(i+1) = update w(i) according to instance (xt, yt) 5. v = v + w(i+1) 6. i = i + 1 7.w=v/(N*T) Figure 3: Generic online learning algorithm. the values of w after each iteration, and the returned weight vector is the average of all the weight vectors throughout training. Averaging has been shown to help reduce overfitting (Collins, 2002). 2.3.1 MIRA Crammer and Singer (2001) developed a natural method for large-margin multi-class classification, which was later extended by Taskar et al. (2003) to structured classification: min IwII s.t. s(x, y) − s(x, y&apos;) &gt; L(y, y&apos;) b(x, y) E T, y&apos; E dt(x) where L(y, y&apos;) is a real-valued loss for the tree y&apos; relative to the correct tree y. We define the loss of a dependency tree as the number of words that have the incorrect parent. Thus, the largest loss a dependency tree can have is the length of the sentence. Informally, this update looks to create a margin between the correct dependency t</context>
<context position="19033" citStr="Collins, 2002" startWordPosition="3193" endWordPosition="3194"> evaluation. Currently the system has 6, 998, 447 features. Each instance only uses a tiny fraction of these features making sparse vector calculations possible. Our system assumes POS tags as input and uses the tagger of Ratnaparkhi (1996) to provide tags for the development and evaluation sets. Table 2 shows the performance of the systems that were compared. Y&amp;M2003 is the SVM-shiftreduce parsing model of Yamada and Matsumoto (2003), N&amp;S2004 is the memory-based learner of Nivre and Scholz (2004) and MIRA is the the system we have described. We also implemented an averaged perceptron system (Collins, 2002) (another online learning algorithm) for comparison. This table compares only pure dependency parsers that do 95 English Czech Accuracy Root Complete Accuracy Root Complete Y&amp;M2003 90.3 91.6 38.4 - - - N&amp;S2004 87.3 84.3 30.4 - - - Avg. Perceptron 90.6 94.0 36.5 82.9 88.0 30.3 MIRA 90.9 94.2 37.5 83.3 88.6 31.3 Table 2: Dependency parsing results for English and Czech. Accuracy is the number of words that correctly identified their parent in the tree. Root is the number of trees in which the root word was correctly identified. For Czech this is f-measure since a sentence may have multiple roots</context>
</contexts>
<marker>Collins, 2002</marker>
<rawString>M. Collins. 2002. Discriminative training methods for hidden Markov models: Theory and experiments with perceptron algorithms. In Proc. EMNLP.</rawString>
</citation>
<citation valid="true">
<authors>
<author>K Crammer</author>
<author>Y Singer</author>
</authors>
<title>On the algorithmic implementation of multiclass kernel based vector machines.</title>
<date>2001</date>
<publisher>JMLR.</publisher>
<contexts>
<context position="10003" citStr="Crammer and Singer (2001)" startWordPosition="1652" endWordPosition="1655">o the instance under consideration. The algorithm in Figure 3 returns an averaged weight vector: an auxiliary weight vector v is maintained that accumulates Training data: T = {(xt, yt)}Tt�1 1. w0 = 0; v = 0; i = 0 2. for n : 1..N 3. fort : 1..T 4. w(i+1) = update w(i) according to instance (xt, yt) 5. v = v + w(i+1) 6. i = i + 1 7.w=v/(N*T) Figure 3: Generic online learning algorithm. the values of w after each iteration, and the returned weight vector is the average of all the weight vectors throughout training. Averaging has been shown to help reduce overfitting (Collins, 2002). 2.3.1 MIRA Crammer and Singer (2001) developed a natural method for large-margin multi-class classification, which was later extended by Taskar et al. (2003) to structured classification: min IwII s.t. s(x, y) − s(x, y&apos;) &gt; L(y, y&apos;) b(x, y) E T, y&apos; E dt(x) where L(y, y&apos;) is a real-valued loss for the tree y&apos; relative to the correct tree y. We define the loss of a dependency tree as the number of words that have the incorrect parent. Thus, the largest loss a dependency tree can have is the length of the sentence. Informally, this update looks to create a margin between the correct dependency tree and each incorrect dependency tree</context>
</contexts>
<marker>Crammer, Singer, 2001</marker>
<rawString>K. Crammer and Y. Singer. 2001. On the algorithmic implementation of multiclass kernel based vector machines. JMLR.</rawString>
</citation>
<citation valid="true">
<authors>
<author>K Crammer</author>
<author>Y Singer</author>
</authors>
<title>Ultraconservative online algorithms for multiclass problems.</title>
<date>2003</date>
<publisher>JMLR.</publisher>
<contexts>
<context position="4431" citStr="Crammer and Singer (2003)" startWordPosition="664" endWordPosition="667">vector machines (SVM) to make parsing decisions in a shift-reduce dependency parser. As in Ratnaparkhi’s parser, the classifiers are trained on individual decisions rather than on the overall quality of the parse. Nivre and Scholz (2004) developed a history-based learning model. Their parser uses a hybrid bottom-up/topdown linear-time heuristic parser and the ability to label edges with semantic types. The accuracy of their parser is lower than that of Yamada and Matsumoto (2003). We present a new approach to training dependency parsers, based on the online large-margin learning algorithms of Crammer and Singer (2003) and Crammer et al. (2003). Unlike the SVM parser of Yamada and Matsumoto (2003) and Ratnaparkhi’s parser, our parsers are trained to maximize the accuracy of the overall tree. Our approach is related to those of Collins and Roark (2004) and Taskar et al. (2004) for phrase structure parsing. Collins and Roark (2004) presented a linear parsing model trained with an averaged perceptron algorithm. However, to use parse features with sufficient history, their parsing algorithm must prune heuristically most of the possible parses. Taskar et al. (2004) formulate the parsing problem in the large-marg</context>
<context position="11113" citStr="Crammer and Singer, 2003" startWordPosition="1852" endWordPosition="1855">mally, this update looks to create a margin between the correct dependency tree and each incorrect dependency tree at least as large as the loss of the incorrect tree. The more errors a tree has, the farther away its score will be from the score of the correct tree. In order to avoid a blow-up in the norm of the weight vector we minimize it subject to constraints that enforce the desired margin between the correct and incorrect trees1. 1The constraints may be unsatisfiable, in which case we can relax them with slack variables as in SVM training. 93 The Margin Infused Relaxed Algorithm (MIRA) (Crammer and Singer, 2003; Crammer et al., 2003) employs this optimization directly within the online framework. On each update, MIRA attempts to keep the norm of the change to the parameter vector as small as possible, subject to correctly classifying the instance under consideration with a margin at least as large as the loss of the incorrect classifications. This can be formalized by substituting the following update into line 4 of the generic online algorithm, � min �w(Z+1) − w(Z)II s.t. s(xt, yt) − s(xt, y&apos;) ≥ L(yt, y&apos;) (1) ∀y&apos; ∈ dt(xt) This is a standard quadratic programming problem that can be easily solved us</context>
</contexts>
<marker>Crammer, Singer, 2003</marker>
<rawString>K. Crammer and Y. Singer. 2003. Ultraconservative online algorithms for multiclass problems. JMLR.</rawString>
</citation>
<citation valid="true">
<authors>
<author>K Crammer</author>
<author>O Dekel</author>
<author>S Shalev-Shwartz</author>
<author>Y Singer</author>
</authors>
<title>Online passive aggressive algorithms.</title>
<date>2003</date>
<booktitle>In Proc. NIPS.</booktitle>
<contexts>
<context position="4457" citStr="Crammer et al. (2003)" startWordPosition="669" endWordPosition="672">parsing decisions in a shift-reduce dependency parser. As in Ratnaparkhi’s parser, the classifiers are trained on individual decisions rather than on the overall quality of the parse. Nivre and Scholz (2004) developed a history-based learning model. Their parser uses a hybrid bottom-up/topdown linear-time heuristic parser and the ability to label edges with semantic types. The accuracy of their parser is lower than that of Yamada and Matsumoto (2003). We present a new approach to training dependency parsers, based on the online large-margin learning algorithms of Crammer and Singer (2003) and Crammer et al. (2003). Unlike the SVM parser of Yamada and Matsumoto (2003) and Ratnaparkhi’s parser, our parsers are trained to maximize the accuracy of the overall tree. Our approach is related to those of Collins and Roark (2004) and Taskar et al. (2004) for phrase structure parsing. Collins and Roark (2004) presented a linear parsing model trained with an averaged perceptron algorithm. However, to use parse features with sufficient history, their parsing algorithm must prune heuristically most of the possible parses. Taskar et al. (2004) formulate the parsing problem in the large-margin structured classificati</context>
<context position="11136" citStr="Crammer et al., 2003" startWordPosition="1856" endWordPosition="1860">o create a margin between the correct dependency tree and each incorrect dependency tree at least as large as the loss of the incorrect tree. The more errors a tree has, the farther away its score will be from the score of the correct tree. In order to avoid a blow-up in the norm of the weight vector we minimize it subject to constraints that enforce the desired margin between the correct and incorrect trees1. 1The constraints may be unsatisfiable, in which case we can relax them with slack variables as in SVM training. 93 The Margin Infused Relaxed Algorithm (MIRA) (Crammer and Singer, 2003; Crammer et al., 2003) employs this optimization directly within the online framework. On each update, MIRA attempts to keep the norm of the change to the parameter vector as small as possible, subject to correctly classifying the instance under consideration with a margin at least as large as the loss of the incorrect classifications. This can be formalized by substituting the following update into line 4 of the generic online algorithm, � min �w(Z+1) − w(Z)II s.t. s(xt, yt) − s(xt, y&apos;) ≥ L(yt, y&apos;) (1) ∀y&apos; ∈ dt(xt) This is a standard quadratic programming problem that can be easily solved using Hildreth’s algorith</context>
</contexts>
<marker>Crammer, Dekel, Shalev-Shwartz, Singer, 2003</marker>
<rawString>K. Crammer, O. Dekel, S. Shalev-Shwartz, and Y. Singer. 2003. Online passive aggressive algorithms. In Proc. NIPS.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Culotta</author>
<author>J Sorensen</author>
</authors>
<title>Dependency tree kernels for relation extraction. In</title>
<date>2004</date>
<booktitle>Proc. ACL.</booktitle>
<contexts>
<context position="2650" citStr="Culotta and Sorensen, 2004" startWordPosition="382" endWordPosition="385">uires repeatedly reparsing the training corpus with the current model to determine the parameter updates that will improve the training criterion. The reparsing cost is already quite high for simple context-free models with O(n3) parsing complexity, but it becomes prohibitive for lexicalized grammars with O(n5) parsing complexity. Dependency trees are an alternative syntactic representation with a long history (Hudson, 1984). Dependency trees capture important aspects of functional relationships between words and have been shown to be useful in many applications including relation extraction (Culotta and Sorensen, 2004), paraphrase acquisition (Shinyama et al., 2002) and machine translation (Ding and Palmer, 2005). Yet, they can be parsed in O(n3) time (Eisner, 1996). Therefore, dependency parsing is a potential “sweet spot” that deserves investigation. We focus here on projective dependency trees in which a word is the parent of all of its arguments, and dependencies are non-crossing with respect to word order (see Figure 1). However, there are cases where crossing dependencies may occur, as is the case for Czech (Hajiˇc, 1998). Edges in a dependency tree may be typed (for instance to indicate grammatical f</context>
</contexts>
<marker>Culotta, Sorensen, 2004</marker>
<rawString>A. Culotta and J. Sorensen. 2004. Dependency tree kernels for relation extraction. In Proc. ACL.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Y Ding</author>
<author>M Palmer</author>
</authors>
<title>Machine translation using probabilistic synchronous dependency insertion grammars.</title>
<date>2005</date>
<booktitle>In Proc. ACL.</booktitle>
<contexts>
<context position="2746" citStr="Ding and Palmer, 2005" startWordPosition="395" endWordPosition="398">tes that will improve the training criterion. The reparsing cost is already quite high for simple context-free models with O(n3) parsing complexity, but it becomes prohibitive for lexicalized grammars with O(n5) parsing complexity. Dependency trees are an alternative syntactic representation with a long history (Hudson, 1984). Dependency trees capture important aspects of functional relationships between words and have been shown to be useful in many applications including relation extraction (Culotta and Sorensen, 2004), paraphrase acquisition (Shinyama et al., 2002) and machine translation (Ding and Palmer, 2005). Yet, they can be parsed in O(n3) time (Eisner, 1996). Therefore, dependency parsing is a potential “sweet spot” that deserves investigation. We focus here on projective dependency trees in which a word is the parent of all of its arguments, and dependencies are non-crossing with respect to word order (see Figure 1). However, there are cases where crossing dependencies may occur, as is the case for Czech (Hajiˇc, 1998). Edges in a dependency tree may be typed (for instance to indicate grammatical function). Though we focus on the simpler non-typed 91 Proceedings of the 43rd Annual Meeting of </context>
</contexts>
<marker>Ding, Palmer, 2005</marker>
<rawString>Y. Ding and M. Palmer. 2005. Machine translation using probabilistic synchronous dependency insertion grammars. In Proc. ACL.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Eisner</author>
</authors>
<title>Three new probabilistic models for dependency parsing: An exploration.</title>
<date>1996</date>
<booktitle>In Proc. COLING.</booktitle>
<contexts>
<context position="2800" citStr="Eisner, 1996" startWordPosition="407" endWordPosition="408">t is already quite high for simple context-free models with O(n3) parsing complexity, but it becomes prohibitive for lexicalized grammars with O(n5) parsing complexity. Dependency trees are an alternative syntactic representation with a long history (Hudson, 1984). Dependency trees capture important aspects of functional relationships between words and have been shown to be useful in many applications including relation extraction (Culotta and Sorensen, 2004), paraphrase acquisition (Shinyama et al., 2002) and machine translation (Ding and Palmer, 2005). Yet, they can be parsed in O(n3) time (Eisner, 1996). Therefore, dependency parsing is a potential “sweet spot” that deserves investigation. We focus here on projective dependency trees in which a word is the parent of all of its arguments, and dependencies are non-crossing with respect to word order (see Figure 1). However, there are cases where crossing dependencies may occur, as is the case for Czech (Hajiˇc, 1998). Edges in a dependency tree may be typed (for instance to indicate grammatical function). Though we focus on the simpler non-typed 91 Proceedings of the 43rd Annual Meeting of the ACL, pages 91–98, Ann Arbor, June 2005. c�2005 Ass</context>
<context position="6031" citStr="Eisner (1996)" startWordPosition="936" endWordPosition="937">s simplicity, our method is efficient and accurate, as we demonstrate experimentally on English and Czech treebank data. 2 System Description 2.1 Definitions and Background In what follows, the generic sentence is denoted by x (possibly subscripted); the ith word of x is denoted by xi. The generic dependency tree is denoted by y. If y is a dependency tree for sentence x, we write (i, j) E y to indicate that there is a directed edge from word xi to word xj in the tree, that is, xi is the parent of xj. T = {(xt, yt)}t_1 denotes the training data. We follow the edge based factorization method of Eisner (1996) and define the score of a dependency tree as the sum of the score of all edges in the tree, s(x, y) = � s(i, j) = � w · f(i, j) (i,j)Ey (i,j)Ey where f(i, j) is a high-dimensional binary feature representation of the edge from xi to xj. For example, in the dependency tree of Figure 1, the following feature would have a value of 1: � = 1 if xi=‘hit’ and xj=‘ball’ f (i, j) 0 otherwise. In general, any real-valued feature may be used, but we use binary features for simplicity. The feature weights in the weight vector w are the parameters that will be learned during training. Our training algorit</context>
<context position="7538" citStr="Eisner (1996)" startWordPosition="1228" endWordPosition="1229"> ties resolved by an arbitrary but fixed rule. Three basic questions must be answered for models of this form: how to find the dependency tree y with highest score for sentence x; how to learn an appropriate weight vector w from the training data; and finally, what feature representation f(i, j) should be used. The following sections address each of these questions. 2.2 Parsing Algorithm Given a feature representation for edges and a weight vector w, we seek the dependency tree or 92 h1 h1 h2 h2 � � h1 h1 h1 h1 h2 h2 s h1 h1 r r+1 h2 h2 t s h1 h1 h2 h2 t s h1 h1 t Figure 2: O(n3) algorithm of Eisner (1996), needs to keep 3 indices at any given stage. trees that maximize the score function, s(x, y). The primary difficulty is that for a given sentence of length n there are exponentially many possible dependency trees. Using a slightly modified version of a lexicalized CKY chart parsing algorithm, it is possible to generate and represent these sentences in a forest that is O(n5) in size and takes O(n5) time to create. Eisner (1996) made the observation that if the head of each chart item is on the left or right periphery, then it is possible to parse in O(n3). The idea is to parse the left and rig</context>
<context position="13134" citStr="Eisner (1996)" startWordPosition="2193" endWordPosition="2194">s y&apos; with the highest scores s(x, y&apos;). The resulting optimization made by MIRA (see Figure 3, line 4) would then be: � min �w(Z+1) − w(Z)II s.t. s(xt, yt) − s(xt, y&apos;) ≥ L(yt, y&apos;) ∀y&apos; ∈ bestk(xt; w(Z)) reducing the number of constraints to the constant k. We tested various values of k on a development data set and found that small values of k are sufficient to achieve close to best performance, justifying our assumption. In fact, as k grew we began to observe a slight degradation of performance, indicating some overfitting to the training data. All the experiments presented here use k = 5. The Eisner (1996) algorithm can be modified to find the k-best trees while only adding an additional O(k log k) factor to the runtime (Huang and Chiang, 2005). A more common approach is to factor the structure of the output space to yield a polynomial set of local constraints (Taskar et al., 2003; Taskar et al., 2004). One such factorization for dependency trees is � min �w(Z+1) − w(Z)II s.t. s(l, j) − s(k, j) ≥ 1 ∀(l, j) ∈ yt, (k, j) ∈� yt It is trivial to show that if these O(n2) constraints are satisfied, then so are those in (1). We implemented this model, but found that the required training time was much</context>
</contexts>
<marker>Eisner, 1996</marker>
<rawString>J. Eisner. 1996. Three new probabilistic models for dependency parsing: An exploration. In Proc. COLING.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Hajiˇc</author>
</authors>
<title>Building a syntactically annotated corpus: The Prague dependency treebank. Issues of Valency and Meaning.</title>
<date>1998</date>
<marker>Hajiˇc, 1998</marker>
<rawString>J. Hajiˇc. 1998. Building a syntactically annotated corpus: The Prague dependency treebank. Issues of Valency and Meaning.</rawString>
</citation>
<citation valid="true">
<authors>
<author>L Huang</author>
<author>D Chiang</author>
</authors>
<title>Better k-best parsing.</title>
<date>2005</date>
<tech>Technical Report MS-CIS-05-08,</tech>
<institution>University of Pennsylvania.</institution>
<contexts>
<context position="13275" citStr="Huang and Chiang, 2005" startWordPosition="2217" endWordPosition="2220">− w(Z)II s.t. s(xt, yt) − s(xt, y&apos;) ≥ L(yt, y&apos;) ∀y&apos; ∈ bestk(xt; w(Z)) reducing the number of constraints to the constant k. We tested various values of k on a development data set and found that small values of k are sufficient to achieve close to best performance, justifying our assumption. In fact, as k grew we began to observe a slight degradation of performance, indicating some overfitting to the training data. All the experiments presented here use k = 5. The Eisner (1996) algorithm can be modified to find the k-best trees while only adding an additional O(k log k) factor to the runtime (Huang and Chiang, 2005). A more common approach is to factor the structure of the output space to yield a polynomial set of local constraints (Taskar et al., 2003; Taskar et al., 2004). One such factorization for dependency trees is � min �w(Z+1) − w(Z)II s.t. s(l, j) − s(k, j) ≥ 1 ∀(l, j) ∈ yt, (k, j) ∈� yt It is trivial to show that if these O(n2) constraints are satisfied, then so are those in (1). We implemented this model, but found that the required training time was much larger than the k-best formulation and typically did not improve performance. Furthermore, the k-best formulation is more flexible with resp</context>
</contexts>
<marker>Huang, Chiang, 2005</marker>
<rawString>L. Huang and D. Chiang. 2005. Better k-best parsing. Technical Report MS-CIS-05-08, University of Pennsylvania.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Richard Hudson</author>
</authors>
<title>Learning to Classify Text using Support Vector Machines.</title>
<date>1984</date>
<publisher>Kluwer.</publisher>
<contexts>
<context position="2451" citStr="Hudson, 1984" startWordPosition="354" endWordPosition="355">ently been investigated (Riezler et al., 2002; Clark and Curran, 2004; Collins and Roark, 2004; Taskar et al., 2004). The most likely reason for this is that discriminative training requires repeatedly reparsing the training corpus with the current model to determine the parameter updates that will improve the training criterion. The reparsing cost is already quite high for simple context-free models with O(n3) parsing complexity, but it becomes prohibitive for lexicalized grammars with O(n5) parsing complexity. Dependency trees are an alternative syntactic representation with a long history (Hudson, 1984). Dependency trees capture important aspects of functional relationships between words and have been shown to be useful in many applications including relation extraction (Culotta and Sorensen, 2004), paraphrase acquisition (Shinyama et al., 2002) and machine translation (Ding and Palmer, 2005). Yet, they can be parsed in O(n3) time (Eisner, 1996). Therefore, dependency parsing is a potential “sweet spot” that deserves investigation. We focus here on projective dependency trees in which a word is the parent of all of its arguments, and dependencies are non-crossing with respect to word order (</context>
</contexts>
<marker>Hudson, 1984</marker>
<rawString>Richard Hudson. 1984. Word Grammar. Blackwell. T. Joachims. 2002. Learning to Classify Text using Support Vector Machines. Kluwer.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Lafferty</author>
<author>A McCallum</author>
<author>F Pereira</author>
</authors>
<title>Conditional random fields: Probabilistic models for segmenting and labeling sequence data. In</title>
<date>2001</date>
<booktitle>Proc. ICML.</booktitle>
<contexts>
<context position="1745" citStr="Lafferty et al., 2001" startWordPosition="245" endWordPosition="248">ve models make complicated and poorly justified independence assumptions and estimations, so we might expect better performance from discriminatively trained models, as has been shown for other tasks like document classification (Joachims, 2002) and shallow parsing (Sha and Pereira, 2003). Ratnaparkhi’s conditional maximum entropy model (Ratnaparkhi, 1999), trained to maximize conditional likelihood P(y|x) of the training data, performed nearly as well as generative models of the same vintage even though it scores parsing decisions in isolation and thus may suffer from the label bias problem (Lafferty et al., 2001). Discriminatively trained parsers that score entire trees for a given sentence have only recently been investigated (Riezler et al., 2002; Clark and Curran, 2004; Collins and Roark, 2004; Taskar et al., 2004). The most likely reason for this is that discriminative training requires repeatedly reparsing the training corpus with the current model to determine the parameter updates that will improve the training criterion. The reparsing cost is already quite high for simple context-free models with O(n3) parsing complexity, but it becomes prohibitive for lexicalized grammars with O(n5) parsing c</context>
</contexts>
<marker>Lafferty, McCallum, Pereira, 2001</marker>
<rawString>J. Lafferty, A. McCallum, and F. Pereira. 2001. Conditional random fields: Probabilistic models for segmenting and labeling sequence data. In Proc. ICML.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Marcus</author>
<author>B Santorini</author>
<author>M Marcinkiewicz</author>
</authors>
<title>Building a large annotated corpus of english: the penn treebank. Computational Linguistics.</title>
<date>1993</date>
<contexts>
<context position="17985" citStr="Marcus et al., 1993" startWordPosition="3020" endWordPosition="3023">n 3.1 and show a significant improvement in parsing times on the testing data. The major limiting factor of the system is its restriction to features over single dependency attachments. Often, when determining the next dependent for a word, it would be useful to know previous attachment decisions and incorporate these into the features. It is fairly straightforward to modify the parsing algorithm to store previous attachments. However, any modification would result in an asymptotic increase in parsing complexity. 3 Experiments We tested our methods experimentally on the English Penn Treebank (Marcus et al., 1993) and on the Czech Prague Dependency Treebank (Hajiˇc, 1998). All experiments were run on a dual 64-bit AMD Opteron 2.4GHz processor. To create dependency structures from the Penn Treebank, we used the extraction rules of Yamada and Matsumoto (2003), which are an approximation to the lexicalization rules of Collins (1999). We split the data into three parts: sections 02-21 for training, section 22 for development and section 23 for evaluation. Currently the system has 6, 998, 447 features. Each instance only uses a tiny fraction of these features making sparse vector calculations possible. Our </context>
</contexts>
<marker>Marcus, Santorini, Marcinkiewicz, 1993</marker>
<rawString>M. Marcus, B. Santorini, and M. Marcinkiewicz. 1993. Building a large annotated corpus of english: the penn treebank. Computational Linguistics.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Nivre</author>
<author>M Scholz</author>
</authors>
<title>Deterministic dependency parsing of english text.</title>
<date>2004</date>
<booktitle>In Proc. COLING.</booktitle>
<contexts>
<context position="4043" citStr="Nivre and Scholz (2004)" startWordPosition="603" endWordPosition="606">tional Linguistics root John hit the ball with the bat Figure 1: An example dependency tree. case, all algorithms are easily extendible to typed structures. The following work on dependency parsing is most relevant to our research. Eisner (1996) gave a generative model with a cubic parsing algorithm based on an edge factorization of trees. Yamada and Matsumoto (2003) trained support vector machines (SVM) to make parsing decisions in a shift-reduce dependency parser. As in Ratnaparkhi’s parser, the classifiers are trained on individual decisions rather than on the overall quality of the parse. Nivre and Scholz (2004) developed a history-based learning model. Their parser uses a hybrid bottom-up/topdown linear-time heuristic parser and the ability to label edges with semantic types. The accuracy of their parser is lower than that of Yamada and Matsumoto (2003). We present a new approach to training dependency parsers, based on the online large-margin learning algorithms of Crammer and Singer (2003) and Crammer et al. (2003). Unlike the SVM parser of Yamada and Matsumoto (2003) and Ratnaparkhi’s parser, our parsers are trained to maximize the accuracy of the overall tree. Our approach is related to those of</context>
<context position="18921" citStr="Nivre and Scholz (2004)" startWordPosition="3171" endWordPosition="3174">ns (1999). We split the data into three parts: sections 02-21 for training, section 22 for development and section 23 for evaluation. Currently the system has 6, 998, 447 features. Each instance only uses a tiny fraction of these features making sparse vector calculations possible. Our system assumes POS tags as input and uses the tagger of Ratnaparkhi (1996) to provide tags for the development and evaluation sets. Table 2 shows the performance of the systems that were compared. Y&amp;M2003 is the SVM-shiftreduce parsing model of Yamada and Matsumoto (2003), N&amp;S2004 is the memory-based learner of Nivre and Scholz (2004) and MIRA is the the system we have described. We also implemented an averaged perceptron system (Collins, 2002) (another online learning algorithm) for comparison. This table compares only pure dependency parsers that do 95 English Czech Accuracy Root Complete Accuracy Root Complete Y&amp;M2003 90.3 91.6 38.4 - - - N&amp;S2004 87.3 84.3 30.4 - - - Avg. Perceptron 90.6 94.0 36.5 82.9 88.0 30.3 MIRA 90.9 94.2 37.5 83.3 88.6 31.3 Table 2: Dependency parsing results for English and Czech. Accuracy is the number of words that correctly identified their parent in the tree. Root is the number of trees in wh</context>
</contexts>
<marker>Nivre, Scholz, 2004</marker>
<rawString>J. Nivre and M. Scholz. 2004. Deterministic dependency parsing of english text. In Proc. COLING.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Ratnaparkhi</author>
</authors>
<title>A maximum entropy model for part-of-speech tagging.</title>
<date>1996</date>
<booktitle>In Proc. EMNLP.</booktitle>
<contexts>
<context position="18659" citStr="Ratnaparkhi (1996)" startWordPosition="3131" endWordPosition="3132">98). All experiments were run on a dual 64-bit AMD Opteron 2.4GHz processor. To create dependency structures from the Penn Treebank, we used the extraction rules of Yamada and Matsumoto (2003), which are an approximation to the lexicalization rules of Collins (1999). We split the data into three parts: sections 02-21 for training, section 22 for development and section 23 for evaluation. Currently the system has 6, 998, 447 features. Each instance only uses a tiny fraction of these features making sparse vector calculations possible. Our system assumes POS tags as input and uses the tagger of Ratnaparkhi (1996) to provide tags for the development and evaluation sets. Table 2 shows the performance of the systems that were compared. Y&amp;M2003 is the SVM-shiftreduce parsing model of Yamada and Matsumoto (2003), N&amp;S2004 is the memory-based learner of Nivre and Scholz (2004) and MIRA is the the system we have described. We also implemented an averaged perceptron system (Collins, 2002) (another online learning algorithm) for comparison. This table compares only pure dependency parsers that do 95 English Czech Accuracy Root Complete Accuracy Root Complete Y&amp;M2003 90.3 91.6 38.4 - - - N&amp;S2004 87.3 84.3 30.4 -</context>
</contexts>
<marker>Ratnaparkhi, 1996</marker>
<rawString>A. Ratnaparkhi. 1996. A maximum entropy model for part-of-speech tagging. In Proc. EMNLP.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Ratnaparkhi</author>
</authors>
<title>Learning to parse natural language with maximum entropy models.</title>
<date>1999</date>
<journal>Machine Learning.</journal>
<contexts>
<context position="1481" citStr="Ratnaparkhi, 1999" startWordPosition="205" endWordPosition="206">bility P(x, y) of sentence x having the structure y (Collins, 1999; Charniak, 2000). Generative parsing models are very convenient because training consists of computing probability estimates from counts of parsing events in the training set. However, generative models make complicated and poorly justified independence assumptions and estimations, so we might expect better performance from discriminatively trained models, as has been shown for other tasks like document classification (Joachims, 2002) and shallow parsing (Sha and Pereira, 2003). Ratnaparkhi’s conditional maximum entropy model (Ratnaparkhi, 1999), trained to maximize conditional likelihood P(y|x) of the training data, performed nearly as well as generative models of the same vintage even though it scores parsing decisions in isolation and thus may suffer from the label bias problem (Lafferty et al., 2001). Discriminatively trained parsers that score entire trees for a given sentence have only recently been investigated (Riezler et al., 2002; Clark and Curran, 2004; Collins and Roark, 2004; Taskar et al., 2004). The most likely reason for this is that discriminative training requires repeatedly reparsing the training corpus with the cu</context>
</contexts>
<marker>Ratnaparkhi, 1999</marker>
<rawString>A. Ratnaparkhi. 1999. Learning to parse natural language with maximum entropy models. Machine Learning.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S Riezler</author>
<author>T King</author>
<author>R Kaplan</author>
<author>R Crouch</author>
<author>J Maxwell</author>
<author>M Johnson</author>
</authors>
<title>Parsing the Wall Street Journal using a lexical-functional grammar and discriminative estimation techniques.</title>
<date>2002</date>
<booktitle>In Proc. ACL.</booktitle>
<contexts>
<context position="1883" citStr="Riezler et al., 2002" startWordPosition="265" endWordPosition="268">inatively trained models, as has been shown for other tasks like document classification (Joachims, 2002) and shallow parsing (Sha and Pereira, 2003). Ratnaparkhi’s conditional maximum entropy model (Ratnaparkhi, 1999), trained to maximize conditional likelihood P(y|x) of the training data, performed nearly as well as generative models of the same vintage even though it scores parsing decisions in isolation and thus may suffer from the label bias problem (Lafferty et al., 2001). Discriminatively trained parsers that score entire trees for a given sentence have only recently been investigated (Riezler et al., 2002; Clark and Curran, 2004; Collins and Roark, 2004; Taskar et al., 2004). The most likely reason for this is that discriminative training requires repeatedly reparsing the training corpus with the current model to determine the parameter updates that will improve the training criterion. The reparsing cost is already quite high for simple context-free models with O(n3) parsing complexity, but it becomes prohibitive for lexicalized grammars with O(n5) parsing complexity. Dependency trees are an alternative syntactic representation with a long history (Hudson, 1984). Dependency trees capture impor</context>
</contexts>
<marker>Riezler, King, Kaplan, Crouch, Maxwell, Johnson, 2002</marker>
<rawString>S. Riezler, T. King, R. Kaplan, R. Crouch, J. Maxwell, and M. Johnson. 2002. Parsing the Wall Street Journal using a lexical-functional grammar and discriminative estimation techniques. In Proc. ACL.</rawString>
</citation>
<citation valid="true">
<authors>
<author>F Sha</author>
<author>F Pereira</author>
</authors>
<title>Shallow parsing with conditional random fields.</title>
<date>2003</date>
<booktitle>In Proc. HLT-NAACL.</booktitle>
<contexts>
<context position="1412" citStr="Sha and Pereira, 2003" startWordPosition="195" endWordPosition="198">st phrase-structure parsing models represent generatively the joint probability P(x, y) of sentence x having the structure y (Collins, 1999; Charniak, 2000). Generative parsing models are very convenient because training consists of computing probability estimates from counts of parsing events in the training set. However, generative models make complicated and poorly justified independence assumptions and estimations, so we might expect better performance from discriminatively trained models, as has been shown for other tasks like document classification (Joachims, 2002) and shallow parsing (Sha and Pereira, 2003). Ratnaparkhi’s conditional maximum entropy model (Ratnaparkhi, 1999), trained to maximize conditional likelihood P(y|x) of the training data, performed nearly as well as generative models of the same vintage even though it scores parsing decisions in isolation and thus may suffer from the label bias problem (Lafferty et al., 2001). Discriminatively trained parsers that score entire trees for a given sentence have only recently been investigated (Riezler et al., 2002; Clark and Curran, 2004; Collins and Roark, 2004; Taskar et al., 2004). The most likely reason for this is that discriminative t</context>
</contexts>
<marker>Sha, Pereira, 2003</marker>
<rawString>F. Sha and F. Pereira. 2003. Shallow parsing with conditional random fields. In Proc. HLT-NAACL.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Y Shinyama</author>
<author>S Sekine</author>
<author>K Sudo</author>
<author>R Grishman</author>
</authors>
<title>Automatic paraphrase acquisition from news articles.</title>
<date>2002</date>
<booktitle>In Proc. HLT.</booktitle>
<contexts>
<context position="2698" citStr="Shinyama et al., 2002" startWordPosition="388" endWordPosition="391">he current model to determine the parameter updates that will improve the training criterion. The reparsing cost is already quite high for simple context-free models with O(n3) parsing complexity, but it becomes prohibitive for lexicalized grammars with O(n5) parsing complexity. Dependency trees are an alternative syntactic representation with a long history (Hudson, 1984). Dependency trees capture important aspects of functional relationships between words and have been shown to be useful in many applications including relation extraction (Culotta and Sorensen, 2004), paraphrase acquisition (Shinyama et al., 2002) and machine translation (Ding and Palmer, 2005). Yet, they can be parsed in O(n3) time (Eisner, 1996). Therefore, dependency parsing is a potential “sweet spot” that deserves investigation. We focus here on projective dependency trees in which a word is the parent of all of its arguments, and dependencies are non-crossing with respect to word order (see Figure 1). However, there are cases where crossing dependencies may occur, as is the case for Czech (Hajiˇc, 1998). Edges in a dependency tree may be typed (for instance to indicate grammatical function). Though we focus on the simpler non-typ</context>
</contexts>
<marker>Shinyama, Sekine, Sudo, Grishman, 2002</marker>
<rawString>Y. Shinyama, S. Sekine, K. Sudo, and R. Grishman. 2002. Automatic paraphrase acquisition from news articles. In Proc. HLT.</rawString>
</citation>
<citation valid="true">
<authors>
<author>B Taskar</author>
<author>C Guestrin</author>
<author>D Koller</author>
</authors>
<title>Max-margin Markov networks.</title>
<date>2003</date>
<booktitle>In Proc. NIPS.</booktitle>
<contexts>
<context position="5089" citStr="Taskar et al., 2003" startWordPosition="769" endWordPosition="772"> SVM parser of Yamada and Matsumoto (2003) and Ratnaparkhi’s parser, our parsers are trained to maximize the accuracy of the overall tree. Our approach is related to those of Collins and Roark (2004) and Taskar et al. (2004) for phrase structure parsing. Collins and Roark (2004) presented a linear parsing model trained with an averaged perceptron algorithm. However, to use parse features with sufficient history, their parsing algorithm must prune heuristically most of the possible parses. Taskar et al. (2004) formulate the parsing problem in the large-margin structured classification setting (Taskar et al., 2003), but are limited to parsing sentences of 15 words or less due to computation time. Though these approaches represent good first steps towards discriminatively-trained parsers, they have not yet been able to display the benefits of discriminative training that have been seen in namedentity extraction and shallow parsing. Besides simplicity, our method is efficient and accurate, as we demonstrate experimentally on English and Czech treebank data. 2 System Description 2.1 Definitions and Background In what follows, the generic sentence is denoted by x (possibly subscripted); the ith word of x is</context>
<context position="10124" citStr="Taskar et al. (2003)" startWordPosition="1669" endWordPosition="1672">is maintained that accumulates Training data: T = {(xt, yt)}Tt�1 1. w0 = 0; v = 0; i = 0 2. for n : 1..N 3. fort : 1..T 4. w(i+1) = update w(i) according to instance (xt, yt) 5. v = v + w(i+1) 6. i = i + 1 7.w=v/(N*T) Figure 3: Generic online learning algorithm. the values of w after each iteration, and the returned weight vector is the average of all the weight vectors throughout training. Averaging has been shown to help reduce overfitting (Collins, 2002). 2.3.1 MIRA Crammer and Singer (2001) developed a natural method for large-margin multi-class classification, which was later extended by Taskar et al. (2003) to structured classification: min IwII s.t. s(x, y) − s(x, y&apos;) &gt; L(y, y&apos;) b(x, y) E T, y&apos; E dt(x) where L(y, y&apos;) is a real-valued loss for the tree y&apos; relative to the correct tree y. We define the loss of a dependency tree as the number of words that have the incorrect parent. Thus, the largest loss a dependency tree can have is the length of the sentence. Informally, this update looks to create a margin between the correct dependency tree and each incorrect dependency tree at least as large as the loss of the incorrect tree. The more errors a tree has, the farther away its score will be from</context>
<context position="13414" citStr="Taskar et al., 2003" startWordPosition="2243" endWordPosition="2246">alues of k on a development data set and found that small values of k are sufficient to achieve close to best performance, justifying our assumption. In fact, as k grew we began to observe a slight degradation of performance, indicating some overfitting to the training data. All the experiments presented here use k = 5. The Eisner (1996) algorithm can be modified to find the k-best trees while only adding an additional O(k log k) factor to the runtime (Huang and Chiang, 2005). A more common approach is to factor the structure of the output space to yield a polynomial set of local constraints (Taskar et al., 2003; Taskar et al., 2004). One such factorization for dependency trees is � min �w(Z+1) − w(Z)II s.t. s(l, j) − s(k, j) ≥ 1 ∀(l, j) ∈ yt, (k, j) ∈� yt It is trivial to show that if these O(n2) constraints are satisfied, then so are those in (1). We implemented this model, but found that the required training time was much larger than the k-best formulation and typically did not improve performance. Furthermore, the k-best formulation is more flexible with respect to the loss function since it does not assume the loss function can be factored into a sum of terms for each dependency. 2.4 Feature Se</context>
</contexts>
<marker>Taskar, Guestrin, Koller, 2003</marker>
<rawString>B. Taskar, C. Guestrin, and D. Koller. 2003. Max-margin Markov networks. In Proc. NIPS.</rawString>
</citation>
<citation valid="true">
<authors>
<author>B Taskar</author>
<author>D Klein</author>
<author>M Collins</author>
<author>D Koller</author>
<author>C Manning</author>
</authors>
<title>Max-margin parsing.</title>
<date>2004</date>
<booktitle>In Proc. EMNLP.</booktitle>
<contexts>
<context position="1954" citStr="Taskar et al., 2004" startWordPosition="277" endWordPosition="280">nt classification (Joachims, 2002) and shallow parsing (Sha and Pereira, 2003). Ratnaparkhi’s conditional maximum entropy model (Ratnaparkhi, 1999), trained to maximize conditional likelihood P(y|x) of the training data, performed nearly as well as generative models of the same vintage even though it scores parsing decisions in isolation and thus may suffer from the label bias problem (Lafferty et al., 2001). Discriminatively trained parsers that score entire trees for a given sentence have only recently been investigated (Riezler et al., 2002; Clark and Curran, 2004; Collins and Roark, 2004; Taskar et al., 2004). The most likely reason for this is that discriminative training requires repeatedly reparsing the training corpus with the current model to determine the parameter updates that will improve the training criterion. The reparsing cost is already quite high for simple context-free models with O(n3) parsing complexity, but it becomes prohibitive for lexicalized grammars with O(n5) parsing complexity. Dependency trees are an alternative syntactic representation with a long history (Hudson, 1984). Dependency trees capture important aspects of functional relationships between words and have been sh</context>
<context position="4693" citStr="Taskar et al. (2004)" startWordPosition="710" endWordPosition="713">rning model. Their parser uses a hybrid bottom-up/topdown linear-time heuristic parser and the ability to label edges with semantic types. The accuracy of their parser is lower than that of Yamada and Matsumoto (2003). We present a new approach to training dependency parsers, based on the online large-margin learning algorithms of Crammer and Singer (2003) and Crammer et al. (2003). Unlike the SVM parser of Yamada and Matsumoto (2003) and Ratnaparkhi’s parser, our parsers are trained to maximize the accuracy of the overall tree. Our approach is related to those of Collins and Roark (2004) and Taskar et al. (2004) for phrase structure parsing. Collins and Roark (2004) presented a linear parsing model trained with an averaged perceptron algorithm. However, to use parse features with sufficient history, their parsing algorithm must prune heuristically most of the possible parses. Taskar et al. (2004) formulate the parsing problem in the large-margin structured classification setting (Taskar et al., 2003), but are limited to parsing sentences of 15 words or less due to computation time. Though these approaches represent good first steps towards discriminatively-trained parsers, they have not yet been able</context>
<context position="13436" citStr="Taskar et al., 2004" startWordPosition="2247" endWordPosition="2250">opment data set and found that small values of k are sufficient to achieve close to best performance, justifying our assumption. In fact, as k grew we began to observe a slight degradation of performance, indicating some overfitting to the training data. All the experiments presented here use k = 5. The Eisner (1996) algorithm can be modified to find the k-best trees while only adding an additional O(k log k) factor to the runtime (Huang and Chiang, 2005). A more common approach is to factor the structure of the output space to yield a polynomial set of local constraints (Taskar et al., 2003; Taskar et al., 2004). One such factorization for dependency trees is � min �w(Z+1) − w(Z)II s.t. s(l, j) − s(k, j) ≥ 1 ∀(l, j) ∈ yt, (k, j) ∈� yt It is trivial to show that if these O(n2) constraints are satisfied, then so are those in (1). We implemented this model, but found that the required training time was much larger than the k-best formulation and typically did not improve performance. Furthermore, the k-best formulation is more flexible with respect to the loss function since it does not assume the loss function can be factored into a sum of terms for each dependency. 2.4 Feature Set Finally, we need a s</context>
</contexts>
<marker>Taskar, Klein, Collins, Koller, Manning, 2004</marker>
<rawString>B. Taskar, D. Klein, M. Collins, D. Koller, and C. Manning. 2004. Max-margin parsing. In Proc. EMNLP.</rawString>
</citation>
<citation valid="true">
<authors>
<author>H Yamada</author>
<author>Y Matsumoto</author>
</authors>
<title>Statistical dependency analysis with support vector machines.</title>
<date>2003</date>
<booktitle>In Proc. IWPT.</booktitle>
<contexts>
<context position="3789" citStr="Yamada and Matsumoto (2003)" startWordPosition="565" endWordPosition="568">, 1998). Edges in a dependency tree may be typed (for instance to indicate grammatical function). Though we focus on the simpler non-typed 91 Proceedings of the 43rd Annual Meeting of the ACL, pages 91–98, Ann Arbor, June 2005. c�2005 Association for Computational Linguistics root John hit the ball with the bat Figure 1: An example dependency tree. case, all algorithms are easily extendible to typed structures. The following work on dependency parsing is most relevant to our research. Eisner (1996) gave a generative model with a cubic parsing algorithm based on an edge factorization of trees. Yamada and Matsumoto (2003) trained support vector machines (SVM) to make parsing decisions in a shift-reduce dependency parser. As in Ratnaparkhi’s parser, the classifiers are trained on individual decisions rather than on the overall quality of the parse. Nivre and Scholz (2004) developed a history-based learning model. Their parser uses a hybrid bottom-up/topdown linear-time heuristic parser and the ability to label edges with semantic types. The accuracy of their parser is lower than that of Yamada and Matsumoto (2003). We present a new approach to training dependency parsers, based on the online large-margin learni</context>
<context position="18233" citStr="Yamada and Matsumoto (2003)" startWordPosition="3059" endWordPosition="3062">it would be useful to know previous attachment decisions and incorporate these into the features. It is fairly straightforward to modify the parsing algorithm to store previous attachments. However, any modification would result in an asymptotic increase in parsing complexity. 3 Experiments We tested our methods experimentally on the English Penn Treebank (Marcus et al., 1993) and on the Czech Prague Dependency Treebank (Hajiˇc, 1998). All experiments were run on a dual 64-bit AMD Opteron 2.4GHz processor. To create dependency structures from the Penn Treebank, we used the extraction rules of Yamada and Matsumoto (2003), which are an approximation to the lexicalization rules of Collins (1999). We split the data into three parts: sections 02-21 for training, section 22 for development and section 23 for evaluation. Currently the system has 6, 998, 447 features. Each instance only uses a tiny fraction of these features making sparse vector calculations possible. Our system assumes POS tags as input and uses the tagger of Ratnaparkhi (1996) to provide tags for the development and evaluation sets. Table 2 shows the performance of the systems that were compared. Y&amp;M2003 is the SVM-shiftreduce parsing model of Yam</context>
<context position="19988" citStr="Yamada and Matsumoto (2003)" startWordPosition="3350" endWordPosition="3353">ncy parsing results for English and Czech. Accuracy is the number of words that correctly identified their parent in the tree. Root is the number of trees in which the root word was correctly identified. For Czech this is f-measure since a sentence may have multiple roots. Complete is the number of sentences for which the entire dependency tree was correct. not exploit phrase structure. We ensured that the gold standard dependencies of all systems compared were identical. Table 2 shows that the model described here performs as well or better than previous comparable systems, including that of Yamada and Matsumoto (2003). Their method has the potential advantage that SVM batch training takes into account all of the constraints from all training instances in the optimization, whereas online training only considers constraints from one instance at a time. However, they are fundamentally limited by their approximate search algorithm. In contrast, our system searches the entire space of dependency trees and most likely benefits greatly from this. This difference is amplified when looking at the percentage of trees that correctly identify the root word. The models that search the entire space will not suffer from </context>
<context position="22783" citStr="Yamada and Matsumoto, 2003" startWordPosition="3814" endWordPosition="3817">t problematic since it contains some crossing dependencies which cannot be parsed by the Eisner algorithm. One trick is to rearrange the words in the training set so that all trees are nested. This at least allows the training algorithm to obtain reasonably low error on the training set. We found that this did improve performance slightly to 83.6% accuracy. 3.1 Lexicalized Phrase Structure Parsers It is well known that dependency trees extracted from lexicalized phrase structure parsers (Collins, 1999; Charniak, 2000) typically are more accurate than those produced by pure dependency parsers (Yamada and Matsumoto, 2003). We compared our system to the Bikel re-implementation of the Collins parser (Bikel, 2004; Collins, 1999) trained with the same head rules of our system. There are two ways to extract dependencies from lexicalized phrase structure. The first is to use the automatically generated dependencies that are explicit in the lexicalization of the trees, we call this system Collinsauto. The second is to take just the phrase structure output of the parser and run the automatic head rules over it to extract the dependencies, we call this sys96 English Accuracy Root Complete Complexity Time Collins-auto 8</context>
</contexts>
<marker>Yamada, Matsumoto, 2003</marker>
<rawString>H. Yamada and Y. Matsumoto. 2003. Statistical dependency analysis with support vector machines. In Proc. IWPT.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>