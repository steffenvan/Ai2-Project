<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000002">
<title confidence="0.991663">
Multilingual Generation and Summarization of Job Adverts:
the TREE Project
</title>
<author confidence="0.988823">
Harold Somers, Bill Black
</author>
<affiliation confidence="0.8367845">
Centre for Computational Linguistics,
UMIST,
</affiliation>
<address confidence="0.6190415">
Manchester, England
Annarosa Multari, Luca Gilardoni
Quinary SpA,
Milano, Italy
</address>
<sectionHeader confidence="0.9111" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999332538461539">
A multilingual Internet-based employment
advertisement system is described. Job
ads are submitted as e-mail texts, analysed
by an example-based pattern matcher and
stored in language-independent schemas in
an object-oriented database. Users can
search the database in their own language
and get customized summaries of the job
ads. The query engine uses symbolic
case-based reasoning techniques, while the
generation module integrates canned text,
templates, and grammar rules to produce
texts and hypertexts in a simple way.
</bodyText>
<sectionHeader confidence="0.99559" genericHeader="introduction">
1 Introduction
</sectionHeader>
<bodyText confidence="0.999051555555555">
Free movement of labour across national boundaries
is an important aim of the European Union.&apos; One of
the prerequisites for this open labour market is ac-
cessibility of information about employment oppor-
tunities, both from the point of view of people seek-
ing work, and of their potential employers. However,
many EU citizens are denied full access to employ-
ment opportunities because information may not be
readily available, and even where it is, it may not be
available in the right language. The TREE project
aims to address this problem by providing a system
on the Internet where employers can deposit job ads,
and which users can browse, each in their own lan-
guage. Access to this service will be either through
the user&apos;s own Internet provider, or at dedicated ter-
minals located in employment centres. There are
currently very many Internet sites where jobs are
advertised, and indeed using information retrieval
</bodyText>
<footnote confidence="0.999720444444444">
1TREE is Language Engineering project LE 1182
of the European Commission&apos;s Fourth Framework Pro-
gramme. We would like to express our thanks to other
partners on the project: Edy Geerts and Marianne
Kamoen (VDAB, Vlaamse Dienst voor Arbeidsbemid-
deling en Beroepsopleiding), Mick Riley (Newcastle upon
Tyne City Council), and Teresa Paskiewicz and Mark
Stairmand (UMIST). The URL for the project&apos;s web site
is http://wvw.mari.co.uk/tree/.
</footnote>
<note confidence="0.8545595">
Joakim Nivre, Torbjarn Lager
SSKKII,
</note>
<affiliation confidence="0.5118234">
University of Goteborg,
Sweden
Jeremy Ellman, Alex Rogers
MARI Computer Systems Ltd,
Ashington, Northumberland, England
</affiliation>
<bodyText confidence="0.999900975">
techniques next to natural language processing to
search job offer databases is not a new application,
cf. (Vega, 1990; Caldwell Sz Korelsky, 1994). But
no other application — as far as we can discover —
offers the opportunity of searching and of getting
summaries of job ads in languages other than that
of the original announcement.
TREE therefore offers two significant services: in-
telligent search and summarization on the one hand,
and these independent of the original language of
the job ad on the other. It could be argued that the
latter at least could be achieved by hooking a com-
mercial Machine Translation (MT) system up to an
Internet employment service. Although MT has had
some success on the Internet (Flanagan, 1996), this
is with largely sympathetic users who understand
well the limitations of MT. Its use for a more del-
icate task aimed at the general public, especially a
public which is not necessarily highly educated, is
certainly out of the question, for well known rea-
sons which we need not explore here. Suffice to say
that an experiment in Canada using an MT system
for precisely this application (Murray, 1989) was far
from successful.
It is also apparent that for many jobs in a loca-
tion where a different language is spoken, sufficient
linguistic knowledge at least to read an ad for a job
in that region would be one of the prerequisites of
the job: this is certainly the case for the kind of pro-
fessional positions often advertised on the Internet.
Nevertheless, our system offers users the possibility
of searching in their own language for jobs advertised
in a variety of languages. Also, there is a significant
workforce for which foreign-language skills are not a
prerequisite for working abroad, and which, further-
more, has traditionally been one of the most mobile:
seasonal semi- and unskilled workers. For this rea-
son, the domain we have chosen for the prototype
development of the TREE project is the hotel and
catering industry.
</bodyText>
<page confidence="0.997576">
269
</page>
<sectionHeader confidence="0.855365" genericHeader="method">
2 Overall design
</sectionHeader>
<bodyText confidence="0.992716921052632">
The TREE system stores job ads in a partly
language-independent schematic form, and is ac-
cessed by job-seeking users who can specify a num-
ber of parameters which are used to search the job
database, and who can also customize the way the
information retrieved is presented to them. A sec-
ond type of user is the potential employer who pro-
vides job announcements to the system in the form
of free text via an e-mail feed or, it is planned, via
a form-filling interface (though we shall not discuss
this latter input mode here).
The initial prototype system currently imple-
mented can store and retrieve job ads in three lan-
guages — English, Flemish and French — regardless of
which of these three languages the job was originally
drafted in.
The system has four key components which are
the subject of this paper. Telematics, HCI and cer-
tain other issues such as maintenance of the system
(deleting old ads, user training, legality of texts in
different countries) and the information retrieval as-
pects of the system will not be discussed in this pa-
per.
The four components which we discuss here are:
(a) the schema data structure for storing the job
ads, and the associated terminological and lexical
databases; (b) the analysis module for converting
job ads received into their schematic form; (c) the
query interface to allow users to specify the range
of job ads they wish to retrieve; and (d) the gener-
ator, which creates a customised selective summary
of the job ads retrieved in HTML format. To a great
extent, the design of each of these modules is not es-
pecially innovative. However, the integration of all
these functions is, from a methodological point of
view, a good example of how a variety of techniques
can be combined into a real application with a real
use in the real world.
</bodyText>
<sectionHeader confidence="0.995031" genericHeader="method">
3 Data Structures
</sectionHeader>
<subsectionHeader confidence="0.999925">
3.1 Job ad representation schema
</subsectionHeader>
<bodyText confidence="0.967918210526316">
Job ads are stored in the system in a &amp;quot;schema&amp;quot;,
which is a typed feature structure consisting of
named slots and fillers. The slots, some of which
have a simple internal structure of their own, iden-
tify elements of the job ad. Many, though not all
of the slots can be specified as part of the search,
and all of them can be generated as part of the job
summary.
The fillers for the slots may be
coded language-independent references to the ter-
minological database, source-language strings which
can nevertheless be translated on demand with ref-
erence to the &amp;quot;lexicon&amp;quot;, or literal strings which will
not be translated at all. The stylised partial example
of a filled schema in Figure 1 gives an impression of
the data structure. The distinction between terms
and items in the lexicon is discussed below, but we
consider first the design and implementation of the
schema database.
</bodyText>
<figureCaption confidence="0.975814">
Figure 1: A partial example of a filled job schema.
</figureCaption>
<bodyText confidence="0.818923">
Slot names are shown in CAPITALS, fillers in quote marks
are stored as strings; other fillers are coded.
JOB: waiter JOBCODE: 92563
NUMBER_OF_JOBS: several
LOCATION: &amp;quot;Urmston&amp;quot; WORKTIME: 2
SKILLS:EXPERIENCE:essential
APPLICATION:PHONE: 224 8619
</bodyText>
<listItem confidence="0.9620275">
CONTACT NAME: &amp;quot;Andrea&amp;quot;
ORIGINAL_TEXT: &amp;quot;Urgent!!! P/T Waiters
required, Urmston area. Experience
essential. Phone Andrea on 224 8619.&amp;quot;
</listItem>
<bodyText confidence="0.999829352941176">
The main aim of the schema is to represent in
a consistent way the information which the anal-
ysis module extracts from the job ads, which the
query module searches, and from which the genera-
tion module produces text. Note that the example
shown in Figure 1 is rather simplified for the pur-
poses of illustration. The schema module provides
a database of job schema instances (Onyshkevych,
1990). The analysis and design phases were con-
ducted using the OMT (Rumbaugh, 1990) object-
oriented methodology. Since the system currently
treats three languages (with the prospect of exten-
sion to more), we decided to codify in a language-
neutral fashion the information extracted from the
ads, converting equivalent linguistic terms into codes
and vice versa via the analysis and generation mod-
ules described below.
</bodyText>
<subsectionHeader confidence="0.994207">
3.2 Terminology
</subsectionHeader>
<bodyText confidence="0.997543263157895">
The terminology module has been designed with the
general aim of supporting all the common function-
alities shared by the analysis, generation and query
modules and of supporting a language-independent
term bank to permit multilingual handling of the
schema database contents. We have focused on
domain-specific terms and classifications, not cover-
ing generic language issues nor providing a general
lexicon and thesaurus.
Different kinds of domain-specific information can
be found as slot fillers, depending on the intended
meaning of schema slots. The most relevant infor-
mation is obviously job types. Existing job classifi-
cations have been established for example by the Eu-
ropean Commission&apos;s Employment Service (EURES,
1989), by the ILO (ILO, 1990) and several individ-
ual companies; each provides a hierarchical classifi-
cation of jobs, specifying, for each term, a distinct
code, a description of the job, one or more generic
</bodyText>
<page confidence="0.988378">
270
</page>
<bodyText confidence="0.9641044">
terms commonly used to refer to the specific job, and
possibly a set of synonyms. The description of the
job ranges, depending on the classification, from a
quite broad one to greatly detailed ones, sometimes
highlighting differences existing in different coun-
tries (e.g. according to the EURES classification,
a &amp;quot;waiter&amp;quot; in some EU states is also required to act
as a barman while in others is not). Job classifica-
tions therefore provide at least three different kinds
of information:
</bodyText>
<listItem confidence="0.978872214285714">
• Definition of recognized job types, with a (more
or less) precise definition of what the job is; chef
is a recognized item, as well as pizza chef, while
chef specializing in preparing hors d&apos;oeuvres is
not; classifications are obviously arbitrary as
long the boundary between whether a specific
job is a recognized one or simply an &amp;quot;unrecog-
nized&amp;quot; classification simply depends on the level
of granularity the classifier decides to use.
• Classification of job types along ISA hierarchies
(e.g. a wine waiter ISA type of waiter).
• Linguistic information about commonly used
terms and synonyms used in a given language
(or more than one) to refer to the specific term.
</listItem>
<bodyText confidence="0.999340368421053">
Accordingly, job classification terms are classified,
coded (i.e. a distinct code identifying the term is
associated with each term) and a list of standard
&amp;quot;names&amp;quot; as well as recognized synonyms is asso-
ciated with them. The classification and coding
schema of VDAB, one of the end-user partners in
the project, is used, but extensions deriving from
other schema could obviously be envisaged. Trans-
lation tables are provided for each term, containing
the names used in the different languages. Align-
ments across different languages are kept whenever
possible. Problems due to missing equivalent terms
in different languages, or to slightly different mean-
ings, are handled, at least in the first stage, simply
by providing terms nearer in meaning. An example
of some job titles is shown in Figure 2: the hier-
archical nature of the titles, and also the existence
of some synonyms, is suggested by the numbering
scheme, and is more or less self-explanatory.
</bodyText>
<figureCaption confidence="0.984278">
Figure 2: Examples of job codes and names in
French, Flemish and English.
</figureCaption>
<footnote confidence="0.7815968">
91200 cuisinier * kok # cook
91202 chef # chef # chef
91205 chef de cuisine # chef-kok # chief cook
91236 cuisinier de regime # dieetkok # diet cook
91237 cuisinier de cantine # kok grootkeuken it canteen cook
91241 commis de cuisine # keukenhulp # kitchen assistant
91241 commis de cuisine # keukenpersoneel # kitchen staff
91241 commis de cuisine # keukenhulp * catering assistant
91241 aide-cuisinier # hulpkok # assistant cook
91260 second cuisinier # hulpkok # second chef
</footnote>
<bodyText confidence="0.990327520833333">
Codes are used as slot fillers in the schema
database. This makes the schema neutral with re-
spect to analysis, query and generation languages.
For example, when searching for a job, the classifica-
tion hierarchies inherent in the terminology database
allow the user to express general search constraints
(e.g. looking for a job as a chef), even though indi-
vidual jobs are coded for specific types of chef (pas-
trycook, pizza chef etc., and of course in different
languages (e.g. Bakkersgast).
Although the job titles themselves provide an ob-
vious area of terminology, we handle various other
areas of vocabulary in a similar way. There are two
criteria for &amp;quot;terminological status&amp;quot; in our system, ei-
ther of which is sufficient: (i) hierarchical structure,
and (ii) standardization. An example of &amp;quot;standard-
ized vocabulary&amp;quot; in our domain is words like full-
time, part-time, which have an agreed meaning, or
adjectives like essential as applied to requirements
such as experience, or a driving licence. Of more
interest perhaps is vocabulary which can be struc-
tured, since this provides us with an opportunity to
allow more sophisticated searching of the database.
One example is types of establishment, e.g. ho-
tel, restaurant, cafe, pub etc. Although such terms
do not necessarily figure in recognized terminolog-
ical thesauri, it is obvious that some structure can
be imposed on these terms, for example to enable
a user who is looking for a job in an eating estab-
lishment to be presented with jobs in a variety of
such places. Some hierarchies are trivially simple,
for example full-time/part-time. A more interest-
ing example is geographical location. Most job ads
express the location of the work either explicitly or
implicitly in the contact address. But often, these lo-
cations are the names of towns or districts, whereas
a user might want to search for jobs in a wider area:
a user looking for work in Flanders, for example,
should be presented with jobs whose location is iden-
tified as Antwerp. This is not as simple as it seems
however, since the kind of &amp;quot;knowledge&amp;quot; implicated
in this kind of search facility is (literally!) &amp;quot;real-
world knowledge&amp;quot; rather than linguistic knowledge:
short of coding an entire gazeteer on the off-chance
that some place-name appeared in a job ad, we must
rather rely on the user trials envisaged later in our
project to identify the extent to which geographical
information needs to be included in the system.
</bodyText>
<subsectionHeader confidence="0.996153">
3.3 Lexicon
</subsectionHeader>
<bodyText confidence="0.999948">
Not all the vocabulary that the system needs to rec-
ognize and handle can be structured in the way just
described, so we recognize a second type of lexical
resource which, for want of a better term, we call
simply &amp;quot;the lexicon&amp;quot;. These are words which we of-
ten find in job ads, associated with specific slots,
which we would like to translate if possible, but
which do not have the status of terms, since they
are neither structured nor standardized. Examples
are adjectives used to describe suitable applicants
</bodyText>
<page confidence="0.983602">
271
</page>
<bodyText confidence="0.991675333333333">
(e.g. young, energetic, experienced), phrases describ-
ing the location (e.g. busy, near the seaside) or the
employer (e.g. world-famous) and so on.
Job ads that appear in newspapers and journals
can be roughly classified according to their length
(short, medium, long) with slightly different lex-
ical and syntactic features accordingly (Alexa
Barcena, 1992), the details of which need not con-
cern us here. Some of the phrases found in typi-
cal job ads serve to signal specific slots (e.g. EM-
PLOYER:NAME is seeking JOB-TITLE), but these lin-
guistic items do not appear in the lexicon as such.
Such elements are regarded as being properly part
of the analysis and generation modules, and we de-
scribe below how they are handled there.
</bodyText>
<sectionHeader confidence="0.996885" genericHeader="method">
4 Analysis
</sectionHeader>
<bodyText confidence="0.9998576">
The system design permits users offering jobs to sub-
mit via an e-mail feed job ads more or less without
restrictions. The system converts these texts as far
as possible into schematic representations which are
then stored in the jobs database. The analysis tech-
nique that we have chosen to implement falls into
the relatively new paradigm of analogy- or example-
based processing. In the following paragraphs we ex-
plain the analysis process and discuss our reasons for
preferring this over a more traditional string match-
ing or parsing approach.
The input that the TREE system will accept is
partially structured, but with much scope for free-
text input. One possible way of analysing this would
be to employ a straightforward pattern-matching ap-
proach, searching for &amp;quot;trigger phrases&amp;quot; such as EM-
PLOYER:NAME is seeking JOB-TITLE, with special
processors for analysing the slot-filler portions of the
text. This simple approach has certain advantages
over a more complex approach based on traditional
phrase-structure parsing, especially since we are not
particularly interested in phrase-structure as such.
Furthermore, there is a clear requirement that our
analysis technique be quite robust: since the input
is not controlled in any way, our analysis procedure
must be able to extract as much information as pos-
sible from the text, but seamlessly ignore — or at
least allocate to the appropriate &amp;quot;unanalysable in-
put&amp;quot; slot — the text which it cannot interpret.
However, both these procedures can be identified
as essentially &amp;quot;rule-based&amp;quot;, in the sense that linguis-
tic data used to match, whether fixed patterns or
syntactic rules, must be explicitly listed in a kind of
grammar, which implies a number of disadvantages,
which we will mention shortly. An alternative is sug-
gested by the paradigm of &amp;quot;example-based&amp;quot; process-
ing (Jones, 1996), now becoming quite prevalent in
MT (Sumita et al., 1990; Somers, 1993), though in
fact the techniques are very much like those of the
longer established paradigm of case-based reasoning.
</bodyText>
<subsectionHeader confidence="0.983693">
4.1 A flexible approach
</subsectionHeader>
<bodyText confidence="0.982789367346939">
In the example-based approach, the &amp;quot;patterns&amp;quot; are
listed in the form of model examples. Semi-fixed
phrases are not identified as such, nor are there any
explicit linguistic rules. Instead, a matcher matches
new input against a database of already (correctly)
analysed models, and interprets the new input on
the basis of a best match (possibly out of several
candidates); robustness is inherent in the system,
since &amp;quot;failure&amp;quot; to analyse is relative.
The main advantage of the example-based ap-
proach is that we do not need to decide beforehand
what the linguistic patterns look like. To see how
this works to our advantage, consider the following.
Let us assume that our database of already analysed
examples contains an ad which includes the follow-
ing: Knowledge of Dutch an advantage, and which
is linked to a schema with slots filled roughly as fol-
lows:
SKILLS:LANGUAGE:LANG:nl
SKILLS:LANGUAGE:REQ:&amp;quot;an advantage&amp;quot;
Now suppose we want to process ads containing the
following texts:
Knowledge of the English language needed. (1)
Some knowledge of Spanish would be helpful. (2)
Very good knowledge of English. (3)
In the rule-based approach, we would probably have
to have a &amp;quot;rule&amp;quot; which specifies the range of (redun-
dant) modifiers (asuming our schema does not store
explicitly the level of language skill specified), that
fillers for the REQ slots can be a past-participle, a
predicative adjective or a noun, and are optional,
and so on. Such rules carry with them a lot of bag-
gage, such as optional elements, alternatives, restric-
tions and so on. The biggest baggage is that some-
one has to write them.
In the example-based approach, we do not need to
be explicit about the structure of the stored example
or the inputs. We need to recognize Dutch, English
and Spanish as being names of languages, but these
words have &amp;quot;terminological status&amp;quot; in our system.
If the system does not know would be helpful, it will
guess that it is a clarification of the language re-
quirement, even if it may not be able to translate
it. Furthermore, we can extend the &amp;quot;knowledge&amp;quot; of
the system simply by adding more examples: if they
contain &amp;quot;new&amp;quot; structures, the knowledge base is ex-
tended; if they mirror existing examples, the system
still benefits since the evidence for one interpretation
or another is thereby strengthened.
</bodyText>
<subsectionHeader confidence="0.9167">
4.2 The matching algorithm
</subsectionHeader>
<bodyText confidence="0.998228333333333">
The matcher, which has been developed from one
first used in the MEG project (Somers et al., 1994),
processes the new text in a linear fashion, having
</bodyText>
<page confidence="0.983737">
272
</page>
<bodyText confidence="0.99998644">
first divided it into manageable portions, on the ba-
sis of punctuation, lay-out, formatting and so on.
The input is tagged, using a standard tagger, e.g.
(Brill, 1992). There is no need to train the tagger
on our text type, because the actual tags do not
matter, as long as tagging is consistent.
The matching process then involves &amp;quot;sliding&amp;quot; one
phrase past the other, identifying &amp;quot;strong&amp;quot; matches
(word and tag) or &amp;quot;weak&amp;quot; (tag only) matches, and
allowing for gaps in the match, in a method not un-
like dynamic programming. The matches are then
scored accordingly. The result is a set of possible
matches linked to correctly filled schemas, so that
even previously unseen words can normally be cor-
rectly assigned to the appropriate slot.
The approach is not without its problems. For
example, some slots and their fillers can be quite
ambiguous: cf. moderate German required vs. tall
German required (!), while other text portions serve
a dual purpose, for example when the name of the
employer also indicates the location. However, the
possibility of on-line or e-mail feedback to the user
submitting the job ad, plus the fact that the matcher
is extremely flexible, means that the analysis module
can degrade gracefully in the face of such problems.
</bodyText>
<sectionHeader confidence="0.974807" genericHeader="method">
5 Query engine
</sectionHeader>
<bodyText confidence="0.999948">
The query engine takes users&apos; specifications of their
employment interests to identify those job ads held
in the database that match their specification. In-
put is provided from an HTML form consisting of
a number of fields which correspond to job-schema
object attributes (e.g. job-title, location etc.). Data
entered for any given object attribute is then en-
coded in the same format used to encode job ad in-
formation. Since both (searchable) job ad informa-
tion and query data are represented in a language-
independent format, matches will be made regard-
less of the language in which the data was entered.
Symbolic case-based reasoning techniques are
used to quantify the extent to which users&apos; queries
match database objects, allowing the &amp;quot;ranking&amp;quot; of
query results.
</bodyText>
<subsectionHeader confidence="0.993123">
5.1 Encoding data
</subsectionHeader>
<bodyText confidence="0.999866083333333">
Input entered by the user must be encoded using
the same method adopted by the analysis module.
There are two means by which this can be achieved.
One method is to restrict the options available to
the user for any given field to a number of possi-
ble values for a given object attribute (i.e. provide
the user with a Boolean choice). The alternative is
to allow users to enter a string which is passed to
the terminology module to retrieve the appropriate
code. If the string does not return a code, it is con-
sidered invalid and the user is requested to enter an
alternative.
</bodyText>
<subsectionHeader confidence="0.998999">
5.2 Applying case-based reasoning
</subsectionHeader>
<bodyText confidence="0.99996940625">
User-entered information is used to construct a job-
schema object which can be considered as the user&apos;s
&amp;quot;ideal&amp;quot; job. Symbolic case-based reasoning tech-
niques are then applied to quantify the difference
between the user&apos;s ideal job and jobs held within the
database in order to identify those jobs most closely
resembling the user&apos;s ideal job.
The purpose of using case-based reasoning tech-
niques is to quantify the difference (as a metric
value) between any two instances of a job-schema
object. That object must be capable of being de-
fined by one or more parameters, with the further
requirement that comparison operations upon any
two parameter values must yield a numeric value re-
flecting the semantic difference between the values.
Thus, objects can be seen as being located within an
n-dimensional parameter space where n is the num-
ber of defining parameters of the object.
The parameters which are used to define job ads
for TREE are given by the job schema definition,
described above. The distance between two values
for a specific parameter will be dependent upon the
method of encoding but any distance function for a
given parameter must define the geometric distance
between its two arguments (Salzberg &amp; Cost, 1993).
That is: a value must have a distance of zero to it-
self (4), a positive distance to all other values (5),
distances must be symmetric (6) and must obey the
triangle inequality (7). A further proviso is added
that the maximum difference between any two pa-
rameter values must be 1, which ensures that all pa-
rameters have an equivalent maximal difference (8).
</bodyText>
<equation confidence="0.7153072">
(5(a, a) = 0
6(a ,b) &gt;0 if a 0 b
6(a ,b) = 6(6, a)
6(a, b) 6(b, c) &gt; 6(a, c)
6(a, &lt; 1
</equation>
<bodyText confidence="0.998215">
For example, a distance function for the job-title pa-
rameter (as represented by job-title codes illustrated
in Figure 2) could be given by (9),
</bodyText>
<equation confidence="0.9996345">
f(la — bl)
6(a ,b) = (9)
</equation>
<bodyText confidence="0.999917916666667">
where a and b are job codes, f (x) returns the number
of digits of its argument, and n is the number of
digits in the job codes (i.e. n = 5). 6(a, b) evaluates
to 1 if the job code arguments differ on the first
digit, 0.8 if they differ on the second digit and so
on. The job codes are hierarchically ordered so job-
title codes that differ over the first digit will refer to
greatly different jobs. As such we can see that this
parameter distance function would reflect common-
sense judgements on the associated job-titles.
The total distance between any two job instances
is simply a measure of the distances between indi-
</bodyText>
<page confidence="0.966577">
273
</page>
<bodyText confidence="0.97682765">
vidual parameter distances and is given by (10), no intermediate structures are created during pro-
cessing.
A(A, B) = E bi) (10)
where A is the instance distance function, bi is the
distance function for parameter i, N is the total
number of parameters by which A and B are de-
fined, and ai and bi are the values of parameter i for
instances A and B respectively.
Equation (10) provides a measure of the total dis-
tance between two instances by summing the dis-
tances between all the constituent parameters. Us-
ing (10) and a set of parameter distance functions
that conform to the properties given as (4)—(8), it is
possible to quantify the difference between any job-
schema instance held in the database and the &amp;quot;ideal&amp;quot;
job-schema object specified by the user. Those pa-
rameters for which no value has been specified will
exactly match every possible parameter value, and
as such the database search is only constrained by
those values which users enter.
Since information on job ads is represented in a
language-independent format, a search profile in one
language will retrieve job ad information entered in
any of languages supported. Database queries are
conducted by matching the &amp;quot;ideal&amp;quot; job as specified
by the user against job-schemas held in the database.
The matching process yields a numeric result repre-
senting the &amp;quot;distance&amp;quot; between two objects. Identi-
fied jobs can then be ranked according to how closely
they resemble the user&apos;s ideal job. The results of a
database query are then fed to the generation mod-
ule for subsequent presentation in the language spec-
ified by the user.
Future plans include increasing the number of
fields over which the search can be conducted and
permitting users to specify the relative importance
of each parameter to the search. The query interface
will also keep a record of user &amp;quot;profiles&amp;quot;, so that reg-
ular users can repeat a previous search the next time
they use the system.
</bodyText>
<sectionHeader confidence="0.99472" genericHeader="method">
6 Generation
</sectionHeader>
<bodyText confidence="0.999937714285714">
The purpose of the TREE generator module is to
generate HTML documents in different languages
from job database entries (i.e. filled or partially
filled schemas), on demand. For several reasons,
the approach to generation adopted in the TREE
system can be termed &amp;quot;integrated&amp;quot;. First, it inte-
grates canned text, templates, and grammar rules
into a single grammar formalism. Second, it inte-
grates conditions on the database with other cat-
egories in the bodies of grammar rules. Third, it
integrates the generation of sentences and the gen-
eration of texts and hypertexts in a simple, seamless
way. Finally, generation involves just one single, ef-
ficient process which is integrated in the sense that
</bodyText>
<subsectionHeader confidence="0.984494">
6.1 Formalism
</subsectionHeader>
<bodyText confidence="0.993743">
In our integrated approach to generation, a grammar
rule has the format (11),
</bodyText>
<note confidence="0.368938">
Co/S0 SSI, ., SS, # Conditions (11)
</note>
<bodyText confidence="0.826490222222222">
where each SS i has the format Ci , the format Ci/Si ,
or the format [WI. Here, Ci denotes a syn-
tactic category, Si denotes a semantic value, and Wi
a word. The slash symbol &amp;quot;/&amp;quot; is used to separate the
syntax from the semantics. The symbol &amp;quot;#&amp;quot; sepa-
rates the grammar body from a set of conditions on
the database. If the set of conditions is empty, the
symbol &amp;quot;#&amp;quot;, and what follows it, may simply be
omitted.
</bodyText>
<subsectionHeader confidence="0.977861">
6.2 Canned text, templates, or grammar?
</subsectionHeader>
<bodyText confidence="0.9997764">
Suppose a system &amp;quot;knows&amp;quot; something, on which we
want it to report; suppose it knows that both the
Cafe Citrus and the Red Herring Restaurant want
to hire chefs, facts which could be captured by the
following (logical interface to the) job database:
</bodyText>
<footnote confidence="0.461523166666667">
item(e1,x1,y1).
job(y1,91202).
company(x1,&apos;Cafe Citrus&apos;).
item(e2,x2,y2).
job(y2,91202).
company(x2,&apos;Red Herring Restaurant&apos;).
</footnote>
<bodyText confidence="0.995826333333333">
We can imagine setting up our system in such a way
that when the system sees facts of this kind, a rule
such as the following —
</bodyText>
<equation confidence="0.7392602">
s/E --&gt;
[&apos;Cafe Citrus&apos;,advertises,as,vacant,a,
position,as,chef] #
fitem(E,X,Y),job(Y,91202),
company(X,&apos;Cafe Citrus&apos;)}.
</equation>
<bodyText confidence="0.945800842105263">
— will be triggered, and the system will produce the
sentence Cafe Citrus advertises as vacant a position
as chef. This is a canned-text approach. It is triv-
ial to implement, but the disadvantage is, of course,
that we would have to store one rule for each utter-
ance that we would like our system to produce.
As soon as a sentence must be produced several
times with only slight alterations, a template-based
approach is more appropriate. Let us modify the
above rule as follows:
s/E --&gt;
pn/X-name(X,C),
[advertises,as,vacant,a,position,as,chef]
# fitem(E,X,Y),job(Y,91202),
company(X,c)}.
The following rule is needed to tell the system that
it is allowed to realize the value of the feature
&lt;company&gt; as the value itself (i.e. the value is the
name of the company).
</bodyText>
<page confidence="0.975629">
274
</page>
<equation confidence="0.572778">
pn/X-name(X,Name) --&gt; [Name].
</equation>
<bodyText confidence="0.9997625">
Thus, here too, given the above job database entry,
the sentence Cafe Citrus advertises as vacant a po-
sition as chef can be generated. Furthermore, Red
Herring Restaurant advertises as vacant a position
as chef can be generated as well.
It is not hard to see that the two rules above form
the beginning of a grammar. Such a grammar may
be further elaborated as follows:
</bodyText>
<equation confidence="0.97881625">
s/E --&gt; np/X, vp/X-E-A # {A}.
np/X --&gt; pn/X-A # {A}.
np/X --&gt; n/X-A # {A}.
vp/A --&gt; v/X-A, np/X.
pn/X-company(X,Name) --&gt; [Name].
n/X-job(X,91202) --&gt; [chef].
v/Y-X-E-item(E,X,Y) --&gt;
[advertises,as,vacant,a,position,as].
</equation>
<bodyText confidence="0.9998530625">
Now, the above sentences, plus many other
sentences, may be generated, given appropriate
database entries.
Our approach is based on the idea that canned-
text approaches, template-based approaches and
grammar-based approaches to natural language gen-
eration — while they are often contrasted — may in
fact be regarded as different points on a scale, from
the very specific to the very general. In a sense, tem-
plates are just generalized canned texts, and gram-
mars are just generalized templates. Indeed, the pos-
sibility of combining these different modes of gener-
ation has recently been highlighted as one of the
keys to efficient use of natural language generation
techniques in practical applications (van Noord
Neumann, 1996; Busemann, 1996).
</bodyText>
<subsectionHeader confidence="0.994272">
6.3 Processing
</subsectionHeader>
<bodyText confidence="0.999821">
Let us now indicate how the rules are meant to be
used by the generator module. Traditionally, the
process of generation is divided into two steps: gen-
eration of message structure from database records
(what to say), and generation of sentences from mes-
sage structures (how to say it).. One way of charac-
terizing the integrated approach to generation is to
say that we go from database records to sentences
in just one step. The process of computing what
to say, and the process of computing how to say it,
are, in the general case, interleaved processes. The
process of generating from a set of grammar rules,
given a particular job database entry, will simply in-
volve picking the rules the conditions of which (best)
match the entry, and using them to generate a doc-
ument.
</bodyText>
<subsectionHeader confidence="0.963851">
6.4 Generating hypertext
</subsectionHeader>
<bodyText confidence="0.999981321428572">
The TREE system provides its output in the form
of hypertext. This approach has several advantages:
first, as argued by (Reiter &amp; Mellish, 1993), the gen-
eration of hypertext can obviate the need to perform
high-level text structuring, such as assembling para-
graphs into documents. &amp;quot;The basic idea is to use hy-
pertext mechanisms to enable users to dynamically
select the paragraphs they wish to read, and there-
fore in essence perform their own high-level text-
planning&amp;quot; (Reiter &amp; Mellish, 1993), p.3. Second,
but related to the first point, the hypertext capabil-
ities are also a mild form of tailoring to the needs of
different users. Users are expected to explore only
links containing information that they need.
Hypertext is generated by means of rules that
are very similar to the grammar rules described
above, but are formulated on a meta-level with re-
spect to sentence/text rules. HTML code &amp;quot;wrap-
pers&amp;quot; can be simply generated around the text. It
is fairly straightforward to extend the grammar to
other HTML constructions, such as headers, styles,
lists, and tables. Using such rules in combination
with other rules enables us to produce simple HTML
documents, or, if required, quite complex and deeply
nested documents incorporating links to other ads,
or buttons to expand information, or clarify termi-
nology (e.g. to get a definition of an unfamiliar job-
title).
</bodyText>
<sectionHeader confidence="0.99594" genericHeader="conclusions">
7 Conclusion
</sectionHeader>
<bodyText confidence="0.9999390625">
The European Union is a loose geo-political organi-
zation that has eleven official languages. As such, it
is clear that even in a restricted domain such as that
of job ads, novel approaches to Language Engineer-
ing are required.
In this paper we have described an approach that
summarizes ads into a base schema, and then gener-
ates output in the desired language in a principled,
though restricted way. At first glance, this may look
like old-fashioned interlingual MT, but there are two
important differences. First, our approach is inher-
ently &amp;quot;lossy&amp;quot;, in that not all the information in the
input ad may be analysed into the schema. It cannot
consequently be included in the generated output.
Second, the format of the output can be controlled
and customised by the user which means again that
the output text is a summary or digest, not nec-
essarily presented in the same order as the original
text. For both these reasons, our system cannot be
descibed as a &amp;quot;translation system&amp;quot;. Nonetheless we
believe this approach is capable of giving consider-
able coverage at a far lower cost and higher quality
than that usually associated with MT.
Our approach is not without some disadvantages
however: it is well known that a considerable quan-
tity of the semantics of human language is culturally
and socially determined. Thus, even though one can
map the names of job categories from one language
to another, it is not necessarily true that they mean
the same thing. So for example, waiters in Spain are
expected to serve snacks, whereas in Belgium they
do not. There is of course no easy solution to these
</bodyText>
<page confidence="0.992553">
275
</page>
<bodyText confidence="0.999736666666667">
problems from the Language Engineering point of
view: our service must simply advise users to check
that the job description in the target country corre-
sponds to their understanding.
Legal constraints are also a significant issue in the
area of job advertising. Thus, whilst most coun-
tries in the EU have legislation to prevent race and
sex discrimination in job advertising, some do not.
Thus a Spanish bar can (or could until recently) ad-
vertise for Pretty girls wanted as bar staff, and Men
wanted to work in the kitchen. This type of discrim-
ination is illegal in the UK where it would violate
Sex Equality Legislation. Thus we must generate
non-discriminatory text to avoid running foul of UK
law. This clearly shows how practical applications
of Language Engineering have to conform in unfore-
seen ways to the real world.
Our future work will continue to extend the prag-
matic approach taken so far. In particular, we are
being encouraged to broaden the coverage of our sys-
tem to include many more employment domains. It
remains to be seen what are the consequences of this
scaling on what has so far proved to be a simple but
effective architecture.
</bodyText>
<sectionHeader confidence="0.996909" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.978077714285714">
Alexa, Melpomeni &amp; Elena Barcena. 1992. A cross-
linguistic study of the sublanguage of short job
advertisements for the design of a multilingual
text generation system (MEG). CCL/UMIST Re-
port 92/8, Centre for Computational Linguistics,
UMIST, Manchester.
Brill, Eric. 1992. A simple rule-based part of speech
tagger. In Third Conference on Applied Natural
Language Processing, Trento, Italy, pp. 153-5.
Busemann, Stephan. 1996. Best-first sur-
face realization. Computation and Lan-
guage E-Print Archive cmp-lg/9605010. URL
http://xxx.lanl.gov/cmp-lg/.
Caldwell, David E. &amp; Tatiana Korelsky. 1994. Bilin-
gual generation of job descriptions from quais-
conceptual forms. In Fourth Conference on
Applied Natural Language Processing, Stuttgart,
Germany, pp. 1-6.
EURES. 1989. Communication of the comparison
of vocational training qualifications between mem-
ber states established in implementation of Com-
mission Decision 85/368/EEC of 16th July 1985:
Hotel and Catering Industry. Official Journal of
the European Communities 32, C166, 3 July 1989,
pp. 1-56.
Flanagan, Mary. 1996. Two years online: experi-
ences, challenges and trends. In Expanding MT
Horizons: Proceedings of the Second Conference
of the Association for Machine Translation in the
Americas, Montreal, Canada, pp. 192-7.
ILO. 1990. International Standard Classification
of Occupations: ISCO-88, International Labour
Office, Geneva.
Jones, Daniel. 1996. Analogical Natural Language
Processing, UCL Press, London.
Murray, Pamela. 1989. A review of MT policy
and current commercial systems in Canada with
a view to illustrating the importance of sublan-
guages in successful MT application. MSc disser-
tation, UMIST, Manchester.
Onyshkevych, Boyan. 1993. Template Design for
Information Extraction. In Proceedings of the
Fifth Message Understanding Conference (MUC-
5), Baltimore, Md., pp. 19-23.
Reiter, Ehud &amp; Chris Mellish 1993. Optimis-
ing the costs and benefits of natural language
generation. In Proceedings of the 13th Interna-
tional Joint Conference on Artificial Intelligence,
Chambery, France, pp. 1164-71.
Rumbaugh, James. 1995. OMT: the Object Model.
Journal of Object-Oriented Programming, 7.8:21-
7.
Salzberg, Steven &amp; Scott Cost. 1993. A weighted
nearest neighbour algoritm for learning with sym-
bolic features. Machine Learning 10:57-78.
Somers, Harold L. 1993. La traduction automatique
ba,see sur l&apos;exemple ou sur les corpus. In La tra-
ductique: Etudes et recherches de traduction par
ordinateur, Pierrette Bouillon &amp; Andre Clas (eds),
Les Presses de l&apos;Universite de Montreal, pp. 149-
66.
Somers, Harold L., Ian McLean &amp; Daniel Jones.
1994. Experiments in multilingual example-based
generation. In CSNLP 1994: 3rd Conference on
the Cognitive Science of Natural Language Pro-
cessing, Dublin, Ireland.
Sumita, Eiichiro, Hitoshi Iida &amp; Hideo Kameyama.
1990. Translating with examples: a new approach
to Machine Translation. In The Third Interna-
tional Conference on Theoretical and Methodolog-
ical Issues in Machine Translation of Natural Lan-
guage, Austin, Texas, pp. 203-12.
van Noord, Gertjan &amp; Gunter Neumann. 1996. Syn-
tactic generation. In Survey of the State of the Art
in Human Language Technology (Ronald A. Cole,
general ed.), Chapter 4 (Hans Uszkoreit, ed.).
Available at http: //www. cse ogi. edu/CSLU/
HLTsurvey/ch4node4.html#SECTION42. To be
published by Cambridge University Press.
Vega, Jose. 1990. Semantic matching between job
offers and job search requests. In COLING-90:
Papers presented to the 13th International Confer-
ence on Computational Linguistics, Helsinki, Fin-
land, Vol.1 pp. 67-9.
</reference>
<page confidence="0.998461">
276
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.000002">
<title confidence="0.985849">Multilingual Generation and Summarization of Job Adverts: the TREE Project</title>
<author confidence="0.999918">Harold Somers</author>
<author confidence="0.999918">Bill Black</author>
<affiliation confidence="0.9895235">Centre for Computational Linguistics, UMIST,</affiliation>
<address confidence="0.998539">Manchester, England</address>
<author confidence="0.959828">Annarosa Multari</author>
<author confidence="0.959828">Luca Gilardoni</author>
<affiliation confidence="0.991004">Quinary SpA,</affiliation>
<address confidence="0.996161">Milano, Italy</address>
<abstract confidence="0.996808536585366">A multilingual Internet-based employment advertisement system is described. Job ads are submitted as e-mail texts, analysed by an example-based pattern matcher and stored in language-independent schemas in an object-oriented database. Users can search the database in their own language and get customized summaries of the job ads. The query engine uses symbolic case-based reasoning techniques, while the generation module integrates canned text, templates, and grammar rules to produce texts and hypertexts in a simple way. Free movement of labour across national boundaries is an important aim of the European Union.&apos; One of the prerequisites for this open labour market is accessibility of information about employment opportunities, both from the point of view of people seeking work, and of their potential employers. However, many EU citizens are denied full access to employment opportunities because information may not be readily available, and even where it is, it may not be available in the right language. The TREE project aims to address this problem by providing a system on the Internet where employers can deposit job ads, and which users can browse, each in their own language. Access to this service will be either through the user&apos;s own Internet provider, or at dedicated terminals located in employment centres. There are currently very many Internet sites where jobs are advertised, and indeed using information retrieval is Language Engineering project LE 1182 of the European Commission&apos;s Fourth Framework Programme. We would like to express our thanks to other partners on the project: Edy Geerts and Marianne Kamoen (VDAB, Vlaamse Dienst voor Arbeidsbemiddeling en Beroepsopleiding), Mick Riley (Newcastle upon Tyne City Council), and Teresa Paskiewicz and Mark Stairmand (UMIST). The URL for the project&apos;s web site is http://wvw.mari.co.uk/tree/.</abstract>
<author confidence="0.645417">Joakim Nivre</author>
<author confidence="0.645417">Torbjarn Lager</author>
<affiliation confidence="0.979102">SSKKII, University of Goteborg,</affiliation>
<address confidence="0.730191">Sweden</address>
<author confidence="0.975992">Jeremy Ellman</author>
<author confidence="0.975992">Alex Rogers</author>
<affiliation confidence="0.999699">MARI Computer Systems Ltd,</affiliation>
<address confidence="0.997096">Ashington, Northumberland, England</address>
<abstract confidence="0.98692340272109">techniques next to natural language processing to search job offer databases is not a new application, cf. (Vega, 1990; Caldwell Sz Korelsky, 1994). But no other application — as far as we can discover — offers the opportunity of searching and of getting summaries of job ads in languages other than that of the original announcement. TREE therefore offers two significant services: intelligent search and summarization on the one hand, and these independent of the original language of the job ad on the other. It could be argued that the latter at least could be achieved by hooking a commercial Machine Translation (MT) system up to an Internet employment service. Although MT has had some success on the Internet (Flanagan, 1996), this is with largely sympathetic users who understand well the limitations of MT. Its use for a more delicate task aimed at the general public, especially a public which is not necessarily highly educated, is certainly out of the question, for well known reasons which we need not explore here. Suffice to say that an experiment in Canada using an MT system for precisely this application (Murray, 1989) was far from successful. It is also apparent that for many jobs in a location where a different language is spoken, sufficient linguistic knowledge at least to read an ad for a job in that region would be one of the prerequisites of the job: this is certainly the case for the kind of professional positions often advertised on the Internet. Nevertheless, our system offers users the possibility of searching in their own language for jobs advertised in a variety of languages. Also, there is a significant workforce for which foreign-language skills are not a prerequisite for working abroad, and which, furthermore, has traditionally been one of the most mobile: seasonal semiand unskilled workers. For this reason, the domain we have chosen for the prototype development of the TREE project is the hotel and catering industry. 269 2 Overall design The TREE system stores job ads in a partly language-independent schematic form, and is accessed by job-seeking users who can specify a number of parameters which are used to search the job database, and who can also customize the way the information retrieved is presented to them. A second type of user is the potential employer who provides job announcements to the system in the form of free text via an e-mail feed or, it is planned, via a form-filling interface (though we shall not discuss this latter input mode here). The initial prototype system currently implemented can store and retrieve job ads in three languages — English, Flemish and French — regardless of which of these three languages the job was originally drafted in. The system has four key components which are subject of this paper. Telematics, HCI and certain other issues such as maintenance of the system (deleting old ads, user training, legality of texts in different countries) and the information retrieval aspects of the system will not be discussed in this paper. The four components which we discuss here are: (a) the schema data structure for storing the job ads, and the associated terminological and lexical databases; (b) the analysis module for converting job ads received into their schematic form; (c) the query interface to allow users to specify the range of job ads they wish to retrieve; and (d) the generator, which creates a customised selective summary of the job ads retrieved in HTML format. To a great extent, the design of each of these modules is not especially innovative. However, the integration of all these functions is, from a methodological point of view, a good example of how a variety of techniques can be combined into a real application with a real use in the real world. 3 Data Structures 3.1 Job ad representation schema Job ads are stored in the system in a &amp;quot;schema&amp;quot;, which is a typed feature structure consisting of named slots and fillers. The slots, some of which have a simple internal structure of their own, identify elements of the job ad. Many, though not all of the slots can be specified as part of the search, and all of them can be generated as part of the job summary. The fillers for the slots may be coded language-independent references to the terminological database, source-language strings which can nevertheless be translated on demand with reference to the &amp;quot;lexicon&amp;quot;, or literal strings which will not be translated at all. The stylised partial example of a filled schema in Figure 1 gives an impression of the data structure. The distinction between terms and items in the lexicon is discussed below, but we consider first the design and implementation of the schema database. Figure 1: A partial example of a filled job schema. names are in in quote marks are stored as strings; other fillers are coded. JOB: waiter JOBCODE: 92563 NUMBER_OF_JOBS: several LOCATION: &amp;quot;Urmston&amp;quot; WORKTIME: 2 SKILLS:EXPERIENCE:essential APPLICATION:PHONE: 224 8619 CONTACT NAME: &amp;quot;Andrea&amp;quot; ORIGINAL_TEXT: &amp;quot;Urgent!!! P/T Waiters required, Urmston area. Experience essential. Phone Andrea on 224 8619.&amp;quot; The main aim of the schema is to represent in a consistent way the information which the analysis module extracts from the job ads, which the query module searches, and from which the generation module produces text. Note that the example shown in Figure 1 is rather simplified for the purposes of illustration. The schema module provides a database of job schema instances (Onyshkevych, 1990). The analysis and design phases were conducted using the OMT (Rumbaugh, 1990) objectoriented methodology. Since the system currently treats three languages (with the prospect of extension to more), we decided to codify in a languageneutral fashion the information extracted from the ads, converting equivalent linguistic terms into codes and vice versa via the analysis and generation modules described below. 3.2 Terminology The terminology module has been designed with the general aim of supporting all the common functionalities shared by the analysis, generation and query modules and of supporting a language-independent term bank to permit multilingual handling of the schema database contents. We have focused on domain-specific terms and classifications, not covering generic language issues nor providing a general lexicon and thesaurus. Different kinds of domain-specific information can be found as slot fillers, depending on the intended meaning of schema slots. The most relevant information is obviously job types. Existing job classifications have been established for example by the European Commission&apos;s Employment Service (EURES, 1989), by the ILO (ILO, 1990) and several individual companies; each provides a hierarchical classification of jobs, specifying, for each term, a distinct code, a description of the job, one or more generic 270 terms commonly used to refer to the specific job, and possibly a set of synonyms. The description of the job ranges, depending on the classification, from a quite broad one to greatly detailed ones, sometimes highlighting differences existing in different countries (e.g. according to the EURES classification, a &amp;quot;waiter&amp;quot; in some EU states is also required to act as a barman while in others is not). Job classifications therefore provide at least three different kinds of information: • Definition of recognized job types, with a (more less) precise definition of what the job is; a recognized item, as well as chef, specializing in preparing hors d&apos;oeuvres not; classifications are obviously arbitrary as long the boundary between whether a specific job is a recognized one or simply an &amp;quot;unrecognized&amp;quot; classification simply depends on the level of granularity the classifier decides to use. Classification of job types along a waiter of • Linguistic information about commonly used terms and synonyms used in a given language (or more than one) to refer to the specific term. Accordingly, job classification terms are classified, coded (i.e. a distinct code identifying the term is associated with each term) and a list of standard &amp;quot;names&amp;quot; as well as recognized synonyms is associated with them. The classification and coding schema of VDAB, one of the end-user partners in the project, is used, but extensions deriving from other schema could obviously be envisaged. Translation tables are provided for each term, containing the names used in the different languages. Alignments across different languages are kept whenever possible. Problems due to missing equivalent terms in different languages, or to slightly different meanings, are handled, at least in the first stage, simply by providing terms nearer in meaning. An example of some job titles is shown in Figure 2: the hierarchical nature of the titles, and also the existence of some synonyms, is suggested by the numbering scheme, and is more or less self-explanatory. Figure 2: Examples of job codes and names in French, Flemish and English. 91200 cuisinier * kok # cook 91202 chef # chef # chef 91205 chef de cuisine # chef-kok # chief cook 91236 cuisinier de regime # dieetkok # diet cook cuisinier de cantine # kok grootkeuken cook 91241 commis de cuisine # keukenhulp # kitchen assistant 91241 commis de cuisine # keukenpersoneel # kitchen staff 91241 commis de cuisine # keukenhulp * catering assistant 91241 aide-cuisinier # hulpkok # assistant cook 91260 second cuisinier # hulpkok # second chef Codes are used as slot fillers in the schema database. This makes the schema neutral with respect to analysis, query and generation languages. For example, when searching for a job, the classification hierarchies inherent in the terminology database allow the user to express general search constraints (e.g. looking for a job as a chef), even though indijobs are coded for specific types of chef (paspizza chef and of course in different (e.g. Although the job titles themselves provide an obvious area of terminology, we handle various other areas of vocabulary in a similar way. There are two criteria for &amp;quot;terminological status&amp;quot; in our system, either of which is sufficient: (i) hierarchical structure, and (ii) standardization. An example of &amp;quot;standardvocabulary&amp;quot; in our domain is words like fullpart-time, have an agreed meaning, or like applied to requirements such as experience, or a driving licence. Of more interest perhaps is vocabulary which can be structured, since this provides us with an opportunity to allow more sophisticated searching of the database. example is types of establishment, e.g. horestaurant, cafe, pub Although such terms do not necessarily figure in recognized terminological thesauri, it is obvious that some structure can be imposed on these terms, for example to enable a user who is looking for a job in an eating establishment to be presented with jobs in a variety of such places. Some hierarchies are trivially simple, example more interesting example is geographical location. Most job ads express the location of the work either explicitly or implicitly in the contact address. But often, these locations are the names of towns or districts, whereas a user might want to search for jobs in a wider area: a user looking for work in Flanders, for example, should be presented with jobs whose location is identified as Antwerp. This is not as simple as it seems however, since the kind of &amp;quot;knowledge&amp;quot; implicated in this kind of search facility is (literally!) &amp;quot;realworld knowledge&amp;quot; rather than linguistic knowledge: short of coding an entire gazeteer on the off-chance that some place-name appeared in a job ad, we must rather rely on the user trials envisaged later in our project to identify the extent to which geographical information needs to be included in the system. 3.3 Lexicon Not all the vocabulary that the system needs to recognize and handle can be structured in the way just described, so we recognize a second type of lexical resource which, for want of a better term, we call simply &amp;quot;the lexicon&amp;quot;. These are words which we often find in job ads, associated with specific slots, which we would like to translate if possible, but which do not have the status of terms, since they are neither structured nor standardized. Examples are adjectives used to describe suitable applicants 271 energetic, experienced), describthe location (e.g. near the seaside) the (e.g. so on. Job ads that appear in newspapers and journals can be roughly classified according to their length (short, medium, long) with slightly different lexical and syntactic features accordingly (Alexa Barcena, 1992), the details of which need not concern us here. Some of the phrases found in typijob ads serve to signal specific slots (e.g. EMseeking these linguistic items do not appear in the lexicon as such. Such elements are regarded as being properly part of the analysis and generation modules, and we describe below how they are handled there. The system design permits users offering jobs to submit via an e-mail feed job ads more or less without restrictions. The system converts these texts as far as possible into schematic representations which are then stored in the jobs database. The analysis technique that we have chosen to implement falls into the relatively new paradigm of analogyor examplebased processing. In the following paragraphs we explain the analysis process and discuss our reasons for preferring this over a more traditional string matching or parsing approach. The input that the TREE system will accept is partially structured, but with much scope for freetext input. One possible way of analysing this would be to employ a straightforward pattern-matching apsearching for &amp;quot;trigger phrases&amp;quot; such as EMseeking special processors for analysing the slot-filler portions of the text. This simple approach has certain advantages over a more complex approach based on traditional phrase-structure parsing, especially since we are not particularly interested in phrase-structure as such. Furthermore, there is a clear requirement that our analysis technique be quite robust: since the input not any way, our analysis procedure must be able to extract as much information as possible from the text, but seamlessly ignore — or at least allocate to the appropriate &amp;quot;unanalysable input&amp;quot; slot — the text which it cannot interpret. However, both these procedures can be identified as essentially &amp;quot;rule-based&amp;quot;, in the sense that linguistic data used to match, whether fixed patterns or syntactic rules, must be explicitly listed in a kind of grammar, which implies a number of disadvantages, which we will mention shortly. An alternative is suggested by the paradigm of &amp;quot;example-based&amp;quot; processing (Jones, 1996), now becoming quite prevalent in MT (Sumita et al., 1990; Somers, 1993), though in fact the techniques are very much like those of the longer established paradigm of case-based reasoning. 4.1 A flexible approach In the example-based approach, the &amp;quot;patterns&amp;quot; are listed in the form of model examples. Semi-fixed phrases are not identified as such, nor are there any explicit linguistic rules. Instead, a matcher matches new input against a database of already (correctly) analysed models, and interprets the new input on the basis of a best match (possibly out of several candidates); robustness is inherent in the system, since &amp;quot;failure&amp;quot; to analyse is relative. The main advantage of the example-based approach is that we do not need to decide beforehand what the linguistic patterns look like. To see how this works to our advantage, consider the following. Let us assume that our database of already analysed examples contains an ad which includes the followof Dutch an advantage, which is linked to a schema with slots filled roughly as follows: SKILLS:LANGUAGE:LANG:nl SKILLS:LANGUAGE:REQ:&amp;quot;an advantage&amp;quot; Now suppose we want to process ads containing the following texts: Knowledge of the English language needed. (1) Some knowledge of Spanish would be helpful. (2) good knowledge of English. In the rule-based approach, we would probably have to have a &amp;quot;rule&amp;quot; which specifies the range of (redundant) modifiers (asuming our schema does not store explicitly the level of language skill specified), that for the can be a past-participle, a predicative adjective or a noun, and are optional, and so on. Such rules carry with them a lot of baggage, such as optional elements, alternatives, restrictions and so on. The biggest baggage is that someone has to write them. In the example-based approach, we do not need to be explicit about the structure of the stored example the inputs. We need to recognize English being names of languages, but these words have &amp;quot;terminological status&amp;quot; in our system. the system does not know be helpful, will guess that it is a clarification of the language requirement, even if it may not be able to translate it. Furthermore, we can extend the &amp;quot;knowledge&amp;quot; of the system simply by adding more examples: if they contain &amp;quot;new&amp;quot; structures, the knowledge base is extended; if they mirror existing examples, the system still benefits since the evidence for one interpretation or another is thereby strengthened. 4.2 The matching algorithm The matcher, which has been developed from one first used in the MEG project (Somers et al., 1994), processes the new text in a linear fashion, having 272 first divided it into manageable portions, on the basis of punctuation, lay-out, formatting and so on. The input is tagged, using a standard tagger, e.g. (Brill, 1992). There is no need to train the tagger on our text type, because the actual tags do not matter, as long as tagging is consistent. The matching process then involves &amp;quot;sliding&amp;quot; one phrase past the other, identifying &amp;quot;strong&amp;quot; matches (word and tag) or &amp;quot;weak&amp;quot; (tag only) matches, and allowing for gaps in the match, in a method not unlike dynamic programming. The matches are then scored accordingly. The result is a set of possible matches linked to correctly filled schemas, so that even previously unseen words can normally be correctly assigned to the appropriate slot. The approach is not without its problems. For example, some slots and their fillers can be quite cf. German required vs. tall required (!), other text portions serve a dual purpose, for example when the name of the employer also indicates the location. However, the possibility of on-line or e-mail feedback to the user submitting the job ad, plus the fact that the matcher is extremely flexible, means that the analysis module can degrade gracefully in the face of such problems. 5 Query engine The query engine takes users&apos; specifications of their employment interests to identify those job ads held in the database that match their specification. Input is provided from an HTML form consisting of a number of fields which correspond to job-schema object attributes (e.g. job-title, location etc.). Data entered for any given object attribute is then encoded in the same format used to encode job ad information. Since both (searchable) job ad information and query data are represented in a languageindependent format, matches will be made regardless of the language in which the data was entered. Symbolic case-based reasoning techniques are used to quantify the extent to which users&apos; queries match database objects, allowing the &amp;quot;ranking&amp;quot; of query results. 5.1 Encoding data Input entered by the user must be encoded using the same method adopted by the analysis module. There are two means by which this can be achieved. One method is to restrict the options available to the user for any given field to a number of possible values for a given object attribute (i.e. provide the user with a Boolean choice). The alternative is to allow users to enter a string which is passed to the terminology module to retrieve the appropriate code. If the string does not return a code, it is considered invalid and the user is requested to enter an alternative. 5.2 Applying case-based reasoning User-entered information is used to construct a jobschema object which can be considered as the user&apos;s &amp;quot;ideal&amp;quot; job. Symbolic case-based reasoning techniques are then applied to quantify the difference between the user&apos;s ideal job and jobs held within the database in order to identify those jobs most closely resembling the user&apos;s ideal job. The purpose of using case-based reasoning techniques is to quantify the difference (as a metric value) between any two instances of a job-schema object. That object must be capable of being defined by one or more parameters, with the further requirement that comparison operations upon any two parameter values must yield a numeric value reflecting the semantic difference between the values. Thus, objects can be seen as being located within an n-dimensional parameter space where n is the number of defining parameters of the object. The parameters which are used to define job ads for TREE are given by the job schema definition, described above. The distance between two values for a specific parameter will be dependent upon the method of encoding but any distance function for a given parameter must define the geometric distance between its two arguments (Salzberg &amp; Cost, 1993). That is: a value must have a distance of zero to itself (4), a positive distance to all other values (5), distances must be symmetric (6) and must obey the triangle inequality (7). A further proviso is added that the maximum difference between any two parameter values must be 1, which ensures that all parameters have an equivalent maximal difference (8). (5(a, a) = 0 ,b) if a b 6(a ,b) = 6(6, a) 6(a, b) 6(b, c) &gt; 6(a, c) 6(a, &lt; 1 For example, a distance function for the job-title parameter (as represented by job-title codes illustrated in Figure 2) could be given by (9), f(la — bl) ,b) = a and job codes, (x) the number of digits of its argument, and n is the number of in the job codes (i.e. n = 5). b) to 1 if the job code arguments differ on the first digit, 0.8 if they differ on the second digit and so on. The job codes are hierarchically ordered so jobtitle codes that differ over the first digit will refer to greatly different jobs. As such we can see that this parameter distance function would reflect commonsense judgements on the associated job-titles. The total distance between any two job instances simply a measure of the distances between indi- 273 parameter distances and is given by (10), no intermediate structures are created during processing. = (10) A is the instance distance function, the function for parameter N the total of parameters by which A and deand ai and the values of parameter i for A and Equation (10) provides a measure of the total distance between two instances by summing the distances between all the constituent parameters. Using (10) and a set of parameter distance functions that conform to the properties given as (4)—(8), it is possible to quantify the difference between any jobschema instance held in the database and the &amp;quot;ideal&amp;quot; job-schema object specified by the user. Those parameters for which no value has been specified will exactly match every possible parameter value, and as such the database search is only constrained by those values which users enter. Since information on job ads is represented in a language-independent format, a search profile in one language will retrieve job ad information entered in any of languages supported. Database queries are conducted by matching the &amp;quot;ideal&amp;quot; job as specified by the user against job-schemas held in the database. The matching process yields a numeric result representing the &amp;quot;distance&amp;quot; between two objects. Identified jobs can then be ranked according to how closely they resemble the user&apos;s ideal job. The results of a database query are then fed to the generation module for subsequent presentation in the language specified by the user. Future plans include increasing the number of fields over which the search can be conducted and permitting users to specify the relative importance of each parameter to the search. The query interface will also keep a record of user &amp;quot;profiles&amp;quot;, so that regular users can repeat a previous search the next time they use the system. 6 Generation The purpose of the TREE generator module is to generate HTML documents in different languages from job database entries (i.e. filled or partially filled schemas), on demand. For several reasons, the approach to generation adopted in the TREE system can be termed &amp;quot;integrated&amp;quot;. First, it integrates canned text, templates, and grammar rules into a single grammar formalism. Second, it integrates conditions on the database with other categories in the bodies of grammar rules. Third, it integrates the generation of sentences and the generation of texts and hypertexts in a simple, seamless way. Finally, generation involves just one single, efficient process which is integrated in the sense that 6.1 Formalism In our integrated approach to generation, a grammar rule has the format (11), SSI, SS, # each i the format , the format Ci/Si , the format Here, denotes a category, denotes a semantic value, and Wi a word. The slash symbol &amp;quot;/&amp;quot; is used to separate the syntax from the semantics. The symbol &amp;quot;#&amp;quot; separates the grammar body from a set of conditions on the database. If the set of conditions is empty, the symbol &amp;quot;#&amp;quot;, and what follows it, may simply be omitted. 6.2 Canned text, templates, or grammar? Suppose a system &amp;quot;knows&amp;quot; something, on which we want it to report; suppose it knows that both the Cafe Citrus and the Red Herring Restaurant want to hire chefs, facts which could be captured by the following (logical interface to the) job database: item(e1,x1,y1). job(y1,91202). company(x1,&apos;Cafe Citrus&apos;). item(e2,x2,y2). job(y2,91202). company(x2,&apos;Red Herring Restaurant&apos;). We can imagine setting up our system in such a way that when the system sees facts of this kind, a rule such as the following — s/E --&gt; [&apos;Cafe Citrus&apos;,advertises,as,vacant,a, position,as,chef] # fitem(E,X,Y),job(Y,91202), company(X,&apos;Cafe Citrus&apos;)}. be triggered, and the system will produce the Citrus advertises as vacant a position chef. is a canned-text approach. It is trivial to implement, but the disadvantage is, of course, that we would have to store one rule for each utterance that we would like our system to produce. As soon as a sentence must be produced several times with only slight alterations, a template-based approach is more appropriate. Let us modify the above rule as follows: s/E --&gt; [advertises,as,vacant,a,position,as,chef] company(X,c)}. The following rule is needed to tell the system that it is allowed to realize the value of the feature &lt;company&gt; as the value itself (i.e. the value is the name of the company). 274 --&gt; [Name]. Thus, here too, given the above job database entry, sentence Citrus advertises as vacant a poas chef be generated. Furthermore, Herring Restaurant advertises as vacant a position chef be generated as well. It is not hard to see that the two rules above form beginning of a a grammar may be further elaborated as follows: --&gt; np/X, # {A}. --&gt; # {A}. --&gt; # {A}. --&gt; np/X. --&gt; [Name]. --&gt; [chef]. --&gt; [advertises,as,vacant,a,position,as]. Now, the above sentences, plus many other sentences, may be generated, given appropriate database entries. Our approach is based on the idea that cannedtext approaches, template-based approaches and grammar-based approaches to natural language generation — while they are often contrasted — may in fact be regarded as different points on a scale, from very specific to the very general. In a sense, templates are just generalized canned texts, and gramare just generalized templates. the possibility of combining these different modes of generation has recently been highlighted as one of the keys to efficient use of natural language generation techniques in practical applications (van Noord Neumann, 1996; Busemann, 1996). 6.3 Processing Let us now indicate how the rules are meant to be used by the generator module. Traditionally, the process of generation is divided into two steps: generation of message structure from database records (what to say), and generation of sentences from message structures (how to say it).. One way of characterizing the integrated approach to generation is to say that we go from database records to sentences in just one step. The process of computing what to say, and the process of computing how to say it, are, in the general case, interleaved processes. The process of generating from a set of grammar rules, given a particular job database entry, will simply involve picking the rules the conditions of which (best) match the entry, and using them to generate a document. 6.4 Generating hypertext The TREE system provides its output in the form approach has several advantages: first, as argued by (Reiter &amp; Mellish, 1993), the generation of hypertext can obviate the need to perform high-level text structuring, such as assembling paragraphs into documents. &amp;quot;The basic idea is to use hypertext mechanisms to enable users to dynamically select the paragraphs they wish to read, and therefore in essence perform their own high-level textplanning&amp;quot; (Reiter &amp; Mellish, 1993), p.3. Second, but related to the first point, the hypertext capabilities are also a mild form of tailoring to the needs of different users. Users are expected to explore only links containing information that they need. Hypertext is generated by means of rules that are very similar to the grammar rules described above, but are formulated on a meta-level with respect to sentence/text rules. HTML code &amp;quot;wrappers&amp;quot; can be simply generated around the text. It is fairly straightforward to extend the grammar to other HTML constructions, such as headers, styles, lists, and tables. Using such rules in combination with other rules enables us to produce simple HTML documents, or, if required, quite complex and deeply nested documents incorporating links to other ads, or buttons to expand information, or clarify terminology (e.g. to get a definition of an unfamiliar jobtitle). 7 Conclusion The European Union is a loose geo-political organization that has eleven official languages. As such, it is clear that even in a restricted domain such as that of job ads, novel approaches to Language Engineering are required. In this paper we have described an approach that summarizes ads into a base schema, and then generates output in the desired language in a principled, though restricted way. At first glance, this may look like old-fashioned interlingual MT, but there are two important differences. First, our approach is inherently &amp;quot;lossy&amp;quot;, in that not all the information in the input ad may be analysed into the schema. It cannot consequently be included in the generated output. Second, the format of the output can be controlled and customised by the user which means again that the output text is a summary or digest, not necessarily presented in the same order as the original text. For both these reasons, our system cannot be descibed as a &amp;quot;translation system&amp;quot;. Nonetheless we believe this approach is capable of giving considerable coverage at a far lower cost and higher quality than that usually associated with MT. Our approach is not without some disadvantages it is well known that a considerable quantity of the semantics of human language is culturally and socially determined. Thus, even though one can map the names of job categories from one language to another, it is not necessarily true that they mean the same thing. So for example, waiters in Spain are expected to serve snacks, whereas in Belgium they do not. There is of course no easy solution to these 275 problems from the Language Engineering point of view: our service must simply advise users to check that the job description in the target country corresponds to their understanding. Legal constraints are also a significant issue in the area of job advertising. Thus, whilst most countries in the EU have legislation to prevent race and sex discrimination in job advertising, some do not. Thus a Spanish bar can (or could until recently) adfor girls wanted as bar staff, to work in the kitchen. type of discrimination is illegal in the UK where it would violate Sex Equality Legislation. Thus we must generate non-discriminatory text to avoid running foul of UK law. This clearly shows how practical applications of Language Engineering have to conform in unforeseen ways to the real world. Our future work will continue to extend the pragmatic approach taken so far. In particular, we are being encouraged to broaden the coverage of our system to include many more employment domains. It remains to be seen what are the consequences of this scaling on what has so far proved to be a simple but effective architecture. References Alexa, Melpomeni &amp; Elena Barcena. 1992. A crosslinguistic study of the sublanguage of short job advertisements for the design of a multilingual text generation system (MEG). CCL/UMIST Re-</abstract>
<note confidence="0.885578111111111">port 92/8, Centre for Computational Linguistics, UMIST, Manchester. Brill, Eric. 1992. A simple rule-based part of speech In Conference on Applied Natural Processing, Italy, pp. 153-5. Stephan. 1996. Best-first surrealization. Computation and guage E-Print Archive cmp-lg/9605010. URL Caldwell, David E. &amp; Tatiana Korelsky. 1994. Bilingual generation of job descriptions from quaisforms. In Conference on Natural Language Processing, Germany, pp. 1-6. EURES. 1989. Communication of the comparison of vocational training qualifications between member states established in implementation of Commission Decision 85/368/EEC of 16th July 1985: and Catering Industry. Journal of European Communities 3 July 1989, pp. 1-56. Flanagan, Mary. 1996. Two years online: experichallenges and trends. In MT Horizons: Proceedings of the Second Conference of the Association for Machine Translation in the Canada, pp. 192-7. 1990. Standard Classification Occupations: ISCO-88, Labour</note>
<address confidence="0.5302985">Office, Geneva. Daniel. 1996. Natural Language Press, London. Murray, Pamela. 1989. A review of MT policy</address>
<abstract confidence="0.813619">and current commercial systems in Canada with a view to illustrating the importance of sublanguages in successful MT application. MSc dissertation, UMIST, Manchester.</abstract>
<address confidence="0.503037">Onyshkevych, Boyan. 1993. Template Design for</address>
<note confidence="0.956046">Extraction. In of the Fifth Message Understanding Conference (MUC- Md., pp. 19-23. Reiter, Ehud &amp; Chris Mellish 1993. Optimising the costs and benefits of natural language In of the 13th International Joint Conference on Artificial Intelligence, Chambery, France, pp. 1164-71. Rumbaugh, James. 1995. OMT: the Object Model. of Object-Oriented Programming, 7.8:21- 7. Salzberg, Steven &amp; Scott Cost. 1993. A weighted</note>
<abstract confidence="0.8960515">nearest neighbour algoritm for learning with symfeatures. Learning Somers, Harold L. 1993. La traduction automatique sur l&apos;exemple ou sur les corpus. In traductique: Etudes et recherches de traduction par Bouillon &amp; Andre Clas (eds),</abstract>
<note confidence="0.731407692307692">Les Presses de l&apos;Universite de Montreal, pp. 149- 66. Somers, Harold L., Ian McLean &amp; Daniel Jones. 1994. Experiments in multilingual example-based In 1994: 3rd Conference on the Cognitive Science of Natural Language Pro- Ireland. Sumita, Eiichiro, Hitoshi Iida &amp; Hideo Kameyama. 1990. Translating with examples: a new approach Machine Translation. In Third International Conference on Theoretical and Methodological Issues in Machine Translation of Natural Lan- Texas, pp. 203-12. van Noord, Gertjan &amp; Gunter Neumann. 1996. Syngeneration. In of the State of the Art Human Language Technology A. Cole, general ed.), Chapter 4 (Hans Uszkoreit, ed.). at //www. cse ogi. edu/CSLU/ be published by Cambridge University Press. Vega, Jose. 1990. Semantic matching between job and job search requests. In Papers presented to the 13th International Conferon Computational Linguistics, Finland, Vol.1 pp. 67-9. 276</note>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Melpomeni Alexa</author>
<author>Elena Barcena</author>
</authors>
<title>A crosslinguistic study of the sublanguage of short job advertisements for the design of a multilingual text generation system (MEG).</title>
<date>1992</date>
<tech>CCL/UMIST Report 92/8,</tech>
<institution>Centre for Computational Linguistics,</institution>
<location>UMIST, Manchester.</location>
<marker>Alexa, Barcena, 1992</marker>
<rawString>Alexa, Melpomeni &amp; Elena Barcena. 1992. A crosslinguistic study of the sublanguage of short job advertisements for the design of a multilingual text generation system (MEG). CCL/UMIST Report 92/8, Centre for Computational Linguistics, UMIST, Manchester.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Eric Brill</author>
</authors>
<title>A simple rule-based part of speech tagger.</title>
<date>1992</date>
<booktitle>In Third Conference on Applied Natural Language Processing,</booktitle>
<pages>153--5</pages>
<location>Trento, Italy,</location>
<contexts>
<context position="20265" citStr="Brill, 1992" startWordPosition="3321" endWordPosition="3322"> &amp;quot;knowledge&amp;quot; of the system simply by adding more examples: if they contain &amp;quot;new&amp;quot; structures, the knowledge base is extended; if they mirror existing examples, the system still benefits since the evidence for one interpretation or another is thereby strengthened. 4.2 The matching algorithm The matcher, which has been developed from one first used in the MEG project (Somers et al., 1994), processes the new text in a linear fashion, having 272 first divided it into manageable portions, on the basis of punctuation, lay-out, formatting and so on. The input is tagged, using a standard tagger, e.g. (Brill, 1992). There is no need to train the tagger on our text type, because the actual tags do not matter, as long as tagging is consistent. The matching process then involves &amp;quot;sliding&amp;quot; one phrase past the other, identifying &amp;quot;strong&amp;quot; matches (word and tag) or &amp;quot;weak&amp;quot; (tag only) matches, and allowing for gaps in the match, in a method not unlike dynamic programming. The matches are then scored accordingly. The result is a set of possible matches linked to correctly filled schemas, so that even previously unseen words can normally be correctly assigned to the appropriate slot. The approach is not without it</context>
</contexts>
<marker>Brill, 1992</marker>
<rawString>Brill, Eric. 1992. A simple rule-based part of speech tagger. In Third Conference on Applied Natural Language Processing, Trento, Italy, pp. 153-5.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Stephan Busemann</author>
</authors>
<title>Best-first surface realization.</title>
<date>1996</date>
<booktitle>Computation and Language E-Print Archive cmp-lg/9605010. URL http://xxx.lanl.gov/cmp-lg/.</booktitle>
<contexts>
<context position="31186" citStr="Busemann, 1996" startWordPosition="5162" endWordPosition="5163">ed on the idea that cannedtext approaches, template-based approaches and grammar-based approaches to natural language generation — while they are often contrasted — may in fact be regarded as different points on a scale, from the very specific to the very general. In a sense, templates are just generalized canned texts, and grammars are just generalized templates. Indeed, the possibility of combining these different modes of generation has recently been highlighted as one of the keys to efficient use of natural language generation techniques in practical applications (van Noord Neumann, 1996; Busemann, 1996). 6.3 Processing Let us now indicate how the rules are meant to be used by the generator module. Traditionally, the process of generation is divided into two steps: generation of message structure from database records (what to say), and generation of sentences from message structures (how to say it).. One way of characterizing the integrated approach to generation is to say that we go from database records to sentences in just one step. The process of computing what to say, and the process of computing how to say it, are, in the general case, interleaved processes. The process of generating f</context>
</contexts>
<marker>Busemann, 1996</marker>
<rawString>Busemann, Stephan. 1996. Best-first surface realization. Computation and Language E-Print Archive cmp-lg/9605010. URL http://xxx.lanl.gov/cmp-lg/.</rawString>
</citation>
<citation valid="true">
<authors>
<author>David E Caldwell</author>
<author>Tatiana Korelsky</author>
</authors>
<title>Bilingual generation of job descriptions from quaisconceptual forms.</title>
<date>1994</date>
<booktitle>In Fourth Conference on Applied Natural Language Processing,</booktitle>
<pages>1--6</pages>
<location>Stuttgart, Germany,</location>
<marker>Caldwell, Korelsky, 1994</marker>
<rawString>Caldwell, David E. &amp; Tatiana Korelsky. 1994. Bilingual generation of job descriptions from quaisconceptual forms. In Fourth Conference on Applied Natural Language Processing, Stuttgart, Germany, pp. 1-6.</rawString>
</citation>
<citation valid="true">
<authors>
<author>EURES</author>
</authors>
<title>Communication of the comparison of vocational training qualifications between member states established in implementation of Commission Decision</title>
<date>1989</date>
<journal>Official Journal of the European Communities</journal>
<booktitle>85/368/EEC of 16th</booktitle>
<volume>32</volume>
<pages>1--56</pages>
<contexts>
<context position="8979" citStr="EURES, 1989" startWordPosition="1454" endWordPosition="1455"> the analysis, generation and query modules and of supporting a language-independent term bank to permit multilingual handling of the schema database contents. We have focused on domain-specific terms and classifications, not covering generic language issues nor providing a general lexicon and thesaurus. Different kinds of domain-specific information can be found as slot fillers, depending on the intended meaning of schema slots. The most relevant information is obviously job types. Existing job classifications have been established for example by the European Commission&apos;s Employment Service (EURES, 1989), by the ILO (ILO, 1990) and several individual companies; each provides a hierarchical classification of jobs, specifying, for each term, a distinct code, a description of the job, one or more generic 270 terms commonly used to refer to the specific job, and possibly a set of synonyms. The description of the job ranges, depending on the classification, from a quite broad one to greatly detailed ones, sometimes highlighting differences existing in different countries (e.g. according to the EURES classification, a &amp;quot;waiter&amp;quot; in some EU states is also required to act as a barman while in others is</context>
</contexts>
<marker>EURES, 1989</marker>
<rawString>EURES. 1989. Communication of the comparison of vocational training qualifications between member states established in implementation of Commission Decision 85/368/EEC of 16th July 1985: Hotel and Catering Industry. Official Journal of the European Communities 32, C166, 3 July 1989, pp. 1-56.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Mary Flanagan</author>
</authors>
<title>Two years online: experiences, challenges and trends.</title>
<date>1996</date>
<booktitle>In Expanding MT Horizons: Proceedings of the Second Conference of the Association for Machine Translation in the Americas,</booktitle>
<pages>pp.</pages>
<location>Montreal, Canada,</location>
<contexts>
<context position="3021" citStr="Flanagan, 1996" startWordPosition="464" endWordPosition="465">; Caldwell Sz Korelsky, 1994). But no other application — as far as we can discover — offers the opportunity of searching and of getting summaries of job ads in languages other than that of the original announcement. TREE therefore offers two significant services: intelligent search and summarization on the one hand, and these independent of the original language of the job ad on the other. It could be argued that the latter at least could be achieved by hooking a commercial Machine Translation (MT) system up to an Internet employment service. Although MT has had some success on the Internet (Flanagan, 1996), this is with largely sympathetic users who understand well the limitations of MT. Its use for a more delicate task aimed at the general public, especially a public which is not necessarily highly educated, is certainly out of the question, for well known reasons which we need not explore here. Suffice to say that an experiment in Canada using an MT system for precisely this application (Murray, 1989) was far from successful. It is also apparent that for many jobs in a location where a different language is spoken, sufficient linguistic knowledge at least to read an ad for a job in that regio</context>
</contexts>
<marker>Flanagan, 1996</marker>
<rawString>Flanagan, Mary. 1996. Two years online: experiences, challenges and trends. In Expanding MT Horizons: Proceedings of the Second Conference of the Association for Machine Translation in the Americas, Montreal, Canada, pp. 192-7.</rawString>
</citation>
<citation valid="true">
<authors>
<author>ILO</author>
</authors>
<title>International Standard Classification of Occupations:</title>
<date>1990</date>
<booktitle>ISCO-88, International Labour Office,</booktitle>
<location>Geneva.</location>
<contexts>
<context position="9003" citStr="ILO, 1990" startWordPosition="1459" endWordPosition="1460">and query modules and of supporting a language-independent term bank to permit multilingual handling of the schema database contents. We have focused on domain-specific terms and classifications, not covering generic language issues nor providing a general lexicon and thesaurus. Different kinds of domain-specific information can be found as slot fillers, depending on the intended meaning of schema slots. The most relevant information is obviously job types. Existing job classifications have been established for example by the European Commission&apos;s Employment Service (EURES, 1989), by the ILO (ILO, 1990) and several individual companies; each provides a hierarchical classification of jobs, specifying, for each term, a distinct code, a description of the job, one or more generic 270 terms commonly used to refer to the specific job, and possibly a set of synonyms. The description of the job ranges, depending on the classification, from a quite broad one to greatly detailed ones, sometimes highlighting differences existing in different countries (e.g. according to the EURES classification, a &amp;quot;waiter&amp;quot; in some EU states is also required to act as a barman while in others is not). Job classificatio</context>
</contexts>
<marker>ILO, 1990</marker>
<rawString>ILO. 1990. International Standard Classification of Occupations: ISCO-88, International Labour Office, Geneva.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Daniel Jones</author>
</authors>
<title>Analogical Natural Language Processing,</title>
<date>1996</date>
<publisher>UCL Press,</publisher>
<location>London.</location>
<contexts>
<context position="17392" citStr="Jones, 1996" startWordPosition="2844" endWordPosition="2845"> in any way, our analysis procedure must be able to extract as much information as possible from the text, but seamlessly ignore — or at least allocate to the appropriate &amp;quot;unanalysable input&amp;quot; slot — the text which it cannot interpret. However, both these procedures can be identified as essentially &amp;quot;rule-based&amp;quot;, in the sense that linguistic data used to match, whether fixed patterns or syntactic rules, must be explicitly listed in a kind of grammar, which implies a number of disadvantages, which we will mention shortly. An alternative is suggested by the paradigm of &amp;quot;example-based&amp;quot; processing (Jones, 1996), now becoming quite prevalent in MT (Sumita et al., 1990; Somers, 1993), though in fact the techniques are very much like those of the longer established paradigm of case-based reasoning. 4.1 A flexible approach In the example-based approach, the &amp;quot;patterns&amp;quot; are listed in the form of model examples. Semi-fixed phrases are not identified as such, nor are there any explicit linguistic rules. Instead, a matcher matches new input against a database of already (correctly) analysed models, and interprets the new input on the basis of a best match (possibly out of several candidates); robustness is i</context>
</contexts>
<marker>Jones, 1996</marker>
<rawString>Jones, Daniel. 1996. Analogical Natural Language Processing, UCL Press, London.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Pamela Murray</author>
</authors>
<title>A review of MT policy and current commercial systems in Canada with a view to illustrating the importance of sublanguages in successful MT application. MSc dissertation, UMIST,</title>
<date>1989</date>
<location>Manchester.</location>
<contexts>
<context position="3426" citStr="Murray, 1989" startWordPosition="534" endWordPosition="535">rgued that the latter at least could be achieved by hooking a commercial Machine Translation (MT) system up to an Internet employment service. Although MT has had some success on the Internet (Flanagan, 1996), this is with largely sympathetic users who understand well the limitations of MT. Its use for a more delicate task aimed at the general public, especially a public which is not necessarily highly educated, is certainly out of the question, for well known reasons which we need not explore here. Suffice to say that an experiment in Canada using an MT system for precisely this application (Murray, 1989) was far from successful. It is also apparent that for many jobs in a location where a different language is spoken, sufficient linguistic knowledge at least to read an ad for a job in that region would be one of the prerequisites of the job: this is certainly the case for the kind of professional positions often advertised on the Internet. Nevertheless, our system offers users the possibility of searching in their own language for jobs advertised in a variety of languages. Also, there is a significant workforce for which foreign-language skills are not a prerequisite for working abroad, and w</context>
</contexts>
<marker>Murray, 1989</marker>
<rawString>Murray, Pamela. 1989. A review of MT policy and current commercial systems in Canada with a view to illustrating the importance of sublanguages in successful MT application. MSc dissertation, UMIST, Manchester.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Boyan Onyshkevych</author>
</authors>
<title>Template Design for Information Extraction.</title>
<date>1993</date>
<booktitle>In Proceedings of the Fifth Message Understanding Conference (MUC5),</booktitle>
<pages>pp.</pages>
<location>Baltimore, Md.,</location>
<marker>Onyshkevych, 1993</marker>
<rawString>Onyshkevych, Boyan. 1993. Template Design for Information Extraction. In Proceedings of the Fifth Message Understanding Conference (MUC5), Baltimore, Md., pp. 19-23.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ehud Reiter</author>
<author>Chris Mellish</author>
</authors>
<title>Optimising the costs and benefits of natural language generation.</title>
<date>1993</date>
<booktitle>In Proceedings of the 13th International Joint Conference on Artificial Intelligence,</booktitle>
<pages>1164--71</pages>
<location>Chambery, France,</location>
<contexts>
<context position="32147" citStr="Reiter &amp; Mellish, 1993" startWordPosition="5325" endWordPosition="5328">grated approach to generation is to say that we go from database records to sentences in just one step. The process of computing what to say, and the process of computing how to say it, are, in the general case, interleaved processes. The process of generating from a set of grammar rules, given a particular job database entry, will simply involve picking the rules the conditions of which (best) match the entry, and using them to generate a document. 6.4 Generating hypertext The TREE system provides its output in the form of hypertext. This approach has several advantages: first, as argued by (Reiter &amp; Mellish, 1993), the generation of hypertext can obviate the need to perform high-level text structuring, such as assembling paragraphs into documents. &amp;quot;The basic idea is to use hypertext mechanisms to enable users to dynamically select the paragraphs they wish to read, and therefore in essence perform their own high-level textplanning&amp;quot; (Reiter &amp; Mellish, 1993), p.3. Second, but related to the first point, the hypertext capabilities are also a mild form of tailoring to the needs of different users. Users are expected to explore only links containing information that they need. Hypertext is generated by means</context>
</contexts>
<marker>Reiter, Mellish, 1993</marker>
<rawString>Reiter, Ehud &amp; Chris Mellish 1993. Optimising the costs and benefits of natural language generation. In Proceedings of the 13th International Joint Conference on Artificial Intelligence, Chambery, France, pp. 1164-71.</rawString>
</citation>
<citation valid="true">
<authors>
<author>James Rumbaugh</author>
</authors>
<title>OMT: the Object Model.</title>
<date>1995</date>
<journal>Journal of Object-Oriented Programming,</journal>
<pages>7--8</pages>
<marker>Rumbaugh, 1995</marker>
<rawString>Rumbaugh, James. 1995. OMT: the Object Model. Journal of Object-Oriented Programming, 7.8:21-7.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Steven Salzberg</author>
<author>Scott Cost</author>
</authors>
<title>A weighted nearest neighbour algoritm for learning with symbolic features.</title>
<date>1993</date>
<journal>Machine Learning</journal>
<pages>10--57</pages>
<contexts>
<context position="23986" citStr="Salzberg &amp; Cost, 1993" startWordPosition="3943" endWordPosition="3946">arison operations upon any two parameter values must yield a numeric value reflecting the semantic difference between the values. Thus, objects can be seen as being located within an n-dimensional parameter space where n is the number of defining parameters of the object. The parameters which are used to define job ads for TREE are given by the job schema definition, described above. The distance between two values for a specific parameter will be dependent upon the method of encoding but any distance function for a given parameter must define the geometric distance between its two arguments (Salzberg &amp; Cost, 1993). That is: a value must have a distance of zero to itself (4), a positive distance to all other values (5), distances must be symmetric (6) and must obey the triangle inequality (7). A further proviso is added that the maximum difference between any two parameter values must be 1, which ensures that all parameters have an equivalent maximal difference (8). (5(a, a) = 0 6(a ,b) &gt;0 if a 0 b 6(a ,b) = 6(6, a) 6(a, b) 6(b, c) &gt; 6(a, c) 6(a, &lt; 1 For example, a distance function for the job-title parameter (as represented by job-title codes illustrated in Figure 2) could be given by (9), f(la — bl) </context>
</contexts>
<marker>Salzberg, Cost, 1993</marker>
<rawString>Salzberg, Steven &amp; Scott Cost. 1993. A weighted nearest neighbour algoritm for learning with symbolic features. Machine Learning 10:57-78.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Harold L Somers</author>
</authors>
<title>La traduction automatique ba,see sur l&apos;exemple ou sur les corpus. In La traductique: Etudes et recherches de traduction par ordinateur,</title>
<date>1993</date>
<booktitle>Pierrette Bouillon &amp; Andre Clas (eds), Les Presses de l&apos;Universite de Montreal,</booktitle>
<pages>149--66</pages>
<contexts>
<context position="17464" citStr="Somers, 1993" startWordPosition="2856" endWordPosition="2857">ormation as possible from the text, but seamlessly ignore — or at least allocate to the appropriate &amp;quot;unanalysable input&amp;quot; slot — the text which it cannot interpret. However, both these procedures can be identified as essentially &amp;quot;rule-based&amp;quot;, in the sense that linguistic data used to match, whether fixed patterns or syntactic rules, must be explicitly listed in a kind of grammar, which implies a number of disadvantages, which we will mention shortly. An alternative is suggested by the paradigm of &amp;quot;example-based&amp;quot; processing (Jones, 1996), now becoming quite prevalent in MT (Sumita et al., 1990; Somers, 1993), though in fact the techniques are very much like those of the longer established paradigm of case-based reasoning. 4.1 A flexible approach In the example-based approach, the &amp;quot;patterns&amp;quot; are listed in the form of model examples. Semi-fixed phrases are not identified as such, nor are there any explicit linguistic rules. Instead, a matcher matches new input against a database of already (correctly) analysed models, and interprets the new input on the basis of a best match (possibly out of several candidates); robustness is inherent in the system, since &amp;quot;failure&amp;quot; to analyse is relative. The main </context>
</contexts>
<marker>Somers, 1993</marker>
<rawString>Somers, Harold L. 1993. La traduction automatique ba,see sur l&apos;exemple ou sur les corpus. In La traductique: Etudes et recherches de traduction par ordinateur, Pierrette Bouillon &amp; Andre Clas (eds), Les Presses de l&apos;Universite de Montreal, pp. 149-66.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Harold L Somers</author>
<author>Ian McLean</author>
<author>Daniel Jones</author>
</authors>
<title>Experiments in multilingual example-based generation.</title>
<date>1994</date>
<booktitle>In CSNLP 1994: 3rd Conference on the Cognitive Science of Natural Language Processing,</booktitle>
<location>Dublin, Ireland.</location>
<contexts>
<context position="20041" citStr="Somers et al., 1994" startWordPosition="3281" endWordPosition="3284">ve &amp;quot;terminological status&amp;quot; in our system. If the system does not know would be helpful, it will guess that it is a clarification of the language requirement, even if it may not be able to translate it. Furthermore, we can extend the &amp;quot;knowledge&amp;quot; of the system simply by adding more examples: if they contain &amp;quot;new&amp;quot; structures, the knowledge base is extended; if they mirror existing examples, the system still benefits since the evidence for one interpretation or another is thereby strengthened. 4.2 The matching algorithm The matcher, which has been developed from one first used in the MEG project (Somers et al., 1994), processes the new text in a linear fashion, having 272 first divided it into manageable portions, on the basis of punctuation, lay-out, formatting and so on. The input is tagged, using a standard tagger, e.g. (Brill, 1992). There is no need to train the tagger on our text type, because the actual tags do not matter, as long as tagging is consistent. The matching process then involves &amp;quot;sliding&amp;quot; one phrase past the other, identifying &amp;quot;strong&amp;quot; matches (word and tag) or &amp;quot;weak&amp;quot; (tag only) matches, and allowing for gaps in the match, in a method not unlike dynamic programming. The matches are then</context>
</contexts>
<marker>Somers, McLean, Jones, 1994</marker>
<rawString>Somers, Harold L., Ian McLean &amp; Daniel Jones. 1994. Experiments in multilingual example-based generation. In CSNLP 1994: 3rd Conference on the Cognitive Science of Natural Language Processing, Dublin, Ireland.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Eiichiro Sumita</author>
<author>Hitoshi Iida</author>
<author>Hideo Kameyama</author>
</authors>
<title>Translating with examples: a new approach to Machine Translation.</title>
<date>1990</date>
<booktitle>In The Third International Conference on Theoretical and Methodological Issues in Machine Translation of Natural Language,</booktitle>
<pages>203--12</pages>
<location>Austin, Texas,</location>
<contexts>
<context position="17449" citStr="Sumita et al., 1990" startWordPosition="2852" endWordPosition="2855">o extract as much information as possible from the text, but seamlessly ignore — or at least allocate to the appropriate &amp;quot;unanalysable input&amp;quot; slot — the text which it cannot interpret. However, both these procedures can be identified as essentially &amp;quot;rule-based&amp;quot;, in the sense that linguistic data used to match, whether fixed patterns or syntactic rules, must be explicitly listed in a kind of grammar, which implies a number of disadvantages, which we will mention shortly. An alternative is suggested by the paradigm of &amp;quot;example-based&amp;quot; processing (Jones, 1996), now becoming quite prevalent in MT (Sumita et al., 1990; Somers, 1993), though in fact the techniques are very much like those of the longer established paradigm of case-based reasoning. 4.1 A flexible approach In the example-based approach, the &amp;quot;patterns&amp;quot; are listed in the form of model examples. Semi-fixed phrases are not identified as such, nor are there any explicit linguistic rules. Instead, a matcher matches new input against a database of already (correctly) analysed models, and interprets the new input on the basis of a best match (possibly out of several candidates); robustness is inherent in the system, since &amp;quot;failure&amp;quot; to analyse is rela</context>
</contexts>
<marker>Sumita, Iida, Kameyama, 1990</marker>
<rawString>Sumita, Eiichiro, Hitoshi Iida &amp; Hideo Kameyama. 1990. Translating with examples: a new approach to Machine Translation. In The Third International Conference on Theoretical and Methodological Issues in Machine Translation of Natural Language, Austin, Texas, pp. 203-12.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Gertjan van Noord</author>
<author>Gunter Neumann</author>
</authors>
<title>Syntactic generation.</title>
<date>1996</date>
<journal>Chapter</journal>
<booktitle>In Survey of the State of the Art in Human Language Technology</booktitle>
<volume>4</volume>
<editor>(Ronald A. Cole, general ed.),</editor>
<publisher>University Press.</publisher>
<marker>van Noord, Neumann, 1996</marker>
<rawString>van Noord, Gertjan &amp; Gunter Neumann. 1996. Syntactic generation. In Survey of the State of the Art in Human Language Technology (Ronald A. Cole, general ed.), Chapter 4 (Hans Uszkoreit, ed.). Available at http: //www. cse ogi. edu/CSLU/ HLTsurvey/ch4node4.html#SECTION42. To be published by Cambridge University Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jose Vega</author>
</authors>
<title>Semantic matching between job offers and job search requests.</title>
<date>1990</date>
<booktitle>In COLING-90: Papers presented to the 13th International Conference on Computational Linguistics,</booktitle>
<pages>67--9</pages>
<location>Helsinki, Finland, Vol.1</location>
<contexts>
<context position="2406" citStr="Vega, 1990" startWordPosition="360" endWordPosition="361">. We would like to express our thanks to other partners on the project: Edy Geerts and Marianne Kamoen (VDAB, Vlaamse Dienst voor Arbeidsbemiddeling en Beroepsopleiding), Mick Riley (Newcastle upon Tyne City Council), and Teresa Paskiewicz and Mark Stairmand (UMIST). The URL for the project&apos;s web site is http://wvw.mari.co.uk/tree/. Joakim Nivre, Torbjarn Lager SSKKII, University of Goteborg, Sweden Jeremy Ellman, Alex Rogers MARI Computer Systems Ltd, Ashington, Northumberland, England techniques next to natural language processing to search job offer databases is not a new application, cf. (Vega, 1990; Caldwell Sz Korelsky, 1994). But no other application — as far as we can discover — offers the opportunity of searching and of getting summaries of job ads in languages other than that of the original announcement. TREE therefore offers two significant services: intelligent search and summarization on the one hand, and these independent of the original language of the job ad on the other. It could be argued that the latter at least could be achieved by hooking a commercial Machine Translation (MT) system up to an Internet employment service. Although MT has had some success on the Internet (</context>
</contexts>
<marker>Vega, 1990</marker>
<rawString>Vega, Jose. 1990. Semantic matching between job offers and job search requests. In COLING-90: Papers presented to the 13th International Conference on Computational Linguistics, Helsinki, Finland, Vol.1 pp. 67-9.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>