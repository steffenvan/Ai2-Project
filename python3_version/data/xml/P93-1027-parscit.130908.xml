<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<note confidence="0.63502725">
ON THE DECIDABILITY OF FUNCTIONAL UNCERTAINTY*
Rolf Backofen
German Research Center for Artificial Intelligence (DFKI)
W-6600 Saarbriicken, Germany
</note>
<email confidence="0.849621">
backofen@dfki.uni-sb.de
</email>
<sectionHeader confidence="0.992186" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999522444444444">
We show that feature logic extended by functional
uncertainty is decidable, even if one admits cyclic
descriptions. We present an algorithm, which
solves feature descriptions containing functional un-
certainty in two phases, both phases using a set of de-
terministic and non-deterministic rewrite rules. We
then compare our algorithm with the one of Kaplan
and Maxwell, that does not cover cyclic feature de-
scriptions.
</bodyText>
<sectionHeader confidence="0.99906" genericHeader="introduction">
1 Introduction
</sectionHeader>
<bodyText confidence="0.995596106666667">
Feature logic is the main device of unification gram-
mars, the currently predominant paradigm in com-
putational linguistics. More recently, feature de-
scriptions have been proposed as a constraint system
for logic programming (e.g. see [11]). They provide
for partial descriptions of abstract objects by means
of functional attributes called features.
Formalizations of feature logic have been proposed
in various forms (for more details see [3] in this vol-
ume). We will follow the logical approach intro-
duced by Smolka [9, 10], where feature descriptions
are standard first order formulae interpreted in first
order structures. In this formalization features are
considered as functional relations. Atomic formulae
(which we will call atomic constraints) are of either
the form A(x) or xfy, where z, y are first order vari-
ables, A is some sort predicate and f is a feature
(written in infix notation). The constraints of the
form x fy can be generalized to constraints of the
form xwy, where w = fn is a finite feature path.
This does not affect the computational properties.
In this paper we will be concerned with an ex-
tension to feature descriptions, which has been in-
troduced as &amp;quot;functional uncertainty&amp;quot; by Kaplan and
Zaenen [7] and Kaplan and Maxwell [5]. This for-
mal device plays an important role in the framework
of LFG in modelling so-called long distance depen-
dencies and constituent coordination. For a detailed
linguistic motivation see [7], [6] and [5]; a more gen-
eral use of functional uncertainty can be found in [8].
Functional uncertainty consists of constraints of
*This work was supported by a research grant,
ITW 9002 0, from the German Bundesministerium fiir
Forschung und Technologie to the DFKI project DISCO.
I would like to thank Jochen Done, Joachim Niehren and
Ralf Treinen for reading draft version of this paper. For
space limitations most of the proofs are omitted; they
can be found in the complete paper [2]
the form xLy, where L is a finite description of
a regular language of feature paths. A constraint
xLy holds if there is a path w E L such that zwy
holds. Under this existential interpretation, a con-
straint xLy can be seen as the disjunction
xLy = V Ixwy I w E Ll.
Certainly, this disjunction may be infinite, thus
functional uncertainty yields additional expressivity.
Note that a constraint xwy is a special case of a func-
tional uncertainty constraint.
To see some possible application of functional un-
certainty we briefly recall an example that is given in
Kaplan and Maxwell [5, page 1]. Consider the top-
icalized sentence Mary John telephoned yesterday.
Using s as a variable denoting the whole sentence,
the LFG-like clause s topic x A s obj x specifies that
in s Mary should be interpreted as the object of the
relation telephoned. The sentence could be extended
by introducing additional complement predicates, as
e.g. in sentences like Mary John claimed that Bill
telephoned; Mary John claimed that Bill said that
... Henry telephoned yesterday; .... For this fam-
ily of sentences the clauses s topic x A s comp obj x,
s topic x A s comp comp obj x and so on would be ap-
propriate; specifying all possibilities would yield an
infinite disjunction. This changes if we make use of
functional uncertainty allowing to specify the above
as the single clause s topic x A s comp* obj x.
Kaplan and Maxwell [5] have shown that consis-
tency of feature descriptions is decidable, provided
that a certain acyclicity condition is met. More re-
cently, Baader et al. [1] have proven, that consistency
is not decidable if we add negation. But it is an open
problem whether consistency of feature descriptions
without negation and without additional restrictions
(such as acyclicity) is decidable. In the work pre-
sented here we show that it indeed is decidable.
</bodyText>
<sectionHeader confidence="0.990638" genericHeader="method">
2 The Method
</sectionHeader>
<bodyText confidence="0.9999468">
We will first briefly describe the main part of solving
the standard feature terms and then turn to their
extension with functional uncertainty.
Consider a clause 0 = xpiyi A xp2y2 (from now on
we will refer to pure conjunctive formulae as clauses).
A standard method for solving feature terms would
rewrite 0 in order to achieve a solved form. This
rewriting depends on the paths pi and p2. If pi
equals p2, we know that yl and y2 must be equal.
This implies that 0 is equivalent to xpiylAyi = y2. If
</bodyText>
<page confidence="0.996547">
201
</page>
<bodyText confidence="0.999589507692308">
P1 is a prefix of p2 and hence P2 = Pip&apos;, we can trans-
form 0 equivalently into the formulae xpiyi A y1p&apos;y2.
The reverse case is treated in a similar fashion. If
neither prefix or equality holds between the paths,
there is nothing to be done. By and large, clauses
where this holds for every x and every pair of differ-
ent constraints xpiy and xp2z are the solved forms
in Smolka [9], which are consistent.
If we consider a clause of the form 0 = xLlyi A
2L2y2, then we again have to check the relation be-
tween yi and y2. But now there is in general no
unique relation determined by 0, since this depends
on which paths pi and p2 we choose out of Li and
L2. Hence, we have to guess the relation between pi
and p2 before we can calculate the relation between
yi and y2. However, there is a problem with the
original syntax, namely that it does not allow one to
express any relation between the chosen paths (in a
later section we will compare our algorithm to the
one of Kaplan/Maxwell, thus showing where exactly
the problem occurs in their syntax). Therefore, we
extend the syntax by introducing so-called path vari-
ables (written a, fl, a&apos;, ...), which are interpreted as
feature paths (we will call the other variables first
order variables). Hence, if we use the modified sub-
term relation xay and a restriction constraint a e L,
a constraint xLy can equivalently be expressed as
xay A aeL (a new). The interpretation of xay is
done in two steps. Given a valuation 14 of the path
variables as feature paths, a constraint xay in 0 is
substituted by xVp(a)y. This constraint is then in-
terpreted using the valuation for the first order vari-
ables in the way such constraints are usually inter-
preted.
By using this extended (two-sorted) syntax we are
now able to reason about the relations between dif-
ferent path variables. In doing so, we introduce ad-
ditional constraints a =. 13 (equality), a -&amp;quot;‹ fl (prefix)
and a ñ [3 (divergence). Divergence holds if neither
equality nor prefix holds. Now we can describe a nor-
mal form equivalent to the solved clauses in Smolka&apos;s
work, which we will call pre-solved clauses. A clause
0 is pre-solved if for each pair of different constraint
xayi and xi3y2 in 0 there is a constraint a U in 0.
We call this clauses pre-solved, since such clauses are
not necessarily consistent. It may happen, that the
divergence constraints together with the restrictions
of form a e L are inconsistent (e.g. think of the clause
e f+Afleff+ A a it )3). But pre-solved clauses
have the property, that if we find a valuation for the
path variables, then the clause is consistent.
Our algorithm first transforms a clause into a set
of pre-solved clauses, which is (seen as a disjunction)
equivalent to the initial clause. In a second phase the
pre-solved clauses are checked for consistency with
respect to the path variables. In this paper we will
concentrate on the first phase, since it is the more
difficult one.
Before looking at the technical part we will illus-
trate the first phase. For the rest of the paper we
will write clauses as sets of atomic constraints. Now
consider the clause 7 = {xay, ai e Li, xflz, fle L2}.
The first step is to guess the relation between the
path variables a and #. Therefore, 7 can be ex-
pressed equivalently by the set of clauses
</bodyText>
<equation confidence="0.996043">
71 = {anig) U7 73 = {a /3} U7
72 ={a=,e} U 74 = a} U
</equation>
<bodyText confidence="0.992334909090909">
The clause 71 is pre-solved. For the others we have
to evaluate the relation between a and )3, which is
done as follows. For 72 we substitute 13 by a and z
by y, which yields
{y z, xay, aeLi, aeL2}.
We keep only the equality constraint for the first or-
der variables, since we are only interested in their val-
uation. Combining {a e Li, a e L2} to la e (Li fl L2)}
then will give us the equivalent pre-solved clause
-6= {y z, xay, a e (Li nL2)}•
For 73 we know that the variable /3 can be split
into two parts, one of them covered by a. We can
use concatenation of path variables to express this,
i.e. we can replace ,3 by the term a.0&apos;, where /3&apos; is
new. Thus we get the clause
= {xay, aèLi, yfliz, a.)3&apos;eL2},
The only thing that we have to do additionally in
order to achieve a pre-solved clause is to resolve the
constraint a.fi&apos;&apos; e L2. To do this we have to guess a
so-called decomposition P,S of L2 with P.S C L2
such that a e P and e S. In general, there can be
an infinite number of decompositions (think of the
possible decompositions of the language rg). But
as we use regular languages, there is a finite set of
regular decompositions covering all possibilities. Fi-
nally, reducing {a e Li, ae P} to {a e (L1 n P)) will
yield a pre-solved clause.
Note that the evaluation of the prefix relation in
73 has the additional effect of introducing a new con-
straint y131z. This implies that there again may be
some path variables the relation of which is unknown.
Hence, after reducing the terms of form a /3 or
13 we may have to repeat the non-deterministic
choice of relations between path variables. In the
end, the only remaining constraints between path
variables will be of the form a 11/3.
We have to consider some additional point, namely
that the rules we present will (naturally) loop in some
cases. Roughly speaking, one can say that this al-
ways occurs if a cycle in the graph coincides with
a cycle in the regular language. To see this let us
vary the above example and let 7 now be the clause
{xax, a e f, xflz, gef*g}. Then a possible looping
derivation could be
</bodyText>
<listItem confidence="0.918518">
1. add a :&lt;
xax, aef, xi3z, fiery}
2. split 13 into a-fl&apos;:
{xax, aef, xifz, cr-giefig}
3. decompose a-fi&apos;&apos; ef*g:
</listItem>
<bodyText confidence="0.343351">
{xax, ae f, xiYz, aef*, [3&apos; erg}
</bodyText>
<page confidence="0.988422">
202
</page>
<sectionHeader confidence="0.711969" genericHeader="method">
4. join a-restrictions:
</sectionHeader>
<bodyText confidence="0.987213642857143">
{xax, ae f, x,31z, #1 erg}
However, we will proof that the rule system is
quasi-terminating, which means that the rule system
may cycle, but produces only finitely many different
clauses (see [4]). This means that checking for cyclic
derivations will give us an effective algorithm.
Quasi-termination is achieved by the following
measures: first we will guarantee that the rules do
not introduce additional variables; second we restrict
concatenation to length 2; and third we will show
that the rules system produces only finitely many
regular languages. In order to show that our rewrite
system is complete, we also have to show that every
solution can be found in a pre-solved clause.
</bodyText>
<sectionHeader confidence="0.998485" genericHeader="method">
3 Preliminaries
</sectionHeader>
<bodyText confidence="0.952637272727273">
Our signature consists of a set of sorts S (A, B, .),
first order variables X (x, y, .), path variables P
(a, 13, . . .) and features F (f, g, . ..). We will assume
a finite set of features and infinite sets of variables
and sorts. A path is a finite string of features. A
path u is a prefix of a path v (written u -&lt; v) if there
is a non-empty path w such that v = uw. Note that
-&lt; is neither symmetric nor reflexive. Two paths u, v
diverge (written u u v) if there are features f,g with
I g and possibly empty paths w, w1, w2 such that
u = wfwi A v = wgw2. Clearly, u is a symmetric
relation.
Proposition 3.1 Given two paths u and v, then ex-
actly one of the relations u = v, u -&lt; v, u ›- v or u u v
holds.
A path term (p, q,...) is either a path variable a or
a concatenation of path variables a•fl. We will allow
complex path terms only in divergence constraints
and not in prefix or equality constraints. Hence, the
set of atomic constraints is given by
Ax sort restriction
y agreement
</bodyText>
<listItem confidence="0.756924">
• • • 4. Y subterm agreement I
</listItem>
<bodyText confidence="0.89675252631579">
xay subterm agreement 2
pe L path restriction
p q divergence
prefix
a=/3 path equality
We exclude empty paths in subterm agreement since
xey is equivalent to x = y. Therefore, we require
h.- • • • -fn E .P4- and L C F.
A clause is a finite set of atomic constraint de-
noting their conjunction. We will say that a path
term a•f3 is contained (or used) in some clause 0 if
0 contains either a constraint a-f3 e L or a constraint
a•fi ii g.1 Constraints of the form pe L, pU q,
and a will be called path constraints.
An interpretation I is a standard first order struc-
ture, where every feature f E F is interpreted as a bi-
nary, functional relation Fx and where sort symbols
We will not differentiate between p ii g and q it p.
are interpreted as unary, disjoint predicates (hence
</bodyText>
<listItem confidence="0.93913">
• fl = 0 for A 0 B). A valuation is a pair
</listItem>
<bodyText confidence="0.972136666666667">
(Vx, 14), where Vx is a standard first order valu-
ation of the variables in X and Vp is a function
Vp :P—+F. We define Vp(a.(3) to be Vp (a)Vp(t3),
The validity of an atomic constraint in an inter-
pretation I under a valuation (Vx, Vp) is defined as
follows:
</bodyText>
<table confidence="0.7807693">
(Vs ,Vp) J=j Ax : Vx(x)E
(Vi, Vp) kr X y Vs (x) = Vs (y)
(Vx, VP) kz- x P Vx(x) FY- o o Vx(Y)
: •:==&gt;
(Vx, xay (Vs Vp) x Vp(a)
:
(Vs, Vp) p e L : &lt;==&gt; VP(P) E L
(Vx , Vp) p g VP (P) 0 VP (q)
for O E
:==
</table>
<bodyText confidence="0.982615363636363">
where p is the path fi• .• fr, and Fi/ are the inter-
pretations of fi in I.
For a set C X we define =c to be the following
relation on first order valuation:
VX =fVk iff Vx E : Vx(z) = q(x).
Similarly, we define =„ with ir C P for path valua-
tions. Let t9 c xur be a set of variables. For a given
interpretation I we say that a valuation (Vx, Vp) is
a 19-solution of a clause 0 in I if there is a valuation
(Vk, 4) in 1 such that Vx =xno q, vp
and (Vi, 0. The set of all 9-solutions of 0 in
</bodyText>
<listItem confidence="0.900165">
• is denoted by( [0],i. We will call X-solutions just
</listItem>
<bodyText confidence="0.819531833333333">
solutions and write NY instead of 1[0]Fx.
For checking satisfiability we will use transfor-
mation rules. A rule R is 19-sound 4) --qt 7
D Hi for every interpretation I. R is called
t3-preserving if 0 -y log c R is globally
19-preserving if [013.c U Flo/.
</bodyText>
<sectionHeader confidence="0.990987" genericHeader="method">
4 The First Phase
</sectionHeader>
<subsectionHeader confidence="0.998014">
4.1 A Set of Rules
</subsectionHeader>
<bodyText confidence="0.9981002">
Recall that we have switched from the original syntax
to a (two-sorted) syntax by translating constraints
xLy into Ixay, a e LI, where a is new. The result of
the translation constitutes a special class of clauses,
namely the class of prime clauses, which will be de-
fined below. Hence, it suffices to show decidability
of consistency of prime clauses. They are the input
clauses for the first phase.
Let 0 be some clause and x, y be different vari-
ables. We say that 0 binds y to x if x y E 0 and y
occurs only once in 0. Here it is important that we
consider equations as directed, i.e. we assume that
y is different from y = x. We say that 0 elimi-
nates y if 0 binds y to some variable x. A clause is
called basic if
</bodyText>
<listItem confidence="0.983435666666667">
1. x = y appears in 0 if 0 eliminates y,
2. For every path variable a used in 0 there is at
most one constraint xay E 0.
</listItem>
<page confidence="0.993256">
203
</page>
<figure confidence="0.989592111111111">
L L&apos;
(Join)
(Pre)
(Eq) fa = 16, ray, xi6z} U
{ y z, xay} U 7,ffig 4— a, y
{a -k ray, xflz} Utk
{xay} U {y/3z} U 4-- a. fi] a (1
{aeL, creL&apos;}U0
{ae(LnL1)}Utk
(Divi)fa /31 u {cOn filuO
{aii#&apos;}uo
(Div2) {c&amp;quot;9/1 a&apos;ff} U
{fliiiT}U0
(SCIash) {Az, Bx} Ut,l)
A 0 B
(Daashi) II a} u tp
(DClash2)
(Empty)
</figure>
<figureCaption confidence="0.999992">
Figure 1: Simplification rules. Note that (Pre) does not introduce a new variable.
</figureCaption>
<bodyText confidence="0.97167275">
A basic clause 0 is called prime if 0 does not contain
an atomic constraint of the form p ñ q, fl or a
[3. Every clause 0 in the original Kaplan/Maxwell
syntax can be translated into a prime clause 7 such
that 0 is consistent if 7 is consistent.
Now let&apos;s turn to the output clauses of the first
step. A basic clause is said to be pre-solved if the
following holds:
</bodyText>
<listItem confidence="0.96124">
1. Ax E 0 and Br E 0 implies A = B.
2.aeLE 4i andaeVE q impliesL= .
Furthermore, a e0 is not in 0.
3. ce-i3, a = [3 or a )6 are not contained in
4. ani6E0iffa0)6,xayE0 andxfizE0.
</listItem>
<construct confidence="0.403843666666667">
Lemma 4.1 A pre-solved clause 4&apos; is consistent if
there is a path valuation 14 with vp k, where
is the set of path constraints in 0.
</construct>
<bodyText confidence="0.991066583333333">
Now let&apos;s turn to the rule system. As we
have explained informally, the first rule adds non-
deterministicly relational constraints between path
variables. In one step we will add the relations be-
tween one fixed variable a and all other path vari-
ables f3 which are used under the same node x as a.
Furthermore, we will consider only the constraints
= f3 and a /3 and not additionally the
constraint a
For better readability we will use pseudo-code for
describing this rule (using the usual don&apos;t care/don&apos;t
know distinction for non-determinism):
</bodyText>
<equation confidence="0.930181333333333">
(PathRel)
Choose x E Varsx (0) (don&apos;t care)
Choose ray E 0 (don&apos;t know)
</equation>
<bodyText confidence="0.967649075">
For each x/6z E 0 with a #16 and a ft )3 fl
add a Op # with &lt;5,3 E {-=, -k,11) (don&apos;t know)
&amp;quot;don&apos;t care non-determinism&amp;quot; means that one is
free to choose an arbitrary alternative at this choose
point, whereas &amp;quot;don&apos;t know&amp;quot; means that one has to
consider every alternative in parallel (i.e. for every al-
ternative of the don&apos;t care non-determinism a clause
0 is equivalent to the set of all don&apos;t know alterna-
tives that can be generated by applying the rule to
0). Note that the order of rule application is another
example for don&apos;t care non-determinism in our rule
system.
Although we have restricted the relations Op to
{.=, :&lt;,11}, this rule is globally preserving since we
have non-deterministically chosen ray. To see this
let 0 be a clause, I be an interpretation and (Vx,14)
be a valuation in I with (Vx, Vp) = 0. To find an
instance of (PathRel) such that (Vi, 14) J=x 7 where
7 is the result of applying this instance, we choose
ray E 0 with Vp(a) is prefix minimal in
{l/p(/6) I xfiz E 0}.
Then for each x /3z E 0 with a g and a II )6 0
we add a Op [3 where Vp(a) Op Vp()6) holds. Note
that Op equals ;- will not occur since we have cho-
sen a path variable a whose interpretation is prefix
minimal. Therefore, the restriction Op E it} is
satisfied.
We have defined (PathRel) in a very special way.
The reason for this is that only by using this spe-
cial definition we can maintain the condition that
concatenation of path variables is restricted to bi-
nary concatenation. E.g. assume that we would have
added both )61 a and a /62 to a clause 7. Then
first splitting up the variable a into )61.a&apos; and then
)62 into a.16; will result in a substitution of 132 in 7
by /3i-a&apos;.16;. By the definition of (PathRel) we have
ensured that this does not occur.
The second non-deterministic rule is used in the
decomposition of regular languages. For decomposi-
tion we have the following rules:
</bodyText>
<equation confidence="0.97132875">
(DecClash) Ia./3 e U
{ w E L iwi &gt; 1} = 0
(LangDecA) {a.fieL} U P.S C L
fa e P} U {16 e S} Ut,b
</equation>
<bodyText confidence="0.999892583333334">
where P, S, L C F+ and A is a finite set of
reg. languages with L, P,S E A. L must
contain a word w with twl &gt; 1.
The clash rule is needed since we require regular lan-
guages not to contain the empty path. The remain-
ing rules are listed in Figure 1.
We use A in (LangDecA) as a global restriction,
i.e. for every A we get an different rule (LangDecA)
(and hence a different rule system RA). This is done
because the rule system is quasi-terminating. By
restricting (LangDecA) we can guarantee that only
finitely many regular languages are produced.
</bodyText>
<page confidence="0.993396">
204
</page>
<bodyText confidence="0.997834">
For (LangDecA) to be globally preserving we need
to find a suitable pair P, S in A for every possible
valuation of a and fl. Therefore, we require A to
satisfy
</bodyText>
<equation confidence="0.9633405">
VL E A, VW1, W2 0 e: [WiW2 €L
3P, S E A : (P •Sc LA w1 E P A W2 E S)].
</equation>
<bodyText confidence="0.9431215">
We will call A closed under decomposition if it sat-
isfies this condition. Additionally we have to ensure
that L E A for every L that is contained in some
clause 0. We will call such a set A 0-closed. Surely,
we will not find a finite A that is closed under de-
composition and 0-closed for arbitrary 0. But the
next lemma states some weaker condition that suf-
fices. We say that 7 is a (0,7.A)-derivative if 7 is
derivable from 0 by using only rules from RA. H
is clear from the context, we will just say that 7 is a
0-derivative.
Lemma 4.2
</bodyText>
<listItem confidence="0.9933154">
1. If A is 0-closed and closed under intersection,
then A is 7-closed for all (0,R.A)-derivatives 7.
2. For every prime clause 0 there is a finite A such
that A is 0-closed and closed under intersection
and decomposition.
</listItem>
<bodyText confidence="0.998793">
The proof of this lemma (containing the construc-
tion of the set A) can be found in the appendix.
</bodyText>
<subsectionHeader confidence="0.998506">
4.2 Completeness and Quasi-Termination
</subsectionHeader>
<bodyText confidence="0.999930746987952">
The rule system serves for an algorithm to transform
a prime clause into an equivalent set of pre-solved
clauses. The rules are applied in arbitrary order un-
til a pre-solved clause has been derived. If one of the
non-deterministic rules is applied, a clause is sub-
stituted by a whole set of clauses, one for each of
the don&apos;t know alternatives. Since the rule system
is quasi-terminating, we may encounter cycles dur-
ing the application of the rules. In this case we skip
the corresponding alternative, since every pre-solved
clause that can be produced via a cyclic derivation
can also be produced via a derivation that does not
contain a cycle.
Theorem 4.3 Let 0 be a prime clause. If A is 0-
closed, closed under intersection and decomposition,
then NI = U1,E,b 1711 for every interpretation I,
where 4) is the set of pre-solved (0,1N-derivatives.
The set 4:1) is finite and effectively computable.
To prove this theorem we have to show that the
rule system is sound and complete. Sound means,
that we do not add new solutions during the pro-
cessing, whereas complete means that we find all so-
lutions in the set of pre-solved derivatives.
For the completeness it normally suffices to show
that (1) every rule preserves (or globally preserves)
the initial solutions and (2) the pre-solved clauses
are exactly the RA-irreducible clause (i.e. if a clause
is not pre-solved, then one rule applies). But in our
case this is not sufficient as the rule system is quasi-
terminating. A prime clause 0 may have a solution
Vx which is a solution of all (0, &apos;RA)-derivatives in
some cyclic derivation, but can not be found in any
pre-solved (0, RA)-derivative. We have to show that
this cannot happen. Since this part of the proof is
unusual, we will explain the main idea (see the ap-
pendix for a more detailed outline of the proofs).
Let 0 be some (consistent) prime clause and let
Vx E [01/ for some I. Then there exists a path val-
uation Vp such that (Vx, Vp) =r 0. We will find a
pre-solved 0-derivative that has Vx as a solution by
imposing an additional control that depends on 14.
This control will guarantee (1) finiteness of deriva-
tions, (2) that each derivation ends with a pre-solved
clause, (3) the initial solution is a solution of every
clause that is derivable under this control. Since the
(Pre) rule does not preserve the initial path valua-
tion Vp (recall that the variable )3 is substituted by
the term a.P), we have to change the path valuation
Vp every time (Pre) is applied. It is important to no-
tice that this control is only used for proof purposes
and not part of the algorithm. For the algorithm it
suffices to encounter all pre-solved 0-derivatives.
To understand this control, we will compare
derivations in our syntax to derivations in standard
feature logic. Recall that we have a two-level inter-
pretation. A constraint xay is valid under Vx and
Vp if xVp(a)y is valid under Vx. Hence, for each
clause 0 and each valuation Vx, Vp with 0 valid un-
der Vx and Vp there is a clause 0v7, in standard
feature logic syntax (not containing functional un-
certainty) such that 0v7„ is valid under V. E.g. for
the clause {xax, aef, xi3z, 13e f*g} and a path val-
uation Vp with Vp (a) = f and Vp(P) = g the clause
(fiv, is {xfx, xgy}. The control we have mentioned
requires (by and large) that only those rewrite rules
will be applied, that are compatible to the clause
Ovp and thus preserve V. If one of the rules (Eq)
or (Pre) is applied, we also have to rewrite 0v,„. Tak-
ing the above example, we are only allowed to add
n P to 0 (using (PathRel)), since 0v, is already in
pre-solved form.
Now let&apos;s vary the example and let Vp be a path
valuation with Vp(a) = f and 14(3) = fig. Then
we have to add a in the first step, since this
relation holds between a and P. The next step is
to apply (Pre) on a [I. Here we have to rewrite
both 0 and çiv. Hence, the new clauses 0&apos; and 01„,
are {xax, aéf, xflz, a-fle f*g} and {x f x,x fg y}
respectively. Note that the constraint x f fg y has
been reduced to x fg y by the application of (Pre).
Since infinite derivations must infinitely often use
(Pre), this control guarantees that we find a pre-
solved clause that has Vx as a solution.
</bodyText>
<sectionHeader confidence="0.991847" genericHeader="method">
5 The Second Phase
</sectionHeader>
<bodyText confidence="0.999932333333333">
In the second phase we have to check consistency
of pre-solved clauses. As we have mentioned, a pre-
solved clause is consistent if we find some appropri-
ate path valuation. This means that we have to
check the consistency of divergence constraints of
the form al 11 a2 together with path restrictions
</bodyText>
<page confidence="0.997152">
205
</page>
<bodyText confidence="0.999614">
al e Li and a2 L2. A constraint al ñ a2 is
valid under some valuation Vp if there are (possi-
bly empty) words w, w1, w2 and features&apos; f g such
that Vp(ai) = wfwi and Vp(a2) = wgw2. This def-
inition could directly be used for a rewrite rule that
solves a single divergence constraint, which gives us
</bodyText>
<equation confidence="0.962276666666667">
(So1v) {ai a2} U
q, )3, a12 new
e f.F*,cV2eg.r} U0&apos;
</equation>
<bodyText confidence="0.999766888888889">
where 0&apos; =0[ai a2 4— )3.a&apos;2]. By the ap-
plication of this rule we will get constraints of the
form e L1 and 13.ai2 L2. Decomposing these
restriction constraints and joining the correspond-
ing path restrictions for 13 and c4,2 will result in
fi3 e (P1 fl P2), ac. e (f n a12 (g S2)}
with Pi C L1 and P2.S2 C L2, which completes
the consistency check.
Additionally, one has to consider the effects of in-
troducing the path terms )3.a&apos;i. The main part of this
task is to resolve constraints of the form /3.aii 11 a.
There are two possibilities: Either a has also )3 as
an prefix, in which case we have to add )3 a; or
g is not a prefix of a, which means that we have to
add a ñ )3. After doing this, the introduced prefix
constraints have to be evaluated using (Pre). (In the
appendix we present a solution which is more appro-
priate for proofing termination).
</bodyText>
<sectionHeader confidence="0.953943" genericHeader="evaluation">
6 Kaplan and Maxwell&apos;s Method
</sectionHeader>
<bodyText confidence="0.999964076923077">
We are now able to compare our method with the
one used by Kaplan and Maxwell. In our method,
the non-deterministic addition of path relation and
the evaluation of these relations are done at different
times. The evaluation of the introduced constraints
)3 and a 13 are done after (PathRel) in the first
phase of the algorithm, whereas the evaluation of the
divergence constraints is done in a separate second
phase.
In Kaplan and Maxwell&apos;s algorithm all these
steps are combined into one single rule. Roughly,
they substitute a clause {xL1y,xL2z,} U 0 non-
deterministicly by one of the following clauses:2
</bodyText>
<equation confidence="0.975665">
{ x(L1nL2)y, x }
{ x (LinP)y, ySz }U0 P.S C L2
{ X (L2nP) Z, ZSy}U P.S C Li
{ (PinP2)n, u (f Si) y, u(g-S2)z }U0 with
Prf C Li, P2.9-S2 C L2, f 0 g, u new
</equation>
<bodyText confidence="0.993560310344828">
Recall that {xLig, xL2z} is expressed in our syntax
by the clause 7 = {xay, e Li, x fiz, e L2}, which
is the example we have used on page 2. The first
three cases correspond exactly to the result of the
&apos;This is not the way their algorithm was originally
described in [5] as they use a slightly different syntax.
Furthermore, they don&apos;t use non-deterministic rules, but
use a single rule that produces a disjunction. However,
the way we describe their method seems to be more ap-
propriate in comparing both approaches.
derivations that have been described for 72, 73 and
74. By and large, the last case is achieved if we first
add a 11 ft to 7 and then turn over to the second
phase as described in the last section.
The problem with Kaplan/Maxwell&apos;s algorithm is
that one has to introduce a new variable u in the last
case, since there is no other possibility to express di-
vergence. If their rule system is applied to a cyclic
description, it will not terminate as the last part in-
troduces new variables. Hence it cannot be used for
an algorithm in case of cyclic descriptions.
The delaying of the evaluation of divergence con-
straint may not only be useful when applied to
cyclic feature descriptions. As Kaplan and Maxwell
pointed out, it is in general useful to postpone the
consistency check for functional uncertainty. With
the algorithm we have described it is also possible
to delay single parts of the evaluation of constraints
containing functional uncertainty.
</bodyText>
<sectionHeader confidence="0.978873" genericHeader="conclusions">
Appendix
</sectionHeader>
<bodyText confidence="0.9813065">
Proof of Lemma 4.2. The first claim is easy
to prove. For the second claim let { L1, ..., C
P(.1+) be the set of regular languages used in 0 and
let Ai = (QA,,iA,cA,FinA,) be finite, determinis-
tic automatons such that Ai recognizes L. For each
Ai we define dec(Ai) to be the set
</bodyText>
<equation confidence="0.5311">
dec(Ai) = p, q E QA,},
</equation>
<bodyText confidence="0.9995268125">
where LI = {w E w) = gl. It is easy
to show that dec(Ai) is a set of regular languages
that contains Li and is closed under decomposition.
Hence, the set Ao = U1 dec (Ai) contains each Li
and is closed under decomposition. Let A = fi (Ao)
be the least set that contains Ao and is closed under
intersection. Then A is finite and 0-closed, since it
contains each L.
We will prove that A is also closed under decompo-
sition. Given some L E A and a word w = w1 w2 E L,
we have to find an appropriate decomposition P, S
in A. Since each L in A can be written as a finite
intersection L = Lik where Li, is in Ao, we
know that w = w1 w2 is in Li, for 1..m. As Ao is
closed under decomposition, there are languages Pi,
and Sik for k = 1..m with w1 E 1k, w2 E Si„ and
</bodyText>
<equation confidence="0.902478">
Pi„-Si„ C Li,. Let P = andS= n
Pik k •
</equation>
<bodyText confidence="0.723198">
Clearly, wi E P, w2 E S and P.S C L. Furthermore,
P, S E A as A is closed under intersection. This im-
plies that P,S is an appropriate decomposition for
W1W2.
</bodyText>
<subsectionHeader confidence="0.7266125">
A.1 Phase I: Soundness, Completeness and
Quasi-Termination
</subsectionHeader>
<bodyText confidence="0.954683">
Proposition A.1 The rule (PathRel) is X U V-
sound and globally X UV-preserving. If A is closed
under decomposition, then (LangDecA) is X U V-
sound and globally X UV-preserving. The (Pre) rule
is X -sound and X -preserving. All other rules are
X UV-sound and X UV-preserving.
</bodyText>
<page confidence="0.996846">
206
</page>
<bodyText confidence="0.99942625">
Next we will prove some syntactic properties of the
clauses derivable by the rule system. For the rest of
the paper we will call clauses that are derivable from
prime clauses admissible.
</bodyText>
<construct confidence="0.789969">
Proposition A.2 Every admissible clause is basic.
If a -k [3, a= 13 or a u [3 is contained in some
admissible clause 0, then there is a variable x such
that xay and xfiz is in 0.
</construct>
<bodyText confidence="0.951492636363636">
Note that (by this proposition) (Pre) (resp. (Eq))
can always be applied if a constraint a f/ (resp.
/3) is contained in some admissible clause. The
next lemma will show that different applications of
(Pre) or (Eq) will not interact. This means the
application of one of these rule to some prefix or
path equality constraint will not change any other
prefix or path equality constraint contained in the
same clause. This is a direct consequence of the way
(PathRel) was defined.
Lemma A.3 Given two admissible clauses 7,
</bodyText>
<figureCaption confidence="0.538556">
with 7 -y&apos; and r different from (PathRel). Then
</figureCaption>
<bodyText confidence="0.977334666666667">
= E -y1 (resp. a /3 E 7&apos;) implies a E -y
(resp. a .k E 7). Furthermore, if a.f3 is contained
in y&apos;, then either a.)(3 or a -k is contained in 7.
Note that this lemma implies that new path
equality or prefix constraints are only introduced
by (PathRel). We can derive from this lemma
some syntactic properties of admissible clauses which
are needed for proving completeness and quasi-
termination.
</bodyText>
<construct confidence="0.815075">
Lemma A.4 If 0 is an admissible clause, then
I. If a -k 13 is contained in 0, then there is no other
prefix or equality constraint in 0 involving 13.
Furthermore, neither f3.0&apos; nor 0&apos;./3 is contained
in 0.
2. if co() 11 /3&apos; is in 0, then either [3&apos; equals a or 0
contains a constraint of form a 11 /3&apos;, a 0&apos; or
a .k
</construct>
<bodyText confidence="0.927704166666667">
The first property will guarantee that concatena-
tion does not occur in prefix or equality constraints
and that the length of path concatenation is re-
stricted to 2. The second property ensures that a
constraint a./3 11 fl&apos; is always reducible.
Theorem A.5 For every finite A the rule system
RA is quasi-terminating.
Proof. The rule system produces only finitely many
different clauses since the rules introduce no addi-
tional variables or sort symbols and the set of used
languages is finite. Additionally, the length of con-
catenation is restricted to 2. 0
</bodyText>
<construct confidence="0.761211">
Lemma A.6 There are no infinite derivations using
only finitely many instances of (Pre).
</construct>
<bodyText confidence="0.998808142857143">
Since the rule system is quasi-terminating, the
completeness proof consists of two parts. In the first
part we will proof that pre-solved clauses are just the
irreducible clauses. In the second part we will show
that one finds for each solution VX of a prime clause
0 a pre-solved 0-derivative 7 such that Vx is also a
solution of 7.
</bodyText>
<construct confidence="0.4008436">
Theorem A.7 (Completeness I) Given an ad-
missible clause 0 1 such that 0 is not in pre-solved
form. If A is 0-closed and closed under decomposi-
tion, then 0 is RA-reducible.
Theorem A.8 (Completeness II) For ev-
</construct>
<bodyText confidence="0.3500035">
ery prime clause 0 and for every A that is 0-closed,
closed under decomposition and intersection we have
</bodyText>
<equation confidence="0.333639">
it c U 1171 z
&apos;1Epre-solved(0,RA)
</equation>
<bodyText confidence="0.983993311111111">
where pre-solved(0, RA) is the set of pre-solved
(0, RA)-derivatives.
Proof (Sketch) We have to show, that for each
prime clause 0 and each Vx, Vp, I with (Vi, Vp)
0 there is a pre-solved (0, RA)-derivative 7 such that
Vx E 1[7]/. We will do this by controlling deriva-
tion using the valuation (Vs, Vp). The control will
guarantee finiteness of derivations and will maintain
the first completeness property, namely that the ir-
reducible clauses are exactly the pre-solved clauses.
We allow only those instances of the non-
deterministic rules (PathRel) and (LangDecA),
which preserve exactly the valuation (Vs, Vp). That
means if (Vx, Vp) kl 0 and 0 7 for one of
these rules, then (Vx, Vp) -y must hold. Note
that the control depends only on Vp. E.g. for the
clause 0 = {xay, a e Li, xigz,13 L2} and arbitray
Vx this means that if Vp (a) = f, Vp(f3) = g and
(Vx, Vp) J=z 0, the rule (PathRel) can transform 0
only into {a U /3} U 0.
If Vp satisfies Vp (a) Vp (13) for a different from /3
with xay E (1) and zgz E we cannot add any prefix
constraint using this control. Hence, (Pre) cannot be
applied, which implies (by lemma A.6) that in this
case there is no infinite controlled derivation. We will
call such path valuations prefix-free with respect to
0.
If Vp is not prefix-free, then (Pre) will be applied
during the derivations. In this case we have to change
the path valuation, since (Pre) is not P-preserving.
If (Vx, Vp) 1= 4&apos; = {a 0} U ?,/, and we apply (Pre)
on a -k ,3 yielding 7, then the valuation V); with
Vp(13) = Vp(a)V:,(#) and Vp (a) = Vi&apos;,(a) for a 0
will satisfy (Vs ,V.;,,) i=-y. We will use VI, for
controlling the further derivations.
If we change the path valuation in this way, there
will again be only finite derivations. To see this,
note that every time (Pre) is applied and the path
valuation is changed, the valuation of one variable is
shortened by a non-empty path. As the number of
variables used in clauses does not increase, this short-
ening can only be done finitely many times. This
implies, that (Pre) can only finitely often be applied
under this control. Hence (by lemma A.6), there are
again only finite controlled derivations.
</bodyText>
<page confidence="0.990441">
207
</page>
<note confidence="0.805958">
A.2 Consistency of Pre-Solved Clauses
</note>
<bodyText confidence="0.999948714285714">
We will first do a minor redefinition of _divergence.
We say that two paths u, v are directly diverging
(written u uo v) if there are features f g such
that u E f.r and v E g.r. Then u H v holds if
there are a possible empty prefix w and paths u&apos;, v&apos;
such that u = wu&apos; and v = un, and u&apos;ll v&apos;.
We will reformulate the reduction of divergence
constraints in order to avoid constraints of form
a.)3 Handling such constraints would make the
termination proof somewhat complicated. For the
reformulation we use a special property of pre-solved
clauses, namely that a U /3 is in a pre-solved clause
qi if xay and xf3x is in 0. Hence, if a and i3 U
is in 0, then a Li 6 is also in 0. This implies, that
</bodyText>
<equation confidence="0.964976">
we can write Op as (Ai) 1.1(An) WO, where
n (A) is a syntactic sugar for
Li (A) = {aLi a&apos; I a a&apos; A a, E A},
</equation>
<bodyText confidence="0.99123025">
A1,. , An are disjoint sets of path variables and
does not contain divergence constraints. Note
that for every Ai = {ai, ..., an} there are vari-
ables x, yi, yn such that {xaiyi,. . .xay} C
0. Now given such that a constraint ñ (A), we as-
sume that a whole set of path variables A1 C A di-
verges with the same prefix That means we can
replace Li (A1) C (A) by
</bodyText>
<equation confidence="0.803712">
A1 = )(3.A&apos;IU no(Al.),
</equation>
<bodyText confidence="0.9995863125">
where is new, A&apos;1 = , a&apos;,} is a disjoint copy
of A1 .7.: {ai, , an} and A = P-Ac is an abbre-
viation for the clause {al = g•ac, ..., an = }.
Li o(A) is defined similar to n (A). Assuming addi-
tionally that the common prefix (3 is maximal implies
that fi Li a holds for a E (A —A1). If we also consider
the effects of Ai = )3.Ac on the subterm agreements
in 0 that involves variables of A1, then we result in
the following rule:
where o&apos; =[a 1 4— Q.ai, • • • , an #.4],
Ai WA2 = A, jAi I &gt; 1 and z, /3 new. Ais
a disjoint copy of Al. xAiYi is short for
fxaiyi, • • • , xanynl. may not contain
constraints of form 6.6e L in tk.
Note that we have avoided constraints of the form
oz-#1i /3&apos;. The rules
</bodyText>
<equation confidence="0.562908">
(Red2) no(A)u1&apos;
1.1 (A) U 1,1)
no(A) u ?,b „
</equation>
<bodyText confidence="0.94855896">
{aEfa-F*IaEA} U f,0 fa,for aa&apos;
(Solv)
together with the rules (LangDecA), (Join) and
(Empty) completes the rule system RsA°I&amp;quot;. (Red2)
is needed as path variables always denote non-empty
paths. We will view (Redi) and (Red2) as one single
rule (Reduce).
A clause 0 is said to be solved if (1) a.p e L and
e 0 is not in Op; (2) a e Li in Op and a e L2 in Op
implies L1 = L2; (3) 0 does not contain constraints
of form a Li fi, a U0 13, a fi, or a [1; and (4) for
every {ay, xi3z} C 0 with a fi there are features
I g with la e e gL2} C 0. It is easy to
see that every solved clause is consistent. Note that
every solved clause is also prime.
Lemma A.9 The rules (Reduce) = (Redi)
(Red2) and (Solv) are X-sound and globally X-
preserving. Furthermore, Rse is terminating.
Lemma A.10 Let 0 be a pre-solved clause. If A is
0-closed, closed under intersection and decomposi-
tion, then a derivative different from 1 is
irreducible if and only if it is solved.
Finally we can combine both phases of the algorithm.
Theorem A.11 Consistency of prime clauses is de-
cidable.
</bodyText>
<sectionHeader confidence="0.997281" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.99973452631579">
[1] F. Baader, H.-J. Biirckert, B. Nebel, W. Nutt, and
G. Smolka. On the expressivity of feature logics with
negation, functional uncertainity, and sort equa-
tions. Research Report RR-91-01, DFKI, 1991.
[2] R. Backofen. Regular path expressions in feature
logic. Research Report RR-93-17, DFKI, 1993.
[3] R. Backofen and G. Smolka. A complete and recur-
sive feature theory. In Proc. of the 31 th ACL, 1993.
this volume.
[4] N. Dershowitz. Termination of rewriting. Journal
of Symbolic Computation, 3:69-116, 1987.
[5] for functional uncertainty. In Proc. of the 12th COL-
R. M. Kaplan and J. T. Maxwell III. An algorithm
ING, pages 297-302, Budapest, Hungary, 1988.
[6] R. M. Kaplan and A. Zaenen. Functional uncer-
tainty and functional precedence in continental west
germanic. In H. Trost, editor, 4. Osterreichische
Artificial-Intelligence-Tagung: Wiener Workshop -
Wissensbasierte Sprachverarbeitung, pages 114-123.
Springer, Berlin, Heidelberg, 1988.
R. M. Kaplan and A. Zaenen. Long-distance depen-
dencies, constituent structure, and functional uncer-
tainty. In M. Baltin and A. Kroch, editors, Alterna-
tive Conceptions of Phrase Structure. University of
Chicago Press, Chicago, 1988.
B. Keller. Feature logics, infinitary descriptions and
the logical treatment of grammar. Cognitive Science
Research Report 205, Univerity of Sussex, School of
Cognitive and Computing Sciences, 1991.
G. Smolka. A feature logic with subsorts. LILOG-
Report 33, IBM Deutschland, Stuttgart, 1988.
G. Smolka. Feature constraint logics for unification
grammars. Journal of Logic Programming, 12:51-
87, 1992.
[11] G. Smolka and R. Treinen. Records for logic pro-
gramming. In Proceedings of the 1992 Joint Inter-
national Conference and Symposium on Logic Pro-
gramming, pages 240-254, Washington, DC, 1992.
</reference>
<figure confidence="0.9963958">
(Redi)
{0z} U zAlYi U no(A) U li({#}UA2) U
ii(A)U 7,/)
[7]
[9]
</figure>
<page confidence="0.953954">
208
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.852532">
<title confidence="0.99897">ON THE DECIDABILITY OF FUNCTIONAL UNCERTAINTY*</title>
<author confidence="0.999986">Rolf Backofen</author>
<affiliation confidence="0.982259">Research Center for Artificial Intelligence (DFKI)</affiliation>
<address confidence="0.989107">Germany</address>
<email confidence="0.999424">backofen@dfki.uni-sb.de</email>
<abstract confidence="0.9872658">We show that feature logic extended by functional uncertainty is decidable, even if one admits cyclic descriptions. We present an algorithm, which solves feature descriptions containing functional uncertainty in two phases, both phases using a set of deterministic and non-deterministic rewrite rules. We then compare our algorithm with the one of Kaplan and Maxwell, that does not cover cyclic feature descriptions.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>F Baader</author>
<author>H-J Biirckert</author>
<author>B Nebel</author>
<author>W Nutt</author>
<author>G Smolka</author>
</authors>
<title>On the expressivity of feature logics with negation, functional uncertainity, and sort equations.</title>
<date>1991</date>
<tech>Research Report RR-91-01, DFKI,</tech>
<contexts>
<context position="4111" citStr="[1]" startWordPosition="680" endWordPosition="680">imed that Bill telephoned; Mary John claimed that Bill said that ... Henry telephoned yesterday; .... For this family of sentences the clauses s topic x A s comp obj x, s topic x A s comp comp obj x and so on would be appropriate; specifying all possibilities would yield an infinite disjunction. This changes if we make use of functional uncertainty allowing to specify the above as the single clause s topic x A s comp* obj x. Kaplan and Maxwell [5] have shown that consistency of feature descriptions is decidable, provided that a certain acyclicity condition is met. More recently, Baader et al. [1] have proven, that consistency is not decidable if we add negation. But it is an open problem whether consistency of feature descriptions without negation and without additional restrictions (such as acyclicity) is decidable. In the work presented here we show that it indeed is decidable. 2 The Method We will first briefly describe the main part of solving the standard feature terms and then turn to their extension with functional uncertainty. Consider a clause 0 = xpiyi A xp2y2 (from now on we will refer to pure conjunctive formulae as clauses). A standard method for solving feature terms wou</context>
</contexts>
<marker>[1]</marker>
<rawString>F. Baader, H.-J. Biirckert, B. Nebel, W. Nutt, and G. Smolka. On the expressivity of feature logics with negation, functional uncertainity, and sort equations. Research Report RR-91-01, DFKI, 1991.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Backofen</author>
</authors>
<title>Regular path expressions in feature logic.</title>
<date>1993</date>
<tech>Research Report RR-93-17, DFKI,</tech>
<contexts>
<context position="2550" citStr="[2]" startWordPosition="404" endWordPosition="404">ling so-called long distance dependencies and constituent coordination. For a detailed linguistic motivation see [7], [6] and [5]; a more general use of functional uncertainty can be found in [8]. Functional uncertainty consists of constraints of *This work was supported by a research grant, ITW 9002 0, from the German Bundesministerium fiir Forschung und Technologie to the DFKI project DISCO. I would like to thank Jochen Done, Joachim Niehren and Ralf Treinen for reading draft version of this paper. For space limitations most of the proofs are omitted; they can be found in the complete paper [2] the form xLy, where L is a finite description of a regular language of feature paths. A constraint xLy holds if there is a path w E L such that zwy holds. Under this existential interpretation, a constraint xLy can be seen as the disjunction xLy = V Ixwy I w E Ll. Certainly, this disjunction may be infinite, thus functional uncertainty yields additional expressivity. Note that a constraint xwy is a special case of a functional uncertainty constraint. To see some possible application of functional uncertainty we briefly recall an example that is given in Kaplan and Maxwell [5, page 1]. Conside</context>
</contexts>
<marker>[2]</marker>
<rawString>R. Backofen. Regular path expressions in feature logic. Research Report RR-93-17, DFKI, 1993.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Backofen</author>
<author>G Smolka</author>
</authors>
<title>A complete and recursive feature theory.</title>
<date>1993</date>
<booktitle>In Proc. of the 31 th ACL,</booktitle>
<note>this volume.</note>
<contexts>
<context position="1055" citStr="[3]" startWordPosition="151" endWordPosition="151">n-deterministic rewrite rules. We then compare our algorithm with the one of Kaplan and Maxwell, that does not cover cyclic feature descriptions. 1 Introduction Feature logic is the main device of unification grammars, the currently predominant paradigm in computational linguistics. More recently, feature descriptions have been proposed as a constraint system for logic programming (e.g. see [11]). They provide for partial descriptions of abstract objects by means of functional attributes called features. Formalizations of feature logic have been proposed in various forms (for more details see [3] in this volume). We will follow the logical approach introduced by Smolka [9, 10], where feature descriptions are standard first order formulae interpreted in first order structures. In this formalization features are considered as functional relations. Atomic formulae (which we will call atomic constraints) are of either the form A(x) or xfy, where z, y are first order variables, A is some sort predicate and f is a feature (written in infix notation). The constraints of the form x fy can be generalized to constraints of the form xwy, where w = fn is a finite feature path. This does not affec</context>
</contexts>
<marker>[3]</marker>
<rawString>R. Backofen and G. Smolka. A complete and recursive feature theory. In Proc. of the 31 th ACL, 1993. this volume.</rawString>
</citation>
<citation valid="true">
<authors>
<author>N Dershowitz</author>
</authors>
<title>Termination of rewriting.</title>
<date>1987</date>
<journal>Journal of Symbolic Computation,</journal>
<pages>3--69</pages>
<contexts>
<context position="10702" citStr="[4]" startWordPosition="1899" endWordPosition="1899">t this always occurs if a cycle in the graph coincides with a cycle in the regular language. To see this let us vary the above example and let 7 now be the clause {xax, a e f, xflz, gef*g}. Then a possible looping derivation could be 1. add a :&lt; xax, aef, xi3z, fiery} 2. split 13 into a-fl&apos;: {xax, aef, xifz, cr-giefig} 3. decompose a-fi&apos;&apos; ef*g: {xax, ae f, xiYz, aef*, [3&apos; erg} 202 4. join a-restrictions: {xax, ae f, x,31z, #1 erg} However, we will proof that the rule system is quasi-terminating, which means that the rule system may cycle, but produces only finitely many different clauses (see [4]). This means that checking for cyclic derivations will give us an effective algorithm. Quasi-termination is achieved by the following measures: first we will guarantee that the rules do not introduce additional variables; second we restrict concatenation to length 2; and third we will show that the rules system produces only finitely many regular languages. In order to show that our rewrite system is complete, we also have to show that every solution can be found in a pre-solved clause. 3 Preliminaries Our signature consists of a set of sorts S (A, B, .), first order variables X (x, y, .), pa</context>
</contexts>
<marker>[4]</marker>
<rawString>N. Dershowitz. Termination of rewriting. Journal of Symbolic Computation, 3:69-116, 1987.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Kaplan</author>
<author>J T Maxwell</author>
</authors>
<title>for functional uncertainty.</title>
<date>1988</date>
<booktitle>In Proc. of the 12th</booktitle>
<pages>297--302</pages>
<location>Budapest, Hungary,</location>
<contexts>
<context position="1870" citStr="[5]" startWordPosition="291" endWordPosition="291">es are considered as functional relations. Atomic formulae (which we will call atomic constraints) are of either the form A(x) or xfy, where z, y are first order variables, A is some sort predicate and f is a feature (written in infix notation). The constraints of the form x fy can be generalized to constraints of the form xwy, where w = fn is a finite feature path. This does not affect the computational properties. In this paper we will be concerned with an extension to feature descriptions, which has been introduced as &amp;quot;functional uncertainty&amp;quot; by Kaplan and Zaenen [7] and Kaplan and Maxwell [5]. This formal device plays an important role in the framework of LFG in modelling so-called long distance dependencies and constituent coordination. For a detailed linguistic motivation see [7], [6] and [5]; a more general use of functional uncertainty can be found in [8]. Functional uncertainty consists of constraints of *This work was supported by a research grant, ITW 9002 0, from the German Bundesministerium fiir Forschung und Technologie to the DFKI project DISCO. I would like to thank Jochen Done, Joachim Niehren and Ralf Treinen for reading draft version of this paper. For space limitat</context>
<context position="3959" citStr="[5]" startWordPosition="655" endWordPosition="655">ject of the relation telephoned. The sentence could be extended by introducing additional complement predicates, as e.g. in sentences like Mary John claimed that Bill telephoned; Mary John claimed that Bill said that ... Henry telephoned yesterday; .... For this family of sentences the clauses s topic x A s comp obj x, s topic x A s comp comp obj x and so on would be appropriate; specifying all possibilities would yield an infinite disjunction. This changes if we make use of functional uncertainty allowing to specify the above as the single clause s topic x A s comp* obj x. Kaplan and Maxwell [5] have shown that consistency of feature descriptions is decidable, provided that a certain acyclicity condition is met. More recently, Baader et al. [1] have proven, that consistency is not decidable if we add negation. But it is an open problem whether consistency of feature descriptions without negation and without additional restrictions (such as acyclicity) is decidable. In the work presented here we show that it indeed is decidable. 2 The Method We will first briefly describe the main part of solving the standard feature terms and then turn to their extension with functional uncertainty. </context>
<context position="27289" citStr="[5]" startWordPosition="5115" endWordPosition="5115">d Maxwell&apos;s algorithm all these steps are combined into one single rule. Roughly, they substitute a clause {xL1y,xL2z,} U 0 nondeterministicly by one of the following clauses:2 { x(L1nL2)y, x } { x (LinP)y, ySz }U0 P.S C L2 { X (L2nP) Z, ZSy}U P.S C Li { (PinP2)n, u (f Si) y, u(g-S2)z }U0 with Prf C Li, P2.9-S2 C L2, f 0 g, u new Recall that {xLig, xL2z} is expressed in our syntax by the clause 7 = {xay, e Li, x fiz, e L2}, which is the example we have used on page 2. The first three cases correspond exactly to the result of the &apos;This is not the way their algorithm was originally described in [5] as they use a slightly different syntax. Furthermore, they don&apos;t use non-deterministic rules, but use a single rule that produces a disjunction. However, the way we describe their method seems to be more appropriate in comparing both approaches. derivations that have been described for 72, 73 and 74. By and large, the last case is achieved if we first add a 11 ft to 7 and then turn over to the second phase as described in the last section. The problem with Kaplan/Maxwell&apos;s algorithm is that one has to introduce a new variable u in the last case, since there is no other possibility to express </context>
</contexts>
<marker>[5]</marker>
<rawString>for functional uncertainty. In Proc. of the 12th COLR. M. Kaplan and J. T. Maxwell III. An algorithm ING, pages 297-302, Budapest, Hungary, 1988.</rawString>
</citation>
<citation valid="false">
<authors>
<author>R M Kaplan</author>
<author>A Zaenen</author>
</authors>
<title>Functional uncertainty and functional precedence in continental west germanic.</title>
<date>1988</date>
<journal>Journal of Logic Programming,</journal>
<booktitle>Feature logics, infinitary descriptions and the logical treatment of grammar. Cognitive Science Research Report 205, Univerity of Sussex, School of Cognitive and Computing Sciences,</booktitle>
<pages>114--123</pages>
<editor>In H. Trost, editor,</editor>
<publisher>Springer,</publisher>
<location>Berlin, Heidelberg,</location>
<contexts>
<context position="2068" citStr="[6]" startWordPosition="322" endWordPosition="322">and f is a feature (written in infix notation). The constraints of the form x fy can be generalized to constraints of the form xwy, where w = fn is a finite feature path. This does not affect the computational properties. In this paper we will be concerned with an extension to feature descriptions, which has been introduced as &amp;quot;functional uncertainty&amp;quot; by Kaplan and Zaenen [7] and Kaplan and Maxwell [5]. This formal device plays an important role in the framework of LFG in modelling so-called long distance dependencies and constituent coordination. For a detailed linguistic motivation see [7], [6] and [5]; a more general use of functional uncertainty can be found in [8]. Functional uncertainty consists of constraints of *This work was supported by a research grant, ITW 9002 0, from the German Bundesministerium fiir Forschung und Technologie to the DFKI project DISCO. I would like to thank Jochen Done, Joachim Niehren and Ralf Treinen for reading draft version of this paper. For space limitations most of the proofs are omitted; they can be found in the complete paper [2] the form xLy, where L is a finite description of a regular language of feature paths. A constraint xLy holds if there</context>
</contexts>
<marker>[6]</marker>
<rawString>R. M. Kaplan and A. Zaenen. Functional uncertainty and functional precedence in continental west germanic. In H. Trost, editor, 4. Osterreichische Artificial-Intelligence-Tagung: Wiener Workshop -Wissensbasierte Sprachverarbeitung, pages 114-123. Springer, Berlin, Heidelberg, 1988. R. M. Kaplan and A. Zaenen. Long-distance dependencies, constituent structure, and functional uncertainty. In M. Baltin and A. Kroch, editors, Alternative Conceptions of Phrase Structure. University of Chicago Press, Chicago, 1988. B. Keller. Feature logics, infinitary descriptions and the logical treatment of grammar. Cognitive Science Research Report 205, Univerity of Sussex, School of Cognitive and Computing Sciences, 1991. G. Smolka. A feature logic with subsorts. LILOGReport 33, IBM Deutschland, Stuttgart, 1988. G. Smolka. Feature constraint logics for unification grammars. Journal of Logic Programming, 12:51-87, 1992.</rawString>
</citation>
<citation valid="true">
<authors>
<author>G Smolka</author>
<author>R Treinen</author>
</authors>
<title>Records for logic programming.</title>
<date>1992</date>
<booktitle>In Proceedings of the 1992 Joint International Conference and Symposium on Logic Programming,</booktitle>
<pages>240--254</pages>
<location>Washington, DC,</location>
<contexts>
<context position="850" citStr="[11]" startWordPosition="121" endWordPosition="121">decidable, even if one admits cyclic descriptions. We present an algorithm, which solves feature descriptions containing functional uncertainty in two phases, both phases using a set of deterministic and non-deterministic rewrite rules. We then compare our algorithm with the one of Kaplan and Maxwell, that does not cover cyclic feature descriptions. 1 Introduction Feature logic is the main device of unification grammars, the currently predominant paradigm in computational linguistics. More recently, feature descriptions have been proposed as a constraint system for logic programming (e.g. see [11]). They provide for partial descriptions of abstract objects by means of functional attributes called features. Formalizations of feature logic have been proposed in various forms (for more details see [3] in this volume). We will follow the logical approach introduced by Smolka [9, 10], where feature descriptions are standard first order formulae interpreted in first order structures. In this formalization features are considered as functional relations. Atomic formulae (which we will call atomic constraints) are of either the form A(x) or xfy, where z, y are first order variables, A is some </context>
</contexts>
<marker>[11]</marker>
<rawString>G. Smolka and R. Treinen. Records for logic programming. In Proceedings of the 1992 Joint International Conference and Symposium on Logic Programming, pages 240-254, Washington, DC, 1992.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>