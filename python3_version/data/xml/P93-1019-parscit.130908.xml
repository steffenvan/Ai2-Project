<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<title confidence="0.65378">
FEATURE-BASED ALLOMORPHY*
</title>
<author confidence="0.875795">
Hans-Ulrich Krieger Hannes Pirker
</author>
<affiliation confidence="0.6629995">
German Research Center for
Artificial Intelligence (DFKI)
</affiliation>
<address confidence="0.529860444444444">
Stuhlsatzenhausweg 3
W-66 Saarbriicken 11, Germany
{krieger,pirker}©dfki.uni-sb.de
John Nerbonne
Alfa Informatica, P.O.Box 716
Oude Kijk in &apos;t Jatstraat 41
Rijksuniversiteit Groningen
NL 9700 AS Groningen, Holland
nerbonne©let.rug.n1
</address>
<page confidence="0.747212">
(1
</page>
<sectionHeader confidence="0.977164" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.997988555555556">
Morphotactics and allomorphy are usually
modeled in different components, leading to in-
terface problems. To describe both uniformly,
we define finite automata (FA) for allomorphy in
the same feature description language used for
morphotactics. Nonphonologically conditioned
allomorphy is problematic in FA models but
submits readily to treatment in a uniform for-
malism.
</bodyText>
<sectionHeader confidence="0.834634" genericHeader="categories and subject descriptors">
1 Background and Goals
</sectionHeader>
<bodyText confidence="0.98820618367347">
ALLOMORPHY or MORPHOPHONEMICS describes
the variation we find among the different forms
of a morpheme. For instance, the German sec-
ond person singular present ending -st has three
different allomorphs, -st, -est, -t, determined by
the stem it combines with.
&apos;say&apos; pray&amp;quot;mix&apos;
) lsg pres ind sag+e bet+e mix+e
2sg pres ind sag+st bet+est mix+t
3sg pres ind sag+t bet+et mix+t
MORPHOTACTICS describes the arrangement of
morphs in words, including, e.g., the properties
of -st that it is a suffix (and thus follows the
stem it combines with), and that it combines
with verbs. While allomorphy is normally de-
scribed in finite automata (FA), morphotactics
is generally described in syntax-oriented models,
e.g., CFGs or feature-based grammars.
The present paper describes both allomor-
phy and morphotactics in a feature-based lan-
guage like that of Head-Driven Phrase Struc-
ture Grammar (HPSG) (Pollard and Sag 1987).
This work was supported by research grant ITW
9002 0 from the German Bundesministerium fiir
Forschung und Technologie to the DFKI DISCO
project. We are grateful to an anonymous ACL re-
viewer for helpful comments.
The technical kernel of the paper is a feature-
based definition of FA.1 While it is unsurprising
that the languages defined by FA may also be
defined by feature description languages (FDL),
our reduction goes beyond this, showing how the
FA themselves may be defined. The significance
of specifying the FA and not merely the lan-
guage it generates is that it allows us to use FA
technology in processing allomorphy, even while
keeping the interface to other grammar compo-
nents maximally transparent (i.e., there is NO
interface—all linguistic information is specified
via FDL).
Our motivation for exploring this application
of typed feature logic is the opportunity it pro-
vides for integrating in a single descriptive for-
malism not only (i) allomorphic and morpho-
tactic information but also (ii) concatenative
and non-concatenative allomorphy. The latter
is particularly useful when concatenative and
non-concatenative allomorphy coexists in a sin-
gle language, as it does, e.g., in German.
</bodyText>
<sectionHeader confidence="0.8096605" genericHeader="method">
2 Finite Automata as Typed
Feature Structures
</sectionHeader>
<bodyText confidence="0.999138583333333">
An FA A is defined by a 5-tuple (Q, E, S, go, F),
where Q is a finite set of STATES, E a finite IN-
PUT ALPHABET, 6:QXE -+ Q is the TRAN-
SITION FUNCTION, qo E Q the INITIAL STATE,
and F C Q the set of FINAL STATES.2 For
reasons of simplicity and space, we only refer
to the simplest form of FA, viz., DETERMIN-
ISTIC finite automata without c-moves which
consume exactly one input symbol at a time.
This is of course not a restriction w.r.t. ex-
pressivity: given an arbitrary automaton, we
can always construct a deterministic, equiva-
</bodyText>
<footnote confidence="0.95824975">
&apos;See Krieger 1993b for the details and several
extensions.
2We assume a familiarity with automata theory
(e.g., Hoperoft and Ullman 1979).
</footnote>
<page confidence="0.996577">
140
</page>
<bodyText confidence="0.999963166666667">
lent one which recognizes the same language
(see Hoperoft and Ullman 1979). Fortunately,
our approach is also capable of representing and
processing directly non-deterministic FA with c-
moves and allows for edges which are multiple-
symbol consumers.
Specifying an automaton in our approach
means introducing for every state gEQa possi-
bly recursive feature type with the same name as
q. We will call such a type a CONFIGURATION.
Exactly the attributes EDGE, NEXT, and INPUT
are appropriate for a configuration, where EDGE
encodes disjunctively the outgoing edges of q,
NEXT the successor states of q, and INPUT the
symbols which remain on the input list when
reaching q.3 Note that a configuration does not
model just a state of the automaton, but an en-
tire description at a point in computation.
</bodyText>
<sectionHeader confidence="0.684799" genericHeader="method">
[EDGE input-symb
(2) proto-config -E- NEXT config
INPUT list(input-symb)
</sectionHeader>
<bodyText confidence="0.999568555555556">
We now define two natural subtypes of proto-
config. The first one represents the non-final
states Q \ F. Because we assume that exactly
one input symbol is consumed every time an
edge is taken, we are allowed to separate the
input list into the first element and the rest list
in order to structure-share the first element with
EDGE (the consumed input symbol) and to pass
the rest list one level deeper to the next state.
</bodyText>
<figure confidence="0.208265">
(3) non-final-config
NEXT1INPUT
INPUT (
</figure>
<bodyText confidence="0.999332375">
The other subtype encodes the final states of
F which possess no outgoing edges and therefore
no successor states. To cope with this fact, we
introduce a special subtype of T, called undef, ,
which is incompatible with every other type. In
addition, successfully reaching a final state with
no outgoing edge implies that the input list is
empty.
</bodyText>
<figure confidence="0.883727166666667">
proto-configl
EDGE undef
(4) final-config
NEXT undef
INPUT ( )
&apos;Note that EDGE is not restricted in bearing only
</figure>
<footnote confidence="0.97501375">
atomic symbols, but can also be labeled with com-
plex ones, i.e., with a possibly underspecified fea-
ture structure (for instance in the case of 2-level
morphology—see below).
</footnote>
<figureCaption confidence="0.80061">
Figure 1: A finite automaton A recognizing the
language L(A) = (a + b)* c.
</figureCaption>
<bodyText confidence="0.973190842105263">
Of course, there will be final states with out-
going edges, but such states are subtypes of the
following DISJUNCTIVE type specification:
(5) config non-final-config V final-config
To make the idea more concrete, let us study
a very small example, viz., the FA A (see Fig-
ure 1). A consists of the two states X and Y,
from which we define the types X and Y, where
Y (7) is only an instantiation of final-config.
In order to depict the states perspicuously, we
shall make use of DISTRIBUTED DISJUNCTIONS.
DOrre and Eisele 1989 and Backofen et al. 1990
introduce distributed disjunctions because they
(normally) allow more efficient processing of dis-
junctions, sometimes obviating the need to ex-
pand to disjunctive normal form. They add no
expressive power to a feature formalism (assum-
ing it has disjunction), but abbreviate some oth-
erwise prolix disjunctions:
</bodyText>
<equation confidence="0.999253666666667">
[[PATHI {s1 a V b}
PATH2{ia V )3}
PATH3 [ . ]
PATHI b
PATH2 )5&apos;
PATH3 [ ] }
</equation>
<bodyText confidence="0.998636375">
The two disjunctions in the feature structure
on the left bear the same name &apos;$1&apos;, indicat-
ing that they are a single alternation. The
sets of disjuncts named covary, taken in order.
This may be seen in the right-hand side of the
equivalence.&apos;
We employ distributed disjunctions below (6)
to capture the covariation between edges and
</bodyText>
<footnote confidence="0.9959314">
4Two of the advantages of distributed disjunc-
tions may be seen in the artificial example above.
First, co-varying but nonidentical elements can be
identified as such, even if they occur remotely from
one another in structure, and second, features struc-
tures are abbreviated. The amount of abbreviation
depends on the number of distributed disjunctions,
the lengths of the paths PATH1 and PATH2, and—in
at least some competing formalisms—on the size of
the remaining structure (cf. PATH3 E. —7 above).
</footnote>
<equation confidence="0.502868125">
proto-config
EDGE fl
2
2
,1
[ PATHI a
PATH2 a
PATH3 [ ]
</equation>
<page confidence="0.983053">
141
</page>
<bodyText confidence="0.986097294117647">
their successor states: if a is taken, we must
take the type X (and vice versa), if b is used,
use again type X, but if c is chosen, choose the
type Y.
X:e [non-final-config
EDGE gi{aV b V c}
NEXT si{X V X V Y}
Y [final-config]
Whether an FA A ACCEPTS the input or not
is equivalent in our approach to the question of
FEATURE TERM CONSISTENCY: if we wish to
know whether w (a list of input symbols) will
be recognized by A, we must EXPAND the type
which is associated with the initial state go of A
and say that its INPUT is w. Using the terminol-
ogy of Carpenter 1992: (8) must be a TOTALLY
WELL-TYPED feature structure.
</bodyText>
<listItem confidence="0.635998">
(8) I. INPUT w
</listItem>
<bodyText confidence="0.997663928571429">
Coming back to our example (see Figure 1),
we might ask whether abc belongs to .C(A).
We can decide this question, by expanding the
type X with [INPUT (a , b , Or This will lead
us to the following consistent feature structure
which moreover represents, for free, the com-
plete recognition history of abc, i.e., all its solu-
tions in the FA.
Note that this special form of type expansion
will always terminate, either with a unification
failure (A does not accept w) or with a fully
expanded feature structure, representing a suc-
cessful recognition. This idea leads us to the
following ACCEPTANCE CRITERION:
</bodyText>
<equation confidence="0.660023">
w E G(A)
(9) 3INPUT w
</equation>
<bodyText confidence="0.9685825">
(NEXT). [f
INPUT (&gt;1]
where f E F
Notice too that the acceptance criterion does not
need to be checked explicitly—it&apos;s only a logi-
cal specification of the conditions under which
a word is accepted by an FA. Rather the effects
of (10) are encoded in the type specifications of
the states (subtypes of final-config, etc.).
Now that we have demonstrated the feature-
based encoding of automata, we can abbrevi-
ate them, using regular expressions as &amp;quot;feature
templates&amp;quot; to stand for the initial states of the
automaton derived from them as above.&apos; For
example, we might write a feature specification
[MORPHIFORM (a + b)* c] to designate words of
the form accepted by our example automaton.
As a nice by-product of our encoding tech-
nique, we can show that unification, disjunction,
and negation in the underlying feature logic di-
rectly correspond to the intersection, union, and
complementation of FA. Note that this state-
ment can be easily proved when assuming a clas-
sical set-theoretical semantics for feature struc-
tures (e.g., Smolka 1988). To give the flavor of
how this is accomplished, consider the two reg-
ular expressions Li = ab*c and £2 = a*19c. We
model them via six types, one for each state of
the automata. The initial state of CI is A, that
of £2 is X. The intersection of Zi and £2 is given
by the unification of A and X. Unifying A and
X leads to the following structure:
</bodyText>
<equation confidence="0.8298216">
A X A A X
[NEDEGxET ai A [ENDEGxE aVv 3} T
b},1 = [ENDEGxE a
B T x
B A xi
</equation>
<bodyText confidence="0.983665">
Now, testing whether w belongs to fl £2 is
equivalent to the satisfiability (consistency) of
</bodyText>
<listItem confidence="0.840207">
(11) AA XA [INPUT ,
</listItem>
<bodyText confidence="0.980621555555555">
where type expansion yields a decision proce-
dure. The same argumentation holds for the
union and complementation of FA. It has to be
noted that the intersection and complementa-
tion of FA via unification do not work in general
&apos;Template&apos; is a mild abuse of terminology since
we intend not only to designate the type correspond-
ing to the initial state of automaton, but also to
suggest what other types are accessible.
</bodyText>
<figure confidence="0.998507555555555">
a
X
EDGE fl b
X
EDGE 13 c
Y
NEXT EDGE undef
NEXT
NEXT undef
INPUT 6 ( )
( • )
OD)
X
EDGE
NEXT
INPUT
INPUT
INPUT (
</figure>
<page confidence="0.986783">
142
</page>
<bodyText confidence="0.998745375">
for FA with &amp;moves (Ritchie et al. 1992, 33-35).
This restriction is due to the fact, that the in-
tersected FA must run &amp;quot;in sync&amp;quot; (Sproat 1992,
139-140).
The following closure properties are demon-
strated fairly directly.
Let Ai = (Qi,E1,81,9o,F1) and A2 =
(Q2, E2,2, 90, F2)•
</bodyText>
<listItem confidence="0.999754333333333">
• Ai n A2 =-&amp;quot;- q0 A 910
• Al U A2 qo V q&apos;o
• Ai -=&amp;quot;.&amp;quot; -1,70
</listItem>
<bodyText confidence="0.999503">
In addition, a weak form of functional uncer-
tainty (Kaplan and Maxwell 1988), represented
through recursive type specifications, is appro-
priate for the expression also concatenation and
Kleene closure of FA. Krieger 19936 provides
proofs using auxiliary definitions and apparatus
we lack space for here.
</bodyText>
<sectionHeader confidence="0.998827" genericHeader="method">
3 Allomorphy
</sectionHeader>
<bodyText confidence="0.999945666666667">
The focus of this section lies in the illustration
of the proposal above and in the demonstration
of some benefits that can be drawn from the in-
tegration of allomorphy and morphotactics; we
eschew here the discussion of alternative the-
ories and concentrate on inflectional morphol-
ogy. We describe inflection using a word-and-
paradigm (WP) specification of morphotactics
(Matthews 1972) and a two-level treatment of
allomorphy (Koskenniemi 1983). We also indi-
cate some potential advantages of mixed models
of allomorphy—finite state and other.6
</bodyText>
<subsectionHeader confidence="0.988108">
3.1 WP Morphotactics in FDL
</subsectionHeader>
<bodyText confidence="0.948351526315789">
Several WORD-GRAMMARS use FDL morphotac-
tics (Trost 1991, Krieger and Nerbonne 1992 on
derivation); alternative models are also avail-
able. Krieger and Nerbonne 1992 propose an
FDL-based WP treatment of inflection. The
basic idea is to characterize all the elements
of a paradigm as alternative specifications of
abstract lexemes. Technically, this is realized
through the specification of large disjunctions
which unify with lexeme specifications. The
6The choice of two-level allomorphy is justified
both by the simplicity of two-level descriptions and
by their status as a &amp;quot;lingua franca&amp;quot; among compu-
tational morphologists. Two-level analyses in FDLs
may also prove advantageous if they simplify the po-
tential compilation into a hybrid two-level approach
of the kind described in Trost 1991.
three elements of the paradigm in (1) would be
described by the distributed disjunction in (13).
</bodyText>
<table confidence="0.904327769230769">
(13) weak-paradigm
word FORM append(E1 0)
STEM
MORPH (+,e)V
ENDING Ei s,{ (+,s,t)V
(+,t)
NUM sg
SYNILOCIHEADIAGR [ pER sill V2V3}
This treatment provides a seamless inter-
face to syntactic/semantic information, and
helps realize the goal of representing ALL
linguistic knowledge in a single formalism
(Pollard and Sag 1987).
</table>
<bodyText confidence="0.999251083333333">
Nevertheless, the model lacks a treatment
of allomorphy. The various allomorphs of -st
in (1) are not distinguished in the FDL, and
Krieger and Nerbonne 1992 foresaw an interface
to an external module for allomorphy. It would
be possible—but scientifically poor—to distin-
guish all of the variants at the level of mor-
photactics, providing a brute-force solution and
multiplying paradigms greatly.&apos; The character-
ization in Section 2 above allows us to formu-
late WITHIN FDL the missing allomorphy com-
ponent.
</bodyText>
<subsectionHeader confidence="0.979234">
3.2 Two-Level Allomorphy
</subsectionHeader>
<bodyText confidence="0.99988980952381">
Two-level morphology has become popular be-
cause it is a declarative, bidirectional and
efficient means of treating allomorphy (see
Sproat 1992 for a comprehensive introduction).
In general, two-level descriptions provide con-
straints on correspondences between underly-
ing (lexical) and surface levels. We shall use
it to state constraints between morphemic units
and their allomorphic realizations. Because two-
level automata characterize relations between
two levels, they are often referred to (and often
realized as) transducers. The individual rules
then represent constraints on the relation being
transduced.
The different forms of the suffix in 2nd person
singular in (1) are predictable given the phono-
logical shape of the stem, and the alternations
can be described by the following (simplified)
two-level rules (we have abstracted away from
inessential restrictions here, e.g., that (strong)
verbs with i/e-umlaut do not show epenthesis):
</bodyText>
<footnote confidence="0.589824666666667">
7Tzoukermann and Libermann 1990 show that
multiplying paradigms need not degrade perfor-
mance, however.
</footnote>
<page confidence="0.995489">
143
</page>
<table confidence="0.83604925">
(14) e-epenthesis in the bet- case
:e {d,t} {s,t}
s-deletion in the mix- case
s : 0 4* {s, z, ch} : t
</table>
<bodyText confidence="0.995890777777778">
The colon `:&apos; indicates a correspondence be-
tween lexical and surface levels. Thus the
first rule states that a lexical morph bound-
ary + must correspond to a surface e if it oc-
curs after d or I and before s or I. The sec-
ond specifies when lexical s is deleted (corre-
sponds to surface 0). Two-level rules of this
sort are then normally compiled into transduc-
ers (Dalrymple et al. 1987, p.35-45).
</bodyText>
<subsectionHeader confidence="0.836502">
3.3 FDL Specification of Two-Level
Morphology
</subsectionHeader>
<bodyText confidence="0.999714727272727">
Two-level descriptions of allomorphy can be
specified in FDLs straightforwardly if we model
not transducers, but rather two-level accep-
tors (of strings of symbol pairs), following
Ritchie et al. 1992. We therefore employ FA
over an alphabet consisting of pairs of symbols
rather than single symbols.8
The encoding of these FA in our approach
requires only replacing the alphabet of atomic
symbols with an alphabet of feature structures,
each of which bears the attributes LEX and SURF.
A pair of segments appearing as values of these
features stand in the lexical-surface correspon-
dence relation denoted by `:&apos; in standard two-
level formalisms. The values of the attributes
STEM and ENDING in (13) are then not lists of
symbols but rather lists of (underspecified) fea-
ture structures. Note that the italicized t etc.
found in the sequences under MORPHIENDING (13)
denote types defined by equations such as (16)
or (17). (To make formulas shorter we abbrevi-
ate &apos;alphabet&apos; etymologically as &apos;aiT.)
</bodyText>
<equation confidence="0.761206">
(15) crfl
LEX i{&amp;quot;a&amp;quot; V ...&amp;quot;s&amp;quot; V &amp;quot;s&amp;quot; V &amp;quot;+&amp;quot; V &amp;quot;+&amp;quot;)
SURF $1{&amp;quot;a&amp;quot; V ...&amp;quot;s&amp;quot; V 0 V &amp;quot;e&amp;quot; V 0}
cti3
(16) t = afi A [LEX &amp;quot;t&amp;quot;] = [ LEX &amp;quot;t&amp;quot;
SURF &amp;quot;t&amp;quot;
[
c,8cr
(17) + a ,6 A [LEX &amp;quot;+&amp;quot;] = LEX &amp;quot;+&amp;quot;
SURF &amp;quot;e&amp;quot; V 0
</equation>
<bodyText confidence="0.928813545454545">
&apos;Since our formalisation of FA cannot allow e-
transitions without losing important properties, we
are in fact forced to this position.
It is the role of the collection of FA to re-
strict underspecified lexical representations to
those obeying allomorphic constraints. This is
the substance of the allomorphy constraint (18),
which, together with the Acceptance Criterion
(10), guarantees that the input obeys the con-
straints of the associated (initial states of the)
FA.
Rules of the sort found in (14) can be directly
compiled into FA acceptors over strings of sym-
bol pairs (Ritchie et al. 1992, p.19). Making use
of the regular expression notation as templates
(introduced in Section 2 above), (19-21) display
a compilation of the first rule in (14). Here the
composite rule is split up into three different
constraints. The first indicates that epenthesis
is obligatory in the environment specified and
the latter two that each half of the environment
specification is necessary.9
</bodyText>
<figure confidence="0.976061444444445">
(18) epenth-1
{allomorphy
[MORPH [FORM Or* ft ,d} + :0 {23,0 r*)]]
(19) epenth-2
{allomorphy
MORPH [FORM (r*
[(21) epenth-3 a--
allomorphy
MORPH [FORM (sr* It , d} +:e
</figure>
<subsectionHeader confidence="0.998787">
3.4 Limits of Pure FA Morphology
</subsectionHeader>
<bodyText confidence="0.999929">
Finite-state morphology has been criticized (i)
for the strict finite-stateness of its handling
of morphotactics (Sproat 1992; 43-66); (ii) for
making little or no use of the notion of inflec-
tional paradigms and inheritance relations be-
tween morphological classes (Cahill 1990); and
(iii) for its strict separation of phonology from
morphology—i.e., standard two-level rules can
only be sensitive to phonological contexts (in-
cluding word and morpheme boundaries), and
apply to all forms where these contexts hold.
In fact, allomorphic variation is often &amp;quot;fos-
silized&amp;quot;, having outlived its original phonological
motivation. Therefore some allomorphic rules
</bodyText>
<footnote confidence="0.339341">
9 7T* denotes the Kleene closure over alphabet ir
and A the complement of A with respect to r.
</footnote>
<figure confidence="0.998538428571429">
(20) allomorphy
INPUT
MORPHIFORM
[
El
El
{s ,t}
</figure>
<page confidence="0.996653">
144
</page>
<bodyText confidence="0.989287963636364">
are restricted in nonphonological ways, apply-
ing only to certain word classes, so that some
stems admit idiosyncratic exceptions with re-
spect to the applicability of rules (see Bear 1988,
Emele 1988, Trost 1991).
To overcome the first difficulty, a number
of researchers have suggested augmenting FA
with &amp;quot;word grammars&amp;quot;, expressed in terms of
feature formalisms like PATR II (Bear 1986)
or HPSG (Trost 1990). Our proposal follows
theirs, improving only on the degree to which
morphotactics may be integrated with allomor-
phy. See Krieger and Nerbonne 1992 for pro-
posals for treating morphotactics in typed fea-
ture systems.
We illustrate how the FDL approach over-
comes the last two difficulties in a concrete
case of nonphonologically motivated allomor-
phy. German epenthesizes schwa (&lt; e &gt;) at
morph boundaries, but in a way which is sensi-
tive to morphological environments, and which
thus behaves differently in adjectives and verbs.
The data in (22) demonstrates some of these dif-
ferences, comparing epenthesis in phonologically
very similar forms.
free, adj super frei-Fst frei est
(22) free, v 2s pres be+frei-l-st befreist
woo, v 2s pres frei+st freist
While the rule stated in (14) (and reformu-
lated in (19)-(21)) treats the verbal epenthesis
correctly, it is not appropriate for adjectives, for
It does not allow epenthesis to take place after
vowels. We thus have to state different rules for
different morphological categories.
The original two-level formalism could only
solve this problem by introducing arbitrary dia-
critic markers. The most general solution is due
to Trost 1991, who associated two-level rules
with arbitrary filters in form of feature struc-
tures. These feature structures are unified with
the underlying morphs in order to check the con-
text restrictions, and thus serve as an interface
to information provided in the feature-based lex-
icon. But Trost&apos;s two-level rules are a com-
pletely different data structure from the feature
structures decorating transitions in FA.
We attack the problem head on by restrict-
ing allomorphic constraints to specific classes
of lexical entries, making use of the inheritance
techniques available in structured lexicons. The
cases of epenthesis in (22) is handled by defining
not only the rule in (19-21) for the verbal cases,
but also a second, quite similar rule for the more
liberal epenthesis in adjectives.10 This frees the
&amp;quot;In fact, the rules could be specified so that the
</bodyText>
<figure confidence="0.9917265">
•
allomorphy
epenth-1 epenth-2 epenth-3 &apos;word
Adj Verb
</figure>
<figureCaption confidence="0.986388">
Figure 2: Nonphonological Conditioning of
allomorphy is achieved by requiring that only
some word classes obey the relevant constraints.
Adjectives inherit from two of the epenthesis
constraints in the text, and verbs (without i/e
umlaut) satisfy all three. This very natural
means of restricting allomorphic variation to se-
lected, nonphonologically motivated classes is
only made available through the expression of
allomorphy in type hierarchy of the FDL. (The
types denote the initial states of FA, as ex-
plained in Section 2.)
</figureCaption>
<bodyText confidence="0.72809">
rule from operating on a strictly phonological
basis, making it subject to lexical conditioning.
This is illustrated in Figure 2.
But note that this example demonstrates not
only how feature-based allomorphy can over-
come the strictly phonological base of two-level
morphology (criticism (iii) above), but it also
makes use of the inheritance structure in mod-
ern lexicons as well.
</bodyText>
<sectionHeader confidence="0.996822" genericHeader="conclusions">
4 Conclusions
</sectionHeader>
<bodyText confidence="0.999033666666667">
In this section we examine our proposal vis-à-vis
others, suggest future directions, and provide a
summary.
</bodyText>
<subsectionHeader confidence="0.999613">
4.1 Comparison to other Work
</subsectionHeader>
<bodyText confidence="0.8749256">
Computational morphology is a large and ac-
tive field, as recent textbooks (Sproat 1992
and Ritchie et al. 1992) testify. This im-
pedes the identification of particularly im-
portant predecessors, among whom nonethe-
less three stand out. First, Trost 1991&apos;s
use of two-level morphology in combination
verbal rule inherited from the more general adjecti-
val rule, but pursuing this here would take us some-
what afield.
</bodyText>
<page confidence="0.997108">
145
</page>
<bodyText confidence="0.999930269230769">
with feature-based filters was an important
impetus. Second, researchers at Edinburgh
(Calder 1988, Bird 1992) first suggested using
FDLs in phonological and morphological de-
scription, and Bird 1992 suggests describing FA
in FDL (without showing how they might be so
characterized, however—in particular, providing
no FDL definition of what it means for an FA
to accept a string).
Third, Cahill 1990 posed the critical question,
viz., how is one to link the work in lexical inher-
itance (on morphotactics) with that in finite-
state morphology (on allomorphy). This ear-
lier work retained a separation of formalisms
for allomorphy (MOLUSC) and morphotactics
(DATR). Cahill 1993 goes on to experiment with
assuming all of the allomorphic specification into
the lexicon, in just the spirit proposed here.11
Our work differs from this later work (i) in that
we use FDL while she uses DATR, which are
similar but not identical (cf. Nerbonne 1992);
and (ii) in that we have been concerned with
showing how the standard model of allomorphy
(FA) may be assumed into the inheritance hier-
archy of the lexicon, while Cahill has introduced
syllable-based models.
</bodyText>
<subsectionHeader confidence="0.844242">
4.2 Future Work
</subsectionHeader>
<bodyText confidence="0.9993115">
At present only the minimal examples in
Section 2 above have actually been imple-
mented, and we are interested in attempting
more. Second, a compilation into genuine fi-
nite state models could be useful. Third,
we are concerned that, in restricting ourselves
thus far to acceptors over two-level alpha-
bets, we may incur parsing problems, which a
more direct approach through finite-state trans-
ducers can avoid (Sproat 1992, p.143). See
Ritchie et al. 1992, 19-33 for an approach to
parsing using finite-state acceptors, however.
</bodyText>
<subsectionHeader confidence="0.996036">
4.3 Summary
</subsectionHeader>
<bodyText confidence="0.99804979245283">
This paper proposes a treatment of allomor-
phy formulated and processable in typed feature
logic. There are several reasons for developing
this approach to morphology. First, we prefer
the GENERALITY of a system in which linguis-
tic knowledge of all sorts may be expressed—at
least as long as we do not sacrifice processing
efficiency. This is an overarching goal of HPSG
(Pollard and Sag 1987)—in which syntax and
semantics is described in a feature formalism,
and in which strides toward descriptions of mor-
photactics (Krieger 1993a, Riehemann 1993,
&amp;quot;Cf. Reinhard and Gibbon 1991 for another sort
of DATR-based allomorphy
Gerdemann 1993) and phonology (Bird 1992)
have been taken. This work is the first to show
how allomorphy may be described here. The
proposal here would allow one to describe seg-
ments using features, as well, but we have not
explored this opportunity for reasons of space.
Second, the uniform formalism allows the ex-
act and more transparent specification of depen-
dencies which span modules of otherwise dif-
ferent formalisms. Obviously interesting cases
for the extension of feature-based descriptions
to other areas are those involving stress and
intonation—where phonological properties can
determine the meaning (via focus) and even syn-
tactic well-formedness (e.g., of deviant word or-
ders). Similarly, allomorphic variants covary in
the style register they belong to: the German
dative singular in -e, dem Kinde, belongs to a
formal register.
Third, and more specifically, the feature-
based treatment of allomorphy overcomes the
bifurcation of morphology into lexical aspects—
which have mostly been treated in lexical in-
heritance schemes—and phonological aspects—
which are normally treated in finite-state mor-
phology. This division has long been recognized
as problematic. One symptom of the problem
is seen in the treatment of nonphonologically
conditioned allomorphy, such as German um-
laut, which (Trost 1990) correctly criticizes as
ad hoc in finite-state morphology because the
latter deals only in phonological (or graphemic)
categories. We illustrated the benefits of the
uniform formalism above where we showed how
a similar nonphonologically motivated alterna-
tion (German schwa epenthesis) is treated in
a feature-based description, which may deal in
several levels of linguistic description simultane-
ously.
</bodyText>
<sectionHeader confidence="0.998131" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.995019875">
Backofen, R., L. Euler, and G. Gorz. 1990. Towards
the Integration of Functions, Relations and Types
in an Al Programming Language. In Proc. of
GWA1-90. Berlin. Springer.
Bear, J. 1986. A Morphological Recognizer with
Syntactic and Phonological Rules. In Proc. of
COLING, 272-276.
Bear, J. 1988. Morphology with Two-Level Rules
and Negative Rule Features. In Proc. of COLING,
28-31.
Bird, S. 1992. Finite-State Phonology in HPSG. In
Proc. of COLING, 74-80.
Cahill, L. J. 1990. Syllable-Based Morphology. In
Proc. of COLING, 48-53.
Cahill, L. J. 1993. Morphonology in the Lexicon. In
Proc. of the 7th European ACL, 87-96.
</reference>
<page confidence="0.987616">
146
</page>
<reference confidence="0.999622551724138">
Calder, J. 1988. Paradigmatic Morphology. In Proc.
of the 5th European ACL.
Carpenter, B. 1992. The Logic of Typed Feature
Structures. No. 32Tracts in Theoretical Com-
puter Science. Cambridge: Cambridge University
Press.
Dalrymple, M., R. Ka-
plan, L. Karttunen, K. Koskenniemi, S. Shaio,
and M. Wescoat. 1987. Tools for Morphological
Analysis. Technical Report CSLI-1987-108, CSLI,
Stanford University.
Dorre, J., and A. Eisele. 1989. Determining Consis-
tency of Feature Terms with Distributed Disjunc-
tions. In Proc. of GWAI-89 (15th German Work-
shop on AI), ed. D. Metzing, 270-279. Berlin.
Springer-Verlag.
Emele, M. 1988. fTherlegungen zu einer Two-Level
Morphologie fiir das Deutsche. In Proc. der
4. Osterreichischen Artificial-Intelligence-Tagung
und des WWWS, ed. H. Trost, 156-163. Berlin:
Springer. Informatik-Fachberichte 176.
Gerdemann, D. 1993. Complement Inheritance as
Subcategorization Inheritance. In German Gram-
mar in HPSG, ed. J. Nerbonne, K. Netter, and
C. Pollard. Stanford: CSLI.
Hoperoft, J. E., and J. D. Ullman. 1979. In-
troduction to Automata Theory, Languages, and
Computation. Reading, Massachusetts: Addison-
Wesley.
Kaplan, R., and J. Maxwell. 1988. An Algorithm for
Functional Uncertainty. In Proc. of Coling 1988,
303-305. Budapest.
Koskenniemi, K. 1983. Two-Level Model for Mor-
phological Analysis. In Proc. of IJCAI, 683-685.
Krieger, H.-U. 1993a. Derivation Without Lexi-
cal Rules. In Constraint Propagation, Linguis-
tic Description and Computation, ed. R. Johnson,
M. Rosner, and C. Rupp. Academic Press.
Krieger, H.-U. 1993b. Representing and Pro-
cessing Finite Automata Within Typed Fea-
ture Formalisms. Technical report, Deutsches
Forschungsinstitut far Ki:mstliche Intelligenz,
Saarbriicken, Germany.
Krieger, H.-U., and J. Nerbonne. 1992. Feature-
Based Inheritance Networks for Computational
Lexicons. In Default Inheritance within
Unification-Based Approaches to the Lexicon, ed.
T. Briscoe, A. Copestake, and V. de Paiva. Cam-
bridge: Cambridge University Press. Also DFKI
Research Report RR-91-31.
Matthews, P. 1972. Inflectional Morphology: A The-
oretical Study Based on Aspects of Latin Verb
Conjugation. Cambridge, England: Cambridge
University Press.
Nerbonne, J. 1992. Feature-Based Lexicons-
An Example and a Comparison to DATR. In
Beitrage des ASL-Lexikon-Workshops, Wandlitz
(bei Berlin), ed. D. Reimann, 36-49. also DFKI
RR-92-04.
Pollard, C., and I. Sag. 1987. Information-Based
Syntax and Semantics, Vol.]: Stanford: CSLI.
Reinhard, S., and D. Gibbon. 1991. Prosodic In-
heritance and Morphological Generalizations. In
Proc. of the 6th European ACL, 131-137.
Riehemann, S. 1993. Word Formation in Lexical
Type Hierarchies. A Case Study of bar-Adjectives
in German. Master&apos;s thesis, Eberhard-Karls-
Universitat Tübingen, Seminar fiir Sprachwis-
senschaft.
Ritchie, G. D., G. J. Russell, A. W. Black, and S. G.
Pulman. 1992. Computational Morphology: Prac-
tical Mechanisms for the English Lexicon. Cam-
bridge: MIT Press.
Smollca, G. 1988. A Feature Logic with Subsorts.
Technical Report 33, WT LILOG-IBM Germany.
Sproat, R. 1992. Morphology and Computation.
Cambridge: MIT Press.
Trost, H. 1990. The Application of Two-Level Mor-
phology to Non-concatenative German Morphol-
ogy. In Proc. of COLING, 371-376.
Trost, H. 1991. X2MORF: A Morphological Com-
ponent Based on Augmented Two-Level Mor-
phology. Technical Report RR-91-04, DFKI,
Saarbriicken, Germany.
Tzoukermann, E., and M. Libermann. 1990. A
Finite-State Morphological Processor for Spanish.
In Proc. of COLING, Vol. 3.
</reference>
<page confidence="0.998099">
147
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.000209">
<title confidence="0.761891">FEATURE-BASED ALLOMORPHY* Hans-Ulrich Krieger Hannes Pirker</title>
<author confidence="0.547133">German Research Center for</author>
<affiliation confidence="0.911041">Artificial Intelligence (DFKI)</affiliation>
<address confidence="0.802091">Stuhlsatzenhausweg 3 W-66 Saarbriicken 11, Germany</address>
<email confidence="0.994996">krieger©dfki.uni-sb.de</email>
<email confidence="0.994996">pirker©dfki.uni-sb.de</email>
<author confidence="0.914653">John Nerbonne</author>
<note confidence="0.843366166666667">Alfa Informatica, P.O.Box 716 Oude Kijk in &apos;t Jatstraat 41 Rijksuniversiteit Groningen NL 9700 AS Groningen, Holland nerbonne©let.rug.n1 (1</note>
<abstract confidence="0.971711309701494">Morphotactics and allomorphy are usually modeled in different components, leading to interface problems. To describe both uniformly, we define finite automata (FA) for allomorphy in the same feature description language used for morphotactics. Nonphonologically conditioned allomorphy is problematic in FA models but submits readily to treatment in a uniform formalism. 1 Background and Goals ALLOMORPHY or MORPHOPHONEMICS describes the variation we find among the different forms of a morpheme. For instance, the German secperson singular present ending three allomorphs, -est, -t, by the stem it combines with. &apos;say&apos; pray&amp;quot;mix&apos; ) lsg pres ind 2sg pres ind 3sg pres ind sag+e bet+e bet+est bet+et mix+e sag+st mix+t sag+t mix+t MORPHOTACTICS describes the arrangement of morphs in words, including, e.g., the properties it is a suffix (and thus follows the stem it combines with), and that it combines with verbs. While allomorphy is normally described in finite automata (FA), morphotactics is generally described in syntax-oriented models, e.g., CFGs or feature-based grammars. The present paper describes both allomorphy and morphotactics in a feature-based language like that of Head-Driven Phrase Structure Grammar (HPSG) (Pollard and Sag 1987). This work was supported by research grant ITW 9002 0 from the German Bundesministerium fiir Forschung und Technologie to the DFKI DISCO project. We are grateful to an anonymous ACL reviewer for helpful comments. The technical kernel of the paper is a featuredefinition of While it is unsurprising that the languages defined by FA may also be defined by feature description languages (FDL), our reduction goes beyond this, showing how the FA themselves may be defined. The significance of specifying the FA and not merely the language it generates is that it allows us to use FA technology in processing allomorphy, even while keeping the interface to other grammar components maximally transparent (i.e., there is NO interface—all linguistic information is specified via FDL). Our motivation for exploring this application of typed feature logic is the opportunity it provides for integrating in a single descriptive formalism not only (i) allomorphic and morphotactic information but also (ii) concatenative and non-concatenative allomorphy. The latter is particularly useful when concatenative and non-concatenative allomorphy coexists in a single language, as it does, e.g., in German. 2 Finite Automata as Typed Feature Structures FA A is defined by a 5-tuple (Q,E, F), a finite set of STATES, finite IN- ALPHABET, -+ TRAN- FUNCTION, E INITIAL STATE, C Q set of FINAL For reasons of simplicity and space, we only refer to the simplest form of FA, viz., DETERMIN- ISTIC finite automata without c-moves which consume exactly one input symbol at a time. This is of course not a restriction w.r.t. expressivity: given an arbitrary automaton, we always construct a deterministic, equiva- Krieger for the details and several extensions. assume a familiarity with automata theory (e.g., Hoperoft and Ullman 1979). 140 lent one which recognizes the same language (see Hoperoft and Ullman 1979). Fortunately, our approach is also capable of representing and processing directly non-deterministic FA with cmoves and allows for edges which are multiplesymbol consumers. Specifying an automaton in our approach introducing for every state possibly recursive feature type with the same name as will call such a type a the attributes NEXT, appropriate for a configuration, where disjunctively the outgoing edges of successor states of symbols which remain on the input list when Note that a configuration does not model just a state of the automaton, but an entire description at a point in computation. proto-config now define two natural subtypes of protofirst one represents the non-final \ F. we assume that exactly one input symbol is consumed every time an edge is taken, we are allowed to separate the input list into the first element and the rest list in order to structure-share the first element with consumed input symbol) and to pass the rest list one level deeper to the next state. (3) non-final-config NEXT1INPUT INPUT ( The other subtype encodes the final states of possess no outgoing edges and therefore no successor states. To cope with this fact, we a special subtype of T, called , which is incompatible with every other type. In addition, successfully reaching a final state with no outgoing edge implies that the input list is empty. proto-configl (4) final-config INPUT ( ) that not restricted in bearing atomic symbols, but can also be labeled with complex ones, i.e., with a possibly underspecified feature structure (for instance in the case of 2-level morphology—see below). 1: A finite automaton the = (a + c. Of course, there will be final states with outgoing edges, but such states are subtypes of the specification: non-final-config V final-config To make the idea more concrete, let us study a very small example, viz., the FA A (see Figure 1). A consists of the two states X and Y, which we define the types Y, where (7) is only an instantiation of In order to depict the states perspicuously, we make use of DISJUNCTIONS. DOrre and Eisele 1989 and Backofen et al. 1990 introduce distributed disjunctions because they (normally) allow more efficient processing of disjunctions, sometimes obviating the need to expand to disjunctive normal form. They add no expressive power to a feature formalism (assuming it has disjunction), but abbreviate some otherwise prolix disjunctions: a V V )3} PATH3 [ . ] PATH3 [ ] } The two disjunctions in the feature structure on the left bear the same name &apos;$1&apos;, indicating that they are a single alternation. The sets of disjuncts named covary, taken in order. This may be seen in the right-hand side of the equivalence.&apos; We employ distributed disjunctions below (6) to capture the covariation between edges and of advantages of distributed disjunctions may be seen in the artificial example above. First, co-varying but nonidentical elements can be identified as such, even if they occur remotely from one another in structure, and second, features structures are abbreviated. The amount of abbreviation depends on the number of distributed disjunctions, lengths of the paths at least some competing formalisms—on the size of remaining structure (cf. E. —7 proto-config fl 2 2 ,1 PATH3 [ ] 141 their successor states: if a is taken, we must the type vice versa), if used, again type if chosen, choose the type Y. b V c} si{X V Y} an FA the input or not is equivalent in our approach to the question of FEATURE TERM CONSISTENCY: if we wish to know whether w (a list of input symbols) will recognized by must EXPAND the type is associated with the initial state go of say that its is Using the terminology of Carpenter 1992: (8) must be a TOTALLY WELL-TYPED feature structure. (8) w Coming back to our example (see Figure 1), might ask whether to We can decide this question, by expanding the (a , b , Or will lead us to the following consistent feature structure which moreover represents, for free, the comrecognition history of all its solutions in the FA. Note that this special form of type expansion will always terminate, either with a unification failure (A does not accept w) or with a fully expanded feature structure, representing a successful recognition. This idea leads us to the following ACCEPTANCE CRITERION: E (9) w [f INPUT (&gt;1] E F Notice too that the acceptance criterion does not need to be checked explicitly—it&apos;s only a logical specification of the conditions under which a word is accepted by an FA. Rather the effects of (10) are encoded in the type specifications of states (subtypes of Now that we have demonstrated the featurebased encoding of automata, we can abbreviate them, using regular expressions as &amp;quot;feature templates&amp;quot; to stand for the initial states of the automaton derived from them as above.&apos; For example, we might write a feature specification + c] designate words of the form accepted by our example automaton. As a nice by-product of our encoding technique, we can show that unification, disjunction, and negation in the underlying feature logic directly correspond to the intersection, union, and complementation of FA. Note that this statement can be easily proved when assuming a classical set-theoretical semantics for feature structures (e.g., Smolka 1988). To give the flavor of how this is accomplished, consider the two regexpressions Li = = model them via six types, one for each state of automata. The initial state of is £2 is intersection of Zi and £2 is given the unification of A and to the following structure: X A ai A 3} T = a T x A whether w belongs to fl is equivalent to the satisfiability (consistency) of AA , where type expansion yields a decision procedure. The same argumentation holds for the union and complementation of FA. It has to be noted that the intersection and complementation of FA via unification do not work in general &apos;Template&apos; is a mild abuse of terminology since we intend not only to designate the type corresponding to the initial state of automaton, but also to suggest what other types are accessible. a X EDGE fl b X Y EDGE NEXT INPUT 6 ( ) ( • ) X EDGE</abstract>
<affiliation confidence="0.69860775">NEXT INPUT INPUT INPUT (</affiliation>
<note confidence="0.942594181818182">142 for FA with &amp;moves (Ritchie et al. 1992, 33-35). This restriction is due to the fact, that the intersected FA must run &amp;quot;in sync&amp;quot; (Sproat 1992, 139-140). The following closure properties are demonstrated fairly directly. Ai = and = 90, F2)• Ai =-&amp;quot;q0 Al U A2 V</note>
<abstract confidence="0.973112757575758">Ai In addition, a weak form of functional uncertainty (Kaplan and Maxwell 1988), represented through recursive type specifications, is appropriate for the expression also concatenation and Kleene closure of FA. Krieger 19936 provides proofs using auxiliary definitions and apparatus we lack space for here. 3 Allomorphy The focus of this section lies in the illustration of the proposal above and in the demonstration of some benefits that can be drawn from the integration of allomorphy and morphotactics; we eschew here the discussion of alternative theories and concentrate on inflectional morphology. We describe inflection using a word-andparadigm (WP) specification of morphotactics (Matthews 1972) and a two-level treatment of allomorphy (Koskenniemi 1983). We also indicate some potential advantages of mixed models allomorphy—finite state and in FDL FDL morphotactics (Trost 1991, Krieger and Nerbonne 1992 on derivation); alternative models are also available. Krieger and Nerbonne 1992 propose an of inflection. The basic idea is to characterize all the elements of a paradigm as alternative specifications of abstract lexemes. Technically, this is realized through the specification of large disjunctions which unify with lexeme specifications. The choice of two-level allomorphy is justified both by the simplicity of two-level descriptions and by their status as a &amp;quot;lingua franca&amp;quot; among computational morphologists. Two-level analyses in FDLs may also prove advantageous if they simplify the potential compilation into a hybrid two-level approach of the kind described in Trost 1991. three elements of the paradigm in (1) would be described by the distributed disjunction in (13). (13) weak-paradigm word append(E1 STEM MORPH (+,e)V (+,t) SYNILOCIHEADIAGR sill V2V3} treatment provides a seamless interface to syntactic/semantic information, and realize the goal of representing linguistic knowledge in a single formalism (Pollard and Sag 1987). Nevertheless, the model lacks a treatment allomorphy. The various allomorphs of in (1) are not distinguished in the FDL, and Krieger and Nerbonne 1992 foresaw an interface to an external module for allomorphy. It would be possible—but scientifically poor—to distinguish all of the variants at the level of morphotactics, providing a brute-force solution and multiplying paradigms greatly.&apos; The characterization in Section 2 above allows us to formuthe missing allomorphy component. Two-level morphology has become popular because it is a declarative, bidirectional and efficient means of treating allomorphy (see</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>R Backofen</author>
<author>L Euler</author>
<author>G Gorz</author>
</authors>
<title>Towards the Integration of Functions, Relations and Types in an Al Programming Language. In</title>
<date>1990</date>
<booktitle>Proc. of GWA1-90.</booktitle>
<publisher>Springer.</publisher>
<location>Berlin.</location>
<contexts>
<context position="6167" citStr="Backofen et al. 1990" startWordPosition="999" endWordPosition="1002">ure 1: A finite automaton A recognizing the language L(A) = (a + b)* c. Of course, there will be final states with outgoing edges, but such states are subtypes of the following DISJUNCTIVE type specification: (5) config non-final-config V final-config To make the idea more concrete, let us study a very small example, viz., the FA A (see Figure 1). A consists of the two states X and Y, from which we define the types X and Y, where Y (7) is only an instantiation of final-config. In order to depict the states perspicuously, we shall make use of DISTRIBUTED DISJUNCTIONS. DOrre and Eisele 1989 and Backofen et al. 1990 introduce distributed disjunctions because they (normally) allow more efficient processing of disjunctions, sometimes obviating the need to expand to disjunctive normal form. They add no expressive power to a feature formalism (assuming it has disjunction), but abbreviate some otherwise prolix disjunctions: [[PATHI {s1 a V b} PATH2{ia V )3} PATH3 [ . ] PATHI b PATH2 )5&apos; PATH3 [ ] } The two disjunctions in the feature structure on the left bear the same name &apos;$1&apos;, indicating that they are a single alternation. The sets of disjuncts named covary, taken in order. This may be seen in the right-ha</context>
</contexts>
<marker>Backofen, Euler, Gorz, 1990</marker>
<rawString>Backofen, R., L. Euler, and G. Gorz. 1990. Towards the Integration of Functions, Relations and Types in an Al Programming Language. In Proc. of GWA1-90. Berlin. Springer.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Bear</author>
</authors>
<title>A Morphological Recognizer with Syntactic and Phonological Rules.</title>
<date>1986</date>
<booktitle>In Proc. of COLING,</booktitle>
<pages>272--276</pages>
<contexts>
<context position="18933" citStr="Bear 1986" startWordPosition="3154" endWordPosition="3155">ived its original phonological motivation. Therefore some allomorphic rules 9 7T* denotes the Kleene closure over alphabet ir and A the complement of A with respect to r. (20) allomorphy INPUT MORPHIFORM [ El El {s ,t} 144 are restricted in nonphonological ways, applying only to certain word classes, so that some stems admit idiosyncratic exceptions with respect to the applicability of rules (see Bear 1988, Emele 1988, Trost 1991). To overcome the first difficulty, a number of researchers have suggested augmenting FA with &amp;quot;word grammars&amp;quot;, expressed in terms of feature formalisms like PATR II (Bear 1986) or HPSG (Trost 1990). Our proposal follows theirs, improving only on the degree to which morphotactics may be integrated with allomorphy. See Krieger and Nerbonne 1992 for proposals for treating morphotactics in typed feature systems. We illustrate how the FDL approach overcomes the last two difficulties in a concrete case of nonphonologically motivated allomorphy. German epenthesizes schwa (&lt; e &gt;) at morph boundaries, but in a way which is sensitive to morphological environments, and which thus behaves differently in adjectives and verbs. The data in (22) demonstrates some of these differenc</context>
</contexts>
<marker>Bear, 1986</marker>
<rawString>Bear, J. 1986. A Morphological Recognizer with Syntactic and Phonological Rules. In Proc. of COLING, 272-276.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Bear</author>
</authors>
<title>Morphology with Two-Level Rules and Negative Rule Features.</title>
<date>1988</date>
<booktitle>In Proc. of COLING,</booktitle>
<pages>28--31</pages>
<contexts>
<context position="18732" citStr="Bear 1988" startWordPosition="3123" endWordPosition="3124">only be sensitive to phonological contexts (including word and morpheme boundaries), and apply to all forms where these contexts hold. In fact, allomorphic variation is often &amp;quot;fossilized&amp;quot;, having outlived its original phonological motivation. Therefore some allomorphic rules 9 7T* denotes the Kleene closure over alphabet ir and A the complement of A with respect to r. (20) allomorphy INPUT MORPHIFORM [ El El {s ,t} 144 are restricted in nonphonological ways, applying only to certain word classes, so that some stems admit idiosyncratic exceptions with respect to the applicability of rules (see Bear 1988, Emele 1988, Trost 1991). To overcome the first difficulty, a number of researchers have suggested augmenting FA with &amp;quot;word grammars&amp;quot;, expressed in terms of feature formalisms like PATR II (Bear 1986) or HPSG (Trost 1990). Our proposal follows theirs, improving only on the degree to which morphotactics may be integrated with allomorphy. See Krieger and Nerbonne 1992 for proposals for treating morphotactics in typed feature systems. We illustrate how the FDL approach overcomes the last two difficulties in a concrete case of nonphonologically motivated allomorphy. German epenthesizes schwa (&lt; e</context>
</contexts>
<marker>Bear, 1988</marker>
<rawString>Bear, J. 1988. Morphology with Two-Level Rules and Negative Rule Features. In Proc. of COLING, 28-31.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S Bird</author>
</authors>
<title>Finite-State Phonology in HPSG.</title>
<date>1992</date>
<booktitle>In Proc. of COLING,</booktitle>
<pages>74--80</pages>
<contexts>
<context position="22627" citStr="Bird 1992" startWordPosition="3736" endWordPosition="3737">hers, suggest future directions, and provide a summary. 4.1 Comparison to other Work Computational morphology is a large and active field, as recent textbooks (Sproat 1992 and Ritchie et al. 1992) testify. This impedes the identification of particularly important predecessors, among whom nonetheless three stand out. First, Trost 1991&apos;s use of two-level morphology in combination verbal rule inherited from the more general adjectival rule, but pursuing this here would take us somewhat afield. 145 with feature-based filters was an important impetus. Second, researchers at Edinburgh (Calder 1988, Bird 1992) first suggested using FDLs in phonological and morphological description, and Bird 1992 suggests describing FA in FDL (without showing how they might be so characterized, however—in particular, providing no FDL definition of what it means for an FA to accept a string). Third, Cahill 1990 posed the critical question, viz., how is one to link the work in lexical inheritance (on morphotactics) with that in finitestate morphology (on allomorphy). This earlier work retained a separation of formalisms for allomorphy (MOLUSC) and morphotactics (DATR). Cahill 1993 goes on to experiment with assuming </context>
<context position="24883" citStr="Bird 1992" startWordPosition="4099" endWordPosition="4100">ted and processable in typed feature logic. There are several reasons for developing this approach to morphology. First, we prefer the GENERALITY of a system in which linguistic knowledge of all sorts may be expressed—at least as long as we do not sacrifice processing efficiency. This is an overarching goal of HPSG (Pollard and Sag 1987)—in which syntax and semantics is described in a feature formalism, and in which strides toward descriptions of morphotactics (Krieger 1993a, Riehemann 1993, &amp;quot;Cf. Reinhard and Gibbon 1991 for another sort of DATR-based allomorphy Gerdemann 1993) and phonology (Bird 1992) have been taken. This work is the first to show how allomorphy may be described here. The proposal here would allow one to describe segments using features, as well, but we have not explored this opportunity for reasons of space. Second, the uniform formalism allows the exact and more transparent specification of dependencies which span modules of otherwise different formalisms. Obviously interesting cases for the extension of feature-based descriptions to other areas are those involving stress and intonation—where phonological properties can determine the meaning (via focus) and even syntact</context>
</contexts>
<marker>Bird, 1992</marker>
<rawString>Bird, S. 1992. Finite-State Phonology in HPSG. In Proc. of COLING, 74-80.</rawString>
</citation>
<citation valid="true">
<authors>
<author>L J Cahill</author>
</authors>
<title>Syllable-Based Morphology.</title>
<date>1990</date>
<booktitle>In Proc. of COLING,</booktitle>
<pages>48--53</pages>
<contexts>
<context position="18021" citStr="Cahill 1990" startWordPosition="3011" endWordPosition="3012">enthesis is obligatory in the environment specified and the latter two that each half of the environment specification is necessary.9 (18) epenth-1 {allomorphy [MORPH [FORM Or* ft ,d} + :0 {23,0 r*)]] (19) epenth-2 {allomorphy MORPH [FORM (r* [(21) epenth-3 a-- allomorphy MORPH [FORM (sr* It , d} +:e 3.4 Limits of Pure FA Morphology Finite-state morphology has been criticized (i) for the strict finite-stateness of its handling of morphotactics (Sproat 1992; 43-66); (ii) for making little or no use of the notion of inflectional paradigms and inheritance relations between morphological classes (Cahill 1990); and (iii) for its strict separation of phonology from morphology—i.e., standard two-level rules can only be sensitive to phonological contexts (including word and morpheme boundaries), and apply to all forms where these contexts hold. In fact, allomorphic variation is often &amp;quot;fossilized&amp;quot;, having outlived its original phonological motivation. Therefore some allomorphic rules 9 7T* denotes the Kleene closure over alphabet ir and A the complement of A with respect to r. (20) allomorphy INPUT MORPHIFORM [ El El {s ,t} 144 are restricted in nonphonological ways, applying only to certain word class</context>
<context position="22916" citStr="Cahill 1990" startWordPosition="3782" endWordPosition="3783"> nonetheless three stand out. First, Trost 1991&apos;s use of two-level morphology in combination verbal rule inherited from the more general adjectival rule, but pursuing this here would take us somewhat afield. 145 with feature-based filters was an important impetus. Second, researchers at Edinburgh (Calder 1988, Bird 1992) first suggested using FDLs in phonological and morphological description, and Bird 1992 suggests describing FA in FDL (without showing how they might be so characterized, however—in particular, providing no FDL definition of what it means for an FA to accept a string). Third, Cahill 1990 posed the critical question, viz., how is one to link the work in lexical inheritance (on morphotactics) with that in finitestate morphology (on allomorphy). This earlier work retained a separation of formalisms for allomorphy (MOLUSC) and morphotactics (DATR). Cahill 1993 goes on to experiment with assuming all of the allomorphic specification into the lexicon, in just the spirit proposed here.11 Our work differs from this later work (i) in that we use FDL while she uses DATR, which are similar but not identical (cf. Nerbonne 1992); and (ii) in that we have been concerned with showing how th</context>
</contexts>
<marker>Cahill, 1990</marker>
<rawString>Cahill, L. J. 1990. Syllable-Based Morphology. In Proc. of COLING, 48-53.</rawString>
</citation>
<citation valid="true">
<authors>
<author>L J Cahill</author>
</authors>
<title>Morphonology in the Lexicon.</title>
<date>1993</date>
<booktitle>In Proc. of the 7th European ACL,</booktitle>
<pages>87--96</pages>
<contexts>
<context position="23190" citStr="Cahill 1993" startWordPosition="3825" endWordPosition="3826">esearchers at Edinburgh (Calder 1988, Bird 1992) first suggested using FDLs in phonological and morphological description, and Bird 1992 suggests describing FA in FDL (without showing how they might be so characterized, however—in particular, providing no FDL definition of what it means for an FA to accept a string). Third, Cahill 1990 posed the critical question, viz., how is one to link the work in lexical inheritance (on morphotactics) with that in finitestate morphology (on allomorphy). This earlier work retained a separation of formalisms for allomorphy (MOLUSC) and morphotactics (DATR). Cahill 1993 goes on to experiment with assuming all of the allomorphic specification into the lexicon, in just the spirit proposed here.11 Our work differs from this later work (i) in that we use FDL while she uses DATR, which are similar but not identical (cf. Nerbonne 1992); and (ii) in that we have been concerned with showing how the standard model of allomorphy (FA) may be assumed into the inheritance hierarchy of the lexicon, while Cahill has introduced syllable-based models. 4.2 Future Work At present only the minimal examples in Section 2 above have actually been implemented, and we are interested</context>
</contexts>
<marker>Cahill, 1993</marker>
<rawString>Cahill, L. J. 1993. Morphonology in the Lexicon. In Proc. of the 7th European ACL, 87-96.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Calder</author>
</authors>
<title>Paradigmatic Morphology.</title>
<date>1988</date>
<booktitle>In Proc. of the 5th European ACL.</booktitle>
<contexts>
<context position="22615" citStr="Calder 1988" startWordPosition="3734" endWordPosition="3735"> vis-à-vis others, suggest future directions, and provide a summary. 4.1 Comparison to other Work Computational morphology is a large and active field, as recent textbooks (Sproat 1992 and Ritchie et al. 1992) testify. This impedes the identification of particularly important predecessors, among whom nonetheless three stand out. First, Trost 1991&apos;s use of two-level morphology in combination verbal rule inherited from the more general adjectival rule, but pursuing this here would take us somewhat afield. 145 with feature-based filters was an important impetus. Second, researchers at Edinburgh (Calder 1988, Bird 1992) first suggested using FDLs in phonological and morphological description, and Bird 1992 suggests describing FA in FDL (without showing how they might be so characterized, however—in particular, providing no FDL definition of what it means for an FA to accept a string). Third, Cahill 1990 posed the critical question, viz., how is one to link the work in lexical inheritance (on morphotactics) with that in finitestate morphology (on allomorphy). This earlier work retained a separation of formalisms for allomorphy (MOLUSC) and morphotactics (DATR). Cahill 1993 goes on to experiment wi</context>
</contexts>
<marker>Calder, 1988</marker>
<rawString>Calder, J. 1988. Paradigmatic Morphology. In Proc. of the 5th European ACL.</rawString>
</citation>
<citation valid="true">
<authors>
<author>B Carpenter</author>
</authors>
<title>The Logic of Typed Feature Structures. No. 32Tracts in Theoretical Computer Science. Cambridge:</title>
<date>1992</date>
<publisher>Cambridge University Press.</publisher>
<contexts>
<context position="8014" citStr="Carpenter 1992" startWordPosition="1331" endWordPosition="1332">EDGE fl 2 2 ,1 [ PATHI a PATH2 a PATH3 [ ] 141 their successor states: if a is taken, we must take the type X (and vice versa), if b is used, use again type X, but if c is chosen, choose the type Y. X:e [non-final-config EDGE gi{aV b V c} NEXT si{X V X V Y} Y [final-config] Whether an FA A ACCEPTS the input or not is equivalent in our approach to the question of FEATURE TERM CONSISTENCY: if we wish to know whether w (a list of input symbols) will be recognized by A, we must EXPAND the type which is associated with the initial state go of A and say that its INPUT is w. Using the terminology of Carpenter 1992: (8) must be a TOTALLY WELL-TYPED feature structure. (8) I. INPUT w Coming back to our example (see Figure 1), we might ask whether abc belongs to .C(A). We can decide this question, by expanding the type X with [INPUT (a , b , Or This will lead us to the following consistent feature structure which moreover represents, for free, the complete recognition history of abc, i.e., all its solutions in the FA. Note that this special form of type expansion will always terminate, either with a unification failure (A does not accept w) or with a fully expanded feature structure, representing a success</context>
</contexts>
<marker>Carpenter, 1992</marker>
<rawString>Carpenter, B. 1992. The Logic of Typed Feature Structures. No. 32Tracts in Theoretical Computer Science. Cambridge: Cambridge University Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Dalrymple</author>
<author>R Kaplan</author>
<author>L Karttunen</author>
<author>K Koskenniemi</author>
<author>S Shaio</author>
<author>M Wescoat</author>
</authors>
<title>Tools for Morphological Analysis.</title>
<date>1987</date>
<tech>Technical Report CSLI-1987-108,</tech>
<institution>CSLI, Stanford University.</institution>
<contexts>
<context position="15318" citStr="Dalrymple et al. 1987" startWordPosition="2557" endWordPosition="2560">laut do not show epenthesis): 7Tzoukermann and Libermann 1990 show that multiplying paradigms need not degrade performance, however. 143 (14) e-epenthesis in the bet- case :e {d,t} {s,t} s-deletion in the mix- case s : 0 4* {s, z, ch} : t The colon `:&apos; indicates a correspondence between lexical and surface levels. Thus the first rule states that a lexical morph boundary + must correspond to a surface e if it occurs after d or I and before s or I. The second specifies when lexical s is deleted (corresponds to surface 0). Two-level rules of this sort are then normally compiled into transducers (Dalrymple et al. 1987, p.35-45). 3.3 FDL Specification of Two-Level Morphology Two-level descriptions of allomorphy can be specified in FDLs straightforwardly if we model not transducers, but rather two-level acceptors (of strings of symbol pairs), following Ritchie et al. 1992. We therefore employ FA over an alphabet consisting of pairs of symbols rather than single symbols.8 The encoding of these FA in our approach requires only replacing the alphabet of atomic symbols with an alphabet of feature structures, each of which bears the attributes LEX and SURF. A pair of segments appearing as values of these features</context>
</contexts>
<marker>Dalrymple, Kaplan, Karttunen, Koskenniemi, Shaio, Wescoat, 1987</marker>
<rawString>Dalrymple, M., R. Kaplan, L. Karttunen, K. Koskenniemi, S. Shaio, and M. Wescoat. 1987. Tools for Morphological Analysis. Technical Report CSLI-1987-108, CSLI, Stanford University.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Dorre</author>
<author>A Eisele</author>
</authors>
<title>Determining Consistency of Feature Terms with Distributed Disjunctions.</title>
<date>1989</date>
<booktitle>In Proc. of GWAI-89 (15th German Workshop on AI), ed. D. Metzing,</booktitle>
<pages>270--279</pages>
<publisher>Springer-Verlag.</publisher>
<location>Berlin.</location>
<marker>Dorre, Eisele, 1989</marker>
<rawString>Dorre, J., and A. Eisele. 1989. Determining Consistency of Feature Terms with Distributed Disjunctions. In Proc. of GWAI-89 (15th German Workshop on AI), ed. D. Metzing, 270-279. Berlin. Springer-Verlag.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Emele</author>
</authors>
<title>fTherlegungen zu einer Two-Level Morphologie fiir das Deutsche.</title>
<date>1988</date>
<booktitle>In Proc. der 4. Osterreichischen Artificial-Intelligence-Tagung und</booktitle>
<pages>156--163</pages>
<editor>des WWWS, ed. H. Trost,</editor>
<publisher>Springer. Informatik-Fachberichte</publisher>
<location>Berlin:</location>
<contexts>
<context position="18744" citStr="Emele 1988" startWordPosition="3125" endWordPosition="3126">sitive to phonological contexts (including word and morpheme boundaries), and apply to all forms where these contexts hold. In fact, allomorphic variation is often &amp;quot;fossilized&amp;quot;, having outlived its original phonological motivation. Therefore some allomorphic rules 9 7T* denotes the Kleene closure over alphabet ir and A the complement of A with respect to r. (20) allomorphy INPUT MORPHIFORM [ El El {s ,t} 144 are restricted in nonphonological ways, applying only to certain word classes, so that some stems admit idiosyncratic exceptions with respect to the applicability of rules (see Bear 1988, Emele 1988, Trost 1991). To overcome the first difficulty, a number of researchers have suggested augmenting FA with &amp;quot;word grammars&amp;quot;, expressed in terms of feature formalisms like PATR II (Bear 1986) or HPSG (Trost 1990). Our proposal follows theirs, improving only on the degree to which morphotactics may be integrated with allomorphy. See Krieger and Nerbonne 1992 for proposals for treating morphotactics in typed feature systems. We illustrate how the FDL approach overcomes the last two difficulties in a concrete case of nonphonologically motivated allomorphy. German epenthesizes schwa (&lt; e &gt;) at morph</context>
</contexts>
<marker>Emele, 1988</marker>
<rawString>Emele, M. 1988. fTherlegungen zu einer Two-Level Morphologie fiir das Deutsche. In Proc. der 4. Osterreichischen Artificial-Intelligence-Tagung und des WWWS, ed. H. Trost, 156-163. Berlin: Springer. Informatik-Fachberichte 176.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D Gerdemann</author>
</authors>
<title>Complement Inheritance as Subcategorization Inheritance. In German Grammar</title>
<date>1993</date>
<editor>in HPSG, ed. J. Nerbonne, K. Netter, and C. Pollard. Stanford:</editor>
<publisher>CSLI.</publisher>
<contexts>
<context position="24857" citStr="Gerdemann 1993" startWordPosition="4095" endWordPosition="4096">treatment of allomorphy formulated and processable in typed feature logic. There are several reasons for developing this approach to morphology. First, we prefer the GENERALITY of a system in which linguistic knowledge of all sorts may be expressed—at least as long as we do not sacrifice processing efficiency. This is an overarching goal of HPSG (Pollard and Sag 1987)—in which syntax and semantics is described in a feature formalism, and in which strides toward descriptions of morphotactics (Krieger 1993a, Riehemann 1993, &amp;quot;Cf. Reinhard and Gibbon 1991 for another sort of DATR-based allomorphy Gerdemann 1993) and phonology (Bird 1992) have been taken. This work is the first to show how allomorphy may be described here. The proposal here would allow one to describe segments using features, as well, but we have not explored this opportunity for reasons of space. Second, the uniform formalism allows the exact and more transparent specification of dependencies which span modules of otherwise different formalisms. Obviously interesting cases for the extension of feature-based descriptions to other areas are those involving stress and intonation—where phonological properties can determine the meaning (v</context>
</contexts>
<marker>Gerdemann, 1993</marker>
<rawString>Gerdemann, D. 1993. Complement Inheritance as Subcategorization Inheritance. In German Grammar in HPSG, ed. J. Nerbonne, K. Netter, and C. Pollard. Stanford: CSLI.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J E Hoperoft</author>
<author>J D Ullman</author>
</authors>
<title>Introduction to Automata Theory, Languages, and Computation.</title>
<date>1979</date>
<publisher>AddisonWesley.</publisher>
<location>Reading, Massachusetts:</location>
<contexts>
<context position="3576" citStr="Hoperoft and Ullman 1979" startWordPosition="557" endWordPosition="560">, go, F), where Q is a finite set of STATES, E a finite INPUT ALPHABET, 6:QXE -+ Q is the TRANSITION FUNCTION, qo E Q the INITIAL STATE, and F C Q the set of FINAL STATES.2 For reasons of simplicity and space, we only refer to the simplest form of FA, viz., DETERMINISTIC finite automata without c-moves which consume exactly one input symbol at a time. This is of course not a restriction w.r.t. expressivity: given an arbitrary automaton, we can always construct a deterministic, equiva&apos;See Krieger 1993b for the details and several extensions. 2We assume a familiarity with automata theory (e.g., Hoperoft and Ullman 1979). 140 lent one which recognizes the same language (see Hoperoft and Ullman 1979). Fortunately, our approach is also capable of representing and processing directly non-deterministic FA with cmoves and allows for edges which are multiplesymbol consumers. Specifying an automaton in our approach means introducing for every state gEQa possibly recursive feature type with the same name as q. We will call such a type a CONFIGURATION. Exactly the attributes EDGE, NEXT, and INPUT are appropriate for a configuration, where EDGE encodes disjunctively the outgoing edges of q, NEXT the successor states of</context>
</contexts>
<marker>Hoperoft, Ullman, 1979</marker>
<rawString>Hoperoft, J. E., and J. D. Ullman. 1979. Introduction to Automata Theory, Languages, and Computation. Reading, Massachusetts: AddisonWesley.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Kaplan</author>
<author>J Maxwell</author>
</authors>
<title>An Algorithm for Functional Uncertainty.</title>
<date>1988</date>
<booktitle>In Proc. of Coling</booktitle>
<pages>303--305</pages>
<location>Budapest.</location>
<contexts>
<context position="11224" citStr="Kaplan and Maxwell 1988" startWordPosition="1921" endWordPosition="1924">onding to the initial state of automaton, but also to suggest what other types are accessible. a X EDGE fl b X EDGE 13 c Y NEXT EDGE undef NEXT NEXT undef INPUT 6 ( ) ( • ) OD) X EDGE NEXT INPUT INPUT INPUT ( 142 for FA with &amp;moves (Ritchie et al. 1992, 33-35). This restriction is due to the fact, that the intersected FA must run &amp;quot;in sync&amp;quot; (Sproat 1992, 139-140). The following closure properties are demonstrated fairly directly. Let Ai = (Qi,E1,81,9o,F1) and A2 = (Q2, E2,2, 90, F2)• • Ai n A2 =-&amp;quot;- q0 A 910 • Al U A2 qo V q&apos;o • Ai -=&amp;quot;.&amp;quot; -1,70 In addition, a weak form of functional uncertainty (Kaplan and Maxwell 1988), represented through recursive type specifications, is appropriate for the expression also concatenation and Kleene closure of FA. Krieger 19936 provides proofs using auxiliary definitions and apparatus we lack space for here. 3 Allomorphy The focus of this section lies in the illustration of the proposal above and in the demonstration of some benefits that can be drawn from the integration of allomorphy and morphotactics; we eschew here the discussion of alternative theories and concentrate on inflectional morphology. We describe inflection using a word-andparadigm (WP) specification of morp</context>
</contexts>
<marker>Kaplan, Maxwell, 1988</marker>
<rawString>Kaplan, R., and J. Maxwell. 1988. An Algorithm for Functional Uncertainty. In Proc. of Coling 1988, 303-305. Budapest.</rawString>
</citation>
<citation valid="true">
<authors>
<author>K Koskenniemi</author>
</authors>
<title>Two-Level Model for Morphological Analysis.</title>
<date>1983</date>
<booktitle>In Proc. of IJCAI,</booktitle>
<pages>683--685</pages>
<contexts>
<context position="11908" citStr="Koskenniemi 1983" startWordPosition="2025" endWordPosition="2026"> for the expression also concatenation and Kleene closure of FA. Krieger 19936 provides proofs using auxiliary definitions and apparatus we lack space for here. 3 Allomorphy The focus of this section lies in the illustration of the proposal above and in the demonstration of some benefits that can be drawn from the integration of allomorphy and morphotactics; we eschew here the discussion of alternative theories and concentrate on inflectional morphology. We describe inflection using a word-andparadigm (WP) specification of morphotactics (Matthews 1972) and a two-level treatment of allomorphy (Koskenniemi 1983). We also indicate some potential advantages of mixed models of allomorphy—finite state and other.6 3.1 WP Morphotactics in FDL Several WORD-GRAMMARS use FDL morphotactics (Trost 1991, Krieger and Nerbonne 1992 on derivation); alternative models are also available. Krieger and Nerbonne 1992 propose an FDL-based WP treatment of inflection. The basic idea is to characterize all the elements of a paradigm as alternative specifications of abstract lexemes. Technically, this is realized through the specification of large disjunctions which unify with lexeme specifications. The 6The choice of two-le</context>
</contexts>
<marker>Koskenniemi, 1983</marker>
<rawString>Koskenniemi, K. 1983. Two-Level Model for Morphological Analysis. In Proc. of IJCAI, 683-685.</rawString>
</citation>
<citation valid="true">
<authors>
<author>H-U Krieger</author>
</authors>
<title>Derivation Without Lexical Rules.</title>
<date>1993</date>
<booktitle>In Constraint Propagation, Linguistic Description and Computation,</booktitle>
<editor>ed. R. Johnson, M. Rosner, and C. Rupp.</editor>
<publisher>Academic Press.</publisher>
<contexts>
<context position="3456" citStr="Krieger 1993" startWordPosition="541" endWordPosition="542">es, e.g., in German. 2 Finite Automata as Typed Feature Structures An FA A is defined by a 5-tuple (Q, E, S, go, F), where Q is a finite set of STATES, E a finite INPUT ALPHABET, 6:QXE -+ Q is the TRANSITION FUNCTION, qo E Q the INITIAL STATE, and F C Q the set of FINAL STATES.2 For reasons of simplicity and space, we only refer to the simplest form of FA, viz., DETERMINISTIC finite automata without c-moves which consume exactly one input symbol at a time. This is of course not a restriction w.r.t. expressivity: given an arbitrary automaton, we can always construct a deterministic, equiva&apos;See Krieger 1993b for the details and several extensions. 2We assume a familiarity with automata theory (e.g., Hoperoft and Ullman 1979). 140 lent one which recognizes the same language (see Hoperoft and Ullman 1979). Fortunately, our approach is also capable of representing and processing directly non-deterministic FA with cmoves and allows for edges which are multiplesymbol consumers. Specifying an automaton in our approach means introducing for every state gEQa possibly recursive feature type with the same name as q. We will call such a type a CONFIGURATION. Exactly the attributes EDGE, NEXT, and INPUT are</context>
<context position="11368" citStr="Krieger 1993" startWordPosition="1943" endWordPosition="1944">NPUT 6 ( ) ( • ) OD) X EDGE NEXT INPUT INPUT INPUT ( 142 for FA with &amp;moves (Ritchie et al. 1992, 33-35). This restriction is due to the fact, that the intersected FA must run &amp;quot;in sync&amp;quot; (Sproat 1992, 139-140). The following closure properties are demonstrated fairly directly. Let Ai = (Qi,E1,81,9o,F1) and A2 = (Q2, E2,2, 90, F2)• • Ai n A2 =-&amp;quot;- q0 A 910 • Al U A2 qo V q&apos;o • Ai -=&amp;quot;.&amp;quot; -1,70 In addition, a weak form of functional uncertainty (Kaplan and Maxwell 1988), represented through recursive type specifications, is appropriate for the expression also concatenation and Kleene closure of FA. Krieger 19936 provides proofs using auxiliary definitions and apparatus we lack space for here. 3 Allomorphy The focus of this section lies in the illustration of the proposal above and in the demonstration of some benefits that can be drawn from the integration of allomorphy and morphotactics; we eschew here the discussion of alternative theories and concentrate on inflectional morphology. We describe inflection using a word-andparadigm (WP) specification of morphotactics (Matthews 1972) and a two-level treatment of allomorphy (Koskenniemi 1983). We also indicate some potential advantages of mixed models</context>
<context position="24751" citStr="Krieger 1993" startWordPosition="4080" endWordPosition="4081">33 for an approach to parsing using finite-state acceptors, however. 4.3 Summary This paper proposes a treatment of allomorphy formulated and processable in typed feature logic. There are several reasons for developing this approach to morphology. First, we prefer the GENERALITY of a system in which linguistic knowledge of all sorts may be expressed—at least as long as we do not sacrifice processing efficiency. This is an overarching goal of HPSG (Pollard and Sag 1987)—in which syntax and semantics is described in a feature formalism, and in which strides toward descriptions of morphotactics (Krieger 1993a, Riehemann 1993, &amp;quot;Cf. Reinhard and Gibbon 1991 for another sort of DATR-based allomorphy Gerdemann 1993) and phonology (Bird 1992) have been taken. This work is the first to show how allomorphy may be described here. The proposal here would allow one to describe segments using features, as well, but we have not explored this opportunity for reasons of space. Second, the uniform formalism allows the exact and more transparent specification of dependencies which span modules of otherwise different formalisms. Obviously interesting cases for the extension of feature-based descriptions to other </context>
</contexts>
<marker>Krieger, 1993</marker>
<rawString>Krieger, H.-U. 1993a. Derivation Without Lexical Rules. In Constraint Propagation, Linguistic Description and Computation, ed. R. Johnson, M. Rosner, and C. Rupp. Academic Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>H-U Krieger</author>
</authors>
<title>Representing and Processing Finite Automata Within Typed Feature Formalisms. Technical report, Deutsches Forschungsinstitut far Ki:mstliche Intelligenz,</title>
<date>1993</date>
<location>Saarbriicken, Germany.</location>
<contexts>
<context position="3456" citStr="Krieger 1993" startWordPosition="541" endWordPosition="542">es, e.g., in German. 2 Finite Automata as Typed Feature Structures An FA A is defined by a 5-tuple (Q, E, S, go, F), where Q is a finite set of STATES, E a finite INPUT ALPHABET, 6:QXE -+ Q is the TRANSITION FUNCTION, qo E Q the INITIAL STATE, and F C Q the set of FINAL STATES.2 For reasons of simplicity and space, we only refer to the simplest form of FA, viz., DETERMINISTIC finite automata without c-moves which consume exactly one input symbol at a time. This is of course not a restriction w.r.t. expressivity: given an arbitrary automaton, we can always construct a deterministic, equiva&apos;See Krieger 1993b for the details and several extensions. 2We assume a familiarity with automata theory (e.g., Hoperoft and Ullman 1979). 140 lent one which recognizes the same language (see Hoperoft and Ullman 1979). Fortunately, our approach is also capable of representing and processing directly non-deterministic FA with cmoves and allows for edges which are multiplesymbol consumers. Specifying an automaton in our approach means introducing for every state gEQa possibly recursive feature type with the same name as q. We will call such a type a CONFIGURATION. Exactly the attributes EDGE, NEXT, and INPUT are</context>
<context position="11368" citStr="Krieger 1993" startWordPosition="1943" endWordPosition="1944">NPUT 6 ( ) ( • ) OD) X EDGE NEXT INPUT INPUT INPUT ( 142 for FA with &amp;moves (Ritchie et al. 1992, 33-35). This restriction is due to the fact, that the intersected FA must run &amp;quot;in sync&amp;quot; (Sproat 1992, 139-140). The following closure properties are demonstrated fairly directly. Let Ai = (Qi,E1,81,9o,F1) and A2 = (Q2, E2,2, 90, F2)• • Ai n A2 =-&amp;quot;- q0 A 910 • Al U A2 qo V q&apos;o • Ai -=&amp;quot;.&amp;quot; -1,70 In addition, a weak form of functional uncertainty (Kaplan and Maxwell 1988), represented through recursive type specifications, is appropriate for the expression also concatenation and Kleene closure of FA. Krieger 19936 provides proofs using auxiliary definitions and apparatus we lack space for here. 3 Allomorphy The focus of this section lies in the illustration of the proposal above and in the demonstration of some benefits that can be drawn from the integration of allomorphy and morphotactics; we eschew here the discussion of alternative theories and concentrate on inflectional morphology. We describe inflection using a word-andparadigm (WP) specification of morphotactics (Matthews 1972) and a two-level treatment of allomorphy (Koskenniemi 1983). We also indicate some potential advantages of mixed models</context>
<context position="24751" citStr="Krieger 1993" startWordPosition="4080" endWordPosition="4081">33 for an approach to parsing using finite-state acceptors, however. 4.3 Summary This paper proposes a treatment of allomorphy formulated and processable in typed feature logic. There are several reasons for developing this approach to morphology. First, we prefer the GENERALITY of a system in which linguistic knowledge of all sorts may be expressed—at least as long as we do not sacrifice processing efficiency. This is an overarching goal of HPSG (Pollard and Sag 1987)—in which syntax and semantics is described in a feature formalism, and in which strides toward descriptions of morphotactics (Krieger 1993a, Riehemann 1993, &amp;quot;Cf. Reinhard and Gibbon 1991 for another sort of DATR-based allomorphy Gerdemann 1993) and phonology (Bird 1992) have been taken. This work is the first to show how allomorphy may be described here. The proposal here would allow one to describe segments using features, as well, but we have not explored this opportunity for reasons of space. Second, the uniform formalism allows the exact and more transparent specification of dependencies which span modules of otherwise different formalisms. Obviously interesting cases for the extension of feature-based descriptions to other </context>
</contexts>
<marker>Krieger, 1993</marker>
<rawString>Krieger, H.-U. 1993b. Representing and Processing Finite Automata Within Typed Feature Formalisms. Technical report, Deutsches Forschungsinstitut far Ki:mstliche Intelligenz, Saarbriicken, Germany.</rawString>
</citation>
<citation valid="true">
<authors>
<author>H-U Krieger</author>
<author>J Nerbonne</author>
</authors>
<title>FeatureBased Inheritance Networks for Computational Lexicons.</title>
<date>1992</date>
<booktitle>In Default Inheritance within Unification-Based Approaches to the Lexicon,</booktitle>
<editor>ed. T. Briscoe, A. Copestake, and V. de Paiva. Cambridge:</editor>
<publisher>Cambridge University Press.</publisher>
<note>Also DFKI Research Report RR-91-31.</note>
<contexts>
<context position="12118" citStr="Krieger and Nerbonne 1992" startWordPosition="2055" endWordPosition="2058">es in the illustration of the proposal above and in the demonstration of some benefits that can be drawn from the integration of allomorphy and morphotactics; we eschew here the discussion of alternative theories and concentrate on inflectional morphology. We describe inflection using a word-andparadigm (WP) specification of morphotactics (Matthews 1972) and a two-level treatment of allomorphy (Koskenniemi 1983). We also indicate some potential advantages of mixed models of allomorphy—finite state and other.6 3.1 WP Morphotactics in FDL Several WORD-GRAMMARS use FDL morphotactics (Trost 1991, Krieger and Nerbonne 1992 on derivation); alternative models are also available. Krieger and Nerbonne 1992 propose an FDL-based WP treatment of inflection. The basic idea is to characterize all the elements of a paradigm as alternative specifications of abstract lexemes. Technically, this is realized through the specification of large disjunctions which unify with lexeme specifications. The 6The choice of two-level allomorphy is justified both by the simplicity of two-level descriptions and by their status as a &amp;quot;lingua franca&amp;quot; among computational morphologists. Two-level analyses in FDLs may also prove advantageous if</context>
<context position="13407" citStr="Krieger and Nerbonne 1992" startWordPosition="2252" endWordPosition="2255"> approach of the kind described in Trost 1991. three elements of the paradigm in (1) would be described by the distributed disjunction in (13). (13) weak-paradigm word FORM append(E1 0) STEM MORPH (+,e)V ENDING Ei s,{ (+,s,t)V (+,t) NUM sg SYNILOCIHEADIAGR [ pER sill V2V3} This treatment provides a seamless interface to syntactic/semantic information, and helps realize the goal of representing ALL linguistic knowledge in a single formalism (Pollard and Sag 1987). Nevertheless, the model lacks a treatment of allomorphy. The various allomorphs of -st in (1) are not distinguished in the FDL, and Krieger and Nerbonne 1992 foresaw an interface to an external module for allomorphy. It would be possible—but scientifically poor—to distinguish all of the variants at the level of morphotactics, providing a brute-force solution and multiplying paradigms greatly.&apos; The characterization in Section 2 above allows us to formulate WITHIN FDL the missing allomorphy component. 3.2 Two-Level Allomorphy Two-level morphology has become popular because it is a declarative, bidirectional and efficient means of treating allomorphy (see Sproat 1992 for a comprehensive introduction). In general, two-level descriptions provide constr</context>
<context position="19101" citStr="Krieger and Nerbonne 1992" startWordPosition="3179" endWordPosition="3182">ith respect to r. (20) allomorphy INPUT MORPHIFORM [ El El {s ,t} 144 are restricted in nonphonological ways, applying only to certain word classes, so that some stems admit idiosyncratic exceptions with respect to the applicability of rules (see Bear 1988, Emele 1988, Trost 1991). To overcome the first difficulty, a number of researchers have suggested augmenting FA with &amp;quot;word grammars&amp;quot;, expressed in terms of feature formalisms like PATR II (Bear 1986) or HPSG (Trost 1990). Our proposal follows theirs, improving only on the degree to which morphotactics may be integrated with allomorphy. See Krieger and Nerbonne 1992 for proposals for treating morphotactics in typed feature systems. We illustrate how the FDL approach overcomes the last two difficulties in a concrete case of nonphonologically motivated allomorphy. German epenthesizes schwa (&lt; e &gt;) at morph boundaries, but in a way which is sensitive to morphological environments, and which thus behaves differently in adjectives and verbs. The data in (22) demonstrates some of these differences, comparing epenthesis in phonologically very similar forms. free, adj super frei-Fst frei est (22) free, v 2s pres be+frei-l-st befreist woo, v 2s pres frei+st freis</context>
</contexts>
<marker>Krieger, Nerbonne, 1992</marker>
<rawString>Krieger, H.-U., and J. Nerbonne. 1992. FeatureBased Inheritance Networks for Computational Lexicons. In Default Inheritance within Unification-Based Approaches to the Lexicon, ed. T. Briscoe, A. Copestake, and V. de Paiva. Cambridge: Cambridge University Press. Also DFKI Research Report RR-91-31.</rawString>
</citation>
<citation valid="true">
<authors>
<author>P Matthews</author>
</authors>
<title>Inflectional Morphology: A Theoretical Study Based on Aspects of Latin Verb Conjugation. Cambridge, England:</title>
<date>1972</date>
<publisher>Cambridge University Press.</publisher>
<contexts>
<context position="11849" citStr="Matthews 1972" startWordPosition="2017" endWordPosition="2018">ed through recursive type specifications, is appropriate for the expression also concatenation and Kleene closure of FA. Krieger 19936 provides proofs using auxiliary definitions and apparatus we lack space for here. 3 Allomorphy The focus of this section lies in the illustration of the proposal above and in the demonstration of some benefits that can be drawn from the integration of allomorphy and morphotactics; we eschew here the discussion of alternative theories and concentrate on inflectional morphology. We describe inflection using a word-andparadigm (WP) specification of morphotactics (Matthews 1972) and a two-level treatment of allomorphy (Koskenniemi 1983). We also indicate some potential advantages of mixed models of allomorphy—finite state and other.6 3.1 WP Morphotactics in FDL Several WORD-GRAMMARS use FDL morphotactics (Trost 1991, Krieger and Nerbonne 1992 on derivation); alternative models are also available. Krieger and Nerbonne 1992 propose an FDL-based WP treatment of inflection. The basic idea is to characterize all the elements of a paradigm as alternative specifications of abstract lexemes. Technically, this is realized through the specification of large disjunctions which </context>
</contexts>
<marker>Matthews, 1972</marker>
<rawString>Matthews, P. 1972. Inflectional Morphology: A Theoretical Study Based on Aspects of Latin Verb Conjugation. Cambridge, England: Cambridge University Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Nerbonne</author>
</authors>
<title>Feature-Based LexiconsAn Example and a Comparison to DATR.</title>
<date>1992</date>
<booktitle>In Beitrage des ASL-Lexikon-Workshops,</booktitle>
<pages>92--04</pages>
<editor>(bei Berlin), ed. D. Reimann, 36-49. also DFKI</editor>
<location>Wandlitz</location>
<contexts>
<context position="12118" citStr="Nerbonne 1992" startWordPosition="2057" endWordPosition="2058">lustration of the proposal above and in the demonstration of some benefits that can be drawn from the integration of allomorphy and morphotactics; we eschew here the discussion of alternative theories and concentrate on inflectional morphology. We describe inflection using a word-andparadigm (WP) specification of morphotactics (Matthews 1972) and a two-level treatment of allomorphy (Koskenniemi 1983). We also indicate some potential advantages of mixed models of allomorphy—finite state and other.6 3.1 WP Morphotactics in FDL Several WORD-GRAMMARS use FDL morphotactics (Trost 1991, Krieger and Nerbonne 1992 on derivation); alternative models are also available. Krieger and Nerbonne 1992 propose an FDL-based WP treatment of inflection. The basic idea is to characterize all the elements of a paradigm as alternative specifications of abstract lexemes. Technically, this is realized through the specification of large disjunctions which unify with lexeme specifications. The 6The choice of two-level allomorphy is justified both by the simplicity of two-level descriptions and by their status as a &amp;quot;lingua franca&amp;quot; among computational morphologists. Two-level analyses in FDLs may also prove advantageous if</context>
<context position="13407" citStr="Nerbonne 1992" startWordPosition="2254" endWordPosition="2255"> the kind described in Trost 1991. three elements of the paradigm in (1) would be described by the distributed disjunction in (13). (13) weak-paradigm word FORM append(E1 0) STEM MORPH (+,e)V ENDING Ei s,{ (+,s,t)V (+,t) NUM sg SYNILOCIHEADIAGR [ pER sill V2V3} This treatment provides a seamless interface to syntactic/semantic information, and helps realize the goal of representing ALL linguistic knowledge in a single formalism (Pollard and Sag 1987). Nevertheless, the model lacks a treatment of allomorphy. The various allomorphs of -st in (1) are not distinguished in the FDL, and Krieger and Nerbonne 1992 foresaw an interface to an external module for allomorphy. It would be possible—but scientifically poor—to distinguish all of the variants at the level of morphotactics, providing a brute-force solution and multiplying paradigms greatly.&apos; The characterization in Section 2 above allows us to formulate WITHIN FDL the missing allomorphy component. 3.2 Two-Level Allomorphy Two-level morphology has become popular because it is a declarative, bidirectional and efficient means of treating allomorphy (see Sproat 1992 for a comprehensive introduction). In general, two-level descriptions provide constr</context>
<context position="19101" citStr="Nerbonne 1992" startWordPosition="3181" endWordPosition="3182">to r. (20) allomorphy INPUT MORPHIFORM [ El El {s ,t} 144 are restricted in nonphonological ways, applying only to certain word classes, so that some stems admit idiosyncratic exceptions with respect to the applicability of rules (see Bear 1988, Emele 1988, Trost 1991). To overcome the first difficulty, a number of researchers have suggested augmenting FA with &amp;quot;word grammars&amp;quot;, expressed in terms of feature formalisms like PATR II (Bear 1986) or HPSG (Trost 1990). Our proposal follows theirs, improving only on the degree to which morphotactics may be integrated with allomorphy. See Krieger and Nerbonne 1992 for proposals for treating morphotactics in typed feature systems. We illustrate how the FDL approach overcomes the last two difficulties in a concrete case of nonphonologically motivated allomorphy. German epenthesizes schwa (&lt; e &gt;) at morph boundaries, but in a way which is sensitive to morphological environments, and which thus behaves differently in adjectives and verbs. The data in (22) demonstrates some of these differences, comparing epenthesis in phonologically very similar forms. free, adj super frei-Fst frei est (22) free, v 2s pres be+frei-l-st befreist woo, v 2s pres frei+st freis</context>
<context position="23455" citStr="Nerbonne 1992" startWordPosition="3871" endWordPosition="3872">finition of what it means for an FA to accept a string). Third, Cahill 1990 posed the critical question, viz., how is one to link the work in lexical inheritance (on morphotactics) with that in finitestate morphology (on allomorphy). This earlier work retained a separation of formalisms for allomorphy (MOLUSC) and morphotactics (DATR). Cahill 1993 goes on to experiment with assuming all of the allomorphic specification into the lexicon, in just the spirit proposed here.11 Our work differs from this later work (i) in that we use FDL while she uses DATR, which are similar but not identical (cf. Nerbonne 1992); and (ii) in that we have been concerned with showing how the standard model of allomorphy (FA) may be assumed into the inheritance hierarchy of the lexicon, while Cahill has introduced syllable-based models. 4.2 Future Work At present only the minimal examples in Section 2 above have actually been implemented, and we are interested in attempting more. Second, a compilation into genuine finite state models could be useful. Third, we are concerned that, in restricting ourselves thus far to acceptors over two-level alphabets, we may incur parsing problems, which a more direct approach through f</context>
</contexts>
<marker>Nerbonne, 1992</marker>
<rawString>Nerbonne, J. 1992. Feature-Based LexiconsAn Example and a Comparison to DATR. In Beitrage des ASL-Lexikon-Workshops, Wandlitz (bei Berlin), ed. D. Reimann, 36-49. also DFKI RR-92-04.</rawString>
</citation>
<citation valid="true">
<authors>
<author>C Pollard</author>
<author>I Sag</author>
</authors>
<title>Information-Based Syntax and Semantics,</title>
<date>1987</date>
<publisher>CSLI.</publisher>
<location>Vol.]: Stanford:</location>
<contexts>
<context position="1663" citStr="Pollard and Sag 1987" startWordPosition="237" endWordPosition="240">ind sag+e bet+e mix+e 2sg pres ind sag+st bet+est mix+t 3sg pres ind sag+t bet+et mix+t MORPHOTACTICS describes the arrangement of morphs in words, including, e.g., the properties of -st that it is a suffix (and thus follows the stem it combines with), and that it combines with verbs. While allomorphy is normally described in finite automata (FA), morphotactics is generally described in syntax-oriented models, e.g., CFGs or feature-based grammars. The present paper describes both allomorphy and morphotactics in a feature-based language like that of Head-Driven Phrase Structure Grammar (HPSG) (Pollard and Sag 1987). This work was supported by research grant ITW 9002 0 from the German Bundesministerium fiir Forschung und Technologie to the DFKI DISCO project. We are grateful to an anonymous ACL reviewer for helpful comments. The technical kernel of the paper is a featurebased definition of FA.1 While it is unsurprising that the languages defined by FA may also be defined by feature description languages (FDL), our reduction goes beyond this, showing how the FA themselves may be defined. The significance of specifying the FA and not merely the language it generates is that it allows us to use FA technolog</context>
<context position="13248" citStr="Pollard and Sag 1987" startWordPosition="2226" endWordPosition="2229">mong computational morphologists. Two-level analyses in FDLs may also prove advantageous if they simplify the potential compilation into a hybrid two-level approach of the kind described in Trost 1991. three elements of the paradigm in (1) would be described by the distributed disjunction in (13). (13) weak-paradigm word FORM append(E1 0) STEM MORPH (+,e)V ENDING Ei s,{ (+,s,t)V (+,t) NUM sg SYNILOCIHEADIAGR [ pER sill V2V3} This treatment provides a seamless interface to syntactic/semantic information, and helps realize the goal of representing ALL linguistic knowledge in a single formalism (Pollard and Sag 1987). Nevertheless, the model lacks a treatment of allomorphy. The various allomorphs of -st in (1) are not distinguished in the FDL, and Krieger and Nerbonne 1992 foresaw an interface to an external module for allomorphy. It would be possible—but scientifically poor—to distinguish all of the variants at the level of morphotactics, providing a brute-force solution and multiplying paradigms greatly.&apos; The characterization in Section 2 above allows us to formulate WITHIN FDL the missing allomorphy component. 3.2 Two-Level Allomorphy Two-level morphology has become popular because it is a declarative,</context>
<context position="24612" citStr="Pollard and Sag 1987" startWordPosition="4057" endWordPosition="4060">y incur parsing problems, which a more direct approach through finite-state transducers can avoid (Sproat 1992, p.143). See Ritchie et al. 1992, 19-33 for an approach to parsing using finite-state acceptors, however. 4.3 Summary This paper proposes a treatment of allomorphy formulated and processable in typed feature logic. There are several reasons for developing this approach to morphology. First, we prefer the GENERALITY of a system in which linguistic knowledge of all sorts may be expressed—at least as long as we do not sacrifice processing efficiency. This is an overarching goal of HPSG (Pollard and Sag 1987)—in which syntax and semantics is described in a feature formalism, and in which strides toward descriptions of morphotactics (Krieger 1993a, Riehemann 1993, &amp;quot;Cf. Reinhard and Gibbon 1991 for another sort of DATR-based allomorphy Gerdemann 1993) and phonology (Bird 1992) have been taken. This work is the first to show how allomorphy may be described here. The proposal here would allow one to describe segments using features, as well, but we have not explored this opportunity for reasons of space. Second, the uniform formalism allows the exact and more transparent specification of dependencies </context>
</contexts>
<marker>Pollard, Sag, 1987</marker>
<rawString>Pollard, C., and I. Sag. 1987. Information-Based Syntax and Semantics, Vol.]: Stanford: CSLI.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S Reinhard</author>
<author>D Gibbon</author>
</authors>
<title>Prosodic Inheritance and Morphological Generalizations.</title>
<date>1991</date>
<booktitle>In Proc. of the 6th European ACL,</booktitle>
<pages>131--137</pages>
<contexts>
<context position="24799" citStr="Reinhard and Gibbon 1991" startWordPosition="4085" endWordPosition="4088">finite-state acceptors, however. 4.3 Summary This paper proposes a treatment of allomorphy formulated and processable in typed feature logic. There are several reasons for developing this approach to morphology. First, we prefer the GENERALITY of a system in which linguistic knowledge of all sorts may be expressed—at least as long as we do not sacrifice processing efficiency. This is an overarching goal of HPSG (Pollard and Sag 1987)—in which syntax and semantics is described in a feature formalism, and in which strides toward descriptions of morphotactics (Krieger 1993a, Riehemann 1993, &amp;quot;Cf. Reinhard and Gibbon 1991 for another sort of DATR-based allomorphy Gerdemann 1993) and phonology (Bird 1992) have been taken. This work is the first to show how allomorphy may be described here. The proposal here would allow one to describe segments using features, as well, but we have not explored this opportunity for reasons of space. Second, the uniform formalism allows the exact and more transparent specification of dependencies which span modules of otherwise different formalisms. Obviously interesting cases for the extension of feature-based descriptions to other areas are those involving stress and intonation—</context>
</contexts>
<marker>Reinhard, Gibbon, 1991</marker>
<rawString>Reinhard, S., and D. Gibbon. 1991. Prosodic Inheritance and Morphological Generalizations. In Proc. of the 6th European ACL, 131-137.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S Riehemann</author>
</authors>
<title>Word Formation in Lexical Type Hierarchies. A Case Study of bar-Adjectives in German. Master&apos;s thesis, Eberhard-KarlsUniversitat Tübingen, Seminar fiir Sprachwissenschaft.</title>
<date>1993</date>
<contexts>
<context position="24768" citStr="Riehemann 1993" startWordPosition="4082" endWordPosition="4083">ach to parsing using finite-state acceptors, however. 4.3 Summary This paper proposes a treatment of allomorphy formulated and processable in typed feature logic. There are several reasons for developing this approach to morphology. First, we prefer the GENERALITY of a system in which linguistic knowledge of all sorts may be expressed—at least as long as we do not sacrifice processing efficiency. This is an overarching goal of HPSG (Pollard and Sag 1987)—in which syntax and semantics is described in a feature formalism, and in which strides toward descriptions of morphotactics (Krieger 1993a, Riehemann 1993, &amp;quot;Cf. Reinhard and Gibbon 1991 for another sort of DATR-based allomorphy Gerdemann 1993) and phonology (Bird 1992) have been taken. This work is the first to show how allomorphy may be described here. The proposal here would allow one to describe segments using features, as well, but we have not explored this opportunity for reasons of space. Second, the uniform formalism allows the exact and more transparent specification of dependencies which span modules of otherwise different formalisms. Obviously interesting cases for the extension of feature-based descriptions to other areas are those i</context>
</contexts>
<marker>Riehemann, 1993</marker>
<rawString>Riehemann, S. 1993. Word Formation in Lexical Type Hierarchies. A Case Study of bar-Adjectives in German. Master&apos;s thesis, Eberhard-KarlsUniversitat Tübingen, Seminar fiir Sprachwissenschaft.</rawString>
</citation>
<citation valid="true">
<authors>
<author>G D Ritchie</author>
<author>G J Russell</author>
<author>A W Black</author>
<author>S G Pulman</author>
</authors>
<title>Computational Morphology: Practical Mechanisms for the English Lexicon.</title>
<date>1992</date>
<publisher>MIT Press.</publisher>
<location>Cambridge:</location>
<contexts>
<context position="10852" citStr="Ritchie et al. 1992" startWordPosition="1849" endWordPosition="1852">ability (consistency) of (11) AA XA [INPUT , where type expansion yields a decision procedure. The same argumentation holds for the union and complementation of FA. It has to be noted that the intersection and complementation of FA via unification do not work in general &apos;Template&apos; is a mild abuse of terminology since we intend not only to designate the type corresponding to the initial state of automaton, but also to suggest what other types are accessible. a X EDGE fl b X EDGE 13 c Y NEXT EDGE undef NEXT NEXT undef INPUT 6 ( ) ( • ) OD) X EDGE NEXT INPUT INPUT INPUT ( 142 for FA with &amp;moves (Ritchie et al. 1992, 33-35). This restriction is due to the fact, that the intersected FA must run &amp;quot;in sync&amp;quot; (Sproat 1992, 139-140). The following closure properties are demonstrated fairly directly. Let Ai = (Qi,E1,81,9o,F1) and A2 = (Q2, E2,2, 90, F2)• • Ai n A2 =-&amp;quot;- q0 A 910 • Al U A2 qo V q&apos;o • Ai -=&amp;quot;.&amp;quot; -1,70 In addition, a weak form of functional uncertainty (Kaplan and Maxwell 1988), represented through recursive type specifications, is appropriate for the expression also concatenation and Kleene closure of FA. Krieger 19936 provides proofs using auxiliary definitions and apparatus we lack space for here. </context>
<context position="15575" citStr="Ritchie et al. 1992" startWordPosition="2594" endWordPosition="2597">tes a correspondence between lexical and surface levels. Thus the first rule states that a lexical morph boundary + must correspond to a surface e if it occurs after d or I and before s or I. The second specifies when lexical s is deleted (corresponds to surface 0). Two-level rules of this sort are then normally compiled into transducers (Dalrymple et al. 1987, p.35-45). 3.3 FDL Specification of Two-Level Morphology Two-level descriptions of allomorphy can be specified in FDLs straightforwardly if we model not transducers, but rather two-level acceptors (of strings of symbol pairs), following Ritchie et al. 1992. We therefore employ FA over an alphabet consisting of pairs of symbols rather than single symbols.8 The encoding of these FA in our approach requires only replacing the alphabet of atomic symbols with an alphabet of feature structures, each of which bears the attributes LEX and SURF. A pair of segments appearing as values of these features stand in the lexical-surface correspondence relation denoted by `:&apos; in standard twolevel formalisms. The values of the attributes STEM and ENDING in (13) are then not lists of symbols but rather lists of (underspecified) feature structures. Note that the i</context>
<context position="17154" citStr="Ritchie et al. 1992" startWordPosition="2873" endWordPosition="2876">&amp;quot;] = LEX &amp;quot;+&amp;quot; SURF &amp;quot;e&amp;quot; V 0 &apos;Since our formalisation of FA cannot allow etransitions without losing important properties, we are in fact forced to this position. It is the role of the collection of FA to restrict underspecified lexical representations to those obeying allomorphic constraints. This is the substance of the allomorphy constraint (18), which, together with the Acceptance Criterion (10), guarantees that the input obeys the constraints of the associated (initial states of the) FA. Rules of the sort found in (14) can be directly compiled into FA acceptors over strings of symbol pairs (Ritchie et al. 1992, p.19). Making use of the regular expression notation as templates (introduced in Section 2 above), (19-21) display a compilation of the first rule in (14). Here the composite rule is split up into three different constraints. The first indicates that epenthesis is obligatory in the environment specified and the latter two that each half of the environment specification is necessary.9 (18) epenth-1 {allomorphy [MORPH [FORM Or* ft ,d} + :0 {23,0 r*)]] (19) epenth-2 {allomorphy MORPH [FORM (r* [(21) epenth-3 a-- allomorphy MORPH [FORM (sr* It , d} +:e 3.4 Limits of Pure FA Morphology Finite-sta</context>
<context position="22213" citStr="Ritchie et al. 1992" startWordPosition="3671" endWordPosition="3674"> a strictly phonological basis, making it subject to lexical conditioning. This is illustrated in Figure 2. But note that this example demonstrates not only how feature-based allomorphy can overcome the strictly phonological base of two-level morphology (criticism (iii) above), but it also makes use of the inheritance structure in modern lexicons as well. 4 Conclusions In this section we examine our proposal vis-à-vis others, suggest future directions, and provide a summary. 4.1 Comparison to other Work Computational morphology is a large and active field, as recent textbooks (Sproat 1992 and Ritchie et al. 1992) testify. This impedes the identification of particularly important predecessors, among whom nonetheless three stand out. First, Trost 1991&apos;s use of two-level morphology in combination verbal rule inherited from the more general adjectival rule, but pursuing this here would take us somewhat afield. 145 with feature-based filters was an important impetus. Second, researchers at Edinburgh (Calder 1988, Bird 1992) first suggested using FDLs in phonological and morphological description, and Bird 1992 suggests describing FA in FDL (without showing how they might be so characterized, however—in par</context>
<context position="24134" citStr="Ritchie et al. 1992" startWordPosition="3980" endWordPosition="3983">he standard model of allomorphy (FA) may be assumed into the inheritance hierarchy of the lexicon, while Cahill has introduced syllable-based models. 4.2 Future Work At present only the minimal examples in Section 2 above have actually been implemented, and we are interested in attempting more. Second, a compilation into genuine finite state models could be useful. Third, we are concerned that, in restricting ourselves thus far to acceptors over two-level alphabets, we may incur parsing problems, which a more direct approach through finite-state transducers can avoid (Sproat 1992, p.143). See Ritchie et al. 1992, 19-33 for an approach to parsing using finite-state acceptors, however. 4.3 Summary This paper proposes a treatment of allomorphy formulated and processable in typed feature logic. There are several reasons for developing this approach to morphology. First, we prefer the GENERALITY of a system in which linguistic knowledge of all sorts may be expressed—at least as long as we do not sacrifice processing efficiency. This is an overarching goal of HPSG (Pollard and Sag 1987)—in which syntax and semantics is described in a feature formalism, and in which strides toward descriptions of morphotact</context>
</contexts>
<marker>Ritchie, Russell, Black, Pulman, 1992</marker>
<rawString>Ritchie, G. D., G. J. Russell, A. W. Black, and S. G. Pulman. 1992. Computational Morphology: Practical Mechanisms for the English Lexicon. Cambridge: MIT Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>G Smollca</author>
</authors>
<title>A Feature Logic with Subsorts.</title>
<date>1988</date>
<tech>Technical Report 33, WT LILOG-IBM</tech>
<marker>Smollca, 1988</marker>
<rawString>Smollca, G. 1988. A Feature Logic with Subsorts. Technical Report 33, WT LILOG-IBM Germany.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Sproat</author>
</authors>
<title>Morphology and Computation.</title>
<date>1992</date>
<publisher>MIT Press.</publisher>
<location>Cambridge:</location>
<contexts>
<context position="10954" citStr="Sproat 1992" startWordPosition="1870" endWordPosition="1871">ntation holds for the union and complementation of FA. It has to be noted that the intersection and complementation of FA via unification do not work in general &apos;Template&apos; is a mild abuse of terminology since we intend not only to designate the type corresponding to the initial state of automaton, but also to suggest what other types are accessible. a X EDGE fl b X EDGE 13 c Y NEXT EDGE undef NEXT NEXT undef INPUT 6 ( ) ( • ) OD) X EDGE NEXT INPUT INPUT INPUT ( 142 for FA with &amp;moves (Ritchie et al. 1992, 33-35). This restriction is due to the fact, that the intersected FA must run &amp;quot;in sync&amp;quot; (Sproat 1992, 139-140). The following closure properties are demonstrated fairly directly. Let Ai = (Qi,E1,81,9o,F1) and A2 = (Q2, E2,2, 90, F2)• • Ai n A2 =-&amp;quot;- q0 A 910 • Al U A2 qo V q&apos;o • Ai -=&amp;quot;.&amp;quot; -1,70 In addition, a weak form of functional uncertainty (Kaplan and Maxwell 1988), represented through recursive type specifications, is appropriate for the expression also concatenation and Kleene closure of FA. Krieger 19936 provides proofs using auxiliary definitions and apparatus we lack space for here. 3 Allomorphy The focus of this section lies in the illustration of the proposal above and in the demon</context>
<context position="13922" citStr="Sproat 1992" startWordPosition="2332" endWordPosition="2333">various allomorphs of -st in (1) are not distinguished in the FDL, and Krieger and Nerbonne 1992 foresaw an interface to an external module for allomorphy. It would be possible—but scientifically poor—to distinguish all of the variants at the level of morphotactics, providing a brute-force solution and multiplying paradigms greatly.&apos; The characterization in Section 2 above allows us to formulate WITHIN FDL the missing allomorphy component. 3.2 Two-Level Allomorphy Two-level morphology has become popular because it is a declarative, bidirectional and efficient means of treating allomorphy (see Sproat 1992 for a comprehensive introduction). In general, two-level descriptions provide constraints on correspondences between underlying (lexical) and surface levels. We shall use it to state constraints between morphemic units and their allomorphic realizations. Because twolevel automata characterize relations between two levels, they are often referred to (and often realized as) transducers. The individual rules then represent constraints on the relation being transduced. The different forms of the suffix in 2nd person singular in (1) are predictable given the phonological shape of the stem, and the</context>
<context position="17869" citStr="Sproat 1992" startWordPosition="2987" endWordPosition="2988">-21) display a compilation of the first rule in (14). Here the composite rule is split up into three different constraints. The first indicates that epenthesis is obligatory in the environment specified and the latter two that each half of the environment specification is necessary.9 (18) epenth-1 {allomorphy [MORPH [FORM Or* ft ,d} + :0 {23,0 r*)]] (19) epenth-2 {allomorphy MORPH [FORM (r* [(21) epenth-3 a-- allomorphy MORPH [FORM (sr* It , d} +:e 3.4 Limits of Pure FA Morphology Finite-state morphology has been criticized (i) for the strict finite-stateness of its handling of morphotactics (Sproat 1992; 43-66); (ii) for making little or no use of the notion of inflectional paradigms and inheritance relations between morphological classes (Cahill 1990); and (iii) for its strict separation of phonology from morphology—i.e., standard two-level rules can only be sensitive to phonological contexts (including word and morpheme boundaries), and apply to all forms where these contexts hold. In fact, allomorphic variation is often &amp;quot;fossilized&amp;quot;, having outlived its original phonological motivation. Therefore some allomorphic rules 9 7T* denotes the Kleene closure over alphabet ir and A the complement</context>
<context position="22188" citStr="Sproat 1992" startWordPosition="3668" endWordPosition="3669">rom operating on a strictly phonological basis, making it subject to lexical conditioning. This is illustrated in Figure 2. But note that this example demonstrates not only how feature-based allomorphy can overcome the strictly phonological base of two-level morphology (criticism (iii) above), but it also makes use of the inheritance structure in modern lexicons as well. 4 Conclusions In this section we examine our proposal vis-à-vis others, suggest future directions, and provide a summary. 4.1 Comparison to other Work Computational morphology is a large and active field, as recent textbooks (Sproat 1992 and Ritchie et al. 1992) testify. This impedes the identification of particularly important predecessors, among whom nonetheless three stand out. First, Trost 1991&apos;s use of two-level morphology in combination verbal rule inherited from the more general adjectival rule, but pursuing this here would take us somewhat afield. 145 with feature-based filters was an important impetus. Second, researchers at Edinburgh (Calder 1988, Bird 1992) first suggested using FDLs in phonological and morphological description, and Bird 1992 suggests describing FA in FDL (without showing how they might be so char</context>
<context position="24101" citStr="Sproat 1992" startWordPosition="3976" endWordPosition="3977">cerned with showing how the standard model of allomorphy (FA) may be assumed into the inheritance hierarchy of the lexicon, while Cahill has introduced syllable-based models. 4.2 Future Work At present only the minimal examples in Section 2 above have actually been implemented, and we are interested in attempting more. Second, a compilation into genuine finite state models could be useful. Third, we are concerned that, in restricting ourselves thus far to acceptors over two-level alphabets, we may incur parsing problems, which a more direct approach through finite-state transducers can avoid (Sproat 1992, p.143). See Ritchie et al. 1992, 19-33 for an approach to parsing using finite-state acceptors, however. 4.3 Summary This paper proposes a treatment of allomorphy formulated and processable in typed feature logic. There are several reasons for developing this approach to morphology. First, we prefer the GENERALITY of a system in which linguistic knowledge of all sorts may be expressed—at least as long as we do not sacrifice processing efficiency. This is an overarching goal of HPSG (Pollard and Sag 1987)—in which syntax and semantics is described in a feature formalism, and in which strides </context>
</contexts>
<marker>Sproat, 1992</marker>
<rawString>Sproat, R. 1992. Morphology and Computation. Cambridge: MIT Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>H Trost</author>
</authors>
<title>The Application of Two-Level Morphology to Non-concatenative German Morphology.</title>
<date>1990</date>
<booktitle>In Proc. of COLING,</booktitle>
<pages>371--376</pages>
<contexts>
<context position="18954" citStr="Trost 1990" startWordPosition="3158" endWordPosition="3159">onological motivation. Therefore some allomorphic rules 9 7T* denotes the Kleene closure over alphabet ir and A the complement of A with respect to r. (20) allomorphy INPUT MORPHIFORM [ El El {s ,t} 144 are restricted in nonphonological ways, applying only to certain word classes, so that some stems admit idiosyncratic exceptions with respect to the applicability of rules (see Bear 1988, Emele 1988, Trost 1991). To overcome the first difficulty, a number of researchers have suggested augmenting FA with &amp;quot;word grammars&amp;quot;, expressed in terms of feature formalisms like PATR II (Bear 1986) or HPSG (Trost 1990). Our proposal follows theirs, improving only on the degree to which morphotactics may be integrated with allomorphy. See Krieger and Nerbonne 1992 for proposals for treating morphotactics in typed feature systems. We illustrate how the FDL approach overcomes the last two difficulties in a concrete case of nonphonologically motivated allomorphy. German epenthesizes schwa (&lt; e &gt;) at morph boundaries, but in a way which is sensitive to morphological environments, and which thus behaves differently in adjectives and verbs. The data in (22) demonstrates some of these differences, comparing epenthe</context>
</contexts>
<marker>Trost, 1990</marker>
<rawString>Trost, H. 1990. The Application of Two-Level Morphology to Non-concatenative German Morphology. In Proc. of COLING, 371-376.</rawString>
</citation>
<citation valid="true">
<authors>
<author>H Trost</author>
</authors>
<title>X2MORF: A Morphological Component Based on Augmented Two-Level Morphology.</title>
<date>1991</date>
<tech>Technical Report RR-91-04,</tech>
<location>DFKI, Saarbriicken, Germany.</location>
<contexts>
<context position="12091" citStr="Trost 1991" startWordPosition="2053" endWordPosition="2054">s section lies in the illustration of the proposal above and in the demonstration of some benefits that can be drawn from the integration of allomorphy and morphotactics; we eschew here the discussion of alternative theories and concentrate on inflectional morphology. We describe inflection using a word-andparadigm (WP) specification of morphotactics (Matthews 1972) and a two-level treatment of allomorphy (Koskenniemi 1983). We also indicate some potential advantages of mixed models of allomorphy—finite state and other.6 3.1 WP Morphotactics in FDL Several WORD-GRAMMARS use FDL morphotactics (Trost 1991, Krieger and Nerbonne 1992 on derivation); alternative models are also available. Krieger and Nerbonne 1992 propose an FDL-based WP treatment of inflection. The basic idea is to characterize all the elements of a paradigm as alternative specifications of abstract lexemes. Technically, this is realized through the specification of large disjunctions which unify with lexeme specifications. The 6The choice of two-level allomorphy is justified both by the simplicity of two-level descriptions and by their status as a &amp;quot;lingua franca&amp;quot; among computational morphologists. Two-level analyses in FDLs may</context>
<context position="18757" citStr="Trost 1991" startWordPosition="3127" endWordPosition="3128">onological contexts (including word and morpheme boundaries), and apply to all forms where these contexts hold. In fact, allomorphic variation is often &amp;quot;fossilized&amp;quot;, having outlived its original phonological motivation. Therefore some allomorphic rules 9 7T* denotes the Kleene closure over alphabet ir and A the complement of A with respect to r. (20) allomorphy INPUT MORPHIFORM [ El El {s ,t} 144 are restricted in nonphonological ways, applying only to certain word classes, so that some stems admit idiosyncratic exceptions with respect to the applicability of rules (see Bear 1988, Emele 1988, Trost 1991). To overcome the first difficulty, a number of researchers have suggested augmenting FA with &amp;quot;word grammars&amp;quot;, expressed in terms of feature formalisms like PATR II (Bear 1986) or HPSG (Trost 1990). Our proposal follows theirs, improving only on the degree to which morphotactics may be integrated with allomorphy. See Krieger and Nerbonne 1992 for proposals for treating morphotactics in typed feature systems. We illustrate how the FDL approach overcomes the last two difficulties in a concrete case of nonphonologically motivated allomorphy. German epenthesizes schwa (&lt; e &gt;) at morph boundaries, </context>
<context position="20135" citStr="Trost 1991" startWordPosition="3346" endWordPosition="3347">ifferences, comparing epenthesis in phonologically very similar forms. free, adj super frei-Fst frei est (22) free, v 2s pres be+frei-l-st befreist woo, v 2s pres frei+st freist While the rule stated in (14) (and reformulated in (19)-(21)) treats the verbal epenthesis correctly, it is not appropriate for adjectives, for It does not allow epenthesis to take place after vowels. We thus have to state different rules for different morphological categories. The original two-level formalism could only solve this problem by introducing arbitrary diacritic markers. The most general solution is due to Trost 1991, who associated two-level rules with arbitrary filters in form of feature structures. These feature structures are unified with the underlying morphs in order to check the context restrictions, and thus serve as an interface to information provided in the feature-based lexicon. But Trost&apos;s two-level rules are a completely different data structure from the feature structures decorating transitions in FA. We attack the problem head on by restricting allomorphic constraints to specific classes of lexical entries, making use of the inheritance techniques available in structured lexicons. The case</context>
<context position="22352" citStr="Trost 1991" startWordPosition="3694" endWordPosition="3695">ot only how feature-based allomorphy can overcome the strictly phonological base of two-level morphology (criticism (iii) above), but it also makes use of the inheritance structure in modern lexicons as well. 4 Conclusions In this section we examine our proposal vis-à-vis others, suggest future directions, and provide a summary. 4.1 Comparison to other Work Computational morphology is a large and active field, as recent textbooks (Sproat 1992 and Ritchie et al. 1992) testify. This impedes the identification of particularly important predecessors, among whom nonetheless three stand out. First, Trost 1991&apos;s use of two-level morphology in combination verbal rule inherited from the more general adjectival rule, but pursuing this here would take us somewhat afield. 145 with feature-based filters was an important impetus. Second, researchers at Edinburgh (Calder 1988, Bird 1992) first suggested using FDLs in phonological and morphological description, and Bird 1992 suggests describing FA in FDL (without showing how they might be so characterized, however—in particular, providing no FDL definition of what it means for an FA to accept a string). Third, Cahill 1990 posed the critical question, viz., </context>
</contexts>
<marker>Trost, 1991</marker>
<rawString>Trost, H. 1991. X2MORF: A Morphological Component Based on Augmented Two-Level Morphology. Technical Report RR-91-04, DFKI, Saarbriicken, Germany.</rawString>
</citation>
<citation valid="true">
<authors>
<author>E Tzoukermann</author>
<author>M Libermann</author>
</authors>
<title>A Finite-State Morphological Processor for Spanish.</title>
<date>1990</date>
<booktitle>In Proc. of COLING,</booktitle>
<volume>3</volume>
<contexts>
<context position="14758" citStr="Tzoukermann and Libermann 1990" startWordPosition="2450" endWordPosition="2453">rphemic units and their allomorphic realizations. Because twolevel automata characterize relations between two levels, they are often referred to (and often realized as) transducers. The individual rules then represent constraints on the relation being transduced. The different forms of the suffix in 2nd person singular in (1) are predictable given the phonological shape of the stem, and the alternations can be described by the following (simplified) two-level rules (we have abstracted away from inessential restrictions here, e.g., that (strong) verbs with i/e-umlaut do not show epenthesis): 7Tzoukermann and Libermann 1990 show that multiplying paradigms need not degrade performance, however. 143 (14) e-epenthesis in the bet- case :e {d,t} {s,t} s-deletion in the mix- case s : 0 4* {s, z, ch} : t The colon `:&apos; indicates a correspondence between lexical and surface levels. Thus the first rule states that a lexical morph boundary + must correspond to a surface e if it occurs after d or I and before s or I. The second specifies when lexical s is deleted (corresponds to surface 0). Two-level rules of this sort are then normally compiled into transducers (Dalrymple et al. 1987, p.35-45). 3.3 FDL Specification of Two</context>
</contexts>
<marker>Tzoukermann, Libermann, 1990</marker>
<rawString>Tzoukermann, E., and M. Libermann. 1990. A Finite-State Morphological Processor for Spanish. In Proc. of COLING, Vol. 3.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>