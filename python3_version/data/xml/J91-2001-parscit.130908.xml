<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<title confidence="0.953335">
Features and Formulae
</title>
<author confidence="0.988689">
Mark Johnson.
</author>
<affiliation confidence="0.825984">
Brown University
</affiliation>
<bodyText confidence="0.998631166666667">
Feature structures are a representational device used in several current linguistic theories. This
paper shows how these structures can be axiomatized in a decidable class of first-order logic,
which can also be used to express constraints on these structures. Desirable properties, such
as compactness and decidability, follow directly. Moreover, additional types of feature values,
such as &amp;quot;set-valued&amp;quot; features, can be incorporated into the system simply by axiomatizing their
properties.
</bodyText>
<sectionHeader confidence="0.994347" genericHeader="abstract">
1. Introduction
</sectionHeader>
<bodyText confidence="0.999856115384615">
Many modern linguistic theories, such as Lexical-Functional Grammar (Bresnan 1982),
Functional Unification Grammar (Kay 1985), Generalized Phrase Structure Grammar
(Gazdar et al. 1985), Unification Categorial Grammar (Haddock et al. 1987), (Uszkoreit
1986), and Head-Driven Phrase Structure Grammar (Pollard and Sag 1987), replace the
atomic categories of a context-free grammar with a &amp;quot;feature structure&amp;quot; that represents
the syntactic and semantic properties of the phrase. These feature structures are spec-
ified indirectly in terms of constraints that they must satisfy Lexical entries constrain
the feature structures that can be associated with terminal nodes of the syntactic tree,
and phrase structure rules simultaneously constrain the feature structures that can be
associated with a parent node and its immediate descendants.
That is, lexical entries and syntactic rules used to construct a syntactic phrase
structure tree all contribute constraints on the feature structures that appear as the
labels on nodes in the syntactic tree. The tree is well formed if and only if all of
these constraints are simultaneously satisfiable. Thus for the purposes of recognition
a method for determining the satisfiability of such constraints is required; the precise
nature of the satisfying feature structures (of which there may be infinitely many) is
of secondary importance.&apos;
A variety of different types of feature structures have been proposed in the liter-
ature, but most work on unification-based grammar has centered on a certain type of
feature structure known as an attribute-value structure. The elements in an attribute-
value structure come in two kinds: constant elements and complex elements. Constant
elements are atomic entities with no internal structure: i.e. they have no attributes.
Complex elements have zero or more attributes, whose values may be any other ele-
ment in the structure, including a complex element. An element can be the value of
zero, one or several attributes. Attributes are partial: it need not be the case that every
attribute is defined for every complex element.
</bodyText>
<note confidence="0.689921">
* Department of Cognitive and Linguistic Sciences, Providence, RI 02912 USA
</note>
<footnote confidence="0.83114525">
1 The validity problem is also of interest, since it provides a way of &amp;quot;extracting information&amp;quot; about all of
the satisfying feature structures. In the framework developed below, if 0 is a formula representing a
system of constraints and 0 is valid, then 0 is a true description of every feature structure
satisfying 0.
</footnote>
<note confidence="0.652156">
© 1991 Association for Computational Linguistics
Computational Linguistics Volume 17, Number 2
</note>
<equation confidence="0.92725755">
pred = seem
num = sg
subj =
-
agr =
e pers = 3rd
5
e3 pred = mary
pred = like
pred = john
&amp;quot;Mary seems to like John&amp;quot;
comp =
obj =
agr =
e2 e4
tense = none
subj = e3
num = sg
pers = 3rd
eo tense = pres
</equation>
<figureCaption confidence="0.897603">
Figure 1
</figureCaption>
<bodyText confidence="0.956125964285714">
An attribute-value structure for Mary seems to like John
Example 1
Figure 1 depicts an attribute-value structure. The attribute-value element labeled eo
in Figure 1 might be associated with the sentence Mary seems to like John.
The attribute-value structure depicted in Figure 1 contains six complex elements
e0,... e5 e5 and eight constant elements seem, like, john, sg, 3rd, mary, none, and pres. The
element eo is a complex attribute-value element with four attributes: pred, subj, cornp,
and tense: the order in which the attributes appear in the diagram is irrelevant. The
value of its pred attribute is the constant seem (which abbreviates the relation denoted
by the verb seem), and the value of its tense attribute is the constant element pres
(which indicates that the clause is in the present tense). The values of the subj and
comp attributes are the complex elements e3 and el (which represent the subject and the
complement of the verb seem, respectively). The element e3 also appears as the subject
of el, indicating that Mary is also the (understood) subject of the verb likes as well.
The element el is a complex attribute-value element with four attributes pred, obj,
subj, and tense. The value of its pred attribute is the constant element like (which abbre-
viates the relation denoted by the verb like) and the value of its tense attribute is the
constant element none (which indicates that the clause is untensed). The values of the
attributes obj and subj of el are the complex elements e2 and e3, respectively (which
represent the subject and object of the clause). Both e4 and e5 have the same attributes
num and pers, and the values of these attributes of e4 are identical to the corresponding
values of these attributes of e5. Nevertheless, e4 and e5 are distinct elements.
An operation called unification plays an important role in most accounts of feature
structures (Kay 1985; Shieber 1986). The unification operation &amp;quot;combines&amp;quot; or &amp;quot;merges&amp;quot;
two elements into a single element that agrees with both of the original elements on
the values of all of their defined sequences of attributes, so the unification of two
complex elements requires the unification of the values of any attributes they have
in common. The unification operation fails if it requires the unification of distinct
</bodyText>
<page confidence="0.984711">
132
</page>
<figure confidence="0.874516882352941">
Johnson Features and Formulae
salmon pred = salmon
agr = pers = 3rd
pred = swim
swims num = sg
pers = 3rd
subj = agr =
e&amp;quot; f&apos;
e_tense = pres
Figure 2
Lexical entries for salmon and swim
&amp;quot;The salmon swims&amp;quot; &apos; pred = swim
agr --=f num = sg
subj = pers = 3rd
e&apos;
e„ -pred = salmon
Ltense = pres
</figure>
<figureCaption confidence="0.804268">
Figure 3
</figureCaption>
<bodyText confidence="0.856104333333333">
An example of attribute-value unification
constant elements (a constant—constant clash) or the unification of a constant element
and a complex element (a constant—complex clash).
</bodyText>
<subsectionHeader confidence="0.60996">
Example 2
</subsectionHeader>
<bodyText confidence="0.997358882352941">
A grammar might assign the attribute-value structures in Figure 2 to the NP the salmon
and the VP swims, respectively. Note that e&apos; does not have a num attribute, since the
salmon can be either singular or plural, and that e&amp;quot; does not have a pred attribute.
The attribute-value structure for the sentence (the) salmon swims is obtained by
unifying e&apos; and e&amp;quot;, which corresponds to identifying salmon as the subject of swims.
The resulting element inherits the value of the pred attribute from e&apos; and the value of
the num attribute from e&amp;quot;. The unification of e&apos; and e&amp;quot; requires the unification off&apos; and
f&amp;quot; as well.
Although it might not be obvious from this simple example, a large number of
syntactic constructions from a variety of natural languages can be described in such
a unification-based framework (many of the analyses presented in Bresnan 1982 can
be expressed in such a &amp;quot;pure&amp;quot; unification-based framework). Nevertheless, it is often
convenient and sometimes necessary to extend the basic unification framework to
include a wider variety of feature structures.
For example, &amp;quot;negative values&amp;quot; and &amp;quot;disjunctive values&amp;quot; allow grammars and
lexical entries to be written much more succinctly, as the following examples show
(based on Karttunen 1984).
</bodyText>
<page confidence="0.99725">
133
</page>
<table confidence="0.50558425">
Computational Linguistics Volume 17, Number 2
cat = determiner
number: singular
agr = gender: feminine
number: plural
die
case = /nom \
\ ace
</table>
<figureCaption confidence="0.85584">
Figure 4
</figureCaption>
<figure confidence="0.672003">
Disjunction in the lexical entry for die
swim pred = swim num = sg
subj = agr = pers = 3rd
e pres
tense =
</figure>
<figureCaption confidence="0.842826">
Figure 5
</figureCaption>
<bodyText confidence="0.94676">
Negation in the lexical entry for swim
</bodyText>
<subsectionHeader confidence="0.823547">
Example 3
</subsectionHeader>
<bodyText confidence="0.999866">
In German the determiner die must have accusative or nominative case, and agrees
with either feminine singular nouns or plural nouns of any gender. In a framework
with disjunctive values only one lexical entry for die is required.2
</bodyText>
<subsectionHeader confidence="0.921304">
Example 4
</subsectionHeader>
<bodyText confidence="0.999472181818182">
In the basic unification framework described above the tensed verb swim would require
multiple lexical entries, since it agrees with first person, second person, and plural third
person subjects; i.e., a subject with any agreement features other than third person
singular. In a framework with &amp;quot;negative values&amp;quot; it requires only the single lexical
entry in Figure 5, where &amp;quot;&amp;quot; identifies a &amp;quot;negative value.&amp;quot;
As mentioned earlier, other kinds of feature structures besides attribute-value
structures have been proposed in the literature. Johnson and Klein (1986) and Johnson
and Kay (1990) show how &amp;quot;set-valued&amp;quot; features can be used to express Discourse Rep-
resentation Theory (Kamp 1981) in a complex-feature based grammar formalism. The
highly simplified example below is meant solely to show one way in which set-valued
features can be used—no claims are made for its linguistic correctness.
</bodyText>
<footnote confidence="0.981593666666667">
2 &amp;quot;Disjunctive&amp;quot; features are depicted using angle brackets, since curly brackets are used in this paper to
depict &amp;quot;set-valued&amp;quot; features. Below we reinterpret the &amp;quot;disjunctive&amp;quot; and &amp;quot;negative&amp;quot; features depicted
in this example and the next as disjunctions and negations of constraints.
</footnote>
<page confidence="0.995592">
134
</page>
<figure confidence="0.535951375">
Johnson Features and Formulae
she ). cat = NP ,--
index e s 1 cat = N
refs-in = s ! index = i&apos;
refs-out = s woman --).- II refs-in = s&apos;
— i refs-out = s&apos; u I i&apos; 1
VL
U
</figure>
<figureCaption confidence="0.874408">
Figure 6
</figureCaption>
<bodyText confidence="0.839711">
Set-values in the lexical entries for she and woman
</bodyText>
<equation confidence="0.9924405">
V —
cat = N
index =i&apos;
refs-in = { }
refs-out = { i&apos; }
—
</equation>
<figureCaption confidence="0.966408">
Figure 7
</figureCaption>
<bodyText confidence="0.95349008">
The result of unifying s&apos; in Figure 6 with the empty set
Example 5
A naive theory of anaphoric dependencies between indefinite NPs and anaphoric pro-
nouns can be constructed as follows. Each NP has an index attribute whose value is
a &amp;quot;reference marker,&amp;quot; and two NPs are coreferential iff they share the same reference
marker.3 Every feature structure associated with a node in the syntactic tree has at-
tributes refs-in and refs-out, whose values are the sets of discourse entities available
preceding and following this node, respectively. The grammar constrains the value
of the refs-out attribute of an indefinite NP to be the union of its refs-in attribute and
the singleton set containing the value of the NP&apos;s index attribute; this adds the NP&apos;s
index to the set of available indices. Similarly, the grammar requires the values of a
pronoun&apos;s refs-in and refs-out attributes to be identical, and that its index attribute be a
member of the value of its refs-in attribute. This requires that the pronoun refer to an
entity previously introduced into the discourse. In a framework with set values the
lexical entries for (a) woman and she could be as seen in Figure 6.
Unifying the value s&apos; of the refs-in attribute of the lexical entry for woman with the
empty set (which corresponds to the empty discourse context) produces the feature
structure depicted in Figure 7.
Further, the unification of the value of the refs-out attribute in Figure 7 with the
value of the refs-in attribute of u in Figure 6 (the lexical entry for she), which corre-
sponds to interpreting the pronoun as an anaphor within the context established by
the single NP a woman produces the feature structure depicted in Figure 8.
Extending the possible feature structures beyond the basic attribute-value features
complicates the basic unification operation, however. For example, Moshier and Rounds
(1987) and Pereira (1987) point out that it is not obvious how to extend unification
</bodyText>
<footnote confidence="0.662237">
3 Reference markers in DRT correspond approximately to the referential indices associated with NPs in
GB theory.
</footnote>
<page confidence="0.606325">
-
135
</page>
<note confidence="0.264461">
Computational Linguistics Volume 17, Number 2
</note>
<equation confidence="0.9964895">
cat = NP
index =
refs-in = { }
refs-out = }
</equation>
<figureCaption confidence="0.713273">
Figure 8
</figureCaption>
<bodyText confidence="0.554053">
The result of unifying the value of the refs-out attribute of Figure 7 with s in Figure 6
</bodyText>
<equation confidence="0.545026">
def = + these def = +
num = sg num = pl
this
agr = pers = 3rd agr = , pers = 3rd
u&apos; v
pred = salmon
salmon
pred = swim num = sg
subj = agr = pers = 3rd
tense = pres
swim
</equation>
<figureCaption confidence="0.935518">
Figure 9
</figureCaption>
<bodyText confidence="0.972104368421053">
Feature structures demonstrating interaction of negative values and unification
to negative feature values; specifically, some apparently plausible extensions lose the
associativity property of unification.
Example 6
Consider the feature structures in Figure 9, which might be assigned to the singular
determiner this, the plural determiner these, the noun salmon, and the verb swim (the
latter two structures are the same as those depicted in Figures 2 and 5). These can be
used to analyze utterances such as these salmon swim and (the ill-formed utterance) this
salmon swim, which involve the unification of u, e&apos;, and e or u&apos;, e&apos;, and e, respectively.
Suppose a negative value is interpreted as a constraint that a feature structure
either satisfies or does not satisfy, and suppose further that in Figure 9 the negative
feature constraint f is satisfied by the value 1. Then e&apos; and e in Figure 9 unify, and
moreover further unification of e&apos; with either u&apos; or u succeeds, undesirably in the latter
case. (Reinterpreting the negative constraint f so that f&apos; fails to satisfy it does not help,
since the unification of e, e&apos;, and u&apos; should succeed). On the other hand, we obtain the
results we desire if e&apos; is unified with u or u&apos; before being unified with e. If e&apos; is first
unified with u, then f&apos; is unified with v, and further unification of e&apos; with e fails, since
v does not satisfy f. If e&apos; is first unified with u&apos; then f&apos; is unified with v&apos; and further
unification of e&apos; with e succeeds, since v&apos; does satisfy f. Thus under this interpretation
</bodyText>
<equation confidence="0.968834">
agr = [pers = 3rd &apos;
</equation>
<page confidence="0.991897">
136
</page>
<note confidence="0.379268">
Johnson Features and Formulae
</note>
<bodyText confidence="0.9995185">
of negation and unification, the success or failure of a sequence of unifications depends
on the order in which they are performed.4
</bodyText>
<subsectionHeader confidence="0.764429">
2. Feature Structures and Function-free Formulae
</subsectionHeader>
<bodyText confidence="0.998954955555556">
These problems have generated a considerable body of work on the mathematical
properties of feature structures and the constraints and operations that apply to them.
Following Kaplan and Bresnan (1982), Pereira and Shieber (1984), Kasper and Rounds
(1986, 1990), and Johnson (1988, 1990a) the constraints that determine the feature struc-
tures are regarded as formulae from a language for describing feature structures, rather
than as feature structures themselves.
Disjunction and negation appear only in expressions from the description lan-
guage, rather than as components of the feature structures that these expressions de-
scribe. Thus the lexical entries in the examples above will be interpreted as formulae
that constrain the feature structures that can be associated with these lexical items in
a syntactic tree, rather than the feature structures themselves. For example, the feature
matrices depicted in Figures 2, 4 6, and 9 will be interpreted as graphical depictions of
formulae expressing constraints on linguistic objects, rather than the linguistic objects
that satisfy these constraints. This avoids any need to refer to &amp;quot;negative&amp;quot; or &amp;quot;disjunc-
tive&amp;quot; objects as entities appearing in a feature structure.
As explained below, the familiar attribute-value &amp;quot;unification algorithm&amp;quot; can be
interpreted as computing the atomic consequences of a purely conjunctive formula
(where the graphs it operates on are data structures efficiently representing such for-
mulae), and unification failure corresponds to the unsatisfiability of that conjunction
(Kasper and Rounds 1990; Johnson 1988, 1990a; Pereira 1987).
The most widely known model of feature structures and constraint language is
the one developed to explain disjunctive feature values by Kasper and Rounds (1986,
1990) and Kasper (1986, 1987). The Kasper—Rounds treatment resolves the difficulties
in interpreting disjunctive values by developing a specialized language for expressing
these constraints. Various proposals to extend the Kasper—Rounds approach to deal
with negative feature values are described by Moshier and Rounds (1987), Moshier
(1988), Kasper (1988), Dawar and Vijayashanker (1989, 1990), Langholm (1989); other
extensions to this framework are discussed by Dorre and Rounds (1989), Smolka (1988,
1989), and Nebel and Smolka (1989); and Shieber (1989) discusses the integration of
such feature systems into a variety of parsing algorithms.
One difficulty with this approach is that the constraint language is &amp;quot;custom built,&amp;quot;
so important properties, such as compactness and decidability, must be investigated
from scratch. Moreover, it is often unclear if the treatment can be extended to
handle other types of feature structures as well. Rounds (1988) proposes a model
for set-valued features, but he does not provide a language for expressing constraints
on such set-valued entities, or investigate the computational complexity of systems of
such constraints.
This paper follows an alternative strategy suggested in Johnson (1990a): axiomatize
the relevant properties of feature structures in some well-understood language (here
first-order logic) and translate constraints on these structures into the same language.
4 It is possible to avoid these problems by augmenting feature structures with &amp;quot;inequality arcs,&amp;quot; as was
first proposed (to my knowledge) by Karttunen (1984) and discussed in Johnson (1990a), Johnson (in
press) and pages 67-72 of Johnson (1988). However, it is hard to justify the existence of such arcs if
feature structures are supposed to be linguistic objects (rather than data structures that represent
formulae manipulated during the parsing process).
</bodyText>
<page confidence="0.959958">
137
</page>
<note confidence="0.27148">
Computational Linguistics Volume 17, Number 2
</note>
<bodyText confidence="0.9999515">
Thus the satisfiability problem for a set of constraints on feature structures is reduced
to the satisfiability problem for the axioms conjoined with the translation of these
constraints in the target language. Importantly, techniques used to determine satisfia-
bility in the target language can be used to determine the satisfiability of the feature
constraints as well. In this paper the properties of attribute-value structures and con-
straints on them are expressed in a decidable class of first-order formulae: this means
that the satisfiability problem for such formulae, and hence the feature constraints that
they express, is always decidable.
Of course, some linguistic analyses make use of feature structure constraint sys-
tems that can encode undecidable problems. For example, subsumption constraints,
which are useful in the description of agreement phenomena in coordination con-
structions (Shieber 1989) can be used to encode undecidable problems, as Dorre and
Rounds (1989) have shown. Clearly such constraints cannot be expressed in a decidable
class, but often they can be axiomatized in other standard logics. Johnson (1991) shows
how (positively occurring) subsumption constraints can be axiomatized in first-order
logic, and sketches treatments of sort constraints and nonmonotonic devices such as
ANY values (Kay 1985) and &apos;constraint equations&apos; (Kaplan and Bresnan 1982) can be
formalized in second-order logic using circumscription.
</bodyText>
<subsectionHeader confidence="0.999583">
2.1 Axiomatizing Feature Structures with Function-Free Formulae
</subsectionHeader>
<bodyText confidence="0.999918666666667">
This section shows how the important properties of feature structures can be axioma-
tized using formulae from the Schtinfinkel-Bernays class, which is the class of first-order
formulae of the form
</bodyText>
<equation confidence="0.467017">
. xnVyi • • • yn(10
</equation>
<bodyText confidence="0.99950684">
where co contains no function symbols or quantifiers. (Thus no existential quantifier
can appear in the scope of a universal quantifier.) This class of formulae was chosen
because it is both decidable (see e.g. Lewis and Papadimitriou 1981) and can express
the quantification needed to describe the particular set operations proposed here, as
well as a variety of other interesting types of feature structures and constraints. (For
a general discussion of decidable classes see Gurevich 1976 and Dreben and Goldfarb
1979.) The next section shows how the various kinds of constraints on feature struc-
tures described above can be translated into this class of formulae, so any system of
such feature constraints is decidable as well.
The elements of a feature structure, both complex and constant, constitute the
domain of individuals in the intended interpretation. The attributes are binary
relations over this domain.5 We proceed by axiomatizing the conditions under which
an interpretation corresponds to a well-formed feature structure, formulating them in
essentially the same way as Smolka (1988, 1989) does.
The axiomatization begins by describing the properties of the constant elements of
attribute-value structures. The attribute-value constants are the denotation of certain
constant symbols of the language of first-order logic, but not all constants (of the first-
order language) will denote attribute-value constants since it is convenient to have
constants that denote other entities as well. The following axiom schemata express the
requirement that attribute-value constants have no attributes and that all attribute-
5 This differs from earlier work (Johnson 1988) in which values and attributes were both conceptualized
as individuals. In fact, research in progress indicates that it is advantageous to conceptualize of
attributes as individuals and attribute relations in terms of a 3-place relation arc, where arc(x, a, y) is
true iff the value of x&apos;s attribute a is y. This permits the quantification over attributes needed to define
both simple and parameterized sorts to be expressed.
</bodyText>
<page confidence="0.969199">
138
</page>
<bodyText confidence="0.687257333333333">
Johnson Features and Formulae
value constants are distinct; i.e., that distinct attribute-value constants denote different
entities.
</bodyText>
<listItem confidence="0.8741565">
1. For all attribute-value constants c and attributes a, V x
2. For all distinct pairs of attribute-value constants c1, c2, Ci c2.
The next axiom schema requires attributes to be single-valued.
3. For all attributes a, V xyz a(x y) A a(x , z) y = z.
</listItem>
<bodyText confidence="0.991977771428571">
This completes the axiomatization of attribute-value feature structures.&apos; The claim is
that any interpretation that satisfies these axioms is an attribute-value structure, i.e.
1-3 constitute a definition of attribute-value structures. Such interpretations can be
viewed as (possibly infinite and disconnected) directed graphs, where the individuals
constitute the graph&apos;s nodes and the attribute relations the arcs between those nodes.
Thus these axioms admit a much wider class of models than do most other treat-
ments of feature structures (e.g., Kasper and Rounds (1990) require feature structures
to be a certain type of finite automata). In fact it is easy to add axioms requiring
attribute-value structures to have additional properties such as acyclicity. But since
the axioms that define attribute-value structures are in effect assumptions that stipulate
the nature of linguistic entities, we obtain a more general theory the weaker these
axioms are. Thus 1-3 are intended to stipulate only the properties of attribute-value
structures that are required by linguistic analyses.
Note that the partiality of attributes is of crucial importance: if attributes were
required to be total rather than partial functions, we could not axiomatize them with
formulae from the Schonfinkel-Bernays class. (An axiom schema requiring attributes
to be total functions would have instances of the form Vx By a(x, y), which do not
belong to the Schonfinkel-Bernays class).
Example 7
The interpretation corresponding to the attribute-value structure depicted in Figure 1
has as its domain the set D = {seem, like, john, sg, 3rd, mary, pres, none} u {eo, ,e5}.
The attributes denote relations on D x D. For example, pred denotes the relation
{(e0 , seem), (e1, like), (e2, john), (e3, mary)} . It is straightforward to check that all of the
axioms hold in this interpretation.
Instead of providing entities in the interpretation that serve as the denotation for &amp;quot;dis-
junctive&amp;quot; or &amp;quot;negative&amp;quot; features, we follow Kasper and Rounds (1986, 1990), Moshier
and Rounds (1987), and Johnson (1988, 1990) in permitting disjunction and negation
only in the constraint language. Since the classical semantics of disjunction and nega-
tion for first-order languages is consistent and monotonic, a consistent, monotonic
semantics for negative and disjunctive feature constraints follows directly. (An exam-
ple is presented below; see Johnson (1990) and especially Section 2.10 of Johnson (1988)
for further discussion).
We turn now to the set-valued features. The most straightforward way of introduc-
ing set-valued features would be to combine some standard axiomatization of set the-
ory with the axiomatization of attribute-value structures just presented. Unfortunately,
</bodyText>
<footnote confidence="0.9661125">
6 This axiomatization is finite iff the sets of attribute symbols and constant symbols are finite. In the
intended computational and linguistic applications this is always the case.
</footnote>
<page confidence="0.986296">
139
</page>
<note confidence="0.48224">
Computational Linguistics Volume 17, Number 2
</note>
<bodyText confidence="0.999960428571429">
all of the formulations of set-theory I am aware of, such as Zermelo—Fraenkel set-
theory, are expressed in languages whose satisfiability problem is undecidable. While
this does not imply that the satisfiability problem for set-valued feature-structure con-
straints is also undecidable (since the feature constraint language may have restricted
expressiveness), it does mean that its decidability cannot be shown by noting that a
translation into a decidable class of formulae exists.
Also, as an anonymous reviewer points out, since the intended linguistic applica-
tions only require finite sets and operations such as union and intersection, standard
theories of sets (such as Zermelo—Fraenkel set-theory) are much more powerful than
needed.
Instead, we axiomatize just those properties of set-valued features that our feature
constraints require using formulae from the Schonfinkel-Bernays class. We interpret
the two-place relation in as the membership relation; in(x , y) is true in a model iff x is a
member of y. We place no restrictions on this relation, but in other formulations axioms
of foundation and extensionality could be used to ensure that the in relation can be
interpreted as the set-membership relation of Zermelo—Fraenkel set theory. Thus this
axiomatization presented here will admit models in which the values of set-valued fea-
tures do not have these properties.7 These additional properties of the set-membership
relation don&apos;t seem to be needed in linguistic analyses, so such stipulations are not
made here.
The axiom of foundation requires that all sets are well founded; i.e., that the tran-
sitive closure of the set-membership relation is irreflexive, or more informally, that no
set directly or indirectly contains itself as a member. Versions of set-theory that relax
this restriction have been proposed by, e.g., Aczel (1988), and Rounds (1988) argues
that non—well founded sets may be appropriate models of set values in feature struc-
tures. The paradoxes associated with non—well founded set theories are avoided here
because the axiom of comprehension that asserts the existence of paradoxical sets is
not included in this axiomatization; i.e., the only way of defining a set is either by
explicitly listing its members or by means of union and intersection operations.
The axiom of extensionality requires that if sets Si and 52 contain exactly the same
members then Si = S2; without extensionality it is possible for two different sets to
contain exactly the same members. Admittedly the primary reason for omitting an
extensionality axiom is that it does not appear to be axiomatizable using Schonfinkel-
Bernays&apos; formulae, but three other reasons motivate this decision.
First, as noted in Shieber (1986) and in Example 1 above, feature structures in
general are not extensional (e.g., two distinct attribute-value elements can have ex-
actly the same attributes and values), and it seems reasonable to treat set-values in a
nonextensional fashion as well.
Second, extensionality could produce undesirable interactions with the attribute-
value component of feature structures. Since set-valued features can also have at-
tributes (for example, in LFG (Kaplan and Bresnan 1982)) a conjunction is associated
with a set-value that also has attributes), extensionality would prohibit there being
</bodyText>
<footnote confidence="0.441860142857143">
7 In fact there are Schonfinkel-Bernays axioms that require the in relation to be acyclic. Define a new
relation, say ink, by the axioms
V s in(e, s) in+ (e, s)
V es s&apos; in+ (e, s) A in+ (s, s&apos;) in+ (e, s&apos;).
Then in any model in+ denotes a superset of the transitive closure of the in relation. The following
axiom requires that this transitive closure is irreflexive, i.e. that no set is contained in itself.
Vs (s, s).
</footnote>
<page confidence="0.981027">
140
</page>
<note confidence="0.567652">
Johnson Features and Formulae
</note>
<bodyText confidence="0.999752">
two set-valued features that contain exactly the same elements but that differ on the
value of some attribute, something a linguistic analysis might reasonably require.
Third, as far as I am aware, no linguistic analysis requires sets to be extensional.
Appealing to the same general considerations that were used to justify the attribute-
value axioms, since the assumption that sets are extensional is not required, the stip-
ulation is not made here.
It is necessary to define some predicates that describe set-values. We begin by pre-
senting a general first-order axiomatization of these predicates, and then approximate
these with formulae from the Schonfinkel-Bernays class.
Most of the definitions are straightforward, and are given without explanation.&apos;
The unary predicate null is true of an element iff that element has no members.
</bodyText>
<listItem confidence="0.434581">
4. Vx null(x) in(y, x)
</listItem>
<bodyText confidence="0.885747">
The ternary relation union(x, y, z) is true only if every element in z is in x or y.
</bodyText>
<listItem confidence="0.717342">
5. Vxyz union(x, y, z) 4-4 Vu in(u, z) 4—* in(u, x) V in(u, y)
</listItem>
<bodyText confidence="0.934668">
The ternary relation intersection(x, y, z) is true only if every element in z is in x and in y.
</bodyText>
<listItem confidence="0.976968666666667">
6. Vxyz intersection(x,y, z) Vu in(u , z) 4-4 in(u, x) A in(u, y)
The binary relation singleton(u, x) is true if and only if u is the only member of x.
7. Vux singleton(u, x) 4-4 in(u, x) A Vv in(v , x) u = v
</listItem>
<bodyText confidence="0.997330111111111">
Unfortunately the axioms 4-7 do not belong to the Schonfinkel-Bernays class, so we
cannot guarantee the decidability of systems of constraints defined using them simply
by noting a translation into this class exists. However, in all of the linguistic applica-
tions I am aware of these predicates always appear positively, and in this case these
axioms can be replaced by the corresponding &amp;quot;one-sided&amp;quot; axioms given below. (The
predicate null is an exception, since some HPSG analyses (Pollard and Sag 1987) re-
quire the set of unsaturated arguments of some phrases to be non-null. However, it
is possible to require that a set s is nonempty by introducing a new constant u and
require that in (u , s).)
</bodyText>
<listItem confidence="0.92440725">
4&apos;. V xy null(x) x)
5&apos;. Vuxyz union(x, y, z) (in(u, z) 4—* in(u , x) v in(u, y))
6&apos;. Vuxyz intersection(x, y, z) —+ (in(u, z) in(u, x) A in(u, y))
7&apos;. Vuxv singleton(u, x) -4 (in(u, x) A in(v, , x) —+ u -= v)
</listItem>
<bodyText confidence="0.949098666666667">
These one-sided definitions are incorrect when these predicates appear negatively (i.e.,
in the scope of an odd number of negation symbols after all other proposition con-
nectives have been expressed in terms of A, V, and For example, an interpretation
</bodyText>
<footnote confidence="0.801697">
8 In the following axioms all of the connectives are to be interpreted as right-associative.
</footnote>
<page confidence="0.979161">
141
</page>
<note confidence="0.479391">
Computational Linguistics Volume 17, Number 2
</note>
<bodyText confidence="0.999475142857143">
with an empty in relation can satisfy -,null(x). As Johan van Benthem and the anony-
mous reviewer independently pointed out to me, it is possible to prove that so long as
the relations null, union, intersection, and singleton appear only positively in linguistic
constraints, any model satisfying 4&apos;-7&apos; differs from a model satisfying 4-7 at most in
the denotation of these relations; other relations, in particular the attribute relations or
even the in relation, are not affected by the one-sided approximation. The following
proposition expresses this.
</bodyText>
<subsectionHeader confidence="0.888673">
Proposition
</subsectionHeader>
<bodyText confidence="0.9972615">
Let x be a tuple of variables, A be any relation symbol, W(A) be any formula in which
A appears only positively, and (p(x) be a formula in which A does not appear. Then
</bodyText>
<listItem confidence="0.9244025">
(i) M 1= kli(A) A Vx A(x) 4-* co(x)
if and only if there is a model M&apos; differing from M only on the denotation it assigns
to A such that
(ii) .A4&apos; = W(A) A Vx A(x) -4
</listItem>
<subsectionHeader confidence="0.813951">
Proof
</subsectionHeader>
<bodyText confidence="0.999715777777778">
The left to right direction is obvious. The proposition follows from right to left as
follows. Let .A4&apos; be any model that satisfies (ii). A model M that satisfies (i) can be
constructed as follows. Let M be the model that agrees with .A4&apos; except possibly on A,
where viim u [Ax(p(x)1,,,,. Now we check that M satisfies (i). Since NM D
[Am, and A appears only positively in (A), A4 1= ill (A). Further M j= VxA(x) (p(x)
by construction. Since A does not appear in co(x), Ax(,o(x)] m = EfAx(p(x)]]A,t,, and since
AM D M 1= VxA(x) —&gt; (p(x) as well. Thus M satisfies (i) as required. In
fact we have shown something stronger; the denotation of A in .A4&apos; is a subset of the
denotation of A in M. •
</bodyText>
<subsectionHeader confidence="0.999871">
2.2 Expressing Constraints
</subsectionHeader>
<bodyText confidence="0.999979066666667">
A feature structure is specified implicitly by means of the constraints that it must sat-
isfy. This section shows how such constraints can be translated into quantifies-free and
function-free prenex formulae. There is a plethora of different notations for expressing
these constraints: the constraint requiring that the value of attribute a of (the entity
denoted by) x is (the entity denoted by) y is written as (x a) = y in PATR-II (Shieber
1986), as (x a) = y in LFG (Kaplan and Bresnan 1982), and as x(a) y in Johnson
(1988), for example. Here we express attribute-value constraints using the attribute
relations a, so this constraint would be expressed as a(x , y). Set-valued constraints are
expressed using the relations in, null, union, and singleton defined in the previous sec-
tion. The propositional connectives are used to express negative and disjunctive feature
constraints. This section shows how constraints on feature bundles can be specified
using equality, the attribute relations, and the set predicates axiomatized in the last
section. (In fact as far as the theoretical results of this paper are concerned all that is
important is that the constraints are taken to mean the same thing as these formulae,
irrespective of the notation in which they are expressed.)
</bodyText>
<page confidence="0.986859">
142
</page>
<figure confidence="0.6744334">
Johnson Features and Formulae
Example 2 (continued)
The lexical entries for salmon and swims in Figure 2 are the following formulae, where
e&apos;, e&amp;quot;, f&apos;, f&amp;quot; and g&amp;quot; are constants of the first-order language that are not attribute-value
constants.9
8a. pred(e&apos; , salmon) A agr(e&apos; , f&apos;) A pers(f&apos; , 3rd)
8b. pred(g&amp;quot; , swim) A tense(g&amp;quot; , pres)A subj(g&amp;quot; , e&amp;quot;)A agr(e&amp;quot; , f&amp;quot;)A
num(f&amp;quot; , sg)A pers(f&amp;quot; , 3rd).
Example 3 (continued)
The lexical entry for the determiner die of Figure 4 is the following formula, where x is
a (non—attribute-value) constant that denotes the feature structure of the determiner,
and y and z are constants that are not attribute-value constants.
9. cat(x, determiner)A agr(x, y)A (case(x, nom) V case(x, acc))A
(number(y, plural) V (number(y, singular)A gender(y, feminine)))
Example 4 (continued)
</figure>
<bodyText confidence="0.975195125">
The lexical entry for the verb swim of Figure 5 is the following formula, where g is a
constant that denotes the feature structure of the verb, and e and f are constants that
are not attribute-value constants.&amp;quot;
10. pred(g, swim)A tense(g, pres)A subj(g, e)A agr(e, f)A
—r(num(f, , sg)A pers(f, , 3rd))
The lexical entries for the determiners this and these of Figure 9 are the following
formulae, where u, v, u&apos; and are constants that are not attribute-value constants,
and u denotes the feature structure of this and u&apos; denotes the feature structure of these.
</bodyText>
<listItem confidence="0.4803072">
11. def(u, +) A agr(u, v) A num(v, sg) A pers(v, 3rd)
12. def(u&apos; , +) A agr(u/ , v&apos;) A num(v/ , pl) A pers(v1 , 3rd)
9 Instead of naming all of the nonroot attribute-value elements with constants as is done here, it is
possible to merely assert their existence using an existential quantification. For example, the lexical
entry for salmon could be the formula
</listItem>
<subsectionHeader confidence="0.483395">
Sf&apos;pred(e&apos;, salmon) A agr(ei , A pers(f&apos; , 3rd)
</subsectionHeader>
<bodyText confidence="0.9995826">
where f&apos; is an existentially quantified variable. This formulation has the advantage that no &apos;renaming&apos;
is needed when determining subsumption of systems of attribute-value constraints. (The subsumption
relation between systems of constraints is used in certain types of &apos;unification based&apos; parsers (Shieber
1989).) That is, a system of constraints represented by a formula (,o subsumes another system of
constraints represented by 6 iff A 0 —&gt; co, where A is the conjunction of the axioms defining the
relevant types of feature structures.
10 The formulation (10) of the negative constraint depicted in Figure 5 does not imply that f has either a
num or pers attribute. Conceivably, one might want to interpret such a negative constraint as requiring
f to have both num and pers attributes with values differing from either sg or 3rd, respectively. The
formula below expresses this interpretation.
</bodyText>
<construct confidence="0.4285095">
pred(g, swim) A tense(g, pres) A subj(g, e) A agr(e, f)A
num(f, , u) A pers(f, v) A = sg An = 3rd)
</construct>
<page confidence="0.995259">
143
</page>
<figure confidence="0.5437505">
Computational Linguistics Volume 17, Number 2
Example 5 (continued)
</figure>
<bodyText confidence="0.9259682">
The lexical entries for she and woman of Figure 6 are the formulae (13) and (14), where
u denotes the feature structure of the pronoun, v denotes the feature structure of the
noun, and w, s, s&apos;, s&amp;quot;, i, and i&apos; are constants that are not attribute-value constants.
13. cat (u , np) A refs-in(u, s) A refs-out(u , s) A index (u , i) A in(i, s)
14. cat(v, , n) A index (v , i&apos;)A refs-in(v, s&apos;)A refs-out(v, s&amp;quot;) A singleton(i&apos; , w) A
union(s&apos; , w, s&amp;quot;)
In general then, a system of feature structure constraints can be viewed as a function-
free and quantifier-free formula. These constraints are satisfiable if and only if there is
an interpretation that simultaneously satisfies the corresponding formula and the ax-
ioms presented in the previous section, or equivalently, the conjunction of this formula
and the relevant axioms from the axiomatization. This conjunction is itself a formula
from the Schonfinkel-Bernays class, and so the satisfiability problem for systems of
feature structure constraints is decidable.
Further, we can apply results on the computational complexity of the satisfiability
problem for the Schonfinkel-Bernays class to determine the computational complexity
of the satisfiability problem for systems of such feature constraints. Since (universal)
quantifiers appear only in the axiomatization of feature structures and not in the
feature constraints themselves, the number of quantifiers appearing in the conjunction
of the feature constraints and the axiomatization is a constant, and does not vary with
the size of the system of feature constraints. By Proposition 3.2 of Lewis (1980), the
satisfiability problem for a formula F with u universal quantifiers in the Schonfinkel-
Bernays class requires nondeterministic time polynomial in IF u, so the problem is in
NP. The reductions presented in Kasper and Rounds (1986) and Johnson (1988) can
be used to show that the problem is NP-hard, so the satisfiability problem for feature
constraints with set-values (as defined above) is NP-complete.
</bodyText>
<subsectionHeader confidence="0.999668">
2.3 Unification and Satisfaction
</subsectionHeader>
<bodyText confidence="0.999983421052632">
This section discusses the relationship between unification and the axiomatization
presented above.
Unification identifies or merges exactly the elements that the axiomatization im-
plies are equal. The unification of two complex elements e and e&apos; causes the unification
of the values of all attributes a that are defined on both e and e&apos;. Similarly, the con-
junction of the formulae e = e&apos;, a(e. f), a(e&apos; , I) and the axioms given above implies that
f = f, since axiom schema (3) requires that attributes are single valued.
Similarly, the unification of two attribute-value structures fails either when two
distinct constant elements are unified (a constant-constant clash) or when a constant
and a complex element are unified. The formula x = x&apos; is unsatisfiable under exactly
the same circumstances in the theory axiomatized above. The formula x = x&apos; conjoined
with x = c and x&apos; = c&apos; for distinct attribute-value constants c, c&apos; is unsatisfiable, since
c c&apos; by axiom schema (2). Also, x = x&apos; is unsatisfiable when conjoined with a(x,y)
for any y and x&apos; c, since —,a(c,y) by axiom schema (1).
If attention is restricted to purely conjunctive attribute-value systems, the corre-
sponding formulae can be represented as a directed graph, where nodes represent
(first-order) constants, and an arc labeled a from x to y encodes the atom a(x,y).
Then the standard attribute-value &apos;unification algorithm&apos; can be used as a specialized
inference procedure that takes as input such a graph encoding of a conjunction of
</bodyText>
<page confidence="0.993024">
144
</page>
<note confidence="0.56097">
Johnson Features and Formulae
</note>
<bodyText confidence="0.978695916666667">
attribute-value relations and returns (the graph encoding of) the conjunction of all of
their atomic consequences.
As Kasper (1986, 1987) noted in a different setting, the steps of the attribute-value
unification algorithm are just applications of the axioms 1-3. It &apos;forward chains&apos; using
axiom schema (3) (for which the graph representation provides efficient indexing),
and checks at each step that 1 and 2 are not falsified; if they are falsified the unifi-
cation algorithm halts and reports a unification failure. Atomic equalities x =y are
represented by a &apos;forwarding pointer&apos; from x to y (as in the UNION-FIND algorithm
(Gallier 1986; Nelson and Oppen 1980; Johnson in press)).
Example 2 (continued)
The unification of e&apos; and e&amp;quot; in Figures 2 and 3 corresponds to conjoining the formula
e&apos; -= e&amp;quot; to the conjunction of 8a and 8b, resulting in the formula 15a.
</bodyText>
<equation confidence="0.841001">
15a. e&apos; =- e&amp;quot;A pred(e&apos;, salmon)A agr(e&apos;,I)A pers(f&apos;,3rd)A pred(g&amp;quot;,swim)A
tense(g&amp;quot; , pres)A subj(g&amp;quot; , e&amp;quot;)A agr(e&amp;quot; , f&amp;quot;) A num(f&amp;quot; , sg)A pers(f&amp;quot; , 3rd).
</equation>
<bodyText confidence="0.998528333333333">
This formula can be simplified by substituting e&apos; for e&amp;quot; to yield 15b (this substitution
corresponds exactly to the first step of the unification algorithm, viz, redirecting e&amp;quot;
to e&apos;). The affected subformulae are in boldface below.
</bodyText>
<equation confidence="0.8130525">
15b. e&apos; = e&amp;quot;A pred(e&apos;,salmon)A agr(e&apos;, f&apos;)A pers(f&apos;,3rd)A pred(g&amp;quot;,swim)A
tense(g&amp;quot; , pres) A subj(g&amp;quot;, e&apos;)A agr(e&apos; , f&amp;quot;)A num(f&amp;quot; , sg)A pers(f&amp;quot; , 3rd).
</equation>
<bodyText confidence="0.965557588235294">
Since 15b contains the conjunction of agr(e&apos; , f&apos;) and agr(e&apos; , f&amp;quot;), axiom schema (3) re-
quires that f&apos; = f&amp;quot;, so 15b can be further simplified by substituting f&apos; for f&amp;quot; to
yield 15c.
15c. e&apos; = e&amp;quot;A f&apos; = f&amp;quot; A pred(e&apos; ,salmon)A agr(e&apos;,I)A pers(f&apos;,3rd)A
pred(g&amp;quot; , swim)A tense(g&amp;quot; , pres)A subj(g&amp;quot; , e&apos;)A agr(e&apos; , f&apos;) A num(f&apos; , sg)A
pers(f&apos; , 3rd).
The duplicate occurrences of agr(e&apos;, f&apos;) and pers(f&apos;,3rd) can be deleted, yielding 15d
(these last two steps correspond exactly to the unification of f&apos; and f&amp;quot; in Figure 3).
15d. e&apos; = e&amp;quot;A f&apos; = f&amp;quot; A pred(e&apos; ,salmon)A agr(e&apos;, f&apos;)A pers(f&apos;,3rd)A
pred(g&amp;quot; , swim)A tense(g&amp;quot; , pres)A subj(g&amp;quot;, e&apos;)A num (f&apos; , sg).
No further simplifications are possible, and 15d is satisfiable. In fact 15d describes the
structure depicted in Figure 3, as expected.
The standard unification algorithm is unable to handle negative constraints correctly,
as noted above. However, because negation is interpreted declaratively (in fact, clas-
sically) in the first-order language used to express constraints here, its treatment is
straightforward and unproblematic, and suggests ways of extending the unification
algorithm to cover these cases (Johnson 1990b, to appear).
</bodyText>
<page confidence="0.992206">
145
</page>
<figure confidence="0.734608181818182">
Computational Linguistics Volume 17, Number 2
pred =
subj =
e&apos;
tense =
swim
pred = salmon
agr = num = sg
f pers = 3rd
f
pres
</figure>
<figureCaption confidence="0.725352">
Figure 10
</figureCaption>
<bodyText confidence="0.713895">
A graphical depiction of the formula 16b
</bodyText>
<subsectionHeader confidence="0.617108">
Example 4 (continued)
</subsectionHeader>
<bodyText confidence="0.994723666666667">
The unification of e&apos; and e (i.e. the lexical entries for salmon and swim) of Figure 9
corresponds to the conjunction of the formula e = e&apos; to the conjunction of 8a and 10,
which is the formula 16a.
</bodyText>
<equation confidence="0.7101105">
16a. e = e&apos; A pred(e&apos;,salmon)A agr(e1,1)A pers(f&apos;,3rd)A pred(g,swim)A
tense(g,pres)A subj(g,e)A agr(e,f)A (num(f,sg)A pers(f,3rd))
</equation>
<bodyText confidence="0.90160325">
This can be simplified by straightforward applications of axiom schema (3), equality
substitution, and propositional equivalences to obtain 16b.
16b. e = e&apos; A f = f&apos; A pred(e,salmon)A pers(f,3rd)A pred(g,swim)A
tense(g,pres)A subj(g,e)A agr(e, f)A -inum(f, sg).
This formula could be depicted as in Figure 10, where such matrices are now to be
understood as graphical depictions of formulae. The further unification of e&apos; with u,
the lexical entry for this, corresponds to the conjunction of e&apos; = u to the conjunction of
the formulae 16b and 11, which is the formula 16c.
</bodyText>
<listItem confidence="0.646201">
16c. e = e&apos; A f = f&apos; A e&apos; = uA pred(e,salmon)A pers(f,3rd)A pred(g,swim)A
tense(g,pres)A subj(g,e)A agr(e,f)A -inum(f,sg)A def(u,+)A agr(u,v)A
num(v, sg) A pers(v, 3rd).
By substituting e for both e&apos; and u in 16c, we obtain 16d.
16d. e = e&apos; A f = f&apos; A e = uA pred(e,salmon)A pers(f,3rd)A pred(g,swim)A
tense(g,pres)A subj(g,e)A agr(e, f)A -inum(f, ,sg)A def(e,+)A agr(e, v)A
num(v, sg) A pers(v, 3rd).
</listItem>
<bodyText confidence="0.6794048">
Again, since 16d contains the conjunction of agr(e, f) and agr(e, v), axiom schema (3)
requires that f = v, so 16d can be further simplified by substituting f for v, yielding 16e.
16e. e = e&apos; A f = f&apos; A e = uA f = VA pred(e,salmon)A pers(f,3rd)A
pred(g, swim)A tense(g,pres)A subj(g, e)A agr(e, f)A -inum(f , sg)A
deffe, +)A agr(e,f)A num(f,sg)A pers(f,3rd).
</bodyText>
<page confidence="0.994585">
146
</page>
<note confidence="0.658681">
Johnson Features and Formulae
</note>
<equation confidence="0.995599142857143">
pred = swim
subj = pred = salmon
def = +
agr = num = pl
e&apos; f pers = 3rd
u&apos;_ v&apos;
g _ tense = pres
</equation>
<figureCaption confidence="0.675062">
Figure 11
</figureCaption>
<bodyText confidence="0.994685857142857">
A graphical depiction of the formula 16f
The formula 16e is unsatisfiable, since it contains conjunction of both num(f, , sg) and
its negation ---inum(f, sg). This is the desired result, since the utterance this salmon swim
is ill formed.
On the other hand, the unification e&apos; in 16b (c.f. Figure 10) is with u&apos;, the lexical
entry for these, corresponds to the conjunction of e&apos; = u&apos;, 16b and 12, which is the
formula 16c&apos;.
</bodyText>
<equation confidence="0.982919">
16c&apos;. e = e&apos;A f e&apos; = u&apos;A pred(e,salmon)A pers(f,3rd)A pred(g,swim)A
tense(g,pres)A subj(g,e)A agr(e,f)A --inum(f,sg)A def(u&apos;,+)A agr(u&apos;,v9A
num(v&apos;,p1)A pers(v&apos;,3rd).
</equation>
<bodyText confidence="0.92504425">
By following the same steps as were used to simplify 16c to 16e, 16c&apos; can be simplified
to 16e&apos;.
16e&apos;. e = e&apos; A f = f&apos; A e = u&apos;A f = v&apos; A pred(e,salmon)A pers(f,3rd)A
pred(g, swim)A tense(g, pres)A subj(g, e)A agr(e,f)A -,num(f , sg) A
def(e,+)A agr(e,f)A num(f,p1)A pers(f,3rd).
One of duplicate conjuncts agr(e,f) can be deleted, and since num(f,p1) implies
--inum(f,sg) (by instances sg pl of (2) and Vxyz num(x,y) A num(x,z) y = z of
(3)), 16e&apos; can be further simplified to 16f&apos;, where ---inum(f, sg) has also been deleted.
</bodyText>
<construct confidence="0.623022666666667">
16f&apos;. e = e&apos; A f e = u&apos; A f v&apos; A pred(e,salmon)A pers(f,3rd)A
pred(g, swim)A tense(g, pres)A subj(g, e)A agr(e,f)A def(e, -OA num(f, , pl)A
pers(f, 3rd).
</construct>
<bodyText confidence="0.9988872">
This formula is satisfiable, as desired, since the utterance these salmon swim is well
formed. This formula could be depicted as in Figure 11, where again the matrix is to
be understood as a graphical depiction of the formula 16f&apos;.
The set-valued examples are somewhat more complicated because they involve quan-
tification.
</bodyText>
<page confidence="0.988219">
147
</page>
<note confidence="0.4047385">
Computational Linguistics Volume 17, Number 2
Example 5 (continued)
</note>
<bodyText confidence="0.865228">
The unification of s&apos; with the empty set in Figure 6 corresponds to the conjunction of
14 with the formula null(s&apos;), as given in 17a.
</bodyText>
<equation confidence="0.723234">
17a. cat(v, n)A index(v, i&apos;)A refs-in(v, , s&apos; ) A refs-out(v, , s&amp;quot; ) A singleton(i&apos; , w)A
union(s&apos; , w, s&amp;quot;)A null(s&apos;).
Now singleton(i&apos; , w) A union(s&apos; , w, s&amp;quot;) implies by axioms (5) and (7) that Vu in(u, s&amp;quot;) 4—&gt;
u = i&apos; V in(u, s&apos;). Further, since null(s&apos;) implies by axiom (4) that Vu---,in(u, s&apos;), it follows
that 17a is equivalent to 17b.
17b. cat(v, n)A index(v, i&apos;)A refs-in(v, s&apos;)A refs-out(v, s&amp;quot;)A singleton(i&apos;, w)A
union(s&apos; , w, s&amp;quot;)A null(s&apos;)A Vu (in(u, s&amp;quot;) 4—&gt; u = i&apos;).
</equation>
<bodyText confidence="0.968067666666667">
Unifying the value of the refs-out attribute of Figure 7 with the value of the refs-in
attribute of u in Figure 6 corresponds to conjoining s = s&amp;quot; with the conjunction of 17b
and 13, yielding 17c.
</bodyText>
<construct confidence="0.767953875">
17c. s = s&amp;quot;A cat(u, np)A refs-in(u, s)A refs-out(u, s)A index(u, i)A in(i, s)A
cat(v, n) A index(v, i&apos;) A refs-in(v, , s&apos;) A refs-out(v, s&amp;quot;) A singleton(i&apos;, w) A
union(s&apos; , w, s&amp;quot; ) A null(s&apos;)A Vu (in(u, s&amp;quot;) 4—* u = i&apos;).
This can be simplified by substituting s for s&amp;quot; and noting that Vu (in(u, s) 4—&gt; u = i&apos;)
and in(i, s) implies that i = , as required.
17d. s = s&amp;quot; A cat (u , np)A refs-in(u, s)A refs-out(u, s) A index(u, i)A in(i, s) A
cat (v , n) A index(v, i) A refs-in(v, s&apos;) A refs-out(v, s) A singleton(i, w) A
union(s&apos; , w, s) A null(s&apos;)A Vu (in(u, s) 4—* u = i).
</construct>
<sectionHeader confidence="0.852759" genericHeader="conclusions">
3. Conclusion
</sectionHeader>
<bodyText confidence="0.9867855625">
The general approach adopted here of separating the feature structures and the con-
straints that they must satisfy is used in most accounts of feature structures. The novel
aspect of this work is that feature structures are axiomatized in and the constraints on
feature structures are expressed in a decidable class of first-order logic, so important
results such as decidability and compactness follow directly. The Schonfinkel-Bernays
class of formulae used in this paper are sufficiently expressive so that &amp;quot;set-valued&amp;quot;
features can be axiomatized quite directly.
We conclude with some tentative remarks about the implementation of the system
described here. Although a general-purpose first-order logic theorem prover could
be used to determine the satisfiability of Schonfinkel-Bernays formulae, it should be
possible to take advantage of the syntactic restrictions these formulae satisfy to obtain
a more efficient implementation. One way in which this might be done is as follows.
First, the axioms should be expressed in clausal form, i.e. in the form
xnV yn A1 A ... A Am —4 B1 V ... V Bn
where the A and 131 are atoms. These can be used in a &apos;forward chaining&apos; inference pro-
cedure using &apos;semi-naive evaluation&apos; (see Genesereth and Nilsson (1987) for details).
</bodyText>
<page confidence="0.98408">
148
</page>
<note confidence="0.520952">
Johnson Features and Formulae
</note>
<bodyText confidence="0.918632625">
For example, the clausal form expansion of axiom (5&apos;) for union is
18a. V xyzu union(x,y, z) A in(u, z) in(u , x) V in(u, y)
18b. V xyzu union(x, y, z) A in(u, x) --* in(u, z)
18c. V xyzu union(x, y, z) A in(u, y) in(u, z).
Second, if efficiency comparable to the standard (purely conjunctive) unification algo-
rithm is to be achieved, it is necessary to efficiently index atoms on their arguments
(both from the original constraints and those produced as consequences during the in-
ference process just described). If we were dealing with only purely conjunctive formu-
lae we could use a graph-based representation similar to the one used in the standard
attribute-value unification algorithm, but since axioms such as 18a have disjunctive
consequents we need a data structure that can represent nonconjunctive formulae,
even if all of the linguistic constraints associated with lexical entries and syntactic
rules are purely conjunctive. This problem is an instance of the general problem of
disjunction, and it seems that some of the techniques proposed in the feature-structure
literature to deal with disjunction (e.g. Eisele and Dorre 1988; Done and Eisele 1990;
Maxwell and Kaplan 1989a, 1989b) can be applied here too.
</bodyText>
<sectionHeader confidence="0.997992" genericHeader="acknowledgments">
Acknowledgments
</sectionHeader>
<reference confidence="0.889269">
I would like to thank Nick Asher, Jochen
Dorre, Andreas Eisele, Martin Emele,
Martin Kay, Ron Kaplan, Lauri Karttunen,
Harry Lewis, John Maxwell, Bill Rounds,
Gert Smolka, Stuart Shieber, Rich
Thomason, Johan van Benthem, and Jurgen
</reference>
<bodyText confidence="0.997681722222222">
Wedekind as well as an anonymous
reviewer and audiences at the CLIN Dag in
Utrecht and at the DFKI in Saarbriicken for
their important contributions to the material
presented in this paper. The idea of
translating feature constraints into a
specialized language with desirable
computational properties arose in
conversation with Jürgen Wedekind. Harry
Lewis noted that attribute-value structures
could be axiomatized using formulae from
the Schonfinkel-Bernays class, and guided
me to the relevant results. Naturally, all
errors remain my own. The final revision of
this paper was completed at the Institut fiir
maschinelle Sprachverarbeitung, Universitat
Stuttgart, which I thank for providing a
congenial research environment.
</bodyText>
<sectionHeader confidence="0.993715" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999001636363636">
Aczel, P. (1988). Non-Well-Founded Sets.
CSLI Lecture Notes Series, University of
Chicago Press, Chicago.
Bresnan, J. (1982). The Mental Representation
of Grammatical Relations. The MIT Press,
Cambridge, Mass.
Dawar, A. and Vijayashanker, K. (1990).
Three-Valued Interpretation of Negation in
Feature Structure Descriptions. University
of Delaware Technical Report 90-03.
Dawar, A. and Vijayashanker, K. (1989). &amp;quot;A
Three-Valued Interpretation of Negation
in Feature Structures,&amp;quot; in The 27th Annual
Meeting of the Association of Computational
Linguistics, Vancouver.
Dorre, J. and Eisele, A. (1990). &amp;quot;Feature
Logic with Disjunctive Unification,&amp;quot; in
The Proceedings of COLING-1990,
Helsinki, Finland.
Dorre, J. and Rounds, W. (1989). On
Subsumption and Semiunification in Feature
Algebras. IWBS Report, IBM Germany.
Dreben, B. and Goldfarb, W. D. (1979). The
Decision Problem: Solvable Classes of
Quantificational Formulas. Addison-Wesley,
Reading, Mass.
Eisele, A. and Dorre, J. (1988). &amp;quot;Unification
of Disjunctive Feature Descriptions,&amp;quot; in
The Proceedings of the 26th Annual Meeting
of the Association for Computational
Linguistics, Buffalo, New York, 286-294.
Gallier, J. H. (1986). Logic for Computer
Science. Harper and Row, New York.
Gazdar, G.; Klein, E.; Pullum, G.; and Sag, I.
(1985). Generalized Phrase Structure
Grammar. Blackwell, Oxford, England.
Genesereth, M. and Nilsson, N. (1987).
Logical Foundations of Artificial Intelligence.
Morgan Kaufmann, Los Altos.
Gurevich, Y. (1976). &amp;quot;The Decision Problem
for Standard Classes,&amp;quot; The Journal of
Symbolic Logic. 41.2, 460-464.
Haddock, N. J.; Klein, E.; and Morrill, G.
(1987). Categorial Grammar, Unification
</reference>
<page confidence="0.995718">
149
</page>
<reference confidence="0.998448902439024">
Computational Linguistics Volume 17, Number 2
Grammar. University of Edinburgh
Edinburgh Working Papers in Cognitive
Science 1.
Johnson, M. (1991). &amp;quot;Logic and Feature
Structures,&amp;quot; in Proceedings of IJCAI 1991,
Sydney.
Johnson, M. (1990a). &amp;quot;Expressing
Disjunctive and Negative Feature
Constraints with Classical First-order
Logic,&amp;quot; in The Proceedings of the 28th
Annual Meeting of the Association for
Computational Linguistics, Pittsburgh, PA.
Johnson, M. (1990b). &amp;quot;Features, Frames and
Quantifier-Free Formulae,&amp;quot; in
P. Saint-Dizier and S. Szpakowicz, eds.,
Logic and Logic Grammars for Language
Processing, Ellis Horwood, New York.
Johnson, M. (1988). Attribute-Value Logic and
the Theory of Grammar. CSLI Lecture Notes
Series, University of Chicago Press,
Chicago.
Johnson, M. (in press). &amp;quot;Attribute-Value
Logic and Natural Language Processing,&amp;quot;
in J. Wedekind, ed., Studies in Unification
Grammar, The MIT Press, Cambridge,
Mass. (originally presented at the Titisee
Conference, Germany, 1988).
Johnson, M. and Kay, M. (1990). &amp;quot;Semantic
Operators and Anaphora,&amp;quot; in The
Proceedings of COLING 1990, Helsinki,
Finland.
Johnson, M. and Klein, E. (1986).
&amp;quot;Discourse, Parsing and Anaphora,&amp;quot; in
The Proceedings of COLING 1986, Bonn,
West Germany.
Kamp, H. (1981). &amp;quot;A Theory of Truth and
Semantic Representation,&amp;quot; in
J. A. G. Groenendijk, T. M. V. Janssem
and M. B. J. Stokhof, eds., Formal Methods
in the Study of Language, Mathematical
Centre Tracts, Amsterdam.
Kaplan, R. and Bresnan, J. (1982).
&amp;quot;Lexical-functional grammar, a formal
system for grammatical representation,&amp;quot;
in J. Bresnan, ed., The Mental
Representation of Grammatical Relations,
The MIT Press, Cambridge, Mass.
Karttunen, L. (1984). &amp;quot;Features and Values,&amp;quot;
in COLING-1984, The Association for
Computational Linguistics, Stanford
University.
Kasper, R. T. (1988). &amp;quot;Conditional
Descriptions in Functional Unification
Grammar,&amp;quot; in Proceedings of the 26th
Annual Meeting of the Association for
Computational Linguistics, Buffalo, New
York.
Kasper, R. T. (1987). &amp;quot;A Unification Method
for Disjunctive Feature Structures,&amp;quot; in The
Proceedings of the 25th Annual Meeting of
the Association for Computational
Linguistics, Stanford University.
Kasper, R. T. (1986). Feature Structures: A
Logical Theory with Application to Language
Analysis, Ph.D. Thesis, University of
Michigan.
Kasper, R. T. and Rounds, W. C. (1990).
&amp;quot;The Logic of Unification in Grammar,&amp;quot;
Linguistics and Philosophy. 13.1, 35-58.
Kasper, R. T. and Rounds, W. C. (1986). &amp;quot;A
Logical Semantics for Feature Structures,&amp;quot;
in The Proceedings of the 24th Annual
Meeting of the Association for Computational
Linguistics, Columbia University, New
York.
Kay, M. (1985). &amp;quot;Unification in Grammar,&amp;quot;
in V. Dahl and P. Saint-Dizier, eds.,
Natural Language Understanding and Logic
Programming, North Holland, Amsterdam,
The Netherlands.
Langholm, T. (1989). How to Say No with
Feature Structures. Department of
Mathematics, University of Oslo,
COSMOS Report No. 13.
Lewis, H. (1980). &amp;quot;Complexity Results for
Classes of Quantificational Formulae,&amp;quot;
Journal of Computer and System Sciences. 21,
317-353.
Lewis, H. and Papadimitriou, C. (1981).
Elements of the Theory of Computation.
Prentice Hall, New Jersey.
Maxwell, J. and Kaplan, R. (1989a). A
Method for Disjunctive Constraint
Satisfaction. Xerox PARC ms.
Maxwell, J. T., III and Kaplan, R. (1989b).
&amp;quot;An Overview of Disjunctive Constraint
Satisfaction,&amp;quot; in International Workshop on
Parsing Technologies, Carnegie Mellon,
Pittsburgh, PA.
Moshier, M. (1988). Extensions to Unification
Grammar for the Description of Programming
Languages, Ph.D. Thesis, University of
Michigan.
Moshier, M. D. and Rounds, W. C. (1987).
&amp;quot;A Logic for Partially Specified Data
Structures,&amp;quot; in The ACM Symposium on the
Principles of Programming Languages,
Association for Computing Machinery,
Munich, Germany.
Nebel, B. and Smolka, G. (1989).
Representation and Reasoning with
Attributive Descriptions. IBM Stuttgart
IWBS Report 81.
Nelson, G. and Oppen, D. C. (1980). &amp;quot;Fast
Decision Procedures Based on
Congruence Closure,&amp;quot; Journal of the
Association for Computing Machinery. 27.2,
245-257.
Pereira, F. C. N. (1987). &amp;quot;Grammars and
Logics of Partial Information,&amp;quot; in The
Proceedings of the International Conference
on Logic Programming, Melbourne,
</reference>
<page confidence="0.979107">
150
</page>
<reference confidence="0.998886">
Johnson Features and Formulae
Australia.
Pereira, F. C. N. and Shieber, S. M. (1984).
&amp;quot;The Semantics of Grammar Formalisms
Seen as Computer Languages,&amp;quot; in
COLING-84, The Association for
Computational Linguistics, Stanford
University.
Pollard, C. and Sag, I. (1987).
Information-Based Syntax and Semantics,
Volume 1. CSLI Lecture Notes, Chicago
University Press, Chicago.
Rounds, W. (1988). Set Values for
Unification-Based Grammar Formalisms and
Logic Programming. Center for the Study
of Language and Information CSLI
Report 129.
Shieber, S. M. (1989). Parsing and Type
Inference for Natural and Computer
Languages. SRI International Technical
Note 460.
Shieber, S. M. (1986). An Introduction to
Unification-Based Approaches to Grammar.
CSLI Lecture Notes Series, University of
Chicago Press, Chicago.
Smolka, G. (1989a). Attributive Concept
Descriptions with Unions and Complements.
IBM Stuttgart IWBS Report 68.
Smolka, G. (1989b). Feature Constraint Logics
for Unification Grammars. IBM
Deutschland Wissenschaftliches Zentrum
IWBS Report No. 93.
Smolka, G. (1988). A Feature Logic with
Subsorts. IBM Deutschland GmbH. Lilog
Report No. 33.
Uszkoreit, H. (1986). &amp;quot;Categorial Unification
Grammar,&amp;quot; in COLING-86, 187-194.
</reference>
<page confidence="0.998348">
151
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.867645">
<title confidence="0.999775">Features and Formulae</title>
<author confidence="0.999995">Mark Johnson</author>
<affiliation confidence="0.999966">Brown University</affiliation>
<abstract confidence="0.976731666666667">Feature structures are a representational device used in several current linguistic theories. This paper shows how these structures can be axiomatized in a decidable class of first-order logic, which can also be used to express constraints on these structures. Desirable properties, such as compactness and decidability, follow directly. Moreover, additional types of feature values, such as &amp;quot;set-valued&amp;quot; features, can be incorporated into the system simply by axiomatizing their properties.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="false">
<authors>
<author>Rich Thomason Shieber</author>
<author>Johan van Benthem</author>
</authors>
<title>I would like to thank Nick Asher, Jochen Dorre, Andreas Eisele,</title>
<location>Martin Emele, Martin Kay, Ron Kaplan, Lauri Karttunen, Harry Lewis, John Maxwell, Bill Rounds, Gert Smolka, Stuart</location>
<marker>Shieber, van Benthem, </marker>
<rawString>I would like to thank Nick Asher, Jochen Dorre, Andreas Eisele, Martin Emele, Martin Kay, Ron Kaplan, Lauri Karttunen, Harry Lewis, John Maxwell, Bill Rounds, Gert Smolka, Stuart Shieber, Rich Thomason, Johan van Benthem, and Jurgen</rawString>
</citation>
<citation valid="true">
<authors>
<author>P Aczel</author>
</authors>
<title>Non-Well-Founded Sets.</title>
<date>1988</date>
<booktitle>CSLI Lecture Notes Series, University of</booktitle>
<publisher>Chicago Press,</publisher>
<location>Chicago.</location>
<contexts>
<context position="26453" citStr="Aczel (1988)" startWordPosition="4221" endWordPosition="4222">et theory. Thus this axiomatization presented here will admit models in which the values of set-valued features do not have these properties.7 These additional properties of the set-membership relation don&apos;t seem to be needed in linguistic analyses, so such stipulations are not made here. The axiom of foundation requires that all sets are well founded; i.e., that the transitive closure of the set-membership relation is irreflexive, or more informally, that no set directly or indirectly contains itself as a member. Versions of set-theory that relax this restriction have been proposed by, e.g., Aczel (1988), and Rounds (1988) argues that non—well founded sets may be appropriate models of set values in feature structures. The paradoxes associated with non—well founded set theories are avoided here because the axiom of comprehension that asserts the existence of paradoxical sets is not included in this axiomatization; i.e., the only way of defining a set is either by explicitly listing its members or by means of union and intersection operations. The axiom of extensionality requires that if sets Si and 52 contain exactly the same members then Si = S2; without extensionality it is possible for two </context>
</contexts>
<marker>Aczel, 1988</marker>
<rawString>Aczel, P. (1988). Non-Well-Founded Sets. CSLI Lecture Notes Series, University of Chicago Press, Chicago.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Bresnan</author>
</authors>
<title>The Mental Representation of Grammatical Relations.</title>
<date>1982</date>
<publisher>The MIT Press,</publisher>
<location>Cambridge, Mass.</location>
<contexts>
<context position="643" citStr="Bresnan 1982" startWordPosition="86" endWordPosition="87">nson. Brown University Feature structures are a representational device used in several current linguistic theories. This paper shows how these structures can be axiomatized in a decidable class of first-order logic, which can also be used to express constraints on these structures. Desirable properties, such as compactness and decidability, follow directly. Moreover, additional types of feature values, such as &amp;quot;set-valued&amp;quot; features, can be incorporated into the system simply by axiomatizing their properties. 1. Introduction Many modern linguistic theories, such as Lexical-Functional Grammar (Bresnan 1982), Functional Unification Grammar (Kay 1985), Generalized Phrase Structure Grammar (Gazdar et al. 1985), Unification Categorial Grammar (Haddock et al. 1987), (Uszkoreit 1986), and Head-Driven Phrase Structure Grammar (Pollard and Sag 1987), replace the atomic categories of a context-free grammar with a &amp;quot;feature structure&amp;quot; that represents the syntactic and semantic properties of the phrase. These feature structures are specified indirectly in terms of constraints that they must satisfy Lexical entries constrain the feature structures that can be associated with terminal nodes of the syntactic t</context>
<context position="7016" citStr="Bresnan 1982" startWordPosition="1151" endWordPosition="1152"> pred attribute. The attribute-value structure for the sentence (the) salmon swims is obtained by unifying e&apos; and e&amp;quot;, which corresponds to identifying salmon as the subject of swims. The resulting element inherits the value of the pred attribute from e&apos; and the value of the num attribute from e&amp;quot;. The unification of e&apos; and e&amp;quot; requires the unification off&apos; and f&amp;quot; as well. Although it might not be obvious from this simple example, a large number of syntactic constructions from a variety of natural languages can be described in such a unification-based framework (many of the analyses presented in Bresnan 1982 can be expressed in such a &amp;quot;pure&amp;quot; unification-based framework). Nevertheless, it is often convenient and sometimes necessary to extend the basic unification framework to include a wider variety of feature structures. For example, &amp;quot;negative values&amp;quot; and &amp;quot;disjunctive values&amp;quot; allow grammars and lexical entries to be written much more succinctly, as the following examples show (based on Karttunen 1984). 133 Computational Linguistics Volume 17, Number 2 cat = determiner number: singular agr = gender: feminine number: plural die case = /nom \ \ ace Figure 4 Disjunction in the lexical entry for die s</context>
<context position="13889" citStr="Bresnan (1982)" startWordPosition="2334" endWordPosition="2335"> not satisfy f. If e&apos; is first unified with u&apos; then f&apos; is unified with v&apos; and further unification of e&apos; with e succeeds, since v&apos; does satisfy f. Thus under this interpretation agr = [pers = 3rd &apos; 136 Johnson Features and Formulae of negation and unification, the success or failure of a sequence of unifications depends on the order in which they are performed.4 2. Feature Structures and Function-free Formulae These problems have generated a considerable body of work on the mathematical properties of feature structures and the constraints and operations that apply to them. Following Kaplan and Bresnan (1982), Pereira and Shieber (1984), Kasper and Rounds (1986, 1990), and Johnson (1988, 1990a) the constraints that determine the feature structures are regarded as formulae from a language for describing feature structures, rather than as feature structures themselves. Disjunction and negation appear only in expressions from the description language, rather than as components of the feature structures that these expressions describe. Thus the lexical entries in the examples above will be interpreted as formulae that constrain the feature structures that can be associated with these lexical items in </context>
<context position="18787" citStr="Bresnan 1982" startWordPosition="3052" endWordPosition="3053"> example, subsumption constraints, which are useful in the description of agreement phenomena in coordination constructions (Shieber 1989) can be used to encode undecidable problems, as Dorre and Rounds (1989) have shown. Clearly such constraints cannot be expressed in a decidable class, but often they can be axiomatized in other standard logics. Johnson (1991) shows how (positively occurring) subsumption constraints can be axiomatized in first-order logic, and sketches treatments of sort constraints and nonmonotonic devices such as ANY values (Kay 1985) and &apos;constraint equations&apos; (Kaplan and Bresnan 1982) can be formalized in second-order logic using circumscription. 2.1 Axiomatizing Feature Structures with Function-Free Formulae This section shows how the important properties of feature structures can be axiomatized using formulae from the Schtinfinkel-Bernays class, which is the class of first-order formulae of the form . xnVyi • • • yn(10 where co contains no function symbols or quantifiers. (Thus no existential quantifier can appear in the scope of a universal quantifier.) This class of formulae was chosen because it is both decidable (see e.g. Lewis and Papadimitriou 1981) and can express</context>
<context position="27803" citStr="Bresnan 1982" startWordPosition="4431" endWordPosition="4432">t appear to be axiomatizable using SchonfinkelBernays&apos; formulae, but three other reasons motivate this decision. First, as noted in Shieber (1986) and in Example 1 above, feature structures in general are not extensional (e.g., two distinct attribute-value elements can have exactly the same attributes and values), and it seems reasonable to treat set-values in a nonextensional fashion as well. Second, extensionality could produce undesirable interactions with the attributevalue component of feature structures. Since set-valued features can also have attributes (for example, in LFG (Kaplan and Bresnan 1982)) a conjunction is associated with a set-value that also has attributes), extensionality would prohibit there being 7 In fact there are Schonfinkel-Bernays axioms that require the in relation to be acyclic. Define a new relation, say ink, by the axioms V s in(e, s) in+ (e, s) V es s&apos; in+ (e, s) A in+ (s, s&apos;) in+ (e, s&apos;). Then in any model in+ denotes a superset of the transitive closure of the in relation. The following axiom requires that this transitive closure is irreflexive, i.e. that no set is contained in itself. Vs (s, s). 140 Johnson Features and Formulae two set-valued features that c</context>
<context position="33113" citStr="Bresnan 1982" startWordPosition="5378" endWordPosition="5379"> something stronger; the denotation of A in .A4&apos; is a subset of the denotation of A in M. • 2.2 Expressing Constraints A feature structure is specified implicitly by means of the constraints that it must satisfy. This section shows how such constraints can be translated into quantifies-free and function-free prenex formulae. There is a plethora of different notations for expressing these constraints: the constraint requiring that the value of attribute a of (the entity denoted by) x is (the entity denoted by) y is written as (x a) = y in PATR-II (Shieber 1986), as (x a) = y in LFG (Kaplan and Bresnan 1982), and as x(a) y in Johnson (1988), for example. Here we express attribute-value constraints using the attribute relations a, so this constraint would be expressed as a(x , y). Set-valued constraints are expressed using the relations in, null, union, and singleton defined in the previous section. The propositional connectives are used to express negative and disjunctive feature constraints. This section shows how constraints on feature bundles can be specified using equality, the attribute relations, and the set predicates axiomatized in the last section. (In fact as far as the theoretical resu</context>
</contexts>
<marker>Bresnan, 1982</marker>
<rawString>Bresnan, J. (1982). The Mental Representation of Grammatical Relations. The MIT Press, Cambridge, Mass.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Dawar</author>
<author>K Vijayashanker</author>
</authors>
<title>Three-Valued Interpretation of Negation in Feature Structure Descriptions.</title>
<date>1990</date>
<tech>Technical Report 90-03.</tech>
<institution>University of Delaware</institution>
<marker>Dawar, Vijayashanker, 1990</marker>
<rawString>Dawar, A. and Vijayashanker, K. (1990). Three-Valued Interpretation of Negation in Feature Structure Descriptions. University of Delaware Technical Report 90-03.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Dawar</author>
<author>K Vijayashanker</author>
</authors>
<title>A Three-Valued Interpretation of Negation in Feature Structures,&amp;quot;</title>
<date>1989</date>
<booktitle>in The 27th Annual Meeting of the Association of Computational Linguistics,</booktitle>
<location>Vancouver.</location>
<contexts>
<context position="15850" citStr="Dawar and Vijayashanker (1989" startWordPosition="2616" endWordPosition="2619">of that conjunction (Kasper and Rounds 1990; Johnson 1988, 1990a; Pereira 1987). The most widely known model of feature structures and constraint language is the one developed to explain disjunctive feature values by Kasper and Rounds (1986, 1990) and Kasper (1986, 1987). The Kasper—Rounds treatment resolves the difficulties in interpreting disjunctive values by developing a specialized language for expressing these constraints. Various proposals to extend the Kasper—Rounds approach to deal with negative feature values are described by Moshier and Rounds (1987), Moshier (1988), Kasper (1988), Dawar and Vijayashanker (1989, 1990), Langholm (1989); other extensions to this framework are discussed by Dorre and Rounds (1989), Smolka (1988, 1989), and Nebel and Smolka (1989); and Shieber (1989) discusses the integration of such feature systems into a variety of parsing algorithms. One difficulty with this approach is that the constraint language is &amp;quot;custom built,&amp;quot; so important properties, such as compactness and decidability, must be investigated from scratch. Moreover, it is often unclear if the treatment can be extended to handle other types of feature structures as well. Rounds (1988) proposes a model for set-va</context>
</contexts>
<marker>Dawar, Vijayashanker, 1989</marker>
<rawString>Dawar, A. and Vijayashanker, K. (1989). &amp;quot;A Three-Valued Interpretation of Negation in Feature Structures,&amp;quot; in The 27th Annual Meeting of the Association of Computational Linguistics, Vancouver.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Dorre</author>
<author>A Eisele</author>
</authors>
<title>Feature Logic with Disjunctive Unification,&amp;quot;</title>
<date>1990</date>
<booktitle>in The Proceedings of COLING-1990,</booktitle>
<location>Helsinki, Finland.</location>
<marker>Dorre, Eisele, 1990</marker>
<rawString>Dorre, J. and Eisele, A. (1990). &amp;quot;Feature Logic with Disjunctive Unification,&amp;quot; in The Proceedings of COLING-1990, Helsinki, Finland.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Dorre</author>
<author>W Rounds</author>
</authors>
<title>On Subsumption and Semiunification in Feature Algebras.</title>
<date>1989</date>
<tech>IWBS Report, IBM Germany.</tech>
<contexts>
<context position="15951" citStr="Dorre and Rounds (1989)" startWordPosition="2631" endWordPosition="2634">l of feature structures and constraint language is the one developed to explain disjunctive feature values by Kasper and Rounds (1986, 1990) and Kasper (1986, 1987). The Kasper—Rounds treatment resolves the difficulties in interpreting disjunctive values by developing a specialized language for expressing these constraints. Various proposals to extend the Kasper—Rounds approach to deal with negative feature values are described by Moshier and Rounds (1987), Moshier (1988), Kasper (1988), Dawar and Vijayashanker (1989, 1990), Langholm (1989); other extensions to this framework are discussed by Dorre and Rounds (1989), Smolka (1988, 1989), and Nebel and Smolka (1989); and Shieber (1989) discusses the integration of such feature systems into a variety of parsing algorithms. One difficulty with this approach is that the constraint language is &amp;quot;custom built,&amp;quot; so important properties, such as compactness and decidability, must be investigated from scratch. Moreover, it is often unclear if the treatment can be extended to handle other types of feature structures as well. Rounds (1988) proposes a model for set-valued features, but he does not provide a language for expressing constraints on such set-valued entit</context>
<context position="18383" citStr="Dorre and Rounds (1989)" startWordPosition="2992" endWordPosition="2995">as well. In this paper the properties of attribute-value structures and constraints on them are expressed in a decidable class of first-order formulae: this means that the satisfiability problem for such formulae, and hence the feature constraints that they express, is always decidable. Of course, some linguistic analyses make use of feature structure constraint systems that can encode undecidable problems. For example, subsumption constraints, which are useful in the description of agreement phenomena in coordination constructions (Shieber 1989) can be used to encode undecidable problems, as Dorre and Rounds (1989) have shown. Clearly such constraints cannot be expressed in a decidable class, but often they can be axiomatized in other standard logics. Johnson (1991) shows how (positively occurring) subsumption constraints can be axiomatized in first-order logic, and sketches treatments of sort constraints and nonmonotonic devices such as ANY values (Kay 1985) and &apos;constraint equations&apos; (Kaplan and Bresnan 1982) can be formalized in second-order logic using circumscription. 2.1 Axiomatizing Feature Structures with Function-Free Formulae This section shows how the important properties of feature structure</context>
</contexts>
<marker>Dorre, Rounds, 1989</marker>
<rawString>Dorre, J. and Rounds, W. (1989). On Subsumption and Semiunification in Feature Algebras. IWBS Report, IBM Germany.</rawString>
</citation>
<citation valid="true">
<authors>
<author>B Dreben</author>
<author>W D Goldfarb</author>
</authors>
<title>The Decision Problem: Solvable Classes of Quantificational Formulas.</title>
<date>1979</date>
<publisher>Addison-Wesley,</publisher>
<location>Reading, Mass.</location>
<contexts>
<context position="19651" citStr="Dreben and Goldfarb 1979" startWordPosition="3182" endWordPosition="3185"> Schtinfinkel-Bernays class, which is the class of first-order formulae of the form . xnVyi • • • yn(10 where co contains no function symbols or quantifiers. (Thus no existential quantifier can appear in the scope of a universal quantifier.) This class of formulae was chosen because it is both decidable (see e.g. Lewis and Papadimitriou 1981) and can express the quantification needed to describe the particular set operations proposed here, as well as a variety of other interesting types of feature structures and constraints. (For a general discussion of decidable classes see Gurevich 1976 and Dreben and Goldfarb 1979.) The next section shows how the various kinds of constraints on feature structures described above can be translated into this class of formulae, so any system of such feature constraints is decidable as well. The elements of a feature structure, both complex and constant, constitute the domain of individuals in the intended interpretation. The attributes are binary relations over this domain.5 We proceed by axiomatizing the conditions under which an interpretation corresponds to a well-formed feature structure, formulating them in essentially the same way as Smolka (1988, 1989) does. The ax</context>
</contexts>
<marker>Dreben, Goldfarb, 1979</marker>
<rawString>Dreben, B. and Goldfarb, W. D. (1979). The Decision Problem: Solvable Classes of Quantificational Formulas. Addison-Wesley, Reading, Mass.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Eisele</author>
<author>J Dorre</author>
</authors>
<title>Unification of Disjunctive Feature Descriptions,&amp;quot;</title>
<date>1988</date>
<booktitle>in The Proceedings of the 26th Annual Meeting of the Association for Computational Linguistics,</booktitle>
<pages>286--294</pages>
<location>Buffalo, New York,</location>
<marker>Eisele, Dorre, 1988</marker>
<rawString>Eisele, A. and Dorre, J. (1988). &amp;quot;Unification of Disjunctive Feature Descriptions,&amp;quot; in The Proceedings of the 26th Annual Meeting of the Association for Computational Linguistics, Buffalo, New York, 286-294.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J H Gallier</author>
</authors>
<title>Logic for Computer Science. Harper and Row,</title>
<date>1986</date>
<location>New York.</location>
<contexts>
<context position="40991" citStr="Gallier 1986" startWordPosition="6666" endWordPosition="6667">d returns (the graph encoding of) the conjunction of all of their atomic consequences. As Kasper (1986, 1987) noted in a different setting, the steps of the attribute-value unification algorithm are just applications of the axioms 1-3. It &apos;forward chains&apos; using axiom schema (3) (for which the graph representation provides efficient indexing), and checks at each step that 1 and 2 are not falsified; if they are falsified the unification algorithm halts and reports a unification failure. Atomic equalities x =y are represented by a &apos;forwarding pointer&apos; from x to y (as in the UNION-FIND algorithm (Gallier 1986; Nelson and Oppen 1980; Johnson in press)). Example 2 (continued) The unification of e&apos; and e&amp;quot; in Figures 2 and 3 corresponds to conjoining the formula e&apos; -= e&amp;quot; to the conjunction of 8a and 8b, resulting in the formula 15a. 15a. e&apos; =- e&amp;quot;A pred(e&apos;, salmon)A agr(e&apos;,I)A pers(f&apos;,3rd)A pred(g&amp;quot;,swim)A tense(g&amp;quot; , pres)A subj(g&amp;quot; , e&amp;quot;)A agr(e&amp;quot; , f&amp;quot;) A num(f&amp;quot; , sg)A pers(f&amp;quot; , 3rd). This formula can be simplified by substituting e&apos; for e&amp;quot; to yield 15b (this substitution corresponds exactly to the first step of the unification algorithm, viz, redirecting e&amp;quot; to e&apos;). The affected subformulae are in boldfac</context>
</contexts>
<marker>Gallier, 1986</marker>
<rawString>Gallier, J. H. (1986). Logic for Computer Science. Harper and Row, New York.</rawString>
</citation>
<citation valid="true">
<authors>
<author>G Gazdar</author>
<author>E Klein</author>
<author>G Pullum</author>
<author>I Sag</author>
</authors>
<date>1985</date>
<booktitle>Generalized Phrase Structure Grammar.</booktitle>
<location>Blackwell, Oxford, England.</location>
<contexts>
<context position="745" citStr="Gazdar et al. 1985" startWordPosition="97" endWordPosition="100">linguistic theories. This paper shows how these structures can be axiomatized in a decidable class of first-order logic, which can also be used to express constraints on these structures. Desirable properties, such as compactness and decidability, follow directly. Moreover, additional types of feature values, such as &amp;quot;set-valued&amp;quot; features, can be incorporated into the system simply by axiomatizing their properties. 1. Introduction Many modern linguistic theories, such as Lexical-Functional Grammar (Bresnan 1982), Functional Unification Grammar (Kay 1985), Generalized Phrase Structure Grammar (Gazdar et al. 1985), Unification Categorial Grammar (Haddock et al. 1987), (Uszkoreit 1986), and Head-Driven Phrase Structure Grammar (Pollard and Sag 1987), replace the atomic categories of a context-free grammar with a &amp;quot;feature structure&amp;quot; that represents the syntactic and semantic properties of the phrase. These feature structures are specified indirectly in terms of constraints that they must satisfy Lexical entries constrain the feature structures that can be associated with terminal nodes of the syntactic tree, and phrase structure rules simultaneously constrain the feature structures that can be associated</context>
</contexts>
<marker>Gazdar, Klein, Pullum, Sag, 1985</marker>
<rawString>Gazdar, G.; Klein, E.; Pullum, G.; and Sag, I. (1985). Generalized Phrase Structure Grammar. Blackwell, Oxford, England.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Genesereth</author>
<author>N Nilsson</author>
</authors>
<date>1987</date>
<booktitle>Logical Foundations of Artificial Intelligence.</booktitle>
<publisher>Morgan Kaufmann,</publisher>
<location>Los Altos.</location>
<contexts>
<context position="49260" citStr="Genesereth and Nilsson (1987)" startWordPosition="8099" endWordPosition="8102">ation of the system described here. Although a general-purpose first-order logic theorem prover could be used to determine the satisfiability of Schonfinkel-Bernays formulae, it should be possible to take advantage of the syntactic restrictions these formulae satisfy to obtain a more efficient implementation. One way in which this might be done is as follows. First, the axioms should be expressed in clausal form, i.e. in the form xnV yn A1 A ... A Am —4 B1 V ... V Bn where the A and 131 are atoms. These can be used in a &apos;forward chaining&apos; inference procedure using &apos;semi-naive evaluation&apos; (see Genesereth and Nilsson (1987) for details). 148 Johnson Features and Formulae For example, the clausal form expansion of axiom (5&apos;) for union is 18a. V xyzu union(x,y, z) A in(u, z) in(u , x) V in(u, y) 18b. V xyzu union(x, y, z) A in(u, x) --* in(u, z) 18c. V xyzu union(x, y, z) A in(u, y) in(u, z). Second, if efficiency comparable to the standard (purely conjunctive) unification algorithm is to be achieved, it is necessary to efficiently index atoms on their arguments (both from the original constraints and those produced as consequences during the inference process just described). If we were dealing with only purely c</context>
</contexts>
<marker>Genesereth, Nilsson, 1987</marker>
<rawString>Genesereth, M. and Nilsson, N. (1987). Logical Foundations of Artificial Intelligence. Morgan Kaufmann, Los Altos.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Y Gurevich</author>
</authors>
<title>The Decision Problem for Standard Classes,&amp;quot;</title>
<date>1976</date>
<journal>The Journal of Symbolic Logic.</journal>
<volume>41</volume>
<pages>460--464</pages>
<contexts>
<context position="19622" citStr="Gurevich 1976" startWordPosition="3179" endWordPosition="3180"> formulae from the Schtinfinkel-Bernays class, which is the class of first-order formulae of the form . xnVyi • • • yn(10 where co contains no function symbols or quantifiers. (Thus no existential quantifier can appear in the scope of a universal quantifier.) This class of formulae was chosen because it is both decidable (see e.g. Lewis and Papadimitriou 1981) and can express the quantification needed to describe the particular set operations proposed here, as well as a variety of other interesting types of feature structures and constraints. (For a general discussion of decidable classes see Gurevich 1976 and Dreben and Goldfarb 1979.) The next section shows how the various kinds of constraints on feature structures described above can be translated into this class of formulae, so any system of such feature constraints is decidable as well. The elements of a feature structure, both complex and constant, constitute the domain of individuals in the intended interpretation. The attributes are binary relations over this domain.5 We proceed by axiomatizing the conditions under which an interpretation corresponds to a well-formed feature structure, formulating them in essentially the same way as Smo</context>
</contexts>
<marker>Gurevich, 1976</marker>
<rawString>Gurevich, Y. (1976). &amp;quot;The Decision Problem for Standard Classes,&amp;quot; The Journal of Symbolic Logic. 41.2, 460-464.</rawString>
</citation>
<citation valid="true">
<authors>
<author>N J Haddock</author>
<author>E Klein</author>
<author>G Morrill</author>
</authors>
<title>Working Papers in</title>
<date>1987</date>
<journal>Categorial Grammar, Unification Computational Linguistics</journal>
<volume>17</volume>
<institution>Grammar. University of Edinburgh Edinburgh</institution>
<contexts>
<context position="799" citStr="Haddock et al. 1987" startWordPosition="104" endWordPosition="107">tures can be axiomatized in a decidable class of first-order logic, which can also be used to express constraints on these structures. Desirable properties, such as compactness and decidability, follow directly. Moreover, additional types of feature values, such as &amp;quot;set-valued&amp;quot; features, can be incorporated into the system simply by axiomatizing their properties. 1. Introduction Many modern linguistic theories, such as Lexical-Functional Grammar (Bresnan 1982), Functional Unification Grammar (Kay 1985), Generalized Phrase Structure Grammar (Gazdar et al. 1985), Unification Categorial Grammar (Haddock et al. 1987), (Uszkoreit 1986), and Head-Driven Phrase Structure Grammar (Pollard and Sag 1987), replace the atomic categories of a context-free grammar with a &amp;quot;feature structure&amp;quot; that represents the syntactic and semantic properties of the phrase. These feature structures are specified indirectly in terms of constraints that they must satisfy Lexical entries constrain the feature structures that can be associated with terminal nodes of the syntactic tree, and phrase structure rules simultaneously constrain the feature structures that can be associated with a parent node and its immediate descendants. Tha</context>
</contexts>
<marker>Haddock, Klein, Morrill, 1987</marker>
<rawString>Haddock, N. J.; Klein, E.; and Morrill, G. (1987). Categorial Grammar, Unification Computational Linguistics Volume 17, Number 2 Grammar. University of Edinburgh Edinburgh Working Papers in Cognitive Science 1.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Johnson</author>
</authors>
<title>Logic and Feature Structures,&amp;quot;</title>
<date>1991</date>
<booktitle>in Proceedings of IJCAI 1991,</booktitle>
<location>Sydney.</location>
<contexts>
<context position="18537" citStr="Johnson (1991)" startWordPosition="3018" endWordPosition="3019">that the satisfiability problem for such formulae, and hence the feature constraints that they express, is always decidable. Of course, some linguistic analyses make use of feature structure constraint systems that can encode undecidable problems. For example, subsumption constraints, which are useful in the description of agreement phenomena in coordination constructions (Shieber 1989) can be used to encode undecidable problems, as Dorre and Rounds (1989) have shown. Clearly such constraints cannot be expressed in a decidable class, but often they can be axiomatized in other standard logics. Johnson (1991) shows how (positively occurring) subsumption constraints can be axiomatized in first-order logic, and sketches treatments of sort constraints and nonmonotonic devices such as ANY values (Kay 1985) and &apos;constraint equations&apos; (Kaplan and Bresnan 1982) can be formalized in second-order logic using circumscription. 2.1 Axiomatizing Feature Structures with Function-Free Formulae This section shows how the important properties of feature structures can be axiomatized using formulae from the Schtinfinkel-Bernays class, which is the class of first-order formulae of the form . xnVyi • • • yn(10 where </context>
</contexts>
<marker>Johnson, 1991</marker>
<rawString>Johnson, M. (1991). &amp;quot;Logic and Feature Structures,&amp;quot; in Proceedings of IJCAI 1991, Sydney.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Johnson</author>
</authors>
<title>Expressing Disjunctive and Negative Feature Constraints with Classical First-order Logic,&amp;quot;</title>
<date>1990</date>
<booktitle>in The Proceedings of the 28th Annual Meeting of the Association for Computational Linguistics,</booktitle>
<location>Pittsburgh, PA.</location>
<contexts>
<context position="16701" citStr="Johnson (1990" startWordPosition="2745" endWordPosition="2746">f parsing algorithms. One difficulty with this approach is that the constraint language is &amp;quot;custom built,&amp;quot; so important properties, such as compactness and decidability, must be investigated from scratch. Moreover, it is often unclear if the treatment can be extended to handle other types of feature structures as well. Rounds (1988) proposes a model for set-valued features, but he does not provide a language for expressing constraints on such set-valued entities, or investigate the computational complexity of systems of such constraints. This paper follows an alternative strategy suggested in Johnson (1990a): axiomatize the relevant properties of feature structures in some well-understood language (here first-order logic) and translate constraints on these structures into the same language. 4 It is possible to avoid these problems by augmenting feature structures with &amp;quot;inequality arcs,&amp;quot; as was first proposed (to my knowledge) by Karttunen (1984) and discussed in Johnson (1990a), Johnson (in press) and pages 67-72 of Johnson (1988). However, it is hard to justify the existence of such arcs if feature structures are supposed to be linguistic objects (rather than data structures that represent for</context>
<context position="24043" citStr="Johnson (1990)" startWordPosition="3856" endWordPosition="3857">to check that all of the axioms hold in this interpretation. Instead of providing entities in the interpretation that serve as the denotation for &amp;quot;disjunctive&amp;quot; or &amp;quot;negative&amp;quot; features, we follow Kasper and Rounds (1986, 1990), Moshier and Rounds (1987), and Johnson (1988, 1990) in permitting disjunction and negation only in the constraint language. Since the classical semantics of disjunction and negation for first-order languages is consistent and monotonic, a consistent, monotonic semantics for negative and disjunctive feature constraints follows directly. (An example is presented below; see Johnson (1990) and especially Section 2.10 of Johnson (1988) for further discussion). We turn now to the set-valued features. The most straightforward way of introducing set-valued features would be to combine some standard axiomatization of set theory with the axiomatization of attribute-value structures just presented. Unfortunately, 6 This axiomatization is finite iff the sets of attribute symbols and constant symbols are finite. In the intended computational and linguistic applications this is always the case. 139 Computational Linguistics Volume 17, Number 2 all of the formulations of set-theory I am a</context>
<context position="42923" citStr="Johnson 1990" startWordPosition="6988" endWordPosition="6989">gr(e&apos;, f&apos;)A pers(f&apos;,3rd)A pred(g&amp;quot; , swim)A tense(g&amp;quot; , pres)A subj(g&amp;quot;, e&apos;)A num (f&apos; , sg). No further simplifications are possible, and 15d is satisfiable. In fact 15d describes the structure depicted in Figure 3, as expected. The standard unification algorithm is unable to handle negative constraints correctly, as noted above. However, because negation is interpreted declaratively (in fact, classically) in the first-order language used to express constraints here, its treatment is straightforward and unproblematic, and suggests ways of extending the unification algorithm to cover these cases (Johnson 1990b, to appear). 145 Computational Linguistics Volume 17, Number 2 pred = subj = e&apos; tense = swim pred = salmon agr = num = sg f pers = 3rd f pres Figure 10 A graphical depiction of the formula 16b Example 4 (continued) The unification of e&apos; and e (i.e. the lexical entries for salmon and swim) of Figure 9 corresponds to the conjunction of the formula e = e&apos; to the conjunction of 8a and 10, which is the formula 16a. 16a. e = e&apos; A pred(e&apos;,salmon)A agr(e1,1)A pers(f&apos;,3rd)A pred(g,swim)A tense(g,pres)A subj(g,e)A agr(e,f)A (num(f,sg)A pers(f,3rd)) This can be simplified by straightforward application</context>
</contexts>
<marker>Johnson, 1990</marker>
<rawString>Johnson, M. (1990a). &amp;quot;Expressing Disjunctive and Negative Feature Constraints with Classical First-order Logic,&amp;quot; in The Proceedings of the 28th Annual Meeting of the Association for Computational Linguistics, Pittsburgh, PA.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Johnson</author>
</authors>
<title>Features, Frames and Quantifier-Free Formulae,&amp;quot;</title>
<date>1990</date>
<booktitle>Logic and Logic Grammars for Language Processing,</booktitle>
<editor>in P. Saint-Dizier and S. Szpakowicz, eds.,</editor>
<publisher>Ellis Horwood,</publisher>
<location>New York.</location>
<contexts>
<context position="16701" citStr="Johnson (1990" startWordPosition="2745" endWordPosition="2746">f parsing algorithms. One difficulty with this approach is that the constraint language is &amp;quot;custom built,&amp;quot; so important properties, such as compactness and decidability, must be investigated from scratch. Moreover, it is often unclear if the treatment can be extended to handle other types of feature structures as well. Rounds (1988) proposes a model for set-valued features, but he does not provide a language for expressing constraints on such set-valued entities, or investigate the computational complexity of systems of such constraints. This paper follows an alternative strategy suggested in Johnson (1990a): axiomatize the relevant properties of feature structures in some well-understood language (here first-order logic) and translate constraints on these structures into the same language. 4 It is possible to avoid these problems by augmenting feature structures with &amp;quot;inequality arcs,&amp;quot; as was first proposed (to my knowledge) by Karttunen (1984) and discussed in Johnson (1990a), Johnson (in press) and pages 67-72 of Johnson (1988). However, it is hard to justify the existence of such arcs if feature structures are supposed to be linguistic objects (rather than data structures that represent for</context>
<context position="24043" citStr="Johnson (1990)" startWordPosition="3856" endWordPosition="3857">to check that all of the axioms hold in this interpretation. Instead of providing entities in the interpretation that serve as the denotation for &amp;quot;disjunctive&amp;quot; or &amp;quot;negative&amp;quot; features, we follow Kasper and Rounds (1986, 1990), Moshier and Rounds (1987), and Johnson (1988, 1990) in permitting disjunction and negation only in the constraint language. Since the classical semantics of disjunction and negation for first-order languages is consistent and monotonic, a consistent, monotonic semantics for negative and disjunctive feature constraints follows directly. (An example is presented below; see Johnson (1990) and especially Section 2.10 of Johnson (1988) for further discussion). We turn now to the set-valued features. The most straightforward way of introducing set-valued features would be to combine some standard axiomatization of set theory with the axiomatization of attribute-value structures just presented. Unfortunately, 6 This axiomatization is finite iff the sets of attribute symbols and constant symbols are finite. In the intended computational and linguistic applications this is always the case. 139 Computational Linguistics Volume 17, Number 2 all of the formulations of set-theory I am a</context>
<context position="42923" citStr="Johnson 1990" startWordPosition="6988" endWordPosition="6989">gr(e&apos;, f&apos;)A pers(f&apos;,3rd)A pred(g&amp;quot; , swim)A tense(g&amp;quot; , pres)A subj(g&amp;quot;, e&apos;)A num (f&apos; , sg). No further simplifications are possible, and 15d is satisfiable. In fact 15d describes the structure depicted in Figure 3, as expected. The standard unification algorithm is unable to handle negative constraints correctly, as noted above. However, because negation is interpreted declaratively (in fact, classically) in the first-order language used to express constraints here, its treatment is straightforward and unproblematic, and suggests ways of extending the unification algorithm to cover these cases (Johnson 1990b, to appear). 145 Computational Linguistics Volume 17, Number 2 pred = subj = e&apos; tense = swim pred = salmon agr = num = sg f pers = 3rd f pres Figure 10 A graphical depiction of the formula 16b Example 4 (continued) The unification of e&apos; and e (i.e. the lexical entries for salmon and swim) of Figure 9 corresponds to the conjunction of the formula e = e&apos; to the conjunction of 8a and 10, which is the formula 16a. 16a. e = e&apos; A pred(e&apos;,salmon)A agr(e1,1)A pers(f&apos;,3rd)A pred(g,swim)A tense(g,pres)A subj(g,e)A agr(e,f)A (num(f,sg)A pers(f,3rd)) This can be simplified by straightforward application</context>
</contexts>
<marker>Johnson, 1990</marker>
<rawString>Johnson, M. (1990b). &amp;quot;Features, Frames and Quantifier-Free Formulae,&amp;quot; in P. Saint-Dizier and S. Szpakowicz, eds., Logic and Logic Grammars for Language Processing, Ellis Horwood, New York.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Johnson</author>
</authors>
<title>Attribute-Value Logic and the Theory of Grammar.</title>
<date>1988</date>
<booktitle>CSLI Lecture Notes Series, University of</booktitle>
<publisher>Chicago Press,</publisher>
<location>Chicago.</location>
<contexts>
<context position="13968" citStr="Johnson (1988" startWordPosition="2346" endWordPosition="2347">rther unification of e&apos; with e succeeds, since v&apos; does satisfy f. Thus under this interpretation agr = [pers = 3rd &apos; 136 Johnson Features and Formulae of negation and unification, the success or failure of a sequence of unifications depends on the order in which they are performed.4 2. Feature Structures and Function-free Formulae These problems have generated a considerable body of work on the mathematical properties of feature structures and the constraints and operations that apply to them. Following Kaplan and Bresnan (1982), Pereira and Shieber (1984), Kasper and Rounds (1986, 1990), and Johnson (1988, 1990a) the constraints that determine the feature structures are regarded as formulae from a language for describing feature structures, rather than as feature structures themselves. Disjunction and negation appear only in expressions from the description language, rather than as components of the feature structures that these expressions describe. Thus the lexical entries in the examples above will be interpreted as formulae that constrain the feature structures that can be associated with these lexical items in a syntactic tree, rather than the feature structures themselves. For example, t</context>
<context position="15278" citStr="Johnson 1988" startWordPosition="2538" endWordPosition="2539">of formulae expressing constraints on linguistic objects, rather than the linguistic objects that satisfy these constraints. This avoids any need to refer to &amp;quot;negative&amp;quot; or &amp;quot;disjunctive&amp;quot; objects as entities appearing in a feature structure. As explained below, the familiar attribute-value &amp;quot;unification algorithm&amp;quot; can be interpreted as computing the atomic consequences of a purely conjunctive formula (where the graphs it operates on are data structures efficiently representing such formulae), and unification failure corresponds to the unsatisfiability of that conjunction (Kasper and Rounds 1990; Johnson 1988, 1990a; Pereira 1987). The most widely known model of feature structures and constraint language is the one developed to explain disjunctive feature values by Kasper and Rounds (1986, 1990) and Kasper (1986, 1987). The Kasper—Rounds treatment resolves the difficulties in interpreting disjunctive values by developing a specialized language for expressing these constraints. Various proposals to extend the Kasper—Rounds approach to deal with negative feature values are described by Moshier and Rounds (1987), Moshier (1988), Kasper (1988), Dawar and Vijayashanker (1989, 1990), Langholm (1989); ot</context>
<context position="17134" citStr="Johnson (1988)" startWordPosition="2808" endWordPosition="2809">raints on such set-valued entities, or investigate the computational complexity of systems of such constraints. This paper follows an alternative strategy suggested in Johnson (1990a): axiomatize the relevant properties of feature structures in some well-understood language (here first-order logic) and translate constraints on these structures into the same language. 4 It is possible to avoid these problems by augmenting feature structures with &amp;quot;inequality arcs,&amp;quot; as was first proposed (to my knowledge) by Karttunen (1984) and discussed in Johnson (1990a), Johnson (in press) and pages 67-72 of Johnson (1988). However, it is hard to justify the existence of such arcs if feature structures are supposed to be linguistic objects (rather than data structures that represent formulae manipulated during the parsing process). 137 Computational Linguistics Volume 17, Number 2 Thus the satisfiability problem for a set of constraints on feature structures is reduced to the satisfiability problem for the axioms conjoined with the translation of these constraints in the target language. Importantly, techniques used to determine satisfiability in the target language can be used to determine the satisfiability o</context>
<context position="20809" citStr="Johnson 1988" startWordPosition="3355" endWordPosition="3356">tially the same way as Smolka (1988, 1989) does. The axiomatization begins by describing the properties of the constant elements of attribute-value structures. The attribute-value constants are the denotation of certain constant symbols of the language of first-order logic, but not all constants (of the firstorder language) will denote attribute-value constants since it is convenient to have constants that denote other entities as well. The following axiom schemata express the requirement that attribute-value constants have no attributes and that all attribute5 This differs from earlier work (Johnson 1988) in which values and attributes were both conceptualized as individuals. In fact, research in progress indicates that it is advantageous to conceptualize of attributes as individuals and attribute relations in terms of a 3-place relation arc, where arc(x, a, y) is true iff the value of x&apos;s attribute a is y. This permits the quantification over attributes needed to define both simple and parameterized sorts to be expressed. 138 Johnson Features and Formulae value constants are distinct; i.e., that distinct attribute-value constants denote different entities. 1. For all attribute-value constants</context>
<context position="23699" citStr="Johnson (1988" startWordPosition="3808" endWordPosition="3809">. Example 7 The interpretation corresponding to the attribute-value structure depicted in Figure 1 has as its domain the set D = {seem, like, john, sg, 3rd, mary, pres, none} u {eo, ,e5}. The attributes denote relations on D x D. For example, pred denotes the relation {(e0 , seem), (e1, like), (e2, john), (e3, mary)} . It is straightforward to check that all of the axioms hold in this interpretation. Instead of providing entities in the interpretation that serve as the denotation for &amp;quot;disjunctive&amp;quot; or &amp;quot;negative&amp;quot; features, we follow Kasper and Rounds (1986, 1990), Moshier and Rounds (1987), and Johnson (1988, 1990) in permitting disjunction and negation only in the constraint language. Since the classical semantics of disjunction and negation for first-order languages is consistent and monotonic, a consistent, monotonic semantics for negative and disjunctive feature constraints follows directly. (An example is presented below; see Johnson (1990) and especially Section 2.10 of Johnson (1988) for further discussion). We turn now to the set-valued features. The most straightforward way of introducing set-valued features would be to combine some standard axiomatization of set theory with the axiomati</context>
<context position="33146" citStr="Johnson (1988)" startWordPosition="5385" endWordPosition="5386">ion of A in .A4&apos; is a subset of the denotation of A in M. • 2.2 Expressing Constraints A feature structure is specified implicitly by means of the constraints that it must satisfy. This section shows how such constraints can be translated into quantifies-free and function-free prenex formulae. There is a plethora of different notations for expressing these constraints: the constraint requiring that the value of attribute a of (the entity denoted by) x is (the entity denoted by) y is written as (x a) = y in PATR-II (Shieber 1986), as (x a) = y in LFG (Kaplan and Bresnan 1982), and as x(a) y in Johnson (1988), for example. Here we express attribute-value constraints using the attribute relations a, so this constraint would be expressed as a(x , y). Set-valued constraints are expressed using the relations in, null, union, and singleton defined in the previous section. The propositional connectives are used to express negative and disjunctive feature constraints. This section shows how constraints on feature bundles can be specified using equality, the attribute relations, and the set predicates axiomatized in the last section. (In fact as far as the theoretical results of this paper are concerned a</context>
<context position="38622" citStr="Johnson (1988)" startWordPosition="6283" endWordPosition="6284">ts. Since (universal) quantifiers appear only in the axiomatization of feature structures and not in the feature constraints themselves, the number of quantifiers appearing in the conjunction of the feature constraints and the axiomatization is a constant, and does not vary with the size of the system of feature constraints. By Proposition 3.2 of Lewis (1980), the satisfiability problem for a formula F with u universal quantifiers in the SchonfinkelBernays class requires nondeterministic time polynomial in IF u, so the problem is in NP. The reductions presented in Kasper and Rounds (1986) and Johnson (1988) can be used to show that the problem is NP-hard, so the satisfiability problem for feature constraints with set-values (as defined above) is NP-complete. 2.3 Unification and Satisfaction This section discusses the relationship between unification and the axiomatization presented above. Unification identifies or merges exactly the elements that the axiomatization implies are equal. The unification of two complex elements e and e&apos; causes the unification of the values of all attributes a that are defined on both e and e&apos;. Similarly, the conjunction of the formulae e = e&apos;, a(e. f), a(e&apos; , I) and </context>
</contexts>
<marker>Johnson, 1988</marker>
<rawString>Johnson, M. (1988). Attribute-Value Logic and the Theory of Grammar. CSLI Lecture Notes Series, University of Chicago Press, Chicago.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Johnson</author>
</authors>
<title>(in press). &amp;quot;Attribute-Value Logic and Natural Language Processing,&amp;quot;</title>
<date>1988</date>
<booktitle>Studies in Unification Grammar, The</booktitle>
<editor>in J. Wedekind, ed.,</editor>
<publisher>MIT Press,</publisher>
<location>Cambridge, Mass.</location>
<contexts>
<context position="13968" citStr="Johnson (1988" startWordPosition="2346" endWordPosition="2347">rther unification of e&apos; with e succeeds, since v&apos; does satisfy f. Thus under this interpretation agr = [pers = 3rd &apos; 136 Johnson Features and Formulae of negation and unification, the success or failure of a sequence of unifications depends on the order in which they are performed.4 2. Feature Structures and Function-free Formulae These problems have generated a considerable body of work on the mathematical properties of feature structures and the constraints and operations that apply to them. Following Kaplan and Bresnan (1982), Pereira and Shieber (1984), Kasper and Rounds (1986, 1990), and Johnson (1988, 1990a) the constraints that determine the feature structures are regarded as formulae from a language for describing feature structures, rather than as feature structures themselves. Disjunction and negation appear only in expressions from the description language, rather than as components of the feature structures that these expressions describe. Thus the lexical entries in the examples above will be interpreted as formulae that constrain the feature structures that can be associated with these lexical items in a syntactic tree, rather than the feature structures themselves. For example, t</context>
<context position="15278" citStr="Johnson 1988" startWordPosition="2538" endWordPosition="2539">of formulae expressing constraints on linguistic objects, rather than the linguistic objects that satisfy these constraints. This avoids any need to refer to &amp;quot;negative&amp;quot; or &amp;quot;disjunctive&amp;quot; objects as entities appearing in a feature structure. As explained below, the familiar attribute-value &amp;quot;unification algorithm&amp;quot; can be interpreted as computing the atomic consequences of a purely conjunctive formula (where the graphs it operates on are data structures efficiently representing such formulae), and unification failure corresponds to the unsatisfiability of that conjunction (Kasper and Rounds 1990; Johnson 1988, 1990a; Pereira 1987). The most widely known model of feature structures and constraint language is the one developed to explain disjunctive feature values by Kasper and Rounds (1986, 1990) and Kasper (1986, 1987). The Kasper—Rounds treatment resolves the difficulties in interpreting disjunctive values by developing a specialized language for expressing these constraints. Various proposals to extend the Kasper—Rounds approach to deal with negative feature values are described by Moshier and Rounds (1987), Moshier (1988), Kasper (1988), Dawar and Vijayashanker (1989, 1990), Langholm (1989); ot</context>
<context position="17134" citStr="Johnson (1988)" startWordPosition="2808" endWordPosition="2809">raints on such set-valued entities, or investigate the computational complexity of systems of such constraints. This paper follows an alternative strategy suggested in Johnson (1990a): axiomatize the relevant properties of feature structures in some well-understood language (here first-order logic) and translate constraints on these structures into the same language. 4 It is possible to avoid these problems by augmenting feature structures with &amp;quot;inequality arcs,&amp;quot; as was first proposed (to my knowledge) by Karttunen (1984) and discussed in Johnson (1990a), Johnson (in press) and pages 67-72 of Johnson (1988). However, it is hard to justify the existence of such arcs if feature structures are supposed to be linguistic objects (rather than data structures that represent formulae manipulated during the parsing process). 137 Computational Linguistics Volume 17, Number 2 Thus the satisfiability problem for a set of constraints on feature structures is reduced to the satisfiability problem for the axioms conjoined with the translation of these constraints in the target language. Importantly, techniques used to determine satisfiability in the target language can be used to determine the satisfiability o</context>
<context position="20809" citStr="Johnson 1988" startWordPosition="3355" endWordPosition="3356">tially the same way as Smolka (1988, 1989) does. The axiomatization begins by describing the properties of the constant elements of attribute-value structures. The attribute-value constants are the denotation of certain constant symbols of the language of first-order logic, but not all constants (of the firstorder language) will denote attribute-value constants since it is convenient to have constants that denote other entities as well. The following axiom schemata express the requirement that attribute-value constants have no attributes and that all attribute5 This differs from earlier work (Johnson 1988) in which values and attributes were both conceptualized as individuals. In fact, research in progress indicates that it is advantageous to conceptualize of attributes as individuals and attribute relations in terms of a 3-place relation arc, where arc(x, a, y) is true iff the value of x&apos;s attribute a is y. This permits the quantification over attributes needed to define both simple and parameterized sorts to be expressed. 138 Johnson Features and Formulae value constants are distinct; i.e., that distinct attribute-value constants denote different entities. 1. For all attribute-value constants</context>
<context position="23699" citStr="Johnson (1988" startWordPosition="3808" endWordPosition="3809">. Example 7 The interpretation corresponding to the attribute-value structure depicted in Figure 1 has as its domain the set D = {seem, like, john, sg, 3rd, mary, pres, none} u {eo, ,e5}. The attributes denote relations on D x D. For example, pred denotes the relation {(e0 , seem), (e1, like), (e2, john), (e3, mary)} . It is straightforward to check that all of the axioms hold in this interpretation. Instead of providing entities in the interpretation that serve as the denotation for &amp;quot;disjunctive&amp;quot; or &amp;quot;negative&amp;quot; features, we follow Kasper and Rounds (1986, 1990), Moshier and Rounds (1987), and Johnson (1988, 1990) in permitting disjunction and negation only in the constraint language. Since the classical semantics of disjunction and negation for first-order languages is consistent and monotonic, a consistent, monotonic semantics for negative and disjunctive feature constraints follows directly. (An example is presented below; see Johnson (1990) and especially Section 2.10 of Johnson (1988) for further discussion). We turn now to the set-valued features. The most straightforward way of introducing set-valued features would be to combine some standard axiomatization of set theory with the axiomati</context>
<context position="33146" citStr="Johnson (1988)" startWordPosition="5385" endWordPosition="5386">ion of A in .A4&apos; is a subset of the denotation of A in M. • 2.2 Expressing Constraints A feature structure is specified implicitly by means of the constraints that it must satisfy. This section shows how such constraints can be translated into quantifies-free and function-free prenex formulae. There is a plethora of different notations for expressing these constraints: the constraint requiring that the value of attribute a of (the entity denoted by) x is (the entity denoted by) y is written as (x a) = y in PATR-II (Shieber 1986), as (x a) = y in LFG (Kaplan and Bresnan 1982), and as x(a) y in Johnson (1988), for example. Here we express attribute-value constraints using the attribute relations a, so this constraint would be expressed as a(x , y). Set-valued constraints are expressed using the relations in, null, union, and singleton defined in the previous section. The propositional connectives are used to express negative and disjunctive feature constraints. This section shows how constraints on feature bundles can be specified using equality, the attribute relations, and the set predicates axiomatized in the last section. (In fact as far as the theoretical results of this paper are concerned a</context>
<context position="38622" citStr="Johnson (1988)" startWordPosition="6283" endWordPosition="6284">ts. Since (universal) quantifiers appear only in the axiomatization of feature structures and not in the feature constraints themselves, the number of quantifiers appearing in the conjunction of the feature constraints and the axiomatization is a constant, and does not vary with the size of the system of feature constraints. By Proposition 3.2 of Lewis (1980), the satisfiability problem for a formula F with u universal quantifiers in the SchonfinkelBernays class requires nondeterministic time polynomial in IF u, so the problem is in NP. The reductions presented in Kasper and Rounds (1986) and Johnson (1988) can be used to show that the problem is NP-hard, so the satisfiability problem for feature constraints with set-values (as defined above) is NP-complete. 2.3 Unification and Satisfaction This section discusses the relationship between unification and the axiomatization presented above. Unification identifies or merges exactly the elements that the axiomatization implies are equal. The unification of two complex elements e and e&apos; causes the unification of the values of all attributes a that are defined on both e and e&apos;. Similarly, the conjunction of the formulae e = e&apos;, a(e. f), a(e&apos; , I) and </context>
</contexts>
<marker>Johnson, 1988</marker>
<rawString>Johnson, M. (in press). &amp;quot;Attribute-Value Logic and Natural Language Processing,&amp;quot; in J. Wedekind, ed., Studies in Unification Grammar, The MIT Press, Cambridge, Mass. (originally presented at the Titisee Conference, Germany, 1988).</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Johnson</author>
<author>M Kay</author>
</authors>
<title>Semantic Operators and Anaphora,&amp;quot;</title>
<date>1990</date>
<booktitle>in The Proceedings of COLING</booktitle>
<location>Helsinki, Finland.</location>
<contexts>
<context position="8567" citStr="Johnson and Kay (1990)" startWordPosition="1399" endWordPosition="1402">ry for die is required.2 Example 4 In the basic unification framework described above the tensed verb swim would require multiple lexical entries, since it agrees with first person, second person, and plural third person subjects; i.e., a subject with any agreement features other than third person singular. In a framework with &amp;quot;negative values&amp;quot; it requires only the single lexical entry in Figure 5, where &amp;quot;&amp;quot; identifies a &amp;quot;negative value.&amp;quot; As mentioned earlier, other kinds of feature structures besides attribute-value structures have been proposed in the literature. Johnson and Klein (1986) and Johnson and Kay (1990) show how &amp;quot;set-valued&amp;quot; features can be used to express Discourse Representation Theory (Kamp 1981) in a complex-feature based grammar formalism. The highly simplified example below is meant solely to show one way in which set-valued features can be used—no claims are made for its linguistic correctness. 2 &amp;quot;Disjunctive&amp;quot; features are depicted using angle brackets, since curly brackets are used in this paper to depict &amp;quot;set-valued&amp;quot; features. Below we reinterpret the &amp;quot;disjunctive&amp;quot; and &amp;quot;negative&amp;quot; features depicted in this example and the next as disjunctions and negations of constraints. 134 Johnson</context>
</contexts>
<marker>Johnson, Kay, 1990</marker>
<rawString>Johnson, M. and Kay, M. (1990). &amp;quot;Semantic Operators and Anaphora,&amp;quot; in The Proceedings of COLING 1990, Helsinki, Finland.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Johnson</author>
<author>E Klein</author>
</authors>
<title>Discourse, Parsing and Anaphora,&amp;quot;</title>
<date>1986</date>
<booktitle>in The Proceedings of COLING 1986,</booktitle>
<location>Bonn, West</location>
<contexts>
<context position="8540" citStr="Johnson and Klein (1986)" startWordPosition="1394" endWordPosition="1397">e values only one lexical entry for die is required.2 Example 4 In the basic unification framework described above the tensed verb swim would require multiple lexical entries, since it agrees with first person, second person, and plural third person subjects; i.e., a subject with any agreement features other than third person singular. In a framework with &amp;quot;negative values&amp;quot; it requires only the single lexical entry in Figure 5, where &amp;quot;&amp;quot; identifies a &amp;quot;negative value.&amp;quot; As mentioned earlier, other kinds of feature structures besides attribute-value structures have been proposed in the literature. Johnson and Klein (1986) and Johnson and Kay (1990) show how &amp;quot;set-valued&amp;quot; features can be used to express Discourse Representation Theory (Kamp 1981) in a complex-feature based grammar formalism. The highly simplified example below is meant solely to show one way in which set-valued features can be used—no claims are made for its linguistic correctness. 2 &amp;quot;Disjunctive&amp;quot; features are depicted using angle brackets, since curly brackets are used in this paper to depict &amp;quot;set-valued&amp;quot; features. Below we reinterpret the &amp;quot;disjunctive&amp;quot; and &amp;quot;negative&amp;quot; features depicted in this example and the next as disjunctions and negations </context>
</contexts>
<marker>Johnson, Klein, 1986</marker>
<rawString>Johnson, M. and Klein, E. (1986). &amp;quot;Discourse, Parsing and Anaphora,&amp;quot; in The Proceedings of COLING 1986, Bonn, West Germany.</rawString>
</citation>
<citation valid="true">
<authors>
<author>H Kamp</author>
</authors>
<title>A Theory of Truth and Semantic Representation,&amp;quot;</title>
<date>1981</date>
<booktitle>Formal Methods in the Study of Language, Mathematical Centre Tracts,</booktitle>
<editor>in J. A. G. Groenendijk, T. M. V. Janssem and M. B. J. Stokhof, eds.,</editor>
<location>Amsterdam.</location>
<contexts>
<context position="8665" citStr="Kamp 1981" startWordPosition="1416" endWordPosition="1417">ld require multiple lexical entries, since it agrees with first person, second person, and plural third person subjects; i.e., a subject with any agreement features other than third person singular. In a framework with &amp;quot;negative values&amp;quot; it requires only the single lexical entry in Figure 5, where &amp;quot;&amp;quot; identifies a &amp;quot;negative value.&amp;quot; As mentioned earlier, other kinds of feature structures besides attribute-value structures have been proposed in the literature. Johnson and Klein (1986) and Johnson and Kay (1990) show how &amp;quot;set-valued&amp;quot; features can be used to express Discourse Representation Theory (Kamp 1981) in a complex-feature based grammar formalism. The highly simplified example below is meant solely to show one way in which set-valued features can be used—no claims are made for its linguistic correctness. 2 &amp;quot;Disjunctive&amp;quot; features are depicted using angle brackets, since curly brackets are used in this paper to depict &amp;quot;set-valued&amp;quot; features. Below we reinterpret the &amp;quot;disjunctive&amp;quot; and &amp;quot;negative&amp;quot; features depicted in this example and the next as disjunctions and negations of constraints. 134 Johnson Features and Formulae she ). cat = NP ,-- index e s 1 cat = N refs-in = s ! index = i&apos; refs-out =</context>
</contexts>
<marker>Kamp, 1981</marker>
<rawString>Kamp, H. (1981). &amp;quot;A Theory of Truth and Semantic Representation,&amp;quot; in J. A. G. Groenendijk, T. M. V. Janssem and M. B. J. Stokhof, eds., Formal Methods in the Study of Language, Mathematical Centre Tracts, Amsterdam.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Kaplan</author>
<author>J Bresnan</author>
</authors>
<title>Lexical-functional grammar, a formal system for grammatical representation,&amp;quot;</title>
<date>1982</date>
<booktitle>The Mental Representation of Grammatical Relations, The</booktitle>
<editor>in J. Bresnan, ed.,</editor>
<publisher>MIT Press,</publisher>
<location>Cambridge, Mass.</location>
<contexts>
<context position="13889" citStr="Kaplan and Bresnan (1982)" startWordPosition="2332" endWordPosition="2335">ince v does not satisfy f. If e&apos; is first unified with u&apos; then f&apos; is unified with v&apos; and further unification of e&apos; with e succeeds, since v&apos; does satisfy f. Thus under this interpretation agr = [pers = 3rd &apos; 136 Johnson Features and Formulae of negation and unification, the success or failure of a sequence of unifications depends on the order in which they are performed.4 2. Feature Structures and Function-free Formulae These problems have generated a considerable body of work on the mathematical properties of feature structures and the constraints and operations that apply to them. Following Kaplan and Bresnan (1982), Pereira and Shieber (1984), Kasper and Rounds (1986, 1990), and Johnson (1988, 1990a) the constraints that determine the feature structures are regarded as formulae from a language for describing feature structures, rather than as feature structures themselves. Disjunction and negation appear only in expressions from the description language, rather than as components of the feature structures that these expressions describe. Thus the lexical entries in the examples above will be interpreted as formulae that constrain the feature structures that can be associated with these lexical items in </context>
<context position="18787" citStr="Kaplan and Bresnan 1982" startWordPosition="3050" endWordPosition="3053">oblems. For example, subsumption constraints, which are useful in the description of agreement phenomena in coordination constructions (Shieber 1989) can be used to encode undecidable problems, as Dorre and Rounds (1989) have shown. Clearly such constraints cannot be expressed in a decidable class, but often they can be axiomatized in other standard logics. Johnson (1991) shows how (positively occurring) subsumption constraints can be axiomatized in first-order logic, and sketches treatments of sort constraints and nonmonotonic devices such as ANY values (Kay 1985) and &apos;constraint equations&apos; (Kaplan and Bresnan 1982) can be formalized in second-order logic using circumscription. 2.1 Axiomatizing Feature Structures with Function-Free Formulae This section shows how the important properties of feature structures can be axiomatized using formulae from the Schtinfinkel-Bernays class, which is the class of first-order formulae of the form . xnVyi • • • yn(10 where co contains no function symbols or quantifiers. (Thus no existential quantifier can appear in the scope of a universal quantifier.) This class of formulae was chosen because it is both decidable (see e.g. Lewis and Papadimitriou 1981) and can express</context>
<context position="27803" citStr="Kaplan and Bresnan 1982" startWordPosition="4429" endWordPosition="4432"> it does not appear to be axiomatizable using SchonfinkelBernays&apos; formulae, but three other reasons motivate this decision. First, as noted in Shieber (1986) and in Example 1 above, feature structures in general are not extensional (e.g., two distinct attribute-value elements can have exactly the same attributes and values), and it seems reasonable to treat set-values in a nonextensional fashion as well. Second, extensionality could produce undesirable interactions with the attributevalue component of feature structures. Since set-valued features can also have attributes (for example, in LFG (Kaplan and Bresnan 1982)) a conjunction is associated with a set-value that also has attributes), extensionality would prohibit there being 7 In fact there are Schonfinkel-Bernays axioms that require the in relation to be acyclic. Define a new relation, say ink, by the axioms V s in(e, s) in+ (e, s) V es s&apos; in+ (e, s) A in+ (s, s&apos;) in+ (e, s&apos;). Then in any model in+ denotes a superset of the transitive closure of the in relation. The following axiom requires that this transitive closure is irreflexive, i.e. that no set is contained in itself. Vs (s, s). 140 Johnson Features and Formulae two set-valued features that c</context>
<context position="33113" citStr="Kaplan and Bresnan 1982" startWordPosition="5376" endWordPosition="5379"> have shown something stronger; the denotation of A in .A4&apos; is a subset of the denotation of A in M. • 2.2 Expressing Constraints A feature structure is specified implicitly by means of the constraints that it must satisfy. This section shows how such constraints can be translated into quantifies-free and function-free prenex formulae. There is a plethora of different notations for expressing these constraints: the constraint requiring that the value of attribute a of (the entity denoted by) x is (the entity denoted by) y is written as (x a) = y in PATR-II (Shieber 1986), as (x a) = y in LFG (Kaplan and Bresnan 1982), and as x(a) y in Johnson (1988), for example. Here we express attribute-value constraints using the attribute relations a, so this constraint would be expressed as a(x , y). Set-valued constraints are expressed using the relations in, null, union, and singleton defined in the previous section. The propositional connectives are used to express negative and disjunctive feature constraints. This section shows how constraints on feature bundles can be specified using equality, the attribute relations, and the set predicates axiomatized in the last section. (In fact as far as the theoretical resu</context>
</contexts>
<marker>Kaplan, Bresnan, 1982</marker>
<rawString>Kaplan, R. and Bresnan, J. (1982). &amp;quot;Lexical-functional grammar, a formal system for grammatical representation,&amp;quot; in J. Bresnan, ed., The Mental Representation of Grammatical Relations, The MIT Press, Cambridge, Mass.</rawString>
</citation>
<citation valid="true">
<authors>
<author>L Karttunen</author>
</authors>
<title>Features and Values,&amp;quot; in COLING-1984, The Association for Computational Linguistics,</title>
<date>1984</date>
<institution>Stanford University.</institution>
<contexts>
<context position="7417" citStr="Karttunen 1984" startWordPosition="1209" endWordPosition="1210">obvious from this simple example, a large number of syntactic constructions from a variety of natural languages can be described in such a unification-based framework (many of the analyses presented in Bresnan 1982 can be expressed in such a &amp;quot;pure&amp;quot; unification-based framework). Nevertheless, it is often convenient and sometimes necessary to extend the basic unification framework to include a wider variety of feature structures. For example, &amp;quot;negative values&amp;quot; and &amp;quot;disjunctive values&amp;quot; allow grammars and lexical entries to be written much more succinctly, as the following examples show (based on Karttunen 1984). 133 Computational Linguistics Volume 17, Number 2 cat = determiner number: singular agr = gender: feminine number: plural die case = /nom \ \ ace Figure 4 Disjunction in the lexical entry for die swim pred = swim num = sg subj = agr = pers = 3rd e pres tense = Figure 5 Negation in the lexical entry for swim Example 3 In German the determiner die must have accusative or nominative case, and agrees with either feminine singular nouns or plural nouns of any gender. In a framework with disjunctive values only one lexical entry for die is required.2 Example 4 In the basic unification framework de</context>
<context position="17047" citStr="Karttunen (1984)" startWordPosition="2794" endWordPosition="2795"> a model for set-valued features, but he does not provide a language for expressing constraints on such set-valued entities, or investigate the computational complexity of systems of such constraints. This paper follows an alternative strategy suggested in Johnson (1990a): axiomatize the relevant properties of feature structures in some well-understood language (here first-order logic) and translate constraints on these structures into the same language. 4 It is possible to avoid these problems by augmenting feature structures with &amp;quot;inequality arcs,&amp;quot; as was first proposed (to my knowledge) by Karttunen (1984) and discussed in Johnson (1990a), Johnson (in press) and pages 67-72 of Johnson (1988). However, it is hard to justify the existence of such arcs if feature structures are supposed to be linguistic objects (rather than data structures that represent formulae manipulated during the parsing process). 137 Computational Linguistics Volume 17, Number 2 Thus the satisfiability problem for a set of constraints on feature structures is reduced to the satisfiability problem for the axioms conjoined with the translation of these constraints in the target language. Importantly, techniques used to determ</context>
</contexts>
<marker>Karttunen, 1984</marker>
<rawString>Karttunen, L. (1984). &amp;quot;Features and Values,&amp;quot; in COLING-1984, The Association for Computational Linguistics, Stanford University.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R T Kasper</author>
</authors>
<title>Conditional Descriptions in Functional Unification Grammar,&amp;quot;</title>
<date>1988</date>
<booktitle>in Proceedings of the 26th Annual Meeting of the Association for Computational Linguistics,</booktitle>
<location>Buffalo, New York.</location>
<contexts>
<context position="15819" citStr="Kasper (1988)" startWordPosition="2614" endWordPosition="2615">satisfiability of that conjunction (Kasper and Rounds 1990; Johnson 1988, 1990a; Pereira 1987). The most widely known model of feature structures and constraint language is the one developed to explain disjunctive feature values by Kasper and Rounds (1986, 1990) and Kasper (1986, 1987). The Kasper—Rounds treatment resolves the difficulties in interpreting disjunctive values by developing a specialized language for expressing these constraints. Various proposals to extend the Kasper—Rounds approach to deal with negative feature values are described by Moshier and Rounds (1987), Moshier (1988), Kasper (1988), Dawar and Vijayashanker (1989, 1990), Langholm (1989); other extensions to this framework are discussed by Dorre and Rounds (1989), Smolka (1988, 1989), and Nebel and Smolka (1989); and Shieber (1989) discusses the integration of such feature systems into a variety of parsing algorithms. One difficulty with this approach is that the constraint language is &amp;quot;custom built,&amp;quot; so important properties, such as compactness and decidability, must be investigated from scratch. Moreover, it is often unclear if the treatment can be extended to handle other types of feature structures as well. Rounds (19</context>
</contexts>
<marker>Kasper, 1988</marker>
<rawString>Kasper, R. T. (1988). &amp;quot;Conditional Descriptions in Functional Unification Grammar,&amp;quot; in Proceedings of the 26th Annual Meeting of the Association for Computational Linguistics, Buffalo, New York.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R T Kasper</author>
</authors>
<title>A Unification Method for Disjunctive Feature Structures,&amp;quot;</title>
<date>1987</date>
<booktitle>in The Proceedings of the 25th Annual Meeting of the Association</booktitle>
<institution>for Computational Linguistics, Stanford University.</institution>
<marker>Kasper, 1987</marker>
<rawString>Kasper, R. T. (1987). &amp;quot;A Unification Method for Disjunctive Feature Structures,&amp;quot; in The Proceedings of the 25th Annual Meeting of the Association for Computational Linguistics, Stanford University.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R T Kasper</author>
</authors>
<title>Feature Structures: A Logical Theory with Application to Language Analysis,</title>
<date>1986</date>
<tech>Ph.D. Thesis,</tech>
<institution>University of Michigan.</institution>
<contexts>
<context position="15485" citStr="Kasper (1986" startWordPosition="2570" endWordPosition="2571">ppearing in a feature structure. As explained below, the familiar attribute-value &amp;quot;unification algorithm&amp;quot; can be interpreted as computing the atomic consequences of a purely conjunctive formula (where the graphs it operates on are data structures efficiently representing such formulae), and unification failure corresponds to the unsatisfiability of that conjunction (Kasper and Rounds 1990; Johnson 1988, 1990a; Pereira 1987). The most widely known model of feature structures and constraint language is the one developed to explain disjunctive feature values by Kasper and Rounds (1986, 1990) and Kasper (1986, 1987). The Kasper—Rounds treatment resolves the difficulties in interpreting disjunctive values by developing a specialized language for expressing these constraints. Various proposals to extend the Kasper—Rounds approach to deal with negative feature values are described by Moshier and Rounds (1987), Moshier (1988), Kasper (1988), Dawar and Vijayashanker (1989, 1990), Langholm (1989); other extensions to this framework are discussed by Dorre and Rounds (1989), Smolka (1988, 1989), and Nebel and Smolka (1989); and Shieber (1989) discusses the integration of such feature systems into a variet</context>
<context position="40481" citStr="Kasper (1986" startWordPosition="6584" endWordPosition="6585">ce —,a(c,y) by axiom schema (1). If attention is restricted to purely conjunctive attribute-value systems, the corresponding formulae can be represented as a directed graph, where nodes represent (first-order) constants, and an arc labeled a from x to y encodes the atom a(x,y). Then the standard attribute-value &apos;unification algorithm&apos; can be used as a specialized inference procedure that takes as input such a graph encoding of a conjunction of 144 Johnson Features and Formulae attribute-value relations and returns (the graph encoding of) the conjunction of all of their atomic consequences. As Kasper (1986, 1987) noted in a different setting, the steps of the attribute-value unification algorithm are just applications of the axioms 1-3. It &apos;forward chains&apos; using axiom schema (3) (for which the graph representation provides efficient indexing), and checks at each step that 1 and 2 are not falsified; if they are falsified the unification algorithm halts and reports a unification failure. Atomic equalities x =y are represented by a &apos;forwarding pointer&apos; from x to y (as in the UNION-FIND algorithm (Gallier 1986; Nelson and Oppen 1980; Johnson in press)). Example 2 (continued) The unification of e&apos; a</context>
</contexts>
<marker>Kasper, 1986</marker>
<rawString>Kasper, R. T. (1986). Feature Structures: A Logical Theory with Application to Language Analysis, Ph.D. Thesis, University of Michigan.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R T Kasper</author>
<author>W C Rounds</author>
</authors>
<title>The Logic of Unification in Grammar,&amp;quot; Linguistics and Philosophy.</title>
<date>1990</date>
<volume>13</volume>
<pages>35--58</pages>
<contexts>
<context position="15264" citStr="Kasper and Rounds 1990" startWordPosition="2534" endWordPosition="2537">as graphical depictions of formulae expressing constraints on linguistic objects, rather than the linguistic objects that satisfy these constraints. This avoids any need to refer to &amp;quot;negative&amp;quot; or &amp;quot;disjunctive&amp;quot; objects as entities appearing in a feature structure. As explained below, the familiar attribute-value &amp;quot;unification algorithm&amp;quot; can be interpreted as computing the atomic consequences of a purely conjunctive formula (where the graphs it operates on are data structures efficiently representing such formulae), and unification failure corresponds to the unsatisfiability of that conjunction (Kasper and Rounds 1990; Johnson 1988, 1990a; Pereira 1987). The most widely known model of feature structures and constraint language is the one developed to explain disjunctive feature values by Kasper and Rounds (1986, 1990) and Kasper (1986, 1987). The Kasper—Rounds treatment resolves the difficulties in interpreting disjunctive values by developing a specialized language for expressing these constraints. Various proposals to extend the Kasper—Rounds approach to deal with negative feature values are described by Moshier and Rounds (1987), Moshier (1988), Kasper (1988), Dawar and Vijayashanker (1989, 1990), Langh</context>
<context position="22196" citStr="Kasper and Rounds (1990)" startWordPosition="3568" endWordPosition="3571">r all attributes a, V xyz a(x y) A a(x , z) y = z. This completes the axiomatization of attribute-value feature structures.&apos; The claim is that any interpretation that satisfies these axioms is an attribute-value structure, i.e. 1-3 constitute a definition of attribute-value structures. Such interpretations can be viewed as (possibly infinite and disconnected) directed graphs, where the individuals constitute the graph&apos;s nodes and the attribute relations the arcs between those nodes. Thus these axioms admit a much wider class of models than do most other treatments of feature structures (e.g., Kasper and Rounds (1990) require feature structures to be a certain type of finite automata). In fact it is easy to add axioms requiring attribute-value structures to have additional properties such as acyclicity. But since the axioms that define attribute-value structures are in effect assumptions that stipulate the nature of linguistic entities, we obtain a more general theory the weaker these axioms are. Thus 1-3 are intended to stipulate only the properties of attribute-value structures that are required by linguistic analyses. Note that the partiality of attributes is of crucial importance: if attributes were re</context>
</contexts>
<marker>Kasper, Rounds, 1990</marker>
<rawString>Kasper, R. T. and Rounds, W. C. (1990). &amp;quot;The Logic of Unification in Grammar,&amp;quot; Linguistics and Philosophy. 13.1, 35-58.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R T Kasper</author>
<author>W C Rounds</author>
</authors>
<title>A Logical Semantics for Feature Structures,&amp;quot;</title>
<date>1986</date>
<booktitle>in The Proceedings of the 24th Annual Meeting of the Association for Computational Linguistics,</booktitle>
<location>Columbia University, New York.</location>
<contexts>
<context position="13942" citStr="Kasper and Rounds (1986" startWordPosition="2340" endWordPosition="2343">u&apos; then f&apos; is unified with v&apos; and further unification of e&apos; with e succeeds, since v&apos; does satisfy f. Thus under this interpretation agr = [pers = 3rd &apos; 136 Johnson Features and Formulae of negation and unification, the success or failure of a sequence of unifications depends on the order in which they are performed.4 2. Feature Structures and Function-free Formulae These problems have generated a considerable body of work on the mathematical properties of feature structures and the constraints and operations that apply to them. Following Kaplan and Bresnan (1982), Pereira and Shieber (1984), Kasper and Rounds (1986, 1990), and Johnson (1988, 1990a) the constraints that determine the feature structures are regarded as formulae from a language for describing feature structures, rather than as feature structures themselves. Disjunction and negation appear only in expressions from the description language, rather than as components of the feature structures that these expressions describe. Thus the lexical entries in the examples above will be interpreted as formulae that constrain the feature structures that can be associated with these lexical items in a syntactic tree, rather than the feature structures </context>
<context position="15461" citStr="Kasper and Rounds (1986" startWordPosition="2564" endWordPosition="2567">&amp;quot;disjunctive&amp;quot; objects as entities appearing in a feature structure. As explained below, the familiar attribute-value &amp;quot;unification algorithm&amp;quot; can be interpreted as computing the atomic consequences of a purely conjunctive formula (where the graphs it operates on are data structures efficiently representing such formulae), and unification failure corresponds to the unsatisfiability of that conjunction (Kasper and Rounds 1990; Johnson 1988, 1990a; Pereira 1987). The most widely known model of feature structures and constraint language is the one developed to explain disjunctive feature values by Kasper and Rounds (1986, 1990) and Kasper (1986, 1987). The Kasper—Rounds treatment resolves the difficulties in interpreting disjunctive values by developing a specialized language for expressing these constraints. Various proposals to extend the Kasper—Rounds approach to deal with negative feature values are described by Moshier and Rounds (1987), Moshier (1988), Kasper (1988), Dawar and Vijayashanker (1989, 1990), Langholm (1989); other extensions to this framework are discussed by Dorre and Rounds (1989), Smolka (1988, 1989), and Nebel and Smolka (1989); and Shieber (1989) discusses the integration of such featu</context>
<context position="23646" citStr="Kasper and Rounds (1986" startWordPosition="3798" endWordPosition="3801"> a(x, y), which do not belong to the Schonfinkel-Bernays class). Example 7 The interpretation corresponding to the attribute-value structure depicted in Figure 1 has as its domain the set D = {seem, like, john, sg, 3rd, mary, pres, none} u {eo, ,e5}. The attributes denote relations on D x D. For example, pred denotes the relation {(e0 , seem), (e1, like), (e2, john), (e3, mary)} . It is straightforward to check that all of the axioms hold in this interpretation. Instead of providing entities in the interpretation that serve as the denotation for &amp;quot;disjunctive&amp;quot; or &amp;quot;negative&amp;quot; features, we follow Kasper and Rounds (1986, 1990), Moshier and Rounds (1987), and Johnson (1988, 1990) in permitting disjunction and negation only in the constraint language. Since the classical semantics of disjunction and negation for first-order languages is consistent and monotonic, a consistent, monotonic semantics for negative and disjunctive feature constraints follows directly. (An example is presented below; see Johnson (1990) and especially Section 2.10 of Johnson (1988) for further discussion). We turn now to the set-valued features. The most straightforward way of introducing set-valued features would be to combine some st</context>
<context position="38603" citStr="Kasper and Rounds (1986)" startWordPosition="6278" endWordPosition="6281">ems of such feature constraints. Since (universal) quantifiers appear only in the axiomatization of feature structures and not in the feature constraints themselves, the number of quantifiers appearing in the conjunction of the feature constraints and the axiomatization is a constant, and does not vary with the size of the system of feature constraints. By Proposition 3.2 of Lewis (1980), the satisfiability problem for a formula F with u universal quantifiers in the SchonfinkelBernays class requires nondeterministic time polynomial in IF u, so the problem is in NP. The reductions presented in Kasper and Rounds (1986) and Johnson (1988) can be used to show that the problem is NP-hard, so the satisfiability problem for feature constraints with set-values (as defined above) is NP-complete. 2.3 Unification and Satisfaction This section discusses the relationship between unification and the axiomatization presented above. Unification identifies or merges exactly the elements that the axiomatization implies are equal. The unification of two complex elements e and e&apos; causes the unification of the values of all attributes a that are defined on both e and e&apos;. Similarly, the conjunction of the formulae e = e&apos;, a(e.</context>
</contexts>
<marker>Kasper, Rounds, 1986</marker>
<rawString>Kasper, R. T. and Rounds, W. C. (1986). &amp;quot;A Logical Semantics for Feature Structures,&amp;quot; in The Proceedings of the 24th Annual Meeting of the Association for Computational Linguistics, Columbia University, New York.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Kay</author>
</authors>
<title>Unification in Grammar,&amp;quot;</title>
<date>1985</date>
<booktitle>Natural Language Understanding and Logic Programming,</booktitle>
<editor>in V. Dahl and P. Saint-Dizier, eds.,</editor>
<location>North Holland, Amsterdam, The Netherlands.</location>
<contexts>
<context position="686" citStr="Kay 1985" startWordPosition="91" endWordPosition="92"> representational device used in several current linguistic theories. This paper shows how these structures can be axiomatized in a decidable class of first-order logic, which can also be used to express constraints on these structures. Desirable properties, such as compactness and decidability, follow directly. Moreover, additional types of feature values, such as &amp;quot;set-valued&amp;quot; features, can be incorporated into the system simply by axiomatizing their properties. 1. Introduction Many modern linguistic theories, such as Lexical-Functional Grammar (Bresnan 1982), Functional Unification Grammar (Kay 1985), Generalized Phrase Structure Grammar (Gazdar et al. 1985), Unification Categorial Grammar (Haddock et al. 1987), (Uszkoreit 1986), and Head-Driven Phrase Structure Grammar (Pollard and Sag 1987), replace the atomic categories of a context-free grammar with a &amp;quot;feature structure&amp;quot; that represents the syntactic and semantic properties of the phrase. These feature structures are specified indirectly in terms of constraints that they must satisfy Lexical entries constrain the feature structures that can be associated with terminal nodes of the syntactic tree, and phrase structure rules simultaneou</context>
<context position="5265" citStr="Kay 1985" startWordPosition="847" endWordPosition="848"> denoted by the verb like) and the value of its tense attribute is the constant element none (which indicates that the clause is untensed). The values of the attributes obj and subj of el are the complex elements e2 and e3, respectively (which represent the subject and object of the clause). Both e4 and e5 have the same attributes num and pers, and the values of these attributes of e4 are identical to the corresponding values of these attributes of e5. Nevertheless, e4 and e5 are distinct elements. An operation called unification plays an important role in most accounts of feature structures (Kay 1985; Shieber 1986). The unification operation &amp;quot;combines&amp;quot; or &amp;quot;merges&amp;quot; two elements into a single element that agrees with both of the original elements on the values of all of their defined sequences of attributes, so the unification of two complex elements requires the unification of the values of any attributes they have in common. The unification operation fails if it requires the unification of distinct 132 Johnson Features and Formulae salmon pred = salmon agr = pers = 3rd pred = swim swims num = sg pers = 3rd subj = agr = e&amp;quot; f&apos; e_tense = pres Figure 2 Lexical entries for salmon and swim &amp;quot;The</context>
<context position="18734" citStr="Kay 1985" startWordPosition="3045" endWordPosition="3046">systems that can encode undecidable problems. For example, subsumption constraints, which are useful in the description of agreement phenomena in coordination constructions (Shieber 1989) can be used to encode undecidable problems, as Dorre and Rounds (1989) have shown. Clearly such constraints cannot be expressed in a decidable class, but often they can be axiomatized in other standard logics. Johnson (1991) shows how (positively occurring) subsumption constraints can be axiomatized in first-order logic, and sketches treatments of sort constraints and nonmonotonic devices such as ANY values (Kay 1985) and &apos;constraint equations&apos; (Kaplan and Bresnan 1982) can be formalized in second-order logic using circumscription. 2.1 Axiomatizing Feature Structures with Function-Free Formulae This section shows how the important properties of feature structures can be axiomatized using formulae from the Schtinfinkel-Bernays class, which is the class of first-order formulae of the form . xnVyi • • • yn(10 where co contains no function symbols or quantifiers. (Thus no existential quantifier can appear in the scope of a universal quantifier.) This class of formulae was chosen because it is both decidable (s</context>
</contexts>
<marker>Kay, 1985</marker>
<rawString>Kay, M. (1985). &amp;quot;Unification in Grammar,&amp;quot; in V. Dahl and P. Saint-Dizier, eds., Natural Language Understanding and Logic Programming, North Holland, Amsterdam, The Netherlands.</rawString>
</citation>
<citation valid="true">
<authors>
<author>T Langholm</author>
</authors>
<title>How to Say No with Feature Structures.</title>
<date>1989</date>
<tech>Report No. 13.</tech>
<institution>Department of Mathematics, University of Oslo, COSMOS</institution>
<contexts>
<context position="15874" citStr="Langholm (1989)" startWordPosition="2621" endWordPosition="2622"> 1990; Johnson 1988, 1990a; Pereira 1987). The most widely known model of feature structures and constraint language is the one developed to explain disjunctive feature values by Kasper and Rounds (1986, 1990) and Kasper (1986, 1987). The Kasper—Rounds treatment resolves the difficulties in interpreting disjunctive values by developing a specialized language for expressing these constraints. Various proposals to extend the Kasper—Rounds approach to deal with negative feature values are described by Moshier and Rounds (1987), Moshier (1988), Kasper (1988), Dawar and Vijayashanker (1989, 1990), Langholm (1989); other extensions to this framework are discussed by Dorre and Rounds (1989), Smolka (1988, 1989), and Nebel and Smolka (1989); and Shieber (1989) discusses the integration of such feature systems into a variety of parsing algorithms. One difficulty with this approach is that the constraint language is &amp;quot;custom built,&amp;quot; so important properties, such as compactness and decidability, must be investigated from scratch. Moreover, it is often unclear if the treatment can be extended to handle other types of feature structures as well. Rounds (1988) proposes a model for set-valued features, but he do</context>
</contexts>
<marker>Langholm, 1989</marker>
<rawString>Langholm, T. (1989). How to Say No with Feature Structures. Department of Mathematics, University of Oslo, COSMOS Report No. 13.</rawString>
</citation>
<citation valid="true">
<authors>
<author>H Lewis</author>
</authors>
<title>Complexity Results for Classes of Quantificational Formulae,&amp;quot;</title>
<date>1980</date>
<journal>Journal of Computer and System Sciences.</journal>
<volume>21</volume>
<pages>317--353</pages>
<contexts>
<context position="38369" citStr="Lewis (1980)" startWordPosition="6243" endWordPosition="6244">s is decidable. Further, we can apply results on the computational complexity of the satisfiability problem for the Schonfinkel-Bernays class to determine the computational complexity of the satisfiability problem for systems of such feature constraints. Since (universal) quantifiers appear only in the axiomatization of feature structures and not in the feature constraints themselves, the number of quantifiers appearing in the conjunction of the feature constraints and the axiomatization is a constant, and does not vary with the size of the system of feature constraints. By Proposition 3.2 of Lewis (1980), the satisfiability problem for a formula F with u universal quantifiers in the SchonfinkelBernays class requires nondeterministic time polynomial in IF u, so the problem is in NP. The reductions presented in Kasper and Rounds (1986) and Johnson (1988) can be used to show that the problem is NP-hard, so the satisfiability problem for feature constraints with set-values (as defined above) is NP-complete. 2.3 Unification and Satisfaction This section discusses the relationship between unification and the axiomatization presented above. Unification identifies or merges exactly the elements that </context>
</contexts>
<marker>Lewis, 1980</marker>
<rawString>Lewis, H. (1980). &amp;quot;Complexity Results for Classes of Quantificational Formulae,&amp;quot; Journal of Computer and System Sciences. 21, 317-353.</rawString>
</citation>
<citation valid="true">
<authors>
<author>H Lewis</author>
<author>C Papadimitriou</author>
</authors>
<title>Elements of the Theory of Computation.</title>
<date>1981</date>
<publisher>Prentice Hall,</publisher>
<location>New Jersey.</location>
<contexts>
<context position="19371" citStr="Lewis and Papadimitriou 1981" startWordPosition="3139" endWordPosition="3142">nstraint equations&apos; (Kaplan and Bresnan 1982) can be formalized in second-order logic using circumscription. 2.1 Axiomatizing Feature Structures with Function-Free Formulae This section shows how the important properties of feature structures can be axiomatized using formulae from the Schtinfinkel-Bernays class, which is the class of first-order formulae of the form . xnVyi • • • yn(10 where co contains no function symbols or quantifiers. (Thus no existential quantifier can appear in the scope of a universal quantifier.) This class of formulae was chosen because it is both decidable (see e.g. Lewis and Papadimitriou 1981) and can express the quantification needed to describe the particular set operations proposed here, as well as a variety of other interesting types of feature structures and constraints. (For a general discussion of decidable classes see Gurevich 1976 and Dreben and Goldfarb 1979.) The next section shows how the various kinds of constraints on feature structures described above can be translated into this class of formulae, so any system of such feature constraints is decidable as well. The elements of a feature structure, both complex and constant, constitute the domain of individuals in the </context>
</contexts>
<marker>Lewis, Papadimitriou, 1981</marker>
<rawString>Lewis, H. and Papadimitriou, C. (1981). Elements of the Theory of Computation. Prentice Hall, New Jersey.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Maxwell</author>
<author>R Kaplan</author>
</authors>
<title>A Method for Disjunctive Constraint Satisfaction. Xerox PARC ms.</title>
<date>1989</date>
<marker>Maxwell, Kaplan, 1989</marker>
<rawString>Maxwell, J. and Kaplan, R. (1989a). A Method for Disjunctive Constraint Satisfaction. Xerox PARC ms.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J T Maxwell</author>
<author>R Kaplan</author>
</authors>
<title>An Overview of Disjunctive Constraint Satisfaction,&amp;quot;</title>
<date>1989</date>
<booktitle>in International Workshop on Parsing Technologies,</booktitle>
<location>Carnegie Mellon, Pittsburgh, PA.</location>
<marker>Maxwell, Kaplan, 1989</marker>
<rawString>Maxwell, J. T., III and Kaplan, R. (1989b). &amp;quot;An Overview of Disjunctive Constraint Satisfaction,&amp;quot; in International Workshop on Parsing Technologies, Carnegie Mellon, Pittsburgh, PA.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Moshier</author>
</authors>
<title>Extensions to Unification Grammar for the Description of Programming Languages,</title>
<date>1988</date>
<tech>Ph.D. Thesis,</tech>
<institution>University of Michigan.</institution>
<contexts>
<context position="15804" citStr="Moshier (1988)" startWordPosition="2612" endWordPosition="2613">sponds to the unsatisfiability of that conjunction (Kasper and Rounds 1990; Johnson 1988, 1990a; Pereira 1987). The most widely known model of feature structures and constraint language is the one developed to explain disjunctive feature values by Kasper and Rounds (1986, 1990) and Kasper (1986, 1987). The Kasper—Rounds treatment resolves the difficulties in interpreting disjunctive values by developing a specialized language for expressing these constraints. Various proposals to extend the Kasper—Rounds approach to deal with negative feature values are described by Moshier and Rounds (1987), Moshier (1988), Kasper (1988), Dawar and Vijayashanker (1989, 1990), Langholm (1989); other extensions to this framework are discussed by Dorre and Rounds (1989), Smolka (1988, 1989), and Nebel and Smolka (1989); and Shieber (1989) discusses the integration of such feature systems into a variety of parsing algorithms. One difficulty with this approach is that the constraint language is &amp;quot;custom built,&amp;quot; so important properties, such as compactness and decidability, must be investigated from scratch. Moreover, it is often unclear if the treatment can be extended to handle other types of feature structures as w</context>
</contexts>
<marker>Moshier, 1988</marker>
<rawString>Moshier, M. (1988). Extensions to Unification Grammar for the Description of Programming Languages, Ph.D. Thesis, University of Michigan.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M D Moshier</author>
<author>W C Rounds</author>
</authors>
<title>A Logic for Partially Specified Data Structures,&amp;quot;</title>
<date>1987</date>
<booktitle>in The ACM Symposium on the Principles of Programming Languages, Association for Computing Machinery,</booktitle>
<location>Munich, Germany.</location>
<contexts>
<context position="11333" citStr="Moshier and Rounds (1987)" startWordPosition="1873" endWordPosition="1876">the empty set (which corresponds to the empty discourse context) produces the feature structure depicted in Figure 7. Further, the unification of the value of the refs-out attribute in Figure 7 with the value of the refs-in attribute of u in Figure 6 (the lexical entry for she), which corresponds to interpreting the pronoun as an anaphor within the context established by the single NP a woman produces the feature structure depicted in Figure 8. Extending the possible feature structures beyond the basic attribute-value features complicates the basic unification operation, however. For example, Moshier and Rounds (1987) and Pereira (1987) point out that it is not obvious how to extend unification 3 Reference markers in DRT correspond approximately to the referential indices associated with NPs in GB theory. - 135 Computational Linguistics Volume 17, Number 2 cat = NP index = refs-in = { } refs-out = } Figure 8 The result of unifying the value of the refs-out attribute of Figure 7 with s in Figure 6 def = + these def = + num = sg num = pl this agr = pers = 3rd agr = , pers = 3rd u&apos; v pred = salmon salmon pred = swim num = sg subj = agr = pers = 3rd tense = pres swim Figure 9 Feature structures demonstrating i</context>
<context position="15788" citStr="Moshier and Rounds (1987)" startWordPosition="2608" endWordPosition="2611">d unification failure corresponds to the unsatisfiability of that conjunction (Kasper and Rounds 1990; Johnson 1988, 1990a; Pereira 1987). The most widely known model of feature structures and constraint language is the one developed to explain disjunctive feature values by Kasper and Rounds (1986, 1990) and Kasper (1986, 1987). The Kasper—Rounds treatment resolves the difficulties in interpreting disjunctive values by developing a specialized language for expressing these constraints. Various proposals to extend the Kasper—Rounds approach to deal with negative feature values are described by Moshier and Rounds (1987), Moshier (1988), Kasper (1988), Dawar and Vijayashanker (1989, 1990), Langholm (1989); other extensions to this framework are discussed by Dorre and Rounds (1989), Smolka (1988, 1989), and Nebel and Smolka (1989); and Shieber (1989) discusses the integration of such feature systems into a variety of parsing algorithms. One difficulty with this approach is that the constraint language is &amp;quot;custom built,&amp;quot; so important properties, such as compactness and decidability, must be investigated from scratch. Moreover, it is often unclear if the treatment can be extended to handle other types of feature</context>
<context position="23680" citStr="Moshier and Rounds (1987)" startWordPosition="3803" endWordPosition="3806"> the Schonfinkel-Bernays class). Example 7 The interpretation corresponding to the attribute-value structure depicted in Figure 1 has as its domain the set D = {seem, like, john, sg, 3rd, mary, pres, none} u {eo, ,e5}. The attributes denote relations on D x D. For example, pred denotes the relation {(e0 , seem), (e1, like), (e2, john), (e3, mary)} . It is straightforward to check that all of the axioms hold in this interpretation. Instead of providing entities in the interpretation that serve as the denotation for &amp;quot;disjunctive&amp;quot; or &amp;quot;negative&amp;quot; features, we follow Kasper and Rounds (1986, 1990), Moshier and Rounds (1987), and Johnson (1988, 1990) in permitting disjunction and negation only in the constraint language. Since the classical semantics of disjunction and negation for first-order languages is consistent and monotonic, a consistent, monotonic semantics for negative and disjunctive feature constraints follows directly. (An example is presented below; see Johnson (1990) and especially Section 2.10 of Johnson (1988) for further discussion). We turn now to the set-valued features. The most straightforward way of introducing set-valued features would be to combine some standard axiomatization of set theor</context>
</contexts>
<marker>Moshier, Rounds, 1987</marker>
<rawString>Moshier, M. D. and Rounds, W. C. (1987). &amp;quot;A Logic for Partially Specified Data Structures,&amp;quot; in The ACM Symposium on the Principles of Programming Languages, Association for Computing Machinery, Munich, Germany.</rawString>
</citation>
<citation valid="true">
<authors>
<author>B Nebel</author>
<author>G Smolka</author>
</authors>
<title>Representation and Reasoning with Attributive Descriptions.</title>
<date>1989</date>
<journal>IBM Stuttgart IWBS Report</journal>
<volume>81</volume>
<contexts>
<context position="16001" citStr="Nebel and Smolka (1989)" startWordPosition="2639" endWordPosition="2642"> the one developed to explain disjunctive feature values by Kasper and Rounds (1986, 1990) and Kasper (1986, 1987). The Kasper—Rounds treatment resolves the difficulties in interpreting disjunctive values by developing a specialized language for expressing these constraints. Various proposals to extend the Kasper—Rounds approach to deal with negative feature values are described by Moshier and Rounds (1987), Moshier (1988), Kasper (1988), Dawar and Vijayashanker (1989, 1990), Langholm (1989); other extensions to this framework are discussed by Dorre and Rounds (1989), Smolka (1988, 1989), and Nebel and Smolka (1989); and Shieber (1989) discusses the integration of such feature systems into a variety of parsing algorithms. One difficulty with this approach is that the constraint language is &amp;quot;custom built,&amp;quot; so important properties, such as compactness and decidability, must be investigated from scratch. Moreover, it is often unclear if the treatment can be extended to handle other types of feature structures as well. Rounds (1988) proposes a model for set-valued features, but he does not provide a language for expressing constraints on such set-valued entities, or investigate the computational complexity o</context>
</contexts>
<marker>Nebel, Smolka, 1989</marker>
<rawString>Nebel, B. and Smolka, G. (1989). Representation and Reasoning with Attributive Descriptions. IBM Stuttgart IWBS Report 81.</rawString>
</citation>
<citation valid="true">
<authors>
<author>G Nelson</author>
<author>D C Oppen</author>
</authors>
<title>Fast Decision Procedures Based on Congruence Closure,&amp;quot;</title>
<date>1980</date>
<journal>Journal of the Association for Computing Machinery.</journal>
<volume>27</volume>
<pages>245--257</pages>
<contexts>
<context position="41014" citStr="Nelson and Oppen 1980" startWordPosition="6668" endWordPosition="6671"> graph encoding of) the conjunction of all of their atomic consequences. As Kasper (1986, 1987) noted in a different setting, the steps of the attribute-value unification algorithm are just applications of the axioms 1-3. It &apos;forward chains&apos; using axiom schema (3) (for which the graph representation provides efficient indexing), and checks at each step that 1 and 2 are not falsified; if they are falsified the unification algorithm halts and reports a unification failure. Atomic equalities x =y are represented by a &apos;forwarding pointer&apos; from x to y (as in the UNION-FIND algorithm (Gallier 1986; Nelson and Oppen 1980; Johnson in press)). Example 2 (continued) The unification of e&apos; and e&amp;quot; in Figures 2 and 3 corresponds to conjoining the formula e&apos; -= e&amp;quot; to the conjunction of 8a and 8b, resulting in the formula 15a. 15a. e&apos; =- e&amp;quot;A pred(e&apos;, salmon)A agr(e&apos;,I)A pers(f&apos;,3rd)A pred(g&amp;quot;,swim)A tense(g&amp;quot; , pres)A subj(g&amp;quot; , e&amp;quot;)A agr(e&amp;quot; , f&amp;quot;) A num(f&amp;quot; , sg)A pers(f&amp;quot; , 3rd). This formula can be simplified by substituting e&apos; for e&amp;quot; to yield 15b (this substitution corresponds exactly to the first step of the unification algorithm, viz, redirecting e&amp;quot; to e&apos;). The affected subformulae are in boldface below. 15b. e&apos; = e&amp;quot;A </context>
</contexts>
<marker>Nelson, Oppen, 1980</marker>
<rawString>Nelson, G. and Oppen, D. C. (1980). &amp;quot;Fast Decision Procedures Based on Congruence Closure,&amp;quot; Journal of the Association for Computing Machinery. 27.2, 245-257.</rawString>
</citation>
<citation valid="true">
<authors>
<author>F C N Pereira</author>
</authors>
<title>Grammars and Logics of Partial Information,&amp;quot;</title>
<date>1987</date>
<booktitle>in The Proceedings of the International Conference on Logic Programming,</booktitle>
<location>Melbourne, Johnson</location>
<contexts>
<context position="11352" citStr="Pereira (1987)" startWordPosition="1878" endWordPosition="1879">ds to the empty discourse context) produces the feature structure depicted in Figure 7. Further, the unification of the value of the refs-out attribute in Figure 7 with the value of the refs-in attribute of u in Figure 6 (the lexical entry for she), which corresponds to interpreting the pronoun as an anaphor within the context established by the single NP a woman produces the feature structure depicted in Figure 8. Extending the possible feature structures beyond the basic attribute-value features complicates the basic unification operation, however. For example, Moshier and Rounds (1987) and Pereira (1987) point out that it is not obvious how to extend unification 3 Reference markers in DRT correspond approximately to the referential indices associated with NPs in GB theory. - 135 Computational Linguistics Volume 17, Number 2 cat = NP index = refs-in = { } refs-out = } Figure 8 The result of unifying the value of the refs-out attribute of Figure 7 with s in Figure 6 def = + these def = + num = sg num = pl this agr = pers = 3rd agr = , pers = 3rd u&apos; v pred = salmon salmon pred = swim num = sg subj = agr = pers = 3rd tense = pres swim Figure 9 Feature structures demonstrating interaction of negat</context>
<context position="15300" citStr="Pereira 1987" startWordPosition="2541" endWordPosition="2542">g constraints on linguistic objects, rather than the linguistic objects that satisfy these constraints. This avoids any need to refer to &amp;quot;negative&amp;quot; or &amp;quot;disjunctive&amp;quot; objects as entities appearing in a feature structure. As explained below, the familiar attribute-value &amp;quot;unification algorithm&amp;quot; can be interpreted as computing the atomic consequences of a purely conjunctive formula (where the graphs it operates on are data structures efficiently representing such formulae), and unification failure corresponds to the unsatisfiability of that conjunction (Kasper and Rounds 1990; Johnson 1988, 1990a; Pereira 1987). The most widely known model of feature structures and constraint language is the one developed to explain disjunctive feature values by Kasper and Rounds (1986, 1990) and Kasper (1986, 1987). The Kasper—Rounds treatment resolves the difficulties in interpreting disjunctive values by developing a specialized language for expressing these constraints. Various proposals to extend the Kasper—Rounds approach to deal with negative feature values are described by Moshier and Rounds (1987), Moshier (1988), Kasper (1988), Dawar and Vijayashanker (1989, 1990), Langholm (1989); other extensions to this</context>
</contexts>
<marker>Pereira, 1987</marker>
<rawString>Pereira, F. C. N. (1987). &amp;quot;Grammars and Logics of Partial Information,&amp;quot; in The Proceedings of the International Conference on Logic Programming, Melbourne, Johnson Features and Formulae Australia.</rawString>
</citation>
<citation valid="true">
<authors>
<author>F C N Pereira</author>
<author>S M Shieber</author>
</authors>
<title>The Semantics of Grammar Formalisms Seen as Computer Languages,&amp;quot; in COLING-84, The Association for Computational Linguistics,</title>
<date>1984</date>
<institution>Stanford University.</institution>
<contexts>
<context position="13917" citStr="Pereira and Shieber (1984)" startWordPosition="2336" endWordPosition="2339">If e&apos; is first unified with u&apos; then f&apos; is unified with v&apos; and further unification of e&apos; with e succeeds, since v&apos; does satisfy f. Thus under this interpretation agr = [pers = 3rd &apos; 136 Johnson Features and Formulae of negation and unification, the success or failure of a sequence of unifications depends on the order in which they are performed.4 2. Feature Structures and Function-free Formulae These problems have generated a considerable body of work on the mathematical properties of feature structures and the constraints and operations that apply to them. Following Kaplan and Bresnan (1982), Pereira and Shieber (1984), Kasper and Rounds (1986, 1990), and Johnson (1988, 1990a) the constraints that determine the feature structures are regarded as formulae from a language for describing feature structures, rather than as feature structures themselves. Disjunction and negation appear only in expressions from the description language, rather than as components of the feature structures that these expressions describe. Thus the lexical entries in the examples above will be interpreted as formulae that constrain the feature structures that can be associated with these lexical items in a syntactic tree, rather tha</context>
</contexts>
<marker>Pereira, Shieber, 1984</marker>
<rawString>Pereira, F. C. N. and Shieber, S. M. (1984). &amp;quot;The Semantics of Grammar Formalisms Seen as Computer Languages,&amp;quot; in COLING-84, The Association for Computational Linguistics, Stanford University.</rawString>
</citation>
<citation valid="true">
<authors>
<author>C Pollard</author>
<author>I Sag</author>
</authors>
<title>Information-Based Syntax and Semantics, Volume 1. CSLI Lecture Notes,</title>
<date>1987</date>
<publisher>Chicago University Press,</publisher>
<location>Chicago.</location>
<contexts>
<context position="882" citStr="Pollard and Sag 1987" startWordPosition="115" endWordPosition="118"> be used to express constraints on these structures. Desirable properties, such as compactness and decidability, follow directly. Moreover, additional types of feature values, such as &amp;quot;set-valued&amp;quot; features, can be incorporated into the system simply by axiomatizing their properties. 1. Introduction Many modern linguistic theories, such as Lexical-Functional Grammar (Bresnan 1982), Functional Unification Grammar (Kay 1985), Generalized Phrase Structure Grammar (Gazdar et al. 1985), Unification Categorial Grammar (Haddock et al. 1987), (Uszkoreit 1986), and Head-Driven Phrase Structure Grammar (Pollard and Sag 1987), replace the atomic categories of a context-free grammar with a &amp;quot;feature structure&amp;quot; that represents the syntactic and semantic properties of the phrase. These feature structures are specified indirectly in terms of constraints that they must satisfy Lexical entries constrain the feature structures that can be associated with terminal nodes of the syntactic tree, and phrase structure rules simultaneously constrain the feature structures that can be associated with a parent node and its immediate descendants. That is, lexical entries and syntactic rules used to construct a syntactic phrase stru</context>
<context position="30190" citStr="Pollard and Sag 1987" startWordPosition="4847" endWordPosition="4850">ton(u, x) is true if and only if u is the only member of x. 7. Vux singleton(u, x) 4-4 in(u, x) A Vv in(v , x) u = v Unfortunately the axioms 4-7 do not belong to the Schonfinkel-Bernays class, so we cannot guarantee the decidability of systems of constraints defined using them simply by noting a translation into this class exists. However, in all of the linguistic applications I am aware of these predicates always appear positively, and in this case these axioms can be replaced by the corresponding &amp;quot;one-sided&amp;quot; axioms given below. (The predicate null is an exception, since some HPSG analyses (Pollard and Sag 1987) require the set of unsaturated arguments of some phrases to be non-null. However, it is possible to require that a set s is nonempty by introducing a new constant u and require that in (u , s).) 4&apos;. V xy null(x) x) 5&apos;. Vuxyz union(x, y, z) (in(u, z) 4—* in(u , x) v in(u, y)) 6&apos;. Vuxyz intersection(x, y, z) —+ (in(u, z) in(u, x) A in(u, y)) 7&apos;. Vuxv singleton(u, x) -4 (in(u, x) A in(v, , x) —+ u -= v) These one-sided definitions are incorrect when these predicates appear negatively (i.e., in the scope of an odd number of negation symbols after all other proposition connectives have been expres</context>
</contexts>
<marker>Pollard, Sag, 1987</marker>
<rawString>Pollard, C. and Sag, I. (1987). Information-Based Syntax and Semantics, Volume 1. CSLI Lecture Notes, Chicago University Press, Chicago.</rawString>
</citation>
<citation valid="true">
<authors>
<author>W Rounds</author>
</authors>
<title>Set Values for Unification-Based Grammar Formalisms and Logic Programming. Center for the Study of Language and Information</title>
<date>1988</date>
<tech>CSLI Report 129.</tech>
<contexts>
<context position="16422" citStr="Rounds (1988)" startWordPosition="2705" endWordPosition="2706">per (1988), Dawar and Vijayashanker (1989, 1990), Langholm (1989); other extensions to this framework are discussed by Dorre and Rounds (1989), Smolka (1988, 1989), and Nebel and Smolka (1989); and Shieber (1989) discusses the integration of such feature systems into a variety of parsing algorithms. One difficulty with this approach is that the constraint language is &amp;quot;custom built,&amp;quot; so important properties, such as compactness and decidability, must be investigated from scratch. Moreover, it is often unclear if the treatment can be extended to handle other types of feature structures as well. Rounds (1988) proposes a model for set-valued features, but he does not provide a language for expressing constraints on such set-valued entities, or investigate the computational complexity of systems of such constraints. This paper follows an alternative strategy suggested in Johnson (1990a): axiomatize the relevant properties of feature structures in some well-understood language (here first-order logic) and translate constraints on these structures into the same language. 4 It is possible to avoid these problems by augmenting feature structures with &amp;quot;inequality arcs,&amp;quot; as was first proposed (to my knowl</context>
<context position="26472" citStr="Rounds (1988)" startWordPosition="4224" endWordPosition="4225">is axiomatization presented here will admit models in which the values of set-valued features do not have these properties.7 These additional properties of the set-membership relation don&apos;t seem to be needed in linguistic analyses, so such stipulations are not made here. The axiom of foundation requires that all sets are well founded; i.e., that the transitive closure of the set-membership relation is irreflexive, or more informally, that no set directly or indirectly contains itself as a member. Versions of set-theory that relax this restriction have been proposed by, e.g., Aczel (1988), and Rounds (1988) argues that non—well founded sets may be appropriate models of set values in feature structures. The paradoxes associated with non—well founded set theories are avoided here because the axiom of comprehension that asserts the existence of paradoxical sets is not included in this axiomatization; i.e., the only way of defining a set is either by explicitly listing its members or by means of union and intersection operations. The axiom of extensionality requires that if sets Si and 52 contain exactly the same members then Si = S2; without extensionality it is possible for two different sets to c</context>
</contexts>
<marker>Rounds, 1988</marker>
<rawString>Rounds, W. (1988). Set Values for Unification-Based Grammar Formalisms and Logic Programming. Center for the Study of Language and Information CSLI Report 129.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S M Shieber</author>
</authors>
<title>Parsing and Type Inference for Natural and Computer Languages.</title>
<date>1989</date>
<journal>SRI International Technical Note</journal>
<volume>460</volume>
<contexts>
<context position="16021" citStr="Shieber (1989)" startWordPosition="2644" endWordPosition="2645"> disjunctive feature values by Kasper and Rounds (1986, 1990) and Kasper (1986, 1987). The Kasper—Rounds treatment resolves the difficulties in interpreting disjunctive values by developing a specialized language for expressing these constraints. Various proposals to extend the Kasper—Rounds approach to deal with negative feature values are described by Moshier and Rounds (1987), Moshier (1988), Kasper (1988), Dawar and Vijayashanker (1989, 1990), Langholm (1989); other extensions to this framework are discussed by Dorre and Rounds (1989), Smolka (1988, 1989), and Nebel and Smolka (1989); and Shieber (1989) discusses the integration of such feature systems into a variety of parsing algorithms. One difficulty with this approach is that the constraint language is &amp;quot;custom built,&amp;quot; so important properties, such as compactness and decidability, must be investigated from scratch. Moreover, it is often unclear if the treatment can be extended to handle other types of feature structures as well. Rounds (1988) proposes a model for set-valued features, but he does not provide a language for expressing constraints on such set-valued entities, or investigate the computational complexity of systems of such co</context>
<context position="18312" citStr="Shieber 1989" startWordPosition="2982" endWordPosition="2983">d to determine the satisfiability of the feature constraints as well. In this paper the properties of attribute-value structures and constraints on them are expressed in a decidable class of first-order formulae: this means that the satisfiability problem for such formulae, and hence the feature constraints that they express, is always decidable. Of course, some linguistic analyses make use of feature structure constraint systems that can encode undecidable problems. For example, subsumption constraints, which are useful in the description of agreement phenomena in coordination constructions (Shieber 1989) can be used to encode undecidable problems, as Dorre and Rounds (1989) have shown. Clearly such constraints cannot be expressed in a decidable class, but often they can be axiomatized in other standard logics. Johnson (1991) shows how (positively occurring) subsumption constraints can be axiomatized in first-order logic, and sketches treatments of sort constraints and nonmonotonic devices such as ANY values (Kay 1985) and &apos;constraint equations&apos; (Kaplan and Bresnan 1982) can be formalized in second-order logic using circumscription. 2.1 Axiomatizing Feature Structures with Function-Free Formul</context>
<context position="36003" citStr="Shieber 1989" startWordPosition="5852" endWordPosition="5853"> , 3rd) 9 Instead of naming all of the nonroot attribute-value elements with constants as is done here, it is possible to merely assert their existence using an existential quantification. For example, the lexical entry for salmon could be the formula Sf&apos;pred(e&apos;, salmon) A agr(ei , A pers(f&apos; , 3rd) where f&apos; is an existentially quantified variable. This formulation has the advantage that no &apos;renaming&apos; is needed when determining subsumption of systems of attribute-value constraints. (The subsumption relation between systems of constraints is used in certain types of &apos;unification based&apos; parsers (Shieber 1989).) That is, a system of constraints represented by a formula (,o subsumes another system of constraints represented by 6 iff A 0 —&gt; co, where A is the conjunction of the axioms defining the relevant types of feature structures. 10 The formulation (10) of the negative constraint depicted in Figure 5 does not imply that f has either a num or pers attribute. Conceivably, one might want to interpret such a negative constraint as requiring f to have both num and pers attributes with values differing from either sg or 3rd, respectively. The formula below expresses this interpretation. pred(g, swim) </context>
</contexts>
<marker>Shieber, 1989</marker>
<rawString>Shieber, S. M. (1989). Parsing and Type Inference for Natural and Computer Languages. SRI International Technical Note 460.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S M Shieber</author>
</authors>
<title>An Introduction to Unification-Based Approaches to Grammar.</title>
<date>1986</date>
<booktitle>CSLI Lecture Notes Series, University of</booktitle>
<publisher>Chicago Press,</publisher>
<location>Chicago.</location>
<contexts>
<context position="5280" citStr="Shieber 1986" startWordPosition="849" endWordPosition="850">y the verb like) and the value of its tense attribute is the constant element none (which indicates that the clause is untensed). The values of the attributes obj and subj of el are the complex elements e2 and e3, respectively (which represent the subject and object of the clause). Both e4 and e5 have the same attributes num and pers, and the values of these attributes of e4 are identical to the corresponding values of these attributes of e5. Nevertheless, e4 and e5 are distinct elements. An operation called unification plays an important role in most accounts of feature structures (Kay 1985; Shieber 1986). The unification operation &amp;quot;combines&amp;quot; or &amp;quot;merges&amp;quot; two elements into a single element that agrees with both of the original elements on the values of all of their defined sequences of attributes, so the unification of two complex elements requires the unification of the values of any attributes they have in common. The unification operation fails if it requires the unification of distinct 132 Johnson Features and Formulae salmon pred = salmon agr = pers = 3rd pred = swim swims num = sg pers = 3rd subj = agr = e&amp;quot; f&apos; e_tense = pres Figure 2 Lexical entries for salmon and swim &amp;quot;The salmon swims&amp;quot; </context>
<context position="27336" citStr="Shieber (1986)" startWordPosition="4362" endWordPosition="4363">l sets is not included in this axiomatization; i.e., the only way of defining a set is either by explicitly listing its members or by means of union and intersection operations. The axiom of extensionality requires that if sets Si and 52 contain exactly the same members then Si = S2; without extensionality it is possible for two different sets to contain exactly the same members. Admittedly the primary reason for omitting an extensionality axiom is that it does not appear to be axiomatizable using SchonfinkelBernays&apos; formulae, but three other reasons motivate this decision. First, as noted in Shieber (1986) and in Example 1 above, feature structures in general are not extensional (e.g., two distinct attribute-value elements can have exactly the same attributes and values), and it seems reasonable to treat set-values in a nonextensional fashion as well. Second, extensionality could produce undesirable interactions with the attributevalue component of feature structures. Since set-valued features can also have attributes (for example, in LFG (Kaplan and Bresnan 1982)) a conjunction is associated with a set-value that also has attributes), extensionality would prohibit there being 7 In fact there a</context>
<context position="33066" citStr="Shieber 1986" startWordPosition="5367" endWordPosition="5368">atisfies (i) as required. In fact we have shown something stronger; the denotation of A in .A4&apos; is a subset of the denotation of A in M. • 2.2 Expressing Constraints A feature structure is specified implicitly by means of the constraints that it must satisfy. This section shows how such constraints can be translated into quantifies-free and function-free prenex formulae. There is a plethora of different notations for expressing these constraints: the constraint requiring that the value of attribute a of (the entity denoted by) x is (the entity denoted by) y is written as (x a) = y in PATR-II (Shieber 1986), as (x a) = y in LFG (Kaplan and Bresnan 1982), and as x(a) y in Johnson (1988), for example. Here we express attribute-value constraints using the attribute relations a, so this constraint would be expressed as a(x , y). Set-valued constraints are expressed using the relations in, null, union, and singleton defined in the previous section. The propositional connectives are used to express negative and disjunctive feature constraints. This section shows how constraints on feature bundles can be specified using equality, the attribute relations, and the set predicates axiomatized in the last s</context>
</contexts>
<marker>Shieber, 1986</marker>
<rawString>Shieber, S. M. (1986). An Introduction to Unification-Based Approaches to Grammar. CSLI Lecture Notes Series, University of Chicago Press, Chicago.</rawString>
</citation>
<citation valid="true">
<authors>
<author>G Smolka</author>
</authors>
<title>Attributive Concept Descriptions with Unions and Complements.</title>
<date>1989</date>
<journal>IBM Stuttgart IWBS Report</journal>
<volume>68</volume>
<contexts>
<context position="16001" citStr="Smolka (1989)" startWordPosition="2641" endWordPosition="2642">eveloped to explain disjunctive feature values by Kasper and Rounds (1986, 1990) and Kasper (1986, 1987). The Kasper—Rounds treatment resolves the difficulties in interpreting disjunctive values by developing a specialized language for expressing these constraints. Various proposals to extend the Kasper—Rounds approach to deal with negative feature values are described by Moshier and Rounds (1987), Moshier (1988), Kasper (1988), Dawar and Vijayashanker (1989, 1990), Langholm (1989); other extensions to this framework are discussed by Dorre and Rounds (1989), Smolka (1988, 1989), and Nebel and Smolka (1989); and Shieber (1989) discusses the integration of such feature systems into a variety of parsing algorithms. One difficulty with this approach is that the constraint language is &amp;quot;custom built,&amp;quot; so important properties, such as compactness and decidability, must be investigated from scratch. Moreover, it is often unclear if the treatment can be extended to handle other types of feature structures as well. Rounds (1988) proposes a model for set-valued features, but he does not provide a language for expressing constraints on such set-valued entities, or investigate the computational complexity o</context>
</contexts>
<marker>Smolka, 1989</marker>
<rawString>Smolka, G. (1989a). Attributive Concept Descriptions with Unions and Complements. IBM Stuttgart IWBS Report 68.</rawString>
</citation>
<citation valid="true">
<authors>
<author>G Smolka</author>
</authors>
<title>Feature Constraint Logics for Unification Grammars. IBM Deutschland Wissenschaftliches Zentrum</title>
<date>1989</date>
<tech>IWBS Report No. 93.</tech>
<contexts>
<context position="16001" citStr="Smolka (1989)" startWordPosition="2641" endWordPosition="2642">eveloped to explain disjunctive feature values by Kasper and Rounds (1986, 1990) and Kasper (1986, 1987). The Kasper—Rounds treatment resolves the difficulties in interpreting disjunctive values by developing a specialized language for expressing these constraints. Various proposals to extend the Kasper—Rounds approach to deal with negative feature values are described by Moshier and Rounds (1987), Moshier (1988), Kasper (1988), Dawar and Vijayashanker (1989, 1990), Langholm (1989); other extensions to this framework are discussed by Dorre and Rounds (1989), Smolka (1988, 1989), and Nebel and Smolka (1989); and Shieber (1989) discusses the integration of such feature systems into a variety of parsing algorithms. One difficulty with this approach is that the constraint language is &amp;quot;custom built,&amp;quot; so important properties, such as compactness and decidability, must be investigated from scratch. Moreover, it is often unclear if the treatment can be extended to handle other types of feature structures as well. Rounds (1988) proposes a model for set-valued features, but he does not provide a language for expressing constraints on such set-valued entities, or investigate the computational complexity o</context>
</contexts>
<marker>Smolka, 1989</marker>
<rawString>Smolka, G. (1989b). Feature Constraint Logics for Unification Grammars. IBM Deutschland Wissenschaftliches Zentrum IWBS Report No. 93.</rawString>
</citation>
<citation valid="true">
<authors>
<author>G Smolka</author>
</authors>
<title>A Feature Logic with Subsorts. IBM Deutschland GmbH.</title>
<date>1988</date>
<tech>Lilog Report No. 33.</tech>
<contexts>
<context position="15965" citStr="Smolka (1988" startWordPosition="2635" endWordPosition="2636">nd constraint language is the one developed to explain disjunctive feature values by Kasper and Rounds (1986, 1990) and Kasper (1986, 1987). The Kasper—Rounds treatment resolves the difficulties in interpreting disjunctive values by developing a specialized language for expressing these constraints. Various proposals to extend the Kasper—Rounds approach to deal with negative feature values are described by Moshier and Rounds (1987), Moshier (1988), Kasper (1988), Dawar and Vijayashanker (1989, 1990), Langholm (1989); other extensions to this framework are discussed by Dorre and Rounds (1989), Smolka (1988, 1989), and Nebel and Smolka (1989); and Shieber (1989) discusses the integration of such feature systems into a variety of parsing algorithms. One difficulty with this approach is that the constraint language is &amp;quot;custom built,&amp;quot; so important properties, such as compactness and decidability, must be investigated from scratch. Moreover, it is often unclear if the treatment can be extended to handle other types of feature structures as well. Rounds (1988) proposes a model for set-valued features, but he does not provide a language for expressing constraints on such set-valued entities, or invest</context>
<context position="20231" citStr="Smolka (1988" startWordPosition="3272" endWordPosition="3273">976 and Dreben and Goldfarb 1979.) The next section shows how the various kinds of constraints on feature structures described above can be translated into this class of formulae, so any system of such feature constraints is decidable as well. The elements of a feature structure, both complex and constant, constitute the domain of individuals in the intended interpretation. The attributes are binary relations over this domain.5 We proceed by axiomatizing the conditions under which an interpretation corresponds to a well-formed feature structure, formulating them in essentially the same way as Smolka (1988, 1989) does. The axiomatization begins by describing the properties of the constant elements of attribute-value structures. The attribute-value constants are the denotation of certain constant symbols of the language of first-order logic, but not all constants (of the firstorder language) will denote attribute-value constants since it is convenient to have constants that denote other entities as well. The following axiom schemata express the requirement that attribute-value constants have no attributes and that all attribute5 This differs from earlier work (Johnson 1988) in which values and a</context>
</contexts>
<marker>Smolka, 1988</marker>
<rawString>Smolka, G. (1988). A Feature Logic with Subsorts. IBM Deutschland GmbH. Lilog Report No. 33.</rawString>
</citation>
<citation valid="true">
<authors>
<author>H Uszkoreit</author>
</authors>
<title>Categorial Unification Grammar,&amp;quot;</title>
<date>1986</date>
<booktitle>in COLING-86,</booktitle>
<pages>187--194</pages>
<contexts>
<context position="817" citStr="Uszkoreit 1986" startWordPosition="108" endWordPosition="109">d in a decidable class of first-order logic, which can also be used to express constraints on these structures. Desirable properties, such as compactness and decidability, follow directly. Moreover, additional types of feature values, such as &amp;quot;set-valued&amp;quot; features, can be incorporated into the system simply by axiomatizing their properties. 1. Introduction Many modern linguistic theories, such as Lexical-Functional Grammar (Bresnan 1982), Functional Unification Grammar (Kay 1985), Generalized Phrase Structure Grammar (Gazdar et al. 1985), Unification Categorial Grammar (Haddock et al. 1987), (Uszkoreit 1986), and Head-Driven Phrase Structure Grammar (Pollard and Sag 1987), replace the atomic categories of a context-free grammar with a &amp;quot;feature structure&amp;quot; that represents the syntactic and semantic properties of the phrase. These feature structures are specified indirectly in terms of constraints that they must satisfy Lexical entries constrain the feature structures that can be associated with terminal nodes of the syntactic tree, and phrase structure rules simultaneously constrain the feature structures that can be associated with a parent node and its immediate descendants. That is, lexical entr</context>
</contexts>
<marker>Uszkoreit, 1986</marker>
<rawString>Uszkoreit, H. (1986). &amp;quot;Categorial Unification Grammar,&amp;quot; in COLING-86, 187-194.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>