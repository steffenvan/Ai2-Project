<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000017">
<title confidence="0.999835">
A Transition-Based Dependency Parser
Using a Dynamic Parsing Strategy
</title>
<author confidence="0.997683">
Francesco Sartorio
</author>
<affiliation confidence="0.978041666666667">
Department of
Information Engineering
University of Padua, Italy
</affiliation>
<email confidence="0.992129">
sartorio@dei.unipd.it
</email>
<author confidence="0.993951">
Giorgio Satta
</author>
<affiliation confidence="0.977063666666667">
Department of
Information Engineering
University of Padua, Italy
</affiliation>
<email confidence="0.991922">
satta@dei.unipd.it
</email>
<author confidence="0.979774">
Joakim Nivre
</author>
<affiliation confidence="0.957229666666667">
Department of
Linguistics and Philology
Uppsala University, Sweden
</affiliation>
<email confidence="0.992703">
joakim.nivre@lingfil.uu.se
</email>
<sectionHeader confidence="0.993768" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.9996876">
We present a novel transition-based, greedy
dependency parser which implements a
flexible mix of bottom-up and top-down
strategies. The new strategy allows the
parser to postpone difficult decisions until
the relevant information becomes available.
The novel parser has a ∼12% error reduc-
tion in unlabeled attachment score over an
arc-eager parser, with a slow-down factor
of 2.8.
</bodyText>
<sectionHeader confidence="0.998752" genericHeader="introduction">
1 Introduction
</sectionHeader>
<bodyText confidence="0.999879764705883">
Dependency-based methods for syntactic parsing
have become increasingly popular during the last
decade or so. This development is probably due
to many factors, such as the increased availability
of dependency treebanks and the perceived use-
fulness of dependency structures as an interface
to downstream applications, but a very important
reason is also the high efficiency offered by de-
pendency parsers, enabling web-scale parsing with
high throughput. The most efficient parsers are
greedy transition-based parsers, which only explore
a single derivation for each input and relies on
a locally trained classifier for predicting the next
parser action given a compact representation of the
derivation history, as pioneered by Yamada and
Matsumoto (2003), Nivre (2003), Attardi (2006),
and others. However, while these parsers are cap-
able of processing tens of thousands of tokens per
second with the right choice of classifiers, they are
also known to perform slightly below the state-of-
the-art because of search errors and subsequent
error propagation (McDonald and Nivre, 2007),
and recent research on transition-based depend-
ency parsing has therefore explored different ways
of improving their accuracy.
The most common approach is to use beam
search instead of greedy decoding, in combination
with a globally trained model that tries to minim-
ize the loss over the entire sentence instead of a
locally trained classifier that tries to maximize the
accuracy of single decisions (given no previous er-
rors), as first proposed by Zhang and Clark (2008).
With these methods, transition-based parsers have
reached state-of-the-art accuracy for a number of
languages (Zhang and Nivre, 2011; Bohnet and
Nivre, 2012). However, the drawback with this ap-
proach is that parsing speed is proportional to the
size of the beam, which means that the most accur-
ate transition-based parsers are not nearly as fast
as the original greedy transition-based parsers. An-
other line of research tries to retain the efficiency of
greedy classifier-based parsing by instead improv-
ing the way in which classifiers are learned from
data. While the classical approach limits training
data to parser states that result from oracle predic-
tions (derived from a treebank), these novel ap-
proaches allow the classifier to explore states that
result from its own (sometimes erroneous) predic-
tions (Choi and Palmer, 2011; Goldberg and Nivre,
2012).
In this paper, we explore an orthogonal approach
to improving the accuracy of transition-based pars-
ers, without sacrificing their advantage in efficiency,
by introducing a new type of transition system.
While all previous transition systems assume a
static parsing strategy with respect to top-down
and bottom-up processing, our new system allows
a dynamic strategy for ordering parsing decisions.
This has the advantage that the parser can postpone
difficult decisions until the relevant information be-
comes available, in a way that is not possible in
existing transition systems. A second advantage of
dynamic parsing is that we can extend the feature
inventory of previous systems. Our experiments
show that these advantages lead to significant im-
provements in parsing accuracy, compared to a
baseline parser that uses the arc-eager transition
system of Nivre (2003), which is one of the most
</bodyText>
<page confidence="0.983408">
135
</page>
<note confidence="0.9270835">
Proceedings of the 51st Annual Meeting of the Association for Computational Linguistics, pages 135–144,
Sofia, Bulgaria, August 4-9 2013. c�2013 Association for Computational Linguistics
</note>
<bodyText confidence="0.9727095">
widely used static transition systems.
2 Static vs. Dynamic Parsing
The notions of bottom-up and top-down parsing
strategies do not have a general mathematical defin-
ition; they are instead specified, often only inform-
ally, for individual families of grammar formal-
isms. In the context of dependency parsing, a pars-
ing strategy is called purely bottom-up if every
dependency h -+ d is constructed only after all
dependencies of the form d -+ i have been con-
structed. Here h -+ d denotes a dependency with
h the head node and d the dependent node. In con-
trast, a parsing strategy is called purely top-down
if h -+ d is constructed before any dependency of
the form d -+ i.
If we consider transition-based dependency pars-
ing (Nivre, 2008), the purely bottom-up strategy is
implemented by the arc-standard model of Nivre
(2004). After building a dependency h -+ d, this
model immediately removes from its stack node d,
preventing further attachment of dependents to this
node. A second popular parser, the arc-eager model
of Nivre (2003), instead adopts a mixed strategy.
In this model, a dependency h -+ d is constructed
using a purely bottom-up strategy if it represents a
left-arc, that is, if the dependent d is placed to the
left of the head h in the input string. In contrast, if
h -+ d represents a right-arc (defined symmetric-
ally), then this dependency is constructed before
any right-arc d -+ i (top-down) but after any left-
arc d -+ i (bottom-up).
What is important to notice about the above
transition-based parsers is that the adopted pars-
ing strategies are static. By this we mean that each
dependency is constructed according to some fixed
criterion, depending on structural conditions such
as the fact that the dependency represents a left or a
right arc. This should be contrasted with dynamic
parsing strategies in which several parsing options
are simultaneously available for the dependencies
being constructed.
In the context of left-to-right, transition-based
parsers, dynamic strategies are attractive for sev-
eral reasons. One argument is related to the well-
known PP-attachment problem, illustrated in Fig-
ure 1. Here we have to choose whether to attach
node P as a dependent of V (arc α2) or else as
a dependent of N1 (arc α3). The purely bottom-
up arc-standard model has to take a decision as
soon as N1 is placed into the stack. This is so
</bodyText>
<equation confidence="0.947879">
V N1 P N2
</equation>
<figureCaption confidence="0.9360035">
Figure 1: PP-attachment example, with dashed arcs
identifying two alternative choices.
</figureCaption>
<bodyText confidence="0.999446173913043">
because the construction of α1 excludes α3 from
the search space, while the alternative decision of
shifting P into the stack excludes α2. This is bad,
because the information about the correct attach-
ment could come from the lexical content of node P.
The arc-eager model performs slightly better, since
it can delay the decision up to the point in which α1
has been constructed and P is read from the buffer.
However, at this point it must make a commitment
and either construct α3 or pop N1 from the stack
(implicitly committing to α2) before N2 is read
from the buffer. In contrast with this scenario, in
the next sections we implement a dynamic parsing
strategy that allows a transition system to decide
between the attachments α2 and α3 after it has seen
all of the four nodes V, N1, P and N2.
Other additional advantages of dynamic parsing
strategies with respect to static strategies are re-
lated to the increase in the feature inventory that
we apply to parser states, and to the increase of
spurious ambiguity. However, these arguments are
more technical than the PP-attachment argument
above, and will be discussed later.
</bodyText>
<sectionHeader confidence="0.990333" genericHeader="method">
3 Dependency Parser
</sectionHeader>
<bodyText confidence="0.999733666666667">
In this section we present a novel transition-based
parser for projective dependency trees, implement-
ing a dynamic parsing strategy.
</bodyText>
<subsectionHeader confidence="0.996232">
3.1 Preliminaries
</subsectionHeader>
<bodyText confidence="0.970295454545455">
For non-negative integers i and j with i &lt; j, we
write [i, j] to denote the set {i, i+1,... , j}. When
i &gt; j, [i, j] is the empty set.
We represent an input sentence as a string w =
w0 · · · wn, n &gt; 1, where token w0 is a special
root symbol and, for each i E [1, n], token wi =
(i, ai, ti) encodes a lexical element ai and a part-of-
speech tag ti associated with the i-th word in the
sentence.
A dependency tree for w is a directed, ordered
tree Tw = (Vw, Aw), where Vw = {wi  |i E
</bodyText>
<equation confidence="0.755456583333333">
α2
α1
α3 α4
136
(a) (b)
w4
w2 w5 w7
w1 w3 w6
T
T&apos;
T
T&apos;
</equation>
<figureCaption confidence="0.9721105">
Figure 2: A dependency tree with left spine
(w4, w2, w1) and right spine (w4, w7).
</figureCaption>
<bodyText confidence="0.996131933333333">
[0, n]} is the set of nodes, and Aw C Vw x Vw is
the set of arcs. Arc (wi, wj) encodes a dependency
wi -+ wj. A sample dependency tree (excluding
w0) is displayed in Figure 2. If (wi, wj) E Aw for
j &lt; i, we say that wj is a left child of wi; a right
child is defined in a symmetrical way.
The left spine of Tw is an ordered sequence
(u1, ... , up) with p &gt; 1 and ui E Vw for i E [1,p],
consisting of all nodes in a descending path from
the root of Tw taking the leftmost child node at
each step. More formally, u1 is the root node of Tw
and ui is the leftmost child of ui_1, for i E [2, p].
The right spine of Tw is defined symmetrically;
see again Figure 2. Note that the left and the right
spines share the root node and no other node.
</bodyText>
<subsectionHeader confidence="0.9998">
3.2 Basic Idea
</subsectionHeader>
<bodyText confidence="0.999946636363636">
Transition-based dependency parsers use a stack
data structure, where each stack element is associ-
ated with a tree spanning some (contiguous) sub-
string of the input w. The parser can combine
two trees T and T&apos; through attachment operations,
called left-arc or right-arc, under the condition that
T and T&apos; appear at the two topmost positions in
the stack. Crucially, only the roots of T and T&apos; are
available for attachment; see Figure 3(a).
In contrast, a stack element in our parser records
the entire left spine and right spine of the associated
tree. This allows us to extend the inventory of the
attachment operations of the parser by including
the attachment of tree T as a dependent of any node
in the left or in the right spine of a second tree T&apos;,
provided that this does not violate projectivity.1
See Figure 3(b) for an example.
The new parser implements a mix of bottom-up
and top-down strategies, since after any of the at-
tachments in Figure 3(b) is performed, additional
dependencies can still be created for the root of T.
Furthermore, the new parsing strategy is clearly dy-
</bodyText>
<footnote confidence="0.9602705">
1A dependency tree for w is projective if every subtree has
a contiguous yield in w.
</footnote>
<figureCaption confidence="0.988560333333333">
Figure 3: Left-arc attachment of T to T&apos; in case
of (a) standard transition-based parsers and (b) our
parser.
</figureCaption>
<bodyText confidence="0.999924117647059">
namic, due to the free choice in the timing for these
attachments. The new strategy is more powerful
than the strategy of the arc-eager model, since we
can use top-down parsing at left arcs, which is not
allowed in arc-eager parsing, and we do not have
the restrictions of parsing right arcs (h -+ d) before
the attachment of right dependents at node d.
To conclude this section, let us resume our dis-
cussion of the PP-attachment example in Figure 1.
We observe that the new parsing strategy allows the
construction of a tree T&apos; consisting of the only de-
pendency V -+ N1 and a tree T, placed at the right
of T&apos;, consisting of the only dependency P -+ N2.
Since the right spine of T&apos; consists of nodes V
and N1, we can freely choose between attachment
V -+ P and attachment N1 -+ P. Note that this is
done after we have seen node N2, as desired.
</bodyText>
<subsectionHeader confidence="0.99593">
3.3 Transition-based Parser
</subsectionHeader>
<bodyText confidence="0.991566894736842">
We assume the reader is familiar with the formal
framework of transition-based dependency parsing
originally introduced by Nivre (2003); see Nivre
(2008) for an introduction. To keep the notation at
a simple level, we only discuss here the unlabeled
version of our parser; however, a labeled extension
is used in §5 for our experiments.
Our transition-based parser uses a stack data
structure to store partial parses for the input string
w. We represent the stack as an ordered sequence
σ = [σd, . . . , σ1], d &gt; 0, of stack elements, with
the topmost element placed at the right. When d =
0, we have the empty stack σ = []. Sometimes we
use the vertical bar to denote the append operator
for σ, and write σ = σ&apos;|σ1 to indicate that σ1 is the
topmost element of σ.
A stack element is a pair
σk = ((uk,1, ... , uk,p), (vk,1, ... , vk,q))
where the ordered sequences (uk,1, ... , uk,p) and
</bodyText>
<page confidence="0.989346">
137
</page>
<bodyText confidence="0.994928735294118">
(vk,1, ... , vk,q) are the left and the right spines, re-
spectively, of the tree associated with σk. Recall
that uk,1 = vk,1, since the root node of the associ-
ated tree is shared by the two spines.
The parser also uses a buffer to store the por-
tion of the input string still to be processed. We
represent the buffer as an ordered sequence β =
[wi, ... , wn], i &gt; 0, of tokens from w, with the
first element placed at the left. Note that β always
represents a (non-necessarily proper) suffix of w.
When i &gt; n, we have the empty buffer β = [].
Sometimes we use the vertical bar to denote the
append operator for β, and write β = wi|β0 to in-
dicate that wi is the first token of β; consequently,
we have β0 = [wi+1, ... , wn].
When processing w, the parser reaches several
states, technically called configurations. A con-
figuration of the parser relative to w is a triple
c = (σ, β, A), where σ and β are a stack and
a buffer, respectively, and A C_ Vw x Vw is a
set of arcs. The initial configuration for w is
([], [w0, ... , wn], 0). The set of terminal config-
urations consists of all configurations of the form
([σ1], [], A), where σ1 is associated with a tree hav-
ing root w0, that is, u1,1 = v1,1 = w0, and A is any
set of arcs.
The core of a transition-based parser is the set
of its transitions. Each transition is a binary rela-
tion defined over the set of configurations of the
parser. Since the set of configurations is infinite,
a transition is infinite as well, when viewed as a
set. However, transitions can always be specified
by some finite means. Our parser uses three types
of transitions, defined in what follows.
</bodyText>
<listItem confidence="0.9796964">
• SHIFT, or sh for short. This transition re-
moves the first node from the buffer and
pushes into the stack a new element, consist-
ing of the left and right spines of the associ-
ated tree. More formally
(σ, wi|β, A) �_sh (σ|((wi), (wi)),β, A)
• LEFT-ARCk, k &gt; 1, or lak for short. Let h
be the k-th node in the left spine of the top-
most tree in the stack, and let d be the root
node of the second topmost tree in the stack.
</listItem>
<bodyText confidence="0.91445125">
This transition creates a new arc h -+ d. Fur-
thermore, the two topmost stack elements are
replaced by a new element associated with the
tree resulting from the h -+ d attachment. The
transition does not advance with the reading
of the buffer. More formally
(σ0|σ2|σ1, β, A) �-lak (σ0|σla, β, A U {h -+ d})
where
</bodyText>
<equation confidence="0.9994165">
σ1 = ((u1,1, ... , u1,p), (v1,1, ... , v1,q)) ,
σ2 = ((u2,1, ... , u2,r), (v2,1, ... , v2,s)) ,
σla = ((u1,1, ... , u1,k, u2,1, ... ,u2,r),
(v1,1, ... , v1,q)) ,
</equation>
<bodyText confidence="0.933954">
and where we have set h = u1,k and d = u2,1.
</bodyText>
<listItem confidence="0.999706666666667">
• RIGHT-ARCk, k &gt; 1, or rak for short. This
transition is defined symmetrically with re-
spect to lak. We have
</listItem>
<bodyText confidence="0.926283">
(σ0|σ2|σ1, β, A) Irak (σ0|σra, β, A U {h -+ d})
where σ1 and σ2 are as in the lak case,
</bodyText>
<equation confidence="0.539601">
σra = ((u2,1,. . . , u2,r),
(v2,1, ... , v2,k, v1,1, ... , v1,q)) ,
</equation>
<bodyText confidence="0.999852954545455">
and we have set h = v2,k and d = v1,1.
Transitions lak and rak are parametric in k,
where k is bounded by the length of the input string
and not by a fixed constant (but see also the experi-
mental findings in §5). Thus our system uses an un-
bounded number of transition relations, which has
an apparent disadvantage for learning algorithms.
We will get back to this problem in §4.3.
A complete computation relative to w is a se-
quence of configurations c1, c2,. . . , ct, t &gt; 1, such
that c1 and ct are initial and final configurations,
respectively, and for each i E [2, t], ci is produced
by the application of some transition to ci−1. It is
not difficult to see that the transition-based parser
specified above is sound, meaning that the set of
arcs constructed in any complete computation on
w is always a dependency tree for w. The parser
is also complete, meaning that every (projective)
dependency tree for w is constructed by some com-
plete computation on w. A mathematical proof of
this statement is beyond the scope of this paper,
and will not be provided here.
</bodyText>
<subsectionHeader confidence="0.962622">
3.4 Deterministic Parsing Algorithm
</subsectionHeader>
<bodyText confidence="0.9997315">
The transition-based parser of the previous sec-
tion is a nondeterministic device, since several
transitions can be applied to a given configuration.
This might result in several complete computations
</bodyText>
<page confidence="0.989254">
138
</page>
<bodyText confidence="0.718762666666667">
Algorithm 1 Parsing Algorithm
Input: string w = w0 · · · wn, function score()
Output: dependency tree Tw
</bodyText>
<equation confidence="0.900115090909091">
c = (Q, β, A) +- ([], [w0, ... , wn], 0)
while |Q |&gt; 1 V |β |&gt; 0 do
while |Q |&lt; 2 do
update c with sh
p +- length of left spine of Q1
s +- length of right spine of Q2
T +- flak  |k E [1,p]} U
frak  |k E [1, s]} U fsh}
bestT +- argmaxtcT score(t, c)
update c with bestT
return Tw = (Vw, A)
</equation>
<bodyText confidence="0.999768807692307">
for w. We present here an algorithm that runs
the parser in pseudo-deterministic mode, greed-
ily choosing at each configuration the transition
that maximizes some score function. Algorithm 1
takes as input a string w and a scoring function
score() defined over parser transitions and parser
configurations. The scoring function will be the
subject of §4 and is not discussed here. The output
of the parser is a dependency tree for w.
At each iteration the algorithm checks whether
there are at least two elements in the stack and, if
this is not the case, it shifts elements from the buffer
to the stack. Then the algorithm uses the function
score() to evaluate all transitions that can be ap-
plied under the current configuration c = (Q, β, A),
and it applies the transition with the highest score,
updating the current configuration.
To parse a sentence of length n (excluding the
root token w0) the algorithm applies exactly 2n + 1
transitions. In the worst case, each transition ap-
plication involves 1 + p + s transition evaluations.
We therefore conclude that the algorithm always
reaches a configuration with an empty buffer and a
stack which contains only one element. Then the al-
gorithm stops, returning the dependency tree whose
arc set is defined as in the current configuration.
</bodyText>
<sectionHeader confidence="0.98862" genericHeader="method">
4 Model and Training
</sectionHeader>
<bodyText confidence="0.9995365">
In this section we introduce the adopted learning
algorithm and discuss the model parameters.
</bodyText>
<subsectionHeader confidence="0.99614">
4.1 Learning Algorithm
</subsectionHeader>
<bodyText confidence="0.8563076">
We use a linear model for the score function in
Algorithm 1, and define score(t, c) = cv · φ(t, c).
Here cv is a weight vector and function φ provides
Algorithm 2 Learning Algorithm
Input: pair (w = w0 · · · wn, Ag), vector cv
</bodyText>
<equation confidence="0.94602125">
Output: vector cv
c = (Q, β, A) +- ([], [w0, ... , wn], 0)
while |Q |&gt; 1 V |β |&gt; 0 do
while |Q |&lt; 2 do
update c with SHIFT
p +- length of left spine of Q1
s +- length of right spine of Q2
T +- flak  |k E [1,p]} U
frak  |k E [1, s]} U fsh}
bestT +- argmaxtcT score(t, c)
bestCorrectT +-
argmaxtcT∧isCorrect(t) score(t, c)
if bestT =� bestCorrectT then
cv +- cv − φ(bestT, c)
+φ(bestCorrectT, c)
update c with bestCorrectT
</equation>
<bodyText confidence="0.999742461538461">
a feature vector representation for a transition t ap-
plying to a configuration c. The function φ will be
discussed at length in §4.3. The vector cv is trained
using the perceptron algorithm in combination with
the averaging method to avoid overfitting; see Fre-
und and Schapire (1999) and Collins and Duffy
(2002) for details.
The training data set consists of pairs (w, Ag),
where w is a sentence and Ag is the set of arcs
of the gold (desired) dependency tree for w. At
training time, each pair (w, Ag) is processed using
the learning algorithm described as Algorithm 2.
The algorithm is based on the notions of correct and
incorrect transitions, discussed at length in §4.2.
Algorithm 2 parses w following Algorithm 1 and
using the current cv, until the highest score selec-
ted transition bestT is incorrect according to Ag.
When this happens, cv is updated by decreasing the
weights of the features associated with the incorrect
bestT and by increasing the weights of the features
associated with the transition bestCorrectT having
the highest score among all possible correct trans-
itions. After each update, the learning algorithm
resumes parsing from the current configuration by
applying bestCorrectT, and moves on using the
updated weights.
</bodyText>
<subsectionHeader confidence="0.991067">
4.2 Correct and Incorrect Transitions
</subsectionHeader>
<bodyText confidence="0.999928">
Standard transition-based dependency parsers are
trained by associating each gold tree with a canon-
ical complete computation. This means that, for
each configuration of interest, only one transition
</bodyText>
<page confidence="0.974698">
139
</page>
<figure confidence="0.936288416666667">
σ2 σ1 b1
(a)
σ2 σ1 b1
(b)
(c)
(d)
� � �
σ2 σ1
bi
� � �
σ2 σ1
bi
</figure>
<figureCaption confidence="0.884853666666667">
Figure 4: Graphical representation of configura-
tions; drawn arcs are in Ay but have not yet been
added to the configuration. Transition sh is incor-
</figureCaption>
<bodyText confidence="0.960018909090909">
rect for configuration (a) and (b); sh and ra1 are
correct for (c); sh and la1 are correct for (d).
leading to the gold tree is considered as correct. In
this paper we depart from such a methodology, and
follow Goldberg and Nivre (2012) in allowing more
than one correct transition for each configuration,
as explained in detail below.
Let (w, Ay) be a pair in the training set. In §3.3
we have mentioned that there is always a complete
computation on w that results in the construction
of the set Ay. In general, there might be more than
one computation for Ay. This means that the parser
shows spurious ambiguity.
Observe that all complete computations for Ay
share the same initial configuration cI,w and final
configuration cF,A9. Consider now the set C(w) of
all configurations c that are reachable from cI,w,
meaning that there exists a sequence of transitions
that takes the parser from cI,w to c. A configuration
c E C(w) is correct for Ay if cF,A. is reachable
from c; otherwise, c is incorrect for Ay.
Let c E C(w) be a correct configuration for Ay.
A transition t is correct for c and Ay if c at c0
and c0 is correct for Ay; otherwise, t is incorrect
for c and Ay. The next lemma provides a charac-
terization of correct and incorrect transitions; see
Figure 4 for examples. We use this characterization
in the implementation of predicate isCorrect() in
Algorithm 2.
Lemma 1 Let (w, Ay) be a pair in the training set
and let c E C(w) with c = (σ,β, A) be a correct
configuration for Ay. Let also v1,k, k E [1, q], be
the nodes in the right spine of σ1.
</bodyText>
<listItem confidence="0.894389285714286">
(i) lak and rak are incorrect for c and Ay if and
only if they create a new arc (h -+ d) E� Ay;
(ii) sh is incorrect for c and Ay if and only if the
following conditions are both satisfied:
(a) there exists an arc (h -+ d) in Ay such
that h is in σ and d = v1,1;
(b) there is no arc (h0 -+ d0) in Ay with
</listItem>
<equation confidence="0.962639">
h0 = v1,k, k E [1, q], and d0 in β. ✷
</equation>
<bodyText confidence="0.999388288888889">
PROOF (SKETCH) To prove part (i) we focus on
transition rak; a similar argument applies to lak.
The ‘if’ statement in part (i) is self-evident.
‘Only if’. Assuming that transition rak creates
a new arc (h -+ d) E Ay, we argue that from con-
figuration c0 with c arek c0 we can still reach the
final configuration associated with Ay. We have
h = v2,k and d = u1,1. The tree fragments in σ
with roots v2,k+1 and u1,1 must be adjacent siblings
in the tree associated with Ay, since c is a correct
configuration for Ay and (v2,k -+ u1,1) E Ay.
This means that each of the nodes v2,k+1, . . . , v2,s
in the right spine in σ2 in c must have already ac-
quired all of its right dependents, since the tree is
projective. Therefore it is safe for transition rak to
eliminate the nodes v2,k+1, . . . , v2,s from the right
spine in σ2.
We now deal with part (ii). Let c ash c0, c0 =
(σ0, β0, A).
‘If’. Assuming (ii)a and (ii)b, we argue that c0 is
incorrect. Node d is the head of σ02. Arc (h -+ d) is
not in A, and the only way we could create (h -+ d)
from c0 is by reaching a new configuration with d
in the topmost stack symbol, which amounts to say
that σ01 can be reduced by a correct transition. Node
h is in some σ0i, i &gt; 2, by (ii)a. Then reduction of
σ01 implies that the root of σ01 is reachable from the
root of σ02, which contradicts (ii)b.
‘Only if’. Assuming (ii)a is not satisfied, we
argue that sh is correct for c and Ay. There must
be an arc (h -+ d) not in A with d = v1,1 and h is
some token wi in β. From stack σ0 = σ00|σ02|σ01 it
is always possible to construct (h -+ d) consuming
the substring of β up to wi and ending up with
stack σ00|σ,d, where σ,d is a stack element with
root wi. From there, the parser can move on to
the final configuration cF,A. . A similar argument
applies if we assume that (ii)b is not satisfied. ■
From condition (i) in Lemma 1 and from the fact
that there are no cycles in Ay, it follows that there
is at most one correct transition among the trans-
itions of type lak or rak. From condition (ii) in the
lemma we can also see that the existence of a cor-
rect transition of type lak or rak for some configura-
tion does not imply that the sh transition is incorrect
</bodyText>
<page confidence="0.993066">
140
</page>
<bodyText confidence="0.999981956521739">
for the same configuration; see Figures 4(c,d) for
examples. It follows that for a correct configuration
there might be at most 2 correct transitions. In our
training experiments for English in §5 we observe 2
correct transitions for 42% of the reached configur-
ations. This nondeterminism is a byproduct of the
adopted dynamic parsing strategy, and eventually
leads to the spurious ambiguity of the parser.
As already mentioned, we do not impose any ca-
nonical form on complete computations that would
hardwire a preference for some correct transition
and get rid of spurious ambiguity. Following Gold-
berg and Nivre (2012), we instead regard spurious
ambiguity as an additional resource of our pars-
ing strategy. Our main goal is that the training
algorithm learns to prefer a sh transition in a con-
figuration that does not provide enough information
for the choice of the correct arc. In the context of
dependency parsing, the strategy of delaying arc
construction when the current configuration is not
informative is called the easyfirst strategy, and
has been first explored by Goldberg and Elhadad
(2010).
</bodyText>
<subsectionHeader confidence="0.999043">
4.3 Feature Extraction
</subsectionHeader>
<bodyText confidence="0.999969114285715">
In existing transition-based parsers a set of atomic
features is statically defined and extracted from
each configuration. These features are then com-
bined together into complex features, according to
some feature template, and joined with the avail-
able transition types. This is not possible in our
system, since the number of transitions lak and rak
is not bounded by a constant. Furthermore, it is not
meaningful to associate transitions lak and rak, for
any k ≥ 1, always with the same features, since
the constructed arcs impinge on nodes at differ-
ent depths in the involved spines. It seems indeed
more significant to extract information that is local
to the arc h → d being constructed by each trans-
ition, such as for instance the grandparent and the
great grandparent nodes of d. This is possible if
we introduce a higher level of abstraction than in
existing transition-based parsers. We remark here
that this abstraction also makes the feature repres-
entation more similar to the ones typically found
in graph-based parsers, which are centered on arcs
or subgraphs of the dependency tree.
We index the nodes in the stack a relative to
the head node of the arc being constructed, in
case of the transitions lak or rak, or else relative
to the root node of a1, in case of the transition
sh. More precisely, let c = (a, β, A) be a con-
figuration and let t be a transition. We define
the context of c and t as the tuple C(c, t) =
(s3, s2, s1, q1, q2, gp, gg), whose components are
placeholders for word tokens in a or in β. All these
placeholders are specified in Table 1, for each c and
t. Figure 5 shows an example of feature extraction
for the displayed configuration c = (a, β, A) and
the transition la2. In this case we have s3 = u3,1,
</bodyText>
<equation confidence="0.848484">
s2 = u2,1, s1 = u1,2, q1 = gp = u1,1, q2 = b1;
</equation>
<bodyText confidence="0.999400666666667">
gg = none because the head of gp is not available
in c.
Note that in Table 1 placeholders are dynamic-
ally assigned in such a way that s1 and s2 refer to
the nodes in the constructed arc h → d, and gp, gg
refer to the grandparent and the great grandparent
nodes, respectively, of d. Furthermore, the node
assigned to s3 is the parent node of s2, if such a
node is defined; otherwise, the node assigned to
s3 is the root of the tree fragment in the stack un-
derneath a2. Symmetrically, placeholders q1 and
q2 refer to the parent and grandparent nodes of s1,
respectively, when these nodes are defined; other-
wise, these placeholders get assigned tokens from
the buffer. See again Figure 5.
Finally, from the placeholders in C(c, t) we ex-
tract a standard set of atomic features and their
complex combinations, to define the function φ.
Our feature template is an extended version of the
feature template of Zhang and Nivre (2011), ori-
ginally developed for the arc-eager model. The
extension is obtained by adding top-down features
for left-arcs (based on placeholders gp and gg),
and by adding right child features for the first stack
element. The latter group of features is usually ex-
ploited for the arc-standard model, but is undefined
for the arc-eager model.
</bodyText>
<sectionHeader confidence="0.994793" genericHeader="method">
5 Experimental Assessment
</sectionHeader>
<bodyText confidence="0.999859416666667">
Performance evaluation is carried out on the Penn
Treebank (Marcus et al., 1993) converted to Stan-
ford basic dependencies (De Marneffe et al., 2006).
We use sections 2-21 for training, 22 as develop-
ment set, and 23 as test set. The part-of-speech
tags are assigned by an automatic tagger with ac-
curacy 97.1%. The tagger used on the training set
is trained on the same data set by using four-way
jackknifing, while the tagger used on the develop-
ment and test sets is trained on all the training set.
We train an arc-labeled version of our parser.
In the first three lines of Table 2 we compare
</bodyText>
<page confidence="0.991456">
141
</page>
<table confidence="0.974840222222222">
context sh k = 1 lak k = 1 rak
placeholder k = 2 k &gt; 2 k = 2 k &gt; 2
s1 u1,1 = v1,1 u1,k u1,1 = v1,1
s2 u2,1 = v2,1 u2,1 = v2,1 v2,k
s3 u3,1 = v3,1 u3,1 = v3,1 u3,1 = v3,1 v2,k−1
q1 b1 b1 u1,k−1 b1
q2 b2 b2 b1 u1,k−2 b2
9p none none u1,k−1 none v2,k−1
99 none none none u1,k−2 none none v2,k−2
</table>
<tableCaption confidence="0.999783">
Table 1: Definition of C(c, t) = (s3, s2, s1, q1, q2, gp, gg), for c = (σ&apos;|σ3|σ2|σ1, b1|b2|β, A) and t of type
</tableCaption>
<bodyText confidence="0.989359">
sh or lak, rak, k ≥ 1. Symbols uj,k and vj,k are the k-th nodes in the left and right spines, respectively, of
stack element σj, with uj,1 = vj,1 being the shared root of σj; none is an artificial element used when
some context’s placeholder is not available.
</bodyText>
<equation confidence="0.981374083333333">
stack σ buffer β
· · ·
b1 b2 b3
· · ·
u3,1 = v3,1
v3,2
u2,1 = v2,1
u2,2 v2,2
la2 u1,1 = v1,1
u1,2 v1,2
v2,3 u1,3 v1,3
s3 s2 s1 q1=gp q2
</equation>
<bodyText confidence="0.705859">
context extracted for la2
</bodyText>
<figureCaption confidence="0.99869">
Figure 5: Extraction of atomic features for context C(c, la2) = (s3, s2, s1, q1, q2, gp, gg), c = (σ, β, A).
</figureCaption>
<table confidence="0.996219333333333">
parser iter UAS LAS UEM
arc-standard 23 90.02 87.69 38.33
arc-eager 12 90.18 87.83 40.02
this work 30 91.33 89.16 42.38
arc-standard + easy-first 21 90.49 88.22 39.61
arc-standard + spine 27 90.44 88.23 40.27
</table>
<tableCaption confidence="0.8231585">
Table 2: Accuracy on test set, excluding punc-
tuation, for unlabeled attachment score (UAS),
labeled attachment score (LAS), unlabeled exact
match (UEM).
</tableCaption>
<bodyText confidence="0.999964682926829">
the accuracy of our parser against our implementa-
tion of the arc-eager and arc-standard parsers. For
the arc-eager parser, we use the feature template
of Zhang and Nivre (2011). The same template is
adapted to the arc-standard parser, by removing the
top-down parent features and by adding the right
child features for the first stack element. It turns out
that our feature template, described in §4.3, is the
exact merge of the templates used for the arc-eager
and the arc-standard parsers.
We train all parsers up to 30 iterations, and for
each parser we select the weight vector ω~ from the
iteration with the best accuracy on the development
set. All our parsers attach the root node at the end
of the parsing process, following the ‘None’ ap-
proach discussed by Ballesteros and Nivre (2013).
Punctuation is excluded in all evaluation metrics.
Considering UAS, our parser provides an improve-
ment of 1.15 over the arc-eager parser and an im-
provement of 1.31 over the arc-standard parser, that
is an error reduction of —12% and —13%, respect-
ively. Considering LAS, we achieve improvements
of 1.33 and 1.47, with an error reduction of —11%
and —12%, over the arc-eager and the arc-standard
parsers, respectively.
We speculate that the observed improvement of
our parser can be ascribed to two distinct com-
ponents. The first component is the left-/right-
spine representation for stack elements, introduced
in §3.3. The second component is the easy-first
strategy, implemented on the basis of the spurious
ambiguity of our parser and the definition of cor-
rect/incorrect transitions in §4.2. In this perspective,
we observe that our parser can indeed be viewed as
an arc-standard model augmented with (i) the spine
representation, and (ii) the easy-first strategy. More
specifically, (i) generalizes the la/ra transitions to
the lak/rak transitions, introducing a top-down com-
ponent into the purely bottom-up arc-standard. On
the other hand, (ii) drops the limitation of canonical
computations for the arc-standard, and leverages
</bodyText>
<page confidence="0.993794">
142
</page>
<bodyText confidence="0.999447019230769">
on the spurious ambiguity of the parser to enlarge
the search space.
The two components above are mutually inde-
pendent, meaning that we can individually imple-
ment each component on top of an arc-standard
model. More precisely, the arc-standard + spine
model uses the transitions lak/rak but retains the
definition of canonical computation, defined by ap-
plying each lak/rak transition as soon as possible.
On the other hand, the arc-standard + easy-first
model retains the original la/ra transitions but is
trained allowing any correct transition at each con-
figuration. In this case the characterization of cor-
rect and incorrect configurations in Lemma 1 has
been adapted to transitions la/ra, taking into ac-
count the bottom-up constraint.
With the purpose of incremental comparison, we
report accuracy results for the two ‘incremental’
models in the last two lines of Table 2. Analyzing
these results, and comparing with the plain arc-
standard, we see that the spine representation and
the easy-first strategy individually improve accur-
acy. Moreover, their combination into our model
(third line of Table 2) works very well, with an
overall improvement larger than the sum of the
individual contributions.
We now turn to a computational analysis. At
each iteration our parser evaluates a number of
transitions bounded by -y + 1, with -y the maximum
value of the sum of the lengths of the left spine in U1
and of the right spine in U2. Quantity -y is bounded
by the length n of the input sentence. Since the
parser applies exactly 2n + 1 transitions, worst
case running time is O(n2). We have computed
the average value of -y on our English data set,
resulting in 2.98 (variance 2.15) for training set,
and 2.95 (variance 1.96) for development set. We
conclude that, in the expected case, running time is
O(n), with a slow down constant which is rather
small, in comparison to standard transition-based
parsers. Accordingly, when running our parser
against our implementation of the arc-eager and
arc-standard models, we measured a slow-down of
2.8 and 2.2, respectively. Besides the change in
representation, this slow-down is also due to the
increase in the number of features in our system.
We have also checked the worst case value of -y in
our data set. Interestingly, we have seen that for
strings of length smaller than 40 this value linearly
grows with n, and for longer strings the growth
stops, with a maximum worst case observed value
of 22.
</bodyText>
<sectionHeader confidence="0.983717" genericHeader="conclusions">
6 Concluding Remarks
</sectionHeader>
<bodyText confidence="0.999994138888889">
We have presented a novel transition-based parser
using a dynamic parsing strategy, which achieves
a ∼12% error reduction in unlabeled attachment
score over the static arc-eager strategy and even
more over the (equally static) arc-standard strategy,
when evaluated on English.
The idea of representing the right spine of a
tree within the stack elements of a shift-reduce
device is quite old in parsing, predating empirical
approaches. It has been mainly exploited to solve
the PP-attachment problem, motivated by psycho-
linguistic models. The same representation is also
adopted in applications of discourse parsing, where
right spines are usually called right frontiers; see
for instance Subba and Di Eugenio (2009). In
the context of transition-based dependency parsers,
right spines have also been exploited by Kitagawa
and Tanaka-Ishii (2010) to decide where to attach
the next word from the buffer. In this paper we
have generalized their approach by introducing the
symmetrical notion of left spine, and by allowing
attachment of full trees rather than attachment of a
single word.2
Since one can regard a spine as a stack in it-
self, whose elements are tree nodes, our model is
reminiscent of the embedded pushdown automata
of Schabes and Vijay-Shanker (1990), used to parse
tree adjoining grammars (Joshi and Schabes, 1997)
and exploiting a stack of stacks. However, by im-
posing projectivity, we do not use the extra-power
of the latter class.
An interesting line of future research is to com-
bine our dynamic parsing strategy with a training
method that allows the parser to explore transitions
that apply to incorrect configurations, as in Gold-
berg and Nivre (2012).
</bodyText>
<sectionHeader confidence="0.998227" genericHeader="acknowledgments">
Acknowledgments
</sectionHeader>
<bodyText confidence="0.999407333333333">
We wish to thank Liang Huang and Marco Kuhl-
mann for discussion related to the ideas reported in
this paper, and the anonymous reviewers for their
useful suggestions. The second author has been
partially supported by MIUR under project PRIN
No. 2010LYA9RH 006.
</bodyText>
<footnote confidence="0.894179">
2Accuracy comparison of our work with Kitagawa and
Tanaka-Ishii (2010) is not meaningful, since these authors
have evaluated their system on the same data set but based on
gold part-of-speech tags (personal communication).
</footnote>
<page confidence="0.998782">
143
</page>
<sectionHeader confidence="0.995846" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999734912621359">
Giuseppe Attardi. 2006. Experiments with a multil-
anguage non-projective dependency parser. In Pro-
ceedings of the 10th Conference on Computational
Natural Language Learning (CoNLL), pages 166–
170.
Miguel Ballesteros and Joakim Nivre. 2013. Going
to the roots of dependency parsing. Computational
Linguistics, 39(1):5–13.
Bernd Bohnet and Joakim Nivre. 2012. A transition-
based system for joint part-of-speech tagging and
labeled non-projective dependency parsing. In Pro-
ceedings of the 2012 Joint Conference on Empirical
Methods in Natural Language Processing and Com-
putational Natural Language Learning, pages 1455–
1465.
Jinho D. Choi and Martha Palmer. 2011. Getting the
most out of transition-based dependency parsing. In
Proceedings of the 49th Annual Meeting of the Asso-
ciation for Computational Linguistics (ACL), pages
687–692.
Michael Collins and Nigel Duffy. 2002. New ranking
algorithms for parsing and tagging: Kernels over dis-
crete structures, and the voted perceptron. In Pro-
ceedings of the 40th Annual Meeting of the Asso-
ciation for Computational Linguistics (ACL), pages
263–270, Philadephia, Pennsylvania.
Marie-Catherine De Marneffe, Bill MacCartney, and
Christopher D. Manning. 2006. Generating typed
dependency parses from phrase structure parses. In
Proceedings of the 5th International Conference
on Language Resources and Evaluation (LREC),
volume 6, pages 449–454.
Yoav Freund and Robert E. Schapire. 1999. Large
margin classification using the perceptron algorithm.
Machine Learning, 37(3):277–296, December.
Yoav Goldberg and Michael Elhadad. 2010. An ef-
ficient algorithm for easy-first non-directional de-
pendency parsing. In Proceedings of Human Lan-
guage Technologies: The 2010 Annual Conference
of the North American Chapter of the Association
for Computational Linguistics (NAACL), pages 742–
750, Los Angeles, USA.
Yoav Goldberg and Joakim Nivre. 2012. A dynamic or-
acle for arc-eager dependency parsing. In Proceed-
ings of the 24th International Conference on Com-
putational Linguistics (COLING), pages 959–976.
Aravind K. Joshi and Yves Schabes. 1997. Tree-
Adjoining Grammars. In Grzegorz Rozenberg and
Arto Salomaa, editors, Handbook of Formal Lan-
guages, volume 3, pages 69–123. Springer.
Kotaro Kitagawa and Kumiko Tanaka-Ishii. 2010.
Tree-based deterministic dependency parsing — an
application to Nivre’s method —. In Proceedings of
the 48th Annual Meeting of the Association for Com-
putational Linguistics (ACL) Short Papers, pages
189–193.
Mitchell P. Marcus, Beatrice Santorini, and Mary Ann
Marcinkiewicz. 1993. Building a large annotated
corpus of English: The Penn Treebank. Computa-
tional Linguistics, 19:313–330.
Ryan McDonald and Joakim Nivre. 2007. Character-
izing the errors of data-driven dependency parsing
models. In Proceedings of the 2007 Joint Confer-
ence on Empirical Methods in Natural Language
Processing and Computational Natural Language
Learning (EMNLP-CoNLL), pages 122–131.
Joakim Nivre. 2003. An efficient algorithm for pro-
jective dependency parsing. In Proceedings of the
Eighth International Workshop on Parsing Techno-
logies (IWPT), pages 149–160, Nancy, France.
Joakim Nivre. 2004. Incrementality in deterministic
dependency parsing. In Workshop on Incremental
Parsing: Bringing Engineering and Cognition To-
gether, pages 50–57, Barcelona, Spain.
Joakim Nivre. 2008. Algorithms for deterministic in-
cremental dependency parsing. Computational Lin-
guistics, 34(4):513–553.
Yves Schabes and K. Vijay-Shanker. 1990. Determ-
inistic left to right parsing of tree adjoining lan-
guages. In Proceedings of the 28th annual meet-
ing of the Association for Computational Linguistics
(ACL), pages 276–283, Pittsburgh, Pennsylvania.
Rajen Subba and Barbara Di Eugenio. 2009. An effect-
ive discourse parser that uses rich linguistic inform-
ation. In Proceedings of Human Language Techno-
logies: The 2009 Annual Conference of the North
American Chapter of the Association for Computa-
tional Linguistics, pages 566–574.
Hiroyasu Yamada and Yuji Matsumoto. 2003. Stat-
istical dependency analysis with support vector ma-
chines. In Proceedings of the 8th International
Workshop on Parsing Technologies (IWPT), pages
195–206.
Yue Zhang and Stephen Clark. 2008. A tale of two
parsers: Investigating and combining graph-based
and transition-based dependency parsing. In Pro-
ceedings of the Conference on Empirical Methods in
Natural Language Processing (EMNLP), pages 562–
571.
Yue Zhang and Joakim Nivre. 2011. Transition-based
parsing with rich non-local features. In Proceedings
of the 49th Annual Meeting of the Association for
Computational Linguistics (ACL), pages 188–193.
</reference>
<page confidence="0.998569">
144
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.218035">
<title confidence="0.9989245">A Transition-Based Dependency Using a Dynamic Parsing Strategy</title>
<author confidence="0.996849">Francesco</author>
<affiliation confidence="0.907675333333333">Department Information University of Padua, Italy</affiliation>
<email confidence="0.99521">sartorio@dei.unipd.it</email>
<author confidence="0.999753">Giorgio Satta</author>
<affiliation confidence="0.9952695">Department of Information Engineering</affiliation>
<address confidence="0.743945">University of Padua, Italy</address>
<email confidence="0.997756">satta@dei.unipd.it</email>
<author confidence="0.464086">Joakim</author>
<affiliation confidence="0.989528333333333">Department Linguistics and Uppsala University, Sweden</affiliation>
<email confidence="0.979718">joakim.nivre@lingfil.uu.se</email>
<abstract confidence="0.993114">We present a novel transition-based, greedy dependency parser which implements a flexible mix of bottom-up and top-down strategies. The new strategy allows the parser to postpone difficult decisions until the relevant information becomes available. novel parser has a error reduction in unlabeled attachment score over an arc-eager parser, with a slow-down factor of 2.8.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Giuseppe Attardi</author>
</authors>
<title>Experiments with a multilanguage non-projective dependency parser.</title>
<date>2006</date>
<booktitle>In Proceedings of the 10th Conference on Computational Natural Language Learning (CoNLL),</booktitle>
<pages>166--170</pages>
<contexts>
<context position="1569" citStr="Attardi (2006)" startWordPosition="215" endWordPosition="216">he increased availability of dependency treebanks and the perceived usefulness of dependency structures as an interface to downstream applications, but a very important reason is also the high efficiency offered by dependency parsers, enabling web-scale parsing with high throughput. The most efficient parsers are greedy transition-based parsers, which only explore a single derivation for each input and relies on a locally trained classifier for predicting the next parser action given a compact representation of the derivation history, as pioneered by Yamada and Matsumoto (2003), Nivre (2003), Attardi (2006), and others. However, while these parsers are capable of processing tens of thousands of tokens per second with the right choice of classifiers, they are also known to perform slightly below the state-ofthe-art because of search errors and subsequent error propagation (McDonald and Nivre, 2007), and recent research on transition-based dependency parsing has therefore explored different ways of improving their accuracy. The most common approach is to use beam search instead of greedy decoding, in combination with a globally trained model that tries to minimize the loss over the entire sentence</context>
</contexts>
<marker>Attardi, 2006</marker>
<rawString>Giuseppe Attardi. 2006. Experiments with a multilanguage non-projective dependency parser. In Proceedings of the 10th Conference on Computational Natural Language Learning (CoNLL), pages 166– 170.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Miguel Ballesteros</author>
<author>Joakim Nivre</author>
</authors>
<title>Going to the roots of dependency parsing.</title>
<date>2013</date>
<journal>Computational Linguistics,</journal>
<volume>39</volume>
<issue>1</issue>
<contexts>
<context position="31767" citStr="Ballesteros and Nivre (2013)" startWordPosition="5767" endWordPosition="5770">vre (2011). The same template is adapted to the arc-standard parser, by removing the top-down parent features and by adding the right child features for the first stack element. It turns out that our feature template, described in §4.3, is the exact merge of the templates used for the arc-eager and the arc-standard parsers. We train all parsers up to 30 iterations, and for each parser we select the weight vector ω~ from the iteration with the best accuracy on the development set. All our parsers attach the root node at the end of the parsing process, following the ‘None’ approach discussed by Ballesteros and Nivre (2013). Punctuation is excluded in all evaluation metrics. Considering UAS, our parser provides an improvement of 1.15 over the arc-eager parser and an improvement of 1.31 over the arc-standard parser, that is an error reduction of —12% and —13%, respectively. Considering LAS, we achieve improvements of 1.33 and 1.47, with an error reduction of —11% and —12%, over the arc-eager and the arc-standard parsers, respectively. We speculate that the observed improvement of our parser can be ascribed to two distinct components. The first component is the left-/rightspine representation for stack elements, i</context>
</contexts>
<marker>Ballesteros, Nivre, 2013</marker>
<rawString>Miguel Ballesteros and Joakim Nivre. 2013. Going to the roots of dependency parsing. Computational Linguistics, 39(1):5–13.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Bernd Bohnet</author>
<author>Joakim Nivre</author>
</authors>
<title>A transitionbased system for joint part-of-speech tagging and labeled non-projective dependency parsing.</title>
<date>2012</date>
<booktitle>In Proceedings of the 2012 Joint Conference on Empirical Methods in Natural Language Processing and Computational Natural Language Learning,</booktitle>
<pages>1455--1465</pages>
<contexts>
<context position="2496" citStr="Bohnet and Nivre, 2012" startWordPosition="358" endWordPosition="361">cent research on transition-based dependency parsing has therefore explored different ways of improving their accuracy. The most common approach is to use beam search instead of greedy decoding, in combination with a globally trained model that tries to minimize the loss over the entire sentence instead of a locally trained classifier that tries to maximize the accuracy of single decisions (given no previous errors), as first proposed by Zhang and Clark (2008). With these methods, transition-based parsers have reached state-of-the-art accuracy for a number of languages (Zhang and Nivre, 2011; Bohnet and Nivre, 2012). However, the drawback with this approach is that parsing speed is proportional to the size of the beam, which means that the most accurate transition-based parsers are not nearly as fast as the original greedy transition-based parsers. Another line of research tries to retain the efficiency of greedy classifier-based parsing by instead improving the way in which classifiers are learned from data. While the classical approach limits training data to parser states that result from oracle predictions (derived from a treebank), these novel approaches allow the classifier to explore states that r</context>
</contexts>
<marker>Bohnet, Nivre, 2012</marker>
<rawString>Bernd Bohnet and Joakim Nivre. 2012. A transitionbased system for joint part-of-speech tagging and labeled non-projective dependency parsing. In Proceedings of the 2012 Joint Conference on Empirical Methods in Natural Language Processing and Computational Natural Language Learning, pages 1455– 1465.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jinho D Choi</author>
<author>Martha Palmer</author>
</authors>
<title>Getting the most out of transition-based dependency parsing.</title>
<date>2011</date>
<booktitle>In Proceedings of the 49th Annual Meeting of the Association for Computational Linguistics (ACL),</booktitle>
<pages>687--692</pages>
<contexts>
<context position="3171" citStr="Choi and Palmer, 2011" startWordPosition="467" endWordPosition="470">sing speed is proportional to the size of the beam, which means that the most accurate transition-based parsers are not nearly as fast as the original greedy transition-based parsers. Another line of research tries to retain the efficiency of greedy classifier-based parsing by instead improving the way in which classifiers are learned from data. While the classical approach limits training data to parser states that result from oracle predictions (derived from a treebank), these novel approaches allow the classifier to explore states that result from its own (sometimes erroneous) predictions (Choi and Palmer, 2011; Goldberg and Nivre, 2012). In this paper, we explore an orthogonal approach to improving the accuracy of transition-based parsers, without sacrificing their advantage in efficiency, by introducing a new type of transition system. While all previous transition systems assume a static parsing strategy with respect to top-down and bottom-up processing, our new system allows a dynamic strategy for ordering parsing decisions. This has the advantage that the parser can postpone difficult decisions until the relevant information becomes available, in a way that is not possible in existing transitio</context>
</contexts>
<marker>Choi, Palmer, 2011</marker>
<rawString>Jinho D. Choi and Martha Palmer. 2011. Getting the most out of transition-based dependency parsing. In Proceedings of the 49th Annual Meeting of the Association for Computational Linguistics (ACL), pages 687–692.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Michael Collins</author>
<author>Nigel Duffy</author>
</authors>
<title>New ranking algorithms for parsing and tagging: Kernels over discrete structures, and the voted perceptron.</title>
<date>2002</date>
<booktitle>In Proceedings of the 40th Annual Meeting of the Association for Computational Linguistics (ACL),</booktitle>
<pages>263--270</pages>
<location>Philadephia, Pennsylvania.</location>
<contexts>
<context position="19378" citStr="Collins and Duffy (2002)" startWordPosition="3460" endWordPosition="3463">te c with SHIFT p +- length of left spine of Q1 s +- length of right spine of Q2 T +- flak |k E [1,p]} U frak |k E [1, s]} U fsh} bestT +- argmaxtcT score(t, c) bestCorrectT +- argmaxtcT∧isCorrect(t) score(t, c) if bestT =� bestCorrectT then cv +- cv − φ(bestT, c) +φ(bestCorrectT, c) update c with bestCorrectT a feature vector representation for a transition t applying to a configuration c. The function φ will be discussed at length in §4.3. The vector cv is trained using the perceptron algorithm in combination with the averaging method to avoid overfitting; see Freund and Schapire (1999) and Collins and Duffy (2002) for details. The training data set consists of pairs (w, Ag), where w is a sentence and Ag is the set of arcs of the gold (desired) dependency tree for w. At training time, each pair (w, Ag) is processed using the learning algorithm described as Algorithm 2. The algorithm is based on the notions of correct and incorrect transitions, discussed at length in §4.2. Algorithm 2 parses w following Algorithm 1 and using the current cv, until the highest score selected transition bestT is incorrect according to Ag. When this happens, cv is updated by decreasing the weights of the features associated </context>
</contexts>
<marker>Collins, Duffy, 2002</marker>
<rawString>Michael Collins and Nigel Duffy. 2002. New ranking algorithms for parsing and tagging: Kernels over discrete structures, and the voted perceptron. In Proceedings of the 40th Annual Meeting of the Association for Computational Linguistics (ACL), pages 263–270, Philadephia, Pennsylvania.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Marie-Catherine De Marneffe</author>
<author>Bill MacCartney</author>
<author>Christopher D Manning</author>
</authors>
<title>Generating typed dependency parses from phrase structure parses.</title>
<date>2006</date>
<booktitle>In Proceedings of the 5th International Conference on Language Resources and Evaluation (LREC),</booktitle>
<volume>6</volume>
<pages>449--454</pages>
<marker>De Marneffe, MacCartney, Manning, 2006</marker>
<rawString>Marie-Catherine De Marneffe, Bill MacCartney, and Christopher D. Manning. 2006. Generating typed dependency parses from phrase structure parses. In Proceedings of the 5th International Conference on Language Resources and Evaluation (LREC), volume 6, pages 449–454.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Yoav Freund</author>
<author>Robert E Schapire</author>
</authors>
<title>Large margin classification using the perceptron algorithm.</title>
<date>1999</date>
<booktitle>Machine Learning,</booktitle>
<volume>37</volume>
<issue>3</issue>
<contexts>
<context position="19349" citStr="Freund and Schapire (1999)" startWordPosition="3454" endWordPosition="3458">β |&gt; 0 do while |Q |&lt; 2 do update c with SHIFT p +- length of left spine of Q1 s +- length of right spine of Q2 T +- flak |k E [1,p]} U frak |k E [1, s]} U fsh} bestT +- argmaxtcT score(t, c) bestCorrectT +- argmaxtcT∧isCorrect(t) score(t, c) if bestT =� bestCorrectT then cv +- cv − φ(bestT, c) +φ(bestCorrectT, c) update c with bestCorrectT a feature vector representation for a transition t applying to a configuration c. The function φ will be discussed at length in §4.3. The vector cv is trained using the perceptron algorithm in combination with the averaging method to avoid overfitting; see Freund and Schapire (1999) and Collins and Duffy (2002) for details. The training data set consists of pairs (w, Ag), where w is a sentence and Ag is the set of arcs of the gold (desired) dependency tree for w. At training time, each pair (w, Ag) is processed using the learning algorithm described as Algorithm 2. The algorithm is based on the notions of correct and incorrect transitions, discussed at length in §4.2. Algorithm 2 parses w following Algorithm 1 and using the current cv, until the highest score selected transition bestT is incorrect according to Ag. When this happens, cv is updated by decreasing the weight</context>
</contexts>
<marker>Freund, Schapire, 1999</marker>
<rawString>Yoav Freund and Robert E. Schapire. 1999. Large margin classification using the perceptron algorithm. Machine Learning, 37(3):277–296, December.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Yoav Goldberg</author>
<author>Michael Elhadad</author>
</authors>
<title>An efficient algorithm for easy-first non-directional dependency parsing.</title>
<date>2010</date>
<booktitle>In Proceedings of Human Language Technologies: The 2010 Annual Conference of the North American Chapter of the Association for Computational Linguistics (NAACL),</booktitle>
<pages>742--750</pages>
<location>Los Angeles, USA.</location>
<contexts>
<context position="25978" citStr="Goldberg and Elhadad (2010)" startWordPosition="4697" endWordPosition="4700">mputations that would hardwire a preference for some correct transition and get rid of spurious ambiguity. Following Goldberg and Nivre (2012), we instead regard spurious ambiguity as an additional resource of our parsing strategy. Our main goal is that the training algorithm learns to prefer a sh transition in a configuration that does not provide enough information for the choice of the correct arc. In the context of dependency parsing, the strategy of delaying arc construction when the current configuration is not informative is called the easyfirst strategy, and has been first explored by Goldberg and Elhadad (2010). 4.3 Feature Extraction In existing transition-based parsers a set of atomic features is statically defined and extracted from each configuration. These features are then combined together into complex features, according to some feature template, and joined with the available transition types. This is not possible in our system, since the number of transitions lak and rak is not bounded by a constant. Furthermore, it is not meaningful to associate transitions lak and rak, for any k ≥ 1, always with the same features, since the constructed arcs impinge on nodes at different depths in the invo</context>
</contexts>
<marker>Goldberg, Elhadad, 2010</marker>
<rawString>Yoav Goldberg and Michael Elhadad. 2010. An efficient algorithm for easy-first non-directional dependency parsing. In Proceedings of Human Language Technologies: The 2010 Annual Conference of the North American Chapter of the Association for Computational Linguistics (NAACL), pages 742– 750, Los Angeles, USA.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Yoav Goldberg</author>
<author>Joakim Nivre</author>
</authors>
<title>A dynamic oracle for arc-eager dependency parsing.</title>
<date>2012</date>
<booktitle>In Proceedings of the 24th International Conference on Computational Linguistics (COLING),</booktitle>
<pages>959--976</pages>
<contexts>
<context position="3198" citStr="Goldberg and Nivre, 2012" startWordPosition="471" endWordPosition="474">nal to the size of the beam, which means that the most accurate transition-based parsers are not nearly as fast as the original greedy transition-based parsers. Another line of research tries to retain the efficiency of greedy classifier-based parsing by instead improving the way in which classifiers are learned from data. While the classical approach limits training data to parser states that result from oracle predictions (derived from a treebank), these novel approaches allow the classifier to explore states that result from its own (sometimes erroneous) predictions (Choi and Palmer, 2011; Goldberg and Nivre, 2012). In this paper, we explore an orthogonal approach to improving the accuracy of transition-based parsers, without sacrificing their advantage in efficiency, by introducing a new type of transition system. While all previous transition systems assume a static parsing strategy with respect to top-down and bottom-up processing, our new system allows a dynamic strategy for ordering parsing decisions. This has the advantage that the parser can postpone difficult decisions until the relevant information becomes available, in a way that is not possible in existing transition systems. A second advanta</context>
<context position="21001" citStr="Goldberg and Nivre (2012)" startWordPosition="3738" endWordPosition="3741"> dependency parsers are trained by associating each gold tree with a canonical complete computation. This means that, for each configuration of interest, only one transition 139 σ2 σ1 b1 (a) σ2 σ1 b1 (b) (c) (d) � � � σ2 σ1 bi � � � σ2 σ1 bi Figure 4: Graphical representation of configurations; drawn arcs are in Ay but have not yet been added to the configuration. Transition sh is incorrect for configuration (a) and (b); sh and ra1 are correct for (c); sh and la1 are correct for (d). leading to the gold tree is considered as correct. In this paper we depart from such a methodology, and follow Goldberg and Nivre (2012) in allowing more than one correct transition for each configuration, as explained in detail below. Let (w, Ay) be a pair in the training set. In §3.3 we have mentioned that there is always a complete computation on w that results in the construction of the set Ay. In general, there might be more than one computation for Ay. This means that the parser shows spurious ambiguity. Observe that all complete computations for Ay share the same initial configuration cI,w and final configuration cF,A9. Consider now the set C(w) of all configurations c that are reachable from cI,w, meaning that there ex</context>
<context position="25493" citStr="Goldberg and Nivre (2012)" startWordPosition="4617" endWordPosition="4621">140 for the same configuration; see Figures 4(c,d) for examples. It follows that for a correct configuration there might be at most 2 correct transitions. In our training experiments for English in §5 we observe 2 correct transitions for 42% of the reached configurations. This nondeterminism is a byproduct of the adopted dynamic parsing strategy, and eventually leads to the spurious ambiguity of the parser. As already mentioned, we do not impose any canonical form on complete computations that would hardwire a preference for some correct transition and get rid of spurious ambiguity. Following Goldberg and Nivre (2012), we instead regard spurious ambiguity as an additional resource of our parsing strategy. Our main goal is that the training algorithm learns to prefer a sh transition in a configuration that does not provide enough information for the choice of the correct arc. In the context of dependency parsing, the strategy of delaying arc construction when the current configuration is not informative is called the easyfirst strategy, and has been first explored by Goldberg and Elhadad (2010). 4.3 Feature Extraction In existing transition-based parsers a set of atomic features is statically defined and ex</context>
</contexts>
<marker>Goldberg, Nivre, 2012</marker>
<rawString>Yoav Goldberg and Joakim Nivre. 2012. A dynamic oracle for arc-eager dependency parsing. In Proceedings of the 24th International Conference on Computational Linguistics (COLING), pages 959–976.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Aravind K Joshi</author>
<author>Yves Schabes</author>
</authors>
<title>TreeAdjoining Grammars.</title>
<date>1997</date>
<booktitle>In Grzegorz Rozenberg and Arto Salomaa, editors, Handbook of Formal Languages,</booktitle>
<volume>3</volume>
<pages>69--123</pages>
<publisher>Springer.</publisher>
<contexts>
<context position="36805" citStr="Joshi and Schabes, 1997" startWordPosition="6576" endWordPosition="6579">nio (2009). In the context of transition-based dependency parsers, right spines have also been exploited by Kitagawa and Tanaka-Ishii (2010) to decide where to attach the next word from the buffer. In this paper we have generalized their approach by introducing the symmetrical notion of left spine, and by allowing attachment of full trees rather than attachment of a single word.2 Since one can regard a spine as a stack in itself, whose elements are tree nodes, our model is reminiscent of the embedded pushdown automata of Schabes and Vijay-Shanker (1990), used to parse tree adjoining grammars (Joshi and Schabes, 1997) and exploiting a stack of stacks. However, by imposing projectivity, we do not use the extra-power of the latter class. An interesting line of future research is to combine our dynamic parsing strategy with a training method that allows the parser to explore transitions that apply to incorrect configurations, as in Goldberg and Nivre (2012). Acknowledgments We wish to thank Liang Huang and Marco Kuhlmann for discussion related to the ideas reported in this paper, and the anonymous reviewers for their useful suggestions. The second author has been partially supported by MIUR under project PRIN</context>
</contexts>
<marker>Joshi, Schabes, 1997</marker>
<rawString>Aravind K. Joshi and Yves Schabes. 1997. TreeAdjoining Grammars. In Grzegorz Rozenberg and Arto Salomaa, editors, Handbook of Formal Languages, volume 3, pages 69–123. Springer.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kotaro Kitagawa</author>
<author>Kumiko Tanaka-Ishii</author>
</authors>
<title>Tree-based deterministic dependency parsing — an application to Nivre’s method —.</title>
<date>2010</date>
<booktitle>In Proceedings of the 48th Annual Meeting of the Association for Computational Linguistics (ACL) Short Papers,</booktitle>
<pages>189--193</pages>
<contexts>
<context position="36321" citStr="Kitagawa and Tanaka-Ishii (2010)" startWordPosition="6494" endWordPosition="6497">ally static) arc-standard strategy, when evaluated on English. The idea of representing the right spine of a tree within the stack elements of a shift-reduce device is quite old in parsing, predating empirical approaches. It has been mainly exploited to solve the PP-attachment problem, motivated by psycholinguistic models. The same representation is also adopted in applications of discourse parsing, where right spines are usually called right frontiers; see for instance Subba and Di Eugenio (2009). In the context of transition-based dependency parsers, right spines have also been exploited by Kitagawa and Tanaka-Ishii (2010) to decide where to attach the next word from the buffer. In this paper we have generalized their approach by introducing the symmetrical notion of left spine, and by allowing attachment of full trees rather than attachment of a single word.2 Since one can regard a spine as a stack in itself, whose elements are tree nodes, our model is reminiscent of the embedded pushdown automata of Schabes and Vijay-Shanker (1990), used to parse tree adjoining grammars (Joshi and Schabes, 1997) and exploiting a stack of stacks. However, by imposing projectivity, we do not use the extra-power of the latter cl</context>
</contexts>
<marker>Kitagawa, Tanaka-Ishii, 2010</marker>
<rawString>Kotaro Kitagawa and Kumiko Tanaka-Ishii. 2010. Tree-based deterministic dependency parsing — an application to Nivre’s method —. In Proceedings of the 48th Annual Meeting of the Association for Computational Linguistics (ACL) Short Papers, pages 189–193.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Mitchell P Marcus</author>
<author>Beatrice Santorini</author>
<author>Mary Ann Marcinkiewicz</author>
</authors>
<title>Building a large annotated corpus of English: The Penn Treebank. Computational Linguistics,</title>
<date>1993</date>
<contexts>
<context position="29160" citStr="Marcus et al., 1993" startWordPosition="5269" endWordPosition="5272">dard set of atomic features and their complex combinations, to define the function φ. Our feature template is an extended version of the feature template of Zhang and Nivre (2011), originally developed for the arc-eager model. The extension is obtained by adding top-down features for left-arcs (based on placeholders gp and gg), and by adding right child features for the first stack element. The latter group of features is usually exploited for the arc-standard model, but is undefined for the arc-eager model. 5 Experimental Assessment Performance evaluation is carried out on the Penn Treebank (Marcus et al., 1993) converted to Stanford basic dependencies (De Marneffe et al., 2006). We use sections 2-21 for training, 22 as development set, and 23 as test set. The part-of-speech tags are assigned by an automatic tagger with accuracy 97.1%. The tagger used on the training set is trained on the same data set by using four-way jackknifing, while the tagger used on the development and test sets is trained on all the training set. We train an arc-labeled version of our parser. In the first three lines of Table 2 we compare 141 context sh k = 1 lak k = 1 rak placeholder k = 2 k &gt; 2 k = 2 k &gt; 2 s1 u1,1 = v1,1 u</context>
</contexts>
<marker>Marcus, Santorini, Marcinkiewicz, 1993</marker>
<rawString>Mitchell P. Marcus, Beatrice Santorini, and Mary Ann Marcinkiewicz. 1993. Building a large annotated corpus of English: The Penn Treebank. Computational Linguistics, 19:313–330.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ryan McDonald</author>
<author>Joakim Nivre</author>
</authors>
<title>Characterizing the errors of data-driven dependency parsing models.</title>
<date>2007</date>
<booktitle>In Proceedings of the 2007 Joint Conference on Empirical Methods in Natural Language Processing and Computational Natural Language Learning (EMNLP-CoNLL),</booktitle>
<pages>122--131</pages>
<contexts>
<context position="1865" citStr="McDonald and Nivre, 2007" startWordPosition="260" endWordPosition="263">he most efficient parsers are greedy transition-based parsers, which only explore a single derivation for each input and relies on a locally trained classifier for predicting the next parser action given a compact representation of the derivation history, as pioneered by Yamada and Matsumoto (2003), Nivre (2003), Attardi (2006), and others. However, while these parsers are capable of processing tens of thousands of tokens per second with the right choice of classifiers, they are also known to perform slightly below the state-ofthe-art because of search errors and subsequent error propagation (McDonald and Nivre, 2007), and recent research on transition-based dependency parsing has therefore explored different ways of improving their accuracy. The most common approach is to use beam search instead of greedy decoding, in combination with a globally trained model that tries to minimize the loss over the entire sentence instead of a locally trained classifier that tries to maximize the accuracy of single decisions (given no previous errors), as first proposed by Zhang and Clark (2008). With these methods, transition-based parsers have reached state-of-the-art accuracy for a number of languages (Zhang and Nivre</context>
</contexts>
<marker>McDonald, Nivre, 2007</marker>
<rawString>Ryan McDonald and Joakim Nivre. 2007. Characterizing the errors of data-driven dependency parsing models. In Proceedings of the 2007 Joint Conference on Empirical Methods in Natural Language Processing and Computational Natural Language Learning (EMNLP-CoNLL), pages 122–131.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Joakim Nivre</author>
</authors>
<title>An efficient algorithm for projective dependency parsing.</title>
<date>2003</date>
<booktitle>In Proceedings of the Eighth International Workshop on Parsing Technologies (IWPT),</booktitle>
<pages>149--160</pages>
<location>Nancy, France.</location>
<contexts>
<context position="1553" citStr="Nivre (2003)" startWordPosition="213" endWordPosition="214">ors, such as the increased availability of dependency treebanks and the perceived usefulness of dependency structures as an interface to downstream applications, but a very important reason is also the high efficiency offered by dependency parsers, enabling web-scale parsing with high throughput. The most efficient parsers are greedy transition-based parsers, which only explore a single derivation for each input and relies on a locally trained classifier for predicting the next parser action given a compact representation of the derivation history, as pioneered by Yamada and Matsumoto (2003), Nivre (2003), Attardi (2006), and others. However, while these parsers are capable of processing tens of thousands of tokens per second with the right choice of classifiers, they are also known to perform slightly below the state-ofthe-art because of search errors and subsequent error propagation (McDonald and Nivre, 2007), and recent research on transition-based dependency parsing has therefore explored different ways of improving their accuracy. The most common approach is to use beam search instead of greedy decoding, in combination with a globally trained model that tries to minimize the loss over the</context>
<context position="4069" citStr="Nivre (2003)" startWordPosition="605" endWordPosition="606">parsing strategy with respect to top-down and bottom-up processing, our new system allows a dynamic strategy for ordering parsing decisions. This has the advantage that the parser can postpone difficult decisions until the relevant information becomes available, in a way that is not possible in existing transition systems. A second advantage of dynamic parsing is that we can extend the feature inventory of previous systems. Our experiments show that these advantages lead to significant improvements in parsing accuracy, compared to a baseline parser that uses the arc-eager transition system of Nivre (2003), which is one of the most 135 Proceedings of the 51st Annual Meeting of the Association for Computational Linguistics, pages 135–144, Sofia, Bulgaria, August 4-9 2013. c�2013 Association for Computational Linguistics widely used static transition systems. 2 Static vs. Dynamic Parsing The notions of bottom-up and top-down parsing strategies do not have a general mathematical definition; they are instead specified, often only informally, for individual families of grammar formalisms. In the context of dependency parsing, a parsing strategy is called purely bottom-up if every dependency h -+ d i</context>
<context position="5320" citStr="Nivre (2003)" startWordPosition="811" endWordPosition="812">es of the form d -+ i have been constructed. Here h -+ d denotes a dependency with h the head node and d the dependent node. In contrast, a parsing strategy is called purely top-down if h -+ d is constructed before any dependency of the form d -+ i. If we consider transition-based dependency parsing (Nivre, 2008), the purely bottom-up strategy is implemented by the arc-standard model of Nivre (2004). After building a dependency h -+ d, this model immediately removes from its stack node d, preventing further attachment of dependents to this node. A second popular parser, the arc-eager model of Nivre (2003), instead adopts a mixed strategy. In this model, a dependency h -+ d is constructed using a purely bottom-up strategy if it represents a left-arc, that is, if the dependent d is placed to the left of the head h in the input string. In contrast, if h -+ d represents a right-arc (defined symmetrically), then this dependency is constructed before any right-arc d -+ i (top-down) but after any leftarc d -+ i (bottom-up). What is important to notice about the above transition-based parsers is that the adopted parsing strategies are static. By this we mean that each dependency is constructed accordi</context>
<context position="11707" citStr="Nivre (2003)" startWordPosition="1989" endWordPosition="1990">r discussion of the PP-attachment example in Figure 1. We observe that the new parsing strategy allows the construction of a tree T&apos; consisting of the only dependency V -+ N1 and a tree T, placed at the right of T&apos;, consisting of the only dependency P -+ N2. Since the right spine of T&apos; consists of nodes V and N1, we can freely choose between attachment V -+ P and attachment N1 -+ P. Note that this is done after we have seen node N2, as desired. 3.3 Transition-based Parser We assume the reader is familiar with the formal framework of transition-based dependency parsing originally introduced by Nivre (2003); see Nivre (2008) for an introduction. To keep the notation at a simple level, we only discuss here the unlabeled version of our parser; however, a labeled extension is used in §5 for our experiments. Our transition-based parser uses a stack data structure to store partial parses for the input string w. We represent the stack as an ordered sequence σ = [σd, . . . , σ1], d &gt; 0, of stack elements, with the topmost element placed at the right. When d = 0, we have the empty stack σ = []. Sometimes we use the vertical bar to denote the append operator for σ, and write σ = σ&apos;|σ1 to indicate that σ1</context>
</contexts>
<marker>Nivre, 2003</marker>
<rawString>Joakim Nivre. 2003. An efficient algorithm for projective dependency parsing. In Proceedings of the Eighth International Workshop on Parsing Technologies (IWPT), pages 149–160, Nancy, France.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Joakim Nivre</author>
</authors>
<title>Incrementality in deterministic dependency parsing.</title>
<date>2004</date>
<booktitle>In Workshop on Incremental Parsing: Bringing Engineering and Cognition Together,</booktitle>
<pages>50--57</pages>
<location>Barcelona,</location>
<contexts>
<context position="5110" citStr="Nivre (2004)" startWordPosition="777" endWordPosition="778">informally, for individual families of grammar formalisms. In the context of dependency parsing, a parsing strategy is called purely bottom-up if every dependency h -+ d is constructed only after all dependencies of the form d -+ i have been constructed. Here h -+ d denotes a dependency with h the head node and d the dependent node. In contrast, a parsing strategy is called purely top-down if h -+ d is constructed before any dependency of the form d -+ i. If we consider transition-based dependency parsing (Nivre, 2008), the purely bottom-up strategy is implemented by the arc-standard model of Nivre (2004). After building a dependency h -+ d, this model immediately removes from its stack node d, preventing further attachment of dependents to this node. A second popular parser, the arc-eager model of Nivre (2003), instead adopts a mixed strategy. In this model, a dependency h -+ d is constructed using a purely bottom-up strategy if it represents a left-arc, that is, if the dependent d is placed to the left of the head h in the input string. In contrast, if h -+ d represents a right-arc (defined symmetrically), then this dependency is constructed before any right-arc d -+ i (top-down) but after a</context>
</contexts>
<marker>Nivre, 2004</marker>
<rawString>Joakim Nivre. 2004. Incrementality in deterministic dependency parsing. In Workshop on Incremental Parsing: Bringing Engineering and Cognition Together, pages 50–57, Barcelona, Spain.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Joakim Nivre</author>
</authors>
<title>Algorithms for deterministic incremental dependency parsing.</title>
<date>2008</date>
<journal>Computational Linguistics,</journal>
<volume>34</volume>
<issue>4</issue>
<contexts>
<context position="5022" citStr="Nivre, 2008" startWordPosition="764" endWordPosition="765">s do not have a general mathematical definition; they are instead specified, often only informally, for individual families of grammar formalisms. In the context of dependency parsing, a parsing strategy is called purely bottom-up if every dependency h -+ d is constructed only after all dependencies of the form d -+ i have been constructed. Here h -+ d denotes a dependency with h the head node and d the dependent node. In contrast, a parsing strategy is called purely top-down if h -+ d is constructed before any dependency of the form d -+ i. If we consider transition-based dependency parsing (Nivre, 2008), the purely bottom-up strategy is implemented by the arc-standard model of Nivre (2004). After building a dependency h -+ d, this model immediately removes from its stack node d, preventing further attachment of dependents to this node. A second popular parser, the arc-eager model of Nivre (2003), instead adopts a mixed strategy. In this model, a dependency h -+ d is constructed using a purely bottom-up strategy if it represents a left-arc, that is, if the dependent d is placed to the left of the head h in the input string. In contrast, if h -+ d represents a right-arc (defined symmetrically)</context>
<context position="11725" citStr="Nivre (2008)" startWordPosition="1992" endWordPosition="1993">e PP-attachment example in Figure 1. We observe that the new parsing strategy allows the construction of a tree T&apos; consisting of the only dependency V -+ N1 and a tree T, placed at the right of T&apos;, consisting of the only dependency P -+ N2. Since the right spine of T&apos; consists of nodes V and N1, we can freely choose between attachment V -+ P and attachment N1 -+ P. Note that this is done after we have seen node N2, as desired. 3.3 Transition-based Parser We assume the reader is familiar with the formal framework of transition-based dependency parsing originally introduced by Nivre (2003); see Nivre (2008) for an introduction. To keep the notation at a simple level, we only discuss here the unlabeled version of our parser; however, a labeled extension is used in §5 for our experiments. Our transition-based parser uses a stack data structure to store partial parses for the input string w. We represent the stack as an ordered sequence σ = [σd, . . . , σ1], d &gt; 0, of stack elements, with the topmost element placed at the right. When d = 0, we have the empty stack σ = []. Sometimes we use the vertical bar to denote the append operator for σ, and write σ = σ&apos;|σ1 to indicate that σ1 is the topmost el</context>
</contexts>
<marker>Nivre, 2008</marker>
<rawString>Joakim Nivre. 2008. Algorithms for deterministic incremental dependency parsing. Computational Linguistics, 34(4):513–553.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Yves Schabes</author>
<author>K Vijay-Shanker</author>
</authors>
<title>Deterministic left to right parsing of tree adjoining languages.</title>
<date>1990</date>
<booktitle>In Proceedings of the 28th annual meeting of the Association for Computational Linguistics (ACL),</booktitle>
<pages>276--283</pages>
<location>Pittsburgh, Pennsylvania.</location>
<contexts>
<context position="36740" citStr="Schabes and Vijay-Shanker (1990)" startWordPosition="6566" endWordPosition="6569">es are usually called right frontiers; see for instance Subba and Di Eugenio (2009). In the context of transition-based dependency parsers, right spines have also been exploited by Kitagawa and Tanaka-Ishii (2010) to decide where to attach the next word from the buffer. In this paper we have generalized their approach by introducing the symmetrical notion of left spine, and by allowing attachment of full trees rather than attachment of a single word.2 Since one can regard a spine as a stack in itself, whose elements are tree nodes, our model is reminiscent of the embedded pushdown automata of Schabes and Vijay-Shanker (1990), used to parse tree adjoining grammars (Joshi and Schabes, 1997) and exploiting a stack of stacks. However, by imposing projectivity, we do not use the extra-power of the latter class. An interesting line of future research is to combine our dynamic parsing strategy with a training method that allows the parser to explore transitions that apply to incorrect configurations, as in Goldberg and Nivre (2012). Acknowledgments We wish to thank Liang Huang and Marco Kuhlmann for discussion related to the ideas reported in this paper, and the anonymous reviewers for their useful suggestions. The seco</context>
</contexts>
<marker>Schabes, Vijay-Shanker, 1990</marker>
<rawString>Yves Schabes and K. Vijay-Shanker. 1990. Deterministic left to right parsing of tree adjoining languages. In Proceedings of the 28th annual meeting of the Association for Computational Linguistics (ACL), pages 276–283, Pittsburgh, Pennsylvania.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Rajen Subba</author>
<author>Barbara Di Eugenio</author>
</authors>
<title>An effective discourse parser that uses rich linguistic information.</title>
<date>2009</date>
<booktitle>In Proceedings of Human Language Technologies: The 2009 Annual Conference of the North American Chapter of the Association for Computational Linguistics,</booktitle>
<pages>566--574</pages>
<marker>Subba, Di Eugenio, 2009</marker>
<rawString>Rajen Subba and Barbara Di Eugenio. 2009. An effective discourse parser that uses rich linguistic information. In Proceedings of Human Language Technologies: The 2009 Annual Conference of the North American Chapter of the Association for Computational Linguistics, pages 566–574.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Hiroyasu Yamada</author>
<author>Yuji Matsumoto</author>
</authors>
<title>Statistical dependency analysis with support vector machines.</title>
<date>2003</date>
<booktitle>In Proceedings of the 8th International Workshop on Parsing Technologies (IWPT),</booktitle>
<pages>195--206</pages>
<contexts>
<context position="1539" citStr="Yamada and Matsumoto (2003)" startWordPosition="209" endWordPosition="212"> is probably due to many factors, such as the increased availability of dependency treebanks and the perceived usefulness of dependency structures as an interface to downstream applications, but a very important reason is also the high efficiency offered by dependency parsers, enabling web-scale parsing with high throughput. The most efficient parsers are greedy transition-based parsers, which only explore a single derivation for each input and relies on a locally trained classifier for predicting the next parser action given a compact representation of the derivation history, as pioneered by Yamada and Matsumoto (2003), Nivre (2003), Attardi (2006), and others. However, while these parsers are capable of processing tens of thousands of tokens per second with the right choice of classifiers, they are also known to perform slightly below the state-ofthe-art because of search errors and subsequent error propagation (McDonald and Nivre, 2007), and recent research on transition-based dependency parsing has therefore explored different ways of improving their accuracy. The most common approach is to use beam search instead of greedy decoding, in combination with a globally trained model that tries to minimize the</context>
</contexts>
<marker>Yamada, Matsumoto, 2003</marker>
<rawString>Hiroyasu Yamada and Yuji Matsumoto. 2003. Statistical dependency analysis with support vector machines. In Proceedings of the 8th International Workshop on Parsing Technologies (IWPT), pages 195–206.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Yue Zhang</author>
<author>Stephen Clark</author>
</authors>
<title>A tale of two parsers: Investigating and combining graph-based and transition-based dependency parsing.</title>
<date>2008</date>
<booktitle>In Proceedings of the Conference on Empirical Methods in Natural Language Processing (EMNLP),</booktitle>
<pages>562--571</pages>
<contexts>
<context position="2337" citStr="Zhang and Clark (2008)" startWordPosition="336" endWordPosition="339">they are also known to perform slightly below the state-ofthe-art because of search errors and subsequent error propagation (McDonald and Nivre, 2007), and recent research on transition-based dependency parsing has therefore explored different ways of improving their accuracy. The most common approach is to use beam search instead of greedy decoding, in combination with a globally trained model that tries to minimize the loss over the entire sentence instead of a locally trained classifier that tries to maximize the accuracy of single decisions (given no previous errors), as first proposed by Zhang and Clark (2008). With these methods, transition-based parsers have reached state-of-the-art accuracy for a number of languages (Zhang and Nivre, 2011; Bohnet and Nivre, 2012). However, the drawback with this approach is that parsing speed is proportional to the size of the beam, which means that the most accurate transition-based parsers are not nearly as fast as the original greedy transition-based parsers. Another line of research tries to retain the efficiency of greedy classifier-based parsing by instead improving the way in which classifiers are learned from data. While the classical approach limits tra</context>
</contexts>
<marker>Zhang, Clark, 2008</marker>
<rawString>Yue Zhang and Stephen Clark. 2008. A tale of two parsers: Investigating and combining graph-based and transition-based dependency parsing. In Proceedings of the Conference on Empirical Methods in Natural Language Processing (EMNLP), pages 562– 571.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Yue Zhang</author>
<author>Joakim Nivre</author>
</authors>
<title>Transition-based parsing with rich non-local features.</title>
<date>2011</date>
<booktitle>In Proceedings of the 49th Annual Meeting of the Association for Computational Linguistics (ACL),</booktitle>
<pages>188--193</pages>
<contexts>
<context position="2471" citStr="Zhang and Nivre, 2011" startWordPosition="354" endWordPosition="357">nd Nivre, 2007), and recent research on transition-based dependency parsing has therefore explored different ways of improving their accuracy. The most common approach is to use beam search instead of greedy decoding, in combination with a globally trained model that tries to minimize the loss over the entire sentence instead of a locally trained classifier that tries to maximize the accuracy of single decisions (given no previous errors), as first proposed by Zhang and Clark (2008). With these methods, transition-based parsers have reached state-of-the-art accuracy for a number of languages (Zhang and Nivre, 2011; Bohnet and Nivre, 2012). However, the drawback with this approach is that parsing speed is proportional to the size of the beam, which means that the most accurate transition-based parsers are not nearly as fast as the original greedy transition-based parsers. Another line of research tries to retain the efficiency of greedy classifier-based parsing by instead improving the way in which classifiers are learned from data. While the classical approach limits training data to parser states that result from oracle predictions (derived from a treebank), these novel approaches allow the classifier</context>
<context position="28719" citStr="Zhang and Nivre (2011)" startWordPosition="5199" endWordPosition="5202">e assigned to s3 is the parent node of s2, if such a node is defined; otherwise, the node assigned to s3 is the root of the tree fragment in the stack underneath a2. Symmetrically, placeholders q1 and q2 refer to the parent and grandparent nodes of s1, respectively, when these nodes are defined; otherwise, these placeholders get assigned tokens from the buffer. See again Figure 5. Finally, from the placeholders in C(c, t) we extract a standard set of atomic features and their complex combinations, to define the function φ. Our feature template is an extended version of the feature template of Zhang and Nivre (2011), originally developed for the arc-eager model. The extension is obtained by adding top-down features for left-arcs (based on placeholders gp and gg), and by adding right child features for the first stack element. The latter group of features is usually exploited for the arc-standard model, but is undefined for the arc-eager model. 5 Experimental Assessment Performance evaluation is carried out on the Penn Treebank (Marcus et al., 1993) converted to Stanford basic dependencies (De Marneffe et al., 2006). We use sections 2-21 for training, 22 as development set, and 23 as test set. The part-of</context>
<context position="31149" citStr="Zhang and Nivre (2011)" startWordPosition="5661" endWordPosition="5664">tomic features for context C(c, la2) = (s3, s2, s1, q1, q2, gp, gg), c = (σ, β, A). parser iter UAS LAS UEM arc-standard 23 90.02 87.69 38.33 arc-eager 12 90.18 87.83 40.02 this work 30 91.33 89.16 42.38 arc-standard + easy-first 21 90.49 88.22 39.61 arc-standard + spine 27 90.44 88.23 40.27 Table 2: Accuracy on test set, excluding punctuation, for unlabeled attachment score (UAS), labeled attachment score (LAS), unlabeled exact match (UEM). the accuracy of our parser against our implementation of the arc-eager and arc-standard parsers. For the arc-eager parser, we use the feature template of Zhang and Nivre (2011). The same template is adapted to the arc-standard parser, by removing the top-down parent features and by adding the right child features for the first stack element. It turns out that our feature template, described in §4.3, is the exact merge of the templates used for the arc-eager and the arc-standard parsers. We train all parsers up to 30 iterations, and for each parser we select the weight vector ω~ from the iteration with the best accuracy on the development set. All our parsers attach the root node at the end of the parsing process, following the ‘None’ approach discussed by Ballestero</context>
</contexts>
<marker>Zhang, Nivre, 2011</marker>
<rawString>Yue Zhang and Joakim Nivre. 2011. Transition-based parsing with rich non-local features. In Proceedings of the 49th Annual Meeting of the Association for Computational Linguistics (ACL), pages 188–193.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>