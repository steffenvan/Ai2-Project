<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<title confidence="0.985638">
Programming in Logic with Constraints for
Natural Language Processing
</title>
<note confidence="0.633351">
Patrick Saint-Dizier
LSI Universite Paul Sabatier
118 route de Narbonne
31062 TOULOUSE Cedex France
</note>
<sectionHeader confidence="0.984423" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999886909090909">
In this paper, we present a logic-based
computational model for movement theory in
Government and Binding Theory. For that purpose,
we have designed a language called DISLOG.
DISLOG stands for programming in logic with
discontinuities and permits to express in a simple,
concise and declarative way relations or constraints
between non-contiguous elements in a structure.
DISLOG is also weel adapted to model other types of
linguistic phenomena like Quantifier Raising
involving long-distance relations or constraints.
</bodyText>
<sectionHeader confidence="0.998771" genericHeader="keywords">
1. Introduction
</sectionHeader>
<bodyText confidence="0.999910263888889">
Many areas of natural language syntax and
semantics are a fruitful source of inspiration for
computer languages and systems designers. The
complexity of natural language and the high level of
abstraction of most linguistic and semantic theories
have motivated the emergence of highly abstract and
transparent programming languages. One of the most
striking examples is undoubtedly Prolog, initially
designed for natural language parsing, via
Metamorphosis Grammars (Colmerauer 1978).
For a few years, the Logic Programming paradigm
has been augmented with a number of technical and
formal devices designed to extend its expressive
power. New logic programming languages have
emerged, several of them motivated by natural
language processing problems. Among them let us
mention: CIL (Mulcai 1985), designed to express in a
direct way concepts of Situation Semantics, MOLOG
(Farinas et al. 1985), an extension to Prolog designed
to specify in a very simple and declarative way the
semantics of modal operators and X-Prolog (Nadathur
and Miller 1988), designed to deal with X—expressions
and X-reduction.
Recently, the Logic Programming paradigm has
been augmented with the concept of constrained logic
programming (CLP). The basic research done within
this area amounts to specifying tools for a more
refined control on the type of values or terms a
variable in a program can stand for. Answers to
goals can be intensional: they are sets of equations
(constraints) rather than mere values. Furthermore, the
idea at the operational level, incorrect assignments are
filtered out as soon as they are encountered when
building a proof, making thus proof procedures more
efficient.
In this document, we deal with a new, original,
type of CLP mechanism: constraints on proof trees.
This type of constraint has emerged from, in
particular, the definition of a computational model for
the quantifier raising operation and for movement
theory in Government and Binding theory (noted
hereafter as GB). We model those phenomena in terms
of constraints between non-contiguous elements in a
structure. For example, we want to express
constraints between a moved constituent and its
co-indexed trace. Constraints are expressed in terms of
relations between subtrees in a syntactic tree or in
terms of relations between parenthetized constituents
in the now more commonly adopted annotated surface
forms of sentences.
We have designed Dislog, programming in logic
with discontinuities, which permits to express
relations between non-contiguous elements in a
structure in a simple, declarative and concise way.
Dislog is an extension to Prolog; its procedural and
declarative semantics are given in (Saint-Dizier
1988b), computer applications like compiler writing
and planning are given in (Saint-Dizier 1988a), its use
in natural language parsing for free-phrase order
languages is given in (Saint-Dizier 1987). In the
present document we will focus on modelling
movement theory in GB (Chomsky 1982, 1986) and
Quantifier Raising (May 1986), which have been in
the past two years our main guidelines to specify
Dislog. We do not have in mind to build a complete
model of GB theory, but we feel that the transfer of
some of its main principles and results to the field of
natural language processing is worth investigating and
is very promising for reasons we will develop
hereafter. We are also convinced that GB principles
should be paired with other approaches of Alto deal,
for example, with the lexicon, lexical semantics,
</bodyText>
<equation confidence="0.470599">
CP-H - 87 -
</equation>
<bodyText confidence="0.9351488">
feature representation and control systems and, finally,
logical form construction.
rule, more-a, controlled by principles and filters.
This very general rule states:
Move any constituent a to any position.
</bodyText>
<listItem confidence="0.627702">
2. Movement Theory in GB
</listItem>
<bodyText confidence="0.997274855072464">
In this section, we briefly summarize the main
aspects of movement theory (Chomsky 1982, 1986)
and give several examples. GB theory is a complete
revision of the baroque set of rules and
transformations of the standard theory, achieving a
much greater expressive power and explanatory
adequacy. GB theory is composed of a very small base
component (which follows X-bar syntax), a single
movement rule and a small set of principles whose
role is to control the power of the movement rule. GB
exhibits a greater clarity, ease of understanding and
linguistic coverage (in spite of some points which
remain obscure). The recent formalization of GB
theory has several attractive properties for the design
of a computational model of natural language
processing, among which:
- concision and economy of means,
- high degree of parametrization,
- modularity (e.g. independence of filtering
principles),
- declarativity (e.g. no order in the application
of rules),
- absence of intermediate structures (e.g.
no deep structure).
GB theory postulates four levels: d-structure
(sometimes not taken into account, like in our
approach), s-structure (surface form of structural
description), phonetic form (PF) and logical
form (LF). The latter two levels are derived
independently from s-structure. We will be mainly
interested here in the s-structure level. Movement
theory being also applicable, with different parameter
values, to LF, we will also show how our approach is
well-adapted to characterize LF level from s-structure
level.
The most immediate constraints are that a is
moved to the left to an empty position (a subject
position which is not 0-marked) or is adjoined to a
COMP or 1NFL node (new positions are created from
nothing, but this not in contradiction with the
projection principle). Constraints and filters control
movement but they also force movement. For
example, when a verb is used in the passive voice, it
can no longer assign case to its object. The object NP
must thus move to a place where it is assigned case.
The (external) subject 0-role being also suppressed,
the object NP naturally moves to the subject
position, where it is assigned case, while keeping its
previous 0-role.
Another immediate constraint is the 0-criterion:
each argument has one and only one 0-role and each
0-role is assigned to one and only one argument. Such
roles are lexically induced by means of the projection
principle (and by lexical insertion), confering thus an
increasing role to lexical subcategorization. Finally,
government gives a precise definition of what a
constituent can govern and thus how the projection
principled is handled.
Move-a is too abstract to be directly
implementable. It needs to be at least partially
instantiated, in a way which preserves its generality
and its explanatory power. In addition, while the
theory is attaining higher and higher levels of
adequacy, the interest for analysing the specifics of
particular constructions is decreasing. As a
consequence, we have to make explicit elements left
in the shade or just neglected. Finally, the feature
system implicit in GB theory has also to be
integrated.
</bodyText>
<subsectionHeader confidence="0.999899">
2.2 Examples of movements
2.1 Move-a and constraints
</subsectionHeader>
<bodyText confidence="0.975501444444444">
In GB, grammaticality of a sentence is based on
the existence of a well-formed annotated surface form
of that sentence. Thus, no real movements of
constituents occur and additional computational and
representational problems are avoided. Up to now very
few and only partial works have been undertaken to
model principles of GB theory. Among them, let us
mention (Berwick and Weinberg 1986), (Stabler 1987)
and (Brown et al. 1987). There is however an
increasing interest for this approach.
GB theory postulates a single movement
All the examples given below are expressed within
the framework of head-initial languages like French
and English. Let us first consider the relative
clause construction. In a relative clause, an N is
pronominalized and moved to the left and adjoined to a
COMP node. A trace of N is left behind and
co-indexed with the pronominalized N:
</bodyText>
<listItem confidence="0.6616275">
(1) [COMP N+Pro)i [N2 trace i
as in:
</listItem>
<bodyText confidence="0.972090285714286">
[COMp that i John met [N2 trace i] yesterday]
Where i is the co-indexation link.
- 88 -
The case of the passive construction is a
little more complicated and needs to be explained. An
object NP is moved to a subject position because the
passivisation of the verb no longer allows the verb to
assign case to its object NP and a 0-role to its subject
NP (in an indirect manner):
at d-structure we have, for example:
[ [NP [INFL gives [ N2 a book
and at s-structure we have:
[ [Np a books ] [NFL is given [N2 traces ] ].
At d-structure, the subject NP is here not
mentioned. In a passive construction, the subject is
not moved to a PP position (12y_N2). 0-roles are
redistributed when the verb is passivized (this
illustrates once again the prominent role played by the
lexical description and the projection principle) and a
by-complement with the previous 0-role of the
subject NP is created.
Another example is the subject-to-subject raising
operation, where:
It seems that Jane is on time
becomes:
Jane seems to be on time.
Jane moves to a position without 0-role (it is not
0-marked by seem). When the clause is on time is in
the infinitive form then the subject NP position is no
longer case-marked, forcing Jane to move:
[&apos;NFL Janes seem [comp traces [vp to be on
time ] ] ]
Finally, let us consider the wh-construal
construction occuring at logical form (LF) (May 86).
The representation of:
</bodyText>
<subsectionHeader confidence="0.895618">
Who saw what?
</subsectionHeader>
<bodyText confidence="0.9400214375">
is at s-structure:
[COMP2 [COMP whoi] [1NFL maces saw &apos; [N
what] I]
and becomes at LF:
[COMP2 [COMP whatj ) [COMP who [lNFL
traces saw tracej ] ].
Both what and who are adjoined to a COMP node.
This latter type of movement is also restricted by
a small number of general principles based on the
type of landing site a raised quantifier may occupy and
on the nature of the nodes a quantifier can cross over
when raised. The first type of constraint will be
directly expressed in rules by means of features; the
latter will be dealt with in section 5 devoted to
Bounding theory, where a model of the subjacency
constraint is presented.
</bodyText>
<subsectionHeader confidence="0.9875305">
2.3 Towards a computational
expression of movements
</subsectionHeader>
<bodyText confidence="0.999826315789474">
Movements have to be expressed in a simple
computational way. Let us consider the relative clause
construction (wh-movement in general), all the other
examples can be expressed in the same way.
Relative clause construction can be expressed in a
declarative way by stating, very informally, that:
within the domain of a COMP, an N(+Pro) is
adjoined to that COMP and somewhere else in that
domain an N2 is derived into a trace co-indexed with
that N(+Pro). The notion of domain associated to a
node like COMP refers to Bounding theory and will
be detailed in section 5, the constraint on the
co-existence in that domain of an N(+Pro) adjoined to
a COMP and, somewhere else, of an N2 derived into a
trace can directly be expressed by constraints on
syntactic trees, and, thus, by constraints on proof
trees in an operational framework. This is precisely
the main motivation of DISLOG that we now briefly
introduce.
</bodyText>
<listItem confidence="0.710139">
3. An Introduction to DISLOG,
Programming in Logic with
Discontinuities.
</listItem>
<bodyText confidence="0.999802833333333">
Dislog is an extension to Prolog. It is a language
composed of Prolog standard clauses and of Dislog
clauses. The computational aspects are similar to that
of Prolog. Foundations of DISLOG are given in
(Saint-Dizier 1988b). We now introduce and briefly
illustrate the main concepts of Dislog.
</bodyText>
<subsectionHeader confidence="0.997847">
3.1. Dislog clauses
</subsectionHeader>
<bodyText confidence="0.999664">
A Dislog clause is a fmite, unordered set of Prolog
clauses fs of the form:
</bodyText>
<subsubsectionHeader confidence="0.598173">
..f2 In .1.
</subsubsectionHeader>
<bodyText confidence="0.894206454545455">
The informal meaning of a Dislog clause is: if a
clause fi in a Dislog clause is used in a given proof
tree, then all the other fj of that Dislog clause must
be used to build that proof tree, with the same
substitutions applied to identical variables. For
example, the Dislog clause (with empty bodies here,
for the sake of clarity):
arc(a,b) ,arc(e,t)).
means that, in a graph, the use of arc(a,b) to
construct a proof is conditional to the use of arc(ef).
If one is looking for paths in a graph, this means that
- 89 -
all path going through arc(a,b) will also have to go
through arc(e1).
A Dislog clause with a single element is
equivalent to a Prolog clause (also called definite
program clause).
A Dislog program is composed of a set of Dislog
clauses. The definition of a predicate p in a Dislog
program is the set of all Dislog clauses which contain
at least one definite clause with head predicate symbol
p. Here is an example of a possible definition for p:
</bodyText>
<equation confidence="0.942542">
p(1) , h t(X) ).
(p(X) t(X), p(X-l) ) , d(3) ).
(p(5)).
</equation>
<bodyText confidence="0.988916">
A full example is given in section 3.3.
</bodyText>
<subsectionHeader confidence="0.999875">
3.2 Constraining Dislog clauses
</subsectionHeader>
<bodyText confidence="0.981508783783783">
We now propose some simple restrictions of the
above general form for Dislog clauses. A first type of
restriction is to impose restrictions on the order of use
of Prolog clauses in a Dislog clause. We say that an
instance of a clause ri precedes an instance of a clause
rj in a proof tree if either rj appears in that proof tree
to the left of I] or if rj dominates rj. Notice that this
notion of precedence is independent of the strategy
used to build the proof tree. In the following diagram,
the clause: a :- al precedes the clause b bl. :
To model this notion of precedence, we add to
Dislog clauses the traditional linear precedence
restriction notation, with the meaning given above:
a &lt; b means that the clause with head a
precedes the clause with head b (clause numbers can
also be used). When the clause order in a Dislog
clause is complete, we use the more convenient
notation:
fl I f2 I I fn .
which means that fl precedes f2 which precedes
etc... The relation / is viewed as an accessibilit3
relation.
Another improvement to Dislog clauses is du
adjunction of modalities. We want to allow Prolof
clauses in a Dislog clause to be used several times
This permits to deal, for example, with parasitic gap:
and with pronominal references. We use the modality
m applied on a rule to express that this clause can be
used any number of times in a Dislog clause. Fon
example, in: ., _
f fl f2 m(f3 ) J.
the clause f3 can be used any number of times
provided that fl and f2 are used. Substitutions fa
identical variables remain the same as before.
Another notational improvement is the use of the
semi-colon &apos;;&apos; with a similar meaning as in Prolog tc
factor out rules having similar parts:
</bodyText>
<figure confidence="0.458585">
{a,b). and { a,c)
can be factored out as:
(a,(b;c)).
which means that a must be used with either b 01
C.
</figure>
<subsectionHeader confidence="0.998495">
3.3 Programming in Dislog
</subsectionHeader>
<bodyText confidence="0.969856272727273">
Here is a short and simple example where Disloi
turns out to be very well-adapted.
In a conventional programming language, there an
several one-to-one or one-to-many relations between
non-contiguous instructions. For instance, there is g
relation between a procedure and its corresponding
calls and another relation between a label declaration
and its corresponding branching instructions. Dislog
rule format is very well adapted to express thom
relations, permitting variables to be shared between
several definite clause in a Dislog clause. These
variables can percolate, for example, addresses of entr3
points.
We now consider the compiler given in (Sterling
and Shapiro 86) which transforms a program written
in a simplified version of Pascal into a set of basic
instructions (built in the argument). This smal
compiler can be augmented with two Dislog rules:
(procedure declaration, procedure calks)).
( label statement, branching instruction(s) to
label).
In order for a procedure call to be allowed tc
</bodyText>
<figure confidence="0.8462914">
a
bl
al
or:
- 90 -
</figure>
<bodyText confidence="0.929364">
appear before the declaration of the corresponding
procedure we do not state any linear precedence
restriction. Furthemore, procedure call and branching
instruction description rules are in a many-to-one
relation with respectively the procedure declaration and
the label declaration. A procedure call may indeed
appear several times in the body of a program (this is
precisely the role of a procedure in fact). Thus, we
have to use the modality m as follows:
procedure declaration, m(procedure call)).
{ label statement, m(branching instruction to
label)).
In a parse tree corresponding to the syntactic
analysis of a Pascal program, we could have, for
example the following tree:
</bodyText>
<equation confidence="0.845753">
proc_call(Address)
proc_declaration(Address,Code)
proc_call(Address) ■
proc_call(Address)
</equation>
<bodyText confidence="0.991742285714286">
The main calls and the Dislog rules are the
following:
parse(Structure) --&gt; [program],
identifier(X), [&apos;;&apos;],
statement(Structure).
statement((S;Sa) --&gt; [begin],
statement(S),
rest_statement(S a).
statement(assign(X,V)) --&gt;
identifier(X), [1:=1,
expression(V).
1* procedure declaration and call */
( (statement(proc_decl(N,S)) --&gt;
[procedure],
identifier(N),
statement(S),
[end] ) ,
m( statement(proc_call(N,S)) --&gt;
identifier(N) ) ).
1* label declaration and branching */
( (statement(label(N)) --&gt;
identifier(N),
[&apos;:&apos;] )
m( statement(goto(N)) --&gt;
identifier(N) ) ).
We have carried out an efficient and complete
implementation for Dislog rules which are compiled
into Prolog clauses.
</bodyText>
<sectionHeader confidence="0.9923775" genericHeader="introduction">
4. Expressing movement rules in
Dislog
</sectionHeader>
<bodyText confidence="0.999960214285714">
A way of thinking to move-a (as in Sells 85) is
that it expresses the &apos;movement&apos; part of a relation
between two structures. We quote the term movement
because, in our approach, we no longer deal with
d-structure and no longer have, thus, movements but
rather long-distance relations or constraints.
We think that, in fact, move-a is itself the
relation (or prototype of relation) and that the
constraints (case assignment, 0-marking, bounding
theory, etc...) are just specific arguments or
constraints on that relation: everything is possible
(relation) and constraints filter out incorrect
configurations. From this point of view, Dislog is a
simple and direct computational model for move-a.
</bodyText>
<subsectionHeader confidence="0.965972">
4.1 Expressing movement in
Dislog
</subsectionHeader>
<bodyText confidence="0.998931777777778">
The relativisation rule given above is expressed in
a straightforward way by a Dislog clause. That Dislog
clause is composed of two Prolog(-like) clauses. The
first clause deals with the adjunction of the N(+Pro)
to the COMP and the second clause deals with the
derivation of the N2 into a trace. A shared variable I
permits to establish the co-indexation link. The
Dislog clause is the following, in which we adopt the
X-bar syntax terminology:
</bodyText>
<equation confidence="0.768711">
xp(comp,0,_„) --&gt; xp(n,O,pro(Case),1,) ,
xp(n,2,Caselj --&gt; trace(I).
</equation>
<bodyText confidence="0.937607692307692">
An xp is a predicate which represents any
category. The category is specified in the first
argument, the bar level in the second, syntactic
features in the third one (oversimplified here), the
fourth argument is the co-indexation link and the last
one, not dealt with here, contains the logical form
associated with the rule. Notice that using identical
variables (namely here I and Case) in two different
clauses in a Dislog clauses permits to transfer feature
values in a very simple and transparent way.
The passive construction is expressed in a similar
way. Notice that we are only interested in the
s-structure description since we produce annotated
- 91 -
The movement construction rules given abov
have many similarities. They can be informally pi
together to form a single, partially instanciate
movement rule, roughly as follows:
surface forms (from which we then derive a semantic
representation). The passive construction rule in
Dislog is:
--&gt;
--&gt; trace(I).
Case and 0-role are lexically induced. Following a
specification format like in (Sells 85), we have, for
example, for the verb to eat, the following lexical
entry:
eat, V, (subject:NP, agent), (object:NP, patient),
assigns no case to object.
which becomes with the passive inflection:
eaten, V. (object: NP, patient), assigns no case.
(the by-complement is also lexically induced by a
lexical transformation of the same kind with:
iobject:NP, agent, case: ablative)
Let us now consider the subject-to-subject raising
operation. At d-structure, the derivation of an N2 into
the dummy pronoun it is replaced by the derivation of
that N2 into an overt noun phrase. This is formulated
as follows in Dislog:
</bodyText>
<equation confidence="0.993263666666667">
xp(inf1,2,Case,_,) --&gt; xp(n,2,Case,13,
xp(inf1,1,_,_,J 1
xp(n,2,Case,I,J--&gt; trace(I).
</equation>
<bodyText confidence="0.999570727272727">
In order to properly anchor the N2, we have to
repeat in the Dislog rule a rule from the base
component (rule with infl). Once again, this is
lexically induced from the description of the verb to
seem: when the N2 is raised, the proposition
following the completive verb has no subject, it is
tenseless, i.e. in the infinitive form. Finally, notice
the case variable, designed to maintain the case chain.
The wh-construal construction at LF is dealt with
in exactly the same manner, an N2(+pro) is adjoined
to a COMP node:
</bodyText>
<equation confidence="0.988156333333333">
xp(comp,2,_,_,_) --&gt; xp(n,2,pro(Case),13,
xp(comp,2,_,_,_) /
xp(n,2,Case,I,_)--&gt; trace(I).
</equation>
<bodyText confidence="0.999935">
Case permits the distinction between different
pronouns. Notice that this rule is exactly similar to
the relative construction rule.
Dislog rules describing movements can be used in
any order and are independent of the parsing strategy.
They are simple, but their interactions can become
quite complex. However, the high level of
declarativity of Dislog permits us to control
movements in a sound way.
</bodyText>
<equation confidence="0.9955798">
( (xp(inf1,1,_,_,_) --&gt; xp(n,0,_,I,_
) ;
(xp(inf1,2 ,Case,_,_) --&gt; xp(n,2,Case
) ; etc.... 1
xp(n,2,(Case;pro(Case)),I,_)--&gt; trace(I) ).
</equation>
<subsectionHeader confidence="0.965863">
4.2 Other uses of Dislog fo
natural language processing
</subsectionHeader>
<bodyText confidence="0.999979684210527">
Dislog has many other uses in natural languai
processing. At the semantic level, it can be used in
convenient way as a computational model to deal wi
quantifier raising, with negation and modality operat
raising operations or to model some meanh
postulates in Montague semantics. Dislog can al:
provide a simple model for temporal relatiol
involving the notion of (partial) precedence of actioi
or events.
Semantic interpretation or formula optimisatil
often involves putting together or rewriting elemer
which are not necessarily contiguous in a formul
Dislog rules can then be used as rewriting rules.
Finally, at the level of syntax, we have shown
(Saint-Diner 87) that Dislog can be efficiently used
deal with free phrase order or free word cut
languages, producing as a result a normaliz,
syntactic tree. Dislog can also be used to skip parts
sentences which cannot be parsed.
</bodyText>
<subsectionHeader confidence="0.9993785">
4.3 Formal grammatical aspects
Dislog rules
</subsectionHeader>
<bodyText confidence="0.999554625">
A Dislog rule can be interpreted by a ter
attribute grammar. A term attribute grammar 11
arguments which are terms. It is a context-fr
grammar that has been augmented with conditions (
arguments) enabling non-context-free aspects of
language to be specified. A Dislog rule can
translated as follows into a term attribute gramm
Consider the rule:
</bodyText>
<figure confidence="0.570357">
a --&gt; b / c --&gt; d.
a possible (and simple) interpretation is:
</figure>
<equation confidence="0.936341">
a(X,Y) --&gt; b(XX1), add(X1,[c--&gt;d1,Y).
b(X,Y) --&gt; withdrawac--&gt;41,X,Y1), d(Y1,Y).
</equation>
<bodyText confidence="0.982614666666667">
When a--&gt;b is executed, the rule c--&gt;d is stored
an argument (X and Y represent input and out
arguments for storing these rules to be executed, 1
strings of words are stored in DCGs). c--&gt;d can cm
- 92 -
be executed if it is present in the list. At the end of
the parsing process, the list of rules to be executed
must be empty (except for rules marked with modality
m). Notice also that shared variables in a Dislog rule
are unified and further percolated when rules are stored
by the procedure add.
Dislog rules can be used to express
context-sensitive languages. For example, consider
the language L= (anbmcndm, n, m positive integers),
it is recognized by the following grammar:
</bodyText>
<figure confidence="0.9811922">
S --&gt; A, B, C, D.
A --&gt; [a], A I C --&gt; [c] , C.
B --&gt; [bl , B I D --&gt; [d] , D.
A--&gt; [a] . B --&gt; [b] .
C --&gt; [c] . D --&gt; [a] .
</figure>
<bodyText confidence="0.863148625">
If a, b, c and d are mixed, with the only condition
that the number of a&apos;s is equal to the number of c&apos;s
and the number of b&apos;s is equal to the number of d&apos;s,
we have:
( (S --&gt; [a], S), (S --&gt; [c], S) ).
S --&gt; [a] / [b] / [c] / [d].
Bounding nodes and modalities can also be added
to deal with more complex languages.
</bodyText>
<subsectionHeader confidence="0.565249">
4.4 Related works
</subsectionHeader>
<bodyText confidence="0.999963878787879">
Dislog originates a new type of logic-based
grammar that we call Contextual Discontinuous
Grammars. The closest formalisms to Dislog are
Extraposition Grammars (Pereira 1981) and Gapping
Grammars (Dahl and Abramson 1984). As opposed to
Gapping Grammars, Dislog permits to deal with trees
rather than with graphs. Gapping Grammars are of
type-0 and are much more difficult to write and to
control the power of. Compared to Extraposition
Grammars, Dislog no longer operates movements of
strings and it is also more general since a Dislog
clause can contain any number of Prolog clauses
which can be used in any orderand at any place within
a domain. Extraposition grammars also involve
graphs (although much simpler than for Gapping
Grammars) instead of trees, which are closer to the
linguistic reality. The implementation of Dislog is
about as efficient as the very insightful
implementation provided by F. Pereira.
More recently (Dahl, forthcoming), Static
Discontinuity Grammars have been introduced,
motivated by the need to model GB theory for
sentence generation. They permit to overcome some
drawbacks of Gapping Grammars by prohibiting
movements of constituents in rules. They have also
borrowed several aspects to Dislog (like bounding
nodes and its procedural interpretation). Dislog is
however more general and more powerful because it
deals with unordered sets of rules rather than with a
single, rigid rewriting rule, it also permits to
introduce modalities and no extrasymbols (to
represents skips or to avoid loops) need to be
introduced (see Saint-Dizier 88b).
</bodyText>
<sectionHeader confidence="0.658883" genericHeader="method">
5. Bounding Theory in Dislog
</sectionHeader>
<bodyText confidence="0.999935857142857">
Bounding theory is a general phenomena common
to several linguistic theories and expressed in very
similar ways. Roughly speaking, Bounding theory
states constraints on the way to move constituents,
or, in non-transformational terms on the way to
establish relations between non-contiguous elements
in a sentence. The main type of constraint is
expressed in terms of domains over the boundaries of
which relations cannot be established. For example, if
A is a bounding node (or a subtree which is a
sequence of bounding nodes), then the domain of A is
the domain it is the root of and no constituent X
inside that domain can have relations with a
constituent outside it (at least not directly):
</bodyText>
<sectionHeader confidence="0.784786" genericHeader="method">
A
</sectionHeader>
<bodyText confidence="0.776896">
or, if A represents a sequence B ... C of bounding
nodes:
\
</bodyText>
<sectionHeader confidence="0.570255" genericHeader="method">
B
</sectionHeader>
<bodyText confidence="0.999938416666667">
In Dislog, if an instance of a Dislog clause is
activated within the domain of a bounding node, then,
the whole Dislog clause has to be used within that
domain. For a given application, bounding nodes are
specified as a small database of Prolog facts and are
interpreted by the Dislog system.
In the case of Quantifier Raising, we have several
types of bounding nodes: the nodes of syntax, nodes
corresponding to conjunctions, modals, some
temporal expressions, etc... Those nodes are declared
as bounding nodes and are then processed by Dislog in
a way transparent to the grammar writer.
</bodyText>
<sectionHeader confidence="0.954503" genericHeader="method">
6. An implementation of Dislog for
</sectionHeader>
<bodyText confidence="0.825917">
- 93 -
</bodyText>
<subsectionHeader confidence="0.447062">
natural language processing
</subsectionHeader>
<bodyText confidence="0.999813588235294">
We have carried out an specific implementation of
Dislog for natural language parsing described in
(St-Dizier, Toussaint, Delaunay and Sebillot 1989).
The very regular format of the grammar rules (X-bar
syntax) permits us to define a specific implementation
which, in spite of the high degree of parametrization
of the linguistic system, is very efficient.
We use a bottom-up parsing strategy similar to
that given in (Pereira and Shieber 1987), with some
adaptations due to the very regular rule format of
X-bar syntax rules, and a one-step look-ahead
mechanism which very efficiently anticipates the
rejection of many unappropriate rules. The sentences
we have worked on involve several complex
constructions; they are parsed in 0.2 to 2 seconds
CPU time in Quintus Prolog on a SUN 3.6
workstation.
</bodyText>
<sectionHeader confidence="0.995582" genericHeader="conclusions">
7. Perspectives
</sectionHeader>
<bodyText confidence="0.999932">
In this paper, we have presented a simple,
declarative computational model for movement theory
in Government and Binding. For that purpose, we
have introduced Dislog, a logic programming
language built on top of Prolog, designed to express
in a simple, transparent and concise way relations or
constraints between non-contiguous constituents in a
structure. Although Dislog is still in an early stage of
development, it seems a promising language for
natural language processing and also to represent and
to program several kinds of problems where the idea
of non-contiguity is involved. The efficient
implementation we have carried out permits to use
Dislog on a large scale. We have designed a prototype
parser which includes our model of movement rules,
the GB base component, a quite extensive lexicon and
semantic compositional rules to build logical
formulas. We also use the same model for natural
language generation.
</bodyText>
<sectionHeader confidence="0.998711" genericHeader="acknowledgments">
Acknowledgements
</sectionHeader>
<bodyText confidence="0.999799">
I would like to thank A. Borillo, M. Borillo, C.
Brown, V. Dahl, C. Delaunay, G. Lapalme, P.
Sebillot and J. Virbel for their comments on ealier
versions of this work. This project is supported by
the INRIA and by the PRC Communication
Homme-machine of the CNRS.
</bodyText>
<sectionHeader confidence="0.999602" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.99343262295082">
Berwick, R. and Weinberg, A., The Grammatical
Basis of Linguistic Performance, MIT Press, 1986.
Brown, C., Pattabhiraman, T., Massicotte, P.,
Towards a Theory of Natural Language Generation:
the Connection between Syntax and Semantics, in:
Natural Language Understanding and Logic
Programming II, V. Dahl and P. Saint-Dizier Edts,
North Holland 1987.
Chomsky, N., Lectures on Government and
Binding, Foris Pub., Dordrecht, 1981.
Chomsky, N., Barriers, Linguistic Inquiry
monograph nb. 13, MIT Press 1986.
Colmerauer, A., Metamorphosis Grammars, in:
Natural Language Understanding by Computer,
Lecture notes in Computer Science, L. Bolc Edt.,
Springer-Verlag, 1978.
Dahl V., Abramson, H., On Gapping Grammars,
Proc. of the 3rd Logic Programming Conference,
Uppsala, 1984.
Farinas del Cerro, L., Arthaud, A., Molog:
Programming in Modal Logic, Fifth Generation
Computing journal, 1985.
May, R., Logical Form, Linguistic Inquiry
monograph nb. 12, MIT Press, 1986.
Mukai, K., Unification over Complex
Indeterminates, Fifth Generation Computer journal,
1985.
Nadathur, G., Miller, D., An overview of
X-Prolog, Technical report MS-CIS-88-40, University
of Pennsylvania, 1988.
Pereira, F., Logic for Natural Language Analysis,
SRI technical report 275, Stanford, 1985.
Pereira, F., Sheiber, S., Prolog for Natural
Language Analysis, CSLI lecture Notes, Chicago
University Press, 1987.
Saint-Dizier, P., Contextual Discontinuous
Grammars, in: Natural Language Understanding and
Logic Programming II, V. Dahl and P. Saint-Dizier
Edts, North Holland, 1987.
Saint-Dizier, P., Dislog, Programming in Logic
with Discontinuities, Computational Intelligence,
vol. 5-1, 1988.
Saint-Dizier, P., Foundations of Dislog,
programming in Logic with Discontinuities, in
proc. of FGCS&apos;88, Tokyo, 1988.
Saint-Dizier,P., Toussaint,Y.,Delaunay,C.,
Sebillot,P., A Natural language processing system
based on principles of government and binding theory,
in Logic Programming and Logic grammars, P.
Saint-Dizier and S. Szpalcowicz Edts, Ellis Horwood,
1989.
Sells, P., Lectures on Contemporary Syntactic
Theories, CSLI lecture notes no 3, Chicago
University Press, 1985.
Stabler, E., Parsing with Explicit Representations
of Syntactic Constraints, in: Natural Language
Understanding and Logic Programming II, V. Dahl
and P. Saint-Dizier Edts, North Holland, 1987.
Sterling, L., Shapiro, S., The Art of Prolog,
mrr Press, 1986.
- 94 -
</reference>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.671516">
<title confidence="0.9999215">Programming in Logic with Constraints for Natural Language Processing</title>
<author confidence="0.996405">Patrick Saint-Dizier</author>
<affiliation confidence="0.700572">LSI Universite Paul Sabatier</affiliation>
<address confidence="0.982727">118 route de Narbonne 31062 TOULOUSE Cedex France</address>
<abstract confidence="0.99785925">In this paper, we present a logic-based computational model for movement theory in Government and Binding Theory. For that purpose, we have designed a language called DISLOG. DISLOG stands for programming in logic with discontinuities and permits to express in a simple, concise and declarative way relations or constraints between non-contiguous elements in a structure. DISLOG is also weel adapted to model other types of linguistic phenomena like Quantifier Raising involving long-distance relations or constraints.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>R Berwick</author>
<author>A Weinberg</author>
</authors>
<title>The Grammatical Basis of Linguistic Performance,</title>
<date>1986</date>
<publisher>MIT Press,</publisher>
<contexts>
<context position="8051" citStr="Berwick and Weinberg 1986" startWordPosition="1246" endWordPosition="1249">ns is decreasing. As a consequence, we have to make explicit elements left in the shade or just neglected. Finally, the feature system implicit in GB theory has also to be integrated. 2.2 Examples of movements 2.1 Move-a and constraints In GB, grammaticality of a sentence is based on the existence of a well-formed annotated surface form of that sentence. Thus, no real movements of constituents occur and additional computational and representational problems are avoided. Up to now very few and only partial works have been undertaken to model principles of GB theory. Among them, let us mention (Berwick and Weinberg 1986), (Stabler 1987) and (Brown et al. 1987). There is however an increasing interest for this approach. GB theory postulates a single movement All the examples given below are expressed within the framework of head-initial languages like French and English. Let us first consider the relative clause construction. In a relative clause, an N is pronominalized and moved to the left and adjoined to a COMP node. A trace of N is left behind and co-indexed with the pronominalized N: (1) [COMP N+Pro)i [N2 trace i as in: [COMp that i John met [N2 trace i] yesterday] Where i is the co-indexation link. - 88 </context>
</contexts>
<marker>Berwick, Weinberg, 1986</marker>
<rawString>Berwick, R. and Weinberg, A., The Grammatical Basis of Linguistic Performance, MIT Press, 1986.</rawString>
</citation>
<citation valid="true">
<authors>
<author>C Brown</author>
<author>T Pattabhiraman</author>
<author>P Massicotte</author>
</authors>
<title>Towards a Theory of Natural Language Generation: the Connection between Syntax and Semantics, in: Natural Language Understanding and Logic Programming</title>
<date>1987</date>
<location>North Holland</location>
<contexts>
<context position="8091" citStr="Brown et al. 1987" startWordPosition="1253" endWordPosition="1256">ake explicit elements left in the shade or just neglected. Finally, the feature system implicit in GB theory has also to be integrated. 2.2 Examples of movements 2.1 Move-a and constraints In GB, grammaticality of a sentence is based on the existence of a well-formed annotated surface form of that sentence. Thus, no real movements of constituents occur and additional computational and representational problems are avoided. Up to now very few and only partial works have been undertaken to model principles of GB theory. Among them, let us mention (Berwick and Weinberg 1986), (Stabler 1987) and (Brown et al. 1987). There is however an increasing interest for this approach. GB theory postulates a single movement All the examples given below are expressed within the framework of head-initial languages like French and English. Let us first consider the relative clause construction. In a relative clause, an N is pronominalized and moved to the left and adjoined to a COMP node. A trace of N is left behind and co-indexed with the pronominalized N: (1) [COMP N+Pro)i [N2 trace i as in: [COMp that i John met [N2 trace i] yesterday] Where i is the co-indexation link. - 88 - The case of the passive construction i</context>
</contexts>
<marker>Brown, Pattabhiraman, Massicotte, 1987</marker>
<rawString>Brown, C., Pattabhiraman, T., Massicotte, P., Towards a Theory of Natural Language Generation: the Connection between Syntax and Semantics, in: Natural Language Understanding and Logic Programming II, V. Dahl and P. Saint-Dizier Edts, North Holland 1987.</rawString>
</citation>
<citation valid="true">
<authors>
<author>N Chomsky</author>
</authors>
<title>Lectures on Government and Binding, Foris Pub.,</title>
<date>1981</date>
<location>Dordrecht,</location>
<marker>Chomsky, 1981</marker>
<rawString>Chomsky, N., Lectures on Government and Binding, Foris Pub., Dordrecht, 1981.</rawString>
</citation>
<citation valid="true">
<authors>
<author>N Chomsky</author>
<author>Barriers</author>
</authors>
<title>Linguistic Inquiry monograph nb. 13,</title>
<date>1986</date>
<publisher>MIT Press</publisher>
<marker>Chomsky, Barriers, 1986</marker>
<rawString>Chomsky, N., Barriers, Linguistic Inquiry monograph nb. 13, MIT Press 1986.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Colmerauer</author>
</authors>
<title>Metamorphosis Grammars, in: Natural Language Understanding by Computer,</title>
<date>1978</date>
<booktitle>Lecture notes in Computer Science, L. Bolc Edt.,</booktitle>
<publisher>Springer-Verlag,</publisher>
<contexts>
<context position="1196" citStr="Colmerauer 1978" startWordPosition="167" endWordPosition="168">o model other types of linguistic phenomena like Quantifier Raising involving long-distance relations or constraints. 1. Introduction Many areas of natural language syntax and semantics are a fruitful source of inspiration for computer languages and systems designers. The complexity of natural language and the high level of abstraction of most linguistic and semantic theories have motivated the emergence of highly abstract and transparent programming languages. One of the most striking examples is undoubtedly Prolog, initially designed for natural language parsing, via Metamorphosis Grammars (Colmerauer 1978). For a few years, the Logic Programming paradigm has been augmented with a number of technical and formal devices designed to extend its expressive power. New logic programming languages have emerged, several of them motivated by natural language processing problems. Among them let us mention: CIL (Mulcai 1985), designed to express in a direct way concepts of Situation Semantics, MOLOG (Farinas et al. 1985), an extension to Prolog designed to specify in a very simple and declarative way the semantics of modal operators and X-Prolog (Nadathur and Miller 1988), designed to deal with X—expressio</context>
</contexts>
<marker>Colmerauer, 1978</marker>
<rawString>Colmerauer, A., Metamorphosis Grammars, in: Natural Language Understanding by Computer, Lecture notes in Computer Science, L. Bolc Edt., Springer-Verlag, 1978.</rawString>
</citation>
<citation valid="true">
<authors>
<author>V Dahl</author>
<author>H Abramson</author>
</authors>
<title>On Gapping Grammars,</title>
<date>1984</date>
<booktitle>Proc. of the 3rd Logic Programming Conference,</booktitle>
<location>Uppsala,</location>
<contexts>
<context position="24481" citStr="Dahl and Abramson 1984" startWordPosition="3998" endWordPosition="4001">, B I D --&gt; [d] , D. A--&gt; [a] . B --&gt; [b] . C --&gt; [c] . D --&gt; [a] . If a, b, c and d are mixed, with the only condition that the number of a&apos;s is equal to the number of c&apos;s and the number of b&apos;s is equal to the number of d&apos;s, we have: ( (S --&gt; [a], S), (S --&gt; [c], S) ). S --&gt; [a] / [b] / [c] / [d]. Bounding nodes and modalities can also be added to deal with more complex languages. 4.4 Related works Dislog originates a new type of logic-based grammar that we call Contextual Discontinuous Grammars. The closest formalisms to Dislog are Extraposition Grammars (Pereira 1981) and Gapping Grammars (Dahl and Abramson 1984). As opposed to Gapping Grammars, Dislog permits to deal with trees rather than with graphs. Gapping Grammars are of type-0 and are much more difficult to write and to control the power of. Compared to Extraposition Grammars, Dislog no longer operates movements of strings and it is also more general since a Dislog clause can contain any number of Prolog clauses which can be used in any orderand at any place within a domain. Extraposition grammars also involve graphs (although much simpler than for Gapping Grammars) instead of trees, which are closer to the linguistic reality. The implementatio</context>
</contexts>
<marker>Dahl, Abramson, 1984</marker>
<rawString>Dahl V., Abramson, H., On Gapping Grammars, Proc. of the 3rd Logic Programming Conference, Uppsala, 1984.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Farinas del Cerro</author>
<author>L Arthaud</author>
<author>A</author>
</authors>
<title>Molog: Programming in Modal Logic, Fifth Generation Computing journal,</title>
<date>1985</date>
<marker>Cerro, Arthaud, A, 1985</marker>
<rawString>Farinas del Cerro, L., Arthaud, A., Molog: Programming in Modal Logic, Fifth Generation Computing journal, 1985.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R May</author>
</authors>
<title>Logical Form, Linguistic Inquiry monograph nb. 12,</title>
<date>1986</date>
<publisher>MIT Press,</publisher>
<contexts>
<context position="3737" citStr="May 1986" startWordPosition="556" endWordPosition="557">ned Dislog, programming in logic with discontinuities, which permits to express relations between non-contiguous elements in a structure in a simple, declarative and concise way. Dislog is an extension to Prolog; its procedural and declarative semantics are given in (Saint-Dizier 1988b), computer applications like compiler writing and planning are given in (Saint-Dizier 1988a), its use in natural language parsing for free-phrase order languages is given in (Saint-Dizier 1987). In the present document we will focus on modelling movement theory in GB (Chomsky 1982, 1986) and Quantifier Raising (May 1986), which have been in the past two years our main guidelines to specify Dislog. We do not have in mind to build a complete model of GB theory, but we feel that the transfer of some of its main principles and results to the field of natural language processing is worth investigating and is very promising for reasons we will develop hereafter. We are also convinced that GB principles should be paired with other approaches of Alto deal, for example, with the lexicon, lexical semantics, CP-H - 87 - feature representation and control systems and, finally, logical form construction. rule, more-a, con</context>
</contexts>
<marker>May, 1986</marker>
<rawString>May, R., Logical Form, Linguistic Inquiry monograph nb. 12, MIT Press, 1986.</rawString>
</citation>
<citation valid="true">
<authors>
<author>K Mukai</author>
</authors>
<title>Unification over Complex Indeterminates, Fifth Generation Computer journal,</title>
<date>1985</date>
<marker>Mukai, 1985</marker>
<rawString>Mukai, K., Unification over Complex Indeterminates, Fifth Generation Computer journal, 1985.</rawString>
</citation>
<citation valid="true">
<authors>
<author>G Nadathur</author>
<author>D Miller</author>
</authors>
<title>An overview of X-Prolog,</title>
<date>1988</date>
<tech>Technical report MS-CIS-88-40,</tech>
<institution>University of Pennsylvania,</institution>
<contexts>
<context position="1761" citStr="Nadathur and Miller 1988" startWordPosition="254" endWordPosition="257">nguage parsing, via Metamorphosis Grammars (Colmerauer 1978). For a few years, the Logic Programming paradigm has been augmented with a number of technical and formal devices designed to extend its expressive power. New logic programming languages have emerged, several of them motivated by natural language processing problems. Among them let us mention: CIL (Mulcai 1985), designed to express in a direct way concepts of Situation Semantics, MOLOG (Farinas et al. 1985), an extension to Prolog designed to specify in a very simple and declarative way the semantics of modal operators and X-Prolog (Nadathur and Miller 1988), designed to deal with X—expressions and X-reduction. Recently, the Logic Programming paradigm has been augmented with the concept of constrained logic programming (CLP). The basic research done within this area amounts to specifying tools for a more refined control on the type of values or terms a variable in a program can stand for. Answers to goals can be intensional: they are sets of equations (constraints) rather than mere values. Furthermore, the idea at the operational level, incorrect assignments are filtered out as soon as they are encountered when building a proof, making thus proof</context>
</contexts>
<marker>Nadathur, Miller, 1988</marker>
<rawString>Nadathur, G., Miller, D., An overview of X-Prolog, Technical report MS-CIS-88-40, University of Pennsylvania, 1988.</rawString>
</citation>
<citation valid="true">
<authors>
<author>F Pereira</author>
</authors>
<title>Logic for Natural Language Analysis, SRI technical report 275,</title>
<date>1985</date>
<location>Stanford,</location>
<marker>Pereira, 1985</marker>
<rawString>Pereira, F., Logic for Natural Language Analysis, SRI technical report 275, Stanford, 1985.</rawString>
</citation>
<citation valid="true">
<authors>
<author>F Pereira</author>
<author>S Sheiber</author>
</authors>
<title>Prolog for Natural Language Analysis, CSLI lecture Notes,</title>
<date>1987</date>
<publisher>Chicago University Press,</publisher>
<marker>Pereira, Sheiber, 1987</marker>
<rawString>Pereira, F., Sheiber, S., Prolog for Natural Language Analysis, CSLI lecture Notes, Chicago University Press, 1987.</rawString>
</citation>
<citation valid="true">
<authors>
<author>P Saint-Dizier</author>
</authors>
<title>Contextual Discontinuous Grammars, in: Natural Language Understanding and Logic Programming</title>
<date>1987</date>
<contexts>
<context position="3608" citStr="Saint-Dizier 1987" startWordPosition="535" endWordPosition="536">terms of relations between parenthetized constituents in the now more commonly adopted annotated surface forms of sentences. We have designed Dislog, programming in logic with discontinuities, which permits to express relations between non-contiguous elements in a structure in a simple, declarative and concise way. Dislog is an extension to Prolog; its procedural and declarative semantics are given in (Saint-Dizier 1988b), computer applications like compiler writing and planning are given in (Saint-Dizier 1988a), its use in natural language parsing for free-phrase order languages is given in (Saint-Dizier 1987). In the present document we will focus on modelling movement theory in GB (Chomsky 1982, 1986) and Quantifier Raising (May 1986), which have been in the past two years our main guidelines to specify Dislog. We do not have in mind to build a complete model of GB theory, but we feel that the transfer of some of its main principles and results to the field of natural language processing is worth investigating and is very promising for reasons we will develop hereafter. We are also convinced that GB principles should be paired with other approaches of Alto deal, for example, with the lexicon, lex</context>
</contexts>
<marker>Saint-Dizier, 1987</marker>
<rawString>Saint-Dizier, P., Contextual Discontinuous Grammars, in: Natural Language Understanding and Logic Programming II, V. Dahl and P. Saint-Dizier Edts, North Holland, 1987.</rawString>
</citation>
<citation valid="true">
<authors>
<author>P Saint-Dizier</author>
<author>Dislog</author>
</authors>
<date>1988</date>
<booktitle>Programming in Logic with Discontinuities, Computational Intelligence,</booktitle>
<volume>vol.</volume>
<pages>5--1</pages>
<marker>Saint-Dizier, Dislog, 1988</marker>
<rawString>Saint-Dizier, P., Dislog, Programming in Logic with Discontinuities, Computational Intelligence, vol. 5-1, 1988.</rawString>
</citation>
<citation valid="true">
<authors>
<author>P Saint-Dizier</author>
</authors>
<title>Foundations of Dislog, programming in Logic with Discontinuities, in proc. of FGCS&apos;88,</title>
<date>1988</date>
<location>Tokyo,</location>
<contexts>
<context position="3413" citStr="Saint-Dizier 1988" startWordPosition="508" endWordPosition="509">ure. For example, we want to express constraints between a moved constituent and its co-indexed trace. Constraints are expressed in terms of relations between subtrees in a syntactic tree or in terms of relations between parenthetized constituents in the now more commonly adopted annotated surface forms of sentences. We have designed Dislog, programming in logic with discontinuities, which permits to express relations between non-contiguous elements in a structure in a simple, declarative and concise way. Dislog is an extension to Prolog; its procedural and declarative semantics are given in (Saint-Dizier 1988b), computer applications like compiler writing and planning are given in (Saint-Dizier 1988a), its use in natural language parsing for free-phrase order languages is given in (Saint-Dizier 1987). In the present document we will focus on modelling movement theory in GB (Chomsky 1982, 1986) and Quantifier Raising (May 1986), which have been in the past two years our main guidelines to specify Dislog. We do not have in mind to build a complete model of GB theory, but we feel that the transfer of some of its main principles and results to the field of natural language processing is worth investig</context>
<context position="11867" citStr="Saint-Dizier 1988" startWordPosition="1915" endWordPosition="1916">e co-existence in that domain of an N(+Pro) adjoined to a COMP and, somewhere else, of an N2 derived into a trace can directly be expressed by constraints on syntactic trees, and, thus, by constraints on proof trees in an operational framework. This is precisely the main motivation of DISLOG that we now briefly introduce. 3. An Introduction to DISLOG, Programming in Logic with Discontinuities. Dislog is an extension to Prolog. It is a language composed of Prolog standard clauses and of Dislog clauses. The computational aspects are similar to that of Prolog. Foundations of DISLOG are given in (Saint-Dizier 1988b). We now introduce and briefly illustrate the main concepts of Dislog. 3.1. Dislog clauses A Dislog clause is a fmite, unordered set of Prolog clauses fs of the form: ..f2 In .1. The informal meaning of a Dislog clause is: if a clause fi in a Dislog clause is used in a given proof tree, then all the other fj of that Dislog clause must be used to build that proof tree, with the same substitutions applied to identical variables. For example, the Dislog clause (with empty bodies here, for the sake of clarity): arc(a,b) ,arc(e,t)). means that, in a graph, the use of arc(a,b) to construct a proof</context>
</contexts>
<marker>Saint-Dizier, 1988</marker>
<rawString>Saint-Dizier, P., Foundations of Dislog, programming in Logic with Discontinuities, in proc. of FGCS&apos;88, Tokyo, 1988.</rawString>
</citation>
<citation valid="true">
<authors>
<author>P Saint-Dizier</author>
<author>Y Toussaint</author>
<author>C Delaunay</author>
</authors>
<title>Sebillot,P., A Natural language processing system based on principles of government and binding theory,</title>
<date>1989</date>
<booktitle>in Logic Programming and Logic</booktitle>
<marker>Saint-Dizier, Toussaint, Delaunay, 1989</marker>
<rawString>Saint-Dizier,P., Toussaint,Y.,Delaunay,C., Sebillot,P., A Natural language processing system based on principles of government and binding theory, in Logic Programming and Logic grammars, P. Saint-Dizier and S. Szpalcowicz Edts, Ellis Horwood, 1989.</rawString>
</citation>
<citation valid="true">
<authors>
<author>P Sells</author>
</authors>
<title>Lectures on Contemporary Syntactic Theories, CSLI lecture notes no 3,</title>
<date>1985</date>
<publisher>Chicago University Press,</publisher>
<marker>Sells, 1985</marker>
<rawString>Sells, P., Lectures on Contemporary Syntactic Theories, CSLI lecture notes no 3, Chicago University Press, 1985.</rawString>
</citation>
<citation valid="true">
<authors>
<author>E Stabler</author>
</authors>
<title>Parsing with Explicit Representations of Syntactic Constraints, in: Natural Language Understanding and Logic Programming</title>
<date>1987</date>
<contexts>
<context position="8067" citStr="Stabler 1987" startWordPosition="1250" endWordPosition="1251">uence, we have to make explicit elements left in the shade or just neglected. Finally, the feature system implicit in GB theory has also to be integrated. 2.2 Examples of movements 2.1 Move-a and constraints In GB, grammaticality of a sentence is based on the existence of a well-formed annotated surface form of that sentence. Thus, no real movements of constituents occur and additional computational and representational problems are avoided. Up to now very few and only partial works have been undertaken to model principles of GB theory. Among them, let us mention (Berwick and Weinberg 1986), (Stabler 1987) and (Brown et al. 1987). There is however an increasing interest for this approach. GB theory postulates a single movement All the examples given below are expressed within the framework of head-initial languages like French and English. Let us first consider the relative clause construction. In a relative clause, an N is pronominalized and moved to the left and adjoined to a COMP node. A trace of N is left behind and co-indexed with the pronominalized N: (1) [COMP N+Pro)i [N2 trace i as in: [COMp that i John met [N2 trace i] yesterday] Where i is the co-indexation link. - 88 - The case of th</context>
</contexts>
<marker>Stabler, 1987</marker>
<rawString>Stabler, E., Parsing with Explicit Representations of Syntactic Constraints, in: Natural Language Understanding and Logic Programming II, V. Dahl and P. Saint-Dizier Edts, North Holland, 1987.</rawString>
</citation>
<citation valid="true">
<authors>
<author>L Sterling</author>
<author>S Shapiro</author>
</authors>
<title>The Art of Prolog,</title>
<date>1986</date>
<publisher>mrr Press,</publisher>
<marker>Sterling, Shapiro, 1986</marker>
<rawString>Sterling, L., Shapiro, S., The Art of Prolog, mrr Press, 1986.</rawString>
</citation>
<citation valid="false">
<pages>94</pages>
<marker></marker>
<rawString>- 94 -</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>