<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<title confidence="0.9982545">
Processing Language with Logical Types
and Active Constraints
</title>
<note confidence="0.779669333333333">
Patrick SAINT-DIZIER
1RIT Universitd Paul Sabatier 118, route de Narbonne
31062 Toulouse cedex FRANCE
</note>
<email confidence="0.992648">
e-mail: stdizier@irit.irit.fr
</email>
<sectionHeader confidence="0.995513" genericHeader="abstract">
ABSTRACT
</sectionHeader>
<bodyText confidence="0.9997654">
In this document, we present a language which
associates type construction principles to constraint
logic programming. We show that it is very
appropriate for language processing, providing more
uniform, expressive and efficient tools and
treatments. We introduce three kinds of constraints,
that we exemplify by motivational examples.
Finally, we give the procedural semantics of our
language, combining type construction with SLD-
resolution.
</bodyText>
<sectionHeader confidence="0.987002" genericHeader="introduction">
Introduction
</sectionHeader>
<bodyText confidence="0.999852045454546">
With the development of highly parameterized
syntactic theories like Government and Binding
theory and Head-Driven phrase structure grammars
and with the development of theories where rewriting
and unification plays a central role, like Categorial
grammars and Unification Grammars, there is an
increasing need for more appropriate and more
efficient feature systems.
Feature systems must be designed to preserve the
adequacy, the expressiveness and the explanatory
power of the linguistic system that one wants to
model. Real parsing as well as generation systems
often require the manipulation of large sets of
features, these systems must therefore offer a great
flexibility in the specification of features in grammar
symbols and a significant modularity so that each
linguistic aspect (morphological, categorial, ...) can
be dealt with independently. Features are often subject
to various constraints. These constraints cannot
always be evaluated at the level they are formulated
(e.g. a feature value is not yet known) but have to be
evaluated later and must be true throughout the whole
parsing or generation process.
The development of principled-based approaches to
language processing also require the definition of
more abstract formal systems to handle in an adequate
way these principles. Principles indeed often apply
not at grammar rule level but they involve a large
part of a parse tree. They must be expressed by a
constraint system which is global to the whole
grammar and not local to a rule, as for example, in
DCGs.
These brief considerations have motivated our
approach: syntactic rules are viewed as type
constructions on which constraints are applied. These
constraints are themselves part of the type. To give
an appropriate expressive power to constraints and an
efficient interpretation, they are interpreted within
the Constraint Logic Programming framework.
In the next sections, we introduce our description
language based on types and constraints. We then
give motivational examples which clarify its use.
Then we give its procedural interpretation and a
constraint resolution mechanism system.
</bodyText>
<sectionHeader confidence="0.982977" genericHeader="method">
1. A typed-based description
language
</sectionHeader>
<bodyText confidence="0.998535533333333">
Three main types of operations are at the basis of
the typed-based language we have designed for
language processing, namely:
- the expression of type construction to describe
phrase structures,
- the expression of relations (either local or long-
distance) between types,
- the expression of well-formedness constraints on
types.
The term type refers here to structured data
representation. They must not be confused with types
defined in linguistics, as in the categorial system.
The starting point of our description language is
CIL (Mukai 85), a language designed to model
Situation Semantics which permits the expression of
some constraints on typed descriptions called
complex indeterminates; and Login (Ait-Kagi and
Nasr 86), a typed-based language with a built-in
inheritance schema. To these languages we have added
specific feature treatments and constraints usually
necessary for language processing that we now find
in advanced unification grammar systems (Sheiber
87, Emele &amp; Zajac 90). We have also provided a
specific declarative and procedural semantics merging
type construction and resolution of constraints,
viewed as active constraints of the constraint logic
programming framework (noted hereafter as CLP)
(Colmerauer 90), (Jaffar and Lassez 87).
We now informally present the syntax of our type-
based language. It is directly derived from the syntax
</bodyText>
<listItem confidence="0.922311230769231">
- 57 -
of Login. The syntactic representation of a structured
term is called a Ni-term. It consists of:
(1) a root symbol, which is a type constructor and
denotes a class of entities,
(2) attribute labels, which are record field symbols.
Each attribute denotes a function in extenso, from the
root to the attribute value. The attribute value can
itself be a reference to a type or to an instance of a
type.
(3) coreference constraints among paths of labels,
indicate that the corresponding attributes denote the
same function. They are indicated by variables.
</listItem>
<bodyText confidence="0.748054">
Here is an example:
</bodyText>
<equation confidence="0.9351926">
person( id =&gt; name(f irst =&gt; string,
last =&gt; X: string),
born =&gt; date(day =&gt; integer,
month =&gt; monthname, year =&gt; integer),
father =&gt; person( id =&gt; name(last =&gt; X ))).
</equation>
<bodyText confidence="0.999845">
The root symbol is person; id, born and father are
three sub-w-terms which have either constants or
types as values. X indicates a coreference. All
different type structures are tagged by different
symbols. Notice also that in the latter field only
relevant information about person is mentioned.
Infinite structures can also be specified by coreference
links. Variables are in capital letters, constants in
small letters. To this description, we have added the
treatment of negation on constants, and the treatment
of conjunctions and disjunctions, in a way quite
similar to (Johnson 90). Taxonomic relations
between identifiers are also taken into account in the
unification mechanism. These features will not
however be developed, since this is not central to
what we want to explain here.
This formalism permits us to define type
inheritance and the possibility to define in a clean
way classes and subclasses corresponding to
structured linguistic objects (Saint-Dizier 91).
</bodyText>
<subsectionHeader confidence="0.406745">
2. Dealing with constraints
</subsectionHeader>
<bodyText confidence="0.711234">
The general form of a type is:
</bodyText>
<subsectionHeader confidence="0.896428">
Type :- Constraints.
</subsectionHeader>
<bodyText confidence="0.971166017241379">
Constraints belong to the following classes:
- constraints on attribute values not yet known,
- constraints on values of two attributes,
- constraints on the existence of an attribute
possibly with a given associated value,
- constraints on the co-existence of attributes (to
express dependencies),
- constraints expressing precedence relations on
strings of words.
The first two classes of constraints being developed
by F. Giinthner (Ganthner 88) within the framework
of Prolog III, we will here concentrate on the three
last types of constraints, which are quite different in
nature from the two first ones. We view constraints
as part of the type: (Type :- Constraints) is itself a
type, subsumed by Type.
The linear precedence constraint:
precede(X,Y),
where X and Y are of type string. It imposes that the
string X precedes of the string Y. Precedence
constraints on constituents are stated in the grammar
rules and at the lexical level. At each stage i of a
parse, a partial and coherent order Pl(i) on the words
and structures already processed can be constructed.
On the other hand, the input sentence to parse has a
strict order P2 on words. Then, at each stage of the
parsing process, P1(i) and P2 must be satisfiable. As
shown in the ID/LP framework, having precedence
relations permits us to have a more general and
flexible description of phrase structures. The CLP
interpretation of precedence permits us to have a
more efficient system because backtracking will
occur as soon as a precedence violation is detected.
The next constraint imposes the presence of a
certain attribute in a type:
has(Attribute, Type)
where Attribute is either an attribute label or a pair
attribute-value (a sub-Ni-term) and Type is a
reference to a type. This constraint imposes that at
some stage there is an attribute in Type which is
subsumed by or equal to Attribute. Informally, (1)
when incoherence with Attribute is detected or (2)
when Type is fully constructed, the non-satisfaction
of has(attribute,type) will provoque backtracking.
This constraint also permits us to encode the
inclusion of a set of values into another.
The last class of constraint is mainly related to the
expression of long-distance relations between
sentence constituents. Within the framework of
types, the notion of long-distance is somewhat
obsolete since there is no ordering relation on
subtypes in a type (attributes may be written in any
order). Thus, the notion of long-distance dependency
will be here formulated as a sub-type co-occurence
constraint. This constraint emerged from Dislog
(Saint-Dizier 87, 89), that we now briefly present.
A Dislog clause is a finite, unordered set of
Horn clauses fi of the form:
</bodyText>
<equation confidence="0.405582">
Ifi f2
</equation>
<bodyText confidence="0.960970833333333">
The informal meaning Of a Dislog clause is: if a
clause fi in a Dislog clause is used to construct a
given proof tree, then all the other fi of that Dislog
clause must be used to construct that proof tree,
with the same substitutions applied to identical
variables. Moreover, there are no hypothesis made on
the location of these clauses in the proof tree. For
example, the following Dislog clause composed of
two Prolog facts:
arc(a,b), arc(e I)).
means that, in a graph, the use of arc(a,b) to
construct a proof is conditional to the use of arc(ef).
- 58 -
If one is looking for paths in a graph, this means
that all path going through the arc(a,b) will have to
go through the arc(ef), or conversely.
A Dislog clause thus permits us to express co-
occurence of clauses in a proof tree. The constraint
stating that all identical variables in an instance of a
Dislog clause must be substituted for the same terms
permits the transfer of argument values between non-
contiguous elements in a very convenient way. A
Dislog clause can be subject to various types of
restrictions such as: linear precedence constraints on
the fi , modalities on applications of some fi and the
specification of bounding domains in which an
Dislog clause instance must be fully used (Saint-
Dizier 89).
The co-occurence of two subtypes in a larger type
is expressed by the constraint:
</bodyText>
<equation confidence="0.522933">
pending(A,B)
</equation>
<bodyText confidence="0.999914714285714">
where A is a type specification and B is a list of type
specifications. Informally, this constraint means that
A originates the pending of the types in B, in other
terms that A can be used as a type constructor if,
somewhere else in the main type (corresponding to
sentence), all the types in B are also used as type
constructors with identical substitutions applied to
identical variables. Notice that this constraint is not
equivalent to a conjunction of has(X,T) constraints
because the has(X,T) constraint imposes that T is
fully defined whereas pending(A,B) does not impose,
a priori, any constraints on the location in the main
type of the types in B. The constraint resolution
mechanism of this constraint is given in section 6.
</bodyText>
<subsectionHeader confidence="0.422278">
3. Parsing with types and constraints
</subsectionHeader>
<bodyText confidence="0.9999876">
We first present simple, motivational examples. A
more abstract syntactic description of the X-bar
system follows and shows more clearly the
expressive power of the formalism. The following
examples show that our description language can
accomodate principled-based descriptions of language
like Government and Binding theory as well as
lexically and head driven descriptions like in the
HPSG framework (which also follow principles, but
not in the same sense).
</bodyText>
<subsectionHeader confidence="0.998318">
3.1 A simple grammatical system:
</subsectionHeader>
<bodyText confidence="0.9962875">
In the following examples, we only have two
main type constructors:
- x0 corresponding to lexical entries,
- xp corresponding to phrase structures.
Here is the description of the lexical entry
corresponding to the verb to give:
</bodyText>
<equation confidence="0.8289926">
x0( cat =&gt; v, string =&gt; [give] ) :-
pending(x0(cat =&gt; v), [xp( cat =&gt; n,
role =&gt; patient, case =&gt; acc ),
xp( cat =&gt; p, role =&gt; recipient,
case =&gt; dative ) ).
</equation>
<bodyText confidence="0.97056">
This entry indicates that give is a verb which
subcategorizes for an np with role patient and case
accusative and a pp with role recipient and case
oblique, which are left pending since they do not
necessarily immediately follow the verb in a
sentence. These constraints will be dealt with by the
type describing the structure of a vp. The whole
description x0 construction and the constraints is the
type of the verb to give.
Let us now consider the construction of a vp with
an np and a pp complements:
</bodyText>
<equation confidence="0.958711714285714">
xp( cat =&gt; v, string =&gt; 5,
const 1 =&gt; x0(cat =&gt; v, string =&gt; 51 ),
const2 -&gt; X : xp(cat =&gt; n, string =&gt; 52),
const3 =&gt; Y : xp( cat =&gt; p, string =&gt; 53)) :-
has(role, X), has(case, X),
has(role, Y), has(case, Y),
precede(5 I ,52), precede(52,53).
</equation>
<bodyText confidence="0.999871533333333">
The consti attributes in the type constructor xp
permits the satisfaction of the pending constraints
specified in the lexical entries. We view phrase
structure type constructors both as a descriptive and a
computational mean to construct structures. The
constraints has(role,X) and has(role,Y) impose that
the constituents const2 and const3 have a role
assigned at some level in the type construction
process. The same situation holds for case. This is a
simple expression, for example, of the Case Filter
and the 0-criterion in GB theory. Notice that most
pending situations are satisfied locally, which limits
complexity. Finally, notice that the denotation of this
type is the set of sentences S which can be
constructed and which meet the constraints.
</bodyText>
<subsectionHeader confidence="0.999758">
3.2 Expressing X-bar syntax
</subsectionHeader>
<bodyText confidence="0.909520454545455">
Our description language permits the expression of
most current versions of X-bar theory that we now
illustrate. X-bar syntax is a typical example of type
construction. Let us consider the rule:
X1 --&gt; X°, complement.
The element X° is a direct reference to the type
constructor x0, as described in the preceding section.
We now show how X1 is defined by the type
constructor xl; the nature of the complement is
induced from lexical descriptions given in x0:
x1( cat =&gt; C, bar =&gt; 1, string =&gt; 5,
</bodyText>
<equation confidence="0.564166333333333">
head =&gt;x0( cat =&gt; C, bar =&gt; 0, string =&gt; 51,
complement =&gt; Z: xp( cat =&gt; Compl,
bar =&gt; B1, role =&gt; R, satisfied =&gt; 1) ),
complement =&gt; xp( syntax =&gt; Z
case =&gt; Case, string =&gt; 52 ) ) :-
atom(R), atom(Ca),
precede(S 1 ,52),
C =/- inn, C=/= comp,
assign(C, Case).
</equation>
<bodyText confidence="0.9884604">
Notice how a co-reference link is established by
means of the variable Z between the
subcategorization frame given in the head and the
- 59 -
syntactic characteristics of the complement. The
subcategorization data is not left pending since it is
contiguous to the head and can be moved only by
another mean, namely, within GB theory, by move-
a. The subcategorization of a complement is satified
(i.e. satisfied =&gt; 1), the complement is assigned the
appropriate 0-role. Case is also assigned whenever
appropriate, by the call to assign_case.
Similar rules can be defined for X2 and adjuncts,
with the difference that adjuncts are usually not
obligatory. Rules involving non lexical categories
like INFL and COMP are described in the same
manner. However, at the level of INFL, the
assignment of the external 0-role and case to the
subject position is carried out using a long-distance
constraint, expressed in Dislog.
</bodyText>
<subsectionHeader confidence="0.997932">
3.3 On Government
</subsectionHeader>
<bodyText confidence="0.979632384615385">
The notion of Government in GB theory
introduces an interesting use of the constraint has to
control the well-formedness of a construction. We
now present a model for Government, so that 0-roles
and cases can be properly assigned. In what follows,
we refer to Government and to the notion of Barriers
as defined in (Chomsky 86).
Government can be modeled as a well-formedness
constraint on X2 categories. Indeed, each X2 which
can be a barrier (i.e. all categories except INFL)
prevents a category above it from governing a
category dominated by that X2. Thus, for all rules of
the general form:
Z --&gt; W, X2, T.
where Z, W and T are any kind of non-terminal
symbol, a control has to be made on the well-
formedness of X2 if X2 is a barrier. This control
consists in three constraints:
- every N2 is assigned a case (Case Filter in GB),
- every N2 is assigned a thematic role (0-criterion),
- all obligatory subcategorization has to be
satisfied (Projection Principle).
The two first constraints have been already given in
3.1, the latter is carried out by checking that the
following sub-W-term is not present in tN type
constructor x2 corresponding to the category Xh:
</bodyText>
<equation confidence="0.97476325">
xp( obi igatory =&gt; 1, satisfied =&gt; 0 )
which can be expressed by the negated constraint:
not(has(xp( obligatory =&gt; 1,
satisfied =&gt; 0 ),Type).
</equation>
<bodyText confidence="0.9999262">
The attribute obligatory comes from lexical
description where it is specified whether an
complement is obligatory or not. The attribute
satisfied is properly instanciated to 1 when a—
complement is constructed (see 3.2).
</bodyText>
<subsectionHeader confidence="0.994776">
3.4 On Long-Distance Dependencies
</subsectionHeader>
<bodyText confidence="0.999954235294118">
Let us finally consider an example of the
expression of long-distance dependencies for which
we use the pending constraint: wh-movement.
Refering to X-bar syntax, the general annotated
surface form is:
[comp PROi [N2 tracei ] ] as in:
[comp THATi John met [N2 tracei ] yesterday ]
Within the framework of our type-based approach,
a pending constraint specifies the co-occurence of two
type, constructions, which must be both used during
the type construction process associated to the
sentence being parsed. In our example, the first
subtype constructor will describe the adjunction of an
N2 to a COMP node (here COMPO) while the second
subtype constructor will express that that N2 is
constructed from a trace. A shared variable, I,
represents the co-indexation link:
</bodyText>
<equation confidence="0.9928025">
xp( cat =&gt; X: comp°, string =&gt; S,
constl =&gt; xp(cat =&gt; n, form =&gt; pro,
index =&gt; I, string =&gt; 51 ),
const2 =&gt; xp( cat =&gt; X , string =&gt; 52 ) ,
xp( cat =&gt; n, form =&gt; trace, string =&gt; 53,
index =&gt; I ) precede(5,53).
</equation>
<bodyText confidence="0.992471">
Since the adjunction to COMP is always to the left
of the trace, this Dislog clause can be translated into
a single type specification by means of the pending
constraint:
</bodyText>
<construct confidence="0.505917285714286">
xp(: cat =&gt; X: cOmpO, string =&gt; S,
const 1 =&gt; xp(cat =&gt; n, form =&gt; pro,
index =&gt; I, string =&gt; S1 ),
const2 =&gt; xp( cat =&gt; X , string =&gt; 52 )) :-
pending(xp(cat =&gt; comp0), xp( cat =&gt; n,
form =&gt; trace, string =&gt; 53, index =&gt; I ) ),
precede(5,53).
</construct>
<bodyText confidence="0.997354666666667">
To summarize, in lexical entries we express the
subcategorization requirements and the precedence
relations; in types expressing syntactic constructions,
we have controls on the contents of types and
pending constraints due to long-distance dependencies
between sentence constituents.
</bodyText>
<sectionHeader confidence="0.9558605" genericHeader="method">
4. An abstract machine for type
construction
</sectionHeader>
<bodyText confidence="0.999896615384616">
Parsing a sentence is constructing a well-formed
type describing the sentence structure. We present in
this section an abstract machine which describes how
types are constructed. This machine is based on the
procedural semantics of Prolog but it resembles a
push-down tree automaton whose stack is updated
each time a subtype is modified.
There are two kinds of type constructors: those
corresponding to non-terminal structures (such as xp
and xl in our examples) and those corresponding to
terminal structures (e.g. x0). We now present a step
in the construction of a type. It can be decomposed
into 3 levels:
</bodyText>
<listItem confidence="0.9609046">
(1) current state ai :
co( al =&gt; 4, a2 =&gt; t2, ..., an =&gt; tn),
- 60 -
(2) selection in the current programme P of a type
construction specification:
</listItem>
<equation confidence="0.755533">
c1( b1 =&gt;t1 bm =&gt; t&apos;m )
</equation>
<bodyText confidence="0.958088">
such that tl subsumes it (or unifies with it) modulo
the mgu 0.
</bodyText>
<listItem confidence="0.680165666666667">
(3) New state ai+ : 4 is replaced by:
ci( bi =&gt; byn =&gt; ),
with, as a result, the following type:
</listItem>
<equation confidence="0.6066875">
c.0( al =&gt; ci( b =&gt; bm =&gt; t&apos;m ) ,
a2 =&gt; an &amp;quot;-&gt; in) ei
</equation>
<bodyText confidence="0.93716968">
The process goes on and processes t . The type
construction strategy is here similar to Prolog&apos;s
strategy and computation rule : depth-first and from
left to right. The main difference at this level with
SLD-resolution is that only types corresponding to
non-terminal structures are expanded. Informally,
when a type ti corresponds to a terminal structure, an
attempt is male to find a terminal type description ei
in the programme which is subsumed by or unifies
with and, if so, a replacement occurs. e. is said to
bedoes final state. If t&apos;• not exist, backtracking
occurs.
The next type description immediately to the
right of ei is then treated in the same manner. The
type construction process successfully ends when all
subtypes corresponding to terminal symbols are in a
final state and it fails if a terminal type description tp
cannot reach a final state.
5. Extension of the abstract machine
to handle constraints
The above abstract machine can be extended in a
simple way to deal with constraints. Constraint
resolution mechanisms are similar to usual constraint
logic programming systems like Prolog HI. The
three above levels become:
</bodyText>
<listItem confidence="0.927659166666667">
(1) current state ai represented by the couple:
&lt; co( al =&gt; t1, a2 =&gt; t2, ..., an =&gt; tn), S &gt;
where S is the set of current constraints,
(2) selection in the current programme P of a type
construction specification:
c1( b1 =&gt;t&apos;1, bm =&gt; t&apos;m ) :- R. where R is
the set of constraints associated to el, and ti
subsumes (or unifies with) t&apos;1.
(3) New state ai+1 characterized by the
following couple:
&lt; co( ai =&gt; ci( bi =&gt; bm =&gt; t&apos;m ) ,
a2 =&gt; t2, ..., an =&gt; tn) ,
</listItem>
<bodyText confidence="0.966728625">
S uRu subsume(ti, c1( b1 =&gt; t&apos;1, . • .,
bm =&gt; t&apos;m ) ) &gt;
with the condition that the new set of constraints
must be satisfiable with respect to the constraint
resolution axioms defined for each type of constraint
and, if not, a backtracking occurs. At this level
constraints simplifications may also occur. Mgu Oi is
replaced here by the subsumption constraint.
</bodyText>
<sectionHeader confidence="0.930981" genericHeader="method">
6. A Constraint Logic Programming
</sectionHeader>
<bodyText confidence="0.917706095238095">
interpretation of the &apos;pending&apos;
constraint
The pending constraint is interpreted within the
Constraint Logic programming framework
(Colmerauer 90, Jaffar and Lassez 87) in a very
simple way. The constraint solving approach of the
CLP corresponds better to programming practice and
to programming language design. Constraints
directly state properties on objects of the domain
being dealt with which have to be always true, in
contrast to coding them by means of terms. The CLP
framework offers a global rule-based framework to
handle and to reason about constraints.
The domain of objects on which constraints of a
CLP interpretation of Dislog operate is a domain of
types. Let us first consider a simple translation
example of a Dislog clause into a CLP clause. A
Dislog clause like:
( a, b)
where a and b are type construction (TC)
specifications, is translated as follows in CLP:
</bodyText>
<figure confidence="0.778701">
a :- pending(a, [b]).
b pending(b, [a]).
</figure>
<bodyText confidence="0.937063315789474">
The constraint pending(A,B) states here that the
TC A is at the origin of the pending TC B. The
general case is interpreted as follows. Let us consider
the Dislog clause:
( A, B, N ).
it is translated into a set of CLP clauses as follows:
A :- pending(A, [8, ..., NJ ).
pending(B, [A, ..., NJ ).
N pending(N, [A, B, ).
The constraint resolution procedure associated to
pending consists in a simplification rule for the
elimination of pending TCs when the co-occurence
contraint is satisfied. This simplification rule is
written as follows for the simple example given
above in section 2:
pending(A,B)A pending(B,A)--&gt; 0 .
Notice that we have a symmetric treatment for A and
B. The general simplification rule is the following,
where LA, LB and LC are lists of pending TCs:
</bodyText>
<reference confidence="0.62726075">
(pending(A, LA), pending(B, LB) --&gt;
pending(A, LC) ):-
mb(A, LB), mb(6, LA),
Withdraw(B, LA, LC).
</reference>
<bodyText confidence="0.818200944444445">
LC is the resulting pending list equal to LA
minus B.
This constraint resolution mechanism can be
further extended quite straightforwardly to handle
linear precedence restrictions and modalities. Linear
precedence constraints, are dealt with independently
from each other. The Dislog clause:
- 61 -
( A, B, ..., X, ..., N ) ..., X &lt; Y ,
is translated into a CLP clause as follows:
X 0 pending(X, [A, B, Y, A not
(pending(Y,EA, B, ..., X, ..., ND).
The coherence control is the following:
pending(X, LA)Anot(pending(X, LA)) --&gt; failure.
the simplification rule is:
not (pending(Y, [A, B, ..., X, ..., )) --&gt; 0
or, more simply, since all negations are withdrawn at
each stage: not (pending(_,_) --&gt; 0.
</bodyText>
<sectionHeader confidence="0.695228" genericHeader="method">
7. Specific features of our approach
</sectionHeader>
<bodyText confidence="0.999874838709678">
Our approach can be contrasted mainly with the
usual systems based on unification grammar (UG)
formalisms. The first major difference is that the
unification and rewriting mechanisms usually
associated with UG are replaced by a more
constraining operation, type construction, which
always proceeds by sucessive restrictions (or
monotone increasing specialisation) each time a type
is further expanded. From that point of view, our
approach also substancially differs from (Emele &amp;
Zajac 90) who propose a powerful and semantically
clear mechanism for typed unification associated to
type inheritance.
Next, we have a single operation: type
construction; we do not have on the one hand
grammar rules and on the other hand, associated to
each rule, a set of equations to deal with feature
values and constraints. The constraints we have
associated with our types are not of the same nature
and cannot be compared to the equations of UGs.
They are moreover a part of the type.
Constraints added to types are interpreted within
the CLP framework, this permits us to have a more
expressive and powerful constraint system, which is
also more efficient and simpler to write. Constraint
satisfaction is not indeed guaranteed at the level they
are given, but throughout the whole type
construction process.
Our approach is compatible with the current
principled-based approaches to describing languages.
This is exemplified in section 4 by the constraints on
role and case assignments. In a more general way, the
description language we have presented here is
particularly appropriate for highly abstract
descriptions of language, which corresponds to
several current trends in computational linguistics.
Our description language is, in the same time, well-
adapted to deal with lexical-based approaches to
language processing (those approaches like lexicon
grammars where the lexicon plays a central role) and
to describe representations developed within lexical
semantics.
Finally, a constraint like pending generalises the
notion of long-distance dependency to several other
kinds of dependencies. This generalization is in
particular a consequence of the fact that type
structures do not have any ordering on subtypes and
they cannot, thus, directly express the difference
between remote and close constituents.
The abstract machine we have described gives a
clear procedural semantics to the system. A similar
machine can be defined for natural language
generation. Our description language has now being
fully implemented in Prolog on a SUN workstation
following the abstract machine description given
above. The fust version is an interpreter; a compiler
is under development. Experiments with GB theory
descriptions (Saint-Dizier 90) have been successfully
carried out. It is however important to notice that our
formalism is not specifically designed for GB theory
and that it can express with the same accuracy other
approaches such as HPSGs and lexicon grammars.
</bodyText>
<sectionHeader confidence="0.997635" genericHeader="acknowledgments">
Acknowledgements
</sectionHeader>
<bodyText confidence="0.865419">
This work owes much to discussions with Nabil
Hathout.This work was supported by the French
GRECO-PRC Communication Homme-Machine.
</bodyText>
<sectionHeader confidence="0.997509" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.987350263157895">
AR-Kagi, H., Nasr, R., LOGIN: A Logic
Programming Language with Built-in Inheritance,
journal of Logic Programming, vol. 3, pp 185-
215, 1986.
Chomsky, N., Barriers, Linguistic Inquiry
monograph nb. 13, MIT Press 1986.
Colmerauer, A., An Introduction to Prolog III,
CACM 33-7, 1990.
Emele, M., Zajac, R., Typed Unification Grammars,
in proc. COLING&apos;90, Helsinki, 1990.
Giinthner, F., Features and Values, Research Report
Univ of Tubingen, SNS 88-40, 1988.
Jaffar, J., Lassez, J.L., Constraint Logic
Programming, Proc. 14th ACM Symposium on
Principles of Programming Languages, 1987.
Johnson, M., Expressing Disjunctive and Negative
Feature Constraints with Classical First-Order
Logic, proc. ACL&apos;90, Pittsburgh, 1990.
Mukai, K., CIL: Complex Indeterminate Language,
Fifth Generation Computing journal, 1985.
Saint-Dizier, P., Contextual Discontinuous
Grammars, 2nd NLULP, Vancouver 1987 and in:
Natural Language Understanding and Logic
Programming II, V. Dahl and P. Saint-Dizier Edts,
North Holland, 1988.
Saint-Dizier, P., Constrained Logic Programming for
Natural Language Processing, proc. ACL-89,
Manchester, 1989.
Saint-Dizier, P., Modelling Move-ct and Government
by a typed-based approach, GB-Parsing workshop,
Geneva 1990.
Saint-Dizier, P., Condamines, A., An Intelligent
Environment for the Acquisition of Lexical Data,
proc. ACH/ALLC conference, Tempe AZ, 1991.
Sheiber, S., An Introduction to Unification-Based
Approaches to Grammar, CSL1 lecture notes no 4,
Chicago University Press, 1986.
- 62 -
</reference>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.769002">
<title confidence="0.9994195">Processing Language with Logical Types and Active Constraints</title>
<author confidence="0.999754">Patrick SAINT-DIZIER</author>
<affiliation confidence="0.952826">1RIT Universitd Paul Sabatier 118, route de Narbonne</affiliation>
<address confidence="0.999823">31062 Toulouse cedex FRANCE</address>
<email confidence="0.999741">e-mail:stdizier@irit.irit.fr</email>
<abstract confidence="0.982207272727273">In this document, we present a language which associates type construction principles to constraint logic programming. We show that it is very appropriate for language processing, providing more uniform, expressive and efficient tools and treatments. We introduce three kinds of constraints, that we exemplify by motivational examples. Finally, we give the procedural semantics of our language, combining type construction with SLDresolution.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="false">
<authors>
<author>pending</author>
</authors>
<journal>LB) --&gt; pending(A, LC) ):-</journal>
<marker>pending, </marker>
<rawString>(pending(A, LA), pending(B, LB) --&gt; pending(A, LC) ):-</rawString>
</citation>
<citation valid="false">
<authors>
<author>mb</author>
</authors>
<location>mb(6, LA), Withdraw(B, LA, LC).</location>
<marker>mb, </marker>
<rawString>mb(A, LB), mb(6, LA), Withdraw(B, LA, LC).</rawString>
</citation>
<citation valid="true">
<authors>
<author>H AR-Kagi</author>
<author>R Nasr</author>
</authors>
<title>LOGIN: A Logic Programming Language with Built-in Inheritance,</title>
<date>1986</date>
<journal>journal of Logic Programming,</journal>
<volume>3</volume>
<pages>185--215</pages>
<marker>AR-Kagi, Nasr, 1986</marker>
<rawString>AR-Kagi, H., Nasr, R., LOGIN: A Logic Programming Language with Built-in Inheritance, journal of Logic Programming, vol. 3, pp 185-215, 1986.</rawString>
</citation>
<citation valid="true">
<authors>
<author>N Chomsky</author>
<author>Barriers</author>
</authors>
<title>Linguistic Inquiry monograph nb. 13,</title>
<date>1986</date>
<publisher>MIT Press</publisher>
<marker>Chomsky, Barriers, 1986</marker>
<rawString>Chomsky, N., Barriers, Linguistic Inquiry monograph nb. 13, MIT Press 1986.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Colmerauer</author>
</authors>
<title>An Introduction to Prolog III,</title>
<date>1990</date>
<journal>CACM</journal>
<pages>33--7</pages>
<marker>Colmerauer, 1990</marker>
<rawString>Colmerauer, A., An Introduction to Prolog III, CACM 33-7, 1990.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Emele</author>
<author>R Zajac</author>
</authors>
<title>Typed Unification Grammars,</title>
<date>1990</date>
<booktitle>in proc. COLING&apos;90,</booktitle>
<location>Helsinki,</location>
<marker>Emele, Zajac, 1990</marker>
<rawString>Emele, M., Zajac, R., Typed Unification Grammars, in proc. COLING&apos;90, Helsinki, 1990.</rawString>
</citation>
<citation valid="true">
<authors>
<author>F Giinthner</author>
</authors>
<title>Features and Values,</title>
<date>1988</date>
<journal>Research Report Univ of Tubingen, SNS</journal>
<pages>88--40</pages>
<marker>Giinthner, 1988</marker>
<rawString>Giinthner, F., Features and Values, Research Report Univ of Tubingen, SNS 88-40, 1988.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Jaffar</author>
<author>J L Lassez</author>
</authors>
<date>1987</date>
<booktitle>Constraint Logic Programming, Proc. 14th ACM Symposium on Principles of Programming Languages,</booktitle>
<marker>Jaffar, Lassez, 1987</marker>
<rawString>Jaffar, J., Lassez, J.L., Constraint Logic Programming, Proc. 14th ACM Symposium on Principles of Programming Languages, 1987.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Johnson</author>
</authors>
<title>Expressing Disjunctive and Negative Feature Constraints with Classical First-Order Logic,</title>
<date>1990</date>
<booktitle>proc. ACL&apos;90,</booktitle>
<location>Pittsburgh,</location>
<marker>Johnson, 1990</marker>
<rawString>Johnson, M., Expressing Disjunctive and Negative Feature Constraints with Classical First-Order Logic, proc. ACL&apos;90, Pittsburgh, 1990.</rawString>
</citation>
<citation valid="true">
<authors>
<author>K Mukai</author>
</authors>
<title>CIL: Complex Indeterminate Language, Fifth Generation Computing journal,</title>
<date>1985</date>
<marker>Mukai, 1985</marker>
<rawString>Mukai, K., CIL: Complex Indeterminate Language, Fifth Generation Computing journal, 1985.</rawString>
</citation>
<citation valid="true">
<authors>
<author>P Saint-Dizier</author>
</authors>
<title>Contextual Discontinuous Grammars, 2nd NLULP,</title>
<date>1987</date>
<location>Vancouver</location>
<marker>Saint-Dizier, 1987</marker>
<rawString>Saint-Dizier, P., Contextual Discontinuous Grammars, 2nd NLULP, Vancouver 1987 and in: Natural Language Understanding and Logic Programming II, V. Dahl and P. Saint-Dizier Edts, North Holland, 1988.</rawString>
</citation>
<citation valid="true">
<authors>
<author>P Saint-Dizier</author>
</authors>
<title>Constrained Logic Programming for Natural Language</title>
<date>1989</date>
<booktitle>Processing, proc. ACL-89,</booktitle>
<location>Manchester,</location>
<marker>Saint-Dizier, 1989</marker>
<rawString>Saint-Dizier, P., Constrained Logic Programming for Natural Language Processing, proc. ACL-89, Manchester, 1989.</rawString>
</citation>
<citation valid="true">
<authors>
<author>P Saint-Dizier</author>
</authors>
<title>Modelling Move-ct and Government by a typed-based approach, GB-Parsing workshop,</title>
<date>1990</date>
<location>Geneva</location>
<marker>Saint-Dizier, 1990</marker>
<rawString>Saint-Dizier, P., Modelling Move-ct and Government by a typed-based approach, GB-Parsing workshop, Geneva 1990.</rawString>
</citation>
<citation valid="true">
<authors>
<author>P Saint-Dizier</author>
<author>A Condamines</author>
</authors>
<title>An Intelligent Environment for the Acquisition of Lexical Data,</title>
<date>1991</date>
<booktitle>proc. ACH/ALLC conference,</booktitle>
<location>Tempe AZ,</location>
<marker>Saint-Dizier, Condamines, 1991</marker>
<rawString>Saint-Dizier, P., Condamines, A., An Intelligent Environment for the Acquisition of Lexical Data, proc. ACH/ALLC conference, Tempe AZ, 1991.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S Sheiber</author>
</authors>
<title>An Introduction to Unification-Based Approaches to Grammar, CSL1 lecture notes no 4,</title>
<date>1986</date>
<publisher>Chicago University Press,</publisher>
<marker>Sheiber, 1986</marker>
<rawString>Sheiber, S., An Introduction to Unification-Based Approaches to Grammar, CSL1 lecture notes no 4, Chicago University Press, 1986.</rawString>
</citation>
<citation valid="false">
<pages>62</pages>
<marker></marker>
<rawString>- 62 -</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>