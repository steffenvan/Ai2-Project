<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000004">
<title confidence="0.999429">
A Polynomial-Time Parsing Algorithm for TT-MCTAG
</title>
<author confidence="0.904205">
Laura Kallmeyer
</author>
<affiliation confidence="0.726501">
Collaborative Research Center 441
</affiliation>
<address confidence="0.5517775">
Universit¨at T¨ubingen
T¨ubingen, Germany
</address>
<email confidence="0.988778">
lk@sfs.uni-tuebingen.de
</email>
<author confidence="0.996741">
Giorgio Satta
</author>
<affiliation confidence="0.957554666666667">
Department of Information Engineering
University of Padua
Padova, Italy
</affiliation>
<email confidence="0.994443">
satta@dei.unipd.it
</email>
<sectionHeader confidence="0.993797" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999692533333333">
This paper investigates the class of Tree-
Tuple MCTAG with Shared Nodes, TT-
MCTAG for short, an extension of Tree
Adjoining Grammars that has been pro-
posed for natural language processing, in
particular for dealing with discontinuities
and word order variation in languages such
as German. It has been shown that the uni-
versal recognition problem for this formal-
ism is NP-hard, but so far it was not known
whether the class of languages generated
by TT-MCTAG is included in PTIME. We
provide a positive answer to this ques-
tion, using a new characterization of TT-
MCTAG.
</bodyText>
<sectionHeader confidence="0.99899" genericHeader="introduction">
1 Introduction
</sectionHeader>
<bodyText confidence="0.999791126984127">
For a large range of linguistic phenomena, exten-
sions of Tree Adjoining Grammars (Joshi et al.,
1975), or TAG for short, have been proposed based
on the idea of separating the contribution of a lex-
ical item into several components. Instead of sin-
gle trees, these grammars contain (multi-)sets of
trees. Examples are tree-local and set-local mul-
ticomponent TAG (Joshi, 1985; Weir, 1988), MC-
TAG for short, non-local MCTAG with dominance
links (Becker et al., 1991), Vector-TAG with dom-
inance links (Rambow, 1994) and, more recently,
Tree-Tuple MCTAG with Shared Nodes (Lichte,
2007)), or TT-MCTAG for short.
For some of the above formalisms the word
recognition problem is NP-hard. This has been
shown for non-local MCTAG (Rambow and Satta,
1992), even in the lexicalized case (Champollion,
2007). Some others generate only polynomial lan-
guages but their generative capacity is too limited
to deal with all natural language phenomena. This
has been argued for tree-local and even set-local
MCTAG on the basis of scrambling data from lan-
guages such as German (Becker et al., 1992; Ram-
bow, 1994).
In this paper, we focus on TT-MCTAG (Lichte,
2007). So far, it has been shown that the univer-
sal recognition problem for TT-MCTAG is NP-
hard (Søgaard et al., 2007). A restriction on TT-
MCTAG has been proposed in (Kallmeyer and
Parmentier, 2008): with such a restriction, the uni-
versal recognition problem is still NP-hard, but
the class of generated languages is included in
PTIME, i.e., all these languages can be recognized
in deterministic polynomial time. In this paper, we
address the question of whether for general TT-
MCTAG, i.e., TT-MCTAG without the constraint
from (Kallmeyer and Parmentier, 2008), the class
of generated languages is included in PTIME. We
provide a positive answer to this question.
The TT-MCTAG definition from (Lichte, 2007;
Kallmeyer and Parmentier, 2008) imposes a con-
dition on the way different tree components from a
tree tuple in the grammar combine with each other.
This condition is formulated in terms of mapping
between argument and head trees, i.e., in order to
test such a condition one has to guess some group-
ing of the tree components used in a derivation into
instances of tree tuples from the grammar. This re-
sults in a combinatorial explosion of parsing anal-
yses. In order to obtain a polynomial parsing al-
gorithm, we need to avoid this effect.
On this line, we propose an alternative charac-
terization of TT-MCTAG that only requires (i) a
counting of tree components and (ii) the check of
some local conditions on these counts. This allows
for parsing in polynomial deterministic time.
TT-MCTAG uses so-called ‘parallel unordered’
rewriting. The first polynomial time parsing
results on this class were presented in (Ram-
bow and Satta, 1994; Satta, 1995) for some
string-based systems, exploiting counting tech-
niques closely related to those we use in this pa-
per. In contrast to string-based rewriting, the tree
</bodyText>
<page confidence="0.968931">
994
</page>
<note confidence="0.999636">
Proceedings of the 47th Annual Meeting of the ACL and the 4th IJCNLP of the AFNLP, pages 994–1002,
Suntec, Singapore, 2-7 August 2009. c�2009 ACL and AFNLP
</note>
<figure confidence="0.993216">
S
NP VP
V
laughs
VP
ADV VP∗
always
NP
NP VP
John ADV VP
always V
laughs
derivation tree:
laugh
1 2
john always
John
derived tree:
S
</figure>
<bodyText confidence="0.9997786">
rewriting formalisms we consider here are struc-
turally more complex and require specializations
of the above techniques. Polynomial parsing re-
sults for tree rewriting systems based on paral-
lel unordered rewriting have also been reported
in (Rambow, 1994; Rambow et al., 1995). How-
ever, in the approach proposed by these authors,
tree-based grammars are first translated into equiv-
alent string-based systems, and the result is again
provided on the string domain.
</bodyText>
<sectionHeader confidence="0.95128" genericHeader="method">
2 Tree Adjoining Grammars
</sectionHeader>
<bodyText confidence="0.985772763157895">
Tree Adjoining Grammars (Joshi et al., 1975) are
a formalism based on tree rewriting. We briefly
summarize here the relevant definitions and refer
the reader to (Joshi and Schabes, 1997) for a more
complete introduction.
Definition 1 A Tree Adjoining Grammar
(TAG) is a tuple G = (VN, VT, S, I, A) where
VN and VT are disjoint alphabets of non-terminal
and terminal symbols, respectively, S E VN is the
start symbol, and I and A are finite sets of initial
and auxiliary trees, respectively. ❑
Trees in I U A are called elementary trees. The
internal nodes in the elementary trees are labeled
with non-terminal symbols, the leaves with non-
terminal or terminal symbols. As a special prop-
erty, each auxiliary tree Q has exactly one of its
leaf nodes marked as the foot node, having the
same label as the root. Such a node is denoted by
Ft(Q). Leaves with non-terminal labels that are
not foot nodes are called substitution nodes.
In a TAG, larger trees can be derived from the
elementary trees by subsequent applications of the
operations substitution and adjunction. The sub-
stitution operation replaces a substitution node q
with an initial tree having root node with the same
label as q. The adjunction operation replaces
an internal node q in a previously derived tree -y
with an auxiliary tree Q having root node with the
same label as q. The subtree of -y rooted at q is
then placed below the foot node of Q. Only inter-
nal nodes can allow for adjunction, adjunction at
leaves is not possible. See figure 1 for an example
of a tree derivation.
Usually, a TAG comes with restrictions on the
two operations, specified at each node q by sets
Sbst(q) and Adj (q) listing all elementary trees
that can be substituted or adjoined, respectively.
Furthermore, adjunction at q might be obligatory.
</bodyText>
<figureCaption confidence="0.99873">
Figure 1: TAG derivation for John always laughs
</figureCaption>
<bodyText confidence="0.999697523809524">
TAG derivations are represented by derivation
trees that record the history of how the elemen-
tary trees are put together. A derivation tree is
an unordered tree whose nodes are labeled with
elements in I U A and whose edges are labeled
with Gorn addresses of elementary trees.1 Each
edge in a derivation tree stands for an adjunction
or a substitution. E.g., the derivation tree in fig-
ure 1 indicates that the elementary tree for John is
substituted for the node at address 1 and always is
adjoined at node address 2.
In the following, we write a derivation tree D
as a directed graph (V, E, r) where V is the set of
nodes, E C V x V is the set of arcs and r E V is
the root. For every v E V , Lab(v) gives the node
label and for every (v1, v2) E E, Lab((v1, v2))
gives the edge label.
A derived tree is the result of carrying out the
substitutions and the adjunctions in a derivation
tree, i.e., the derivation tree describes uniquely the
derived tree; see again figure 1.
</bodyText>
<sectionHeader confidence="0.998885" genericHeader="method">
3 TT-MCTAG
</sectionHeader>
<subsectionHeader confidence="0.999714">
3.1 Introduction to TT-MCTAG
</subsectionHeader>
<bodyText confidence="0.999652272727273">
For a range of linguistic phenomena, multicompo-
nent TAG (Weir, 1988) have been proposed, also
called MCTAG for short. The underlying motiva-
tion is the desire to split the contribution of a single
lexical item (e.g., a verb and its arguments) into
several elementary trees. An MCTAG consists of
(multi-)sets of elementary trees, called tree sets.
If an elementary tree from some set is used in a
derivation, then all of the remaining trees in the
set must be used as well. Several variants of MC-
TAGs can be found the literature, differing on the
</bodyText>
<footnote confidence="0.8557625">
1In this convention, the root address is a and the jth child
of a node with address p has address p · j.
</footnote>
<page confidence="0.99836">
995
</page>
<bodyText confidence="0.999594444444444">
specific definition of the derivation process.
The particular MCTAG variant we are con-
cerned with is Tree-Tuple MCTAG with Shared
Nodes, TT-MCTAG (Lichte, 2007). TT-MCTAG
were introduced to deal with free word order phe-
nomena in languages such as German. An exam-
ple is (1) where the argument es of reparieren pre-
cedes the argument der Mann of versucht and is
not adjacent to the predicate it depends on.
</bodyText>
<listItem confidence="0.4480635">
(1) ... dass es der Mann zu reparieren versucht
... that it the man to repair tries
</listItem>
<bodyText confidence="0.989388102040816">
‘... that the man tries to repair it’
A TT-MCTAG is slightly different from stan-
dard MCTAGs since each elementary tree set con-
tains one specially marked lexicalized tree called
the head, and all of the remaining trees in the set
function as arguments of the head. Furthermore, in
a TT-MCTAG derivation the argument trees must
either adjoin directly to their head tree, or they
must be linked in the derivation tree to an elemen-
tary tree that attaches to the head tree, by means
of a chain of adjunctions at root nodes. In other
words, in the corresponding TAG derivation tree,
the head tree must dominate the argument trees in
such a way that all positions on the path between
them, except the first one, must be labeled by ε.
This captures the notion of adjunction under node
sharing from (Kallmeyer, 2005).2
Definition 2 A TT-MCTAG is a tuple G = (VN,
VT, S, I, A, T ) where GT = (VN, VT, S, I, A) is
an underlying TAG and T is a finite set of tree
tuples of the form F = hγ,{β1, ... , βr}i where
γ ∈ (I ∪ A) has at least one node with a terminal
label, and β1, ... , βn ∈ A. ❑
For each F = hγ,{β1, ... , βr}i ∈ T , we call γ
the head tree and the βj’s the argument trees.
We informally say that γ and the βj’s belong to F,
and write |F |= r + 1.
As a remark, an elementary tree γ from the un-
derlying TAG GT can be found in different tree tu-
ples in G, or there could even be multiple instances
of such a tree within the same tree tuple F. In these
cases, we just treat these tree instances as distinct
trees that are isomorphic and have identical labels.
2The intuition is that, if a tree -y′ adjoins to some -y, its
root in the resulting derived tree somehow belongs both to -y
and -y′ or, in other words, is shared by them. A further tree Q
adjoining to this node can then be considered as adjoining to
-y, not only to -y′ as in standard TAG. Note that we assume that
foot nodes do not allow adjunctions, otherwise node sharing
would also apply to them.
For a given argument tree β in F, h(β) denotes the
head of β in F. For a given γ ∈ I∪A, a(γ) denotes
the set of argument trees of γ, if there are any, or
the empty set otherwise. Furthermore, for a given
TT-MCTAG G, H(G) is the set of head trees and
A(G) is the set of argument trees. Finally, a node
v in a derivation tree for G with Lab(v) = γ is
called a γ-node.
Definition 3 Let G = (VN, VT, S, I, A, T ) be
</bodyText>
<listItem confidence="0.8573065">
some TT-MCTAG. A derivation tree D =
hV, E, ri in the underlying TAG GT is licensed in
G if and only if the following conditions (MC) and
(SN-TTL) are both satisfied.
• (MC): For all F from G and for all γ1, γ2
in F, we have |{v  |v ∈ V, Lab(v) = γ1} |=
|{v  |v ∈ V, Lab(v) = γ2}|.
• (SN-TTL): For all β ∈ A(G) and n ≥ 1,
let v1, ... , vn ∈ V be pairwise different
h(β)-nodes, 1 ≤ i ≤ n. Then there are
pairwise different β-nodes u1, ... , un ∈ V ,
1 ≤ i ≤ n. Furthermore, for 1 ≤ i ≤
n, either hvi, uii ∈ E, or else there are
ui,1, ... , ui,k, k ≥ 2, with auxiliary tree la-
bels, such that ui = ui,k, hvi, ui,1i ∈ E and,
for 1 ≤ j ≤ k − 1, hui,j, ui,j+1i ∈ E with
</listItem>
<equation confidence="0.747748">
Lab(hui,j, ui,j+1i) = ε. �
</equation>
<bodyText confidence="0.999973541666667">
The separation between (MC) and (SN-TTL)
in definition 3 is motivated by the desire to
separate the multicomponent property that TT-
MCTAG shares with a range of related formalisms
(e.g., tree-local and set-local MCTAG, Vector-
TAG, etc.) from the notion of tree-locality with
shared nodes that is peculiar to TT-MCTAG.
Figure 2 shows a TT-MCTAG derivation for (1).
Here, the NPnom auxiliary tree adjoins directly to
versucht (its head) while the NPacc tree adjoins to
the root of a tree that adjoins to the root of a tree
that adjoins to reparieren.
TT-MCTAG can generate languages that, in
a strong sense, cannot be generated by Linear
Context-Free Rewriting Systems (Vijay-Shanker
et al., 1987; Weir, 1988), or LCFRS for
short. An example is the language of all strings
π(n[1] ... n[m])v[1] ... v[m] with m ≥ 1, π a per-
mutation, and n[i] = n is a nominal argument of
v[i] = v for 1 ≤ i ≤ m, i.e., these occurrences
come from the same tree set in the grammar. Such
a language has been proposed as an abstract de-
scription of the scrambling phenomenon as found
in German and other free word order languages,
</bodyText>
<page confidence="0.996928">
996
</page>
<figureCaption confidence="0.996121">
Figure 2: TT-MCTAG derivation of (1)
</figureCaption>
<figure confidence="0.968886666666667">
derivation tree:
reparieren
ε
versucht
ε
NPnom
1 ε
Mann NPacc
1
es
*( ) + * +
VP VP NPnom
VP∗ versucht , der Mann , {}
NPnom VP∗
* ( ) + * +
VP VP NPacc
zu reparieren , es , {}
NPacc VP∗
* α VP ( β1 VPv=− )+
,
v n VP∗ NA
* β2 VP (β3 VPv=− )+
,
v VP∗NAv=+ n VP∗NA
</figure>
<figureCaption confidence="0.998397">
Figure 3: TT-MCTAG
</figureCaption>
<bodyText confidence="0.999704901639345">
and cannot be generated by a LCFRS (Becker et
al., 1992; Rambow, 1994). Figure 3 reports a TT-
MCTAG for this language.
Concerning the other direction, at the time of
writing it is not known whether there are lan-
guages generated by LCFRS but not by TT-
MCTAG. It is well known that LCFRS is closed
under the finite-copy operator. This means that,
for any fixed k &gt; 1, if L is generated by a LCFRS
then the language {w  |w = uk, u ∈ L} can
also be generated by a LCFRS. We conjecture that
TT-MCTAG does not have such a closure prop-
erty. However, from a first inspection of the MC-
TAG analyses proposed for natural languages (see
Chen-Main and Joshi (2007) for an overview), it
seems that there are no important natural language
phenomena that can be described by LCFRS and
not by TT-MCTAG. Any construction involving
some kind of component stacking along the VP
projection such as subject-auxiliary inversion can
be modelled with TT-MCTAG. Unbounded extra-
position phenomena cannot be described with TT-
MCTAG but they constitute a problem for any lo-
cal formalism and so far the nature of these phe-
nomena is not sufficiently well-understood.
Note that, in contrast to non-local MCTAG, in
TT-MCTAG the trees coming from the same in-
stance of a tuple in the grammar are not required
to be added at the same time. TT-MCTAGs share
this property of ‘non-simultaneity’ with other vec-
tor grammars such as Unordered Vector Gram-
mars (Cremers and Mayer, 1973) and Vector-
TAG (Rambow, 1994), V-TAG for short, and it
is crucial for the polynomial parsing algorithm.
The non-simultaneity seems to be an advantage
when using synchronous grammars to model the
syntax-semantics interface (Nesson and Shieber,
2008). The closest formalism to TT-MCTAG is
V-TAG. However, there are fundamental differ-
ences between the two. Firstly, they make a dif-
ferent use of dominance links: In V-TAG domi-
nance links relate different nodes in the trees of
a tree set from the grammar. They present domi-
nance requirements that constrain the derived tree.
In TT-MCTAG, there are no dominance links be-
tween nodes in elementary trees. Instead, the node
of a head tree in the derivation tree must domi-
nate all its arguments. Furthermore, even though
TT-MCTAG arguments can adjoin with a delay
to their head, their possible adjunction site is re-
stricted with respect to their head. As a result,
one obtains a slight degree of locality that can
be exploited for natural language phenomena that
are unbounded only in a limited domain. This is
proposed in (Lichte and Kallmeyer, 2008) where
the fact that substitution nodes block argument ad-
junction to higher heads is used to model the lim-
ited domain of scrambling in German. V-TAG
does not have any such notion of locality. Instead,
it uses explicit constraints, so-called integrity con-
straints, to establish islands.
</bodyText>
<subsectionHeader confidence="0.937513">
3.2 An alternative characterization of
TT-MCTAG
</subsectionHeader>
<bodyText confidence="0.999971">
The definition of TT-MCTAG in subsection 3.1 is
taken from (Lichte, 2007; Kallmeyer and Parmen-
tier, 2008). The condition (SN-TTL) on the TAG
derivation tree is formulated in terms of heads and
arguments belonging together, i.e., coming from
the same tuple instance. For our parsing algo-
rithm, we want to avoid grouping the instances
of elementary trees in a derivation tree into tu-
ple instances. In other words, we want to check
whether a TAG derivation tree is a valid TT-
</bodyText>
<page confidence="0.984597">
997
</page>
<bodyText confidence="0.931700854166667">
and there is some
hv, vεi ∈ E with Lab(hv, vεi) = E and
7r(v, Q) ≤ 7r(vε, Q) ≤ 7r(v, Q) + 1.
Intuitively, condition (i) in lemma 1 captures the
fact that heads always dominate their arguments
in the derivation tree. Condition (ii)b states that,
if v is a Q-node and if v is not the only ‘pend-
ing’ Q-node in Dv, then all pending Q-nodes in
Dv, except v itself, must be below the root adjoin-
ing node. Here pending means that the node is
not matched to a head-node within Dv. Condition
(ii)c treats the case in which there are pending Q-
nodes in Dv for some node v whose label is neither
Q nor h(Q). Then the pending nodes must all be
below the root adjoining node. Finally, condition
(ii)d deals with the case of a h(Q)-node v where,
besides the Q-node that serves as an argument of
v, there are other pending Q-nodes in Dv. These
other pending Q-nodes must all be in DvE, where
vε is the (unique) root adjoining node, if it exists.
The argument of v might as well be below vε, and
then the number of pending Q-nodes in DvE is the
number of pending nodes in Dv, incremented by
1, since the argument of v is not pending in Dv
but it is pending in DvE. Otherwise, the argument
of v is a pending Q-node below some other daugh-
ter of v. Then the number of pending Q-nodes in
DvE is the same as in Dv.
PROOF We first show that (SN-TTL) implies both
(i) and (ii).
Condition (i): Assume that there is a v ∈ V
and a Q ∈ A(G) with 7r(v, Q) &lt; 0. Then for
some n and for pairwise different v1, ... , vn with
hv, vii ∈ E∗, Lab(vi) = h(Q) (1 ≤ i ≤ n),
we cannot find pairwise different u1, ... , un with
hvi, uii ∈ E∗, Lab(ui) = Q. This is in contradic-
tion with (SN-TTL). Consequently, condition (i)
must be satisfied.
Condition (ii): Assume Q and v as in the state-
ment of the lemma, with 7r(v, Q) &gt; 0. Let
v1, ... , vn be all the h(Q)-nodes in D. There
is a bijection fβ from these nodes to n pairwise
distinct Q-nodes in D, such that every pair vi,
fβ(vi) = ui satisfies the conditions in (SN-TTL).
Because of (MC), the nodes u1, ... , un must be
all the Q-nodes in D. There must be at least one vi
(1 ≤ i ≤ n) with hvi, vi ∈ E+, hv, fβ(vi)i ∈ E∗.
Then we have one of the following cases.
</bodyText>
<listItem confidence="0.638255">
(a) ui = v and vi is the only h(Q)-node dominat-
ing v with a corresponding Q-node dominated by
v. In this case (ii)a holds.
(b) Lab(v) = Q, i.e., hf−1
β (v), vi ∈ E+ and there
are other nodes u ∈ Dom(v, Q), u =6 v with
hf−1
β (u), vi ∈ E+. Then, with (SN-TTL), there
must be a vε with hv, vεi ∈ E, Lab(hv, vεi) = E
and for all such nodes u, hvε, ui ∈ E∗. Conse-
quently, (ii)b holds.
(c) Lab(v) ∈� {Q, h(Q)}. Then, as in (b), there
must be a vε with hv, vεi ∈ E, Lab(hv, vεi) = E
and for all u ∈ Dom(v, Q) with hf−1
</listItem>
<equation confidence="0.495836">
β (u), vi ∈
E+, hvε, ui ∈ E∗. Consequently, (ii)c holds.
</equation>
<listItem confidence="0.788348111111111">
(d) Lab(v) = h(Q). If fβ(v) is dominated by a vε
that is a daughter of v with Lab(hv, vεi) = E, then
for all u ∈ Dom(v, Q) with hf−1
β (u), vi ∈ E+
we have hvε, ui ∈ E∗. Consequently, 7r(vε, Q) =
7r(v, Q) + 1. Alternatively, fβ(v) is dominated by
some other daughter v′ of v with Lab(hv, v′i) =6
E. In this case vε must still exist and, for all
u ∈ Dom(v,Q) with u =6 fβ(v) and with
</listItem>
<equation confidence="0.853935">
hf−1
β (u), vi ∈ E+, we have hvε, ui ∈ E∗. Conse-
quently, 7r(vε, Q) = 7r(v, Q).
</equation>
<bodyText confidence="0.965745692307692">
Now we show that (i) and (ii) imply (SN-TTL).
With (MC), the number of Q-nodes and h(Q)-
nodes in V are the same, for every Q ∈ A(G). For
every Q ∈ A(G), we construct a bijection fβ of the
MCTAG derivation tree without deciding, for ev-
ery occurrence of some argument Q, which of the
h(Q)-nodes represents its head. Therefore we pro-
pose to reformulate (SN-TTL).
For a node v in a derivation tree D, we write
Dv to represent the subtree of D rooted at v. For
ry ∈ (I ∪ A), we define Dom(v, -y) as the set of
nodes of Dv that are labeled by &apos;y. Furthermore,
for an argument tree Q ∈ A(G), we let 7r(v, Q) =
</bodyText>
<figure confidence="0.9192026">
|Dom(v, Q) |− |Dom(v, h(Q))|
.
Lemma 1 Let G be a TT-MCTAG with underlying
TAG GT, and let D = hV, E, ri be a derivation
tree in GT that satisfies (MC). D satisfies (SN-
TTL) if and only if, for every v ∈ V and every
Q ∈ A(G), the following conditions both hold.
(i) 7r(v, Q) ≥ 0.
(ii) If 7r(v, Q) &gt; 0, then one of the following con-
ditions must be satisfied:
(a) Lab(v) = Q and 7r(v, Q) = 1;
(b) Lab(v) = Q and 7r(v, Q) &gt; 1, and there
is some hv, vεi ∈ E with Lab(hv, vεi) =
E and 7r(vε, Q) + 1 = 7r(v, Q);
(c) Lab(v) ∈� {Q, h(Q)} and there is some
hv, vεi ∈ E with
//��Lab (hv, vεi) = E and
//��
7r (vε, N) = 7r (v,0)
(d) Lab(v) = h(Q)
</figure>
<page confidence="0.991152">
998
</page>
<bodyText confidence="0.956696833333333">
same type as in the first part of the proof, and show
that (SN-TTL) is satisfied. To construct fβ, for ev-
ery v ∈ V we define sets Vβ,v ⊆ Dom(v, Q) of Q-
nodes vβ that have a matching head fβ(vβ) domi-
nating v. The definition satisfies |Vβ,v |= 7r(v, Q).
For every v with v1, ... , vn being all its daughters:
</bodyText>
<listItem confidence="0.964064315789474">
a) If Lab(v) = Q, then (by (ii)) for every 1 ≤ j ≤
n with Lab(hv, vji) =6 E, Vβ,vj = ∅. If there is a
vi with Lab(hv, vii) = E, then Vβ,v = Vβ,vi ∪ {v},
else Vβ,v = {v}.
b) If Lab(v) ∈� {Q, h(Q)}, then (by (ii)) Vβ,vj = ∅
for every 1 ≤ j ≤ n with Lab(hv, vji) =6 E. If
there is a vi with Lab(hv, vii) = E, then Vβ,v =
Vβ,vi, else Vβ,v = ∅.
c) If Lab(v) = h(Q), then there must be some i,
1 ≤ i ≤ n, such that Vβ,vi =6 ∅. We need to
distinguish two cases. In the first case we have
Lab(hv, vii) =6 E, |Vβ,vi |= 1 and, for every
1 ≤ j ≤ n with j =6 i, either Vβ,vj = ∅ or
Lab(hv, vji) = E. In this case we define fβ(v) =
v′ for {v′} = Vβ,vi. In the second case we have
Lab(hv, vii) = E and, for every 1 ≤ j ≤ n with
j =6 i, Vβ,vj = ∅. In this case we pick an arbitrary
v′ ∈ Vβ,vi and let fβ(v) = v′. In both cases we let
Vβ,v = (Uni�1 Vβ,vi) \ {fβ(v)}.
</listItem>
<bodyText confidence="0.999008">
With this mapping, (SN-TTL) is satisfied when
choosing for each h(Q)-node vi the Q-node ui =
fβ(vi) as its corresponding node.
</bodyText>
<sectionHeader confidence="0.968114" genericHeader="method">
4 Parsing algorithm
</sectionHeader>
<bodyText confidence="0.999983">
In this section we present a recognition algorithm
for TT-MCTAG working in polynomial time in the
size of the input string. The algorithm can be eas-
ily converted into a parsing algorithm. The ba-
sic idea is to use a parsing algorithm for TAG,
and impose on-the-fly additional restrictions on
the underlying derivation trees that are being con-
structed, in order to fulfill the definition of valid
TT-MCTAG derivation. To simplify the presenta-
tion, we assume without loss of generality that all
elementary trees in our grammars are binary trees.
The input string has the form w = a1 · · · an with
each ai ∈ VT and n ≥ 0 (n = 0 means w = E).
</bodyText>
<subsectionHeader confidence="0.976114">
4.1 TAG recognition
</subsectionHeader>
<bodyText confidence="0.99963669047619">
We start with the discussion of a baseline recogni-
tion algorithm for TAG, along the lines of (Vijay-
Shanker and Joshi, 1985). The algorithm is
specified by means of deduction rules, follow-
ing (Shieber et al., 1995), and can be implemented
using standard tabular techniques. Items have the
form [-y, pt, i, f1, f2, j] where -y ∈ I ∪ A, p is the
address of a node in -y, subscript t ∈ {⊤, ⊥} speci-
fies whether substitution or adjunction has already
taken place (⊤) or not (⊥) at p, and 0 ≤ i ≤ f1 ≤
f2 ≤ j ≤ n are indices with i, j indicating the left
and right edges of the span recognized by p and
f1, f2 indicating the span of a gap in case a foot
node is dominated by p. We write f1 = f2 = − if
no gap is involved. For combining indices, we use
the operator f′⊕f″= f where f = f′ if f″= −,
f = f″if f′ = −, and f is undefined otherwise.
The deduction rules are shown in figure 4.
The algorithm walks bottom-up on the deriva-
tion tree. Rules (1) and (2) process leaf nodes
in elementary trees and require precondition
Lab(-y, p) = wi+1 and Lab(-y, p) = E, respec-
tively. Rule (3) processes the foot node of aux-
iliary tree Q ∈ A by guessing the portion of w
spanned by the gap. Note that we use pT in the
consequent item in order to block adjunction at
foot nodes, as usually required in TAG.
We move up along nodes in an elementary
tree by means of rules (4) and (5), depending on
whether the current node has no sibling or has a
single sibling, respectively.
Rule (6) substitutes initial tree a at p in -y, un-
der the precondition a ∈ Sbst(-y, p). Similarly,
rule (7) adjoins auxiliary tree Q at p in -y, under the
precondition Q ∈ Adj (-y, p). Both these rules use
pT in the consequent item in order to block mul-
tiple adjunction or substitution at p, as usually re-
quired in TAG. Rule (8) processes nodes at which
adjunction is not obligatory.
The algorithm recognizes w if and only if some
item [a, ET, 0, −, −, n] can be inferred with a ∈ I
and Lab(a, E) = S.
</bodyText>
<subsectionHeader confidence="0.925736">
4.2 TT-MCTAG recognition
</subsectionHeader>
<bodyText confidence="0.999976461538462">
We now extend the recognition algorithm of fig-
ure 4 to TT-MCTAG. Let G be an input TT-
MCTAG. We assume that the tuples in T are num-
bered from 1 to |T |, and that the elementary trees
in each Fi are also numbered from 1 to |Fi|, with
the first element being the head. We then write -yq,r
for the r-th elementary tree in the q-th tuple in T .
A t-counter is a ragged array T of integers with
primary index q ranging over {1, ... , |T |} and
with secondary index r ranging over {1, ... , |Fi|}.
We write T(q,r) to denote the t-counter with
T [q, r] = 1 and zero everywhere else. We also use
the sum and the difference of t-counters, which are
</bodyText>
<page confidence="0.968657">
999
</page>
<equation confidence="0.91599275">
[γ,(p · 1)⊤,i, f1, f2,j] (4)
[γ, p⊥, i, f1, f2, j]
[γ, (p · 1)⊤, i, f1, f2, k]
[γ, (p · 2)⊤, k, f′1, f′2, j]
(7)
(5)
[γ, p⊥, i, f1 ⊕ f′1, f2 ⊕ f′2, j]
[α, ε⊤, i, −, −, j] [γ, p⊤, i, −, −, j](6)
[β, ε⊤, i, f1, f2, j]
[γ, p⊥, f1, f′1, f′2, f2]
[γ, p⊤, i, f′1, f′2, j]
[γ, p⊥, i, f1, f2, j] (8)
[γ, p⊤, i, f1, f2, j]
[γ, p⊥, i, −, −, i+ 1]
[γ, p⊥, i, −,−, i]
[β, Ft(β)⊤, i, i, j,j]
</equation>
<figureCaption confidence="0.9958945">
Figure 4: A baseline recognition algorithm for TAG. Rule preconditions and goal item are described in
the text.
</figureCaption>
<equation confidence="0.996344588235294">
(9)
[γq,r, p⊥, i, −, −, i + 1, T (q,r)]
[γq,r, (p · 1)⊤, i, f1, f2, k, T1]
[γq,r, (p· 2)⊤, k, f′1, f′2, j, T2] (13)
[γq,r, p⊥, i, f1 ⊕ f′1, f2 ⊕ f′2, j, T1 + T2 − T(q,r)]
[γq,r, p⊥, i, −, −, i, T(q,r)] (10)
[γq,r,Ft(γq,r)⊤,i, i,j, j,T( q,r)] (11)
[γq,r, (p · 1)⊤, i, f1, f2, j, T] (12)
[γq,r,p⊥,i, f1, f2, j, T]
[γq′,r′,ε⊤,i, −,−,j, T′] (14)
[γq,r,p⊤,i, −,−,j,T′ + T(q,r)]
[γq′,r′,ε⊤,i, f1, f2,j, T ′]
[γq,r, p⊥, f1, f′ 1, f′2, f2, T]
[γq,r, p⊤, i, f′1, f′2, j, T + T′]
[γ, p⊥, i, f1, f2, j, T] (16)
[γ, p⊤, i, f1, f2, j, T]
(15)
</equation>
<figureCaption confidence="0.9701555">
Figure 5: A recognition algorithm for TT-MCTAG. Rule preconditions are the same as for figure 4,
filtering conditions on rules are described in the text.
</figureCaption>
<bodyText confidence="0.999099321428572">
defined elementwise in the obvious way.
Let D be a derivation tree generated by the TAG
underlying G. We associate D with the t-counter
T such that T [q, r] equals the count of all occur-
rences of elementary tree γq,r appearing in D. In-
tuitively, we use t-counters to represent informa-
tion about TAG derivation trees that are relevant
to the licensing of such trees by the input TT-
MCTAG G.
We are now ready to present a recognizer based
on TT-MCTAG. To simplify the presentation, we
first discuss how to extend the algorithm of fig. 4
in order to compute t-counters, and will later spec-
ify how to apply TT-MCTAG filtering conditions
through such counters. The reader should however
keep in mind that the two processes are strictly
interleaved, with filtering conditions being tested
right after the construction of each new t-counter.
We use items of the form [γq,r, p�, i, f1, f2, j,
T], where the first six components are defined as
in the case of TAG items, and the last component is
a t-counter associated with the constructed deriva-
tions. Our algorithm is specified in figure 5.
The simplest case is that of rules (12) and (16).
These rules do not alter the underlying derivation
tree, and thus the t-counter is simply copied from
the antecedent item to the consequent item.
Rules (9), (10) and (11) introduce γq,r as the
first elementary tree in the analysis (γq,r ∈ A in
case of rule (11)). Therefore we set the associated
t-counter to T(q,r).
In rule (14) we substitute initial tree γq′,r′ at
node p in γq,r. In terms of derivation structures,
we extend a derivation tree D′ rooted at node v′
with Lab(v′) = γq′,r′ to a new derivation tree D
with root node v, Lab(v) = γq,r. Node v has a sin-
gle child represented by the root of D′. Thus the
t-counter associated with D should be T′ + T (q,r).
A slightly different operation needs to be per-
formed when applying rule (15). Here we have
a derivation tree D with root node v, Lab(v) =
γq,r and a derivation tree D′ with root node v′,
Lab(v′) = γq′,r′. When adjoining γq′,r′ into γq,r,
we need to add to the root of D a new child node,
represented by the root of D′. This means that
the t-counter associated with the consequent item
should be the sum of the t-counters associated with
D and D′.
Finally, rule (13) involves derivation trees D1
and D2, rooted at nodes v1 and v2, respectively.
Nodes v1 and v2 have the same label γq,r. The ap-
plication of the rule corresponds to the ‘merging’
of v1 and v2 into a new node v with label γq,r as
well, Node v inherits all of the children of v1 and
v2. In this case the t-counter associated with the
consequent item is T1 + T2 − T (q,r). Here T (q,r)
</bodyText>
<page confidence="0.95125">
1000
</page>
<bodyText confidence="0.9993029375">
needs to be subtracted because the contribution of
tree ryq,r is accounted for in both v1 and v2.
We can now discuss the filtering conditions that
need to be applied when using the above deduc-
tion rules. We start by observing that the algo-
rithm in figure 5 might not even stop if there is an
infinite set of derivation trees for the input string
w = a1 · · · a,,, in the underlying TAG GT. This
is because each derivation can have a distinct t-
counter. However, the definition of TT-MCTAG
imposes that the head tree of each tuple contains
at least one lexical element. Together with con-
dition (MC), this implies that no more than n tu-
ple instances can occur in a derivation tree for w
according to G. To test for such a condition, we
introduce a norm for t-counters
</bodyText>
<equation confidence="0.9432635">
Γ
maxr 91 T [q, r]
</equation>
<bodyText confidence="0.999972">
We then impose ||T ||m &lt; n for each t-counter con-
structed by our deduction rule, and block the cor-
responding derivation if this is not satisfied.
We also need to test conditions (i) and (ii) from
lemma 1. Since these conditions apply to nodes
of the derivation tree, this testing is done at each
deduction rule in which a consequent item may be
constructed for a node ET, that is, rules (14), (15)
and (16). We introduce two specialized predicates
</bodyText>
<equation confidence="0.9810735">
F&lt;(T) = b(q, r) T [q,1] &lt; T [q, r] �
F=(T) = b(q, r) T [q, 1] = T [q, r] �
</equation>
<bodyText confidence="0.988644588235294">
We then test F&lt;(T), which amounts to testing
condition (i) for each argument tree in A(G).
Furthermore, if at some rule we have F&lt;(T) n
-,F=(T), then we need to test for condition (ii).
To do this, we consider each argument tree ryq,r,
r =� 1, and compare the elementary tree ryq,r in the
consequent item of the current rule with ryq,r and
h(ryq,r) = ryq,1, to select the appropriate subcondi-
tion of (ii).
As an example, assume that we are applying
rule (15) as in figure 5, with p = E. Let T, =
T + T′ be the t-counter associated with the con-
sequent item. When we come to process some ar-
gument tree ryq,r such that T,[q, r] − T,[q,1] &gt; 0
and ryq,r E� {ryq,r, ryq,11, we need to test (ii)c. This
is done by requiring
T′[q, r] − T′[q,1] = T,[q, r] − T,[q,1]�
If we are instead applying rule (16) with p = E
and T [q, r] − T [q, 1] &gt; 0, then we test (ii)a, since
there is no adjunction at the root node, by requir-
ing ryq,r = ryq,r and T [q, r] − T [q, 1] = 1.
We block the current derivation whenever the
conditions in lemma 1 are not satisfied.
The algorithm recognizes w if and only if some
item [ryq,1, ET, 0, −, −, n, T] can be inferred sat-
isfying ryq,1 E I, Lab(ryq,1, E) = 5 and F=(T).
The correctness immediately follows from the cor-
rectness of the underlying TAG parser and from
lemma 1.
Finally, we turn to the computational analysis
of the algorithm. We assume a tabular implemen-
tation of the process of item inference using our
deduction rules. Our algorithm clearly stops after
some finite amount of time, because of the filtering
condition ||T||m &lt; n. We then need to derive an
upper bound on the number of applications of de-
duction rules. To do this, we use an argument that
is rather standard in the tabular parsing literature.
The number of t-counters satisfying ||T||m &lt; n
is O(n&apos;G), with cG = �|T |
Z=1 |rZ|. Since all of
the other components in an item are bounded by
O(n4), there are polynomially (in n) many items
that can be constructed for an input w. It is not dif-
ficult to see that each individual item can be con-
structed by a number of rule applications bounded
by a polynomial as well. Therefore, the total num-
ber of applications of our deduction rules is also
bounded by some polynomial in n. We thus con-
clude that the languages generated by the class TT-
MCTAG are all included in PTIME.
</bodyText>
<sectionHeader confidence="0.982661" genericHeader="conclusions">
5 Conclusion and open problems
</sectionHeader>
<bodyText confidence="0.999972636363636">
We have shown in this paper that the class of lan-
guages generated by TT-MCTAG is included in
PTIME, by characterizing the definition of TT-
MCTAG through some conditions that can be
tested locally. PTIME is one of the required
properties in the definition of the class of Mildly
Context-Sensitive (MCS) formalisms (Joshi et al.,
1991). In order to settle membership in MCS for
TT-MCTAG, what is still missing is the constant-
growth property or, more generally, the semilin-
earity property.
</bodyText>
<sectionHeader confidence="0.998287" genericHeader="acknowledgments">
Acknowledgments
</sectionHeader>
<bodyText confidence="0.9706944">
The work of the first author has been sup-
ported by the DFG within the Emmy-Noether
Program. The second author has been partially
supported by MIUR under project PRIN No.
2007TJNZRE 002.
</bodyText>
<equation confidence="0.9776945">
||T||m = � |T |
q=1
</equation>
<page confidence="0.975774">
1001
</page>
<sectionHeader confidence="0.995832" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999949065420561">
Tilman Becker, Aravind K. Joshi, and Owen Rambow.
1991. Long-distance scrambling and tree adjoining
grammars. In Proceedings ofACL-Europe.
Tilman Becker, Owen Rambow, and Michael Niv.
1992. The Derivationel Generative Power of Formal
Systems or Scrambling is Beyond LCFRS. Tech-
nical Report IRCS-92-38, Institute for Research in
Cognitive Science, University of Pennsylvania.
Lucas Champollion. 2007. Lexicalized non-local MC-
TAG with dominance links is NP-complete. In Ger-
ald Penn and Ed Stabler, editors, Proceedings of
Mathematics ofLanguage (MOL) 10, CSLI On-Line
Publications.
Joan Chen-Main and Aravind Joshi. 2007. Some
observations on a graphical model-theoretical ap-
proach and generative models. In Model Theoretic
Syntax at 10. Workshop, ESSLLI2007, Dublin, Ire-
land.
Armin B. Cremers and Otto Mayer. 1973. On matrix
languages. Information and Control, 23:86–96.
Aravind K. Joshi and Yves Schabes. 1997. Tree-
Adjoning Grammars. In G. Rozenberg and A. Salo-
maa, editors, Handbook ofFormal Languages, pages
69–123. Springer, Berlin.
Aravind K. Joshi, Leon S. Levy, and Masako Taka-
hashi. 1975. Tree Adjunct Grammars. Journal of
Computer and System Science, 10:136–163.
A. Joshi, K. Vijay-Shanker, and D. Weir. 1991. The
convergence of mildly context-sensitive grammati-
cal formalisms. In P. Sells, S. Shieber, and T. Wa-
sow, editors, Foundational Issues in Natural Lan-
guage Processing. MIT Press, Cambridge MA.
Aravind K. Joshi. 1985. Tree adjoining grammars:
How much contextsensitivity is required ro provide
reasonable structural descriptions? In D. Dowty,
L. Karttunen, and A. Zwicky, editors, Natural Lan-
guage Parsing, pages 206–250. Cambridge Univer-
sity Press.
Laura Kallmeyer and Yannick Parmentier. 2008. On
the relation between Multicomponent Tree Adjoin-
ing Grammars with Tree Tuples (TT-MCTAG) and
Range Concatenation Grammars (RCG). In Carlos
Martin-Vide, Friedrich Otto, and Henning Fernaus,
editors, Language and Automata Theory and Ap-
plications. Second International Conference, LATA
2008, number 5196 in Lecture Notes in Computer
Science, pages 263–274. Springer-Verlag, Heidel-
berg Berlin.
Laura Kallmeyer. 2005. Tree-local multicomponent
tree adjoining grammars with shared nodes. Com-
putational Linguistics, 31(2):187–225.
Timm Lichte and Laura Kallmeyer. 2008. Factorizing
Complementation in a TT-MCTAG for German. In
Proceedings of the Ninth International Workshop on
Tree Adjoining Grammars and Related Formalisms
(TAG+9), pages 57–64, T¨ubingen, June.
Timm Lichte. 2007. An MCTAG with Tuples for Co-
herent Constructions in German. In Proceedings
of the 12th Conference on Formal Grammar 2007,
Dublin, Ireland.
Rebecca Nesson and Stuart Shieber. 2008. Syn-
chronous Vector TAG for Syntax and Semantics:
Control Verbs, Relative Clauses, and Inverse Link-
ing. In Proceedings of the Ninth International Work-
shop on Tree Adjoining Grammars and Related For-
malisms (TAG+9), T¨ubingen, June.
Owen Rambow and Giorgio Satta. 1992. Formal prop-
erties of non-locality. In Proceedings of 1st Interna-
tional Workshop on Tree Adjoining Grammars.
Owen Rambow and Giorgio Satta. 1994. A rewrit-
ing system for free word order syntax that is non-
local and mildly context sensitive. In C. Martin-
Vide, editor, Current Issues in Mathematical Lin-
guistics, North-Holland Linguistic series, Volume
56. Elsevier-North Holland, Amsterdam.
Owen Rambow, K. Vijay-shanker, and David Weir.
1995. Parsing d-Ttree grammars. In Proceedings of
the Fourth International Workshop on Parsing Tech-
nologies, Prague, pages 252–259.
Owen Rambow. 1994. Formal and Computational
Aspects of Natural Language Syntax. Ph.D. thesis,
University of Pennsylvania.
Giorgio Satta. 1995. The membership problem for un-
ordered vector languages. In Developments in Lan-
guage Theory, pages 267–275.
Stuart M. Shieber, Yves Schabes, and Fernando C. N.
Pereira. 1995. Principles and Implementation of
Deductive Parsing. Journal of Logic Programming,
24(1&amp;2):3–36.
Anders Søgaard, Timm Lichte, and Wolfgang Maier.
2007. The complexity of linguistically motivated
extensions of tree-adjoining grammar. In Recent
Advances in Natural Language Processing 2007,
Borovets, Bulgaria.
K. Vijay-Shanker and Aravind K. Joshi. 1985. Some
computational properties of Tree Adjoining Gram-
mars. In Proceedings of the 23rd Annual Meeting
of the Association for Computational Linguistics,
pages 82–93.
K. Vijay-Shanker, D. J. Weir, and A. K. Joshi. 1987.
Characterizing structural descriptions produced by
various grammatical formalisms. In 25th Meet-
ing of the Association for Computational Linguistics
(ACL’87).
David J. Weir. 1988. Characterizing mildly context-
sensitive grammar formalisms. Ph.D. thesis, Uni-
versity of Pennsylvania.
</reference>
<page confidence="0.995283">
1002
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.434176">
<title confidence="0.999884">A Polynomial-Time Parsing Algorithm for TT-MCTAG</title>
<author confidence="0.99993">Laura Kallmeyer</author>
<affiliation confidence="0.9749955">Collaborative Research Center 441 Universit¨at T¨ubingen</affiliation>
<address confidence="0.9763">T¨ubingen, Germany</address>
<email confidence="0.998836">lk@sfs.uni-tuebingen.de</email>
<author confidence="0.999811">Giorgio Satta</author>
<affiliation confidence="0.9996625">Department of Information Engineering University of Padua</affiliation>
<address confidence="0.98255">Padova, Italy</address>
<email confidence="0.998894">satta@dei.unipd.it</email>
<abstract confidence="0.9887796">This paper investigates the class of Tree- Tuple MCTAG with Shared Nodes, TT- MCTAG for short, an extension of Tree Adjoining Grammars that has been proposed for natural language processing, in particular for dealing with discontinuities and word order variation in languages such as German. It has been shown that the universal recognition problem for this formalism is NP-hard, but so far it was not known whether the class of languages generated by TT-MCTAG is included in PTIME. We provide a positive answer to this question, using a new characterization of TT-</abstract>
<intro confidence="0.51692">MCTAG.</intro>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Tilman Becker</author>
<author>Aravind K Joshi</author>
<author>Owen Rambow</author>
</authors>
<title>Long-distance scrambling and tree adjoining grammars.</title>
<date>1991</date>
<booktitle>In Proceedings ofACL-Europe.</booktitle>
<contexts>
<context position="1323" citStr="Becker et al., 1991" startWordPosition="201" endWordPosition="204"> languages generated by TT-MCTAG is included in PTIME. We provide a positive answer to this question, using a new characterization of TTMCTAG. 1 Introduction For a large range of linguistic phenomena, extensions of Tree Adjoining Grammars (Joshi et al., 1975), or TAG for short, have been proposed based on the idea of separating the contribution of a lexical item into several components. Instead of single trees, these grammars contain (multi-)sets of trees. Examples are tree-local and set-local multicomponent TAG (Joshi, 1985; Weir, 1988), MCTAG for short, non-local MCTAG with dominance links (Becker et al., 1991), Vector-TAG with dominance links (Rambow, 1994) and, more recently, Tree-Tuple MCTAG with Shared Nodes (Lichte, 2007)), or TT-MCTAG for short. For some of the above formalisms the word recognition problem is NP-hard. This has been shown for non-local MCTAG (Rambow and Satta, 1992), even in the lexicalized case (Champollion, 2007). Some others generate only polynomial languages but their generative capacity is too limited to deal with all natural language phenomena. This has been argued for tree-local and even set-local MCTAG on the basis of scrambling data from languages such as German (Becke</context>
</contexts>
<marker>Becker, Joshi, Rambow, 1991</marker>
<rawString>Tilman Becker, Aravind K. Joshi, and Owen Rambow. 1991. Long-distance scrambling and tree adjoining grammars. In Proceedings ofACL-Europe.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Tilman Becker</author>
<author>Owen Rambow</author>
<author>Michael Niv</author>
</authors>
<title>The Derivationel Generative Power of Formal Systems or Scrambling is Beyond LCFRS.</title>
<date>1992</date>
<tech>Technical Report IRCS-92-38,</tech>
<institution>Institute for Research in Cognitive Science, University of Pennsylvania.</institution>
<contexts>
<context position="1937" citStr="Becker et al., 1992" startWordPosition="299" endWordPosition="302">1991), Vector-TAG with dominance links (Rambow, 1994) and, more recently, Tree-Tuple MCTAG with Shared Nodes (Lichte, 2007)), or TT-MCTAG for short. For some of the above formalisms the word recognition problem is NP-hard. This has been shown for non-local MCTAG (Rambow and Satta, 1992), even in the lexicalized case (Champollion, 2007). Some others generate only polynomial languages but their generative capacity is too limited to deal with all natural language phenomena. This has been argued for tree-local and even set-local MCTAG on the basis of scrambling data from languages such as German (Becker et al., 1992; Rambow, 1994). In this paper, we focus on TT-MCTAG (Lichte, 2007). So far, it has been shown that the universal recognition problem for TT-MCTAG is NPhard (Søgaard et al., 2007). A restriction on TTMCTAG has been proposed in (Kallmeyer and Parmentier, 2008): with such a restriction, the universal recognition problem is still NP-hard, but the class of generated languages is included in PTIME, i.e., all these languages can be recognized in deterministic polynomial time. In this paper, we address the question of whether for general TTMCTAG, i.e., TT-MCTAG without the constraint from (Kallmeyer </context>
<context position="13124" citStr="Becker et al., 1992" startWordPosition="2390" endWordPosition="2393">of v[i] = v for 1 ≤ i ≤ m, i.e., these occurrences come from the same tree set in the grammar. Such a language has been proposed as an abstract description of the scrambling phenomenon as found in German and other free word order languages, 996 Figure 2: TT-MCTAG derivation of (1) derivation tree: reparieren ε versucht ε NPnom 1 ε Mann NPacc 1 es *( ) + * + VP VP NPnom VP∗ versucht , der Mann , {} NPnom VP∗ * ( ) + * + VP VP NPacc zu reparieren , es , {} NPacc VP∗ * α VP ( β1 VPv=− )+ , v n VP∗ NA * β2 VP (β3 VPv=− )+ , v VP∗NAv=+ n VP∗NA Figure 3: TT-MCTAG and cannot be generated by a LCFRS (Becker et al., 1992; Rambow, 1994). Figure 3 reports a TTMCTAG for this language. Concerning the other direction, at the time of writing it is not known whether there are languages generated by LCFRS but not by TTMCTAG. It is well known that LCFRS is closed under the finite-copy operator. This means that, for any fixed k &gt; 1, if L is generated by a LCFRS then the language {w |w = uk, u ∈ L} can also be generated by a LCFRS. We conjecture that TT-MCTAG does not have such a closure property. However, from a first inspection of the MCTAG analyses proposed for natural languages (see Chen-Main and Joshi (2007) for an</context>
</contexts>
<marker>Becker, Rambow, Niv, 1992</marker>
<rawString>Tilman Becker, Owen Rambow, and Michael Niv. 1992. The Derivationel Generative Power of Formal Systems or Scrambling is Beyond LCFRS. Technical Report IRCS-92-38, Institute for Research in Cognitive Science, University of Pennsylvania.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Lucas Champollion</author>
</authors>
<title>Lexicalized non-local MCTAG with dominance links is NP-complete.</title>
<date>2007</date>
<booktitle>Proceedings of Mathematics ofLanguage (MOL) 10,</booktitle>
<editor>In Gerald Penn and Ed Stabler, editors,</editor>
<publisher>CSLI On-Line Publications.</publisher>
<contexts>
<context position="1655" citStr="Champollion, 2007" startWordPosition="254" endWordPosition="255">contribution of a lexical item into several components. Instead of single trees, these grammars contain (multi-)sets of trees. Examples are tree-local and set-local multicomponent TAG (Joshi, 1985; Weir, 1988), MCTAG for short, non-local MCTAG with dominance links (Becker et al., 1991), Vector-TAG with dominance links (Rambow, 1994) and, more recently, Tree-Tuple MCTAG with Shared Nodes (Lichte, 2007)), or TT-MCTAG for short. For some of the above formalisms the word recognition problem is NP-hard. This has been shown for non-local MCTAG (Rambow and Satta, 1992), even in the lexicalized case (Champollion, 2007). Some others generate only polynomial languages but their generative capacity is too limited to deal with all natural language phenomena. This has been argued for tree-local and even set-local MCTAG on the basis of scrambling data from languages such as German (Becker et al., 1992; Rambow, 1994). In this paper, we focus on TT-MCTAG (Lichte, 2007). So far, it has been shown that the universal recognition problem for TT-MCTAG is NPhard (Søgaard et al., 2007). A restriction on TTMCTAG has been proposed in (Kallmeyer and Parmentier, 2008): with such a restriction, the universal recognition proble</context>
</contexts>
<marker>Champollion, 2007</marker>
<rawString>Lucas Champollion. 2007. Lexicalized non-local MCTAG with dominance links is NP-complete. In Gerald Penn and Ed Stabler, editors, Proceedings of Mathematics ofLanguage (MOL) 10, CSLI On-Line Publications.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Joan Chen-Main</author>
<author>Aravind Joshi</author>
</authors>
<title>Some observations on a graphical model-theoretical approach and generative models.</title>
<date>2007</date>
<booktitle>In Model Theoretic Syntax at 10. Workshop, ESSLLI2007,</booktitle>
<location>Dublin, Ireland.</location>
<contexts>
<context position="13717" citStr="Chen-Main and Joshi (2007)" startWordPosition="2503" endWordPosition="2506">d by a LCFRS (Becker et al., 1992; Rambow, 1994). Figure 3 reports a TTMCTAG for this language. Concerning the other direction, at the time of writing it is not known whether there are languages generated by LCFRS but not by TTMCTAG. It is well known that LCFRS is closed under the finite-copy operator. This means that, for any fixed k &gt; 1, if L is generated by a LCFRS then the language {w |w = uk, u ∈ L} can also be generated by a LCFRS. We conjecture that TT-MCTAG does not have such a closure property. However, from a first inspection of the MCTAG analyses proposed for natural languages (see Chen-Main and Joshi (2007) for an overview), it seems that there are no important natural language phenomena that can be described by LCFRS and not by TT-MCTAG. Any construction involving some kind of component stacking along the VP projection such as subject-auxiliary inversion can be modelled with TT-MCTAG. Unbounded extraposition phenomena cannot be described with TTMCTAG but they constitute a problem for any local formalism and so far the nature of these phenomena is not sufficiently well-understood. Note that, in contrast to non-local MCTAG, in TT-MCTAG the trees coming from the same instance of a tuple in the gra</context>
</contexts>
<marker>Chen-Main, Joshi, 2007</marker>
<rawString>Joan Chen-Main and Aravind Joshi. 2007. Some observations on a graphical model-theoretical approach and generative models. In Model Theoretic Syntax at 10. Workshop, ESSLLI2007, Dublin, Ireland.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Armin B Cremers</author>
<author>Otto Mayer</author>
</authors>
<title>On matrix languages. Information and Control,</title>
<date>1973</date>
<pages>23--86</pages>
<contexts>
<context position="14507" citStr="Cremers and Mayer, 1973" startWordPosition="2634" endWordPosition="2637"> kind of component stacking along the VP projection such as subject-auxiliary inversion can be modelled with TT-MCTAG. Unbounded extraposition phenomena cannot be described with TTMCTAG but they constitute a problem for any local formalism and so far the nature of these phenomena is not sufficiently well-understood. Note that, in contrast to non-local MCTAG, in TT-MCTAG the trees coming from the same instance of a tuple in the grammar are not required to be added at the same time. TT-MCTAGs share this property of ‘non-simultaneity’ with other vector grammars such as Unordered Vector Grammars (Cremers and Mayer, 1973) and VectorTAG (Rambow, 1994), V-TAG for short, and it is crucial for the polynomial parsing algorithm. The non-simultaneity seems to be an advantage when using synchronous grammars to model the syntax-semantics interface (Nesson and Shieber, 2008). The closest formalism to TT-MCTAG is V-TAG. However, there are fundamental differences between the two. Firstly, they make a different use of dominance links: In V-TAG dominance links relate different nodes in the trees of a tree set from the grammar. They present dominance requirements that constrain the derived tree. In TT-MCTAG, there are no dom</context>
</contexts>
<marker>Cremers, Mayer, 1973</marker>
<rawString>Armin B. Cremers and Otto Mayer. 1973. On matrix languages. Information and Control, 23:86–96.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Aravind K Joshi</author>
<author>Yves Schabes</author>
</authors>
<title>TreeAdjoning Grammars.</title>
<date>1997</date>
<booktitle>Handbook ofFormal Languages,</booktitle>
<pages>69--123</pages>
<editor>In G. Rozenberg and A. Salomaa, editors,</editor>
<publisher>Springer,</publisher>
<location>Berlin.</location>
<contexts>
<context position="4775" citStr="Joshi and Schabes, 1997" startWordPosition="770" endWordPosition="773">lly more complex and require specializations of the above techniques. Polynomial parsing results for tree rewriting systems based on parallel unordered rewriting have also been reported in (Rambow, 1994; Rambow et al., 1995). However, in the approach proposed by these authors, tree-based grammars are first translated into equivalent string-based systems, and the result is again provided on the string domain. 2 Tree Adjoining Grammars Tree Adjoining Grammars (Joshi et al., 1975) are a formalism based on tree rewriting. We briefly summarize here the relevant definitions and refer the reader to (Joshi and Schabes, 1997) for a more complete introduction. Definition 1 A Tree Adjoining Grammar (TAG) is a tuple G = (VN, VT, S, I, A) where VN and VT are disjoint alphabets of non-terminal and terminal symbols, respectively, S E VN is the start symbol, and I and A are finite sets of initial and auxiliary trees, respectively. ❑ Trees in I U A are called elementary trees. The internal nodes in the elementary trees are labeled with non-terminal symbols, the leaves with nonterminal or terminal symbols. As a special property, each auxiliary tree Q has exactly one of its leaf nodes marked as the foot node, having the sam</context>
</contexts>
<marker>Joshi, Schabes, 1997</marker>
<rawString>Aravind K. Joshi and Yves Schabes. 1997. TreeAdjoning Grammars. In G. Rozenberg and A. Salomaa, editors, Handbook ofFormal Languages, pages 69–123. Springer, Berlin.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Aravind K Joshi</author>
<author>Leon S Levy</author>
<author>Masako Takahashi</author>
</authors>
<title>Tree Adjunct Grammars.</title>
<date>1975</date>
<journal>Journal of Computer and System Science,</journal>
<pages>10--136</pages>
<contexts>
<context position="962" citStr="Joshi et al., 1975" startWordPosition="142" endWordPosition="145"> Nodes, TTMCTAG for short, an extension of Tree Adjoining Grammars that has been proposed for natural language processing, in particular for dealing with discontinuities and word order variation in languages such as German. It has been shown that the universal recognition problem for this formalism is NP-hard, but so far it was not known whether the class of languages generated by TT-MCTAG is included in PTIME. We provide a positive answer to this question, using a new characterization of TTMCTAG. 1 Introduction For a large range of linguistic phenomena, extensions of Tree Adjoining Grammars (Joshi et al., 1975), or TAG for short, have been proposed based on the idea of separating the contribution of a lexical item into several components. Instead of single trees, these grammars contain (multi-)sets of trees. Examples are tree-local and set-local multicomponent TAG (Joshi, 1985; Weir, 1988), MCTAG for short, non-local MCTAG with dominance links (Becker et al., 1991), Vector-TAG with dominance links (Rambow, 1994) and, more recently, Tree-Tuple MCTAG with Shared Nodes (Lichte, 2007)), or TT-MCTAG for short. For some of the above formalisms the word recognition problem is NP-hard. This has been shown f</context>
<context position="4633" citStr="Joshi et al., 1975" startWordPosition="747" endWordPosition="750">hn ADV VP always V laughs derivation tree: laugh 1 2 john always John derived tree: S rewriting formalisms we consider here are structurally more complex and require specializations of the above techniques. Polynomial parsing results for tree rewriting systems based on parallel unordered rewriting have also been reported in (Rambow, 1994; Rambow et al., 1995). However, in the approach proposed by these authors, tree-based grammars are first translated into equivalent string-based systems, and the result is again provided on the string domain. 2 Tree Adjoining Grammars Tree Adjoining Grammars (Joshi et al., 1975) are a formalism based on tree rewriting. We briefly summarize here the relevant definitions and refer the reader to (Joshi and Schabes, 1997) for a more complete introduction. Definition 1 A Tree Adjoining Grammar (TAG) is a tuple G = (VN, VT, S, I, A) where VN and VT are disjoint alphabets of non-terminal and terminal symbols, respectively, S E VN is the start symbol, and I and A are finite sets of initial and auxiliary trees, respectively. ❑ Trees in I U A are called elementary trees. The internal nodes in the elementary trees are labeled with non-terminal symbols, the leaves with nontermin</context>
</contexts>
<marker>Joshi, Levy, Takahashi, 1975</marker>
<rawString>Aravind K. Joshi, Leon S. Levy, and Masako Takahashi. 1975. Tree Adjunct Grammars. Journal of Computer and System Science, 10:136–163.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Joshi</author>
<author>K Vijay-Shanker</author>
<author>D Weir</author>
</authors>
<title>The convergence of mildly context-sensitive grammatical formalisms. In</title>
<date>1991</date>
<booktitle>Foundational Issues in Natural Language Processing.</booktitle>
<editor>P. Sells, S. Shieber, and T. Wasow, editors,</editor>
<publisher>MIT Press,</publisher>
<location>Cambridge MA.</location>
<marker>Joshi, Vijay-Shanker, Weir, 1991</marker>
<rawString>A. Joshi, K. Vijay-Shanker, and D. Weir. 1991. The convergence of mildly context-sensitive grammatical formalisms. In P. Sells, S. Shieber, and T. Wasow, editors, Foundational Issues in Natural Language Processing. MIT Press, Cambridge MA.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Aravind K Joshi</author>
</authors>
<title>Tree adjoining grammars: How much contextsensitivity is required ro provide reasonable structural descriptions? In</title>
<date>1985</date>
<booktitle>Natural Language Parsing,</booktitle>
<pages>206--250</pages>
<editor>D. Dowty, L. Karttunen, and A. Zwicky, editors,</editor>
<publisher>Cambridge University Press.</publisher>
<contexts>
<context position="1233" citStr="Joshi, 1985" startWordPosition="188" endWordPosition="189">m for this formalism is NP-hard, but so far it was not known whether the class of languages generated by TT-MCTAG is included in PTIME. We provide a positive answer to this question, using a new characterization of TTMCTAG. 1 Introduction For a large range of linguistic phenomena, extensions of Tree Adjoining Grammars (Joshi et al., 1975), or TAG for short, have been proposed based on the idea of separating the contribution of a lexical item into several components. Instead of single trees, these grammars contain (multi-)sets of trees. Examples are tree-local and set-local multicomponent TAG (Joshi, 1985; Weir, 1988), MCTAG for short, non-local MCTAG with dominance links (Becker et al., 1991), Vector-TAG with dominance links (Rambow, 1994) and, more recently, Tree-Tuple MCTAG with Shared Nodes (Lichte, 2007)), or TT-MCTAG for short. For some of the above formalisms the word recognition problem is NP-hard. This has been shown for non-local MCTAG (Rambow and Satta, 1992), even in the lexicalized case (Champollion, 2007). Some others generate only polynomial languages but their generative capacity is too limited to deal with all natural language phenomena. This has been argued for tree-local and</context>
<context position="22943" citStr="Joshi, 1985" startWordPosition="4342" endWordPosition="4343">parsing algorithm. The basic idea is to use a parsing algorithm for TAG, and impose on-the-fly additional restrictions on the underlying derivation trees that are being constructed, in order to fulfill the definition of valid TT-MCTAG derivation. To simplify the presentation, we assume without loss of generality that all elementary trees in our grammars are binary trees. The input string has the form w = a1 · · · an with each ai ∈ VT and n ≥ 0 (n = 0 means w = E). 4.1 TAG recognition We start with the discussion of a baseline recognition algorithm for TAG, along the lines of (VijayShanker and Joshi, 1985). The algorithm is specified by means of deduction rules, following (Shieber et al., 1995), and can be implemented using standard tabular techniques. Items have the form [-y, pt, i, f1, f2, j] where -y ∈ I ∪ A, p is the address of a node in -y, subscript t ∈ {⊤, ⊥} specifies whether substitution or adjunction has already taken place (⊤) or not (⊥) at p, and 0 ≤ i ≤ f1 ≤ f2 ≤ j ≤ n are indices with i, j indicating the left and right edges of the span recognized by p and f1, f2 indicating the span of a gap in case a foot node is dominated by p. We write f1 = f2 = − if no gap is involved. For com</context>
</contexts>
<marker>Joshi, 1985</marker>
<rawString>Aravind K. Joshi. 1985. Tree adjoining grammars: How much contextsensitivity is required ro provide reasonable structural descriptions? In D. Dowty, L. Karttunen, and A. Zwicky, editors, Natural Language Parsing, pages 206–250. Cambridge University Press.</rawString>
</citation>
<citation valid="false">
<authors>
<author>Laura Kallmeyer</author>
<author>Yannick Parmentier</author>
</authors>
<title>On the relation between Multicomponent Tree Adjoining Grammars with Tree Tuples (TT-MCTAG) and Range Concatenation Grammars</title>
<date>2008</date>
<booktitle>Language and Automata Theory and Applications. Second International Conference, LATA 2008, number 5196 in Lecture Notes in Computer Science,</booktitle>
<pages>263--274</pages>
<editor>(RCG). In Carlos Martin-Vide, Friedrich Otto, and Henning Fernaus, editors,</editor>
<publisher>Springer-Verlag,</publisher>
<location>Heidelberg Berlin.</location>
<contexts>
<context position="2196" citStr="Kallmeyer and Parmentier, 2008" startWordPosition="345" endWordPosition="348">non-local MCTAG (Rambow and Satta, 1992), even in the lexicalized case (Champollion, 2007). Some others generate only polynomial languages but their generative capacity is too limited to deal with all natural language phenomena. This has been argued for tree-local and even set-local MCTAG on the basis of scrambling data from languages such as German (Becker et al., 1992; Rambow, 1994). In this paper, we focus on TT-MCTAG (Lichte, 2007). So far, it has been shown that the universal recognition problem for TT-MCTAG is NPhard (Søgaard et al., 2007). A restriction on TTMCTAG has been proposed in (Kallmeyer and Parmentier, 2008): with such a restriction, the universal recognition problem is still NP-hard, but the class of generated languages is included in PTIME, i.e., all these languages can be recognized in deterministic polynomial time. In this paper, we address the question of whether for general TTMCTAG, i.e., TT-MCTAG without the constraint from (Kallmeyer and Parmentier, 2008), the class of generated languages is included in PTIME. We provide a positive answer to this question. The TT-MCTAG definition from (Lichte, 2007; Kallmeyer and Parmentier, 2008) imposes a condition on the way different tree components f</context>
<context position="16038" citStr="Kallmeyer and Parmentier, 2008" startWordPosition="2882" endWordPosition="2886">sult, one obtains a slight degree of locality that can be exploited for natural language phenomena that are unbounded only in a limited domain. This is proposed in (Lichte and Kallmeyer, 2008) where the fact that substitution nodes block argument adjunction to higher heads is used to model the limited domain of scrambling in German. V-TAG does not have any such notion of locality. Instead, it uses explicit constraints, so-called integrity constraints, to establish islands. 3.2 An alternative characterization of TT-MCTAG The definition of TT-MCTAG in subsection 3.1 is taken from (Lichte, 2007; Kallmeyer and Parmentier, 2008). The condition (SN-TTL) on the TAG derivation tree is formulated in terms of heads and arguments belonging together, i.e., coming from the same tuple instance. For our parsing algorithm, we want to avoid grouping the instances of elementary trees in a derivation tree into tuple instances. In other words, we want to check whether a TAG derivation tree is a valid TT997 and there is some hv, vεi ∈ E with Lab(hv, vεi) = E and 7r(v, Q) ≤ 7r(vε, Q) ≤ 7r(v, Q) + 1. Intuitively, condition (i) in lemma 1 captures the fact that heads always dominate their arguments in the derivation tree. Condition (ii</context>
</contexts>
<marker>Kallmeyer, Parmentier, 2008</marker>
<rawString>Laura Kallmeyer and Yannick Parmentier. 2008. On the relation between Multicomponent Tree Adjoining Grammars with Tree Tuples (TT-MCTAG) and Range Concatenation Grammars (RCG). In Carlos Martin-Vide, Friedrich Otto, and Henning Fernaus, editors, Language and Automata Theory and Applications. Second International Conference, LATA 2008, number 5196 in Lecture Notes in Computer Science, pages 263–274. Springer-Verlag, Heidelberg Berlin.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Laura Kallmeyer</author>
</authors>
<title>Tree-local multicomponent tree adjoining grammars with shared nodes.</title>
<date>2005</date>
<journal>Computational Linguistics,</journal>
<volume>31</volume>
<issue>2</issue>
<contexts>
<context position="9390" citStr="Kallmeyer, 2005" startWordPosition="1604" endWordPosition="1605">all of the remaining trees in the set function as arguments of the head. Furthermore, in a TT-MCTAG derivation the argument trees must either adjoin directly to their head tree, or they must be linked in the derivation tree to an elementary tree that attaches to the head tree, by means of a chain of adjunctions at root nodes. In other words, in the corresponding TAG derivation tree, the head tree must dominate the argument trees in such a way that all positions on the path between them, except the first one, must be labeled by ε. This captures the notion of adjunction under node sharing from (Kallmeyer, 2005).2 Definition 2 A TT-MCTAG is a tuple G = (VN, VT, S, I, A, T ) where GT = (VN, VT, S, I, A) is an underlying TAG and T is a finite set of tree tuples of the form F = hγ,{β1, ... , βr}i where γ ∈ (I ∪ A) has at least one node with a terminal label, and β1, ... , βn ∈ A. ❑ For each F = hγ,{β1, ... , βr}i ∈ T , we call γ the head tree and the βj’s the argument trees. We informally say that γ and the βj’s belong to F, and write |F |= r + 1. As a remark, an elementary tree γ from the underlying TAG GT can be found in different tree tuples in G, or there could even be multiple instances of such a t</context>
</contexts>
<marker>Kallmeyer, 2005</marker>
<rawString>Laura Kallmeyer. 2005. Tree-local multicomponent tree adjoining grammars with shared nodes. Computational Linguistics, 31(2):187–225.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Timm Lichte</author>
<author>Laura Kallmeyer</author>
</authors>
<title>Factorizing Complementation in a TT-MCTAG for German.</title>
<date>2008</date>
<booktitle>In Proceedings of the Ninth International Workshop on Tree Adjoining Grammars and Related Formalisms (TAG+9),</booktitle>
<pages>57--64</pages>
<location>T¨ubingen,</location>
<contexts>
<context position="15599" citStr="Lichte and Kallmeyer, 2008" startWordPosition="2814" endWordPosition="2817">rees of a tree set from the grammar. They present dominance requirements that constrain the derived tree. In TT-MCTAG, there are no dominance links between nodes in elementary trees. Instead, the node of a head tree in the derivation tree must dominate all its arguments. Furthermore, even though TT-MCTAG arguments can adjoin with a delay to their head, their possible adjunction site is restricted with respect to their head. As a result, one obtains a slight degree of locality that can be exploited for natural language phenomena that are unbounded only in a limited domain. This is proposed in (Lichte and Kallmeyer, 2008) where the fact that substitution nodes block argument adjunction to higher heads is used to model the limited domain of scrambling in German. V-TAG does not have any such notion of locality. Instead, it uses explicit constraints, so-called integrity constraints, to establish islands. 3.2 An alternative characterization of TT-MCTAG The definition of TT-MCTAG in subsection 3.1 is taken from (Lichte, 2007; Kallmeyer and Parmentier, 2008). The condition (SN-TTL) on the TAG derivation tree is formulated in terms of heads and arguments belonging together, i.e., coming from the same tuple instance. </context>
</contexts>
<marker>Lichte, Kallmeyer, 2008</marker>
<rawString>Timm Lichte and Laura Kallmeyer. 2008. Factorizing Complementation in a TT-MCTAG for German. In Proceedings of the Ninth International Workshop on Tree Adjoining Grammars and Related Formalisms (TAG+9), pages 57–64, T¨ubingen, June.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Timm Lichte</author>
</authors>
<title>An MCTAG with Tuples for Coherent Constructions in German.</title>
<date>2007</date>
<booktitle>In Proceedings of the 12th Conference on Formal Grammar</booktitle>
<location>Dublin, Ireland.</location>
<contexts>
<context position="1441" citStr="Lichte, 2007" startWordPosition="220" endWordPosition="221">ation of TTMCTAG. 1 Introduction For a large range of linguistic phenomena, extensions of Tree Adjoining Grammars (Joshi et al., 1975), or TAG for short, have been proposed based on the idea of separating the contribution of a lexical item into several components. Instead of single trees, these grammars contain (multi-)sets of trees. Examples are tree-local and set-local multicomponent TAG (Joshi, 1985; Weir, 1988), MCTAG for short, non-local MCTAG with dominance links (Becker et al., 1991), Vector-TAG with dominance links (Rambow, 1994) and, more recently, Tree-Tuple MCTAG with Shared Nodes (Lichte, 2007)), or TT-MCTAG for short. For some of the above formalisms the word recognition problem is NP-hard. This has been shown for non-local MCTAG (Rambow and Satta, 1992), even in the lexicalized case (Champollion, 2007). Some others generate only polynomial languages but their generative capacity is too limited to deal with all natural language phenomena. This has been argued for tree-local and even set-local MCTAG on the basis of scrambling data from languages such as German (Becker et al., 1992; Rambow, 1994). In this paper, we focus on TT-MCTAG (Lichte, 2007). So far, it has been shown that the </context>
<context position="2704" citStr="Lichte, 2007" startWordPosition="426" endWordPosition="427">d (Søgaard et al., 2007). A restriction on TTMCTAG has been proposed in (Kallmeyer and Parmentier, 2008): with such a restriction, the universal recognition problem is still NP-hard, but the class of generated languages is included in PTIME, i.e., all these languages can be recognized in deterministic polynomial time. In this paper, we address the question of whether for general TTMCTAG, i.e., TT-MCTAG without the constraint from (Kallmeyer and Parmentier, 2008), the class of generated languages is included in PTIME. We provide a positive answer to this question. The TT-MCTAG definition from (Lichte, 2007; Kallmeyer and Parmentier, 2008) imposes a condition on the way different tree components from a tree tuple in the grammar combine with each other. This condition is formulated in terms of mapping between argument and head trees, i.e., in order to test such a condition one has to guess some grouping of the tree components used in a derivation into instances of tree tuples from the grammar. This results in a combinatorial explosion of parsing analyses. In order to obtain a polynomial parsing algorithm, we need to avoid this effect. On this line, we propose an alternative characterization of TT</context>
<context position="8255" citStr="Lichte, 2007" startWordPosition="1399" endWordPosition="1400">al item (e.g., a verb and its arguments) into several elementary trees. An MCTAG consists of (multi-)sets of elementary trees, called tree sets. If an elementary tree from some set is used in a derivation, then all of the remaining trees in the set must be used as well. Several variants of MCTAGs can be found the literature, differing on the 1In this convention, the root address is a and the jth child of a node with address p has address p · j. 995 specific definition of the derivation process. The particular MCTAG variant we are concerned with is Tree-Tuple MCTAG with Shared Nodes, TT-MCTAG (Lichte, 2007). TT-MCTAG were introduced to deal with free word order phenomena in languages such as German. An example is (1) where the argument es of reparieren precedes the argument der Mann of versucht and is not adjacent to the predicate it depends on. (1) ... dass es der Mann zu reparieren versucht ... that it the man to repair tries ‘... that the man tries to repair it’ A TT-MCTAG is slightly different from standard MCTAGs since each elementary tree set contains one specially marked lexicalized tree called the head, and all of the remaining trees in the set function as arguments of the head. Furtherm</context>
<context position="16005" citStr="Lichte, 2007" startWordPosition="2880" endWordPosition="2881"> head. As a result, one obtains a slight degree of locality that can be exploited for natural language phenomena that are unbounded only in a limited domain. This is proposed in (Lichte and Kallmeyer, 2008) where the fact that substitution nodes block argument adjunction to higher heads is used to model the limited domain of scrambling in German. V-TAG does not have any such notion of locality. Instead, it uses explicit constraints, so-called integrity constraints, to establish islands. 3.2 An alternative characterization of TT-MCTAG The definition of TT-MCTAG in subsection 3.1 is taken from (Lichte, 2007; Kallmeyer and Parmentier, 2008). The condition (SN-TTL) on the TAG derivation tree is formulated in terms of heads and arguments belonging together, i.e., coming from the same tuple instance. For our parsing algorithm, we want to avoid grouping the instances of elementary trees in a derivation tree into tuple instances. In other words, we want to check whether a TAG derivation tree is a valid TT997 and there is some hv, vεi ∈ E with Lab(hv, vεi) = E and 7r(v, Q) ≤ 7r(vε, Q) ≤ 7r(v, Q) + 1. Intuitively, condition (i) in lemma 1 captures the fact that heads always dominate their arguments in t</context>
</contexts>
<marker>Lichte, 2007</marker>
<rawString>Timm Lichte. 2007. An MCTAG with Tuples for Coherent Constructions in German. In Proceedings of the 12th Conference on Formal Grammar 2007, Dublin, Ireland.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Rebecca Nesson</author>
<author>Stuart Shieber</author>
</authors>
<title>Synchronous Vector TAG for Syntax and Semantics: Control Verbs, Relative Clauses, and Inverse Linking.</title>
<date>2008</date>
<booktitle>In Proceedings of the Ninth International Workshop on Tree Adjoining Grammars and Related Formalisms (TAG+9), T¨ubingen,</booktitle>
<contexts>
<context position="14755" citStr="Nesson and Shieber, 2008" startWordPosition="2671" endWordPosition="2674">far the nature of these phenomena is not sufficiently well-understood. Note that, in contrast to non-local MCTAG, in TT-MCTAG the trees coming from the same instance of a tuple in the grammar are not required to be added at the same time. TT-MCTAGs share this property of ‘non-simultaneity’ with other vector grammars such as Unordered Vector Grammars (Cremers and Mayer, 1973) and VectorTAG (Rambow, 1994), V-TAG for short, and it is crucial for the polynomial parsing algorithm. The non-simultaneity seems to be an advantage when using synchronous grammars to model the syntax-semantics interface (Nesson and Shieber, 2008). The closest formalism to TT-MCTAG is V-TAG. However, there are fundamental differences between the two. Firstly, they make a different use of dominance links: In V-TAG dominance links relate different nodes in the trees of a tree set from the grammar. They present dominance requirements that constrain the derived tree. In TT-MCTAG, there are no dominance links between nodes in elementary trees. Instead, the node of a head tree in the derivation tree must dominate all its arguments. Furthermore, even though TT-MCTAG arguments can adjoin with a delay to their head, their possible adjunction si</context>
</contexts>
<marker>Nesson, Shieber, 2008</marker>
<rawString>Rebecca Nesson and Stuart Shieber. 2008. Synchronous Vector TAG for Syntax and Semantics: Control Verbs, Relative Clauses, and Inverse Linking. In Proceedings of the Ninth International Workshop on Tree Adjoining Grammars and Related Formalisms (TAG+9), T¨ubingen, June.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Owen Rambow</author>
<author>Giorgio Satta</author>
</authors>
<title>Formal properties of non-locality.</title>
<date>1992</date>
<booktitle>In Proceedings of 1st International Workshop on Tree Adjoining Grammars.</booktitle>
<contexts>
<context position="1605" citStr="Rambow and Satta, 1992" startWordPosition="245" endWordPosition="248">have been proposed based on the idea of separating the contribution of a lexical item into several components. Instead of single trees, these grammars contain (multi-)sets of trees. Examples are tree-local and set-local multicomponent TAG (Joshi, 1985; Weir, 1988), MCTAG for short, non-local MCTAG with dominance links (Becker et al., 1991), Vector-TAG with dominance links (Rambow, 1994) and, more recently, Tree-Tuple MCTAG with Shared Nodes (Lichte, 2007)), or TT-MCTAG for short. For some of the above formalisms the word recognition problem is NP-hard. This has been shown for non-local MCTAG (Rambow and Satta, 1992), even in the lexicalized case (Champollion, 2007). Some others generate only polynomial languages but their generative capacity is too limited to deal with all natural language phenomena. This has been argued for tree-local and even set-local MCTAG on the basis of scrambling data from languages such as German (Becker et al., 1992; Rambow, 1994). In this paper, we focus on TT-MCTAG (Lichte, 2007). So far, it has been shown that the universal recognition problem for TT-MCTAG is NPhard (Søgaard et al., 2007). A restriction on TTMCTAG has been proposed in (Kallmeyer and Parmentier, 2008): with su</context>
</contexts>
<marker>Rambow, Satta, 1992</marker>
<rawString>Owen Rambow and Giorgio Satta. 1992. Formal properties of non-locality. In Proceedings of 1st International Workshop on Tree Adjoining Grammars.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Owen Rambow</author>
<author>Giorgio Satta</author>
</authors>
<title>A rewriting system for free word order syntax that is nonlocal and mildly context sensitive.</title>
<date>1994</date>
<booktitle>Current Issues in Mathematical Linguistics, North-Holland Linguistic series, Volume 56. Elsevier-North</booktitle>
<editor>In C. MartinVide, editor,</editor>
<location>Holland, Amsterdam.</location>
<contexts>
<context position="3636" citStr="Rambow and Satta, 1994" startWordPosition="580" endWordPosition="584">ree components used in a derivation into instances of tree tuples from the grammar. This results in a combinatorial explosion of parsing analyses. In order to obtain a polynomial parsing algorithm, we need to avoid this effect. On this line, we propose an alternative characterization of TT-MCTAG that only requires (i) a counting of tree components and (ii) the check of some local conditions on these counts. This allows for parsing in polynomial deterministic time. TT-MCTAG uses so-called ‘parallel unordered’ rewriting. The first polynomial time parsing results on this class were presented in (Rambow and Satta, 1994; Satta, 1995) for some string-based systems, exploiting counting techniques closely related to those we use in this paper. In contrast to string-based rewriting, the tree 994 Proceedings of the 47th Annual Meeting of the ACL and the 4th IJCNLP of the AFNLP, pages 994–1002, Suntec, Singapore, 2-7 August 2009. c�2009 ACL and AFNLP S NP VP V laughs VP ADV VP∗ always NP NP VP John ADV VP always V laughs derivation tree: laugh 1 2 john always John derived tree: S rewriting formalisms we consider here are structurally more complex and require specializations of the above techniques. Polynomial pars</context>
</contexts>
<marker>Rambow, Satta, 1994</marker>
<rawString>Owen Rambow and Giorgio Satta. 1994. A rewriting system for free word order syntax that is nonlocal and mildly context sensitive. In C. MartinVide, editor, Current Issues in Mathematical Linguistics, North-Holland Linguistic series, Volume 56. Elsevier-North Holland, Amsterdam.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Owen Rambow</author>
<author>K Vijay-shanker</author>
<author>David Weir</author>
</authors>
<title>Parsing d-Ttree grammars.</title>
<date>1995</date>
<booktitle>In Proceedings of the Fourth International Workshop on Parsing Technologies,</booktitle>
<pages>252--259</pages>
<location>Prague,</location>
<contexts>
<context position="4375" citStr="Rambow et al., 1995" startWordPosition="707" endWordPosition="710">per. In contrast to string-based rewriting, the tree 994 Proceedings of the 47th Annual Meeting of the ACL and the 4th IJCNLP of the AFNLP, pages 994–1002, Suntec, Singapore, 2-7 August 2009. c�2009 ACL and AFNLP S NP VP V laughs VP ADV VP∗ always NP NP VP John ADV VP always V laughs derivation tree: laugh 1 2 john always John derived tree: S rewriting formalisms we consider here are structurally more complex and require specializations of the above techniques. Polynomial parsing results for tree rewriting systems based on parallel unordered rewriting have also been reported in (Rambow, 1994; Rambow et al., 1995). However, in the approach proposed by these authors, tree-based grammars are first translated into equivalent string-based systems, and the result is again provided on the string domain. 2 Tree Adjoining Grammars Tree Adjoining Grammars (Joshi et al., 1975) are a formalism based on tree rewriting. We briefly summarize here the relevant definitions and refer the reader to (Joshi and Schabes, 1997) for a more complete introduction. Definition 1 A Tree Adjoining Grammar (TAG) is a tuple G = (VN, VT, S, I, A) where VN and VT are disjoint alphabets of non-terminal and terminal symbols, respectivel</context>
</contexts>
<marker>Rambow, Vijay-shanker, Weir, 1995</marker>
<rawString>Owen Rambow, K. Vijay-shanker, and David Weir. 1995. Parsing d-Ttree grammars. In Proceedings of the Fourth International Workshop on Parsing Technologies, Prague, pages 252–259.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Owen Rambow</author>
</authors>
<title>Formal and Computational Aspects of Natural Language Syntax.</title>
<date>1994</date>
<tech>Ph.D. thesis,</tech>
<institution>University of Pennsylvania.</institution>
<contexts>
<context position="1371" citStr="Rambow, 1994" startWordPosition="210" endWordPosition="211">We provide a positive answer to this question, using a new characterization of TTMCTAG. 1 Introduction For a large range of linguistic phenomena, extensions of Tree Adjoining Grammars (Joshi et al., 1975), or TAG for short, have been proposed based on the idea of separating the contribution of a lexical item into several components. Instead of single trees, these grammars contain (multi-)sets of trees. Examples are tree-local and set-local multicomponent TAG (Joshi, 1985; Weir, 1988), MCTAG for short, non-local MCTAG with dominance links (Becker et al., 1991), Vector-TAG with dominance links (Rambow, 1994) and, more recently, Tree-Tuple MCTAG with Shared Nodes (Lichte, 2007)), or TT-MCTAG for short. For some of the above formalisms the word recognition problem is NP-hard. This has been shown for non-local MCTAG (Rambow and Satta, 1992), even in the lexicalized case (Champollion, 2007). Some others generate only polynomial languages but their generative capacity is too limited to deal with all natural language phenomena. This has been argued for tree-local and even set-local MCTAG on the basis of scrambling data from languages such as German (Becker et al., 1992; Rambow, 1994). In this paper, we</context>
<context position="4353" citStr="Rambow, 1994" startWordPosition="705" endWordPosition="706">use in this paper. In contrast to string-based rewriting, the tree 994 Proceedings of the 47th Annual Meeting of the ACL and the 4th IJCNLP of the AFNLP, pages 994–1002, Suntec, Singapore, 2-7 August 2009. c�2009 ACL and AFNLP S NP VP V laughs VP ADV VP∗ always NP NP VP John ADV VP always V laughs derivation tree: laugh 1 2 john always John derived tree: S rewriting formalisms we consider here are structurally more complex and require specializations of the above techniques. Polynomial parsing results for tree rewriting systems based on parallel unordered rewriting have also been reported in (Rambow, 1994; Rambow et al., 1995). However, in the approach proposed by these authors, tree-based grammars are first translated into equivalent string-based systems, and the result is again provided on the string domain. 2 Tree Adjoining Grammars Tree Adjoining Grammars (Joshi et al., 1975) are a formalism based on tree rewriting. We briefly summarize here the relevant definitions and refer the reader to (Joshi and Schabes, 1997) for a more complete introduction. Definition 1 A Tree Adjoining Grammar (TAG) is a tuple G = (VN, VT, S, I, A) where VN and VT are disjoint alphabets of non-terminal and termina</context>
<context position="13139" citStr="Rambow, 1994" startWordPosition="2394" endWordPosition="2395"> ≤ m, i.e., these occurrences come from the same tree set in the grammar. Such a language has been proposed as an abstract description of the scrambling phenomenon as found in German and other free word order languages, 996 Figure 2: TT-MCTAG derivation of (1) derivation tree: reparieren ε versucht ε NPnom 1 ε Mann NPacc 1 es *( ) + * + VP VP NPnom VP∗ versucht , der Mann , {} NPnom VP∗ * ( ) + * + VP VP NPacc zu reparieren , es , {} NPacc VP∗ * α VP ( β1 VPv=− )+ , v n VP∗ NA * β2 VP (β3 VPv=− )+ , v VP∗NAv=+ n VP∗NA Figure 3: TT-MCTAG and cannot be generated by a LCFRS (Becker et al., 1992; Rambow, 1994). Figure 3 reports a TTMCTAG for this language. Concerning the other direction, at the time of writing it is not known whether there are languages generated by LCFRS but not by TTMCTAG. It is well known that LCFRS is closed under the finite-copy operator. This means that, for any fixed k &gt; 1, if L is generated by a LCFRS then the language {w |w = uk, u ∈ L} can also be generated by a LCFRS. We conjecture that TT-MCTAG does not have such a closure property. However, from a first inspection of the MCTAG analyses proposed for natural languages (see Chen-Main and Joshi (2007) for an overview), it </context>
<context position="14536" citStr="Rambow, 1994" startWordPosition="2641" endWordPosition="2642"> projection such as subject-auxiliary inversion can be modelled with TT-MCTAG. Unbounded extraposition phenomena cannot be described with TTMCTAG but they constitute a problem for any local formalism and so far the nature of these phenomena is not sufficiently well-understood. Note that, in contrast to non-local MCTAG, in TT-MCTAG the trees coming from the same instance of a tuple in the grammar are not required to be added at the same time. TT-MCTAGs share this property of ‘non-simultaneity’ with other vector grammars such as Unordered Vector Grammars (Cremers and Mayer, 1973) and VectorTAG (Rambow, 1994), V-TAG for short, and it is crucial for the polynomial parsing algorithm. The non-simultaneity seems to be an advantage when using synchronous grammars to model the syntax-semantics interface (Nesson and Shieber, 2008). The closest formalism to TT-MCTAG is V-TAG. However, there are fundamental differences between the two. Firstly, they make a different use of dominance links: In V-TAG dominance links relate different nodes in the trees of a tree set from the grammar. They present dominance requirements that constrain the derived tree. In TT-MCTAG, there are no dominance links between nodes in</context>
</contexts>
<marker>Rambow, 1994</marker>
<rawString>Owen Rambow. 1994. Formal and Computational Aspects of Natural Language Syntax. Ph.D. thesis, University of Pennsylvania.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Giorgio Satta</author>
</authors>
<title>The membership problem for unordered vector languages.</title>
<date>1995</date>
<booktitle>In Developments in Language Theory,</booktitle>
<pages>267--275</pages>
<contexts>
<context position="3650" citStr="Satta, 1995" startWordPosition="585" endWordPosition="586"> derivation into instances of tree tuples from the grammar. This results in a combinatorial explosion of parsing analyses. In order to obtain a polynomial parsing algorithm, we need to avoid this effect. On this line, we propose an alternative characterization of TT-MCTAG that only requires (i) a counting of tree components and (ii) the check of some local conditions on these counts. This allows for parsing in polynomial deterministic time. TT-MCTAG uses so-called ‘parallel unordered’ rewriting. The first polynomial time parsing results on this class were presented in (Rambow and Satta, 1994; Satta, 1995) for some string-based systems, exploiting counting techniques closely related to those we use in this paper. In contrast to string-based rewriting, the tree 994 Proceedings of the 47th Annual Meeting of the ACL and the 4th IJCNLP of the AFNLP, pages 994–1002, Suntec, Singapore, 2-7 August 2009. c�2009 ACL and AFNLP S NP VP V laughs VP ADV VP∗ always NP NP VP John ADV VP always V laughs derivation tree: laugh 1 2 john always John derived tree: S rewriting formalisms we consider here are structurally more complex and require specializations of the above techniques. Polynomial parsing results fo</context>
</contexts>
<marker>Satta, 1995</marker>
<rawString>Giorgio Satta. 1995. The membership problem for unordered vector languages. In Developments in Language Theory, pages 267–275.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Stuart M Shieber</author>
<author>Yves Schabes</author>
<author>Fernando C N Pereira</author>
</authors>
<date>1995</date>
<booktitle>Principles and Implementation of Deductive Parsing. Journal of Logic Programming,</booktitle>
<pages>24--1</pages>
<contexts>
<context position="23033" citStr="Shieber et al., 1995" startWordPosition="4355" endWordPosition="4358">se on-the-fly additional restrictions on the underlying derivation trees that are being constructed, in order to fulfill the definition of valid TT-MCTAG derivation. To simplify the presentation, we assume without loss of generality that all elementary trees in our grammars are binary trees. The input string has the form w = a1 · · · an with each ai ∈ VT and n ≥ 0 (n = 0 means w = E). 4.1 TAG recognition We start with the discussion of a baseline recognition algorithm for TAG, along the lines of (VijayShanker and Joshi, 1985). The algorithm is specified by means of deduction rules, following (Shieber et al., 1995), and can be implemented using standard tabular techniques. Items have the form [-y, pt, i, f1, f2, j] where -y ∈ I ∪ A, p is the address of a node in -y, subscript t ∈ {⊤, ⊥} specifies whether substitution or adjunction has already taken place (⊤) or not (⊥) at p, and 0 ≤ i ≤ f1 ≤ f2 ≤ j ≤ n are indices with i, j indicating the left and right edges of the span recognized by p and f1, f2 indicating the span of a gap in case a foot node is dominated by p. We write f1 = f2 = − if no gap is involved. For combining indices, we use the operator f′⊕f″= f where f = f′ if f″= −, f = f″if f′ = −, and f</context>
</contexts>
<marker>Shieber, Schabes, Pereira, 1995</marker>
<rawString>Stuart M. Shieber, Yves Schabes, and Fernando C. N. Pereira. 1995. Principles and Implementation of Deductive Parsing. Journal of Logic Programming, 24(1&amp;2):3–36.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Anders Søgaard</author>
<author>Timm Lichte</author>
<author>Wolfgang Maier</author>
</authors>
<title>The complexity of linguistically motivated extensions of tree-adjoining grammar.</title>
<date>2007</date>
<booktitle>In Recent Advances in Natural Language Processing</booktitle>
<location>Borovets, Bulgaria.</location>
<contexts>
<context position="2116" citStr="Søgaard et al., 2007" startWordPosition="332" endWordPosition="335">isms the word recognition problem is NP-hard. This has been shown for non-local MCTAG (Rambow and Satta, 1992), even in the lexicalized case (Champollion, 2007). Some others generate only polynomial languages but their generative capacity is too limited to deal with all natural language phenomena. This has been argued for tree-local and even set-local MCTAG on the basis of scrambling data from languages such as German (Becker et al., 1992; Rambow, 1994). In this paper, we focus on TT-MCTAG (Lichte, 2007). So far, it has been shown that the universal recognition problem for TT-MCTAG is NPhard (Søgaard et al., 2007). A restriction on TTMCTAG has been proposed in (Kallmeyer and Parmentier, 2008): with such a restriction, the universal recognition problem is still NP-hard, but the class of generated languages is included in PTIME, i.e., all these languages can be recognized in deterministic polynomial time. In this paper, we address the question of whether for general TTMCTAG, i.e., TT-MCTAG without the constraint from (Kallmeyer and Parmentier, 2008), the class of generated languages is included in PTIME. We provide a positive answer to this question. The TT-MCTAG definition from (Lichte, 2007; Kallmeyer </context>
</contexts>
<marker>Søgaard, Lichte, Maier, 2007</marker>
<rawString>Anders Søgaard, Timm Lichte, and Wolfgang Maier. 2007. The complexity of linguistically motivated extensions of tree-adjoining grammar. In Recent Advances in Natural Language Processing 2007, Borovets, Bulgaria.</rawString>
</citation>
<citation valid="true">
<authors>
<author>K Vijay-Shanker</author>
<author>Aravind K Joshi</author>
</authors>
<title>Some computational properties of Tree Adjoining Grammars.</title>
<date>1985</date>
<booktitle>In Proceedings of the 23rd Annual Meeting of the Association for Computational Linguistics,</booktitle>
<pages>82--93</pages>
<marker>Vijay-Shanker, Joshi, 1985</marker>
<rawString>K. Vijay-Shanker and Aravind K. Joshi. 1985. Some computational properties of Tree Adjoining Grammars. In Proceedings of the 23rd Annual Meeting of the Association for Computational Linguistics, pages 82–93.</rawString>
</citation>
<citation valid="true">
<authors>
<author>K Vijay-Shanker</author>
<author>D J Weir</author>
<author>A K Joshi</author>
</authors>
<title>Characterizing structural descriptions produced by various grammatical formalisms.</title>
<date>1987</date>
<booktitle>In 25th Meeting of the Association for Computational Linguistics (ACL’87).</booktitle>
<contexts>
<context position="12334" citStr="Vijay-Shanker et al., 1987" startWordPosition="2217" endWordPosition="2220">ted by the desire to separate the multicomponent property that TTMCTAG shares with a range of related formalisms (e.g., tree-local and set-local MCTAG, VectorTAG, etc.) from the notion of tree-locality with shared nodes that is peculiar to TT-MCTAG. Figure 2 shows a TT-MCTAG derivation for (1). Here, the NPnom auxiliary tree adjoins directly to versucht (its head) while the NPacc tree adjoins to the root of a tree that adjoins to the root of a tree that adjoins to reparieren. TT-MCTAG can generate languages that, in a strong sense, cannot be generated by Linear Context-Free Rewriting Systems (Vijay-Shanker et al., 1987; Weir, 1988), or LCFRS for short. An example is the language of all strings π(n[1] ... n[m])v[1] ... v[m] with m ≥ 1, π a permutation, and n[i] = n is a nominal argument of v[i] = v for 1 ≤ i ≤ m, i.e., these occurrences come from the same tree set in the grammar. Such a language has been proposed as an abstract description of the scrambling phenomenon as found in German and other free word order languages, 996 Figure 2: TT-MCTAG derivation of (1) derivation tree: reparieren ε versucht ε NPnom 1 ε Mann NPacc 1 es *( ) + * + VP VP NPnom VP∗ versucht , der Mann , {} NPnom VP∗ * ( ) + * + VP VP </context>
</contexts>
<marker>Vijay-Shanker, Weir, Joshi, 1987</marker>
<rawString>K. Vijay-Shanker, D. J. Weir, and A. K. Joshi. 1987. Characterizing structural descriptions produced by various grammatical formalisms. In 25th Meeting of the Association for Computational Linguistics (ACL’87).</rawString>
</citation>
<citation valid="true">
<authors>
<author>David J Weir</author>
</authors>
<title>Characterizing mildly contextsensitive grammar formalisms.</title>
<date>1988</date>
<tech>Ph.D. thesis,</tech>
<institution>University of Pennsylvania.</institution>
<contexts>
<context position="1246" citStr="Weir, 1988" startWordPosition="190" endWordPosition="191">rmalism is NP-hard, but so far it was not known whether the class of languages generated by TT-MCTAG is included in PTIME. We provide a positive answer to this question, using a new characterization of TTMCTAG. 1 Introduction For a large range of linguistic phenomena, extensions of Tree Adjoining Grammars (Joshi et al., 1975), or TAG for short, have been proposed based on the idea of separating the contribution of a lexical item into several components. Instead of single trees, these grammars contain (multi-)sets of trees. Examples are tree-local and set-local multicomponent TAG (Joshi, 1985; Weir, 1988), MCTAG for short, non-local MCTAG with dominance links (Becker et al., 1991), Vector-TAG with dominance links (Rambow, 1994) and, more recently, Tree-Tuple MCTAG with Shared Nodes (Lichte, 2007)), or TT-MCTAG for short. For some of the above formalisms the word recognition problem is NP-hard. This has been shown for non-local MCTAG (Rambow and Satta, 1992), even in the lexicalized case (Champollion, 2007). Some others generate only polynomial languages but their generative capacity is too limited to deal with all natural language phenomena. This has been argued for tree-local and even set-loc</context>
<context position="7509" citStr="Weir, 1988" startWordPosition="1267" endWordPosition="1268">ss 1 and always is adjoined at node address 2. In the following, we write a derivation tree D as a directed graph (V, E, r) where V is the set of nodes, E C V x V is the set of arcs and r E V is the root. For every v E V , Lab(v) gives the node label and for every (v1, v2) E E, Lab((v1, v2)) gives the edge label. A derived tree is the result of carrying out the substitutions and the adjunctions in a derivation tree, i.e., the derivation tree describes uniquely the derived tree; see again figure 1. 3 TT-MCTAG 3.1 Introduction to TT-MCTAG For a range of linguistic phenomena, multicomponent TAG (Weir, 1988) have been proposed, also called MCTAG for short. The underlying motivation is the desire to split the contribution of a single lexical item (e.g., a verb and its arguments) into several elementary trees. An MCTAG consists of (multi-)sets of elementary trees, called tree sets. If an elementary tree from some set is used in a derivation, then all of the remaining trees in the set must be used as well. Several variants of MCTAGs can be found the literature, differing on the 1In this convention, the root address is a and the jth child of a node with address p has address p · j. 995 specific defin</context>
<context position="12347" citStr="Weir, 1988" startWordPosition="2221" endWordPosition="2222">e the multicomponent property that TTMCTAG shares with a range of related formalisms (e.g., tree-local and set-local MCTAG, VectorTAG, etc.) from the notion of tree-locality with shared nodes that is peculiar to TT-MCTAG. Figure 2 shows a TT-MCTAG derivation for (1). Here, the NPnom auxiliary tree adjoins directly to versucht (its head) while the NPacc tree adjoins to the root of a tree that adjoins to the root of a tree that adjoins to reparieren. TT-MCTAG can generate languages that, in a strong sense, cannot be generated by Linear Context-Free Rewriting Systems (Vijay-Shanker et al., 1987; Weir, 1988), or LCFRS for short. An example is the language of all strings π(n[1] ... n[m])v[1] ... v[m] with m ≥ 1, π a permutation, and n[i] = n is a nominal argument of v[i] = v for 1 ≤ i ≤ m, i.e., these occurrences come from the same tree set in the grammar. Such a language has been proposed as an abstract description of the scrambling phenomenon as found in German and other free word order languages, 996 Figure 2: TT-MCTAG derivation of (1) derivation tree: reparieren ε versucht ε NPnom 1 ε Mann NPacc 1 es *( ) + * + VP VP NPnom VP∗ versucht , der Mann , {} NPnom VP∗ * ( ) + * + VP VP NPacc zu repa</context>
</contexts>
<marker>Weir, 1988</marker>
<rawString>David J. Weir. 1988. Characterizing mildly contextsensitive grammar formalisms. Ph.D. thesis, University of Pennsylvania.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>