<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<title confidence="0.7827665">
AN ALGORITHM FOR GENERATING
NON-REDUNDANT QUANTIFIER SCOPINGS
</title>
<author confidence="0.883137">
Espen J. Vestre
</author>
<affiliation confidence="0.983583">
Department of Mathematics
University of Oslo
</affiliation>
<address confidence="0.522521">
P.O. Box 1053 Blindern
N-0316 OSLO 3, Norway
</address>
<email confidence="0.972851">
Internet: espen@math.uio.no
</email>
<sectionHeader confidence="0.97778" genericHeader="abstract">
ABSTRACT
</sectionHeader>
<bodyText confidence="0.999906545454545">
This paper describes an algorithm for generat-
ing quantifier scopings. The algorithm is designed to
generate only logically non-redundant scopings and
to partially order the scopings with a given default
scoping first. Removing logical redundancy is not
only interesting per se, but also drastically reduces
the processing time. The input and output formats
are described through a few access and construc-
tion functions. Thus, the algorithm is interesting for a
modular linguistic theory, which is flexible with re-
spect to syntactic and semantic framework.
</bodyText>
<sectionHeader confidence="0.997835" genericHeader="introduction">
INTRODUCTION
</sectionHeader>
<bodyText confidence="0.96666">
Natural language sentences like the notorious
</bodyText>
<listItem confidence="0.964596">
(1) Every man loves a woman,
</listItem>
<bodyText confidence="0.999855619047619">
are usually regarded to be scope ambiguous.
There have been two ways to attack this problem:
To generate the most probable scoping and ignore
the rest, or to generate all theoretically possible
scopings.
Choosing the first alternative is actually not a
bad solution, since any sample piece of text usually
contains few possibilities for (real) scope ambiguity,
and since reasonable heuristics in most cases pick
out the intended reading. However, there are cases
which seem to be genuinely ambiguous, or where
the selection of the intended reading requires exten-
sive world knowledge.
If the second alternative is chosen, there are
basically two possible approaches: To integrate the
generation of scopings into the grammar (like e.g. in
Johnson and Kay (90) or Halvorsen and Kaplan
(88)), or to devise a procedure that generates the
scopings from the parse output (like in Hobbs and
Shieber (87)). In both cases, only structurally im-
possible scopings are ruled out, like the reading of
</bodyText>
<listItem confidence="0.9181385">
(2) Every representative of a company saw
most samples
</listItem>
<bodyText confidence="0.999708820512821">
in which &amp;quot;most samples&amp;quot; is outscoped by &amp;quot;every
representative&amp;quot; but outscopes &amp;quot;a company&amp;quot; (Hobbs
and Shieber (87)).
Logically equivalent readings are not ruled out on
either of these proposals. Hobbs and Shieber argue
that
&amp;quot;When we Move beyond the two first-
order quantifiers to deal with the so-called
generalized quantifiers, such as &amp;quot;most&amp;quot;,
these logical redundancies become quite
rare&amp;quot;.
Theoretically, they become rare. But it may
very well be that sentences with several occur-
rences of non-first-order generalized quantifiers are
not very commonly used. On the other hand, sen-
tences with several occurrences of existential or
universal quantifiers may be quite common. What
kinds of expressions that really resemble first-order
quantifiers is of course a controversial question. But
working natural language systems, with inference
mechanisms that are based on first-order logic, often
have to simplify the interpretation process by inter-
preting broad classes of expressions as plain univer-
sal or existential quantifiers. Thus, the gain of gen-
erating only non-equivalent scopings may be quite
significant in practical systems.
Ordering of the scopings according to preference
is also not treated on approaches like that of Hobbs
&amp; Shieber (87) or Johnson &amp; Kay (90). Hobbs &amp;
Shieber (87) are quite aware of this, and give some
suggestions on how to build ordering heuristics into
the algorithm. On the approach of Johnson 81 Kay
(90), scopings are generated with a DCG grammar
augmented with procedure calls for &amp;quot;shuffling&amp;quot; and
applying the quantifiers&apos;. The program will return
new scopings by backtracking. Because of the re-
cursive inside-out nature of the algorithm, it seems
difficult to preserve generation-by-backtracking if
one wants to order the scopings.
</bodyText>
<footnote confidence="0.55666025">
&apos;The quantifier shuffling method is essentially the same as
in Pereira &amp; Shieber (87), but correctly avoids the
&amp;quot;structurally impossible&amp;quot; scopings mentioned above.
- 251 -
</footnote>
<note confidence="0.926794666666667">
Scope islands: In English, only existential quanti-
fiers may be extracted out of relative clauses.
Notice the difference between
</note>
<listItem confidence="0.8593745">
(3a) An owner of every company attended the
meeting.
(3b) A man who owns every company attended
the meeting.
</listItem>
<bodyText confidence="0.996270454545454">
A scoping algorithm must take this into account,
since it will be very difficult to filter out such read-
ings at a later stage. In the algorithm of Johnson &amp;
Kay (90), adding such a mechanism seems to be
quite easy, since the shuffling and application of
quantifiers are handled in the grammar rules. In the
algorithm of Hobbs &amp; Shieber (87), it is a bit more
difficult, since the language of the input forms does
not distinguish between relative clauses and other
kinds of NP modifiers.
In general, any working scoping algorithm
should meet as many linguistic constraints on scope
generation as possible.
Modularity: The main concern of Johnson &amp; Kay
(90) is to build a grammar that is independent of se-
mantic formalism. This is done by a DCG grammar
using &amp;quot;curly bracket notation&amp;quot; to include calls to
formalism-dependent constructor functions.
It is tempting to take this approach one step fur-
ther, and let the generation of scopings be indepen-
dent on both the syntactic and semantic theory cho-
sen.
</bodyText>
<sectionHeader confidence="0.899894" genericHeader="method">
A MODULAR APPROACH
</sectionHeader>
<bodyText confidence="0.995900555555555">
The algorithm I propose provides solutions to
the four problems mentioned above simultaneously.
It is an extension and generalisation of the algorithm
presented in Vestre (87)2.
In the following I will make the (commonly
made) assumption that quantified formulas are 4-
part objects. I will occasionally use a simple lan-
guage of generalized quantifiers, where the formula
format is
</bodyText>
<subsectionHeader confidence="0.584813">
DET(x, Nr(x,...))
</subsectionHeader>
<bodyText confidence="0.9563482">
for determiners DET and formulas rti, tr. DET will
be referred to as the determiner of the quantifier, x
is its variable, 4) its restriction, and xv is its scope.
The term quantifier will usually refer to the deter-
miner with variable and restriction.
</bodyText>
<footnote confidence="0.72656375">
2This paper is in Norwegian, I&apos;m afraid. An English
overview of the work is included in Fenstad, Langholm and
Vestre (89), but the details of the scoping algorithm are not
described there.
</footnote>
<bodyText confidence="0.997815103448276">
Treating quantifiers in this way, it is easy to rule
out the &amp;quot;structurally impossible&amp;quot; scopings men-
tioned above because the formulas corresponding to
the &amp;quot;impossible scopings&amp;quot; will contain free vari-
ables. For instance, in sentence (2), the variable of
&amp;quot;a company&amp;quot; (say, y) will also occur in the restrictor
of &amp;quot;every representative&amp;quot;. So in order to avoid an
unbound occurrence of that variable, &amp;quot;a company&amp;quot;
must either have wider scope than &amp;quot;every represen-
tative&amp;quot; or be bound inside its restrictor.
The algorithm presupposes that a few access
functions are included for the type of input structure3
used. Further, a few constructor functions must be
included to define the format of the logical forms
generated.
The role of the main access function, get-
quants, is to pick out the parts of the input structure
that are quantifiers, and to return them as a list,
where the list order gives the default quantification
order. There are almost no limits to what kinds of
input structures that may be used, but the quantifiers
that are returned by the access functions must con-
tain their restrictors as a substructure. Of course,
using input structures that already contain such lists
of quantifiers as substructures will make the imple-
mentation of get7quants almost trivial.
In the following, I will give some rather informal
descriptions of the main functions involved. The al-
gorithm has been implemented in Common Lisp.
</bodyText>
<sectionHeader confidence="0.953384" genericHeader="method">
AN OUTSIDE-IN ALGORITHM
</sectionHeader>
<bodyText confidence="0.997619">
The usual way to generate scopings is to do it
inside-out: Quantifiers of a subformula are either
applied to the subforrnula or lifted to be applied at a
higher level.
On the approach presented here, generation is
done outside-in; i.e. by first choosing the outermost
quantifier of the formula to be generated. The moti-
vation behind this unorthodox move is rather prag-
matic: It makes it possible, as we shall see below, to
implement non-redundancy and sorting in an easy
and understandable way. It is also easy to treat ex-
amples like the following, presented by Hobbs &amp;
Shieber (87):
</bodyText>
<listItem confidence="0.465777">
(4) Every man I know a child of has arrived
</listItem>
<bodyText confidence="0.9120538">
where &amp;quot;a child of...&amp;quot; cannot be scoped outside of
&amp;quot;Every man&amp;quot;, since it (presumably) contains a vari-
able that &amp;quot;Every man&amp;quot; binds. Building formulas
outside-in, it is trivial to check that a formula only
contains variables that are already bound.
</bodyText>
<subsectionHeader confidence="0.814085">
3The input structnre will typically be output from a parser.
</subsectionHeader>
<bodyText confidence="0.986314">
- 252 -
There may be other good reasons for choosing
an outside-in approach; e.g. if anaphora resolution is
going to be integrated into the algorithm, or if scope
generation is to be done incrementally: Usually, the
first NP of a sentence contains the quantifier that by
default has the widest scope, so an outside-in algo-
rithm is just the right match for an incremental
parser.
The outside-in generation works in this way:
</bodyText>
<listItem confidence="0.996226588235294">
1. Select one of the quantifiers returned by
get-quants.
2. Generate all possible restrictions of this
quantifier by recursively scoping the re-
strictions.
3. Recursively generate all possible scopes
of the quantifier by applying the scoping
function to the input structure with the
selected quantifier (and thereby the
quantifiers in its restriction) removed.
Note that get-quants is called anew for
each subscoping, but it will only find
quantifiers which have not yet been ap-
plied.
4. Finally, construct a set of formulas, by
combining the quantifier with all the pos-
sible restrictions and scopes.
</listItem>
<sectionHeader confidence="0.732203" genericHeader="method">
THE BASIC ALGORITHM
</sectionHeader>
<bodyText confidence="0.9978644">
I will not formulate a precise definition of the al-
gorithm in some formal programming language, but I
will in the following give a half-formal definition of
the main functions of the algorithm as it works in its
basic version, i.e. with neither removal of logical re=
dundancy nor ordering of scopings integrated into
the algorithm:
The main function is scopings- which takes an in-
put form of (almost) any format and returns a set of
scoped formulas:
</bodyText>
<equation confidence="0.9517565">
scopings(form)=
( build-main(form)), ifform is quantifier free
build-quant(q,r,$)I q E get-quants(form),
r E scope-restrictions(q),
s e scopings(form(get-var(q)Iq)))
otherwise
</equation>
<bodyText confidence="0.996966166666667">
where form( get-var(q)Iq) means form with get-
var(q) substituted for q. The purpose of this substi-
tution is to mark the quantifier as &amp;quot;already bound&amp;quot;
by replacing it with the variable it binds. The vari-
able is then used by build-main in the main formula.
The function scope-restrictions is defined by
</bodyText>
<equation confidence="0.993632333333333">
scope-restrictions(quant) =
combine-restrictions(( scopings(r) :
r e get-restrictions(q)))
</equation>
<bodyText confidence="0.999865615384615">
where the role of combine-restrictions is to combine
scopings when there are several restrictions to a
quantifier, e.g. both a relative clause and a preposi-
tional phrase. Roughly, combine-restrictions works
by using the application-defined function build-con-
junction to conjoin one element from each of the
sets in its argument set.
This is the whole algorithm in its most basic ver-
provided of course, that the functions build-
main, build-quant, build-conjunction, get-quants,
get-var and get-restrictions are defined. These may
be defined to fit almost any kind of input and output
structure5
</bodyText>
<sectionHeader confidence="0.9998645" genericHeader="method">
REMOVING LOGICAL
REDUNDANCY
</sectionHeader>
<bodyText confidence="0.8748831">
We now turn to the enhancements which are
the main concern of this paper. We first look at the
most important, the removal of logically redundant
scopings. To give a precise formulation of the kind
of logical redundancy that we want to avoid, we
first need some definitions:
Definition
A determiner DET is scope-commutative
if (for all suitable formulas) the following is
equivalent:
</bodyText>
<listItem confidence="0.995956">
(1) DET(x, Ri(x), DET(y, RAY), S(x, y)))
(2) DET(y, RAY), DET(x, Ri(x), S(x, y)))
</listItem>
<bodyText confidence="0.726988333333333">
A determiner DET is restrictor-commuta-
tive if (for all suitable formulas) the follow-
ing is equivalent:
</bodyText>
<listItem confidence="0.9368165">
(1) DET(x, Ri(x) &amp; DET(y, RAY), S2(x, y)),
S (x))
(2) DET(y, RAY),
DET(x, Ri(x) &amp; SAx, y), Si(x)))
</listItem>
<footnote confidence="0.59661275">
4In this basic version, the algorithm does exactly what the
algorithm of Hobbs &amp; Shieber (87) does when &amp;quot;opaque
operators&amp;quot; are left out.
5In the actual Common Lisp implementation, substitution of
</footnote>
<bodyText confidence="0.927449297297297">
variables for quantifiers is done by destructive list
manipulation. This means that quantifiers must be cons-
cells, and that the occurrence of a quantifier in the list
returned by get-quants(form) must share with the
occurrence of the same quantifier inform.
- 253 -
It is easily seen that both existential and univer-
sal determiners are scope-commutative, and that
existential, but not universal, determiners are re-
stricter-commutative. In natural language, this
means that e.g. A representative of a company ar-
rived is not ambiguous, in contrast to Every repre-
sentative of every company arrived. Typical gen-
eralized quantifiers like most are neither restrictor-
commutative nor scope-commutative6.
Since quantifiers are selected outside-in, it is
now easy to equip the algorithm with a mechanism
to remove redundant scopings:
If the surrounding quantifier had a scope-
commutative determiner, quantifiers with
the same determiner and which precede
the surrounding quantifier in the default
ordering are not selected.
For example, this means that in Every man loves
every woman, &amp;quot;every man&amp;quot; has to be selected be-
fore &amp;quot;every woman&amp;quot;. The algorithm will also try
&amp;quot;every woman&amp;quot; as the first quantifier, but will then
discard that alternative because &amp;quot;every man&amp;quot; can-
not be selected in the next step - it precedes &amp;quot;every
woman&amp;quot; in the default ordering. For more complex
sentences, this discarding may give a significant
time saving, which will be discussed below.
The algorithm also takes care of the restrictor-
commutativity of existential determiners by using
the same technique of comparing with the surround-
ing quantifier when restrictions on quantifiers are re-
cursively scoped.
</bodyText>
<sectionHeader confidence="0.9991415" genericHeader="method">
PARTIALLY ORDERING THE
SCOPINGS
</sectionHeader>
<bodyText confidence="0.991800903225806">
Generating outside-in, one has a &amp;quot;global&amp;quot; view
of the generation process, which may be an advan-
tage when trying to integrate ordering of scoping
according to preference into the algorithm. As an
example, the implemented algorithm provides a very
simple kind of preference ordering: A scoping is
considered &amp;quot;better&amp;quot; than another scoping if the
number of quantifiers occurring in a non-default
position is lower.
It is supposed that the input comes with a de-
fault ordering, and that the application-specific func-
tion get-quants takes care of this. This default order
may reflect several heuristics for scope generation;
e.g. that the of-complements of NPs usually take
6To prove non-scope-commutativity of most, construct an
actual example where Most men love most women holds,
but Most women are loved by most men does not hold (with
the default scopings)!
scope over the whole NP (and thus should be lifted
by default).
The trick is now to assign a &amp;quot;penalty&amp;quot; number to
every sub-scoping. Every time several quantifiers
can be chosen at a given step, the penalty is in-
creased by 1 if a quantifier different from the default
one is chosen. And every time a quantifier is con,.
structed, its penalty is set to the sum of the penalties
of the restrictor and scope subformulas. Thus, the
penalty counts the number of quantifier displace,
ments (compared to the default scoping). The main
function of the Common Lisp implementation thus
looks like thi.s7:
</bodyText>
<figure confidence="0.666273666666667">
(defun scopings (form)
(let ((qlist (get-quants form)))
(if qiist
(prefer (use-quant (car qlist) form)
&apos; (use-quants (cdr gist) form))
(list (cons 0 (build-main form))))))
</figure>
<bodyText confidence="0.938520666666667">
Here prefer is a function which increases the
penalty of each of the scopings in its second list, and
calls merge-scopings on the two lists. Merge-scop-
ings merges the two lists with the penalty as order-
ing criterion. This function is used whenever needed
by the algorithm, such that one never needs to re-
order the scoping list. From the last function-call
above, one can also see how the coding of penalties
is done: Atomic formulas are marked with a zero in
their car. This number is later removed, the penalty
is always stored only in the car of the whole scoped
formula.
</bodyText>
<sectionHeader confidence="0.9840275" genericHeader="method">
SCOPE OF RELATIVE CLAUSE
QUANTIFIERS
</sectionHeader>
<bodyText confidence="0.999164866666667">
Whether it is a general constraint on English
may be questionable, but at least for practical pur-
poses it seems reasonable to assume that no other
quantifiers than the existential quantifier may be
extracted out of a relative clause.
The algorithm makes it easy to implement such
a constraint. Since the quantifiers that can be used
at a given step are given by the application-defined
function get-quants, it is easy for any implementa-
tion of get-quants to filter out all non-existential
quantifiers when looking for quantifiers inside a rela-
tive clause. Here some of the burden is put on the
grammar: The parts of the input structures that cor-
respond to relative clauses must be marked to be
distinguishable from e.g. PP complementss.
</bodyText>
<footnote confidence="0.5102508">
&apos;Tor clarity, the mechanism for removing logical redundancy
is left out here.
80ne could also put all the burden on the grammar, if one
wanted the structures to contain the quantifier list as a
- 254 -
</footnote>
<note confidence="0.646243">
THE NUMBER OF SCOPINGS
</note>
<bodyText confidence="0.9997128">
Hobbs and Shieber (87) point out that just by
avoiding those scopings that are structurally impos-
sible, the number of scopings generated is signifi-
candy lower than n!. For the following sentence, the
reduction is from 8! = 40320 to &amp;quot;only&amp;quot; 2988:
</bodyText>
<listItem confidence="0.832514">
(5) A representative of a department of a
company gave a friend of a director of a
company a sample of a product.
</listItem>
<bodyText confidence="0.999295476190476">
Of course, the sentence has only one &amp;quot;real&amp;quot;
scoping! Since the algorithm presented here avoids
logical non-redundancy by looking at the default
order already when a quantifier is selected for the
generation of a subformula, the gain for sentences
like (5) is tremendous9.
The above suggests that complexity for scoping
algorithms is a function of both the number of quan-
tifiers in the input, and of the structure of the input.
The highest number of scopings is obtained when
the input contains n quantifiers, none of which are
contained in a restriction to one of the others. An
example of this is Most women give most men a
flower. In such cases, no quantifier permutations
can be sorted out on structural grounds, so the num-
ber of scopings is n!.
For more complex sentences, the picture is
fairly complex. The easiest task is to look at the
case where the lowest number of scopings are ob-
tained (disregarding logical redundancy), when all
quantifiers are nested inside each other, e.g.
</bodyText>
<listItem confidence="0.778387666666667">
(6) Most representatives of most depart-
ments of most companies of most cities
sighed.
</listItem>
<bodyText confidence="0.999304333333333">
It is easy to see that if N is the function that
counts the number of scopings in such a sentence,
then
</bodyText>
<equation confidence="0.996607">
N(n) = E N(n — k)N (k —1)
k =1
</equation>
<bodyText confidence="0.998254">
Here N (n — k)N (k — 1) is the number of sub-
scopings generated if quantifier number k is selected
as the outermost, the factors are the number of
</bodyText>
<footnote confidence="0.951552">
substructure. This seems difficult to do with a pure
unification grammar, however.
9For this particular sentence, the single scoping is
generated in less than 1/200 of the time required to
generate the 2988 scopings of the same sentence with
&apos;most&apos; substituted for &apos;a&apos;.
</footnote>
<bodyText confidence="0.953063333333333">
scopings of the restriction and scope of that quanti-
fier, respectively. Of course, N(0) = 1.
It can be shown thatlo
</bodyText>
<equation confidence="0.744748">
N(n)—
n!(n + 1)!
</equation>
<bodyText confidence="0.9686025">
Further, estimating by Stirlings formula for n!we get
the following (rough) estimate:
</bodyText>
<equation confidence="0.554832">
4 n
N(n) + n
</equation>
<bodyText confidence="0.999942">
The important observation here, is that that the
number of scopings of the completely nested sen-
tences no longer is of faculty order, but of &amp;quot;only&amp;quot; ex-
ponential order. This gives us a mathematical con-
firmation of the suspicion that the number of sew-
ings of such sentences is significantly lower than the
number of permutations of quantifiers. For sen,
tences which contain two argument NPs and the
rest of the quantifiers nested inside each of these,
the number of scopings is also N(n). For sentences
with three argument NPs, it is somewhat higher, but
still of exponential order.
</bodyText>
<sectionHeader confidence="0.971519" genericHeader="method">
COMPUTATIONAL COMPLEXITY
</sectionHeader>
<bodyText confidence="0.972491679245283">
What is the optimal way to generate (an explicit
representation of) the n/ scopings of the worst case?
The absolute lower bound of the time complexity,
will necessarily be at least as bad as the lower
bound on space complexity. And the absolute lower
bound on space complexity is given by the size of an
optimally structure-sharing direct representation of
the n! scopings. Such a representation will only con,
lain one instance of each possible subscoping, but it
has to contain all subscopings as substructures. This
makes a total of n + n.(n-1)+...+n! subscopings.
Factoring out n!, we get n!(1 + 111! + 112!
+...+11(n-1)!). Readers trained in elementary cal-
culus, will recognize the latter sum as the Taylor
polynomial of degree n-1 around 0 of the exponential
function, applied to argument 1, i.e. the sum con-
verges to the number e. This means that the total
number of subscopings — and hence the lower bound
on space complexity — is of order n!.
Without any structure-sharing, the number of
subscopings generated will of course be n.n!. This is
exactly what happens here: The algorithm pre,
senteel is 0(n2 .n!) in time and space (provided that
no redundancy occurs). This estimate presupposes
that get-quants is of order n in both time and space,
even when less than n quantifiers are left
(presumably this figure will be better for some im-
10see e.g. Jacobson (51), p. 19.
(2n)!
- 255 -
plementations of get-quants). By comparison, the
Hobbs &amp; Shieber algorithm is 0(n!), by using opti-
mal structure sharing.
Does this mean that the outside-in approach
should be rejected? Note that we above only con-
sidered the non-nested case. In the nested case, the
algorithm presented here gains somewhat, while the
Hobbs&amp;Shieber algorithm loses somewhat. In both
cases, scoping of restrictions has to be redone for
every new application of the quantifier they restrict.
This means that in the general case, the Hobbs &amp;
Shieber algorithm no longer provides optimal struc-
ture sharing, while the algorithm presented here
provides a modest structure sharing. Now, both al-
gorithms can of course be equipped with a hash
table (or even a plain array) for storing sets of sub-
scopings (by the quantifiers left to be bound). This
has been successfully tried out with the algorithm
presented here. It brings the complexity down to the
optimal: 0(n!) in the worst case, and similarly to
0(44n-3/2) in the completely nested case. So, there
is, at least in theory, nothing to be lost in efficiency
by using an outside-in algorithm.
</bodyText>
<sectionHeader confidence="0.974948" genericHeader="method">
THE SINGLE-SCOPING CASE
</sectionHeader>
<bodyText confidence="0.999425727272727">
What about the promised reduction of complex-
ity due to redundancy checking? We consider the
case where a sentence contains n un-nested exis-
tential quantifiers. Then the complexity is given by
the number of times the algorithm tries to generate a
subscoping, multiplied by the complexity of get-
quants. When quantifier number k is selected as the
outermost, n-k quantifiers are left applicable in the
resulting recursive call to the algorithm. Let S be the
function that counts the number of subscopings
considered. We have:
</bodyText>
<equation confidence="0.984437">
S(n) = 1 + S(n k) =24 — 1
k =1
</equation>
<bodyText confidence="0.999516555555556">
Thus, in the single-scoping case the algorithm is
0(n -211) for input with un-nested quantifiers (and
even lower for nested quantifiers).
Although the savings will be somewhat less
spectacular for sentences with more than 1 scoping,
this nevertheless shows that removing logical redun-
dancy not only is of its own right, but also gives a
significant reduction of the complexity of the algo-
rithm.
</bodyText>
<sectionHeader confidence="0.999859" genericHeader="method">
MODULAR THEORIES OF
LINGUISTICS
</sectionHeader>
<bodyText confidence="0.999622954545455">
The algorithm presented here is related to the
work of Johnson &amp; Kay (90) by its modular nature.
As mentioned, the interface with the syntax (parse
output) is through a small set of access functions
(get-quants, get-restrictions, get-var, and quant-
type) and the interface with the semantics (the out-
put of the algorithm) is through a small set of con-
structor functions (build-conjuction, build-main and
build-quant). The implementation thus is a conve,
nient &amp;quot;software glue&amp;quot; which allows a high degree of
freedom in the choice of both syntactic and semantic
framework.
This approach is not as &amp;quot;nice&amp;quot; as that of
Johnson &amp; Kay (90) or Halvorsen &amp; Kaplan (88),
and may on such grounds be rejected as a theory of
the syntactic/semantic interface. But the question is
whether it is possible to state any relationship be-
tween syntax and semantics which satisfies my four
initial requirements (non-redundancy, ordering,
special treatment of sub-clauses and modularity),
and which still is &amp;quot;beautiful&amp;quot; or &amp;quot;simple&amp;quot; according
to some standard.
</bodyText>
<sectionHeader confidence="0.999753" genericHeader="references">
REFERENCES
</sectionHeader>
<reference confidence="0.97389712">
Fenstad, J.E.; Langholm, T. and Vestre, E.
(1989): Representations and Interpretations.
Cosmos Report no. 09, Department of Mathematics,
University of Oslo.
Halvorsen, PIC. and Kaplan, R.M. (1988):
Projections and Semantic Description in Lexical-
Functional Grammar, Proceedings of FGCS&apos;88,
Tokyo, Japan. Tokyo: Institute for New Generation
Systems; 1988; Volume 3: 1116-1122.
Hobbs, J.R. and Shieber, S.M. (1987): An
Algorithm for Generating Quantifier Scope.
Computational Linguistics, Volume 13, Numbers 1-
2, January-June 1987.
Jacobson, N. (1951): Lectures in Abstract
Algebra. D. van Nostrand Comp. Ltd., New York.
Johnson, M. and Kay, M. (1990): Semantic
Abstraction and Anaphora. Proceedings of
COLING 90.
Pereira, F.CN. and Shieber, S.M. (1987):
Prolog and Natural-language Analysis. CSLI
Lecture Notes No. 10, CSLI, Stanford.
Vestre, E. (1987): Representasjon av direkte
spOrsmal, Cand. Scient. thesis (unpublished, in nor-
wegian)
- 256 -
</reference>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.684475">
<title confidence="0.9974475">AN ALGORITHM FOR GENERATING NON-REDUNDANT QUANTIFIER SCOPINGS</title>
<author confidence="0.999996">Espen J Vestre</author>
<affiliation confidence="0.999387">Department of Mathematics University of Oslo</affiliation>
<address confidence="0.910876">P.O. Box 1053 Blindern N-0316 OSLO 3, Norway</address>
<email confidence="0.858078">Internet:espen@math.uio.no</email>
<abstract confidence="0.997139333333333">This paper describes an algorithm for generating quantifier scopings. The algorithm is designed to generate only logically non-redundant scopings and to partially order the scopings with a given default scoping first. Removing logical redundancy is not only interesting per se, but also drastically reduces the processing time. The input and output formats are described through a few access and construction functions. Thus, the algorithm is interesting for a modular linguistic theory, which is flexible with respect to syntactic and semantic framework.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>J E Fenstad</author>
<author>T Langholm</author>
<author>E Vestre</author>
</authors>
<title>Representations and Interpretations.</title>
<date>1989</date>
<tech>Cosmos Report no. 09,</tech>
<institution>Department of Mathematics, University of Oslo.</institution>
<marker>Fenstad, Langholm, Vestre, 1989</marker>
<rawString>Fenstad, J.E.; Langholm, T. and Vestre, E. (1989): Representations and Interpretations. Cosmos Report no. 09, Department of Mathematics, University of Oslo.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R M Kaplan</author>
</authors>
<title>Projections and Semantic Description in LexicalFunctional Grammar,</title>
<date>1988</date>
<booktitle>Proceedings of FGCS&apos;88,</booktitle>
<volume>3</volume>
<pages>1116--1122</pages>
<institution>Institute for New Generation Systems;</institution>
<location>Tokyo, Japan. Tokyo:</location>
<marker>Kaplan, 1988</marker>
<rawString>Halvorsen, PIC. and Kaplan, R.M. (1988): Projections and Semantic Description in LexicalFunctional Grammar, Proceedings of FGCS&apos;88, Tokyo, Japan. Tokyo: Institute for New Generation Systems; 1988; Volume 3: 1116-1122.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J R Hobbs</author>
<author>S M Shieber</author>
</authors>
<title>An Algorithm for Generating Quantifier Scope.</title>
<date>1987</date>
<journal>Computational Linguistics, Volume</journal>
<volume>13</volume>
<location>Numbers</location>
<marker>Hobbs, Shieber, 1987</marker>
<rawString>Hobbs, J.R. and Shieber, S.M. (1987): An Algorithm for Generating Quantifier Scope. Computational Linguistics, Volume 13, Numbers 1-2, January-June 1987.</rawString>
</citation>
<citation valid="true">
<authors>
<author>N Jacobson</author>
</authors>
<date>1951</date>
<booktitle>Lectures in Abstract Algebra. D. van Nostrand Comp.</booktitle>
<publisher>Ltd.,</publisher>
<location>New York.</location>
<marker>Jacobson, 1951</marker>
<rawString>Jacobson, N. (1951): Lectures in Abstract Algebra. D. van Nostrand Comp. Ltd., New York.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Johnson</author>
<author>M Kay</author>
</authors>
<title>Semantic Abstraction and Anaphora.</title>
<date>1990</date>
<booktitle>Proceedings of COLING 90.</booktitle>
<marker>Johnson, Kay, 1990</marker>
<rawString>Johnson, M. and Kay, M. (1990): Semantic Abstraction and Anaphora. Proceedings of COLING 90.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S M Shieber</author>
</authors>
<title>Prolog and Natural-language Analysis.</title>
<date>1987</date>
<booktitle>CSLI Lecture Notes No. 10,</booktitle>
<location>CSLI, Stanford.</location>
<marker>Shieber, 1987</marker>
<rawString>Pereira, F.CN. and Shieber, S.M. (1987): Prolog and Natural-language Analysis. CSLI Lecture Notes No. 10, CSLI, Stanford.</rawString>
</citation>
<citation valid="true">
<authors>
<author>E Vestre</author>
</authors>
<title>Representasjon av direkte spOrsmal,</title>
<date>1987</date>
<journal>Cand. Scient.</journal>
<note>thesis (unpublished, in norwegian)</note>
<marker>Vestre, 1987</marker>
<rawString>Vestre, E. (1987): Representasjon av direkte spOrsmal, Cand. Scient. thesis (unpublished, in norwegian)</rawString>
</citation>
<citation valid="false">
<pages>256</pages>
<marker></marker>
<rawString>- 256 -</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>