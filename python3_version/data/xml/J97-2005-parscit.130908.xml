<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000387">
<title confidence="0.930921">
Squibs and Discussions
A Delayed Syntactic-Encoding-based LFG
Parsing Strategy for an Indian
Language—Bangla
</title>
<author confidence="0.969373">
Probal Sengupta* B. B. Chaudhuri*
</author>
<affiliation confidence="0.961395">
Indian Statistical Institute Indian Statistical Institute
</affiliation>
<sectionHeader confidence="0.990715" genericHeader="abstract">
1. Introduction
</sectionHeader>
<bodyText confidence="0.999892851851852">
In this squib, we propose a technique aimed at efficient computer implementation of
LFG-based parsers for Indian languages in general and Bangla (Bengali) in particular.
(For the LFG formalism, see Kaplan and Bresnan [1982].) The technique may also be
useful for other languages having similar properties.
Indian languages are mostly nonconfigurational and highly inflectional. Gram-
matical functions (GF&apos;s) are predicted by case inflections (markers) on the head nouns
of noun phrases (NPs) and postpositional particles in postpositional phrases (PPs).
However, in many cases the mapping from case marker to GF is not one-to-one.
The classical technique for non-configurational syntactic encoding of GF&apos;s (Bresnan
1982b) therefore requires a number of alternations to be thrown in to handle this
phenomenon. The resulting nondeterminism in the parser implementation leads to a
non-efficient unification component. The problem here, however, is not of unbounded
functional uncertainty (described, with proposed solutions, in Kaplan, Maxwell, and
Zaenen [1987], Kaplan and Maxwell [1988], and Kaplan and Zaenan [1990]), but rather,
one of disjunctive constraint satisfaction bounded within the matrix. Disjunctive con-
straint satisfaction leads to a degradation of efficiency of the unification component
of LFG, as has been pointed out in Knight (1989) and Maxwell and Kaplan (1991).1 A
closer look at the languages reveals that most disjunctions do not exist if an a priori
knowledge of the verb (which is generally at the end of the sentence, since Indian
languages are mostly verb final and the verb is the last lexeme encountered in a left-
to-right scan of the parser) is available. Here we propose a technique that uses this
fact to reduce alternations in syntactic encoding. Our method is based on a delayed
evaluation of syntactic encoding schema. We treat the points of syntactic encoding
of noun phrases as forward references that are temporarily maintained in a symbol
table for later binding. A new metavariable, augmentation of the scope of the Locate
operator, and a special type of schema (called m-structure) to be projected by the verb
are some of the salient features of our technique.
</bodyText>
<sectionHeader confidence="0.965761" genericHeader="method">
2. Delayed Syntactic Encoding
</sectionHeader>
<bodyText confidence="0.998536">
As suggested in Bresnan (1982a, 1982b) and Mohanan (1982), a flat constituent struc-
ture for a Bangla sentence S is given by the rule in (1), where constituent NPs and/or
</bodyText>
<footnote confidence="0.626644">
* Computer Vision and Pattern Recognition Unit, Indian Statistical Institute, 203 B. T. Road, Calcutta 700
035. India. E-mail: sprobal@isical.emet.in; bbc@isical.ernet.in
1 Maxwell and Kaplan (1991) also propose a method to minimize unification overhead.
</footnote>
<note confidence="0.7678045">
® 1997 Association for Computational Linguistics
Computational Linguistics Volume 23, Number 2
</note>
<tableCaption confidence="0.990586">
Table 1
</tableCaption>
<bodyText confidence="0.703544">
Case markers and their possible grammatical functions. The
GEN case marker normally marks a genitive qualifier of a noun.
However, for certain verb forms (for example, ones in
pseudopassive voice), it also marks the subject.
</bodyText>
<table confidence="0.97475">
Marker Name SUBJ OBJ IOBJ ADJUNCT
None NULL • • • •
+ke, +re DATive • • •
+e, +te OBLique • • • •
+er GENitive •
</table>
<equation confidence="0.97608">
PPs may freely permute among themselves.&apos;
NP* V NP*
(1 (1 CASE)) =1 (1 (1 CASE)) =1
(I (1 CASE)) =1 (2)
</equation>
<bodyText confidence="0.999959388888889">
In (1), syntactic encoding of GF&apos;s is carried out using the simplified encoding
schemata (2) annotating the NPs (Bresnan 1982b, 297-299). In the implementation
domain, schemata (2) works quite well if the mapping from case marker to function is
nearly one-to-one. Unfortunately, as shown in Table 1, many modern Indian languages
lack this property—almost every marker has many-to-one mapping. The classical way
of handling such situations is to use alternation or disjunction. However, in the context
of an a priori lexical knowledge of the verb, the alternations cease to exist in most
cases. To express this more formally, let G = {gi,g2, ...} be the set of relevant GF&apos;s, C -=
{c1, c2,. .} be the set of NP case markers, and cToG be a mapping from case markers
to GF&apos;s, such that cToG(c), c E C is (are) the grammatical function(s) predictable from
c. In our case, cToG(c) is actually a finite disjunction gh v g,2 V • • • of functions. If fN
is the f-structure of an NP of a sentence S with f-structure fs and the case marker
on the head noun of the NP is c, the semantics of schemata (2) annotating the NP
is (fs cToG[c]) = fN, where &amp;quot;=&amp;quot; denotes unification. Since cToG[c] is a disjunction, in a
parser implementation, it effectively multiplies out to IcToG(c)I nondeterministic choices
for the functional role played by the fN in fs. If, in the ultimate analysis, the NP is
found to play the functional role g in fs, the constraints set in (3), projected by the
verb, must have been satisfied:
</bodyText>
<equation confidence="0.814038">
(fs g CASE) = c
Ai (fs g qi) = vi
</equation>
<bodyText confidence="0.999635714285714">
where q, are different normal agreement features (like NUMBer, PERSon, etc.) and/or
other semantic agreement features (like ANIMacy, etc.). We shall call the schema (3)
the agreement schema for the function g projected by the verb. Observations show
that in most well-formed sentences, the agreement schema of the verb for any function
g is satisfied by at most one constituent NP of the sentences, provided some order of
processing the agreement schema of different GF&apos;s is maintained. The mapping cToG is
therefore nearly one-to-one in the context of the agreement schema of the verb and the
</bodyText>
<page confidence="0.524925">
2 The PPs have been kept out of the present discussion.
</page>
<figure confidence="0.409686">
(1)
(3)
</figure>
<page confidence="0.983798">
346
</page>
<note confidence="0.630569">
Sengupta and Chaudhuri Delayed Syntactic Encoding
</note>
<bodyText confidence="0.999930111111111">
agreement schema may serve as test criteria for selecting grammatical functions from
internal properties of NPs. The parser must ensure evaluation of an encoding schemata
of a constituent NP in the context of the agreement schema of the verb, somewhat like
handling a forward reference (where an item referred to is defined later than the places
where it has been referred to). The trick is to delay the evaluation of encoding schema
of constituent NPs till an appropriate moment, while maintaining a persistent data
structure, such as a symbol table, to keep track of the points of forward reference
(at which actual function names get instantiated) and their local environments (the
internal f-structure of the constituent NPs).
</bodyText>
<sectionHeader confidence="0.753228" genericHeader="method">
3. The Proposed Solution Technique
</sectionHeader>
<bodyText confidence="0.9995075">
In this section, we provide the basic solution technique for simple sentences (i.e.,
consisting of a single verb only) in two parts.
</bodyText>
<subsectionHeader confidence="0.999048">
3.1 Solution Part I: Initiation of Forward Reference
</subsectionHeader>
<bodyText confidence="0.9999382">
A forward reference discussed in the previous section is encountered during Locate-
ing the left-hand side of a schemata like (2) while processing an NP. In our delayed
encoding proposal, the (modified) Locate operation should leave the &amp;quot;name&amp;quot; of the
functional role played by the NP as &amp;quot;underspecified.&amp;quot; To force the Locate operator to
behave in this manner, we propose:
</bodyText>
<listItem confidence="0.997824">
1. The introduction of a new type of underspecification metavariable:?
2. The modification of encoding schemata (2) to schemata (4):
</listItem>
<equation confidence="0.93222">
(i ?) =i (4)
</equation>
<bodyText confidence="0.99993825">
The ? metavariables generate placeholders for hitherto anonymous grammatical
functions, which we shall call nameholders, and denote them by actual name variables
ni, n2, Lo cate-ing of schemata (4) creates such a nameholder (n, say) in the scope
of the functional placeholder (f, say) for the I metavariable and simultaneously stores
the pair (f, n) in the symbol table. Locate-ing a construct like (f n) where both f and
n are already defined placeholder and nameholder, respectively, returns (a pointer to)
the &amp;quot;value&amp;quot; part of the pair in the f-structure (pointed at by)f, whose name is (pointed
at by) n. The extended semantics of Locate is therefore:
Lo cat e[cl], where d has the form (x y). Let f be the reference to an f-structure
Locate [x]. If y is a ? metavariable, let n be a new nameholder for the metavariable.
An anonymous slot is created in the scope of f, and n is made to point to it. Simul-
taneously, the pair (f, n) is entered as a new entry of the symbol table. If, however, y
is a nameholder n, Locate returns the value field of the pair in f whose name field is
held by n.
With this, the semantics of Locate with fispect to the form in (5), which is the
left-hand side of schemata (4), may be pictorially represented as in Figure 1.
</bodyText>
<subsectionHeader confidence="0.999084">
3.2 Solution Part II: Name Binding of Forward References
</subsectionHeader>
<bodyText confidence="0.999678">
The next point to be considered is binding actual function names to nameholders.
We assume that the agreement schema for a function g may select the structure that
satisfies the constraints. For this, the agreement schema must be handled in a different
</bodyText>
<page confidence="0.965711">
347
</page>
<figure confidence="0.83896375">
Computational Linguistics
Volume 23, Number 2
Symbol Table
f
</figure>
<figureCaption confidence="0.974216">
Figure 1
</figureCaption>
<bodyText confidence="0.973678973684211">
Semantics of Locate with respect to (5).
manner than normal projection schema. We choose the notation (# g qi) =- v1 for
one agreement schemata for the function g. We shall call the forms (# g q,) v, a
metastructure or m-structure. M-structure schema are projected by the main verb of
a sentence. A symbol table entry (f, n) satisfies an m-structure schemata (# g q,) = v,
projected by the verb V of a sentence S. if f is the f-structure of S. and the structure (f n),
where n is treated as an atom, contains the pair [q, vi]. If a symbol table entry satisfies
all m-structure schema for a function g, by our proposed scheme, the nameholder n
that points to the entry is bound to the function name g. Also, the satisfying symbol
table entry is deleted.
Testing of symbol table entries with m-structure schema and resulting binding of
nameholders to actual function names are carried out by a newly introduced operator
Search. The operator Search takes the entire set m-structure schema for a particular
GF and carries out the process described in the previous paragraph. If more than one
symbol table entry satisfies the m-structure schema for a particular function g, the one
earlier in order of occurrence is chosen. The relative evaluation (by operating with
Search) order for the sets of m-structure schema for different functions is motivated
by the default ordering of phrases in a sentence in the target language. In Bangla for
example, the default ordering is SUBJ-IOBJ-OBJ. Thus, the test for SUBJ. is carried out
first, followed by IOBJ, and OBJ, if any.
The final solution technique therefore involves first evaluating all f-structure
schema, including those with underspecification metavariables annotating the children
nodes of an S-dominated c-structure tree. This would generate symbol table entries
corresponding to NPs annotated with the ? schema. Next, the m-structure schema of
the main verb are operated on with the Search operator in the default phrasal order
for the language. A sentence is well formed if and only if all the m-structure schema
for the verb are satisfied and all nameholders in the scope of the sentence are bound
to names (i.e., at the end, the symbol table is empty). The evaluation process naturally
satisfies the uniqueness property for sentence-level grammatical functions.
Regarding the relative evaluation order of f- and m-structure schema, the general
principle is &amp;quot;all f-structure schema are evaluated before any m-structure schemata is
evaluated (i.e., fed to the Search operator).&amp;quot;
Example 1
Let us consider the Bangla simple sentence below, in which the NPs have been under-
lined.
a&apos;pni a&apos;ma&apos;ke ekt&apos;a&apos; bai dilen
You(honored)-NULL I-DAT one-DEF book-NULL give-3p-hon-PAST
You (honored) will give me a book
</bodyText>
<page confidence="0.99189">
348
</page>
<table confidence="0.979779555555556">
Sengupta and Chaudhuri Delayed Syntactic Encoding
a) a&apos;pni N Cr PERS) = 3, b) a&apos;ma&apos;ke N (1 PERS) = 1,
Cr HON) =1, Cr HON) = 0,
ANIM) = +, Cr ANIM)
PRED) = &apos;you&apos;, PRED) = &apos;I&apos;,
Cr CASE) = NULL (1 CASE) = DAT
c) bai N Cr PERS) = 0, d) dilen V Cr TENSE) = PAST
(T HON) =0, (t PERS) = 2
ANIM) = — (1 HON) =1
(1 PRED) = &apos;book&apos;, PRED) = &apos;give((SUBJ),(OBJ), (IOBJ))&apos;
(1 CASE) = NULL (# SUBJ PERS) = 2
(# SUB! HON) = 1
(# SUBJ ANIM) = +
(# SUBJ CASE) = NULL
(# IOBJ ANIM) = +
(# IOBJ CASE) = DAT
(# OBJ ANIM) = —
(# OBJ CASE) = NULL
</table>
<figureCaption confidence="0.7676285">
Figure 2
Lexical entries of head nouns and verbs in Bangla sentence a&apos;pni a&apos;make ekt&apos;a&apos; bai dilen.
</figureCaption>
<figure confidence="0.991263740740741">
[ANIM +
CASE NULL
PERS 2
HON 1
PRED &apos;You&apos;
fa
n2
[ANIM +
CASE DAT
PERS 1
PRED &apos;I&apos;
fb
ANIM —
DEF YES
n3 CASE NULL
PERS 3
PRED &apos;book&apos;
IC
TENSE PAST
PRED &apos;give(• •)&apos;
Is
Figure 3
F-structure of Bangla sentence a&apos;pni a&apos;male ekt&apos;a&apos; bai dilen.
Symbol Table
fs nl
Is nz
Is n3
</figure>
<bodyText confidence="0.99901325">
Any permutation of the underlined phrases and the verb should give identical
results. The lexical entries of the head nouns and the verb are given in Figure 2. The
feature HON is a three-valued scalar, 1 for honored, 0 for casual, and —1 for intimate.
Since Bangla has no subject-verb agreement based on number, the NUM feature has
been omitted.&apos;
The f-structure fs of the sentence before processing the m-structure of the verb
appears as in Figure 3 and the final solution is as given in Figure 4. The f-structures
fa, fb, and fc are for the NPs in order.
</bodyText>
<page confidence="0.954193">
3 Alternately, since Bangla verbs are not marked for number, the NUM feature is omitted in agreement.
349
</page>
<figure confidence="0.9983548">
Computational Linguistics Volume 23, Number 2
ANIM
CASE NULL
SUBJ PERS 2
HON 1
PRED &apos;You&apos;
[
ANIM
CASE DAT
IOBJ
PERS 1
PRED
ANIM —
DEF YES
OBJ CASE NULL
PERS 3
PRED &apos;book&apos;
TENSE PAST
PRED &apos;give((SUBJ), (OBJ)(IOBJ))&apos;
fs
</figure>
<figureCaption confidence="0.98722">
Figure 4
</figureCaption>
<bodyText confidence="0.741419">
Final solution for Bangla sentence a&apos;pni a&apos;ma&apos;ke ekr a&apos; bai dilen.
</bodyText>
<sectionHeader confidence="0.988809" genericHeader="conclusions">
4. Discussion
</sectionHeader>
<bodyText confidence="0.999989130434783">
A comparison of our technique and other feature-based parsing mechanisms may be
in order. We provide brief comparisons with two such formalisms. In Rambow (1994),
a V-TAG parser (a Tree Adjoint Grammar extended to handle scrambling and other
aspects) is implemented through the {1-BEPDA,4 which uses sets of auxiliary trees as
unfulfilled nominal subcategorization. More recently, Johnson and Dorre (1995) have
presented a framework for constraint coroutining to deal with linguistic constraints
that cannot be effectively resolved during parsing at the location in which they are
most naturally introduced.
A properly designed NLP platform for Indian languages must come with an effi-
cient morphosyntactic unit for parsing words into their constituent morphemes where
lexical projections of words can be obtained from projections of individual morphemes.
At present, we have a fully implemented morphosyntactic lexical subsystem for Bangla
based on a formalism suitable for an LFG-based NLP platform, as proposed in Sen-
gupta and Chaudhuri (1993) and Sengupta (1994). We have implemented the operators
Locate (modified as suggested in the text), Merge (as an object-oriented unification
method), Include, and Search, and are in the process of creating an effective object-
oriented parser for c-structure generation.
We tested our formalism on a sample of about 250 simple and complex sentences
picked from newspaper clippings. Though phrasal orderings were quite random, al-
most all simple sentences in active voice (constituting about 57% of the samples) were
correctly parsed. The method has been extended to take care of a class of complex sen-
tences (with dependent clause &amp;quot;embedded&amp;quot; within the matrix) and &amp;quot;chained&amp;quot; clauses
as described in the results (not LFG based) in Sengupta (1994).
</bodyText>
<page confidence="0.783512">
4 A multiset version of Bottom-up Embedded Push-down Automata.
350
</page>
<note confidence="0.964059">
Sengupta and Chaudhuri Delayed Syntactic Encoding
</note>
<sectionHeader confidence="0.538104" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.993813081967214">
Bresnan, J. 1982a. Passive in lexical theory.
In J. Bresnan, editor, The Mental
Representation of Grammatical Relations. MIT
Press, Cambridge, MA, pages 3-86.
Bresnan, J. 1982b. Control and
Complementation. In J. Bresnan, editors,
The Mental Representation of Grammatical
Relations. MIT Press, Cambridge, MA,
pages 282-390.
Johnson, M. and J. Dorre. 1995.
Memorization of Coroutined Constraints.
In Proceedings of the 33rd Annual Meeting,
pages 100-107, Cambridge. Association
for Computational Linguistics.
Kaplan, R. M. and J. Bresnan. 1982. Lexical
Functional Grammar: A Formal System
for Grammatical Representation. In
J. Bresnan, editor, The Mental
Representation of Grammatical Relations. MIT
Press, Cambridge, MA, pages 173-281.
Kaplan, R. M., J. T. Maxwell, and
A. Zaenen. 1987. Functional Uncertainty.
In The CSLI Monthly, Center for the Study
of Language and Information, Stanford
University
Kaplan, R. M. and J. Maxwell. 1988. An
Algorithm for Functional Uncertainty.
Technical Paper No. P88-00084, Systems
Sciences Laboratory, XEROX PARC. (Also
in Proceedings of COLING-88, Budapest,
pages 297-302.)
Kaplan, R. M. and A. Zaenen. 1990.
Long-distance Dependencies, Constraint
Structure and Functional Uncertainty In
M. Baltin and A. Kroch, editors, Alternate
Conceptions of Phrase Structure. Chicago
University Press, Chicago.
Knight, K. 1989. Unification:
A Multidisciplinary Survey. ACM
Computing Surveys 21(1):93-124.
Maxwell, J. T. and R. M. Kaplan. 1991. A
Method for Disjunctive Constraint
Satisfaction. In M. Tomita, editor, Current
Issues in Parsing Technology. Kluwer
Academic Publishers, pages 173-190.
Mohanan, K. P. 1982. Grammatical Relations
and Clause Structure in Malayalam. In
J. Bresnan, editor, The Mental
Representation of Grammatical Relations. MIT
Press, Cambridge, MA, pages 504-589.
Rambow, 0. 1994. Formal and Computational
Aspects of Natural Language Syntax. Ph.D.
dissertation, University of Pennsylvania.
Sengupta, P. and B. B. Chaudhuri. 1993. A
Morpho-Syntactic Analysis Based Lexical
Sub-System. International Journal of Pattern
Recognition and Artificial Intelligence
7(3):595-619.
Sengupta, P. 1994. On Lexical and Syntactic
Processing of Bangla Language by Computer.
Ph.D. thesis, Indian Statistical Institute.
</reference>
<page confidence="0.998669">
351
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.756040">
<title confidence="0.943774">Squibs and Discussions A Delayed Syntactic-Encoding-based LFG Parsing Strategy for an Indian Language—Bangla</title>
<author confidence="0.943114">Probal Sengupta B B Chaudhuri</author>
<affiliation confidence="0.943527">Indian Statistical Institute Indian Statistical Institute</affiliation>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>J Bresnan</author>
</authors>
<title>Passive in lexical theory.</title>
<date>1982</date>
<booktitle>The Mental Representation of Grammatical Relations.</booktitle>
<pages>3--86</pages>
<editor>In J. Bresnan, editor,</editor>
<publisher>MIT Press,</publisher>
<location>Cambridge, MA,</location>
<contexts>
<context position="935" citStr="Bresnan 1982" startWordPosition="128" endWordPosition="129">Indian languages in general and Bangla (Bengali) in particular. (For the LFG formalism, see Kaplan and Bresnan [1982].) The technique may also be useful for other languages having similar properties. Indian languages are mostly nonconfigurational and highly inflectional. Grammatical functions (GF&apos;s) are predicted by case inflections (markers) on the head nouns of noun phrases (NPs) and postpositional particles in postpositional phrases (PPs). However, in many cases the mapping from case marker to GF is not one-to-one. The classical technique for non-configurational syntactic encoding of GF&apos;s (Bresnan 1982b) therefore requires a number of alternations to be thrown in to handle this phenomenon. The resulting nondeterminism in the parser implementation leads to a non-efficient unification component. The problem here, however, is not of unbounded functional uncertainty (described, with proposed solutions, in Kaplan, Maxwell, and Zaenen [1987], Kaplan and Maxwell [1988], and Kaplan and Zaenan [1990]), but rather, one of disjunctive constraint satisfaction bounded within the matrix. Disjunctive constraint satisfaction leads to a degradation of efficiency of the unification component of LFG, as has b</context>
<context position="2476" citStr="Bresnan (1982" startWordPosition="373" endWordPosition="374">ght scan of the parser) is available. Here we propose a technique that uses this fact to reduce alternations in syntactic encoding. Our method is based on a delayed evaluation of syntactic encoding schema. We treat the points of syntactic encoding of noun phrases as forward references that are temporarily maintained in a symbol table for later binding. A new metavariable, augmentation of the scope of the Locate operator, and a special type of schema (called m-structure) to be projected by the verb are some of the salient features of our technique. 2. Delayed Syntactic Encoding As suggested in Bresnan (1982a, 1982b) and Mohanan (1982), a flat constituent structure for a Bangla sentence S is given by the rule in (1), where constituent NPs and/or * Computer Vision and Pattern Recognition Unit, Indian Statistical Institute, 203 B. T. Road, Calcutta 700 035. India. E-mail: sprobal@isical.emet.in; bbc@isical.ernet.in 1 Maxwell and Kaplan (1991) also propose a method to minimize unification overhead. ® 1997 Association for Computational Linguistics Computational Linguistics Volume 23, Number 2 Table 1 Case markers and their possible grammatical functions. The GEN case marker normally marks a genitive </context>
</contexts>
<marker>Bresnan, 1982</marker>
<rawString>Bresnan, J. 1982a. Passive in lexical theory. In J. Bresnan, editor, The Mental Representation of Grammatical Relations. MIT Press, Cambridge, MA, pages 3-86.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Bresnan</author>
</authors>
<title>Control and Complementation.</title>
<date>1982</date>
<pages>282--390</pages>
<editor>In J. Bresnan, editors,</editor>
<publisher>MIT Press,</publisher>
<location>Cambridge, MA,</location>
<contexts>
<context position="935" citStr="Bresnan 1982" startWordPosition="128" endWordPosition="129">Indian languages in general and Bangla (Bengali) in particular. (For the LFG formalism, see Kaplan and Bresnan [1982].) The technique may also be useful for other languages having similar properties. Indian languages are mostly nonconfigurational and highly inflectional. Grammatical functions (GF&apos;s) are predicted by case inflections (markers) on the head nouns of noun phrases (NPs) and postpositional particles in postpositional phrases (PPs). However, in many cases the mapping from case marker to GF is not one-to-one. The classical technique for non-configurational syntactic encoding of GF&apos;s (Bresnan 1982b) therefore requires a number of alternations to be thrown in to handle this phenomenon. The resulting nondeterminism in the parser implementation leads to a non-efficient unification component. The problem here, however, is not of unbounded functional uncertainty (described, with proposed solutions, in Kaplan, Maxwell, and Zaenen [1987], Kaplan and Maxwell [1988], and Kaplan and Zaenan [1990]), but rather, one of disjunctive constraint satisfaction bounded within the matrix. Disjunctive constraint satisfaction leads to a degradation of efficiency of the unification component of LFG, as has b</context>
<context position="2476" citStr="Bresnan (1982" startWordPosition="373" endWordPosition="374">ght scan of the parser) is available. Here we propose a technique that uses this fact to reduce alternations in syntactic encoding. Our method is based on a delayed evaluation of syntactic encoding schema. We treat the points of syntactic encoding of noun phrases as forward references that are temporarily maintained in a symbol table for later binding. A new metavariable, augmentation of the scope of the Locate operator, and a special type of schema (called m-structure) to be projected by the verb are some of the salient features of our technique. 2. Delayed Syntactic Encoding As suggested in Bresnan (1982a, 1982b) and Mohanan (1982), a flat constituent structure for a Bangla sentence S is given by the rule in (1), where constituent NPs and/or * Computer Vision and Pattern Recognition Unit, Indian Statistical Institute, 203 B. T. Road, Calcutta 700 035. India. E-mail: sprobal@isical.emet.in; bbc@isical.ernet.in 1 Maxwell and Kaplan (1991) also propose a method to minimize unification overhead. ® 1997 Association for Computational Linguistics Computational Linguistics Volume 23, Number 2 Table 1 Case markers and their possible grammatical functions. The GEN case marker normally marks a genitive </context>
</contexts>
<marker>Bresnan, 1982</marker>
<rawString>Bresnan, J. 1982b. Control and Complementation. In J. Bresnan, editors, The Mental Representation of Grammatical Relations. MIT Press, Cambridge, MA, pages 282-390.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Johnson</author>
<author>J Dorre</author>
</authors>
<title>Memorization of Coroutined Constraints.</title>
<date>1995</date>
<booktitle>In Proceedings of the 33rd Annual Meeting,</booktitle>
<pages>100--107</pages>
<institution>Cambridge. Association for Computational Linguistics.</institution>
<contexts>
<context position="13795" citStr="Johnson and Dorre (1995)" startWordPosition="2336" endWordPosition="2339"> [ ANIM CASE DAT IOBJ PERS 1 PRED ANIM — DEF YES OBJ CASE NULL PERS 3 PRED &apos;book&apos; TENSE PAST PRED &apos;give((SUBJ), (OBJ)(IOBJ))&apos; fs Figure 4 Final solution for Bangla sentence a&apos;pni a&apos;ma&apos;ke ekr a&apos; bai dilen. 4. Discussion A comparison of our technique and other feature-based parsing mechanisms may be in order. We provide brief comparisons with two such formalisms. In Rambow (1994), a V-TAG parser (a Tree Adjoint Grammar extended to handle scrambling and other aspects) is implemented through the {1-BEPDA,4 which uses sets of auxiliary trees as unfulfilled nominal subcategorization. More recently, Johnson and Dorre (1995) have presented a framework for constraint coroutining to deal with linguistic constraints that cannot be effectively resolved during parsing at the location in which they are most naturally introduced. A properly designed NLP platform for Indian languages must come with an efficient morphosyntactic unit for parsing words into their constituent morphemes where lexical projections of words can be obtained from projections of individual morphemes. At present, we have a fully implemented morphosyntactic lexical subsystem for Bangla based on a formalism suitable for an LFG-based NLP platform, as p</context>
</contexts>
<marker>Johnson, Dorre, 1995</marker>
<rawString>Johnson, M. and J. Dorre. 1995. Memorization of Coroutined Constraints. In Proceedings of the 33rd Annual Meeting, pages 100-107, Cambridge. Association for Computational Linguistics.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R M Kaplan</author>
<author>J Bresnan</author>
</authors>
<title>Lexical Functional Grammar: A Formal System for Grammatical Representation. In</title>
<date>1982</date>
<booktitle>The Mental Representation of Grammatical Relations.</booktitle>
<pages>173--281</pages>
<editor>J. Bresnan, editor,</editor>
<publisher>MIT Press,</publisher>
<location>Cambridge, MA,</location>
<marker>Kaplan, Bresnan, 1982</marker>
<rawString>Kaplan, R. M. and J. Bresnan. 1982. Lexical Functional Grammar: A Formal System for Grammatical Representation. In J. Bresnan, editor, The Mental Representation of Grammatical Relations. MIT Press, Cambridge, MA, pages 173-281.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R M Kaplan</author>
<author>J T Maxwell</author>
<author>A Zaenen</author>
</authors>
<title>Functional Uncertainty.</title>
<date>1987</date>
<booktitle>In The CSLI Monthly, Center for the Study of Language and Information,</booktitle>
<location>Stanford University</location>
<marker>Kaplan, Maxwell, Zaenen, 1987</marker>
<rawString>Kaplan, R. M., J. T. Maxwell, and A. Zaenen. 1987. Functional Uncertainty. In The CSLI Monthly, Center for the Study of Language and Information, Stanford University</rawString>
</citation>
<citation valid="true">
<authors>
<author>R M Kaplan</author>
<author>J Maxwell</author>
</authors>
<title>An Algorithm for Functional Uncertainty.</title>
<date>1988</date>
<booktitle>Systems Sciences Laboratory, XEROX PARC. (Also in Proceedings of COLING-88,</booktitle>
<tech>Technical Paper No. P88-00084,</tech>
<pages>297--302</pages>
<location>Budapest,</location>
<marker>Kaplan, Maxwell, 1988</marker>
<rawString>Kaplan, R. M. and J. Maxwell. 1988. An Algorithm for Functional Uncertainty. Technical Paper No. P88-00084, Systems Sciences Laboratory, XEROX PARC. (Also in Proceedings of COLING-88, Budapest, pages 297-302.)</rawString>
</citation>
<citation valid="true">
<authors>
<author>R M Kaplan</author>
<author>A Zaenen</author>
</authors>
<title>Long-distance Dependencies, Constraint Structure and Functional Uncertainty</title>
<date>1990</date>
<booktitle>Alternate Conceptions of Phrase Structure.</booktitle>
<editor>In M. Baltin and A. Kroch, editors,</editor>
<publisher>Chicago University Press,</publisher>
<location>Chicago.</location>
<marker>Kaplan, Zaenen, 1990</marker>
<rawString>Kaplan, R. M. and A. Zaenen. 1990. Long-distance Dependencies, Constraint Structure and Functional Uncertainty In M. Baltin and A. Kroch, editors, Alternate Conceptions of Phrase Structure. Chicago University Press, Chicago.</rawString>
</citation>
<citation valid="true">
<authors>
<author>K Knight</author>
</authors>
<title>Unification: A Multidisciplinary Survey.</title>
<date>1989</date>
<journal>ACM Computing Surveys</journal>
<pages>21--1</pages>
<contexts>
<context position="1567" citStr="Knight (1989)" startWordPosition="219" endWordPosition="220">es a number of alternations to be thrown in to handle this phenomenon. The resulting nondeterminism in the parser implementation leads to a non-efficient unification component. The problem here, however, is not of unbounded functional uncertainty (described, with proposed solutions, in Kaplan, Maxwell, and Zaenen [1987], Kaplan and Maxwell [1988], and Kaplan and Zaenan [1990]), but rather, one of disjunctive constraint satisfaction bounded within the matrix. Disjunctive constraint satisfaction leads to a degradation of efficiency of the unification component of LFG, as has been pointed out in Knight (1989) and Maxwell and Kaplan (1991).1 A closer look at the languages reveals that most disjunctions do not exist if an a priori knowledge of the verb (which is generally at the end of the sentence, since Indian languages are mostly verb final and the verb is the last lexeme encountered in a leftto-right scan of the parser) is available. Here we propose a technique that uses this fact to reduce alternations in syntactic encoding. Our method is based on a delayed evaluation of syntactic encoding schema. We treat the points of syntactic encoding of noun phrases as forward references that are temporari</context>
</contexts>
<marker>Knight, 1989</marker>
<rawString>Knight, K. 1989. Unification: A Multidisciplinary Survey. ACM Computing Surveys 21(1):93-124.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J T Maxwell</author>
<author>R M Kaplan</author>
</authors>
<title>A Method for Disjunctive Constraint Satisfaction.</title>
<date>1991</date>
<booktitle>Current Issues in Parsing Technology.</booktitle>
<pages>173--190</pages>
<editor>In M. Tomita, editor,</editor>
<publisher>Kluwer Academic Publishers,</publisher>
<contexts>
<context position="1597" citStr="Maxwell and Kaplan (1991)" startWordPosition="222" endWordPosition="225">ernations to be thrown in to handle this phenomenon. The resulting nondeterminism in the parser implementation leads to a non-efficient unification component. The problem here, however, is not of unbounded functional uncertainty (described, with proposed solutions, in Kaplan, Maxwell, and Zaenen [1987], Kaplan and Maxwell [1988], and Kaplan and Zaenan [1990]), but rather, one of disjunctive constraint satisfaction bounded within the matrix. Disjunctive constraint satisfaction leads to a degradation of efficiency of the unification component of LFG, as has been pointed out in Knight (1989) and Maxwell and Kaplan (1991).1 A closer look at the languages reveals that most disjunctions do not exist if an a priori knowledge of the verb (which is generally at the end of the sentence, since Indian languages are mostly verb final and the verb is the last lexeme encountered in a leftto-right scan of the parser) is available. Here we propose a technique that uses this fact to reduce alternations in syntactic encoding. Our method is based on a delayed evaluation of syntactic encoding schema. We treat the points of syntactic encoding of noun phrases as forward references that are temporarily maintained in a symbol tabl</context>
</contexts>
<marker>Maxwell, Kaplan, 1991</marker>
<rawString>Maxwell, J. T. and R. M. Kaplan. 1991. A Method for Disjunctive Constraint Satisfaction. In M. Tomita, editor, Current Issues in Parsing Technology. Kluwer Academic Publishers, pages 173-190.</rawString>
</citation>
<citation valid="true">
<authors>
<author>K P Mohanan</author>
</authors>
<title>Grammatical Relations and Clause Structure in Malayalam. In</title>
<date>1982</date>
<booktitle>The Mental Representation of Grammatical Relations.</booktitle>
<pages>504--589</pages>
<editor>J. Bresnan, editor,</editor>
<publisher>MIT Press,</publisher>
<location>Cambridge, MA,</location>
<contexts>
<context position="2504" citStr="Mohanan (1982)" startWordPosition="377" endWordPosition="378">available. Here we propose a technique that uses this fact to reduce alternations in syntactic encoding. Our method is based on a delayed evaluation of syntactic encoding schema. We treat the points of syntactic encoding of noun phrases as forward references that are temporarily maintained in a symbol table for later binding. A new metavariable, augmentation of the scope of the Locate operator, and a special type of schema (called m-structure) to be projected by the verb are some of the salient features of our technique. 2. Delayed Syntactic Encoding As suggested in Bresnan (1982a, 1982b) and Mohanan (1982), a flat constituent structure for a Bangla sentence S is given by the rule in (1), where constituent NPs and/or * Computer Vision and Pattern Recognition Unit, Indian Statistical Institute, 203 B. T. Road, Calcutta 700 035. India. E-mail: sprobal@isical.emet.in; bbc@isical.ernet.in 1 Maxwell and Kaplan (1991) also propose a method to minimize unification overhead. ® 1997 Association for Computational Linguistics Computational Linguistics Volume 23, Number 2 Table 1 Case markers and their possible grammatical functions. The GEN case marker normally marks a genitive qualifier of a noun. However</context>
</contexts>
<marker>Mohanan, 1982</marker>
<rawString>Mohanan, K. P. 1982. Grammatical Relations and Clause Structure in Malayalam. In J. Bresnan, editor, The Mental Representation of Grammatical Relations. MIT Press, Cambridge, MA, pages 504-589.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Rambow</author>
</authors>
<title>Formal and Computational Aspects of Natural Language Syntax.</title>
<date>1994</date>
<institution>University of Pennsylvania.</institution>
<note>Ph.D. dissertation,</note>
<contexts>
<context position="13551" citStr="Rambow (1994)" startWordPosition="2303" endWordPosition="2304"> fb, and fc are for the NPs in order. 3 Alternately, since Bangla verbs are not marked for number, the NUM feature is omitted in agreement. 349 Computational Linguistics Volume 23, Number 2 ANIM CASE NULL SUBJ PERS 2 HON 1 PRED &apos;You&apos; [ ANIM CASE DAT IOBJ PERS 1 PRED ANIM — DEF YES OBJ CASE NULL PERS 3 PRED &apos;book&apos; TENSE PAST PRED &apos;give((SUBJ), (OBJ)(IOBJ))&apos; fs Figure 4 Final solution for Bangla sentence a&apos;pni a&apos;ma&apos;ke ekr a&apos; bai dilen. 4. Discussion A comparison of our technique and other feature-based parsing mechanisms may be in order. We provide brief comparisons with two such formalisms. In Rambow (1994), a V-TAG parser (a Tree Adjoint Grammar extended to handle scrambling and other aspects) is implemented through the {1-BEPDA,4 which uses sets of auxiliary trees as unfulfilled nominal subcategorization. More recently, Johnson and Dorre (1995) have presented a framework for constraint coroutining to deal with linguistic constraints that cannot be effectively resolved during parsing at the location in which they are most naturally introduced. A properly designed NLP platform for Indian languages must come with an efficient morphosyntactic unit for parsing words into their constituent morphemes</context>
</contexts>
<marker>Rambow, 1994</marker>
<rawString>Rambow, 0. 1994. Formal and Computational Aspects of Natural Language Syntax. Ph.D. dissertation, University of Pennsylvania.</rawString>
</citation>
<citation valid="true">
<authors>
<author>P Sengupta</author>
<author>B B Chaudhuri</author>
</authors>
<title>A Morpho-Syntactic Analysis Based Lexical Sub-System.</title>
<date>1993</date>
<journal>International Journal of Pattern Recognition and Artificial Intelligence</journal>
<pages>7--3</pages>
<contexts>
<context position="14435" citStr="Sengupta and Chaudhuri (1993)" startWordPosition="2430" endWordPosition="2434">nted a framework for constraint coroutining to deal with linguistic constraints that cannot be effectively resolved during parsing at the location in which they are most naturally introduced. A properly designed NLP platform for Indian languages must come with an efficient morphosyntactic unit for parsing words into their constituent morphemes where lexical projections of words can be obtained from projections of individual morphemes. At present, we have a fully implemented morphosyntactic lexical subsystem for Bangla based on a formalism suitable for an LFG-based NLP platform, as proposed in Sengupta and Chaudhuri (1993) and Sengupta (1994). We have implemented the operators Locate (modified as suggested in the text), Merge (as an object-oriented unification method), Include, and Search, and are in the process of creating an effective objectoriented parser for c-structure generation. We tested our formalism on a sample of about 250 simple and complex sentences picked from newspaper clippings. Though phrasal orderings were quite random, almost all simple sentences in active voice (constituting about 57% of the samples) were correctly parsed. The method has been extended to take care of a class of complex sente</context>
</contexts>
<marker>Sengupta, Chaudhuri, 1993</marker>
<rawString>Sengupta, P. and B. B. Chaudhuri. 1993. A Morpho-Syntactic Analysis Based Lexical Sub-System. International Journal of Pattern Recognition and Artificial Intelligence 7(3):595-619.</rawString>
</citation>
<citation valid="true">
<authors>
<author>P Sengupta</author>
</authors>
<title>On Lexical and Syntactic Processing of Bangla Language by Computer.</title>
<date>1994</date>
<tech>Ph.D. thesis,</tech>
<institution>Indian Statistical Institute.</institution>
<contexts>
<context position="14455" citStr="Sengupta (1994)" startWordPosition="2436" endWordPosition="2437">routining to deal with linguistic constraints that cannot be effectively resolved during parsing at the location in which they are most naturally introduced. A properly designed NLP platform for Indian languages must come with an efficient morphosyntactic unit for parsing words into their constituent morphemes where lexical projections of words can be obtained from projections of individual morphemes. At present, we have a fully implemented morphosyntactic lexical subsystem for Bangla based on a formalism suitable for an LFG-based NLP platform, as proposed in Sengupta and Chaudhuri (1993) and Sengupta (1994). We have implemented the operators Locate (modified as suggested in the text), Merge (as an object-oriented unification method), Include, and Search, and are in the process of creating an effective objectoriented parser for c-structure generation. We tested our formalism on a sample of about 250 simple and complex sentences picked from newspaper clippings. Though phrasal orderings were quite random, almost all simple sentences in active voice (constituting about 57% of the samples) were correctly parsed. The method has been extended to take care of a class of complex sentences (with dependent</context>
</contexts>
<marker>Sengupta, 1994</marker>
<rawString>Sengupta, P. 1994. On Lexical and Syntactic Processing of Bangla Language by Computer. Ph.D. thesis, Indian Statistical Institute.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>