<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<sectionHeader confidence="0.7461125" genericHeader="abstract">
F-PATR: FUNCTIONAL CONSTRAINTS FOR
UNIFICATION-BASED GRAMMARS
</sectionHeader>
<author confidence="0.453286">
Kent Wittenburg
</author>
<affiliation confidence="0.388987">
Bellcore
</affiliation>
<address confidence="0.7981885">
445 South St., MIRE 2A-347
Morristown, NJ 07962-1910, USA
</address>
<email confidence="0.980061">
Internet: kentw@bellcore.com
</email>
<sectionHeader confidence="0.995434" genericHeader="keywords">
Abstract
</sectionHeader>
<bodyText confidence="0.999909611111111">
Motivation for including relational constraints other
than equality within grammatical formalisms has come
from discontinuous constituency and partially free word
order for natural languages as well as from the need to
define combinatory operations at the most basic level
for languages with a two-dimensional syntax (e.g.,
mathematical notation, chemical equations, and various
diagramming languages). This paper presents F-PATR,
a generalization of the PATR-II unification-based for-
malism, which incorporates relational constraints
expressed as user-defined functions. An operational
semantics is given for unification that is an adaptation
and extension of the approach taken by Ait-Kaci and
Nasr (1989). It is designed particularly for unification-
based formalisms implemented in functional program-
ming environments such as Lisp. The application of
unification in a chart parser for relational set languages
is discussed briefly.
</bodyText>
<sectionHeader confidence="0.999766" genericHeader="introduction">
1. INTRODUCTION
</sectionHeader>
<bodyText confidence="0.999889114754099">
For the most part, unification-based grammar for-
malisms (e.g., Kaplan and Bresnan 1982; Pereira and
Warren 1980; Shieber 1984) have adopted string
rewriting conventions from context-free grammar rules,
assuming string concatenation as the basic combining
operator external to the unification process itself. Kay&apos;s
Functional Unification Grammar (Kay 1979), while not
borrowing the conventions of CFG rewriting rules, still
assumed concatenation of strings as the underlying
combining operation. However, recent work in HPSG
(e.g., Pollard and Sag 1987, Reape 1990, Carpenter et al.
1991) and elsewhere has sought to incorporate con-
straints for combining operations into the unification-
based representation directly. Part of the motivation for
doing so is to accommodate partially free word order
and discontinuous constituency without the complica-
tion of passing along intermediate &amp;quot;threading&amp;quot; informa-
tion within derivations. Such exensions to unification
grammars require the use of nonequational constraints,
i.e., constraints on values other than simple conditions
of equality and the logical connectives built with them.
Reape (1990) has proposed, for example, the relations
permutation and sequence union to constrain word
sequences in his HPSG fragment for German.
A different motivation for extending the constraint
language for combination within unification grammars
comes from languages with a two-dimensional syntax
(e.g., mathematical notation, chemical equations, and
various diagramming languages). Approaching such
domains from a linguistic perspective requires that
grammars be capable of dealing with a richer source of
data types than just strings and also with specifying a
richer set of combinatory operations than simple string
concatenation. The approach taken by Helm and Mani-
ott (1986, 1990) and Wittenburg, Weitzman, and Talley
(1991) [hereafter WW1.] is to augment declarative, uni-
fication-based grammars with relational constraints.
Combinatory operations can then be defined out of the
sets of relational constraints present in rule bodies. The
approach in WWT includes a set-valued attribute called
cover in feature structures. Relations such as above,
below, north-east-of, and connected-to are examples
that may be incorporated into cover constraints used in
grammars for two-dimensional languages. These con-
straints apply to sets of the basic input vocabulary,
whose members may themselves be complex objects.
The use of sets in these grammars takes the place of
strings, or sequences of words, as used in grammars for
natural languages.
This paper presents a generalization of the PATR-II
unification-based grammar formalism to incorporate
relational constraints. The extension has been primarily
motivated by the demands of combinatory operations in
the syntax for two-dimensional languages although such
constraints can be used to express more complex com-
binatory relations on strings as well as for other pur-
poses (see, for example, work in CLG (Damas and
Varile 1989; Balari et al. 1990)).
The approach described here arose as a result of
extending a Lisp-based implementation of PATR-II
used with a chart parser. A natural path was provided by
</bodyText>
<page confidence="0.997775">
216
</page>
<bodyText confidence="0.999905875">
Ait-Kaci and Nasr (1989), who proposed integrating
logic and functional programming by allowing con-
straints to be specified with applicative expressions.
This work has subsequently become one of the three
cornerstones of the programming language Life (Ait-
Kaci 1990). The key idea is to allow interpreted func-
tional expressions to appear as bona fide arguments in
logical statements. Unification operations then must
allow for delaying the evaluation of functional expres-
sions until such time as argument variables become
grounded, a process that leads to what Ait-Kaci and
Nasr call residuation.
For the most part, the adaptation of Ait-Kaci and
Nasr&apos;s methods to an extension of PATR-H proved to
be straitforward. However, there are two points on
which the operational semantics of F-PATR unifica-
tion as defined here differs from theirs. The first, a
variation on dereferencing applicative values, was
motivated by the demands of caching intermediate
results imposed by chart parsing. The second, atomic
disjunction, allows for more expressiveness in the
grammar and also, again, was motivated by the parsing
algorithm we assumed. We will return to these points
in Section 6.
</bodyText>
<sectionHeader confidence="0.999128" genericHeader="method">
2. FUNCTIONAL CONSTRAINTS
</sectionHeader>
<bodyText confidence="0.992172203389831">
From the graph perspective, the basic vocabulary of
PATR-II (Shieber 1984) consists of a set of arc labels
and a set of terminal (leaf) node labels, the latter
including a variable (or null) value. The graphs can
have reentrancies at the leaf levels or higher up, which
express identity (or unification) of structure.
Following Ait-Kaci and Nasr (1989), we incorpo-
rate applicative expressions (function specification
followed by zero or more argument specifications),
into our constraint language. Two uses of applicative
expressions in the Ait-Kaci/Nasr language Le Fun
concern us here. The first allows variables to equate to
an (eventual) evaluation of some applicative expres-
sion whose arguments may contain variables. For
example,
X = (union Y Z)
(Our convention will be to write applicative expres-
sions using Lisp s-expression syntax, i.e, function
name followed by zero or more arguments all enclosed
in parentheses.) The second allows Le Fun clauses to
be formed from arbitrary ground-decidable predicates,
i.e., applicative expressions whose arguments also
may start out as variables. For example, given the
user-defined boolean function sw-of (south-west of),
the following would be an acceptable statement: (sw-
of X Y).
The analogous PATR-II extension to the first of
these allows leaf nodes to be labeled with an applica-
tive expression. Any &amp;quot;unbound&amp;quot; arguments in these
applicative expressions will point to variable nodes
elsewhere in the graph. Equations such as the follow-
ing example will then be allowed in the language.
&lt;mother cover&gt; = (union &lt;daught 1 cover&gt;
&lt;daught2 cover&gt;)
In F-PATR, we restrict the types of nodes repre-
sented by paths to those that may appear as leaf values,
i.e., atomic, a disjunction of atoms, null (variable), or
another applicative value. This restriction is signifi-
cant: it does not allow for arguments in functional con-
straints to be of the complex attribute-value type.
The second use of applicative expressions, as pred-
icates, allows the inclusion of functional expressions
into feature specifications as independent conditions
on successful unification. So here the evaluation of the
expression is not associated with a leaf node&apos;s value.
The statement below is an example of a such a con-
straint on the value of a node that might be included in
graph. This predicate sw-of will be taken to be a con-
dition on successful unification.
(sw-of &lt;daughtl cover&gt; &lt;daught2 cover&gt;)
The two statements above taken together would
then correspond to the graph shown in Figure 1, a first
approximation for a rule for forming exponent expres-
sions in a grammar of mathematical notation. The
unlabeled arcs linking arguments in applicative
expressions to the variable nodes are a notational con-
venience, indicating a forwarding pointer. The argu-
ments to these expressions are in fact the nodes
themselves.
</bodyText>
<figure confidence="0.5357675">
(union
(sw-of
</figure>
<figureCaption confidence="0.940705">
Figure 1 An F-PATR Graph
</figureCaption>
<bodyText confidence="0.9943945">
Our proposal for F-PATR feature structures begins
with a vocabulary of the following types suitable for
</bodyText>
<equation confidence="0.839089666666667">
daughtl
cover
daught2
cover
mother
cover
</equation>
<page confidence="0.991426">
217
</page>
<bodyText confidence="0.971186066666667">
interpretive, functionally oriented programming lan-
guages such as Lisp.
Atom Symbol or number
Fun-exp Function, i.e, symbol pointing to a function,
or lambda expression interpretable as a
function, of type
Atom X Atom X ... Atom -4 Atom
or else
Atom X Atom X ... Atom --&gt; List-of-atoms
(where List-of-atoms will be interpreted as
a logical disjunction of atomic values)
S-expression Any complete evaluatable expression with-
out internal references to F-PATR nodes
The following then is a BNF grammar for F-PATR
equations representing feature structures:
</bodyText>
<equation confidence="0.9746685">
Feat-struct ::= Statement+
Statement ::= Atom I Equation I App!
Equation ::= Path = Path I Path = Val I Path =
Appl
Path ::= &lt; Atom+ &gt;
Val ::= Atom I (Atom Atom + }
Appl ::= ( Fun-exp Arg*)
Arg ::= Path I App! I S-expression
</equation>
<bodyText confidence="0.9494248">
We will assume the existence of a familiar equiva-
lent notation for these feature equations, in which
graph reentrancies (or path equivalences) are
expressed by a matrix with integers used for shared
reference. Predicates will follow the core attribute-
value matrix. For example,
[a: 1[]
b: 2(foo &lt;1&gt;)]
(fie &lt;1&gt; &lt;2&gt;)
is equivalent to
&lt;b&gt; = (foo &lt;a&gt;)
(fie &lt;a&gt; &lt;b&gt;).
In addition to functional values and constraints, we
augment the original PATR-II notation with atomic
disjunction (interpreted as exclusive OR) as a possible
value of leaf nodes. Such values are written with curly
braces surrounding two or more atoms. Atomic dis-
junction is one of the most basic extensions to the
PATR-I1 unification language and is in common use.
If atomic values are considered to be singleton sets,
unification of atomic disjunctions with other disjunc-
tions or atoms can be operationally treated as set inter-
section. In F-PATR, atomic disjunctions may appear
not only independently but also as arguments and val-
ues of applicative expressions.
</bodyText>
<sectionHeader confidence="0.983716" genericHeader="method">
3. DATA TYPES
</sectionHeader>
<bodyText confidence="0.998238127659575">
In Ait-Kaci and Nasr (1989), functional expres-
sions in feature structures are evaluated as soon as
their arguments become bound. Otherwise, data struc-
tures will become residuated, a state representing
incompletion with respect to determining constraints
on unification. Ait-Kaci and Nases algorithms thus
delay the resolution of functionally-specified values or
predicates until all variables are bound, but then
resolve them as early as possible once bindings occur.
Here we follow this same general approach for predi-
cates only, but not for applicative values, which are
checked for readiness to evaluate only when derefer-
enced. Further, we expand the routines to deal with
atomic disjunction.
We assume the following data types for nodes in a
feature structure graph:
:Arc-list a set of attribute labels and associated val-
ues, the latter of which may be of any type
:null the uninstantiated &amp;quot;variable&amp;quot; type
:atomic a singleton set of one symbol or number
:disjunct a set of 2 or more atomic values
:appl an applicative expression
:res-var a residuated variable, i.e., a :null type that
appears as an argument in at least one
predicate
:res-disjunct a residuated disjunction, i.e., a :disjunct
type that appears as an argument in at least
one predicate
The node types that may acquire residuations
include :null, :disjunct, and :appl (a type for which we
do not distinguish residuated from nonresiduated sub-
types). There are two kinds of residuations: predicates
not ready for evaluation and delayed unifications asso-
ciated with the :appl type. Predicate residuations arise
when a predicate contains any arguments of type :null
or :appl, or else when a predicate has more than one
argument of type :disjunct. During unification, any
such arguments mutate to a residuated type (if they are
unresidutated to start with), and the predicate is pushed
onto their residuation list.
The second kind of residuation arises when unifica-
tion is called for between a node of type :appl that is
not ready for evaluation and any other non-:null type.
The unification call itself must be delayed until such
time as the function is ready for evaluation, and so a
form that will provoke the unification is pushed onto
the residuation list of the :appl node.
</bodyText>
<page confidence="0.991629">
218
</page>
<bodyText confidence="0.9978825">
function. But note that functions used in F-PATR
graphs do not themselves take disjunctive arguments
directly, as indicated in the discussion of data types
above.
</bodyText>
<tableCaption confidence="0.976126">
Table 1: Unification for leaf types
</tableCaption>
<figure confidence="0.8405208">
:null :atom :disju :appl :r-var :r-dis
:null :null :atom :disju :appl :r-var :r-dis
:atom :atom :atom :atom :appl :atom :atom
:disju
:r-dis
:disju :disju :atom :atom :appl :atom :atom
:disju :disju :disju
:r-dis :r-dis
:appl :appl :appl :appl :appl :appl :appl
:r-var :r-var :atom :atom :appl :r-var :atom
:disju :disju
:r-dis :r-dis
:r-dis :r-dis :atom :atom :appl :atom :atom
. :disju :disju :disju :disju
:r-dis :r-dis :r-dis :r-dis
</figure>
<bodyText confidence="0.999536625">
There are a number of pairings in Table 1 that are
capable of producing either residuated disjunctions,
disjunctions, or atoms. These all involve a residuated
predicate appearing in at least one of the leaf node
arguments. If the initial intersection of the node&apos;s con-
tents (independently from residuations) yields a value
that still does not provoke evaluation of the predicate,
then the result is a residuated disjunction. If the pred-
icate is evaluated, then the unification process may
yield an atomic value or a disjunctive value, as
explained in the previous paragraph.
Space precludes us from further discussion of the
unification algorithms here. With reference to Ait-
Kaci and Nasr (1989) and Table 1, however, the
details should emerge. See also the examples in the
Appendix, which are taken from program output.
</bodyText>
<sectionHeader confidence="0.975557" genericHeader="method">
6. APPLICATION TO PARSING
</sectionHeader>
<bodyText confidence="0.999569">
The two significant design changes that we have
introduced were motivated by our application of F-
PATR to parsing of relational set grammars for graph-
ical languages, which is discussed in detail in WWT.
Initial experiments adopted the Ait-Kaci/Nasr
</bodyText>
<sectionHeader confidence="0.997609" genericHeader="method">
4. DEREFERENCING
</sectionHeader>
<bodyText confidence="0.999982296296296">
The notion of dereferencing a data structure repre-
senting a feature value (or node) is common to most
unification implementations. A field in the data struc-
ture indicates whether the value is to be found locally
or else by following pointers to other data structures
that may have been introduced through prior unifica-
tion. Introducing residuations into the data structures
adds the wrinlde that, during dereferencing, applica-
tive expressions will be evaluated if they are ready. In
F-Patr, dereferencing an :appl type node is in fact the
only point at which to evaluate an applicative expres-
sion. This is a change from Le Fun--there arguments
in applicative expressions may acquire applicative
expressions as residuations that can be evaluated as
argument terms become grounded during unification.
This design change will be motivated in Section 6.
For each node type, the dereference function fol-
lows pointers in the usual way until no pointers
remain. In addition, if the resulting node is of :appl
type, we check to see if all its arguments are atomic or
else lisp s-expressions, an indication that the function
is ready to be evaluated. If the function evaluates to a
non-nil atom or a disjunctive list of atoms, then any
residuations (delayed unifications) on the node are
also called. Note then that dereferencing can itself fail
as a result of provoking unifications that fail, which the
top-level unification routines need to take account of.
</bodyText>
<sectionHeader confidence="0.999109" genericHeader="evaluation">
5. UNIFICATION
</sectionHeader>
<bodyText confidence="0.999950380952381">
The types associated with successful unifications of
dereferenced leaf node types are shown in Table 1.
Some cells contain more than one type since residua-
tions and disjunctions may or may not be reduced in
the result term. Note that an :appl type unified with
any other type always yields another :appl type. This
is a bit misleading, however, since the table does not
take into account the effects of dereferencing, which,
as we have just described, can provoke a chain of
delayed unifications involving any types.
During unification, the evaluation of functions
used in predicates and :appl nodes each may produce
disjunctive values, but in different ways. Predicates
can be evaluated when there is at most one disjunctive
argument node, in which case we map the predicate
Over each of the disjunctions in the disjunctive argu-
ment, and collect successful results. If there is more
than one successful result, then the result is a disjunc-
tion. Alternatively, for functions appearing in :appl
nodes only, the function itself may produce a disjunc-
tive value as directed by the internal definition of the
</bodyText>
<page confidence="0.995202">
219
</page>
<bodyText confidence="0.997805681818182">
approach of evaluating the functions of :appl nodes as
soon as possible, which meant residuating the argu-
ment nodes of these functions. However, this
approach led to difficulties in our chart parsing algo-
rithm, which needed to cache the feature structures of
active edges before any of the destructive effects of
unification involving what we call expander functions
took place. The root of the issue is that with the Ait-
Kaci/Nasr approach, the control of function evaluation
is within unification rather than with some external
algorithm. In our approach, it was most natural to use
external control to implement chart parsing. This
point may be clarified by considering an example, for
which we need to summarize F-PATR relational set
grammars. (See also Wittenburg (1992a 1992b).)
The feature structures for grammatical constituents
include the primary attributes cover, syntax, and
semantics. The attribute cover takes as value a refer-
ence to a subset of input objects. This scheme is anal-
ogous to HPSG feature structures, where the string-
valued phonology attribute is replaced by the set-val-
ued cover attribute. Rules have the form
</bodyText>
<equation confidence="0.813822444444444">
[mother: [cover: []
syntax: [1
semantics: 0]
daughti : [cover: []
syntax: []
semantics: []]
. . .
daughtn: [cover: []
syntax: []
</equation>
<bodyText confidence="0.79519703030303">
semantics: [1]]
with the condition that for the daughter elements of a
rule 131...130, there must exist at least one expander
relation between covers of each daughter Di, 2 i n,
and a cover of daughter Di where j &lt;i.
The expander relations are a subclass of relational
constraints among sets of input objects used to define
the combinatory possibilities of rules. For parsing, the
constraints are expressed as functions from cover-sets
to cover-sets and appear as a functional value of cover
attributes.
[mother: [syntax: Exp
cover: (union-covers &lt;2&gt; &lt;3&gt; &lt;4&gt;)
semantics: (divide &lt;6&gt; &lt;7&gt;)]
daught 1 : [syntax: horizontal-line
cover: 2[]]
daught2: [syntax: Exp
cover: 3(what-is-above &lt;2&gt;)
semantics: &lt;6&gt;]
daught3: [syntax: Exp
cover: 4(what-is-below &lt;2&gt;)
semantics: &lt;7&gt;]]
(contains-in-x &lt;2&gt; &lt;4&gt;)
(contains-in-x &lt;2&gt; &lt;3&gt;)
The example above is the rule for vertical infixation
for fractions, used in a grammar of mathematical nota-
tion.
Let us consider now what the feature structure for
an active chart-parsing edge for the fraction rule would
look like after the first daughter had been unified in.
The cover attribute would acquire a set-reference
value (we will use a number in binary suggestive of the
use of bit vectors to represent subsets).
</bodyText>
<figure confidence="0.316043142857143">
Active edge feature structure:
[mother: [syntax: Exp
cover: (union-covers 0001 &lt;3&gt; &lt;4&gt;)
semantics: (divide &lt;6&gt; &lt;7&gt;)]
daughti: [syntax: horizontal-line
cover: 0001]
daught2: [syntax: Exp
cover: 3(what-is-above 0001)
semantics: &lt;6&gt;]
daught3: [syntax: Exp
cover: 4(what-is-below 0001)
semantics: &lt;7&gt;]]
(contains-in-x 0001 &lt;4&gt;)
(contains-in-x 0001 &lt;3&gt;)
</figure>
<bodyText confidence="0.99998955">
At this point the Ait-Kaci/Nasr algorithm for unifi-
cation would provoke the evaluation of the what-is-
above and what-is-below functions, since their argu-
ments are now &amp;quot;grounded&amp;quot;. However, this is not what
we want for a chart parser since the features of the
active edge graph shown here must be kept indepen-
dent from each of its future advancements. That is, we
want to evaluate these two functions at separate cycles
in the parsing algorithm at the points when we are
ready to extend this edge with the daughters in ques-
tion. The more conservative approach to derefencing
and evaluation of :appl nodes and also the extension of
disjunctions as possible values of expander functions
provides an elegant solution.&apos; The functions what-is-
above and what-is-below will be evaluated in indepen-
dent expand steps of the WWT algorithm. In either
case, the function is capable of returning a disjunction
of values. But any such values must also meet the con-
straints of the predicate contains-in-x, the application
of which may have the effect of reducing the set of val-
</bodyText>
<footnote confidence="0.7493765">
1. Hassan Ait-Kaci (personal communication) has pointed out
that a solution to the control problem is available in the Le Fun/LIFE
framework. An extra unbound argument could be added to
expander functions such as what-is-above so that evaluation would
not be provoked at undesired times. A binding for this extra variable
could later be offered when evaluation was wanted.
</footnote>
<page confidence="0.995415">
220
</page>
<bodyText confidence="0.999822">
ues and perhaps eliminating all of them, leading to a
unification failure. All this happens as it should with
the approach to unification outlined above.
</bodyText>
<sectionHeader confidence="0.993314" genericHeader="conclusions">
7. CONCLUDING REMARKS
</sectionHeader>
<bodyText confidence="0.999984954545454">
One of the goals of this paper is to bring the work
of Ait-Kaci and Nasr to the attention of the computa-
tional linguistics community. Their techniques for
marrying declarative and functional programming par-
adigms are an important avenue to explore in expand-
ing the expressiveness of formalisms for linguisic
applications. The design issues encountered in build-
ing an implementation of F-PATR should be of inter-
est to implementors of such a paradigm. Of course we
do not address here issues in the logic of such feature
structures or their declarative semantics. The signifi-
cant differences of F-Patr from Le Fun include an
alternative approach to dereferencing certain data
types, a change motivated by an environment in which
parsing control is outside the unification process, and
also an extension to a simple form of disjunction. In
contrast to the research projects that implement unifi-
cation-based grammar formalisms on top of Prolog,
this implementation has built a unification environ-
ment on top of Lisp. The job of integrating the declar-
ative and functional paradigms is made considerably
easier by relying on Lisp for lambda conversion and
function evaluation.
In the by now extensive literature on unification
grammar frameworks, the current proposal figures as a
somewhat conservative, and yet radically expressive,
extension to PATR-II. It is conservative in that the
logic of feature structures includes only minimal dis-
junction and no negation or conditionalization. But
the extension leads to unlimited expressive power by
bringing in the full power of function evaluation. It
appears to be an extension appropriate for the repre-
sentational problems we encountered, but it also has
led to unanticipated uses. For example, in writing the
semantics for graphical grammars we have been able
to use functions in feature structures as a way of build-
ing forms that can simply be evaluated to invoke the
appropriate operations for applications. Here again,
having more control over when evaluation takes place
external to the unification process has proved to be
important.
There are limitations, however, to the expressive
power of F-PATR as it stands. It cannot directly sup-
port some of the constraints envisioned in current
HPSG literature, for example, because of F-PATR&apos;s
restrictions on arguments to functional constraints. In
HPSG, relations constrain not just atomic values but
also general feature structures incuding lists and sets.
Such an extension to F-PATR is not planned by the
author but it may be of interest. From the logic gram-
mar point of view, the work reported on here may be
relevant as a source of ideas for efficiency. Con-
straints expressed as relations in frameworks such as
Zajac (1992) could instead be expressed in F-PATR as
compiled functions, leading perhaps to improved
runtime speeds.
The MCC/Bellcore implementation of F-PATR
includes both destructive and nondestructive versions
of unification. The destructive version is, as expected,
more straightforward to implement but more expen-
sive computationally given that over copying and early
copying are profligate (see Wroblewski 1987). The
algorithms for nondestructive unification have been
influenced by Tomabechi (1991), but applicative
expressions and residuations change the landscape sig-
nificantly. There tends to be extensive circularity in
the data structures: residuated argument nodes point to
predicates that in turn point back to their arguments;
residuations in applicative-valued nodes point to unifi-
cation forms that in turn point back to the applicative
nodes. There is a need for future work to address issues
of space and time efficiency for extensions represented
by F-PATR just as there has been such a need for other
PATR-II extensions.
A line of research that the author is pursuing cur-
rently (Wittenburg 1992b) is to design a more spe-
cialized grammar formalism that finesses some of the
complexity of residuation and unification through a
version of &amp;quot;pseudo-unification&amp;quot; (Tomita 1990). In
contrast to residuation, which manages function eval-
uation at runtime, the idea is to manage the order of
evaluation for functional constraints at compile time.
In grammar formalisms and parsers under investiga-
tion, it is possible for a compiler to order constraints
within rule data structures such that evaluation readi-
ness is a deterministic matter, circumventing the need
for runtime checks and extra data structures required
for delaying evaluation dynamically.
</bodyText>
<sectionHeader confidence="0.994724" genericHeader="acknowledgments">
ACKNOWLEDGEMENTS
</sectionHeader>
<bodyText confidence="0.999887111111111">
This research was carried out at MCC under the
sponsorship of Bellcore and MCC. Louis Weitzman
and Jim Talley worked closely with the author in
exploring the use of F-PATR grammars in visual lan-
guage applications. Roger Nasr was very helpful in
consultations on the Le Fun unification algorithms.
Thanks to Phil Cannata and Jim Hollan for their sup-
port of the project and to the anonymous ACL review-
ers for their helpful comments on the manuscript.
</bodyText>
<page confidence="0.9979">
221
</page>
<sectionHeader confidence="0.994612" genericHeader="references">
REFERENCES
</sectionHeader>
<reference confidence="0.996809984615385">
Ait-Kaci, H. (1991) An Overview of LIFE. In J.W.
Schmidt and A.A. Stogny (eds.), Next Generation Informa-
tion System Technology, Proceedings of the 1st Interna-
tional East/West Data Base Workshop, Lecture Notes in
Computer Science 504, Springer Verlag, pp. 42-58.
Ait-Kaci, H., and R. Nasr (1989) Integrating Logic and
Functional Programming. Lisp and Symbolic Computation
2:51-89.
Balari, S., L. Damas, and G. B. Varile (1989) CLG: Con-
straint Logic Grammars, Proceedings of the 13th Interna-
tional Conference on Computational Linguistics, Helsinki,
vol. 3, pp. 7-12.
Carpenter, B., C. Pollard, and A. Franz (1991) The Spec-
ification and Implementation of Constraint-Based Unifica-
tion Grammars. In Proceedings IWPT 91, Second
International Workshop on Parsing Technologies, pp. 143-
153.
Damas, L. and G. Varile (1989) CLG: A Grammar For-
malism based on Constraint Resolution. In E.M. Morgado
and J.P. Martins (eds.), EPIA &apos;89, Lecture Notes in Artificial
Intelligence 390, Springer Verlag.
Helm, R., and K. Marriott (1986) Declarative Graphics.
In Proceedings of the Third International Conference on
Logic Programming, Lecture Notes in Computer Science
225, pp. 513-527. Springer-Verlag.
Helm, R., and K. Marriott (1990) Declarative Specifica-
tion of Visual Languages. In 1990 IEEE Workshop on
Visual Languages (Skokie, Illinois), pp. 98-103.
Kaplan, R., and J. Bresnan (1982) Lexical-Functional
Grammar: A Formal System for Grammatical Representa-
tion. In J. Bresnan (ed.), The Mental Representation of
Grammatical Relations, MIT Press, pp. 173-281.
Kay, M. (1979) Functional Grammar. In Proceedings of
the Fifth Annual Meeting of the Berkeley Linguistic Society.
Pereira, F.C.N., and D. Warren (1980) Definite Clause
Grammars for Language Analysis--A Survey of the Formal-
ism and a Comparison with Augmented Transition Net-
works. Artificial Intelligence 13:231-278.
Pollard, C., and I. Sag (1987) Information-based Syntax
and Semantics: Volume 1. Center for the Study of Language
and Information.
Reape, M. (1990) Getting Things in Order. In Proceed-
ings of the Symposium on Discontinuous Constituency,
Institute for Language Technology and Artificial Intelli-
gence, Tilburg University, The Netherlands, pp. 125-137.
Tomabechi, H. (1991) Quasi-Destructive Graph Unifica-
tion. In Proceedings IVVPT 91, Second International Work-
shop on Parsing Technologies, pp. 164-171.
Tomita, M. (1990) The Generalized LR Parser/Compiler
V8-4: A Software Package for Practical NL Projects. In:
COLING-90, Volume 1, 59-63.
Wittenburg, K. (1992a) Earley-style Parsing for Rela-
tional Gramars. In Proceedings of IEEE Workshop on Visual
Languages, Sept. 15-18, 1992, Seattle, Washington, pp.
192-199.
Wittenburg, K. (1992b) The Relational Language Sys-
tem, Bellcore Technical Memorandum TM-ARH-022353.
Wittenburg, K., L. Weitzman, and J. Talley (1991) Unifi-
cation-Based Grammars and Tabular Parsing for Graphical
Languages. Journal of Visual Languages and Computing
2:347-370.
Wroblewski, D. (1987) Nondestructive Graph Unifica-
tion. In Proceedings of AAAI 87, pp. 582-587.
Zajac, R. (1992) Inheritance and Constraint-Based Gram-
mar Formalisms. Computational Linguistics 18:159-182.
</reference>
<table confidence="0.416529511111111">
APPENDIX: Unification Examples
Example 1 :appl with :atom
[ obj: [ length: 25]]
U [ obj: [ length: (+ 1[] 2[])]
obj2: [length: &lt;2&gt;1
objl: [ length: &lt;1&gt;]]
= [ obj: [ length: 1(+ 2[1 3[])1
obj2: [ length: &lt;3&gt;1
objl: [ length: &lt;2&gt;]]
(Unify &lt;1&gt; 25)
U [objl: [ length: 20])
= [ obj: [ length: 1(+ 20 2[])]
obj2: [ length: &lt;2&gt;]
objl: [ length: 201]
(Unify &lt;1&gt;25)
U [ obj2: [ length: 5]]
= ( obj: [ length: 1(+ 20 5)]
obj2: [ length: 5]
objl: [ length: 20]]
(Unify &lt;1&gt;25)
Example 2 :res-var with :atom
[ obj: [ length: 1[]]
objl: [ length: 2[]1]
(EQ &lt;1&gt; &lt;2&gt;)
U [ obj: [ length: 551]
= [ obj: [ length: 55]
objl: [ length: 10]1
(EQ 55 &lt;1&gt;)
U [objl: [ length: 55]]
= ( obj: [ length: 55]
objl: [ length: 5511
Example 3 :res-var with :disjunct
[ obj: [ length: 1[]]
objl: [ length: 2[1]]
(EQ &lt;1&gt; &lt;2&gt;)
U [ obj: [ length: (55 36)]]
[ obj: [length: 1(5536)]
objl: [ length: 2[]1]
(EQ &lt;1&gt; &lt;2&gt;)
U [objl: [ length: 55]]
= [ obj: length: 55]
objl: [ length: 55]1
Example 4 :appl with :res-var
[objl: [ length: (+ 5 1[1)]
obj2: [ length: &lt;I&gt;]1
</table>
<page confidence="0.978361">
222
</page>
<equation confidence="0.843877">
U [ objl: [ length: 1[]]
obj2: [ length: [1]]
(&gt;= &lt;1&gt;54)
= [ objl: [ length: 1(+ 5 2[])]
obj2: [ length: &lt;2&gt;]]
(&gt;= &lt;1&gt;54)
U [ obj2: [ length: 501]
= [ objl: [ length: 1(+ 5 50)]
obj2: [ length: 50]]
(&gt;. &lt;1&gt;54)
U [ objl: [ length: []]]
= [ objl: [ length: 55]
obj2: [ length: 50]]
Example 5 :res-var with :res-var
[ obj: [ length: 1[]]]
(&lt;= &lt;1&gt;60)
U [ obj: [ length: 1[]]]
(&gt;= &lt;1&gt;54)
= [ obj: [ length: 1[]]]
(&gt;= &lt;1&gt;54)
(&lt;= &lt;1&gt;60)
U [ obj: [ length: 5511
= [ obj: [ length: 55]]
Example 6 :res-disjunct with :atom and :disjunct
[ obj: [ length: 1(55 43 44)]
objl: [ length: 2[]]]
(EQ &lt;1&gt; &lt;2&gt;)
</equation>
<bodyText confidence="0.70659709375">
U [ obj: [ length: (43 55 )]]
= [ obj: [ length: 1(55 43)]
objl: [ length: 2[]]]
(EQ &lt;1&gt; &lt;2&gt;)
U [ obj: [ length: 55]]
= [ obj: [ length: 55]
objl: [ length: l[]]]
(EQ 55 &lt;1&gt;)
U [ objl: [ length: 55]]
= [ obj: [ length: 55]
objl: [ length: 55]]
Example 7 :appl with :res-disjunct
[ objl: [ length: (+ 5 10)]
obj2: [ length: &lt;1&gt;]]
U [ objl: [ length: 1{55 4342)]
obj2: [ length: 2[]]]
(&gt; &lt;1&gt; &lt;2&gt;)
= [ objl: [ length: l(+5 2[])]
obj2: [ length: &lt;2&gt;]]
(Unify &lt;1&gt; (55 43 42))
(&gt; &lt;1&gt; &lt;2&gt;)
U [ obj2: [ length: 50]]
= [ objl: [ length: 1(+ 5 50)]
obj2: [ length: 50]]
(&gt; &lt;1&gt;50)
(Unify &lt;1&gt; (55 43 42))
U [ objl: [ length: []]]
= [ objl: [ length: 55]
obj2: [ length: 50]]
Example 8 :res-var with :res-disjunct
[ obj: [ length: 1(55 43 42)]
objl: [ length: 2[]]]
</bodyText>
<equation confidence="0.980631051282051">
(EQ &lt;1&gt; &lt;2&gt;)
U [ obj: [ length: 1[]]
objl: [ length: 2[]]]
((LAMBDA (X Y) (EQ (+ X Y) 110)) &lt;1&gt; &lt;2&gt;)
= [ obj: [ length: 1(55 43 42)]
objl: [ length: 2[]]]
((LAMBDA (X Y) (EQ (+ X Y) 110)) &lt;1&gt; &lt;2&gt;)
(EQ &lt;1&gt; &lt;2&gt;)
U [ objl: [ length: 55]]
= [ obj: [ length: 55]
objl: [ length: 55]]
Example 9 :appl with :appl
[ obj: [ length: (+ 5 1[])]
obj2: [ length: &lt;1&gt;]]
U [ obj: [ length:
((LAMBDA (X) (- (+ X 10) 5)) 10)]
obj2: [ length: &lt;1&gt;]]
= [ obj: [ length: 1(+ 5 2[])]
obj2: [ length: &lt;2&gt;]]
(Unify &lt;1&gt;
((LAMBDA (X) (- (+ X 10) 5)) &lt;2&gt;))
U [ obj2: [ length: 55]]
= [ obj: [ length: 1(+ 5 55)]
obj2: [ length: 55]]
(Unify &lt;1&gt; ((LAMBDA (X) (- (+ X 10) 5)) 55))
U [ obj: [ length: [1]]
= [ obj: [ length: 60]
obj2: [ length: 55]]
Example 10 :res-disjunct with res-disjunct
[ objl: [ length: 1(55 43 42)]
obj2: [ length: 2[]]]
(EQ &lt;1&gt; &lt;2&gt;)
U [ objl: [ length: 1(45 55 43)]
obj2: [ length: 2[]]]
((LAMBDA (X Y) (EQ (+ X Y) 110)) &lt;1&gt; &lt;2&gt;)
= [ objl: [ length: 1(55 43)]
obj2: [ length: 2[]]]
(EQ &lt;1&gt; &lt;2&gt;)
((LAMBDA (X Y) (EQ (+ X Y) 110)) &lt;1&gt; &lt;2&gt;)
</equation>
<bodyText confidence="0.554308333333333">
U [ obj2: [ length: 55]]
= [ objl: [ length: 55]
obj2: [ length: 55]]
</bodyText>
<page confidence="0.998367">
223
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.800715">
<title confidence="0.9983155">F-PATR: FUNCTIONAL CONSTRAINTS FOR UNIFICATION-BASED GRAMMARS</title>
<author confidence="0.998434">Kent Wittenburg</author>
<affiliation confidence="0.824818">Bellcore</affiliation>
<address confidence="0.9994515">445 South St., MIRE 2A-347 Morristown, NJ 07962-1910, USA</address>
<email confidence="0.995612">Internet:kentw@bellcore.com</email>
<abstract confidence="0.998862684210526">Motivation for including relational constraints other than equality within grammatical formalisms has come from discontinuous constituency and partially free word order for natural languages as well as from the need to define combinatory operations at the most basic level for languages with a two-dimensional syntax (e.g., mathematical notation, chemical equations, and various diagramming languages). This paper presents F-PATR, a generalization of the PATR-II unification-based formalism, which incorporates relational constraints expressed as user-defined functions. An operational semantics is given for unification that is an adaptation and extension of the approach taken by Ait-Kaci and Nasr (1989). It is designed particularly for unificationbased formalisms implemented in functional programming environments such as Lisp. The application of unification in a chart parser for relational set languages is discussed briefly.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>H Ait-Kaci</author>
</authors>
<title>An Overview of LIFE.</title>
<date>1991</date>
<booktitle>Next Generation Information System Technology, Proceedings of the 1st International East/West Data Base Workshop, Lecture Notes in Computer Science 504,</booktitle>
<pages>42--58</pages>
<editor>In J.W. Schmidt and A.A. Stogny (eds.),</editor>
<publisher>Springer Verlag,</publisher>
<marker>Ait-Kaci, 1991</marker>
<rawString>Ait-Kaci, H. (1991) An Overview of LIFE. In J.W. Schmidt and A.A. Stogny (eds.), Next Generation Information System Technology, Proceedings of the 1st International East/West Data Base Workshop, Lecture Notes in Computer Science 504, Springer Verlag, pp. 42-58.</rawString>
</citation>
<citation valid="true">
<authors>
<author>H Ait-Kaci</author>
<author>R Nasr</author>
</authors>
<date>1989</date>
<booktitle>Integrating Logic and Functional Programming. Lisp and Symbolic Computation</booktitle>
<pages>2--51</pages>
<contexts>
<context position="889" citStr="Ait-Kaci and Nasr (1989)" startWordPosition="113" endWordPosition="116">ical formalisms has come from discontinuous constituency and partially free word order for natural languages as well as from the need to define combinatory operations at the most basic level for languages with a two-dimensional syntax (e.g., mathematical notation, chemical equations, and various diagramming languages). This paper presents F-PATR, a generalization of the PATR-II unification-based formalism, which incorporates relational constraints expressed as user-defined functions. An operational semantics is given for unification that is an adaptation and extension of the approach taken by Ait-Kaci and Nasr (1989). It is designed particularly for unificationbased formalisms implemented in functional programming environments such as Lisp. The application of unification in a chart parser for relational set languages is discussed briefly. 1. INTRODUCTION For the most part, unification-based grammar formalisms (e.g., Kaplan and Bresnan 1982; Pereira and Warren 1980; Shieber 1984) have adopted string rewriting conventions from context-free grammar rules, assuming string concatenation as the basic combining operator external to the unification process itself. Kay&apos;s Functional Unification Grammar (Kay 1979), </context>
<context position="4342" citStr="Ait-Kaci and Nasr (1989)" startWordPosition="616" endWordPosition="619">nts a generalization of the PATR-II unification-based grammar formalism to incorporate relational constraints. The extension has been primarily motivated by the demands of combinatory operations in the syntax for two-dimensional languages although such constraints can be used to express more complex combinatory relations on strings as well as for other purposes (see, for example, work in CLG (Damas and Varile 1989; Balari et al. 1990)). The approach described here arose as a result of extending a Lisp-based implementation of PATR-II used with a chart parser. A natural path was provided by 216 Ait-Kaci and Nasr (1989), who proposed integrating logic and functional programming by allowing constraints to be specified with applicative expressions. This work has subsequently become one of the three cornerstones of the programming language Life (AitKaci 1990). The key idea is to allow interpreted functional expressions to appear as bona fide arguments in logical statements. Unification operations then must allow for delaying the evaluation of functional expressions until such time as argument variables become grounded, a process that leads to what Ait-Kaci and Nasr call residuation. For the most part, the adapt</context>
<context position="5873" citStr="Ait-Kaci and Nasr (1989)" startWordPosition="855" endWordPosition="858">caching intermediate results imposed by chart parsing. The second, atomic disjunction, allows for more expressiveness in the grammar and also, again, was motivated by the parsing algorithm we assumed. We will return to these points in Section 6. 2. FUNCTIONAL CONSTRAINTS From the graph perspective, the basic vocabulary of PATR-II (Shieber 1984) consists of a set of arc labels and a set of terminal (leaf) node labels, the latter including a variable (or null) value. The graphs can have reentrancies at the leaf levels or higher up, which express identity (or unification) of structure. Following Ait-Kaci and Nasr (1989), we incorporate applicative expressions (function specification followed by zero or more argument specifications), into our constraint language. Two uses of applicative expressions in the Ait-Kaci/Nasr language Le Fun concern us here. The first allows variables to equate to an (eventual) evaluation of some applicative expression whose arguments may contain variables. For example, X = (union Y Z) (Our convention will be to write applicative expressions using Lisp s-expression syntax, i.e, function name followed by zero or more arguments all enclosed in parentheses.) The second allows Le Fun cl</context>
<context position="10393" citStr="Ait-Kaci and Nasr (1989)" startWordPosition="1583" endWordPosition="1586"> notation with atomic disjunction (interpreted as exclusive OR) as a possible value of leaf nodes. Such values are written with curly braces surrounding two or more atoms. Atomic disjunction is one of the most basic extensions to the PATR-I1 unification language and is in common use. If atomic values are considered to be singleton sets, unification of atomic disjunctions with other disjunctions or atoms can be operationally treated as set intersection. In F-PATR, atomic disjunctions may appear not only independently but also as arguments and values of applicative expressions. 3. DATA TYPES In Ait-Kaci and Nasr (1989), functional expressions in feature structures are evaluated as soon as their arguments become bound. Otherwise, data structures will become residuated, a state representing incompletion with respect to determining constraints on unification. Ait-Kaci and Nases algorithms thus delay the resolution of functionally-specified values or predicates until all variables are bound, but then resolve them as early as possible once bindings occur. Here we follow this same general approach for predicates only, but not for applicative values, which are checked for readiness to evaluate only when dereferenc</context>
</contexts>
<marker>Ait-Kaci, Nasr, 1989</marker>
<rawString>Ait-Kaci, H., and R. Nasr (1989) Integrating Logic and Functional Programming. Lisp and Symbolic Computation 2:51-89.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S Balari</author>
<author>L Damas</author>
<author>G B Varile</author>
</authors>
<title>CLG: Constraint Logic Grammars,</title>
<date>1989</date>
<booktitle>Proceedings of the 13th International Conference on Computational Linguistics, Helsinki,</booktitle>
<volume>3</volume>
<pages>7--12</pages>
<marker>Balari, Damas, Varile, 1989</marker>
<rawString>Balari, S., L. Damas, and G. B. Varile (1989) CLG: Constraint Logic Grammars, Proceedings of the 13th International Conference on Computational Linguistics, Helsinki, vol. 3, pp. 7-12.</rawString>
</citation>
<citation valid="true">
<authors>
<author>B Carpenter</author>
<author>C Pollard</author>
<author>A Franz</author>
</authors>
<title>The Specification and Implementation of Constraint-Based Unification Grammars.</title>
<date>1991</date>
<booktitle>In Proceedings IWPT 91, Second International Workshop on Parsing Technologies,</booktitle>
<pages>143--153</pages>
<contexts>
<context position="1719" citStr="Carpenter et al. 1991" startWordPosition="230" endWordPosition="233">discussed briefly. 1. INTRODUCTION For the most part, unification-based grammar formalisms (e.g., Kaplan and Bresnan 1982; Pereira and Warren 1980; Shieber 1984) have adopted string rewriting conventions from context-free grammar rules, assuming string concatenation as the basic combining operator external to the unification process itself. Kay&apos;s Functional Unification Grammar (Kay 1979), while not borrowing the conventions of CFG rewriting rules, still assumed concatenation of strings as the underlying combining operation. However, recent work in HPSG (e.g., Pollard and Sag 1987, Reape 1990, Carpenter et al. 1991) and elsewhere has sought to incorporate constraints for combining operations into the unificationbased representation directly. Part of the motivation for doing so is to accommodate partially free word order and discontinuous constituency without the complication of passing along intermediate &amp;quot;threading&amp;quot; information within derivations. Such exensions to unification grammars require the use of nonequational constraints, i.e., constraints on values other than simple conditions of equality and the logical connectives built with them. Reape (1990) has proposed, for example, the relations permutat</context>
</contexts>
<marker>Carpenter, Pollard, Franz, 1991</marker>
<rawString>Carpenter, B., C. Pollard, and A. Franz (1991) The Specification and Implementation of Constraint-Based Unification Grammars. In Proceedings IWPT 91, Second International Workshop on Parsing Technologies, pp. 143-153.</rawString>
</citation>
<citation valid="true">
<authors>
<author>L Damas</author>
<author>G Varile</author>
</authors>
<title>CLG: A Grammar Formalism based on Constraint Resolution.</title>
<date>1989</date>
<booktitle>EPIA &apos;89, Lecture Notes in Artificial Intelligence 390,</booktitle>
<editor>In E.M. Morgado and J.P. Martins (eds.),</editor>
<publisher>Springer Verlag.</publisher>
<contexts>
<context position="4135" citStr="Damas and Varile 1989" startWordPosition="581" endWordPosition="584">ocabulary, whose members may themselves be complex objects. The use of sets in these grammars takes the place of strings, or sequences of words, as used in grammars for natural languages. This paper presents a generalization of the PATR-II unification-based grammar formalism to incorporate relational constraints. The extension has been primarily motivated by the demands of combinatory operations in the syntax for two-dimensional languages although such constraints can be used to express more complex combinatory relations on strings as well as for other purposes (see, for example, work in CLG (Damas and Varile 1989; Balari et al. 1990)). The approach described here arose as a result of extending a Lisp-based implementation of PATR-II used with a chart parser. A natural path was provided by 216 Ait-Kaci and Nasr (1989), who proposed integrating logic and functional programming by allowing constraints to be specified with applicative expressions. This work has subsequently become one of the three cornerstones of the programming language Life (AitKaci 1990). The key idea is to allow interpreted functional expressions to appear as bona fide arguments in logical statements. Unification operations then must a</context>
</contexts>
<marker>Damas, Varile, 1989</marker>
<rawString>Damas, L. and G. Varile (1989) CLG: A Grammar Formalism based on Constraint Resolution. In E.M. Morgado and J.P. Martins (eds.), EPIA &apos;89, Lecture Notes in Artificial Intelligence 390, Springer Verlag.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Helm</author>
<author>K Marriott</author>
</authors>
<title>Declarative Graphics.</title>
<date>1986</date>
<booktitle>In Proceedings of the Third International Conference on Logic Programming, Lecture Notes in Computer Science 225,</booktitle>
<pages>513--527</pages>
<publisher>Springer-Verlag.</publisher>
<marker>Helm, Marriott, 1986</marker>
<rawString>Helm, R., and K. Marriott (1986) Declarative Graphics. In Proceedings of the Third International Conference on Logic Programming, Lecture Notes in Computer Science 225, pp. 513-527. Springer-Verlag.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Helm</author>
<author>K Marriott</author>
</authors>
<title>Declarative Specification of Visual Languages. In</title>
<date>1990</date>
<booktitle>IEEE Workshop on Visual Languages</booktitle>
<pages>98--103</pages>
<location>(Skokie, Illinois),</location>
<marker>Helm, Marriott, 1990</marker>
<rawString>Helm, R., and K. Marriott (1990) Declarative Specification of Visual Languages. In 1990 IEEE Workshop on Visual Languages (Skokie, Illinois), pp. 98-103.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Kaplan</author>
<author>J Bresnan</author>
</authors>
<title>Lexical-Functional Grammar: A Formal System for Grammatical Representation.</title>
<date>1982</date>
<booktitle>The Mental Representation of Grammatical Relations,</booktitle>
<pages>173--281</pages>
<editor>In J. Bresnan (ed.),</editor>
<publisher>MIT Press,</publisher>
<contexts>
<context position="1218" citStr="Kaplan and Bresnan 1982" startWordPosition="160" endWordPosition="163">r presents F-PATR, a generalization of the PATR-II unification-based formalism, which incorporates relational constraints expressed as user-defined functions. An operational semantics is given for unification that is an adaptation and extension of the approach taken by Ait-Kaci and Nasr (1989). It is designed particularly for unificationbased formalisms implemented in functional programming environments such as Lisp. The application of unification in a chart parser for relational set languages is discussed briefly. 1. INTRODUCTION For the most part, unification-based grammar formalisms (e.g., Kaplan and Bresnan 1982; Pereira and Warren 1980; Shieber 1984) have adopted string rewriting conventions from context-free grammar rules, assuming string concatenation as the basic combining operator external to the unification process itself. Kay&apos;s Functional Unification Grammar (Kay 1979), while not borrowing the conventions of CFG rewriting rules, still assumed concatenation of strings as the underlying combining operation. However, recent work in HPSG (e.g., Pollard and Sag 1987, Reape 1990, Carpenter et al. 1991) and elsewhere has sought to incorporate constraints for combining operations into the unificationb</context>
</contexts>
<marker>Kaplan, Bresnan, 1982</marker>
<rawString>Kaplan, R., and J. Bresnan (1982) Lexical-Functional Grammar: A Formal System for Grammatical Representation. In J. Bresnan (ed.), The Mental Representation of Grammatical Relations, MIT Press, pp. 173-281.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Kay</author>
</authors>
<title>Functional Grammar.</title>
<date>1979</date>
<booktitle>In Proceedings of the Fifth Annual Meeting of the Berkeley Linguistic Society.</booktitle>
<contexts>
<context position="1487" citStr="Kay 1979" startWordPosition="197" endWordPosition="198">Nasr (1989). It is designed particularly for unificationbased formalisms implemented in functional programming environments such as Lisp. The application of unification in a chart parser for relational set languages is discussed briefly. 1. INTRODUCTION For the most part, unification-based grammar formalisms (e.g., Kaplan and Bresnan 1982; Pereira and Warren 1980; Shieber 1984) have adopted string rewriting conventions from context-free grammar rules, assuming string concatenation as the basic combining operator external to the unification process itself. Kay&apos;s Functional Unification Grammar (Kay 1979), while not borrowing the conventions of CFG rewriting rules, still assumed concatenation of strings as the underlying combining operation. However, recent work in HPSG (e.g., Pollard and Sag 1987, Reape 1990, Carpenter et al. 1991) and elsewhere has sought to incorporate constraints for combining operations into the unificationbased representation directly. Part of the motivation for doing so is to accommodate partially free word order and discontinuous constituency without the complication of passing along intermediate &amp;quot;threading&amp;quot; information within derivations. Such exensions to unification</context>
</contexts>
<marker>Kay, 1979</marker>
<rawString>Kay, M. (1979) Functional Grammar. In Proceedings of the Fifth Annual Meeting of the Berkeley Linguistic Society.</rawString>
</citation>
<citation valid="true">
<authors>
<author>F C N Pereira</author>
<author>D Warren</author>
</authors>
<title>Definite Clause Grammars for Language Analysis--A Survey of the Formalism and a Comparison with Augmented Transition Networks.</title>
<date>1980</date>
<journal>Artificial Intelligence</journal>
<pages>13--231</pages>
<contexts>
<context position="1243" citStr="Pereira and Warren 1980" startWordPosition="164" endWordPosition="167">ralization of the PATR-II unification-based formalism, which incorporates relational constraints expressed as user-defined functions. An operational semantics is given for unification that is an adaptation and extension of the approach taken by Ait-Kaci and Nasr (1989). It is designed particularly for unificationbased formalisms implemented in functional programming environments such as Lisp. The application of unification in a chart parser for relational set languages is discussed briefly. 1. INTRODUCTION For the most part, unification-based grammar formalisms (e.g., Kaplan and Bresnan 1982; Pereira and Warren 1980; Shieber 1984) have adopted string rewriting conventions from context-free grammar rules, assuming string concatenation as the basic combining operator external to the unification process itself. Kay&apos;s Functional Unification Grammar (Kay 1979), while not borrowing the conventions of CFG rewriting rules, still assumed concatenation of strings as the underlying combining operation. However, recent work in HPSG (e.g., Pollard and Sag 1987, Reape 1990, Carpenter et al. 1991) and elsewhere has sought to incorporate constraints for combining operations into the unificationbased representation direc</context>
</contexts>
<marker>Pereira, Warren, 1980</marker>
<rawString>Pereira, F.C.N., and D. Warren (1980) Definite Clause Grammars for Language Analysis--A Survey of the Formalism and a Comparison with Augmented Transition Networks. Artificial Intelligence 13:231-278.</rawString>
</citation>
<citation valid="true">
<authors>
<author>C Pollard</author>
<author>I Sag</author>
</authors>
<title>Information-based Syntax and Semantics: Volume 1. Center for the Study of Language and Information.</title>
<date>1987</date>
<contexts>
<context position="1683" citStr="Pollard and Sag 1987" startWordPosition="224" endWordPosition="227">r for relational set languages is discussed briefly. 1. INTRODUCTION For the most part, unification-based grammar formalisms (e.g., Kaplan and Bresnan 1982; Pereira and Warren 1980; Shieber 1984) have adopted string rewriting conventions from context-free grammar rules, assuming string concatenation as the basic combining operator external to the unification process itself. Kay&apos;s Functional Unification Grammar (Kay 1979), while not borrowing the conventions of CFG rewriting rules, still assumed concatenation of strings as the underlying combining operation. However, recent work in HPSG (e.g., Pollard and Sag 1987, Reape 1990, Carpenter et al. 1991) and elsewhere has sought to incorporate constraints for combining operations into the unificationbased representation directly. Part of the motivation for doing so is to accommodate partially free word order and discontinuous constituency without the complication of passing along intermediate &amp;quot;threading&amp;quot; information within derivations. Such exensions to unification grammars require the use of nonequational constraints, i.e., constraints on values other than simple conditions of equality and the logical connectives built with them. Reape (1990) has proposed,</context>
</contexts>
<marker>Pollard, Sag, 1987</marker>
<rawString>Pollard, C., and I. Sag (1987) Information-based Syntax and Semantics: Volume 1. Center for the Study of Language and Information.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Reape</author>
</authors>
<title>Getting Things in Order.</title>
<date>1990</date>
<booktitle>In Proceedings of the Symposium on Discontinuous Constituency, Institute for Language Technology and Artificial Intelligence,</booktitle>
<pages>125--137</pages>
<location>Tilburg University, The</location>
<contexts>
<context position="1695" citStr="Reape 1990" startWordPosition="228" endWordPosition="229">anguages is discussed briefly. 1. INTRODUCTION For the most part, unification-based grammar formalisms (e.g., Kaplan and Bresnan 1982; Pereira and Warren 1980; Shieber 1984) have adopted string rewriting conventions from context-free grammar rules, assuming string concatenation as the basic combining operator external to the unification process itself. Kay&apos;s Functional Unification Grammar (Kay 1979), while not borrowing the conventions of CFG rewriting rules, still assumed concatenation of strings as the underlying combining operation. However, recent work in HPSG (e.g., Pollard and Sag 1987, Reape 1990, Carpenter et al. 1991) and elsewhere has sought to incorporate constraints for combining operations into the unificationbased representation directly. Part of the motivation for doing so is to accommodate partially free word order and discontinuous constituency without the complication of passing along intermediate &amp;quot;threading&amp;quot; information within derivations. Such exensions to unification grammars require the use of nonequational constraints, i.e., constraints on values other than simple conditions of equality and the logical connectives built with them. Reape (1990) has proposed, for example</context>
</contexts>
<marker>Reape, 1990</marker>
<rawString>Reape, M. (1990) Getting Things in Order. In Proceedings of the Symposium on Discontinuous Constituency, Institute for Language Technology and Artificial Intelligence, Tilburg University, The Netherlands, pp. 125-137.</rawString>
</citation>
<citation valid="true">
<authors>
<author>H Tomabechi</author>
</authors>
<title>Quasi-Destructive Graph Unification.</title>
<date>1991</date>
<booktitle>In Proceedings IVVPT 91, Second International Workshop on Parsing Technologies,</booktitle>
<pages>164--171</pages>
<contexts>
<context position="24619" citStr="Tomabechi (1991)" startWordPosition="3850" endWordPosition="3851"> may be relevant as a source of ideas for efficiency. Constraints expressed as relations in frameworks such as Zajac (1992) could instead be expressed in F-PATR as compiled functions, leading perhaps to improved runtime speeds. The MCC/Bellcore implementation of F-PATR includes both destructive and nondestructive versions of unification. The destructive version is, as expected, more straightforward to implement but more expensive computationally given that over copying and early copying are profligate (see Wroblewski 1987). The algorithms for nondestructive unification have been influenced by Tomabechi (1991), but applicative expressions and residuations change the landscape significantly. There tends to be extensive circularity in the data structures: residuated argument nodes point to predicates that in turn point back to their arguments; residuations in applicative-valued nodes point to unification forms that in turn point back to the applicative nodes. There is a need for future work to address issues of space and time efficiency for extensions represented by F-PATR just as there has been such a need for other PATR-II extensions. A line of research that the author is pursuing currently (Witten</context>
</contexts>
<marker>Tomabechi, 1991</marker>
<rawString>Tomabechi, H. (1991) Quasi-Destructive Graph Unification. In Proceedings IVVPT 91, Second International Workshop on Parsing Technologies, pp. 164-171.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Tomita</author>
</authors>
<title>The Generalized LR Parser/Compiler V8-4: A Software Package for Practical NL Projects. In:</title>
<date>1990</date>
<booktitle>COLING-90,</booktitle>
<volume>1</volume>
<pages>59--63</pages>
<contexts>
<context position="25404" citStr="Tomita 1990" startWordPosition="3973" endWordPosition="3974">point to predicates that in turn point back to their arguments; residuations in applicative-valued nodes point to unification forms that in turn point back to the applicative nodes. There is a need for future work to address issues of space and time efficiency for extensions represented by F-PATR just as there has been such a need for other PATR-II extensions. A line of research that the author is pursuing currently (Wittenburg 1992b) is to design a more specialized grammar formalism that finesses some of the complexity of residuation and unification through a version of &amp;quot;pseudo-unification&amp;quot; (Tomita 1990). In contrast to residuation, which manages function evaluation at runtime, the idea is to manage the order of evaluation for functional constraints at compile time. In grammar formalisms and parsers under investigation, it is possible for a compiler to order constraints within rule data structures such that evaluation readiness is a deterministic matter, circumventing the need for runtime checks and extra data structures required for delaying evaluation dynamically. ACKNOWLEDGEMENTS This research was carried out at MCC under the sponsorship of Bellcore and MCC. Louis Weitzman and Jim Talley w</context>
</contexts>
<marker>Tomita, 1990</marker>
<rawString>Tomita, M. (1990) The Generalized LR Parser/Compiler V8-4: A Software Package for Practical NL Projects. In: COLING-90, Volume 1, 59-63.</rawString>
</citation>
<citation valid="true">
<authors>
<author>K Wittenburg</author>
</authors>
<title>Earley-style Parsing for Relational Gramars. In</title>
<date>1992</date>
<booktitle>Proceedings of IEEE Workshop on Visual Languages,</booktitle>
<pages>192--199</pages>
<location>Seattle, Washington,</location>
<contexts>
<context position="17708" citStr="Wittenburg (1992" startWordPosition="2764" endWordPosition="2765">h led to difficulties in our chart parsing algorithm, which needed to cache the feature structures of active edges before any of the destructive effects of unification involving what we call expander functions took place. The root of the issue is that with the AitKaci/Nasr approach, the control of function evaluation is within unification rather than with some external algorithm. In our approach, it was most natural to use external control to implement chart parsing. This point may be clarified by considering an example, for which we need to summarize F-PATR relational set grammars. (See also Wittenburg (1992a 1992b).) The feature structures for grammatical constituents include the primary attributes cover, syntax, and semantics. The attribute cover takes as value a reference to a subset of input objects. This scheme is analogous to HPSG feature structures, where the stringvalued phonology attribute is replaced by the set-valued cover attribute. Rules have the form [mother: [cover: [] syntax: [1 semantics: 0] daughti : [cover: [] syntax: [] semantics: []] . . . daughtn: [cover: [] syntax: [] semantics: [1]] with the condition that for the daughter elements of a rule 131...130, there must exist at </context>
<context position="25228" citStr="Wittenburg 1992" startWordPosition="3947" endWordPosition="3948">(1991), but applicative expressions and residuations change the landscape significantly. There tends to be extensive circularity in the data structures: residuated argument nodes point to predicates that in turn point back to their arguments; residuations in applicative-valued nodes point to unification forms that in turn point back to the applicative nodes. There is a need for future work to address issues of space and time efficiency for extensions represented by F-PATR just as there has been such a need for other PATR-II extensions. A line of research that the author is pursuing currently (Wittenburg 1992b) is to design a more specialized grammar formalism that finesses some of the complexity of residuation and unification through a version of &amp;quot;pseudo-unification&amp;quot; (Tomita 1990). In contrast to residuation, which manages function evaluation at runtime, the idea is to manage the order of evaluation for functional constraints at compile time. In grammar formalisms and parsers under investigation, it is possible for a compiler to order constraints within rule data structures such that evaluation readiness is a deterministic matter, circumventing the need for runtime checks and extra data structure</context>
</contexts>
<marker>Wittenburg, 1992</marker>
<rawString>Wittenburg, K. (1992a) Earley-style Parsing for Relational Gramars. In Proceedings of IEEE Workshop on Visual Languages, Sept. 15-18, 1992, Seattle, Washington, pp. 192-199.</rawString>
</citation>
<citation valid="true">
<authors>
<author>K Wittenburg</author>
</authors>
<title>The Relational Language System, Bellcore</title>
<date>1992</date>
<tech>Technical Memorandum TM-ARH-022353.</tech>
<contexts>
<context position="17708" citStr="Wittenburg (1992" startWordPosition="2764" endWordPosition="2765">h led to difficulties in our chart parsing algorithm, which needed to cache the feature structures of active edges before any of the destructive effects of unification involving what we call expander functions took place. The root of the issue is that with the AitKaci/Nasr approach, the control of function evaluation is within unification rather than with some external algorithm. In our approach, it was most natural to use external control to implement chart parsing. This point may be clarified by considering an example, for which we need to summarize F-PATR relational set grammars. (See also Wittenburg (1992a 1992b).) The feature structures for grammatical constituents include the primary attributes cover, syntax, and semantics. The attribute cover takes as value a reference to a subset of input objects. This scheme is analogous to HPSG feature structures, where the stringvalued phonology attribute is replaced by the set-valued cover attribute. Rules have the form [mother: [cover: [] syntax: [1 semantics: 0] daughti : [cover: [] syntax: [] semantics: []] . . . daughtn: [cover: [] syntax: [] semantics: [1]] with the condition that for the daughter elements of a rule 131...130, there must exist at </context>
<context position="25228" citStr="Wittenburg 1992" startWordPosition="3947" endWordPosition="3948">(1991), but applicative expressions and residuations change the landscape significantly. There tends to be extensive circularity in the data structures: residuated argument nodes point to predicates that in turn point back to their arguments; residuations in applicative-valued nodes point to unification forms that in turn point back to the applicative nodes. There is a need for future work to address issues of space and time efficiency for extensions represented by F-PATR just as there has been such a need for other PATR-II extensions. A line of research that the author is pursuing currently (Wittenburg 1992b) is to design a more specialized grammar formalism that finesses some of the complexity of residuation and unification through a version of &amp;quot;pseudo-unification&amp;quot; (Tomita 1990). In contrast to residuation, which manages function evaluation at runtime, the idea is to manage the order of evaluation for functional constraints at compile time. In grammar formalisms and parsers under investigation, it is possible for a compiler to order constraints within rule data structures such that evaluation readiness is a deterministic matter, circumventing the need for runtime checks and extra data structure</context>
</contexts>
<marker>Wittenburg, 1992</marker>
<rawString>Wittenburg, K. (1992b) The Relational Language System, Bellcore Technical Memorandum TM-ARH-022353.</rawString>
</citation>
<citation valid="true">
<authors>
<author>K Wittenburg</author>
<author>L Weitzman</author>
<author>J Talley</author>
</authors>
<title>Unification-Based Grammars and Tabular Parsing for Graphical Languages.</title>
<date>1991</date>
<journal>Journal of Visual Languages and Computing</journal>
<pages>2--347</pages>
<marker>Wittenburg, Weitzman, Talley, 1991</marker>
<rawString>Wittenburg, K., L. Weitzman, and J. Talley (1991) Unification-Based Grammars and Tabular Parsing for Graphical Languages. Journal of Visual Languages and Computing 2:347-370.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D Wroblewski</author>
</authors>
<title>Nondestructive Graph Unification.</title>
<date>1987</date>
<booktitle>In Proceedings of AAAI 87,</booktitle>
<pages>582--587</pages>
<contexts>
<context position="24531" citStr="Wroblewski 1987" startWordPosition="3839" endWordPosition="3840">t it may be of interest. From the logic grammar point of view, the work reported on here may be relevant as a source of ideas for efficiency. Constraints expressed as relations in frameworks such as Zajac (1992) could instead be expressed in F-PATR as compiled functions, leading perhaps to improved runtime speeds. The MCC/Bellcore implementation of F-PATR includes both destructive and nondestructive versions of unification. The destructive version is, as expected, more straightforward to implement but more expensive computationally given that over copying and early copying are profligate (see Wroblewski 1987). The algorithms for nondestructive unification have been influenced by Tomabechi (1991), but applicative expressions and residuations change the landscape significantly. There tends to be extensive circularity in the data structures: residuated argument nodes point to predicates that in turn point back to their arguments; residuations in applicative-valued nodes point to unification forms that in turn point back to the applicative nodes. There is a need for future work to address issues of space and time efficiency for extensions represented by F-PATR just as there has been such a need for ot</context>
</contexts>
<marker>Wroblewski, 1987</marker>
<rawString>Wroblewski, D. (1987) Nondestructive Graph Unification. In Proceedings of AAAI 87, pp. 582-587.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Zajac</author>
</authors>
<title>Inheritance and Constraint-Based Grammar Formalisms.</title>
<date>1992</date>
<journal>Computational Linguistics</journal>
<pages>18--159</pages>
<contexts>
<context position="24126" citStr="Zajac (1992)" startWordPosition="3784" endWordPosition="3785">ver, to the expressive power of F-PATR as it stands. It cannot directly support some of the constraints envisioned in current HPSG literature, for example, because of F-PATR&apos;s restrictions on arguments to functional constraints. In HPSG, relations constrain not just atomic values but also general feature structures incuding lists and sets. Such an extension to F-PATR is not planned by the author but it may be of interest. From the logic grammar point of view, the work reported on here may be relevant as a source of ideas for efficiency. Constraints expressed as relations in frameworks such as Zajac (1992) could instead be expressed in F-PATR as compiled functions, leading perhaps to improved runtime speeds. The MCC/Bellcore implementation of F-PATR includes both destructive and nondestructive versions of unification. The destructive version is, as expected, more straightforward to implement but more expensive computationally given that over copying and early copying are profligate (see Wroblewski 1987). The algorithms for nondestructive unification have been influenced by Tomabechi (1991), but applicative expressions and residuations change the landscape significantly. There tends to be extens</context>
</contexts>
<marker>Zajac, 1992</marker>
<rawString>Zajac, R. (1992) Inheritance and Constraint-Based Grammar Formalisms. Computational Linguistics 18:159-182.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>