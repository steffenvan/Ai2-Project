<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<title confidence="0.715379">
Squibs and Discussions
Restriction and Termination in Parsing with
Feature-Theoretic Grammars
</title>
<author confidence="0.998458">
S. P. Harrison* T. M. Ellison*
</author>
<affiliation confidence="0.99175">
University of Western Australia University of Western Australia
</affiliation>
<bodyText confidence="0.991766111111111">
Shieber (1987) describes a technique for limiting the number of active edges introduced into a chart
by top-down prediction in chart parsers for PATR grammars, without affecting the correctness
or completeness of the parser. That technique, termed restriction, is extendable to other parsing
algorithms. It can be employed to increase parsing efficiency and to induce termination for some
classes of grammars that would not otherwise terminate.
Here, we describe one class of grammars for which restriction, as described by Shieber, induces
non-termination. We do not suggest that the concept of restriction is fatally flawed, however. On
the contrary, relatively minor modifications to the implementation of restriction can make it a
more flexible tool for fine-tuning PATR grammars.
</bodyText>
<subsectionHeader confidence="0.780732">
Background
</subsectionHeader>
<bodyText confidence="0.99997405882353">
Shieber (1987) observes that the potentially infinite category domain of feature-theoretic
grammar formalisms like PATR-II makes implementing efficient parsers for such for-
malisms difficult. He concludes that the two earliest approaches to the problem are
at best ill-advised. Parsing with a context-free backbone effectively ignores informa-
tion in fact available to guide the parse and violates the spirit of feature-theoretic
grammar. Tailoring the parsing algorithm or the grammar itself to the exigencies of
feature-theoretic formalisms puts the burden of coping with the problem in the wrong
place, on the end user of a grammar development system.
The most obvious alternative to parsing with a context-free backbone is using
graph unification, rather than atomic symbol identity, to drive the parsing process.
Shieber notes that not only is that approach costly (in using information that in fact can
never affect the outcome of a parse) but, for some grammars, induces non-termination.
The class of grammars Shieber describes might be termed top-down path building gram-
mars, because they are grammars in which the length of a path through the graph
increases as one descends the parse tree.
The particular grammar Shieber uses is one that counts the number of terminal
symbols in the string being parsed:
</bodyText>
<figure confidence="0.8775586">
(G1)
Rule &apos;set end marker&apos;
S T:
(Sf) = (Tf)
(Tf) = a.
</figure>
<footnote confidence="0.676154">
* Centre for Linguistics, University of Western Australia, Perth, Western Australia
</footnote>
<note confidence="0.910665666666667">
© 1992 Association for Computational Linguistics
Computational Linguistics Volume 18, Number 4
Rule &apos;recursive clause&apos; (Ton = (Tiff).
To —&gt; T -4 A.
Rule &apos;base clause&apos; A —* a.
Rule &apos;lexical insertion&apos;
</note>
<bodyText confidence="0.955628">
Cl generates trees like the following:
In the course of a derivation, GI builds a path (Tnf +) from the root of the graph
Tn corresponding to each node Tn in the tree. The &apos;count&apos; is reflected in the length of
the path (Ttif +). As one descends the tree, the length of the path that is the value of
the attribute f increases by 1 for each successive node Tn+i:
Hence the term top-down path building, characterizing grammars like CI. Recall that, in
a chart parsing regime, for each active edge En, of the form:
</bodyText>
<equation confidence="0.715872333333333">
(i, j, X .Y 13)
and each rule R, of the form:
Y &apos;y
</equation>
<bodyText confidence="0.777035">
the top-down rule adds an active edge En of the form:
</bodyText>
<page confidence="0.992062">
520
</page>
<note confidence="0.978083">
S. P. Harrison and T. M. Ellison Restriction and Termination in Parsing
</note>
<bodyText confidence="0.999277964285714">
If, associated with Em, there is a graph Gm, and with Ri a graph G1, then associated
with En will be a graph Gn = G, U Gm (Y), where Gm (Y) is the subgraph of Gm at Y. As
Shieber points out, a parser employing this top-down rule will not terminate when
interpreting grammar Cl. On initialization (with Rule &apos;set end marker&apos;), the parser
generates an active edge seeking a constituent of category T. The top-down rule then
uses that edge and the Rule &apos;recursive clause&apos; to generate a new active edge seeking
a constituent of category T. That active edge then generates a new (and, crucially, a
distinct) active edge not subsumed by any existing edge, &amp;quot;and so forth, ad infinitum.&amp;quot;
In other words, each top-down recursion anticipates a different terminal string that is
one symbol longer than that predicted on the previous recursion; because the graphs
associated with those anticipated strings are distinct, the normal chart parsing checks
fail to prevent looping.
Shieber&apos;s solution to the problem posed by grammar G1 is to introduce a notion
he terms restriction. Under restriction, the graph associated with an edge generated by
the top-down rule (applied to an active edge Em and a grammar rule Ri) is not a graph
G = G, U Gm (X), where G, is the graph associated with R, and Gm (X)is that portion
of the graph (associated with Em) corresponding to the left hand side of R1. Rather,
G = G, U (Gm(X)!), where Gni(X)!4)) is a graph G&apos; resulting from filtering out of Gm
all those paths not explicitly sanctioned by I. The filter t■ is termed a restrictor, and
is represented as a set of paths P. The graph G&apos; (=-- G!.1)) is derived from G by filtering
out all those paths that are not members of P.1
Given a restrictor that passes through only the (cat) path, the termination problem
for grammar Cl vanishes. Since the active edges generated by the top-down rule
pass on only their category information, each time the rule &apos;recursive clause&apos; is called
recursively, the edge it generates is the same (underspecified) edge generated on the
first call to that rule, and already on the chart.
The following observations regarding the restrictors Shieber describes might be
made at this point:
</bodyText>
<listItem confidence="0.973472166666666">
1. The graph for the active edge generated by the top-down rule with a
parser using restriction is no less specific (has no less information) than
the graph stipulated by the rule used; i.e., it is information from the extant
active edge that is suppressed.
2. The restrictor provides a positive restriction, i.e., it stipulates which paths
are included in the restricted graph, not which paths are suppressed.
</listItem>
<subsectionHeader confidence="0.87541">
A Problem: Bottom-up Path Building
</subsectionHeader>
<bodyText confidence="0.509311636363636">
The following grammar might be considered almost the inverse of the grammar G1
described by Shieber (1987). It parses strings of length 1, and generates one node T in
1 Shieber&apos;s definition of restriction is as follows:
&amp;quot;Given a relation F between paths and labels, and a dag D, we define D!F to be the most
specific dag (D J D&apos;) such that for every path p either D&apos; (p) is undefined, or D&apos; (p) is
atomic, or for every I E dom(EY (p)), 0,1. That is, every path in the restricted dag is either
undefined, atomic, or specifically allowed by the restrictor.&amp;quot;
That definition might seem to suggest that paths that are instantiated (atom valued) are not filtered out
by the restrictor. His examples demonstrate that that is not the correct interpretation of his definition.
Rather, it would seem that atomic paths (i.e. &apos;leaves&apos;), and not atomic-valued paths, fall through the
filter.
</bodyText>
<page confidence="0.987554">
521
</page>
<figure confidence="0.964138862068965">
Computational Linguistics Volume 18, Number 4
the parse tree for each arc labeled g in the graph corresponding to the item recognized:
(G2)
Rule &apos;copy attribute&apos;
S —&gt; AT:
Rule &apos;recursive clause&apos;
To -- T1:
Rule &apos;base clause&apos;
T --:
Rule &apos;lexical insertion a&apos;
A -4 a:
Rule &apos;lexical insertion b&apos;
A -+ b:
G2 generates exactly two trees:
(Ag) = (Tg).
(Togg) = (Tig).
(Tg) = e.
(Aggg) = e.
(Agg) -= e.
Tree2a. Tree2b.
A0 A
A T
A T
0
I
Ti
b T1
each of which is associated with a distinct graph:
Dag2a. Dag2b.
</figure>
<page confidence="0.973725">
522
</page>
<note confidence="0.853303">
S. P. Harrison and T. M. Ellison Restriction and Termination in Parsing
</note>
<bodyText confidence="0.999862">
For this grammar, the length of the path (Tng+) in each subgraph Tn increases as
one ascends the tree. Hence the term bottom-up path building is used to characterize
grammars of this sort.
Using the same restrictor (i.e. (cat)) employed for CI, a parser interpreting G2 will
not terminate on any grammatical input. As in Gl, only one active edge generated
from the Rule &apos;recursive clause&apos; is put on the chart:
</bodyText>
<equation confidence="0.371419">
E1
r cat : T
</equation>
<table confidence="0.8457424">
g: [g:I11] J
cat: T 1
g:1H J
X0:
:
</table>
<bodyText confidence="0.846354">
The rule &apos;base clause&apos; of G2 generates the passive edge:
</bodyText>
<equation confidence="0.88310825">
E2
[cat :
(1,1,X—&gt; .,[X:
g:
The fundamental rule then applies to E1 and E2 to yield the passive edge:
E3
[[
(1,1, Xo -4 xi.,
</equation>
<bodyText confidence="0.875544">
and then applies to El and E3 to yield:
</bodyText>
<equation confidence="0.799730727272727">
E4
cat: T 1
g: g:111]
cat: T 1
j
cat : T 1
g: gdoi
r cat : T
[ g:111[g:e]
(1, 1, Xo -4 xi., X0:
X1:
</equation>
<bodyText confidence="0.959317">
and so forth, ad infinitum. Ultimately, the fundamental rule will generate a passive
edge with a graph G such that G(g) {G, : r(g)}, for the passive edge:
</bodyText>
<equation confidence="0.981849">
(0,1,S -+
</equation>
<bodyText confidence="0.9620625">
where {G, : T&apos;(g)} is the subgraph corresponding to the constituent T. At that point,
the parser, in effect, will have parsed the input string. Nonetheless, it will continue
to add new passive edges, each with a graph whose (g+) path is one arc longer than
that of the passive edge from which it is generated.
Bottom-up path building grammars are not without interesting linguistic applica-
tions. Consider, for example, the following PATR implementation of the append oper-
ation on lists employed in HPSG (Pollard and Sag 1987; Section 2.2):
(G3)
</bodyText>
<subsectionHeader confidence="0.494854">
Rule &apos;collect lists&apos;
</subsectionHeader>
<bodyText confidence="0.692496">
Top Left Right Append:
</bodyText>
<equation confidence="0.719604">
(Append list1) = (Left list)
(Append list2) = (Right list)
(Top list) -= (Append list).
</equation>
<page confidence="0.966387">
523
</page>
<table confidence="0.863407714285714">
Computational Linguistics Volume 18, Number 4
Rule &apos;base case&apos;
Append —*:
(Append list) =- (Append list2)
(Append listl) = 0.
Rule &apos;recursive clause&apos;
Append() Appendi:
</table>
<equation confidence="0.960715">
(Append° list first) = (Append() listl first)
(Append() list rest) = (Appendi list)
(Append° listl rest) = (Appendi listl)
(Appendi list2) = (Append() list2).
</equation>
<bodyText confidence="0.999707833333333">
Given the rules &apos;base case&apos; and &apos;recursive clause,&apos; one need only introduce a &apos;dummy&apos;
constituent Append (whose only function is to collect the list-valued attributes listl
and list2 in a single list), and appropriate constraints on some list-valued attribute, in
order to simulate the HPSG append in PATR. Unfortunately, because these two rules are
an instance of the bottom-up path building problem, no derivation employing these
rules will terminate.&apos;
</bodyText>
<subsectionHeader confidence="0.504679">
Solutions
</subsectionHeader>
<bodyText confidence="0.999417714285714">
The source of the bottom-up path building problem is the active edge E1 above, whose
(g+) path is of indeterminate length. Because the parser does not know how long that
path should be, it keeps adding to it ad infinitum. Observe, however, that the parser
had the required information (obtained from the (g) attribute of constituent A), but
was induced by the restrictor to throw that information away.
There are at least three solutions to the problem posed by bottom-up path building
grammars under restriction:
</bodyText>
<listItem confidence="0.999623">
1. Impose a finite limit on the path (g+).
2. Convert the grammar to top-down path building.
3. Change the nature and implementation of restriction.
</listItem>
<bodyText confidence="0.827705076923077">
We consider each of these proposals in turn in the following paragraphs.
Solution 1 involves picking an arbitrary upper limit on the length of (g+), and
adding a corresponding path to the restrictor. The parser would then terminate for
any input whose (g+) path length is less than or equal to that of the stipulated
path. For example, a parser interpreting G2 above would terminate with the restrictor
{(cat)(g g g)}. But that is a &amp;quot;Band-Aid&amp;quot; solution at best.
2 The append operation is necessary whenever a grammar demands that two list-valued attributes be
combined; for example, when the SUBCAT of a constituent is defined as the union of the values of
SUBCAT for its daughters, or when the list-valued SKELETON of a syllable is defined as the
SKELETON of the onset followed by the SKELETON of the rhyme. One would, of course, prefer to
have PATR extended to accommodate append, rather than have to simulate the append operation in pure
PATR, but that is not the issue here. The point we are making is simply that one could simulate append
in pure PATR, were it not for the restriction regime of the PATR standard defined in Shieber (1989).
</bodyText>
<page confidence="0.993207">
524
</page>
<note confidence="0.923304">
S. P. Harrison and T. M. Ellison Restriction and Termination in Parsing
</note>
<bodyText confidence="0.902057">
Solution 2 might involve a grammar like G4, a top-down path building grammar
weakly equivalent to G2. G4 does not, however, have the termination problem of G2:
</bodyText>
<figure confidence="0.903140121212121">
(G4)
Rule &apos;base case&apos;
S -+ T:
Rule &apos;recursive clause&apos;
To -+ T1:
Rule &apos;copy path&apos;
T-4211:
Rule &apos;lexical insertion a&apos;
A -4 a:
Rule &apos;lexical insertion b&apos;
A b:
(Tg) = e.
(Tog) = (Tigg).
(Tg) = (Ag).
(Aggg) = e.
(Agg) = e.
(The following are the trees, and corresponding complex feature structures, generated
by G4:
S
I
To
1
T
11
A
lb
525
Computational Linguistics Volume 18, Number 4
Note that the length of the path g+ increases as one descends the tree.) Similarly,
grammar G5 provides a top-down path building solution to the append operation:
(G5)
Rule &apos;collect lists&apos;
Append Left Right:
</figure>
<equation confidence="0.9715816">
(Append residue) = (Append list)
(Append listl) = (Left list)
(Append list2) = (Right list).
Rule &apos;append base case&apos;
Top —&gt; Append:
(Top list) = (Append list)
(Append residue) = (Append list2)
(Append listl) = ( ).
Rule &apos;append recursive clause&apos;
Append° —&gt; Append:
(Append° list) = (Appendi list)
(Append° listl) = (Appendi list1 rest)
(Append° list2) = (Appendi list2)
(Append° residue) = (Appendi residue rest)
(Appendi residue first) = (Appendi listl first).
</equation>
<bodyText confidence="0.997306">
Consider the case of two descendants, Left and Right, of a node Top, where the value
of (Left list) is (a, b), the value of (Right list) is (c, d), and the value of (Top list) is
append ((L list), (R list)). G3 assigns to that construction the parse tree:
</bodyText>
<figure confidence="0.4451875">
Left Right Append()
Appendi
</figure>
<page confidence="0.767553">
Append2
526
</page>
<note confidence="0.867599">
S. P. Harrison and T. M. Ellison Restriction and Termination in Parsing
</note>
<bodyText confidence="0.550085">
and the complex feature structure:
</bodyText>
<figure confidence="0.890352307692308">
Top: [list : [ 1 I] [first : 41 a
: rest : [61 first:
[Left list : 121 [ rest: :
[Right : list : 131 [ first : 11
rest: [ first:d
rest: 0 I
-
Append° :
Appendi :
_ list2 : 131
first :
. rest :
first :
rest :
- first :
. rest :
first :
rest :
list: 11
121
131
151
list]. : 161
4
_
5
4
_
6
7
_
3
7
—
9
-
_
I
list : 3
listl : 9
[
list2 : 3
Append2 :
G5, by contrast, assigns it the parse tree:
Top
I
Append()
1
Appendi
1
Append2
Left Right
527
Computational Linguistics Volume 18, Number 4
first :
rest :
first :
rest :
and the complex feature structure:
Top : [list :
list :
residue:
list1 :
a
I 4 1 [first:
rest :
I first : d
[ rest
first : 6
rest : 5
first : 6
rest : 4
Left: list :
[Right : list :
I 1 1]
1 3 1
Append° :
9
7
1 1
1
2
_ list2 : 3
list : 1
residue :
j5 1 first : 9
4 rest :
first :
rest:
Appendi : list1 : 3
9
7
_ list2 :
list
:
residue:
list1 :
list2 :
3
1
3
7
3
Append2 :
</figure>
<bodyText confidence="0.999854842105263">
As noted above, G3 provides a &apos;dummy&apos; constituent Append that one might want
ultimately to prune, since its only function is to assemble the appended list. By con-
trast, G5 assembles the appended list in successive Append nodes dominating the
constituents Left and Right. One might want to argue that the latter solution is less fe-
licitous than the former because the Append nodes dominate lexical material. In any
event, as Shieber stresses, the grammar writer should not be constrained to choose
between weakly equivalent grammars by the demands of the grammar development
system.
Let us now consider solution 3, modifying the nature and implementation of re-
striction. We choose to term the sort of restriction Shieber describes positive restriction.
In positive restriction, the restrictor tells the parser how much of the information for
which paths to retain (in the graph corresponding to the active edge used by the top-
down rule). If a path is not explicitly mentioned in the restrictor, no information about
that path is retained. An empty restrictor in effect tells the parser to throw away all
the information in the restricted graph.
(An anonymous reviewer for Computational Linguistics points out that grammars
G2 and G3, in contrast to Shieber&apos;s Cl, are not offline parsable [in the sense of Bresnan
and Kaplan 1982:263ff and Johnson 1988:95ffl, and suggests that this failure of offline
parsability is a necessary condition for membership in the class of grammars that are
</bodyText>
<page confidence="0.996096">
528
</page>
<note confidence="0.95425">
S. P. Harrison and T. M. Ellison Restriction and Termination in Parsing
</note>
<bodyText confidence="0.997809">
nonterminating under positive restriction. The constituent structures generated by a
grammar are offline parsable iff:
i. they contain no nonbranching dominance chains in which the same
category [label] appears twice, and
ii. all terminal nodes dominate lexical material
G2 and G3 fail both these conditions, since neither the T node chain of G2 nor the
Append node chain of G3 either branch or dominate lexical material. We make two
observations in this regard. First, while it may indeed be the case that failure of offline
parsability is a necessary condition for non-termination under positive restriction, it is
certainly not a sufficient one, since G4 and G5 both fail condition i. above, and are thus
not offline parsable, but do terminate under positive restriction. Second, though G2
through G5 fail the letter of an offline parsability constraint, they do not fail its spirit.
Offline parsability has been proposed as a constraint on grammars guaranteeing
the decidability of the recognition problem for feature-theoretic grammars of the sort
considered here. For grammars that satisfy offline parsability, it will be the case that
the number of nodes of any parse tree assigned to some string will be a computable
function of the length of the string being parsed. This is not the case for G2 through
G5. What is the case, however, is that the number of nodes in a parse tree generated
by those grammars is a computable function of the graphs associated with the lexical
material covered by the tree. This is because each of these grammars makes crucial
reference either to a list-valued or path-valued attribute of lexical items, where the
length of the list or path is finite and stipulated in the lexicon. The number of iden-
tical nodes in any nonbranching dominance chain generated by these grammars is a
function of the length of a [bounded] list or path.)
Positive restriction can be contrasted with what might be termed negative restric-
tion. Under negative restriction, the restrictor tells the parser what information to
throw away. For stipulated paths, the effects of positive and negative restriction are
the same: a restrictor (ggg) tells the parser to (positively) retain all information up to
and including an atomic value for the path (ggg), or to (negatively) throw away all
information about any nonatomic extension of (ggg). The difference is in the interpre-
tation of paths not explicitly mentioned; under positive restriction these are thrown
away; under negative restriction they are retained.
In formal terms, a restrictor, for Shieber, is a relation between paths and the single
edges that are permitted to extend those paths: If 4) is a restrictor, p a path and 1 some
edge label, then the restrictor permits the path pl iff 01. But Shieber does not use
the full power of this formalism. He considers only what we term positive restrictors.
Mathematically, if P is some finite set of paths, one can define a positive restrictor 4)/1
to be the relation defined by:
iff 3 q E P, p q
where p &lt; q means that p is a (perhaps improper) prefix to the path q. By contrast, the
negative restriction regime proposed here allows paths not explicitly disallowed:
</bodyText>
<equation confidence="0.386419">
0)171 iff (3 r E P, r &lt; p) 3 q E P, p q (1)
</equation>
<bodyText confidence="0.9903835">
In other words, whereas the positive restrictor admits those paths obeying the condi-
tion &amp;quot;is a prefix of a member of the restrictor set,&amp;quot; the negative restrictor only applies
</bodyText>
<page confidence="0.9805">
529
</page>
<note confidence="0.359973">
Computational Linguistics Volume 18, Number 4
</note>
<bodyText confidence="0.976192833333333">
this condition to paths extending members of the restrictor set. Paths not extending
members of the restrictor set are themselves not subject to restriction.
It is an easy matter to show that any positive restrictor p can be defined in terms of
a negative restrictor. If the null path is included in the restrictor set, then the antecedent
of the implication in the definition of .13- (1 above) is always true (except if p = ( )),
and the consequent 3q E P U {( )}, p &lt; q is equivalent to 3q E P. p &lt; q (except when
p = ( )). If p is the null path, then the antecedent is always true and so (1
pu{o}
is equivalent to 04)1;1. For other p, 043p-uf 0 11 = 043it1. So, 4)i,&amp;quot;u{()} = (13/t. Thus, an
implementation using negative restriction can simulate any positive restrictor and,
therefore, can necessarily solve all problems solvable by positive restriction, as well as
those problems, described earlier, where positive restriction fails.
Note that we have limited ourselves, as Shieber has, to finite restrictor sets. This
limitation is not necessary. A more general proposal allows restrictor sets consisting
of all paths expressable by some regular expression. Restrictors can then be imple-
mented as finite state automata. An implementation of this sort would not impose a
large computational burden and would allow much greater flexibility in the choice of
restrictor relations.
We have demonstrated that any restriction definable by a positive restrictor can
also be defined by a negative restrictor. It follows that any parser requiring positive
restriction to guarantee termination will also terminate for the same set of grammars
using negative restriction. But we have also demonstrated that the reverse does not
hold. Therefore, it would seem that negative restriction is superior to positive restric-
tion in the implementation of parsers for feature-theoretic grammars.
</bodyText>
<sectionHeader confidence="0.923355" genericHeader="abstract">
References MIT Press.
</sectionHeader>
<bodyText confidence="0.977553125">
Johnson, M. (1988). &amp;quot;Attribute-value logic Pollard, C., and Sag, I. A. (1987).
and the theory of grammar.&amp;quot; CSLI Lecture &amp;quot;Information-based syntax and
Notes, 16. semantics.&amp;quot; CSLI Lecture Notes, 13(1).
Kaplan, R., and Bresnan, J. (1982). Shieber, S. M. (1987). &amp;quot;Using restriction to
&amp;quot;Lexical-functional grammar, a formal extend parsing algorithms for
system for grammatical representation.&amp;quot; complex-feature-based formalisms.&amp;quot;
In The Mental Representation of Grammatical Proceedings, 23rd Annual Meeting of the
Relations, edited by J. Bresnan, 173-281. ACL. 154-52.
</bodyText>
<page confidence="0.966176">
530
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.000000">
<title confidence="0.999471666666667">Squibs and Discussions Restriction and Termination in Parsing with Feature-Theoretic Grammars</title>
<author confidence="0.99998">S P Harrison T M Ellison</author>
<affiliation confidence="0.997432">University of Western Australia University of Western Australia</affiliation>
<abstract confidence="0.993764148148148">Shieber (1987) describes a technique for limiting the number of active edges introduced into a chart by top-down prediction in chart parsers for PATR grammars, without affecting the correctness completeness of the parser. That technique, termed extendable to other parsing algorithms. It can be employed to increase parsing efficiency and to induce termination for some classes of grammars that would not otherwise terminate. Here, we describe one class of grammars for which restriction, as described by Shieber, induces non-termination. We do not suggest that the concept of restriction is fatally flawed, however. On the contrary, relatively minor modifications to the implementation of restriction can make it a more flexible tool for fine-tuning PATR grammars. Background Shieber (1987) observes that the potentially infinite category domain of feature-theoretic grammar formalisms like PATR-II makes implementing efficient parsers for such formalisms difficult. He concludes that the two earliest approaches to the problem are at best ill-advised. Parsing with a context-free backbone effectively ignores information in fact available to guide the parse and violates the spirit of feature-theoretic grammar. Tailoring the parsing algorithm or the grammar itself to the exigencies of feature-theoretic formalisms puts the burden of coping with the problem in the wrong place, on the end user of a grammar development system. The most obvious alternative to parsing with a context-free backbone is using graph unification, rather than atomic symbol identity, to drive the parsing process. Shieber notes that not only is that approach costly (in using information that in fact can never affect the outcome of a parse) but, for some grammars, induces non-termination. class of grammars Shieber describes might be termed path building grammars, because they are grammars in which the length of a path through the graph increases as one descends the parse tree. The particular grammar Shieber uses is one that counts the number of terminal symbols in the string being parsed:</abstract>
<note confidence="0.780247090909091">(G1) Rule &apos;set end marker&apos; S T: (Sf) = (Tf) (Tf) = a. * Centre for Linguistics, University of Western Australia, Perth, Western Australia © 1992 Association for Computational Linguistics Computational Linguistics Volume 18, Number 4 Rule &apos;recursive clause&apos; To —&gt; = T -4 A. Rule &apos;base clause&apos; Rule &apos;lexical insertion&apos; —* Cl generates trees like the following:</note>
<abstract confidence="0.966085064935065">the course of a derivation, GI builds a path +) from the root of the graph corresponding to each node in the tree. The &apos;count&apos; is reflected in the length of path +). one descends the tree, the length of the path that is the value of the attribute f increases by 1 for each successive node Tn+i: the term path building, grammars like CI. Recall that, in chart parsing regime, for each active edge of the form: (i, j, X .Y 13) and each rule R, of the form: top-down rule adds an active edge of the form: 520 S. P. Harrison and T. M. Ellison Restriction and Termination in Parsing associated with is a graph with graph associated will be a graph = G, U Gm (Y), (Y) the subgraph of at Y. As Shieber points out, a parser employing this top-down rule will not terminate when interpreting grammar Cl. On initialization (with Rule &apos;set end marker&apos;), the parser an active edge seeking a constituent of category top-down rule then uses that edge and the Rule &apos;recursive clause&apos; to generate a new active edge seeking constituent of category That edge then generates a new (and, crucially, a edge not subsumed by any existing edge, &amp;quot;and so forth, ad infinitum.&amp;quot; In other words, each top-down recursion anticipates a different terminal string that is one symbol longer than that predicted on the previous recursion; because the graphs associated with those anticipated strings are distinct, the normal chart parsing checks fail to prevent looping. Shieber&apos;s solution to the problem posed by grammar G1 is to introduce a notion terms restriction, the graph associated with an edge generated by top-down rule (applied to an active edge and a grammar rule not a graph = G, U Gm (X), the graph associated with that portion the graph (associated with to the left hand side of = G, U a graph from filtering out of those paths not explicitly sanctioned by I. The filter t■ is termed a represented as a set of paths graph (=-- G!.1)) derived from filtering all those paths that are not members of Given a restrictor that passes through only the (cat) path, the termination problem for grammar Cl vanishes. Since the active edges generated by the top-down rule pass on only their category information, each time the rule &apos;recursive clause&apos; is called recursively, the edge it generates is the same (underspecified) edge generated on the first call to that rule, and already on the chart. The following observations regarding the restrictors Shieber describes might be made at this point: 1. The graph for the active edge generated by the top-down rule with a parser using restriction is no less specific (has no less information) than graph stipulated the rule used; it is information from the extant active edge that is suppressed. The restrictor provides a i.e., it stipulates which paths are included in the restricted graph, not which paths are suppressed. Problem: Path Building The following grammar might be considered almost the inverse of the grammar G1 by Shieber (1987). It parses strings of length 1, and generates one node 1 Shieber&apos;s definition of restriction is as follows: a relation paths and labels, and a dag define be the most dag J D&apos;) that for every path p either (p) undefined, or (p) or for every dom(EY (p)), That is, every path in the restricted dag is either undefined, atomic, or specifically allowed by the restrictor.&amp;quot; definition might seem to suggest that are instantiated (atom valued) are not filtered out by the restrictor. His examples demonstrate that that is not the correct interpretation of his definition. Rather, it would seem that atomic paths (i.e. &apos;leaves&apos;), and not atomic-valued paths, fall through the filter. 521 Computational Linguistics Volume 18, Number 4 parse tree for each arc labeled the graph corresponding to the item recognized: (G2) Rule &apos;copy attribute&apos; S —&gt; AT: Rule &apos;recursive clause&apos; -- T1: Rule &apos;base clause&apos; T --: &apos;lexical insertion -4 Rule &apos;lexical insertion b&apos; -+ G2 generates exactly two trees: (Ag) = = (Tg) = (Aggg) = (Agg) -= e.</abstract>
<note confidence="0.7556666">Tree2a. Tree2b. A0 A A T A T 0 I b T1 each of which is associated with a distinct graph: Dag2a. Dag2b. 522</note>
<abstract confidence="0.894890512820513">S. P. Harrison and T. M. Ellison Restriction and Termination in Parsing this grammar, the length of the path each subgraph increases as tree. Hence the term path building used to characterize grammars of this sort. Using the same restrictor (i.e. (cat)) employed for CI, a parser interpreting G2 will not terminate on any grammatical input. As in Gl, only one active edge generated from the Rule &apos;recursive clause&apos; is put on the chart: E1 rcat : T J cat:T1 : The rule &apos;base clause&apos; of G2 generates the passive edge: E2 [cat : (1,1,X—&gt; .,[X: g: fundamental rule then applies to E1 and yield the passive edge: E3 then applies to and yield: E4 cat: T 1 g: g:111] T j cat : T 1 1, Xo X1: and so forth, ad infinitum. Ultimately, the fundamental rule will generate a passive with a graph that {G, : r(g)}, the passive edge: (0,1,S -+ : T&apos;(g)} the subgraph corresponding to the constituent that point, the parser, in effect, will have parsed the input string. Nonetheless, it will continue add new passive edges, each with a graph whose is one arc longer than that of the passive edge from which it is generated. path building are not without interesting linguistic applica- Consider, for example, the following PATR implementation of the operation on lists employed in HPSG (Pollard and Sag 1987; Section 2.2): (G3) Rule &apos;collect lists&apos;</abstract>
<note confidence="0.960203">Top Left Right Append: (Append list1) = (Left list) (Append list2) = (Right list) (Top list) -= (Append list). 523 Computational Linguistics Volume 18, Number 4 Rule &apos;base case&apos; Append —*: (Append list) =- (Append list2) (Append listl) = 0. Rule &apos;recursive clause&apos; Append() Appendi:</note>
<abstract confidence="0.981779133333333">list first) = listl first) list rest) = (Appendi list) listl rest) = listl) list2) = list2). Given the rules &apos;base case&apos; and &apos;recursive clause,&apos; one need only introduce a &apos;dummy&apos; constituent Append (whose only function is to collect the list-valued attributes listl and list2 in a single list), and appropriate constraints on some list-valued attribute, in to simulate the HPSG PATR. Unfortunately, because these two rules are an instance of the bottom-up path building problem, no derivation employing these rules will terminate.&apos; Solutions The source of the bottom-up path building problem is the active edge E1 above, whose is of indeterminate length. Because the parser does not know how long that should be, it keeps adding to it infinitum. however, that the parser the required information (obtained from the of constituent A), but induced the restrictor throw that information away. There are at least three solutions to the problem posed by bottom-up path building grammars under restriction: Impose a finite limit on the path Convert the grammar top-down path building. 3. Change the nature and implementation of restriction. We consider each of these proposals in turn in the following paragraphs. 1 involves picking an arbitrary upper limit on the length of adding a corresponding path to the restrictor. The parser would then terminate for input whose length is less than or equal to that of the stipulated path. For example, a parser interpreting G2 above would terminate with the restrictor g g)}. that is a &amp;quot;Band-Aid&amp;quot; solution at best. The is necessary whenever a grammar demands that two list-valued attributes be combined; for example, when the SUBCAT of a constituent is defined as the union of the values of SUBCAT for its daughters, or when the list-valued SKELETON of a syllable is defined as the SKELETON of the onset followed by the SKELETON of the rhyme. One would, of course, prefer to PATR extended to accommodate than have to simulate the in pure but that is not the issue here. The point we are making is simply that one in pure PATR, were it not for the restriction regime of the PATR standard defined in Shieber (1989). 524 S. P. Harrison and T. M. Ellison Restriction and Termination in Parsing Solution 2 might involve a grammar like G4, a top-down path building grammar weakly equivalent to G2. G4 does not, however, have the termination problem of G2: (G4) Rule &apos;base case&apos; -+ Rule &apos;recursive clause&apos; -+ Rule &apos;copy path&apos; Rule &apos;lexical insertion a&apos;</abstract>
<note confidence="0.93484521875">A -4 a: Rule &apos;lexical insertion b&apos; A b: (Tg) = e. (Tog) = (Tigg). (Tg) = (Ag). (Aggg) = e. (Agg) = e. (The following are the trees, and corresponding complex feature structures, generated by G4: S 1 T A 525 Computational Linguistics Volume 18, Number 4 that the length of the path as one tree.) Similarly, G5 provides a top-down path building solution to the (G5) Rule &apos;collect lists&apos; Append Left Right: (Append residue) = (Append list) (Append listl) = (Left list) (Append list2) = (Right list). Rule &apos;append base case&apos; Top —&gt; Append: (Top list) = (Append list) (Append residue) = (Append list2) (Append listl) = ( ). Rule &apos;append recursive clause&apos; Append° —&gt; Append: (Append° list) = (Appendi list)</note>
<abstract confidence="0.873307094339623">listl) = list1 rest) list2) = list2) residue) = residue rest) (Appendi residue first) = (Appendi listl first). Consider the case of two descendants, Left and Right, of a node Top, where the value (Left list) is b), value of (Right list) is d), the value of (Top list) is list), (R list)). G3 assigns to that construction the parse tree: Append2 526 S. P. Harrison and T. M. Ellison Restriction and Termination in Parsing and the complex feature structure: Top: [list : [ 1 I] : a : rest : first: list : [ rest: : : list : : rest: 11 - : : _ list2 : 131 first : . rest : first rest : first : . rest : first rest : list: 11 131 list]. : 4 _ 5 4 _ 6 7 _ 3 7 — 9 - _ I list : 3 listl : 9 [ list2 : 3 : G5, by contrast, assigns it the parse tree: Top I</abstract>
<note confidence="0.5464934">1 1 Left Right 527 Computational Linguistics Volume 18, Number 4</note>
<degree confidence="0.971438714285714">first : rest : first : rest : and the complex feature structure: Top : [list : list :</degree>
<abstract confidence="0.968999770992367">residue: list1 : a 4 rest : first : [ rest first : 6 rest : 5 first : 6 rest : 4 Left: list : : list : I 1 1] 13 1 : 9 7 1 1 1 2 _ list2 : list : 3 residue : 1 j5 1 first : rest : 9 4 first : rest: : list1 : 3 9 7 _ list2 : list : residue: list1 : list2 : 3 1 3 7 3 : As noted above, G3 provides a &apos;dummy&apos; constituent Append that one might want ultimately to prune, since its only function is to assemble the appended list. By contrast, G5 assembles the appended list in successive Append nodes dominating the constituents Left and Right. One might want to argue that the latter solution is less felicitous than the former because the Append nodes dominate lexical material. In any event, as Shieber stresses, the grammar writer should not be constrained to choose between weakly equivalent grammars by the demands of the grammar development system. Let us now consider solution 3, modifying the nature and implementation of re- We choose to term the sort of restriction Shieber describes restriction. positive restriction, the restrictor tells the parser much the information for to retain (in the graph corresponding to the active edge used by the topdown rule). If a path is not explicitly mentioned in the restrictor, no information about that path is retained. An empty restrictor in effect tells the parser to throw away all the information in the restricted graph. anonymous reviewer for Linguistics out that grammars G2 and G3, in contrast to Shieber&apos;s Cl, are not offline parsable [in the sense of Bresnan and Kaplan 1982:263ff and Johnson 1988:95ffl, and suggests that this failure of offline parsability is a necessary condition for membership in the class of grammars that are 528 S. P. Harrison and T. M. Ellison Restriction and Termination in Parsing nonterminating under positive restriction. The constituent structures generated by a grammar are offline parsable iff: i. they contain no nonbranching dominance chains in which the same category [label] appears twice, and ii. all terminal nodes dominate lexical material G2 and G3 fail both these conditions, since neither the T node chain of G2 nor the Append node chain of G3 either branch or dominate lexical material. We make two observations in this regard. First, while it may indeed be the case that failure of offline is a for non-termination under positive restriction, it is not a since G4 and G5 both fail condition i. above, and are thus not offline parsable, but do terminate under positive restriction. Second, though G2 through G5 fail the letter of an offline parsability constraint, they do not fail its spirit. Offline parsability has been proposed as a constraint on grammars guaranteeing the decidability of the recognition problem for feature-theoretic grammars of the sort considered here. For grammars that satisfy offline parsability, it will be the case that the number of nodes of any parse tree assigned to some string will be a computable function of the length of the string being parsed. This is not the case for G2 through G5. What is the case, however, is that the number of nodes in a parse tree generated by those grammars is a computable function of the graphs associated with the lexical material covered by the tree. This is because each of these grammars makes crucial reference either to a list-valued or path-valued attribute of lexical items, where the length of the list or path is finite and stipulated in the lexicon. The number of identical nodes in any nonbranching dominance chain generated by these grammars is a function of the length of a [bounded] list or path.) restriction can be contrasted with what might be termed restricnegative restriction, the restrictor tells the parser what information to throw away. For stipulated paths, the effects of positive and negative restriction are same: a restrictor the parser to (positively) retain all information up to including an atomic value for the path to (negatively) throw away all about any nonatomic extension of difference is in the interpretation of paths not explicitly mentioned; under positive restriction these are thrown away; under negative restriction they are retained. In formal terms, a restrictor, for Shieber, is a relation between paths and the single that are permitted to extend those paths: If 4) is a restrictor, path and label, then the restrictor permits the path Shieber does not use full power of this formalism. He considers only what we term restrictors. if some finite set of paths, one can define a positive restrictor to be the relation defined by: 3 &lt; q that a (perhaps improper) prefix to the path contrast, the restriction proposed here allows paths not explicitly disallowed: r E r &lt; p) E P, p q (1) In other words, whereas the positive restrictor admits those paths obeying the condition &amp;quot;is a prefix of a member of the restrictor set,&amp;quot; the negative restrictor only applies 529 Computational Linguistics Volume 18, Number 4 this condition to paths extending members of the restrictor set. Paths not extending members of the restrictor set are themselves not subject to restriction. It is an easy matter to show that any positive restrictor p can be defined in terms of a negative restrictor. If the null path is included in the restrictor set, then the antecedent the implication in the definition of (1 above) is always true (except if = ( )), the consequent {( )}, &lt; q equivalent to p &lt; q when = ( If the null path, then the antecedent is always true and so pu{o} equivalent to For other 0 11 = = Thus, an implementation using negative restriction can simulate any positive restrictor and, therefore, can necessarily solve all problems solvable by positive restriction, as well as those problems, described earlier, where positive restriction fails. Note that we have limited ourselves, as Shieber has, to finite restrictor sets. This limitation is not necessary. A more general proposal allows restrictor sets consisting of all paths expressable by some regular expression. Restrictors can then be implemented as finite state automata. An implementation of this sort would not impose a large computational burden and would allow much greater flexibility in the choice of restrictor relations. We have demonstrated that any restriction definable by a positive restrictor can also be defined by a negative restrictor. It follows that any parser requiring positive restriction to guarantee termination will also terminate for the same set of grammars using negative restriction. But we have also demonstrated that the reverse does not hold. Therefore, it would seem that negative restriction is superior to positive restriction in the implementation of parsers for feature-theoretic grammars.</abstract>
<note confidence="0.9420845">References MIT Press. Johnson, M. (1988). &amp;quot;Attribute-value logic the theory of grammar.&amp;quot; Lecture Pollard, C., and Sag, I. A. (1987). &amp;quot;Information-based syntax and Lecture Notes, Kaplan, R., and Bresnan, J. (1982). &amp;quot;Lexical-functional grammar, a formal system for grammatical representation.&amp;quot; Mental Representation of Grammatical by J. Bresnan, 173-281. Shieber, S. M. (1987). &amp;quot;Using restriction to extend parsing algorithms for complex-feature-based formalisms.&amp;quot; Proceedings, 23rd Annual Meeting of the 530</note>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
</citationList>
</algorithm>
</algorithms>