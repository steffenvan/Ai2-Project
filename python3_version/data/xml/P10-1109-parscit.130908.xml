<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<title confidence="0.994624">
A Tree Transducer Model for Synchronous Tree-Adjoining Grammars
</title>
<author confidence="0.830667">
Andreas Maletti
</author>
<affiliation confidence="0.547981">
Universitat Rovira i Virgili
Avinguda de Catalunya 25, 43002 Tarragona, Spain.
</affiliation>
<email confidence="0.921236">
andreas.maletti@urv.cat
</email>
<sectionHeader confidence="0.99291" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999785692307692">
A characterization of the expressive power
of synchronous tree-adjoining grammars
(STAGs) in terms of tree transducers (or
equivalently, synchronous tree substitution
grammars) is developed. Essentially, a
STAG corresponds to an extended tree
transducer that uses explicit substitution in
both the input and output. This characteri-
zation allows the easy integration of STAG
into toolkits for extended tree transducers.
Moreover, the applicability of the charac-
terization to several representational and
algorithmic problems is demonstrated.
</bodyText>
<sectionHeader confidence="0.998379" genericHeader="keywords">
1 Introduction
</sectionHeader>
<bodyText confidence="0.999480090909091">
Machine translation has seen a multitude of for-
mal translation models. Here we focus on syntax-
based (or tree-based) models. One of the old-
est models is the synchronous context-free gram-
mar (Aho and Ullman, 1972). It is clearly too
weak as a syntax-based model, but found use in
the string-based setting. Top-down tree transduc-
ers (Rounds, 1970; Thatcher, 1970) have been
heavily investigated in the formal language com-
munity (G´ecseg and Steinby, 1984; G´ecseg and
Steinby, 1997), but as argued by Shieber (2004)
they are still too weak for syntax-based machine
translation. Instead Shieber (2004) proposes syn-
chronous tree substitution grammars (STSGs) and
develops an equivalent bimorphism (Arnold and
Dauchet, 1982) characterization. This character-
ization eventually led to the rediscovery of ex-
tended tree transducers (Graehl and Knight, 2004;
Knight and Graehl, 2005; Graehl et al., 2008),
which are essentially as powerful as STSG. They
had been studied already by Arnold and Dauchet
(1982) in the form of bimorphisms, but received
little attention until rediscovered.
Shieber (2007) claims that even STSGs might
be too simple to capture naturally occuring transla-
tion phenomena. Instead Shieber (2007) suggests
a yet more powerful mechanism, synchronous
tree-adjoining grammars (STAGs) as introduced
by Shieber and Schabes (1990), that can capture
certain (mildly) context-sensitive features of natu-
ral language. In the tradition of Shieber (2004), a
characterization of the power of STAGs in terms
of bimorphims was developed by Shieber (2006).
The bimorphisms used are rather unconventional
because they consist of a regular tree language and
two embedded tree transducers (instead of two tree
homomorphisms). Such embedded tree transduc-
ers (Shieber, 2006) are particular macro tree trans-
ducers (Courcelle and Franchi-Zannettacci, 1982;
Engelfriet and Vogler, 1985).
In this contribution, we try to unify the pic-
ture even further. We will develop a tree trans-
ducer model that can simulate STAGs. It turns out
that the adjunction operation of an STAG can be
explained easily by explicit substitution. In this
sense, the slogan that an STAG is an STSG with
adjunction, which refers to the syntax, also trans-
lates to the semantics. We prove that any tree
transformation computed by an STAG can also be
computed by an STSG using explicit substitution.
Thus, a simple evaluation procedure that performs
the explicit substitution is all that is needed to sim-
ulate an STAG in a toolkit for STSGs or extended
tree transducers like TIBURON by May and Knight
(2006).
We show that some standard algorithms on
STAG can actually be run on the constructed
STSG, which often is simpler and better under-
stood. Further, it might be easier to develop new
algorithms with the alternative characterization,
which we demonstrate with a product construc-
tion for input restriction in the spirit of Neder-
hof (2009). Finally, we also present a complete
tree transducer model that is as powerful as STAG,
which is an extension of the embedded tree trans-
ducers of Shieber (2006).
</bodyText>
<page confidence="0.928744">
1067
</page>
<note confidence="0.969029">
Proceedings of the 48th Annual Meeting of the Association for Computational Linguistics, pages 1067–1076,
Uppsala, Sweden, 11-16 July 2010. c�2010 Association for Computational Linguistics
</note>
<sectionHeader confidence="0.970649" genericHeader="introduction">
2 Notation
</sectionHeader>
<bodyText confidence="0.999660266666667">
We quickly recall some central notions about trees,
tree languages, and tree transformations. For a
more in-depth discussion we refer to G´ecseg and
Steinby (1984) and G´ecseg and Steinby (1997). A
finite set E of labels is an alphabet. The set of all
strings over that alphabet is E* where ε denotes
the empty string. To simplify the presentation, we
assume an infinite set X = {x1, x2,... } of vari-
ables. Those variables are syntactic and represent
only themselves. In particular, they are all differ-
ent. For each k ≥ 0, we let Xk = {x1,... , xk}.
We can also form trees over the alphabet E. To
allow some more flexibility, we will also allow
leaves from a special set V . Formally, a E-tree
over V is either:
</bodyText>
<listItem confidence="0.997196">
• a leaf labeled with an element of v ∈ E ∪ V ,
or
• a node that is labeled with an element of E
</listItem>
<bodyText confidence="0.83885">
with k ≥ 1 children such that each child is a
E-tree over V itself.1
The set of all E-trees over V is denoted by TΣ(V ).
We just write TΣ for TΣ(∅). The trees in Figure 1
are, for example, elements of TΔ(Y ) where
</bodyText>
<equation confidence="0.8805875">
A = {S, NP, VP, V, DT, N}
Y = {saw, the} .
</equation>
<bodyText confidence="0.9996776875">
We often present trees as terms. A leaf labeled v
is simply written as v. The tree with a root node
labeled σ is written σ(t1, ... , tk) where t1, ... , tk
are the term representations of its k children.
A tree language is any subset of TΣ(V ) for
some alphabet E and set V . Given another al-
phabet A and a set Y , a tree transformation is a
relation τ ⊆ TΣ(V ) × TΔ(Y ). In many of our
examples we have V = ∅ = Y . Occasionally,
we also speak about the translation of a tree trans-
formation τ ⊆ TΣ × TΔ. The translation of τ is
the relation {(yd(t), yd(u))  |(t, u) ∈ τ} where
yd(t), the yield of t, is the sequence of leaf labels
in a left-to-right tree traversal of t. The yield of the
third tree in Figure 1 is “the N saw the N”. Note
that the translation is a relation τ&apos; ⊆ E* × A*.
</bodyText>
<sectionHeader confidence="0.998209" genericHeader="method">
3 Substitution
</sectionHeader>
<bodyText confidence="0.999921333333333">
A standard operation on (labeled) trees is substitu-
tion, which replaces leaves with a specified label
in one tree by another tree. We write t[u]A for (the
</bodyText>
<footnote confidence="0.9498295">
1Note that we do not require the symbols to have a fixed
rank; i.e., a symbol does not determine its number of children.
</footnote>
<note confidence="0.292492">
t u t[u]NP
</note>
<figureCaption confidence="0.9999">
Figure 1: A substitution.
</figureCaption>
<bodyText confidence="0.996061555555556">
result of) the substitution that replaces all leaves
labeled A in the tree t by the tree u. If t ∈ TΣ(V )
and u ∈ TΔ(Y ), then t[u]A ∈ TΣuΔ(V ∪ Y ). We
often use the variables of X = {x1, x2,... } as
substitution points and write t[u1, ... , uk] instead
of (··· (t[u1]x,) ... )[uk]xk.
An example substitution is shown in Figure 1.
The figure also illustrates a common problem with
substitution. Occasionally, it is not desirable to re-
place all leaves with a certain label by the same
tree. In the depicted example, we might want
to replace one ‘NP’ by a different tree, which
cannot be achieved with substitution. Clearly,
this problem is avoided if the source tree t con-
tains only one leaf labeled A. We call a tree A-
proper if it contains exactly one leaf with label A.2
The subset CΣ(Xk) ⊆ TΣ(Xk) contains exactly
those trees of TΣ(Xk) that are xi-proper for every
1 ≤ i ≤ k. For example, the tree t of Figure 1 is
‘saw’-proper, and the tree u of Figure 1 is ‘the’-
and ‘N’-proper.
In this contribution, we will also use substitu-
tion as an explicit operator. The tree t[u]NP in
Figure 1 only shows the result of the substitution.
It cannot be infered from the tree alone, how it
was obtained (if we do not know t and u).3 To
make substitution explicit, we use the special bi-
nary symbols ·[·]A where A is a label. Those sym-
bols will always be used with exactly two chil-
dren (i.e., as binary symbols). Since this prop-
erty can easily be checked by all considered de-
vices, we ignore trees that use those symbols in a
non-binary manner. For every set E of labels, we
let E = E ∪ {·[·]A  |A ∈ E} be the extended
set of labels containing also the substition sym-
bols. The substitution of Figure 1 can then be ex-
</bodyText>
<footnote confidence="0.985003">
2A-proper trees are sometimes also called A-context in
the literature.
3This remains true even if we know that the participating
trees t and u are A-proper and the substitution t[u]A replac-
ing leaves labeled A was used. This is due to the fact that, in
general, the root label of u need not coincide with A.
</footnote>
<figure confidence="0.993978904761905">
S
NP VP
saw
V
NP
NP
DT
the
N
NP
DT
the
N
S
saw
V
VP
NP
DT
the
N
</figure>
<page confidence="0.982571">
1068
</page>
<bodyText confidence="0.9995905">
pressed as the tree ·[·]NP(t,u). To obtain t[u]NP
(the right-most tree in Figure 1), we have to evalu-
ate ·[·]NP(t, u). However, we want to replace only
one leaf at a time. Consequently, we restrict the
evaluation of ·[·]A(t, u) such that it applies only to
trees t whose evaluation is A-proper. To enforce
this restriction, we introduce an error signal L,
which we assume not to occur in any set of la-
bels. Let E be the set of labels. Then we define
the function ·E : TE —* TE U {L} by4
</bodyText>
<equation confidence="0.99994275">
E E E
σ(t1,...,tk) = σ(t1 ,...,tk)
E 1 tE[uEI A if tE is A-proper
[ ]A(t&apos; u) =
</equation>
<bodyText confidence="0.9883165">
for every k &gt; 0, σ E E, and t, t1, ... , tk, u E TE.5
We generally discard all trees that contain the er-
ror signal L. Since the devices that we will study
later can also check the required A-properness us-
ing their state behavior, we generally do not dis-
cuss trees with error symbols explicitly.
</bodyText>
<sectionHeader confidence="0.973427" genericHeader="method">
4 Extended tree transducer
</sectionHeader>
<bodyText confidence="0.9972130625">
An extended tree transducer is a theoretical model
that computes a tree transformation. Such trans-
ducers have been studied first by Arnold and
Dauchet (1982) in a purely theoretic setting, but
were later applied in, for example, machine trans-
lation (Knight and Graehl, 2005; Knight, 2007;
Graehl et al., 2008; Graehl et al., 2009). Their
popularity in machine translation is due to Shieber
(2004), in which it is shown that extended tree
transducers are essentially (up to a relabeling) as
expressive as synchronous tree substitution gram-
mars (STSG). We refer to Chiang (2006) for an
introduction to synchronous devices.
Let us recall the formal definition. An ex-
tended tree transducer (for short: XTT)6 is a sys-
tem M = (Q, E, A, I, R) where
</bodyText>
<listItem confidence="0.887420666666667">
• Q is a finite set of states,
• E and A are alphabets of input and output
symbols, respectively,
• I C Q is a set of initial states, and
• R is a finite set of rules of the form
(q, l) —* (q1 ··· qk, r)
</listItem>
<footnote confidence="0.867113375">
4Formally, we should introduce an evaluation function for
each alphabet E, but we assume that the alphabet can be in-
fered.
5This evaluation is a special case of a yield-mapping (En-
gelfriet and Vogler, 1985).
6Using the notions of Graehl et al. (2009) our extended
tree transducers are linear, nondeleting extended top-down
tree transducers.
</footnote>
<figureCaption confidence="0.62740975">
Figure 2: Example rules taken from Graehl et al.
(2009). The term representation of the first rule
is (qS, S(x1, VP(x2, x3))) —* (w, S&apos;(x2, x1, x3))
where w = qNPqVqNP.
</figureCaption>
<bodyText confidence="0.979016">
where k &gt; 0, l E CE(Xk), and r E CA(Xk).
Recall that any tree of CE(Xk) contains each
variable of Xk = {x1, ... , xk} exactly once. In
graphical representations of a rule
</bodyText>
<equation confidence="0.484336">
(q, l) —* (q1 ··· qk, r) E R ,
we usually
</equation>
<listItem confidence="0.9924666">
• add the state q as root node of the left-hand
side7, and
• add the states q1, ... , qk on top of the nodes
labeled x1, ... , xk, respectively, in the right-
hand side of the rule.
</listItem>
<bodyText confidence="0.977781444444444">
Some example rules are displayed in Figure 2.
The rules are applied in the expected way (as in
a term-rewrite system). The only additional fea-
ture are the states of Q, which can be used to con-
trol the derivation. A sentential form is a tree that
contains exclusively output symbols towards the
root and remaining parts of the input headed by a
state as leaves. A derivation step starting from ξ
then consists in
</bodyText>
<listItem confidence="0.997861615384615">
• selecting a leaf of ξ with remaining input
symbols,
• matching the state q and the left-hand side l
of a rule (q, l) —* (q1 · · · qk, r) E R to the
state and input tree stored in the leaf, thus
matching input subtrees t1, ... , tk to the vari-
ables x1, ... , xk,
• replacing all the variables x1, ... , xk in the
right-hand side r by the matched input sub-
trees q1(t1), ... , qk(tk) headed by the corre-
sponding state, respectively, and
• replacing the selected leaf in ξ by the tree
constructed in the previous item.
</listItem>
<bodyText confidence="0.931585">
The process is illustrated in Figure 3.
Formally, a sentential form of the XTT M is a
tree of SF = TA(Q(TE)) where
</bodyText>
<equation confidence="0.909489">
Q(TE) = {q(t)  |q E Q,t E TE} .
</equation>
<footnote confidence="0.937053">
7States are thus also special symbols that are exclusively
used as unary symbols.
</footnote>
<figure confidence="0.996348034482759">
S’
—*
—*
qNP
qV
NP
N
atefl
x2
N
boy
the
qS
S
x1 VP
x2 x3
qNP
NP
DT
qNP
x1 x3
L otherwise
1069
NP
NP
DT
les
bonbons
adjunction
</figure>
<figureCaption confidence="0.999685">
Figure 4: Illustration of an adjunction taken from
Nesson et al. (2008).
</figureCaption>
<figure confidence="0.999568166666667">
derived
tree
N
bonbons
DT
les
N
N
ADJ
rouges
�
C
S’
qNP
VP
qV
qNP
t1
t2
t1
t3
t2 t3
qS
S
C
N
N* ADJ
rouges
auxiliary
tree
</figure>
<figureCaption confidence="0.966085">
Figure 3: Illustration of a derivation step of an
XTT using the left rule of Figure 2.
</figureCaption>
<equation confidence="0.489695666666667">
Given ξ, ζ E SF, we write ξ ==&gt;. ζ if there ex-
ist C E CA(X1), t1, ... , tk E TE, and a rule
(q, l) (q1 • • • qk, r) E R such that
</equation>
<listItem confidence="0.853733">
• ξ = C[q(l[t1, ... , tk])] and
• ζ = C[r[q1(t1),... ,qk(tk)]].
</listItem>
<bodyText confidence="0.866974">
The tree transformation computed by M is the re-
lation
</bodyText>
<equation confidence="0.87771">
τM = {(t,u) E TE x TA I Iq E I : q(t) ==&gt;.* u}
</equation>
<bodyText confidence="0.999918142857143">
where ==�-* is the reflexive, transitive closure of ==�-.
In other words, the tree t can be transformed into u
if there exists an initial state q such that we can
derive u from q(t) in several derivation steps.
We refer to Arnold and Dauchet (1982), Graehl
et al. (2008), and Graehl et al. (2009) for a more
detailed exposition to XTT.
</bodyText>
<sectionHeader confidence="0.838136" genericHeader="method">
5 Synchronous tree-adjoining grammar
</sectionHeader>
<bodyText confidence="0.999794470588235">
XTT are a simple, natural model for tree trans-
formations, however they are not suitably ex-
pressive for all applications in machine transla-
tion (Shieber, 2007). In particular, all tree trans-
formations of XTT have a certain locality condi-
tion, which yields that the input tree and its corre-
sponding translation cannot be separated by an un-
bounded distance. To overcome this problem and
certain dependency problems, Shieber and Sch-
abes (1990) and Shieber (2007) suggest a stronger
model called synchronous tree-adjoining gram-
mar (STAG), which in addition to the substitution
operation of STSG (Chiang, 2005) also has an ad-
joining operation.
Let us recall the model in some detail. A tree-
adjoining grammar essentially is a regular tree
grammar (G´ecseg and Steinby, 1984; G´ecseg and
</bodyText>
<figure confidence="0.520246">
NP
</figure>
<figureCaption confidence="0.978447">
Figure 5: Illustration of the adjunction of Figure 4
using explicit substitution.
</figureCaption>
<bodyText confidence="0.9486823125">
Steinby, 1997) enhanced with an adjunction oper-
ation. Roughly speaking, an adjunction replaces a
node (not necessarily a leaf) by an auxiliary tree,
which has exactly one distinguished foot node.
The original children of the replaced node will be-
come the children of the foot node after adjunc-
tion. Traditionally, the root label and the label of
the foot node coincide in an auxiliary tree aside
from a star index that marks the foot node. For
example, if the root node of an auxiliary tree is
labeled A, then the foot node is traditionally la-
beled A*. The star index is not reproduced once
adjoined. Formally, the adjunction of the auxil-
iary tree u with root label A (and foot node la-
bel A*) into a tree t = C[A(t1, ... , tk)] with
C E CE(X1) and t1,...,tk ETEis
</bodyText>
<equation confidence="0.74519">
C[u[A(t1, ... , tk)]A*] .
</equation>
<bodyText confidence="0.997803">
Adjunction is illustrated in Figure 4.
We note that adjunction can easily be expressed
using explicit substitution. Essentially, only an ad-
ditional node with the adjoined subtree is added.
The result of the adjunction of Figure 4 using ex-
plicit substitution is displayed in Figure 5.
To simplify the development, we will make
some assumptions on all tree-adjoining grammars
(and synchronous tree-adjoining grammars). A
tree-adjoining grammar (TAG) is a finite set of
initial trees and a finite set of auxiliary trees. Our
</bodyText>
<figure confidence="0.984910170212766">
DT
.[.]N*
N* ADJ
rouges
N
bonbons
N
les
1070
S1
T
S
S?
c
S
a S
S? a
S
b S
S? b
S1
S
— T
S1
c a S? a
S
a
S1
S? a
S
T
c
—
—
—
S
S?
S
S?
S
b S1
S? b
S
S1
b S? b
initial auxiliary auxiliary auxiliary
tree tree tree tree
</figure>
<figureCaption confidence="0.9526895">
Figure 6: A TAG for the copy string language
{wcw  |w ∈ {a, b}*} taken from Shieber (2006).
</figureCaption>
<bodyText confidence="0.99993252631579">
TAG do not use substitution, but only adjunction.
A derivation is a chain of trees that starts with an
initial tree and each derived tree is obtained from
the previous one in the chain by adjunction of an
auxiliary tree. As in Shieber (2006) we assume
that all adjunctions are mandatory; i.e., if an aux-
iliary tree can be adjoined, then we need to make
an adjunction. Thus, a derivation starting from an
initial tree to a derived tree is complete if no ad-
junction is possible in the derived tree. Moreover,
we assume that to each node only one adjunction
can be applied. This is easily achieved by label-
ing the root of each adjoined auxiliary tree by a
special marker. Traditionally, the root label A of
an auxiliary tree is replaced by AO once adjoined.
Since we assume that there are no auxiliary trees
with such a root label, no further adjunction is pos-
sible at such nodes. Another effect of this restric-
tion is that the number of operable nodes (i.e., the
nodes to which an adjunction must still be applied)
is known at any given time.8 A full TAG with our
restrictions is shown in Figure 6.
Intuitively, a synchronous tree-adjoining gram-
mar (STAG) is essentially a pair of TAGs. The
synchronization is achieved by pairing the initial
trees and the auxiliary trees. In addition, for each
such pair (t, u) of trees, there exists a bijection be-
tween the operable nodes of t and u. Such nodes in
bijection are linked and the links are preserved in
derivations, in which we now use pairs of trees as
sentential forms. In graphical representations we
often indicate this bijection with integers; i.e., two
nodes marked with the same integer are linked. A
pair of auxiliary trees is then adjoined to linked
nodes (one in each tree of the sentential form) in
the expected manner. We will avoid a formal def-
inition here, but rather present an example STAG
and a derivation with it in Figures 7 and 8. For a
</bodyText>
<footnote confidence="0.971258333333333">
8Without the given restrictions, this number cannot be de-
termined easily because no or several adjunctions can take
place at a certain node.
</footnote>
<figure confidence="0.892405555555555">
{(wcwR, wcw)
 |w ∈ {a, b}*} where wR is the
reverse of w.
STAG G we write
for the tree tran
τG
sformation
computed by G.
sult
</figure>
<figureCaption confidence="0.85114">
the tree transformation represented by
</figureCaption>
<bodyText confidence="0.966132222222222">
up to
a relabeling (a mapping that consistently replaces
node labels throughout the tree). The additional
relabeling is required because
do not have
states. If we replace the extended tree transducer
by a STSG, then the result holds even without the
relabeling.
Theore
</bodyText>
<equation confidence="0.6564086">
τM
STAGs
m 1 For every STAG G, there exists an ex-
tended tree transducer M such that
τG = {(tE, uE)  |(t, u) ∈ τM} .
</equation>
<bodyText confidence="0.782161333333333">
Conversely, for every extended tree transducer M,
there exists a STAG G such that the above relation
holds up to a relabeling.
</bodyText>
<subsectionHeader confidence="0.997661">
6.1 Proof sketch
</subsectionHeader>
<bodyText confidence="0.973469">
will illustrate the relevant constr
uction on our ex-
ample after the proof sketch, which contains the
outline for the correctness.
</bodyText>
<figureCaption confidence="0.998012">
Figure 7: STAG that computes the translation
</figureCaption>
<sectionHeader confidence="0.967425" genericHeader="method">
6 Main re
</sectionHeader>
<bodyText confidence="0.999794538461539">
In this section, we will present our main result. Es-
sentially, it states that a STAG is as powerful as a
STSG using explicit substitution. Thus, for every
tree transformation computed by a STAG, there is
an extended tree transducer that computes a repre-
sentation of the tree transformation using explicit
substitution. The converse is also true. For every
extended tree transducer M that uses explicit sub-
stitution, we can construct a STAG that computes
The following proof sketch is intended for readers
that are familiar with the literature on embedded
tree transducers, macro tree transducers, and bi-
morphisms. It can safely be skipped because we
</bodyText>
<page confidence="0.971665">
1071
</page>
<figure confidence="0.999367132075472">
S1
T
—
S1
T
a
a —
S
S
S1
b S
a S
T
c
c
T
S
S1
a S
T
c
S
a S1
S
T
c
c
S
a S
b S
a S1
a — S
b S b
a S a
a
S
a S
b S1
b — S
a
a
S
T
c
S
S
S
S1
b a S
b S
a S
T
c c
</figure>
<figureCaption confidence="0.999913">
Figure 8: An incomplete derivation using the STAG of Figure 7.
</figureCaption>
<bodyText confidence="0.998816542857143">
Let r C_ TE x TA be a tree transformation
computed by a STAG. By Shieber (2006) there
exists a regular tree language L C_ Tr and two
functions e1: Tr —* TE and e2: Tr —* TA such
that T = {(e1(t),e2(t)) I t E L}. Moreover,
e1 and e2 can be computed by embedded tree
transducers (Shieber, 2006), which are particu-
lar 1-state, deterministic, total, 1-parameter, lin-
ear, and nondeleting macro tree transducers (Cour-
celle and Franchi-Zannettacci, 1982; Engelfriet
and Vogler, 1985). In fact, the converse is also true
up to a relabeling, which is also shown in Shieber
(2006). The outer part of Figure 9 illustrates these
relations. Finally, we remark that all involved con-
structions are effective.
Using a result of Engelfriet and Vogler (1985),
each embedded tree transducer can be decom-
posed into a top-down tree transducer (G´ecseg
and Steinby, 1984; G´ecseg and Steinby, 1997)
and a yield-mapping. In our particular case, the
top-down tree transducers are linear and nondelet-
ing homomorphisms h1 and h2. Linearity and
nondeletion are inherited from the corresponding
properties of the macro tree transducer. The prop-
erties ‘1-state’, ‘deterministic’, and ‘total’ of the
macro tree transducer ensure that the obtained top-
down tree transducer is also 1-state, determinis-
tic, and total, which means that it is a homomor-
phism. Finally, the 1-parameter property yields
that the used substitution symbols are binary (as
our substitution symbols ·[·]A). Consequently, the
yield-mapping actually coincides with our evalua-
tion. Again, this decomposition actually is a char-
acterization of embedded tree transducers. Now
the set I(h1(t), h2(t)) I t E L} can be computed
</bodyText>
<figureCaption confidence="0.999163">
Figure 9: Illustration of the proof sketch.
</figureCaption>
<bodyText confidence="0.9998465">
by an extended tree transducer M due to results
of Shieber (2004) and Maletti (2008). More pre-
cisely, every extended tree transducer computes
such a set, so that also this step is a characteri-
zation. Thus we obtain that T is an evaluation of a
tree transformation computed by an extended tree
transducer, and moreover, for each extended tree
transducer, the evaluation can be computed (up to
a relabeling) by a STAG. The overall proof struc-
ture is illustrated in Figure 9.
</bodyText>
<subsectionHeader confidence="0.992486">
6.2 Example
</subsectionHeader>
<bodyText confidence="0.999974083333333">
Let us illustrate one direction (the construction
of the extended tree transducer) on our example
STAG of Figure 7. Essentially, we just prepare all
operable nodes by inserting an explicit substitu-
tion just on top of them. The first subtree of that
substitution will either be a variable (in the left-
hand side of a rule) or a variable headed by a state
(in the right-hand side of a rule). The numbers of
the variables encode the links of the STAG. Two
example rules obtained from the STAG of Figure 7
are presented in Figure 10. Using all XTT rules
constructed for the STAG of Figure 7, we present
</bodyText>
<equation confidence="0.955481">
T
e1 e2
h1 h2
·E
TM
·E
</equation>
<page confidence="0.986507">
1072
</page>
<figureCaption confidence="0.688609875">
Figure 10: Two constructed XTT rules.
a complete derivation of the XTT in Figure 11 that
(up to the final step) matches the derivation of the
STAG in Figure 8. The matching is achieved by
the evaluation ·E introduced in Section 3 (i.e., ap-
plying the evaluation to the derived trees of Fig-
ure 11 yields the corresponding derived trees of
Figure 8.
</figureCaption>
<sectionHeader confidence="0.994851" genericHeader="method">
7 Applications
</sectionHeader>
<bodyText confidence="0.99997875">
In this section, we will discuss a few applications
of our main result. Those range from representa-
tional issues to algorithmic problems. Finally, we
also present a tree transducer model that includes
explicit substitution. Such a model might help to
address algorithmic problems because derivation
and evaluation are intertwined in the model and
not separate as in our main result.
</bodyText>
<subsectionHeader confidence="0.950075">
7.1 Toolkits
</subsectionHeader>
<bodyText confidence="0.99997352631579">
Obviously, our characterization can be applied in
a toolkit for extended tree transducers (or STSG)
such as TIBURON by May and Knight (2006) to
simulate STAG. The existing infrastructure (input-
output, derivation mechanism, etc) for extended
tree transducers can be re-used to run XTTs en-
coding STAGs. The only additional overhead is
the implementation of the evaluation, which is a
straightforward recursive function (as defined in
Section 3). After that any STAG can be simulated
in the existing framework, which allows experi-
ments with STAG and an evaluation of their ex-
pressive power without the need to develop a new
toolkit. It should be remarked that some essential
algorithms that are very sensitive to the input and
output behavior (such as parsing) cannot be sim-
ulated by the corresponding algorithms for STSG.
It remains an open problem whether the close rela-
tionship can also be exploited for such algorithms.
</bodyText>
<subsectionHeader confidence="0.989654">
7.2 Algorithms
</subsectionHeader>
<bodyText confidence="0.991992660377358">
We already mentioned in the previous section
that some algorithms do not easily translate from
STAG to STSG (or vice versa) with the help of
our characterization. However, many standard al-
gorithms for STAG can easily be derived from
the corresponding algorithms for STSG. The sim-
plest example is the union of two STAG. Instead
of taking the union of two STAG using the clas-
sical construction, we can take the union of the
corresponding XTT (or STSG) that simulate the
STAGs. Their union will simulate the union of the
STAGs. Such properties are especially valuable
when we simulate STAG in toolkits for XTT.
A second standard algorithm that easily trans-
lates is the algorithm computing the n-best deriva-
tions (Huang and Chiang, 2005). Clearly, the n-
best derivation algorithm does not consider a par-
ticular input or output tree. Since the derivations
of the XTT match the derivations of the STAG
(in the former the input and output are encoded
using explicit substitution), the n-best derivations
will coincide. If we are additionally interested in
the input and output trees for those n-best deriva-
tions, then we can simply evaluate the coded input
and output trees returned by n-best derivation al-
gorithm.
Finally, let us consider an algorithm that can be
obtained for STAG by developing it for XTT us-
ing explicit substitution. We will develop a BAR-
HILLEL (Bar-Hillel et al., 1964) construction for
STAG. Thus, given a STAG G and a recognizable
tree language L, we want to construct a STAG G&apos;
such that
TG&apos; = {(t, u)  |(t, u) E TG, t E L} .
In other words, we take the tree transformation TG
but additionally require the input tree to be in L.
Consequently, this operation is also called input
restriction. Since STAG are symmetric, the corre-
sponding output restriction can be obtained in the
same manner. Note that a classical BAR-HILLEL
construction restricting to a regular set of yields
can be obtained easily as a particular input restric-
tion. As in Nederhof (2009) a change of model
is beneficial for the development of such an algo-
rithm, so we will develop an input restriction for
XTT using explicit substitution.
Let M = (Q, E, A, I, R) be an XTT (using ex-
plicit substitution) and G = (N, E, I&apos;, P) be a
tree substitution grammar (regular tree grammar)
in normal form that recognizes L (i.e., L(G) = L).
Let S = {A E E  |·[·]A E E}. A context is a map-
ping c: S —* N, which remembers a nontermi-
nal of G for each substitution point. Given a rule
</bodyText>
<figure confidence="0.997879782608696">
4S
·[·]S�
x1 S
T
c
·[·]S�
S
x1 T
c
4S
S
·[·]S�
x1 S
a S� a
S
a ·[·]S�
4S
x1
�
�
4S
S
S� a
</figure>
<page confidence="0.787151">
1073
</page>
<figureCaption confidence="0.994077">
Figure 11: Complete derivation using the constructed XTT rules.
</figureCaption>
<figure confidence="0.999908717948718">
S
S?
S
·[·]S?
S
a S? a
S
b S? b
S
S?
S
·[·]S?
S
a S? a
S
·[·]S?
S
b S? b
·[·]S?
qS
S
·[·]S?
S
a S? a
S
T
c
�
S
S?
S
·[·]S?
S
a S? a
S
a ·[·]S?
qS
S
·[·]S?
S
b S? b
·[·]S?
S
S? a
T
S
c
�
S
S?
S
a ·[·]S?
S
b ·[·]S?
qS
S
·[·]S?
S
a S? a
S
S? b
·[·]S?
S
S? a
T
S
c
�
S
a ·[·]S?
qS
S
S?
S
a ·[·]S?
S
b ·[·]S?
S
S? a
S
S? b
·[·]S?
S
S? a
T
S
c
�
S
a ·[·]S?
S
S
S? S? a
S
a ·[·]S?
S
b ·[·]S?
S
S? b
·[·]S?
S
S? a
S
T
c
S
T
S
·[·]S?
qS
·[·]S?
c
�
a S? a
S
·[·]S?
S
</figure>
<bodyText confidence="0.92588075">
(q, l) —* (q1 · · · qk, r) E R, a nonterminal p E N,
and a context c E S, we construct new rules cor-
responding to successful parses of l subject to the
following restrictions:
</bodyText>
<listItem confidence="0.833465333333333">
• If l = ·[·]A(l1, l2) for some A E E, then se-
lect p&apos; E N, parse l1 in p with context c&apos;
where c&apos; = c[A H p&apos;]9, and parse l2 in p&apos;
with context c.
• If l = A? with A E E, then p = c(A).
• Finally, if l = σ(l1, ... , lk) for some σ E E,
then select p —* σ(p1, ... , pk) E P is a pro-
duction of G and we parse li with nontermi-
nal pi and context c for each 1 G i G k.
</listItem>
<subsectionHeader confidence="0.925176">
7.3 A complete tree transducer model
</subsectionHeader>
<bodyText confidence="0.991213964285714">
So far, we have specified a tree transducer model
that requires some additional parsing before it can
be applied. This parsing step has to annotate (and
correspondingly restructure) the input tree by the
adjunction points. This is best illustrated by the
left tree in the last pair of trees in Figure 8. To run
our constructed XTT on the trivially completed
version of this input tree, it has to be transformed
into the first tree of Figure 11, where the adjunc-
tions are now visible. In fact, a second un-parsing
step is required to evaluate the output.
To avoid the first additional parsing step, we
will now modify our tree transducer model such
that this parsing step is part of its semantics. This
shows that it can also be done locally (instead of
globally parsing the whole input tree). In addition,
we arrive at a tree transducer model that exactly
(up to a relabeling) matches the power of STAG,
which can be useful for certain constructions. It is
known that an embedded tree transducer (Shieber,
2006) can handle the mentioned un-parsing step.
An extended embedded tree transducer with
9c&apos; is the same as c except that it maps A to p.
substitution M = (Q, E, A, I, R) is simply an
embedded tree transducer with extended left-hand
sides (i.e., any number of input symbols is allowed
in the left-hand side) that uses the special sym-
bols ·[·]A in the input. Formally, let
</bodyText>
<listItem confidence="0.962031333333333">
• Q = Q0 U Q1 be finite where Q0 and Q1
are the set of states that do not and do have a
context parameter, respectively,
• E and A be ranked alphabets such that if
·[·]A E E, then A, A? E E,
• Q(U) be such that
</listItem>
<equation confidence="0.717617">
Q(U) = {q(u)  |q E Q1, u E U} U
U {q()  |q E Q0} ,
</equation>
<listItem confidence="0.877758">
• I C Q(TA), and
• R is a finite set of rules l —* r such that there
exists k &gt; 0 with l E Q({y})(CE(Xk)) and
r E Rhsk where
</listItem>
<equation confidence="0.996416">
Rhsk := δ(Rhsk, ... , Rhsk) |
 |q1(Rhsk)(x)  |q0()(x)
</equation>
<bodyText confidence="0.9955282">
with δ E Ak, q1 E Q1, q0 E Q0, and x E Xk.
Moreover, each variable of l (including y) is
supposed to occur exactly once in r.
We refer to Shieber (2006) for a full description
of embedded tree transducers. As seen from the
syntax, we write the context parameter y of a
state q E Q1 as q(y). If q E Q0, then we also
write q() or q(ε). In each right-hand side, such
a context parameter u can contain output symbols
and further calls to input subtrees. The semantics
of extended embedded tree transducers with sub-
stitution deviates slightly from the embedded tree
transducer semantics. Roughly speaking, not its
rules as such, but rather their evaluation are now
applied in a term-rewrite fashion. Let
</bodyText>
<equation confidence="0.970216">
SF&apos; := δ(SF&apos;, ... , SF&apos;) |
 |q1(SF&apos;)(t)  |q0()(t)
</equation>
<page confidence="0.982673">
1074
</page>
<bodyText confidence="0.652810444444444">
Figure 12: Rule and derivation step using the rule
in an extended embedded tree transducer with sub-
stitution where the context parameter (if present)
is displayed as first child.
where S E Ak, q1 E Q1, q0 E Q0, and t E TE.
Given �, ( E SF&apos;, we write � ==&gt;. ( if there exist
C E CA(X1), t1, ... , tk E TE, u E TAU{e}, and
a rule q(u)(l) —* r E R10 with l E CE(Xk) such
that
</bodyText>
<listItem confidence="0.641709">
• = C[q(u)(l[t1, ... , tk]E)] and
• ( = C[(r[t1, ... , tk])[u]y].
</listItem>
<bodyText confidence="0.998859916666667">
Note that the essential difference to the “stan-
dard” semantics of embedded tree transducers is
the evaluation in the first item. The tree transfor-
mation computed by M is defined as usual. We
illustrate a derivation step in Figure 12, where the
match •[•]S,,(x1, S(T(c)))E = S(S(T(c))) is suc-
cessful for x1 = S(S?).
Theorem 2 Every STAG can be simulated by an
extended embedded tree transducer with substi-
tution. Moreover, every extended embedded tree
transducer computes a tree transformation that
can be computed by a STAG up to a relabeling.
</bodyText>
<sectionHeader confidence="0.99934" genericHeader="conclusions">
8 Conclusions
</sectionHeader>
<bodyText confidence="0.996719">
We presented an alternative view on STAG us-
ing tree transducers (or equivalently, STSG). Our
main result shows that the syntactic characteri-
zation of STAG as STSG plus adjunction rules
also carries over to the semantic side. A STAG
tree transformation can also be computed by an
STSG using explicit substitution. In the light
of this result, some standard problems for STAG
can be reduced to the corresponding problems
for STSG. This allows us to re-use existing algo-
rithms for STSG also for STAG. Moreover, exist-
ing STAG algorithms can be related to the corre-
sponding STSG algorithms, which provides fur-
ther evidence of the close relationship between the
two models. We used this relationship to develop a
10Note that u is a if q E Q0.
BAR-HILLEL construction for STAG. Finally, we
hope that the alternative characterization is easier
to handle and might provide further insight into
general properties of STAG such as compositions
and preservation of regularity.
</bodyText>
<sectionHeader confidence="0.994004" genericHeader="acknowledgments">
Acknowledgements
</sectionHeader>
<bodyText confidence="0.988503666666667">
ANDREAS MALETTI was financially supported
by the Ministerio de Educaci´on y Ciencia (MEC)
grant JDCI-2007-760.
</bodyText>
<sectionHeader confidence="0.998133" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999652297297297">
Alfred V. Aho and Jeffrey D. Ullman. 1972. The The-
ory of Parsing, Translation, and Compiling. Pren-
tice Hall.
Andr´e Arnold and Max Dauchet. 1982. Morphismes
et bimorphismes d’arbres. Theoret. Comput. Sci.,
20(1):33–93.
Yehoshua Bar-Hillel, Micha Perles, and Eliyahu
Shamir. 1964. On formal properties of simple
phrase structure grammars. In Yehoshua Bar-Hillel,
editor, Language and Information: Selected Essays
on their Theory and Application, chapter 9, pages
116–150. Addison Wesley.
David Chiang. 2005. A hierarchical phrase-based
model for statistical machine translation. In Proc.
ACL, pages 263–270. Association for Computa-
tional Linguistics.
David Chiang. 2006. An introduction to synchronous
grammars. In Proc. ACL. Association for Computa-
tional Linguistics. Part of a tutorial given with Kevin
Knight.
Bruno Courcelle and Paul Franchi-Zannettacci. 1982.
Attribute grammars and recursive program schemes.
Theoret. Comput. Sci., 17:163–191, 235–257.
Joost Engelfriet and Heiko Vogler. 1985. Macro tree
transducers. J. Comput. System Sci., 31(1):71–146.
Ferenc G´ecseg and Magnus Steinby. 1984. Tree Au-
tomata. Akad´emiai Kiad´o, Budapest.
Ferenc G´ecseg and Magnus Steinby. 1997. Tree lan-
guages. In Handbook of Formal Languages, vol-
ume 3, chapter 1, pages 1–68. Springer.
Jonathan Graehl and Kevin Knight. 2004. Training
tree transducers. In HLT-NAACL, pages 105–112.
Association for Computational Linguistics. See
also (Graehl et al., 2008).
Jonathan Graehl, Kevin Knight, and Jonathan May.
2008. Training tree transducers. Computational
Linguistics, 34(3):391–427.
</reference>
<figure confidence="0.998933826086956">
c
qS()
.[.]S,,
x1 S
T
�
S
T
q(&apos;)
x1
c
qS()
S
S
T
�
T
q(&apos;)
S
S
S?
c
c
</figure>
<page confidence="0.94729">
1075
</page>
<reference confidence="0.999829893617021">
Jonathan Graehl, Mark Hopkins, Kevin Knight, and
Andreas Maletti. 2009. The power of extended top-
down tree transducers. SIAM Journal on Comput-
ing, 39(2):410–430.
Liang Huang and David Chiang. 2005. Better k-best
parsing. In Proc. IWPT, pages 53–64. Association
for Computational Linguistics.
Kevin Knight and Jonathan Graehl. 2005. An over-
view of probabilistic tree transducers for natural lan-
guage processing. In Proc. CICLing, volume 3406
of LNCS, pages 1–24. Springer.
Kevin Knight. 2007. Capturing practical natural
language transformations. Machine Translation,
21(2):121–133.
Andreas Maletti. 2008. Compositions of extended top-
down tree transducers. Inform. and Comput., 206(9–
10):1187–1196.
Jonathan May and Kevin Knight. 2006. TIBURON:
A weighted tree automata toolkit. In Proc. CIAA,
volume 4094 of LNCS, pages 102–113. Springer.
Mark-Jan Nederhof. 2009. Weighted parsing of trees.
In Proc. IWPT, pages 13–24. Association for Com-
putational Linguistics.
Rebecca Nesson, Giorgio Satta, and Stuart M. Shieber.
2008. Optimal k-arization of synchronous tree-
adjoining grammar. In Proc. ACL, pages 604–612.
Association for Computational Linguistics.
William C. Rounds. 1970. Mappings and grammars
on trees. Math. Systems Theory, 4(3):257–287.
Stuart M. Shieber and Yves Schabes. 1990. Syn-
chronous tree-adjoining grammars. In Proc. Com-
putational Linguistics, volume 3, pages 253–258.
Stuart M. Shieber. 2004. Synchronous grammars as
tree transducers. In Proc. TAG+7, pages 88–95.
Stuart M. Shieber. 2006. Unifying synchronous tree
adjoining grammars and tree transducers via bimor-
phisms. In Proc. EACL, pages 377–384. Association
for Computational Linguistics.
Stuart M. Shieber. 2007. Probabilistic synchronous
tree-adjoining grammars for machine translation:
The argument from bilingual dictionaries. In Proc.
Workshop on Syntax and Structure in Statistical
Translation, pages 88–95. Association for Compu-
tational Linguistics.
James W. Thatcher. 1970. Generalized sequential
machine maps. J. Comput. System Sci., 4(4):339–
367.
</reference>
<page confidence="0.995263">
1076
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.956430">
<title confidence="0.999986">A Tree Transducer Model for Synchronous Tree-Adjoining Grammars</title>
<author confidence="0.999903">Andreas Maletti</author>
<affiliation confidence="0.996684">Universitat Rovira i Virgili</affiliation>
<address confidence="0.988075">Avinguda de Catalunya 25, 43002 Tarragona, Spain.</address>
<email confidence="0.994742">andreas.maletti@urv.cat</email>
<abstract confidence="0.997701214285714">A characterization of the expressive power of synchronous tree-adjoining grammars (STAGs) in terms of tree transducers (or equivalently, synchronous tree substitution grammars) is developed. Essentially, a STAG corresponds to an extended tree transducer that uses explicit substitution in both the input and output. This characterization allows the easy integration of STAG into toolkits for extended tree transducers. Moreover, the applicability of the characterization to several representational and algorithmic problems is demonstrated.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Alfred V Aho</author>
<author>Jeffrey D Ullman</author>
</authors>
<date>1972</date>
<booktitle>The Theory of Parsing, Translation, and Compiling.</booktitle>
<publisher>Prentice Hall.</publisher>
<contexts>
<context position="959" citStr="Aho and Ullman, 1972" startWordPosition="130" endWordPosition="133">us tree substitution grammars) is developed. Essentially, a STAG corresponds to an extended tree transducer that uses explicit substitution in both the input and output. This characterization allows the easy integration of STAG into toolkits for extended tree transducers. Moreover, the applicability of the characterization to several representational and algorithmic problems is demonstrated. 1 Introduction Machine translation has seen a multitude of formal translation models. Here we focus on syntaxbased (or tree-based) models. One of the oldest models is the synchronous context-free grammar (Aho and Ullman, 1972). It is clearly too weak as a syntax-based model, but found use in the string-based setting. Top-down tree transducers (Rounds, 1970; Thatcher, 1970) have been heavily investigated in the formal language community (G´ecseg and Steinby, 1984; G´ecseg and Steinby, 1997), but as argued by Shieber (2004) they are still too weak for syntax-based machine translation. Instead Shieber (2004) proposes synchronous tree substitution grammars (STSGs) and develops an equivalent bimorphism (Arnold and Dauchet, 1982) characterization. This characterization eventually led to the rediscovery of extended tree t</context>
</contexts>
<marker>Aho, Ullman, 1972</marker>
<rawString>Alfred V. Aho and Jeffrey D. Ullman. 1972. The Theory of Parsing, Translation, and Compiling. Prentice Hall.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Andr´e Arnold</author>
<author>Max Dauchet</author>
</authors>
<title>Morphismes et bimorphismes d’arbres.</title>
<date>1982</date>
<journal>Theoret. Comput. Sci.,</journal>
<volume>20</volume>
<issue>1</issue>
<contexts>
<context position="1466" citStr="Arnold and Dauchet, 1982" startWordPosition="206" endWordPosition="209">xbased (or tree-based) models. One of the oldest models is the synchronous context-free grammar (Aho and Ullman, 1972). It is clearly too weak as a syntax-based model, but found use in the string-based setting. Top-down tree transducers (Rounds, 1970; Thatcher, 1970) have been heavily investigated in the formal language community (G´ecseg and Steinby, 1984; G´ecseg and Steinby, 1997), but as argued by Shieber (2004) they are still too weak for syntax-based machine translation. Instead Shieber (2004) proposes synchronous tree substitution grammars (STSGs) and develops an equivalent bimorphism (Arnold and Dauchet, 1982) characterization. This characterization eventually led to the rediscovery of extended tree transducers (Graehl and Knight, 2004; Knight and Graehl, 2005; Graehl et al., 2008), which are essentially as powerful as STSG. They had been studied already by Arnold and Dauchet (1982) in the form of bimorphisms, but received little attention until rediscovered. Shieber (2007) claims that even STSGs might be too simple to capture naturally occuring translation phenomena. Instead Shieber (2007) suggests a yet more powerful mechanism, synchronous tree-adjoining grammars (STAGs) as introduced by Shieber </context>
<context position="9321" citStr="Arnold and Dauchet (1982)" startWordPosition="1663" endWordPosition="1666">set of labels. Then we define the function ·E : TE —* TE U {L} by4 E E E σ(t1,...,tk) = σ(t1 ,...,tk) E 1 tE[uEI A if tE is A-proper [ ]A(t&apos; u) = for every k &gt; 0, σ E E, and t, t1, ... , tk, u E TE.5 We generally discard all trees that contain the error signal L. Since the devices that we will study later can also check the required A-properness using their state behavior, we generally do not discuss trees with error symbols explicitly. 4 Extended tree transducer An extended tree transducer is a theoretical model that computes a tree transformation. Such transducers have been studied first by Arnold and Dauchet (1982) in a purely theoretic setting, but were later applied in, for example, machine translation (Knight and Graehl, 2005; Knight, 2007; Graehl et al., 2008; Graehl et al., 2009). Their popularity in machine translation is due to Shieber (2004), in which it is shown that extended tree transducers are essentially (up to a relabeling) as expressive as synchronous tree substitution grammars (STSG). We refer to Chiang (2006) for an introduction to synchronous devices. Let us recall the formal definition. An extended tree transducer (for short: XTT)6 is a system M = (Q, E, A, I, R) where • Q is a finite</context>
<context position="13121" citStr="Arnold and Dauchet (1982)" startWordPosition="2427" endWordPosition="2430">e 3: Illustration of a derivation step of an XTT using the left rule of Figure 2. Given ξ, ζ E SF, we write ξ ==&gt;. ζ if there exist C E CA(X1), t1, ... , tk E TE, and a rule (q, l) (q1 • • • qk, r) E R such that • ξ = C[q(l[t1, ... , tk])] and • ζ = C[r[q1(t1),... ,qk(tk)]]. The tree transformation computed by M is the relation τM = {(t,u) E TE x TA I Iq E I : q(t) ==&gt;.* u} where ==�-* is the reflexive, transitive closure of ==�-. In other words, the tree t can be transformed into u if there exists an initial state q such that we can derive u from q(t) in several derivation steps. We refer to Arnold and Dauchet (1982), Graehl et al. (2008), and Graehl et al. (2009) for a more detailed exposition to XTT. 5 Synchronous tree-adjoining grammar XTT are a simple, natural model for tree transformations, however they are not suitably expressive for all applications in machine translation (Shieber, 2007). In particular, all tree transformations of XTT have a certain locality condition, which yields that the input tree and its corresponding translation cannot be separated by an unbounded distance. To overcome this problem and certain dependency problems, Shieber and Schabes (1990) and Shieber (2007) suggest a strong</context>
</contexts>
<marker>Arnold, Dauchet, 1982</marker>
<rawString>Andr´e Arnold and Max Dauchet. 1982. Morphismes et bimorphismes d’arbres. Theoret. Comput. Sci., 20(1):33–93.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Yehoshua Bar-Hillel</author>
<author>Micha Perles</author>
<author>Eliyahu Shamir</author>
</authors>
<title>On formal properties of simple phrase structure grammars.</title>
<date>1964</date>
<booktitle>In Yehoshua Bar-Hillel, editor, Language and Information: Selected Essays on their Theory and Application, chapter 9,</booktitle>
<pages>116--150</pages>
<publisher>Addison Wesley.</publisher>
<contexts>
<context position="25420" citStr="Bar-Hillel et al., 1964" startWordPosition="4605" endWordPosition="4608">vation algorithm does not consider a particular input or output tree. Since the derivations of the XTT match the derivations of the STAG (in the former the input and output are encoded using explicit substitution), the n-best derivations will coincide. If we are additionally interested in the input and output trees for those n-best derivations, then we can simply evaluate the coded input and output trees returned by n-best derivation algorithm. Finally, let us consider an algorithm that can be obtained for STAG by developing it for XTT using explicit substitution. We will develop a BARHILLEL (Bar-Hillel et al., 1964) construction for STAG. Thus, given a STAG G and a recognizable tree language L, we want to construct a STAG G&apos; such that TG&apos; = {(t, u) |(t, u) E TG, t E L} . In other words, we take the tree transformation TG but additionally require the input tree to be in L. Consequently, this operation is also called input restriction. Since STAG are symmetric, the corresponding output restriction can be obtained in the same manner. Note that a classical BAR-HILLEL construction restricting to a regular set of yields can be obtained easily as a particular input restriction. As in Nederhof (2009) a change of</context>
</contexts>
<marker>Bar-Hillel, Perles, Shamir, 1964</marker>
<rawString>Yehoshua Bar-Hillel, Micha Perles, and Eliyahu Shamir. 1964. On formal properties of simple phrase structure grammars. In Yehoshua Bar-Hillel, editor, Language and Information: Selected Essays on their Theory and Application, chapter 9, pages 116–150. Addison Wesley.</rawString>
</citation>
<citation valid="true">
<authors>
<author>David Chiang</author>
</authors>
<title>A hierarchical phrase-based model for statistical machine translation.</title>
<date>2005</date>
<booktitle>In Proc. ACL,</booktitle>
<pages>263--270</pages>
<publisher>Association</publisher>
<institution>for Computational Linguistics.</institution>
<contexts>
<context position="13850" citStr="Chiang, 2005" startWordPosition="2545" endWordPosition="2546"> grammar XTT are a simple, natural model for tree transformations, however they are not suitably expressive for all applications in machine translation (Shieber, 2007). In particular, all tree transformations of XTT have a certain locality condition, which yields that the input tree and its corresponding translation cannot be separated by an unbounded distance. To overcome this problem and certain dependency problems, Shieber and Schabes (1990) and Shieber (2007) suggest a stronger model called synchronous tree-adjoining grammar (STAG), which in addition to the substitution operation of STSG (Chiang, 2005) also has an adjoining operation. Let us recall the model in some detail. A treeadjoining grammar essentially is a regular tree grammar (G´ecseg and Steinby, 1984; G´ecseg and NP Figure 5: Illustration of the adjunction of Figure 4 using explicit substitution. Steinby, 1997) enhanced with an adjunction operation. Roughly speaking, an adjunction replaces a node (not necessarily a leaf) by an auxiliary tree, which has exactly one distinguished foot node. The original children of the replaced node will become the children of the foot node after adjunction. Traditionally, the root label and the la</context>
<context position="24771" citStr="Chiang, 2005" startWordPosition="4498" endWordPosition="4499">sa) with the help of our characterization. However, many standard algorithms for STAG can easily be derived from the corresponding algorithms for STSG. The simplest example is the union of two STAG. Instead of taking the union of two STAG using the classical construction, we can take the union of the corresponding XTT (or STSG) that simulate the STAGs. Their union will simulate the union of the STAGs. Such properties are especially valuable when we simulate STAG in toolkits for XTT. A second standard algorithm that easily translates is the algorithm computing the n-best derivations (Huang and Chiang, 2005). Clearly, the nbest derivation algorithm does not consider a particular input or output tree. Since the derivations of the XTT match the derivations of the STAG (in the former the input and output are encoded using explicit substitution), the n-best derivations will coincide. If we are additionally interested in the input and output trees for those n-best derivations, then we can simply evaluate the coded input and output trees returned by n-best derivation algorithm. Finally, let us consider an algorithm that can be obtained for STAG by developing it for XTT using explicit substitution. We w</context>
</contexts>
<marker>Chiang, 2005</marker>
<rawString>David Chiang. 2005. A hierarchical phrase-based model for statistical machine translation. In Proc. ACL, pages 263–270. Association for Computational Linguistics.</rawString>
</citation>
<citation valid="true">
<authors>
<author>David Chiang</author>
</authors>
<title>An introduction to synchronous grammars.</title>
<date>2006</date>
<booktitle>In Proc. ACL.</booktitle>
<publisher>Association</publisher>
<contexts>
<context position="9740" citStr="Chiang (2006)" startWordPosition="1733" endWordPosition="1734">plicitly. 4 Extended tree transducer An extended tree transducer is a theoretical model that computes a tree transformation. Such transducers have been studied first by Arnold and Dauchet (1982) in a purely theoretic setting, but were later applied in, for example, machine translation (Knight and Graehl, 2005; Knight, 2007; Graehl et al., 2008; Graehl et al., 2009). Their popularity in machine translation is due to Shieber (2004), in which it is shown that extended tree transducers are essentially (up to a relabeling) as expressive as synchronous tree substitution grammars (STSG). We refer to Chiang (2006) for an introduction to synchronous devices. Let us recall the formal definition. An extended tree transducer (for short: XTT)6 is a system M = (Q, E, A, I, R) where • Q is a finite set of states, • E and A are alphabets of input and output symbols, respectively, • I C Q is a set of initial states, and • R is a finite set of rules of the form (q, l) —* (q1 ··· qk, r) 4Formally, we should introduce an evaluation function for each alphabet E, but we assume that the alphabet can be infered. 5This evaluation is a special case of a yield-mapping (Engelfriet and Vogler, 1985). 6Using the notions of </context>
</contexts>
<marker>Chiang, 2006</marker>
<rawString>David Chiang. 2006. An introduction to synchronous grammars. In Proc. ACL. Association for Computational Linguistics. Part of a tutorial given with Kevin Knight.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Bruno Courcelle</author>
<author>Paul Franchi-Zannettacci</author>
</authors>
<title>Attribute grammars and recursive program schemes.</title>
<date>1982</date>
<journal>Theoret. Comput. Sci.,</journal>
<volume>17</volume>
<pages>235--257</pages>
<contexts>
<context position="2592" citStr="Courcelle and Franchi-Zannettacci, 1982" startWordPosition="371" endWordPosition="374">07) suggests a yet more powerful mechanism, synchronous tree-adjoining grammars (STAGs) as introduced by Shieber and Schabes (1990), that can capture certain (mildly) context-sensitive features of natural language. In the tradition of Shieber (2004), a characterization of the power of STAGs in terms of bimorphims was developed by Shieber (2006). The bimorphisms used are rather unconventional because they consist of a regular tree language and two embedded tree transducers (instead of two tree homomorphisms). Such embedded tree transducers (Shieber, 2006) are particular macro tree transducers (Courcelle and Franchi-Zannettacci, 1982; Engelfriet and Vogler, 1985). In this contribution, we try to unify the picture even further. We will develop a tree transducer model that can simulate STAGs. It turns out that the adjunction operation of an STAG can be explained easily by explicit substitution. In this sense, the slogan that an STAG is an STSG with adjunction, which refers to the syntax, also translates to the semantics. We prove that any tree transformation computed by an STAG can also be computed by an STSG using explicit substitution. Thus, a simple evaluation procedure that performs the explicit substitution is all that</context>
<context position="19976" citStr="Courcelle and Franchi-Zannettacci, 1982" startWordPosition="3695" endWordPosition="3699"> S T c c T S S1 a S T c S a S1 S T c c S a S b S a S1 a — S b S b a S a a S a S b S1 b — S a a S T c S S S S1 b a S b S a S T c c Figure 8: An incomplete derivation using the STAG of Figure 7. Let r C_ TE x TA be a tree transformation computed by a STAG. By Shieber (2006) there exists a regular tree language L C_ Tr and two functions e1: Tr —* TE and e2: Tr —* TA such that T = {(e1(t),e2(t)) I t E L}. Moreover, e1 and e2 can be computed by embedded tree transducers (Shieber, 2006), which are particular 1-state, deterministic, total, 1-parameter, linear, and nondeleting macro tree transducers (Courcelle and Franchi-Zannettacci, 1982; Engelfriet and Vogler, 1985). In fact, the converse is also true up to a relabeling, which is also shown in Shieber (2006). The outer part of Figure 9 illustrates these relations. Finally, we remark that all involved constructions are effective. Using a result of Engelfriet and Vogler (1985), each embedded tree transducer can be decomposed into a top-down tree transducer (G´ecseg and Steinby, 1984; G´ecseg and Steinby, 1997) and a yield-mapping. In our particular case, the top-down tree transducers are linear and nondeleting homomorphisms h1 and h2. Linearity and nondeletion are inherited fr</context>
</contexts>
<marker>Courcelle, Franchi-Zannettacci, 1982</marker>
<rawString>Bruno Courcelle and Paul Franchi-Zannettacci. 1982. Attribute grammars and recursive program schemes. Theoret. Comput. Sci., 17:163–191, 235–257.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Joost Engelfriet</author>
<author>Heiko Vogler</author>
</authors>
<title>Macro tree transducers.</title>
<date>1985</date>
<journal>J. Comput. System Sci.,</journal>
<volume>31</volume>
<issue>1</issue>
<contexts>
<context position="2622" citStr="Engelfriet and Vogler, 1985" startWordPosition="375" endWordPosition="378">m, synchronous tree-adjoining grammars (STAGs) as introduced by Shieber and Schabes (1990), that can capture certain (mildly) context-sensitive features of natural language. In the tradition of Shieber (2004), a characterization of the power of STAGs in terms of bimorphims was developed by Shieber (2006). The bimorphisms used are rather unconventional because they consist of a regular tree language and two embedded tree transducers (instead of two tree homomorphisms). Such embedded tree transducers (Shieber, 2006) are particular macro tree transducers (Courcelle and Franchi-Zannettacci, 1982; Engelfriet and Vogler, 1985). In this contribution, we try to unify the picture even further. We will develop a tree transducer model that can simulate STAGs. It turns out that the adjunction operation of an STAG can be explained easily by explicit substitution. In this sense, the slogan that an STAG is an STSG with adjunction, which refers to the syntax, also translates to the semantics. We prove that any tree transformation computed by an STAG can also be computed by an STSG using explicit substitution. Thus, a simple evaluation procedure that performs the explicit substitution is all that is needed to simulate an STAG</context>
<context position="10316" citStr="Engelfriet and Vogler, 1985" startWordPosition="1846" endWordPosition="1850">stitution grammars (STSG). We refer to Chiang (2006) for an introduction to synchronous devices. Let us recall the formal definition. An extended tree transducer (for short: XTT)6 is a system M = (Q, E, A, I, R) where • Q is a finite set of states, • E and A are alphabets of input and output symbols, respectively, • I C Q is a set of initial states, and • R is a finite set of rules of the form (q, l) —* (q1 ··· qk, r) 4Formally, we should introduce an evaluation function for each alphabet E, but we assume that the alphabet can be infered. 5This evaluation is a special case of a yield-mapping (Engelfriet and Vogler, 1985). 6Using the notions of Graehl et al. (2009) our extended tree transducers are linear, nondeleting extended top-down tree transducers. Figure 2: Example rules taken from Graehl et al. (2009). The term representation of the first rule is (qS, S(x1, VP(x2, x3))) —* (w, S&apos;(x2, x1, x3)) where w = qNPqVqNP. where k &gt; 0, l E CE(Xk), and r E CA(Xk). Recall that any tree of CE(Xk) contains each variable of Xk = {x1, ... , xk} exactly once. In graphical representations of a rule (q, l) —* (q1 ··· qk, r) E R , we usually • add the state q as root node of the left-hand side7, and • add the states q1, ...</context>
<context position="20006" citStr="Engelfriet and Vogler, 1985" startWordPosition="3700" endWordPosition="3703">a S b S a S1 a — S b S b a S a a S a S b S1 b — S a a S T c S S S S1 b a S b S a S T c c Figure 8: An incomplete derivation using the STAG of Figure 7. Let r C_ TE x TA be a tree transformation computed by a STAG. By Shieber (2006) there exists a regular tree language L C_ Tr and two functions e1: Tr —* TE and e2: Tr —* TA such that T = {(e1(t),e2(t)) I t E L}. Moreover, e1 and e2 can be computed by embedded tree transducers (Shieber, 2006), which are particular 1-state, deterministic, total, 1-parameter, linear, and nondeleting macro tree transducers (Courcelle and Franchi-Zannettacci, 1982; Engelfriet and Vogler, 1985). In fact, the converse is also true up to a relabeling, which is also shown in Shieber (2006). The outer part of Figure 9 illustrates these relations. Finally, we remark that all involved constructions are effective. Using a result of Engelfriet and Vogler (1985), each embedded tree transducer can be decomposed into a top-down tree transducer (G´ecseg and Steinby, 1984; G´ecseg and Steinby, 1997) and a yield-mapping. In our particular case, the top-down tree transducers are linear and nondeleting homomorphisms h1 and h2. Linearity and nondeletion are inherited from the corresponding propertie</context>
</contexts>
<marker>Engelfriet, Vogler, 1985</marker>
<rawString>Joost Engelfriet and Heiko Vogler. 1985. Macro tree transducers. J. Comput. System Sci., 31(1):71–146.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ferenc G´ecseg</author>
<author>Magnus Steinby</author>
</authors>
<title>Tree Automata. Akad´emiai Kiad´o,</title>
<date>1984</date>
<location>Budapest.</location>
<marker>G´ecseg, Steinby, 1984</marker>
<rawString>Ferenc G´ecseg and Magnus Steinby. 1984. Tree Automata. Akad´emiai Kiad´o, Budapest.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ferenc G´ecseg</author>
<author>Magnus Steinby</author>
</authors>
<title>Tree languages.</title>
<date>1997</date>
<booktitle>In Handbook of Formal Languages,</booktitle>
<volume>3</volume>
<pages>1--68</pages>
<publisher>Springer.</publisher>
<marker>G´ecseg, Steinby, 1997</marker>
<rawString>Ferenc G´ecseg and Magnus Steinby. 1997. Tree languages. In Handbook of Formal Languages, volume 3, chapter 1, pages 1–68. Springer.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jonathan Graehl</author>
<author>Kevin Knight</author>
</authors>
<title>Training tree transducers.</title>
<date>2004</date>
<booktitle>In HLT-NAACL,</booktitle>
<pages>105--112</pages>
<publisher>Association</publisher>
<contexts>
<context position="1594" citStr="Graehl and Knight, 2004" startWordPosition="224" endWordPosition="227">rly too weak as a syntax-based model, but found use in the string-based setting. Top-down tree transducers (Rounds, 1970; Thatcher, 1970) have been heavily investigated in the formal language community (G´ecseg and Steinby, 1984; G´ecseg and Steinby, 1997), but as argued by Shieber (2004) they are still too weak for syntax-based machine translation. Instead Shieber (2004) proposes synchronous tree substitution grammars (STSGs) and develops an equivalent bimorphism (Arnold and Dauchet, 1982) characterization. This characterization eventually led to the rediscovery of extended tree transducers (Graehl and Knight, 2004; Knight and Graehl, 2005; Graehl et al., 2008), which are essentially as powerful as STSG. They had been studied already by Arnold and Dauchet (1982) in the form of bimorphisms, but received little attention until rediscovered. Shieber (2007) claims that even STSGs might be too simple to capture naturally occuring translation phenomena. Instead Shieber (2007) suggests a yet more powerful mechanism, synchronous tree-adjoining grammars (STAGs) as introduced by Shieber and Schabes (1990), that can capture certain (mildly) context-sensitive features of natural language. In the tradition of Shiebe</context>
</contexts>
<marker>Graehl, Knight, 2004</marker>
<rawString>Jonathan Graehl and Kevin Knight. 2004. Training tree transducers. In HLT-NAACL, pages 105–112. Association for Computational Linguistics. See also (Graehl et al., 2008).</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jonathan Graehl</author>
<author>Kevin Knight</author>
<author>Jonathan May</author>
</authors>
<title>Training tree transducers.</title>
<date>2008</date>
<journal>Computational Linguistics,</journal>
<volume>34</volume>
<issue>3</issue>
<contexts>
<context position="1641" citStr="Graehl et al., 2008" startWordPosition="232" endWordPosition="235">e in the string-based setting. Top-down tree transducers (Rounds, 1970; Thatcher, 1970) have been heavily investigated in the formal language community (G´ecseg and Steinby, 1984; G´ecseg and Steinby, 1997), but as argued by Shieber (2004) they are still too weak for syntax-based machine translation. Instead Shieber (2004) proposes synchronous tree substitution grammars (STSGs) and develops an equivalent bimorphism (Arnold and Dauchet, 1982) characterization. This characterization eventually led to the rediscovery of extended tree transducers (Graehl and Knight, 2004; Knight and Graehl, 2005; Graehl et al., 2008), which are essentially as powerful as STSG. They had been studied already by Arnold and Dauchet (1982) in the form of bimorphisms, but received little attention until rediscovered. Shieber (2007) claims that even STSGs might be too simple to capture naturally occuring translation phenomena. Instead Shieber (2007) suggests a yet more powerful mechanism, synchronous tree-adjoining grammars (STAGs) as introduced by Shieber and Schabes (1990), that can capture certain (mildly) context-sensitive features of natural language. In the tradition of Shieber (2004), a characterization of the power of ST</context>
<context position="9472" citStr="Graehl et al., 2008" startWordPosition="1688" endWordPosition="1691"> &gt; 0, σ E E, and t, t1, ... , tk, u E TE.5 We generally discard all trees that contain the error signal L. Since the devices that we will study later can also check the required A-properness using their state behavior, we generally do not discuss trees with error symbols explicitly. 4 Extended tree transducer An extended tree transducer is a theoretical model that computes a tree transformation. Such transducers have been studied first by Arnold and Dauchet (1982) in a purely theoretic setting, but were later applied in, for example, machine translation (Knight and Graehl, 2005; Knight, 2007; Graehl et al., 2008; Graehl et al., 2009). Their popularity in machine translation is due to Shieber (2004), in which it is shown that extended tree transducers are essentially (up to a relabeling) as expressive as synchronous tree substitution grammars (STSG). We refer to Chiang (2006) for an introduction to synchronous devices. Let us recall the formal definition. An extended tree transducer (for short: XTT)6 is a system M = (Q, E, A, I, R) where • Q is a finite set of states, • E and A are alphabets of input and output symbols, respectively, • I C Q is a set of initial states, and • R is a finite set of rules</context>
<context position="13143" citStr="Graehl et al. (2008)" startWordPosition="2431" endWordPosition="2434">vation step of an XTT using the left rule of Figure 2. Given ξ, ζ E SF, we write ξ ==&gt;. ζ if there exist C E CA(X1), t1, ... , tk E TE, and a rule (q, l) (q1 • • • qk, r) E R such that • ξ = C[q(l[t1, ... , tk])] and • ζ = C[r[q1(t1),... ,qk(tk)]]. The tree transformation computed by M is the relation τM = {(t,u) E TE x TA I Iq E I : q(t) ==&gt;.* u} where ==�-* is the reflexive, transitive closure of ==�-. In other words, the tree t can be transformed into u if there exists an initial state q such that we can derive u from q(t) in several derivation steps. We refer to Arnold and Dauchet (1982), Graehl et al. (2008), and Graehl et al. (2009) for a more detailed exposition to XTT. 5 Synchronous tree-adjoining grammar XTT are a simple, natural model for tree transformations, however they are not suitably expressive for all applications in machine translation (Shieber, 2007). In particular, all tree transformations of XTT have a certain locality condition, which yields that the input tree and its corresponding translation cannot be separated by an unbounded distance. To overcome this problem and certain dependency problems, Shieber and Schabes (1990) and Shieber (2007) suggest a stronger model called synchr</context>
</contexts>
<marker>Graehl, Knight, May, 2008</marker>
<rawString>Jonathan Graehl, Kevin Knight, and Jonathan May. 2008. Training tree transducers. Computational Linguistics, 34(3):391–427.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jonathan Graehl</author>
<author>Mark Hopkins</author>
<author>Kevin Knight</author>
<author>Andreas Maletti</author>
</authors>
<title>The power of extended topdown tree transducers.</title>
<date>2009</date>
<journal>SIAM Journal on Computing,</journal>
<volume>39</volume>
<issue>2</issue>
<contexts>
<context position="9494" citStr="Graehl et al., 2009" startWordPosition="1692" endWordPosition="1695">1, ... , tk, u E TE.5 We generally discard all trees that contain the error signal L. Since the devices that we will study later can also check the required A-properness using their state behavior, we generally do not discuss trees with error symbols explicitly. 4 Extended tree transducer An extended tree transducer is a theoretical model that computes a tree transformation. Such transducers have been studied first by Arnold and Dauchet (1982) in a purely theoretic setting, but were later applied in, for example, machine translation (Knight and Graehl, 2005; Knight, 2007; Graehl et al., 2008; Graehl et al., 2009). Their popularity in machine translation is due to Shieber (2004), in which it is shown that extended tree transducers are essentially (up to a relabeling) as expressive as synchronous tree substitution grammars (STSG). We refer to Chiang (2006) for an introduction to synchronous devices. Let us recall the formal definition. An extended tree transducer (for short: XTT)6 is a system M = (Q, E, A, I, R) where • Q is a finite set of states, • E and A are alphabets of input and output symbols, respectively, • I C Q is a set of initial states, and • R is a finite set of rules of the form (q, l) —*</context>
<context position="13169" citStr="Graehl et al. (2009)" startWordPosition="2436" endWordPosition="2439">g the left rule of Figure 2. Given ξ, ζ E SF, we write ξ ==&gt;. ζ if there exist C E CA(X1), t1, ... , tk E TE, and a rule (q, l) (q1 • • • qk, r) E R such that • ξ = C[q(l[t1, ... , tk])] and • ζ = C[r[q1(t1),... ,qk(tk)]]. The tree transformation computed by M is the relation τM = {(t,u) E TE x TA I Iq E I : q(t) ==&gt;.* u} where ==�-* is the reflexive, transitive closure of ==�-. In other words, the tree t can be transformed into u if there exists an initial state q such that we can derive u from q(t) in several derivation steps. We refer to Arnold and Dauchet (1982), Graehl et al. (2008), and Graehl et al. (2009) for a more detailed exposition to XTT. 5 Synchronous tree-adjoining grammar XTT are a simple, natural model for tree transformations, however they are not suitably expressive for all applications in machine translation (Shieber, 2007). In particular, all tree transformations of XTT have a certain locality condition, which yields that the input tree and its corresponding translation cannot be separated by an unbounded distance. To overcome this problem and certain dependency problems, Shieber and Schabes (1990) and Shieber (2007) suggest a stronger model called synchronous tree-adjoining gramm</context>
</contexts>
<marker>Graehl, Hopkins, Knight, Maletti, 2009</marker>
<rawString>Jonathan Graehl, Mark Hopkins, Kevin Knight, and Andreas Maletti. 2009. The power of extended topdown tree transducers. SIAM Journal on Computing, 39(2):410–430.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Liang Huang</author>
<author>David Chiang</author>
</authors>
<title>Better k-best parsing.</title>
<date>2005</date>
<booktitle>In Proc. IWPT,</booktitle>
<pages>53--64</pages>
<publisher>Association</publisher>
<institution>for Computational Linguistics.</institution>
<contexts>
<context position="24771" citStr="Huang and Chiang, 2005" startWordPosition="4496" endWordPosition="4499">r vice versa) with the help of our characterization. However, many standard algorithms for STAG can easily be derived from the corresponding algorithms for STSG. The simplest example is the union of two STAG. Instead of taking the union of two STAG using the classical construction, we can take the union of the corresponding XTT (or STSG) that simulate the STAGs. Their union will simulate the union of the STAGs. Such properties are especially valuable when we simulate STAG in toolkits for XTT. A second standard algorithm that easily translates is the algorithm computing the n-best derivations (Huang and Chiang, 2005). Clearly, the nbest derivation algorithm does not consider a particular input or output tree. Since the derivations of the XTT match the derivations of the STAG (in the former the input and output are encoded using explicit substitution), the n-best derivations will coincide. If we are additionally interested in the input and output trees for those n-best derivations, then we can simply evaluate the coded input and output trees returned by n-best derivation algorithm. Finally, let us consider an algorithm that can be obtained for STAG by developing it for XTT using explicit substitution. We w</context>
</contexts>
<marker>Huang, Chiang, 2005</marker>
<rawString>Liang Huang and David Chiang. 2005. Better k-best parsing. In Proc. IWPT, pages 53–64. Association for Computational Linguistics.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kevin Knight</author>
<author>Jonathan Graehl</author>
</authors>
<title>An overview of probabilistic tree transducers for natural language processing.</title>
<date>2005</date>
<booktitle>In Proc. CICLing,</booktitle>
<volume>3406</volume>
<pages>1--24</pages>
<publisher>Springer.</publisher>
<contexts>
<context position="1619" citStr="Knight and Graehl, 2005" startWordPosition="228" endWordPosition="231">based model, but found use in the string-based setting. Top-down tree transducers (Rounds, 1970; Thatcher, 1970) have been heavily investigated in the formal language community (G´ecseg and Steinby, 1984; G´ecseg and Steinby, 1997), but as argued by Shieber (2004) they are still too weak for syntax-based machine translation. Instead Shieber (2004) proposes synchronous tree substitution grammars (STSGs) and develops an equivalent bimorphism (Arnold and Dauchet, 1982) characterization. This characterization eventually led to the rediscovery of extended tree transducers (Graehl and Knight, 2004; Knight and Graehl, 2005; Graehl et al., 2008), which are essentially as powerful as STSG. They had been studied already by Arnold and Dauchet (1982) in the form of bimorphisms, but received little attention until rediscovered. Shieber (2007) claims that even STSGs might be too simple to capture naturally occuring translation phenomena. Instead Shieber (2007) suggests a yet more powerful mechanism, synchronous tree-adjoining grammars (STAGs) as introduced by Shieber and Schabes (1990), that can capture certain (mildly) context-sensitive features of natural language. In the tradition of Shieber (2004), a characterizat</context>
<context position="9437" citStr="Knight and Graehl, 2005" startWordPosition="1682" endWordPosition="1685">tE is A-proper [ ]A(t&apos; u) = for every k &gt; 0, σ E E, and t, t1, ... , tk, u E TE.5 We generally discard all trees that contain the error signal L. Since the devices that we will study later can also check the required A-properness using their state behavior, we generally do not discuss trees with error symbols explicitly. 4 Extended tree transducer An extended tree transducer is a theoretical model that computes a tree transformation. Such transducers have been studied first by Arnold and Dauchet (1982) in a purely theoretic setting, but were later applied in, for example, machine translation (Knight and Graehl, 2005; Knight, 2007; Graehl et al., 2008; Graehl et al., 2009). Their popularity in machine translation is due to Shieber (2004), in which it is shown that extended tree transducers are essentially (up to a relabeling) as expressive as synchronous tree substitution grammars (STSG). We refer to Chiang (2006) for an introduction to synchronous devices. Let us recall the formal definition. An extended tree transducer (for short: XTT)6 is a system M = (Q, E, A, I, R) where • Q is a finite set of states, • E and A are alphabets of input and output symbols, respectively, • I C Q is a set of initial state</context>
</contexts>
<marker>Knight, Graehl, 2005</marker>
<rawString>Kevin Knight and Jonathan Graehl. 2005. An overview of probabilistic tree transducers for natural language processing. In Proc. CICLing, volume 3406 of LNCS, pages 1–24. Springer.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kevin Knight</author>
</authors>
<title>Capturing practical natural language transformations.</title>
<date>2007</date>
<journal>Machine Translation,</journal>
<volume>21</volume>
<issue>2</issue>
<contexts>
<context position="9451" citStr="Knight, 2007" startWordPosition="1686" endWordPosition="1687"> = for every k &gt; 0, σ E E, and t, t1, ... , tk, u E TE.5 We generally discard all trees that contain the error signal L. Since the devices that we will study later can also check the required A-properness using their state behavior, we generally do not discuss trees with error symbols explicitly. 4 Extended tree transducer An extended tree transducer is a theoretical model that computes a tree transformation. Such transducers have been studied first by Arnold and Dauchet (1982) in a purely theoretic setting, but were later applied in, for example, machine translation (Knight and Graehl, 2005; Knight, 2007; Graehl et al., 2008; Graehl et al., 2009). Their popularity in machine translation is due to Shieber (2004), in which it is shown that extended tree transducers are essentially (up to a relabeling) as expressive as synchronous tree substitution grammars (STSG). We refer to Chiang (2006) for an introduction to synchronous devices. Let us recall the formal definition. An extended tree transducer (for short: XTT)6 is a system M = (Q, E, A, I, R) where • Q is a finite set of states, • E and A are alphabets of input and output symbols, respectively, • I C Q is a set of initial states, and • R is </context>
</contexts>
<marker>Knight, 2007</marker>
<rawString>Kevin Knight. 2007. Capturing practical natural language transformations. Machine Translation, 21(2):121–133.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Andreas Maletti</author>
</authors>
<title>Compositions of extended topdown tree transducers. Inform. and Comput.,</title>
<date>2008</date>
<pages>10--1187</pages>
<contexts>
<context position="21317" citStr="Maletti (2008)" startWordPosition="3909" endWordPosition="3910">ro tree transducer ensure that the obtained topdown tree transducer is also 1-state, deterministic, and total, which means that it is a homomorphism. Finally, the 1-parameter property yields that the used substitution symbols are binary (as our substitution symbols ·[·]A). Consequently, the yield-mapping actually coincides with our evaluation. Again, this decomposition actually is a characterization of embedded tree transducers. Now the set I(h1(t), h2(t)) I t E L} can be computed Figure 9: Illustration of the proof sketch. by an extended tree transducer M due to results of Shieber (2004) and Maletti (2008). More precisely, every extended tree transducer computes such a set, so that also this step is a characterization. Thus we obtain that T is an evaluation of a tree transformation computed by an extended tree transducer, and moreover, for each extended tree transducer, the evaluation can be computed (up to a relabeling) by a STAG. The overall proof structure is illustrated in Figure 9. 6.2 Example Let us illustrate one direction (the construction of the extended tree transducer) on our example STAG of Figure 7. Essentially, we just prepare all operable nodes by inserting an explicit substituti</context>
</contexts>
<marker>Maletti, 2008</marker>
<rawString>Andreas Maletti. 2008. Compositions of extended topdown tree transducers. Inform. and Comput., 206(9– 10):1187–1196.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jonathan May</author>
<author>Kevin Knight</author>
</authors>
<title>TIBURON: A weighted tree automata toolkit.</title>
<date>2006</date>
<booktitle>In Proc. CIAA,</booktitle>
<volume>4094</volume>
<pages>102--113</pages>
<publisher>Springer.</publisher>
<contexts>
<context position="3312" citStr="May and Knight (2006)" startWordPosition="496" endWordPosition="499">will develop a tree transducer model that can simulate STAGs. It turns out that the adjunction operation of an STAG can be explained easily by explicit substitution. In this sense, the slogan that an STAG is an STSG with adjunction, which refers to the syntax, also translates to the semantics. We prove that any tree transformation computed by an STAG can also be computed by an STSG using explicit substitution. Thus, a simple evaluation procedure that performs the explicit substitution is all that is needed to simulate an STAG in a toolkit for STSGs or extended tree transducers like TIBURON by May and Knight (2006). We show that some standard algorithms on STAG can actually be run on the constructed STSG, which often is simpler and better understood. Further, it might be easier to develop new algorithms with the alternative characterization, which we demonstrate with a product construction for input restriction in the spirit of Nederhof (2009). Finally, we also present a complete tree transducer model that is as powerful as STAG, which is an extension of the embedded tree transducers of Shieber (2006). 1067 Proceedings of the 48th Annual Meeting of the Association for Computational Linguistics, pages 10</context>
<context position="23242" citStr="May and Knight (2006)" startWordPosition="4244" endWordPosition="4247">rees of Figure 11 yields the corresponding derived trees of Figure 8. 7 Applications In this section, we will discuss a few applications of our main result. Those range from representational issues to algorithmic problems. Finally, we also present a tree transducer model that includes explicit substitution. Such a model might help to address algorithmic problems because derivation and evaluation are intertwined in the model and not separate as in our main result. 7.1 Toolkits Obviously, our characterization can be applied in a toolkit for extended tree transducers (or STSG) such as TIBURON by May and Knight (2006) to simulate STAG. The existing infrastructure (inputoutput, derivation mechanism, etc) for extended tree transducers can be re-used to run XTTs encoding STAGs. The only additional overhead is the implementation of the evaluation, which is a straightforward recursive function (as defined in Section 3). After that any STAG can be simulated in the existing framework, which allows experiments with STAG and an evaluation of their expressive power without the need to develop a new toolkit. It should be remarked that some essential algorithms that are very sensitive to the input and output behavior </context>
</contexts>
<marker>May, Knight, 2006</marker>
<rawString>Jonathan May and Kevin Knight. 2006. TIBURON: A weighted tree automata toolkit. In Proc. CIAA, volume 4094 of LNCS, pages 102–113. Springer.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Mark-Jan Nederhof</author>
</authors>
<title>Weighted parsing of trees.</title>
<date>2009</date>
<booktitle>In Proc. IWPT,</booktitle>
<pages>13--24</pages>
<publisher>Association</publisher>
<institution>for Computational Linguistics.</institution>
<contexts>
<context position="3647" citStr="Nederhof (2009)" startWordPosition="552" endWordPosition="554"> by an STAG can also be computed by an STSG using explicit substitution. Thus, a simple evaluation procedure that performs the explicit substitution is all that is needed to simulate an STAG in a toolkit for STSGs or extended tree transducers like TIBURON by May and Knight (2006). We show that some standard algorithms on STAG can actually be run on the constructed STSG, which often is simpler and better understood. Further, it might be easier to develop new algorithms with the alternative characterization, which we demonstrate with a product construction for input restriction in the spirit of Nederhof (2009). Finally, we also present a complete tree transducer model that is as powerful as STAG, which is an extension of the embedded tree transducers of Shieber (2006). 1067 Proceedings of the 48th Annual Meeting of the Association for Computational Linguistics, pages 1067–1076, Uppsala, Sweden, 11-16 July 2010. c�2010 Association for Computational Linguistics 2 Notation We quickly recall some central notions about trees, tree languages, and tree transformations. For a more in-depth discussion we refer to G´ecseg and Steinby (1984) and G´ecseg and Steinby (1997). A finite set E of labels is an alpha</context>
<context position="26008" citStr="Nederhof (2009)" startWordPosition="4712" endWordPosition="4713">L (Bar-Hillel et al., 1964) construction for STAG. Thus, given a STAG G and a recognizable tree language L, we want to construct a STAG G&apos; such that TG&apos; = {(t, u) |(t, u) E TG, t E L} . In other words, we take the tree transformation TG but additionally require the input tree to be in L. Consequently, this operation is also called input restriction. Since STAG are symmetric, the corresponding output restriction can be obtained in the same manner. Note that a classical BAR-HILLEL construction restricting to a regular set of yields can be obtained easily as a particular input restriction. As in Nederhof (2009) a change of model is beneficial for the development of such an algorithm, so we will develop an input restriction for XTT using explicit substitution. Let M = (Q, E, A, I, R) be an XTT (using explicit substitution) and G = (N, E, I&apos;, P) be a tree substitution grammar (regular tree grammar) in normal form that recognizes L (i.e., L(G) = L). Let S = {A E E |·[·]A E E}. A context is a mapping c: S —* N, which remembers a nonterminal of G for each substitution point. Given a rule 4S ·[·]S� x1 S T c ·[·]S� S x1 T c 4S S ·[·]S� x1 S a S� a S a ·[·]S� 4S x1 � � 4S S S� a 1073 Figure 11: Complete der</context>
</contexts>
<marker>Nederhof, 2009</marker>
<rawString>Mark-Jan Nederhof. 2009. Weighted parsing of trees. In Proc. IWPT, pages 13–24. Association for Computational Linguistics.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Rebecca Nesson</author>
<author>Giorgio Satta</author>
<author>Stuart M Shieber</author>
</authors>
<title>Optimal k-arization of synchronous treeadjoining grammar.</title>
<date>2008</date>
<booktitle>In Proc. ACL,</booktitle>
<pages>604--612</pages>
<publisher>Association</publisher>
<institution>for Computational Linguistics.</institution>
<contexts>
<context position="12367" citStr="Nesson et al. (2008)" startWordPosition="2256" endWordPosition="2259">nd side r by the matched input subtrees q1(t1), ... , qk(tk) headed by the corresponding state, respectively, and • replacing the selected leaf in ξ by the tree constructed in the previous item. The process is illustrated in Figure 3. Formally, a sentential form of the XTT M is a tree of SF = TA(Q(TE)) where Q(TE) = {q(t) |q E Q,t E TE} . 7States are thus also special symbols that are exclusively used as unary symbols. S’ —* —* qNP qV NP N atefl x2 N boy the qS S x1 VP x2 x3 qNP NP DT qNP x1 x3 L otherwise 1069 NP NP DT les bonbons adjunction Figure 4: Illustration of an adjunction taken from Nesson et al. (2008). derived tree N bonbons DT les N N ADJ rouges � C S’ qNP VP qV qNP t1 t2 t1 t3 t2 t3 qS S C N N* ADJ rouges auxiliary tree Figure 3: Illustration of a derivation step of an XTT using the left rule of Figure 2. Given ξ, ζ E SF, we write ξ ==&gt;. ζ if there exist C E CA(X1), t1, ... , tk E TE, and a rule (q, l) (q1 • • • qk, r) E R such that • ξ = C[q(l[t1, ... , tk])] and • ζ = C[r[q1(t1),... ,qk(tk)]]. The tree transformation computed by M is the relation τM = {(t,u) E TE x TA I Iq E I : q(t) ==&gt;.* u} where ==�-* is the reflexive, transitive closure of ==�-. In other words, the tree t can be tr</context>
</contexts>
<marker>Nesson, Satta, Shieber, 2008</marker>
<rawString>Rebecca Nesson, Giorgio Satta, and Stuart M. Shieber. 2008. Optimal k-arization of synchronous treeadjoining grammar. In Proc. ACL, pages 604–612. Association for Computational Linguistics.</rawString>
</citation>
<citation valid="true">
<authors>
<author>William C Rounds</author>
</authors>
<title>Mappings and grammars on trees.</title>
<date>1970</date>
<booktitle>Math. Systems Theory,</booktitle>
<pages>4--3</pages>
<contexts>
<context position="1091" citStr="Rounds, 1970" startWordPosition="154" endWordPosition="155">n both the input and output. This characterization allows the easy integration of STAG into toolkits for extended tree transducers. Moreover, the applicability of the characterization to several representational and algorithmic problems is demonstrated. 1 Introduction Machine translation has seen a multitude of formal translation models. Here we focus on syntaxbased (or tree-based) models. One of the oldest models is the synchronous context-free grammar (Aho and Ullman, 1972). It is clearly too weak as a syntax-based model, but found use in the string-based setting. Top-down tree transducers (Rounds, 1970; Thatcher, 1970) have been heavily investigated in the formal language community (G´ecseg and Steinby, 1984; G´ecseg and Steinby, 1997), but as argued by Shieber (2004) they are still too weak for syntax-based machine translation. Instead Shieber (2004) proposes synchronous tree substitution grammars (STSGs) and develops an equivalent bimorphism (Arnold and Dauchet, 1982) characterization. This characterization eventually led to the rediscovery of extended tree transducers (Graehl and Knight, 2004; Knight and Graehl, 2005; Graehl et al., 2008), which are essentially as powerful as STSG. They </context>
</contexts>
<marker>Rounds, 1970</marker>
<rawString>William C. Rounds. 1970. Mappings and grammars on trees. Math. Systems Theory, 4(3):257–287.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Stuart M Shieber</author>
<author>Yves Schabes</author>
</authors>
<title>Synchronous tree-adjoining grammars.</title>
<date>1990</date>
<booktitle>In Proc. Computational Linguistics,</booktitle>
<volume>3</volume>
<pages>253--258</pages>
<contexts>
<context position="2084" citStr="Shieber and Schabes (1990)" startWordPosition="297" endWordPosition="300">t, 1982) characterization. This characterization eventually led to the rediscovery of extended tree transducers (Graehl and Knight, 2004; Knight and Graehl, 2005; Graehl et al., 2008), which are essentially as powerful as STSG. They had been studied already by Arnold and Dauchet (1982) in the form of bimorphisms, but received little attention until rediscovered. Shieber (2007) claims that even STSGs might be too simple to capture naturally occuring translation phenomena. Instead Shieber (2007) suggests a yet more powerful mechanism, synchronous tree-adjoining grammars (STAGs) as introduced by Shieber and Schabes (1990), that can capture certain (mildly) context-sensitive features of natural language. In the tradition of Shieber (2004), a characterization of the power of STAGs in terms of bimorphims was developed by Shieber (2006). The bimorphisms used are rather unconventional because they consist of a regular tree language and two embedded tree transducers (instead of two tree homomorphisms). Such embedded tree transducers (Shieber, 2006) are particular macro tree transducers (Courcelle and Franchi-Zannettacci, 1982; Engelfriet and Vogler, 1985). In this contribution, we try to unify the picture even furth</context>
<context position="13685" citStr="Shieber and Schabes (1990)" startWordPosition="2518" endWordPosition="2522">everal derivation steps. We refer to Arnold and Dauchet (1982), Graehl et al. (2008), and Graehl et al. (2009) for a more detailed exposition to XTT. 5 Synchronous tree-adjoining grammar XTT are a simple, natural model for tree transformations, however they are not suitably expressive for all applications in machine translation (Shieber, 2007). In particular, all tree transformations of XTT have a certain locality condition, which yields that the input tree and its corresponding translation cannot be separated by an unbounded distance. To overcome this problem and certain dependency problems, Shieber and Schabes (1990) and Shieber (2007) suggest a stronger model called synchronous tree-adjoining grammar (STAG), which in addition to the substitution operation of STSG (Chiang, 2005) also has an adjoining operation. Let us recall the model in some detail. A treeadjoining grammar essentially is a regular tree grammar (G´ecseg and Steinby, 1984; G´ecseg and NP Figure 5: Illustration of the adjunction of Figure 4 using explicit substitution. Steinby, 1997) enhanced with an adjunction operation. Roughly speaking, an adjunction replaces a node (not necessarily a leaf) by an auxiliary tree, which has exactly one dis</context>
</contexts>
<marker>Shieber, Schabes, 1990</marker>
<rawString>Stuart M. Shieber and Yves Schabes. 1990. Synchronous tree-adjoining grammars. In Proc. Computational Linguistics, volume 3, pages 253–258.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Stuart M Shieber</author>
</authors>
<title>Synchronous grammars as tree transducers.</title>
<date>2004</date>
<booktitle>In Proc. TAG+7,</booktitle>
<pages>88--95</pages>
<contexts>
<context position="1260" citStr="Shieber (2004)" startWordPosition="180" endWordPosition="181">characterization to several representational and algorithmic problems is demonstrated. 1 Introduction Machine translation has seen a multitude of formal translation models. Here we focus on syntaxbased (or tree-based) models. One of the oldest models is the synchronous context-free grammar (Aho and Ullman, 1972). It is clearly too weak as a syntax-based model, but found use in the string-based setting. Top-down tree transducers (Rounds, 1970; Thatcher, 1970) have been heavily investigated in the formal language community (G´ecseg and Steinby, 1984; G´ecseg and Steinby, 1997), but as argued by Shieber (2004) they are still too weak for syntax-based machine translation. Instead Shieber (2004) proposes synchronous tree substitution grammars (STSGs) and develops an equivalent bimorphism (Arnold and Dauchet, 1982) characterization. This characterization eventually led to the rediscovery of extended tree transducers (Graehl and Knight, 2004; Knight and Graehl, 2005; Graehl et al., 2008), which are essentially as powerful as STSG. They had been studied already by Arnold and Dauchet (1982) in the form of bimorphisms, but received little attention until rediscovered. Shieber (2007) claims that even STSGs</context>
<context position="9560" citStr="Shieber (2004)" startWordPosition="1704" endWordPosition="1705">ror signal L. Since the devices that we will study later can also check the required A-properness using their state behavior, we generally do not discuss trees with error symbols explicitly. 4 Extended tree transducer An extended tree transducer is a theoretical model that computes a tree transformation. Such transducers have been studied first by Arnold and Dauchet (1982) in a purely theoretic setting, but were later applied in, for example, machine translation (Knight and Graehl, 2005; Knight, 2007; Graehl et al., 2008; Graehl et al., 2009). Their popularity in machine translation is due to Shieber (2004), in which it is shown that extended tree transducers are essentially (up to a relabeling) as expressive as synchronous tree substitution grammars (STSG). We refer to Chiang (2006) for an introduction to synchronous devices. Let us recall the formal definition. An extended tree transducer (for short: XTT)6 is a system M = (Q, E, A, I, R) where • Q is a finite set of states, • E and A are alphabets of input and output symbols, respectively, • I C Q is a set of initial states, and • R is a finite set of rules of the form (q, l) —* (q1 ··· qk, r) 4Formally, we should introduce an evaluation funct</context>
<context position="21298" citStr="Shieber (2004)" startWordPosition="3906" endWordPosition="3907"> ‘total’ of the macro tree transducer ensure that the obtained topdown tree transducer is also 1-state, deterministic, and total, which means that it is a homomorphism. Finally, the 1-parameter property yields that the used substitution symbols are binary (as our substitution symbols ·[·]A). Consequently, the yield-mapping actually coincides with our evaluation. Again, this decomposition actually is a characterization of embedded tree transducers. Now the set I(h1(t), h2(t)) I t E L} can be computed Figure 9: Illustration of the proof sketch. by an extended tree transducer M due to results of Shieber (2004) and Maletti (2008). More precisely, every extended tree transducer computes such a set, so that also this step is a characterization. Thus we obtain that T is an evaluation of a tree transformation computed by an extended tree transducer, and moreover, for each extended tree transducer, the evaluation can be computed (up to a relabeling) by a STAG. The overall proof structure is illustrated in Figure 9. 6.2 Example Let us illustrate one direction (the construction of the extended tree transducer) on our example STAG of Figure 7. Essentially, we just prepare all operable nodes by inserting an </context>
</contexts>
<marker>Shieber, 2004</marker>
<rawString>Stuart M. Shieber. 2004. Synchronous grammars as tree transducers. In Proc. TAG+7, pages 88–95.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Stuart M Shieber</author>
</authors>
<title>Unifying synchronous tree adjoining grammars and tree transducers via bimorphisms. In</title>
<date>2006</date>
<booktitle>Proc. EACL,</booktitle>
<pages>377--384</pages>
<publisher>Association</publisher>
<institution>for Computational Linguistics.</institution>
<contexts>
<context position="2299" citStr="Shieber (2006)" startWordPosition="332" endWordPosition="333"> They had been studied already by Arnold and Dauchet (1982) in the form of bimorphisms, but received little attention until rediscovered. Shieber (2007) claims that even STSGs might be too simple to capture naturally occuring translation phenomena. Instead Shieber (2007) suggests a yet more powerful mechanism, synchronous tree-adjoining grammars (STAGs) as introduced by Shieber and Schabes (1990), that can capture certain (mildly) context-sensitive features of natural language. In the tradition of Shieber (2004), a characterization of the power of STAGs in terms of bimorphims was developed by Shieber (2006). The bimorphisms used are rather unconventional because they consist of a regular tree language and two embedded tree transducers (instead of two tree homomorphisms). Such embedded tree transducers (Shieber, 2006) are particular macro tree transducers (Courcelle and Franchi-Zannettacci, 1982; Engelfriet and Vogler, 1985). In this contribution, we try to unify the picture even further. We will develop a tree transducer model that can simulate STAGs. It turns out that the adjunction operation of an STAG can be explained easily by explicit substitution. In this sense, the slogan that an STAG is </context>
<context position="3808" citStr="Shieber (2006)" startWordPosition="581" endWordPosition="582">s needed to simulate an STAG in a toolkit for STSGs or extended tree transducers like TIBURON by May and Knight (2006). We show that some standard algorithms on STAG can actually be run on the constructed STSG, which often is simpler and better understood. Further, it might be easier to develop new algorithms with the alternative characterization, which we demonstrate with a product construction for input restriction in the spirit of Nederhof (2009). Finally, we also present a complete tree transducer model that is as powerful as STAG, which is an extension of the embedded tree transducers of Shieber (2006). 1067 Proceedings of the 48th Annual Meeting of the Association for Computational Linguistics, pages 1067–1076, Uppsala, Sweden, 11-16 July 2010. c�2010 Association for Computational Linguistics 2 Notation We quickly recall some central notions about trees, tree languages, and tree transformations. For a more in-depth discussion we refer to G´ecseg and Steinby (1984) and G´ecseg and Steinby (1997). A finite set E of labels is an alphabet. The set of all strings over that alphabet is E* where ε denotes the empty string. To simplify the presentation, we assume an infinite set X = {x1, x2,... } </context>
<context position="15728" citStr="Shieber (2006)" startWordPosition="2900" endWordPosition="2901">tion of Figure 4 using explicit substitution is displayed in Figure 5. To simplify the development, we will make some assumptions on all tree-adjoining grammars (and synchronous tree-adjoining grammars). A tree-adjoining grammar (TAG) is a finite set of initial trees and a finite set of auxiliary trees. Our DT .[.]N* N* ADJ rouges N bonbons N les 1070 S1 T S S? c S a S S? a S b S S? b S1 S — T S1 c a S? a S a S1 S? a S T c — — — S S? S S? S b S1 S? b S S1 b S? b initial auxiliary auxiliary auxiliary tree tree tree tree Figure 6: A TAG for the copy string language {wcw |w ∈ {a, b}*} taken from Shieber (2006). TAG do not use substitution, but only adjunction. A derivation is a chain of trees that starts with an initial tree and each derived tree is obtained from the previous one in the chain by adjunction of an auxiliary tree. As in Shieber (2006) we assume that all adjunctions are mandatory; i.e., if an auxiliary tree can be adjoined, then we need to make an adjunction. Thus, a derivation starting from an initial tree to a derived tree is complete if no adjunction is possible in the derived tree. Moreover, we assume that to each node only one adjunction can be applied. This is easily achieved by </context>
<context position="19609" citStr="Shieber (2006)" startWordPosition="3635" endWordPosition="3636">e. For every extended tree transducer M that uses explicit substitution, we can construct a STAG that computes The following proof sketch is intended for readers that are familiar with the literature on embedded tree transducers, macro tree transducers, and bimorphisms. It can safely be skipped because we 1071 S1 T — S1 T a a — S S S1 b S a S T c c T S S1 a S T c S a S1 S T c c S a S b S a S1 a — S b S b a S a a S a S b S1 b — S a a S T c S S S S1 b a S b S a S T c c Figure 8: An incomplete derivation using the STAG of Figure 7. Let r C_ TE x TA be a tree transformation computed by a STAG. By Shieber (2006) there exists a regular tree language L C_ Tr and two functions e1: Tr —* TE and e2: Tr —* TA such that T = {(e1(t),e2(t)) I t E L}. Moreover, e1 and e2 can be computed by embedded tree transducers (Shieber, 2006), which are particular 1-state, deterministic, total, 1-parameter, linear, and nondeleting macro tree transducers (Courcelle and Franchi-Zannettacci, 1982; Engelfriet and Vogler, 1985). In fact, the converse is also true up to a relabeling, which is also shown in Shieber (2006). The outer part of Figure 9 illustrates these relations. Finally, we remark that all involved constructions </context>
<context position="28694" citStr="Shieber, 2006" startWordPosition="5324" endWordPosition="5325">e transformed into the first tree of Figure 11, where the adjunctions are now visible. In fact, a second un-parsing step is required to evaluate the output. To avoid the first additional parsing step, we will now modify our tree transducer model such that this parsing step is part of its semantics. This shows that it can also be done locally (instead of globally parsing the whole input tree). In addition, we arrive at a tree transducer model that exactly (up to a relabeling) matches the power of STAG, which can be useful for certain constructions. It is known that an embedded tree transducer (Shieber, 2006) can handle the mentioned un-parsing step. An extended embedded tree transducer with 9c&apos; is the same as c except that it maps A to p. substitution M = (Q, E, A, I, R) is simply an embedded tree transducer with extended left-hand sides (i.e., any number of input symbols is allowed in the left-hand side) that uses the special symbols ·[·]A in the input. Formally, let • Q = Q0 U Q1 be finite where Q0 and Q1 are the set of states that do not and do have a context parameter, respectively, • E and A be ranked alphabets such that if ·[·]A E E, then A, A? E E, • Q(U) be such that Q(U) = {q(u) |q E Q1,</context>
</contexts>
<marker>Shieber, 2006</marker>
<rawString>Stuart M. Shieber. 2006. Unifying synchronous tree adjoining grammars and tree transducers via bimorphisms. In Proc. EACL, pages 377–384. Association for Computational Linguistics.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Stuart M Shieber</author>
</authors>
<title>Probabilistic synchronous tree-adjoining grammars for machine translation: The argument from bilingual dictionaries.</title>
<date>2007</date>
<booktitle>In Proc. Workshop on Syntax and Structure in Statistical Translation,</booktitle>
<pages>88--95</pages>
<publisher>Association</publisher>
<institution>for Computational Linguistics.</institution>
<contexts>
<context position="1837" citStr="Shieber (2007)" startWordPosition="264" endWordPosition="265">997), but as argued by Shieber (2004) they are still too weak for syntax-based machine translation. Instead Shieber (2004) proposes synchronous tree substitution grammars (STSGs) and develops an equivalent bimorphism (Arnold and Dauchet, 1982) characterization. This characterization eventually led to the rediscovery of extended tree transducers (Graehl and Knight, 2004; Knight and Graehl, 2005; Graehl et al., 2008), which are essentially as powerful as STSG. They had been studied already by Arnold and Dauchet (1982) in the form of bimorphisms, but received little attention until rediscovered. Shieber (2007) claims that even STSGs might be too simple to capture naturally occuring translation phenomena. Instead Shieber (2007) suggests a yet more powerful mechanism, synchronous tree-adjoining grammars (STAGs) as introduced by Shieber and Schabes (1990), that can capture certain (mildly) context-sensitive features of natural language. In the tradition of Shieber (2004), a characterization of the power of STAGs in terms of bimorphims was developed by Shieber (2006). The bimorphisms used are rather unconventional because they consist of a regular tree language and two embedded tree transducers (instea</context>
<context position="13404" citStr="Shieber, 2007" startWordPosition="2475" endWordPosition="2476">ation computed by M is the relation τM = {(t,u) E TE x TA I Iq E I : q(t) ==&gt;.* u} where ==�-* is the reflexive, transitive closure of ==�-. In other words, the tree t can be transformed into u if there exists an initial state q such that we can derive u from q(t) in several derivation steps. We refer to Arnold and Dauchet (1982), Graehl et al. (2008), and Graehl et al. (2009) for a more detailed exposition to XTT. 5 Synchronous tree-adjoining grammar XTT are a simple, natural model for tree transformations, however they are not suitably expressive for all applications in machine translation (Shieber, 2007). In particular, all tree transformations of XTT have a certain locality condition, which yields that the input tree and its corresponding translation cannot be separated by an unbounded distance. To overcome this problem and certain dependency problems, Shieber and Schabes (1990) and Shieber (2007) suggest a stronger model called synchronous tree-adjoining grammar (STAG), which in addition to the substitution operation of STSG (Chiang, 2005) also has an adjoining operation. Let us recall the model in some detail. A treeadjoining grammar essentially is a regular tree grammar (G´ecseg and Stein</context>
</contexts>
<marker>Shieber, 2007</marker>
<rawString>Stuart M. Shieber. 2007. Probabilistic synchronous tree-adjoining grammars for machine translation: The argument from bilingual dictionaries. In Proc. Workshop on Syntax and Structure in Statistical Translation, pages 88–95. Association for Computational Linguistics.</rawString>
</citation>
<citation valid="true">
<authors>
<author>James W Thatcher</author>
</authors>
<title>Generalized sequential machine maps.</title>
<date>1970</date>
<journal>J. Comput. System Sci.,</journal>
<volume>4</volume>
<issue>4</issue>
<pages>367</pages>
<contexts>
<context position="1108" citStr="Thatcher, 1970" startWordPosition="156" endWordPosition="157">ut and output. This characterization allows the easy integration of STAG into toolkits for extended tree transducers. Moreover, the applicability of the characterization to several representational and algorithmic problems is demonstrated. 1 Introduction Machine translation has seen a multitude of formal translation models. Here we focus on syntaxbased (or tree-based) models. One of the oldest models is the synchronous context-free grammar (Aho and Ullman, 1972). It is clearly too weak as a syntax-based model, but found use in the string-based setting. Top-down tree transducers (Rounds, 1970; Thatcher, 1970) have been heavily investigated in the formal language community (G´ecseg and Steinby, 1984; G´ecseg and Steinby, 1997), but as argued by Shieber (2004) they are still too weak for syntax-based machine translation. Instead Shieber (2004) proposes synchronous tree substitution grammars (STSGs) and develops an equivalent bimorphism (Arnold and Dauchet, 1982) characterization. This characterization eventually led to the rediscovery of extended tree transducers (Graehl and Knight, 2004; Knight and Graehl, 2005; Graehl et al., 2008), which are essentially as powerful as STSG. They had been studied </context>
</contexts>
<marker>Thatcher, 1970</marker>
<rawString>James W. Thatcher. 1970. Generalized sequential machine maps. J. Comput. System Sci., 4(4):339– 367.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>