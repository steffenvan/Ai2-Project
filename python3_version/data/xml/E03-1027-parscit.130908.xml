<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<title confidence="0.971395">
Well-Nested Parallelism Constraints for Ellipsis Resolution
</title>
<author confidence="0.979977">
Katrin Erk and Joachim Niehren
</author>
<affiliation confidence="0.969988">
Saarland University, Saarbriicken, Germany
</affiliation>
<email confidence="0.964319">
erk@coli.uni-sb.de / niehren@ps.uni-sb.de
</email>
<sectionHeader confidence="0.993879" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.99964725">
The Constraint Language for Lambda
Structures (CLLS) is an expressive tree
description language. It provides a uni-
form framework for underspecified se-
mantics, covering scope, ellipsis, and
anaphora. Efficient algorithms exist for
the sublanguage that models scope. But
so far no terminating algorithm exists
for sublanguages that model ellipsis. We
introduce well-nested parallelism con-
straints and show that they solve this
problem.
</bodyText>
<sectionHeader confidence="0.998428" genericHeader="keywords">
1 Introduction
</sectionHeader>
<bodyText confidence="0.999938309090909">
Ellipsis phenomena are ubiquitous in natural lan-
guage, e.g. in VP ellipsis, answers to questions,
and corrections. They have been studied exten-
sively (Sag, 1976; Williams, 1977; Fiengo and
May, 1994; Dalrymple et al., 1991; Hardt, 1993;
Kehler, 1995; Lappin and Shih, 1996) but remain
difficult to handle. Among the problems to solve
in connection with ellipsis are: determining the el-
lipsis antecedent, constructing a description of the
ellipsis meaning, and resolving the ellipsis (i.e. ac-
tually determining its meaning). In this paper we
focus on the problem of resolving ellipsis. We as-
sume an analysis of its structure (source, target,
and parallel elements) in the Constraint Language
for Lambda Structures (CLLS) (Egg et al., 2001).
CLLS is an expressive tree description language
that provides a uniform framework for seman-
tic underspecification covering scope, ellipsis, and
anaphora. CLLS offers dominance constraints for
modeling scope ambiguity in a similar way as pre-
vious approaches (Reyle, 1993; Pinkal, 1995; Bos,
1996), parallelism constraints for modeling ellip-
sis, and anaphoric links for modeling coreference.
The interaction of ellipsis with scope (quantifier
parallelism) is handled in a modular fashion. Enu-
merating scope readings becomes solving domi-
nance constraints, while ellipsis resolution is re-
duced to solving parallelism constraints.
Constraint solving subsumes satisfiability
checking. Satisfiability of dominance constraints
is NP-complete (Koller et al., 2001). But for
modeling scope underspecification a sublanguage
of constraints suffices. These constraints can be
solved in low polynomial time (Althaus et al.,
2002). Parallelism constraints are as expressive
as the language of Context Unification, the
satisfiability problem of which is prominent but
still open (Comon, 1992). A lower bound is given
by string unification (Makanin, 1977), for which
the best known algorithm runs in PSPACE.
So far, no terminating algorithm exists for sub-
languages of CLLS that model ellipsis. The sound
and complete semi-decision procedure for CLLS
(Erk et al., 2002) can be used for this purpose but
is slow in practice and not guaranteed to terminate.
In the current paper we introduce well-nested
parallelism constraints and so solve this prob-
lem for the first time. We argue that well-nested
parallelism constraints are powerful enough to
model ellipsis, in particular VP-ellipsis. We
present a solver for well-nested parallelism con-
straints which decides satisfiability in nondeter-
ministic polynomial time, and hence proves the
NP-completeness of this problem, as dominance
constraints are subsumed.
</bodyText>
<sectionHeader confidence="0.999351" genericHeader="introduction">
2 CLLS
</sectionHeader>
<bodyText confidence="0.998652">
We represent the meaning of sentences by lambda
terms, which are seen as trees and then described
</bodyText>
<page confidence="0.998246">
115
</page>
<bodyText confidence="0.999011">
by formulas of CLLS. The most basic formulas of
CLLS are dominance constraints (Marcus et al.,
1983). They model scope ambiguity in an under-
specified way such that the solved forms of a con-
straint correspond precisely to the readings of a
scopally ambiguous sentence.
Next we look at a simple example to see how
ellipsis is modeled in this setting.
</bodyText>
<listItem confidence="0.789501">
(1) Mary sleeps, and John does, too.
</listItem>
<bodyText confidence="0.993245375">
Fig. 1(a) shows the meaning of sentence (1) as
a tree. The source Mary sleeps has the same mean-
ing as the target John does, too except that the
contribution of the source parallel element Mary
is replaced by the one of the target parallel ele-
ment John. In the tree in Fig. 1, this is reflected
in the two shaded tree segments having the same
structure.
</bodyText>
<figure confidence="0.9971675">
(a) and (b)
Zki) X0
sleep mary sleep Am : 0
X : y
sleep mary 1 johni
X0 /X Y0 /Y
</figure>
<figureCaption confidence="0.999725">
Figure 1: (a) The semantics of sentence (1), and
</figureCaption>
<listItem confidence="0.478141">
(b) a CLLS description
</listItem>
<bodyText confidence="0.9992681">
Next we look at an idealized CLLS constraint
that a syntax/semantics interface could produce
for the above sentence. The graph of this con-
straint is given in Fig. 1 (b).
The semantics of the source starts at node X0,
the semantics of the target at Yo. The source par-
allel element starts at X1 and the target parallel
element at Y1. The graph contains an explicit de-
scription of the source semantics, but leaves the
semantics of the target (mostly) unspecified. How-
ever the target semantics is described by the par-
allelism constraint X0/X1 Y0/Y1, which states
that the tree segment X0/X1 has the same struc-
ture as the tree segment Yo/Yi.
CLLS models coreference by anaphoric
links The interaction of ellipsis and anaphora
(strict/sloppy ambiguity) is modeled by copying
rules, which result in link chains equivalent to
Kehler&apos;s (1995) analysis.
For modeling more complex classes of ellip-
sis, generalizations of parallelism constraints are
needed: parallelism segments with more than one
hole, and jigsaw parallelism, (Erk and Koller,
2001), which is used for cases where the ex-
cluded semantic contributions are not subtrees, as
in &amp;quot;John went to the station, and every student did
too, on a bike.&amp;quot; The approach we describe in this
paper extends canonically to segments with more
than one hole. For jigsaw parallelism the exten-
sion remains a topic of further research.
</bodyText>
<sectionHeader confidence="0.983653" genericHeader="method">
3 Parallelism Constraints
</sectionHeader>
<bodyText confidence="0.979478857142857">
In the following sections we restrict ourself to the
language of parallelism constraints: CLLS with-
out anaphoric links However our results extend
to the whole language of CLLS. We comment on
this further in Sec. 7.
We first briefly recall the definition of paral-
lelism constraints.
Trees. We assume a signature E = { f , g,. .}
of function symbols, each equipped with an arity
ar(f) &gt; 0. A tree is a ground term over E. A
node of a tree can be identified with its path from
the root down, expressed by a word over N. We
use the letters u, v for paths. We write E for the
empty path and uv for the concatenation of two
paths u and v. A tree T consists of a finite set of
nodes u E DT, each of which is labeled by a sym-
bol LT (u) E E. Each node u has a sequence of
children ul, , un E DT where n = ar(Ly(u))
is the arity of the label of u. A single node E, the
root of -r, is not the child of any other node.
A tree defines the following relations. The
labeling relation u:f (ui, , un) holds in T if
LT (u) = f and ui = ui for all 1 &lt; i &lt; n.
The dominance relation uv holds iff there is a
path u&amp;quot; such that uul = v. Inequality is sim-
ply inequality of nodes; disjointness ulv holds iff
neither uv nor vu. We combine dominance
and inequality into strict dominance ue v, which
holds if both wev and
Parallelism. Intuitively, a segment is an occur-
rence of a subtree from which another subtree has
been cut out.
Definition 3.1 (Segments). A segment a of a tree
T is a pair uo I ui of nodes in DT such that 7.10&lt;i*u1
holds in r. The root of the segment is uo, and its
</bodyText>
<page confidence="0.995286">
116
</page>
<figure confidence="0.981971">
P,Q XeY I X_LY I XY
X:f(Xl, • • • , Xn) (ar(f) = n)
A,-,B IP A Q
A .R,C XIY
</figure>
<bodyText confidence="0.3525832">
Dominance constraints can be drawn as con-
straint graphs, like in Fig. 1 (b). The nodes of
the constraint graph are the variables of the con-
straint. Labels and solid lines indicatc labeling lit-
erals, dotted lines represent dominance.
</bodyText>
<figureCaption confidence="0.995519">
Figure 2: The language of parallelism constraints
</figureCaption>
<sectionHeader confidence="0.880757" genericHeader="method">
4 Well-Nested Parallelism
</sectionHeader>
<bodyText confidence="0.802772">
hole is ui. The set bi- (cc) of inner nodes of a is:
</bodyText>
<equation confidence="0.647144">
b( a) {2) E DT I no* v ,(nifv)}
</equation>
<bodyText confidence="0.9887594">
The proper inner by- (a) = 13,-(a) - full excludes
the hole ui. A segment a is empty iff uo = ui.
A correspondence function is an isomorphism
between two segments of some tree that have the
same structure.
Definition 3.2 (Correspondence function). A
correspondence function between two segments
a,,@ is a bijective mapping c : 11,-(a) b(8)
such that c maps the root of a to the root of 13
and the hole of a to the hole of /3, and for every
</bodyText>
<equation confidence="0.7714875">
u E by- (a) and every label f, u:f (ul, ,un) &lt;=&gt;
c(u): f (c(u1), c(un)).
</equation>
<bodyText confidence="0.901626">
Corresponding nodes bear the same labels and
have corresponding children, except for the holes.
</bodyText>
<construct confidence="0.6699876">
Definition 3.3 (Parallelism relation). A paral-
lelism relation in a tree T is a two-place relation
a on segments of T such that a im-
plies the existence of a correspondence function
between a and 0.
</construct>
<bodyText confidence="0.966113266666667">
Constraint Language. We assume an infinite
set of node variables X, Y, Z. Figure 2 shows the
language of parallelism constraints.
A constraint P is a conjunction of literals (for
dominance, labeling, parallelism etc). We use
the abbreviations Xa-hY for XeY A X and
X = Y for Xa*Y A Ya*X. For simplicity, we
view inequality () and disjointness (I) literals
as symmetric. A segment term A is a pair of node
variables X/Y. A parallelism literal relates two
segment terms. We write V(P) for the set of vari-
ables of P. The dominance part of P is P without
its parallelism literals.
A tuple (T, a) of a tree T, a parallelism re-
lation and a variable assignment a satisfies a
constraint P iff it satisfies each literal, in the obvi-
ous way. In that case, (T, a) is a solution, and
(T, a model of P.
Parallelism constraints are
very expressive - more
expressive than is neces-
sary for modeling ellip-
sis. In particular, over-
lapping parallel segments
seem useless, but are dif-
ficult to resolve. Consider the example on the
right. The parallel segments Xo/X1 and Yo/Y1
must overlap but this is impossible. If one tries to
build a solution, one quickly runs into an infinite
repetition caused by the overlap.
</bodyText>
<subsectionHeader confidence="0.647446">
4.1 Well-Nested Parallelism Relations
</subsectionHeader>
<figureCaption confidence="0.985643">
Figure 3: (a) inside, (b) outside, (c) overlap
</figureCaption>
<bodyText confidence="0.933351333333333">
The idea behind well-nested parallelism con-
straints is to exclude overlap between all parallel
segments in a solution.
Definition 4.1 (inside, outside, overlap). Let a, )3
be segments of a tree T, a = uolui, = volvi.
Then inside(ce, 13) holds in T iff
</bodyText>
<listItem confidence="0.9993005">
• either voeuoeurevi,
• or VoeUOIV1.
</listItem>
<construct confidence="0.8055388">
outside(a, 0) holds in T iff (a) n b,-(0) = 0.
Otherwise, overlap(a, )3) holds in T.
The image of a segment
is its copy within another
segment, as illustrated to
the right:
Definition 4.2 (Image).
Let c: a —&gt; 13 be a correspondence function and
let -y = ulv be inside a. Then c(-y) = c(u)lc(v)
is the image of under c.
</construct>
<figure confidence="0.871253875">
X0/X1&amp;quot;-&apos;110/Y1
117
(b)
4golD
in the
spring_
„..,..,,,
r
</figure>
<bodyText confidence="0.7350735">
We have to prohibit overlap between images as
well as &amp;quot;original&amp;quot; segments.
</bodyText>
<construct confidence="0.919880833333333">
Definition 4.3 (image closure). A parallelism re-
lation — is image-closed if for all correspondence
functions c relating segments a 13, and all -y
inside a: 7 — c(-y).
Definition 4.4 (Well-nested Models). Let be
an image-closed parallelism relation in the tree &apos;r.
Then (7-, is a well-nested model iffor all seg-
ments a either inside(a, (3) or inside(13, a)
or outside(a, 0) holds in &apos;T.
Definition 4.5 (Well-nested Constraints). A par-
allelism constraint is well-nested if it is unsatisfi-
able or permits a well-nested model.
</construct>
<subsectionHeader confidence="0.991045">
4.2 Application to Ellipsis
</subsectionHeader>
<bodyText confidence="0.998867785714286">
Well-nesting seems to be
a sufficiently weak condi-
tion to ensure that we can
still model ellipsis. We
now show a few examples.
In Fig. 1 (b), the two seg-
ments involved do not overlap, in fact, they have
to lie in disjoint positions in any tree that matches
the description. If we outline segments as boxes,
the situation of Fig. 1 (b) can be sketched as the
picture to the right.
In a similar way, the following elliptical sen-
tences can be modeled with CLLS constraints in
which segment terms are properly nested:
</bodyText>
<listItem confidence="0.991244666666667">
(2) John revised his paper before the teacher
did, and so did Bill.
(3) Mary can&apos;t go to Princeton in the fall, but
she can in the spring, although if she does,
those that expect her in fall will be very
disappointed. (Sag, 1976)
</listItem>
<bodyText confidence="0.998922">
Sentence (2) is a famous many-pronouns puz-
zle. Figure 4 (a) shows a sketch of the two paral-
lelisms that model the two ellipses. Both segments
of the first parallelism are nested in the same seg-
ment of the second. The situation for sentence (3)
is sketched in Fig. 4 (b). The right segment of
the first parallelism is nested in the left segment
of the second parallelism. So in both cases, the
parallelism segments are either nonoverlapping or
properly nested.
</bodyText>
<figure confidence="0.973837333333333">
(a
I
elk&amp;quot;) Ca7±1.e3 Lall
</figure>
<figureCaption confidence="0.999323">
Figure 4: Nesting sketches for (2) and (3)
</figureCaption>
<bodyText confidence="0.995714166666667">
These examples are typical of the constellations
we found. It seems that many cases of ellipsis can
be modeled without overlapping parallelism. Cor-
rections may be problematic, although we have not
yet managed to construct a definitive counterex-
ample.
</bodyText>
<sectionHeader confidence="0.984805" genericHeader="method">
5 Solved Forms
</sectionHeader>
<bodyText confidence="0.9991660625">
In this and the following section, we describe
our algorithm for well-nested parallelism con-
straints. It makes a constraint dominance-solved,
then solves one parallelism literal, then makes the
constraint dominance-solved again, etc. In the
current section we define the dominance solved
forms that all dominance constraint solvers com-
pute, and the well-nested solved forms that will be
constructed by our solver.
Dominance solved forms and constraint
graphs. In Sec. 2 we have introduced constraint
graphs informally. We now make this notion for-
mal. The graph G(P) of a dominance constraint
P is a directed graph (V(P), a* W- al t1 4 2 Lt1 . Its
nodes are the variables of P, and it has two kinds
of directed edges:
</bodyText>
<equation confidence="0.976746333333333">
(X, Y) E e if Xa*Y E P
(X,Y) E ‹i if X: f (. ,Y,...) E P,
Y i-th child of X
</equation>
<bodyText confidence="0.99663225">
We draw dominance edges (X, Y) E e by dashed
lines and children edges (X, Y) E &lt;1.i by solid
lines. (We leave out node labels as they are not es-
sential here.) We write P H Xa*Y if there exists
a directed path from X to Y in the graph G(P).
A dominance solved form is a dominance con-
straint P with the following properties for all
X, Y E V (P):
</bodyText>
<listItem confidence="0.991755666666667">
1. The constraint graph G(P) is a tree (no two
incoming edges, acyclic, exactly one root).
2. No variable is labeled twice in P.
</listItem>
<page confidence="0.873893">
118
</page>
<listItem confidence="0.898411142857143">
3. Labeled variables in P don&apos;t have outgoing
dominance edges in the graph G(P).
4. If X_LY e P then neither P H X a*Y nor
P H Y&lt;I*X.
5. Not )C..X- E P and not X=Y E P
Proposition 5.1. A dominance solved form is sat-
isfiable.
</listItem>
<bodyText confidence="0.9621315">
Segment relations. Fig. 5 defines the possible
relationships between two tree segments. The for-
mula seg(A) that we use there states that the seg-
ment term A = X/X1 denotes a segment:
</bodyText>
<equation confidence="0.870115">
seg(A) =df XXl
</equation>
<bodyText confidence="0.906391444444444">
The inside and outside relations are nonproper so
that the formulas inside(A, B) A inside(B, A) and
inside(A, B) A outside(A, B) remain satisfiable.
In the first case, equal(A, B) follows, in the sec-
ond case A must denote the empty segment. The
overlap relation, however, is proper:
inside (A, B) —ioverlap(A, B)
We also use &amp;quot;inside&amp;quot; and &amp;quot;outside&amp;quot; to describe the
relation between a segment term and a variable:
inside(Z, A) =df inside(Z/Z, A)
outside(Z, A) =df outside(Z/Z, A)
Predecision. In a predecided constraint, the rel-
ative positions of segment terms are decided. (A
dominance-solved form need not be predecided.)
A constraint P is predecided if any two segment
terms A, B in P satisfy the following conditions:
DI Different segment terms denote different seg-
ments: P H —iequal(A, B) if A B.
</bodyText>
<equation confidence="0.902298">
D2 Segment inclusion is decided: P
inside(A, B) or P H —iinside (A, B).
D3 No overlap: P H —ioverlap (A, B).
D4 Variable inclusion is decided: For all Z E
V (P), P inside(Z, A) or P
—iinside(Z, A).
</equation>
<footnote confidence="0.586782">
D5 Equality to holes is decided: For A = X/X&apos;
and all Z in V (P), P or P
</footnote>
<construct confidence="0.26892275">
z=xi.
Proposition 5.2. Every well-nested parallelism
constraint is satisfaction equivalent to a finite dis-
junction of predecided constraints.
</construct>
<bodyText confidence="0.957824789473684">
Blank segment terms. If for a parallelism lit-
eral AB, the segment term B is blank, i.e. con-
tains no information, then it is easy to read off the
solutions of this parallelism literal. We call a seg-
ment term B = XIY blank in P if it fulfills three
conditions:
B1 Variables Z E V(P)—V(B) cannot take val-
ues inside B, i.e., P H B).
B2 B is a segment term X/ Y with distinct vari-
ables and X&lt;*Y is the only literal of the
dominance part of P containing X and Y.
B3 No literal X: f (. .) or Z : f (. , Y, . . .) be-
longs to P for any f and Z.
Nesting graphs. In a predecided parallelism
constraint, we can study the nesting of segment
terms: The nesting graph N(P) of a constraint P
is a directed graph whose nodes are the segment
terms of P. The edges of N(P) are given by the
relation &lt; that we define recursively:
</bodyText>
<construct confidence="0.8288416">
A &lt; B if P H inside(A, B) A —iequal(A, B)
or A &lt; B&apos; and B&apos; E P
Or A&apos; &lt; B and A&apos; A e P
Proposition 5.3. If P is satisfiable then the nest-
ing graph N(P) is acyclic.
</construct>
<bodyText confidence="0.970515533333333">
Proof Let (T, cr) H P be a solution of P. If
A &lt; B holds in N(P) then the inner by (o-(A))
has properly less nodes than bi- (o-(B)). So if there
existed a cycle A &lt; . &lt; A in N(P) then
13,-(o-(A)) would contain strictly less nodes than
itself.
The segment term A is outermost in P if A has
no outgoing edges in the nesting graph N(P).
Well-nested solved forms. Now we have all
the notation we need to define well-nested solved
forms, constraints from which a well-nested solu-
tion can be directly read off. We call P a well-
nested solved form iff:
Si The dominance part of P is satisfiable.
S2 P is predecided.
</bodyText>
<page confidence="0.974065">
119
</page>
<equation confidence="0.964577">
inside (A, B) =df
outside(A, B) =df
equal(A, B) —df
overlap (A, B) =df
seg(A) A seg(B) A Ya*X A (X&apos;a*Y V X_LY&apos;)
seg(A) A seg(B) A Y&apos;‹*X V X&apos;&lt;f&amp;quot;Y V X1Y
seg(A) A seg(B) A X=Y A X1=Y&apos;
seg(A) A seg(B) A (X &lt;i+Y ‹+ ‹±-171 V Y&lt;I+XeY&apos;&lt;i+X/V
Xa*Ya*X&apos;_LY&apos; V Ya*X&lt;*r_LX1)
Figure 5: Segment relations where A = X/X&apos; and B = Y/ Y&apos;
cap(P, B, A) =
% invariant: P A AB is predecided
% cut
let Pi = P — cut(B, P)— para(P)
let P2 = P1 A Xl*Y where X/ Y = B
% paste
let r : V(B, P) V be some variable renaming
with r(B) = A and r (Z) fresh for all Z V V (B)
let P3 = P2 A r(cut(B, P)) A s(r)(para(P))
return predecide(P3)
</equation>
<figureCaption confidence="0.996795">
Figure 6: Cut and paste simplification
</figureCaption>
<bodyText confidence="0.65531825">
S3 The nesting graph N(P) is acyclic.
S4 If P = P&apos; A A,-,B then B is blank in P&apos;.
Proposition 5.4. Every well-nested solved form
has a well-nested solution.
</bodyText>
<sectionHeader confidence="0.90921" genericHeader="method">
6 Constraint Solving
</sectionHeader>
<bodyText confidence="0.983004428571429">
In this section we present a constraint solver for
well-nested parallelism constraints: Given a par-
allelism constraint P, it computes a finite set
of well-nested solved forms with the same well-
nested solutions as P.
Dominance constraint solving and predecision.
To compute predecide(P):
</bodyText>
<listItem confidence="0.998873777777778">
• first compute dominance solved forms of P.
• In each dominance solved form P&apos;, guess rel-
ative positions of variables with respect to
the roots and holes of segment terms, unless
they are implied by P&apos; already. Discard P&apos; if
it contains overlapping segments. Substitute
variables if necessary to fulfill condition Di.
• Again compute dominance solved forms to
detect inconsistencies.
</listItem>
<bodyText confidence="0.919973727272727">
Cut-and-paste simplification. Given a domi-
nance solved and predecided constraint, we apply
cut-and-paste to an outermost parallelism literal.
The goal is to make one segment term blank.
We need some notation. Given a constraint P
with segment B let V(P, B) be the set of variables
of B that must take their value inside B.
V(P, B) = {Z I P inside(Z, B)}
The constraint cut(B, P) consists of all literals of
P with variables in V(P, B), with the exception
of constant labelings of the hole of B:
</bodyText>
<equation confidence="0.997010333333333">
cut(B, P) = P
- Iv(P,B) — lab(B, P)
lab(X/Y,P) = {Z:a P Z=Y, a E El
</equation>
<bodyText confidence="0.9941664">
Let para(P) be the conjunction of parallelism lit-
erals in P. Finally, we lift substitutions r : V&apos; —&gt;
✓ with V&apos; C V to a substitution s(r) on segment
terms which only alters segment terms with vari-
ables solely in V&apos;:
</bodyText>
<equation confidence="0.8128395">
r(C) if V(C) C V&apos;
C else
</equation>
<bodyText confidence="0.996722166666667">
The cut-and-paste simplification cap(P, B, A) is
shown in Fig. 6. It requires that P A AB is
predecided. It first cuts out the contents of B,
cut(B, P), from P and removes all parallelism lit-
erals. Then it makes B blank. In P3, two things
happen: First, the contents of B are pasted over
those of A. This is done by renaming the variables
in cut(B, P) apart but mapping root and hole of
B to those of A. Second, the parallelism literals
are adapted by mapping segment terms inside B
to segment terms inside A. Finally, the resulting
constraint gets dominance-solved and predecided.
</bodyText>
<construct confidence="0.957049333333333">
Lemma 6.1. A predecided constraint P&apos; = P A
A,-,B where A, B are outermost in N(P&apos;) has the
same models as A, B A V cap(P, B, A).
</construct>
<equation confidence="0.5864804">
s(r)(C) =
120
solve(P)
% invariant: P is predecided
if P contains no parallelism literals then return {P
el scif N(P) is cyclic then return 0
else let P A,--13 A P&apos; with A outermost in N(P)
let Si cap(P&apos;,B,A) % cut-and-paste
let S2 = U{ solve(Q) Q E Sl}
return { Q A A,--,13 Q E S2 }
</equation>
<figureCaption confidence="0.998208">
Figure 7: Constraint solver
</figureCaption>
<bodyText confidence="0.993343791666667">
This holds because parallel segments have the
same structure, so in any model, the segment de-
noting A contains the structure described by A and
the structure described by B.
The complete algorithm. The solver for well-
nested parallelism constraints is shown in Fig. 6. It
applies cut-and-paste simplification exhaustively
to parallel segment terms in P. always choosing
an outermost parallelism literal next. Constraints
with cyclic nesting graphs are discarded as they
have no solution.
Proposition 6.2 (Complexity). The computation
of solve(P) terminates for all predecided P;
emptiness of solve(P) can be checked in non-
deterministic polynomial time.
Recursive calls during solve(P) apply to con-
straints P&apos; with properly fewer parallelism literals
than P. All used subroutines terminate, and thus,
the computation of solve(P) terminates.
Emptiness of solve(P) can be decided by
computing the elements of solve(P) non-
deterministically: Whenever solve(P) works with
sets of constraints, we choose a single element and
continue it alone. The remaining deterministic
steps require at most polynomial time.
Proposition 6.3 (Correctness). If P is predecided
then solve(P) is a finite set of well-nested solved
forms that has the same well-nested models as P.
The dominance solver and predecision algo-
rithm see to it that solve(P) is predecided and has
a satisfiable dominance part. Cutting and pasting
leaves the right segment term of a parallelism lit-
eral blank, and nothing can move into a blank seg-
ment term later because we work from the outside
in: B is outermost at the point in time that we
solve the literal, and afterwards we only change
parts of the constraint that are deeper nested than
} B . For the same reason, the acyclicity of the
nesting graph is guaranteed. Well-nested models
are preserved in spite of the changed parallelism
literals because well-nestedness presumes image-
closedness (Def. 4.3).
Theorem 6.4. Sati,sfiability of well-nested paral-
lelism constraints is NP- complete.
Propositions 6.2 and 6.3 prove satisfiability in
nondeterministic polynomial time. NP-hardness
already holds for dominance constraints (Koller et
al., 2001) which are clearly well-nested.
</bodyText>
<sectionHeader confidence="0.976008" genericHeader="method">
7 An Example
</sectionHeader>
<bodyText confidence="0.9386815">
We demonstrate the algorithm on sentence (2), and
we also show how ellipsis resolution and anaphora
resolution may be integrated. Figure 8 shows the
constraint for that sentence. The coreference is
represented by the arrow from &amp;quot;ono&amp;quot; to &amp;quot;john&amp;quot;.
We have abbreviated &amp;quot;revise&amp;quot; and &amp;quot;the teacher&amp;quot; for
better readability.
revise
</bodyText>
<figureCaption confidence="0.9105845">
Figure 8: &amp;quot;John revised his paper before the
teacher did, and so did Bill.&amp;quot;
</figureCaption>
<bodyText confidence="0.999871666666667">
Constructing a dominance-solved form includes
resolving the scope of &amp;quot;john&amp;quot; and &amp;quot;his paper&amp;quot;. We
pursue the case where &amp;quot;john&amp;quot; takes wide scope.
The resulting constraint is already predecided: It
entails that the segment terms do not overlap, and
it is clear for all variables whether they are inside
the segment terms or outside. This is typical for
constraints from the linguistic application. So al-
though the problem is NP-hard in theory, in prac-
tice it is not necessary to guess relative positions.
We first resolve the ellipses, ignoring the
anaphora. We start by solving the outer paral-
lelism X0/X1,-,Yo/Y1 by &amp;quot;cut-and-paste&amp;quot;. The
result is shown in Fig. 9 (a). For better read-
ability we have abbreviated &amp;quot;his paper&amp;quot; to &amp;quot;ana&amp;quot;.
</bodyText>
<figure confidence="0.990418346153846">
@
@\ lam
paper— ana -
of
X1/ \
john lam
the
teacher
X0 and
0
hill lam
lam
X 0/X I— Y 0/Y I^
Z 0/X I W0/W1
121
(b) x and
0
Z 0/before w
: 0
-st- 6 WI
john lam the
teacher
aria
revise
Y An interesting question to pursue is whether we
0
</figure>
<bodyText confidence="0.8789095">
can use an even less expressive fragment of paral-
lelismconstraints to model ellipsis.
</bodyText>
<sectionHeader confidence="0.855127" genericHeader="conclusions">
References
</sectionHeader>
<reference confidence="0.583640333333333">
E. Althaus, D. Duchicr, A. Kollcr, K. Mchlhorn, J. Nichrcn,
and S. Thiel. 2002. An cffi cient graph algorithm for dom-
inance constraints. Journal of Algorithms. To appear.
</reference>
<figure confidence="0.9998357">
(a) X and 0
__before \t‘ Y
in bill
W/
v v6\
john lam Z \ lam
thc
teacher
ana0 X — W0 /W
revise
</figure>
<figureCaption confidence="0.997919">
Figure 9: After solving (a) the outer parallelism,
(b) the inner parallelism
</figureCaption>
<bodyText confidence="0.998802">
Now Zo /Xi ,--,W0/Wi is outermost. The re-
sult of applying &amp;quot;cut-and-paste&amp;quot; to it is shown
in Fig. 9 (b). As no parallelism literals are left,
solve(P) is this constraint plus X0/X1-,Y0/ Yi A
Zo/X1,-Wo/W1, a well-nested solved form.
To read off a solution from the well-nested
solved form, we take each parallelism literal and
copy the contents of the left segment term to the
right, this time working from the inside out. Fi-
nally we enumerate the anaphora readings, using
the CLLS rules for the interaction of parallelism
and anaphoric links Figure 10 shows one of the 5
readings (Egg et al., 2001) that this yields.
</bodyText>
<figure confidence="0.678447333333333">
d
an
X 0
z
beFore before.
W16
A
\Y 6\
lam bill lam lam
the the
teacher
ana ), anal ana
revise revise revise
John revised John&apos;s paper before the teacher revised John&apos;s paper, and
Bill revised Bill&apos;s paper before the teacher revised Bill&apos;s paper.
</figure>
<figureCaption confidence="0.401042">
Figure 10: Reading off the results
</figureCaption>
<sectionHeader confidence="0.98114" genericHeader="references">
8 Conclusion and Outlook
</sectionHeader>
<bodyText confidence="0.999039428571429">
We have introduced well-nested parallelism con-
straints, a fragment of CLLS for which satisfi-
ability is decidable in nondeterministic polyno-
mial time. We have presented an algorithm for
computing well-nested solved forms, and we have
shown how well-nested parallelism constraints can
be used to model ellipsis.
</bodyText>
<reference confidence="0.999348923076923">
J. Bos. 1996. Predicate logic unplugged. In Proc. of the 10th
Amsterdam Colloquium.
H. Comon. 1992. Completion of rewrite systems with mem-
bership constraints. In Proc. of ICALP &apos;92.
M. Dalrymple, S. Shieber, and F. Pereira. 1991. Ellipsis
and higher-order unifi cation. Linguistics &amp; Philosophy,
14:399-452.
M. Egg, A. Koller, and J. Niehren. 2001. The Constraint
Language for Lambda Structures. Journal of Logic, Lan-
guage, and Information, 10:457-485.
Katrin Erk and Alexander Koller. 2001. VP ellipsis by tree
surgery. In Proc. of the 13th Amsterdam Colloquium.
K. Erk, A. Koller, and J. Niehren. 2002. Processing under-
specifi ed semantic representations in the Constraint Lan-
guage for Lambda Structures. Journal of Language and
Computation. To appear.
R. Fiengo and R. May. 1994. Indices and Identity. MIT
Press, Cambridge.
D. Hardt. 1993. Verb Phrase Ellipsis: Form, Meaning, and
Processing. Ph.D. thesis, University of Pennsylvania.
A. Kehler. 1995. Interpreting Cohesive Forms in the Context
of Discourse Inference. Ph.D. thesis, Harvard University.
A. Koller, J. Niehren, and R.Trei nen. 2001. Dominance con-
straints: Algorithms and complexity. In Proc. of LACL&apos;01.
S. Lappin and H. Shih. 1996. A generalized reconstruction
algorithm for ellipsis resolution. In Proc. of COLING&apos;96.
G. S. Makanin. 1977. The problem of solvability of equa-
tions in a free semigroup. Mat. Sbomik., 103(2):147-236.
M. P. Marcus, D. Hindle, and M. M. Fleck. 1983. D-theory:
Talking about talking about trees. In Proc. ACL&apos;83.
M. Pinkal. 1995. Radical underspecifi cation. In Proc. of the
10th Amsterdam Colloquium. University of Amsterdam.
U. Reyle. 1993. Dealing with ambiguities by underspecifi -
cation: Construction, representation, and deduction. Jour-
nal of Semantics, 10(2).
I. Sag. 1976. Deletion and logical form. Ph.D. thesis, MIT,
Cambridge.
E. Williams. 1977. Discourse and logical form. Linguistic
Inquiry, 8(1):101-139.
</reference>
<figure confidence="0.94944925">
X /6\
john lam
ana
revise
</figure>
<page confidence="0.941701">
122
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.660352">
<title confidence="0.999376">Well-Nested Parallelism Constraints for Ellipsis Resolution</title>
<author confidence="0.995931">Katrin Erk</author>
<author confidence="0.995931">Joachim Niehren</author>
<affiliation confidence="0.898246">Saarland University, Saarbriicken, Germany</affiliation>
<email confidence="0.772061">/</email>
<abstract confidence="0.997731307692308">The Constraint Language for Lambda Structures (CLLS) is an expressive tree description language. It provides a uniform framework for underspecified semantics, covering scope, ellipsis, and anaphora. Efficient algorithms exist for the sublanguage that models scope. But so far no terminating algorithm exists for sublanguages that model ellipsis. We parallelism conshow that they solve this problem.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>E Althaus</author>
<author>D Duchicr</author>
<author>A Kollcr</author>
<author>K Mchlhorn</author>
<author>J Nichrcn</author>
<author>S Thiel</author>
</authors>
<title>An cffi cient graph algorithm for dominance constraints. Journal of Algorithms.</title>
<date>2002</date>
<note>To appear.</note>
<contexts>
<context position="2289" citStr="Althaus et al., 2002" startWordPosition="321" endWordPosition="324">), parallelism constraints for modeling ellipsis, and anaphoric links for modeling coreference. The interaction of ellipsis with scope (quantifier parallelism) is handled in a modular fashion. Enumerating scope readings becomes solving dominance constraints, while ellipsis resolution is reduced to solving parallelism constraints. Constraint solving subsumes satisfiability checking. Satisfiability of dominance constraints is NP-complete (Koller et al., 2001). But for modeling scope underspecification a sublanguage of constraints suffices. These constraints can be solved in low polynomial time (Althaus et al., 2002). Parallelism constraints are as expressive as the language of Context Unification, the satisfiability problem of which is prominent but still open (Comon, 1992). A lower bound is given by string unification (Makanin, 1977), for which the best known algorithm runs in PSPACE. So far, no terminating algorithm exists for sublanguages of CLLS that model ellipsis. The sound and complete semi-decision procedure for CLLS (Erk et al., 2002) can be used for this purpose but is slow in practice and not guaranteed to terminate. In the current paper we introduce well-nested parallelism constraints and so </context>
</contexts>
<marker>Althaus, Duchicr, Kollcr, Mchlhorn, Nichrcn, Thiel, 2002</marker>
<rawString>E. Althaus, D. Duchicr, A. Kollcr, K. Mchlhorn, J. Nichrcn, and S. Thiel. 2002. An cffi cient graph algorithm for dominance constraints. Journal of Algorithms. To appear.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Bos</author>
</authors>
<title>Predicate logic unplugged.</title>
<date>1996</date>
<booktitle>In Proc. of the 10th Amsterdam Colloquium.</booktitle>
<contexts>
<context position="1669" citStr="Bos, 1996" startWordPosition="240" endWordPosition="241">ption of the ellipsis meaning, and resolving the ellipsis (i.e. actually determining its meaning). In this paper we focus on the problem of resolving ellipsis. We assume an analysis of its structure (source, target, and parallel elements) in the Constraint Language for Lambda Structures (CLLS) (Egg et al., 2001). CLLS is an expressive tree description language that provides a uniform framework for semantic underspecification covering scope, ellipsis, and anaphora. CLLS offers dominance constraints for modeling scope ambiguity in a similar way as previous approaches (Reyle, 1993; Pinkal, 1995; Bos, 1996), parallelism constraints for modeling ellipsis, and anaphoric links for modeling coreference. The interaction of ellipsis with scope (quantifier parallelism) is handled in a modular fashion. Enumerating scope readings becomes solving dominance constraints, while ellipsis resolution is reduced to solving parallelism constraints. Constraint solving subsumes satisfiability checking. Satisfiability of dominance constraints is NP-complete (Koller et al., 2001). But for modeling scope underspecification a sublanguage of constraints suffices. These constraints can be solved in low polynomial time (A</context>
</contexts>
<marker>Bos, 1996</marker>
<rawString>J. Bos. 1996. Predicate logic unplugged. In Proc. of the 10th Amsterdam Colloquium.</rawString>
</citation>
<citation valid="true">
<authors>
<author>H Comon</author>
</authors>
<title>Completion of rewrite systems with membership constraints.</title>
<date>1992</date>
<booktitle>In Proc. of ICALP &apos;92.</booktitle>
<contexts>
<context position="2450" citStr="Comon, 1992" startWordPosition="346" endWordPosition="347"> in a modular fashion. Enumerating scope readings becomes solving dominance constraints, while ellipsis resolution is reduced to solving parallelism constraints. Constraint solving subsumes satisfiability checking. Satisfiability of dominance constraints is NP-complete (Koller et al., 2001). But for modeling scope underspecification a sublanguage of constraints suffices. These constraints can be solved in low polynomial time (Althaus et al., 2002). Parallelism constraints are as expressive as the language of Context Unification, the satisfiability problem of which is prominent but still open (Comon, 1992). A lower bound is given by string unification (Makanin, 1977), for which the best known algorithm runs in PSPACE. So far, no terminating algorithm exists for sublanguages of CLLS that model ellipsis. The sound and complete semi-decision procedure for CLLS (Erk et al., 2002) can be used for this purpose but is slow in practice and not guaranteed to terminate. In the current paper we introduce well-nested parallelism constraints and so solve this problem for the first time. We argue that well-nested parallelism constraints are powerful enough to model ellipsis, in particular VP-ellipsis. We pre</context>
</contexts>
<marker>Comon, 1992</marker>
<rawString>H. Comon. 1992. Completion of rewrite systems with membership constraints. In Proc. of ICALP &apos;92.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Dalrymple</author>
<author>S Shieber</author>
<author>F Pereira</author>
</authors>
<title>Ellipsis and higher-order unifi cation.</title>
<date>1991</date>
<journal>Linguistics &amp; Philosophy,</journal>
<pages>14--399</pages>
<contexts>
<context position="856" citStr="Dalrymple et al., 1991" startWordPosition="114" endWordPosition="117">LS) is an expressive tree description language. It provides a uniform framework for underspecified semantics, covering scope, ellipsis, and anaphora. Efficient algorithms exist for the sublanguage that models scope. But so far no terminating algorithm exists for sublanguages that model ellipsis. We introduce well-nested parallelism constraints and show that they solve this problem. 1 Introduction Ellipsis phenomena are ubiquitous in natural language, e.g. in VP ellipsis, answers to questions, and corrections. They have been studied extensively (Sag, 1976; Williams, 1977; Fiengo and May, 1994; Dalrymple et al., 1991; Hardt, 1993; Kehler, 1995; Lappin and Shih, 1996) but remain difficult to handle. Among the problems to solve in connection with ellipsis are: determining the ellipsis antecedent, constructing a description of the ellipsis meaning, and resolving the ellipsis (i.e. actually determining its meaning). In this paper we focus on the problem of resolving ellipsis. We assume an analysis of its structure (source, target, and parallel elements) in the Constraint Language for Lambda Structures (CLLS) (Egg et al., 2001). CLLS is an expressive tree description language that provides a uniform framework </context>
</contexts>
<marker>Dalrymple, Shieber, Pereira, 1991</marker>
<rawString>M. Dalrymple, S. Shieber, and F. Pereira. 1991. Ellipsis and higher-order unifi cation. Linguistics &amp; Philosophy, 14:399-452.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Egg</author>
<author>A Koller</author>
<author>J Niehren</author>
</authors>
<title>The Constraint Language for Lambda Structures.</title>
<date>2001</date>
<journal>Journal of Logic, Language, and Information,</journal>
<pages>10--457</pages>
<contexts>
<context position="1372" citStr="Egg et al., 2001" startWordPosition="195" endWordPosition="198">ave been studied extensively (Sag, 1976; Williams, 1977; Fiengo and May, 1994; Dalrymple et al., 1991; Hardt, 1993; Kehler, 1995; Lappin and Shih, 1996) but remain difficult to handle. Among the problems to solve in connection with ellipsis are: determining the ellipsis antecedent, constructing a description of the ellipsis meaning, and resolving the ellipsis (i.e. actually determining its meaning). In this paper we focus on the problem of resolving ellipsis. We assume an analysis of its structure (source, target, and parallel elements) in the Constraint Language for Lambda Structures (CLLS) (Egg et al., 2001). CLLS is an expressive tree description language that provides a uniform framework for semantic underspecification covering scope, ellipsis, and anaphora. CLLS offers dominance constraints for modeling scope ambiguity in a similar way as previous approaches (Reyle, 1993; Pinkal, 1995; Bos, 1996), parallelism constraints for modeling ellipsis, and anaphoric links for modeling coreference. The interaction of ellipsis with scope (quantifier parallelism) is handled in a modular fashion. Enumerating scope readings becomes solving dominance constraints, while ellipsis resolution is reduced to solvi</context>
</contexts>
<marker>Egg, Koller, Niehren, 2001</marker>
<rawString>M. Egg, A. Koller, and J. Niehren. 2001. The Constraint Language for Lambda Structures. Journal of Logic, Language, and Information, 10:457-485.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Katrin Erk</author>
<author>Alexander Koller</author>
</authors>
<title>VP ellipsis by tree surgery.</title>
<date>2001</date>
<booktitle>In Proc. of the 13th Amsterdam Colloquium.</booktitle>
<contexts>
<context position="5302" citStr="Erk and Koller, 2001" startWordPosition="828" endWordPosition="831">mantics of the target (mostly) unspecified. However the target semantics is described by the parallelism constraint X0/X1 Y0/Y1, which states that the tree segment X0/X1 has the same structure as the tree segment Yo/Yi. CLLS models coreference by anaphoric links The interaction of ellipsis and anaphora (strict/sloppy ambiguity) is modeled by copying rules, which result in link chains equivalent to Kehler&apos;s (1995) analysis. For modeling more complex classes of ellipsis, generalizations of parallelism constraints are needed: parallelism segments with more than one hole, and jigsaw parallelism, (Erk and Koller, 2001), which is used for cases where the excluded semantic contributions are not subtrees, as in &amp;quot;John went to the station, and every student did too, on a bike.&amp;quot; The approach we describe in this paper extends canonically to segments with more than one hole. For jigsaw parallelism the extension remains a topic of further research. 3 Parallelism Constraints In the following sections we restrict ourself to the language of parallelism constraints: CLLS without anaphoric links However our results extend to the whole language of CLLS. We comment on this further in Sec. 7. We first briefly recall the def</context>
</contexts>
<marker>Erk, Koller, 2001</marker>
<rawString>Katrin Erk and Alexander Koller. 2001. VP ellipsis by tree surgery. In Proc. of the 13th Amsterdam Colloquium.</rawString>
</citation>
<citation valid="true">
<authors>
<author>K Erk</author>
<author>A Koller</author>
<author>J Niehren</author>
</authors>
<title>Processing underspecifi ed semantic representations in the Constraint Language for Lambda Structures.</title>
<date>2002</date>
<journal>Journal of Language and Computation.</journal>
<note>To appear.</note>
<contexts>
<context position="2725" citStr="Erk et al., 2002" startWordPosition="389" endWordPosition="392">(Koller et al., 2001). But for modeling scope underspecification a sublanguage of constraints suffices. These constraints can be solved in low polynomial time (Althaus et al., 2002). Parallelism constraints are as expressive as the language of Context Unification, the satisfiability problem of which is prominent but still open (Comon, 1992). A lower bound is given by string unification (Makanin, 1977), for which the best known algorithm runs in PSPACE. So far, no terminating algorithm exists for sublanguages of CLLS that model ellipsis. The sound and complete semi-decision procedure for CLLS (Erk et al., 2002) can be used for this purpose but is slow in practice and not guaranteed to terminate. In the current paper we introduce well-nested parallelism constraints and so solve this problem for the first time. We argue that well-nested parallelism constraints are powerful enough to model ellipsis, in particular VP-ellipsis. We present a solver for well-nested parallelism constraints which decides satisfiability in nondeterministic polynomial time, and hence proves the NP-completeness of this problem, as dominance constraints are subsumed. 2 CLLS We represent the meaning of sentences by lambda terms, </context>
</contexts>
<marker>Erk, Koller, Niehren, 2002</marker>
<rawString>K. Erk, A. Koller, and J. Niehren. 2002. Processing underspecifi ed semantic representations in the Constraint Language for Lambda Structures. Journal of Language and Computation. To appear.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Fiengo</author>
<author>R May</author>
</authors>
<title>Indices and Identity.</title>
<date>1994</date>
<publisher>MIT Press,</publisher>
<location>Cambridge.</location>
<contexts>
<context position="832" citStr="Fiengo and May, 1994" startWordPosition="110" endWordPosition="113"> Lambda Structures (CLLS) is an expressive tree description language. It provides a uniform framework for underspecified semantics, covering scope, ellipsis, and anaphora. Efficient algorithms exist for the sublanguage that models scope. But so far no terminating algorithm exists for sublanguages that model ellipsis. We introduce well-nested parallelism constraints and show that they solve this problem. 1 Introduction Ellipsis phenomena are ubiquitous in natural language, e.g. in VP ellipsis, answers to questions, and corrections. They have been studied extensively (Sag, 1976; Williams, 1977; Fiengo and May, 1994; Dalrymple et al., 1991; Hardt, 1993; Kehler, 1995; Lappin and Shih, 1996) but remain difficult to handle. Among the problems to solve in connection with ellipsis are: determining the ellipsis antecedent, constructing a description of the ellipsis meaning, and resolving the ellipsis (i.e. actually determining its meaning). In this paper we focus on the problem of resolving ellipsis. We assume an analysis of its structure (source, target, and parallel elements) in the Constraint Language for Lambda Structures (CLLS) (Egg et al., 2001). CLLS is an expressive tree description language that provi</context>
</contexts>
<marker>Fiengo, May, 1994</marker>
<rawString>R. Fiengo and R. May. 1994. Indices and Identity. MIT Press, Cambridge.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D Hardt</author>
</authors>
<title>Verb Phrase Ellipsis: Form, Meaning, and Processing.</title>
<date>1993</date>
<tech>Ph.D. thesis,</tech>
<institution>University of Pennsylvania.</institution>
<contexts>
<context position="869" citStr="Hardt, 1993" startWordPosition="118" endWordPosition="119">e description language. It provides a uniform framework for underspecified semantics, covering scope, ellipsis, and anaphora. Efficient algorithms exist for the sublanguage that models scope. But so far no terminating algorithm exists for sublanguages that model ellipsis. We introduce well-nested parallelism constraints and show that they solve this problem. 1 Introduction Ellipsis phenomena are ubiquitous in natural language, e.g. in VP ellipsis, answers to questions, and corrections. They have been studied extensively (Sag, 1976; Williams, 1977; Fiengo and May, 1994; Dalrymple et al., 1991; Hardt, 1993; Kehler, 1995; Lappin and Shih, 1996) but remain difficult to handle. Among the problems to solve in connection with ellipsis are: determining the ellipsis antecedent, constructing a description of the ellipsis meaning, and resolving the ellipsis (i.e. actually determining its meaning). In this paper we focus on the problem of resolving ellipsis. We assume an analysis of its structure (source, target, and parallel elements) in the Constraint Language for Lambda Structures (CLLS) (Egg et al., 2001). CLLS is an expressive tree description language that provides a uniform framework for semantic </context>
</contexts>
<marker>Hardt, 1993</marker>
<rawString>D. Hardt. 1993. Verb Phrase Ellipsis: Form, Meaning, and Processing. Ph.D. thesis, University of Pennsylvania.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Kehler</author>
</authors>
<title>Interpreting Cohesive Forms in the Context of Discourse Inference.</title>
<date>1995</date>
<tech>Ph.D. thesis,</tech>
<institution>Harvard University.</institution>
<contexts>
<context position="883" citStr="Kehler, 1995" startWordPosition="120" endWordPosition="121"> language. It provides a uniform framework for underspecified semantics, covering scope, ellipsis, and anaphora. Efficient algorithms exist for the sublanguage that models scope. But so far no terminating algorithm exists for sublanguages that model ellipsis. We introduce well-nested parallelism constraints and show that they solve this problem. 1 Introduction Ellipsis phenomena are ubiquitous in natural language, e.g. in VP ellipsis, answers to questions, and corrections. They have been studied extensively (Sag, 1976; Williams, 1977; Fiengo and May, 1994; Dalrymple et al., 1991; Hardt, 1993; Kehler, 1995; Lappin and Shih, 1996) but remain difficult to handle. Among the problems to solve in connection with ellipsis are: determining the ellipsis antecedent, constructing a description of the ellipsis meaning, and resolving the ellipsis (i.e. actually determining its meaning). In this paper we focus on the problem of resolving ellipsis. We assume an analysis of its structure (source, target, and parallel elements) in the Constraint Language for Lambda Structures (CLLS) (Egg et al., 2001). CLLS is an expressive tree description language that provides a uniform framework for semantic underspecifica</context>
</contexts>
<marker>Kehler, 1995</marker>
<rawString>A. Kehler. 1995. Interpreting Cohesive Forms in the Context of Discourse Inference. Ph.D. thesis, Harvard University.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Koller</author>
<author>J Niehren</author>
<author>R Trei nen</author>
</authors>
<title>Dominance constraints: Algorithms and complexity.</title>
<date>2001</date>
<booktitle>In Proc. of LACL&apos;01.</booktitle>
<contexts>
<context position="2129" citStr="Koller et al., 2001" startWordPosition="298" endWordPosition="301">sis, and anaphora. CLLS offers dominance constraints for modeling scope ambiguity in a similar way as previous approaches (Reyle, 1993; Pinkal, 1995; Bos, 1996), parallelism constraints for modeling ellipsis, and anaphoric links for modeling coreference. The interaction of ellipsis with scope (quantifier parallelism) is handled in a modular fashion. Enumerating scope readings becomes solving dominance constraints, while ellipsis resolution is reduced to solving parallelism constraints. Constraint solving subsumes satisfiability checking. Satisfiability of dominance constraints is NP-complete (Koller et al., 2001). But for modeling scope underspecification a sublanguage of constraints suffices. These constraints can be solved in low polynomial time (Althaus et al., 2002). Parallelism constraints are as expressive as the language of Context Unification, the satisfiability problem of which is prominent but still open (Comon, 1992). A lower bound is given by string unification (Makanin, 1977), for which the best known algorithm runs in PSPACE. So far, no terminating algorithm exists for sublanguages of CLLS that model ellipsis. The sound and complete semi-decision procedure for CLLS (Erk et al., 2002) can</context>
<context position="22567" citStr="Koller et al., 2001" startWordPosition="4008" endWordPosition="4011"> the outside in: B is outermost at the point in time that we solve the literal, and afterwards we only change parts of the constraint that are deeper nested than } B . For the same reason, the acyclicity of the nesting graph is guaranteed. Well-nested models are preserved in spite of the changed parallelism literals because well-nestedness presumes imageclosedness (Def. 4.3). Theorem 6.4. Sati,sfiability of well-nested parallelism constraints is NP- complete. Propositions 6.2 and 6.3 prove satisfiability in nondeterministic polynomial time. NP-hardness already holds for dominance constraints (Koller et al., 2001) which are clearly well-nested. 7 An Example We demonstrate the algorithm on sentence (2), and we also show how ellipsis resolution and anaphora resolution may be integrated. Figure 8 shows the constraint for that sentence. The coreference is represented by the arrow from &amp;quot;ono&amp;quot; to &amp;quot;john&amp;quot;. We have abbreviated &amp;quot;revise&amp;quot; and &amp;quot;the teacher&amp;quot; for better readability. revise Figure 8: &amp;quot;John revised his paper before the teacher did, and so did Bill.&amp;quot; Constructing a dominance-solved form includes resolving the scope of &amp;quot;john&amp;quot; and &amp;quot;his paper&amp;quot;. We pursue the case where &amp;quot;john&amp;quot; takes wide scope. The resulting</context>
</contexts>
<marker>Koller, Niehren, nen, 2001</marker>
<rawString>A. Koller, J. Niehren, and R.Trei nen. 2001. Dominance constraints: Algorithms and complexity. In Proc. of LACL&apos;01.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S Lappin</author>
<author>H Shih</author>
</authors>
<title>A generalized reconstruction algorithm for ellipsis resolution.</title>
<date>1996</date>
<booktitle>In Proc. of COLING&apos;96.</booktitle>
<contexts>
<context position="907" citStr="Lappin and Shih, 1996" startWordPosition="122" endWordPosition="125">provides a uniform framework for underspecified semantics, covering scope, ellipsis, and anaphora. Efficient algorithms exist for the sublanguage that models scope. But so far no terminating algorithm exists for sublanguages that model ellipsis. We introduce well-nested parallelism constraints and show that they solve this problem. 1 Introduction Ellipsis phenomena are ubiquitous in natural language, e.g. in VP ellipsis, answers to questions, and corrections. They have been studied extensively (Sag, 1976; Williams, 1977; Fiengo and May, 1994; Dalrymple et al., 1991; Hardt, 1993; Kehler, 1995; Lappin and Shih, 1996) but remain difficult to handle. Among the problems to solve in connection with ellipsis are: determining the ellipsis antecedent, constructing a description of the ellipsis meaning, and resolving the ellipsis (i.e. actually determining its meaning). In this paper we focus on the problem of resolving ellipsis. We assume an analysis of its structure (source, target, and parallel elements) in the Constraint Language for Lambda Structures (CLLS) (Egg et al., 2001). CLLS is an expressive tree description language that provides a uniform framework for semantic underspecification covering scope, ell</context>
</contexts>
<marker>Lappin, Shih, 1996</marker>
<rawString>S. Lappin and H. Shih. 1996. A generalized reconstruction algorithm for ellipsis resolution. In Proc. of COLING&apos;96.</rawString>
</citation>
<citation valid="true">
<authors>
<author>G S Makanin</author>
</authors>
<title>The problem of solvability of equations in a free semigroup.</title>
<date>1977</date>
<journal>Mat. Sbomik.,</journal>
<pages>103--2</pages>
<contexts>
<context position="2512" citStr="Makanin, 1977" startWordPosition="356" endWordPosition="357">lving dominance constraints, while ellipsis resolution is reduced to solving parallelism constraints. Constraint solving subsumes satisfiability checking. Satisfiability of dominance constraints is NP-complete (Koller et al., 2001). But for modeling scope underspecification a sublanguage of constraints suffices. These constraints can be solved in low polynomial time (Althaus et al., 2002). Parallelism constraints are as expressive as the language of Context Unification, the satisfiability problem of which is prominent but still open (Comon, 1992). A lower bound is given by string unification (Makanin, 1977), for which the best known algorithm runs in PSPACE. So far, no terminating algorithm exists for sublanguages of CLLS that model ellipsis. The sound and complete semi-decision procedure for CLLS (Erk et al., 2002) can be used for this purpose but is slow in practice and not guaranteed to terminate. In the current paper we introduce well-nested parallelism constraints and so solve this problem for the first time. We argue that well-nested parallelism constraints are powerful enough to model ellipsis, in particular VP-ellipsis. We present a solver for well-nested parallelism constraints which de</context>
</contexts>
<marker>Makanin, 1977</marker>
<rawString>G. S. Makanin. 1977. The problem of solvability of equations in a free semigroup. Mat. Sbomik., 103(2):147-236.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M P Marcus</author>
<author>D Hindle</author>
<author>M M Fleck</author>
</authors>
<title>D-theory: Talking about talking about trees.</title>
<date>1983</date>
<booktitle>In Proc. ACL&apos;83. M. Pinkal.</booktitle>
<institution>Amsterdam Colloquium. University of Amsterdam.</institution>
<contexts>
<context position="3472" citStr="Marcus et al., 1983" startWordPosition="506" endWordPosition="509">ested parallelism constraints and so solve this problem for the first time. We argue that well-nested parallelism constraints are powerful enough to model ellipsis, in particular VP-ellipsis. We present a solver for well-nested parallelism constraints which decides satisfiability in nondeterministic polynomial time, and hence proves the NP-completeness of this problem, as dominance constraints are subsumed. 2 CLLS We represent the meaning of sentences by lambda terms, which are seen as trees and then described 115 by formulas of CLLS. The most basic formulas of CLLS are dominance constraints (Marcus et al., 1983). They model scope ambiguity in an underspecified way such that the solved forms of a constraint correspond precisely to the readings of a scopally ambiguous sentence. Next we look at a simple example to see how ellipsis is modeled in this setting. (1) Mary sleeps, and John does, too. Fig. 1(a) shows the meaning of sentence (1) as a tree. The source Mary sleeps has the same meaning as the target John does, too except that the contribution of the source parallel element Mary is replaced by the one of the target parallel element John. In the tree in Fig. 1, this is reflected in the two shaded tr</context>
</contexts>
<marker>Marcus, Hindle, Fleck, 1983</marker>
<rawString>M. P. Marcus, D. Hindle, and M. M. Fleck. 1983. D-theory: Talking about talking about trees. In Proc. ACL&apos;83. M. Pinkal. 1995. Radical underspecifi cation. In Proc. of the 10th Amsterdam Colloquium. University of Amsterdam.</rawString>
</citation>
<citation valid="true">
<authors>
<author>U Reyle</author>
</authors>
<title>Dealing with ambiguities by underspecifi -cation: Construction, representation, and deduction.</title>
<date>1993</date>
<journal>Journal of Semantics,</journal>
<volume>10</volume>
<issue>2</issue>
<contexts>
<context position="1643" citStr="Reyle, 1993" startWordPosition="236" endWordPosition="237">dent, constructing a description of the ellipsis meaning, and resolving the ellipsis (i.e. actually determining its meaning). In this paper we focus on the problem of resolving ellipsis. We assume an analysis of its structure (source, target, and parallel elements) in the Constraint Language for Lambda Structures (CLLS) (Egg et al., 2001). CLLS is an expressive tree description language that provides a uniform framework for semantic underspecification covering scope, ellipsis, and anaphora. CLLS offers dominance constraints for modeling scope ambiguity in a similar way as previous approaches (Reyle, 1993; Pinkal, 1995; Bos, 1996), parallelism constraints for modeling ellipsis, and anaphoric links for modeling coreference. The interaction of ellipsis with scope (quantifier parallelism) is handled in a modular fashion. Enumerating scope readings becomes solving dominance constraints, while ellipsis resolution is reduced to solving parallelism constraints. Constraint solving subsumes satisfiability checking. Satisfiability of dominance constraints is NP-complete (Koller et al., 2001). But for modeling scope underspecification a sublanguage of constraints suffices. These constraints can be solved</context>
</contexts>
<marker>Reyle, 1993</marker>
<rawString>U. Reyle. 1993. Dealing with ambiguities by underspecifi -cation: Construction, representation, and deduction. Journal of Semantics, 10(2).</rawString>
</citation>
<citation valid="true">
<authors>
<author>I Sag</author>
</authors>
<title>Deletion and logical form.</title>
<date>1976</date>
<tech>Ph.D. thesis,</tech>
<institution>MIT, Cambridge.</institution>
<contexts>
<context position="794" citStr="Sag, 1976" startWordPosition="106" endWordPosition="107">The Constraint Language for Lambda Structures (CLLS) is an expressive tree description language. It provides a uniform framework for underspecified semantics, covering scope, ellipsis, and anaphora. Efficient algorithms exist for the sublanguage that models scope. But so far no terminating algorithm exists for sublanguages that model ellipsis. We introduce well-nested parallelism constraints and show that they solve this problem. 1 Introduction Ellipsis phenomena are ubiquitous in natural language, e.g. in VP ellipsis, answers to questions, and corrections. They have been studied extensively (Sag, 1976; Williams, 1977; Fiengo and May, 1994; Dalrymple et al., 1991; Hardt, 1993; Kehler, 1995; Lappin and Shih, 1996) but remain difficult to handle. Among the problems to solve in connection with ellipsis are: determining the ellipsis antecedent, constructing a description of the ellipsis meaning, and resolving the ellipsis (i.e. actually determining its meaning). In this paper we focus on the problem of resolving ellipsis. We assume an analysis of its structure (source, target, and parallel elements) in the Constraint Language for Lambda Structures (CLLS) (Egg et al., 2001). CLLS is an expressiv</context>
<context position="11808" citStr="Sag, 1976" startWordPosition="2046" endWordPosition="2047">. 1 (b), the two segments involved do not overlap, in fact, they have to lie in disjoint positions in any tree that matches the description. If we outline segments as boxes, the situation of Fig. 1 (b) can be sketched as the picture to the right. In a similar way, the following elliptical sentences can be modeled with CLLS constraints in which segment terms are properly nested: (2) John revised his paper before the teacher did, and so did Bill. (3) Mary can&apos;t go to Princeton in the fall, but she can in the spring, although if she does, those that expect her in fall will be very disappointed. (Sag, 1976) Sentence (2) is a famous many-pronouns puzzle. Figure 4 (a) shows a sketch of the two parallelisms that model the two ellipses. Both segments of the first parallelism are nested in the same segment of the second. The situation for sentence (3) is sketched in Fig. 4 (b). The right segment of the first parallelism is nested in the left segment of the second parallelism. So in both cases, the parallelism segments are either nonoverlapping or properly nested. (a I elk&amp;quot;) Ca7±1.e3 Lall Figure 4: Nesting sketches for (2) and (3) These examples are typical of the constellations we found. It seems tha</context>
</contexts>
<marker>Sag, 1976</marker>
<rawString>I. Sag. 1976. Deletion and logical form. Ph.D. thesis, MIT, Cambridge.</rawString>
</citation>
<citation valid="true">
<authors>
<author>E Williams</author>
</authors>
<date>1977</date>
<booktitle>Discourse and logical form. Linguistic Inquiry,</booktitle>
<pages>8--1</pages>
<contexts>
<context position="810" citStr="Williams, 1977" startWordPosition="108" endWordPosition="109">int Language for Lambda Structures (CLLS) is an expressive tree description language. It provides a uniform framework for underspecified semantics, covering scope, ellipsis, and anaphora. Efficient algorithms exist for the sublanguage that models scope. But so far no terminating algorithm exists for sublanguages that model ellipsis. We introduce well-nested parallelism constraints and show that they solve this problem. 1 Introduction Ellipsis phenomena are ubiquitous in natural language, e.g. in VP ellipsis, answers to questions, and corrections. They have been studied extensively (Sag, 1976; Williams, 1977; Fiengo and May, 1994; Dalrymple et al., 1991; Hardt, 1993; Kehler, 1995; Lappin and Shih, 1996) but remain difficult to handle. Among the problems to solve in connection with ellipsis are: determining the ellipsis antecedent, constructing a description of the ellipsis meaning, and resolving the ellipsis (i.e. actually determining its meaning). In this paper we focus on the problem of resolving ellipsis. We assume an analysis of its structure (source, target, and parallel elements) in the Constraint Language for Lambda Structures (CLLS) (Egg et al., 2001). CLLS is an expressive tree descripti</context>
</contexts>
<marker>Williams, 1977</marker>
<rawString>E. Williams. 1977. Discourse and logical form. Linguistic Inquiry, 8(1):101-139.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>