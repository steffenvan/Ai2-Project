<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.092104">
<title confidence="0.992773">
Supporting Annotation Layers for Natural Language Processing
</title>
<author confidence="0.998884">
Preslav Nakov, Ariel Schwartz, Brian Wolf
</author>
<affiliation confidence="0.998707">
Computer Science Division
University of California, Berkeley
</affiliation>
<address confidence="0.908246">
Berkeley, CA 94720
</address>
<email confidence="0.99965">
{nakov,sariel}@cs.berkeley.edu
</email>
<author confidence="0.848433">
Marti Hearst
</author>
<affiliation confidence="0.9028545">
SIMS
University of California, Berkeley
</affiliation>
<address confidence="0.908222">
Berkeley, CA 94720
</address>
<email confidence="0.999029">
hearst@sims.berkeley.edu
</email>
<sectionHeader confidence="0.998601" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.9998411">
We demonstrate a system for flexible
querying against text that has been anno-
tated with the results of NLP processing.
The system supports self-overlapping and
parallel layers, integration of syntactic and
ontological hierarchies, flexibility in the
format of returned results, and tight inte-
gration with SQL. We present a query lan-
guage and its use on examples taken from
the NLP literature.
</bodyText>
<sectionHeader confidence="0.999517" genericHeader="introduction">
1 Introduction
</sectionHeader>
<bodyText confidence="0.999989695652174">
Today most natural language processing (NLP)
algorithms make use of the results of previous
processing steps. For example, a word sense disam-
biguation algorithm may combine the output of a to-
kenizer, a part-of-speech tagger, a phrase boundary
recognizer, and a module that classifies noun phrases
into semantic categories. Currently there is no stan-
dard way to represent and store the results of such
processing for efficient retrieval.
We propose a framework for annotating text with
the results of NLP processing and then querying
against those annotations in flexible ways. The
framework includes a query language and an in-
dexing architecture for efficient retrieval, built on
top of a relational database management system
(RDBMS). The model allows for both hierarchical
and overlapping layers of annotation as well as for
querying at multiple levels of description.
In the remainder of the paper we describe related
work, illustrate the annotation model and the query
language and describe the indexing architecture and
the experimental results, thus showing the feasibility
of the approach for a variety of NLP tasks.
</bodyText>
<sectionHeader confidence="0.999918" genericHeader="related work">
2 Related Work
</sectionHeader>
<bodyText confidence="0.999132851851852">
There are several specialized tools for indexing and
querying treebanks. (See Bird et al. (2005) for an
overview and critical comparisons.) TGrep21 is a
a grep-like utility for the Penn Treebank corpus of
parsed Wall Street Journal texts. It allows Boolean
expressions over nodes and regular expressions in-
side nodes. Matching uses a binary index and is
performed recursively starting at the top node in the
query. TIGERSearch2 is associated with the German
syntactic corpus TIGER. The tool is more typed than
TGrep2 and allows search over discontinuous con-
stituents that are common in German. TIGERSearch
stores the corpus in a Prolog-like logical form and
searches using unification matching. LPath is an
extension of XPath with three features: immedi-
ate precedence, subtree scoping and edge alignment.
The queries are executed in an SQL database (Lai
and Bird, 2004). Other tree query languages include
CorpusSearch, Gsearch, Linguist’s Search Engine,
Netgraph, TIQL, VIQTORYA etc.
Some tools go beyond the tree model and al-
low multiple intersecting hierarchies. Emu (Cas-
sidy and Harrington, 2001) supports sequential lev-
els of annotations over speech datasets. Hierarchi-
cal relations may exist between tokens in different
levels, but precedence is defined only between el-
ements within the same level. The queries cannot
</bodyText>
<footnote confidence="0.9988875">
1http://tedlab.mit.edu/—dr/Tgrep2/
2http://www.ims.uni-stuttgart.de/projekte/TIGER/TIGERSearch/
</footnote>
<bodyText confidence="0.9997">
express immediate precedence and are executed us-
ing a linear search. NiteQL is the query language
for the MATE annotation workbench (McKelvie et
al., 2001). It is highly expressive and, similarly to
TIGERSearch, allows quering of intersecting hier-
archies. However, the system uses XML for stor-
age and retrieval, with an in-memory representation,
which may limit its scalability.
Bird and Liberman (2001) introduce an abstract
general annotation approach, based on annotation
graphs.3 The model is best suited for speech data,
where time constraints are limited within an inter-
val, but it is unnecessarily complex for supporting
annotations on written text.
</bodyText>
<sectionHeader confidence="0.989112" genericHeader="method">
3 The Layered Query Language
</sectionHeader>
<bodyText confidence="0.986637">
Our framework differs from others by simultane-
ously supporting several key features:
</bodyText>
<listItem confidence="0.999277076923077">
• Multiple overlapping layers (which cannot be
expressed in a single XML file), including self-
overlapping (e.g., a word shared by two phrases
from the same layer), and parallel layers, as
when multiple syntactic parses span the same
text.
• Integration of multiple intersecting hierarchies
(e.g., MeSH, UMLS, WordNet).
• Flexible results format.
• Tight integration with SQL, including applica-
tion of SQL operators over the returned results.
• Scalability to large collections such as MED-
LINE (containing millions of documents).4
</listItem>
<bodyText confidence="0.998489454545455">
While existing systems possess some of these fea-
tures, none offers all of them.
We assume that the underlying text is fairly static.
While we support addition, removal and editing of
annotations via a Java API, we do not optimize for
efficient editing, but instead focus on compact rep-
resentation, easy query formulation, easy addition
and removal of layers, and straightforward trans-
lation into SQL. Below we illustrate our Layered
Query Language (LQL) using examples from bio-
science NLP.5
</bodyText>
<footnote confidence="0.92256">
3http://agtk.sourceforge.net/
4http://www.nlm.nih.gov/pubs/factsheets/medline.html
5See http://biotext.berkeley.edu/lql/ for a formal description
of the language and additional examples.
</footnote>
<bodyText confidence="0.996033787878788">
Figure 1 illustrates the layered annotation of a
sentence from biomedical text. Each annotation rep-
resents an interval spanning a sequence of charac-
ters, using absolute beginning and ending positions.
Each layer corresponds to a conceptually different
kind of annotation (e.g., word, gene/protein6, shal-
low parse). Layers can be sequential, overlapping
(e.g., two concepts sharing the same word), and hi-
erarchical (either spanning, when the intervals are
nested as in a parse tree, or ontologically, when the
token itself is derived from a hierarchical ontology).
Word, POS and shallow parse layers are sequen-
tial (the latter can skip or span multiple words). The
gene/protein layer assigns IDs from the LocusLink
database of gene names.7 For a given gene there are
as many LocusLink IDs as the number of organisms
it is found in (e.g., 4 in the case of the gene Bcl-2).
The MeSH layer contains entities from the hier-
archical medical ontology MeSH (Medical Subject
Headings).8 The MeSH annotations on Figure 1 are
overlapping (share the word cell) and hierarchical
both ways: spanning, since blood cell (with MeSH
id D001773) orthographically spans the word cell
(id A11), and ontologically, since blood cell is a kind
of cell and cell death (id D016923) is a kind of Bio-
logical Phenomena.
Given this annotation, we can extract potential
protein-protein interactions from MEDLINE text.
One simple approach is to follow (Blaschke et al.,
1999), who developed a list of verbs (and their de-
rived forms) and scanned for sentences containing
the pattern PROTEIN ... INTERACTION-VERB ...
PROTEIN. This can be expressed in LQL as follows:
</bodyText>
<equation confidence="0.971376857142857">
FROM
[layer=’sentence’ { ALLOW GAPS }
[layer=’protein’] AS prot1
[layer=’pos’ &amp;&amp; tag_type=&amp;quot;verb&amp;quot; &amp;&amp;
content=’activates’]
[layer=’protein’] AS prot2
] SELECT prot1.content, prot2.content
</equation>
<bodyText confidence="0.9989434">
This example extracts sentences containing a pro-
tein name in the gene/protein layer, followed by any
sequence of words (because of ALLOW GAPS), fol-
lowed by the interaction verb activates, followed by
any sequence of words, and finally followed by an-
</bodyText>
<footnote confidence="0.99987275">
6Genes and their corresponding proteins often share the
same name and the difference between them is often elided.
7http://www.ncbi.nlm.nih.gov/LocusLink
8http://www.nlm.nih.gov/mesh/meshhome.html
</footnote>
<figureCaption confidence="0.999976">
Figure 1: Illustration of the annotation layers. The full parse, sentence and section layers are not shown.
</figureCaption>
<bodyText confidence="0.993405647058823">
other protein name. All possible protein matches
within the same sentence will be returned. The re-
sults are presented as pairs of protein names.
Each query level specifies a layer (e.g., sentence,
part-of-speech, gene/protein) and optional restric-
tions on the attribute values. A binding statement
is allowed after the layer’s closing bracket. We
can search for more than one verb simultaneously,
e.g., by changing the POS layer of the query above
to [layer=’pos’ &amp;&amp; (content=’activates’
 ||content=’inhibit’  ||content=’binds’)].
Further, a wildcard like content  ’activate%’
can match the verb forms activate, activates and
activated. We can also use double quotes &amp;quot; to make
the comparison case insensitive. Finally, since LQL
is automatically translated into SQL, SQL code
can be written to surround the LQL query and to
reference its results, thus allowing the use of SQL
operators such as GROUP BY, COUNT, DISTINCT,
ORDER BY, etc., as well as set operations like UNION.
Now consider the task of extracting interactions
between chemicals and diseases. Given the sen-
tence “Adherence to statin prevents one coronary
heart disease event for every 429 patients.”, we
want to extract the relation that statin (potentially)
prevents coronary heart disease. The latter is in
the MeSH hierarchy (id D003327) with tree codes
C14.280.647.250 and C14.907.553.470.250, while
the former is listed in the MeSH supplementary con-
cepts (ID C047068). In fact, the whole C subtree
in MeSH contains diseases and all supplementary
MeSH concepts represent chemicals. So we can find
potentially useful sentences (to be further processed
by another algorithm) using the following query:
</bodyText>
<equation confidence="0.7201641">
FROM
[layer=’sentence’ {NO ORDER, ALLOW GAPS}
[layer=’shallow_parse’ &amp;&amp; tag_type=’NP’
[layer=’chemicals’] AS chem $
]
[layer=’shallow_parse’ &amp;&amp; tag_type=’NP’
[layer=’MeSH’ &amp;&amp; label BELOW &amp;quot;C&amp;quot;] AS dis $
]
] AS sent
SELECT chem.content,dis.content,sent.content
</equation>
<bodyText confidence="0.9797655">
This looks for sentences containing two NPs in any
order without overlaps (NO ORDER) and separated by
any number of intervening elements. We further re-
quire one of the NPs to end (ensured by the $ sym-
bol) with a chemical, and the other (the disease) to
end with a MeSH term from the C subtree.
</bodyText>
<sectionHeader confidence="0.97589" genericHeader="method">
4 System Architecture
</sectionHeader>
<bodyText confidence="0.995693333333333">
Our basic model is similar to that of TIPSTER (Gr-
ishman, 1996): each annotation is stored as a record,
which specifies the character-level beginning and
ending positions, the layer and the type. The ba-
sic table9 contains the following columns: (1) an-
notation id; (2) doc id; (3) section: title, abstract
or body; (4) layer id: layer identifier (word, POS,
shallow parse, sentence, etc.); (5) start char pos:
beginning character position, relative to section and
doc id; (6) end char pos: ending character posi-
tion; (7) tag type: a layer-specific token identifier.
After evaluating various different extensions
of the structure above, we have arrived at one
with some additional columns, which improves
cross-layer query performance: (8) sentence id;
(9) word id; (10) first word pos; and (11)
last word pos. Columns (9)-(11) treat the word
layer as atomic and require all annotations to coin-
cide with word boundaries.
Finally, we use two types of composite indexes:
forward, which looks for positions in a given docu-
ment, and inverted, which supports searching based
on annotation values.10 An index lookup can be per-
formed on any column combination that corresponds
to an index prefix. An RDBMS’ query optimizer
estimates the optimal access paths (index and table
scans), and join orders based on statistics collected
over the stored records. In complex queries a com-
bination of forward (F) and inverted (I) indexes is
typically used. The particular ones we used are:11
(F) +doc id+section+layer id+sentence
+first word pos+last word pos+tag type
(I) +layer id+tag type+doc id+section+sentence
+first word pos+last word pos
(I) +word id+layer id+tag type+doc id+section
+sentence+first word pos
We have experimented with the system on a col-
lection of 1.4 million MEDLINE abstracts, which
include 10 million sentences annotated with 320
million multi-layered annotations. The current data-
base size is around 70 GB. Annotations are indexed
as they are inserted into the database.
</bodyText>
<footnote confidence="0.994402142857143">
9There are some additional tables mapping token IDs to en-
tities (the string in case of a word, the MeSH label(s) in case of
a MeSH term etc.)
10These inverted indexes can be seen as a direct extension of
the widely used inverted file indexes in traditional IR systems.
11There is also an index on annotation id, which allows for
annotating relations between annotations.
</footnote>
<bodyText confidence="0.999482333333333">
Our initial evaluation shows variation in the exe-
cution time, depending on the kind and complexity
of the query. Response time for simple queries is
usually less than a minute, while for more complex
ones it can be much longer. We are in the process of
further investigating and tuning the system.
</bodyText>
<sectionHeader confidence="0.998736" genericHeader="conclusions">
5 Conclusions and Future Work
</sectionHeader>
<bodyText confidence="0.999963294117647">
We have provided a mechanism to effectively store
and query layers of textual annotations, focusing
on compact representation, easy query formulation,
easy addition and removal of layers, and straight-
forward translation into SQL. Using a collection of
1.4 MEDLINE abstracts, we have evaluated vari-
ous structures for data storage and have arrived at
a promising one.
We have also designed a concise language (LQL)
to express queries that span multiple levels of anno-
tation structure, allowing users to express queries in
a syntax that closely resembles the underlying anno-
tation structure. We plan to release the software to
the research community for use in their own annota-
tion and querying needs.
Acknowledgements This research was supported
by NSF DBI-0317510 and a gift from Genentech.
</bodyText>
<sectionHeader confidence="0.999494" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999078652173913">
Steven Bird and Mark Liberman. 2001. A formal framework
for linguistic annotation. Speech Communication, 33(1-
2):23–60.
Steven Bird, Yi Chen, Susan Davidson, Haejoong Lee, and
Yifeng Zheng. 2005. Extending XPath to support linguis-
tic queries. In Proceedings of PLANX, pages 35–46.
Christian Blaschke, Miguel Andrade, Christos Ouzounis, and
Alfonso Valencia. 1999. Automatic extraction of biological
information from scientific text: Protein-protein interactions.
In Proceedings of ISMB, pages 60–67.
Steve Cassidy and Jonathan Harrington. 2001. Multi-level an-
notation in the Emu speech database management system.
Speech Communication, 33(1-2):61–77.
Ralph Grishman. 1996. Building an architecture: a CAWG
saga. Advances in Text Processing: Tipster Program Ph. II.
Catherine Lai and Steven Bird. 2004. Querying and updating
treebanks: A critical survey and requirements analysis. In
Proceedings Australasian Language Technology Workshop,
pages 139–146.
David McKelvie, Amy Isard, Andreas Mengel, Morten Moeller,
Michael Grosse, and Marion Klein. 2001. The MATE work-
bench - an annotation tool for XML coded speech corpora.
Speech Communication, 33(1-2):97–112.
</reference>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.795043">
<title confidence="0.999981">Supporting Annotation Layers for Natural Language Processing</title>
<author confidence="0.999139">Preslav Nakov</author>
<author confidence="0.999139">Ariel Schwartz</author>
<author confidence="0.999139">Brian Wolf</author>
<affiliation confidence="0.999236">Computer Science Division University of California, Berkeley</affiliation>
<address confidence="0.999805">Berkeley, CA 94720</address>
<author confidence="0.996559">Marti Hearst</author>
<affiliation confidence="0.960809">SIMS University of California, Berkeley</affiliation>
<address confidence="0.999708">Berkeley, CA 94720</address>
<email confidence="0.998832">hearst@sims.berkeley.edu</email>
<abstract confidence="0.987757454545455">We demonstrate a system for flexible querying against text that has been annotated with the results of NLP processing. The system supports self-overlapping and parallel layers, integration of syntactic and ontological hierarchies, flexibility in the format of returned results, and tight integration with SQL. We present a query language and its use on examples taken from the NLP literature.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Steven Bird</author>
<author>Mark Liberman</author>
</authors>
<title>A formal framework for linguistic annotation.</title>
<date>2001</date>
<journal>Speech Communication,</journal>
<pages>33--1</pages>
<contexts>
<context position="3690" citStr="Bird and Liberman (2001)" startWordPosition="543" endWordPosition="546">etween tokens in different levels, but precedence is defined only between elements within the same level. The queries cannot 1http://tedlab.mit.edu/—dr/Tgrep2/ 2http://www.ims.uni-stuttgart.de/projekte/TIGER/TIGERSearch/ express immediate precedence and are executed using a linear search. NiteQL is the query language for the MATE annotation workbench (McKelvie et al., 2001). It is highly expressive and, similarly to TIGERSearch, allows quering of intersecting hierarchies. However, the system uses XML for storage and retrieval, with an in-memory representation, which may limit its scalability. Bird and Liberman (2001) introduce an abstract general annotation approach, based on annotation graphs.3 The model is best suited for speech data, where time constraints are limited within an interval, but it is unnecessarily complex for supporting annotations on written text. 3 The Layered Query Language Our framework differs from others by simultaneously supporting several key features: • Multiple overlapping layers (which cannot be expressed in a single XML file), including selfoverlapping (e.g., a word shared by two phrases from the same layer), and parallel layers, as when multiple syntactic parses span the same</context>
</contexts>
<marker>Bird, Liberman, 2001</marker>
<rawString>Steven Bird and Mark Liberman. 2001. A formal framework for linguistic annotation. Speech Communication, 33(1-2):23–60.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Steven Bird</author>
<author>Yi Chen</author>
<author>Susan Davidson</author>
<author>Haejoong Lee</author>
<author>Yifeng Zheng</author>
</authors>
<title>Extending XPath to support linguistic queries.</title>
<date>2005</date>
<booktitle>In Proceedings of PLANX,</booktitle>
<pages>35--46</pages>
<contexts>
<context position="1963" citStr="Bird et al. (2005)" startWordPosition="289" endWordPosition="292">and an indexing architecture for efficient retrieval, built on top of a relational database management system (RDBMS). The model allows for both hierarchical and overlapping layers of annotation as well as for querying at multiple levels of description. In the remainder of the paper we describe related work, illustrate the annotation model and the query language and describe the indexing architecture and the experimental results, thus showing the feasibility of the approach for a variety of NLP tasks. 2 Related Work There are several specialized tools for indexing and querying treebanks. (See Bird et al. (2005) for an overview and critical comparisons.) TGrep21 is a a grep-like utility for the Penn Treebank corpus of parsed Wall Street Journal texts. It allows Boolean expressions over nodes and regular expressions inside nodes. Matching uses a binary index and is performed recursively starting at the top node in the query. TIGERSearch2 is associated with the German syntactic corpus TIGER. The tool is more typed than TGrep2 and allows search over discontinuous constituents that are common in German. TIGERSearch stores the corpus in a Prolog-like logical form and searches using unification matching. L</context>
</contexts>
<marker>Bird, Chen, Davidson, Lee, Zheng, 2005</marker>
<rawString>Steven Bird, Yi Chen, Susan Davidson, Haejoong Lee, and Yifeng Zheng. 2005. Extending XPath to support linguistic queries. In Proceedings of PLANX, pages 35–46.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Christian Blaschke</author>
<author>Miguel Andrade</author>
<author>Christos Ouzounis</author>
<author>Alfonso Valencia</author>
</authors>
<title>Automatic extraction of biological information from scientific text: Protein-protein interactions.</title>
<date>1999</date>
<booktitle>In Proceedings of ISMB,</booktitle>
<pages>60--67</pages>
<contexts>
<context position="6708" citStr="Blaschke et al., 1999" startWordPosition="1004" endWordPosition="1007"> found in (e.g., 4 in the case of the gene Bcl-2). The MeSH layer contains entities from the hierarchical medical ontology MeSH (Medical Subject Headings).8 The MeSH annotations on Figure 1 are overlapping (share the word cell) and hierarchical both ways: spanning, since blood cell (with MeSH id D001773) orthographically spans the word cell (id A11), and ontologically, since blood cell is a kind of cell and cell death (id D016923) is a kind of Biological Phenomena. Given this annotation, we can extract potential protein-protein interactions from MEDLINE text. One simple approach is to follow (Blaschke et al., 1999), who developed a list of verbs (and their derived forms) and scanned for sentences containing the pattern PROTEIN ... INTERACTION-VERB ... PROTEIN. This can be expressed in LQL as follows: FROM [layer=’sentence’ { ALLOW GAPS } [layer=’protein’] AS prot1 [layer=’pos’ &amp;&amp; tag_type=&amp;quot;verb&amp;quot; &amp;&amp; content=’activates’] [layer=’protein’] AS prot2 ] SELECT prot1.content, prot2.content This example extracts sentences containing a protein name in the gene/protein layer, followed by any sequence of words (because of ALLOW GAPS), followed by the interaction verb activates, followed by any sequence of words, a</context>
</contexts>
<marker>Blaschke, Andrade, Ouzounis, Valencia, 1999</marker>
<rawString>Christian Blaschke, Miguel Andrade, Christos Ouzounis, and Alfonso Valencia. 1999. Automatic extraction of biological information from scientific text: Protein-protein interactions. In Proceedings of ISMB, pages 60–67.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Steve Cassidy</author>
<author>Jonathan Harrington</author>
</authors>
<title>Multi-level annotation in the Emu speech database management system.</title>
<date>2001</date>
<journal>Speech Communication,</journal>
<pages>33--1</pages>
<contexts>
<context position="2967" citStr="Cassidy and Harrington, 2001" startWordPosition="444" endWordPosition="448">pus TIGER. The tool is more typed than TGrep2 and allows search over discontinuous constituents that are common in German. TIGERSearch stores the corpus in a Prolog-like logical form and searches using unification matching. LPath is an extension of XPath with three features: immediate precedence, subtree scoping and edge alignment. The queries are executed in an SQL database (Lai and Bird, 2004). Other tree query languages include CorpusSearch, Gsearch, Linguist’s Search Engine, Netgraph, TIQL, VIQTORYA etc. Some tools go beyond the tree model and allow multiple intersecting hierarchies. Emu (Cassidy and Harrington, 2001) supports sequential levels of annotations over speech datasets. Hierarchical relations may exist between tokens in different levels, but precedence is defined only between elements within the same level. The queries cannot 1http://tedlab.mit.edu/—dr/Tgrep2/ 2http://www.ims.uni-stuttgart.de/projekte/TIGER/TIGERSearch/ express immediate precedence and are executed using a linear search. NiteQL is the query language for the MATE annotation workbench (McKelvie et al., 2001). It is highly expressive and, similarly to TIGERSearch, allows quering of intersecting hierarchies. However, the system uses</context>
</contexts>
<marker>Cassidy, Harrington, 2001</marker>
<rawString>Steve Cassidy and Jonathan Harrington. 2001. Multi-level annotation in the Emu speech database management system. Speech Communication, 33(1-2):61–77.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ralph Grishman</author>
</authors>
<title>Building an architecture: a CAWG saga.</title>
<date>1996</date>
<booktitle>Advances in Text Processing: Tipster Program Ph.</booktitle>
<location>II.</location>
<contexts>
<context position="9940" citStr="Grishman, 1996" startWordPosition="1493" endWordPosition="1495">’ {NO ORDER, ALLOW GAPS} [layer=’shallow_parse’ &amp;&amp; tag_type=’NP’ [layer=’chemicals’] AS chem $ ] [layer=’shallow_parse’ &amp;&amp; tag_type=’NP’ [layer=’MeSH’ &amp;&amp; label BELOW &amp;quot;C&amp;quot;] AS dis $ ] ] AS sent SELECT chem.content,dis.content,sent.content This looks for sentences containing two NPs in any order without overlaps (NO ORDER) and separated by any number of intervening elements. We further require one of the NPs to end (ensured by the $ symbol) with a chemical, and the other (the disease) to end with a MeSH term from the C subtree. 4 System Architecture Our basic model is similar to that of TIPSTER (Grishman, 1996): each annotation is stored as a record, which specifies the character-level beginning and ending positions, the layer and the type. The basic table9 contains the following columns: (1) annotation id; (2) doc id; (3) section: title, abstract or body; (4) layer id: layer identifier (word, POS, shallow parse, sentence, etc.); (5) start char pos: beginning character position, relative to section and doc id; (6) end char pos: ending character position; (7) tag type: a layer-specific token identifier. After evaluating various different extensions of the structure above, we have arrived at one with </context>
</contexts>
<marker>Grishman, 1996</marker>
<rawString>Ralph Grishman. 1996. Building an architecture: a CAWG saga. Advances in Text Processing: Tipster Program Ph. II.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Catherine Lai</author>
<author>Steven Bird</author>
</authors>
<title>Querying and updating treebanks: A critical survey and requirements analysis.</title>
<date>2004</date>
<booktitle>In Proceedings Australasian Language Technology Workshop,</booktitle>
<pages>139--146</pages>
<contexts>
<context position="2736" citStr="Lai and Bird, 2004" startWordPosition="412" endWordPosition="415">oolean expressions over nodes and regular expressions inside nodes. Matching uses a binary index and is performed recursively starting at the top node in the query. TIGERSearch2 is associated with the German syntactic corpus TIGER. The tool is more typed than TGrep2 and allows search over discontinuous constituents that are common in German. TIGERSearch stores the corpus in a Prolog-like logical form and searches using unification matching. LPath is an extension of XPath with three features: immediate precedence, subtree scoping and edge alignment. The queries are executed in an SQL database (Lai and Bird, 2004). Other tree query languages include CorpusSearch, Gsearch, Linguist’s Search Engine, Netgraph, TIQL, VIQTORYA etc. Some tools go beyond the tree model and allow multiple intersecting hierarchies. Emu (Cassidy and Harrington, 2001) supports sequential levels of annotations over speech datasets. Hierarchical relations may exist between tokens in different levels, but precedence is defined only between elements within the same level. The queries cannot 1http://tedlab.mit.edu/—dr/Tgrep2/ 2http://www.ims.uni-stuttgart.de/projekte/TIGER/TIGERSearch/ express immediate precedence and are executed usi</context>
</contexts>
<marker>Lai, Bird, 2004</marker>
<rawString>Catherine Lai and Steven Bird. 2004. Querying and updating treebanks: A critical survey and requirements analysis. In Proceedings Australasian Language Technology Workshop, pages 139–146.</rawString>
</citation>
<citation valid="true">
<authors>
<author>David McKelvie</author>
<author>Amy Isard</author>
<author>Andreas Mengel</author>
<author>Morten Moeller</author>
<author>Michael Grosse</author>
<author>Marion Klein</author>
</authors>
<title>The MATE workbench - an annotation tool for XML coded speech corpora.</title>
<date>2001</date>
<journal>Speech Communication,</journal>
<pages>33--1</pages>
<contexts>
<context position="3442" citStr="McKelvie et al., 2001" startWordPosition="506" endWordPosition="509">, Netgraph, TIQL, VIQTORYA etc. Some tools go beyond the tree model and allow multiple intersecting hierarchies. Emu (Cassidy and Harrington, 2001) supports sequential levels of annotations over speech datasets. Hierarchical relations may exist between tokens in different levels, but precedence is defined only between elements within the same level. The queries cannot 1http://tedlab.mit.edu/—dr/Tgrep2/ 2http://www.ims.uni-stuttgart.de/projekte/TIGER/TIGERSearch/ express immediate precedence and are executed using a linear search. NiteQL is the query language for the MATE annotation workbench (McKelvie et al., 2001). It is highly expressive and, similarly to TIGERSearch, allows quering of intersecting hierarchies. However, the system uses XML for storage and retrieval, with an in-memory representation, which may limit its scalability. Bird and Liberman (2001) introduce an abstract general annotation approach, based on annotation graphs.3 The model is best suited for speech data, where time constraints are limited within an interval, but it is unnecessarily complex for supporting annotations on written text. 3 The Layered Query Language Our framework differs from others by simultaneously supporting severa</context>
</contexts>
<marker>McKelvie, Isard, Mengel, Moeller, Grosse, Klein, 2001</marker>
<rawString>David McKelvie, Amy Isard, Andreas Mengel, Morten Moeller, Michael Grosse, and Marion Klein. 2001. The MATE workbench - an annotation tool for XML coded speech corpora. Speech Communication, 33(1-2):97–112.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>