<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<title confidence="0.9975215">
Compiling Regular Formalisms with Rule Features into
Finite-State Automata
</title>
<author confidence="0.506556">
George Anton Kiraz
</author>
<affiliation confidence="0.418293">
Bell Laboratories
</affiliation>
<address confidence="0.687745">
Lucent Technologies
700 Mountain Ave.
Murray Hill, NJ 07974, USA
</address>
<email confidence="0.925321">
gkirazOresearch.bell-labs.com
</email>
<sectionHeader confidence="0.996499" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.998936">
This paper presents an algorithm for the
compilation of regular formalisms with rule
features into finite-state automata. Rule
features are incorporated into the right
context of rules. This general notion
can also be applied to other algorithms
which compile regular rewrite rules into au-
tomata.
</bodyText>
<sectionHeader confidence="0.999393" genericHeader="keywords">
1 Introduction
</sectionHeader>
<bodyText confidence="0.999098956521739">
The past few years have witnessed an increased in-
terest in applying finite-state methods to language
and speech problems. This in turn generated inter-
est in devising algorithms for compiling rules which
describe regular languages/relations into finite-state
automata.
It has long been proposed that regular formalisms
(e.g., rewrite rules, two-level formalisms) accom-
modate rule features which provide for finer and
more elegant descriptions (Bear, 1988). Without
such a mechanism, writing complex grammars (say
two-level grammars for Syriac or Arabic morphol-
ogy) would be difficult, if not impossible. Algo-
rithms which compile regular grammars into au-
tomata (Kaplan and Kay, 1994; Mohri and Sproat,
1996; Grimley-Evans, Kiraz, and Pulman, 1996) do
not make use of this important mechanism. This pa-
per presents a method for incorporating rule features
in the resulting automata.
The following Syriac example is used here, with
the infamous Semitic root {ktb} &apos;notion of writ-
ing&apos;. The verbal pa&amp;quot;el measure&apos;, /katteb/2 &apos;wrote
CAUSATIVE ACTIVE&apos;, is derived from the following
</bodyText>
<footnote confidence="0.95932425">
1Syriac verbs are classified under various measures
(i.e., forms), the basic ones being p`al, pa &amp;quot;el and &apos;eel.
2Spirantization is ignored here; for a discussion on
Syriac spirantization, see (Kiraz, 1995).
</footnote>
<bodyText confidence="0.96728425">
morphemes: the pattern {cvcvc} &apos;verbal pattern&apos;,
the above mentioned root, and the vocalism {ae}
&apos;ACTIVE&apos;. The morphemes produce the following un-
derlying form:3
</bodyText>
<equation confidence="0.752896">
a e
cvcvc =*/kateb/
I
k t b
</equation>
<bodyText confidence="0.999430142857143">
/katteb/ is derived then by the gemination, implying
CAUSATIVE, of the middle consonant, [t].4
The current work assumes knowledge of regular
relations (Kaplan and Kay, 1994). The following
convention has been adopted. Lexical forms (e.g.,
morphemes in morphology) appear in braces, {
phonological segments in square brackets, [], and
elements of tuples in angle brackets, ( ).
Section 2 describes a regular formalism with rule
features. Section 3 introduce a number of mathe-
matical operators used in the compilation process.
Sections 4 and 5 present our algorithm. Finally, sec-
tion 6 provides an evaluation and some concluding
remarks.
</bodyText>
<sectionHeader confidence="0.979017" genericHeader="introduction">
2 Regular Formalism with Rule
Features
</sectionHeader>
<bodyText confidence="0.998817">
This work adopts the following notation for regular
formalisms, cf. (Kaplan and Kay, 1994):
</bodyText>
<equation confidence="0.933448">
(1)
</equation>
<bodyText confidence="0.998888333333333">
where r, A and p are n-way regular expressions which
describe same-length relations.&apos; (An n-way regu-
lar expression is a regular expression whose terms
</bodyText>
<footnote confidence="0.996838375">
3This analysis is along the lines of (McCarthy, 1981)
— based on autosegmental phonology (Goldsmith, 1976).
4This derivation is based on the linguistic model pro-
posed by (Kiraz, 1996).
5More &apos;user-friendly&apos; notations which allow mapping
expressions of unequal length (e.g., (Grimley-Evans, Ki-
raz, and Pulman, 1996)) are mathematically equivalent
to the above notation after rules are converted into same-
</footnote>
<page confidence="0.987546">
329
</page>
<equation confidence="0.994936555555555">
R1 k:c1:k:0
R2 b:c3:b:0
R3 a:v:0:a
R4 e:v:0:e
Ft5 t:c2:t:0 t:0:0:0
([catz=verb], [measure=pa&amp;quot;el], [])
R6 t:c2:t:0
([cat=verb], [measure=p`al], [])
R7 0:v:0:a .4* _ t:c2:t:0 a:v:0:a
</equation>
<figure confidence="0.72983">
Sublexicon Entry Feature Structure
Pattern ci vc2vc3 [cat=verb]
Root ktb [measure=(p`al,pa&amp;quot;el)t]
Vocalism ae [voice=active,
aa measure=pa&amp;quot;el]
[voice=active,
measure=p`al]
tParenthesis denote disjunction over the given values.
</figure>
<figureCaption confidence="0.9999095">
Figure 2: Simple Syriac Lexicon
Figure 1: Simple Syriac Grammar
</figureCaption>
<bodyText confidence="0.9996881">
are n-tuples of alphabetic symbols or the empty
string 6. A same-length relation is devoid of e. For
clarity, the elements of the n-tuple are separated
by colons: e.g., a:b:c* q:r:s describes the 3-relation
{ (am q , bmr, cm s) I m &gt; 0 }. Following current ter-
minology, we call the first j elements `surface&apos;6 and
the remaining elements `lexical&apos;.) The arrows corre-
spond to context restriction (CR), surface coercion
(SC) and composite rules, respectively. A compound
rule takes the form
</bodyText>
<equation confidence="0.384502">
} Al A2 p2; (2)
</equation>
<bodyText confidence="0.997543333333333">
To accommodate for rule features, each rule may
be associated with an (n — j)-tuple of feature struc-
tures, each of the form
</bodyText>
<equation confidence="0.897085">
[attributei=vall , attribute2=val2, .] (3)
</equation>
<bodyText confidence="0.99821105882353">
i.e., an unordered set of attribute=val pairs. An
attribute is an atomic label. A val can be an atom or
a variable drawn from a predefined finite set of possi-
ble values.7 The ith element in the tuple corresponds
to the (j i)th element in rule expressions. As a
way of illustration, consider the simplified grammar
in Figure 1 with j = 1.
The four elements of the tuples are: surface, pat-
tern, root, and vocalism. R1 and R2 sanction the
first and third consonants, respectively. R3 and R4
sanction vowels. R5 is the gemination rule; it is
only triggered if the given rule features are satisfied:
[cat=verb] for the first lexical element (i.e., the pat-
tern) and [measure=pa&amp;quot;el] for the second element
(i.e., the root). The rule also illustrates that 7 can
be a sequence of tuples. The derivation of /katteb/
is illustrated below:
</bodyText>
<footnote confidence="0.993254">
length descriptions at some preprocessing stage.
6In natural language, usually j = 1.
7It is also possible to extend the above formalism in
order to allow val to be a category-feature structure,
though that takes us beyond finite-state power.
</footnote>
<equation confidence="0.366255">
vocalism
root
pattern
surface
</equation>
<bodyText confidence="0.9998789375">
The numbers between the lexical expressions and the
surface expression denote the rules in Figure 1 which
sanction the given lexical-surface mappings.
Rule features play a role in the semantics of rules:
a = states that if the contexts and rule features
are satisfied, the rule is triggered; a = states that
if the contexts, lexical expressions and rule features
are satisfied, then the rule is applied. For example,
although R5 is devoid of context expressions, the
rule is composite indicating that if the root measure
is pa &amp;quot;el, then gemination must occur and vice versa.
Note that in a compound rule, each set of contexts
is associated with a feature structure of its own.
What is meant by &apos;rule features are satisfied&apos;?
Regular grammars which make use of rule features
normally interact with a lexicon. In our model, the
lexicon consists of (n — sublexica corresponding
to the lexical elements in the formalism. Each sub-
lexical entry is associate with a feature structure.
Rule features are satisfied if they match the feature
structures of the lexical entries containing the lexical
expressions in 7, respectively. Consider the lexicon
in Figure 2 and rule R5 with 7 = t:c2:t:0 t:0:0:0 and
the rule features ([cat=verb], [measure=pa&amp;quot;el], []).
The lexical entries containing 7 are {ci vc,vc3} and
{ktb}, respectively. For the rule to be triggered,
[cat=verb] of the rule must match with [cat=verb]
of the lexical entry {c1vc2vc3}, and [measure=pa&amp;quot;el]
of the rule must match with [measure=(p`al,pa&amp;quot;e1)]
of the lexical entry {ktb}.
As a second illustration, R6 derives the simple p &apos;al
measure, /ktab/. Note that in R5 and R6,
</bodyText>
<listItem confidence="0.997827">
1. the lexical expressions in both rules (ignoring
Os) are equivalent,
2. both rules are composite, and
</listItem>
<figure confidence="0.9989635">
a 100
e 1
0
0
0 tOj 0 1 b
ci 1 v 1c201 v 1 c3
1 3 5 4 2
klalttlelb
</figure>
<page confidence="0.905965">
330
</page>
<bodyText confidence="0.921638857142857">
3. they have different surface expression in 7.
In traditional rewrite formalism, such rules will be
contradicting each other. However, this is not the
case here since R5 and R6 have different rule fea-
tures. The derivation of this measure is shown below
(R7 completes the derivation deleting the first vowel
on the surface8):
</bodyText>
<figure confidence="0.9861644">
0 a 01 a 0 vocalism
0 t to root
c11 v Ic21 V 3 pattern
1 7 6 3 2
kIOtab surface
</figure>
<bodyText confidence="0.9993885">
Note that in order to remain within finite-state
power, both the attributes and the values in feature
structures must be atomic. The formalism allows a
value to be a variable drawn from a predefined finite
set of possible atomic values. In the compilation
process, such variables are taken as the disjunction
of all possible predefined values.
Additionally, this version of rule feature match-
ing does not cater for rules whose 7 span over two
lexical forms. It is possible, of course, to avoid this
limitation by having rule features match the feature
structures of both lexical entries in such cases.
</bodyText>
<sectionHeader confidence="0.993746" genericHeader="method">
3 Mathematical Preliminaries
</sectionHeader>
<bodyText confidence="0.999930153846154">
We define here a number of operations which will be
used in our compilation process.
If an operator Op takes a number of arguments
(a,, • • • , at), the arguments are shown as a subscript,
e.g. Op(ai, ..,a&amp;quot; - the parentheses are ignored if there
is only one argument. When the operator is men-
tioned without reference to arguments, it appears
on its own, e.g. Op.
Operations which are defined on tuples of strings
can be extended to sets of tuples and relations. For
example, if S is a tuple of strings and Op(S) is an
operator defined on S, the operator can be extended
to a relation R in the following manner
</bodyText>
<equation confidence="0.940032">
Op(R) = {Op(S) SE R
Definition 3.1 (Identity) Let L be a regu-
</equation>
<bodyText confidence="0.976954666666667">
lar language. Id(L) = X I Xis an
n-tuple of the form (x, • • , x), x E L } is the n-way
identity of L.9
</bodyText>
<construct confidence="0.3754475">
Remark 3.1 If Id is applied to a string s, we simply
write 1d0(s) to denote the n-tuple (s, , s).
</construct>
<footnote confidence="0.9863395">
8Short vowels in open unstressed syllables are deleted
in Syriac.
8This is a generalization of the operator Id in (Kaplan
and Kay, 1994).
</footnote>
<bodyText confidence="0.986678083333334">
Definition 3.2 (Insertion) Let R be a regular re-
lation over the alphabet E and let in be a set of
symbols not necessarily in E. Insertm(R) inserts
the relation 1d0(a) for all a E in, freely throughout
R. Insert-1 o Insertm(R) = R removes all such
instances if in is disjoint from E.1°
Remark 3.2 We can define another form of Insert
where the elements in m. are tuples of symbols as fol-
lows: Let R be a regular relation over the alphabet
E and let m be a set of tuples of symbols not nec-
essarily in E. Insertm(R) inserts a, for all a E m,
freely throughout R.
</bodyText>
<equation confidence="0.878156833333333">
Definition 3.3 (Substitution) Let S and S&apos; be
same-length n-tuples of strings over the alphabet
(E x • • • x E), I = 1d0(a) for some a E E, and
S = SIIS2I • • • Sk, k &gt; 1, such that Si does not
contain I - i.e. Si E ((E x • x E) — .
Substitute(si)(S) = SIS&apos;52S1 • • Sk substitutes
every occurrence of I in S with 5&apos;.
Definition 3.4 (Projection) Let S = (s,,. , sn)
be a tuple of strings. Projecti(S), for some
E { 1, n }, denotes the tuple element si.
Pro j ectT 1 (S), for some i E { 1, n) denotes the
(n — 1)-tuple (Si,.. • , si-i, si+i, • • ,sn).
</equation>
<bodyText confidence="0.9990248">
The symbol 7 denotes &apos;feasible tuples&apos;, similar to
&apos;feasible pairs&apos; in traditional two-level morphology.
The number of surface expressions, j, is always 1.
The operator o represents mathematical composi-
tion, not necessarily the composition of transducers.
</bodyText>
<sectionHeader confidence="0.9749675" genericHeader="method">
4 Compilation without Rule
Features
</sectionHeader>
<bodyText confidence="0.99988525">
The current algorithm is motivated by the work of
(Grimley-Evans, Kiraz, and Pulman, 1996).11
Intuitively, the automata is built by three approx-
imations as follows:
</bodyText>
<listItem confidence="0.95513675">
1. Accepting 7s irrespective of any context.
2. Adding context restriction constraints
making the automata accept only the sequences
which appear in contexts described by the
grammar.
3. Forcing surface coercion constraints mak-
ing the automata accept all and only the se-
quences described by the grammar.
</listItem>
<footnote confidence="0.8300025">
1°This is similar to the operator Intro in (Kaplan and
Kay, 1994).
&amp;quot;The subtractive approach for compiling rules into
FSAs was first suggested by Edmund Grimley-Evans.
</footnote>
<page confidence="0.992969">
331
</page>
<subsectionHeader confidence="0.968997">
4.1 Accepting rs
</subsectionHeader>
<bodyText confidence="0.989736666666667">
Let T be the set of all rs in a regular grammar, p be
an auxiliary boundary symbol (not in the grammar&apos;s
alphabets) and p&apos; = Icin(p). The first approxima-
tion is described by
For all 7s, we subtract this expression from the
automaton under construction, yielding
</bodyText>
<equation confidence="0.9987985">
CR = Centers —U Restrict(r) (8)
Centers = R U 7)tir (4)
</equation>
<bodyText confidence="0.9736599">
rer
Centers accepts the symbols, p&apos;, followed by zero
or more TS, each (if any) followed by p&apos;. In other
words, the machine accepts all centers described by
the grammar (each center surrounded by p&apos;) irre-
spective of their contexts.
It is implementation dependent as to whether T
includes other correspondences which are not explic-
itly given in rules (e.g., a set of additional feasible
centers).
</bodyText>
<subsectionHeader confidence="0.975214">
4.2 Context Restriction Rules
</subsectionHeader>
<bodyText confidence="0.9836665">
For a given compound rule, the set of relations in
which r is invalid is
</bodyText>
<equation confidence="0.999684">
Restrict(r) = r* r7r*
eAkrpkr* (5)
</equation>
<bodyText confidence="0.95577475">
i.e., r in any context minus 7 in all valid contexts.
However, since in §4.1 above, the symbol p appears
freely, we need to introduce it in the above expres-
sion. The result becomes
</bodyText>
<equation confidence="0.9973075">
Restrict(r) = Insert(p) o (6)
7* T7*
</equation>
<bodyText confidence="0.982165">
The above expression is only valid if 7 consists of
only one tuple. However, to allow it to be a sequence
of such tuples as in R5 in Figure 1, it must be
</bodyText>
<listItem confidence="0.979424">
1. surrounded by p&apos; on both sides, and
2. devoid of p&apos;.
</listItem>
<bodyText confidence="0.999877">
The first condition is accomplished by simply plac-
ing p&apos; to the left and right of T. As for the sec-
ond condition, we use an auxiliary symbol, w, as a
place-holder representing T, introduce p freely, then
substitute r in place of w. Formally, let w be an
auxiliary symbol (not in the grammar&apos;s alphabet),
and let w&apos; = Id(w) be a place-holder representing
7. The above expression becomes
</bodyText>
<equation confidence="0.897548666666667">
Restrict(r) = Subst itut e(r, w&apos;) o (7)
Insert{} o
— U 7r* Ak p&apos;w&apos;plpk 7r*
</equation>
<bodyText confidence="0.97999425">
CR now accepts only the sequences of tuples
which appear in contexts in the grammar (but in-
cluding the partitioning symbols p&apos;); however, it
does not force surface coercion constraints.
</bodyText>
<subsectionHeader confidence="0.996818">
4.3 Surface Coercion Rules
</subsectionHeader>
<bodyText confidence="0.999687">
Let T/ represent the center of the rule with the cor-
rect lexical expressions and the incorrect surface ex-
pressions with respect to 7* ,
</bodyText>
<equation confidence="0.973995">
= Projecti(r) x Projecti-1(7) (9)
</equation>
<bodyText confidence="0.862403">
The coerce relation for a compound rule can be
simply expressed by12
</bodyText>
<equation confidence="0.9901755">
Coerce(Ti) = Insert{} o (10)
uAk p/ 7,83,pk
</equation>
<bodyText confidence="0.999295">
The two p&apos;s surrounding 7&apos; ensure that coercion ap-
plies on at least one center of the rule.
For all such expressions, we subtract Coerce from
the automaton under construction, yielding
</bodyText>
<equation confidence="0.880823">
SC = CR —UC oerce(r) (11)
</equation>
<bodyText confidence="0.998731615384616">
SC now accepts all and only the sequences of tu-
ples described by the grammar (but including the
partitioning symbols p&apos;).
It remains only to remove all instances of p from
the final machine, determinize and minimize it.
There are two methods for interpreting transduc-
ers. When interpreted as acceptors with n-tuples
of symbols on each transition, they can be deter-
minized using standard algorithms (Hoperoft and
Ullman, 1979). When interpreted as a transduc-
tion that maps an input to an output, they can-
not always be turned into a deterministic form (see
(Mohri, 1994; Roche and Schabes, 1995)).
</bodyText>
<sectionHeader confidence="0.951166" genericHeader="method">
5 Compilation with Rule Features
</sectionHeader>
<bodyText confidence="0.8677255">
This section shows how feature structures which are
associated with rules and lexical entries can be in-
corporated into FSAs.
&apos;A special case can be added for epenthetic rules.
</bodyText>
<page confidence="0.969592">
332
</page>
<figure confidence="0.9885195">
Entry Feature Structure
abcd fi
ef 12
ghi
</figure>
<figureCaption confidence="0.999779">
Figure 3: Lexicon Example
</figureCaption>
<subsectionHeader confidence="0.946005">
5.1 Intuitive Description
</subsectionHeader>
<bodyText confidence="0.951870222222222">
We shall describe our handling of rule features with a
two-level example. Consider the following analysis.
Lexical
Surface
The lexical expression contains the lexical forms
{ef} and {ghi}, separated by a boundary
symbol, 1, which designates the end of a lexical entry.
The numbers between the tapes represent the rules
(in some grammar) which allow the given lexical-
surface mappings.
Assume that the above lexical forms are associ-
ated in the lexicon with the feature structures as in
Figure 3. Further, assume that each two-level rule
m, 1 &lt; m &lt; 10, above is associated with the fea-
ture structure Fm. Hence, in order for the above
two-level analysis to be valid, the following feature
structures must match
All the structures ... must match
</bodyText>
<equation confidence="0.991551333333333">
, F2,F3,F 4 11
F6,F7 12
F8,F9,F10 13
</equation>
<bodyText confidence="0.9483436">
Usually, boundary rules, e.g. rule 5 above, are not
associated with feature structures, though there is
nothing stopping the grammar writer from doing so.
To match the feature structures associated with
rules and those in the lexicon we proceed as follows.
Firstly, we suffix each lexical entry in the lexicon
with the boundary symbol, I), and it&apos;s feature struc-
ture. (For simplicity, we consider a feature struc-
ture with instantiated values to be an atomic object
of length one which can be a label of a transition
in a FSA.)13 Hence the above lexical forms become:
`abcd bfi &apos;ef bf2&apos;, and `ghi bf3&apos;. Secondly, we incor-
porate a feature structure of a rule into the rule&apos;s
right context, p. For example, if p of rule 1 above is
b:b c:c, the context becomes
b:b c:c 7r* 0:F1 (12)
(this simplified version of the expression suffices for
the moment). In other words, in order for a:a to be
sanctioned, it must be followed by the sequence:
13As to how this is done is a matter of implementation.
</bodyText>
<listItem confidence="0.995709">
1. b:b c:c, i.e., the original right context;
2. any feasible tuple, 7r* ; and
3. the rule&apos;s feature structure which is deleted on
the surface, 0:F1.
</listItem>
<bodyText confidence="0.99704225">
This will succeed if only if F1 (of rule 1) and 11 (of
the lexical entry) were identical. The above analysis
is repeated below with the feature structures incor-
porated into p.
</bodyText>
<equation confidence="0.924870333333333">
alb I c Id ri) lei f Hf21 gihli Mf3 Lexical
1 2 3 4 5 6 7 5 8 9 10 5
alblcId10101elf10101gihli1010 Surface
</equation>
<bodyText confidence="0.999920857142857">
As indicated earlier, in order to remain within
finite-state power, all values in a feature structure
must be instantiated. Since the formalism allows
values to be variables drawn from a predefined finite
set of possible values, variables entered by the user
are replaced by a disjunction over all the possible
values.
</bodyText>
<subsectionHeader confidence="0.999895">
5.2 Compiling the Lexicon
</subsectionHeader>
<bodyText confidence="0.9999695">
Our aim is to construct a FSA which accepts any
lexical entry from the ith sublexicon on its j ith
tape.
A lexical entry it (e.g., morpheme) which is asso-
ciated with a feature structure 0 is simply expressed
by pbck, where I? is a (morpheme) boundary symbol
which is not in the alphabet of the lexicon. The
expression of sublexicon i with r entries becomes,
</bodyText>
<equation confidence="0.511266">
Li =U prbOr (13)
</equation>
<bodyText confidence="0.9706968">
We also compute the feasible feature structures of
sublexicon i to be
= U 6r (14)
and the overall feasible feature structures on all sub-
lexica to be
</bodyText>
<equation confidence="0.729145">
= x x F2 X • • (15)
</equation>
<bodyText confidence="0.999932333333333">
The first element deletes all such features on the
surface. For convenience in later expressions, we in-
corporate features with 7r as follows
</bodyText>
<equation confidence="0.827542333333333">
= 71&amp;quot; U (16)
The overall lexicon can be expressed by,&amp;quot;
Lexicon = L1 x L2 x • • (17)
</equation>
<bodyText confidence="0.7532665">
&amp;quot;To make the lexicon describe equal-length relations,
a special symbol, say 0, is inserted throughout.
</bodyText>
<equation confidence="0.537144">
aFbIcIdIbjeJfIgjhJiI
1 2 3 4 5 6 7 5 8 9 10 5
</equation>
<page confidence="0.997365">
333
</page>
<bodyText confidence="0.99981725">
The operator x creates one large lexicon out of
all the sublexica. This lexicon can be substantially
reduced by intersecting it with Projectrl (iro)* .
If a two-level grammar is compiled into an au-
tomaton, denoted by Gram, and a lexicon is com-
piled into an automaton, denoted by Lex, the au-
tomaton which enforces lexical constraints on the
language is expressed by
</bodyText>
<equation confidence="0.983342">
L = (Pro j ect (r)* x Lex) n Gram (18)
</equation>
<bodyText confidence="0.99993">
The first component above is a relation which ac-
cepts any surface symbol on its first tape and the
lexicon on the remaining tapes.
</bodyText>
<subsectionHeader confidence="0.996252">
5.3 Compiling Rules
</subsectionHeader>
<bodyText confidence="0.999917">
A compound regular rule with in context-pairs and
in rule features takes the form
</bodyText>
<equation confidence="0.9949525">
7 ; A2 p2 ; ; Arn _ pm
[01, 02, omi (19)
</equation>
<bodyText confidence="0.953714142857143">
where T, Ak , and pk, 1 &lt; k &lt; m are like before and
Ok is the tuple of feature structures associated with
rule k.
The following modifications to the procedure
given in section 4 are required.
Forgetting contexts for the moment, our basic ma-
chine scans sequences of tuples (from &apos;T), but re-
quires that any sequence representing a lexical entry
be followed by the entry&apos;s feature structure (from
(I)). This is achieved by modifying eq. 4 as follows:
Centers = P&apos;([( U 7)P1+4101)* (20)
TET
The expression accepts the symbols, p&apos;, followed
by zero or more occurrences of the following:
</bodyText>
<listItem confidence="0.988873">
1. one or more 7, each followed by p&apos;, and
2. a feature tuple in (I) followed by p&apos;.
</listItem>
<bodyText confidence="0.99984725">
In the second and third phases of the compilation
process, we need to incorporate members of (I) freely
throughout the contexts. For each ,\k, we compute
the new left context
</bodyText>
<equation confidence="0.955714">
Lk = Insert4,(Ak) (21)
</equation>
<bodyText confidence="0.99833">
The right context is more complicated. It requires
that the first feature structure to appear to the right
of r is Ok. This is achieved by the expression,
</bodyText>
<equation confidence="0.927356">
12,k = InserteD(pk) n r*Okr; (22)
</equation>
<bodyText confidence="0.95307575">
The intersection with r*Okr; ensures that the first
feature structure to appear to the right of T is Ok:
zero or more feasible tuples, followed by Ok, followed
by zero or more feasible tuples or feature structures.
Now we are ready to modify the Restrict relation.
The first component in eq. 5 becomes
A = (7r U r(1))*/-71; (23)
The expression allows (I) to appear in the left and
right contexts of 7; however, at the left of T, the
expression (7rU7r(D) puts the restriction that the first
tuple at the left end must be in r, not in &lt;D.
The second component in eq. 5 simply becomes
</bodyText>
<equation confidence="0.518352">
B =Ueork riek 7.; (24)
</equation>
<bodyText confidence="0.714567">
Hence, Restrict becomes (after replacing T with
w&apos; in eq. 23 and eq. 24)
</bodyText>
<equation confidence="0.604779666666667">
Restrict(r) = Subst itute(r, ) o (25)
Insert{} o
A — B
</equation>
<bodyText confidence="0.8829395">
In a similar manner, the CoerceR relation be-
comes
</bodyText>
<equation confidence="0.917809">
Coerce(7-&apos;) = Insert{} 0 (26)
u ir;ck pyip,,Tek7r;
</equation>
<sectionHeader confidence="0.959469" genericHeader="evaluation">
6 Conclusion and Future Work
</sectionHeader>
<bodyText confidence="0.999981952380952">
The above algorithm was implemented in Prolog and
was tested successfully with a number of sample-
type grammars. In every case, the automata pro-
duced by the compiler were manually checked for
correctness, and the machines were executed in gen-
eration mode to ensure that they did not over gen-
erate.
It was mentioned that the algorithm presented
here is based on the work of (Grimley-Evans, Kiraz,
and Pulman, 1996) rather than (Kaplan and Kay,
1994). It must be stated, however, that the intu-
itive ideas behind our compilation of rule features,
viz, the incorporation of rule features in contexts,
are independent of the algorithm itself and can be
also applied to (Kaplan and Kay, 1994) and (Mohri
and Sproat, 1996).
One issue which remains to be resolved, how-
ever, is to determine which approach for compiling
rules into automata is more efficient: the standard
method of (Kaplan and Kay, 1994) (also (Mohri and
Sproat, 1996) which follows the same philosophy) or
</bodyText>
<page confidence="0.997186">
334
</page>
<sectionHeader confidence="0.656311" genericHeader="conclusions">
Algorithm Intersection Determini-
</sectionHeader>
<bodyText confidence="0.7747292">
(N2) zation (2N)
KK (n 1) -L 3 E7....1 ki 8 , ki
EKP 1-1- E7_, ki 1 -1- E7_3. ki
where n = number of rules in a grammar,
and ki = number of contexts for rule i,1 &lt; i &lt; n.
</bodyText>
<figureCaption confidence="0.99914">
Figure 4: Statistics of Complex Operation&apos;s
</figureCaption>
<bodyText confidence="0.9742996">
the subtractive approach of (Grimley-Evans, Kiraz,
and Pulman, 1996).
The statistics of the usage of computationally ex-
pensive operations — viz., intersection (quadratic
complexity) and determinization (exponential com-
plexity) — in both algorithms are summarized in Fig-
ure 4 (KK = Kaplan and Kay, EKP = Grimley-
Evans, Kiraz and Pulman). Note that complemen-
tation requires determinization, and subtraction re-
quires one intersection and one complementation
since
A —B=An73— (27)
Although statistically speaking the number of op-
erations used in (Grimley-Evans, Kiraz, and Pul-
man, 1996) is less than the ones used in (Kaplan
and Kay, 1994), only an empirical study can resolve
the issue as the following example illustrates. Con-
sider the expression
dealt with at the morphotactic level using a unifica-
tion based formalism.
</bodyText>
<sectionHeader confidence="0.988054" genericHeader="acknowledgments">
Acknowledgments
</sectionHeader>
<bodyText confidence="0.9999855">
I would like to thank Richard Sproat for comment-
ing on an earlier draft. Many of the anonymous
reviewers&apos; comments proofed very useful. Mistakes,
as always, remain mine.
</bodyText>
<sectionHeader confidence="0.998365" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.991998">
Bear, J. 1988. Morphology with two-level rules and
negative rule features. In COLING-88: Papers
Presented to the 12th International Conference on
Computational Linguistics, volume 1, pages 28-
31.
Goldsmith, J. 1976. Autosegmental Phonology.
Ph.D. thesis, MIT. Published as Autosegmentcl
and Metrical Phonology, Oxford 1990.
Grimley-Evans, E., G. Kiraz, and S. Pulman. 1996.
Compiling a partition-based two-level formalism.
In COLING-96: Papers Presented to the 16th
International Conference on Computational Lin-
guistics.
Hoperoft, J. and J. Ullman. 1979. Introduction to
Automata Theory, Languages, and Computation.
Addison-Wesley.
</reference>
<bodyText confidence="0.4797984">
Kaplan, R. and M. Kay. 1994. Regular models of
(28) phonological rule systems. Computational Lin-
guistics, 20(3):331-78.
A = al U a2 U • • • U
and the De Morgan&apos;s law equivalent
</bodyText>
<equation confidence="0.891478">
B = n n • • n ?LT,. (29)
</equation>
<bodyText confidence="0.992247058823529">
The former requires only one complement which re-
sults in one determinization (since the automata
must be determinized before a complement is com-
puted). The latter not only requires n complements,
but also n — 1 intersections. The worst-case analy-
sis clearly indicates that computing A is much less
expensive than computing B. Empirically, however,
this is not the case when n is large and ai is small,
which is usually the case in rewrite rules. The reason
lies in the fact that the determinization algorithm
in the former expression applies on a machine which
is by far larger than the small individual machines
present in the latter expression.&apos;
Another aspect of rule features concerns the mor-
photactic unification of lexical entries. This is best
&amp;quot;This important difference was pointed out by one of
the anonymous reviewers whom I thank.
</bodyText>
<reference confidence="0.839168611111111">
Kiraz, G. 1995. Introduction to Syriac Spirantiza-
tion. Bar Hebraeus Verlag, The Netherlands.
Kiraz, G. [1996]. Syriac morphology: From a lin-
guistic description to a computational implemen-
tation. In R. Lavenant, editor, VIItum Sympo-
sium Syria cum 1996, Forthcoming in Orientalia
Christiana Analecta. Pontificio Institutum Studio-
rum Orientalium.
Kiraz, G. [Forthcoming]. Computational Ap-
proach to Nonlinear Morphology: with empha-
sis on Semitic languages. Cambridge University
Press.
McCarthy, J. 1981. A prosodic theory of non-
concatenative morphology. Linguistic Inquiry,
12(3):373-418.
Mohri, M. 1994. On some applications of finite-state
automata theory to natural language processing.
Technical report, Institut Gaspard Monge.
</reference>
<page confidence="0.994981">
335
</page>
<bodyText confidence="0.552788142857143">
Mohri, M. and S. Sproat. 1996. An efficient com-
piler for weighted rewrite rules. In Proceedings
of the 34th Annual Meeting of the Association for
Computational Linguistics, pages 231-8.
Roche, E. and Y. Schabes. 1995. Deterministic
part-of-speech tagging with finite-state transduc-
ers. CL, 21(2):227-53.
</bodyText>
<page confidence="0.998822">
336
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.635955">
<title confidence="0.978556">Compiling Regular Formalisms with Rule Features into Finite-State Automata</title>
<author confidence="0.999453">George Anton Kiraz</author>
<affiliation confidence="0.9591165">Bell Laboratories Lucent Technologies</affiliation>
<address confidence="0.9996985">700 Mountain Ave. Murray Hill, NJ 07974, USA</address>
<abstract confidence="0.969108">This paper presents an algorithm for the compilation of regular formalisms with rule features into finite-state automata. Rule features are incorporated into the right context of rules. This general notion can also be applied to other algorithms which compile regular rewrite rules into automata.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>J Bear</author>
</authors>
<title>Morphology with two-level rules and negative rule features.</title>
<date>1988</date>
<booktitle>In COLING-88: Papers Presented to the 12th International Conference on Computational Linguistics,</booktitle>
<volume>1</volume>
<pages>28--31</pages>
<contexts>
<context position="982" citStr="Bear, 1988" startWordPosition="136" endWordPosition="137">to the right context of rules. This general notion can also be applied to other algorithms which compile regular rewrite rules into automata. 1 Introduction The past few years have witnessed an increased interest in applying finite-state methods to language and speech problems. This in turn generated interest in devising algorithms for compiling rules which describe regular languages/relations into finite-state automata. It has long been proposed that regular formalisms (e.g., rewrite rules, two-level formalisms) accommodate rule features which provide for finer and more elegant descriptions (Bear, 1988). Without such a mechanism, writing complex grammars (say two-level grammars for Syriac or Arabic morphology) would be difficult, if not impossible. Algorithms which compile regular grammars into automata (Kaplan and Kay, 1994; Mohri and Sproat, 1996; Grimley-Evans, Kiraz, and Pulman, 1996) do not make use of this important mechanism. This paper presents a method for incorporating rule features in the resulting automata. The following Syriac example is used here, with the infamous Semitic root {ktb} &apos;notion of writing&apos;. The verbal pa&amp;quot;el measure&apos;, /katteb/2 &apos;wrote CAUSATIVE ACTIVE&apos;, is derived </context>
</contexts>
<marker>Bear, 1988</marker>
<rawString>Bear, J. 1988. Morphology with two-level rules and negative rule features. In COLING-88: Papers Presented to the 12th International Conference on Computational Linguistics, volume 1, pages 28-31.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Goldsmith</author>
</authors>
<title>Autosegmental Phonology.</title>
<date>1976</date>
<booktitle>Ph.D. thesis, MIT. Published as Autosegmentcl and Metrical Phonology,</booktitle>
<location>Oxford</location>
<contexts>
<context position="3024" citStr="Goldsmith, 1976" startWordPosition="453" endWordPosition="454">lism with rule features. Section 3 introduce a number of mathematical operators used in the compilation process. Sections 4 and 5 present our algorithm. Finally, section 6 provides an evaluation and some concluding remarks. 2 Regular Formalism with Rule Features This work adopts the following notation for regular formalisms, cf. (Kaplan and Kay, 1994): (1) where r, A and p are n-way regular expressions which describe same-length relations.&apos; (An n-way regular expression is a regular expression whose terms 3This analysis is along the lines of (McCarthy, 1981) — based on autosegmental phonology (Goldsmith, 1976). 4This derivation is based on the linguistic model proposed by (Kiraz, 1996). 5More &apos;user-friendly&apos; notations which allow mapping expressions of unequal length (e.g., (Grimley-Evans, Kiraz, and Pulman, 1996)) are mathematically equivalent to the above notation after rules are converted into same329 R1 k:c1:k:0 R2 b:c3:b:0 R3 a:v:0:a R4 e:v:0:e Ft5 t:c2:t:0 t:0:0:0 ([catz=verb], [measure=pa&amp;quot;el], []) R6 t:c2:t:0 ([cat=verb], [measure=p`al], []) R7 0:v:0:a .4* _ t:c2:t:0 a:v:0:a Sublexicon Entry Feature Structure Pattern ci vc2vc3 [cat=verb] Root ktb [measure=(p`al,pa&amp;quot;el)t] Vocalism ae [voice=ac</context>
</contexts>
<marker>Goldsmith, 1976</marker>
<rawString>Goldsmith, J. 1976. Autosegmental Phonology. Ph.D. thesis, MIT. Published as Autosegmentcl and Metrical Phonology, Oxford 1990.</rawString>
</citation>
<citation valid="true">
<authors>
<author>E Grimley-Evans</author>
<author>G Kiraz</author>
<author>S Pulman</author>
</authors>
<title>Compiling a partition-based two-level formalism.</title>
<date>1996</date>
<booktitle>In COLING-96: Papers Presented to the 16th International Conference on Computational Linguistics.</booktitle>
<contexts>
<context position="1272" citStr="Grimley-Evans, Kiraz, and Pulman, 1996" startWordPosition="177" endWordPosition="181">peech problems. This in turn generated interest in devising algorithms for compiling rules which describe regular languages/relations into finite-state automata. It has long been proposed that regular formalisms (e.g., rewrite rules, two-level formalisms) accommodate rule features which provide for finer and more elegant descriptions (Bear, 1988). Without such a mechanism, writing complex grammars (say two-level grammars for Syriac or Arabic morphology) would be difficult, if not impossible. Algorithms which compile regular grammars into automata (Kaplan and Kay, 1994; Mohri and Sproat, 1996; Grimley-Evans, Kiraz, and Pulman, 1996) do not make use of this important mechanism. This paper presents a method for incorporating rule features in the resulting automata. The following Syriac example is used here, with the infamous Semitic root {ktb} &apos;notion of writing&apos;. The verbal pa&amp;quot;el measure&apos;, /katteb/2 &apos;wrote CAUSATIVE ACTIVE&apos;, is derived from the following 1Syriac verbs are classified under various measures (i.e., forms), the basic ones being p`al, pa &amp;quot;el and &apos;eel. 2Spirantization is ignored here; for a discussion on Syriac spirantization, see (Kiraz, 1995). morphemes: the pattern {cvcvc} &apos;verbal pattern&apos;, the above mentio</context>
<context position="3231" citStr="Grimley-Evans, Kiraz, and Pulman, 1996" startWordPosition="479" endWordPosition="484">valuation and some concluding remarks. 2 Regular Formalism with Rule Features This work adopts the following notation for regular formalisms, cf. (Kaplan and Kay, 1994): (1) where r, A and p are n-way regular expressions which describe same-length relations.&apos; (An n-way regular expression is a regular expression whose terms 3This analysis is along the lines of (McCarthy, 1981) — based on autosegmental phonology (Goldsmith, 1976). 4This derivation is based on the linguistic model proposed by (Kiraz, 1996). 5More &apos;user-friendly&apos; notations which allow mapping expressions of unequal length (e.g., (Grimley-Evans, Kiraz, and Pulman, 1996)) are mathematically equivalent to the above notation after rules are converted into same329 R1 k:c1:k:0 R2 b:c3:b:0 R3 a:v:0:a R4 e:v:0:e Ft5 t:c2:t:0 t:0:0:0 ([catz=verb], [measure=pa&amp;quot;el], []) R6 t:c2:t:0 ([cat=verb], [measure=p`al], []) R7 0:v:0:a .4* _ t:c2:t:0 a:v:0:a Sublexicon Entry Feature Structure Pattern ci vc2vc3 [cat=verb] Root ktb [measure=(p`al,pa&amp;quot;el)t] Vocalism ae [voice=active, aa measure=pa&amp;quot;el] [voice=active, measure=p`al] tParenthesis denote disjunction over the given values. Figure 2: Simple Syriac Lexicon Figure 1: Simple Syriac Grammar are n-tuples of alphabetic symbols </context>
<context position="10912" citStr="Grimley-Evans, Kiraz, and Pulman, 1996" startWordPosition="1839" endWordPosition="1843">ence of I in S with 5&apos;. Definition 3.4 (Projection) Let S = (s,,. , sn) be a tuple of strings. Projecti(S), for some E { 1, n }, denotes the tuple element si. Pro j ectT 1 (S), for some i E { 1, n) denotes the (n — 1)-tuple (Si,.. • , si-i, si+i, • • ,sn). The symbol 7 denotes &apos;feasible tuples&apos;, similar to &apos;feasible pairs&apos; in traditional two-level morphology. The number of surface expressions, j, is always 1. The operator o represents mathematical composition, not necessarily the composition of transducers. 4 Compilation without Rule Features The current algorithm is motivated by the work of (Grimley-Evans, Kiraz, and Pulman, 1996).11 Intuitively, the automata is built by three approximations as follows: 1. Accepting 7s irrespective of any context. 2. Adding context restriction constraints making the automata accept only the sequences which appear in contexts described by the grammar. 3. Forcing surface coercion constraints making the automata accept all and only the sequences described by the grammar. 1°This is similar to the operator Intro in (Kaplan and Kay, 1994). &amp;quot;The subtractive approach for compiling rules into FSAs was first suggested by Edmund Grimley-Evans. 331 4.1 Accepting rs Let T be the set of all rs in a</context>
<context position="21308" citStr="Grimley-Evans, Kiraz, and Pulman, 1996" startWordPosition="3693" endWordPosition="3697">replacing T with w&apos; in eq. 23 and eq. 24) Restrict(r) = Subst itute(r, ) o (25) Insert{} o A — B In a similar manner, the CoerceR relation becomes Coerce(7-&apos;) = Insert{} 0 (26) u ir;ck pyip,,Tek7r; 6 Conclusion and Future Work The above algorithm was implemented in Prolog and was tested successfully with a number of sampletype grammars. In every case, the automata produced by the compiler were manually checked for correctness, and the machines were executed in generation mode to ensure that they did not over generate. It was mentioned that the algorithm presented here is based on the work of (Grimley-Evans, Kiraz, and Pulman, 1996) rather than (Kaplan and Kay, 1994). It must be stated, however, that the intuitive ideas behind our compilation of rule features, viz, the incorporation of rule features in contexts, are independent of the algorithm itself and can be also applied to (Kaplan and Kay, 1994) and (Mohri and Sproat, 1996). One issue which remains to be resolved, however, is to determine which approach for compiling rules into automata is more efficient: the standard method of (Kaplan and Kay, 1994) (also (Mohri and Sproat, 1996) which follows the same philosophy) or 334 Algorithm Intersection Determini(N2) zation</context>
</contexts>
<marker>Grimley-Evans, Kiraz, Pulman, 1996</marker>
<rawString>Grimley-Evans, E., G. Kiraz, and S. Pulman. 1996. Compiling a partition-based two-level formalism. In COLING-96: Papers Presented to the 16th International Conference on Computational Linguistics.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Hoperoft</author>
<author>J Ullman</author>
</authors>
<title>Introduction to Automata Theory, Languages, and Computation.</title>
<date>1979</date>
<publisher>Addison-Wesley.</publisher>
<contexts>
<context position="14354" citStr="Hoperoft and Ullman, 1979" startWordPosition="2440" endWordPosition="2443">s surrounding 7&apos; ensure that coercion applies on at least one center of the rule. For all such expressions, we subtract Coerce from the automaton under construction, yielding SC = CR —UC oerce(r) (11) SC now accepts all and only the sequences of tuples described by the grammar (but including the partitioning symbols p&apos;). It remains only to remove all instances of p from the final machine, determinize and minimize it. There are two methods for interpreting transducers. When interpreted as acceptors with n-tuples of symbols on each transition, they can be determinized using standard algorithms (Hoperoft and Ullman, 1979). When interpreted as a transduction that maps an input to an output, they cannot always be turned into a deterministic form (see (Mohri, 1994; Roche and Schabes, 1995)). 5 Compilation with Rule Features This section shows how feature structures which are associated with rules and lexical entries can be incorporated into FSAs. &apos;A special case can be added for epenthetic rules. 332 Entry Feature Structure abcd fi ef 12 ghi Figure 3: Lexicon Example 5.1 Intuitive Description We shall describe our handling of rule features with a two-level example. Consider the following analysis. Lexical Surface</context>
</contexts>
<marker>Hoperoft, Ullman, 1979</marker>
<rawString>Hoperoft, J. and J. Ullman. 1979. Introduction to Automata Theory, Languages, and Computation. Addison-Wesley.</rawString>
</citation>
<citation valid="true">
<authors>
<author>G Kiraz</author>
</authors>
<title>Introduction to Syriac Spirantization. Bar Hebraeus Verlag, The Netherlands.</title>
<date>1995</date>
<contexts>
<context position="1805" citStr="Kiraz, 1995" startWordPosition="263" endWordPosition="264">n and Kay, 1994; Mohri and Sproat, 1996; Grimley-Evans, Kiraz, and Pulman, 1996) do not make use of this important mechanism. This paper presents a method for incorporating rule features in the resulting automata. The following Syriac example is used here, with the infamous Semitic root {ktb} &apos;notion of writing&apos;. The verbal pa&amp;quot;el measure&apos;, /katteb/2 &apos;wrote CAUSATIVE ACTIVE&apos;, is derived from the following 1Syriac verbs are classified under various measures (i.e., forms), the basic ones being p`al, pa &amp;quot;el and &apos;eel. 2Spirantization is ignored here; for a discussion on Syriac spirantization, see (Kiraz, 1995). morphemes: the pattern {cvcvc} &apos;verbal pattern&apos;, the above mentioned root, and the vocalism {ae} &apos;ACTIVE&apos;. The morphemes produce the following underlying form:3 a e cvcvc =*/kateb/ I k t b /katteb/ is derived then by the gemination, implying CAUSATIVE, of the middle consonant, [t].4 The current work assumes knowledge of regular relations (Kaplan and Kay, 1994). The following convention has been adopted. Lexical forms (e.g., morphemes in morphology) appear in braces, { phonological segments in square brackets, [], and elements of tuples in angle brackets, ( ). Section 2 describes a regular fo</context>
</contexts>
<marker>Kiraz, 1995</marker>
<rawString>Kiraz, G. 1995. Introduction to Syriac Spirantization. Bar Hebraeus Verlag, The Netherlands.</rawString>
</citation>
<citation valid="true">
<authors>
<author>G Kiraz</author>
</authors>
<title>Syriac morphology: From a linguistic description to a computational implementation.</title>
<date>1996</date>
<booktitle>VIItum Symposium Syria cum 1996, Forthcoming in Orientalia Christiana Analecta. Pontificio Institutum Studiorum Orientalium.</booktitle>
<editor>In R. Lavenant, editor,</editor>
<contexts>
<context position="3101" citStr="Kiraz, 1996" startWordPosition="466" endWordPosition="467">sed in the compilation process. Sections 4 and 5 present our algorithm. Finally, section 6 provides an evaluation and some concluding remarks. 2 Regular Formalism with Rule Features This work adopts the following notation for regular formalisms, cf. (Kaplan and Kay, 1994): (1) where r, A and p are n-way regular expressions which describe same-length relations.&apos; (An n-way regular expression is a regular expression whose terms 3This analysis is along the lines of (McCarthy, 1981) — based on autosegmental phonology (Goldsmith, 1976). 4This derivation is based on the linguistic model proposed by (Kiraz, 1996). 5More &apos;user-friendly&apos; notations which allow mapping expressions of unequal length (e.g., (Grimley-Evans, Kiraz, and Pulman, 1996)) are mathematically equivalent to the above notation after rules are converted into same329 R1 k:c1:k:0 R2 b:c3:b:0 R3 a:v:0:a R4 e:v:0:e Ft5 t:c2:t:0 t:0:0:0 ([catz=verb], [measure=pa&amp;quot;el], []) R6 t:c2:t:0 ([cat=verb], [measure=p`al], []) R7 0:v:0:a .4* _ t:c2:t:0 a:v:0:a Sublexicon Entry Feature Structure Pattern ci vc2vc3 [cat=verb] Root ktb [measure=(p`al,pa&amp;quot;el)t] Vocalism ae [voice=active, aa measure=pa&amp;quot;el] [voice=active, measure=p`al] tParenthesis denote disj</context>
</contexts>
<marker>Kiraz, 1996</marker>
<rawString>Kiraz, G. [1996]. Syriac morphology: From a linguistic description to a computational implementation. In R. Lavenant, editor, VIItum Symposium Syria cum 1996, Forthcoming in Orientalia Christiana Analecta. Pontificio Institutum Studiorum Orientalium.</rawString>
</citation>
<citation valid="false">
<authors>
<author>G Kiraz</author>
</authors>
<title>Computational Approach to Nonlinear Morphology: with emphasis on Semitic languages.</title>
<publisher>Cambridge University Press.</publisher>
<marker>Kiraz, </marker>
<rawString>Kiraz, G. [Forthcoming]. Computational Approach to Nonlinear Morphology: with emphasis on Semitic languages. Cambridge University Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J McCarthy</author>
</authors>
<title>A prosodic theory of nonconcatenative morphology.</title>
<date>1981</date>
<journal>Linguistic Inquiry,</journal>
<pages>12--3</pages>
<contexts>
<context position="2971" citStr="McCarthy, 1981" startWordPosition="446" endWordPosition="447">e brackets, ( ). Section 2 describes a regular formalism with rule features. Section 3 introduce a number of mathematical operators used in the compilation process. Sections 4 and 5 present our algorithm. Finally, section 6 provides an evaluation and some concluding remarks. 2 Regular Formalism with Rule Features This work adopts the following notation for regular formalisms, cf. (Kaplan and Kay, 1994): (1) where r, A and p are n-way regular expressions which describe same-length relations.&apos; (An n-way regular expression is a regular expression whose terms 3This analysis is along the lines of (McCarthy, 1981) — based on autosegmental phonology (Goldsmith, 1976). 4This derivation is based on the linguistic model proposed by (Kiraz, 1996). 5More &apos;user-friendly&apos; notations which allow mapping expressions of unequal length (e.g., (Grimley-Evans, Kiraz, and Pulman, 1996)) are mathematically equivalent to the above notation after rules are converted into same329 R1 k:c1:k:0 R2 b:c3:b:0 R3 a:v:0:a R4 e:v:0:e Ft5 t:c2:t:0 t:0:0:0 ([catz=verb], [measure=pa&amp;quot;el], []) R6 t:c2:t:0 ([cat=verb], [measure=p`al], []) R7 0:v:0:a .4* _ t:c2:t:0 a:v:0:a Sublexicon Entry Feature Structure Pattern ci vc2vc3 [cat=verb] R</context>
</contexts>
<marker>McCarthy, 1981</marker>
<rawString>McCarthy, J. 1981. A prosodic theory of nonconcatenative morphology. Linguistic Inquiry, 12(3):373-418.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Mohri</author>
</authors>
<title>On some applications of finite-state automata theory to natural language processing.</title>
<date>1994</date>
<tech>Technical report,</tech>
<institution>Institut Gaspard Monge.</institution>
<contexts>
<context position="14496" citStr="Mohri, 1994" startWordPosition="2468" endWordPosition="2469">ruction, yielding SC = CR —UC oerce(r) (11) SC now accepts all and only the sequences of tuples described by the grammar (but including the partitioning symbols p&apos;). It remains only to remove all instances of p from the final machine, determinize and minimize it. There are two methods for interpreting transducers. When interpreted as acceptors with n-tuples of symbols on each transition, they can be determinized using standard algorithms (Hoperoft and Ullman, 1979). When interpreted as a transduction that maps an input to an output, they cannot always be turned into a deterministic form (see (Mohri, 1994; Roche and Schabes, 1995)). 5 Compilation with Rule Features This section shows how feature structures which are associated with rules and lexical entries can be incorporated into FSAs. &apos;A special case can be added for epenthetic rules. 332 Entry Feature Structure abcd fi ef 12 ghi Figure 3: Lexicon Example 5.1 Intuitive Description We shall describe our handling of rule features with a two-level example. Consider the following analysis. Lexical Surface The lexical expression contains the lexical forms {ef} and {ghi}, separated by a boundary symbol, 1, which designates the end of a lexical en</context>
</contexts>
<marker>Mohri, 1994</marker>
<rawString>Mohri, M. 1994. On some applications of finite-state automata theory to natural language processing. Technical report, Institut Gaspard Monge.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>