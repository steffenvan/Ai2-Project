<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<title confidence="0.9989105">
A Practical Approach to Multiple Default
Inheritance for Unification-Based Lexicons
</title>
<author confidence="0.794565666666667">
Graham Russell*
ISSCO
John CarrolP
</author>
<affiliation confidence="0.9004825">
Cambridge University Computer
Laboratory
</affiliation>
<sectionHeader confidence="0.8097415" genericHeader="abstract">
Afzal Ballim*
ISSCO
Susan Warwick-Armstrong*
ISSCO
</sectionHeader>
<bodyText confidence="0.981240333333333">
This paper describes a unification-based lexicon system for NLP applications that incorporates
mechanisms for multiple default inheritance. Such systems are intractable in the general case—
the approach adopted here places a number of restrictions on the inheritance hierarchy in order to
remove some of the sources of complexity while retaining more desirable properties. Implications
of the design choices are discussed, comparisons are drawn with related work in computational
linguistics and Al, and illustrative examples from the lexicons of German and English are given.
</bodyText>
<sectionHeader confidence="0.990143" genericHeader="introduction">
1. Introduction
</sectionHeader>
<bodyText confidence="0.99997995">
In essence, the primary task of a computational lexicon is to associate character strings
representing word forms with various types of information, able to account for their
distribution within a sentence and for their contribution to the meaning of a text.
Economical lexical organization appears to require the ability, on the one hand, to
make general statements about classes of words, and, on the other, to express excep-
tions to such statements affecting both individual words and subclasses of words.
These considerations have provoked interest in applying to the domain of the lexi-
con Al knowledge representation techniques involving the notions of inheritance and
defaults) Unfortunately, many of the schemes that have been proposed are highly com-
plex; departing from simple tree-form taxonomies dramatically increases the problems
of dealing in a systematic fashion with default inheritance. Not only are the intuitions
underlying the behavior of systems such as those of Touretzky (1986) and Sandewall
(1986) unstable (as Touretzky et al. [1987] show), Selman and Levesque (1989) demon-
strate that certain of them are NP-hard and thus effectively intractable.
In a well-defined domain such as the lexicon there remains the possibility of miti-
gating these problems by adopting a principled compromise; it may be advantageous
to surrender some of the generality of an inheritance system, if the more restricted
version that results retains sufficient expressive power for the domain in question. We
expand on this below and propose a number of simplifications that are motivated by
the particular task that the system is intended to perform.
</bodyText>
<footnote confidence="0.347528666666667">
* ISSCO, 54 route des Acacias, 1227 Geneva, Switzerland.
t Cambridge University Computer Laboratory, New Museums Site, Pembroke Street, Cambridge CI32
3QG, UK.
I See, e.g., Evans and Gazdar 1990, Gazdar 1990 (especially the References), much of the material in
Daelemans and Gazdar 1990, and the contributions to Briscoe et al. 1991. We discuss some of this work
below.
</footnote>
<note confidence="0.8442345">
C) 1992 Association for Computational Linguistics
Computational Linguistics Volume 18, Number 3
</note>
<bodyText confidence="0.999902210526316">
The system described here has been implemented as part of the au&apos; unification
grammar development environment for research in machine translation, made up of
parser, generator, lexicon, and transfer mechanism. The user language resembles that
of PATR-II (Shieber 1986a), but provides a larger range of data types and more pow-
erful means of stating relations between them. Among the requirements imposed by
the context within which this system is used are (i) the ability to both analyze and
generate complex word forms, (ii) full integration with existing parts of the au en-
vironment, and (iii) the ability to accommodate a relatively large number of words.
In particular, an important objective is to preserve as far as possible the flavor of this
type of environment: a specialized programming language for linguistic descriptions,
suitable for interpretation by a variety of programs performing tasks such as anal-
ysis and generation of sentences and phrases, lexical lookup, etc., which associates
with natural language expressions representations defined by the writer of a linguis-
tic description and employs unification as the method of combining information and
enforcing constraints. The intention is that the au language should be as general
as possible, in the sense of imposing minimal restrictions on the form of linguistic
analyses and descriptions.
Unification is an attractive choice as the basic computational mechanism of such
a system, for well-known reasons: its algebraic properties permit a declarative, mono-
tonic semantics for the language that is independent of whatever programs interpret it.
However, it does not always meet the requirements of practical linguistic descriptions.
The treatment of exceptions is a case in point; negation and conditional statements of
the kind excluded by pure unification frequently play a large part in accounts of nat-
ural language phenomena, and the best-motivated area for the application of these
ideas appears to be the lexicon. It is this problem that the current work seeks to ad-
dress. We would hope that the interest of the system presented here extends beyond
the particular environment for which it has been developed; as an attempt to reconcile
two apparently disparate paradigms, the combination of inheritance and unification
may be of interest in quite different contexts.
The remainder of the paper is organized as follows. Section 2 discusses general
issues concerning the organization of the system: the basic formalism is introduced,
together with the notions of multiple inheritance, default inheritance, and class prece-
dence. Section 3 describes the system in greater detail, showing how the form of the
inheritance hierarchy determines how information in lexical specifications is combined,
and Section 4 provides some comparisons with related work. Some more extended lin-
guistic examples appear in Section 5; these serve to illustrate the various mechanisms
described earlier and suggest methods that might be adopted in formulating other
analyses. Finally, in Section 6, the current implementation is discussed.
</bodyText>
<sectionHeader confidence="0.92187" genericHeader="method">
2. The Lexicon as a Hierarchy
</sectionHeader>
<subsectionHeader confidence="0.997737">
2.1 An Overview of the Formalism
</subsectionHeader>
<bodyText confidence="0.897305142857143">
An au lexicon consists of a number of &apos;classes,&apos; each of which is a structured collec-
tion of constraint equations encoding information common to a set of words, together
with links to other more general &apos;superclasses.&apos; For example, if an &apos;intransitive&apos; class
is used to express the common syntactic properties shared by all intransitive verbs,
then particular instances of intransitive verbs can be made to inherit this informa-
2 &amp;quot;Environnement Linguistique d&apos;Unification&amp;quot; (Estival 1990). See also Johnson and Rosner (1989) for a
description of the earlier UD system on which ELu is based.
</bodyText>
<page confidence="0.98866">
312
</page>
<note confidence="0.995665">
Graham Russell et al. A Practical Approach to Multiple Default Inheritance
</note>
<bodyText confidence="0.981033392857143">
tion by specifying the &apos;intransitive&apos; class as one of their superclasses—it then becomes
unnecessary to specify the relevant properties individually for each such verb. Sim-
ilarly, the &apos;intransitive&apos; class need not express any of the more general properties of
the &apos;verb&apos; class. The lexicon may be thought of as a tangled hierarchy of classes linked
by inheritance paths, with, at the most specific level, lexical classes and, at the most
general, classes for which no superclasses have been defined; these therefore inherit
no information from elsewhere. Basic lexical entries are themselves classes,&apos; and any
information they contain is standardly specific to an individual word; lexical and non-
lexical classes differ in that analysis and generation take only the former as entry
points to the lexicon.
It is possible to define certain properties of a class as defeasible. Such a property
will be inherited from a superclass only if it is consistent with all properties con-
tributed by more specific classes; if it is not consistent, then it is ignored. Defeasible
constraints imposed on a class of words may thus be overridden by information asso-
ciated with individual members or subclasses of that class; this is the notion of default
that underlies the system. It is possible, for example, to place in the class expressing
general properties of verbs an equation such as &apos;&lt;aux&gt; = no&apos; (i.e. &amp;quot;typical verbs are
not auxiliaries&amp;quot;), while placing the contradictory specification &apos;&lt;aux&gt; = yes&apos; in a sub-
class from which only auxiliaries inherit. The ability to encode exceptional properties
of lexical items is extremely attractive from the linguistic point of view; the lower the
position in the hierarchy at which the property appears, the more exceptional it may
be considered.
Like other parts of an au description, a lexicon consists of a set of statements that
are compiled into an internal format for use in analysis and generation of linguistic
expressions. Section 2.6 describes some relevant aspects of the lexical compilation
process.
2.1.1 Class Definition. A class definition consists of the compiler directive &apos;#C1 as s&apos;
(for a nonlexical class) or &apos;#Word&apos; (for a lexical class),4 followed by:
</bodyText>
<listItem confidence="0.98632075">
(i) the name of the class
(ii) a (possibly empty) list of its direct superclasses
(iii) a (possibly empty) &apos;main&apos; equation set
(iv) zero or more (possibly empty) &apos;variant&apos; equation sets.
</listItem>
<subsubsectionHeader confidence="0.697295">
2.1.2 Superclass Declaration. The superclass declaration is a list of the names of any
</subsubsectionHeader>
<bodyText confidence="0.8301434">
direct superclass of the current class. This is used in computing the relative precedence
of classes in the lexicon for the purpose of default inheritance (see Section 2.5); it
may be empty if the class has no superclasses, i.e., if it is one of the most general
in the lexicon, and thus inherits no information. Precedence of direct superclasses is
3 Thus no distinction is made between classes and &apos;instances,&apos; as in, e.g., KL-ONE (Schmolze and Lipkis
1983) and much more recent work. One reason for this is that instances of the kind appealed to by
some KR researchers do not exist within a unification-based linguistic description. What would count
as an instance in this context is an occurrence of a word in the analysis of some text; in general,
information associated with one particular occurrence of a word will originate partly in its lexical
specification and partly through unifications with other items.
</bodyText>
<footnote confidence="0.505672">
A second, related reason for not enforcing a class/instance distinction is that lexical classes may
themselves usefully be inherited from; examples of this behavior are discussed in Section 5.2.
4 Both lexical and nonlexical classes have the same form and interpretation. The distinction becomes
relevant for lexical access; only lexical classes are taken as entry points to the lexicon.
</footnote>
<page confidence="0.996654">
313
</page>
<note confidence="0.830375">
Computational Linguistics Volume 18, Number 3
</note>
<bodyText confidence="0.980133583333334">
determined by the order in which they appear in the list--more specific classes appear
to the left of more general ones. Precedence of nondirect superclasses is derived by
topologically sorting the hierarchy in a manner described in Section 2.6.
2.1.3 Main Equation Set. Following the superclass declaration are zero or more equa-
tions representing default information, which we refer to as the &apos;main&apos; equation set.
These may be overridden by conflicting information in a more specific class. Each
equation in a main set functions as an independent constraint, in a manner that will
be clarified in Section 3 below.
2.1.4 Variant Equation Sets. Following the (possibly empty) main equation set are
zero or more sets of equations representing variants within the class, which loosely
speaking correspond to alternatives at the same &apos;conceptual level&apos; in the hierarchy.
Equations within a variant set are absolute constraints, in contrast to those in the
main set; if they conflict with information in a more specific class, failure of unification
occurs in the normal way. Also, unlike the main set, each variant set functions as a
single, possibly complex, constraint (see Section 3.2). A feature structure is created for
each variant set that successfully unifies with the single structure resulting from the
main set. Each variant set is preceded by the vertical bar &apos;
2.1.5 String Concatenation. Construction and decomposition of complex words are
carried out by the string concatenation operator VC An equation of the form
String = Pref ix Fac Suffix
unifies String with the result of concatenating Pref ix and Suffix. The unification is
nondeterministic, in the sense that if String is abc, and Prefix and Suffix are oth-
erwise uninstantiated unification variables, the equation has the four solutions shown
below, where &apos; &amp;quot; &amp;quot; &apos; indicates the empty string:
</bodyText>
<listItem confidence="0.99935725">
(0 Prefix : Suffix : abc
(ii) Prefix : a Suffix : bc
(fip Prefix : ab Suffix : c
(iv) Prefix : abc Suffix :
</listItem>
<subsectionHeader confidence="0.999006">
2.2 Other Aspects of the ELU Language
</subsectionHeader>
<bodyText confidence="0.598523">
We introduce here a variety of notational conventions used in the examples below.
2.2.1 Lists. Values of attributes may take the form of lists of feature structures, notated
in grammar rules and lexical entries as &apos;[F1. • . , Fn
2.2.2 Disjunction. Disjunction is defined over atomic feature structures. A value de-
fined as la/b/c&apos; represents a set of atoms D {a, b, c}, which unifies with: (i) any d E D
(result: d); (ii) any other disjunction representing a set D&apos; such that D n D&apos; = I (result:
I if nonempty, otherwise failure); and (iii) the negation (see below) of a disjunction
representing a set D&apos; (result: D D&apos; if nonempty, otherwise failure).
2.2.3 Negation. Negation is defined over atomic feature structures and disjunctions of
atomic feature structures; a value defined as a&apos; unifies with any feature structure F
that does not unify with a, the result being F.
</bodyText>
<page confidence="0.996188">
314
</page>
<note confidence="0.82183">
Graham Russell et al. A Practical Approach to Multiple Default Inheritance
</note>
<subsubsectionHeader confidence="0.6450065">
2.2.4 Path Specifications. Attribute value paths are notated in the form &apos;&lt;al , an&gt;.&apos;
2.2.5 Variables. Unification variables have an initial uppercase letter; quoted expres-
</subsubsectionHeader>
<bodyText confidence="0.948072">
sions beginning with uppercase letters are interpreted as constants. Thus, Var is a
variable, and both atom and &apos; Var &apos; are atomic FSs.
</bodyText>
<subsectionHeader confidence="0.999983">
2.3 An Example
</subsectionHeader>
<bodyText confidence="0.996396">
The following example illustrates the form and interaction of class definitions.
</bodyText>
<equation confidence="0.974602333333333">
#Word walk (Intransitive Verb)
&lt;stem&gt; = walk
#Class Intransitive 0
&lt;subcat&gt; = [Subj] &lt;Subj cat&gt; = np
#Class Verb 0 &lt;cat&gt; = v
&lt;aux&gt; = no &lt;form&gt; = &lt;stem&gt; la ed
&lt;tense&gt; = past &lt;tense&gt; = present
&lt;agr&gt; = sg3 &lt;tense&gt; = present
&lt;form&gt; = &lt;stem&gt; &amp;&amp; s
1
&lt;agr&gt; = non_sg3
&lt;form&gt; = &lt;stem&gt;
</equation>
<bodyText confidence="0.997137714285714">
The lexical class walk is declared as having two direct superclasses, Verb and Intransi-
tive; its main set contains just one equation, which sets the value of the feature &lt;stern&gt;
to be walk. Intransitive has no direct superclasses, and its main equation set assigns
to the value of &lt;subcat&gt; a list with one element, a feature structure in which the value
of &lt;cat&gt; is np. Neither walk nor Intransitive has any variant equation sets. Verb,
by contrast, has three, in addition to two main set equations assigning default values
for &lt;cat&gt; and &lt;aux&gt;. The three variants accounted for by this example are:
</bodyText>
<listItem confidence="0.999169142857143">
• the past tense verb, in which the value of &lt;f orm&gt; unifies with the result
of concatenating the value of &lt;stem&gt; with the string &apos;ed,&apos;
• the third person singular form of the present tense, in which the suffix
string is &apos;s,&apos; and
• the form representing other combinations of person and number in the
present tense; in the last case, the &lt;form&gt; value is simply identical to the
&lt;stem&gt; value.
</listItem>
<subsectionHeader confidence="0.999669">
2.4 Multiple Inheritance
</subsectionHeader>
<bodyText confidence="0.999957285714286">
As we have just seen, a class may inherit from more than one direct superclass. In-
stead of a simple, tree-form taxonomic structure, therefore, the lexical hierarchy takes
the form of a directed (acyclic) graph. In general, multiple inheritance of this kind
necessitates more complex methods of searching a hierarchy; in the worst case, the
number of paths to be traversed grows exponentially with the depth of the hierarchy.
Moreover, since it then becomes possible to reach a node by more than one path, the
presence of exceptions (via default assignments or negative links) permits incompatible
</bodyText>
<page confidence="0.997223">
315
</page>
<note confidence="0.339628">
Computational Linguistics Volume 18, Number 3
</note>
<bodyText confidence="0.999875340425532">
conclusions to be drawn—forks leading to such inconsistencies must be detected and
suitable records kept. Much of the complexity of inheritance reasoners lies in finding
and determining what to do in these cases of ambiguity.&apos; Multiple inheritance is not
an a priori necessity for lexical specification, so it is worth considering whether any
phenomena occur in this domain that might make multiple inheritance preferable to
the simpler tree-structured hierarchy. If it proved possible to eliminate this source of
complexity, the goal of a practical inheritance system would be nearer.
However, natural language lexicons do appear to require description in terms
of &apos;tangled hierarchies,&apos; at least if certain types of generalization are not to go un-
expressed. It has often been observed, for example, that syntactic and morphological
properties are in many respects disjoint; the subcategorization class of a verb cannot be
predicted from its conjugation class, and vice versa. A French lexicon will distinguish
three basic verb conjugations, exemplified by the transitive aimer (&apos;love&apos;), hair (&apos;hate&apos;),
and voir (&apos;see&apos;). Each of these three classes, not surprisingly, also contains intransitive
verbs; in a tree-form hierarchy, nodes must be created for first conjugation transitive
and first conjugation intransitive verbs, and similarly for the other cases, with infor-
mation relevant to transitive verbs in general, or first conjugation verbs in general,
repeated at each appropriate node. When the many subclasses and special cases of
inflectional behavior are taken into account, together with a more adequate analysis
of subcategorization patterns, the number of nodes required, and the redundancy of
the specifications, increases considerably.
Multiple inheritance permits the two types of information to be kept separate
by isolating them in distinct sub-hierarchies. This compartmentalization is implicitly
related to the independence of the sub-hierarchies; if constraints relevant to different
types of information are always disjoint, then the system as a whole is &apos;orthogonal&apos;
(Touretzky 1986: 73ff). The significance of this point lies in the fact that, if superclasses
B and C of some class A are independent in this way, no conflict can arise when A
inherits from both B and C, and the result of inheriting default information from the
superclasses will not vary according to the order in which the defaults apply.
The organization of a lexicon must reflect two types of relation between classes of
words. Clearly, certain classes stand in the subset/superset relation—&apos;words&apos; in gen-
eral, &apos;verbs,&apos; present tense verbs,&apos; present tense verbs agreeing with a plural subject,&apos;
&apos;present tense verbs agreeing with a second person plural subject,&apos; and so on. Equally
clearly, within many of these classes there exist disjoint subsets—&apos;present tense verbs,&apos;
&apos;past tense verbs,&apos; infinitive verbs,&apos; verbs agreeing with second person plural subject,&apos;
&apos;verbs agreeing with third person plural subject,&apos; and so on. Word classes within the
lexicon must encode both types of relation, and, in broad terms, it is the latter that
one might wish to represent by means of unordered multiple inheritance.
The design of such a system presents a three-way choice: (i) to accept ambiguity of
inheritance; (ii) to enforce orthogonality in the hierarchy; (iii) to eliminate unordered
multiple inheritance. The present system takes the third option; ambiguity of inheri-
tance is eliminated by enforcing a total ordering on the superclasses of any given class
or word, and by making it clear to users how this ordering is derived so that they
may more accurately control and exploit it in the organization of the hierarchy.
As a substitute for unordered multiple inheritance, the variant set mechanism is
introduced; this allows variants to be represented directly within a class rather than
by creating alternate, unordered superclasses, and corresponds to a strong element
</bodyText>
<page confidence="0.922206">
5 Cf. examples of cascaded ambiguity and On-Path versus Off-Path preemption in Touretzky et al.
(1987).
316
</page>
<note confidence="0.965959">
Graham Russell et al. A Practical Approach to Multiple Default Inheritance
</note>
<bodyText confidence="0.999985">
in traditional grammatical description, that such mutually exclusive variant classes
should nevertheless be grouped together in a single compound statement or paradigm.
A concrete version of this may be seen in the inflection tables to be found in reference
and pedagogical grammars of foreign languages. Users are able to simulate ambiguity
judiciously when required, but are responsible for determining when this should occur.
In effect, we are giving away some of the generality of an inheritance reasoner (that it
reasons correctly over arbitrary inheritance networks according to certain &amp;quot;intuitions&amp;quot;)
by making creators of lexicons perform the &amp;quot;intuitive&amp;quot; work themselves. This is no bad
thing, since the creator of the lexicon is then forced to consider the desired relations,
rather than relying on the semantics of the inheritance system to produce them.
</bodyText>
<subsectionHeader confidence="0.998985">
2.5 Default Inheritance
</subsectionHeader>
<bodyText confidence="0.999993083333333">
The use of default information in a unification-based system raises the question of how
the two types of operation are to interact. If unification is employed in its conventional
form, then combining conflicting information from different classes will produce fail-
ure and a null result. While this is reasonable behavior elsewhere, it prevents the
desired treatment of exceptions to generalizations in word classes. One step toward
a solution is to define default inheritance of constraints to be such that if A is a FS
associated with a class C and B is a default FS associated with a superclass of C, then
the result of applying B to A is R = A U B, if R T, and A otherwise.&apos; This is not
yet sufficient, since a failure of one subpart of B causes all other, possibly compati-
ble, information in B to be discarded. What is needed is a scheme in which A unifies
with as many as possible of the individual constraints embodied in B. We shall see in
Section 3.2 how the casual &amp;quot;as many as possible&amp;quot; can be made precise.
</bodyText>
<subsectionHeader confidence="0.999652">
2.6 Class Precedence
</subsectionHeader>
<bodyText confidence="0.996842117647059">
A system such as the Elm lexicon, which permits the defeasible inheritance of infor-
mation from more than one superclass, must provide a way of resolving the conflicts
that arise when information present in two or more superclasses is mutually incom-
patible, e.g., when the result obtained when A inherits from one superclass B before
inheriting from another, C, differs from that obtained by inheriting first from C and
then from B. It is in such cases that the notion of &amp;quot;precedence&amp;quot; comes into play; if the
system is constrained so that information is inherited first from B, we say that B &amp;quot;has
precedence over,&amp;quot; or &amp;quot;is more specific than&amp;quot; C.
A familiar example of this type of situation from the AT literature is the so-called
&apos;Nixon diamond&apos; (Touretzky 1986). Nixon is both a Quaker and a Republican; Quak-
ers are (typically) pacifists, while Republicans are (typically) not; the question to be
answered is whether Nixon is a pacifist. In a conventional inheritance network, this
problem might be represented by the configuration shown in Figure 1. If the links to
the &apos;Pacifist&apos; class are both defeasible, which should take precedence, the positive link
from &apos;Quaker,&apos; or the negative link from &apos;Republican&apos;?&apos;
Within the Eix lexicon, a natural way of representing the same information is to
dispense with a &apos;Pacifist&apos; class, and instead to make (non) pacifisthood a defeasible
</bodyText>
<footnote confidence="0.91223075">
6 Throughout this paper, &apos;A Li B&apos; denotes the unification of A and B, &apos;T&apos; denotes the inconsistent feature
structure equated with failure of unification, and &apos;1&apos; denotes the empty or most general feature
structure, which subsumes all others.
7 If the links in question are strict rather than defeasible, a system may resolve the ambiguity by
&apos;skeptical&apos; or &apos;credulous&apos; reasoning, yielding no answer or both answers, respectively. A mixture of
strict and defeasible links (i.e., a &apos;heterogeneous&apos; inheritance system) is argued by Ballim et al. (1988;
1990) to be more capable than a homogeneous system (one with only strict or only defeasible links) of
expressing the intuitions underlying networks such as the &amp;quot;Nixon diamond.&amp;quot; See also Section 4.3.
</footnote>
<page confidence="0.996796">
317
</page>
<figure confidence="0.997581">
Computational Linguistics Volume 18, Number 3
Pacifist
Republican
Quaker
Nixon
</figure>
<figureCaption confidence="0.980337">
Figure 1
</figureCaption>
<bodyText confidence="0.645247">
The Nixon diamond.
property of Quakers and Republicans, as shown in the example below:
</bodyText>
<equation confidence="0.88248175">
#Word Nixon (Quaker Republican)
&lt;name&gt; = &apos;Nixon&apos;
#Class Quaker 0
&lt;pacifist&gt; = yes
&lt;denomination&gt; = &apos;Quaker&apos;
*Class Republican 0
&lt;pacifist&gt; = no
&lt;party&gt; = &apos;Republican&apos;
</equation>
<bodyText confidence="0.998616434782609">
Here, the &apos;lexical class&apos; Nixon has two direct superclasses, Quaker and Republican—
as we shall see below, the order in which these are declared is significant. It also
contains the constraint that the value of the &lt;name&gt; attribute must be Nixon. Quaker
imposes two constraints; the value of &lt;denomination&gt; must be Quaker, and the value
of &lt;pacif ist&gt; must be yes, unless that would conflict with a value assigned in some
more specific class. The constraints embodied in Republican are that the value of
&lt;party&gt; must be Republican, while, again unless differently assigned in a more spe-
cific class, &lt;pacif ist&gt; has the value no.
What will be the result of looking up &apos;Nixon&apos; in this lexicon? The attributes
&lt;name&gt;, &lt;party&gt;, and &lt;denomination&gt; are unproblematic; the only conflict arises with
&lt;pac if ist&gt;. As indicated above, its value will depend on which of the two super-
classes of Nixon is the more specific, i.e., in this simple case, on the order in which they
appear in the superclass declaration; the declaration (Quaker Republican) states not
only what the direct superclasses of Nixon are, but also that Quaker is to be regarded
as more specific than Republican. Thus it is Quaker that will provide the value for
&lt;pacif ist&gt;. If the opposite answer were required, the appropriate declaration would
be (Republican Quaker).
A frequent approach to such matters in the AT community is to arrange for a
result where neither of the conflicting properties is inherited, so that, in the case of
the present example, the value of &lt;pacifist&gt; is unspecified. A trivial implementation
of this solution in the au lexicon would be to omit from the class definitions all
mention of pacifisthood; the semantics of graph unification is such that an absence of
information concerning some attribute is compatible with any possible value. If the
</bodyText>
<page confidence="0.9985">
318
</page>
<note confidence="0.978949">
Graham Russell et al. A Practical Approach to Multiple Default Inheritance
</note>
<figureCaption confidence="0.986984">
Figure 2
</figureCaption>
<bodyText confidence="0.994445142857143">
A partially ordered set of classes.
intention were to permit either of the values yes and no, but no other, then the value
of &lt;paci f i st&gt; could be supplied as a disjunction: &apos;yes/no.&apos;
Consider now a situation in which conflicting information occurs in nondirect
superclasses, say C and D in the lexicon below. No superclass declaration contains
both of these, and so the type of local ordering constraint imposed by the declarations
in the &apos;Nixon&apos; example is not available.
</bodyText>
<subsectionHeader confidence="0.450368">
#Word A (B D) #Class B (C) #Class C (F)
#Class D (E) #Class E (F) #Class F 0
</subsectionHeader>
<bodyText confidence="0.999065105263158">
The Eui lexicon employs the class precedence algorithm of the Common Lisp Object
System (CLOS) to derive a total order on the superclasses of each lexical class; we
adopt some of the CLOS terminology here.&apos; The resulting &apos;class precedence list&apos; (CPL)
contains the lexical class itself and all of its superclasses, from most specific to most
general, consistent with the local order given by class declarations. Informally, the
CPL is created by performing a topological sort on the partial order: the effect can
be seen most clearly in connection with a graphical representation such as that in
Figure 2, which represents the partial order generated by the local superclass ordering
constraints of the lexicon above.
Note that the left-to-right order of the two &apos;branches&apos; in Figure 2 reflects the order
in which B and D appear in the superclass declaration of A. The CPL is constructed by
traversing the graph in a depth-first, left-to-right manner, at any joins (such as F in this
case) splicing in the next leftmost path before continuing with depth-first computation.
The CPL of A in Figure 2 is therefore (A,B,C,D,E,F), with A being the most specific
and F the most general.&apos; This procedure deterministically selects one total ordering
from the set of orderings compatible with the superclass declarations; if none can be
derived, the system gives an error during compilation.
A given CPL can be derived from several sets of class definitions; the lexicons
shown below are some of those which, when compiled, will result in the same CPL
</bodyText>
<footnote confidence="0.4429094">
8 See Steele (1990: 782f0 for details of the algorithm, and Keene (1989: 118ff) for discussion.
9 The ordering relation of specificity on classes should not be confused with the subsumption relation on
feature structures; the former is determined by superclass declarations and is independent of the
information content of any constraints within the classes. Typically, more specific classes describe
smaller sets of words.
</footnote>
<page confidence="0.993022">
319
</page>
<figure confidence="0.894572461538461">
Computational Linguistics Volume 18, Number 3
A
Figure 3
An impossible hierarchy.
(A,B,C,D,E,F), as the example above:
#Word A (B) #Class B (C) #Class C (D)
#Class D (E) #Class E (F) #Class F 0
#Word A (B) #Class B (C) #Class C (D)
#Class D (E F) #Class E 0 #Class F 0
#Word A (B) #Class B (C) #Class C (D E F)
#Class D (E) #Class E (F) #Class F 0
#Word A (B C D) #Class B (F) #Class C 0
#Class D (E F) #Class E 0 #Class F 0
</figure>
<bodyText confidence="0.999388136363636">
The class precedence algorithm may thus be seen as defining an equivalence relation
on lexical specifications.
Patterns of inheritance between superclasses of a lexical class are determined solely
by the CPL. Note that this scheme excludes a number of configurations that have
figured in the AT literature. Dual paths from one class to another, of the sort shown in
Figure 3, cannot arise in the compiled lexicon; given a CPL (c1,. ca), the only path
from c, to ck is through every ci , 1 &lt;i&lt;j&lt;k&lt;n. However, there is no prohibition on
expressing the same information in two classes—this type of redundancy is harmless
in that it does not complicate the process of searching the hierarchy.
Another consequence is that cyclic hierarchies are precluded—no total order can
be constructed in which A &lt; B and B &lt;A. Intuitively, there is no reason for defining a
network with cyclic paths, when traversing the same portion of the network repeatedly
can add no more information and may introduce paradoxes.
Nor is there any means of expressing negative links of the kind shown in Figure 1.10
The au lexicon is thus what Touretzky et al. (1987) term a unipolar system. The
significance of this point is that the presence of exception links is another factor in
the complexity of a hierarchy; moreover, this type of negation is of dubious utility in
the present context, for two reasons. First, the precedence of default information from
subclasses appears to enable exceptionality to be expressed without explicit negation
of inheritance. The second reason is connected with the nature of graph unification.
The absence of a path-value pair P = &lt;p, v&gt; in a FS F cannot be interpreted as a
positive constraint that (some extension of) F does not have the property represented
</bodyText>
<footnote confidence="0.951752">
10 Negated inheritance links should not be confused with the negation introduced in Section 2.2, which is
defined over the unification of atomic feature structures.
</footnote>
<page confidence="0.993859">
320
</page>
<note confidence="0.957977">
Graham Russell et al. A Practical Approach to Multiple Default Inheritance
</note>
<bodyText confidence="0.999245083333333">
by P; a later unification may lead to P being added to F. The desired effect can only
be achieved by the presence in F of a distinct path-value pair &lt;p, v&apos;&gt;, where v and v&apos;
do not unify. Conflicting information of this type can be introduced by means of the
standard positive inheritance link.
In comparison with inheritance systems in general, then, the ELU lexicon is rather
restrictive. Hierarchies are constrained to be acyclic, unipolar, and unambiguous, these
limitations reflecting the desire not only to reduce the complexity of the system but also
to eliminate from it inessential or redundant aspects. Finally, the defaulting behavior of
the lexicon as a whole is determined by the CPLs of each lexical class, and these are in
turn derived from the superclass declarations within class definitions. This imposition
of a global organization by a collection of local constraints is attractively consistent
with the spirit of unification-based formalisms.
</bodyText>
<sectionHeader confidence="0.434849" genericHeader="method">
3. Information in the Hierarchical Lexicon
</sectionHeader>
<bodyText confidence="0.999003">
Having discussed the form and organization of the lexicon, we continue with an
account of the manner in which information distributed among its classes combines
to characterize a set of lexical items.
</bodyText>
<subsectionHeader confidence="0.999938">
3.1 An Informal Account of Lexical Access
</subsectionHeader>
<bodyText confidence="0.999050789473684">
Lookup of a lexical item with CPL c1,. c) proceeds as follows: starting with an
empty FS, the system first applies any default equations in cl, then applies any variant
sets in c1 to the result. The system then repeats this process on each resulting FS, for
the classes c,+1 to c, in turn. The result of lookup is the set of FSs produced by the
most general class c0; this set we term the global extension of the lexical class c1.
A set of default equations D {d1, dn} applies to a FS F as follows: each d, that
does not conflict with some existing information in F is unified with F, subject to the
condition that any reentrant substructure of F should be compatible with D, and that
any reentrant subset of D should be compatible with F. The purpose of this condition
is to preserve declarativeness; a set of equations that satisfy it may be applied without
regard to order.11 Any variant sets that exist in the current class are then applied to
the resulting FS F&apos;.
The result of applying variant sets {vi,..vn } to a FS F is the set of FSs {f1,. • • fm},
where each fi is the result of successfully unifying F with some different vi. Unification
failure in variant sets produces a null result, so m &lt; n. Variant sets have two effects:
they enforce strict constraints that cannot be overridden, and multiple variant sets
&apos;multiply&apos; FSs, e.g., to produce different members of an inflectional paradigm.
The lexicon below provides a simple nonlinguistic illustration of how defeasible
inheritance and nondefeasible inheritance interact in the lexicon.
</bodyText>
<equation confidence="0.840082375">
#Word A (B)
‹p 1&gt; = a
&lt;q 1&gt; = r
I &lt;q 1&gt; = s
#Class B (C)
&lt;p 1&gt; = b
&lt;p 2&gt; = b
I &lt;q 1&gt; = s
</equation>
<page confidence="0.8683455">
11 See Section 4.2 for an example of the interaction of reentrancy and default unification.
321
</page>
<note confidence="0.231736">
Computational Linguistics Volume 18, Number 3
</note>
<equation confidence="0.762087166666667">
*Class C 0
&lt;p 1&gt; = c
&lt;p 2&gt; = c
&lt;p 3&gt; = c
I &lt;q 2&gt; = t
&lt;q 2&gt; = u
</equation>
<bodyText confidence="0.948764333333333">
The CPL of A is (A,B,C). Applying the single default equation of class A to the empty
FS 1 produces the FS shown as (1) below; the result of applying the two variant sets
to this is the pair of FSs (2) and (3).
</bodyText>
<equation confidence="0.99885575">
(1) [ [ 1 a ]
(2) P [ 1 all [ El a ]
P (3)
Q 1 r ] Q [ 1 S
</equation>
<bodyText confidence="0.964896666666667">
Since there is no conflict between 1 and the information in class A the situation is
straightforward; two FSs are created, one for each of A&apos;s variant sets. Class B then
applies to each of these, but in this case conflicts do arise. The first is between the
values of P: 1 present in (2) and (3) and that specified in the default set of B. The
default constraint is overridden by the information contributed by the more specific
class A, while the equation providing the value of P: 2 succeeds, producing the FSs
</bodyText>
<listItem confidence="0.534852666666667">
(4) and (5).
(4) P {12 lapi (5) [ p [ 12 lap I 1
[ Q [ 1 r] IQ [is] i
</listItem>
<bodyText confidence="0.990746142857143">
The second conflict in class B arises from the single variant set, which permits only
the value s for Q: 1. This is a strict constraint, and, while (5) satisfies it, (4) does not.
Only (5), therefore, is considered by class C.
As before, the default set of C contains constraints (those involving P: 1 and P :2)
that are overridden by existing information; the third default equation succeeds, and
yields (6). The two variant classes each add a value for Q :2, producing the FSs (7)
and (8).
</bodyText>
<figure confidence="0.983144166666667">
[ la - [ la
p [21 ab -I P 2b 2b
(6) I_ 3 cii 3c 3c
Q Els] [ 21 ts _ { 1 s ]
L2 u
(7) (8)
</figure>
<figureCaption confidence="0.96478">
Intuitively, (7) and (8) represent two alternative sets of information that the lexicon
associates with the lexical class A.
</figureCaption>
<bodyText confidence="0.999857357142857">
It is useful to have some terminology for the various steps we have just followed.
We shall refer to the result of applying to some FS F the set of default equations in
a class C as the default extension of F with respect to C. (1) above is thus the default
extension of I with respect to A, and (5) the default extension of (2) with respect to B,
for example. Similarly, we refer to the result of applying both default and variant set
information in a class C to some FS F as the superclass extension of F with respect to C.
The set containing (2) and (3) is then the superclass extension of (1) with respect to A,
that consisting of just (5) is the superclass extension of (2) with respect to B, and the
set containing (7) and (8) is the superclass extension of (5) with respect to C. Finally,
since C is the most general superclass of A, (7) and (8) together comprise the global
extension of the lexical class A.
Figure 4 shows the pattern of inheritance arising from this lexicon; classes are
labeled &apos;A,&amp;quot;B,&apos; and &apos;C,&apos; and within each the default and variant sets are identified as
&apos;d&apos; and &apos;v,&apos; respectively. Arcs are labeled with the names of FSs shown above.
</bodyText>
<page confidence="0.990195">
322
</page>
<note confidence="0.990091">
Graham Russell et al. A Practical Approach to Multiple Default Inheritance
</note>
<figureCaption confidence="0.980746">
Figure 4
</figureCaption>
<bodyText confidence="0.878619">
Feature structures characterized by the lexicon.
</bodyText>
<subsectionHeader confidence="0.963131">
3.2 Definitions
</subsectionHeader>
<bodyText confidence="0.956089">
Following the relatively informal presentation in the previous section, we continue by
refining some of the notions introduced there. We define the global extension of a lexical
class in terms of the auxiliary notions default extension and superclass extension.
3.2.1 Default Extension. Let 0 be a FS, and R(0) the restriction of 0 to reentrant paths,
i.e., the most general FS such that Vp,q kb(p) 0(q) --+ R(0)(p) R(0)(q)].&amp;quot; Then the
default extension of a FS 0 with respect to a set of FSs 111 is
</bodyText>
<equation confidence="0.49648">
Li11{,0eklii0Lizp T}
</equation>
<bodyText confidence="0.998049">
if both R(0) Li LJ W T and 0 Li R(11 IF) T, and T otherwise.
Each of the FSs in that can unify with ch. does so—those that cannot, because
they conflict with information already present, are ignored. This is the basis of the
defaulting behavior of the lexicon.
The condition referring to reentrancy takes account of the potential order-sensitivity
of the defaulting operation—only those main sets having this property can be applied
without regard to the relative order of the individual constraints within them. If the
condition is met then the application of defaults always succeeds, producing a feature
structure which, if no member of the set is applicable, is unchanged, i.e., identical to
0; otherwise the lookup fails.&apos;
</bodyText>
<subsubsectionHeader confidence="0.971025">
3.2.2 Superclass Extension. The superclass extension S of a FS 0 with respect to a class
</subsubsectionHeader>
<bodyText confidence="0.987103444444444">
C having a main equation set M and variant sets 01, ... vr, is
S(0, C) &lt;i&lt;nAv` T1,
where M&apos; is the smallest set of FSs such that each mE M describes some m&apos; E M&apos;, 01 is
the default extension of 0 with respect to M&apos;, and v; is the feature structure described
by v,.
S(0, C) is formed by applying to 0 any default equations in the main set of C,
and then applying to the result each variant set in C; for variant sets 01, ... vi,, the
result of this second stage is the set of FSs { where each &apos;01 is the result of
successfully unifying 0 with some different v1.
</bodyText>
<page confidence="0.62453">
12 Here, &apos;OW denotes the value of the attribute-value path p in the FS 0, and denotes token identity
</page>
<table confidence="0.3375355">
of its operands.
13 See Section 4.1 for a different approach to order sensitivity proposed by Carpenter (1991).
</table>
<page confidence="0.910236">
323
</page>
<figure confidence="0.669372">
Computational Linguistics Volume 18, Number 3
3.2.3 Global Extension. The global extension of a lexical class L having the CPL C =
(c1, . . c,,) is Gn, where Go --- {I}, and
Gi&gt;0 I Vcb E G1_1, tif --= S(0, ci)}
</figure>
<bodyText confidence="0.998256428571429">
To speak in procedural terms, 1 is the empty FS that is input to C; each c, in C yields as
its superclass extension a set of FSs, each member of which is input to the remainder
of C, (c,+1, ca). The global extension of L is then the yield of the most general class
in its CPL—expressed in a slightly different way, the global extension of L is the result
of applying to 1 the CPL of L.&apos;
The set of lexical items admitted by a lexicon consists of the union of the global
extensions of all lexical classes in the lexicon.
</bodyText>
<subsectionHeader confidence="0.978028">
3.3 Variant Sets—Discussion
</subsectionHeader>
<bodyText confidence="0.999985473684211">
Variant sets may be thought of as representing a restricted form of disjunction over
complex FSs. Kasper and Rounds (1986) show general disjunctive unification to be in-
tractable, since it involves an exponentially complex step of expansion to disjunctive
normal form. Note, however, that the alternation embodied in variant sets is guaran-
teed to be at the &apos;top level&apos; of FSs only; that is to say, the FSs described by multiple
variant sets are already in disjunctive normal form, apart from any atomic disjunctions
they may contain. For this reason, multiple variant sets impose no mutual constraints;
regardless of whether the information they contain is orthogonal, complementary, or
conflicting, the crucial factor is the unifiability of each variant set individually with
the single candidate FS.
The variant set mechanism tends to suggest a close connection between strict
constraints and multiple realizations of class membership. Clearly, a class may have
a single variant set, so nondefeasible information does not entail alternation. On the
other hand, it may at first appear that the system forces a style of analysis in which, for
example, all members of an inflectional paradigm have equal status. In many cases, this
will be undesirable. Consider once more the class of regular English verbs; instead of
encoding their inflectional behavior by means of class Reg_Verb_Present below, one
might well wish to express the generalization that five out of the six present tense
forms are identical, and treat the sixth as an exception.
</bodyText>
<equation confidence="0.931072714285714">
#Class Reg_Verb_Present (Verb)
&lt;agr&gt; = sgl &lt;form&gt; = &lt;stem&gt;
&lt;agr&gt; = sg2 &lt;form&gt; = &lt;stem&gt;
&lt;agr&gt; = sg3 &lt;form&gt; = &lt;stem&gt; 8c8c s
&lt;agr&gt; = p11 &lt;form&gt; = &lt;stem&gt;
&lt;agr&gt; = p12 &lt;form&gt; = &lt;stem&gt;
&lt;agr&gt; = p13 &lt;form&gt; = &lt;stem&gt;
</equation>
<bodyText confidence="0.600907">
14 The fact that G, is defined here recursively in terms of G1_1 should not be misinterpreted as reflecting
a &apos;top-down&apos; view of inheritance—the default unification performed in order to compute the default
extension of a FS requires a bottom-up view, in which more specific classes are inherited from before
more general ones.
</bodyText>
<page confidence="0.994617">
324
</page>
<note confidence="0.984616">
Graham Russell et al. A Practical Approach to Multiple Default Inheritance
</note>
<bodyText confidence="0.993724333333333">
A more attractive analysis would involve the use of a class that encodes in one variant
set just the exceptional case, and in a second provides sufficient information to exclude
that exception from a default stated in a more general class.
</bodyText>
<figure confidence="0.60301">
#Class Reg_Verb_Present_Exception (Verb)
&lt;agr&gt; = sg3 &lt;form&gt; = &lt;stem&gt; &amp;&amp; s
1
&lt;agr&gt; = sglisg2/p11/p12/p13
#Class Verb 0
&lt;form&gt; = &lt;stem&gt;
</figure>
<bodyText confidence="0.994882964285714">
The lexicon will generally be called upon to establish a pairing of morphosyn-
tactic information (tense, case, agreement, etc.) and phonological or graphological in-
formation (the form taken by the variant of a word that expresses a particular mor-
phosyntactic property). The two kinds of information will normally be expressed as
the values of distinct attributes, in which case the semantics of default unification set
out in Section 3.2 will not enforce the intended pairing. The strict unification apply-
ing within variant sets causes equations to be interpreted in the conventional way
for unification-based linguistic descriptions, i.e., as conjunctive constraints on feature
structures. In practice, it is tempting to think of the lexicon as operating in a direc-
tional manner. Looking up a word involves retrieving from the lexicon the collection
of morphosyntactic properties expressed by a given word form, and here the natural
informal interpretation will be that the existence of that wordform implies the pres-
ence of those properties. Generating a word, on the other hand, involves retrieving
the word form that expresses a given set of morphosyntactic properties, and here the
natural informal interpretation will be the reverse. Nevertheless, the system retains
the nondirectionality of unification, and this informal view of its operation is no more
than a convenient approximation to its underlying semantics.
Since strict constraints are able to filter out unwanted intermediate solutions, com-
puting the global extension of a lexical class will in general involve creation of a larger
number of FSs than appear in the result. If v(c) is the number of variant sets in the class
c, and f is the function in the natural numbers such that f (0) = 1 and f (k) = k if k&gt; 0,15
the maximum number of FSs constructed for a lexical class with the CPL cn) is
given by
This maximum arises when no failures of strict unification occur.
Finally, while the variant set mechanism provides some of the functionality of
the lexical rules proposed by Flickinger et al. (1985), Calder (1989), and others, the
structure of the EL U lexicon does not admit the full range of capabilities of these more
powerful devices; cyclic rule applications cannot be simulated, for example.
</bodyText>
<sectionHeader confidence="0.904241" genericHeader="method">
4. Some Comparisons
</sectionHeader>
<bodyText confidence="0.9177696">
As we mentioned briefly in Section 1, the idea of applying inheritance to the lexicon,
and indeed to linguistic descriptions in general, is not a new one. Here we consider a
few of the proposals that have appeared in recent years.
15 Classes with one or no variant set yield at most a singleton superclass extension for each FS they apply
to, while others multiply a FS by a factor of no more than their total number of variant sets.
</bodyText>
<page confidence="0.987415">
325
</page>
<note confidence="0.496791">
Computational Linguistics Volume 18, Number 3
</note>
<subsectionHeader confidence="0.90346">
4.1 Defaults and Reentrancy
</subsectionHeader>
<bodyText confidence="0.99600225">
The notion of &apos;default extension&apos; employed here resembles the &apos;priority union&apos; of
Kaplan (1987: 180f) and the &apos;conservative addition&apos; of Shieber (1986b). As Bouma (1990)
points out, the result of defaulting under this approach may depend on order of
application. To take Bouma&apos;s (p. 166) simple example, default unification of the FSs
</bodyText>
<figure confidence="0.990862294117647">
(1) [ F a] (2) [a b
with a re-entrant structure
o[i
produces different, nonunifying, results:
[Fa] (5) F 1:0]b]
(4)
G [G
(4) results when (1) applies before (2), and (5) when (2) applies before (1).
Similarly, defaulting the FSs
(6) F 131 (7) [G 13]
G
onto a FS
(8) [ F a]
produces one of
[F W al
(9) (10) IF al
G Lab]
</figure>
<figureCaption confidence="0.700459">
according to whether (6) applies before (7), in which case the result is (9), or (7) applies
before (6), to produce (10).
</figureCaption>
<bodyText confidence="0.999463384615385">
Both situations are avoided in the au system by making applicability of defaults
conditional on the unifiability of reentrant subsets of the default information and
candidate structure (see Section 3). The first case, where the candidate FS (3) contains
a reentrancy that has nonunifying extensions in the default information (1 and 2), is
excluded by the requirement that R(3) LI 11{1,2} T, and the second case, where a
reentrancy in a default FS (6) has nonunifying extensions in the candidate FS (8) and
other default FSs (7), is excluded by the requirement that (8) LJ R(11{(6), (7)1) T.
Carpenter (1991) proposes a more permissive view of default unification in which
conflicts of this type are resolved in one of two modes, &apos;credulous&apos; and &apos;skeptical.&apos;
Credulous default unification preserves the maximum possible default information,
and is defined so as to produce a (nonempty) set of solutions. For example, the result
of credulously defaulting (11) (the unification of 6 and 7 above) onto (8) is the set of
solutions (12) (i.e., 9 and 10).
</bodyText>
<figure confidence="0.534485666666667">
{F Wbl (12) [F Wa Fa
(11) G m [G bll
La j
</figure>
<bodyText confidence="0.72059425">
Skeptical default unification retains only consistent information, and is defined as the
generalization of such a set of solutions.&apos; Skeptically defaulting (11) onto (8) produces
16 The generalization of two FSs corresponds to their greatest lower bound in the subsumption lattice. See
Karttunen (1984).
</bodyText>
<page confidence="0.997436">
326
</page>
<note confidence="0.983924">
Graham Russell et al. A Practical Approach to Multiple Default Inheritance
</note>
<bodyText confidence="0.972238">
the FS (13), in which the only default information to have been preserved is that
concerning the presence of an attribute G, whose value, since it conflicts with that in
(8), is unspecified:
</bodyText>
<equation confidence="0.973986333333333">
[
(13) F a
G _L
</equation>
<bodyText confidence="0.999954">
Neither of these proposals for the treatment of inconsistent default information
is equivalent to ours. Of the various properties of skeptical and credulous default
unification noted by Carpenter, the au lexicon shares the following.
</bodyText>
<listItem confidence="0.9914552">
(i) Strict information is preserved—i.e., default unification is monotonic (see
Section 4.2).
(ii) Default unification reduces to standard unification if the two FSs
involved are consistent.
(iii) Default unification is finite.
</listItem>
<bodyText confidence="0.99967525">
The fourth property, that skeptical and credulous default unification are both well
defined in all cases, is not shared by the present system—as we have seen above, the
definition of default extension (Section 3.2) produces no solution for unifications of
the type illustrated here.
</bodyText>
<subsectionHeader confidence="0.971913">
4.2 Monotonicity
</subsectionHeader>
<bodyText confidence="0.997953153846154">
The &apos;template&apos; facility of PATR-II (Shieber 1986a: 55ff) allows inheritance within the
lexicon. Lexical entries may be defined by means of templates that have other templates
in their definitions. Thus, if the definition of a template T1 mentions the templates T2
and T3, any entry in which T1 appears also receives the contents of T2 and T3. This is a
form of strict multiple inheritance, since, if T2 and T3 contain conflicting information,
unification fails and no corresponding lexical item is created. Shieber (1986a: 59ff) also
describes a type of default inheritance implemented in terms of a noncommutative
&apos;overwriting&apos; operation, in which constraint equations may be formulated so as to
take precedence over existing structures. These devices permit the construction of
heterogeneous systems like that of au; one difference between the two would be
that, in Shieber&apos;s scheme, the statements exhibiting default behavior are ones that
have the ability to override others over which they have precedence, whereas in the
approach described above the default statements are ones that can be overridden by
others that have precedence over them.
In the D-PATR environment presented by Karttunen (1986), all templates engage
in defaulting: &amp;quot;... templates and other specifications that occur [in lexical entries] are
processed sequentially from left to right. Each item is compiled to a directed graph
and superimposed on the graph previously compiled&amp;quot; (p. 76). Here, then, defaulting
occurs as standard; any sequence of statements in a lexical entry may be such that a
later statement conceals the effect of an earlier one. Again, the fact that defaulting is
interpreted as the overwriting of one structure by another means that structures may
be modified in a nonmonotonic fashion.
The implementation of defaults in au contrasts with these approaches in that
the system ensures the monotonicity of structure-building—given a CPL (ci, ca),
any FS F admitted by a class ci subsumes every FS that can be created by applying
to F the classes (c,+1, i &lt; m &lt; n.1&apos; This follows directly from the definition of
</bodyText>
<page confidence="0.9540385">
17 &apos;Apply&apos; here is used in the sense introduced in Section 3.2.
327
</page>
<note confidence="0.529508">
Computational Linguistics Volume 18, Number 3
</note>
<bodyText confidence="0.999201444444444">
&amp;quot;default extension&amp;quot; given in Section 3.2. Each individual constraint in a default set
contributes information to a FS F if and only if that information is consistent (i.e.,
unifies) with the existing contents of F. Inconsistent information is ignored, but since
it is only inconsistent information that would be capable of destructively modifying
F, by removing or replacing some of its content, the consequence is that F subsumes
its default extension with respect to any set of constraints; moreover, since the other
operations involved in determining superclass extension employ only conventional
&apos;strict&apos; unification, these are equally unable to introduce into the system any element
of nonmonotonicity.
</bodyText>
<subsectionHeader confidence="0.769529">
4.3 Other Issues
</subsectionHeader>
<bodyText confidence="0.996069263157895">
Inheritance hierarchies are frequently employed in object-oriented programming lan-
guages and environments. Some work in computational linguistics has been explicitly
object-oriented in nature (Daelemans 1990; De Smedt 1984; De Smedt and de Graaf
1990) but, as Gazdar (1990) observes, this has tended to adapt existing general-purpose
techniques and languages, rather than attempt to devise specialized linguistic for-
malisms. Daelemans (1990) suggests that inheritance can replace unification as a basic
mechanism for linguistic description, but his proposals remain relatively undeveloped.
In some ways, the use of typed FSs and other data structures in au represents a
step toward a rapprochement of unification and object-oriented techniques. However,
object-oriented programming involves much more than the use of inheritance, and the
lack of mechanisms in ELu implementing encapsulation of data or message-passing
protocols means that it would be a mistake to classify the work presented here as a
variety of object-oriented linguistic description.
DATR (Evans and Gazdar 1990) is a language designed for the definition of in-
heritance networks for use in lexical specification. Its syntax is similar to ELu&apos;s in
that paths and their values are grouped together into compound statements, in DATR
called &apos;nodes,&apos; but at a less superficial level the two systems are quite different. An
example will make some of the differences clear. The theory below defines two nodes,
A and B:
</bodyText>
<equation confidence="0.87209125">
A: &lt;pl&gt; ==vi
&lt;p2a p2b&gt; == v2
&lt;p3&gt; == B.
B: &lt;p3&gt; == v3.
</equation>
<bodyText confidence="0.999867333333333">
The values of &lt;pl&gt; and &lt;p2a p2b&gt; in A are set locally, while the value of &lt;p3&gt; is
inherited from B. Inheritance of values is thus specialized to individual paths in DATR,
rather than applying uniformly to entire classes as in Elm. Moreover, the defaulting
mechanism of DATR is independent of the inheritance mechanism, and based on path
extension; an equation of the form &apos;&lt;al , ai&gt; == v&apos; allows v to be inferred as the value
of all paths &lt;a1,.ak&gt;, 1 &lt;i &lt; k, such that no initial subpath &lt;al, ... aj&gt;, i &lt;j &lt; k, has
explicitly been assigned a different value. As a consequence, the objects manipulated
by DATR are strictly linear, in contrast to the more general feature structures that
form the basis of the au lexicon18—in practice, path-value equations in DATR tend
to correspond to variant sets in ELu.
Flickinger et al. (1985) present a model of the lexicon based on multiple default
inheritance in the frame language HPRL (Rosenberg 1983). Two inheritance modes
</bodyText>
<footnote confidence="0.540351">
18 This is not to say that the two are not interconvertible—see Kilbury et al. (1991).
</footnote>
<page confidence="0.99692">
328
</page>
<note confidence="0.983929">
Graham Russell et al. A Practical Approach to Multiple Default Inheritance
</note>
<bodyText confidence="0.999973735294117">
exist: &apos;normal,&apos; a conventional shortest-path default method in which a slot is filled by
information from the most specific accessible node in the hierarchy, and &apos;complete,&apos; by
which multiple values for a slot are obtained from a number of more general frames.
Values for the FEATURES slot for the word has thus include (AUX PLUS) inherited
from AUXILIARY, (AGREEMENT 3RD-SING) from THIRD-SING, and (CONTROL SSR) from
SUBJECT-RAISE. The values in this example are compatible; the question of contradic-
tions in complete-mode inheritance is raised, but it is not stated whether any that do
occur are resolved, produce inconsistent results, or cause the search to fail. Flickinger
(1987: 60) refers to constraining the hierarchy &amp;quot;in such a way that each single-valued
attribute of some given class or member [is] assigned a value by at most one of the
immediate superclasses, or its parents, so conflicting values [cannot] occur,&amp;quot; but does
not indicate whether this constraint is to be imposed automatically as part of a com-
pilation or consistency checking process, or is simply to take the form of advice to
users. He considers as an alternative a rule of inheritance &amp;quot;which for each attribute
assigns priority to some one of the parent classes,&amp;quot; and a convention similar to that
of the au lexicon, whereby precedence of direct superclasses is encoded in the order
of elements in a list.
The system described by Padgham (1988) resembles the au lexicon in taking the
objects in the hierarchy as being sets of properties, partitioned into strict and defeasible
subsets: &amp;quot;The type core includes those characteristics which we regard as always present
in objects of this type .... The type default contains the information for typical objects of
that type.&amp;quot; Padgham&apos;s types may also be partially specified, and thus bear quite a close
resemblance to ELU classes with single variant sets. Where this arrangement differs
from the ELU lexicon is in permitting inheritance links between types to involve just
these substructures; to represent the fact that instances of type T1 are always typical
instances of type T2, a link connects the core of T1 and the default of T2, and so on.
Negative relations between core and default substructures may also be expressed.
Inheritance hierarchies have chiefly been studied within two overlapping but con-
ceptually distinguishable subareas of artificial intelligence: knowledge representation
and commonsense reasoning. The latter of these domains is characterized by concerns
that extend beyond those of the present work. For example, problems of reasoning
with possibly incomplete knowledge do not arise in the context of lexical organiza-
tion, since for any query the writer of a lexicon can be assumed to have envisaged the
entire conclusion space and all factors required for computing it.
</bodyText>
<sectionHeader confidence="0.923557" genericHeader="method">
5. Example Analyses
</sectionHeader>
<bodyText confidence="0.953087454545455">
This section contains some longer linguistic examples illustrating aspects of the ELU
lexicon introduced above. While these analyses are correct in the sense that they char-
acterize sets of feature structures that achieve the desired pairing of word forms and
morphosyntactic properties, it should of course be borne in mind that each represents
just one treatment among the many possible.
5.1 English Irregular Verbs
In most cases, lexical items that realize certain morphosyntactic properties in irregular
forms do not also have regular realizations of those properties; thus *sinked, on the
analogy of, e.g., walked, is not a well-formed alternative to sank or sunk. This phe-
nomenon has frequently been discussed in both theoretical and computational mor-
phology, under the title of &apos;blocking,&apos; and it appears to provide clear motivation for a
</bodyText>
<page confidence="0.996047">
329
</page>
<note confidence="0.636721">
Computational Linguistics Volume 18, Number 3
</note>
<bodyText confidence="0.999197625">
default-based hierarchical approach to lexical organization.&apos; There are exceptions to
the general rule, however, and inheritance mechanisms must be sufficiently flexible to
permit deviation from this pattern.
Consider the small class of English verbs including dream, lean, learn, and burn;
these have, for many speakers, alternate past finite and past participle forms: e.g.,
dreamed and dreamt. The following fragment produces the correct analyses, in which
the value of &lt;morph&gt; expresses inflectional information, and that of &lt;f orm&gt; is the
corresponding word form.&amp;quot;
</bodyText>
<figure confidence="0.776708526315789">
#Word walk (Verb)
&lt;stem&gt; = walk
#Word sink (Verb)
&lt;stem&gt; = sink
&lt;p_fin_form&gt; = sank &lt;psp_form&gt; = sunk
#Word dream (DualPast Verb)
&lt;stem&gt; = dream
#Class DualPast
&lt;psp_form&gt; = &lt;stem&gt; Raz t
&lt;p_fin_form&gt; = &lt;stem&gt; &amp;&amp; t
&lt;morph&gt; = pastfinite/pastnonfinite
#Class Verb 0 &lt;form&gt; = &lt;stem&gt; &amp;&amp; s
&lt;cat&gt; = v &lt;form&gt; = &lt;stem&gt;
&lt;p_fin_form&gt; = &lt;stem&gt; &amp;&amp; ed &lt;form&gt; = &lt;p_fin_form&gt;
&lt;psp_form&gt; = &lt;stem&gt; &amp;&amp; ed &lt;form&gt; = &lt;psp_form&gt;
&lt;morph&gt; = present_sg3
&lt;morph&gt; = present_nonsg3
&lt;morph&gt; = pastfinite
&lt;morph&gt; = pastnonfinite
</figure>
<bodyText confidence="0.999060818181818">
The lexical class of a regular verb such as walk contains a minimum of idiosyncratic
information, the value of the feature &lt;st em&gt;. Its direct superclass, Verb, contributes the
information that the value of &lt;cat&gt; is v, and that the values of both &lt;p_fin_form&gt; and
&lt;psp_form&gt; are the result of concatenating the &lt;st em&gt; value and ed. In addition to this
default information, Verb has four variant sets, corresponding to the four combinations
of &lt;morph&gt; and &lt;form&gt; values admitted by the fragment. Finite and nonfinite past
forms are both associated via the values of &lt;p_fin_form&gt; and &lt;psp_form&gt; with the
string walked, the third person singular present tense variant is assigned the string
walks, and the word form representing the other present tense variants is walk.
Irregular verbs differ in having the two past forms specified in their lexical class.
The defeasible constraints providing values for &lt;psp_form&gt; and &lt;p_fin_form&gt; in Verb
</bodyText>
<footnote confidence="0.984623">
19 Blocking is a consequence of the architecture proposed by Calder (1989) and of the DATR language.
20 The analysis sketched here is simplified in the sense that several variants within the Verb class have
been omitted, all inflectional information is embodied as the value of the single feature &lt;morph&gt;, and
no account is given of the various spelling alternations that accompany suffixation.
</footnote>
<page confidence="0.993186">
330
</page>
<note confidence="0.989759">
Graham Russell et al. A.Practical Approach to Multiple Default Inheritance
</note>
<bodyText confidence="0.999960846153846">
are overridden by this more specific information, so that while sink behaves like regular
verbs in its present tense, the values of &lt;form&gt; for the past finite and past nonfinite
variants are sank and sunk.
Verbs like dream have DualPast as a direct superclass, with higher precedence than
Verb. DualPast has two variant sets, the first of which assigns as values of &lt;psp_form&gt;
and &lt;p_f in_form&gt; the concatenation of the &lt;st em&gt; value and t, giving dreamt, etc.
The second variant set is empty (recall that variant sets are preceded by the vertical
bar &apos; I &apos;) and the absence of contradictory specifications in this second variant permits
the equations in the main set of Verb to apply. In addition to specifying exceptional
properties, therefore, the definition of DualPast also permits inheritance of properties
from more general classes; among these properties is that shared by verbs like walk of
forming the two past forms by suffixing ed to the stem, which produces the regular
(dreamed, etc.) past forms.
</bodyText>
<subsectionHeader confidence="0.99985">
5.2 German Separable Verbs
</subsectionHeader>
<bodyText confidence="0.999992142857143">
Two large classes of German verbs are the separable- and inseparable-prefixed com-
pound verbs; their analysis involves some quite intricate interactions of morphologi-
cal, syntactic, and semantic information. Separable verbs are of interest syntactically
because, as their name suggests, the prefix is a bound morpheme only in certain syn-
tactic environments, namely when the verb is untensed or head of a verb-final clause.&apos;
Members of both classes share morphological, but not necessarily syntactic or seman-
tic, properties of the verb that corresponds in form to their stem. The separable-prefix
verb weglaufen (&apos;run away&apos;) and inseparable verlaufen (&apos;elapse&apos;) are two such verbs
that the lexicon should be able to relate to their apparent stem laufen (&apos;run&apos;), assigning
them similar morphological properties—laufen then becomes the model for a family
of verbs. Morphosyntactic peculiarities of the separable verbs include the form of the
past participle, in which the normal past participle prefix ge- is preceded by the sep-
arable prefix (e.g., weggelaufen), and the existence of an infinitive form, in which the
separable prefix is followed by zu (e.g., wegzulaufen); the infinitive of other verbs is
formed phrasally (from the perspective of written language, at least) with the particle
zu as a separate word. Past participles of inseparable-prefix verbs omit the ge- prefix.
As in the example of Section 5.1, lexical classes encode just the idiosyncratic prop-
erties of verbs. Here, for compound verbs related to laufen, only their semantics is
specified at this level; other properties are inherited from classes associated with the
prefix and stem. The class lauf en, in addition, specifies that the form of the past tense
stem for this family of verbs is lief.
</bodyText>
<equation confidence="0.831570714285714">
#Word laufen (VStem Strong)
&lt;sem&gt; = laufen
&lt;morph past_stem&gt; = lief
#Word weglauf en (Weg lauf en)
&lt;sem&gt; = weglauf en
#Word verlauf en (Ver lauf en)
&lt;sem&gt; = verlauf en
</equation>
<bodyText confidence="0.9956225">
The class Ver inherits from NonSeparable, where values for &lt;morph psp prefix&gt; (the
form of prefix for the past participle) and &lt;morph pref ix&gt; (the form of prefix for other
</bodyText>
<footnote confidence="0.855761">
21 Within the syntactic analysis assumed here, their distribution is controlled by a binary feature
&lt;syn inv&gt;, whose value in these contexts is no, and elsewhere is yes.
</footnote>
<page confidence="0.992771">
331
</page>
<figure confidence="0.45608175">
Computational Linguistics Volume 18, Number 3
variants) are instantiated to the value of &lt;pref ix&gt; provided in Ver —the past participle
of verlaufen is thus verlaufen, etc.
#Class Ver (NonSeparable)
&lt;prefix&gt; = ver
#Class NonSeparable
&lt;morph prefix&gt; = &lt;prefix&gt;
&lt;morph psp prefix&gt; = &lt;prefix&gt;
</figure>
<bodyText confidence="0.99905375">
The behavior of separable verbs is more complex, and involves a number of variant
sets in the Separable class. The first of these accounts for the prefix occurring in the
past participle, which is the result of concatenating the value of &lt;morph pref ix&gt; and
ge—the past participle of weglaufen is thus weggelaufen. The second variant set accounts
similarly for the infinitive form wegzulaufen. The third accounts for all other forms of
a separable verb in which the prefix is attached; these are just the forms for which the
sentence grammar assigns the value no to the &lt;syn inv&gt; attribute, with the exception
of the past participle and infinitive, which receive special treatment. The fourth variant
accounts for the other cases, i.e., those finite verbs in which the prefix is detached, and
for which the sentence grammar assigns to &lt;syn inv&gt; the value yes. Here, the &lt;syn
prefix&gt; attribute encodes the form of the detached prefix for use by the sentence
grammar.
</bodyText>
<equation confidence="0.958575">
#Class Weg (Separable)
&lt;prefix&gt; = weg
#Class Separable 0
&lt;syn infl&gt; = psp
&lt;morph psp prefix&gt; = &lt;prefix&gt; ia ge
&lt;syn infl&gt; = inf
&lt;morph prefix&gt; = &lt;prefix&gt; &amp;&amp; zu
&lt;syn infl&gt; = -psp/inf
&lt;syn inv&gt; = no
&lt;morph prefix&gt; = &lt;prefix&gt;
&lt;syn infl&gt; = pres_sg_3/past_sg_3
&lt;syn inv&gt; = yes
&lt;syn prefix&gt; = &lt;prefix&gt;
</equation>
<bodyText confidence="0.999984833333333">
The role of the class VStem is rather different; it serves to identify the substring of
a verb&apos;s citation form that corresponds to its &amp;quot;base stem.&amp;quot; For the majority of verbs,
whose citation form ends in -en, this is what results when any prefix (with the empty
string as default) and the final -en are detached. For the minority of verbs whose
citation form ends in -em n or -ern, only the final -n is detached. Recall that the citation
form of verbs in this lexicon coincides with the value of the &lt;sem&gt; attribute.
</bodyText>
<equation confidence="0.9635212">
#Class VStem (Verb)
&lt;prefix&gt; = &amp;quot;
&lt;sem&gt; = &lt;prefix&gt; &amp;&amp; &lt;morph bse stem&gt; &amp;&amp; en
&lt;sem&gt; = &lt;prefix&gt; &amp;&amp; &lt;morph bse stem&gt; &amp;&amp; n
&lt;sem&gt; = _ &amp;&amp; ln/rn
</equation>
<page confidence="0.996483">
332
</page>
<note confidence="0.988976">
Graham Russell et al. A Practical Approach to Multiple Default Inheritance
</note>
<bodyText confidence="0.999775818181818">
The lexical class lauf en inherits directly, and weglauf en, etc., indirectly, from the
Strong class. Some strong verbs undergo a stem alternation known as &apos;Umlaut&apos; in
certain parts of their paradigm—the third person singular of the present tense for
laufen is liiuft, for example. This modification is performed here by the macro call in
the main set of the Strong class; Umlaut is defined elsewhere as a macro that employs
the string concatenation operator described in Section 2.1 to segment the string passed
as its first argument, change the vowel, and reassemble the components to produce
its second argument. Strong verbs form their past participle with the suffix -en, where
weak verbs have -t. Their second and third person singular present tense forms may
undergo vowel modification as described above, and the past tense forms are irregular,
with a zero suffix for the first and third person singular.
</bodyText>
<equation confidence="0.853134153846154">
#Class Strong (VInfl Verb)
I
&lt;syn infl&gt; = psp
&lt;morph psp suffix&gt; = en
I
!Umlaut(&lt;morph bse stem&gt;,&lt;morph stem&gt;)
&lt;syn infl&gt; = pres_sg_3
I
&lt;syn infl&gt; = past_sg_3
&lt;morph suffix&gt; = ))
&lt;morph stem&gt; = &lt;morph past_stem&gt;
1
&lt;syn infl&gt; = -psp/pres_sg_3/past_sg_3
</equation>
<bodyText confidence="0.9997321">
Other members of the paradigm are described by the fourth variant set of Strong, the
function of which is not to add information, but rather to permit them to inherit from
VInf 1 properties common to weak verbs. VInf 1 contains default statements concerning
the past participle form: unless contradicted by more specific information, this is to
be constructed from the prefix ge-, the suffix -t, and the value of &lt;morph bse stem&gt;
provided in VSt em. The weak verb warten, for example, has the past participle gewartet.
The &apos;base&apos; or &apos;bare infinitive&apos; form is constructed similarly, and the suffix for the third
person singular of the present tense is stated to be -t, to give lauft, etc. As before, the
fourth variant set permits members of the paradigm not treated explicitly in this class
to inherit from Verb.
</bodyText>
<equation confidence="0.959751055555556">
#Class VInfl (Verb)
&lt;morph psp prefix&gt; = ge
&lt;morph psp suffix&gt; = t
&lt;morph psp stem&gt; = &lt;morph bse stem&gt;
&lt;syn infl&gt; = psp/bse/pres_sg_3/past_sg_3
1
&lt;syn infl&gt; = psp
&lt;form&gt; = &lt;morph psp prefix&gt; &amp;&amp;
&lt;morph psp stem&gt; &amp;&amp; &lt;morph psp suffix&gt;
I
&lt;syn infl&gt; = bse
&lt;form&gt; = &lt;morph prefix&gt; &amp;&amp;
&lt;morph bse stem&gt; &amp;&amp; en
I
&lt;syn infl&gt; = pres_sg_3
&lt;morph suffix&gt; = t
1
&lt;syn infl&gt; = -psp/bse/pres_sg_3
</equation>
<page confidence="0.995982">
333
</page>
<note confidence="0.605746">
Computational Linguistics Volume 18, Number 3
</note>
<bodyText confidence="0.999959375">
The most general class, Verb, establishes default values for prefix, stem, and suf-
fix attributes, and states that the default &lt;f orm&gt; value is the result of concatenating
whatever values these attributes have been assigned, either in this class or in more
specific ones. It also states that, by default, a verb has no detached separable prefix;
tensed separable verbs are exceptions to this, and receive their &lt;syn pref ix&gt; value
in the Separable class. The two variant sets in Verb serve to restrict the syntactically
relevant &lt;syn inv&gt; attribute to a no value for the base, past participle, and infinitive
forms, while leaving tensed verbs able to take either value.
</bodyText>
<figure confidence="0.53805475">
#Class Verb 0
&lt;cat&gt; = v
&lt;syn prefix&gt; = none
&lt;morph stem&gt; = &lt;morph bse stem&gt;
&lt;morph prefix&gt; = &amp;quot;
&lt;morph suffix&gt; = en
&lt;form&gt; =
&lt;morph prefix&gt; &amp;&amp; &lt;morph stem&gt; &amp;&amp; &lt;morph suffix&gt;
&lt;syn infl&gt; = bse/psp/inf
&lt;syn inv&gt; = no
1
&lt;syn infl&gt; = &amp;quot;bse/psp/inf
</figure>
<sectionHeader confidence="0.77615" genericHeader="evaluation">
6. Implementational and Practical Issues
</sectionHeader>
<bodyText confidence="0.995983">
The introduction stated three main requirements imposed by the context within which
the ELu lexicon system is used: the ability to both analyze and generate word forms,
good integration with other components that interface to the lexicon system (for ex-
ample parsers and generators), and the ability to accommodate a large number of
words. Our implementation, though relatively straightforward, achieves these goals,
making the system genuinely useful in practice; this section briefly discusses some of
the implementational issues involved.
</bodyText>
<subsectionHeader confidence="0.699289">
6.1 Analysis and Generation of Word Forms
</subsectionHeader>
<bodyText confidence="0.999988076923077">
In Section 3, the set of lexical items admitted by a lexicon was defined formally as
the union of the global extensions of all lexical classes in the lexicon. This definition
suggests an obvious (bottom-up) implementation of the analysis and generation of
word forms: collecting up all the lexical classes in the lexicon, and computing the
union of their global extensions, in analysis returning only the FSs with wordform
attribute the same as the word form being analyzed, and in generation returning only
the word forms whose FSs unify with the structure being generated from.
This form of exhaustive search is computationally expensive for all but the smallest
lexicons—however, it does allow all unification and defaulting operations to be traced,
so that when developing a lexicon (and working with only a representative sample of
lexical classes) the user can precisely monitor the effects of adding new classes and
modifying old ones. The tracing information is presented in an order and a manner
that appears natural to a user who understands global extension.
</bodyText>
<subsectionHeader confidence="0.88694">
6.2 Efficiency
</subsectionHeader>
<bodyText confidence="0.9987485">
While a lexicon is being debugged, all the words and classes in it are held in main
memory, and analysis and generation are performed using exhaustive search, as de-
scribed above. Once the lexicon is fully debugged, this approach has three major
drawbacks: since they are ordinary text files, large lexicons take a long time to load
</bodyText>
<page confidence="0.996828">
334
</page>
<note confidence="0.98797">
Graham Russell et al. A Practical Approach to Multiple Default Inheritance
</note>
<bodyText confidence="0.999953038461539">
into the system, once in memory the representations of the classes in them occupy
a lot of space (increasing process size and swapping and garbage collection time),
and exhaustive search over all the lexical classes on every lookup is too inefficient for
practical purposes.
To solve these problems, we have implemented a facility that indexes a lexicon,
storing all the information in it in a machine-oriented format in files on disc. The
format is such that the information can be retrieved quickly with minimal processing.
One index file holds all the classes in the lexicon, each superclass in a class&apos;s CPL being
stored as an integer representing the byte position in the file at which its definition
starts. During the indexing process, for each lexical class, all the lexical items admit-
ted by the class are generated. The index file byte position of the class is associated
with each distinct word form in the lexical items.&apos; This position is also associated
with the name of each semantic relation occurring in the lexical items. At the end
of indexing these pairings are lexicographically sorted and written out to index files.
Analysis works by searching for the word form (using a binary chop on the word
form index file), retrieving the byte positions associated with the form, fetching the
lexical classes at these positions together with their superclasses, and performing an
exhaustive lookup (as described above) using just these lexical classes. Generation is
similar but instead uses the semantic relation index.
If there are n possible word forms implicit in a lexicon, then analyzing one form
will take time proportional to c • log2(n) where c is a small constant, plus in the average
case a constant time for lookup with the candidate lexical classes. Generation similarly
will take time proportional to log2 of the total number of semantic relations in the
lexicon plus a constant. In practice, the size of the lexicon makes little difference to
lookup time; what really matters is the number of classes in the CPLs of lexical classes
and their complexity.
</bodyText>
<subsectionHeader confidence="0.993963">
6.3 Integration
</subsectionHeader>
<bodyText confidence="0.999921545454545">
The FLU lexicon system is fully integrated with the rest of ELU. The fact that the lexicon
is based on multiple default inheritance is transparent to the analyzer and generator
(and even to the casual user). Indeed, au supports another type of lexicon based on
finite state morphology; lexicons of this type are accessed via the same interface, and
one may be loaded and available for use at the same time as an inheritance-based
lexicon.
One of the characteristics of the au lexicon system that has allowed it to be so
well integrated with the other components in the system is that it represents feature
structures in exactly the same way that they do. In particular, au does not have to
convert from one representation to another at the interface to the lexicon, as does
DATR when used within a unification grammar system (Kilbury et al. 1991).
</bodyText>
<sectionHeader confidence="0.920654" genericHeader="conclusions">
7. Summary
</sectionHeader>
<bodyText confidence="0.9998992">
The popularity of unification as a tool for computational linguistics stems from its
declarative, monotonic semantics; however, the price to be paid for the benefits of a
pure unification framework is the lack of a satisfactory treatment of exceptions (nega-
tion, defaults, etc.). The popularity of default inheritance as a tool for knowledge
representation stems from its ability to encode, in a straightforward manner, the type
</bodyText>
<footnote confidence="0.626554">
22 In theory, the system can deal with lexicons admitting up to around 4,000,000 word forms, but the
largest lexicon tested to date contains slightly more than 30,000 entries.
</footnote>
<page confidence="0.993651">
335
</page>
<note confidence="0.606321">
Computational Linguistics Volume 18, Number 3
</note>
<bodyText confidence="0.99996775">
of nested generalization with exceptions that natural language lexicons exhibit; how-
ever, in achieving this expressive power one introduces a degree of order-dependence
into the system. The approach presented here attempts to combine the advantages of
unification and default inheritance while minimizing the disadvantages arising from
their interaction.
Properties of general default systems that lead to intractability are absent; the
total ordering imposed on superclasses by the CPL eliminates cycles, ambiguity, and
the redundancy of multiple paths, while the suppression of negative inheritance links
removes a further source of complexity. Facilities have been dispensed with not only
because they are computationally problematic, but also as a result of the application
in question—as we observe in Section 2, ambiguity and negation are not essential in
the context of a unification-based lexicon.
</bodyText>
<sectionHeader confidence="0.992278" genericHeader="acknowledgments">
Acknowledgments
</sectionHeader>
<bodyText confidence="0.981658">
This paper is an expanded version of
Russell et al. (1990). We are indebted to
Mark Johnson for valuable comments on
that earlier work, and to Computational
Linguistics referees for their suggestions.
Participants at the ACQUILEX workshop on
default inheritance held in Cambridge in
April 1991 also made useful suggestions.
</bodyText>
<sectionHeader confidence="0.989761" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999717884615385">
Ballim, A.; Candelaria de Ram, S.; and Fass,
D. (1990). &amp;quot;Reasoning using inheritance
from a mixture of knowledge and
beliefs.&amp;quot; In Knowledge Based Computer
Systems: Proceedings of KBCS &apos;89 (Lecture
Notes in Artificial Intelligence no. 444),
edited by S. Ramani, R. Chandrasekar,
and K. S. R. Anjaneyulu, 387-396.
Springer-Verlag.
Ballim, A.; Fass, D.; and Candelaria de Ram,
S. (1988). &amp;quot;Resolving a clash of intuitions:
Utilizing strict and defeasible information
in an inheritance system.&amp;quot; CRL
Memoranda MCCS-88-119, Computing
Research Laboratory, New Mexico State
University.
Bouma, G. (1990). &amp;quot;Defaults in unification
grammar.&amp;quot; In: Proceedings, 28th Annual
Meeting of the Association for Computational
Linguistics. 165-172.
Briscoe, T.; Copestake, A.; and de Paiva V.,
eds. (1991). Proceedings of the ACQUILEX
Workshop on Default Inheritance in the
Lexicon. Technical Report No. 238,
Cambridge University Computer
Laboratory.
Calder, J. (1989). &amp;quot;Paradigmatic
morphology.&amp;quot; In Proceedings, Fourth
Conference of the European Chapter of the
Association for Computational Linguistics.
58-65.
Carpenter, B. (1991). &amp;quot;Skeptical and
credulous default unification with
applications to templates and
inheritance.&amp;quot; In Proceedings, ACQUILEX
Workshop on Default Inheritance in the
Lexicon, edited by T. Briscoe,
A. Copestake, and V. de Paiva. Technical
Report No. 238, Cambridge University
Computer Laboratory.
Daelemans, W. (1990). &amp;quot;Inheritance in
object-oriented natural language
processing.&amp;quot; In Proceedings of the Workshop
on Inheritance and Natural Language
Processing, edited by W. Daelemans and
G. Gazdar, 30-38. Tilburg University.
Daelemans, W., and Gazdar, G., eds. (1990).
Proceedings of the Workshop on Inheritance in
Natural Language Processing. ITK, Tilburg
University.
De Smedt, K. (1984). &amp;quot;Using object-oriented
knowledge-representation techniques in
morphology and syntax programming.&amp;quot;
In Proceedings, 3rd European Conference on
Artificial Intelligence (ECAI84). 181-184.
De Smedt, K. and de Graaf, J. (1990).
&amp;quot;Structured inheritance in frame-based
representation of linguistic categories.&amp;quot; In
Proceedings of the Workshop on Inheritance
and Natural Language Processing, edited by
W. Daelemans and G. Gazdar, 39-47.
Tilburg University.
Estival, D. (1990). ELU User Manual.
Technical Report 1, ISSCO, Geneva.
Evans, R., and Gazdar, G., eds. (1990). The
DATR Papers: February 1990. Cognitive
Science Research Paper CSRP 139, School
of Cognitive and Computing Sciences,
University of Sussex, Falmer.
Flickinger, D. P. (1987). Lexical rules in the
hierarchical lexicon. Doctoral dissertation,
Stanford University, Palo Alto, CA.
Flickinger, D. P.; Pollard, C.; and Wasow, T.
(1985). &amp;quot;Structure-sharing in lexical
representation.&amp;quot; In Proceedings, 23rd
Annual Meeting of the Association for
Computational Linguistics. 262-267.
Gazdar, G. (1990). &amp;quot;An introduction to
</reference>
<page confidence="0.997224">
336
</page>
<note confidence="0.957215">
Graham Russell et al. A Practical Approach to Multiple Default Inheritance
</note>
<reference confidence="0.99912438372093">
DATR.&amp;quot; In The DATR Papers: February
1990, edited by R. Evans and G. Gazdar,
1-14, Cognitive Science Research Paper
CSRP 139, University of Sussex.
Johnson, R., and Rosner, M. (1989). &amp;quot;A rich
environment for experimentation with
unification grammars.&amp;quot; In Proceedings,
Fourth Conference of the European Chapter of
the Association for Computational Linguistics.
182-189.
Kaplan, R. M. (1987). &amp;quot;Three Seductions of
Computational Psycholinguistics.&amp;quot; In
Linguistic Theory and Computer Applications,
edited by P. Whitelock, M. M. Wood,
H. L. Somers, R. Johnson, and P. Bennett,
149-188. Academic Press.
Karttunen, L. (1984). &amp;quot;Features and values.&amp;quot;
In Proceedings, 10th International Conference
on Computational Linguistics and the 22nd
Annual Meeting of the Association for
Computational Linguistics. 28-33.
Karttunen, L. (1986). &amp;quot;D-PATR: A
development environment for
unification-based grammars.&amp;quot; In
Proceedings, 11th International Conference on
Computational Linguistics. 74-80.
Kasper, R. T., and Rounds, W. C. (1986). &amp;quot;A
logical semantics for feature structures.&amp;quot;
In Proceedings, 24th Annual Meeting of the
Association for Computational Linguistics.
257-266.
Keene, S. (1989). Object-Oriented
Programming in Common Lisp.
Addison-Wesley.
Kilbury, J.; Naerger, P.; and Renz, I., (1991).
&amp;quot;DATR as a lexical component for PAIR.&amp;quot;
In Proceedings, Fifth Conference of the
European Chapter of the Association for
Computational Linguistics. 137-142.
Padgham, L. (1988). &amp;quot;A model and
representation for type information and
its use in reasoning with defaults.&amp;quot; In
Proceedings, Seventh National Conference on
Artificial Intelligence. 409-414.
Rosenberg, S. (1983). &amp;quot;HPRL: A language
for building expert systems.&amp;quot; In
Proceedings, Eighth International Joint
Conference on Artificial Intelligence, 215-217.
Russell, G.; Carroll, J.; and Warwick, S.
(1990). &amp;quot;Multiple default inheritance in a
unification-based lexicon.&amp;quot; In Proceedings
of the Workshop on Inheritance and Natural
Language Processing, edited by
W. Daelemans and G. Gazdar. 93-102.
Tilburg University.
Sandewall, E. (1986). &amp;quot;Nonmonotonic
inference rules for multiple inheritance
with exceptions.&amp;quot; In Proceedings, IEEE 74.
1345-1353.
Schmolze, J. G., and Lipkis, T. A. (1983).
&amp;quot;Classification in the KL-ONE knowledge
representation system.&amp;quot; In Proceedings,
Eighth International Joint Conference on
Artificial Intelligence. 330-332.
Selman, B., and Levesque, H. J. (1989). &amp;quot;The
tractability of path-based inheritance.&amp;quot; In
Proceedings, 11th International Joint
Conference on Artificial Intelligence.
1140-1145.
Shieber, S. M. (1986a). An Introduction to
Unification-Based Approaches to Grammar.
CSLI.
Shieber, S. M. (1986b). &amp;quot;A simple
reconstruction of GPSG.&amp;quot; In Proceedings,
11th International Conference on
Computational Linguistics. 211-215.
Steele, G. L. (1990). Common Lisp: The
Language, Second Edition. Digital Press.
Touretzky, D. S. (1986). The Mathematics of
Inheritance Systems. Pitman Publishing.
Touretzky, D. S.; Horty, J. E; and Thomason,
R. H. (1987). &amp;quot;A clash of intuitions: The
current state of nonmonotonic multiple
inheritance systems.&amp;quot; In Proceedings, Tenth
International Joint Conference on Artificial
Intelligence. 476-482.
</reference>
<page confidence="0.998457">
337
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.089463">
<title confidence="0.999185">A Practical Approach to Multiple Default Inheritance for Unification-Based Lexicons</title>
<author confidence="0.994348">Graham Russell</author>
<email confidence="0.612578">ISSCO</email>
<author confidence="0.874912">John CarrolP</author>
<affiliation confidence="0.9970605">Cambridge University Computer Laboratory</affiliation>
<title confidence="0.4544055">Afzal Ballim* ISSCO</title>
<author confidence="0.965497">Susan Warwick-Armstrong</author>
<abstract confidence="0.929988428571429">ISSCO This paper describes a unification-based lexicon system for NLP applications that incorporates mechanisms for multiple default inheritance. Such systems are intractable in the general case— the approach adopted here places a number of restrictions on the inheritance hierarchy in order to remove some of the sources of complexity while retaining more desirable properties. Implications of the design choices are discussed, comparisons are drawn with related work in computational linguistics and Al, and illustrative examples from the lexicons of German and English are given.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>A Ballim</author>
<author>Candelaria de Ram</author>
<author>S</author>
<author>D Fass</author>
</authors>
<title>Reasoning using inheritance from a mixture of knowledge and beliefs.&amp;quot; In Knowledge Based Computer Systems:</title>
<date>1990</date>
<booktitle>Proceedings of KBCS &apos;89 (Lecture Notes in Artificial Intelligence no. 444),</booktitle>
<pages>387--396</pages>
<publisher>Springer-Verlag.</publisher>
<note>edited by</note>
<marker>Ballim, de Ram, S, Fass, 1990</marker>
<rawString>Ballim, A.; Candelaria de Ram, S.; and Fass, D. (1990). &amp;quot;Reasoning using inheritance from a mixture of knowledge and beliefs.&amp;quot; In Knowledge Based Computer Systems: Proceedings of KBCS &apos;89 (Lecture Notes in Artificial Intelligence no. 444), edited by S. Ramani, R. Chandrasekar, and K. S. R. Anjaneyulu, 387-396. Springer-Verlag.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Ballim</author>
<author>D Fass</author>
<author>Candelaria de Ram</author>
<author>S</author>
</authors>
<title>Resolving a clash of intuitions: Utilizing strict and defeasible information in an inheritance system.&amp;quot;</title>
<date>1988</date>
<journal>CRL Memoranda</journal>
<pages>88--119</pages>
<institution>Computing Research Laboratory, New Mexico State University.</institution>
<marker>Ballim, Fass, de Ram, S, 1988</marker>
<rawString>Ballim, A.; Fass, D.; and Candelaria de Ram, S. (1988). &amp;quot;Resolving a clash of intuitions: Utilizing strict and defeasible information in an inheritance system.&amp;quot; CRL Memoranda MCCS-88-119, Computing Research Laboratory, New Mexico State University.</rawString>
</citation>
<citation valid="true">
<authors>
<author>G Bouma</author>
</authors>
<title>Defaults in unification grammar.&amp;quot; In:</title>
<date>1990</date>
<booktitle>Proceedings, 28th Annual Meeting of the Association for Computational Linguistics.</booktitle>
<pages>165--172</pages>
<contexts>
<context position="45652" citStr="Bouma (1990)" startWordPosition="7599" endWordPosition="7600">e to the lexicon, and indeed to linguistic descriptions in general, is not a new one. Here we consider a few of the proposals that have appeared in recent years. 15 Classes with one or no variant set yield at most a singleton superclass extension for each FS they apply to, while others multiply a FS by a factor of no more than their total number of variant sets. 325 Computational Linguistics Volume 18, Number 3 4.1 Defaults and Reentrancy The notion of &apos;default extension&apos; employed here resembles the &apos;priority union&apos; of Kaplan (1987: 180f) and the &apos;conservative addition&apos; of Shieber (1986b). As Bouma (1990) points out, the result of defaulting under this approach may depend on order of application. To take Bouma&apos;s (p. 166) simple example, default unification of the FSs (1) [ F a] (2) [a b with a re-entrant structure o[i produces different, nonunifying, results: [Fa] (5) F 1:0]b] (4) G [G (4) results when (1) applies before (2), and (5) when (2) applies before (1). Similarly, defaulting the FSs (6) F 131 (7) [G 13] G onto a FS (8) [ F a] produces one of [F W al (9) (10) IF al G Lab] according to whether (6) applies before (7), in which case the result is (9), or (7) applies before (6), to produce</context>
</contexts>
<marker>Bouma, 1990</marker>
<rawString>Bouma, G. (1990). &amp;quot;Defaults in unification grammar.&amp;quot; In: Proceedings, 28th Annual Meeting of the Association for Computational Linguistics. 165-172.</rawString>
</citation>
<citation valid="true">
<authors>
<author>T Briscoe</author>
<author>A Copestake</author>
<author>V de Paiva</author>
<author>eds</author>
</authors>
<date>1991</date>
<booktitle>Proceedings of the ACQUILEX Workshop on Default Inheritance in the Lexicon.</booktitle>
<tech>Technical Report No. 238,</tech>
<institution>Cambridge University Computer Laboratory.</institution>
<marker>Briscoe, Copestake, de Paiva, eds, 1991</marker>
<rawString>Briscoe, T.; Copestake, A.; and de Paiva V., eds. (1991). Proceedings of the ACQUILEX Workshop on Default Inheritance in the Lexicon. Technical Report No. 238, Cambridge University Computer Laboratory.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Calder</author>
</authors>
<title>Paradigmatic morphology.&amp;quot; In</title>
<date>1989</date>
<booktitle>Proceedings, Fourth Conference of the European Chapter of the Association for Computational Linguistics.</booktitle>
<pages>58--65</pages>
<contexts>
<context position="44766" citStr="Calder (1989)" startWordPosition="7450" endWordPosition="7451">nwanted intermediate solutions, computing the global extension of a lexical class will in general involve creation of a larger number of FSs than appear in the result. If v(c) is the number of variant sets in the class c, and f is the function in the natural numbers such that f (0) = 1 and f (k) = k if k&gt; 0,15 the maximum number of FSs constructed for a lexical class with the CPL cn) is given by This maximum arises when no failures of strict unification occur. Finally, while the variant set mechanism provides some of the functionality of the lexical rules proposed by Flickinger et al. (1985), Calder (1989), and others, the structure of the EL U lexicon does not admit the full range of capabilities of these more powerful devices; cyclic rule applications cannot be simulated, for example. 4. Some Comparisons As we mentioned briefly in Section 1, the idea of applying inheritance to the lexicon, and indeed to linguistic descriptions in general, is not a new one. Here we consider a few of the proposals that have appeared in recent years. 15 Classes with one or no variant set yield at most a singleton superclass extension for each FS they apply to, while others multiply a FS by a factor of no more th</context>
<context position="60139" citStr="Calder (1989)" startWordPosition="9922" endWordPosition="9923">, corresponding to the four combinations of &lt;morph&gt; and &lt;form&gt; values admitted by the fragment. Finite and nonfinite past forms are both associated via the values of &lt;p_fin_form&gt; and &lt;psp_form&gt; with the string walked, the third person singular present tense variant is assigned the string walks, and the word form representing the other present tense variants is walk. Irregular verbs differ in having the two past forms specified in their lexical class. The defeasible constraints providing values for &lt;psp_form&gt; and &lt;p_fin_form&gt; in Verb 19 Blocking is a consequence of the architecture proposed by Calder (1989) and of the DATR language. 20 The analysis sketched here is simplified in the sense that several variants within the Verb class have been omitted, all inflectional information is embodied as the value of the single feature &lt;morph&gt;, and no account is given of the various spelling alternations that accompany suffixation. 330 Graham Russell et al. A.Practical Approach to Multiple Default Inheritance are overridden by this more specific information, so that while sink behaves like regular verbs in its present tense, the values of &lt;form&gt; for the past finite and past nonfinite variants are sank and </context>
</contexts>
<marker>Calder, 1989</marker>
<rawString>Calder, J. (1989). &amp;quot;Paradigmatic morphology.&amp;quot; In Proceedings, Fourth Conference of the European Chapter of the Association for Computational Linguistics. 58-65.</rawString>
</citation>
<citation valid="true">
<authors>
<author>B Carpenter</author>
</authors>
<title>Skeptical and credulous default unification with applications to templates and inheritance.&amp;quot;</title>
<date>1991</date>
<booktitle>In Proceedings, ACQUILEX Workshop on Default Inheritance in the Lexicon, edited</booktitle>
<contexts>
<context position="39387" citStr="Carpenter (1991)" startWordPosition="6551" endWordPosition="6552"> E M&apos;, 01 is the default extension of 0 with respect to M&apos;, and v; is the feature structure described by v,. S(0, C) is formed by applying to 0 any default equations in the main set of C, and then applying to the result each variant set in C; for variant sets 01, ... vi,, the result of this second stage is the set of FSs { where each &apos;01 is the result of successfully unifying 0 with some different v1. 12 Here, &apos;OW denotes the value of the attribute-value path p in the FS 0, and denotes token identity of its operands. 13 See Section 4.1 for a different approach to order sensitivity proposed by Carpenter (1991). 323 Computational Linguistics Volume 18, Number 3 3.2.3 Global Extension. The global extension of a lexical class L having the CPL C = (c1, . . c,,) is Gn, where Go --- {I}, and Gi&gt;0 I Vcb E G1_1, tif --= S(0, ci)} To speak in procedural terms, 1 is the empty FS that is input to C; each c, in C yields as its superclass extension a set of FSs, each member of which is input to the remainder of C, (c,+1, ca). The global extension of L is then the yield of the most general class in its CPL—expressed in a slightly different way, the global extension of L is the result of applying to 1 the CPL of </context>
<context position="46867" citStr="Carpenter (1991)" startWordPosition="7815" endWordPosition="7816">e (10). Both situations are avoided in the au system by making applicability of defaults conditional on the unifiability of reentrant subsets of the default information and candidate structure (see Section 3). The first case, where the candidate FS (3) contains a reentrancy that has nonunifying extensions in the default information (1 and 2), is excluded by the requirement that R(3) LI 11{1,2} T, and the second case, where a reentrancy in a default FS (6) has nonunifying extensions in the candidate FS (8) and other default FSs (7), is excluded by the requirement that (8) LJ R(11{(6), (7)1) T. Carpenter (1991) proposes a more permissive view of default unification in which conflicts of this type are resolved in one of two modes, &apos;credulous&apos; and &apos;skeptical.&apos; Credulous default unification preserves the maximum possible default information, and is defined so as to produce a (nonempty) set of solutions. For example, the result of credulously defaulting (11) (the unification of 6 and 7 above) onto (8) is the set of solutions (12) (i.e., 9 and 10). {F Wbl (12) [F Wa Fa (11) G m [G bll La j Skeptical default unification retains only consistent information, and is defined as the generalization of such a se</context>
</contexts>
<marker>Carpenter, 1991</marker>
<rawString>Carpenter, B. (1991). &amp;quot;Skeptical and credulous default unification with applications to templates and inheritance.&amp;quot; In Proceedings, ACQUILEX Workshop on Default Inheritance in the Lexicon, edited by T. Briscoe,</rawString>
</citation>
<citation valid="false">
<authors>
<author>A Copestake</author>
<author>V de Paiva</author>
</authors>
<tech>Technical Report No. 238,</tech>
<institution>Cambridge University Computer Laboratory.</institution>
<marker>Copestake, de Paiva, </marker>
<rawString>A. Copestake, and V. de Paiva. Technical Report No. 238, Cambridge University Computer Laboratory.</rawString>
</citation>
<citation valid="true">
<authors>
<author>W Daelemans</author>
</authors>
<title>Inheritance in object-oriented natural language processing.&amp;quot;</title>
<date>1990</date>
<booktitle>In Proceedings of the Workshop on Inheritance and Natural Language Processing, edited by W. Daelemans</booktitle>
<pages>30--38</pages>
<institution>Tilburg University.</institution>
<contexts>
<context position="51855" citStr="Daelemans 1990" startWordPosition="8595" endWordPosition="8596">e of destructively modifying F, by removing or replacing some of its content, the consequence is that F subsumes its default extension with respect to any set of constraints; moreover, since the other operations involved in determining superclass extension employ only conventional &apos;strict&apos; unification, these are equally unable to introduce into the system any element of nonmonotonicity. 4.3 Other Issues Inheritance hierarchies are frequently employed in object-oriented programming languages and environments. Some work in computational linguistics has been explicitly object-oriented in nature (Daelemans 1990; De Smedt 1984; De Smedt and de Graaf 1990) but, as Gazdar (1990) observes, this has tended to adapt existing general-purpose techniques and languages, rather than attempt to devise specialized linguistic formalisms. Daelemans (1990) suggests that inheritance can replace unification as a basic mechanism for linguistic description, but his proposals remain relatively undeveloped. In some ways, the use of typed FSs and other data structures in au represents a step toward a rapprochement of unification and object-oriented techniques. However, object-oriented programming involves much more than t</context>
</contexts>
<marker>Daelemans, 1990</marker>
<rawString>Daelemans, W. (1990). &amp;quot;Inheritance in object-oriented natural language processing.&amp;quot; In Proceedings of the Workshop on Inheritance and Natural Language Processing, edited by W. Daelemans and G. Gazdar, 30-38. Tilburg University.</rawString>
</citation>
<citation valid="true">
<authors>
<author>W Daelemans</author>
<author>G Gazdar</author>
<author>eds</author>
</authors>
<date>1990</date>
<booktitle>Proceedings of the Workshop on Inheritance in Natural Language Processing. ITK,</booktitle>
<institution>Tilburg University.</institution>
<marker>Daelemans, Gazdar, eds, 1990</marker>
<rawString>Daelemans, W., and Gazdar, G., eds. (1990). Proceedings of the Workshop on Inheritance in Natural Language Processing. ITK, Tilburg University.</rawString>
</citation>
<citation valid="true">
<authors>
<author>K De Smedt</author>
</authors>
<title>Using object-oriented knowledge-representation techniques in morphology and syntax programming.&amp;quot;</title>
<date>1984</date>
<booktitle>In Proceedings, 3rd European Conference on Artificial Intelligence (ECAI84).</booktitle>
<pages>181--184</pages>
<marker>De Smedt, 1984</marker>
<rawString>De Smedt, K. (1984). &amp;quot;Using object-oriented knowledge-representation techniques in morphology and syntax programming.&amp;quot; In Proceedings, 3rd European Conference on Artificial Intelligence (ECAI84). 181-184.</rawString>
</citation>
<citation valid="true">
<authors>
<author>K De Smedt</author>
<author>J de Graaf</author>
</authors>
<title>Structured inheritance in frame-based representation of linguistic categories.&amp;quot;</title>
<date>1990</date>
<booktitle>In Proceedings of the Workshop on Inheritance and Natural Language Processing, edited by W. Daelemans</booktitle>
<pages>39--47</pages>
<institution>Tilburg University.</institution>
<marker>De Smedt, de Graaf, 1990</marker>
<rawString>De Smedt, K. and de Graaf, J. (1990). &amp;quot;Structured inheritance in frame-based representation of linguistic categories.&amp;quot; In Proceedings of the Workshop on Inheritance and Natural Language Processing, edited by W. Daelemans and G. Gazdar, 39-47. Tilburg University.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D Estival</author>
</authors>
<title>ELU User Manual.</title>
<date>1990</date>
<tech>Technical Report 1, ISSCO, Geneva.</tech>
<contexts>
<context position="6561" citStr="Estival 1990" startWordPosition="993" endWordPosition="994">Finally, in Section 6, the current implementation is discussed. 2. The Lexicon as a Hierarchy 2.1 An Overview of the Formalism An au lexicon consists of a number of &apos;classes,&apos; each of which is a structured collection of constraint equations encoding information common to a set of words, together with links to other more general &apos;superclasses.&apos; For example, if an &apos;intransitive&apos; class is used to express the common syntactic properties shared by all intransitive verbs, then particular instances of intransitive verbs can be made to inherit this informa2 &amp;quot;Environnement Linguistique d&apos;Unification&amp;quot; (Estival 1990). See also Johnson and Rosner (1989) for a description of the earlier UD system on which ELu is based. 312 Graham Russell et al. A Practical Approach to Multiple Default Inheritance tion by specifying the &apos;intransitive&apos; class as one of their superclasses—it then becomes unnecessary to specify the relevant properties individually for each such verb. Similarly, the &apos;intransitive&apos; class need not express any of the more general properties of the &apos;verb&apos; class. The lexicon may be thought of as a tangled hierarchy of classes linked by inheritance paths, with, at the most specific level, lexical class</context>
</contexts>
<marker>Estival, 1990</marker>
<rawString>Estival, D. (1990). ELU User Manual. Technical Report 1, ISSCO, Geneva.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Evans</author>
<author>G Gazdar</author>
<author>eds</author>
</authors>
<date>1990</date>
<booktitle>The DATR Papers: February 1990. Cognitive Science Research Paper CSRP 139, School of Cognitive and Computing Sciences,</booktitle>
<institution>University of Sussex, Falmer.</institution>
<marker>Evans, Gazdar, eds, 1990</marker>
<rawString>Evans, R., and Gazdar, G., eds. (1990). The DATR Papers: February 1990. Cognitive Science Research Paper CSRP 139, School of Cognitive and Computing Sciences, University of Sussex, Falmer.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D P Flickinger</author>
</authors>
<title>Lexical rules in the hierarchical lexicon. Doctoral dissertation,</title>
<date>1987</date>
<institution>Stanford University,</institution>
<location>Palo Alto, CA.</location>
<contexts>
<context position="55002" citStr="Flickinger (1987" startWordPosition="9110" endWordPosition="9111">h a slot is filled by information from the most specific accessible node in the hierarchy, and &apos;complete,&apos; by which multiple values for a slot are obtained from a number of more general frames. Values for the FEATURES slot for the word has thus include (AUX PLUS) inherited from AUXILIARY, (AGREEMENT 3RD-SING) from THIRD-SING, and (CONTROL SSR) from SUBJECT-RAISE. The values in this example are compatible; the question of contradictions in complete-mode inheritance is raised, but it is not stated whether any that do occur are resolved, produce inconsistent results, or cause the search to fail. Flickinger (1987: 60) refers to constraining the hierarchy &amp;quot;in such a way that each single-valued attribute of some given class or member [is] assigned a value by at most one of the immediate superclasses, or its parents, so conflicting values [cannot] occur,&amp;quot; but does not indicate whether this constraint is to be imposed automatically as part of a compilation or consistency checking process, or is simply to take the form of advice to users. He considers as an alternative a rule of inheritance &amp;quot;which for each attribute assigns priority to some one of the parent classes,&amp;quot; and a convention similar to that of th</context>
</contexts>
<marker>Flickinger, 1987</marker>
<rawString>Flickinger, D. P. (1987). Lexical rules in the hierarchical lexicon. Doctoral dissertation, Stanford University, Palo Alto, CA.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D P Flickinger</author>
<author>C Pollard</author>
<author>T Wasow</author>
</authors>
<title>Structure-sharing in lexical representation.&amp;quot;</title>
<date>1985</date>
<booktitle>In Proceedings, 23rd Annual Meeting of the Association for Computational Linguistics.</booktitle>
<pages>262--267</pages>
<contexts>
<context position="44751" citStr="Flickinger et al. (1985)" startWordPosition="7446" endWordPosition="7449">s are able to filter out unwanted intermediate solutions, computing the global extension of a lexical class will in general involve creation of a larger number of FSs than appear in the result. If v(c) is the number of variant sets in the class c, and f is the function in the natural numbers such that f (0) = 1 and f (k) = k if k&gt; 0,15 the maximum number of FSs constructed for a lexical class with the CPL cn) is given by This maximum arises when no failures of strict unification occur. Finally, while the variant set mechanism provides some of the functionality of the lexical rules proposed by Flickinger et al. (1985), Calder (1989), and others, the structure of the EL U lexicon does not admit the full range of capabilities of these more powerful devices; cyclic rule applications cannot be simulated, for example. 4. Some Comparisons As we mentioned briefly in Section 1, the idea of applying inheritance to the lexicon, and indeed to linguistic descriptions in general, is not a new one. Here we consider a few of the proposals that have appeared in recent years. 15 Classes with one or no variant set yield at most a singleton superclass extension for each FS they apply to, while others multiply a FS by a facto</context>
<context position="54015" citStr="Flickinger et al. (1985)" startWordPosition="8952" endWordPosition="8955">tire classes as in Elm. Moreover, the defaulting mechanism of DATR is independent of the inheritance mechanism, and based on path extension; an equation of the form &apos;&lt;al , ai&gt; == v&apos; allows v to be inferred as the value of all paths &lt;a1,.ak&gt;, 1 &lt;i &lt; k, such that no initial subpath &lt;al, ... aj&gt;, i &lt;j &lt; k, has explicitly been assigned a different value. As a consequence, the objects manipulated by DATR are strictly linear, in contrast to the more general feature structures that form the basis of the au lexicon18—in practice, path-value equations in DATR tend to correspond to variant sets in ELu. Flickinger et al. (1985) present a model of the lexicon based on multiple default inheritance in the frame language HPRL (Rosenberg 1983). Two inheritance modes 18 This is not to say that the two are not interconvertible—see Kilbury et al. (1991). 328 Graham Russell et al. A Practical Approach to Multiple Default Inheritance exist: &apos;normal,&apos; a conventional shortest-path default method in which a slot is filled by information from the most specific accessible node in the hierarchy, and &apos;complete,&apos; by which multiple values for a slot are obtained from a number of more general frames. Values for the FEATURES slot for th</context>
</contexts>
<marker>Flickinger, Pollard, Wasow, 1985</marker>
<rawString>Flickinger, D. P.; Pollard, C.; and Wasow, T. (1985). &amp;quot;Structure-sharing in lexical representation.&amp;quot; In Proceedings, 23rd Annual Meeting of the Association for Computational Linguistics. 262-267.</rawString>
</citation>
<citation valid="true">
<authors>
<author>G Gazdar</author>
</authors>
<title>An introduction to DATR.&amp;quot;</title>
<date>1990</date>
<booktitle>In The DATR Papers:</booktitle>
<pages>1--14</pages>
<institution>University of Sussex.</institution>
<note>edited by</note>
<contexts>
<context position="2648" citStr="Gazdar 1990" startWordPosition="393" endWordPosition="394">possibility of mitigating these problems by adopting a principled compromise; it may be advantageous to surrender some of the generality of an inheritance system, if the more restricted version that results retains sufficient expressive power for the domain in question. We expand on this below and propose a number of simplifications that are motivated by the particular task that the system is intended to perform. * ISSCO, 54 route des Acacias, 1227 Geneva, Switzerland. t Cambridge University Computer Laboratory, New Museums Site, Pembroke Street, Cambridge CI32 3QG, UK. I See, e.g., Evans and Gazdar 1990, Gazdar 1990 (especially the References), much of the material in Daelemans and Gazdar 1990, and the contributions to Briscoe et al. 1991. We discuss some of this work below. C) 1992 Association for Computational Linguistics Computational Linguistics Volume 18, Number 3 The system described here has been implemented as part of the au&apos; unification grammar development environment for research in machine translation, made up of parser, generator, lexicon, and transfer mechanism. The user language resembles that of PATR-II (Shieber 1986a), but provides a larger range of data types and more powerf</context>
<context position="51921" citStr="Gazdar (1990)" startWordPosition="8608" endWordPosition="8609">s content, the consequence is that F subsumes its default extension with respect to any set of constraints; moreover, since the other operations involved in determining superclass extension employ only conventional &apos;strict&apos; unification, these are equally unable to introduce into the system any element of nonmonotonicity. 4.3 Other Issues Inheritance hierarchies are frequently employed in object-oriented programming languages and environments. Some work in computational linguistics has been explicitly object-oriented in nature (Daelemans 1990; De Smedt 1984; De Smedt and de Graaf 1990) but, as Gazdar (1990) observes, this has tended to adapt existing general-purpose techniques and languages, rather than attempt to devise specialized linguistic formalisms. Daelemans (1990) suggests that inheritance can replace unification as a basic mechanism for linguistic description, but his proposals remain relatively undeveloped. In some ways, the use of typed FSs and other data structures in au represents a step toward a rapprochement of unification and object-oriented techniques. However, object-oriented programming involves much more than the use of inheritance, and the lack of mechanisms in ELu implement</context>
</contexts>
<marker>Gazdar, 1990</marker>
<rawString>Gazdar, G. (1990). &amp;quot;An introduction to DATR.&amp;quot; In The DATR Papers: February 1990, edited by R. Evans and G. Gazdar, 1-14, Cognitive Science Research Paper CSRP 139, University of Sussex.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Johnson</author>
<author>M Rosner</author>
</authors>
<title>A rich environment for experimentation with unification grammars.&amp;quot;</title>
<date>1989</date>
<booktitle>In Proceedings, Fourth Conference of the European Chapter of the Association for Computational Linguistics.</booktitle>
<pages>182--189</pages>
<contexts>
<context position="6597" citStr="Johnson and Rosner (1989)" startWordPosition="997" endWordPosition="1000">he current implementation is discussed. 2. The Lexicon as a Hierarchy 2.1 An Overview of the Formalism An au lexicon consists of a number of &apos;classes,&apos; each of which is a structured collection of constraint equations encoding information common to a set of words, together with links to other more general &apos;superclasses.&apos; For example, if an &apos;intransitive&apos; class is used to express the common syntactic properties shared by all intransitive verbs, then particular instances of intransitive verbs can be made to inherit this informa2 &amp;quot;Environnement Linguistique d&apos;Unification&amp;quot; (Estival 1990). See also Johnson and Rosner (1989) for a description of the earlier UD system on which ELu is based. 312 Graham Russell et al. A Practical Approach to Multiple Default Inheritance tion by specifying the &apos;intransitive&apos; class as one of their superclasses—it then becomes unnecessary to specify the relevant properties individually for each such verb. Similarly, the &apos;intransitive&apos; class need not express any of the more general properties of the &apos;verb&apos; class. The lexicon may be thought of as a tangled hierarchy of classes linked by inheritance paths, with, at the most specific level, lexical classes and, at the most general, classes</context>
</contexts>
<marker>Johnson, Rosner, 1989</marker>
<rawString>Johnson, R., and Rosner, M. (1989). &amp;quot;A rich environment for experimentation with unification grammars.&amp;quot; In Proceedings, Fourth Conference of the European Chapter of the Association for Computational Linguistics. 182-189.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R M Kaplan</author>
</authors>
<title>Three Seductions of Computational Psycholinguistics.&amp;quot; In Linguistic Theory and Computer Applications, edited by</title>
<date>1987</date>
<pages>149--188</pages>
<publisher>Academic Press.</publisher>
<contexts>
<context position="45577" citStr="Kaplan (1987" startWordPosition="7588" endWordPosition="7589">isons As we mentioned briefly in Section 1, the idea of applying inheritance to the lexicon, and indeed to linguistic descriptions in general, is not a new one. Here we consider a few of the proposals that have appeared in recent years. 15 Classes with one or no variant set yield at most a singleton superclass extension for each FS they apply to, while others multiply a FS by a factor of no more than their total number of variant sets. 325 Computational Linguistics Volume 18, Number 3 4.1 Defaults and Reentrancy The notion of &apos;default extension&apos; employed here resembles the &apos;priority union&apos; of Kaplan (1987: 180f) and the &apos;conservative addition&apos; of Shieber (1986b). As Bouma (1990) points out, the result of defaulting under this approach may depend on order of application. To take Bouma&apos;s (p. 166) simple example, default unification of the FSs (1) [ F a] (2) [a b with a re-entrant structure o[i produces different, nonunifying, results: [Fa] (5) F 1:0]b] (4) G [G (4) results when (1) applies before (2), and (5) when (2) applies before (1). Similarly, defaulting the FSs (6) F 131 (7) [G 13] G onto a FS (8) [ F a] produces one of [F W al (9) (10) IF al G Lab] according to whether (6) applies before </context>
</contexts>
<marker>Kaplan, 1987</marker>
<rawString>Kaplan, R. M. (1987). &amp;quot;Three Seductions of Computational Psycholinguistics.&amp;quot; In Linguistic Theory and Computer Applications, edited by P. Whitelock, M. M. Wood, H. L. Somers, R. Johnson, and P. Bennett, 149-188. Academic Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>L Karttunen</author>
</authors>
<title>Features and values.&amp;quot;</title>
<date>1984</date>
<booktitle>In Proceedings, 10th International Conference on Computational Linguistics and the 22nd Annual Meeting of the Association for Computational Linguistics.</booktitle>
<pages>28--33</pages>
<contexts>
<context position="47653" citStr="Karttunen (1984)" startWordPosition="7944" endWordPosition="7945">nification preserves the maximum possible default information, and is defined so as to produce a (nonempty) set of solutions. For example, the result of credulously defaulting (11) (the unification of 6 and 7 above) onto (8) is the set of solutions (12) (i.e., 9 and 10). {F Wbl (12) [F Wa Fa (11) G m [G bll La j Skeptical default unification retains only consistent information, and is defined as the generalization of such a set of solutions.&apos; Skeptically defaulting (11) onto (8) produces 16 The generalization of two FSs corresponds to their greatest lower bound in the subsumption lattice. See Karttunen (1984). 326 Graham Russell et al. A Practical Approach to Multiple Default Inheritance the FS (13), in which the only default information to have been preserved is that concerning the presence of an attribute G, whose value, since it conflicts with that in (8), is unspecified: [ (13) F a G _L Neither of these proposals for the treatment of inconsistent default information is equivalent to ours. Of the various properties of skeptical and credulous default unification noted by Carpenter, the au lexicon shares the following. (i) Strict information is preserved—i.e., default unification is monotonic (se</context>
</contexts>
<marker>Karttunen, 1984</marker>
<rawString>Karttunen, L. (1984). &amp;quot;Features and values.&amp;quot; In Proceedings, 10th International Conference on Computational Linguistics and the 22nd Annual Meeting of the Association for Computational Linguistics. 28-33.</rawString>
</citation>
<citation valid="true">
<authors>
<author>L Karttunen</author>
</authors>
<title>D-PATR: A development environment for unification-based grammars.&amp;quot;</title>
<date>1986</date>
<booktitle>In Proceedings, 11th International Conference on Computational Linguistics.</booktitle>
<pages>74--80</pages>
<contexts>
<context position="49907" citStr="Karttunen (1986)" startWordPosition="8293" endWordPosition="8294"> terms of a noncommutative &apos;overwriting&apos; operation, in which constraint equations may be formulated so as to take precedence over existing structures. These devices permit the construction of heterogeneous systems like that of au; one difference between the two would be that, in Shieber&apos;s scheme, the statements exhibiting default behavior are ones that have the ability to override others over which they have precedence, whereas in the approach described above the default statements are ones that can be overridden by others that have precedence over them. In the D-PATR environment presented by Karttunen (1986), all templates engage in defaulting: &amp;quot;... templates and other specifications that occur [in lexical entries] are processed sequentially from left to right. Each item is compiled to a directed graph and superimposed on the graph previously compiled&amp;quot; (p. 76). Here, then, defaulting occurs as standard; any sequence of statements in a lexical entry may be such that a later statement conceals the effect of an earlier one. Again, the fact that defaulting is interpreted as the overwriting of one structure by another means that structures may be modified in a nonmonotonic fashion. The implementation </context>
</contexts>
<marker>Karttunen, 1986</marker>
<rawString>Karttunen, L. (1986). &amp;quot;D-PATR: A development environment for unification-based grammars.&amp;quot; In Proceedings, 11th International Conference on Computational Linguistics. 74-80.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R T Kasper</author>
<author>W C Rounds</author>
</authors>
<title>A logical semantics for feature structures.&amp;quot;</title>
<date>1986</date>
<booktitle>In Proceedings, 24th Annual Meeting of the Association for Computational Linguistics.</booktitle>
<pages>257--266</pages>
<contexts>
<context position="40274" citStr="Kasper and Rounds (1986)" startWordPosition="6718" endWordPosition="6721">S that is input to C; each c, in C yields as its superclass extension a set of FSs, each member of which is input to the remainder of C, (c,+1, ca). The global extension of L is then the yield of the most general class in its CPL—expressed in a slightly different way, the global extension of L is the result of applying to 1 the CPL of L.&apos; The set of lexical items admitted by a lexicon consists of the union of the global extensions of all lexical classes in the lexicon. 3.3 Variant Sets—Discussion Variant sets may be thought of as representing a restricted form of disjunction over complex FSs. Kasper and Rounds (1986) show general disjunctive unification to be intractable, since it involves an exponentially complex step of expansion to disjunctive normal form. Note, however, that the alternation embodied in variant sets is guaranteed to be at the &apos;top level&apos; of FSs only; that is to say, the FSs described by multiple variant sets are already in disjunctive normal form, apart from any atomic disjunctions they may contain. For this reason, multiple variant sets impose no mutual constraints; regardless of whether the information they contain is orthogonal, complementary, or conflicting, the crucial factor is t</context>
</contexts>
<marker>Kasper, Rounds, 1986</marker>
<rawString>Kasper, R. T., and Rounds, W. C. (1986). &amp;quot;A logical semantics for feature structures.&amp;quot; In Proceedings, 24th Annual Meeting of the Association for Computational Linguistics. 257-266.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S Keene</author>
</authors>
<date>1989</date>
<booktitle>Object-Oriented Programming in Common Lisp.</booktitle>
<publisher>Addison-Wesley.</publisher>
<contexts>
<context position="28514" citStr="Keene (1989" startWordPosition="4573" endWordPosition="4574">he next leftmost path before continuing with depth-first computation. The CPL of A in Figure 2 is therefore (A,B,C,D,E,F), with A being the most specific and F the most general.&apos; This procedure deterministically selects one total ordering from the set of orderings compatible with the superclass declarations; if none can be derived, the system gives an error during compilation. A given CPL can be derived from several sets of class definitions; the lexicons shown below are some of those which, when compiled, will result in the same CPL 8 See Steele (1990: 782f0 for details of the algorithm, and Keene (1989: 118ff) for discussion. 9 The ordering relation of specificity on classes should not be confused with the subsumption relation on feature structures; the former is determined by superclass declarations and is independent of the information content of any constraints within the classes. Typically, more specific classes describe smaller sets of words. 319 Computational Linguistics Volume 18, Number 3 A Figure 3 An impossible hierarchy. (A,B,C,D,E,F), as the example above: #Word A (B) #Class B (C) #Class C (D) #Class D (E) #Class E (F) #Class F 0 #Word A (B) #Class B (C) #Class C (D) #Class D (E</context>
</contexts>
<marker>Keene, 1989</marker>
<rawString>Keene, S. (1989). Object-Oriented Programming in Common Lisp. Addison-Wesley.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Kilbury</author>
<author>P Naerger</author>
<author>I Renz</author>
</authors>
<title>DATR as a lexical component for PAIR.&amp;quot;</title>
<date>1991</date>
<booktitle>In Proceedings, Fifth Conference of the European Chapter of the Association for Computational Linguistics.</booktitle>
<pages>137--142</pages>
<contexts>
<context position="54237" citStr="Kilbury et al. (1991)" startWordPosition="8989" endWordPosition="8992"> paths &lt;a1,.ak&gt;, 1 &lt;i &lt; k, such that no initial subpath &lt;al, ... aj&gt;, i &lt;j &lt; k, has explicitly been assigned a different value. As a consequence, the objects manipulated by DATR are strictly linear, in contrast to the more general feature structures that form the basis of the au lexicon18—in practice, path-value equations in DATR tend to correspond to variant sets in ELu. Flickinger et al. (1985) present a model of the lexicon based on multiple default inheritance in the frame language HPRL (Rosenberg 1983). Two inheritance modes 18 This is not to say that the two are not interconvertible—see Kilbury et al. (1991). 328 Graham Russell et al. A Practical Approach to Multiple Default Inheritance exist: &apos;normal,&apos; a conventional shortest-path default method in which a slot is filled by information from the most specific accessible node in the hierarchy, and &apos;complete,&apos; by which multiple values for a slot are obtained from a number of more general frames. Values for the FEATURES slot for the word has thus include (AUX PLUS) inherited from AUXILIARY, (AGREEMENT 3RD-SING) from THIRD-SING, and (CONTROL SSR) from SUBJECT-RAISE. The values in this example are compatible; the question of contradictions in complete</context>
<context position="74522" citStr="Kilbury et al. 1991" startWordPosition="12308" endWordPosition="12311">s another type of lexicon based on finite state morphology; lexicons of this type are accessed via the same interface, and one may be loaded and available for use at the same time as an inheritance-based lexicon. One of the characteristics of the au lexicon system that has allowed it to be so well integrated with the other components in the system is that it represents feature structures in exactly the same way that they do. In particular, au does not have to convert from one representation to another at the interface to the lexicon, as does DATR when used within a unification grammar system (Kilbury et al. 1991). 7. Summary The popularity of unification as a tool for computational linguistics stems from its declarative, monotonic semantics; however, the price to be paid for the benefits of a pure unification framework is the lack of a satisfactory treatment of exceptions (negation, defaults, etc.). The popularity of default inheritance as a tool for knowledge representation stems from its ability to encode, in a straightforward manner, the type 22 In theory, the system can deal with lexicons admitting up to around 4,000,000 word forms, but the largest lexicon tested to date contains slightly more tha</context>
</contexts>
<marker>Kilbury, Naerger, Renz, 1991</marker>
<rawString>Kilbury, J.; Naerger, P.; and Renz, I., (1991). &amp;quot;DATR as a lexical component for PAIR.&amp;quot; In Proceedings, Fifth Conference of the European Chapter of the Association for Computational Linguistics. 137-142.</rawString>
</citation>
<citation valid="true">
<authors>
<author>L Padgham</author>
</authors>
<title>A model and representation for type information and its use in reasoning with defaults.&amp;quot;</title>
<date>1988</date>
<booktitle>In Proceedings, Seventh National Conference on Artificial Intelligence.</booktitle>
<pages>409--414</pages>
<contexts>
<context position="55743" citStr="Padgham (1988)" startWordPosition="9236" endWordPosition="9237">assigned a value by at most one of the immediate superclasses, or its parents, so conflicting values [cannot] occur,&amp;quot; but does not indicate whether this constraint is to be imposed automatically as part of a compilation or consistency checking process, or is simply to take the form of advice to users. He considers as an alternative a rule of inheritance &amp;quot;which for each attribute assigns priority to some one of the parent classes,&amp;quot; and a convention similar to that of the au lexicon, whereby precedence of direct superclasses is encoded in the order of elements in a list. The system described by Padgham (1988) resembles the au lexicon in taking the objects in the hierarchy as being sets of properties, partitioned into strict and defeasible subsets: &amp;quot;The type core includes those characteristics which we regard as always present in objects of this type .... The type default contains the information for typical objects of that type.&amp;quot; Padgham&apos;s types may also be partially specified, and thus bear quite a close resemblance to ELU classes with single variant sets. Where this arrangement differs from the ELU lexicon is in permitting inheritance links between types to involve just these substructures; to r</context>
</contexts>
<marker>Padgham, 1988</marker>
<rawString>Padgham, L. (1988). &amp;quot;A model and representation for type information and its use in reasoning with defaults.&amp;quot; In Proceedings, Seventh National Conference on Artificial Intelligence. 409-414.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S Rosenberg</author>
</authors>
<title>HPRL: A language for building expert systems.&amp;quot;</title>
<date>1983</date>
<booktitle>In Proceedings, Eighth International Joint Conference on Artificial Intelligence,</booktitle>
<pages>215--217</pages>
<contexts>
<context position="54128" citStr="Rosenberg 1983" startWordPosition="8972" endWordPosition="8973">on path extension; an equation of the form &apos;&lt;al , ai&gt; == v&apos; allows v to be inferred as the value of all paths &lt;a1,.ak&gt;, 1 &lt;i &lt; k, such that no initial subpath &lt;al, ... aj&gt;, i &lt;j &lt; k, has explicitly been assigned a different value. As a consequence, the objects manipulated by DATR are strictly linear, in contrast to the more general feature structures that form the basis of the au lexicon18—in practice, path-value equations in DATR tend to correspond to variant sets in ELu. Flickinger et al. (1985) present a model of the lexicon based on multiple default inheritance in the frame language HPRL (Rosenberg 1983). Two inheritance modes 18 This is not to say that the two are not interconvertible—see Kilbury et al. (1991). 328 Graham Russell et al. A Practical Approach to Multiple Default Inheritance exist: &apos;normal,&apos; a conventional shortest-path default method in which a slot is filled by information from the most specific accessible node in the hierarchy, and &apos;complete,&apos; by which multiple values for a slot are obtained from a number of more general frames. Values for the FEATURES slot for the word has thus include (AUX PLUS) inherited from AUXILIARY, (AGREEMENT 3RD-SING) from THIRD-SING, and (CONTROL S</context>
</contexts>
<marker>Rosenberg, 1983</marker>
<rawString>Rosenberg, S. (1983). &amp;quot;HPRL: A language for building expert systems.&amp;quot; In Proceedings, Eighth International Joint Conference on Artificial Intelligence, 215-217.</rawString>
</citation>
<citation valid="true">
<authors>
<author>G Russell</author>
<author>J Carroll</author>
<author>S Warwick</author>
</authors>
<title>Multiple default inheritance in a unification-based lexicon.&amp;quot;</title>
<date>1990</date>
<booktitle>In Proceedings of the Workshop on Inheritance and Natural Language Processing,</booktitle>
<note>edited by</note>
<marker>Russell, Carroll, Warwick, 1990</marker>
<rawString>Russell, G.; Carroll, J.; and Warwick, S. (1990). &amp;quot;Multiple default inheritance in a unification-based lexicon.&amp;quot; In Proceedings of the Workshop on Inheritance and Natural Language Processing, edited by</rawString>
</citation>
<citation valid="false">
<authors>
<author>W Daelemans</author>
<author>G Gazdar</author>
</authors>
<pages>93--102</pages>
<institution>Tilburg University.</institution>
<marker>Daelemans, Gazdar, </marker>
<rawString>W. Daelemans and G. Gazdar. 93-102. Tilburg University.</rawString>
</citation>
<citation valid="true">
<authors>
<author>E Sandewall</author>
</authors>
<title>Nonmonotonic inference rules for multiple inheritance with exceptions.&amp;quot;</title>
<date>1986</date>
<booktitle>In Proceedings, IEEE</booktitle>
<volume>74</volume>
<pages>1345--1353</pages>
<contexts>
<context position="1823" citStr="Sandewall (1986)" startWordPosition="263" endWordPosition="264">other, to express exceptions to such statements affecting both individual words and subclasses of words. These considerations have provoked interest in applying to the domain of the lexicon Al knowledge representation techniques involving the notions of inheritance and defaults) Unfortunately, many of the schemes that have been proposed are highly complex; departing from simple tree-form taxonomies dramatically increases the problems of dealing in a systematic fashion with default inheritance. Not only are the intuitions underlying the behavior of systems such as those of Touretzky (1986) and Sandewall (1986) unstable (as Touretzky et al. [1987] show), Selman and Levesque (1989) demonstrate that certain of them are NP-hard and thus effectively intractable. In a well-defined domain such as the lexicon there remains the possibility of mitigating these problems by adopting a principled compromise; it may be advantageous to surrender some of the generality of an inheritance system, if the more restricted version that results retains sufficient expressive power for the domain in question. We expand on this below and propose a number of simplifications that are motivated by the particular task that the </context>
</contexts>
<marker>Sandewall, 1986</marker>
<rawString>Sandewall, E. (1986). &amp;quot;Nonmonotonic inference rules for multiple inheritance with exceptions.&amp;quot; In Proceedings, IEEE 74. 1345-1353.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J G Schmolze</author>
<author>T A Lipkis</author>
</authors>
<title>Classification in the KL-ONE knowledge representation system.&amp;quot;</title>
<date>1983</date>
<booktitle>In Proceedings, Eighth International Joint Conference on Artificial Intelligence.</booktitle>
<pages>330--332</pages>
<contexts>
<context position="9680" citStr="Schmolze and Lipkis 1983" startWordPosition="1498" endWordPosition="1501">main&apos; equation set (iv) zero or more (possibly empty) &apos;variant&apos; equation sets. 2.1.2 Superclass Declaration. The superclass declaration is a list of the names of any direct superclass of the current class. This is used in computing the relative precedence of classes in the lexicon for the purpose of default inheritance (see Section 2.5); it may be empty if the class has no superclasses, i.e., if it is one of the most general in the lexicon, and thus inherits no information. Precedence of direct superclasses is 3 Thus no distinction is made between classes and &apos;instances,&apos; as in, e.g., KL-ONE (Schmolze and Lipkis 1983) and much more recent work. One reason for this is that instances of the kind appealed to by some KR researchers do not exist within a unification-based linguistic description. What would count as an instance in this context is an occurrence of a word in the analysis of some text; in general, information associated with one particular occurrence of a word will originate partly in its lexical specification and partly through unifications with other items. A second, related reason for not enforcing a class/instance distinction is that lexical classes may themselves usefully be inherited from; ex</context>
</contexts>
<marker>Schmolze, Lipkis, 1983</marker>
<rawString>Schmolze, J. G., and Lipkis, T. A. (1983). &amp;quot;Classification in the KL-ONE knowledge representation system.&amp;quot; In Proceedings, Eighth International Joint Conference on Artificial Intelligence. 330-332.</rawString>
</citation>
<citation valid="true">
<authors>
<author>B Selman</author>
<author>H J Levesque</author>
</authors>
<title>The tractability of path-based inheritance.&amp;quot;</title>
<date>1989</date>
<booktitle>In Proceedings, 11th International Joint Conference on Artificial Intelligence.</booktitle>
<pages>1140--1145</pages>
<contexts>
<context position="1894" citStr="Selman and Levesque (1989)" startWordPosition="272" endWordPosition="275">h individual words and subclasses of words. These considerations have provoked interest in applying to the domain of the lexicon Al knowledge representation techniques involving the notions of inheritance and defaults) Unfortunately, many of the schemes that have been proposed are highly complex; departing from simple tree-form taxonomies dramatically increases the problems of dealing in a systematic fashion with default inheritance. Not only are the intuitions underlying the behavior of systems such as those of Touretzky (1986) and Sandewall (1986) unstable (as Touretzky et al. [1987] show), Selman and Levesque (1989) demonstrate that certain of them are NP-hard and thus effectively intractable. In a well-defined domain such as the lexicon there remains the possibility of mitigating these problems by adopting a principled compromise; it may be advantageous to surrender some of the generality of an inheritance system, if the more restricted version that results retains sufficient expressive power for the domain in question. We expand on this below and propose a number of simplifications that are motivated by the particular task that the system is intended to perform. * ISSCO, 54 route des Acacias, 1227 Gene</context>
</contexts>
<marker>Selman, Levesque, 1989</marker>
<rawString>Selman, B., and Levesque, H. J. (1989). &amp;quot;The tractability of path-based inheritance.&amp;quot; In Proceedings, 11th International Joint Conference on Artificial Intelligence. 1140-1145.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S M Shieber</author>
</authors>
<title>An Introduction to Unification-Based Approaches to Grammar.</title>
<date>1986</date>
<publisher>CSLI.</publisher>
<contexts>
<context position="3187" citStr="Shieber 1986" startWordPosition="473" endWordPosition="474">mbroke Street, Cambridge CI32 3QG, UK. I See, e.g., Evans and Gazdar 1990, Gazdar 1990 (especially the References), much of the material in Daelemans and Gazdar 1990, and the contributions to Briscoe et al. 1991. We discuss some of this work below. C) 1992 Association for Computational Linguistics Computational Linguistics Volume 18, Number 3 The system described here has been implemented as part of the au&apos; unification grammar development environment for research in machine translation, made up of parser, generator, lexicon, and transfer mechanism. The user language resembles that of PATR-II (Shieber 1986a), but provides a larger range of data types and more powerful means of stating relations between them. Among the requirements imposed by the context within which this system is used are (i) the ability to both analyze and generate complex word forms, (ii) full integration with existing parts of the au environment, and (iii) the ability to accommodate a relatively large number of words. In particular, an important objective is to preserve as far as possible the flavor of this type of environment: a specialized programming language for linguistic descriptions, suitable for interpretation by a </context>
<context position="45633" citStr="Shieber (1986" startWordPosition="7596" endWordPosition="7597"> applying inheritance to the lexicon, and indeed to linguistic descriptions in general, is not a new one. Here we consider a few of the proposals that have appeared in recent years. 15 Classes with one or no variant set yield at most a singleton superclass extension for each FS they apply to, while others multiply a FS by a factor of no more than their total number of variant sets. 325 Computational Linguistics Volume 18, Number 3 4.1 Defaults and Reentrancy The notion of &apos;default extension&apos; employed here resembles the &apos;priority union&apos; of Kaplan (1987: 180f) and the &apos;conservative addition&apos; of Shieber (1986b). As Bouma (1990) points out, the result of defaulting under this approach may depend on order of application. To take Bouma&apos;s (p. 166) simple example, default unification of the FSs (1) [ F a] (2) [a b with a re-entrant structure o[i produces different, nonunifying, results: [Fa] (5) F 1:0]b] (4) G [G (4) results when (1) applies before (2), and (5) when (2) applies before (1). Similarly, defaulting the FSs (6) F 131 (7) [G 13] G onto a FS (8) [ F a] produces one of [F W al (9) (10) IF al G Lab] according to whether (6) applies before (7), in which case the result is (9), or (7) applies bef</context>
<context position="48751" citStr="Shieber 1986" startWordPosition="8113" endWordPosition="8114">he au lexicon shares the following. (i) Strict information is preserved—i.e., default unification is monotonic (see Section 4.2). (ii) Default unification reduces to standard unification if the two FSs involved are consistent. (iii) Default unification is finite. The fourth property, that skeptical and credulous default unification are both well defined in all cases, is not shared by the present system—as we have seen above, the definition of default extension (Section 3.2) produces no solution for unifications of the type illustrated here. 4.2 Monotonicity The &apos;template&apos; facility of PATR-II (Shieber 1986a: 55ff) allows inheritance within the lexicon. Lexical entries may be defined by means of templates that have other templates in their definitions. Thus, if the definition of a template T1 mentions the templates T2 and T3, any entry in which T1 appears also receives the contents of T2 and T3. This is a form of strict multiple inheritance, since, if T2 and T3 contain conflicting information, unification fails and no corresponding lexical item is created. Shieber (1986a: 59ff) also describes a type of default inheritance implemented in terms of a noncommutative &apos;overwriting&apos; operation, in which</context>
</contexts>
<marker>Shieber, 1986</marker>
<rawString>Shieber, S. M. (1986a). An Introduction to Unification-Based Approaches to Grammar. CSLI.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S M Shieber</author>
</authors>
<title>A simple reconstruction of GPSG.&amp;quot;</title>
<date>1986</date>
<booktitle>In Proceedings, 11th International Conference on Computational Linguistics.</booktitle>
<pages>211--215</pages>
<contexts>
<context position="3187" citStr="Shieber 1986" startWordPosition="473" endWordPosition="474">mbroke Street, Cambridge CI32 3QG, UK. I See, e.g., Evans and Gazdar 1990, Gazdar 1990 (especially the References), much of the material in Daelemans and Gazdar 1990, and the contributions to Briscoe et al. 1991. We discuss some of this work below. C) 1992 Association for Computational Linguistics Computational Linguistics Volume 18, Number 3 The system described here has been implemented as part of the au&apos; unification grammar development environment for research in machine translation, made up of parser, generator, lexicon, and transfer mechanism. The user language resembles that of PATR-II (Shieber 1986a), but provides a larger range of data types and more powerful means of stating relations between them. Among the requirements imposed by the context within which this system is used are (i) the ability to both analyze and generate complex word forms, (ii) full integration with existing parts of the au environment, and (iii) the ability to accommodate a relatively large number of words. In particular, an important objective is to preserve as far as possible the flavor of this type of environment: a specialized programming language for linguistic descriptions, suitable for interpretation by a </context>
<context position="45633" citStr="Shieber (1986" startWordPosition="7596" endWordPosition="7597"> applying inheritance to the lexicon, and indeed to linguistic descriptions in general, is not a new one. Here we consider a few of the proposals that have appeared in recent years. 15 Classes with one or no variant set yield at most a singleton superclass extension for each FS they apply to, while others multiply a FS by a factor of no more than their total number of variant sets. 325 Computational Linguistics Volume 18, Number 3 4.1 Defaults and Reentrancy The notion of &apos;default extension&apos; employed here resembles the &apos;priority union&apos; of Kaplan (1987: 180f) and the &apos;conservative addition&apos; of Shieber (1986b). As Bouma (1990) points out, the result of defaulting under this approach may depend on order of application. To take Bouma&apos;s (p. 166) simple example, default unification of the FSs (1) [ F a] (2) [a b with a re-entrant structure o[i produces different, nonunifying, results: [Fa] (5) F 1:0]b] (4) G [G (4) results when (1) applies before (2), and (5) when (2) applies before (1). Similarly, defaulting the FSs (6) F 131 (7) [G 13] G onto a FS (8) [ F a] produces one of [F W al (9) (10) IF al G Lab] according to whether (6) applies before (7), in which case the result is (9), or (7) applies bef</context>
<context position="48751" citStr="Shieber 1986" startWordPosition="8113" endWordPosition="8114">he au lexicon shares the following. (i) Strict information is preserved—i.e., default unification is monotonic (see Section 4.2). (ii) Default unification reduces to standard unification if the two FSs involved are consistent. (iii) Default unification is finite. The fourth property, that skeptical and credulous default unification are both well defined in all cases, is not shared by the present system—as we have seen above, the definition of default extension (Section 3.2) produces no solution for unifications of the type illustrated here. 4.2 Monotonicity The &apos;template&apos; facility of PATR-II (Shieber 1986a: 55ff) allows inheritance within the lexicon. Lexical entries may be defined by means of templates that have other templates in their definitions. Thus, if the definition of a template T1 mentions the templates T2 and T3, any entry in which T1 appears also receives the contents of T2 and T3. This is a form of strict multiple inheritance, since, if T2 and T3 contain conflicting information, unification fails and no corresponding lexical item is created. Shieber (1986a: 59ff) also describes a type of default inheritance implemented in terms of a noncommutative &apos;overwriting&apos; operation, in which</context>
</contexts>
<marker>Shieber, 1986</marker>
<rawString>Shieber, S. M. (1986b). &amp;quot;A simple reconstruction of GPSG.&amp;quot; In Proceedings, 11th International Conference on Computational Linguistics. 211-215.</rawString>
</citation>
<citation valid="true">
<authors>
<author>G L Steele</author>
</authors>
<title>Common Lisp: The Language, Second Edition.</title>
<date>1990</date>
<publisher>Digital Press.</publisher>
<contexts>
<context position="28461" citStr="Steele (1990" startWordPosition="4564" endWordPosition="4565">r, at any joins (such as F in this case) splicing in the next leftmost path before continuing with depth-first computation. The CPL of A in Figure 2 is therefore (A,B,C,D,E,F), with A being the most specific and F the most general.&apos; This procedure deterministically selects one total ordering from the set of orderings compatible with the superclass declarations; if none can be derived, the system gives an error during compilation. A given CPL can be derived from several sets of class definitions; the lexicons shown below are some of those which, when compiled, will result in the same CPL 8 See Steele (1990: 782f0 for details of the algorithm, and Keene (1989: 118ff) for discussion. 9 The ordering relation of specificity on classes should not be confused with the subsumption relation on feature structures; the former is determined by superclass declarations and is independent of the information content of any constraints within the classes. Typically, more specific classes describe smaller sets of words. 319 Computational Linguistics Volume 18, Number 3 A Figure 3 An impossible hierarchy. (A,B,C,D,E,F), as the example above: #Word A (B) #Class B (C) #Class C (D) #Class D (E) #Class E (F) #Class </context>
</contexts>
<marker>Steele, 1990</marker>
<rawString>Steele, G. L. (1990). Common Lisp: The Language, Second Edition. Digital Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D S Touretzky</author>
</authors>
<title>The Mathematics of Inheritance Systems.</title>
<date>1986</date>
<publisher>Pitman Publishing.</publisher>
<contexts>
<context position="1802" citStr="Touretzky (1986)" startWordPosition="260" endWordPosition="261">f words, and, on the other, to express exceptions to such statements affecting both individual words and subclasses of words. These considerations have provoked interest in applying to the domain of the lexicon Al knowledge representation techniques involving the notions of inheritance and defaults) Unfortunately, many of the schemes that have been proposed are highly complex; departing from simple tree-form taxonomies dramatically increases the problems of dealing in a systematic fashion with default inheritance. Not only are the intuitions underlying the behavior of systems such as those of Touretzky (1986) and Sandewall (1986) unstable (as Touretzky et al. [1987] show), Selman and Levesque (1989) demonstrate that certain of them are NP-hard and thus effectively intractable. In a well-defined domain such as the lexicon there remains the possibility of mitigating these problems by adopting a principled compromise; it may be advantageous to surrender some of the generality of an inheritance system, if the more restricted version that results retains sufficient expressive power for the domain in question. We expand on this below and propose a number of simplifications that are motivated by the part</context>
<context position="17982" citStr="Touretzky 1986" startWordPosition="2842" endWordPosition="2843">. When the many subclasses and special cases of inflectional behavior are taken into account, together with a more adequate analysis of subcategorization patterns, the number of nodes required, and the redundancy of the specifications, increases considerably. Multiple inheritance permits the two types of information to be kept separate by isolating them in distinct sub-hierarchies. This compartmentalization is implicitly related to the independence of the sub-hierarchies; if constraints relevant to different types of information are always disjoint, then the system as a whole is &apos;orthogonal&apos; (Touretzky 1986: 73ff). The significance of this point lies in the fact that, if superclasses B and C of some class A are independent in this way, no conflict can arise when A inherits from both B and C, and the result of inheriting default information from the superclasses will not vary according to the order in which the defaults apply. The organization of a lexicon must reflect two types of relation between classes of words. Clearly, certain classes stand in the subset/superset relation—&apos;words&apos; in general, &apos;verbs,&apos; present tense verbs,&apos; present tense verbs agreeing with a plural subject,&apos; &apos;present tense v</context>
<context position="22710" citStr="Touretzky 1986" startWordPosition="3618" endWordPosition="3619">olving the conflicts that arise when information present in two or more superclasses is mutually incompatible, e.g., when the result obtained when A inherits from one superclass B before inheriting from another, C, differs from that obtained by inheriting first from C and then from B. It is in such cases that the notion of &amp;quot;precedence&amp;quot; comes into play; if the system is constrained so that information is inherited first from B, we say that B &amp;quot;has precedence over,&amp;quot; or &amp;quot;is more specific than&amp;quot; C. A familiar example of this type of situation from the AT literature is the so-called &apos;Nixon diamond&apos; (Touretzky 1986). Nixon is both a Quaker and a Republican; Quakers are (typically) pacifists, while Republicans are (typically) not; the question to be answered is whether Nixon is a pacifist. In a conventional inheritance network, this problem might be represented by the configuration shown in Figure 1. If the links to the &apos;Pacifist&apos; class are both defeasible, which should take precedence, the positive link from &apos;Quaker,&apos; or the negative link from &apos;Republican&apos;?&apos; Within the Eix lexicon, a natural way of representing the same information is to dispense with a &apos;Pacifist&apos; class, and instead to make (non) pacifis</context>
</contexts>
<marker>Touretzky, 1986</marker>
<rawString>Touretzky, D. S. (1986). The Mathematics of Inheritance Systems. Pitman Publishing.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D S Touretzky</author>
<author>J E Horty</author>
<author>R H Thomason</author>
</authors>
<title>A clash of intuitions: The current state of nonmonotonic multiple inheritance systems.&amp;quot;</title>
<date>1987</date>
<booktitle>In Proceedings, Tenth International Joint Conference on Artificial Intelligence.</booktitle>
<pages>476--482</pages>
<contexts>
<context position="19942" citStr="Touretzky et al. (1987)" startWordPosition="3152" endWordPosition="3155">biguity of inheritance is eliminated by enforcing a total ordering on the superclasses of any given class or word, and by making it clear to users how this ordering is derived so that they may more accurately control and exploit it in the organization of the hierarchy. As a substitute for unordered multiple inheritance, the variant set mechanism is introduced; this allows variants to be represented directly within a class rather than by creating alternate, unordered superclasses, and corresponds to a strong element 5 Cf. examples of cascaded ambiguity and On-Path versus Off-Path preemption in Touretzky et al. (1987). 316 Graham Russell et al. A Practical Approach to Multiple Default Inheritance in traditional grammatical description, that such mutually exclusive variant classes should nevertheless be grouped together in a single compound statement or paradigm. A concrete version of this may be seen in the inflection tables to be found in reference and pedagogical grammars of foreign languages. Users are able to simulate ambiguity judiciously when required, but are responsible for determining when this should occur. In effect, we are giving away some of the generality of an inheritance reasoner (that it r</context>
<context position="30431" citStr="Touretzky et al. (1987)" startWordPosition="4911" endWordPosition="4914">e is no prohibition on expressing the same information in two classes—this type of redundancy is harmless in that it does not complicate the process of searching the hierarchy. Another consequence is that cyclic hierarchies are precluded—no total order can be constructed in which A &lt; B and B &lt;A. Intuitively, there is no reason for defining a network with cyclic paths, when traversing the same portion of the network repeatedly can add no more information and may introduce paradoxes. Nor is there any means of expressing negative links of the kind shown in Figure 1.10 The au lexicon is thus what Touretzky et al. (1987) term a unipolar system. The significance of this point is that the presence of exception links is another factor in the complexity of a hierarchy; moreover, this type of negation is of dubious utility in the present context, for two reasons. First, the precedence of default information from subclasses appears to enable exceptionality to be expressed without explicit negation of inheritance. The second reason is connected with the nature of graph unification. The absence of a path-value pair P = &lt;p, v&gt; in a FS F cannot be interpreted as a positive constraint that (some extension of) F does not</context>
</contexts>
<marker>Touretzky, Horty, Thomason, 1987</marker>
<rawString>Touretzky, D. S.; Horty, J. E; and Thomason, R. H. (1987). &amp;quot;A clash of intuitions: The current state of nonmonotonic multiple inheritance systems.&amp;quot; In Proceedings, Tenth International Joint Conference on Artificial Intelligence. 476-482.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>