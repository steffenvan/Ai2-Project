<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<title confidence="0.996084">
Deterministic Consistency Checking of LP Constraints
</title>
<author confidence="0.994272">
Suresh Manandhar
</author>
<affiliation confidence="0.998258333333333">
Language Technology Group
Human Communication Research Centre
University of Edinburgh, Scotland
</affiliation>
<email confidence="0.998778">
email: Suresh.Manandhar@ed.ac.uk
</email>
<sectionHeader confidence="0.998577" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.9730995">
We provide a constraint based compu-
tational model of linear precedence as
employed in the HPSG grammar formal-
ism. An extended feature logic which
adds a wide range of constraints involv-
ing precedence is described. A sound,
complete and terminating deterministic
constraint solving procedure is given.
Deterministic computational model is
achieved by weakening the logic such
that it is sufficient for linguistic appli-
cations involving word-order.
Subject areas: feature logic, constraint based
grammars
</bodyText>
<sectionHeader confidence="0.99956" genericHeader="keywords">
1 Introduction
</sectionHeader>
<bodyText confidence="0.999407166666667">
Within HPSG (Pollard and Sag, 1987) (Pollard
and Sag, 1994) the constituent ordering princi-
ple given in (1) is intended to express the rela-
tion between the value of the PHON attribute and
the DTRS attribute which contains the hierarchical
structure of the derivation.
</bodyText>
<listItem confidence="0.905374">
(1) phrasal_sign = PHON order_constituentC)
DTRS n
(2) Linear Precedence Constraint 1 (LP1):
HEAD[LEX+] &lt; []
</listItem>
<bodyText confidence="0.970589666666667">
However, it is not entirely clear how or-
der_constituent is supposed to interpret various
linear precedence statements such as LP1.
</bodyText>
<subsectionHeader confidence="0.993882">
1.1 Reape&apos;s approach
</subsectionHeader>
<bodyText confidence="0.999862625">
The idea taken in Reape&apos;s approach (Reape, 1993)
is to suggest that word-order is enforced between
locally definable word order domains which are or-
dered sequences of constituents. Word order do-
mains in Reape&apos;s approach are totally ordered se-
quences. A domain union operation as given in (3)
is then employed to construct word order domains
locally within a HPSG derivation step.
</bodyText>
<listItem confidence="0.407096">
(3) 0(7/,7i,n).
</listItem>
<bodyText confidence="0.839516571428571">
(31(x o o- 3) 44 C)(o-,,o.„0-3).
C)(o-,,xoa„x 0 (73) 44 C)(o-,,a2,a-3).
If A is the string &lt; a,b &gt; and B is the
string &lt;c, d&gt;, their domain union C given by
0(A, B, C) will produce all the sequences in
which a precedes b and c precedes d i.e. the fol-
lowing sequences:
</bodyText>
<listItem confidence="0.939886666666667">
&lt; a,b,c,d &gt; &lt; a, c,b, d &gt;
&lt; a, c,d,b &gt; &lt; c, d, a, b &gt;
&lt; c,d, a, b &gt; &lt; c, a, b, d &gt;
</listItem>
<bodyText confidence="0.834523">
However in this system to encode the property
that {x, y, z} is a domain in which the ordering is
arbitrary (i.e. free) then one needs the following
disjunctive statements:
</bodyText>
<equation confidence="0.798279">
&lt;x, y, z &gt; U &lt;x, z,y &gt;
&lt; y,x, z &gt; U &lt; y, z,x &gt;
&lt; z,x,y &gt; U &lt; z,y,x &gt;
</equation>
<bodyText confidence="0.9966218">
It is simply not possible to be agnostic about
the relative ordering of sequence elements within
Reape&apos;s system.
We identify two deficiencies in Reape&apos;s ap-
proach namely:
</bodyText>
<listItem confidence="0.999433333333333">
• System is non-deterministic (generate and
test paradigm)
• Not possible to be agnostic about order
</listItem>
<bodyText confidence="0.999560857142857">
This is so since domain union is a non-
deterministic operation and secondly underspec-
ification of ordering within elements of a domain
is not permitted.
In the following sections we describe a con-
straint language for specifying LP constraints that
overcomes both these deficiencies. Additionally
our constraint language provides a broad range of
constraints for specifying linear precedence that
go well beyond what is available within current
typed feature formalisms. Our approach is in the
spirit of Reape&apos;s approach but improves upon it.
Furthermore, a sound, complete and terminat-
ing consistency checking procedure is described.
</bodyText>
<page confidence="0.997797">
165
</page>
<bodyText confidence="0.930193307692308">
Our constraint solving rules are deterministic and
incremental. Hence these do not introduce costly
choice-points. These constraint solving rules can
be employed for building an efficient implementa-
tion. This is an important requirement for prac-
tical systems. Indeed we have successfully ex-
tended the ProFIT typed feature formalism (Er-
bach, 1995) with the constructs described in this
paper.
2 Outline of an alternative
approach
To motivate our approach we start with an exam-
ple on scrambling in German subordinate clauses.
</bodyText>
<listItem confidence="0.769818">
(4) daB er einen Mann in der Strafie laufen
that he a man in the street walking
sah.
saw.
that he saw a man walking in the street.
(5) daB er in der StraBe einen Mann laufen sah.
(6) daB einen Mann er in der .StraBe laufen sah.
(7) daB einen Mann in der StraBe er laufen sah.
(8) daB in der StraBe er einen Mann laufen sah.
(9) daB in der StraBe einen Mann er laufen sah.
</listItem>
<bodyText confidence="0.999777333333333">
The above data can be captured precisely if we
can state that sah requires both its verbal argu-
ment laufen and its NP argument er to precede it.
Similarly, laufen would require both its arguments
einen Mann and in der Strafle to precede it. This
is illustrated schematically in (10) below.
</bodyText>
<equation confidence="0.9531215">
(10) { er
{ einen mann, in der strasse) — { laufen }
</equation>
<bodyText confidence="0.9993866">
Our idea is to employ a specification such as the
one given in (11) which is a partial specification
of the lexical entry for the verb sah. The specifi-
cation can be thought of as a formal specification
of the intuitive description given in (12).
</bodyText>
<equation confidence="0.973227272727273">
(11)
/ V ri phon : &lt; sah &gt; fl
field: Field n
syn: ( cat : v fl
subcat : NP fl dom: NPdom,
V, 11 dom: V idom} 11
dom :3 NPdom fl
dom :3 V ,dom ) fl
V idom &lt; dom. {v} fl
NPdom &lt; dom {lit} n
1/ &lt; v
</equation>
<bodyText confidence="0.9931967">
For space reasons, our treatment is necessar-
ily somewhat superficial since we do not take
into account other interacting phenomena such as
fronting or extraposition.
The definition in (11) does not make specific as-
sumption about whether a context-free backbone
is employed or not. However, if a CFG back-
bone is employed then we assume that the value
of the subcat attribute is treated as an unordered
sequence (i.e. a set) as defined in (11).
</bodyText>
<equation confidence="0.706536">
(12) NPdom V
Vidom vi
</equation>
<bodyText confidence="0.961998142857143">
The essential idea is to use set-valued descrip-
tions to model word-order domains. In particu-
lar subset constraints (Manandhar, 1994) are em-
ployed to construct larger domains from smaller
ones. Thus in example (11) the domain of the verb
is constructed by including the domains of the
subcategorised arguments (enforced by the con-
straints dom :3 N Pdomil dom :3 ViDom). Note
that in this example the verb itself is not part of its
own domain. The binary constraint V, &lt; V en-
forces precedence ordering between the signs V,
and V. The constraint V idom &lt; dom {V} en-
sures that every element of the set V iDom pre-
cedes the sign V. In other words, the set V iDorn
is in the domain precedence relation with the sin-
gleton {V}.
However there are strong constraints on order-
ing in the middle field. For instance, when prono-
mia1 complements are involved then not all per-
mutations are acceptable. Examples such as (13)
are considered ungrammatical.
</bodyText>
<listItem confidence="0.9353798">
(13) *daB in der StraBe ihn er laufen sah.
According to Uszkoreit (Uszkoreit, 1985), order-
ing of arguments in the middle field is governed by
the following set of LP constraints given in (14)
which are to be interpreted disjunctively.
(14) PPRN : &lt; PPRN : —
T R : agent &lt; TR: theme
TR : agent &lt; TR: goal
TR : goal &lt; TR: theme
FOCUS: — &lt; FOCUS :
</listItem>
<bodyText confidence="0.979754571428571">
The LP constraint in (14) states that for every
pair of constituents in the middle field at least one
of the conditions should apply otherwise the sen-
tence is considered ungrammatical. A related but
more elaborate LP rule mechanism is considered
in (Steinberger, 1994).
sah
</bodyText>
<page confidence="0.997181">
166
</page>
<bodyText confidence="0.9997834">
To approximate this complex LP constraint em-
ploying the kind of logical machinery described in
this paper, we can use a description such as the
one given in (15). The definition given in (15)
extends the description given in (11).
</bodyText>
<figure confidence="0.7556926">
(15) syn: dom : MF 11
3x3yif xEMFAyEMFAx&lt;y
then
if x = pprn : + A y = pprn : —
then T
else
if x = tr : agent A y = tr : theme
then T
else
if x = tr : agent A y = tr : goal
then T
else
if x = tr : goal A y = tr : theme
then T
else
</figure>
<bodyText confidence="0.975892666666667">
x= focus: —Ayr-- f ocus : +
The definition in (15) can be understood as fol-
lows. The feature constraint syn : darn : MF co-
instantiates the middle field domain to the vari-
able MF. To keep the example simple, we assume
that the whole domain is in the middle field and
we ignore fronting or extraposition. A more com-
plex condition would be needed to handle these.
The rest of the definition in (15) ensures that for
every pair of elements x and y such that x and y
are both members of MF and x precedes y at least
one of the LP constraints hold. If every LP con-
straint is violated then an inconsistency results.
The constraints in (15) is a weaker representation
of the disjunctive specification given in (16).
</bodyText>
<listItem confidence="0.6262365">
(16) 3x3y if (x EMFAyEMFAx&lt; y)
then
</listItem>
<equation confidence="0.9415176">
V x = tr : agent A y = tr : goal
{ x = pprn : + A y = pprn : --
x = tr : agent A y = tr : theme
x = tr : goal A y = tr : theme
x = f ocus : — A y = f ocus : +
</equation>
<bodyText confidence="0.996556545454546">
The description in (16) non-deterministically re-
quires that at least one of the LP constraints hold.
On the other hand, the description in (15) waits
until either one of the LP constraints is satisfied
(in which case it succeeds) or all the LP con-
straints are violated (in which case it fails). Thus
the description in (15) can be solved determinis-
tically.
Thus (15) should rule out the ungrammatical
example in (13) if the assumptions regarding focus
are made as in (17).
</bodyText>
<listItem confidence="0.57537925">
(17) *daB in der StraBe ihn er laufen sah.
ppm:- focus:-
th:theme pprn:+
tr: agent
</listItem>
<bodyText confidence="0.9995475">
Note that it is not necessary to know whether the
PP in der Strafle is focussed to rule out (17) since
the fact that the pronoun ihn is focus:- is enough
to trigger the inconsistency.
</bodyText>
<sectionHeader confidence="0.719469" genericHeader="introduction">
3 Some generic LP constraints
</sectionHeader>
<bodyText confidence="0.99923875">
As suggested by the example in (11), in general
we would want support within typed feature for-
malisms for at least the following kinds of LP con-
straints.
</bodyText>
<listItem confidence="0.99757825">
1. Sign, &lt; Sign,
2. Dom, &lt; dorn Dom2
(Dom, and Dom, are set-valued)
3. Dom, is included in Dom,
</listItem>
<bodyText confidence="0.997603888888889">
The constraint Sign, &lt; Sign, states that Sign,
precedes Sign,. The constraint Dom, &lt; don, Dom,
states that every element of the set described by
Dom, precedes every element of the set described
by Dom,. Constraints such as Dom, is included
in Dom, essentially builds larger domains from
smaller ones and can be thought of as achieving
the same effect as Reape&apos;s domain union oper-
ation. Note crucially that within our approach
the specification of precedence constraints (such
as Sign, &lt; Sign, and Dom, &lt; dom, Dom2) is in-
dependent of the domain building constraint (i.e.
the constraint Dom, is included in Dom2). This
we believe is a generalisation of Reape&apos;s approach.
Other constraints such as the following involv-
ing immediate precedence and first element of a
domain are of lesser importance. However, these
could be of the form:
</bodyText>
<listItem confidence="0.9971795">
1. Sign, immediately-precedes Sign2
2. First daughter of Dom, is Sign,
</listItem>
<bodyText confidence="0.849418333333333">
To be able to state descriptions such as in (15),
we also want to introduce guarded (or conditional)
LP constraints such the following:
</bodyText>
<listItem confidence="0.989643222222222">
1. if Sign, is NP[acc] A Sign, is NP[dat]
then Sign, &lt; Sign,
( Guards on Feature constraints)
2. if Sign, &lt; Sign, then
( Guards on precedence constraints)
3. 3x3y (if x:NP[acc] E Dom A
y:NP[dat] E Dom
then x &lt;y)
( Guards on set members)
</listItem>
<bodyText confidence="0.981004333333333">
Guarded constraints can be thought of as condi-
tional constraints whose execution depends on the
presence of other constraints. The condition part
</bodyText>
<page confidence="0.988128">
167
</page>
<bodyText confidence="0.999920962962963">
G of a guarded constraint if G then S else T is
known as a guard. The consequent S is executed if
the current set of constraints entail the guard G.
The consequent T is executed if the current set
of constraints disentail the guard G. If the cur-
rent set of constraints neither entail nor disentail
G then the execution of the whole guarded con-
straint is blocked until more information is avail-
able.
The application of guarded constraints within
computational linguistics has not been well ex-
plored. However, the Horn extended feature struc-
tures described in (Hegner, 1991) can be thought
of as adding guards to feature structures. On the
other hand, within logic programming guarded
logic programming languages have a longer his-
tory originating with committed-choice languages
(Ueda, 1985) and popularised by the concurrent
constraint programming paradigm due to Saraswat
(Saraswat and Rinard, 1990) (Saraswat, 1993).
For space reasons, we do not cover the logic of
guarded feature constraints, guards on set mem-
bership constraints and guards on precedence con-
straints. Guarded feature constraints have been
extensively studied in (Ait-Kaci et al., 1992)
(Smolka and Treinen, 1994) (Ait-Kaci and Podel-
ski, 1994).
</bodyText>
<sectionHeader confidence="0.807612" genericHeader="method">
4 A feature logic with LP
constraints
</sectionHeader>
<bodyText confidence="0.967746916666667">
In this section we provide formal definitions for
the syntax and semantics of an extended feature
logic that directly supports linear precedence con-
straints as logical primitives. The logic described
in this paper is a further development of the one
described in (Manandhar, 1993).
The syntax of the constraint language is defined
by the following BNF definitions.
Syntax
Let .T be the set of relation symbols and let P
be the set of irreflexive relation symbols. We shall
require that .7. and P are disjoint.
</bodyText>
<equation confidence="0.996747625">
0,0 x = f : y feature constraint
x =3f : y set-membership
x = 3p+ : y transitive closure
x =3p* : y reflex-trans closure
x = f g(y) subset inclusion
x = [f p first daughter
f (x) : p+ : g(y) domain precedence
f(x) : p* : g(y) domain prec. equals
</equation>
<bodyText confidence="0.981024105263158">
(i) &amp; conjunction
where f E .T and p E P
The constraint x = f : y specifies that y is the
only f-value of x. The constraint x = 3f : y
states that y is one of the f-values of x.
The constraint x = 3p+ : y just says that
x is related to y via the transitive closure of p.
The precedence constraint such as Sign, precedes
Sign2 is intended to be captured by the constraint
Sign, =3p+ :Sign2 where p denotes the (user cho-
sen) immediate precedence relation.
Similarly, x = 3p* : y states that x is related
to y via the transitive, reflexive closure of p. This
constraint is similar to the constraint x = 3p+ : y
except that it permits x and y to be equal.
The constraints f (x) : p+ : g(y) and f (x) : p* :
g(y) are intended to enforce precedence between
two word-ordering domains. The constraint f (x) :
p+ : g(y) states that every f-value of x precedes
(i.e. is in the p+ relation with) every g-value of p.
The constraint f (x) : p* : g(y) is analogous.
The constraint x = {f p l}y states that y is the
first daughter amongst the f-values of x (i.e. is in
the p* relation with every f-value of x).
Since our language supports both feature con-
straints and set-membership constraints the con-
ventional semantics for feature logic (Smolka,
1992) needs to be extended. The essential differ-
ence being that we interpret every feature/relation
as a binary relation on the domain of interpreta-
tion. Feature constraints then require that they
behave functionally on the variable upon which
the constraint is expressed.
A precise semantics of our constraint language
is given next.
Semantics
An interpretation structure I =&lt; /41, ./ &gt; is a
structure such that:
</bodyText>
<listItem confidence="0.8881482">
• Li/ is an arbitrary non-empty set
• ./ is an interpretation function which maps:
— every relation f E Y to a binary relation:
fi C x 241
— every relation p E P to a binary relation:
</listItem>
<equation confidence="0.431427">
131 c x Li/ with the added condition
that (p1)+ is irreflexive
</equation>
<bodyText confidence="0.956733857142857">
A variable assignment a is a function
: V
We shall write f I (e) to mean the set:
fl (e) = fe&apos; E (e, e&apos;) E
We say that an interpretation I and a variable as-
signment a satisfies a constraint /5 written I, a
if the following conditions are satisfied:
</bodyText>
<page confidence="0.883127">
168
</page>
<equation confidence="0.998091058823529">
1,aHx= f :y fl(a(x))= {a(y)}
I,c J= x = 21: y (a(x),a(y)) E
1,a = x = 3p+ : y -;=;, (a(x),a(y)) E (p1&amp;quot;)+
/, x 3p* : y (a(x),a(y)) E (pl.)*
1,a k x = f g (y) f I (co)) 2 91 (am)
1,a = x = [f p lly a(y) E f (a(x))A
Ve E U1
(e E f1 (a(x))
(a(Y), e) E (PI)*)
/, f (x) : p+ g(y) Vei, ez E
((ei E f1(a(x))A
e2 E g1(a(y)))
(e1,e2) E (p1)+)
1,a f (x) : p* : g(y) Ve1,e2 E U1
((ei E f (a(x))A
e2 E gl(a(y)))
(ei,e2) E (p1)*)
</equation>
<bodyText confidence="0.994474">
Given the above semantics, it turns out that the
first-daughter constraint can be defined in terms
of other constraints in the logic. Let f _pi. be a
distinct relation symbol then we can equivalently
define the first-daughter constraint by:
</bodyText>
<listItem confidence="0.775759">
• x = [f p fly x = f_p_l yA
x=3f : y A f _p_1(x) :p5 :1(x)
</listItem>
<bodyText confidence="0.9996024">
The translation states that y (which is the f_p_1-
value of x) precedes or is equal to every f-value
of x and y is a f-value of x. For this to work, we
require that the feature symbol f _p_1 appears only
in the translation of the constraint x = [f p 1]y.
</bodyText>
<subsectionHeader confidence="0.991209">
4.1 Two Restrictions
</subsectionHeader>
<bodyText confidence="0.999362666666667">
The logic we have described comes with 2 limita-
tions which at first glance appears to be somewhat
severe, namely:
</bodyText>
<listItem confidence="0.999896">
• NO atomic values
• NO precedence as a feature
</listItem>
<bodyText confidence="0.998343538461539">
This is so because it turns out that adding both
functional precedence and atoms in general leads
to a non-deterministic constraint solving proce-
dure. To illustrate this, consider the following
constraints:
x=f:yAy=aAx= 3f5:z
where a is assumed to be an atom.
The above constraints state that y is the f-value
of x and y is the atom a and z is related to x by
the reflexive-transitive closure of f.
Determining consistency of such constraints in
general involves solving for the following disjunc-
tive choices of constraints.
</bodyText>
<equation confidence="0.959923666666667">
X = Z Or y = z
x=yACs
(Equals)
x = y A [x/y]Cs
if x y and x occurs in C,
x=f:yAx=f:zA C,
(Feat)
x=f:yAy=zACs
x=f:yAx= 3f z A C,
(FeatExists)
x=f:yAx=3f:zAy=zAC5
(Subset)
x=f:2g(y)Ay=G:zACs
x=3f :yAx= f :D g(y)Ay=G:zAC,
ifx=3f:yVC,
</equation>
<bodyText confidence="0.988762">
where G ranges over g, 3g
</bodyText>
<figureCaption confidence="0.999396">
Figure 1: Constraint Solving - I
</figureCaption>
<bodyText confidence="0.99987875">
However for practical reasons we want to eliminate
any form of backtracking since this is very likely
to be expensive for implemented systems. On the
other hand, we certainly cannot prohibit atoms
since they are crucially required in grammar spec-
ification. But disallowing functional precedence
is less problematic from a grammar development
perspective.
</bodyText>
<subsectionHeader confidence="0.995286">
4.2 Imposing the restriction
</subsectionHeader>
<bodyText confidence="0.999978333333333">
We note that precedence can be restricted to non-
atomic types such as HPSG signs without com-
promising the grammar in any way. We then need
to ensure that precedence constraints never have
to consider atoms as their values. This can be
easily achieved within current typed feature for-
malisms by employing appropriateness conditions
(Carpenter, 1992).
An appropriateness condition just states that
a given feature (in our case a relation) can only
be defined on certain (appropriate) types. The
assumption we make is that precedence is specified
in such a way that is appropriate only for non-
atomic types. This restriction can be imposed by
the system (i.e. a typed feature formalism) itself.
</bodyText>
<sectionHeader confidence="0.970363" genericHeader="method">
5 Constraint Solving
</sectionHeader>
<bodyText confidence="0.998193636363636">
We are now ready to consider consistency checking
rules for our constraint language. To simplify the
presentation we have split up the rules into two
groups given in figure 1 and figure 2.
The constraint solving rules given in figure
1 deal with constraints involving features, set-
memberships, subset and first daughter. Rules
(Equals) and (Feat) are the usual feature logic
rules (Smolka, 1992) that deal with equality and
features. By [x/y)Cs we mean replacing every
occurrence of x with y in Cs. Rule (FeatEx-
</bodyText>
<page confidence="0.967319">
169
</page>
<equation confidence="0.96031675">
=-- 3p* :yAx= 3p+ : y A Cs
(TransConj)
x =3p+ : y A Cs
(TransClos) x = 3R1 : y A y = 3112 : z A C,
x (R, x R2) : zA
x -= 3R, : y A y = 3R2 : z A C,
if x = 3p+ : z CsA
x -= 3(R, x R2) : z V C
</equation>
<bodyText confidence="0.559597">
where R, x 172 is computed from:
</bodyText>
<table confidence="0.463413666666667">
x p* p+
PS P* 13+
P+ 13+ /3+
</table>
<figureCaption confidence="0.990044">
Figure 2: Constraint Solving - II
</figureCaption>
<bodyText confidence="0.999567375">
ists) deals with the interaction of feature and
set-membership constraint. Rule (Subset) deals
with subset constraints and adds a new constraint
x = 3f : y in the presence of the subset constraint
x f :D g(y) and the constraint y --= G : z (where
G ranges over g, 3g).
The constraint solving rules given in figure
2 deal with constraints involving the precedes
and the precedes or equal to relations and do-
main precedence. Rule (TransConj) eliminates
the weaker constraint x =3p* : y when both
x = 3p8 : y A x = 3p+ : y hold. Rule (TransC-
los) effectively computes the transitive closure of
the precedence relation one-step at a time. Rule
(Cycle) detects cyclic relations that are consis-
tent, namely, when x precedes or equals y and
vice versa then x = y is asserted. Finally rule
(DomPrec) propagates constraints involving do-
main precedence.
We say that a set of constraints are in normal
form if no constraint solving rules are applicable
to it. We say that a set of constraints in normal
form contains a clash if it contains constraints of
the form:
</bodyText>
<equation confidence="0.994113">
x = : x
</equation>
<bodyText confidence="0.999092">
In the following sections we show that our con-
straint solving rules are sound and every clash-
free constraint system in normal form is consis-
tent.
</bodyText>
<subsectionHeader confidence="0.3404715">
5.1 Soundness, Completeness and
Termination
</subsectionHeader>
<construct confidence="0.813991">
Theorem 1 (Soundness) Let&apos;&apos;, a be any inter-
pretation, assignment pair and let C, be any set
of constraints. If a constraint solving rule trans-
forms C8 to C&apos;8 then:
1, a C iff /, a C&apos;s
</construct>
<bodyText confidence="0.680702166666667">
Proof Sketch: The soundness claim can be verified
by checking that every rule indeed preserves the
interpretation of every variable and every relation
symbol.
Let succ(x, 1) and succ(x,p) and denote the
sets:
</bodyText>
<equation confidence="0.848100666666667">
• succ(x, f) =
{Y1x=3f :yEC„V f:yEC,}
• succ(x,p) = { y
x = 3R : y E Cs\
-az : (x = 3R, : z A z = 3/72 : y) E Cs}
where R, Ri, .172 E fp+ , p*1
Theorem 2 (Completeness) A constraint sys-
tem C5 in normal form is consistent if C, is
clash-free.
</equation>
<bodyText confidence="0.98771325">
Proof Sketch: For the first part, let C, be a con-
straint system containing a clash then it is clear
from the definition of clash that there is no in-
terpretation 1 and variable assignment a which
satisfies C,.
Let C, be a clash-free constraint system in nor-
mal form.
We shall construct an interpretation
=&lt; UR, .R &gt; and a variable assignment a such
that R., a = C.
Let UR = V.
The assignment function a is defined as follows:
</bodyText>
<listItem confidence="0.99935825">
• if x does not occur in C, then a(x) = x
• if x is such that x occurs exactly once in x =
y E C, then a(x) = x
• if x = y E Cs then a(y) = a(x)
</listItem>
<bodyText confidence="0.990875">
Note that for constraints in normal form: if x
y E Cs then either x is identical to y or x occurs
just once in C, (in the constraint x = y). Other-
wise Rule (Equals) is applicable.
The interpretation function . R is defined as fol-
lows:
</bodyText>
<listItem confidence="0.998949">
• f R(a(x)) = succ(a(x), f)
• pR(a(x)) = succ(a(x),p)
</listItem>
<bodyText confidence="0.961726">
It can be shown by a case by case analysis that
for every constraint K in C5:
a= K.
Hence we have the theorem.
</bodyText>
<equation confidence="0.967313714285714">
(Cycle) X = RP* A = 3 *:xAC,
f (x) : R : g(y) Ax=3f :x „A
y = 3g : yi A Cs
xi = 3R : y, A f (x) : R : g(y)A
x = 3f :x1 Ay =g :y, A Cs
if xi. = 3P+ : yi CsA
x, = 3R : y, C,
</equation>
<bodyText confidence="0.927834">
where R ranges over p+ , p*
</bodyText>
<figure confidence="0.732009666666667">
(DomPrec)
170
(Initial Description)
</figure>
<figureCaption confidence="0.977766">
Figure 3: Linearisation of precedence ordered
DAGs
</figureCaption>
<bodyText confidence="0.922521777777778">
Theorem 3 (Termination)
The consistency checking procedure terminates in
a finite number of steps.
Proof Sketch: The termination claim can be easily
verified if we first exclude rules (Subset), (TransC-
los) and (DomPrec) from consideration. Then for
the remainder of the rules termination is obvious
since these rules only simplify existing constraints.
For these rules:
</bodyText>
<listItem confidence="0.8261095">
1. Rule (Subset) increases the size of succ(x, f)
but since none of our rules introduces new
variables this is terminating.
2. Rules (TransClos) and (DomPrec) asserts a
</listItem>
<bodyText confidence="0.975178166666666">
relation R between pairs of variables x, y.
However, none of these rules apply once x =
3p+ : y is known. Furthermore, if x = 3p+ : y
is known it is never simplified to the weaker
x = 313* : y. This means that these rules
converge.
</bodyText>
<sectionHeader confidence="0.86018" genericHeader="method">
6 Linearisation of precedence
ordered DAGs
</sectionHeader>
<bodyText confidence="0.99650825">
The models generated by the completeness theo-
rem interpret (the map of) every precedence re-
lation p as a directed acyclic graph (DAG) as de-
picted in figure 3. However sentences in natural
languages are always totally ordered (i.e. they are
strings of words). This then raises the question:
Is it possible to generate linearised models?
For the logic that we have described this is always
possible. We only provide a graphical argument
given in figure 3 to illustrate that this is indeed
possible.
The question that arises is then:
</bodyText>
<footnote confidence="0.4989915">
What happens when we add immediate prece-
dence?
</footnote>
<figureCaption confidence="0.998487">
Figure 4: Difficulty in guaranteeing linearisable
models with immediate precedence
</figureCaption>
<subsectionHeader confidence="0.977148">
6.1 Problem with immediate precedence
</subsectionHeader>
<bodyText confidence="0.999916933333333">
However if we add immediate precedence to our
logic then it is not clear whether we can guarantee
linearisable models. This is highlighted in figure
4.
As illustrated in this figure consistency check-
ing of constraints involving both linear precedence
and immediate precedence with a semantics that
requires linearised models is not trivial. So we do
not explore this scenario in this paper.
However, it is possible to add immediate prece-
dence and extend the constraint solving rules de-
scribed in this paper in such a way that it is sound
and complete with respect to the current seman-
tics described in this paper (which does not insist
on linearised models).
</bodyText>
<sectionHeader confidence="0.884434" genericHeader="method">
7 Handling immediate precedence
</sectionHeader>
<bodyText confidence="0.998908444444444">
In this section, we provide additional constraint
solving rules for handling immediate precedence.
The basic idea is to treat immediate precedence
as a functional relation whose inverse too is func-
tional.
In effect what we add to our logic is both prece-
dence as a feature and a new constraint for repre-
senting the inverse functional precedence.
This is summarised by:
</bodyText>
<listItem confidence="0.984512">
• Represent x immediately precedes y by :
x x
• Semantics: I,o =y =p1 : x •&lt;&gt;
</listItem>
<equation confidence="0.946086">
(PI)-1(a(Y)) = {a(x)}
</equation>
<bodyText confidence="0.9622">
The additional rules given in figure below are all
that is needed to handle immediate precedence.
</bodyText>
<figure confidence="0.999606125">
(Incorrect
Model)
(Incorrect
Model)
A &amp; C B D
(Correct Model)
A
A
</figure>
<page confidence="0.642445">
171
</page>
<equation confidence="0.649223785714286">
x=p:y AC,,
(FeatExists) x=p:yAx= 3p : y A C,
ifx=3p:y0C,
: ,
(ExistsTrans = 3p y A C
)
x 3p : y A x = 3p+ : y A C,
if x = 3p+ : y C,
(InvIntro) 2;p=: xA% : y A C,
y p 1 : y A
f p:x
(InvExists) = po—t:yAz= 3p: x A C,
y=zAx=p&apos;:yAy=3p:xAC,
if y z
</equation>
<sectionHeader confidence="0.977124" genericHeader="conclusions">
8 Conclusions
</sectionHeader>
<bodyText confidence="0.993246666666667">
We have shown that the logic of linear precedence
can be handled elegantly and deterministically by
adding new logical primitives to feature logic. Al-
though, theoretically speaking, our logic comes
with some restrictions these have no practical con-
sequences whatsoever. Our implementation of the
logic as an extension to the ProFIT typed feature
formalism shows that a reasonably efficient imple-
mentation is feasible. Some further work is neces-
sary to determine the computational complexity
of our constraint solving procedure. However, we
believe that it is polynomial.
The logic presented in this paper generalises the
approach taken in (Reape, 1993). Our approach
demonstrates that it is not necessary to employ a
non-deterministic operation such as domain union
to manipulate domains. Instead precedence con-
straints are directly embedded in feature logic
and a deterministic constraint solving procedure
is provided. A wide range of constraints involv-
ing precedence is provided directly in feature logic
ranging from constraints expressing precedence be-
tween variables, precedence between domains to
guards on precedence constraints.
</bodyText>
<sectionHeader confidence="0.995658" genericHeader="acknowledgments">
9 Acknowledgments
</sectionHeader>
<bodyText confidence="0.999938846153846">
This work was supported by The Commission of
the European Communities through the project
LRE-61-061 &amp;quot;Reusable Grammatical Resources&amp;quot;,
where the logic described in this paper has been
implemented. Thanks to Wojciech Skut for devel-
oping sample grammars to test the implementa-
tion and for working on the interface to ProFIT.
Thanks to Gregor Erbach for demoing the ex-
tended system dubbed CL-ONE. Thanks to Her-
bert Ruessink and Craig Thiersch for using and
providing feedback on the implementation. And
thanks to Ralf Steinberger for providing useful
comments on an earlier draft.
</bodyText>
<sectionHeader confidence="0.998969" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999794859649123">
Hassan Ait-Kaci and Andreas Podelski. 1994. Func-
tions as Passive Constraints in LIFE. ACM Trans-
actions on Programming Languages and Systems,
16(4):1-40, July.
Hassan Ait-Kaci, Gert Smolka, and R. Treinen. 1992.
A feature-based constraint system for logic pro-
gramming with entailment. Research report, DFKI,
Saarbriicken, Germany.
Bob Carpenter. 1992. The Logic of Typed Feature
Structures. Cambridge University Press.
Gregor Erbach. 1995. ProFIT: Prolog with Features,
Inheritance and Templates. In Seventh Conference
of the EACL (This Vol.), Dublin, Ireland, March.
S. Hegner. 1991. Horn extended feature structures:
fast unification with negation and limited disjunc-
tion. In Fifth Conference of the EACL, pages 33-38,
Berlin, Germany.
Suresh Manandhar. 1993. Relational Extensions to
Feature Logic: Applications to Constraint Based
Grammars. Ph.D. thesis, Department of Artificial
Intelligence, University of Edinburgh.
Suresh Manandhar. 1994. An Attributive Logic of Set
Descriptions and Set Operations. In 32nd Annual
Meeting of the ACL, pages 255-262, Las Cruces,
New Mexico.
Carl Pollard and Ivan Andrew Sag. 1987.
Information-Based Syntax and Semantics: Volume
1 Fundamentals, volume 13 of Lecture Notes. CSLI,
Stanford, CA.
Carl Pollard and Ivan Andrew Sag. 1994. Head-driven
Phrase Structure Grammar. Chicago: University of
Chicago Press and Stanford: CSLI Publications.
Mike Reape. 1993. Getting Things in Order. In
Wietske Sijtsma and Arthur van Horck, editors,
Discontinuous Constituency. Berlin: Mouton de
Gruyte.
V. Saraswat and M. Rinard. 1990. Concurrent Con-
straint Programming. In Proceedings of the 7th
ACM Symposium on the Principles of Programming
Languages, pages 232-245, San Francisco, CA, Jan-
uary.
Vijay Saraswat. 1993. Concurrent Constraint Pro-
gramming. MIT Press.
Gert Smolka and Ralf Treinen. 1994. Records for
logic programming. Journal of Logic Programming,
18(3):229-258, April.
Gert Smolka. 1992. Feature constraint logics for uni-
fication grammars. Journal of Logic Programming,
12:51-87.
Ralf Steinberger. 1994. Treating &apos;Free Word Order&apos;
in Machine Translation. In Proceedings of COLING
1994, Vol. I, pages 69-75, Kyoto, Japan.
K. Ueda. 1985. Guarded Horn Clauses. Technical
Report TR-103, ICOT, Japan.
Hans Uszkoreit. 1985. Constraints on order. Tech-
nical Note 364, SRI International, 333 Ravenswood
Ave., Menlo Park, CA 94025, October.
</reference>
<page confidence="0.997882">
172
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.290938">
<title confidence="0.99785">Deterministic Consistency Checking of LP Constraints</title>
<author confidence="0.965581">Suresh Manandhar</author>
<affiliation confidence="0.998352">Language Technology Group Human Communication Research Centre</affiliation>
<address confidence="0.625733">University of Edinburgh, Scotland</address>
<email confidence="0.990443">Suresh.Manandhar@ed.ac.uk</email>
<abstract confidence="0.999429307692308">We provide a constraint based computational model of linear precedence as employed in the HPSG grammar formalism. An extended feature logic which adds a wide range of constraints involving precedence is described. A sound, complete and terminating deterministic constraint solving procedure is given. Deterministic computational model is achieved by weakening the logic such that it is sufficient for linguistic applications involving word-order.</abstract>
<note confidence="0.687747">Subject areas: feature logic, constraint based grammars</note>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Hassan Ait-Kaci</author>
<author>Andreas Podelski</author>
</authors>
<title>Functions as Passive Constraints in LIFE.</title>
<date>1994</date>
<journal>ACM Transactions on Programming Languages and Systems,</journal>
<pages>16--4</pages>
<contexts>
<context position="11879" citStr="Ait-Kaci and Podelski, 1994" startWordPosition="2132" endWordPosition="2136">ught of as adding guards to feature structures. On the other hand, within logic programming guarded logic programming languages have a longer history originating with committed-choice languages (Ueda, 1985) and popularised by the concurrent constraint programming paradigm due to Saraswat (Saraswat and Rinard, 1990) (Saraswat, 1993). For space reasons, we do not cover the logic of guarded feature constraints, guards on set membership constraints and guards on precedence constraints. Guarded feature constraints have been extensively studied in (Ait-Kaci et al., 1992) (Smolka and Treinen, 1994) (Ait-Kaci and Podelski, 1994). 4 A feature logic with LP constraints In this section we provide formal definitions for the syntax and semantics of an extended feature logic that directly supports linear precedence constraints as logical primitives. The logic described in this paper is a further development of the one described in (Manandhar, 1993). The syntax of the constraint language is defined by the following BNF definitions. Syntax Let .T be the set of relation symbols and let P be the set of irreflexive relation symbols. We shall require that .7. and P are disjoint. 0,0 x = f : y feature constraint x =3f : y set-mem</context>
</contexts>
<marker>Ait-Kaci, Podelski, 1994</marker>
<rawString>Hassan Ait-Kaci and Andreas Podelski. 1994. Functions as Passive Constraints in LIFE. ACM Transactions on Programming Languages and Systems, 16(4):1-40, July.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Hassan Ait-Kaci</author>
<author>Gert Smolka</author>
<author>R Treinen</author>
</authors>
<title>A feature-based constraint system for logic programming with entailment. Research report,</title>
<date>1992</date>
<location>DFKI, Saarbriicken, Germany.</location>
<contexts>
<context position="11822" citStr="Ait-Kaci et al., 1992" startWordPosition="2124" endWordPosition="2127">e structures described in (Hegner, 1991) can be thought of as adding guards to feature structures. On the other hand, within logic programming guarded logic programming languages have a longer history originating with committed-choice languages (Ueda, 1985) and popularised by the concurrent constraint programming paradigm due to Saraswat (Saraswat and Rinard, 1990) (Saraswat, 1993). For space reasons, we do not cover the logic of guarded feature constraints, guards on set membership constraints and guards on precedence constraints. Guarded feature constraints have been extensively studied in (Ait-Kaci et al., 1992) (Smolka and Treinen, 1994) (Ait-Kaci and Podelski, 1994). 4 A feature logic with LP constraints In this section we provide formal definitions for the syntax and semantics of an extended feature logic that directly supports linear precedence constraints as logical primitives. The logic described in this paper is a further development of the one described in (Manandhar, 1993). The syntax of the constraint language is defined by the following BNF definitions. Syntax Let .T be the set of relation symbols and let P be the set of irreflexive relation symbols. We shall require that .7. and P are dis</context>
</contexts>
<marker>Ait-Kaci, Smolka, Treinen, 1992</marker>
<rawString>Hassan Ait-Kaci, Gert Smolka, and R. Treinen. 1992. A feature-based constraint system for logic programming with entailment. Research report, DFKI, Saarbriicken, Germany.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Bob Carpenter</author>
</authors>
<title>The Logic of Typed Feature Structures.</title>
<date>1992</date>
<publisher>Cambridge University Press.</publisher>
<contexts>
<context position="17523" citStr="Carpenter, 1992" startWordPosition="3197" endWordPosition="3198">ve for implemented systems. On the other hand, we certainly cannot prohibit atoms since they are crucially required in grammar specification. But disallowing functional precedence is less problematic from a grammar development perspective. 4.2 Imposing the restriction We note that precedence can be restricted to nonatomic types such as HPSG signs without compromising the grammar in any way. We then need to ensure that precedence constraints never have to consider atoms as their values. This can be easily achieved within current typed feature formalisms by employing appropriateness conditions (Carpenter, 1992). An appropriateness condition just states that a given feature (in our case a relation) can only be defined on certain (appropriate) types. The assumption we make is that precedence is specified in such a way that is appropriate only for nonatomic types. This restriction can be imposed by the system (i.e. a typed feature formalism) itself. 5 Constraint Solving We are now ready to consider consistency checking rules for our constraint language. To simplify the presentation we have split up the rules into two groups given in figure 1 and figure 2. The constraint solving rules given in figure 1 </context>
</contexts>
<marker>Carpenter, 1992</marker>
<rawString>Bob Carpenter. 1992. The Logic of Typed Feature Structures. Cambridge University Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Gregor Erbach</author>
</authors>
<title>ProFIT: Prolog with Features, Inheritance and Templates.</title>
<date>1995</date>
<booktitle>In Seventh Conference of the EACL (This Vol.),</booktitle>
<location>Dublin, Ireland,</location>
<contexts>
<context position="3498" citStr="Erbach, 1995" startWordPosition="568" endWordPosition="570">g linear precedence that go well beyond what is available within current typed feature formalisms. Our approach is in the spirit of Reape&apos;s approach but improves upon it. Furthermore, a sound, complete and terminating consistency checking procedure is described. 165 Our constraint solving rules are deterministic and incremental. Hence these do not introduce costly choice-points. These constraint solving rules can be employed for building an efficient implementation. This is an important requirement for practical systems. Indeed we have successfully extended the ProFIT typed feature formalism (Erbach, 1995) with the constructs described in this paper. 2 Outline of an alternative approach To motivate our approach we start with an example on scrambling in German subordinate clauses. (4) daB er einen Mann in der Strafie laufen that he a man in the street walking sah. saw. that he saw a man walking in the street. (5) daB er in der StraBe einen Mann laufen sah. (6) daB einen Mann er in der .StraBe laufen sah. (7) daB einen Mann in der StraBe er laufen sah. (8) daB in der StraBe er einen Mann laufen sah. (9) daB in der StraBe einen Mann er laufen sah. The above data can be captured precisely if we can</context>
</contexts>
<marker>Erbach, 1995</marker>
<rawString>Gregor Erbach. 1995. ProFIT: Prolog with Features, Inheritance and Templates. In Seventh Conference of the EACL (This Vol.), Dublin, Ireland, March.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S Hegner</author>
</authors>
<title>Horn extended feature structures: fast unification with negation and limited disjunction.</title>
<date>1991</date>
<booktitle>In Fifth Conference of the EACL,</booktitle>
<pages>33--38</pages>
<location>Berlin, Germany.</location>
<contexts>
<context position="11240" citStr="Hegner, 1991" startWordPosition="2040" endWordPosition="2041">ther constraints. The condition part 167 G of a guarded constraint if G then S else T is known as a guard. The consequent S is executed if the current set of constraints entail the guard G. The consequent T is executed if the current set of constraints disentail the guard G. If the current set of constraints neither entail nor disentail G then the execution of the whole guarded constraint is blocked until more information is available. The application of guarded constraints within computational linguistics has not been well explored. However, the Horn extended feature structures described in (Hegner, 1991) can be thought of as adding guards to feature structures. On the other hand, within logic programming guarded logic programming languages have a longer history originating with committed-choice languages (Ueda, 1985) and popularised by the concurrent constraint programming paradigm due to Saraswat (Saraswat and Rinard, 1990) (Saraswat, 1993). For space reasons, we do not cover the logic of guarded feature constraints, guards on set membership constraints and guards on precedence constraints. Guarded feature constraints have been extensively studied in (Ait-Kaci et al., 1992) (Smolka and Trein</context>
</contexts>
<marker>Hegner, 1991</marker>
<rawString>S. Hegner. 1991. Horn extended feature structures: fast unification with negation and limited disjunction. In Fifth Conference of the EACL, pages 33-38, Berlin, Germany.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Suresh Manandhar</author>
</authors>
<title>Relational Extensions to Feature Logic: Applications to Constraint Based Grammars.</title>
<date>1993</date>
<tech>Ph.D. thesis,</tech>
<institution>Department of Artificial Intelligence, University of Edinburgh.</institution>
<contexts>
<context position="12199" citStr="Manandhar, 1993" startWordPosition="2186" endWordPosition="2187">). For space reasons, we do not cover the logic of guarded feature constraints, guards on set membership constraints and guards on precedence constraints. Guarded feature constraints have been extensively studied in (Ait-Kaci et al., 1992) (Smolka and Treinen, 1994) (Ait-Kaci and Podelski, 1994). 4 A feature logic with LP constraints In this section we provide formal definitions for the syntax and semantics of an extended feature logic that directly supports linear precedence constraints as logical primitives. The logic described in this paper is a further development of the one described in (Manandhar, 1993). The syntax of the constraint language is defined by the following BNF definitions. Syntax Let .T be the set of relation symbols and let P be the set of irreflexive relation symbols. We shall require that .7. and P are disjoint. 0,0 x = f : y feature constraint x =3f : y set-membership x = 3p+ : y transitive closure x =3p* : y reflex-trans closure x = f g(y) subset inclusion x = [f p first daughter f (x) : p+ : g(y) domain precedence f(x) : p* : g(y) domain prec. equals (i) &amp; conjunction where f E .T and p E P The constraint x = f : y specifies that y is the only f-value of x. The constraint </context>
</contexts>
<marker>Manandhar, 1993</marker>
<rawString>Suresh Manandhar. 1993. Relational Extensions to Feature Logic: Applications to Constraint Based Grammars. Ph.D. thesis, Department of Artificial Intelligence, University of Edinburgh.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Suresh Manandhar</author>
</authors>
<title>An Attributive Logic of Set Descriptions and Set Operations.</title>
<date>1994</date>
<booktitle>In 32nd Annual Meeting of the ACL,</booktitle>
<pages>255--262</pages>
<location>Las Cruces, New Mexico.</location>
<contexts>
<context position="5429" citStr="Manandhar, 1994" startWordPosition="940" endWordPosition="941">dom {lit} n 1/ &lt; v For space reasons, our treatment is necessarily somewhat superficial since we do not take into account other interacting phenomena such as fronting or extraposition. The definition in (11) does not make specific assumption about whether a context-free backbone is employed or not. However, if a CFG backbone is employed then we assume that the value of the subcat attribute is treated as an unordered sequence (i.e. a set) as defined in (11). (12) NPdom V Vidom vi The essential idea is to use set-valued descriptions to model word-order domains. In particular subset constraints (Manandhar, 1994) are employed to construct larger domains from smaller ones. Thus in example (11) the domain of the verb is constructed by including the domains of the subcategorised arguments (enforced by the constraints dom :3 N Pdomil dom :3 ViDom). Note that in this example the verb itself is not part of its own domain. The binary constraint V, &lt; V enforces precedence ordering between the signs V, and V. The constraint V idom &lt; dom {V} ensures that every element of the set V iDom precedes the sign V. In other words, the set V iDorn is in the domain precedence relation with the singleton {V}. However there</context>
</contexts>
<marker>Manandhar, 1994</marker>
<rawString>Suresh Manandhar. 1994. An Attributive Logic of Set Descriptions and Set Operations. In 32nd Annual Meeting of the ACL, pages 255-262, Las Cruces, New Mexico.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Carl Pollard</author>
<author>Ivan Andrew Sag</author>
</authors>
<title>Information-Based Syntax and Semantics:</title>
<date>1987</date>
<volume>1</volume>
<location>CSLI, Stanford, CA.</location>
<contexts>
<context position="761" citStr="Pollard and Sag, 1987" startWordPosition="99" endWordPosition="102">ity of Edinburgh, Scotland email: Suresh.Manandhar@ed.ac.uk Abstract We provide a constraint based computational model of linear precedence as employed in the HPSG grammar formalism. An extended feature logic which adds a wide range of constraints involving precedence is described. A sound, complete and terminating deterministic constraint solving procedure is given. Deterministic computational model is achieved by weakening the logic such that it is sufficient for linguistic applications involving word-order. Subject areas: feature logic, constraint based grammars 1 Introduction Within HPSG (Pollard and Sag, 1987) (Pollard and Sag, 1994) the constituent ordering principle given in (1) is intended to express the relation between the value of the PHON attribute and the DTRS attribute which contains the hierarchical structure of the derivation. (1) phrasal_sign = PHON order_constituentC) DTRS n (2) Linear Precedence Constraint 1 (LP1): HEAD[LEX+] &lt; [] However, it is not entirely clear how order_constituent is supposed to interpret various linear precedence statements such as LP1. 1.1 Reape&apos;s approach The idea taken in Reape&apos;s approach (Reape, 1993) is to suggest that word-order is enforced between locally</context>
</contexts>
<marker>Pollard, Sag, 1987</marker>
<rawString>Carl Pollard and Ivan Andrew Sag. 1987. Information-Based Syntax and Semantics: Volume 1 Fundamentals, volume 13 of Lecture Notes. CSLI, Stanford, CA.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Carl Pollard</author>
<author>Ivan Andrew Sag</author>
</authors>
<title>Head-driven Phrase Structure Grammar. Chicago: University of Chicago Press and Stanford:</title>
<date>1994</date>
<publisher>CSLI Publications.</publisher>
<contexts>
<context position="785" citStr="Pollard and Sag, 1994" startWordPosition="103" endWordPosition="106">nd email: Suresh.Manandhar@ed.ac.uk Abstract We provide a constraint based computational model of linear precedence as employed in the HPSG grammar formalism. An extended feature logic which adds a wide range of constraints involving precedence is described. A sound, complete and terminating deterministic constraint solving procedure is given. Deterministic computational model is achieved by weakening the logic such that it is sufficient for linguistic applications involving word-order. Subject areas: feature logic, constraint based grammars 1 Introduction Within HPSG (Pollard and Sag, 1987) (Pollard and Sag, 1994) the constituent ordering principle given in (1) is intended to express the relation between the value of the PHON attribute and the DTRS attribute which contains the hierarchical structure of the derivation. (1) phrasal_sign = PHON order_constituentC) DTRS n (2) Linear Precedence Constraint 1 (LP1): HEAD[LEX+] &lt; [] However, it is not entirely clear how order_constituent is supposed to interpret various linear precedence statements such as LP1. 1.1 Reape&apos;s approach The idea taken in Reape&apos;s approach (Reape, 1993) is to suggest that word-order is enforced between locally definable word order do</context>
</contexts>
<marker>Pollard, Sag, 1994</marker>
<rawString>Carl Pollard and Ivan Andrew Sag. 1994. Head-driven Phrase Structure Grammar. Chicago: University of Chicago Press and Stanford: CSLI Publications.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Mike Reape</author>
</authors>
<title>Getting Things in Order.</title>
<date>1993</date>
<booktitle>In Wietske Sijtsma and Arthur van Horck, editors, Discontinuous Constituency.</booktitle>
<location>Berlin: Mouton</location>
<note>de Gruyte.</note>
<contexts>
<context position="1303" citStr="Reape, 1993" startWordPosition="186" endWordPosition="187">aint based grammars 1 Introduction Within HPSG (Pollard and Sag, 1987) (Pollard and Sag, 1994) the constituent ordering principle given in (1) is intended to express the relation between the value of the PHON attribute and the DTRS attribute which contains the hierarchical structure of the derivation. (1) phrasal_sign = PHON order_constituentC) DTRS n (2) Linear Precedence Constraint 1 (LP1): HEAD[LEX+] &lt; [] However, it is not entirely clear how order_constituent is supposed to interpret various linear precedence statements such as LP1. 1.1 Reape&apos;s approach The idea taken in Reape&apos;s approach (Reape, 1993) is to suggest that word-order is enforced between locally definable word order domains which are ordered sequences of constituents. Word order domains in Reape&apos;s approach are totally ordered sequences. A domain union operation as given in (3) is then employed to construct word order domains locally within a HPSG derivation step. (3) 0(7/,7i,n). (31(x o o- 3) 44 C)(o-,,o.„0-3). C)(o-,,xoa„x 0 (73) 44 C)(o-,,a2,a-3). If A is the string &lt; a,b &gt; and B is the string &lt;c, d&gt;, their domain union C given by 0(A, B, C) will produce all the sequences in which a precedes b and c precedes d i.e. the follo</context>
<context position="25582" citStr="Reape, 1993" startWordPosition="4709" endWordPosition="4710">recedence can be handled elegantly and deterministically by adding new logical primitives to feature logic. Although, theoretically speaking, our logic comes with some restrictions these have no practical consequences whatsoever. Our implementation of the logic as an extension to the ProFIT typed feature formalism shows that a reasonably efficient implementation is feasible. Some further work is necessary to determine the computational complexity of our constraint solving procedure. However, we believe that it is polynomial. The logic presented in this paper generalises the approach taken in (Reape, 1993). Our approach demonstrates that it is not necessary to employ a non-deterministic operation such as domain union to manipulate domains. Instead precedence constraints are directly embedded in feature logic and a deterministic constraint solving procedure is provided. A wide range of constraints involving precedence is provided directly in feature logic ranging from constraints expressing precedence between variables, precedence between domains to guards on precedence constraints. 9 Acknowledgments This work was supported by The Commission of the European Communities through the project LRE-61</context>
</contexts>
<marker>Reape, 1993</marker>
<rawString>Mike Reape. 1993. Getting Things in Order. In Wietske Sijtsma and Arthur van Horck, editors, Discontinuous Constituency. Berlin: Mouton de Gruyte.</rawString>
</citation>
<citation valid="true">
<authors>
<author>V Saraswat</author>
<author>M Rinard</author>
</authors>
<title>Concurrent Constraint Programming.</title>
<date>1990</date>
<booktitle>In Proceedings of the 7th ACM Symposium on the Principles of Programming Languages,</booktitle>
<pages>232--245</pages>
<location>San Francisco, CA,</location>
<contexts>
<context position="11567" citStr="Saraswat and Rinard, 1990" startWordPosition="2085" endWordPosition="2088">her entail nor disentail G then the execution of the whole guarded constraint is blocked until more information is available. The application of guarded constraints within computational linguistics has not been well explored. However, the Horn extended feature structures described in (Hegner, 1991) can be thought of as adding guards to feature structures. On the other hand, within logic programming guarded logic programming languages have a longer history originating with committed-choice languages (Ueda, 1985) and popularised by the concurrent constraint programming paradigm due to Saraswat (Saraswat and Rinard, 1990) (Saraswat, 1993). For space reasons, we do not cover the logic of guarded feature constraints, guards on set membership constraints and guards on precedence constraints. Guarded feature constraints have been extensively studied in (Ait-Kaci et al., 1992) (Smolka and Treinen, 1994) (Ait-Kaci and Podelski, 1994). 4 A feature logic with LP constraints In this section we provide formal definitions for the syntax and semantics of an extended feature logic that directly supports linear precedence constraints as logical primitives. The logic described in this paper is a further development of the on</context>
</contexts>
<marker>Saraswat, Rinard, 1990</marker>
<rawString>V. Saraswat and M. Rinard. 1990. Concurrent Constraint Programming. In Proceedings of the 7th ACM Symposium on the Principles of Programming Languages, pages 232-245, San Francisco, CA, January.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Vijay Saraswat</author>
</authors>
<title>Concurrent Constraint Programming.</title>
<date>1993</date>
<publisher>MIT Press.</publisher>
<contexts>
<context position="11584" citStr="Saraswat, 1993" startWordPosition="2089" endWordPosition="2090">hen the execution of the whole guarded constraint is blocked until more information is available. The application of guarded constraints within computational linguistics has not been well explored. However, the Horn extended feature structures described in (Hegner, 1991) can be thought of as adding guards to feature structures. On the other hand, within logic programming guarded logic programming languages have a longer history originating with committed-choice languages (Ueda, 1985) and popularised by the concurrent constraint programming paradigm due to Saraswat (Saraswat and Rinard, 1990) (Saraswat, 1993). For space reasons, we do not cover the logic of guarded feature constraints, guards on set membership constraints and guards on precedence constraints. Guarded feature constraints have been extensively studied in (Ait-Kaci et al., 1992) (Smolka and Treinen, 1994) (Ait-Kaci and Podelski, 1994). 4 A feature logic with LP constraints In this section we provide formal definitions for the syntax and semantics of an extended feature logic that directly supports linear precedence constraints as logical primitives. The logic described in this paper is a further development of the one described in (M</context>
</contexts>
<marker>Saraswat, 1993</marker>
<rawString>Vijay Saraswat. 1993. Concurrent Constraint Programming. MIT Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Gert Smolka</author>
<author>Ralf Treinen</author>
</authors>
<title>Records for logic programming.</title>
<date>1994</date>
<journal>Journal of Logic Programming,</journal>
<pages>18--3</pages>
<contexts>
<context position="11849" citStr="Smolka and Treinen, 1994" startWordPosition="2128" endWordPosition="2131">n (Hegner, 1991) can be thought of as adding guards to feature structures. On the other hand, within logic programming guarded logic programming languages have a longer history originating with committed-choice languages (Ueda, 1985) and popularised by the concurrent constraint programming paradigm due to Saraswat (Saraswat and Rinard, 1990) (Saraswat, 1993). For space reasons, we do not cover the logic of guarded feature constraints, guards on set membership constraints and guards on precedence constraints. Guarded feature constraints have been extensively studied in (Ait-Kaci et al., 1992) (Smolka and Treinen, 1994) (Ait-Kaci and Podelski, 1994). 4 A feature logic with LP constraints In this section we provide formal definitions for the syntax and semantics of an extended feature logic that directly supports linear precedence constraints as logical primitives. The logic described in this paper is a further development of the one described in (Manandhar, 1993). The syntax of the constraint language is defined by the following BNF definitions. Syntax Let .T be the set of relation symbols and let P be the set of irreflexive relation symbols. We shall require that .7. and P are disjoint. 0,0 x = f : y featur</context>
</contexts>
<marker>Smolka, Treinen, 1994</marker>
<rawString>Gert Smolka and Ralf Treinen. 1994. Records for logic programming. Journal of Logic Programming, 18(3):229-258, April.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Gert Smolka</author>
</authors>
<title>Feature constraint logics for unification grammars.</title>
<date>1992</date>
<journal>Journal of Logic Programming,</journal>
<pages>12--51</pages>
<contexts>
<context position="13914" citStr="Smolka, 1992" startWordPosition="2527" endWordPosition="2528">mits x and y to be equal. The constraints f (x) : p+ : g(y) and f (x) : p* : g(y) are intended to enforce precedence between two word-ordering domains. The constraint f (x) : p+ : g(y) states that every f-value of x precedes (i.e. is in the p+ relation with) every g-value of p. The constraint f (x) : p* : g(y) is analogous. The constraint x = {f p l}y states that y is the first daughter amongst the f-values of x (i.e. is in the p* relation with every f-value of x). Since our language supports both feature constraints and set-membership constraints the conventional semantics for feature logic (Smolka, 1992) needs to be extended. The essential difference being that we interpret every feature/relation as a binary relation on the domain of interpretation. Feature constraints then require that they behave functionally on the variable upon which the constraint is expressed. A precise semantics of our constraint language is given next. Semantics An interpretation structure I =&lt; /41, ./ &gt; is a structure such that: • Li/ is an arbitrary non-empty set • ./ is an interpretation function which maps: — every relation f E Y to a binary relation: fi C x 241 — every relation p E P to a binary relation: 131 c x</context>
<context position="18282" citStr="Smolka, 1992" startWordPosition="3321" endWordPosition="3322">ssumption we make is that precedence is specified in such a way that is appropriate only for nonatomic types. This restriction can be imposed by the system (i.e. a typed feature formalism) itself. 5 Constraint Solving We are now ready to consider consistency checking rules for our constraint language. To simplify the presentation we have split up the rules into two groups given in figure 1 and figure 2. The constraint solving rules given in figure 1 deal with constraints involving features, setmemberships, subset and first daughter. Rules (Equals) and (Feat) are the usual feature logic rules (Smolka, 1992) that deal with equality and features. By [x/y)Cs we mean replacing every occurrence of x with y in Cs. Rule (FeatEx169 =-- 3p* :yAx= 3p+ : y A Cs (TransConj) x =3p+ : y A Cs (TransClos) x = 3R1 : y A y = 3112 : z A C, x (R, x R2) : zA x -= 3R, : y A y = 3R2 : z A C, if x = 3p+ : z CsA x -= 3(R, x R2) : z V C where R, x 172 is computed from: x p* p+ PS P* 13+ P+ 13+ /3+ Figure 2: Constraint Solving - II ists) deals with the interaction of feature and set-membership constraint. Rule (Subset) deals with subset constraints and adds a new constraint x = 3f : y in the presence of the subset constra</context>
</contexts>
<marker>Smolka, 1992</marker>
<rawString>Gert Smolka. 1992. Feature constraint logics for unification grammars. Journal of Logic Programming, 12:51-87.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ralf Steinberger</author>
</authors>
<title>Treating &apos;Free Word Order&apos; in Machine Translation.</title>
<date>1994</date>
<booktitle>In Proceedings of COLING</booktitle>
<volume>Vol. I,</volume>
<pages>69--75</pages>
<location>Kyoto, Japan.</location>
<contexts>
<context position="6847" citStr="Steinberger, 1994" startWordPosition="1201" endWordPosition="1202">cal. (13) *daB in der StraBe ihn er laufen sah. According to Uszkoreit (Uszkoreit, 1985), ordering of arguments in the middle field is governed by the following set of LP constraints given in (14) which are to be interpreted disjunctively. (14) PPRN : &lt; PPRN : — T R : agent &lt; TR: theme TR : agent &lt; TR: goal TR : goal &lt; TR: theme FOCUS: — &lt; FOCUS : The LP constraint in (14) states that for every pair of constituents in the middle field at least one of the conditions should apply otherwise the sentence is considered ungrammatical. A related but more elaborate LP rule mechanism is considered in (Steinberger, 1994). sah 166 To approximate this complex LP constraint employing the kind of logical machinery described in this paper, we can use a description such as the one given in (15). The definition given in (15) extends the description given in (11). (15) syn: dom : MF 11 3x3yif xEMFAyEMFAx&lt;y then if x = pprn : + A y = pprn : — then T else if x = tr : agent A y = tr : theme then T else if x = tr : agent A y = tr : goal then T else if x = tr : goal A y = tr : theme then T else x= focus: —Ayr-- f ocus : + The definition in (15) can be understood as follows. The feature constraint syn : darn : MF coinstant</context>
</contexts>
<marker>Steinberger, 1994</marker>
<rawString>Ralf Steinberger. 1994. Treating &apos;Free Word Order&apos; in Machine Translation. In Proceedings of COLING 1994, Vol. I, pages 69-75, Kyoto, Japan.</rawString>
</citation>
<citation valid="true">
<authors>
<author>K Ueda</author>
</authors>
<title>Guarded Horn Clauses.</title>
<date>1985</date>
<tech>Technical Report TR-103, ICOT,</tech>
<contexts>
<context position="11457" citStr="Ueda, 1985" startWordPosition="2072" endWordPosition="2073">if the current set of constraints disentail the guard G. If the current set of constraints neither entail nor disentail G then the execution of the whole guarded constraint is blocked until more information is available. The application of guarded constraints within computational linguistics has not been well explored. However, the Horn extended feature structures described in (Hegner, 1991) can be thought of as adding guards to feature structures. On the other hand, within logic programming guarded logic programming languages have a longer history originating with committed-choice languages (Ueda, 1985) and popularised by the concurrent constraint programming paradigm due to Saraswat (Saraswat and Rinard, 1990) (Saraswat, 1993). For space reasons, we do not cover the logic of guarded feature constraints, guards on set membership constraints and guards on precedence constraints. Guarded feature constraints have been extensively studied in (Ait-Kaci et al., 1992) (Smolka and Treinen, 1994) (Ait-Kaci and Podelski, 1994). 4 A feature logic with LP constraints In this section we provide formal definitions for the syntax and semantics of an extended feature logic that directly supports linear prec</context>
</contexts>
<marker>Ueda, 1985</marker>
<rawString>K. Ueda. 1985. Guarded Horn Clauses. Technical Report TR-103, ICOT, Japan.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Hans Uszkoreit</author>
</authors>
<title>Constraints on order.</title>
<date>1985</date>
<booktitle>Technical Note 364, SRI International, 333 Ravenswood Ave.,</booktitle>
<location>Menlo Park, CA 94025,</location>
<contexts>
<context position="6317" citStr="Uszkoreit, 1985" startWordPosition="1100" endWordPosition="1101">itself is not part of its own domain. The binary constraint V, &lt; V enforces precedence ordering between the signs V, and V. The constraint V idom &lt; dom {V} ensures that every element of the set V iDom precedes the sign V. In other words, the set V iDorn is in the domain precedence relation with the singleton {V}. However there are strong constraints on ordering in the middle field. For instance, when pronomia1 complements are involved then not all permutations are acceptable. Examples such as (13) are considered ungrammatical. (13) *daB in der StraBe ihn er laufen sah. According to Uszkoreit (Uszkoreit, 1985), ordering of arguments in the middle field is governed by the following set of LP constraints given in (14) which are to be interpreted disjunctively. (14) PPRN : &lt; PPRN : — T R : agent &lt; TR: theme TR : agent &lt; TR: goal TR : goal &lt; TR: theme FOCUS: — &lt; FOCUS : The LP constraint in (14) states that for every pair of constituents in the middle field at least one of the conditions should apply otherwise the sentence is considered ungrammatical. A related but more elaborate LP rule mechanism is considered in (Steinberger, 1994). sah 166 To approximate this complex LP constraint employing the kind</context>
</contexts>
<marker>Uszkoreit, 1985</marker>
<rawString>Hans Uszkoreit. 1985. Constraints on order. Technical Note 364, SRI International, 333 Ravenswood Ave., Menlo Park, CA 94025, October.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>