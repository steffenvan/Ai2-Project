<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<title confidence="0.99744">
A Language for the Statement of Binary Relations
over Feature Structures
</title>
<note confidence="0.843584333333333">
Graham Russell Afzal Ballim Dominique Estival Susan Warwick-Armstrong
ISSCO, 54 rte. des Acacias
1227 Geneva, Switzerland
</note>
<email confidence="0.986495">
elu@divsun.unige.ch
</email>
<sectionHeader confidence="0.972317" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999396333333333">
Unification is often the appropriate method for
expressing relations between representations in
the form of feature structures; however, there
are circumstances in which a different
approach is desirable. A declarative formalism
is presented which permits direct mappings of
one feature structure into another, and illustra-
tive examples are given of its application to
areas of current interest.
</bodyText>
<sectionHeader confidence="0.990366" genericHeader="keywords">
1. Introduction
</sectionHeader>
<bodyText confidence="0.998669909090909">
Benefits arising from the adoption of
unification as a tool in computational linguis-
tics are well known: a declarative, monotonic
method of combining partial information
expressed in data structures convenient for
linguistic applications permits the writing of
sensible grammars that can be made indepen-
dent from processing mechanisms, and a grow-
ing familiarity, in both theoretical and compu-
tational circles, with the techniques of
unification fosters fruitful interchange of ideas
and experiences. There are, however, occa-
sions when unification alone is not an
appropriate tool. In essence, unification is a
ternary relation in which two structures, when
merged, form a third; it is less attractive in cir-
cumstances where the relation to be expressed
is binary — when one would like to manipulate
a single feature structure (FS), perhaps simu-
lating the direct transformation of one FS into
another.1 The present paper introduces a
declarative formalism intended for the expres-
sion of such relations, and shows how it may
be applied to some areas of current interest.
The formalism in question is based upon a
notion of &apos;transfer rule&apos;; informally, a set of
such rules may be considered as characterizing
We are indebted to Jacques Jayez for comments on an
earlier draft of this paper.
I Clearly there is a sense in which such relations can
be viewed as ternary: T(Fi , R, F2), where 1:11 and F2 are
FSs, and R is the rule set which relates them.
a binary relation over a set of feature struc-
tures, the properties of that relation depending
on the content of the particular rule set in use.
Transfer rules associate the analysis of one FS
with the synthesis of another; they may be
thought of as a specialized variety of pattern-
matching rule. They are local in nature, and
permit the recursive analysis and synthesis of
complex structures according to patterns
specified in a format closely related to that
widely employed in unification-based compu-
tational linguistics. Indeed, the interpretation
of transfer rules involves unification, albeit in a
context which restricts it to the role of a
structure-building operation.2
In the remainder of this paper we provide a
brief specification of the transfer rule formal-
ism, discuss its interpretation, outline two
alternative rule application regimes, and illus-
trate the use of the formalism in the areas of
machine translation and reduction of FSs to
canonical form. We conclude with an over-
view of continuing strands of research.
</bodyText>
<subsectionHeader confidence="0.6447345">
2. Rule Format and Interpretation
2.1. General Remarks
</subsectionHeader>
<bodyText confidence="0.874071">
A transfer rule consists of four parts:
</bodyText>
<listItem confidence="0.7310124">
(i) a rule name;3
(ii) a set of constraint equations describing a
FS;
(iii) a set of constraint equations describing a
FS;4
</listItem>
<bodyText confidence="0.956575681818182">
2 The rule formalism is thus monotonic, being unable
to effect changes in the input representation, and con-
structing the output by means of unification.
3 The rule name plays no part in the interpretation of
rules, but provides a convenient reference for tracing
their ordering and application.
4 The equations in each of (ii) and (iii) must be
uniquely rooted. The current implementation disallows
disjunction in the equation sets for this reason.
- 287 -
(iv) a (possibly empty) set of &apos;transfer
correspondence statements&apos; — equations
describing transfer correspondences that
must hold between variable bindings esta-
blished in (ii) and
A transfer rule relates the two FSs it describes
either directly or indirectly, via the rule&apos;s
transfer correspondence statements; in order
for the relation to hold between the source and
destination FS, it must hold between the FSs to
which any transfer-variables are bound. An
example of a transfer rule is given below:
</bodyText>
<equation confidence="0.980979571428571">
:T: example-1
:Ll: &lt;* a b&gt; = XI
&lt;* c d&gt; = Y1
:L2: &lt;* p q&gt; = X2
&lt;* p r&gt; = Y2
:X: X1 &lt;=&gt; X2
Yl &lt;=&gt; Y2
</equation>
<bodyText confidence="0.989017">
This rule establishes a correspondence between
the two feature structures shown below, (1)
being the FS described by the equations under
&apos;Li&apos; and (2) by those under 1.2&apos;:
a b Xl]
(i) [c d Y1
The correspondence is licensed provisionally
for this FS pair by &amp;quot;example-1&amp;quot;; it is licensed
absolutely for a pair of FSs (1&apos;) and (2&apos;) having
the same root as (1) and (2) respectively only
if:
</bodyText>
<listItem confidence="0.529394428571429">
(i) (1&apos;) contains sub-FSs a unified with X1
and f unified with Y1 in (1),
(ii) (2&apos;) contains sub-FSs y unified with X2
and 8 unified with Y2 in (2), and
(iii) the same type of correspondence is
licensed, possibly by some other rule,
between a and y and between /3 and 8.
</listItem>
<bodyText confidence="0.99968585">
Complex FSs are analysed and constructed
recursively as a result of the passage of control
through transfer variables.
In the abstract, transfer rules have no
inherent directionality; the two FSs above may
be visualized interchangeably as input and out-
put, or &apos;source&apos; and &apos;destination&apos;. When com-
piled for a particular application, however,
they are interpreted directionally, the domain
of the transfer relation being collectively
characterized by the equation sets labelled &apos;Li&apos;
and the range by those labelled 1.2&apos;, or vice
versa. One may then think of compiled
transfer rules as having a &apos;left-hand&apos; or &apos;input&apos;
and a `right-hand&apos; or &apos;output&apos; side, the former
describing a source FS and the latter a destina-
tion FS. We shall use these terms freely in
contexts where directionality is at issue, and
assume that the rules have been compiled
accordingly.
</bodyText>
<subsectionHeader confidence="0.916575">
2.2. Interpretation
</subsectionHeader>
<bodyText confidence="0.9913567">
The relation of transfer between a source FS E
and a destination FS A is defined recursively in
terms of the quintuple ( R, (Dx(R), clop(R),
T(R), 19(E)), where R is a rule, eox,(R) and
(R) are, respectively, the FSs induced by the
left-hand and right-hand equation sets in R,
T(R) is the set of transfer correspondence
statements in R, and Eil(E) is the result of con-
verting. any path-final variables in E to con-
stants:
</bodyText>
<sectionHeader confidence="0.549011" genericHeader="introduction">
3
</sectionHeader>
<bodyText confidence="0.906369885714286">
E stands in the transfer relation to A with
respect to R iff:
(i) fh(R) subsumes 8(E), and
(ii) Op(R) unifies with A, and
(iii) for each t e T(R), the sub-FSs of E and A
unifying with the transfer variables men-
tioned in t stand in the transfer relation
with respect to some rule in the currently
accessible rule set.
The first clause of this definition states the con-
dition under which a rule is a candidate for
application to a given input FS. The second
states the condition under which a rule is a
candidate for application to a given output FS.
Note that the operations differ; whereas the
matching in (i) is based on subsumption, the
action in (ii) employs unification. As a conse-
quence, the FS ItIop(R) is added to the output FS
A. The third clause imposes the further condi-
tion that, in order for E and A to be related by
R, any FSs they contain which are explicitly
connected via variable binding and a transfer
correspondence statement in T(R) are also
related.
As will be seen from clause (iii) of the
definition, a complex FS is traversed from root
to terminals, control being passed via variables
in transfer equations, and the extent of each
sub-transfer (i.e. how much of the input FS is
consumed at each stage) being determined by
5 It may well be the case that, in certain applications
or environments, source FSs will not contain such vari-
ables; the possibility must be acknowledged nevertheless,
since non-declarative rule interactions may otherwise oc-
cur.
</bodyText>
<equation confidence="0.96985525">
(2) [P [q
r
X2Y2]
- 288 -
</equation>
<bodyText confidence="0.985539166666667">
the path specifications in the left-hand side
equation set of the currently active rule. Possi-
ble paths through the FS from a given point are
determined collectively by the left-hand side
equations of all rules, together with their
transfer correspondence statements.
Because FSs are finite and acyclic, termina-
tion is guaranteed as long as there is no rule of
the form shown below. This is able to apply
(in the &apos;Ll —+ L2&apos; direction — we ignore the
converse) without consuming part of the
source FS:
</bodyText>
<equation confidence="0.386672">
:T: infinite-recursion
:Ll: &lt;*&gt; = X
:L2: ...
:X: X &lt;=&gt; Y
</equation>
<bodyText confidence="0.999596866666667">
Coherence of a destination FS with respect to a
source FS and a set of transfer rules is ensured
by the formalism; material can only be intro-
duced into a destination FS by the right-hand
side of transfer rules which have successfully
applied. Completeness, on the other hand,
must be verified explicitly; every part of the
source FS must be subsumed by a subpart of
the FS obtained by unifying the FSs induced
by the left-hand side patterns of every rules
that has successfully applied. In the current
implementation, it is possible to declare that
certain subparts of a source FS are not to be
transferred; in this case, it is the remainder of
that FS which must be covered by the rules.
</bodyText>
<sectionHeader confidence="0.57394" genericHeader="method">
3. Applications of the Formalism
</sectionHeader>
<bodyText confidence="0.999631555555556">
We now illustrate how the transfer rule formal-
ism may be exploited, and indicate briefly how
the rule invocation regime may vary. The
machine translation example in the following
section assumes parallel invocation of the rule
set, while that involving reductions to canoni-
cal form seems most amenable to the serial
invocation of individual rules or subsets of
rules.
</bodyText>
<subsectionHeader confidence="0.981854">
3.1. Machine Translation
</subsectionHeader>
<bodyText confidence="0.995113764705882">
Perhaps the most obvious application for the
formalism presented here lies in the domain of
machine translation. The transfer model of
MT may be thought of as involving three dis-
tinct mappings; from the source language
expression to a source linguistic representa-
tion, from the source representation to a target
representation, and from this to an expression
in the target language. The first and last of
these are to be performed by parsing and gen-
eration with natural language grammars, but,
while proposals have been made to combine
some of the three stages (e.g. Kaplan et al.,
1989), there are advantages in treating the
intermediate, transfer, stage independently.
As an example, consider the FSs shown
below:6
</bodyText>
<table confidence="0.750449125">
[
(3) sem pied schwimmen
args (&lt;1&gt; sem pied Maria)
mod sem pied gem
(4) sem pied aimer
args (&lt;1&gt; sem Fed Maria,
&lt;2&gt; sem [pied nagel
args ( #1 ) )
</table>
<bodyText confidence="0.9737189375">
(3) and (4) are possible representations for the
German sentence Maria schwimmt gem, and
the French sentence Maria aime nager, both of
which might translate into English as &apos;Maria
likes swimming&apos;. Note that, whereas (3) has
the predicate which translates &apos;swim&apos; at the top
level, and contains a modifier gem n which
might be glossed as &apos;gladly&apos;, (4) embeds the
&apos;swim&apos; predicate within an argument to the
main predicate aimer &apos;like&apos;, and links the first
argument of aimer to the first argument of
nager by means of a re-entrancy.7
The set of rules given below together estab-
lish a transfer relation between (3) and (4):8
6 Note the use of a list, indicated by &apos;(...)&apos;,to encode
argiunents in these FSs, the identification of elements on
such a list by e.g. &lt;l&gt;&apos;, and re-entrancy flagged by V&apos;.
7 Clearly, one could employ a similar analysis for the
German sentence by making gent an &apos;equi&apos; predicate like
aimer — this would amount to simplifying transfer by
shifting complexity from the transfer rules into the Ger-
man grammar.
8 This is not quite true; the variables &apos;Tr and &apos;Tg&apos; in
the rule &amp;quot;gern-aimer&amp;quot; will bind to lists (the empty list in
this case), and we therefore require additional generic
list-transfer rules that will have the effect of passing
through a list, recursively transferring heads and tails.
Implementations for systems that lack the list data type
will naturally be able to dispense with this. In addition,
the lexical transfer rules assume the presence in the
current set of a rule consuming the &apos;&lt;* sem pred &gt;&apos;
paths terminating in Paul and Maria.
</bodyText>
<table confidence="0.958661523809524">
- 289 -
:TA:Paul Paul
:TA: Maria Maria
:T: schwimmen-nager
:Ll: &lt;* sem pred&gt; = schwimmen
&lt;* sem args&gt; = [Xg]
:L2: &lt;* sem pred&gt; = nager
&lt;* sem args&gt; = [Xf]
:X: Xg &lt;=&gt; Xf
:T: gem-aimer
:Ll: &lt;* sem pred&gt; = Rg
&lt;* sem args&gt; = [AgITg]
&lt;* sem mod sem pred&gt; = gem
:L2: &lt;* sem pred&gt; = aimer
&lt;* sem args&gt; = [Af,Vf]
&lt;* sem args&gt; = [Af,Vf]
&lt;Vf sem args&gt; = [AflTf]
:X: Rg &lt;=&gt; Rf
Ag &lt;=&gt; Af
Tg &lt;=&gt; Tf
&lt;Vf sem pred&gt; = Rf
</table>
<bodyText confidence="0.933037571428572">
The pair of rules Paul Paul&apos; and
Maria Maria&apos; are &apos;lexical transfer rules&apos;;
they state a transfer relation between atomic
FSs (i.e. words, in the context of MT), rather
than complex ones, and, further, do so without
reference to the context of these FSs. They are
equivalent to e.g.
</bodyText>
<figure confidence="0.30963475">
:T: Maria Maria
:Ll: &lt;*&gt; = Maria
:L2: &lt;*&gt; = Maria
:X: -
</figure>
<bodyText confidence="0.991965333333333">
The re-entrancy in FS (4), in which the first
argument associated with the predicate aimer
is also the argument associated with the
embedded predicate nager, is of some interest
in connection with transfer. Taking (4) as the
source, application of &amp;quot;gem-aimer&amp;quot; results in
the binding of both instances of the variable
&apos;AI&apos; to the sub-FS indexed as &apos;&lt;1&gt; which is
subject to the relevant transfer correspondence
statement and whose corresponding destination
sub-FS (in this case identical) will be present
in the overall destination FS as the first ele-
ment on the argument list of schwimmen. Rev-
ersing the direction, with (3) as the source, the
variable &apos;Ag&apos; is bound to the sub-FS indexed
as &apos;&lt;1&gt;&apos;, whose corresponding destination
sub-FS is similarly present in the overall desti-
nation FS, this time as the first element in both
argument lists, and, moreover, owing to the
identity of variables in &amp;quot;gem-aimer&amp;quot;, unified
rather than duplicated. Re-entrancy may thus
be detected in the source FS and created in the
destination; naturally, responsibility for
correctly analysing structures containing re-
entrancies, and enforcing them where desired
in output structures, lies with the writer of
transfer rules.
</bodyText>
<subsectionHeader confidence="0.965844">
3.2. Reduction to Canonical Form
</subsectionHeader>
<bodyText confidence="0.999943333333334">
It is often the case that a grammar assigns just
one of a range of logically equivalent represen-
tations to a sentence; designers of grammars
for use in analysis generally take care to ensure
that the result of parsing a non-ambiguous sen-
tence is a unique semantic representation, and
multiple representations are seen as the hall-
mark of (pre-theoretical) ambiguity. In gen-
eration, as Shieber (1988) and Appelt (1989)
observe, a situation may arise in which the
representation supplied as input to the process
(perhaps by another program) is not itself
directly suitable, but is logically equivalent to
one that is. The use of distinct grammars for
parsing and generation could provide a solu-
tion to this problem, but it raises others con-
nected with management of the resulting sys-
tem. An alternative is to define equivalence
classes of representations, and reduce all
members of a class to the single canonical
form which the grammar can map into a sen-
tence. Exactly how the classes and reductions
are defined will doubtless depend on many fac-
tors; we consider here some of the standard
logical equivalences exploited in reducing
arbitrary expressions of the propositional cal-
culus to disjunctive normal form.
</bodyText>
<table confidence="0.980179888888889">
:T: not-not
:L1: &lt;* op&gt; = not
&lt;* vat 1 op&gt; = not
&lt;* vat 1 vat 1&gt; = Y
:L2: &lt;*&gt; = X
:X: X &lt;=&gt; Y
:T: not-or
:Ll: &lt;* op&gt; = not
&lt;* vat 1 op&gt; = or
&lt;* vat 1 vat 1&gt; = X1
&lt;* vat 1 vat 2&gt; = X2
:L2: &lt;* op&gt; = and
&lt;* vat 1 op&gt; = not
&lt;* vat 1 vat 1&gt; = Yl
&lt;* vat 2 op&gt; = not
&lt;* vat 2 vat 1&gt; = Y2
:X: X1 &lt;= Y1
X2 &lt;=&gt; Y2
</table>
<bodyText confidence="0.647476454545454">
The two rules shown above express the
equivalences which are more familiar as:
--1(--Ip) 4-&gt; p
and
--1(p v q) 4-&gt; (--Ip
- 290 -
The mode of application required here is rather
different from that described in the preceding
section, for a context in which &amp;quot;not-not&amp;quot;
applies may not exist prior to the application of
&amp;quot;not-or&amp;quot;. Consider the three FSs below:
</bodyText>
<figure confidence="0.907764133333334">
op or
vail op not
val 1 /1
2Q
(6) op and
val 1 r op not
val 1 [ op not
val 1
2 [op not
1 1 Q
val
(7) op and
val l p
2 op not
val 1 QI
</figure>
<bodyText confidence="0.959198611111111">
Given (5), the desired result is (7), by way of (6).
A suitable context for the rule &amp;quot;not-not&amp;quot; is created
by &amp;quot;not-or&amp;quot;; note, however, that this context exists
only in the destination FS, and not in the source.
What is required is a serial mode of invocation, as
opposed to the parallel mode assumed for the MT
application, with the &apos;output&apos; of one rule serving as
the &apos;input&apos; to another. An alternative would be to
formulate transfer rules that encompass a wider
context; drawbacks of such an approach would be
that it is not possible to cater for all contexts, and
that, in attempting to do so, one would diminish the
locality and thus the transparency of the rules.
There are several possibilities for imple-
menting serial rule invocation; the most
straightforward involves taking an output FS
as the input to another pass through the rule
set. In this case, vacuous application of the
rule set must be detected in order to ensure ter-
mination.
It will not normally be desirable to apply
canonicalization rules &apos;in reverse&apos;: the effect
will be to derive all forms that are logically
equivalent to the input, and, if the relevant
equivalence classes are not finite, the process
will not terminate. Consider the rule &amp;quot;not-
not&amp;quot;; its presence in a rule set compiled with
`L2&apos; as the left-hand side will result in the
derivation of forms involving, at each point, an
embedding of the source FS under a progres-
sively higher even number of nots. This is as
it should be, however, given the semantics of
transfer rules outlined in section 2, since, in
this direction, the rule characterizes a relation
whose range is not finite. Individual applica-
dons of the rule terminate, nevertheless.
</bodyText>
<sectionHeader confidence="0.99708" genericHeader="conclusions">
4. Conclusion
</sectionHeader>
<bodyText confidence="0.99735141025641">
We have presented what is to our knowledge
the first formalization and implementation of a
type of rule and control regime intended for
use in situations where it is desired to produce
the effect of transforming one feature structure
into another.9
The formalism described above has been
implemented as part of ISSCO&apos;s ELUM, an
enhanced PATR-II style (Shieber, 1986)
unification grammar environment, based on the
UD system presented by Johnson and Rosner
(1989). ELU incorporates a parser and genera-
tor, and is primarily intended for use as a tool
for research in machine translation. Use of
transfer rules in translation has not so far
brought to light instances where the serial rule
invocation regime described in section 3.2
proves necessary. ELU grammars pernsit the
use of typed feature structures (cf. Johnson and
Rosner, op. cit., Moens et al., 1989) in gram-
mars; although the present transfer rule format
does not, they are clearly a desirable addition,
since they would provide a means of exerting
control over rule interactions.
A third area in which the transfer rule for-
malism might be applied concerns the manipu-
lation of re-entrant structures. While re-
entrancy is in general a useful property of FSs,
the complexity entailed by its presence is in
some cases unwelcome; the method of genera-
Van Noord (1990) describes the use of a standard
unification grammar to successively instantiate a single
feature structure embodying meaning representations for
both source and target language expressions in a machine
translation application. Similarly, the transfer rules of
Zajac (1990) express a relation between subparts of a sin-
gle complex structure. Such an approach does not appear
suitable for the application discussed in section 3.2
above.
</bodyText>
<figure confidence="0.8765495">
10 &amp;quot;Envizennement Linguistique d&apos;Unification&amp;quot;
(5) op not
val 1
- 291 -
</figure>
<bodyText confidence="0.999802129032258">
tion proposed by Wedekind (1988), for exam-
ple, requires that the LFG-style f-structures
which form the input to the generation process
be &apos;unfolded&apos; into unordered trees. This may
be done with a suitably formulated rule set of
the kind introduced here. The present rule for-
mat is unable to preserve the information that
distinct sub-FSs in a destination FS arise from
the duplication of a single, re-entrant, sub-FS
in the source. Ways of incorporating this abil-
ity into the rule formalism are under considera-
tion, one possibility being the addition of an
indexing mechanism that would flag sub-FSs
as originating in a re-entrancy.
A companion paper describes an interpreta-
tion of transfer rule sets in terms of a partial
ordering with respect to the specificity of rules,
and discusses linguistic and computational
motivations for this view; it also comments in
greater detail on the rule interaction problems
referred to in fn. 3, and on issues of termina-
tion, completeness and coherence in transfer.
Here, we simply note that, in the current
implementation, it is possible to declare to the
system the path set of a source FS that is to be
subject to transfer, so as to provide run-time
notification if inadequacies in the rule set
result in a specified sub-FS being neglected.
With respect to a given rule set and source FS,
however, correctness of the transfer process is
Assured.
</bodyText>
<sectionHeader confidence="0.998934" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.993696553571428">
Appelt, Douglas E. (1989) &amp;quot;Bidirectional
Grammars and the Design of Natural
Language Generation Systems&amp;quot;, in Y.
Wilks (ed.) Theoretical Issues in Natural
Language Processing; 199-205. Hillsdale,
NJ: Laurence Erlbaum.
Johnson, Rod and Mike Rosner (1989) &amp;quot;A
Rich Environment for Experimentation
with Unification Grammars&amp;quot;. Proceedings
of the Fourth Conference of the European
Chapter of the Association for Computa-
tional Linguistics, Manchester, UK, April
10th-12th 1989; 182-189.
Kaplan, Ronald M., Klaus Netter, Jurgen
Wedekind, and Annie Zaenen (1989)
&amp;quot;Translation by Structural Correspon-
dence&amp;quot;. Proceedings of the Fourth Confer-
ence of the European Chapter of the Asso-
ciation for Computational Linguistics,
Manchester, UK, April 10th-12th 1989;
272-281.
Moens, Marc, Jo Calder, Ewan Klein, Mike
Reape, and Henk Zeevat (1989) &amp;quot;Express-
ing Generalizations in Unification-based
Grammar Formalisms&amp;quot;. Proceedings of the
Fourth Conference of the European
Chapter of the Association for Computa-
tional Linguistics, Manchester, UK, April
10th-12th 1989; 174-181.
Shieber, Stuart M. (1986) An Introduction to
Unification-Based Theories of Grammar.
CSLI Lecture Notes no. 4, CSLI, Stanford.
Shieber, Stuart M. (1988) &amp;quot;A Uniform Archi-
tecture for Parsing and Generation&amp;quot;.
Proceedings of the 12th International
Conference on Computational Linguistics,
Budapest, August 22nd-27th, 1988;
614-619.
van Noord, Gertjan (1990) &amp;quot;Reversible
Unification Based Machine Translation&amp;quot;.
Proceedings of the 13th International
Conference on Computational Linguistics,
vol.2, Helsinki, Finland, August 20th-24th,
1990; 299-304.
Wedekind, Jürgen (1988) &amp;quot;Generation as
Structure-Driven Derivation&amp;quot;. Proceedings
of the 12th International Conference on
Computational Linguistics, Budapest,
August 22nd-27th, 1988; 732-737.
Zajac, Remi (1990) &amp;quot;A Relational Approach to
Translation&amp;quot;. Proceedings of the Third
International Conference on Theoretical
and Methodological Issues in Machine
Translation of Natural Language, Austin,
Texas, June llth-13th, 1990.
- 292 -
</reference>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.751641">
<title confidence="0.995438">A Language for the Statement of Binary Relations over Feature Structures</title>
<author confidence="0.992554">Graham Russell Afzal Ballim Dominique Estival Susan Warwick-Armstrong</author>
<address confidence="0.891883">ISSCO, 54 rte. des Acacias 1227 Geneva, Switzerland</address>
<email confidence="0.991595">elu@divsun.unige.ch</email>
<abstract confidence="0.998209">Unification is often the appropriate method for expressing relations between representations in the form of feature structures; however, there are circumstances in which a different approach is desirable. A declarative formalism is presented which permits direct mappings of one feature structure into another, and illustrative examples are given of its application to areas of current interest.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Douglas E Appelt</author>
</authors>
<title>Bidirectional Grammars and the Design of Natural Language Generation Systems&amp;quot;,</title>
<date>1989</date>
<booktitle>Theoretical Issues in Natural Language Processing; 199-205.</booktitle>
<editor>in Y. Wilks (ed.)</editor>
<publisher>Laurence Erlbaum.</publisher>
<location>Hillsdale, NJ:</location>
<contexts>
<context position="14355" citStr="Appelt (1989)" startWordPosition="2441" endWordPosition="2442">sibility for correctly analysing structures containing reentrancies, and enforcing them where desired in output structures, lies with the writer of transfer rules. 3.2. Reduction to Canonical Form It is often the case that a grammar assigns just one of a range of logically equivalent representations to a sentence; designers of grammars for use in analysis generally take care to ensure that the result of parsing a non-ambiguous sentence is a unique semantic representation, and multiple representations are seen as the hallmark of (pre-theoretical) ambiguity. In generation, as Shieber (1988) and Appelt (1989) observe, a situation may arise in which the representation supplied as input to the process (perhaps by another program) is not itself directly suitable, but is logically equivalent to one that is. The use of distinct grammars for parsing and generation could provide a solution to this problem, but it raises others connected with management of the resulting system. An alternative is to define equivalence classes of representations, and reduce all members of a class to the single canonical form which the grammar can map into a sentence. Exactly how the classes and reductions are defined will d</context>
</contexts>
<marker>Appelt, 1989</marker>
<rawString>Appelt, Douglas E. (1989) &amp;quot;Bidirectional Grammars and the Design of Natural Language Generation Systems&amp;quot;, in Y. Wilks (ed.) Theoretical Issues in Natural Language Processing; 199-205. Hillsdale, NJ: Laurence Erlbaum.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Rod Johnson</author>
<author>Mike Rosner</author>
</authors>
<title>A Rich Environment for Experimentation with Unification Grammars&amp;quot;.</title>
<date>1989</date>
<booktitle>Proceedings of the Fourth Conference of the European Chapter of the Association for Computational Linguistics,</booktitle>
<pages>182--189</pages>
<location>Manchester, UK,</location>
<contexts>
<context position="18097" citStr="Johnson and Rosner (1989)" startWordPosition="3131" endWordPosition="3134">2, since, in this direction, the rule characterizes a relation whose range is not finite. Individual applicadons of the rule terminate, nevertheless. 4. Conclusion We have presented what is to our knowledge the first formalization and implementation of a type of rule and control regime intended for use in situations where it is desired to produce the effect of transforming one feature structure into another.9 The formalism described above has been implemented as part of ISSCO&apos;s ELUM, an enhanced PATR-II style (Shieber, 1986) unification grammar environment, based on the UD system presented by Johnson and Rosner (1989). ELU incorporates a parser and generator, and is primarily intended for use as a tool for research in machine translation. Use of transfer rules in translation has not so far brought to light instances where the serial rule invocation regime described in section 3.2 proves necessary. ELU grammars pernsit the use of typed feature structures (cf. Johnson and Rosner, op. cit., Moens et al., 1989) in grammars; although the present transfer rule format does not, they are clearly a desirable addition, since they would provide a means of exerting control over rule interactions. A third area in which</context>
</contexts>
<marker>Johnson, Rosner, 1989</marker>
<rawString>Johnson, Rod and Mike Rosner (1989) &amp;quot;A Rich Environment for Experimentation with Unification Grammars&amp;quot;. Proceedings of the Fourth Conference of the European Chapter of the Association for Computational Linguistics, Manchester, UK, April 10th-12th 1989; 182-189.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ronald M Kaplan</author>
<author>Klaus Netter</author>
<author>Jurgen Wedekind</author>
<author>Annie Zaenen</author>
</authors>
<title>Translation by Structural Correspondence&amp;quot;.</title>
<date>1989</date>
<booktitle>Proceedings of the Fourth Conference of the European Chapter of the Association for Computational Linguistics,</booktitle>
<pages>272--281</pages>
<location>Manchester, UK,</location>
<contexts>
<context position="10110" citStr="Kaplan et al., 1989" startWordPosition="1703" endWordPosition="1706"> rules. 3.1. Machine Translation Perhaps the most obvious application for the formalism presented here lies in the domain of machine translation. The transfer model of MT may be thought of as involving three distinct mappings; from the source language expression to a source linguistic representation, from the source representation to a target representation, and from this to an expression in the target language. The first and last of these are to be performed by parsing and generation with natural language grammars, but, while proposals have been made to combine some of the three stages (e.g. Kaplan et al., 1989), there are advantages in treating the intermediate, transfer, stage independently. As an example, consider the FSs shown below:6 [ (3) sem pied schwimmen args (&lt;1&gt; sem pied Maria) mod sem pied gem (4) sem pied aimer args (&lt;1&gt; sem Fed Maria, &lt;2&gt; sem [pied nagel args ( #1 ) ) (3) and (4) are possible representations for the German sentence Maria schwimmt gem, and the French sentence Maria aime nager, both of which might translate into English as &apos;Maria likes swimming&apos;. Note that, whereas (3) has the predicate which translates &apos;swim&apos; at the top level, and contains a modifier gem n which might be</context>
</contexts>
<marker>Kaplan, Netter, Wedekind, Zaenen, 1989</marker>
<rawString>Kaplan, Ronald M., Klaus Netter, Jurgen Wedekind, and Annie Zaenen (1989) &amp;quot;Translation by Structural Correspondence&amp;quot;. Proceedings of the Fourth Conference of the European Chapter of the Association for Computational Linguistics, Manchester, UK, April 10th-12th 1989; 272-281.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Marc Moens</author>
<author>Jo Calder</author>
<author>Ewan Klein</author>
<author>Mike Reape</author>
<author>Henk Zeevat</author>
</authors>
<title>Expressing Generalizations in Unification-based Grammar Formalisms&amp;quot;.</title>
<date>1989</date>
<booktitle>Proceedings of the Fourth Conference of the European Chapter of the Association for Computational Linguistics,</booktitle>
<pages>174--181</pages>
<location>Manchester, UK,</location>
<contexts>
<context position="18494" citStr="Moens et al., 1989" startWordPosition="3197" endWordPosition="3200">another.9 The formalism described above has been implemented as part of ISSCO&apos;s ELUM, an enhanced PATR-II style (Shieber, 1986) unification grammar environment, based on the UD system presented by Johnson and Rosner (1989). ELU incorporates a parser and generator, and is primarily intended for use as a tool for research in machine translation. Use of transfer rules in translation has not so far brought to light instances where the serial rule invocation regime described in section 3.2 proves necessary. ELU grammars pernsit the use of typed feature structures (cf. Johnson and Rosner, op. cit., Moens et al., 1989) in grammars; although the present transfer rule format does not, they are clearly a desirable addition, since they would provide a means of exerting control over rule interactions. A third area in which the transfer rule formalism might be applied concerns the manipulation of re-entrant structures. While reentrancy is in general a useful property of FSs, the complexity entailed by its presence is in some cases unwelcome; the method of generaVan Noord (1990) describes the use of a standard unification grammar to successively instantiate a single feature structure embodying meaning representati</context>
</contexts>
<marker>Moens, Calder, Klein, Reape, Zeevat, 1989</marker>
<rawString>Moens, Marc, Jo Calder, Ewan Klein, Mike Reape, and Henk Zeevat (1989) &amp;quot;Expressing Generalizations in Unification-based Grammar Formalisms&amp;quot;. Proceedings of the Fourth Conference of the European Chapter of the Association for Computational Linguistics, Manchester, UK, April 10th-12th 1989; 174-181.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Stuart M Shieber</author>
</authors>
<title>An Introduction to Unification-Based Theories of Grammar.</title>
<date>1986</date>
<journal>CSLI Lecture Notes</journal>
<volume>4</volume>
<location>CSLI, Stanford.</location>
<contexts>
<context position="18002" citStr="Shieber, 1986" startWordPosition="3119" endWordPosition="3120">as it should be, however, given the semantics of transfer rules outlined in section 2, since, in this direction, the rule characterizes a relation whose range is not finite. Individual applicadons of the rule terminate, nevertheless. 4. Conclusion We have presented what is to our knowledge the first formalization and implementation of a type of rule and control regime intended for use in situations where it is desired to produce the effect of transforming one feature structure into another.9 The formalism described above has been implemented as part of ISSCO&apos;s ELUM, an enhanced PATR-II style (Shieber, 1986) unification grammar environment, based on the UD system presented by Johnson and Rosner (1989). ELU incorporates a parser and generator, and is primarily intended for use as a tool for research in machine translation. Use of transfer rules in translation has not so far brought to light instances where the serial rule invocation regime described in section 3.2 proves necessary. ELU grammars pernsit the use of typed feature structures (cf. Johnson and Rosner, op. cit., Moens et al., 1989) in grammars; although the present transfer rule format does not, they are clearly a desirable addition, sin</context>
</contexts>
<marker>Shieber, 1986</marker>
<rawString>Shieber, Stuart M. (1986) An Introduction to Unification-Based Theories of Grammar. CSLI Lecture Notes no. 4, CSLI, Stanford.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Stuart M Shieber</author>
</authors>
<title>A Uniform Architecture for Parsing and Generation&amp;quot;.</title>
<date>1988</date>
<booktitle>Proceedings of the 12th International Conference on Computational Linguistics,</booktitle>
<pages>614--619</pages>
<location>Budapest,</location>
<contexts>
<context position="14337" citStr="Shieber (1988)" startWordPosition="2438" endWordPosition="2439">; naturally, responsibility for correctly analysing structures containing reentrancies, and enforcing them where desired in output structures, lies with the writer of transfer rules. 3.2. Reduction to Canonical Form It is often the case that a grammar assigns just one of a range of logically equivalent representations to a sentence; designers of grammars for use in analysis generally take care to ensure that the result of parsing a non-ambiguous sentence is a unique semantic representation, and multiple representations are seen as the hallmark of (pre-theoretical) ambiguity. In generation, as Shieber (1988) and Appelt (1989) observe, a situation may arise in which the representation supplied as input to the process (perhaps by another program) is not itself directly suitable, but is logically equivalent to one that is. The use of distinct grammars for parsing and generation could provide a solution to this problem, but it raises others connected with management of the resulting system. An alternative is to define equivalence classes of representations, and reduce all members of a class to the single canonical form which the grammar can map into a sentence. Exactly how the classes and reductions </context>
</contexts>
<marker>Shieber, 1988</marker>
<rawString>Shieber, Stuart M. (1988) &amp;quot;A Uniform Architecture for Parsing and Generation&amp;quot;. Proceedings of the 12th International Conference on Computational Linguistics, Budapest, August 22nd-27th, 1988; 614-619.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Gertjan van Noord</author>
</authors>
<title>Reversible Unification Based Machine Translation&amp;quot;.</title>
<date>1990</date>
<booktitle>Proceedings of the 13th International Conference on Computational Linguistics, vol.2,</booktitle>
<pages>299--304</pages>
<location>Helsinki, Finland,</location>
<marker>van Noord, 1990</marker>
<rawString>van Noord, Gertjan (1990) &amp;quot;Reversible Unification Based Machine Translation&amp;quot;. Proceedings of the 13th International Conference on Computational Linguistics, vol.2, Helsinki, Finland, August 20th-24th, 1990; 299-304.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jürgen Wedekind</author>
</authors>
<title>Generation as Structure-Driven Derivation&amp;quot;.</title>
<date>1988</date>
<booktitle>Proceedings of the 12th International Conference on Computational Linguistics,</booktitle>
<pages>732--737</pages>
<location>Budapest,</location>
<contexts>
<context position="19494" citStr="Wedekind (1988)" startWordPosition="3357" endWordPosition="3358">its presence is in some cases unwelcome; the method of generaVan Noord (1990) describes the use of a standard unification grammar to successively instantiate a single feature structure embodying meaning representations for both source and target language expressions in a machine translation application. Similarly, the transfer rules of Zajac (1990) express a relation between subparts of a single complex structure. Such an approach does not appear suitable for the application discussed in section 3.2 above. 10 &amp;quot;Envizennement Linguistique d&apos;Unification&amp;quot; (5) op not val 1 - 291 - tion proposed by Wedekind (1988), for example, requires that the LFG-style f-structures which form the input to the generation process be &apos;unfolded&apos; into unordered trees. This may be done with a suitably formulated rule set of the kind introduced here. The present rule format is unable to preserve the information that distinct sub-FSs in a destination FS arise from the duplication of a single, re-entrant, sub-FS in the source. Ways of incorporating this ability into the rule formalism are under consideration, one possibility being the addition of an indexing mechanism that would flag sub-FSs as originating in a re-entrancy. </context>
</contexts>
<marker>Wedekind, 1988</marker>
<rawString>Wedekind, Jürgen (1988) &amp;quot;Generation as Structure-Driven Derivation&amp;quot;. Proceedings of the 12th International Conference on Computational Linguistics, Budapest, August 22nd-27th, 1988; 732-737.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Remi Zajac</author>
</authors>
<title>A Relational Approach to Translation&amp;quot;.</title>
<date>1990</date>
<booktitle>Proceedings of the Third International Conference on Theoretical and Methodological Issues in Machine Translation of Natural Language,</booktitle>
<location>Austin, Texas,</location>
<contexts>
<context position="19229" citStr="Zajac (1990)" startWordPosition="3314" endWordPosition="3315">rovide a means of exerting control over rule interactions. A third area in which the transfer rule formalism might be applied concerns the manipulation of re-entrant structures. While reentrancy is in general a useful property of FSs, the complexity entailed by its presence is in some cases unwelcome; the method of generaVan Noord (1990) describes the use of a standard unification grammar to successively instantiate a single feature structure embodying meaning representations for both source and target language expressions in a machine translation application. Similarly, the transfer rules of Zajac (1990) express a relation between subparts of a single complex structure. Such an approach does not appear suitable for the application discussed in section 3.2 above. 10 &amp;quot;Envizennement Linguistique d&apos;Unification&amp;quot; (5) op not val 1 - 291 - tion proposed by Wedekind (1988), for example, requires that the LFG-style f-structures which form the input to the generation process be &apos;unfolded&apos; into unordered trees. This may be done with a suitably formulated rule set of the kind introduced here. The present rule format is unable to preserve the information that distinct sub-FSs in a destination FS arise from</context>
</contexts>
<marker>Zajac, 1990</marker>
<rawString>Zajac, Remi (1990) &amp;quot;A Relational Approach to Translation&amp;quot;. Proceedings of the Third International Conference on Theoretical and Methodological Issues in Machine Translation of Natural Language, Austin, Texas, June llth-13th, 1990.</rawString>
</citation>
<citation valid="false">
<pages>292</pages>
<marker></marker>
<rawString>- 292 -</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>