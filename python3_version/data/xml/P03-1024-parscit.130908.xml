<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000017">
<title confidence="0.98753">
Generating parallel multilingual LFG-TAG grammars from a MetaGrammar
</title>
<author confidence="0.935335">
Lionel Cl´ement Alexandra Kinyon
</author>
<affiliation confidence="0.78286">
Inria-Roquencourt France CIS Dpt - Univ. of Pennsylvania
</affiliation>
<email confidence="0.995253">
lionel.clement@inria.fr kinyon@linc.cis.upenn.edu
</email>
<sectionHeader confidence="0.993782" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.997405666666667">
We introduce a MetaGrammar, which al-
lows us to automatically generate, from
a single and compact MetaGrammar hier-
archy, parallel Lexical Functional Gram-
mars (LFG) and Tree-Adjoining Gram-
mars (TAG) for French and for English:
the grammar writer specifies in compact
manner syntactic properties that are po-
tentially framework-, and to some extent
language-independent (such as subcatego-
rization, valency alternations and realiza-
tion of syntactic functions), from which
grammars for several frameworks and
languages are automatically generated
offline.1
</bodyText>
<sectionHeader confidence="0.998772" genericHeader="keywords">
1 Introduction
</sectionHeader>
<bodyText confidence="0.971192871794872">
Expensive dedicated tools and resources (e.g. gram-
mars, parsers, lexicons, etc.) have been developed
for a variety of grammar formalisms, which all have
the same goal: model the syntactic properties of nat-
ural language, but resort to a different machinery to
achieve that goal. However, there are some core syn-
tactic phenomena on which a cross-framework (and
to some extent a cross-language) consensus exists,
such as the notions of subcategorization, valency al-
ternations, syntactic function. From a theoretical
perspective, a MetaGrammatical level of representa-
tion allows one to encode such consensual pieces of
syntactic knowledge and to compare different frame-
works and languages. From a practical perspective,
encoding syntactic phenomena at a metagrammati-
cal level, from which grammars for different frame-
works and languages are generated offline, has sev-
eral advantages such as portability among grammat-
ical frameworks, better parallelism, increased coher-
ence and consistency in the grammars generated and
less need for human intervention in the grammar de-
velopment process.
In section 2, we explain the notion of MetaGram-
mar (MG), present the MG tool we use to gener-
ate TAGs, and how we extend the approach to gen-
erate LFGs. In section 3, we justify the use of a
MetaGrammar for generating LFGs and explore sev-
eral options, i.e. domains of locality, for doing so.
In sections 4 and 5, we discus the handling of va-
lency alternations without resorting to LFG lexical
1We assume the reader has a basic knowledge of TAGs and
LFGs and refer respectively to (Joshi, 1987) and (Bresnan and
Kaplan, 1982) for an introduction to these frameworks.
rules, and the treatment of long-distance dependen-
cies. In sections 6 and 7, we discuss the advantages of
a MG approach and the automatic generation of par-
allel TAG-LFG grammars for English and for French
with an explicit sharing of both cross-language and
cross-framework syntactic knowledge in the MG.
</bodyText>
<sectionHeader confidence="0.629916" genericHeader="introduction">
2 What is a MetaGrammar ?
</sectionHeader>
<bodyText confidence="0.999384666666667">
The notion of MetaGrammar was originally pre-
sented in (Candito, 1996) to automatically generate
wide-coverage TAGs for French and Italian2, using
a compact higher-level layer of linguistic description
which imposes a general organization for syntactic
information in a three-dimensional hierarchy:
</bodyText>
<listItem confidence="0.9999295">
• Dimension 1: initial subcategorization
• Dimension 2: valency alternations and redistri-
bution of functions
• Dimension 3: surface realization of arguments.
</listItem>
<bodyText confidence="0.999096814814815">
Each terminal class in dimension 1 encodes an
initial subcategorization (i.e. transitive, ditransitive
etc...); Each terminal class in dimension 2 - a list
of ordered redistributions of functions (e.g. to add
an argument for causatives, to erase one for passive
with no agents ...); Each terminal class in dimen-
sion 3 - the surface realization of a syntactic func-
tion (e.g. declares if a direct-object is pronominal-
ized, wh-extracted, etc.). Each class in the hierar-
chy is associated to the partial description of a tree
(Rogers and Vijay-Shanker, 1994) which encodes fa-
ther, dominance, equality and precedence relations
between nodes. A well-formed tree is generated by
inheriting from exactly one terminal class from di-
mension 1, one terminal class from dimension 23,
and n terminal classes from dimension 3 (where n is
the number of arguments of the elementary tree being
generated). For instance, the elementary tree for “Par
qui sera accompagn´ee Marie” (By whom will Mary be
accompanied) is generated by inheriting from tran-
sitive in dimension 1, from passive in dimension
2 and subject-nominal-inverted for its subject and
Wh-questioned-object for its object in dimension 3.
This particular tool was used to develop from a com-
pact hand-coded hierarchy of a few dozen nodes, a
wide-coverage TAG for French of 5000 elementary
trees (Abeill´e et al., 1999), as well as a medium-size
</bodyText>
<footnote confidence="0.9466128">
2A Similar MetaGrammar type of organization for TAGs was
independently presented in (Xia, 2001) for English.
3This terminal class may be the result of the crossing of sev-
eral super-classes, to handle complex phenomena such as Pas-
sive+Causative.
</footnote>
<bodyText confidence="0.999558588235294">
TAG for Italian (Candito, 1999). The compactness
of the hierarchy is due to the fact that nodes are de-
fined only for simple syntactic phenomena: classes
for complex syntactic phenomena (e.g. Topicalized-
object+Pronominalized) are generated by automatic
crossings of classes for simple phenomena. In ad-
dition to proposing a compact representation of syn-
tactic knowledge, (Candito, 1999) explored whether
some components of the hierarchy could be re-used
across similar languages (French and Italian). How-
ever, she developed two distinct hierarchies to gen-
erate grammars for these two languages and gener-
ated only TAG grammars. We extend the use of the
MetaGrammar to generate LFGs and also push fur-
ther its cross-language and cross-framework potential
by generating parallel TAGs and LFGs for English
and French from one single hierarchy 4.
</bodyText>
<subsectionHeader confidence="0.951571">
2.1 HyperTags
</subsectionHeader>
<bodyText confidence="0.999985272727273">
The grammar rules we generate are sorted by syn-
tactic phenomena, thanks to the notion of HyperTag,
introduced in (Kinyon, 2000). The main idea behind
HyperTags is to keep track, when trees (i.e. grammar
rules) are generated from a MetaGrammar hierarchy,
of which terminal classes were used for generating
the tree. This allows one to obtain a framework-
independent feature structure containing the salient
syntactic characteristics of each grammar rule5. For
instance, the verb give in A book was given to Mary
could be assigned the HyperTag:
</bodyText>
<subsectionHeader confidence="0.698559">
Subcat Ditransitive
Valency alternations Passive no Agent
</subsectionHeader>
<bodyText confidence="0.740408">
� �
</bodyText>
<sectionHeader confidence="0.493056" genericHeader="method">
Subject: Canonical NP
</sectionHeader>
<subsectionHeader confidence="0.9188735">
Argument Realization �Object: Not realized �
By-Phrase: Canonical PP
</subsectionHeader>
<bodyText confidence="0.999734222222222">
Although we retain the linguistic insights pre-
sented in (Candito, 1996), that is the three dimen-
sions to model syntax, (subcategorization, valency
alternation, realization of syntactic arguments), we
slightly alter it, and add sub-dimensions for the real-
ization of predicates as well as modifiers. Moreover,
we use a different MetaGrammar tool which is less
framework-dependent and supports the notion of Hy-
perTag.
</bodyText>
<subsectionHeader confidence="0.997418">
2.2 The LORIA MetaGrammar tool
</subsectionHeader>
<bodyText confidence="0.995469666666667">
To generate TAGs and LFGs, we use the MG com-
piler presented in (Gaiffe et al., 2002)6. Each class in
the MG hierarchy encodes:
</bodyText>
<listItem confidence="0.998132666666667">
• Its SuperClasse(s)
• A HyperTag which captures the salient linguis-
tic characteristics of that class.
</listItem>
<footnote confidence="0.993018875">
4We also generate Range Concatenation Grammars (Boullier,
1998), but do not develop this point here.
5The notion of HyperTag was inspired by that of supertags
(Srinivas, 1997), which consists in assigning a TAG elementary
tree to lexical items, hence enriching traditional POS tagging.
However, HyperTags are framework-independent.
6This compiler is freely available on
http://www.loria.fr/equipes/led/outils/mgc/mgc.html
</footnote>
<listItem confidence="0.994557285714286">
• What the class needs and provides.
• A set of quasi-nodes (i.e. variables)
• Topological relations between these nodes (fa-
ther, dominates, precedes, equals)7
• A function for each quasi-nodes to decorate the
tree (e.g. traditional agreement features and/or
LFG functional equations).
</listItem>
<bodyText confidence="0.999909636363637">
The MG tool automatically crosses the nodes in
the hierarchy, looking to create “balanced” classes,
that is classes that do not need nor provide any re-
source8. Then for each balanced terminal class, the
HyperTags are unified, and the structural constraints
between quasi-nodes are unified; If the unification
succeeds, one or more &lt;HyperTag, tree&gt; pairs are
generated. When generating a TAG, tree is inter-
preted as a TAG elementary tree (i.e. a grammar
rule). When generating an LFG, tree is a tree deco-
rated with traditional LFG functional annotations (in
a way which is similar to constituent trees decorated
with functional annotation e.g. by (Frank, 2000)),
and is in a second step broken down into one or more
LFG rules. Figure 1 illustrates how a simple dec-
orated tree is generated with the MG compiler, and
how the decorated tree corresponds to one TAG el-
ementary tree and to two LFG rewriting rules for
a canonical transitive construction. In addition, to
facilitate the grammar-lexicon interface, each deco-
rated tree yields an LFG lexical template (here, Sub-
jObj:V (TPred=‘x&lt;(TSubj)(TObj)&gt;’).
</bodyText>
<sectionHeader confidence="0.782894" genericHeader="method">
3 Why use a MetaGrammar for LFGs
</sectionHeader>
<subsectionHeader confidence="0.998697">
3.1 Redundancies in LFG
</subsectionHeader>
<bodyText confidence="0.944947931034483">
Because TAGs are a tree rewriting system, there are
intrinsic redundancies in the rules of a TAG. E.g., all
the rules for verbs with a canonical NP subject and
a canonical realization of the verb will have a redun-
dant piece of structure (S NP0↓ (VP (V⋄))) . This piece
of structure will be present not only for each new sub-
categorization frame (intransitive, transitive, ditransi-
tive...), but also for all related non-canonical syntactic
constructions such as in each grammar rule encoding
a Wh-extracted object. This redundancy justifies the
use of a MetaGrammar for TAGs. Since LFG rules
rely on a context free backbone, it is generally admit-
ted that there is less redundancy in LFG than in TAG.
However, there are still redundancies, at the level of
rewriting rules, at the level of functional equations,
and at the level of lexical entries. To illustrate such
redundancies, we take the example of French ditran-
sitives. with the inserti p of one or re modifiers.
The direct object is rea�iz med as an NP, the second ob-
ject as a PP. Both orders NP PP and PP NP are ac-
ceptable. On top of that, one or more modifiers may
be inserted before, after or between the two argu-
ments, and can be of almost any category (PP, ADVP,
7We have augmented the tool to support free variables for
nodes, optional resources, as well as additional relations such as
sister and c-command. We do not detail these technical points
for sake of brevity.
8Another way to see this is by analogy to a resource allocation
graph.
</bodyText>
<equation confidence="0.830029">
�
� � � � � �
i
</equation>
<figureCaption confidence="0.700616666666667">
Figure 1: A simple hierarchy which yields one decorated tree, corresponding to one TAG rule and two LFG
rules ( → stands for father, &lt; for precedes in the MG hierarchy. ⋄ ↓ resp. stand for “anchor” and substitution nodes in TAGs. ↓ and
↑ stand for standard LFGs functional equations.
</figureCaption>
<bodyText confidence="0.98172875">
NP etc.). Here is a non exhaustive list of acceptable
word-order variations:
- Jean donne une pomme a` Marie (lit: J. gives an apple to M.)
- Jean donne a` Marie une pomme (lit: J. gives to M. an apple)
- Jean aujourd’hui donne a` Marie une pomme (lit: J. today gives
to M. an apple)
- Jean donne a` Marie chaque matin une pomme avant le d´epart
du train (lit: J gives to M. every morning an apple before the
departure of the train)
- Jean donne chaque matin a` Marie une pomme (lit: J. gives each
morning to M. an apple)
- Aujourd’hui Jean donne a` Marie une pomme (lit: Today J. gives
to M. an apple)
A first rule for VP expansion, accounting for the
free order between the first and second object without
modifiers, is shown below:
</bodyText>
<equation confidence="0.955802">
VP → V (NP) PP (NP)
↑=↓ (↑Obj)=↓ (↑SecondObj)=↓ (↑Obj)=↓
</equation>
<bodyText confidence="0.999874032258064">
This VP rule is redundant: the NP is mentioned
twice, with its associated functional equation. The
NPs are both marked optional because at least one of
them has to be not realized, else no well-formed F-
structure could be built since the uniqueness condi-
tion would be violated by the presence of two direct-
objects: for a sentence such as “*Jean donne une
pomme a` Mary une pomme”/J. gives an apple to
M. an apple, a C-structure would be built but, as
expected, no corresponding well-formed F-structure.
Let us now enrich the rule to account for modifier in-
sertion. This yields the VP expansion shown in 2(a).
The rule for VP expansion is now highly redun-
dant, although the syntactic phenomena handled by
this rule are very simple ones: the NP for the di-
rect object is repeated twice, along with its functional
equation, the disjunction (ADVP|NP|PP) is repeated
5 times, again with its functional equation. This gives
us grounds to support a MetaGrammar type of orga-
nization for LFG. In practice, as described in (Ka-
plan and Maxwell, 1996), additional LFG notation
is available such as operators like “insert or ignore”,
”shuffle” ”ID/LP”, ”Macros” etc. However, these op-
erators, which are motivated from a formal perspec-
tive, but not so much from a linguistic perspective,
yield two major problems: first, not all LFG parsers
support those additional operators. Second, the pro-
liferation of operators allows for a same rule to be
expressed in many different ways, which is helpful
for grammar writing purpose, but not so desirable
for maintenance purpose 9. Although nothing pre-
</bodyText>
<footnote confidence="0.961628">
9This can be compared to computer programs written in Perl,
which are easy to develop, but hard to read and maintain. A
</footnote>
<figure confidence="0.960650833333333">
(a) VP → (ADVP|NP|PP)* V (ADVP|NP|PP)* (NP) (ADVP|NP|PP)* PP (ADVP|NP|PP)* (NP) (ADVP|NP|PP)*
(↑Modif) ∋↓ ↑=↓ (↑Modif)∋↓ (↑Obj)=↓ (↑Modif)∋↓ (↑SecObj)=↓(↑Modif)∋↓ (↑Obj)=↓ (↑Modif)∋↓
(b) VP → (ADVP|NP|PP)* V (ADVP|NP|PP)* NP (ADVP|NP|PP)* PP (ADVP|NP|PP)*
(↑Modif) ∋↓ ↑=↓ (↑Modif)∋↓ (↑Obj)=↓ (↑Modif)∋↓ (↑SecObj)=↓(↑Modif)∋↓
(c) VP → (ADVP|NP|PP)* V (ADVP|NP|PP)* PP (ADVP|NP|PP)* NP (ADVP|NP|PP)*
(↑Modif) ∋↓ ↑=↓ (↑Modif)∋↓ (↑SecObj)=↓(↑Modif)∋↓ (↑Obj)=↓ (↑Modif)∋↓
</figure>
<figureCaption confidence="0.998842">
Figure 2: VP expansion
</figureCaption>
<bodyText confidence="0.999074">
vents the MG generator to create rules with opera-
tors such as “ignore or insert”, we chose not to do
so. Instead of generating rules with operators or rules
like (2a), we generate two rules (2b) and (2c) in order
to have uniqueness, completeness and coherence not
only at the F-structure level but also at the C-structure
level.10. Moreover, for lexical organization, practical
LFGs resort to the notion of lexical template but from
a linguistic perspective, the lexicon is not cleanly or-
ganized in LFG11.
</bodyText>
<subsectionHeader confidence="0.998906">
3.2 Exploring different domains of locality
</subsectionHeader>
<bodyText confidence="0.99999275">
We have seen in section 2.2 that the MG tool we use
outputs &lt;HyperTag, tree&gt; pairs, where tree is dec-
orated with functional equations and corresponds to
one or more LFG rewriting rules (Figure 1).
</bodyText>
<equation confidence="0.9893455">
VP
V
(TFamily)=SubjObjPrepObj
TPred=’x&lt;(TSubj)(TObj)(Tde-Obj)&gt;’
VP —* V PP N2
↑=↓ (↑(↓ pcase)Obj)=↓ (↑ object)=↓
SubjObjectPrepObject:V
(↑ pred = ‘x &lt;(↑ Subj) (↑ Obj) (↑ de-Obj)&gt;’
</equation>
<figureCaption confidence="0.993993">
Figure 3: LFG Rule and a lexical entry
</figureCaption>
<bodyText confidence="0.999052">
In order to generate LFG rules with a MG, we have
two options. The first option consists in generating
“standard” LFG rules, that is trees of depth 1 deco-
rated with functional equations. Figure 3 illustrates
</bodyText>
<footnote confidence="0.966968333333333">
detailed discussion of the (Kaplan and Maxwell, 1996) operators
is found in (Cl´ement and Kinyon, 2003).
10Thus the grammars we generate exhibit redundancies for
modifiers, but, since the MG hierarchy has relatively few redun-
dancies, and since these grammars are automatically generated,
the problem is minor.
11As opposed for instance to lexical organization not only in
TAGs and TAG related framework (e.g. DATR (Evans et al.,
2000)), but in HPSG (Flickinger, 1987).
</footnote>
<bodyText confidence="0.9982398">
such as decorated tree, which yields one LFG rewrit-
ing rule, and one lexical entry for French verbs such
as “´eloigner” ( take away from), which take an NP
object and a PP object introduced by “de”. (Ex: “Pe-
ter ´eloigne son enfant de la fenˆetre”/ P. takes his child
away from the window). The second option, which is
the one we have opted for, consists in generating con-
stituent trees which may be of depth superior to one,
decorated with feature equations. It has the following
advantages:
</bodyText>
<listItem confidence="0.995334875">
• It allows for a more natural parallelism between
the TAG and LFG grammars generated
• It allows for a more natural encoding of syntax
at the MetaGrammar level
• It allows us to generate LFGs without Lexical
Rules
• It allows us to easily handle long-distance de-
pendencies.
</listItem>
<bodyText confidence="0.99993175">
The trees decorated with LFG functional annota-
tions are then decomposed into standard LFG rewrit-
ing rules and lexical entries12. The grammar we ob-
tain is then interfaced with a parser 13. Concerning
the first point (TAG-LFG parallelism), the trees dec-
orated with functional equations and TAG elemen-
tary trees are very similar, as was first discussed in
(Kameyama, 1986). Concerning the second point
(more natural encoding of the MetaGrammar level),
the “resource model” of the MetaGrammar, based on
“needs” and “provides”, allows for a natural encod-
ing and enforcement of LFG coherence, complete-
ness and uniqueness principles: A transitive verb
needs exactly one resource “Subject” and one re-
source “Object”. Violations result in invalid classes
which do not yield any rules. So from that perspec-
tive, it makes little sense, apart from practical rea-
sons such as interfacing the grammar with an existing
parser, to force the rules generated to be trees of depth
one. Moreover, classical completeness/coherence
</bodyText>
<footnote confidence="0.853136375">
12Non terminal symbols symbols are renamed and, in a second
phase, rules which differ only by the name of their non terminals
are merged, in a manner similar to that used in (Hepple and van
Genabith, 2000). For space reasons, we do not detail the algo-
rithm here.
13We use the freely available XLFG parser described in
(Cl´ement and Kinyon, 2001) and have also experimented with
the Xerox parser (Kaplan and Maxwell, 1996).
</footnote>
<equation confidence="0.9290375">
NP PP
(TObj)=1 (T(1pcase)Obj)=1
</equation>
<bodyText confidence="0.9996038">
conditions have received a similar resource-sensitive
re-interpretation in LFG to compute semantic struc-
tures using linear logic (Dalrymple et al., 1995). We
devote the next two sections to the third (lexical rules)
and fourth (wh) points.
</bodyText>
<sectionHeader confidence="0.84265" genericHeader="method">
4 Lexical rules
</sectionHeader>
<figureCaption confidence="0.998107">
Figure 4: An alternative to lexical rules
</figureCaption>
<bodyText confidence="0.999984391304348">
Traditional LFGs encode phrase structure realiza-
tions of syntactic functions such as the wh-extraction
or pronominalization of an object in phrase structure
rules. In the MetaGrammar, these are encoded in the
“Argument Realization” dimension (dimension 3 in
Candito’s terminology). For valency alternations, i.e.
when initial syntactic functions are modified, LFG re-
sorts to the additional machinery of lexical rules 14.
However, these valency alternations are encoded di-
rectly in the MetaGrammar in the “valency alterna-
tion” dimension (dimension 2 in Candito’s terminol-
ogy). Hence, when a rule is generated for a canonical
transitive verb, rules are generated not only for all
possible argument realization for the subject and di-
rect object (wh-questioned, relativized, cliticized for
French etc.), but also for all the valency alternations
allowed for the subcategory frame concerned (here,
passive with/without agent, causative etc). Therefore,
there is no need to generate usual LFG lexical rules,
and the absence of lexical rules has no effect on inter-
facing the grammars we generate with existing LFG
parsers. Fig. 4 illustrates the generation of a deco-
rated tree for passive-with-no-agent.
</bodyText>
<sectionHeader confidence="0.971033" genericHeader="method">
5 Long distance dependencies
</sectionHeader>
<bodyText confidence="0.999531375">
When generating TAGs and LFGs from a single MG
hierarchy, we must make sure that long-distance phe-
nomena are correctly handled. The only difference
between TAG and LFG is that for TAG, we must
make sure that bridge verbs are auxiliary trees, i.e.
have a foot node, whereas for LFG we must make
sure that extraction rules have a node decorated with
a functional uncertainty equation. In TAGs, long
</bodyText>
<footnote confidence="0.670338">
14Or, alternatively, some notion of lexical mapping, which we
do not discuss here.
</footnote>
<figureCaption confidence="0.849102666666667">
Figure 6: Long distance dependencies in LFG:
C and F structures for What did M. say that J. ate
Figure 7: Tree decorated with f. uncertainty
</figureCaption>
<bodyText confidence="0.95152395">
distance dependencies are handled through the do-
main of locality of elementary trees, the argument-
predicate co-occurrence principle and the adjunction
operation (Joshi and Vijay-Shanker, 1989). Figure 5
illustrates the TAG analysis of What did Mary say
that John ate: the extracted element is in the same
grammar rule as its predicate “ate” 15 and the tree an-
chored by the bridge verb is inserted in the “ate” tree
thanks to the adjunction operation. More trees can
adjoin in to analyze What does P. think that M. said
... that John ate using the same mechanism, which we
retain in the TAGs we generate by generating auxil-
iary tree for bridge verbs (i.e. trees with a foot node).
In LFG, long-distance dependencies are handled by
functional uncertainty (Kaplan and Zaenen, 1989).
Here is a small LFG grammar to analyze What did
M. say that John ate.
15Although a trace is present in rule for “ate”, following the
convention of the Xtag project, it is not compulsory and not
needed from a formal point of view.
</bodyText>
<figure confidence="0.998290142857143">
NPo
(What)
Sy
Aux
(did)
S2
NPx
(Mary)
Vx
(say)
VPx
Compl
(that)
Sx
Sbarx
VPy
Vy
(ate)
NPs
(John)
�Pred ’say(Subj,Comp)’
� �
� � Topic Pred What 1
� � � � � �Subj Pred ’Mary’ Comp
�
Pred ’ate(Subj,Obj)’
� Subj Pred John
�
�
� � �
1 �
1
Obj
Substitution
Adjunction0
</figure>
<figureCaption confidence="0.990042">
Figure 5: Long distance dependencies in TAGs (What did M. say that J. ate)
</figureCaption>
<figure confidence="0.803229307692308">
1- Sx → Aux NPx VPx
(↑Subj)=↓ ↑=↓
2- VPx → Vx Sbarx
↑=↓ (↑Comp)=↓
3- Sbarx → Compl Sx
↑=↓
4- Sy → NPo S2
(↑topic)=↓ ↑=↓
(↑topic)=(↑Comp*.Obj)
5- S2 → NPs VPy
(↑Subj)=↓ ↑=↓
6- VPy → Vy
↑=↓
</figure>
<bodyText confidence="0.969630956521739">
The extracted element (node NPo in rule 4) is asso-
ciated to a function path (in bold characters), which is
unknown since an arbitrary number of clauses can ap-
pear between “NPo” and its regent (Vy in rule 6). The
result of the LFG analysis for What did M. say that
J. ate, using this standard LFG grammar is shown in
Figure 6. A constituent structure is built using the the
rewriting rules. The functional equations associated
to nodes compute an F-structure which ensures that
each predicate of the sentence (i.e. “say” and “ate”)
have their arguments realized. The need for func-
tional uncertainty results from the fact that in LFG,
contrary to TAGs, the extracted element (NPo) and its
governor (Vy) are located in different grammar rules.
Hence, when generating LFGs, we must make sure
that the decorated tree bears a functional uncertainty
equation at the site of the extraction. 7 illustrates the
generation of such a decorated tree (identical to the
TAG tree for ”ate” modulo the functional equations),
which will be decomposed into rules 4, 5 and 6.16
16Because the MG does not impose a restricted domain of lo-
cality, (Kinyon, 2003) proposes an alternative to functional un-
certainty, which we do not present here for space reasons.
</bodyText>
<sectionHeader confidence="0.524377" genericHeader="method">
6 Advantages of a MetaGrammatical level
</sectionHeader>
<bodyText confidence="0.999868035714286">
A first advantage of using a MetaGrammar, dis-
cussed in (Kinyon and Prolo, 2002), is that the
syntactic phenomena covered are quite system-
atic: if rules are generated for “transitive-passive-
whExtractedByPhrase” (e.g. By whom was the
mouse eaten), and if the hierarchy includes ditran-
sitive verbs, then the automatic crossing of phe-
nomena ensures that sentences will be generated for
“ditransitive-passive-whExtractedByPhrase” (i.e. By
whom was Peter given a present). All rules for word
order variations are automatically generated by un-
derspecifying relations between quasi-nodes in the
MG hierarchy (e.g. precedence relation between first
and second object for ditransitives in French). A sec-
ond advantage of the MG is to minimize the need
for human intervention in the grammar development
process. Humans encode the linguistic knowledge in
a compact manner i.e. the MG hierarchy, and then
verify the validity of the rules generated. If some
grammar rules are missing or incorrect, then changes
are made directly in the MG hierarchy and never in
the generated rules17. This ensures a homogeneity
not necessarily present with traditional hand-crafted
grammars. A third and essential advantage is that it
is straightforward to obtain from a single hierarchy
parallel multi-lingual grammars similar to the paral-
lel LFG grammars presented in (Butt et al., 1999)
and (Butt et al., 2002), but with an explicit sharing
</bodyText>
<footnote confidence="0.5671455">
17Exceptionality is handled in the MG hierarchy as well. We
do not have much to say about it: only that the MG does not
impose any additional burden to handle syntactic “exceptions”
compared to hand-crafted grammars.
</footnote>
<bodyText confidence="0.997519">
of classes 18 in the MetaGrammar hierarchy plus a
cross-framework application. 19
</bodyText>
<sectionHeader confidence="0.801655" genericHeader="method">
7 Cross-language and -framework
generation
</sectionHeader>
<bodyText confidence="0.99996515625">
So far, we have implemented a non trivial hierarchy
which consists of 189 classes. A fragment of the hi-
erarchy is shown in Figure 8. From this hierarchy,
we generate 550 decorated trees, which correspond to
approx. 550 TAG trees and 140 LFG rules. We cover
the following syntactic phenomena: 50 verb subcate-
gorization frames (including auxiliaries, modals, sen-
tential and infinitival complements), dative-shift for
English, clitics (and their placement) for French, pas-
sives with and without agent, long distance depen-
dencies (relatives, wh-questions, clefts) and a few
idiomatic expressions. A more detailed presenta-
tion of the LFG grammar is presented in (Cl´ement
and Kinyon, 2003). A more detailed discussion of
the cross-language aspects with a comparison to re-
lated work such as the LFG ParGram project, or
HPSG matrix grammars (Bender et al., 2002) may
be found in (Kinyon and Rambow, 2003a)20. The
cross-language and cross-framework parallelism is
insured by the HyperTags: Most classes in the hi-
erarchy are shared for French and for English. Lan-
guage specific classes are marked using the binary
features “English” and “French” in their HyperTag.
So for instance, classes encoding clitic placement are
marked [French=+;English=-] and classes pertain-
ing to dative-shift are marked [French=-;English=+].
This prevents the crossing of incompatible classes
and hence the generation of incorrect rules (such
as “Dative-shift-withCliticizedObject”). Similarly,
most classes in the hierarchy are shared for TAGs
and LFGs. Classes specific to TAGs are marked
[TAG=+;LFG=-] (and conversely for LFGs)21
</bodyText>
<sectionHeader confidence="0.997664" genericHeader="conclusions">
8 Conclusion
</sectionHeader>
<bodyText confidence="0.995857939393939">
We have presented a MetaGrammar tool which al-
lows us to automatically generate parallel TAG and
LFG grammars for English and French. We have
discussed the handling of long-distance dependen-
cies. We keep enriching our hierarchy in order to
18To the best of our knowledge, (Butt et al., 2002) apply sim-
ilar linguistic choices for grammars in different languages when
possible, but do not explicitly resort to rule-sharing.
19(Kinyon and Rambow, 2003b) have used the tool to gener-
ate from a single hierarchy cross-framework and cross-language
annotated test-suites, including English and German sentences
annotated for F-structure, as well as for constituent and depen-
dency structure
20The main difference with HPSG approaches such as Matrix
is that HPSG type-hierarchies are an inherent part of the gram-
mar, and deal only with one framework:HPSG, whereas our MG
hierarchy is not an inherent part of the grammar, since it is used
to generate cross-framework grammars offline.
21We use binary features in order to add more languages and
frameworks to the hierarchy. E.g. when adding German, some
classes are shared for English and German, but not French and
are marked [English=+;German=+;French=-]. This would not be
possible if we had a non binary feature [Language=X]. The same
reasoning applies for generating additional frameworks.
increase the coverage of our grammars, are adding
new languages (German) and exploring the extension
of the domain of locality to sentence level (Kinyon
and Rambow, 2003a). The ultimate goal of this
work is twofold: first, to maximize cross-language
rule-sharing at the metagrammatical level; Second,
to automatic extract MetaGrammars from a tree-
bank (Kinyon, 2003), and then automatically gener-
ate grammars for different frameworks.
</bodyText>
<sectionHeader confidence="0.999126" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.991338012987013">
A. Abeill´e, M. Candito, and A. Kinyon. 1999. FTAG: current
status and parsing scheme. In Proc. Vextal-99, Venice.
E. Bender, D. Flickinger, and S. Oepen. 2002. The Gram-
mar Matrix: an open-source starter-kit for the rapid devel-
opment of cross-linguistically consistent broad-coverage pre-
cision grammars. In Proc. GEE-COLING, Taipei.
P. Boullier. 1998. Proposal for a natural language processing
syntactic backbone. Technical report, Inria. France.
J. Bresnan and R. Kaplan. 1982. Introduction: grammars as
mental representations of language. In The Mental Represen-
tation of Grammatical Relations, pages xvii–lii. MIT Press,
Cambridge, MA.
M. Butt, S. Dipper, A. Frank, and T. Holloway-King. 1999.
Writing large-scale parallel grammars for English, French,
and German. In Proc. LFG-99.
M. Butt, H. Dyvik, T.H. King, H. Masuichi, and C. Rohrer. 2002.
The parallel grammar project. In proc. GEE-COLING, Taipei.
M.H. Candito. 1996. A principle-based hierarchical representa-
tion of LTAGs. In Proc. COLING-96, Copenhagen.
M.H. Candito. 1999. Repr´esentation modulaire et param´etrable
de grammaires ´electroniques lexicalis´ees. Ph.D. thesis, Univ.
Paris 7.
L. Cl´ement and A. Kinyon. 2003. Generating LFGs with a
MetaGrammar. In Proc. LFG-03, Saratoga Springs.
L. Cl´ement and A. Kinyon. 2001. XLFG: an LFG parsing
scheme for french. In Proc LFG-01, Hong-Kong.
M. Dalrymple, J. Lamping, F. Pereira, and V. Saraswat. 1995.
Linear logic for meaning assembly. In Proc. CLNLP, Edin-
burgh.
R. Evans, G. Gazdar, and D. Weir. 2000. Lexical rules are
just lexical rules. In Abeille Rambow, editor, Tree Adjoining
Grammars, CSLI.
D. Flickinger. 1987. Lexical rules in the hierarchical lexicon.
Ph.D. thesis, Stanford.
A. Frank. 2000. Automatic F-Structure annotation of treebank
trees. In Proc. LFG-00, Berkeley.
B. Gaiffe, B. Crabb´e, and A. Roussanaly. 2002. A new meta-
grammar compiler. In Proc. TAG+6, Venice.
M. Hepple and J. van Genabith. 2000. Experiments in struc-
ture preserving grammar compaction. In Proc. 1st meeting
on Speech Technology Transfer, Sevilla.
Figure 8: Screen capture of a fragment of our MetaGrammar hierarchy
A. K. Joshi and K. Vijay-Shanker. 1989. Treatment of long dis-
tance dependencies in LFG and TAG: Functional uncertainty
in LFG is a corollary in TAG. In Proc. ACL-89, Vancouver.
A.K. Joshi. 1987. An introduction to tree adjoining gram-
mars. In Mathematics of language, John Benjamins Publish-
ing Company.
M. Kameyama. 1986. Characterising LFG in terms of TAG. In
Unpublished Manuscript, Univ. of Pennsylvania.
R. Kaplan and J. Maxwell. 1996. LFG grammar writer’s work-
bench. Technical Report version 3.1, Xerox corporation.
R Kaplan and A. Zaenen. 1989. Long distance dependencies,
constituent structure and functional uncertainty. In Alterna-
tives conceptions ofphrase-structure, Univ. of Chicago press.
A. Kinyon and C. Prolo. 2002. A classification of grammar
development strategies. In Proc. GEE-COLING, Taipei.
A. Kinyon and O. Rambow. 2003a. Using the metagrammar
for parallel multilingual grammar development and genera-
tion. In Proc. ESSLLI workshop on multilingual grammar
engineering, Vienna.
A. Kinyon and O. Rambow. 2003b. Using the MetaGrammar to
generate cross-language and cross-framework annotated test-
suites. In Proc. LINC-EACL, Budapest.
A. Kinyon. 2000. Hypertags. In Proc. COLING-00, Sar-
rebrucken.
A. Kinyon. 2003. MetaGrammars for efficient development, ex-
traction and generation ofparallel grammars. Ph.D. thesis,
Proposal. Univ. of Pennsylvania.
J. Rogers and K. Vijay-Shanker. 1994. Obtaining trees from
their description: an application to TAGS. In Computational
Intelligence 10:4.
B. Srinivas. 1997. Complexity of lexical descriptions and its
relevance for partial parsing. Ph.D. thesis, Univ. of Pennsyl-
vania.
F. Xia. 2001. Automatic grammar generation from two perspec-
tives. Ph.D. thesis, Univ. of Pennsylvania.
</reference>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.721724">
<title confidence="0.998802">Generating parallel multilingual LFG-TAG grammars from a MetaGrammar</title>
<author confidence="0.999333">Lionel Cl´ement Alexandra Kinyon</author>
<affiliation confidence="0.974729">Inria-Roquencourt France CIS Dpt - Univ. of Pennsylvania</affiliation>
<email confidence="0.998504">lionel.clement@inria.frkinyon@linc.cis.upenn.edu</email>
<abstract confidence="0.982433866666667">introduce a which allows us to automatically generate, from a single and compact MetaGrammar hierarchy, parallel Lexical Functional Grammars (LFG) and Tree-Adjoining Grammars (TAG) for French and for English: the grammar writer specifies in compact manner syntactic properties that are potentially framework-, and to some extent language-independent (such as subcategorization, valency alternations and realization of syntactic functions), from which grammars for several frameworks and languages are automatically generated</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>A Abeill´e</author>
<author>M Candito</author>
<author>A Kinyon</author>
</authors>
<title>FTAG: current status and parsing scheme.</title>
<date>1999</date>
<booktitle>In Proc. Vextal-99,</booktitle>
<location>Venice.</location>
<marker>Abeill´e, Candito, Kinyon, 1999</marker>
<rawString>A. Abeill´e, M. Candito, and A. Kinyon. 1999. FTAG: current status and parsing scheme. In Proc. Vextal-99, Venice.</rawString>
</citation>
<citation valid="true">
<authors>
<author>E Bender</author>
<author>D Flickinger</author>
<author>S Oepen</author>
</authors>
<title>The Grammar Matrix: an open-source starter-kit for the rapid development of cross-linguistically consistent broad-coverage precision grammars.</title>
<date>2002</date>
<booktitle>In Proc. GEE-COLING,</booktitle>
<tech>Technical report, Inria. France.</tech>
<contexts>
<context position="25164" citStr="Bender et al., 2002" startWordPosition="4081" endWordPosition="4084">0 LFG rules. We cover the following syntactic phenomena: 50 verb subcategorization frames (including auxiliaries, modals, sentential and infinitival complements), dative-shift for English, clitics (and their placement) for French, passives with and without agent, long distance dependencies (relatives, wh-questions, clefts) and a few idiomatic expressions. A more detailed presentation of the LFG grammar is presented in (Cl´ement and Kinyon, 2003). A more detailed discussion of the cross-language aspects with a comparison to related work such as the LFG ParGram project, or HPSG matrix grammars (Bender et al., 2002) may be found in (Kinyon and Rambow, 2003a)20. The cross-language and cross-framework parallelism is insured by the HyperTags: Most classes in the hierarchy are shared for French and for English. Language specific classes are marked using the binary features “English” and “French” in their HyperTag. So for instance, classes encoding clitic placement are marked [French=+;English=-] and classes pertaining to dative-shift are marked [French=-;English=+]. This prevents the crossing of incompatible classes and hence the generation of incorrect rules (such as “Dative-shift-withCliticizedObject”). Si</context>
</contexts>
<marker>Bender, Flickinger, Oepen, 2002</marker>
<rawString>E. Bender, D. Flickinger, and S. Oepen. 2002. The Grammar Matrix: an open-source starter-kit for the rapid development of cross-linguistically consistent broad-coverage precision grammars. In Proc. GEE-COLING, Taipei. P. Boullier. 1998. Proposal for a natural language processing syntactic backbone. Technical report, Inria. France.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Bresnan</author>
<author>R Kaplan</author>
</authors>
<title>Introduction: grammars as mental representations of language.</title>
<date>1982</date>
<booktitle>In The Mental Representation of Grammatical Relations,</booktitle>
<pages>pages xvii–lii.</pages>
<publisher>MIT Press,</publisher>
<location>Cambridge, MA.</location>
<contexts>
<context position="2389" citStr="Bresnan and Kaplan, 1982" startWordPosition="357" endWordPosition="360">ncy in the grammars generated and less need for human intervention in the grammar development process. In section 2, we explain the notion of MetaGrammar (MG), present the MG tool we use to generate TAGs, and how we extend the approach to generate LFGs. In section 3, we justify the use of a MetaGrammar for generating LFGs and explore several options, i.e. domains of locality, for doing so. In sections 4 and 5, we discus the handling of valency alternations without resorting to LFG lexical 1We assume the reader has a basic knowledge of TAGs and LFGs and refer respectively to (Joshi, 1987) and (Bresnan and Kaplan, 1982) for an introduction to these frameworks. rules, and the treatment of long-distance dependencies. In sections 6 and 7, we discuss the advantages of a MG approach and the automatic generation of parallel TAG-LFG grammars for English and for French with an explicit sharing of both cross-language and cross-framework syntactic knowledge in the MG. 2 What is a MetaGrammar ? The notion of MetaGrammar was originally presented in (Candito, 1996) to automatically generate wide-coverage TAGs for French and Italian2, using a compact higher-level layer of linguistic description which imposes a general org</context>
</contexts>
<marker>Bresnan, Kaplan, 1982</marker>
<rawString>J. Bresnan and R. Kaplan. 1982. Introduction: grammars as mental representations of language. In The Mental Representation of Grammatical Relations, pages xvii–lii. MIT Press, Cambridge, MA.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Butt</author>
<author>S Dipper</author>
<author>A Frank</author>
<author>T Holloway-King</author>
</authors>
<title>Writing large-scale parallel grammars for English, French, and German. In</title>
<date>1999</date>
<booktitle>Proc. LFG-99.</booktitle>
<contexts>
<context position="23912" citStr="Butt et al., 1999" startWordPosition="3883" endWordPosition="3886"> for human intervention in the grammar development process. Humans encode the linguistic knowledge in a compact manner i.e. the MG hierarchy, and then verify the validity of the rules generated. If some grammar rules are missing or incorrect, then changes are made directly in the MG hierarchy and never in the generated rules17. This ensures a homogeneity not necessarily present with traditional hand-crafted grammars. A third and essential advantage is that it is straightforward to obtain from a single hierarchy parallel multi-lingual grammars similar to the parallel LFG grammars presented in (Butt et al., 1999) and (Butt et al., 2002), but with an explicit sharing 17Exceptionality is handled in the MG hierarchy as well. We do not have much to say about it: only that the MG does not impose any additional burden to handle syntactic “exceptions” compared to hand-crafted grammars. of classes 18 in the MetaGrammar hierarchy plus a cross-framework application. 19 7 Cross-language and -framework generation So far, we have implemented a non trivial hierarchy which consists of 189 classes. A fragment of the hierarchy is shown in Figure 8. From this hierarchy, we generate 550 decorated trees, which correspond</context>
</contexts>
<marker>Butt, Dipper, Frank, Holloway-King, 1999</marker>
<rawString>M. Butt, S. Dipper, A. Frank, and T. Holloway-King. 1999. Writing large-scale parallel grammars for English, French, and German. In Proc. LFG-99.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Butt</author>
<author>H Dyvik</author>
<author>T H King</author>
<author>H Masuichi</author>
<author>C Rohrer</author>
</authors>
<title>The parallel grammar project.</title>
<date>2002</date>
<booktitle>In proc. GEE-COLING, Taipei. M.H. Candito.</booktitle>
<location>Copenhagen.</location>
<contexts>
<context position="23936" citStr="Butt et al., 2002" startWordPosition="3888" endWordPosition="3891">in the grammar development process. Humans encode the linguistic knowledge in a compact manner i.e. the MG hierarchy, and then verify the validity of the rules generated. If some grammar rules are missing or incorrect, then changes are made directly in the MG hierarchy and never in the generated rules17. This ensures a homogeneity not necessarily present with traditional hand-crafted grammars. A third and essential advantage is that it is straightforward to obtain from a single hierarchy parallel multi-lingual grammars similar to the parallel LFG grammars presented in (Butt et al., 1999) and (Butt et al., 2002), but with an explicit sharing 17Exceptionality is handled in the MG hierarchy as well. We do not have much to say about it: only that the MG does not impose any additional burden to handle syntactic “exceptions” compared to hand-crafted grammars. of classes 18 in the MetaGrammar hierarchy plus a cross-framework application. 19 7 Cross-language and -framework generation So far, we have implemented a non trivial hierarchy which consists of 189 classes. A fragment of the hierarchy is shown in Figure 8. From this hierarchy, we generate 550 decorated trees, which correspond to approx. 550 TAG tree</context>
<context position="26214" citStr="Butt et al., 2002" startWordPosition="4238" endWordPosition="4241">d [French=-;English=+]. This prevents the crossing of incompatible classes and hence the generation of incorrect rules (such as “Dative-shift-withCliticizedObject”). Similarly, most classes in the hierarchy are shared for TAGs and LFGs. Classes specific to TAGs are marked [TAG=+;LFG=-] (and conversely for LFGs)21 8 Conclusion We have presented a MetaGrammar tool which allows us to automatically generate parallel TAG and LFG grammars for English and French. We have discussed the handling of long-distance dependencies. We keep enriching our hierarchy in order to 18To the best of our knowledge, (Butt et al., 2002) apply similar linguistic choices for grammars in different languages when possible, but do not explicitly resort to rule-sharing. 19(Kinyon and Rambow, 2003b) have used the tool to generate from a single hierarchy cross-framework and cross-language annotated test-suites, including English and German sentences annotated for F-structure, as well as for constituent and dependency structure 20The main difference with HPSG approaches such as Matrix is that HPSG type-hierarchies are an inherent part of the grammar, and deal only with one framework:HPSG, whereas our MG hierarchy is not an inherent p</context>
</contexts>
<marker>Butt, Dyvik, King, Masuichi, Rohrer, 2002</marker>
<rawString>M. Butt, H. Dyvik, T.H. King, H. Masuichi, and C. Rohrer. 2002. The parallel grammar project. In proc. GEE-COLING, Taipei. M.H. Candito. 1996. A principle-based hierarchical representation of LTAGs. In Proc. COLING-96, Copenhagen.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M H Candito</author>
</authors>
<title>Repr´esentation modulaire et param´etrable de grammaires ´electroniques lexicalis´ees.</title>
<date>1999</date>
<tech>Ph.D. thesis,</tech>
<institution>Univ. Paris</institution>
<contexts>
<context position="4880" citStr="Candito, 1999" startWordPosition="748" endWordPosition="749"> 1, from passive in dimension 2 and subject-nominal-inverted for its subject and Wh-questioned-object for its object in dimension 3. This particular tool was used to develop from a compact hand-coded hierarchy of a few dozen nodes, a wide-coverage TAG for French of 5000 elementary trees (Abeill´e et al., 1999), as well as a medium-size 2A Similar MetaGrammar type of organization for TAGs was independently presented in (Xia, 2001) for English. 3This terminal class may be the result of the crossing of several super-classes, to handle complex phenomena such as Passive+Causative. TAG for Italian (Candito, 1999). The compactness of the hierarchy is due to the fact that nodes are defined only for simple syntactic phenomena: classes for complex syntactic phenomena (e.g. Topicalizedobject+Pronominalized) are generated by automatic crossings of classes for simple phenomena. In addition to proposing a compact representation of syntactic knowledge, (Candito, 1999) explored whether some components of the hierarchy could be re-used across similar languages (French and Italian). However, she developed two distinct hierarchies to generate grammars for these two languages and generated only TAG grammars. We ext</context>
</contexts>
<marker>Candito, 1999</marker>
<rawString>M.H. Candito. 1999. Repr´esentation modulaire et param´etrable de grammaires ´electroniques lexicalis´ees. Ph.D. thesis, Univ. Paris 7.</rawString>
</citation>
<citation valid="true">
<authors>
<author>L Cl´ement</author>
<author>A Kinyon</author>
</authors>
<title>Generating LFGs with a MetaGrammar.</title>
<date>2003</date>
<booktitle>In Proc. LFG-03,</booktitle>
<location>Saratoga Springs.</location>
<marker>Cl´ement, Kinyon, 2003</marker>
<rawString>L. Cl´ement and A. Kinyon. 2003. Generating LFGs with a MetaGrammar. In Proc. LFG-03, Saratoga Springs.</rawString>
</citation>
<citation valid="true">
<authors>
<author>L Cl´ement</author>
<author>A Kinyon</author>
</authors>
<title>XLFG: an LFG parsing scheme for french.</title>
<date>2001</date>
<booktitle>In Proc LFG-01, Hong-Kong.</booktitle>
<marker>Cl´ement, Kinyon, 2001</marker>
<rawString>L. Cl´ement and A. Kinyon. 2001. XLFG: an LFG parsing scheme for french. In Proc LFG-01, Hong-Kong.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Dalrymple</author>
<author>J Lamping</author>
<author>F Pereira</author>
<author>V Saraswat</author>
</authors>
<title>Linear logic for meaning assembly.</title>
<date>1995</date>
<booktitle>In Proc. CLNLP,</booktitle>
<location>Edinburgh.</location>
<contexts>
<context position="17747" citStr="Dalrymple et al., 1995" startWordPosition="2855" endWordPosition="2858">ness/coherence 12Non terminal symbols symbols are renamed and, in a second phase, rules which differ only by the name of their non terminals are merged, in a manner similar to that used in (Hepple and van Genabith, 2000). For space reasons, we do not detail the algorithm here. 13We use the freely available XLFG parser described in (Cl´ement and Kinyon, 2001) and have also experimented with the Xerox parser (Kaplan and Maxwell, 1996). NP PP (TObj)=1 (T(1pcase)Obj)=1 conditions have received a similar resource-sensitive re-interpretation in LFG to compute semantic structures using linear logic (Dalrymple et al., 1995). We devote the next two sections to the third (lexical rules) and fourth (wh) points. 4 Lexical rules Figure 4: An alternative to lexical rules Traditional LFGs encode phrase structure realizations of syntactic functions such as the wh-extraction or pronominalization of an object in phrase structure rules. In the MetaGrammar, these are encoded in the “Argument Realization” dimension (dimension 3 in Candito’s terminology). For valency alternations, i.e. when initial syntactic functions are modified, LFG resorts to the additional machinery of lexical rules 14. However, these valency alternation</context>
</contexts>
<marker>Dalrymple, Lamping, Pereira, Saraswat, 1995</marker>
<rawString>M. Dalrymple, J. Lamping, F. Pereira, and V. Saraswat. 1995. Linear logic for meaning assembly. In Proc. CLNLP, Edinburgh.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Evans</author>
<author>G Gazdar</author>
<author>D Weir</author>
</authors>
<title>Lexical rules are just lexical rules.</title>
<date>2000</date>
<booktitle>In Abeille Rambow, editor, Tree Adjoining Grammars, CSLI.</booktitle>
<contexts>
<context position="15328" citStr="Evans et al., 2000" startWordPosition="2456" endWordPosition="2459">G rules with a MG, we have two options. The first option consists in generating “standard” LFG rules, that is trees of depth 1 decorated with functional equations. Figure 3 illustrates detailed discussion of the (Kaplan and Maxwell, 1996) operators is found in (Cl´ement and Kinyon, 2003). 10Thus the grammars we generate exhibit redundancies for modifiers, but, since the MG hierarchy has relatively few redundancies, and since these grammars are automatically generated, the problem is minor. 11As opposed for instance to lexical organization not only in TAGs and TAG related framework (e.g. DATR (Evans et al., 2000)), but in HPSG (Flickinger, 1987). such as decorated tree, which yields one LFG rewriting rule, and one lexical entry for French verbs such as “´eloigner” ( take away from), which take an NP object and a PP object introduced by “de”. (Ex: “Peter ´eloigne son enfant de la fenˆetre”/ P. takes his child away from the window). The second option, which is the one we have opted for, consists in generating constituent trees which may be of depth superior to one, decorated with feature equations. It has the following advantages: • It allows for a more natural parallelism between the TAG and LFG gramma</context>
</contexts>
<marker>Evans, Gazdar, Weir, 2000</marker>
<rawString>R. Evans, G. Gazdar, and D. Weir. 2000. Lexical rules are just lexical rules. In Abeille Rambow, editor, Tree Adjoining Grammars, CSLI.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D Flickinger</author>
</authors>
<date>1987</date>
<booktitle>Lexical rules in the hierarchical lexicon. Ph.D. thesis,</booktitle>
<location>Stanford.</location>
<contexts>
<context position="15361" citStr="Flickinger, 1987" startWordPosition="2463" endWordPosition="2464">ons. The first option consists in generating “standard” LFG rules, that is trees of depth 1 decorated with functional equations. Figure 3 illustrates detailed discussion of the (Kaplan and Maxwell, 1996) operators is found in (Cl´ement and Kinyon, 2003). 10Thus the grammars we generate exhibit redundancies for modifiers, but, since the MG hierarchy has relatively few redundancies, and since these grammars are automatically generated, the problem is minor. 11As opposed for instance to lexical organization not only in TAGs and TAG related framework (e.g. DATR (Evans et al., 2000)), but in HPSG (Flickinger, 1987). such as decorated tree, which yields one LFG rewriting rule, and one lexical entry for French verbs such as “´eloigner” ( take away from), which take an NP object and a PP object introduced by “de”. (Ex: “Peter ´eloigne son enfant de la fenˆetre”/ P. takes his child away from the window). The second option, which is the one we have opted for, consists in generating constituent trees which may be of depth superior to one, decorated with feature equations. It has the following advantages: • It allows for a more natural parallelism between the TAG and LFG grammars generated • It allows for a mo</context>
</contexts>
<marker>Flickinger, 1987</marker>
<rawString>D. Flickinger. 1987. Lexical rules in the hierarchical lexicon. Ph.D. thesis, Stanford.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Frank</author>
</authors>
<title>Automatic F-Structure annotation of treebank trees.</title>
<date>2000</date>
<booktitle>In Proc. LFG-00,</booktitle>
<location>Berkeley.</location>
<contexts>
<context position="8440" citStr="Frank, 2000" startWordPosition="1292" endWordPosition="1293">the hierarchy, looking to create “balanced” classes, that is classes that do not need nor provide any resource8. Then for each balanced terminal class, the HyperTags are unified, and the structural constraints between quasi-nodes are unified; If the unification succeeds, one or more &lt;HyperTag, tree&gt; pairs are generated. When generating a TAG, tree is interpreted as a TAG elementary tree (i.e. a grammar rule). When generating an LFG, tree is a tree decorated with traditional LFG functional annotations (in a way which is similar to constituent trees decorated with functional annotation e.g. by (Frank, 2000)), and is in a second step broken down into one or more LFG rules. Figure 1 illustrates how a simple decorated tree is generated with the MG compiler, and how the decorated tree corresponds to one TAG elementary tree and to two LFG rewriting rules for a canonical transitive construction. In addition, to facilitate the grammar-lexicon interface, each decorated tree yields an LFG lexical template (here, SubjObj:V (TPred=‘x&lt;(TSubj)(TObj)&gt;’). 3 Why use a MetaGrammar for LFGs 3.1 Redundancies in LFG Because TAGs are a tree rewriting system, there are intrinsic redundancies in the rules of a TAG. E.</context>
</contexts>
<marker>Frank, 2000</marker>
<rawString>A. Frank. 2000. Automatic F-Structure annotation of treebank trees. In Proc. LFG-00, Berkeley.</rawString>
</citation>
<citation valid="true">
<authors>
<author>B Gaiffe</author>
<author>B Crabb´e</author>
<author>A Roussanaly</author>
</authors>
<title>A new metagrammar compiler.</title>
<date>2002</date>
<booktitle>In Proc. TAG+6,</booktitle>
<location>Venice.</location>
<marker>Gaiffe, Crabb´e, Roussanaly, 2002</marker>
<rawString>B. Gaiffe, B. Crabb´e, and A. Roussanaly. 2002. A new metagrammar compiler. In Proc. TAG+6, Venice.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Hepple</author>
<author>J van Genabith</author>
</authors>
<title>Experiments in structure preserving grammar compaction.</title>
<date>2000</date>
<booktitle>In Proc. 1st meeting on Speech Technology Transfer,</booktitle>
<location>Sevilla.</location>
<marker>Hepple, van Genabith, 2000</marker>
<rawString>M. Hepple and J. van Genabith. 2000. Experiments in structure preserving grammar compaction. In Proc. 1st meeting on Speech Technology Transfer, Sevilla.</rawString>
</citation>
<citation valid="false">
<title>Figure 8: Screen capture of a fragment of our MetaGrammar hierarchy</title>
<marker></marker>
<rawString>Figure 8: Screen capture of a fragment of our MetaGrammar hierarchy</rawString>
</citation>
<citation valid="true">
<authors>
<author>A K Joshi</author>
<author>K Vijay-Shanker</author>
</authors>
<title>Treatment of long distance dependencies in LFG and TAG: Functional uncertainty in LFG is a corollary in TAG.</title>
<date>1989</date>
<booktitle>In Proc. ACL-89,</booktitle>
<location>Vancouver.</location>
<contexts>
<context position="19931" citStr="Joshi and Vijay-Shanker, 1989" startWordPosition="3197" endWordPosition="3200">, we must make sure that bridge verbs are auxiliary trees, i.e. have a foot node, whereas for LFG we must make sure that extraction rules have a node decorated with a functional uncertainty equation. In TAGs, long 14Or, alternatively, some notion of lexical mapping, which we do not discuss here. Figure 6: Long distance dependencies in LFG: C and F structures for What did M. say that J. ate Figure 7: Tree decorated with f. uncertainty distance dependencies are handled through the domain of locality of elementary trees, the argumentpredicate co-occurrence principle and the adjunction operation (Joshi and Vijay-Shanker, 1989). Figure 5 illustrates the TAG analysis of What did Mary say that John ate: the extracted element is in the same grammar rule as its predicate “ate” 15 and the tree anchored by the bridge verb is inserted in the “ate” tree thanks to the adjunction operation. More trees can adjoin in to analyze What does P. think that M. said ... that John ate using the same mechanism, which we retain in the TAGs we generate by generating auxiliary tree for bridge verbs (i.e. trees with a foot node). In LFG, long-distance dependencies are handled by functional uncertainty (Kaplan and Zaenen, 1989). Here is a sm</context>
</contexts>
<marker>Joshi, Vijay-Shanker, 1989</marker>
<rawString>A. K. Joshi and K. Vijay-Shanker. 1989. Treatment of long distance dependencies in LFG and TAG: Functional uncertainty in LFG is a corollary in TAG. In Proc. ACL-89, Vancouver.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A K Joshi</author>
</authors>
<title>An introduction to tree adjoining grammars.</title>
<date>1987</date>
<journal>In Mathematics of language, John Benjamins</journal>
<publisher>Publishing Company.</publisher>
<contexts>
<context position="2358" citStr="Joshi, 1987" startWordPosition="354" endWordPosition="355">rence and consistency in the grammars generated and less need for human intervention in the grammar development process. In section 2, we explain the notion of MetaGrammar (MG), present the MG tool we use to generate TAGs, and how we extend the approach to generate LFGs. In section 3, we justify the use of a MetaGrammar for generating LFGs and explore several options, i.e. domains of locality, for doing so. In sections 4 and 5, we discus the handling of valency alternations without resorting to LFG lexical 1We assume the reader has a basic knowledge of TAGs and LFGs and refer respectively to (Joshi, 1987) and (Bresnan and Kaplan, 1982) for an introduction to these frameworks. rules, and the treatment of long-distance dependencies. In sections 6 and 7, we discuss the advantages of a MG approach and the automatic generation of parallel TAG-LFG grammars for English and for French with an explicit sharing of both cross-language and cross-framework syntactic knowledge in the MG. 2 What is a MetaGrammar ? The notion of MetaGrammar was originally presented in (Candito, 1996) to automatically generate wide-coverage TAGs for French and Italian2, using a compact higher-level layer of linguistic descript</context>
</contexts>
<marker>Joshi, 1987</marker>
<rawString>A.K. Joshi. 1987. An introduction to tree adjoining grammars. In Mathematics of language, John Benjamins Publishing Company.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Kameyama</author>
</authors>
<title>Characterising LFG in terms of TAG.</title>
<date>1986</date>
<institution>In Unpublished Manuscript, Univ. of Pennsylvania.</institution>
<contexts>
<context position="16499" citStr="Kameyama, 1986" startWordPosition="2660" endWordPosition="2661">l parallelism between the TAG and LFG grammars generated • It allows for a more natural encoding of syntax at the MetaGrammar level • It allows us to generate LFGs without Lexical Rules • It allows us to easily handle long-distance dependencies. The trees decorated with LFG functional annotations are then decomposed into standard LFG rewriting rules and lexical entries12. The grammar we obtain is then interfaced with a parser 13. Concerning the first point (TAG-LFG parallelism), the trees decorated with functional equations and TAG elementary trees are very similar, as was first discussed in (Kameyama, 1986). Concerning the second point (more natural encoding of the MetaGrammar level), the “resource model” of the MetaGrammar, based on “needs” and “provides”, allows for a natural encoding and enforcement of LFG coherence, completeness and uniqueness principles: A transitive verb needs exactly one resource “Subject” and one resource “Object”. Violations result in invalid classes which do not yield any rules. So from that perspective, it makes little sense, apart from practical reasons such as interfacing the grammar with an existing parser, to force the rules generated to be trees of depth one. Mor</context>
</contexts>
<marker>Kameyama, 1986</marker>
<rawString>M. Kameyama. 1986. Characterising LFG in terms of TAG. In Unpublished Manuscript, Univ. of Pennsylvania.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Kaplan</author>
<author>J Maxwell</author>
</authors>
<title>LFG grammar writer’s workbench.</title>
<date>1996</date>
<tech>Technical Report version 3.1,</tech>
<institution>Xerox corporation.</institution>
<contexts>
<context position="12570" citStr="Kaplan and Maxwell, 1996" startWordPosition="2027" endWordPosition="2031"> a C-structure would be built but, as expected, no corresponding well-formed F-structure. Let us now enrich the rule to account for modifier insertion. This yields the VP expansion shown in 2(a). The rule for VP expansion is now highly redundant, although the syntactic phenomena handled by this rule are very simple ones: the NP for the direct object is repeated twice, along with its functional equation, the disjunction (ADVP|NP|PP) is repeated 5 times, again with its functional equation. This gives us grounds to support a MetaGrammar type of organization for LFG. In practice, as described in (Kaplan and Maxwell, 1996), additional LFG notation is available such as operators like “insert or ignore”, ”shuffle” ”ID/LP”, ”Macros” etc. However, these operators, which are motivated from a formal perspective, but not so much from a linguistic perspective, yield two major problems: first, not all LFG parsers support those additional operators. Second, the proliferation of operators allows for a same rule to be expressed in many different ways, which is helpful for grammar writing purpose, but not so desirable for maintenance purpose 9. Although nothing pre9This can be compared to computer programs written in Perl, </context>
<context position="14947" citStr="Kaplan and Maxwell, 1996" startWordPosition="2397" endWordPosition="2400">outputs &lt;HyperTag, tree&gt; pairs, where tree is decorated with functional equations and corresponds to one or more LFG rewriting rules (Figure 1). VP V (TFamily)=SubjObjPrepObj TPred=’x&lt;(TSubj)(TObj)(Tde-Obj)&gt;’ VP —* V PP N2 ↑=↓ (↑(↓ pcase)Obj)=↓ (↑ object)=↓ SubjObjectPrepObject:V (↑ pred = ‘x &lt;(↑ Subj) (↑ Obj) (↑ de-Obj)&gt;’ Figure 3: LFG Rule and a lexical entry In order to generate LFG rules with a MG, we have two options. The first option consists in generating “standard” LFG rules, that is trees of depth 1 decorated with functional equations. Figure 3 illustrates detailed discussion of the (Kaplan and Maxwell, 1996) operators is found in (Cl´ement and Kinyon, 2003). 10Thus the grammars we generate exhibit redundancies for modifiers, but, since the MG hierarchy has relatively few redundancies, and since these grammars are automatically generated, the problem is minor. 11As opposed for instance to lexical organization not only in TAGs and TAG related framework (e.g. DATR (Evans et al., 2000)), but in HPSG (Flickinger, 1987). such as decorated tree, which yields one LFG rewriting rule, and one lexical entry for French verbs such as “´eloigner” ( take away from), which take an NP object and a PP object intro</context>
<context position="17560" citStr="Kaplan and Maxwell, 1996" startWordPosition="2830" endWordPosition="2833">makes little sense, apart from practical reasons such as interfacing the grammar with an existing parser, to force the rules generated to be trees of depth one. Moreover, classical completeness/coherence 12Non terminal symbols symbols are renamed and, in a second phase, rules which differ only by the name of their non terminals are merged, in a manner similar to that used in (Hepple and van Genabith, 2000). For space reasons, we do not detail the algorithm here. 13We use the freely available XLFG parser described in (Cl´ement and Kinyon, 2001) and have also experimented with the Xerox parser (Kaplan and Maxwell, 1996). NP PP (TObj)=1 (T(1pcase)Obj)=1 conditions have received a similar resource-sensitive re-interpretation in LFG to compute semantic structures using linear logic (Dalrymple et al., 1995). We devote the next two sections to the third (lexical rules) and fourth (wh) points. 4 Lexical rules Figure 4: An alternative to lexical rules Traditional LFGs encode phrase structure realizations of syntactic functions such as the wh-extraction or pronominalization of an object in phrase structure rules. In the MetaGrammar, these are encoded in the “Argument Realization” dimension (dimension 3 in Candito’s </context>
</contexts>
<marker>Kaplan, Maxwell, 1996</marker>
<rawString>R. Kaplan and J. Maxwell. 1996. LFG grammar writer’s workbench. Technical Report version 3.1, Xerox corporation.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Kaplan</author>
<author>A Zaenen</author>
</authors>
<title>Long distance dependencies, constituent structure and functional uncertainty.</title>
<date>1989</date>
<booktitle>In Alternatives conceptions ofphrase-structure, Univ. of</booktitle>
<publisher>Chicago press.</publisher>
<contexts>
<context position="20517" citStr="Kaplan and Zaenen, 1989" startWordPosition="3302" endWordPosition="3305">ration (Joshi and Vijay-Shanker, 1989). Figure 5 illustrates the TAG analysis of What did Mary say that John ate: the extracted element is in the same grammar rule as its predicate “ate” 15 and the tree anchored by the bridge verb is inserted in the “ate” tree thanks to the adjunction operation. More trees can adjoin in to analyze What does P. think that M. said ... that John ate using the same mechanism, which we retain in the TAGs we generate by generating auxiliary tree for bridge verbs (i.e. trees with a foot node). In LFG, long-distance dependencies are handled by functional uncertainty (Kaplan and Zaenen, 1989). Here is a small LFG grammar to analyze What did M. say that John ate. 15Although a trace is present in rule for “ate”, following the convention of the Xtag project, it is not compulsory and not needed from a formal point of view. NPo (What) Sy Aux (did) S2 NPx (Mary) Vx (say) VPx Compl (that) Sx Sbarx VPy Vy (ate) NPs (John) �Pred ’say(Subj,Comp)’ � � � � Topic Pred What 1 � � � � � �Subj Pred ’Mary’ Comp � Pred ’ate(Subj,Obj)’ � Subj Pred John � � � � � 1 � 1 Obj Substitution Adjunction0 Figure 5: Long distance dependencies in TAGs (What did M. say that J. ate) 1- Sx → Aux NPx VPx (↑Subj)=↓</context>
</contexts>
<marker>Kaplan, Zaenen, 1989</marker>
<rawString>R Kaplan and A. Zaenen. 1989. Long distance dependencies, constituent structure and functional uncertainty. In Alternatives conceptions ofphrase-structure, Univ. of Chicago press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Kinyon</author>
<author>C Prolo</author>
</authors>
<title>A classification of grammar development strategies.</title>
<date>2002</date>
<booktitle>In Proc. GEE-COLING,</booktitle>
<location>Taipei.</location>
<contexts>
<context position="22633" citStr="Kinyon and Prolo, 2002" startWordPosition="3689" endWordPosition="3692">rules. Hence, when generating LFGs, we must make sure that the decorated tree bears a functional uncertainty equation at the site of the extraction. 7 illustrates the generation of such a decorated tree (identical to the TAG tree for ”ate” modulo the functional equations), which will be decomposed into rules 4, 5 and 6.16 16Because the MG does not impose a restricted domain of locality, (Kinyon, 2003) proposes an alternative to functional uncertainty, which we do not present here for space reasons. 6 Advantages of a MetaGrammatical level A first advantage of using a MetaGrammar, discussed in (Kinyon and Prolo, 2002), is that the syntactic phenomena covered are quite systematic: if rules are generated for “transitive-passivewhExtractedByPhrase” (e.g. By whom was the mouse eaten), and if the hierarchy includes ditransitive verbs, then the automatic crossing of phenomena ensures that sentences will be generated for “ditransitive-passive-whExtractedByPhrase” (i.e. By whom was Peter given a present). All rules for word order variations are automatically generated by underspecifying relations between quasi-nodes in the MG hierarchy (e.g. precedence relation between first and second object for ditransitives in </context>
</contexts>
<marker>Kinyon, Prolo, 2002</marker>
<rawString>A. Kinyon and C. Prolo. 2002. A classification of grammar development strategies. In Proc. GEE-COLING, Taipei.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Kinyon</author>
<author>O Rambow</author>
</authors>
<title>Using the metagrammar for parallel multilingual grammar development and generation.</title>
<date>2003</date>
<booktitle>In Proc. ESSLLI workshop on multilingual grammar engineering,</booktitle>
<location>Vienna.</location>
<contexts>
<context position="25205" citStr="Kinyon and Rambow, 2003" startWordPosition="4089" endWordPosition="4092">ntactic phenomena: 50 verb subcategorization frames (including auxiliaries, modals, sentential and infinitival complements), dative-shift for English, clitics (and their placement) for French, passives with and without agent, long distance dependencies (relatives, wh-questions, clefts) and a few idiomatic expressions. A more detailed presentation of the LFG grammar is presented in (Cl´ement and Kinyon, 2003). A more detailed discussion of the cross-language aspects with a comparison to related work such as the LFG ParGram project, or HPSG matrix grammars (Bender et al., 2002) may be found in (Kinyon and Rambow, 2003a)20. The cross-language and cross-framework parallelism is insured by the HyperTags: Most classes in the hierarchy are shared for French and for English. Language specific classes are marked using the binary features “English” and “French” in their HyperTag. So for instance, classes encoding clitic placement are marked [French=+;English=-] and classes pertaining to dative-shift are marked [French=-;English=+]. This prevents the crossing of incompatible classes and hence the generation of incorrect rules (such as “Dative-shift-withCliticizedObject”). Similarly, most classes in the hierarchy ar</context>
</contexts>
<marker>Kinyon, Rambow, 2003</marker>
<rawString>A. Kinyon and O. Rambow. 2003a. Using the metagrammar for parallel multilingual grammar development and generation. In Proc. ESSLLI workshop on multilingual grammar engineering, Vienna.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Kinyon</author>
<author>O Rambow</author>
</authors>
<title>Using the MetaGrammar to generate cross-language and cross-framework annotated testsuites.</title>
<date>2003</date>
<booktitle>In Proc. LINC-EACL,</booktitle>
<location>Budapest.</location>
<contexts>
<context position="25205" citStr="Kinyon and Rambow, 2003" startWordPosition="4089" endWordPosition="4092">ntactic phenomena: 50 verb subcategorization frames (including auxiliaries, modals, sentential and infinitival complements), dative-shift for English, clitics (and their placement) for French, passives with and without agent, long distance dependencies (relatives, wh-questions, clefts) and a few idiomatic expressions. A more detailed presentation of the LFG grammar is presented in (Cl´ement and Kinyon, 2003). A more detailed discussion of the cross-language aspects with a comparison to related work such as the LFG ParGram project, or HPSG matrix grammars (Bender et al., 2002) may be found in (Kinyon and Rambow, 2003a)20. The cross-language and cross-framework parallelism is insured by the HyperTags: Most classes in the hierarchy are shared for French and for English. Language specific classes are marked using the binary features “English” and “French” in their HyperTag. So for instance, classes encoding clitic placement are marked [French=+;English=-] and classes pertaining to dative-shift are marked [French=-;English=+]. This prevents the crossing of incompatible classes and hence the generation of incorrect rules (such as “Dative-shift-withCliticizedObject”). Similarly, most classes in the hierarchy ar</context>
</contexts>
<marker>Kinyon, Rambow, 2003</marker>
<rawString>A. Kinyon and O. Rambow. 2003b. Using the MetaGrammar to generate cross-language and cross-framework annotated testsuites. In Proc. LINC-EACL, Budapest.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Kinyon</author>
</authors>
<title>Hypertags.</title>
<date>2000</date>
<booktitle>In Proc. COLING-00, Sarrebrucken.</booktitle>
<contexts>
<context position="5829" citStr="Kinyon, 2000" startWordPosition="895" endWordPosition="896">, (Candito, 1999) explored whether some components of the hierarchy could be re-used across similar languages (French and Italian). However, she developed two distinct hierarchies to generate grammars for these two languages and generated only TAG grammars. We extend the use of the MetaGrammar to generate LFGs and also push further its cross-language and cross-framework potential by generating parallel TAGs and LFGs for English and French from one single hierarchy 4. 2.1 HyperTags The grammar rules we generate are sorted by syntactic phenomena, thanks to the notion of HyperTag, introduced in (Kinyon, 2000). The main idea behind HyperTags is to keep track, when trees (i.e. grammar rules) are generated from a MetaGrammar hierarchy, of which terminal classes were used for generating the tree. This allows one to obtain a frameworkindependent feature structure containing the salient syntactic characteristics of each grammar rule5. For instance, the verb give in A book was given to Mary could be assigned the HyperTag: Subcat Ditransitive Valency alternations Passive no Agent � � Subject: Canonical NP Argument Realization �Object: Not realized � By-Phrase: Canonical PP Although we retain the linguisti</context>
</contexts>
<marker>Kinyon, 2000</marker>
<rawString>A. Kinyon. 2000. Hypertags. In Proc. COLING-00, Sarrebrucken.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Kinyon</author>
</authors>
<title>MetaGrammars for efficient development, extraction and generation ofparallel grammars.</title>
<date>2003</date>
<tech>Ph.D. thesis,</tech>
<institution>Proposal. Univ. of Pennsylvania.</institution>
<contexts>
<context position="14997" citStr="Kinyon, 2003" startWordPosition="2407" endWordPosition="2408">unctional equations and corresponds to one or more LFG rewriting rules (Figure 1). VP V (TFamily)=SubjObjPrepObj TPred=’x&lt;(TSubj)(TObj)(Tde-Obj)&gt;’ VP —* V PP N2 ↑=↓ (↑(↓ pcase)Obj)=↓ (↑ object)=↓ SubjObjectPrepObject:V (↑ pred = ‘x &lt;(↑ Subj) (↑ Obj) (↑ de-Obj)&gt;’ Figure 3: LFG Rule and a lexical entry In order to generate LFG rules with a MG, we have two options. The first option consists in generating “standard” LFG rules, that is trees of depth 1 decorated with functional equations. Figure 3 illustrates detailed discussion of the (Kaplan and Maxwell, 1996) operators is found in (Cl´ement and Kinyon, 2003). 10Thus the grammars we generate exhibit redundancies for modifiers, but, since the MG hierarchy has relatively few redundancies, and since these grammars are automatically generated, the problem is minor. 11As opposed for instance to lexical organization not only in TAGs and TAG related framework (e.g. DATR (Evans et al., 2000)), but in HPSG (Flickinger, 1987). such as decorated tree, which yields one LFG rewriting rule, and one lexical entry for French verbs such as “´eloigner” ( take away from), which take an NP object and a PP object introduced by “de”. (Ex: “Peter ´eloigne son enfant de </context>
<context position="22414" citStr="Kinyon, 2003" startWordPosition="3655" endWordPosition="3656">ate”) have their arguments realized. The need for functional uncertainty results from the fact that in LFG, contrary to TAGs, the extracted element (NPo) and its governor (Vy) are located in different grammar rules. Hence, when generating LFGs, we must make sure that the decorated tree bears a functional uncertainty equation at the site of the extraction. 7 illustrates the generation of such a decorated tree (identical to the TAG tree for ”ate” modulo the functional equations), which will be decomposed into rules 4, 5 and 6.16 16Because the MG does not impose a restricted domain of locality, (Kinyon, 2003) proposes an alternative to functional uncertainty, which we do not present here for space reasons. 6 Advantages of a MetaGrammatical level A first advantage of using a MetaGrammar, discussed in (Kinyon and Prolo, 2002), is that the syntactic phenomena covered are quite systematic: if rules are generated for “transitive-passivewhExtractedByPhrase” (e.g. By whom was the mouse eaten), and if the hierarchy includes ditransitive verbs, then the automatic crossing of phenomena ensures that sentences will be generated for “ditransitive-passive-whExtractedByPhrase” (i.e. By whom was Peter given a pre</context>
<context position="24993" citStr="Kinyon, 2003" startWordPosition="4054" endWordPosition="4055">89 classes. A fragment of the hierarchy is shown in Figure 8. From this hierarchy, we generate 550 decorated trees, which correspond to approx. 550 TAG trees and 140 LFG rules. We cover the following syntactic phenomena: 50 verb subcategorization frames (including auxiliaries, modals, sentential and infinitival complements), dative-shift for English, clitics (and their placement) for French, passives with and without agent, long distance dependencies (relatives, wh-questions, clefts) and a few idiomatic expressions. A more detailed presentation of the LFG grammar is presented in (Cl´ement and Kinyon, 2003). A more detailed discussion of the cross-language aspects with a comparison to related work such as the LFG ParGram project, or HPSG matrix grammars (Bender et al., 2002) may be found in (Kinyon and Rambow, 2003a)20. The cross-language and cross-framework parallelism is insured by the HyperTags: Most classes in the hierarchy are shared for French and for English. Language specific classes are marked using the binary features “English” and “French” in their HyperTag. So for instance, classes encoding clitic placement are marked [French=+;English=-] and classes pertaining to dative-shift are ma</context>
</contexts>
<marker>Kinyon, 2003</marker>
<rawString>A. Kinyon. 2003. MetaGrammars for efficient development, extraction and generation ofparallel grammars. Ph.D. thesis, Proposal. Univ. of Pennsylvania.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Rogers</author>
<author>K Vijay-Shanker</author>
</authors>
<title>Obtaining trees from their description: an application to TAGS.</title>
<date>1994</date>
<journal>In Computational Intelligence</journal>
<volume>10</volume>
<contexts>
<context position="3770" citStr="Rogers and Vijay-Shanker, 1994" startWordPosition="569" endWordPosition="572"> redistribution of functions • Dimension 3: surface realization of arguments. Each terminal class in dimension 1 encodes an initial subcategorization (i.e. transitive, ditransitive etc...); Each terminal class in dimension 2 - a list of ordered redistributions of functions (e.g. to add an argument for causatives, to erase one for passive with no agents ...); Each terminal class in dimension 3 - the surface realization of a syntactic function (e.g. declares if a direct-object is pronominalized, wh-extracted, etc.). Each class in the hierarchy is associated to the partial description of a tree (Rogers and Vijay-Shanker, 1994) which encodes father, dominance, equality and precedence relations between nodes. A well-formed tree is generated by inheriting from exactly one terminal class from dimension 1, one terminal class from dimension 23, and n terminal classes from dimension 3 (where n is the number of arguments of the elementary tree being generated). For instance, the elementary tree for “Par qui sera accompagn´ee Marie” (By whom will Mary be accompanied) is generated by inheriting from transitive in dimension 1, from passive in dimension 2 and subject-nominal-inverted for its subject and Wh-questioned-object fo</context>
</contexts>
<marker>Rogers, Vijay-Shanker, 1994</marker>
<rawString>J. Rogers and K. Vijay-Shanker. 1994. Obtaining trees from their description: an application to TAGS. In Computational Intelligence 10:4.</rawString>
</citation>
<citation valid="true">
<authors>
<author>B Srinivas</author>
</authors>
<title>Complexity of lexical descriptions and its relevance for partial parsing.</title>
<date>1997</date>
<tech>Ph.D. thesis,</tech>
<institution>Univ. of Pennsylvania.</institution>
<contexts>
<context position="7248" citStr="Srinivas, 1997" startWordPosition="1116" endWordPosition="1117">sions for the realization of predicates as well as modifiers. Moreover, we use a different MetaGrammar tool which is less framework-dependent and supports the notion of HyperTag. 2.2 The LORIA MetaGrammar tool To generate TAGs and LFGs, we use the MG compiler presented in (Gaiffe et al., 2002)6. Each class in the MG hierarchy encodes: • Its SuperClasse(s) • A HyperTag which captures the salient linguistic characteristics of that class. 4We also generate Range Concatenation Grammars (Boullier, 1998), but do not develop this point here. 5The notion of HyperTag was inspired by that of supertags (Srinivas, 1997), which consists in assigning a TAG elementary tree to lexical items, hence enriching traditional POS tagging. However, HyperTags are framework-independent. 6This compiler is freely available on http://www.loria.fr/equipes/led/outils/mgc/mgc.html • What the class needs and provides. • A set of quasi-nodes (i.e. variables) • Topological relations between these nodes (father, dominates, precedes, equals)7 • A function for each quasi-nodes to decorate the tree (e.g. traditional agreement features and/or LFG functional equations). The MG tool automatically crosses the nodes in the hierarchy, looki</context>
</contexts>
<marker>Srinivas, 1997</marker>
<rawString>B. Srinivas. 1997. Complexity of lexical descriptions and its relevance for partial parsing. Ph.D. thesis, Univ. of Pennsylvania.</rawString>
</citation>
<citation valid="true">
<authors>
<author>F Xia</author>
</authors>
<title>Automatic grammar generation from two perspectives.</title>
<date>2001</date>
<tech>Ph.D. thesis,</tech>
<institution>Univ. of Pennsylvania.</institution>
<contexts>
<context position="4699" citStr="Xia, 2001" startWordPosition="719" endWordPosition="720">ng generated). For instance, the elementary tree for “Par qui sera accompagn´ee Marie” (By whom will Mary be accompanied) is generated by inheriting from transitive in dimension 1, from passive in dimension 2 and subject-nominal-inverted for its subject and Wh-questioned-object for its object in dimension 3. This particular tool was used to develop from a compact hand-coded hierarchy of a few dozen nodes, a wide-coverage TAG for French of 5000 elementary trees (Abeill´e et al., 1999), as well as a medium-size 2A Similar MetaGrammar type of organization for TAGs was independently presented in (Xia, 2001) for English. 3This terminal class may be the result of the crossing of several super-classes, to handle complex phenomena such as Passive+Causative. TAG for Italian (Candito, 1999). The compactness of the hierarchy is due to the fact that nodes are defined only for simple syntactic phenomena: classes for complex syntactic phenomena (e.g. Topicalizedobject+Pronominalized) are generated by automatic crossings of classes for simple phenomena. In addition to proposing a compact representation of syntactic knowledge, (Candito, 1999) explored whether some components of the hierarchy could be re-use</context>
</contexts>
<marker>Xia, 2001</marker>
<rawString>F. Xia. 2001. Automatic grammar generation from two perspectives. Ph.D. thesis, Univ. of Pennsylvania.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>