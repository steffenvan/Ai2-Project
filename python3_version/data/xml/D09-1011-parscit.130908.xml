<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000003">
<title confidence="0.979932">
Graphical Models over Multiple Strings∗
</title>
<author confidence="0.997105">
Markus Dreyer and Jason Eisner
</author>
<affiliation confidence="0.99961">
Department of Computer Science / Johns Hopkins University
</affiliation>
<address confidence="0.794815">
Baltimore, MD 21218, USA
</address>
<email confidence="0.998778">
{markus,jason}@cs.jhu.edu
</email>
<sectionHeader confidence="0.984911" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999896684210526">
We study graphical modeling in the case of string-
valued random variables. Whereas a weighted
finite-state transducer can model the probabilis-
tic relationship between two strings, we are inter-
ested in building up joint models of three or more
strings. This is needed for inflectional paradigms
in morphology, cognate modeling or language re-
construction, and multiple-string alignment. We
propose a Markov Random Field in which each
factor (potential function) is a weighted finite-state
machine, typically a transducer that evaluates the
relationship between just two of the strings. The
full joint distribution is then a product of these fac-
tors. Though decoding is actually undecidable in
general, we can still do efficient joint inference
using approximate belief propagation; the nec-
essary computations and messages are all finite-
state. We demonstrate the methods by jointly pre-
dicting morphological forms.
</bodyText>
<sectionHeader confidence="0.992169" genericHeader="keywords">
1 Overview
</sectionHeader>
<bodyText confidence="0.9998623">
This paper considers what happens if a graphical
model’s variables can range over strings of un-
bounded length, rather than over the typical finite
domains such as booleans, words, or tags. Vari-
ables that are connected in the graphical model are
related by some weighted finite-state transduction.
Graphical models have become popular in ma-
chine learning as a principled way to work with
collections of interrelated random variables. Most
often they are used as follows:
</bodyText>
<listItem confidence="0.997366666666667">
1. Build: Manually specify the n variables of
interest; their domains; and the possible di-
rect interactions among them.
2. Train: Train this model’s parameters θ to
obtain a specific joint probability distribution
p(Vi, ... , Vn) over the n variables.
3. Infer: Use this joint distribution to predict
the values of various unobserved variables
from observed ones.
</listItem>
<footnote confidence="0.576788333333333">
∗Supported by the Human Language Technology Center
of Excellence at Johns Hopkins University, and by National
Science Foundation grant No. 0347822 to the second author.
</footnote>
<bodyText confidence="0.808407">
Note that 1. requires intuitions about the domain;
</bodyText>
<listItem confidence="0.957661666666667">
2. requires some choice of training procedure; and
3. requires a choice of exact or approximate infer-
ence algorithm.
</listItem>
<bodyText confidence="0.967697">
Our graphical models over strings are natural
objects to investigate. We motivate them with
some natural applications in computational lin-
guistics (section 2). We then give our formalism:
a Markov Random Field whose potential functions
are rational weighted languages and relations (sec-
tion 3). Next, we point out that inference is in gen-
eral undecidable, and explain how to do approxi-
mate inference using message-passing algorithms
such as belief propagation (section 4). The mes-
sages are represented as weighted finite-state ma-
chines.
Finally, we report on some initial experiments
using these methods (section 7). We use incom-
plete data to train a joint model of morphological
paradigms, then use the trained model to complete
the data by predicting unseen forms.
</bodyText>
<sectionHeader confidence="0.991467" genericHeader="introduction">
2 Motivation
</sectionHeader>
<bodyText confidence="0.9986975">
The problem of mapping between different forms
and representations of strings is ubiquitous in nat-
ural language processing and computational lin-
guistics. This is typically done between string
pairs, where a pronunciation is mapped to its
spelling, an inflected form to its lemma, a spelling
variant to its canonical spelling, or a name is
transliterated from one alphabet into another.
However, many problems involve more than just
two strings:
</bodyText>
<listItem confidence="0.989930909090909">
• in morphology, the inflected forms of a (possi-
bly irregular) verb are naturally considered to-
gether as a whole morphological paradigm in
which different forms reinforce one another;
• mapping an English word to its foreign translit-
eration may be easier when one considers the
orthographic and phonological forms of both
words;
• similar cognates in multiple languages are nat-
urally described together, in orthographic or
phonological representations, or both;
</listItem>
<page confidence="0.982172">
101
</page>
<note confidence="0.9941265">
Proceedings of the 2009 Conference on Empirical Methods in Natural Language Processing, pages 101–110,
Singapore, 6-7 August 2009. c�2009 ACL and AFNLP
</note>
<listItem confidence="0.8760778">
• modern and ancestral word forms form a phylo-
genetic tree in historical linguistics;
• in bioinformatics and in system combination,
multiple sequences need to be aligned in order
to identify regions of similarity.
</listItem>
<bodyText confidence="0.999158428571429">
We propose a unified model for multiple strings
that is suitable for all the problems mentioned
above. It is robust and configurable and can
make use of task-specific overlapping features. It
learns from observed and unobserved, or latent, in-
formation, making it useful in supervised, semi-
supervised, and unsupervised settings.
</bodyText>
<sectionHeader confidence="0.999267" genericHeader="method">
3 Formal Modeling Approach
</sectionHeader>
<subsectionHeader confidence="0.938227">
3.1 Variables
</subsectionHeader>
<bodyText confidence="0.999957333333333">
A Markov Random Field (MRF) is a joint model
of a set of random variables, V = {V1, ... , Vn}.
We assume that all variables are string-valued, i.e.
the value of Vi may be any string E E∗i, where Ei
is some finite alphabet.
We may use meaningful names for the integers
i, such as V2SA for the 2nd singular past form of a
verb.
The assumption that all variables are string-
valued is not crucial; it merely simplifies our
presentation. It is, however, sufficient for many
practical purposes, since most other discrete ob-
jects can be easily encoded as strings. For exam-
ple, if V1 is a part of speech tag, it may be en-
coded as a length-1 string over the finite alphabet
</bodyText>
<equation confidence="0.7211575">
def
E1 = {Noun, Verb, ...}.
</equation>
<subsectionHeader confidence="0.974412">
3.2 Factors
</subsectionHeader>
<bodyText confidence="0.9956675">
A Markov Random Field defines a probability for
each assignment A of values to the variables in V:
</bodyText>
<equation confidence="0.955824666666667">
11m
p(A) def = 1
Z j=1
</equation>
<bodyText confidence="0.9996124">
This distribution over assignments is specified by
the collection of factors Fj : A H R&gt;0. Each
factor (or potential function) is a function that de-
pends on only a subset of A.
Fig. 1 displays an undirected factor graph, in
which each factor is connected to the variables
that it depends on. F1, F3, F5 in this example are
unary factors because each one scores the value
of a single variable, while F2, F4, F6 are binary
factors.
</bodyText>
<figureCaption confidence="0.99837">
Figure 1: Example of a factor graph. Black boxes represent
factors, circles represent variables (infinitive, 2nd past, and
3rd present-tense forms of the same verb; different samples
from the MRF correspond to different verbs). Binary factors
evaluate how well one string can be transduced into another,
summing over all transducer paths (i.e., alignments, which
are not observed in training).
</figureCaption>
<bodyText confidence="0.999917833333333">
In our setting, we will assume that each unary
factor is specified by a weighted finite-state au-
tomaton (WFSA) whose weights fall in the semir-
ing (R&gt;0, +, ×). Thus the score F3(..., V2SA =
x,...) is the total weight of all paths in the F3’s
WFSA that accept the string x E E∗2SA. Each
path’s weight is the product of its component arcs’
weights, which are non-negative.
Similarly, we assume that each binary factor is
specified by a weighted finite-state transducer
(WFST). Such a model is essentially a generaliza-
tion of stochastic edit distance (Ristad and Yian-
ilos, 1996) in which the edit probabilities can be
made sensitive to a finite summary of context.
Formally, a WFST is an automaton that resem-
bles a weighted FSA, but it nondeterministically
reads two strings x, y in parallel from left to right.
The score of (x, y) is given by the total weight of
all accepting paths in the WFST that map x to y.
For example, different paths may consider various
monotonic alignments of x with y, and we sum
over these mutually exclusive possibilities.1
A factor might depend on k &gt; 2 variables. This
requires a k-tape weighted finite-state machine
(WFSM), an obvious generalization where each
path reads k strings in some alignment.2
To ensure that Z is finite in equation (1), we can
require each factor to be a “proper” WFSM, i.e.,
its accepting paths have finite total weight (even if
the WFSM is cyclic, with infinitely many paths).
</bodyText>
<footnote confidence="0.956235">
1Each string is said to be on a different “tape,” which has
its own “read head,” allowing the WFSM to maintain a sep-
arate position in each string. Thus, a path in a WFST may
consume any number of characters from x before consuming
the next character from y.
2Weighted acceptors and transducers are the cases k = 1
and k = 2, which are said to define rational languages and
rational relations.
</footnote>
<equation confidence="0.991651857142857">
F1
Vinf
F2 F6
V2SA V3SE
Fa
F3 F5
Fj(A) (1)
</equation>
<page confidence="0.994514">
102
</page>
<subsectionHeader confidence="0.994501">
3.3 Parameters
</subsectionHeader>
<bodyText confidence="0.99994925">
Our probability model has trainable parameters: a
vector of feature weights 0 ∈ R. Each arc in each
WFSM has a real-valued weight that depends on 0.
Thus, tuning 0 during training will change the arc
weights, hence the path weights, the factor func-
tions, and the whole probability distribution p(A).
Designing the probability model includes spec-
ifying the topology and weights of each WFSM.
Eisner (2002) explains how to specify and train
such parameterized WFSMs. Typically, the
weight of an arc is a simple sum like 012 + 055 +
072, where 012 is included on all arcs that share
feature 12. However, more interesting parameter-
izations arise if the WFSM is constructed by op-
erations such as transducer composition, or from a
weighted regular expression.
</bodyText>
<subsectionHeader confidence="0.996899">
3.4 Power of the formalism
</subsectionHeader>
<bodyText confidence="0.999935739130435">
Factored finite-state string models (1) were orig-
inally suggested by the second author, in Kempe
et al. (2004). That paper showed that even in the
unweighted case, such models could be used to en-
code relations that could not be recognized by any
k-tape FSM. We offer a more linguistic example
as a small puzzle. We invite the reader to spec-
ify a factored model (consisting of three FSTs as
in Fig. 1) that assigns positive probability to just
those triples of character strings (x, y, z) that have
the form (red ball, ball red, red), (white house,
house white, white), etc. This uses the auxiliary
variable Z to help encode a relation between X
and Y that swaps words of unbounded length. By
contrast, no FSM can accomplish such unbounded
swapping, even with 3 or more tapes.
Such extra power might be linguistically useful.
Troublingly, however, Kempe et al. (2004) also
observed that the framework is powerful enough to
express computationally undecidable problems.3
This implies that to work with arbitrary models,
we will need approximate methods.4 Fortunately,
the graphical models community has already de-
</bodyText>
<footnote confidence="0.723325545454545">
3Consider a simple model with two variables and two bi-
nary factors: p(V1, V2) =def 1 · F1(V1, V2) · F2(V1, V2). Sup-
pose F1 is 1 or 0 according to whether its arguments are
equal. Under this model, p(e) &lt; 1 iff there exists a string
x =� e that can be transduced to itself by the unweighted
transducer F2. This question can be used to encode any in-
stance of Post’s Correspondence Problem, so is undecidable.
4Notice that the simplest approximation to cure undecid-
ability would be to impose an arbitrary maximum on string
length, so that the random variables have a finite domain, just
as in most discrete graphical models.
</footnote>
<equation confidence="0.886552666666667">
l-LV--+F l-LF--+U
U
F
</equation>
<figureCaption confidence="0.981939666666667">
Figure 2: Illustration of messages being passed from variable
to factor and factor to variable. Each message is represented
by a finite-state acceptor.
</figureCaption>
<bodyText confidence="0.906416666666667">
veloped many such methods, to deal with the com-
putational intractability (if not undecidability) of
exact inference.
</bodyText>
<sectionHeader confidence="0.982967" genericHeader="method">
4 Approximate Inference
</sectionHeader>
<bodyText confidence="0.999637666666667">
In this paper, we focus on how belief propagation
(BP)—a simple well-known method for approxi-
mate inference in MRFs (Bishop, 2006)—can be
used in our setting. BP in its general form has
not yet been widely used in the NLP community.5
However, it is just a generalization to arbitrary
factor graphs of the familiar forward-backward al-
gorithm (which operates only on chain-structured
factor graphs). The algorithm becomes approxi-
mate (and may not even converge) when the factor
graphs have cycles. (In that case it is more prop-
erly called “loopy belief propagation.”)
</bodyText>
<subsectionHeader confidence="0.998924">
4.1 Belief propagation
</subsectionHeader>
<bodyText confidence="0.9999547">
We first sketch how BP works in general. Each
variable V in the graphical model maintains a be-
lief about its value, in the form of a marginal dis-
tribution ˜pV over the possible values of V . The
final beliefs are the output of the algorithm.
Beliefs arise from messages that are sent be-
tween the variables and factors along the edges of
the factor graph. Variable V sends factor F a mes-
sage AV ,F, which is an (unnormalized) probabil-
ity distribution over V ’s values v, computed by
</bodyText>
<equation confidence="0.987786">
AF1,V (v) (2)
F&apos;EN(V ),F&apos;�F
</equation>
<bodyText confidence="0.992972714285714">
where N is the set of neighbors of V in the graph-
ical model. This message represents a consensus
of V ’s other neighboring factors concerning V ’s
value. It is how V tells F what its belief ˜pV would
be if F were absent. Informally, it communicates
to F: Here is what my value would be if it were up
to my other neighboring factors F&apos; to determine.
</bodyText>
<footnote confidence="0.9904695">
5Notable exceptions are Sutton et al. (2004) for chunking
and tagging, Sutton and McCallum (2004) for information
extraction, Smith and Eisner (2008) for dependency parsing,
and Cromier`es and Kurohashi (2009) for alignment.
</footnote>
<equation confidence="0.980197">
V
AV,F (v) :=
</equation>
<page confidence="0.982093">
103
</page>
<bodyText confidence="0.998209">
The factor F can then collect such incoming
messages from neighboring variables and send its
own message on to another neighbor U. Such a
message AF,U suggests good values for U, in the
form of an (unnormalized) distribution over U’s
values u, computed by
</bodyText>
<equation confidence="0.585853666666667">
�AF ,U(u) := F(A) � AU&apos;,F (A[U&apos;])
A s.t.A[U]=u U&apos;EN(F),U&apos;�U
(3)
</equation>
<bodyText confidence="0.996947714285714">
where A is an assignment to all variables, and
A[U] is the value of variable U in that assign-
ment. This message represents F’s prediction of
U’s value based on its other neighboring variables
U&apos;. Informally, via this message, F tells U: Here
is what I would like your value to be, based on
the messages that my other neighboring variables
have sent me about their values, and how I would
prefer you to relate to them.
Thus, each edge of the factor graph maintains
two messages AV ,F, AF,V . All messages are
updated repeatedly, in some order, using the two
equations above, until some stopping criterion is
reached.6 The beliefs are then computed:
</bodyText>
<equation confidence="0.991632">
�˜pV (v) def = AF,V (v) (4)
FEN(V)
</equation>
<bodyText confidence="0.999861555555556">
If variable V is observed, then the right-hand
sides of equations (2) and (4) are modified to tell
V that it must have the observed value v. This is
done by multiplying in an extra message Aobs,V
that puts probability 1 on v7 and 0 on other val-
ues. That affects other messages and beliefs. The
final belief at each variable estimates its posterior
marginal under the MRF (1), given all observa-
tions.
</bodyText>
<subsectionHeader confidence="0.998277">
4.2 Finite-state messages in BP
</subsectionHeader>
<bodyText confidence="0.9942938">
Both AV,F and AF,V are unnormalized distribu-
tions over the possible values of V—in our case,
strings. A distribution over strings is naturally
represented by a WFSA. Thus, belief propagation
translates to our setting as follows:
</bodyText>
<listItem confidence="0.998445333333333">
• Each message is a WFSA.
• Messages are typically initialized to a one-state
WFSA that accepts all strings in E*, each with
</listItem>
<footnote confidence="0.997496">
6Preferably when the beliefs converge to some fixed point
(a local minimum of the Bethe free energy). However, con-
vergence is not guaranteed.
7More generally, on all possible observed variables.
</footnote>
<construct confidence="0.292142">
weight 1.8
</construct>
<listItem confidence="0.9416586">
• Taking a pointwise product of messages to V in
equation (2) corresponds to WFSA intersection.
• If F in equation (3) is binary,9 then there is only
one U&apos;. Then the outgoing message AF,U, a
WFSA, is computed as domain(F o AU&apos;,F).
</listItem>
<bodyText confidence="0.98377725">
Here o composes the factor WFST with the in-
coming message WFSA, yielding a WFST that
gives a joint distribution over (U, U&apos;). The
domain operator projects this WFST onto the U
side to obtain a WFSA, which corresponds to
marginalizing to obtain a distribution over U.
• In general, F is a k-tape WFSM. Equation (3)
“composes” k − 1 of its tapes with k − 1 in-
coming messages AU&apos;,F, to construct a joint
distribution over the k variables in N(F), then
projects onto the kth tape to marginalize over the
k −1 U&apos; variables and get a distribution over U.
All this can be accomplished by the WFSM gen-
eralized composition operator ® (Kempe et al.,
2004).
After projecting, it is desirable to determinize
the WFSA. Otherwise, the summation in (3) is
only implicit—the summands remain as distinct
paths in the WFSA10—and thus the WFSAs would
get larger and larger as BP proceeds. Unfortu-
nately, determinizing a WFSA still does not guar-
antee a small result. In fact it can lead to expo-
nential blowup, or even infinite blowup.11 Thus,
in practice we recommend against determinizing
the messages, which may be inherently complex.
To shrink a message, it is safer to approximate it
with a small deterministic WFSA, as discussed in
the next section.
</bodyText>
<subsectionHeader confidence="0.999985">
4.3 Approximation of messages
</subsectionHeader>
<bodyText confidence="0.99984875">
In our domain, it is possible for the finite-state
messages to grow unboundedly in size as they flow
around a cycle. After all, our messages are not
just multinomial distributions over a fixed finite
</bodyText>
<footnote confidence="0.913940923076923">
8This is an (improper) uniform distribution over Σ*. Al-
though is not a proper WFSA (see section 3.2), there is an
upper bound on the weights it assigns to strings. That guar-
antees that all the messages and beliefs computed by (2)–(4)
will be proper FSMs, provided that all the factors are proper
WFSMs.
9If it is unary, (3) trivially reduces to AF—.U = F.
10The usual implementation of projection does not change
the topology of the WFST, but only deletes the U&apos; part of its
arc labels. Thus, multiple paths that accept the same value of
U remain distinct according to the distinct values of U&apos; that
they were paired with before projection.
11If there is no deterministic equivalent (Mohri, 1997).
</footnote>
<page confidence="0.997953">
104
</page>
<bodyText confidence="0.999864678571428">
set. They are distributions over the infinite set E∗.
A WFSA represents this in finite space, but more
complex distributions require bigger WFSAs, with
more distinct states and arc weights.
Facing the same problem for distributions over
the infinite set R, Sudderth et al. (2002) simplified
each message µV →F, approximating a complex
Gaussian mixture by using fewer components.
We could act similarly, variationally approxi-
mating a large WFSA P with a smaller one Q.
Choose a family of message approximations (such
as bigram models) by specifying the topology for
a (small) deterministic WFSA Q. Then choose
Q’s edge weights to minimize the KL divergence
KL(P 11 Q). This can be done in closed form.12
Another possible procedure—used in the ex-
periments of this paper—approximates µV →F by
pruning it back to a finite set of most plausible
strings.13 Equation (2) requests an intersection
of several WFSAs, e.g., µF1→V n µF2→V n · · · .
List all strings that appear on any of the 1000-
best paths in any of these WFSAs, removing du-
plicates. Let Q be a uniform distribution over this
combined list of plausible strings, represented as
a determinized, minimized, acyclic WFSA. Now
approximate the intersection of equation (2) as
(( Q¯ n µF1→V ) n µF2→V ) n · · · . This is efficient
to compute and has the same topology as ¯Q.
</bodyText>
<sectionHeader confidence="0.993831" genericHeader="method">
5 Training the Model Parameters
</sectionHeader>
<bodyText confidence="0.9661825">
Any standard training method for MRFs will
transfer naturally to our setting. In all cases we
draw on Eisner (2002), who showed how to train
the parameters θ of a single WFST, F, to (locally)
maximize the joint or conditional probability of
fully or partially observed training data. This in-
volves computing the gradient of that likelihood
function with respect to θ.14
12See Li et al. (2009, footnote 9) for a sketch of the con-
struction, which finds locally normalized edge weights. Or
if Q is large but parameterized by some compact parameter
vector 0, so we are only allowed to control its edge weights
via 0, then Li and Eisner (2009, section 6) explain how to
minimize KL(P 11 Q) by gradient descent. In both cases Q
must be deterministic.
We remark that if a factor F were specified by a syn-
chronous grammar rather than a WFSM, then its outgoing
messages would be weighted context-free languages. Exact
intersection of these is undecidable, but they too can be ap-
proximated variationally by WFSAs, with the same methods.
13We are also considering other ways of adaptively choos-
ing the topology of WFSA approximations at runtime, partic-
ularly in conjunction with expectation propagation.
14The likelihood is usually non-convex; even when the
two strings are observed (supervised training), their accepting
We must generalize this to train a product of
WFSMs. Typically, training data for an MRF (1)
consists of some fully or partially observed IID
samples of the joint distribution p(V1, ... Vn). It
is well-known how to tune an MRF’s parameters θ
by stochastic gradient descent to locally maximize
the probability of this training set, even though
both the probability and its gradient are in general
intractable to compute in an MRF. The gradient is
a sum of quantities, one for each factor Fj. While
the summand for Fj cannot be computed exactly,
it can be estimated using the BP messages to Fj.
Roughly speaking, the gradient for Fj is computed
much as in supervised training (see above), but
treating any message µV,→F; as an uncertain ob-
servation of Vi—a form of noisy supervision.15
Our concerns about training are the same as
for any MRF. First of all, BP is approximate.
Kulesza and Pereira (2008) warn that its estimates
of the gradient can be misleading. Second, semi-
supervised training (which we will attempt below)
is always difficult and prone to local optima. As
in EM, a small number of supervised examples for
some variable may be drowned out by many nois-
ily reconstructed examples.
Faster and potentially more stable approaches
include the piecewise training methods of Sut-
ton and McCallum (2008), which train the factors
independently or in small groups. In the semi-
supervised case, each factor can be trained on only
the supervised forms available for it. It might be
useful to reweight the trained factors (cf. Smith et
al. (2005)), or train the factors consecutively (cf.
Fahlman and Lebiere (1990)), in a way that mini-
mizes the loss of BP decoding on held-out data.
</bodyText>
<sectionHeader confidence="0.920866" genericHeader="method">
6 Comparison With Other Approaches
</sectionHeader>
<subsectionHeader confidence="0.978824">
6.1 Multi-tape WFSMs
</subsectionHeader>
<bodyText confidence="0.994485454545455">
In principle, one could use a 100-tape WFSM to
jointly model the 100 distinct forms of a typical
Polish verb. In other words, the WFSM would de-
scribe the distribution of a random variable V~ =
(V1, . . . , V100), where each Vi is a string. One
would train the parameters of the WFSM on a
~
sample of V, each sample being a fully or partially
observed paradigm for some Polish verb. The re-
sulting distribution could be used to infer missing
forms for these or other verbs.
</bodyText>
<footnote confidence="0.637744666666667">
path through the WFST may be ambiguous and unobserved.
15See Bishop (2006), or consult Smith and Eisner (2008)
for notation close to that of this paper.
</footnote>
<page confidence="0.997459">
105
</page>
<bodyText confidence="0.999903217391304">
As a simple example, either a morphological
generator or a morphological analyzer might need
the probability that krzyczałoby is the neuter third-
person singular conditional imperfective of krzy-
cze´c, despite never having observed it in training.
The model determines this probability based on
other observed and hypothesized forms of krzy-
cze´c, using its knowledge of how neuter third-
person singular conditional imperfectives are re-
lated to these other forms in other verbs.
Unfortunately, such a 100-tape WFSM would
be huge, with an astronomical number of arcs
(each representing a possible 100-way edit opera-
tion). Our approach is to factor the problem into a
number of (e.g.) pairwise relationships among the
verb forms. Using a factored distribution has sev-
eral benefits over the k-tape WFSM: (1) a smaller
representation in memory, (2) a small number
of parameters to learn, (3) efficient approximate
computation that takes advantage of the factored
structure, (4) the ability to reuse WFSAs and WF-
STs previously developed for smaller problems,
(5) additional modeling power.
</bodyText>
<subsectionHeader confidence="0.998036">
6.2 Simpler graphical models on strings
</subsectionHeader>
<bodyText confidence="0.999447948717948">
Some previous researchers have used factored
joint models of several strings. To our knowledge,
they have all chosen acyclic, directed graphical
models. The acyclicity meant that exact inference
was at least possible for them, if not necessarily ef-
ficient. The factors in these past models have been
WFSTs (though typically simpler than the ones we
will use).
Many papers have used cascades of probabilis-
tic finite-state transducers. Such a cascade may
be regarded as a directed graphical model with a
linear-chain structure. Pereira and Riley (1997)
built a speech recognizer in this way, relating
acoustic to phonetic to lexical strings. Simi-
larly, Knight and Graehl (1997) presented a gen-
erative cascade using 4 variables and 5 factors:
p(w, e,j,k,o) def= p(w)·p(e  |w)·p(j  |e)·p(k  |j)
·p(o  |k) where e is an English word sequence, w
its pronunciation, j a Japanese version of the pro-
nunciation, k a katakana rendering of the Japanese
pronunciation, and o an OCR-corrupted version of
the katakana. Knight and Graehl used finite-state
operations to perform inference at test time, ob-
serving o and recovering the most likely w, while
marginalizing out e, j, and k.
Bouchard-Cˆot´e et al. (2009) reconstructed an-
cient word forms given modern equivalents. They
used a directed graphical model, whose tree struc-
ture reflected the evolutionary development of the
modern languages, and which included latent vari-
ables for historical intermediate forms that were
never observed in training data. They used Gibbs
sampling rather than an exact solution (possible on
trees) or a variational approximation (like our BP).
Our work seeks to be general in terms of the
graphical model structures used, as well as effi-
cient through the use of BP with approximate mes-
sages. We also seek to avoid local normalization,
using a globally normalized model.16
</bodyText>
<subsectionHeader confidence="0.996415">
6.3 Unbounded objects in graphical models
</subsectionHeader>
<bodyText confidence="0.99997">
We distinguish our work from “dynamic” graph-
ical models such as Dynamic Bayesian Networks
and Conditional Random Fields, where the string
brechen would be represented by creating 7 letter-
valued variables. Those methods can represent
strings (or paths) of any length—but the length for
each training or test string must be specified in ad-
vance, not inferred. Furthermore, it is awkward
and costly to model unknown alignments, since
the variables are position-specific, and any posi-
tion in brechen could in principle align with any
position in brichst. WFSTs are a much more natu-
ral and flexible model of string pairs.
We also distinguish our work from current non-
parametric Bayesian models, which sometimes
generate unbounded strings, trees, or grammars. If
they generate two unbounded objects, they model
their relationship by a single synchronous genera-
tion process (akin to Section 6.1), rather than by
a globally normalized product of overlapping fac-
tors.
</bodyText>
<sectionHeader confidence="0.999039" genericHeader="evaluation">
7 Experiments
</sectionHeader>
<bodyText confidence="0.973238">
To study our approach, we conducted initial ex-
periments that reconstruct missing word forms in
morphological paradigms. In inflectional mor-
phology, each uninflected verb form (lemma) is
associated with a vector of forms that are inflected
for tense, person, number, etc. Some inflected
forms may be observed frequently in natural text,
others rarely. Two variables that are usually pre-
dictable from each other may or may not keep this
relationship in the case of an irregular verb.
16Although we do normalize locally during piecewise
training (see section 7.3).
</bodyText>
<page confidence="0.986821">
106
</page>
<figure confidence="0.994325">
(a) # paradigms 9,393
(b) # finite forms per paradigm 9
(c) # hidden finite forms per paradigm (avg.) 8.3
(d) # paradigms with some finite form(s) observed 2,176
(e) In (d), # of finite forms observed (avg.) 3.4
</figure>
<tableCaption confidence="0.985673">
Table 1: Statistics of our training data.
</tableCaption>
<bodyText confidence="0.956413166666667">
Our task is to reconstruct (generate) specific un-
observed morphological forms in a paradigm by
learning from observed ones. This is a particu-
larly interesting semisupervised scenario, because
different subsets of the variables are observed on
different examples.
</bodyText>
<subsectionHeader confidence="0.978978">
7.1 Experimental data
</subsectionHeader>
<bodyText confidence="0.999556416666667">
We used orthographic rather than phonological
forms. We extracted morphological paradigms for
all 9393 German verbs in the CELEX morpholog-
ical database. Each paradigm lists 5 present-tense
and 4 past-tense indicative forms, as well as the
verb’s lemma, for a total of 10 string-valued vari-
ables.17 In each paradigm, we removed, or hid,
verb forms that occur only rarely in natural text,
i.e, verb forms with a small frequency figure pro-
vided by CELEX.18 All paradigms other than sein
(’to be’) were now incompletely observed. Table 1
gives some statistics.
</bodyText>
<subsectionHeader confidence="0.999531">
7.2 Model factors and parameters
</subsectionHeader>
<bodyText confidence="0.990793269230769">
Our current MRF uses only binary factors. Each
factor is a WFST that is trained to relate 2 of the 10
variables (morphological forms). Each WFST can
score an aligned pair using a log-linear model that
counts features in a sliding 3-character window.
To score an unaligned pair, it sums over all pos-
sible alignments. Specifically, our WFST topol-
ogy and parameterization follow the state-of-the-
art approach to supervised morphology in Dreyer
et al. (2008), although we dropped some of their
features to speed up these early experiments.19 We
17Some pairs of forms are always identical in German,
hence are treated as a single form by CELEX. We likewise
use a single variable—these are the “1,3” variables in Fig. 3.
Occasionally a form is listed as UNKNOWN. We neither
train nor evaluate on such forms, although the model will still
predict them.
18The frequency figure for each word form is based on
counts in the Mannheim News corpus. We hide forms with
frequency &lt; 10.
19We dropped their latent classes and regions as well as
features that detected which characters were orthographic
vowels. Also, we retained their “target language model fea-
tures” only in the baseline “U” model, since elsewhere they
implemented and manipulated all WFSMs using
the OpenFST library (Allauzen et al., 2007).
</bodyText>
<subsectionHeader confidence="0.87565">
7.3 Training in the experiments
</subsectionHeader>
<bodyText confidence="0.989675588235294">
We trained 0 on the incompletely observed
paradigms. As suggested in section 5, we used
a variant of piecewise pseudolikelihood training
(Sutton and McCallum, 2008). Suppose there is
a binary factor F attached to forms U and V . For
any value of 0, we can define pUV (U  |V ) from
the tiny MRF consisting only of U, V , and F.
def
We can therefore compute the goodness LUV =
log pUV (ui  |vi)+logV U(vi  |ui),20 summed over
all observed (U, V ) pairs in training data. We at-
tempted to tune 0 to maximize the total LUV over
all U, V pairs,21 regularized by subtracting ||0||2.
Note that different factors thus enjoyed different
amounts of observed training data, but training
was fully supervised (except for the unobserved
alignments between ui and vi).
</bodyText>
<subsectionHeader confidence="0.756295">
7.4 Inference in the experiments
</subsectionHeader>
<bodyText confidence="0.995330888888889">
At test time, we are given each lemma (e.g.
brechen) and all its observed (frequent) inflected
forms (e.g., brachen, bricht,... ), and are asked to
predict the remaining (rarer) forms (e.g., breche,
brichst, ... ).
We run approximate joint inference using be-
lief propagation.22 We extract our output from the
final beliefs: for each unseen variable V , we pre-
seemed to hurt in our current training setup.
We followed Dreyer et al. (2008) in slightly pruning the
space of possible alignments. We compensated by replacing
their WFST, F, with the union F U 10−12(0.999E x E)∗.
This ensured that the factor could still map any string to any
other string (though perhaps with very low weight), guaran-
teeing that the intersection at the end of section 4.3 would be
non-empty.
20The second term is omitted if V is the lemma. We do
not train the model to predict the lemma since it is always
observed in test data.
21Unfortunately, just before press time we discovered that
this was not quite what we had done. A shortcut in our im-
plementation trained puv(U  |V ) and pvu(V  |U) sepa-
rately. This let them make different use of the (unobserved)
alignments—so that even if each individually liked the pair
(u, v), they might not have been able to agree on the same
accepting path for it at test time. This could have slightly
harmed our joint inference results, though not our baselines.
22To derive the update order for message passing, we take
an arbitrary spanning tree over the factor graph, and let O be
a list of all factors and variables that is topologically sorted
according to the spanning tree, with the leaves of the tree
coming first. We then discard the spanning tree. A single it-
eration visits all factors and variables in order of O, updating
each one’s messages to later variables and factors, and then
visits all factors and variables in reverse order, updating each
one’s messages to earlier variables and factors.
</bodyText>
<page confidence="0.997521">
107
</page>
<bodyText confidence="0.999950833333333">
dict its value to be argmaxv ˜pV (v). This predic-
tion considers the values of all other unseen vari-
ables but sums over their possibilities. This is the
Bayes-optimal decoder for our scoring function,
since that function reports the fraction of individ-
ual forms that were predicted perfectly.23
</bodyText>
<subsectionHeader confidence="0.986953">
7.5 Model selection of MRF topology
</subsectionHeader>
<bodyText confidence="0.999995541666667">
It is hard to know a priori what the causal relation-
ships might be in a morphological paradigm. In
principle, one would like to automatically choose
which factors to have in the MRF. Or one could
start with many factors, but use methods such as
those suggested in section 5 to learn that certain
less useful factors should be left weak to avoid
confusing loopy BP.
For our present experiments, we simply com-
pared several fixed model topologies (Fig. 3).
These were variously unconnected (U), chain
graphs (C1,..., C4), trees (T1, T2), or loopy
graphs (L1,..., L4). We used several factor graphs
that differ only by one or two added factors and
compared the results. The graphs were designed
by hand; they connect some forms with similar
morphological properties more or less densely.
We trained different models using the observed
forms in the 9393 paradigms as training data. The
first 100 paradigms were then used as develop-
ment data for model selection:24 we were given
the answers to their hidden forms, enabling us to
compare the models. The best model was then
evaluated on the 9293 remaining paradigms.
</bodyText>
<subsectionHeader confidence="0.996008">
7.6 Development data results
</subsectionHeader>
<bodyText confidence="0.9985651">
The models are compared on development data
in Table 2. Among the factor graphs we evalu-
ated, we find that L4 (see Fig. 3) performs best
overall (whole-word accuracy 82.1). Note that the
unconnected graph U does not perform very well
(69.0), but using factor graphs with more connect-
ing factors generally helps overall accuracy (see
C1–C3). Note, however, that in some cases the ad-
ditional structure hurts: The chain model C4 and
the loopy model L1 perform relatively badly. The
23If we instead wished to maximize the fraction of entire
paradigms that were predicted perfectly, then we would have
approximated full MAP decoding over the paradigm (Viterbi
decoding) by using max-product BP. Other loss functions
(e.g., edit distance) would motivate other decoding methods.
24Using these paradigms was simply a quick way to avoid
model selection by cross-validation. If data were really as
sparse as our training setup pretends (see Table 2), then 100
complete paradigms would be too valuable to squander as
mere development data.
</bodyText>
<figureCaption confidence="0.937867">
Figure 3: The graphs that we evaluate on development data.
</figureCaption>
<bodyText confidence="0.855711923076923">
The nodes represent morphological forms, e.g. the first node
in the left of each graph represents the first person singular
present. Each variable is also connected to the lemma (not
shown). See results in Table 2.
reason for such a performance degradation is that
undertrained factors were used: The factors relat-
ing second-person to second-person forms, for ex-
ample, are trained from only 8 available examples.
Non-loopy models always converge (exactly) in
one iteration (see footnote 22). But even our loopy
models appeared to converge in accuracy within
two iterations. Only L3 and L4 required the sec-
ond iteration, which made tiny improvements.
</bodyText>
<subsectionHeader confidence="0.97929">
7.7 Test data results
</subsectionHeader>
<bodyText confidence="0.999869608695652">
Based on the development results, we selected
model L4 and tested on the remaining 9293
paradigms.
We regard the unconnected model U as a base-
line to improve upon. We also tried a rather differ-
ent baseline as in (Dreyer et al., 2008). We trained
the machine translation toolkit Moses (Koehn et
al., 2007) to translate groups of letters rather than
groups of words (“phrases”). For each form f
to be predicted, we trained a Moses model on
all supervised form pairs (l, f) available in the
data, to learn a prediction for the form given the
lemma l. The M,3 condition restricted Moses use
“phrases” no longer than 3 letters, comparable to
our own trigram-based factors (see section 7.2).
M,15 could use up to 15 letters.
Again, our novel L4 model far outperformed
the others overall. Breaking the results down by
form, we find that this advantage mainly comes
from the 3 forms with the fewest observed train-
ing examples (Table 3, first 3 rows). The M and
U models are barely able to predict these forms at
all from the lemma, but L4 can predict them bet-
</bodyText>
<figure confidence="0.980252241071428">
Pres Past Pres Past Pres Past Pres Past
Pres Past
(T1)
(T2) (L1)
(L2)
(L3)
(L4)
Singular
1
1
1
1
1
1,3
1,3
1,3
1,3
1,3
2
2
2
2
2
2
2
2
2
2
3
3
3
3
3
Plural
1,3
1,3
1,3
1,3
1,3
1,3
1,3
1,3
1,3
1,3
2
2
2
2
2
2
2
2
2
2
(C4)
1
1
1,3
1,3
1
1
1
1
1,3
1,3
1,3
1,3
2
2
2
2
2
2
2
2
2
2
2
2
3
3
3
3
3
3
1,3
1,3
1,3
1,3
1,3
1,3
1,3
1,3
1,3
1,3
1,3
1,3
2
2
2
2
2
2
2
2
2
2
2
2
Plural
Singular
(iJ) (C1) (C2) (C3)
</figure>
<page confidence="0.966517">
108
</page>
<table confidence="0.975654">
Unconn. Chains Trees Loops
U C1 C2 C3 C4 T1 T2 L1 L2 L3 L4
69.0 72.9 73.4 74.8 65.2 78.1 78.7 62.3 79.6 78.9 82.1
</table>
<tableCaption confidence="0.899021">
Table 2: Whole-word accuracies of the different models in reconstructing the missing forms in morphological paradigms, here
on 100 verbs (development data). The names refer to the graphs in Fig. 3. We selected L4 as final model (Table 3).
</tableCaption>
<table confidence="0.999902545454545">
Form # obs. M,3 M,15 U L4
2.Sg.Pa. 4 0.0 0.2 0.8 69.7
2.Pl.Pa. 9 0.9 1.1 1.4 45.6
2.Sg.Pr. 166 49.4 62.6 74.7 90.5
1.Sg.Pr. 285 99.6 98.8 99.3 97.2
1,3.Pl.Pa. 673 46.5 78.3 75.0 75.6
1,3.Sg.Pa. 1124 65.0 88.8 84.0 74.8
2.Pl.Pr. 1274 98.3 99.2 99.0 96.4
3.Sg.Pr. 1410 91.0 95.9 95.2 88.2
1,3.Pl.Pr. 1688 99.8 98.9 99.8 98.0
All 6633 59.2 67.3 68.0 81.2
</table>
<tableCaption confidence="0.848741333333333">
Table 3: Whole-word accuracies on the missing forms from
9293 test paradigms. The Moses baselines and our un-
connected model (U) predict each form separately from the
</tableCaption>
<bodyText confidence="0.986507192307692">
lemma, which is always observed. L4 uses all observations
jointly, running belief propagation for decoding. Moses,15
memorizes phrases of length up to 15, all other models use
max length 3. The table is sorted by the column “# obs.”,
which reports the numbers of observations for a given form.
ter by exploiting other observed or latent forms.
By contrast, well-trained forms were already easy
enough for the M and U models that L4 had little
new to offer and in fact suffered from its approxi-
mate training and/or inference.
Leaving aside the comparisons, it was useful to
confirm that loopy BP could be used in this set-
ting at all. 8014 of the 9293 test paradigms had
≤ 2 observed forms (in addition to the lemma)
but ≥ 7 missing forms. One might have expected
that loopy BP would have failed to converge, or
converged to the wrong thing. Nonetheless, it
achieved quite respectable success at exactly pre-
dicting various inflected forms.
For the curious, Table 4 shows accuracies
grouped by different categories of paradigms,
where the category is determined by the number
of missing forms to predict. Most paradigms fall
in the category where 7 to 9 forms are missing, so
the accuracies in that line are similar to the overall
accuracies in Table 3.
</bodyText>
<sectionHeader confidence="0.999007" genericHeader="conclusions">
8 Conclusions
</sectionHeader>
<bodyText confidence="0.999293333333333">
We have proposed that one can jointly model sev-
eral multiple strings by using Markov Random
Fields. We described this formally as an undi-
</bodyText>
<table confidence="0.99844775">
# missing # paradig. M,3 M,15 U L4
1–3 205 20.3 20.8 26.8 74.4
4–6 1037 44.2 50.5 52.7 82.8
7–9 8014 60.6 68.8 69.4 81.1
</table>
<tableCaption confidence="0.554672666666667">
Table 4: Accuracy on test data, reported separately for
paradigms in which 1–3, 4–6, or 7–9 forms are missing.
Missing words have CELEX frequency count &lt; 10; these are
the ones to predict. (The numbers in col. 2 add up to 9256,
not 9293, since some paradigms are incomplete in CELEX to
begin with, with no forms to be removed or evaluated.)
</tableCaption>
<bodyText confidence="0.999856941176471">
rected graphical model with string-valued vari-
ables and whose factors (potential functions) are
defined by weighted finite-state transducers. Each
factor evaluates some subset of the strings.
Approximate inference can be done by loopy
belief propagation. The messages take the form
of weighted finite-state acceptors, and are con-
structed by standard operations. We explained
why the messages might become large, and gave
methods for approximating them with smaller
messages. We also discussed training methods.
We presented some pilot experiments on the
task of jointly predicting multiple missing verb
forms in morphological paradigms. The factors
were simplified versions of statistical finite-state
models for supervised morphology. Our MRF
for this task might be used not only to conjugate
verbs (e.g., in MT), but to guide further learning
of morphology—either active learning from a hu-
man or semi-supervised learning from the distri-
butional properties of a raw text corpus.
Our modeling approach is potentially applicable
to a wide range of other tasks, including translit-
eration, phonology, cognate modeling, multiple-
sequence alignment and system combination.
Our work ties into a broader vision of using al-
gorithms like belief propagation to coordinate the
work of several NLP models and algorithms. Each
individual factor considers some portion of a joint
problem, using classical statistical NLP methods
(weighted grammars, transducers, dynamic pro-
gramming). The factors coordinate their work by
passing marginal probabilities. Smith and Eisner
(2008) reported complementary work in this vein.
</bodyText>
<page confidence="0.998879">
109
</page>
<sectionHeader confidence="0.993882" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999850252747253">
Cyril Allauzen, Michael Riley, Johan Schalkwyk, Wo-
jciech Skut, and Mehryar Mohri. 2007. OpenFst: A
general and efficient weighted finite-state transducer
library. In Proc. of CIAA, volume 4783 of Lecture
Notes in Computer Science, pages 11–23.
Christopher M. Bishop. 2006. Pattern Recognition
and Machine Learning. Springer.
Alexandre Bouchard-Cˆot´e, Thomas L. Griffiths, and
Dan Klein. 2009. Improved reconstruction of pro-
tolanguage word forms. In Proc. of HLT-NAACL,
pages 65–73, Boulder, Colorado, June. Association
for Computational Linguistics.
Fabien Cromier`es and Sadao Kurohashi. 2009. An
alignment algorithm using belief propagation and a
structure-based distortion model. In Proc. of EACL,
pages 166–174, Athens, Greece, March. Association
for Computational Linguistics.
Markus Dreyer, Jason Smith, and Jason Eisner. 2008.
Latent-variable modeling of string transductions
with finite-state methods. In Proc. of EMNLP, Hon-
olulu, Hawaii, October.
Jason Eisner. 2002. Parameter estimation for prob-
abilistic finite-state transducers. In Proc. of ACL,
pages 1–8, Philadelphia, July.
Scott E. Fahlman and Christian Lebiere. 1990. The
cascade-correlation learning architecture. Technical
Report CMU-CS-90-100, School of Computer Sci-
ence, Carnegie Mellon University.
Andr´e Kempe, Jean-Marc Champarnaud, and Jason
Eisner. 2004. A note on join and auto-intersection
of n-ary rational relations. In Loek Cleophas and
Bruce Watson, editors, Proceedings of the Eind-
hoven FASTAR Days (Computer Science Techni-
cal Report 04-40). Department of Mathematics and
Computer Science, Technische Universiteit Eind-
hoven, Netherlands.
Kevin Knight and Jonathan Graehl. 1997. Machine
transliteration. In Proc. of ACL, pages 128–135.
Philipp Koehn, Hieu Hoang, Alexandra Birch, Chris
Callison-Burch, Marcello Federico, Nicola Bertoldi,
Brooke Cowan, Wade Shen, Christine Moran,
Richard Zens, Chris Dyer, Ondrej Bojar, Alexandra
Constantin, and Evan Herbst. 2007. Moses: Open
source toolkit for statistical machine translation. In
Proc. of ACL, Companion Volume, pages 177–180,
Prague, Czech Republic, June. Association for Com-
putational Linguistics.
Alex Kulesza and Fernando Pereira. 2008. Structured
learning with approximate inference. In Proc. of
NIPS.
Zhifei Li and Jason Eisner. 2009. First- and second-
order expectation semirings with applications to
minimum-risk training on translation forests. In
Proc. of EMNLP.
Zhifei Li, Jason Eisner, and Sanjeev Khudanpur. 2009.
Variational decoding for statistical machine transla-
tion. In Proc. of ACL.
Mehryar Mohri. 1997. Finite-state transducers in lan-
guage and speech processing. Computational Lin-
guistics, 23(2).
Fernando C. N. Pereira and Michael Riley. 1997.
Speech recognition by composition of weighted fi-
nite automata. In Emmanuel Roche and Yves
Schabes, editors, Finite-State Language Processing.
MIT Press, Cambridge, MA.
Eric Sven Ristad and Peter N. Yianilos. 1996. Learn-
ing string edit distance. Technical Report CS-TR-
532-96, Princeton University, Department of Com-
puter Science, October.
David Smith and Jason Eisner. 2008. Dependency
parsing by belief propagation. In Proc. of EMNLP.
Andrew Smith, Trevor Cohn, and Miles Osborne.
2005. Logarithmic opinion pools for conditional
random fields. In Proc. ofACL, pages 18–25, June.
Erik B. Sudderth, Alexander T. Ihler, Er T. Ihler,
William T. Freeman, and Alan S. Willsky. 2002.
Nonparametric belief propagation. In Proc. of
CVPR, pages 605–612.
Charles Sutton and Andrew McCallum. 2004. Collec-
tive segmentation and labeling of distant entities in
information extraction. In ICML Workshop on Sta-
tistical Relational Learning and Its Connections to
Other Fields.
Charles Sutton and Andrew McCallum. 2008. Piece-
wise training for structured prediction. Machine
Learning. In submission.
Charles Sutton, Khashayar Rohanimanesh, and An-
drew McCallum. 2004. Dynamic conditional ran-
dom fields: Factorized probabilistic models for la-
beling and segmenting sequence data. In Proc. of
ICML.
</reference>
<page confidence="0.998369">
110
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.000000">
<title confidence="0.998509">Models over Multiple</title>
<author confidence="0.974684">Dreyer</author>
<affiliation confidence="0.999594">Department of Computer Science / Johns Hopkins</affiliation>
<address confidence="0.998329">Baltimore, MD 21218,</address>
<abstract confidence="0.998834887305701">study graphical modeling in the case of stringvariables. Whereas a weighted finite-state transducer can model the probabilisrelationship between we are interin building up joint models of or more This is needed for inflectional paradigms in morphology, cognate modeling or language reconstruction, and multiple-string alignment. We propose a Markov Random Field in which each factor (potential function) is a weighted finite-state machine, typically a transducer that evaluates the relationship between just two of the strings. The full joint distribution is then a product of these factors. Though decoding is actually undecidable in general, we can still do efficient joint inference using approximate belief propagation; the necessary computations and messages are all finitestate. We demonstrate the methods by jointly predicting morphological forms. 1 Overview This paper considers what happens if a graphical variables can range over unlength, rather than over the typical domains such as booleans, words, or tags. Variables that are connected in the graphical model are related by some weighted finite-state transduction. Graphical models have become popular in machine learning as a principled way to work with collections of interrelated random variables. Most often they are used as follows: Build: specify the of interest; their domains; and the possible direct interactions among them. Train: this model’s parameters obtain a specific joint probability distribution ... , the Infer: this joint distribution to predict the values of various unobserved variables from observed ones. by the Human Language Technology Center of Excellence at Johns Hopkins University, and by National Science Foundation grant No. 0347822 to the second author. Note that 1. requires intuitions about the domain; 2. requires some choice of training procedure; and 3. requires a choice of exact or approximate inference algorithm. Our graphical models over strings are natural objects to investigate. We motivate them with some natural applications in computational linguistics (section 2). We then give our formalism: a Markov Random Field whose potential functions are rational weighted languages and relations (section 3). Next, we point out that inference is in general undecidable, and explain how to do approximate inference using message-passing algorithms such as belief propagation (section 4). The messages are represented as weighted finite-state machines. Finally, we report on some initial experiments using these methods (section 7). We use incomplete data to train a joint model of morphological paradigms, then use the trained model to complete the data by predicting unseen forms. 2 Motivation The problem of mapping between different forms and representations of strings is ubiquitous in natural language processing and computational linguistics. This is typically done between string where a pronunciation is mapped to its spelling, an inflected form to its lemma, a spelling variant to its canonical spelling, or a name is transliterated from one alphabet into another. However, many problems involve more than just two strings: in the inflected forms of a (possibly irregular) verb are naturally considered together as a whole morphological paradigm in which different forms reinforce one another; mapping an English word to its foreign translitbe easier when one considers the forms of both words; similar multiple languages are naturally described together, in orthographic or phonological representations, or both; 101 of the 2009 Conference on Empirical Methods in Natural Language pages 6-7 August 2009. ACL and AFNLP • modern and ancestral word forms form a phylotree in in in multiple sequences need to be aligned in order to identify regions of similarity. We propose a unified model for multiple strings that is suitable for all the problems mentioned above. It is robust and configurable and can make use of task-specific overlapping features. It learns from observed and unobserved, or latent, information, making it useful in supervised, semisupervised, and unsupervised settings. 3 Formal Modeling Approach 3.1 Variables Random Field is a joint model a set of random variables, ... , We assume that all variables are string-valued, i.e. value of be any string where is some finite alphabet. We may use meaningful names for the integers such as for the of a verb. assumption that are stringvalued is not crucial; it merely simplifies our presentation. It is, however, sufficient for many practical purposes, since most other discrete objects can be easily encoded as strings. For examif a part of speech tag, it may be encoded as a length-1 string over the finite alphabet def 3.2 Factors A Markov Random Field defines a probability for assignment values to the variables in 1 This distribution over assignments is specified by collection of H Each (or is a function that deon only a 1 displays an undirected in which each factor is connected to the variables it depends on. this example are because each one scores the value a single variable, while factors. Figure 1: Example of a factor graph. Black boxes represent factors, circles represent variables (infinitive, 2nd past, and 3rd present-tense forms of the same verb; different samples from the MRF correspond to different verbs). Binary factors evaluate how well one string can be transduced into another, summing over all transducer paths (i.e., alignments, which are not observed in training). In our setting, we will assume that each unary is specified by a finite-state auwhose weights fall in the semirthe score the total weight of all paths in the that accept the string x Each path’s weight is the product of its component arcs’ weights, which are non-negative. Similarly, we assume that each binary factor is by a finite-state transducer (WFST). Such a model is essentially a generalization of stochastic edit distance (Ristad and Yianilos, 1996) in which the edit probabilities can be made sensitive to a finite summary of context. Formally, a WFST is an automaton that resembles a weighted FSA, but it nondeterministically x, y in parallel from left to right. score of given by the total weight of all accepting paths in the WFST that map x to y. For example, different paths may consider various monotonic alignments of x with y, and we sum these mutually exclusive factor might depend on k &gt; This a k-tape finite-state machine (WFSM), an obvious generalization where each reads k strings in some To ensure that Z is finite in equation (1), we can each factor to be a i.e., its accepting paths have finite total weight (even if the WFSM is cyclic, with infinitely many paths). string is said to be on a different “tape,” which has its own “read head,” allowing the WFSM to maintain a separate position in each string. Thus, a path in a WFST may any number of characters from consuming next character from acceptors and transducers are the cases 1 which are said to define languages 102 3.3 Parameters Our probability model has trainable parameters: a of weights Each arc in each has a real-valued weight that depends on tuning training will change the arc weights, hence the path weights, the factor funcand the whole probability distribution Designing the probability model includes specifying the topology and weights of each WFSM. Eisner (2002) explains how to specify and train Typically, the of an arc is a simple sum like included on all arcs that share feature 12. However, more interesting parameterizations arise if the WFSM is constructed by operations such as transducer composition, or from a weighted regular expression. 3.4 Power of the formalism Factored finite-state string models (1) were originally suggested by the second author, in Kempe et al. (2004). That paper showed that even in the unweighted case, such models could be used to encode relations that could not be recognized by any FSM. We offer a more linguistic example as a small puzzle. We invite the reader to specify a factored model (consisting of three FSTs as in Fig. 1) that assigns positive probability to just triples of character strings y, have form etc. This uses the auxiliary help encode a relation between swaps words of unbounded length. By contrast, no FSM can accomplish such unbounded swapping, even with 3 or more tapes. Such extra power might be linguistically useful. Troublingly, however, Kempe et al. (2004) also observed that the framework is powerful enough to computationally This implies that to work with arbitrary models, will need approximate graphical models community has already dea simple model with two variables and two bifactors: Sup- 1 or 0 according to whether its arguments are Under this model, there exists a string can be transduced to itself by the unweighted This question can be used to encode any instance of Post’s Correspondence Problem, so is undecidable. that the simplest approximation to cure undecidability would be to impose an arbitrary maximum on string length, so that the random variables have a finite domain, just as in most discrete graphical models. U F Figure 2: Illustration of messages being passed from variable to factor and factor to variable. Each message is represented by a finite-state acceptor. veloped many such methods, to deal with the computational intractability (if not undecidability) of exact inference. 4 Approximate Inference this paper, we focus on how propagation (BP)—a simple well-known method for approximate inference in MRFs (Bishop, 2006)—can be used in our setting. BP in its general form has yet been widely used in the NLP it is just a generalization to factor graphs of the familiar forward-backward algorithm (which operates only on chain-structured factor graphs). The algorithm becomes approximate (and may not even converge) when the factor graphs have cycles. (In that case it is more properly called “loopy belief propagation.”) 4.1 Belief propagation We first sketch how BP works in general. Each the graphical model maintains a beits value, in the form of a marginal disthe possible values of The final beliefs are the output of the algorithm. arise from are sent between the variables and factors along the edges of factor graph. Variable factor mesis an (unnormalized) probabildistribution over values computed by the set of neighbors of the graphical model. This message represents a consensus factors concerning It is how its belief if absent. Informally, it communicates is what my value would be if it were up my other neighboring factors determine. exceptions are Sutton et al. (2004) for chunking and tagging, Sutton and McCallum (2004) for information extraction, Smith and Eisner (2008) for dependency parsing, and Cromier`es and Kurohashi (2009) for alignment. V := 103 factor then collect such incoming messages from neighboring variables and send its message on to another neighbor Such a good values for in the of an (unnormalized) distribution over computed by := (3) an assignment to all variables, and the value of variable that assign- This message represents prediction of value based on its variables Informally, via this message, is what I would like your value to be, based on the messages that my other neighboring variables have sent me about their values, and how I would prefer you to relate to them. Thus, each edge of the factor graph maintains messages All messages are updated repeatedly, in some order, using the two equations above, until some stopping criterion is then computed: variable then the right-hand sides of equations (2) and (4) are modified to tell it the observed value This is by multiplying in an extra message puts probability 1 on 0 on other val- That affects and beliefs. The belief at each variable estimates its under the MRF (1), all observa- 4.2 Finite-state messages in BP unnormalized distribuover the possible values of our case, strings. A distribution over strings is naturally represented by a WFSA. Thus, belief propagation translates to our setting as follows: • Each message is a WFSA. • Messages are typically initialized to a one-state that accepts all strings in each with when the beliefs converge to some fixed point (a local minimum of the Bethe free energy). However, convergence is not guaranteed. generally, on observed variables. Taking a pointwise product of messages to equation (2) corresponds to WFSA intersection. If equation (3) is there is only Then the outgoing message is computed as the factor WFST with the incoming message WFSA, yielding a WFST that a joint distribution over The operator projects this WFST onto the side to obtain a WFSA, which corresponds to to obtain a distribution over In general, a WFSM. Equation (3) its tapes with inmessages construct a joint over the in then onto the to marginalize over the and get a distribution over All this can be accomplished by the WFSM gencomposition operator et al., 2004). After projecting, it is desirable to determinize the WFSA. Otherwise, the summation in (3) is only implicit—the summands remain as distinct in the thus the WFSAs would get larger and larger as BP proceeds. Unfortunately, determinizing a WFSA still does not guarantee a small result. In fact it can lead to expoblowup, or even infinite in practice we recommend against determinizing the messages, which may be inherently complex. shrink a message, it is safer to with a small deterministic WFSA, as discussed in the next section. 4.3 Approximation of messages In our domain, it is possible for the finite-state to unboundedly in size they flow around a cycle. After all, our messages are not just multinomial distributions over a fixed finite is an (improper) uniform distribution over Alis proper WFSA (see section 3.2), there is an upper bound on the weights it assigns to strings. That guarantees that all the messages and beliefs computed by (2)–(4) will be proper FSMs, provided that all the factors are proper WFSMs. it is unary, (3) trivially reduces to usual implementation of projection does not change topology of the WFST, but only deletes the of its arc labels. Thus, multiple paths that accept the same value of distinct according to the distinct values of they were paired with before projection. there is no deterministic equivalent (Mohri, 1997). 104 They are distributions over the infinite set A WFSA represents this in finite space, but more complex distributions require bigger WFSAs, with more distinct states and arc weights. Facing the same problem for distributions over infinite set Sudderth et al. (2002) simplified message a complex Gaussian mixture by using fewer components. We could act similarly, variationally approxia large WFSA a smaller one Choose a family of message approximations (such as bigram models) by specifying the topology for (small) deterministic WFSA Then choose edge weights to minimize the KL divergence This can be done in closed Another possible procedure—used in the exof this paper—approximates pruning it back to a finite set of most plausible (2) requests an intersection several WFSAs, e.g., · · · List all strings that appear on any of the 1000best paths in any of these WFSAs, removing du- Let a uniform distribution over this combined list of plausible strings, represented as a determinized, minimized, acyclic WFSA. Now approximate the intersection of equation (2) as · · · This is efficient compute and has the same topology as 5 Training the Model Parameters Any standard training method for MRFs will transfer naturally to our setting. In all cases we draw on Eisner (2002), who showed how to train parameters a to (locally) maximize the joint or conditional probability of fully or partially observed training data. This involves computing the gradient of that likelihood with respect to Li et al. (2009, footnote 9) for a sketch of the construction, which finds locally normalized edge weights. Or large but parameterized by some compact parameter so we are only allowed to control its edge weights then Li and Eisner (2009, section 6) explain how to gradient descent. In both cases must be deterministic. remark that if a factor specified by a synchronous grammar rather than a WFSM, then its outgoing messages would be weighted context-free languages. Exact intersection of these is undecidable, but they too can be approximated variationally by WFSAs, with the same methods. are also considering other ways of adaptively choosing the topology of WFSA approximations at runtime, particularly in conjunction with expectation propagation. likelihood is usually non-convex; even when the two strings are observed (supervised training), their accepting must generalize this to train a WFSMs. Typically, training data for an MRF (1) consists of some fully or partially observed IID of the joint distribution ... It well-known how to tune an MRF’s parameters by stochastic gradient descent to locally maximize the probability of this training set, even though both the probability and its gradient are in general intractable to compute in an MRF. The gradient is sum of quantities, one for each factor While summand for be computed exactly, can be estimated using the BP messages to speaking, the gradient for computed much as in supervised training (see above), but any message an uncertain obof form of noisy Our concerns about training are the same as for any MRF. First of all, BP is approximate. Kulesza and Pereira (2008) warn that its estimates of the gradient can be misleading. Second, semisupervised training (which we will attempt below) is always difficult and prone to local optima. As in EM, a small number of supervised examples for some variable may be drowned out by many noisily reconstructed examples. Faster and potentially more stable approaches the training of Sutton and McCallum (2008), which train the factors independently or in small groups. In the semisupervised case, each factor can be trained on only the supervised forms available for it. It might be useful to reweight the trained factors (cf. Smith et al. (2005)), or train the factors consecutively (cf. Fahlman and Lebiere (1990)), in a way that minimizes the loss of BP decoding on held-out data. 6 Comparison With Other Approaches 6.1 Multi-tape WFSMs In principle, one could use a 100-tape WFSM to jointly model the 100 distinct forms of a typical Polish verb. In other words, the WFSM would dethe distribution of a random variable . . . , each a string. One would train the parameters of the WFSM on a ~ of each sample being a fully or partially observed paradigm for some Polish verb. The resulting distribution could be used to infer missing forms for these or other verbs. path through the WFST may be ambiguous and unobserved. Bishop (2006), or consult Smith and Eisner (2008) for notation close to that of this paper. 105 As a simple example, either a morphological generator or a morphological analyzer might need probability that the neuter thirdsingular conditional imperfective of krzydespite never having observed it in training. The model determines this probability based on observed and hypothesized forms of krzyusing its knowledge of how neuter thirdperson singular conditional imperfectives are related to these other forms in other verbs. Unfortunately, such a 100-tape WFSM would be huge, with an astronomical number of arcs (each representing a possible 100-way edit operation). Our approach is to factor the problem into a number of (e.g.) pairwise relationships among the verb forms. Using a factored distribution has sevbenefits over the WFSM: (1) a smaller representation in memory, (2) a small number of parameters to learn, (3) efficient approximate computation that takes advantage of the factored structure, (4) the ability to reuse WFSAs and WF- STs previously developed for smaller problems, (5) additional modeling power. 6.2 Simpler graphical models on strings Some previous researchers have used factored joint models of several strings. To our knowledge, have all chosen models. The acyclicity meant that exact inference was at least possible for them, if not necessarily efficient. The factors in these past models have been WFSTs (though typically simpler than the ones we will use). Many papers have used cascades of probabilistic finite-state transducers. Such a cascade may be regarded as a directed graphical model with a linear-chain structure. Pereira and Riley (1997) built a speech recognizer in this way, relating acoustic to phonetic to lexical strings. Similarly, Knight and Graehl (1997) presented a generative cascade using 4 variables and 5 factors: · an English word sequence, pronunciation, Japanese version of the prokatakana rendering of the Japanese and OCR-corrupted version of the katakana. Knight and Graehl used finite-state operations to perform inference at test time, obrecovering the most likely while out and Bouchard-Cˆot´e et al. (2009) reconstructed ancient word forms given modern equivalents. They used a directed graphical model, whose tree structure reflected the evolutionary development of the modern languages, and which included latent variables for historical intermediate forms that were never observed in training data. They used Gibbs sampling rather than an exact solution (possible on trees) or a variational approximation (like our BP). Our work seeks to be general in terms of the graphical model structures used, as well as efficient through the use of BP with approximate messages. We also seek to avoid local normalization, a globally normalized 6.3 Unbounded objects in graphical models We distinguish our work from “dynamic” graphical models such as Dynamic Bayesian Networks and Conditional Random Fields, where the string be represented by creating 7 lettervalued variables. Those methods can represent strings (or paths) of any length—but the length for each training or test string must be specified in advance, not inferred. Furthermore, it is awkward and costly to model unknown alignments, since the variables are position-specific, and any posiin in principle align with any in WFSTs are a much more natural and flexible model of string pairs. We also distinguish our work from current nonparametric Bayesian models, which sometimes generate unbounded strings, trees, or grammars. If they generate two unbounded objects, they model their relationship by a single synchronous generation process (akin to Section 6.1), rather than by a globally normalized product of overlapping factors. 7 Experiments To study our approach, we conducted initial experiments that reconstruct missing word forms in paradigms. In moreach uninflected verb form is associated with a vector of forms that are inflected for tense, person, number, etc. Some inflected forms may be observed frequently in natural text, others rarely. Two variables that are usually predictable from each other may or may not keep this relationship in the case of an irregular verb. we do normalize locally during piecewise training (see section 7.3). 106 (a) # paradigms 9,393 (b) # finite forms per paradigm 9 (c) # hidden finite forms per paradigm (avg.) 8.3 (d) # paradigms with some finite form(s) observed 2,176 (e) In (d), # of finite forms observed (avg.) 3.4 Table 1: Statistics of our training data. task is to reconstruct specific unobserved morphological forms in a paradigm by learning from observed ones. This is a particularly interesting semisupervised scenario, because different subsets of the variables are observed on different examples. 7.1 Experimental data We used orthographic rather than phonological forms. We extracted morphological paradigms for all 9393 German verbs in the CELEX morphological database. Each paradigm lists 5 present-tense and 4 past-tense indicative forms, as well as the verb’s lemma, for a total of 10 string-valued varieach paradigm, we removed, or hid, verb forms that occur only rarely in natural text, i.e, verb forms with a small frequency figure proby paradigms other than (’to be’) were now incompletely observed. Table 1 gives some statistics. 7.2 Model factors and parameters Our current MRF uses only binary factors. Each factor is a WFST that is trained to relate 2 of the 10 variables (morphological forms). Each WFST can score an aligned pair using a log-linear model that counts features in a sliding 3-character window. To score an unaligned pair, it sums over all possible alignments. Specifically, our WFST topology and parameterization follow the state-of-theapproach to in Dreyer et al. (2008), although we dropped some of their to speed up these early pairs of forms are always identical in German, hence are treated as a single form by CELEX. We likewise use a single variable—these are the “1,3” variables in Fig. 3. a form is listed as We neither train nor evaluate on such forms, although the model will still predict them. frequency figure for each word form is based on counts in the Mannheim News corpus. We hide forms with dropped their latent classes and regions as well as features that detected which characters were orthographic vowels. Also, we retained their “target language model features” only in the baseline “U” model, since elsewhere they implemented and manipulated all WFSMs using the OpenFST library (Allauzen et al., 2007). 7.3 Training in the experiments trained the incompletely observed paradigms. As suggested in section 5, we used a variant of piecewise pseudolikelihood training (Sutton and McCallum, 2008). Suppose there is binary factor to forms For value of we can define tiny MRF consisting only of and def can therefore compute the goodness over V in training data. We atto tune maximize the total V by subtracting Note that different factors thus enjoyed different amounts of observed training data, but training was fully supervised (except for the unobserved between 7.4 Inference in the experiments At test time, we are given each lemma (e.g. and all its observed (frequent) inflected (e.g., ), and are asked to the remaining (rarer) forms (e.g., ... We run approximate joint inference using beextract our output from the beliefs: for each unseen variable we preseemed to hurt in our current training setup. We followed Dreyer et al. (2008) in slightly pruning the space of possible alignments. We compensated by replacing WFST, with the union This ensured that the factor could still map any string to any other string (though perhaps with very low weight), guaranteeing that the intersection at the end of section 4.3 would be non-empty. second term is omitted if the lemma. We do not train the model to predict the lemma since it is always observed in test data. just before press time we discovered that this was not quite what we had done. A shortcut in our imtrained separately. This let them make different use of the (unobserved) alignments—so that even if each individually liked the pair might not have been able to agree on the same accepting path for it at test time. This could have slightly harmed our joint inference results, though not our baselines. derive the update order for message passing, we take arbitrary spanning tree over the factor graph, and let a list of all factors and variables that is topologically sorted according to the spanning tree, with the leaves of the tree coming first. We then discard the spanning tree. A single itvisits all factors and variables in order of updating each one’s messages to later variables and factors, and then visits all factors and variables in reverse order, updating each one’s messages to earlier variables and factors. 107 its value to be This prediction considers the values of all other unseen variables but sums over their possibilities. This is the Bayes-optimal decoder for our scoring function, that function reports the fraction of individforms were predicted 7.5 Model selection of MRF topology is hard to know priori the causal relationships might be in a morphological paradigm. In one would like to which factors to have in the MRF. Or one could start with many factors, but use methods such as those suggested in section 5 to learn that certain less useful factors should be left weak to avoid confusing loopy BP. For our present experiments, we simply compared several fixed model topologies (Fig. 3). These were variously unconnected (U), chain graphs (C1,..., C4), trees (T1, T2), or loopy graphs (L1,..., L4). We used several factor graphs that differ only by one or two added factors and compared the results. The graphs were designed by hand; they connect some forms with similar morphological properties more or less densely. We trained different models using the observed forms in the 9393 paradigms as training data. The first 100 paradigms were then used as developdata for we were given the answers to their hidden forms, enabling us to compare the models. The best model was then evaluated on the 9293 remaining paradigms. 7.6 Development data results The models are compared on development data in Table 2. Among the factor graphs we evaluated, we find that L4 (see Fig. 3) performs best overall (whole-word accuracy 82.1). Note that the unconnected graph U does not perform very well (69.0), but using factor graphs with more connecting factors generally helps overall accuracy (see C1–C3). Note, however, that in some cases the additional structure hurts: The chain model C4 and the loopy model L1 perform relatively badly. The we instead wished to maximize the fraction of entire paradigms that were predicted perfectly, then we would have approximated full MAP decoding over the paradigm (Viterbi decoding) by using max-product BP. Other loss functions (e.g., edit distance) would motivate other decoding methods. these paradigms was simply a quick way to avoid model selection by cross-validation. If data were really as sparse as our training setup pretends (see Table 2), then 100 complete paradigms would be too valuable to squander as mere development data. Figure 3: The graphs that we evaluate on development data. The nodes represent morphological forms, e.g. the first node in the left of each graph represents the first person singular present. Each variable is also connected to the lemma (not shown). See results in Table 2. reason for such a performance degradation is that undertrained factors were used: The factors relating second-person to second-person forms, for example, are trained from only 8 available examples. Non-loopy models always converge (exactly) in one iteration (see footnote 22). But even our loopy models appeared to converge in accuracy within two iterations. Only L3 and L4 required the second iteration, which made tiny improvements. 7.7 Test data results Based on the development results, we selected model L4 and tested on the remaining 9293 paradigms. We regard the unconnected model U as a baseline to improve upon. We also tried a rather different baseline as in (Dreyer et al., 2008). We trained the machine translation toolkit Moses (Koehn et al., 2007) to translate groups of letters rather than of words (“phrases”). For each form to be predicted, we trained a Moses model on supervised form pairs in the data, to learn a prediction for the form given the The M,3 condition restricted Moses use “phrases” no longer than 3 letters, comparable to our own trigram-based factors (see section 7.2). M,15 could use up to 15 letters. Again, our novel L4 model far outperformed the others overall. Breaking the results down by form, we find that this advantage mainly comes from the 3 forms with the fewest observed training examples (Table 3, first 3 rows). The M and U models are barely able to predict these forms at from the lemma, but L4 can predict them bet-</abstract>
<title confidence="0.483851">Pres Past Pres Past Pres Past Pres Past Pres Past</title>
<note confidence="0.84892875">(T1) (T2) (L1) (L2) (L3) (L4) Singular 1 1 1 1 1 1,3 1,3 1,3 1,3 1,3</note>
<abstract confidence="0.782035267379679">2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 Plural 1,3 1,3 1,3 1,3 1,3 1,3 1,3 1,3 1,3 1,3 2 2 2 2 2 2 2 2 2 2 (C4) 1 1 1,3 1,3 1 1 1 1 1,3 1,3 1,3 1,3 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 1,3 1,3 1,3 1,3 1,3 1,3 1,3 1,3 1,3 1,3 1,3 1,3 2 2 2 2 2 2 2 2 2 2 2 2 Plural Singular (iJ) (C1) (C2) (C3) 108 Unconn. Chains Trees Loops U C1 C2 C3 C4 T1 T2 L1 L2 L3 L4 69.0 72.9 73.4 74.8 65.2 78.1 78.7 62.3 79.6 78.9 82.1 Table 2: Whole-word accuracies of the different models in reconstructing the missing forms in morphological paradigms, here on 100 verbs (development data). The names refer to the graphs in Fig. 3. We selected L4 as final model (Table 3). Form # obs. M,3 M,15 U L4 2.Sg.Pa. 4 0.0 0.2 0.8 69.7 2.Pl.Pa. 9 0.9 1.1 1.4 45.6 2.Sg.Pr. 166 49.4 62.6 74.7 90.5 1.Sg.Pr. 285 99.6 98.8 99.3 97.2 1,3.Pl.Pa. 673 46.5 78.3 75.0 75.6 1,3.Sg.Pa. 1124 65.0 88.8 84.0 74.8 2.Pl.Pr. 1274 98.3 99.2 99.0 96.4 3.Sg.Pr. 1410 91.0 95.9 95.2 88.2 1,3.Pl.Pr. 1688 99.8 98.9 99.8 98.0 All 6633 59.2 67.3 68.0 81.2 Table 3: Whole-word accuracies on the missing forms from 9293 test paradigms. The Moses baselines and our unconnected model (U) predict each form separately from the lemma, which is always observed. L4 uses all observations jointly, running belief propagation for decoding. Moses,15 memorizes phrases of length up to 15, all other models use max length 3. The table is sorted by the column “# obs.”, which reports the numbers of observations for a given form. ter by exploiting other observed or latent forms. By contrast, well-trained forms were already easy enough for the M and U models that L4 had little new to offer and in fact suffered from its approximate training and/or inference. Leaving aside the comparisons, it was useful to confirm that loopy BP could be used in this setting at all. 8014 of the 9293 test paradigms had forms (in addition to the lemma) forms. One might have expected that loopy BP would have failed to converge, or converged to the wrong thing. Nonetheless, it achieved quite respectable success at exactly predicting various inflected forms. For the curious, Table 4 shows accuracies grouped by different categories of paradigms, where the category is determined by the number of missing forms to predict. Most paradigms fall in the category where 7 to 9 forms are missing, so the accuracies in that line are similar to the overall accuracies in Table 3. 8 Conclusions We have proposed that one can jointly model several multiple strings by using Markov Random We described this formally as an undi- 1–3 205 20.3 20.8 26.8 74.4 4–6 1037 44.2 50.5 52.7 82.8 7–9 8014 60.6 68.8 69.4 81.1 Table 4: Accuracy on test data, reported separately for paradigms in which 1–3, 4–6, or 7–9 forms are missing. words have CELEX frequency count these are the ones to predict. (The numbers in col. 2 add up to 9256, not 9293, since some paradigms are incomplete in CELEX to begin with, with no forms to be removed or evaluated.) rected graphical model with string-valued variables and whose factors (potential functions) are defined by weighted finite-state transducers. Each factor evaluates some subset of the strings. Approximate inference can be done by loopy belief propagation. The messages take the form of weighted finite-state acceptors, and are constructed by standard operations. We explained why the messages might become large, and gave methods for approximating them with smaller messages. We also discussed training methods. We presented some pilot experiments on the task of jointly predicting multiple missing verb forms in morphological paradigms. The factors were simplified versions of statistical finite-state models for supervised morphology. Our MRF for this task might be used not only to conjugate verbs (e.g., in MT), but to guide further learning of morphology—either active learning from a human or semi-supervised learning from the distributional properties of a raw text corpus. Our modeling approach is potentially applicable to a wide range of other tasks, including transliteration, phonology, cognate modeling, multiplesequence alignment and system combination. Our work ties into a broader vision of using algorithms like belief propagation to coordinate the work of several NLP models and algorithms. Each individual factor considers some portion of a joint problem, using classical statistical NLP methods (weighted grammars, transducers, dynamic programming). The factors coordinate their work by passing marginal probabilities. Smith and Eisner (2008) reported complementary work in this vein.</abstract>
<note confidence="0.679326257142857">109 References Cyril Allauzen, Michael Riley, Johan Schalkwyk, Wojciech Skut, and Mehryar Mohri. 2007. OpenFst: A general and efficient weighted finite-state transducer In of volume 4783 of in Computer pages 11–23. M. Bishop. 2006. Recognition Machine Springer. Alexandre Bouchard-Cˆot´e, Thomas L. Griffiths, and Dan Klein. 2009. Improved reconstruction of proword forms. In of pages 65–73, Boulder, Colorado, June. Association for Computational Linguistics. Fabien Cromier`es and Sadao Kurohashi. 2009. An alignment algorithm using belief propagation and a distortion model. In of pages 166–174, Athens, Greece, March. Association for Computational Linguistics. Markus Dreyer, Jason Smith, and Jason Eisner. 2008. Latent-variable modeling of string transductions finite-state methods. In of Honolulu, Hawaii, October. Jason Eisner. 2002. Parameter estimation for probfinite-state transducers. In of pages 1–8, Philadelphia, July. Scott E. Fahlman and Christian Lebiere. 1990. The cascade-correlation learning architecture. Technical Report CMU-CS-90-100, School of Computer Science, Carnegie Mellon University. Andr´e Kempe, Jean-Marc Champarnaud, and Jason Eisner. 2004. A note on join and auto-intersection rational relations. In Loek Cleophas and Watson, editors, of the Eindhoven FASTAR Days (Computer Science Techni-</note>
<affiliation confidence="0.9648325">Report Department of Mathematics and Computer Science, Technische Universiteit Eind-</affiliation>
<address confidence="0.972871">hoven, Netherlands.</address>
<note confidence="0.873000666666667">Kevin Knight and Jonathan Graehl. 1997. Machine In of pages 128–135. Philipp Koehn, Hieu Hoang, Alexandra Birch, Chris</note>
<author confidence="0.743306">Marcello Federico Callison-Burch</author>
<author confidence="0.743306">Nicola Bertoldi</author>
<author confidence="0.743306">Brooke Cowan</author>
<author confidence="0.743306">Wade Shen</author>
<author confidence="0.743306">Christine Moran</author>
<author confidence="0.743306">Richard Zens</author>
<author confidence="0.743306">Chris Dyer</author>
<author confidence="0.743306">Ondrej Bojar</author>
<author confidence="0.743306">Alexandra</author>
<note confidence="0.742580857142857">Constantin, and Evan Herbst. 2007. Moses: Open source toolkit for statistical machine translation. In of ACL, Companion pages 177–180, Prague, Czech Republic, June. Association for Computational Linguistics. Alex Kulesza and Fernando Pereira. 2008. Structured with approximate inference. In of</note>
<abstract confidence="0.979744333333333">Zhifei Li and Jason Eisner. 2009. Firstand secondorder expectation semirings with applications to minimum-risk training on translation forests. In of Zhifei Li, Jason Eisner, and Sanjeev Khudanpur. 2009. Variational decoding for statistical machine transla- In of Mehryar Mohri. 1997. Finite-state transducers in lanand speech processing. Lin-</abstract>
<note confidence="0.532773516129032">23(2). Fernando C. N. Pereira and Michael Riley. 1997. Speech recognition by composition of weighted finite automata. In Emmanuel Roche and Yves editors, Language MIT Press, Cambridge, MA. Eric Sven Ristad and Peter N. Yianilos. 1996. Learning string edit distance. Technical Report CS-TR- 532-96, Princeton University, Department of Computer Science, October. David Smith and Jason Eisner. 2008. Dependency by belief propagation. In of Andrew Smith, Trevor Cohn, and Miles Osborne. 2005. Logarithmic opinion pools for conditional fields. In pages 18–25, June. Erik B. Sudderth, Alexander T. Ihler, Er T. Ihler, William T. Freeman, and Alan S. Willsky. 2002. belief propagation. In of pages 605–612. Charles Sutton and Andrew McCallum. 2004. Collective segmentation and labeling of distant entities in extraction. In Workshop on Statistical Relational Learning and Its Connections to Charles Sutton and Andrew McCallum. 2008. Piecetraining for structured prediction. In submission. Charles Sutton, Khashayar Rohanimanesh, and Andrew McCallum. 2004. Dynamic conditional random fields: Factorized probabilistic models for laand segmenting sequence data. In of 110</note>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Cyril Allauzen</author>
<author>Michael Riley</author>
<author>Johan Schalkwyk</author>
<author>Wojciech Skut</author>
<author>Mehryar Mohri</author>
</authors>
<title>OpenFst: A general and efficient weighted finite-state transducer library.</title>
<date>2007</date>
<booktitle>In Proc. of CIAA,</booktitle>
<volume>4783</volume>
<pages>11--23</pages>
<contexts>
<context position="29157" citStr="Allauzen et al., 2007" startWordPosition="4872" endWordPosition="4875">able—these are the “1,3” variables in Fig. 3. Occasionally a form is listed as UNKNOWN. We neither train nor evaluate on such forms, although the model will still predict them. 18The frequency figure for each word form is based on counts in the Mannheim News corpus. We hide forms with frequency &lt; 10. 19We dropped their latent classes and regions as well as features that detected which characters were orthographic vowels. Also, we retained their “target language model features” only in the baseline “U” model, since elsewhere they implemented and manipulated all WFSMs using the OpenFST library (Allauzen et al., 2007). 7.3 Training in the experiments We trained 0 on the incompletely observed paradigms. As suggested in section 5, we used a variant of piecewise pseudolikelihood training (Sutton and McCallum, 2008). Suppose there is a binary factor F attached to forms U and V . For any value of 0, we can define pUV (U |V ) from the tiny MRF consisting only of U, V , and F. def We can therefore compute the goodness LUV = log pUV (ui |vi)+logV U(vi |ui),20 summed over all observed (U, V ) pairs in training data. We attempted to tune 0 to maximize the total LUV over all U, V pairs,21 regularized by subtracting |</context>
</contexts>
<marker>Allauzen, Riley, Schalkwyk, Skut, Mohri, 2007</marker>
<rawString>Cyril Allauzen, Michael Riley, Johan Schalkwyk, Wojciech Skut, and Mehryar Mohri. 2007. OpenFst: A general and efficient weighted finite-state transducer library. In Proc. of CIAA, volume 4783 of Lecture Notes in Computer Science, pages 11–23.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Christopher M Bishop</author>
</authors>
<date>2006</date>
<booktitle>Pattern Recognition and Machine Learning.</booktitle>
<publisher>Springer.</publisher>
<contexts>
<context position="11206" citStr="Bishop, 2006" startWordPosition="1854" endWordPosition="1855"> undecidability would be to impose an arbitrary maximum on string length, so that the random variables have a finite domain, just as in most discrete graphical models. l-LV--+F l-LF--+U U F Figure 2: Illustration of messages being passed from variable to factor and factor to variable. Each message is represented by a finite-state acceptor. veloped many such methods, to deal with the computational intractability (if not undecidability) of exact inference. 4 Approximate Inference In this paper, we focus on how belief propagation (BP)—a simple well-known method for approximate inference in MRFs (Bishop, 2006)—can be used in our setting. BP in its general form has not yet been widely used in the NLP community.5 However, it is just a generalization to arbitrary factor graphs of the familiar forward-backward algorithm (which operates only on chain-structured factor graphs). The algorithm becomes approximate (and may not even converge) when the factor graphs have cycles. (In that case it is more properly called “loopy belief propagation.”) 4.1 Belief propagation We first sketch how BP works in general. Each variable V in the graphical model maintains a belief about its value, in the form of a marginal</context>
<context position="22114" citStr="Bishop (2006)" startWordPosition="3748" endWordPosition="3749">-out data. 6 Comparison With Other Approaches 6.1 Multi-tape WFSMs In principle, one could use a 100-tape WFSM to jointly model the 100 distinct forms of a typical Polish verb. In other words, the WFSM would describe the distribution of a random variable V~ = (V1, . . . , V100), where each Vi is a string. One would train the parameters of the WFSM on a ~ sample of V, each sample being a fully or partially observed paradigm for some Polish verb. The resulting distribution could be used to infer missing forms for these or other verbs. path through the WFST may be ambiguous and unobserved. 15See Bishop (2006), or consult Smith and Eisner (2008) for notation close to that of this paper. 105 As a simple example, either a morphological generator or a morphological analyzer might need the probability that krzyczałoby is the neuter thirdperson singular conditional imperfective of krzycze´c, despite never having observed it in training. The model determines this probability based on other observed and hypothesized forms of krzycze´c, using its knowledge of how neuter thirdperson singular conditional imperfectives are related to these other forms in other verbs. Unfortunately, such a 100-tape WFSM would </context>
</contexts>
<marker>Bishop, 2006</marker>
<rawString>Christopher M. Bishop. 2006. Pattern Recognition and Machine Learning. Springer.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Alexandre Bouchard-Cˆot´e</author>
<author>Thomas L Griffiths</author>
<author>Dan Klein</author>
</authors>
<title>Improved reconstruction of protolanguage word forms.</title>
<date>2009</date>
<booktitle>In Proc. of HLT-NAACL,</booktitle>
<pages>65--73</pages>
<publisher>Association</publisher>
<institution>for Computational Linguistics.</institution>
<location>Boulder, Colorado,</location>
<marker>Bouchard-Cˆot´e, Griffiths, Klein, 2009</marker>
<rawString>Alexandre Bouchard-Cˆot´e, Thomas L. Griffiths, and Dan Klein. 2009. Improved reconstruction of protolanguage word forms. In Proc. of HLT-NAACL, pages 65–73, Boulder, Colorado, June. Association for Computational Linguistics.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Fabien Cromier`es</author>
<author>Sadao Kurohashi</author>
</authors>
<title>An alignment algorithm using belief propagation and a structure-based distortion model.</title>
<date>2009</date>
<booktitle>In Proc. of EACL,</booktitle>
<pages>166--174</pages>
<publisher>Association</publisher>
<institution>for Computational Linguistics.</institution>
<location>Athens, Greece,</location>
<marker>Cromier`es, Kurohashi, 2009</marker>
<rawString>Fabien Cromier`es and Sadao Kurohashi. 2009. An alignment algorithm using belief propagation and a structure-based distortion model. In Proc. of EACL, pages 166–174, Athens, Greece, March. Association for Computational Linguistics.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Markus Dreyer</author>
<author>Jason Smith</author>
<author>Jason Eisner</author>
</authors>
<title>Latent-variable modeling of string transductions with finite-state methods.</title>
<date>2008</date>
<booktitle>In Proc. of EMNLP,</booktitle>
<location>Honolulu, Hawaii,</location>
<contexts>
<context position="28320" citStr="Dreyer et al. (2008)" startWordPosition="4733" endWordPosition="4736">cy figure provided by CELEX.18 All paradigms other than sein (’to be’) were now incompletely observed. Table 1 gives some statistics. 7.2 Model factors and parameters Our current MRF uses only binary factors. Each factor is a WFST that is trained to relate 2 of the 10 variables (morphological forms). Each WFST can score an aligned pair using a log-linear model that counts features in a sliding 3-character window. To score an unaligned pair, it sums over all possible alignments. Specifically, our WFST topology and parameterization follow the state-of-theart approach to supervised morphology in Dreyer et al. (2008), although we dropped some of their features to speed up these early experiments.19 We 17Some pairs of forms are always identical in German, hence are treated as a single form by CELEX. We likewise use a single variable—these are the “1,3” variables in Fig. 3. Occasionally a form is listed as UNKNOWN. We neither train nor evaluate on such forms, although the model will still predict them. 18The frequency figure for each word form is based on counts in the Mannheim News corpus. We hide forms with frequency &lt; 10. 19We dropped their latent classes and regions as well as features that detected whi</context>
<context position="30412" citStr="Dreyer et al. (2008)" startWordPosition="5091" endWordPosition="5094">thus enjoyed different amounts of observed training data, but training was fully supervised (except for the unobserved alignments between ui and vi). 7.4 Inference in the experiments At test time, we are given each lemma (e.g. brechen) and all its observed (frequent) inflected forms (e.g., brachen, bricht,... ), and are asked to predict the remaining (rarer) forms (e.g., breche, brichst, ... ). We run approximate joint inference using belief propagation.22 We extract our output from the final beliefs: for each unseen variable V , we preseemed to hurt in our current training setup. We followed Dreyer et al. (2008) in slightly pruning the space of possible alignments. We compensated by replacing their WFST, F, with the union F U 10−12(0.999E x E)∗. This ensured that the factor could still map any string to any other string (though perhaps with very low weight), guaranteeing that the intersection at the end of section 4.3 would be non-empty. 20The second term is omitted if V is the lemma. We do not train the model to predict the lemma since it is always observed in test data. 21Unfortunately, just before press time we discovered that this was not quite what we had done. A shortcut in our implementation t</context>
<context position="35363" citStr="Dreyer et al., 2008" startWordPosition="5924" endWordPosition="5927"> were used: The factors relating second-person to second-person forms, for example, are trained from only 8 available examples. Non-loopy models always converge (exactly) in one iteration (see footnote 22). But even our loopy models appeared to converge in accuracy within two iterations. Only L3 and L4 required the second iteration, which made tiny improvements. 7.7 Test data results Based on the development results, we selected model L4 and tested on the remaining 9293 paradigms. We regard the unconnected model U as a baseline to improve upon. We also tried a rather different baseline as in (Dreyer et al., 2008). We trained the machine translation toolkit Moses (Koehn et al., 2007) to translate groups of letters rather than groups of words (“phrases”). For each form f to be predicted, we trained a Moses model on all supervised form pairs (l, f) available in the data, to learn a prediction for the form given the lemma l. The M,3 condition restricted Moses use “phrases” no longer than 3 letters, comparable to our own trigram-based factors (see section 7.2). M,15 could use up to 15 letters. Again, our novel L4 model far outperformed the others overall. Breaking the results down by form, we find that thi</context>
</contexts>
<marker>Dreyer, Smith, Eisner, 2008</marker>
<rawString>Markus Dreyer, Jason Smith, and Jason Eisner. 2008. Latent-variable modeling of string transductions with finite-state methods. In Proc. of EMNLP, Honolulu, Hawaii, October.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jason Eisner</author>
</authors>
<title>Parameter estimation for probabilistic finite-state transducers.</title>
<date>2002</date>
<booktitle>In Proc. of ACL,</booktitle>
<pages>1--8</pages>
<location>Philadelphia,</location>
<contexts>
<context position="8651" citStr="Eisner (2002)" startWordPosition="1423" endWordPosition="1424">ter from y. 2Weighted acceptors and transducers are the cases k = 1 and k = 2, which are said to define rational languages and rational relations. F1 Vinf F2 F6 V2SA V3SE Fa F3 F5 Fj(A) (1) 102 3.3 Parameters Our probability model has trainable parameters: a vector of feature weights 0 ∈ R. Each arc in each WFSM has a real-valued weight that depends on 0. Thus, tuning 0 during training will change the arc weights, hence the path weights, the factor functions, and the whole probability distribution p(A). Designing the probability model includes specifying the topology and weights of each WFSM. Eisner (2002) explains how to specify and train such parameterized WFSMs. Typically, the weight of an arc is a simple sum like 012 + 055 + 072, where 012 is included on all arcs that share feature 12. However, more interesting parameterizations arise if the WFSM is constructed by operations such as transducer composition, or from a weighted regular expression. 3.4 Power of the formalism Factored finite-state string models (1) were originally suggested by the second author, in Kempe et al. (2004). That paper showed that even in the unweighted case, such models could be used to encode relations that could no</context>
<context position="18633" citStr="Eisner (2002)" startWordPosition="3152" endWordPosition="3153"> (2) requests an intersection of several WFSAs, e.g., µF1→V n µF2→V n · · · . List all strings that appear on any of the 1000- best paths in any of these WFSAs, removing duplicates. Let Q be a uniform distribution over this combined list of plausible strings, represented as a determinized, minimized, acyclic WFSA. Now approximate the intersection of equation (2) as (( Q¯ n µF1→V ) n µF2→V ) n · · · . This is efficient to compute and has the same topology as ¯Q. 5 Training the Model Parameters Any standard training method for MRFs will transfer naturally to our setting. In all cases we draw on Eisner (2002), who showed how to train the parameters θ of a single WFST, F, to (locally) maximize the joint or conditional probability of fully or partially observed training data. This involves computing the gradient of that likelihood function with respect to θ.14 12See Li et al. (2009, footnote 9) for a sketch of the construction, which finds locally normalized edge weights. Or if Q is large but parameterized by some compact parameter vector 0, so we are only allowed to control its edge weights via 0, then Li and Eisner (2009, section 6) explain how to minimize KL(P 11 Q) by gradient descent. In both c</context>
</contexts>
<marker>Eisner, 2002</marker>
<rawString>Jason Eisner. 2002. Parameter estimation for probabilistic finite-state transducers. In Proc. of ACL, pages 1–8, Philadelphia, July.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Scott E Fahlman</author>
<author>Christian Lebiere</author>
</authors>
<title>The cascade-correlation learning architecture.</title>
<date>1990</date>
<tech>Technical Report CMU-CS-90-100,</tech>
<institution>School of Computer Science, Carnegie Mellon University.</institution>
<contexts>
<context position="21443" citStr="Fahlman and Lebiere (1990)" startWordPosition="3621" endWordPosition="3624">ing (which we will attempt below) is always difficult and prone to local optima. As in EM, a small number of supervised examples for some variable may be drowned out by many noisily reconstructed examples. Faster and potentially more stable approaches include the piecewise training methods of Sutton and McCallum (2008), which train the factors independently or in small groups. In the semisupervised case, each factor can be trained on only the supervised forms available for it. It might be useful to reweight the trained factors (cf. Smith et al. (2005)), or train the factors consecutively (cf. Fahlman and Lebiere (1990)), in a way that minimizes the loss of BP decoding on held-out data. 6 Comparison With Other Approaches 6.1 Multi-tape WFSMs In principle, one could use a 100-tape WFSM to jointly model the 100 distinct forms of a typical Polish verb. In other words, the WFSM would describe the distribution of a random variable V~ = (V1, . . . , V100), where each Vi is a string. One would train the parameters of the WFSM on a ~ sample of V, each sample being a fully or partially observed paradigm for some Polish verb. The resulting distribution could be used to infer missing forms for these or other verbs. pat</context>
</contexts>
<marker>Fahlman, Lebiere, 1990</marker>
<rawString>Scott E. Fahlman and Christian Lebiere. 1990. The cascade-correlation learning architecture. Technical Report CMU-CS-90-100, School of Computer Science, Carnegie Mellon University.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Andr´e Kempe</author>
<author>Jean-Marc Champarnaud</author>
<author>Jason Eisner</author>
</authors>
<title>A note on join and auto-intersection of n-ary rational relations.</title>
<date>2004</date>
<booktitle>In Loek Cleophas and Bruce Watson, editors, Proceedings of the Eindhoven FASTAR Days (Computer Science</booktitle>
<tech>Technical Report 04-40).</tech>
<institution>Department of Mathematics and Computer Science, Technische Universiteit Eindhoven,</institution>
<location>Netherlands.</location>
<contexts>
<context position="9138" citStr="Kempe et al. (2004)" startWordPosition="1504" endWordPosition="1507">bability distribution p(A). Designing the probability model includes specifying the topology and weights of each WFSM. Eisner (2002) explains how to specify and train such parameterized WFSMs. Typically, the weight of an arc is a simple sum like 012 + 055 + 072, where 012 is included on all arcs that share feature 12. However, more interesting parameterizations arise if the WFSM is constructed by operations such as transducer composition, or from a weighted regular expression. 3.4 Power of the formalism Factored finite-state string models (1) were originally suggested by the second author, in Kempe et al. (2004). That paper showed that even in the unweighted case, such models could be used to encode relations that could not be recognized by any k-tape FSM. We offer a more linguistic example as a small puzzle. We invite the reader to specify a factored model (consisting of three FSTs as in Fig. 1) that assigns positive probability to just those triples of character strings (x, y, z) that have the form (red ball, ball red, red), (white house, house white, white), etc. This uses the auxiliary variable Z to help encode a relation between X and Y that swaps words of unbounded length. By contrast, no FSM c</context>
<context position="15639" citStr="Kempe et al., 2004" startWordPosition="2638" endWordPosition="2641"> WFST with the incoming message WFSA, yielding a WFST that gives a joint distribution over (U, U&apos;). The domain operator projects this WFST onto the U side to obtain a WFSA, which corresponds to marginalizing to obtain a distribution over U. • In general, F is a k-tape WFSM. Equation (3) “composes” k − 1 of its tapes with k − 1 incoming messages AU&apos;,F, to construct a joint distribution over the k variables in N(F), then projects onto the kth tape to marginalize over the k −1 U&apos; variables and get a distribution over U. All this can be accomplished by the WFSM generalized composition operator ® (Kempe et al., 2004). After projecting, it is desirable to determinize the WFSA. Otherwise, the summation in (3) is only implicit—the summands remain as distinct paths in the WFSA10—and thus the WFSAs would get larger and larger as BP proceeds. Unfortunately, determinizing a WFSA still does not guarantee a small result. In fact it can lead to exponential blowup, or even infinite blowup.11 Thus, in practice we recommend against determinizing the messages, which may be inherently complex. To shrink a message, it is safer to approximate it with a small deterministic WFSA, as discussed in the next section. 4.3 Approx</context>
</contexts>
<marker>Kempe, Champarnaud, Eisner, 2004</marker>
<rawString>Andr´e Kempe, Jean-Marc Champarnaud, and Jason Eisner. 2004. A note on join and auto-intersection of n-ary rational relations. In Loek Cleophas and Bruce Watson, editors, Proceedings of the Eindhoven FASTAR Days (Computer Science Technical Report 04-40). Department of Mathematics and Computer Science, Technische Universiteit Eindhoven, Netherlands.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kevin Knight</author>
<author>Jonathan Graehl</author>
</authors>
<title>Machine transliteration.</title>
<date>1997</date>
<booktitle>In Proc. of ACL,</booktitle>
<pages>128--135</pages>
<contexts>
<context position="23993" citStr="Knight and Graehl (1997)" startWordPosition="4040" endWordPosition="4043">models of several strings. To our knowledge, they have all chosen acyclic, directed graphical models. The acyclicity meant that exact inference was at least possible for them, if not necessarily efficient. The factors in these past models have been WFSTs (though typically simpler than the ones we will use). Many papers have used cascades of probabilistic finite-state transducers. Such a cascade may be regarded as a directed graphical model with a linear-chain structure. Pereira and Riley (1997) built a speech recognizer in this way, relating acoustic to phonetic to lexical strings. Similarly, Knight and Graehl (1997) presented a generative cascade using 4 variables and 5 factors: p(w, e,j,k,o) def= p(w)·p(e |w)·p(j |e)·p(k |j) ·p(o |k) where e is an English word sequence, w its pronunciation, j a Japanese version of the pronunciation, k a katakana rendering of the Japanese pronunciation, and o an OCR-corrupted version of the katakana. Knight and Graehl used finite-state operations to perform inference at test time, observing o and recovering the most likely w, while marginalizing out e, j, and k. Bouchard-Cˆot´e et al. (2009) reconstructed ancient word forms given modern equivalents. They used a directed </context>
</contexts>
<marker>Knight, Graehl, 1997</marker>
<rawString>Kevin Knight and Jonathan Graehl. 1997. Machine transliteration. In Proc. of ACL, pages 128–135.</rawString>
</citation>
<citation valid="false">
<authors>
<author>Philipp Koehn</author>
<author>Hieu Hoang</author>
<author>Alexandra Birch</author>
<author>Chris Callison-Burch</author>
<author>Marcello Federico</author>
<author>Nicola Bertoldi</author>
<author>Brooke Cowan</author>
<author>Wade Shen</author>
<author>Christine Moran</author>
<author>Richard Zens</author>
</authors>
<title>Chris Dyer, Ondrej Bojar,</title>
<date>2007</date>
<booktitle>In Proc. of ACL, Companion Volume,</booktitle>
<pages>177--180</pages>
<publisher>Association</publisher>
<institution>for Computational Linguistics.</institution>
<location>Alexandra</location>
<contexts>
<context position="35434" citStr="Koehn et al., 2007" startWordPosition="5935" endWordPosition="5938">or example, are trained from only 8 available examples. Non-loopy models always converge (exactly) in one iteration (see footnote 22). But even our loopy models appeared to converge in accuracy within two iterations. Only L3 and L4 required the second iteration, which made tiny improvements. 7.7 Test data results Based on the development results, we selected model L4 and tested on the remaining 9293 paradigms. We regard the unconnected model U as a baseline to improve upon. We also tried a rather different baseline as in (Dreyer et al., 2008). We trained the machine translation toolkit Moses (Koehn et al., 2007) to translate groups of letters rather than groups of words (“phrases”). For each form f to be predicted, we trained a Moses model on all supervised form pairs (l, f) available in the data, to learn a prediction for the form given the lemma l. The M,3 condition restricted Moses use “phrases” no longer than 3 letters, comparable to our own trigram-based factors (see section 7.2). M,15 could use up to 15 letters. Again, our novel L4 model far outperformed the others overall. Breaking the results down by form, we find that this advantage mainly comes from the 3 forms with the fewest observed trai</context>
</contexts>
<marker>Koehn, Hoang, Birch, Callison-Burch, Federico, Bertoldi, Cowan, Shen, Moran, Zens, 2007</marker>
<rawString>Philipp Koehn, Hieu Hoang, Alexandra Birch, Chris Callison-Burch, Marcello Federico, Nicola Bertoldi, Brooke Cowan, Wade Shen, Christine Moran, Richard Zens, Chris Dyer, Ondrej Bojar, Alexandra Constantin, and Evan Herbst. 2007. Moses: Open source toolkit for statistical machine translation. In Proc. of ACL, Companion Volume, pages 177–180, Prague, Czech Republic, June. Association for Computational Linguistics.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Alex Kulesza</author>
<author>Fernando Pereira</author>
</authors>
<title>Structured learning with approximate inference.</title>
<date>2008</date>
<booktitle>In Proc. of NIPS.</booktitle>
<contexts>
<context position="20729" citStr="Kulesza and Pereira (2008)" startWordPosition="3504" endWordPosition="3507">o locally maximize the probability of this training set, even though both the probability and its gradient are in general intractable to compute in an MRF. The gradient is a sum of quantities, one for each factor Fj. While the summand for Fj cannot be computed exactly, it can be estimated using the BP messages to Fj. Roughly speaking, the gradient for Fj is computed much as in supervised training (see above), but treating any message µV,→F; as an uncertain observation of Vi—a form of noisy supervision.15 Our concerns about training are the same as for any MRF. First of all, BP is approximate. Kulesza and Pereira (2008) warn that its estimates of the gradient can be misleading. Second, semisupervised training (which we will attempt below) is always difficult and prone to local optima. As in EM, a small number of supervised examples for some variable may be drowned out by many noisily reconstructed examples. Faster and potentially more stable approaches include the piecewise training methods of Sutton and McCallum (2008), which train the factors independently or in small groups. In the semisupervised case, each factor can be trained on only the supervised forms available for it. It might be useful to reweight</context>
</contexts>
<marker>Kulesza, Pereira, 2008</marker>
<rawString>Alex Kulesza and Fernando Pereira. 2008. Structured learning with approximate inference. In Proc. of NIPS.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Zhifei Li</author>
<author>Jason Eisner</author>
</authors>
<title>First- and secondorder expectation semirings with applications to minimum-risk training on translation forests.</title>
<date>2009</date>
<booktitle>In Proc. of EMNLP.</booktitle>
<contexts>
<context position="19155" citStr="Li and Eisner (2009" startWordPosition="3242" endWordPosition="3245">ing method for MRFs will transfer naturally to our setting. In all cases we draw on Eisner (2002), who showed how to train the parameters θ of a single WFST, F, to (locally) maximize the joint or conditional probability of fully or partially observed training data. This involves computing the gradient of that likelihood function with respect to θ.14 12See Li et al. (2009, footnote 9) for a sketch of the construction, which finds locally normalized edge weights. Or if Q is large but parameterized by some compact parameter vector 0, so we are only allowed to control its edge weights via 0, then Li and Eisner (2009, section 6) explain how to minimize KL(P 11 Q) by gradient descent. In both cases Q must be deterministic. We remark that if a factor F were specified by a synchronous grammar rather than a WFSM, then its outgoing messages would be weighted context-free languages. Exact intersection of these is undecidable, but they too can be approximated variationally by WFSAs, with the same methods. 13We are also considering other ways of adaptively choosing the topology of WFSA approximations at runtime, particularly in conjunction with expectation propagation. 14The likelihood is usually non-convex; even</context>
</contexts>
<marker>Li, Eisner, 2009</marker>
<rawString>Zhifei Li and Jason Eisner. 2009. First- and secondorder expectation semirings with applications to minimum-risk training on translation forests. In Proc. of EMNLP.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Zhifei Li</author>
<author>Jason Eisner</author>
<author>Sanjeev Khudanpur</author>
</authors>
<title>Variational decoding for statistical machine translation.</title>
<date>2009</date>
<booktitle>In Proc. of ACL.</booktitle>
<contexts>
<context position="18909" citStr="Li et al. (2009" startWordPosition="3197" endWordPosition="3200"> a determinized, minimized, acyclic WFSA. Now approximate the intersection of equation (2) as (( Q¯ n µF1→V ) n µF2→V ) n · · · . This is efficient to compute and has the same topology as ¯Q. 5 Training the Model Parameters Any standard training method for MRFs will transfer naturally to our setting. In all cases we draw on Eisner (2002), who showed how to train the parameters θ of a single WFST, F, to (locally) maximize the joint or conditional probability of fully or partially observed training data. This involves computing the gradient of that likelihood function with respect to θ.14 12See Li et al. (2009, footnote 9) for a sketch of the construction, which finds locally normalized edge weights. Or if Q is large but parameterized by some compact parameter vector 0, so we are only allowed to control its edge weights via 0, then Li and Eisner (2009, section 6) explain how to minimize KL(P 11 Q) by gradient descent. In both cases Q must be deterministic. We remark that if a factor F were specified by a synchronous grammar rather than a WFSM, then its outgoing messages would be weighted context-free languages. Exact intersection of these is undecidable, but they too can be approximated variational</context>
</contexts>
<marker>Li, Eisner, Khudanpur, 2009</marker>
<rawString>Zhifei Li, Jason Eisner, and Sanjeev Khudanpur. 2009. Variational decoding for statistical machine translation. In Proc. of ACL.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Mehryar Mohri</author>
</authors>
<title>Finite-state transducers in language and speech processing.</title>
<date>1997</date>
<journal>Computational Linguistics,</journal>
<volume>23</volume>
<issue>2</issue>
<contexts>
<context position="17155" citStr="Mohri, 1997" startWordPosition="2897" endWordPosition="2898">see section 3.2), there is an upper bound on the weights it assigns to strings. That guarantees that all the messages and beliefs computed by (2)–(4) will be proper FSMs, provided that all the factors are proper WFSMs. 9If it is unary, (3) trivially reduces to AF—.U = F. 10The usual implementation of projection does not change the topology of the WFST, but only deletes the U&apos; part of its arc labels. Thus, multiple paths that accept the same value of U remain distinct according to the distinct values of U&apos; that they were paired with before projection. 11If there is no deterministic equivalent (Mohri, 1997). 104 set. They are distributions over the infinite set E∗. A WFSA represents this in finite space, but more complex distributions require bigger WFSAs, with more distinct states and arc weights. Facing the same problem for distributions over the infinite set R, Sudderth et al. (2002) simplified each message µV →F, approximating a complex Gaussian mixture by using fewer components. We could act similarly, variationally approximating a large WFSA P with a smaller one Q. Choose a family of message approximations (such as bigram models) by specifying the topology for a (small) deterministic WFSA </context>
</contexts>
<marker>Mohri, 1997</marker>
<rawString>Mehryar Mohri. 1997. Finite-state transducers in language and speech processing. Computational Linguistics, 23(2).</rawString>
</citation>
<citation valid="true">
<authors>
<author>Fernando C N Pereira</author>
<author>Michael Riley</author>
</authors>
<title>Speech recognition by composition of weighted finite automata.</title>
<date>1997</date>
<booktitle>In Emmanuel Roche and Yves Schabes, editors, Finite-State Language Processing.</booktitle>
<publisher>MIT Press,</publisher>
<location>Cambridge, MA.</location>
<contexts>
<context position="23868" citStr="Pereira and Riley (1997)" startWordPosition="4020" endWordPosition="4023">s, (5) additional modeling power. 6.2 Simpler graphical models on strings Some previous researchers have used factored joint models of several strings. To our knowledge, they have all chosen acyclic, directed graphical models. The acyclicity meant that exact inference was at least possible for them, if not necessarily efficient. The factors in these past models have been WFSTs (though typically simpler than the ones we will use). Many papers have used cascades of probabilistic finite-state transducers. Such a cascade may be regarded as a directed graphical model with a linear-chain structure. Pereira and Riley (1997) built a speech recognizer in this way, relating acoustic to phonetic to lexical strings. Similarly, Knight and Graehl (1997) presented a generative cascade using 4 variables and 5 factors: p(w, e,j,k,o) def= p(w)·p(e |w)·p(j |e)·p(k |j) ·p(o |k) where e is an English word sequence, w its pronunciation, j a Japanese version of the pronunciation, k a katakana rendering of the Japanese pronunciation, and o an OCR-corrupted version of the katakana. Knight and Graehl used finite-state operations to perform inference at test time, observing o and recovering the most likely w, while marginalizing ou</context>
</contexts>
<marker>Pereira, Riley, 1997</marker>
<rawString>Fernando C. N. Pereira and Michael Riley. 1997. Speech recognition by composition of weighted finite automata. In Emmanuel Roche and Yves Schabes, editors, Finite-State Language Processing. MIT Press, Cambridge, MA.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Eric Sven Ristad</author>
<author>Peter N Yianilos</author>
</authors>
<title>Learning string edit distance.</title>
<date>1996</date>
<tech>Technical Report CS-TR532-96,</tech>
<institution>Princeton University, Department of Computer Science,</institution>
<contexts>
<context position="6932" citStr="Ristad and Yianilos, 1996" startWordPosition="1115" endWordPosition="1119">., alignments, which are not observed in training). In our setting, we will assume that each unary factor is specified by a weighted finite-state automaton (WFSA) whose weights fall in the semiring (R&gt;0, +, ×). Thus the score F3(..., V2SA = x,...) is the total weight of all paths in the F3’s WFSA that accept the string x E E∗2SA. Each path’s weight is the product of its component arcs’ weights, which are non-negative. Similarly, we assume that each binary factor is specified by a weighted finite-state transducer (WFST). Such a model is essentially a generalization of stochastic edit distance (Ristad and Yianilos, 1996) in which the edit probabilities can be made sensitive to a finite summary of context. Formally, a WFST is an automaton that resembles a weighted FSA, but it nondeterministically reads two strings x, y in parallel from left to right. The score of (x, y) is given by the total weight of all accepting paths in the WFST that map x to y. For example, different paths may consider various monotonic alignments of x with y, and we sum over these mutually exclusive possibilities.1 A factor might depend on k &gt; 2 variables. This requires a k-tape weighted finite-state machine (WFSM), an obvious generaliza</context>
</contexts>
<marker>Ristad, Yianilos, 1996</marker>
<rawString>Eric Sven Ristad and Peter N. Yianilos. 1996. Learning string edit distance. Technical Report CS-TR532-96, Princeton University, Department of Computer Science, October.</rawString>
</citation>
<citation valid="true">
<authors>
<author>David Smith</author>
<author>Jason Eisner</author>
</authors>
<title>Dependency parsing by belief propagation.</title>
<date>2008</date>
<booktitle>In Proc. of EMNLP.</booktitle>
<contexts>
<context position="12673" citStr="Smith and Eisner (2008)" startWordPosition="2113" endWordPosition="2116">ssage AV ,F, which is an (unnormalized) probability distribution over V ’s values v, computed by AF1,V (v) (2) F&apos;EN(V ),F&apos;�F where N is the set of neighbors of V in the graphical model. This message represents a consensus of V ’s other neighboring factors concerning V ’s value. It is how V tells F what its belief ˜pV would be if F were absent. Informally, it communicates to F: Here is what my value would be if it were up to my other neighboring factors F&apos; to determine. 5Notable exceptions are Sutton et al. (2004) for chunking and tagging, Sutton and McCallum (2004) for information extraction, Smith and Eisner (2008) for dependency parsing, and Cromier`es and Kurohashi (2009) for alignment. V AV,F (v) := 103 The factor F can then collect such incoming messages from neighboring variables and send its own message on to another neighbor U. Such a message AF,U suggests good values for U, in the form of an (unnormalized) distribution over U’s values u, computed by �AF ,U(u) := F(A) � AU&apos;,F (A[U&apos;]) A s.t.A[U]=u U&apos;EN(F),U&apos;�U (3) where A is an assignment to all variables, and A[U] is the value of variable U in that assignment. This message represents F’s prediction of U’s value based on its other neighboring vari</context>
<context position="22150" citStr="Smith and Eisner (2008)" startWordPosition="3752" endWordPosition="3755">th Other Approaches 6.1 Multi-tape WFSMs In principle, one could use a 100-tape WFSM to jointly model the 100 distinct forms of a typical Polish verb. In other words, the WFSM would describe the distribution of a random variable V~ = (V1, . . . , V100), where each Vi is a string. One would train the parameters of the WFSM on a ~ sample of V, each sample being a fully or partially observed paradigm for some Polish verb. The resulting distribution could be used to infer missing forms for these or other verbs. path through the WFST may be ambiguous and unobserved. 15See Bishop (2006), or consult Smith and Eisner (2008) for notation close to that of this paper. 105 As a simple example, either a morphological generator or a morphological analyzer might need the probability that krzyczałoby is the neuter thirdperson singular conditional imperfective of krzycze´c, despite never having observed it in training. The model determines this probability based on other observed and hypothesized forms of krzycze´c, using its knowledge of how neuter thirdperson singular conditional imperfectives are related to these other forms in other verbs. Unfortunately, such a 100-tape WFSM would be huge, with an astronomical number</context>
</contexts>
<marker>Smith, Eisner, 2008</marker>
<rawString>David Smith and Jason Eisner. 2008. Dependency parsing by belief propagation. In Proc. of EMNLP.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Andrew Smith</author>
<author>Trevor Cohn</author>
<author>Miles Osborne</author>
</authors>
<title>Logarithmic opinion pools for conditional random fields.</title>
<date>2005</date>
<booktitle>In Proc. ofACL,</booktitle>
<pages>18--25</pages>
<contexts>
<context position="21374" citStr="Smith et al. (2005)" startWordPosition="3611" endWordPosition="3614">f the gradient can be misleading. Second, semisupervised training (which we will attempt below) is always difficult and prone to local optima. As in EM, a small number of supervised examples for some variable may be drowned out by many noisily reconstructed examples. Faster and potentially more stable approaches include the piecewise training methods of Sutton and McCallum (2008), which train the factors independently or in small groups. In the semisupervised case, each factor can be trained on only the supervised forms available for it. It might be useful to reweight the trained factors (cf. Smith et al. (2005)), or train the factors consecutively (cf. Fahlman and Lebiere (1990)), in a way that minimizes the loss of BP decoding on held-out data. 6 Comparison With Other Approaches 6.1 Multi-tape WFSMs In principle, one could use a 100-tape WFSM to jointly model the 100 distinct forms of a typical Polish verb. In other words, the WFSM would describe the distribution of a random variable V~ = (V1, . . . , V100), where each Vi is a string. One would train the parameters of the WFSM on a ~ sample of V, each sample being a fully or partially observed paradigm for some Polish verb. The resulting distributi</context>
</contexts>
<marker>Smith, Cohn, Osborne, 2005</marker>
<rawString>Andrew Smith, Trevor Cohn, and Miles Osborne. 2005. Logarithmic opinion pools for conditional random fields. In Proc. ofACL, pages 18–25, June.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Erik B Sudderth</author>
<author>Alexander T Ihler</author>
<author>Er T Ihler</author>
<author>William T Freeman</author>
<author>Alan S Willsky</author>
</authors>
<title>Nonparametric belief propagation.</title>
<date>2002</date>
<booktitle>In Proc. of CVPR,</booktitle>
<pages>605--612</pages>
<contexts>
<context position="17440" citStr="Sudderth et al. (2002)" startWordPosition="2941" endWordPosition="2944">he usual implementation of projection does not change the topology of the WFST, but only deletes the U&apos; part of its arc labels. Thus, multiple paths that accept the same value of U remain distinct according to the distinct values of U&apos; that they were paired with before projection. 11If there is no deterministic equivalent (Mohri, 1997). 104 set. They are distributions over the infinite set E∗. A WFSA represents this in finite space, but more complex distributions require bigger WFSAs, with more distinct states and arc weights. Facing the same problem for distributions over the infinite set R, Sudderth et al. (2002) simplified each message µV →F, approximating a complex Gaussian mixture by using fewer components. We could act similarly, variationally approximating a large WFSA P with a smaller one Q. Choose a family of message approximations (such as bigram models) by specifying the topology for a (small) deterministic WFSA Q. Then choose Q’s edge weights to minimize the KL divergence KL(P 11 Q). This can be done in closed form.12 Another possible procedure—used in the experiments of this paper—approximates µV →F by pruning it back to a finite set of most plausible strings.13 Equation (2) requests an int</context>
</contexts>
<marker>Sudderth, Ihler, Ihler, Freeman, Willsky, 2002</marker>
<rawString>Erik B. Sudderth, Alexander T. Ihler, Er T. Ihler, William T. Freeman, and Alan S. Willsky. 2002. Nonparametric belief propagation. In Proc. of CVPR, pages 605–612.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Charles Sutton</author>
<author>Andrew McCallum</author>
</authors>
<title>Collective segmentation and labeling of distant entities in information extraction.</title>
<date>2004</date>
<booktitle>In ICML Workshop on Statistical Relational Learning and Its Connections to Other</booktitle>
<location>Fields.</location>
<contexts>
<context position="12621" citStr="Sutton and McCallum (2004)" startWordPosition="2106" endWordPosition="2109">ges of the factor graph. Variable V sends factor F a message AV ,F, which is an (unnormalized) probability distribution over V ’s values v, computed by AF1,V (v) (2) F&apos;EN(V ),F&apos;�F where N is the set of neighbors of V in the graphical model. This message represents a consensus of V ’s other neighboring factors concerning V ’s value. It is how V tells F what its belief ˜pV would be if F were absent. Informally, it communicates to F: Here is what my value would be if it were up to my other neighboring factors F&apos; to determine. 5Notable exceptions are Sutton et al. (2004) for chunking and tagging, Sutton and McCallum (2004) for information extraction, Smith and Eisner (2008) for dependency parsing, and Cromier`es and Kurohashi (2009) for alignment. V AV,F (v) := 103 The factor F can then collect such incoming messages from neighboring variables and send its own message on to another neighbor U. Such a message AF,U suggests good values for U, in the form of an (unnormalized) distribution over U’s values u, computed by �AF ,U(u) := F(A) � AU&apos;,F (A[U&apos;]) A s.t.A[U]=u U&apos;EN(F),U&apos;�U (3) where A is an assignment to all variables, and A[U] is the value of variable U in that assignment. This message represents F’s predict</context>
</contexts>
<marker>Sutton, McCallum, 2004</marker>
<rawString>Charles Sutton and Andrew McCallum. 2004. Collective segmentation and labeling of distant entities in information extraction. In ICML Workshop on Statistical Relational Learning and Its Connections to Other Fields.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Charles Sutton</author>
<author>Andrew McCallum</author>
</authors>
<title>Piecewise training for structured prediction. Machine Learning. In submission.</title>
<date>2008</date>
<contexts>
<context position="21137" citStr="Sutton and McCallum (2008)" startWordPosition="3569" endWordPosition="3573">ve), but treating any message µV,→F; as an uncertain observation of Vi—a form of noisy supervision.15 Our concerns about training are the same as for any MRF. First of all, BP is approximate. Kulesza and Pereira (2008) warn that its estimates of the gradient can be misleading. Second, semisupervised training (which we will attempt below) is always difficult and prone to local optima. As in EM, a small number of supervised examples for some variable may be drowned out by many noisily reconstructed examples. Faster and potentially more stable approaches include the piecewise training methods of Sutton and McCallum (2008), which train the factors independently or in small groups. In the semisupervised case, each factor can be trained on only the supervised forms available for it. It might be useful to reweight the trained factors (cf. Smith et al. (2005)), or train the factors consecutively (cf. Fahlman and Lebiere (1990)), in a way that minimizes the loss of BP decoding on held-out data. 6 Comparison With Other Approaches 6.1 Multi-tape WFSMs In principle, one could use a 100-tape WFSM to jointly model the 100 distinct forms of a typical Polish verb. In other words, the WFSM would describe the distribution of</context>
<context position="29355" citStr="Sutton and McCallum, 2008" startWordPosition="4902" endWordPosition="4905">igure for each word form is based on counts in the Mannheim News corpus. We hide forms with frequency &lt; 10. 19We dropped their latent classes and regions as well as features that detected which characters were orthographic vowels. Also, we retained their “target language model features” only in the baseline “U” model, since elsewhere they implemented and manipulated all WFSMs using the OpenFST library (Allauzen et al., 2007). 7.3 Training in the experiments We trained 0 on the incompletely observed paradigms. As suggested in section 5, we used a variant of piecewise pseudolikelihood training (Sutton and McCallum, 2008). Suppose there is a binary factor F attached to forms U and V . For any value of 0, we can define pUV (U |V ) from the tiny MRF consisting only of U, V , and F. def We can therefore compute the goodness LUV = log pUV (ui |vi)+logV U(vi |ui),20 summed over all observed (U, V ) pairs in training data. We attempted to tune 0 to maximize the total LUV over all U, V pairs,21 regularized by subtracting ||0||2. Note that different factors thus enjoyed different amounts of observed training data, but training was fully supervised (except for the unobserved alignments between ui and vi). 7.4 Inference</context>
</contexts>
<marker>Sutton, McCallum, 2008</marker>
<rawString>Charles Sutton and Andrew McCallum. 2008. Piecewise training for structured prediction. Machine Learning. In submission.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Charles Sutton</author>
<author>Khashayar Rohanimanesh</author>
<author>Andrew McCallum</author>
</authors>
<title>Dynamic conditional random fields: Factorized probabilistic models for labeling and segmenting sequence data.</title>
<date>2004</date>
<booktitle>In Proc. of ICML.</booktitle>
<contexts>
<context position="12568" citStr="Sutton et al. (2004)" startWordPosition="2098" endWordPosition="2101"> between the variables and factors along the edges of the factor graph. Variable V sends factor F a message AV ,F, which is an (unnormalized) probability distribution over V ’s values v, computed by AF1,V (v) (2) F&apos;EN(V ),F&apos;�F where N is the set of neighbors of V in the graphical model. This message represents a consensus of V ’s other neighboring factors concerning V ’s value. It is how V tells F what its belief ˜pV would be if F were absent. Informally, it communicates to F: Here is what my value would be if it were up to my other neighboring factors F&apos; to determine. 5Notable exceptions are Sutton et al. (2004) for chunking and tagging, Sutton and McCallum (2004) for information extraction, Smith and Eisner (2008) for dependency parsing, and Cromier`es and Kurohashi (2009) for alignment. V AV,F (v) := 103 The factor F can then collect such incoming messages from neighboring variables and send its own message on to another neighbor U. Such a message AF,U suggests good values for U, in the form of an (unnormalized) distribution over U’s values u, computed by �AF ,U(u) := F(A) � AU&apos;,F (A[U&apos;]) A s.t.A[U]=u U&apos;EN(F),U&apos;�U (3) where A is an assignment to all variables, and A[U] is the value of variable U in</context>
</contexts>
<marker>Sutton, Rohanimanesh, McCallum, 2004</marker>
<rawString>Charles Sutton, Khashayar Rohanimanesh, and Andrew McCallum. 2004. Dynamic conditional random fields: Factorized probabilistic models for labeling and segmenting sequence data. In Proc. of ICML.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>