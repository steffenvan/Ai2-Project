<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<title confidence="0.926444">
Higher-order Linear Logic Programming
of Categorial Deduction
</title>
<author confidence="0.935891">
Glyn Morrill
</author>
<affiliation confidence="0.5391445">
SecciO d&apos;Intel.figencia Artificial
Departament de Llenguatges i Sistemes Informatics
</affiliation>
<address confidence="0.886718">
Universitat Politecnica de Catalunya
Pau Gargallo, 5
08028 Barcelona
</address>
<email confidence="0.996994">
morrill@lsi.upc.es
</email>
<sectionHeader confidence="0.990299" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999986123595506">
We show how categorial deduction can
be implemented in higher-order (lin-
ear) logic programming, thereby realis-
ing parsing as deduction for the associa-
tive and non-associative Lambek calculi.
This provides a method of solution to
the parsing problem of Lambek catego-
rial grammar applicable to a variety of
its extensions.
The present work deals with the parsing prob-
lem for Lambek calculus and its extensions as de-
veloped in, for example, Moortgat (1988), van
Benthern (1991), Moortgat and Morrill (1991),
Moortgat and Oehrle (1993), Morrill (1994b) and
Hepple (1995). Some previous approaches to pars-
ing Lambek grammar such as Konig (1989), Hep-
ple (1990) and Hendriks (1993) have concentrated
on the possibilities of sequent proof normalisa-
tion. In Roorda (1991), Moortgat (1992), Hen-
driks (1993) and Oehrle (1994) a strategy of un-
folding and labelling for proof net construction is
considered. We aim to show here how such unfold-
ing allows compilation into programs executable
by a version of SLD resolution, implementing cat-
egorial deduction in dynamic linear clauses. The
linearity resides in the use exactly once per word
token of each of the clauses compiled from lexi-
cal categorisations. By dynamic, it is meant that
clauses may be higher-order (they are hereditary
Harrop Horn clauses) so that clausal resolution in-
volves insertion in, as well as retraction from, the
resolution database; see Miller et al. (1991), and
Hodas and Miller (1994).
It is shown how a range of calculi can be
treated by dealing with the highest common fac-
tor of connectives as linear logical validity. The
prosodic (i.e. sublinear) aspects of word order
and hierarchical structure are encoded in labels,
in effect the term structure of quantified linear
logic. Compiling labels according to interpreta-
tions in groupoids provides a general method for
calculi with various structural properties and also
for multimodal hybrid formulations. Unification
must be carried out according to the structural
axioms but is limited to one-way matching, i.e.
one term is always ground. Furthermore, for the
particular case of associative Lambek calculus an
additional perspective of binary relational inter-
pretation allows an especially efficient coding in
which the span of expressions is represented in
such a way as to avoid the computation of unifiers
under associativity, and this can also be exploited
for non-associative calculus.
Higher-order linear logic programming has al-
ready been applied to natural language process-
ing in, for example, Hodas (1992) and Hodas
and Miller (1994), in work deriving from Pareschi
(1989) and Pareschi and Miller (1990). What we
show here is that such implementation can be re-
alised systematically, indeed by a mechanical com-
pilation, while grammars themselves are written
in higher level categorial grammar formalism.
Automated deduction for Lambek calculi is of
interest in its own right but solution of the parsing
problem for categorial logic allowing significant
linguistic coverage demands automated deduction
for more than just individual calculi. There is
a need for methods applying to whole classes of
systems in ways which are principled and power-
ful enough to support the further generalisations
that grammar development will demand. We aim
to indicate here how higher-order logic program-
ming can provide for such a need.
After reviewing the &amp;quot;standard&amp;quot; approach, via
sequent proof normalisation, we outline the rel-
evant features of (linear) logic programming and
explain compilation and execution for associative
and non-associative calculi in terms of groupoid
and binary relational interpretations of categorial
connectives. We go on to briefly mention multi-
modal calculi for the binary connectives.
The parsing problem is usually construed as
the recovery of structural descriptions assigned
to strings by a grammar. In practice the inter-
est is in computing semantic forms implicit in the
structural descriptions, which are themselves usu-
ally implicit in the history of a derivation recog-
nising well-formedness of a string. This is true
in particular of compositional categorial architec-
</bodyText>
<page confidence="0.998411">
133
</page>
<bodyText confidence="0.99856325">
tures and we shall focus on algorithms for showing
well-formedness. The further step to computing
semantics is unproblematic.
For the non-associative Lambek calculus NL of
Lambek (1961) we assume types freely generated
from a set of primitive types by binary (infix) op-
erators \, / and •. A sequent comprises a succe-
dent type A and an antecedent configuration I&apos;
which is a binary bracketed list of one or more
types; we write F A. The notation r(A) here
refers to a configuration F with a distinguished
subconfiguration A.
</bodyText>
<listItem confidence="0.686808">
a. A A id F A (A) =B (1)
</listItem>
<equation confidence="0.9824879">
Cut
A(F) B
b. F=A z(B)=C [A, r] B
\L \R
A({r,A\BD C F A\B
r A B) =4&apos;.0
A([B IA, 11) C
d. F([A, C
•L
F(A.B) C
</equation>
<bodyText confidence="0.9988254">
For the associative Lambek calculus L of Lambek
(1958) the types are the same. A sequent com-
prises a succedent type A and an antecedent con-
figuration I&apos; which is a list of one or more types;
again we write I&apos; A.
</bodyText>
<listItem confidence="0.993045333333333">
a. A A id F=A A(A) B Cut (2)
A(F) B
b. F=A A (B) C A, r B
</listItem>
<equation confidence="0.987949375">
\L \R
A(F, A\B) C A\B
C. F=A A (B) =C
A
(B/A, r) c
d. F(A, B) C F A A B
•L
F(A.B) C F, A
</equation>
<bodyText confidence="0.9984405">
Lambek showed Cut-elimination for both calculi,
i.e. every theorem has a Cut-free proof. Of the
remaining rules each instance of premises has ex-
actly one connective occurrence less than the cor-
responding conclusion so Cut-elimination shows
decidability through finite space Cut-free sequent
proof search from conclusions to premises. Lifting
is derivable in NL as follows:
</bodyText>
<equation confidence="0.85134">
A=A B=B (3)
\L
/R
</equation>
<bodyText confidence="0.7464118">
[A, A\B] B
A B/(A\B)
erasing the brackets. But L-derivable composi-
tion depends essentially on associativity and is not
NL-derivable:
</bodyText>
<equation confidence="0.510684">
BB CC (4)
L
A A B, B\C C
\L
A, A\B, B\C C
\R
A\B, B\C A\C
</equation>
<bodyText confidence="0.999318736842105">
Even amongst the Cut-free proofs however there
is still semantic equivalence under the Curry-
Howard rendering (van Benthem, 1983; see Mor-
rill, 1994b) and in this respect redundancy in
parsing as exhaustive proof search since distinct
lines of inference converge on common subprob-
lems. This derivational equivalence (or: &amp;quot;spuri-
ous ambiguity&amp;quot;) betrays the permutability of cer-
tain rule applications. Thus two left rules may be
permutable: N/CN, CN, N \S S can be proved
by choosing to work on either connective first.
And left and right rules are permutable: N/CN,
CN S/(N \ S)) may be proved by applying a left
rule first, or a right rule, (and the latter step then
further admits the two options of the first exam-
ple). Such non-determinism is not significant se-
mantically: the variants have the same readings;
the non-determinism in partitioning by the binary
left rules in L is semantically significant, but still
a source of inefficiency in its backward chaining
&amp;quot;generate-and-test&amp;quot; incarnation. Another source
of derivational equivalence is that a complex id ax-
iom instance such as N \S N \S can be proved
either by a direct matching against the axiom
scheme, or by two rule applications. This is easily
solved by restricting id to atomic formulas. More
problematic are the permutability of rule applica-
tions, the non-determinism of rules requiring split-
ting of configurations in L, and the need in NL to
hypothesise configuration structure a priori (such
hierarchical structure is not given by the input
to the parsing problem). It seems that only the
first of these difficulties can be overcome from a
Gentzen sequent perspective.
The situation regarding equivalence and rule or-
dering is solved, at least for L—{.L}, by sequent
proof normalisation (Konig, 1989; Hepple, 1990;
Hendriks, 1993):
</bodyText>
<figure confidence="0.99592190625">
(5)
FI,A,F2
F=
A(
A(r,
A
A
B I A
A\B ) C
A( B) C
,F) c
A(
B1) CA, r FB1
\L*
r A\B
r, A
F
/R
B IA
/L [F, A] = B
/R
F BIA
F A A B
•R
F, A = A•B
F, A B
/R
F BIA
/L
A A id* A
,F2 B
P.
</figure>
<bodyText confidence="0.775894">
It is also derivable in L; indeed all NL deriva- This involves firstly ordering right rules before
tions are converted to L derivations by simply left rules reading from endsequent to axiom leaves
</bodyText>
<page confidence="0.994033">
134
</page>
<bodyText confidence="0.996895825">
(so left rules only apply to sequents with atomic
succedents; this effects uniform proof; see Miller
et al., 1991), and secondly further demanding
successive unfolding of the same configuration
type (&amp;quot;focusing&amp;quot;). In the *-ed rules the succe-
dent is atomic. A necessary condition for suc-
cess is that an antecedent type is only selected
by P* if it yields the succedent atom as its even-
tual range. Let us refer to (5) as L . L is
free of spurious ambiguity, and FL F A iff
1-0 A- . The focusing strategy breaks down
for .L: (VP/PP)/N, N.PP = VP requires switch-
ing between configuration types. It happens that
left occurrences of product are not motivated in
grammar, but more critically sequent proof nor-
malisation leaves the non-determinism of parti-
tioning, and offers no general method for multi-
modal extensions which may have complex and
interacting structural properties. To eliminate
the splitting problem we need some kind of repre-
sentation of configurations such that the domain
of functors need not be hypothesised and then
checked, but rather discovered by constraint prop-
agation. Such is the character of our treatment,
whereby partitioning is explored by unification in
the term structure of higher-order linear logic pio-
gramming, to which we now turn. By way of ori-
entation we review the (propositional) features of
clausal programming.
The first order case, naturally, corresponds to
Prolog. Let us assume a set AT OM of atomic
formulas, 0-ary, 1-ary, etc., formula constructors
{• A . . . A • }nE 10,1_4 and a binary (infix) formula
formula A and a database r which is a bag of
constructor A sequent comprises an agenda
program clauses 01, ..., B„bn,ii &gt; 0 (subscript
in for multiset); we write r A. In BNF, the
set of agendas corresponding to the nonterminal
Age ArDA and the set of program clauses corre-
sponding to the nonterminal PCS are defined by:
</bodyText>
<equation confidence="0.9398895">
AgegDA ::= goAc A ... A goAc (6)
PCGS ::= ATOM Age.VDA
</equation>
<bodyText confidence="0.9826475">
For first order programming the set g OAC of
goals is defined by:
</bodyText>
<equation confidence="0.840425">
.g0AG ATOM (7)
Then execution is guided by the following rules.
r, A A ax (8)
</equation>
<bodyText confidence="0.9977915">
I.e. the unit agenda is a consequence of any
database containing its atomic clause.
</bodyText>
<equation confidence="0.640105">
(9)
</equation>
<bodyText confidence="0.9967005">
I.e. we can resolve the first goal on the agenda with
the head of a program clause and then continue
with the program as before and a new agenda
given by prefixing the program clause subagenda
to the rest of the original agenda (depth-first
search).
For the higher-order case agendas and program
clauses are defined as above, but the notion of
GOAC on which they depend is generalised to in-
clude implications:
</bodyText>
<equation confidence="0.607181">
gOAG::= ATOM I goAc PC,CS (10)
</equation>
<bodyText confidence="0.729939">
And a &amp;quot;deduction theorem&amp;quot; rule of inference is
added:
</bodyText>
<equation confidence="0.859795">
r,B A r CI A ... A Cm (11)
r (A B) A CI A ...A Cm
</equation>
<bodyText confidence="0.938310111111111">
I.e. we solve a higher-order goal first on the agenda
by adding its precondition to the database and
trying to prove its postcondition.
In linear logic programming the rules become
resource conscious; in this context we write 0 for
the conjunction and o— for the implication:
A A ax (12)
I.e. an atomic agenda is a consequence of its unit
database: all program clauses must be &amp;quot;used up&amp;quot;
by the resolution rule:
(13)
RES
F,Ao—B10...0B„ A0C10...0C,„.
I.e. a program clause disappears from the database
once it is resolved upon: each is used exactly
once. The deduction theorem rule for higher-order
clauses also becomes sensitised to the employment
of antecedent contexts:
</bodyText>
<equation confidence="0.4756065">
DT
r, B A CI . • • 0 Cm (14)
</equation>
<bodyText confidence="0.999712272727273">
We shall motivate compilation into linear
clauses directly from simple algebraic models for
the calculi. In the case of L we have first inter-
pretation in semigroups (L,+) (i.e. sets L closed
under associative binary operations +; intuitively:
strings under concatenation). Relative to a model
each type A has an interpretation as a subset
D(A) of L. Given that primitive types are in-
terpreted as some such subsets, complex types re-
ceive their denotations by residuation as follows
(cf. e.g. Lambek, 1988):
</bodyText>
<equation confidence="0.994072333333333">
D(A.B) = Isi-Fs2181 E D(A) A 82 E D(B)} (15)
D(A\B) = {SIV&apos; E D(A),s&apos;+s E D(B)}
D(BIA) = {s1Vs&apos; E D(A),s+s&apos; E D(B))
</equation>
<bodyText confidence="0.997884">
For the non-associative calculus we drop the con-
dition of associativity and interpret in arbitrary
</bodyText>
<figure confidence="0.5435295">
CI. A ... A &amp;quot; RES
r, A +--- Bi A ... A Bn A A CI A ... A Cm
r, A B1 A... A B B1A... A
BA
DT
F ... Bn Ci .. 0 Cm
</figure>
<page confidence="0.986114">
135
</page>
<bodyText confidence="0.994507333333333">
groupoids (intuitively: trees under adjunction&apos;).
Categorial type assignment statements com-
prise a term a and a type A; we write a: A. Given
a set of lexical assignments, a phrasal assignment
is projected if and only if in every model satisfying
the lexical assignments the phrasal assignment is
also satisfied. A categorial sequent has a trans-
lation given by I • I into a linear sequent of type
assignments which can be safely read as predica-
tions. For L we have the following (NL preserves
input antecedent configuration in output succe-
dent term structure):
</bodyText>
<equation confidence="0.893485">
lBo (16), • • , Al =
ko: B , • • • • kn: B ko+ +kr,: A-
</equation>
<bodyText confidence="0.999316666666667">
Categorial type assignment statements are trans-
lated into linear logic according to the interpreta-
tion of types. The polar translation functions are
identity functions on atomic assignments; on com-
plex category predicates they are defined mutu-
ally as follows (for related unfolding, but for proof
nets, see Roorda, 1991; Moortgat, 1992; Hendriks,
1993; and Oehrle, 1994); 15 indicates the polarity
complementary to p:
</bodyText>
<equation confidence="0.9324845">
(17)
A\BP
7+a: BP 0— a: A9 a new variable/
y: B/AP constant as p +1-
</equation>
<bodyText confidence="0.999840909090909">
The unfolding transformations have the same gen-
eral form for the positive (configuration/database)
and negative (succedent/agenda) occurrences; the
polarity is used to indicate whether new symbols
introduced for quantified variables in the inter-
pretation clauses are metavariables (in italics) or
Skolem constants (in boldface); we shall see ex-
amples shortly. The program clauses and agenda
are read directly off the unfoldings, with the only
manipulation being a flattening of positive impli-
cations into uncurried form:
</bodyText>
<equation confidence="0.9874601">
((x+ 0- Yi-) Yn7
X + o- . . . ®Y,
databaser, A o- B1 . Bn
agenda
i. A 0 CI ... Cm
i+1. Bi ... Bn Ci ... Cm
database F,
agenda
i. (A 0- B) Ci 0 ... Cm DT
i+1. A 0 Ci 0 ... Cm
</equation>
<bodyText confidence="0.999907428571429">
The sharing of a Skolem constant between A and
B in (20) ensures that B can and must be used to
prove A so that a mechanism for the lazy splitting
of contexts is effected. The termination condition
is met by a unit agenda with its unit database.
By way of illustration for L consider composi-
tion given the sequent translation (21).
</bodyText>
<equation confidence="0.839949666666667">
IA\B, B\C = A\CI= (21)
k: A\B+, 1: B \C+ k+1: A\C-
The assignments are unfolded thus:
B o- a: A C o-- b: B(22)
k: A\B+ 1: B\C+
m-1-(k4-1): C o- m: A
k+1: A \ C-
Then the proof runs as follows.
database B o- a: A3, (23)
C o- b: B2,
in: A1
agenda
</equation>
<table confidence="0.2258378125">
1. m+(k-F1): Ca- m: A DT
&apos;2. m+(k+1): C RES b = m+k
B RES a = m
in: A RES
non-
BP 0- a: Ai&amp;quot;
a new variable/
constant as p +/-
RES
The unification at line 2 relies on associativity.
Note that unifications are all one-way, but even
one-way associative (=string) unification has ex-
pensive worst cases.
For NL the term labelling provides a clausal
(18) implementation with unification being
associative. Consider lifting:
</table>
<bodyText confidence="0.994128142857143">
(This means that matching against the head of a
clause and assembly of subgoals does not require
any recursion or restructuring at runtime.) We
shall also allow unit program clauses X o- to be
abbreviated X.
Starting from the initial database and agenda,
a proof will be represented as a list of agendas,
avoiding the context repetition of sequent proofs
by indicating where the resolution rule retracts
from the database (superscript coindexed over-
line), and where the deduction theorem rule adds
to it (subscript coindexation):
&apos;Though NL with product is incomplete with re-
spect to finite trees as opposed to groupoids in general.
</bodyText>
<equation confidence="0.9878629">
B/(A\B)I = k: A = k: B/(A\B) (24)
a-Fl: B o- a: A (25)
k-I-1: B o- 1: A \
k: B/(A\B)-
The proof is as follows.
k: A3, (26)
B o- a: Al2
k+1: B o- (a+1: B o- a: A) DT
B RES a = k
k: A RES
</equation>
<bodyText confidence="0.780877">
database
agenda
</bodyText>
<page confidence="0.995632">
136
</page>
<bodyText confidence="0.999940791666667">
The simple one-way term unification is very fast
but it is unnatural from the point of view of pars-
ing that, as for the sequent approach, a hierarchi-
cal binary structure on the input string needs to
be posited before inference begins, and exhaustive
search would require all possibilities to be tried.
Later we shall see how hierarchical structure can
be discovered rather than conjectured by factoring
out horizontal structure.
Let us note here the relation to L L applies
(working back from the target sequent) right rules
before left rules. Here, when a higher-order goal
is found on the agenda its precondition is added
to the database by DT. This precedes applications
of the RES rule (hence the uniformity character)
which corresponds to the left sequent inferences.
It applies when the agenda goal is atomic and
picks out antecedent types which yields that atom
(cf. the eventual range condition of L ). The fo-
cusing character is embodied by creating in one
step the objective of seeking all the arguments of
an uncurried functor.
By way of further example consider the follow-
ing in L, with terms and types as indicated.
</bodyText>
<equation confidence="0.3793085">
(a book from which) the references are missing (27)
the references are missing (28)
r: N m: ((S/(N\S))\S)/PP
r+m: S/PP
</equation>
<bodyText confidence="0.9995165">
We have compilation for &apos;are missing&apos; as in Fig-
ure 1 yielding (29).
</bodyText>
<equation confidence="0.952965">
I&gt; (29)
b-Hin-Fa): S o- (b+k: S o- (c+k: S o- c: N)) 0 a: PP
</equation>
<bodyText confidence="0.99933045">
And the succedent unfolds as follows:
The problem is that a and 0 are not determin-
istically given by 7 at the &amp;quot;compile time&amp;quot; of un-
folding. The best we could manage seems to be to
try different partitionings of 7 at execution time;
but even if this could work it would still amount
to trying different partitionings for *It as in the
sequent calculus: a source of non-determinism we
seek to reduce. This limitation combines with the
other difficulties with groupoid labelling of worst
case of (even) one-way associative unification for
L, and the need for a priori hypothesis of non-
associative structure for NL.
The method of solution resides in looking at
an alternative model: the associative calculus has
relational algebraic models (van Benthem, 1991)
which interpret types as relations on some set V,
i.e. as sets of ordered pairs. Given denotations
for primitive types, those of compound types are
fixed as subsets of V x V by:
</bodyText>
<equation confidence="0.999353">
D (A\B) = {(1)2, v3)IV (v , v2) E D (A), (32)
(vi, v3) E D(B))
D( B I A) = ((vi, v2)IV (v2, v3) E D (A),
(vi, v3) E D(B))
D(A• I (v , v 3)132)2 , (Vi, v2) E D(A)
(v2, v3) E D (B))
</equation>
<bodyText confidence="0.999492">
Points in V intuitively corresponds to string posi-
tions (as in definite clause grammars, and charts)
and ordered pairs to the vertices of substrings per-
taining to the categories to which they are as-
signed. This induces unfolding as follows:
</bodyText>
<equation confidence="0.998652714285714">
i - k: BP o- j: Al7 i new variable/ (33)
j - k: A\BP constant as p +I-
- k: BP o- J k:A k new variable/
i -.j: BIAP constant as p +I-
(r+m)+1: S o- 1: PP (30) Furthermore right product (though still not non-
r-Fm: S&amp;P-
i&gt; (r+m)+1: So-I: PP
</equation>
<bodyText confidence="0.999436230769231">
Derivation is as in figure 2. The unification at line
2 relies on associativity and as always atomic goals
on the agenda are ground. But in general we have
to try subproofs for different unifiers, that is, we
effectively still have to guess partitioning for left
rules. We shall see that this is not necessary, and
that associative unification can be avoided.
There is a further problem which will be solved
in the same move. Unfolding of left products
would create two positive subformulas and thus
fall outside the scope of Horn clause programming.
However, the term-labelled implementation as it
has been given also fails for right products:
</bodyText>
<equation confidence="0.6800752">
a: A- 0 B- (31)
7 - a+S?
A•B-
Horn left product) unfolding can be expressed:
i - j: A- 0 j - k: B- (34)
</equation>
<bodyText confidence="0.631784666666667">
j new variable
Composition is now treated as follows. Assume
sequent translation thus:
</bodyText>
<equation confidence="0.975929666666667">
1.A\B, B\C A\CI= (35)
0 - 1: A\B+, 1 - 2: B\C+ 0 - 2: A\C-
The assignments are compiled as shown in (36).
z - 1: B o- i - 0: A (36)
0 - 1: A\B+
j - 2: C o- j - 1: B 3 - 2: C o- 3 - 0: A
- 2: B\C+ 0 - 2: A \C-
The proof is thus:
i - k: A•B-
</equation>
<page confidence="0.996251">
137
</page>
<figure confidence="0.8556386">
c+k: S o- c: N
b+k: S o- k: N\S+
b+(m+a): S o- b: S/(N\S)-
In-Fa: (SAN \S))\S+ o- a: PP
m: ((S/(N\S))\S)/PP+
</figure>
<figureCaption confidence="0.9767">
Figure 1: Groupoid compilation of the assignment to &apos;are missing&apos;
</figureCaption>
<figure confidence="0.5544064">
database r: N5,
b-1-(m+a): So- (b±k: S o- (c+k: S o- c: N)) a: PP 2,
171,T-.16,
c+k: S o- c: N34,
agenda
</figure>
<listItem confidence="0.990433666666667">
1. (r+m)+1: S o- 1: PP
2. (r+m)+1: S
3. S o- (c+k: S o- c: N)) 1: PP
4. r+k: S®1: PP
5. r: NØ1: PP
6. 1: PP
</listItem>
<figure confidence="0.996782833333333">
DT
RES b=r, a=1
DT
RES c=r
RES
RES
</figure>
<figureCaption confidence="0.931459">
Figure 2: Groupoid execution for &apos;the references are missing&apos;
</figureCaption>
<figure confidence="0.727077142857143">
database i - 1: Bo- i -0: A3,
3 -2: Co-3 - 1: B2,
3 - 0: A14
agenda 3 - 2: Co-3 -0: A
1. 3 - 2: C
&apos;. 3 - 1: B
3 - 0: A
</figure>
<bodyText confidence="0.999592428571429">
In this way associative unification is avoided; in-
deed the only matching is trivial unification be-
tween constants and variables. So for L the rela-
tional compilation allows partitioning by the bi-
nary rules to be discovered by simple constraint
propagation rather than by the generate-and-test
strategy of normalised sequent proof.
Although the (one-way) term unification for
groupoid compilation of the non-associative cal-
culus is very fast we want to get round the fact
that a hierarchical binary structure on the input
string needs to be posited before inference begins.
We can do this through observation of the follow-
ing:
</bodyText>
<listItem confidence="0.993556636363636">
• All non-associative theorems are associative
theorems (ignore brackets)
• Interpret non-associative operators in the
product algebra of NL groupoid algebra and
L relational algebra, and perform labelled
compilation accordingly
• Use the (efficient) relational labelling to check
associative validity
• Use the groupoid labelling to check non-
associative validity and compute the prosodic
form induced
</listItem>
<bodyText confidence="0.986886666666667">
I.e. the endsequent succedent groupoid term can
be left as a variable and the groupoid unification
performed on the return trip from axiom leaves af-
ter associative validity has been assured, as will be
seen in our final example. The groupoid unifica-
tion will now be one-way in the opposite direction.
The simultaneous compilation separates hori-
zontal structure (word order) represented by inter-
val segments, and horizontal-and-vertical struc-
ture (linear and hierarchical organisation) repre-
sented by groupoid terms, and uses the efficient
segment labelling to compute L-validity, and then
the term labelling both to check the stricter NL-
validity, and to calculate the hierarchical struc-
ture. In this way we use the fact that models for
NL are given by intersection in the product of re-
lational and groupoid models. Each type A has
an interpretation D(A) as a subset of LxVx V:
</bodyText>
<equation confidence="0.9978455">
D(A\B) = ((s, v2, v3)IV(81, v1, v2) E D(A), (38)
(si+s, v1, v3) E D(B)}
D(B I A) = {(s, vi , v2)IV (s&apos; , 112, v3) E D(A);
(s+s&apos;, vi, v3) E D(B)}
D(A. B) = {(si 32 , v , v3)13v2, (sf., , v2) E D(A)
(s2,v2, v3) E D(B)}
</equation>
<bodyText confidence="0.380003">
Unfolding is thus:
</bodyText>
<figure confidence="0.920758956521739">
a+-y-i-k: BP 0- -j:
A\BP
7-f-a-i-k: BP o-
-y-i-j: BIAP
A- 0 0.-j-k: .13-
- k: A•B-
(37)
DT
RES j =3
RES i = 3
RES
(39)
a, i new variables/
constants as p +1-
a,k new variables/
constants as p +1-
a, 9, j new variables
138
S 0— c-1-1: N
S 0- k-1-4: N\S+
b+(m+a)-i-ki: S 0- b-i-1: S/(N\S)- 0- a-2-ki: PP
m-Fa-1-ki: (S/(N\S))\S+
m-1-2: ((S/(N\S))\S)/PP+
</figure>
<figureCaption confidence="0.987006">
Figure 3: Groupoid-relational compilation of the assignment to &apos;are missing&apos;
</figureCaption>
<table confidence="0.7757435">
database TITITTC14,
S 0-(b+k-i-4: S 0- (c-l-k-1-4: S 0- c-1-1: N)) (2) : PP&apos;,
c+k-1-4: So- c-1-1: N23,
f-2-3: PP5
agenda
d-0-3: S RES d = b-1-(m+a)
(b+k-0-4: So-(c-fk-i-4: So- c-I-1: N))®a-2-3: PP DT
S 0a-2-3: PP RES b = c
c-0-1: N0a-2-3: PP RES c = r
a-2-3: PP RES a = f
</table>
<figureCaption confidence="0.993881">
Figure 4: Groupoid-relational execution for the references are missing from this book&apos;
</figureCaption>
<figure confidence="0.9708063">
By way of example consider the following:
are missing (40)
cf+,-y: BP o- a new variable/
-y:A\,BP
the references
(44)
constant as p +/-
r-0-1: N m-1-2: ((S/(N\S))\S)/PP
from this book
f-2-3: PP d-0-3: S
</figure>
<bodyText confidence="0.9210075">
The unfolding compilation yielding (41) for are
missing&apos; is given in Figure 3.
</bodyText>
<equation confidence="0.824013666666667">
(41)
: S 0-
(b+k-i-4: S 0- (c+k-/-4: So- c-1-1: N)) a-2-ki: PP
</equation>
<bodyText confidence="0.99772675">
The derivation is given in Figure 4. Note how
the term unification computing the hierarchical
structure can be carried out one-way in the re-
verse order to the forward segment matchings:
</bodyText>
<equation confidence="0.938027">
d = b-1-(m+a) = c-F(m+a) = r+(m-Fa) = (42)
rd-(m+f)
</equation>
<bodyText confidence="0.958210125">
In the case of NL-invalidity the term unification
would fail.
We mention finally multimodal generalisations.
In multimodal calculi families of connectives
{ii, \i,•i}ie { 1,...,0 are each defined by residua-
tion with respect to their adjunction in a &amp;quot;poly-
groupoid&amp;quot; (L, {+i}iE11,...,n}) (Moortgat and Mor-
rill, 1991):
</bodyText>
<equation confidence="0.697548714285714">
D(AcB) = E D(A) A 82 E D(B)) (43)
D(A\,B) = IsiVs&apos;E D(A), -I-is E D(B))
D(B I iA) = E D(A), E D(B))
Multimodal groupoid compilation for implications
is immediate:
BP o- A&apos;i5 a new variable/
: B I,AP constant as p +1-
</equation>
<bodyText confidence="0.999862586206896">
This is entirely general. Any multimodal cal-
culus can be implemented this way provided we
have a (one-way) unification algorithm specialised
according to the structural communication ax-
ioms. For example Morrill (1993) deals with mul-
timodality for discontinuity which involves vary-
ing internal structural properties (associativity vs.
non-associativity) as well as &amp;quot;split/wrap&amp;quot; interac-
tion between modes. This is treated computa-
tionally in the current manner in Morrill (1994a)
which also considers head-oriented discontinuity
and unary operators projecting bracketed string
structure. In these cases also simultaneous com-
pilation including binary relational labelling can
provide additional advantages.
Labelled unfolding of categorial formulas has
been invoked in the references cited as a way of
checking well-formedness of proof nets for catego-
rial calculi by unification of labels on linked for-
mulas. This offers improvements over sequent for-
mulations but raises alternative problems; for ex-
ample associative unification in general can have
infinite solutions and is undecidable. Taking lin-
ear validity as the highest common factor of sub-
linear categorial calculi we have been able to show
a strategy based on resolution in which the flow of
information is such that one term in unification is
always ground. Furthermore binary relational la-
belling propagates constraints in such a way that
</bodyText>
<page confidence="0.996641">
139
</page>
<bodyText confidence="0.999962846153846">
computation of unifiers may be reduced to a sub-
set of cases or avoided altogether. Higher-order
coding allows emission of hypotheticals to be post-
poned until they are germane. Simultaneous com-
pilation allows a factoring out of horizontal struc-
ture from vertical structure within the sublinear
space in such a way that the partial information of
word order can drive computation of hierarchical
structure for the categorial parsing problem in the
presence of non-associativity. The treatments for
the calculi above and their multimodal generalisa-
tions have been implemented in Prolog (Morrill,
1994a).
</bodyText>
<sectionHeader confidence="0.999433" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999832696078432">
van Benthem, Johan: 1983, &apos;The Semantics of
Variety in Categorial Grammar&apos;, Report 83-29,
Department of Mathematics, Simon Fraser Uni-
versity, also in Buszkowski, W., W. Marciszewski,
and J. van Benthem (eds.): 1988, Categorial
Grammar, Linguistic k, Literary Studies in East-
ern Europe Volume 25, John Benjamins, Amster-
dam, 37-55.
van Benthem, J.: 1991, Language in Action:
Categories, Lambdas and Dynamic Logic, Studies
in Logic and the Foundations of Mathematics Vol-
ume 130, North-Holland, Amsterdam.
Hendriks, Herman: 1993, Studied Flexibility:
Categories and Types in Syntax and Semantics,
Ph.D dissertation, Institute for Logic, Language
and Computation, Universiteit van Amsterdam.
Hepple, Mark: 1990, The Grammar and Pro-
cessing of Order and Dependency: A Categorial
Approach, Ph.D. dissertation, University of Edin-
burgh.
Hepple, Mark: 1995, &apos;Mixing Modes of Linguis-
tic Description in Categorial Grammar&apos;, this vol-
ume.
Hodas, J.: 1992, &apos;Specifying Filler-Gap De-
pendency Parsers in a Linear-Logic Programming
Language&apos;, in Proceedings of the Joint Interna-
tional Conference and Symposium on Logic Pro-
gramming, 622-636.
Hodas, Joshua and Dale Miller: 1994, &apos;Logic
Programming in a Fragment of Intuitionistic Lin-
ear Logic&apos;, to appear in Journal of Information
and Computation.
Konig, E.: 1989, &apos;Parsing as natural deduction&apos;,
in Proceedings of the Annual Meeting of the Asso-
ciation for Computational Linguistics, Vancouver.
Lambek, J.: 1958, &apos;The mathematics of sentence
structure&apos;, American Mathematical Monthly 65,
154-170, also in Buszkowski, W., W. Mar-
ciszewski, and J. van Benthem (eds.): 1988, Cate-
gorial Grammar, Linguistic &amp; Literary Studies in
Eastern Europe Volume 25, John. Benjamins, Am-
sterdam, 153-172.
Lambek, J.: 1961, &apos;On the calculus of syntactic
types&apos;, in R. Jakobson (ed.) Structure of language
and its mathematical aspects, Proceedings of the
Symposia in Applied Mathematics XII, American
Mathematical Society, 166-178.
Lambek, J.: 1988, &apos;Categorial and Categorical
Grammars&apos;, in Richard T. Oehrle, Emmon Bach,
and Deidre Wheeler (eds.) Categorial Grammars
and Natural Language Structures, Studies in Lin-
guistics and Philosophy Volume 32, D. Reidel,
Dordrecht, 297-317.
Miller, D., G. Nadathur, F. Pfenning, and
A. Scedrov: 1991, &apos;Uniform Proofs as a Founda-
tion for Logic Programming&apos;, Annals of Pure and
Applied Logic 51, 125-157.
Moortgat, Michael: 1988, Categorial Investiga-
tions: Logical and Linguistic Aspects of the Lam-
bek Calculus, Foris, Dordrecht.
Moortgat, Michael: 1992, &apos;Labelled Deductive
Systems for categorial theorem proving&apos;, OTS
Working Paper OTS-WP-CL-92-003, Rijksuni-
versiteit Utrecht, also in Proceedings of the Eighth
Amsterdam Colloquium, Institute for Language,
Logic and Information, Universiteit van Amster-
dam.
Moortgat, Michael and Glyn Morrill: 1991,
&apos;Heads and Phra.ses: Type Calculus for Depen-
dency and Constituent Structure&apos;, to appear in
Journal of Language, Logic, and Information.
Moortgat, Michael and Dick Oehrle: 1994, &apos;Ad-
jacency, dependency and order&apos;, in Proceedings of
the Ninth Amsterdam Colloquium, 447-466.
Morrill, Glyn: 1993, Discontinuity and Pied-
Piping in Categorial Grammar, Report de Re-
cerca LSI-93-18-R, Departament de Llenguatges
i Sistemes Informatics, Universitat Politecnica de
Catalunya, to appear in Linguistics and Philoso-
phy.
Morrill, Glyn: 1994a, &apos;Higher-Order Linear
Logic Programming of Categorial Deduction&apos;, Re-
port de Recerca LSI-94-42-R, Departament de
Llenguatges i Sistemes Informatics, Universitat
Politecnica de Catalunya
Morrill, Glyn: 1994b, Type Logical Grammar:
Categorial Logic of Signs, Kluwer Academic Pub-
lishers, Dordrecht.
Oehrle, Dick: 1994, &apos;Term labelled categorial
type systems&apos;, to appear in Linguistics and Phi-
losophy.
Pareschi, R.: 1989, Type-driven Natural Lan-
guage Analysis, Ph.D. thesis, University of Edin-
burgh.
Pareschi, R. and D, Miller: 1990, &apos;Extend-
ing Definite Clause Grammars with Scoping Con-
structs&apos;, in D.H.D. Warren and P. Szeredi (eds.)
1990 International Conference in Logic Program-
ming, MIT Press, 373-389.
Roorda, Dirk: 1991, Resource Logics: proof-
theoretical investigations, Ph.D. dissertation, Uni-
versiteit van Amsterdam.
</reference>
<page confidence="0.99754">
140
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.000000">
<title confidence="0.9995625">Higher-order Linear Logic Programming of Categorial Deduction</title>
<author confidence="0.999479">Glyn Morrill</author>
<affiliation confidence="0.875158333333333">SecciO d&apos;Intel.figencia Artificial Departament de Llenguatges i Sistemes Informatics Universitat Politecnica de Catalunya</affiliation>
<address confidence="0.99307">Pau Gargallo, 5 08028 Barcelona</address>
<email confidence="0.995212">morrill@lsi.upc.es</email>
<abstract confidence="0.995405708737864">We show how categorial deduction can be implemented in higher-order (linear) logic programming, thereby realising parsing as deduction for the associative and non-associative Lambek calculi. This provides a method of solution to the parsing problem of Lambek categorial grammar applicable to a variety of its extensions. The present work deals with the parsing problem for Lambek calculus and its extensions as developed in, for example, Moortgat (1988), van Benthern (1991), Moortgat and Morrill (1991), Moortgat and Oehrle (1993), Morrill (1994b) and Hepple (1995). Some previous approaches to parsing Lambek grammar such as Konig (1989), Hepple (1990) and Hendriks (1993) have concentrated on the possibilities of sequent proof normalisation. In Roorda (1991), Moortgat (1992), Hendriks (1993) and Oehrle (1994) a strategy of unfolding and labelling for proof net construction is considered. We aim to show here how such unfolding allows compilation into programs executable by a version of SLD resolution, implementing categorial deduction in dynamic linear clauses. The linearity resides in the use exactly once per word token of each of the clauses compiled from lexical categorisations. By dynamic, it is meant that clauses may be higher-order (they are hereditary Harrop Horn clauses) so that clausal resolution involves insertion in, as well as retraction from, the resolution database; see Miller et al. (1991), and Hodas and Miller (1994). It is shown how a range of calculi can be treated by dealing with the highest common factor of connectives as linear logical validity. The prosodic (i.e. sublinear) aspects of word order and hierarchical structure are encoded in labels, in effect the term structure of quantified linear logic. Compiling labels according to interpretations in groupoids provides a general method for calculi with various structural properties and also for multimodal hybrid formulations. Unification must be carried out according to the structural but is limited to i.e. one term is always ground. Furthermore, for the particular case of associative Lambek calculus an additional perspective of binary relational interpretation allows an especially efficient coding in which the span of expressions is represented in such a way as to avoid the computation of unifiers under associativity, and this can also be exploited for non-associative calculus. Higher-order linear logic programming has already been applied to natural language processing in, for example, Hodas (1992) and Hodas and Miller (1994), in work deriving from Pareschi (1989) and Pareschi and Miller (1990). What we show here is that such implementation can be realised systematically, indeed by a mechanical compilation, while grammars themselves are written in higher level categorial grammar formalism. Automated deduction for Lambek calculi is of interest in its own right but solution of the parsing problem for categorial logic allowing significant linguistic coverage demands automated deduction for more than just individual calculi. There is a need for methods applying to whole classes of systems in ways which are principled and powerful enough to support the further generalisations that grammar development will demand. We aim to indicate here how higher-order logic programming can provide for such a need. After reviewing the &amp;quot;standard&amp;quot; approach, via sequent proof normalisation, we outline the relevant features of (linear) logic programming and explain compilation and execution for associative and non-associative calculi in terms of groupoid and binary relational interpretations of categorial connectives. We go on to briefly mention multimodal calculi for the binary connectives. The parsing problem is usually construed as the recovery of structural descriptions assigned to strings by a grammar. In practice the interest is in computing semantic forms implicit in the structural descriptions, which are themselves usually implicit in the history of a derivation recognising well-formedness of a string. This is true particular of compositional categorial architec- 133 a. tures and we shall focus on algorithms for showing well-formedness. The further step to computing semantics is unproblematic. For the non-associative Lambek calculus NL of Lambek (1961) we assume types freely generated from a set of primitive types by binary (infix) operators \, / and •. A sequent comprises a succetype an antecedent configuration I&apos; which is a binary bracketed list of one or more we write notation r(A) here refers to a configuration F with a distinguished subconfiguration A.</abstract>
<title confidence="0.8318672">A A id F A (A) Cut F=A \L \R A({r,A\BD</title>
<abstract confidence="0.643457944444444">B) =4&apos;.0 A([B IA, F([A, •L For the associative Lambek calculus L of Lambek (1958) the types are the same. A sequent coma succedent type antecedent configuration I&apos; which is a list of one or more types; we write I&apos; A A F=A A(A) (2) F=A A C A, \L \R A(F, C A\B =C A (B/A, F(A, C A A •L F(A.B) C F, A Lambek showed Cut-elimination for both calculi, i.e. every theorem has a Cut-free proof. Of the remaining rules each instance of premises has exactly one connective occurrence less than the corresponding conclusion so Cut-elimination shows decidability through finite space Cut-free sequent proof search from conclusions to premises. Lifting is derivable in NL as follows: B=B \L /R [A, A\B] B A B/(A\B) erasing the brackets. But L-derivable composition depends essentially on associativity and is not NL-derivable: BB CC (4)</abstract>
<title confidence="0.8696142">L A A B, B\C C \L A, A\B, B\C C \R</title>
<abstract confidence="0.987307189189189">A\B, B\C A\C the Cut-free proofs however there is still semantic equivalence under the Curry- Howard rendering (van Benthem, 1983; see Morrill, 1994b) and in this respect redundancy in parsing as exhaustive proof search since distinct lines of inference converge on common subproblems. This derivational equivalence (or: &amp;quot;spurious ambiguity&amp;quot;) betrays the permutability of certain rule applications. Thus two left rules may be permutable: N/CN, CN, N \S S can be proved by choosing to work on either connective first. And left and right rules are permutable: N/CN, CN S/(N \ S)) may be proved by applying a left rule first, or a right rule, (and the latter step then further admits the two options of the first example). Such non-determinism is not significant semantically: the variants have the same readings; the non-determinism in partitioning by the binary rules in L significant, but still a source of inefficiency in its backward chaining &amp;quot;generate-and-test&amp;quot; incarnation. Another source derivational equivalence is that a complex id axiom instance such as N \S N \S can be proved either by a direct matching against the axiom scheme, or by two rule applications. This is easily solved by restricting id to atomic formulas. More problematic are the permutability of rule applications, the non-determinism of rules requiring splitting of configurations in L, and the need in NL to hypothesise configuration structure a priori (such hierarchical structure is not given by the input to the parsing problem). It seems that only the first of these difficulties can be overcome from a Gentzen sequent perspective. The situation regarding equivalence and rule ordering is solved, at least for L—{.L}, by sequent</abstract>
<note confidence="0.7182325">proof normalisation (Konig, 1989; Hepple, 1990; Hendriks, 1993):</note>
<title confidence="0.814568625">A( A(r, A A B I A A\B ) C C A(</title>
<address confidence="0.812354">CA, FB1</address>
<email confidence="0.531848">\L*</email>
<title confidence="0.965321636363636">r, A F /R B IA /L = B /R A A •R A = B /R</title>
<abstract confidence="0.959191739776952">L id* A It is also derivable in L; indeed all NL deriva- This involves firstly ordering right rules before tions are converted to L derivations by simply left rules reading from endsequent to axiom leaves 134 (so left rules only apply to sequents with atomic this effects uniform proof; et al., 1991), and secondly further demanding successive unfolding of the same configuration type (&amp;quot;focusing&amp;quot;). In the *-ed rules the succedent is atomic. A necessary condition for success is that an antecedent type is only selected P* if it yields the succedent atom as its evenrange. Let us refer to (5) as . L free of spurious ambiguity, and FL F A iff . focusing strategy breaks down for .L: (VP/PP)/N, N.PP = VP requires switching between configuration types. It happens that left occurrences of product are not motivated in grammar, but more critically sequent proof normalisation leaves the non-determinism of partitioning, and offers no general method for multimodal extensions which may have complex and interacting structural properties. To eliminate the splitting problem we need some kind of representation of configurations such that the domain of functors need not be hypothesised and then checked, but rather discovered by constraint propagation. Such is the character of our treatment, whereby partitioning is explored by unification in the term structure of higher-order linear logic piogramming, to which we now turn. By way of orientation we review the (propositional) features of clausal programming. The first order case, naturally, corresponds to Let us assume a set OM atomic formulas, 0-ary, 1-ary, etc., formula constructors . . . A • and a binary (infix) formula a database is a bag of A sequent an agenda clauses ..., (subscript for multiset); we write In BNF, the set of agendas corresponding to the nonterminal the set of program clauses correto the nonterminal defined by: ::= ... A ATOM Age.VDA first order programming the set OAC goals is defined by: Then execution is guided by the following rules. A A ax I.e. the unit agenda is a consequence of any database containing its atomic clause. I.e. we can resolve the first goal on the agenda with the head of a program clause and then continue with the program as before and a new agenda given by prefixing the program clause subagenda to the rest of the original agenda (depth-first search). For the higher-order case agendas and program clauses are defined as above, but the notion of which they depend is generalised to include implications: ATOM And a &amp;quot;deduction theorem&amp;quot; rule of inference is added: A ... A (A A ...A I.e. we solve a higher-order goal first on the agenda by adding its precondition to the database and prove its postcondition. In linear logic programming the rules become conscious; in this context we write 0 the conjunction and o— for the implication: (12) I.e. an atomic agenda is a consequence of its unit database: all program clauses must be &amp;quot;used up&amp;quot; by the resolution rule: (13) RES I.e. a program clause disappears from the database once it is resolved upon: each is used exactly once. The deduction theorem rule for higher-order clauses also becomes sensitised to the employment of antecedent contexts: DT . • • 0 We shall motivate compilation into linear clauses directly from simple algebraic models for calculi. In the case of have first interin semigroups sets under associative binary operations +; intuitively: strings under concatenation). Relative to a model type an interpretation as a subset that primitive types are interpreted as some such subsets, complex types retheir denotations by follows (cf. e.g. Lambek, 1988): = 82 = = {s1Vs&apos; the non-associative calculus we the condition of associativity and interpret in arbitrary A... A &amp;quot;RES +--- Bi ... A A A A ... A B1 A A BA DT ... Ci .. 0 Cm 135 groupoids (intuitively: trees under adjunction&apos;). Categorial type assignment statements coma term a and a type A; we write a: a set of lexical assignments, a phrasal assignment is projected if and only if in every model satisfying the lexical assignments the phrasal assignment is satisfied. sequent has a translation given by I • I into a linear sequent of type assignments which can be safely read as predica- For have the following input antecedent configuration in output succedent term structure): (16), • • , = B • • • • B ko+ Categorial type assignment statements are translated into linear logic according to the interpretation of types. The polar translation functions are identity functions on atomic assignments; on complex category predicates they are defined mutually as follows (for related unfolding, but for proof nets, see Roorda, 1991; Moortgat, 1992; Hendriks, and Oehrle, 1994); the polarity complementary to p: (17) BP A9 new variable/ B/AP as The unfolding transformations have the same general form for the positive (configuration/database) and negative (succedent/agenda) occurrences; the polarity is used to indicate whether new symbols introduced for quantified variables in the interpretation clauses are metavariables (in italics) or constants (in boldface); we shall examples shortly. The program clauses and agenda directly off the unfoldings, with the only manipulation being a flattening of positive implications into uncurried form: 0- Yn7 X + o- . . . ®Y, . Bn agenda 0 ... Cm ... Ci ... Cm database F, agenda 0- B) Ci 0 ... Cm A 0 Ci 0 ... sharing of a Skolem constant between (20) ensures that and must be used to prove A so that a mechanism for the lazy splitting of contexts is effected. The termination condition is met by a unit agenda with its unit database. way of illustration for composition given the sequent translation (21). B\C = (21) B \C+ k+1: The assignments are unfolded thus: oa: A C o-k: A\B+ 1: B\C+ m-1-(k4-1): C om: A A \ proof runs as follows. B oa: (23) oin: A1 agenda 1. m+(k-F1): Cam: A DT &apos;2. m+(k+1): C = B RES a = m in: A RES nona: variable/ +/- (19) RES The unification at line 2 relies on associativity. Note that unifications are all one-way, but even one-way associative (=string) unification has expensive worst cases. the labelling provides a clausal (18) implementation with unification being associative. Consider lifting: (This means that matching against the head of a clause and assembly of subgoals does not require any recursion or restructuring at runtime.) We shall also allow unit program clauses X oto be abbreviated X. from the initial database and proof will be represented as a list of avoiding the context repetition of sequent proofs by indicating where the resolution rule retracts from the database (superscript coindexed overline), and where the deduction theorem rule adds to it (subscript coindexation): with product is incomplete with respect to finite trees as opposed to groupoids in general. B/(A\B)I = k: A = k: B/(A\B) (24) a-Fl: B oa: A (25) k-I-1: B o- 1: A \ The proof is as follows. (26) oa: k+1: B o- (a+1: B oa: A) DT B RES a = k k: A RES database agenda 136 The simple one-way term unification is very fast but it is unnatural from the point of view of parsing that, as for the sequent approach, a hierarchical binary structure on the input string needs to be posited before inference begins, and exhaustive search would require all possibilities to be tried. Later we shall see how hierarchical structure can be discovered rather than conjectured by factoring out horizontal structure. us note here the relation to LL (working back from the target sequent) right rules before left rules. Here, when a higher-order goal is found on the agenda its precondition is added to the database by DT. This precedes applications of the RES rule (hence the uniformity character) which corresponds to the left sequent inferences. It applies when the agenda goal is atomic and picks out antecedent types which yields that atom the eventual range condition of ). focharacter is embodied creating in one step the objective of seeking all the arguments of an uncurried functor. By way of further example consider the followin L, terms and as indicated. (a book from which) the references are missing (27) the references are missing (28) N m: r+m: S/PP We have compilation for &apos;are missing&apos; as in Figure 1 yielding (29). I&gt; (29) S oo- S oc: N)) 0 a: And the succedent unfolds as follows: problem is that a and not deterministically given by 7 at the &amp;quot;compile time&amp;quot; of unfolding. The best we could manage seems to be to try different partitionings of 7 at execution time; even if this could work it would still trying partitionings for in the sequent calculus: a source of non-determinism we seek to reduce. This limitation combines with the other difficulties with groupoid labelling of worst case of (even) one-way associative unification for the need for a priori hypothesis of nonstructure for The method of solution resides in looking at an alternative model: the associative calculus has relational algebraic models (van Benthem, 1991) which interpret types as relations on some set V, i.e. as sets of ordered pairs. Given denotations for primitive types, those of compound types are</abstract>
<note confidence="0.774111666666667">fixed as subsets of V x V by: (A\B) = {(1)2, v3)IV (v , E (A), v3) E B I A) = ((vi, v2)IV (v2, v3) (A), E I (v , v 3)132)2 , v2</note>
<abstract confidence="0.97323365625">v3) (B)) in corresponds to string posi- (as in definite clause grammars, and and ordered pairs to the vertices of substrings pertaining to the categories to which they are assigned. This induces unfolding as follows: BP oi variable/ (33) k: A\BP as +Ik: BP ok variable/ BIAP as +I- PP (30) right product (though still not noni&gt; (r+m)+1: So-I: PP Derivation is as in figure 2. The unification at line 2 relies on associativity and as always atomic goals on the agenda are ground. But in general we have to try subproofs for different unifiers, that is, we effectively still have to guess partitioning for left rules. We shall see that this is not necessary, and that associative unification can be avoided. There is a further problem which will be solved in the same move. Unfolding of left products create two positive subformulas and fall outside the scope of Horn clause programming. However, the term-labelled implementation as it has been given also fails for right products: 0 (31) A•B- Horn left product) unfolding can be expressed: 0 j k: (34) j variable Composition is now treated as follows. Assume sequent translation thus:</abstract>
<note confidence="0.845328833333333">1.A\B, B\C A\CI= (35) - 1: 1 B\C+ 0 - 2: The assignments are compiled as shown in (36). - 1: B oi - 0: (36) 0 - 1: A\B+ C 3 - 2: C o- 3 - 0: A 2: B\C+ 0 \C- The proof is thus: k: 137 S ob+k: S ok: N\S+ S o- In-Fa: (SAN \S))\S+ oa: PP m: ((S/(N\S))\S)/PP+ Figure 1: Groupoid compilation of the assignment to &apos;are missing&apos; r: So- (b±k: S o- (c+k: S oa: PP S oagenda 1. (r+m)+1: S o- 1: PP 2. (r+m)+1: S S o- (c+k: S o- 1: PP 4. r+k: S®1: PP 5. r: NØ1: PP 6. 1: PP DT RES b=r, a=1 DT RES c=r RES RES Figure 2: Groupoid execution for &apos;the references are missing&apos; i - 1: Boi -0: Co-3 - 1: - 0:</note>
<abstract confidence="0.9161506375">agenda 1. 3 - 2: Co-3 -0: A 3 - 2: C 3 - 1: B 3 - 0: A &apos;. In this way associative unification is avoided; indeed the only matching is trivial unification between constants and variables. So for L the relational compilation allows partitioning by the binary rules to be discovered by simple constraint propagation rather than by the generate-and-test strategy of normalised sequent proof. Although the (one-way) term unification for groupoid compilation of the non-associative calculus is very fast we want to get round the fact that a hierarchical binary structure on the input string needs to be posited before inference begins. We can do this through observation of the following: • All non-associative theorems are associative theorems (ignore brackets) • Interpret non-associative operators in the product algebra of NL groupoid algebra and L relational algebra, and perform labelled compilation accordingly • Use the (efficient) relational labelling to check associative validity • Use the groupoid labelling to check nonassociative validity and compute the prosodic form induced I.e. the endsequent succedent groupoid term can be left as a variable and the groupoid unification performed on the return trip from axiom leaves after associative validity has been assured, as will be seen in our final example. The groupoid unification will now be one-way in the opposite direction. The simultaneous compilation separates horizontal structure (word order) represented by interval segments, and horizontal-and-vertical structure (linear and hierarchical organisation) represented by groupoid terms, and uses the efficient segment labelling to compute L-validity, and then the term labelling both to check the stricter NLvalidity, and to calculate the hierarchical structure. In this way we use the fact that models for NL are given by intersection in the product of relational and groupoid models. Each type A has interpretation a subset of LxVx = ((s, v2) E I A) = {(s, vi , v2)IV (s&apos; , 112, v3) E B) = {(si 32 , v , (sf., , E E Unfolding is thus: BP A\BP BP o- 0 A•B- (37) DT RES i = 3 RES (39) a, i new variables/ constants as p +1variables/ as p variables 138 S c-1-1: S 0k-1-4: N\S+ S 0- 0a-2-ki: PP m-Fa-1-ki: (S/(N\S))\S+ m-1-2: ((S/(N\S))\S)/PP+ 3: compilation of the assignment to &apos;are missing&apos; 0-(b+k-i-4: S 0- (c-l-k-1-4: S 0- (2) : Soagenda d-0-3: S So-(c-fk-i-4: So- PP DT S 0a-2-3: PP c-0-1: N0a-2-3: PP r RES a = f 4: execution for the references are missing from this book&apos; By way of example consider the following: are missing (40) a new variable/ -y:A\,BP the references (44) constant as p +/r-0-1: N m-1-2: ((S/(N\S))\S)/PP from this book f-2-3: PP d-0-3: S The unfolding compilation yielding (41) for are missing&apos; is given in Figure 3. (41) : S 0- S 0- (c+k-/-4: So- N)) PP The derivation is given in Figure 4. Note how the term unification computing the hierarchical can be carried out in the reverse order to the forward segment matchings: d = b-1-(m+a) = c-F(m+a) = r+(m-Fa) = (42) rd-(m+f) case of NL-invalidity the term unification would fail. We mention finally multimodal generalisations. In multimodal calculi families of connectives {ii, \i,•i}ie { 1,...,0 are each defined by residuation with respect to their adjunction in a &amp;quot;poly- {+i}iE11,...,n}) and Morrill, 1991): = 82 = -I-is E D(B)) I iA) = Multimodal groupoid compilation for implications is immediate: oa new variable/ B I,AP as p This is entirely general. Any multimodal calculus can be implemented this way provided we have a (one-way) unification algorithm specialised according to the structural communication axioms. For example Morrill (1993) deals with multimodality for discontinuity which involves varying internal structural properties (associativity vs. non-associativity) as well as &amp;quot;split/wrap&amp;quot; interaction between modes. This is treated computationally in the current manner in Morrill (1994a) which also considers head-oriented discontinuity and unary operators projecting bracketed string In these cases simultaneous compilation including binary relational labelling can provide additional advantages. Labelled unfolding of categorial formulas has been invoked in the references cited as a way of checking well-formedness of proof nets for categocalculi by unification of labels on formulas. This offers improvements over sequent formulations but raises alternative problems; for example associative unification in general can have infinite solutions and is undecidable. Taking linear validity as the highest common factor of sublinear categorial calculi we have been able to show a strategy based on resolution in which the flow of information is such that one term in unification is always ground. Furthermore binary relational labelling propagates constraints in such a way that 139 computation of unifiers may be reduced to a subset of cases or avoided altogether. Higher-order coding allows emission of hypotheticals to be postponed until they are germane. Simultaneous compilation allows a factoring out of horizontal structure from vertical structure within the sublinear space in such a way that the partial information of word order can drive computation of hierarchical structure for the categorial parsing problem in the presence of non-associativity. The treatments for the calculi above and their multimodal generalisations have been implemented in Prolog (Morrill, 1994a).</abstract>
<note confidence="0.6436413">References van Benthem, Johan: 1983, &apos;The Semantics of Variety in Categorial Grammar&apos;, Report 83-29, Department of Mathematics, Simon Fraser University, also in Buszkowski, W., W. Marciszewski, J. van Benthem (eds.): 1988, k, Literary Studies in Eastern Europe Volume 25, John Benjamins, Amsterdam, 37-55. Benthem, J.: 1991, in Action:</note>
<affiliation confidence="0.4679945">Lambdas and Dynamic Logic, in Logic and the Foundations of Mathematics Vol-</affiliation>
<address confidence="0.66466">ume 130, North-Holland, Amsterdam. Herman: 1993, Flexibility:</address>
<keyword confidence="0.7357775">Categories and Types in Syntax and Semantics, Ph.D dissertation, Institute for Logic, Language</keyword>
<affiliation confidence="0.585493">and Computation, Universiteit van Amsterdam.</affiliation>
<address confidence="0.513653">Mark: 1990, Grammar and Pro-</address>
<affiliation confidence="0.5575605">cessing of Order and Dependency: A Categorial dissertation, University of Edin-</affiliation>
<abstract confidence="0.91170625">burgh. Hepple, Mark: 1995, &apos;Mixing Modes of Linguistic Description in Categorial Grammar&apos;, this volume.</abstract>
<note confidence="0.833848291139241">Hodas, J.: 1992, &apos;Specifying Filler-Gap Dependency Parsers in a Linear-Logic Programming in of the Joint International Conference and Symposium on Logic Pro- Hodas, Joshua and Dale Miller: 1994, &apos;Logic Programming in a Fragment of Intuitionistic Lin- Logic&apos;, to appear in of Information and Computation. Konig, E.: 1989, &apos;Parsing as natural deduction&apos;, of the Annual Meeting of the Asso- Computational Linguistics, Lambek, J.: 1958, &apos;The mathematics of sentence Mathematical Monthly 154-170, also in Buszkowski, W., W. Marand J. van Benthem (eds.): 1988, Cate- Grammar, &amp; Literary Studies in Europe Volume 25, Benjamins, Amsterdam, 153-172. Lambek, J.: 1961, &apos;On the calculus of syntactic in R. Jakobson (ed.) of language its mathematical aspects, of the Symposia in Applied Mathematics XII, American Mathematical Society, 166-178. Lambek, J.: 1988, &apos;Categorial and Categorical Grammars&apos;, in Richard T. Oehrle, Emmon Bach, Deidre Wheeler (eds.) Grammars Natural Language Structures, in Linguistics and Philosophy Volume 32, D. Reidel, Dordrecht, 297-317. Miller, D., G. Nadathur, F. Pfenning, and A. Scedrov: 1991, &apos;Uniform Proofs as a Foundafor Logic Programming&apos;, of Pure and Logic 125-157. Michael: 1988, Investigations: Logical and Linguistic Aspects of the Lam- Calculus, Dordrecht. Moortgat, Michael: 1992, &apos;Labelled Deductive Systems for categorial theorem proving&apos;, OTS Working Paper OTS-WP-CL-92-003, Rijksuni- Utrecht, also in of the Eighth Colloquium, for Language, Logic and Information, Universiteit van Amsterdam. Moortgat, Michael and Glyn Morrill: 1991, &apos;Heads and Phra.ses: Type Calculus for Dependency and Constituent Structure&apos;, to appear in Journal of Language, Logic, and Information. Moortgat, Michael and Dick Oehrle: 1994, &apos;Addependency and order&apos;, in of Ninth Amsterdam Colloquium, Glyn: 1993, and Piedin Categorial Grammar, de Recerca LSI-93-18-R, Departament de Llenguatges i Sistemes Informatics, Universitat Politecnica de to appear in and Philosophy. Morrill, Glyn: 1994a, &apos;Higher-Order Linear Logic Programming of Categorial Deduction&apos;, Report de Recerca LSI-94-42-R, Departament de Llenguatges i Sistemes Informatics, Universitat Politecnica de Catalunya Glyn: 1994b, Logical Grammar: Logic of Signs, Academic Publishers, Dordrecht. Oehrle, Dick: 1994, &apos;Term labelled categorial systems&apos;, to appear in and Philosophy. R.: 1989, Natural Lan- Analysis, thesis, University of Edinburgh. Pareschi, R. and D, Miller: 1990, &apos;Extending Definite Clause Grammars with Scoping Constructs&apos;, in D.H.D. Warren and P. Szeredi (eds.) 1990 International Conference in Logic Program- Press, 373-389. Dirk: 1991, Logics: proofinvestigations, dissertation, Universiteit van Amsterdam. 140</note>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>van Benthem</author>
</authors>
<title>The Semantics of Variety in Categorial Grammar&apos;,</title>
<date>1983</date>
<booktitle>1988, Categorial Grammar, Linguistic k, Literary Studies in Eastern Europe Volume 25,</booktitle>
<tech>Report 83-29,</tech>
<pages>37--55</pages>
<editor>also in Buszkowski, W., W. Marciszewski, and J. van Benthem (eds.):</editor>
<institution>Department of Mathematics, Simon Fraser University,</institution>
<location>Johan:</location>
<marker>van Benthem, 1983</marker>
<rawString>van Benthem, Johan: 1983, &apos;The Semantics of Variety in Categorial Grammar&apos;, Report 83-29, Department of Mathematics, Simon Fraser University, also in Buszkowski, W., W. Marciszewski, and J. van Benthem (eds.): 1988, Categorial Grammar, Linguistic k, Literary Studies in Eastern Europe Volume 25, John Benjamins, Amsterdam, 37-55.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J van Benthem</author>
</authors>
<title>Language in Action: Categories, Lambdas and Dynamic Logic,</title>
<date>1991</date>
<booktitle>Studies in Logic and the Foundations of Mathematics Volume 130, North-Holland,</booktitle>
<location>Amsterdam.</location>
<marker>van Benthem, 1991</marker>
<rawString>van Benthem, J.: 1991, Language in Action: Categories, Lambdas and Dynamic Logic, Studies in Logic and the Foundations of Mathematics Volume 130, North-Holland, Amsterdam.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Herman Hendriks</author>
</authors>
<title>Studied Flexibility: Categories and Types</title>
<date>1993</date>
<booktitle>in Syntax and Semantics, Ph.D dissertation, Institute for Logic, Language and Computation, Universiteit</booktitle>
<location>van Amsterdam.</location>
<contexts>
<context position="931" citStr="Hendriks (1993)" startWordPosition="134" endWordPosition="135">er-order (linear) logic programming, thereby realising parsing as deduction for the associative and non-associative Lambek calculi. This provides a method of solution to the parsing problem of Lambek categorial grammar applicable to a variety of its extensions. The present work deals with the parsing problem for Lambek calculus and its extensions as developed in, for example, Moortgat (1988), van Benthern (1991), Moortgat and Morrill (1991), Moortgat and Oehrle (1993), Morrill (1994b) and Hepple (1995). Some previous approaches to parsing Lambek grammar such as Konig (1989), Hepple (1990) and Hendriks (1993) have concentrated on the possibilities of sequent proof normalisation. In Roorda (1991), Moortgat (1992), Hendriks (1993) and Oehrle (1994) a strategy of unfolding and labelling for proof net construction is considered. We aim to show here how such unfolding allows compilation into programs executable by a version of SLD resolution, implementing categorial deduction in dynamic linear clauses. The linearity resides in the use exactly once per word token of each of the clauses compiled from lexical categorisations. By dynamic, it is meant that clauses may be higher-order (they are hereditary Ha</context>
<context position="7768" citStr="Hendriks, 1993" startWordPosition="1272" endWordPosition="1273">lications. This is easily solved by restricting id to atomic formulas. More problematic are the permutability of rule applications, the non-determinism of rules requiring splitting of configurations in L, and the need in NL to hypothesise configuration structure a priori (such hierarchical structure is not given by the input to the parsing problem). It seems that only the first of these difficulties can be overcome from a Gentzen sequent perspective. The situation regarding equivalence and rule ordering is solved, at least for L—{.L}, by sequent proof normalisation (Konig, 1989; Hepple, 1990; Hendriks, 1993): (5) FI,A,F2 F= A( A(r, A A B I A A\B ) C A( B) C ,F) c A( B1) CA, r FB1 \L* r A\B r, A F /R B IA /L [F, A] = B /R F BIA F A A B •R F, A = A•B F, A B /R F BIA /L A A id* A ,F2 B P. It is also derivable in L; indeed all NL deriva- This involves firstly ordering right rules before tions are converted to L derivations by simply left rules reading from endsequent to axiom leaves 134 (so left rules only apply to sequents with atomic succedents; this effects uniform proof; see Miller et al., 1991), and secondly further demanding successive unfolding of the same configuration type (&amp;quot;focusing&amp;quot;). In t</context>
<context position="13349" citStr="Hendriks, 1993" startWordPosition="2295" endWordPosition="2296">given by I • I into a linear sequent of type assignments which can be safely read as predications. For L we have the following (NL preserves input antecedent configuration in output succedent term structure): lBo (16), • • , Al = ko: B , • • • • kn: B ko+ +kr,: ACategorial type assignment statements are translated into linear logic according to the interpretation of types. The polar translation functions are identity functions on atomic assignments; on complex category predicates they are defined mutually as follows (for related unfolding, but for proof nets, see Roorda, 1991; Moortgat, 1992; Hendriks, 1993; and Oehrle, 1994); 15 indicates the polarity complementary to p: (17) A\BP 7+a: BP 0— a: A9 a new variable/ y: B/AP constant as p +1- The unfolding transformations have the same general form for the positive (configuration/database) and negative (succedent/agenda) occurrences; the polarity is used to indicate whether new symbols introduced for quantified variables in the interpretation clauses are metavariables (in italics) or Skolem constants (in boldface); we shall see examples shortly. The program clauses and agenda are read directly off the unfoldings, with the only manipulation being a </context>
</contexts>
<marker>Hendriks, 1993</marker>
<rawString>Hendriks, Herman: 1993, Studied Flexibility: Categories and Types in Syntax and Semantics, Ph.D dissertation, Institute for Logic, Language and Computation, Universiteit van Amsterdam.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Mark Hepple</author>
</authors>
<title>The Grammar and Processing of Order and Dependency: A Categorial Approach,</title>
<date>1990</date>
<institution>University of Edinburgh.</institution>
<note>Ph.D. dissertation,</note>
<contexts>
<context position="911" citStr="Hepple (1990)" startWordPosition="130" endWordPosition="132">mplemented in higher-order (linear) logic programming, thereby realising parsing as deduction for the associative and non-associative Lambek calculi. This provides a method of solution to the parsing problem of Lambek categorial grammar applicable to a variety of its extensions. The present work deals with the parsing problem for Lambek calculus and its extensions as developed in, for example, Moortgat (1988), van Benthern (1991), Moortgat and Morrill (1991), Moortgat and Oehrle (1993), Morrill (1994b) and Hepple (1995). Some previous approaches to parsing Lambek grammar such as Konig (1989), Hepple (1990) and Hendriks (1993) have concentrated on the possibilities of sequent proof normalisation. In Roorda (1991), Moortgat (1992), Hendriks (1993) and Oehrle (1994) a strategy of unfolding and labelling for proof net construction is considered. We aim to show here how such unfolding allows compilation into programs executable by a version of SLD resolution, implementing categorial deduction in dynamic linear clauses. The linearity resides in the use exactly once per word token of each of the clauses compiled from lexical categorisations. By dynamic, it is meant that clauses may be higher-order (th</context>
<context position="7751" citStr="Hepple, 1990" startWordPosition="1270" endWordPosition="1271">y two rule applications. This is easily solved by restricting id to atomic formulas. More problematic are the permutability of rule applications, the non-determinism of rules requiring splitting of configurations in L, and the need in NL to hypothesise configuration structure a priori (such hierarchical structure is not given by the input to the parsing problem). It seems that only the first of these difficulties can be overcome from a Gentzen sequent perspective. The situation regarding equivalence and rule ordering is solved, at least for L—{.L}, by sequent proof normalisation (Konig, 1989; Hepple, 1990; Hendriks, 1993): (5) FI,A,F2 F= A( A(r, A A B I A A\B ) C A( B) C ,F) c A( B1) CA, r FB1 \L* r A\B r, A F /R B IA /L [F, A] = B /R F BIA F A A B •R F, A = A•B F, A B /R F BIA /L A A id* A ,F2 B P. It is also derivable in L; indeed all NL deriva- This involves firstly ordering right rules before tions are converted to L derivations by simply left rules reading from endsequent to axiom leaves 134 (so left rules only apply to sequents with atomic succedents; this effects uniform proof; see Miller et al., 1991), and secondly further demanding successive unfolding of the same configuration type (</context>
</contexts>
<marker>Hepple, 1990</marker>
<rawString>Hepple, Mark: 1990, The Grammar and Processing of Order and Dependency: A Categorial Approach, Ph.D. dissertation, University of Edinburgh.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Mark Hepple</author>
</authors>
<title>Mixing Modes of Linguistic Description in Categorial Grammar&apos;, this volume.</title>
<date>1995</date>
<contexts>
<context position="823" citStr="Hepple (1995)" startWordPosition="116" endWordPosition="117"> 5 08028 Barcelona morrill@lsi.upc.es Abstract We show how categorial deduction can be implemented in higher-order (linear) logic programming, thereby realising parsing as deduction for the associative and non-associative Lambek calculi. This provides a method of solution to the parsing problem of Lambek categorial grammar applicable to a variety of its extensions. The present work deals with the parsing problem for Lambek calculus and its extensions as developed in, for example, Moortgat (1988), van Benthern (1991), Moortgat and Morrill (1991), Moortgat and Oehrle (1993), Morrill (1994b) and Hepple (1995). Some previous approaches to parsing Lambek grammar such as Konig (1989), Hepple (1990) and Hendriks (1993) have concentrated on the possibilities of sequent proof normalisation. In Roorda (1991), Moortgat (1992), Hendriks (1993) and Oehrle (1994) a strategy of unfolding and labelling for proof net construction is considered. We aim to show here how such unfolding allows compilation into programs executable by a version of SLD resolution, implementing categorial deduction in dynamic linear clauses. The linearity resides in the use exactly once per word token of each of the clauses compiled fr</context>
</contexts>
<marker>Hepple, 1995</marker>
<rawString>Hepple, Mark: 1995, &apos;Mixing Modes of Linguistic Description in Categorial Grammar&apos;, this volume.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Hodas</author>
</authors>
<title>Specifying Filler-Gap Dependency Parsers in a Linear-Logic Programming Language&apos;,</title>
<date>1992</date>
<booktitle>in Proceedings of the Joint International Conference and Symposium on Logic Programming,</booktitle>
<pages>622--636</pages>
<contexts>
<context position="2789" citStr="Hodas (1992)" startWordPosition="425" endWordPosition="426">. Unification must be carried out according to the structural axioms but is limited to one-way matching, i.e. one term is always ground. Furthermore, for the particular case of associative Lambek calculus an additional perspective of binary relational interpretation allows an especially efficient coding in which the span of expressions is represented in such a way as to avoid the computation of unifiers under associativity, and this can also be exploited for non-associative calculus. Higher-order linear logic programming has already been applied to natural language processing in, for example, Hodas (1992) and Hodas and Miller (1994), in work deriving from Pareschi (1989) and Pareschi and Miller (1990). What we show here is that such implementation can be realised systematically, indeed by a mechanical compilation, while grammars themselves are written in higher level categorial grammar formalism. Automated deduction for Lambek calculi is of interest in its own right but solution of the parsing problem for categorial logic allowing significant linguistic coverage demands automated deduction for more than just individual calculi. There is a need for methods applying to whole classes of systems i</context>
</contexts>
<marker>Hodas, 1992</marker>
<rawString>Hodas, J.: 1992, &apos;Specifying Filler-Gap Dependency Parsers in a Linear-Logic Programming Language&apos;, in Proceedings of the Joint International Conference and Symposium on Logic Programming, 622-636.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Joshua Hodas</author>
<author>Dale Miller</author>
</authors>
<title>Logic Programming in a Fragment of Intuitionistic Linear Logic&apos;, to appear in</title>
<date>1994</date>
<journal>Journal of Information and Computation.</journal>
<contexts>
<context position="1706" citStr="Hodas and Miller (1994)" startWordPosition="257" endWordPosition="260">of unfolding and labelling for proof net construction is considered. We aim to show here how such unfolding allows compilation into programs executable by a version of SLD resolution, implementing categorial deduction in dynamic linear clauses. The linearity resides in the use exactly once per word token of each of the clauses compiled from lexical categorisations. By dynamic, it is meant that clauses may be higher-order (they are hereditary Harrop Horn clauses) so that clausal resolution involves insertion in, as well as retraction from, the resolution database; see Miller et al. (1991), and Hodas and Miller (1994). It is shown how a range of calculi can be treated by dealing with the highest common factor of connectives as linear logical validity. The prosodic (i.e. sublinear) aspects of word order and hierarchical structure are encoded in labels, in effect the term structure of quantified linear logic. Compiling labels according to interpretations in groupoids provides a general method for calculi with various structural properties and also for multimodal hybrid formulations. Unification must be carried out according to the structural axioms but is limited to one-way matching, i.e. one term is always </context>
</contexts>
<marker>Hodas, Miller, 1994</marker>
<rawString>Hodas, Joshua and Dale Miller: 1994, &apos;Logic Programming in a Fragment of Intuitionistic Linear Logic&apos;, to appear in Journal of Information and Computation.</rawString>
</citation>
<citation valid="true">
<authors>
<author>E Konig</author>
</authors>
<title>Parsing as natural deduction&apos;,</title>
<date>1989</date>
<booktitle>in Proceedings of the Annual Meeting of the Association for Computational Linguistics,</booktitle>
<location>Vancouver.</location>
<contexts>
<context position="896" citStr="Konig (1989)" startWordPosition="128" endWordPosition="129">ction can be implemented in higher-order (linear) logic programming, thereby realising parsing as deduction for the associative and non-associative Lambek calculi. This provides a method of solution to the parsing problem of Lambek categorial grammar applicable to a variety of its extensions. The present work deals with the parsing problem for Lambek calculus and its extensions as developed in, for example, Moortgat (1988), van Benthern (1991), Moortgat and Morrill (1991), Moortgat and Oehrle (1993), Morrill (1994b) and Hepple (1995). Some previous approaches to parsing Lambek grammar such as Konig (1989), Hepple (1990) and Hendriks (1993) have concentrated on the possibilities of sequent proof normalisation. In Roorda (1991), Moortgat (1992), Hendriks (1993) and Oehrle (1994) a strategy of unfolding and labelling for proof net construction is considered. We aim to show here how such unfolding allows compilation into programs executable by a version of SLD resolution, implementing categorial deduction in dynamic linear clauses. The linearity resides in the use exactly once per word token of each of the clauses compiled from lexical categorisations. By dynamic, it is meant that clauses may be h</context>
<context position="7737" citStr="Konig, 1989" startWordPosition="1268" endWordPosition="1269"> scheme, or by two rule applications. This is easily solved by restricting id to atomic formulas. More problematic are the permutability of rule applications, the non-determinism of rules requiring splitting of configurations in L, and the need in NL to hypothesise configuration structure a priori (such hierarchical structure is not given by the input to the parsing problem). It seems that only the first of these difficulties can be overcome from a Gentzen sequent perspective. The situation regarding equivalence and rule ordering is solved, at least for L—{.L}, by sequent proof normalisation (Konig, 1989; Hepple, 1990; Hendriks, 1993): (5) FI,A,F2 F= A( A(r, A A B I A A\B ) C A( B) C ,F) c A( B1) CA, r FB1 \L* r A\B r, A F /R B IA /L [F, A] = B /R F BIA F A A B •R F, A = A•B F, A B /R F BIA /L A A id* A ,F2 B P. It is also derivable in L; indeed all NL deriva- This involves firstly ordering right rules before tions are converted to L derivations by simply left rules reading from endsequent to axiom leaves 134 (so left rules only apply to sequents with atomic succedents; this effects uniform proof; see Miller et al., 1991), and secondly further demanding successive unfolding of the same config</context>
</contexts>
<marker>Konig, 1989</marker>
<rawString>Konig, E.: 1989, &apos;Parsing as natural deduction&apos;, in Proceedings of the Annual Meeting of the Association for Computational Linguistics, Vancouver.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Lambek</author>
</authors>
<title>The mathematics of sentence structure&apos;,</title>
<date>1958</date>
<journal>American Mathematical Monthly</journal>
<booktitle>Benthem (eds.): 1988, Categorial Grammar, Linguistic &amp; Literary Studies in Eastern Europe Volume 25,</booktitle>
<volume>65</volume>
<pages>154--170</pages>
<editor>also in Buszkowski, W., W. Marciszewski, and J. van</editor>
<location>John. Benjamins, Amsterdam,</location>
<contexts>
<context position="5086" citStr="Lambek (1958)" startWordPosition="802" endWordPosition="803">emantics is unproblematic. For the non-associative Lambek calculus NL of Lambek (1961) we assume types freely generated from a set of primitive types by binary (infix) operators \, / and •. A sequent comprises a succedent type A and an antecedent configuration I&apos; which is a binary bracketed list of one or more types; we write F A. The notation r(A) here refers to a configuration F with a distinguished subconfiguration A. a. A A id F A (A) =B (1) Cut A(F) B b. F=A z(B)=C [A, r] B \L \R A({r,A\BD C F A\B r A B) =4&apos;.0 A([B IA, 11) C d. F([A, C •L F(A.B) C For the associative Lambek calculus L of Lambek (1958) the types are the same. A sequent comprises a succedent type A and an antecedent configuration I&apos; which is a list of one or more types; again we write I&apos; A. a. A A id F=A A(A) B Cut (2) A(F) B b. F=A A (B) C A, r B \L \R A(F, A\B) C A\B C. F=A A (B) =C A (B/A, r) c d. F(A, B) C F A A B •L F(A.B) C F, A Lambek showed Cut-elimination for both calculi, i.e. every theorem has a Cut-free proof. Of the remaining rules each instance of premises has exactly one connective occurrence less than the corresponding conclusion so Cut-elimination shows decidability through finite space Cut-free sequent proo</context>
</contexts>
<marker>Lambek, 1958</marker>
<rawString>Lambek, J.: 1958, &apos;The mathematics of sentence structure&apos;, American Mathematical Monthly 65, 154-170, also in Buszkowski, W., W. Marciszewski, and J. van Benthem (eds.): 1988, Categorial Grammar, Linguistic &amp; Literary Studies in Eastern Europe Volume 25, John. Benjamins, Amsterdam, 153-172.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Lambek</author>
</authors>
<title>On the calculus of syntactic types&apos;,</title>
<date>1961</date>
<booktitle>Structure of language and its mathematical aspects, Proceedings of the Symposia in Applied Mathematics XII,</booktitle>
<pages>166--178</pages>
<editor>in R. Jakobson (ed.)</editor>
<publisher>American Mathematical Society,</publisher>
<contexts>
<context position="4559" citStr="Lambek (1961)" startWordPosition="693" endWordPosition="694">calculi for the binary connectives. The parsing problem is usually construed as the recovery of structural descriptions assigned to strings by a grammar. In practice the interest is in computing semantic forms implicit in the structural descriptions, which are themselves usually implicit in the history of a derivation recognising well-formedness of a string. This is true in particular of compositional categorial architec133 tures and we shall focus on algorithms for showing well-formedness. The further step to computing semantics is unproblematic. For the non-associative Lambek calculus NL of Lambek (1961) we assume types freely generated from a set of primitive types by binary (infix) operators \, / and •. A sequent comprises a succedent type A and an antecedent configuration I&apos; which is a binary bracketed list of one or more types; we write F A. The notation r(A) here refers to a configuration F with a distinguished subconfiguration A. a. A A id F A (A) =B (1) Cut A(F) B b. F=A z(B)=C [A, r] B \L \R A({r,A\BD C F A\B r A B) =4&apos;.0 A([B IA, 11) C d. F([A, C •L F(A.B) C For the associative Lambek calculus L of Lambek (1958) the types are the same. A sequent comprises a succedent type A and an an</context>
</contexts>
<marker>Lambek, 1961</marker>
<rawString>Lambek, J.: 1961, &apos;On the calculus of syntactic types&apos;, in R. Jakobson (ed.) Structure of language and its mathematical aspects, Proceedings of the Symposia in Applied Mathematics XII, American Mathematical Society, 166-178.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Lambek</author>
</authors>
<title>Categorial and Categorical Grammars&apos;,</title>
<date>1988</date>
<booktitle>Categorial Grammars and Natural Language Structures, Studies in Linguistics and Philosophy Volume 32,</booktitle>
<pages>297--317</pages>
<editor>in Richard T. Oehrle, Emmon Bach, and Deidre Wheeler (eds.)</editor>
<location>Dordrecht,</location>
<contexts>
<context position="12051" citStr="Lambek, 1988" startWordPosition="2051" endWordPosition="2052">order clauses also becomes sensitised to the employment of antecedent contexts: DT r, B A CI . • • 0 Cm (14) We shall motivate compilation into linear clauses directly from simple algebraic models for the calculi. In the case of L we have first interpretation in semigroups (L,+) (i.e. sets L closed under associative binary operations +; intuitively: strings under concatenation). Relative to a model each type A has an interpretation as a subset D(A) of L. Given that primitive types are interpreted as some such subsets, complex types receive their denotations by residuation as follows (cf. e.g. Lambek, 1988): D(A.B) = Isi-Fs2181 E D(A) A 82 E D(B)} (15) D(A\B) = {SIV&apos; E D(A),s&apos;+s E D(B)} D(BIA) = {s1Vs&apos; E D(A),s+s&apos; E D(B)) For the non-associative calculus we drop the condition of associativity and interpret in arbitrary CI. A ... A &amp;quot; RES r, A +--- Bi A ... A Bn A A CI A ... A Cm r, A B1 A... A B B1A... A BA DT F ... Bn Ci .. 0 Cm 135 groupoids (intuitively: trees under adjunction&apos;). Categorial type assignment statements comprise a term a and a type A; we write a: A. Given a set of lexical assignments, a phrasal assignment is projected if and only if in every model satisfying the lexical assignmen</context>
</contexts>
<marker>Lambek, 1988</marker>
<rawString>Lambek, J.: 1988, &apos;Categorial and Categorical Grammars&apos;, in Richard T. Oehrle, Emmon Bach, and Deidre Wheeler (eds.) Categorial Grammars and Natural Language Structures, Studies in Linguistics and Philosophy Volume 32, D. Reidel, Dordrecht, 297-317.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D Miller</author>
<author>G Nadathur</author>
<author>F Pfenning</author>
<author>A Scedrov</author>
</authors>
<title>Uniform Proofs as a Foundation for Logic Programming&apos;,</title>
<date>1991</date>
<journal>Annals of Pure and Applied Logic</journal>
<volume>51</volume>
<pages>125--157</pages>
<contexts>
<context position="1677" citStr="Miller et al. (1991)" startWordPosition="252" endWordPosition="255"> Oehrle (1994) a strategy of unfolding and labelling for proof net construction is considered. We aim to show here how such unfolding allows compilation into programs executable by a version of SLD resolution, implementing categorial deduction in dynamic linear clauses. The linearity resides in the use exactly once per word token of each of the clauses compiled from lexical categorisations. By dynamic, it is meant that clauses may be higher-order (they are hereditary Harrop Horn clauses) so that clausal resolution involves insertion in, as well as retraction from, the resolution database; see Miller et al. (1991), and Hodas and Miller (1994). It is shown how a range of calculi can be treated by dealing with the highest common factor of connectives as linear logical validity. The prosodic (i.e. sublinear) aspects of word order and hierarchical structure are encoded in labels, in effect the term structure of quantified linear logic. Compiling labels according to interpretations in groupoids provides a general method for calculi with various structural properties and also for multimodal hybrid formulations. Unification must be carried out according to the structural axioms but is limited to one-way match</context>
<context position="8265" citStr="Miller et al., 1991" startWordPosition="1386" endWordPosition="1389">nd rule ordering is solved, at least for L—{.L}, by sequent proof normalisation (Konig, 1989; Hepple, 1990; Hendriks, 1993): (5) FI,A,F2 F= A( A(r, A A B I A A\B ) C A( B) C ,F) c A( B1) CA, r FB1 \L* r A\B r, A F /R B IA /L [F, A] = B /R F BIA F A A B •R F, A = A•B F, A B /R F BIA /L A A id* A ,F2 B P. It is also derivable in L; indeed all NL deriva- This involves firstly ordering right rules before tions are converted to L derivations by simply left rules reading from endsequent to axiom leaves 134 (so left rules only apply to sequents with atomic succedents; this effects uniform proof; see Miller et al., 1991), and secondly further demanding successive unfolding of the same configuration type (&amp;quot;focusing&amp;quot;). In the *-ed rules the succedent is atomic. A necessary condition for success is that an antecedent type is only selected by P* if it yields the succedent atom as its eventual range. Let us refer to (5) as L . L is free of spurious ambiguity, and FL F A iff 1-0 A- . The focusing strategy breaks down for .L: (VP/PP)/N, N.PP = VP requires switching between configuration types. It happens that left occurrences of product are not motivated in grammar, but more critically sequent proof normalisation le</context>
</contexts>
<marker>Miller, Nadathur, Pfenning, Scedrov, 1991</marker>
<rawString>Miller, D., G. Nadathur, F. Pfenning, and A. Scedrov: 1991, &apos;Uniform Proofs as a Foundation for Logic Programming&apos;, Annals of Pure and Applied Logic 51, 125-157.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Michael Moortgat</author>
</authors>
<title>Categorial Investigations: Logical and Linguistic Aspects of the Lambek Calculus,</title>
<date>1988</date>
<location>Foris, Dordrecht.</location>
<contexts>
<context position="710" citStr="Moortgat (1988)" startWordPosition="100" endWordPosition="101">cia Artificial Departament de Llenguatges i Sistemes Informatics Universitat Politecnica de Catalunya Pau Gargallo, 5 08028 Barcelona morrill@lsi.upc.es Abstract We show how categorial deduction can be implemented in higher-order (linear) logic programming, thereby realising parsing as deduction for the associative and non-associative Lambek calculi. This provides a method of solution to the parsing problem of Lambek categorial grammar applicable to a variety of its extensions. The present work deals with the parsing problem for Lambek calculus and its extensions as developed in, for example, Moortgat (1988), van Benthern (1991), Moortgat and Morrill (1991), Moortgat and Oehrle (1993), Morrill (1994b) and Hepple (1995). Some previous approaches to parsing Lambek grammar such as Konig (1989), Hepple (1990) and Hendriks (1993) have concentrated on the possibilities of sequent proof normalisation. In Roorda (1991), Moortgat (1992), Hendriks (1993) and Oehrle (1994) a strategy of unfolding and labelling for proof net construction is considered. We aim to show here how such unfolding allows compilation into programs executable by a version of SLD resolution, implementing categorial deduction in dynami</context>
</contexts>
<marker>Moortgat, 1988</marker>
<rawString>Moortgat, Michael: 1988, Categorial Investigations: Logical and Linguistic Aspects of the Lambek Calculus, Foris, Dordrecht.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Michael Moortgat</author>
</authors>
<title>Labelled Deductive Systems for categorial theorem proving&apos;, OTS Working Paper OTS-WP-CL-92-003, Rijksuniversiteit Utrecht, also</title>
<date>1992</date>
<booktitle>in Proceedings of the Eighth Amsterdam Colloquium, Institute for Language, Logic and Information, Universiteit</booktitle>
<location>van Amsterdam.</location>
<contexts>
<context position="1036" citStr="Moortgat (1992)" startWordPosition="149" endWordPosition="150">ssociative Lambek calculi. This provides a method of solution to the parsing problem of Lambek categorial grammar applicable to a variety of its extensions. The present work deals with the parsing problem for Lambek calculus and its extensions as developed in, for example, Moortgat (1988), van Benthern (1991), Moortgat and Morrill (1991), Moortgat and Oehrle (1993), Morrill (1994b) and Hepple (1995). Some previous approaches to parsing Lambek grammar such as Konig (1989), Hepple (1990) and Hendriks (1993) have concentrated on the possibilities of sequent proof normalisation. In Roorda (1991), Moortgat (1992), Hendriks (1993) and Oehrle (1994) a strategy of unfolding and labelling for proof net construction is considered. We aim to show here how such unfolding allows compilation into programs executable by a version of SLD resolution, implementing categorial deduction in dynamic linear clauses. The linearity resides in the use exactly once per word token of each of the clauses compiled from lexical categorisations. By dynamic, it is meant that clauses may be higher-order (they are hereditary Harrop Horn clauses) so that clausal resolution involves insertion in, as well as retraction from, the reso</context>
<context position="13333" citStr="Moortgat, 1992" startWordPosition="2293" endWordPosition="2294">s a translation given by I • I into a linear sequent of type assignments which can be safely read as predications. For L we have the following (NL preserves input antecedent configuration in output succedent term structure): lBo (16), • • , Al = ko: B , • • • • kn: B ko+ +kr,: ACategorial type assignment statements are translated into linear logic according to the interpretation of types. The polar translation functions are identity functions on atomic assignments; on complex category predicates they are defined mutually as follows (for related unfolding, but for proof nets, see Roorda, 1991; Moortgat, 1992; Hendriks, 1993; and Oehrle, 1994); 15 indicates the polarity complementary to p: (17) A\BP 7+a: BP 0— a: A9 a new variable/ y: B/AP constant as p +1- The unfolding transformations have the same general form for the positive (configuration/database) and negative (succedent/agenda) occurrences; the polarity is used to indicate whether new symbols introduced for quantified variables in the interpretation clauses are metavariables (in italics) or Skolem constants (in boldface); we shall see examples shortly. The program clauses and agenda are read directly off the unfoldings, with the only manip</context>
</contexts>
<marker>Moortgat, 1992</marker>
<rawString>Moortgat, Michael: 1992, &apos;Labelled Deductive Systems for categorial theorem proving&apos;, OTS Working Paper OTS-WP-CL-92-003, Rijksuniversiteit Utrecht, also in Proceedings of the Eighth Amsterdam Colloquium, Institute for Language, Logic and Information, Universiteit van Amsterdam.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Michael Moortgat</author>
<author>Glyn Morrill</author>
</authors>
<title>Heads and Phra.ses: Type Calculus for Dependency and Constituent Structure&apos;, to appear in</title>
<date>1991</date>
<journal>Journal of Language, Logic, and Information.</journal>
<contexts>
<context position="760" citStr="Moortgat and Morrill (1991)" startWordPosition="105" endWordPosition="108">ges i Sistemes Informatics Universitat Politecnica de Catalunya Pau Gargallo, 5 08028 Barcelona morrill@lsi.upc.es Abstract We show how categorial deduction can be implemented in higher-order (linear) logic programming, thereby realising parsing as deduction for the associative and non-associative Lambek calculi. This provides a method of solution to the parsing problem of Lambek categorial grammar applicable to a variety of its extensions. The present work deals with the parsing problem for Lambek calculus and its extensions as developed in, for example, Moortgat (1988), van Benthern (1991), Moortgat and Morrill (1991), Moortgat and Oehrle (1993), Morrill (1994b) and Hepple (1995). Some previous approaches to parsing Lambek grammar such as Konig (1989), Hepple (1990) and Hendriks (1993) have concentrated on the possibilities of sequent proof normalisation. In Roorda (1991), Moortgat (1992), Hendriks (1993) and Oehrle (1994) a strategy of unfolding and labelling for proof net construction is considered. We aim to show here how such unfolding allows compilation into programs executable by a version of SLD resolution, implementing categorial deduction in dynamic linear clauses. The linearity resides in the use</context>
<context position="24465" citStr="Moortgat and Morrill, 1991" startWordPosition="4348" endWordPosition="4352">in Figure 3. (41) : S 0- (b+k-i-4: S 0- (c+k-/-4: So- c-1-1: N)) a-2-ki: PP The derivation is given in Figure 4. Note how the term unification computing the hierarchical structure can be carried out one-way in the reverse order to the forward segment matchings: d = b-1-(m+a) = c-F(m+a) = r+(m-Fa) = (42) rd-(m+f) In the case of NL-invalidity the term unification would fail. We mention finally multimodal generalisations. In multimodal calculi families of connectives {ii, \i,•i}ie { 1,...,0 are each defined by residuation with respect to their adjunction in a &amp;quot;polygroupoid&amp;quot; (L, {+i}iE11,...,n}) (Moortgat and Morrill, 1991): D(AcB) = E D(A) A 82 E D(B)) (43) D(A\,B) = IsiVs&apos;E D(A), -I-is E D(B)) D(B I iA) = E D(A), E D(B)) Multimodal groupoid compilation for implications is immediate: BP o- A&apos;i5 a new variable/ : B I,AP constant as p +1- This is entirely general. Any multimodal calculus can be implemented this way provided we have a (one-way) unification algorithm specialised according to the structural communication axioms. For example Morrill (1993) deals with multimodality for discontinuity which involves varying internal structural properties (associativity vs. non-associativity) as well as &amp;quot;split/wrap&amp;quot; inte</context>
</contexts>
<marker>Moortgat, Morrill, 1991</marker>
<rawString>Moortgat, Michael and Glyn Morrill: 1991, &apos;Heads and Phra.ses: Type Calculus for Dependency and Constituent Structure&apos;, to appear in Journal of Language, Logic, and Information.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Michael Moortgat</author>
<author>Dick Oehrle</author>
</authors>
<title>Adjacency, dependency and order&apos;,</title>
<date>1994</date>
<booktitle>in Proceedings of the Ninth Amsterdam Colloquium,</booktitle>
<pages>447--466</pages>
<marker>Moortgat, Oehrle, 1994</marker>
<rawString>Moortgat, Michael and Dick Oehrle: 1994, &apos;Adjacency, dependency and order&apos;, in Proceedings of the Ninth Amsterdam Colloquium, 447-466.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Glyn Morrill</author>
</authors>
<title>Discontinuity and PiedPiping in Categorial Grammar, Report de Recerca LSI-93-18-R, Departament de Llenguatges i Sistemes Informatics, Universitat Politecnica de Catalunya, to appear in Linguistics and Philosophy.</title>
<date>1993</date>
<contexts>
<context position="24901" citStr="Morrill (1993)" startWordPosition="4427" endWordPosition="4428">lies of connectives {ii, \i,•i}ie { 1,...,0 are each defined by residuation with respect to their adjunction in a &amp;quot;polygroupoid&amp;quot; (L, {+i}iE11,...,n}) (Moortgat and Morrill, 1991): D(AcB) = E D(A) A 82 E D(B)) (43) D(A\,B) = IsiVs&apos;E D(A), -I-is E D(B)) D(B I iA) = E D(A), E D(B)) Multimodal groupoid compilation for implications is immediate: BP o- A&apos;i5 a new variable/ : B I,AP constant as p +1- This is entirely general. Any multimodal calculus can be implemented this way provided we have a (one-way) unification algorithm specialised according to the structural communication axioms. For example Morrill (1993) deals with multimodality for discontinuity which involves varying internal structural properties (associativity vs. non-associativity) as well as &amp;quot;split/wrap&amp;quot; interaction between modes. This is treated computationally in the current manner in Morrill (1994a) which also considers head-oriented discontinuity and unary operators projecting bracketed string structure. In these cases also simultaneous compilation including binary relational labelling can provide additional advantages. Labelled unfolding of categorial formulas has been invoked in the references cited as a way of checking well-forme</context>
</contexts>
<marker>Morrill, 1993</marker>
<rawString>Morrill, Glyn: 1993, Discontinuity and PiedPiping in Categorial Grammar, Report de Recerca LSI-93-18-R, Departament de Llenguatges i Sistemes Informatics, Universitat Politecnica de Catalunya, to appear in Linguistics and Philosophy.</rawString>
</citation>
<citation valid="false">
<authors>
<author>Glyn Morrill</author>
</authors>
<title>1994a, &apos;Higher-Order Linear Logic Programming of Categorial Deduction&apos;,</title>
<booktitle>Departament de Llenguatges i Sistemes Informatics, Universitat Politecnica de Catalunya</booktitle>
<tech>Report de Recerca LSI-94-42-R,</tech>
<marker>Morrill, </marker>
<rawString>Morrill, Glyn: 1994a, &apos;Higher-Order Linear Logic Programming of Categorial Deduction&apos;, Report de Recerca LSI-94-42-R, Departament de Llenguatges i Sistemes Informatics, Universitat Politecnica de Catalunya</rawString>
</citation>
<citation valid="false">
<authors>
<author>Glyn Morrill</author>
</authors>
<title>1994b, Type Logical Grammar: Categorial Logic of Signs,</title>
<publisher>Kluwer Academic Publishers,</publisher>
<location>Dordrecht.</location>
<marker>Morrill, </marker>
<rawString>Morrill, Glyn: 1994b, Type Logical Grammar: Categorial Logic of Signs, Kluwer Academic Publishers, Dordrecht.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Dick Oehrle</author>
</authors>
<title>Term labelled categorial type systems&apos;,</title>
<date>1994</date>
<note>to appear in Linguistics and Philosophy.</note>
<contexts>
<context position="1071" citStr="Oehrle (1994)" startWordPosition="155" endWordPosition="156">des a method of solution to the parsing problem of Lambek categorial grammar applicable to a variety of its extensions. The present work deals with the parsing problem for Lambek calculus and its extensions as developed in, for example, Moortgat (1988), van Benthern (1991), Moortgat and Morrill (1991), Moortgat and Oehrle (1993), Morrill (1994b) and Hepple (1995). Some previous approaches to parsing Lambek grammar such as Konig (1989), Hepple (1990) and Hendriks (1993) have concentrated on the possibilities of sequent proof normalisation. In Roorda (1991), Moortgat (1992), Hendriks (1993) and Oehrle (1994) a strategy of unfolding and labelling for proof net construction is considered. We aim to show here how such unfolding allows compilation into programs executable by a version of SLD resolution, implementing categorial deduction in dynamic linear clauses. The linearity resides in the use exactly once per word token of each of the clauses compiled from lexical categorisations. By dynamic, it is meant that clauses may be higher-order (they are hereditary Harrop Horn clauses) so that clausal resolution involves insertion in, as well as retraction from, the resolution database; see Miller et al. </context>
<context position="13368" citStr="Oehrle, 1994" startWordPosition="2298" endWordPosition="2299">a linear sequent of type assignments which can be safely read as predications. For L we have the following (NL preserves input antecedent configuration in output succedent term structure): lBo (16), • • , Al = ko: B , • • • • kn: B ko+ +kr,: ACategorial type assignment statements are translated into linear logic according to the interpretation of types. The polar translation functions are identity functions on atomic assignments; on complex category predicates they are defined mutually as follows (for related unfolding, but for proof nets, see Roorda, 1991; Moortgat, 1992; Hendriks, 1993; and Oehrle, 1994); 15 indicates the polarity complementary to p: (17) A\BP 7+a: BP 0— a: A9 a new variable/ y: B/AP constant as p +1- The unfolding transformations have the same general form for the positive (configuration/database) and negative (succedent/agenda) occurrences; the polarity is used to indicate whether new symbols introduced for quantified variables in the interpretation clauses are metavariables (in italics) or Skolem constants (in boldface); we shall see examples shortly. The program clauses and agenda are read directly off the unfoldings, with the only manipulation being a flattening of posit</context>
</contexts>
<marker>Oehrle, 1994</marker>
<rawString>Oehrle, Dick: 1994, &apos;Term labelled categorial type systems&apos;, to appear in Linguistics and Philosophy.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Pareschi</author>
</authors>
<title>Type-driven Natural Language Analysis,</title>
<date>1989</date>
<tech>Ph.D. thesis,</tech>
<institution>University of Edinburgh.</institution>
<contexts>
<context position="2856" citStr="Pareschi (1989)" startWordPosition="436" endWordPosition="437">ioms but is limited to one-way matching, i.e. one term is always ground. Furthermore, for the particular case of associative Lambek calculus an additional perspective of binary relational interpretation allows an especially efficient coding in which the span of expressions is represented in such a way as to avoid the computation of unifiers under associativity, and this can also be exploited for non-associative calculus. Higher-order linear logic programming has already been applied to natural language processing in, for example, Hodas (1992) and Hodas and Miller (1994), in work deriving from Pareschi (1989) and Pareschi and Miller (1990). What we show here is that such implementation can be realised systematically, indeed by a mechanical compilation, while grammars themselves are written in higher level categorial grammar formalism. Automated deduction for Lambek calculi is of interest in its own right but solution of the parsing problem for categorial logic allowing significant linguistic coverage demands automated deduction for more than just individual calculi. There is a need for methods applying to whole classes of systems in ways which are principled and powerful enough to support the furt</context>
</contexts>
<marker>Pareschi, 1989</marker>
<rawString>Pareschi, R.: 1989, Type-driven Natural Language Analysis, Ph.D. thesis, University of Edinburgh.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Pareschi</author>
<author>D Miller</author>
</authors>
<title>Extending Definite Clause Grammars with Scoping Constructs&apos;,</title>
<date>1990</date>
<booktitle>1990 International Conference in Logic Programming,</booktitle>
<pages>373--389</pages>
<editor>in D.H.D. Warren and P. Szeredi (eds.)</editor>
<publisher>MIT Press,</publisher>
<contexts>
<context position="2887" citStr="Pareschi and Miller (1990)" startWordPosition="439" endWordPosition="442">to one-way matching, i.e. one term is always ground. Furthermore, for the particular case of associative Lambek calculus an additional perspective of binary relational interpretation allows an especially efficient coding in which the span of expressions is represented in such a way as to avoid the computation of unifiers under associativity, and this can also be exploited for non-associative calculus. Higher-order linear logic programming has already been applied to natural language processing in, for example, Hodas (1992) and Hodas and Miller (1994), in work deriving from Pareschi (1989) and Pareschi and Miller (1990). What we show here is that such implementation can be realised systematically, indeed by a mechanical compilation, while grammars themselves are written in higher level categorial grammar formalism. Automated deduction for Lambek calculi is of interest in its own right but solution of the parsing problem for categorial logic allowing significant linguistic coverage demands automated deduction for more than just individual calculi. There is a need for methods applying to whole classes of systems in ways which are principled and powerful enough to support the further generalisations that gramma</context>
</contexts>
<marker>Pareschi, Miller, 1990</marker>
<rawString>Pareschi, R. and D, Miller: 1990, &apos;Extending Definite Clause Grammars with Scoping Constructs&apos;, in D.H.D. Warren and P. Szeredi (eds.) 1990 International Conference in Logic Programming, MIT Press, 373-389.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Dirk Roorda</author>
</authors>
<title>Resource Logics: prooftheoretical investigations,</title>
<date>1991</date>
<institution>Universiteit van Amsterdam.</institution>
<note>Ph.D. dissertation,</note>
<contexts>
<context position="1019" citStr="Roorda (1991)" startWordPosition="147" endWordPosition="148">ative and non-associative Lambek calculi. This provides a method of solution to the parsing problem of Lambek categorial grammar applicable to a variety of its extensions. The present work deals with the parsing problem for Lambek calculus and its extensions as developed in, for example, Moortgat (1988), van Benthern (1991), Moortgat and Morrill (1991), Moortgat and Oehrle (1993), Morrill (1994b) and Hepple (1995). Some previous approaches to parsing Lambek grammar such as Konig (1989), Hepple (1990) and Hendriks (1993) have concentrated on the possibilities of sequent proof normalisation. In Roorda (1991), Moortgat (1992), Hendriks (1993) and Oehrle (1994) a strategy of unfolding and labelling for proof net construction is considered. We aim to show here how such unfolding allows compilation into programs executable by a version of SLD resolution, implementing categorial deduction in dynamic linear clauses. The linearity resides in the use exactly once per word token of each of the clauses compiled from lexical categorisations. By dynamic, it is meant that clauses may be higher-order (they are hereditary Harrop Horn clauses) so that clausal resolution involves insertion in, as well as retracti</context>
<context position="13317" citStr="Roorda, 1991" startWordPosition="2291" endWordPosition="2292">ial sequent has a translation given by I • I into a linear sequent of type assignments which can be safely read as predications. For L we have the following (NL preserves input antecedent configuration in output succedent term structure): lBo (16), • • , Al = ko: B , • • • • kn: B ko+ +kr,: ACategorial type assignment statements are translated into linear logic according to the interpretation of types. The polar translation functions are identity functions on atomic assignments; on complex category predicates they are defined mutually as follows (for related unfolding, but for proof nets, see Roorda, 1991; Moortgat, 1992; Hendriks, 1993; and Oehrle, 1994); 15 indicates the polarity complementary to p: (17) A\BP 7+a: BP 0— a: A9 a new variable/ y: B/AP constant as p +1- The unfolding transformations have the same general form for the positive (configuration/database) and negative (succedent/agenda) occurrences; the polarity is used to indicate whether new symbols introduced for quantified variables in the interpretation clauses are metavariables (in italics) or Skolem constants (in boldface); we shall see examples shortly. The program clauses and agenda are read directly off the unfoldings, wit</context>
</contexts>
<marker>Roorda, 1991</marker>
<rawString>Roorda, Dirk: 1991, Resource Logics: prooftheoretical investigations, Ph.D. dissertation, Universiteit van Amsterdam.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>