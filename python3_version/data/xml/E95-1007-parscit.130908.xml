<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<title confidence="0.9981995">
Some Remarks on the Decidability of the Generation Problem in
LFG- and PATR-Style Unification Grammars
</title>
<author confidence="0.998479">
Jürgen Wedekind
</author>
<affiliation confidence="0.9973475">
Institute for Natural Language Processing
University of Stuttgart
</affiliation>
<address confidence="0.7746665">
Azenbergstr. 12
D-70174 Stuttgart, FRG
</address>
<email confidence="0.959828">
juergen@ims.uni-stuttgart.de
</email>
<sectionHeader confidence="0.997215" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999959058823529">
In this paper, we prove the decidability of
the generation problem for those unifica-
tion grammars which are based on context-
free phrase structure rule skeletons, like
e.g. LFG and PATR-II. The result shows
a perhaps unexpected asymmetry, since it
is valid also for those unification grammars
whose parsing problem is undecidable, e.g.
grammars which do not satisfy the off-line
parsability constraint. The general proof is
achieved by showing that the space of the
derivations which have to be considered in
order to decide the problem for a given in-
put is always restricted to derivations whose
length is limited by some fixed upper bound
which is determined relative to the &amp;quot;size&amp;quot; of
the input.
</bodyText>
<sectionHeader confidence="0.999471" genericHeader="keywords">
1 Introduction
</sectionHeader>
<bodyText confidence="0.9998739375">
Unification Grammars with a context-free skeleton,
like Lexical Functional Grammar (LFG) and PATR-
II (cf. e.g. Kaplan and Bresnan 1982, Shieber et
al. 1983) assign to a sentence not only a constituent
structure (c-structure), but also an additional lin-
guistic entity. In the rather restricted grammars of
the early stage this entity is identified with a special
graph structure, commonly called feature structure.
Since a string is regarded as well-formed only if a
(well-formed) feature structure is assigned to it by
the grammar, two inverse decidability problems arise
which had to be solved in order to know whether we
can formulate terminating parsing and generation al-
gorithms. If we retain the terminology of the early
stages then an adequate parsing algorithm requires
that we can decide for a given grammar and a given
string whether there exists a feature structure as-
signed to it by the grammar (parsing problem) and
an adequate generation algorithm requires that we
can decide for a given grammar and a given feature
structure whether there exists a sentence to which
this structure is assigned by the grammar (genera-
tion problem).
While we already know for a long time that the
parsing problem is undecidable (cf. Kaplan and Bres-
nan 1982, Johnson 1988), we want to show in this pa-
per that the generation problem is decidable even for
unrestricted (not off-line parsable) unification gram-
mars. For the proof we first introduce in section 2 the
type of grammar we want to consider. In section 3
we then define the generation problem and show its
decidability in two steps.
</bodyText>
<sectionHeader confidence="0.997127" genericHeader="introduction">
2 Preliminaries
</sectionHeader>
<bodyText confidence="0.9984364">
The unification grammars we want to consider con-
sist of rules with a context-free skeleton and a set of
annotations associated with the constituents men-
tioned in the rules. Typical examples taken from
LFG and PATR-II are given in figure 1. For the for-
</bodyText>
<equation confidence="0.992351">
S-+ NP VP S NP VP
(t suBJ) (VP AGR) = (NP AGR)
NP -4 John NP Uther
(t PRED) = JOHN (NP AGR NUM) = SG
(NP AGR PER) = 3RD
</equation>
<figureCaption confidence="0.677143">
Figure 1
</figureCaption>
<bodyText confidence="0.954100363636364">
Examples of rules in LFG (left) and PATR-II
format (right).
mal definition of those grammars we reconstruct the
annotations as formulas of a quantifier-free sublan-
guage of a classical first-order language with equality
whose (nonlogical) symbols are given by a finite set of
unary partial function symbols and a finite set of con-
stants. For the translation of LFG and PATR-II an-
notations we regard the attributes (in figure 1: SUBJ,
PRED, AGR, NUM, PER) as unary partial function
symbols and the atomic values (in figure 1: JOHN,
</bodyText>
<page confidence="0.99869">
45
</page>
<bodyText confidence="0.999725111111111">
SG, 3RD) as individual constants. Furthermore, we
assume for a context-free rule of the form A w
(w E (VN U VT)*) that the variable xo is associated
with A and that for each occurrence wi in w there
is a variable xi which is associated with wi. For the
formal reconstruction of LFG&apos;s we assume that each
occurrence of j. in the annotation of wi corresponds
to an occurrence of xi and that each occurrence of
t corresponds to an occurrence of xo. For grammars
in PATR-II format we suppose that occurrences of
categories in the annotations correspond to the asso-
ciated variables.
Before we give the definition of the grammars we
want to investigate, we introduce the following nota-
tion. In the following we use S[xl, xn] to indicate
that the variables occurring in the set of formulas S
are included in {xi, .., xril and S(xi, x.) if the set
of variables occurring in S is exactly {x1, xn}.
</bodyText>
<listItem confidence="0.975236333333333">
1. DEFINITION. A unification grammar is a tuple
(VN, VT, S, F,, V, V, R), consisting of a finite nonter-
minal vocabulary VN, a finite terminal vocabulary
VT, a start symbol S E VN and a feature-description
language L determined by a finite set of unary par-
tial function symbols F1, a finite set of atomic values
</listItem>
<equation confidence="0.7105835">
V and a denumerable set of variables1
V = Ix, I a E lN*) with x, x„, for o-
</equation>
<bodyText confidence="0.9984134">
All vocabularies are pairwise disjoint. R is a finite
set of rules of the form r= ((A, w), Sr[xo, ••, xiw
(xi E V), with (A, w) E VN X (VN U VT)* (a context-
free phrase structure rule) and Sr [XO, x1.1] a finite
set of (quantifier-free) literals of L.&apos;
According to our definition the LFG rules in figure 1
are now expressed as depicted in (la) and the PATR-
II rules as given in (lb). Note that the structure of
the terms is now &amp;quot;mirror imaged&amp;quot;, since we assume
the attributes to be unary partial function symbols.
</bodyText>
<equation confidence="0.93668">
(1) (a) (S NP VP, {SUBJ X0 Pe. Xl, X0 &apos;;&apos;,1 X2})
(NP -4 John, {PRED X0 JOHN})
(b) (S NP VP, {AOR X2^..•,-* AGR Xi))
NUM AGR xo SG, 1 \
(NP Uther,
{PER AGR XO 3RD f
</equation>
<bodyText confidence="0.992831333333334">
For the definition of the sentences derivable by a
unification grammar we have to specify first what
derivations are.
</bodyText>
<listItem confidence="0.903600333333333">
2. DEFINITION. A sequence of pairs 7T0...7rn with
7ro = (B0, 0) (B E VN) is called derivation of length
n if for each Tit = (13 [—Awl() , S) (0 &lt; 1&lt; n) there is
</listItem>
<equation confidence="0.6006515">
a ruler = (A —&gt; , Sr) such that
= (B[..A[w121.1,••,WItcl.m1P-103Sr)•
</equation>
<bodyText confidence="0.99504825">
In the definition we assume that the order of the
arcs of a tree is encoded by numbering the arcs and
that each node is identified with the sequence of in-
tegers numbering the arcs along the path from the
</bodyText>
<footnote confidence="0.59172575">
&apos;The syntax and semantics of feature-description lan-
guages is given in the appendix.
2A literal is an atomic formula or the negation of an
atomic formula.
</footnote>
<bodyText confidence="0.998681375">
root (0) to that node. In our bracket notation we
add to a constituent its root node as the right and
its root node label as the left index. In order to be
able to refer to the c-structure derivation and to the
sequence of feature descriptions and to have access
to the nodes which are substituted in each step of a
derivation, we define for a derivation 7r three other
sequences.
</bodyText>
<listItem confidence="0.9954895">
3. DEFINITION. Let ir be a derivation of length
n. We then define two sequences oi and -y for
each i = 0, n with -xi = (Tc, S) by w, =T and
-yi = S and a sequence tv for each i = 1,..,n with
</listItem>
<equation confidence="0.814024333333333">
w_,d= BL•A[WA1.1) 7 WAk.M11-,••]0
2-1 = B[.•Aii•o and T,
by tvi =
</equation>
<bodyText confidence="0.997190571428571">
Let S be a set of literals and 0 a unary partial map-
ping over the set of terms. Then the expression SP)
denotes the set of expressions obtained from S by
simultaneously replacing each occurrence of a term
T in each formula in S by 0(r). The feature descrip-
tion derived by 7r is then defined by means of the
following operation.
</bodyText>
<listItem confidence="0.968138">
4. DEFINITION. If 7r is a derivation of length n then
the feature description derived by 7r from h to k
(0 &lt; h &lt; k &lt; n) is given by
</listItem>
<equation confidence="0.9610675">
Sk = U -yi[f (xj, x,i.j) I xj occurs in -yin
i=h
</equation>
<bodyText confidence="0.842833333333333">
EXAMPLE 1. If we start a derivation 7r from (Se, 0)
and apply the S-rule in (la) and the following VP-
rule
</bodyText>
<equation confidence="0.8754774">
(VP V VP&apos;, {xo Xi, XCOMP X0 Pe, X2})
we end up with the following sequence.
7r0 = (So, 0)
7ri = (SENP1, VP210 JSUBJ X0 r-z% X1,X0 X2})
71-2 = (S[NPI ,VP [V2.1,VP&apos;2.2]2]0 &apos;{X° r-sj Xi, XCOMP XO X2})
</equation>
<bodyText confidence="0.972594666666667">
For the steps depicted above the sequence to is given
by tvi = 0 and tv2 = 2 and the feature description
derived by 7r from 0 to 2 (S2) is
</bodyText>
<equation confidence="0.671588">
{SUBJ X0r.z,&apos; Xi, X0 Pe, X2, X2&apos;A.,&apos; X2.1, XCOMP X2%,--1 x2.2}.
</equation>
<bodyText confidence="0.913428">
Sentences are then defined as follows.
</bodyText>
<listItem confidence="0.9747655">
5. DEFINITION. A terminal string w (w E V) is
a sentence if there is a derivation (Se, 0) = Iro•.7rn
with wn, = s[w]o and 3x,..x0„. A sj,,(xt„ , ••,
satisfiable.&apos;
</listItem>
<bodyText confidence="0.992877444444444">
In the following we write S for if the inter-
val covers the whole derivation, i.e. if ir is of length
Since a specific reduction algorithm and a few
model-theoretic facts required in the proofs later on
can be introduced by showing how satisfiability of
such existential prenex formulas can be decided, we
will continue with a short excursion on satisfiability.
&apos;We use s[w]0 to denote an S-rooted c-structure with
yield w.
</bodyText>
<page confidence="0.998699">
46
</page>
<subsectionHeader confidence="0.927327">
2.1 Satisfiability
</subsectionHeader>
<bodyText confidence="0.956895">
In order to test whether for a given finite set of lit-
erals S of a feature-description language (2)
</bodyText>
<listItem confidence="0.974107">
(2) ]xi..x/ A s(xi, xi)
</listItem>
<bodyText confidence="0.9027918">
is satisfiable, we can exploit by skolemization well-
known test procedures available for quantifier- and
variable-free sets of such literals. Let C be a set of
Skolem-constants (I{xi, •., xi} I = ICI) and 0 be a bi-
jective function from {xi, x1} to C, then (2) can be
</bodyText>
<listItem confidence="0.5639245">
tested by testing the set of literals (3) over L(C)4
(3) S[0],
</listItem>
<bodyText confidence="0.9976475">
since (2) and (3) are equi-satisfiable. In the follow-
ing we complete the procedure by introducing a re-
duction algorithm that reduces a set of literals (3)
according to a measure in a sequence of measure
decreasing rewrite steps to a deductively equivalent
set (4) (in reduced form)
</bodyText>
<listItem confidence="0.489715">
(4) (S[9])p,
</listItem>
<bodyText confidence="0.99430875">
which is satisfiable iff the terms T of all inequalities
T T of (4) do not occur as subterms in equations
of (4).5
For the proof we first introduce a few definitions
and some notation. Let T be the set of terms
of a variable-free feature-description language L(C).
Then an injective function m E [T IN*] is a mea-
sure if it satisfies the following conditions for all
</bodyText>
<equation confidence="0.989289">
T T1 E T and a. E
(i) if I7I &lt; 1711, then m(7) &lt; m(7&apos;),
(ii) if m(7) &lt; m(71), then m(o-r) &lt; m(crri).
</equation>
<bodyText confidence="0.9831483">
For literals and sets of literals S we extend a mea-
sure m as usual by m((—)7 P.-, 7&apos;) = m(7) + m(7&apos;)
and m(S) =
0Es
In the following we use T T1 if m(7) &gt; m(7&apos;)
and to denote ambiguously 7 71 or 7&apos; r.
Let S be a set of literals then E denotes the set of
all equations in S, Ts the set of terms occurring in
the formulas of S (Ts = {7,71 I (^,)T S 71 E S}) and
SUB(Ts) the set of all subterms of the terms in Ts
</bodyText>
<equation confidence="0.556518">
SUB(Ts) = 17- I cIT E Ts, with a E
</equation>
<bodyText confidence="0.7422638">
For the construction of a reduced form we need a
specific partial choice function p which satisfies
p(S) E fr ESITE SUB(Ts\{,,,..„,,})}
if the specified set is nonempty and undefined other-
wise.
</bodyText>
<listItem confidence="0.907839666666667">
6. DEFINITION. For a given finite set of literals S
and a choice function p we define a sequence of sets
Sp, (i &gt; 0) by induction:
</listItem>
<equation confidence="0.990388">
Sp° =S
(SpA{TT&apos;})[TIrdU {7P-:•7&apos;} if p(Sp,) = T1
p‘+, { c,
</equation>
<bodyText confidence="0.969760461538462">
if p(Sp) undef.
4The feature-description language which in addition
to L provides a distinct set of Skolem-constants C. Cf.
the appendix for more details.
&apos;The algorithm is adapted from Statman 1977 and
Knuth and Bendix 1970 and first applied to feature-
description languages by Beierle and Pletat (1988).
Since m(Sp,) &gt; m(S1) if p is defined for Sp„ the
construction terminates with a finite set of literals.
If we set
S,, = S,,,; with t = min{i I Sp, = Sp,,,}
the following lemma can easily be proven by induc-
tion on the construction of 5p.6
</bodyText>
<listItem confidence="0.897512666666667">
7. LEMMA. For S,, it holds that:
(i) S S p,
(ii) if T Ti E Sp then T
</listItem>
<bodyText confidence="0.981435666666667">
Since Sp is obviously not satisfiable if it contains
an inequality T T and T occurs as a subterm in Ep,
the whole proof is completed by showing that we can
construct a canonical model satisfying Sp if Sp does
not contain such an inequality.
For the model construction we need the set
Thp = fr E SUB(TEP) I —13&apos;71 (T T1 E 4)1
and the function le E [SUB(Th) 1-4 Thp] which is de-
fined for each 7 E SUB(TE) by
</bodyText>
<equation confidence="0.853304">
1&apos;( E Ep) if 0 &apos;TZ
hC (r) =
otherwise.
That hC is well-defined results of course from 7(fi).
</equation>
<bodyText confidence="0.945258">
8. DEFINITION. For a set of literals Sp the canoni-
cal term model is given by the pair Mp = (1,1p, p)
consisting of the universe
u f Tk, if Ep 0
P 1 {0} otherwise
and the interpretation function .cap, which is defined
for cEVUC,/ E Fi and 7- E tip by:
= {hc (c) if c E SUB(TE)
undefined otherwise
f ft&apos; (f 7) if fT E SUB (TE, )
</bodyText>
<subsubsectionHeader confidence="0.665561">
°P(f)(T) lundefined otherwise.
</subsubsectionHeader>
<bodyText confidence="0.8614675">
For Mp which is well-defined the following lemma
holds:
</bodyText>
<listItem confidence="0.63766">
9. LEMMA. If T is a subterm of Ts, then
c-lp(T) = hc(T), if T E SUB(TE,),
(ii) r E SUB(TEp), if r E Dom(,,).
</listItem>
<bodyText confidence="0.95920575">
PROOF. (By induction on the length of r.) The
lemma is trivial for constants. By showing (i) be-
fore (ii) we get the induction step for a subterm fT
of Ts, in both cases according to
</bodyText>
<equation confidence="0.981996">
p(fT) = p(i)((T)) = C4(i)(hc(r)) =
</equation>
<bodyText confidence="0.8983505">
We get C p (r = hC (T) by inductive hypothesis and
h&apos;(7) = 7-, since 7 0 lip would imply the existence of
</bodyText>
<footnote confidence="0.808513">
61n order to verify 7(i) cf. e.g. Wedekind 1991
and 1994.
</footnote>
<page confidence="0.998328">
47
</page>
<bodyText confidence="0.943701066666667">
T E Ep and Pr could not be a subterm of Ts,
according to lemma 7(ii). Now, if (i) fr E SUB(TE)
then ■&apos;F- p(f)(T) is defined and equal to he(fr) and
(ii) if fr E SUB(Ts) and C p(f T) is defined then
fr E SUB(TE„).
On the basis of lemma 9 it is now easy to prove:
10. LEMMA. VT T E Sp(T SUB(TEp )) A/p S.
PROOF. (If the condition is satisfied =M0 holds for
every 0 E Sr.) If 0 E Sp with m(7&apos;) &lt; m(7),
then T&apos; E Ti.p by 7(ii) and hence lic(7&apos;) = T1. We get
then Itc(7) = T&apos; for m(71) = m(7) by Ti = T and for
m(7&apos;) &lt;m(T) by the definition of hc , since T T.
Thus ■1&apos; p(T) = :1,0(7&apos;) by 9(i) and hence =M 0.
Assume 0 = T . If T T1 were satis-
fied by Iv!,,, we would get :1 p(T) = p (7-&apos;) and
</bodyText>
<equation confidence="0.789054666666667">
by 9(ii) T E SUB(TEp). Since 7(ii) ensures
lic(r) = hc(73) = T = r&apos;, we would have 7 7 E Sp
with T E SUB(TEp). 0
</equation>
<bodyText confidence="0.9988632">
Finally it should be mentioned that Mp is a unique
(up to isomorphism) minimal model for S,,, i.e. if M
is a model for Sp, homomorphic to Mp, then every
minimal submodel of M that satisfies S,, is isomor-
phic to M,,.
</bodyText>
<sectionHeader confidence="0.9930945" genericHeader="method">
3 The Generation Problem and its
Decidability
</sectionHeader>
<bodyText confidence="0.999714">
Although it was not necessary for the definition of
the sentences derivable by a unification grammar, we
now have to make explicit that also a feature descrip-
tion is assigned to a sentence.
</bodyText>
<listItem confidence="0.9140198">
11. DEFINITION. A terminal string w (w E VP is
derivable with feature description 3x1..x/0(xi, ••, xt)
if the feature description is satisfiable and there
is a derivation (So, 0) = 70..7n with con = s[w]o and
= A s7r •
</listItem>
<bodyText confidence="0.995055117647059">
Since deductively equivalent consistent feature de-
scriptions are assumed to describe the same set of
feature structures (models), the assignment of en-
tities to terminal strings determined by a unifica-
tion grammar is then formally given by a binary
relation A between terminal strings and sets of
classes of deductively equivalent feature descriptions
[axi-x10(x1,
12. DEFINITION. For each terminal string w E 1/4:
and each class [3xi 0(xi ••, xt)]:
A (w, [3x1.•xi0(xi, ••, if w is derivable with
•-, xt)•
Definition 12 now brings us closer to the problem,
since we can for any unification grammar in rather
abstract terms specify what parsers and generators
are: a parser is a procedure which recursively enu-
merates for any given string w the set
</bodyText>
<footnote confidence="0.613616666666667">
1[3xi..xi0(xi,..,xt)] IA(w,[3xi-x14)(xi,••,xt)1)}
7We omit the index of the equivalence classes in the
following.
</footnote>
<bodyText confidence="0.948638">
and a generator is a procedure which recursively enu-
merates for any given class [3xi..x/0(xi, ••, x/
</bodyText>
<equation confidence="0.790226">
E 174,&apos;I A(w, []xi ••x/4)(xi, -,X1)])}.
</equation>
<bodyText confidence="0.99959325">
Whether adequate algorithms (effective proce-
dures) can be formulated depends on the decidability
of the corresponding parsing and generation problem.
In our case (generation), it is the problem whether
</bodyText>
<equation confidence="0.932845">
3w E V4-•&apos;(A(w, [3xi..x/0(xi,..,x/)]))
</equation>
<bodyText confidence="0.9988597">
is decidable for any given class [3x1-xt95(xi , ••, xt)]•
The decidability of the generation problem alone en-
sures the existence of algorithms which terminate in
any case with an output, although they might (of
course) not be able to produce all possible solutions.
Despite decidability, inputs can still be infinitely am-
biguous (Ilw E V IA(w, [3xi..x/0(xi,..,x/)])}1 infi-
nite).
In order to prove the decidability of the generation
problem (theorem 13), we proceed in two steps.
</bodyText>
<listItem confidence="0.962368">
13. THEOREM. It is decidable for each feature
description 3y1..ykO(y1,..,yk) whether there is a
terminal string w E 1/4; which is derivable with
3xi..x/0(xi,.., xi) and
</listItem>
<bodyText confidence="0.943409615384615">
3Y1-Y/c/P(Y1, ••,Yk) -1F- 3xi-x10(xi, ••,x1).
In the first step we show that we can always shorten
a derivation of a sentence w with (consistent) fea-
ture description 0 to a derivation of a sentence w&apos;
with feature description 4/ and 45 -II- 0&apos; whose length
is bounded by the &amp;quot;size&amp;quot; of 0. By showing in the
second step that two deductively equivalent consis-
tent feature descriptions have the same &amp;quot;size&amp;quot; the-
orem 13 follows, since only a finite set of deriva-
tions (those whose length does not exceed this up-
per bound) have to be inspected in order to decide
3w E ((w, [0])) for an arbitrary consistent input
(k•
</bodyText>
<subsectionHeader confidence="0.997385">
3.1 Redundant Recursions and Pumping
</subsectionHeader>
<bodyText confidence="0.998088875">
For the proof that for a derivation of a sentence w
with (consistent) feature description 0 there always
exists a short derivation of a sentence w&apos; with fea-
ture description 0&apos; and 0 -II- 0&apos; we exploit the fact
that a c-structure may contain recursions of the form
depicted in figure 2 whose corresponding subderiva-
tions in 7r are eliminable. Such recursions are called
redundant.
</bodyText>
<listItem confidence="0.965614714285714">
14. DEFINITION. Let IT be a derivation of a sentence
uvzxy of length m + k + 1 whose c-structure deriva-
tion has the form wo..con,..con,+k..com±k±/ = con with
wm = S [U A y] 0 and com±k = s [u, A [v , Ap.n, x]n , yjo
(reorder if necessary). If 7&apos; is a derivation of
uzy of length m + 1 which is defined for each j
(0 &lt; j &lt; m + 1) by
</listItem>
<bodyText confidence="0.5255515">
=
{7r.
</bodyText>
<figure confidence="0.3290155">
3
3 (S[UTy]o, S) if j &gt; in and ri±k = (sEuvrxylo,S)
</figure>
<footnote confidence="0.99632575">
8We assume here strong reversibility, since a generator
is for a given input y simply a parser which operates on
it recursively enumerates instead of Ix I A(x,y)}
the set fx I
</footnote>
<page confidence="0.998629">
48
</page>
<figureCaption confidence="0.608774">
Figure 2
</figureCaption>
<figure confidence="0.794131785714286">
A c-structure with recursion idzi, A„.„,xJ (1K1 &gt; 0).
and
19. DEFINITION. A set of literals S(xi, _xi) is in-
dependent if there is no formula (j) E S for which
3xi ..x/(A(SVOI) D 0) holds.
Normal forms are then defined as follows.
20. DEFINITION. A consistent feature description
3x1..x1 A sixi , is in normal form (in the fol-
lowing indicated by a V index) if Sixi,..,xil is in-
dependent.
Furthermore, we call 3x1 ..x1 A svfxi, • •, xil a normal
form of 3x1..x1x&apos;1..x,, A .., if
is an independent subset of S&apos;[0] E R(S`) and
3x1 ..x/ (A Su (xi, xil A Si[0])•
</figure>
<bodyText confidence="0.89878875">
Lemma 18 and the condition in definition 20 ensure
that a consistent feature description and its normal
forms are deductively equivalent.
In order to be able to show the existence of
a redundant recursion, we exploit the simple fact
that the information which contributes a literal
in a normal form with a minimal model (11n, p)
can be specified by an equation r TI where
</bodyText>
<equation confidence="0.924876833333333">
iff 171 +
W/r• if j &lt; m
• = i
p.t f 3 &gt; m and tV j+k =
7rrn-1-1•••7rrn+k is a redundant recursion
3x1..xi A srr (xi, ..,x,) 3xc, ..x&apos;k A sir&apos; ,
</equation>
<bodyText confidence="0.998696384615385">
If we assume that a given derivation of a sentence
is already shortened to a derivation without redun-
dant recursions it remains to show that the length of
such a derivation could not exceed the upper bound
determined by the &amp;quot;size&amp;quot; of the derived feature de-
scription.
The &amp;quot;size&amp;quot; of a consistent feature description is on
the one hand determined by the size of its minimal
model, and on the other hand determined by a nor-
mal form into which every feature description can be
converted. The conversion is performed in two steps.
In the first step, we eliminate as many variables as
possible by substitution.
</bodyText>
<listItem confidence="0.968881142857143">
15. DEFINITION. If S(xi, .., xi) is a set of lit-
erals, then x, is elirninable in S(xi,..,xi) if
there is a term T not containing xi such that
3xi...xt (A S(xi, .., xi) D xi 7).
16. NOTATION. In the following we write SI-xi, ••, xi]
if each xi is not eliminable in S.
17. DEFINITION. We assign to a set of liter-
</listItem>
<equation confidence="0.7058875">
als S&apos; (xi , .., 4) a set R(S&apos;) which con-
tains a set Sixi, if there is a substitution
E [14, .., xik} T(xi,..,x/)] such that
3xi..x14..xik(A D x: 0(4))
</equation>
<bodyText confidence="0.8335605">
for all x (1 &lt; &lt; k) and Sixi, = S&apos;[0].9
By the substitutivity theorem we get:
</bodyText>
<listItem confidence="0.6870755">
18. LEMMA. If E
then 3xi..x`k (A S AS&apos;).
</listItem>
<bodyText confidence="0.957660525">
In the second step, we make the set of literals in-
dependent, i.e. we remove those literals which are
implied by the remaining subset.
/ .., xl) denotes the set of terms over V,
{xi, .., xi} and
&lt; JU,, + 2. A literal 7 r■&apos;: CICII T&amp;quot; (ICI1 &gt; 0)
whose terms are longer must always be reducible
by a loop °dr&amp;quot;•=:.•-• 7&amp;quot; to a shorter equation. Since
the construction of such an information piece can be
done with a subderivation of some fixed length, there
must be a redundant recursion if the length of whole
derivation exeeds a fixed value which is dependent
on Pp and 1S14 and exactly specified in lemma 21.1°
21. LEMMA. Suppose that w E 1/4-,&apos; is derivable with
over 7r of length n,
thatRxi..xl A s, [xi , is a normal form of q5 and
that Mp = (1,1p,,i-p) is a minimal model of 0. If 7r
has no redundant recursions then each path of w„ is
shorter or equal to IVNI • (31/41 + 1) ((Sp! + 1).
PROOF. Suppose, one path of con were longer
than 1V/s/ 1 • (31/41 + 1) • (1,5,1 + 1), then more than
(3 Pp&apos; + 1) • (1S,1 + 1) different nodes on that path
had to be labelled by the same A E VN. With-
out loss of generality we can assume that ir is a
derivation whose c-structure derivation w has the
form wo..wm..wn, with win= s y]o for each node
p on that path which is labelled by A (reorder if
necessary). In order to exclude that complex in-
ferences are used to build up 0, we assume fur-
thermore that U is non-deterministically constructed
from S&amp;quot; by recursive variable substitution, i.e. we
require for each (x, GT) E 0 either xr•:,-crr E S&apos; or
3x•-•:.•&apos;ay E r((y, , r) E 0). Finally, let S C S7 with
Sz, = S[0]. In order to identify the redundant re-
cursion we have to consider the following cases.
1. Suppose there are more than ISI + 1 A-labelled
nodes p such that xm does not occur in S7, then there
must be more than IS,,I non-overlapping recursions.
For at least one of those recursions 7r7,1+1...7r,,,+k it
must hold that
</bodyText>
<subsectionHeader confidence="0.366121">
(s n u
</subsectionHeader>
<bodyText confidence="0.942078">
1°The given factor I VNI • (3 Illp + 1) +1) de-
creases for more restricted grammars, like e.g. grammars
which allow only feature descriptions with single-rooted
and/or acyclic minimal models.
</bodyText>
<figure confidence="0.473046">
then
</figure>
<page confidence="0.830042">
49
</page>
<figure confidence="0.986260153846154">
But then
S C U
and 7r7,2-0•••71-m+k must be redundant.
2. If case 1 does not apply there must be more than
3 Pol • (1.5,1 + 1) distinct A-labelled nodes u on that
path such that xi, occurrs in .57 and for more than
3 IS„1 + 1 of these nodes must pairwise hold
3xi..4 (A S&amp;quot; D xp xp.).
But then there must be at least three recursions such
that
3x1..x1k(A S&apos; D XL XL.A XL.A.1.1 R&amp;quot;&apos;&apos; X C.A.1.1.c)
and
(S n Si&amp;quot;/) u S,Tr+/+v-i-z+1_,,n)•
</figure>
<bodyText confidence="0.990713">
We can then assign to each recursion 7rm-F1•••rm+k
(m=i,k=l;m=i+1,k=v or m=i+1+v,k=z) a
type which corresponds to the strongest of the fol-
lowing conditions the recursion satisfies.
</bodyText>
<figure confidence="0.908687428571429">
(a) irm+1...7rm+k satisfies
F- Qir
(A D xp
(b) It holds only
3xi..x&apos;k(A Sm1r+1.„±k D xpa, ax)
with la! &gt; 0 and a0(x) O(x) is implied by
3xi ..xik (A SLm+k A S9) where S9 is the set of
ground literals of S.
(c) Or it holds
3x1.4 (A sil+1,.+k
with la &gt; 0 and o-&apos;19(xo.„) O(xo.„) is implied by
H (A Sni&amp;quot; +i,„ A S9).
(d) If a recursion which satisfies
3x1 (A S+171-1-k Xpt•K ax)
</figure>
<bodyText confidence="0.801639">
WTI &gt; 0) is not of type (b) then there must be a
ground term T which is not reducible in terms of xo,
i.e. 6 can not satisfy T = C710(Xp) for some non-empty
prefix a&apos;, and
3x,...x1k (A S7r D xp.„ A r e(xp)).
(e) For a recursion with
3xi..4 (A ST1-1-1_4m-1-k D atXtt•tc xis)
which is not of type (c) we get for xi, the same prop-
erty as for xo., in (d).
(f) If the previous cases do not apply, the recursion
might satisfy
H 3x1..xik(A Sm&amp;quot; DCrIXP•n axP)
with lal &gt; 0 and a&apos;i &gt; 0. Since xo is not eliminable
in terms of xo.„ and vice versa, there-must be ground
</bodyText>
<listItem confidence="0.57566425">
terms T, Ti such that
3x1..4 (A Sir xp TA xp.„ Tt Ar T&apos;).
(g) If a recursion is not of type (a—f) then
3xi...x&apos;k(A Sm&amp;quot; +1,m+k D ax xi, A u&apos;y
</listItem>
<bodyText confidence="0.9124438">
But then x„ and xu.„ must be ground eliminable as
in (f).
Since a recursion of type (a—c) is not redundant if it
contains terms T or T1 such that T is not reducible in
terms of xu and Ti is not reducible in terms of xo.,
and r or T1 are used to eliminate xo and xo.„, there
must be at least one recursion 7r,o+1...7rm±k such that
3x1 (A S&apos; (SJ,„,,US7I+k+1,,,,U {xo
and 0 still follows either by ground inferences or due
to the properties of (b) and (c). 0
If /max = max{lw I I ((A, w), Sr) E RI then the fol-
lowing pumping lemma follows immediately as a
corollary.
22. COROLLARY. Suppose that w E VI is deriv-
able with cb Rxi..xix&apos;3...x&apos;k A Sir (X1 4) over 7r
of length 72, that ]xj...xi A s,, [xi, ..,x11 is a nor-
mal form of (1) and that M09 = (U ) is a mini-
mal,P
model of ç5. If Iwi &gt; IVNI.(21U p1+1) lmax then w has
the form uvzxy with Ivxl &gt; 0 and for all i 1:
(uvizxiy, [3xi A sir (xi , ..,x1k)j) E A•
PROOF. If wi &gt; 11=(21141+1) then at least one path
of wo is longer than IVNI • (2 1141+1) and more than
21/41 + 1 different nodes on that path are labelled
by the same A E VN. Without loss of generality
we assume again that 7r is a derivation whose c-
structure derivation w has the form wo..wm..wo with
Wm = s [u, Ao, y]q for each node tt on that path which
is labelled by A, and that 0 is non-deterministically
constructed from Sif by recursive variable substi-
tution, i.e. we require for each (x, ar) E 6 either
xar E Sir or 3xo-y E S&apos;((y, 7-) E 0). Suppose fur-
thermore that S c S&amp;quot; with Su = S[0]. In order to
isolate the recursion which allows pumping we have
to distinguish the following cases.
</bodyText>
<listItem confidence="0.944626571428571">
1. If 7r contains a recursion 7roi+1...7rm-i-k with
Lam = s[u, Ao, y10, wro+k = s[u, AA jc, 42, y10
and Ivxl &gt; 0 and xo and xo.„ do not occur in S&amp;quot;,
we take irm+1...7rm+k •
2. If 7T does not contain such a recursion there must
be at least three distinct A-labelled nodes t, t.A, t.A.v
on that path such that
</listItem>
<equation confidence="0.831892">
wi= sAt, Om
= s U1,A[vi, At.x, Yilo,
wi+/+v = s U1, Alp&apos;, A[r, v],x, y&apos;}ø
</equation>
<bodyText confidence="0.827224111111111">
with Iv&apos;x&apos;l &gt; 0, Vs! &gt; 0 and
3xi..4(A S&apos; D xt x.),
2.1 Suppose there is a recursion of type (a—c) (cf.
proof of lemma 21) we choose this one.
2.2 If 7r does not contain such a recursion each of
the recursions must be of type (d), (e), (f) or (g).
But then there must be one recursion 7rm.44...7rm+k
(in = k =1 or m = + /, k = v) with
3xi..x&apos;k (A D xp T V Xp, js Pe. T1)
</bodyText>
<page confidence="0.98996">
50
</page>
<bodyText confidence="0.9999404">
for some ground terms T, T1. This recursion is
choosen for the proof.
On the basis of the recursion 71-Th+1...rm+k we can
now define derivations 71-&apos; as follows. We set 7r1 = 7r
and define 713+1 on the basis of 7rt by
</bodyText>
<equation confidence="0.8607505">
(siu,A[virxiip.,‘,Y]o,S) if j &gt; m+ik and
(s [u,A
113 3-k
7rt. if j&lt;m+ik
</equation>
<bodyText confidence="0.850138040816326">
and
if j &lt; m + ik
{ 3
Wi p.ici.t if j &gt; m + ik and Wii_k =
By induction on i it can then be shown for all possible
cases that H 3x/ -(A Sir* AS). 0
3.2 Invariance of the Parameters under
Deductive Equivalence
Since the universes of the minimal models of two de-
ductively equivalent consistent feature descriptions
must have the same cardinality, for the completion
of the proof of theorem 13 it remains to be shown
that two deductively equivalent consistent feature
descriptions have the same &amp;quot;information content&amp;quot;,
i.e. that the sets of literals of their normal forms have
the same cardinality:
23. LEMMA. Suppose that 3xi..xt A sv Ix&apos;, • •, xii
and 3yi..yk A ykl are deductively equivalent
consistent feature descriptions in normal form then
is,, rxi, .•, xti = ••, yki
23 in two steps. First, we
convert Sui fyi, ykl into a set
the same cardinality such that
xi]-a- A sp&amp;quot; [xi, .., x/1) holds.
24. LEMMA. Assume that 3x1-xl A Sjxi, •.,
and 3yi..yk A S, r are deductively equivalent
consistent feature descriptions in normal form. Then
1 --= k and there is a set Sv&amp;quot;1-xi, with
(i) 15&apos;p/11xi, xil I = FYi, Ykl I and
(ii) 3xi..xt (A S,, Ixi , xil a A Su&amp;quot; fxi, xil ).
PROOF. Suppose that {xi, .., xi} n {yi , ••, yk} =
(rename if necessary), that 5, iyi , ••, ykl is in re-
duced form (the reduction of an independent set does
not change the cardinality) and that M = (U,:.1)
is an arbitrary model of 3x1..xt A Su fx1, ••, x/1
and 3y1..yk A s,,&apos; rm. 7 .•1 Ykl p • Let a and a&apos;
be assignments such that a J=M S,,fxi, .., xil and
a&apos; ./v/ S&apos;y f-Y1,••,Yklp•
We show first that there is a bijective function
E { yi, Yk }1 such that for all xi
there is a ai E Fi* (i = 1, ..,/) and a variable /9(x2)
occurring in S&apos; with a(xi) = (cri/9(xi))(a&apos;). First
of all 19 is left-total, since a(xi) = (7-) with T
variable-free would imply that xi is eliminable
in S. In order to show that t is a func-
tion, assume a(xi) = (:s(o-jyj)(&amp;) =cs&apos;s(ahyh)(cr&apos;) for
Yh occurring in S&apos; with yi yk. Since yj
and yh are not eliminable in 5&apos; there must
be terms 7-j, Th such that a1(Yj) =
</bodyText>
<equation confidence="0.996825">
ai(Yk) = (Tk)(a),(Zs-5(0.373)(a) = (ahrh)(a) and
</equation>
<bodyText confidence="0.998519904761905">
there is no a e 17 such that Z&apos;(o7-,)(a) )(a)
or (cri-h)(ce) = (-7-j)(a). Thus, Ti and Th must be
terms in T({xi,.., xi}\{xi}) and xi would be elim-
inable in S. Suppose now that yj is not in the
range of /9. Then there must be a term 7- with
= a1(yi). Since yj is not eliminable in S1,
T must be of the form o-xi and there must be a
term T1 with a(xi) = .q.(7-&apos;)(a1). If T1 is a term in
T({Yi, yk} \ {yi}), yj would be eliminable. Oth-
erwise T1 is of the form a&apos;yj and we would get
a(xi) = y j)(a&apos;). Hence 0 is onto. Assume fi-
nally a(x) = (cliyh)(a&apos;) and a(x3) =(aiyh)(a1)
with x2 xj. Then there must be a term T with
a1(yh) = 5:s(r)(a). Since xi and xi would be elim-
inable in S if T is a term in T({xi, Xj}),
T is of the form ax, or ax. But then either
a(x) = No-jax,)(a) ora(x2) = :1(llicrxj)(a). Thus,
19 is bijective and 1 = k.
On the basis of /9 we then define a sequence of new
sets S: (0 &lt; i &lt;I) by induction as follows (within the
induction we assume 19(x,) -= y):
</bodyText>
<equation confidence="0.589980333333333">
SO= S:,ryi,
if a(xi) = a&apos;(y)
\{yr----,o-o-&apos;y})[Ykx.] U {x, Gio-xj} if (A),
</equation>
<bodyText confidence="0.9901011">
where (A) means a(xi) a1(y), E S.:_1 and
a(xi) = ca(ody)(a1). In the case where the variables
refer to different nodes on a loop (a(xi) a1(y)) the
definition is well-formed, since p is re-
duced and normalized and thus there must be ex-
actly one equation yo-ll&apos;y in S,&apos;_1 describing the
loop with the node to which x, refers. For S&amp;quot; =
ISuurxi,..,xlii ryi , •., Ykl I follows immediately
by induction on the construction of S&amp;quot;.
Finally we get (ii), since
</bodyText>
<equation confidence="0.3697075">
H 3x1..x,(3xi±i ..xt A S,, fx1,.., x/1 E
3/9(xi+1)../9(x1) A s; [xi , ..,x, 9(x2+1), ..09(xt)l)
</equation>
<bodyText confidence="0.9884955">
can easily be verified by induction on the construc-
tion of S&amp;quot;. 0
Since two deductively equivalent independent and
consistent sets of (variable-free) literals reduce to
the same set of literals in reduced form, lemma 25
follows by skolemization and completes the proof of
lemma 23.
25. LEMMA. If 3xi..xi A svrxi, .., xi] is a consistent
feature description in normal form
and I- 3x1 (A Sv {xi, .., xil a- A sv&amp;quot; xil) then
</bodyText>
<sectionHeader confidence="0.965984" genericHeader="method">
Appendix: Syntax and Semantics of
Feature-Description Languages
</sectionHeader>
<bodyText confidence="0.965410666666667">
A feature-description language L(C) consists of the
logical connectives — (negation), D (implication),
the equality symbol the existential quantifier 3
and the parentheses (, ). The nonlogical vocabulary
is given by a finite set of constants V (atomic values),
We proof lemma
show that we can
S,&amp;quot; {xi , with
3x1 ..xt (A S. rxi 7
</bodyText>
<page confidence="0.953257">
51
</page>
<bodyText confidence="0.998655086956522">
a possibly empty finite set of constants C (Skolem-
constants) and a finite set of unary partial function
symbols F1 (V,C,F1 pairwise disjoint). The class of
terms and formulas of L(C) are recursively defined as
usual. Feature descriptions of L(C) are expressions
of the form Dxi..xi A s[xi, •., xd, where S is a finite
set of (quantifier-free) literals. (We assume that the
connectives V (disjunction), A (conjunction) and -a
(equivalence) are introduced by their usual defini-
tions.)
A model for L(C) consists of a nonempty universe
1,1 and an interpretation function. Since not every
term denotes an element in U if the function symbols
are interpreted as unary partial functions, we gener-
alize the partiality of the denotation by assuming
that itself is a partial function. It is only required
that all Skolem-constants denote. Suppose [X 1—, 11
designates the set of all partial functions from X to
Y and [X Y] the set of all total functions from X
to Y, then a model is defined as follows:&amp;quot;
DEFINITION. A model for L(C) is a pair M =
consisting of a nonempty set 1,1 and an interpretation
function U cy U :IF„ such that
</bodyText>
<equation confidence="0.967131">
(i) E [V 1-1- /4],
(ii) E [C Li],
(iii) F1 E [F1 &apos;—&apos; [14
(iv) Vf E Fi(f E Dom() (f) 0 0).
</equation>
<bodyText confidence="0.999794166666667">
If we extend the denotation function to terms and
variable assignments a, the definition of the satisfac-
tion relation differs only in the clause for the equa-
tions from the usual one:
a km T T1 if (:s(r)(a) and :1(r&apos;)(a) are defined
and (-i-)(a) =
</bodyText>
<sectionHeader confidence="0.999244" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999812108108108">
Beierle, C., and U. Pletat. 1988. Feature Graphs and
Abstract Data Types: A Unifying Approach. In Pro-
ceedings of the 12th International Conference on Com-
putational Linguistics. Budapest.
Kaplan, R., and J. Bresnan. 1982. Lexical-Functional
Grammar: A Formal System for Grammatical Repre-
sentation. In J. Bresnan, ed., The Mental Represen-
tation of Grammatical Relations. Cambridge, Mass.:
The MIT Press.
Johnson, M. 1988. Attribute-Value Logic and the Theory
of Grammar. Chicago: CSLI Lecture Notes Series,
Chicago University Press.
Knuth, D., and P. Bendix. 1970. Simple Word Problems
in Universal Algebra. In J. Leech, ed., Computational
Problems in Universal Algebra. Elmsford: Pergamon
Press.
Shieber, S., H. Uszkoreit, F. Pereira, J. Robinson, and
M. Tyson. 1983. The Formalism and Implementation
of PATR-II. In B. Grosz and M. Stickel, eds., Research
on Interactive Acquisition and Use of Knowledge. SRI
Final Report 1984. SRI International, Menlo Park.
&amp;quot;If constant-consistency and constant/complex-
consistency are to be guaranteed for the atomic values
V or acyclicity has to be ensured for the models, special
conditions can be added to the definition.
Statman, R. 1977. Herbrand&apos;s Theorem and Gentzen&apos;s
Notion of a Direct Proof. In J. Barwise, ed., Handbook
of Mathematical Logic. Amsterdam: Elsevier North-
Holland.
Wedekind, J. 1991. Classical Logics for Attribute-Value
Languages. In Proceedings of the 5th Conference of
the European Chapter of the Association for Compu-
tational Linguistics. Berlin.
Wedekind, J. 1994. Some Remarks on the Logic of Uni-
fication Grammars. In C. J. Rupp, M. Rosner, and
R. Johnson, eds., Constraints, Language and Compu-
tation. London: Academic Press.
</reference>
<page confidence="0.998859">
52
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.953903">
<title confidence="0.9988075">Some Remarks on the Decidability of the Generation Problem in LFGand PATR-Style Unification Grammars</title>
<author confidence="0.994293">Jürgen Wedekind</author>
<affiliation confidence="0.9978495">Institute for Natural Language Processing University of Stuttgart</affiliation>
<address confidence="0.9952285">Azenbergstr. 12 D-70174 Stuttgart, FRG</address>
<email confidence="0.994352">juergen@ims.uni-stuttgart.de</email>
<abstract confidence="0.998764111111111">In this paper, we prove the decidability of the generation problem for those unification grammars which are based on contextfree phrase structure rule skeletons, like e.g. LFG and PATR-II. The result shows a perhaps unexpected asymmetry, since it is valid also for those unification grammars whose parsing problem is undecidable, e.g. grammars which do not satisfy the off-line parsability constraint. The general proof is achieved by showing that the space of the derivations which have to be considered in order to decide the problem for a given input is always restricted to derivations whose length is limited by some fixed upper bound which is determined relative to the &amp;quot;size&amp;quot; of the input.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>C Beierle</author>
<author>U Pletat</author>
</authors>
<title>Feature Graphs and Abstract Data Types: A Unifying Approach.</title>
<date>1988</date>
<booktitle>In Proceedings of the 12th International Conference on Computational Linguistics.</booktitle>
<location>Budapest.</location>
<contexts>
<context position="10793" citStr="Beierle and Pletat (1988)" startWordPosition="1990" endWordPosition="1993">ial choice function p which satisfies p(S) E fr ESITE SUB(Ts\{,,,..„,,})} if the specified set is nonempty and undefined otherwise. 6. DEFINITION. For a given finite set of literals S and a choice function p we define a sequence of sets Sp, (i &gt; 0) by induction: Sp° =S (SpA{TT&apos;})[TIrdU {7P-:•7&apos;} if p(Sp,) = T1 p‘+, { c, if p(Sp) undef. 4The feature-description language which in addition to L provides a distinct set of Skolem-constants C. Cf. the appendix for more details. &apos;The algorithm is adapted from Statman 1977 and Knuth and Bendix 1970 and first applied to featuredescription languages by Beierle and Pletat (1988). Since m(Sp,) &gt; m(S1) if p is defined for Sp„ the construction terminates with a finite set of literals. If we set S,, = S,,,; with t = min{i I Sp, = Sp,,,} the following lemma can easily be proven by induction on the construction of 5p.6 7. LEMMA. For S,, it holds that: (i) S S p, (ii) if T Ti E Sp then T Since Sp is obviously not satisfiable if it contains an inequality T T and T occurs as a subterm in Ep, the whole proof is completed by showing that we can construct a canonical model satisfying Sp if Sp does not contain such an inequality. For the model construction we need the set Thp = f</context>
</contexts>
<marker>Beierle, Pletat, 1988</marker>
<rawString>Beierle, C., and U. Pletat. 1988. Feature Graphs and Abstract Data Types: A Unifying Approach. In Proceedings of the 12th International Conference on Computational Linguistics. Budapest.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Kaplan</author>
<author>J Bresnan</author>
</authors>
<title>Lexical-Functional Grammar: A Formal System for Grammatical Representation. In</title>
<date>1982</date>
<booktitle>The Mental Representation of Grammatical Relations.</booktitle>
<editor>J. Bresnan, ed.,</editor>
<publisher>The MIT Press.</publisher>
<location>Cambridge, Mass.:</location>
<contexts>
<context position="1107" citStr="Kaplan and Bresnan 1982" startWordPosition="165" endWordPosition="168">cted asymmetry, since it is valid also for those unification grammars whose parsing problem is undecidable, e.g. grammars which do not satisfy the off-line parsability constraint. The general proof is achieved by showing that the space of the derivations which have to be considered in order to decide the problem for a given input is always restricted to derivations whose length is limited by some fixed upper bound which is determined relative to the &amp;quot;size&amp;quot; of the input. 1 Introduction Unification Grammars with a context-free skeleton, like Lexical Functional Grammar (LFG) and PATRII (cf. e.g. Kaplan and Bresnan 1982, Shieber et al. 1983) assign to a sentence not only a constituent structure (c-structure), but also an additional linguistic entity. In the rather restricted grammars of the early stage this entity is identified with a special graph structure, commonly called feature structure. Since a string is regarded as well-formed only if a (well-formed) feature structure is assigned to it by the grammar, two inverse decidability problems arise which had to be solved in order to know whether we can formulate terminating parsing and generation algorithms. If we retain the terminology of the early stages t</context>
</contexts>
<marker>Kaplan, Bresnan, 1982</marker>
<rawString>Kaplan, R., and J. Bresnan. 1982. Lexical-Functional Grammar: A Formal System for Grammatical Representation. In J. Bresnan, ed., The Mental Representation of Grammatical Relations. Cambridge, Mass.: The MIT Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Johnson</author>
</authors>
<title>Attribute-Value Logic and the Theory of Grammar.</title>
<date>1988</date>
<booktitle>CSLI Lecture Notes Series,</booktitle>
<publisher>Chicago University Press.</publisher>
<location>Chicago:</location>
<contexts>
<context position="2238" citStr="Johnson 1988" startWordPosition="354" endWordPosition="355">sing and generation algorithms. If we retain the terminology of the early stages then an adequate parsing algorithm requires that we can decide for a given grammar and a given string whether there exists a feature structure assigned to it by the grammar (parsing problem) and an adequate generation algorithm requires that we can decide for a given grammar and a given feature structure whether there exists a sentence to which this structure is assigned by the grammar (generation problem). While we already know for a long time that the parsing problem is undecidable (cf. Kaplan and Bresnan 1982, Johnson 1988), we want to show in this paper that the generation problem is decidable even for unrestricted (not off-line parsable) unification grammars. For the proof we first introduce in section 2 the type of grammar we want to consider. In section 3 we then define the generation problem and show its decidability in two steps. 2 Preliminaries The unification grammars we want to consider consist of rules with a context-free skeleton and a set of annotations associated with the constituents mentioned in the rules. Typical examples taken from LFG and PATR-II are given in figure 1. For the forS-+ NP VP S NP</context>
</contexts>
<marker>Johnson, 1988</marker>
<rawString>Johnson, M. 1988. Attribute-Value Logic and the Theory of Grammar. Chicago: CSLI Lecture Notes Series, Chicago University Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D Knuth</author>
<author>P Bendix</author>
</authors>
<title>Simple Word Problems in Universal Algebra. In</title>
<date>1970</date>
<booktitle>Computational Problems in Universal Algebra.</booktitle>
<editor>J. Leech, ed.,</editor>
<publisher>Pergamon Press.</publisher>
<location>Elmsford:</location>
<contexts>
<context position="10714" citStr="Knuth and Bendix 1970" startWordPosition="1978" endWordPosition="1981">Ts, with a E For the construction of a reduced form we need a specific partial choice function p which satisfies p(S) E fr ESITE SUB(Ts\{,,,..„,,})} if the specified set is nonempty and undefined otherwise. 6. DEFINITION. For a given finite set of literals S and a choice function p we define a sequence of sets Sp, (i &gt; 0) by induction: Sp° =S (SpA{TT&apos;})[TIrdU {7P-:•7&apos;} if p(Sp,) = T1 p‘+, { c, if p(Sp) undef. 4The feature-description language which in addition to L provides a distinct set of Skolem-constants C. Cf. the appendix for more details. &apos;The algorithm is adapted from Statman 1977 and Knuth and Bendix 1970 and first applied to featuredescription languages by Beierle and Pletat (1988). Since m(Sp,) &gt; m(S1) if p is defined for Sp„ the construction terminates with a finite set of literals. If we set S,, = S,,,; with t = min{i I Sp, = Sp,,,} the following lemma can easily be proven by induction on the construction of 5p.6 7. LEMMA. For S,, it holds that: (i) S S p, (ii) if T Ti E Sp then T Since Sp is obviously not satisfiable if it contains an inequality T T and T occurs as a subterm in Ep, the whole proof is completed by showing that we can construct a canonical model satisfying Sp if Sp does not</context>
</contexts>
<marker>Knuth, Bendix, 1970</marker>
<rawString>Knuth, D., and P. Bendix. 1970. Simple Word Problems in Universal Algebra. In J. Leech, ed., Computational Problems in Universal Algebra. Elmsford: Pergamon Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S Shieber</author>
<author>H Uszkoreit</author>
<author>F Pereira</author>
<author>J Robinson</author>
<author>M Tyson</author>
</authors>
<title>The Formalism and Implementation of PATR-II.</title>
<date>1983</date>
<booktitle>Research on Interactive Acquisition and Use of Knowledge. SRI Final Report</booktitle>
<editor>In B. Grosz and M. Stickel, eds.,</editor>
<publisher>SRI International, Menlo Park.</publisher>
<contexts>
<context position="1129" citStr="Shieber et al. 1983" startWordPosition="169" endWordPosition="172">is valid also for those unification grammars whose parsing problem is undecidable, e.g. grammars which do not satisfy the off-line parsability constraint. The general proof is achieved by showing that the space of the derivations which have to be considered in order to decide the problem for a given input is always restricted to derivations whose length is limited by some fixed upper bound which is determined relative to the &amp;quot;size&amp;quot; of the input. 1 Introduction Unification Grammars with a context-free skeleton, like Lexical Functional Grammar (LFG) and PATRII (cf. e.g. Kaplan and Bresnan 1982, Shieber et al. 1983) assign to a sentence not only a constituent structure (c-structure), but also an additional linguistic entity. In the rather restricted grammars of the early stage this entity is identified with a special graph structure, commonly called feature structure. Since a string is regarded as well-formed only if a (well-formed) feature structure is assigned to it by the grammar, two inverse decidability problems arise which had to be solved in order to know whether we can formulate terminating parsing and generation algorithms. If we retain the terminology of the early stages then an adequate parsin</context>
</contexts>
<marker>Shieber, Uszkoreit, Pereira, Robinson, Tyson, 1983</marker>
<rawString>Shieber, S., H. Uszkoreit, F. Pereira, J. Robinson, and M. Tyson. 1983. The Formalism and Implementation of PATR-II. In B. Grosz and M. Stickel, eds., Research on Interactive Acquisition and Use of Knowledge. SRI Final Report 1984. SRI International, Menlo Park.</rawString>
</citation>
<citation valid="false">
<title>If constant-consistency and constant/complexconsistency are to be guaranteed for the atomic values V or acyclicity has to be ensured for the models, special conditions can be added to the definition.</title>
<marker></marker>
<rawString>&amp;quot;If constant-consistency and constant/complexconsistency are to be guaranteed for the atomic values V or acyclicity has to be ensured for the models, special conditions can be added to the definition.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Statman</author>
</authors>
<title>Herbrand&apos;s Theorem and Gentzen&apos;s Notion of a Direct Proof. In</title>
<date>1977</date>
<booktitle>Handbook of Mathematical Logic.</booktitle>
<editor>J. Barwise, ed.,</editor>
<publisher>Elsevier NorthHolland.</publisher>
<location>Amsterdam:</location>
<contexts>
<context position="10688" citStr="Statman 1977" startWordPosition="1975" endWordPosition="1976">s) = 17- I cIT E Ts, with a E For the construction of a reduced form we need a specific partial choice function p which satisfies p(S) E fr ESITE SUB(Ts\{,,,..„,,})} if the specified set is nonempty and undefined otherwise. 6. DEFINITION. For a given finite set of literals S and a choice function p we define a sequence of sets Sp, (i &gt; 0) by induction: Sp° =S (SpA{TT&apos;})[TIrdU {7P-:•7&apos;} if p(Sp,) = T1 p‘+, { c, if p(Sp) undef. 4The feature-description language which in addition to L provides a distinct set of Skolem-constants C. Cf. the appendix for more details. &apos;The algorithm is adapted from Statman 1977 and Knuth and Bendix 1970 and first applied to featuredescription languages by Beierle and Pletat (1988). Since m(Sp,) &gt; m(S1) if p is defined for Sp„ the construction terminates with a finite set of literals. If we set S,, = S,,,; with t = min{i I Sp, = Sp,,,} the following lemma can easily be proven by induction on the construction of 5p.6 7. LEMMA. For S,, it holds that: (i) S S p, (ii) if T Ti E Sp then T Since Sp is obviously not satisfiable if it contains an inequality T T and T occurs as a subterm in Ep, the whole proof is completed by showing that we can construct a canonical model sa</context>
</contexts>
<marker>Statman, 1977</marker>
<rawString>Statman, R. 1977. Herbrand&apos;s Theorem and Gentzen&apos;s Notion of a Direct Proof. In J. Barwise, ed., Handbook of Mathematical Logic. Amsterdam: Elsevier NorthHolland.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Wedekind</author>
</authors>
<title>Classical Logics for Attribute-Value Languages.</title>
<date>1991</date>
<booktitle>In Proceedings of the 5th Conference of the European Chapter of the Association for Computational Linguistics.</booktitle>
<location>Berlin.</location>
<contexts>
<context position="12494" citStr="Wedekind 1991" startWordPosition="2344" endWordPosition="2345">fined otherwise f ft&apos; (f 7) if fT E SUB (TE, ) °P(f)(T) lundefined otherwise. For Mp which is well-defined the following lemma holds: 9. LEMMA. If T is a subterm of Ts, then c-lp(T) = hc(T), if T E SUB(TE,), (ii) r E SUB(TEp), if r E Dom(,,). PROOF. (By induction on the length of r.) The lemma is trivial for constants. By showing (i) before (ii) we get the induction step for a subterm fT of Ts, in both cases according to p(fT) = p(i)((T)) = C4(i)(hc(r)) = We get C p (r = hC (T) by inductive hypothesis and h&apos;(7) = 7-, since 7 0 lip would imply the existence of 61n order to verify 7(i) cf. e.g. Wedekind 1991 and 1994. 47 T E Ep and Pr could not be a subterm of Ts, according to lemma 7(ii). Now, if (i) fr E SUB(TE) then ■&apos;F- p(f)(T) is defined and equal to he(fr) and (ii) if fr E SUB(Ts) and C p(f T) is defined then fr E SUB(TE„). On the basis of lemma 9 it is now easy to prove: 10. LEMMA. VT T E Sp(T SUB(TEp )) A/p S. PROOF. (If the condition is satisfied =M0 holds for every 0 E Sr.) If 0 E Sp with m(7&apos;) &lt; m(7), then T&apos; E Ti.p by 7(ii) and hence lic(7&apos;) = T1. We get then Itc(7) = T&apos; for m(71) = m(7) by Ti = T and for m(7&apos;) &lt;m(T) by the definition of hc , since T T. Thus ■1&apos; p(T) = :1,0(7&apos;) by 9(i</context>
</contexts>
<marker>Wedekind, 1991</marker>
<rawString>Wedekind, J. 1991. Classical Logics for Attribute-Value Languages. In Proceedings of the 5th Conference of the European Chapter of the Association for Computational Linguistics. Berlin.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Wedekind</author>
</authors>
<title>Some Remarks on the Logic of Unification Grammars.</title>
<date>1994</date>
<booktitle>Constraints, Language and Computation.</booktitle>
<editor>In C. J. Rupp, M. Rosner, and R. Johnson, eds.,</editor>
<publisher>Academic Press.</publisher>
<location>London:</location>
<marker>Wedekind, 1994</marker>
<rawString>Wedekind, J. 1994. Some Remarks on the Logic of Unification Grammars. In C. J. Rupp, M. Rosner, and R. Johnson, eds., Constraints, Language and Computation. London: Academic Press.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>