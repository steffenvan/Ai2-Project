<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000079">
<title confidence="0.972618">
Natural Language Generation in the IBM Flight Information
System
</title>
<author confidence="0.635935">
Scott Axelrod
</author>
<note confidence="0.928403">
IBM T.J. Watson Research Center
P.O. Box 218
</note>
<address confidence="0.583613">
Yorktown Heights, NY 10598
</address>
<email confidence="0.993695">
axelrod@us.ibm.com
</email>
<sectionHeader confidence="0.987914" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999704181818182">
The IBM flight information system is a speech based
conversational stem which allows users to create
multi-leg airline travel itineraries based on live flight
availability information. We discuss here the compo-
nents of the system relating to natural language gen-
eration, The deep generation component of the sys-
tem decides what to say based on information shared
with the user about constraints on flights. The sur-
face generation component generates text based on
a simple error catching mechanism and a few basic
&amp;quot;generation constructs&amp;quot;.
</bodyText>
<sectionHeader confidence="0.993803" genericHeader="keywords">
1 Introduction
</sectionHeader>
<bodyText confidence="0.999425384615385">
In this paper we report on our experience in devel-
oping the natural language generation component of
the IBM flight information system which engages the
user in a dialog in English over the phone in order to
find an itinerary for airline travel which best meets
the user&apos;s requirements. Although the focus here is
on the airline travel domain, our techniques should
apply to many domains where the system helps the
user find some data obeying suitable constraints. We
consider here both the problem of deep generation
(deciding what information to say) and surface gen-
eration (deciding how to say the information in spo-
ken language).
</bodyText>
<sectionHeader confidence="0.980195" genericHeader="introduction">
2 Architecture
</sectionHeader>
<bodyText confidence="0.997744918918919">
The system has a central hub that passes a frame of
information around a loop of servers. It runs com-
patibly with the evolving architectural standard of
the DARPA Communicator projectt participated in
by several sites including MIT (Seneff et al., 1998),
CMU (Rudnicky et al., 1999), University of Col-
orado (Ward and Pellom, 1999), and AT&amp;T (Bia-
tov et al., 2000). The system obtains flight data
by connecting to the SABRE computer reservation
system used by many travel agents. Dialog man-
agement is based on the form-based dialog manager
For a description of the Communicator pro-
gram and documentation of the architecture see
httpl /www ,darpa.milf ito/researchIcom/index.html and
http://fofoca.mitre.org.
described in (Papineni et al., 1999). The form based
dialog manager generates messages to the user under
the circumstance when the user has not yet specified
enough constraints to allow for a SABRE query. Af-
ter that point, the generation components discussed
in this paper apply. The deep generation module
passes its decision about what to say to the surface
generation module in the form of a high level list of
what kinds of things to say. The details are passed
in the contents of the frame of information which is
shared between the servers. Both components of the
generation module place information in the frame to
provide feedback to the servers implementing speech
recognition and natural language understanding. •
The generation components discussed here have
been implemented in the tcl programming language.
The advantage of this over a custom scripting lan-
guage is that it leverages both the power and flexibil-
ity of a fully programmable scripting language which
is platform independent. The choice of tcl was one
of convenience since it interoperated best with other
components of our dialog system.
</bodyText>
<sectionHeader confidence="0.998161" genericHeader="method">
3 Example Conversations
</sectionHeader>
<bodyText confidence="0.988364285714286">
To give the reader a flavor of our system, particularly
in regards to natural language generation, we begin
by presenting three excerpts from actual telephone
dialogs with novice users. The user input is the out-
put from automatic speech recognition. The system
output does not currently include prosody informa-
tion; however, punctuation does get translated into
pauses.
Excerpt 1: The first excerpt begins after the user
has entered their identification code.
i SYSTEM: Hello Bob, Please tell me
about the first leg of your trip. For
example, you can say, I want a flight to
chicago leaving next tuesday.
</bodyText>
<listItem confidence="0.6395158">
2 BOB: I WOULD LIKE TO SEE ALL FLIGHTS
FROM NEW YORK TO NATIONAL AIRPORT IN
WASHINGTON D.C. NEXT THURSDAY
3 SYSTEM: what time would you like to
leave on january twenty seventh from
</listItem>
<page confidence="0.975011">
21
</page>
<listItem confidence="0.979201">
new york to washington national
4 BOB: TEN A.M.
6 SYSTEM: i see a few flights from new
york to washington national which depart
about ten A M on january twenty seventh.
do you prefer to depart from newark, J F
K, or la guardia.
6 BOB: LA GUARDIA
7 SYSTEM: there are several flights from
la guardia, you can fly on delta
departing at nine thirty A M or ten
thirty A M, or on U S air at ten A M.
please specify an airline or time.
8 BOB: U.S. AIR
-
9 SYSTEM: U S-air flight 63 57 departs la
guardia at ten A M on Thursday, january
twenty seventh and arrives in washington
national at eleven seventeen A M. Is
this flight okay?
10 BOB: YES
</listItem>
<bodyText confidence="0.952986956521739">
Excerpt 2: The second excerpt regards a flight
from New York to Melbourne, Australia. The ex-
cerpt is the system response after the user has re-
stricted his New York departure to La Guardia air-
port, similarly to (Excerpt 1, Line 6):
SYSTEM: i see a couple of flights
from la guardia. both of them are on
american and make connections in Chicago
o&apos;hare and los angeles. the first
flight departs at nine thirty A M and
arrives at eight twenty five A M. the
second flight departs at nine thirty A M
and arrives at eight twenty five A M.
Note: The two flights differ only in the second of
three segments of the trip, although the user would
only discover this rather unusual coincidence upon
asking for details about the individual flights. The
difficulty in this case arises because the mechanism
for generation for a very short list of flights has
not yet been subsumed as part of the aggregation
mechanism (described below) which would have au-
tomatically determined that the two flights should
be grouped.
</bodyText>
<listItem confidence="0.971852">
Excerpt 3:
1 SYSTEM: I will book this leg. Do you
want to continue with another leg?
Please say yes or no.
2 JANE: YES I NEED TO CONTINUE BUT I NEED
TO HAVE FLIGHT COMING BACK
3 SYSTEM: Okay, continuing with leg two.
flying from phoenix to newark on what
date?
4 JANE: OKAY THAT WOULD BE FINE JUNE THIRD
5 SYSTEM: what time would you like to
leave on june third?
6 JANE: OF THE TWO O&apos;CLOCK IN THE
AFTERNOON
7 SYSTEM: america west flight 7 74
</listItem>
<bodyText confidence="0.856260428571429">
departs phoenix at one thirty six P
M on Saturday, june third and arrives
in las vegas at two thirty eight P M,
connecting to continental flight 12
62 departing at three fifteen P M and
arriving in newark at ten forty one P M.
Is this flight okay?
</bodyText>
<listItem confidence="0.964150857142857">
8 JANE: NO IS THERE A DIRECT FLIGHT
FROM PHOENIX TO NEWARK I ON JUNE THIRD
ANYTIME TO THIRD
9 SYSTEM: pardon me, what time would you
like to leave?
10 JANE: TIME TEN O&apos;CLOCK IN THE MORNING
11 SYSTEM: i can&apos;t find any nonstop flights
</listItem>
<bodyText confidence="0.924909833333333">
from phoenix to newark on america west
which depart about ten A M on june
third. you may want to try changing the
departure time to seven twenty five A M,
eight fifty nine A M, twelve seventeen P
M, or three oh five P M.
</bodyText>
<sectionHeader confidence="0.964768" genericHeader="method">
4 Deep Generation
</sectionHeader>
<bodyText confidence="0.963540074074074">
In this section we will focus on some tasks han-
dled by our deep generation module, emphasiz-
ing the role of constraint functions as a unifying
theme. Although the notion can be developed more
broadly in various ways, we will consider a con-
straint function here to be a function on a single
data record consisting of information about a par-
ticular flight from one location to another, possibly
making connections. Examples of a constraint func-
tion are: timeDepVal, giving the departure time
of the flight; timeArrClass, giving the class of the
arrival time (before six A.M., between six A.M. and
noon, etc); and connVal giving the list of connec-
tion cities, A constraint on a data record is the
condition that some given constraint function has
a given value,
In a typical turn a user may modify the list of
constraints imposed on the flights under discussion2.
How the system interprets the user input, searches
for flights satisfying the constraints, and decides
what to say about them are all affected by the
shared conversational context between system and
2For brevity, we focus in this section on system response to
user input whose content consists solely of constraints modi-
fications. Processing of other kinds of input such as questions
(e.g. &amp;quot;when does the nine A.M. flight arrive?&amp;quot;) is handled
similarly.
</bodyText>
<page confidence="0.972559">
22
</page>
<listItem confidence="0.975709555555555">
user. Specifically, we have found the following most
useful to keep track of:
1. the constraints the user has imposed on the
flights;
2. what information about the user input con-
straints the system has repeated back to the
user;
3. the flights the system has conveyed information
about to the user; and
</listItem>
<bodyText confidence="0.9194146">
4, the constraints on flights that the system has
discovered and whether those constraints have
been conveyed to the user or can be deduced by
the user.
-
In this section we- focus on two particular cases
that need to be handled by any dialog system in
which the user and system negotiate to find a suit-
able record from a source of data: the under-
constrained case and the over-constrained case.
</bodyText>
<subsectionHeader confidence="0.999495">
4.1 Grouping of Information
</subsectionHeader>
<bodyText confidence="0.9999064">
In this section we discuss how the system decides
what to say in the under-constrained case when there
are many flights satisfying the user request. Exam-
ples of the system response in this case can be found
in (Excerpt 1, Turn 5), (Excerpt 1, Turn 7), arid
Excerpt 2. The following example occurred when a
user requested a departure after 10:00 A.M., after
having previously imposed the constraints of flying
from Chicago to Miami on March third. The system
responded as follows:
</bodyText>
<listItem confidence="0.996642166666667">
(1) there are several flights which depart
after ten A M.
(2) all of them leave from chicago o&apos;hare
and arrive in the afternoon.
(3) do you prefer to fly on american or
united.
</listItem>
<bodyText confidence="0.919091764705882">
Part (1) of the system response summarizes the
most salient constraints of the user input using the
summary script of section 53. Part (2) is a specifi-
cation of the significant information common to all
flights. In part (3), the system has decided which
under-specified constraint is most likely relevant to
the user, grouped the flights according to the values
of the constraints, and prompted the user by speci-
fying the possible values of the constraint.
The significant common information in part (2)
and the most relevant grouping in part (3) are corn-
Some readers may have noticed that, in (Excerpt 1, Turn
5), the system unnecessarily reviewed constraints that have
recently been reviewed. This is because the generation mech-
anism used before enough constraints have been satisfied to
query the data base has not yet been fully unified with the
mechanism discussed in this paper.
</bodyText>
<figure confidence="0.955683833333333">
timeArrClass
depArpVal
ORD
afternoon
complex node ---•- CairVaD
american united
</figure>
<figureCaption confidence="0.999996">
Figure 1: Example of an Aggregation
</figureCaption>
<bodyText confidence="0.977891923076924">
puted by what we call the aggregation algorithm4.
The principal domain dependent data needed by
the algorithm consists of utility functions for each
constraint telling how high a priority it is to go
into detail about that constraint. The output is a
tree structure which represents the hierarchy of con-
straint information that is deemed most useful to
convey to the user.
More specifically, the inputs to the aggregation
algorithm consist of a flat list of data records (e.g.
a table of flights) together with a list of aggrega-
tion specifications. An aggregation specification is
a triple consisting of: (1) a constraint function by
which data may be grouped, (2) a sort function
which orders the groups according to their constraint
value, and (3) a utility function to determine how
useful this grouping is (which may depend both on
conversational context as well as when in the algo-
rithm the grouping is attempted). The utility func-
tions also have the ability to return codes that con-
trol the search for the best tree. For example, a
utility function can declare itself to be the high-
est priority, thus pruning the search. The output
is a tree with non-terminal nodes labeled by lists of
constraint functions, edges labeled by values taken
by the constraint functions labeling the node above,
and terminal vertices labeled by a list of the data,
records satisfying the constraints specified by the la-
belings of all its ancestor nodes and edges.
For the example discussed above, the output of
the aggregation algorithm is depicted in Figure 1.
The top node and the edge below it indicate that
all the flights leave from Chicago O&apos;Hare in the af-
ternoon (i.e. the constraint depArpVal takes on
4 The term &amp;quot;aggregation&amp;quot; is sometimes used within the gen-
eration community referring to a process of combining groups
of linguistically similar phrases. One might say the aggrega-
tion here is occurring on a semantic level, i.e. the internal
representations of the flights are being grouped.
</bodyText>
<table confidence="0.63963">
1) ORD... 1230 ..american
2) ORD... 1420 ...americen
depArp timeArr air
1) ORD... 1310 ...united
2) ORD... 1520 ...united
crepArp timeArT air
simple node
</table>
<page confidence="0.997432">
23
</page>
<bodyText confidence="0.998242291666667">
the SABRE code &amp;quot;ORD&amp;quot; for Chicago O&apos;Hare and
the constraint timeArrClass takes on the value
&amp;quot;morning&amp;quot;). We call this node a simple node be-
cause there is only one edge emanating from it. By
contrast, the node below is a complex node since
the constraint function at that node airVal can
take on more than one value (either &amp;quot;american&amp;quot; or
&amp;quot;united&amp;quot;). The box on the lower left contains those
input flights which are on American Airlines and de-
part from Chicago O&apos;Hare in the morning, and sim-
ilarly for the box on the lower right.
For our application we have found it best to use
the same kind of utility function for all constraints.
When only this type of utility function is used the
behavior of the aggregation algorithm is quite simple
and always plod-aces a tree similar to the one in
Figure 1, naniely-one with two nodes: a simple one
above a complex one. Corresponding to the notion of
simple node and complex node, we call a constraint
function (chosen from the aggregation specification)
simple if it yields the same value when applied to
all of the data records and complex otherwise. The
simplified aggregation algorithm effectively proceeds
as follows:
</bodyText>
<listItem confidence="0.9543584">
(1) For each simple constraint function (whose
value is not known to the user based on the
conversational history) apply a significance test.
Place those constraints functions that pass the
test (if there are any) in the top node of the
tree.
(2) Pick the complex constraint function of maxi-
mum positive utility and place that in the node
below the top. If all utilities are negative, the
node remains empty.
</listItem>
<bodyText confidence="0.999385153846154">
As an example, when depArpVal is a simple con-
straint it is deemed significant if it is not the only
airport serving the departure location the user re-
quested. In our example, since Chicago is served
by both O&apos;Hare and Midway airports, the fact that
all flights land in O&apos;Hare is deemed significant to
tell the user. As our airline travel system develops
we expect to have available more expert knowledge
about the airline travel domain. For example, the
significance test for d.epArpVal may be modified
in the future if&apos; the system has a way of knowing
that Chicago O&apos;Hare is the airport the user would
naturally expect in many circumstances.
</bodyText>
<subsectionHeader confidence="0.600457">
4.2 Relaxation
</subsectionHeader>
<bodyText confidence="0.9619414">
In this section, we consider the over-constrained case
in which no suitable flights can be found that sat-
isfy the user request. One example of the system
response in such a case occurs in (Excerpt 3, line
11). Another example is the following:
(1) there don&apos;t seem to be any nonstop
flights from san francisco to newark
new jersey on united which serve
breakfast and depart after nine A M
on february tenth.
(2) you may want to try changing your
choice of meal, the airline to
continental, or the departure time
to seven oh five A M or eight twenty A
In part (1), the system first reviews detailed in-
formation about what it believes the current user
request is. This is particularly useful to help alert
the user to any previous conversational error. In
part (2), the system suggests possible relaxations
that may be of interest to the user. A relaxation
here is just a change of a single constraint in the
user request which would allow flights to be found.
For example, the system response (2) above indi-
cates that there aro flights on united which satisfy
all of the other user constraints listed in (1) above.
</bodyText>
<sectionHeader confidence="0.982096" genericHeader="method">
5 Surface Generation
</sectionHeader>
<bodyText confidence="0.999975972222222">
There are many approaches to generating text from
an underlying semantic representation. Simple tem-
plates are adequate for many purposes, but result
in a combinatorial explosion in the number of tem-
plates required to produce output for all possible
circumstances. There are also several powerful gen-
eration packages available. One package in partic-
ular that we found it insightful to experiment with
was FUF(Elhadad, 1989), which is short for &amp;quot;Func-
tional Unification Framework&amp;quot;(Elhadad and Robin,
1992). FUF comes available with a reusable gram-
mar of English(Elhadad and Robin, 1996). Al-
though we found the sophisticated linguistic frame-
work of FUF/SURGE difficult to adapt to our needs,
we have found it helpful to include analogues of some
elements of that framework in the approach we now
describe.
After our initial experiments, we decided to
&amp;quot;evolve&amp;quot; a surface generation module starting with
the straight forward model of template filling and
procedure calls provided by the programming lan-
guage tcl. To overcome the problem of combina-
torial explosion in program size, our surface gen-
eration makes use of an exception catching mecha-
nism which allows sub-phrases within a complicated
phrase to be &amp;quot;turned on&amp;quot; if the semantic input re-
quired for them is present. This can be done re-
cursively. This approach has a side benefit of being
very robust because detailed error catching is built
in. Even if the script writer makes an unintentional
error in part of a script (and no alternatives for gen-
erating the information in the erroneous part are
available) only that part will fail to be generated.
Our system makes available to the developer sev-
eral useful domain independent constructs. In addi-
tion to these basic constructs, our surface generation
</bodyText>
<page confidence="0.996704">
24
</page>
<table confidence="0.999248181818182">
[opt-s [DoStops $stops]}] [opt-s {$rtow}] [Noun flight]
[opt-s {from [DoArp $locFrE- ] [opt-s {to [DoArp $locTo]} ]
[opt-s {on CDoAir $airil
[opt-s { which
[NonEmptyConj unct ion [list
[opt-s {[Verb cost] [DoPriceRange $price]).]
[opt-s { [Verb have] flight number $fltNum}]
[opt-s { [Verb serve] Small]
[opt-s {[subst $: :Script(VPDep)]} ]
[opt-s {[subst $ : : Script (VPConnect)]). ]
[opt-s {[subst $: :Script(VPArr)]} II ]
</table>
<figureCaption confidence="0.983105">
Figure 2: Fragment from summarization script (generating text after vertical bar in examples in Table 1).
</figureCaption>
<bodyText confidence="0.995040166666667">
has a morphology module (giving the correct form of
a word based on number, tense, etc.) and a library
of routines for generating simple phrases. To give
the reader a flavor of our approach, we discuss the
example of the script which generates phrases such
as those in Table 1.
</bodyText>
<listItem confidence="0.990915166666667">
1. There are I several flights.
2. I can&apos;t find any I roundtrip flights from New
York to Chicago.
3. There don&apos;t seem to be any I nonstop flights
which serve breakfast and make a connection in
Dallas.
4. There is only one I flight on American which de-
parts between six pm and nine p m on February
second and arrives in the morning on February
third.
5. 1 see quite a few I flights which cost less than
$1000 and arrive in the morning.
</listItem>
<tableCaption confidence="0.73364475">
Table 1: Sample output from summarization script.
(The vertical bar has been added to demarcate the
separation between parts generated by separate sub-
scripts.)
</tableCaption>
<bodyText confidence="0.999666724137931">
Phrases such as the ones above are generated by
surface generation when it is asked by deep genera-
tion to summarize some of the constraints on what
kind of flight the user is looking for and the approx-
imate number of flights found. The script fragment
in Figure 2 generates phrases like the ones after the
vertical bar in the above examples. Variables such as
locPr, dateDep, and air correspond to user spec-
ified constraints on departure location, departure
date, airline, and so on. Only those variables will
be set which deep generation has decided should be
summarized. Since there are thirteen variables re-
ferred to in the short script below and the (even
shorter) subscripts it refers to, they are capable of
generating 213 different kinds of phrases expressing
the desired content. It is perhaps a fortunate prop-
erty of the airline travel domain we are restricting to
that this approach allows fairly simple scripts to be
used in circumstances where an inordinate number
of templates would have been required.
We offer a few words of explanation of the script in
Figure 2. First, the &amp;quot;morphology&amp;quot; procedure Verb
provides the appropriate morphological form of a
verb (depending on the current setting of number,
tense, etc.). The procedure subst is used for ex-
panding the subscripts referred to. The procedures
DoAir, DoArp DoPriceRange, and DoStops
are from the &amp;quot;phrase library&amp;quot;. They generate ap-
propriate phrases associated with an airline, an air-
port, a price range, or whether or not a flight is
nonstop. One may think of these as rules for con-
verting the semantic information, previously deter-
mined by deep generation and stored in variables
such as air and price, into a surface realization. For
example, &amp;quot;CDoAir $airl&amp;quot; returns &amp;quot;American&amp;quot; and
&amp;quot;[DoPrice $Price]&amp;quot; returns &amp;quot;less than $1000&amp;quot;,
The construct opt-s (short for optional
substitution) includes the text generated by
expanding its argument if that expansion is suc-
cessful, or else catches and ignores any errors if
the expansion was not successful. The construct
NonEmptyConjunction is used to adjoin a list
of phrases. (The separators between phrases are
optional arguments.) If the input list is empty,
however, an error is generated. In such a case (e.g.
examples 1 and 2 above), the error is caught by
the enclosing opt-s, so the entire &amp;quot;which&amp;quot; clause is
omitted.
Another example of a construct is SayOnce. This
is used when generating a list of phrases, so that
a particular script fragment will only be expanded
and included the first time it is encountered. For
example, SayOnce has been used to omit the sec-
ond occurrence of the word &amp;quot;departing&amp;quot; in (Excerpt
1, Turn 7). Similarly, in the following response to
a user query about the arrival times of the flights
under discussion, the second occurrence of the word
&amp;quot;flights&amp;quot; has been omitted by a simple application
</bodyText>
<page confidence="0.993475">
25
</page>
<bodyText confidence="0.8901146">
of SayOnce:
i see at least 3 flights which arrive
between two P M and six P M, and 4
which arrive between six P N and ten P
M.
</bodyText>
<sectionHeader confidence="0.993558" genericHeader="conclusions">
6 Conclusion
</sectionHeader>
<bodyText confidence="0.999993170731707">
In developing our deep and surface generation mod-
ules we have followed a strategy of starting with a
simple approach and adding basic building blocks as
they are warranted, for example the generation con-
structs described in section 5 and the utility func-
tions of sections 4.1. This strategy has helped us
develop generation modules which are flexible, ro-
bust, and interact well with the other components
of our system. Also, the tools presented here tend
to reduce the growth in code size with complexity (as
measured by the number of possible constraints).
We are optimistic that these methods can be ap-
plied to other domains, although certainly additional
features would have to be added. For instance, in
Excerpt 2, we gave an example of a shortcoming
of our system that arose when we summarized de-
tails about a very short list of flights. This problem
could be fixed either by subsuming the case of a
very short list of flights into the general aggregation
mechanism or by adding an additional mechanism
to handle this separate case better. Since the prob-
lem seemed insignificant enough in the airline travel
domain we have not yet resolved it, but we expect
that experience with other domains will dictate the
best approach.
We consider it to be an advantage of this ap-
proach that it is not tied to a particular linguis-
tic framework and affords rather straight forward
development. This certainly seems appropriate for
our application so far, where the summary script of
Figure 2 represents the typical level of complexity
of the scripts we have had to develop. It is pos-
sible that this could become a limiting factor as
the complexity, scope, and variety of domains in-
creases. However, we expect other limitations to be-
come more pressing. For example, we plan to inves-
tigate additional building blocks which will be useful
as we begin to delve into issues such as improving
our help messages or adding emphasis to particular
parts of the information we want to convey, either
via prosody or more finely crafted text.
</bodyText>
<sectionHeader confidence="0.962059" genericHeader="acknowledgments">
Acknowledgements
</sectionHeader>
<bodyText confidence="0.9260834">
The author would like to thank Mark Epstein,
Adwait Ratnaparhki, Salim Roukos, Kishore Pap-
ineni, and Todd Ward for helpful discussions. This
work was supported in part by DARPA contract #
MDA972-97-C-0012.
</bodyText>
<sectionHeader confidence="0.975214" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999769909090909">
K. Biatov, E. Bocchieri, G. Di Frabbrizio, C. Kahni,
E. Levin, S. Narayanan, A. Pokrovsky, P. Ruscitti,
M. Rahim, and L. Walker. 2000. Spoken dialog
systems: Some case studies from AT&amp;T. In Pre-
sentation at DARPA Communicator Workshop,
Charleston, SC, Jan. 2000. See http://www.dsic-
web.net:8501/pub/comm_2000jan/ATT-
Narayanan.pdf for presentation and
http;//www.dsic-web .net/ito/meetings/
communicator.jan00/agenda.htrn1 for conference
agenda.
Michael Elhadad and Jacques Robin. 1992. Control-
ling content realization with functional unification
grammars. In Aspects of Automated Natural Lan-
guage Generation, Lecture Notes in Artificial In-
telligence, 587, pages 89-104. Springer, Berlin.
Michael Elhadad and Jacques Robin. 1996. An
overview of SURGE: A re-usable comprehensive
syntactic realization component. In Proceedings of
the 8th International Workshop on Natural Lan-
guage Generation, Beer Sheva, Israel.
Michael Elhadad. 1989. FUF: The universal uni-
fier user manual. Technical report, Department
of Computer Science, Columbia University. URL
= http://www.cs.ligu.acillsurge/index.htm,
K. A. Papineni, S. Roukos, and R. T. Ward. 1999.
Free-flow dialog management using forms. In Pro-
ceedings of Eurospeech-99, pages 1411-1414, Sept.
1999,
AL Ruclnicky, E. Thayer, P. Constantinides,
C. Tchou, R. Shern, K. Lenzo, W. Xu, and A. Oh.
1999. Creating natural dialogs in the Carnegie
Mellon Communicator system. In Proceedings of
Eurospeech- 1999, pages 931-934, Budapest, Hun-
gary, Sept. 1999.
S. Seneff, E. Hurley, R. Lau, C. Pao, P. Schmid, and
V. Zue. 1998. Galaxy-II: A reference architecture
for conversational system development. In Pro-
ceedings of ICSLP-1998, pages 1153-1156, Syd-
ney, Australia, Nov. 30—Dec. 4, 1998.
Wayne Ward and Bryan Pellom. 1999. The CU
Communicator system. In .1999 IEEE Work-
shop on Automatic Speech Recognition and Un-
derstanding, Keystone Colorado, Dec. 1999.
</reference>
<page confidence="0.998058">
26
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.330247">
<title confidence="0.99925">Natural Language Generation in the IBM Flight Information System</title>
<author confidence="0.965558">Scott</author>
<affiliation confidence="0.718592">IBM T.J. Watson Research</affiliation>
<author confidence="0.805062">P O Box</author>
<affiliation confidence="0.691449">Yorktown Heights, NY</affiliation>
<email confidence="0.998877">axelrod@us.ibm.com</email>
<abstract confidence="0.9886205">The IBM flight information system is a speech based conversational stem which allows users to create multi-leg airline travel itineraries based on live flight availability information. We discuss here the components of the system relating to natural language generation, The deep generation component of the system decides what to say based on information shared with the user about constraints on flights. The surface generation component generates text based on a simple error catching mechanism and a few basic &amp;quot;generation constructs&amp;quot;.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="false">
<authors>
<author>K Biatov</author>
<author>E Bocchieri</author>
<author>G Di Frabbrizio</author>
<author>C Kahni</author>
<author>E Levin</author>
<author>S Narayanan</author>
<author>A Pokrovsky</author>
<author>P Ruscitti</author>
<author>M Rahim</author>
<author>L Walker</author>
</authors>
<title>Spoken dialog systems: Some case studies from AT&amp;T.</title>
<date>2000</date>
<booktitle>In Presentation at DARPA Communicator Workshop,</booktitle>
<location>Charleston, SC,</location>
<marker>Biatov, Bocchieri, Di Frabbrizio, Kahni, Levin, Narayanan, Pokrovsky, Ruscitti, Rahim, Walker, 2000</marker>
<rawString>K. Biatov, E. Bocchieri, G. Di Frabbrizio, C. Kahni, E. Levin, S. Narayanan, A. Pokrovsky, P. Ruscitti, M. Rahim, and L. Walker. 2000. Spoken dialog systems: Some case studies from AT&amp;T. In Presentation at DARPA Communicator Workshop, Charleston, SC, Jan. 2000. See http://www.dsicweb.net:8501/pub/comm_2000jan/ATTNarayanan.pdf for presentation and http;//www.dsic-web .net/ito/meetings/ communicator.jan00/agenda.htrn1 for conference agenda.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Michael Elhadad</author>
<author>Jacques Robin</author>
</authors>
<title>Controlling content realization with functional unification grammars.</title>
<date>1992</date>
<journal>In Aspects of Automated Natural Language Generation, Lecture Notes in Artificial Intelligence,</journal>
<volume>587</volume>
<pages>89--104</pages>
<publisher>Springer,</publisher>
<location>Berlin.</location>
<contexts>
<context position="16524" citStr="Elhadad and Robin, 1992" startWordPosition="2835" endWordPosition="2838">hat there aro flights on united which satisfy all of the other user constraints listed in (1) above. 5 Surface Generation There are many approaches to generating text from an underlying semantic representation. Simple templates are adequate for many purposes, but result in a combinatorial explosion in the number of templates required to produce output for all possible circumstances. There are also several powerful generation packages available. One package in particular that we found it insightful to experiment with was FUF(Elhadad, 1989), which is short for &amp;quot;Functional Unification Framework&amp;quot;(Elhadad and Robin, 1992). FUF comes available with a reusable grammar of English(Elhadad and Robin, 1996). Although we found the sophisticated linguistic framework of FUF/SURGE difficult to adapt to our needs, we have found it helpful to include analogues of some elements of that framework in the approach we now describe. After our initial experiments, we decided to &amp;quot;evolve&amp;quot; a surface generation module starting with the straight forward model of template filling and procedure calls provided by the programming language tcl. To overcome the problem of combinatorial explosion in program size, our surface generation make</context>
</contexts>
<marker>Elhadad, Robin, 1992</marker>
<rawString>Michael Elhadad and Jacques Robin. 1992. Controlling content realization with functional unification grammars. In Aspects of Automated Natural Language Generation, Lecture Notes in Artificial Intelligence, 587, pages 89-104. Springer, Berlin.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Michael Elhadad</author>
<author>Jacques Robin</author>
</authors>
<title>An overview of SURGE: A re-usable comprehensive syntactic realization component.</title>
<date>1996</date>
<booktitle>In Proceedings of the 8th International Workshop on Natural Language Generation, Beer Sheva,</booktitle>
<contexts>
<context position="16605" citStr="Elhadad and Robin, 1996" startWordPosition="2848" endWordPosition="2851">isted in (1) above. 5 Surface Generation There are many approaches to generating text from an underlying semantic representation. Simple templates are adequate for many purposes, but result in a combinatorial explosion in the number of templates required to produce output for all possible circumstances. There are also several powerful generation packages available. One package in particular that we found it insightful to experiment with was FUF(Elhadad, 1989), which is short for &amp;quot;Functional Unification Framework&amp;quot;(Elhadad and Robin, 1992). FUF comes available with a reusable grammar of English(Elhadad and Robin, 1996). Although we found the sophisticated linguistic framework of FUF/SURGE difficult to adapt to our needs, we have found it helpful to include analogues of some elements of that framework in the approach we now describe. After our initial experiments, we decided to &amp;quot;evolve&amp;quot; a surface generation module starting with the straight forward model of template filling and procedure calls provided by the programming language tcl. To overcome the problem of combinatorial explosion in program size, our surface generation makes use of an exception catching mechanism which allows sub-phrases within a compli</context>
</contexts>
<marker>Elhadad, Robin, 1996</marker>
<rawString>Michael Elhadad and Jacques Robin. 1996. An overview of SURGE: A re-usable comprehensive syntactic realization component. In Proceedings of the 8th International Workshop on Natural Language Generation, Beer Sheva, Israel.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Michael Elhadad</author>
</authors>
<title>FUF: The universal unifier user manual.</title>
<date>1989</date>
<tech>Technical report,</tech>
<institution>Department of Computer Science, Columbia University.</institution>
<note>URL = http://www.cs.ligu.acillsurge/index.htm,</note>
<contexts>
<context position="16444" citStr="Elhadad, 1989" startWordPosition="2826" endWordPosition="2827">ts to be found. For example, the system response (2) above indicates that there aro flights on united which satisfy all of the other user constraints listed in (1) above. 5 Surface Generation There are many approaches to generating text from an underlying semantic representation. Simple templates are adequate for many purposes, but result in a combinatorial explosion in the number of templates required to produce output for all possible circumstances. There are also several powerful generation packages available. One package in particular that we found it insightful to experiment with was FUF(Elhadad, 1989), which is short for &amp;quot;Functional Unification Framework&amp;quot;(Elhadad and Robin, 1992). FUF comes available with a reusable grammar of English(Elhadad and Robin, 1996). Although we found the sophisticated linguistic framework of FUF/SURGE difficult to adapt to our needs, we have found it helpful to include analogues of some elements of that framework in the approach we now describe. After our initial experiments, we decided to &amp;quot;evolve&amp;quot; a surface generation module starting with the straight forward model of template filling and procedure calls provided by the programming language tcl. To overcome the</context>
</contexts>
<marker>Elhadad, 1989</marker>
<rawString>Michael Elhadad. 1989. FUF: The universal unifier user manual. Technical report, Department of Computer Science, Columbia University. URL = http://www.cs.ligu.acillsurge/index.htm,</rawString>
</citation>
<citation valid="true">
<authors>
<author>K A Papineni</author>
<author>S Roukos</author>
<author>R T Ward</author>
</authors>
<title>Free-flow dialog management using forms.</title>
<date>1999</date>
<booktitle>In Proceedings of Eurospeech-99,</booktitle>
<pages>1411--1414</pages>
<contexts>
<context position="2124" citStr="Papineni et al., 1999" startWordPosition="331" endWordPosition="334">olving architectural standard of the DARPA Communicator projectt participated in by several sites including MIT (Seneff et al., 1998), CMU (Rudnicky et al., 1999), University of Colorado (Ward and Pellom, 1999), and AT&amp;T (Biatov et al., 2000). The system obtains flight data by connecting to the SABRE computer reservation system used by many travel agents. Dialog management is based on the form-based dialog manager For a description of the Communicator program and documentation of the architecture see httpl /www ,darpa.milf ito/researchIcom/index.html and http://fofoca.mitre.org. described in (Papineni et al., 1999). The form based dialog manager generates messages to the user under the circumstance when the user has not yet specified enough constraints to allow for a SABRE query. After that point, the generation components discussed in this paper apply. The deep generation module passes its decision about what to say to the surface generation module in the form of a high level list of what kinds of things to say. The details are passed in the contents of the frame of information which is shared between the servers. Both components of the generation module place information in the frame to provide feedba</context>
</contexts>
<marker>Papineni, Roukos, Ward, 1999</marker>
<rawString>K. A. Papineni, S. Roukos, and R. T. Ward. 1999. Free-flow dialog management using forms. In Proceedings of Eurospeech-99, pages 1411-1414, Sept. 1999,</rawString>
</citation>
<citation valid="true">
<authors>
<author>AL Ruclnicky</author>
<author>E Thayer</author>
<author>P Constantinides</author>
<author>C Tchou</author>
<author>R Shern</author>
<author>K Lenzo</author>
<author>W Xu</author>
<author>A Oh</author>
</authors>
<title>Creating natural dialogs in the Carnegie Mellon Communicator system.</title>
<date>1999</date>
<booktitle>In Proceedings of Eurospeech-</booktitle>
<pages>931--934</pages>
<location>Budapest, Hungary,</location>
<marker>Ruclnicky, Thayer, Constantinides, Tchou, Shern, Lenzo, Xu, Oh, 1999</marker>
<rawString>AL Ruclnicky, E. Thayer, P. Constantinides, C. Tchou, R. Shern, K. Lenzo, W. Xu, and A. Oh. 1999. Creating natural dialogs in the Carnegie Mellon Communicator system. In Proceedings of Eurospeech- 1999, pages 931-934, Budapest, Hungary, Sept. 1999.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S Seneff</author>
<author>E Hurley</author>
<author>R Lau</author>
<author>C Pao</author>
<author>P Schmid</author>
<author>V Zue</author>
</authors>
<title>Galaxy-II: A reference architecture for conversational system development.</title>
<date>1998</date>
<booktitle>In Proceedings of ICSLP-1998,</booktitle>
<volume>30</volume>
<pages>1153--1156</pages>
<location>Sydney, Australia,</location>
<contexts>
<context position="1635" citStr="Seneff et al., 1998" startWordPosition="257" endWordPosition="260">nts. Although the focus here is on the airline travel domain, our techniques should apply to many domains where the system helps the user find some data obeying suitable constraints. We consider here both the problem of deep generation (deciding what information to say) and surface generation (deciding how to say the information in spoken language). 2 Architecture The system has a central hub that passes a frame of information around a loop of servers. It runs compatibly with the evolving architectural standard of the DARPA Communicator projectt participated in by several sites including MIT (Seneff et al., 1998), CMU (Rudnicky et al., 1999), University of Colorado (Ward and Pellom, 1999), and AT&amp;T (Biatov et al., 2000). The system obtains flight data by connecting to the SABRE computer reservation system used by many travel agents. Dialog management is based on the form-based dialog manager For a description of the Communicator program and documentation of the architecture see httpl /www ,darpa.milf ito/researchIcom/index.html and http://fofoca.mitre.org. described in (Papineni et al., 1999). The form based dialog manager generates messages to the user under the circumstance when the user has not yet</context>
</contexts>
<marker>Seneff, Hurley, Lau, Pao, Schmid, Zue, 1998</marker>
<rawString>S. Seneff, E. Hurley, R. Lau, C. Pao, P. Schmid, and V. Zue. 1998. Galaxy-II: A reference architecture for conversational system development. In Proceedings of ICSLP-1998, pages 1153-1156, Sydney, Australia, Nov. 30—Dec. 4, 1998.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Wayne Ward</author>
<author>Bryan Pellom</author>
</authors>
<title>The CU Communicator system.</title>
<date>1999</date>
<booktitle>In .1999 IEEE Workshop on Automatic Speech Recognition and Understanding,</booktitle>
<location>Keystone Colorado,</location>
<contexts>
<context position="1712" citStr="Ward and Pellom, 1999" startWordPosition="270" endWordPosition="273">s should apply to many domains where the system helps the user find some data obeying suitable constraints. We consider here both the problem of deep generation (deciding what information to say) and surface generation (deciding how to say the information in spoken language). 2 Architecture The system has a central hub that passes a frame of information around a loop of servers. It runs compatibly with the evolving architectural standard of the DARPA Communicator projectt participated in by several sites including MIT (Seneff et al., 1998), CMU (Rudnicky et al., 1999), University of Colorado (Ward and Pellom, 1999), and AT&amp;T (Biatov et al., 2000). The system obtains flight data by connecting to the SABRE computer reservation system used by many travel agents. Dialog management is based on the form-based dialog manager For a description of the Communicator program and documentation of the architecture see httpl /www ,darpa.milf ito/researchIcom/index.html and http://fofoca.mitre.org. described in (Papineni et al., 1999). The form based dialog manager generates messages to the user under the circumstance when the user has not yet specified enough constraints to allow for a SABRE query. After that point, t</context>
</contexts>
<marker>Ward, Pellom, 1999</marker>
<rawString>Wayne Ward and Bryan Pellom. 1999. The CU Communicator system. In .1999 IEEE Workshop on Automatic Speech Recognition and Understanding, Keystone Colorado, Dec. 1999.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>