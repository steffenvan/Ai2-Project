<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.004960">
<note confidence="0.840398">
Proceedings of EACL &apos;99
</note>
<title confidence="0.950328">
The Treegram Index—An Efficient Technique for Retrieval in
Linguistic Treebanks
</title>
<author confidence="0.811326">
Hans Argenton and Anke Feldhaus
</author>
<bodyText confidence="0.957055245614035">
Infineon Technologies, DAT CIF, Postbox 801709, D-81617 München
hans.argenton@infineon.com
University of Tubingen, SfS, Kleine Wilhelmstr.113, D-72074 Tubingen
feldhausOsfs.nphil.uni-tuebingen.de
Multiway trees (MT, henceforth) are a
common and well-understood data struc-
ture for describing hierarchical linguistic
information. With the availability of large
treebanks, retrieval techniques for highly
structured data now become essential. In
this contribution, we investigate the effi-
cient retrieval of MT structures at the cost
of a complex index—the Treegrarn Index.
We illustrate our approach with the
VENONA retrieval system, which han-
dles the BHt (Biblia Hebraica transcripta)
treebank comprising 508,650 phrase struc-
ture trees with maximum degree eight and
maximum height 17, containing altogether
3.3 million Old-Hebrew words.
1 Multiway-tree retrieval based on
treegrams
The base entities of the tree-retrieval
problem for positional MTs are (labeled)
rooted .MTs where children are distin-
guished by their position.
Let s and t be two MTs; t contains s
(written as s t) if there exists an in-
jective embedding such that (1) nodes are
mapped to nodes with identical labels and
(2) a root of a child with position i is
mapped to a root of a child with the same
position.
Retrieval problem: Let DB be a set
of labeled positional MTs and let q be a
query tree having the same label alphabet.
The problem is to find efficiently all trees
t E DB that contain q.
To cope with this tree-retrieval problem,
we generalize the well-known n-gram in-
dexing technique for text databases: In
place of substrings with fixed length, we
use subtrees with fixed maximal height—
treegrams.
Let TG(t,h) denote the set of all tree-
grams of height h contained in the MT
t, and let T(DB, g) denote the set of all
database trees that contain the treegram
g. Assume that g has the height h and
that T(DB, g) can be efficiently computed
using the index relation &apos;DB := {(g, Olt E
DB A g E TG(t, h)}, which lists for each
treegram g of height h every database tree
that contains g. We compute the desired
result set R = ft E DBlq t} for a given
query tree q such that q&apos;s height is greater
than or equal h as follows:
</bodyText>
<listItem confidence="0.9774932">
Retrieval method:
(1) Compute the set TG(q, h): All tree-
grams of height h contained in the
query.
(2) Compute the candidate set of q
Candh(q) := ngETG(q,h) T(DB, g).
The set of all database trees that con-
tain every query treegram.
(3) Compute the result set R = ft E
Candh(q)lq tl.
</listItem>
<bodyText confidence="0.996940666666667">
The costly operation in this approach is
the last containment test q t. The build-
ing of index &apos;DB is justified if in general the
</bodyText>
<page confidence="0.981842">
267
</page>
<bodyText confidence="0.841034142857143">
Proceedings of EACL &apos;99
number of candidates will be much smaller
than the number of trees in DB.
2 Efficient query evaluation
The treegram-index retrieval method given
above encounters the following interesting
problems:
</bodyText>
<listItem confidence="0.749300583333333">
(A) A single treegram may be very com-
plex because of its unlimited degree
and label strings; this leads to costly
look-up operations.
(B) There are many treegrams rooting at
a given node in a database tree: To
accomodate queries with subtree vari-
ables, the index has to contain all
matching treegrams for that subtree.
(C) It is quite expensive to intersect the
tree sets T(DB, g) for all treegrams g
contained in the query q.
</listItem>
<bodyText confidence="0.9838505">
VENONA addresses these problems by the
following approach:
</bodyText>
<subsubsectionHeader confidence="0.75124">
Problem A: Processing of a single tree-
</subsubsectionHeader>
<bodyText confidence="0.997943419354839">
gram: (1) Node labels hash to an integer
of a few bytes: We do not consider labels
structured; to model the structure of word
forms, feature terms should be used&apos;. (2)
VENONA deals only with treegrams of a
maximal degree d; if a tree is of greater
degree, it will be transformed automati-
cally to a d-ary tree.2 (3) For describing
a single treegram g, VENONA takes each
of g&apos;s hashed labels and combines it with
the position of its corresponding node in
a complete d-ary tree; an integer encod-
ing g&apos;s structure completes this represen-
tation: Structure is at least as essential for
tree retrieval as label information.
&apos;Due to lack of space, we cannot present our ex-
tension of treegram indexing to feature terms in this
abstract.
&apos;The employed algorithm is a generalization of the
well-known transformation of trees to binary trees.
d&apos;s value is a configurable parameter of the index-
generation.
Problem B VENONA uses only one tree-
gram per node v: the treegram includ-
ing every node found on the first h lev-
els of the subtree rooted in v. This ap-
proach keeps the index small but intro-
duces another problem: A query treegram
may not appear in the treegram index as it
is. Therefore, VENONA expands all query
treegram structures at runtime; for a given
query treegram g, this expansion yields all
database treegrams with a structure com-
patible to g. That approach keeps the tree-
gram index small and preserves efficiency.
Problem C The evaluation of a given
query q is processed along the following
steps: (1) According to q&apos;s degree and
height, VENONA chooses a treegram in-
dex among those available for the tree
database. (2) VENONA collects q&apos;s tree-
grams and represents them by sets of tree-
gram parts. For a given query treegram,
VENONA expands the structure number to
a set of index treegram structures and re-
moves those labels that consist of a vari-
able: Variables and the constraints that
they impose belong to the matching phase.
(3) VENONA sorts q&apos;s treegrams according
to their selectivity by estimating a tree-
gram&apos;s selectivity based on the selectivity
of its treegram parts. (4) VENONA esti-
mates how many query treegrams it has
to evaluate to yield a candidate set small
enough for the tree matcher; only for those
it determines the corresponding index tree-
grams. (5) VENONA processes these se-
lected treegrams until the candidate set
has the desired size—if necessary, falling
back on some of the treegrams put aside.
(6) Finally, the tree matcher selects the an-
swer trees from these candidates.
</bodyText>
<page confidence="0.995555">
268
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.147314">
<note confidence="0.808257">Proceedings of EACL &apos;99</note>
<title confidence="0.9916945">The Treegram Index—An Efficient Technique for Retrieval in Linguistic Treebanks</title>
<author confidence="0.709241">Hans Argenton</author>
<author confidence="0.709241">Anke Feldhaus</author>
<affiliation confidence="0.497661">Infineon Technologies, DAT CIF, Postbox 801709, D-81617 München</affiliation>
<email confidence="0.983281">hans.argenton@infineon.com</email>
<affiliation confidence="0.62086">University of Tubingen, SfS, Kleine Wilhelmstr.113, D-72074 Tubingen</affiliation>
<email confidence="0.783909">feldhausOsfs.nphil.uni-tuebingen.de</email>
<abstract confidence="0.99924342384106">Multiway trees (MT, henceforth) are a common and well-understood data structure for describing hierarchical linguistic information. With the availability of large treebanks, retrieval techniques for highly structured data now become essential. In this contribution, we investigate the efficient retrieval of MT structures at the cost a complex index—the Index. We illustrate our approach with the VENONA retrieval system, which hanthe (Biblia Hebraica transcripta) treebank comprising 508,650 phrase structure trees with maximum degree eight and maximum height 17, containing altogether 3.3 million Old-Hebrew words. 1 Multiway-tree retrieval based on treegrams The base entities of the tree-retrieval problem for positional MTs are (labeled) rooted .MTs where children are distinguished by their position. t be two MTs; contains s as t) there exists an jective embedding such that (1) nodes are mapped to nodes with identical labels and (2) a root of a child with position i is mapped to a root of a child with the same position. Retrieval problem: Let DB be a set labeled positional MTs and let a query tree having the same label alphabet. The problem is to find efficiently all trees that contain To cope with this tree-retrieval problem, we generalize the well-known n-gram indexing technique for text databases: In place of substrings with fixed length, we use subtrees with fixed maximal height— treegrams. Let TG(t,h) denote the set of all treeof height in the MT let T(DB, the set of all database trees that contain the treegram that the height T(DB, be efficiently computed the index relation := lists for each height database tree contains compute the desired set = E t} for a given tree that q&apos;s height is greater or equal follows: Retrieval method: Compute the set TG(q, treeof height in the query. Compute the set q := The set of all database trees that contain every query treegram. Compute the set R = ft tl. The costly operation in this approach is last containment test t. buildof index justified if in general the 267 Proceedings of EACL &apos;99 number of candidates will be much smaller than the number of trees in DB. 2 Efficient query evaluation The treegram-index retrieval method given above encounters the following interesting problems: (A) A single treegram may be very complex because of its unlimited degree and label strings; this leads to costly look-up operations. (B) There are many treegrams rooting at a given node in a database tree: To accomodate queries with subtree variables, the index has to contain all matching treegrams for that subtree. (C) It is quite expensive to intersect the sets all treegrams in the query these problems by the following approach: A: of a single tree- (1) labels hash to an integer of a few bytes: We do not consider labels structured; to model the structure of word forms, feature terms should be used&apos;. (2) VENONA deals only with treegrams of a degree a tree is of greater degree, it will be transformed automatito a d-ary (3) For describing single treegram each of g&apos;s hashed labels and combines it with the position of its corresponding node in a complete d-ary tree; an integer encoding g&apos;s structure completes this representation: Structure is at least as essential for tree retrieval as label information. &apos;Due to lack of space, we cannot present our extension of treegram indexing to feature terms in this abstract. &apos;The employed algorithm is a generalization of the well-known transformation of trees to binary trees. d&apos;s value is a configurable parameter of the indexgeneration. B uses only one treegram per node v: the treegram includfound on the first levels of the subtree rooted in v. This approach keeps the index small but introduces another problem: A query treegram may not appear in the treegram index as it is. Therefore, VENONA expands all query runtime; for a given treegram expansion yields all database treegrams with a structure comto approach keeps the treegram index small and preserves efficiency. C evaluation of a given processed along the following steps: (1) According to q&apos;s degree and height, VENONA chooses a treegram index among those available for the tree database. (2) VENONA collects q&apos;s treegrams and represents them by sets of treegram parts. For a given query treegram, VENONA expands the structure number to a set of index treegram structures and removes those labels that consist of a variable: Variables and the constraints that they impose belong to the matching phase. q&apos;s treegrams according to their selectivity by estimating a treegram&apos;s selectivity based on the selectivity of its treegram parts. (4) VENONA estimates how many query treegrams it has to evaluate to yield a candidate set small enough for the tree matcher; only for those it determines the corresponding index treethese seuntil the candidate has the desired size—if necessary, falling back on some of the treegrams put aside. (6) Finally, the tree matcher selects the answer trees from these candidates.</abstract>
<intro confidence="0.781422">268</intro>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
</citationList>
</algorithm>
</algorithms>