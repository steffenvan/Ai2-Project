<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000065">
<note confidence="0.780871">
ON THE GENERATIVE POWER OF TWO-LEVEL MORPHOLOGICAL RULES
</note>
<author confidence="0.489301">
Graeme Ritchie
</author>
<affiliation confidence="0.9934045">
Department of Artificial Intelligence
University of Edinburgh
</affiliation>
<address confidence="0.828170333333333">
80 South Bridge
Edinburgh EH1 1HN
Scotland
</address>
<email confidence="0.512993">
ABSTRACT
</email>
<bodyText confidence="0.99975775">
Koskenniemi&apos;s model of two-level morphology
has been very influential in recent years, but
definitions of the formalism have generally been
phrased in terms of a compilation (sometimes
left unspecified) into a form of finite-state trans-
ducers, or else have consisted of an informal
outline of the intended interpretation of the
rule-formalism itself. Analyses of the properties
of the formalism have generally focussed on the
transducer mechanism. It is, however, possible
to give a fully formal definition of the original
rule notation directly, in a way which reflects
Koskenniemi&apos;s original informal characterisation
and which does not depend directly on the
notion of a transducer (although it must retain
the essential nature of parts of the notation as
being regular expressions). This re-formulation
allows a proof that the ability of this formalism
to characterise mappings between strings is
more limited than that of arbitrary transducers.
</bodyText>
<sectionHeader confidence="0.78349" genericHeader="background">
BACKGROUND
</sectionHeader>
<bodyText confidence="0.9934155">
Koskenniemi(1983a,b;1984) proposed a
rule-system for describing morphological regu-
larities in a language, depending centrally on the
idea of matching two sequences of symbols - a
lexical string (made up of the lexical forms of
morphemes) and a surface string (the sequence
of characters in the normal, inflected, form of
the word). In principle, symbols could be
orthographic or phonological; here we shall fol-
low common practice within two-level morphol-
ogy, and assume orthographic forms are being
analysed. Koskenniemi(1983a) originally
described the rules in two alternative forms -
high-level rules and finite-state transducers, and
conjectured that an automatic compilation pro-
cedure could be devised to transform the more
readable, high-level form into the more directly
implementable transducer form. His implemen-
tation was an interpreter for the transducers,
which were directly written by the linguist as
rules in their own right. The various linguistic
analyses presented in Dalrymple et al.(1983)
also follow this approach, expressing rules as
transition tables for transducers. Kosken-
niemi(1985) refined the notation and sketched a
compilation method, and Ritchie, Black et
al.(1987), Karttunen et al.(1987) describe com-
pilation techniques for two variants of the nota-
tion.
The aim of this paper is to give an alter-
native statement of the meaning of the original
high-level rule notation, without recourse to
compilation into finite-state transducers. The
benefits of this are twofold:
(i) alternative implementation techniques can
be considered or discussed with reference
to a standard interpretation which is not
tied to an existing approach to implemen-
tation;
(ii) the formal properties of the actual rule-
formalism can be assessed, rather than the
formal properties of another formalism
(transducers) which might in principle be
more powerful.
In particular, it is possible to show that the
two-level morphological mechanism is more
limited than the transducer model in its ability
to define relationships between strings.
</bodyText>
<sectionHeader confidence="0.995177" genericHeader="method">
THE FORMALISM
TWO-LEVEL NOTATION
</sectionHeader>
<bodyText confidence="0.897584545454545">
The original notation proposed in
Koskenniemi(1983a) included some rather com-
plex notational conventions which have not sur-
vived into later versions. The formalisation
given here will deal only with the core ideas, as
embodied in Koskenniemi(1985) (and other
implementations such as ICarttunen et al.(1987),
- 51 -
Ritchie, Black, et al.(1987)). By way of illus-
tration, here is a two-level morphological rule
taken from Ritchie, Pulman et al. (1987):
</bodyText>
<equation confidence="0.98031">
e:0 &lt;=&gt; =:C2 &lt;+:0 V:=&gt;
or &lt; C:C V:V&gt; &lt;+:0 e:e&gt;
or (g:g c:c) &lt;+:0 (e:e i:i) &gt;
or 1:0 +:0
or c:c &lt;+:0 a:0 t:t&gt;
</equation>
<bodyText confidence="0.987720913043479">
Rules are phrased in terms of symbol-pairs
(written with an infix colon), where the first in
the pair is a lexical symbol and the second is a
surface symbol. In the above example, the pair
of symbols on the left (lexical &amp;quot;e&amp;quot; and surface
null) are allowed to occur only in the contexts
listed on the right of the rule, where &amp;quot; &amp;quot; indi-
cates the position of the pair &amp;quot;e:0&amp;quot;. Each context
has a left part and a right part, each of these
being essentially a regular expression over
symbol-pairs, where angle brackets indicate
sequences of pairs and braces indicate alterna-
tives (disjunction). Certain versions of the nota-
tion may also allow the &amp;quot;Kleene star&amp;quot; symbol
&amp;quot;*&amp;quot; to indicate zero or more repetitions, and the
insertion of optional elements. In this example,
&amp;quot;C&amp;quot;, &amp;quot;V&amp;quot;, &amp;quot;C2&amp;quot;, and &amp;quot;=&amp;quot; represent subsets of the
relevant symbol alphabets and &amp;quot;+&amp;quot; is an abstract
symbol occurring in certain lexical forms.
The formalism here will not include sym-
bolic mnemonics for sets of symbols, nor vari-
ables ranging over sets of symbols. The seman-
tics of both these notations (which are com-
monly used in two-level morphology) can be
stated in terms of equivalent sets of rules
without such abbreviator)&apos; conventions, so all
that is required is a definition of the interpreta-
tion of rules containing only actual character
symbols, together with the various devices for
indicating disjunction, repetition, etc. (Most of
the latter could also be ignored here by a simi-
lar assumption, but the presentation is perhaps
easier to follow if the resemblance to the actual
notation is retained).
One of the more peripheral aspects of
two-level morphology is the role of the rules in
segmenting surface input strings into lexical
forms (i.e. the interface between a rule inter-
preter and a lexicon of morphemes). It is only
there that the special null symbol &amp;quot;0&amp;quot; takes on
special significance (see later section). Hence
most of the definitions, and the subsequent dis-
cussion of generative power, are concerned with
sequences of symbol-pairs, which is equivalent
to considering only pairs of strings of equal
length.
</bodyText>
<sectionHeader confidence="0.609706" genericHeader="method">
BASIC DEFINITIONS
</sectionHeader>
<bodyText confidence="0.99972">
Given any two finite symbolic alphabets,
A and A&apos;, a symbol-pair from A and A&apos; is a
pair &lt;a, a&apos;&gt; where a E A and a&apos; E A&apos;. Such
symbol-pairs will normally be written as &amp;quot;a:a&apos;&amp;quot;.
A symbol-pair sequence from A and A&apos; is sim-
ply a sequence (possibly empty) of symbol-pairs
from A and A&apos;, and a symbol-pair language
over A and A&apos; is a set of symbol-pair sequences
(i.e. a subset of (A x
Given two alphabets A and A&apos;, and a
symbol-pair sequence S from A and A&apos;, a
sequence &lt;P1,..P,i&gt; of symbol-pair sequences
from A and A&apos; is said to be a partition of S iff
</bodyText>
<equation confidence="0.8873065">
S = (i.e. the concatenation
of the P)
</equation>
<sectionHeader confidence="0.842479" genericHeader="method">
CONTEXTS AND RULES
</sectionHeader>
<bodyText confidence="0.955675865384615">
Given two symbol sets A and A&apos;, a
context-expression from A and A&apos; is a regular
expression over A x A&apos;. That is, a context-
expression characterises a regular set of
sequences of symbol-pairs. For example, the
expression
b:b v (a:a b:b)*
characterises the set
(e, b:b, a:a b:b, a:a b:b a:a b:b.....
where e denotes the empty sequence.
Given two alphabets A and A&apos;, a two-
level morphological rule over A and A&apos; consists
of a pair &lt;P. C&gt; where P is a symbol-pair from
A and A&apos;, and C is a non-empty set of pairs
&lt;LC,RC&gt; where LC and RC are context-
expressions from A and A&apos;. The reason for
including a set of pairs of contexts, is that we
must cater, in the general case, for there being a
disjunction of pairs of contexts (as in the illus-
trative example above, where the disjuncts are
separated by &amp;quot;or&amp;quot;). In the case where the set is a
singleton, this reduces to the simple (non-
disjunctive) case.
A context-expression ce is said to match
at the right-end a symbol-pair sequence S iff
there is a partition &lt;Pa, P2&gt; of S such that P2 is
an element of the set characterised by ce.
A context-expression ce is said to match
at the left-end a symbol-pair sequence S iff
there is a partition &lt;Pr, P2&gt; of S such that Pr is
- 52 -
an element of the set characterised by ce.
In a two-level morphological grammar,
there are generally three sorts of rule, although
one of them can be re-expressed as a combina-
tion of rules of the two more basic sorts. The
first basic form of rule is the context restriction
rule written with the operator &amp;quot;=&gt;&amp;quot; separating
the symbol-pair from the specification of the
contexts. For example,
1:i =&gt; b:b e:e
would mean &amp;quot;if there is a lexical I paired with a
lexical i, then there must be a lexical and sur-
face b on its left, and a lexical e and surface e
on its right&amp;quot;.
On the other hand, a surface coercion
rule, written using the operator &amp;quot;&lt;=&amp;quot; indicates
that wherever the contexts (i.e. the right side of
the rule) occur, and the lexical symbol is as
given in the pair on the left side of the rule,
then the surface symbol must be as given on the
left side of the rule. For example:
</bodyText>
<equation confidence="0.517292">
1:i &lt;= b:b e:e
</equation>
<bodyText confidence="0.9999116">
would mean that &amp;quot;whenever there is a lexical b
and surface b on the left, a lexical e and surface
e on the right, and a lexical 1, then the surface
symbol must be i&amp;quot;.
The third type of rule, illustrated earlier,
uses the &amp;quot;&lt;=&gt;&amp;quot; operator, and is defined to be
equivalent to a pair of rules, one of each of the
two basic types, but with the same content.
Hence, no formal definition will be given of the
third type of rule, on the grounds that a gram-
mar written using the &amp;quot;&lt;=&gt;&amp;quot; operator is merely
an abbreviation for a larger set of rules of the
two basic types. We will first define the form
of restriction imposed by rules normally written
with the &amp;quot;=&gt;&amp;quot; operator (&amp;quot;context restriction&amp;quot;
rules).
A set R of two-level morphological rules
contextually allows a symbol-pair sequence S
iff, for every partition &lt;P1, a:a&apos;, P2&gt; of S. either
there is no rule of the form &lt;a:a&apos;, C&gt; in R, or
there is at least one rule &lt;a:a&apos;, C&gt; in R such
that C contains a context pair &lt;LC, RC&gt; such
that LC matches P1 at the right end and RC
matches P2 at the left end.
The definition corresponding to a &amp;quot;surface
coercion&amp;quot; rule (operator &amp;quot;&lt;=&amp;quot;) is as follows.
A two-level morphological rule R =
C&gt; coercively allows a symbol-pair sequence S
iff for every possible partition &lt;P1, b:b&apos;, P2&gt; of
S and every element &lt;LC, RC&gt; in C such that
LC matches P1 at the right end, and RC
matches P2 at the left end, if b = a, then b&apos; = a&apos;.
An alternative but equivalent variation on
the last definition would be that a two-level
morphological rule R = C&gt; coercively
disallows a symbol-pair sequence S iff there is a
possible partition &lt;P1, b:b&apos;, P2&gt; of S and an ele-
ment &lt;LC, RC&gt; in C such that LC matches P1
at the right end, RC matches P2 at the left end,
b = a and b&apos; a&apos;.
</bodyText>
<sectionHeader confidence="0.877471" genericHeader="method">
TWO-LEVEL GRAMMARS
</sectionHeader>
<bodyText confidence="0.998172435897436">
Given two alphabets A and A&apos;, a two-
level morphological grammar based on A and
A&apos; consists of a pair &lt;CR, SC&gt; where CR and
SC are finite sets of two-level morphological
rules over A and A&apos;. The two sets of rules are
the context restriction and surface coercion rules
respectively.
One minor detail which must now be con-
sidered is the question of feasible pairs. When
set-mnemonics and variables are used within
rules, these are deemed to cover not all possible
symbol-pairs, but only those which are &amp;quot;feasi-
ble&amp;quot;. Even when not using these abbreviatory
devices, it is necessary to have some notion of
feasible symbol-pair, since such pairs are
allowed to occur freely even if licensed by no
rule (providing no rule forbids them). Usually,
pairs of the form x:x (where x is in the intersec-
tion of the two alphabets) are taken as feasible,
but any pairs which appear in a rule are also
deemed feasible. If we assume that the notion
of a symbol-pair occurring in a regular expres-
sion is clear enough, occurrence within a rule
set is straightforward— a symbol-pair a:a&apos; is
said to occur in a rule &lt;b:b&apos;, C&gt; iff either a:a&apos; =
b:b&apos; or for at least one element &lt;LC, RC&gt; of C,
a:a&apos; occurs in at least one of LC and RC.
Given a two-level morphological grammar G =
&lt;CR, SC&gt;, the set of feasible pairs in G is the
set of symbol-pairs
(a:a&apos; I
a:a&apos; occurs in some element of CR u SC)
(In an implemented system, the user may be
allowed to declare certain pairs as feasible, but
at this level of abstraction we do not need to
include this in our definition of a two-level mor-
phological grammar, since such an effect could
be represented by including rather vacuous
context-restriction rules of the form
</bodyText>
<equation confidence="0.560405">
- 53 -
&lt; a:b, ( «&gt;,&lt;» ) &gt;).
</equation>
<bodyText confidence="0.932702333333333">
Given a two-level morphological grammar
G = &lt;CR, SC&gt;, a symbol-pair sequence S is
generated by G iff all the following hold:
</bodyText>
<listItem confidence="0.75888775">
(i) all the symbol-pairs in S are feasible pairs
in G;
(ii) each rule in SC coercively allows S;
(iii) the set CR of rules contextually allows S.
</listItem>
<bodyText confidence="0.999855875">
Notice that the two classes of rules are
treated slightly differently - surface coercion
rules are conjoined, forming a set of constraints
all of which must be met, and context restriction
rules are disjoined, giving a set of possible
licensing contexts. If no rules apply to a particu-
lar symbol-pair, it is acceptable if and only if it
is feasible.
</bodyText>
<sectionHeader confidence="0.772465" genericHeader="method">
THE LEXICON
</sectionHeader>
<bodyText confidence="0.996843678571429">
The mechanisms described so far have
provided a way of relating one sequence of
symbols to another sequence (of the same
length). There has been little or no asymmetry
between the roles played by the two sequences,
and no explicit indication of how these rules
might achieve the practical task of segmenting a
word into a set of lexical forms which appear in
a given dictionary.1 The first convention that is
needed is quite simple - the string of lexical
symbols is regarded as being supplied by any
valid concatenation of lexical forms. That is, the
set of lexical entries implicitly defines an
infinite set of strings of indefinite length, formed
by any concatenation of lexical forms. It is in
the course of integrating the string-matching
with the segmentation that the special null sym-
bol will be needed, so we must first define the
notion of two strings being the same after the
removal of nulls.
Suppose we have some symbolic alphabet A.
We define the function &amp;quot;delete&amp;quot; from A x A* to
A* as follows, where e denotes the empty
string:
delete(a, e) = e
delete(a, aS) = delete(a, S)
delete(a, bS) = b delete(a,S) for any b * a.
The formal arguments concerning generative
power concern only the mechanisms presented so far,
so readers uninterested in the interface to the lexicon
may skip this section.
The other minor formal definition we
need is to allow us to move from equal-length
sequences of symbol-pairs to pairs of equal-
length symbol-sequences in the obvious way.
Suppose S1 and S2 are two sequences of sym-
bols, of equal length, with SI = ai...a„ and S2
= bi...bn. Then the symbol-pair sequence asso-
ciated with Si and S2 is the sequence
We can then define a two-level morphological
grammar as licensing a pair of strings of equal
length, iff their associated symbol-pair sequence
is generated by the grammar.
A lexical segmentation system consists of
a tuple (AL, AS, 0, L, G) where AL is a finite
set (the lexical alphabet ), AS is a finite set
(the surface alphabet ), 0 is a symbol which is
not an element of AL u AS, L is a set (the set
of lexical forms) of non-null elements of AL*,
and G is a two-level morphographemic grammar
based on AL u (0) and AS u (0).
Given a lexical segmentation system
(AL, AS, 0, L, G), a string S E AS* can be
segmented as &lt;li,...1„&gt; where ti E L for all i, if
there are strings S1 E AL*, S2 E AS* such that
the following all hold:
</bodyText>
<equation confidence="0.954429333333333">
delete(0, S1) =
delete(0, S2) = S
G licenses &lt;S1, S2&gt;
</equation>
<bodyText confidence="0.9999665">
Notice that there is no distinguished symbol
indicating a morpheme boundary or word boun-
dary. Although the writer of the two-level rules
will probably find it useful to insert certain spe-
cial symbols (e.g. the &amp;quot;+&amp;quot; used in the example
above), these have no special significance, and
rules must be written to define how they relate
to other symbols. The boundaries between mor-
phemes are implicit in the successful match
between the surface form (via the two-level
rules) and the concatenated sequence of lexical
forms.
</bodyText>
<sectionHeader confidence="0.995721" genericHeader="method">
CROSS-LINKED LEXICONS
</sectionHeader>
<bodyText confidence="0.992599">
In Koskenniemi(1983a) (and in the papers in
Dalrymple et al.(1983)) the interface to the lexi-
con is slightly more complicated, since the
representation of morphotactic information is
built into the interface, in the following way. A
lexical entry (for a single morpheme) contains
one or more continuation classes which indicate
what categories of morpheme might follow it
within a valid word; for example, a noun stem
- 54 -
is marked as allowing a noun suffix as a possi-
ble continuation. The morphemes are not held in
a single, uniform dictionary, but in a set of sub-
lexicons, where each lexicon corresponds to
some single morphotactic class. Hence, when
the lookup process has found a particular mor-
pheme (say, a noun stem) by matching entries
in the noun-stem sublexicon, the indication that
noun-suffix is a possible continuation will cause
the lookup process to continue scanning in the
noun suffix sublexicon as it matches the input
word from left to right. This can be rephrased
in a more declarative way by stating that an
input string S corresponds to a sequence of lexi-
cal forms if S matches w1w2 ...wn (the
concatenation of the forms) according to the
morphographemic rules, and for each i between
1 and n-1, wi+1 is in a continuation class of w.
A lexical segmentation system would then have
to include a function which mapped each lexical
entry to its set of continuation classes. Hence
the definitions given above would have to be
altered to the following.
A lexical segmentation system consists of
a tuple (AL, AS, 0, f, G) where AL is
a finite set (the lexical alphabet), AS is a finite
set (the surface alphabet), 0 is a symbol which
is not an element of AL u AS, (Li) is a finite
set of finite sets of non-null elements of AL*
(the sublexicons), f is a function which associ-
ates with each pair &lt;w, j&gt; (where w E Li) a
subset of (4,...4) (the continuation class map-
ping) and G is a two-level morphographemic
grammar based on AL u (0) and AS u (0).
Given a lexical segmentation system
(AL, AS, 0, L, f, G), a string S in AS* can be
segmented as &lt;11,...1.&gt; where l; in La for each
j, if there are strings S1 in AL*, Sy in AS* such
that the following all hold:
</bodyText>
<equation confidence="0.997872">
delete(0, S1) =
delete(0, S2) = S
G licenses &lt;S1, S2&gt;
L84.1) E f(ii, g(j)) for each j from 1 to n-1
</equation>
<bodyText confidence="0.999933285714286">
The advantage of introducing cross-linked lexi-
cons is that some form of morphotactic informa-
tion can be inserted directly into the lexicon,
and the processing of this information incor-
porated into the scanning of the surface string
very easily. One theoretical disadvantage is that
it imposes a finite-state structure on the morpho-
tactics, which may well be undesirable. If
cross-linked sublexicons are not used, some
further descriptive device is needed to express
morphotactic information in a usable form, but
this could be completely separate from the two-
level morphology system (cf. Ritchie, Pulman et
al.(1987)).
</bodyText>
<sectionHeader confidence="0.762997" genericHeader="method">
LANGUAGES GENERATED
</sectionHeader>
<bodyText confidence="0.995913543478261">
With the above definitions, it is now pos-
sible to ask what sorts of symbol-pair languages
can be characterised using a two-level morpho-
logical grammar. Here we shall ignore the issue
of the interface to the lexicon, and simply con-
sider the capacity of two-level morphological
grammars to characterise sets of sequences of
symbol-pairs.
Lemma 1 : Let R be a set of two-level morpho-
logical rules. Let Ea and E2 be symbol-pair
sequences such that R contextually allows Ea,
and R contextually allows Ey. Then R contextu-
ally allows the concatenation E1E2.
Proof: If there is no symbol-pair a:a&apos; in E1E2
such that there is some rule «a:a&apos;&gt;, C&gt; in R,
then R contextually allows E1E2 for trivial rea-
sons. Let a:a&apos; be a symbol-pair occurring in
4E2 such that there is at least one rule
«a:a&apos;,C&gt; in R. Let &lt;P1, a:a&apos;,P2&gt; be a partition
of E1E2. It follows from the definitions of a
partition and concatenation that either Pa is a
proper initial subsequence of El and P2 = S2E2
for some sequence S2 (i.e. this occurrence of
a:a&apos; is in Ea), or P1 = EiSi for some sequence
S1 and P2 is proper final subsequence of Ey (i.e.
this occurrence of a:a&apos; is in E2). That is, either
&lt;P1, a:a&apos;, Sy&gt; is a partition of El, or &lt;S1, a:a&apos;,
Py&gt; is a partition of Ey. Assume the former is
true (a symmetrical argument can be followed
for the latter). Since R contextually allows El,
for the partition &lt;Pa, a:a&apos;, S2&gt; of El there is at
least one rule C in R which contains at least one
context-pair &lt;LC, RC&gt; such that LC matches P1
at the right end and RC matches Sy at the left
end. If RC matches Sy at the left end, then RC
will also match S2E2 = Py at the left end. Hence,
for the partition &lt;Pa, a:a&apos;, Py&gt; of E1E2 there is
at least one rule C in R which contains at least
one context-pair &lt;LC, RC&gt; such that LC
matches P1 at the right end and RC matches P2
at the left end. A similar argument can be
given for the occurrence of a:a&apos; being in Ey.
Since this will be true for any such a:a&apos; in E1E2,
R contextually allows E1E2.
Lemma 2 : Let R = &lt;a:a&apos;, C&gt; be a two-level
morphological rule. Let El, Ey, E3 be symbol-
</bodyText>
<equation confidence="0.543235">
CP-F - 55 -
</equation>
<bodyText confidence="0.999850710526316">
pair sequences such that E1E2E3 is coercively
allowed by R. Then E2 is coercively allowed by
R.
Proof: If E2 were not coercively allowed by R,
it would mean that there is a partition &lt;S1, a:b,
S2&gt; of E2 such that for some &lt;LC, RC&gt; in C,
LC matches S1 at the right end, RC matches S2
at the left end, and b # a&apos;. If this were the
case, there would be a corresponding partition
&lt;EiSi, a:b, S2E3&gt; of E1E2E3, with LC matching
EiSi at the right end, and RC matching S2E3 at
the left end. This would (by definition) mean
that R does not coercively allow E1E2E3, which
is not the case by hypothesis.
Corollary :Let C be a set of two-level morpho-
logical rules, all of which coercively allow a
symbol-pair sequence E. Then all of the rules in
C coercively allow any subsequence of E.
Lemma 3 : Let G be a two-level morphological
grammar &lt;CR, SC&gt;, and let L(G) be the set of
symbol-pair sequences generated by G. Sup-
pose that there are sequences Ei, E, E3, E4 such
that E2 E L(G), E&apos;3 E L(G), and E1E2E3E4 E
L(G). Then E2E3 E L(G).
Proof : (i) Since E1E2E3E4 E L(G), all the
symbol-pairs in it are feasible with respect to G,
hence all the symbol-pairs in E2E3 are feasible.
(ii) Since E2 and E3 are in L(G), it follows that
CR contextually allows E2 and E.3 (by
definition). By Lemma 1 above, this means that
CR contextually allows E2E3.
(iii) Since E1E2E3E4 E L(G), it follows (by
definition) that all of the rules in SC coercively
allow E1E2E3E4. Hence, by the corollary to
Lemma 2 above, all of the rules in SC coer-
cively allow E2E3.
This establishes the three defining conditions
for E2E3 e L(G).
</bodyText>
<sectionHeader confidence="0.998545" genericHeader="method">
REGULAR RELATIONS
</sectionHeader>
<bodyText confidence="0.998293810810811">
As mentioned in the introduction, two-
level grammars have historically been written in
two different ways— as rules as defined here,
and as sets of finite-state transducers. In the
latter case, each transducer deals with some
linguistic phenomenon, and a sequence of
symbol-pairs is generated by the grammar if
every transducer in the grammar accepts it.
That is, the symbol-pair sequence must be in the
intersection of the languages accepted by the
transducers (viewed as acceptors); in procedural
terms, this is often referred to as &amp;quot;having the
transducers executed in parallel&amp;quot;. Hence, when
working with the transducer formalism the
linguist has to devise independent transducers
whose intersection is the required language.
Kaplan(l988) discussed the notion of a
regular relation, which is, roughly speaking, a
symbol-pair language which can be character-
ised by a regular expression of symbol-pairs.
Not surprisingly, a set of symbol-pair sequences
is regular if and only if it can be accepted by a
finite-state transducer in the obvious way.
Kaplan has developed an algebraic way of
manipulating regular expressions over symbol-
pairs together with ordinary regular expressions
over symbols, and one of his results is that the
intersection of several regular relations is also a
regular relation. It follows that the symbol-pair
languages accepted by the two-level transducer
model are exactly the regular relations.
Kaplan also formalises the re-expression
of two-level morphological rules as transducers
(i.e. the compilation mentioned in the introduc-
tion above) by constructing regular relations
equivalent to languages generated by individual
two-level morphological rules. This re-
expression is one-way - from a two-level mor-
phological rule an equivalent regular relation
can be formed.
All this suggests that the &amp;quot;parallel trans-
ducer&amp;quot; model is at least as powerful as the strict
two-level grammar model defined earlier. The
obvious question is whether there is a difference
in power; in fact, there is:
Theorem: There are regular relations (i.e.
symbol-pair languages characterised by regular
expressions of symbol-pairs) which cannot be
generated by any two-level morphological gram-
mar.
Proof: This follows directly from Lemma 3
above. Any language L generated by a two-
level morphological grammar must have the
property that if E2, E3, and E1E2E3E4 are in L,
then E2E3 is in L. There are regular relations
which do not have this property, such as the
language b:b v (a:a b:b)* mentioned earlier
(which contains b:b and a:a b:b but not b:b a:a
b:b, even though that sequence is a subsequence
of other elements of the language).
There is another, rather trivial, difference
between the power of two-level morphological
rules and regular relations. According to the
definitions given here, the empty sequence of
symbol-pairs is in every language generated by
a two-level morphological grammar, since it
- 56 -
conforms to the definition regardless of the con-
tent of the rules. The definitions could be
altered to exclude the empty sequence from
every language, but it is hard to see how the
rule mechanism could be used to allow the
empty sequence in some languages but not oth-
ers.
</bodyText>
<sectionHeader confidence="0.985062" genericHeader="conclusions">
CONCLUSIONS
</sectionHeader>
<bodyText confidence="0.999981458333334">
We have presented an alternative formal
statement of the meaning of Koskenniemi&apos;s
notation for two-level morphological rules. This
definition appears to be wholly faithful to the
original informal explanations of the intent of
two-level morphological rules, but is indepen-
dent of the expression of the rules as transduc-
ers. The generative power of two-level morpho-
logical grammars, viewed as ways of charac-
terising sets of sequences of symbol-pairs, is
less than that of arbitrary transducers, despite
the fact that the transducer formulation is some-
times discussed as if it were the essential
definition of the two-level model.
It now remains to determine further pro-
perties of the set of two-level generatable
languages. Barton et al.(1987) have shown that
the recognition problem for two-level transduc-
ers (including cross-linked lexicons) is NP-
complete, and a very similar demonstration can
be constructed for the two-level model defined
here. Closure properties (or lack thereof) of the
two-level generatable languages are yet to be
proven.
</bodyText>
<sectionHeader confidence="0.984961" genericHeader="acknowledgments">
ACKNOWLEDGEMENTS
</sectionHeader>
<bodyText confidence="0.99902125">
This work was supported by SERC/Alvey
grant GR/D/83507 (IICBS 096). I would like to
thank Alan Black for useful discussions of this
material.
</bodyText>
<sectionHeader confidence="0.998402" genericHeader="references">
REFERENCES
</sectionHeader>
<reference confidence="0.9931325">
Dalrymple, Mary; Doron, Edit; Goggin,
John; Goodman, Beverley; and McCarthy, John
(eds) 1983 Texas Linguistic Forum 22, Depart-
ment of Linguistics, University of Texas at Aus-
tin, Austin, Texas.
Barton, G. Edward; Berwick, Robert C.;
and Ristad, Eric Sven 1987 Computational
Complexity and Natural Language. MIT Press,
Cambridge, Mass.
Kaplan, Ronald M. 1988 Talk on finite-
state transducers given at the Alvey Workshop
on Parsing and Pattern Recognition, Oxford,
April 1988.
ICarttunen, Lauri; Koskenniemi, Kimmo;
and Kaplan, Ronald M. 1987 A Compiler for
Two-level Phonological Rules. Unpublished
manuscript.
Koskenniemi, Kimmo 1983a Two-level
Morphology: a general computational model for
word-form recognition and production. Publica-
tion No.11, University of Helsinki, Finland.
Koskenniemi, Kimmo 1983b Two-level
model for morphological analysis. Pp. 683-685
in Proceedings of the Eighth International Joint
Conference on Artificial Intelligence, Karlsruhe.
Koskenniemi, Kimmo 1984 A General
Computational Model for Word-Form Recogni-
tion and Production. Pp. 178-181 in Proceed-
ings of COLING-84 (10th International Confer-
ence on Computational Linguistics/22nd Annual
Meeting of the ACL), Stanford, CA.
Koskenniemi, Kimmo 1985 Compilation
of Automata from Morphological Two-Level
Rules. Pp. 143-149 in Papers from the Fifth
Scandinavian Conference of Computational
Linguistics , Publication No.15, University of
Helsinki, Finland.
Reape, Mike; and Thompson, Henry 1988
Parallel Intersection and Serial Composition of
Finite State Transducers. Pp.535-539 in
Proceedings of COLING-88 (12th International
Conference on Computational Linguistics).
Bonn.
Ritchie, Graeme D.; Black, Alan W.; Pul-
man, Stephen G.; and Russell Graham J. 1987
The Edinburgh/Cambridge Morphological Ana-
lyser and Dictionary System: System Descrip-
tion. Version 3.0. Software Paper 11, Depart-
ment of Artificial Intelligence, University of
Edinburgh.
Ritchie, Graeme D.; Pulman, Stephen G.;
Black, Alan W.; and Russell, Graham J. 1987
A Computational Framework for Lexical
Description. Computational Linguistics 13, (3-
4):290-307.
- 57 -
</reference>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.462947">
<title confidence="0.999322">ON THE GENERATIVE POWER OF TWO-LEVEL MORPHOLOGICAL RULES</title>
<author confidence="0.999771">Graeme Ritchie</author>
<affiliation confidence="0.999798">Department of Artificial Intelligence University of Edinburgh</affiliation>
<address confidence="0.876849333333333">80 South Bridge Edinburgh EH1 1HN Scotland</address>
<abstract confidence="0.999032808349146">Koskenniemi&apos;s model of two-level morphology has been very influential in recent years, but definitions of the formalism have generally been phrased in terms of a compilation (sometimes left unspecified) into a form of finite-state transducers, or else have consisted of an informal outline of the intended interpretation of the rule-formalism itself. Analyses of the properties of the formalism have generally focussed on the transducer mechanism. It is, however, possible to give a fully formal definition of the original rule notation directly, in a way which reflects Koskenniemi&apos;s original informal characterisation and which does not depend directly on the notion of a transducer (although it must retain the essential nature of parts of the notation as being regular expressions). This re-formulation allows a proof that the ability of this formalism to characterise mappings between strings is more limited than that of arbitrary transducers. BACKGROUND Koskenniemi(1983a,b;1984) proposed a rule-system for describing morphological regularities in a language, depending centrally on the idea of matching two sequences of symbols a (made up of the lexical forms of and surface (the of characters in the normal, inflected, form of the word). In principle, symbols could be orthographic or phonological; here we shall follow common practice within two-level morphology, and assume orthographic forms are being analysed. Koskenniemi(1983a) originally described the rules in two alternative forms high-level rules and finite-state transducers, and conjectured that an automatic compilation procedure could be devised to transform the more readable, high-level form into the more directly implementable transducer form. His implementation was an interpreter for the transducers, which were directly written by the linguist as rules in their own right. The various linguistic analyses presented in Dalrymple et al.(1983) also follow this approach, expressing rules as transition tables for transducers. Koskenniemi(1985) refined the notation and sketched a compilation method, and Ritchie, Black et al.(1987), Karttunen et al.(1987) describe compilation techniques for two variants of the notation. The aim of this paper is to give an alternative statement of the meaning of the original high-level rule notation, without recourse to compilation into finite-state transducers. The benefits of this are twofold: (i) alternative implementation techniques can be considered or discussed with reference to a standard interpretation which is not tied to an existing approach to implementation; (ii) the formal properties of the actual ruleformalism can be assessed, rather than the formal properties of another formalism (transducers) which might in principle be more powerful. In particular, it is possible to show that the two-level morphological mechanism is more limited than the transducer model in its ability to define relationships between strings. THE FORMALISM TWO-LEVEL NOTATION The original notation proposed in Koskenniemi(1983a) included some rather complex notational conventions which have not survived into later versions. The formalisation given here will deal only with the core ideas, as embodied in Koskenniemi(1985) (and other implementations such as ICarttunen et al.(1987), - 51 - Ritchie, Black, et al.(1987)). By way of illustration, here is a two-level morphological rule taken from Ritchie, Pulman et al. (1987): e:0 &lt;=&gt; =:C2 &lt;+:0 V:=&gt; or &lt; C:C V:V&gt; &lt;+:0 e:e&gt; or (g:g c:c) &lt;+:0 (e:e i:i) &gt; or 1:0 +:0 or c:c &lt;+:0 a:0 t:t&gt; Rules are phrased in terms of symbol-pairs (written with an infix colon), where the first in the pair is a lexical symbol and the second is a surface symbol. In the above example, the pair of symbols on the left (lexical &amp;quot;e&amp;quot; and surface null) are allowed to occur only in the contexts on the right of the rule, where &amp;quot; &amp;quot; cates the position of the pair &amp;quot;e:0&amp;quot;. Each context has a left part and a right part, each of these being essentially a regular expression over symbol-pairs, where angle brackets indicate sequences of pairs and braces indicate alternatives (disjunction). Certain versions of the notation may also allow the &amp;quot;Kleene star&amp;quot; symbol &amp;quot;*&amp;quot; to indicate zero or more repetitions, and the insertion of optional elements. In this example, &amp;quot;C&amp;quot;, &amp;quot;V&amp;quot;, &amp;quot;C2&amp;quot;, and &amp;quot;=&amp;quot; represent subsets of the relevant symbol alphabets and &amp;quot;+&amp;quot; is an abstract symbol occurring in certain lexical forms. The formalism here will not include symbolic mnemonics for sets of symbols, nor variables ranging over sets of symbols. The semantics of both these notations (which are commonly used in two-level morphology) can be stated in terms of equivalent sets of rules without such abbreviator)&apos; conventions, so all that is required is a definition of the interpretation of rules containing only actual character symbols, together with the various devices for indicating disjunction, repetition, etc. (Most of the latter could also be ignored here by a similar assumption, but the presentation is perhaps easier to follow if the resemblance to the actual notation is retained). One of the more peripheral aspects of two-level morphology is the role of the rules in segmenting surface input strings into lexical forms (i.e. the interface between a rule interpreter and a lexicon of morphemes). It is only there that the special null symbol &amp;quot;0&amp;quot; takes on special significance (see later section). Hence most of the definitions, and the subsequent discussion of generative power, are concerned with sequences of symbol-pairs, which is equivalent to considering only pairs of strings of equal length. BASIC DEFINITIONS Given any two finite symbolic alphabets, and A&apos;, a A and A&apos; is a &lt;a, a&apos;&gt; where a and a&apos; Such symbol-pairs will normally be written as &amp;quot;a:a&apos;&amp;quot;. sequence from A and A&apos; is simply a sequence (possibly empty) of symbol-pairs A and A&apos;, and a language A and A&apos; is a of symbol-pair sequences (i.e. a subset of (A x Given two alphabets A and A&apos;, and a symbol-pair sequence S from A and A&apos;, a symbol-pair sequences A and A&apos; is said to be a S iff S = (i.e. the concatenation the CONTEXTS AND RULES Given two symbol sets A and A&apos;, a from A and A&apos; is regular expression over A x A&apos;. That is, a contextexpression characterises a regular set of sequences of symbol-pairs. For example, the expression b:b v (a:a b:b)* characterises the set (e, b:b, a:a b:b, a:a b:b a:a b:b..... where e denotes the empty sequence. two alphabets A and A&apos;, a twomorphological rule A and A&apos; consists of a pair &lt;P. C&gt; where P is a symbol-pair from A and A&apos;, and C is a non-empty set of pairs &lt;LC,RC&gt; where LC and RC are contextexpressions from A and A&apos;. The reason for a pairs of contexts, is that we must cater, in the general case, for there being a disjunction of pairs of contexts (as in the illustrative example above, where the disjuncts are separated by &amp;quot;or&amp;quot;). In the case where the set is a singleton, this reduces to the simple (nondisjunctive) case. context-expression ce is said to the right-end symbol-pair sequence S iff is a partition P2&gt; S such that an element of the set characterised by ce. context-expression ce is said to the left-end symbol-pair sequence S iff is a partition S such that is - 52 an element of the set characterised by ce. In a two-level morphological grammar, there are generally three sorts of rule, although one of them can be re-expressed as a combination of rules of the two more basic sorts. The basic form of rule is the restriction with the operator &amp;quot;=&gt;&amp;quot; separating the symbol-pair from the specification of the contexts. For example, 1:i =&gt; b:b e:e would mean &amp;quot;if there is a lexical I paired with a lexical i, then there must be a lexical and surface b on its left, and a lexical e and surface e on its right&amp;quot;. the other hand, a coercion using the operator &amp;quot;&lt;=&amp;quot; indicates that wherever the contexts (i.e. the right side of rule) occur, lexical symbol is as given in the pair on the left side of the rule, then the surface symbol must be as given on the left side of the rule. For example: 1:i &lt;= b:b e:e would mean that &amp;quot;whenever there is a lexical b and surface b on the left, a lexical e and surface e on the right, and a lexical 1, then the surface symbol must be i&amp;quot;. The third type of rule, illustrated earlier, uses the &amp;quot;&lt;=&gt;&amp;quot; operator, and is defined to be equivalent to a pair of rules, one of each of the two basic types, but with the same content. Hence, no formal definition will be given of the third type of rule, on the grounds that a grammar written using the &amp;quot;&lt;=&gt;&amp;quot; operator is merely an abbreviation for a larger set of rules of the two basic types. We will first define the form of restriction imposed by rules normally written with the &amp;quot;=&gt;&amp;quot; operator (&amp;quot;context restriction&amp;quot; rules). A set R of two-level morphological rules allows symbol-pair sequence S for every partition a:a&apos;, S. either there is no rule of the form &lt;a:a&apos;, C&gt; in R, or there is at least one rule &lt;a:a&apos;, C&gt; in R such that C contains a context pair &lt;LC, RC&gt; such LC matches at the right end and RC the left end. The definition corresponding to a &amp;quot;surface coercion&amp;quot; rule (operator &amp;quot;&lt;=&amp;quot;) is as follows. A two-level morphological rule R = allows symbol-pair sequence S for every possible partition b:b&apos;, S and every element &lt;LC, RC&gt; in C such that matches at the right end, and RC the left end, if b = a, then b&apos; = a&apos;. An alternative but equivalent variation on the last definition would be that a two-level rule R = C&gt; coercively symbol-pair sequence S iff there is a partition b:b&apos;, S and an ele- &lt;LC, RC&gt; in C such that LC matches the right end, RC matches the left end, b = a and b&apos; a&apos;. GRAMMARS two alphabets A and A&apos;, a twolevel morphological grammar based on A and A&apos; consists of a pair &lt;CR, SC&gt; where CR and SC are finite sets of two-level morphological rules over A and A&apos;. The two sets of rules are the context restriction and surface coercion rules respectively. One minor detail which must now be conis the question of pairs. set-mnemonics and variables are used within rules, these are deemed to cover not all possible symbol-pairs, but only those which are &amp;quot;feasible&amp;quot;. Even when not using these abbreviatory devices, it is necessary to have some notion of feasible symbol-pair, since such pairs are allowed to occur freely even if licensed by no rule (providing no rule forbids them). Usually, pairs of the form x:x (where x is in the intersection of the two alphabets) are taken as feasible, but any pairs which appear in a rule are also deemed feasible. If we assume that the notion of a symbol-pair occurring in a regular expression is clear enough, occurrence within a rule set is straightforward— a symbol-pair a:a&apos; is to in rule &lt;b:b&apos;, C&gt; iff either a:a&apos; = b:b&apos; or for at least one element &lt;LC, RC&gt; of C, a:a&apos; occurs in at least one of LC and RC. Given a two-level morphological grammar G = SC&gt;, the of feasible pairs in G the set of symbol-pairs (a:a&apos; I a:a&apos; occurs in some element of CR u SC) (In an implemented system, the user may be allowed to declare certain pairs as feasible, but at this level of abstraction we do not need to include this in our definition of a two-level morphological grammar, since such an effect could be represented by including rather vacuous context-restriction rules of the form - 53 - &lt; a:b, ( «&gt;,&lt;» ) &gt;). Given a two-level morphological grammar G = &lt;CR, SC&gt;, a symbol-pair sequence S is G iff all the following hold: (i) all the symbol-pairs in S are feasible pairs in G; (ii) each rule in SC coercively allows S; (iii) the set CR of rules contextually allows S. Notice that the two classes of rules are treated slightly differently surface coercion rules are conjoined, forming a set of constraints all of which must be met, and context restriction rules are disjoined, giving a set of possible licensing contexts. If no rules apply to a particular symbol-pair, it is acceptable if and only if it is feasible. THE LEXICON The mechanisms described so far have provided a way of relating one sequence of symbols to another sequence (of the same length). There has been little or no asymmetry between the roles played by the two sequences, and no explicit indication of how these rules might achieve the practical task of segmenting a word into a set of lexical forms which appear in given The first convention that is needed is quite simple the string of lexical symbols is regarded as being supplied by any valid concatenation of lexical forms. That is, the set of lexical entries implicitly defines an infinite set of strings of indefinite length, formed by any concatenation of lexical forms. It is in the course of integrating the string-matching with the segmentation that the special null symbol will be needed, so we must first define the notion of two strings being the same after the removal of nulls. Suppose we have some symbolic alphabet A. We define the function &amp;quot;delete&amp;quot; from A x A* to A* as follows, where e denotes the empty string: delete(a, e) = e delete(a, aS) = delete(a, S) delete(a, bS) = b delete(a,S) for any b * a. The formal arguments concerning generative power concern only the mechanisms presented so far, so readers uninterested in the interface to the lexicon may skip this section. The other minor formal definition we need is to allow us to move from equal-length sequences of symbol-pairs to pairs of equallength symbol-sequences in the obvious way. and are two sequences of symof equal length, with = the sequence assowith and is the sequence We can then define a two-level morphological as a of strings of equal length, iff their associated symbol-pair sequence is generated by the grammar. segmentation system of a tuple (AL, AS, 0, L, G) where AL is a finite (the alphabet ), is a finite set surfacealphabet ), is a symbol which is not an element of AL u AS, L is a set (the set forms) non-null elements of AL*, and G is a two-level morphographemic grammar based on AL u (0) and AS u (0). Given a lexical segmentation system AS, 0, L, G), a string S E AS* be as E L for all i, if are strings E E such that the following all hold: = = S licenses Notice that there is no distinguished symbol indicating a morpheme boundary or word boundary. Although the writer of the two-level rules will probably find it useful to insert certain special symbols (e.g. the &amp;quot;+&amp;quot; used in the example above), these have no special significance, and rules must be written to define how they relate to other symbols. The boundaries between morphemes are implicit in the successful match between the surface form (via the two-level rules) and the concatenated sequence of lexical forms. CROSS-LINKED LEXICONS In Koskenniemi(1983a) (and in the papers in Dalrymple et al.(1983)) the interface to the lexicon is slightly more complicated, since the representation of morphotactic information is built into the interface, in the following way. A lexical entry (for a single morpheme) contains or more classes indicate what categories of morpheme might follow it within a valid word; for example, a noun stem - 54 is marked as allowing a noun suffix as a possible continuation. The morphemes are not held in a single, uniform dictionary, but in a set of sublexicons, where each lexicon corresponds to some single morphotactic class. Hence, when the lookup process has found a particular morpheme (say, a noun stem) by matching entries in the noun-stem sublexicon, the indication that noun-suffix is a possible continuation will cause the lookup process to continue scanning in the noun suffix sublexicon as it matches the input word from left to right. This can be rephrased in a more declarative way by stating that an string S corresponds to a sequence of lexical forms if S matches w1w2 ...wn (the concatenation of the forms) according to the morphographemic rules, and for each i between and n-1, is in a continuation class of A lexical segmentation system would then have to include a function which mapped each lexical entry to its set of continuation classes. Hence the definitions given above would have to be altered to the following. segmentation system of a tuple (AL, AS, 0, f, G) where AL is finite set (the alphabet), is a finite (the alphabet), is a symbol which not an element of AL u AS, a finite set of finite sets of non-null elements of AL* is a function which associwith each pair &lt;w, j&gt; (where w E of (4,...4) (the class mapping) and G is a two-level morphographemic grammar based on AL u (0) and AS u (0). Given a lexical segmentation system AS, 0, L, f, G), a string S in AS* be as in for each if there are strings in AL*, Sy in AS* such that the following all hold: = delete(0, S2) = S licenses E g(j)) for each j from 1 to n-1 The advantage of introducing cross-linked lexicons is that some form of morphotactic information can be inserted directly into the lexicon, and the processing of this information incorporated into the scanning of the surface string very easily. One theoretical disadvantage is that it imposes a finite-state structure on the morphotactics, which may well be undesirable. If cross-linked sublexicons are not used, some further descriptive device is needed to express morphotactic information in a usable form, but this could be completely separate from the twolevel morphology system (cf. Ritchie, Pulman et al.(1987)). LANGUAGES GENERATED With the above definitions, it is now possible to ask what sorts of symbol-pair languages can be characterised using a two-level morphological grammar. Here we shall ignore the issue of the interface to the lexicon, and simply consider the capacity of two-level morphological grammars to characterise sets of sequences of symbol-pairs. Lemma 1 : Let R be a set of two-level morphorules. Let and be symbol-pair such that R contextually allows and R contextually allows Ey. Then R contextuallows the concatenation there is no symbol-pair a:a&apos; in such that there is some rule «a:a&apos;&gt;, C&gt; in R, R contextually allows for trivial reasons. Let a:a&apos; be a symbol-pair occurring in such that there is at least one rule in R. Let be a partition It follows from the definitions of a and concatenation that either is a initial subsequence of and = some sequence (i.e. this occurrence of is in or = for some sequence and is proper final subsequence of Ey (i.e. occurrence of a:a&apos; is in That is, either a:a&apos;, Sy&gt; is a partition of or a:a&apos;, Py&gt; is a partition of Ey. Assume the former is true (a symmetrical argument can be followed the latter). Since R contextually allows the partition a:a&apos;, of there is at least one rule C in R which contains at least one &lt;LC, RC&gt; such that LC matches at the right end and RC matches Sy at the left end. If RC matches Sy at the left end, then RC also match = Py at the left end. Hence, the partition a:a&apos;, Py&gt; of there is at least one rule C in R which contains at least one context-pair &lt;LC, RC&gt; such that LC at the right end and RC matches at the left end. A similar argument can be given for the occurrence of a:a&apos; being in Ey. this will be true for any such a:a&apos; in contextually allows Lemma 2 : Let R = &lt;a:a&apos;, C&gt; be a two-level rule. Let Ey, be symbol- 55 sequences such that is coercively by R. Then is coercively allowed by R. were not coercively allowed by R, would mean that there is a partition a:b, of such that for some &lt;LC, RC&gt; in C, matches at the right end, RC matches at the left end, and b # a&apos;. If this were the case, there would be a corresponding partition a:b, of with LC matching at the right end, and RC matching at the left end. This would (by definition) mean R does not coercively allow which is not the case by hypothesis. :Let be a set of two-level morphological rules, all of which coercively allow a symbol-pair sequence E. Then all of the rules in C coercively allow any subsequence of E. Lemma 3 : Let G be a two-level morphological grammar &lt;CR, SC&gt;, and let L(G) be the set of symbol-pair sequences generated by G. Supthat there are sequences E, such E E and E Then E : (i) E all the symbol-pairs in it are feasible with respect to G, all the symbol-pairs in are feasible. Since and are in L(G), it follows that contextually allows and (by definition). By Lemma 1 above, this means that contextually allows Since E it follows (by definition) that all of the rules in SC coercively Hence, by the corollary to Lemma 2 above, all of the rules in SC coerallow This establishes the three defining conditions e</abstract>
<intro confidence="0.892697">REGULAR RELATIONS</intro>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Mary Dalrymple</author>
<author>Edit Doron</author>
<author>John Goggin</author>
<author>Beverley Goodman</author>
<author>John McCarthy</author>
</authors>
<date>1983</date>
<booktitle>Texas Linguistic Forum 22,</booktitle>
<institution>Department of Linguistics, University of Texas at Austin,</institution>
<location>Austin, Texas.</location>
<marker>Dalrymple, Doron, Goggin, Goodman, McCarthy, 1983</marker>
<rawString>Dalrymple, Mary; Doron, Edit; Goggin, John; Goodman, Beverley; and McCarthy, John (eds) 1983 Texas Linguistic Forum 22, Department of Linguistics, University of Texas at Austin, Austin, Texas.</rawString>
</citation>
<citation valid="true">
<authors>
<author>G Edward Barton</author>
<author>Robert C Berwick</author>
<author>Ristad</author>
</authors>
<title>Eric Sven</title>
<date>1987</date>
<booktitle>Computational Complexity and Natural Language.</booktitle>
<publisher>MIT Press,</publisher>
<location>Cambridge, Mass.</location>
<marker>Barton, Berwick, Ristad, 1987</marker>
<rawString>Barton, G. Edward; Berwick, Robert C.; and Ristad, Eric Sven 1987 Computational Complexity and Natural Language. MIT Press, Cambridge, Mass.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ronald M Kaplan</author>
</authors>
<title>Talk on finitestate transducers given at the Alvey Workshop on Parsing and Pattern Recognition,</title>
<date>1988</date>
<location>Oxford,</location>
<marker>Kaplan, 1988</marker>
<rawString>Kaplan, Ronald M. 1988 Talk on finitestate transducers given at the Alvey Workshop on Parsing and Pattern Recognition, Oxford, April 1988.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Lauri ICarttunen</author>
<author>Kimmo Koskenniemi</author>
<author>Ronald M Kaplan</author>
</authors>
<title>A Compiler for Two-level Phonological Rules.</title>
<date>1987</date>
<note>Unpublished manuscript.</note>
<marker>ICarttunen, Koskenniemi, Kaplan, 1987</marker>
<rawString>ICarttunen, Lauri; Koskenniemi, Kimmo; and Kaplan, Ronald M. 1987 A Compiler for Two-level Phonological Rules. Unpublished manuscript.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Koskenniemi</author>
</authors>
<title>Kimmo 1983a Two-level Morphology: a general computational model for word-form recognition and production. Publication No.11,</title>
<date></date>
<institution>University of Helsinki,</institution>
<marker>Koskenniemi, </marker>
<rawString>Koskenniemi, Kimmo 1983a Two-level Morphology: a general computational model for word-form recognition and production. Publication No.11, University of Helsinki, Finland.</rawString>
</citation>
<citation valid="false">
<authors>
<author>Koskenniemi</author>
</authors>
<title>Kimmo 1983b Two-level model for morphological analysis.</title>
<booktitle>Pp. 683-685 in Proceedings of the Eighth International Joint Conference on Artificial Intelligence,</booktitle>
<location>Karlsruhe.</location>
<marker>Koskenniemi, </marker>
<rawString>Koskenniemi, Kimmo 1983b Two-level model for morphological analysis. Pp. 683-685 in Proceedings of the Eighth International Joint Conference on Artificial Intelligence, Karlsruhe.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kimmo Koskenniemi</author>
</authors>
<title>A General Computational Model for Word-Form Recognition and Production. Pp. 178-181 in</title>
<date>1984</date>
<booktitle>Proceedings of COLING-84 (10th International Conference on Computational Linguistics/22nd Annual Meeting of the ACL),</booktitle>
<location>Stanford, CA.</location>
<marker>Koskenniemi, 1984</marker>
<rawString>Koskenniemi, Kimmo 1984 A General Computational Model for Word-Form Recognition and Production. Pp. 178-181 in Proceedings of COLING-84 (10th International Conference on Computational Linguistics/22nd Annual Meeting of the ACL), Stanford, CA.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kimmo Koskenniemi</author>
</authors>
<title>Compilation of Automata from Morphological Two-Level Rules.</title>
<date>1985</date>
<booktitle>Pp. 143-149 in Papers from the Fifth Scandinavian Conference of Computational Linguistics , Publication No.15,</booktitle>
<institution>University of Helsinki,</institution>
<marker>Koskenniemi, 1985</marker>
<rawString>Koskenniemi, Kimmo 1985 Compilation of Automata from Morphological Two-Level Rules. Pp. 143-149 in Papers from the Fifth Scandinavian Conference of Computational Linguistics , Publication No.15, University of Helsinki, Finland.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Mike Reape</author>
<author>Henry Thompson</author>
</authors>
<title>Parallel Intersection and Serial Composition of Finite State Transducers. Pp.535-539</title>
<date>1988</date>
<booktitle>in Proceedings of COLING-88 (12th International Conference on Computational Linguistics).</booktitle>
<location>Bonn.</location>
<marker>Reape, Thompson, 1988</marker>
<rawString>Reape, Mike; and Thompson, Henry 1988 Parallel Intersection and Serial Composition of Finite State Transducers. Pp.535-539 in Proceedings of COLING-88 (12th International Conference on Computational Linguistics). Bonn.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Graeme D Ritchie</author>
<author>Alan W Black</author>
<author>Stephen G Pulman</author>
<author>Russell Graham J</author>
</authors>
<title>The Edinburgh/Cambridge Morphological Analyser and Dictionary System: System Description.</title>
<date>1987</date>
<booktitle>Version 3.0. Software Paper 11,</booktitle>
<institution>Department of Artificial Intelligence, University of Edinburgh.</institution>
<marker>Ritchie, Black, Pulman, J, 1987</marker>
<rawString>Ritchie, Graeme D.; Black, Alan W.; Pulman, Stephen G.; and Russell Graham J. 1987 The Edinburgh/Cambridge Morphological Analyser and Dictionary System: System Description. Version 3.0. Software Paper 11, Department of Artificial Intelligence, University of Edinburgh.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Graeme D Ritchie</author>
<author>Stephen G Pulman</author>
<author>Alan W Black</author>
<author>Graham J Russell</author>
</authors>
<title>A Computational Framework for Lexical Description.</title>
<date>1987</date>
<journal>Computational Linguistics</journal>
<volume>13</volume>
<pages>3--4</pages>
<marker>Ritchie, Pulman, Black, Russell, 1987</marker>
<rawString>Ritchie, Graeme D.; Pulman, Stephen G.; Black, Alan W.; and Russell, Graham J. 1987 A Computational Framework for Lexical Description. Computational Linguistics 13, (3-4):290-307.</rawString>
</citation>
<citation valid="false">
<pages>57</pages>
<marker></marker>
<rawString>- 57 -</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>