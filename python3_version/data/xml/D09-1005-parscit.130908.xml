<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<title confidence="0.806988">
First- and Second-Order Expectation Semirings
with Applications to Minimum-Risk Training on Translation Forests∗
</title>
<author confidence="0.996636">
Zhifei Li and Jason Eisner
</author>
<affiliation confidence="0.9591005">
Department of Computer Science and Center for Language and Speech Processing
Johns Hopkins University, Baltimore, MD 21218, USA
</affiliation>
<email confidence="0.993889">
zhifei.work@gmail.com, jason@cs.jhu.edu
</email>
<sectionHeader confidence="0.994708" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999915772727273">
Many statistical translation models can be
regarded as weighted logical deduction.
Under this paradigm, we use weights from
the expectation semiring (Eisner, 2002), to
compute first-order statistics (e.g., the ex-
pected hypothesis length or feature counts)
over packed forests of translations (lat-
tices or hypergraphs). We then introduce
a novel second-order expectation semir-
ing, which computes second-order statis-
tics (e.g., the variance of the hypothe-
sis length or the gradient of entropy).
This second-order semiring is essential for
many interesting training paradigms such
as minimum risk, deterministic anneal-
ing, active learning, and semi-supervised
learning, where gradient descent optimiza-
tion requires computing the gradient of en-
tropy or risk. We use these semirings in an
open-source machine translation toolkit,
Joshua, enabling minimum-risk training
for a benefit of up to 1.0 BLEU point.
</bodyText>
<sectionHeader confidence="0.998783" genericHeader="introduction">
1 Introduction
</sectionHeader>
<bodyText confidence="0.999484769230769">
A hypergraph or “packed forest” (Gallo et al.,
1993; Klein and Manning, 2004; Huang and Chi-
ang, 2005) is a compact data structure that uses
structure-sharing to represent exponentially many
trees in polynomial space. A weighted hypergraph
also defines a probability or other weight for each
tree, and can be used to represent the hypothesis
space considered (for a given input) by a mono-
lingual parser or a tree-based translation system,
e.g., tree to string (Quirk et al., 2005; Liu et al.,
2006), string to tree (Galley et al., 2006), tree to
tree (Eisner, 2003), or string to string with latent
tree structures (Chiang, 2007).
</bodyText>
<footnote confidence="0.9886025">
∗This research was partially supported by the Defense
Advanced Research Projects Agency’s GALE program via
Contract No HR0011-06-2-0001. We are grateful to Sanjeev
Khudanpur for early guidance and regular discussions.
</footnote>
<bodyText confidence="0.999923302325582">
Given a hypergraph, we are often interested in
computing some quantities over it using dynamic
programming algorithms. For example, we may
want to run the Viterbi algorithm to find the most
probable derivation tree in the hypergraph, or the k
most probable trees. Semiring-weighted logic pro-
gramming is a general framework to specify these
algorithms (Pereira and Warren, 1983; Shieber et
al., 1994; Goodman, 1999; Eisner et al., 2005;
Lopez, 2009). Goodman (1999) describes many
useful semirings (e.g., Viterbi, inside, and Viterbi-
n-best). While most of these semirings are used in
“testing” (i.e., decoding), we are mainly interested
in the semirings that are useful for “training” (i.e.,
parameter estimation). The expectation semiring
(Eisner, 2002), originally proposed for finite-state
machines, is one such “training” semiring, and can
be used to compute feature expectations for the E-
step of the EM algorithm, or gradients of the like-
lihood function for gradient descent.
In this paper, we apply the expectation semir-
ing (Eisner, 2002) to a hypergraph (or packed for-
est) rather than just a lattice. We then propose
a novel second-order expectation semiring, nick-
named the “variance semiring.”
The original first-order expectation semiring al-
lows us to efficiently compute a vector of first-
order statistics (expectations; first derivatives) on
the set of paths in a lattice or the set of trees in a
hypergraph. The second-order expectation semir-
ing additionally computes a matrix of second-
order statistics (expectations of products; second
derivatives (Hessian); derivatives of expectations).
We present details on how to compute many in-
teresting quantities over the hypergraph using the
expectation and variance semirings. These quan-
tities include expected hypothesis length, feature
expectation, entropy, cross-entropy, Kullback-
Leibler divergence, Bayes risk, variance of hy-
pothesis length, gradient of entropy and Bayes
risk, covariance and Hessian matrix, and so on.
The variance semiring is essential for many in-
teresting training paradigms such as deterministic
</bodyText>
<page confidence="0.984252">
40
</page>
<note confidence="0.9966215">
Proceedings of the 2009 Conference on Empirical Methods in Natural Language Processing, pages 40–51,
Singapore, 6-7 August 2009. c�2009 ACL and AFNLP
</note>
<bodyText confidence="0.9973788">
annealing (Rose, 1998), minimum risk (Smith and
Eisner, 2006), active and semi-supervised learning
(Grandvalet and Bengio, 2004; Jiao et al., 2006).
In these settings, we must compute the gradient of
entropy or risk. The semirings can also be used for
second-order gradient optimization algorithms.
We implement the expectation and variance
semirings in Joshua (Li et al., 2009a), and demon-
strate their practical benefit by using minimum-
risk training to improve Hiero (Chiang, 2007).
</bodyText>
<sectionHeader confidence="0.851077" genericHeader="method">
2 Semiring Parsing on Hypergraphs
</sectionHeader>
<bodyText confidence="0.99995175">
We use a specific tree-based system called Hiero
(Chiang, 2007) as an example, although the dis-
cussion is general for any systems that use a hy-
pergraph to represent the hypothesis space.
</bodyText>
<subsectionHeader confidence="0.912851">
2.1 Hierarchical Machine Translation
</subsectionHeader>
<bodyText confidence="0.9879745">
In Hiero, a synchronous context-free grammar
(SCFG) is extracted from automatically word-
aligned corpora. An illustrative grammar rule for
Chinese-to-English translation is
</bodyText>
<equation confidence="0.99268">
X — (X0 I n,X1 , X1 of X0 ),
</equation>
<bodyText confidence="0.999985285714286">
where the Chinese word In, means of, and the
alignment, encoded via subscripts on the nonter-
minals, causes the two phrases around In, to be
reordered around of in the translation. Given
a source sentence, Hiero uses a CKY parser to
generate a hypergraph, encoding many derivation
trees along with the translation strings.
</bodyText>
<subsectionHeader confidence="0.981558">
2.2 Hypergraphs
</subsectionHeader>
<bodyText confidence="0.99993525">
Formally, a hypergraph is a pair (V, E), where V
is a set of nodes (vertices) and E is a set of hy-
peredges, with each hyperedge connecting a set of
antecedent nodes to a single consequent node.1 In
parsing parlance, a node corresponds to an item
in the chart (which specifies aligned spans of in-
put and output together with a nonterminal label).
The root node corresponds to the goal item. A
hyperedge represents an SCFG rule that has been
“instantiated” at a particular position, so that the
nonterminals on the right and left sides have been
replaced by particular antecedent and consequent
items; this corresponds to storage of backpointers
in the chart.
We write T(e) to denote the set of antecedent
nodes of a hyperedge e. We write I(v) for the
</bodyText>
<footnote confidence="0.91235">
1Strictly speaking, making each hyperedge designate a
single consequent defines a B-hypergraph (Gallo et al., 1993).
</footnote>
<figureCaption confidence="0.998028">
Figure 1: A toy hypergraph in Hiero. When generating the
</figureCaption>
<bodyText confidence="0.87107605">
hypergraph, a trigram language model is integrated. Rect-
angles represent items, where each item is identified by the
non-terminal symbol, source span, and left- and right-side
language model states. An item has one or more incoming
hyperedges. A hyperedge consists of a rule, and a pointer to
an antecedent item for each non-terminal symbol in the rule.
set of incoming hyperedges of node v (i.e., hyper-
edges of which v is the consequent), which repre-
sent different ways of deriving v. Figure 1 shows
a simple Hiero-style hypergraph. The hypergraph
encodes four different derivation trees that share
some of the same items. By exploiting this shar-
ing, a hypergraph can compactly represent expo-
nentially many trees.
We observe that any finite-state automaton can
also be encoded as a hypergraph (in which every
hyperedge is an ordinary edge that connects a sin-
gle antecedent to a consequent). Thus, the meth-
ods of this paper apply directly to the simpler case
of hypothesis lattices as well.
</bodyText>
<subsectionHeader confidence="0.999058">
2.3 Semiring Parsing
</subsectionHeader>
<bodyText confidence="0.999982411764706">
We assume a hypergraph HG, which compactly
encodes many derivation trees d E D. Given HG,
we wish to extract the best derivations—or other
aggregate properties of the forest of derivations.
Semiring parsing (Goodman, 1999) is a general
framework to describe such algorithms. To define
a particular algorithm, we choose a semiring K
and specify a “weight” ke E K for each hyper-
edge e. The desired aggregate result then emerges
as the total weight of all derivations in the hyper-
graph. For example, to simply count derivations,
one can assign every hyperedge weight 1 in the
semiring of ordinary integers; then each deriva-
tion also has weight 1, and their total weight is the
number of derivations.
We write K = (K, ®, ®, 0,1) for a semiring
with elements K, additive operation ®, multi-
</bodyText>
<figure confidence="0.9638784375">
goal item
S—(XO, X0) S—&apos;(XO, X0)
X—(Xo G J X1, Xp ’S X1)
X—(Xo n Xl, X0 XI)
X 0,2 the mat NA X 3,4 a cat
X 0,4 the mat
x,(kT _., the mat)
M-T0 ±1 n2 rF93
on the mat of a cat
a cat
X—(Xo n Xl, Xl on Xo)
X 0,4 a cat
X—(Xo n Xl, Xl of XO)
X—(N, a cat)
the mat
NA
</figure>
<page confidence="0.999108">
41
</page>
<bodyText confidence="0.9844568">
plicative operation ⊗, additive identity 0, and mul-
tiplicative identity 1. The ⊗ operation is used to
obtain the weight of each derivation d by multi-
plying the weights of its component hyperedges e,
that is, kd = ®eEd ke. The ⊕ operation is used
to sum over all derivations d in the hypergraph
to obtain the total weight of the hypergraph HG,
which is � �eEd ke.2 Figure 2 shows how to
dED
compute the total weight of an acyclic hypergraph
HG.3 In general, the total weight is a sum over
exponentially many derivations d. But Figure 2
sums over these derivations in time only linear on
the size of the hypergraph. Its correctness relies
on axiomatic properties of the semiring: namely,
⊕ is associative and commutative with identity 0,
⊗ is associative with two-sided identity 1, and
⊗ distributes over ⊕ from both sides. The dis-
tributive property is what makes Figure 2 work.
The other properties are necessary to ensure that
</bodyText>
<equation confidence="0.90089">
� �eEd ke is well-defined.4
dED
</equation>
<bodyText confidence="0.995768333333333">
The algorithm in Figure 2 is general and can be
applied with any semiring (e.g., Viterbi). Below,
we present our novel semirings.
</bodyText>
<sectionHeader confidence="0.938803" genericHeader="method">
3 Finding Expectations on Hypergraphs
</sectionHeader>
<bodyText confidence="0.9999105">
We now introduce the computational problems of
this paper and the semirings we use to solve them.
</bodyText>
<subsectionHeader confidence="0.997954">
3.1 Problem Definitions
</subsectionHeader>
<bodyText confidence="0.984169666666667">
We are given a function p : D → R&gt;0, which
decomposes multiplicatively over component hy-
peredges e of a derivation d ∈ D: that is, p(d) def =
</bodyText>
<page confidence="0.479179">
11
</page>
<bodyText confidence="0.87293775">
eEd pe. In practice, p(d) will specify a probabil-
ity distribution over the derivations in the hyper-
2Eisner (2002) uses closed semirings that are also
equipped with a Kleene closure operator *. For example, in
the real semiring (Il2, +, x, 0, 1), we define p* = (1 − p)−1
(= 1 + p + p2 + ...) for |p |&lt; 1 and is undefined other-
wise. The closure operator enables exact summation over the
infinitely many paths in a cyclic FSM, or trees in a hyper-
graph with non-branching cycles, without the need to iterate
around cycles to numerical convergence. For completeness,
we specify the closure operator for our semirings, satisfying
the axioms k* = 1 ® k ® k* = 1 ® k* ® k, but we do not
use it in our experiments since our hypergraphs are acyclic.
3We assume that HG has already been built by deductive
inference (Shieber et al., 1994). But in practice, the nodes’ in-
side weights ,3(v) are usually accumulated as the hypergraph
is being built, so that pruning heuristics can consult them.
4Actually, the notation ®eEd ke assumes that ® is com-
mutative as well, as does the notation “for u E T(e)” in our
algorithms; neither specifies a loop order. One could how-
ever use a non-commutative semiring by ordering each hyper-
edge’s antecedents and specifying that a derivation’s weight
is the product of the weights of its hyperedges when visited in
prefix order. Tables 1–2 will not assume any commutativity.
</bodyText>
<equation confidence="0.5951205">
INSIDE(HG, K)
1 for v in topological order on HG &gt; each node
2 &gt; find ,3(v) — ®eEZ(v)(ke ® (®uET(e) ,3(u)))
3 Q(v) ← 0
4 fore ∈ I(v) &gt; each incoming hyperedge
5 k ← ke &gt; hyperedge weight
6 for u ∈ T(e) &gt; each antecedent node
7 k ← k ⊗ Q(u)
8 Q(v) ← Q(v) ⊕ k
9 return Q(root)
</equation>
<figureCaption confidence="0.9883365">
Figure 2: Inside algorithm for an acyclic hypergraph HG,
which provides hyperedge weights ke E K. This computes
all “inside weights” ,3(v) E K, and returns ,3(root), which is
total weight of the hypergraph, i.e., ®dED ®eEd ke.
</figureCaption>
<equation confidence="0.8270655">
OUTSIDE(HG, K)
1 for v in HG
2 α(v) ← 0
3 α(root) ← 1
4 for v in reverse topological order on HG
5 for e ∈ I(v) &gt; each incoming hyperedge
6 for u ∈ T(e) &gt; each antecedent node
7 α(u) ← α(u) ⊕ (α(v) ⊗ ke⊗
�
8 wET(e),w�=u Q(w))
</equation>
<figureCaption confidence="0.891434666666667">
Figure 3: Computes the “outside weights” α(v). Can only be
run after INSIDE(HG) of Figure 2 has already computed the
inside weights ,3(v).
</figureCaption>
<bodyText confidence="0.99763">
graph. It is often convenient to permit this prob-
ability distribution to be unnormalized, i.e., one
may have to divide it through by some Z to get a
proper distribution that sums to 1.
We are also given two functions of interest r, s :
D → R, each of which decomposes additively
over its component hyperedges e: that is, r(d) def =
EeEd re, and s(d) def = EeEd se.
We are now interested in computing the follow-
ing quantities on the hypergraph HG:
</bodyText>
<equation confidence="0.99981175">
p(d) (1)
p(d)r(d) (2)
p(d)s(d) (3)
p(d)r(d)s(d) (4)
</equation>
<bodyText confidence="0.999785">
Note that r/Z, s/Z, and t/Z are expectations un-
der p of r(d), s(d), and r(d)s(d), respectively.
More formally, the probabilistic interpretation
is that D is a discrete sample space (consisting
</bodyText>
<equation confidence="0.928030529411765">
�Z def =
dED
�
def
r =
dED
s �def =
dED
�t def =
dED
42
INSIDE-OUTSIDE(HG, K, X)
1 D Run inside and outside on HG with only ke weights
2 kˆ +— INSIDE(HG, K) D see Figure 2
3 OUTSIDE(HG, K) D see Figure 3
4 D Do a single linear combination to get x�
5 xˆ+— 0
</equation>
<listItem confidence="0.73153825">
6 for v in HG D each node
7 for e E I(v) D each incoming hyperedge
8 ke +— α(v)
9 for u E T(e) D each antecedent node
</listItem>
<figure confidence="0.683122666666667">
10 ke +— ke Q(u)
11 xˆ +— xˆ + (ke xe)
12 return (ˆk, ˆx)
</figure>
<figureCaption confidence="0.845159">
Figure 4: If every hyperedge specifies a weight (ke, xe) in
some expectation semiring EK,X, then this inside-outside al-
</figureCaption>
<bodyText confidence="0.973797783783784">
gorithm is a more efficient alternative to Figure 2 for comput-
ing the total weight (k, x) of the hypergraph, especially if the
xe are vectors. First, at lines 2–3, the inside and outside al-
gorithms are run using only the ke weights, obtaining only k
(without x) but also obtaining all inside and outside weights
,Q, α ∈ K as a side effect. Then the second component x� of
the total weight is accumulated in lines 5–11 as a linear com-
bination of all the xe values, namely x� = Ee kexe, where
ke is computed at lines 8–10 using α and ,Q weights. The lin-
ear coefficient ke is the “exclusive weight” for hyperedge e,
meaning that the product keke is the total weight in K of all
derivations d ∈ D that include e.
of all derivations in the hypergraph), p is a mea-
sure over this space, and r, s : D — R are ran-
dom variables. Then r/Z and s/Z give the expec-
tations of these random variables, and t/Z gives
the expectation of their product t = rs, so that
t/Z − (r/Z)(s/Z) gives their covariance.
Example 1: r(d) is the length of the translation
corresponding to derivation d (arranged by setting
re to the number of target-side terminal words in
the SCFG rule associated with e). Then r/Z is
the expected hypothesis length. Example 2: r(d)
evaluates the loss of d compared to a reference
translation, using some additively decomposable
loss function. Then r/Z is the risk (expected loss),
which is useful in minimum-risk training. Exam-
ple 3: r(d) is the number of times that a certain
feature fires on d. Then r/Z is the expected fea-
ture count, which is useful in maximum-likelihood
training. We will generalize later in Section 4 to
allow r(d) to be a vector of features. Example 4:
Suppose r(d) and s(d) are identical and both com-
pute hypothesis length. Then the second-order
statistic t/Z is the second moment of the length
distribution, so the variance of hypothesis length
can be found as t/Z − (r/Z)2.
</bodyText>
<subsectionHeader confidence="0.999916">
3.2 Computing the Quantities
</subsectionHeader>
<bodyText confidence="0.999981833333333">
We will use the semiring parsing framework to
compute the quantities (1)–(4). Although each is a
sum over exponentially many derivations, we will
compute it in O(JHGJ) time using Figure 2.
In the simplest case, let K = (R, +, x, 0, 1),
and define ke = pe for each hyperedge e. Then
the algorithm of Figure 2 reduces to the classical
inside algorithm (Baker, 1979) and computes Z.
Next suppose K is the expectation semiring
(Eisner, 2002), shown in Table 1. Define ke =
(pe, pere). Then Figure 2 will return (Z, r).
Finally, suppose K is our novel second-order
expectation semiring, which we introduce in Ta-
ble 2. Define ke = (pe, pere, pese, perese).
Then the algorithm of Figure 2 returns (Z, r, s, t).
Note that, to compute t, one cannot simply con-
struct a first-order expectation semiring by defin-
ing t(d) def = r(d)s(d) because t(d), unlike r(d)
and s(d), is not additively decomposable over the
hyperedges in d.5 Also, when r(d) and s(d) are
identical, the second-order expectation semiring
allows us to compute variance as t/Z − (r/Z)2,
which is why we may call our second-order ex-
pectation semiring the variance semiring.
</bodyText>
<subsectionHeader confidence="0.999758">
3.3 Correctness of the Algorithms
</subsectionHeader>
<bodyText confidence="0.985065">
To prove our claim about the first-order expecta-
tion semiring, we first observe that the definitions
in Table 1 satisfy the semiring axioms. The
reader can easily check these axioms (as well
as the closure axioms in footnote 2). With a
valid semiring, we then simply observe that Fig-
ure 2 returns the total weight ®dED ®eEd ke =
®dED (p(d), p(d)r(d)) = (Z, r). It is easy to
verify the second equality from the definitions
of ®, Z, and r. The first equality requires
proving that ®eEd ke = (p(d), p(d)r(d))
from the definitions of ®, ke, p(d), and r(d).
The main intuition is that ® can be used to
build up (p(d), p(d)r(d)) inductively from the
ke: if d decomposes into two disjoint sub-
derivations d1, d2, then (p(d), p(d)r(d)) =
(p(d1)p(d2),p(d1)p(d2)(r(d1) + r(d2))) =
(p(d1),p(d1)r(d1)) ® (p(d2),p(d2)r(d2)). The
base cases are where d is a single hyperedge e, in
which case (p(d), p(d)r(d)) = ke (thanks to our
choice of ke), and where d is empty, in which case
5However, in a more tricky way, the second-order expec-
tation semiring can be constructed using the first-order ex-
pectation semiring, as will be seen in Section 4.3.
</bodyText>
<page confidence="0.968912">
43
</page>
<equation confidence="0.903646">
Element (p, r)
(p1,r1) ⊗ (p2,r2) (p1p2, p1r2 + p2r1)
(p1, r1) ⊕ (p2, r2) (p1 + p2, r1 + r2)
(p, r)∗ (p∗,p∗p∗r)
0 (0, 0)
1 (1, 0)
</equation>
<tableCaption confidence="0.994742">
Table 1: Expectation semiring: Each element in the semir-
</tableCaption>
<bodyText confidence="0.6557655">
ing is a pair (p, r). The second and third rows define the
operations between two elements (p1, r1) and (p2, r2), and
the last two rows define the identities. Note that the multi-
plicative identity 1 has an r component of 0.
</bodyText>
<figure confidence="0.453695333333333">
a · b
sa·b fa·b
+ fa + fb
- fa + fb
- fa + fb
+ fa + fb
</figure>
<tableCaption confidence="0.993421">
Table 3: Storing signed values in log domain: each value a
</tableCaption>
<bodyText confidence="0.7695715">
(= saeea) is stored as a pair (sa, `a) where sa and `a are the
sign bit of a and natural logarithm of |a|, respectively. This
table shows the operations between two values a = sa2ea
and b = sb2eb, assuming `a ≥ `b. Note: log(1 + x) (where
</bodyText>
<equation confidence="0.93390225">
|x |&lt; 1) should be computed by the Mercator series x −
x2/2+x3/3−· · · , e.g., using the math library function log1p.
(p(d), p(d)r(d)) = 1. It follows by induction that
(p(d),p(d)r(d)) = ®e∈d ke.
</equation>
<bodyText confidence="0.9953905">
The proof for the second-order expec-
tation semiring is similar. In particular,
one mainly needs to show that ®e∈d ke =
(p(d), p(d)r(d), p(d)s(d), p(d)r(d)s(d)).
</bodyText>
<subsectionHeader confidence="0.988156">
3.4 Preventing Underflow/Overflow
</subsectionHeader>
<bodyText confidence="0.971268904761905">
In Tables 1–2, we do not discuss how to store p, r,
s, and t. If p is a probability, it often suffers from
the underflow problem. r, s, and t may suffer from
both underflow and overflow problems, depending
on their scales.
To address these, we could represent p in the
log domain as usual. However, r, s, and t can be
positive or negative, and we cannot directly take
the log of a negative number. Therefore, we repre-
sent real numbers as ordered pairs. Specifically, to
represent a = sae`a, we store (sa, fa), where the
sa ∈ {+, −} is the sign bit of a and the floating-
point number fa is the natural logarithm of |a|.6
Table 3 shows the “·” and “+”operations.
6An alternative that avoids log and exp is to store a =
fa2ea as (fa, ea), where fa is a floating-point number and
ea is a sufficiently wide integer. E.g., combining a 32-bit
fa with a 32-bit ea will in effect extend fa’s 8-bit internal
exponent to 32 bits by adding ea to it. This gives much more
dynamic range than the 11-bit exponent of a 64-bit double-
precision floating-point number, if vastly less than in Table 3.
</bodyText>
<sectionHeader confidence="0.955295" genericHeader="method">
4 Generalizations and Speedups
</sectionHeader>
<bodyText confidence="0.99967325">
In this section, we generalize beyond the above
case where p, r, s are R-valued. In general, p may
be an element of some other semiring, and r and s
may be vectors or other algebraic objects.
When r and s are vectors, especially high-
dimensional vectors, the basic “inside algorithm”
of Figure 2 will be slow. We will show how to
speed it up with an “inside-outside algorithm.”
</bodyText>
<subsectionHeader confidence="0.999782">
4.1 Allowing Feature Vectors and More
</subsectionHeader>
<bodyText confidence="0.9998579">
In general, for P, R, 5, T, we can define the
first-order expectation semiring EP,R = (P ×
R, ⊕, ⊗, 0,1) and the second-order expectation
semiring EP,R,S,T = (P × R × 5 × T, ⊕, ⊗, 0, 1),
using the definitions from Tables 1–2. But do
those definitions remain meaningful, and do they
continue to satisfy the semiring axioms?
Indeed they do when P = R, R = Rn, 5 =
Rm, T = Rn×m, with rs defined as the outer
product rsT (a matrix) where sT is the trans-
pose of s. In this way, the second-order semiring
EP,R,S,T lets us take expectations of vectors and
outer products of vectors. So we can find means
and covariances of any number of linearly decom-
posable quantities (e.g., feature counts) defined on
the hypergraph.
We will consider some other choices in Sec-
tions 4.3–4.4 below. Thus, for generality, we con-
clude this section by stating the precise technical
conditions needed to construct EP,R and EP,R,S,T:
</bodyText>
<listItem confidence="0.9994955">
• P is a semiring
• R is a P-module (e.g, a vector space), mean-
ing that it comes equipped with an associative
and commutative addition operation with an
identity element 0, and also a multiplication
operation P ×R → R, such that p(r1+r2) =
pr1+pr2, (p1+p2)r = p1r+p2r, p1(p2r) =
(p1p2)r
• 5 and T are also P-modules
• there is a multiplication operation R × 5 →
</listItem>
<equation confidence="0.807135">
T that is bilinear, i.e., (r1 + r2)s = r1s +
r2s, r(s1 + s2) = rs1 + rs2, (pr)s = p(rs),
r(ps) = p(rs)
</equation>
<bodyText confidence="0.9995455">
As a matter of notation, note that above and in
Tables 1–2, we overload “+” to denote any of
the addition operations within P, R, 5, T; over-
load “0” to denote their respective additive iden-
tities; and overload concatenation to denote any
of the multiplication operations within or between
</bodyText>
<figure confidence="0.5190681">
sa sb a + b
sa+b fa+b
+ fa + log(1 + e`b−`a)
+ fa + log(1 − e`b−`a)
- fa + log(1 − e`b−`a)
- fa + log(1 + e`b−`a)
+ +
+ -
- +
- -
</figure>
<page confidence="0.886303">
44
</page>
<table confidence="0.916055">
Element (p, r, s, t)
(p1, r1, s1, t1) ® (p2, r2, s2, t2) (p1p2, p1r2 + p2r1, p1s2 + p2s1,
p1t2 + p2t1 + r1s2 + r2s1)
(p1, r1, s1, t1) ® (p2, r2, s2, t2) (p1 + p2, r1 + r2, s1 + s2, t1 + t2)
(p, r, s, t)* (p*, p*p*r, p*p*s, p*p*(p*rs + p*rs + t))
0 (0,0,0,0)
1 (1,0,0,0)
</table>
<tableCaption confidence="0.979481">
Table 2: Second-order expectation semiring (variance semiring): Each element in the semiring is a 4-tuple (p, r, s, t). The
second and third rows define the operations between two elements (p1, r1, s1, t1) and (p2, r2, s2, t2), while the last two rows
define the identities. Note that the multiplicative identity 1 has r,s and t components of 0.
</tableCaption>
<bodyText confidence="0.999433916666667">
P, R, S, T. “1” refers to the multiplicative identity
of P. We continue to use distinguished symbols
®, ®, 0,1 for the operations and identities in our
“main semiring of interest,” EP,R or EP,R,S,T .
To compute equations (1)–(4) in this more gen-
eral setting, we must still require multiplicative
or additive decomposability, defining p(d) def =
HeEd pe, r(d) def EeEd re, s(d) def
EeEd se as be-
fore. But the H and E operators here now denote
appropriate operations within P, R, and S respec-
tively (rather than the usual operations within R).
</bodyText>
<subsectionHeader confidence="0.992291">
4.2 Inside-Outside Speedup for First-Order
Expectation Semirings
</subsectionHeader>
<bodyText confidence="0.999955952380952">
Under the first-order expectation semiring ER,R-,
the inside algorithm of Figure 2 will return (Z, r)
where r is a vector of n feature expectations.
However, Eisner (2002, section 5) observes that
this is inefficient when n is large. Why? The
inside algorithm takes the trouble to compute an
inside weight β(v) E R x Rn for each node v
in the hypergraph (or lattice). The second com-
ponent of β(v) is a presumably dense vector of
all features that fire in all subderivations rooted at
node v. Moreover, as β(v) is computed in lines
3–8, that vector is built up (via the ® and ® oper-
ations of Table 1) as a linear combination of other
dense vectors (the second components of the vari-
ous β(u)). These vector operations can be slow.
A much more efficient approach (usually) is
the traditional inside-outside algorithm (Baker,
1979).7 Figure 4 generalizes the inside-outside
algorithm to work with any expectation semiring
EK,X.8 We are given a hypergraph HG whose
edges have weights (ke, xe) in this semiring (so
</bodyText>
<footnote confidence="0.800385285714286">
7Note, however, that the expectation semiring requires
only the forward/inside pass to compute expectations, and
thus it is more efficient than the traditional inside-outside al-
gorithm (which requires two passes) if we are interested in
computing only a small number of quantities.
8This follows Eisner (2002), who similarly generalized
the forward-backward algorithm.
</footnote>
<bodyText confidence="0.9933892">
now ke E K denotes only part of the edge weight,
not all of it). INSIDE-OUTSIDE(HG, K, X) finds
®dED ®eEd (ke, xe), which has the form ( ˆk, ˆx).
But, INSIDE(HG, EK,X) could accomplish the
same thing. So what makes the inside-outside al-
gorithm more efficient? It turns out that xˆ can
be found quickly as a single linear combination
Ee kexe of just the feature vectors xe that ap-
pear on individual hyperedges—typically a sum
of very sparse vectors! And the linear coefficients
ke, as well as ˆk, are computed entirely within the
cheap semiring K. They are based on β and α val-
ues obtained by first running INSIDE(HG, K) and
OUTSIDE(HG, K), which use only the ke part of
the weights and ignore the more expensive xe.
It is noteworthy that the expectation semiring is
not used at all by Figure 4. Although the return
value (ˆk, ˆx) is in the expectation semiring, it is
built up not by ® and ® but rather by computing
kˆ and xˆ separately. One might therefore wonder
why the expectation semiring and its operations
are still needed. One reason is that the input to
Figure 4 consists of hyperedge weights (ke, xe) in
the expectation semiring—and these weights may
well have been constructed using ® and ®. For
example, Eisner (2002) uses finite-state operations
such as composition, which do combine weights
entirely within the expectation semiring before
their result is passed to the forward-backward al-
gorithm. A second reason is that when we work
with a second-order expectation semiring in Sec-
tion 4.4 below, the ˆk, β, and α values in Figure 4
will turn out to be elements of a first-order expec-
tation semiring, and they must still be constructed
by first-order ® and ®, via calls to Figures 2–3.
Why does inside-outside work? Whereas the
inside algorithm computes ®dED ®eEd in any
semiring, the inside-outside algorithm exploits
the special structure of an expectation semir-
ing. By that semiring’s definitions of ® and �
</bodyText>
<equation confidence="0.5630845">
(Table 1), � �eEd (ke, xe) can be found as
dED
</equation>
<page confidence="0.972121">
45
</page>
<bodyText confidence="0.904438">
( PdED QeEd ke, PdED PeEd(Qe0Ed,e0�e ke0)xe).
The first component (giving ˆk) is found
by calling the inside algorithm on just the
ke part of the weights. The second com-
ponent (giving ˆx) can be rearranged into
Pe Pd: eEd(Q7e&apos;&apos;Ed,e0�e ke0)xe = Pe kexe, where
ke def Pd: eEd (l le0Ed,e0�e ke0) is found from Q, α.
The application described at the start of this
subsection is the classical inside-outside algo-
rithm. Here (ke,xe) def = (pe, pere), and the al-
gorithm returns (ˆk, ˆx) = (Z, r). In fact, that
</bodyText>
<equation confidence="0.80281775">
xˆ = r can be seen directly: r = Pd p(d)r(d) =
Pd p(d)(PeEd re) = Pe Pd: eEd p(d)re
Pe(keke)re = Pe kexe = ˆx. This uses the fact
that keke = Pd: eEd p(d).
</equation>
<subsectionHeader confidence="0.987048">
4.3 Lifting Trick for Second-Order Semirings
</subsectionHeader>
<bodyText confidence="0.998455380952381">
We now observe that the second-order expectation
semiring EP,R,S,T can be obtained indirectly by
nesting one first-order expectation semiring inside
another! First “lift” P to obtain the first-order ex-
pectation semiring K def = EP,R. Then lift this a sec-
ond time to obtain the “nested” first-order expec-
tation semiring EK,X = E(EP,R),(SxT), where we
equip Xdef = 5 x T with the operations (s1, t1) +
(s2, t2) def = (s1 + s2, t1 + t2) and (p, r)(s, t) def =
(ps, pt + rs). The resulting first-order expectation
semiring has elements of the form ((p, r), (s, t)).
Table 4 shows that it is indeed isomorphic to
EP,R,S,T, with corresponding elements (p, r, s, t).
This construction of the second-order semiring
as a first-order semiring is a useful bit of abstract
algebra, because it means that known properties
of first-order semirings will also apply to second-
order ones. First of all, we are immediately guar-
anteed that the second-order semiring satisfies the
semiring axioms. Second, we can directly apply
the inside-outside algorithm there, as we now see.
</bodyText>
<subsectionHeader confidence="0.98615">
4.4 Inside-Outside Speedup for
Second-Order Expectation Semirings
</subsectionHeader>
<bodyText confidence="0.99903516">
Given a hypergraph weighted by a second-order
expectation semiring EP,R,S,T. By recasting this
as the first-order expectation semiring EK,X where
K = EP,R and X = (5 x T), we can again ap-
ply INSIDE-OUTSIDE(HG, K, X) to find the total
weight of all derivations.
For example, to speed up Section 3.2, we
may define (ke, xe) = ((pe,pere), (pese,perese))
for each hyperedge e. Then the inside-outside
algorithm of Figure 4 will compute (ˆk, ˆx) =
((Z, r), (s, t)), more quickly than the inside algo-
rithm of Figure 2 computed (Z, r, s, t).
Figure 4 in this case will run the inside and
outside algorithms in the semiring EP,R, so that
ke, ˆk, α, Q, and ke will now be elements of P x R
(not just elements of P as in the first-order case).
Finally it finds xˆ = Pe kexe, where xe E 5 x T.9
This is a particularly effective speedup over
the inside algorithm when R consists of scalars
(or small vectors) whereas 5, T are sparse high-
dimensional vectors. We will see exactly this case
in our experiments, where our weights (p, r, s, t)
denote (probability, risk, gradient of probability,
gradient of risk), or (probability, entropy, gradient
of probability, gradient of entropy).
</bodyText>
<sectionHeader confidence="0.97114" genericHeader="method">
5 Finding Gradients on Hypergraphs
</sectionHeader>
<bodyText confidence="0.963389961538461">
In Sections 3.2 and 4.1, we saw how our semirings
helped find the sum Z of all p(d), and compute
expectations r, s, t of r(d), s(d), and r(d)s(d).
It turns out that these semirings can also com-
pute first- and second-order partial derivatives of
all the above results, with respect to a parameter
vector B E Rm. That is, we ask how they are
affected when B changes slightly from its current
value. The elementary values pe, re, se are now
assumed to implicitly be functions of B.
Case 1: Recall that Z def = Pd p(d) is com-
puted by INSIDE(HG, R) if each hyperedge e has
weight pe. “Lift” this weight to (pe, Vpe), where
Vpe E Rm is a gradient vector. Now (Z, VZ) will
be returned by INSIDE(HG, ER,Rm)— or, more
efficiently, by INSIDE-OUTSIDE(HG, R, Rm).
Case 2: To differentiate a second
time, “lift” the above weights again
to obtain ((pe, Vpe), V(pe, Vpe))
((pe,Vpe), (Vpe, V2pe)), where V2pe E Rmxm
is the Hessian matrix of second-order mixed
partial derivatives. These weights are in a
second-order expectation semiring.10 Now
9Figure 4 was already proved generally correct in Sec-
tion 4.2. To understand more specifically how (s, t) gets
computed, observe in analogy to the end of Section 4.2 that
</bodyText>
<equation confidence="0.921580571428571">
(s, t) = Pd (p(d)s(d), p(d)r(d)s(d))
= Pd (p(d), p(d)r(d)) (s(d), 0)
= E� /te`d (p(d), p(d)r(d)) Pe∈d (se, 0)
Ee Ed: e∈d (p(d), p(d)r(d)) (se, 0)
= [&amp;(keke)(se, 0) = Pe ke(pe, pere) (se, 0)
L
= e ke(pese, perese) = Pe kexe = ˆx.
</equation>
<bodyText confidence="0.7908906">
10Modulo the trivial isomorphism from ((p, r), (s, t)) to
(p, r, s, t) (see Section 4.3), the intended semiring both here
and in Case 3 is the one that was defined at the start of Sec-
tion 4.1, in which r, s are vectors and their product is defined
=
</bodyText>
<page confidence="0.838112">
46
</page>
<equation confidence="0.99952125">
((p1,r1),(s1,t1)) ® ((p2,r2),(s2,t2)) = ((p1,r1) + (p2, r2), (s1, t1) + (s2, t2))
= ((p1 + p2, r1 + r2), (s1 + s2, t1 + t2))
((p1,r1),(s1,t1)) ® ((p2,r2),(s2,t2)) = ((p1, r1)(p2, r2), (p1, r1)(s2, t2) + (p2,r2)(s1,t1))
= ((p1p2, p1r2 + p2r1), (p1s2 + p2s1, p1t2 + p2t1 + r1s2 + r2s1))
</equation>
<tableCaption confidence="0.867467666666667">
Table 4: Constructing second-order expectation semiring as first-order. Here we show that the operations in EK,X are
isomorphic to Table 2’s operations in EP,R,S,T, provided that K def= EP,R and X def= S x T is a K-module, in which addition is
defined by(s1, t1) + (s2, t2) def= (s1 + s2, t1 + t2), and left-multiplication by K is defined by (p, r)(s, t) def= (ps, pt + rs).
</tableCaption>
<bodyText confidence="0.952308888888889">
(Z, VZ, VZ, V2Z) will be returned by
INSIDE(HG, ER,R—,R—,R—x—), or more effi-
ciently by INSIDE-OUTSIDE(HG, ER,R—, Rm x
Rm×m).
Case 3: Our experiments will need to find ex-
pectations and their partial derivatives. Recall that
(Z, r) is computed by INSIDE(HG, ER,Rn) when
the edge weights are (pe, pere) with re E Rn. Lift
these weights to ((pe,pere),V(pe,pere)) =
</bodyText>
<equation confidence="0.7531113">
((pe, pere), (Vpe, (Vpe)re + pe(Vre))).
Now (Z, r, VZ, Vr) will be returned
by INSIDE(HG, ER,Rn,R—,Rnx—) or by
INSIDE-OUTSIDE(HG, ER,Rn, Rm
x Rn×m).11
compute
+
in multiplication simply as 2
if n &gt; m, it is faster to instead use
x
</equation>
<bodyText confidence="0.9410073">
swapping the
second and third components of the 4-tuple and trans-
posing the matrix in the fourth component. Alge-
braically, this changes nothing because
and
are isomorphic, thanks to symmetries in Ta-
ble 2. This method computes the expectation of the gradient
rather than the gradient of the expectation—they are equal.
relied on the fact that this relationship still
holds even when the scalars Z,
</bodyText>
<equation confidence="0.592575">
E
</equation>
<bodyText confidence="0.719016">
are replaced by more
complex objects that we wish to differentiate. Our discus-
sion below sticks to the scalar case for simplicity, but would
generalize fairly straightforwardly.
</bodyText>
<figure confidence="0.418111952380952">
and Siskind
(2007) give the relevan
r1s2
s1r2
·r1r2.11Or,
INSIDE-OUTSIDE(HG,EK,Km,Rn
R—xn),
EK,Kn,KmxKn×m
EK,Km,KnxKm×n
12Cases2–3
pe
R
Pearlmutter
t generalizations of dual numbers.
5.1 What Connects Gradients to Expectations?
In Case 1, we claimed that the same algorithm
will compute either gradients (Z,
or expec-
tations (Z, r), if the hyperedge weights are set to
or
This may
</figure>
<bodyText confidence="0.9335413">
seem wonderful and mysterious. We now show in
two distinct ways why this follows from our setup
of Section 3.1. At the end, we derive as a special
case the well-known relationship between gradi-
ents and expectations in log-linear models.
From Expectations to Gradients One perspec-
tive is that our
fundamentally finds ex-
pectations. Thus, we must be finding VZ by for-
mulating it as a certain expectation r. Specif-
</bodyText>
<equation confidence="0.9806055">
ically, VZ = V
VZ)
(pe,Vpe)
(pe,pere)respectively.12
semiring
Pdp(d)=PdVp(d) =
</equation>
<bodyText confidence="0.821972">
to be rsT, a matrix. However, when using this semiring to
compute second derivatives (Case 2) or covariances, one may
exploit the invariant that r = s, e.g., to avoid storing s and to
</bodyText>
<page confidence="0.893805">
47
</page>
<figure confidence="0.768852802631579">
p(d)r(d) = r, provided that r(d)
(Vp(d))/p(d). That can be arranged by defining
that is why the input weights
take the form
From Gradients to Expectations An alterna-
tive perspective is that our
fundamen-
tally finds gradients. Indeed, pairs like (p,
have long been used for this purpose (Clifford,
1873) under the name
Oper-
ations on dual numbers, including those in Ta-
ble 1, compute a result in
along with its gradi-
ent. For example, our ®multiplies dual numbers,
since
+
The inside algo-
rithm thus computes both Z and VZ in a single
or
pass—known as automatic
differentiation in the forward mode. The inside-
outside algorithm instead uses the reverse mode
(a.k.a. back-propagation), where a separate
or
pass is used to compute VZ.
How can we modify this machinery to pro-
duce expectations
given some arbitrary
of interest? Automatic differentiation may
be used on any function (e.g., a neural net),
but for our simple sum-of-products function
Z, it happens that
= V(
d
e
)
d
e
d(
e&apos;
d,e&apos;
e
e&apos;)V
e
Our trick is to
surreptitiously replace the
in the input
weights
with
Then the output
changes similarly:
� the algorithms will instead
find
d
e
d(lle&apos;
d,e&apos;
e pe&apos;)p
r
which re-
duces to
d
e
d
(d)re
d
(d)
e
d re
d p(d)r(d) =
Log-linear Models as a Special Case Replac-
ing
with
is unnecessary if
already
</figure>
<footnote confidence="0.3981478">
equals
That is the case in log-linear models,
B) for some feature vector
associated with e. So there,
already
</footnote>
<equation confidence="0.956240545454546">
P
d
=
def
re =(Vpe)/pe.13So
(pe,pere)
(pe,Vpe).
semiring
Vp)
“dualnumbers.”
R
(p1,Vp1)® (p2,Vp2)=(p1p2,p1(Vp2)
(Vp1)p2)=(p1p2,V(p1p2)).
“forward”
“inside”
“back-
ward”
“outside”
r¯
re
VZ
P
Q
e
=P
P
∈
Q
∈
6=
p
p
.
Vpe
(pe,Vpe)
pere.
P
P
∈
∈
6=
e
e,
P
P
∈
p
=P
p
P
∈
=
P
¯r.
Vpe
</equation>
<bodyText confidence="0.8605758">
pere
Vpe
pere.
def
where pe =exp(re·
</bodyText>
<equation confidence="0.909965647058823">
re
VZ
equals
¯r—yielding a key useful property of log-linear
r(d)
re
13Proof:
=EeEd
=EeEd(Ope)/pe =
EeEd
=
EeEd
=
O log pe
O
log pe=O log11eEd pe
O log p(d)=(Op(d))/p(d).
</equation>
<bodyText confidence="0.996972">
models, that V log Z = (VZ)/Z = ¯r/Z, the vec-
tor of feature expectations (Lau et al., 1993).
</bodyText>
<sectionHeader confidence="0.96669" genericHeader="method">
6 Practical Applications
</sectionHeader>
<bodyText confidence="0.9999834">
Given a hypergraph HG whose hyperedges e are
annotated with values pe. Recall from Section 3.1
that this defines a probability distribution over all
derivations d in the hypergraph, namely p(d)/Z
where p(d) def = 11eEd pe.
</bodyText>
<subsectionHeader confidence="0.991751">
6.1 First-Order Expectation Semiring ]ER,R
</subsectionHeader>
<bodyText confidence="0.992788047619048">
In Section 3, we show how to compute the ex-
pected hypothesis length or expected feature
counts, using the algorithm of Figure 2 with a
first-order expectation semiring ER,R. In general,
given hyperedge weights (pe, pere), the algorithm
computes (Z, r) and thus r/Z, the expectation of
r(d) def = EeEd re. We now show how to compute a
few other quantities by choosing re appropriately.
Entropy on a Hypergraph The entropy of the
distribution of derivations in a hypergraph14 is
where the first term Zq can be computed using
the inside algorithm with hyperedge weights qe,
and the numerator and denominator of the sec-
ond term using an expectation semiring with hy-
def
peredge weights (pe, pere) with re = log qe.
The KL divergence to p from q can be computed
as KL(p II q) = H(p, q) − H(p).
Expected Loss (Risk) Given a reference sen-
tence y*, the expected loss (i.e., Bayes risk) of the
hypotheses in the hypergraph is defined as,
</bodyText>
<equation confidence="0.9859515">
R(p) = � (p(d)/Z)L(Y(d), y*) (7)
dED
</equation>
<bodyText confidence="0.999962125">
where Y(d) is the target yield of d and L(y, y*) is
the loss of the hypothesis y with respect to the ref-
erence y*. The popular machine translation met-
ric, BLEU (Papineni et al., 2001), is not additively
decomposable, and thus we are not able to com-
pute the expected loss for it. Tromble et al. (2008)
develop the following loss function, of which a lin-
ear approximation to BLEU is a special case,
</bodyText>
<equation confidence="0.97515">
� (p(d)/Z) log(p(d)/Z) (5) � θw#w(y)δw(y*)) (8)
H(p) = − L(y, y*) = −(θ0|y |+
dED wEN
1 �
= log Z −
Z
dED
1 �
= log Z −
Z
dED
def
</equation>
<bodyText confidence="0.999488">
provided that we define re = log pe (so that
r(d) = EeEd re = log p(d)). Of course, we can
compute (Z, r) as explained in Section 3.2.
Cross-Entropy and KL Divergence We may
be interested in computing the cross-entropy or
KL divergence between two distributions p and q.
For example, in variational decoding for machine
translation (Li et al., 2009b), p is a distribution
represented by a hypergraph, while q, represented
by a finite state automaton, is an approximation to
p. The cross entropy between p and q is defined as
</bodyText>
<equation confidence="0.990696888888889">
H(p, q) = − � (p(d)/Zp)log(q(d)/Zq) (6)
dED
1
= log Zq − Z I: p(d) log q(d)
p dED
= log Zq − Z 1 L p(d)r(d) = r
log ZQ —
P Zp
dED
</equation>
<bodyText confidence="0.881859">
14Unfortunately, it is intractable to compute the entropy of
the distribution over strings (each string’s probability is a sum
over several derivations). But Li et al. (2009b, section 5.4) do
estimate the gap between derivational and string entropies.
where w is an n-gram type, N is a set of n-gram
types with n E [1, 4], #w(y) is the number of oc-
currence of the n-gram w in y, δw(y*) is an indica-
tor to check if y* contains at least one occurrence
of w, and θn is the weight indicating the relative
importance of an n-gram match. If the hypergraph
is already annotated with n-gram (n &gt; 4) lan-
guage model states, this loss function is additively
def
decomposable. Using re = Le where Le is the
loss for a hyperedge e, we compute the expected
loss,
</bodyText>
<subsectionHeader confidence="0.999758">
6.2 Second-Order Expectation Semirings
</subsectionHeader>
<bodyText confidence="0.9998463">
With second-order expectation semirings, we can
compute from a hypergraph the expectation and
variance of hypothesis length; the feature expec-
tation vector and covariance matrix; the Hessian
(matrix of second derivatives) of Z; and the gradi-
ents of entropy and expected loss. The computa-
tions should be clear from earlier discussion. Be-
low we compute gradient of entropy or Bayes risk.
Gradient of Entropy or Risk It is easy to see
that the gradient of entropy (5) is
</bodyText>
<equation confidence="0.998692166666666">
p(d) log p(d)
r
p(d)r(d) = log Z −
Z
R(p) =
EdED p(d)L(Y(d), y*) r =
Z Z (9)
VH(p)
VZ ZVr − rVZ =
−
Z
Z2 (10)
</equation>
<page confidence="0.989877">
48
</page>
<bodyText confidence="0.971292125">
We may compute (Z, r, VZ, Vr) as ex-
plained in Case 3 of Section 5 by using
defdef
ke = (pe,pere,Vpe, (Vpe)re + peVre) =
(pe,pe log pe, Vpe, (1 + log pe)Vpe), where Vpe
depends on the particular parameterization of the
model (see Section 7.1 for an example).
Similarly, the gradient of risk of (9) is
</bodyText>
<equation confidence="0.90565375">
ZVr − rVZ
VR(p) = (11)
Z2
def
</equation>
<bodyText confidence="0.902656">
We may compute (Z, r, VZ, Vr) using ke =
(pe, peLe, Vpe, LeVpe).
</bodyText>
<sectionHeader confidence="0.959047" genericHeader="method">
7 Minimum-Risk Training for MT
</sectionHeader>
<bodyText confidence="0.9998755">
We now show how we improve the training of a
Hiero MT model by optimizing an objective func-
tion that includes entropy and risk. Our objective
function could be computed with a first-order ex-
pectation semiring, but computing it along with its
gradient requires a second-order one.
</bodyText>
<subsectionHeader confidence="0.731614">
7.1 The Model p
</subsectionHeader>
<bodyText confidence="0.9999035">
We assume a globally normalized linear model
for its simplicity. Each derivation d is scored by
</bodyText>
<equation confidence="0.79742475">
� 4bi(d) θi (12)
def
score(d) = 4b(d) · θ =
i
</equation>
<bodyText confidence="0.9999645">
where 4b(d) E RI is a vector of features of d. We
then define the unnormalized distribution p(d) as
</bodyText>
<equation confidence="0.991458">
p(d) = exp(γ · score(d)) (13)
</equation>
<bodyText confidence="0.9999635">
where the scale factor γ adjusts how sharply the
distribution favors the highest-scoring hypotheses.
</bodyText>
<subsectionHeader confidence="0.987565">
7.2 Minimum-Risk Training
</subsectionHeader>
<bodyText confidence="0.9806235">
Adjusting θ or γ changes the distribution p. Mini-
mum error rate training (MERT) (Och, 2003) tries
to tune θ to minimize the BLEU loss of a decoder
that chooses the most probable output according
to p. (γ has no effect.) MERT’s specialized line-
search addresses the problem that this objective
function is piecewise constant, but it does not scale
to a large number of parameters.
Smith and Eisner (2006) instead propose a dif-
ferentiable objective that can be optimized by gra-
dient descent: the Bayes risk R(p) of (7). This is
the expected loss if one were (hypothetically) to
use a randomized decoder, which chooses a hy-
pothesis d in proportion to its probability p(d). If
entropy H(p) is large (e.g., small γ), the Bayes risk
is smooth and has few local minima. Thus, Smith
and Eisner (2006) try to avoid local minima by
starting with large H(p) and decreasing it gradu-
ally during optimization. This is called determin-
istic annealing (Rose, 1998). As H(p) —* 0 (e.g.,
large γ), the Bayes risk does approach the MERT
objective (i.e. minimizing 1-best error).The objec-
tive is
minimize R(p) − T · H(p) (14)
where the “temperature” T starts high and is ex-
plicitly decreased as optimization proceeds.
</bodyText>
<subsectionHeader confidence="0.984712">
7.3 Gradient Descent Optimization
</subsectionHeader>
<bodyText confidence="0.999551111111111">
Solving (14) for a given T requires computing the
entropy H(p) and risk R(p) and their gradients
with respect to θ and γ. Smith and Eisner (2006)
followed MERT in constraining their decoder to
only an n-best list, so for them, computing these
quantities did not involve dynamic programming.
We compare those methods to training on a hy-
pergraph containing exponentially many hypothe-
ses. In this condition, we need our new second-
order semiring methods and must also approxi-
mate BLEU (during training only) by an additively
decomposable loss (Tromble et al., 2008).15
Our algorithms require that p(d) of (13) is mul-
tiplicatively decomposable. It suffices to define
4b(d) def = Ee∈d 4be, so that all features are local
to individual hyperedges; the vector 4be indicates
which features fire on hyperedge e. Then score(d)
of (12) is additively decomposable:
</bodyText>
<equation confidence="0.943471">
�score(d) = �scoree = 4be · θ (15)
e∈d e∈d
</equation>
<bodyText confidence="0.999546777777778">
We can then set pe = exp(γ · scoree), and Vpe =
γpe4b(e), and use the algorithms described in Sec-
tion 6 to compute H(p) and R(p) and their gradi-
ents with respect to θ and γ.16
15Pauls et al. (2009) concurrently developed a method to
maximize the expected n-gram counts on a hypergraph using
gradient descent. Their objective is similar to the minimum
risk objective (though without annealing), and their gradient
descent optimization involves in algorithms in computing ex-
pected feature/n-gram counts as well as expected products of
features and n-gram counts, which can be viewed as instances
of our general algorithms with first- and second-order semir-
ings. They focused on tuning only a small number (i.e. nine)
of features as in a regular MERT setting, while our experi-
ments involve both a small and a large number of features.
16It is easy to verify that the gradient of a function f (e.g.
entropy or risk) with respect to γ can be written as a weighted
sum of gradients with respect to the feature weights θi, i.e.
</bodyText>
<equation confidence="0.7553245">
= 1 θi × ae (16)
γ i i
</equation>
<page confidence="0.868981333333333">
∂f
∂ry
49
</page>
<subsectionHeader confidence="0.5102695">
7.4 Experimental Results
7.4.1 Experimental Setup
</subsectionHeader>
<bodyText confidence="0.999938833333333">
We built a translation model on a corpus for
IWSLT 2005 Chinese-to-English translation task
(Eck and Hori, 2005), which consists of 40k pairs
of sentences. We used a 5-gram language model
with modified Kneser-Ney smoothing, trained on
the bitext’s English using SRILM (Stolcke, 2002).
</bodyText>
<subsectionHeader confidence="0.967833">
7.4.2 Tuning a Small Number of Features
</subsectionHeader>
<bodyText confidence="0.999971739130435">
We first investigate how minimum-risk training
(MR), with and without deterministic annealing
(DA), performs compared to regular MERT. MR
without DA just fixes T = 0 and γ = 1 in (14).
All MR or MR+DA uses an approximated BLEU
(Tromble et al., 2008) (for training only), while
MERT uses the exact corpus BLEU in training.
The first five rows in Table 5 present the results
by tuning the weights offive features (θ ∈ R5). We
observe that MR or MR+DA performs worse than
MERT on the dev set. This may be mainly because
MR or MR+DA uses an approximated BLEU while
MERT doesn’t. On the test set, MR or MR+DA
on an n-best list is comparable to MERT. But our
new approach, MR or MR+DA on a hypergraph,
does consistently better (statistically significant)
than MERT, despite approximating BLEU.17
Did DA help? For both n-best and hypergraph,
MR+DA did obtain a better BLEU score than plain
MR on the dev set.18 This shows that DA helps
with the local minimum problem, as hoped. How-
ever, DA’s improvement on the dev set did not
transfer to the test set.
</bodyText>
<subsectionHeader confidence="0.890533">
7.4.3 Tuning a Large Number of Features
</subsectionHeader>
<bodyText confidence="0.999937333333333">
MR (with or without DA) is scalable to tune a
large number of features, while MERT is not. To
achieve competitive performance, we adopt a for-
est reranking approach (Li and Khudanpur, 2009;
Huang, 2008). Specifically, our training has two
stages. In the first stage, we train a baseline system
as usual. We also find the optimal feature weights
for the five features mentioned before, using the
method of MR+DA operating on a hypergraph. In
the second stage, we generate a hypergraph for
each sentence in the training data (which consists
of about 40k sentence pairs), using the baseline
</bodyText>
<footnote confidence="0.9964322">
17Pauls et al. (2009) concurrently observed a similar pat-
tern (i.e., MR performs worse than MERT on the dev set, but
performs better on a test set).
18We also verified that MR+DA found a better objective
value (i.e., expected loss on the dev set) than MR.
</footnote>
<table confidence="0.999573142857143">
Training scheme dev test
MERT (Nbest, small) 42.6 47.7
MR (Nbest, small) 40.8 47.7
MR+DA (Nbest, small) 41.6 47.8
MR (hypergraph, small) 41.3 48.4
MR+DA (hypergraph, small) 41.9 48.3
MR (hypergraph, large) 42.3 48.7
</table>
<tableCaption confidence="0.995925">
Table 5: BLEU scores on the Dev and test sets under different
</tableCaption>
<bodyText confidence="0.934277571428571">
training scenarios. In the “small” model, five features (i.e.,
one for the language model, three for the translation model,
and one for word penalty) are tuned. In the “large” model,
21k additional unigram and bigram features are used.
system. In this stage, we add 21k additional uni-
gram and bigram target-side language model fea-
tures (cf. Li and Khudanpur (2008)). For example,
a specific bigram “the cat” can be a feature. Note
that the total score by the baseline system is also
a feature in the second-stage model. With these
features and the 40k hypergraphs, we run the MR
training to obtain the optimal weights.
During test time, a similar procedure is fol-
lowed. For a given test sentence, the baseline sys-
tem first generates a hypergraph, and then the hy-
pergraph is reranked by the second-stage model.
The last row in Table 5 reports the BLEU scores.
Clearly, adding more features improves (statisti-
cally significant) the case with only five features.
We plan to incorporate more informative features
described by Chiang et al. (2009).19
</bodyText>
<sectionHeader confidence="0.99934" genericHeader="conclusions">
8 Conclusions
</sectionHeader>
<bodyText confidence="0.999815">
We presented first-order expectation semirings
and inside-outside computation in more detail
than (Eisner, 2002), and developed extensions to
higher-order expectation semirings. This enables
efficient computation of many interesting quanti-
ties over the exponentially many derivations en-
coded in a hypergraph: second derivatives (Hes-
sians), expectations of products (covariances), and
expectations such as risk and entropy along with
their derivatives. To our knowledge, algorithms
for these problems have not been presented before.
Our approach is theoretically elegant, like other
work in this vein (Goodman, 1999; Lopez, 2009;
Gimpel and Smith, 2009). We used it practically to
enable a new form of minimum-risk training that
improved Chinese-English MT by 1.0 BLEU point.
Our implementation will be released within the
open-source MT toolkit Joshua (Li et al., 2009a).
</bodyText>
<footnote confidence="0.830002666666667">
19Their MIRA training tries to favor a specific oracle
translation—indeed a specific tree—from the (pruned) hyper-
graph. MR does not commit to such an arbitrary choice.
</footnote>
<figure confidence="0.816586">
NEW!
NEW!
NEW!
</figure>
<page confidence="0.979162">
50
</page>
<sectionHeader confidence="0.992331" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999831754237288">
J. K. Baker. 1979. Trainable grammars for speech
recognition. In Jared J. Wolf and Dennis H. Klatt,
editors, Speech Communication Papers Presented at
the 97th Meeting of the Acoustical Society of Amer-
ica, MIT, Cambridge, MA, June.
David Chiang, Kevin Knight, and Wei Wang. 2009.
11,001 new features for statistical machine transla-
tion. In NAACL, pages 218–226.
David Chiang. 2007. Hierarchical phrase-based trans-
lation. Computational Linguistics, 33(2):201–228.
W. K. Clifford. 1873. Preliminary sketch of bi-
quaternions. Proceedings of the London Mathemat-
ical Society, 4:381–395.
Matthias Eck and Chiori Hori. 2005. Overview of the
iwslt 2005 evaluation campaign. In In Proc. of the
International Workshop on Spoken Language Trans-
lation.
Jason Eisner, Eric Goldlust, and Noah A. Smith.
2005. Compiling comp ling: practical weighted
dynamic programming and the dyna language. In
HLT/EMNLP, pages 281–290.
Jason Eisner. 2002. Parameter estimation for proba-
bilistic finite-state transducers. In ACL, pages 1–8.
Jason Eisner. 2003. Learning non-isomorphic tree
mappings for machine translation. In ACL, pages
205–208.
Michel Galley, Jonathan Graehl, Kevin Knight, Daniel
Marcu, Steve DeNeefe, Wei Wang, and Ignacio
Thayer. 2006. Scalable inference and training of
context-rich syntactic translation models. In ACL,
pages 961–968.
Giorgio Gallo, Giustino Longo, Stefano Pallottino, and
Sang Nguyen. 1993. Directed hypergraphs and ap-
plications. Discrete Appl. Math., 42(2-3):177–201.
Kevin Gimpel and Noah A. Smith. 2009. Cube
summing, approximate inference with non-local fea-
tures, and dynamic programming without semirings.
In EACL, pages 318–326.
Joshua Goodman. 1999. Semiring parsing. Computa-
tional Linguistics, 25(4):573–605.
Y Grandvalet and Y Bengio. 2004. Semi-supervised
learning by entropy minimization. In NIPS, pages
529–536.
Liang Huang and David Chiang. 2005. Better k-best
parsing. In IWPT, pages 53–64.
Liang Huang. 2008. Forest reranking: Discriminative
parsing with non-local features. In ACL, pages 586–
594.
Feng Jiao, Shaojun Wang, Chi-Hoon Lee, Russell
Greiner, and Dale Schuurmans. 2006. Semi-
supervised conditional random fields for improved
sequence segmentation and labeling. In ACL, pages
209–216.
Dan Klein and Christopher D. Manning. 2004. Pars-
ing and hypergraphs. New developments in parsing
technology, pages 351–372.
Raymond Lau, Ronald Rosenfeld, and Salim Roukos.
1993. Adaptive language modelling using the maxi-
mum entropy principle. In Proc. ARPA Human Lan-
guage Technologies Workshop, pages 81–86.
Zhifei Li and Sanjeev Khudanpur. 2008. Large-scale
discriminative n-gram language models for statisti-
cal machine translation. In AMTA, pages 133–142.
Zhifei Li and Sanjeev Khudanpur. 2009. Forest
reranking for machine translation with the percep-
tron algorithm. In GALE book chapter on ”MT
From Text”.
Zhifei Li, Chris Callison-Burch, Chris Dyer, Juri
Ganitkevitch, Sanjeev Khudanpur, Lane Schwartz,
Wren Thornton, Jonathan Weese, and Omar. Zaidan.
2009a. Joshua: An open source toolkit for parsing-
based machine translation. In WMT09, pages 26–30.
Zhifei Li, Jason Eisner, and Sanjeev Khudanpur.
2009b. Variational decoding for statistical machine
translation. In ACL.
Yang Liu, Qun Liu, and Shouxun Lin. 2006. Tree-
to-string alignment template for statistical machine
translation. In ACL, pages 609–616.
Adam Lopez. 2009. Translation as weighted deduc-
tion. In EACL, pages 532–540.
Franz Josef Och. 2003. Minimum error rate training in
statistical machine translation. In ACL, pages 160–
167.
Kishore Papineni, Salim Roukos, Todd Ward, and Wei-
Jing Zhu. 2001. BLEU: A method for automatic
evaluation of machine translation. In ACL, pages
311–318.
Adam Pauls, John DeNero, and Dan Klein. 2009. Con-
sensus training for consensus decoding in machine
translation. In EMNLP.
B. A. Pearlmutter and J. M. Siskind. 2007. Lazy mul-
tivariate higher-order forward-mode ad. In Proceed-
ings of the 34th Annual Symposium on Principles of
Programming Languages (POPL), pages 155–160.
Fernando C. N. Pereira and David H. D. Warren. 1983.
Parsing as deduction. In ACL, pages 137–144.
Chris Quirk, Arul Menezes, and Colin Cherry. 2005.
Dependency treelet translation: syntactically in-
formed phrasal smt. In ACL, pages 271–279.
Kenneth Rose. 1998. Deterministic annealing for clus-
tering, compression, classification, regression, and
related optimization problems. In Proceedings of
the IEEE, pages 2210–2239.
Stuart M. Shieber, Yves Schabes, and Fernando C. N.
Pereira. 1994. Principles and implementation of
deductive parsing. Journal of Logic Programming,
24:3–36.
David A. Smith and Jason Eisner. 2006. Minimum risk
annealing for training log-linear models. In ACL,
pages 787–794.
Andreas Stolcke. 2002. SRILM—an extensible lan-
guage modeling toolkit. In Proceedings of the Inter-
national Conference on Spoken Language Process-
ing, pages 901–904.
Roy Tromble, Shankar Kumar, Franz Och, and Wolf-
gang Macherey. 2008. Lattice minimum-Bayes-
risk decoding for statistical machine translation. In
EMNLP, pages 620–629.
</reference>
<page confidence="0.99912">
51
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.524331">
<title confidence="0.9993385">Firstand Second-Order Expectation Semirings Applications to Minimum-Risk Training on Translation</title>
<author confidence="0.995655">Li</author>
<affiliation confidence="0.999087">Department of Computer Science and Center for Language and Speech</affiliation>
<address confidence="0.943229">Johns Hopkins University, Baltimore, MD 21218,</address>
<email confidence="0.999794">zhifei.work@gmail.com,jason@cs.jhu.edu</email>
<abstract confidence="0.980160826086957">Many statistical translation models can be regarded as weighted logical deduction. Under this paradigm, we use weights from the expectation semiring (Eisner, 2002), to compute first-order statistics (e.g., the expected hypothesis length or feature counts) over packed forests of translations (lattices or hypergraphs). We then introduce novel semiring, which computes second-order statistics (e.g., the variance of the hypothesis length or the gradient of entropy). This second-order semiring is essential for many interesting training paradigms such as minimum risk, deterministic annealing, active learning, and semi-supervised learning, where gradient descent optimization requires computing the gradient of entropy or risk. We use these semirings in an open-source machine translation toolkit, enabling minimum-risk training a benefit of up to 1.0</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>J K Baker</author>
</authors>
<title>Trainable grammars for speech recognition. In</title>
<date>1979</date>
<booktitle>Speech Communication Papers Presented at the 97th Meeting of the Acoustical Society of America, MIT,</booktitle>
<editor>Jared J. Wolf and Dennis H. Klatt, editors,</editor>
<location>Cambridge, MA,</location>
<contexts>
<context position="15770" citStr="Baker, 1979" startWordPosition="2721" endWordPosition="2722">ose r(d) and s(d) are identical and both compute hypothesis length. Then the second-order statistic t/Z is the second moment of the length distribution, so the variance of hypothesis length can be found as t/Z − (r/Z)2. 3.2 Computing the Quantities We will use the semiring parsing framework to compute the quantities (1)–(4). Although each is a sum over exponentially many derivations, we will compute it in O(JHGJ) time using Figure 2. In the simplest case, let K = (R, +, x, 0, 1), and define ke = pe for each hyperedge e. Then the algorithm of Figure 2 reduces to the classical inside algorithm (Baker, 1979) and computes Z. Next suppose K is the expectation semiring (Eisner, 2002), shown in Table 1. Define ke = (pe, pere). Then Figure 2 will return (Z, r). Finally, suppose K is our novel second-order expectation semiring, which we introduce in Table 2. Define ke = (pe, pere, pese, perese). Then the algorithm of Figure 2 returns (Z, r, s, t). Note that, to compute t, one cannot simply construct a first-order expectation semiring by defining t(d) def = r(d)s(d) because t(d), unlike r(d) and s(d), is not additively decomposable over the hyperedges in d.5 Also, when r(d) and s(d) are identical, the s</context>
<context position="24227" citStr="Baker, 1979" startWordPosition="4293" endWordPosition="4294">t when n is large. Why? The inside algorithm takes the trouble to compute an inside weight β(v) E R x Rn for each node v in the hypergraph (or lattice). The second component of β(v) is a presumably dense vector of all features that fire in all subderivations rooted at node v. Moreover, as β(v) is computed in lines 3–8, that vector is built up (via the ® and ® operations of Table 1) as a linear combination of other dense vectors (the second components of the various β(u)). These vector operations can be slow. A much more efficient approach (usually) is the traditional inside-outside algorithm (Baker, 1979).7 Figure 4 generalizes the inside-outside algorithm to work with any expectation semiring EK,X.8 We are given a hypergraph HG whose edges have weights (ke, xe) in this semiring (so 7Note, however, that the expectation semiring requires only the forward/inside pass to compute expectations, and thus it is more efficient than the traditional inside-outside algorithm (which requires two passes) if we are interested in computing only a small number of quantities. 8This follows Eisner (2002), who similarly generalized the forward-backward algorithm. now ke E K denotes only part of the edge weight, </context>
</contexts>
<marker>Baker, 1979</marker>
<rawString>J. K. Baker. 1979. Trainable grammars for speech recognition. In Jared J. Wolf and Dennis H. Klatt, editors, Speech Communication Papers Presented at the 97th Meeting of the Acoustical Society of America, MIT, Cambridge, MA, June.</rawString>
</citation>
<citation valid="true">
<authors>
<author>David Chiang</author>
<author>Kevin Knight</author>
<author>Wei Wang</author>
</authors>
<title>11,001 new features for statistical machine translation.</title>
<date>2009</date>
<booktitle>In NAACL,</booktitle>
<pages>218--226</pages>
<contexts>
<context position="48062" citStr="Chiang et al. (2009)" startWordPosition="8504" endWordPosition="8507">re. Note that the total score by the baseline system is also a feature in the second-stage model. With these features and the 40k hypergraphs, we run the MR training to obtain the optimal weights. During test time, a similar procedure is followed. For a given test sentence, the baseline system first generates a hypergraph, and then the hypergraph is reranked by the second-stage model. The last row in Table 5 reports the BLEU scores. Clearly, adding more features improves (statistically significant) the case with only five features. We plan to incorporate more informative features described by Chiang et al. (2009).19 8 Conclusions We presented first-order expectation semirings and inside-outside computation in more detail than (Eisner, 2002), and developed extensions to higher-order expectation semirings. This enables efficient computation of many interesting quantities over the exponentially many derivations encoded in a hypergraph: second derivatives (Hessians), expectations of products (covariances), and expectations such as risk and entropy along with their derivatives. To our knowledge, algorithms for these problems have not been presented before. Our approach is theoretically elegant, like other </context>
</contexts>
<marker>Chiang, Knight, Wang, 2009</marker>
<rawString>David Chiang, Kevin Knight, and Wei Wang. 2009. 11,001 new features for statistical machine translation. In NAACL, pages 218–226.</rawString>
</citation>
<citation valid="true">
<authors>
<author>David Chiang</author>
</authors>
<title>Hierarchical phrase-based translation.</title>
<date>2007</date>
<journal>Computational Linguistics,</journal>
<volume>33</volume>
<issue>2</issue>
<contexts>
<context position="1863" citStr="Chiang, 2007" startWordPosition="275" endWordPosition="276"> “packed forest” (Gallo et al., 1993; Klein and Manning, 2004; Huang and Chiang, 2005) is a compact data structure that uses structure-sharing to represent exponentially many trees in polynomial space. A weighted hypergraph also defines a probability or other weight for each tree, and can be used to represent the hypothesis space considered (for a given input) by a monolingual parser or a tree-based translation system, e.g., tree to string (Quirk et al., 2005; Liu et al., 2006), string to tree (Galley et al., 2006), tree to tree (Eisner, 2003), or string to string with latent tree structures (Chiang, 2007). ∗This research was partially supported by the Defense Advanced Research Projects Agency’s GALE program via Contract No HR0011-06-2-0001. We are grateful to Sanjeev Khudanpur for early guidance and regular discussions. Given a hypergraph, we are often interested in computing some quantities over it using dynamic programming algorithms. For example, we may want to run the Viterbi algorithm to find the most probable derivation tree in the hypergraph, or the k most probable trees. Semiring-weighted logic programming is a general framework to specify these algorithms (Pereira and Warren, 1983; Sh</context>
<context position="4793" citStr="Chiang, 2007" startWordPosition="713" endWordPosition="714">2009 Conference on Empirical Methods in Natural Language Processing, pages 40–51, Singapore, 6-7 August 2009. c�2009 ACL and AFNLP annealing (Rose, 1998), minimum risk (Smith and Eisner, 2006), active and semi-supervised learning (Grandvalet and Bengio, 2004; Jiao et al., 2006). In these settings, we must compute the gradient of entropy or risk. The semirings can also be used for second-order gradient optimization algorithms. We implement the expectation and variance semirings in Joshua (Li et al., 2009a), and demonstrate their practical benefit by using minimumrisk training to improve Hiero (Chiang, 2007). 2 Semiring Parsing on Hypergraphs We use a specific tree-based system called Hiero (Chiang, 2007) as an example, although the discussion is general for any systems that use a hypergraph to represent the hypothesis space. 2.1 Hierarchical Machine Translation In Hiero, a synchronous context-free grammar (SCFG) is extracted from automatically wordaligned corpora. An illustrative grammar rule for Chinese-to-English translation is X — (X0 I n,X1 , X1 of X0 ), where the Chinese word In, means of, and the alignment, encoded via subscripts on the nonterminals, causes the two phrases around In, to be</context>
</contexts>
<marker>Chiang, 2007</marker>
<rawString>David Chiang. 2007. Hierarchical phrase-based translation. Computational Linguistics, 33(2):201–228.</rawString>
</citation>
<citation valid="false">
<authors>
<author>W K Clifford</author>
</authors>
<title>1873. Preliminary sketch of biquaternions.</title>
<booktitle>Proceedings of the London Mathematical Society,</booktitle>
<pages>4--381</pages>
<marker>Clifford, </marker>
<rawString>W. K. Clifford. 1873. Preliminary sketch of biquaternions. Proceedings of the London Mathematical Society, 4:381–395.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Matthias Eck</author>
<author>Chiori Hori</author>
</authors>
<title>Overview of the iwslt 2005 evaluation campaign. In</title>
<date>2005</date>
<booktitle>In Proc. of the International Workshop on Spoken Language Translation.</booktitle>
<contexts>
<context position="44600" citStr="Eck and Hori, 2005" startWordPosition="7910" endWordPosition="7913">our general algorithms with first- and second-order semirings. They focused on tuning only a small number (i.e. nine) of features as in a regular MERT setting, while our experiments involve both a small and a large number of features. 16It is easy to verify that the gradient of a function f (e.g. entropy or risk) with respect to γ can be written as a weighted sum of gradients with respect to the feature weights θi, i.e. = 1 θi × ae (16) γ i i ∂f ∂ry 49 7.4 Experimental Results 7.4.1 Experimental Setup We built a translation model on a corpus for IWSLT 2005 Chinese-to-English translation task (Eck and Hori, 2005), which consists of 40k pairs of sentences. We used a 5-gram language model with modified Kneser-Ney smoothing, trained on the bitext’s English using SRILM (Stolcke, 2002). 7.4.2 Tuning a Small Number of Features We first investigate how minimum-risk training (MR), with and without deterministic annealing (DA), performs compared to regular MERT. MR without DA just fixes T = 0 and γ = 1 in (14). All MR or MR+DA uses an approximated BLEU (Tromble et al., 2008) (for training only), while MERT uses the exact corpus BLEU in training. The first five rows in Table 5 present the results by tuning the </context>
</contexts>
<marker>Eck, Hori, 2005</marker>
<rawString>Matthias Eck and Chiori Hori. 2005. Overview of the iwslt 2005 evaluation campaign. In In Proc. of the International Workshop on Spoken Language Translation.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jason Eisner</author>
<author>Eric Goldlust</author>
<author>Noah A Smith</author>
</authors>
<title>Compiling comp ling: practical weighted dynamic programming and the dyna language. In</title>
<date>2005</date>
<booktitle>HLT/EMNLP,</booktitle>
<pages>281--290</pages>
<contexts>
<context position="2517" citStr="Eisner et al., 2005" startWordPosition="372" endWordPosition="375">orted by the Defense Advanced Research Projects Agency’s GALE program via Contract No HR0011-06-2-0001. We are grateful to Sanjeev Khudanpur for early guidance and regular discussions. Given a hypergraph, we are often interested in computing some quantities over it using dynamic programming algorithms. For example, we may want to run the Viterbi algorithm to find the most probable derivation tree in the hypergraph, or the k most probable trees. Semiring-weighted logic programming is a general framework to specify these algorithms (Pereira and Warren, 1983; Shieber et al., 1994; Goodman, 1999; Eisner et al., 2005; Lopez, 2009). Goodman (1999) describes many useful semirings (e.g., Viterbi, inside, and Viterbin-best). While most of these semirings are used in “testing” (i.e., decoding), we are mainly interested in the semirings that are useful for “training” (i.e., parameter estimation). The expectation semiring (Eisner, 2002), originally proposed for finite-state machines, is one such “training” semiring, and can be used to compute feature expectations for the Estep of the EM algorithm, or gradients of the likelihood function for gradient descent. In this paper, we apply the expectation semiring (Eisn</context>
</contexts>
<marker>Eisner, Goldlust, Smith, 2005</marker>
<rawString>Jason Eisner, Eric Goldlust, and Noah A. Smith. 2005. Compiling comp ling: practical weighted dynamic programming and the dyna language. In HLT/EMNLP, pages 281–290.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jason Eisner</author>
</authors>
<title>Parameter estimation for probabilistic finite-state transducers.</title>
<date>2002</date>
<booktitle>In ACL,</booktitle>
<pages>1--8</pages>
<contexts>
<context position="2836" citStr="Eisner, 2002" startWordPosition="419" endWordPosition="420">ant to run the Viterbi algorithm to find the most probable derivation tree in the hypergraph, or the k most probable trees. Semiring-weighted logic programming is a general framework to specify these algorithms (Pereira and Warren, 1983; Shieber et al., 1994; Goodman, 1999; Eisner et al., 2005; Lopez, 2009). Goodman (1999) describes many useful semirings (e.g., Viterbi, inside, and Viterbin-best). While most of these semirings are used in “testing” (i.e., decoding), we are mainly interested in the semirings that are useful for “training” (i.e., parameter estimation). The expectation semiring (Eisner, 2002), originally proposed for finite-state machines, is one such “training” semiring, and can be used to compute feature expectations for the Estep of the EM algorithm, or gradients of the likelihood function for gradient descent. In this paper, we apply the expectation semiring (Eisner, 2002) to a hypergraph (or packed forest) rather than just a lattice. We then propose a novel second-order expectation semiring, nicknamed the “variance semiring.” The original first-order expectation semiring allows us to efficiently compute a vector of firstorder statistics (expectations; first derivatives) on th</context>
<context position="10082" citStr="Eisner (2002)" startWordPosition="1638" endWordPosition="1640">ies are necessary to ensure that � �eEd ke is well-defined.4 dED The algorithm in Figure 2 is general and can be applied with any semiring (e.g., Viterbi). Below, we present our novel semirings. 3 Finding Expectations on Hypergraphs We now introduce the computational problems of this paper and the semirings we use to solve them. 3.1 Problem Definitions We are given a function p : D → R&gt;0, which decomposes multiplicatively over component hyperedges e of a derivation d ∈ D: that is, p(d) def = 11 eEd pe. In practice, p(d) will specify a probability distribution over the derivations in the hyper2Eisner (2002) uses closed semirings that are also equipped with a Kleene closure operator *. For example, in the real semiring (Il2, +, x, 0, 1), we define p* = (1 − p)−1 (= 1 + p + p2 + ...) for |p |&lt; 1 and is undefined otherwise. The closure operator enables exact summation over the infinitely many paths in a cyclic FSM, or trees in a hypergraph with non-branching cycles, without the need to iterate around cycles to numerical convergence. For completeness, we specify the closure operator for our semirings, satisfying the axioms k* = 1 ® k ® k* = 1 ® k* ® k, but we do not use it in our experiments since o</context>
<context position="15844" citStr="Eisner, 2002" startWordPosition="2733" endWordPosition="2734">the second-order statistic t/Z is the second moment of the length distribution, so the variance of hypothesis length can be found as t/Z − (r/Z)2. 3.2 Computing the Quantities We will use the semiring parsing framework to compute the quantities (1)–(4). Although each is a sum over exponentially many derivations, we will compute it in O(JHGJ) time using Figure 2. In the simplest case, let K = (R, +, x, 0, 1), and define ke = pe for each hyperedge e. Then the algorithm of Figure 2 reduces to the classical inside algorithm (Baker, 1979) and computes Z. Next suppose K is the expectation semiring (Eisner, 2002), shown in Table 1. Define ke = (pe, pere). Then Figure 2 will return (Z, r). Finally, suppose K is our novel second-order expectation semiring, which we introduce in Table 2. Define ke = (pe, pere, pese, perese). Then the algorithm of Figure 2 returns (Z, r, s, t). Note that, to compute t, one cannot simply construct a first-order expectation semiring by defining t(d) def = r(d)s(d) because t(d), unlike r(d) and s(d), is not additively decomposable over the hyperedges in d.5 Also, when r(d) and s(d) are identical, the second-order expectation semiring allows us to compute variance as t/Z − (r</context>
<context position="23570" citStr="Eisner (2002" startWordPosition="4175" endWordPosition="4176">g of interest,” EP,R or EP,R,S,T . To compute equations (1)–(4) in this more general setting, we must still require multiplicative or additive decomposability, defining p(d) def = HeEd pe, r(d) def EeEd re, s(d) def EeEd se as before. But the H and E operators here now denote appropriate operations within P, R, and S respectively (rather than the usual operations within R). 4.2 Inside-Outside Speedup for First-Order Expectation Semirings Under the first-order expectation semiring ER,R-, the inside algorithm of Figure 2 will return (Z, r) where r is a vector of n feature expectations. However, Eisner (2002, section 5) observes that this is inefficient when n is large. Why? The inside algorithm takes the trouble to compute an inside weight β(v) E R x Rn for each node v in the hypergraph (or lattice). The second component of β(v) is a presumably dense vector of all features that fire in all subderivations rooted at node v. Moreover, as β(v) is computed in lines 3–8, that vector is built up (via the ® and ® operations of Table 1) as a linear combination of other dense vectors (the second components of the various β(u)). These vector operations can be slow. A much more efficient approach (usually) </context>
<context position="26007" citStr="Eisner (2002)" startWordPosition="4596" endWordPosition="4597"> K) and OUTSIDE(HG, K), which use only the ke part of the weights and ignore the more expensive xe. It is noteworthy that the expectation semiring is not used at all by Figure 4. Although the return value (ˆk, ˆx) is in the expectation semiring, it is built up not by ® and ® but rather by computing kˆ and xˆ separately. One might therefore wonder why the expectation semiring and its operations are still needed. One reason is that the input to Figure 4 consists of hyperedge weights (ke, xe) in the expectation semiring—and these weights may well have been constructed using ® and ®. For example, Eisner (2002) uses finite-state operations such as composition, which do combine weights entirely within the expectation semiring before their result is passed to the forward-backward algorithm. A second reason is that when we work with a second-order expectation semiring in Section 4.4 below, the ˆk, β, and α values in Figure 4 will turn out to be elements of a first-order expectation semiring, and they must still be constructed by first-order ® and ®, via calls to Figures 2–3. Why does inside-outside work? Whereas the inside algorithm computes ®dED ®eEd in any semiring, the inside-outside algorithm explo</context>
<context position="48192" citStr="Eisner, 2002" startWordPosition="8522" endWordPosition="8523">aphs, we run the MR training to obtain the optimal weights. During test time, a similar procedure is followed. For a given test sentence, the baseline system first generates a hypergraph, and then the hypergraph is reranked by the second-stage model. The last row in Table 5 reports the BLEU scores. Clearly, adding more features improves (statistically significant) the case with only five features. We plan to incorporate more informative features described by Chiang et al. (2009).19 8 Conclusions We presented first-order expectation semirings and inside-outside computation in more detail than (Eisner, 2002), and developed extensions to higher-order expectation semirings. This enables efficient computation of many interesting quantities over the exponentially many derivations encoded in a hypergraph: second derivatives (Hessians), expectations of products (covariances), and expectations such as risk and entropy along with their derivatives. To our knowledge, algorithms for these problems have not been presented before. Our approach is theoretically elegant, like other work in this vein (Goodman, 1999; Lopez, 2009; Gimpel and Smith, 2009). We used it practically to enable a new form of minimum-ris</context>
</contexts>
<marker>Eisner, 2002</marker>
<rawString>Jason Eisner. 2002. Parameter estimation for probabilistic finite-state transducers. In ACL, pages 1–8.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jason Eisner</author>
</authors>
<title>Learning non-isomorphic tree mappings for machine translation. In</title>
<date>2003</date>
<booktitle>ACL,</booktitle>
<pages>205--208</pages>
<contexts>
<context position="1799" citStr="Eisner, 2003" startWordPosition="265" endWordPosition="266"> benefit of up to 1.0 BLEU point. 1 Introduction A hypergraph or “packed forest” (Gallo et al., 1993; Klein and Manning, 2004; Huang and Chiang, 2005) is a compact data structure that uses structure-sharing to represent exponentially many trees in polynomial space. A weighted hypergraph also defines a probability or other weight for each tree, and can be used to represent the hypothesis space considered (for a given input) by a monolingual parser or a tree-based translation system, e.g., tree to string (Quirk et al., 2005; Liu et al., 2006), string to tree (Galley et al., 2006), tree to tree (Eisner, 2003), or string to string with latent tree structures (Chiang, 2007). ∗This research was partially supported by the Defense Advanced Research Projects Agency’s GALE program via Contract No HR0011-06-2-0001. We are grateful to Sanjeev Khudanpur for early guidance and regular discussions. Given a hypergraph, we are often interested in computing some quantities over it using dynamic programming algorithms. For example, we may want to run the Viterbi algorithm to find the most probable derivation tree in the hypergraph, or the k most probable trees. Semiring-weighted logic programming is a general fra</context>
</contexts>
<marker>Eisner, 2003</marker>
<rawString>Jason Eisner. 2003. Learning non-isomorphic tree mappings for machine translation. In ACL, pages 205–208.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Michel Galley</author>
<author>Jonathan Graehl</author>
<author>Kevin Knight</author>
<author>Daniel Marcu</author>
<author>Steve DeNeefe</author>
<author>Wei Wang</author>
<author>Ignacio Thayer</author>
</authors>
<title>Scalable inference and training of context-rich syntactic translation models.</title>
<date>2006</date>
<booktitle>In ACL,</booktitle>
<pages>961--968</pages>
<contexts>
<context position="1770" citStr="Galley et al., 2006" startWordPosition="258" endWordPosition="261">enabling minimum-risk training for a benefit of up to 1.0 BLEU point. 1 Introduction A hypergraph or “packed forest” (Gallo et al., 1993; Klein and Manning, 2004; Huang and Chiang, 2005) is a compact data structure that uses structure-sharing to represent exponentially many trees in polynomial space. A weighted hypergraph also defines a probability or other weight for each tree, and can be used to represent the hypothesis space considered (for a given input) by a monolingual parser or a tree-based translation system, e.g., tree to string (Quirk et al., 2005; Liu et al., 2006), string to tree (Galley et al., 2006), tree to tree (Eisner, 2003), or string to string with latent tree structures (Chiang, 2007). ∗This research was partially supported by the Defense Advanced Research Projects Agency’s GALE program via Contract No HR0011-06-2-0001. We are grateful to Sanjeev Khudanpur for early guidance and regular discussions. Given a hypergraph, we are often interested in computing some quantities over it using dynamic programming algorithms. For example, we may want to run the Viterbi algorithm to find the most probable derivation tree in the hypergraph, or the k most probable trees. Semiring-weighted logic</context>
</contexts>
<marker>Galley, Graehl, Knight, Marcu, DeNeefe, Wang, Thayer, 2006</marker>
<rawString>Michel Galley, Jonathan Graehl, Kevin Knight, Daniel Marcu, Steve DeNeefe, Wei Wang, and Ignacio Thayer. 2006. Scalable inference and training of context-rich syntactic translation models. In ACL, pages 961–968.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Giorgio Gallo</author>
<author>Giustino Longo</author>
<author>Stefano Pallottino</author>
<author>Sang Nguyen</author>
</authors>
<title>Directed hypergraphs and applications. Discrete Appl.</title>
<date>1993</date>
<pages>42--2</pages>
<publisher>Math.,</publisher>
<contexts>
<context position="1286" citStr="Gallo et al., 1993" startWordPosition="177" endWordPosition="180">-order expectation semiring, which computes second-order statistics (e.g., the variance of the hypothesis length or the gradient of entropy). This second-order semiring is essential for many interesting training paradigms such as minimum risk, deterministic annealing, active learning, and semi-supervised learning, where gradient descent optimization requires computing the gradient of entropy or risk. We use these semirings in an open-source machine translation toolkit, Joshua, enabling minimum-risk training for a benefit of up to 1.0 BLEU point. 1 Introduction A hypergraph or “packed forest” (Gallo et al., 1993; Klein and Manning, 2004; Huang and Chiang, 2005) is a compact data structure that uses structure-sharing to represent exponentially many trees in polynomial space. A weighted hypergraph also defines a probability or other weight for each tree, and can be used to represent the hypothesis space considered (for a given input) by a monolingual parser or a tree-based translation system, e.g., tree to string (Quirk et al., 2005; Liu et al., 2006), string to tree (Galley et al., 2006), tree to tree (Eisner, 2003), or string to string with latent tree structures (Chiang, 2007). ∗This research was pa</context>
<context position="6457" citStr="Gallo et al., 1993" startWordPosition="988" endWordPosition="991">in the chart (which specifies aligned spans of input and output together with a nonterminal label). The root node corresponds to the goal item. A hyperedge represents an SCFG rule that has been “instantiated” at a particular position, so that the nonterminals on the right and left sides have been replaced by particular antecedent and consequent items; this corresponds to storage of backpointers in the chart. We write T(e) to denote the set of antecedent nodes of a hyperedge e. We write I(v) for the 1Strictly speaking, making each hyperedge designate a single consequent defines a B-hypergraph (Gallo et al., 1993). Figure 1: A toy hypergraph in Hiero. When generating the hypergraph, a trigram language model is integrated. Rectangles represent items, where each item is identified by the non-terminal symbol, source span, and left- and right-side language model states. An item has one or more incoming hyperedges. A hyperedge consists of a rule, and a pointer to an antecedent item for each non-terminal symbol in the rule. set of incoming hyperedges of node v (i.e., hyperedges of which v is the consequent), which represent different ways of deriving v. Figure 1 shows a simple Hiero-style hypergraph. The hyp</context>
</contexts>
<marker>Gallo, Longo, Pallottino, Nguyen, 1993</marker>
<rawString>Giorgio Gallo, Giustino Longo, Stefano Pallottino, and Sang Nguyen. 1993. Directed hypergraphs and applications. Discrete Appl. Math., 42(2-3):177–201.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kevin Gimpel</author>
<author>Noah A Smith</author>
</authors>
<title>Cube summing, approximate inference with non-local features, and dynamic programming without semirings.</title>
<date>2009</date>
<booktitle>In EACL,</booktitle>
<pages>318--326</pages>
<marker>Gimpel, Smith, 2009</marker>
<rawString>Kevin Gimpel and Noah A. Smith. 2009. Cube summing, approximate inference with non-local features, and dynamic programming without semirings. In EACL, pages 318–326.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Joshua Goodman</author>
</authors>
<title>Semiring parsing.</title>
<date>1999</date>
<journal>Computational Linguistics,</journal>
<volume>25</volume>
<issue>4</issue>
<contexts>
<context position="2496" citStr="Goodman, 1999" startWordPosition="370" endWordPosition="371"> partially supported by the Defense Advanced Research Projects Agency’s GALE program via Contract No HR0011-06-2-0001. We are grateful to Sanjeev Khudanpur for early guidance and regular discussions. Given a hypergraph, we are often interested in computing some quantities over it using dynamic programming algorithms. For example, we may want to run the Viterbi algorithm to find the most probable derivation tree in the hypergraph, or the k most probable trees. Semiring-weighted logic programming is a general framework to specify these algorithms (Pereira and Warren, 1983; Shieber et al., 1994; Goodman, 1999; Eisner et al., 2005; Lopez, 2009). Goodman (1999) describes many useful semirings (e.g., Viterbi, inside, and Viterbin-best). While most of these semirings are used in “testing” (i.e., decoding), we are mainly interested in the semirings that are useful for “training” (i.e., parameter estimation). The expectation semiring (Eisner, 2002), originally proposed for finite-state machines, is one such “training” semiring, and can be used to compute feature expectations for the Estep of the EM algorithm, or gradients of the likelihood function for gradient descent. In this paper, we apply the expec</context>
<context position="7750" citStr="Goodman, 1999" startWordPosition="1202" endWordPosition="1203">ms. By exploiting this sharing, a hypergraph can compactly represent exponentially many trees. We observe that any finite-state automaton can also be encoded as a hypergraph (in which every hyperedge is an ordinary edge that connects a single antecedent to a consequent). Thus, the methods of this paper apply directly to the simpler case of hypothesis lattices as well. 2.3 Semiring Parsing We assume a hypergraph HG, which compactly encodes many derivation trees d E D. Given HG, we wish to extract the best derivations—or other aggregate properties of the forest of derivations. Semiring parsing (Goodman, 1999) is a general framework to describe such algorithms. To define a particular algorithm, we choose a semiring K and specify a “weight” ke E K for each hyperedge e. The desired aggregate result then emerges as the total weight of all derivations in the hypergraph. For example, to simply count derivations, one can assign every hyperedge weight 1 in the semiring of ordinary integers; then each derivation also has weight 1, and their total weight is the number of derivations. We write K = (K, ®, ®, 0,1) for a semiring with elements K, additive operation ®, multigoal item S—(XO, X0) S—&apos;(XO, X0) X—(Xo</context>
</contexts>
<marker>Goodman, 1999</marker>
<rawString>Joshua Goodman. 1999. Semiring parsing. Computational Linguistics, 25(4):573–605.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Y Grandvalet</author>
<author>Y Bengio</author>
</authors>
<title>Semi-supervised learning by entropy minimization.</title>
<date>2004</date>
<booktitle>In NIPS,</booktitle>
<pages>529--536</pages>
<contexts>
<context position="4438" citStr="Grandvalet and Bengio, 2004" startWordPosition="655" endWordPosition="658">s. These quantities include expected hypothesis length, feature expectation, entropy, cross-entropy, KullbackLeibler divergence, Bayes risk, variance of hypothesis length, gradient of entropy and Bayes risk, covariance and Hessian matrix, and so on. The variance semiring is essential for many interesting training paradigms such as deterministic 40 Proceedings of the 2009 Conference on Empirical Methods in Natural Language Processing, pages 40–51, Singapore, 6-7 August 2009. c�2009 ACL and AFNLP annealing (Rose, 1998), minimum risk (Smith and Eisner, 2006), active and semi-supervised learning (Grandvalet and Bengio, 2004; Jiao et al., 2006). In these settings, we must compute the gradient of entropy or risk. The semirings can also be used for second-order gradient optimization algorithms. We implement the expectation and variance semirings in Joshua (Li et al., 2009a), and demonstrate their practical benefit by using minimumrisk training to improve Hiero (Chiang, 2007). 2 Semiring Parsing on Hypergraphs We use a specific tree-based system called Hiero (Chiang, 2007) as an example, although the discussion is general for any systems that use a hypergraph to represent the hypothesis space. 2.1 Hierarchical Machi</context>
</contexts>
<marker>Grandvalet, Bengio, 2004</marker>
<rawString>Y Grandvalet and Y Bengio. 2004. Semi-supervised learning by entropy minimization. In NIPS, pages 529–536.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Liang Huang</author>
<author>David Chiang</author>
</authors>
<title>Better k-best parsing.</title>
<date>2005</date>
<booktitle>In IWPT,</booktitle>
<pages>53--64</pages>
<contexts>
<context position="1336" citStr="Huang and Chiang, 2005" startWordPosition="185" endWordPosition="189">econd-order statistics (e.g., the variance of the hypothesis length or the gradient of entropy). This second-order semiring is essential for many interesting training paradigms such as minimum risk, deterministic annealing, active learning, and semi-supervised learning, where gradient descent optimization requires computing the gradient of entropy or risk. We use these semirings in an open-source machine translation toolkit, Joshua, enabling minimum-risk training for a benefit of up to 1.0 BLEU point. 1 Introduction A hypergraph or “packed forest” (Gallo et al., 1993; Klein and Manning, 2004; Huang and Chiang, 2005) is a compact data structure that uses structure-sharing to represent exponentially many trees in polynomial space. A weighted hypergraph also defines a probability or other weight for each tree, and can be used to represent the hypothesis space considered (for a given input) by a monolingual parser or a tree-based translation system, e.g., tree to string (Quirk et al., 2005; Liu et al., 2006), string to tree (Galley et al., 2006), tree to tree (Eisner, 2003), or string to string with latent tree structures (Chiang, 2007). ∗This research was partially supported by the Defense Advanced Research</context>
</contexts>
<marker>Huang, Chiang, 2005</marker>
<rawString>Liang Huang and David Chiang. 2005. Better k-best parsing. In IWPT, pages 53–64.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Liang Huang</author>
</authors>
<title>Forest reranking: Discriminative parsing with non-local features.</title>
<date>2008</date>
<booktitle>In ACL,</booktitle>
<pages>586--594</pages>
<contexts>
<context position="46100" citStr="Huang, 2008" startWordPosition="8175" endWordPosition="8176">+DA on a hypergraph, does consistently better (statistically significant) than MERT, despite approximating BLEU.17 Did DA help? For both n-best and hypergraph, MR+DA did obtain a better BLEU score than plain MR on the dev set.18 This shows that DA helps with the local minimum problem, as hoped. However, DA’s improvement on the dev set did not transfer to the test set. 7.4.3 Tuning a Large Number of Features MR (with or without DA) is scalable to tune a large number of features, while MERT is not. To achieve competitive performance, we adopt a forest reranking approach (Li and Khudanpur, 2009; Huang, 2008). Specifically, our training has two stages. In the first stage, we train a baseline system as usual. We also find the optimal feature weights for the five features mentioned before, using the method of MR+DA operating on a hypergraph. In the second stage, we generate a hypergraph for each sentence in the training data (which consists of about 40k sentence pairs), using the baseline 17Pauls et al. (2009) concurrently observed a similar pattern (i.e., MR performs worse than MERT on the dev set, but performs better on a test set). 18We also verified that MR+DA found a better objective value (i.e</context>
</contexts>
<marker>Huang, 2008</marker>
<rawString>Liang Huang. 2008. Forest reranking: Discriminative parsing with non-local features. In ACL, pages 586– 594.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Feng Jiao</author>
<author>Shaojun Wang</author>
<author>Chi-Hoon Lee</author>
<author>Russell Greiner</author>
<author>Dale Schuurmans</author>
</authors>
<title>Semisupervised conditional random fields for improved sequence segmentation and labeling.</title>
<date>2006</date>
<booktitle>In ACL,</booktitle>
<pages>209--216</pages>
<contexts>
<context position="4458" citStr="Jiao et al., 2006" startWordPosition="659" endWordPosition="662">xpected hypothesis length, feature expectation, entropy, cross-entropy, KullbackLeibler divergence, Bayes risk, variance of hypothesis length, gradient of entropy and Bayes risk, covariance and Hessian matrix, and so on. The variance semiring is essential for many interesting training paradigms such as deterministic 40 Proceedings of the 2009 Conference on Empirical Methods in Natural Language Processing, pages 40–51, Singapore, 6-7 August 2009. c�2009 ACL and AFNLP annealing (Rose, 1998), minimum risk (Smith and Eisner, 2006), active and semi-supervised learning (Grandvalet and Bengio, 2004; Jiao et al., 2006). In these settings, we must compute the gradient of entropy or risk. The semirings can also be used for second-order gradient optimization algorithms. We implement the expectation and variance semirings in Joshua (Li et al., 2009a), and demonstrate their practical benefit by using minimumrisk training to improve Hiero (Chiang, 2007). 2 Semiring Parsing on Hypergraphs We use a specific tree-based system called Hiero (Chiang, 2007) as an example, although the discussion is general for any systems that use a hypergraph to represent the hypothesis space. 2.1 Hierarchical Machine Translation In Hi</context>
</contexts>
<marker>Jiao, Wang, Lee, Greiner, Schuurmans, 2006</marker>
<rawString>Feng Jiao, Shaojun Wang, Chi-Hoon Lee, Russell Greiner, and Dale Schuurmans. 2006. Semisupervised conditional random fields for improved sequence segmentation and labeling. In ACL, pages 209–216.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Dan Klein</author>
<author>Christopher D Manning</author>
</authors>
<title>Parsing and hypergraphs. New developments in parsing technology,</title>
<date>2004</date>
<pages>351--372</pages>
<contexts>
<context position="1311" citStr="Klein and Manning, 2004" startWordPosition="181" endWordPosition="184">emiring, which computes second-order statistics (e.g., the variance of the hypothesis length or the gradient of entropy). This second-order semiring is essential for many interesting training paradigms such as minimum risk, deterministic annealing, active learning, and semi-supervised learning, where gradient descent optimization requires computing the gradient of entropy or risk. We use these semirings in an open-source machine translation toolkit, Joshua, enabling minimum-risk training for a benefit of up to 1.0 BLEU point. 1 Introduction A hypergraph or “packed forest” (Gallo et al., 1993; Klein and Manning, 2004; Huang and Chiang, 2005) is a compact data structure that uses structure-sharing to represent exponentially many trees in polynomial space. A weighted hypergraph also defines a probability or other weight for each tree, and can be used to represent the hypothesis space considered (for a given input) by a monolingual parser or a tree-based translation system, e.g., tree to string (Quirk et al., 2005; Liu et al., 2006), string to tree (Galley et al., 2006), tree to tree (Eisner, 2003), or string to string with latent tree structures (Chiang, 2007). ∗This research was partially supported by the </context>
</contexts>
<marker>Klein, Manning, 2004</marker>
<rawString>Dan Klein and Christopher D. Manning. 2004. Parsing and hypergraphs. New developments in parsing technology, pages 351–372.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Raymond Lau</author>
<author>Ronald Rosenfeld</author>
<author>Salim Roukos</author>
</authors>
<title>Adaptive language modelling using the maximum entropy principle.</title>
<date>1993</date>
<booktitle>In Proc. ARPA Human Language Technologies Workshop,</booktitle>
<pages>81--86</pages>
<contexts>
<context position="36329" citStr="Lau et al., 1993" startWordPosition="6423" endWordPosition="6426">ector associated with e. So there, already P d = def re =(Vpe)/pe.13So (pe,pere) (pe,Vpe). semiring Vp) “dualnumbers.” R (p1,Vp1)® (p2,Vp2)=(p1p2,p1(Vp2) (Vp1)p2)=(p1p2,V(p1p2)). “forward” “inside” “backward” “outside” r¯ re VZ P Q e =P P ∈ Q ∈ 6= p p . Vpe (pe,Vpe) pere. P P ∈ ∈ 6= e e, P P ∈ p =P p P ∈ = P ¯r. Vpe pere Vpe pere. def where pe =exp(re· re VZ equals ¯r—yielding a key useful property of log-linear r(d) re 13Proof: =EeEd =EeEd(Ope)/pe = EeEd = EeEd = O log pe O log pe=O log11eEd pe O log p(d)=(Op(d))/p(d). models, that V log Z = (VZ)/Z = ¯r/Z, the vector of feature expectations (Lau et al., 1993). 6 Practical Applications Given a hypergraph HG whose hyperedges e are annotated with values pe. Recall from Section 3.1 that this defines a probability distribution over all derivations d in the hypergraph, namely p(d)/Z where p(d) def = 11eEd pe. 6.1 First-Order Expectation Semiring ]ER,R In Section 3, we show how to compute the expected hypothesis length or expected feature counts, using the algorithm of Figure 2 with a first-order expectation semiring ER,R. In general, given hyperedge weights (pe, pere), the algorithm computes (Z, r) and thus r/Z, the expectation of r(d) def = EeEd re. We</context>
</contexts>
<marker>Lau, Rosenfeld, Roukos, 1993</marker>
<rawString>Raymond Lau, Ronald Rosenfeld, and Salim Roukos. 1993. Adaptive language modelling using the maximum entropy principle. In Proc. ARPA Human Language Technologies Workshop, pages 81–86.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Zhifei Li</author>
<author>Sanjeev Khudanpur</author>
</authors>
<title>Large-scale discriminative n-gram language models for statistical machine translation.</title>
<date>2008</date>
<booktitle>In AMTA,</booktitle>
<pages>133--142</pages>
<contexts>
<context position="47384" citStr="Li and Khudanpur (2008)" startWordPosition="8389" endWordPosition="8392"> test MERT (Nbest, small) 42.6 47.7 MR (Nbest, small) 40.8 47.7 MR+DA (Nbest, small) 41.6 47.8 MR (hypergraph, small) 41.3 48.4 MR+DA (hypergraph, small) 41.9 48.3 MR (hypergraph, large) 42.3 48.7 Table 5: BLEU scores on the Dev and test sets under different training scenarios. In the “small” model, five features (i.e., one for the language model, three for the translation model, and one for word penalty) are tuned. In the “large” model, 21k additional unigram and bigram features are used. system. In this stage, we add 21k additional unigram and bigram target-side language model features (cf. Li and Khudanpur (2008)). For example, a specific bigram “the cat” can be a feature. Note that the total score by the baseline system is also a feature in the second-stage model. With these features and the 40k hypergraphs, we run the MR training to obtain the optimal weights. During test time, a similar procedure is followed. For a given test sentence, the baseline system first generates a hypergraph, and then the hypergraph is reranked by the second-stage model. The last row in Table 5 reports the BLEU scores. Clearly, adding more features improves (statistically significant) the case with only five features. We p</context>
</contexts>
<marker>Li, Khudanpur, 2008</marker>
<rawString>Zhifei Li and Sanjeev Khudanpur. 2008. Large-scale discriminative n-gram language models for statistical machine translation. In AMTA, pages 133–142.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Zhifei Li</author>
<author>Sanjeev Khudanpur</author>
</authors>
<title>Forest reranking for machine translation with the perceptron algorithm.</title>
<date>2009</date>
<booktitle>In GALE book chapter on ”MT From Text”.</booktitle>
<contexts>
<context position="46086" citStr="Li and Khudanpur, 2009" startWordPosition="8171" endWordPosition="8174">r new approach, MR or MR+DA on a hypergraph, does consistently better (statistically significant) than MERT, despite approximating BLEU.17 Did DA help? For both n-best and hypergraph, MR+DA did obtain a better BLEU score than plain MR on the dev set.18 This shows that DA helps with the local minimum problem, as hoped. However, DA’s improvement on the dev set did not transfer to the test set. 7.4.3 Tuning a Large Number of Features MR (with or without DA) is scalable to tune a large number of features, while MERT is not. To achieve competitive performance, we adopt a forest reranking approach (Li and Khudanpur, 2009; Huang, 2008). Specifically, our training has two stages. In the first stage, we train a baseline system as usual. We also find the optimal feature weights for the five features mentioned before, using the method of MR+DA operating on a hypergraph. In the second stage, we generate a hypergraph for each sentence in the training data (which consists of about 40k sentence pairs), using the baseline 17Pauls et al. (2009) concurrently observed a similar pattern (i.e., MR performs worse than MERT on the dev set, but performs better on a test set). 18We also verified that MR+DA found a better object</context>
</contexts>
<marker>Li, Khudanpur, 2009</marker>
<rawString>Zhifei Li and Sanjeev Khudanpur. 2009. Forest reranking for machine translation with the perceptron algorithm. In GALE book chapter on ”MT From Text”.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Zaidan</author>
</authors>
<title>Joshua: An open source toolkit for parsingbased machine translation. In</title>
<date>2009</date>
<booktitle>WMT09,</booktitle>
<pages>26--30</pages>
<marker>Zaidan, 2009</marker>
<rawString>Zhifei Li, Chris Callison-Burch, Chris Dyer, Juri Ganitkevitch, Sanjeev Khudanpur, Lane Schwartz, Wren Thornton, Jonathan Weese, and Omar. Zaidan. 2009a. Joshua: An open source toolkit for parsingbased machine translation. In WMT09, pages 26–30.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Zhifei Li</author>
<author>Jason Eisner</author>
<author>Sanjeev Khudanpur</author>
</authors>
<title>Variational decoding for statistical machine translation.</title>
<date>2009</date>
<booktitle>In ACL.</booktitle>
<contexts>
<context position="4688" citStr="Li et al., 2009" startWordPosition="695" endWordPosition="698"> semiring is essential for many interesting training paradigms such as deterministic 40 Proceedings of the 2009 Conference on Empirical Methods in Natural Language Processing, pages 40–51, Singapore, 6-7 August 2009. c�2009 ACL and AFNLP annealing (Rose, 1998), minimum risk (Smith and Eisner, 2006), active and semi-supervised learning (Grandvalet and Bengio, 2004; Jiao et al., 2006). In these settings, we must compute the gradient of entropy or risk. The semirings can also be used for second-order gradient optimization algorithms. We implement the expectation and variance semirings in Joshua (Li et al., 2009a), and demonstrate their practical benefit by using minimumrisk training to improve Hiero (Chiang, 2007). 2 Semiring Parsing on Hypergraphs We use a specific tree-based system called Hiero (Chiang, 2007) as an example, although the discussion is general for any systems that use a hypergraph to represent the hypothesis space. 2.1 Hierarchical Machine Translation In Hiero, a synchronous context-free grammar (SCFG) is extracted from automatically wordaligned corpora. An illustrative grammar rule for Chinese-to-English translation is X — (X0 I n,X1 , X1 of X0 ), where the Chinese word In, means o</context>
<context position="38462" citStr="Li et al., 2009" startWordPosition="6812" endWordPosition="6815">ected loss for it. Tromble et al. (2008) develop the following loss function, of which a linear approximation to BLEU is a special case, � (p(d)/Z) log(p(d)/Z) (5) � θw#w(y)δw(y*)) (8) H(p) = − L(y, y*) = −(θ0|y |+ dED wEN 1 � = log Z − Z dED 1 � = log Z − Z dED def provided that we define re = log pe (so that r(d) = EeEd re = log p(d)). Of course, we can compute (Z, r) as explained in Section 3.2. Cross-Entropy and KL Divergence We may be interested in computing the cross-entropy or KL divergence between two distributions p and q. For example, in variational decoding for machine translation (Li et al., 2009b), p is a distribution represented by a hypergraph, while q, represented by a finite state automaton, is an approximation to p. The cross entropy between p and q is defined as H(p, q) = − � (p(d)/Zp)log(q(d)/Zq) (6) dED 1 = log Zq − Z I: p(d) log q(d) p dED = log Zq − Z 1 L p(d)r(d) = r log ZQ — P Zp dED 14Unfortunately, it is intractable to compute the entropy of the distribution over strings (each string’s probability is a sum over several derivations). But Li et al. (2009b, section 5.4) do estimate the gap between derivational and string entropies. where w is an n-gram type, N is a set of </context>
</contexts>
<marker>Li, Eisner, Khudanpur, 2009</marker>
<rawString>Zhifei Li, Jason Eisner, and Sanjeev Khudanpur. 2009b. Variational decoding for statistical machine translation. In ACL.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Yang Liu</author>
<author>Qun Liu</author>
<author>Shouxun Lin</author>
</authors>
<title>Treeto-string alignment template for statistical machine translation.</title>
<date>2006</date>
<booktitle>In ACL,</booktitle>
<pages>609--616</pages>
<contexts>
<context position="1732" citStr="Liu et al., 2006" startWordPosition="251" endWordPosition="254">chine translation toolkit, Joshua, enabling minimum-risk training for a benefit of up to 1.0 BLEU point. 1 Introduction A hypergraph or “packed forest” (Gallo et al., 1993; Klein and Manning, 2004; Huang and Chiang, 2005) is a compact data structure that uses structure-sharing to represent exponentially many trees in polynomial space. A weighted hypergraph also defines a probability or other weight for each tree, and can be used to represent the hypothesis space considered (for a given input) by a monolingual parser or a tree-based translation system, e.g., tree to string (Quirk et al., 2005; Liu et al., 2006), string to tree (Galley et al., 2006), tree to tree (Eisner, 2003), or string to string with latent tree structures (Chiang, 2007). ∗This research was partially supported by the Defense Advanced Research Projects Agency’s GALE program via Contract No HR0011-06-2-0001. We are grateful to Sanjeev Khudanpur for early guidance and regular discussions. Given a hypergraph, we are often interested in computing some quantities over it using dynamic programming algorithms. For example, we may want to run the Viterbi algorithm to find the most probable derivation tree in the hypergraph, or the k most p</context>
</contexts>
<marker>Liu, Liu, Lin, 2006</marker>
<rawString>Yang Liu, Qun Liu, and Shouxun Lin. 2006. Treeto-string alignment template for statistical machine translation. In ACL, pages 609–616.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Adam Lopez</author>
</authors>
<title>Translation as weighted deduction.</title>
<date>2009</date>
<booktitle>In EACL,</booktitle>
<pages>532--540</pages>
<contexts>
<context position="2531" citStr="Lopez, 2009" startWordPosition="376" endWordPosition="377">Advanced Research Projects Agency’s GALE program via Contract No HR0011-06-2-0001. We are grateful to Sanjeev Khudanpur for early guidance and regular discussions. Given a hypergraph, we are often interested in computing some quantities over it using dynamic programming algorithms. For example, we may want to run the Viterbi algorithm to find the most probable derivation tree in the hypergraph, or the k most probable trees. Semiring-weighted logic programming is a general framework to specify these algorithms (Pereira and Warren, 1983; Shieber et al., 1994; Goodman, 1999; Eisner et al., 2005; Lopez, 2009). Goodman (1999) describes many useful semirings (e.g., Viterbi, inside, and Viterbin-best). While most of these semirings are used in “testing” (i.e., decoding), we are mainly interested in the semirings that are useful for “training” (i.e., parameter estimation). The expectation semiring (Eisner, 2002), originally proposed for finite-state machines, is one such “training” semiring, and can be used to compute feature expectations for the Estep of the EM algorithm, or gradients of the likelihood function for gradient descent. In this paper, we apply the expectation semiring (Eisner, 2002) to a</context>
</contexts>
<marker>Lopez, 2009</marker>
<rawString>Adam Lopez. 2009. Translation as weighted deduction. In EACL, pages 532–540.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Franz Josef Och</author>
</authors>
<title>Minimum error rate training in statistical machine translation.</title>
<date>2003</date>
<booktitle>In ACL,</booktitle>
<pages>160--167</pages>
<contexts>
<context position="41350" citStr="Och, 2003" startWordPosition="7354" endWordPosition="7355">first-order expectation semiring, but computing it along with its gradient requires a second-order one. 7.1 The Model p We assume a globally normalized linear model for its simplicity. Each derivation d is scored by � 4bi(d) θi (12) def score(d) = 4b(d) · θ = i where 4b(d) E RI is a vector of features of d. We then define the unnormalized distribution p(d) as p(d) = exp(γ · score(d)) (13) where the scale factor γ adjusts how sharply the distribution favors the highest-scoring hypotheses. 7.2 Minimum-Risk Training Adjusting θ or γ changes the distribution p. Minimum error rate training (MERT) (Och, 2003) tries to tune θ to minimize the BLEU loss of a decoder that chooses the most probable output according to p. (γ has no effect.) MERT’s specialized linesearch addresses the problem that this objective function is piecewise constant, but it does not scale to a large number of parameters. Smith and Eisner (2006) instead propose a differentiable objective that can be optimized by gradient descent: the Bayes risk R(p) of (7). This is the expected loss if one were (hypothetically) to use a randomized decoder, which chooses a hypothesis d in proportion to its probability p(d). If entropy H(p) is lar</context>
</contexts>
<marker>Och, 2003</marker>
<rawString>Franz Josef Och. 2003. Minimum error rate training in statistical machine translation. In ACL, pages 160– 167.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kishore Papineni</author>
<author>Salim Roukos</author>
<author>Todd Ward</author>
<author>WeiJing Zhu</author>
</authors>
<title>BLEU: A method for automatic evaluation of machine translation.</title>
<date>2001</date>
<booktitle>In ACL,</booktitle>
<pages>311--318</pages>
<contexts>
<context position="37770" citStr="Papineni et al., 2001" startWordPosition="6677" endWordPosition="6680"> inside algorithm with hyperedge weights qe, and the numerator and denominator of the second term using an expectation semiring with hydef peredge weights (pe, pere) with re = log qe. The KL divergence to p from q can be computed as KL(p II q) = H(p, q) − H(p). Expected Loss (Risk) Given a reference sentence y*, the expected loss (i.e., Bayes risk) of the hypotheses in the hypergraph is defined as, R(p) = � (p(d)/Z)L(Y(d), y*) (7) dED where Y(d) is the target yield of d and L(y, y*) is the loss of the hypothesis y with respect to the reference y*. The popular machine translation metric, BLEU (Papineni et al., 2001), is not additively decomposable, and thus we are not able to compute the expected loss for it. Tromble et al. (2008) develop the following loss function, of which a linear approximation to BLEU is a special case, � (p(d)/Z) log(p(d)/Z) (5) � θw#w(y)δw(y*)) (8) H(p) = − L(y, y*) = −(θ0|y |+ dED wEN 1 � = log Z − Z dED 1 � = log Z − Z dED def provided that we define re = log pe (so that r(d) = EeEd re = log p(d)). Of course, we can compute (Z, r) as explained in Section 3.2. Cross-Entropy and KL Divergence We may be interested in computing the cross-entropy or KL divergence between two distribu</context>
</contexts>
<marker>Papineni, Roukos, Ward, Zhu, 2001</marker>
<rawString>Kishore Papineni, Salim Roukos, Todd Ward, and WeiJing Zhu. 2001. BLEU: A method for automatic evaluation of machine translation. In ACL, pages 311–318.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Adam Pauls</author>
<author>John DeNero</author>
<author>Dan Klein</author>
</authors>
<title>Consensus training for consensus decoding in machine translation.</title>
<date>2009</date>
<booktitle>In EMNLP.</booktitle>
<contexts>
<context position="43581" citStr="Pauls et al. (2009)" startWordPosition="7737" endWordPosition="7740">te BLEU (during training only) by an additively decomposable loss (Tromble et al., 2008).15 Our algorithms require that p(d) of (13) is multiplicatively decomposable. It suffices to define 4b(d) def = Ee∈d 4be, so that all features are local to individual hyperedges; the vector 4be indicates which features fire on hyperedge e. Then score(d) of (12) is additively decomposable: �score(d) = �scoree = 4be · θ (15) e∈d e∈d We can then set pe = exp(γ · scoree), and Vpe = γpe4b(e), and use the algorithms described in Section 6 to compute H(p) and R(p) and their gradients with respect to θ and γ.16 15Pauls et al. (2009) concurrently developed a method to maximize the expected n-gram counts on a hypergraph using gradient descent. Their objective is similar to the minimum risk objective (though without annealing), and their gradient descent optimization involves in algorithms in computing expected feature/n-gram counts as well as expected products of features and n-gram counts, which can be viewed as instances of our general algorithms with first- and second-order semirings. They focused on tuning only a small number (i.e. nine) of features as in a regular MERT setting, while our experiments involve both a sma</context>
<context position="46507" citStr="Pauls et al. (2009)" startWordPosition="8241" endWordPosition="8244">f Features MR (with or without DA) is scalable to tune a large number of features, while MERT is not. To achieve competitive performance, we adopt a forest reranking approach (Li and Khudanpur, 2009; Huang, 2008). Specifically, our training has two stages. In the first stage, we train a baseline system as usual. We also find the optimal feature weights for the five features mentioned before, using the method of MR+DA operating on a hypergraph. In the second stage, we generate a hypergraph for each sentence in the training data (which consists of about 40k sentence pairs), using the baseline 17Pauls et al. (2009) concurrently observed a similar pattern (i.e., MR performs worse than MERT on the dev set, but performs better on a test set). 18We also verified that MR+DA found a better objective value (i.e., expected loss on the dev set) than MR. Training scheme dev test MERT (Nbest, small) 42.6 47.7 MR (Nbest, small) 40.8 47.7 MR+DA (Nbest, small) 41.6 47.8 MR (hypergraph, small) 41.3 48.4 MR+DA (hypergraph, small) 41.9 48.3 MR (hypergraph, large) 42.3 48.7 Table 5: BLEU scores on the Dev and test sets under different training scenarios. In the “small” model, five features (i.e., one for the language mod</context>
</contexts>
<marker>Pauls, DeNero, Klein, 2009</marker>
<rawString>Adam Pauls, John DeNero, and Dan Klein. 2009. Consensus training for consensus decoding in machine translation. In EMNLP.</rawString>
</citation>
<citation valid="true">
<authors>
<author>B A Pearlmutter</author>
<author>J M Siskind</author>
</authors>
<title>Lazy multivariate higher-order forward-mode ad.</title>
<date>2007</date>
<booktitle>In Proceedings of the 34th Annual Symposium on Principles of Programming Languages (POPL),</booktitle>
<pages>155--160</pages>
<marker>Pearlmutter, Siskind, 2007</marker>
<rawString>B. A. Pearlmutter and J. M. Siskind. 2007. Lazy multivariate higher-order forward-mode ad. In Proceedings of the 34th Annual Symposium on Principles of Programming Languages (POPL), pages 155–160.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Fernando C N Pereira</author>
<author>David H D Warren</author>
</authors>
<title>Parsing as deduction.</title>
<date>1983</date>
<booktitle>In ACL,</booktitle>
<pages>137--144</pages>
<contexts>
<context position="2459" citStr="Pereira and Warren, 1983" startWordPosition="362" endWordPosition="365">ee structures (Chiang, 2007). ∗This research was partially supported by the Defense Advanced Research Projects Agency’s GALE program via Contract No HR0011-06-2-0001. We are grateful to Sanjeev Khudanpur for early guidance and regular discussions. Given a hypergraph, we are often interested in computing some quantities over it using dynamic programming algorithms. For example, we may want to run the Viterbi algorithm to find the most probable derivation tree in the hypergraph, or the k most probable trees. Semiring-weighted logic programming is a general framework to specify these algorithms (Pereira and Warren, 1983; Shieber et al., 1994; Goodman, 1999; Eisner et al., 2005; Lopez, 2009). Goodman (1999) describes many useful semirings (e.g., Viterbi, inside, and Viterbin-best). While most of these semirings are used in “testing” (i.e., decoding), we are mainly interested in the semirings that are useful for “training” (i.e., parameter estimation). The expectation semiring (Eisner, 2002), originally proposed for finite-state machines, is one such “training” semiring, and can be used to compute feature expectations for the Estep of the EM algorithm, or gradients of the likelihood function for gradient desce</context>
</contexts>
<marker>Pereira, Warren, 1983</marker>
<rawString>Fernando C. N. Pereira and David H. D. Warren. 1983. Parsing as deduction. In ACL, pages 137–144.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Chris Quirk</author>
<author>Arul Menezes</author>
<author>Colin Cherry</author>
</authors>
<title>Dependency treelet translation: syntactically informed phrasal smt.</title>
<date>2005</date>
<booktitle>In ACL,</booktitle>
<pages>271--279</pages>
<contexts>
<context position="1713" citStr="Quirk et al., 2005" startWordPosition="247" endWordPosition="250">in an open-source machine translation toolkit, Joshua, enabling minimum-risk training for a benefit of up to 1.0 BLEU point. 1 Introduction A hypergraph or “packed forest” (Gallo et al., 1993; Klein and Manning, 2004; Huang and Chiang, 2005) is a compact data structure that uses structure-sharing to represent exponentially many trees in polynomial space. A weighted hypergraph also defines a probability or other weight for each tree, and can be used to represent the hypothesis space considered (for a given input) by a monolingual parser or a tree-based translation system, e.g., tree to string (Quirk et al., 2005; Liu et al., 2006), string to tree (Galley et al., 2006), tree to tree (Eisner, 2003), or string to string with latent tree structures (Chiang, 2007). ∗This research was partially supported by the Defense Advanced Research Projects Agency’s GALE program via Contract No HR0011-06-2-0001. We are grateful to Sanjeev Khudanpur for early guidance and regular discussions. Given a hypergraph, we are often interested in computing some quantities over it using dynamic programming algorithms. For example, we may want to run the Viterbi algorithm to find the most probable derivation tree in the hypergra</context>
</contexts>
<marker>Quirk, Menezes, Cherry, 2005</marker>
<rawString>Chris Quirk, Arul Menezes, and Colin Cherry. 2005. Dependency treelet translation: syntactically informed phrasal smt. In ACL, pages 271–279.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kenneth Rose</author>
</authors>
<title>Deterministic annealing for clustering, compression, classification, regression, and related optimization problems.</title>
<date>1998</date>
<booktitle>In Proceedings of the IEEE,</booktitle>
<pages>2210--2239</pages>
<contexts>
<context position="4333" citStr="Rose, 1998" startWordPosition="643" endWordPosition="644">ny interesting quantities over the hypergraph using the expectation and variance semirings. These quantities include expected hypothesis length, feature expectation, entropy, cross-entropy, KullbackLeibler divergence, Bayes risk, variance of hypothesis length, gradient of entropy and Bayes risk, covariance and Hessian matrix, and so on. The variance semiring is essential for many interesting training paradigms such as deterministic 40 Proceedings of the 2009 Conference on Empirical Methods in Natural Language Processing, pages 40–51, Singapore, 6-7 August 2009. c�2009 ACL and AFNLP annealing (Rose, 1998), minimum risk (Smith and Eisner, 2006), active and semi-supervised learning (Grandvalet and Bengio, 2004; Jiao et al., 2006). In these settings, we must compute the gradient of entropy or risk. The semirings can also be used for second-order gradient optimization algorithms. We implement the expectation and variance semirings in Joshua (Li et al., 2009a), and demonstrate their practical benefit by using minimumrisk training to improve Hiero (Chiang, 2007). 2 Semiring Parsing on Hypergraphs We use a specific tree-based system called Hiero (Chiang, 2007) as an example, although the discussion i</context>
<context position="42205" citStr="Rose, 1998" startWordPosition="7502" endWordPosition="7503"> not scale to a large number of parameters. Smith and Eisner (2006) instead propose a differentiable objective that can be optimized by gradient descent: the Bayes risk R(p) of (7). This is the expected loss if one were (hypothetically) to use a randomized decoder, which chooses a hypothesis d in proportion to its probability p(d). If entropy H(p) is large (e.g., small γ), the Bayes risk is smooth and has few local minima. Thus, Smith and Eisner (2006) try to avoid local minima by starting with large H(p) and decreasing it gradually during optimization. This is called deterministic annealing (Rose, 1998). As H(p) —* 0 (e.g., large γ), the Bayes risk does approach the MERT objective (i.e. minimizing 1-best error).The objective is minimize R(p) − T · H(p) (14) where the “temperature” T starts high and is explicitly decreased as optimization proceeds. 7.3 Gradient Descent Optimization Solving (14) for a given T requires computing the entropy H(p) and risk R(p) and their gradients with respect to θ and γ. Smith and Eisner (2006) followed MERT in constraining their decoder to only an n-best list, so for them, computing these quantities did not involve dynamic programming. We compare those methods </context>
</contexts>
<marker>Rose, 1998</marker>
<rawString>Kenneth Rose. 1998. Deterministic annealing for clustering, compression, classification, regression, and related optimization problems. In Proceedings of the IEEE, pages 2210–2239.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Stuart M Shieber</author>
<author>Yves Schabes</author>
<author>Fernando C N Pereira</author>
</authors>
<title>Principles and implementation of deductive parsing.</title>
<date>1994</date>
<journal>Journal of Logic Programming,</journal>
<pages>24--3</pages>
<contexts>
<context position="2481" citStr="Shieber et al., 1994" startWordPosition="366" endWordPosition="369">7). ∗This research was partially supported by the Defense Advanced Research Projects Agency’s GALE program via Contract No HR0011-06-2-0001. We are grateful to Sanjeev Khudanpur for early guidance and regular discussions. Given a hypergraph, we are often interested in computing some quantities over it using dynamic programming algorithms. For example, we may want to run the Viterbi algorithm to find the most probable derivation tree in the hypergraph, or the k most probable trees. Semiring-weighted logic programming is a general framework to specify these algorithms (Pereira and Warren, 1983; Shieber et al., 1994; Goodman, 1999; Eisner et al., 2005; Lopez, 2009). Goodman (1999) describes many useful semirings (e.g., Viterbi, inside, and Viterbin-best). While most of these semirings are used in “testing” (i.e., decoding), we are mainly interested in the semirings that are useful for “training” (i.e., parameter estimation). The expectation semiring (Eisner, 2002), originally proposed for finite-state machines, is one such “training” semiring, and can be used to compute feature expectations for the Estep of the EM algorithm, or gradients of the likelihood function for gradient descent. In this paper, we </context>
<context position="10797" citStr="Shieber et al., 1994" startWordPosition="1774" endWordPosition="1777">n the real semiring (Il2, +, x, 0, 1), we define p* = (1 − p)−1 (= 1 + p + p2 + ...) for |p |&lt; 1 and is undefined otherwise. The closure operator enables exact summation over the infinitely many paths in a cyclic FSM, or trees in a hypergraph with non-branching cycles, without the need to iterate around cycles to numerical convergence. For completeness, we specify the closure operator for our semirings, satisfying the axioms k* = 1 ® k ® k* = 1 ® k* ® k, but we do not use it in our experiments since our hypergraphs are acyclic. 3We assume that HG has already been built by deductive inference (Shieber et al., 1994). But in practice, the nodes’ inside weights ,3(v) are usually accumulated as the hypergraph is being built, so that pruning heuristics can consult them. 4Actually, the notation ®eEd ke assumes that ® is commutative as well, as does the notation “for u E T(e)” in our algorithms; neither specifies a loop order. One could however use a non-commutative semiring by ordering each hyperedge’s antecedents and specifying that a derivation’s weight is the product of the weights of its hyperedges when visited in prefix order. Tables 1–2 will not assume any commutativity. INSIDE(HG, K) 1 for v in topolog</context>
</contexts>
<marker>Shieber, Schabes, Pereira, 1994</marker>
<rawString>Stuart M. Shieber, Yves Schabes, and Fernando C. N. Pereira. 1994. Principles and implementation of deductive parsing. Journal of Logic Programming, 24:3–36.</rawString>
</citation>
<citation valid="true">
<authors>
<author>David A Smith</author>
<author>Jason Eisner</author>
</authors>
<title>Minimum risk annealing for training log-linear models.</title>
<date>2006</date>
<booktitle>In ACL,</booktitle>
<pages>787--794</pages>
<contexts>
<context position="4372" citStr="Smith and Eisner, 2006" startWordPosition="647" endWordPosition="650">ver the hypergraph using the expectation and variance semirings. These quantities include expected hypothesis length, feature expectation, entropy, cross-entropy, KullbackLeibler divergence, Bayes risk, variance of hypothesis length, gradient of entropy and Bayes risk, covariance and Hessian matrix, and so on. The variance semiring is essential for many interesting training paradigms such as deterministic 40 Proceedings of the 2009 Conference on Empirical Methods in Natural Language Processing, pages 40–51, Singapore, 6-7 August 2009. c�2009 ACL and AFNLP annealing (Rose, 1998), minimum risk (Smith and Eisner, 2006), active and semi-supervised learning (Grandvalet and Bengio, 2004; Jiao et al., 2006). In these settings, we must compute the gradient of entropy or risk. The semirings can also be used for second-order gradient optimization algorithms. We implement the expectation and variance semirings in Joshua (Li et al., 2009a), and demonstrate their practical benefit by using minimumrisk training to improve Hiero (Chiang, 2007). 2 Semiring Parsing on Hypergraphs We use a specific tree-based system called Hiero (Chiang, 2007) as an example, although the discussion is general for any systems that use a hy</context>
<context position="41661" citStr="Smith and Eisner (2006)" startWordPosition="7406" endWordPosition="7409">ures of d. We then define the unnormalized distribution p(d) as p(d) = exp(γ · score(d)) (13) where the scale factor γ adjusts how sharply the distribution favors the highest-scoring hypotheses. 7.2 Minimum-Risk Training Adjusting θ or γ changes the distribution p. Minimum error rate training (MERT) (Och, 2003) tries to tune θ to minimize the BLEU loss of a decoder that chooses the most probable output according to p. (γ has no effect.) MERT’s specialized linesearch addresses the problem that this objective function is piecewise constant, but it does not scale to a large number of parameters. Smith and Eisner (2006) instead propose a differentiable objective that can be optimized by gradient descent: the Bayes risk R(p) of (7). This is the expected loss if one were (hypothetically) to use a randomized decoder, which chooses a hypothesis d in proportion to its probability p(d). If entropy H(p) is large (e.g., small γ), the Bayes risk is smooth and has few local minima. Thus, Smith and Eisner (2006) try to avoid local minima by starting with large H(p) and decreasing it gradually during optimization. This is called deterministic annealing (Rose, 1998). As H(p) —* 0 (e.g., large γ), the Bayes risk does appr</context>
</contexts>
<marker>Smith, Eisner, 2006</marker>
<rawString>David A. Smith and Jason Eisner. 2006. Minimum risk annealing for training log-linear models. In ACL, pages 787–794.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Andreas Stolcke</author>
</authors>
<title>SRILM—an extensible language modeling toolkit.</title>
<date>2002</date>
<booktitle>In Proceedings of the International Conference on Spoken Language Processing,</booktitle>
<pages>901--904</pages>
<contexts>
<context position="44771" citStr="Stolcke, 2002" startWordPosition="7938" endWordPosition="7939">ments involve both a small and a large number of features. 16It is easy to verify that the gradient of a function f (e.g. entropy or risk) with respect to γ can be written as a weighted sum of gradients with respect to the feature weights θi, i.e. = 1 θi × ae (16) γ i i ∂f ∂ry 49 7.4 Experimental Results 7.4.1 Experimental Setup We built a translation model on a corpus for IWSLT 2005 Chinese-to-English translation task (Eck and Hori, 2005), which consists of 40k pairs of sentences. We used a 5-gram language model with modified Kneser-Ney smoothing, trained on the bitext’s English using SRILM (Stolcke, 2002). 7.4.2 Tuning a Small Number of Features We first investigate how minimum-risk training (MR), with and without deterministic annealing (DA), performs compared to regular MERT. MR without DA just fixes T = 0 and γ = 1 in (14). All MR or MR+DA uses an approximated BLEU (Tromble et al., 2008) (for training only), while MERT uses the exact corpus BLEU in training. The first five rows in Table 5 present the results by tuning the weights offive features (θ ∈ R5). We observe that MR or MR+DA performs worse than MERT on the dev set. This may be mainly because MR or MR+DA uses an approximated BLEU whi</context>
</contexts>
<marker>Stolcke, 2002</marker>
<rawString>Andreas Stolcke. 2002. SRILM—an extensible language modeling toolkit. In Proceedings of the International Conference on Spoken Language Processing, pages 901–904.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Roy Tromble</author>
<author>Shankar Kumar</author>
<author>Franz Och</author>
<author>Wolfgang Macherey</author>
</authors>
<title>Lattice minimum-Bayesrisk decoding for statistical machine translation.</title>
<date>2008</date>
<booktitle>In EMNLP,</booktitle>
<pages>620--629</pages>
<contexts>
<context position="37887" citStr="Tromble et al. (2008)" startWordPosition="6699" endWordPosition="6702"> semiring with hydef peredge weights (pe, pere) with re = log qe. The KL divergence to p from q can be computed as KL(p II q) = H(p, q) − H(p). Expected Loss (Risk) Given a reference sentence y*, the expected loss (i.e., Bayes risk) of the hypotheses in the hypergraph is defined as, R(p) = � (p(d)/Z)L(Y(d), y*) (7) dED where Y(d) is the target yield of d and L(y, y*) is the loss of the hypothesis y with respect to the reference y*. The popular machine translation metric, BLEU (Papineni et al., 2001), is not additively decomposable, and thus we are not able to compute the expected loss for it. Tromble et al. (2008) develop the following loss function, of which a linear approximation to BLEU is a special case, � (p(d)/Z) log(p(d)/Z) (5) � θw#w(y)δw(y*)) (8) H(p) = − L(y, y*) = −(θ0|y |+ dED wEN 1 � = log Z − Z dED 1 � = log Z − Z dED def provided that we define re = log pe (so that r(d) = EeEd re = log p(d)). Of course, we can compute (Z, r) as explained in Section 3.2. Cross-Entropy and KL Divergence We may be interested in computing the cross-entropy or KL divergence between two distributions p and q. For example, in variational decoding for machine translation (Li et al., 2009b), p is a distribution r</context>
<context position="43050" citStr="Tromble et al., 2008" startWordPosition="7640" endWordPosition="7643">as optimization proceeds. 7.3 Gradient Descent Optimization Solving (14) for a given T requires computing the entropy H(p) and risk R(p) and their gradients with respect to θ and γ. Smith and Eisner (2006) followed MERT in constraining their decoder to only an n-best list, so for them, computing these quantities did not involve dynamic programming. We compare those methods to training on a hypergraph containing exponentially many hypotheses. In this condition, we need our new secondorder semiring methods and must also approximate BLEU (during training only) by an additively decomposable loss (Tromble et al., 2008).15 Our algorithms require that p(d) of (13) is multiplicatively decomposable. It suffices to define 4b(d) def = Ee∈d 4be, so that all features are local to individual hyperedges; the vector 4be indicates which features fire on hyperedge e. Then score(d) of (12) is additively decomposable: �score(d) = �scoree = 4be · θ (15) e∈d e∈d We can then set pe = exp(γ · scoree), and Vpe = γpe4b(e), and use the algorithms described in Section 6 to compute H(p) and R(p) and their gradients with respect to θ and γ.16 15Pauls et al. (2009) concurrently developed a method to maximize the expected n-gram coun</context>
<context position="45062" citStr="Tromble et al., 2008" startWordPosition="7987" endWordPosition="7990"> Experimental Results 7.4.1 Experimental Setup We built a translation model on a corpus for IWSLT 2005 Chinese-to-English translation task (Eck and Hori, 2005), which consists of 40k pairs of sentences. We used a 5-gram language model with modified Kneser-Ney smoothing, trained on the bitext’s English using SRILM (Stolcke, 2002). 7.4.2 Tuning a Small Number of Features We first investigate how minimum-risk training (MR), with and without deterministic annealing (DA), performs compared to regular MERT. MR without DA just fixes T = 0 and γ = 1 in (14). All MR or MR+DA uses an approximated BLEU (Tromble et al., 2008) (for training only), while MERT uses the exact corpus BLEU in training. The first five rows in Table 5 present the results by tuning the weights offive features (θ ∈ R5). We observe that MR or MR+DA performs worse than MERT on the dev set. This may be mainly because MR or MR+DA uses an approximated BLEU while MERT doesn’t. On the test set, MR or MR+DA on an n-best list is comparable to MERT. But our new approach, MR or MR+DA on a hypergraph, does consistently better (statistically significant) than MERT, despite approximating BLEU.17 Did DA help? For both n-best and hypergraph, MR+DA did obta</context>
</contexts>
<marker>Tromble, Kumar, Och, Macherey, 2008</marker>
<rawString>Roy Tromble, Shankar Kumar, Franz Och, and Wolfgang Macherey. 2008. Lattice minimum-Bayesrisk decoding for statistical machine translation. In EMNLP, pages 620–629.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>