<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000591">
<title confidence="0.998879">
Stochastic Gradient Descent Training for
L1-regularized Log-linear Models with Cumulative Penalty
</title>
<author confidence="0.997277">
Yoshimasa Tsuruokatt Jun’ichi Tsujiitt* Sophia Ananiadoutt
</author>
<affiliation confidence="0.956211666666667">
t School of Computer Science, University of Manchester, UK
t National Centre for Text Mining (NaCTeM), UK
* Department of Computer Science, University of Tokyo, Japan
</affiliation>
<email confidence="0.997524">
{yoshimasa.tsuruoka,j.tsujii,sophia.ananiadou}@manchester.ac.uk
</email>
<sectionHeader confidence="0.994769" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999919653846154">
Stochastic gradient descent (SGD) uses
approximate gradients estimated from
subsets of the training data and updates
the parameters in an online fashion. This
learning framework is attractive because
it often requires much less training time
in practice than batch training algorithms.
However, L1-regularization, which is be-
coming popular in natural language pro-
cessing because of its ability to pro-
duce compact models, cannot be effi-
ciently applied in SGD training, due to
the large dimensions of feature vectors
and the fluctuations of approximate gra-
dients. We present a simple method to
solve these problems by penalizing the
weights according to cumulative values for
L1 penalty. We evaluate the effectiveness
of our method in three applications: text
chunking, named entity recognition, and
part-of-speech tagging. Experimental re-
sults demonstrate that our method can pro-
duce compact and accurate models much
more quickly than a state-of-the-art quasi-
Newton method for L1-regularized log-
linear models.
</bodyText>
<sectionHeader confidence="0.998882" genericHeader="introduction">
1 Introduction
</sectionHeader>
<bodyText confidence="0.999925038461539">
Log-linear models (a.k.a maximum entropy mod-
els) are one of the most widely-used probabilistic
models in the field of natural language process-
ing (NLP). The applications range from simple
classification tasks such as text classification and
history-based tagging (Ratnaparkhi,1996) to more
complex structured prediction tasks such as part-
of-speech (POS) tagging (Lafferty et al., 2001),
syntactic parsing (Clark and Curran, 2004) and se-
mantic role labeling (Toutanova et al., 2005). Log-
linear models have a major advantage over other
discriminative machine learning models such as
support vector machines—their probabilistic out-
put allows the information on the confidence of
the decision to be used by other components in the
text processing pipeline.
The training of log-liner models is typically per-
formed based on the maximum likelihood crite-
rion, which aims to obtain the weights of the fea-
tures that maximize the conditional likelihood of
the training data. In maximum likelihood training,
regularization is normally needed to prevent the
model from overfitting the training data,
The two most common regularization methods
are called L1 and L2 regularization. L1 regular-
ization penalizes the weight vector for its L1-norm
(i.e. the sum of the absolute values of the weights),
whereas L2 regularization uses its L2-norm. There
is usually not a considerable difference between
the two methods in terms of the accuracy of the
resulting model (Gao et al., 2007), but L1 regu-
larization has a significant advantage in practice.
Because many of the weights of the features be-
come zero as a result of L1-regularized training,
the size of the model can be much smaller than that
produced by L2-regularization. Compact models
require less space on memory and storage, and en-
able the application to start up quickly. These mer-
its can be of vital importance when the application
is deployed in resource-tight environments such as
cell-phones.
A common way to train a large-scale L1-
regularized model is to use a quasi-Newton
method. Kazama and Tsujii (2003) describe a
method for training a L1-regularized log-linear
model with a bound constrained version of the
BFGS algorithm (Nocedal, 1980). Andrew and
Gao (2007) present an algorithm called Orthant-
Wise Limited-memory Quasi-Newton (OWL-
QN), which can work on the BFGS algorithm
without bound constraints and achieve faster con-
vergence.
</bodyText>
<page confidence="0.976359">
477
</page>
<note confidence="0.999612">
Proceedings of the 47th Annual Meeting of the ACL and the 4th IJCNLP of the AFNLP, pages 477–485,
Suntec, Singapore, 2-7 August 2009. c�2009 ACL and AFNLP
</note>
<bodyText confidence="0.999896295081967">
An alternative approach to training a log-linear
model is to use stochastic gradient descent (SGD)
methods. SGD uses approximate gradients esti-
mated from subsets of the training data and up-
dates the weights of the features in an online
fashion—the weights are updated much more fre-
quently than batch training algorithms. This learn-
ing framework is attracting attention because it of-
ten requires much less training time in practice
than batch training algorithms, especially when
the training data is large and redundant. SGD was
recently used for NLP tasks including machine
translation (Tillmann and Zhang, 2006) and syn-
tactic parsing (Smith and Eisner, 2008; Finkel et
al., 2008). Also, SGD is very easy to implement
because it does not need to use the Hessian infor-
mation on the objective function. The implemen-
tation could be as simple as the perceptron algo-
rithm.
Although SGD is a very attractive learning
framework, the direct application of L1 regular-
ization in this learning framework does not result
in efficient training. The first problem is the inef-
ficiency of applying the L1 penalty to the weights
of all features. In NLP applications, the dimen-
sion of the feature space tends to be very large—it
can easily become several millions, so the appli-
cation of L1 penalty to all features significantly
slows down the weight updating process. The sec-
ond problem is that the naive application of L1
penalty in SGD does not always lead to compact
models, because the approximate gradient used at
each update is very noisy, so the weights of the
features can be easily moved away from zero by
those fluctuations.
In this paper, we present a simple method for
solving these two problems in SGD learning. The
main idea is to keep track of the total penalty and
the penalty that has been applied to each weight,
so that the L1 penalty is applied based on the dif-
ference between those cumulative values. That
way, the application of L1 penalty is needed only
for the features that are used in the current sample,
and also the effect of noisy gradient is smoothed
away.
We evaluate the effectiveness of our method
by using linear-chain conditional random fields
(CRFs) and three traditional NLP tasks, namely,
text chunking (shallow parsing), named entity
recognition, and POS tagging. We show that our
enhanced SGD learning method can produce com-
pact and accurate models much more quickly than
the OWL-QN algorithm.
This paper is organized as follows. Section 2
provides a general description of log-linear mod-
els used in NLP. Section 3 describes our stochastic
gradient descent method for L1-regularized log-
linear models. Experimental results are presented
in Section 4. Some related work is discussed in
Section 5. Section 6 gives some concluding re-
marks.
</bodyText>
<sectionHeader confidence="0.997813" genericHeader="method">
2 Log-Linear Models
</sectionHeader>
<bodyText confidence="0.9706334">
In this section, we briefly describe log-linear mod-
els used in NLP tasks and L1 regularization.
A log-linear model defines the following prob-
abilistic distribution over possible structure y for
input x:
</bodyText>
<equation confidence="0.9979385">
1
p(y|x) = Z(x) exp wifi(y, x),
</equation>
<bodyText confidence="0.996972333333333">
where fi(y, x) is a function indicating the occur-
rence of feature i, wi is the weight of the feature,
and Z(x) is a partition (normalization) function:
</bodyText>
<equation confidence="0.9991355">
Z(x) = exp wifi(y, x).
Y i
</equation>
<bodyText confidence="0.999873307692308">
If the structure is a sequence, the model is called
a linear-chain CRF model, and the marginal prob-
abilities of the features and the partition function
can be efficiently computed by using the forward-
backward algorithm. The model is used for a va-
riety of sequence labeling tasks such as POS tag-
ging, chunking, and named entity recognition.
If the structure is a tree, the model is called a
tree CRF model, and the marginal probabilities
can be computed by using the inside-outside algo-
rithm. The model can be used for tasks like syn-
tactic parsing (Finkel et al., 2008) and semantic
role labeling (Cohn and Blunsom, 2005).
</bodyText>
<subsectionHeader confidence="0.985538">
2.1 Training
</subsectionHeader>
<bodyText confidence="0.99863375">
The weights of the features in a log-linear model
are optimized in such a way that they maximize
the regularized conditional log-likelihood of the
training data:
</bodyText>
<equation confidence="0.966963">
N
LW = log p(yj|xj; w) − R(w), (1)
j=1
</equation>
<bodyText confidence="0.9985075">
where N is the number of training samples, yj is
the correct output for input xj, and R(w) is the
</bodyText>
<equation confidence="0.798615">
i
</equation>
<page confidence="0.866755">
478
</page>
<subsectionHeader confidence="0.556885">
3.1 L1 regularization
</subsectionHeader>
<bodyText confidence="0.9995846">
The update equation for the weight of each feature
i is as follows:
regularization term which prevents the model from
overfitting the training data. In the case of L1 reg-
ularization, the term is defined as:
</bodyText>
<equation confidence="0.998393">
X |wi|, ∂ wik+1 = wik + ηk ∂wi (L(j, w) − N  |wi  |).
R(w) = C
i
</equation>
<bodyText confidence="0.998686333333333">
where C is the meta-parameter that controls the
degree of regularization, which is usually tuned by
cross-validation or using the heldout data.
In what follows, we denote by L(j, w)
the conditional log-likelihood of each sample
log p(yj|xj; w). Equation 1 is rewritten as:
</bodyText>
<equation confidence="0.9850025">
L(j, w) − C X |wi|. (2)
i
</equation>
<sectionHeader confidence="0.995803" genericHeader="method">
3 Stochastic Gradient Descent
</sectionHeader>
<bodyText confidence="0.999926578947369">
SGD uses a small randomly-selected subset of the
training samples to approximate the gradient of
the objective function given by Equation 2. The
number of training samples used for this approx-
imation is called the batch size. When the batch
size is N, the SGD training simply translates into
gradient descent (hence is very slow to converge).
By using a small batch size, one can update the
parameters more frequently than gradient descent
and speed up the convergence. The extreme case
is a batch size of 1, and it gives the maximum
frequency of updates and leads to a very simple
perceptron-like algorithm, which we adopt in this
work.1
Apart from using a single training sample to
approximate the gradient, the optimization proce-
dure is the same as simple gradient descent,2 so
the weights of the features are updated at training
sample j as follows:
</bodyText>
<equation confidence="0.958646">
∂ Xwk+1 = wk + ηk ∂w(L(j, w) − C N
i
</equation>
<bodyText confidence="0.9992348">
where k is the iteration counter and ηk is the learn-
ing rate, which is normally designed to decrease
as the iteration proceeds. The actual learning rate
scheduling methods used in our experiments are
described later in Section 3.3.
</bodyText>
<footnote confidence="0.9590474">
1In the actual implementation, we randomly shuffled the
training samples at the beginning of each pass, and then
picked them up sequentially.
2What we actually do here is gradient ascent, but we stick
to the term “gradient descent”.
</footnote>
<bodyText confidence="0.999899666666667">
The difficulty with L1 regularization is that the
last term on the right-hand side of the above equa-
tion is not differentiable when the weight is zero.
One straightforward solution to this problem is to
consider a subgradient at zero and use the follow-
ing update equation:
</bodyText>
<equation confidence="0.978220333333333">
− C
wik+1 = wik + ηk ∂L(j, w) N ηksign(wk i ),
∂wi
</equation>
<bodyText confidence="0.999961583333334">
where sign(x) = 1 if x &gt; 0, sign(x) = −1 if x &lt;
0, and sign(x) = 0 if x = 0. In this paper, we call
this weight updating method “SGD-L1 (Naive)”.
This naive method has two serious problems.
The first problem is that, at each update, we need
to perform the application of L1 penalty to all fea-
tures, including the features that are not used in
the current training sample. Since the dimension
of the feature space can be very large, it can sig-
nificantly slow down the weight update process.
The second problem is that it does not produce
a compact model, i.e. most of the weights of the
features do not become zero as a result of train-
ing. Note that the weight of a feature does not be-
come zero unless it happens to fall on zero exactly,
which rarely happens in practice.
Carpenter (2008) describes an alternative ap-
proach. The weight updating process is divided
into two steps. First, the weight is updated with-
out considering the L1 penalty term. Then, the
L1 penalty is applied to the weight to the extent
that it does not change its sign. In other words,
the weight is clipped when it crosses zero. Their
weight update procedure is as follows:
</bodyText>
<equation confidence="0.981577642857143">
k+ 1
if wi &gt; 0 then
2
wk+1
i = max(0, wk+1
i − C
2 N ηk),
k+ 1
else if wi&lt; 0 then
2
wk+1
i = min(0, wk+ 1
i + C
2 N ηk).
</equation>
<bodyText confidence="0.7860395">
In this paper, we call this update method “SGD-
L1 (Clipping)”. It should be noted that this method
</bodyText>
<equation confidence="0.994754777777778">
XN
j=1
Lw =
k+1 ∂L(j, w)
wi = wk
2 i + ηk
|wi|),
���,
∂wi �w=wk
</equation>
<page confidence="0.996029">
479
</page>
<figure confidence="0.9945415">
0 1000 2000 3000 4000 5000 6000
Updates
</figure>
<figureCaption confidence="0.999968">
Figure 1: An example of weight updates.
</figureCaption>
<bodyText confidence="0.99773425">
up a little and be pulled back to zero straightaway.
Here, we present a different strategy for apply-
ing the L1 penalty to the weights of the features.
The key idea is to smooth out the effect of fluctu-
ating gradients by considering the cumulative ef-
fects from L1 penalty.
Let uk be the absolute value of the total L1-
penalty that each weight could have received up
to the point. Since the absolute value of the L1
penalty does not depend on the weight and we are
using the same regularization constant C for all
weights, it is simply accumulated as:
</bodyText>
<figure confidence="0.995663">
Weight 0.1
0.05
0
-0.05
-0.1
</figure>
<bodyText confidence="0.971120666666666">
is actually a special case of the FOLOS algorithm
(Duchi and Singer, 2008) and the truncated gradi-
ent method (Langford et al., 2009).
The obvious advantage of using this method is
that we can expect many of the weights of the
features to become zero during training. Another
merit is that it allows us to perform the applica-
tion of L1 penalty in a lazy fashion, so that we
do not need to update the weights of the features
that are not used in the current sample, which leads
to much faster training when the dimension of the
feature space is large. See the aforementioned pa-
pers for the details. In this paper, we call this effi-
cient implementation “SGD-L1 (Clipping + Lazy-
Update)”.
3.2 L1 regularization with cumulative
penalty
Unfortunately, the clipping-at-zero approach does
not solve all problems. Still, we often end up with
many features whose weights are not zero. Re-
call that the gradient used in SGD is a crude ap-
proximation to the true gradient and is very noisy.
The weight of a feature is, therefore, easily moved
away from zero when the feature is used in the
current sample.
Figure 1 gives an illustrative example in which
the weight of a feature fails to become zero. The
figure shows how the weight of a feature changes
during training. The weight goes up sharply when
it is used in the sample and then is pulled back
toward zero gradually by the L1 penalty. There-
fore, the weight fails to become zero if the feature
is used toward the end of training, which is the
case in this example. Note that the weight would
become zero if the true (fluctuationless) gradient
were used—at each update the weight would go
</bodyText>
<equation confidence="0.985199571428572">
ηt. (3)
At each training sample, we update the weights
of the features that are used in the sample as fol-
lows:
k+2 k + % aw
i Lwk
wi = wi ,
wk+1
= max(0, wk+2
(uk + qk
1))
= min(0,
i
−
−
,k+ 1
else if wi &lt; 0 then
2wk+1i
wk+ 1
i + (uk − qk−1
2 i )),
</equation>
<bodyText confidence="0.9921995">
where qki is the total L1-penalty that wi has actu-
ally received up to the point:
</bodyText>
<equation confidence="0.820377875">
(wt+1
i − wt+ 1
i ).
2
k+ 1
if wi &gt; 0 then
2
(4)
</equation>
<bodyText confidence="0.9979633">
This weight updating method penalizes the
weight according to the difference between uk and
In effect, it forces the weight to receive the
total
penalty that would have been applied if
the weight had been updated by the true gradients,
assuming that the current weight vector resides in
the same orthant as the true weight vector.
It should be noted that this method is basi-
cally equivalent to a
</bodyText>
<subsectionHeader confidence="0.338063">
(Clipping +
</subsectionHeader>
<bodyText confidence="0.921087625">
method if we were able to use the true
gradients instead of the stochastic gradients.
In this paper, we call this weight updating
method
The implemen-
tation of this method is very simple. Figure 2
shows the whole SGD training algori
qk−1
</bodyText>
<equation confidence="0.972058571428571">
i .
L1
“SGD-L1
Lazy-
Update)”
“SGD-L1(Cumulative)”.
thm with this
strategy in pseudo-code.
C k
uk = N t=1
aL(j, w)
k
qk i =
t=1
</equation>
<page confidence="0.937892">
480
</page>
<listItem confidence="0.9705318">
1: procedure TRAIN(C)
2: u &lt;-- 0
3: Initialize wi and qi with zero for all i
4: for k = 0 to MaxIterations
5: 77 &lt;-- LEARNINGRATE(k)
6: u &lt;-- u + 77C/N
7: Select sample j randomly
8: UPDATEWEIGHTS(j)
10: procedure UPDATEWEIGHTS(j)
11: for i E features used in sample j
</listItem>
<figure confidence="0.9958305">
∂L(j,w)
12: wi &lt;-- wi + 77 ∂w�
13: APPLYPENALTY(i)
15: procedure APPLYPENALTY(i)
16: z &lt;-- wi
17: if wi &gt; 0 then
18: wi &lt;-- max(0, wi − (u + qi))
19: else if wi &lt; 0 then
20: wi &lt;-- min(0, wi + (u − qi))
21: qi &lt;-- qi + (wi − z)
</figure>
<figureCaption confidence="0.9864265">
Figure 2: Stochastic gradient descent training with
cumulative L1 penalty. z is a temporary variable.
</figureCaption>
<subsectionHeader confidence="0.999643">
3.3 Learning Rate
</subsectionHeader>
<bodyText confidence="0.99981325">
The scheduling of learning rates often has a major
impact on the convergence speed in SGD training.
A typical choice of learning rate scheduling can
be found in (Collins et al., 2008):
</bodyText>
<equation confidence="0.998926333333333">
77k =
770 (5)
1 + k/N ,
</equation>
<bodyText confidence="0.998788166666667">
where 770 is a constant. Although this scheduling
guarantees ultimate convergence, the actual speed
of convergence can be poor in practice (Darken
and Moody, 1990).
In this work, we also tested simple exponential
decay:
</bodyText>
<equation confidence="0.978592">
77k = 770α−k/N , (6)
</equation>
<bodyText confidence="0.999965733333333">
where α is a constant. In our experiments, we
found this scheduling more practical than that
given in Equation 5. This is mainly because ex-
ponential decay sweeps the range of learning rates
more smoothly—the learning rate given in Equa-
tion 5 drops too fast at the beginning and too
slowly at the end.
It should be noted that exponential decay is not
a good choice from a theoretical point of view, be-
cause it does not satisfy one of the necessary con-
ditions for convergence—the sum of the learning
rates must diverge to infinity (Spall, 2005). How-
ever, this is probably not a big issue for practition-
ers because normally the training has to be termi-
nated at a certain number of iterations in practice.3
</bodyText>
<sectionHeader confidence="0.999013" genericHeader="method">
4 Experiments
</sectionHeader>
<bodyText confidence="0.999939333333333">
We evaluate the effectiveness our training algo-
rithm using linear-chain CRF models and three
NLP tasks: text chunking, named entity recogni-
tion, and POS tagging.
To compare our algorithm with the state-of-the-
art, we present the performance of the OWL-QN
algorithm on the same data. We used the publicly
available OWL-QN optimizer developed by An-
drew and Gao.4 The meta-parameters for learning
were left unchanged from the default settings of
the software: the convergence tolerance was 1e-4;
and the L-BFGS memory parameter was 10.
</bodyText>
<subsectionHeader confidence="0.990824">
4.1 Text Chunking
</subsectionHeader>
<bodyText confidence="0.99994224">
The first set of experiments used the text chunk-
ing data set provided for the CoNLL 2000 shared
task.5 The training data consists of 8,936 sen-
tences in which each token is annotated with the
“IOB” tags representing text chunks such as noun
and verb phrases. We separated 1,000 sentences
from the training data and used them as the held-
out data. The test data provided by the shared task
was used only for the final accuracy report.
The features used in this experiment were uni-
grams and bigrams of neighboring words, and un-
igrams, bigrams and trigrams of neighboring POS
tags.
To avoid giving any advantage to our SGD al-
gorithms over the OWL-QN algorithm in terms of
the accuracy of the resulting model, the OWL-QN
algorithm was used when tuning the regularization
parameter C. The tuning was performed in such a
way that it maximized the likelihood of the heldout
data. The learning rate parameters for SGD were
then tuned in such a way that they maximized the
value of the objective function in 30 passes. We
first determined 770 by testing 1.0, 0.5, 0.2, and 0.1.
We then determined α by testing 0.9, 0.85, and 0.8
with the fixed 770.
</bodyText>
<footnote confidence="0.995074833333333">
3This issue could also be sidestepped by, for example,
adding a small O(1/k) term to the learning rate.
4Available from the original developers’ websites:
http://research.microsoft.com/en-us/people/galena/ or
http://research.microsoft.com/en-us/um/people/jfgao/
5http://www.cnts.ua.ac.be/conll2000/chunking/
</footnote>
<page confidence="0.994001">
481
</page>
<table confidence="0.999857166666667">
Passes L,/N # Features Time (sec) F-score
OWL-QN 160 -1.583 18,109 598 93.62
SGD-L1 (Naive) 30 -1.671 455,651 1,117 93.64
SGD-L1 (Clipping + Lazy-Update) 30 -1.671 87,792 144 93.65
SGD-L1 (Cumulative) 30 -1.653 28,189 149 93.68
SGD-L1 (Cumulative + Exponential-Decay) 30 -1.622 23,584 148 93.66
</table>
<tableCaption confidence="0.999735">
Table 1: CoNLL-2000 Chunking task. Training time and accuracy of the trained model on the test data.
</tableCaption>
<figure confidence="0.9925695">
0 10 20 30 40 50
Passes
0 10 20 30 40 50
Passes
</figure>
<figureCaption confidence="0.9941355">
Figure 4: CoNLL 2000 chunking task: Number of
active features.
</figureCaption>
<bodyText confidence="0.99635278">
Figures 3 and 4 show the training process of
the model. Each figure contains four curves repre-
senting the results of the OWL-QN algorithm and
three SGD-based algorithms. “SGD-L1 (Cumu-
lative + ED)” represents the results of our cumu-
lative penalty-based method that uses exponential
decay (ED) for learning rate scheduling.
Figure 3 shows how the value of the objec-
tive function changed as the training proceeded.
SGD-based algorithms show much faster conver-
gence than the OWL-QN algorithm. Notice also
that “SGD-L1 (Cumulative)” improves the objec-
tive slightly faster than “SGD-L1 (Clipping)”. The
result of “SGD-L1 (Naive)” is not shown in this
figure, but the curve was almost identical to that
of “SGD-L1 (Clipping)”.
Figure 4 shows the numbers of active features
(the features whose weight are not zero). It is
clearly seen that the clipping-at-zero approach
fails to reduce the number of active features, while
our algorithms succeeded in reducing the number
of active features to the same level as OWL-QN.
We then trained the models using the whole
training data (including the heldout data) and eval-
uated the accuracy of the chunker on the test data.
The number of passes performed over the train-
ing data in SGD was set to 30. The results are
shown in Table 1. The second column shows the
number of passes performed in the training. The
third column shows the final value of the objective
function per sample. The fourth column shows
the number of resulting active features. The fifth
column show the training time. The last column
shows the f-score (harmonic mean of recall and
precision) of the chunking results. There was no
significant difference between the models in terms
of accuracy. The naive SGD training took much
longer than OWL-QN because of the overhead of
applying L1 penalty to all dimensions.
Our SGD algorithms finished training in 150
seconds on Xeon 2.13GHz processors. The
CRF++ version 0.50, a popular CRF library de-
veloped by Taku Kudo,6 is reported to take 4,021
seconds on Xeon 3.0GHz processors to train the
model using a richer feature set.7 CRFsuite ver-
sion 0.4, a much faster library for CRFs, is re-
ported to take 382 seconds on Xeon 3.0GHz, using
the same feature set as ours.8 Their library uses the
OWL-QN algorithm for optimization. Although
direct comparison of training times is not impor-
</bodyText>
<footnote confidence="0.997510333333333">
6http://crfpp.sourceforge.net/
7http://www.chokkan.org/software/crfsuite/benchmark.html
8ditto
</footnote>
<figure confidence="0.9980832">
Objective function
-1.6
-1.8
-2.2
-2.4
-2
OWL-QN
SGD-L1 (Clipping)
SGD-L1 (Cumulative)
SGD-L1 (Cumulative + ED)
</figure>
<figureCaption confidence="0.889338">
Figure 3: CoNLL 2000 chunking task: Objective
</figureCaption>
<figure confidence="0.996394">
# Active features
200000
150000
100000
50000
0
OWL-QN
SGD-L1 (Clipping)
SGD-L1 (Cumulative)
SGD-L1 (Cumulative + ED)
</figure>
<page confidence="0.997633">
482
</page>
<bodyText confidence="0.999964">
tant due to the differences in implementation and
hardware platforms, these results demonstrate that
our algorithm can actually result in a very fast im-
plementation of a CRF trainer.
</bodyText>
<subsectionHeader confidence="0.995118">
4.2 Named Entity Recognition
</subsectionHeader>
<bodyText confidence="0.999930434782609">
The second set of experiments used the named
entity recognition data set provided for the
BioNLP/NLPBA 2004 shared task (Kim et al.,
2004).9 The training data consist of 18,546 sen-
tences in which each token is annotated with the
“IOB” tags representing biomedical named enti-
ties such as the names of proteins and RNAs.
The training and test data were preprocessed
by the GENIA tagger,10 which provided POS tags
and chunk tags. We did not use any information on
the named entity tags output by the GENIA tagger.
For the features, we used unigrams of neighboring
chunk tags, substrings (shorter than 10 characters)
of the current word, and the shape of the word (e.g.
“IL-2” is converted into “AA-#”), on top of the
features used in the text chunking experiments.
The results are shown in Figure 5 and Table
2. The trend in the results is the same as that of
the text chunking task: our SGD algorithms show
much faster convergence than the OWL-QN algo-
rithm and produce compact models.
Okanohara et al. (2006) report an f-score of
71.48 on the same data, using semi-Markov CRFs.
</bodyText>
<subsectionHeader confidence="0.999058">
4.3 Part-Of-Speech Tagging
</subsectionHeader>
<bodyText confidence="0.999983647058823">
The third set of experiments used the POS tag-
ging data in the Penn Treebank (Marcus et al.,
1994). Following (Collins, 2002), we used sec-
tions 0-18 of the Wall Street Journal (WSJ) corpus
for training, sections 19-21 for development, and
sections 22-24 for final evaluation. The POS tags
were extracted from the parse trees in the corpus.
All experiments for this work, including the tun-
ing of features and parameters for regularization,
were carried out using the training and develop-
ment sets. The test set was used only for the final
accuracy report.
It should be noted that training a CRF-based
POS tagger using the whole WSJ corpus is not a
trivial task and was once even deemed impractical
in previous studies. For example, Wellner and Vi-
lain (2006) abandoned maximum likelihood train-
</bodyText>
<footnote confidence="0.997241333333333">
9The data is available for download at http://www-
tsujii.is.s.u-tokyo.ac.jp/GENIA/ERtask/report.html
10http://www-tsujii.is.s.u-tokyo.ac.jp/GENIA/tagger/
</footnote>
<figure confidence="0.8997975">
0 10 20 30 40 50
Passes
</figure>
<figureCaption confidence="0.995329">
Figure 5: NLPBA 2004 named entity recognition
task: Objective.
</figureCaption>
<figure confidence="0.99199">
0 10 20 30 40 50
Passes
</figure>
<figureCaption confidence="0.999835">
Figure 6: POS tagging task: Objective.
</figureCaption>
<bodyText confidence="0.999080235294118">
ing because it was “prohibitive” (7-8 days for sec-
tions 0-18 of the WSJ corpus).
For the features, we used unigrams and bigrams
of neighboring words, prefixes and suffixes of
the current word, and some characteristics of the
word. We also normalized the current word by
lowering capital letters and converting all the nu-
merals into ‘#’, and used the normalized word as a
feature.
The results are shown in Figure 6 and Table 3.
Again, the trend is the same. Our algorithms fin-
ished training in about 30 minutes, producing ac-
curate models that are as compact as that produced
by OWL-QN.
Shen et al., (2007) report an accuracy of 97.33%
on the same data set using a perceptron-based bidi-
rectional tagging model.
</bodyText>
<sectionHeader confidence="0.999744" genericHeader="method">
5 Discussion
</sectionHeader>
<bodyText confidence="0.998644">
An alternative approach to producing compact
models for log-linear models is to reformulate the
</bodyText>
<figure confidence="0.997444866666667">
-2.2
-2.4
-2.6
-2.8
-3.2
-3.4
-3.6
-3.8
-3
OWL-QN
SGD-L1 (Clipping)
SGD-L1 (Cumulative)
SGD-L1 (Cumulative + ED)
Objective function
-1.8
-1.9
-2.1
-2.2
-2.3
-2.4
-2.5
-2.6
-2.7
-2.8
-2
OWL-QN
SGD-L1 (Clipping)
SGD-L1 (Cumulative)
SGD-L1 (Cumulative + ED)
Objective function
</figure>
<page confidence="0.996936">
483
</page>
<table confidence="0.999828333333333">
Passes L,/N # Features Time (sec) F-score
OWL-QN 161 -2.448 30,710 2,253 71.76
SGD-L1 (Naive) 30 -2.537 1,032,962 4,528 71.20
SGD-L1 (Clipping + Lazy-Update) 30 -2.538 279,886 585 71.20
SGD-L1 (Cumulative) 30 -2.479 31,986 631 71.40
SGD-L1 (Cumulative + Exponential-Decay) 30 -2.443 25,965 631 71.63
</table>
<tableCaption confidence="0.9732335">
Table 2: NLPBA 2004 Named entity recognition task. Training time and accuracy of the trained model
on the test data.
</tableCaption>
<table confidence="0.999901666666667">
Passes L,/N # Features Time (sec) Accuracy
OWL-QN 124 -1.941 50,870 5,623 97.16%
SGD-L1 (Naive) 30 -2.013 2,142,130 18,471 97.18%
SGD-L1 (Clipping + Lazy-Update) 30 -2.013 323,199 1,680 97.18%
SGD-L1 (Cumulative) 30 -1.987 62,043 1,777 97.19%
SGD-L1 (Cumulative + Exponential-Decay) 30 -1.954 51,857 1,774 97.17%
</table>
<tableCaption confidence="0.993778">
Table 3: POS tagging on the WSJ corpus. Training time and accuracy of the trained model on the test
</tableCaption>
<bodyText confidence="0.989472333333333">
data.
problem as a L1-constrained problem (Lee et al.,
2006), where the conditional log-likelihood of the
training data is maximized under a fixed constraint
of the L1-norm of the weight vector. Duchi et
al. (2008) describe efficient algorithms for pro-
jecting a weight vector onto the L1-ball. Although
L1-regularized and L1-constrained learning algo-
rithms are not directly comparable because the ob-
jective functions are different, it would be inter-
esting to compare the two approaches in terms
of practicality. It should be noted, however, that
the efficient algorithm presented in (Duchi et al.,
2008) needs to employ a red-black tree and is
rather complex.
In SGD learning, the need for tuning the meta-
parameters for learning rate scheduling can be an-
noying. In the case of exponential decay, the set-
ting of α = 0.85 turned out to be a good rule
of thumb in our experiments—it always produced
near best results in 30 passes, but the other param-
eter ,7o needed to be tuned. It would be very useful
if those meta-parameters could be tuned in a fully
automatic way.
There are some sophisticated algorithms for
adaptive learning rate scheduling in SGD learning
(Vishwanathan et al., 2006; Huang et al., 2007).
However, those algorithms use second-order infor-
mation (i.e. Hessian information) and thus need
access to the weights of the features that are not
used in the current sample, which should slow
down the weight updating process for the same
reason discussed earlier. It would be interesting
to investigate whether those sophisticated learning
scheduling algorithms can actually result in fast
training in large-scale NLP tasks.
</bodyText>
<sectionHeader confidence="0.999014" genericHeader="conclusions">
6 Conclusion
</sectionHeader>
<bodyText confidence="0.9999456">
We have presented a new variant of SGD that can
efficiently train L1-regularized log-linear models.
The algorithm is simple and extremely easy to im-
plement.
We have conducted experiments using CRFs
and three NLP tasks, and demonstrated empiri-
cally that our training algorithm can produce com-
pact and accurate models much more quickly than
a state-of-the-art quasi-Newton method for L1-
regularization.
</bodyText>
<sectionHeader confidence="0.996978" genericHeader="acknowledgments">
Acknowledgments
</sectionHeader>
<bodyText confidence="0.999895875">
We thank N. Okazaki, N. Yoshinaga, D.
Okanohara and the anonymous reviewers for their
useful comments and suggestions. The work de-
scribed in this paper has been funded by the
Biotechnology and Biological Sciences Research
Council (BBSRC; BB/E004431/1). The research
team is hosted by the JISC/BBSRC/EPSRC spon-
sored National Centre for Text Mining.
</bodyText>
<sectionHeader confidence="0.99859" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.951152333333333">
Galen Andrew and Jianfeng Gao. 2007. Scalable train-
ing of L1-regularized log-linear models. In Pro-
ceedings ofICML, pages 33–40.
</reference>
<page confidence="0.988857">
484
</page>
<reference confidence="0.999818097087379">
Bob Carpenter. 2008. Lazy sparse stochastic gradient
descent for regularized multinomial logistic regres-
sion. Technical report, Alias-i.
Stephen Clark and James R. Curran. 2004. Parsing the
WSJ using CCG and log-linear models. In Proceed-
ings of COLING 2004, pages 103–110.
Trevor Cohn and Philip Blunsom. 2005. Semantic role
labeling with tree conditional random fields. In Pro-
ceedings of CoNLL, pages 169–172.
Michael Collins, Amir Globerson, Terry Koo, Xavier
Carreras, and Peter L. Bartlett. 2008. Exponen-
tiated gradient algorithms for conditional random
fields and max-margin markov networks. The Jour-
nal ofMachine Learning Research (JMLR), 9:1775–
1822.
Michael Collins. 2002. Discriminative training meth-
ods for hidden markov models: Theory and exper-
iments with perceptron algorithms. In Proceedings
of EMNLP, pages 1–8.
Christian Darken and John Moody. 1990. Note on
learning rate schedules for stochastic optimization.
In Proceedings ofNIPS, pages 832–838.
Juhn Duchi and Yoram Singer. 2008. Online and
batch learning using forward-looking subgradients.
In NIPS Workshop: OPT 2008 Optimization for Ma-
chine Learning.
Juhn Duchi, Shai Shalev-Shwartz, Yoram Singer, and
Tushar Chandra. 2008. Efficient projections onto
the l1-ball for learning in high dimensions. In Pro-
ceedings ofICML, pages 272–279.
Jenny Rose Finkel, Alex Kleeman, and Christopher D.
Manning. 2008. Efficient, feature-based, condi-
tional random field parsing. In Proceedings ofACL-
08:HLT, pages 959–967.
Jianfeng Gao, Galen Andrew, Mark Johnson, and
Kristina Toutanova. 2007. A comparative study of
parameter estimation methods for statistical natural
language processing. In Proceedings ofACL, pages
824–831.
Han-Shen Huang, Yu-Ming Chang, and Chun-Nan
Hsu. 2007. Training conditional random fields by
periodic step size adaptation for large-scale text min-
ing. In Proceedings ofICDM, pages 511–516.
Jun’ichi Kazama and Jun’ichi Tsujii. 2003. Evalua-
tion and extension of maximum entropy models with
inequality constraints. In Proceedings of EMNLP
2003.
J.-D. Kim, T. Ohta, Y. Tsuruoka, Y. Tateisi, and N. Col-
lier. 2004. Introduction to the bio-entity recognition
task at JNLPBA. In Proceedings ofthe International
Joint Workshop on Natural Language Processing in
Biomedicine and its Applications (JNLPBA), pages
70–75.
John Lafferty, Andrew McCallum, and Fernando
Pereira. 2001. Conditional random fields: Prob-
abilistic models for segmenting and labeling se-
quence data. In Proceedings of ICML, pages 282–
289.
John Langford, Lihong Li, and Tong Zhang. 2009.
Sparse online learning via truncated gradient. The
Journal of Machine Learning Research (JMLR),
10:777–801.
Su-In Lee, Honglak Lee, Pieter Abbeel, and Andrew Y.
Ng. 2006. Efficient l1 regularized logistic regres-
sion. In Proceedings ofAAAI-06, pages 401–408.
Mitchell P. Marcus, Beatrice Santorini, and Mary Ann
Marcinkiewicz. 1994. Building a large annotated
corpus of English: The Penn Treebank. Computa-
tional Linguistics, 19(2):313–330.
Jorge Nocedal. 1980. Updating quasi-newton matrices
with limited storage. Mathematics of Computation,
35(151):773–782.
Daisuke Okanohara, Yusuke Miyao, Yoshimasa Tsu-
ruoka, and Jun’ichi Tsujii. 2006. Improving
the scalability of semi-markov conditional random
fields for named entity recognition. In Proceedings
of COLING/ACL, pages 465–472.
Adwait Ratnaparkhi. 1996. A maximum entropy
model for part-of-speech tagging. In Proceedings
of EMNLP 1996, pages 133–142.
Libin Shen, Giorgio Satta, and Aravind Joshi. 2007.
Guided learning for bidirectional sequence classifi-
cation. In Proceedings ofACL, pages 760–767.
David Smith and Jason Eisner. 2008. Dependency
parsing by belief propagation. In Proceedings of
EMNLP, pages 145–156.
James C. Spall. 2005. Introduction to Stochastic
Search and Optimization. Wiley-IEEE.
Christoph Tillmann and Tong Zhang. 2006. A discrim-
inative global training algorithm for statistical MT.
In Proceedings of COLING/ACL, pages 721–728.
Kristina Toutanova, Aria Haghighi, and Christopher
Manning. 2005. Joint learning improves semantic
role labeling. In Proceedings of ACL, pages 589–
596.
S. V. N. Vishwanathan, Nicol N. Schraudolph, Mark W.
Schmidt, and Kevin P. Murphy. 2006. Accelerated
training of conditional random fields with stochastic
gradient methods. In Proceedings of ICML, pages
969–976.
Ben Wellner and Marc Vilain. 2006. Leveraging
machine readable dictionaries in discriminative se-
quence models. In Proceedings ofLREC 2006.
</reference>
<page confidence="0.999069">
485
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.450905">
<title confidence="0.98299">Stochastic Gradient Descent Training for L1-regularized Log-linear Models with Cumulative Penalty</title>
<author confidence="0.990065">Sophia</author>
<affiliation confidence="0.814592">of Computer Science, University of Manchester, UK Centre for Text Mining (NaCTeM), UK of Computer Science, University of Tokyo, Japan</affiliation>
<abstract confidence="0.997596">Stochastic gradient descent (SGD) uses approximate gradients estimated from subsets of the training data and updates the parameters in an online fashion. This learning framework is attractive because it often requires much less training time in practice than batch training algorithms. However, L1-regularization, which is becoming popular in natural language processing because of its ability to produce compact models, cannot be efficiently applied in SGD training, due to the large dimensions of feature vectors and the fluctuations of approximate gradients. We present a simple method to solve these problems by penalizing the weights according to cumulative values for L1 penalty. We evaluate the effectiveness of our method in three applications: text chunking, named entity recognition, and part-of-speech tagging. Experimental results demonstrate that our method can produce compact and accurate models much more quickly than a state-of-the-art quasi- Newton method for L1-regularized loglinear models.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Galen Andrew</author>
<author>Jianfeng Gao</author>
</authors>
<title>Scalable training of L1-regularized log-linear models.</title>
<date>2007</date>
<booktitle>In Proceedings ofICML,</booktitle>
<pages>33--40</pages>
<contexts>
<context position="3633" citStr="Andrew and Gao (2007)" startWordPosition="541" endWordPosition="544">esult of L1-regularized training, the size of the model can be much smaller than that produced by L2-regularization. Compact models require less space on memory and storage, and enable the application to start up quickly. These merits can be of vital importance when the application is deployed in resource-tight environments such as cell-phones. A common way to train a large-scale L1- regularized model is to use a quasi-Newton method. Kazama and Tsujii (2003) describe a method for training a L1-regularized log-linear model with a bound constrained version of the BFGS algorithm (Nocedal, 1980). Andrew and Gao (2007) present an algorithm called OrthantWise Limited-memory Quasi-Newton (OWLQN), which can work on the BFGS algorithm without bound constraints and achieve faster convergence. 477 Proceedings of the 47th Annual Meeting of the ACL and the 4th IJCNLP of the AFNLP, pages 477–485, Suntec, Singapore, 2-7 August 2009. c�2009 ACL and AFNLP An alternative approach to training a log-linear model is to use stochastic gradient descent (SGD) methods. SGD uses approximate gradients estimated from subsets of the training data and updates the weights of the features in an online fashion—the weights are updated </context>
</contexts>
<marker>Andrew, Gao, 2007</marker>
<rawString>Galen Andrew and Jianfeng Gao. 2007. Scalable training of L1-regularized log-linear models. In Proceedings ofICML, pages 33–40.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Bob Carpenter</author>
</authors>
<title>Lazy sparse stochastic gradient descent for regularized multinomial logistic regression.</title>
<date>2008</date>
<tech>Technical report, Alias-i.</tech>
<contexts>
<context position="11186" citStr="Carpenter (2008)" startWordPosition="1860" endWordPosition="1861"> serious problems. The first problem is that, at each update, we need to perform the application of L1 penalty to all features, including the features that are not used in the current training sample. Since the dimension of the feature space can be very large, it can significantly slow down the weight update process. The second problem is that it does not produce a compact model, i.e. most of the weights of the features do not become zero as a result of training. Note that the weight of a feature does not become zero unless it happens to fall on zero exactly, which rarely happens in practice. Carpenter (2008) describes an alternative approach. The weight updating process is divided into two steps. First, the weight is updated without considering the L1 penalty term. Then, the L1 penalty is applied to the weight to the extent that it does not change its sign. In other words, the weight is clipped when it crosses zero. Their weight update procedure is as follows: k+ 1 if wi &gt; 0 then 2 wk+1 i = max(0, wk+1 i − C 2 N ηk), k+ 1 else if wi&lt; 0 then 2 wk+1 i = min(0, wk+ 1 i + C 2 N ηk). In this paper, we call this update method “SGDL1 (Clipping)”. It should be noted that this method XN j=1 Lw = k+1 ∂L(j,</context>
</contexts>
<marker>Carpenter, 2008</marker>
<rawString>Bob Carpenter. 2008. Lazy sparse stochastic gradient descent for regularized multinomial logistic regression. Technical report, Alias-i.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Stephen Clark</author>
<author>James R Curran</author>
</authors>
<title>Parsing the WSJ using CCG and log-linear models.</title>
<date>2004</date>
<booktitle>In Proceedings of COLING</booktitle>
<pages>103--110</pages>
<contexts>
<context position="1850" citStr="Clark and Curran, 2004" startWordPosition="255" endWordPosition="258">ntal results demonstrate that our method can produce compact and accurate models much more quickly than a state-of-the-art quasiNewton method for L1-regularized loglinear models. 1 Introduction Log-linear models (a.k.a maximum entropy models) are one of the most widely-used probabilistic models in the field of natural language processing (NLP). The applications range from simple classification tasks such as text classification and history-based tagging (Ratnaparkhi,1996) to more complex structured prediction tasks such as partof-speech (POS) tagging (Lafferty et al., 2001), syntactic parsing (Clark and Curran, 2004) and semantic role labeling (Toutanova et al., 2005). Loglinear models have a major advantage over other discriminative machine learning models such as support vector machines—their probabilistic output allows the information on the confidence of the decision to be used by other components in the text processing pipeline. The training of log-liner models is typically performed based on the maximum likelihood criterion, which aims to obtain the weights of the features that maximize the conditional likelihood of the training data. In maximum likelihood training, regularization is normally needed</context>
</contexts>
<marker>Clark, Curran, 2004</marker>
<rawString>Stephen Clark and James R. Curran. 2004. Parsing the WSJ using CCG and log-linear models. In Proceedings of COLING 2004, pages 103–110.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Trevor Cohn</author>
<author>Philip Blunsom</author>
</authors>
<title>Semantic role labeling with tree conditional random fields.</title>
<date>2005</date>
<booktitle>In Proceedings of CoNLL,</booktitle>
<pages>169--172</pages>
<contexts>
<context position="7778" citStr="Cohn and Blunsom, 2005" startWordPosition="1237" endWordPosition="1240"> i If the structure is a sequence, the model is called a linear-chain CRF model, and the marginal probabilities of the features and the partition function can be efficiently computed by using the forwardbackward algorithm. The model is used for a variety of sequence labeling tasks such as POS tagging, chunking, and named entity recognition. If the structure is a tree, the model is called a tree CRF model, and the marginal probabilities can be computed by using the inside-outside algorithm. The model can be used for tasks like syntactic parsing (Finkel et al., 2008) and semantic role labeling (Cohn and Blunsom, 2005). 2.1 Training The weights of the features in a log-linear model are optimized in such a way that they maximize the regularized conditional log-likelihood of the training data: N LW = log p(yj|xj; w) − R(w), (1) j=1 where N is the number of training samples, yj is the correct output for input xj, and R(w) is the i 478 3.1 L1 regularization The update equation for the weight of each feature i is as follows: regularization term which prevents the model from overfitting the training data. In the case of L1 regularization, the term is defined as: X |wi|, ∂ wik+1 = wik + ηk ∂wi (L(j, w) − N |wi |).</context>
</contexts>
<marker>Cohn, Blunsom, 2005</marker>
<rawString>Trevor Cohn and Philip Blunsom. 2005. Semantic role labeling with tree conditional random fields. In Proceedings of CoNLL, pages 169–172.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Michael Collins</author>
<author>Amir Globerson</author>
<author>Terry Koo</author>
<author>Xavier Carreras</author>
<author>Peter L Bartlett</author>
</authors>
<title>Exponentiated gradient algorithms for conditional random fields and max-margin markov networks.</title>
<date>2008</date>
<journal>The Journal ofMachine Learning Research (JMLR),</journal>
<volume>9</volume>
<pages>1822</pages>
<contexts>
<context position="16076" citStr="Collins et al., 2008" startWordPosition="2809" endWordPosition="2812"> 8: UPDATEWEIGHTS(j) 10: procedure UPDATEWEIGHTS(j) 11: for i E features used in sample j ∂L(j,w) 12: wi &lt;-- wi + 77 ∂w� 13: APPLYPENALTY(i) 15: procedure APPLYPENALTY(i) 16: z &lt;-- wi 17: if wi &gt; 0 then 18: wi &lt;-- max(0, wi − (u + qi)) 19: else if wi &lt; 0 then 20: wi &lt;-- min(0, wi + (u − qi)) 21: qi &lt;-- qi + (wi − z) Figure 2: Stochastic gradient descent training with cumulative L1 penalty. z is a temporary variable. 3.3 Learning Rate The scheduling of learning rates often has a major impact on the convergence speed in SGD training. A typical choice of learning rate scheduling can be found in (Collins et al., 2008): 77k = 770 (5) 1 + k/N , where 770 is a constant. Although this scheduling guarantees ultimate convergence, the actual speed of convergence can be poor in practice (Darken and Moody, 1990). In this work, we also tested simple exponential decay: 77k = 770α−k/N , (6) where α is a constant. In our experiments, we found this scheduling more practical than that given in Equation 5. This is mainly because exponential decay sweeps the range of learning rates more smoothly—the learning rate given in Equation 5 drops too fast at the beginning and too slowly at the end. It should be noted that exponent</context>
</contexts>
<marker>Collins, Globerson, Koo, Carreras, Bartlett, 2008</marker>
<rawString>Michael Collins, Amir Globerson, Terry Koo, Xavier Carreras, and Peter L. Bartlett. 2008. Exponentiated gradient algorithms for conditional random fields and max-margin markov networks. The Journal ofMachine Learning Research (JMLR), 9:1775– 1822.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Michael Collins</author>
</authors>
<title>Discriminative training methods for hidden markov models: Theory and experiments with perceptron algorithms.</title>
<date>2002</date>
<booktitle>In Proceedings of EMNLP,</booktitle>
<pages>1--8</pages>
<contexts>
<context position="23709" citStr="Collins, 2002" startWordPosition="4069" endWordPosition="4070">of the current word, and the shape of the word (e.g. “IL-2” is converted into “AA-#”), on top of the features used in the text chunking experiments. The results are shown in Figure 5 and Table 2. The trend in the results is the same as that of the text chunking task: our SGD algorithms show much faster convergence than the OWL-QN algorithm and produce compact models. Okanohara et al. (2006) report an f-score of 71.48 on the same data, using semi-Markov CRFs. 4.3 Part-Of-Speech Tagging The third set of experiments used the POS tagging data in the Penn Treebank (Marcus et al., 1994). Following (Collins, 2002), we used sections 0-18 of the Wall Street Journal (WSJ) corpus for training, sections 19-21 for development, and sections 22-24 for final evaluation. The POS tags were extracted from the parse trees in the corpus. All experiments for this work, including the tuning of features and parameters for regularization, were carried out using the training and development sets. The test set was used only for the final accuracy report. It should be noted that training a CRF-based POS tagger using the whole WSJ corpus is not a trivial task and was once even deemed impractical in previous studies. For exa</context>
</contexts>
<marker>Collins, 2002</marker>
<rawString>Michael Collins. 2002. Discriminative training methods for hidden markov models: Theory and experiments with perceptron algorithms. In Proceedings of EMNLP, pages 1–8.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Christian Darken</author>
<author>John Moody</author>
</authors>
<title>Note on learning rate schedules for stochastic optimization.</title>
<date>1990</date>
<booktitle>In Proceedings ofNIPS,</booktitle>
<pages>832--838</pages>
<contexts>
<context position="16265" citStr="Darken and Moody, 1990" startWordPosition="2842" endWordPosition="2845"> if wi &gt; 0 then 18: wi &lt;-- max(0, wi − (u + qi)) 19: else if wi &lt; 0 then 20: wi &lt;-- min(0, wi + (u − qi)) 21: qi &lt;-- qi + (wi − z) Figure 2: Stochastic gradient descent training with cumulative L1 penalty. z is a temporary variable. 3.3 Learning Rate The scheduling of learning rates often has a major impact on the convergence speed in SGD training. A typical choice of learning rate scheduling can be found in (Collins et al., 2008): 77k = 770 (5) 1 + k/N , where 770 is a constant. Although this scheduling guarantees ultimate convergence, the actual speed of convergence can be poor in practice (Darken and Moody, 1990). In this work, we also tested simple exponential decay: 77k = 770α−k/N , (6) where α is a constant. In our experiments, we found this scheduling more practical than that given in Equation 5. This is mainly because exponential decay sweeps the range of learning rates more smoothly—the learning rate given in Equation 5 drops too fast at the beginning and too slowly at the end. It should be noted that exponential decay is not a good choice from a theoretical point of view, because it does not satisfy one of the necessary conditions for convergence—the sum of the learning rates must diverge to in</context>
</contexts>
<marker>Darken, Moody, 1990</marker>
<rawString>Christian Darken and John Moody. 1990. Note on learning rate schedules for stochastic optimization. In Proceedings ofNIPS, pages 832–838.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Juhn Duchi</author>
<author>Yoram Singer</author>
</authors>
<title>Online and batch learning using forward-looking subgradients.</title>
<date>2008</date>
<booktitle>In NIPS Workshop: OPT 2008 Optimization for Machine Learning.</booktitle>
<contexts>
<context position="12567" citStr="Duchi and Singer, 2008" startWordPosition="2133" endWordPosition="2136">to zero straightaway. Here, we present a different strategy for applying the L1 penalty to the weights of the features. The key idea is to smooth out the effect of fluctuating gradients by considering the cumulative effects from L1 penalty. Let uk be the absolute value of the total L1- penalty that each weight could have received up to the point. Since the absolute value of the L1 penalty does not depend on the weight and we are using the same regularization constant C for all weights, it is simply accumulated as: Weight 0.1 0.05 0 -0.05 -0.1 is actually a special case of the FOLOS algorithm (Duchi and Singer, 2008) and the truncated gradient method (Langford et al., 2009). The obvious advantage of using this method is that we can expect many of the weights of the features to become zero during training. Another merit is that it allows us to perform the application of L1 penalty in a lazy fashion, so that we do not need to update the weights of the features that are not used in the current sample, which leads to much faster training when the dimension of the feature space is large. See the aforementioned papers for the details. In this paper, we call this efficient implementation “SGD-L1 (Clipping + Lazy</context>
</contexts>
<marker>Duchi, Singer, 2008</marker>
<rawString>Juhn Duchi and Yoram Singer. 2008. Online and batch learning using forward-looking subgradients. In NIPS Workshop: OPT 2008 Optimization for Machine Learning.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Juhn Duchi</author>
<author>Shai Shalev-Shwartz</author>
<author>Yoram Singer</author>
<author>Tushar Chandra</author>
</authors>
<title>Efficient projections onto the l1-ball for learning in high dimensions.</title>
<date>2008</date>
<booktitle>In Proceedings ofICML,</booktitle>
<pages>272--279</pages>
<contexts>
<context position="26818" citStr="Duchi et al. (2008)" startWordPosition="4565" endWordPosition="4568">,/N # Features Time (sec) Accuracy OWL-QN 124 -1.941 50,870 5,623 97.16% SGD-L1 (Naive) 30 -2.013 2,142,130 18,471 97.18% SGD-L1 (Clipping + Lazy-Update) 30 -2.013 323,199 1,680 97.18% SGD-L1 (Cumulative) 30 -1.987 62,043 1,777 97.19% SGD-L1 (Cumulative + Exponential-Decay) 30 -1.954 51,857 1,774 97.17% Table 3: POS tagging on the WSJ corpus. Training time and accuracy of the trained model on the test data. problem as a L1-constrained problem (Lee et al., 2006), where the conditional log-likelihood of the training data is maximized under a fixed constraint of the L1-norm of the weight vector. Duchi et al. (2008) describe efficient algorithms for projecting a weight vector onto the L1-ball. Although L1-regularized and L1-constrained learning algorithms are not directly comparable because the objective functions are different, it would be interesting to compare the two approaches in terms of practicality. It should be noted, however, that the efficient algorithm presented in (Duchi et al., 2008) needs to employ a red-black tree and is rather complex. In SGD learning, the need for tuning the metaparameters for learning rate scheduling can be annoying. In the case of exponential decay, the setting of α =</context>
</contexts>
<marker>Duchi, Shalev-Shwartz, Singer, Chandra, 2008</marker>
<rawString>Juhn Duchi, Shai Shalev-Shwartz, Yoram Singer, and Tushar Chandra. 2008. Efficient projections onto the l1-ball for learning in high dimensions. In Proceedings ofICML, pages 272–279.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jenny Rose Finkel</author>
<author>Alex Kleeman</author>
<author>Christopher D Manning</author>
</authors>
<title>Efficient, feature-based, conditional random field parsing.</title>
<date>2008</date>
<booktitle>In Proceedings ofACL08:HLT,</booktitle>
<pages>959--967</pages>
<contexts>
<context position="4646" citStr="Finkel et al., 2008" startWordPosition="702" endWordPosition="705">use stochastic gradient descent (SGD) methods. SGD uses approximate gradients estimated from subsets of the training data and updates the weights of the features in an online fashion—the weights are updated much more frequently than batch training algorithms. This learning framework is attracting attention because it often requires much less training time in practice than batch training algorithms, especially when the training data is large and redundant. SGD was recently used for NLP tasks including machine translation (Tillmann and Zhang, 2006) and syntactic parsing (Smith and Eisner, 2008; Finkel et al., 2008). Also, SGD is very easy to implement because it does not need to use the Hessian information on the objective function. The implementation could be as simple as the perceptron algorithm. Although SGD is a very attractive learning framework, the direct application of L1 regularization in this learning framework does not result in efficient training. The first problem is the inefficiency of applying the L1 penalty to the weights of all features. In NLP applications, the dimension of the feature space tends to be very large—it can easily become several millions, so the application of L1 penalty </context>
<context position="7726" citStr="Finkel et al., 2008" startWordPosition="1229" endWordPosition="1232">normalization) function: Z(x) = exp wifi(y, x). Y i If the structure is a sequence, the model is called a linear-chain CRF model, and the marginal probabilities of the features and the partition function can be efficiently computed by using the forwardbackward algorithm. The model is used for a variety of sequence labeling tasks such as POS tagging, chunking, and named entity recognition. If the structure is a tree, the model is called a tree CRF model, and the marginal probabilities can be computed by using the inside-outside algorithm. The model can be used for tasks like syntactic parsing (Finkel et al., 2008) and semantic role labeling (Cohn and Blunsom, 2005). 2.1 Training The weights of the features in a log-linear model are optimized in such a way that they maximize the regularized conditional log-likelihood of the training data: N LW = log p(yj|xj; w) − R(w), (1) j=1 where N is the number of training samples, yj is the correct output for input xj, and R(w) is the i 478 3.1 L1 regularization The update equation for the weight of each feature i is as follows: regularization term which prevents the model from overfitting the training data. In the case of L1 regularization, the term is defined as:</context>
</contexts>
<marker>Finkel, Kleeman, Manning, 2008</marker>
<rawString>Jenny Rose Finkel, Alex Kleeman, and Christopher D. Manning. 2008. Efficient, feature-based, conditional random field parsing. In Proceedings ofACL08:HLT, pages 959–967.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jianfeng Gao</author>
<author>Galen Andrew</author>
<author>Mark Johnson</author>
<author>Kristina Toutanova</author>
</authors>
<title>A comparative study of parameter estimation methods for statistical natural language processing.</title>
<date>2007</date>
<booktitle>In Proceedings ofACL,</booktitle>
<pages>824--831</pages>
<contexts>
<context position="2885" citStr="Gao et al., 2007" startWordPosition="419" endWordPosition="422">ion, which aims to obtain the weights of the features that maximize the conditional likelihood of the training data. In maximum likelihood training, regularization is normally needed to prevent the model from overfitting the training data, The two most common regularization methods are called L1 and L2 regularization. L1 regularization penalizes the weight vector for its L1-norm (i.e. the sum of the absolute values of the weights), whereas L2 regularization uses its L2-norm. There is usually not a considerable difference between the two methods in terms of the accuracy of the resulting model (Gao et al., 2007), but L1 regularization has a significant advantage in practice. Because many of the weights of the features become zero as a result of L1-regularized training, the size of the model can be much smaller than that produced by L2-regularization. Compact models require less space on memory and storage, and enable the application to start up quickly. These merits can be of vital importance when the application is deployed in resource-tight environments such as cell-phones. A common way to train a large-scale L1- regularized model is to use a quasi-Newton method. Kazama and Tsujii (2003) describe a</context>
</contexts>
<marker>Gao, Andrew, Johnson, Toutanova, 2007</marker>
<rawString>Jianfeng Gao, Galen Andrew, Mark Johnson, and Kristina Toutanova. 2007. A comparative study of parameter estimation methods for statistical natural language processing. In Proceedings ofACL, pages 824–831.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Han-Shen Huang</author>
<author>Yu-Ming Chang</author>
<author>Chun-Nan Hsu</author>
</authors>
<title>Training conditional random fields by periodic step size adaptation for large-scale text mining.</title>
<date>2007</date>
<booktitle>In Proceedings ofICDM,</booktitle>
<pages>511--516</pages>
<contexts>
<context position="27811" citStr="Huang et al., 2007" startWordPosition="4732" endWordPosition="4735">i et al., 2008) needs to employ a red-black tree and is rather complex. In SGD learning, the need for tuning the metaparameters for learning rate scheduling can be annoying. In the case of exponential decay, the setting of α = 0.85 turned out to be a good rule of thumb in our experiments—it always produced near best results in 30 passes, but the other parameter ,7o needed to be tuned. It would be very useful if those meta-parameters could be tuned in a fully automatic way. There are some sophisticated algorithms for adaptive learning rate scheduling in SGD learning (Vishwanathan et al., 2006; Huang et al., 2007). However, those algorithms use second-order information (i.e. Hessian information) and thus need access to the weights of the features that are not used in the current sample, which should slow down the weight updating process for the same reason discussed earlier. It would be interesting to investigate whether those sophisticated learning scheduling algorithms can actually result in fast training in large-scale NLP tasks. 6 Conclusion We have presented a new variant of SGD that can efficiently train L1-regularized log-linear models. The algorithm is simple and extremely easy to implement. We</context>
</contexts>
<marker>Huang, Chang, Hsu, 2007</marker>
<rawString>Han-Shen Huang, Yu-Ming Chang, and Chun-Nan Hsu. 2007. Training conditional random fields by periodic step size adaptation for large-scale text mining. In Proceedings ofICDM, pages 511–516.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jun’ichi Kazama</author>
<author>Jun’ichi Tsujii</author>
</authors>
<title>Evaluation and extension of maximum entropy models with inequality constraints.</title>
<date>2003</date>
<booktitle>In Proceedings of EMNLP</booktitle>
<contexts>
<context position="3474" citStr="Kazama and Tsujii (2003)" startWordPosition="517" endWordPosition="520"> resulting model (Gao et al., 2007), but L1 regularization has a significant advantage in practice. Because many of the weights of the features become zero as a result of L1-regularized training, the size of the model can be much smaller than that produced by L2-regularization. Compact models require less space on memory and storage, and enable the application to start up quickly. These merits can be of vital importance when the application is deployed in resource-tight environments such as cell-phones. A common way to train a large-scale L1- regularized model is to use a quasi-Newton method. Kazama and Tsujii (2003) describe a method for training a L1-regularized log-linear model with a bound constrained version of the BFGS algorithm (Nocedal, 1980). Andrew and Gao (2007) present an algorithm called OrthantWise Limited-memory Quasi-Newton (OWLQN), which can work on the BFGS algorithm without bound constraints and achieve faster convergence. 477 Proceedings of the 47th Annual Meeting of the ACL and the 4th IJCNLP of the AFNLP, pages 477–485, Suntec, Singapore, 2-7 August 2009. c�2009 ACL and AFNLP An alternative approach to training a log-linear model is to use stochastic gradient descent (SGD) methods. S</context>
</contexts>
<marker>Kazama, Tsujii, 2003</marker>
<rawString>Jun’ichi Kazama and Jun’ichi Tsujii. 2003. Evaluation and extension of maximum entropy models with inequality constraints. In Proceedings of EMNLP 2003.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J-D Kim</author>
<author>T Ohta</author>
<author>Y Tsuruoka</author>
<author>Y Tateisi</author>
<author>N Collier</author>
</authors>
<title>Introduction to the bio-entity recognition task at JNLPBA.</title>
<date>2004</date>
<booktitle>In Proceedings ofthe International Joint Workshop on Natural Language Processing in Biomedicine and its Applications (JNLPBA),</booktitle>
<pages>70--75</pages>
<contexts>
<context position="22620" citStr="Kim et al., 2004" startWordPosition="3878" endWordPosition="3881">nction -1.6 -1.8 -2.2 -2.4 -2 OWL-QN SGD-L1 (Clipping) SGD-L1 (Cumulative) SGD-L1 (Cumulative + ED) Figure 3: CoNLL 2000 chunking task: Objective # Active features 200000 150000 100000 50000 0 OWL-QN SGD-L1 (Clipping) SGD-L1 (Cumulative) SGD-L1 (Cumulative + ED) 482 tant due to the differences in implementation and hardware platforms, these results demonstrate that our algorithm can actually result in a very fast implementation of a CRF trainer. 4.2 Named Entity Recognition The second set of experiments used the named entity recognition data set provided for the BioNLP/NLPBA 2004 shared task (Kim et al., 2004).9 The training data consist of 18,546 sentences in which each token is annotated with the “IOB” tags representing biomedical named entities such as the names of proteins and RNAs. The training and test data were preprocessed by the GENIA tagger,10 which provided POS tags and chunk tags. We did not use any information on the named entity tags output by the GENIA tagger. For the features, we used unigrams of neighboring chunk tags, substrings (shorter than 10 characters) of the current word, and the shape of the word (e.g. “IL-2” is converted into “AA-#”), on top of the features used in the tex</context>
</contexts>
<marker>Kim, Ohta, Tsuruoka, Tateisi, Collier, 2004</marker>
<rawString>J.-D. Kim, T. Ohta, Y. Tsuruoka, Y. Tateisi, and N. Collier. 2004. Introduction to the bio-entity recognition task at JNLPBA. In Proceedings ofthe International Joint Workshop on Natural Language Processing in Biomedicine and its Applications (JNLPBA), pages 70–75.</rawString>
</citation>
<citation valid="true">
<authors>
<author>John Lafferty</author>
<author>Andrew McCallum</author>
<author>Fernando Pereira</author>
</authors>
<title>Conditional random fields: Probabilistic models for segmenting and labeling sequence data.</title>
<date>2001</date>
<booktitle>In Proceedings of ICML,</booktitle>
<pages>282--289</pages>
<contexts>
<context position="1806" citStr="Lafferty et al., 2001" startWordPosition="249" endWordPosition="252">ition, and part-of-speech tagging. Experimental results demonstrate that our method can produce compact and accurate models much more quickly than a state-of-the-art quasiNewton method for L1-regularized loglinear models. 1 Introduction Log-linear models (a.k.a maximum entropy models) are one of the most widely-used probabilistic models in the field of natural language processing (NLP). The applications range from simple classification tasks such as text classification and history-based tagging (Ratnaparkhi,1996) to more complex structured prediction tasks such as partof-speech (POS) tagging (Lafferty et al., 2001), syntactic parsing (Clark and Curran, 2004) and semantic role labeling (Toutanova et al., 2005). Loglinear models have a major advantage over other discriminative machine learning models such as support vector machines—their probabilistic output allows the information on the confidence of the decision to be used by other components in the text processing pipeline. The training of log-liner models is typically performed based on the maximum likelihood criterion, which aims to obtain the weights of the features that maximize the conditional likelihood of the training data. In maximum likelihood</context>
</contexts>
<marker>Lafferty, McCallum, Pereira, 2001</marker>
<rawString>John Lafferty, Andrew McCallum, and Fernando Pereira. 2001. Conditional random fields: Probabilistic models for segmenting and labeling sequence data. In Proceedings of ICML, pages 282– 289.</rawString>
</citation>
<citation valid="true">
<authors>
<author>John Langford</author>
<author>Lihong Li</author>
<author>Tong Zhang</author>
</authors>
<title>Sparse online learning via truncated gradient.</title>
<date>2009</date>
<journal>The Journal of Machine Learning Research (JMLR),</journal>
<pages>10--777</pages>
<contexts>
<context position="12625" citStr="Langford et al., 2009" startWordPosition="2143" endWordPosition="2146"> for applying the L1 penalty to the weights of the features. The key idea is to smooth out the effect of fluctuating gradients by considering the cumulative effects from L1 penalty. Let uk be the absolute value of the total L1- penalty that each weight could have received up to the point. Since the absolute value of the L1 penalty does not depend on the weight and we are using the same regularization constant C for all weights, it is simply accumulated as: Weight 0.1 0.05 0 -0.05 -0.1 is actually a special case of the FOLOS algorithm (Duchi and Singer, 2008) and the truncated gradient method (Langford et al., 2009). The obvious advantage of using this method is that we can expect many of the weights of the features to become zero during training. Another merit is that it allows us to perform the application of L1 penalty in a lazy fashion, so that we do not need to update the weights of the features that are not used in the current sample, which leads to much faster training when the dimension of the feature space is large. See the aforementioned papers for the details. In this paper, we call this efficient implementation “SGD-L1 (Clipping + LazyUpdate)”. 3.2 L1 regularization with cumulative penalty Un</context>
</contexts>
<marker>Langford, Li, Zhang, 2009</marker>
<rawString>John Langford, Lihong Li, and Tong Zhang. 2009. Sparse online learning via truncated gradient. The Journal of Machine Learning Research (JMLR), 10:777–801.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Su-In Lee</author>
<author>Honglak Lee</author>
<author>Pieter Abbeel</author>
<author>Andrew Y Ng</author>
</authors>
<title>Efficient l1 regularized logistic regression.</title>
<date>2006</date>
<booktitle>In Proceedings ofAAAI-06,</booktitle>
<pages>401--408</pages>
<contexts>
<context position="26664" citStr="Lee et al., 2006" startWordPosition="4540" endWordPosition="4543">30 -2.443 25,965 631 71.63 Table 2: NLPBA 2004 Named entity recognition task. Training time and accuracy of the trained model on the test data. Passes L,/N # Features Time (sec) Accuracy OWL-QN 124 -1.941 50,870 5,623 97.16% SGD-L1 (Naive) 30 -2.013 2,142,130 18,471 97.18% SGD-L1 (Clipping + Lazy-Update) 30 -2.013 323,199 1,680 97.18% SGD-L1 (Cumulative) 30 -1.987 62,043 1,777 97.19% SGD-L1 (Cumulative + Exponential-Decay) 30 -1.954 51,857 1,774 97.17% Table 3: POS tagging on the WSJ corpus. Training time and accuracy of the trained model on the test data. problem as a L1-constrained problem (Lee et al., 2006), where the conditional log-likelihood of the training data is maximized under a fixed constraint of the L1-norm of the weight vector. Duchi et al. (2008) describe efficient algorithms for projecting a weight vector onto the L1-ball. Although L1-regularized and L1-constrained learning algorithms are not directly comparable because the objective functions are different, it would be interesting to compare the two approaches in terms of practicality. It should be noted, however, that the efficient algorithm presented in (Duchi et al., 2008) needs to employ a red-black tree and is rather complex. </context>
</contexts>
<marker>Lee, Lee, Abbeel, Ng, 2006</marker>
<rawString>Su-In Lee, Honglak Lee, Pieter Abbeel, and Andrew Y. Ng. 2006. Efficient l1 regularized logistic regression. In Proceedings ofAAAI-06, pages 401–408.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Mitchell P Marcus</author>
<author>Beatrice Santorini</author>
<author>Mary Ann Marcinkiewicz</author>
</authors>
<title>Building a large annotated corpus of English: The Penn Treebank. Computational Linguistics,</title>
<date>1994</date>
<contexts>
<context position="23682" citStr="Marcus et al., 1994" startWordPosition="4064" endWordPosition="4067">ngs (shorter than 10 characters) of the current word, and the shape of the word (e.g. “IL-2” is converted into “AA-#”), on top of the features used in the text chunking experiments. The results are shown in Figure 5 and Table 2. The trend in the results is the same as that of the text chunking task: our SGD algorithms show much faster convergence than the OWL-QN algorithm and produce compact models. Okanohara et al. (2006) report an f-score of 71.48 on the same data, using semi-Markov CRFs. 4.3 Part-Of-Speech Tagging The third set of experiments used the POS tagging data in the Penn Treebank (Marcus et al., 1994). Following (Collins, 2002), we used sections 0-18 of the Wall Street Journal (WSJ) corpus for training, sections 19-21 for development, and sections 22-24 for final evaluation. The POS tags were extracted from the parse trees in the corpus. All experiments for this work, including the tuning of features and parameters for regularization, were carried out using the training and development sets. The test set was used only for the final accuracy report. It should be noted that training a CRF-based POS tagger using the whole WSJ corpus is not a trivial task and was once even deemed impractical i</context>
</contexts>
<marker>Marcus, Santorini, Marcinkiewicz, 1994</marker>
<rawString>Mitchell P. Marcus, Beatrice Santorini, and Mary Ann Marcinkiewicz. 1994. Building a large annotated corpus of English: The Penn Treebank. Computational Linguistics, 19(2):313–330.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jorge Nocedal</author>
</authors>
<title>Updating quasi-newton matrices with limited storage.</title>
<date>1980</date>
<journal>Mathematics of Computation,</journal>
<volume>35</volume>
<issue>151</issue>
<contexts>
<context position="3610" citStr="Nocedal, 1980" startWordPosition="539" endWordPosition="540">come zero as a result of L1-regularized training, the size of the model can be much smaller than that produced by L2-regularization. Compact models require less space on memory and storage, and enable the application to start up quickly. These merits can be of vital importance when the application is deployed in resource-tight environments such as cell-phones. A common way to train a large-scale L1- regularized model is to use a quasi-Newton method. Kazama and Tsujii (2003) describe a method for training a L1-regularized log-linear model with a bound constrained version of the BFGS algorithm (Nocedal, 1980). Andrew and Gao (2007) present an algorithm called OrthantWise Limited-memory Quasi-Newton (OWLQN), which can work on the BFGS algorithm without bound constraints and achieve faster convergence. 477 Proceedings of the 47th Annual Meeting of the ACL and the 4th IJCNLP of the AFNLP, pages 477–485, Suntec, Singapore, 2-7 August 2009. c�2009 ACL and AFNLP An alternative approach to training a log-linear model is to use stochastic gradient descent (SGD) methods. SGD uses approximate gradients estimated from subsets of the training data and updates the weights of the features in an online fashion—t</context>
</contexts>
<marker>Nocedal, 1980</marker>
<rawString>Jorge Nocedal. 1980. Updating quasi-newton matrices with limited storage. Mathematics of Computation, 35(151):773–782.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Daisuke Okanohara</author>
<author>Yusuke Miyao</author>
<author>Yoshimasa Tsuruoka</author>
<author>Jun’ichi Tsujii</author>
</authors>
<title>Improving the scalability of semi-markov conditional random fields for named entity recognition.</title>
<date>2006</date>
<booktitle>In Proceedings of COLING/ACL,</booktitle>
<pages>465--472</pages>
<contexts>
<context position="23488" citStr="Okanohara et al. (2006)" startWordPosition="4030" endWordPosition="4033">,10 which provided POS tags and chunk tags. We did not use any information on the named entity tags output by the GENIA tagger. For the features, we used unigrams of neighboring chunk tags, substrings (shorter than 10 characters) of the current word, and the shape of the word (e.g. “IL-2” is converted into “AA-#”), on top of the features used in the text chunking experiments. The results are shown in Figure 5 and Table 2. The trend in the results is the same as that of the text chunking task: our SGD algorithms show much faster convergence than the OWL-QN algorithm and produce compact models. Okanohara et al. (2006) report an f-score of 71.48 on the same data, using semi-Markov CRFs. 4.3 Part-Of-Speech Tagging The third set of experiments used the POS tagging data in the Penn Treebank (Marcus et al., 1994). Following (Collins, 2002), we used sections 0-18 of the Wall Street Journal (WSJ) corpus for training, sections 19-21 for development, and sections 22-24 for final evaluation. The POS tags were extracted from the parse trees in the corpus. All experiments for this work, including the tuning of features and parameters for regularization, were carried out using the training and development sets. The tes</context>
</contexts>
<marker>Okanohara, Miyao, Tsuruoka, Tsujii, 2006</marker>
<rawString>Daisuke Okanohara, Yusuke Miyao, Yoshimasa Tsuruoka, and Jun’ichi Tsujii. 2006. Improving the scalability of semi-markov conditional random fields for named entity recognition. In Proceedings of COLING/ACL, pages 465–472.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Adwait Ratnaparkhi</author>
</authors>
<title>A maximum entropy model for part-of-speech tagging.</title>
<date>1996</date>
<booktitle>In Proceedings of EMNLP</booktitle>
<pages>133--142</pages>
<marker>Ratnaparkhi, 1996</marker>
<rawString>Adwait Ratnaparkhi. 1996. A maximum entropy model for part-of-speech tagging. In Proceedings of EMNLP 1996, pages 133–142.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Libin Shen</author>
<author>Giorgio Satta</author>
<author>Aravind Joshi</author>
</authors>
<title>Guided learning for bidirectional sequence classification.</title>
<date>2007</date>
<booktitle>In Proceedings ofACL,</booktitle>
<pages>760--767</pages>
<contexts>
<context position="25282" citStr="Shen et al., (2007)" startWordPosition="4325" endWordPosition="4328">sk: Objective. ing because it was “prohibitive” (7-8 days for sections 0-18 of the WSJ corpus). For the features, we used unigrams and bigrams of neighboring words, prefixes and suffixes of the current word, and some characteristics of the word. We also normalized the current word by lowering capital letters and converting all the numerals into ‘#’, and used the normalized word as a feature. The results are shown in Figure 6 and Table 3. Again, the trend is the same. Our algorithms finished training in about 30 minutes, producing accurate models that are as compact as that produced by OWL-QN. Shen et al., (2007) report an accuracy of 97.33% on the same data set using a perceptron-based bidirectional tagging model. 5 Discussion An alternative approach to producing compact models for log-linear models is to reformulate the -2.2 -2.4 -2.6 -2.8 -3.2 -3.4 -3.6 -3.8 -3 OWL-QN SGD-L1 (Clipping) SGD-L1 (Cumulative) SGD-L1 (Cumulative + ED) Objective function -1.8 -1.9 -2.1 -2.2 -2.3 -2.4 -2.5 -2.6 -2.7 -2.8 -2 OWL-QN SGD-L1 (Clipping) SGD-L1 (Cumulative) SGD-L1 (Cumulative + ED) Objective function 483 Passes L,/N # Features Time (sec) F-score OWL-QN 161 -2.448 30,710 2,253 71.76 SGD-L1 (Naive) 30 -2.537 1,03</context>
</contexts>
<marker>Shen, Satta, Joshi, 2007</marker>
<rawString>Libin Shen, Giorgio Satta, and Aravind Joshi. 2007. Guided learning for bidirectional sequence classification. In Proceedings ofACL, pages 760–767.</rawString>
</citation>
<citation valid="true">
<authors>
<author>David Smith</author>
<author>Jason Eisner</author>
</authors>
<title>Dependency parsing by belief propagation.</title>
<date>2008</date>
<booktitle>In Proceedings of EMNLP,</booktitle>
<pages>145--156</pages>
<contexts>
<context position="4624" citStr="Smith and Eisner, 2008" startWordPosition="698" endWordPosition="701"> log-linear model is to use stochastic gradient descent (SGD) methods. SGD uses approximate gradients estimated from subsets of the training data and updates the weights of the features in an online fashion—the weights are updated much more frequently than batch training algorithms. This learning framework is attracting attention because it often requires much less training time in practice than batch training algorithms, especially when the training data is large and redundant. SGD was recently used for NLP tasks including machine translation (Tillmann and Zhang, 2006) and syntactic parsing (Smith and Eisner, 2008; Finkel et al., 2008). Also, SGD is very easy to implement because it does not need to use the Hessian information on the objective function. The implementation could be as simple as the perceptron algorithm. Although SGD is a very attractive learning framework, the direct application of L1 regularization in this learning framework does not result in efficient training. The first problem is the inefficiency of applying the L1 penalty to the weights of all features. In NLP applications, the dimension of the feature space tends to be very large—it can easily become several millions, so the appl</context>
</contexts>
<marker>Smith, Eisner, 2008</marker>
<rawString>David Smith and Jason Eisner. 2008. Dependency parsing by belief propagation. In Proceedings of EMNLP, pages 145–156.</rawString>
</citation>
<citation valid="true">
<authors>
<author>James C Spall</author>
</authors>
<title>Introduction to Stochastic Search and Optimization.</title>
<date>2005</date>
<publisher>Wiley-IEEE.</publisher>
<contexts>
<context position="16885" citStr="Spall, 2005" startWordPosition="2955" endWordPosition="2956">s work, we also tested simple exponential decay: 77k = 770α−k/N , (6) where α is a constant. In our experiments, we found this scheduling more practical than that given in Equation 5. This is mainly because exponential decay sweeps the range of learning rates more smoothly—the learning rate given in Equation 5 drops too fast at the beginning and too slowly at the end. It should be noted that exponential decay is not a good choice from a theoretical point of view, because it does not satisfy one of the necessary conditions for convergence—the sum of the learning rates must diverge to infinity (Spall, 2005). However, this is probably not a big issue for practitioners because normally the training has to be terminated at a certain number of iterations in practice.3 4 Experiments We evaluate the effectiveness our training algorithm using linear-chain CRF models and three NLP tasks: text chunking, named entity recognition, and POS tagging. To compare our algorithm with the state-of-theart, we present the performance of the OWL-QN algorithm on the same data. We used the publicly available OWL-QN optimizer developed by Andrew and Gao.4 The meta-parameters for learning were left unchanged from the def</context>
</contexts>
<marker>Spall, 2005</marker>
<rawString>James C. Spall. 2005. Introduction to Stochastic Search and Optimization. Wiley-IEEE.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Christoph Tillmann</author>
<author>Tong Zhang</author>
</authors>
<title>A discriminative global training algorithm for statistical MT.</title>
<date>2006</date>
<booktitle>In Proceedings of COLING/ACL,</booktitle>
<pages>721--728</pages>
<contexts>
<context position="4578" citStr="Tillmann and Zhang, 2006" startWordPosition="690" endWordPosition="693">L and AFNLP An alternative approach to training a log-linear model is to use stochastic gradient descent (SGD) methods. SGD uses approximate gradients estimated from subsets of the training data and updates the weights of the features in an online fashion—the weights are updated much more frequently than batch training algorithms. This learning framework is attracting attention because it often requires much less training time in practice than batch training algorithms, especially when the training data is large and redundant. SGD was recently used for NLP tasks including machine translation (Tillmann and Zhang, 2006) and syntactic parsing (Smith and Eisner, 2008; Finkel et al., 2008). Also, SGD is very easy to implement because it does not need to use the Hessian information on the objective function. The implementation could be as simple as the perceptron algorithm. Although SGD is a very attractive learning framework, the direct application of L1 regularization in this learning framework does not result in efficient training. The first problem is the inefficiency of applying the L1 penalty to the weights of all features. In NLP applications, the dimension of the feature space tends to be very large—it c</context>
</contexts>
<marker>Tillmann, Zhang, 2006</marker>
<rawString>Christoph Tillmann and Tong Zhang. 2006. A discriminative global training algorithm for statistical MT. In Proceedings of COLING/ACL, pages 721–728.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kristina Toutanova</author>
<author>Aria Haghighi</author>
<author>Christopher Manning</author>
</authors>
<title>Joint learning improves semantic role labeling.</title>
<date>2005</date>
<booktitle>In Proceedings of ACL,</booktitle>
<pages>589--596</pages>
<contexts>
<context position="1902" citStr="Toutanova et al., 2005" startWordPosition="264" endWordPosition="267"> compact and accurate models much more quickly than a state-of-the-art quasiNewton method for L1-regularized loglinear models. 1 Introduction Log-linear models (a.k.a maximum entropy models) are one of the most widely-used probabilistic models in the field of natural language processing (NLP). The applications range from simple classification tasks such as text classification and history-based tagging (Ratnaparkhi,1996) to more complex structured prediction tasks such as partof-speech (POS) tagging (Lafferty et al., 2001), syntactic parsing (Clark and Curran, 2004) and semantic role labeling (Toutanova et al., 2005). Loglinear models have a major advantage over other discriminative machine learning models such as support vector machines—their probabilistic output allows the information on the confidence of the decision to be used by other components in the text processing pipeline. The training of log-liner models is typically performed based on the maximum likelihood criterion, which aims to obtain the weights of the features that maximize the conditional likelihood of the training data. In maximum likelihood training, regularization is normally needed to prevent the model from overfitting the training </context>
</contexts>
<marker>Toutanova, Haghighi, Manning, 2005</marker>
<rawString>Kristina Toutanova, Aria Haghighi, and Christopher Manning. 2005. Joint learning improves semantic role labeling. In Proceedings of ACL, pages 589– 596.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S V N Vishwanathan</author>
<author>Nicol N Schraudolph</author>
<author>Mark W Schmidt</author>
<author>Kevin P Murphy</author>
</authors>
<title>Accelerated training of conditional random fields with stochastic gradient methods.</title>
<date>2006</date>
<booktitle>In Proceedings of ICML,</booktitle>
<pages>969--976</pages>
<contexts>
<context position="27790" citStr="Vishwanathan et al., 2006" startWordPosition="4728" endWordPosition="4731">lgorithm presented in (Duchi et al., 2008) needs to employ a red-black tree and is rather complex. In SGD learning, the need for tuning the metaparameters for learning rate scheduling can be annoying. In the case of exponential decay, the setting of α = 0.85 turned out to be a good rule of thumb in our experiments—it always produced near best results in 30 passes, but the other parameter ,7o needed to be tuned. It would be very useful if those meta-parameters could be tuned in a fully automatic way. There are some sophisticated algorithms for adaptive learning rate scheduling in SGD learning (Vishwanathan et al., 2006; Huang et al., 2007). However, those algorithms use second-order information (i.e. Hessian information) and thus need access to the weights of the features that are not used in the current sample, which should slow down the weight updating process for the same reason discussed earlier. It would be interesting to investigate whether those sophisticated learning scheduling algorithms can actually result in fast training in large-scale NLP tasks. 6 Conclusion We have presented a new variant of SGD that can efficiently train L1-regularized log-linear models. The algorithm is simple and extremely </context>
</contexts>
<marker>Vishwanathan, Schraudolph, Schmidt, Murphy, 2006</marker>
<rawString>S. V. N. Vishwanathan, Nicol N. Schraudolph, Mark W. Schmidt, and Kevin P. Murphy. 2006. Accelerated training of conditional random fields with stochastic gradient methods. In Proceedings of ICML, pages 969–976.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ben Wellner</author>
<author>Marc Vilain</author>
</authors>
<title>Leveraging machine readable dictionaries in discriminative sequence models.</title>
<date>2006</date>
<booktitle>In Proceedings ofLREC</booktitle>
<contexts>
<context position="24340" citStr="Wellner and Vilain (2006)" startWordPosition="4174" endWordPosition="4178">sed sections 0-18 of the Wall Street Journal (WSJ) corpus for training, sections 19-21 for development, and sections 22-24 for final evaluation. The POS tags were extracted from the parse trees in the corpus. All experiments for this work, including the tuning of features and parameters for regularization, were carried out using the training and development sets. The test set was used only for the final accuracy report. It should be noted that training a CRF-based POS tagger using the whole WSJ corpus is not a trivial task and was once even deemed impractical in previous studies. For example, Wellner and Vilain (2006) abandoned maximum likelihood train9The data is available for download at http://wwwtsujii.is.s.u-tokyo.ac.jp/GENIA/ERtask/report.html 10http://www-tsujii.is.s.u-tokyo.ac.jp/GENIA/tagger/ 0 10 20 30 40 50 Passes Figure 5: NLPBA 2004 named entity recognition task: Objective. 0 10 20 30 40 50 Passes Figure 6: POS tagging task: Objective. ing because it was “prohibitive” (7-8 days for sections 0-18 of the WSJ corpus). For the features, we used unigrams and bigrams of neighboring words, prefixes and suffixes of the current word, and some characteristics of the word. We also normalized the current </context>
</contexts>
<marker>Wellner, Vilain, 2006</marker>
<rawString>Ben Wellner and Marc Vilain. 2006. Leveraging machine readable dictionaries in discriminative sequence models. In Proceedings ofLREC 2006.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>