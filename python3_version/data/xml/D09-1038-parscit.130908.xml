<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<title confidence="0.902891">
Better Synchronous Binarization for Machine Translation
</title>
<author confidence="0.946434">
Tong Xiao*, Mu Li+, Dongdong Zhang+, Jingbo Zhu*, Ming Zhou+
</author>
<affiliation confidence="0.921998">
*Natural Language Processing Lab
Northeastern University
</affiliation>
<address confidence="0.783003">
Shenyang, China, 110004
</address>
<email confidence="0.867899">
xiaotong@mail.neu.edu.cn
zhujingbo@mail.neu.edu.cn
</email>
<affiliation confidence="0.6038275">
+Microsoft Research Asia
Sigma Center
</affiliation>
<address confidence="0.721776">
Beijing, China, 100080
</address>
<email confidence="0.869614666666667">
muli@microsoft.com
dozhang@microsoft.com
mingzhou@microsoft.com
</email>
<sectionHeader confidence="0.980408" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.996116529411765">
Binarization of Synchronous Context Free
Grammars (SCFG) is essential for achieving
polynomial time complexity of decoding for
SCFG parsing based machine translation sys-
tems. In this paper, we first investigate the
excess edge competition issue caused by a left-
heavy binary SCFG derived with the method
of Zhang et al. (2006). Then we propose a new
binarization method to mitigate the problem
by exploring other alternative equivalent bi-
nary SCFGs. We present an algorithm that ite-
ratively improves the resulting binary SCFG,
and empirically show that our method can im-
prove a string-to-tree statistical machine trans-
lations system based on the synchronous bina-
rization method in Zhang et al. (2006) on the
NIST machine translation evaluation tasks.
</bodyText>
<sectionHeader confidence="0.986188" genericHeader="keywords">
1 Introduction
</sectionHeader>
<bodyText confidence="0.997500636363636">
Recently Statistical Machine Translation (SMT)
systems based on Synchronous Context Free
Grammar (SCFG) have been extensively investi-
gated (Chiang, 2005; Galley et al., 2004; Galley
et al., 2006) and have achieved state-of-the-art
performance. In these systems, machine transla-
tion decoding is cast as a synchronous parsing
task. Because general SCFG parsing is an NP-
hard problem (Satta and Peserico, 2005), practic-
al SMT decoders based on SCFG parsing re-
quires an equivalent binary SCFG that is directly
learned from training data to achieve polynomial
time complexity using the CKY algorithm (Ka-
sami, 1965; Younger, 1967) borrowed from CFG
parsing techniques. Zhang et al. (2006) proposed
synchronous binarization, a principled method to
binarize an SCFG in such a way that both the
source-side and target-side virtual non-terminals
have contiguous spans. This property of syn-
chronous binarization guarantees the polynomial
time complexity of SCFG parsers even when an
n-gram language model is integrated, which has
been proved to be one of the keys to the success
of a string-to-tree syntax-based SMT system.
However, as shown by Chiang (2007), SCFG-
based decoding with an integrated n-gram lan-
guage model still has a time complexity of
e(m3 ITI4(nâˆ’1)), where m is the source sentence
length, and ITI is the vocabulary size of the lan-
guage model. Although it is not exponential in
theory, the actual complexity can still be very
high in practice. Here is an example extracted
from real data. Given the following SCFG rule:
</bodyText>
<note confidence="0.520663">
VP â€” VB NP ä¼š JJR ,
VB NP will be JJR
</note>
<bodyText confidence="0.821232333333333">
we can obtain a set of equivalent binary rules
using the synchronous binarization method
(Zhang et al., 2006) as follows:
</bodyText>
<equation confidence="0.99899">
VP â€” V1 JJR , V1 JJR
V1 â€” VB V2 , VB V2
V2 â€” NP ä¼š , NP will be
</equation>
<bodyText confidence="0.8441538">
This binarization is shown with the solid lines as
binarization (a) in Figure 1. We can see that bi-
narization (a) requires that â€œNP ä¼šâ€ should be
reduced at first. Data analysis shows that â€œNP ä¼šâ€
is a frequent pattern in the training corpus, and
there are 874 binary rules of which the source
language sides are â€œNP ä¼šâ€. Consequently these
binary rules generate a large number of compet-
ing edges in the chart when â€œNP ä¼šâ€ is matched
in decoding. To reduce the number of edges pro-
</bodyText>
<note confidence="0.901971">
362
Proceedings of the 2009 Conference on Empirical Methods in Natural Language Processing, pages 362â€“370,
Singapore, 6-7 August 2009. cï¿½2009 ACL and AFNLP
</note>
<bodyText confidence="0.999911523809524">
posed in decoding, hypothesis re-combination is
used to combine the equivalent edges in terms of
dynamic programming. Generally, two edges can
be re-combined if they satisfy the following two
constraints: 1) the LHS (left-hand side) non-
terminals are identical and the sub-alignments
are the same (Zhang et al., 2006); and 2) the
boundary words1 on both sides of the partial
translations are equal between the two edges
(Chiang, 2007). However, as shown in Figure 2,
the decoder still generates 801 edges after the
hypothesis re-combination. As a result, aggres-
sive pruning with beam search has to be em-
ployed to reduce the search space to make the
decoding practical. Usually in beam search only
a very small number of edges are kept in the
beam of each chart cell (e.g. less than 100).
These edges have to compete with each other to
survive from the pruning. Obviously, more com-
peting edges proposed during decoding can lead
to a higher risk of making search errors.
</bodyText>
<note confidence="0.953498666666667">
VP
VB NP ä¼š JJR
VB NP will be JJR
</note>
<figureCaption confidence="0.774594666666667">
Figure 1: Two different binarizations (a) and
(b) of the same SCFG rule distinguished by the
solid lines and dashed lines
</figureCaption>
<figure confidence="0.93929425">
Wr l *V_ IrkR _16-ï¿½ 3M ï¿½
(We hope the situation will be better .)
match 874 rules match 62 rules
competing edges: 801 competing edges: 57
</figure>
<figureCaption confidence="0.977245">
Figure 2: Edge competitions caused by different
binarizations
</figureCaption>
<bodyText confidence="0.9733395">
The edge competition problem for SMT de-
coding is not addressed in previous work (Zhang
et al., 2006; Huang, 2007) in which each SCFG
rule is binarized in a fixed way. Actually the re-
sults of synchronous binarization may not be the
only solution. As illustrated in Figure 1, the rule
1 For the case of n-gram language model integration,
2 x (ğ‘› âˆ’ 1) boundary words needs to be examined.
can also be binarized as binarization (b) which is
shown with the dashed lines.
We think that this problem can be alleviated
by choosing better binarizations for SMT decod-
ers, since there is generally more than one bina-
rization for a SCFG rule. In our investigation,
about 96% rules that need to be binarized have
more than one binarization under the contiguous
constraint. As shown in binarization (b) (Figure
1), â€œä¼š JJRâ€ is reduced first. In the decoder, the
number of binary rules with the source-side â€œä¼š
JJRâ€ is 62, and the corresponding number of
edges is 57 (Figure 2). The two numbers are both
much smaller than those of â€œNP ä¼šâ€ in (a). This
is an informative clue that the binarization (b)
could be better than the binarization (a) based on
the following: the probability of pruning the rule
in (a) is higher than that in (b) as the rule in (b)
has fewer competitors and has more chances to
survive during pruning.
In this paper we propose a novel binarization
method, aiming to find better binarizations to
improve an SCFG-based machine translation
system. We formulate the binarization optimiza-
tion as a cost reduction process, where the cost is
defined as the number of rules sharing a common
source-side derivation in an SCFG. We present
an algorithm, iterative cost reduction algorithm,
to obtain better binarization for the SCFG learnt
automatically from the training corpus. It can
work with an efficient CKY-style binarizer to
search for the lowest-cost binarization. We apply
our method into a state-of-the-art string-to-tree
SMT system. The experimental results show that
our method outperforms the synchronous binari-
zation method (Zhang et al., 2006) with over 0.8
BLEU scores on both NIST 2005 and NIST 2008
Chinese-to-English evaluation data sets.
</bodyText>
<sectionHeader confidence="0.999443" genericHeader="introduction">
2 Related Work
</sectionHeader>
<bodyText confidence="0.999439571428572">
The problem of binarization originates from the
parsing problem in which several binarization
methods are studied such as left/right binariza-
tion (Charniak et al., 1998; Tsuruoka and Tsujii,
2004) and head binarization (Charniak et al.,
2006). Generally, the pruning issue in SMT de-
coding is unnecessary for the parsing problem,
and the accuracy of parsing does not rely on the
binarization method heavily. Thus, many efforts
on the binarization in parsing are made for the
efficiency improvement instead of the accuracy
improvement (Song et al., 2008).
Binarization is also an important topic in the
research of syntax-based SMT. A synchronous
</bodyText>
<figure confidence="0.972746285714286">
(b) (a)
V,
V2
V,&apos;
V2&apos;
decoding
Wr l *V_ NP -,`ï¿½ JJR ï¿½
</figure>
<page confidence="0.761888">
363
</page>
<bodyText confidence="0.999896">
binarization method is proposed in (Zhang et al.,
2006) whose basic idea is to build a left-heavy
binary synchronous tree (Shapiro and Stephens,
1991) with a left-to-right shift-reduce algorithm.
Target-side binarization is another binarization
method which is proposed by Huang (2007). It
works in a left-to-right way on the target lan-
guage side. Although this method is compara-
tively easy to be implemented, it just achieves
the same performance as the synchronous binari-
zation method (Zhang et al., 2006) for syntax-
based SMT systems. In addition, it cannot be
easily integrated into the decoding of some syn-
tax-based models (Galley et al., 2004; Marcu et
al., 2006), because it does not guarantee conti-
guous spans on the source language side.
</bodyText>
<sectionHeader confidence="0.856717" genericHeader="method">
3 Synchronous Binarization Optimiza-
tion by Cost Reduction
</sectionHeader>
<bodyText confidence="0.999884782608696">
As discussed in Section 1, binarizing an SCFG in
a fixed (left-heavy) way (Zhang et al., 2006) may
lead to a large number of competing edges and
consequently high risk of making search errors.
Fortunately, in most cases a binarizable SCFG
can be binarized in different ways, which pro-
vides us with an opportunity to find a better solu-
tion than the default left-heavy binarization. An
ideal solution to this problem could be that we
define an exact edge competition estimation
function and choose the best binary SCFG based
on it. However, even for the rules with a com-
mon source-side, generally it is difficult to esti-
mate the exact number of competing edges in the
dynamic SCFG parsing process for machine
translation, because in order to integrate an n-
gram language model, the actual number of
edges not only depends on SCFG rules, but also
depends on language model states which are spe-
cific to input sentences. Instead, we have to em-
ploy certain kinds of approximation of it. First
we will introduce some notations frequently used
in later discussions.
</bodyText>
<subsectionHeader confidence="0.994713">
3.1 Notations
</subsectionHeader>
<bodyText confidence="0.999454461538462">
We use G = {Ri : Xi â€”ï¿½ ai, Fli} to denote an
SCFG, where Ri is the ith rule in G; Xi is the
LHS (left hand side) non-terminal of Ri; ai and
Fli are the source-side and target-side RHS (right
hand side) derivations of Ri respectively. We use
B (G) to denote the set of equivalent binary
SCFG of G. The goal of SCFG binarization is to
find an appropriate binary SCFG Gâ€² E B (G). For
Ri , B (Ri) = {vil} S Gâ€² G B (G) is the set of
equivalent binary rules based on Ri, where vil is
the lth binary rule in B (Ri). Figure 3 illustrates
the meanings of these notations with a sample
grammar.
</bodyText>
<figureCaption confidence="0.972165">
Figure 3: Binarization on a sample grammar
</figureCaption>
<equation confidence="0.966108">
V12 â†’ VB V13 , VB V13
S(â€œVB NP ä¼š JJR â€, Gâ€™) S(â€œVB NP ä¼šâ€, Gâ€™) S(â€œNP ä¼šâ€, Gâ€™)
</equation>
<bodyText confidence="0.999505086956522">
The function L(â€¢) is defined to map a result-
ing binary rule vil EGâ€² to the sub-sequence in ai
derived from vil . For example, as shown in Fig-
ure 3, the binary rule v13 covers the source sub-
sequence â€œNP ä¼šâ€ in R1, so L(v13 ) = &amp;quot;NP ä¼š&amp;quot;.
Similarly, L(v12 ) = &amp;quot;VB NP ä¼š&amp;quot;.
The function L(â€¢) is used to group the rules in
Gâ€² with a common right-hand side derivation for
source language. Given a binary rule v E Gâ€², we
can put it into a bucket in which all the binary
rules have the same source sub-sequence L(v).
For example (Figure 3), as L(v12 ) = &amp;quot;VB NP ä¼š&amp;quot;,
v12 is put into the bucket indexed by â€œVB NP ä¼šâ€.
And v13 and v22 are put into the same bucket,
since they have the same source sub-sequence
â€œNP ä¼šâ€. Obviously, Gâ€² can be divided into a set
of mutual exclusive rule buckets by L(â€¢).
In this paper, we use S(L(v), Gâ€²) to denote the
bucket for the binary rules having the source sub-
sequence L(v). For example, S(&amp;quot;NP ä¼š&amp;quot;, Gâ€²) de-
notes the bucket for the binary rules having the
source-side â€œNP ä¼šâ€. For simplicity, we also use
S(v, Gâ€²) to denote S(L(v), Gâ€² ).
</bodyText>
<subsectionHeader confidence="0.999464">
3.2 Cost Reduction for SCFG Binarization
</subsectionHeader>
<bodyText confidence="0.999985166666667">
Given a binary SCFG Gâ€², it can be easily noticed
that if a rule v in the bucket S(v, Gâ€²) can be ap-
plied to generate one or more new edges in
SCFG parsing, any other rules in this bucket can
also be applied because all of them can be re-
duced from the same underlying derivation L(v).
</bodyText>
<equation confidence="0.917503826086957">
G
R1 :
R2 :
VP â†’ VB NP ä¼š JJR , VB NP will be JJR
S â†’ NP ä¼š VP , NP will VP
binarization
Gâ€™
(R1)
v11 :
v12 :
v13 :
VP â†’ V12 JJR , V12 JJR
V13 â†’ NP ä¼š , NP will be
(R2)
v21 : S â†’ V22 VP , V22 VP
v22 : V22 â†’ NP ä¼š , NP will
rule bucket
L(v12)=â€VB NP ä¼šâ€
v22
v11 v12
v13
...
364
</equation>
<bodyText confidence="0.999943037037037">
Each application of other rules in the bucket
ğ‘†(ğ‘£, ğºâ€²) can generate competing edges with the
one based on ğ‘£. Intuitively, the size of bucket
can be used to approximately indicate the actual
number of competing edges on average, and re-
ducing the size of bucket could help reduce the
edges generated in a parsing chart by applying
the rules in the bucket. Therefore, if we can find
a method to greedily reduce the size of each
bucket ğ‘†(ğ‘£, ğºâ€²), we can reduce the overall ex-
pected edge competitions when parsing with ğºâ€².
However, it can be easily proved that the
numbers of binary rules in any ğºâ€² âˆˆ â„¬ ğº are
same, which implies that we cannot reduce the
sizes of all buckets at the same time â€“ removing
a rule from one bucket means adding it to anoth-
er. Allowing for this fact, the excess edge com-
petition example shown in Section 1 is essential-
ly caused by the uneven distribution of rules
among different buckets ğ‘† âˆ™ . Accordingly, our
optimization objective should be a more even
distribution of rules among buckets.
In the following, we formally define a metric
to model the evenness of rule distribution over
buckets. Given a binary SCFG ğºâ€² and a binary
SCFG rule ğ‘£ âˆˆ ğºâ€², ğ‘„(ğ‘£) is defined as the cost
function that maps ğ‘£ to the size of the bucket
</bodyText>
<equation confidence="0.9332075">
ğ‘† ğ‘£, ğºâ€² :
ğ‘„ ğ‘£ = ğ‘† ğ‘£, ğºâ€² (1)
</equation>
<bodyText confidence="0.99962">
Obviously, all the binary rules in ğ‘† ğ‘£, ğºâ€² share a
common cost value ğ‘† ğ‘£, ğºâ€² . For example (Fig-
ure 3), both ğ‘£13 and ğ‘£22 are put into the same
bucket ğ‘† &amp;quot;ğ‘ğ‘ƒ ä¼š&amp;quot;, ğºâ€² , so ğ‘„ ğ‘£13 = ğ‘„ ğ‘£22 = 2.
The cost of the SCFG ğºâ€² is computed by
summing up all the costs of SCFG rules in it:
</bodyText>
<equation confidence="0.955635">
ğ‘„ ğºâ€² = ğ‘„(ğ‘£) (2)
ğ‘£âˆˆğºâ€²
</equation>
<bodyText confidence="0.9989175">
Back to our task, we are to find an equivalent
binary SCFG ğºâ€² of ğº with the lowest cost in
terms of the cost function ğ‘„(. ) given in Equation
(2):
</bodyText>
<equation confidence="0.989627">
ğºâˆ— = argminğºâ€² âˆˆâ„¬ ğº ğ‘„(ğºâ€²) (3)
</equation>
<bodyText confidence="0.9999446">
Next we will show how ğºâˆ— is related to the
evenness of rule distribution among different
buckets. Let ğ‘† ğºâ€² = {ğ‘†1,... ,ğ‘†ğ‘€} be the set of
rule buckets containing rules in ğºâ€², then the value
of ğ‘„ (ğºâ€²) can also be written as:
</bodyText>
<equation confidence="0.991746">
ğ‘„ ğºâ€² = ğ‘†ğ‘– 2
1â‰¤ğ‘–â‰¤ğ‘€
</equation>
<bodyText confidence="0.986559">
Assume ğ‘Œğ‘– = ğ‘†ğ‘– is an empirical distribution of a
discrete random variable ğ‘Œ, then the square devi-
ation of the empirical distribution is:
</bodyText>
<equation confidence="0.943185714285714">
1
ğœ2 = ğ‘€ ( ğ‘†ğ‘– âˆ’ ğ‘Œ )2 (5)
ğ‘–
Noticing that Î£ ğ‘†ğ‘– = ğºâ€²
ation (5) can be written as:
â€² âˆ’ ğºâ€² 2
ğ‘€ (6)
</equation>
<bodyText confidence="0.999917285714286">
Since both ğ‘€ and |ğºâ€² |are constants, minimizing
the cost function ğ‘„ (ğºâ€²) is equivalent to minimiz-
ing the square deviation of the distribution of
rules among different buckets. A binary SCFG
with the lower cost indicates the rules are more
evenly distributed in terms of derivation patterns
on the source language side.
</bodyText>
<subsectionHeader confidence="0.994137">
3.3 Static Cost Reduction
</subsectionHeader>
<bodyText confidence="0.999398161290323">
Before moving on discussing the algorithm
which can optimize Equation (3) based on rule
costs specified in Equation (1), we first present
an algorithm to find the optimal solution to Eq-
uation (3) if we have known the cost setting of
ğºâˆ— and can use the costs as static values during
binarization. Using this simplification, the prob-
lem of finding the binary SCFG ğºâˆ— with minim-
al costs can be reduced to find the optimal bina-
rization â„¬âˆ—(ğ‘…ğ‘–) for each rule ğ‘…ğ‘– in ğº.
To obtain â„¬âˆ—(ğ‘…ğ‘–), we can employ a CKY-
style binarization algorithm which builds a com-
pact binarization forest for the rule ğ‘…ğ‘– in bottom-
up direction. The algorithm combines two adja-
cent spans of ğ›¼ğ‘– each time, in which two spans
can be combined if and only if they observe the
BTG constraints âˆ’ their translations are either
sequentially or reversely adjacent in ğ›½ğ‘–, the tar-
get-side derivation of ğ‘…ğ‘–. The key idea of this
algorithm is that we only use the binarization tree
with the lowest cost of each span for later com-
bination, which can avoid enumerating all the
possible binarization trees of ğ‘…ğ‘– using dynamic
programming.
Let ğ›¼ğ‘ğ‘ be the sub-sequence spanning from p
to q on the source-side, ğ‘£[ğ‘, ğ‘] be optimal bina-
rization tree spanning ğ›¼ğ‘ğ‘ , ğ‘„ğ‘£ [ğ‘, ğ‘] be the cost of
ğ‘£[ğ‘, ğ‘], and ğ‘„ğ‘Ÿ [ğ‘, ğ‘] be the cost of any binary
rules whose source-side is ğ›¼ğ‘ğ‘ , then the cost of
optimal binarization tree spanning ğ›¼ğ‘ğ‘ can be
computed as:
</bodyText>
<equation confidence="0.959917142857143">
ğ‘„ğ‘£ [ğ‘, ğ‘] = min (ğ‘„ğ‘Ÿ[ğ‘, ğ‘] + ğ‘„ğ‘£[ğ‘, ğ‘˜] + ğ‘„ğ‘£[ğ‘˜ + 1, ğ‘])
ğ‘â‰¤ğ‘˜â‰¤ğ‘âˆ’1
(4)
and ğ‘Œ = ğºâ€² /ğ‘€, Equ-
1
ğœ2 = ğ‘€ ğ‘„ ğº
365
</equation>
<bodyText confidence="0.76106575">
The algorithm is shown as follows:
CYK-based binarization algorithm
Input: a SCFG rule ğ‘…ğ‘– and the cost function ğ‘„(. ).
Output: the lowest cost binarization on ğ‘…ğ‘–
</bodyText>
<listItem confidence="0.984579375">
1: Function CKYBINARIZATION(ğ‘…ğ‘–, ğ‘„)
2: for l = 2 to n do âŠ³ Length of span
3: for p = 1 to n â€“ l + 1 do âŠ³ Start of span
4: q = p + l âŠ³ End of span
5: for k = p to q â€“ 1 do âŠ³ Partition of span
6: if not CONSECUTIVE(ğ‘‡ ğ‘, ğ‘˜ , ğ‘‡ ğ‘˜ + 1, ğ‘ )
then next loop
7: ğ‘„ğ‘Ÿ [ğ‘, ğ‘] â† ğ‘„ (ğ›¼ğ‘ ğ‘)
8: curCost â† ğ‘„ğ‘Ÿ ğ‘, ğ‘ +ğ‘„ğ‘£ ğ‘, ğ‘˜ +ğ‘„ğ‘£ [ğ‘˜ + 1, ğ‘]
9: if curCost &lt; minCost then
10: minCost â† curCost
11: ğ‘£[ğ‘, ğ‘] â† COMBINE(ğ‘£[ğ‘, ğ‘˜], ğ‘£[ğ‘˜ + 1, ğ‘])
12: ğ‘„ğ‘£ ğ‘, ğ‘ â† minCost
13: return ğ‘£ [1, ğ‘›]
14: Function CONSECUTIVE(( a, b), (c, d))
15: return (b = c â€“ 1) or (d = a â€“ 1)
</listItem>
<bodyText confidence="0.999962769230769">
where n is the number of tokens (consecutive
terminals are viewed as a single token) on the
source-side of ğ‘…ğ‘–. COMBINE(ğ‘£[ğ‘, ğ‘˜], ğ‘£[ğ‘˜ + 1, ğ‘])
combines the two binary sub-trees into a larger
sub-tree over ğ›¼ğ‘ğ‘ . ğ‘‡ ğ‘, ğ‘ = (ğ‘, ğ‘) means that the
non-terminals covering ğ›¼ğ‘ğ‘ have the consecutive
indices ranging from a to b on the target-side. If
the target non-terminal indices are not consecu-
tive, we set ğ‘‡ ğ‘, ğ‘ = (âˆ’1, âˆ’1). ğ‘„ ğ›¼ ğ‘ğ‘ = ğ‘„ (ğ‘£â€²)
where ğ‘£â€² is any rule in the bucket ğ‘† ğ›¼ğ‘ğ‘, ğºâ€² .
In the algorithm, lines 9-11 implement dynam-
ic programming, and the function CONSECUTIVE
checks whether the two spans can be combined.
</bodyText>
<note confidence="0.767331">
VB NP will be JJR
</note>
<figureCaption confidence="0.978617">
Figure 4: Binarization forest for an SCFG rule
</figureCaption>
<table confidence="0.999830833333333">
ğ¿(ğ‘£) ğ‘„(ğ‘£) ğ¿(ğ‘£) ğ‘„(ğ‘£)
VB NP VB NP ä¼š VB NP ä¼š 10
6619
NP ä¼š 874 c=0 c=0 c=0 c=0 2
NP ä¼š JJR
ä¼š JJR 62 VB NP ä¼š JJR 1
</table>
<tableCaption confidence="0.9994">
Table 1: Sub-sequences and corresponding costs
</tableCaption>
<bodyText confidence="0.9999206875">
Figure 4 shows an example of the compact
forest the algorithm builds, where the solid lines
indicate the optimal binarization of the rule,
while other alternatives pruned by dynamic pro-
gramming are shown in dashed lines. The costs
for binarization trees are computed based on the
cost table given in Table 1.
The time complexity of the CKY-based bina-
rization algorithm is Î˜(n3), which is higher than
that of the linear binarization such as the syn-
chronous binarization (Zhang et al., 2006). But it
is still efficient enough in practice, as there are
generally only a few tokens (n &lt; 5) on the
source-sides of SCFG rules. In our experiments,
the linear binarization method is just 2 times
faster than the CKY-based binarization.
</bodyText>
<subsectionHeader confidence="0.718052">
3.4 Iterative Cost Reduction
</subsectionHeader>
<bodyText confidence="0.999374857142857">
However, ğ‘„ (âˆ™) cannot be easily predetermined in
a static way as is assumed in Section 3.3 because
it depends on ğºâ€² and should be updated whenever
a rule in ğº is binarized differently. In our work
this problem is solved using the iterative cost
reduction algorithm, in which the update of ğºâ€²
and the cost function ğ‘„ (âˆ™) are coupled together.
</bodyText>
<table confidence="0.814725">
Iterative cost reduction algorithm
Input: An SCFG ğº
Output: An equivalent binary SCFG ğºâ€² of ğº
</table>
<listItem confidence="0.836288444444444">
1: Function ITERATIVECOSTREDUCTION(ğº)
2: ğºâ€² â† ğº0
3: for each ğ‘£ âˆˆ ğº0do
4: ğ‘„(ğ‘£) = ğ‘† ğ‘£, ğº0
5: while ğ‘„ (ğºâ€²) does not converge do
6: for each ğ‘…ğ‘– âˆˆ ğº do
7: ğº[âˆ’ğ‘…ğ‘–] â† ğºâ€² âˆ’ â„¬(ğ‘…ğ‘–)
8: for each ğ‘£ âˆˆ â„¬(ğ‘…ğ‘–) do
9: for each ğ‘£â€² âˆˆ ğ‘† ğ‘£, ğºâ€² do
</listItem>
<figure confidence="0.589967428571429">
10: ğ‘„ ğ‘£â€² â† ğ‘„ ğ‘£â€² âˆ’ 1
11: â„¬(ğ‘…ğ‘–) â† CKYBINARIZATION(ğ‘…ğ‘–, ğ‘„)
12: ğºâ€² â† ğº[âˆ’ğ‘…ğ‘–] âˆª â„¬(ğ‘…ğ‘–)
13: for each ğ‘£ âˆˆ â„¬(ğ‘…ğ‘–) do
14: for each ğ‘£â€² âˆˆ ğ‘† ğ‘£, ğºâ€² do
15: ğ‘„ ğ‘£â€² â† ğ‘„ ğ‘£â€² + 1
16: return ğºâ€²
</figure>
<bodyText confidence="0.993302866666667">
In the iterative cost reduction algorithm, we
first obtain an initial binary SCFG ğº0 using the
synchronous binarization method proposed in
(Zhang et al., 2006). Then ğº0 is assigned to an
iterative variable ğºâ€². The cost of each binary rule
in ğº0 is computed based on ğº0 according to Equ-
ation (1) (lines 3-4 in the algorithm).
After initialization, ğºâ€² is updated by iteratively
finding better binarization for each rule in ğº. The
basic idea is: for each ğ‘…ğ‘– in ğº, we remove the
current binarization result for ğ‘…ğ‘– from ğºâ€² (line 7),
while the cost function ğ‘„(âˆ™) is updated accor-
dingly since the removal of binary rule ğ‘£ âˆˆ
â„¬(ğ‘…ğ‘–) results in the reduction of the size of the
corresponding bucket ğ‘† ğ‘£, ğºâ€² . Lines 8-10 im-
</bodyText>
<figure confidence="0.553346333333333">
VP c=65
c=6682
lowest cost
c=885
V[1,3] V[2,4]
c=6629 c=884 c=876 c=64
V[1,2] V[2,3] V[3,4]
c=6619 c=874 c=62
JJR
</figure>
<page confidence="0.57212">
366
</page>
<bodyText confidence="0.999149454545455">
plement the cost reduction of each binary rule in
the bucket S(v, Gâ€² ).
Next, we find the lowest cost binarization for
Ri based on the updated cost function Q(â€¢) with
the CKY-based binarization algorithm presented
in Section 3.3 (line 11).
At last, the new binarization for Ri is added
back to Gâ€² and Q (â€¢) is re-updated to synchronize
with this change (lines 12-15). Figure 5 illu-
strates the differences between the static cost
reduction and the iterative cost reduction.
</bodyText>
<figure confidence="0.63607">
(q) iterative cost reduction
</figure>
<figureCaption confidence="0.990901">
Figure 5: Comparison between the static cost
</figureCaption>
<bodyText confidence="0.970372">
reduction and the iterative cost reduction
The algorithm stops when Q (Gâ€²) does not de-
crease any more. Next we will show that Q (Gâ€²)
is guaranteed not to increase in the iterative
process.
For any B(Ri) on Ri, we have
</bodyText>
<equation confidence="0.981964">
Q (G[âˆ’Ri] U B(Ri))
= 2 x Q(B(Ri)) + IB (Ri)I + Q(G[âˆ’Ri] )
</equation>
<bodyText confidence="0.992120666666667">
As both IB(Ri)I and Q(G[âˆ’Ri] ) are constants with
respect to Q(B(Ri)), Q (G[âˆ’Ri] U B(Ri)) is a li-
near function of Q(B (Ri)), and the correspond-
ing slope is positive. Thus Q (G[âˆ’Ri] U B(Ri))
reaches the lowest value only when Q (B (Ri))
reaches the lowest value. So Q (G[âˆ’Ri] U B(Ri))
achieves the lowest cost when we replace the
current binarization with the new binarization
B*(Ri) (line 12). Therefore Q (G[âˆ’Ri] U B(Ri))
does not increase in the processing on each Ri
(lines 7-15), and Q(Gâ€²) will finally converge to a
local minimum when the algorithm stops.
</bodyText>
<sectionHeader confidence="0.99898" genericHeader="method">
4 Experiments
</sectionHeader>
<bodyText confidence="0.99804275">
The experiments are conducted on Chinese-to-
English translation in a state-of-the-art string-to-
tree SMT system. All the results are reported in
terms of case-insensitive BLEU4(%).
</bodyText>
<subsectionHeader confidence="0.979439">
4.1 Experimental Setup
</subsectionHeader>
<bodyText confidence="0.999992451612903">
Our bilingual training corpus consists of about
350K bilingual sentences (9M Chinese words +
10M English words)2. Giza++ is employed to
perform word alignment on the bilingual sen-
tences. The parse trees on the English side are
generated using the Berkeley Parser3. A 5-gram
language model is trained on the English part of
LDC bilingual training data and the Xinhua part
of Gigaword corpus. Our development data set
comes from NIST2003 evaluation data in which
the sentences of more than 20 words are ex-
cluded to speed up the Minimum Error Rate
Training (MERT). The test data sets are the
NIST evaluation sets of 2005 and 2008.
Our string-to-tree SMT system is built based
on the work of (Galley et al., 2006; Marcu et al.,
2006), where both the minimal GHKM and
SPMT rules are extracted from the training cor-
pus, and the composed rules are generated by
combining two or three minimal GHKM and
SPMT rules. Before the rule extraction, we also
binarize the parse trees on the English side using
Wang et al. (2007) â€s method to increase the
coverage of GHKM and SPMT rules. There are
totally 4.26M rules after the low frequency rules
are filtered out. The pruning strategy is similar to
the cube pruning described in (Chiang, 2007). To
achieve acceptable translation speed, the beam
size is set to 50 by default. The baseline system
is based on the synchronous binarization (Zhang
et al., 2006).
</bodyText>
<subsectionHeader confidence="0.997765">
4.2 Binarization Schemes
</subsectionHeader>
<bodyText confidence="0.999788">
Besides the baseline (Zhang et al., 2006) and
iterative cost reduction binarization methods, we
also perform right-heavy and random synchron-
ous binarizations for comparison. In this paper,
the random synchronous binarization is obtained
by: 1) performing the CKY binarization to build
the binarization forest for an SCFG rule; then 2)
performing a top-down traversal of the forest. In
the traversal, we randomly pick a feasible binari-
zation for each span, and then go on the traversal
in the two branches of the picked binarization.
Table 2 shows the costs of resulting binary
SCFGs generated using different binarization
methods. The costs of the baseline (left-heavy)
</bodyText>
<figure confidence="0.956013064516129">
2 LDC2003E14, LDC2003E07, LDC2005T06 and
LDC2005T10
3 http://code.google.com/p/berkeleyparser/
(a) static cost reduction
the ith
rule
Ri+,
Ri-,
Ri
...
G
...
binarize
update
binarizer
Q(âˆ™)
G0
dynamic
G
...
Ri-,
Q(âˆ™)
the ith
rule
Ri
binarize
binarizer
Ri+,
...
static
367
</figure>
<bodyText confidence="0.998568166666666">
and right-heavy binarization are similar, while
the cost of the random synchronous binarization
is lower than that of the baseline method4. As
expected, the iterative cost reduction method ob-
tains the lowest cost, which is much lower than
that of the other three methods.
</bodyText>
<table confidence="0.9597064">
Method cost of binary SCFG ğºâ€²
Baseline 4,897M
Right-heavy 5,182M
Random 3,479M
Iterative cost reduction 185M
</table>
<tableCaption confidence="0.997487">
Table 2: Costs of the binary SCFGs generated
using different binarization methods.
</tableCaption>
<subsectionHeader confidence="0.996134">
4.3 Evaluation of Translations
</subsectionHeader>
<bodyText confidence="0.9996164">
Table 3 shows the performance of SMT systems
based on different binarization methods. The
iterative cost reduction binarization method
achieves the best performance on the test sets as
well as the development set. Compared with the
baseline method, it obtains gains of 0.82 and
0.84 BLEU scores on NIST05 and NIST08 test
sets respectively. Using the statistical signific-
ance test described by Koehn (2004), the im-
provements are significant (p &lt; 0.05).
</bodyText>
<table confidence="0.999862166666667">
Method Dev NIST05 NIST08
Baseline 40.02 37.90 27.53
Right-heavy 40.05 37.87 27.40
Random 40.10 37.99 27.58
Iterative cost 40.97* 38.72* 28.37*
reduction
</table>
<tableCaption confidence="0.954089333333333">
Table 3: Performance (BLUE4(%)) of different
binarization methods. * = significantly better than
baseline (p &lt; 0.05).
</tableCaption>
<bodyText confidence="0.996371578947368">
The baseline method and the right-heavy bina-
rization method achieve similar performance,
while the random synchronous binarization me-
thod performs slightly better than the baseline
method, which agrees with the fact of the cost
reduction shown in Table 2. A possible reason
that the random synchronous binarization me-
thod can outperform the baseline method lies in
that compared with binarizing SCFG in a fixed
way, the random synchronous binarization tends
to give a more even distribution of rules among
buckets, which alleviates the problem of edge
competition. However, since the high-frequency
source sub-sequences still have high probabilities
to be generated in the binarization and lead to the
4 We perform random synchronous binarization for 5
times and report the average cost.
excess competing edges, it just achieves a very
small improvement.
</bodyText>
<subsectionHeader confidence="0.817333">
4.4 Translation Accuracy vs. Cost of Binary
SCFG
</subsectionHeader>
<bodyText confidence="0.999954">
We also study the impacts of cost reduction on
translation accuracy over iterations in iterative
cost reduction. Figure 6 and Figure 7 show the
results on NIST05 and NIST08 test sets. We can
see that the cost of the resulting binary SCFG
drops greatly as the iteration count increases,
especially in the first iteration, and the BLEU
scores increase as the cost decreases.
</bodyText>
<note confidence="0.450945">
BLEU4(%) cost of G&apos;
</note>
<figure confidence="0.985976222222222">
38.8
38.6
38.4
1.0E+09
38.2
38
1.0E+08
0 1 2 3 4 5 iteration
performance(BLEU4) cost
</figure>
<figureCaption confidence="0.996615">
Figure 6: Cost of binary SCFG vs. BLEU4 (NIST05)
</figureCaption>
<figure confidence="0.9697744">
BLEU4(%) cost of G&apos;
28.4
28.2
28
1.0E+09
27.8
27.6
1.0E+08
0 1 2 3 4 5 iteration
performance(BLEU4) cost
</figure>
<figureCaption confidence="0.999899">
Figure 7: Cost of binary SCFG vs. BLEU4 (NIST08)
</figureCaption>
<subsectionHeader confidence="0.995408">
4.5 Impact of Beam Size
</subsectionHeader>
<bodyText confidence="0.999950666666667">
In this section, we study the impacts of beam
sizes on translation accuracy as well as compet-
ing edges. To explicitly investigate the issue un-
der large beam sizes, we use a subset of NIST05
and NIST08 test sets for test, which has 50 Chi-
nese sentences of no longer than 10 words.
Figure 8 shows that the iterative cost reduction
method is consistently better than the baseline
method under various beam settings. Besides the
experiment on the test set of short sentences, we
also conduct the experiment on NIST05 test set.
To achieve acceptable decoding speed, we range
the beam size from 10 to 70. As shown in Figure
9, the iterative cost reduction method also out-
performs the baseline method under various
beam settings on the large test set.
Though enlarging beam size can reduce the
search errors and improve the system perfor-
mance, the decoding speed of string-to-tree SMT
drops dramatically when we enlarge the beam
size. The problem is more serious when long
</bodyText>
<figure confidence="0.9138066">
37.8
1.0E+10
27.4
1.0E+10
368
</figure>
<bodyText confidence="0.995753333333333">
sentences are translated. For example, when the
beam size is set to a larger number (e.g. 200), our
decoder takes nearly one hour to translate a sen-
tence whose length is about 20 on a 3GHz CPU.
Decoding on the entire NIST05 and NIST08 test
sets with large beam sizes is impractical.
</bodyText>
<figureCaption confidence="0.995197">
Figure 9: BLEU4 against beam size (NIST05)
</figureCaption>
<bodyText confidence="0.995181">
Figure 10 compares the baseline method and
the iterative cost reduction method in terms of
translation accuracy against the number of edges
proposed during decoding. Actually, the number
of edges proposed during decoding can be re-
garded as a measure of the size of search space.
We can see that the iterative cost reduction me-
thod outperforms the baseline method under var-
ious search effort.
</bodyText>
<figure confidence="0.6336855">
BLEU4(%)
1E+07 1E+08 1E+09 1E+10
</figure>
<figureCaption confidence="0.815418">
Figure 10: BLEU4 against competing edges
</figureCaption>
<bodyText confidence="0.9999536">
The experimental results of this section show
that compared with the baseline method, the iter-
ative cost reduction method can lead to much
fewer edges (about 25% reduction) as well as the
higher BLEU scores under various beam settings.
</bodyText>
<sectionHeader confidence="0.4034185" genericHeader="method">
4.6 Edge Competition vs. Cost of Binary
SCFG
</sectionHeader>
<bodyText confidence="0.999952971428572">
In this section, we study the impacts of cost re-
duction on the edge competition in the chart cells
of our CKY-based decoder. Two metrics are
used to evaluate the degree of edge competition.
They are the variance and the mean of the num-
ber of competing edges in the chart cells, where
high variance means that in some chart cells the
rules have high risk to be pruned due to the large
number of competing edges. The same situation
holds for the mean as well. Both of the two me-
trics are calculated on NIST05 test set, varying
with the span length of chart cell.
Figure 11 shows the cost of resulting binary
SCFG and the variance of competing edges
against iteration count in iterative cost reduction.
We can see that both the cost and the variance
reduce greatly as the iteration count increases.
Figure 12 shows the case for mean, where the
reduction of cost also leads to the reduction of
the mean value. The results shown in Figure 11
and Figure 12 indicate that the cost reduction is
helpful to reduce edge competition in the chart
cells.
We also perform decoding without pruning
(i.e. beam size = âˆ) on a very small set which
has 20 sentences of no longer than 7 words. In
this experiment, the baseline system and our iter-
ative cost reduction based system propose
14,454M and 10,846M competing edges respec-
tively. These numbers can be seen as the real
numbers of the edges proposed during decoding
instead of an approximate number observed in
the pruned search space. It suggests that our me-
thod can reduce the number of the edges in real
search space effectively. A possible reason to
</bodyText>
<figure confidence="0.996191444444444">
BLEU4(%)
42
40
38
36
34
32
10 50 100 500 1000 5000 beam
size
</figure>
<figureCaption confidence="0.824635">
Figure 8: BLEU4 against beam size (small test set)
</figureCaption>
<figure confidence="0.998467166666667">
BLEU4(%)
cost reduction
baseline
beam
10 20 30 40 50 70 size
39
38
37
36
35
cost reduction
baseline
42
40
38
36
34
32
cost reduction
baseline
# of
edges
variance cost of G&apos;
1.0E+10 1.0E+10 span=2
1.0E+9 span=3
span=5
span=7
span=10
span=20
cost
1.0E+9 1.0E+8
1.0E+7
1.0E+8
1.0E+7 1.0E+6
1.0E+5
0 1 2 3 4 5 iteration
</figure>
<figureCaption confidence="0.9808575">
Figure 11: Cost of binary SCFG vs. variance of
competing edge number (NIST05)
</figureCaption>
<figure confidence="0.982499">
mean cost of G&apos;
1.0E+5 1.0E+10 span=2
1.0E+9 span=3
span=5
span=7
span=10
span=20
cost
1.0E+8
1.0E+7
8.0E+3 1.0E+6
0 1 2 3 4 5 iteration
</figure>
<figureCaption confidence="0.992495">
Figure 12: Cost of binary SCFG vs. mean of
competing edge number (NIST05)
</figureCaption>
<page confidence="0.767499">
369
</page>
<bodyText confidence="0.9996834">
this result is that the cost reduction based binari-
zation could reduce the probability of rule mis-
matching caused by binarization, which results in
the reduction of the number of edges proposed
during decoding.
</bodyText>
<sectionHeader confidence="0.986088" genericHeader="conclusions">
5 Conclusion and Future Work
</sectionHeader>
<bodyText confidence="0.999986894736842">
This paper introduces a new binarization method,
aiming at choosing better binarization for SCFG-
based SMT systems. We demonstrate the effec-
tiveness of our method on a state-of-the-art
string-to-tree SMT system. Experimental results
show that our method can significantly outper-
form the conventional synchronous binarization
method, which indicates that better binarization
selection is very beneficial to SCFG-based SMT
systems.
In this paper the cost of a binary rule is de-
fined based on the competition among the binary
rules that have the same source-sides. However,
some binary rules with different source-sides
may also have competitions in a chart cell. We
think that the cost of a binary rule can be better
estimated by taking the rules with different
source-sides into account. We intend to study
this issue in our future work.
</bodyText>
<sectionHeader confidence="0.993967" genericHeader="acknowledgments">
Acknowledgements
</sectionHeader>
<bodyText confidence="0.9996145">
The authors would like to thank the anonymous
reviewers for their pertinent comments, and Xi-
nying Song, Nan Duan and Shasha Li for their
valuable suggestions for improving this paper.
</bodyText>
<sectionHeader confidence="0.994202" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999924236111111">
Eugene Charniak, Mark Johnson, Micha Elsner, Jo-
seph Austerweil, David Ellis, Isaac Haxton, Cathe-
rine Hill, R. Shrivaths, Jeremy Moore, Michael Po-
zar, and Theresa Vu. 2006. Multilevel Coarse-to-
Fine PCFG Parsing. In Proc. of HLT-NAACL 2006,
New York, USA, 168-175.
Eugene Charniak, Sharon Goldwater, and Mark John-
son. 1998. Edge-Based Best-First Chart Parsing. In
Proc. of the Six Workshop on Very Large Corpora,
pages: 127-133.
David Chiang. 2005. A Hierarchical Phrase-Based
Model for Statistical Machine Translation. In Proc.
of ACL 2005, Ann Arbor, Michigan, pages: 263-
270.
David Chiang. 2007. Hierarchical Phrase-based
Translation. Computational Linguistics. 33(2):
202-208.
Michel Galley, Jonathan Graehl, Kevin Knight, Da-
niel Marcu, Steve DeNeefe, Wei Wang, and Igna-
cio Thayer. 2006. Scalable Inference and Training
of Context-Rich Syntactic Translation Models. In
Proc. of ACL 2006, Sydney, Australia, pages: 961-
968.
Michel Galley, Mark Hopkins, Kevin Knight, and
Daniel Marcu. 2004. Whatâ€Ÿs in a translation rule?
In Proc. of HLT-NAACL 2004, Boston, USA, pag-
es: 273-280.
Liang Huang. 2007. Binarization, Synchronous Bina-
rization, and Target-side binarization. In Proc. of
HLT-NAACL 2007 / AMTA workshop on Syntax
and Structure in Statistical Translation, New York,
USA, pages: 33-40.
Tadao Kasami. 1965. An Efficient Recognition and
Syntax Analysis Algorithm for Context-Free Lan-
guages. Technical Report AFCRL-65-758, Air
Force Cambridge Research Laboratory, Bedford,
Massachusetts.
Philipp Koehn. 2004. Statistical Significance Tests for
Machine Translation Evaluation. In Proc. of
EMNLP 2004, Barcelona, Spain , pages: 388â€“395.
Daniel Marcu, Wei Wang, Abdessamad Echihabi, and
Kevin Knight. 2006. SPMT: Statistical machine
translation with syntactified target language phras-
es. In Proc. of EMNLP 2006, Sydney, Australia,
pages: 44-52.
Giorgio Satta and Enoch Peserico. 2005. Some Com-
putational Complexity Results for Synchronous
Context-Free Grammars. In Proc. of HLT-EMNLP
2005, Vancouver, pages: 803-810.
L. Shapiro and A. B. Stephens. 1991. Bootstrap per-
colation, the Schğ‘Ÿ oder numbers, and the n-kings
problem. SIAM Journal on Discrete Mathematics,
4(2):275-280.
Xinying Song, Shilin Ding and Chin-Yew Lin. 2008.
Better Binarization for the CKY Parsing. In Proc.
of EMNLP 2008, Hawaii, pages: 167-176.
Yoshimasa Tsuruoka and Junichi Tsujii. 2004. Itera-
tive CKY Parsing for Probabilistic Context-Free
Grammars. In Proc. of IJCNLP 2004, pages: 52-
60.
Wei Wang and Kevin Knight and Daniel Marcu.
2007. Binarizing Syntax Trees to Improve Syntax-
Based Machine Translation Accuracy. In Proc. of
EMNLP-CoNLL 2007, Prague, Czech Republic,
pages: 746-754.
D. H. Younger. 1967. Recognition and Parsing of
Context-Free Languages in Time n3. Information
and Control, 10(2):189-208.
Hao Zhang, Liang Huang, Daniel Gildea, and Kevin
Knight. 2006. Synchronous Binarization for Ma-
chine Translation. In Proc. of HLT-NAACL 2006,
New York, USA, pages: 256- 263.
</reference>
<page confidence="0.909396">
370
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.076526">
<title confidence="0.7865675">Better Synchronous Binarization for Machine Translation Mu Dongdong Jingbo Ming Language Processing Northeastern</title>
<address confidence="0.991652">Shenyang, China, 110004</address>
<email confidence="0.609363">xiaotong@mail.neu.edu.cnzhujingbo@mail.neu.edu.cn</email>
<affiliation confidence="0.742501">Research</affiliation>
<address confidence="0.7981555">Sigma Beijing, China, 100080</address>
<email confidence="0.999429">mingzhou@microsoft.com</email>
<abstract confidence="0.999252388888889">Binarization of Synchronous Context Free Grammars (SCFG) is essential for achieving polynomial time complexity of decoding for SCFG parsing based machine translation systems. In this paper, we first investigate the excess edge competition issue caused by a leftheavy binary SCFG derived with the method of Zhang et al. (2006). Then we propose a new binarization method to mitigate the problem by exploring other alternative equivalent binary SCFGs. We present an algorithm that iteratively improves the resulting binary SCFG, and empirically show that our method can improve a string-to-tree statistical machine translations system based on the synchronous binarization method in Zhang et al. (2006) on the NIST machine translation evaluation tasks.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Eugene Charniak</author>
<author>Mark Johnson</author>
<author>Micha Elsner</author>
<author>Joseph Austerweil</author>
<author>David Ellis</author>
<author>Isaac Haxton</author>
<author>Catherine Hill</author>
<author>R Shrivaths</author>
<author>Jeremy Moore</author>
<author>Michael Pozar</author>
<author>Theresa Vu</author>
</authors>
<title>Multilevel Coarse-toFine PCFG Parsing.</title>
<date>2006</date>
<booktitle>In Proc. of HLT-NAACL</booktitle>
<pages>168--175</pages>
<location>New York, USA,</location>
<contexts>
<context position="7260" citStr="Charniak et al., 2006" startWordPosition="1193" endWordPosition="1196">th an efficient CKY-style binarizer to search for the lowest-cost binarization. We apply our method into a state-of-the-art string-to-tree SMT system. The experimental results show that our method outperforms the synchronous binarization method (Zhang et al., 2006) with over 0.8 BLEU scores on both NIST 2005 and NIST 2008 Chinese-to-English evaluation data sets. 2 Related Work The problem of binarization originates from the parsing problem in which several binarization methods are studied such as left/right binarization (Charniak et al., 1998; Tsuruoka and Tsujii, 2004) and head binarization (Charniak et al., 2006). Generally, the pruning issue in SMT decoding is unnecessary for the parsing problem, and the accuracy of parsing does not rely on the binarization method heavily. Thus, many efforts on the binarization in parsing are made for the efficiency improvement instead of the accuracy improvement (Song et al., 2008). Binarization is also an important topic in the research of syntax-based SMT. A synchronous (b) (a) V, V2 V,&apos; V2&apos; decoding Wr l *V_ NP -,`ï¿½ JJR ï¿½ 363 binarization method is proposed in (Zhang et al., 2006) whose basic idea is to build a left-heavy binary synchronous tree (Shapiro and Step</context>
</contexts>
<marker>Charniak, Johnson, Elsner, Austerweil, Ellis, Haxton, Hill, Shrivaths, Moore, Pozar, Vu, 2006</marker>
<rawString>Eugene Charniak, Mark Johnson, Micha Elsner, Joseph Austerweil, David Ellis, Isaac Haxton, Catherine Hill, R. Shrivaths, Jeremy Moore, Michael Pozar, and Theresa Vu. 2006. Multilevel Coarse-toFine PCFG Parsing. In Proc. of HLT-NAACL 2006, New York, USA, 168-175.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Eugene Charniak</author>
<author>Sharon Goldwater</author>
<author>Mark Johnson</author>
</authors>
<title>Edge-Based Best-First Chart Parsing.</title>
<date>1998</date>
<booktitle>In Proc. of the Six Workshop on Very Large Corpora,</booktitle>
<pages>127--133</pages>
<contexts>
<context position="7186" citStr="Charniak et al., 1998" startWordPosition="1182" endWordPosition="1185">or the SCFG learnt automatically from the training corpus. It can work with an efficient CKY-style binarizer to search for the lowest-cost binarization. We apply our method into a state-of-the-art string-to-tree SMT system. The experimental results show that our method outperforms the synchronous binarization method (Zhang et al., 2006) with over 0.8 BLEU scores on both NIST 2005 and NIST 2008 Chinese-to-English evaluation data sets. 2 Related Work The problem of binarization originates from the parsing problem in which several binarization methods are studied such as left/right binarization (Charniak et al., 1998; Tsuruoka and Tsujii, 2004) and head binarization (Charniak et al., 2006). Generally, the pruning issue in SMT decoding is unnecessary for the parsing problem, and the accuracy of parsing does not rely on the binarization method heavily. Thus, many efforts on the binarization in parsing are made for the efficiency improvement instead of the accuracy improvement (Song et al., 2008). Binarization is also an important topic in the research of syntax-based SMT. A synchronous (b) (a) V, V2 V,&apos; V2&apos; decoding Wr l *V_ NP -,`ï¿½ JJR ï¿½ 363 binarization method is proposed in (Zhang et al., 2006) whose bas</context>
</contexts>
<marker>Charniak, Goldwater, Johnson, 1998</marker>
<rawString>Eugene Charniak, Sharon Goldwater, and Mark Johnson. 1998. Edge-Based Best-First Chart Parsing. In Proc. of the Six Workshop on Very Large Corpora, pages: 127-133.</rawString>
</citation>
<citation valid="true">
<authors>
<author>David Chiang</author>
</authors>
<title>A Hierarchical Phrase-Based Model for Statistical Machine Translation.</title>
<date>2005</date>
<booktitle>In Proc. of ACL 2005,</booktitle>
<pages>263--270</pages>
<location>Ann Arbor, Michigan,</location>
<contexts>
<context position="1300" citStr="Chiang, 2005" startWordPosition="176" endWordPosition="177"> Zhang et al. (2006). Then we propose a new binarization method to mitigate the problem by exploring other alternative equivalent binary SCFGs. We present an algorithm that iteratively improves the resulting binary SCFG, and empirically show that our method can improve a string-to-tree statistical machine translations system based on the synchronous binarization method in Zhang et al. (2006) on the NIST machine translation evaluation tasks. 1 Introduction Recently Statistical Machine Translation (SMT) systems based on Synchronous Context Free Grammar (SCFG) have been extensively investigated (Chiang, 2005; Galley et al., 2004; Galley et al., 2006) and have achieved state-of-the-art performance. In these systems, machine translation decoding is cast as a synchronous parsing task. Because general SCFG parsing is an NPhard problem (Satta and Peserico, 2005), practical SMT decoders based on SCFG parsing requires an equivalent binary SCFG that is directly learned from training data to achieve polynomial time complexity using the CKY algorithm (Kasami, 1965; Younger, 1967) borrowed from CFG parsing techniques. Zhang et al. (2006) proposed synchronous binarization, a principled method to binarize an </context>
</contexts>
<marker>Chiang, 2005</marker>
<rawString>David Chiang. 2005. A Hierarchical Phrase-Based Model for Statistical Machine Translation. In Proc. of ACL 2005, Ann Arbor, Michigan, pages: 263-270.</rawString>
</citation>
<citation valid="true">
<authors>
<author>David Chiang</author>
</authors>
<title>Hierarchical Phrase-based Translation.</title>
<date>2007</date>
<journal>Computational Linguistics.</journal>
<volume>33</volume>
<issue>2</issue>
<pages>202--208</pages>
<contexts>
<context position="2294" citStr="Chiang (2007)" startWordPosition="332" endWordPosition="333">o achieve polynomial time complexity using the CKY algorithm (Kasami, 1965; Younger, 1967) borrowed from CFG parsing techniques. Zhang et al. (2006) proposed synchronous binarization, a principled method to binarize an SCFG in such a way that both the source-side and target-side virtual non-terminals have contiguous spans. This property of synchronous binarization guarantees the polynomial time complexity of SCFG parsers even when an n-gram language model is integrated, which has been proved to be one of the keys to the success of a string-to-tree syntax-based SMT system. However, as shown by Chiang (2007), SCFGbased decoding with an integrated n-gram language model still has a time complexity of e(m3 ITI4(nâˆ’1)), where m is the source sentence length, and ITI is the vocabulary size of the language model. Although it is not exponential in theory, the actual complexity can still be very high in practice. Here is an example extracted from real data. Given the following SCFG rule: VP â€” VB NP ä¼š JJR , VB NP will be JJR we can obtain a set of equivalent binary rules using the synchronous binarization method (Zhang et al., 2006) as follows: VP â€” V1 JJR , V1 JJR V1 â€” VB V2 , VB V2 V2 â€” NP ä¼š , NP will be</context>
<context position="3960" citStr="Chiang, 2007" startWordPosition="632" endWordPosition="633"> the number of edges pro362 Proceedings of the 2009 Conference on Empirical Methods in Natural Language Processing, pages 362â€“370, Singapore, 6-7 August 2009. cï¿½2009 ACL and AFNLP posed in decoding, hypothesis re-combination is used to combine the equivalent edges in terms of dynamic programming. Generally, two edges can be re-combined if they satisfy the following two constraints: 1) the LHS (left-hand side) nonterminals are identical and the sub-alignments are the same (Zhang et al., 2006); and 2) the boundary words1 on both sides of the partial translations are equal between the two edges (Chiang, 2007). However, as shown in Figure 2, the decoder still generates 801 edges after the hypothesis re-combination. As a result, aggressive pruning with beam search has to be employed to reduce the search space to make the decoding practical. Usually in beam search only a very small number of edges are kept in the beam of each chart cell (e.g. less than 100). These edges have to compete with each other to survive from the pruning. Obviously, more competing edges proposed during decoding can lead to a higher risk of making search errors. VP VB NP ä¼š JJR VB NP will be JJR Figure 1: Two different binariza</context>
<context position="22773" citStr="Chiang, 2007" startWordPosition="4171" endWordPosition="4172">05 and 2008. Our string-to-tree SMT system is built based on the work of (Galley et al., 2006; Marcu et al., 2006), where both the minimal GHKM and SPMT rules are extracted from the training corpus, and the composed rules are generated by combining two or three minimal GHKM and SPMT rules. Before the rule extraction, we also binarize the parse trees on the English side using Wang et al. (2007) â€s method to increase the coverage of GHKM and SPMT rules. There are totally 4.26M rules after the low frequency rules are filtered out. The pruning strategy is similar to the cube pruning described in (Chiang, 2007). To achieve acceptable translation speed, the beam size is set to 50 by default. The baseline system is based on the synchronous binarization (Zhang et al., 2006). 4.2 Binarization Schemes Besides the baseline (Zhang et al., 2006) and iterative cost reduction binarization methods, we also perform right-heavy and random synchronous binarizations for comparison. In this paper, the random synchronous binarization is obtained by: 1) performing the CKY binarization to build the binarization forest for an SCFG rule; then 2) performing a top-down traversal of the forest. In the traversal, we randoml</context>
</contexts>
<marker>Chiang, 2007</marker>
<rawString>David Chiang. 2007. Hierarchical Phrase-based Translation. Computational Linguistics. 33(2): 202-208.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Michel Galley</author>
<author>Jonathan Graehl</author>
<author>Kevin Knight</author>
<author>Daniel Marcu</author>
<author>Steve DeNeefe</author>
<author>Wei Wang</author>
<author>Ignacio Thayer</author>
</authors>
<title>Scalable Inference and Training of Context-Rich Syntactic Translation Models.</title>
<date>2006</date>
<booktitle>In Proc. of ACL 2006,</booktitle>
<pages>961--968</pages>
<location>Sydney, Australia,</location>
<contexts>
<context position="1343" citStr="Galley et al., 2006" startWordPosition="182" endWordPosition="185">se a new binarization method to mitigate the problem by exploring other alternative equivalent binary SCFGs. We present an algorithm that iteratively improves the resulting binary SCFG, and empirically show that our method can improve a string-to-tree statistical machine translations system based on the synchronous binarization method in Zhang et al. (2006) on the NIST machine translation evaluation tasks. 1 Introduction Recently Statistical Machine Translation (SMT) systems based on Synchronous Context Free Grammar (SCFG) have been extensively investigated (Chiang, 2005; Galley et al., 2004; Galley et al., 2006) and have achieved state-of-the-art performance. In these systems, machine translation decoding is cast as a synchronous parsing task. Because general SCFG parsing is an NPhard problem (Satta and Peserico, 2005), practical SMT decoders based on SCFG parsing requires an equivalent binary SCFG that is directly learned from training data to achieve polynomial time complexity using the CKY algorithm (Kasami, 1965; Younger, 1967) borrowed from CFG parsing techniques. Zhang et al. (2006) proposed synchronous binarization, a principled method to binarize an SCFG in such a way that both the source-sid</context>
<context position="22253" citStr="Galley et al., 2006" startWordPosition="4078" endWordPosition="4081">s + 10M English words)2. Giza++ is employed to perform word alignment on the bilingual sentences. The parse trees on the English side are generated using the Berkeley Parser3. A 5-gram language model is trained on the English part of LDC bilingual training data and the Xinhua part of Gigaword corpus. Our development data set comes from NIST2003 evaluation data in which the sentences of more than 20 words are excluded to speed up the Minimum Error Rate Training (MERT). The test data sets are the NIST evaluation sets of 2005 and 2008. Our string-to-tree SMT system is built based on the work of (Galley et al., 2006; Marcu et al., 2006), where both the minimal GHKM and SPMT rules are extracted from the training corpus, and the composed rules are generated by combining two or three minimal GHKM and SPMT rules. Before the rule extraction, we also binarize the parse trees on the English side using Wang et al. (2007) â€s method to increase the coverage of GHKM and SPMT rules. There are totally 4.26M rules after the low frequency rules are filtered out. The pruning strategy is similar to the cube pruning described in (Chiang, 2007). To achieve acceptable translation speed, the beam size is set to 50 by default</context>
</contexts>
<marker>Galley, Graehl, Knight, Marcu, DeNeefe, Wang, Thayer, 2006</marker>
<rawString>Michel Galley, Jonathan Graehl, Kevin Knight, Daniel Marcu, Steve DeNeefe, Wei Wang, and Ignacio Thayer. 2006. Scalable Inference and Training of Context-Rich Syntactic Translation Models. In Proc. of ACL 2006, Sydney, Australia, pages: 961-968.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Michel Galley</author>
<author>Mark Hopkins</author>
<author>Kevin Knight</author>
<author>Daniel Marcu</author>
</authors>
<title>Whatâ€Ÿs in a translation rule?</title>
<date>2004</date>
<booktitle>In Proc. of HLT-NAACL 2004,</booktitle>
<pages>273--280</pages>
<location>Boston, USA,</location>
<contexts>
<context position="1321" citStr="Galley et al., 2004" startWordPosition="178" endWordPosition="181">(2006). Then we propose a new binarization method to mitigate the problem by exploring other alternative equivalent binary SCFGs. We present an algorithm that iteratively improves the resulting binary SCFG, and empirically show that our method can improve a string-to-tree statistical machine translations system based on the synchronous binarization method in Zhang et al. (2006) on the NIST machine translation evaluation tasks. 1 Introduction Recently Statistical Machine Translation (SMT) systems based on Synchronous Context Free Grammar (SCFG) have been extensively investigated (Chiang, 2005; Galley et al., 2004; Galley et al., 2006) and have achieved state-of-the-art performance. In these systems, machine translation decoding is cast as a synchronous parsing task. Because general SCFG parsing is an NPhard problem (Satta and Peserico, 2005), practical SMT decoders based on SCFG parsing requires an equivalent binary SCFG that is directly learned from training data to achieve polynomial time complexity using the CKY algorithm (Kasami, 1965; Younger, 1967) borrowed from CFG parsing techniques. Zhang et al. (2006) proposed synchronous binarization, a principled method to binarize an SCFG in such a way th</context>
<context position="8368" citStr="Galley et al., 2004" startWordPosition="1375" endWordPosition="1378">sed in (Zhang et al., 2006) whose basic idea is to build a left-heavy binary synchronous tree (Shapiro and Stephens, 1991) with a left-to-right shift-reduce algorithm. Target-side binarization is another binarization method which is proposed by Huang (2007). It works in a left-to-right way on the target language side. Although this method is comparatively easy to be implemented, it just achieves the same performance as the synchronous binarization method (Zhang et al., 2006) for syntaxbased SMT systems. In addition, it cannot be easily integrated into the decoding of some syntax-based models (Galley et al., 2004; Marcu et al., 2006), because it does not guarantee contiguous spans on the source language side. 3 Synchronous Binarization Optimization by Cost Reduction As discussed in Section 1, binarizing an SCFG in a fixed (left-heavy) way (Zhang et al., 2006) may lead to a large number of competing edges and consequently high risk of making search errors. Fortunately, in most cases a binarizable SCFG can be binarized in different ways, which provides us with an opportunity to find a better solution than the default left-heavy binarization. An ideal solution to this problem could be that we define an e</context>
</contexts>
<marker>Galley, Hopkins, Knight, Marcu, 2004</marker>
<rawString>Michel Galley, Mark Hopkins, Kevin Knight, and Daniel Marcu. 2004. Whatâ€Ÿs in a translation rule? In Proc. of HLT-NAACL 2004, Boston, USA, pages: 273-280.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Liang Huang</author>
</authors>
<title>Binarization, Synchronous Binarization, and Target-side binarization.</title>
<date>2007</date>
<booktitle>In Proc. of HLT-NAACL 2007 / AMTA workshop on Syntax and Structure in Statistical Translation,</booktitle>
<pages>33--40</pages>
<location>New York, USA,</location>
<contexts>
<context position="4963" citStr="Huang, 2007" startWordPosition="813" endWordPosition="814"> other to survive from the pruning. Obviously, more competing edges proposed during decoding can lead to a higher risk of making search errors. VP VB NP ä¼š JJR VB NP will be JJR Figure 1: Two different binarizations (a) and (b) of the same SCFG rule distinguished by the solid lines and dashed lines Wr l *V_ IrkR _16-ï¿½ 3M ï¿½ (We hope the situation will be better .) match 874 rules match 62 rules competing edges: 801 competing edges: 57 Figure 2: Edge competitions caused by different binarizations The edge competition problem for SMT decoding is not addressed in previous work (Zhang et al., 2006; Huang, 2007) in which each SCFG rule is binarized in a fixed way. Actually the results of synchronous binarization may not be the only solution. As illustrated in Figure 1, the rule 1 For the case of n-gram language model integration, 2 x (ğ‘› âˆ’ 1) boundary words needs to be examined. can also be binarized as binarization (b) which is shown with the dashed lines. We think that this problem can be alleviated by choosing better binarizations for SMT decoders, since there is generally more than one binarization for a SCFG rule. In our investigation, about 96% rules that need to be binarized have more than one </context>
<context position="8006" citStr="Huang (2007)" startWordPosition="1315" endWordPosition="1316">e binarization method heavily. Thus, many efforts on the binarization in parsing are made for the efficiency improvement instead of the accuracy improvement (Song et al., 2008). Binarization is also an important topic in the research of syntax-based SMT. A synchronous (b) (a) V, V2 V,&apos; V2&apos; decoding Wr l *V_ NP -,`ï¿½ JJR ï¿½ 363 binarization method is proposed in (Zhang et al., 2006) whose basic idea is to build a left-heavy binary synchronous tree (Shapiro and Stephens, 1991) with a left-to-right shift-reduce algorithm. Target-side binarization is another binarization method which is proposed by Huang (2007). It works in a left-to-right way on the target language side. Although this method is comparatively easy to be implemented, it just achieves the same performance as the synchronous binarization method (Zhang et al., 2006) for syntaxbased SMT systems. In addition, it cannot be easily integrated into the decoding of some syntax-based models (Galley et al., 2004; Marcu et al., 2006), because it does not guarantee contiguous spans on the source language side. 3 Synchronous Binarization Optimization by Cost Reduction As discussed in Section 1, binarizing an SCFG in a fixed (left-heavy) way (Zhang </context>
</contexts>
<marker>Huang, 2007</marker>
<rawString>Liang Huang. 2007. Binarization, Synchronous Binarization, and Target-side binarization. In Proc. of HLT-NAACL 2007 / AMTA workshop on Syntax and Structure in Statistical Translation, New York, USA, pages: 33-40.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Tadao Kasami</author>
</authors>
<title>An Efficient Recognition and Syntax Analysis Algorithm for Context-Free Languages.</title>
<date>1965</date>
<tech>Technical Report AFCRL-65-758,</tech>
<institution>Air Force Cambridge Research Laboratory,</institution>
<location>Bedford, Massachusetts.</location>
<contexts>
<context position="1755" citStr="Kasami, 1965" startWordPosition="248" endWordPosition="250">tion Recently Statistical Machine Translation (SMT) systems based on Synchronous Context Free Grammar (SCFG) have been extensively investigated (Chiang, 2005; Galley et al., 2004; Galley et al., 2006) and have achieved state-of-the-art performance. In these systems, machine translation decoding is cast as a synchronous parsing task. Because general SCFG parsing is an NPhard problem (Satta and Peserico, 2005), practical SMT decoders based on SCFG parsing requires an equivalent binary SCFG that is directly learned from training data to achieve polynomial time complexity using the CKY algorithm (Kasami, 1965; Younger, 1967) borrowed from CFG parsing techniques. Zhang et al. (2006) proposed synchronous binarization, a principled method to binarize an SCFG in such a way that both the source-side and target-side virtual non-terminals have contiguous spans. This property of synchronous binarization guarantees the polynomial time complexity of SCFG parsers even when an n-gram language model is integrated, which has been proved to be one of the keys to the success of a string-to-tree syntax-based SMT system. However, as shown by Chiang (2007), SCFGbased decoding with an integrated n-gram language model</context>
</contexts>
<marker>Kasami, 1965</marker>
<rawString>Tadao Kasami. 1965. An Efficient Recognition and Syntax Analysis Algorithm for Context-Free Languages. Technical Report AFCRL-65-758, Air Force Cambridge Research Laboratory, Bedford, Massachusetts.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Philipp Koehn</author>
</authors>
<title>Statistical Significance Tests for Machine Translation Evaluation.</title>
<date>2004</date>
<booktitle>In Proc. of EMNLP 2004,</booktitle>
<pages>388--395</pages>
<location>Barcelona, Spain ,</location>
<contexts>
<context position="24803" citStr="Koehn (2004)" startWordPosition="4486" endWordPosition="4487">inary SCFG ğºâ€² Baseline 4,897M Right-heavy 5,182M Random 3,479M Iterative cost reduction 185M Table 2: Costs of the binary SCFGs generated using different binarization methods. 4.3 Evaluation of Translations Table 3 shows the performance of SMT systems based on different binarization methods. The iterative cost reduction binarization method achieves the best performance on the test sets as well as the development set. Compared with the baseline method, it obtains gains of 0.82 and 0.84 BLEU scores on NIST05 and NIST08 test sets respectively. Using the statistical significance test described by Koehn (2004), the improvements are significant (p &lt; 0.05). Method Dev NIST05 NIST08 Baseline 40.02 37.90 27.53 Right-heavy 40.05 37.87 27.40 Random 40.10 37.99 27.58 Iterative cost 40.97* 38.72* 28.37* reduction Table 3: Performance (BLUE4(%)) of different binarization methods. * = significantly better than baseline (p &lt; 0.05). The baseline method and the right-heavy binarization method achieve similar performance, while the random synchronous binarization method performs slightly better than the baseline method, which agrees with the fact of the cost reduction shown in Table 2. A possible reason that the</context>
</contexts>
<marker>Koehn, 2004</marker>
<rawString>Philipp Koehn. 2004. Statistical Significance Tests for Machine Translation Evaluation. In Proc. of EMNLP 2004, Barcelona, Spain , pages: 388â€“395.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Daniel Marcu</author>
<author>Wei Wang</author>
<author>Abdessamad Echihabi</author>
<author>Kevin Knight</author>
</authors>
<title>SPMT: Statistical machine translation with syntactified target language phrases.</title>
<date>2006</date>
<booktitle>In Proc. of EMNLP 2006,</booktitle>
<pages>44--52</pages>
<location>Sydney, Australia,</location>
<contexts>
<context position="8389" citStr="Marcu et al., 2006" startWordPosition="1379" endWordPosition="1382"> 2006) whose basic idea is to build a left-heavy binary synchronous tree (Shapiro and Stephens, 1991) with a left-to-right shift-reduce algorithm. Target-side binarization is another binarization method which is proposed by Huang (2007). It works in a left-to-right way on the target language side. Although this method is comparatively easy to be implemented, it just achieves the same performance as the synchronous binarization method (Zhang et al., 2006) for syntaxbased SMT systems. In addition, it cannot be easily integrated into the decoding of some syntax-based models (Galley et al., 2004; Marcu et al., 2006), because it does not guarantee contiguous spans on the source language side. 3 Synchronous Binarization Optimization by Cost Reduction As discussed in Section 1, binarizing an SCFG in a fixed (left-heavy) way (Zhang et al., 2006) may lead to a large number of competing edges and consequently high risk of making search errors. Fortunately, in most cases a binarizable SCFG can be binarized in different ways, which provides us with an opportunity to find a better solution than the default left-heavy binarization. An ideal solution to this problem could be that we define an exact edge competition</context>
<context position="22274" citStr="Marcu et al., 2006" startWordPosition="4082" endWordPosition="4085">)2. Giza++ is employed to perform word alignment on the bilingual sentences. The parse trees on the English side are generated using the Berkeley Parser3. A 5-gram language model is trained on the English part of LDC bilingual training data and the Xinhua part of Gigaword corpus. Our development data set comes from NIST2003 evaluation data in which the sentences of more than 20 words are excluded to speed up the Minimum Error Rate Training (MERT). The test data sets are the NIST evaluation sets of 2005 and 2008. Our string-to-tree SMT system is built based on the work of (Galley et al., 2006; Marcu et al., 2006), where both the minimal GHKM and SPMT rules are extracted from the training corpus, and the composed rules are generated by combining two or three minimal GHKM and SPMT rules. Before the rule extraction, we also binarize the parse trees on the English side using Wang et al. (2007) â€s method to increase the coverage of GHKM and SPMT rules. There are totally 4.26M rules after the low frequency rules are filtered out. The pruning strategy is similar to the cube pruning described in (Chiang, 2007). To achieve acceptable translation speed, the beam size is set to 50 by default. The baseline system</context>
</contexts>
<marker>Marcu, Wang, Echihabi, Knight, 2006</marker>
<rawString>Daniel Marcu, Wei Wang, Abdessamad Echihabi, and Kevin Knight. 2006. SPMT: Statistical machine translation with syntactified target language phrases. In Proc. of EMNLP 2006, Sydney, Australia, pages: 44-52.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Giorgio Satta</author>
<author>Enoch Peserico</author>
</authors>
<title>Some Computational Complexity Results for Synchronous Context-Free Grammars.</title>
<date>2005</date>
<booktitle>In Proc. of HLT-EMNLP 2005,</booktitle>
<pages>803--810</pages>
<location>Vancouver,</location>
<contexts>
<context position="1554" citStr="Satta and Peserico, 2005" startWordPosition="214" endWordPosition="217"> that our method can improve a string-to-tree statistical machine translations system based on the synchronous binarization method in Zhang et al. (2006) on the NIST machine translation evaluation tasks. 1 Introduction Recently Statistical Machine Translation (SMT) systems based on Synchronous Context Free Grammar (SCFG) have been extensively investigated (Chiang, 2005; Galley et al., 2004; Galley et al., 2006) and have achieved state-of-the-art performance. In these systems, machine translation decoding is cast as a synchronous parsing task. Because general SCFG parsing is an NPhard problem (Satta and Peserico, 2005), practical SMT decoders based on SCFG parsing requires an equivalent binary SCFG that is directly learned from training data to achieve polynomial time complexity using the CKY algorithm (Kasami, 1965; Younger, 1967) borrowed from CFG parsing techniques. Zhang et al. (2006) proposed synchronous binarization, a principled method to binarize an SCFG in such a way that both the source-side and target-side virtual non-terminals have contiguous spans. This property of synchronous binarization guarantees the polynomial time complexity of SCFG parsers even when an n-gram language model is integrated</context>
</contexts>
<marker>Satta, Peserico, 2005</marker>
<rawString>Giorgio Satta and Enoch Peserico. 2005. Some Computational Complexity Results for Synchronous Context-Free Grammars. In Proc. of HLT-EMNLP 2005, Vancouver, pages: 803-810.</rawString>
</citation>
<citation valid="true">
<authors>
<author>L Shapiro</author>
<author>A B Stephens</author>
</authors>
<title>Bootstrap percolation, the Schğ‘Ÿ oder numbers, and the n-kings problem.</title>
<date>1991</date>
<journal>SIAM Journal on Discrete Mathematics,</journal>
<pages>4--2</pages>
<contexts>
<context position="7871" citStr="Shapiro and Stephens, 1991" startWordPosition="1296" endWordPosition="1299">ak et al., 2006). Generally, the pruning issue in SMT decoding is unnecessary for the parsing problem, and the accuracy of parsing does not rely on the binarization method heavily. Thus, many efforts on the binarization in parsing are made for the efficiency improvement instead of the accuracy improvement (Song et al., 2008). Binarization is also an important topic in the research of syntax-based SMT. A synchronous (b) (a) V, V2 V,&apos; V2&apos; decoding Wr l *V_ NP -,`ï¿½ JJR ï¿½ 363 binarization method is proposed in (Zhang et al., 2006) whose basic idea is to build a left-heavy binary synchronous tree (Shapiro and Stephens, 1991) with a left-to-right shift-reduce algorithm. Target-side binarization is another binarization method which is proposed by Huang (2007). It works in a left-to-right way on the target language side. Although this method is comparatively easy to be implemented, it just achieves the same performance as the synchronous binarization method (Zhang et al., 2006) for syntaxbased SMT systems. In addition, it cannot be easily integrated into the decoding of some syntax-based models (Galley et al., 2004; Marcu et al., 2006), because it does not guarantee contiguous spans on the source language side. 3 Sy</context>
</contexts>
<marker>Shapiro, Stephens, 1991</marker>
<rawString>L. Shapiro and A. B. Stephens. 1991. Bootstrap percolation, the Schğ‘Ÿ oder numbers, and the n-kings problem. SIAM Journal on Discrete Mathematics, 4(2):275-280.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Xinying Song</author>
<author>Shilin Ding</author>
<author>Chin-Yew Lin</author>
</authors>
<title>Better Binarization for the CKY Parsing.</title>
<date>2008</date>
<booktitle>In Proc. of EMNLP 2008,</booktitle>
<pages>167--176</pages>
<location>Hawaii,</location>
<contexts>
<context position="7570" citStr="Song et al., 2008" startWordPosition="1243" endWordPosition="1246">NIST 2008 Chinese-to-English evaluation data sets. 2 Related Work The problem of binarization originates from the parsing problem in which several binarization methods are studied such as left/right binarization (Charniak et al., 1998; Tsuruoka and Tsujii, 2004) and head binarization (Charniak et al., 2006). Generally, the pruning issue in SMT decoding is unnecessary for the parsing problem, and the accuracy of parsing does not rely on the binarization method heavily. Thus, many efforts on the binarization in parsing are made for the efficiency improvement instead of the accuracy improvement (Song et al., 2008). Binarization is also an important topic in the research of syntax-based SMT. A synchronous (b) (a) V, V2 V,&apos; V2&apos; decoding Wr l *V_ NP -,`ï¿½ JJR ï¿½ 363 binarization method is proposed in (Zhang et al., 2006) whose basic idea is to build a left-heavy binary synchronous tree (Shapiro and Stephens, 1991) with a left-to-right shift-reduce algorithm. Target-side binarization is another binarization method which is proposed by Huang (2007). It works in a left-to-right way on the target language side. Although this method is comparatively easy to be implemented, it just achieves the same performance a</context>
</contexts>
<marker>Song, Ding, Lin, 2008</marker>
<rawString>Xinying Song, Shilin Ding and Chin-Yew Lin. 2008. Better Binarization for the CKY Parsing. In Proc. of EMNLP 2008, Hawaii, pages: 167-176.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Yoshimasa Tsuruoka</author>
<author>Junichi Tsujii</author>
</authors>
<title>Iterative CKY Parsing for Probabilistic Context-Free Grammars.</title>
<date>2004</date>
<booktitle>In Proc. of IJCNLP</booktitle>
<pages>52--60</pages>
<contexts>
<context position="7214" citStr="Tsuruoka and Tsujii, 2004" startWordPosition="1186" endWordPosition="1189">matically from the training corpus. It can work with an efficient CKY-style binarizer to search for the lowest-cost binarization. We apply our method into a state-of-the-art string-to-tree SMT system. The experimental results show that our method outperforms the synchronous binarization method (Zhang et al., 2006) with over 0.8 BLEU scores on both NIST 2005 and NIST 2008 Chinese-to-English evaluation data sets. 2 Related Work The problem of binarization originates from the parsing problem in which several binarization methods are studied such as left/right binarization (Charniak et al., 1998; Tsuruoka and Tsujii, 2004) and head binarization (Charniak et al., 2006). Generally, the pruning issue in SMT decoding is unnecessary for the parsing problem, and the accuracy of parsing does not rely on the binarization method heavily. Thus, many efforts on the binarization in parsing are made for the efficiency improvement instead of the accuracy improvement (Song et al., 2008). Binarization is also an important topic in the research of syntax-based SMT. A synchronous (b) (a) V, V2 V,&apos; V2&apos; decoding Wr l *V_ NP -,`ï¿½ JJR ï¿½ 363 binarization method is proposed in (Zhang et al., 2006) whose basic idea is to build a left-h</context>
</contexts>
<marker>Tsuruoka, Tsujii, 2004</marker>
<rawString>Yoshimasa Tsuruoka and Junichi Tsujii. 2004. Iterative CKY Parsing for Probabilistic Context-Free Grammars. In Proc. of IJCNLP 2004, pages: 52-60.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Wei Wang</author>
<author>Kevin Knight</author>
<author>Daniel Marcu</author>
</authors>
<title>Binarizing Syntax Trees to Improve SyntaxBased Machine Translation Accuracy.</title>
<date>2007</date>
<booktitle>In Proc. of EMNLP-CoNLL 2007,</booktitle>
<pages>746--754</pages>
<location>Prague, Czech Republic,</location>
<contexts>
<context position="22556" citStr="Wang et al. (2007)" startWordPosition="4132" endWordPosition="4135">r development data set comes from NIST2003 evaluation data in which the sentences of more than 20 words are excluded to speed up the Minimum Error Rate Training (MERT). The test data sets are the NIST evaluation sets of 2005 and 2008. Our string-to-tree SMT system is built based on the work of (Galley et al., 2006; Marcu et al., 2006), where both the minimal GHKM and SPMT rules are extracted from the training corpus, and the composed rules are generated by combining two or three minimal GHKM and SPMT rules. Before the rule extraction, we also binarize the parse trees on the English side using Wang et al. (2007) â€s method to increase the coverage of GHKM and SPMT rules. There are totally 4.26M rules after the low frequency rules are filtered out. The pruning strategy is similar to the cube pruning described in (Chiang, 2007). To achieve acceptable translation speed, the beam size is set to 50 by default. The baseline system is based on the synchronous binarization (Zhang et al., 2006). 4.2 Binarization Schemes Besides the baseline (Zhang et al., 2006) and iterative cost reduction binarization methods, we also perform right-heavy and random synchronous binarizations for comparison. In this paper, the </context>
</contexts>
<marker>Wang, Knight, Marcu, 2007</marker>
<rawString>Wei Wang and Kevin Knight and Daniel Marcu. 2007. Binarizing Syntax Trees to Improve SyntaxBased Machine Translation Accuracy. In Proc. of EMNLP-CoNLL 2007, Prague, Czech Republic, pages: 746-754.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D H Younger</author>
</authors>
<title>Recognition and Parsing of Context-Free Languages</title>
<date>1967</date>
<booktitle>in Time n3. Information and Control,</booktitle>
<pages>10--2</pages>
<contexts>
<context position="1771" citStr="Younger, 1967" startWordPosition="251" endWordPosition="252">Statistical Machine Translation (SMT) systems based on Synchronous Context Free Grammar (SCFG) have been extensively investigated (Chiang, 2005; Galley et al., 2004; Galley et al., 2006) and have achieved state-of-the-art performance. In these systems, machine translation decoding is cast as a synchronous parsing task. Because general SCFG parsing is an NPhard problem (Satta and Peserico, 2005), practical SMT decoders based on SCFG parsing requires an equivalent binary SCFG that is directly learned from training data to achieve polynomial time complexity using the CKY algorithm (Kasami, 1965; Younger, 1967) borrowed from CFG parsing techniques. Zhang et al. (2006) proposed synchronous binarization, a principled method to binarize an SCFG in such a way that both the source-side and target-side virtual non-terminals have contiguous spans. This property of synchronous binarization guarantees the polynomial time complexity of SCFG parsers even when an n-gram language model is integrated, which has been proved to be one of the keys to the success of a string-to-tree syntax-based SMT system. However, as shown by Chiang (2007), SCFGbased decoding with an integrated n-gram language model still has a tim</context>
</contexts>
<marker>Younger, 1967</marker>
<rawString>D. H. Younger. 1967. Recognition and Parsing of Context-Free Languages in Time n3. Information and Control, 10(2):189-208.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Hao Zhang</author>
<author>Liang Huang</author>
<author>Daniel Gildea</author>
<author>Kevin Knight</author>
</authors>
<title>Synchronous Binarization for Machine Translation.</title>
<date>2006</date>
<booktitle>In Proc. of HLT-NAACL</booktitle>
<pages>256--263</pages>
<location>New York, USA,</location>
<contexts>
<context position="708" citStr="Zhang et al. (2006)" startWordPosition="86" endWordPosition="89">g+, Jingbo Zhu*, Ming Zhou+ *Natural Language Processing Lab Northeastern University Shenyang, China, 110004 xiaotong@mail.neu.edu.cn zhujingbo@mail.neu.edu.cn +Microsoft Research Asia Sigma Center Beijing, China, 100080 muli@microsoft.com dozhang@microsoft.com mingzhou@microsoft.com Abstract Binarization of Synchronous Context Free Grammars (SCFG) is essential for achieving polynomial time complexity of decoding for SCFG parsing based machine translation systems. In this paper, we first investigate the excess edge competition issue caused by a leftheavy binary SCFG derived with the method of Zhang et al. (2006). Then we propose a new binarization method to mitigate the problem by exploring other alternative equivalent binary SCFGs. We present an algorithm that iteratively improves the resulting binary SCFG, and empirically show that our method can improve a string-to-tree statistical machine translations system based on the synchronous binarization method in Zhang et al. (2006) on the NIST machine translation evaluation tasks. 1 Introduction Recently Statistical Machine Translation (SMT) systems based on Synchronous Context Free Grammar (SCFG) have been extensively investigated (Chiang, 2005; Galley</context>
<context position="2819" citStr="Zhang et al., 2006" startWordPosition="426" endWordPosition="429">to the success of a string-to-tree syntax-based SMT system. However, as shown by Chiang (2007), SCFGbased decoding with an integrated n-gram language model still has a time complexity of e(m3 ITI4(nâˆ’1)), where m is the source sentence length, and ITI is the vocabulary size of the language model. Although it is not exponential in theory, the actual complexity can still be very high in practice. Here is an example extracted from real data. Given the following SCFG rule: VP â€” VB NP ä¼š JJR , VB NP will be JJR we can obtain a set of equivalent binary rules using the synchronous binarization method (Zhang et al., 2006) as follows: VP â€” V1 JJR , V1 JJR V1 â€” VB V2 , VB V2 V2 â€” NP ä¼š , NP will be This binarization is shown with the solid lines as binarization (a) in Figure 1. We can see that binarization (a) requires that â€œNP ä¼šâ€ should be reduced at first. Data analysis shows that â€œNP ä¼šâ€ is a frequent pattern in the training corpus, and there are 874 binary rules of which the source language sides are â€œNP ä¼šâ€. Consequently these binary rules generate a large number of competing edges in the chart when â€œNP ä¼šâ€ is matched in decoding. To reduce the number of edges pro362 Proceedings of the 2009 Conference on Empiri</context>
<context position="4949" citStr="Zhang et al., 2006" startWordPosition="809" endWordPosition="812">to compete with each other to survive from the pruning. Obviously, more competing edges proposed during decoding can lead to a higher risk of making search errors. VP VB NP ä¼š JJR VB NP will be JJR Figure 1: Two different binarizations (a) and (b) of the same SCFG rule distinguished by the solid lines and dashed lines Wr l *V_ IrkR _16-ï¿½ 3M ï¿½ (We hope the situation will be better .) match 874 rules match 62 rules competing edges: 801 competing edges: 57 Figure 2: Edge competitions caused by different binarizations The edge competition problem for SMT decoding is not addressed in previous work (Zhang et al., 2006; Huang, 2007) in which each SCFG rule is binarized in a fixed way. Actually the results of synchronous binarization may not be the only solution. As illustrated in Figure 1, the rule 1 For the case of n-gram language model integration, 2 x (ğ‘› âˆ’ 1) boundary words needs to be examined. can also be binarized as binarization (b) which is shown with the dashed lines. We think that this problem can be alleviated by choosing better binarizations for SMT decoders, since there is generally more than one binarization for a SCFG rule. In our investigation, about 96% rules that need to be binarized have </context>
<context position="6903" citStr="Zhang et al., 2006" startWordPosition="1138" endWordPosition="1141">slation system. We formulate the binarization optimization as a cost reduction process, where the cost is defined as the number of rules sharing a common source-side derivation in an SCFG. We present an algorithm, iterative cost reduction algorithm, to obtain better binarization for the SCFG learnt automatically from the training corpus. It can work with an efficient CKY-style binarizer to search for the lowest-cost binarization. We apply our method into a state-of-the-art string-to-tree SMT system. The experimental results show that our method outperforms the synchronous binarization method (Zhang et al., 2006) with over 0.8 BLEU scores on both NIST 2005 and NIST 2008 Chinese-to-English evaluation data sets. 2 Related Work The problem of binarization originates from the parsing problem in which several binarization methods are studied such as left/right binarization (Charniak et al., 1998; Tsuruoka and Tsujii, 2004) and head binarization (Charniak et al., 2006). Generally, the pruning issue in SMT decoding is unnecessary for the parsing problem, and the accuracy of parsing does not rely on the binarization method heavily. Thus, many efforts on the binarization in parsing are made for the efficiency </context>
<context position="8228" citStr="Zhang et al., 2006" startWordPosition="1351" endWordPosition="1354">ic in the research of syntax-based SMT. A synchronous (b) (a) V, V2 V,&apos; V2&apos; decoding Wr l *V_ NP -,`ï¿½ JJR ï¿½ 363 binarization method is proposed in (Zhang et al., 2006) whose basic idea is to build a left-heavy binary synchronous tree (Shapiro and Stephens, 1991) with a left-to-right shift-reduce algorithm. Target-side binarization is another binarization method which is proposed by Huang (2007). It works in a left-to-right way on the target language side. Although this method is comparatively easy to be implemented, it just achieves the same performance as the synchronous binarization method (Zhang et al., 2006) for syntaxbased SMT systems. In addition, it cannot be easily integrated into the decoding of some syntax-based models (Galley et al., 2004; Marcu et al., 2006), because it does not guarantee contiguous spans on the source language side. 3 Synchronous Binarization Optimization by Cost Reduction As discussed in Section 1, binarizing an SCFG in a fixed (left-heavy) way (Zhang et al., 2006) may lead to a large number of competing edges and consequently high risk of making search errors. Fortunately, in most cases a binarizable SCFG can be binarized in different ways, which provides us with an op</context>
<context position="18021" citStr="Zhang et al., 2006" startWordPosition="3305" endWordPosition="3308">VB NP ä¼š VB NP ä¼š 10 6619 NP ä¼š 874 c=0 c=0 c=0 c=0 2 NP ä¼š JJR ä¼š JJR 62 VB NP ä¼š JJR 1 Table 1: Sub-sequences and corresponding costs Figure 4 shows an example of the compact forest the algorithm builds, where the solid lines indicate the optimal binarization of the rule, while other alternatives pruned by dynamic programming are shown in dashed lines. The costs for binarization trees are computed based on the cost table given in Table 1. The time complexity of the CKY-based binarization algorithm is Î˜(n3), which is higher than that of the linear binarization such as the synchronous binarization (Zhang et al., 2006). But it is still efficient enough in practice, as there are generally only a few tokens (n &lt; 5) on the source-sides of SCFG rules. In our experiments, the linear binarization method is just 2 times faster than the CKY-based binarization. 3.4 Iterative Cost Reduction However, ğ‘„ (âˆ™) cannot be easily predetermined in a static way as is assumed in Section 3.3 because it depends on ğºâ€² and should be updated whenever a rule in ğº is binarized differently. In our work this problem is solved using the iterative cost reduction algorithm, in which the update of ğºâ€² and the cost function ğ‘„ (âˆ™) are coupled </context>
<context position="19275" citStr="Zhang et al., 2006" startWordPosition="3555" endWordPosition="3558">algorithm Input: An SCFG ğº Output: An equivalent binary SCFG ğºâ€² of ğº 1: Function ITERATIVECOSTREDUCTION(ğº) 2: ğºâ€² â† ğº0 3: for each ğ‘£ âˆˆ ğº0do 4: ğ‘„(ğ‘£) = ğ‘† ğ‘£, ğº0 5: while ğ‘„ (ğºâ€²) does not converge do 6: for each ğ‘…ğ‘– âˆˆ ğº do 7: ğº[âˆ’ğ‘…ğ‘–] â† ğºâ€² âˆ’ â„¬(ğ‘…ğ‘–) 8: for each ğ‘£ âˆˆ â„¬(ğ‘…ğ‘–) do 9: for each ğ‘£â€² âˆˆ ğ‘† ğ‘£, ğºâ€² do 10: ğ‘„ ğ‘£â€² â† ğ‘„ ğ‘£â€² âˆ’ 1 11: â„¬(ğ‘…ğ‘–) â† CKYBINARIZATION(ğ‘…ğ‘–, ğ‘„) 12: ğºâ€² â† ğº[âˆ’ğ‘…ğ‘–] âˆª â„¬(ğ‘…ğ‘–) 13: for each ğ‘£ âˆˆ â„¬(ğ‘…ğ‘–) do 14: for each ğ‘£â€² âˆˆ ğ‘† ğ‘£, ğºâ€² do 15: ğ‘„ ğ‘£â€² â† ğ‘„ ğ‘£â€² + 1 16: return ğºâ€² In the iterative cost reduction algorithm, we first obtain an initial binary SCFG ğº0 using the synchronous binarization method proposed in (Zhang et al., 2006). Then ğº0 is assigned to an iterative variable ğºâ€². The cost of each binary rule in ğº0 is computed based on ğº0 according to Equation (1) (lines 3-4 in the algorithm). After initialization, ğºâ€² is updated by iteratively finding better binarization for each rule in ğº. The basic idea is: for each ğ‘…ğ‘– in ğº, we remove the current binarization result for ğ‘…ğ‘– from ğºâ€² (line 7), while the cost function ğ‘„(âˆ™) is updated accordingly since the removal of binary rule ğ‘£ âˆˆ â„¬(ğ‘…ğ‘–) results in the reduction of the size of the corresponding bucket ğ‘† ğ‘£, ğºâ€² . Lines 8-10 imVP c=65 c=6682 lowest cost c=885 V[1,3] V[2,4] c</context>
<context position="22936" citStr="Zhang et al., 2006" startWordPosition="4196" endWordPosition="4199">s are extracted from the training corpus, and the composed rules are generated by combining two or three minimal GHKM and SPMT rules. Before the rule extraction, we also binarize the parse trees on the English side using Wang et al. (2007) â€s method to increase the coverage of GHKM and SPMT rules. There are totally 4.26M rules after the low frequency rules are filtered out. The pruning strategy is similar to the cube pruning described in (Chiang, 2007). To achieve acceptable translation speed, the beam size is set to 50 by default. The baseline system is based on the synchronous binarization (Zhang et al., 2006). 4.2 Binarization Schemes Besides the baseline (Zhang et al., 2006) and iterative cost reduction binarization methods, we also perform right-heavy and random synchronous binarizations for comparison. In this paper, the random synchronous binarization is obtained by: 1) performing the CKY binarization to build the binarization forest for an SCFG rule; then 2) performing a top-down traversal of the forest. In the traversal, we randomly pick a feasible binarization for each span, and then go on the traversal in the two branches of the picked binarization. Table 2 shows the costs of resulting bin</context>
</contexts>
<marker>Zhang, Huang, Gildea, Knight, 2006</marker>
<rawString>Hao Zhang, Liang Huang, Daniel Gildea, and Kevin Knight. 2006. Synchronous Binarization for Machine Translation. In Proc. of HLT-NAACL 2006, New York, USA, pages: 256- 263.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>