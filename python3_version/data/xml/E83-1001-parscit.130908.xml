<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000002">
<sectionHeader confidence="0.4666985" genericHeader="abstract">
ABSTRACT CONTROL STRUCTURES
AND THE SEMANTICS OF QUANTIFIERS
</sectionHeader>
<author confidence="0.5653">
Steven Cushing
</author>
<affiliation confidence="0.794158">
Computer. Science Department
</affiliation>
<address confidence="0.637014">
St. Anselm College
Manchester, New Hampshire, 03102 USA
</address>
<email confidence="0.77342">
ABSTRACT
</email>
<bodyText confidence="0.999787344827586">
Intuitively, a quantifier is any word or
phrase that expresses a meaning that answers one of
the questions &amp;quot;How many?&amp;quot; or &amp;quot;How much?&amp;quot; Typical
English examples include all, no, many, few, some
but not many, all but at most a very few, wherever,
whoever, whoever there is, and also, it can be
argued, only (Keenan, 1971), also (Cushing, 1978b),
and the (Chomsky, 1977). In this paper we review
an empirically motivated analysis of such meanings
(Cushing, 1976; 1982a) and draw out its computa-
tional significance. For purposes of illustration,
we focus our attention on the meanings expressed by
the English words whatever and some, commonly
represented, respectively, by the symbols &amp;quot;V&amp;quot; and
&amp;quot;3&amp;quot;, but most of what we say will generalize to the
other meanings of this class.
In Section 1, we review the notion of satis-
faction in a model, through which logical formulas
are customarily imbued implicitly with meaning. In
Section 2, we discuss quantifier relativization, a
notion that becomes important for meanings other
than V and 3. In Section 3, we use these two
notions to characterize quantifier meanings as
structured functions of a certain sort. In
Section 4, we discuss the computational signifi-
cance of that analysis. In Section 5, we elaborate
on this significance by outlining a notion of
abstract control structure that the analysis
instantiates.
</bodyText>
<sectionHeader confidence="0.8862" genericHeader="introduction">
/ MODELS AND SATISFACTION
</sectionHeader>
<bodyText confidence="0.979380735849057">
Given a semantic representation language L
containing predicate constants and individual
constants and variables, an interpretation I of L
is a triple &lt;D, R, {f}â€º, where D is a set of
Individuals, the domain of I; R is a function, the
interpretation function of I, that assigns members
of D to individual constants in L and sets of lists
of members of D to predicates in L, the length of a
list being equal to the number of arguments in the
predicate to which it corresponds; and {0 is a set
of functions, the assignment functions of I, that
assign members of D to variables in L. A model M
for L is a pair &lt;D, R&gt;, an interpretation of L
without its assignment functions. Since &amp;quot;a factual
situation comprises a set of individuals bearing
certain relations to each other,&amp;quot; such &amp;quot;a situation
can be represented by a relational structure
21,...&gt;, where D is the set of indivi-
duals in question and R1,.. certain certain rela-
tions on D,&amp;quot; (van Fraassen, 1971, 107), i.e., in
this context, sets of lists of members of D.
Models thus serve intuitively to relate formulas in
L to the factual situations they are intended to
describe by mapping their constants into D and
&lt;R4... .. R ...&gt;. The &amp;quot;variable&amp;quot; character of the
- -4&apos;
symbols assigned values by an f relative to those
interpreted by R is reflected in the fact that a
set of fs corresponds to a fixed &lt;D, R&gt; to comprise
an interpretation.
The distinction between R and f gives us two
different levels on which the satisfaction of
formulas can be defined, i.e., on which formulas in
L can be said to be true or false under I. First,
we define satisfaction relative to an assignment of
values to variables, by formulating statements like
(i)-(vi) of Figure 1, where &amp;quot;M =(A) [f]&amp;quot; is read
as f satisfies A in M or M satisfies A given f.
Given these statements, we can defineB&amp;quot;, read
If A then B, as 11-(B &amp; -,A)&amp;quot;, and we can define
17370117-ieid for some x or there are x, as
&amp;quot;-(V x).,&amp;quot;. Second, we can define satisfaction by a
model, by saying that M satisfies A, written &amp;quot;M
l= (A)&amp;quot;, if M (A) [f] for whatever assignment
functions f there are for M. Intuitively, this can
be read as saying that A is true of the factual
situation that is represented by the relational
structure into which L is interpreted, regardless
of what values are given to variables by the
assignment functions of an interpretation. For
some discussion of the cognitive or psychological
significance of these notions, see Miller (1979a,b)
and Cushing (1983).
</bodyText>
<sectionHeader confidence="0.521113" genericHeader="method">
II SIMPLE AND RELATIVIZED QUANTIFICATION
</sectionHeader>
<bodyText confidence="0.8171536">
Statement (v) of Figure 1 characterizes simple
quantifications like (1), which represent the mean-
ings expressed by sentences like (2), for which
x = &amp;quot;x&amp;quot; and A = (3), while (vi) characterizes
relativized quantifications like (4), which
</bodyText>
<page confidence="0.867077">
1
</page>
<table confidence="0.99558425">
iff (i.e., if and only if) f(xl) = f(x2)
x._))[f] iff
M (A &amp; B) (f] iff M (A)[f] and M (B) (f]
M (- A)[f] iff it is not the case that M (A)[f]
M ((V x) A)[f] iff M (A)[r] for whatever assignments f&apos; for M are like f except perhaps
(i.e., at most) at
M ((V x)(B;A))[f] iff M (A)W] for whatever assignments f&apos; for M are like f except
perhaps at x for which M (B)[fr]
</table>
<figureCaption confidence="0.995609">
Figure 1: Typical Satisfaction Statements for Logical Formulas (adapted from van Fraassen, 1971, 108)
</figureCaption>
<bodyText confidence="0.933566">
represent the meanings expressed by sentences like
(5), for which x and A are as for (2) and B = (6):
</bodyText>
<listItem confidence="0.955492375">
(1) (V x) A
(2) Whatever there is is interesting.
(3) Interesting(x)
(4) (V x)(B;A)
(5) Whatever is linguistic is interesting.
(= Whatever there is that is linguistic
is interesting.)
(6) Linguistic(x)
</listItem>
<bodyText confidence="0.986931769230769">
In general, B and A in (4) are lists of formulas in
L, the relativization formulas and the principal
formulas, respectively, of (4); both lists for (5)
are of length 1, and we will assume lists of that
length for the rest of our discussion.
Given (v) and (vi), the relativized quantifi-
cation (4) is logically equivalent to the simple
quantification (7), reflecting the synonymy of (5)
with (8), for example, but this fact does not
generalize to quantifier meanings other than V,
because there are quantifiers a for which there is
no truth-functional connective c for which (9) is
logically equivalent to (10):
</bodyText>
<listItem confidence="0.9903978">
(7) (V x)(8 A)
(8) Whatever there is, if it is linguistic,
then it is interesting.
(9) (9.&amp;(;&amp;
(10) (2. x)(B c A)
</listItem>
<bodyText confidence="0.984196666666667">
For a formal proof of this important fact, see
Cushing (1976; 1982a). The relativized case must
thus be considered separately from the simple one,
despite its apparent superfluity in the case of V,
which suffices for our purposes (with 3) in all
other respects.
</bodyText>
<sectionHeader confidence="0.672042" genericHeader="method">
III QUANTIFIER MEANINGS AS STRUCTURED FUNCTIONS
</sectionHeader>
<bodyText confidence="0.9981804">
Statement (vi) characterizes the meaning ex-
pressed by (4) implicitly, by stating the condi-
tions under which (4) can be said to be either true
or false; in general, other &amp;quot;truth values&amp;quot; are also
required for natural language (Cushing, 1982a;
1983), but we will not discuss those cases here.
Given (vi), we can characterize the meaning
expressed by (4) explicitly as a function, (11),
that generates a truth value u from M, f, x, B, and
A:
</bodyText>
<listItem confidence="0.585196">
(11) u = V(M,f,x,B,A)
</listItem>
<bodyText confidence="0.999589888888889">
If we let a* be the function that maps a predicate
in L to its extension relative to M, f, and x
e the subset of D whose members make that
predicate satisfied by M given f when assigned
individually as values to x --, then we can replace
the English clause on the right-hand side of the
&amp;quot;iff&amp;quot; in (vi) with the equivalent set-theoretic
formulation (12), and thus (vi) itself with the
equivalent statement (13):
</bodyText>
<listItem confidence="0.815994">
(12) D n a*(M,f,x,B) a*(M,f,x,A)
(13) M (V x)(B;A)[f]
</listItem>
<bodyText confidence="0.968167857142857">
iff D n a*(M,f,x,B)
In other words, (4) is true if and only if the
intersection of D with the extension of B is wholly
contained as a subset in the extension of A. D is
omitted from the right-hand side of the &amp;quot; c &amp;quot; in
(12) for more general reasons that need not concern
us here.
Letting ai, 1=0,1,2, be set variables, we can
abstract away &apos;From the sets in (12) to get the re-
lation -- i.e., in this context, boolean-valued
function -- (14), which can be factored into more
basic component set-theoretic relations as shown in
(15), in which the superscripts and subscripts
indicate which argument places a relation is to be
</bodyText>
<page confidence="0.941645">
2
</page>
<bodyText confidence="0.860898">
applied to, when the steps in the derivation are
reversed:
</bodyText>
<equation confidence="0.9431535">
(14) 20 n 24 E2
(15) n 24 _s a2
2
S1 (20 n &apos;A2)
2 2
n 1) (lo&apos;Ai&apos;12)
</equation>
<bodyText confidence="0.996110333333333">
Finally, dropping the arguments ai from the last
line of (15), we get the quantificaTional relation,
py, expressed by V, as shown in (16):
</bodyText>
<equation confidence="0.979398666666667">
2 2
(16) P =- &apos; n )
V 41
</equation>
<bodyText confidence="0.987121069767442">
The function (11), the meaning expressed by
(4), thus consists of instances of two other
functions: a*, which generates sets from models,
assignments, and predicates; and py, which gener-
ates truth values from sets; all related as in
Figure 2. Strictly speaking, the left-most in-
stance of a* is really a different function --
viz., the three-input function a*( â€ž
rather than the four-input function a*( â€ž , )
since true is a constant that must occur there, but
this technicality need not worry us here. Each
function in Figure 2 provides the same mapping as
is provided collectively by the lower-level
functions to which it is connected. &amp;quot;Select sets&amp;quot;,
for example, is a mnemonic dummy-name for the
function that consists of the three indicated
instances of a*, through which these three inde-
pendent instances interface with py. The effect of
V, in turn, is achieved by applying pv to whatever
three sets are provided to it by Select-sets. Like
Select-sets, pv can also be further decomposed into
subfunctions, as shown in Figure 3, which reflects
the structure of (15). The important point here is
not the tree notation per se, but the fact that a
functional hierarchy is involved, of the indicated
sort. Any other notation that is capable of ex-
pressing the relevant relationships would be just
as -- in certain respects, more (Cushing, 1982a,
Figures 10 and 11) -- adequate for our purpose.
For some general discussion of meanings as struc-
tured functions, see Cushing (1979a).
The two immediate subfunctions of V differ in
one key respect, namely, in that Select-sets has
nothing to do specifically with V, but would be
required in the analysis of any quantifier meaning;
everything that is peculiar to V is encoded en-
tirely in pv. An analysis of 3, for example, can
be obtained by simply replacing pv in Figure 2 with
an appropriate p3, viz., the one in (17), in which
Comp is a function that take the complement of a
set -- i.e., those members of D that are not in the
set --, and Pair is a function that duplicates its
input:
</bodyText>
<equation confidence="0.7153355">
2 1 4 1
(17) p = (01&apos;Comp1, n 2,Pair1)
</equation>
<page confidence="0.466969">
3
</page>
<bodyText confidence="0.9917225">
This relation unravels to exactly the correct truth
condition and satisfaction statement for relati-
vized 3, just as (16) does for V.
In the general case, we also have to include a
third subfunction, Ha, which generates a numerical
parameter, as indicated in Figure 4. The function
</bodyText>
<equation confidence="0.9937234">
u = V(M,f,x,B,A)
u = p (a a a )
20 = a*(M,f,x,true)
Select-sets(M,f,x,B,A)
al = a*(M,f,x,B) a2 = a*(M,f,x,A)
</equation>
<figureCaption confidence="0.993409">
Figure 2: Functional Decomposition of Relativized V
</figureCaption>
<figure confidence="0.9880265">
Pv(10,Apa2)
u =2(a a 1)
</figure>
<figureCaption confidence="0.99859">
Figure 3: Functional Decomposition of the Quantificational Relation Expressed by Relativized V
</figureCaption>
<page confidence="0.686768">
3
</page>
<figure confidence="0.998692111111111">
u = R(M,f,x,B,A)
B,A)
Select-sets
and-parameter (14,f,B
a ,a1,a2,2)
(a a a )
-0&apos; -/
Select-sets(M,f,x,B,A)
= a*(M,f,x,true)
</figure>
<figureCaption confidence="0.994039">
Figure 4: Functional Decomposition of the General Relativized Quantifier Meaning
</figureCaption>
<figure confidence="0.961736875">
PQ Select-sets-and-parameter
(characteristic of Q:
predication property Select-sets nQ
(characteristic of Q:
irreducibility property,
in certain cases)
(independent of St:
binding property)
</figure>
<figureCaption confidence="0.646244125">
Figure 5: Relationships Among Quantifier Meaning Subfunctions and the Properties They Explicate
Select-sets -- more precisely, its a* subfunctions
-- explicates the binding, property common to all
quantifier meanings, because it characterizes the
extensions of predicates (via a*) by removing the
relevant variable from the purview of the assign-
ment, as can be seen clearly in statement (vi) of
Figure 1. The function pa, the quantifications&apos;
</figureCaption>
<bodyText confidence="0.998039857142857">
relation expressed by a, explicates the predication
property of quantifier meanings, by virtue (pri-
marily) of which different quantifier meanings are
distinguished. Its quantificational relation is
what a quantifier predicates; the extensions of the
predicates it is applied to are what it predicates
that of. The intuition that quantifiers are in
some sense predicational is thus explained, even
though the notion that they are &amp;quot;higher predicates&amp;quot;
in a syntactic sense has long since failed the test
of empirical verification. The function II, is what
underlies the irreducibility property of certain
quantifier meanings, by virtue of which (9) is not
logically equivalent to (10). Like p , 2 is
</bodyText>
<page confidence="0.849613">
2
</page>
<bodyText confidence="0.9955572">
specifically characteristic of a. For present pur-
poses, we can consider it to be null in the case of
V and 3. The relationship of these functions to
the quantifier meanings they decompose is indicated
schematically in Figure 5.
</bodyText>
<sectionHeader confidence="0.974165" genericHeader="method">
IV COMPUTATIONAL SIGNIFICANCE
</sectionHeader>
<bodyText confidence="0.996728227272727">
It must be stressed in the strongest possible
terms that the motivation for the analysis embodied
in Figure 4 has absolutely nothing at all to do
with computational considerations of any sort.
Computational relevance need not imply linguistic
or cognitive relevance, any more than mathematical
relevance does, and vice versa. See Cushing
(1979b) and Berwick and Weinberg (1982) for
relevant argumentation. On the contrary, the
analysis is motivated by a wide range of linguistic
and psychological considerations that is too
extensive to review here. See Cushing (1982a) for
the full argument. The analysis does have
computational significance, however, which follows
post facto from its form and consists in the fact
that functional hierarchies of exactly the sort it
exemplifies can be seen to make up the computa-
tional systems that are expressed by computer pro-
grams.
If we take a program like the one in Figure 6,
for example, and ask what functions --
mathematical mappings with no side effects -- it
</bodyText>
<page confidence="0.993152">
4
</page>
<bodyText confidence="0.9768935">
involves, we can answer immediately with the list
in (18):
</bodyText>
<equation confidence="0.971748">
(18) (i) y = x + 2
</equation>
<bodyText confidence="0.995762666666667">
Second, there is the boolean-valued function in
(20), which also appears in Figure 6, but with no
indication as to its functional character:
</bodyText>
<equation confidence="0.8793918">
(ii) z&apos; .râ€¢ (y + x)2
(iii) z
(iv) a&apos; &apos; (Y
(v) z = -z&apos;2
(vi) w = z - 1
</equation>
<bodyText confidence="0.948365222222222">
More significantly, there is a set of
functions that are entirely implicit in Figure 6.
2&apos; Since (19) generates a value of s from a value of
- x) y, and (20) generates a value of b from that value
of s, there is an implicit function -- call it Fl
-- that is defined by that interaction, generating
that value of b from that value of y, as indicated
in (21):
(20) b = &lt;(s,.5)
There is a function that gets a value for y by
adding 2 to the value of x, a function that gets a
value for z&apos; by squaring the sum of the values of x
and y, and so on. Closer examination reveals,
however, that there is an even larger number of
other functions that must be recognized as being
involved in Figure 6. First, there is the function
in (19), which does appear explicitly in Figure 6,
but without an explicit output variable:
</bodyText>
<equation confidence="0.993855666666667">
(19) s = sin(y)
(21) b F,(y)
b = &lt;(s,.5) = sin(y)
</equation>
<bodyText confidence="0.999969">
Similarly, since (18)(ii) and (iv) generate values
of z&apos; independently from values of x and y, and
these are then taken by (18)(iii) and (v),
respectively, to generate values of z, there are
two further implicit functions -- call them F4 and
</bodyText>
<equation confidence="0.947167714285714">
BEGIN y = x + 2;
IF sin r &lt;.5 THEN z&apos; = (y + x) ** 2;
z = z&apos; ** 2;
ELSE z&apos; = (y - x) ** 2;
z = -(z&apos; ** 2);
w = z - 1;
END;
</equation>
<figureCaption confidence="0.999994">
Figure 6: A Simple Sample Program
Figure 7: Functional Hierarchy Expressed by the Program in Figure 6.
</figureCaption>
<page confidence="0.815322">
5
</page>
<bodyText confidence="0.9351215">
F5 -- that are defined by these interactions, as
shown in (22) and (23):
</bodyText>
<equation confidence="0.972112666666667">
(23) z F,(x,y)
,2 2
z = -z z&apos; (y - x)
</equation>
<bodyText confidence="0.999111552631579">
Since F4 and F5 generate different values, in
general, for z for the same values of x and y, they
interact, in turn, to define a &amp;quot;choice&amp;quot; function --
call it F3 -- with its alternatives determined, in
this case, by the value of b, as indicated in (24):
Continuing in this way, we can extract two further
functions: F2&apos; which consists of the composition
of (18vi) and F3&apos; â€¢ and F0&apos; which consists of the
composition of F2, Fl, and (181) and defines the
overall function effected by the program, as shown
in Figure 7.
The variables in Figure 6 are strictly
numerical only for the sake of illustration. As we
have just seen, even in this case, extracting the
implicit functional hierarchy expressed by the
program requires the introduction of a non-
numerical -- viz., boolean-valued -- variable. In
general, variables in a program can be taken to
range over any data type at all -- i.e., any kind
of object to be processed --, as long as it can be
provided with an appropriate implementation, and
the same is therefore true, as well, of its
implicit functional hierarchy. For an extensive
list of references on abstract data types, see
Kapur (1980); for some discussion of their com-
plementary relationship with the functional
hierarchies expressed by programs, see Cushing
(1978a; 1980).
variables that range over registers, locations, and
the like, and bottom-node functions that store and
retrieve data, and so on, just as Figure 4 has
bottom-node functions that assign extensions to
. predicates and form the intersections of sets.
Given implementations of these latter functions,
Figure 4 defines a computational system, just as
much as Figure 7 does, and so can be naturally
implemented in whatever programming language those
implementations are themselves formulated in.
</bodyText>
<sectionHeader confidence="0.991268" genericHeader="method">
V ABSTRACT CONTROL STRUCTURES
AS FUNCTIONAL HIERARCHIES
</sectionHeader>
<bodyText confidence="0.999959958333334">
The control structure indicators -- the words
IF, THEN, ELSE, the semi-colons, the sequential
placement on the page, and so on -- in Figure 6 are
ad hoc syntactic devices that really express
semantic relationships of functional hierarchy,
viz., those shown in Figure 7. In general, we can
identify a control structure with such a functional
hierarchy. For some background discussion relevant
to this notion, see Hamilton and Zeldin (1976). A
control structure can be said to be legitimate, if
its interfaces are correct, i.e., if the sub-
functions do effect the same mappings as the
functions they purportedly decompose. Of the three
structures in Figure 8, for example, only (ii) is
legitimate, because (i) and (iii) each generates a
value of a as a side effect -- a is generated
by a subfunction, but not by the overall function
--, and b in (i) appears from nowhere -- i.e., as
an input to a subfunction, but not as an input to
the overall function, or as an output from another
subfunction on the same level.
Structure (iii) can be made legitimate by
adding a to the output list of its top-most
function, as indicated in (25):
</bodyText>
<equation confidence="0.9778875">
(25) y,a = f(x)
y = g(x) h(x)
</equation>
<bodyText confidence="0.996563833333333">
This structure represents one sort of parallel
process, in which two functions operate in-
dependently on the same input variable to generate
values for different output variables. Structure
(i) can be made legitimate by adding a to the
output list of its top-most function, as in the
</bodyText>
<equation confidence="0.9989845">
(24)
(b = False)
z = F5(x,y)
z = F4(x&apos;y)
F3(x&apos;y,b)
(b = True)
</equation>
<bodyText confidence="0.9995095">
The hierarchy expressed by an assembly
language program, for example, might well involve
</bodyText>
<equation confidence="0.9803345">
f(x) y= f(x)
y = g(b) a = h(x) y= g(a) a = h(x)
</equation>
<figureCaption confidence="0.995504">
Figure 8: Three Possible Control Structures
</figureCaption>
<page confidence="0.997965">
6
</page>
<bodyText confidence="0.974593">
case of (iii), and also adding b to that function&apos;s
input list, as indicated in (26):
</bodyText>
<equation confidence="0.994683">
(26) y,a = f(b,x)
y = g(b) a = h(x)
</equation>
<bodyText confidence="0.929382107692308">
This structure represents a different sort of
parallel process, in which two functions operate
independently on different input variables to
generate values for different output variables.
Structure (ii) represents a non-parallel,
sequential process in which two functions operate
dependently, one generating a value for an output
variable that is used by the other as an input
variable.
In general, the variables in these structures
can be interpreted as really representing lists of
variables, just as &amp;quot;B&amp;quot; and &amp;quot;A&amp;quot; in (4) can be
interpreted as representing lists of predicates.
Of these three legitimate structures, then, only
(ii) can be seen as occurring in Figure 7.
Figure 4 also contains a different structure (for
Select-sets) that combines the features of (25) and
(26).
The important point here is that functional
hierarchies comprising legitimate control struc-
tures are inherent in the systems expressed by
workable programs. As such, they have proven
useful both as a verification tool and as a
programming tool. For some discussion of the
relationship that ought to exist, ideally, between
these two different modes of application, see
Hamilton and Zeldin (1979).
Through interaction with those who have
written an existing program, one can derive the
abstract control structure of the system expressed
by the program, make that structure legitimate, and
then make the corresponding changes in the original
program. In this way, subtle but substantial
errors can be exposed and corrected that might not
be readily revealed by more conventional debugging
techniques.
Conversely, given a legitimate control struc-
ture -- such as the one for quantifier meanings in
Figure 4, for example --, the system it comprises
can be implemented in any convenient programming
language -- essentially, by reversing the process
through which we derived Figure 7 from Figure 6,
adapted to the relevant language. For some dis-
cussion of software that automates this process,
see Cushing (1982b) and Wasserman and Gutz (1982).
For a good description of the vision that motivates
the development of this software -- i.e., the ideal
situation toward which its development is directed
--, see Hamilton and Zeldin (1983). Our present
concerns are primarily theoretical and thus do not
require the ultimate perfection of this or any
other software.
A number of interesting variants have been
proposed to make this notion of control structure
applicable to a wider class of programs. See
Martin (1982), for example, for an attempt to
integrate it with more traditional data base
notions. Harel (1979) introduces non-determinacy,
and Prade and Vaina (1980) attempt to incorporate
concepts from the theory of fuzzy sets and systems.
Further development of the latter of these efforts
would be of particular interest in our present
context, in view of work done by Zadeh (1977), for
example, to explicate quantifier and other meanings
in terms of fuzzy logic.
</bodyText>
<sectionHeader confidence="0.986936" genericHeader="acknowledgments">
ACKNOWLEDGEMENTS
</sectionHeader>
<bodyText confidence="0.967295">
I would like to thank Fred Barrett, Mitka
Golub, and Robert Kuhns for helpful comments on an
earlier draft, and Margaret Moore for typing the
final manuscript.
</bodyText>
<sectionHeader confidence="0.991111" genericHeader="references">
REFERENCES
</sectionHeader>
<reference confidence="0.99911990625">
Berwick, Robert C. and Amy S. Weinberg. 1982.
&amp;quot;Parsing Efficiency, Computational Complexity,
and the Evaluation of Grammatical Theories.&amp;quot;
Linguistic Inquiry. 13:165-191.
Chomsky, Noam. 1977. Essays on Form and Inter-
pretation. New York: North-Holland.
Cushing, Steven. 1976. &amp;quot;The Formal Semantics of
Quantification.&amp;quot; UCLA doctoral dissertation.
Ann Arbor, Michigan: University Microfilms.
. 1978a. &amp;quot;Algebraic Specification of Data
Types in Higher Order Software.&amp;quot; Proceedings,
.Eleventh Annual Hawaii International Conference
on System Sciences. Honolulu, Hawaii.
. 1978b. &amp;quot;Not Only Only, But Also Also.&amp;quot;
Linguistic Inquiry. 9:127-132.
. 1979a. &amp;quot;Lexical Functions and Lexical
Decompositibn: An Algebraic Approach to Lexical
Meaning.&amp;quot; Linguistic Inquiry. 10:327-345.
. 1979b. &amp;quot;Semantic Considerations in Natural
Language: Crosslinguistic Evidence and Morpho-
logical Motivation.&amp;quot; Studies in Language. 3:181-
201.
. 1980. &amp;quot;Software Security and How to Handle
It.&amp;quot; Chapter 4 of Advances in Computer Security
Management, Volume 1. Rullo, Thomas A. (ed.).
Philadelphia: Heyden &amp; Son.
. 1982a. Quantifier Meanings: A Study in
the Dimensions of Semantic Competence. North-
Holland Linguistic Series, Volume 48. Amsterdam:
North-Holland.
. 1982b. Letter to ACM Forum. Communi-
cations of the ACM. 25:951.
</reference>
<page confidence="0.990147">
7
</page>
<reference confidence="0.997604510638298">
. 1983. &amp;quot;Dynamic Model Selection in the In-
terpretation of Discourse.&amp;quot; In Cognitive Con-
straints on Communication: Representations and
Processes. Vaina, Lucia and Jaakko Hintikka
(eds.). Dordrecht: Reidel.
van Fraassen, Bas C. 1971. Formal Semantics and
Logic. New York: Macmillan.
Hamilton, Margaret and Saydean Zeldin. 1976.
&amp;quot;Higher Order Software -- A Methodology for
Defining Software.&amp;quot; IEEE Transactions on
Software Engineering. SE-2:9-32.
71113112j=lio:IshgmtraD=Wa::d
&amp;quot;The Functional Life Cycle and Its
Journal of Systems and Software.
Harel, David. 1979. &amp;quot;And/Or Programs: A New
Approach to Structured Programming.&amp;quot; Specifi-
cations of Reliable Software. IEEE Catalog No.
79 CH1401-9C.
Kapur, Deepak. 1980. &amp;quot;Towards a Theory for
Abstract Data Types.&amp;quot; TR-237. Laboratory for
Computer Science. Massachusetts Institute of
Technology.
Keenan, Edward L. 1971. &amp;quot;Quantifier Structures in
English.&amp;quot; Foundations of Language. 7:255-284.
Martin, James. 1982. Program Design Which Is
Provably Correct. Carnforth, England: Savant In-
stitute.
Miller, George A. 1979a. &amp;quot;Construction and
Selection in the Mental Representation of Text.&amp;quot;
Cahiers de l&apos;Institut de Linguistique de Louvain.
5:185-197.
. 1979b. &amp;quot;Images and Models, Similes and
Metaphors.&amp;quot; In Metaphor and Thought. Ortony,
Andrew (ed.). Cambridge: Cambridge University
Press.
Prade, Henri and Lucia Vaina. 1980. &amp;quot;What &apos;Fuzzy
HOS&apos; May Mean.&amp;quot; Proceedings, Fourth Interna-
tional Computer Software and Applications Con-
ference. IEEE Catalog No. 80 CH1607-1.
Wasserman, Anthony I. and Steven Gutz. Reply to
Letters to ACM Forum. Communications of the ACM.
25:951-2.
Zadeh, Lotfi A. 1977. &amp;quot;PRUF - A Language for the
Representation of Meaning in Natural Languages.&amp;quot;
Proceedings, Fifth International Joint Conference
on Artificial Intelligence, Volume 2. Cambridge,
Massachusetts.
</reference>
<figure confidence="0.995567166666667">
1979.
Verification.
1:29-56.
. 1983.
Automation.&amp;quot;
3:25-62.
</figure>
<page confidence="0.955585">
8
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.082205">
<title confidence="0.9995075">ABSTRACT CONTROL STRUCTURES AND THE SEMANTICS OF QUANTIFIERS</title>
<author confidence="0.999794">Steven Cushing</author>
<affiliation confidence="0.8478835">Science Department St. Anselm College</affiliation>
<address confidence="0.999175">Manchester, New Hampshire, 03102 USA</address>
<abstract confidence="0.979677010526316">a quantifieris any word or phrase that expresses a meaning that answers one of the questions &amp;quot;How many?&amp;quot; or &amp;quot;How much?&amp;quot; Typical examples include all, no, many,few, some not many,all but at most a veryfew, whoeverthere is, and also, it can be only(Keenan, 1971), also (Cushing, 1978b), and the (Chomsky, 1977). In this paper we review an empirically motivated analysis of such meanings (Cushing, 1976; 1982a) and draw out its computational significance. For purposes of illustration, we focus our attention on the meanings expressed by English words whateverand some, commonly represented, respectively, by the symbols &amp;quot;V&amp;quot; and &amp;quot;3&amp;quot;, but most of what we say will generalize to the other meanings of this class. In Section 1, we review the notion of satisfaction in a model, through which logical formulas are customarily imbued implicitly with meaning. In Section 2, we discuss quantifier relativization, a notion that becomes important for meanings other than V and 3. In Section 3, we use these two notions to characterize quantifier meanings as structured functions of a certain sort. In Section 4, we discuss the computational significance of that analysis. In Section 5, we elaborate on this significance by outlining a notion of abstract control structure that the analysis instantiates. / MODELS AND SATISFACTION Given a semantic representation language L containing predicate constants and individual and variables, an interpretationI of L is a triple &lt;D, R, {f}â€º, where D is a set of the domainof I; R is a function, the functionof I, that assigns members D to individual constants in sets of lists of members of D to predicates in L, the length of a list being equal to the number of arguments in the predicate to which it corresponds; and {0 is a set functions, the functionsof I, that members of D to variables in modelM a pair &lt;D, R&gt;, an interpretation of L without its assignment functions. Since &amp;quot;a factual situation comprises a set of individuals bearing certain relations to each other,&amp;quot; such &amp;quot;a situation can be represented by a relational structure where D is the set of indiviin question and certain certain relations on D,&amp;quot; (van Fraassen, 1971, 107), i.e., in this context, sets of lists of members of D. Models thus serve intuitively to relate formulas in the factual situations they are intended to describe by mapping their constants into D and .. R ...&gt;. The &amp;quot;variable&amp;quot; character - -4&apos; symbols assigned values by an f relative to those interpreted by R is reflected in the fact that a set of fs corresponds to a fixed &lt;D, R&gt; to comprise an interpretation. The distinction between R and f gives us two levels on which the satisfactionof formulas can be defined, i.e., on which formulas in L can be said to be true or false under I. First, we define satisfaction relative to an assignment of values to variables, by formulating statements like (i)-(vi) of Figure 1, where &amp;quot;M =(A) [f]&amp;quot; is read f satisfiesA in M or M satisfies A given f. Given these statements, we can defineB&amp;quot;, read A then B, as &amp; and we can define for some x or there are x, as &amp;quot;-(V x).,&amp;quot;. Second, we can define satisfaction by a by saying that M satisfiesA, written &amp;quot;M l= (A)&amp;quot;, if M (A) [f] for whatever assignment functions f there are for M. Intuitively, this can be read as saying that A is true of the factual situation that is represented by the relational structure into which L is interpreted, regardless of what values are given to variables by the assignment functions of an interpretation. For discussion of the cognitiveor of these notions, (1979a,b) and Cushing (1983). II SIMPLE AND RELATIVIZED QUANTIFICATION (v) of Figure 1 characterizes quantificationslike (1), which represent the meanings expressed by sentences like (2), for which x = &amp;quot;x&amp;quot; and A = (3), while (vi) characterizes quantificationslike (4), which 1 and only if) = iff M (A &amp; B) (f] iff M (A)[f] and M (B) (f] M (- A)[f] iff it is not the case that M (A)[f] M ((V x) A)[f] iff M (A)[r] for whatever assignments f&apos; for M are like f except perhaps (i.e., at most) at M ((V x)(B;A))[f] iff M (A)W] for whatever assignments f&apos; for M are like f except at x for which M Figure 1: Typical Satisfaction Statements for Logical Formulas (adapted from van Fraassen, 1971, 108) represent the meanings expressed by sentences like (5), for which x and A are as for (2) and B = (6): (1) (V x) A (2) Whatever there is is interesting. (3) Interesting(x) (4) (V x)(B;A) (5) Whatever is linguistic is interesting. (= Whatever there is that is linguistic is interesting.) (6) Linguistic(x) In general, B and A in (4) are lists of formulas in the formulasand the formulas,respectively, of (4); both lists for (5) are of length 1, and we will assume lists of that length for the rest of our discussion. Given (v) and (vi), the relativized quantification (4) is logically equivalent to the simple quantification (7), reflecting the synonymy of (5) with (8), for example, but this fact does not generalize to quantifier meanings other than V, there are quantifiers afor which there is no truth-functional connective c for which (9) is logically equivalent to (10): (7) (V x)(8 A) (8) Whatever there is, if it is linguistic, then it is interesting. (9) (10) x)(B c A) For a formal proof of this important fact, see Cushing (1976; 1982a). The relativized case must thus be considered separately from the simple one, despite its apparent superfluity in the case of V, which suffices for our purposes (with 3) in all other respects. III QUANTIFIER MEANINGS AS STRUCTURED FUNCTIONS Statement (vi) characterizes the meaning expressed by (4) implicitly, by stating the conditions under which (4) can be said to be either true or false; in general, other &amp;quot;truth values&amp;quot; are also required for natural language (Cushing, 1982a; 1983), but we will not discuss those cases here. Given (vi), we can characterize the meaning expressed by (4) explicitly as a function, (11), that generates a truth value u from M, f, x, B, and A: u = V(M,f,x,B,A) If we let a* be the function that maps a predicate L to its extensionrelative to M, f, and x e the subset of D whose members make that predicate satisfied by M given f when assigned individually as values to x --, then we can replace the English clause on the right-hand side of the &amp;quot;iff&amp;quot; in (vi) with the equivalent set-theoretic formulation (12), and thus (vi) itself with the equivalent statement (13): D a*(M,f,x,A) (13) M (V x)(B;A)[f] D In other words, (4) is true if and only if the intersection of D with the extension of B is wholly contained as a subset in the extension of A. D is omitted from the right-hand side of the &amp;quot; c &amp;quot; in (12) for more general reasons that need not concern us here. 1=0,1,2, be set variables, we can abstract away &apos;From the sets in (12) to get the relation -i.e., in this context, boolean-valued function -- (14), which can be factored into more basic component set-theoretic relations as shown in (15), in which the superscripts and subscripts indicate which argument places a relation is to be 2 applied to, when the steps in the derivation are reversed: (14) n E2 n 2 n 2 2 n dropping the arguments from the last of (15), we get the relation, expressed by V, as shown in (16): 2 2 P =- &apos; ) V 41 The function (11), the meaning expressed by (4), thus consists of instances of two other functions: a*, which generates sets from models, and predicates; and which generates truth values from sets; all related as in 2. Strictly speaking, the left-most stance of a* is really a different function -viz., the three-input function a*( â€ž rather than the four-input function a*( â€ž , ) since true is a constant that must occur there, but this technicality need not worry us here. Each function in Figure 2 provides the same mapping as is provided collectively by the lower-level functions to which it is connected. &amp;quot;Select sets&amp;quot;, for example, is a mnemonic dummy-name for the function that consists of the three indicated of which these three indeinstances interface with The effect of in turn, is achieved by applying to whatever three sets are provided to it by Select-sets. Like can also be further decomposed into subfunctions, as shown in Figure 3, which reflects the structure of (15). The important point here is the tree notation perse, but the fact that a hierarchyis involved, of the indicated sort. Any other notation that is capable of expressing the relevant relationships would be just as -in certain respects, more (Cushing, 1982a, Figures 10 and 11) -adequate for our purpose. For some general discussion of meanings as strucfunctions, (1979a). The two immediate subfunctions of V differ in one key respect, namely, in that Select-sets has nothing to do specifically with V, but would be required in the analysis of any quantifier meaning; that is peculiar to V is encoded enin An analysis of 3, for example, can obtained by simply replacing in Figure 2 with appropriate the one in which is a function that take the complementof a set -i.e., those members of D that are not in the set --, and Pair is a function that duplicates its input: 2 1 4 1 p = 3 This relation unravels to exactly the correct truth condition and satisfaction statement for relativized 3, just as (16) does for V. In the general case, we also have to include a subfunction, generates a numerical parameter, as indicated in Figure 4. The function = V(M,f,x,B,A) u = p (a a a ) = a*(M,f,x,true) Select-sets(M,f,x,B,A) = a*(M,f,x,B) = a*(M,f,x,A) Figure 2: Functional Decomposition of Relativized V Figure 3: Functional Decomposition of the Quantificational Relation Expressed by Relativized V 3 = R(M,f,x,B,A) B,A) Select-sets (a a a ) -0&apos; -/ Select-sets(M,f,x,B,A) = a*(M,f,x,true) Figure 4: Functional Decomposition of the General Relativized Quantifier Meaning Select-sets-and-parameter (characteristic of Q: property Select-sets (characteristic of Q: irreducibility property, in certain cases) (independent of St: binding property) Figure 5: Relationships Among Quantifier Meaning Subfunctions and the Properties They Explicate Select-sets -more precisely, its a* subfunctions explicates the binding,property common to all quantifier meanings, because it characterizes the of predicates (via removing the relevant variable from the purview of the assignment, as can be seen clearly in statement (vi) of 1. The function relationexpressed by the property of quantifier meanings, by virtue (primarily) of which different quantifier meanings are distinguished. Its quantificational relation is what a quantifier predicates; the extensions of the predicates it is applied to are what it predicates that of. The intuition that quantifiers are in some sense predicational is thus explained, even though the notion that they are &amp;quot;higher predicates&amp;quot; a syntacticsense has long since failed the test empirical verification. The function what the irreducibilityproperty of certain quantifier meanings, by virtue of which (9) is not equivalent to (10). Like p , 2 characteristic of present purposes, we can consider it to be null in the case of V and 3. The relationship of these functions to the quantifier meanings they decompose is indicated schematically in Figure 5. IV COMPUTATIONAL SIGNIFICANCE It must be stressed in the strongest possible that the motivationfor the analysis embodied in Figure 4 has absolutely nothing at all to do with computational considerations of any sort. Computational relevance need not imply linguistic or cognitive relevance, any more than mathematical relevance does, and vice versa. See Cushing (1979b) and Berwick and Weinberg (1982) for relevant argumentation. On the contrary, the analysis is motivated by a wide range of linguistic and psychological considerations that is too extensive to review here. See Cushing (1982a) for the full argument. The analysis does have significance,however, which follows postfacto from its form and consists in the fact that functional hierarchies of exactly the sort it exemplifies can be seen to make up the computational systems that are expressed by computer programs. If we take a program like the one in Figure 6, example, and ask what functions-mathematical mappings with no side effects -it 4 involves, we can answer immediately with the list in (18): (18) (i) y = x + 2 Second, there is the boolean-valued function in (20), which also appears in Figure 6, but with no indication as to its functional character: z&apos; .râ€¢ (y (iii) z (iv) a&apos; &apos; (Y z = (vi) w = z - 1 More significantly, there is a set of functions that are entirely implicit in Figure 6. 2&apos; Since (19) generates a value of s from a value of x) y, and (20) generates a value of b from that value s, there is an implicit function -call it -that is defined by that interaction, generating that value of b from that value of y, as indicated in (21): (20) b = &lt;(s,.5) There is a function that gets a value for y by adding 2 to the value of x, a function that gets a value for z&apos; by squaring the sum of the values of x and y, and so on. Closer examination reveals, however, that there is an even larger number of other functions that must be recognized as being involved in Figure 6. First, there is the function in (19), which does appear explicitly in Figure 6, but without an explicit output variable: (19) s = sin(y) b b = &lt;(s,.5) = sin(y) Similarly, since (18)(ii) and (iv) generate values of z&apos; independently from values of x and y, and these are then taken by (18)(iii) and (v), respectively, to generate values of z, there are further implicit functions -call them and BEGIN y = x + 2; sin THEN z&apos; = (y + x) ** 2; z = z&apos; ** 2; ELSE z&apos; = (y x) ** 2; z = -(z&apos; ** 2); w = z - 1; END; Figure 6: A Simple Sample Program Figure 7: Functional Hierarchy Expressed by the Program in Figure 6. 5 -that are defined by these interactions, as shown in (22) and (23): (23) z F,(x,y) = -z z&apos; (y x) different values, in general, for z for the same values of x and y, they interact, in turn, to define a &amp;quot;choice&amp;quot; function -it -with its alternatives determined, in this case, by the value of b, as indicated in (24): Continuing in this way, we can extract two further consists of the composition (18vi) and â€¢ and which consists of the of and (181) and defines the overall function effected by the program, as shown in Figure 7. The variables in Figure 6 are strictly numerical only for the sake of illustration. As we have just seen, even in this case, extracting the implicit functional hierarchy expressed by the</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Robert C Berwick</author>
<author>Amy S Weinberg</author>
</authors>
<title>Parsing Efficiency, Computational Complexity, and the Evaluation of Grammatical Theories.&amp;quot; Linguistic Inquiry.</title>
<date>1982</date>
<pages>13--165</pages>
<contexts>
<context position="12757" citStr="Berwick and Weinberg (1982)" startWordPosition="2186" endWordPosition="2189">ally characteristic of a. For present purposes, we can consider it to be null in the case of V and 3. The relationship of these functions to the quantifier meanings they decompose is indicated schematically in Figure 5. IV COMPUTATIONAL SIGNIFICANCE It must be stressed in the strongest possible terms that the motivation for the analysis embodied in Figure 4 has absolutely nothing at all to do with computational considerations of any sort. Computational relevance need not imply linguistic or cognitive relevance, any more than mathematical relevance does, and vice versa. See Cushing (1979b) and Berwick and Weinberg (1982) for relevant argumentation. On the contrary, the analysis is motivated by a wide range of linguistic and psychological considerations that is too extensive to review here. See Cushing (1982a) for the full argument. The analysis does have computational significance, however, which follows post facto from its form and consists in the fact that functional hierarchies of exactly the sort it exemplifies can be seen to make up the computational systems that are expressed by computer programs. If we take a program like the one in Figure 6, for example, and ask what functions -- mathematical mappings</context>
</contexts>
<marker>Berwick, Weinberg, 1982</marker>
<rawString>Berwick, Robert C. and Amy S. Weinberg. 1982. &amp;quot;Parsing Efficiency, Computational Complexity, and the Evaluation of Grammatical Theories.&amp;quot; Linguistic Inquiry. 13:165-191.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Noam Chomsky</author>
</authors>
<date>1977</date>
<booktitle>Essays on Form and Interpretation.</booktitle>
<publisher>North-Holland.</publisher>
<location>New York:</location>
<marker>Chomsky, 1977</marker>
<rawString>Chomsky, Noam. 1977. Essays on Form and Interpretation. New York: North-Holland.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Steven Cushing</author>
</authors>
<title>The Formal Semantics of Quantification.&amp;quot; UCLA doctoral dissertation. Ann Arbor,</title>
<date>1976</date>
<institution>University Microfilms.</institution>
<location>Michigan:</location>
<contexts>
<context position="627" citStr="Cushing, 1976" startWordPosition="97" endWordPosition="98">OL STRUCTURES AND THE SEMANTICS OF QUANTIFIERS Steven Cushing Computer. Science Department St. Anselm College Manchester, New Hampshire, 03102 USA ABSTRACT Intuitively, a quantifier is any word or phrase that expresses a meaning that answers one of the questions &amp;quot;How many?&amp;quot; or &amp;quot;How much?&amp;quot; Typical English examples include all, no, many, few, some but not many, all but at most a very few, wherever, whoever, whoever there is, and also, it can be argued, only (Keenan, 1971), also (Cushing, 1978b), and the (Chomsky, 1977). In this paper we review an empirically motivated analysis of such meanings (Cushing, 1976; 1982a) and draw out its computational significance. For purposes of illustration, we focus our attention on the meanings expressed by the English words whatever and some, commonly represented, respectively, by the symbols &amp;quot;V&amp;quot; and &amp;quot;3&amp;quot;, but most of what we say will generalize to the other meanings of this class. In Section 1, we review the notion of satisfaction in a model, through which logical formulas are customarily imbued implicitly with meaning. In Section 2, we discuss quantifier relativization, a notion that becomes important for meanings other than V and 3. In Section 3, we use these </context>
<context position="5861" citStr="Cushing (1976" startWordPosition="1020" endWordPosition="1021">d we will assume lists of that length for the rest of our discussion. Given (v) and (vi), the relativized quantification (4) is logically equivalent to the simple quantification (7), reflecting the synonymy of (5) with (8), for example, but this fact does not generalize to quantifier meanings other than V, because there are quantifiers a for which there is no truth-functional connective c for which (9) is logically equivalent to (10): (7) (V x)(8 A) (8) Whatever there is, if it is linguistic, then it is interesting. (9) (9.&amp;(;&amp; (10) (2. x)(B c A) For a formal proof of this important fact, see Cushing (1976; 1982a). The relativized case must thus be considered separately from the simple one, despite its apparent superfluity in the case of V, which suffices for our purposes (with 3) in all other respects. III QUANTIFIER MEANINGS AS STRUCTURED FUNCTIONS Statement (vi) characterizes the meaning expressed by (4) implicitly, by stating the conditions under which (4) can be said to be either true or false; in general, other &amp;quot;truth values&amp;quot; are also required for natural language (Cushing, 1982a; 1983), but we will not discuss those cases here. Given (vi), we can characterize the meaning expressed by (4)</context>
</contexts>
<marker>Cushing, 1976</marker>
<rawString>Cushing, Steven. 1976. &amp;quot;The Formal Semantics of Quantification.&amp;quot; UCLA doctoral dissertation. Ann Arbor, Michigan: University Microfilms.</rawString>
</citation>
<citation valid="false">
<authors>
<author>1978a</author>
</authors>
<title>Algebraic Specification of Data Types in Higher Order Software.&amp;quot;</title>
<booktitle>Proceedings, .Eleventh Annual Hawaii International Conference on System Sciences.</booktitle>
<location>Honolulu, Hawaii.</location>
<marker>1978a, </marker>
<rawString>. 1978a. &amp;quot;Algebraic Specification of Data Types in Higher Order Software.&amp;quot; Proceedings, .Eleventh Annual Hawaii International Conference on System Sciences. Honolulu, Hawaii.</rawString>
</citation>
<citation valid="false">
<authors>
<author>1978b</author>
</authors>
<title>Not Only Only, But Also Also.&amp;quot; Linguistic Inquiry.</title>
<pages>9--127</pages>
<marker>1978b, </marker>
<rawString>. 1978b. &amp;quot;Not Only Only, But Also Also.&amp;quot; Linguistic Inquiry. 9:127-132.</rawString>
</citation>
<citation valid="false">
<authors>
<author>1979a</author>
</authors>
<title>Lexical Functions and Lexical Decompositibn: An Algebraic Approach to Lexical Meaning.&amp;quot; Linguistic Inquiry.</title>
<pages>10--327</pages>
<contexts>
<context position="19931" citStr="(1979)" startWordPosition="3468" endWordPosition="3468">redicates. Of these three legitimate structures, then, only (ii) can be seen as occurring in Figure 7. Figure 4 also contains a different structure (for Select-sets) that combines the features of (25) and (26). The important point here is that functional hierarchies comprising legitimate control structures are inherent in the systems expressed by workable programs. As such, they have proven useful both as a verification tool and as a programming tool. For some discussion of the relationship that ought to exist, ideally, between these two different modes of application, see Hamilton and Zeldin (1979). Through interaction with those who have written an existing program, one can derive the abstract control structure of the system expressed by the program, make that structure legitimate, and then make the corresponding changes in the original program. In this way, subtle but substantial errors can be exposed and corrected that might not be readily revealed by more conventional debugging techniques. Conversely, given a legitimate control structure -- such as the one for quantifier meanings in Figure 4, for example --, the system it comprises can be implemented in any convenient programming la</context>
</contexts>
<marker>1979a, </marker>
<rawString>. 1979a. &amp;quot;Lexical Functions and Lexical Decompositibn: An Algebraic Approach to Lexical Meaning.&amp;quot; Linguistic Inquiry. 10:327-345.</rawString>
</citation>
<citation valid="false">
<authors>
<author>1979b</author>
</authors>
<title>Semantic Considerations in Natural Language: Crosslinguistic Evidence and Morphological Motivation.&amp;quot; Studies in Language.</title>
<pages>3--181</pages>
<contexts>
<context position="19931" citStr="(1979)" startWordPosition="3468" endWordPosition="3468">redicates. Of these three legitimate structures, then, only (ii) can be seen as occurring in Figure 7. Figure 4 also contains a different structure (for Select-sets) that combines the features of (25) and (26). The important point here is that functional hierarchies comprising legitimate control structures are inherent in the systems expressed by workable programs. As such, they have proven useful both as a verification tool and as a programming tool. For some discussion of the relationship that ought to exist, ideally, between these two different modes of application, see Hamilton and Zeldin (1979). Through interaction with those who have written an existing program, one can derive the abstract control structure of the system expressed by the program, make that structure legitimate, and then make the corresponding changes in the original program. In this way, subtle but substantial errors can be exposed and corrected that might not be readily revealed by more conventional debugging techniques. Conversely, given a legitimate control structure -- such as the one for quantifier meanings in Figure 4, for example --, the system it comprises can be implemented in any convenient programming la</context>
</contexts>
<marker>1979b, </marker>
<rawString>. 1979b. &amp;quot;Semantic Considerations in Natural Language: Crosslinguistic Evidence and Morphological Motivation.&amp;quot; Studies in Language. 3:181-201.</rawString>
</citation>
<citation valid="true">
<title>Software Security and How to Handle It.&amp;quot;</title>
<date>1980</date>
<journal>Chapter</journal>
<booktitle>of Advances in Computer Security Management,</booktitle>
<volume>4</volume>
<editor>Rullo, Thomas A. (ed.). Philadelphia: Heyden &amp; Son.</editor>
<contexts>
<context position="16262" citStr="(1980)" startWordPosition="2860" endWordPosition="2860">e 6 are strictly numerical only for the sake of illustration. As we have just seen, even in this case, extracting the implicit functional hierarchy expressed by the program requires the introduction of a nonnumerical -- viz., boolean-valued -- variable. In general, variables in a program can be taken to range over any data type at all -- i.e., any kind of object to be processed --, as long as it can be provided with an appropriate implementation, and the same is therefore true, as well, of its implicit functional hierarchy. For an extensive list of references on abstract data types, see Kapur (1980); for some discussion of their complementary relationship with the functional hierarchies expressed by programs, see Cushing (1978a; 1980). variables that range over registers, locations, and the like, and bottom-node functions that store and retrieve data, and so on, just as Figure 4 has bottom-node functions that assign extensions to . predicates and form the intersections of sets. Given implementations of these latter functions, Figure 4 defines a computational system, just as much as Figure 7 does, and so can be naturally implemented in whatever programming language those implementations a</context>
</contexts>
<marker>1980</marker>
<rawString>. 1980. &amp;quot;Software Security and How to Handle It.&amp;quot; Chapter 4 of Advances in Computer Security Management, Volume 1. Rullo, Thomas A. (ed.). Philadelphia: Heyden &amp; Son.</rawString>
</citation>
<citation valid="false">
<authors>
<author>1982a</author>
</authors>
<title>Quantifier Meanings: A Study</title>
<booktitle>in the Dimensions of Semantic Competence. NorthHolland Linguistic Series, Volume 48.</booktitle>
<publisher>North-Holland.</publisher>
<location>Amsterdam:</location>
<contexts>
<context position="12757" citStr="(1982)" startWordPosition="2189" endWordPosition="2189">f a. For present purposes, we can consider it to be null in the case of V and 3. The relationship of these functions to the quantifier meanings they decompose is indicated schematically in Figure 5. IV COMPUTATIONAL SIGNIFICANCE It must be stressed in the strongest possible terms that the motivation for the analysis embodied in Figure 4 has absolutely nothing at all to do with computational considerations of any sort. Computational relevance need not imply linguistic or cognitive relevance, any more than mathematical relevance does, and vice versa. See Cushing (1979b) and Berwick and Weinberg (1982) for relevant argumentation. On the contrary, the analysis is motivated by a wide range of linguistic and psychological considerations that is too extensive to review here. See Cushing (1982a) for the full argument. The analysis does have computational significance, however, which follows post facto from its form and consists in the fact that functional hierarchies of exactly the sort it exemplifies can be seen to make up the computational systems that are expressed by computer programs. If we take a program like the one in Figure 6, for example, and ask what functions -- mathematical mappings</context>
<context position="20772" citStr="(1982)" startWordPosition="3600" endWordPosition="3600"> original program. In this way, subtle but substantial errors can be exposed and corrected that might not be readily revealed by more conventional debugging techniques. Conversely, given a legitimate control structure -- such as the one for quantifier meanings in Figure 4, for example --, the system it comprises can be implemented in any convenient programming language -- essentially, by reversing the process through which we derived Figure 7 from Figure 6, adapted to the relevant language. For some discussion of software that automates this process, see Cushing (1982b) and Wasserman and Gutz (1982). For a good description of the vision that motivates the development of this software -- i.e., the ideal situation toward which its development is directed --, see Hamilton and Zeldin (1983). Our present concerns are primarily theoretical and thus do not require the ultimate perfection of this or any other software. A number of interesting variants have been proposed to make this notion of control structure applicable to a wider class of programs. See Martin (1982), for example, for an attempt to integrate it with more traditional data base notions. Harel (1979) introduces non-determinacy, an</context>
</contexts>
<marker>1982a, </marker>
<rawString>. 1982a. Quantifier Meanings: A Study in the Dimensions of Semantic Competence. NorthHolland Linguistic Series, Volume 48. Amsterdam: North-Holland.</rawString>
</citation>
<citation valid="false">
<authors>
<author>1982b</author>
</authors>
<title>Letter to ACM Forum.</title>
<journal>Communications of the ACM.</journal>
<pages>25--951</pages>
<contexts>
<context position="12757" citStr="(1982)" startWordPosition="2189" endWordPosition="2189">f a. For present purposes, we can consider it to be null in the case of V and 3. The relationship of these functions to the quantifier meanings they decompose is indicated schematically in Figure 5. IV COMPUTATIONAL SIGNIFICANCE It must be stressed in the strongest possible terms that the motivation for the analysis embodied in Figure 4 has absolutely nothing at all to do with computational considerations of any sort. Computational relevance need not imply linguistic or cognitive relevance, any more than mathematical relevance does, and vice versa. See Cushing (1979b) and Berwick and Weinberg (1982) for relevant argumentation. On the contrary, the analysis is motivated by a wide range of linguistic and psychological considerations that is too extensive to review here. See Cushing (1982a) for the full argument. The analysis does have computational significance, however, which follows post facto from its form and consists in the fact that functional hierarchies of exactly the sort it exemplifies can be seen to make up the computational systems that are expressed by computer programs. If we take a program like the one in Figure 6, for example, and ask what functions -- mathematical mappings</context>
<context position="20772" citStr="(1982)" startWordPosition="3600" endWordPosition="3600"> original program. In this way, subtle but substantial errors can be exposed and corrected that might not be readily revealed by more conventional debugging techniques. Conversely, given a legitimate control structure -- such as the one for quantifier meanings in Figure 4, for example --, the system it comprises can be implemented in any convenient programming language -- essentially, by reversing the process through which we derived Figure 7 from Figure 6, adapted to the relevant language. For some discussion of software that automates this process, see Cushing (1982b) and Wasserman and Gutz (1982). For a good description of the vision that motivates the development of this software -- i.e., the ideal situation toward which its development is directed --, see Hamilton and Zeldin (1983). Our present concerns are primarily theoretical and thus do not require the ultimate perfection of this or any other software. A number of interesting variants have been proposed to make this notion of control structure applicable to a wider class of programs. See Martin (1982), for example, for an attempt to integrate it with more traditional data base notions. Harel (1979) introduces non-determinacy, an</context>
</contexts>
<marker>1982b, </marker>
<rawString>. 1982b. Letter to ACM Forum. Communications of the ACM. 25:951.</rawString>
</citation>
<citation valid="true">
<title>Dynamic Model Selection in the Interpretation of Discourse.&amp;quot;</title>
<date>1983</date>
<booktitle>In Cognitive Constraints on Communication: Representations and Processes. Vaina, Lucia and Jaakko Hintikka</booktitle>
<editor>(eds.).</editor>
<location>Dordrecht: Reidel.</location>
<contexts>
<context position="4026" citStr="(1983)" startWordPosition="693" endWordPosition="693">define 17370117-ieid for some x or there are x, as &amp;quot;-(V x).,&amp;quot;. Second, we can define satisfaction by a model, by saying that M satisfies A, written &amp;quot;M l= (A)&amp;quot;, if M (A) [f] for whatever assignment functions f there are for M. Intuitively, this can be read as saying that A is true of the factual situation that is represented by the relational structure into which L is interpreted, regardless of what values are given to variables by the assignment functions of an interpretation. For some discussion of the cognitive or psychological significance of these notions, see Miller (1979a,b) and Cushing (1983). II SIMPLE AND RELATIVIZED QUANTIFICATION Statement (v) of Figure 1 characterizes simple quantifications like (1), which represent the meanings expressed by sentences like (2), for which x = &amp;quot;x&amp;quot; and A = (3), while (vi) characterizes relativized quantifications like (4), which 1 iff (i.e., if and only if) f(xl) = f(x2) x._))[f] iff M (A &amp; B) (f] iff M (A)[f] and M (B) (f] M (- A)[f] iff it is not the case that M (A)[f] M ((V x) A)[f] iff M (A)[r] for whatever assignments f&apos; for M are like f except perhaps (i.e., at most) at M ((V x)(B;A))[f] iff M (A)W] for whatever assignments f&apos; for M are li</context>
<context position="20963" citStr="(1983)" startWordPosition="3631" endWordPosition="3631">gitimate control structure -- such as the one for quantifier meanings in Figure 4, for example --, the system it comprises can be implemented in any convenient programming language -- essentially, by reversing the process through which we derived Figure 7 from Figure 6, adapted to the relevant language. For some discussion of software that automates this process, see Cushing (1982b) and Wasserman and Gutz (1982). For a good description of the vision that motivates the development of this software -- i.e., the ideal situation toward which its development is directed --, see Hamilton and Zeldin (1983). Our present concerns are primarily theoretical and thus do not require the ultimate perfection of this or any other software. A number of interesting variants have been proposed to make this notion of control structure applicable to a wider class of programs. See Martin (1982), for example, for an attempt to integrate it with more traditional data base notions. Harel (1979) introduces non-determinacy, and Prade and Vaina (1980) attempt to incorporate concepts from the theory of fuzzy sets and systems. Further development of the latter of these efforts would be of particular interest in our p</context>
</contexts>
<marker>1983</marker>
<rawString>. 1983. &amp;quot;Dynamic Model Selection in the Interpretation of Discourse.&amp;quot; In Cognitive Constraints on Communication: Representations and Processes. Vaina, Lucia and Jaakko Hintikka (eds.). Dordrecht: Reidel.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Bas C van Fraassen</author>
</authors>
<title>Formal Semantics and Logic.</title>
<date>1971</date>
<publisher>Macmillan.</publisher>
<location>New York:</location>
<marker>van Fraassen, 1971</marker>
<rawString>van Fraassen, Bas C. 1971. Formal Semantics and Logic. New York: Macmillan.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Margaret Hamilton</author>
<author>Saydean Zeldin</author>
</authors>
<title>Higher Order Software -- A Methodology for Defining Software.&amp;quot;</title>
<date>1976</date>
<journal>IEEE Transactions on Software Engineering.</journal>
<pages>2--9</pages>
<contexts>
<context position="17385" citStr="Hamilton and Zeldin (1976)" startWordPosition="3027" endWordPosition="3030">re 7 does, and so can be naturally implemented in whatever programming language those implementations are themselves formulated in. V ABSTRACT CONTROL STRUCTURES AS FUNCTIONAL HIERARCHIES The control structure indicators -- the words IF, THEN, ELSE, the semi-colons, the sequential placement on the page, and so on -- in Figure 6 are ad hoc syntactic devices that really express semantic relationships of functional hierarchy, viz., those shown in Figure 7. In general, we can identify a control structure with such a functional hierarchy. For some background discussion relevant to this notion, see Hamilton and Zeldin (1976). A control structure can be said to be legitimate, if its interfaces are correct, i.e., if the subfunctions do effect the same mappings as the functions they purportedly decompose. Of the three structures in Figure 8, for example, only (ii) is legitimate, because (i) and (iii) each generates a value of a as a side effect -- a is generated by a subfunction, but not by the overall function --, and b in (i) appears from nowhere -- i.e., as an input to a subfunction, but not as an input to the overall function, or as an output from another subfunction on the same level. Structure (iii) can be mad</context>
</contexts>
<marker>Hamilton, Zeldin, 1976</marker>
<rawString>Hamilton, Margaret and Saydean Zeldin. 1976. &amp;quot;Higher Order Software -- A Methodology for Defining Software.&amp;quot; IEEE Transactions on Software Engineering. SE-2:9-32. &amp;quot;The Functional Life Cycle and Its Journal of Systems and Software.</rawString>
</citation>
<citation valid="true">
<authors>
<author>David Harel</author>
</authors>
<title>And/Or Programs: A New Approach to Structured Programming.&amp;quot; Specifications of Reliable Software.</title>
<date>1979</date>
<journal>IEEE Catalog No.</journal>
<volume>79</volume>
<pages>1401--9</pages>
<marker>Harel, 1979</marker>
<rawString>Harel, David. 1979. &amp;quot;And/Or Programs: A New Approach to Structured Programming.&amp;quot; Specifications of Reliable Software. IEEE Catalog No. 79 CH1401-9C.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Deepak Kapur</author>
</authors>
<title>Towards a Theory for Abstract Data Types.&amp;quot;</title>
<date>1980</date>
<tech>TR-237.</tech>
<institution>Laboratory for Computer Science. Massachusetts Institute of Technology.</institution>
<contexts>
<context position="16262" citStr="Kapur (1980)" startWordPosition="2859" endWordPosition="2860"> Figure 6 are strictly numerical only for the sake of illustration. As we have just seen, even in this case, extracting the implicit functional hierarchy expressed by the program requires the introduction of a nonnumerical -- viz., boolean-valued -- variable. In general, variables in a program can be taken to range over any data type at all -- i.e., any kind of object to be processed --, as long as it can be provided with an appropriate implementation, and the same is therefore true, as well, of its implicit functional hierarchy. For an extensive list of references on abstract data types, see Kapur (1980); for some discussion of their complementary relationship with the functional hierarchies expressed by programs, see Cushing (1978a; 1980). variables that range over registers, locations, and the like, and bottom-node functions that store and retrieve data, and so on, just as Figure 4 has bottom-node functions that assign extensions to . predicates and form the intersections of sets. Given implementations of these latter functions, Figure 4 defines a computational system, just as much as Figure 7 does, and so can be naturally implemented in whatever programming language those implementations a</context>
</contexts>
<marker>Kapur, 1980</marker>
<rawString>Kapur, Deepak. 1980. &amp;quot;Towards a Theory for Abstract Data Types.&amp;quot; TR-237. Laboratory for Computer Science. Massachusetts Institute of Technology.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Edward L Keenan</author>
</authors>
<title>Quantifier Structures in English.&amp;quot;</title>
<date>1971</date>
<journal>Foundations of Language.</journal>
<pages>7--255</pages>
<marker>Keenan, 1971</marker>
<rawString>Keenan, Edward L. 1971. &amp;quot;Quantifier Structures in English.&amp;quot; Foundations of Language. 7:255-284.</rawString>
</citation>
<citation valid="true">
<authors>
<author>James Martin</author>
</authors>
<title>Program Design Which Is Provably Correct.</title>
<date>1982</date>
<institution>Savant Institute.</institution>
<location>Carnforth, England:</location>
<contexts>
<context position="21242" citStr="Martin (1982)" startWordPosition="3675" endWordPosition="3676">dapted to the relevant language. For some discussion of software that automates this process, see Cushing (1982b) and Wasserman and Gutz (1982). For a good description of the vision that motivates the development of this software -- i.e., the ideal situation toward which its development is directed --, see Hamilton and Zeldin (1983). Our present concerns are primarily theoretical and thus do not require the ultimate perfection of this or any other software. A number of interesting variants have been proposed to make this notion of control structure applicable to a wider class of programs. See Martin (1982), for example, for an attempt to integrate it with more traditional data base notions. Harel (1979) introduces non-determinacy, and Prade and Vaina (1980) attempt to incorporate concepts from the theory of fuzzy sets and systems. Further development of the latter of these efforts would be of particular interest in our present context, in view of work done by Zadeh (1977), for example, to explicate quantifier and other meanings in terms of fuzzy logic. ACKNOWLEDGEMENTS I would like to thank Fred Barrett, Mitka Golub, and Robert Kuhns for helpful comments on an earlier draft, and Margaret Moore </context>
</contexts>
<marker>Martin, 1982</marker>
<rawString>Martin, James. 1982. Program Design Which Is Provably Correct. Carnforth, England: Savant Institute.</rawString>
</citation>
<citation valid="true">
<authors>
<author>George A Miller</author>
</authors>
<title>Construction and Selection in the Mental Representation of Text.&amp;quot; Cahiers de l&apos;Institut de Linguistique de Louvain.</title>
<date>1979</date>
<pages>5--185</pages>
<contexts>
<context position="4003" citStr="Miller (1979" startWordPosition="689" endWordPosition="690">as 11-(B &amp; -,A)&amp;quot;, and we can define 17370117-ieid for some x or there are x, as &amp;quot;-(V x).,&amp;quot;. Second, we can define satisfaction by a model, by saying that M satisfies A, written &amp;quot;M l= (A)&amp;quot;, if M (A) [f] for whatever assignment functions f there are for M. Intuitively, this can be read as saying that A is true of the factual situation that is represented by the relational structure into which L is interpreted, regardless of what values are given to variables by the assignment functions of an interpretation. For some discussion of the cognitive or psychological significance of these notions, see Miller (1979a,b) and Cushing (1983). II SIMPLE AND RELATIVIZED QUANTIFICATION Statement (v) of Figure 1 characterizes simple quantifications like (1), which represent the meanings expressed by sentences like (2), for which x = &amp;quot;x&amp;quot; and A = (3), while (vi) characterizes relativized quantifications like (4), which 1 iff (i.e., if and only if) f(xl) = f(x2) x._))[f] iff M (A &amp; B) (f] iff M (A)[f] and M (B) (f] M (- A)[f] iff it is not the case that M (A)[f] M ((V x) A)[f] iff M (A)[r] for whatever assignments f&apos; for M are like f except perhaps (i.e., at most) at M ((V x)(B;A))[f] iff M (A)W] for whatever assi</context>
</contexts>
<marker>Miller, 1979</marker>
<rawString>Miller, George A. 1979a. &amp;quot;Construction and Selection in the Mental Representation of Text.&amp;quot; Cahiers de l&apos;Institut de Linguistique de Louvain. 5:185-197.</rawString>
</citation>
<citation valid="false">
<authors>
<author>1979b</author>
</authors>
<title>Images and Models, Similes and Metaphors.&amp;quot;</title>
<editor>In Metaphor and Thought. Ortony, Andrew (ed.). Cambridge:</editor>
<publisher>Cambridge University Press.</publisher>
<contexts>
<context position="19931" citStr="(1979)" startWordPosition="3468" endWordPosition="3468">redicates. Of these three legitimate structures, then, only (ii) can be seen as occurring in Figure 7. Figure 4 also contains a different structure (for Select-sets) that combines the features of (25) and (26). The important point here is that functional hierarchies comprising legitimate control structures are inherent in the systems expressed by workable programs. As such, they have proven useful both as a verification tool and as a programming tool. For some discussion of the relationship that ought to exist, ideally, between these two different modes of application, see Hamilton and Zeldin (1979). Through interaction with those who have written an existing program, one can derive the abstract control structure of the system expressed by the program, make that structure legitimate, and then make the corresponding changes in the original program. In this way, subtle but substantial errors can be exposed and corrected that might not be readily revealed by more conventional debugging techniques. Conversely, given a legitimate control structure -- such as the one for quantifier meanings in Figure 4, for example --, the system it comprises can be implemented in any convenient programming la</context>
</contexts>
<marker>1979b, </marker>
<rawString>. 1979b. &amp;quot;Images and Models, Similes and Metaphors.&amp;quot; In Metaphor and Thought. Ortony, Andrew (ed.). Cambridge: Cambridge University Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Henri Prade</author>
<author>Lucia Vaina</author>
</authors>
<title>What &apos;Fuzzy HOS&apos; May Mean.&amp;quot;</title>
<date>1980</date>
<booktitle>Proceedings, Fourth International Computer Software and Applications Conference. IEEE Catalog No.</booktitle>
<volume>80</volume>
<pages>1607--1</pages>
<marker>Prade, Vaina, 1980</marker>
<rawString>Prade, Henri and Lucia Vaina. 1980. &amp;quot;What &apos;Fuzzy HOS&apos; May Mean.&amp;quot; Proceedings, Fourth International Computer Software and Applications Conference. IEEE Catalog No. 80 CH1607-1.</rawString>
</citation>
<citation valid="false">
<authors>
<author>Anthony I Wasserman</author>
<author>Steven Gutz</author>
</authors>
<title>Reply to Letters to ACM Forum.</title>
<journal>Communications of the ACM.</journal>
<pages>25--951</pages>
<marker>Wasserman, Gutz, </marker>
<rawString>Wasserman, Anthony I. and Steven Gutz. Reply to Letters to ACM Forum. Communications of the ACM. 25:951-2.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Lotfi A Zadeh</author>
</authors>
<title>PRUF - A Language for the Representation of Meaning in Natural Languages.&amp;quot;</title>
<date>1977</date>
<booktitle>Proceedings, Fifth International Joint Conference on Artificial Intelligence,</booktitle>
<volume>2</volume>
<location>Cambridge, Massachusetts.</location>
<marker>Zadeh, 1977</marker>
<rawString>Zadeh, Lotfi A. 1977. &amp;quot;PRUF - A Language for the Representation of Meaning in Natural Languages.&amp;quot; Proceedings, Fifth International Joint Conference on Artificial Intelligence, Volume 2. Cambridge, Massachusetts.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>