<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.124645">
<title confidence="0.9958065">
Kiwi: A Multilingual Usage Consultation Tool
based on Internet Searching
</title>
<author confidence="0.942011">
Kumiko TANAKA-Ishii and Masato YAMAMOTO and Hiroshi NAKAGAWA
</author>
<affiliation confidence="0.9656395">
Language Informatics Laboratory, Information Technology Center
The University of Tokyo
</affiliation>
<email confidence="0.982662">
fkumiko, yamamoto, nakagawal@r.dl.itc.u-tokyo.ac.jp
</email>
<sectionHeader confidence="0.979725" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999925526315789">
We present a usage consultation tool
based on Internet searching. When a
user enters a string of words that he
wants to find the usage for, the system
sends a query to the search engine to
obtain a corpus about the string. The
corpus is statistically analyzed and re-
sults are displayed. As the system
uses neither language-dependent anal-
ysis nor initial data, queries can be
made in any language, even languages
for which there are no well-established
analytical methods. Also, since the
corpus is dynamically obtained from
the search engines, the usages provided
to the user are always up to date. Kiwi
can fill in the missing parts of the
collocations frequently used by native
speakers.
</bodyText>
<sectionHeader confidence="0.996304" genericHeader="keywords">
1 Introduction
</sectionHeader>
<bodyText confidence="0.999898">
When a learner gets stuck on a question of usage,
one possible solution is to use a search engine.
For example, suppose that a Japanese student
wants to find how to say &amp;quot;wireless network&amp;quot; in
French. In Japanese, the most common way of
saying &amp;quot;wireless network&amp;quot; is &amp;quot;musen (wireless)
LAN&amp;quot;. A direct translation cannot be found
in any Japanese-French dictionaries, so typically
the student will first try to translate part of the
target using a conventional dictionary; if the stu-
dent looks up &amp;quot;musen&amp;quot;, the dictionary definition
will be &amp;quot;sans fil&amp;quot;. (&amp;quot;LAN&amp;quot; cannot be found in
dictionaries, either). This clue, &amp;quot;sans fil&amp;quot;, can
then be input to the search engine, and usages
such as &amp;quot;l&apos;access sans fil&amp;quot; or &amp;quot;le reseau sans fil&amp;quot;
will be retrieved within the first two or three
pages of search-engine results.
The user can find out more if he scans, say,
50 pages of results. For example, he would find
that the most common usage of wireless network
is in the expression &amp;quot;l&apos;internet sans fil&amp;quot; (followed
by &amp;quot;les reseaux sans fil&amp;quot;). To make this task of
scanning and summing up more practical, we
need a tool that can read the entire 50 pages on
behalf of the user since the process would other-
wise be too time-consuming. For this purpose,
we have developed Kiwi, a tool that dynamically
obtains data from the worldwide web (WWW),
scans tens of pages of search-engine results, sta-
tistically analyzes the pages, and reports the re-
sults to the user.
Internet search engines are increasingly used
by language students to learn about usage, and
the idea of creating a tool to facilitate this is not
new. One example of an existing tool is Web-
corp (Webcorp, 1999). Using the WWW as its
corpus, Webcorp traverses links to obtain an ex-
tensive collection of relevant pages, and then it
totals the search engine results. However, this
tool is only available in English and is not read-
ily applicable to languages without word seg-
mentation. Another recent examples are found
in (GoogleFight, 2000)(Peters, 2002), where the
user enters two different phrases and the tool
suggests which is most commonly used accord-
ing to data obtained from the search engine. Al-
though these pages allow multilingual consulta-
tion, the range of possible queries is limited be-
cause the two phrases can be compared only in
terms of occurrence frequency.
Our tool, Kiwi, is designed to be more gen-
eral in its applicability than these existing tools
in that it is language independent and allows
greater query flexibility. It does this through
candidate extraction and candidate ranking.
Another concern that we address in this pa-
per is to what extent the search-engine re-
sults can be used as an example-based lan-
guage source. In this sense, our study is sim-
ilar to that of (Keller et al., 2002). They ar-
gue that high-quality n-grams can be derived
from the ostensibly-noisy WWW, although their
approach is word based thus presumes the use
of tagger for non-segmented languages. As we
believe that the idea is more important to be
utilized independently of language, we discuss
the performance when the idea is applied to the
string-based processing. Such results can serve
as the fundamental study useful for more diffi-
cult tasks based on the use of search engines:
for example, Question and Answering (Brill et
al., 2001) (Dumais et al., 2002) or dynamic term
translation(Nagata et al., 2001). In the next sec-
tion, we explain Kiwi in more detail.
</bodyText>
<sectionHeader confidence="0.984277" genericHeader="introduction">
2 KIWI
</sectionHeader>
<bodyText confidence="0.999379666666667">
Kiwi is a simple tool written in the Java lan-
guage. It is designed for use with an Internet
connection. The Kiwi processing is as follows:
</bodyText>
<listItem confidence="0.926647454545454">
1. Receive an input query from a user:
2. Obtain a fixed number of search engine re-
sults that match the query.
3. Extract all fixed length strings that might
include candidates.
4. Obtain candidates from these strings.
5. Rank candidates.
6. Display results.
Compared with previous works (Webcorp,
1999) (GoogleFight, 2000), Kiwi allows more
flexible query entries.
</listItem>
<bodyText confidence="0.996267142857143">
Wild Card `&apos;&amp;quot; can be used to replace a missing
word or string. For example, &amp;quot;human *&amp;quot;, &amp;quot;*
sans flu&amp;quot;, can be entered into Kiwi.
Comparison allows us to compare two or more
phrases and prioritize them depending on
which is most relevant. This can be ex-
pressed as (A/B/C...).
Another feature of Kiwi is language indepen-
dence. We adopted this in order to widen oppor-
tunities of usage consultation, even in languages
not widely used internationally.
Let&apos;s look at some actual examples of how
Kiwi can be used(Table 1). These examples are
related to seven languages. Some involve the
</bodyText>
<tableCaption confidence="0.996626">
Table 1: Kiwi Live Examples
</tableCaption>
<table confidence="0.997339142857143">
I nput Kiwi Result Examples
English
wireless* communications network
Harry and the and the
Potter* Sorcerer&apos;s Chamber of
Stone Secrets
*animation flash cartoon
Bovine* Spongiform Encephalopathy
(BSE, mad cow disease)
Stir* Wars Trek
French
*sans fil reseaux letephone
(wireless) (network) (telephone)
*du Monde coupe. tour
(of world) (cup) (tour)
*Zidane Zinedine Zinedine
(Soccer (first name) (first name)
player)
Japanese
(w i re I ess) LAN LAN )7— F
(LAN) (LAN card)
(Tokyo) (Stadium) ad i um) -U) 7 L.
(D i sney Land)
34I—P.F ij,* [11%1A:qtff,1\M
(Jun&apos;ichiro) (Koizumi) (Prime Minister)
Chinese
(wireless) (network) (radio
management)
(Martialart) (Tai Chi) (Tai Chi)
(duck) (Beijing) (restaurant
name)
Korean
*;11 371 131-11
(kimchi) (Poi kimchi ) (Chinese .
cabbage)
German
schla* Neuschwanstein Neuhaus
(castle) (castle name) (castle name)
Spanish
Real* Madrid Sociedad
(Soccer (team name) (team name)
team)
</table>
<tableCaption confidence="0.993642">
Table 2: Top 10 Altavista Results for &apos;wireless&apos;
</tableCaption>
<footnote confidence="0.9249291">
1st Pre-release wireless Java software
2nd Beta-edition, wireless Java software
3rd All digital wireless
4th AT&amp;T wireless
5th AT&amp;T wireless
6th on the wireless Internet
7th 5-day wireless boot-camp
8th Wireless Lans
9th Wireless phone calling plans
10th Wireless News
</footnote>
<bodyText confidence="0.996760583333333">
translation of &amp;quot;wireless network&amp;quot;, and the oth-
ers show VIP names, film titles, food names,
and so on. We see that the results directly re-
flect our times: we watch Harry Potter and the
Sorcerer&apos;s Stone and Star Wars, eat Kimchi and
Peking duck, visit Neuschwanstein schloss. Such
live results can be observed only with a simple
tool such as Kiwi that sums up the overall trend
of the search engine data.
What we want to emphasize here is that such
an overall view cannot be obtained through
the direct use of a search engine by the user.
Table 2 shows the Altavista search result for
&amp;quot;wireless&amp;quot;. (Kiwi currently uses Altavista as
its mother search engine because of its index-
ing strategy). &amp;quot;wireless Internet&amp;quot; had the sixth
highest score, and &amp;quot;Wireless Lans&amp;quot; had the
eighth highest. This result is badly affected by
noise. By comparison, Kiwi gave far clearer re-
sults: communications, network, and Internet.
As explained in §1, the two most important
functions of Kiwi are the candidate extraction
and the candidate ranking. We next explain the
design of these functions in Kiwi.
</bodyText>
<sectionHeader confidence="0.752256" genericHeader="method">
3 Candidate Extraction and Ranking
</sectionHeader>
<bodyText confidence="0.990860277777778">
Intuitively, we would expect a candidate to have
the following features:
A It occurs frequently.
B It has moderate length.
C There is a variety of succeeding characters.
A concerns the relevancy of the candidate (as
will be discussed in the next section). On the
other hand, C essentially expresses information
about the word boundaries. B can be used for
either objective.
Combining C and B, we decided to extract
the candidates in the following way. With X as
a string, let X, be the head i characters of X,
and C, be the number of kinds of characters at
the (i ± 1)th position of all strings of the prefix
X. We extract X, as a candidate when:
C, &gt; c_1.
Such idea of using the branching degree has been
proposed in a various way (resumed in (Naka-
gawa and Mori, 2002)) and shown to be success-
ful. What is new of our idea is to apply their
idea to string level, that is to say, how many
kinds of characters suceed the focused chracter.
After candidates are obtained, Kiwi ranks
them. Here, the most important information
is frequency (A). The length is also a con-
cern, though, because short strings obviously oc-
cur more frequently than longer ones (condition
B). Therefore, a bias towards longer candidates
should be included in the evaluation function.
The question is how best to incorporate these
two features into an evaluation function formula.
We decided to do this empirically. With X as
the candidate, IX I as its length, and freq(X) as
its frequency, we used the following function as
our evaluation function:
</bodyText>
<equation confidence="0.929624">
F(X) = freq(X)log(IXI± 1).
</equation>
<bodyText confidence="0.998447">
We chose to use this function because it outper-
formed all other functions we considered.
</bodyText>
<sectionHeader confidence="0.996669" genericHeader="evaluation">
4 Evaluation
</sectionHeader>
<subsectionHeader confidence="0.998368">
4.1 Data and Process
</subsectionHeader>
<bodyText confidence="0.999143142857143">
We evaluated Kiwi when using the Altavista
search engine. English collocations were chosen
as our query test set because hundreds of them
were automatically available. We here show only
of the evaluation on cases where the wild card
was placed at the head or the end of the query.
Our evaluation was done in five stages:
</bodyText>
<listItem confidence="0.999456631578947">
1. Obtain a set of collocations with each being
more than three words in length.
2. For each collocation, replace the head or
the tail part with the wild card. These are
called queries, and the replaced words are
called required answers in the following.
3. Scan all the queries and remove ambigu-
ous queries (such as, the query &amp;quot;* up with&amp;quot;
which would lead to two required answers of
&amp;quot;come&amp;quot; and &amp;quot;keep&amp;quot;). Each set ahead, tail}
x {collocation}) of unambiguous queries
contain about 300 entries.
4. For each query, download data that
matched the query from the search engine
(only summaries). The maximum data
amount was set at 1000 matches for each
query. (There are queries with fewer avail-
able matches.)
5. Calculate the following three rates:
</listItem>
<bodyText confidence="0.962544166666667">
Best Rate The rate of required answers
appearing as the highest ranked.
Top N Rate The rate of required answers
appearing among the top N.
Candidate Rate The rate of required an-
swers appearing among all.
</bodyText>
<tableCaption confidence="0.98923">
Table 3: Overall Kiwi Performance
</tableCaption>
<table confidence="0.999458833333333">
best top 10 candidate
(%) (%) (%)
Kiwi (head) A 77.0 93.3 B 97.0
Kiwi (tail) A 78.5 92.8 B 96.3
baseline (head) 32.8 75.5 C 98.9
baseline (t ail) 33.6 80.8 C 97.4
</table>
<bodyText confidence="0.998969285714286">
For comparison, a baseline was calculated sim-
ilarly by looking at the query matches in the
descending order of the search engine proposals.
The rates are counted with respect to an exact
match for the Kiwi results, whereas the baseline
results are counted as correct when the corre-
sponding string includes the required answer.
</bodyText>
<subsectionHeader confidence="0.902165">
4.2 Performance using Collocations
</subsectionHeader>
<bodyText confidence="0.997863942857143">
Table 3 shows the Kiwi and the baseline results
for collocations. The best and the top-10 rate
of Kiwi outperformed the baseline. For the best
rate, Kiwi records were twice as good as those
for the baseline. Also, nearly 95% of the Kiwi re-
sults contained the required answers among the
top 10, which was superior to the baseline re-
sults. We thus concluded that the Kiwi aggre-
gation process was effective.
The overall error rate for a required answer
that occurred at least once was:
(C - B)±(B - A) %
where each term corresponds to extraction and
ranking error, respectively. If the required an-
swer does not occur frequently enough on the
web, Kiwi cannot obtain enough information to
totalize the result. For example, for the query
&amp;quot;be anxious *&amp;quot;, the best candidate was con-
sidered &amp;quot;to&amp;quot; although the required answer was
&amp;quot;for&amp;quot;, and this case was counted as an error.
Such situations occur when our required answer
differs from what is the true answer on the web.
The cause lies in how we prepare the test set,
too.
The extreme case is when the required answer
was not included in the downloaded data ob-
tained from the search engine: the answer could
not be processed. The error rate attributable to
such cases equals:
(100 - C of Table 3)%.
As this error was not caused by Kiwi itself,
the value of C gives the upper bound of Kiwi&apos;s
performance. The potential power of Kiwi is
demonstrated by how close the value B was to
this upper bound.
</bodyText>
<sectionHeader confidence="0.992109" genericHeader="conclusions">
5 Conclusion
</sectionHeader>
<bodyText confidence="0.999939791666666">
Kiwi is a web-based usage consultation tool
based on search engines. When the user enters
a string of words to check the usage, the system
sends the query to a search engine to obtain a
small corpus related to the string. The corpus
is then analyzed and the results are displayed.
Our system differs from existing systems in
two ways. First, it is language independent,
so queries can be made in any language if the
mother search engine supports that language.
This is achieved by string-based processing of
the candidate extraction and ranking. We for-
malized the extraction through term branching,
and ranked by candidate frequency and length.
Second, flexible queries can be made using wild
cards and comparisons.
According to our evaluation, the missing parts
of collocations were provided by the highest
ranked candidate proposed by Kiwi 70% of the
time. When the top 10 candidates were consid-
ered, nearly 95% of the required answers were
found. The effect of totalization was clarified by
comparing the Kiwi results with the raw search
engine baselines.
</bodyText>
<sectionHeader confidence="0.998817" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.997844772727273">
E. Brill, J. Lin, M. Banko, S. Dumais, and A. Ng. 2001.
Data-intensive question answering. In TREC, pages
393-400.
S. Dumais, M. Banko, and Brill et al. 2002. Web question
answering: Is more always better? In SIGIR, pages
291-298.
GoogleFight. 2000. Google fight : Make
a fight with googlefight. Available at
http: //www. googlef ight . corn/.
F. Keller, M. Lapata, and 0. Ourioupina. 2002. Using
the web to overcome data sparseness. In EMNLP,
pages 230-237.
M. Nagata, Saito T., and Suzuki K. 2001. Using the web
as a bilingual dictionary. ACL workshop DDMT.
H. Nakagawa and T. Mori. 2002. A simple but powerful
automatic termextraction method. In Computerm2:
2nd International Workshop on Computational Ter-
minology (COLING-Workshop), pages 29-35.
G. Peters. 2002. Geoff&apos;s googleduel! Available at
http: !!www. sfu. ca/ gpeters/cgi-bin/pear/.
Webcorp. 1999. Webcorp home page. Available at
http: !!www . webcorp. org . uk/.
</reference>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.866182">
<title confidence="0.998929">Kiwi: A Multilingual Usage Consultation Tool based on Internet Searching</title>
<author confidence="0.971009">TANAKA-Ishii YAMAMOTO NAKAGAWA</author>
<affiliation confidence="0.994705">Language Informatics Laboratory, Information Technology Center The University of Tokyo</affiliation>
<email confidence="0.94338">fkumiko,yamamoto,nakagawal@r.dl.itc.u-tokyo.ac.jp</email>
<abstract confidence="0.9977442">a usage consultation tool based on Internet searching. When a user enters a string of words that he wants to find the usage for, the system sends a query to the search engine to obtain a corpus about the string. The corpus is statistically analyzed and results are displayed. As the system uses neither language-dependent analysis nor initial data, queries can be made in any language, even languages for which there are no well-established analytical methods. Also, since the corpus is dynamically obtained from the search engines, the usages provided to the user are always up to date. Kiwi can fill in the missing parts of the collocations frequently used by native speakers.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>E Brill</author>
<author>J Lin</author>
<author>M Banko</author>
<author>S Dumais</author>
<author>A Ng</author>
</authors>
<title>Data-intensive question answering.</title>
<date>2001</date>
<booktitle>In TREC,</booktitle>
<pages>393--400</pages>
<contexts>
<context position="4264" citStr="Brill et al., 2001" startWordPosition="706" endWordPosition="709">based language source. In this sense, our study is similar to that of (Keller et al., 2002). They argue that high-quality n-grams can be derived from the ostensibly-noisy WWW, although their approach is word based thus presumes the use of tagger for non-segmented languages. As we believe that the idea is more important to be utilized independently of language, we discuss the performance when the idea is applied to the string-based processing. Such results can serve as the fundamental study useful for more difficult tasks based on the use of search engines: for example, Question and Answering (Brill et al., 2001) (Dumais et al., 2002) or dynamic term translation(Nagata et al., 2001). In the next section, we explain Kiwi in more detail. 2 KIWI Kiwi is a simple tool written in the Java language. It is designed for use with an Internet connection. The Kiwi processing is as follows: 1. Receive an input query from a user: 2. Obtain a fixed number of search engine results that match the query. 3. Extract all fixed length strings that might include candidates. 4. Obtain candidates from these strings. 5. Rank candidates. 6. Display results. Compared with previous works (Webcorp, 1999) (GoogleFight, 2000), Kiw</context>
</contexts>
<marker>Brill, Lin, Banko, Dumais, Ng, 2001</marker>
<rawString>E. Brill, J. Lin, M. Banko, S. Dumais, and A. Ng. 2001. Data-intensive question answering. In TREC, pages 393-400.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S Dumais</author>
<author>M Banko</author>
<author>Brill</author>
</authors>
<title>Web question answering: Is more always better? In</title>
<date>2002</date>
<booktitle>SIGIR,</booktitle>
<pages>291--298</pages>
<contexts>
<context position="4286" citStr="Dumais et al., 2002" startWordPosition="710" endWordPosition="713">. In this sense, our study is similar to that of (Keller et al., 2002). They argue that high-quality n-grams can be derived from the ostensibly-noisy WWW, although their approach is word based thus presumes the use of tagger for non-segmented languages. As we believe that the idea is more important to be utilized independently of language, we discuss the performance when the idea is applied to the string-based processing. Such results can serve as the fundamental study useful for more difficult tasks based on the use of search engines: for example, Question and Answering (Brill et al., 2001) (Dumais et al., 2002) or dynamic term translation(Nagata et al., 2001). In the next section, we explain Kiwi in more detail. 2 KIWI Kiwi is a simple tool written in the Java language. It is designed for use with an Internet connection. The Kiwi processing is as follows: 1. Receive an input query from a user: 2. Obtain a fixed number of search engine results that match the query. 3. Extract all fixed length strings that might include candidates. 4. Obtain candidates from these strings. 5. Rank candidates. 6. Display results. Compared with previous works (Webcorp, 1999) (GoogleFight, 2000), Kiwi allows more flexible</context>
</contexts>
<marker>Dumais, Banko, Brill, 2002</marker>
<rawString>S. Dumais, M. Banko, and Brill et al. 2002. Web question answering: Is more always better? In SIGIR, pages 291-298.</rawString>
</citation>
<citation valid="true">
<authors>
<author>GoogleFight</author>
</authors>
<title>Google fight : Make a fight with googlefight. Available at http: //www. googlef ight .</title>
<date>2000</date>
<publisher>corn/.</publisher>
<contexts>
<context position="2962" citStr="GoogleFight, 2000" startWordPosition="489" endWordPosition="490">results, statistically analyzes the pages, and reports the results to the user. Internet search engines are increasingly used by language students to learn about usage, and the idea of creating a tool to facilitate this is not new. One example of an existing tool is Webcorp (Webcorp, 1999). Using the WWW as its corpus, Webcorp traverses links to obtain an extensive collection of relevant pages, and then it totals the search engine results. However, this tool is only available in English and is not readily applicable to languages without word segmentation. Another recent examples are found in (GoogleFight, 2000)(Peters, 2002), where the user enters two different phrases and the tool suggests which is most commonly used according to data obtained from the search engine. Although these pages allow multilingual consultation, the range of possible queries is limited because the two phrases can be compared only in terms of occurrence frequency. Our tool, Kiwi, is designed to be more general in its applicability than these existing tools in that it is language independent and allows greater query flexibility. It does this through candidate extraction and candidate ranking. Another concern that we address i</context>
<context position="4859" citStr="GoogleFight, 2000" startWordPosition="810" endWordPosition="811">ng (Brill et al., 2001) (Dumais et al., 2002) or dynamic term translation(Nagata et al., 2001). In the next section, we explain Kiwi in more detail. 2 KIWI Kiwi is a simple tool written in the Java language. It is designed for use with an Internet connection. The Kiwi processing is as follows: 1. Receive an input query from a user: 2. Obtain a fixed number of search engine results that match the query. 3. Extract all fixed length strings that might include candidates. 4. Obtain candidates from these strings. 5. Rank candidates. 6. Display results. Compared with previous works (Webcorp, 1999) (GoogleFight, 2000), Kiwi allows more flexible query entries. Wild Card `&apos;&amp;quot; can be used to replace a missing word or string. For example, &amp;quot;human *&amp;quot;, &amp;quot;* sans flu&amp;quot;, can be entered into Kiwi. Comparison allows us to compare two or more phrases and prioritize them depending on which is most relevant. This can be expressed as (A/B/C...). Another feature of Kiwi is language independence. We adopted this in order to widen opportunities of usage consultation, even in languages not widely used internationally. Let&apos;s look at some actual examples of how Kiwi can be used(Table 1). These examples are related to seven languag</context>
</contexts>
<marker>GoogleFight, 2000</marker>
<rawString>GoogleFight. 2000. Google fight : Make a fight with googlefight. Available at http: //www. googlef ight . corn/.</rawString>
</citation>
<citation valid="true">
<authors>
<author>F Keller</author>
<author>M Lapata</author>
</authors>
<title>Using the web to overcome data sparseness.</title>
<date>2002</date>
<booktitle>In EMNLP,</booktitle>
<pages>230--237</pages>
<marker>Keller, Lapata, 2002</marker>
<rawString>F. Keller, M. Lapata, and 0. Ourioupina. 2002. Using the web to overcome data sparseness. In EMNLP, pages 230-237.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Nagata</author>
<author>T Saito</author>
<author>K Suzuki</author>
</authors>
<title>Using the web as a bilingual dictionary. ACL workshop DDMT.</title>
<date>2001</date>
<contexts>
<context position="4335" citStr="Nagata et al., 2001" startWordPosition="717" endWordPosition="720">(Keller et al., 2002). They argue that high-quality n-grams can be derived from the ostensibly-noisy WWW, although their approach is word based thus presumes the use of tagger for non-segmented languages. As we believe that the idea is more important to be utilized independently of language, we discuss the performance when the idea is applied to the string-based processing. Such results can serve as the fundamental study useful for more difficult tasks based on the use of search engines: for example, Question and Answering (Brill et al., 2001) (Dumais et al., 2002) or dynamic term translation(Nagata et al., 2001). In the next section, we explain Kiwi in more detail. 2 KIWI Kiwi is a simple tool written in the Java language. It is designed for use with an Internet connection. The Kiwi processing is as follows: 1. Receive an input query from a user: 2. Obtain a fixed number of search engine results that match the query. 3. Extract all fixed length strings that might include candidates. 4. Obtain candidates from these strings. 5. Rank candidates. 6. Display results. Compared with previous works (Webcorp, 1999) (GoogleFight, 2000), Kiwi allows more flexible query entries. Wild Card `&apos;&amp;quot; can be used to repl</context>
</contexts>
<marker>Nagata, Saito, Suzuki, 2001</marker>
<rawString>M. Nagata, Saito T., and Suzuki K. 2001. Using the web as a bilingual dictionary. ACL workshop DDMT.</rawString>
</citation>
<citation valid="true">
<authors>
<author>H Nakagawa</author>
<author>T Mori</author>
</authors>
<title>A simple but powerful automatic termextraction method.</title>
<date>2002</date>
<booktitle>In Computerm2: 2nd International Workshop on Computational Terminology (COLING-Workshop),</booktitle>
<pages>29--35</pages>
<contexts>
<context position="8624" citStr="Nakagawa and Mori, 2002" startWordPosition="1432" endWordPosition="1436">f succeeding characters. A concerns the relevancy of the candidate (as will be discussed in the next section). On the other hand, C essentially expresses information about the word boundaries. B can be used for either objective. Combining C and B, we decided to extract the candidates in the following way. With X as a string, let X, be the head i characters of X, and C, be the number of kinds of characters at the (i ± 1)th position of all strings of the prefix X. We extract X, as a candidate when: C, &gt; c_1. Such idea of using the branching degree has been proposed in a various way (resumed in (Nakagawa and Mori, 2002)) and shown to be successful. What is new of our idea is to apply their idea to string level, that is to say, how many kinds of characters suceed the focused chracter. After candidates are obtained, Kiwi ranks them. Here, the most important information is frequency (A). The length is also a concern, though, because short strings obviously occur more frequently than longer ones (condition B). Therefore, a bias towards longer candidates should be included in the evaluation function. The question is how best to incorporate these two features into an evaluation function formula. We decided to do t</context>
</contexts>
<marker>Nakagawa, Mori, 2002</marker>
<rawString>H. Nakagawa and T. Mori. 2002. A simple but powerful automatic termextraction method. In Computerm2: 2nd International Workshop on Computational Terminology (COLING-Workshop), pages 29-35.</rawString>
</citation>
<citation valid="true">
<authors>
<author>G Peters</author>
</authors>
<title>Geoff&apos;s googleduel! Available at http: !!www. sfu. ca/ gpeters/cgi-bin/pear/. Webcorp.</title>
<date>2002</date>
<publisher>uk/.</publisher>
<contexts>
<context position="2976" citStr="Peters, 2002" startWordPosition="490" endWordPosition="491">lly analyzes the pages, and reports the results to the user. Internet search engines are increasingly used by language students to learn about usage, and the idea of creating a tool to facilitate this is not new. One example of an existing tool is Webcorp (Webcorp, 1999). Using the WWW as its corpus, Webcorp traverses links to obtain an extensive collection of relevant pages, and then it totals the search engine results. However, this tool is only available in English and is not readily applicable to languages without word segmentation. Another recent examples are found in (GoogleFight, 2000)(Peters, 2002), where the user enters two different phrases and the tool suggests which is most commonly used according to data obtained from the search engine. Although these pages allow multilingual consultation, the range of possible queries is limited because the two phrases can be compared only in terms of occurrence frequency. Our tool, Kiwi, is designed to be more general in its applicability than these existing tools in that it is language independent and allows greater query flexibility. It does this through candidate extraction and candidate ranking. Another concern that we address in this paper i</context>
</contexts>
<marker>Peters, 2002</marker>
<rawString>G. Peters. 2002. Geoff&apos;s googleduel! Available at http: !!www. sfu. ca/ gpeters/cgi-bin/pear/. Webcorp. 1999. Webcorp home page. Available at http: !!www . webcorp. org . uk/.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>