<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<title confidence="0.95233">
A step towards incremental generation of logical forms
</title>
<author confidence="0.402578">
Luisa Coheur Nuno Mamede Gabriel G. B`es
</author>
<address confidence="0.3741965">
L2F INESC-ID / GRIL L2F INESC-ID / IST GRIL / Univ. Blaise-Pascal
Lisboa, Portugal Lisboa, Portugal Clermont-Ferrand, France
</address>
<email confidence="0.710486">
Luisa.Coheur@l2f.inesc-id.pt Nuno.Mamede@inesc-id.pt Gabriel.Bes@univ-bpclermont.fr
</email>
<sectionHeader confidence="0.985234" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999747111111111">
This paper presents AsdeCopas, a module de-
signed to interface syntax and semantics. Asde-
Copas is based on hierarchically organised se-
mantic rules, that output formulas in a flat lan-
guage. In this paper, we show how this system
can be used in the following applications: a) se-
mantic disambiguation; b) logical formulas con-
struction (in Minimal Recursion Semantics); c)
question interpretation.
</bodyText>
<sectionHeader confidence="0.998799" genericHeader="keywords">
1 Introduction
</sectionHeader>
<bodyText confidence="0.999822125">
We present AsdeCopas, a syntax-semantic in-
terface based on hierarchically organised rules.
AsdeCopas is integrated in a system where
the input text is first transformed into a graph
and then passed to AsdeCopas. AsdeCopas can
be used in several ways.
It can be used to enrich the graph (Figure 1),
for example, by labeling its arrows.
</bodyText>
<figureCaption confidence="0.998028">
Figure 1: Enriching the graph
</figureCaption>
<bodyText confidence="0.998948">
It can be used in a desambiguation process
and to generate logical formulas. In this paper
we show how AsdeCopas can be used to choose
between several semantic values of some quan-
tifiers and also how it can generate underspec-
ified formulas in Minimal Recursion Semantics
(MRS) (Copestake et al., 2001). Additionally,
it can be used to add constraints to these under-
specified formulas. As AsdeCopas makes a con-
troled generation of variables, these new formu-
las can be simply added to the previous under-
specified MRS formulas and the rules respon-
sible for generating MRS underspecified struc-
tures remain unchangeable.
</bodyText>
<figureCaption confidence="0.992129">
Figure 2: Desambiguation
</figureCaption>
<bodyText confidence="0.999497166666667">
Notice that in all the applications, AsdeCopas
could previously be used to enrich the graph and
the rules used in each task should take it into
consideration.
This paper is organised as follows: we start
with the motivation for this work. Then, in sec-
tion 3, we present our approach. This includes a
description of the semantic rules formalism and
a brief overview of the algorithm behind Asde-
Copas. In section 4 we introduce some applica-
tions. Final remarks and future directions can
be found in section 5.
</bodyText>
<sectionHeader confidence="0.993379" genericHeader="introduction">
2 Motivation
</sectionHeader>
<bodyText confidence="0.994132217391304">
In 1992, an exhaustive study of the Portuguese
tourist resources was made by the Direc¸c˜ao
Geral de Turismo (DGT) and afterwards the
Inventory of Tourist Resources (IRT) emerged.
In order to access it, multimedia “kiosks” were
developed and a system called Edite (da Silva,
1997; Reis et al., 1997; da Silva et al., 1997) was
created with the purpose of being integrated in
these “kiosks” and to allow database access us-
ing natural language. Edite had a set of linguis-
tically motivated traditional modules (semantic
rules associated with syntactic rules, bottom-up
parser, and so on) and it soon became saturated:
adding a new syntactic rule caused dramatic
side effects, a new semantic value could dupli-
cate the number of generated formulas, etc. It
was this experiment that made us change our
approach and invest in a more robust method-
ology. We found in the 5P Paradigm (B`es, 1999;
B`es and Hag`ege, 2001; Hag`ege, 2000) the back-
ground we were looking for and the syntax-
semantic interface presented in this paper re-
flects the effort of adapting to a more robust
methodology.
Many systems base their interface in rules,
that according to (A¨ıt-Mokhtar et al., 2002)
“encode hypothetical local interpretations of
sub-strings, yet to be validated by the produc-
tion of a full parse”. This is typically what hap-
pens to syntactic-semantic bottom-up parsers
where each semantic rule is associated with a
syntactic rule. Even if these systems do not
fail when a sub-string interpretation fails, their
parsers need to deal with a combinatory explo-
sion of multiple interpretations of words, even if
syntactic conditions would allow precise values
to be chosen. This is due to the fact that at each
step there is not a whole vision of the (syntac-
tic) context. An additional effect of not having
access to context is that spurious ambiguities
are produced.
As an example, consider the Portuguese word
qualquer (roughly, any), which can take several
semantic values (see (M´oia, 1992) for a detailed
discussion about the multiple interpretations of
qualquer):
</bodyText>
<listItem confidence="0.998968357142857">
• In Qualquer c˜ao gosta de ossos (All dogs
like bones) it has an universal value (univ);
• In Ele tem qualquer problema (There is
some problem with him) it has an existen-
tial value (exist);
• In Ele e´ um jornalista qualquer (He is an
insignificant journalist) it is an adjective,
and it means something like with no rele-
vant characteristics in the class denoted by
the noun it qualifies. We will denote this
semantic value as indiscriminate;
• In Ele n˜ao e´ um jornalista qualquer (He is
not an insignificant journalist) it has the
same indiscriminate value.
</listItem>
<bodyText confidence="0.99821325">
Let us assume that on the right of a main verb
in the scope of negation, qualquer can only take
the indiscriminate semantic value. Typically,
in a bottom-up parsing (Figure 3) we will not be
able to discard unnecessary values, as in point
(1), when finally we have the whole vision of
the subtree, the semantic rule will not take into
consideration the negation inside V.
</bodyText>
<figureCaption confidence="0.95266">
Figure 3: Grammar and qualquer example
</figureCaption>
<bodyText confidence="0.999113973684211">
Another kind of interface can be found in
systems such as ExtrAns (Moll´a et al., 2003),
where the syntax-semantic interface is executed
over dependencies. According to (Moll´a and
Hutchinson, 2002), the current version of Ex-
trAns uses either Link Grammar or the Conexor
FDG parser.
In the first situation, the logical-form is con-
structed by a top-down procedure, starting in
the head of the main dependency and follow-
ing dependencies. The algorithm is prepared
to deal with a certain type of dependencies,
and whenever an unexpected link appears, a
special recovery treatment is applied. When
describing the algorithm, the authors say that
most of these steps “... become very complex,
sometimes involving recursive applications of
the algorithm” and also that “specific partic-
ularities of the dependency structures returned
by Link Grammar add complexity to this pro-
cess” (Moll´a and Hutchinson, 2002).
In the Conexor FDG case, the bottom up
parser used has three stages. In the first one (in-
trospection) possible underspecified predicates
are associated with each word. Object predi-
cates introduce their own arguments, but other
predicates remain incomplete until the second
stage (extrospection). During extrospection,
arguments are filled by examing the relation
between each word and its head. Sometimes
dummy arguments need to be assigned when
the algorithm faces disconnected dependency
structures. A third stage (re-interpretation) is
needed to re-analyse some logical constructs.
According to the authors, the algorithm can-
not produce the correct argument structure for
long distance dependencies.
As we will see, within AsdeCopas:
</bodyText>
<listItem confidence="0.996705285714286">
• rules allow to identify semantic values that
depend on the context;
• the algorithm itself is independent from the
utilised dependency structures. Only se-
mantic rules have to be adapted to the de-
pendency structures;
• there is no need to recursively apply the al-
gorithm or to create dummy arguments due
to disconnected dependency structures: in
these situations, default rules are triggered;
• long distance dependencies cause no prob-
lem as rules are sensitive for the (possibly
non-local) syntactic context;
• all words, independently from their cate-
</listItem>
<bodyText confidence="0.5553315">
gory, are mapped into formulas in one step:
since rules are self-contained, they contain
all the necessary information to calculate
the corresponding formula.
</bodyText>
<sectionHeader confidence="0.91223" genericHeader="method">
3 Our approach
</sectionHeader>
<subsectionHeader confidence="0.999851">
3.1 Brief overview
</subsectionHeader>
<bodyText confidence="0.999848972972973">
A¨ıt-Mokhtar (A¨ıt-Mokhtar et al., 2002) defines
an incremental rule as “a self-contained oper-
ation, whose result depends on the set of con-
textual restrictions stated in the rule itself. [...]
If a sub-string matches the contextual restric-
tions, the corresponding operation applies with-
out later backtracking” . This is the gold prop-
erty we achieved for our semantic rules.
Now the question is: how are we going to de-
fine an incremental rule if in our output we have
predicates sharing variables, scope relations to
define, and so on? We propose a solution based
on the following:
• we split each rule in three parts: a) the ele-
ment or elements to transform (notice that
each rule can transform more than one el-
ement); b) the context of the elements to
transform (it can be seen as a set of condi-
tions that, being verified, indicate that the
rule can be applied); c) the output (spec-
ified by a set of functions that will trans-
form the elements according to the chosen
representation).
• we assume that there is a set of fixed vari-
ables associated with each word. Each vari-
able has the position the word occupies in
the text as index. As a result, if two ele-
ments are connected (directly or not) they
know each other variables, and they can be
used to build their formulas.
Moreover, in order to incrementally add new
information to our system without having to
rewrite more general rules, semantic rules are
organised in a subsumption hierarchy. As a re-
sult, if a set of rules can be applied, only the
rules that do not subsume other rules are trig-
gered.
</bodyText>
<subsectionHeader confidence="0.9974635">
3.2 Semantic rules
3.2.1 Syntax
</subsectionHeader>
<bodyText confidence="0.9452">
Let W be a set of words, C a set of category
labels, D a set of dependency labels and is
used to represent an underspecified value.
Element: elem(w, c) is an element, where:
</bodyText>
<listItem confidence="0.999821">
• w E { } U W;
• c E { } U C.
</listItem>
<bodyText confidence="0.513408333333333">
Arrow: arrow(c1, c2, d, l) is a dependency, and
no arrow(c1, c2, d, l) a non existing depen-
dency where:
</bodyText>
<listItem confidence="0.975970529411765">
• c1, c2 E C (c1 and c2 are, respectively,
the source and the target);
• d E { } U {L, R} (d is the dependency
orientation: L if it goes from right to
left, R from left to right);
• l E { } U D (l is a possibly undefined
dependency label).
Semantic Rule: [RZ] Σ : Θ H r is a semantic
rule where:
• Σ is a possibly empty set of elements
(the elements to operate on);
• Θ is a possible empty set of exist-
ing and non existing dependencies (the
rule’s context);
• r is a set of functions, that vary ac-
cording to the chosen representation
language.
</listItem>
<bodyText confidence="0.995853666666667">
Extra constraints over semantic rules syntax
can be found in (Coheur et al., 2003b; Coheur,
2004).
</bodyText>
<subsectionHeader confidence="0.986161">
3.2.2 Hierarchy of rules
</subsectionHeader>
<bodyText confidence="0.999929857142857">
In the following we define the subsumption re-
lation between semantic rules. This relation es-
tablishes the hierarchy of rules and it is based
on the subsumption relation between categories.
Although we use labels to represent categories,
each category is a set of attribute/value pairs
organized in a subsumption hierarchy.
</bodyText>
<equation confidence="0.949805444444444">
Element subsumption: Given
e1 = elem(w1, c1) and e2 = elem(w2, c2)
from Σ, e1 subsumes e2 (e1 ve e2) iff:
• c1 v c2;
• (w1 =6 ) ⇒ (w2 = w1).
Dependency subsumption: Given a1 = ar-
row(c1, c2, d1, l1) and a2 = ar-
row(c3, c4, d2, l2) from Θ, a1 subsumes a2
(a1 va a2) iff:
</equation>
<listItem confidence="0.746659333333333">
• c1 v c3 ∧ c2 v c4;
• (d1 =6 ) ⇒ (d2 = d1);
• (l1 =6 ) ⇒ (l2 = l1).
</listItem>
<bodyText confidence="0.949365">
Subsumption of non existing dependencies:
Given a1 = no arrow(c1, c2, d1, l1) and
a2 = no arrow(c3, c4, d2, l2) from Θ, a1
subsumes a2 (a1 va a2) iff:
</bodyText>
<listItem confidence="0.99373025">
• c1 v c3 ∧ c2 v c4;
• (d1 =6 ) ⇒ (d2 = d1);
• (l1 =6 ) ⇒ (l2 = l1).
Rule subsumption: Given two semantic rules
R1 = (Σ1, Θ1, F1) and R2 = (Σ2, Θ2, F2),
R1 subsumes R2 (R1 vr R2) iff:
• (∀ e1 ∈ Σ1)(∃ e2 ∈ Σ2) (e1 ve e2);
• (∀ a1 ∈ Θ1)(∃ a2 ∈ Θ2)(a1 va a2).
</listItem>
<bodyText confidence="0.999661666666667">
Finally, if R1 subsumes R2, R2 is said to be
more specific than R1. If both rules can apply,
only the most specific rule does so.
</bodyText>
<subsectionHeader confidence="0.998712">
3.3 AsdeCopas
</subsectionHeader>
<bodyText confidence="0.9998278">
AsdeCopas is integrated in a system called
Javali (Coheur et al., 2003a), where a module
called Ogre (Coheur, 2004) generates a graph,
which is AsdeCopas’ input. Given the ques-
tion Qual a maior praia do Algarve(Which is
the largest beach in Algarve?), the following fig-
ure shows the graph generated by Ogre:
Each graph node is a triple, representing: a) a
word; b) its associated category; c) its position
(in the text). Each graph arrow is also a triple,
</bodyText>
<figureCaption confidence="0.989707">
Figure 4: Ogre’s output.
</figureCaption>
<bodyText confidence="0.99562">
maintaining information about: a) the position
associated with the source node; b) the position
associated with the target node; c) the arrow
label (possibly undefined)1.
AsdeCopas is implemented in Prolog. It goes
through each graph node and:
</bodyText>
<listItem confidence="0.994568333333333">
• identifies the rules that can be applied;
• chooses the most specific rules;
• triggers the most specific rules.
</listItem>
<bodyText confidence="0.999907928571429">
Then it continuous to the next node. Notice
that since rules are self-contained, the way it
goes through the graph and the order of rule’s
application is not relevant, and results remain
the same. Notice also, that at each step more
than one rule can be triggered.
AsdeCopas is responsible for variable genera-
tion. Thus, instead of randomly generating vari-
ables, each variable is indexed by the position
that the related word occupies in the text. Al-
though apparently naive, this is an important
feature of our system which allows different se-
mantic processes to run at different times and
results to be merged at the end.
</bodyText>
<sectionHeader confidence="0.95903" genericHeader="method">
4 Case studies
</sectionHeader>
<bodyText confidence="0.9999459">
We present three applications. First we show
how AsdeCopas can be used in a disambigua-
tion process. Then we use it to build formulas
in MRS (Copestake et al., 2001). Finally, we
present an application where AsdeCopas gener-
ates logical forms from questions. Quantifica-
tion is ignored in this last task.
Notice, however, that in order to have a se-
rious evaluation of AsdeCopas capabilities, it
needs to be applied to more demanding tasks.
</bodyText>
<subsectionHeader confidence="0.976288">
4.1 Disambiguation process
</subsectionHeader>
<bodyText confidence="0.997080833333333">
Consider again the quantifier qualquer. As we
saw, it can take several semantic values. Some-
times the syntactic context allows to limit these
&apos;Within our applications, dependencies are unla-
belled, and go from dependents to the head. The motiva-
tion behind these structures came from the 5P Paradigm.
possibilities. In some situations, one semantic
value can be chosen, allowing a full desambigua-
tion.
Let us assume that all is an underspeci-
fied value (Poesio, 1994) representing all of the
semantic values. If no desambiguation takes
place, this is the value that will represent this
word’s semantics. Alternatively, we could opt
for a default value. For example, the universal
value since it is the most common.
Let us opt for the universal default value.
We can write a default rule, as the following:
</bodyText>
<listItem confidence="0.4873675">
[R1] {elem(qualquer, qt)} : ∅
H {sem(qt) = univ}
</listItem>
<bodyText confidence="0.942163833333333">
Assuming again, as we did in section 2,
that on the right of the main verb in the
scope of negation, qualquer takes the value
indiscriminate the following rule allows to
choose the correct value for qualquer in that
context:2
</bodyText>
<equation confidence="0.9373452">
[R2] {elem(qualquer, qt)}
: {arrow(qt, n, L, ),
arrow(n, v, L, ),
arrow(neg, v, R, )}
H {sem(qt) = indiscriminate}
</equation>
<bodyText confidence="0.999436857142857">
R2 is more specific than rule R1, thus it is
applied in these particular conditions. In order
to disambiguate, or at least to limit semantic
values, other semantic rules would have to be
added.
Consider now the Portuguese quantifier
algum. When it appears on the left side of a
noun (n), it means “some” (some). On the right
side it means “none” (none), unless it is in the
scope of negation. In this particular situation
it has an universal value. The following rules
allow the right values to be chosen – in this
particular situations – for this quantifier (notice
that rule R5 is more specific than rule R4):
</bodyText>
<listItem confidence="0.991699333333333">
[R3] {elem(algum, qt)}
: {arrow(qt, n, R, )}
H {sem(qt) = some}
</listItem>
<footnote confidence="0.9893004">
2We assume that the object with category n arrowing
an object with category v is the same object with cat-
egory n that receives an arrow from a qt. An index is
used when we need to distinguish two different objects
with the same category.
</footnote>
<listItem confidence="0.942376333333333">
[R4] {elem(algum, qt)}
: {arrow(qt, n, L, )}
H {sem(qt) = none}
[R5] {elem(algum, qt)}
: {arrow(qt, n, L, )
arrow(n, v, L, )
</listItem>
<equation confidence="0.6762015">
arrow(neg, v, , )}
H {sem(qt) = every}3
</equation>
<bodyText confidence="0.9995915">
A precise study of the disambiguation of the
word qualquer can be found in (Coheur, 2003)
and (Coheur, 2004), where we try to go as far
as possible in the disambiguation process of this
word (an some paraphrases of it), by using its
syntactic context. Obviously, there are limits
to this task, as in some situations information
from semantics and pragmatics should also be
taken into account to find the correct semantic
value.
</bodyText>
<subsectionHeader confidence="0.9338445">
4.2 Logical forms generation
4.2.1 Minimal Recursion Semantics
</subsectionHeader>
<bodyText confidence="0.999753023255814">
Linking syntax with semantics is not an easy
task. As Allen says in (Allen, 1995) there seems
to be a structural inconsistency between syn-
tactic structure and the structure of the logical
form.
We can ease this process by using an ad-
equate representation language. In fact, al-
though the concept is not new (Hobbs, 1983),
state of the art frameworks such as (Moll´a et
al., 2003; Baldridge and Kruijff, 2002) are using
flat semantic representations, taht is formulas
with no embedded structures (see (Moll´a, 2000)
for details about flatness), which simplify the
syntactic-semantic interface. At the same time,
and because it is not reasonable to generate all
the possible interpretations of a sentence, many
frameworks are using representation languages
that leave underspecified semantic interpreta-
tions (also an old concept (Woods, 1978)).
MRS (Copestake et al., 2001) uses a flat rep-
resentation with explicit pointers (called han-
dles) to encode scope effects, corresponding to
recursive structures in more conventional formal
semantic representations.
We have chosen this language because it has
three fundamental characteristics: a) it is a flat
language; b) it allows the treatment of quan-
tification; c) it allows underspecification. Un-
3Notice, that by choosing the universal value, in the
final formula this quantifier will no longer be in the scope
of negation.
derspecified MRS structures can be converted
into scope-resolved structures that, according to
(Copestake et al., 1997), “correspond to those
obeyed by a conventionally written bracketed
structure”.
As an example, MRS represents Qualquer
menino adora algum c˜ao(Every boy adores
some dog) in the following underspecified struc-
ture (the =q constraint stands for the equality
modulo quantifiers and relates a handle in an
argument position to a label (Copestake et al.,
2001)):
</bodyText>
<equation confidence="0.9977962">
top p4
h1:every(x, r1, n), h3:menino(x),
r1 =q h3, h7:c~ao(y),
h5:some(y, r5, m), r5 =q h7,
h4:adora(e, x, y)
</equation>
<bodyText confidence="0.950623">
where h1 outscopes h3 and h5 outscopes h7.
Then, by means of a set of constraints, such
that an MRS structure must be a tree, there
should be a unique top-level handle, etc., the
following readings are obtained:
p=h1 (wide scope “every”)
</bodyText>
<equation confidence="0.811356428571429">
h1:every(x, h3, h5), h3:menino(x),
h5:some(y, h7, h4), h7:c~ao(y),
h4:adora(e, x, y)
p=h5 (wide scope “some”),
h5:some(y, h7, h1), h7:c~ao(y),
h1:every(x, h3, h4), h3:menino(x),
h4:adora(e, x, y)
</equation>
<bodyText confidence="0.999229">
In the next section we will show how to reach
these formulas.
</bodyText>
<subsubsectionHeader confidence="0.602164">
4.2.2 Toy example
</subsubsectionHeader>
<bodyText confidence="0.999300454545455">
We will show how to reach an underspeci-
fied MRS representation for constructions as
Qualquer67 menino68 adora69 a70 Maria715
and Qualquer678 menino679 adora680 algum681
c˜ao682. Notice that, for expository reasons,
we are simplifying the process. Actual rules
use fine grained categories for quantifiers,
and scope restrictions are imposed differently
(Coheur, 2004).
In order to perform this task we use the fol-
lowing functions:
</bodyText>
<footnote confidence="0.997238">
4p is the variable over the top.
5Every boy adores Maria
</footnote>
<listItem confidence="0.999178">
• sem returns a (default) predicate
ex: sem(Maria) = Maria6;
• var returns a variable
ex: var(Maria) = x71;
• handle returns a variable for an handle
ex: handle(Maria) = h71;
• restrictor returns a variable for a restrictor
ex: restrictor(Maria) = r71;
• scope returns a scope variable
ex: scope(Maria) = s71.
</listItem>
<bodyText confidence="0.969283555555556">
The following rule applies to nouns, either
common nouns (nc) or proper nouns (npr),
everytime it finds one (because the arrow set is
empty).
[R1]felem( , n)}
: 0
H fhandle(n): sem(n)(var(n)}
If only this rule is defined, the first sentence
is translated into:
</bodyText>
<equation confidence="0.921114">
h68:menino(x68)
h71:Maria(x71)
</equation>
<bodyText confidence="0.862323">
and the second sentence into:
</bodyText>
<equation confidence="0.8592065">
h679:menino(x679)
h682:c~ao(x682)
</equation>
<bodyText confidence="0.874981939393939">
Nonetheless, h71:Maria(x71) is not the
representation we want for Maria. Instead
we use the predicate NAME. Thus, we define
R2, subsumed by R1 (because n E npr), and
consequently more specific.
[R2]felem( , npr)}
: 0
H fhandle(npr):NAME(var(npr), sem(npr))}
Rule R2 is triggered instead of R1 and we
obtain for the first sentence
h71:NAME(x71, Maria)
instead of
h71:Maria(x71).
6Although these values can be obtained in a lexi-
con, in this application they are generated from sentence
words.
Notice that a new rule needs to be de-
fined for the situations where the npr arrows
an nc and not a v, since we want to trans-
late m˜ae807 Maria81 into m~ae(x80), NAME(x80,
Maria) and not into m~ae(x80), NAME(x81,
Maria). In order to do this, we need only to
add a rule for npr (like the previous rule) to be
applied when a npr arrows an nc. This rule, be-
ing more specific than rule R2, is applied in this
particular situation. As the npr is connected
with the nc, it “knows” its variable, which can
be used is the associated formula.
The next rule is applied to a verb (v) when
the verb has an n arrowing from left (typically
the subject) and an n arrowing from right
(typically the direct object), and no preposition
arrows these nouns.
</bodyText>
<equation confidence="0.8839905">
[R3]felem( , v)}
: farrow(nZ, v, R, ),
arrow(nj, v, L, ),
no arrow(prep, nZ, R),
no arrow(prep, nj, R)}
H fhandle(v):sem(v)(var(v),var(nZ), var(nj))}
</equation>
<bodyText confidence="0.942600041666667">
As a result, in the first sentence, adora is
translated into:
h69:adora(x69, x68, x71)
and, in the second one, it is translated into:
h680:adora(x680, x679, x682).
Notice that, at this point, although we don’t
have rules for all the elements within the
example sentences, we already have a partial
representation.
Consider now, a generic rule for quantifiers
(qt):
[R4] felem( ,qt)}
: farrow(qt, nc, , )}
H fhandle(qt): sem(qt)(var(nc), restrictor(qt),
scope(qt)), restrictor(qt) =q handle(nc)}
Now, the results depend on previous process-
ing: if the disambiguation task described in the
previous section was performed, sem(qualquer)
= every and sem(algum) = some. Otherwise,
underspecified values are used.
7mother.
Let us consider that the disambiguation
stage took place before. Thus, this rule adds to
the first sentence:
</bodyText>
<equation confidence="0.886398">
h67: every(x68, r67, s67),
r67 =q h68
</equation>
<bodyText confidence="0.940698">
and to the second sentence:
</bodyText>
<equation confidence="0.964914">
h678: every(x679, r678, s678),
r678 =q h679
</equation>
<bodyText confidence="0.651227">
and
</bodyText>
<equation confidence="0.9746735">
h681: some(x682, r681, s681),
r681 =q h682.
</equation>
<bodyText confidence="0.999803">
Notice that we reach the underspecified for-
mula from 4.2.1 for the first sentence.
We will conclude now this example. It should
be clear that additional rules could impose ex-
tra constraints to the formula, avoiding spurious
ambiguities.
</bodyText>
<subsectionHeader confidence="0.998863">
4.3 Question interpretation
</subsectionHeader>
<bodyText confidence="0.99990845">
From system Edite we inherited a corpus of
680 questions about tourist resources and we
made a preliminar evaluation over 30 questions.
There was no pre-processing of these questions,
no compound terms were detected, no mistakes
were corrected.
Let “correct representation” be a set of for-
mulas representing a question, where the exact
number of expected predicates are produced,
and variables are in the correct places.
Let “system representation” be the set of for-
mulas that the system suggests as the question
representation. Each question can have more
than one “system representation”. Moreover,
a correct “system representation” is a “system
representation” that is equal to the “correct rep-
resentation”.
A general evaluation (of the whole system)
results in a precision of 0,19 (number of correct
“system representations”/number of total “sys-
tem representations”) and a recall of 0,77 (num-
ber of correct “system representations”/30). If
we eliminate two particularly bad results (one
associated 42 “system representations” to a
question and the other 21), we have a precision
of 0,37.
The low precision results from previous
stages, as several graphs are associated with
each question. In fact, with the actual set of
semantic rules only one representation is asso-
ciated with each graph.
Nevertheless, the analysis is not over. The
majority of “system representations” produced
by AsdeCopas are just incomplete and result
from unknown words. For example, the state-
ment Quais os roteiros pedestres sinalizados
em Lisboa?(Which are the signalised footways
in Lisbon?), originated the following formula,
where AM is the predicate for adjectival modifi-
cation and ? indicates the focus of the question:
</bodyText>
<equation confidence="0.9804368">
?x759
roteiros(x759)
AM(x759, x760), pedestres(x760)
em(x759, x763)
NAME(x763, Lisboa)
</equation>
<bodyText confidence="0.999775">
As the word sinalizados was not recognised,
the “system representation” is not correct, be-
cause a predicate associated with this word is
missing. Nevertheless, most of the information
contained in the question is retrieved.
Within AsdeCopas framework a special ef-
fort was made with paraphrastic relations. As
an example, both phrases Quais os hot´eis com
piscina?(Which are the hotels with a swimming
pool?) and Em que hot´eis h´a piscina?(In which
hotels is there a swimming pool?), result in the
following formulas:
</bodyText>
<equation confidence="0.95484225">
?x22
hot´eis(x22)
com(x22, x24)
piscina(x24)
</equation>
<bodyText confidence="0.9998635">
Note that in order to reach this result, we had
just to look into the particular syntactic condi-
tions that make verb haver (to have) behave as
the preposition com (with).
</bodyText>
<sectionHeader confidence="0.999634" genericHeader="conclusions">
5 Conclusions
</sectionHeader>
<bodyText confidence="0.9999373">
We presented AsdeCopas, a syntax-semantics
interface based on hierarchically organized se-
mantic rules. AsdeCopas is integrated in a sys-
tem called Javali and it has been applied to sev-
eral tasks. Apart from some adjustments, Asde-
Copas should be able to process any dependency
structure.
In the near future, we will have to study co-
ordination properly. We also indent to extend
our work to English.
</bodyText>
<sectionHeader confidence="0.998464" genericHeader="acknowledgments">
6 Acknowledgements
</sectionHeader>
<bodyText confidence="0.9980098">
We are greatful for the corrections of Dia-
mantino Caseiro, David Matos and S´ergio
Paulo. We also acknowledge Ricardo Ribeiro
and Rui Chaves. Finally, we thank for the use-
ful comments of this paper reviewers. As usual,
the responsability for the contents of this paper
lies with the authors alone.
This paper was supported by FCT (Funda¸c˜ao
para a Ciˆencia e Tecnologia) and by Project
POSI/PLP/41319/2001 (FEDER).
</bodyText>
<sectionHeader confidence="0.998397" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999724719298245">
Salah A¨ıt-Mokhtar, Jean-Pierre Chanod, and
Claude Roux. 2002. Robustness beyound
shallowness: incremental deep parsing. Nat-
ural Language Engineering, pages 121–144.
James Allen. 1995. Natural Language Un-
derstanding (second edition). The Benjamin
Cummings Publishing Company, Inc.
Jason Baldridge and Geert-Jan M. Kruijff.
2002. Coupling CCG and hybrid logic depen-
dency semantics. In Proceedings of the 40th
Annual Meeting of the Association for Com-
putational Linguistics (ACL), pages 319–326.
Gabriel G. B`es and Caroline Hag`ege. 2001.
Properties in 5P. Technical report, GRIL,
Universit´e Blaise-Pascal, Clermont-Ferrand,
France, November.
Gabriel G. B`es. 1999. La phrase verbal noyau
en fran¸cais. In Recherches sur le fran¸cais
parl´e, volume 15, pages 273–358. Universit´e
de Provence, France.
Luisa Coheur, Fernando Batista, and Joana
Paulo. 2003a. JaVaLI!: understanding real
questions. In EUROLAN 2003 student work-
shop: Applied Natural Language Processing,
possible applications for the Semantic Web,
Bucharest, Romania, July.
Luisa Coheur, Nuno Mamede, and Gabriel G.
B´es. 2003b. ASdeCopas: a syntactic-
semantic interface. In Fernando Moura Pires
and Salvador Abreu, editors, Progress in Ar-
tificial Intelligence: 11th Portuguese Confer-
ence on Artificial Intelligence, EPIA 2003,
volume 2902 / 2003 of Lecture Notes in Arti-
ficial Inteligence, Beja, Portugal, Dezembro.
Springer-Verlag.
Luisa Coheur. 2003. A situa¸c˜ao do “qual-
quer” em qualquer situa¸c˜ao. Technical Re-
port RT/004/03-CDIL, L2F-Laborat´orio de
Sistemas de Lingua Falada, Inesc-id, Lisboa,
Portugal, Mar¸co.
Luisa Coheur. 2004. A interface entre a sin-
taxe e a semˆantica no quadro das linguas
naturais. Ph.D. thesis, Instituto Superior
T´ecnico, Universidade T´ecnica de Lisboa,
Portugal, Universit´e Blaise-Pascal, France.
work in progress.
Ann Copestake, Dan Flickinger, and Ivan A.
Sag. 1997. Minimal recursion semantics: An
introduction (draft).
Ann Copestake, Dan Flickinger, Carl Pollard,
and Ivan A. Sag. 2001. Minimal recursion
semantics: An introduction. LVC, 1(3):1–47.
Luisa Marques da Silva, Nuno Mamede, and
David Matos. 1997. Edite - um sistema de
acesso a uma base de dados em linguagem
natural. In Workshop sobre taggers para o
portuguˆes, pages 20–33, Lisboa, Portugal. In-
stituto de Linguistica Te´orica e Computa-
cional.
Luisa Marques da Silva. 1997. Edite, um sis-
tema de acesso a base de dados em linguagem
natural, an´alise morfol´ogica, sint´actica e
semˆantica. Master’s thesis, Instituto Supe-
rior T´ecnico, Universidade T´ecnica de Lisboa,
Portugal.
Caroline Hag`ege. 2000. Analyse Syntatic
Automatique du Portugais. Ph.D. thesis,
Universit´e Blaise Pascal, Clermont-Ferrand,
France.
Jerry R. Hobbs. 1983. An improper treatment
of quantification in ordinary english. In 21st
Annual Meeting of the Association for Com-
putational Linguistics (ACL).
Telmo M´oia. 1992. Aspectos da Semˆantica do
Operador Qualquer (Cadernos de Semˆantica
n° 5). Faculdade de Letras da Universidade
de Lisboa.
Diego Moll´a. 2000. Ontologically promiscu-
ous flat logical forms for NLP. In IWCS-4,
Tilburg, The Netherlands.
Diego Moll´a and Ben Hutchinson. 2002.
Dependency-based semantic interpretation
for answer extraction. In Proceedings of
the Australasian NLP Workshop (ANLP’02),
Canberra.
Diego Moll´a, Rolf Schwitter, Fabio Rinaldi,
James Dowdall, and Michael Hess. 2003.
Extrans: Extracting answers from techni-
cal texts. IEEE Intelligent Systems, 18(4),
July/August.
M. Poesio. 1994. Ambiguity, underspeci-
fication and discourse interpretation. In
R. A. Muskens H. Bunt and G. Rentier
(eds.), editors, Proceedings of the First In-
ternational Workshop on Computational Se-
mantics, pages 151–160. ”ITK, Tilburg Uni-
versity”.
Paulo Reis, J. Matias, and Nuno Mamede.
1997. Edite - a natural language inter-
face to databases: a new dimension for
an old approach. In Proceedings of the
Fourth International Conference on Infor-
mation and Communication Technology in
Tourism (ENTER’97), pages 317–326, Edin-
burgh, Esc´ocia. Springer-Verlag, Berlin, Ger-
many.
W. A. Woods. 1978. Semantics and quantifica-
tion in natural language question answering.
In M. Yovitz, editor, Advance in Comput-
ers, volume 17. New York: Academic Press.
Reprinted in Readings in Natural Language
Processing, edited by B. Grosz, K. Jones and
B. Webber and published by Morgan Kauf-
mann Publishers, Inc. in 1986.
</reference>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.526072">
<title confidence="0.997334">A step towards incremental generation of logical forms</title>
<author confidence="0.999178">Luisa Coheur Nuno Mamede Gabriel G B`es</author>
<affiliation confidence="0.935652">INESC-ID / GRIL INESC-ID / IST GRIL / Univ. Blaise-Pascal Lisboa, Portugal Lisboa, Portugal Clermont-Ferrand,</affiliation>
<address confidence="0.625858">Luisa.Coheur@l2f.inesc-id.pt Nuno.Mamede@inesc-id.pt Gabriel.Bes@univ-bpclermont.fr</address>
<abstract confidence="0.9920992">This paper presents AsdeCopas, a module designed to interface syntax and semantics. Asde- Copas is based on hierarchically organised semantic rules, that output formulas in a flat language. In this paper, we show how this system can be used in the following applications: a) semantic disambiguation; b) logical formulas construction (in Minimal Recursion Semantics); c) question interpretation.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Salah A¨ıt-Mokhtar</author>
<author>Jean-Pierre Chanod</author>
<author>Claude Roux</author>
</authors>
<title>Robustness beyound shallowness: incremental deep parsing. Natural Language Engineering,</title>
<date>2002</date>
<pages>121--144</pages>
<marker>A¨ıt-Mokhtar, Chanod, Roux, 2002</marker>
<rawString>Salah A¨ıt-Mokhtar, Jean-Pierre Chanod, and Claude Roux. 2002. Robustness beyound shallowness: incremental deep parsing. Natural Language Engineering, pages 121–144.</rawString>
</citation>
<citation valid="true">
<authors>
<author>James Allen</author>
</authors>
<title>Natural Language Understanding (second edition).</title>
<date>1995</date>
<publisher>The Benjamin Cummings Publishing Company, Inc.</publisher>
<contexts>
<context position="16223" citStr="Allen, 1995" startWordPosition="2797" endWordPosition="2798">arrow(neg, v, , )} H {sem(qt) = every}3 A precise study of the disambiguation of the word qualquer can be found in (Coheur, 2003) and (Coheur, 2004), where we try to go as far as possible in the disambiguation process of this word (an some paraphrases of it), by using its syntactic context. Obviously, there are limits to this task, as in some situations information from semantics and pragmatics should also be taken into account to find the correct semantic value. 4.2 Logical forms generation 4.2.1 Minimal Recursion Semantics Linking syntax with semantics is not an easy task. As Allen says in (Allen, 1995) there seems to be a structural inconsistency between syntactic structure and the structure of the logical form. We can ease this process by using an adequate representation language. In fact, although the concept is not new (Hobbs, 1983), state of the art frameworks such as (Moll´a et al., 2003; Baldridge and Kruijff, 2002) are using flat semantic representations, taht is formulas with no embedded structures (see (Moll´a, 2000) for details about flatness), which simplify the syntactic-semantic interface. At the same time, and because it is not reasonable to generate all the possible interpret</context>
</contexts>
<marker>Allen, 1995</marker>
<rawString>James Allen. 1995. Natural Language Understanding (second edition). The Benjamin Cummings Publishing Company, Inc.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jason Baldridge</author>
<author>Geert-Jan M Kruijff</author>
</authors>
<title>Coupling CCG and hybrid logic dependency semantics.</title>
<date>2002</date>
<booktitle>In Proceedings of the 40th Annual Meeting of the Association for Computational Linguistics (ACL),</booktitle>
<pages>319--326</pages>
<contexts>
<context position="16549" citStr="Baldridge and Kruijff, 2002" startWordPosition="2851" endWordPosition="2854">re limits to this task, as in some situations information from semantics and pragmatics should also be taken into account to find the correct semantic value. 4.2 Logical forms generation 4.2.1 Minimal Recursion Semantics Linking syntax with semantics is not an easy task. As Allen says in (Allen, 1995) there seems to be a structural inconsistency between syntactic structure and the structure of the logical form. We can ease this process by using an adequate representation language. In fact, although the concept is not new (Hobbs, 1983), state of the art frameworks such as (Moll´a et al., 2003; Baldridge and Kruijff, 2002) are using flat semantic representations, taht is formulas with no embedded structures (see (Moll´a, 2000) for details about flatness), which simplify the syntactic-semantic interface. At the same time, and because it is not reasonable to generate all the possible interpretations of a sentence, many frameworks are using representation languages that leave underspecified semantic interpretations (also an old concept (Woods, 1978)). MRS (Copestake et al., 2001) uses a flat representation with explicit pointers (called handles) to encode scope effects, corresponding to recursive structures in mor</context>
</contexts>
<marker>Baldridge, Kruijff, 2002</marker>
<rawString>Jason Baldridge and Geert-Jan M. Kruijff. 2002. Coupling CCG and hybrid logic dependency semantics. In Proceedings of the 40th Annual Meeting of the Association for Computational Linguistics (ACL), pages 319–326.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Gabriel G B`es</author>
<author>Caroline Hag`ege</author>
</authors>
<date>2001</date>
<booktitle>Properties in 5P. Technical report, GRIL, Universit´e Blaise-Pascal,</booktitle>
<location>Clermont-Ferrand, France,</location>
<marker>B`es, Hag`ege, 2001</marker>
<rawString>Gabriel G. B`es and Caroline Hag`ege. 2001. Properties in 5P. Technical report, GRIL, Universit´e Blaise-Pascal, Clermont-Ferrand, France, November.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Gabriel G B`es</author>
</authors>
<title>La phrase verbal noyau en fran¸cais. In Recherches sur le fran¸cais parl´e,</title>
<date>1999</date>
<booktitle>Universit´e de Provence,</booktitle>
<volume>15</volume>
<pages>273--358</pages>
<location>France.</location>
<marker>B`es, 1999</marker>
<rawString>Gabriel G. B`es. 1999. La phrase verbal noyau en fran¸cais. In Recherches sur le fran¸cais parl´e, volume 15, pages 273–358. Universit´e de Provence, France.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Luisa Coheur</author>
<author>Fernando Batista</author>
<author>Joana Paulo</author>
</authors>
<title>JaVaLI!: understanding real questions.</title>
<date>2003</date>
<booktitle>In EUROLAN</booktitle>
<location>Bucharest, Romania,</location>
<contexts>
<context position="10182" citStr="Coheur et al., 2003" startWordPosition="1706" endWordPosition="1709">c2 E C (c1 and c2 are, respectively, the source and the target); • d E { } U {L, R} (d is the dependency orientation: L if it goes from right to left, R from left to right); • l E { } U D (l is a possibly undefined dependency label). Semantic Rule: [RZ] Σ : Θ H r is a semantic rule where: • Σ is a possibly empty set of elements (the elements to operate on); • Θ is a possible empty set of existing and non existing dependencies (the rule’s context); • r is a set of functions, that vary according to the chosen representation language. Extra constraints over semantic rules syntax can be found in (Coheur et al., 2003b; Coheur, 2004). 3.2.2 Hierarchy of rules In the following we define the subsumption relation between semantic rules. This relation establishes the hierarchy of rules and it is based on the subsumption relation between categories. Although we use labels to represent categories, each category is a set of attribute/value pairs organized in a subsumption hierarchy. Element subsumption: Given e1 = elem(w1, c1) and e2 = elem(w2, c2) from Σ, e1 subsumes e2 (e1 ve e2) iff: • c1 v c2; • (w1 =6 ) ⇒ (w2 = w1). Dependency subsumption: Given a1 = arrow(c1, c2, d1, l1) and a2 = arrow(c3, c4, d2, l2) from </context>
<context position="11507" citStr="Coheur et al., 2003" startWordPosition="1985" endWordPosition="1988">sumption of non existing dependencies: Given a1 = no arrow(c1, c2, d1, l1) and a2 = no arrow(c3, c4, d2, l2) from Θ, a1 subsumes a2 (a1 va a2) iff: • c1 v c3 ∧ c2 v c4; • (d1 =6 ) ⇒ (d2 = d1); • (l1 =6 ) ⇒ (l2 = l1). Rule subsumption: Given two semantic rules R1 = (Σ1, Θ1, F1) and R2 = (Σ2, Θ2, F2), R1 subsumes R2 (R1 vr R2) iff: • (∀ e1 ∈ Σ1)(∃ e2 ∈ Σ2) (e1 ve e2); • (∀ a1 ∈ Θ1)(∃ a2 ∈ Θ2)(a1 va a2). Finally, if R1 subsumes R2, R2 is said to be more specific than R1. If both rules can apply, only the most specific rule does so. 3.3 AsdeCopas AsdeCopas is integrated in a system called Javali (Coheur et al., 2003a), where a module called Ogre (Coheur, 2004) generates a graph, which is AsdeCopas’ input. Given the question Qual a maior praia do Algarve(Which is the largest beach in Algarve?), the following figure shows the graph generated by Ogre: Each graph node is a triple, representing: a) a word; b) its associated category; c) its position (in the text). Each graph arrow is also a triple, Figure 4: Ogre’s output. maintaining information about: a) the position associated with the source node; b) the position associated with the target node; c) the arrow label (possibly undefined)1. AsdeCopas is imple</context>
</contexts>
<marker>Coheur, Batista, Paulo, 2003</marker>
<rawString>Luisa Coheur, Fernando Batista, and Joana Paulo. 2003a. JaVaLI!: understanding real questions. In EUROLAN 2003 student workshop: Applied Natural Language Processing, possible applications for the Semantic Web, Bucharest, Romania, July.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Luisa Coheur</author>
<author>Nuno Mamede</author>
<author>Gabriel G B´es</author>
</authors>
<title>ASdeCopas: a syntacticsemantic interface.</title>
<date>2003</date>
<booktitle>Progress in Artificial Intelligence: 11th Portuguese Conference on Artificial Intelligence, EPIA 2003, volume 2902 / 2003 of Lecture Notes in Artificial Inteligence,</booktitle>
<editor>In Fernando Moura Pires and Salvador Abreu, editors,</editor>
<publisher>Springer-Verlag.</publisher>
<location>Beja, Portugal, Dezembro.</location>
<marker>Coheur, Mamede, B´es, 2003</marker>
<rawString>Luisa Coheur, Nuno Mamede, and Gabriel G. B´es. 2003b. ASdeCopas: a syntacticsemantic interface. In Fernando Moura Pires and Salvador Abreu, editors, Progress in Artificial Intelligence: 11th Portuguese Conference on Artificial Intelligence, EPIA 2003, volume 2902 / 2003 of Lecture Notes in Artificial Inteligence, Beja, Portugal, Dezembro. Springer-Verlag.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Luisa Coheur</author>
</authors>
<title>A situa¸c˜ao do “qualquer” em qualquer situa¸c˜ao.</title>
<date>2003</date>
<booktitle>L2F-Laborat´orio de Sistemas de Lingua Falada, Inesc-id,</booktitle>
<tech>Technical Report RT/004/03-CDIL,</tech>
<location>Lisboa, Portugal, Mar¸co.</location>
<contexts>
<context position="15740" citStr="Coheur, 2003" startWordPosition="2717" endWordPosition="2718">ier (notice that rule R5 is more specific than rule R4): [R3] {elem(algum, qt)} : {arrow(qt, n, R, )} H {sem(qt) = some} 2We assume that the object with category n arrowing an object with category v is the same object with category n that receives an arrow from a qt. An index is used when we need to distinguish two different objects with the same category. [R4] {elem(algum, qt)} : {arrow(qt, n, L, )} H {sem(qt) = none} [R5] {elem(algum, qt)} : {arrow(qt, n, L, ) arrow(n, v, L, ) arrow(neg, v, , )} H {sem(qt) = every}3 A precise study of the disambiguation of the word qualquer can be found in (Coheur, 2003) and (Coheur, 2004), where we try to go as far as possible in the disambiguation process of this word (an some paraphrases of it), by using its syntactic context. Obviously, there are limits to this task, as in some situations information from semantics and pragmatics should also be taken into account to find the correct semantic value. 4.2 Logical forms generation 4.2.1 Minimal Recursion Semantics Linking syntax with semantics is not an easy task. As Allen says in (Allen, 1995) there seems to be a structural inconsistency between syntactic structure and the structure of the logical form. We c</context>
</contexts>
<marker>Coheur, 2003</marker>
<rawString>Luisa Coheur. 2003. A situa¸c˜ao do “qualquer” em qualquer situa¸c˜ao. Technical Report RT/004/03-CDIL, L2F-Laborat´orio de Sistemas de Lingua Falada, Inesc-id, Lisboa, Portugal, Mar¸co.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Luisa Coheur</author>
</authors>
<title>A interface entre a sintaxe e a semˆantica no quadro das linguas naturais.</title>
<date>2004</date>
<tech>Ph.D. thesis,</tech>
<institution>Instituto Superior T´ecnico, Universidade T´ecnica de Lisboa, Portugal, Universit´e Blaise-Pascal,</institution>
<note>work in progress.</note>
<contexts>
<context position="10198" citStr="Coheur, 2004" startWordPosition="1710" endWordPosition="1711"> respectively, the source and the target); • d E { } U {L, R} (d is the dependency orientation: L if it goes from right to left, R from left to right); • l E { } U D (l is a possibly undefined dependency label). Semantic Rule: [RZ] Σ : Θ H r is a semantic rule where: • Σ is a possibly empty set of elements (the elements to operate on); • Θ is a possible empty set of existing and non existing dependencies (the rule’s context); • r is a set of functions, that vary according to the chosen representation language. Extra constraints over semantic rules syntax can be found in (Coheur et al., 2003b; Coheur, 2004). 3.2.2 Hierarchy of rules In the following we define the subsumption relation between semantic rules. This relation establishes the hierarchy of rules and it is based on the subsumption relation between categories. Although we use labels to represent categories, each category is a set of attribute/value pairs organized in a subsumption hierarchy. Element subsumption: Given e1 = elem(w1, c1) and e2 = elem(w2, c2) from Σ, e1 subsumes e2 (e1 ve e2) iff: • c1 v c2; • (w1 =6 ) ⇒ (w2 = w1). Dependency subsumption: Given a1 = arrow(c1, c2, d1, l1) and a2 = arrow(c3, c4, d2, l2) from Θ, a1 subsumes a</context>
<context position="11552" citStr="Coheur, 2004" startWordPosition="1994" endWordPosition="1995">o arrow(c1, c2, d1, l1) and a2 = no arrow(c3, c4, d2, l2) from Θ, a1 subsumes a2 (a1 va a2) iff: • c1 v c3 ∧ c2 v c4; • (d1 =6 ) ⇒ (d2 = d1); • (l1 =6 ) ⇒ (l2 = l1). Rule subsumption: Given two semantic rules R1 = (Σ1, Θ1, F1) and R2 = (Σ2, Θ2, F2), R1 subsumes R2 (R1 vr R2) iff: • (∀ e1 ∈ Σ1)(∃ e2 ∈ Σ2) (e1 ve e2); • (∀ a1 ∈ Θ1)(∃ a2 ∈ Θ2)(a1 va a2). Finally, if R1 subsumes R2, R2 is said to be more specific than R1. If both rules can apply, only the most specific rule does so. 3.3 AsdeCopas AsdeCopas is integrated in a system called Javali (Coheur et al., 2003a), where a module called Ogre (Coheur, 2004) generates a graph, which is AsdeCopas’ input. Given the question Qual a maior praia do Algarve(Which is the largest beach in Algarve?), the following figure shows the graph generated by Ogre: Each graph node is a triple, representing: a) a word; b) its associated category; c) its position (in the text). Each graph arrow is also a triple, Figure 4: Ogre’s output. maintaining information about: a) the position associated with the source node; b) the position associated with the target node; c) the arrow label (possibly undefined)1. AsdeCopas is implemented in Prolog. It goes through each graph </context>
<context position="15759" citStr="Coheur, 2004" startWordPosition="2720" endWordPosition="2721">le R5 is more specific than rule R4): [R3] {elem(algum, qt)} : {arrow(qt, n, R, )} H {sem(qt) = some} 2We assume that the object with category n arrowing an object with category v is the same object with category n that receives an arrow from a qt. An index is used when we need to distinguish two different objects with the same category. [R4] {elem(algum, qt)} : {arrow(qt, n, L, )} H {sem(qt) = none} [R5] {elem(algum, qt)} : {arrow(qt, n, L, ) arrow(n, v, L, ) arrow(neg, v, , )} H {sem(qt) = every}3 A precise study of the disambiguation of the word qualquer can be found in (Coheur, 2003) and (Coheur, 2004), where we try to go as far as possible in the disambiguation process of this word (an some paraphrases of it), by using its syntactic context. Obviously, there are limits to this task, as in some situations information from semantics and pragmatics should also be taken into account to find the correct semantic value. 4.2 Logical forms generation 4.2.1 Minimal Recursion Semantics Linking syntax with semantics is not an easy task. As Allen says in (Allen, 1995) there seems to be a structural inconsistency between syntactic structure and the structure of the logical form. We can ease this proces</context>
<context position="18977" citStr="Coheur, 2004" startWordPosition="3219" endWordPosition="3220">o(x), h5:some(y, h7, h4), h7:c~ao(y), h4:adora(e, x, y) p=h5 (wide scope “some”), h5:some(y, h7, h1), h7:c~ao(y), h1:every(x, h3, h4), h3:menino(x), h4:adora(e, x, y) In the next section we will show how to reach these formulas. 4.2.2 Toy example We will show how to reach an underspecified MRS representation for constructions as Qualquer67 menino68 adora69 a70 Maria715 and Qualquer678 menino679 adora680 algum681 c˜ao682. Notice that, for expository reasons, we are simplifying the process. Actual rules use fine grained categories for quantifiers, and scope restrictions are imposed differently (Coheur, 2004). In order to perform this task we use the following functions: 4p is the variable over the top. 5Every boy adores Maria • sem returns a (default) predicate ex: sem(Maria) = Maria6; • var returns a variable ex: var(Maria) = x71; • handle returns a variable for an handle ex: handle(Maria) = h71; • restrictor returns a variable for a restrictor ex: restrictor(Maria) = r71; • scope returns a scope variable ex: scope(Maria) = s71. The following rule applies to nouns, either common nouns (nc) or proper nouns (npr), everytime it finds one (because the arrow set is empty). [R1]felem( , n)} : 0 H fhan</context>
</contexts>
<marker>Coheur, 2004</marker>
<rawString>Luisa Coheur. 2004. A interface entre a sintaxe e a semˆantica no quadro das linguas naturais. Ph.D. thesis, Instituto Superior T´ecnico, Universidade T´ecnica de Lisboa, Portugal, Universit´e Blaise-Pascal, France. work in progress.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ann Copestake</author>
<author>Dan Flickinger</author>
<author>Ivan A Sag</author>
</authors>
<title>Minimal recursion semantics: An introduction (draft).</title>
<date>1997</date>
<contexts>
<context position="17630" citStr="Copestake et al., 1997" startWordPosition="3010" endWordPosition="3013">2001) uses a flat representation with explicit pointers (called handles) to encode scope effects, corresponding to recursive structures in more conventional formal semantic representations. We have chosen this language because it has three fundamental characteristics: a) it is a flat language; b) it allows the treatment of quantification; c) it allows underspecification. Un3Notice, that by choosing the universal value, in the final formula this quantifier will no longer be in the scope of negation. derspecified MRS structures can be converted into scope-resolved structures that, according to (Copestake et al., 1997), “correspond to those obeyed by a conventionally written bracketed structure”. As an example, MRS represents Qualquer menino adora algum c˜ao(Every boy adores some dog) in the following underspecified structure (the =q constraint stands for the equality modulo quantifiers and relates a handle in an argument position to a label (Copestake et al., 2001)): top p4 h1:every(x, r1, n), h3:menino(x), r1 =q h3, h7:c~ao(y), h5:some(y, r5, m), r5 =q h7, h4:adora(e, x, y) where h1 outscopes h3 and h5 outscopes h7. Then, by means of a set of constraints, such that an MRS structure must be a tree, there s</context>
</contexts>
<marker>Copestake, Flickinger, Sag, 1997</marker>
<rawString>Ann Copestake, Dan Flickinger, and Ivan A. Sag. 1997. Minimal recursion semantics: An introduction (draft).</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ann Copestake</author>
<author>Dan Flickinger</author>
<author>Carl Pollard</author>
<author>Ivan A Sag</author>
</authors>
<title>Minimal recursion semantics: An introduction.</title>
<date>2001</date>
<journal>LVC,</journal>
<volume>1</volume>
<issue>3</issue>
<contexts>
<context position="1388" citStr="Copestake et al., 2001" startWordPosition="209" endWordPosition="212">erface based on hierarchically organised rules. AsdeCopas is integrated in a system where the input text is first transformed into a graph and then passed to AsdeCopas. AsdeCopas can be used in several ways. It can be used to enrich the graph (Figure 1), for example, by labeling its arrows. Figure 1: Enriching the graph It can be used in a desambiguation process and to generate logical formulas. In this paper we show how AsdeCopas can be used to choose between several semantic values of some quantifiers and also how it can generate underspecified formulas in Minimal Recursion Semantics (MRS) (Copestake et al., 2001). Additionally, it can be used to add constraints to these underspecified formulas. As AsdeCopas makes a controled generation of variables, these new formulas can be simply added to the previous underspecified MRS formulas and the rules responsible for generating MRS underspecified structures remain unchangeable. Figure 2: Desambiguation Notice that in all the applications, AsdeCopas could previously be used to enrich the graph and the rules used in each task should take it into consideration. This paper is organised as follows: we start with the motivation for this work. Then, in section 3, w</context>
<context position="13079" citStr="Copestake et al., 2001" startWordPosition="2253" endWordPosition="2256"> remain the same. Notice also, that at each step more than one rule can be triggered. AsdeCopas is responsible for variable generation. Thus, instead of randomly generating variables, each variable is indexed by the position that the related word occupies in the text. Although apparently naive, this is an important feature of our system which allows different semantic processes to run at different times and results to be merged at the end. 4 Case studies We present three applications. First we show how AsdeCopas can be used in a disambiguation process. Then we use it to build formulas in MRS (Copestake et al., 2001). Finally, we present an application where AsdeCopas generates logical forms from questions. Quantification is ignored in this last task. Notice, however, that in order to have a serious evaluation of AsdeCopas capabilities, it needs to be applied to more demanding tasks. 4.1 Disambiguation process Consider again the quantifier qualquer. As we saw, it can take several semantic values. Sometimes the syntactic context allows to limit these &apos;Within our applications, dependencies are unlabelled, and go from dependents to the head. The motivation behind these structures came from the 5P Paradigm. p</context>
<context position="17012" citStr="Copestake et al., 2001" startWordPosition="2917" endWordPosition="2920">ntation language. In fact, although the concept is not new (Hobbs, 1983), state of the art frameworks such as (Moll´a et al., 2003; Baldridge and Kruijff, 2002) are using flat semantic representations, taht is formulas with no embedded structures (see (Moll´a, 2000) for details about flatness), which simplify the syntactic-semantic interface. At the same time, and because it is not reasonable to generate all the possible interpretations of a sentence, many frameworks are using representation languages that leave underspecified semantic interpretations (also an old concept (Woods, 1978)). MRS (Copestake et al., 2001) uses a flat representation with explicit pointers (called handles) to encode scope effects, corresponding to recursive structures in more conventional formal semantic representations. We have chosen this language because it has three fundamental characteristics: a) it is a flat language; b) it allows the treatment of quantification; c) it allows underspecification. Un3Notice, that by choosing the universal value, in the final formula this quantifier will no longer be in the scope of negation. derspecified MRS structures can be converted into scope-resolved structures that, according to (Copes</context>
</contexts>
<marker>Copestake, Flickinger, Pollard, Sag, 2001</marker>
<rawString>Ann Copestake, Dan Flickinger, Carl Pollard, and Ivan A. Sag. 2001. Minimal recursion semantics: An introduction. LVC, 1(3):1–47.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Luisa Marques da Silva</author>
<author>Nuno Mamede</author>
<author>David Matos</author>
</authors>
<title>Edite - um sistema de acesso a uma base de dados em linguagem natural. In Workshop sobre taggers para o portuguˆes,</title>
<date>1997</date>
<booktitle>Instituto de Linguistica Te´orica e Computacional.</booktitle>
<pages>20--33</pages>
<location>Lisboa,</location>
<contexts>
<context position="2571" citStr="Silva et al., 1997" startWordPosition="406" endWordPosition="409">for this work. Then, in section 3, we present our approach. This includes a description of the semantic rules formalism and a brief overview of the algorithm behind AsdeCopas. In section 4 we introduce some applications. Final remarks and future directions can be found in section 5. 2 Motivation In 1992, an exhaustive study of the Portuguese tourist resources was made by the Direc¸c˜ao Geral de Turismo (DGT) and afterwards the Inventory of Tourist Resources (IRT) emerged. In order to access it, multimedia “kiosks” were developed and a system called Edite (da Silva, 1997; Reis et al., 1997; da Silva et al., 1997) was created with the purpose of being integrated in these “kiosks” and to allow database access using natural language. Edite had a set of linguistically motivated traditional modules (semantic rules associated with syntactic rules, bottom-up parser, and so on) and it soon became saturated: adding a new syntactic rule caused dramatic side effects, a new semantic value could duplicate the number of generated formulas, etc. It was this experiment that made us change our approach and invest in a more robust methodology. We found in the 5P Paradigm (B`es, 1999; B`es and Hag`ege, 2001; Hag`ege, 20</context>
</contexts>
<marker>Silva, Mamede, Matos, 1997</marker>
<rawString>Luisa Marques da Silva, Nuno Mamede, and David Matos. 1997. Edite - um sistema de acesso a uma base de dados em linguagem natural. In Workshop sobre taggers para o portuguˆes, pages 20–33, Lisboa, Portugal. Instituto de Linguistica Te´orica e Computacional.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Luisa Marques da Silva</author>
</authors>
<title>Edite, um sistema de acesso a base de dados em linguagem natural, an´alise morfol´ogica, sint´actica e semˆantica. Master’s thesis, Instituto Superior T´ecnico, Universidade T´ecnica de</title>
<date>1997</date>
<location>Lisboa, Portugal.</location>
<contexts>
<context position="2528" citStr="Silva, 1997" startWordPosition="399" endWordPosition="400">lows: we start with the motivation for this work. Then, in section 3, we present our approach. This includes a description of the semantic rules formalism and a brief overview of the algorithm behind AsdeCopas. In section 4 we introduce some applications. Final remarks and future directions can be found in section 5. 2 Motivation In 1992, an exhaustive study of the Portuguese tourist resources was made by the Direc¸c˜ao Geral de Turismo (DGT) and afterwards the Inventory of Tourist Resources (IRT) emerged. In order to access it, multimedia “kiosks” were developed and a system called Edite (da Silva, 1997; Reis et al., 1997; da Silva et al., 1997) was created with the purpose of being integrated in these “kiosks” and to allow database access using natural language. Edite had a set of linguistically motivated traditional modules (semantic rules associated with syntactic rules, bottom-up parser, and so on) and it soon became saturated: adding a new syntactic rule caused dramatic side effects, a new semantic value could duplicate the number of generated formulas, etc. It was this experiment that made us change our approach and invest in a more robust methodology. We found in the 5P Paradigm (B`es</context>
</contexts>
<marker>Silva, 1997</marker>
<rawString>Luisa Marques da Silva. 1997. Edite, um sistema de acesso a base de dados em linguagem natural, an´alise morfol´ogica, sint´actica e semˆantica. Master’s thesis, Instituto Superior T´ecnico, Universidade T´ecnica de Lisboa, Portugal.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Caroline Hag`ege</author>
</authors>
<title>Analyse Syntatic Automatique du Portugais.</title>
<date>2000</date>
<tech>Ph.D. thesis,</tech>
<institution>Universit´e Blaise Pascal,</institution>
<location>Clermont-Ferrand, France.</location>
<marker>Hag`ege, 2000</marker>
<rawString>Caroline Hag`ege. 2000. Analyse Syntatic Automatique du Portugais. Ph.D. thesis, Universit´e Blaise Pascal, Clermont-Ferrand, France.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jerry R Hobbs</author>
</authors>
<title>An improper treatment of quantification in ordinary english.</title>
<date>1983</date>
<booktitle>In 21st Annual Meeting of the Association for Computational Linguistics (ACL).</booktitle>
<contexts>
<context position="16461" citStr="Hobbs, 1983" startWordPosition="2838" endWordPosition="2839">e paraphrases of it), by using its syntactic context. Obviously, there are limits to this task, as in some situations information from semantics and pragmatics should also be taken into account to find the correct semantic value. 4.2 Logical forms generation 4.2.1 Minimal Recursion Semantics Linking syntax with semantics is not an easy task. As Allen says in (Allen, 1995) there seems to be a structural inconsistency between syntactic structure and the structure of the logical form. We can ease this process by using an adequate representation language. In fact, although the concept is not new (Hobbs, 1983), state of the art frameworks such as (Moll´a et al., 2003; Baldridge and Kruijff, 2002) are using flat semantic representations, taht is formulas with no embedded structures (see (Moll´a, 2000) for details about flatness), which simplify the syntactic-semantic interface. At the same time, and because it is not reasonable to generate all the possible interpretations of a sentence, many frameworks are using representation languages that leave underspecified semantic interpretations (also an old concept (Woods, 1978)). MRS (Copestake et al., 2001) uses a flat representation with explicit pointer</context>
</contexts>
<marker>Hobbs, 1983</marker>
<rawString>Jerry R. Hobbs. 1983. An improper treatment of quantification in ordinary english. In 21st Annual Meeting of the Association for Computational Linguistics (ACL).</rawString>
</citation>
<citation valid="true">
<authors>
<author>Telmo M´oia</author>
</authors>
<title>Aspectos da Semˆantica do Operador Qualquer (Cadernos de Semˆantica n° 5). Faculdade de Letras da Universidade de Lisboa.</title>
<date>1992</date>
<marker>M´oia, 1992</marker>
<rawString>Telmo M´oia. 1992. Aspectos da Semˆantica do Operador Qualquer (Cadernos de Semˆantica n° 5). Faculdade de Letras da Universidade de Lisboa.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Diego Moll´a</author>
</authors>
<title>Ontologically promiscuous flat logical forms for NLP.</title>
<date>2000</date>
<booktitle>In IWCS-4,</booktitle>
<location>Tilburg, The Netherlands.</location>
<marker>Moll´a, 2000</marker>
<rawString>Diego Moll´a. 2000. Ontologically promiscuous flat logical forms for NLP. In IWCS-4, Tilburg, The Netherlands.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Diego Moll´a</author>
<author>Ben Hutchinson</author>
</authors>
<title>Dependency-based semantic interpretation for answer extraction.</title>
<date>2002</date>
<booktitle>In Proceedings of the Australasian NLP Workshop (ANLP’02),</booktitle>
<location>Canberra.</location>
<marker>Moll´a, Hutchinson, 2002</marker>
<rawString>Diego Moll´a and Ben Hutchinson. 2002. Dependency-based semantic interpretation for answer extraction. In Proceedings of the Australasian NLP Workshop (ANLP’02), Canberra.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Diego Moll´a</author>
<author>Rolf Schwitter</author>
<author>Fabio Rinaldi</author>
<author>James Dowdall</author>
<author>Michael Hess</author>
</authors>
<title>Extrans: Extracting answers from technical texts.</title>
<date>2003</date>
<journal>IEEE Intelligent Systems,</journal>
<volume>18</volume>
<issue>4</issue>
<pages>July/August.</pages>
<marker>Moll´a, Schwitter, Rinaldi, Dowdall, Hess, 2003</marker>
<rawString>Diego Moll´a, Rolf Schwitter, Fabio Rinaldi, James Dowdall, and Michael Hess. 2003. Extrans: Extracting answers from technical texts. IEEE Intelligent Systems, 18(4), July/August.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Poesio</author>
</authors>
<title>Ambiguity, underspecification and discourse interpretation. In</title>
<date>1994</date>
<booktitle>Proceedings of the First International Workshop on Computational Semantics,</booktitle>
<pages>151--160</pages>
<editor>R. A. Muskens H. Bunt and G. Rentier (eds.), editors,</editor>
<publisher>ITK, Tilburg University”.</publisher>
<contexts>
<context position="13843" citStr="Poesio, 1994" startWordPosition="2377" endWordPosition="2378">er, that in order to have a serious evaluation of AsdeCopas capabilities, it needs to be applied to more demanding tasks. 4.1 Disambiguation process Consider again the quantifier qualquer. As we saw, it can take several semantic values. Sometimes the syntactic context allows to limit these &apos;Within our applications, dependencies are unlabelled, and go from dependents to the head. The motivation behind these structures came from the 5P Paradigm. possibilities. In some situations, one semantic value can be chosen, allowing a full desambiguation. Let us assume that all is an underspecified value (Poesio, 1994) representing all of the semantic values. If no desambiguation takes place, this is the value that will represent this word’s semantics. Alternatively, we could opt for a default value. For example, the universal value since it is the most common. Let us opt for the universal default value. We can write a default rule, as the following: [R1] {elem(qualquer, qt)} : ∅ H {sem(qt) = univ} Assuming again, as we did in section 2, that on the right of the main verb in the scope of negation, qualquer takes the value indiscriminate the following rule allows to choose the correct value for qualquer in t</context>
</contexts>
<marker>Poesio, 1994</marker>
<rawString>M. Poesio. 1994. Ambiguity, underspecification and discourse interpretation. In R. A. Muskens H. Bunt and G. Rentier (eds.), editors, Proceedings of the First International Workshop on Computational Semantics, pages 151–160. ”ITK, Tilburg University”.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Paulo Reis</author>
<author>J Matias</author>
<author>Nuno Mamede</author>
</authors>
<title>Edite - a natural language interface to databases: a new dimension for an old approach.</title>
<date>1997</date>
<booktitle>In Proceedings of the Fourth International Conference on Information and Communication Technology in Tourism (ENTER’97),</booktitle>
<pages>317--326</pages>
<publisher>Springer-Verlag,</publisher>
<location>Edinburgh, Esc´ocia.</location>
<contexts>
<context position="2547" citStr="Reis et al., 1997" startWordPosition="401" endWordPosition="404">t with the motivation for this work. Then, in section 3, we present our approach. This includes a description of the semantic rules formalism and a brief overview of the algorithm behind AsdeCopas. In section 4 we introduce some applications. Final remarks and future directions can be found in section 5. 2 Motivation In 1992, an exhaustive study of the Portuguese tourist resources was made by the Direc¸c˜ao Geral de Turismo (DGT) and afterwards the Inventory of Tourist Resources (IRT) emerged. In order to access it, multimedia “kiosks” were developed and a system called Edite (da Silva, 1997; Reis et al., 1997; da Silva et al., 1997) was created with the purpose of being integrated in these “kiosks” and to allow database access using natural language. Edite had a set of linguistically motivated traditional modules (semantic rules associated with syntactic rules, bottom-up parser, and so on) and it soon became saturated: adding a new syntactic rule caused dramatic side effects, a new semantic value could duplicate the number of generated formulas, etc. It was this experiment that made us change our approach and invest in a more robust methodology. We found in the 5P Paradigm (B`es, 1999; B`es and Ha</context>
</contexts>
<marker>Reis, Matias, Mamede, 1997</marker>
<rawString>Paulo Reis, J. Matias, and Nuno Mamede. 1997. Edite - a natural language interface to databases: a new dimension for an old approach. In Proceedings of the Fourth International Conference on Information and Communication Technology in Tourism (ENTER’97), pages 317–326, Edinburgh, Esc´ocia. Springer-Verlag, Berlin, Germany.</rawString>
</citation>
<citation valid="true">
<authors>
<author>W A Woods</author>
</authors>
<title>Semantics and quantification in natural language question answering.</title>
<date>1978</date>
<booktitle>Advance in Computers,</booktitle>
<volume>17</volume>
<editor>In M. Yovitz, editor,</editor>
<publisher>Academic Press.</publisher>
<location>New York:</location>
<contexts>
<context position="16981" citStr="Woods, 1978" startWordPosition="2914" endWordPosition="2915"> an adequate representation language. In fact, although the concept is not new (Hobbs, 1983), state of the art frameworks such as (Moll´a et al., 2003; Baldridge and Kruijff, 2002) are using flat semantic representations, taht is formulas with no embedded structures (see (Moll´a, 2000) for details about flatness), which simplify the syntactic-semantic interface. At the same time, and because it is not reasonable to generate all the possible interpretations of a sentence, many frameworks are using representation languages that leave underspecified semantic interpretations (also an old concept (Woods, 1978)). MRS (Copestake et al., 2001) uses a flat representation with explicit pointers (called handles) to encode scope effects, corresponding to recursive structures in more conventional formal semantic representations. We have chosen this language because it has three fundamental characteristics: a) it is a flat language; b) it allows the treatment of quantification; c) it allows underspecification. Un3Notice, that by choosing the universal value, in the final formula this quantifier will no longer be in the scope of negation. derspecified MRS structures can be converted into scope-resolved struc</context>
</contexts>
<marker>Woods, 1978</marker>
<rawString>W. A. Woods. 1978. Semantics and quantification in natural language question answering. In M. Yovitz, editor, Advance in Computers, volume 17. New York: Academic Press. Reprinted in Readings in Natural Language Processing, edited by B. Grosz, K. Jones and B. Webber and published by Morgan Kaufmann Publishers, Inc. in 1986.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>