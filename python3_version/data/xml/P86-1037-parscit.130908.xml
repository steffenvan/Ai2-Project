<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<title confidence="0.9953565">
Some Uses of Higher-Order Logic
in Computational Linguistics
</title>
<author confidence="0.821362">
Dale A. Miller and Gopalan Nadathur
</author>
<affiliation confidence="0.9718275">
Computer and Information Science
University of Pennsylvania
</affiliation>
<address confidence="0.495475">
Philadelphia, PA 19104 â€” 3897
</address>
<bodyText confidence="0.98138725">
Abstract
Consideration of the question of meaning in the frame-
work of linguistics often requires an allusion to sets and
other higher-order notions. The traditional approach to
representing and reasoning about meaning in a computa-
tional setting has been to use knowledge representation sys-
tems that are either based on first-order logic or that use
mechanisms whose formal justifications are to be provided
after the fact. In this paper we shall consider the use of
a higher-order logic for this task. We first present a ver-
sion of definite clauses (positive Horn clauses) that is based
on this logic. Predicate and function variables may oc-
cur in such clauses and the terms in the language are the
typed A-terms. Such term structures have a richness that
may be exploited in representing meanings. We also de-
scribe a higher-order logic programming language, called
AProlog, which represents programs as higher-order defi-
nite clauses and interprets them using a depth-first inter-
preter. A virtue of this language is that it is possible to
write programs in it that integrate syntactic and seman-
tic analyses into one computational paradigm. This is to
be contrasted with the more common practice of using two
entirely different computation paradigms, such as DCGs or
ATNs for parsing and frames or semantic nets for semantic
processing. We illustrate such an integration in this lan-
guage by considering a simple example, and we claim that
its use makes the task of providing formal justifications for
the computations specified much more direct.
</bodyText>
<sectionHeader confidence="0.99836" genericHeader="abstract">
1. Introduction
</sectionHeader>
<bodyText confidence="0.999962720930233">
The representation of meaning, and the use of such a
representation to draw inferences, is an issue of central con-
cern in natural language understanding systems. A theoret-
ical understanding of meaning is generally based on logic,
and it has been recognized that a higher-order logic is par-
ticularly well suited to this task. Montague, for example,
used such a logic to provide a compositional semantics for
simple English sentences. In the computational framework,
knowledge representation systems are given the task of rep-
resenting the semantical notions that are needed in natural
This work has been supported by NSF grants MCS-82-
19196-CER, MCS-82-07294, AT Center grants MCS-83-
05221, US Army Research Office grant ARO-DAA29-84-
9-0027, and DARPA N000-14-85-K-0018.
language understanding programs. While the formal justi-
fications that are provided for such systems is usually log-
ical, the actual formalisms used are often distantly related
to logic. Our approach in this paper is to represent mean-
ings directly by using logical expressions, and to describe
the process of inference by specifying manipulations on such
expressions. As it turns out, most programming languages
are poorly suited for an approach such as ours. Prolog,
for instance, permits the representation and the examina-
tion of the structure of first-order terms, but it is not easy
to use such terms to represent first-order formulas which
contain quantification. Lisp on the other hand allows the
construction of lambda expressions which could encode the
binding operations of quantifiers, but does not provide log-
ical primitives for studying the internal structure of such
expressions. A language that is based on a higher-order
logic seems to be the most natural vehicle for an approach
such as ours, and in the first part of this paper we shall de-
scribe such a language. We shall then use this language to
describe computations of a kind that is needed in a natural
language understanding system.
Before we embark on this task, however, we need to
consider the arguments that are often made against the
computational use of a higher-order logic. Indeed, several
authors in the current literature on computational linguis-
tics and knowledge representation have presented reasons
for preferring first-order logic over higher-order logic in nat-
ural language understanding systems, and amongst these
the following three appear frequently.
</bodyText>
<listItem confidence="0.976353916666667">
(1) Godel showed that second-order logic is essentially in-
complete, i.e. true second-order logic statements are
not recursively enumerable. Hence, theorem provers
for this logic cannot be, even theoretically, complete.
(2) Higher-order objects like functions and predicates can
themselves be considered to be first-order objects of
some sort. Hence, a sorted first-order logic can be used
to encode higher-order objects.
(3) Little research on theorem proving in higher-order log-
ics has been done. Moreover, there is reason to believe
that theorem proving in such a logic is extremely dif-
ficult.
</listItem>
<bodyText confidence="0.9925825">
These facts are often used to conclude that a higher-
order logic should not be used to formalize systems if
such formalizations are to be computationally meaningful.
While there is some truth in each of these observations, we
feel that they do not warrant the conclusion that is drawn
from it. We discuss our reasons for this belief below.
</bodyText>
<page confidence="0.994791">
247
</page>
<bodyText confidence="0.999991328125">
The point regarding the essential undecidability of
second-order logic has actually little import on the com-
putational uses of higher-order logic. This is because the
second-order logic as it is construed in this observation, is
not a proof system but rather a truth system of a very par-
ticular kind. Roughly put, the second-order logic in ques-
tion is not so much a logic as it is a branch of mathematics
which is interested in properties about the integers. There
are higher-order logics that have been provided which con-
tain the formulas of second-order logic but which do not
assume the same notion of models (i.e. the integers). These
logics, in fact, have general models, including the standard,
integer model, as well as other non-standard models, and
with respect to this semantics, the logic has a sound and
complete proof system.
From a theoretical point-of-view, the second observa-
tions is important. Indeed, any system which could not be
encoded into first-order logic would be more powerful than
Turing machines and, hence, would be a rather unsatisfac-
tory computationally! The existence of such an encoding
has little significance, however, with regard to the appro-
priateness of one language over another for a given set of
computational tasks. Clearly, all general purpose program-
ming languages can be encoded onto first-order logic, but
this has little significance with regard to the suitability of
a given programming language for certain applications.
Although less work has been done on theorem proving
in higher-order logic than in first-order logic as claimed in
the last point, the nature of proofs in higher-order logic is
far from mysterious. For example, higher-order resolution
[1] and unification [8] has been developed, and based on
these principles, several theorem provers for various higher-
order logics (see [2] and its references) have been built and
tested. The experience with such systems shows that the-
orem proving in such a logic is difficult. It is not clear,
however, that the difficulty is inherent in the language cho-
sen to express a theorem rather than in the theorem itself.
In fact, expressing a higher-order theorem (as we will claim
many statements about meaning are) in a higher-order logic
makes its logical structure more explicit than an encoding
into first-order logic does. Consequently, it is reasonable
to expect that the higher-order representation should ac-
tually simplify the process of finding proofs. In a more
specific sense, there are sublogics of a higher-order logic in
which the process of constructing proofs is not much more
complicated than in similar sublogics of first-order logic.
An example of such a case is the higher-order version of
definite clauses that we shall consider shortly.
In this paper, we present a higher-order version of def-
inite clauses that may be used to specify computations,
and we describe a logic programming language, AProlog,
that is based on this specification language. We claim that
AProlog has several linguistically meaningful applications.
To bolster this claim we shall show how the syntactic and
semantic processing used within a simple parser of natu-
ral language can be smoothly integrated into one logical
and computational process. We shall first present a defi-
nite clause grammar that analyses the syntactic structure of
simple English sentences to produce logical forms in much
the same way as is done in the Montague framework. We
shall then show how semantic analyses may be specified
via operations on such logical forms. Finally, we shall illus-
trate interactions between these two kinds of analyses by
considering an example of determining pronoun reference.
</bodyText>
<listItem confidence="0.381302">
2. Higher-Order Logic
</listItem>
<bodyText confidence="0.993979423076923">
The higher-order logic we study here, called T, can be
thought of as being a subsystem of either Church&apos;s Simple
Theory of Types [5] or of Montague&apos;s intensional logic IL
[6]. Unlike Church&apos;s or Montague&apos;s logics, T is very weak
because it assumes no axioms regarding extensionality, def-
inite descriptions, infinity, choice, or possible worlds. T
encompasses only the most primitive logical notions, and
generalizes first-order logic by introducing stronger notions
of variables and substitutions. Our use of T is not driven
by a desire to capture of the meaning of linguistic objects,
as was the hope of Montague. It is our hope that programs
written in T will do that.
The language of T is a typed language. The typing
mechanism provides for the usual notion of sorts often used
in first-order logic and also for the notion of functional
types. We take as primitive types (i.e. sorts) o for booleans
and i for (first-order) individuals, adding others as needed.
Functional types are written as a â€”+ 3, where a and f3 are
types. This type is intended to denote the type of func-
tions whose domains are a and whose codomains are 13.
For example, i â€”&gt; i denotes the type of functions which
map individuals to individuals, and (i --+ i) o denotes
the type of functions from that domain to the booleans. In
reading such expressions we use the convention that --&gt; is
right associative, i.e. we read a -4 [3 â€”&gt; -y as a (#
The terms or formulas of T are specified along with
their respective types by the following simple rules: We
start with denumerable sets of constants and variables at
each type. A constant or variable in any of these sets is
considered to be a formula of the corresponding type. Then,
if A is of type a â€”&gt; [3 and B is of type a, the function
application (AB) is a formula of type O. Finally, if x is a
variable of type a and C is a term of type [3, the function
abstraction )txC is a formula of type a â€”&gt; fl.
We assume that the following symbols, called the log-
ical constants, are included in the set of constants of the
corresponding type: true of type o, â€” of type o o, A,
V, and D each of type o -4 o â€”&gt; o and II and E of type
(A o) o for each type A. All these symbols except
the last two correspond to the normal propositional connec-
tives. The symbols II and E are used in conjunction with
the abstraction operation to represent universal and exis-
tential quantification: Vx P is an abbreviation for II(Ax P)
and 3x P is an abbreviation for E(Ax P). II and E are
examples of what are often called generalized quantifiers.
The type o has a special role in this language. A for-
mula with a function type of the form ti --&gt; â€”&gt; tn. â€”+ o
is called a predicate of n arguments. The ith argument of
such a predicate is of type ti. Predicates are to be thought
of as representing sets and relations. Thus a predicate of
type o represents a set of individuals, a predicate of
type (i â€”â€º o) o represents a set of sets of individuals,
</bodyText>
<page confidence="0.994549">
248
</page>
<bodyText confidence="0.999008666666667">
and a predicate of type i (1 o) o represents a bi-
nary relation between individuals and sets of individuals.
Formulas of type o are called propositions. Although pred-
icates are essentially functions, we shall generally use the
term function to denote a formula that does not have the
type of a predicate.
Derivability in T, denoted by I- , is defined in the fol-
lowing (simplified) fashion. The axioms of T are the propo-
sitional tautologies, the formula Vx Bx D Bt, and the for-
mula Vx (PxAQ) D Vx PzAQ. The rules of inference of the
system are Modus Ponens, Universal Generalization, Sub-
stitution, and A-conversion. The rules of A-conversion that
we assume here are a-conversion (change of bound vari-
ables), /3-conversion (contraction), and 77-conversion (re-
place A with Az(Az) and vice versa if A has type a 13, z
has type a, and z is not free in A). A-conversion is essen-
tially the only rule in T that is not in first-order logic, but
combined with the richer syntax of formulas in T it makes
more complex inferences possible.
In general, we shall consider two terms to be equal if
they are each convertible to the other; further distinctions
can be made between formulas in this sense by omitting the
rule for 77-conversion, but we feel that such distinctions are
not important in our context. We say that a formula is a
A-normal formula if it has the form
Ax,â€ž (h ti where n, m &gt; 0,
where h is a constant or variable, (h t1 . . . tm) has a prim-
itive type, and, for 1 &lt; i &lt; m, ti also has the same form.
We call the list of variables , xâ€ž the binder, h the
head, and the formulas ,tn., the arguments of such a
formula. It is well known that every formula, A, can be
converted to a A-normal formula that is unique up to a-
conversions. We call such a formula a A-normal form of A
and we use Anorm(A) to denote any of these alphabetic
variants. Notice that a proposition in A-normal form must
have an empty binder and contain either a constant or free
variable as its head. A proposition in A-normal form which
has a non-logical constant as its head is called atomic.
Our purpose in this paper is not merely to use a logic as
a representational device, but also to think of it as a device
for specifying computations. It turns out that T is too
complex for the latter purpose. We shall therefore restrict
our attention to what may be thought of as a higher-order
analogue of positive Horn clauses. We define these below.
We shall henceforth assume that we have a fixed set
of nonlogical constants. The positive Herbrand Universe is
identified in this context to be the set of all the A-normal
formulas that can be constructed via function application
and abstraction using the nonlogical constants and the log-
ical constants true, A, V and E; the omission here is of the
symbols D, and II. We shall use the symbol )iÂ± to denote
this set of terms. Propositions in this set are of special inter-
est to us. Let G and A be propositions in )1+ such that A is
atomic. A (higher-order) definite clause then is the univer-
sal closure of a formula of the form G j A, i.e. the formula
V2 (G D A) where is an arbitrary listing of all the free
variables in G and A, some of which may be function and
predicate variables. These formulas are our generalization
of positive Horn clauses for first-order logic. The formula
on the left of the D in a higher-order definite clause may
contain nested disjunctions and existential quantification.
This generalization may be dispensed within the first-order
case because of the existence of appropriate normal forms.
For the higher-order case, it is more natural to retain the
embedded disjunctions and existential quantifications since
substitutions for predicate variables have the potential for
re-introducing them. Illustrations of this aspect appear in
Section 4.
Deductions from higher-order definite clauses are very
similar to deductions from positive Horn clauses in first-
order logic. Substitution, unification, and backchaining can
be combined to build a theorem prover in either case. How-
ever, unification in the higher-order setting is complicated
by the presence of A-conversion: two terms t and s are unifi-
able if there exists some substitution go such that cos and
cot are equal modulo A-conversions. Since /3-conversion is
a very complex process, determining this kind of equality
is difficult. The unification of typed A-terms is, in general,
not decidable, and when unifiers do exist, there need not
exist a single most general unifier. Nevertheless, it is pos-
sible to systematically search for unifiers in this setting [8]
and an interpreter for higher-order definite clauses can be
built around this procedure. The resulting interpreter can
be made to resemble Prolog except that it must account
for the extra degree of nondeterminism which arises from
higher-order unification. Although there are several impor-
tant issues regarding the search for higher-order unifiers,
we shall ignore them here since all the unification problems
which arise in this paper can be solved by even a simple-
minded implementation of the procedure described in [8].
</bodyText>
<listItem confidence="0.545539">
3. AProlog
</listItem>
<bodyText confidence="0.999845">
We have used higher-order definite clauses and a
depth-first interpreter to describe a logic programming lan-
guage called AProlog. We present below a brief exposition
of the higher-order features of this language that we shall
use in the examples in the later sections. A fuller descrip-
tion of the language and of the logical considerations un-
derlying it may be found in [9].
Programs in AProlog are essentially higher-order defi-
nite clauses. The following set of clauses that define certain
standard list operations serve to illustrate some of the syn-
tactic features of our language.
</bodyText>
<equation confidence="0.9291625">
append nil K K.
append (cons X L) K (cons X M) :- append L K M.
member X (cons X L).
member X (cons Y L) :- member X L.
</equation>
<bodyText confidence="0.999884888888889">
As should be apparent from these clauses, the syntax of
AProlog borrows a great deal from that of Prolog. Sym-
bols that begin with capital letters represent variables. All
other symbols represent constants. Clauses are written
backwards and the symbol : - is used for C. There are,
however, some differences. We have adopted a curried no-
tation for terms, rather than the notation normally used in
a first-order language. Since the language is a typed one,
types must be associated with each term. This is done by
</bodyText>
<page confidence="0.991426">
249
</page>
<bodyText confidence="0.990066097560976">
either explicitly defining the type of a constant or a vari-
able, or by inferring such a type by a process very similar
to that used in the language ML [7]. The type expressions
that are attached to symbols may contain variables which
provide a form of polymorphism. As an example cons and
nil above are assumed to have the types A -&gt; (list A)
-&gt; (list A) and (list A) respectively; they serve to de-
fine lists of different kinds, but each list being such that all
its elements have a common type. (For the convenience of
expression, we shall actually use Prolog&apos;s notation for lists
in the remainder of this paper, i.e. we shall write (cons X
L) as [X1L]). In the examples in this paper, we shall occa-
sionally provide type associations, but in general we shall
assume that the reader can infer them from context when
it is important. We need to represent A-abstraction in our
language, and we use the symbol \ for this purpose; i.e.
XX A is written in AProlog as X \ A.
The following program, which defines the operation of
mapping a function over a list, illustrates a use of function
variables in our language.
mapfun F (XIL] [(F X)]K) mapfun F L K.
mapfun F .
Given these clauses, (mapfun F Li L2) is provable only if
L2 is a list that results from applying F to each element of
Li. The interpreter for AProlog would therefore evaluate
the goal (mapfun (X\ (g X X)) [a, 13]) L) by returning
the value [(g a a) . (g b b)] for L.
The logical considerations underlying the language
permit functions to be treated as first-class, logic program-
ming variables. In other words, the values of such variables
can be computed through unification. For example, con-
sider the query
(mapfun F [a, ((g a a), (g a b)]).
There is exactly one substitution for F, namely X\ (g a
X), that makes the above query provable. In searching for
such higher-order substitutions, the interpreter for AProlog
would need to backtrack over choices of substitutions. For
example, if the interpreter attempted to prove the above
goal by attempting to unify (F a) with (g a a), it would
need to consider the following four possible substitutions
for F:
</bodyText>
<equation confidence="0.959982">
X\ (g X X) X\ (g a X) X\ (g X a) X\ (g a a).
</equation>
<bodyText confidence="0.990441166666667">
If it chooses any of these other than the second, the inter-
preter would fail in unifying (F b) with (g a b), and would
therefore have to backtrack over that choice.
It is important to notice that the set of functions that
are representable using the typed A-terms of AProlog is not
the set of all computable functions. The set of functions
that are so representable are in fact much weaker than those
representable in, for example, a functional programming
language like Lisp. Consider the goal
(mapfun F [a, b] [c. d]).
There is clearly a Lisp function which maps a to c and b
to d, namely,
</bodyText>
<equation confidence="0.8104025">
(lambda (x) (if (eq x &apos;a) &apos;b
(if (eq x &apos;c) &apos;d &apos;e)))
</equation>
<bodyText confidence="0.999897833333333">
Such a function is, however, not representable using our
typed A-terms since these do not contain any constants rep-
resenting conditionals (or fixed point operators needed for
recursive definitions). It is actually this restriction to our
term structures that makes the determination of function
values through unification a reasonable computational op-
eration.
The provision of function variables and higher-order
unification has several uses, some of which we shall exam-
ine in later sections. Before doing that we consider briefly
certain kinds of function terms that have a special status
in the logic programming context, namely predicate terms.
</bodyText>
<sectionHeader confidence="0.759351" genericHeader="method">
4. Predicates as Values
</sectionHeader>
<bodyText confidence="0.979061227272728">
From a logical point of view, predicates are not much
different from other functions; essentially they are func-
tions that have a type of the form al --+ an â€”+ o. In
a logic programming language, however, variables of this
type may play a different and more interesting role than
non-predicate variables. This is because such variables may
appear inside the terms of a goal as well as the head of a
goal. In a sense, they can be used intensionally and exten-
sionally (or nominally and saturated). When they appear
intensionally, predicates can be determined through unifi-
cation just as functions. When they appear extensionally,
they are essentially &amp;quot;executed.&amp;quot;
An example of these mixed uses of predicate variables
is provided by the following set of clauses; the logical con-
nectives A and V are represented in AProlog by the symbols
. and ; , true is represented by true and E is represented
by the symbol sigma that has the polymorphic type (A -&gt;
o) -&gt; o.
sublist P [XII.] [X1K] P X. sublist P L K.
sublist P K sublist P L K.
sublist P .
have_age L K sublist Zâ€œsigma XVage Z X)) L K.
same_age L K sublist Z\(age Z A) L K.
age bob 23.
age sue 24.
age ned 23.
The first three clauses define the predicate sublist whose
first argument is a predicate and is such that (sublist P
L K) is provable if K is some sublist of L and all the mem-
bers in K satisfy the property expressed by the predicate
P. The fourth clause uses sublist to define the predicate
have_age which is such that (have_age L K) is provable
if K is a sublist of the objects in L which have an age. In
the definition of have_age a predicate term that contains
an explicit quantifier is used to instantiate the predicate
argument of sublist; the predicate (Z \ (sigma X (age Z
X))), which may be written in logic as Az ax age(z,x), is
true of an individual if that individual has an age. This
predicate term needs to be executed in the course of eval-
uating, for example, the query (have_age [bob sue .ned]
K). The predicate same_age whose definition is obtained by
dropping the quantifier from the predicate term defines a
different property; (same_age L K) is true only when the
objects in K have the same age.
</bodyText>
<page confidence="0.972063">
250
</page>
<bodyText confidence="0.980146150684932">
Another example is provided by the following set of
clauses that define the operation of mapping a predicate
over a list.
mappred P [XIL] [YIK] P X Y. mappred P L K.
mappred P U.
This set of clauses may be used, for example, to evaluate
the following query:
mappred (X \Yâ€œage Y X)) [23.24] L.
This query essentially asks for a list of two people, the first
of which is 23 years old while the second is 24 years old.
Given the clauses that appear in the previous example, this
query has two different answers: [bob. sue] and [fled.
sue]. Clearly the mapping operation defined here is much
stronger than a similar operation considered earlier, namely
that of mapping a function over a list. In evaluating a query
that uses this set of clauses a new goal, i.e. (P X Y), is
formed whose evaluation may require arbitrary computa-
tions to be performed. As opposed to this, in the earlier
case only A-reductions are performed. Thus, mappred is
more like the mapping operations found in Lisp than map-
fun is.
In the cases considered above, predicate variables that
appeared as the heads of goals were fully instantiated be-
fore the goal was invoked. This kind of use of predicate
variables is similar to the use of apply and lambda terms
in Lisp: A-contraction followed by the goal invocation sim-
ulates the apply operation in the Prolog context. However,
the variable head of a goal may not always be fully instanti-
ated when the goal has to be evaluated. In such cases there
is a question as to what substitutions should be attempted.
Consider, for example, the query (P bob 23). One value
that may be returned for P is X\ Y\ (age X Y), and this may
seem to be the most &amp;quot;natural&amp;quot; value. There are, however,
many more substitutions for P which also satisfy this goal:
X\Y\(X = bob, Y = 23), X\Y\(Y = 23), X\Y\(age sue
24), etc. are all terms that could be picked, since if they
were substituted for P in the query they would result in a
provable goal. There are, clearly, too many substitutions to
pick from and perhaps backtrack over. Furthermore several
of these may have little to do with the original intention of
the query. A better strategy may be to pick the one sub-
stitution that has the largest &amp;quot;extension&amp;quot; in such cases; in
the case considered here, such a substitution for P would
be the term X \Y \true. It is possible to make such a choice
without adding to the incompleteness of an interpreter.
Picking such a substitution does not necessarily triv-
ialize the use of predicate variables. If a predicate occurs
intensionally as well as extensionally in a goal, this kind of
a trivial substitution may not be possible. To illustrate this
let us consider the following set of clauses:
primrel father.
primrel mother.
primrel wife.
primrel husband.
rel R primrel R.
rel X\Y\(sigma Z\(R X Z. S Z Y))
primrel R, primrel S.
The first four clauses identify four primitive relations be-
tween individuals (primrel has type (i -&gt; j -&gt; o) -&gt; o).
These are then used to define other relations that are a re-
sult of &amp;quot;joining&amp;quot; primitive relations. Now if (mother Jane
nary) and (wife John Jane) are provided as additional
clauses, then the query (rel R. R John nary) would yield
the substitution X \ Y \ (sigma Z\ (wife X Z, mother Z Y))
for R. This query asks for a relation (in the sense of rel)
between j ohm and mary. The answer substitution provides
the relation mother-in-law.
We have been able to show (Theorem 1 [9]) that any
proof in T of a goal formula from a set of definite clauses
which uses a predicate term containing the logical connec-
tives --, D, or V, can be converted into another proof in
which only predicate terms from )(+ are used. Thus, it is
not possible for a term such as
</bodyText>
<listItem confidence="0.283901">
Ax (person(x) A Vy (child(x,y) D doctor(y)))
</listItem>
<bodyText confidence="0.998776533333333">
to be specified by a AProlog program, i.e. be the unique
substitution which makes some goal provable from some
set of definite clauses. This is because a consequence of
our theorem is that if this term is an answer substitution
then there is also another A-term that does not use im-
plications or universal quantification that can be used to
satisy the given goal. If an understanding of a richer set
of predicate constructions is desired, then one course is to
leave definite clause logic for a stronger logic. An alterna-
tive approach, which we use in Section 6, is to represent
predicates as function terms whose types do not involve o.
This, of course, means that such predicate constructions
could not be the head of goals. Hence, additional definite
clauses would be needed to interpret the meaning of these
encoded predicates.
</bodyText>
<sectionHeader confidence="0.472465" genericHeader="method">
5. A Simple Parsing Example
</sectionHeader>
<bodyText confidence="0.999866565217391">
The enriched term structure of AProlog provides two
facilities that are useful in certain contexts. The notion of
A-abstraction allows the representation of binding a vari-
able over a certain expression, and the notion of appli-
cation together with A-contraction captures the idea of
substitution. A situation where this might be useful is
in representing expressions in first-order logic as terms,
and in describing logical manipulations on them. Con-
sider, for example, the task of representing the formula
Vx3y(P(x,y) D Q(y, x)) as a term. Fragments of this for-
mula may be encoded into first-order terms, but there is a
genuine problem with representing the quantification. We
need to represent the variable being quantified as a gen-
uine variable, since, for instance, instantiating the quanti-
fier involves substituting for the variable. At the same time
we desire to distinguish between occurences of a variable
within the scope of the quantifier from occurences outside
of it. The mechanism of A-abstraction provides the tool
needed to make such distinctions. To illustrate this let us
consider how the formula above may be encoded as a A-
term. Let the primitive type b be the type of terms that
represent first-order formulas. Further let us assume we
have the constants 8: and =&gt; of type b -&gt; b -&gt; b, and all
</bodyText>
<page confidence="0.994085">
251
</page>
<bodyText confidence="0.999906363636364">
and some of type (i -&gt; b) -&gt; b. These latter two constants
have the type of generalized quantifiers and are in fact used
to represent quantifiers. The A-term (all X (some Y\ (p X
Y =&gt; q Y X))) may be used to represent the above formula.
The type b should be thought of as a term-level encoding
of the boolean type o.
A more complete illustration of the facilities alluded to
above may be provided by considering the task of translat-
ing simple English sentences into logical forms. As an ex-
ample, consider translating the sentence &amp;quot;Every man loves
a woman&amp;quot; to the logical form
</bodyText>
<equation confidence="0.66693025">
Vx(man(x) D y(woman(y) A loves(x,y)))
which in our context will be represented by the A-term
(all X\ (man X =&gt;
(some Y\(soman Y &amp; loves X Y))))
</equation>
<bodyText confidence="0.884744">
A higher-order version of a DCG [10] for performing this
task is provided below. This DCG draws on the spirit of
Montague Grammars. (See [11] for a similar example.)
</bodyText>
<figure confidence="0.940817285714286">
sentence (P1 P2) --&gt; np Pi, vp P2, [.].
np (Pi P2) --&gt; determ Pi, nom P2.
np P --&gt; propernoun P.
nom P --&gt; noun P.
nom X\(P1 X &amp; P2 X) --&gt; noun Pi, reici-P2.
VP X\(P2 (Pi X)) --&gt; transverb Pi, np P2.
VP P --&gt; intransverb P.
</figure>
<bodyText confidence="0.945053724137931">
relcl P --&gt; [that], vp P.
determ P1\P2\(all X\(P1 X =&gt; P2 X)) --&gt;
[every].
determ P1\P2\(P2 (iota Pi)) --&gt; [the].
determ P1\P2\(some X\(131 X &amp; P2 X)) --&gt; [a].
noun man --&gt; [man] .
noun woman --&gt; [woman).
propernoun john - - &gt; [ j ohn] .
propernoun mary --&gt; [mary).
transverb loves --&gt; [loves] .
transverb likes --&gt; [likes] .
intransverb lives --&gt; [lives] .
We use above the type token for English words; the DCG
translates a list of such tokens to a term of some corre-
sponding type. In the last few clauses certain constants are
used in an overloaded manner. Thus the constant man cor-
responds to two distinct constants, one of type token and
another of type i -&gt; b. We have also used the symbol iota
that has type (i -&gt; b) -&gt; i. This constant plays the role
of a definite description operator; it picks out an individual
given a description of a set of individuals. Thus, parsing the
sentence &amp;quot;The woman that loves john likes mary&amp;quot; produces
the term (likes (iota X \ (woman X &amp; loves X john))
mary), the intended meaning of which is the predication of
the relationship of liking between an object that is picked
out by the description X (woman X &amp; loves X john)) and
mary.
Using this DCG to parse a sentence illustrates the role
that abstraction and application play in realizing the no-
tion of substitution. It is interesting to compare this DCG
with the one in Prolog that is presented in [10]. The first
thing to note is that the two will parse a sentence in nearly
identical fashions. In the first-order version, however, there
is a need to explicitly encode the process of substitution,
and considerable ingenuity must be exercised in devising
grammar rules that take care of this process. In contrast
in AProlog the process of substitution and the process of
parsing are handled by two distinct mechanisms, and con-
sequently the resulting DCG is more perspicuous and so
also easier to extend.
The DCG presented above may also be used to solve
the inverse problem, namely that of obtaining a sentence
given a logical form, and this illustrates the use of higher-
order unification. Consider the task of obtaining a sentence
from the logical form (all X\ (man X =&gt; (some Y\ (woman
Y &amp; loves X Y)))). This involves unifying the above form
with the expression (P1 P2). One of the unifiers for this is
Pi --&gt; P\(all X\(man X =&gt; P X))
P2 --&gt; X\(some Y\(woman Y &amp; loves X Y).
Once this unifier is picked, the task then breaks into that of
obtaining a noun phrase from P\ (all X (man X =&gt; P X))
and a verb phrase from X\ (some Y\ (woman Y &amp; loves X Y).
The use of higher-order unification thus seems to provide a
top-down decomposition in the search for a solution. This
view turns out to be a little simplistic however, since uni-
fication permits more structural decompositions than are
warranted in this context. Thus, another unifier for the
pair considered above is
</bodyText>
<equation confidence="0.982459">
P1 --&gt; ZVall Z)
P2 --&gt; X \ (man X =&gt;
(some Y\ (woman Y &amp; loves X Y)))
</equation>
<bodyText confidence="0.999975235294117">
which does not correspond to a meaningful decomposition
in the context of the rest of the rules. It is possible to
prevent such decompositions by anticipating the rest of
the grammar rules. Alternatively decompositions may be
eschewed altogether; a logical form may be constructed
bottom-up and compared with the given one. The first
alternative detracts from the clarity, or the specificational
nature, of the solution. The latter involves an exhaustive
search over the space of all sentences. The DCG consid-
ered here, together with higher-order unification, seems to
provide a balance between clarity and efficiency.
The final point to be noted is that the terms that
are produced at intermediate stages in the parsing process
are logically meaningful terms, and computations on such
terms may be encoded in other clauses in our language. In
Section 7, we show how some of these terms can be directly
interpreted as frame-like objects.
</bodyText>
<sectionHeader confidence="0.974642" genericHeader="method">
6. Knowledge Representation
</sectionHeader>
<bodyText confidence="0.9999032">
We now consider the question of how a higher-order
logic might be used for the task of representing knowledge.
Traditionally, certain network based formalisms, such as
KL-ONE [4], have been described for this purpose. Such
formalisms use nodes and arcs in a network to encode
</bodyText>
<page confidence="0.992005">
252
</page>
<bodyText confidence="0.999882875">
knowledge, and provide algorithms that operate on this
network in order to perform inferences on the knowledge
so represented. The nature of the information represented
in the network may be clarified with reference to a logic,
and the correctness of the algorithms is often proved by
showing that they perform certain kinds of logical infer-
ence on the underlying information. Our approach here
is to encode the relevant notions by using A-terms that di-
rectly correspond to their logical nature, and to use definite
clauses to specify logical inferences on these notions. We
demonstrate this approach below through a few examples.
A key notion in knowledge representation is that of a
concept. KL-ONE provides the ability to define primitive
roles and concepts and a mechanism to put these together
to define more complex concepts. The intended interpre-
tation of a role is a two place relation, and of a concept
is a set of objects characterized by some defining property.
An appropriate logical view of a concept, therefore, is to
identify it with a one-place predicate. A particularly apt
way of modeling the connection between a concept and a
predicate is to use A-terms of a certain kind to denote con-
cepts. The following set of clauses that are used to define
concepts modelled after examples in [4] serves to make this
clear.
</bodyText>
<construct confidence="0.879431071428571">
prim_role recipient.
prim_role sender.
prim_role supervisor.
prim_concept person.
prim_concept crew.
prim_concept commander.
prim_concept message.
prim_concept important_message.
role R prim_role R.
concept C prim_concept C.
concept (X\ (C1 X &amp; C2 X)) :-
concept Cl, concept C2..
concept (X\(all Y\ (R X Y =&gt; Cl Y))) :-
concept Cl, role R.
</construct>
<bodyText confidence="0.99960875">
The type of prim_role and role in the above example is
(i -&gt; i -&gt; b) -&gt; o and of prim_concept and concept
is (i -&gt; b) -&gt; o. Any term that can be substituted for R
so as to make (role R) provable from these clauses is con-
sidered a role. Similarly, any term that can be substituted
for C so as to make (concept C) provable is considered
a concept. The first three clauses serve to define primitive
roles in this sense, and the next five clauses define primitive
concepts. The remaining clauses describe a mechanism for
constructing further roles and concepts. As can be readily
seen, all roles are primitive roles. An example of a complex
concept is provided by the term
</bodyText>
<equation confidence="0.62026">
(X\(message X &amp; (all Y\(sender X Y =&gt; crew Y))))
</equation>
<bodyText confidence="0.998515466666667">
which may be described by the noun phrase &amp;quot;messages all
of whose senders are crew members.&amp;quot;
One of the purposes for providing a representation for
concepts is so that inferences that involve them can be de-
scribed. One kind of inference that is of particular inter-
est is that of determining subsumption. A concept C1 is
said to subsume another concept C2 if every element of the
set described by C2 is a member of the set described by
Ci. Given our representation of concepts, the question of
whether C1 subsumes C2 reduces to the question of whether
Vx(C2(x) D Ci(x)) is valid (i.e. provable). Such an infer-
ence may be based either on certain primitive containment
relations, or on an analysis of the structure of the terms
used to denote concepts. The following set of clauses make
these ideas precise:
</bodyText>
<figure confidence="0.894460470588235">
subsume person crew.
subsume (X\(all Y\(sender X Y =&gt; person Y)))
message.
subsume (X\(all Yâ€œrecipient X Y =&gt; crew Y)))
message.
subsume message important_message.
subsume (X\(all Y\(sender X Y =&gt; commander Y)))
important_message.
subsume C C.
subsume A B :- subsume A C, subsume C B.
subsume (Z\(A Z &amp; B Z)) C :-
subsume A C, subsume B C.
subsume A (Z\(B Z &amp; C Z)) :- subsume A B.
subsume A (Z\(B Z &amp; C Z)) :- subsume A C.
subsume (Z\(all (Y\(R Z Y =&gt; A Y))))
(Z\(all (Y\(1 Z Y =&gt; B Y)))) :-
subsume A B.
</figure>
<bodyText confidence="0.999945636363637">
The first few clauses specify certain primitive containment
relations; thus the first clause states that the set described
by crew is contained in the set described by person. The
later clauses specify subsumption relations based on these
primitive ones and on the logical structure of the terms
describing the concepts. One of the virtues of our rep-
resentation now becomes clear: It is easy to see that the
above set of clauses correctly specifies the relation of sub-
sumption. If A and B are two terms that represent concepts,
then rather elementary proof-theoretic arguments may be
employed to show that (subsumes A B) is provable from
the above clauses if and only if the first-order term (all
X\ (B X =&gt; A X)) is logically entailed by the primitive sub-
sumption relations. Furthermore, any sound and complete
interpreter for AProlog (such as one searching breath-first)
may be used together with these clauses to provide a sound
and complete subsumption algorithm.
Another kind of inference that is often of interest is
that of determining whether an object a is in the set of
objects denoted by a concept C. This question reduces to
whether (C a) is a theorem. This inference may be encoded
in definite clauses in the manner illustrated below:
</bodyText>
<construct confidence="0.559557">
fact (important_message m1).
fact (sender ml kirk).
fact (recipient ml scotty).
interp A :- fact A.
</construct>
<page confidence="0.996013">
253
</page>
<bodyText confidence="0.853887710843374">
interp (A &amp; B) interp A, interp B.
interp (C U)
subsume (X \ (all Y\ (R X Y =&gt; C Y))) D,
fact (R V U). interp (D V).
interp (CU) :- subsume C D, interp (D U).
In the clauses above, fact and interp are predicates of
type b -&gt; o. The first few clauses state which formulas
of type b should be considered true; (fact X) may be
read as an assertion that X is true. The last few clauses
define interp to be a theorem-prover that uses subsume
and fact to deduce additional formulas of type b. The
only clause that may need to be explained here is the third
one pertaining to interp. This clause may be explained as
follows. Let (D V) and (subsume (X\ (all Y\ (R X Y =&gt; C
Y))) D) be true. By virtue of the meaning of subsumption,
((X\ (all Y\ (R X Y =&gt; C Y))) V), i.e. (all Y\ (B. V
Y =&gt; C Y)), is true. From this it follows that for any U
if (R V U) is true then so is (C U). Given the clauses in
this section, some of the inferences that are possible are the
following: kirk is a person and a commander, and scotty
is a crew and a person. That is, (interp (person kirk)),
for example, is provable from these definite clauses.
7. Syntax and Semantics in Parsing
In Section 5, we showed how sentences and phrases
could be translated into logical forms that correspond to
their meaning. Such logical forms are well defined objects
in our language and in Section 6 we illustrated the possibil-
ity of defining logical inferences on such objects. There are
parsing problems which require semantical analysis as well
as syntactic analysis and our language provides the ability
to combine such analyses in one computational framework.
A common approach in natural language understanding
systems is to use one computational paradigm for syntactic
analysis (e.g. DCGs, ATNs) and another one for seman-
tic analysis (e.g. frames, semantic nets). An integration of
these two paradigms is often difficult to explain in a for-
mal sense. Using the approach that we suggest here also
results in the syntactic and semantic processing being done
at two different levels: one is first-order and the other is
higher-order. Bridging these two levels, however, can be
very natural. For example, the query (see Section 4)
R, B. john mary
mixes both aspects. The process of determining a suitable
instantiation for R is second-order, while the process of de-
termining whether or not (R john mary) is provable is
first-order.
The problem of determining referents for pronouns
provides a example where such an intermixing of levels is
necessary, since possible referents for a pronoun must be
checked for membership in the male or female concepts.
For example, consider the following sentences: &amp;quot;John likes
Mary. She loves him.&amp;quot; The problem here is that of identify-
ing &amp;quot;she&amp;quot; with Mary and &amp;quot;him&amp;quot; with John. This processing
could be done in the following fashion: First, a DCG similar
to the one in Section 5 could be written which returns not
only the logical form corresponding to a sentence but also
a list of possible referents for pronouns that occur later. In
this example, the list of proper nouns (john, mary] would
be returned. When pronouns are encountered, the DCG
would substitute some male or female elements from this
list, depending on the gender of the pronoun. The process
of selecting an appropriate referent may be accomplished
with the following clauses:
prim_concept male.
prim_concept female.
fact (female mary).
fact (male john).
select G X [XIL] interp (G X).
select G X [YIL] :- select X L G.
A call to the goal (select female X [john, mary]) would
result in picking mary as a female from the set of proper
nouns. This is, of course, a very simple example. This
framework, however, supports the following extension.
Let sentences contain definite descriptions. Consider
the following sentences: &amp;quot;The uncle whose children are all
doctors likes Mary. She loves him.&amp;quot; Here, &amp;quot;him&amp;quot; clearly
refers to the uncle whose children are all doctors. In order
to modify our above program we need to make only a few
additions. First, we need to be able to take a concept,
such as &amp;quot;uncle whose children are all doctors&amp;quot; and encode
the (unique) individual within it. To do this, we use the
definite description operator described in Section 5. Hence,
after parsing the first sentence, the list
</bodyText>
<figure confidence="0.636915">
[(iota (X\(uncle X &amp;
(all Y\(child X Y =&gt; doctor Y))))).
mary]
</figure>
<figureCaption confidence="0.3561875">
would be returned as the list of possible pronoun references.
Consider the following additional definite clauses.
</figureCaption>
<bodyText confidence="0.9409123">
prim_concept man.
prim_concept uncle.
prim_concept doctor.
prim_relation child.
subsume male man.
subsume man uncle.
interp (P (iota Q)) :- subsume P Q.
The first six clauses give properties to some of the lexical
items in this sentence. Only the last clause is an addition
to our actual program. This clause, however, is very im-
portant since it is one of those simple and elegant ways in
which the different logical levels can be related. A term
of the form (iota Q) represents a first-order individual
(i.e. some object), but it does so by carrying with it a de-
scription of that object (the concept Q). This description
can be invoked by the following inference: the Q is a P if
all Qs are Ps. Hence, checking membership in a concept is
transformed into a check for subsumption.
To find a referent for &amp;quot;him&amp;quot; in our example sentences,
the goal
</bodyText>
<reference confidence="0.754634">
(select male X
[(iota (X\ (uncle X &amp;
(all Y\(child X Y =&gt; doctor Y))))),
mary])
</reference>
<page confidence="0.997961">
254
</page>
<bodyText confidence="0.9117948">
would be used to pick the male from the list of possible
pronoun references. (Notice here that X occurs both free
and bound in this query.) In attempting to satisfy this
goal, the goal
(interp
(male (iota (X\ (uncle X &amp;
(all Y\ (child X Y =&gt; doctor Y)))))))
and then the goal
(subsume male (X\ (uncle X &amp;
(all Y\ (child X Y =&gt; doctor Y)))))
would be attempted. This last goal is clearly satisfied pro-
viding a suitable referent for the pronoun &amp;quot;him.&amp;quot;
8. Compiling into First-Order Logic
We have suggested that higher-order logic can be used
to provide a formal specification and justification of certain
computations involving meanings and parsing. We have
been concerned with explaining a logic programming ap-
proach to integrating syntactic and semantic processing.
Higher-order logic is, of course, not needed to perform such
computations. In fact, once we have specified algorithms in
this higher-order setting, it is occasionally the case that a
first-order re-implementation is possible. For example, all
the specifications in Section 6 can be transformed or &amp;quot;com-
piled&amp;quot; into first-order definite clauses. One way of perform-
ing such a compilation is to define the following constants
to be the corresponding A-terms:
and C\D\Xâ€œC X dc D X)
restr R\C\X\(all Y\(R X Y =&gt; C Y))
Using these definitions, the clauses for role, concept, and
subsume may be rewritten as the following:
</bodyText>
<reference confidence="0.9894763">
role R prim_role R.
concept C prim_concept C.
concept (and Cl C2) :- concept Cl, concept C2.
concept (restr R Cl) :- concept Cl, role R.
subsume C C.
subsume A B :- subsume A C. subsume C B.
subsume (and A B) C :- subsume A C. subsume B C.
subsume A (and B C) :- subsume A B.
subsume A (and B C) :- subsume A C.
subsume (restr R A) (restr R B) :- subsume A B.
</reference>
<bodyText confidence="0.878214727272727">
Introducing the notion of an element of a concept is less
straightforward. In order to do this, we need to first differ-
entiate between a fact that states membership in a concept
and a fact that states a relationship between two elements.
We do this by making the following additional definitions:
is_a C\X\(fact (C X))
related R\X\Y\(fact (a X Y))
If we assume that interp is only used to decide membership
in concepts, then we may replace (interp (C X)) by (is_a
C X). The remaining clauses in Section 6 can be translated
into the following:
</bodyText>
<reference confidence="0.970027">
is_a important_message ml.
related sender ml kirk.
related recipient mi scotty.
is_a (and A B) X :- is_a A X, is_a B X.
is_a C U :- subsume (restr R C) D.
related R V U. is_a D V.
is_a C U :- subsume C D. is_a D U.
</reference>
<bodyText confidence="0.999806818181818">
The resulting first-order program is isomorphic to the orig-
inal, higher-order program. The subsumption algorithm in
[3] is essentially the one specified by the clauses that define
subsume. There are two important points to make regard-
ing this program, however. First, to correctly specify its
meaning, one needs to develop the machinery of the higher-
order program which we first presented. Second, this lat-
ter program represents a compilation of the first program.
This compilation relys on simplifing the representation of
concepts and roles to a point where their logical structure
is no longer apparent. As a result, it would be harder to
extend this program with new forms of concepts, roles and
inferences that involves them. The original program, how-
ever, is easy to extend.
Another way to see this comparison is to say that the
higher-order program is the formal semantics of the first-
order program. This way of looking at semantics is very
similar to the denotational approach to specifying program
language semantics. There, the correct understanding of
very simple, low level programming features might involve
constructions which are higher-order and functional in na-
ture.
</bodyText>
<sectionHeader confidence="0.997969" genericHeader="conclusions">
9. Conclusions
</sectionHeader>
<bodyText confidence="0.993983454545455">
Our goal in this paper was to argue that higher-order
logic has a meaningful role to play in computational lin-
guistics. Towards this end, we have described a version of
definite clauses based on higher-order logic and presented
several examples that illustrate their possible use in a nat-
ural language understanding system. We have built an ex-
perimental, depth-first interpreter for AProlog on which we
have tested all the programs that appear in this paper (and
many others). We are currently working on the design and
implemention of an efficient interpreter for this program-
ming language.
</bodyText>
<page confidence="0.996899">
255
</page>
<sectionHeader confidence="0.995384" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999972216216216">
[1] Peter B. Andrews, &amp;quot;Resolution in Type Theory,&amp;quot; Jour-
nal of Symbolic Logic 36 (1971), 414 â€” 432.
[2] Peter B. Andrews, Dale A. Miller, Eve Longini Cohen,
Frank Pfenning, &amp;quot;Automating Higher-Order Logic&amp;quot; in
Automated Theorem Proving: After 25 Years, AMS
Contemporary Mathematics Series 29 (1984).
[3] Ronald J. Brachman, Hector J. Levesque, &amp;quot;The Trac-
tability of Subsumption in Frame-based Description
Languages&amp;quot; in the Proceedings of the National Con-
ference on Artificial Intelligence, AAAI 1984, 34 â€” 37.
[4] Ronald J. Brachman, James G. Schmolze, &amp;quot;An Over-
view of the KL-ONE Knowledge Representation Sys-
tem,&amp;quot; Cognitive Science 9 (1985), 171 â€” 216.
[5] Alonzo Church, &amp;quot;A Formulation of the Simple Theory
of Types,&amp;quot; Journal of Symbolic Logic 5 (1940), 56 â€”
68.
[6] David R. Dowty, Robert E. Wall, Stanley Peters, Intro-
duction to Montague Semantics, D. Reidel Publishing
Co., 1981.
[7] Michael J. Gordon, Arthur J. Milner, Christopher P.
Wadsworth, Edinburgh LCF, Springer-Verlag Lecture
Notes in Computer Science No. 78, 1979.
[8] Gerard P. Huet, &amp;quot;A Unification Algorithm for Typed
A-calculus,&amp;quot; Theoretical Computer Science 1 (1975),
27 â€” 57.
[9] Dale A. Miller, Gopalan Nadathur, &amp;quot;Higher-order
Logic Programming,&amp;quot; in the Proceedings of the Third
International Logic Programming Conference, Impe-
rial College, London England, July 1986.
[10] F. C. N. Pereira, D. H. D. Warren, &amp;quot;Definite Clause
Grammars for Language Analysis â€” A Survey of the
Formalism and a Comparison with Augmented Tran-
sition Networks&amp;quot; in Artificial Intelligence 13 (1980).
[11] David Scott Warren, &amp;quot;Using A-Calculus to Represent
Meaning in Logic Grammars&amp;quot; in the Proceedings of
the 21st Annual Meeting of the Association for Com-
putational Linguistics, June 1983, 51 â€” 56.
</reference>
<page confidence="0.998449">
256
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.906765">
<title confidence="0.9990035">Some Uses of Higher-Order Logic in Computational Linguistics</title>
<author confidence="0.999762">Dale A Miller</author>
<author confidence="0.999762">Gopalan Nadathur</author>
<affiliation confidence="0.998774">Computer and Information Science University of Pennsylvania</affiliation>
<address confidence="0.998147">Philadelphia, PA 19104 â€” 3897</address>
<abstract confidence="0.996864392857143">Consideration of the question of meaning in the framework of linguistics often requires an allusion to sets and other higher-order notions. The traditional approach to representing and reasoning about meaning in a computational setting has been to use knowledge representation systems that are either based on first-order logic or that use mechanisms whose formal justifications are to be provided after the fact. In this paper we shall consider the use of a higher-order logic for this task. We first present a version of definite clauses (positive Horn clauses) that is based on this logic. Predicate and function variables may occur in such clauses and the terms in the language are the typed A-terms. Such term structures have a richness that may be exploited in representing meanings. We also describe a higher-order logic programming language, called AProlog, which represents programs as higher-order definite clauses and interprets them using a depth-first interpreter. A virtue of this language is that it is possible to write programs in it that integrate syntactic and semantic analyses into one computational paradigm. This is to be contrasted with the more common practice of using two entirely different computation paradigms, such as DCGs or ATNs for parsing and frames or semantic nets for semantic processing. We illustrate such an integration in this language by considering a simple example, and we claim that its use makes the task of providing formal justifications for the computations specified much more direct.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="false">
<title>mary]) role R prim_role R. concept C prim_concept C. concept (and Cl C2) :- concept Cl, concept C2. concept (restr R Cl) :- concept Cl, role R. subsume C C. subsume A B :- subsume A C.</title>
<journal>subsume C B. subsume (and A B) C :- subsume A C. subsume B C. subsume A (and B C) :- subsume A B. subsume A (and B C) :- subsume A C. subsume (restr R A) (restr R B)</journal>
<marker></marker>
<rawString> (select male X [(iota (X\ (uncle X &amp; (all Y\(child X Y =&gt; doctor Y))))), mary]) role R prim_role R. concept C prim_concept C. concept (and Cl C2) :- concept Cl, concept C2. concept (restr R Cl) :- concept Cl, role R. subsume C C. subsume A B :- subsume A C. subsume C B. subsume (and A B) C :- subsume A C. subsume B C. subsume A (and B C) :- subsume A B. subsume A (and B C) :- subsume A C. subsume (restr R A) (restr R B) :- subsume A B. is_a important_message ml. related sender ml kirk. related recipient mi scotty. is_a (and A B) X :- is_a A X, is_a B X. is_a C U :- subsume (restr R C) D. related R V U. is_a D V. is_a C U :- subsume C D. is_a D U.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Peter B Andrews</author>
</authors>
<title>Resolution in Type Theory,&amp;quot;</title>
<date>1971</date>
<journal>Journal of Symbolic Logic</journal>
<volume>36</volume>
<pages>414--432</pages>
<contexts>
<context position="6807" citStr="[1]" startWordPosition="1080" endWordPosition="1080">uch an encoding has little significance, however, with regard to the appropriateness of one language over another for a given set of computational tasks. Clearly, all general purpose programming languages can be encoded onto first-order logic, but this has little significance with regard to the suitability of a given programming language for certain applications. Although less work has been done on theorem proving in higher-order logic than in first-order logic as claimed in the last point, the nature of proofs in higher-order logic is far from mysterious. For example, higher-order resolution [1] and unification [8] has been developed, and based on these principles, several theorem provers for various higherorder logics (see [2] and its references) have been built and tested. The experience with such systems shows that theorem proving in such a logic is difficult. It is not clear, however, that the difficulty is inherent in the language chosen to express a theorem rather than in the theorem itself. In fact, expressing a higher-order theorem (as we will claim many statements about meaning are) in a higher-order logic makes its logical structure more explicit than an encoding into first</context>
</contexts>
<marker>[1]</marker>
<rawString>Peter B. Andrews, &amp;quot;Resolution in Type Theory,&amp;quot; Journal of Symbolic Logic 36 (1971), 414 â€” 432.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Peter B Andrews</author>
<author>Dale A Miller</author>
</authors>
<title>Eve Longini Cohen, Frank Pfenning, &amp;quot;Automating Higher-Order Logic&amp;quot;</title>
<date>1984</date>
<booktitle>in Automated Theorem Proving: After 25 Years, AMS Contemporary Mathematics Series</booktitle>
<volume>29</volume>
<contexts>
<context position="6942" citStr="[2]" startWordPosition="1101" endWordPosition="1101">mputational tasks. Clearly, all general purpose programming languages can be encoded onto first-order logic, but this has little significance with regard to the suitability of a given programming language for certain applications. Although less work has been done on theorem proving in higher-order logic than in first-order logic as claimed in the last point, the nature of proofs in higher-order logic is far from mysterious. For example, higher-order resolution [1] and unification [8] has been developed, and based on these principles, several theorem provers for various higherorder logics (see [2] and its references) have been built and tested. The experience with such systems shows that theorem proving in such a logic is difficult. It is not clear, however, that the difficulty is inherent in the language chosen to express a theorem rather than in the theorem itself. In fact, expressing a higher-order theorem (as we will claim many statements about meaning are) in a higher-order logic makes its logical structure more explicit than an encoding into first-order logic does. Consequently, it is reasonable to expect that the higher-order representation should actually simplify the process o</context>
</contexts>
<marker>[2]</marker>
<rawString>Peter B. Andrews, Dale A. Miller, Eve Longini Cohen, Frank Pfenning, &amp;quot;Automating Higher-Order Logic&amp;quot; in Automated Theorem Proving: After 25 Years, AMS Contemporary Mathematics Series 29 (1984).</rawString>
</citation>
<citation valid="false">
<authors>
<author>Ronald J Brachman</author>
<author>Hector J Levesque</author>
</authors>
<title>The Tractability of Subsumption in Frame-based Description Languages&amp;quot;</title>
<booktitle>in the Proceedings of the National Conference on Artificial Intelligence, AAAI 1984, 34 â€” 37.</booktitle>
<marker>[3]</marker>
<rawString>Ronald J. Brachman, Hector J. Levesque, &amp;quot;The Tractability of Subsumption in Frame-based Description Languages&amp;quot; in the Proceedings of the National Conference on Artificial Intelligence, AAAI 1984, 34 â€” 37.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ronald J Brachman</author>
<author>James G Schmolze</author>
</authors>
<title>An Overview of the KL-ONE Knowledge Representation System,&amp;quot;</title>
<date>1985</date>
<journal>Cognitive Science</journal>
<volume>9</volume>
<pages>171--216</pages>
<contexts>
<context position="34810" citStr="[4]" startWordPosition="6065" endWordPosition="6065">order unification, seems to provide a balance between clarity and efficiency. The final point to be noted is that the terms that are produced at intermediate stages in the parsing process are logically meaningful terms, and computations on such terms may be encoded in other clauses in our language. In Section 7, we show how some of these terms can be directly interpreted as frame-like objects. 6. Knowledge Representation We now consider the question of how a higher-order logic might be used for the task of representing knowledge. Traditionally, certain network based formalisms, such as KL-ONE [4], have been described for this purpose. Such formalisms use nodes and arcs in a network to encode 252 knowledge, and provide algorithms that operate on this network in order to perform inferences on the knowledge so represented. The nature of the information represented in the network may be clarified with reference to a logic, and the correctness of the algorithms is often proved by showing that they perform certain kinds of logical inference on the underlying information. Our approach here is to encode the relevant notions by using A-terms that directly correspond to their logical nature, an</context>
<context position="36216" citStr="[4]" startWordPosition="6301" endWordPosition="6301">provides the ability to define primitive roles and concepts and a mechanism to put these together to define more complex concepts. The intended interpretation of a role is a two place relation, and of a concept is a set of objects characterized by some defining property. An appropriate logical view of a concept, therefore, is to identify it with a one-place predicate. A particularly apt way of modeling the connection between a concept and a predicate is to use A-terms of a certain kind to denote concepts. The following set of clauses that are used to define concepts modelled after examples in [4] serves to make this clear. prim_role recipient. prim_role sender. prim_role supervisor. prim_concept person. prim_concept crew. prim_concept commander. prim_concept message. prim_concept important_message. role R prim_role R. concept C prim_concept C. concept (X\ (C1 X &amp; C2 X)) :- concept Cl, concept C2.. concept (X\(all Y\ (R X Y =&gt; Cl Y))) :- concept Cl, role R. The type of prim_role and role in the above example is (i -&gt; i -&gt; b) -&gt; o and of prim_concept and concept is (i -&gt; b) -&gt; o. Any term that can be substituted for R so as to make (role R) provable from these clauses is considered a ro</context>
</contexts>
<marker>[4]</marker>
<rawString>Ronald J. Brachman, James G. Schmolze, &amp;quot;An Overview of the KL-ONE Knowledge Representation System,&amp;quot; Cognitive Science 9 (1985), 171 â€” 216.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Alonzo Church</author>
</authors>
<title>A Formulation of the Simple Theory of Types,&amp;quot;</title>
<date>1940</date>
<journal>Journal of Symbolic Logic</journal>
<volume>5</volume>
<pages>56--68</pages>
<contexts>
<context position="8927" citStr="[5]" startWordPosition="1422" endWordPosition="1422">tional process. We shall first present a definite clause grammar that analyses the syntactic structure of simple English sentences to produce logical forms in much the same way as is done in the Montague framework. We shall then show how semantic analyses may be specified via operations on such logical forms. Finally, we shall illustrate interactions between these two kinds of analyses by considering an example of determining pronoun reference. 2. Higher-Order Logic The higher-order logic we study here, called T, can be thought of as being a subsystem of either Church&apos;s Simple Theory of Types [5] or of Montague&apos;s intensional logic IL [6]. Unlike Church&apos;s or Montague&apos;s logics, T is very weak because it assumes no axioms regarding extensionality, definite descriptions, infinity, choice, or possible worlds. T encompasses only the most primitive logical notions, and generalizes first-order logic by introducing stronger notions of variables and substitutions. Our use of T is not driven by a desire to capture of the meaning of linguistic objects, as was the hope of Montague. It is our hope that programs written in T will do that. The language of T is a typed language. The typing mechanism p</context>
</contexts>
<marker>[5]</marker>
<rawString>Alonzo Church, &amp;quot;A Formulation of the Simple Theory of Types,&amp;quot; Journal of Symbolic Logic 5 (1940), 56 â€” 68.</rawString>
</citation>
<citation valid="true">
<authors>
<author>David R Dowty</author>
<author>Robert E Wall</author>
</authors>
<title>Stanley Peters, Introduction to Montague Semantics,</title>
<date>1981</date>
<publisher>Reidel Publishing Co.,</publisher>
<location>D.</location>
<contexts>
<context position="8969" citStr="[6]" startWordPosition="1429" endWordPosition="1429">efinite clause grammar that analyses the syntactic structure of simple English sentences to produce logical forms in much the same way as is done in the Montague framework. We shall then show how semantic analyses may be specified via operations on such logical forms. Finally, we shall illustrate interactions between these two kinds of analyses by considering an example of determining pronoun reference. 2. Higher-Order Logic The higher-order logic we study here, called T, can be thought of as being a subsystem of either Church&apos;s Simple Theory of Types [5] or of Montague&apos;s intensional logic IL [6]. Unlike Church&apos;s or Montague&apos;s logics, T is very weak because it assumes no axioms regarding extensionality, definite descriptions, infinity, choice, or possible worlds. T encompasses only the most primitive logical notions, and generalizes first-order logic by introducing stronger notions of variables and substitutions. Our use of T is not driven by a desire to capture of the meaning of linguistic objects, as was the hope of Montague. It is our hope that programs written in T will do that. The language of T is a typed language. The typing mechanism provides for the usual notion of sorts ofte</context>
</contexts>
<marker>[6]</marker>
<rawString>David R. Dowty, Robert E. Wall, Stanley Peters, Introduction to Montague Semantics, D. Reidel Publishing Co., 1981.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Michael J Gordon</author>
<author>Arthur J Milner</author>
<author>Christopher P Wadsworth</author>
</authors>
<date>1979</date>
<booktitle>LCF, Springer-Verlag Lecture Notes in Computer Science No.</booktitle>
<volume>78</volume>
<location>Edinburgh</location>
<contexts>
<context position="18213" citStr="[7]" startWordPosition="3087" endWordPosition="3087">rows a great deal from that of Prolog. Symbols that begin with capital letters represent variables. All other symbols represent constants. Clauses are written backwards and the symbol : - is used for C. There are, however, some differences. We have adopted a curried notation for terms, rather than the notation normally used in a first-order language. Since the language is a typed one, types must be associated with each term. This is done by 249 either explicitly defining the type of a constant or a variable, or by inferring such a type by a process very similar to that used in the language ML [7]. The type expressions that are attached to symbols may contain variables which provide a form of polymorphism. As an example cons and nil above are assumed to have the types A -&gt; (list A) -&gt; (list A) and (list A) respectively; they serve to define lists of different kinds, but each list being such that all its elements have a common type. (For the convenience of expression, we shall actually use Prolog&apos;s notation for lists in the remainder of this paper, i.e. we shall write (cons X L) as [X1L]). In the examples in this paper, we shall occasionally provide type associations, but in general we </context>
</contexts>
<marker>[7]</marker>
<rawString>Michael J. Gordon, Arthur J. Milner, Christopher P. Wadsworth, Edinburgh LCF, Springer-Verlag Lecture Notes in Computer Science No. 78, 1979.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Gerard P Huet</author>
</authors>
<title>A Unification Algorithm for Typed A-calculus,&amp;quot;</title>
<date>1975</date>
<journal>Theoretical Computer Science</journal>
<volume>1</volume>
<pages>27--57</pages>
<contexts>
<context position="6827" citStr="[8]" startWordPosition="1083" endWordPosition="1083">little significance, however, with regard to the appropriateness of one language over another for a given set of computational tasks. Clearly, all general purpose programming languages can be encoded onto first-order logic, but this has little significance with regard to the suitability of a given programming language for certain applications. Although less work has been done on theorem proving in higher-order logic than in first-order logic as claimed in the last point, the nature of proofs in higher-order logic is far from mysterious. For example, higher-order resolution [1] and unification [8] has been developed, and based on these principles, several theorem provers for various higherorder logics (see [2] and its references) have been built and tested. The experience with such systems shows that theorem proving in such a logic is difficult. It is not clear, however, that the difficulty is inherent in the language chosen to express a theorem rather than in the theorem itself. In fact, expressing a higher-order theorem (as we will claim many statements about meaning are) in a higher-order logic makes its logical structure more explicit than an encoding into first-order logic does. C</context>
<context position="16304" citStr="[8]" startWordPosition="2758" endWordPosition="2758">can be combined to build a theorem prover in either case. However, unification in the higher-order setting is complicated by the presence of A-conversion: two terms t and s are unifiable if there exists some substitution go such that cos and cot are equal modulo A-conversions. Since /3-conversion is a very complex process, determining this kind of equality is difficult. The unification of typed A-terms is, in general, not decidable, and when unifiers do exist, there need not exist a single most general unifier. Nevertheless, it is possible to systematically search for unifiers in this setting [8] and an interpreter for higher-order definite clauses can be built around this procedure. The resulting interpreter can be made to resemble Prolog except that it must account for the extra degree of nondeterminism which arises from higher-order unification. Although there are several important issues regarding the search for higher-order unifiers, we shall ignore them here since all the unification problems which arise in this paper can be solved by even a simpleminded implementation of the procedure described in [8]. 3. AProlog We have used higher-order definite clauses and a depth-first inte</context>
</contexts>
<marker>[8]</marker>
<rawString>Gerard P. Huet, &amp;quot;A Unification Algorithm for Typed A-calculus,&amp;quot; Theoretical Computer Science 1 (1975), 27 â€” 57.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Dale A Miller</author>
</authors>
<title>Gopalan Nadathur, &amp;quot;Higher-order Logic Programming,&amp;quot;</title>
<date>1986</date>
<booktitle>in the Proceedings of the Third International Logic Programming Conference,</booktitle>
<location>Imperial College, London England,</location>
<contexts>
<context position="17212" citStr="[9]" startWordPosition="2904" endWordPosition="2904">arding the search for higher-order unifiers, we shall ignore them here since all the unification problems which arise in this paper can be solved by even a simpleminded implementation of the procedure described in [8]. 3. AProlog We have used higher-order definite clauses and a depth-first interpreter to describe a logic programming language called AProlog. We present below a brief exposition of the higher-order features of this language that we shall use in the examples in the later sections. A fuller description of the language and of the logical considerations underlying it may be found in [9]. Programs in AProlog are essentially higher-order definite clauses. The following set of clauses that define certain standard list operations serve to illustrate some of the syntactic features of our language. append nil K K. append (cons X L) K (cons X M) :- append L K M. member X (cons X L). member X (cons Y L) :- member X L. As should be apparent from these clauses, the syntax of AProlog borrows a great deal from that of Prolog. Symbols that begin with capital letters represent variables. All other symbols represent constants. Clauses are written backwards and the symbol : - is used for C.</context>
<context position="27125" citStr="[9]" startWordPosition="4701" endWordPosition="4701">R, primrel S. The first four clauses identify four primitive relations between individuals (primrel has type (i -&gt; j -&gt; o) -&gt; o). These are then used to define other relations that are a result of &amp;quot;joining&amp;quot; primitive relations. Now if (mother Jane nary) and (wife John Jane) are provided as additional clauses, then the query (rel R. R John nary) would yield the substitution X \ Y \ (sigma Z\ (wife X Z, mother Z Y)) for R. This query asks for a relation (in the sense of rel) between j ohm and mary. The answer substitution provides the relation mother-in-law. We have been able to show (Theorem 1 [9]) that any proof in T of a goal formula from a set of definite clauses which uses a predicate term containing the logical connectives --, D, or V, can be converted into another proof in which only predicate terms from )(+ are used. Thus, it is not possible for a term such as Ax (person(x) A Vy (child(x,y) D doctor(y))) to be specified by a AProlog program, i.e. be the unique substitution which makes some goal provable from some set of definite clauses. This is because a consequence of our theorem is that if this term is an answer substitution then there is also another A-term that does not use</context>
</contexts>
<marker>[9]</marker>
<rawString>Dale A. Miller, Gopalan Nadathur, &amp;quot;Higher-order Logic Programming,&amp;quot; in the Proceedings of the Third International Logic Programming Conference, Imperial College, London England, July 1986.</rawString>
</citation>
<citation valid="true">
<authors>
<author>F C N Pereira</author>
<author>D H D Warren</author>
</authors>
<title>Definite Clause Grammars for Language Analysis â€” A Survey of the Formalism and a Comparison with Augmented Transition Networks&amp;quot;</title>
<date>1980</date>
<journal>in Artificial Intelligence</journal>
<volume>13</volume>
<contexts>
<context position="30378" citStr="[10]" startWordPosition="5269" endWordPosition="5269">-term (all X (some Y\ (p X Y =&gt; q Y X))) may be used to represent the above formula. The type b should be thought of as a term-level encoding of the boolean type o. A more complete illustration of the facilities alluded to above may be provided by considering the task of translating simple English sentences into logical forms. As an example, consider translating the sentence &amp;quot;Every man loves a woman&amp;quot; to the logical form Vx(man(x) D y(woman(y) A loves(x,y))) which in our context will be represented by the A-term (all X\ (man X =&gt; (some Y\(soman Y &amp; loves X Y)))) A higher-order version of a DCG [10] for performing this task is provided below. This DCG draws on the spirit of Montague Grammars. (See [11] for a similar example.) sentence (P1 P2) --&gt; np Pi, vp P2, [.]. np (Pi P2) --&gt; determ Pi, nom P2. np P --&gt; propernoun P. nom P --&gt; noun P. nom X\(P1 X &amp; P2 X) --&gt; noun Pi, reici-P2. VP X\(P2 (Pi X)) --&gt; transverb Pi, np P2. VP P --&gt; intransverb P. relcl P --&gt; [that], vp P. determ P1\P2\(all X\(P1 X =&gt; P2 X)) --&gt; [every]. determ P1\P2\(P2 (iota Pi)) --&gt; [the]. determ P1\P2\(some X\(131 X &amp; P2 X)) --&gt; [a]. noun man --&gt; [man] . noun woman --&gt; [woman). propernoun john - - &gt; [ j ohn] . properno</context>
<context position="32127" citStr="[10]" startWordPosition="5602" endWordPosition="5602">or; it picks out an individual given a description of a set of individuals. Thus, parsing the sentence &amp;quot;The woman that loves john likes mary&amp;quot; produces the term (likes (iota X \ (woman X &amp; loves X john)) mary), the intended meaning of which is the predication of the relationship of liking between an object that is picked out by the description X (woman X &amp; loves X john)) and mary. Using this DCG to parse a sentence illustrates the role that abstraction and application play in realizing the notion of substitution. It is interesting to compare this DCG with the one in Prolog that is presented in [10]. The first thing to note is that the two will parse a sentence in nearly identical fashions. In the first-order version, however, there is a need to explicitly encode the process of substitution, and considerable ingenuity must be exercised in devising grammar rules that take care of this process. In contrast in AProlog the process of substitution and the process of parsing are handled by two distinct mechanisms, and consequently the resulting DCG is more perspicuous and so also easier to extend. The DCG presented above may also be used to solve the inverse problem, namely that of obtaining a</context>
</contexts>
<marker>[10]</marker>
<rawString>F. C. N. Pereira, D. H. D. Warren, &amp;quot;Definite Clause Grammars for Language Analysis â€” A Survey of the Formalism and a Comparison with Augmented Transition Networks&amp;quot; in Artificial Intelligence 13 (1980).</rawString>
</citation>
<citation valid="true">
<authors>
<author>David Scott Warren</author>
</authors>
<title>Using A-Calculus to Represent Meaning in Logic Grammars&amp;quot;</title>
<date>1983</date>
<booktitle>in the Proceedings of the 21st Annual Meeting of the Association for Computational Linguistics,</booktitle>
<pages>51--56</pages>
<contexts>
<context position="30483" citStr="[11]" startWordPosition="5287" endWordPosition="5287"> thought of as a term-level encoding of the boolean type o. A more complete illustration of the facilities alluded to above may be provided by considering the task of translating simple English sentences into logical forms. As an example, consider translating the sentence &amp;quot;Every man loves a woman&amp;quot; to the logical form Vx(man(x) D y(woman(y) A loves(x,y))) which in our context will be represented by the A-term (all X\ (man X =&gt; (some Y\(soman Y &amp; loves X Y)))) A higher-order version of a DCG [10] for performing this task is provided below. This DCG draws on the spirit of Montague Grammars. (See [11] for a similar example.) sentence (P1 P2) --&gt; np Pi, vp P2, [.]. np (Pi P2) --&gt; determ Pi, nom P2. np P --&gt; propernoun P. nom P --&gt; noun P. nom X\(P1 X &amp; P2 X) --&gt; noun Pi, reici-P2. VP X\(P2 (Pi X)) --&gt; transverb Pi, np P2. VP P --&gt; intransverb P. relcl P --&gt; [that], vp P. determ P1\P2\(all X\(P1 X =&gt; P2 X)) --&gt; [every]. determ P1\P2\(P2 (iota Pi)) --&gt; [the]. determ P1\P2\(some X\(131 X &amp; P2 X)) --&gt; [a]. noun man --&gt; [man] . noun woman --&gt; [woman). propernoun john - - &gt; [ j ohn] . propernoun mary --&gt; [mary). transverb loves --&gt; [loves] . transverb likes --&gt; [likes] . intransverb lives --&gt; [li</context>
</contexts>
<marker>[11]</marker>
<rawString>David Scott Warren, &amp;quot;Using A-Calculus to Represent Meaning in Logic Grammars&amp;quot; in the Proceedings of the 21st Annual Meeting of the Association for Computational Linguistics, June 1983, 51 â€” 56.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>