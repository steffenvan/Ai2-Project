<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<note confidence="0.3925326">
MONTAGOVIAN DEFINITE CLAUSE GRAMMAR
R.I.Bainbridge,
Dept. of Computer Science.
Teesside Polytechnic,
Middlesbrough, Cleveland, England.
</note>
<sectionHeader confidence="0.954888" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.973597095238095">
This paper reports a completed stage of
ongoing research at the University of
York. Landsbergen&apos;s advocacy of analyt—
ical inverses for compositional syntax
rules encourages the application of Defin—
ite Clause Grammar techniques to the cons—
truction of a parser returning Montague
analysis trees. A parser MDCG is pres—
ented which implements an augmented
Friedman — Warren algorithm permitting
post referencing, and interfaces with a
language of intensional logic translator
LILT so as to display the derivational
history of corresponding reduced IL form—
ulae. Some familiarity with Montague&apos;s
PTO and the basic DCG mechanism is
assumed.
Ke words Compositional Semantics, Definite
Clause Grammar, Friedman Warren Algorithm,
Intensional Logic, Montague Grammmar, Nat—
ural Language Processing, PROLOG.
</bodyText>
<sectionHeader confidence="0.998607" genericHeader="keywords">
1 Introduction
</sectionHeader>
<bodyText confidence="0.978515333333333">
Consideration is given by Landsbergen
[20] to the global algorithmic structure
of a top down parser demonstrably equi—
valent to a compositional grammar such as
that of PTO [223. The method is as
follows:
</bodyText>
<listItem confidence="0.832232333333333">
1. Formulate the original grammar in
terms of indexed compositional—M rules of
form:
</listItem>
<bodyText confidence="0.960454285714286">
If syntax trees &lt;Sk..Sn) satisfy
condition C then combine
&lt;Sk..Sn&gt; into Sj
such that the compositional history may be
represented on a derivation tree (i.e. a
skeletal analysis tree lacking node
labels).
</bodyText>
<listItem confidence="0.7915713">
2. Subject to specified restraints evolve
inverse analytical—M Rules of form:
If Sj conforms to condition C&apos;
then analyse Sj into &lt;Sk..Sn&gt;.
3. Prove that the compositional and ana—
lytical M rules are equivalent.
4. Construct a two stage parser:
(i) Parse a sentence using a context
free grammar (CFG) thus deriving a
syntax tree.
</listItem>
<bodyText confidence="0.975857533333333">
(ii) Traverse the syntax tree in
postorder [19) under the guidance of
the analytical—M rules. constructing
the derivation tree which reflects
the reverse order application of the
inverse rules.
An abstract algorithm describing the
parser is given in the form of procedural
pseudo code, however the problem of
establishing that an implementation con—
forms to the algorithm is deferred, a
problem perhaps aggravated by the absence
of a formal notation for M rules which
might otherwise have suggested appropriate
data structures.
The postorder traverse in (ii) of a
preorder creation involves a duplication
which may be avoided by adopting the
PROLOG Definite Clause Grammar (DCG)
formalism. ([283 cf.C33, [4], CS], [213),
which, as has been observed C32) virtually
forces the methodology of syntax directed
translation coupled with compositional
semantics. A DCG may be ingenuously
characterised as a CFG having category
symbols augmented by argument places. and
containing supplementary goals not limited
in function to input consumption. • Logical
variables in argument places permit
synthesised and inherited attributes [1S]
to be handled with equal facility. The
clauses of a DCG may be directly executed
by a PROLOG interpreter, hence if combined
CFG+analytical—M rules are presented in
the form of Definite Clauses. the problem
of mapping algorithm to implementation
does not arise: the algorithm and program
are one and the same.
The parsers of both Landsbergen [20]
and Friedman &amp; Warren [9) generate only
skeletal trees, other details being
recoverable from the leaves and operation
indices: however the tedium of such
recovery may properly devolve on the comp—
uter. and for pedagogical purposes at
</bodyText>
<page confidence="0.996334">
25
</page>
<bodyText confidence="0.999564208333333">
least the production of full analysis
trees would be advantageous. This paper
outlines a DCG implementation of a version
of the compositional syntax of PTO which
returns full Montague analysis trees in
the form of vine d4agrams modified at most
by additional ,feature marking on vari-
ables. Given an input sentence. MDCG
returns sets of trees, optionally passing
members to a language of intensional logic
translator (LILT) which generates corres-
ponding IL formula,. The indeterminacy of
PROLOG implies that a DCG written with
circumspection may also be used in
reverse, but it remains to be investigated
whether the model could be so modified as
to achieve the recent objectives of
Friedman £83. To handle quantification
MDCG employs a variation of the
Friedman-Warren algorithm (FWA) £93.
The programs are implemented in
University of Edinburgh DEC-10 PROLOG and
run on the University of York DEC-10 comp-
uter
</bodyText>
<sectionHeader confidence="0.937397" genericHeader="introduction">
2 Implied Modifications to PTO
</sectionHeader>
<bodyText confidence="0.998447909090909">
The version of PTO grammar implemented
in MDCG has both significant and cosmetic
changes. As regards the first. Partee
observes (C24]. [253) that a version of
S12 which inserts labelled bracketing, and
a version of 94 sensitive to such
bracketing and generalised to add subject
- agreement to the first verb in each
conjunct of a conjoined verb phrase is
needed in order to distinguish (1) from
(2).
</bodyText>
<listItem confidence="0.945539">
(1) John tries to walk and talks.
(2) John tries to walk and talk.
</listItem>
<subsectionHeader confidence="0.396133">
Without labelled bracketing. PTO has diff-
</subsectionHeader>
<bodyText confidence="0.985959682926829">
and then constrains the predicate to be a
conjunction of one or more verb phrases
identifiable as commencing with concordant
finite forms. Likewise the procedure
which parses infinitival complements in
accordance with S8 accepts a conjunction
of one or more verb phrases starting with
infinitives. MDCG successfully generates
the trees illustrated in fig 1, thus
tacitly assuming compositional counter-
parts adopting modifications such as
the bracketing of Parte@ ([24], [253),
or the headverb flagging convention of
Bennett [23. Bennett&apos;s simplified sem-
antic typing, which results from treating
IV and CN as primitive categories, is also
exploited in LILT as illustrated in the
appendix.
The MDCG post referencing facility
requires the admission of alternative
capitalised variables, and an amended flO
which undertakes the replacement by term T
Of the earlier of:
(a) the first uncapitalised variable
with index n
or (b) the last occurring variable with
index n.
Whether capitalised :variables would prove
popular with advocates of the &amp;quot;well
formedness constraint&amp;quot; £271 is uncertain
Feature matching. which is achieved by
PROLOG&apos;; cross - goal variable instantiat-
ion conventions, plainly affords a simple
mechanism, from the syntactic viewpoint,
for handling number concord and selection-
al restrictions on the basis of feature
marked lexical entries. Indeed since the
alternative operations licenced by S2 are
also identified in the lexicon, MDCG has
the facility without amendment to produce
analysis trees for plural sentences such
</bodyText>
<figure confidence="0.452796777777778">
******************4********41.4***********************************
M4:4 John tries to walk and talks
*1:w John
*12:8 try to walk and talk
08:6 try to walk
*1:ml try
01:w walk
*1:im talk
*4:4 John tries to walk and talk
john
*8:6 try to walk and talk
*1:1= try
*12:8 walk and talk •
01:m walk
01:m talk •
•
fig 1.
****4.4.44.4.********************************************************
</figure>
<bodyText confidence="0.9462872">
iculty identifying head verbs, but since a
DCC works top down it encounters no such
problems. The MDCG analogue of 94 first
identifies the features of the subject.
as:
</bodyText>
<listItem confidence="0.602413">
(3) The men have not eaten the fishes.
</listItem>
<subsectionHeader confidence="0.4864">
given a further determiner clause in the
</subsectionHeader>
<bodyText confidence="0.870183">
lexicon introducing a definite article
</bodyText>
<page confidence="0.991105">
26
</page>
<bodyText confidence="0.993411833333333">
paired with an additional operation number
and marked with the features Cdef,p12.
The principle of compositionality [103
demands that this syntactical facility
remain officially untriggered pending the
introduction of appropriate plural deter-
</bodyText>
<subsectionHeader confidence="0.492878">
miner interpretation clauses in LILTs
however its introduction for experimental
purposes allows MDCG and LILT to provide •
testbed for the investigation of senses
for additional quantifiers.
The cosmetic variation involves the
introduction of further feature marking on
variables but since variables receive
semantic interpretation only in leaf
position where PTO and MDCG are equi-
</subsectionHeader>
<bodyText confidence="0.975444709677419">
valent, the change has no semantic
significance. Variables as leaves are in
the range he0..hen. but whereas PTO
introduces only accusative marking as a
side effect of combination. MDCG adds
markings for gender (and if needed
number). Amendments to PTO to reflect
these innovations would be purely
decorative. 52 would mark its output with
a number feature derived from the
quantifier. while .both S4 and 85 would.
like 52. licence alternative operations
such that f4.0 and f5.0 would be
restricted to cases where the input T were
not a variable, and f4.1..f4.4. f5.1..f5.4
would generate he IV .. theyn IV. TV
him n TV themn respectively. Since the
translation rules &apos;T4 and 15 refer to the
value of the input term of • function in
the f4. f5 series these would be
unaffected. Rules in the range 53n. 814n
.. Sion would apply on condition that the
input sentence did nli include a variable
with index n having discordant features.
If plural forms became available, the
subject agreement clause of 84 would need
generalising. and 513 would, like 511 and
912. gain access to fie, marking its output
with the number of its first argument in
case the operation were f9. or with
C+plural] otherwise.
</bodyText>
<sectionHeader confidence="0.765206" genericHeader="method">
3 Tree Structures and Parsino Procedures
</sectionHeader>
<bodyText confidence="0.732813416666667">
Nodes on an analysis tree are repres-
ented internally by analogues of the &amp;quot;syn&amp;quot;
structures of McCord C212. having the
form:
node(N.F,L,D)
where:
N = A rule number in the form *Syn:Fun,
aSyn:(Fun.Inx). or 411:= such that Syn
and Fun are Montague syntax rule and
structural operation numbers. Inx is
a variable subscript. and *1=
indicates lexical insertion.
</bodyText>
<listItem confidence="0.2643152">
F = A list of features intrinsic to the
node.
L = A node label in list form.
0 = In the cast of • non-terminal node •
binary list of daughters both of
</listItem>
<bodyText confidence="0.939602">
which are nodes, otherwise a struc-
ture of form:
sense(Item.Category)
used by LILT in the generation of IL
formulae.
Procedures which parse grammatical cat-
egories normally have ten arguments the
nature of which will where necessary be
explained in subsequent sections. The
general form is as follows:
category(N,F.E.L.Ia,Ix,FVB.SA,SRa.SR:)
where
N = A node structure as described.
F = The features of the category - in -
context which may exceed the node
features. For example case is not an
intrinsic noun phrase leaf feature,
but it constrains adoption to specif-
ied configurations.
The environment (preorder
predecessors) of the category relat-
ive to which the parse is aborted if
</bodyText>
<figure confidence="0.89320575">
N is non unique. •
L = The transmission label.
Ia.Ix = String buffers before and after
parsing.
FVB = Free variables below list
SA = Substitutions above list.
SRa.SRx = Substituens. required lists
before and after parsing.
</figure>
<sectionHeader confidence="0.830705" genericHeader="method">
4 Imolementino FWA in PROLOG
</sectionHeader>
<bodyText confidence="0.938081939393939">
The FWA handles the introduction and
subsequent binding of indexed variables on
n-cry substitutes for skeletal analysis
trees by the manipulation of two lists.
FVB (free variables below) and SA (sub-
stitutions above). In order to implement
the algorithm in a PROLOG DCG directed
towards the production of strictly
Montagovian trees. each clause responsible
for creating a node requires both FVB and
SA argument places, the first to act as an
output and the second as in input
parameter, with the proviso that the top
level &amp;quot;sentence&amp;quot; call set both to the
empty list.
A clause charged with the construction
of a I (=NP) node. provided that it does
more than read a surface pronoun. must be
given the potion of returning a default
node, or alternatively of binding the noun
phrase discovered to the next available
variable, adding the. binding to the FVB
set, and returning • a variable node
instead. In MDCG a binding takes the form
not of a (variable, noun-phrase) pair but
of • structure:
bind(Var,Inx,Node)
where:
Var = The indexed variable.
Inx = The subscript.
Node = The complete structure
node(N.F.L.D) for • T or. in case the
binding is performed under the S3
</bodyText>
<page confidence="0.989515">
27
</page>
<bodyText confidence="0.999050529411765">
analogue, for a CN. The feature
field includes both gender and number
although presently available deter—
miners constrain number to be
singular.
Clauses responsible for returning
sentence and verb phrase nodes must like—
wise construct a default node, but must be
permitted to substitute for it • node
having this default as younger daughter. a
T node from a binding extracted from the
current FVB as elder daughter, and the
structural operation flagged with the
binding index.
In all cases the FVB returned to the
head goal must represent the union of the
FVBs of those sub—goals which construct
daughters (proorder successors), plus any
additions resulting from a specific call
to option, or less any extractions
accomplished by a specific call to sub—
stitute. The FVB of a given node may
nevertheless contain bindings apparently
introduced by a preorder predecessor
because the effect of substitute is to
adopt, elder sisters. Accordingly the
published constraints [9] on
quantification over variables remaining
free in preorder predecessors must be
preserved. Prior to extraction MDCO
verifies that the Var field of a binding
does not appear as a label dominated by
the Node field of any other binding
available in the current FVB.
</bodyText>
<subsectionHeader confidence="0.921057">
Vacuously quantified relative clauses
</subsectionHeader>
<bodyText confidence="0.994143918918919">
(&amp;quot;not there&amp;quot; cases £163) are surpris—
ingly. tolerated by the original FWA,
requirement that in the top level
&amp;quot;sentence&amp;quot; call FVB must be [2. The
latter requirement constitutes a final
filter as suggested, albeit with
reservation, by Janssen Elmo as a means of
ensuring syntactic conformity to the
&amp;quot;variable principle&amp;quot;.
When a parsing procedure is called
other than at top level, the SA is
initialised as the union of the SA of the
head goal and the FVB of any goal
constructing an elder sister. A noun
phrase parsing clause which reads a
surface pronoun may reference any binding
in the SA such that, where Node
node(N,F,L,D), the features in F conform
with the pronoun in number and gender. A
variable node having the indexed variable
from the binding in its L field is
returned, thus achieving an antecedent
reference.
Neither LIFO nor FrF0 lists suffice to
generate all permitted quantifier scope
variations. If FVB and SA are formed by
simple concatenation then substitute must
be capable of extracting members randomly.
Alternatively substitute may safely select
the next available item provided that the
lists are formed in such a way that all
permutations emerge in due course. MDCG
adopts the latter choice, employing a
predicate:
mix(L1,L2,L3)
which, given successive calls, simulates
the scattering of the members of Ll within
</bodyText>
<table confidence="0.168249">
L2 in a random pattern on the assumption
that L2 is already random.
***************************************************************
</table>
<tableCaption confidence="0.442479428571429">
*14:10:2 the man such that he loves her finds mary
#1= mary
#4:4 the man such that he loves HER2 finds her2
#2:1 the man such that he loves HER2
*1:* the
*3:3:1 man such that he loves HER2
fig 2.
</tableCaption>
<bodyText confidence="0.837724666666667">
***************************************************************
although a parallel test for variable
eligibility is plainly needed. In MDCG
the eligibility procedure includes •
mechanism suitable for eliminating vacuous
applications of $O: the selected variable
may not be dominated by any node in
another FVB binding, but it must be
dominated by the embedded sentence node.
</bodyText>
<subsectionHeader confidence="0.726822">
The elimination of &amp;quot;left overs&amp;quot;, ie.
</subsectionHeader>
<bodyText confidence="0.999388">
indexed variables remaining free on the
top node of an analysis tree, is achieved
partly by the constraints on substitution
which prevent appearances outside the
scope of quantification, and partly by the
</bodyText>
<sectionHeader confidence="0.993287" genericHeader="method">
5 Auomentino FWA
</sectionHeader>
<bodyText confidence="0.956140833333333">
Since the grammar of PTO does not
generate post referencing pronouns. FWA is
not designed to accommodate them. In MDCG
an augmented FWA is introduced to handle
post referencing via capitalised variables
which are always realised as surface
pronouns. For example in response to the
input:
(4) The man such that he
loves her finds Mary.
the output includes a tree commencing as
in fig 2.
</bodyText>
<page confidence="0.993094">
28
</page>
<bodyText confidence="0.999331416666667">
The augment requires parsing procedures
to accept two additional list holding
argument places, SR. and SR: (Substituens
Required at start and at end). When a
surface pronoun is encountered, • check is
first made both in SA (for an antecedent
referent) and in SR. (in case • previous
post reference has been made) for a
binding with matching number and gender.
If none is found then a dummy binding,
with only the F field of the node struc—
ture set, is created. The union of this
item and SRa becomes SRz. whilst the dummy
is added to FVB. The SRa of an elder
daughter is the SRa of its parent. the SRa
of a younger daughter is the SR: of its
elder sister, and the SRz of the younger
daughter becomes the SR: of the parent.
It is now required that whenever • noun
phrase making clause exercises its option
to introduce a variable. • check must
first be made of the SR list1 and if
possible a suitable dummy binding ex—
tracted and completed with no addition to
the FVB list. The behaviour of PROLOG
ensures that completion effects all
existing occurrences of the dummy. A con—
straint on substitution must now prohibit
the extraction from the FVB of any binding
appearing in the SRz list returned to the
head goal. In this way not only may no
younger sister dominate quantification
over a variable remaining free in the
family of an elder jitter (the original
constraint), but the elder sister must
extend the same courtesy to her sibling.
</bodyText>
<sectionHeader confidence="0.998864" genericHeader="method">
6 The mechanics of MDCG
</sectionHeader>
<subsectionHeader confidence="0.986535">
6.1 Handlina Left Recursion
</subsectionHeader>
<bodyText confidence="0.988000954545455">
Fig 3 illustrates the MDCG equivalent
is essentially left recursive, which pres—
ents problems for a top—down. left—right,
depth first DCG technique. Standard
methods [34] for eliminating left
recursion from a CFG would be inapprop—
riate as they result in only weakly equi—
valent grammars. The MDCG solution is to
employ a well formed substring table
(WFST). (vide C172. [313. C337, [35]) and
assume that the recurring item has already
been found. adding to the table the result
of subsequent parsing given that it is
unique relative to its environment.
Since the WFST must record the relative
position of entries, grammar rule notation
CORN) which insulates the programmer from
lexical decomposition must be proscribed:
accordingly MDCG is written in raw PROLOG,
pairs of variables in the range Ia..Iz
representing string buffers before and
after parsing.
</bodyText>
<subsectionHeader confidence="0.994205">
6.2 Restorative Editina
</subsectionHeader>
<bodyText confidence="0.996672666666667">
Reflection on the behaviour of the
clause in fig 3 during the parsing of:
(5) Woman such, that a man loves her.
reveals that prior to parsing the embedded
sentence the kth variable (k=Inx) in the
range he0..hen is generated and its
binding to CN passed on in a new SA list.
When the pronoun is encountered. the
binding with index k may .be extracted, a
leaf node with hei as label created, and a
form marked for number, gender and case
returned as transmission label to the
immediately dominating node. The value of
Lb (the embedded sentence label) will in
due course be returned as:
</bodyText>
<listItem confidence="0.936228">
(6) a man loves hark.
</listItem>
<bodyText confidence="0.9808405">
Before this may be prefixed with the
common noun plus &amp;quot;such that&amp;quot; to become the
</bodyText>
<table confidence="0.974617086956522">
******************************************************** ******* *
* *
* common(Node,Ft,E,L,la,Iz,FVB.SA.SRa,SRO :— *
* wfst(common(CN,Ft.E.La.Ia.Ib.FVBa.SA.SRa,SRb)), *
* scan(Csuch,thatLIb.Ic). *
* gensym(he,He.lnx.Suffix), *
e join(Ebind(He1Inx.CN)IFVBa3.SA.SAa), *
* join(E.CN.E1). *
* sentence(S.Cdc13.E1,Lb,Ic,Iz,FVBb.SAa.SRb,SRz), *
* eligible(bind(He.Inx,CN),FV1M,[3,[3), *
* dominated(Me,S), *
* makevars(Nom,_,Acc._,Suffix.Subj,Obj.Ft), . *
* editline(Nom,Acc.Subj.Obj,Lb.Lc), *
* join(LapCsuch,thattLc3,Ld). *
e mix(FVBa,FVflb,FVBc), *
e substitute(cn.node(e3:(3:Inx).Ft.Ld.(CN,S3). *
* Node,Ld.L,C],[7.FVBc,FVB,CLSR2), e
* recordz(wfst(common(Node, *
* Ft.E.L.Ia.Iz.FVD,SA.SRa.SRz))). *
* *
* fig 3. *
***************************************** ***** ************ ***** *
of Montague&apos;s rule S3. The inverse of 93 default label Ld it must be edited so as
</table>
<page confidence="0.997643">
29
</page>
<bodyText confidence="0.972009">
to restore all variables with index k to
appropriate surface forms. Samples of
eligible variables (i.e. k—variables of
appropriate number and gender) are created
by makevars, whereafter pditline achieves
the required restoration.
</bodyText>
<subsectionHeader confidence="0.998637">
6.3 Node and Transmission Labels
</subsectionHeader>
<bodyText confidence="0.999869833333333">
The label of a leaf node is invariably
a root form, but a morphological variation
is very often required as transmission
label Non—leaf nodes mag also be so
characterised. When a verbphrase is ex—
tracted from the WFST in fig 4, which ill-
</bodyText>
<subsectionHeader confidence="0.997946">
6.4 Calls to &amp;quot;substitute&amp;quot; and &amp;quot;option&amp;quot;
</subsectionHeader>
<bodyText confidence="0.8911007">
Fig 4 includes a call to substitute
while a call to potion occurs in fig 5
which illustrates the MDCG clause
responsible for parsing proper names. The
form of a substitute call is as follows:
substitute(T.Node,Nodel,Tl,T11,N1.
NLI.FMFV131.9k,SR)
where:
T = The type of node involved (s=SEN,
vp=l‘,/, cn=CN).
</bodyText>
<figure confidence="0.707455652173913">
Node = The default node constructed.
Nadel = The replacement node (Nodel=Node
if no substitution is made).
1I,111 = Default and replacement trans—
****************************************************************
•
• verbphraso(node(NO.FO.LO,D0),VF.E.L.la.Ix.FYILSA.SRa.SRz) *
wfst(verbphrase(node(NI,F1.L1,131).VF,E.La.Ia.Ib,
FVBa.SA.SRa.SRb)),
mix(FVBa.SA.SAa).
join(E.node(N1.Fl.Ll.Dl).El),
vpadverb(VPADV.AV,El,Lb.lb,Ix,FVBb,SAa.SRasSR:),
join(La.Lb,Lc).
join(L1.Lb,L2),
mix(FV13a.FV13b,FV13c).
substitute(vp.node(*10:70.W.L2.
EVPADV.node(Nl.Fl,LI.Dl))):
node(NO.FO.L0.130).
Lc.L.L2.LO,FV13c.FVB,SA,CLSRa),
recordz(wfst(verbphrase(node(NO.FO.LO,D0),VF,E.L.
la.It,FVILSA,SRa,SRz))).
fig 4.
****************************************************************
</figure>
<figureCaption confidence="0.272442">
ustrates the MDCG equivalent of SIO. the
node label LI must contain the bare
</figureCaption>
<bodyText confidence="0.992536352941176">
infinitive of the head verb while La
contains a finite form. Having processed
the adverb, a pair of new labels must
mission labels (T11=T1 if no substit—
ution made).
Nl.N11 = Default and replacement node
labels (Nil-Ni if no substitution
made. and Nl.NL1=C3 if T=s or T=cn
****************************************************************
* nounphrase(Node.[G.(C.Num)3.E.L.Ia.Ix,FVB,SA,SRa.SRz)
scan(PmIa,Ix),
proper(Pn,CG.(Num)],
option(node(*1:&apos;=&apos;,[0.(Num)).[Pn],[sense(Pn,Con)))), *
CO,(C,Num)3,Node,EPn3.L.C3,FVB.SRa.SR2),
recordz(wfst(nounphrase(Node.CG.(C,Num)3,E.
*
fig 5.
****************************************************************
accordingly be constructed, one for the
default node and one for its transmission
label. Should a substitution then be
made, twin labels for the introduced
higher node must likewise be maitained by
the substitute procedure.
since the newt node label is taken
to be Ill).
FVD.FV1:11 = The free variable below lists
before and after any extraction.
Sk = Those bindings bipassed in ancestor
calls to substitute (At top level
Sku[3).
SR = The substituens required list
containing the constraints on sub—
stitution.
</bodyText>
<page confidence="0.99586">
30
</page>
<bodyText confidence="0.997137666666667">
Similarly a call to gotion appears in
the form:
option(Node.F,Nodel.T1.111.FVB.FVB1.
SR.SR1)
where:
Node,Nodel = The default and replacement
nodes.
F = The features (gender and number) of
the node.
11,111 = The default and transmission
labels.
FvB,FVB1 = The free variables below lists
before and after any addition.
SR,SR1 = The substituens required lists
before and after any subtraction.
</bodyText>
<sectionHeader confidence="0.945766" genericHeader="method">
7 A Foretaste of LILT
</sectionHeader>
<bodyText confidence="0.996709166666666">
Warren (32] suggests two possibilities
for encoding lambda terms in PROLOG given
the desire to represent a full typed
lambda calculus. the first portraying
lambda variables as PROLOG structures and
the second equating them with PROLOG van-
descriptive commentary similar to that
given by Partee [253 and Dowty (7]. This
is accomplished during a traverse in
&amp;quot;galilean&amp;quot; postorder of the analysis tree,
producing output of the form illustrated
in the appendix. from which it will be
apparent that. since PROLOG does not
recognise a lambda expression formed by
juxtaposition. the initial pairing of
operator and operand is achieved via a
convenience predicate &amp;quot;eval&amp;quot; and
subsquently evaluated.
Whereas Janssen (C14], (15]) accomp-
lishes reduction by a process of
essentially localised tree transform-
ations. the simplification algorithm of
LILT takes advantage of PROLOG&apos;s list
processing capabilities to undertake
global list transformations whenever
necessary. MDCG - LILT exemplifies the
reorganised directed process approach
discussed by Warren and Friedman (33], ie.
LILT is (optionally) called after each
parse. The present objective of display-
</bodyText>
<table confidence="0.960220555555556">
*************************************************************
* sense(the.Cd(sg)Llambda(p:lambda(q:exists(Y:all(X:
Cp(X)(=&gt;equals(X,Y)),Wq(Y)))))))
fig 6.
*** ***** ******4********************4*************************
************************************* ****** *****************#
* translate(node(N.F,L,Csense(R.T)3),S) :- *
* !isense(R.T,S).message(0,EL,S3). *
* *
</table>
<listItem confidence="0.820813">
• translate(Tree,IL) I.
</listItem>
<bodyText confidence="0.995225151515152">
structure(Tree,node(N.F,L,_),LsubaRsub),
translate(Rsub.Rnew).translate(Lsub.Lnew),
construct(node(N,F,L._).Lnew.Rnew.Treel),
formulate(Treel,IL1),
message(N.IL1),
simplify(ILl.IL).
fig 7.
***************** ***** ************** ****** ************ *******
ables. Since LILT is concerned only with
that subset of lamda calculus needed for
representing Montague&apos;s language IL, a
simpler scheme becomes possible. In LILT
predicate variables are represented by
PROLOG atoms while PROLOG variables are
used directly for individual variables
introduced by &amp;quot;sense&amp;quot; clauses (other than
those anaphoric references already con-
strained to be in the range x0 .. xn).
The essence of this scheme may be ex-
tracted from fig 6 which illustrates the
clause correlating singular definite art-
icle with its sense. The top level trans-
lation clauses are illustrated in fig 7.
These constitute a recursive procedure
which generates reduced IL formulae with
ing a conventional derivational history
makes the immediate return of logical
representations rather than syntactic sub
trees inappropriate. Were all parsing
procedures to call a mute version of
translate locally, it is predicted that a
semantic equivalence parse (op cit) would
result.
</bodyText>
<sectionHeader confidence="0.99802" genericHeader="method">
References
</sectionHeader>
<reference confidence="0.992279166666667">
[1] Ajdukiewicz K. (1935) Syntactic con-
nexion. in McCall S. (Ed. ) Polish
LOQiC 1920-1939. Clarendon, Oxford,
1967.
(23 Bennett M. (1976) A variation and
extension of a Montague fragment of
</reference>
<page confidence="0.999074">
31
</page>
<reference confidence="0.999205237704918">
English. in Partee (1976).
[3] Clocksin W.F. &amp; Mellish C.S. (1981)
Programmina_in PROLOG.
Springer-Verlag, Berlin.
£4] Colmerauer A. (1975) Metamorphosis
grammars. in Bolc L. (Ed.) Natural
Language Communication with Comp-
uters. Springer-Verlag. Berlin.
1978.
[5] Dahl V. (1981) Translating spanish
into logic through logic. American
Journal of Computational Linguistics
Vol.7 No.3.
£67 Davis S. &amp; Mithun M. (Eds.) (1979)
Linauistics. PhijosoDhu. and Montagme
Grammar. University of Texas,
Austin.
£77 Dowty D.R., Wall R.E. &amp; Peters S.
(1981) Introduction to Mantaaue Sem-
antics. Reidel. Dordrecht: Holland.
[8] Friedman J. (1981) Expressing logic-
al formulas in natural language. in
Groenendijk. Janssen, &amp; Stokhof
(1981).
[9] Friedman J. &amp; Warren D.S. (1978) A
parsing method for Montague grammars.
Linguistics &amp; Philosophy 2.
£10] Frege G. (1893) On sense and ref-
erence. in Geach P. &amp; Black M.
(Eds. ) Philosophical Writings of
Gottlob Freae. Blackwell. Oxford,
1966.
£11] Groenendijk J.A.G.. Janssen &amp;
Stokhof M.B.J (Eds. ) (1981) Formal
methods in the Stud u of Lanauaae 1 &amp;
2 Mathematisch Centrum, Amsterdam.
[12] Hintikka K.J.J., Moravcsik J.M.E. &amp;
Suppes P. (Eds. ) (1973) Approack&apos;s
to Nattaal Lanauaao. Reidel,
Dordrecht: Holland.
£13] Hobbs J.R. &amp; Rosenschein S.J.
(1978) Making computational sense of
Montague&apos;s intensional logic. Artif-
icial Intelligence 9.
[147 Janssen T.M.V. (1978) Simulation of
a Montague grammar. Annals of
Systems Research 7.
C15] Janssen T.M.V. (1980) Logical
investigations on PTO arising from
programming requirements. Synthese
44
£167 Janssen T.M.V. (1981) Compositional
semantics and relative clause form-
ation in Montague grammar. in Green-
endijk, Janssen &amp; Stokhof (1981).
[17] Kaplan R.M. (1973) A general syntac-
tic processor. in Rustin (1973).
[18] Knuth D.E. (1968) Semantics of con-
text free languages. Mathematical
Systems Theory Vol. 2 No. 2.
[197 Knuth D.E. (1975) The Art of Comp-
uter Proarammina Vol. 1 : Fundamen-
tal Alaorithms. Addison - Wesley.
Reading. Mass.
£20] Landsbergen J. (1981) Adaptation of
Montague grammar to the requirements
of parsing. in Groenendijk. Janssen
&amp; Stokhof (1981).
[21] McCord M. (1982) Using slots and
modifiers in logic grammars for nat-
ural language. Artificial Intell-
igence 18.
£22] Montague R.M. (1972) The proper
treatment of quantification in ord-
inary English. in Hintikka et al
(1973) and Thomason (1974).
[233 Partee B.H. (1972) Comments on
Montague&apos;s paper. in Hintikka et al
(1973).
[24] Partee B.H. (1973) Some transform-
ational extensions of Montague gram-
mar. in Partee (1976).
(25] Partee B.H. (1975) Montague grammar
and transformational grammar. Ling-
uistic Inquiry 6.
£26] Parte, B.H. (Ed. ) (1976) Montague
Grammar. Academic Press, N.Y.
[27] Partee B.H. (1977) Constraining
transformational Montague grammar: a
framework and a fragment. in Davis &amp;
Mithun (1981).
(28] Pereira F.C.N. &amp; Warren D. H. D.
(1980) Definite clause grammars for
language analysis. Artificial In-
telligence 13.
(297 Rustin R. (Ed. ) (1973) Natural
Lanauaae Processing.. Algorithmics
Press, N.Y.
(30] Thomason R.H. .(1974) (Ed. ) Formal
allosophu - Selected Papers of
Richard Montague. Yale, New Haven
(31] Thompson H. (1981) Chart parsing and
rule schemata in PSG. Proceedings of
the 19th. annual meeting of the Ass-
ociation for Computational Linguist-
ics 167-172.
C32] Warren D.S. (1983) Using lambda
calculus to represent meanings in
logic grammars. Proceedings of the
21st. Annual Meeting of the Assoc-
iation for Computational Linguistics
[33] Warren D.S. &amp; Friedman J. (1982)
Using semantics in non context free
parsing of Montague grammar.
American Journal of Computational
Linguistics S.
(34] Winograd T. (1983) Language as a
Coanitive Process. Addison-Wesley,
Reading, Mass.
[35] Woods W.A. (1970) An experimental
parsing system for transition network
grammars. in Rustin (1973).
</reference>
<page confidence="0.999091">
32
</page>
<sectionHeader confidence="0.6423371875" genericHeader="method">
Appendix : Sample Output
1: nary believes that John is a man.
Parse No. 1
*** ***** *****
#4:4 nary believes that John is a man
01: nary
97:6 believe that John is a man
01: believe
94:4 John is a man
#1: John
#5:5 be a man
#1: be
#2:2 a man
#1: . a
#1: ft man
1? yes.
</sectionHeader>
<reference confidence="0.984914689655172">
Composition 6 Simplification
(0] from Lexicon: Basic expression (man) 0
man
(1) from Lexicon: Basic expression [a]
lambda(paambda(q:exists(_3423:Cp(_3423)6 &apos;q(3423)))))
(2) from [OM: Construction by T2
eval(lambda(p:lambda(q:exists(3423:Cp(_3423)6
sq(3423))))),^man)
(3) from [21: Instantiate variable
eval(&apos;&amp;quot;man, 3423)
[4] from (3): Relational notation
&apos;man(_3423)
[5] from [41: Down—up conversion
man( 3423)
[6] from 12j: Lambda conversion
lambda(q:exists(_3423:(man( 3423)6 &apos;q(3423))))
[7] from Lexicon: Basic expression [be] =7
lambda(sub:lambda( 4607: &apos;sub(-1ambda(_4608:
equals( 4607, 46067))))
[8] from 16,71: Constratioti—by TS 0&gt;
eval(lambda(sub:lambda(_4607: &apos;sub(&amp;quot;lambda(...4608:
equals( 4607,4608))))),^lambda(q:exists(_3423:
man(34IB)E, &apos;q(_3423)))))
(9) from 18j: Instantiate variable
eval(&apos; ^lambda(q:exists( 3423:(man( 3423)6. &apos;q(.3423)))).
-lambda(_4608:equals( 401,...4608))i—
(10) from 19j: Down—up conversion
eval(lambda(q:exists( 3423:(man( 3423)6 &apos;q(_3423)))),
-lambda(26608:equals(:4607,4606Y))
</reference>
<page confidence="0.985525">
33
</page>
<reference confidence="0.988686863636363">
[11] from (10): Instantiate variable
eval(&apos; &amp;quot;lambda(_4608:equals(_4607,_4608)),3423)
[12] from [11]: Down-up conversion
eval(lambda(4608:equals(_4607,24608)),3423)
(131 from [121: Lambda conversion
equals( 4607,3423)
[14] from (101: Substitute identicals
man( 4607)
[15] from [101: Lambda conversion
man(_4607)
[16] from [81: Lambda conversion
].ambda( 4607:man( 4607))
[17] from Lexicon: Basic expression [john]
lambda(p: `p(john))
[18] from [16,17]: Construction by T4 0
eval(lambda(p: &apos;p(john)),&amp;quot;lambda(_4607:man(_4607)))
[19] from [18]: Instantiate variable
eval(&apos; &amp;quot;lambda(_4607:man(_4607)),john)
[20] from [19]: Down-up conversion
eval(lambda(_4607:man(_4607)),john)
[21] from [20]: Lambda conversion
man( John)
[22] from [181: Lambda conversion
man( John)
[23] from Lexicon: Basic expression [believe] 0
believe
(24] from [22,23]: Construction by T7
eval(believe,&amp;quot;man(john))
[25] from [241: Relational notation
believe(&amp;quot;aan(john))
[26] from Lexicon: Basic expression [mary]
lambda(p: &apos;p(mary))
[27) from [25,26]: Construction by T4 0
eval(lambda(p: &apos;o(mary)),&amp;quot;believe(&amp;quot;man(john)))
[28] from [27]: Instantiate variable
eval(&apos; &amp;quot;believe(&amp;quot;man(john)),mary)
[29] from [281: Relational notation
&apos; &amp;quot;believe(mary,&amp;quot;man(john))
[30] from [291: Down-up conversion
believe(mary,&amp;quot;man(john))
[31] from [27]: Lambda conversion
believe(mary,&amp;quot;man(john))
Logical Form
believe(mary,&amp;quot;man(john))
</reference>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.123962">
<title confidence="0.850102">MONTAGOVIAN DEFINITE CLAUSE GRAMMAR</title>
<email confidence="0.82855">R.I.Bainbridge,</email>
<affiliation confidence="0.9850095">Dept. of Computer Science. Teesside Polytechnic,</affiliation>
<address confidence="0.999234">Middlesbrough, Cleveland, England.</address>
<abstract confidence="0.999633833333333">This paper reports a completed stage of ongoing research at the University of York. Landsbergen&apos;s advocacy of analyt— ical inverses for compositional syntax rules encourages the application of Defin— ite Clause Grammar techniques to the cons— truction of a parser returning Montague analysis trees. A parser MDCG is pres— ented which implements an augmented Friedman — Warren algorithm permitting post referencing, and interfaces with a language of intensional logic translator LILT so as to display the derivational history of corresponding reduced IL form— ulae. Some familiarity with Montague&apos;s PTO and the basic DCG mechanism is assumed.</abstract>
<keyword confidence="0.39903425">Ke words Compositional Semantics, Definite Clause Grammar, Friedman Warren Algorithm, Intensional Logic, Montague Grammmar, Nat— ural Language Processing, PROLOG.</keyword>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>K Ajdukiewicz</author>
</authors>
<title>Syntactic connexion. in</title>
<date>1935</date>
<pages>23</pages>
<location>Clarendon, Oxford,</location>
<note>in Partee</note>
<marker>[1]</marker>
<rawString>Ajdukiewicz K. (1935) Syntactic connexion. in McCall S. (Ed. ) Polish LOQiC 1920-1939. Clarendon, Oxford, 1967. (23 Bennett M. (1976) A variation and extension of a Montague fragment of English. in Partee (1976).</rawString>
</citation>
<citation valid="true">
<authors>
<author>W F Clocksin</author>
<author>C S Mellish</author>
</authors>
<title>Programmina_in PROLOG.</title>
<date>1981</date>
<volume>4</volume>
<publisher>Springer-Verlag,</publisher>
<location>Berlin.</location>
<marker>[3]</marker>
<rawString>Clocksin W.F. &amp; Mellish C.S. (1981) Programmina_in PROLOG. Springer-Verlag, Berlin. £4] Colmerauer A. (1975) Metamorphosis grammars. in Bolc L. (Ed.) Natural Language Communication with Computers. Springer-Verlag. Berlin. 1978.</rawString>
</citation>
<citation valid="true">
<authors>
<author>V Dahl</author>
</authors>
<title>Translating spanish into logic through logic.</title>
<date>1981</date>
<journal>American Journal of Computational Linguistics</journal>
<volume>7</volume>
<institution>Linauistics. PhijosoDhu. and Montagme Grammar. University of Texas, Austin.</institution>
<location>Reidel. Dordrecht: Holland.</location>
<marker>[5]</marker>
<rawString>Dahl V. (1981) Translating spanish into logic through logic. American Journal of Computational Linguistics Vol.7 No.3. £67 Davis S. &amp; Mithun M. (Eds.) (1979) Linauistics. PhijosoDhu. and Montagme Grammar. University of Texas, Austin. £77 Dowty D.R., Wall R.E. &amp; Peters S. (1981) Introduction to Mantaaue Semantics. Reidel. Dordrecht: Holland.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Friedman</author>
</authors>
<title>Expressing logical formulas in natural language.</title>
<date>1981</date>
<journal>in Groenendijk. Janssen, &amp; Stokhof</journal>
<marker>[8]</marker>
<rawString>Friedman J. (1981) Expressing logical formulas in natural language. in Groenendijk. Janssen, &amp; Stokhof (1981).</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Friedman</author>
<author>D S Warren</author>
</authors>
<title>A parsing method for Montague grammars. Linguistics &amp; Philosophy 2. £10] Frege G. (1893) On sense and reference.</title>
<date>1978</date>
<booktitle>Philosophical Writings of Gottlob Freae. Blackwell.</booktitle>
<location>Oxford,</location>
<note>in</note>
<contexts>
<context position="12600" citStr="[9]" startWordPosition="1998" endWordPosition="1998">tracted from the current FVB as elder daughter, and the structural operation flagged with the binding index. In all cases the FVB returned to the head goal must represent the union of the FVBs of those sub—goals which construct daughters (proorder successors), plus any additions resulting from a specific call to option, or less any extractions accomplished by a specific call to sub— stitute. The FVB of a given node may nevertheless contain bindings apparently introduced by a preorder predecessor because the effect of substitute is to adopt, elder sisters. Accordingly the published constraints [9] on quantification over variables remaining free in preorder predecessors must be preserved. Prior to extraction MDCO verifies that the Var field of a binding does not appear as a label dominated by the Node field of any other binding available in the current FVB. Vacuously quantified relative clauses (&amp;quot;not there&amp;quot; cases £163) are surpris— ingly. tolerated by the original FWA, requirement that in the top level &amp;quot;sentence&amp;quot; call FVB must be [2. The latter requirement constitutes a final filter as suggested, albeit with reservation, by Janssen Elmo as a means of ensuring syntactic conformity to the</context>
</contexts>
<marker>[9]</marker>
<rawString>Friedman J. &amp; Warren D.S. (1978) A parsing method for Montague grammars. Linguistics &amp; Philosophy 2. £10] Frege G. (1893) On sense and reference. in Geach P. &amp; Black M. (Eds. ) Philosophical Writings of Gottlob Freae. Blackwell. Oxford, 1966. £11] Groenendijk J.A.G.. Janssen &amp; Stokhof M.B.J (Eds. ) (1981) Formal methods in the Stud u of Lanauaae 1 &amp; 2 Mathematisch Centrum, Amsterdam.</rawString>
</citation>
<citation valid="false">
<title>Approack&apos;s to Nattaal Lanauaao.</title>
<date>1973</date>
<journal>Artificial Intelligence</journal>
<booktitle>Annals of Systems Research 7. C15] Janssen T.M.V.</booktitle>
<volume>13</volume>
<pages>147</pages>
<location>Reidel, Dordrecht: Holland.</location>
<marker>[12]</marker>
<rawString>Hintikka K.J.J., Moravcsik J.M.E. &amp; Suppes P. (Eds. ) (1973) Approack&apos;s to Nattaal Lanauaao. Reidel, Dordrecht: Holland. £13] Hobbs J.R. &amp; Rosenschein S.J. (1978) Making computational sense of Montague&apos;s intensional logic. Artificial Intelligence 9. [147 Janssen T.M.V. (1978) Simulation of a Montague grammar. Annals of Systems Research 7. C15] Janssen T.M.V. (1980) Logical investigations on PTO arising from programming requirements. Synthese £167 Janssen T.M.V. (1981) Compositional semantics and relative clause formation in Montague grammar. in Greenendijk, Janssen &amp; Stokhof (1981).</rawString>
</citation>
<citation valid="true">
<authors>
<author>R M Kaplan</author>
</authors>
<title>A general syntactic processor. in Rustin</title>
<date>1973</date>
<marker>[17]</marker>
<rawString>Kaplan R.M. (1973) A general syntactic processor. in Rustin (1973).</rawString>
</citation>
<citation valid="true">
<authors>
<author>D E Knuth</author>
</authors>
<title>Semantics of context free languages.</title>
<date>1968</date>
<journal>Mathematical Systems Theory</journal>
<booktitle>in Groenendijk. Janssen &amp; Stokhof</booktitle>
<volume>2</volume>
<pages>197</pages>
<publisher>Addison - Wesley.</publisher>
<location>Reading. Mass.</location>
<note>20] Landsbergen</note>
<marker>[18]</marker>
<rawString>Knuth D.E. (1968) Semantics of context free languages. Mathematical Systems Theory Vol. 2 No. 2. [197 Knuth D.E. (1975) The Art of Computer Proarammina Vol. 1 : Fundamental Alaorithms. Addison - Wesley. Reading. Mass. £20] Landsbergen J. (1981) Adaptation of Montague grammar to the requirements of parsing. in Groenendijk. Janssen &amp; Stokhof (1981).</rawString>
</citation>
<citation valid="true">
<authors>
<author>M McCord</author>
</authors>
<title>Using slots and modifiers in logic grammars for natural language.</title>
<date>1982</date>
<journal>Artificial Intelligence</journal>
<booktitle>in Hintikka et al</booktitle>
<volume>18</volume>
<marker>[21]</marker>
<rawString>McCord M. (1982) Using slots and modifiers in logic grammars for natural language. Artificial Intelligence 18. £22] Montague R.M. (1972) The proper treatment of quantification in ordinary English. in Hintikka et al (1973) and Thomason (1974). [233 Partee B.H. (1972) Comments on Montague&apos;s paper. in Hintikka et al (1973).</rawString>
</citation>
<citation valid="true">
<authors>
<author>B H Partee</author>
</authors>
<title>Some transformational extensions of Montague grammar. in Partee</title>
<date>1973</date>
<booktitle>Linguistic Inquiry 6. £26] Parte, B.H. (Ed. )</booktitle>
<publisher>Academic Press,</publisher>
<location>N.Y.</location>
<contexts>
<context position="5419" citStr="[24]" startWordPosition="835" endWordPosition="835">o distinguish (1) from (2). (1) John tries to walk and talks. (2) John tries to walk and talk. Without labelled bracketing. PTO has diffand then constrains the predicate to be a conjunction of one or more verb phrases identifiable as commencing with concordant finite forms. Likewise the procedure which parses infinitival complements in accordance with S8 accepts a conjunction of one or more verb phrases starting with infinitives. MDCG successfully generates the trees illustrated in fig 1, thus tacitly assuming compositional counterparts adopting modifications such as the bracketing of Parte@ ([24], [253), or the headverb flagging convention of Bennett [23. Bennett&apos;s simplified semantic typing, which results from treating IV and CN as primitive categories, is also exploited in LILT as illustrated in the appendix. The MDCG post referencing facility requires the admission of alternative capitalised variables, and an amended flO which undertakes the replacement by term T Of the earlier of: (a) the first uncapitalised variable with index n or (b) the last occurring variable with index n. Whether capitalised :variables would prove popular with advocates of the &amp;quot;well formedness constraint&amp;quot; £2</context>
</contexts>
<marker>[24]</marker>
<rawString>Partee B.H. (1973) Some transformational extensions of Montague grammar. in Partee (1976). (25] Partee B.H. (1975) Montague grammar and transformational grammar. Linguistic Inquiry 6. £26] Parte, B.H. (Ed. ) (1976) Montague Grammar. Academic Press, N.Y.</rawString>
</citation>
<citation valid="false">
<authors>
<author>B H Partee</author>
</authors>
<title>Constraining transformational Montague grammar: a framework and a fragment. in Davis &amp; Mithun</title>
<date>1977</date>
<journal>Artificial Intelligence</journal>
<booktitle>Natural Lanauaae Processing.. Algorithmics Press, N.Y. (30] Thomason R.H. .(1974) (Ed. ) Formal allosophu - Selected Papers of Richard</booktitle>
<volume>13</volume>
<pages>297</pages>
<location>Montague. Yale, New Haven (31] Thompson</location>
<marker>[27]</marker>
<rawString>Partee B.H. (1977) Constraining transformational Montague grammar: a framework and a fragment. in Davis &amp; Mithun (1981). (28] Pereira F.C.N. &amp; Warren D. H. D. (1980) Definite clause grammars for language analysis. Artificial Intelligence 13. (297 Rustin R. (Ed. ) (1973) Natural Lanauaae Processing.. Algorithmics Press, N.Y. (30] Thomason R.H. .(1974) (Ed. ) Formal allosophu - Selected Papers of Richard Montague. Yale, New Haven (31] Thompson H. (1981) Chart parsing and rule schemata in PSG. Proceedings of the 19th. annual meeting of the Association for Computational Linguistics 167-172. C32] Warren D.S. (1983) Using lambda calculus to represent meanings in logic grammars. Proceedings of the 21st. Annual Meeting of the Association for Computational Linguistics</rawString>
</citation>
<citation valid="true">
<authors>
<author>D S Warren</author>
<author>J Friedman</author>
</authors>
<title>Using semantics in non context free parsing of Montague grammar.</title>
<date>1982</date>
<journal>American Journal of Computational Linguistics S.</journal>
<volume>34</volume>
<publisher>Addison-Wesley,</publisher>
<location>Reading, Mass.</location>
<marker>[33]</marker>
<rawString>Warren D.S. &amp; Friedman J. (1982) Using semantics in non context free parsing of Montague grammar. American Journal of Computational Linguistics S. (34] Winograd T. (1983) Language as a Coanitive Process. Addison-Wesley, Reading, Mass.</rawString>
</citation>
<citation valid="false">
<authors>
<author>W A Woods</author>
</authors>
<title>An experimental parsing system for transition network grammars. in Rustin</title>
<date>1970</date>
<pages>3423</pages>
<contexts>
<context position="17474" citStr="[35]" startWordPosition="2809" endWordPosition="2809">tion over a variable remaining free in the family of an elder jitter (the original constraint), but the elder sister must extend the same courtesy to her sibling. 6 The mechanics of MDCG 6.1 Handlina Left Recursion Fig 3 illustrates the MDCG equivalent is essentially left recursive, which pres— ents problems for a top—down. left—right, depth first DCG technique. Standard methods [34] for eliminating left recursion from a CFG would be inapprop— riate as they result in only weakly equi— valent grammars. The MDCG solution is to employ a well formed substring table (WFST). (vide C172. [313. C337, [35]) and assume that the recurring item has already been found. adding to the table the result of subsequent parsing given that it is unique relative to its environment. Since the WFST must record the relative position of entries, grammar rule notation CORN) which insulates the programmer from lexical decomposition must be proscribed: accordingly MDCG is written in raw PROLOG, pairs of variables in the range Ia..Iz representing string buffers before and after parsing. 6.2 Restorative Editina Reflection on the behaviour of the clause in fig 3 during the parsing of: (5) Woman such, that a man loves</context>
</contexts>
<marker>[35]</marker>
<rawString>Woods W.A. (1970) An experimental parsing system for transition network grammars. in Rustin (1973). Composition 6 Simplification (0] from Lexicon: Basic expression (man) 0 man (1) from Lexicon: Basic expression [a] lambda(paambda(q:exists(_3423:Cp(_3423)6 &apos;q(3423))))) (2) from [OM: Construction by T2 eval(lambda(p:lambda(q:exists(3423:Cp(_3423)6 sq(3423))))),^man) (3) from [21: Instantiate variable eval(&apos;&amp;quot;man, 3423)</rawString>
</citation>
<citation valid="false">
<title>from (3): Relational notation &apos;man(_3423)</title>
<contexts>
<context position="2498" citStr="[4]" startWordPosition="374" endWordPosition="374">g the derivation tree which reflects the reverse order application of the inverse rules. An abstract algorithm describing the parser is given in the form of procedural pseudo code, however the problem of establishing that an implementation con— forms to the algorithm is deferred, a problem perhaps aggravated by the absence of a formal notation for M rules which might otherwise have suggested appropriate data structures. The postorder traverse in (ii) of a preorder creation involves a duplication which may be avoided by adopting the PROLOG Definite Clause Grammar (DCG) formalism. ([283 cf.C33, [4], CS], [213), which, as has been observed C32) virtually forces the methodology of syntax directed translation coupled with compositional semantics. A DCG may be ingenuously characterised as a CFG having category symbols augmented by argument places. and containing supplementary goals not limited in function to input consumption. • Logical variables in argument places permit synthesised and inherited attributes [1S] to be handled with equal facility. The clauses of a DCG may be directly executed by a PROLOG interpreter, hence if combined CFG+analytical—M rules are presented in the form of Defi</context>
</contexts>
<marker>[4]</marker>
<rawString>from (3): Relational notation &apos;man(_3423)</rawString>
</citation>
<citation valid="false">
<title>from [41: Down—up conversion</title>
<pages>3423</pages>
<marker>[5]</marker>
<rawString>from [41: Down—up conversion man( 3423)</rawString>
</citation>
<citation valid="false">
<booktitle>from 12j: Lambda conversion lambda(q:exists(_3423:(man( 3423)6 &apos;q(3423</booktitle>
<marker>[6]</marker>
<rawString>from 12j: Lambda conversion lambda(q:exists(_3423:(man( 3423)6 &apos;q(3423))))</rawString>
</citation>
<citation valid="false">
<authors>
<author>from Lexicon</author>
</authors>
<title>Basic expression [be] =7 lambda(sub:lambda( 4607: &apos;sub(-1ambda(_4608: equals(</title>
<pages>4607--46067</pages>
<marker>[7]</marker>
<rawString>from Lexicon: Basic expression [be] =7 lambda(sub:lambda( 4607: &apos;sub(-1ambda(_4608: equals( 4607, 46067))))</rawString>
</citation>
<citation valid="false">
<title>from 16,71: Constratioti—by TS 0&gt; eval(lambda(sub:lambda(_4607: &apos;sub(&amp;quot;lambda(...4608: equals( 4607,4608))))),^lambda(q:exists(_3423: man(34IB)E, &apos;q(_3423))))) (9) from 18j: Instantiate variable eval(&apos;</title>
<booktitle>lambda(q:exists( 3423:(man( 3423)6. &apos;q(.3423)))). -lambda(_4608:equals( 401,...4608))i— (10) from 19j: Down—up conversion eval(lambda(q:exists( 3423:(man( 3423)6 &apos;q(_3423)))),</booktitle>
<pages>26608--4607</pages>
<marker>[8]</marker>
<rawString>from 16,71: Constratioti—by TS 0&gt; eval(lambda(sub:lambda(_4607: &apos;sub(&amp;quot;lambda(...4608: equals( 4607,4608))))),^lambda(q:exists(_3423: man(34IB)E, &apos;q(_3423))))) (9) from 18j: Instantiate variable eval(&apos; ^lambda(q:exists( 3423:(man( 3423)6. &apos;q(.3423)))). -lambda(_4608:equals( 401,...4608))i— (10) from 19j: Down—up conversion eval(lambda(q:exists( 3423:(man( 3423)6 &apos;q(_3423)))), -lambda(26608:equals(:4607,4606Y))</rawString>
</citation>
<citation valid="false">
<title>from (10): Instantiate variable eval(&apos; &amp;quot;lambda(_4608:equals(_4607,_4608)),3423</title>
<marker>[11]</marker>
<rawString>from (10): Instantiate variable eval(&apos; &amp;quot;lambda(_4608:equals(_4607,_4608)),3423)</rawString>
</citation>
<citation valid="false">
<title>from [11]: Down-up conversion eval(lambda(4608:equals(_4607,24608)),3423) (131 from [121: Lambda conversion equals(</title>
<pages>4607--3423</pages>
<marker>[12]</marker>
<rawString>from [11]: Down-up conversion eval(lambda(4608:equals(_4607,24608)),3423) (131 from [121: Lambda conversion equals( 4607,3423)</rawString>
</citation>
<citation valid="false">
<title>from (101: Substitute identicals</title>
<pages>4607</pages>
<marker>[14]</marker>
<rawString>from (101: Substitute identicals man( 4607)</rawString>
</citation>
<citation valid="false">
<title>from [101: Lambda conversion man(_4607)</title>
<marker>[15]</marker>
<rawString>from [101: Lambda conversion man(_4607)</rawString>
</citation>
<citation valid="false">
<title>from [81: Lambda conversion ].ambda(</title>
<volume>4607</volume>
<pages>4607</pages>
<marker>[16]</marker>
<rawString>from [81: Lambda conversion ].ambda( 4607:man( 4607))</rawString>
</citation>
<citation valid="false">
<authors>
<author>from Lexicon</author>
</authors>
<title>Basic expression [john] lambda(p: `p(john</title>
<marker>[17]</marker>
<rawString>from Lexicon: Basic expression [john] lambda(p: `p(john))</rawString>
</citation>
<citation valid="false">
<title>from [16,17]: Construction by T4 0 eval(lambda(p: &apos;p(john)),&amp;quot;lambda(_4607:man(_4607</title>
<marker>[18]</marker>
<rawString>from [16,17]: Construction by T4 0 eval(lambda(p: &apos;p(john)),&amp;quot;lambda(_4607:man(_4607)))</rawString>
</citation>
<citation valid="false">
<title>from [18]: Instantiate variable eval(&apos; &amp;quot;lambda(_4607:man(_4607)),john</title>
<marker>[19]</marker>
<rawString>from [18]: Instantiate variable eval(&apos; &amp;quot;lambda(_4607:man(_4607)),john)</rawString>
</citation>
<citation valid="false">
<title>from [19]: Down-up conversion eval(lambda(_4607:man(_4607)),john</title>
<contexts>
<context position="1007" citStr="[20]" startWordPosition="137" endWordPosition="137">arser returning Montague analysis trees. A parser MDCG is pres— ented which implements an augmented Friedman — Warren algorithm permitting post referencing, and interfaces with a language of intensional logic translator LILT so as to display the derivational history of corresponding reduced IL form— ulae. Some familiarity with Montague&apos;s PTO and the basic DCG mechanism is assumed. Ke words Compositional Semantics, Definite Clause Grammar, Friedman Warren Algorithm, Intensional Logic, Montague Grammmar, Nat— ural Language Processing, PROLOG. 1 Introduction Consideration is given by Landsbergen [20] to the global algorithmic structure of a top down parser demonstrably equi— valent to a compositional grammar such as that of PTO [223. The method is as follows: 1. Formulate the original grammar in terms of indexed compositional—M rules of form: If syntax trees &lt;Sk..Sn) satisfy condition C then combine &lt;Sk..Sn&gt; into Sj such that the compositional history may be represented on a derivation tree (i.e. a skeletal analysis tree lacking node labels). 2. Subject to specified restraints evolve inverse analytical—M Rules of form: If Sj conforms to condition C&apos; then analyse Sj into &lt;Sk..Sn&gt;. 3. Prove</context>
<context position="3263" citStr="[20]" startWordPosition="490" endWordPosition="490"> ingenuously characterised as a CFG having category symbols augmented by argument places. and containing supplementary goals not limited in function to input consumption. • Logical variables in argument places permit synthesised and inherited attributes [1S] to be handled with equal facility. The clauses of a DCG may be directly executed by a PROLOG interpreter, hence if combined CFG+analytical—M rules are presented in the form of Definite Clauses. the problem of mapping algorithm to implementation does not arise: the algorithm and program are one and the same. The parsers of both Landsbergen [20] and Friedman &amp; Warren [9) generate only skeletal trees, other details being recoverable from the leaves and operation indices: however the tedium of such recovery may properly devolve on the comp— uter. and for pedagogical purposes at 25 least the production of full analysis trees would be advantageous. This paper outlines a DCG implementation of a version of the compositional syntax of PTO which returns full Montague analysis trees in the form of vine d4agrams modified at most by additional ,feature marking on variables. Given an input sentence. MDCG returns sets of trees, optionally passing</context>
</contexts>
<marker>[20]</marker>
<rawString>from [19]: Down-up conversion eval(lambda(_4607:man(_4607)),john)</rawString>
</citation>
<citation valid="false">
<title>from [20]: Lambda conversion man(</title>
<publisher>John</publisher>
<marker>[21]</marker>
<rawString>from [20]: Lambda conversion man( John)</rawString>
</citation>
<citation valid="false">
<title>from [181: Lambda conversion man(</title>
<publisher>John</publisher>
<marker>[22]</marker>
<rawString>from [181: Lambda conversion man( John)</rawString>
</citation>
<citation valid="false">
<authors>
<author>from Lexicon</author>
</authors>
<title>Basic expression [believe] 0 believe (24] from [22,23]: Construction by T7 eval(believe,&amp;quot;man(john</title>
<marker>[23]</marker>
<rawString>from Lexicon: Basic expression [believe] 0 believe (24] from [22,23]: Construction by T7 eval(believe,&amp;quot;man(john))</rawString>
</citation>
<citation valid="false">
<title>from [241: Relational notation believe(&amp;quot;aan(john</title>
<marker>[25]</marker>
<rawString>from [241: Relational notation believe(&amp;quot;aan(john))</rawString>
</citation>
<citation valid="false">
<authors>
<author>from Lexicon</author>
</authors>
<title>Basic expression [mary] lambda(p: &apos;p(mary</title>
<marker>[26]</marker>
<rawString>from Lexicon: Basic expression [mary] lambda(p: &apos;p(mary))</rawString>
</citation>
<citation valid="false">
<title>Construction by T4 0 eval(lambda(p: &apos;o(mary)),&amp;quot;believe(&amp;quot;man(john</title>
<marker>[27) from [25,26]</marker>
<rawString>: Construction by T4 0 eval(lambda(p: &apos;o(mary)),&amp;quot;believe(&amp;quot;man(john)))</rawString>
</citation>
<citation valid="false">
<title>from [27]: Instantiate variable eval(&apos; &amp;quot;believe(&amp;quot;man(john)),mary</title>
<marker>[28]</marker>
<rawString>from [27]: Instantiate variable eval(&apos; &amp;quot;believe(&amp;quot;man(john)),mary)</rawString>
</citation>
<citation valid="false">
<title>from [281: Relational notation &apos; &amp;quot;believe(mary,&amp;quot;man(john</title>
<marker>[29]</marker>
<rawString>from [281: Relational notation &apos; &amp;quot;believe(mary,&amp;quot;man(john))</rawString>
</citation>
<citation valid="false">
<title>from [291: Down-up conversion believe(mary,&amp;quot;man(john</title>
<marker>[30]</marker>
<rawString>from [291: Down-up conversion believe(mary,&amp;quot;man(john))</rawString>
</citation>
<citation valid="false">
<title>from [27]: Lambda conversion believe(mary,&amp;quot;man(john)) Logical Form believe(mary,&amp;quot;man(john</title>
<marker>[31]</marker>
<rawString>from [27]: Lambda conversion believe(mary,&amp;quot;man(john)) Logical Form believe(mary,&amp;quot;man(john))</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>