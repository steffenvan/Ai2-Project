<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000008">
<title confidence="0.955158">
A Unification Method for Disjunctive Feature Descriptions
</title>
<author confidence="0.989748">
Robert T. Kasper
</author>
<affiliation confidence="0.971660333333333">
USC/Information Sciences Institute
4676 Admiralty Way, Suite 1001
Marina del Rey, CA 90292
and
Electrical Engineering and Computer Science Department
University of Michigan
</affiliation>
<sectionHeader confidence="0.988917" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.9998935">
Although disjunction has been used in several unification-
based grammar formalisms, existing methods of unification
have been unsatisfactory for descriptions containing large
quantities of disjunction, because they require exponential
time. This paper describes a method of unification by succes-
sive approximation, resulting in better average performance.
</bodyText>
<sectionHeader confidence="0.998429" genericHeader="keywords">
1 Introduction
</sectionHeader>
<bodyText confidence="0.999981">
Disjunction has been used in several unification-based gram-
mar formalisms to represent alternative structures in descrip-
tions of constituents. Disjunction is an essential component
of grammatical descriptions in Kay&apos;s Functional Unification
Grammar [6], and it has been proposed by Karttunen as a
linguistically motivated extension to PATR-II [2].
In previous work two methods have been used to handle
disjunctive descriptions in parsing and other computational
applications.
The first method requires expanding descriptions to dis-
junctive normal form (DNF) so that the entire description
can be interpreted as a set of structures, each of which con-
tains no disjunction. This method is exemplified by Definite
Clause Grammar [8], which eliminates disjunctive terms by
expanding each rule containing disjunction into alternative
rules. It is also the method used by Kay [7] in parsing FUG.
This method works reasonably well for small grammars, but
it is clearly unsatisfactory for descriptions containing more
than a small number of disjunctions, because the DNF ex-
pansion requires an amount of space which is exponential in
the number of disjunctions.
The second method, developed by Karttunen [2], uses con-
straints on disjuncts which must be checked whenever a dis-
junct is modified. Karttunen&apos;s method is only applicable to
value disjunctions (i.e. those disjunctions used to specify the
value of a single feature), and it becomes complicated and in-
efficient when disjuncts contain non-local dependencies (i.e.
values specified by path expressions denoting another fea-
ture).
In previous research [4,5] we have shown how descriptions
of feature structures can be represented by a certain type
of logical formula, and that the consistency problem for dis-
junctive descriptions is NP-complete. This result indicates,
according to the widely accepted mathematical assumption
that P NP, that any complete unification algorithm for
disjunctive descriptions will require exponential time in the
worst case. However, this result does not preclude algorithms
with better average performance, such as the method de-
scribed in the remainder of this paper. This method over-
comes the shortcomings of previously existing methods, and
has the following desirable properties:
</bodyText>
<listItem confidence="0.9747702">
1. It applies to descriptions containing general disjunction
and non-local path expressions;
2. It delays expansion to DNF;
3. It can take advantage of fast unification algorithms for
non-disjunctive directed graph structures.
</listItem>
<sectionHeader confidence="0.937711" genericHeader="introduction">
2 Data Structures
</sectionHeader>
<bodyText confidence="0.999851769230769">
The most common unification methods for non-disjunctive
feature structures use a directed graph (DG) representation,
in which arcs are labeled by names of features, and nodes
correspond to values of features. For an introduction to these
methods, the reader is referred to Shieber&apos;s survey [11]. In
the remainder of this section we will define a data structure
for disjunctive descriptions, using DG structures as a basic
component.
In the following exposition, we will carefully observe the
distinction between feature structures and their descriptions,
as explained in [4]. Feature structures will be represented
by DGs, and descriptions of feature structures will be repre-
sented by logical formulas of the type described in [4]. The
</bodyText>
<page confidence="0.996184">
235
</page>
<bodyText confidence="0.95345125">
NIL denoting no information;
TOP denoting inconsistent information;
a where a E A, to describe atomic values;
I : where I E L and E FDL, to describe structures
in which the feature labeled by I has a value described by 0;
[&lt; pi &gt;,•••,&lt; pes &gt;I where each pi E L* , to describe an equivalence class
of paths sharing a common value in a feature structure;
where 0, E FDL;
</bodyText>
<figure confidence="0.773542">
0 V where 0, &apos;E FDL.
</figure>
<figureCaption confidence="0.999528">
Figure 1: Syntax of FDL Formulas.
</figureCaption>
<bodyText confidence="0.999666076923077">
syntax for formulas of this feature description logic (hereafter
called FDL) is given in Figure 1.1
Note, in particular, that disjunction is used in descriptions
of feature structures, but not in the structures themselves.
As we have shown (see [91) that there is a unique minimal
satisfying DG structure for any nondisjunctive FDL formula,
we can represent the parts of a formula which do not contain
any disjunction by DGs. DGs are a more compact way of
representing the same information that is contained in a FDL
formula, provided the formula contains no disjunction.
Let us define an unconditional conjunct to be a conjunct
of a formula which contains no occurrences of disjunction.
After path expansion any formula can be put into the form:
</bodyText>
<subsectionHeader confidence="0.481682">
uconj A dish A ... A disj„,
</subsectionHeader>
<bodyText confidence="0.96042176">
where uconj contains no occurrences of disjunction, and each
disji, for 1 &lt; i &lt; m, is a disjunction of two or more alter-
natives. The uconj part of the formula is formed by using
the commutative law to bring all unconditional conjuncts of
the formula together at the front. Of course, there may be
no unconditional conjuncts in a formula, in which case uconj
would be the formula NIL.
Each disjunct may be any type of formula, so disjuncts can
also be put into a similar form, with all unconditional con-
juncts grouped together before all disjunctive components.
Thus the disjunctions of a formula can be put into the form
(uconji Adi sj 11 A ...Adisji.) V ... V (uconj. Adi a jy, A ...A diejny).
The embedding of conjuncts within disjuncts is preserved,
but the order of conjuncts may be changed.
The unconditional conjuncts of a formula contain informa-
tion that is more definite than the information contained in
disjunctions. Thus a formula can be regarded as having a
definite part, containing only unconditional conjuncts, and
an indefinite part, containing a set of disjunctions. The def-
inite part contains no disjunction, and therefore it may be
represented by a DG structure. To encode these parts of a
formula, let us define a feature-description as a type of data
structure, having two components:
iLet A and L be sets of symbols which are used to denote
atomic values and feature labels, respectively.
</bodyText>
<figureCaption confidence="0.806409666666667">
Figure 2: AND/OR graph representation of a feature
description.
definite: a DG structure;
</figureCaption>
<bodyText confidence="0.979920384615385">
Indefinite: a SET of disjunctions, where each disjunction
is a SET of feature-descriptions.
It is possible to convert any FDL formula into a feature-
description structure by a simple automatic procedure, as
described in [51. This conversion does not add or subtract any
information from a formula, nor increase its size in any sig-
nificant way. It simply identifies components of the formula
which may be converted into a more efficient representation
as DG structures.
A feature-description is conceptually equivalent to a spe-
cial kind of AND/OR graph, in which the terminal nodes are
represented by DG structures. For example, an AND/OR
graph equivalent to the formula,
</bodyText>
<subsectionHeader confidence="0.786186">
00 A (01 V 02) A (03 V 04 V (05 A (06 V 07)))
</subsectionHeader>
<bodyText confidence="0.999845833333333">
is shown in Figure 2. In the AND/OR graph representa-
tion, each AND-node represents a feature-description. The
first outgoing arc from an AND-node represents the definite
component of a feature-description, and the remaining outgo-
ing arcs represent the indefinite component. Each OR-node
represents a disjunction.
</bodyText>
<equation confidence="0.826032">
AND
G(05) _,DG(966)
\ 0
</equation>
<page confidence="0.993588">
236
</page>
<bodyText confidence="0.745717380952381">
Function UNIFY-DESC (f, g) Returns feature-description:
where f and g are feature-descriptions.
/. Unify definite components.
Let new-def = UNIFY-DGS (f.definite, g.definite).
If new-def = TOP, then return (failure).
Let desc = a feature-description with:
desc.definite = new-def,
desc.indefinite = tindefinite U g.indefinite.
If desc.indefinite = 0,
Then return (desc);
Else begin;
2. Check compatibility of indefinite components with new-def.
Let new-desc = CHECK-INDEF (desc, new-def).
If new-desc = failure, then return (failure);
S. Complete ezhau.stiue consistency checking, if necessary.
Else if new-desc.indefinite = 0
OR if complete checking is not required,
Then return (new-desc);
Else begin;
Let n = 1.
Repeat while n &lt; cardinality of new-desc.indefinite:
</bodyText>
<equation confidence="0.911729">
new-desc := NWISE-CONSISTENCY (new-desc, n).
n := n + 1.
return (new-desc).
end.
end.
</equation>
<figureCaption confidence="0.995025">
Figure 3: Unification algorithm for feature-descriptions.
</figureCaption>
<sectionHeader confidence="0.883304" genericHeader="method">
3 The Algorithm: Unification
by Successive Approximation
</sectionHeader>
<bodyText confidence="0.998872130434783">
In this section we will give a complete algorithm for unify-
ing two feature-descriptions, where one or both may contain
disjunction. This algorithm is designed so that it can be used
as a relatively efficient approximation method, with an op-
tional step to perform complete consistency checking when
necessary.
Given two feature-descriptions, the strategy of the unifi-
cation algorithm is to unify the definite components of the
descriptions first, and examine the compatibility of indefi-
nite components later. Disjuncts are eliminated from the
description when they are inconsistent with definite informa-
tion. This strategy avoids exploring disjuncts more than once
when they are inconsistent with definite information.
The exact algorithm is described in Figure 3. It has three
major steps.
In the first step, the definite components of the two de-
scriptions are unified together, producing a DG structure,
new-def, which represents the definite information of the re-
sult. This step can be performed by existing unification al-
gorithms for DGs.
In the second step, the indefinite components of both de-
scriptions are checked for compatibility with new-def, using
the function CHECK-INDEF, which is defined in Figure 4.
CHECK-INDEF uses the function CHECK-DISJ, defined in
Figure 5, to check the compatibility of each disjunction with
the DG structure given by the parameter cond.
The compatibility of two DGs can be checked by almost the
same procedure as unification, but the two structures being
checked are not actually merged as they are in unification.
In the third major step, if any disjunctions remain, and it
is necessary to do so, disjuncts of different disjunctions are
considered in groups, to check whether they are compatible
together. This step is performed by the function NWISE-
CONSISTENCY, defined in Figure 6.
When the parameter n to NWISE-CONSISTENCY has
the value 1, then one disjunct is checked for compatibility
with all other disjunctions of the description in a pairwise
manner. The pairwise manner of checking compatibility can
be generalized to groups of any size by increasing the value
of the parameter n.
While this third step of the algorithm is necessary in or-
der to insure consistency of disjunctive descriptions, it is not
necessary to use it every time a description is built during a
parse. In practice, we find that the performance of the algo-
rithm can be tuned by using this step only at strategic points
during a parse, since it is the most inefficient step of the al-
</bodyText>
<page confidence="0.978889">
237
</page>
<bodyText confidence="0.860451833333333">
Function CHECK-INDEF (desc, cond) Returns feature-description:
where desc is a feature-description,
and cond is a DG.
Let indef = desc.indefinite (a set of disjunctions).
Let new-def = desc.definite (a DG).
Let unchecked-parts = true.
</bodyText>
<table confidence="0.9808914">
While unchecked-parts, begin;
unchecked-parts := false.
Let new-indef = 0.
For each disjunction in indef:
Let compatible-disjuncts = CHECK-DISJ (disjunction, cond).
If cardinality of compatible-disjuncts is:
0 : Return (failure);
1 : Let disjunct = single element of compatible-disjuncts.
new-def := UNIFY-DGS (new-def, disjunct.definite).
new-indef := new-indef U disjunct.indefinite.
unchecked-parts := true;
otherwise: new-indef := new-indef U {compatible-disjuncts}.
Prepare to check remaining disjunctions for compatibility with new-def.
cond := new-def.
indef := new-indef.
end (while loop).
Let new-desc = make feature-description with:
new-desc.deftnite = new-def,
new.desc.indeftnite = new-indef.
Return (new-desc).
</table>
<figureCaption confidence="0.9918">
Figure 4: Algorithm to check compatibility of indefinite parts of feature-descriptions with respect to a condition DG.
</figureCaption>
<bodyText confidence="0.969960333333333">
Function CHECK-DISJ (disj, cond) Returns disjunction:
where disj is a disjunction of feature-descriptions,
and cond is a DG.
</bodyText>
<table confidence="0.901239333333333">
Let new-disj = 0 (a set of feature-descriptions).
For each disjunct in disj:
If DGS-COMPATIBLE? (cond, disjunct.definite),
Then if disjunct.indefinite = 0,
Then new-disj := new-disj u {disjunct};
Else begin;
Let new-disjunct = CHECK-INDEF (disjunct, cond).
If new-disjunct failure, then begin;
new-disj := new-disj u {new-disjunct}.
end.
end.
Return (new-disj).
</table>
<figureCaption confidence="0.931949">
Figure 5: Algorithm to check compatibility of disjunctions with respect to a condition DG.
</figureCaption>
<page confidence="0.9138">
238
</page>
<table confidence="0.991508727272727">
Function NWISE-CONSISTENCY (desc, n) Returns feature-description:
where desc is a feature-description.
If number of disjunctions in desc.indefinite &lt; n,
Then Return (desc).
Let def = desc.definite.
Let indef = desc.indefinite.
Let new-indef = 0.
While disjunctions remain in indef:
Let disjunction = remove one disjunction from indef.
Let new-disj = 0.
For each disjunct in disjunction:
Let disjunct-def = UNIFY-DGS (clef, disjunct.definite).
Let disjunct-indef = disjunct.indefinite U indef U new-indef.
Let hyp-desc = make feature-description with:
hyp-desc.definite = disjunct-def,
hyp-desc.indefinite = disjunct-indef.
If n = 1,
Then let new-desc = CHECK-INDEF (hyp-desc, disjunct-def).
Else let new-desc = NWISE-CONSISTENCY (hyp-desc, n-1).
If new-desc $ failure,
Then new-disj := new-disj U {new-desc}.
If cardinality of new-disj is:
0: Return (failure);
1: Let new-desc = single element of new-disj.
def := new-desc.definite.
indef := new-desc.indefinite.
new-indef := 0;
otherwise: (keep this disjunction in result)
new-indef := new-indef U {new-disj}.
Let result-desc = make feature-description with:
result-desc.definite = def,
result-desc.indefinite = new-indef.
Return (result-desc).
</table>
<figureCaption confidence="0.998398">
Figure 6: Algorithm to check compatibility of disjunctions of a description by checking groups of n disjunctions.
</figureCaption>
<bodyText confidence="0.999978666666667">
gorithm. In our application, using the Earley chart parsing
method, it has proved best to use NWISE-CONSISTENCY
only when building descriptions for complete edges, but not
when building descriptions for active edges.
Note that two feature-descriptions do not become perma-
nently linked when they are unified, unlike unification for
DG stuctures. The result of unifying two descriptions is a
new description, which is satisfied by the intersection of the
sets of structures that satisfy the two given descriptions. The
new description contains all the information that is contained
in either of the given descriptions, subtracting any disjuncts
which are no longer compatible.
</bodyText>
<sectionHeader confidence="0.967353" genericHeader="method">
4 An example
</sectionHeader>
<bodyText confidence="0.995978333333333">
In order to illustrate the effect of each step of the algo-
rithm, let us consider an example of unifying the descrip-
tion of a known constituent with the description of a por-
tion of a grammar. This exemplifies the predominant type of
structure building operation needed in a parsing program for
Functional Unification Grammar. The example given here is
deliberately simple, in order to illustrate how the algorithm
works with a minimum amount of detail. It is not intended
as an example of a linguistically motivated grammar.
</bodyText>
<figureCaption confidence="0.93861775">
Let us trace what happens when the two descriptions of
Figure 7 are given as inputs to the function UNIFY-DESC.
Figure 8 shows the feature-description which results after
step 1 of the algorithm. The definite components of the two
</figureCaption>
<bodyText confidence="0.961624809523809">
descriptions have been unified, and their indefinite compo-
nents have been conjoined together.
In step 2 of the algorithm each of the disjuncts
of DES C.INDEFINITE is checked for compatibility with
DESC.DEFINITE, using the function CHECK-INDEF. In
this case, all disjuncts are compatible with the definite infor-
mation, except for one; the disjunct of the third disjunction
which contains the feature Number : Sing. This disjunct is
eliminated, and the only remaining disjunct in the disjunc-
tion (i.e., the disjunct containing Number : PO is unified
with DESC.DEFINITE. The result after this step is shown
in Figure 9. The four disjuncts that remain are numbered for
convenience.
In step 3, NWISE-CONSISTENCY is used with 1 as the
value of the parameter n. A new description is hypothesized
by unifying disjunct (1) with the definite component of the
description (i.e., NEW-DESC.DEFINITE). Then disjuncts
(3) and (4) are checked for compatibility with this hypothe-
sized structure: (3) is not compatible, because the values of
the Transitivity features do not unify. Disjunct (4) is also
incompatible, because it has Goal : Person : 3, and the hy-
</bodyText>
<page confidence="0.993471">
239
</page>
<figure confidence="0.9986510625">
GRAMMAR:
[Rank :Clause ]
DEFINITE =
Subj :Case : Nom
INDEFINITE =
Voice :Passive
Transitivity :Trans v [Voice : Active
1&lt; Subj &gt;,&lt; Actor &gt;1
i&lt; Subj &gt;,&lt; Goal &gt;1
Transitivity : Intrans IIv Transitivity :Trans
Actor : Person : 3 Goal :Person : 3
SUBJECT CONSTITUENT:
[Lex : Vali I
DEFINITE = Subj: Person : 2
Number : /31
INDEFINITE = NIL
</figure>
<figureCaption confidence="0.999945">
Figure 7: Two descriptions to be unified.
</figureCaption>
<bodyText confidence="0.999404818181818">
pothesized description has ri&lt; Subj &gt;,&lt; Goal &gt;1, along with
Subj : Person : 2. Therefore, since there is no compatible
disjunct among (3) and (4), the hypothesis that (1) is com-
patible with the rest of the description has been shown to be
invalid, and (1) can be eliminated. It follows that disjunct
(2) should be unified with the definite part of the descrip-
tion. Now disjuncts (3) and (4) are checked for compatibility
with the definite component of the new description: (3) is no
longer compatible, but (4) is compatible. Therefore, (3) is
eliminated, and (4) is unified with the definite information.
No disjunctions remain in the result, as shown in Figure 10.
</bodyText>
<sectionHeader confidence="0.643457" genericHeader="method">
5 Complexity of the Algorithm
</sectionHeader>
<bodyText confidence="0.998315738095238">
Referring to Figure 3, note that the function UNIFY-DESC
may terminate after any of the three major steps. After each
step it may detect inconsistency between the two descriptions
and terminate, returning failure, or it may terminate because
no disjunctions remain in the description. Therefore, it is
useful to examine the complexity of each of the three steps
independently.
Let n represent the total number of symbols in the com-
bined description f A g, and d represent the total number
of disjuncts (in both top-level and embedded disjunctions)
contained in f A g.
Step /. This step performs the unification of two DG struc-
tures. Ait-Kaci [1] has shown how this operation can be per-
formed in almost linear time by the UNION/FIND algorithm.
Its time complexity has an upper bound of 0(n log n). Since
an unknown amount of a description may be contained in the
definite component, this step of the algorithm also requires
0(n log it) time.
Step 2. For this step we examine the complexity of the
function CHECK-INDEF. There are two nested loops in
CHECK-INDEF, each of which may be executed at most once
for each disjunct in the description. The inner loop checks the
compatibility of two DG structures, which requires no more
time than unification. Thus, in the worst case, CHECK-
lNDEF requires 0(cen log n) time.
Step 3. NWISE-CONSISTENCY requires at most 0(2d/2)
time. In this step, NWISE-CONSISTENCY is called at most
(d/2) — 1 times. Therefore, the overall complexity of step 3
is 0(2d/2).
Discussion. While the worst case complexity of the entire
algorithm is 0(2d), an exponential, it is significant that it
often terminates before step 3, even when a large number
of disjunctions are present in one of the descriptions. Thus,
in many practical cases the actual cost of the algorithm is
bounded by a polynomial that is at most d2n log it. Since d
must be less than n, this complexity function is almost cubic.
Even when step 3 must be used, the number of remaining
disjunctions is often much fewer than d/2, so the exponent
is usually a small number. The algorithm performs well in
most cases, because the three steps are ordered in increasing
complexity, and the number of disjunctions can only decrease
during unification.
</bodyText>
<sectionHeader confidence="0.992315" genericHeader="method">
6 Implementation
</sectionHeader>
<bodyText confidence="0.998771181818182">
The algorithm presented in the previous sections has been im-
plemented and tested as part of a general parsing method for
Systemic Functional Grammar, which is described in [3]. The
algorithm was integrated with the structure building module
of the PATR-II system [101, written in the Zetalisp program-
ming language.
While the feature-description corresponding to a grammar
may have hundreds of disjunctions, the descriptions that re-
sult from parsing a sentence usually have only a small number
of disjunctions, if any at all. Most disjunctions in a systemic
grammar represent possible alternative values that some par-
ticular feature may have (along with the grammatical conse-
quences entailed by choosing particular values for the fea-
ture). In the analysis of a particular sentence most features
have a unique value, and some features are not present at all.
When disjunction remains in the description of a sentence
after parsing, it usually represents ambiguity or an under-
specified part of the grammar.
With this implementation of the algorithm, sentences of
up to 10 words have been parsed correctly, using a grammar
which contains over 300 disjunctions. The time required for
most sentences is in the range of 10 to 300 seconds, running
on lisp machine hardware.
The fact that sentences can be parsed at all with a gram-
mar containing this many disjunctions indicates that the al-
gorithm is performing much better than its theoretical worst
case time of 0(2d).2 The timings, shown in Table 1, obtained
from the experimental parser for systemic grammar also in-
dicate that a dramatic increase in the number of disjunctions
in the grammar does not result in an exponential increase
in parse time. C08 is a grammar containing 98 disjunctions,
2Consider, 23&amp;quot; i:. 28°, and 280 is taken to be a rough estimate
of the number of particles in the universe.
</bodyText>
<figure confidence="0.99498115625">
( 1
)
Number: Sing Number :P1
V
_ Subj : Number : Sing Subj : Number :P1
240
-
Rank : Clause
Subj :[Lex : y&apos;all
Person : 2
Number : PI
Case : Nom
DES C.DEFINITE =
-
I
DESC.INDEFINITE =
IVoice : Passive
Transitivity :Trans
[&lt; Subj &gt;,&lt; Goal &gt;1 .
Transitivity : Intrans
Actor : Person : 3
Number : Sing
Subj : Number : Sing ,
V [Voice : Active
[&lt; Subj &gt;,&lt; Actor &gt;1 I
Y
Transitivity :Trans
V
Goal : Person : 3
[Number : P1
V
Subj : Number : PI]
</figure>
<figureCaption confidence="0.994613">
Figure 8: UNIFY-DESC: After step 1 (UNIFY-DGS).
</figureCaption>
<figure confidence="0.9959086">
Rank : Clause
[Case : Nom 1
Lex : Vail
Person : 2
Number : PI
Number : PI
NEW-DESC.DEFINITE =
Subj:
NEW-DESC.INDEFINITE =
(1) IVoice : Passive
Transitivity :Trans -
[&lt; Subj &gt;,&lt; Goal &gt;1 ,
Transitivity : Intrans
V (2) [Voice : Active
i&lt; Subj &gt;,&lt; Actor &gt;11 I
1 )
(3) Actor : Person : 3
Transitivity :Trans
v (4)
Goal : Person : 3
</figure>
<figureCaption confidence="0.993801">
Figure 9: UNIFY-DESC: After step 2 (CHECK-INDEF).
</figureCaption>
<figure confidence="0.777808">
_
Rank : Clause
[Case : Nom 1
Lex : y&apos;all
Person : 2
Number : PI
Number : PI
Voice : Active
[&lt; Subj &gt;,&lt; Actor &gt;1
Transitivity :Trans
Goal : Person : 3
NEW-DESC.INDEFINITE = NIL
</figure>
<figureCaption confidence="0.900465">
Figure 10: UNIFY-DESC: After step 3 (NWISE-CONSISTENCY).
</figureCaption>
<figure confidence="0.6367645">
NEW-DESC.DEFINITE =
Subj:
</figure>
<page confidence="0.950889">
241
</page>
<table confidence="0.435952">
Sentence GQ8 G440
Nigel has been speaking English. 22.9 144.3
Nigel has been speaking English to me. 28.6 203.5
</table>
<tableCaption confidence="0.996701">
Table 1: Timings obtained from a systemic parser.
</tableCaption>
<bodyText confidence="0.926033">
and G440 is a grammar containing 440 disjunctions. The total
time used to parse each sentence is given in seconds.
</bodyText>
<sectionHeader confidence="0.999281" genericHeader="conclusions">
7 Conclusions
</sectionHeader>
<bodyText confidence="0.999958235294118">
The unification method presented here represents a general
solution to a seemingly intractable problem. This method has
been used successfully in an experimental parser for a gram-
mar containing several hundred disjunctions in its descrip-
tion. Therefore, we expect that it can be used as the basis
for language processing systems requiring large grammatical
descriptions that contain disjunctive information, and refined
as necessary and appropriate for specific applications.
While the range of speed achieved by a straightforward
implementation of this algorithm is acceptable for grammar
testing, even greater efficiency would be desirable (and neces-
sary for applications demanding fast real-time performance).
Therefore, we suggest two types of refinement to this algo-
rithm as topics for future research: using heuristics to deter-
mine an opportune ordering of the disjuncts within a descrip-
tion, and using parallel hardware to implement the compat-
ibility tests for different disjunctions.
</bodyText>
<sectionHeader confidence="0.994407" genericHeader="acknowledgments">
Acknowledgements
</sectionHeader>
<bodyText confidence="0.999938">
I would like to thank Bill Rounds, my advisor during gradu-
ate studies at the University of Michigan, for his helpful crit-
icism of earlier versions of the algorithm which is presented
here. I would also like to thank Bill Mann for suggestions
during its implementation at USC/ISI, and Stuart Shieber
for providing help in the use of the PATR-II system.
This research was sponsored in part by the United States
Air Force Office of Scientific Research contracts FQ8671-84-
01007 and F49620-87-C-0005, and in part by the United
States Defense Advanced Research Projects Agency under
contract MDA903-81-C-0335; the opinions expressed here are
solely those of the author.
</bodyText>
<sectionHeader confidence="0.999272" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999757186046512">
[11 Ait-Kaci, H. A New Model of Computation Based on a
Calculus of Type Subsumption. PhD thesis, University of
Pennsylvania, 1984.
121 Karttunen, L. Features and Values. In Proceedings of the
Tenth International Conference on Computational Lin-
guistics: COLING 84, Stanford University, Stanford,
California, July 2-7, 1984.
13] Kasper, R. Systemic Grammar and Functional Unifica-
tion Grammar. In J. Benson and W. Greaves, editors,
Systemic Functional Perspectives on Discourse: Selected
Papers from the 12`k International Systemics Workshop,
Norwood, New Jersey: Ablex (forthcoming).
141 Kasper, R. and W. Rounds. A Logical Semantics for
Feature Structures. In Proceedings of the 24th Annual
Meeting of the Association for Computational Linguistics,
Columbia University, New York, NY, June 10-13, 1986.
[5] Kasper, R. Feature Structures: A Logical Theory with Ap-
plication to Language Analysis. PhD dissertation, Uni-
versity of Michigan, 1987.
[6] Kay, M. Functional Grammar. In Proceedings of the
Fifth Annual Meeting of the Berkeley Linguistics Soci-
ety, Berkeley Linguistics Society, Berkeley, California,
February 17-19, 1979.
[7] Kay, M. Parsing in Functional Unification Grammar. In
D. Dowty, L. Karttunen, and A. Zwicky, editors, Natu-
ral Language Parsing. Cambridge University Press, Cam-
bridge, England, 1985.
[8] Pereira, F. C. N. and D. H. D. Warren. Definite clause
grammars for language analysis — a survey of the formal-
ism and a comparison with augmented transition net-
works. Artificial Intelligence, 13:231-278, 1980.
[9] Rounds, W. C. and R. Kasper. A Complete Logical
Calculus for Record Structures Representing Linguistic
Information. Symposium on Logic in Computer Science.
IEEE Computer Society, June 16-18, 1986.
[10] Shieber, S. M. The design of a computer language for
linguistic information. In Proceedings of the Tenth Inter-
national Conference on Computational Linguistics: COL-
ING 84, Stanford University, Stanford, California, July
2-7, 1984.
[11] Shieber, S. M. An Introduction to Unification-based Ap-
proaches to Grammar. Chicago: University of Chicago
Press, CSLI Lecture Notes Series, 1986.
</reference>
<page confidence="0.997716">
242
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.642118">
<title confidence="0.999981">A Unification Method for Disjunctive Feature Descriptions</title>
<author confidence="0.999996">Robert T Kasper</author>
<affiliation confidence="0.999955">USC/Information Sciences Institute</affiliation>
<address confidence="0.9975535">4676 Admiralty Way, Suite 1001 Marina del Rey, CA 90292</address>
<affiliation confidence="0.891268333333333">and Electrical Engineering and Computer Science Department University of Michigan</affiliation>
<abstract confidence="0.993639428571429">Although disjunction has been used in several unificationbased grammar formalisms, existing methods of unification have been unsatisfactory for descriptions containing large quantities of disjunction, because they require exponential time. This paper describes a method of unification by successive approximation, resulting in better average performance.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="false">
<title>A New Model of Computation Based on a Calculus of Type Subsumption. PhD thesis,</title>
<date>1984</date>
<booktitle>In Proceedings of the Tenth International Conference on Computational Linguistics: COLING 84,</booktitle>
<pages>121</pages>
<editor>13] Kasper, R.</editor>
<institution>University of Pennsylvania,</institution>
<location>Stanford University, Stanford, California,</location>
<marker>1984</marker>
<rawString> [11 Ait-Kaci, H. A New Model of Computation Based on a Calculus of Type Subsumption. PhD thesis, University of Pennsylvania, 1984. 121 Karttunen, L. Features and Values. In Proceedings of the Tenth International Conference on Computational Linguistics: COLING 84, Stanford University, Stanford, California, July 2-7, 1984. 13] Kasper, R. Systemic Grammar and Functional Unification Grammar. In J. Benson and W. Greaves, editors, Systemic Functional Perspectives on Discourse: Selected Papers from the 12`k International Systemics Workshop, Norwood, New Jersey: Ablex (forthcoming). 141 Kasper, R. and W. Rounds. A Logical Semantics for Feature Structures. In Proceedings of the 24th Annual Meeting of the Association for Computational Linguistics, Columbia University, New York, NY, June 10-13, 1986.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Kasper</author>
</authors>
<title>Feature Structures: A Logical Theory with Application to Language Analysis.</title>
<date>1987</date>
<institution>University of Michigan,</institution>
<note>PhD dissertation,</note>
<contexts>
<context position="2229" citStr="[4,5]" startWordPosition="322" endWordPosition="322">aining more than a small number of disjunctions, because the DNF expansion requires an amount of space which is exponential in the number of disjunctions. The second method, developed by Karttunen [2], uses constraints on disjuncts which must be checked whenever a disjunct is modified. Karttunen&apos;s method is only applicable to value disjunctions (i.e. those disjunctions used to specify the value of a single feature), and it becomes complicated and inefficient when disjuncts contain non-local dependencies (i.e. values specified by path expressions denoting another feature). In previous research [4,5] we have shown how descriptions of feature structures can be represented by a certain type of logical formula, and that the consistency problem for disjunctive descriptions is NP-complete. This result indicates, according to the widely accepted mathematical assumption that P NP, that any complete unification algorithm for disjunctive descriptions will require exponential time in the worst case. However, this result does not preclude algorithms with better average performance, such as the method described in the remainder of this paper. This method overcomes the shortcomings of previously exist</context>
</contexts>
<marker>[5]</marker>
<rawString>Kasper, R. Feature Structures: A Logical Theory with Application to Language Analysis. PhD dissertation, University of Michigan, 1987.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Kay</author>
</authors>
<title>Functional Grammar.</title>
<date>1979</date>
<booktitle>In Proceedings of the Fifth Annual Meeting of the</booktitle>
<institution>Berkeley Linguistics Society, Berkeley Linguistics Society,</institution>
<location>Berkeley, California,</location>
<contexts>
<context position="879" citStr="[6]" startWordPosition="114" endWordPosition="114">n has been used in several unificationbased grammar formalisms, existing methods of unification have been unsatisfactory for descriptions containing large quantities of disjunction, because they require exponential time. This paper describes a method of unification by successive approximation, resulting in better average performance. 1 Introduction Disjunction has been used in several unification-based grammar formalisms to represent alternative structures in descriptions of constituents. Disjunction is an essential component of grammatical descriptions in Kay&apos;s Functional Unification Grammar [6], and it has been proposed by Karttunen as a linguistically motivated extension to PATR-II [2]. In previous work two methods have been used to handle disjunctive descriptions in parsing and other computational applications. The first method requires expanding descriptions to disjunctive normal form (DNF) so that the entire description can be interpreted as a set of structures, each of which contains no disjunction. This method is exemplified by Definite Clause Grammar [8], which eliminates disjunctive terms by expanding each rule containing disjunction into alternative rules. It is also the me</context>
</contexts>
<marker>[6]</marker>
<rawString>Kay, M. Functional Grammar. In Proceedings of the Fifth Annual Meeting of the Berkeley Linguistics Society, Berkeley Linguistics Society, Berkeley, California, February 17-19, 1979.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Kay</author>
</authors>
<title>Parsing in Functional Unification Grammar. In</title>
<date>1985</date>
<editor>D. Dowty, L. Karttunen, and A. Zwicky, editors,</editor>
<publisher>Cambridge University Press,</publisher>
<location>Cambridge, England,</location>
<contexts>
<context position="1499" citStr="[7]" startWordPosition="210" endWordPosition="210"> proposed by Karttunen as a linguistically motivated extension to PATR-II [2]. In previous work two methods have been used to handle disjunctive descriptions in parsing and other computational applications. The first method requires expanding descriptions to disjunctive normal form (DNF) so that the entire description can be interpreted as a set of structures, each of which contains no disjunction. This method is exemplified by Definite Clause Grammar [8], which eliminates disjunctive terms by expanding each rule containing disjunction into alternative rules. It is also the method used by Kay [7] in parsing FUG. This method works reasonably well for small grammars, but it is clearly unsatisfactory for descriptions containing more than a small number of disjunctions, because the DNF expansion requires an amount of space which is exponential in the number of disjunctions. The second method, developed by Karttunen [2], uses constraints on disjuncts which must be checked whenever a disjunct is modified. Karttunen&apos;s method is only applicable to value disjunctions (i.e. those disjunctions used to specify the value of a single feature), and it becomes complicated and inefficient when disjunc</context>
</contexts>
<marker>[7]</marker>
<rawString>Kay, M. Parsing in Functional Unification Grammar. In D. Dowty, L. Karttunen, and A. Zwicky, editors, Natural Language Parsing. Cambridge University Press, Cambridge, England, 1985.</rawString>
</citation>
<citation valid="true">
<authors>
<author>F C N Pereira</author>
<author>D H D Warren</author>
</authors>
<title>Definite clause grammars for language analysis — a survey of the formalism and a comparison with augmented transition networks.</title>
<date>1980</date>
<journal>Artificial Intelligence,</journal>
<pages>13--231</pages>
<contexts>
<context position="1355" citStr="[8]" startWordPosition="188" endWordPosition="188"> of constituents. Disjunction is an essential component of grammatical descriptions in Kay&apos;s Functional Unification Grammar [6], and it has been proposed by Karttunen as a linguistically motivated extension to PATR-II [2]. In previous work two methods have been used to handle disjunctive descriptions in parsing and other computational applications. The first method requires expanding descriptions to disjunctive normal form (DNF) so that the entire description can be interpreted as a set of structures, each of which contains no disjunction. This method is exemplified by Definite Clause Grammar [8], which eliminates disjunctive terms by expanding each rule containing disjunction into alternative rules. It is also the method used by Kay [7] in parsing FUG. This method works reasonably well for small grammars, but it is clearly unsatisfactory for descriptions containing more than a small number of disjunctions, because the DNF expansion requires an amount of space which is exponential in the number of disjunctions. The second method, developed by Karttunen [2], uses constraints on disjuncts which must be checked whenever a disjunct is modified. Karttunen&apos;s method is only applicable to val</context>
</contexts>
<marker>[8]</marker>
<rawString>Pereira, F. C. N. and D. H. D. Warren. Definite clause grammars for language analysis — a survey of the formalism and a comparison with augmented transition networks. Artificial Intelligence, 13:231-278, 1980.</rawString>
</citation>
<citation valid="true">
<authors>
<author>W C Rounds</author>
<author>R Kasper</author>
</authors>
<title>A Complete Logical Calculus for Record Structures Representing Linguistic Information.</title>
<date>1986</date>
<booktitle>Symposium on Logic in Computer Science. IEEE Computer Society,</booktitle>
<marker>[9]</marker>
<rawString>Rounds, W. C. and R. Kasper. A Complete Logical Calculus for Record Structures Representing Linguistic Information. Symposium on Logic in Computer Science. IEEE Computer Society, June 16-18, 1986.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S M Shieber</author>
</authors>
<title>The design of a computer language for linguistic information.</title>
<date>1984</date>
<booktitle>In Proceedings of the Tenth International Conference on Computational Linguistics: COLING 84,</booktitle>
<institution>Stanford University,</institution>
<location>Stanford, California,</location>
<marker>[10]</marker>
<rawString>Shieber, S. M. The design of a computer language for linguistic information. In Proceedings of the Tenth International Conference on Computational Linguistics: COLING 84, Stanford University, Stanford, California, July 2-7, 1984.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S M Shieber</author>
</authors>
<title>An Introduction to Unification-based Approaches to Grammar. Chicago:</title>
<date>1986</date>
<booktitle>CSLI Lecture Notes Series,</booktitle>
<publisher>University of Chicago Press,</publisher>
<contexts>
<context position="3425" citStr="[11]" startWordPosition="499" endWordPosition="499">ly existing methods, and has the following desirable properties: 1. It applies to descriptions containing general disjunction and non-local path expressions; 2. It delays expansion to DNF; 3. It can take advantage of fast unification algorithms for non-disjunctive directed graph structures. 2 Data Structures The most common unification methods for non-disjunctive feature structures use a directed graph (DG) representation, in which arcs are labeled by names of features, and nodes correspond to values of features. For an introduction to these methods, the reader is referred to Shieber&apos;s survey [11]. In the remainder of this section we will define a data structure for disjunctive descriptions, using DG structures as a basic component. In the following exposition, we will carefully observe the distinction between feature structures and their descriptions, as explained in [4]. Feature structures will be represented by DGs, and descriptions of feature structures will be represented by logical formulas of the type described in [4]. The 235 NIL denoting no information; TOP denoting inconsistent information; a where a E A, to describe atomic values; I : where I E L and E FDL, to describe struc</context>
</contexts>
<marker>[11]</marker>
<rawString>Shieber, S. M. An Introduction to Unification-based Approaches to Grammar. Chicago: University of Chicago Press, CSLI Lecture Notes Series, 1986.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>