<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<title confidence="0.707362">
COMPUTATIONAL SEMANTICS OF MASS TERMS
</title>
<author confidence="0.942509">
Jan Tore Lonning
</author>
<affiliation confidence="0.9892225">
Department of Mathematics
University of Oslo
</affiliation>
<address confidence="0.5987155">
P.O. Box 1053, Blindem
0316 Oslo 3, Norway
</address>
<sectionHeader confidence="0.820578" genericHeader="abstract">
ABSTRACT
</sectionHeader>
<bodyText confidence="0.999728142857143">
Although the formalisms normally used for describ-
ing the semantics of natural languages are far from
computationally tractable, it is possible to isolate
particular semantic phenomena and interpret them
within simpler formal systems. Quantified mass
noun phrases is one such part. We describe a simple
formal system suitable for the interpretation of
quantified mass noun phrases. The main issue of
this paper is to develop an algorithm for deciding the
validity of sentences in the formal system and hence
for deciding the validity of natural language infer-
ences where all the involved noun phrases are
quantified mass noun phrases. The decision proce-
dure is based on a tableau calculus.
</bodyText>
<sectionHeader confidence="0.998797" genericHeader="introduction">
INTRODUCTION
</sectionHeader>
<bodyText confidence="0.999958138461538">
A formal semantics for a part of a natural language
attempts to describe the truth conditions for sen-
tences, or propositions expressed by sentences, in
model theoretic terms, and thereby also the relation
of valid inferences between sentences. From the
point of view of computational linguistics and natu-
ral language understanding, it is important whether
this relation of entailment can be made computa-
tional. In general, the question must be answered in
the negative. All proposed formal semantics of, say,
English are at least as complex as first order logic
and hence at best semi-decidable, which means that if
a sentence 13 is a logical consequence of a set of sen-
tences E, then there exists a proof for 13 from E, but
no effective way to find such a proof. Several pro-
posals use even more complex logics, like the
higher order intensional logic used in Montague
grammar, which has no deductive theory at all.
We will not oppose to the view that English in-
corporates at least the power of first order logic and
that even more complex formalisms may be needed
to represent the meaning of all aspects of English.
But we believe there are two different possible
strategies when one is to study one particular se-
mantic phenomenon in natural languages. The first
one is to try to interpret the particular phenomenon
into a system that attempts to capture all semantic
aspects of the natural language. The other strategy
is to try to isolate the particular semantic phe-
nomenon one wants to study and to build a semantic
interpretation suited for this particular phenomenon.
By following the latter strategy it might be possible
to find systems simpler than even first order logic
that reflect interesting semantic phenomena, and in
particular to come up with systems that are compu-
tationally tractable.
Quantified mass noun phrases is one such phe-
nomenon that can be easily isolated. The properties
particular for the semantics of quantified mass terms
have been difficult to capture in extensions of sys-
tems already developed for count terms, like first or-
der logic. However, if one isolate the mass terms
and tries to interpret only them, it is possible to
build a model where their typical properties fall out
naturally. We have earlier proposed such a system
and shown it to have a decidable logic (Lonning,
1987). We repeat the key points in the two follow-
ing sections. The main point of this paper is a de-
scription of an algorithm for deciding validity of
sentences and inferences involving quantified mass
terms.
The strategy of isolating parts of a natural lan-
guage and giving it a semantics that can be
computational is of course the strategy underlying
all computational uses of semantics. For example,
in queries towards data bases one disregards all truly
quantified sentences, and use only atomic sentences
and pseudo quantified sentences where e.g. for all
means for all individuals represented in the data base.
The system we present here contains genuine
quantifiers like all water and much water, but contain
other restrictions compared to full first order logic.
In particular the mass quantifiers behave simpler
with respect to scope phenomena than count quanti-
fiers.
</bodyText>
<sectionHeader confidence="0.999479" genericHeader="method">
REPRESENTING QUANTIFIED
MASS NOUNS
</sectionHeader>
<bodyText confidence="0.999859166666667">
We will make use of a very simple formal language
for representing sentences containing quantified mass
nouns, called LM (Lonning, 1987). We refer to the
original paper for motivation of the particular chosen
format and more examples and repeat only the key
points here.
</bodyText>
<listItem confidence="0.9480595">
1. A particular LM language consists of a (non-
empty) set of basic terms, say: water, gold,
- 205 -
blue, hot, boil, disappear ..., and a (possibly
empty) set of non-logical determiners, say:
much, little, less_than_two_kilos_of...
2. Common to all LM languages are the unary
operator: -, the binary operator: ., the logical
determiners: : all, some, and the propositional
connectives: : --,, A, v, -,.
3. A term is either basic or of one of the two
forms (t.$) and (-t) if t and s are terms.
4. An atomic formula has the form D(t)(s) where
D is a determiner and t and s are terms.
5. More complex formulas are built by the
propositional connectives in the usual way.
</listItem>
<bodyText confidence="0.681363">
A model for the particular language is a pair con-
sisting of a Boolean algebra A = &lt;A, +, *, -, 0, 1&gt;
and an interpretation function [I, such that
</bodyText>
<listItem confidence="0.978524">
1. [t] is a member of A for all basic terms t,
2. [D] is a set of pairs of members of A for all
determiners D.
</listItem>
<bodyText confidence="0.661579">
The interpretation of more complex expressions
is then defined as an extension of [ ]:
</bodyText>
<listItem confidence="0.977093857142857">
1. [-t]. -Et], the Boolean complement of [t],
[t•s]=[t]*[s], the Boolean product (or meet) of
[t] and [s].
2. [D(t)(s)] is true provided ([t],[s])E[D], in par-
ticular [All(t)(s)] is true provided [t][s], and
[Some(t)(s)] is true provided [t]*[s] * 0.
3. The propositional part is classical.
</listItem>
<bodyText confidence="0.999927083333333">
To get an intuition of how the semantics work
one can think of [water] as the totality of water in
the world or in the more limited situation one con-
siders, of [blue] as the totality of stuff that is blue
and of [disappear] as the totality of stuff that dis-
appeared. However, one shall not take this picture
too literally since the model works as well for ab-
stract as for concrete mass nouns.
In the formalism, a sentence like (la) is repre-
sented as (lb) and (2a) is represented as (2b) if the
negation is read with narrow scope and as (2c) if the
negation is read with wide scope.
</bodyText>
<listItem confidence="0.9999455">
(1) (a) All hot water is water.
(b)All(hot•water)(water)
(2) (a) Much of the water that disappeared was
not polluted.
(b)Much(waterdisappeared)(-polluted)
(c) -,Much(waterdisappeared)(polluted)
</listItem>
<bodyText confidence="0.999718951219512">
Formula (lb) is a valid LM formula. In general, the
valid English inferences that become valid if a mass
term like water is interpreted as quantities of water
and all water is read as all quantities of water are also
valid under the LM interpretation.
In addition, this approach can explain several
phenomena that are not easily explained on other
approaches. Roeper (1983) pointed out that
paraphrasing water as quantities of water was prob-
lematic when propositional connectives were
considered. If some water disappeared and some did
not disappear, there will be many quantities that
partly disappeared and partly did not disappear. If
disappear denotes the set of all quantities that wholly
disappeared and did not disappear denotes the com-
plement set of this set, then all quantities that partly
disappeared will be members of the denotation of did
not disappear. The sum of quantities that are mem-
bers of the denotation of did not disappear will equal
all the water there is. Roeper solved this problem
by letting the quantities be members of a Boolean
algebra and used a non-standard interpretation of the
negation. In LM it naturally comes out by the
Boolean complement as in (2b) and water that did
not disappear is represented by (water(-disappear)).
A main feature of the current proposal is that it
introduces non-logical quantifiers co-occurring with
mass nouns, like much, little, most,... in a
straightforward way. A sentence like much water
was blue does not say anything about the number of
quantities of blue water, but says something about
the totality of blue water, which is the way it is in-
terpreted in LM.
It might seem a little like cheating that the sys-
tem only introduces interpretations of mass quanti-
fiers with minimal scope with respect to other quan-
tifiers, that it is not possible to interpret one quanti-
fier with scope over another quantifier. In particular,
since this is a main reason to why the logic in the
sequel becomes simple. However, it is characteristic
for mass quantifiers that they get narrow scope.
</bodyText>
<listItem confidence="0.9999675">
(3) (a) A boy ate many pizzas.
(b) A girl drank much water.
</listItem>
<bodyText confidence="0.861975962962963">
While it might be possible to get a reading of (3a)
which involves more than one boy, i.e., one boy for
each pizza, it is not possible to get a reading of (3b)
involving more than one girl.
The only determiners that get a fixed, or logical
interpretation in LM are : all and some. For the
other determiners we can add various sorts of con-
straints on the interpretations that will make more of
the inferences we make in English valid in the logic.
For example, it has been claimed that all natural
language determiners are conservative (or &amp;quot;live
on&amp;quot; their first argument), i.e: (a,b)e [D] if and only
if (a,b*a)e [D] (Barwise and Cooper, 1981).
Several determiners are monotone, either
increasing or decreasing, in one or both argu-
ments, e.g., much is monotone increasing in its
- 206 -
second argument: if (a,b) E [much] and b c then
(a,c) E [much], and less _than_two_kilos_of is
monotone decreasing in its second argument.
Whether an inference like
Much water evaporated.
All that evaporated disappeared..
Hence much water disappeared,
becomes valid in the logic, will depend on whether
the denotation of much is constrained to be mono-
tone increasing in its second argument or not.
</bodyText>
<sectionHeader confidence="0.873342" genericHeader="method">
LOGICAL PROPERTIES
</sectionHeader>
<bodyText confidence="0.99965935">
We will repeat shortly several of the properties of
the logic LM shown in (Lonning, 1987) as a back-
ground for the decision algorithm for validity.
A Hilbert style axiomatization was given and it
was shown that any set of LM sentences consistent
in the logic has a model: the logic is complete and
compact.
It was implicitly shown, but not stated, that any
model for LM must be a Boolean algebra: let a
model be any set A with one unary operation H,
one binary operation [1, and a binary relation [All]
then the model is a Boolean algebra with H the
Boolean complement, [e] the Boolean product (meet)
operation and [All] the ordering 5 on A.
It was also shown that the logic was complete
and compact with respect to the smaller model class:
the atomic Boolean algebras, i.e. any consistent set
of sentences has a model which is an atomic algebra,
and in fact a finite such.
From this, it was shown that LM with no non-
logical determiners, let us call it LA, is equivalent to
a subset of monadic first-order logic, hence it is
decidable. It was also shown that the full LM is
decidable. The argument is based on the fact that the
number of possible models for a sentence is finite
and decidable. This number grows rapidly, however.
Already a sentence in LA with n different basic terms
have 2(2n) different models, so the argument does
not establish a good procedure for checking validity
in practice. We will establish procedures that are
better (in most cases) in the next section.
Several natural restrictions on determiners, like
conservativity and monotonicity can be expressed
completely in LM. It is not surprising that this can
be done for a fixed LM language given the finiteness
of its nature. The more important point is that the
properties can be expressed in a uniform way inde-
pendently of the atomic terms of the language,
which in next section will give rise to uniform in-
ference rules.
</bodyText>
<sectionHeader confidence="0.922127" genericHeader="method">
A DECISION PROCEDURE
</sectionHeader>
<bodyText confidence="0.869146705882353">
We shall establish a procedure for deciding the valid-
ity of LM sentences. The procedure is a combina-
tion of a normal form procedure and a tableau proce-
dure (see e.g. Smullyan, 1968).
We start with an LM formula i.p for which we
want to decide whether it is valid, I 9. This is
equivalent to deciding whether --19 is satisfiable.
One can think of the process as an attempt on build-
ing a model for If we succeed, we have shown
that 9 is not valid and we have found an explicit
counterexample; if we fail, we have shown that 9 is
valid. We assume all propositional connectives in 9
to be basic: A, V.
1. First we introduce a new unary quantifier Null
such that Null(t) is a formula when t is a term. The
meaning is that [Null(t)] is true if and only if [t]=0.
Then substitute
</bodyText>
<equation confidence="0.818566666666667">
Null(t.(—s)) for All(t)(s)
Null(0s) for Some(t)(s)
Null(Ps) for Some(t)(s)
</equation>
<bodyText confidence="0.998161666666667">
This step is not necessary, but it gives a more con-
venient notation to work with and fewer instances to
consider in the sequel. The substitutions correspond
to the fact that Some and Every can be taken to be
unary and the one can be defined from the other, as
in the case with count nouns.
</bodyText>
<listItem confidence="0.743847666666667">
2. Then transform to conjunctive normal form,
that is, a conjunction of disjunctions of literals,
where a literal is an atomic or negated atomic for-
mula.
3. Observe that (i) and (ii) are equivalent.
(i) Aw2A ... Awn
</listItem>
<bodyText confidence="0.826369285714286">
(ii) 1 &apos;ill, w2 ... and &apos;I&apos;n,
Hence we can proceed with each conjunct separately.
4. We shall now check I= wivw2v...v1fn, where
each xiti has the form Null(t), D(t)(s) or
—D(t)(s). Observe that the following two formulas
are equivalent, where ti-s is shorthand for
—((—t).(—s)).
</bodyText>
<listItem confidence="0.878496714285714">
(i) Null(t) v Null(s)
(ii) Null(t+s)
(This corresponds to the equivalence between 3 x9 v
3 xw and 2x(9 v w) in first order logic.) Hence
contract all the literals of the form —Null(t) to one.
5. We are then left with a formula of the form
—Null(OvNull(si)v. ...vNull(sn)vviv ...vwm,
</listItem>
<bodyText confidence="0.998649333333333">
where each wi has the form D(u)(v) or —D(u)(v), for
some non-logical D. First assume that there are no
wes. Then observe that (i) and (ii) are equivalent.
</bodyText>
<equation confidence="0.52446375">
- 207 -
(i) I= -1 Null(t) v Null(si) v ...v Null(sn)
(ii) I -Null(t) v Null(sj) or ... or
1° Null(sn)-
</equation>
<bodyText confidence="0.99575625">
(If there are no si&apos;s proceed with I= Null(t).) This
equivalence might need some argument. That (ii)
entails (i) is propositional logic. For the other way
around, there are two possibilites. Either I--INull(t),
which yields the equivalence. Otherwise, there ex-
ists a model A for the language of 4) where [1=0
and for all other terms s in the language: [s]:=0 if
and only if All(s)(t) is a valid formula. Let Ni be the
formula -INull(t) v Null(si) v v Null(s).
Then Ay is valid if and only if NJ is true in A. To
show this, it is sufficient to show that if there is a
model B in which is not true then xv is not true in
A. If B is a model in which Ni is not true, then
[0=0 and each [siDt0 in B. Hence All(si)(t) cannot
be valid and [si]*0 in A for each si. Since [1]=0 in
A, Ni cannot be true in A. The same type of argu-
ment yields that -Null(t) v Null(si) is valid if and
only if it is true in A . If we write A ri for 71 is
true in A, the following equivalence is propositional
logic and yields the equivalence above.
</bodyText>
<figure confidence="0.557479666666667">
(i) A Null(t)v Null(si) v ...v Null(sn)
(ii) A I- Null(t) v Null(si) or ... or
A Null(t) v Null(sn).
</figure>
<figureCaption confidence="0.368954857142857">
6. a. We shall describe two different ways for
checking I= -,Null(t)v Null(si). The first one pro-
ceeds by a transformation to normal form and may
be the easiest one to understand if one is not accus-
tomed to tableau calculus. The second one which
uses a tableau approach is more efficient. First ob-
serve that (i) and (ii) are equivalent.
</figureCaption>
<figure confidence="0.29076575">
(i) Null(t)v Null(si)
(ii) Null((-0..si), (i.e. All(si)(t)).
The last claim entails the first one since
Null((-0.4) -&gt;
</figure>
<bodyText confidence="0.998611470588235">
is a valid LM-formula. To see that (ii) entails (i)
observe that if -INull(OvNull(si) is valid, it will in
particular be true in the model A described in step 5,
hence 1= All(si)(t).
To check I&amp;quot;Null ((-0-Si) rewrite the term (-0.si in
disjunctive normal form: allow the symbol + and
write the term on the form si+...+sm where each si
has the form u i• ... • uk and each uj is either an
atomic term or on the form -v for an atomic term v.
Then Null(si+...+sm) if and only if Null(s1)
and ... and I-Null(sm), and I-Null(up....uk) if and
only if there is a v such that one uj equals v and an-
other uj equals -v.
b. The checking of -iNull(t)vNull(si) will be
faster using a tableau procedure instead of rewriting
to normal form. Note that the following are equiva-
lent:
</bodyText>
<figure confidence="0.880863">
v Null(si)
Null((-Ossi)
-,Null(t-i-(-si))
</figure>
<bodyText confidence="0.956328173913043">
There is a close connection between propositional
logic and Boolean algebras. To each term in LM, t,
there corresponds a formula pt in pure propositional
logic such that -,Nu//(t) is valid in LM if and only if
the corresponding formula pt is a tautology: shift
each basic LM term t with a corresponding proposi-
tional constant pt, and exchange - with * with A,
and + with v. In particular, the following are
equivalent
-iNull(t+(-s)) (in LM)
(pt v(-psi)) (in propositional logic)
(By the earlier mentioned connection between LM
and first order logic this corresponds to the fact that a
first order formula 3x9 is valid if and only if cp is a
tautology whenever q) is quantifier free.)
Step (6a) above is equivalent to checking this
latter formula for validity by transformation to a
normal form. Instead it can be checked by a standard
tableau procedure (see e.g. Smullyan 1968).
We give a short description of the tableau ap-
proach to propositional logic. In order to verify a
formula iv, we try to build a model that falsifies it.
To ease the description we assume that Ni is on
negation normal form, that is, built up from literals
by A, v. The attempt to build a model is done by
building a tree for Nr. We start with a root node de-
picted by xv and use the following two rules:
1. For each node a depicted by a formula of the
form y v 11 attach to each leaf below a in the
tree constructed so far one successor node b de-
picted by y and one successor node c to b de-
picted by
2. For each node a depicted by a formula of the
form y A n attach to each leaf below a in the
tree constructed so far two new leaf nodes one
depicted by y and another one depicted by n.
The tree is complete when all formulas of the
forms y v r and y A fl are reduced according to the
rules above. A branch in a tree is called closed if
there is a formula y such that one node along the
branch is depicted by y and another node along the
branch is depicted by -17. A branch in a complete
tree for Ni which is not closed describes a valuation
that falsifies Ni. Conversely, if all branches in a
complete tree for Ni are closed, Ni is valid. We illus-
trate with an example:
</bodyText>
<equation confidence="0.990322833333333">
- 208 -
pv qA (p r))v (r A q)
--,qA(pv—a)
(r A q)
cl
r q
</equation>
<bodyText confidence="0.999258125">
The sign # indicates that a branch is closed. We
have not completed the rightmost branch since it is
already closed. Since there is one open branch in the
tree, the formula is not valid. The literals along the
open branch: --,p, r shows that any valuation V
such that V(p) = T, V(q) = T, V(r) = 1, falsifies v.
The strategy in step (6a) above with transforma-
tion to normal form corresponds to construction of
separate copies for each branch, hence duplicating
parts of the tree, while the tableau procedure exploits
the possibility of structure sharing.
Returning to our main point, we can observe one
additional gain by using the tableau approach. Our
goal is to check whether --Jslull(t)vNull(si) or, ...
or 1= --Null(t)vNull(sn), which is equivalent to check
whether (tv(--01)) or ...,or (tv(-4sn)) is a tautology.
The part of the tableau tree that corresponds to t can
be constructed (and if possible reduced by removing
closed branches) once and for all, and then be reused
with all the different si&apos;s.
7. We now return to step 5 and consider the case
where one or more disjuncts have the form D(u)(v)
or —,D(u)(v), for some non-logical D. Then the
following are equivalent.
</bodyText>
<equation confidence="0.641158">
(i) 1= —Null(OvN ull(spv ...vN ull(sn)vyt iv yin
</equation>
<bodyText confidence="0.968220272727273">
(01- —Null(OvNull(si) for some i, 1 5 i n, or
—Nu/l(t)vvkvvj for some k and j between 1
and m, where xi/ has the form D(a)(b) and vj
has the form --,D(u)(v) for the same determiner
D.
That (ii) entails (i) is immediate. For the other way
around, suppose that (ii) does not hold. We shall
then construct a model which falsifies the original
formula in (i). Let A be the model where only
terms provably less than t denote 0 and where a pair
([d],[e]) is a member of [D] if and only if —,D(d)(e)
is one of the disjuncts vi&apos;s. By the construction, A
will falsify --Null(t) and each disjunct of the form
-43(d)(e). As in step 5 above, A will falsify each
Null(si). It remains to show that A falsifies each
disjunct of the form D(a)(b). Let? be one such dis-
junct, let lj. 1 j s, be all the disjuncts of the
form —,D(d)(e) with the same determiner D as in y
and let ej be —1■Tu//(t)vyvnj. Since (ii) does not
hold, there exists a model B) where ei is false, for
each ej. Then there also exists a model Aj which
equals A except possibly for the interpretation of D,
and where D gets the same interpretation as in Bj.
Hence ej is false in Aj. Since there exists such an
A • for each e• y cannot be true in A.
J
8. Whether 1= --Null(t)vD(a)(b)v—,D(u)(v) holds,
depends on which restrictions are put on D. With no
restrictions, any possible counterexample is one
where [t]=0, ([u],[v])E [D] while ([a],[b]) [D] .
The only reason we should not be able to construct
such a model is that [a] =[u] and[b] =[v] whenever
[t] =O. We can hence proceed to check
</bodyText>
<equation confidence="0.9756815">
1= —Null(t) v
(Null((—a•u)+(a•—u)) A Null((—b•v)+(b•—v))),
</equation>
<bodyText confidence="0.997801714285714">
according to the same procedures as in step 6 above.
If we have the additional constraint that the de-
terminer in question is conservative, the last rule is
changed such that the last conjunct, which above
stated that the symmetric difference between b and v
was zero, now instead states that the symmetric dif-
ference between ab and ten/ is zero.
</bodyText>
<equation confidence="0.970914">
—Null(t) v (Null((—a•u)+(a•--u)) A
Null((—(a.b).v)+((a-b).—v)))
</equation>
<bodyText confidence="0.9782578">
Similarly, if we know that the determiner is up-
wards monotone in its second argument
D(a)(b)v—ID(u)(v) has to be true in any model where
(a]=[u] and [v]5.[b], so the last conjunct will be
Null((—b•v)) instead of Nulla—b•v)+(b•—v)). If the
determiner is restricted to be both conservative and
monotone, the last conjunct shall be
Null((—(a.b).u.v)). Similar modifications of the rule
can be done for determiners with other forms of
monotone behaviour.
</bodyText>
<sectionHeader confidence="0.858838" genericHeader="method">
GENERALIZED QUANTIFIERS
</sectionHeader>
<bodyText confidence="0.94471125">
One main feature of the decision procedure is that it
incorporates generalized quantifiers (step 7 and 8).
The rules for generalized quantifiers correspond to
axioms one will use in an axiomatization of LM.
For example, the rule for quantifiers with no addi-
tional constraints correspond to the extensionality
schemata:
For all terms a, b, u, v:
</bodyText>
<equation confidence="0.275933">
(All(a)(u) A All(u)(a)) (D(a)(b) D(u)(b))
(All(b)(v) A All(v)(b)) -4 (D(a)(b) D(a)(v))
</equation>
<bodyText confidence="0.9670169375">
One should remember that we do not try to develop a
logic for the strong logical interpretation of deter-
miners like most, but a logic for some minimal
constraints that interpretations of the determiners
should at least satisfy.
pvFr
- 209 -
Just like there is a meaning preserving translation
from LA into first order logic, LM can be translated
into first order logic extended with generalized quan-
tifiers. A proof procedure for first order logic, like a
tableau or a sequent calculus, can be extended with
rules for generalized quantifiers similar to the rules
introduced here. If Q is a binary quantifier with no
additional constraints on its interpretation then the
following are equivalent.
</bodyText>
<equation confidence="0.3744985">
(i) Qx(A(x),8(x)) v —.Qx(C(x),D(x))
(ii) Vx(A(x) COO) A Vx(B(x) &lt;—&gt; D(x))
</equation>
<bodyText confidence="0.9998052">
So to show that (i) is valid one has to show that (ii)
is valid. This can be incorporated into a tableau or
sequent calculus for first order logic. If the first or-
der logic is monadic, as the logic we get after trans-
lating LM into first order logic is, one can use a
similar procedure as the one described here. If the
extended first order logic is not monadic, the proce-
dure one gets when rules corresponding to the reduc-
tion from (i) to (ii) are included, becomes more
complex.
</bodyText>
<sectionHeader confidence="0.993446" genericHeader="method">
EFFICIENCY
</sectionHeader>
<bodyText confidence="0.999995045454545">
We chose to transform the formula being tested to
normal form early in the procedure (step 2).
Alternatively to the described algorithm one could
think of using a tableau procedure all the way, and
not first transform to conjunctive normal form in
step 2. In general, transformation to normal form is
slower than using a tableau procedure (cf. step 6
above). The reason we made the transformation to
normal form was that this was necessary to split the
formula in step 5 and step 7. In the procedure one
gets by translating LM into first order logic (with
generalized quantifiers) and using a tableau procedure
from the start, it is not possible to split the tree
similarly. If we for simplicity considers a formula
with no generalized quantifiers, the pure tableau cal-
culus will not lead to a separate tree for each si to-
gether with t but to one big tree containing all the
si&apos;s and roughly one copy of t for each si. This cor-
responds to the quantifier rules in a tableau calculus
for first order logic: (i) for each formula of the form
V x. introduce one new formula 4)(a) where a is
some new term, (ii) for each formula 3xv introduce
one new formula v(a) for each term a introduced in
the tree at a branch to which 3xv belongs. The
successful separation in the described algorithm here
will also be possible in a proof procedure for
monadic first order logic.
The two different procedures will be of the same
time complexity in worst cases. In the practical ap-
plications we have in mind, the procedure described
here will be faster. Typically we want to check
whether a formula 0 follows from a ,...,an. This
is the same as deciding whether --tt1v—v--ianv0 is
valid or not. The transformation to normal form
will produce one additional copy for each v within
an ai and each A within 0. If each ai and 13 are LM
formulas that represent English sentences, they can
each be expected to be relatively short and in
particular not contain many v&apos;s, so the number of
copies made will be relatively small. On the other
hand, the number of ai&apos;s may be large if they repre-
sent the dialogue so far or the agent&apos;s knowledge. It
is therefore important that each disjunct can be split
up as much as possible.
</bodyText>
<sectionHeader confidence="0.998157" genericHeader="method">
IMPLEMENTATION
</sectionHeader>
<bodyText confidence="0.999801868421052">
The inference algorithm has been implemented in
PROLOG. To test it out we have built a small (toy)
natural language question-answering-system around
it. The program reads in simple sentences and ques-
tions from the terminal and answers the questions.
It can handle simple statements, like If some of the
hot coffee that did not disappear was black then
much gold is valuable (the fragment in Lonning
1987) and yes/no questions like Did much water
evaporate? and Was the old gold that disappeared
valuable? We have written the grammar and transla-
tion to LM in the built in DCG rules (Pereira and
Warren, 1980).
Statements typed on the terminal are interpreted
as facts about the world and stored as simple sen-
tences 41_,...4n. When a question like Did much
water evaporate? is asked, it is parsed and turned into
a formula like v: Much(water)(evaporate). Then the
program proceeds to check the validity of
(OA A0n) --+ v. If it is valid, the program an-
swers yes, otherwise it checks (4)1A...A0n) -4
If this is valid, the answer is no, otherwise the pro-
gram answers that it does not know. When a state-
ment is made the program checks whether it is con-
sistent with what the program already knows before
it is added to the knowledgebase.
The system is mainly made to test the inference
algorithm and is not meant as an application by it-
self. But it illustrates some general points. It is a
system where natural language inferences are made
from natural language sentences and not from a fixed
database. The system contains a complete treatment
of propositional logic and illustrates a sound treat-
ment of negation where failure is treated as does not
know instead of negation. On the other hand, there
is also a price to pay for incorporating full proposi-
tional logic. The system can only handle examples
of a limited size in reasonable time.
</bodyText>
<sectionHeader confidence="0.999477" genericHeader="conclusions">
CONCLUSION
</sectionHeader>
<bodyText confidence="0.994615217391305">
We have here presented a computational approach to
the semantics of quantified mass noun phrases. We
think the semantics ascribed to quantified mass
- 210 -
nouns through a translation into LM is the one that
most adequately reflects their particular semantic
properties. In addition this semantics can be made
computational in a way not possible for other ap-
proaches to the semantics of mass terms, like Bunt&apos;s
(1985) which extends axiomatic set theory, or
Link&apos;s approach (1983) based on Montague&apos;s higher-
order intensional logic.
We have modified and adapted a tableau calculus
to be used with mass terms and extended it with
generalized quantifiers. Although the imple-
mentation we have made is of limited applicability,
we hope that the algorithm can be used to incorpo-
rate quantified mass noun phrases into larger systems
treating count terms. In particular, it should be
possible to combine the algorithm with other ap-
proaches based on a tableau calculus, like the one
described by Guenthner, Lehmann and Schtinfeld
(1986).
</bodyText>
<sectionHeader confidence="0.99968" genericHeader="references">
REFERENCES
</sectionHeader>
<reference confidence="0.98868737037037">
Barwise, J. and R. Cooper: 1981, &apos;Generalized
Quantifiers and Natural Language&amp;quot;, Linguis-
tics and Philosophy, 4, 159-219.
Bunt, H.: 1985, Mass terms and model-theoretic
semantics, Cambridge University Press,
Cambridge.
Guenthner, F., H. Lehmann and W. SchOnfeld:
1986,`A theory for the representation of
knowledge&apos;, IBM J. Res. Develop. 30, 39-
56.
Link, G.:1983,&amp;quot;The Logical Analysis of Plurals and
Mass terms: A Lattice-Theoretical Approach&apos;,
in BAuerle et al. (eds.), Meaning, Use, and In-
terpretation of Language, Walter de Gruyter,
Berlin.
14/inning, J.T.:1987,`Mass Terms and Quantifica-
tion&apos;, Linguistics and Philosophy, 10, 1-52.
Pereira, F.C.N. and D.H.D. Warren: 1980, &apos;Definite
Clause Grammars for Language Analysis — A
Survey of the Formalism and a Comparison
with Augmented Transition Networks&apos;,
Artificial Intelligence 13, 231-278.
Roeper, R.:1983,`Semantics for Mass terms with
Quantifiers&apos;, Nous, 17, 251-265.
Smullyan, R.M.:1968, First-Order Logic, Springer,
New York.
- 211 -
</reference>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.967836">
<title confidence="0.998858">COMPUTATIONAL SEMANTICS OF MASS TERMS</title>
<author confidence="0.999674">Jan Tore Lonning</author>
<affiliation confidence="0.999359">Department of Mathematics University of Oslo</affiliation>
<address confidence="0.997526">P.O. Box 1053, Blindem 0316 Oslo 3, Norway</address>
<abstract confidence="0.998340466666667">Although the formalisms normally used for describing the semantics of natural languages are far from computationally tractable, it is possible to isolate particular semantic phenomena and interpret them within simpler formal systems. Quantified mass noun phrases is one such part. We describe a simple formal system suitable for the interpretation of quantified mass noun phrases. The main issue of this paper is to develop an algorithm for deciding the validity of sentences in the formal system and hence for deciding the validity of natural language inferences where all the involved noun phrases are phrases. The decision procedure is based on a tableau calculus.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>J Barwise</author>
<author>R Cooper</author>
</authors>
<title>Generalized Quantifiers and Natural Language&amp;quot;,</title>
<date>1981</date>
<journal>Linguistics and Philosophy,</journal>
<volume>4</volume>
<pages>159--219</pages>
<contexts>
<context position="9170" citStr="Barwise and Cooper, 1981" startWordPosition="1555" endWordPosition="1558"> possible to get a reading of (3a) which involves more than one boy, i.e., one boy for each pizza, it is not possible to get a reading of (3b) involving more than one girl. The only determiners that get a fixed, or logical interpretation in LM are : all and some. For the other determiners we can add various sorts of constraints on the interpretations that will make more of the inferences we make in English valid in the logic. For example, it has been claimed that all natural language determiners are conservative (or &amp;quot;live on&amp;quot; their first argument), i.e: (a,b)e [D] if and only if (a,b*a)e [D] (Barwise and Cooper, 1981). Several determiners are monotone, either increasing or decreasing, in one or both arguments, e.g., much is monotone increasing in its - 206 - second argument: if (a,b) E [much] and b c then (a,c) E [much], and less _than_two_kilos_of is monotone decreasing in its second argument. Whether an inference like Much water evaporated. All that evaporated disappeared.. Hence much water disappeared, becomes valid in the logic, will depend on whether the denotation of much is constrained to be monotone increasing in its second argument or not. LOGICAL PROPERTIES We will repeat shortly several of the p</context>
</contexts>
<marker>Barwise, Cooper, 1981</marker>
<rawString>Barwise, J. and R. Cooper: 1981, &apos;Generalized Quantifiers and Natural Language&amp;quot;, Linguistics and Philosophy, 4, 159-219.</rawString>
</citation>
<citation valid="true">
<authors>
<author>H Bunt</author>
</authors>
<title>Mass terms and model-theoretic semantics,</title>
<date>1985</date>
<publisher>Cambridge University Press,</publisher>
<location>Cambridge.</location>
<marker>Bunt, 1985</marker>
<rawString>Bunt, H.: 1985, Mass terms and model-theoretic semantics, Cambridge University Press, Cambridge.</rawString>
</citation>
<citation valid="false">
<authors>
<author>F Guenthner</author>
<author>H Lehmann</author>
<author>W SchOnfeld</author>
</authors>
<title>1986,`A theory for the representation of knowledge&apos;,</title>
<journal>IBM J. Res. Develop.</journal>
<volume>30</volume>
<pages>39--56</pages>
<marker>Guenthner, Lehmann, SchOnfeld, </marker>
<rawString>Guenthner, F., H. Lehmann and W. SchOnfeld: 1986,`A theory for the representation of knowledge&apos;, IBM J. Res. Develop. 30, 39-56.</rawString>
</citation>
<citation valid="false">
<authors>
<author>Link</author>
</authors>
<title>G.:1983,&amp;quot;The Logical Analysis of Plurals and Mass terms: A Lattice-Theoretical Approach&apos;,</title>
<booktitle>Meaning, Use, and Interpretation of Language, Walter de Gruyter,</booktitle>
<editor>in BAuerle et al. (eds.),</editor>
<location>Berlin.</location>
<marker>Link, </marker>
<rawString>Link, G.:1983,&amp;quot;The Logical Analysis of Plurals and Mass terms: A Lattice-Theoretical Approach&apos;, in BAuerle et al. (eds.), Meaning, Use, and Interpretation of Language, Walter de Gruyter, Berlin.</rawString>
</citation>
<citation valid="false">
<authors>
<author>14inning</author>
</authors>
<title>J.T.:1987,`Mass Terms and Quantification&apos;,</title>
<journal>Linguistics and Philosophy,</journal>
<volume>10</volume>
<pages>1--52</pages>
<marker>14inning, </marker>
<rawString>14/inning, J.T.:1987,`Mass Terms and Quantification&apos;, Linguistics and Philosophy, 10, 1-52.</rawString>
</citation>
<citation valid="true">
<authors>
<author>F C N Pereira</author>
<author>D H D Warren</author>
</authors>
<title>Definite Clause Grammars for Language Analysis — A Survey of the Formalism and a Comparison with Augmented Transition Networks&apos;,</title>
<date>1980</date>
<journal>Artificial Intelligence</journal>
<volume>13</volume>
<pages>231--278</pages>
<contexts>
<context position="26639" citStr="Pereira and Warren, 1980" startWordPosition="4709" endWordPosition="4712">e. IMPLEMENTATION The inference algorithm has been implemented in PROLOG. To test it out we have built a small (toy) natural language question-answering-system around it. The program reads in simple sentences and questions from the terminal and answers the questions. It can handle simple statements, like If some of the hot coffee that did not disappear was black then much gold is valuable (the fragment in Lonning 1987) and yes/no questions like Did much water evaporate? and Was the old gold that disappeared valuable? We have written the grammar and translation to LM in the built in DCG rules (Pereira and Warren, 1980). Statements typed on the terminal are interpreted as facts about the world and stored as simple sentences 41_,...4n. When a question like Did much water evaporate? is asked, it is parsed and turned into a formula like v: Much(water)(evaporate). Then the program proceeds to check the validity of (OA A0n) --+ v. If it is valid, the program answers yes, otherwise it checks (4)1A...A0n) -4 If this is valid, the answer is no, otherwise the program answers that it does not know. When a statement is made the program checks whether it is consistent with what the program already knows before it is add</context>
</contexts>
<marker>Pereira, Warren, 1980</marker>
<rawString>Pereira, F.C.N. and D.H.D. Warren: 1980, &apos;Definite Clause Grammars for Language Analysis — A Survey of the Formalism and a Comparison with Augmented Transition Networks&apos;, Artificial Intelligence 13, 231-278.</rawString>
</citation>
<citation valid="false">
<authors>
<author>Roeper</author>
</authors>
<title>R.:1983,`Semantics for Mass terms with Quantifiers&apos;,</title>
<journal>Nous,</journal>
<volume>17</volume>
<pages>251--265</pages>
<marker>Roeper, </marker>
<rawString>Roeper, R.:1983,`Semantics for Mass terms with Quantifiers&apos;, Nous, 17, 251-265.</rawString>
</citation>
<citation valid="false">
<authors>
<author>R M Smullyan</author>
</authors>
<title>First-Order Logic,</title>
<publisher>Springer,</publisher>
<location>New York.</location>
<marker>Smullyan, </marker>
<rawString>Smullyan, R.M.:1968, First-Order Logic, Springer, New York.</rawString>
</citation>
<citation valid="false">
<pages>211</pages>
<marker></marker>
<rawString>- 211 -</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>