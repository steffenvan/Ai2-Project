<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<note confidence="0.713348">
Proceedings of EACL &apos;99
</note>
<title confidence="0.995868">
Tabular Algorithms for TAG Parsing
</title>
<author confidence="0.987996">
Miguel A. Alonso
</author>
<affiliation confidence="0.8732475">
Departamento de Computacion
Univesidad de La Coruna
</affiliation>
<address confidence="0.794965666666667">
Campus de Elviria s/n
15071 La Coruna
SPAIN
</address>
<email confidence="0.993832">
alonso@dc.fi.udc.es
</email>
<author confidence="0.878449">
Eric de la Clergerie
</author>
<affiliation confidence="0.6270105">
INRIA
Domaine de Voluceau
</affiliation>
<address confidence="0.640318666666667">
Rocquencourt, B.P. 105
78153 Le Chesnay Cedex
FRANCE
</address>
<email confidence="0.979178">
Eric.De_La_Clergerie@inria.fr
</email>
<sectionHeader confidence="0.992546" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999552375">
We describe several tabular algorithms
for Tree Adjoining Grammar parsing,
creating a continuum from simple pure
bottom-up algorithms to complex pre-
dictive algorithms and showing what
transformations must be applied to each
one in order to obtain the next one in the
continuum.
</bodyText>
<sectionHeader confidence="0.998989" genericHeader="introduction">
1 Introduction
</sectionHeader>
<bodyText confidence="0.999009263157895">
Tree Adjoining Grammars are a extension of CFG
introduced by Joshi in (Joshi, 1987) that use
trees instead of productions as the primary rep-
resenting structure. Several parsing algorithms
have been proposed for this formalism, most of
them based on tabular techniques, ranging from
simple bottom-up algorithms (Vijay-Shanker and
Joshi, 1985) to sophisticated extensions of the
Earley&apos;s algorithm (Schabes and Joshi, 1988; Sch-
abes, 1994; Nederhof, 1997). However, it is diffi-
cult to inter-relate different parsing algorithms. In
this paper we study several tabular algorithms for
TAG parsing, showing their common characteris-
tics and how one algorithm can be derived from
another in turn, creating a continuum from simple
pure bottom-up to complex predictive algorithms.
Formally, a TAG is a 5-tuple G =
(vN, VT, S, I, A), where VN is a finite set of
non-terminal symbols, VT a finite set of terminal
</bodyText>
<figure confidence="0.899679857142857">
David Cabrero
Departamento de Computacion
Univesidad de La Coruria
Campus de Elviria s/n
15071 La Coruna
SPAIN
cabrero@dc.fi.udc.es
Manuel Vilares
Departamento de Computacion
Univesidad de La Coruna
Campus de Elvifia s/n
15071 La Coruna
SPAIN
vilares@dc.fi.udc.es
</figure>
<bodyText confidence="0.99979003125">
symbols, S the axiom of the grammar, I a finite
set of initial trees and A a finite set of auxiliary
trees. /UA is the set of elementary trees. Internal
nodes are labeled by non-terminals and leaf nodes
by terminals or e, except for just one leaf per
auxiliary tree (the foot) which is labeled by the
same non-terminal used as the label of its root
node. The path in an elementary tree from the
root node to the foot node is called the spine of
the tree.
New trees are derived by adjoining: let a be a
tree containing a node Nc&apos; labeled by A and let
,3 be an auxiliary tree whose root and foot nodes
are also labeled by A. Then, the adjoining of )3
at the adjunction node IV is obtained by excising
the subtree of a with root Na, attaching )3 to N&amp;quot;
and attaching the excised subtree to the foot of O.
We use 3 E adj(N&amp;quot;) to denote that a tree )3 may
be adjoined at node N&apos; of the elementary tree a.
In order to describe the parsing algorithms for
TAG, we must be able to represent the partial
recognition of elementary trees. Parsing algo-
rithms for context-free grammars usually denote
partial recognition of productions by dotted pro-
ductions. We can extend this approach to the case
of TAG by considering each elementary tree -y as
formed by a set of context-free productions P(-y):
a node N1&apos; and its children N7 . . /V; arerepre-
sented by a production N&apos;Y N. Thus,
the position of the dot in the tree is indicated by
the position of the dot in a production in P(-y).
The elements of the productions are the nodes of
</bodyText>
<page confidence="0.995468">
150
</page>
<bodyText confidence="0.97214325">
Proceedings of EACL &apos;99
the tree, except for the case of elements belonging
to VT U {e} in the right-hand side of production.
Those elements may not have children and are not
candidates to be adjunction nodes, so we identify
such nodes labeled by a terminal with that termi-
nal.
To simplify the description of parsing algo-
rithms we consider an additional production T
11°` for each initial tree and the two additional pro-
ductions T RO and Pa 1 for each auxiliary
tree 0, where RP and FI3 correspond to the root
node and the foot node of 13, respectively. After
disabling T and 1 as adjunction nodes the gener-
ative capability of the grammars remains intact.
The relation = of derivation on 7)(7) is de-
</bodyText>
<equation confidence="0.9485065">
fined by 6 v if there are 6&apos; , .5&amp;quot; , M, v such that
6 = 6&apos; M76&amp;quot; , v = 8&apos; vo&amp;quot; and MI&apos; E &apos;P(-y) ex-
</equation>
<bodyText confidence="0.990014833333333">
ists. The reflexive and transitive closure of = is
denoted 3 .
In a abuse of notation, we also use 3 to rep-
resent derivations involving an adjunction. So,
6 3 v if there are 5&apos;, 5&amp;quot;, M7, v such that 6 =
6&apos; M-Y (5&amp;quot; , R 3 viV v3, E adj(M7), 11(7 v2
and v = Yvi v2v36&amp;quot; .
Given two pairs (p, q) and (i, j) of integers,
(p, q) &lt; (i, j) is satisfied if i &lt;p and q &lt; j . Given
two integers p and q we define p U q as p if q is un-
defined and as q if p is undefined, being undefined
in other case.
</bodyText>
<subsectionHeader confidence="0.999446">
1.1 Parsing Schemata
</subsectionHeader>
<bodyText confidence="0.99966309375">
We will describe parsing algorithms using Parsing
Schemata, a framework for high-level description
of parsing algorithms (Sikkel, 1997). An interest-
ing application of this framework is the analysis of
the relations between different parsing algorithms
by studying the formal relations between their un-
derlying parsing schemata. Originally, this frame-
work was created for context-free grammars but
we have extended it to deal with tree adjoining
grammars.
A parsing system for a grammar G and string
al a„ is a triple (1,7-1, D), with I a set of items
which represent intermediate parse results, 74 an
initial set of items called hypothesis that encodes
the sentence to be parsed, and D a set of deduc-
tion steps that allow new items to be derived from
already known items. Deduction steps are of the
form 711-7/k cod, meaning that if all antecedents
Th of a deduction step are present and the con-
ditions cond are satisfied, then the consequent e
should be generated by the parser. A set .T C I of
final items represent the recognition of a sentence.
A parsing schema is a parsing system parameter-
ized by a grammar and a sentence.
Parsing schemata are closely related to gram-
matical deduction systems (Shieber et al., 1995),
where items are called formula schemata, deduc-
tion steps are inference rules, hypothesis are ax-
ioms and final items are goal formulas.
A parsing schema can be generalized from
another one using the following transforma-
tions (Sikkel, 1997):
</bodyText>
<listItem confidence="0.998553">
• Item refinement, breaking single items into
multiple items.
• Step refinement, decomposing a single deduc-
tion step in a sequence of steps.
• Extension of a schema by considering a larger
class of grammars.
</listItem>
<bodyText confidence="0.947058333333333">
In order to decrease the number of items and
deduction steps in a parsing schema, we can apply
the following kinds of filtering:
</bodyText>
<listItem confidence="0.9997456">
• Static filtering, in which redundant parts are
simply discarded.
• Dynamic filtering, using context information
to determine the validity of items.
• Step contraction, in which a sequence of de-
</listItem>
<bodyText confidence="0.9480885">
duction steps is replaced by a single one.
The set of items in a parsing system PAig cor-
responding to the parsing schema Alg describing
a given parsing algorithm Alg is denoted &apos;mg, the
set of hypotheses 7/Aig, the set of final items .TAlg
and the set of deduction steps is denoted Dmg
</bodyText>
<sectionHeader confidence="0.749007" genericHeader="method">
2 A CYK-like Algorithm
</sectionHeader>
<bodyText confidence="0.99952525">
We have chosen the CYK-like algorithm for TAG
described in (Vijay-Shanker and Joshi, 1985) as
our starting point. Due to the intrinsic limitations
of this pure bottom-up algorithm, the grammars
it can deal with are restricted to those with nodes
having at most two children.
The tabular interpretation of this algorithm
works with items of the form
</bodyText>
<equation confidence="0.618503">
j I p,q I adj]
</equation>
<bodyText confidence="0.8892856">
such that N 3 ai+i ...a, F-Y aq+1...ai
a,±1 ...ai if and only if (p, q) (— , —) and N&apos;Y
ai if and only if (p, q) = (— , —), where
1\71&apos; is a node of an elementary tree with a label
belonging to VN.
The two indices with respect to the input string
i and j indicate the portion of the input string that
has been derived from N. If 7 E A, p and q are
two indices with respect to the input string that
indicate that part of the input string recognized
</bodyText>
<page confidence="0.994857">
151
</page>
<bodyText confidence="0.970123838709677">
Proceedings of EACL &apos;99
by the foot node of -y. In other case p = q = —
representing they are undefined. The element adj
indicates whether adjunction has taken place on
node N.
.
The introduction of the element adj taking its
value from the set {true, false) corrects the items
previously proposed for this kind of algorithms
in (Vijay-Shanker and Joshi, 1985) in order to
avoid several adjunctions on a node. A value of
true indicates that an adjunction has taken place
in the node N7 and therefore further adjunctions
on the same node are forbidden. A value of false
indicates that no adjunction was performed on
that node. In this case, during future processing
this item can play the role of the item recognizing
the excised part of an elementary tree to be at-
tached to the foot node of an auxiliary tree. As a
consequence, only one adjunction can take place
on an elementary node, as is prescribed by the
tree adjoining grammar formalism (Schabes and
Shieber, 1994). As an additional advantage, the
algorithm does not need to require the restriction
that every auxiliary tree must have at least one
terminal symbol in its frontier (Vijay-Shanker and
Joshi, 1985).
Schema 1 The parsing systems PCYK corre-
sponding to the CYK-line algorithm for a tree ad-
joining grammar G and an input string al . • • an
is defined as follows:
</bodyText>
<equation confidence="0.955772">
IcyK = { j I p,q I adj] }
</equation>
<bodyText confidence="0.67525">
such that N7 E P(7), label(N7) EVN, 1,E/1J
A, 0 &lt; i &lt;j, (p,q) &lt; (i, j), adj E {true, false}
</bodyText>
<equation confidence="0.997145727272727">
WCYK { [a,i-1,i]la=ai,1&lt;i&lt;n }
[a, — 1,i]
N7 -4 a
DScan
CYK [N-y 1,i I — I false]
Vt:YK = [N- ,i,i — I false] N7 -4 E
Dr;Vt
&lt;i =
[F7 j I j false]
,i,k I p,q I adj],
D =LeftDorn , k, j — adj]
CYK [N-r,i,j I p,q I false]
such that N7 M7 P7 E P(-y), M7 E spine(7)
Kr,i,k — I adj],
RightDom tP7, k, j I p, q I adj]
DCYK j I p,q I false]
such that N7 -4 M7 P7 E P (-y), P7 E spine(7)
[M7 ,i,k — adj],
[P7,k,i I —,—I adj]
[N-Y j I — I false]
such that N7 -4 M7 P7 E P(7), .11P ,
spine(-y)
DgryTY = [M7 1i) I p,q adj] adj]
[1V-Y j I p,q I false] N E - PeY)
[RP , j&apos; I i,i I adj],
[N7,i,jI p,q I false]
[AT7 ,i1 , j&apos; p,q I true]
such that E A, E adj(N1)
DCYK = V■M U yi&lt; U DRAt&lt; U DI6wornu
DRightDom
CYK u DN0Dom u DUnary u DAdj
CYK CYK CYK
TCYK = [It°, 0, n I — I adj] IaEI}
</equation>
<bodyText confidence="0.999839678571428">
The hypotheses defined for this parsing system
are the standard ones and therefore they will be
omitted in the next parsing systems described in
this paper.
The key steps in the parsing system PcyK are
DM and DcAyd-IK , which are in charge of the recog-
nition of adjunctions. The other steps are in
charge of the bottom-up traversal of elementary
trees and, in the case of auxiliary trees, the prop-
agation of the information corresponding to the
part of the input string recognized by the foot
node.
The set of deductive steps DM make it possi-
ble to start the bottom-up traversal of each aux-
iliary tree, as it predict all possible parts of the
input string that can be recognized by the foot
nodes. Several parses can exist for an auxiliary
tree which only differs in the part of the input
string which was predicted for the foot node. Not
all of them need take part on a derivation, only
those with a predicted foot compatible with an
adjunction. The compatibility between the ad-
junction node and the foot node of the adjoined
tree is checked by a derivation step DcAyd-1K: when
the root of an auxiliary tree /3 has been reached,
it checks for the existence of a subtree of an ele-
mentary tree rooted by a node N&apos;r which satisfies
the following conditions:
</bodyText>
<listItem confidence="0.980779333333333">
1. 3 can be adjoined on N-
2. N-Y derives the same part of the input string
derived from the foot node of 0.
</listItem>
<figure confidence="0.645177333333333">
DII:crel&amp;quot;.?&lt;om =
DAdj
CYK
</figure>
<page confidence="0.910598">
152
</page>
<bodyText confidence="0.9488492">
Proceedings of EACL &apos;99
If the conditions are satisfied, further adjunctions
on N are forbidden and the parsing process con-
tinues a bottom-up traverse of the rest of the ele-
mentary tree 7 containing N7.
</bodyText>
<sectionHeader confidence="0.985119" genericHeader="method">
3 A Bottom-up Earley-like
Algorithm
</sectionHeader>
<bodyText confidence="0.985525421052632">
To overcome the limitation of binary branching in
trees imposed by CYK-like algorithms, we define a
bottom-up Earley-like parsing algorithm for TAG.
As a first step we need to introduce the dotted
rules into items, which are of the form
[N7 -+8. v, j p,
such that 6 3 ai+i aq+1 aj
az+1 .a3 if and only if (p, q) (-, -) and 63
ai4.1 aj if and only if (p, q) = (- , -).
The items of the new parsing schema, denoted
buEi, are obtained by refining the items of CYK.
The dotted rules eliminate the need for the ele-
ment adj indicating whether the node in the left-
hand side of the production has been used as ad-
junction node.
Schema 2 The parsing system 1:PbuE correspond-
ing to the bottom-up Earley-like parsing algorithm,
given a tree adjoining grammar g and a input
string al ...an is defined as follows:
</bodyText>
<equation confidence="0.980007125">
/1„LE = [N7 Ip,qI
such that N7 -+ Ov E P(-y), -yEILJA, 0 &lt;i&lt;
j, (p, q) &lt; (i, j)
[N7 -&gt; .6, i, i I -, -1
,ThFoot
&amp;quot;&amp;quot;buE [Ffi
[N7 -*8 • av,i, j - 1 I p, q],
.ThScan [a, - 1,j]
huE -
[N7 -4 8a • v, j I p, q]
[N7 -&gt; 6 • M7 v,i, k I p,
[M7 -4 v• , lc, j Ip&apos; ,q&apos;]
ncomp _
‘-&apos;buE [N-y _+ 8111-Y • v,i, j pU pi,qU qi]
T -&gt; RO., k, j 11,mb
M7 -4 vs, l,m I 131,4
,ThAdico,n, huE = N7 • M7 v,i, k p,
[N7 -4 81117 • v, i, j I PU pi , q U
such that /3 E A, E adj(M7)
_ -nInit 7-)Foot T)Scani
huE&amp;quot;ThuE
DComp DAdjComp
`-&apos;buE buE
YbuE [T --+ 0,n1-,--]laE/1
</equation>
<bodyText confidence="0.915190083333333">
The deduction steps of PbuE are obtained from
the steps in lPcyx applying the following refine-
ment:
• LeftDom, RightDom and NoDom deductive
steps have been split into steps mit and
Comp.
• Unary and e steps are no longer necessary,
due to the uniform treatment of all produc-
tions independently of the length of the pro-
duction.
The algorithm performs a bottom-up recog-
nition of the auxiliary trees applying the steps
Dbcur. During the traversal of auxiliary trees,
information about the part of the input string rec-
ognized by the foot is propagated bottom-up. A
set of deductive steps TVA are in charge of start-
ing the recognition process, predicting all possible
start positions for each rule.
A filter has been applied to the parsing system
lPayK , contracting the deductive steps Adj and
Comp in a single AdjComp, as the item gener-
ated by a deductive step Adj can only be used to
advance the dot in the rule which has been used
to predict the left-hand side of its production.
</bodyText>
<sectionHeader confidence="0.756625" genericHeader="method">
4 An Earley-like Algorithm
</sectionHeader>
<bodyText confidence="0.928992529411765">
An Earley-like parsing algorithm for TAG can be
obtained by incorporating top-down prediction.
To do so, two dynamic filters must be applied to
FbuE:
• The deductive steps in Dhnit will only consider
productions having the root of an initial tree
as left-hand side.
• A new set Dred E of predictive steps will be
in charge of controlling the generation of
new items, considering only those new items
which are potentially useful for the parsing
process.
Schema 3 The parsing system IPE corresponding
to an Earley-like parsing algorithm for TAG with-
out the valid prefix property, given a tree adjoining
grammar g and a input string al ... an is defined
as follows:
</bodyText>
<equation confidence="0.923719566666667">
= IbuE
DIEnit = E
[T .R&apos;&apos;,0,0 I —,
153
Proceedings of EACL &apos;99
DPred _ {1\P&apos; —&gt; • Mv,i,j I P,
E
[M7 .V7.17.1 I —7 —}
DEAdjPred [N7 &amp;quot; j q]
-,-]
such that )3 E adj(M7)
F&apos;3 k, k I -,
[N7 --+ 6 • 1117v,i, j I p, q]
[M7 .8, k,k I — , —]
such that [3 E adj(M7)
M7 —4 Ve, k,1 I p,
[Fi3 k, k I -, -b
[N7 -4 6 • M7 v,i, j I p&apos;
[F,3 —+ k,1 I k,l]
such that E adj(M7), p U p&apos; and q U
q&apos; are defined
IT -4 IV., j, m
M7 -4 v., k,l I p, qb
-nAdjEomp . N&amp;quot;I —+ 6 • M7v,i, j I p&apos;, q&apos;] [N7 —&gt; 6M1&apos; • v,i,rn I pUp&apos;,qU qi]
such that [3 E adj(M7)
Dlnit u DScan u DEred u DCompu
buE
vciJ.oemupu DpotPred u DEFko&apos;ti:komPu
Dkic
YE = YbuE
</equation>
<bodyText confidence="0.9956885">
Parsing begins by creating the item correspond-
ing to a production having the root of an initial
tree as left-hand side and the dot in the leftmost
position of the right-hand side. Then, a set of de-
ductive steps DE&amp;quot;d and DEc&apos;mP traverse each ele-
mentary tree. A step predicts the ad-
junction of an auxiliary tree 0 in a node of an ele-
mentary tree -y and starts the traversal of 0. Once
the foot of 0 has been reached, the traversal of 0
is momentary suspended by a step in DpotPred,
which re-takes the subtree of 7 which must be at-
tached to the foot of )3. At this moment, there is
no information available about the node in which
the adjunction of /3 has been performed, so all pos-
sible nodes are predicted. When the traversal of a
predicted subtree has finished, a step in DEFeetcemp
re-takes the traversal of 0 continuing at the foot
node. When the traversal of 0 is completely fin-
ished, a deduction step in DEAd&apos;c&apos;mP checks if the
subtree attached to the foot of 0 corresponds with
the adjunction node. With respect to steps in
DEAdjcomp, p
and q are instantiated if and only if
the adjunction node is in the spine of 7.
</bodyText>
<sectionHeader confidence="0.912551" genericHeader="method">
5 The Valid Prefix Property
</sectionHeader>
<bodyText confidence="0.99993734">
Parsers satisfying the valid prefix property guaran-
tee that, as they read the input string from left to
right, the substrings read so far are valid prefixes
of the language defined by the grammar. More for-
mally, a parser satisfies the valid prefix property
if for any substring al ... ak read from the input
string al ... akak+i ... an guarantees that there is
a string of tokens b1 bni, where bi need not be
part of the input string, such that al . akbi ... bin
is a valid string of the language.
To maintain the valid prefix property, the parser
must recognize all possible derived trees in prefix
form. In order to do that, two different phases
must work coordinately: a top-down phase that
expands the children of each node visited and a
bottom-up phase grouping the children nodes to
indicate the recognition of the parent node (Sch-
abes, 1991).
During the recognition of a derived tree in pre-
fix form, node expansion can depend on adjunc-
tion operations performed in the previously vis-
ited part of the tree. Due to this kind of dependen-
cies the set path is a context-free language (Vijay-
Shanker et al., 1987). A bottom-up algorithm
(e.g. CYK-like or bottom-up Earley-like) can
stack the dependencies shown by the context-free
language defining the path-set. This is sufficient
to get a correct parsing algorithm, but without
the valid prefix property. To preserve this prop-
erty the algorithm must have a top-down phase
which also stacks the dependencies shown by the
language defining the path-set. To transform an
algorithm without the valid prefix property into
another which preserves it is a difficult task be-
cause stacking operations performed during top-
down and bottom-up phases must be correlated
some way and it is not clear how to do so with-
out augmenting the time complexity (Nederhof,
1997).
CYK-like, bottom-up Earley-like and Earley-
like parsing algorithms described above do not
preserve the valid prefix property because foot-
prediction (a top-down operation) is not restric-
tive enough to guarantee that the subtree attached
to the foot node really corresponds with a instance
of the tree involved in the adjunction.
To obtain a Earley-like parsing algorithm for
tree adjoining grammars preserving the valid pre-
fix property we need to refine the items by in-
cluding a new element to indicate the position of
</bodyText>
<figure confidence="0.84475475">
Dl&apos;ootPred
DPootComp
E
=
</figure>
<page confidence="0.997028">
154
</page>
<bodyText confidence="0.8370565">
Proceedings of EACL &apos;99
the input string corresponding to the left-most ex-
treme of the frontier of the tree to which the dot-
ted rule in the item belongs:
</bodyText>
<equation confidence="0.9137442">
[h, N-Y -4 6 • v,i, j I p, ql
such that IV ah.+1 ai5vv and 6
a2 ...a Fr a„+i a3 a. ..a3 if and only if
(p,q) (—,—) and 6 a. ..a3 if and only if
(p,q) = (—,—).
</equation>
<bodyText confidence="0.998238125">
Thus, an item [Am -4 S • v,i, j p,q] of PE
corresponds now with a subset of {[h, Am&apos; —&gt; 6 •
I p,q]} for all h E [0, r].
Schema 4 The parsing system IPEariey corre-
sponding to a Earley-like parsing algorithm with
the valid prefix property, for a tree adjoining gram-
mar g and a input string al . an is defined as
follows:
</bodyText>
<equation confidence="0.986018935483871">
/Earley = [h, N * 6 • v,i, j I p,
--+ 6•vEP(7), yE IUA,O&lt;h&lt;i&lt;
j, (p,q) &lt; (i, j)
E
[0, T ■FO, 0, 0 I —, —]
[h,.AM -4 6 • au, j — 1 I p,
[a, j — 1,j]
[h, -4 oa • v, j I p, q]
[h, 6 • MY v,i, j I p, q]
[h, OV, j, j —H ,
1h, NI&apos; -4 6 • M-rv,i,k p,q],
M&apos;Y v•,k, .1 I ,
[h, 611/17 • 11,i, j I pUp&apos;,qUql
DAdjPred —* 6 • Mv,i,jI p,q]
Earley — [j,
T .1143, —, H
such that 13 E adj(1WY)
j,F15 -4 •_L,k,k I—,—],
,_,FootPred = [ILI .1\rY —) 6 • .11/17 v, p, q]
L&apos;Earley .6, k, k I — —]
such that (3 E adj(IWY)
[h, -4 v., k,l p,q],
11,P5 -4 .1,k, k I —,
rFootcomp _ —&gt; 6 • MY ,
Earley — k, I k,l]
(3 E adj(M1&apos;), p U p&apos; and q u q&apos; are defined
lj, T RO•, j, in, I k,
h, M&apos;Y v.,k,l I p,q],
.D.Adiconn, = h, —&gt; 6 • M1&apos;1., i, I p&apos;
Earley [1, NY 61111&apos; • V,i, TO, I pU p&apos; , q
such that E adj(M7)
</equation>
<table confidence="0.667036833333333">
nInit -1-)Scan &apos;red
&apos;Earley — &amp;quot;Earley &amp;quot;&apos;Earley &amp;quot;Earley&apos;-&apos;
DC° M P U DAdiPred 1-)FootPredi
Earley Earley &amp;quot;Earley
T.,FootComp .nAdjComp
&apos;Earley &amp;quot;&apos;Earley
</table>
<bodyText confidence="0.978162166666667">
YEarley = [0, T Rail, n I —, —] I E / }
Time complexity of the Earley-like algorithm
with respect to the length n of input string is
AdjComp.
0(n7), and it is given by steps DEarley Al-
though 8 indices are involved in a step
partial application allows us to reduce the time
complexity to 0(n7).
Algorithms without the valid prefix property
have a time complexity 0(n6) with respect to the
length of the input string. The change in com-
plexity is due to the additional index in items of
PEariey. That index is needed to check the trees
involved in steps D In the
EoaortePyred and DEF•a•ritecyomp.
other steps, that index is only propagated to the
generated item. This feature allows us to refine
the steps in DEAadriicerP, splitting them into several
steps generating intermediate items without that
index. To get a correct slitting, we must first
differentiate steps in DEA adrjleyomp
in which p and q
are instantiated from steps in DEAadriicerP in which
p&apos; and q&apos; are instantiated. So, we must define two
</bodyText>
<subsectionHeader confidence="0.539415">
AdjCompl Ad&apos;Co
</subsectionHeader>
<bodyText confidence="0.9930165">
new sets DEarley and D m P2 of steps in-
Earley
Aadrfey
stead of the single set D ompE
Additionally, in
steps in DEAadriiceri we need to introduce a new
item (dynamic filtering) to guarantee the correct-
ness of the steps.
</bodyText>
<equation confidence="0.973505444444444">
.j, T RO., j, m I k,
h, v., k,l
p, q Ip,q,
DAdicompl *11, -+6 • M&amp;quot;rv,i, — —1
Earley [h, 81Wr • V,i,M p,
such that 0 E adj(11/11&apos;)
—&gt; m I k,1],
—&gt; v., k,l I —,-1,
DAdjC0mp2h, -+6 • Ite 731 &apos;41]
</equation>
<table confidence="0.364828888888889">
Earley N,y _4 6m-.7 • v,i,m pi,
such that 0 E adj(M&amp;quot;)
DEInaitley U DScari I .7-)Pred
Earley L&apos;Earley`-&apos;
DComp, q-,AdjPred nFootPredi
Earley &apos;Earley &amp;quot;&apos;Earley
,ThFootComp ilAdjCompi , 1-,AdjComp2
Earley &amp;quot;&apos;Earley &apos;Earley
&amp;quot;
</table>
<figure confidence="0.991958">
&amp;quot;Earley
-nScan
&amp;quot;Earley
-r,Pred
&apos;Earley
.1-)Comp
&amp;quot;Earley
DEarley =
</figure>
<page confidence="0.977382">
155
</page>
<table confidence="0.758606142857143">
Proceedings of EACL &apos;99
Now, we must refine steps in DEAadiferwl into
AdjComp° AdjComp&apos;&apos;
steps in DEarley and DEariey , and re-
Aadriiceyo p°
fine steps in DEAadifey0mp2 into steps in DE
and DEticeyomp2&apos; Correctness of these splittings
</table>
<bodyText confidence="0.9989492">
is guaranteed by the context-free property of
TAG (Vijay-Shanker and Weir, 1993) establishing
the independence of each adjunction with respect
to any other adjunction.
After step refinement, we get the Earley-like
parsing algorithm for TAG described in (Neder-
hof, 1997), which preserves the valid prefix prop-
erty having a time complexity 0(n6) with respect
to the input string. In this schema we also need
to define a new kind of intermediate pseudo-items
</bodyText>
<equation confidence="0.625984">
[[N7 • v, j p,q]]
</equation>
<bodyText confidence="0.8832076">
such that ai ap aq+i aj ai
if and only if (p, q) (—,—) and 6 &apos;4 a, ...a3 if
and only if (p, q) = (—, —) .
Schema 5 The parsing system PEariey corre-
sponding to a the final Earley-like parsing algo-
rithm with the valid prefix property having time
complexity 0(n6), for a tree adjoining grammar g
and a input string al ... an is defined as follows:
&apos;Earley = [IL) N-Y -+6 • P, qi
such that N.7 —&gt; 5.ziEP(-y), -yE/UA,0 &lt;h&lt;
</bodyText>
<equation confidence="0.947235642857143">
i j, (p,q) &lt; (i, j)
&apos;Earley = { [{N&amp;quot; -+6 • v, p,q}]
such that N&apos;Y 6 •ziEP(y), -yE/UA,0&lt;i&lt;
j, (p,q) (i, j)
&apos;Earley = &apos;Earley U &apos;Earley
Dinit = E /
Earley I- [0, T -4 •Rft, 0, 0 I
[h, N7 -4 6 • av,i, j — 1 I p,q],
DScan —1,.i]
[11, N7 (5a • v,i, j Ip,qI
[h, N7 6 • M7 v,i, j I p, q]
T,Pred _
Earley —
[h) M7 -4 •v7 I — --]
nAdjPred [h) N&amp;quot; -4 6 • M7v, p,
&apos;Earley — [j, T •RO,j,j —]
such that 0 E adj(M7)
[j, F13 --+ • _L, k, k I— , -b
[h, N-Y 6 • I p,
[h, M-Y .6, k, k I—, —1
such that 0 E adj(M7)
h, M7 -4 J., k,1 p,q],
.1,k,k 1 —-1&apos;
[h, -4 6 • M7 v,i, j I p&apos;
[j,F0 —&gt; k,11 k,1]
E adj(M7), p U p&apos; and
lj, T RO., j,m, Ik,1],
TIAdicomp° _ [h, M7 S., k, 11
</equation>
<bodyText confidence="0.1737245">
&amp;quot;Earley — [[M7 -4 j,m I p,q]]
such that 0 E adj(M7)
</bodyText>
<figure confidence="0.724307173913043">
[[My -4 6*, in I P)
h,F7 -4 .L•, p, q I p,q ,
,,,Adjcompe —&gt; 6 • M7 v,i, j I —, —1
_
&apos;-&apos; Earley — [h, N-r SM 7 • 1/, p,
such that 0 E adj(M7)
FM&amp;quot; m p,q]},
DAdicomp _ N&amp;quot; —&gt; 6 • Mv,i,jp,q]
Earley — [h, N -+ (WY • 1/, i,771, I p, q]
such that 13 E adj(M7)
ninit nS n
V&apos;-&amp;quot; Pred
&amp;quot;Earley &amp;quot; &amp;quot;Earley &amp;quot; &amp;quot;Earley&amp;quot;
,-,Comp q-,AdjPred u Dpary
otePredu
&apos;Earley &amp;quot;&apos;Earley
,r,FootComp ,r,AdjComp°,
&apos;Earley &amp;quot;Earley
.7-)AdjComp1&apos; nAdjeorn
Earley p2&apos;
&amp;quot;Earley
&apos;
TEarley — { [0, T •, 0, It I —7 —] I a E
</figure>
<sectionHeader confidence="0.909075" genericHeader="conclusions">
6 Conclusion
</sectionHeader>
<bodyText confidence="0.9998565">
We have described a set of parsing algorithms
for TAG creating a continuum which has the
CYK-like parsing algorithm by (Vijay-Shanker
and Joshi, 1985) as its starting point and the
Earley-like parsing algorithm by (Nederhof, 1997)
preserving the valid prefix property with time
</bodyText>
<figure confidence="0.895032909090909">
Earley —
[11, N&apos;Y -4 6 • M7 v,i, k I p,q1,
Comp = [h, M7 -4 v., k, j I p&apos;,
[h, N 6m-t • v, i,j I pU p&apos;, q U q&apos;l
DFootPred
Earley —
nFootComp =
&apos;Earley
such that 0
q&apos; are defined
DEarley =
</figure>
<page confidence="0.966358">
156
</page>
<bodyText confidence="0.984410904761905">
Proceedings of EACL &apos;99
complexity 0(n6) as its goal. As intermediate al-
gorithms, we have defined a bottom-up Earley-like
parsing algorithm and an Earley-like parsing algo-
rithm without the valid prefix property, which to
our knowledge has not been previously described
in literature&apos;. We have also shown how to trans-
form one algorithm into the next using simple
transformations.Other algorithms could also has
been included in the continuum, but for reasons
of space we have chosen to show only the algo-
rithms we consider milestones in the development
of parsing algorithms for TAG.
An interesting project for the future will be to
translate the algorithms presented here to sev-
eral proposed automata models for TAG which
have an associated tabulation technique: Strongly
Driven 2-Stack Automata (de la Clergerie and
Alonso, 1998), Bottom-up 2-Stack Automata (de
la Clergerie et al., 1998) and Linear Indexed Au-
tomata (Nederhof, 1998).
</bodyText>
<sectionHeader confidence="0.997714" genericHeader="acknowledgments">
7 Acknowledgments
</sectionHeader>
<bodyText confidence="0.998801333333333">
This work has been partially supported by
FEDER of European Union (1FD97-0047-004-02)
and Xunta de Galicia (and XUGA20402B97).
</bodyText>
<sectionHeader confidence="0.997404" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999044184210526">
Eric de la Clergerie and Miguel A. Alonso. 1998.
A tabular interpretation of a class of 2-Stack
Automata. In COLING-ACL &apos;98, 36th Annual
Meeting of the Association for Computational
Linguistics and 17th International Conference
on Computational Linguistics, Proceedings of
the Conference, volume II, pages 1333-1339,
Montreal, Quebec, Canada, August. ACL.
Eric de la Clergerie, Miguel A. Alonso, and
David Cabrero. 1998. A tabular interpreta-
tion of bottom-up automata for TAG. In Proc.
of Fourth International Workshop on Tree-
Adjoining Grammars and Related Frameworks
(TAG+4), pages 42-45, Philadelphia, PA, USA,
August.
Aravind K. Joshi. 1987. An introduction to
tree adjoining grammars. In Alexis Manaster-
Ramer, editor, Mathematics of Language, pages
87-115. John Benjamins Publishing Co., Ams-
terdam/Philadelphia.
Mark-Jan Nederhof. 1997. Solving the correct-
prefix property for TAGs. In T. Becker and
&apos;Other different formulations of Earley-like pars-
ing algorithms for TAG has been previously proposed,
e.g. (Schabes, 1991).
H.-V. Krieger, editors, Proc. of the Fifth Meet-
ing on Mathematics of Language, pages 124-
130, Schloss Dagstuhl, Saarbruecken, Germany,
August.
Mark-Jan Nederhof. 1998. Linear indexed au-
tomata and tabulation of TAG parsing. In Proc.
of First Workshop on Tabulation in Parsing
and Deduction (TAPD&apos;98), pages 1-9, Paris,
France, April.
Yves Schabes and Aravind K. Joshi. 1988. An
Earley-type parsing algorithm for tree adjoining
grammars. In Proc. of 26th Annual Meeting of
the Association for Computational Linguistics,
pages 258-269, Buffalo, NY, USA, June. ACL.
Yves Schabes and Stuart M. Shieber. 1994. An
alternative conception of tree-adjoining deriva-
tion. Computational Linguistics, 20(1):91-124.
Yves Schabes. 1991. The valid prefix property
and left to right parsing of tree-adjoining gram-
mar. In Proc. of II International Workshop on
Parsing Technologies, IWPT&apos;91, pages 21-30,
Cancun, Mexico.
Yves Schabes. 1994. Left to right parsing of
lexicalized tree-adjoining grammars. Computa-
tional Intelligence, 10(4):506-515.
Stuart M. Shieber, Yves Schabes, and Fernando
C. N. Pereira. 1995. Principles and implemen-
tation of deductive parsing. Journal of Logic
Programming, 24(18z2):3-36, July-August.
Klaas Sikkel. 1997. Parsing Schemata — A
Framework for Specification and Analysis of
Parsing Algorithms. Texts in Theoretical Com-
puter Science — An EATCS Series. Springer-
Verlag, Berlin/Heidelberg/New York.
Krishnamurti Vijay-Shanker and Aravind K.
Joshi. 1985. Some computational properties of
tree adjoining grammars. In 23rd Annual Meet-
ing of the Association for Computational Lin-
guistics, pages 82-93, Chicago, IL, USA, July.
ACL.
Krishnamurti Vijay-Shanker and David J. Weir.
1993. Parsing some constrained gram-
mar formalisms. Computational Linguistics,
19(4):591-636.
Krishnamurti Vijay-Shanker, David J. Weir, and
Aravind K. Joshi. 1987. Characterizing struc-
tural descriptions produced by various gram-
matical formalisms. In Proc. of the 25th Annual
Meeting of the Association for Computational
Linguistics, pages 104-111, Buffalo, NY, USA,
June. ACL.
</reference>
<page confidence="0.99775">
157
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.182171">
<note confidence="0.546681">Proceedings of EACL &apos;99</note>
<title confidence="0.994893">Tabular Algorithms for TAG Parsing</title>
<author confidence="0.99992">Miguel A Alonso</author>
<affiliation confidence="0.9962845">Departamento de Computacion Univesidad de La Coruna</affiliation>
<address confidence="0.804658333333333">Campus de Elviria s/n 15071 La Coruna SPAIN</address>
<email confidence="0.814304">alonso@dc.fi.udc.es</email>
<author confidence="0.981163">Eric de_la Clergerie</author>
<affiliation confidence="0.9665295">INRIA Domaine de Voluceau</affiliation>
<address confidence="0.964247">Rocquencourt, B.P. 105 78153 Le Chesnay Cedex FRANCE</address>
<email confidence="0.990753">Eric.De_La_Clergerie@inria.fr</email>
<abstract confidence="0.994188333333333">We describe several tabular algorithms for Tree Adjoining Grammar parsing, creating a continuum from simple pure bottom-up algorithms to complex predictive algorithms and showing what transformations must be applied to each one in order to obtain the next one in the continuum.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Eric de la Clergerie</author>
<author>Miguel A Alonso</author>
</authors>
<title>A tabular interpretation of a class of 2-Stack Automata.</title>
<date>1998</date>
<booktitle>In COLING-ACL &apos;98, 36th Annual Meeting of the Association for Computational Linguistics and 17th International Conference on Computational Linguistics, Proceedings of the Conference,</booktitle>
<volume>volume II,</volume>
<pages>1333--1339</pages>
<publisher>ACL.</publisher>
<location>Montreal, Quebec, Canada,</location>
<marker>Clergerie, Alonso, 1998</marker>
<rawString>Eric de la Clergerie and Miguel A. Alonso. 1998. A tabular interpretation of a class of 2-Stack Automata. In COLING-ACL &apos;98, 36th Annual Meeting of the Association for Computational Linguistics and 17th International Conference on Computational Linguistics, Proceedings of the Conference, volume II, pages 1333-1339, Montreal, Quebec, Canada, August. ACL.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Eric de la Clergerie</author>
<author>Miguel A Alonso</author>
<author>David Cabrero</author>
</authors>
<title>A tabular interpretation of bottom-up automata for TAG.</title>
<date>1998</date>
<booktitle>In Proc. of Fourth International Workshop on TreeAdjoining Grammars and Related Frameworks (TAG+4),</booktitle>
<pages>42--45</pages>
<location>Philadelphia, PA, USA,</location>
<marker>Clergerie, Alonso, Cabrero, 1998</marker>
<rawString>Eric de la Clergerie, Miguel A. Alonso, and David Cabrero. 1998. A tabular interpretation of bottom-up automata for TAG. In Proc. of Fourth International Workshop on TreeAdjoining Grammars and Related Frameworks (TAG+4), pages 42-45, Philadelphia, PA, USA, August.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Aravind K Joshi</author>
</authors>
<title>An introduction to tree adjoining grammars.</title>
<date>1987</date>
<booktitle>Mathematics of Language,</booktitle>
<pages>87--115</pages>
<editor>In Alexis ManasterRamer, editor,</editor>
<publisher>John Benjamins Publishing Co., Amsterdam/Philadelphia.</publisher>
<contexts>
<context position="707" citStr="Joshi, 1987" startWordPosition="103" endWordPosition="104">putacion Univesidad de La Coruna Campus de Elviria s/n 15071 La Coruna SPAIN alonso@dc.fi.udc.es Eric de la Clergerie INRIA Domaine de Voluceau Rocquencourt, B.P. 105 78153 Le Chesnay Cedex FRANCE Eric.De_La_Clergerie@inria.fr Abstract We describe several tabular algorithms for Tree Adjoining Grammar parsing, creating a continuum from simple pure bottom-up algorithms to complex predictive algorithms and showing what transformations must be applied to each one in order to obtain the next one in the continuum. 1 Introduction Tree Adjoining Grammars are a extension of CFG introduced by Joshi in (Joshi, 1987) that use trees instead of productions as the primary representing structure. Several parsing algorithms have been proposed for this formalism, most of them based on tabular techniques, ranging from simple bottom-up algorithms (Vijay-Shanker and Joshi, 1985) to sophisticated extensions of the Earley&apos;s algorithm (Schabes and Joshi, 1988; Schabes, 1994; Nederhof, 1997). However, it is difficult to inter-relate different parsing algorithms. In this paper we study several tabular algorithms for TAG parsing, showing their common characteristics and how one algorithm can be derived from another in t</context>
</contexts>
<marker>Joshi, 1987</marker>
<rawString>Aravind K. Joshi. 1987. An introduction to tree adjoining grammars. In Alexis ManasterRamer, editor, Mathematics of Language, pages 87-115. John Benjamins Publishing Co., Amsterdam/Philadelphia.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Mark-Jan Nederhof</author>
</authors>
<title>Solving the correctprefix property for TAGs. In T. Becker and &apos;Other different formulations of Earley-like parsing algorithms for TAG has been previously proposed, e.g.</title>
<date>1997</date>
<location>Schabes,</location>
<contexts>
<context position="1076" citStr="Nederhof, 1997" startWordPosition="156" endWordPosition="157">hms to complex predictive algorithms and showing what transformations must be applied to each one in order to obtain the next one in the continuum. 1 Introduction Tree Adjoining Grammars are a extension of CFG introduced by Joshi in (Joshi, 1987) that use trees instead of productions as the primary representing structure. Several parsing algorithms have been proposed for this formalism, most of them based on tabular techniques, ranging from simple bottom-up algorithms (Vijay-Shanker and Joshi, 1985) to sophisticated extensions of the Earley&apos;s algorithm (Schabes and Joshi, 1988; Schabes, 1994; Nederhof, 1997). However, it is difficult to inter-relate different parsing algorithms. In this paper we study several tabular algorithms for TAG parsing, showing their common characteristics and how one algorithm can be derived from another in turn, creating a continuum from simple pure bottom-up to complex predictive algorithms. Formally, a TAG is a 5-tuple G = (vN, VT, S, I, A), where VN is a finite set of non-terminal symbols, VT a finite set of terminal David Cabrero Departamento de Computacion Univesidad de La Coruria Campus de Elviria s/n 15071 La Coruna SPAIN cabrero@dc.fi.udc.es Manuel Vilares Depar</context>
<context position="18158" citStr="Nederhof, 1997" startWordPosition="3405" endWordPosition="3406"> dependencies shown by the context-free language defining the path-set. This is sufficient to get a correct parsing algorithm, but without the valid prefix property. To preserve this property the algorithm must have a top-down phase which also stacks the dependencies shown by the language defining the path-set. To transform an algorithm without the valid prefix property into another which preserves it is a difficult task because stacking operations performed during topdown and bottom-up phases must be correlated some way and it is not clear how to do so without augmenting the time complexity (Nederhof, 1997). CYK-like, bottom-up Earley-like and Earleylike parsing algorithms described above do not preserve the valid prefix property because footprediction (a top-down operation) is not restrictive enough to guarantee that the subtree attached to the foot node really corresponds with a instance of the tree involved in the adjunction. To obtain a Earley-like parsing algorithm for tree adjoining grammars preserving the valid prefix property we need to refine the items by including a new element to indicate the position of Dl&apos;ootPred DPootComp E = 154 Proceedings of EACL &apos;99 the input string correspondi</context>
<context position="22490" citStr="Nederhof, 1997" startWordPosition="4242" endWordPosition="4244">i , 1-,AdjComp2 Earley &amp;quot;&apos;Earley &apos;Earley &amp;quot; &amp;quot;Earley -nScan &amp;quot;Earley -r,Pred &apos;Earley .1-)Comp &amp;quot;Earley DEarley = 155 Proceedings of EACL &apos;99 Now, we must refine steps in DEAadiferwl into AdjComp° AdjComp&apos;&apos; steps in DEarley and DEariey , and reAadriiceyo p° fine steps in DEAadifey0mp2 into steps in DE and DEticeyomp2&apos; Correctness of these splittings is guaranteed by the context-free property of TAG (Vijay-Shanker and Weir, 1993) establishing the independence of each adjunction with respect to any other adjunction. After step refinement, we get the Earley-like parsing algorithm for TAG described in (Nederhof, 1997), which preserves the valid prefix property having a time complexity 0(n6) with respect to the input string. In this schema we also need to define a new kind of intermediate pseudo-items [[N7 • v, j p,q]] such that ai ap aq+i aj ai if and only if (p, q) (—,—) and 6 &apos;4 a, ...a3 if and only if (p, q) = (—, —) . Schema 5 The parsing system PEariey corresponding to a the final Earley-like parsing algorithm with the valid prefix property having time complexity 0(n6), for a tree adjoining grammar g and a input string al ... an is defined as follows: &apos;Earley = [IL) N-Y -+6 • P, qi such that N.7 —&gt; 5.</context>
<context position="24542" citStr="Nederhof, 1997" startWordPosition="4694" endWordPosition="4695"> • 1/, p, such that 0 E adj(M7) FM&amp;quot; m p,q]}, DAdicomp _ N&amp;quot; —&gt; 6 • Mv,i,jp,q] Earley — [h, N -+ (WY • 1/, i,771, I p, q] such that 13 E adj(M7) ninit nS n V&apos;-&amp;quot; Pred &amp;quot;Earley &amp;quot; &amp;quot;Earley &amp;quot; &amp;quot;Earley&amp;quot; ,-,Comp q-,AdjPred u Dpary otePredu &apos;Earley &amp;quot;&apos;Earley ,r,FootComp ,r,AdjComp°, &apos;Earley &amp;quot;Earley .7-)AdjComp1&apos; nAdjeorn Earley p2&apos; &amp;quot;Earley &apos; TEarley — { [0, T •, 0, It I —7 —] I a E 6 Conclusion We have described a set of parsing algorithms for TAG creating a continuum which has the CYK-like parsing algorithm by (Vijay-Shanker and Joshi, 1985) as its starting point and the Earley-like parsing algorithm by (Nederhof, 1997) preserving the valid prefix property with time Earley — [11, N&apos;Y -4 6 • M7 v,i, k I p,q1, Comp = [h, M7 -4 v., k, j I p&apos;, [h, N 6m-t • v, i,j I pU p&apos;, q U q&apos;l DFootPred Earley — nFootComp = &apos;Earley such that 0 q&apos; are defined DEarley = 156 Proceedings of EACL &apos;99 complexity 0(n6) as its goal. As intermediate algorithms, we have defined a bottom-up Earley-like parsing algorithm and an Earley-like parsing algorithm without the valid prefix property, which to our knowledge has not been previously described in literature&apos;. We have also shown how to transform one algorithm into the next using simpl</context>
</contexts>
<marker>Nederhof, 1997</marker>
<rawString>Mark-Jan Nederhof. 1997. Solving the correctprefix property for TAGs. In T. Becker and &apos;Other different formulations of Earley-like parsing algorithms for TAG has been previously proposed, e.g. (Schabes, 1991).</rawString>
</citation>
<citation valid="true">
<date></date>
<booktitle>Proc. of the Fifth Meeting on Mathematics of Language,</booktitle>
<pages>124--130</pages>
<editor>H.-V. Krieger, editors,</editor>
<location>Schloss Dagstuhl, Saarbruecken, Germany,</location>
<marker></marker>
<rawString>H.-V. Krieger, editors, Proc. of the Fifth Meeting on Mathematics of Language, pages 124-130, Schloss Dagstuhl, Saarbruecken, Germany, August.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Mark-Jan Nederhof</author>
</authors>
<title>Linear indexed automata and tabulation of TAG parsing.</title>
<date>1998</date>
<booktitle>In Proc. of First Workshop on Tabulation in Parsing and Deduction (TAPD&apos;98),</booktitle>
<pages>1--9</pages>
<location>Paris, France,</location>
<marker>Nederhof, 1998</marker>
<rawString>Mark-Jan Nederhof. 1998. Linear indexed automata and tabulation of TAG parsing. In Proc. of First Workshop on Tabulation in Parsing and Deduction (TAPD&apos;98), pages 1-9, Paris, France, April.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Yves Schabes</author>
<author>Aravind K Joshi</author>
</authors>
<title>An Earley-type parsing algorithm for tree adjoining grammars.</title>
<date>1988</date>
<booktitle>In Proc. of 26th Annual Meeting of the Association for Computational Linguistics,</booktitle>
<pages>258--269</pages>
<publisher>ACL.</publisher>
<location>Buffalo, NY, USA,</location>
<contexts>
<context position="1044" citStr="Schabes and Joshi, 1988" startWordPosition="149" endWordPosition="152">inuum from simple pure bottom-up algorithms to complex predictive algorithms and showing what transformations must be applied to each one in order to obtain the next one in the continuum. 1 Introduction Tree Adjoining Grammars are a extension of CFG introduced by Joshi in (Joshi, 1987) that use trees instead of productions as the primary representing structure. Several parsing algorithms have been proposed for this formalism, most of them based on tabular techniques, ranging from simple bottom-up algorithms (Vijay-Shanker and Joshi, 1985) to sophisticated extensions of the Earley&apos;s algorithm (Schabes and Joshi, 1988; Schabes, 1994; Nederhof, 1997). However, it is difficult to inter-relate different parsing algorithms. In this paper we study several tabular algorithms for TAG parsing, showing their common characteristics and how one algorithm can be derived from another in turn, creating a continuum from simple pure bottom-up to complex predictive algorithms. Formally, a TAG is a 5-tuple G = (vN, VT, S, I, A), where VN is a finite set of non-terminal symbols, VT a finite set of terminal David Cabrero Departamento de Computacion Univesidad de La Coruria Campus de Elviria s/n 15071 La Coruna SPAIN cabrero@d</context>
</contexts>
<marker>Schabes, Joshi, 1988</marker>
<rawString>Yves Schabes and Aravind K. Joshi. 1988. An Earley-type parsing algorithm for tree adjoining grammars. In Proc. of 26th Annual Meeting of the Association for Computational Linguistics, pages 258-269, Buffalo, NY, USA, June. ACL.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Yves Schabes</author>
<author>Stuart M Shieber</author>
</authors>
<title>An alternative conception of tree-adjoining derivation.</title>
<date>1994</date>
<journal>Computational Linguistics,</journal>
<pages>20--1</pages>
<contexts>
<context position="8703" citStr="Schabes and Shieber, 1994" startWordPosition="1555" endWordPosition="1558">and Joshi, 1985) in order to avoid several adjunctions on a node. A value of true indicates that an adjunction has taken place in the node N7 and therefore further adjunctions on the same node are forbidden. A value of false indicates that no adjunction was performed on that node. In this case, during future processing this item can play the role of the item recognizing the excised part of an elementary tree to be attached to the foot node of an auxiliary tree. As a consequence, only one adjunction can take place on an elementary node, as is prescribed by the tree adjoining grammar formalism (Schabes and Shieber, 1994). As an additional advantage, the algorithm does not need to require the restriction that every auxiliary tree must have at least one terminal symbol in its frontier (Vijay-Shanker and Joshi, 1985). Schema 1 The parsing systems PCYK corresponding to the CYK-line algorithm for a tree adjoining grammar G and an input string al . • • an is defined as follows: IcyK = { j I p,q I adj] } such that N7 E P(7), label(N7) EVN, 1,E/1J A, 0 &lt; i &lt;j, (p,q) &lt; (i, j), adj E {true, false} WCYK { [a,i-1,i]la=ai,1&lt;i&lt;n } [a, — 1,i] N7 -4 a DScan CYK [N-y 1,i I — I false] Vt:YK = [N- ,i,i — I false] N7 -4 E Dr;Vt </context>
</contexts>
<marker>Schabes, Shieber, 1994</marker>
<rawString>Yves Schabes and Stuart M. Shieber. 1994. An alternative conception of tree-adjoining derivation. Computational Linguistics, 20(1):91-124.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Yves Schabes</author>
</authors>
<title>The valid prefix property and left to right parsing of tree-adjoining grammar.</title>
<date>1991</date>
<booktitle>In Proc. of II International Workshop on Parsing Technologies, IWPT&apos;91,</booktitle>
<pages>21--30</pages>
<location>Cancun, Mexico.</location>
<contexts>
<context position="17201" citStr="Schabes, 1991" startWordPosition="3246" endWordPosition="3248"> valid prefix property if for any substring al ... ak read from the input string al ... akak+i ... an guarantees that there is a string of tokens b1 bni, where bi need not be part of the input string, such that al . akbi ... bin is a valid string of the language. To maintain the valid prefix property, the parser must recognize all possible derived trees in prefix form. In order to do that, two different phases must work coordinately: a top-down phase that expands the children of each node visited and a bottom-up phase grouping the children nodes to indicate the recognition of the parent node (Schabes, 1991). During the recognition of a derived tree in prefix form, node expansion can depend on adjunction operations performed in the previously visited part of the tree. Due to this kind of dependencies the set path is a context-free language (VijayShanker et al., 1987). A bottom-up algorithm (e.g. CYK-like or bottom-up Earley-like) can stack the dependencies shown by the context-free language defining the path-set. This is sufficient to get a correct parsing algorithm, but without the valid prefix property. To preserve this property the algorithm must have a top-down phase which also stacks the dep</context>
</contexts>
<marker>Schabes, 1991</marker>
<rawString>Yves Schabes. 1991. The valid prefix property and left to right parsing of tree-adjoining grammar. In Proc. of II International Workshop on Parsing Technologies, IWPT&apos;91, pages 21-30, Cancun, Mexico.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Yves Schabes</author>
</authors>
<title>Left to right parsing of lexicalized tree-adjoining grammars.</title>
<date>1994</date>
<journal>Computational Intelligence,</journal>
<pages>10--4</pages>
<contexts>
<context position="1059" citStr="Schabes, 1994" startWordPosition="153" endWordPosition="155">ttom-up algorithms to complex predictive algorithms and showing what transformations must be applied to each one in order to obtain the next one in the continuum. 1 Introduction Tree Adjoining Grammars are a extension of CFG introduced by Joshi in (Joshi, 1987) that use trees instead of productions as the primary representing structure. Several parsing algorithms have been proposed for this formalism, most of them based on tabular techniques, ranging from simple bottom-up algorithms (Vijay-Shanker and Joshi, 1985) to sophisticated extensions of the Earley&apos;s algorithm (Schabes and Joshi, 1988; Schabes, 1994; Nederhof, 1997). However, it is difficult to inter-relate different parsing algorithms. In this paper we study several tabular algorithms for TAG parsing, showing their common characteristics and how one algorithm can be derived from another in turn, creating a continuum from simple pure bottom-up to complex predictive algorithms. Formally, a TAG is a 5-tuple G = (vN, VT, S, I, A), where VN is a finite set of non-terminal symbols, VT a finite set of terminal David Cabrero Departamento de Computacion Univesidad de La Coruria Campus de Elviria s/n 15071 La Coruna SPAIN cabrero@dc.fi.udc.es Man</context>
</contexts>
<marker>Schabes, 1994</marker>
<rawString>Yves Schabes. 1994. Left to right parsing of lexicalized tree-adjoining grammars. Computational Intelligence, 10(4):506-515.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Stuart M Shieber</author>
<author>Yves Schabes</author>
<author>Fernando C N Pereira</author>
</authors>
<title>Principles and implementation of deductive parsing.</title>
<date>1995</date>
<journal>Journal of Logic Programming,</journal>
<pages>24--18</pages>
<contexts>
<context position="5834" citStr="Shieber et al., 1995" startWordPosition="1039" endWordPosition="1042"> initial set of items called hypothesis that encodes the sentence to be parsed, and D a set of deduction steps that allow new items to be derived from already known items. Deduction steps are of the form 711-7/k cod, meaning that if all antecedents Th of a deduction step are present and the conditions cond are satisfied, then the consequent e should be generated by the parser. A set .T C I of final items represent the recognition of a sentence. A parsing schema is a parsing system parameterized by a grammar and a sentence. Parsing schemata are closely related to grammatical deduction systems (Shieber et al., 1995), where items are called formula schemata, deduction steps are inference rules, hypothesis are axioms and final items are goal formulas. A parsing schema can be generalized from another one using the following transformations (Sikkel, 1997): • Item refinement, breaking single items into multiple items. • Step refinement, decomposing a single deduction step in a sequence of steps. • Extension of a schema by considering a larger class of grammars. In order to decrease the number of items and deduction steps in a parsing schema, we can apply the following kinds of filtering: • Static filtering, i</context>
</contexts>
<marker>Shieber, Schabes, Pereira, 1995</marker>
<rawString>Stuart M. Shieber, Yves Schabes, and Fernando C. N. Pereira. 1995. Principles and implementation of deductive parsing. Journal of Logic Programming, 24(18z2):3-36, July-August.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Klaas Sikkel</author>
</authors>
<title>Parsing Schemata — A Framework for Specification and Analysis of Parsing Algorithms.</title>
<date>1997</date>
<booktitle>Texts in Theoretical Computer Science — An EATCS Series.</booktitle>
<publisher>SpringerVerlag,</publisher>
<location>Berlin/Heidelberg/New York.</location>
<contexts>
<context position="4748" citStr="Sikkel, 1997" startWordPosition="852" endWordPosition="853">ive closure of = is denoted 3 . In a abuse of notation, we also use 3 to represent derivations involving an adjunction. So, 6 3 v if there are 5&apos;, 5&amp;quot;, M7, v such that 6 = 6&apos; M-Y (5&amp;quot; , R 3 viV v3, E adj(M7), 11(7 v2 and v = Yvi v2v36&amp;quot; . Given two pairs (p, q) and (i, j) of integers, (p, q) &lt; (i, j) is satisfied if i &lt;p and q &lt; j . Given two integers p and q we define p U q as p if q is undefined and as q if p is undefined, being undefined in other case. 1.1 Parsing Schemata We will describe parsing algorithms using Parsing Schemata, a framework for high-level description of parsing algorithms (Sikkel, 1997). An interesting application of this framework is the analysis of the relations between different parsing algorithms by studying the formal relations between their underlying parsing schemata. Originally, this framework was created for context-free grammars but we have extended it to deal with tree adjoining grammars. A parsing system for a grammar G and string al a„ is a triple (1,7-1, D), with I a set of items which represent intermediate parse results, 74 an initial set of items called hypothesis that encodes the sentence to be parsed, and D a set of deduction steps that allow new items to </context>
<context position="6074" citStr="Sikkel, 1997" startWordPosition="1079" endWordPosition="1080"> Th of a deduction step are present and the conditions cond are satisfied, then the consequent e should be generated by the parser. A set .T C I of final items represent the recognition of a sentence. A parsing schema is a parsing system parameterized by a grammar and a sentence. Parsing schemata are closely related to grammatical deduction systems (Shieber et al., 1995), where items are called formula schemata, deduction steps are inference rules, hypothesis are axioms and final items are goal formulas. A parsing schema can be generalized from another one using the following transformations (Sikkel, 1997): • Item refinement, breaking single items into multiple items. • Step refinement, decomposing a single deduction step in a sequence of steps. • Extension of a schema by considering a larger class of grammars. In order to decrease the number of items and deduction steps in a parsing schema, we can apply the following kinds of filtering: • Static filtering, in which redundant parts are simply discarded. • Dynamic filtering, using context information to determine the validity of items. • Step contraction, in which a sequence of deduction steps is replaced by a single one. The set of items in a p</context>
</contexts>
<marker>Sikkel, 1997</marker>
<rawString>Klaas Sikkel. 1997. Parsing Schemata — A Framework for Specification and Analysis of Parsing Algorithms. Texts in Theoretical Computer Science — An EATCS Series. SpringerVerlag, Berlin/Heidelberg/New York.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Krishnamurti Vijay-Shanker</author>
<author>Aravind K Joshi</author>
</authors>
<title>Some computational properties of tree adjoining grammars.</title>
<date>1985</date>
<booktitle>In 23rd Annual Meeting of the Association for Computational Linguistics,</booktitle>
<pages>82--93</pages>
<publisher>ACL.</publisher>
<location>Chicago, IL, USA,</location>
<contexts>
<context position="965" citStr="Vijay-Shanker and Joshi, 1985" startWordPosition="138" endWordPosition="141">escribe several tabular algorithms for Tree Adjoining Grammar parsing, creating a continuum from simple pure bottom-up algorithms to complex predictive algorithms and showing what transformations must be applied to each one in order to obtain the next one in the continuum. 1 Introduction Tree Adjoining Grammars are a extension of CFG introduced by Joshi in (Joshi, 1987) that use trees instead of productions as the primary representing structure. Several parsing algorithms have been proposed for this formalism, most of them based on tabular techniques, ranging from simple bottom-up algorithms (Vijay-Shanker and Joshi, 1985) to sophisticated extensions of the Earley&apos;s algorithm (Schabes and Joshi, 1988; Schabes, 1994; Nederhof, 1997). However, it is difficult to inter-relate different parsing algorithms. In this paper we study several tabular algorithms for TAG parsing, showing their common characteristics and how one algorithm can be derived from another in turn, creating a continuum from simple pure bottom-up to complex predictive algorithms. Formally, a TAG is a 5-tuple G = (vN, VT, S, I, A), where VN is a finite set of non-terminal symbols, VT a finite set of terminal David Cabrero Departamento de Computacion</context>
<context position="7007" citStr="Vijay-Shanker and Joshi, 1985" startWordPosition="1237" endWordPosition="1240">y the following kinds of filtering: • Static filtering, in which redundant parts are simply discarded. • Dynamic filtering, using context information to determine the validity of items. • Step contraction, in which a sequence of deduction steps is replaced by a single one. The set of items in a parsing system PAig corresponding to the parsing schema Alg describing a given parsing algorithm Alg is denoted &apos;mg, the set of hypotheses 7/Aig, the set of final items .TAlg and the set of deduction steps is denoted Dmg 2 A CYK-like Algorithm We have chosen the CYK-like algorithm for TAG described in (Vijay-Shanker and Joshi, 1985) as our starting point. Due to the intrinsic limitations of this pure bottom-up algorithm, the grammars it can deal with are restricted to those with nodes having at most two children. The tabular interpretation of this algorithm works with items of the form j I p,q I adj] such that N 3 ai+i ...a, F-Y aq+1...ai a,±1 ...ai if and only if (p, q) (— , —) and N&apos;Y ai if and only if (p, q) = (— , —), where 1\71&apos; is a node of an elementary tree with a label belonging to VN. The two indices with respect to the input string i and j indicate the portion of the input string that has been derived from N. </context>
<context position="8900" citStr="Vijay-Shanker and Joshi, 1985" startWordPosition="1586" endWordPosition="1589">are forbidden. A value of false indicates that no adjunction was performed on that node. In this case, during future processing this item can play the role of the item recognizing the excised part of an elementary tree to be attached to the foot node of an auxiliary tree. As a consequence, only one adjunction can take place on an elementary node, as is prescribed by the tree adjoining grammar formalism (Schabes and Shieber, 1994). As an additional advantage, the algorithm does not need to require the restriction that every auxiliary tree must have at least one terminal symbol in its frontier (Vijay-Shanker and Joshi, 1985). Schema 1 The parsing systems PCYK corresponding to the CYK-line algorithm for a tree adjoining grammar G and an input string al . • • an is defined as follows: IcyK = { j I p,q I adj] } such that N7 E P(7), label(N7) EVN, 1,E/1J A, 0 &lt; i &lt;j, (p,q) &lt; (i, j), adj E {true, false} WCYK { [a,i-1,i]la=ai,1&lt;i&lt;n } [a, — 1,i] N7 -4 a DScan CYK [N-y 1,i I — I false] Vt:YK = [N- ,i,i — I false] N7 -4 E Dr;Vt &lt;i = [F7 j I j false] ,i,k I p,q I adj], D =LeftDorn , k, j — adj] CYK [N-r,i,j I p,q I false] such that N7 M7 P7 E P(-y), M7 E spine(7) Kr,i,k — I adj], RightDom tP7, k, j I p, q I adj] DCYK j I p</context>
<context position="24462" citStr="Vijay-Shanker and Joshi, 1985" startWordPosition="4680" endWordPosition="4683">I P) h,F7 -4 .L•, p, q I p,q , ,,,Adjcompe —&gt; 6 • M7 v,i, j I —, —1 _ &apos;-&apos; Earley — [h, N-r SM 7 • 1/, p, such that 0 E adj(M7) FM&amp;quot; m p,q]}, DAdicomp _ N&amp;quot; —&gt; 6 • Mv,i,jp,q] Earley — [h, N -+ (WY • 1/, i,771, I p, q] such that 13 E adj(M7) ninit nS n V&apos;-&amp;quot; Pred &amp;quot;Earley &amp;quot; &amp;quot;Earley &amp;quot; &amp;quot;Earley&amp;quot; ,-,Comp q-,AdjPred u Dpary otePredu &apos;Earley &amp;quot;&apos;Earley ,r,FootComp ,r,AdjComp°, &apos;Earley &amp;quot;Earley .7-)AdjComp1&apos; nAdjeorn Earley p2&apos; &amp;quot;Earley &apos; TEarley — { [0, T •, 0, It I —7 —] I a E 6 Conclusion We have described a set of parsing algorithms for TAG creating a continuum which has the CYK-like parsing algorithm by (Vijay-Shanker and Joshi, 1985) as its starting point and the Earley-like parsing algorithm by (Nederhof, 1997) preserving the valid prefix property with time Earley — [11, N&apos;Y -4 6 • M7 v,i, k I p,q1, Comp = [h, M7 -4 v., k, j I p&apos;, [h, N 6m-t • v, i,j I pU p&apos;, q U q&apos;l DFootPred Earley — nFootComp = &apos;Earley such that 0 q&apos; are defined DEarley = 156 Proceedings of EACL &apos;99 complexity 0(n6) as its goal. As intermediate algorithms, we have defined a bottom-up Earley-like parsing algorithm and an Earley-like parsing algorithm without the valid prefix property, which to our knowledge has not been previously described in literatu</context>
</contexts>
<marker>Vijay-Shanker, Joshi, 1985</marker>
<rawString>Krishnamurti Vijay-Shanker and Aravind K. Joshi. 1985. Some computational properties of tree adjoining grammars. In 23rd Annual Meeting of the Association for Computational Linguistics, pages 82-93, Chicago, IL, USA, July. ACL.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Krishnamurti Vijay-Shanker</author>
<author>David J Weir</author>
</authors>
<title>Parsing some constrained grammar formalisms.</title>
<date>1993</date>
<journal>Computational Linguistics,</journal>
<pages>19--4</pages>
<contexts>
<context position="22301" citStr="Vijay-Shanker and Weir, 1993" startWordPosition="4213" endWordPosition="4216">mp2h, -+6 • Ite 731 &apos;41] Earley N,y _4 6m-.7 • v,i,m pi, such that 0 E adj(M&amp;quot;) DEInaitley U DScari I .7-)Pred Earley L&apos;Earley`-&apos; DComp, q-,AdjPred nFootPredi Earley &apos;Earley &amp;quot;&apos;Earley ,ThFootComp ilAdjCompi , 1-,AdjComp2 Earley &amp;quot;&apos;Earley &apos;Earley &amp;quot; &amp;quot;Earley -nScan &amp;quot;Earley -r,Pred &apos;Earley .1-)Comp &amp;quot;Earley DEarley = 155 Proceedings of EACL &apos;99 Now, we must refine steps in DEAadiferwl into AdjComp° AdjComp&apos;&apos; steps in DEarley and DEariey , and reAadriiceyo p° fine steps in DEAadifey0mp2 into steps in DE and DEticeyomp2&apos; Correctness of these splittings is guaranteed by the context-free property of TAG (Vijay-Shanker and Weir, 1993) establishing the independence of each adjunction with respect to any other adjunction. After step refinement, we get the Earley-like parsing algorithm for TAG described in (Nederhof, 1997), which preserves the valid prefix property having a time complexity 0(n6) with respect to the input string. In this schema we also need to define a new kind of intermediate pseudo-items [[N7 • v, j p,q]] such that ai ap aq+i aj ai if and only if (p, q) (—,—) and 6 &apos;4 a, ...a3 if and only if (p, q) = (—, —) . Schema 5 The parsing system PEariey corresponding to a the final Earley-like parsing algorithm with </context>
</contexts>
<marker>Vijay-Shanker, Weir, 1993</marker>
<rawString>Krishnamurti Vijay-Shanker and David J. Weir. 1993. Parsing some constrained grammar formalisms. Computational Linguistics, 19(4):591-636.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Krishnamurti Vijay-Shanker</author>
<author>David J Weir</author>
<author>Aravind K Joshi</author>
</authors>
<title>Characterizing structural descriptions produced by various grammatical formalisms.</title>
<date>1987</date>
<booktitle>In Proc. of the 25th Annual Meeting of the Association for Computational Linguistics,</booktitle>
<pages>104--111</pages>
<publisher>ACL.</publisher>
<location>Buffalo, NY, USA,</location>
<marker>Vijay-Shanker, Weir, Joshi, 1987</marker>
<rawString>Krishnamurti Vijay-Shanker, David J. Weir, and Aravind K. Joshi. 1987. Characterizing structural descriptions produced by various grammatical formalisms. In Proc. of the 25th Annual Meeting of the Association for Computational Linguistics, pages 104-111, Buffalo, NY, USA, June. ACL.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>