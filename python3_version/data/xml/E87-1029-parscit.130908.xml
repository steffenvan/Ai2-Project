<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000001">
<note confidence="0.497952">
AUXILIARIES AND CLITICS IN FRENCH
</note>
<bodyText confidence="0.958039666666667">
UCG GRAMMAR
by K. BASCHUNG ., G.G BES **, A. CORLUY GUILLOTIN ***
&amp;quot; Universite de Clermont II, 34 Avenue Carnot, F-63037 Clermont-Ferrand (France)
*** Laboratoires de Marcoussis, Route de Nozay, F-91460 Marcoussis
ABSTRACT
French auxiliaries and clitics have been analysed
in the frame of U.C.G. (Unification Categorial Grammar)
Concatenation of a functor sign and an adjacent argument
sign is the basic operation of the model ; unification
allows (a) to verify if constraints on concatenation are
respected ; (b) to produce a flow of information between
the functor sign and the argument sign.
The rules of the grammar and the design structure
of the sign allows to express : (a) the concatenation
between French auxiliaries (etre and avoir) and the
participle verb form within a single pattern, (b) transitions
between clitics in a systematic way. Two complex
questions of French syntax are thus covered in a fairly
simple way.
The UCG Model
U(nification). C(ategorial) G(rammar) is a new
grammatical model proposed by an Edinburgh team
headed by Ewan Klein in [CALDER 86] and [ZEEVAT
86]. UCG is a feature grammar incorporating some basic
insights from GPSG [GAZDAR 85] and HPSG
[POLLARD 84]. Functional application applies in UCG
as in categorial grammars; it allows for concatenation of a
functor with an adjacent argument. Unification is a basic
operation which allows (a) to verify if constraints on
concatenation are respected; (b) to produce a flow of
information between functor and argument. This
information together with some defined aspects of the
information carried by the functor, will be finally
inscribed in the resulting concatenated sign.
The Sign
A UCG sign has the following format:
</bodyText>
<equation confidence="0.9819084">
(1)
sign --&gt; category:semantics:order:phonology
category --&gt; headleatures:catlist
features —&gt; [feat,clo,agree,class]
catlist —&gt; nil
catlist —&gt; catlist/active
active —&gt; sign
semantics —&gt; index
semantics —&gt; index:predicate:arglist
arglist —&gt; agrl, ,argn
</equation>
<bodyText confidence="0.99935975">
The work reported here was carried out as part of
ESPRIT Project 393 (ACORD), &amp;quot;The construction and In-
terrogation of Knowledge Bases using Natural Language
Text and Graphics&amp;quot;
</bodyText>
<equation confidence="0.8708935">
order —&gt; pre I post
phonology —&gt; &lt;lexicalitem&gt;
</equation>
<bodyText confidence="0.962772857142857">
In graph notation, a UCG sign can be represented
(in a slightly simplified form, relevant to this paper) as in
figure 1.
In this figure the leaves of vertical branches
columns (i) through (viii) - denote the values of the
corresponding labels in its upper portion.
We have:
</bodyText>
<listItem confidence="0.9734025">
(i) to (vi) Simple categories: sent:nil, noun&amp;quot;_:nil.
(ii) Features on (i) (see below)
(iii) values for the CL(itics) label are: prod (dialogue
pronouns, for me , te, nous, vous); protob (third person
object pronouns: le, la, les); prota (third person dative
pronouns: lui, leu&apos;) ; se, en and y, (for se, en and y
pronouns respectively) ; n is a barrier symbol (see
below).
(iv and v) values for morphological aspects of the sign:
(v) categorizes signs in lex(ical) and pron(ominal) ones,
(iv) in masc(ulin) and fem(inin), in sing(ular) and
pl(ural), and introduces values for the 3 persons.
(vi) the subcatlist : the label C will denote the typical
variable for it.
(vii) the index sort system (which is not exhibited here)
allows selection on semantic features while a special field
(pr_res) contains information (agreement, class and COR)
for the pronoun resolution component.
</listItem>
<bodyText confidence="0.968383473684211">
COR(eference) is intended to prepare the semantic
representation for pronoun resolution. The corresponding
values are: obl(igatory), for bound anaphora as in se ;
ind(ependent), for NP nominals of indicative sentences
and dep(endent) for NP nominals of subjunctive ones (the
algorithm for pronoun resolution will not be presented
here, but the semantic representation specified by the
proposed grammar is intended to carry all the required
relevant information).
(viii) post and pre are the values for order; they are
essential for handling word order and for the application
of the grammar rules.
In the unification process and in the generation of
the subsequent flow of information, the labels Class, Ge,
Nb and Pe denote variables for the corresponding values,
Clo the variable for clitic placement value and 0, the
variable for order values.
The two following are the French UCG signs for
aime and Marie:
</bodyText>
<page confidence="0.996866">
173
</page>
<figure confidence="0.985681352941176">
(5) BA (Backward Application)
Argument:
HA:CA:SA:post:WI
Functor :
HF
:CF/(HA:CA:SA:post:_)
(b) Marie :SF
:OF
Head&amp;quot;[Feat,Clo,Ag,Class] :W2
:C/ (Head&amp;quot;[Feat,_,Ag,Class]
:C/(nplor(nom,acc),Clogem:sg:p3),lex] -&gt; HF:CF:SF:OF:[NV1,W2]
:nikmarie:Ord:_)
:Sem We added two rules to these, inspired by
:Ord functional composition as described in [STEEDMAN 861.
:_)
:Sem (6) FC (Forward Composition)
:0
Functor :
:marie
(2) (a) aime
sent&apos; [fin,v,(_:sg:p3),_]
:niJ/np&amp;quot;[nom,n,(_:sg:p3),_]:nil:X:pre:_
/np&amp;quot;[ Y:po st:_
:and(e,at(e,now),aimer(e,X,Y))
:0
:aime
Categories HF
:CF/(HA:CA:SA:pre:_)
Categories are defined by :SF
(3) (a) A simple category is a category. :OF
(b) If H:C is a category and if Si is a sign, H:(C/Si) :W1
is a category.
Rules
Argument:
</figure>
<bodyText confidence="0.9828565">
[ZEEVAT 86] describes 2 grammar rules based on
functional application.
</bodyText>
<equation confidence="0.875027225806452">
(4) FA (Forward Application)
Functor :
HF
:CF/(HA:CA:SA:pre:_)
:SF
:OF
:W1
Argument:
HA:CA:SA:pre:W2
-&gt; HF:CF:SF:OF:[W1,W2]
HA:CA/(np&amp;quot;[Fe,_,Ag,&amp;quot;
-&gt; HF
:CF/(np&amp;quot;[Fe,n,Ag,&amp;quot; lex]:nil:X:pre:_)
:SF
:OF
:[W1,W2]
FC is basically designed to deal with np-gaps.
(7) BC (Backward Composition)
Argument:
HA:CA/(np&amp;quot;Feats:nil:X:0:_):SA:post:W1
Functor :
HF
:CF/(HA:CA:SA:post:_)
:SF
:SO
:W2
-&gt; HF
:CF/(np&amp;quot;Feats:nil:X:0:_)
:SF
:OF
:[W1,W2]
</equation>
<bodyText confidence="0.94853175">
where PROLOG conventions are respected: lower BC is designed to deal with free-order of np-
case = constant, upper case = variable, _ = anonymous arguments of verbs
variable Forward application must be interpreted as
follows :
</bodyText>
<page confidence="0.990903">
174
</page>
<bodyText confidence="0.966698823529412">
If a sign of string W1 and category HF:CF/(HA:CA)
unifies with a sign of string W2 and category HA:CA,
W1 concatenates with W2; the resulting sign, with string
[W1,W2], is of category HF:CF, where HF:CF is the
category inherited from the functor as resulting from
unification with its argument,and stripping HA:CA.
Mutadis mutandis, analogous interpretations must
be given to (5) through (7).
By definition (3) HA:CA in HF:CF/(HA:CA) of (4)
must be a sign; it is the active part of the functor. The
final concatenated sign is obtained by stripping the active
part of the functor as instantiated by the argument.
Example
For example: (8) is the instantiation by BA of
(2b) as the functor with respect to (2a) as the argument of
the rule; (9) is the resulting sign, obtained from (8) by
stripping; (10) represents the sign of the whole sentence
</bodyText>
<figure confidence="0.943784307692308">
Pierre aime Marie:
(8) Marie
senC[fin,m,(_:sg:p3),Class]
:nil/np[nom,n,(Gel:sg:p3),Classl ] :nil:X:pre:P 1
/(senr[fin,_,(_:sg:p3),Class]
:ni1/np^[nom,n,(Ge1:sg:p3),Class1]:nil:X:pre:P1
/nplacc,m,(fem:sg:p3),lextnil:marie:post.:_
:and(e,at(e,now),aimer(e,X,marie))
:post
:aime)
:and(e,at(e,now),aimer(e,X,marie))
:0
:marie
(9) aime Marie
sentlfin,m,C:sg:p3),Class]
:nil/np[nom,n,(Gel :sg:p3),_]:nil:X:pre:P1
:and(e,at(e,now),aimer(e,X,marie))
:0
:[aime,marie]
(10) Pierre aime Marie
senC[fin,n,(_:sg:p3),Class]
:nil
:and(e,at(e,now),aimer(e,pierre,marie))
:0
:[pierre,[aime,mariel]
Semantics
</figure>
<bodyText confidence="0.992521166666667">
The semantics of UCG incorporates the basic
insights of Kamp&apos;s DRT [KAMP 81] but the introduction
of indexes greatly increases the expressive power of
semantic representations (cf. [ZEEVAT 86]).
To resume :
The whole model is based on :
one unique operation : concatenation between
adjacent consti Wants.
one unique process to control the flow of
information and to verify conditions: unification.
similar ways to combine a functor and its argument
to give a resulting sign.
</bodyText>
<table confidence="0.6651142">
The French sentence
simple verbs
They accept left-placed arguments (as clitics) and
rigth-placed ones (as lexical ones).
composed verbal forms
</table>
<tableCaption confidence="0.957376">
No argument can be inserted between the auxilliary
and the participle form.
Whereas in English only one auxiliary is used to
construct perfect tenses, French uses avoir and etre
depending on the main verb. Furthermore, etre is also
used for passive constructions.
</tableCaption>
<bodyText confidence="0.950171375">
The most important problem, however, is due to
the agreement of the past participle with the subject of
the main verb when used with etre, but with the object
-only if it precedes the auxiliary- when used with avoir.
However, we succeeded to maintain a single
lexical entry for a verb, allowing for the different order of
arguments. This is made possible by the introduction of
forward and backward composition rules.
</bodyText>
<sectionHeader confidence="0.903501" genericHeader="abstract">
AUXILIARIES
</sectionHeader>
<bodyText confidence="0.995550277777778">
The following are the main features allowing a
correct treatment of auxiliaries in a French UCG
grammar
Features as presented in Figure 1 column (ii) :
PSPA for past participles of verbs using avoir as
auxiliary, PSPE for verbs used with etre, PAS for passive
participle. They allow for the distinction between finite
and non-finite forms and between participles used with
avoir or etre.
Values for the CL label: v value denotes the fact
that the verb is &amp;quot;virgin&amp;quot; i.e. has not consumed any of its
arguments.
Values for GE, NB, PERS allow for correct
agreement of the past participle and between auxiliary
and subject.
A unique format for perfect tenses with avoir and
etre and for passive constructs with etre was designed as
follows :
</bodyText>
<equation confidence="0.8008205">
(12) auxiliary general design
sentlfin,v,Ag,Class]
:C/senr[FEAT,v,Ag,Class]):C:Sem:pre:_
:Sem
:0
:STRING
</equation>
<bodyText confidence="0.999111111111111">
where STRING and FEAT can take values avoir and
pspa or etre and pspe or pas; the agreement of the
auxiliary unifying with the agreement of the participle
will insert the correct agreement on the nominative
argument in the participle and thus will control the
agreement of the subject with the auxiliary-participle unit.
One of the main achievements of our French UCG
grammar is to have a single lexical entry for a verb,
nonwithstanding differences in semantics according to
</bodyText>
<page confidence="0.997459">
175
</page>
<bodyText confidence="0.990776375">
tense, free word order, and constrained word order due to
clitics.
Standard lexical entries present word order as for
non-clitic arguments, and semantics as for the infinitive.
A morphological component allows for a dynamic
transformation of these entries according to tense gender
and person.
Thus, typical entries look like:
</bodyText>
<figure confidence="0.537462230769231">
(13) regarder
senr[fin,v,Ag,_]
:regarder(e,X,Y)
:0
:regarder
When analysing (motphologycally) the passive
participle (13) is transformed (by a special passive
lexical_rule) into :
(14) regard&amp;
sentlpas,v,(fem:sg:Pe),_]
:regarder(e,X,Y)
:0
:regardee
to be combined with an auxiliary as
(15) etre
senf [fin,v,(Ge:sg:p3),_]
:C/senflor(pspe,pas),v,(Ge:sg:p3),_]:C:S:pre:_
:S
:0
:est
yielding
(16) est regard&amp;
senC[fin,v,(fem:sg:p3),_]
:regarder(e,X,Y)]
:0
:[est,regardee]
</figure>
<bodyText confidence="0.986739">
This can then correctly be combined with the
subject Marie (2b) respecting the agreement auxiliary-
subject and subject-participle (because it is used with
etre)
</bodyText>
<sectionHeader confidence="0.728176" genericHeader="keywords">
CLITICS
</sectionHeader>
<bodyText confidence="0.9921325">
Beside the fact that clitics in French are always
placed before the verb or verb-auxilliary unit (as it was
said before) there are also restrictions concerning
placement between them.
It is thus necessary to specify (17 a) and to
exclude (17 b), among others.
</bodyText>
<listItem confidence="0.998566">
(17) (a) Marie luituo a donne un livre[s&amp;quot;)
(b) Marie a lui[dati donne un livre[acc]
</listItem>
<bodyText confidence="0.9987155">
The main problem with French clitics is that
arguments combine in a different order with the verb
according to (a) whether they are clitic or not and (b)
whether they are first/second person or third person.
</bodyText>
<listItem confidence="0.5324636">
(18) (a) Marie donne un livre(.1 a Pierre
Rtat]
(b) Marie luildati donne un livrewo
(c) Marie le1.1 luituti donne
(d) Marie meNat] le[awl donne
</listItem>
<bodyText confidence="0.994114166666667">
The core of conditions on clitic ordering in French
can be found in (19). These transitions are valid for
argumental elides and non-argumental ones (for example,
VP modifiers, as y in II y a apporte un livre), but the
present paper is only intended to cover the argumental
ones.
</bodyText>
<equation confidence="0.9969705">
(19) 2 prod[acc) prodidat] protob prom y agseel enjdej reface] se[dat]
—&gt; 0 • • 0 0 0 0 •
prodfacc) • 0 0 0 0 0 0 •
Prodidatl 0 • 0 0 a 0 0
protob • 0 • 00 a 0 •
prom • 0 00 • • •
enfatx1 0 • 0 0 •
trldci • • • • 0 0 •
se[accl 0 • 0 • 0
arida] • 0 0 0 0
</equation>
<bodyText confidence="0.903448333333333">
The complex information of the matrice are
included in a uniform way in the clitics lexical entries.
The basic template for elide is :
</bodyText>
<figure confidence="0.806796428571429">
Head&amp;quot;[Feat,C1o2,A,Class]
:C / (Head&amp;quot;[Feat,Clol,A,Class]
:S
:pre
:S
:0
:String
</figure>
<bodyText confidence="0.996237">
where the relation between C1o2 and Clo 1 constains the
matrice information relevant for each elide.
</bodyText>
<sectionHeader confidence="0.991361" genericHeader="introduction">
IMPLEMENTATION
</sectionHeader>
<bodyText confidence="0.971669363636364">
The UCG French grammar has been implemented
at the Laboratoires de Marcoussis (France) on a VAX 780
in C-PROLOG using PIMPLE, a PROLOG
implementation of a PATR-II like tool for development of
unification grammars, implemented by the Centre for
Cognitive Science of Edinburgh University.
Some more examples with auxiliaries and clitics
Entries for the sentence Marie la lui a donnee :
2 where G = grammatical, * = non grammatical, 0
= impossible (because an argument of a verb cannot be
consumed twice)
</bodyText>
<page confidence="0.991181">
176
</page>
<figure confidence="0.996653223880597">
(20) la lui with [a,donnie] by FA yielding:
Head&amp;quot;[Feat,protob,A,Class] sent&amp;quot;[fin,prota,(_:sg:p3),_]
:C / (Head&amp;quot;[Feat,or(prota,y,m,v),A,Class] :nil/np&amp;quot;[nom,n,(_:sg:p3),_]:nil:X:pre:_
:C/nplacc,_,(fem:sg:p3),prol:nil:pro(X):_:_ /nplacc,n,(fem:sg:_),prol:nitY:pre:_
:S :donner(e,X,pro(Z),Y)]
:pre :0
:[lui,[a,domide]]
:S la with [lui,[a,dormien by FA yielding:
:0
:la senr[fin,protob,(_:sg:p3),_]
(21) Jut :donner(e,X,pro(Z),pro(Y))
:0
Head&amp;quot;[Feat,prota,A,Class] :[1a,[lui,[a,donnee]]]
:C / (Head&amp;quot;[Feat,or(en,m,v),A,Class]
marie with fla,(lui,[a,donnie]]l by FA yielding:
:S
:pre sentlfin,n,(_:sg:p3),_]
:nil
:S :donner(e,marie,pro(Z),pro(Y))
:0 :0
:1 :[marie,[1a,[lui,[a,donnee]]]]
(22) a Entries for the sentence Marie lui est doruthe :
dormer as modified by morphological rules into a
past participle:
sentlfin,v,(_:sg:p3),Class]
:C/senflpspa,v,(_:sg:p3),Class]:C:Sem:pre:_
:Sem
:0
:a
(23) dorm&amp;
(24) est
sentlfin,v,Ag,Class]
:Osene[or(pas,pspe),v,Ag,Class]:C:Senrpre:_
:Sem
:0
:est
(25) donnee
sentlpas,v,(fem:sg:Pe),_]
senr[pspa,v,Ag,_]
/nplacc,n,(fem:sg:),protnil:Y:pre:_ :donner(e,unknown,Z,Y)
:0
:donner(e,X,Z,Y) :donnee
:0
:donnee est with dormee by FA yielding:
are combined in the following way:
a with dorinee by FA yielding:
sentlfin,v,(_:sg:p3),_1
/nplacc,n,(fem:sg:_),proknil:Y:pre:_
:donner(e,X,Z,Y)
:0
:[a,donnde]
sent&amp;quot;[fin,v,(fem:sg:Pe),_]
:donner(e,unknown,Z,Y)
:0
:[est,donnee]
lui with lest,dorusie] by FA yielding:
sentlfin,v,(fem:sg:Pe),_]
:donner(e,unknown,pro(Z),Y)
:0
Ilui,[est,donnee]]
177
Marie with [luidest,donnien by FA yielding:
sent&amp;quot;[fin,v,(fem:sg:Pe),_]
:nil
:donner(e,unknown,pro(Z),marie)
:0
:[Marie,[lui,[est,donnde]]]
</figure>
<sectionHeader confidence="0.814914" genericHeader="references">
REFERENCES
</sectionHeader>
<reference confidence="0.983648333333333">
[CALDER 86]
CALDER, KLEIN, MOENS, ZEE VAT, Problems of
Dialogue Parsing, ACORD deliverable T2.1, Edinburgh,
1986.
[GAZDAR 85]
GAZDAR, KLEIN, PULLUM, SAG, Generalized Phrase
Structure Grammar, London, Basil Blackwell, 1985.
[ICAMP 81]
KAMP, A theory of Truth and Semantic Representation.
In Groenendijk, Janssen and Stokhof (eds) Formal
Methods in the Study of Language, Volume 136, pp277-
322. Amsterdam, Mathematical Centre Tracts.
[POLLARD 84]
PROUDIAN and POLLARD, Parsing Head-driven Phrase
Structure Grammar. In Proceedings of the 23rd Annual
Meeting of the Association for Computational Linguistics,
University of Chicago, Chicago, Illinois, 8-12 July, 1985,
pp167-171.
[STEEDMAN 86]
STEEDMAN, Incremental Interpretation in Dialogue,
ACORD deliverable T2.4, Edinburgh, 1986.
[ZEEVAT 86]
ZEE VAT, KLEIN, CALDER, Unification Categorial
Grammar, Edinburgh, 1986.
</reference>
<page confidence="0.997182">
178
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.000004">
<title confidence="0.9934075">AUXILIARIES AND CLITICS IN FRENCH UCG GRAMMAR</title>
<author confidence="0.98857">G G BES</author>
<affiliation confidence="0.542438">amp;quot; Universite de Clermont II, 34 Avenue Carnot, F-63037 Clermont-Ferrand (France)</affiliation>
<address confidence="0.428746">Laboratoires de Marcoussis, Route de Nozay, F-91460 Marcoussis</address>
<abstract confidence="0.994009611111112">French auxiliaries and clitics have been analysed in the frame of U.C.G. (Unification Categorial Grammar) Concatenation of a functor sign and an adjacent argument sign is the basic operation of the model ; unification allows (a) to verify if constraints on concatenation are respected ; (b) to produce a flow of information between the functor sign and the argument sign. The rules of the grammar and the design structure of the sign allows to express : (a) the concatenation French auxiliaries the participle verb form within a single pattern, (b) transitions between clitics in a systematic way. Two complex questions of French syntax are thus covered in a fairly simple way. The UCG Model C(ategorial) G(rammar) is a new grammatical model proposed by an Edinburgh team headed by Ewan Klein in [CALDER 86] and [ZEEVAT 86]. UCG is a feature grammar incorporating some basic insights from GPSG [GAZDAR 85] and HPSG [POLLARD 84]. Functional application applies in UCG as in categorial grammars; it allows for concatenation of a functor with an adjacent argument. Unification is a basic operation which allows (a) to verify if constraints on concatenation are respected; (b) to produce a flow of information between functor and argument. This information together with some defined aspects of the information carried by the functor, will be finally inscribed in the resulting concatenated sign. The Sign A UCG sign has the following format: (1) sign --&gt; category:semantics:order:phonology category --&gt; headleatures:catlist features —&gt; [feat,clo,agree,class] catlist —&gt; nil catlist —&gt; catlist/active active —&gt; sign semantics —&gt; index semantics —&gt; index:predicate:arglist arglist —&gt; agrl, ,argn The work reported here was carried out as part of ESPRIT Project 393 (ACORD), &amp;quot;The construction and Interrogation of Knowledge Bases using Natural Language Text and Graphics&amp;quot; order —&gt; pre I post phonology —&gt; &lt;lexicalitem&gt; In graph notation, a UCG sign can be represented (in a slightly simplified form, relevant to this paper) as in figure 1. In this figure the leaves of vertical branches columns (i) through (viii) denote the values of the corresponding labels in its upper portion. We have: (i) to (vi) Simple categories: sent:nil, noun&amp;quot;_:nil. (ii) Features on (i) (see below) values for the CL(itics) label are: for me , te, vous); protob person pronouns: la, les); prota person dative leu&apos;) ; se, en y, (for en y pronouns respectively) ; n is a barrier symbol (see below). (iv and v) values for morphological aspects of the sign: (v) categorizes signs in lex(ical) and pron(ominal) ones, in masc(ulin) in sing(ular) and pl(ural), and introduces values for the 3 persons. (vi) the subcatlist : the label C will denote the typical variable for it. (vii) the index sort system (which is not exhibited here) allows selection on semantic features while a special field (pr_res) contains information (agreement, class and COR) for the pronoun resolution component. COR(eference) is intended to prepare the semantic representation for pronoun resolution. The corresponding are: obl(igatory), for bound anaphora as in ; ind(ependent), for NP nominals of indicative sentences and dep(endent) for NP nominals of subjunctive ones (the algorithm for pronoun resolution will not be presented here, but the semantic representation specified by the proposed grammar is intended to carry all the required relevant information). post the values for are essential for handling word order and for the application of the grammar rules. In the unification process and in the generation of the subsequent flow of information, the labels Class, Ge, Nb and Pe denote variables for the corresponding values, Clo the variable for clitic placement value and 0, the variable for order values.</abstract>
<note confidence="0.643778842105263">The two following are the French UCG signs for 173 (5) BA (Backward Application) Argument: HA:CA:SA:post:WI Functor : HF :CF/(HA:CA:SA:post:_) :OF Head&amp;quot;[Feat,Clo,Ag,Class] :W2 :C/ (Head&amp;quot;[Feat,_,Ag,Class] :C/(nplor(nom,acc),Clogem:sg:p3),lex] -&gt; HF:CF:SF:OF:[NV1,W2] :nikmarie:Ord:_) :Sem We added two rules to these, inspired by :Ord functional composition as described in [STEEDMAN 861. :_) :Sem (6) FC (Forward Composition) :0 Functor :</note>
<abstract confidence="0.704646285714286">marie (a) sent&apos; [fin,v,(_:sg:p3),_] :niJ/np&amp;quot;[nom,n,(_:sg:p3),_]:nil:X:pre:_ /np&amp;quot;[ Y:po st:_ :and(e,at(e,now),aimer(e,X,Y)) :0 :aime Categories HF :CF/(HA:CA:SA:pre:_) Categories are defined by :SF (3) (a) A simple category is a category. :OF (b) If H:C is a category and if Si is a sign, H:(C/Si) :W1 is a category. Rules Argument: [ZEEVAT 86] describes 2 grammar rules based on functional application. (4) FA (Forward Application) Functor : HF :CF/(HA:CA:SA:pre:_) :SF :OF :W1 Argument: HA:CA:SA:pre:W2 -&gt; HF:CF:SF:OF:[W1,W2] HA:CA/(np&amp;quot;[Fe,_,Ag,&amp;quot; -&gt; HF :CF/(np&amp;quot;[Fe,n,Ag,&amp;quot; lex]:nil:X:pre:_) :SF :OF :[W1,W2] FC is basically designed to deal with np-gaps.</abstract>
<note confidence="0.941402666666667">(7) BC (Backward Composition) Argument: HA:CA/(np&amp;quot;Feats:nil:X:0:_):SA:post:W1</note>
<title confidence="0.598954">Functor : HF</title>
<abstract confidence="0.921958666666667">CF/(HA:CA:SA:post:_) :SF :SO :W2 -&gt; HF :CF/(np&amp;quot;Feats:nil:X:0:_) :SF :OF :[W1,W2] PROLOG conventions are respected: lower BC is designed to deal with free-order of npcase = constant, upper case = variable, _ = anonymous arguments of verbs variable Forward application must be interpreted as follows : 174 If a sign of string W1 and category HF:CF/(HA:CA) unifies with a sign of string W2 and category HA:CA, W1 concatenates with W2; the resulting sign, with string [W1,W2], is of category HF:CF, where HF:CF is the category inherited from the functor as resulting from unification with its argument,and stripping HA:CA. Mutadis mutandis, analogous interpretations must be given to (5) through (7). By definition (3) HA:CA in HF:CF/(HA:CA) of (4) must be a sign; it is the active part of the functor. The final concatenated sign is obtained by stripping the active part of the functor as instantiated by the argument. Example For example: (8) is the instantiation by BA of (2b) as the functor with respect to (2a) as the argument of the rule; (9) is the resulting sign, obtained from (8) by stripping; (10) represents the sign of the whole sentence Pierre aime Marie: (8) Marie senC[fin,m,(_:sg:p3),Class] :nil/np[nom,n,(Gel:sg:p3),Classl ] :nil:X:pre:P 1 /(senr[fin,_,(_:sg:p3),Class] :ni1/np^[nom,n,(Ge1:sg:p3),Class1]:nil:X:pre:P1 /nplacc,m,(fem:sg:p3),lextnil:marie:post.:_ :and(e,at(e,now),aimer(e,X,marie)) :post :aime) :and(e,at(e,now),aimer(e,X,marie)) :0 :marie (9) aime Marie sentlfin,m,C:sg:p3),Class] :nil/np[nom,n,(Gel :sg:p3),_]:nil:X:pre:P1 :and(e,at(e,now),aimer(e,X,marie)) :0 :[aime,marie] (10) Pierre aime Marie senC[fin,n,(_:sg:p3),Class] :nil :and(e,at(e,now),aimer(e,pierre,marie)) :0 :[pierre,[aime,mariel] Semantics</abstract>
<intro confidence="0.405994">The semantics of UCG incorporates the basic</intro>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="false">
<note>[CALDER 86]</note>
<marker></marker>
<rawString>[CALDER 86]</rawString>
</citation>
<citation valid="true">
<authors>
<author>KLEIN CALDER</author>
<author>ZEE VAT MOENS</author>
</authors>
<date>1986</date>
<booktitle>Problems of Dialogue Parsing, ACORD deliverable T2.1,</booktitle>
<location>Edinburgh,</location>
<marker>CALDER, MOENS, 1986</marker>
<rawString>CALDER, KLEIN, MOENS, ZEE VAT, Problems of Dialogue Parsing, ACORD deliverable T2.1, Edinburgh, 1986.</rawString>
</citation>
<citation valid="true">
<authors>
<author>KLEIN GAZDAR</author>
<author>SAG PULLUM</author>
</authors>
<date>1985</date>
<booktitle>Generalized Phrase Structure Grammar,</booktitle>
<location>London, Basil Blackwell,</location>
<marker>GAZDAR, PULLUM, 1985</marker>
<rawString>[GAZDAR 85] GAZDAR, KLEIN, PULLUM, SAG, Generalized Phrase Structure Grammar, London, Basil Blackwell, 1985.</rawString>
</citation>
<citation valid="false">
<authors>
<author>KAMP</author>
</authors>
<title>A theory of Truth and Semantic Representation.</title>
<booktitle>In Groenendijk, Janssen and Stokhof (eds) Formal Methods in the Study of Language,</booktitle>
<volume>136</volume>
<pages>277--322</pages>
<institution>Amsterdam, Mathematical Centre Tracts.</institution>
<marker>KAMP, </marker>
<rawString>[ICAMP 81] KAMP, A theory of Truth and Semantic Representation. In Groenendijk, Janssen and Stokhof (eds) Formal Methods in the Study of Language, Volume 136, pp277-322. Amsterdam, Mathematical Centre Tracts.</rawString>
</citation>
<citation valid="true">
<authors>
<author>PROUDIAN</author>
<author>POLLARD</author>
</authors>
<title>Parsing Head-driven Phrase Structure Grammar.</title>
<date>1985</date>
<booktitle>In Proceedings of the 23rd Annual Meeting of the Association</booktitle>
<pages>167--171</pages>
<institution>for Computational Linguistics, University of Chicago,</institution>
<location>Chicago, Illinois,</location>
<marker>PROUDIAN, POLLARD, 1985</marker>
<rawString>[POLLARD 84] PROUDIAN and POLLARD, Parsing Head-driven Phrase Structure Grammar. In Proceedings of the 23rd Annual Meeting of the Association for Computational Linguistics, University of Chicago, Chicago, Illinois, 8-12 July, 1985, pp167-171.</rawString>
</citation>
<citation valid="true">
<authors>
<author>STEEDMAN</author>
</authors>
<title>Incremental Interpretation in Dialogue,</title>
<date>1986</date>
<booktitle>ACORD deliverable T2.4,</booktitle>
<location>Edinburgh,</location>
<marker>STEEDMAN, 1986</marker>
<rawString>[STEEDMAN 86] STEEDMAN, Incremental Interpretation in Dialogue, ACORD deliverable T2.4, Edinburgh, 1986.</rawString>
</citation>
<citation valid="true">
<authors>
<author>ZEE VAT</author>
<author>CALDER KLEIN</author>
</authors>
<title>Unification Categorial Grammar,</title>
<date>1986</date>
<location>Edinburgh,</location>
<marker>VAT, KLEIN, 1986</marker>
<rawString>[ZEEVAT 86] ZEE VAT, KLEIN, CALDER, Unification Categorial Grammar, Edinburgh, 1986.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>