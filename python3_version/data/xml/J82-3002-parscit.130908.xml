<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<title confidence="0.910927">
An Efficient Easily Adaptable System
for Interpreting Natural Language Queries1
</title>
<author confidence="0.827028">
David H. D. Warren
</author>
<bodyText confidence="0.3108905">
and
Fernando C. N. Pereira
</bodyText>
<sectionHeader confidence="0.84393" genericHeader="method">
Artificial Intelligence Center
SRI International
333 Ravenswood Avenue
Menlo Park, CA 94025
</sectionHeader>
<bodyText confidence="0.99938">
This paper gives an overall account of a prototype natural language question answering
system, called Chat-80. Chat-80 has been designed to be both efficient and easily
adaptable to a variety of applications. The system is implemented entirely in Prolog, a
programming language based on logic. With the aid of a logic-based grammar formalism
called extraposition grammars, Chat-80 translates English questions into the Prolog subset
of logic. The resulting logical expression is then transformed by a planning algorithm into
efficient Prolog, cf. &amp;quot;query optimisation&amp;quot; in a relational database. Finally, the Prolog
form is executed to yield the answer. On a domain of world geography, most questions
within the English subset are answered in well under one second, including relatively
complex queries.
</bodyText>
<sectionHeader confidence="0.995179" genericHeader="method">
1. Introduction
</sectionHeader>
<bodyText confidence="0.9999703">
This paper describes the results of a three-year
research project carried out by the two of us. The
project was directed towards the goal of providing
practical computer systems that will answer questions
expressed in precisely defined subsets of natural lan-
guage. The results of our work are incorporated in a
running prototype system, called &amp;quot;Chat-80&amp;quot;.
Two issues have particularly influenced the ap-
proach we have taken, namely efficiency and portabili-
ty. Given the practical objective, we wanted to
achieve rapid, interactive question answering, and we
wanted the techniques to be easily adaptable to a vari-
ety of applications, with as much of the implementa-
tion code as possible being application independent
(cf. Konolige 1979).
There has been no intention to try to handle unres-
tricted natural language. Given the current state of
the art, we accept that users of a practical natural
language question answering system will have to learn
how to use a restricted natural language subset rele-
</bodyText>
<footnote confidence="0.579046">
1 This work was carried out in the Department of Artificial
</footnote>
<affiliation confidence="0.587916">
Intelligence, University of Edinburgh, Scotland.
</affiliation>
<bodyText confidence="0.952070444444444">
vant to the particular application. The important issue
is whether they will find this more convenient than a
more formal query language. We believe that, for
many purposes, a suitable natural language subset will
be much preferred, on grounds of conciseness and ease
of typing alone (see the examples in Appendix III, for
instance). It is fair to say that our objective is to so
constrain natural language that it becomes a formal,
but user-friendly, query language.
The starting point for our work was a question
answering system for a small subset of Spanish imple-
mented by Veronica Dahl 1981,1979, following the
approach advocated by Colmerauer 1978. We were
particularly attracted to Colmerauer&apos;s approach for the
clear insight it gives into some of the essential prob-
lems involved in constructing a practical natural lan-
guage answering system, especially the problem of
correctly interpreting determiners. In addition, it
proved very easy to adapt Dahl&apos;s program to English
(and to a different domain). This was due in large
part to the fact that the system is implemented in Pro-
log (Roussel 1975; Warren, Pereira, and Pereira
1977), a programming language based on first-order
logic. To be more specific, the system is largely made
Copyright 1982 by the Association for Computational Linguistics. Permission to copy without fee all or part of this material is granted
provided that the copies are not made for direct commercial advantage and the Journal reference and this copyright notice are included on
the first page. To copy otherwise, or to republish, requires a fee and/or specific permission.
</bodyText>
<page confidence="0.6616975">
0362-613X/82/03011043$03.00
110 American Journal of Computational Linguistics, Volume 8, Number 3-4, July-December 1982
</page>
<note confidence="0.977559">
David H.D. Warren and Fernando C.N. Pereira An Efficient Easily Adaptable System
</note>
<bodyText confidence="0.946773417910448">
up of rules of the metamorphosis grammar (MG) for-
malism (Colmerauer 1978), which map directly into
the Prolog subset of logic. MGs are an extension of a
simpler formalism to which we have given the name
definite clause grammars (DCGs) (Pereira and Warren
1980).
We called the adapted program &amp;quot;Chat&amp;quot;. When
running compiled under DEC-10 Prolog (Warren 1979;
Pereira, Pereira, and Warren 1978), Chat&apos;s speed at
analysing English sentences proved very satisfactory
(under a tenth of a second of CPU time per sentence).
Therefore this seemed a promising approach from the
point of view of both efficiency and portability. How-
ever, we found that Chat has a number of shortcom-
ings, the most serious of which is that the process of
answering a question, once it has been analysed, is
much too inefficient for any significant application.
We have therefore written an entirely new pro-
gram, Chat-80, which, like the original Chat, is imple-
mented entirely in Prolog. The main ways in which
Chat-80 differs from its forerunner are:
■ the semantics given to determiners, and the rules for
determining their scopes,
■ the process of planning and executing a query,
■ the rather wider coverage of English,
■ the use of extraposition grammars (XGs) in place of
MGs to handle certain &amp;quot;transformational&amp;quot; aspects
of English,
■ the way the natural language analysis is performed
in three separate phases rather than one.
In order to test the approach on a nontrivial do-
main, Chat-80 includes a database of facts about
world geography, and a small vocabulary of English
words sufficient for querying the database. This do-
main has the advantage, for demonstration purposes,
that the facts in the database are generally common
knowledge, so it is easier to appreciate what is entailed
in answering different queries. The database contains
basic facts about the world&apos;s countries (over 150 of
them), oceans, major seas, major rivers, and major
cities. The largest relation, &apos;borders&apos;, represents all
pairs of countries, oceans, or major seas that are adja-
cent, and contains therefore over 850 tuples. It should
be emphasised that the database is itself implemented
as ordinary Prolog; it therefore resides within the nor-
mal DEC-10 virtual memory.
Chat-80 processes a question in three main stages:
English
translation
logic
planning
Prolog
execution
answer
corresponding roughly to: &amp;quot;What does the question
mean?&amp;quot;, &amp;quot;How shall I answer it?&amp;quot;, &amp;quot;What is the an-
swer?&amp;quot;. The planning and execution stages are dis-
cussed in detail in a companion paper (Warren 1981),
so here we will concentrate on the translation stage,
which is responsible for the natural language analysis.
We first describe the way we represent the &amp;quot;meaning&amp;quot;
of an English sentence as a logical expression, and
then outline how the translation process is formalised,
in logic, as a practical Prolog program. Finally, we
briefly explain how the logical form is transformed
into a Prolog program by the planning phase and how
it is then executed.
</bodyText>
<sectionHeader confidence="0.894484" genericHeader="method">
2. A Simplified Semantics for a Basic English Subset
</sectionHeader>
<bodyText confidence="0.998819806451613">
To answer a question, one first has to understand
what it means. If question answering is to be done by
computer, there needs to be some precise representa-
tion for the result of this first process, what one might
call the &amp;quot;meaning&amp;quot; of the question, and also some
precise way of relating the question to its meaning. It
is further necessary that the meaning representation
can in some way be given a precise interpretation (or
&amp;quot;semantics&amp;quot;) so that, in the case of questions for in-
stance, one then knows precisely what is or is not a
correct answer to the questions. It is surprising that,
even for such basic features of English as the common
determiners, and even within the different language
camps represented by linguistics, philosophy, and arti-
ficial intelligence, there is as yet no established solu-
tion to this problem.
One way to try to articulate the meaning of a sen-
tence is to paraphrase it into some standard, unambi-
guous form of English. Since these standard forms are
likely to be stilted and long-winded, it will probably be
convenient to represent them in a more concise nota-
tion. This is essentially the logician&apos;s approach, and
we will call such meaning representations &amp;quot;logical
forms&amp;quot;.
Chat-80 represents the meaning of a question by a
logical form. The approach is a development of that
proposed by Colmerauer 1978 and implemented by
Dahl 1981,1979.
Words approximating to the status of &amp;quot;proper
nouns&amp;quot; are represented by logical constants, for exam-
ple:
</bodyText>
<figure confidence="0.130075">
France france
the Soviet Union soviet union
wine wine
</figure>
<footnote confidence="0.348965">
Most verbs, nouns, and adjectives (together with any
associated prepositions) are represented by predicates,
taking one or more arguments (which for our purposes
are called constants). A predicate with its arguments
is called a predication (or sometimes a goal). Exam-
ples are:
</footnote>
<note confidence="0.5885065">
American Journal of Computational Linguistics, Volume 8, Number 3-4, July-December 1982 111
David H.D. Warren and Fernando C.N. Pereira An Efficient Easily Adaptable System
</note>
<bodyText confidence="0.898092625">
France exports wine to B ritain.
exports(france,wine,britain)
France is a country. country(france)
Paris is the capital of Fra nce. capital(france,paris)
France is European. european(france)
Many kinds of more complex phrases or sentences
can be represented by conjunctions of predications, for
example:
</bodyText>
<equation confidence="0.8754275">
Paris is a European city.
european(paris) &amp; city(paris).
France is a country that borders on Spain.
country(france) &amp; borders(france,spain)
</equation>
<bodyText confidence="0.982269642857143">
The second of these conjunctions, for example, can be
read more literally as a shorthand for &amp;quot;France is a
country and France borders Spain&amp;quot;, which is just a
paraphrase of the original sentence.
The most important class of words not covered so
far are the determiners — words such as &amp;quot;a&amp;quot;, &amp;quot;the&amp;quot;,
&amp;quot;every&amp;quot;. Determiners play a particularly important
role in questions, since they enable relatively complex
requests for information to be expressed very concise-
ly.
In Colmerauer&apos;s approach, each determiner is rep-
resented by what he called a &amp;quot;three-branched
quantifier&amp;quot; (3BQ). For example, the logical form that
would be ascribed to the sentence &amp;quot;The boy sleeps&amp;quot;
would be:
the(X,boy(X),sleeps(X))
where the determiner &amp;quot;the&amp;quot; is represented by the 3BQ
&apos;the( „ )&apos;. 3BQs are very close to the meaning
representation for determiners used by Woods in the
LUNAR system (1977). Colmerauer gave 3BQ5 a
precise semantics in terms of certain operations over
sets. However, we have found that this way of inter-
preting 3BQ5 fails to give a correct model of natural
language in certain cases, and, worse still, it does not
appear to lend itself to efficient implementation. Cer-
tainly this is the case with Dahl&apos;s program which,
while being very efficient at understanding questions, is
hopelessly inefficient at answering questions where the
domain is of any significant size.
In Chat-80, we have addressed these problems by
instead translating 3BQ5 directly into standard first-
order logic, or rather into something as close to first-
order logic as is practical. To be more exact, we
translate into the Prolog subset of logic, which we
have augmented with certain &amp;quot;meta-logical&amp;quot; exten-
sions. (A similar approach has been taken by McCord
1982, who has independently been developing a sys-
tem influenced by the Colmerauer/Dahl approach.)
The subset of first-order logic we have chosen has the
great advantage as a meaning representation that it
already has a well understood semantics which is
amenable to very efficient implementation. Thus the
meaning representation can in principle be directly
executed as a Prolog program (whereas 3BQs require a
special-purpose interpreter). Furthermore, the first-
order logic formulation lends itself to transformations
which can greatly improve the efficiency of execution.
This corresponds to what is known as &amp;quot;query
optimisation&amp;quot; in relational database circles, and will be
discussed in more detail later.
Our translation into logic completely ignores the
presuppositions which can be implicit in a natural lan-
guage question, and which Colmerauer&apos;s 3B0 seman-
tics took pains to reflect. In most situations that we
are concerned with, this simplification seems relatively
harmless or even beneficial. For example, Chat-80
ignores the presupposition that there is only one an-
swer to the question &amp;quot;Which ocean borders the United
States?&amp;quot;, and simply gives all three answers without
further comment.
The way we translate determiners into logic is
shown in Figure 1. Each determiner is translated into
a quantification, which introduces some logic variable
(X, N, etc.), and which links two predications involv-
ing that variable, called the range and scope, indicated
by R and S.
The determiners &amp;quot;a&amp;quot;, &amp;quot;the&amp;quot; (in a singular context),
and &amp;quot;some&amp;quot; (whether in a singular or plural context)
are all translated in exactly the same way, by a stand-
ard first-order logic existential quantification. Read
`exists(X,P)&apos; as &amp;quot;there is some X such that P&amp;quot;. The
same translation is also normally used for the &amp;quot;empty
plural&amp;quot; determiner, for example:
Zambia exports minerals.
exists (X,mineral(X) &amp; exports(zambia,X)).
The determiner &amp;quot;no&amp;quot; is translated with the aid of a
kind of negation. Read &apos; \ -FP&apos; as &amp;quot;it cannot be shown
that P&amp;quot;. Note that this is not the standard negation of
first-order logic, which is outside the Prolog subset.
Standard negation is problematic to implement and
seems inappropriate for many purposes. Instead Pro-
log systems provide (or can easily be extended with) a
partial implementation of nonprovability. The predica-
tion &apos; \ A-P&apos; is considered true if P is not deducible
from the facts and rules which define a particular ap-
plication domain. Note that nonprovability is also
used in the translation of the determiners &amp;quot;every&amp;quot; and
&amp;quot;all&amp;quot;.
The determiner &amp;quot;the&amp;quot; in a plural context presents a
number of problems, for which we do not yet feel we
have a completely adequate solution. In general, we
consider a plural definite noun phrase to denote a set.
To cater for this, we have proposed and implemented
a &amp;quot;meta-logical&amp;quot; extension to Prolog, which has been
described in detail elsewhere (Warren, 1982; Byrd,
Pereira, and Warren 1980). The extension allows
predications of the form:
setof(X,P,S)
</bodyText>
<page confidence="0.650575">
112 American Journal of Computational Linguistics, Volume 8, Number 3-4, July-December 1982
</page>
<note confidence="0.78082">
David H.D. Warren and Fernando C.N. Pereira An Efficient Easily Adaptable System
</note>
<equation confidence="0.87239825">
a, some, the[singular] exists(X,R &amp; S)
no \ +exists(X,R &amp; S)
every, all \ +exists(X,R &amp; \+S)
the[plural] exists(X,setof(X,R,X) &amp; S)
</equation>
<bodyText confidence="0.899625875">
one, two, ... numeral(N) numberof(X,R &amp; S,N)
which, what answer(X) &lt;= R &amp; S
how many answer(N) &lt;= numberof(X,R &amp; S,N)
Some birds migrate.
exists(X,bird(X) &amp; migrates(X)).
The population of Britain exceeds 50 million
exists(X,population(britain,X) &amp; X&gt; 50000000).
There are no rivers in Antarctica.
</bodyText>
<equation confidence="0.652741090909091">
\ +exists(X,river(X) &amp; in(X,antarctica)).
Man inhabits every continent.
\ +exists(X,continent(X) &amp; \ +inhabits(man,X)).
Jupiter is the largest of the planets.
exists(X,setof(X,planet(X),X) &amp; largest(X,jupiter)).
The Rhine flows through three countries.
numberof(X,country(X) &amp; flows through(rhine,X),3).
Which birds migrate?
answer(X) &lt;= bird(X) &amp; migrates(X).
How many countries export oil?
answer(N) &lt;= numberof(X,country(X) &amp; exports(X,oil),N).
</equation>
<figureCaption confidence="0.99967">
Figure 1. Translations of determiners.
</figureCaption>
<bodyText confidence="0.992847035714286">
to be read as &amp;quot;the set of Xs such that P is provable is
S, where S is nonempty&amp;quot;. Note that this construct
behaves like a quantification in that it introduces a
variable (or, more generally, a collection of variables)
X which is purely local to P. Thus it is possible, as in
the translation of the plural definite article given in
Figure 1, to use the same variable name for a set and
its &amp;quot;typical&amp;quot; element.
Our translation entails that certain predicates can
take sets as arguments. At present, we leave it up to
the definition of each individual predicate to draw any
necessary correspondence between predications over
sets and predications over individuals, since it is hard
to fix a general rule. To see what the problem is,
compare the sentences:
The boys like the girls.
The boys are married to the girls.
In certain contexts, such as:
What are the ages of the boys?
plural definite noun phrases are translated somewhat
differently, as indexed sets. More on this later.
For convenience in translating the numerals &amp;quot;one&amp;quot;,
&amp;quot;two&amp;quot;, &amp;quot;three&amp;quot;, etc., we allow predications of the
form:
numberof(X,P,N)
meaning &amp;quot;the number of Xs such that P is provable is
N&amp;quot;. This predicate can easily be defined in terms of
`setof&apos; by the logical implication:
</bodyText>
<equation confidence="0.861765">
numberof(X,P,N) &lt;= setof(X,P,S) &amp; sizeof(S,N)
</equation>
<bodyText confidence="0.960239083333334">
Read &apos;13 &lt;= Q&apos; as &amp;quot;P if Q&amp;quot;. The predicate `sizeor
just gives the number of elements in a set.
Notice that implications are also used in the trans-
lation of questions. Read `answer(X) &lt;= P&apos; as &amp;quot;X is
an answer if P&amp;quot; or &amp;quot;I want to know X if P (is true)&amp;quot;.
Variables in the &apos;answer&apos; predicate are not explicitly
quantified. Such free variables are interpreted, follow-
ing normal conventions in logic, as though they were
universally quantified; that is, one may prefix one&apos;s
reading of the entire logical form with phrases &amp;quot;For
any X, for any Y,&amp;quot; etc.
We have now seen how some common types of
English words are translated into bits of logical struc-
ture. It remains to discuss how the bits fit together to
produce the complete logical form for a whole sen-
tence. For example, a sentence within the scope of
our subset is:
Which European country exports no arms to coun-
tries in Africa?
How is it that the bits of structure corresponding to
each individual work in this sentence fit together to
produce the following logical form:
American Journal of Computational Linguistics, Volume 8, Number 3-4, July-December 1982 113
David H.D. Warren and Fernando C.N. Pereira An Efficient Easily Adaptable System
</bodyText>
<equation confidence="0.99597075">
answer(C) &lt;--.= european(C) &amp; country(C) &amp;
\ +exists(X, arm(X) &amp;
exists( Cl, country(C1) &amp; in( Cl,africa) &amp;
exports(C,X,C1) ) )
</equation>
<bodyText confidence="0.999817">
(One should realize that this is just a shorthand for
&amp;quot;For any C, C is an answer if C is European and C is
a country and it cannot be shown that there is some X
such that X is an armament and there is some Cl such
that Cl is a country and Cl is in Africa and C exports
X to C 1&amp;quot;.) Hopefully, the reader should already have
a fair intuitive idea of what the &amp;quot;assembly process&amp;quot;
must do. Basically, there are two main problems.
First, how are the appropriate variables or con-
stants chosen to fill each predicate argument position?
For example, why is the last argument of &apos;exports&apos; the
same variable Cl that appears as arguments to
&apos;country&apos; and &apos;in&apos;? This &amp;quot;slot filling&amp;quot; is determined
mainly by the grammatical structure of the sentence,
but the correct attachment of prepositional phrases
often cannot be determined on purely syntactic
grounds.
Second, what determines the scope of the different
quantifications? For example, why is the existential
quantification corresponding to the empty determiner
governing &amp;quot;countries in Africa&amp;quot; nested inside the
quantification corresponding to &amp;quot;no&amp;quot;? This &amp;quot;scoping&amp;quot;
is only weakly influenced by grammatical structure.
Indeed, it is possible to give an alternative but much
less likely reading to our example sentence, which
corresponds to the same grammatical structure, but to
a different logical form where the nesting of the two
inner quantifications is reversed. The more likely
reading is that no arms are exported to any countries
in Africa; the less likely reading is that no arms are
exported to certain countries in Africa.
The details of our mapping from English into logic
are made precise in the program text corresponding to
the first phase of Chat-80. This text itself consists of
clauses of the Prolog subset of logic. It serves both as
a clear formal definition of our mapping and, when
executed by Prolog, as an efficient implementation of
that mapping, which performs the translation of Eng-
lish questions into their logical forms. A fuller discus-
sion of this implementation will be given in the next
section, and further details can be found in Pereira
1982.
</bodyText>
<subsectionHeader confidence="0.434164">
3. Translating English into Logic, in Logic
</subsectionHeader>
<bodyText confidence="0.99992725">
The translation from English sentence to logical
form can be seen as involving three main functions —
the slot filling and scope determination mentioned in
the last section, and in addition the parsing function,
which determines the grammatical structure of a sen-
tence. In Chat-80, in contrast to Dahl&apos;s sYstem, these
three functions are separated into distinct program
modules, which operate in sequence:
</bodyText>
<figure confidence="0.800886285714286">
English question
1 parsing
phrase structure
1 interpretation
semantic structure
1 scoping
logical form
</figure>
<bodyText confidence="0.999371733333334">
The parsing module consists of a set of grammar
rules of the XG formalism, which the Prolog system
preprocesses into Prolog clauses. The interpretation
and scoping modules consist of various translation
rules, expressed directly as Prolog clauses. Executing
the grammar rules with Prolog leads to a straightfor-
ward top-down, backtrack parsing strategy (Pereira
and Warren 1980). Although the main concern in
writing the grammar was to produce a clear description
of the language covered, some concessions have had to
be made to achieve a reasonably efficient behaviour
with the above parsing strategy; in particular, left-
recursive rules have been avoided. It is somewhat
contrary to current opinion that such a grammar, not
carefully designed for parsing, can also be the basis of
an efficient parser. One of the reasons for the effi-
ciency in this case may be that the grammar itself
makes no attempt to give the &amp;quot;right&amp;quot; modifier attach-
ments, as discussed below.
There has been some debate on whether the differ-
ent parts of language analysis, such as the three distin-
guished above, should be done serially or concurrently
(Burton 1976; Woods 1977). Some of the arguments
for concurrent operation are that early semantic inter-
pretation limits search by bringing in relevant informa-
tion at the earliest possible moment, and that piece-
wise generation of the interpretation is psychologically
more plausible. Given that we are not proposing a
model of language comprehension in people, the latter
argument is not directly relevant. The other argument
is a two-edged one: by interweaving several opera-
tions, one is multiplying together their nondetermina-
cies. There are two main reasons why we have chosen
serial operation. The first is that serial operation is
much simpler both conceptually and in programming
terms, particularly if one is trying to deal flexibly with
global properties of the input, for instance the relative
scopes of determiners. The other reason is that the
backtracking traditionally associated with modifier
attachment can be avoided by a careful choice of the
parse trees produced by the parsing module.
In typical systems where syntactic and semantic
functions operate in sequence (Woods, Kaplan, and
Nash-Webber 1972), choices are made in the syntactic
analysis that may be found to be inadequate on se-
</bodyText>
<page confidence="0.632007">
114 American Journal of Computational Linguistics, Volume 8, Number 3-4, July-December 1982
</page>
<note confidence="0.918678">
David H.D. Warren and Fernando C.N. Pereira An Efficient Easily Adaptable System
</note>
<bodyText confidence="0.992164190476191">
mantic grounds, as for example in prepositional phrase
attachment. In the present system, the syntactic com-
ponent of the grammar contains additional constraints
which block all but one of the potential attachments of
each postmodifier. Thus, all analyses produces are in
a kind of normal form with respect to postmodifier
attachment. From this normal form, subsequent oper-
ations can reconstruct other alternative analyses, if
that is needed on semantic grounds. The use of nor-
mal form analyses has the useful consequence of mak-
ing apparent other, significant, ambiguities in the in-
put, which otherwise would be swamped by a large
number of alternative analyses differing only with
respect to modifier attachment.
A major limitation of the current system is that
pronouns (other than interrogative and relative pro-
nouns) are not covered at all by the translation phase.
This makes the natural language subset strictly less
powerful than the underlying logic. For example, the
following sentence has a logical form which cannot be
rendered in our natural language subset:
</bodyText>
<equation confidence="0.87086275">
Which country contains a city bigger than its capital?
answer(C) &lt;= country(C) &amp;
exists(X, contains(C,X) &amp; city(X) &amp;
exists(Y, bigger(X,Y) &amp; capital(C,Y) ) ).
</equation>
<bodyText confidence="0.9994315">
To each of the three modules of the translation
process there corresponds a separate dictionary. The
grammar dictionary contains definitions of the usual
syntactic categories, both for general-purpose, or
&amp;quot;closed-category&amp;quot;, words, such as determiners, and for
application dependent, or &amp;quot;content&amp;quot;, words, such as
the nouns and verbs corresponding to database predi-
cates. The slot filling module has a dictionary of
templates, which define the translation of words to
predicates and the argument patterns required for each
such translation. Each application will require a dif-
ferent set of templates. Finally, the scope determina-
tion module has a small dictionary defining the scope
relationships for determiners and other &amp;quot;operator&amp;quot;
words, and their translation as discussed in the last
section. This dictionary is independent of the applica-
tion domain. The dictionaries are divided in this man-
ner for conceptual and programming reasons, but it
would not be difficult to write a program to create the
dictionary entries from a more user-oriented dictionary
format. The complete dictionary definition for a sin-
gle word is shown in Appendix II.
</bodyText>
<subsectionHeader confidence="0.999718">
3.1. Phrase Structure
</subsectionHeader>
<bodyText confidence="0.999720341463415">
A grammar for any substantial language fragment
needs to define grammatical relationships which we
may call &amp;quot;transformational&amp;quot;, that is, relationships
which cannot be described directly by a small number
of phrase structure (context-free) rules. Both MGs
(used in Dahl&apos;s system) and DCGs have general pro-
gramming power, and so can describe any
&amp;quot;transformational&amp;quot; relationship, but they cannot do so
by specific, well motivated grammar rules. In particu-
lar, this applies to &amp;quot;left extraposition&amp;quot;, the underlying
concept in most grammars for such important con-
structions as WH-questions, relative clauses, and auxil-
iary fronting. Similar comments apply to ATNs
(Woods 1970), even those using the HOLD/VIR facili-
ty.
To handle &amp;quot;left extraposition&amp;quot;, and some other
&amp;quot;transformational&amp;quot; concepts, we have introduced the
grammar formalism of extraposition grammars, which
are described fully elsewhere (Pereira 1981). An XG,
like a DCG, is no more than &amp;quot;syntactic sugar&amp;quot; for
clauses of logic.
As the Chat-80 grammar is intended partly as a
demonstration of the power of XGs for treating left
extraposition in English, the coverage of questions and
relative clauses is fairly extensive. Of course, this
wide coverage is essential if complex queries are to be
formulated in a single sentence.
A major limitation in the present coverage of Eng-
lish syntax is that the only phrases that may be con-
joined (with &amp;quot;and&amp;quot;, etc.) are noun postmodifiers and
predications introduced by the verb &apos;to be&apos;. To cover
more general conjunctions would require a minor
change in the XG formalism, to cope with the interac-
tion between left extraposition and conjoined phrases.
The analysis of a sentence produced by the Chat-
80 grammar is a fairly conventional annotated surface
structure, where in general the subtrees for all phrases
appear in the same order as in the input. This is es-
sential for the heuristics used in the scoping opera-
tions, which rely on the left-to-right order of noun
phrases.
</bodyText>
<subsectionHeader confidence="0.99997">
3.2. Attaching Arguments and Modifiers
</subsectionHeader>
<bodyText confidence="0.999836333333333">
As we have seen, the translation of content words
into predicates is defined by dictionary templates. Of
course, certain words, like &amp;quot;average&amp;quot;, &amp;quot;number (of)&amp;quot;
and superlative adjectives, cannot be translated as
first-order predicates, but represent some higher-order
operation. Templates specify, for each argument posi-
tion of a predicate which translates a word, the &amp;quot;case&amp;quot;
(usually a preposition) and the most general entity type
that can fill the position, or slot. Type matching helps
the system to find a semantically sound argument
placement, and is also used to create additional predi-
cations when attributes are referred to implicitly, as in
comparatives. Templates are similar to the dictionary
entries in Dahl&apos;s system, but our attachment proce-
dure, by being separate from the syntax analysis, can
be much more flexible in deciding how to fill slots.
The following are typical application dependent
templates:
</bodyText>
<note confidence="0.7543195">
American Journal of Computational Linguistics, Volume 8, Number 3-4, July-December 1982 115
David H.D. Warren and Fernando C.N. Pereira An Efficient Easily Adaptable System
</note>
<bodyText confidence="0.937083346153846">
property(area,measure&amp;area,A,region&amp;Type,R,
area(R,A)).
transitive(exceed,measure&amp;Type ,X,measure&amp;Type,Y,
exceeds(X,Y)).
The first template states that &apos;area&apos; is a &amp;quot;property&amp;quot;, a
subclass of nouns which require an argument marked
by the preposition &amp;quot;of&amp;quot;. Variable A in this template
corresponds to the &amp;quot;area&amp;quot; value, which belongs to the
sub-type &apos;area&apos; of the type &apos;measure&apos;. Variable R cor-
responds to the thing having an area, and belongs to
some sub-type of type &apos;region&apos;. The predication for
this word is `area(R,A)&apos;. The second template states
that &amp;quot;(to) exceed&amp;quot; is a transitive verb, whose subject
X and object Y are both measures of some common
type Type, and `exceeds(X,Y)&apos; is the corresponding
predication.
When Prolog accesses such templates, unification
automatically does most of the work of &amp;quot;slot filling&amp;quot;.
The result of the slot filling process is a tree with
three kinds of nodes, quantification nodes (Quants),
predication nodes (Preds) and conjunction nodes
(Conjs). Quants correspond to noun phrases, Preds to
verbs, and Conjs to conjoined restrictive modifiers.
As we have seen, quantifications play a crucial role
in the translation of sentences into logics. The fields
of a Quant are:
</bodyText>
<listItem confidence="0.994310923076923">
• the determiner, which can be an English determiner
or one of the special determiners described below;
• the head, which is either the predication translating
the head noun of a noun phrase, or a term denoting
a higher-order operation;
• the predication, a tree describing restrictions on the
head whose determiners have narrower scope than
the determiner on this Quant;
• the arguments, a list of the trees for the arguments
of the noun, together with the trees of those re-
strictions whose determiners may have wider scope
than the present one;
• the bound variable for this quantification.
</listItem>
<bodyText confidence="0.980885173913044">
The distinction between the predication and the argu-
ment list of a Quant corresponds to one of the main
scoping heuristics in the system: full relative clauses
are the only subordinated phrases whose determiners
cannot &amp;quot;move up&amp;quot; to dominate determiners in higher
tree nodes. Thus, when a Quant is mapped into a
logic quantification, the head, predication, and some of
the arguments will translate into the range of the
quantification, whereas the scope will be made from
the rest of the arguments and some quantifications
which are higher in the tree but whose determiners
have a narrower scope than the present one.
The determiner of a Quant may not be the original
English determiner of the corresponding noun phrase.
In nested plural definite noun phrases, only the highest
determiner gets translated into a set expression follow-
ing the translation table of Figure 1; lower determiners
are understood to index that set, and are represented
in Quants by an index token. For example, the noun
phrase:
the children of the employees
translates into a set of sets of children, indexed by
employees:
</bodyText>
<equation confidence="0.520971">
setof(E-S, employee(E) &amp; setof(C,child(E,C),S), Si).
</equation>
<subsectionHeader confidence="0.996216">
3.3. Meaning and Scope of Quantifications
</subsectionHeader>
<bodyText confidence="0.998500894736842">
Given the tree of Quants, Preds, and Conjs pro-
duced by slot filling, the final module specifies the
relative scopes of determiners, of negation, and of
question markers. The main information for this mo-
dule is a set of rules of thumb about what determiners
usually &amp;quot;govern&amp;quot; other determiners. The relationship
of &amp;quot;governing&amp;quot; is not a total order, or even a partial
order: it is only meaningful for pairs of operators, one
in a subordinating and the other in a subordinated
position. Relative scopes not decided by &amp;quot;governing&amp;quot;
are decided by the left-to-right order of phrases in the
input sentence.
Our scope rules are more accurate than those pro-
posed by Colmerauer 1982 and used in Dahl&apos;s system.
Colmerauer&apos;s rules determine relative scope strictly on
the basis of predicate-argument relationships defined
in syntactic terms. Our rules are related to the ideas
for improving LUNAR discussed by Woods 1977 and
Vanlehn 1978. Unfortunately, except for set and
higher-order operations, we have no means of using
the distinct roles of different argument places to help
decide the scopes of their fillers.
As an example of our scope rules, the determiner
&apos;each&apos; is assumed to have a &amp;quot;distributive&amp;quot; role, and
governs most other determiners, and also question
markers, so the reply to a question containing &apos;each&apos;
will be an indexed list of values, one for each entity
satisfying the conditions in the noun phrase with that
determiner. A negated verb, however, will prevent an
&apos;each&apos; in any of its arguments from assuming its dis-
tributive role. In fact, no determiner governs a nega-
tion except &apos;any&apos;, which is seen as a universal quantifi-
cation of wide scope relative to negation.
Apart from deciding on relative scopes, this module
also specifies how set expressions are built from plural
determiners and index determiners, and what are the
first-order predications which make the arguments of
higher-order functions like &apos;average&apos; and &apos;number of&apos;.
</bodyText>
<subsectionHeader confidence="0.518402">
4. Query Planning and Execution
</subsectionHeader>
<bodyText confidence="0.9903775">
We have now seen how an English question is map-
ped into its logical form. Since the logical form has a
precise semantics, it is in principle possible to deter-
mine the answer to the question. However, there is a
</bodyText>
<page confidence="0.821693">
116 American Journal of Computational Linguistics, Volume 8, Number 3-4, July-December 1982
</page>
<note confidence="0.906605">
David H.D. Warren and Fernando C.N. Pereira An Efficient Easily Adaptable System
</note>
<bodyText confidence="0.998351745454546">
big difference between principle and practice. Can the
process of finding the answer really be made fast
enough for this to be useful for practical question an-
swering purposes? The evidence of Chat-80 is that it
can.
The key question here is how to avoid combinatori-
al explosion. Naive question-answering strategies
typically take a time that is exponential in the size of
the query. Even for relatively small databases, such as
that in Chat-80, exponential behaviour will be disas-
trous for non-trivial queries (and non-trivial queries
are what a natural language interface encourages). A
query over a small database that can be answered
almost instantaneously with the right question-
answering strategy may easily take hours with a poor
algorithm. We had actual experience of this phenome-
non when we experimented with mounting the Chat
database on the relational database system Ingres
(Stonebraker, Wong, Kreps, and Held 1976). Simple
queries Ingres handled easily, but on queries involving
more than two relations, which were no problem for
Chat, Ingres usually bogged down completely. We
therefore think that the question-answering part of
natural language question-answering is at least as wor-
thy of attention as the natural language part, and the
two should be studied hand in hand.
A complete description of the way Chat-80 proc-
esses logic queries, together with a fuller discussion of
the efficiency issues, is given in a separate paper
(Warren 1981), which we urge the interested reader to
consult. Here we just give a brief summary, illustrated
by one example. Basically, Chat-80 augments the
logical form of a query with extra control information,
to make it into an efficient piece of Prolog program,
which can then be directly executed to produce the
answer. The control information is computed by a
general planning algorithm, applicable to any query in
the logic subset, not just to those derivable from the
present natural language subset. The planning process
makes use of certain statistics about the size, etc., of
the domain relations, and is analogous to &amp;quot;query
optimisation&amp;quot; in a relational database system.
The control information that is generated takes two
forms:
■ the ordering of predications within a query, which
will determine the order in which Prolog will at-
tempt to satisfy them;
■ the marking of &amp;quot;independent subproblems&amp;quot; by en-
closing them in braces, to limit (or &amp;quot;cut&amp;quot;) the
amount of backtracking performed by Prolog.
For example, here is an English question with the
logical form produced by the natural language analysis
phase of Chat-80:
&amp;quot;Which countries bordering the Mediterranean border
Asian countries?&amp;quot;
</bodyText>
<equation confidence="0.994181625">
answer(C) &lt;= country(C) &amp;
borders (C,mediterranean) &amp;
exists(C1,country(C1) &amp; asian(C1) &amp;
borders(C,C1))
After planning, the logical form is transformed into:
answer(C) &lt;= borders (C,mediterranean) &amp;
{country(C)1 &amp; fborders(C,C1) &amp;
fasian(C1) &amp; {country(C1)}11
</equation>
<bodyText confidence="0.998841736842105">
When executed by Prolog, this produces a behaviour
equivalent to the following procedural interpretation:
To generate an answer C:
generate a C bordering the mediterranean, and then
check that C is a country, and then
check that it is possible to:
generate a Cl bordered by C, and then
check that Cl is asian, and then
check that Cl is a country.
Thus Prolog is led to answer the query in an obviously
sensible way; it iterates through the countries border-
ing the Mediterranean, and for each one, it iterates
through the things bordering that country until it finds
something that is an Asian country. In fact the
DEC-10 Prolog compiler can in principle compile the
transformed query into code which is comparable in
efficiency with iterative loops in a conventional lan-
guage (Warren 1977). However, in Chat-80 the
transformed query is actually just interpreted.
</bodyText>
<sectionHeader confidence="0.579307" genericHeader="method">
5. Performance and Portability
</sectionHeader>
<bodyText confidence="0.999149583333333">
Chat-80 at its current stage of implementation,
covers a limited but useful subset of English. A fair
idea of the range of the present subset is given by the
examples in Appendix I. It will be seen that the sub-
set includes nouns, verbs, adjectives, prepositions, and
determiners, with a fairly full coverage of interrogative
and relative constructions. We have concentrated on
features of English that seemed essential for simple
question answering; there are many directions in which
the subset could usefully be extended and which do
not appear to pose any particular difficulties.
At present, the system accepts a small vocabulary
of about 100 domain dependent works (not counting
proper nouns, but including alternative word forms
such as plurals). This vocabulary can very easily be
extended (as indicated below). In addition there are
some 50 domain independent words. On the whole,
any question that can be expressed using this vocabu-
lary is correctly understood and answered by the sys-
tern.
The sizes of the different components of the system
are indicated below in terms of the approximate num-
ber of Prolog clauses comprised, and the approximate
number of DEC-10 (36-bit) words occupied:
</bodyText>
<table confidence="0.878979125">
American Journal of Computational Linguistics, Volume 8, Number 3-4, July-December 1982 117
David H.D. Warren and Fernando C.N. Pereira An Efficient Easily Adaptable System
clauses DEC-10
words
NL analysis 580 24000
Query planning and execution, etc. 290 8500
Geographical vocabulary 180 4000
Geographical database 1590 22500
</table>
<bodyText confidence="0.999928603174603">
The speed of Chat-80 on some sample queries rela-
ting to the geographical database is shown in Appen-
dix I. Generally speaking, any query in this domain
that can comfortably be expressed in a single sentence
of the English subset is answered in well under one
second of CPU time. Note that the domain dependent
vocabulary could be much extended without having
any significant impact on these times (because of the
way the dictionary is indexed).
It is also worth noting that, for all but the simplest
queries, natural language analysis represents only a
small proportion of the total time. This suggests that,
as far as the efficiency of natural language question
answering systems is concerned, it is the answering
process rather than the natural language analysis to
which most effort needs to be directed. Certainly this
has been our approach, although it appears to be
somewhat contrary to the prevailing view in artificial
intelligence. In particular, parsing does not seem to
pose any major efficiency problem, provided one does
not expect the grammar to do too much.
As regards portability, we think Chat-80 should be
relatively easy to adapt to different applications — for
the same reasons that we found it easy to adapt Dahl&apos;s
program to English and to a different domain.
Partly this is due to the fact that (in both systems)
the domain dependent parts are clearly separated from
the rest of the system, and are broken down into small
units which can be added incrementally as &amp;quot;data&amp;quot; (see
Appendix II). Thus our natural language analysis mo-
dules deal exclusively with general features of English,
in contrast to the &amp;quot;semantic grammar&amp;quot; approach
(Burton 1976).
Now there are other practical systems which have
not taken the &amp;quot;semantic grammar&amp;quot; approach but are,
we feel, less easy to modify than Chat-80; LUNAR
(Woods, Kaplan, and Nash-Webber 1972) is a good
example. The reason lies in the way &amp;quot;meanings&amp;quot; are
attached to words. In LUNAR, a meaning is simply a
procedure. For nouns it is a procedure to generate
objects in a certain class; for most other words it is a
procedure to test whether some property is true of
given objects. This entails that &amp;quot;meanings&amp;quot; can be
executed in only one way, and precludes the kind of
query planning done in Chat-80. But such a simple-
minded approach to query execution is not viable in
most practical situations, as Woods 1977 recognises
with his &amp;quot;smart quantifiers&amp;quot;. The only alternative,
given the procedural approach to meaning, is to repre-
sent the meaning of a word by a set of alternative
procedures to be used in different circumstances. But
this makes life very difficult for someone wanting to
introduce a new word or concept into the system.
In Chat-80, the meaning of a new word is in princi-
ple just a set of facts and general rules that define the
predicate corresponding to that word. The procedural
aspect is on the whole taken care of by the planning
algorithm, and by Prolog&apos;s flexible handling of predi-
cations in which only certain arguments are instantiat-
ed. However, with the present system, the definer of
a new word must be responsible for ensuring that the
predicate definition he supplies is not only correct, but
is also reasonably efficient when executed by Prolog.
</bodyText>
<sectionHeader confidence="0.994044" genericHeader="method">
6. Conclusion
</sectionHeader>
<bodyText confidence="0.999994857142857">
We have shown how questions within a limited
subset of English can be translated into a certain sub-
set of logic which, when suitably transformed, is exec-
utable as efficient Prolog code. Although this map-
ping between English and logic may seem &amp;quot;obvious&amp;quot;
(since logic is, after all, usually motivated in terms of
its correspondence with natural language), it is surpris-
ing that a mapping like ours does not appear to have
been implemented, or even precisely defined, before.
Parts of the mapping overlap with Montague&apos;s 1974
formalisation of aspects of English, but many of the
basics were not covered in his work (for instance, the
treatment of questions, plurals, and determiner prece-
dence), and of course he was not concerned to prod-
uce a practical implementation. Among practical im-
plementations, the closest work is that of Woods 1977
and that of Colmerauer 1982 as implemented by Dahl
1981. Both these efforts are similar in that they map
English into a nonstandard (and more elaborate) logic,
where the quantifiers are more directly modelled on
the determiners of natural language. These nonstan-
dard quantifiers are called &amp;quot;FOR expressions&amp;quot; by
Woods and &amp;quot;three-branched quantifiers&amp;quot; by Colmer-
auer. We have kept much closer to standard predicate
logic, for the very down-to-earth reason that the tradi-
tional formalism seems to make &amp;quot;query optimisation&amp;quot;
much easier (see the companion paper, Warren 1981).
Our mapping from English to logic, as well as the
processes of query planning and answering, have all
been implemented entirely in Prolog. The result is a
prototype natural language question answering system,
Chat-80, which we think probably has the best combi-
nation of efficiency and portability of any comparable
system at the present time, due principally to the use
of Prolog as the implementation language.
</bodyText>
<sectionHeader confidence="0.986205" genericHeader="method">
Acknowledgements
</sectionHeader>
<bodyText confidence="0.576092">
This work was supported by a British Science Re-
search Council grant, and owes much to the work of
Alain Colmerauer and Veronica Dahl.
</bodyText>
<page confidence="0.762999">
118 American Journal of Computational Linguistics, Volume 8, Number 3-4, July-December 1982
</page>
<note confidence="0.970256">
David H.D. Warren and Fernando C.N. Pereira An Efficient Easily Adaptable System
</note>
<sectionHeader confidence="0.859499" genericHeader="method">
References
</sectionHeader>
<reference confidence="0.980313289855073">
Burton, R.R. 1976 Semantic grammar: an engineering technique
for constructing natural language understanding systems. Re-
port 3453. Bolt Beranek and Newman Inc. (December).
Byrd, L., Pereira, F., and Warren, D.H.D. 1980 A guide to ver-
sion 3 of DEC-10 Prolog. Occasional Paper 19. Dept. of
Artificial Intelligence, University of Edinburgh (July).
Colmerauer, A. 1978 Metamorphosis grammars. In Bolc., L., Ed.,
Natural Language Communication with Computers. Springer-
Verlag. First appeared as an internal report, Les Grammaires
de Metamorphose, in November 1975.
Colmerauer, A. 1982 An interesting subset of natural language.
In Clark, K.L. and Tarnlund, S.-A., Ed., Logic Programming.
Academic Press.
Dahl, V. 1979 Quantification in a three-valued logic for natural
language question-answering systems. IJCAI-79, Tokyo
(August) 182-187.
Dahl, V. 1981 Translating Spanish into logic through logic. AJCL
7, 3, 149-164.
Konolige, K. 1979 A framework for a portable natural language
interface to large data bases. Technical Note 197. Al Center,
SRI International (October).
McCord, M.C. 1982 Using slots and modifiers in logic grammars
for natural language. Artificial Intelligence 18, 3, 327-367.
Montague, R. 1974 The proper treatment of quantification in
ordinary English. In Thomason, R.M., Ed., Formal Philosophy.
Yale University Press.
Pereira, F.C.N. 1981 Extraposition grammars. AJCL 7, 4, 243-
256.
Pereira, F.C.N. 1982 Logic for natural language analysis. Ph.D.
thesis. University of Edinburgh.
Pereira, F.C.N. and Warren, D.H.D. 1980 Definite clause gram-
mars for language analysis — a survey of the formalism and a
comparison with augmented transition networks. Artificial
Intelligence 13, 231-278.
Pereira, L.M., Pereira, F., and Warren, D.H.D. 1978 User&apos;s guide
to DECsystem-10 Prolog. Dept. of Artificial Intelligence,
University of Edinburgh.
Roussel, P. 1975 Prolog: manuel de reference et d&apos;utilisation
Group d&apos;Intelligence Artificielle, UER de Luminy, Universit&amp;
d&apos;Aix-Marseille II.
Stonebraker, M., Wong, E., Kreps, P. and Held, G. 1976 The
design and implementation of INGRES. ACM Trans. on Data-
base Systems 1, 3 (Sept.) 189-222.
Vanlehn, K.A. 1978 Determining the Scope of English Quantifi-
ers. Master&apos;s thesis. Published as Report AI-TR-483. M.I.T.
(June).
Warren, D.H.D. 1977 Implementing Prolog — compiling predicate
logic programs. Technical Research Reports 39 and 40. Dept.
of Artificial Intelligence, University of Edinburgh (May).
Warren, D.H.D. 1979 Prolog on the DECsystem-10. In Michie,
D., Ed., Expert Systems in the Micro-Electronic Age. Edinburgh
University Press.
Warren, D.H.D. 1981 Efficient processing of interactive relational
database queries expressed in logic. Seventh International
Conference on Very Large Data Bases.
Warren, D.H.D. 1982 Higher-order extensions to Prolog — are
they needed? In Hayes, Michie, and Pao, Ed., Machine Intelli-
gence 10. Ellis Horwood.
Warren, D.H.D., Pereira, L.M., and Pereira, F.C.N. 1977 Prolog —
the language and its implementation compared with Lisp. ACM
Symposium on Al and Programming Languages (August).
Woods, W.A. 1970 Transition network grammars for natural
language analysis. Comm. ACM 13 (Oct.) 591-606.
Woods, W.A. 1977 Semantics and quantification in natural lan-
guage question answering. Report 3687. Bolt Beranek and
Newman Inc. (November).
Woods, W.A., Kaplan, R.M., and Nash-Webber, B. 1972 The
Lunar science natural language information system: final report.
Report 3438. Bolt Beranek and Newman Inc. (June).
</reference>
<note confidence="0.826773">
American Journal of Computational Linguistics, Volume 8, Number 3-4, July-December 1982 119
David H.D. Warren and Fernando C.N. Pereira An Efficient Easily Adaptable System
</note>
<sectionHeader confidence="0.841154" genericHeader="method">
Appendix I. Sample Queries
</sectionHeader>
<bodyText confidence="0.9999342">
The Chat-80 examples below show the original
English query, its logical form, the executable form
after planning, and the actual answer. (The logical
expressions have been &amp;quot;tidied&amp;quot;, and superfluous quan-
tifiers dropped, to make them easier to read.) Also
</bodyText>
<subsectionHeader confidence="0.99693">
Does Afghanistan border China?
</subsectionHeader>
<bodyText confidence="0.9995986">
shown, preceding the corresponding output, are the
separate times (in CPU milliseconds on a DEC KL-10)
for natural language analysis, for planning, and for
execution. Time spent in producing output to the user
is excluded.
</bodyText>
<equation confidence="0.895581692307692">
38 ms. ans(yes) &lt;= borders(afghanistan,china).
12 ms. ans(yes) &lt;= { borders (afghanistan,china)
0 ms. yes.
Which country&apos;s capital is Ouagadougou?
41 ms. ans(C) &lt;= country(C) &amp; capital(C,ouagadougou).
15 ms. ans(C) &lt;= capital(C,ouagadougou) &amp; {country(C)}.
22 ms. upper volta.
Which is the ocean that borders African countries and that borders Asisan countries?
91 ms. ans(X) &lt;= ocean(X) &amp; country(C) &amp; african(C) &amp; borders(X,C) &amp;
country(C1) &amp; asian(C1) &amp; borders (X,C1).
51 ms. ans(X) &lt;= ocean(X) &amp;
borders(X,C) &amp; fafrican(C)1 &amp; {country(C)}} &amp;
{borders(X,C1) &amp; {asian(C1)} &amp; {country(C1)}}.
</equation>
<reference confidence="0.940575636363636">
102 ms. indian ocean.
What is the capital of each country bordering the Baltic?
81 ms. ans(C-X) &lt;= country(C) &amp; borders(C,baltic) &amp; capital(C,X).
12 ms. ans(C-X) &lt;= borders(C,baltic) &amp; {country(C)} &amp; capital(C,X).
29 ms. denmark-copenhagen, east germany-east berlin, finland-helsinki, poland-warsaw,
soviet union-moscow, sweden-stockholm, west germany-bonn.
What are the lattitudes of the countries north of the United Kingdom?
102 ms. ans(C-LL) &lt;= country(C) &amp; northof(C,united kingdom) &amp;
setof(L,latitude(C,L),LL).
26 ms. ans(C-LL) &lt;= northof(C,united kingdom) &amp;{country(C)} &amp;
setof(L,latitude(C,L),LL).
141 ms. canada-60 degrees, denmark-55 degrees, finland-65 degrees, iceland-65 degrees,
norway-64 degrees, soviet union-57 degrees, sweden-63 degrees.
Which country is bordered by two seas?
42. ms. ans(C) &lt;= country(C) &amp; numberof(X,sea(X) &amp; borders(C,X),2).
11 ms. ans(C) &lt;= numberof(X,sea(X) &amp; borders(C,X),2) &amp; {country(C)}.
206 ms. egypt, iran, israel, saudi arabia, turkey.
How many countries does the Danube flow through?
48 ms. ans(N) &lt;= numberof(C,country(C) &amp; flows(danube,C),N).
3 ms. ans(N) &lt;= numberof(C,flows(danube,C) &amp; {country(C)},N).
21 ms. 6.
From what country does a river flow into the Persian Gulf?
69 ms. ans(C) &lt;= river(R) &amp; country(C) &amp; flows(R,C,persian gulf).
12 ms. ans(C) &lt;= flows(R,C,persian gulf) &amp; {river(R)} &amp; {country(C)}.
23 ms. iraq.
What is the total area of countries south of the Equator not in Australasia?
115 ms. ans(T) &lt;= setof(A-C,area(C,A) &amp; country(C) &amp;
southof(C,equator) &amp; \ +in(C,australasia),S) &amp;
aggregate(total,S,T).
23 ms. ans(T) &lt;= setof(A-C,southof(C,equator) &amp; area(C,A) &amp;
{countryof(C)} &amp; \ +in(C,australasia),S) &amp;
aggregate(total,S,T).
182 ms. 10228 ksqmiles.
</reference>
<page confidence="0.805543">
120 American Journal of Computational Linguistics, Volume 8, Number 3-4, July-December 1982
</page>
<note confidence="0.81081">
David H.D. Warren and Fernando C.N. Pereira An Efficient Easily Adaptable System
</note>
<bodyText confidence="0.97631">
What is the average area of the countries in each continent?
</bodyText>
<equation confidence="0.9756958">
101 ms. ans(X-Av) &lt;= continent(X) &amp;
setof(A-C,area(C,A) &amp; country(C) &amp; in(C,X),S) &amp;
aggregate(average,S,Av).
33 ms. ans(X-Av) &lt;= continent(X) &amp;
setof (A-C,in(C,X) &amp; area(C,A) &amp; {country(C)},S) &amp;
</equation>
<reference confidence="0.906824875">
aggregate (average,S,Av).
759 ms. africa-233 ksqmiles, america-496 ksqmiles, asia-485 ksqmiles,
australasia-543 ksqmiles, europe-58 ksqmiles.
How many countries are there in each continent?
50 ms. ans(X-N) &lt;= continent(X) &amp; numberof(C,country(C) &amp; in(C,X),N).
19 ms. ans(X-N) &lt;= continent(X) &amp; numberof (C,in(C,X) &amp; {country(C)1,N).
352 ms. africa-48, america-31, asia-39, australasia-6, europe-32.
Is there some ocean that does not border any country?
68 ms. ans(yes) &lt;= ocean(X) &amp; \ +exists(C,borders(X,C) &amp; country(C)).
9 ms. ans(yes) &lt;= { ocean(X) &amp; \ +exists(C,borders(X,C) &amp; {country(C)))}.
14 ms. yes.
What does border the ocean that does not border any country?
59 ms. ans(Y) &lt;= ocean(X) &amp; \ +exists(C,country(C) &amp; borders(X,C)) &amp;
borders (Y,X).
20 ms. ans(Y) &lt;= ocean(X) &amp; \ +exists(C,borders(X,C) &amp; {country,(C)}) &amp;
borders (Y,X).
</reference>
<bodyText confidence="0.8083165">
24 ms. antarctica, atlantic, indian ocean, pacific.
Which are the continents no country in which contains more than two cities whose population exceeds 1 million?
</bodyText>
<equation confidence="0.985067666666667">
160 ms. ans(X) &lt;= continent(X) &amp;
\ +exists(C,exists(N,
country(C) &amp; in(C,X) &amp;
numberof (Ci,exists(P,
city(Ci) &amp; population(Ci,P) &amp;
exceeds(P,1000000) &amp; in(Ci,C)),N) &amp;
N &gt; 2)).
58 ms. ans(X) &lt;= continent(X) &amp;
\ +exists(C,exists(N,
in(C,X) &amp; {country(C)} &amp;
{ numberof (Ci,exists(P,
in(Ci,C) &amp; {city(Ci)1 &amp;
fpopulation(Ci,P) &amp; fexceeds(P,1000000)11),N) &amp;
{N &gt; 211)).
754 ms. africa, antarctica, australasia.
</equation>
<bodyText confidence="0.995509">
Which country bordering the Mediterranean borders a country that is bordered by a country whose population
exceeds the population of India?
</bodyText>
<equation confidence="0.992698625">
144 ms. ans(C) &lt;= country(C) &amp; borders(C,mediterranean) &amp; country(C1) &amp;
country(C2) &amp; population(C2,X) &amp; population(indea,Y) &amp;
exceeds(X,Y) &amp; borders(C2,C1) &amp; borders(C,C1).
57 ms. ans(C) &lt;= population(india,Y) &amp;
borders (C,mediterranean) &amp; {country(C)} &amp;
{ borders(C,C1) &amp; {country(C1)1 &amp;
{ borders(C2,C1) &amp; {country(C2)} &amp;
fpopulation(C2,X) &amp; lexceeds(X,Y)1111.
</equation>
<footnote confidence="0.426298">
204 ms. turkey.
</footnote>
<note confidence="0.6887105">
American Journal of Computational Linguistics, Volume 8, Number 3-4, July-December 1982 121
David H.D. Warren and Fernando C.N. Pereira An Efficient Easily Adaptable System
</note>
<sectionHeader confidence="0.733928" genericHeader="method">
Appendix II. Sample Word Definition
</sectionHeader>
<bodyText confidence="0.8979762">
To illustrate how a new word, and the concept verb, its meaning in terms of the predicate
associated with it, are added to the system, we show a `drains(R,X)&apos; (including the types of the arguments R
slightly simplified version of the actual Prolog clauses and X), data about the size of the &apos;drains&apos; relation and
defining the verb &amp;quot;to drain into.&amp;quot; These clauses repre- of its argument domains, and finally the definition of
sent elementary facts, giving the different forms of the the predicate &apos;drains&apos; itself.
verb_root(drain)
regular present(drain).
regular past(drained,drain).
verb form(drains,drain,present+finite,3+singular).
verb form(draining,drain,present+ participle).
intransitive (drain, drains(R,X), river,R, [slot(preposition(into),region,X)]).
predicate statistics(drains,41,41,12).
drains(amazon,atlantic).
drains(amu darya,aral sea).
etc.
</bodyText>
<sectionHeader confidence="0.691249" genericHeader="method">
Appendix Ill. Comparison with a Formal Query Language
</sectionHeader>
<bodyText confidence="0.97652247368421">
It is interesting to compare, from a user&apos;s point of Quel, the query language of the relational database
view, the Chat-80 subset of English with current rela- system Ingres (Stonebraker, Wong, Kreps, and Held
tional database query languages. The examples below 1976). Quel is arguably one of the most concise and
show some Chat-80 queries with their equivalents in user-friendly of current database query languages.
Which countries bordering the Atlantic border countries bordering the Pacific?
range of Cl, C2 is countries
range of B, Bi, B2 is borders
retrieve (Cl .name)
where Cl. name = Bl.sidel
and B 1 .side2 = &amp;quot;Atlantic&amp;quot;
and Cl. name = B.sidel
and B.side2 = C2.name
and C2.name = B2.side 1
and B2.side2 = &amp;quot;Pacific&amp;quot;
How many countries are there in each continent?
range of C is countries
range of Cont is continents
range of I is inclusions
retrieve (Cont.name, count(C.name where C.name = I.inside and I.outside = Cont.name))
</bodyText>
<subsectionHeader confidence="0.762639">
Which are the continents no country in which contains more than two cities whose population exceeds 1 million?
</subsectionHeader>
<bodyText confidence="0.995683166666667">
range of C is countries
range of Cont is continents
range of City is cities
range of Il, 12 is inclusions
retrieve (Cont.name)
where 0 = count(C.name
where C.name = Il.inside
and Il.outside = Cont.name
and 2 &lt; count(City.name
where City.name = I2.inside
and I2.outside = C.name
and City.population &gt; 1000000))
</bodyText>
<page confidence="0.648714">
122 American Journal of Computational Linguistics, Volume 8, Number 3-4, July-December 1982
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.486687">
<title confidence="0.999455">An Efficient Easily Adaptable Interpreting Natural Language</title>
<author confidence="0.850877">David H D Warren</author>
<author confidence="0.850877">Fernando C N Pereira</author>
<affiliation confidence="0.971797">Artificial Intelligence SRI</affiliation>
<address confidence="0.9809115">333 Ravenswood Menlo Park, CA 94025</address>
<abstract confidence="0.9956317">This paper gives an overall account of a prototype natural language question answering system, called Chat-80. Chat-80 has been designed to be both efficient and easily adaptable to a variety of applications. The system is implemented entirely in Prolog, a programming language based on logic. With the aid of a logic-based grammar formalism called extraposition grammars, Chat-80 translates English questions into the Prolog subset of logic. The resulting logical expression is then transformed by a planning algorithm into efficient Prolog, cf. &amp;quot;query optimisation&amp;quot; in a relational database. Finally, the Prolog form is executed to yield the answer. On a domain of world geography, most questions within the English subset are answered in well under one second, including relatively complex queries.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="false">
<authors>
<author>R R Burton</author>
</authors>
<title>Semantic grammar: an engineering technique for constructing natural language understanding systems. Report 3453. Bolt Beranek and</title>
<date>1976</date>
<booktitle>In Bolc., L., Ed., Natural Language Communication with Computers. SpringerVerlag. First appeared as an internal report, Les Grammaires de Metamorphose, in</booktitle>
<tech>Occasional Paper 19.</tech>
<publisher>Colmerauer, A.</publisher>
<institution>Dept. of Artificial Intelligence, University of Edinburgh</institution>
<location>Tokyo</location>
<contexts>
<context position="21620" citStr="Burton 1976" startWordPosition="3459" endWordPosition="3460">e to achieve a reasonably efficient behaviour with the above parsing strategy; in particular, leftrecursive rules have been avoided. It is somewhat contrary to current opinion that such a grammar, not carefully designed for parsing, can also be the basis of an efficient parser. One of the reasons for the efficiency in this case may be that the grammar itself makes no attempt to give the &amp;quot;right&amp;quot; modifier attachments, as discussed below. There has been some debate on whether the different parts of language analysis, such as the three distinguished above, should be done serially or concurrently (Burton 1976; Woods 1977). Some of the arguments for concurrent operation are that early semantic interpretation limits search by bringing in relevant information at the earliest possible moment, and that piecewise generation of the interpretation is psychologically more plausible. Given that we are not proposing a model of language comprehension in people, the latter argument is not directly relevant. The other argument is a two-edged one: by interweaving several operations, one is multiplying together their nondeterminacies. There are two main reasons why we have chosen serial operation. The first is th</context>
<context position="40815" citStr="Burton 1976" startWordPosition="6496" endWordPosition="6497">r to do too much. As regards portability, we think Chat-80 should be relatively easy to adapt to different applications — for the same reasons that we found it easy to adapt Dahl&apos;s program to English and to a different domain. Partly this is due to the fact that (in both systems) the domain dependent parts are clearly separated from the rest of the system, and are broken down into small units which can be added incrementally as &amp;quot;data&amp;quot; (see Appendix II). Thus our natural language analysis modules deal exclusively with general features of English, in contrast to the &amp;quot;semantic grammar&amp;quot; approach (Burton 1976). Now there are other practical systems which have not taken the &amp;quot;semantic grammar&amp;quot; approach but are, we feel, less easy to modify than Chat-80; LUNAR (Woods, Kaplan, and Nash-Webber 1972) is a good example. The reason lies in the way &amp;quot;meanings&amp;quot; are attached to words. In LUNAR, a meaning is simply a procedure. For nouns it is a procedure to generate objects in a certain class; for most other words it is a procedure to test whether some property is true of given objects. This entails that &amp;quot;meanings&amp;quot; can be executed in only one way, and precludes the kind of query planning done in Chat-80. But s</context>
</contexts>
<marker>Burton, 1976</marker>
<rawString> Burton, R.R. 1976 Semantic grammar: an engineering technique for constructing natural language understanding systems. Report 3453. Bolt Beranek and Newman Inc. (December). Byrd, L., Pereira, F., and Warren, D.H.D. 1980 A guide to version 3 of DEC-10 Prolog. Occasional Paper 19. Dept. of Artificial Intelligence, University of Edinburgh (July). Colmerauer, A. 1978 Metamorphosis grammars. In Bolc., L., Ed., Natural Language Communication with Computers. SpringerVerlag. First appeared as an internal report, Les Grammaires de Metamorphose, in November 1975. Colmerauer, A. 1982 An interesting subset of natural language. In Clark, K.L. and Tarnlund, S.-A., Ed., Logic Programming. Academic Press. Dahl, V. 1979 Quantification in a three-valued logic for natural language question-answering systems. IJCAI-79, Tokyo (August) 182-187. Dahl, V. 1981 Translating Spanish into logic through logic. AJCL</rawString>
</citation>
<citation valid="false">
<title>A framework for a portable natural language interface to large data bases. Technical Note 197. Al Center,</title>
<date>1979</date>
<journal>SRI International</journal>
<volume>18</volume>
<pages>327--367</pages>
<publisher>Yale University Press.</publisher>
<location>McCord, M.C.</location>
<marker>7</marker>
<rawString>, 3, 149-164. Konolige, K. 1979 A framework for a portable natural language interface to large data bases. Technical Note 197. Al Center, SRI International (October). McCord, M.C. 1982 Using slots and modifiers in logic grammars for natural language. Artificial Intelligence 18, 3, 327-367. Montague, R. 1974 The proper treatment of quantification in ordinary English. In Thomason, R.M., Ed., Formal Philosophy. Yale University Press. Pereira, F.C.N. 1981 Extraposition grammars. AJCL 7, 4, 243-</rawString>
</citation>
<citation valid="false">
<authors>
<author>F C N Pereira</author>
</authors>
<title>Logic for natural language analysis.</title>
<date>1982</date>
<journal>Artificial Intelligence</journal>
<booktitle>Prolog on the DECsystem-10. In Michie, D., Ed., Expert Systems in the Micro-Electronic Age.</booktitle>
<tech>Ph.D. thesis.</tech>
<volume>13</volume>
<pages>231--278</pages>
<publisher>Edinburgh University Press.</publisher>
<institution>University of</institution>
<location>Vanlehn, K.A.</location>
<note>Published as</note>
<marker>256</marker>
<rawString>. Pereira, F.C.N. 1982 Logic for natural language analysis. Ph.D. thesis. University of Edinburgh. Pereira, F.C.N. and Warren, D.H.D. 1980 Definite clause grammars for language analysis — a survey of the formalism and a comparison with augmented transition networks. Artificial Intelligence 13, 231-278. Pereira, L.M., Pereira, F., and Warren, D.H.D. 1978 User&apos;s guide to DECsystem-10 Prolog. Dept. of Artificial Intelligence, University of Edinburgh. Roussel, P. 1975 Prolog: manuel de reference et d&apos;utilisation Group d&apos;Intelligence Artificielle, UER de Luminy, Universit&amp; d&apos;Aix-Marseille II. Stonebraker, M., Wong, E., Kreps, P. and Held, G. 1976 The design and implementation of INGRES. ACM Trans. on Database Systems 1, 3 (Sept.) 189-222. Vanlehn, K.A. 1978 Determining the Scope of English Quantifiers. Master&apos;s thesis. Published as Report AI-TR-483. M.I.T. (June). Warren, D.H.D. 1977 Implementing Prolog — compiling predicate logic programs. Technical Research Reports 39 and 40. Dept. of Artificial Intelligence, University of Edinburgh (May). Warren, D.H.D. 1979 Prolog on the DECsystem-10. In Michie, D., Ed., Expert Systems in the Micro-Electronic Age. Edinburgh University Press. Warren, D.H.D. 1981 Efficient processing of interactive relational database queries expressed in logic. Seventh International Conference on Very Large Data Bases. Warren, D.H.D. 1982 Higher-order extensions to Prolog — are they needed? In Hayes, Michie, and Pao, Ed., Machine Intelligence 10. Ellis Horwood. Warren, D.H.D., Pereira, L.M., and Pereira, F.C.N. 1977 Prolog — the language and its implementation compared with Lisp. ACM Symposium on Al and Programming Languages (August). Woods, W.A. 1970 Transition network grammars for natural language analysis. Comm. ACM 13 (Oct.) 591-606. Woods, W.A. 1977 Semantics and quantification in natural language question answering. Report 3687. Bolt Beranek and Newman Inc. (November). Woods, W.A., Kaplan, R.M., and Nash-Webber, B. 1972 The Lunar science natural language information system: final report. Report 3438. Bolt Beranek and Newman Inc. (June).</rawString>
</citation>
<citation valid="false">
<authors>
<author>indian ocean</author>
</authors>
<title>What is the capital of each country bordering the Baltic?</title>
<marker>102</marker>
<rawString>ms. indian ocean. What is the capital of each country bordering the Baltic?</rawString>
</citation>
<citation valid="false">
<authors>
<author>ms</author>
</authors>
<journal>ans(C-X) &lt;= country(C) &amp; borders(C,baltic) &amp; capital(C,X).</journal>
<marker>81</marker>
<rawString>ms. ans(C-X) &lt;= country(C) &amp; borders(C,baltic) &amp; capital(C,X).</rawString>
</citation>
<citation valid="false">
<note>ms. ans(C-X) &lt;= borders(C,baltic) &amp; {country(C)} &amp; capital(C,X).</note>
<marker>12</marker>
<rawString>ms. ans(C-X) &lt;= borders(C,baltic) &amp; {country(C)} &amp; capital(C,X).</rawString>
</citation>
<citation valid="false">
<authors>
<author>denmark-copenhagen</author>
</authors>
<title>east germany-east berlin, finland-helsinki, poland-warsaw, soviet union-moscow, sweden-stockholm, west germany-bonn. What are the lattitudes of the countries north of the United Kingdom?</title>
<marker>29</marker>
<rawString>ms. denmark-copenhagen, east germany-east berlin, finland-helsinki, poland-warsaw, soviet union-moscow, sweden-stockholm, west germany-bonn. What are the lattitudes of the countries north of the United Kingdom?</rawString>
</citation>
<citation valid="false">
<note>ms. ans(C-LL) &lt;= country(C) &amp; northof(C,united kingdom) &amp; setof(L,latitude(C,L),LL).</note>
<marker>102</marker>
<rawString>ms. ans(C-LL) &lt;= country(C) &amp; northof(C,united kingdom) &amp; setof(L,latitude(C,L),LL).</rawString>
</citation>
<citation valid="false">
<note>ms. ans(C-LL) &lt;= northof(C,united kingdom) &amp;{country(C)} &amp; setof(L,latitude(C,L),LL).</note>
<marker>26</marker>
<rawString>ms. ans(C-LL) &lt;= northof(C,united kingdom) &amp;{country(C)} &amp; setof(L,latitude(C,L),LL).</rawString>
</citation>
<citation valid="false">
<title>ms. canada-60 degrees, denmark-55 degrees, finland-65 degrees, iceland-65 degrees, norway-64 degrees, soviet union-57 degrees, sweden-63 degrees. Which country is bordered by two seas?</title>
<marker>141</marker>
<rawString>ms. canada-60 degrees, denmark-55 degrees, finland-65 degrees, iceland-65 degrees, norway-64 degrees, soviet union-57 degrees, sweden-63 degrees. Which country is bordered by two seas?</rawString>
</citation>
<citation valid="false">
<authors>
<author>ms</author>
</authors>
<journal>ans(C) &lt;= country(C) &amp; numberof(X,sea(X) &amp;</journal>
<marker>42</marker>
<rawString>. ms. ans(C) &lt;= country(C) &amp; numberof(X,sea(X) &amp; borders(C,X),2).</rawString>
</citation>
<citation valid="false">
<booktitle>ms. ans(C) &lt;= numberof(X,sea(X) &amp; borders(C,X),2) &amp; {country(C)}.</booktitle>
<marker>11</marker>
<rawString>ms. ans(C) &lt;= numberof(X,sea(X) &amp; borders(C,X),2) &amp; {country(C)}.</rawString>
</citation>
<citation valid="false">
<authors>
<author>egypt</author>
</authors>
<title>iran, israel, saudi arabia, turkey. How many countries does the Danube flow through?</title>
<marker>206</marker>
<rawString>ms. egypt, iran, israel, saudi arabia, turkey. How many countries does the Danube flow through?</rawString>
</citation>
<citation valid="false">
<marker>48</marker>
<rawString>ms. ans(N) &lt;= numberof(C,country(C) &amp; flows(danube,C),N).</rawString>
</citation>
<citation valid="false">
<note>ms. ans(N) &lt;= numberof(C,flows(danube,C) &amp; {country(C)},N).</note>
<marker>3</marker>
<rawString>ms. ans(N) &lt;= numberof(C,flows(danube,C) &amp; {country(C)},N).</rawString>
</citation>
<citation valid="false">
<title>From what country does a river flow into the Persian Gulf?</title>
<marker>21</marker>
<rawString>ms. 6. From what country does a river flow into the Persian Gulf?</rawString>
</citation>
<citation valid="false">
<authors>
<author>ms</author>
</authors>
<journal>ans(C) &lt;= river(R) &amp; country(C) &amp;</journal>
<marker>69</marker>
<rawString>ms. ans(C) &lt;= river(R) &amp; country(C) &amp; flows(R,C,persian gulf).</rawString>
</citation>
<citation valid="false">
<note>ms. ans(C) &lt;= flows(R,C,persian gulf) &amp; {river(R)} &amp; {country(C)}.</note>
<marker>12</marker>
<rawString>ms. ans(C) &lt;= flows(R,C,persian gulf) &amp; {river(R)} &amp; {country(C)}.</rawString>
</citation>
<citation valid="false">
<authors>
<author>iraq</author>
</authors>
<title>What is the total area of countries south of the Equator not in Australasia?</title>
<marker>23</marker>
<rawString>ms. iraq. What is the total area of countries south of the Equator not in Australasia?</rawString>
</citation>
<citation valid="false">
<authors>
<author>ms</author>
</authors>
<journal>ans(T) &lt;= setof(A-C,area(C,A) &amp; country(C) &amp; southof(C,equator) &amp; \ +in(C,australasia),S) &amp; aggregate(total,S,T).</journal>
<marker>115</marker>
<rawString>ms. ans(T) &lt;= setof(A-C,area(C,A) &amp; country(C) &amp; southof(C,equator) &amp; \ +in(C,australasia),S) &amp; aggregate(total,S,T).</rawString>
</citation>
<citation valid="false">
<authors>
<author>ms</author>
</authors>
<journal>ans(T) &lt;= setof(A-C,southof(C,equator) &amp; area(C,A) &amp; {countryof(C)} &amp; \ +in(C,australasia),S) &amp; aggregate(total,S,T).</journal>
<marker>23</marker>
<rawString>ms. ans(T) &lt;= setof(A-C,southof(C,equator) &amp; area(C,A) &amp; {countryof(C)} &amp; \ +in(C,australasia),S) &amp; aggregate(total,S,T).</rawString>
</citation>
<citation valid="false">
<marker>182</marker>
<rawString>ms. 10228 ksqmiles. aggregate (average,S,Av).</rawString>
</citation>
<citation valid="false">
<title>ms. africa-233 ksqmiles, america-496 ksqmiles, asia-485 ksqmiles, australasia-543 ksqmiles, europe-58 ksqmiles. How many countries are there in each continent?</title>
<marker>759</marker>
<rawString>ms. africa-233 ksqmiles, america-496 ksqmiles, asia-485 ksqmiles, australasia-543 ksqmiles, europe-58 ksqmiles. How many countries are there in each continent?</rawString>
</citation>
<citation valid="false">
<note>ms. ans(X-N) &lt;= continent(X) &amp; numberof(C,country(C) &amp; in(C,X),N).</note>
<marker>50</marker>
<rawString>ms. ans(X-N) &lt;= continent(X) &amp; numberof(C,country(C) &amp; in(C,X),N).</rawString>
</citation>
<citation valid="false">
<booktitle>ms. ans(X-N) &lt;= continent(X) &amp; numberof (C,in(C,X) &amp; {country(C)1,N).</booktitle>
<marker>19</marker>
<rawString>ms. ans(X-N) &lt;= continent(X) &amp; numberof (C,in(C,X) &amp; {country(C)1,N).</rawString>
</citation>
<citation valid="false">
<authors>
<author>africa-48</author>
</authors>
<title>america-31, asia-39, australasia-6, europe-32. Is there some ocean that does not border any country?</title>
<marker>352</marker>
<rawString>ms. africa-48, america-31, asia-39, australasia-6, europe-32. Is there some ocean that does not border any country?</rawString>
</citation>
<citation valid="false">
<authors>
<author>ms</author>
</authors>
<journal>ans(yes) &lt;= ocean(X) &amp; \ +exists(C,borders(X,C) &amp; country(C)).</journal>
<marker>68</marker>
<rawString>ms. ans(yes) &lt;= ocean(X) &amp; \ +exists(C,borders(X,C) &amp; country(C)).</rawString>
</citation>
<citation valid="false">
<authors>
<author>ms</author>
</authors>
<journal>ans(yes) &lt;= { ocean(X) &amp; \ +exists(C,borders(X,C) &amp; {country(C)))}.</journal>
<marker>9</marker>
<rawString>ms. ans(yes) &lt;= { ocean(X) &amp; \ +exists(C,borders(X,C) &amp; {country(C)))}.</rawString>
</citation>
<citation valid="false">
<authors>
<author>yes</author>
</authors>
<title>What does border the ocean that does not border any country?</title>
<marker>14</marker>
<rawString>ms. yes. What does border the ocean that does not border any country?</rawString>
</citation>
<citation valid="false">
<authors>
<author>ms</author>
</authors>
<journal>ans(Y) &lt;= ocean(X) &amp; \ +exists(C,country(C) &amp; borders(X,C)) &amp; borders (Y,X).</journal>
<marker>59</marker>
<rawString>ms. ans(Y) &lt;= ocean(X) &amp; \ +exists(C,country(C) &amp; borders(X,C)) &amp; borders (Y,X).</rawString>
</citation>
<citation valid="false">
<authors>
<author>ms</author>
</authors>
<journal>ans(Y) &lt;= ocean(X) &amp; \ +exists(C,borders(X,C) &amp; {country,(C)}) &amp; borders (Y,X).</journal>
<marker>20</marker>
<rawString>ms. ans(Y) &lt;= ocean(X) &amp; \ +exists(C,borders(X,C) &amp; {country,(C)}) &amp; borders (Y,X).</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>