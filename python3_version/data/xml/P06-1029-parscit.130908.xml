<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000099">
<title confidence="0.987793">
Approximation Lasso Methods for Language Modeling
</title>
<author confidence="0.970165">
Jianfeng Gao
</author>
<affiliation confidence="0.939118">
Microsoft Research
</affiliation>
<address confidence="0.845601">
One Microsoft Way
Redmond WA 98052 USA
</address>
<email confidence="0.965041">
jfgao@microsoft.com
</email>
<author confidence="0.914249">
Hisami Suzuki
</author>
<affiliation confidence="0.889298">
Microsoft Research
</affiliation>
<address confidence="0.826586">
One Microsoft Way
Redmond WA 98052 USA
</address>
<email confidence="0.958553">
hisamis@microsoft.com
</email>
<author confidence="0.987055">
Bin Yu
</author>
<affiliation confidence="0.998387">
Department of Statistics
University of California
</affiliation>
<address confidence="0.501596">
Berkeley., CA 94720 U.S.A.
</address>
<email confidence="0.970187">
binyu@stat.berkeley.edu
</email>
<sectionHeader confidence="0.992899" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999925041666667">
Lasso is a regularization method for pa-
rameter estimation in linear models. It op-
timizes the model parameters with respect
to a loss function subject to model com-
plexities. This paper explores the use of
lasso for statistical language modeling for
text input. Owing to the very large number
of parameters, directly optimizing the pe-
nalized lasso loss function is impossible.
Therefore, we investigate two approxima-
tion methods, the boosted lasso (BLasso)
and the forward stagewise linear regres-
sion (FSLR). Both methods, when used
with the exponential loss function, bear
strong resemblance to the boosting algo-
rithm which has been used as a discrimi-
native training method for language mod-
eling. Evaluations on the task of Japanese
text input show that BLasso is able to
produce the best approximation to the
lasso solution, and leads to a significant
improvement, in terms of character error
rate, over boosting and the traditional
maximum likelihood estimation.
</bodyText>
<sectionHeader confidence="0.998783" genericHeader="introduction">
1 Introduction
</sectionHeader>
<bodyText confidence="0.99997250909091">
Language modeling (LM) is fundamental to a
wide range of applications. Recently, it has been
shown that a linear model estimated using dis-
criminative training methods, such as the boost-
ing and perceptron algorithms, outperforms
significantly a traditional word trigram model
trained using maximum likelihood estimation
(MLE) on several tasks such as speech recogni-
tion and Asian language text input (Bacchiani et
al. 2004; Roark et al. 2004; Gao et al. 2005; Suzuki
and Gao 2005).
The success of discriminative training meth-
ods is largely due to fact that unlike the tradi-
tional approach (e.g., MLE) that maximizes the
function (e.g., likelihood of training data) that is
loosely associated with error rate, discriminative
training methods aim to directly minimize the
error rate on training data even if they reduce the
likelihood. However, given a finite set of training
samples, discriminative training methods could
lead to an arbitrary complex model for the pur-
pose of achieving zero training error. It is
well-known that complex models exhibit high
variance and perform poorly on unseen data.
Therefore some regularization methods have to
be used to control the complexity of the model.
Lasso is a regularization method for parame-
ter estimation in linear models. It optimizes the
model parameters with respect to a loss function
subject to model complexities. The basic idea of
lasso is originally proposed by Tibshirani (1996).
Recently, there have been several implementa-
tions and experiments of lasso on multi-class
classification tasks where only a small number of
features need to be handled and the lasso solu-
tion can be directly computed via numerical
methods. To our knowledge, this paper presents
the first empirical study of lasso for a realistic,
large scale task: LM for Asian language text in-
put. Because the task utilizes millions of features
and training samples, directly optimizing the
penalized lasso loss function is impossible.
Therefore, two approximation methods, the
boosted lasso (BLasso, Zhao and Yu 2004) and
the forward stagewise linear regression (FSLR,
Hastie et al. 2001), are investigated. Both meth-
ods, when used with the exponential loss func-
tion, bear strong resemblance to the boosting
algorithm which has been used as a discrimina-
tive training method for LM. Evaluations on the
task of Japanese text input show that BLasso is
able to produce the best approximation to the
lasso solution, and leads to a significant im-
provement, in terms of character error rate, over
the boosting algorithm and the traditional MLE.
</bodyText>
<sectionHeader confidence="0.863454" genericHeader="method">
2 LM Task and Problem Definition
</sectionHeader>
<bodyText confidence="0.999976">
This paper studies LM on the application of
Asian language (e.g. Chinese or Japanese) text
input, a standard method of inputting Chinese or
Japanese text by converting the input phonetic
symbols into the appropriate word string. In this
paper we call the task IME, which stands for
</bodyText>
<page confidence="0.979172">
225
</page>
<note confidence="0.5455395">
Proceedings of the 21st International Conference on Computational Linguistics and 44th Annual Meeting of the ACL, pages 225–232,
Sydney, July 2006. c�2006 Association for Computational Linguistics
</note>
<bodyText confidence="0.993515916666667">
input method editor, based on the name of the
commonly used Windows-based application.
Performance on IME is measured in terms of
the character error rate (CER), which is the
number of characters wrongly converted from
the phonetic string divided by the number of
characters in the correct transcript.
Similar to speech recognition, IME is viewed
as a Bayes decision problem. Let A be the input
phonetic string. An IME system’s task is to
choose the most likely word string W* among
those candidates that could be converted from A:
</bodyText>
<equation confidence="0.998139666666667">
W(1)
= argmaxP(W  |A) = argmaxP(W)P(A |
W∈GEN(A) W∈GEN(A)
</equation>
<bodyText confidence="0.998720230769231">
where GEN(A) denotes the candidate set given A.
Unlike speech recognition, however, there is no
acoustic ambiguity as the phonetic string is in-
putted by users. Moreover, we can assume a
unique mapping from W and A in IME as words
have unique readings, i.e. P(A|W) = 1. So the
decision of Equation (1) depends solely upon
P(W), making IME an ideal evaluation test bed
for LM.
In this study, the LM task for IME is formu-
lated under the framework of linear models (e.g.,
Duda et al. 2001). We use the following notation,
adapted from Collins and Koo (2005):
</bodyText>
<listItem confidence="0.97287328">
• Training data is a set of example in-
put/output pairs. In LM for IME, training sam-
ples are represented as {Ai, WiR}, for i = 1...M,
where each Ai is an input phonetic string and WiR
is the reference transcript of Ai.
• We assume some way of generating a set of
candidate word strings given A, denoted by
GEN(A). In our experiments, GEN(A) consists of
top n word strings converted from A using a
baseline IME system that uses only a word tri-
gram model.
• We assume a set of D+1 features fd(W), for d
= 0...D. The features could be arbitrary functions
that map W to real values. Using vector notation,
we have f(W)∈ℜD+1, where f(W) = [f0(W), f1(W),
..., fD(W)]T. f0(W) is called the base feature, and is
defined in our case as the log probability that the
word trigram model assigns to W. Other features
(fd(W), for d = 1...D) are defined as the counts of
word n-grams (n = 1 and 2 in our experiments) in
W.
• Finally, the parameters of the model form a
vector of D+1 dimensions, each for one feature
function, λ = [λ0, λ1, ..., λD]. The score of a word
string W can be written as
</listItem>
<equation confidence="0.9470495">
D
Score(W, λ) = λf(W) ∑
=
d=0
</equation>
<bodyText confidence="0.882275">
The decision rule of Equation (1) is rewritten as
</bodyText>
<figure confidence="0.60563525">
1 Set λ0 = argminλ0ExpLoss(λ); and λd = 0 for d=1...D
2 Select a feature fk* which has largest estimated
impact on reducing ExpLoss of Eq. (6)
3 Update λk* Å λk* + δ*, and return to Step 2
</figure>
<figureCaption confidence="0.998759">
Figure 1: The boosting algorithm
</figureCaption>
<equation confidence="0.985157">
W *(, ) arg max ( , )
A λ = Score W λ
GEN(A)
</equation>
<bodyText confidence="0.99806635">
Equation (3) views IME as a ranking problem,
where the model gives the ranking score, not
probabilities. We therefore do not evaluate the
model via perplexity.
Now, assume that we can measure the num-
ber of conversion errors in W by comparing it
with a reference transcript WR using an error
function Er(WR,W), which is the string edit dis-
tance function in our case. We call the sum of
error counts over the training samples sample risk.
Our goal then is to search for the best parameter
set λ which minimizes the sample risk, as in
Equation (4):
However, (4) cannot be optimized easily since
Er(.) is a piecewise constant (or step) function of λ
and its gradient is undefined. Therefore, dis-
criminative methods apply different approaches
that optimize it approximately. The boosting
algorithm described below is one of such ap-
proaches.
</bodyText>
<sectionHeader confidence="0.987814" genericHeader="method">
3 Boosting
</sectionHeader>
<bodyText confidence="0.999795875">
This section gives a brief review of the boosting
algorithm, following the description of some
recent work (e.g., Schapire and Singer 1999;
Collins and Koo 2005).
The boosting algorithm uses an exponential
loss function (ExpLoss) to approximate the sam-
ple risk in Equation (4). We define the margin of
the pair (WR, W) with respect to the model λ as
</bodyText>
<equation confidence="0.998836333333333">
M W R W = Score W R λ − Score W λ
( , ) ( , ) ( , ) (5)
Then, ExpLoss is defined as
ExpLoss( )
λ = ∑ ∑exp( ( , ))
R
−M W W (6)
i i
i MW
=1. .. ∈ GEN ( )
A
i i
</equation>
<bodyText confidence="0.947354714285714">
Notice that ExpLoss is convex so there is no
problem with local minima when optimizing it. It
is shown in Freund et al. (1998) and Collins and
Koo (2005) that there exist gradient search pro-
cedures that converge to the right solution.
Figure 1 summarizes the boosting algorithm
we used. After initialization, Steps 2 and 3 are
</bodyText>
<equation confidence="0.981796">
=
i
λ
M
1...
. (4)
λ
def
∑
MSR = arg min Er(WiR , Wi* (A
λ
i , ))
W)
λdfd W
( ). (2)
. (3)
W∈
</equation>
<page confidence="0.980785">
226
</page>
<bodyText confidence="0.9999768">
repeated N times; at each iteration, a feature is
chosen and its weight is updated as follows.
First, we define Upd(λ, k, δ) as an updated
model, with the same parameter values as λ with
the exception of λk, which is incremented by δ
</bodyText>
<equation confidence="0.53157">
Upd(λ,k,δ) = Jλ0,λ,...,λk +δ,...,λD }
</equation>
<bodyText confidence="0.9948845">
Then, Steps 2 and 3 in Figure 1 can be rewritten
as Equations (7) and (8), respectively.
</bodyText>
<equation confidence="0.996311428571429">
(
k *,*) argminExpLoss(Upd( , , ))
δ = λ k δ (7)
k,δ
t Upd( 1,k*,δ*)
λt−
λ = (8)
</equation>
<bodyText confidence="0.999177071428571">
The boosting algorithm can be too greedy:
Each iteration usually reduces the ExpLoss(.) on
training data, so for the number of iterations
large enough this loss can be made arbitrarily
small. However, fitting training data too well
eventually leads to overfiting, which degrades
the performance on unseen test data (even
though in boosting overfitting can happen very
slowly).
Shrinkage is a simple approach to dealing
with the overfitting problem. It scales the incre-
mental step δ by a small constant ν, ν ∈ (0, 1).
Thus, the update of Equation (8) with shrinkage
is
</bodyText>
<equation confidence="0.95054">
t Upd( 1,k *,νδ *)
λt−
λ = (9)
</equation>
<bodyText confidence="0.98772">
Empirically, it has been found that smaller values
of ν lead to smaller numbers of test errors.
</bodyText>
<sectionHeader confidence="0.993712" genericHeader="method">
4 Lasso
</sectionHeader>
<bodyText confidence="0.999931333333333">
Lasso is a regularization method for estimation in
linear models (Tibshirani 1996). It regularizes or
shrinks a fitted model through an L1 penalty or
constraint.
Let T(λ) denote the L1 penalty of the model,
i.e., T(λ) = ∑d = 0...D|λd|. We then optimize the
model λ so as to minimize a regularized loss
function on training data, called lasso loss defined
as
</bodyText>
<equation confidence="0.848109">
LassoLoss( , ) ExpLoss( ) ( )
λ α = λ +αT λ (10)
</equation>
<bodyText confidence="0.99978175">
where T(λ) generally penalizes larger models (or
complex models), and the parameter α controls
the amount of regularization applied to the esti-
mate. Setting α = 0 reverses the LassoLoss to the
unregularized ExpLoss; as α increases, the model
coefficients all shrink, each ultimately becoming
zero. In practice, α should be adaptively chosen
to minimize an estimate of expected loss, e.g., α
decreases with the increase of the number of
iterations.
Computation of the solution to the lasso prob-
lem has been studied for special loss functions.
For least square regression, there is a fast algo-
rithm LARS to find the whole lasso path for dif-
ferent α’ s (Obsborn et al. 2000a; 2000b; Efron et
al. 2004); for 1-norm SVM, it can be transformed
into a linear programming problem with a fast
algorithm similar to LARS (Zhu et al. 2003).
However, the solution to the lasso problem for a
general convex loss function and an adaptive α
remains open. More importantly for our pur-
poses, directly minimizing lasso function of
Equation (10) with respect to λ is not possible
when a very large number of model parameters
are employed, as in our task of LM for IME.
Therefore we investigate below two methods that
closely approximate the effect of the lasso, and
are very similar to the boosting algorithm.
It is also worth noting the difference between
L1 and L2 penalty. The classical Ridge Regression
setting uses an L2 penalty in Equation (10) i.e.,
T(λ) = ∑d = 0...D(λd)2, which is much easier to
minimize (for least square loss but not for Ex-
pLoss). However, recent research (Donoho et al.
1995) shows that the L1 penalty is better suited for
sparse situations, where there are only a small
number of features with nonzero weights among
all candidate features. We find that our task is
indeed a sparse situation: among 860,000 features,
in the resulting linear model only around 5,000
features have nonzero weights. We then focus on
the L1 penalty. We leave the empirical compari-
son of the L1 and L2 penalty on the LM task to
future work.
</bodyText>
<subsectionHeader confidence="0.646687">
4.1 Forward Stagewise Linear
Regression (FSLR)
</subsectionHeader>
<bodyText confidence="0.9999005">
The first approximation method we used is FSLR,
described in (Algorithm 10.4, Hastie et al. 2001),
where Steps 2 and 3 in Figure 1 are performed
according to Equations (7) and (11), respectively.
</bodyText>
<equation confidence="0.997490833333333">
(
k *,*) argminExpLoss(Upd( , , ))
δ = λ k δ (7)
k,δ
λt = Upd( −1 , k*,ε × sign(δ *))
λt (11)
</equation>
<bodyText confidence="0.999542">
Notice that FSLR is very similar to the boosting
algorithm with shrinkage in that at each step, the
feature fk* that has largest estimated impact on
reducing ExpLoss is selected. The only difference
is that FSLR updates the weight of fk* by a small
fixed step size ε. By taking such small steps, FSLR
imposes some implicit regularization, and can
closely approximate the effect of the lasso in a
local sense (Hastie et al. 2001). Empirically, we
find that the performance of the boosting algo-
rithm with shrinkage closely resembles that of
FSLR, with the learning rate parameter ν corre-
sponding to ε.
</bodyText>
<page confidence="0.983492">
227
</page>
<subsectionHeader confidence="0.94396">
4.2 Boosted Lasso (BLasso)
</subsectionHeader>
<bodyText confidence="0.999210777777778">
The second method we used is a modified ver-
sion of the BLasso algorithm described in Zhao
and Yu (2004). There are two major differences
between BLasso and FSLR. At each iteration,
BLasso can take either a forward step or a backward
step. Similar to the boosting algorithm and FSLR,
at each forward step, a feature is selected and its
weight is updated according to Equations (12)
and (13).
</bodyText>
<equation confidence="0.997701571428571">
(
k*, *) argminExpLoss(Upd( , ,
δ = λ k δ )) (12)
k , δ ε
=±
λt = Upd( −1, k*,ε × sign(δ *))
λt (13)
</equation>
<bodyText confidence="0.992758235294118">
However, there is an important difference be-
tween Equations (12) and (7). In the boosting
algorithm with shrinkage and FSLR, as shown in
Equation (7), a feature is selected by its impact on
reducing the loss with its optimal update δ*. In
contract, in BLasso, as shown in Equation (12),
the optimization over δ is removed, and for each
feature, its loss is calculated with an update of
either +ε or -ε, i.e., the grid search is used for
feature selection. We will show later that this
seemingly trivial difference brings a significant
improvement.
The backward step is unique to BLasso. In
each iteration, a feature is selected and its weight
is updated backward if and only if it leads to a
decrease of the lasso loss, as shown in Equations
(14) and (15):
</bodyText>
<equation confidence="0.960843333333333">
λ , k,− sign(λk) × ε) (14)
k ,λk
= Upd(λt−1,k*,−sign(λk*)× ε ) (15)
</equation>
<bodyText confidence="0.951273590909091">
if LassoLoss(λt −1, αt−1) − LassoLoss(λt,α t) &gt; θ
where θ is a tolerance parameter.
Figure 2 summarizes the BLasso algorithm we
used. After initialization, Steps 4 and 5 are re-
peated N times; at each iteration, a feature is
chosen and its weight is updated either backward
or forward by a fixed amount ε. Notice that the
value of α is adaptively chosen according to the
reduction of ExpLoss during training. The algo-
rithm starts with a large initial α, and then at each
forward step the value of α decreases until the
ExpLoss stops decreasing. This is intuitively
desirable: It is expected that most highly effective
features are selected in early stages of training, so
the reduction of ExpLoss at each step in early
stages are more substantial than in later stages.
These early steps coincide with the boosting steps
most of the time. In other words, the effect of
backward steps is more visible at later stages.
Our implementation of BLasso differs slightly
from the original algorithm described in Zhao
and Yu (2004). Firstly, because the value of the
base feature f0 is the log probability (assigned by
a word trigram model) and has a different range
from that of other features as in Equation (2), λ0 is
set to optimize ExpLoss in the initialization step
(Step 1 in Figure 2) and remains fixed during
training. As suggested by Collins and Koo (2005),
this ensures that the contribution of the
log-likelihood feature f0 is well-calibrated with
respect to ExpLoss. Secondly, when updating a
feature weight, if the size of the optimal update
step (computed via Equation (7)) is smaller than
ε, we use the optimal step to update the feature.
Therefore, in our implementation BLasso does
not always take a fixed step; it may take steps
whose size is smaller than ε. In our initial ex-
periments we found that both changes (also used
in our implementations of boosting and FSLR)
were crucial to the performance of the methods.
1 Initialize λ0: set λ0 = argminλ0ExpLoss(λ), and λd = 0
for d=1...D.
2 Take a forward step according to Eq. (12) and (13),
and the updated model is denoted by λ1
</bodyText>
<figure confidence="0.944076571428571">
3 Initialize α = (ExpLoss(λ0)-ExpLoss(λ1))/ε
4 Take a backward step if and only if it leads to a
decrease of LassoLoss according to Eq. (14) and
(15), where θ = 0; otherwise
5 Take a forward step according to Eq. (12) and (13);
update α = min(α, (ExpLoss(λt-1)-ExpLoss(λt))/ε );
and return to Step 4.
</figure>
<figureCaption confidence="0.99997">
Figure 2: The BLasso algorithm
</figureCaption>
<bodyText confidence="0.999928928571429">
(Zhao and Yu 2004) provides theoretical justi-
fications for BLasso. It has been proved that (1) it
guarantees that it is safe for BLasso to start with
an initial α which is the largest α that would
allow an ε step away from 0 (i.e., larger α’s cor-
respond to T(λ)=0); (2) for each value of α, BLasso
performs coordinate descent (i.e., reduces Ex-
pLoss by updating the weight of a feature) until
there is no descent step; and (3) for each step
where the value of α decreases, it guarantees that
the lasso loss is reduced. As a result, it can be
proved that for a finite number of features and θ
= 0, the BLasso algorithm shown in Figure 2
converges to the lasso solution when ε Æ 0.
</bodyText>
<sectionHeader confidence="0.997716" genericHeader="evaluation">
5 Evaluation
</sectionHeader>
<subsectionHeader confidence="0.556855">
5.1 Settings
</subsectionHeader>
<bodyText confidence="0.9999235">
We evaluated the training methods described
above in the so-called cross-domain language
model adaptation paradigm, where we adapt a
model trained on one domain (which we call the
</bodyText>
<equation confidence="0.819085857142857">
minExpLoss(Upd(
k
* =
arg
≠0
t
λ
</equation>
<page confidence="0.990441">
228
</page>
<bodyText confidence="0.999587904761905">
background domain) to a different domain (adap-
tation domain), for which only a small amount of
training data is available.
The data sets we used in our experiments
came from five distinct sources of text. A
36-million-word Nikkei Newspaper corpus was
used as the background domain, on which the
word trigram model was trained. We used four
adaptation domains: Yomiuri (newspaper cor-
pus), TuneUp (balanced corpus containing
newspapers and other sources of text), Encarta
(encyclopedia) and Shincho (collection of novels).
All corpora have been pre-word-segmented us-
ing a lexicon containing 167,107 entries. For each
of the four domains, we created training data
consisting of 72K sentences (0.9M~1.7M words)
and test data of 5K sentences (65K~120K words)
from each adaptation domain. The first 800 and
8,000 sentences of each adaptation training data
were also used to show how different sizes of
training data affected the performances of vari-
ous adaptation methods. Another 5K-sentence
subset was used as held-out data for each do-
main.
We created the training samples for discrimi-
native learning as follows. For each phonetic
string A in adaptation training data, we pro-
duced a lattice of candidate word strings W using
the baseline system described in (Gao et al. 2002),
which uses a word trigram model trained via
MLE on the Nikkei Newspaper corpus. For effi-
ciency, we kept only the best 20 hypotheses in its
candidate conversion set GEN(A) for each
training sample for discriminative training. The
oracle best hypothesis, which gives the minimum
number of errors, was used as the reference tran-
script of A.
We used unigrams and bigrams that occurred
more than once in the training set as features in
the linear model of Equation (2). The total num-
ber of candidate features we used was around
860,000.
</bodyText>
<subsectionHeader confidence="0.99958">
5.2 Main Results
</subsectionHeader>
<bodyText confidence="0.999934088235294">
Table 1 summarizes the results of various model
training (adaptation) methods in terms of CER
(%) and CER reduction (in parentheses) over
comparing models. In the first column, the
numbers in parentheses next to the domain name
indicates the number of training sentences used
for adaptation.
Baseline, with results shown in Column 3, is
the word trigram model. As expected, the CER
correlates very well the similarity between the
background domain and the adaptation domain,
where domain similarity is measured in terms of
cross entropy (Yuan et al. 2005) as shown in Col-
umn 2.
MAP (maximum a posteriori), with results
shown in Column 4, is a traditional LM adapta-
tion method where the parameters of the back-
ground model are adjusted in such a way that
maximizes the likelihood of the adaptation data.
Our implementation takes the form of linear
interpolation as described in Bacchiani et al.
(2004): P(wi|h) = λPb(wi|h) + (1-λ)Pa(wi|h), where
Pb is the probability of the background model, Pa
is the probability trained on adaptation data
using MLE and the history h corresponds to two
preceding words (i.e. Pb and Pa are trigram
probabilities). λ is the interpolation weight opti-
mized on held-out data.
Boosting, with results shown in Column 5, is
the algorithm described in Figure 1. In our im-
plementation, we use the shrinkage method
suggested by Schapire and Singer (1999) and
Collins and Koo (2005). At each iteration, we
used the following update for the kth feature
</bodyText>
<equation confidence="0.986564">
+
1 C Z
+ ε (16)
k
= log
k
</equation>
<bodyText confidence="0.999972129032258">
where Ck+ is a value increasing exponentially
with the sum of margins of (WR, W) pairs over the
set where fk is seen in WR but not in W; Ck- is the
value related to the sum of margins over the set
where fk is seen in W but not in WR. ε is a
smoothing factor (whose value is optimized on
held-out data) and Z is a normalization constant
(whose value is the ExpLoss(.) of training data
according to the current model). We see that εZ in
Equation (16) plays the same role as ν in Equation
(9).
BLasso, with results shown in Column 6, is
the algorithm described in Figure 2. We find that
the performance of BLasso is not very sensitive to
the selection of the step size ε across training sets
of different domains and sizes. Although small ε
is preferred in theory as discussed earlier, it
would lead to a very slow convergence. There-
fore, in our experiments, we always use a large
step (ε = 0.5) and use the so-called early stopping
strategy, i.e., the number of iterations before
stopping is optimized on held-out data.
In the task of LM for IME, there are millions of
features and training samples, forming an ex-
tremely large and sparse matrix. We therefore
applied the techniques described in Collins and
Koo (2005) to speed up the training procedure.
The resulting algorithms run in around 15 and 30
minutes respectively for Boosting and BLasso to
converge on an XEONTM MP 1.90GHz machine
when training on an 8K-sentnece training set.
</bodyText>
<equation confidence="0.977171">
δk
C Z
2
_ + ε
</equation>
<page confidence="0.993374">
229
</page>
<bodyText confidence="0.999969655172414">
The results in Table 1 give rise to several ob-
servations. First of all, both discriminative train-
ing methods (i.e., Boosting and BLasso) outper-
form MAP substantially. The improvement mar-
gins are larger when the background and adap-
tation domains are more similar. The phenome-
non is attributed to the underlying difference
between the two adaptation methods: MAP aims
to improve the likelihood of a distribution, so if
the adaptation domain is very similar to the
background domain, the difference between the
two underlying distributions is so small that
MAP cannot adjust the model effectively. Dis-
criminative methods, on the other hand, do not
have this limitation for they aim to reduce errors
directly. Secondly, BLasso outperforms Boosting
significantly (p-value &lt; 0.01) on all test sets. The
improvement margins vary with the training sets
of different domains and sizes. In general, in
cases where the adaptation domain is less similar
to the background domain and larger training set
is used, the improvement of BLasso is more visi-
ble.
Note that the CER results of FSLR are not in-
cluded in Table 1 because it achieves very similar
results to the boosting algorithm with shrinkage
if the controlling parameters of both algorithms
are optimized via cross-validation. We shall dis-
cuss their difference in the next section.
</bodyText>
<subsectionHeader confidence="0.994206">
5.3 Dicussion
</subsectionHeader>
<bodyText confidence="0.999990407407408">
This section investigates what components of
BLasso bring the improvement over Boosting.
Comparing the algorithms in Figures 1 and 2, we
notice three differences between BLasso and
Boosting: (i) the use of backward steps in BLasso;
(ii) BLasso uses the grid search (fixed step size)
for feature selection in Equation (12) while
Boosting uses the continuous search (optimal
step size) in Equation (7); and (iii) BLasso uses a
fixed step size for feature update in Equation (13)
while Boosting uses an optimal step size in
Equation (8). We then investigate these differ-
ences in turn.
To study the impact of backward steps, we
compared BLasso with the boosting algorithm
with a fixed step search and a fixed step update,
henceforth referred to as F-Boosting. F-Boosting
was implemented as Figure 2, by setting a large
value to θ in Equation (15), i.e., θ = 103, to prohibit
backward steps. We find that although the
training error curves of BLasso and F-Boosting
are almost identical, the T(λ) curves grow apart
with iterations, as shown in Figure 3. The results
show that with backward steps, BLasso achieves
a better approximation to the true lasso solution:
It leads to a model with similar training errors
but less complex (in terms of L1 penalty). In our
experiments we find that the benefit of using
backward steps is only visible in later iterations
when BLasso’s backward steps kick in. A typical
example is shown in Figure 4. The early steps fit
to highly effective features and in these steps
BLasso and F-Boosting agree. For later steps,
fine-tuning of features is required. BLasso with
backward steps provides a better mechanism
than F-Boosting to revise the previously chosen
features to accommodate this fine level of tuning.
Consequently we observe the superior perform-
ance of BLasso at later stages as shown in our
experiments.
As well-known in linear regression models,
when there are many strongly correlated fea-
tures, model parameters can be poorly estimated
and exhibit high variance. By imposing a model
size constraint, as in lasso, this phenomenon is
alleviated. Therefore, we speculate that a better
approximation to lasso, as BLasso with backward
steps, would be superior in eliminating the nega-
tive effect of strongly correlated features in
model estimation. To verify our speculation, we
performed the following experiments. For each
training set, in addition to word unigram and
bigram features, we introduced a new type of
features called headword bigram.
As described in Gao et al. (2002), headwords
are defined as the content words of the sentence.
Therefore, headword bigrams constitute a special
type of skipping bigrams which can capture
dependency between two words that may not be
adjacent. In reality, a large portion of headword
bigrams are identical to word bigrams, as two
headwords can occur next to each other in text. In
the adaptation test data we used, we find that
headword bigram features are for the most part
either completely overlapping with the word bi-
gram features (i.e., all instances of headword
bigrams also count as word bigrams) or not over-
lapping at all (i.e., a headword bigram feature is
not observed as a word bigram feature) – less
than 20% of headword bigram features displayed
a variable degree of overlap with word bigram
features. In our data, the rate of completely
overlapping features is 25% to 47% depending on
the adaptation domain. From this, we can say
that the headword bigram features show moder-
ate to high degree of correlation with the word
bigram features.
We then used BLasso and F-Boosting to train
the linear language models including both word
bigram and headword bigram features. We find
that although the CER reduction by adding
</bodyText>
<page confidence="0.97786">
230
</page>
<bodyText confidence="0.99998880952381">
headword features is overall very small, the dif-
ference between the two versions of BLasso is
more visible in all four test sets. Comparing Fig-
ures 5 – 8 with Figure 4, it can be seen that BLasso
with backward steps outperforms the one with-
out backward steps in much earlier stages of
training with a larger margin. For example, on
Encarta data sets, BLasso outperforms F-Boosting
after around 18,000 iterations with headword
features (Figure 7), as opposed to 25,000 itera-
tions without headword features (Figure 4). The
results seem to corroborate our speculation that
BLasso is more robust in the presence of highly
correlated features.
To investigate the impact of using the grid
search (fixed step size) versus the continuous
search (optimal step size) for feature selection,
we compared F-Boosting with FSLR since they
differs only in their search methods for feature
selection. As shown in Figures 5 to 8, although
FSLR is robust in that its test errors do not in-
crease after many iterations, F-Boosting can reach
a much lower error rate on three out of four test
sets. Therefore, in the task of LM for IME where
CER is the most important metric, the grid search
for feature selection is more desirable.
To investigate the impact of using a fixed ver-
sus an optimal step size for feature update, we
compared FSLR with Boosting. Although both
algorithms achieve very similar CER results, the
performance of FSLR is much less sensitive to the
selected fixed step size. For example, we can
select any value from 0.2 to 0.8, and in most set-
tings FSLR achieves the very similar lowest CER
after 20,000 iterations, and will stay there for
many iterations. In contrast, in Boosting, the
optimal value of ε in Equation (16) varies with the
sizes and domains of training data, and has to be
tuned carefully. We thus conclude that in our
task FSLR is more robust against different train-
ing settings and a fixed step size for feature up-
date is more preferred.
</bodyText>
<sectionHeader confidence="0.99943" genericHeader="conclusions">
6 Conclusion
</sectionHeader>
<bodyText confidence="0.99995445">
This paper investigates two approximation lasso
methods for LM applied to a realistic task with a
very large number of features with sparse feature
space. Our results on Japanese text input are
promising. BLasso outperforms the boosting
algorithm significantly in terms of CER reduction
on all experimental settings.
We have shown that this superior perform-
ance is a consequence of BLasso’s backward step
and its fixed step size in both feature selection
and feature weight update. Our experimental
results in Section 5 show that the use of backward
step is vital for model fine-tuning after major
features are selected and for coping with strongly
correlated features; the fixed step size of BLasso
is responsible for the improvement of CER and
the robustness of the results. Experiments on
other data sets and theoretical analysis are
needed to further support our findings in this
paper.
</bodyText>
<sectionHeader confidence="0.998898" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.99981096">
Bacchiani, M., Roark, B., and Saraclar, M. 2004. Lan-
guage model adaptation with MAP estimation and
the perceptron algorithm. In HLT-NAACL 2004. 21-24.
Collins, Michael and Terry Koo 2005. Discriminative
reranking for natural language parsing. Computational
Linguistics 31(1): 25-69.
Duda, Richard O, Hart, Peter E. and Stork, David G.
2001. Pattern classification. John Wiley &amp; Sons, Inc.
Donoho, D., I. Johnstone, G. Kerkyachairan, and D.
Picard. 1995. Wavelet shrinkage; asymptopia? (with
discussion), J. Royal. Statist. Soc. 57: 201-337.
Efron, B., T. Hastie, I. Johnstone, and R. Tibshirani.
2004. Least angle regression. Ann. Statist. 32, 407-499.
Freund, Y, R. Iyer, R. E. Schapire, and Y. Singer. 1998.
An efficient boosting algorithm for combining pref-
erences. In ICML’98.
Hastie, T., R. Tibshirani and J. Friedman. 2001. The
elements of statistical learning. Springer-Verlag, New
York.
Gao, Jianfeng, Hisami Suzuki and Yang Wen. 2002.
Exploiting headword dependency and predictive
clustering for language modeling. In EMNLP 2002.
Gao. J., Yu, H., Yuan, W., and Xu, P. 2005. Minimum
sample risk methods for language modeling. In
HLT/EMNLP 2005.
Osborne, M.R. and Presnell, B. and Turlach B.A. 2000a.
A new approach to variable selection in least squares
problems. Journal of Numerical Analysis, 20(3).
Osborne, M.R. and Presnell, B. and Turlach B.A. 2000b.
On the lasso and its dual. Journal of Computational and
Graphical Statistics, 9(2): 319-337.
Roark, Brian, Murat Saraclar and Michael Collins.
2004. Corrective language modeling for large vo-
cabulary ASR with the perceptron algorithm. In
ICASSP 2004.
Schapire, Robert E. and Yoram Singer. 1999. Improved
boosting algorithms using confidence-rated predic-
tions. Machine Learning, 37(3): 297-336.
Suzuki, Hisami and Jianfeng Gao. 2005. A comparative
study on language model adaptation using new
evaluation metrics. In HLT/EMNLP 2005.
Tibshirani, R. 1996. Regression shrinkage and selection
via the lasso. J. R. Statist. Soc. B, 58(1): 267-288.
Yuan, W., J. Gao and H. Suzuki. 2005. An Empirical
Study on Language Model Adaptation Using a Met-
ric of Domain Similarity. In IJCNLP 05.
Zhao, P. and B. Yu. 2004. Boosted lasso. Tech Report,
Statistics Department, U. C. Berkeley.
Zhu, J. S. Rosset, T. Hastie, and R. Tibshirani. 2003.
1-norm support vector machines. NIPS 16. MIT Press.
</reference>
<page confidence="0.999434">
231
</page>
<tableCaption confidence="0.999843">
Table 1. CER (%) and CER reduction (%) (Y=Yomiuri; T=TuneUp; E=Encarta; S=-Shincho)
</tableCaption>
<table confidence="0.999037384615384">
Domain Entropy vs.Nikkei Baseline MAP (over Baseline) Boosting (over MAP) BLasso (over MAP/Boosting)
Y (800) 7.69 3.70 3.70 (+0.00) 3.13 (+15.41) 3.01 (+18.65/+3.83)
Y (8K) 7.69 3.70 3.69 (+0.27) 2.88 (+21.95) 2.85 (+22.76/+1.04)
Y (72K) 7.69 3.70 3.69 (+0.27) 2.78 (+24.66) 2.73 (+26.02/+1.80)
T (800) 7.95 5.81 5.81 (+0.00) 5.69 (+2.07) 5.63 (+3.10/+1.05)
T (8K) 7.95 5.81 5.70 (+1.89) 5.48 (+5.48) 5.33 (+6.49/+2.74)
T (72K) 7.95 5.81 5.47 (+5.85) 5.33 (+2.56) 5.05 (+7.68/+5.25)
E (800) 9.30 10.24 9.60 (+6.25) 9.82 (-2.29) 9.18 (+4.38/+6.52)
E (8K) 9.30 10.24 8.64 (+15.63) 8.54 (+1.16) 8.04 (+6.94/+5.85)
E (72K) 9.30 10.24 7.98 (+22.07) 7.53 (+5.64) 7.20 (+9.77/+4.38)
S (800) 9.40 12.18 11.86 (+2.63) 11.91 (-0.42) 11.79 (+0.59/+1.01)
S (8K) 9.40 12.18 11.15 (+8.46) 11.09 (+0.54) 10.73 (+3.77/+3.25)
S (72K) 9.40 12.18 10.76 (+11.66) 10.25 (+4.74) 9.64 (+10.41/+5.95)
</table>
<figureCaption confidence="0.9994601875">
Figure 3. L1 curves: models are trained
on the E(8K) dataset.
Figure 6. Test error curves: models are
trained on the T(8K) dataset, including
headword bigram features.
Figure 4. Test error curves: models are
trained on the E(8K) dataset.
Figure 7. Test error curves: models are
trained on the E(8K) dataset, including
headword bigram features.
Figure 5. Test error curves: models are
trained on the Y(8K) dataset, including
headword bigram features.
Figure 8. Test error curves: models are
trained on the S(8K) dataset, including
headword bigram features.
</figureCaption>
<page confidence="0.981633">
232
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.002423">
<title confidence="0.999479">Approximation Lasso Methods for Language Modeling</title>
<author confidence="0.970218">Jianfeng Gao</author>
<affiliation confidence="0.999655">Microsoft Research</affiliation>
<address confidence="0.991057">One Microsoft Way Redmond WA 98052 USA</address>
<email confidence="0.999798">jfgao@microsoft.com</email>
<author confidence="0.998081">Hisami Suzuki</author>
<affiliation confidence="0.999944">Microsoft Research</affiliation>
<address confidence="0.9899385">One Microsoft Way Redmond WA 98052 USA</address>
<email confidence="0.999397">hisamis@microsoft.com</email>
<author confidence="0.998847">Bin Yu</author>
<affiliation confidence="0.9999315">Department of Statistics University of California</affiliation>
<address confidence="0.997092">Berkeley., CA 94720 U.S.A.</address>
<email confidence="0.999814">binyu@stat.berkeley.edu</email>
<abstract confidence="0.997766195774649">Lasso is a regularization method for parameter estimation in linear models. It optimizes the model parameters with respect to a loss function subject to model complexities. This paper explores the use of lasso for statistical language modeling for text input. Owing to the very large number of parameters, directly optimizing the penalized lasso loss function is impossible. Therefore, we investigate two approximation methods, the boosted lasso (BLasso) and the forward stagewise linear regression (FSLR). Both methods, when used with the exponential loss function, bear strong resemblance to the boosting algorithm which has been used as a discriminative training method for language modeling. Evaluations on the task of Japanese text input show that BLasso is able to produce the best approximation to the lasso solution, and leads to a significant improvement, in terms of character error rate, over boosting and the traditional maximum likelihood estimation. Language modeling (LM) is fundamental to a wide range of applications. Recently, it has been shown that a linear model estimated using discriminative training methods, such as the boosting and perceptron algorithms, outperforms significantly a traditional word trigram model trained using maximum likelihood estimation (MLE) on several tasks such as speech recognition and Asian language text input (Bacchiani et al. 2004; Roark et al. 2004; Gao et al. 2005; Suzuki and Gao 2005). The success of discriminative training methods is largely due to fact that unlike the traditional approach (e.g., MLE) that maximizes the function (e.g., likelihood of training data) that is loosely associated with error rate, discriminative training methods aim to directly minimize the error rate on training data even if they reduce the likelihood. However, given a finite set of training samples, discriminative training methods could lead to an arbitrary complex model for the purpose of achieving zero training error. It is well-known that complex models exhibit high variance and perform poorly on unseen data. Therefore some regularization methods have to be used to control the complexity of the model. Lasso is a regularization method for parameter estimation in linear models. It optimizes the model parameters with respect to a loss function subject to model complexities. The basic idea of lasso is originally proposed by Tibshirani (1996). Recently, there have been several implementations and experiments of lasso on multi-class classification tasks where only a small number of features need to be handled and the lasso solution can be directly computed via numerical methods. To our knowledge, this paper presents the first empirical study of lasso for a realistic, large scale task: LM for Asian language text input. Because the task utilizes millions of features and training samples, directly optimizing the penalized lasso loss function is impossible. Therefore, two approximation methods, the boosted lasso (BLasso, Zhao and Yu 2004) and the forward stagewise linear regression (FSLR, Hastie et al. 2001), are investigated. Both methods, when used with the exponential loss function, bear strong resemblance to the boosting algorithm which has been used as a discriminative training method for LM. Evaluations on the task of Japanese text input show that BLasso is able to produce the best approximation to the lasso solution, and leads to a significant improvement, in terms of character error rate, over the boosting algorithm and the traditional MLE. Task and Problem Definition This paper studies LM on the application of Asian language (e.g. Chinese or Japanese) text input, a standard method of inputting Chinese or Japanese text by converting the input phonetic symbols into the appropriate word string. In this paper we call the task IME, which stands for 225 of the 21st International Conference on Computational Linguistics and 44th Annual Meeting of the pages 225–232, July 2006. Association for Computational Linguistics method based on the name of the commonly used Windows-based application. Performance on IME is measured in terms of the character error rate (CER), which is the number of characters wrongly converted from the phonetic string divided by the number of characters in the correct transcript. Similar to speech recognition, IME is viewed a Bayes decision problem. Let the input phonetic string. An IME system’s task is to the most likely word string among candidates that could be converted from denotes the candidate set given Unlike speech recognition, however, there is no acoustic ambiguity as the phonetic string is inputted by users. Moreover, we can assume a mapping from IME as words unique readings, i.e. = 1. So the decision of Equation (1) depends solely upon making IME an ideal evaluation test bed for LM. In this study, the LM task for IME is formulated under the framework of linear models (e.g., Duda et al. 2001). We use the following notation, adapted from Collins and Koo (2005): • Training data is a set of example input/output pairs. In LM for IME, training samare represented as for each an input phonetic string and the reference transcript of • We assume some way of generating a set of word strings given denoted by In our experiments, consists of strings converted from a baseline IME system that uses only a word trigram model. We assume a set of features for The features could be arbitrary functions map real values. Using vector notation, have where = is called the base feature, and is defined in our case as the log probability that the trigram model assigns to Other features for are defined as the counts of 1 and 2 in our experiments) in • Finally, the parameters of the model form a of dimensions, each for one feature The score of a word be written as D = The decision rule of Equation (1) is rewritten as Set and 0 for Select a feature which has largest estimated impact on reducing ExpLoss of Eq. (6) Update Å and return to Step 2 The boosting algorithm W) arg max ( , ) W Equation (3) views IME as a ranking problem, where the model gives the ranking score, not probabilities. We therefore do not evaluate the model via perplexity. Now, assume that we can measure the numof conversion errors in comparing it a reference transcript an error which is the string edit distance function in our case. We call the sum of counts over the training samples Our goal then is to search for the best parameter minimizes the sample risk, as in Equation (4): However, (4) cannot be optimized easily since is a piecewise constant (or step) function of and its gradient is undefined. Therefore, discriminative methods apply different approaches that optimize it approximately. The boosting algorithm described below is one of such approaches. This section gives a brief review of the boosting algorithm, following the description of some recent work (e.g., Schapire and Singer 1999; Collins and Koo 2005). The boosting algorithm uses an exponential loss function (ExpLoss) to approximate the sample risk in Equation (4). We define the margin of pair with respect to the model W RW W Rλ W , ) ( , ) ( , ) (5) Then, ExpLoss is defined as ExpLoss( ) ( , )) R W W i i i MW .. ) A i i Notice that ExpLoss is convex so there is no problem with local minima when optimizing it. It is shown in Freund et al. (1998) and Collins and Koo (2005) that there exist gradient search procedures that converge to the right solution. Figure 1 summarizes the boosting algorithm we used. After initialization, Steps 2 and 3 are = i λ M 1... . (4) λ def ∑ min , λ )) (2) . (3) 226 at each iteration, a feature is chosen and its weight is updated as follows. we define as an updated with the same parameter values as exception of which is incremented by Then, Steps 2 and 3 in Figure 1 can be rewritten as Equations (7) and (8), respectively. ( argminExpLoss(Upd( , , )) tUpd( The boosting algorithm can be too greedy: Each iteration usually reduces the ExpLoss(.) on training data, so for the number of iterations large enough this loss can be made arbitrarily small. However, fitting training data too well eventually leads to overfiting, which degrades the performance on unseen test data (even though in boosting overfitting can happen very slowly). Shrinkage is a simple approach to dealing with the overfitting problem. It scales the increstep a small constant 1). Thus, the update of Equation (8) with shrinkage is tUpd( (9) Empirically, it has been found that smaller values to smaller numbers of test errors. Lasso is a regularization method for estimation in linear models (Tibshirani 1996). It regularizes or a fitted model through an or constraint. denote the of the model, = We then optimize the as to minimize a regularized loss on training data, called loss as LassoLoss( , ) ExpLoss( ) ( ) (10) generally penalizes larger models (or models), and the parameter the amount of regularization applied to the esti- Setting 0 reverses the LassoLoss to the ExpLoss; as the model coefficients all shrink, each ultimately becoming In practice, be adaptively chosen minimize an estimate of expected loss, e.g., decreases with the increase of the number of iterations. Computation of the solution to the lasso problem has been studied for special loss functions. For least square regression, there is a fast algorithm LARS to find the whole lasso path for difs (Obsborn et al. 2000a; 2000b; Efron et al. 2004); for 1-norm SVM, it can be transformed into a linear programming problem with a fast algorithm similar to LARS (Zhu et al. 2003). However, the solution to the lasso problem for a convex loss function and an adaptive remains open. More importantly for our purposes, directly minimizing lasso function of (10) with respect to not possible when a very large number of model parameters are employed, as in our task of LM for IME. Therefore we investigate below two methods that closely approximate the effect of the lasso, and are very similar to the boosting algorithm. It is also worth noting the difference between The classical Ridge Regression uses an in Equation (10) i.e., = which is much easier to minimize (for least square loss but not for ExpLoss). However, recent research (Donoho et al. shows that the is better suited for sparse situations, where there are only a small number of features with nonzero weights among all candidate features. We find that our task is indeed a sparse situation: among 860,000 features, in the resulting linear model only around 5,000 features have nonzero weights. We then focus on We leave the empirical compariof the on the LM task to future work. Stagewise Linear Regression (FSLR) The first approximation method we used is FSLR, described in (Algorithm 10.4, Hastie et al. 2001), where Steps 2 and 3 in Figure 1 are performed according to Equations (7) and (11), respectively. ( argminExpLoss(Upd( , , )) , Notice that FSLR is very similar to the boosting algorithm with shrinkage in that at each step, the has largest estimated impact on reducing ExpLoss is selected. The only difference that FSLR updates the weight of a small step size By taking such small steps, FSLR imposes some implicit regularization, and can closely approximate the effect of the lasso in a local sense (Hastie et al. 2001). Empirically, we find that the performance of the boosting algorithm with shrinkage closely resembles that of with the learning rate parameter correto 227 Lasso (BLasso) The second method we used is a modified version of the BLasso algorithm described in Zhao and Yu (2004). There are two major differences between BLasso and FSLR. At each iteration, can take either a step a Similar to the boosting algorithm and FSLR, at each forward step, a feature is selected and its weight is updated according to Equations (12) and (13). ( *) argminExpLoss(Upd( , , ε =± However, there is an important difference between Equations (12) and (7). In the boosting algorithm with shrinkage and FSLR, as shown in Equation (7), a feature is selected by its impact on the loss with its optimal update In contract, in BLasso, as shown in Equation (12), optimization over removed, and for each feature, its loss is calculated with an update of i.e., the grid search is used for feature selection. We will show later that this seemingly trivial difference brings a significant improvement. The backward step is unique to BLasso. In each iteration, a feature is selected and its weight is updated backward if and only if it leads to a decrease of the lasso loss, as shown in Equations (14) and (15): (14) a tolerance parameter. Figure 2 summarizes the BLasso algorithm we used. After initialization, Steps 4 and 5 are reat each iteration, a feature is chosen and its weight is updated either backward forward by a fixed amount Notice that the of adaptively chosen according to the reduction of ExpLoss during training. The algostarts with a large initial and then at each step the value of until the ExpLoss stops decreasing. This is intuitively desirable: It is expected that most highly effective features are selected in early stages of training, so the reduction of ExpLoss at each step in early stages are more substantial than in later stages. These early steps coincide with the boosting steps most of the time. In other words, the effect of backward steps is more visible at later stages. Our implementation of BLasso differs slightly from the original algorithm described in Zhao and Yu (2004). Firstly, because the value of the feature the log probability (assigned by a word trigram model) and has a different range that of other features as in Equation (2), set to optimize ExpLoss in the initialization step (Step 1 in Figure 2) and remains fixed during training. As suggested by Collins and Koo (2005), this ensures that the contribution of the feature well-calibrated with respect to ExpLoss. Secondly, when updating a feature weight, if the size of the optimal update step (computed via Equation (7)) is smaller than we use the optimal step to update the feature. Therefore, in our implementation BLasso does not always take a fixed step; it may take steps size is smaller than In our initial experiments we found that both changes (also used in our implementations of boosting and FSLR) crucialto performance of the methods. Initialize set and 0 2 Take a forward step according to Eq. (12) and (13), the updated model is denoted by Initialize 4 Take a backward step if and only if it leads to a decrease of LassoLoss according to Eq. (14) and where 0; otherwise 5 Take a forward step according to Eq. (12) and (13); and return to Step 4. The BLasso algorithm (Zhao and Yu 2004) provides theoretical justifications for BLasso. It has been proved that (1) it guarantees that it is safe for BLasso to start with initial is the largest would an away from 0 (i.e., larger corto (2) for each value of BLasso performs coordinate descent (i.e., reduces ExpLoss by updating the weight of a feature) until there is no descent step; and (3) for each step the value of it guarantees that the lasso loss is reduced. As a result, it can be that for a finite number of features and = 0, the BLasso algorithm shown in Figure 2 to the lasso solution when We evaluated the training methods described above in the so-called cross-domain language model adaptation paradigm, where we adapt a model trained on one domain (which we call the minExpLoss(Upd( k arg t λ 228 to a different domain for which only a small amount of training data is available. The data sets we used in our experiments came from five distinct sources of text. A 36-million-word Nikkei Newspaper corpus was used as the background domain, on which the word trigram model was trained. We used four adaptation domains: Yomiuri (newspaper corpus), TuneUp (balanced corpus containing newspapers and other sources of text), Encarta (encyclopedia) and Shincho (collection of novels). All corpora have been pre-word-segmented using a lexicon containing 167,107 entries. For each of the four domains, we created training data consisting of 72K sentences (0.9M~1.7M words) and test data of 5K sentences (65K~120K words) from each adaptation domain. The first 800 and 8,000 sentences of each adaptation training data were also used to show how different sizes of training data affected the performances of various adaptation methods. Another 5K-sentence subset was used as held-out data for each domain. We created the training samples for discriminative learning as follows. For each phonetic adaptation training data, we proa lattice of candidate word strings the baseline system described in (Gao et al. 2002), which uses a word trigram model trained via MLE on the Nikkei Newspaper corpus. For efficiency, we kept only the best 20 hypotheses in its conversion set for each training sample for discriminative training. The oracle best hypothesis, which gives the minimum number of errors, was used as the reference tranof We used unigrams and bigrams that occurred more than once in the training set as features in the linear model of Equation (2). The total number of candidate features we used was around 860,000. Results Table 1 summarizes the results of various model training (adaptation) methods in terms of CER (%) and CER reduction (in parentheses) over comparing models. In the first column, the numbers in parentheses next to the domain name indicates the number of training sentences used for adaptation. with results shown in Column 3, is the word trigram model. As expected, the CER correlates very well the similarity between the background domain and the adaptation domain, where domain similarity is measured in terms of cross entropy (Yuan et al. 2005) as shown in Column 2. with results shown in Column 4, is a traditional LM adaptation method where the parameters of the background model are adjusted in such a way that maximizes the likelihood of the adaptation data. Our implementation takes the form of linear interpolation as described in Bacchiani et al. = + where the probability of the background model, is the probability trained on adaptation data MLE and the history to two words (i.e. are trigram the interpolation weight optimized on held-out data. with results shown in Column 5, is the algorithm described in Figure 1. In our implementation, we use the shrinkage method suggested by Schapire and Singer (1999) and Collins and Koo (2005). At each iteration, we the following update for the feature + Z ε(16) k is a value increasing exponentially the sum of margins of pairs over the where seen in not in is the value related to the sum of margins over the set seen in not in a smoothing factor (whose value is optimized on data) and a normalization constant (whose value is the ExpLoss(.) of training data to the current model). We see that (16) plays the same role as Equation (9). with results shown in Column 6, is the algorithm described in Figure 2. We find that the performance of BLasso is not very sensitive to selection of the step size training sets different domains and sizes. Although small is preferred in theory as discussed earlier, it would lead to a very slow convergence. Therefore, in our experiments, we always use a large 0.5) and use the so-called early stopping strategy, i.e., the number of iterations before stopping is optimized on held-out data. In the task of LM for IME, there are millions of features and training samples, forming an extremely large and sparse matrix. We therefore applied the techniques described in Collins and Koo (2005) to speed up the training procedure. The resulting algorithms run in around 15 and 30 minutes respectively for Boosting and BLasso to converge on an XEONTM MP 1.90GHz machine when training on an 8K-sentnece training set. C Z 2 229 The results in Table 1 give rise to several observations. First of all, both discriminative training methods (i.e., Boosting and BLasso) outperform MAP substantially. The improvement margins are larger when the background and adaptation domains are more similar. The phenomenon is attributed to the underlying difference between the two adaptation methods: MAP aims to improve the likelihood of a distribution, so if the adaptation domain is very similar to the background domain, the difference between the two underlying distributions is so small that MAP cannot adjust the model effectively. Discriminative methods, on the other hand, do not have this limitation for they aim to reduce errors directly. Secondly, BLasso outperforms Boosting &lt; 0.01) on all test sets. The improvement margins vary with the training sets of different domains and sizes. In general, in cases where the adaptation domain is less similar to the background domain and larger training set is used, the improvement of BLasso is more visible. Note that the CER results of FSLR are not included in Table 1 because it achieves very similar results to the boosting algorithm with shrinkage if the controlling parameters of both algorithms are optimized via cross-validation. We shall discuss their difference in the next section. This section investigates what components of BLasso bring the improvement over Boosting. Comparing the algorithms in Figures 1 and 2, we notice three differences between BLasso and Boosting: (i) the use of backward steps in BLasso; (ii) BLasso uses the grid search (fixed step size) for feature selection in Equation (12) while Boosting uses the continuous search (optimal step size) in Equation (7); and (iii) BLasso uses a fixed step size for feature update in Equation (13) while Boosting uses an optimal step size in Equation (8). We then investigate these differences in turn. To study the impact of backward steps, we compared BLasso with the boosting algorithm with a fixed step search and a fixed step update, referred to as F-Boosting was implemented as Figure 2, by setting a large to Equation (15), i.e., to prohibit backward steps. We find that although the training error curves of BLasso and F-Boosting almost identical, the curves grow apart with iterations, as shown in Figure 3. The results show that with backward steps, BLasso achieves a better approximation to the true lasso solution: It leads to a model with similar training errors less complex (in terms of In our experiments we find that the benefit of using backward steps is only visible in later iterations when BLasso’s backward steps kick in. A typical example is shown in Figure 4. The early steps fit to highly effective features and in these steps BLasso and F-Boosting agree. For later steps, fine-tuning of features is required. BLasso with backward steps provides a better mechanism than F-Boosting to revise the previously chosen features to accommodate this fine level of tuning. Consequently we observe the superior performance of BLasso at later stages as shown in our experiments. As well-known in linear regression models, when there are many strongly correlated features, model parameters can be poorly estimated and exhibit high variance. By imposing a model size constraint, as in lasso, this phenomenon is alleviated. Therefore, we speculate that a better approximation to lasso, as BLasso with backward steps, would be superior in eliminating the negative effect of strongly correlated features in model estimation. To verify our speculation, we performed the following experiments. For each training set, in addition to word unigram and bigram features, we introduced a new type of called As described in Gao et al. (2002), headwords are defined as the content words of the sentence. Therefore, headword bigrams constitute a special type of skipping bigrams which can capture dependency between two words that may not be adjacent. In reality, a large portion of headword bigrams are identical to word bigrams, as two headwords can occur next to each other in text. In the adaptation test data we used, we find that headword bigram features are for the most part overlapping the word bigram features (i.e., all instances of headword also count as word bigrams) or overat all a headword bigram feature is not observed as a word bigram feature) – less than 20% of headword bigram features displayed a variable degree of overlap with word bigram features. In our data, the rate of completely overlapping features is 25% to 47% depending on the adaptation domain. From this, we can say that the headword bigram features show moderate to high degree of correlation with the word bigram features. We then used BLasso and F-Boosting to train the linear language models including both word bigram and headword bigram features. We find that although the CER reduction by adding 230 headword features is overall very small, the difference between the two versions of BLasso is more visible in all four test sets. Comparing Figures 5 – 8 with Figure 4, it can be seen that BLasso with backward steps outperforms the one without backward steps in much earlier stages of training with a larger margin. For example, on Encarta data sets, BLasso outperforms F-Boosting after around 18,000 iterations with headword features (Figure 7), as opposed to 25,000 iterations without headword features (Figure 4). The results seem to corroborate our speculation that BLasso is more robust in the presence of highly correlated features. To investigate the impact of using the grid search (fixed step size) versus the continuous search (optimal step size) for feature selection, we compared F-Boosting with FSLR since they differs only in their search methods for feature selection. As shown in Figures 5 to 8, although FSLR is robust in that its test errors do not increase after many iterations, F-Boosting can reach a much lower error rate on three out of four test sets. Therefore, in the task of LM for IME where CER is the most important metric, the grid search for feature selection is more desirable. To investigate the impact of using a fixed versus an optimal step size for feature update, we compared FSLR with Boosting. Although both algorithms achieve very similar CER results, the performance of FSLR is much less sensitive to the selected fixed step size. For example, we can select any value from 0.2 to 0.8, and in most settings FSLR achieves the very similar lowest CER after 20,000 iterations, and will stay there for many iterations. In contrast, in Boosting, the value of Equation (16) varies with the sizes and domains of training data, and has to be tuned carefully. We thus conclude that in our task FSLR is more robust against different training settings and a fixed step size for feature update is more preferred. This paper investigates two approximation lasso methods for LM applied to a realistic task with a very large number of features with sparse feature space. Our results on Japanese text input are promising. BLasso outperforms the boosting algorithm significantly in terms of CER reduction on all experimental settings. We have shown that this superior performance is a consequence of BLasso’s backward step and its fixed step size in both feature selection and feature weight update. Our experimental results in Section 5 show that the use of backward step is vital for model fine-tuning after major features are selected and for coping with strongly correlated features; the fixed step size of BLasso is responsible for the improvement of CER and the robustness of the results. Experiments on other data sets and theoretical analysis are needed to further support our findings in this paper.</abstract>
<note confidence="0.74061575">References Bacchiani, M., Roark, B., and Saraclar, M. 2004. Language model adaptation with MAP estimation and perceptron algorithm. In 21-24. Collins, Michael and Terry Koo 2005. Discriminative for natural language parsing. 25-69. Duda, Richard O, Hart, Peter E. and Stork, David G. classification. Wiley &amp; Sons, Inc. Donoho, D., I. Johnstone, G. Kerkyachairan, and D. Picard. 1995. Wavelet shrinkage; asymptopia? (with Royal. Statist. Soc. 201-337. Efron, B., T. Hastie, I. Johnstone, and R. Tibshirani. Least angle regression. Statist. 407-499. Freund, Y, R. Iyer, R. E. Schapire, and Y. Singer. 1998. An efficient boosting algorithm for combining pref- In T., R. Tibshirani and J. Friedman. 2001. of statistical learning. New York. Gao, Jianfeng, Hisami Suzuki and Yang Wen. 2002. Exploiting headword dependency and predictive for language modeling. In Gao. J., Yu, H., Yuan, W., and Xu, P. 2005. Minimum sample risk methods for language modeling. In Osborne, M.R. and Presnell, B. and Turlach B.A. 2000a. A new approach to variable selection in least squares of Numerical 20(3). Osborne, M.R. and Presnell, B. and Turlach B.A. 2000b. the lasso and its dual. of Computational and 9(2): 319-337. Roark, Brian, Murat Saraclar and Michael Collins. 2004. Corrective language modeling for large vocabulary ASR with the perceptron algorithm. In Schapire, Robert E. and Yoram Singer. 1999. Improved boosting algorithms using confidence-rated predic- 37(3): 297-336. Suzuki, Hisami and Jianfeng Gao. 2005. A comparative study on language model adaptation using new metrics. In Tibshirani, R. 1996. Regression shrinkage and selection the lasso. R. Statist. Soc. 58(1): 267-288. Yuan, W., J. Gao and H. Suzuki. 2005. An Empirical Study on Language Model Adaptation Using a Metof Domain Similarity. In P. and B. Yu. 2004. Boosted lasso. Statistics Department, U. C. Berkeley. Zhu, J. S. Rosset, T. Hastie, and R. Tibshirani. 2003. support vector machines. MIT Press. 231 1. (%) and CER reduction (%) (Y=Yomiuri; T=TuneUp; E=Encarta; S=-Shincho) Domain Entropy vs.Nikkei Baseline MAP (over Baseline) Boosting (over MAP) BLasso (over MAP/Boosting) Y (800) 7.69 3.70 3.70 (+0.00) 3.13 (+15.41) 3.01 (+18.65/+3.83) Y (8K) 7.69 3.70 3.69 (+0.27) 2.88 (+21.95) 2.85 (+22.76/+1.04) Y (72K) 7.69 3.70 3.69 (+0.27) 2.78 (+24.66) 2.73 (+26.02/+1.80) T (800) 7.95 5.81 5.81 (+0.00) 5.69 (+2.07) 5.63 (+3.10/+1.05) T (8K) 7.95 5.81 5.70 (+1.89) 5.48 (+5.48) 5.33 (+6.49/+2.74) T (72K) 7.95 5.81 5.47 (+5.85) 5.33 (+2.56) 5.05 (+7.68/+5.25) E (800) 9.30 10.24 9.60 (+6.25) 9.82 (-2.29) 9.18 (+4.38/+6.52) E (8K) 9.30 10.24 8.64 (+15.63) 8.54 (+1.16) 8.04 (+6.94/+5.85) E (72K) 9.30 10.24 7.98 (+22.07) 7.53 (+5.64) 7.20 (+9.77/+4.38) S (800) 9.40 12.18 11.86 (+2.63) 11.91 (-0.42) 11.79 (+0.59/+1.01) S (8K) 9.40 12.18 11.15 (+8.46) 11.09 (+0.54) 10.73 (+3.77/+3.25) S (72K) 9.40 12.18 10.76 (+11.66) 10.25 (+4.74) 9.64 (+10.41/+5.95)</note>
<abstract confidence="0.9972554375">3. models are trained on the E(8K) dataset. 6. error curves: models are trained on the T(8K) dataset, including headword bigram features. 4. error curves: models are trained on the E(8K) dataset. 7. error curves: models are trained on the E(8K) dataset, including headword bigram features. 5. error curves: models are trained on the Y(8K) dataset, including headword bigram features. 8. error curves: models are trained on the S(8K) dataset, including headword bigram features.</abstract>
<intro confidence="0.803596">232</intro>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>M Bacchiani</author>
<author>B Roark</author>
<author>M Saraclar</author>
</authors>
<title>Language model adaptation with MAP estimation and the perceptron algorithm.</title>
<date>2004</date>
<booktitle>In HLT-NAACL</booktitle>
<pages>21--24</pages>
<contexts>
<context position="1752" citStr="Bacchiani et al. 2004" startWordPosition="259" endWordPosition="262">the best approximation to the lasso solution, and leads to a significant improvement, in terms of character error rate, over boosting and the traditional maximum likelihood estimation. 1 Introduction Language modeling (LM) is fundamental to a wide range of applications. Recently, it has been shown that a linear model estimated using discriminative training methods, such as the boosting and perceptron algorithms, outperforms significantly a traditional word trigram model trained using maximum likelihood estimation (MLE) on several tasks such as speech recognition and Asian language text input (Bacchiani et al. 2004; Roark et al. 2004; Gao et al. 2005; Suzuki and Gao 2005). The success of discriminative training methods is largely due to fact that unlike the traditional approach (e.g., MLE) that maximizes the function (e.g., likelihood of training data) that is loosely associated with error rate, discriminative training methods aim to directly minimize the error rate on training data even if they reduce the likelihood. However, given a finite set of training samples, discriminative training methods could lead to an arbitrary complex model for the purpose of achieving zero training error. It is well-known</context>
<context position="20684" citStr="Bacchiani et al. (2004)" startWordPosition="3605" endWordPosition="3608">for adaptation. Baseline, with results shown in Column 3, is the word trigram model. As expected, the CER correlates very well the similarity between the background domain and the adaptation domain, where domain similarity is measured in terms of cross entropy (Yuan et al. 2005) as shown in Column 2. MAP (maximum a posteriori), with results shown in Column 4, is a traditional LM adaptation method where the parameters of the background model are adjusted in such a way that maximizes the likelihood of the adaptation data. Our implementation takes the form of linear interpolation as described in Bacchiani et al. (2004): P(wi|h) = λPb(wi|h) + (1-λ)Pa(wi|h), where Pb is the probability of the background model, Pa is the probability trained on adaptation data using MLE and the history h corresponds to two preceding words (i.e. Pb and Pa are trigram probabilities). λ is the interpolation weight optimized on held-out data. Boosting, with results shown in Column 5, is the algorithm described in Figure 1. In our implementation, we use the shrinkage method suggested by Schapire and Singer (1999) and Collins and Koo (2005). At each iteration, we used the following update for the kth feature + 1 C Z + ε (16) k = log </context>
</contexts>
<marker>Bacchiani, Roark, Saraclar, 2004</marker>
<rawString>Bacchiani, M., Roark, B., and Saraclar, M. 2004. Language model adaptation with MAP estimation and the perceptron algorithm. In HLT-NAACL 2004. 21-24.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Michael Collins</author>
<author>Terry Koo</author>
</authors>
<title>Discriminative reranking for natural language parsing.</title>
<date>2005</date>
<journal>Computational Linguistics</journal>
<volume>31</volume>
<issue>1</issue>
<pages>25--69</pages>
<contexts>
<context position="5546" citStr="Collins and Koo (2005)" startWordPosition="879" endWordPosition="882">ted from A: W(1) = argmaxP(W |A) = argmaxP(W)P(A | W∈GEN(A) W∈GEN(A) where GEN(A) denotes the candidate set given A. Unlike speech recognition, however, there is no acoustic ambiguity as the phonetic string is inputted by users. Moreover, we can assume a unique mapping from W and A in IME as words have unique readings, i.e. P(A|W) = 1. So the decision of Equation (1) depends solely upon P(W), making IME an ideal evaluation test bed for LM. In this study, the LM task for IME is formulated under the framework of linear models (e.g., Duda et al. 2001). We use the following notation, adapted from Collins and Koo (2005): • Training data is a set of example input/output pairs. In LM for IME, training samples are represented as {Ai, WiR}, for i = 1...M, where each Ai is an input phonetic string and WiR is the reference transcript of Ai. • We assume some way of generating a set of candidate word strings given A, denoted by GEN(A). In our experiments, GEN(A) consists of top n word strings converted from A using a baseline IME system that uses only a word trigram model. • We assume a set of D+1 features fd(W), for d = 0...D. The features could be arbitrary functions that map W to real values. Using vector notatio</context>
<context position="7983" citStr="Collins and Koo 2005" startWordPosition="1334" endWordPosition="1337">ror counts over the training samples sample risk. Our goal then is to search for the best parameter set λ which minimizes the sample risk, as in Equation (4): However, (4) cannot be optimized easily since Er(.) is a piecewise constant (or step) function of λ and its gradient is undefined. Therefore, discriminative methods apply different approaches that optimize it approximately. The boosting algorithm described below is one of such approaches. 3 Boosting This section gives a brief review of the boosting algorithm, following the description of some recent work (e.g., Schapire and Singer 1999; Collins and Koo 2005). The boosting algorithm uses an exponential loss function (ExpLoss) to approximate the sample risk in Equation (4). We define the margin of the pair (WR, W) with respect to the model λ as M W R W = Score W R λ − Score W λ ( , ) ( , ) ( , ) (5) Then, ExpLoss is defined as ExpLoss( ) λ = ∑ ∑exp( ( , )) R −M W W (6) i i i MW =1. .. ∈ GEN ( ) A i i Notice that ExpLoss is convex so there is no problem with local minima when optimizing it. It is shown in Freund et al. (1998) and Collins and Koo (2005) that there exist gradient search procedures that converge to the right solution. Figure 1 summariz</context>
<context position="15976" citStr="Collins and Koo (2005)" startWordPosition="2800" endWordPosition="2803"> substantial than in later stages. These early steps coincide with the boosting steps most of the time. In other words, the effect of backward steps is more visible at later stages. Our implementation of BLasso differs slightly from the original algorithm described in Zhao and Yu (2004). Firstly, because the value of the base feature f0 is the log probability (assigned by a word trigram model) and has a different range from that of other features as in Equation (2), λ0 is set to optimize ExpLoss in the initialization step (Step 1 in Figure 2) and remains fixed during training. As suggested by Collins and Koo (2005), this ensures that the contribution of the log-likelihood feature f0 is well-calibrated with respect to ExpLoss. Secondly, when updating a feature weight, if the size of the optimal update step (computed via Equation (7)) is smaller than ε, we use the optimal step to update the feature. Therefore, in our implementation BLasso does not always take a fixed step; it may take steps whose size is smaller than ε. In our initial experiments we found that both changes (also used in our implementations of boosting and FSLR) were crucial to the performance of the methods. 1 Initialize λ0: set λ0 = argm</context>
<context position="21189" citStr="Collins and Koo (2005)" startWordPosition="3689" endWordPosition="3692">he adaptation data. Our implementation takes the form of linear interpolation as described in Bacchiani et al. (2004): P(wi|h) = λPb(wi|h) + (1-λ)Pa(wi|h), where Pb is the probability of the background model, Pa is the probability trained on adaptation data using MLE and the history h corresponds to two preceding words (i.e. Pb and Pa are trigram probabilities). λ is the interpolation weight optimized on held-out data. Boosting, with results shown in Column 5, is the algorithm described in Figure 1. In our implementation, we use the shrinkage method suggested by Schapire and Singer (1999) and Collins and Koo (2005). At each iteration, we used the following update for the kth feature + 1 C Z + ε (16) k = log k where Ck+ is a value increasing exponentially with the sum of margins of (WR, W) pairs over the set where fk is seen in WR but not in W; Ck- is the value related to the sum of margins over the set where fk is seen in W but not in WR. ε is a smoothing factor (whose value is optimized on held-out data) and Z is a normalization constant (whose value is the ExpLoss(.) of training data according to the current model). We see that εZ in Equation (16) plays the same role as ν in Equation (9). BLasso, with</context>
<context position="22501" citStr="Collins and Koo (2005)" startWordPosition="3937" endWordPosition="3940">rmance of BLasso is not very sensitive to the selection of the step size ε across training sets of different domains and sizes. Although small ε is preferred in theory as discussed earlier, it would lead to a very slow convergence. Therefore, in our experiments, we always use a large step (ε = 0.5) and use the so-called early stopping strategy, i.e., the number of iterations before stopping is optimized on held-out data. In the task of LM for IME, there are millions of features and training samples, forming an extremely large and sparse matrix. We therefore applied the techniques described in Collins and Koo (2005) to speed up the training procedure. The resulting algorithms run in around 15 and 30 minutes respectively for Boosting and BLasso to converge on an XEONTM MP 1.90GHz machine when training on an 8K-sentnece training set. δk C Z 2 _ + ε 229 The results in Table 1 give rise to several observations. First of all, both discriminative training methods (i.e., Boosting and BLasso) outperform MAP substantially. The improvement margins are larger when the background and adaptation domains are more similar. The phenomenon is attributed to the underlying difference between the two adaptation methods: MAP</context>
</contexts>
<marker>Collins, Koo, 2005</marker>
<rawString>Collins, Michael and Terry Koo 2005. Discriminative reranking for natural language parsing. Computational Linguistics 31(1): 25-69.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Richard O Duda</author>
<author>Peter E Hart</author>
<author>David G Stork</author>
</authors>
<title>Pattern classification.</title>
<date>2001</date>
<publisher>John Wiley &amp; Sons, Inc.</publisher>
<contexts>
<context position="5478" citStr="Duda et al. 2001" startWordPosition="868" endWordPosition="871">kely word string W* among those candidates that could be converted from A: W(1) = argmaxP(W |A) = argmaxP(W)P(A | W∈GEN(A) W∈GEN(A) where GEN(A) denotes the candidate set given A. Unlike speech recognition, however, there is no acoustic ambiguity as the phonetic string is inputted by users. Moreover, we can assume a unique mapping from W and A in IME as words have unique readings, i.e. P(A|W) = 1. So the decision of Equation (1) depends solely upon P(W), making IME an ideal evaluation test bed for LM. In this study, the LM task for IME is formulated under the framework of linear models (e.g., Duda et al. 2001). We use the following notation, adapted from Collins and Koo (2005): • Training data is a set of example input/output pairs. In LM for IME, training samples are represented as {Ai, WiR}, for i = 1...M, where each Ai is an input phonetic string and WiR is the reference transcript of Ai. • We assume some way of generating a set of candidate word strings given A, denoted by GEN(A). In our experiments, GEN(A) consists of top n word strings converted from A using a baseline IME system that uses only a word trigram model. • We assume a set of D+1 features fd(W), for d = 0...D. The features could be</context>
</contexts>
<marker>Duda, Hart, Stork, 2001</marker>
<rawString>Duda, Richard O, Hart, Peter E. and Stork, David G. 2001. Pattern classification. John Wiley &amp; Sons, Inc.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D Donoho</author>
<author>I Johnstone</author>
<author>G Kerkyachairan</author>
<author>D Picard</author>
</authors>
<title>Wavelet shrinkage; asymptopia? (with discussion),</title>
<date>1995</date>
<journal>J. Royal. Statist. Soc.</journal>
<volume>57</volume>
<pages>201--337</pages>
<contexts>
<context position="11892" citStr="Donoho et al. 1995" startWordPosition="2069" endWordPosition="2072">urposes, directly minimizing lasso function of Equation (10) with respect to λ is not possible when a very large number of model parameters are employed, as in our task of LM for IME. Therefore we investigate below two methods that closely approximate the effect of the lasso, and are very similar to the boosting algorithm. It is also worth noting the difference between L1 and L2 penalty. The classical Ridge Regression setting uses an L2 penalty in Equation (10) i.e., T(λ) = ∑d = 0...D(λd)2, which is much easier to minimize (for least square loss but not for ExpLoss). However, recent research (Donoho et al. 1995) shows that the L1 penalty is better suited for sparse situations, where there are only a small number of features with nonzero weights among all candidate features. We find that our task is indeed a sparse situation: among 860,000 features, in the resulting linear model only around 5,000 features have nonzero weights. We then focus on the L1 penalty. We leave the empirical comparison of the L1 and L2 penalty on the LM task to future work. 4.1 Forward Stagewise Linear Regression (FSLR) The first approximation method we used is FSLR, described in (Algorithm 10.4, Hastie et al. 2001), where Step</context>
</contexts>
<marker>Donoho, Johnstone, Kerkyachairan, Picard, 1995</marker>
<rawString>Donoho, D., I. Johnstone, G. Kerkyachairan, and D. Picard. 1995. Wavelet shrinkage; asymptopia? (with discussion), J. Royal. Statist. Soc. 57: 201-337.</rawString>
</citation>
<citation valid="true">
<authors>
<author>B Efron</author>
<author>T Hastie</author>
<author>I Johnstone</author>
<author>R Tibshirani</author>
</authors>
<title>Least angle regression.</title>
<date>2004</date>
<journal>Ann. Statist.</journal>
<volume>32</volume>
<pages>407--499</pages>
<contexts>
<context position="11006" citStr="Efron et al. 2004" startWordPosition="1915" endWordPosition="1918">ter α controls the amount of regularization applied to the estimate. Setting α = 0 reverses the LassoLoss to the unregularized ExpLoss; as α increases, the model coefficients all shrink, each ultimately becoming zero. In practice, α should be adaptively chosen to minimize an estimate of expected loss, e.g., α decreases with the increase of the number of iterations. Computation of the solution to the lasso problem has been studied for special loss functions. For least square regression, there is a fast algorithm LARS to find the whole lasso path for different α’ s (Obsborn et al. 2000a; 2000b; Efron et al. 2004); for 1-norm SVM, it can be transformed into a linear programming problem with a fast algorithm similar to LARS (Zhu et al. 2003). However, the solution to the lasso problem for a general convex loss function and an adaptive α remains open. More importantly for our purposes, directly minimizing lasso function of Equation (10) with respect to λ is not possible when a very large number of model parameters are employed, as in our task of LM for IME. Therefore we investigate below two methods that closely approximate the effect of the lasso, and are very similar to the boosting algorithm. It is al</context>
</contexts>
<marker>Efron, Hastie, Johnstone, Tibshirani, 2004</marker>
<rawString>Efron, B., T. Hastie, I. Johnstone, and R. Tibshirani. 2004. Least angle regression. Ann. Statist. 32, 407-499.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Y Freund</author>
<author>R Iyer</author>
<author>R E Schapire</author>
<author>Y Singer</author>
</authors>
<title>An efficient boosting algorithm for combining preferences.</title>
<date>1998</date>
<booktitle>In ICML’98.</booktitle>
<contexts>
<context position="8457" citStr="Freund et al. (1998)" startWordPosition="1447" endWordPosition="1450">ves a brief review of the boosting algorithm, following the description of some recent work (e.g., Schapire and Singer 1999; Collins and Koo 2005). The boosting algorithm uses an exponential loss function (ExpLoss) to approximate the sample risk in Equation (4). We define the margin of the pair (WR, W) with respect to the model λ as M W R W = Score W R λ − Score W λ ( , ) ( , ) ( , ) (5) Then, ExpLoss is defined as ExpLoss( ) λ = ∑ ∑exp( ( , )) R −M W W (6) i i i MW =1. .. ∈ GEN ( ) A i i Notice that ExpLoss is convex so there is no problem with local minima when optimizing it. It is shown in Freund et al. (1998) and Collins and Koo (2005) that there exist gradient search procedures that converge to the right solution. Figure 1 summarizes the boosting algorithm we used. After initialization, Steps 2 and 3 are = i λ M 1... . (4) λ def ∑ MSR = arg min Er(WiR , Wi* (A λ i , )) W) λdfd W ( ). (2) . (3) W∈ 226 repeated N times; at each iteration, a feature is chosen and its weight is updated as follows. First, we define Upd(λ, k, δ) as an updated model, with the same parameter values as λ with the exception of λk, which is incremented by δ Upd(λ,k,δ) = Jλ0,λ,...,λk +δ,...,λD } Then, Steps 2 and 3 in Figure</context>
</contexts>
<marker>Freund, Iyer, Schapire, Singer, 1998</marker>
<rawString>Freund, Y, R. Iyer, R. E. Schapire, and Y. Singer. 1998. An efficient boosting algorithm for combining preferences. In ICML’98.</rawString>
</citation>
<citation valid="true">
<authors>
<author>T Hastie</author>
<author>R Tibshirani</author>
<author>J Friedman</author>
</authors>
<title>The elements of statistical learning.</title>
<date>2001</date>
<publisher>Springer-Verlag,</publisher>
<location>New York.</location>
<contexts>
<context position="3438" citStr="Hastie et al. 2001" startWordPosition="526" endWordPosition="529"> experiments of lasso on multi-class classification tasks where only a small number of features need to be handled and the lasso solution can be directly computed via numerical methods. To our knowledge, this paper presents the first empirical study of lasso for a realistic, large scale task: LM for Asian language text input. Because the task utilizes millions of features and training samples, directly optimizing the penalized lasso loss function is impossible. Therefore, two approximation methods, the boosted lasso (BLasso, Zhao and Yu 2004) and the forward stagewise linear regression (FSLR, Hastie et al. 2001), are investigated. Both methods, when used with the exponential loss function, bear strong resemblance to the boosting algorithm which has been used as a discriminative training method for LM. Evaluations on the task of Japanese text input show that BLasso is able to produce the best approximation to the lasso solution, and leads to a significant improvement, in terms of character error rate, over the boosting algorithm and the traditional MLE. 2 LM Task and Problem Definition This paper studies LM on the application of Asian language (e.g. Chinese or Japanese) text input, a standard method o</context>
<context position="12480" citStr="Hastie et al. 2001" startWordPosition="2169" endWordPosition="2172">t research (Donoho et al. 1995) shows that the L1 penalty is better suited for sparse situations, where there are only a small number of features with nonzero weights among all candidate features. We find that our task is indeed a sparse situation: among 860,000 features, in the resulting linear model only around 5,000 features have nonzero weights. We then focus on the L1 penalty. We leave the empirical comparison of the L1 and L2 penalty on the LM task to future work. 4.1 Forward Stagewise Linear Regression (FSLR) The first approximation method we used is FSLR, described in (Algorithm 10.4, Hastie et al. 2001), where Steps 2 and 3 in Figure 1 are performed according to Equations (7) and (11), respectively. ( k *,*) argminExpLoss(Upd( , , )) δ = λ k δ (7) k,δ λt = Upd( −1 , k*,ε × sign(δ *)) λt (11) Notice that FSLR is very similar to the boosting algorithm with shrinkage in that at each step, the feature fk* that has largest estimated impact on reducing ExpLoss is selected. The only difference is that FSLR updates the weight of fk* by a small fixed step size ε. By taking such small steps, FSLR imposes some implicit regularization, and can closely approximate the effect of the lasso in a local sense</context>
</contexts>
<marker>Hastie, Tibshirani, Friedman, 2001</marker>
<rawString>Hastie, T., R. Tibshirani and J. Friedman. 2001. The elements of statistical learning. Springer-Verlag, New York.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jianfeng Gao</author>
<author>Hisami Suzuki</author>
<author>Yang Wen</author>
</authors>
<title>Exploiting headword dependency and predictive clustering for language modeling.</title>
<date>2002</date>
<booktitle>In EMNLP</booktitle>
<contexts>
<context position="19234" citStr="Gao et al. 2002" startWordPosition="3361" endWordPosition="3364"> data consisting of 72K sentences (0.9M~1.7M words) and test data of 5K sentences (65K~120K words) from each adaptation domain. The first 800 and 8,000 sentences of each adaptation training data were also used to show how different sizes of training data affected the performances of various adaptation methods. Another 5K-sentence subset was used as held-out data for each domain. We created the training samples for discriminative learning as follows. For each phonetic string A in adaptation training data, we produced a lattice of candidate word strings W using the baseline system described in (Gao et al. 2002), which uses a word trigram model trained via MLE on the Nikkei Newspaper corpus. For efficiency, we kept only the best 20 hypotheses in its candidate conversion set GEN(A) for each training sample for discriminative training. The oracle best hypothesis, which gives the minimum number of errors, was used as the reference transcript of A. We used unigrams and bigrams that occurred more than once in the training set as features in the linear model of Equation (2). The total number of candidate features we used was around 860,000. 5.2 Main Results Table 1 summarizes the results of various model t</context>
<context position="26597" citStr="Gao et al. (2002)" startWordPosition="4608" endWordPosition="4611"> many strongly correlated features, model parameters can be poorly estimated and exhibit high variance. By imposing a model size constraint, as in lasso, this phenomenon is alleviated. Therefore, we speculate that a better approximation to lasso, as BLasso with backward steps, would be superior in eliminating the negative effect of strongly correlated features in model estimation. To verify our speculation, we performed the following experiments. For each training set, in addition to word unigram and bigram features, we introduced a new type of features called headword bigram. As described in Gao et al. (2002), headwords are defined as the content words of the sentence. Therefore, headword bigrams constitute a special type of skipping bigrams which can capture dependency between two words that may not be adjacent. In reality, a large portion of headword bigrams are identical to word bigrams, as two headwords can occur next to each other in text. In the adaptation test data we used, we find that headword bigram features are for the most part either completely overlapping with the word bigram features (i.e., all instances of headword bigrams also count as word bigrams) or not overlapping at all (i.e.</context>
</contexts>
<marker>Gao, Suzuki, Wen, 2002</marker>
<rawString>Gao, Jianfeng, Hisami Suzuki and Yang Wen. 2002. Exploiting headword dependency and predictive clustering for language modeling. In EMNLP 2002.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Yu</author>
<author>H Yuan</author>
<author>W</author>
<author>P Xu</author>
</authors>
<title>Minimum sample risk methods for language modeling.</title>
<date>2005</date>
<booktitle>In HLT/EMNLP</booktitle>
<marker>Yu, Yuan, W, Xu, 2005</marker>
<rawString>Gao. J., Yu, H., Yuan, W., and Xu, P. 2005. Minimum sample risk methods for language modeling. In HLT/EMNLP 2005.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M R Osborne</author>
<author>B Presnell</author>
<author>B A Turlach</author>
</authors>
<title>A new approach to variable selection in least squares problems.</title>
<date>2000</date>
<journal>Journal of Numerical Analysis,</journal>
<volume>20</volume>
<issue>3</issue>
<marker>Osborne, Presnell, Turlach, 2000</marker>
<rawString>Osborne, M.R. and Presnell, B. and Turlach B.A. 2000a. A new approach to variable selection in least squares problems. Journal of Numerical Analysis, 20(3).</rawString>
</citation>
<citation valid="true">
<authors>
<author>M R Osborne</author>
<author>B Presnell</author>
<author>B A Turlach</author>
</authors>
<title>On the lasso and its dual.</title>
<date>2000</date>
<journal>Journal of Computational and Graphical Statistics,</journal>
<volume>9</volume>
<issue>2</issue>
<pages>319--337</pages>
<marker>Osborne, Presnell, Turlach, 2000</marker>
<rawString>Osborne, M.R. and Presnell, B. and Turlach B.A. 2000b. On the lasso and its dual. Journal of Computational and Graphical Statistics, 9(2): 319-337.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Brian Roark</author>
<author>Murat Saraclar</author>
<author>Michael Collins</author>
</authors>
<title>Corrective language modeling for large vocabulary ASR with the perceptron algorithm.</title>
<date>2004</date>
<booktitle>In ICASSP</booktitle>
<contexts>
<context position="1771" citStr="Roark et al. 2004" startWordPosition="263" endWordPosition="266">to the lasso solution, and leads to a significant improvement, in terms of character error rate, over boosting and the traditional maximum likelihood estimation. 1 Introduction Language modeling (LM) is fundamental to a wide range of applications. Recently, it has been shown that a linear model estimated using discriminative training methods, such as the boosting and perceptron algorithms, outperforms significantly a traditional word trigram model trained using maximum likelihood estimation (MLE) on several tasks such as speech recognition and Asian language text input (Bacchiani et al. 2004; Roark et al. 2004; Gao et al. 2005; Suzuki and Gao 2005). The success of discriminative training methods is largely due to fact that unlike the traditional approach (e.g., MLE) that maximizes the function (e.g., likelihood of training data) that is loosely associated with error rate, discriminative training methods aim to directly minimize the error rate on training data even if they reduce the likelihood. However, given a finite set of training samples, discriminative training methods could lead to an arbitrary complex model for the purpose of achieving zero training error. It is well-known that complex model</context>
</contexts>
<marker>Roark, Saraclar, Collins, 2004</marker>
<rawString>Roark, Brian, Murat Saraclar and Michael Collins. 2004. Corrective language modeling for large vocabulary ASR with the perceptron algorithm. In ICASSP 2004.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Robert E Schapire</author>
<author>Yoram Singer</author>
</authors>
<title>Improved boosting algorithms using confidence-rated predictions.</title>
<date>1999</date>
<booktitle>Machine Learning,</booktitle>
<volume>37</volume>
<issue>3</issue>
<pages>297--336</pages>
<contexts>
<context position="7960" citStr="Schapire and Singer 1999" startWordPosition="1330" endWordPosition="1333">ase. We call the sum of error counts over the training samples sample risk. Our goal then is to search for the best parameter set λ which minimizes the sample risk, as in Equation (4): However, (4) cannot be optimized easily since Er(.) is a piecewise constant (or step) function of λ and its gradient is undefined. Therefore, discriminative methods apply different approaches that optimize it approximately. The boosting algorithm described below is one of such approaches. 3 Boosting This section gives a brief review of the boosting algorithm, following the description of some recent work (e.g., Schapire and Singer 1999; Collins and Koo 2005). The boosting algorithm uses an exponential loss function (ExpLoss) to approximate the sample risk in Equation (4). We define the margin of the pair (WR, W) with respect to the model λ as M W R W = Score W R λ − Score W λ ( , ) ( , ) ( , ) (5) Then, ExpLoss is defined as ExpLoss( ) λ = ∑ ∑exp( ( , )) R −M W W (6) i i i MW =1. .. ∈ GEN ( ) A i i Notice that ExpLoss is convex so there is no problem with local minima when optimizing it. It is shown in Freund et al. (1998) and Collins and Koo (2005) that there exist gradient search procedures that converge to the right solu</context>
<context position="21162" citStr="Schapire and Singer (1999)" startWordPosition="3684" endWordPosition="3687">t maximizes the likelihood of the adaptation data. Our implementation takes the form of linear interpolation as described in Bacchiani et al. (2004): P(wi|h) = λPb(wi|h) + (1-λ)Pa(wi|h), where Pb is the probability of the background model, Pa is the probability trained on adaptation data using MLE and the history h corresponds to two preceding words (i.e. Pb and Pa are trigram probabilities). λ is the interpolation weight optimized on held-out data. Boosting, with results shown in Column 5, is the algorithm described in Figure 1. In our implementation, we use the shrinkage method suggested by Schapire and Singer (1999) and Collins and Koo (2005). At each iteration, we used the following update for the kth feature + 1 C Z + ε (16) k = log k where Ck+ is a value increasing exponentially with the sum of margins of (WR, W) pairs over the set where fk is seen in WR but not in W; Ck- is the value related to the sum of margins over the set where fk is seen in W but not in WR. ε is a smoothing factor (whose value is optimized on held-out data) and Z is a normalization constant (whose value is the ExpLoss(.) of training data according to the current model). We see that εZ in Equation (16) plays the same role as ν in</context>
</contexts>
<marker>Schapire, Singer, 1999</marker>
<rawString>Schapire, Robert E. and Yoram Singer. 1999. Improved boosting algorithms using confidence-rated predictions. Machine Learning, 37(3): 297-336.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Hisami Suzuki</author>
<author>Jianfeng Gao</author>
</authors>
<title>A comparative study on language model adaptation using new evaluation metrics.</title>
<date>2005</date>
<booktitle>In HLT/EMNLP</booktitle>
<contexts>
<context position="1810" citStr="Suzuki and Gao 2005" startWordPosition="271" endWordPosition="274">a significant improvement, in terms of character error rate, over boosting and the traditional maximum likelihood estimation. 1 Introduction Language modeling (LM) is fundamental to a wide range of applications. Recently, it has been shown that a linear model estimated using discriminative training methods, such as the boosting and perceptron algorithms, outperforms significantly a traditional word trigram model trained using maximum likelihood estimation (MLE) on several tasks such as speech recognition and Asian language text input (Bacchiani et al. 2004; Roark et al. 2004; Gao et al. 2005; Suzuki and Gao 2005). The success of discriminative training methods is largely due to fact that unlike the traditional approach (e.g., MLE) that maximizes the function (e.g., likelihood of training data) that is loosely associated with error rate, discriminative training methods aim to directly minimize the error rate on training data even if they reduce the likelihood. However, given a finite set of training samples, discriminative training methods could lead to an arbitrary complex model for the purpose of achieving zero training error. It is well-known that complex models exhibit high variance and perform poo</context>
</contexts>
<marker>Suzuki, Gao, 2005</marker>
<rawString>Suzuki, Hisami and Jianfeng Gao. 2005. A comparative study on language model adaptation using new evaluation metrics. In HLT/EMNLP 2005.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Tibshirani</author>
</authors>
<title>Regression shrinkage and selection via the lasso.</title>
<date>1996</date>
<journal>J. R. Statist. Soc. B,</journal>
<volume>58</volume>
<issue>1</issue>
<pages>267--288</pages>
<contexts>
<context position="2764" citStr="Tibshirani (1996)" startWordPosition="423" endWordPosition="424"> the likelihood. However, given a finite set of training samples, discriminative training methods could lead to an arbitrary complex model for the purpose of achieving zero training error. It is well-known that complex models exhibit high variance and perform poorly on unseen data. Therefore some regularization methods have to be used to control the complexity of the model. Lasso is a regularization method for parameter estimation in linear models. It optimizes the model parameters with respect to a loss function subject to model complexities. The basic idea of lasso is originally proposed by Tibshirani (1996). Recently, there have been several implementations and experiments of lasso on multi-class classification tasks where only a small number of features need to be handled and the lasso solution can be directly computed via numerical methods. To our knowledge, this paper presents the first empirical study of lasso for a realistic, large scale task: LM for Asian language text input. Because the task utilizes millions of features and training samples, directly optimizing the penalized lasso loss function is impossible. Therefore, two approximation methods, the boosted lasso (BLasso, Zhao and Yu 20</context>
<context position="9983" citStr="Tibshirani 1996" startWordPosition="1735" endWordPosition="1736">ade arbitrarily small. However, fitting training data too well eventually leads to overfiting, which degrades the performance on unseen test data (even though in boosting overfitting can happen very slowly). Shrinkage is a simple approach to dealing with the overfitting problem. It scales the incremental step δ by a small constant ν, ν ∈ (0, 1). Thus, the update of Equation (8) with shrinkage is t Upd( 1,k *,νδ *) λt− λ = (9) Empirically, it has been found that smaller values of ν lead to smaller numbers of test errors. 4 Lasso Lasso is a regularization method for estimation in linear models (Tibshirani 1996). It regularizes or shrinks a fitted model through an L1 penalty or constraint. Let T(λ) denote the L1 penalty of the model, i.e., T(λ) = ∑d = 0...D|λd|. We then optimize the model λ so as to minimize a regularized loss function on training data, called lasso loss defined as LassoLoss( , ) ExpLoss( ) ( ) λ α = λ +αT λ (10) where T(λ) generally penalizes larger models (or complex models), and the parameter α controls the amount of regularization applied to the estimate. Setting α = 0 reverses the LassoLoss to the unregularized ExpLoss; as α increases, the model coefficients all shrink, each ult</context>
</contexts>
<marker>Tibshirani, 1996</marker>
<rawString>Tibshirani, R. 1996. Regression shrinkage and selection via the lasso. J. R. Statist. Soc. B, 58(1): 267-288.</rawString>
</citation>
<citation valid="true">
<authors>
<author>W Yuan</author>
<author>J Gao</author>
<author>H Suzuki</author>
</authors>
<title>An Empirical Study on Language Model Adaptation Using a Metric of Domain Similarity.</title>
<date>2005</date>
<booktitle>In IJCNLP 05.</booktitle>
<contexts>
<context position="20340" citStr="Yuan et al. 2005" startWordPosition="3545" endWordPosition="3548">ndidate features we used was around 860,000. 5.2 Main Results Table 1 summarizes the results of various model training (adaptation) methods in terms of CER (%) and CER reduction (in parentheses) over comparing models. In the first column, the numbers in parentheses next to the domain name indicates the number of training sentences used for adaptation. Baseline, with results shown in Column 3, is the word trigram model. As expected, the CER correlates very well the similarity between the background domain and the adaptation domain, where domain similarity is measured in terms of cross entropy (Yuan et al. 2005) as shown in Column 2. MAP (maximum a posteriori), with results shown in Column 4, is a traditional LM adaptation method where the parameters of the background model are adjusted in such a way that maximizes the likelihood of the adaptation data. Our implementation takes the form of linear interpolation as described in Bacchiani et al. (2004): P(wi|h) = λPb(wi|h) + (1-λ)Pa(wi|h), where Pb is the probability of the background model, Pa is the probability trained on adaptation data using MLE and the history h corresponds to two preceding words (i.e. Pb and Pa are trigram probabilities). λ is the</context>
</contexts>
<marker>Yuan, Gao, Suzuki, 2005</marker>
<rawString>Yuan, W., J. Gao and H. Suzuki. 2005. An Empirical Study on Language Model Adaptation Using a Metric of Domain Similarity. In IJCNLP 05.</rawString>
</citation>
<citation valid="true">
<authors>
<author>P Zhao</author>
<author>B Yu</author>
</authors>
<title>Boosted lasso.</title>
<date>2004</date>
<tech>Tech Report, Statistics</tech>
<contexts>
<context position="3367" citStr="Zhao and Yu 2004" startWordPosition="515" endWordPosition="518">shirani (1996). Recently, there have been several implementations and experiments of lasso on multi-class classification tasks where only a small number of features need to be handled and the lasso solution can be directly computed via numerical methods. To our knowledge, this paper presents the first empirical study of lasso for a realistic, large scale task: LM for Asian language text input. Because the task utilizes millions of features and training samples, directly optimizing the penalized lasso loss function is impossible. Therefore, two approximation methods, the boosted lasso (BLasso, Zhao and Yu 2004) and the forward stagewise linear regression (FSLR, Hastie et al. 2001), are investigated. Both methods, when used with the exponential loss function, bear strong resemblance to the boosting algorithm which has been used as a discriminative training method for LM. Evaluations on the task of Japanese text input show that BLasso is able to produce the best approximation to the lasso solution, and leads to a significant improvement, in terms of character error rate, over the boosting algorithm and the traditional MLE. 2 LM Task and Problem Definition This paper studies LM on the application of As</context>
<context position="13407" citStr="Zhao and Yu (2004)" startWordPosition="2339" endWordPosition="2342"> has largest estimated impact on reducing ExpLoss is selected. The only difference is that FSLR updates the weight of fk* by a small fixed step size ε. By taking such small steps, FSLR imposes some implicit regularization, and can closely approximate the effect of the lasso in a local sense (Hastie et al. 2001). Empirically, we find that the performance of the boosting algorithm with shrinkage closely resembles that of FSLR, with the learning rate parameter ν corresponding to ε. 227 4.2 Boosted Lasso (BLasso) The second method we used is a modified version of the BLasso algorithm described in Zhao and Yu (2004). There are two major differences between BLasso and FSLR. At each iteration, BLasso can take either a forward step or a backward step. Similar to the boosting algorithm and FSLR, at each forward step, a feature is selected and its weight is updated according to Equations (12) and (13). ( k*, *) argminExpLoss(Upd( , , δ = λ k δ )) (12) k , δ ε =± λt = Upd( −1, k*,ε × sign(δ *)) λt (13) However, there is an important difference between Equations (12) and (7). In the boosting algorithm with shrinkage and FSLR, as shown in Equation (7), a feature is selected by its impact on reducing the loss wit</context>
<context position="15641" citStr="Zhao and Yu (2004)" startWordPosition="2740" endWordPosition="2743">ning. The algorithm starts with a large initial α, and then at each forward step the value of α decreases until the ExpLoss stops decreasing. This is intuitively desirable: It is expected that most highly effective features are selected in early stages of training, so the reduction of ExpLoss at each step in early stages are more substantial than in later stages. These early steps coincide with the boosting steps most of the time. In other words, the effect of backward steps is more visible at later stages. Our implementation of BLasso differs slightly from the original algorithm described in Zhao and Yu (2004). Firstly, because the value of the base feature f0 is the log probability (assigned by a word trigram model) and has a different range from that of other features as in Equation (2), λ0 is set to optimize ExpLoss in the initialization step (Step 1 in Figure 2) and remains fixed during training. As suggested by Collins and Koo (2005), this ensures that the contribution of the log-likelihood feature f0 is well-calibrated with respect to ExpLoss. Secondly, when updating a feature weight, if the size of the optimal update step (computed via Equation (7)) is smaller than ε, we use the optimal step</context>
<context position="17059" citStr="Zhao and Yu 2004" startWordPosition="2991" endWordPosition="2994">(also used in our implementations of boosting and FSLR) were crucial to the performance of the methods. 1 Initialize λ0: set λ0 = argminλ0ExpLoss(λ), and λd = 0 for d=1...D. 2 Take a forward step according to Eq. (12) and (13), and the updated model is denoted by λ1 3 Initialize α = (ExpLoss(λ0)-ExpLoss(λ1))/ε 4 Take a backward step if and only if it leads to a decrease of LassoLoss according to Eq. (14) and (15), where θ = 0; otherwise 5 Take a forward step according to Eq. (12) and (13); update α = min(α, (ExpLoss(λt-1)-ExpLoss(λt))/ε ); and return to Step 4. Figure 2: The BLasso algorithm (Zhao and Yu 2004) provides theoretical justifications for BLasso. It has been proved that (1) it guarantees that it is safe for BLasso to start with an initial α which is the largest α that would allow an ε step away from 0 (i.e., larger α’s correspond to T(λ)=0); (2) for each value of α, BLasso performs coordinate descent (i.e., reduces ExpLoss by updating the weight of a feature) until there is no descent step; and (3) for each step where the value of α decreases, it guarantees that the lasso loss is reduced. As a result, it can be proved that for a finite number of features and θ = 0, the BLasso algorithm s</context>
</contexts>
<marker>Zhao, Yu, 2004</marker>
<rawString>Zhao, P. and B. Yu. 2004. Boosted lasso. Tech Report, Statistics Department, U. C. Berkeley.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J S Rosset Zhu</author>
<author>T Hastie</author>
<author>R Tibshirani</author>
</authors>
<title>1-norm support vector machines.</title>
<date>2003</date>
<journal>NIPS</journal>
<volume>16</volume>
<publisher>MIT Press.</publisher>
<contexts>
<context position="11135" citStr="Zhu et al. 2003" startWordPosition="1938" endWordPosition="1941">oss; as α increases, the model coefficients all shrink, each ultimately becoming zero. In practice, α should be adaptively chosen to minimize an estimate of expected loss, e.g., α decreases with the increase of the number of iterations. Computation of the solution to the lasso problem has been studied for special loss functions. For least square regression, there is a fast algorithm LARS to find the whole lasso path for different α’ s (Obsborn et al. 2000a; 2000b; Efron et al. 2004); for 1-norm SVM, it can be transformed into a linear programming problem with a fast algorithm similar to LARS (Zhu et al. 2003). However, the solution to the lasso problem for a general convex loss function and an adaptive α remains open. More importantly for our purposes, directly minimizing lasso function of Equation (10) with respect to λ is not possible when a very large number of model parameters are employed, as in our task of LM for IME. Therefore we investigate below two methods that closely approximate the effect of the lasso, and are very similar to the boosting algorithm. It is also worth noting the difference between L1 and L2 penalty. The classical Ridge Regression setting uses an L2 penalty in Equation (</context>
</contexts>
<marker>Zhu, Hastie, Tibshirani, 2003</marker>
<rawString>Zhu, J. S. Rosset, T. Hastie, and R. Tibshirani. 2003. 1-norm support vector machines. NIPS 16. MIT Press.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>