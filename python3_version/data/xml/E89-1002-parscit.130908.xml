<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<title confidence="0.731172">
PARSING AND DERIVATIONAL EQUIVALENCE*
</title>
<author confidence="0.863235">
Mark Hepple and Glyn Morrill
</author>
<affiliation confidence="0.81306">
Centre for Cognitive Science, University of Edinburgh
2 Buccleuch Place, Edinburgh EH8 9LW Scotland
</affiliation>
<sectionHeader confidence="0.950465" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999982277777778">
It is a tacit assumption of much linguistic inquiry
that all distinct derivations of a string should assign
distinct meanings. But despite the tidiness of such
derivational uniqueness, there seems to be no a pri-
ori reason to assume that a grammar must have this
property. If a grammar exhibits derivational equiv-
alence, whereby distinct derivations of a string as-
sign the same meanings, naive exhaustive search
for all derivations will be redundant, and quite
possibly intractable. In this paper we show how
notions of derivation-reduction and normal form
can be used to avoid unnecessary work while pars-
ing with grammars exhibiting derivational equiv-
alence. With grammar regarded as analogous to
logic, derivations are proofs; what we are advocat-
ing is proof-reduction, and normal form proof; the
invocation of these logical techniques adds a further
paragraph to the story of parsing-as-deduction.
</bodyText>
<sectionHeader confidence="0.961454" genericHeader="introduction">
Introduction
</sectionHeader>
<bodyText confidence="0.999021666666667">
The phenomenon of derivational equivalence
is most evident in work on generalised categorial
grammars, where it has been referred to as &apos;spu-
rious ambiguity&apos;. It has been argued that the ca-
pacity to assign left-branching, and therefore incre-
mentally interpretable, analyses makes these gram-
mars of particular psychological interest. We will
illustrate our methodology by reference to gener-
alised categorial grammars using a combinatory
logic (as opposed to say, lambda-calculus) seman-
tics. In particular we consider combinatory (cate-
gorial) grammars with rules and generalised rules
• We thank Mike Reape for criticism and suggestions in
relation to this material, and Inge Bethke and Hank Zee-
vat for reading a late draft. All errors are our own. The
work was carried out by the alphabetically first author under
ESRC Postgraduate Award C00428722003 and by the sec-
ond under ESRC Postgraduate Award C00428522008 and
an SERC Postdoctoral Fellowship in IT.
of the kind of Steedman (1987), and with metarules
(Morrill, 1988).
Although the problem of derivational equiva-
lence is most apparent in generalised categorial
grammars, the problem is likely to recur in many
grammars characterising a full complement of con-
structions. For example, suppose that a grammar
is capable of characterising right extraposition of
an object&apos;s adjunct to clause-final position. Then
sentences such as John met a man yesterday who
swims will be generated. But it is probable that
the same grammar will assign John met a man who
swims a right extraposition derivation in which the
relative clause happens to occupy its normal posi-
tion in the string; the normal and right extrapo-
sition derivations generate the same strings with
the same meanings, so there is derivational equiva-
lence. Note that a single equivalence of this kind in
a grammar undermines a methodological assump-
tion of derivational uniqueness.
</bodyText>
<sectionHeader confidence="0.950207" genericHeader="method">
Combinatory Logic and Combina-
tory Grammar
</sectionHeader>
<bodyText confidence="0.9983027">
Combinatory logic (CL; Curry and Feys, 1958;
Curry, Hindley and Seldin, 1972; Hindley and
Seldin, 1986) refers to systems which are ap-
plicative, like the lambda-calculi, but which for-
malise functional abstraction through a small num-
ber of basic `combinators&apos;, rather than through a
variable-binding operator like A. We will define a
typed combinatory logic. Assume a set of basic
types, say e and t. Then the set of types is defined
as follows:
</bodyText>
<listItem confidence="0.492339">
(1) a. If A is a basic type then A is a type
b. If A and B are types then A--■13 is a type
</listItem>
<bodyText confidence="0.943773777777778">
A convention of right-associativity will be used for
types, so that e.g. (e---4)--+(e-4) may be writ-
- 10 -
ten (e--,t)-----4. There is a set of constants (say,
John&apos;, walks&apos;, ...), and a mapping from the set of
constants into the set of types. In addition there
are the combinators in (2); their lambda-analogues
are shown in parentheses.
is defined as follows:
</bodyText>
<note confidence="0.465078">
(5) a. If X is a basic category then X is a category
b. If X and Y are categories then X/Y and X \ Y are
categories
</note>
<figure confidence="0.942606222222222">
(2) IA-.A
B(B-+C)-.(A-.8)--+A-.0
C(A-.B-.c)--+B-rA--+c
W(A-1.A-+B)--+A-+B
(Ax[x])
(AxAyAzIx(yz)])
(AxAYAz[(30)Y])
(AxAYE(xY)Y1)
The set of CL-terms is defined thus:
</figure>
<bodyText confidence="0.967152833333333">
A convention of left-associativity will be used for
categories, so that e.g. (S \NP)VS \NP) may be
written S \NPVS \ NP). There is a set of words,
and a lexical association of words with categories.
There is a set of rules with combinators, mini-
mally:
</bodyText>
<listItem confidence="0.550084">
(3) a. If M is a constant or combinator of type A then
</listItem>
<subsectionHeader confidence="0.444391">
M is a CL-term of type A
</subsectionHeader>
<bodyText confidence="0.8836863">
b. If M is a CL-term of type B--■A and N is a CL-
term of type B then (MN) is a CL-term of type
A.
The interpretation of a term built by (3b) is given
by the functional application of the interpretation
of the left-hand sub-term to that of the right-
hand one. We will assume a convention of left-
association for application. Some examples of CL-
terms are as follows, where the types are written
below each component term:
</bodyText>
<figure confidence="0.744167">
(4) a. walks&apos; John&apos;
e--4t e
t
C I
_ -
((e--,t)-+e-q)--+e-+(e-q)--,t (e-q)--Pe-Pt
e---■(e-+t)-+t
B probably&apos; walks&apos;
—
(t--+t)--+(e--+t)-fre.+t t-+t
</figure>
<subsectionHeader confidence="0.425391">
e-&apos;t
</subsectionHeader>
<bodyText confidence="0.998815769230769">
Other basic combinators can be used in a CL, for
example S, which corresponds to AxAyAz[(xz)(yz)].
Our CL definition is (extensionally) equivalent to
the AI-calculus, i.e. the lambda-calculus without
vacuous abstraction (terms of the form AxM where
x does not occur in M). There is a combinator K
(AxAy[x]) which would introduce vacuous abstrac-
tion, and the CL with S and K is (extensionally)
equivalent to the AK-calculus, i.e. the full lambda-
calculus.
A combinatory grammar (CG) can be defined in
a largely analogous manner. Assume a set of basic
categories, say S, NP, ... Then the set of categories
</bodyText>
<figure confidence="0.505222875">
(6) a. Forward Application (&gt;)
f: X/Y + Y X (where f x y= x 3&apos;)
b. Backward Application (c)
b: Y + X\Y X (where byx=x y)
The set of CG-terms is defined thus:
(7) a. If M is word of category A then M is a CG-term
of category A
b. If X1+• • •-1-Xn X0 is a rule with combinator&apos;,
</figure>
<bodyText confidence="0.8270726">
and Si, • • • , Sn are CG-terms of category Xi, • • • ,
Xn, then [4, Si ... Sn] is a CG-term of category
Xo.
The interpretation of a term built by (7b) is given
by the functional application of the combinator to
the sub-term interpretations in left-to-right order.
A verb phrase containing an auxiliary can be de-
rived as in (8) (throughout, VP abbreviates S \NP).
The meaning assigned is given by (9a), which is
equal to (9b).
</bodyText>
<figure confidence="0.619879">
(5) will see John
— —
VP/VP VP/NP NP
&gt;
VP
VP
(9) a. (f will&apos; (f see&apos; John&apos;))
b. will&apos; (see&apos; John&apos;)
</figure>
<bodyText confidence="0.999399166666667">
Suppose the grammar is augmented with a rule
of functional composition (10), as is claimed to be
appropriate for analysis of extraction and coordina-
tion (Ades and Steedman, 1982; Steedman, 1985).
Then for example, the right hand conjunct in (11a)
can be analysed as shown in (11b).
</bodyText>
<figure confidence="0.95200275">
b.
C.
requires comparison with every edge spanning the
relevant region, checking time increases with the
number of such edges.
(10) Forward Composition (&gt;B)
B: X/Y Y/Z X/Z (where Bxyz=x (y z))
(11) a. Mary [phoned and will see] John
b. will see
VP/VP VP/NP
&gt;B
VP/NP
</figure>
<bodyText confidence="0.94038925">
Forward Application of (11b) to John will assign
meaning (12) which is again equal to (9b), and this
is appropriate because will see John is unambigu-
ous.
</bodyText>
<listItem confidence="0.586133">
(12) (f (B will&apos; see&apos;) John&apos;)
</listItem>
<bodyText confidence="0.999962617647059">
However the grammar now exhibits derivational
equivalence, with different derivations assigning
the same meaning. In general a sequence
Ai/A2+A2/A3+A3/A4+. • +An can be analysed
as Al with the same meaning by combining any
pair of adjacent elements at each step. Thus there
are a number of equivalent derivations equal to
the number of n-leaf binary trees; this is given by
the Catalan series, which is such that Catalan(n)
&gt; 2n-2. As well as it being inefficient to search
through derivations which are equivalent, the expo-
nential figure signifies computational intractability.
Several suggestions have been made in relation
to this problem. Pareschi and Steedman (1987) de-
scribe what they call a &apos;lazy chart parser&apos; intended
to yield only one of each set of equivalent analy-
ses by adopting a reduce-first parsing strategy, and
invoking a special recovery procedure to avoid the
backtracking that this strategy would otherwise ne-
cessitate. But Hepple (1987) shows that their al-
gorithm is incomplete.
Wittenburg (1987) presents an approach in
which a combinatory grammar is compiled into one
not exhibiting derivational equivalence. Such com-
pilation seeks to avoid the problem of parsing with
a grammar exhibiting derivational equivalence by
arranging that the grammar used on-line does not
have this property. The concern here however is
management of parsing when the grammar used
on-line does have the problematic property.
Karttunen (1986) suggests a strategy in which
every potential new edge is tested against the chart
to see whether an existing analysis spanning the
same region is equivalent. If one is found, the new
analysis is discarded. However, because this check
The solution we offer is one in which there ie
a notion of normal form derivation, and a set ol
contraction rules which reduce derivations to theh
normal forms, normal form derivations being those
to which no contraction rule can apply. The con.
traction rules might be used in a number of ways
(e.g. to transform one derivation into another,
rather than recompute from the start, cf. Paresch
and Steedman). The possibility emphasised here
is one in which we ensure that a processing ster
does not create a non-normal form derivation. Any
such derivation is dispensable, assuming exhaustive
search: the normal form derivation to which it is
equivalent, and which won&apos;t be excluded, will yield
the same result. Thus the equivalence check can
be to make sure that each derivation computed is
a normal form, e.g. by checking that no step creates
a form to which a contraction rule can apply. Um
like Karttunen&apos;s subsumption check this test does
not become slower with the size of a chart. The teal
to see whether a derivation is normal form involve
nothing but the derivation itself and the invarian
definition of normal form.
The next section gives a general outline of re
duction and normal forms. This is followed by al
illustration in relation to typed combinatory logic
where we emphasise that the reduction constitute
a proof-reduction. We then describe how the no
tions can be applied to combinatory grammar ts
handle the problem of parsing and derivations
equivalence, and we again note that if derivation
are regarded as proofs, the method is an instantia
tion of proof-reduction.
</bodyText>
<subsectionHeader confidence="0.544632">
Reduction and Normal Form
</subsectionHeader>
<bodyText confidence="0.985174454545454">
It is a common state of affairs for some terms o
a language to be equivalent in that for the intendec
semantics, their interpretations are the same in al
models. In such a circumstance it can be useful ts
elect normal forms which act as unique represen
tatives of their equivalence class. For example, i
terms can be transformed into normal forms, equiv
alence between terms can be equated with identit:
of normal forms.&apos;
The usual way of defining normal forms is 131
1For our purposes &apos;identity&apos; can mean exact syntacti,
identity, and this simplifies discussion somewhat; in a systen
with bound variables such as the lambda-calculus, identit:
would mean identity up to renaming of bound variables.
- 12 -
defining a relation l&gt; (&apos;contracts-to&apos;) of CONTRAC-
TION between equivalent terms; a term X is said to
be in NORMAL FORM if and only if there is no term
Y such that X I&gt; Y. The contraction relation gen-
erates a reduction relation &gt; (&apos;reduces-to&apos;) and an
equality relation = (&apos;equals&apos;) between terms as fol-
lows:
</bodyText>
<listItem confidence="0.883564571428571">
(13) a. If X D Y then X &gt; Y
b. X &gt; X
c. If X &gt; Y and Y &gt; Z then X &gt; Z
(14) a. If X D Y then X = Y
b. X = X
c. If X = Y and Y = Z then X = Z
d. If X = Y then Y = X
</listItem>
<bodyText confidence="0.998958466666667">
The equality relation is sound with respect to a
semantic equivalence relation if X = Y implies
X a-- Y, and complete if X mY implies X = Y. It is a
sufficient condition for soundness that the contrac-
tion relation is valid. Y is a normal form of X if and
only if Y is a normal form and X &gt; Y. A sequence
X0 r&gt; X1 l&gt; • • I&gt; X. is called a REDUCTION (of
X0 to X.).
We see from (14) that if there is a T such that P
&gt; T and Q &gt; T, then P = Q (= T). In particular,
if X and Y have the same normal form, then X =
Y.
Suppose the relations of reduction and equality
generated by the contraction relation have the fol-
lowing property:
</bodyText>
<listItem confidence="0.9408195">
(15) Church-Rosser (C-R): If P = Q then there is a T
such that P &gt; T and Q &gt; T.
</listItem>
<bodyText confidence="0.997203">
There follow as corollaries that if P and Q are dis-
tinct normal forms then P Q, and that any nor-
mal form of a term is unique.2 If two terms X and
Y have distinct normal forms P and Q, then X =
P and Y= Q, but P Q, so X0 Y.
</bodyText>
<tableCaption confidence="0.91708125">
2Suppose P and Q are distinct normal forms and that P
= Q. Because normal forms only reduce to themselves and
P and Q are distinct, there is no term to which P and Q can
both reduce. But C-R tells us that if P = Q, then there it
a term to which they can both reduce. And suppose that
a term X has distinct normal forms P and Q; then X = P,
X = Q, and P = Q. But by the first corollary, for distinct
normal forms P and Q, P Q.
</tableCaption>
<bodyText confidence="0.999054833333333">
We have established that if two terms have the
same normal form then they are equal and (given
C-R) that if they have different normal forms then
they are not equal, and that normal forms are
unique. Suppose we also have the following prop-
erty:
</bodyText>
<listItem confidence="0.891626">
(16) Strong Normalisation (SN): Every reduction is finite.
</listItem>
<bodyText confidence="0.853182055555555">
This has the corollary (normalisation) that every
term has a normal form. A sufficient condition to
demonstrate SN would be to find a metric which
assigns to each term a finite non-negative integer
score, and to show that each application of a con-
traction decrements the score by a non-zero inte-
gral amount. It follows that any reduction of a term
must be finite. Given both C-R and SN, equality is
decidable: we can reduce any terms to their normal
forms in a finite number of steps, and compare for
identity.
Normal Form and Proof-Reduction
in Combinatory Logic
In the CL case, note for example the following
equivalence (omitting types for the moment):
(17) B probably&apos; walks&apos; John&apos; -a probably&apos; (walks&apos; John&apos;)
We may have the following contraction rules:
(18)a. IM PM
</bodyText>
<sectionHeader confidence="0.562355666666667" genericHeader="method">
b. BMNP DM(NP)
c. CMNP DMPN
d. WMN P.MNN
</sectionHeader>
<bodyText confidence="0.999773571428571">
These state that any term containing an occurrence
of the form on the left can be transformed to one
in which the occurrence is replaced by the form on
the right. A form on the left is called a REDEX, the
form on the right, its CONTRACTUM. To see the va-
lidity of the contraction relation defined (and the
soundness of the consequent equality), note that
the functional interpretations of a redex and a con-
tractum are the same, and that by compositional-
ity, the interpretation of a term is unchanged by
substitution of a subterm for an occurrence of a
subterm with the same interpretation. An exam-
ple of reduction of a term to its normal form is as
follows:
</bodyText>
<table confidence="0.261885">
- 13 -
(19) C I John&apos; (B probably&apos; walks&apos;) I&gt;
I (B probably&apos; walks&apos;) John&apos; D
B probably&apos; walks&apos; John&apos; D
probably&apos; (walks&apos; John&apos;)
</table>
<bodyText confidence="0.99500025">
Returning to emphasise types, observe that they
can be regarded as formulae of implicational logic.
In fact the type schemes of the basic combinators
in (2), together with a modus ponens rule corre-
sponding to the application in (3b), provide an
axiomatisation of relevant implication (see Morrill
and Carpenter, 1987, for discussion in relation to
grammar):
</bodyText>
<figure confidence="0.9816728">
(20) a. A-,A
(B-.4C)-■(A--+B)--.A-■C
(A-03--■C)-■(B-■A-■C)
b. B-&apos;A B
A
</figure>
<bodyText confidence="0.996379125">
Consider the typed CL-terms in (4). For each of
these, the tree of type formulae is a proof in im-
plicational relevance logic. Corresponding to the
term-reduction and normal form in (19), there is
proof-reduction and a normal form for a proof over
the language of types (see e.g. Hindley and Seldin,
1986). There can be proof-contraction rules such
as the following:
</bodyText>
<figure confidence="0.7102055">
(21) B N M P
(B--4C)--*(A-+B)--■A-■C B--+C A-al A
(A-03)-■A-0C
A-+C
N M P
B--■C A-413 A
</figure>
<bodyText confidence="0.977317285714286">
Proof-reduction originated with Prawitz (1965)
and is now a standard technique in logic. The sug-
gestion of this paper is that if parse trees labelled
with categories can be regarded as proofs over the
language of categories, then the problem of parsing
and derivational equivalence can be treated on the
pattern of proof-reduction.
Before proceeding to the grammar cases, a cou-
ple of remarks are in order. The equivalence ad-
dressed by the reductions above is not strong (ex-
tensional), but what is called weak equivalence. For
example the following pairs (whose types have been
omitted) are distinct weak normal forms, but are
extensionally equivalent:
</bodyText>
<listItem confidence="0.5150615">
(22) a. B (B probably&apos;necessarily&apos;) walks&apos;
b. B probablyi(B necessarily/walks&apos;)
(23) a. B I walks&apos;
b. walks&apos;
</listItem>
<bodyText confidence="0.964527772727273">
Strong equivalence and reduction is far more com-
plex than weak equivalence and reduction, but un-
fortunately it is the former which is appropriate
for the grammars. Later examples will thus differ
in this respect from the one above. A second dif-
ference is that in the example above, combinators
are axioms, and there is a single rule of applica-
tion. In the grammar cases combinators are rules.
Finally, grammar derivations have both a phono-
logical interpretation (dependent on the order of
the words), and a semantic interpretation. Since
no derivations are equivalent if they produce a dif-
ferent sequence of words, derivation reduction must
always preserve word order.
Normal Form and Proof-Reduction
in Combinatory Grammar
Consider a combinatory grammar containing
the application rules, Forward Composition, and
also Subject Type-Raising (24); the latter two en-
able association of a subject with an incomplete
verb phrase; this is required in (25), as shown in
(26).
</bodyText>
<figure confidence="0.729106555555556">
(24) Subject Type-Raising (&gt;T)
T: NP S/(S\NP) (where T yx= x y)
(25) a. [John likes and Mary loves] opera
b. the man who John likes
(26) John likes
NP S\NP/NP
—&gt;T
SAS\NP)
S/NP
</figure>
<bodyText confidence="0.942359666666667">
This grammar will allow many equivalent
derivations, but consider the following contraction
rules:
</bodyText>
<figure confidence="0.9710856">
&gt;B
- 14 -
(27) a. X/Y Y/Z Z X/Y Y/Z Z
&gt;B &gt;
X/Z pi Y
&gt;
x x
(f (B x y) z) = (f x (f y z))
b. X/Y Y/Z Z/W X/Y Y/Z Z/W
&gt;8 &gt;B
X/Z l&gt;2 Y/W
&gt;B &gt;B
X/W X/W
(B (B x y) z) = (B x (B y z))
(f (T x) y) = (b x y)
</figure>
<bodyText confidence="0.993186727272727">
Each contraction rule states that a derivation
containing an occurrence of the redex can be trans-
formed into an equivalent one in which the occur-
rence is replaced by the contractum. To see that
the rules are valid, note that in each contraction
rule constituent order is preserved, and that the
determination of the root meaning in terms of the
daughter meanings is (extensionally) equivalent un-
der the functional interpretation of the combina-
tors.
Observe by analogy with combinatory logic that
a derivation can be regarded as a proof over the
language of categories, and that the derivation-
reduction defined above is a proof-reduction. So
far as we are aware, the relations of reduction and
equality generated observe the C-R corollaries that
distinct normal forms are non-equal, and that nor-
mal forms are unique. We provide the following
reasoning to the effect that SN holds.
Assign to each derivation a score, depending on
its binary and unary branching tree structure as
follows:
</bodyText>
<listItem confidence="0.663736833333333">
(28) a. An elementary tree has score 1
b. If a left subtree has score z and a right subtree has
score y, the binary-branching tree formed from
them has score 2z + y
c. If a subtree has score z then a unary-branching
tree formed from it has score 2z
</listItem>
<bodyText confidence="0.999686892857143">
All derivations will have a finite score of at least 1.
Consider the scores for the redex and contractum in
each of the above. Let x, y, and z be the scores for
the subtrees dominated by the leaves in left-to-right
order. For Pi, the score of the redex is 2(2x+y)+z
and that of its contractum is 2x + (2y+ z): a decre-
ment of 2x, and this is always non-zero because all
scores are at leatit 1. The case of 1&gt;2 is the same.
In 1&gt;3 the score of the redex is 2(2x) + y, that of
the contractum 2x+ y: also a proper decrement. So
all reductions are finite, and there is the corollary
that all derivations have normal forms.
Since all derivations have normal forms, we can
safely limit attention in parsing to normal form
derivations: for all the derivations excluded, there
is an equivalent normal form which is not excluded.
If not all derivations had normal forms, limitation
to normal forms might lose those derivations in the
grammar which do not have normal forms. The
strategy to avoid unnecessary work can be to dis-
continue any derivation that contains a redex. The
test is neutral as to whether the parsing algorithm
is, e.g. top-down or bottom-up.
The seven derivations of John will see Mary in
the grammar are shown below. Each occurrence of
a redex is marked with a correspondingly labelled
asterisk. It will be seen that of the seven logical
possibilities, only one is now licensed:
</bodyText>
<figure confidence="0.981905925">
(29) a. John will see Mary
— —
NP VP/VP VP/NP NP
&gt;
VP
VP
S
b. John will see Mary
—
NP* VP/VP VP/NP NP
&gt;B
S
c. John will see Mary
—
NP VP/VP VP/NP NP
—&gt;T
*2(S/VP
B,)
c. NP S\NP NP S\NP
—T
SAS\NP) Ds S
&gt;
S
-
1(
VP/NP
VP
&lt;
)
-
B
....
IS/VP
S/NP
S
- 15 -
(32) will give
VP/VP VP/PP/NP
&gt;B2
VP/PP/NP
</figure>
<bodyText confidence="0.983772333333333">
We may accompany the adoption of this rule wit],
replacement of the contraction rule (27b) by thc
following generalised version:
</bodyText>
<figure confidence="0.989645088235294">
d. John will
— —
*q/ NP VP/VP /NP NP
—&gt;T
S/VP
will see Mary
NP VP/V- P VP/NP NP
&gt;T &gt;B
*i.(S/VP
S/NP
SVP/NP
&gt;B
&gt;)
e. John
see Mab
(33) a. X/Y Y/Zi • • ./Zni,BZningWi•••/Wn
Y/Zr • -/Zitt
&gt;B&amp;quot;
X/Zi- ./Zm-i/W1- • IWn
f. John will see Mary
— —
43/NP *1 VP/VP VP/NP NP
&gt;B
S/VP I VP/NP
VP
g. John will see Mary
— —
NP VP/VP VP/NP NP
—&gt;T ---)
----&gt;g
S/VP VP )
&gt;
(
*1 S/VP
</figure>
<bodyText confidence="0.976817">
The derivations are related by the contraction
relation as follows:
Consider now the combinatory grammar ob-
tained by replacing Forward Composition by
the Generalised Forward Composition rule (31a),
whose semantics Bn is recursively defined in terms
of B as shown in (31b).
</bodyText>
<page confidence="0.515707">
(31) a. Generalised Forward Composition (&gt;B&amp;quot;):
</page>
<figure confidence="0.516480636363636">
X/Y Y/Zi• -/Zn X/Zi• •./Zn
b. B1 = B; B&amp;quot;+1 = BBB&amp;quot;, n&gt; 1
This rule allows for combinations such as the fol-
lowing:
X/Y Y/Zr -/Zin Zin/Wr • ./Wn
&gt;13^
Y/Zr • •/Zm-1 /Wi • • IWn
&gt;B1&amp;quot;+&amp;quot;-1
X/Zi•–/Zni_i/Wr -/Wn
b. (B&amp;quot; (Bm x y) a) = (B(&apos;+&amp;quot;-1) x (B&amp;quot; y a))
for n &gt; 1; in &gt; 1
</figure>
<bodyText confidence="0.993305761904762">
It will be seen that (33a) has (27b) as the specia
case n = 1, m = 1. Furthermore, if we admit ;
combinator Be which is equivalent to the combi
nator f, and use this as the semantics for Forwarc
Application, we can extend the generalised contrac
tion rule (33) to have (27a) as a special case als■
(by allowing the values for m and n to be such tha
n &gt; 0; m &gt; 1). It will be seen that again, ever,
contraction results in a proper decrement of th
score assigned, so that SN holds.
In Morrill (1988) it is argued at length that eve]
rules like generalised forward composition are no
adequate to characterise the full range of extra(
tion and coordination phenomena, and that deepe
generalisations need to be expressed. In particulai
a system is advocated in which more complex rule
are derived from the basic rules of application b
the use of metarules, like that in (34); these are sim
ilar to those of Gazdar (1981), but with slash intei
preted as the categorial operator (see also Geact
1972, p485; Moqrtgat, 1987, p18).
</bodyText>
<table confidence="0.83314888">
(34) Right Abstraction
Rik: X + Y/Z V/Z
(where (ft g x y) a = g x (y a) )
Note for instance that applying Right Abstractio
to Forward Application yields Steedman&apos;s Forwar
Composition primitive, and that successive appli
cation yields higher order compositions:
- 16 -
(35) a. Rf: X/Y + Y/Z =. X/Z (39) a. John will see Mary
b. R(Rf): X/Y + Y/Z/W #. X/Z/W — — NP
NP VP/VP VP/NP Rf
Rb
S/VP
Applying Right Abstraction to Backward Applica-
tion yields a combinator capable of assembling a
subject and incomplete verb phrase, without first
type-raising the subject:
S/NP
f
S
(36) a. Rb: Y + X\ Y/Z =. X/Z
b. John likes
NP S \NP/NP
Rb
S/NP
</table>
<bodyText confidence="0.999744">
(Note that for this approach, the labelling for a rule
used in a derivation is precisely the combinator that
forms the semantics for that rule.)
Consider a grammar with just the applica-
tion rules and Right Abstraction. Let Rn0 be
R(... R(0)... ) with n &gt; 0 occurrences of R. In-
stead of the contraction rules earlier we may have:
</bodyText>
<figure confidence="0.4802384">
(37) a. X Y/Z Z/Wi• • &amp;quot;Wu
Rnf
WW1&apos; —/Wn
Suppose we now assign scores as follows:
(38) a. An elementary tree has score 1
</figure>
<figureCaption confidence="0.217867">
b. If a left subtree has score x and a right subtree has
score y, the binary-branching tree formed from
them has score x + 2y
</figureCaption>
<bodyText confidence="0.985946666666667">
The score of a redex will be x+ 2(y+ 2z) and that of
its contractum (x + 2y) + 2z: a proper decrement,
so SN holds and all derivations have normal forms
as before. For the sentence John will see Mary,
the grammar allows the set of derivations shown in
(39).
</bodyText>
<figure confidence="0.94669445">
b. John will see Mary
— —
NPVP/VP VP/NP NP
7(
c. John
*MP
■ S/NP
d. John will see Mary
— —
NP VP/VP VP/NP NP
Rf
*( VP/NP
S
will see Mary
— —
N S/VP
VP/VP VP/NP NP )
Rb
VP
f
</figure>
<bodyText confidence="0.952437">
As before, we can see that only one derivation,
(39b), contains no redexes, and it is thus the only
admissible normal form derivation. The derivations
are related by the contraction relation as follows:
(40) b ____._ d
</bodyText>
<sectionHeader confidence="0.958132" genericHeader="conclusions">
Conclusion
</sectionHeader>
<bodyText confidence="0.999987285714286">
We have offered a solution to the problem of
parsing and derivational equivalence by introduc-
ing a notion of normal-form derivation. A defini-
tion of redex can be used to avoid computing non-
normal form derivations. Computing only normal
form derivations is safe provided every non-normal
form derivation has a normal form equivalent. By
</bodyText>
<figure confidence="0.990111115384615">
Rn0
WW1- • &amp;quot;Wu
X Y/Z Z/Wi • • ./Wn
R0
c.„,.
VIZ
WW1&apos; • liVn
b. (Rn# X (Rnf y a)) = (Rnf (R0 x y) a)
Rnf
VP
b
VP)
will see Mary
— —
VP/VP VP/NP NP
Rf
VP/NP
Rb
f
S
)
VP
b
e. John
S
- 17 -
</figure>
<bodyText confidence="0.999609636363636">
demonstrating strong normalisation for the exam-
ples given, we have shown that every derivation
does have a normal form, and that consequently
parsing with this method is complete in the sense
that at least one member of each equivalence class
is computed. In addition, it would be desirable
to show that the Church-Rosser property holds, to
guarantee that each equivalence class has a unique
normal form. This would ensure that parsing with
this method is optimal in the sense that for each
equivalence class, only one derivation is computed.
</bodyText>
<sectionHeader confidence="0.999412" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.994027262295082">
Ades, A. and Steedman, M. J. 1982. On the Or-
der of Words. Linguistics and Philosophy, 4: 517-
558.
Curry, H. B. and Feys, R. 1958. Combinatory
logic, Volume I. North Holland, Amsterdam.
Curry, H. B., Hindley, J. R. and Seldin, J. P.
1972. Combinatory logic, Volume II. North Hol-
land, Amsterdam.
Gazdar, G. 1981. Unbounded dependencies and
coordinate structure. Linguistic Inquiry, 12: 155-
184.
Geach, P. T. 1972. A program for syntax. In
Davidson, D. and Harman, G. (eds.) Semantics of
Natural Language. Dordrecht: D. Reidel.
Hindley, J. R. and Seldin, J. P. 1986. Intro-
duction to combinators and A-calculus. Cambridge
University Press, Cambridge.
Hepple, M. 1987. Methods for Parsing Com-
binatory Grammars and the Spurious Ambiguity
Problem. Masters Thesis, Centre for Cognitive Sci-
ence, University of Edinburgh.
Karttunen, L. 1986. Radical Lexicalism. Re-
port No. CSLI-86-68, Center for the Study of Lan-
guage and Information, December, 1986. Paper
presented at the Conference on Alternative Con-
ceptions of Phrase Structure, July 1986, New York.
Moortgat, M. 1987. Lambek Categorial Gram-
mar and the Autonomy Thesis. INL Working Pa-
pers No. 87-03, Instituut voor Nederlandse Lexi-
cologie, Leiden, April, 1987.
Morrill, G. 1988. Extraction and Coordina-
tion in Phrase Structure Grammar and Categorial
Grammar. PhD Thesis, Centre for Cognitive Sci-
ence, University of Edinburgh.
Morrill, G. and Carpenter, B. 1987. Compo-
sitionality, Implicational Logics, and Theories of
Grammar. Research Paper No. EUCCS/RP-11,
Centre for Cognitive Science, University of Edin-
burgh, Edinburgh, June, 1987. To appear in Lin-
guistics and Philosophy.
Pareschi, R. and Steedman, M. J. 1987. A
Lazy Way to Chart-Parse with Extended Catego-
rial Grammars. In Proceedings of the 25th An-
nual Meeting of the Association for Computational
Linguistics, Stanford University, Stanford, Ca., 6-9
July, 1987.
Prawitz, D. 1965. Natural Deduction: A Proof-
Theoretical Study. Almqvist and Wiksell, Uppsala.
Steedman, M. 1985. Dependency and Coordi-
nation in the Grammar of Dutch and English. Lan-
guage, 61: 523-568.
Steedman, M. 1987. Combinatory Grammars
and Parasitic Gaps. Natural Language and Lin-
guistic Theory, 5: 403-439.
Wittenburg, K. 1987. Predictive Combinators:
a Method for Efficient Processing of Combinatory
Categorial Grammar. In Proceedings of the 25th
Annual Meeting of the Association for Computa-
tional Linguistics, Stanford University, Stanford,
Ca., 6-9 July, 1987.
- 18 -
</reference>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.851991">
<title confidence="0.998482">AND DERIVATIONAL</title>
<author confidence="0.999987">Mark Hepple</author>
<author confidence="0.999987">Glyn Morrill</author>
<affiliation confidence="0.999944">Centre for Cognitive Science, University of Edinburgh</affiliation>
<address confidence="0.896445">2 Buccleuch Place, Edinburgh EH8 9LW Scotland</address>
<abstract confidence="0.997421736842105">It is a tacit assumption of much linguistic inquiry that all distinct derivations of a string should assign distinct meanings. But despite the tidiness of such derivational uniqueness, there seems to be no a priori reason to assume that a grammar must have this property. If a grammar exhibits derivational equivalence, whereby distinct derivations of a string assign the same meanings, naive exhaustive search for all derivations will be redundant, and quite possibly intractable. In this paper we show how notions of derivation-reduction and normal form can be used to avoid unnecessary work while parsing with grammars exhibiting derivational equivalence. With grammar regarded as analogous to logic, derivations are proofs; what we are advocating is proof-reduction, and normal form proof; the invocation of these logical techniques adds a further paragraph to the story of parsing-as-deduction.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>A Ades</author>
<author>M J Steedman</author>
</authors>
<title>On the Order of Words.</title>
<date>1982</date>
<journal>Linguistics and Philosophy,</journal>
<volume>4</volume>
<pages>517--558</pages>
<contexts>
<context position="6679" citStr="Ades and Steedman, 1982" startWordPosition="1135" endWordPosition="1138">is a CG-term of category Xo. The interpretation of a term built by (7b) is given by the functional application of the combinator to the sub-term interpretations in left-to-right order. A verb phrase containing an auxiliary can be derived as in (8) (throughout, VP abbreviates S \NP). The meaning assigned is given by (9a), which is equal to (9b). (5) will see John — — VP/VP VP/NP NP &gt; VP VP (9) a. (f will&apos; (f see&apos; John&apos;)) b. will&apos; (see&apos; John&apos;) Suppose the grammar is augmented with a rule of functional composition (10), as is claimed to be appropriate for analysis of extraction and coordination (Ades and Steedman, 1982; Steedman, 1985). Then for example, the right hand conjunct in (11a) can be analysed as shown in (11b). b. C. requires comparison with every edge spanning the relevant region, checking time increases with the number of such edges. (10) Forward Composition (&gt;B) B: X/Y Y/Z X/Z (where Bxyz=x (y z)) (11) a. Mary [phoned and will see] John b. will see VP/VP VP/NP &gt;B VP/NP Forward Application of (11b) to John will assign meaning (12) which is again equal to (9b), and this is appropriate because will see John is unambiguous. (12) (f (B will&apos; see&apos;) John&apos;) However the grammar now exhibits derivational</context>
</contexts>
<marker>Ades, Steedman, 1982</marker>
<rawString>Ades, A. and Steedman, M. J. 1982. On the Order of Words. Linguistics and Philosophy, 4: 517-558.</rawString>
</citation>
<citation valid="true">
<authors>
<author>H B Curry</author>
<author>R Feys</author>
</authors>
<title>Combinatory logic, Volume I. North Holland,</title>
<date>1958</date>
<location>Amsterdam.</location>
<contexts>
<context position="3059" citStr="Curry and Feys, 1958" startWordPosition="472" endWordPosition="475">tion. Then sentences such as John met a man yesterday who swims will be generated. But it is probable that the same grammar will assign John met a man who swims a right extraposition derivation in which the relative clause happens to occupy its normal position in the string; the normal and right extraposition derivations generate the same strings with the same meanings, so there is derivational equivalence. Note that a single equivalence of this kind in a grammar undermines a methodological assumption of derivational uniqueness. Combinatory Logic and Combinatory Grammar Combinatory logic (CL; Curry and Feys, 1958; Curry, Hindley and Seldin, 1972; Hindley and Seldin, 1986) refers to systems which are applicative, like the lambda-calculi, but which formalise functional abstraction through a small number of basic `combinators&apos;, rather than through a variable-binding operator like A. We will define a typed combinatory logic. Assume a set of basic types, say e and t. Then the set of types is defined as follows: (1) a. If A is a basic type then A is a type b. If A and B are types then A--■13 is a type A convention of right-associativity will be used for types, so that e.g. (e---4)--+(e-4) may be writ- 10 - </context>
</contexts>
<marker>Curry, Feys, 1958</marker>
<rawString>Curry, H. B. and Feys, R. 1958. Combinatory logic, Volume I. North Holland, Amsterdam.</rawString>
</citation>
<citation valid="true">
<authors>
<author>H B Curry</author>
<author>J R Hindley</author>
<author>J P Seldin</author>
</authors>
<title>Combinatory logic, Volume II.</title>
<date>1972</date>
<publisher>North</publisher>
<location>Holland, Amsterdam.</location>
<marker>Curry, Hindley, Seldin, 1972</marker>
<rawString>Curry, H. B., Hindley, J. R. and Seldin, J. P. 1972. Combinatory logic, Volume II. North Holland, Amsterdam.</rawString>
</citation>
<citation valid="true">
<authors>
<author>G Gazdar</author>
</authors>
<title>Unbounded dependencies and coordinate structure.</title>
<date>1981</date>
<journal>Linguistic Inquiry,</journal>
<volume>12</volume>
<pages>155--184</pages>
<contexts>
<context position="22956" citStr="Gazdar (1981)" startWordPosition="4111" endWordPosition="4112">allowing the values for m and n to be such tha n &gt; 0; m &gt; 1). It will be seen that again, ever, contraction results in a proper decrement of th score assigned, so that SN holds. In Morrill (1988) it is argued at length that eve] rules like generalised forward composition are no adequate to characterise the full range of extra( tion and coordination phenomena, and that deepe generalisations need to be expressed. In particulai a system is advocated in which more complex rule are derived from the basic rules of application b the use of metarules, like that in (34); these are sim ilar to those of Gazdar (1981), but with slash intei preted as the categorial operator (see also Geact 1972, p485; Moqrtgat, 1987, p18). (34) Right Abstraction Rik: X + Y/Z V/Z (where (ft g x y) a = g x (y a) ) Note for instance that applying Right Abstractio to Forward Application yields Steedman&apos;s Forwar Composition primitive, and that successive appli cation yields higher order compositions: - 16 - (35) a. Rf: X/Y + Y/Z =. X/Z (39) a. John will see Mary b. R(Rf): X/Y + Y/Z/W #. X/Z/W — — NP NP VP/VP VP/NP Rf Rb S/VP Applying Right Abstraction to Backward Application yields a combinator capable of assembling a subject an</context>
</contexts>
<marker>Gazdar, 1981</marker>
<rawString>Gazdar, G. 1981. Unbounded dependencies and coordinate structure. Linguistic Inquiry, 12: 155-184.</rawString>
</citation>
<citation valid="true">
<authors>
<author>P T Geach</author>
</authors>
<title>A program for syntax.</title>
<date>1972</date>
<booktitle>Semantics of Natural Language.</booktitle>
<editor>In Davidson, D. and Harman, G. (eds.)</editor>
<location>Dordrecht:</location>
<marker>Geach, 1972</marker>
<rawString>Geach, P. T. 1972. A program for syntax. In Davidson, D. and Harman, G. (eds.) Semantics of Natural Language. Dordrecht: D. Reidel.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J R Hindley</author>
<author>J P Seldin</author>
</authors>
<title>Introduction to combinators and A-calculus.</title>
<date>1986</date>
<publisher>Cambridge University Press,</publisher>
<location>Cambridge.</location>
<contexts>
<context position="3119" citStr="Hindley and Seldin, 1986" startWordPosition="481" endWordPosition="484">ho swims will be generated. But it is probable that the same grammar will assign John met a man who swims a right extraposition derivation in which the relative clause happens to occupy its normal position in the string; the normal and right extraposition derivations generate the same strings with the same meanings, so there is derivational equivalence. Note that a single equivalence of this kind in a grammar undermines a methodological assumption of derivational uniqueness. Combinatory Logic and Combinatory Grammar Combinatory logic (CL; Curry and Feys, 1958; Curry, Hindley and Seldin, 1972; Hindley and Seldin, 1986) refers to systems which are applicative, like the lambda-calculi, but which formalise functional abstraction through a small number of basic `combinators&apos;, rather than through a variable-binding operator like A. We will define a typed combinatory logic. Assume a set of basic types, say e and t. Then the set of types is defined as follows: (1) a. If A is a basic type then A is a type b. If A and B are types then A--■13 is a type A convention of right-associativity will be used for types, so that e.g. (e---4)--+(e-4) may be writ- 10 - ten (e--,t)-----4. There is a set of constants (say, John&apos;, </context>
<context position="15693" citStr="Hindley and Seldin, 1986" startWordPosition="2772" endWordPosition="2775">the type schemes of the basic combinators in (2), together with a modus ponens rule corresponding to the application in (3b), provide an axiomatisation of relevant implication (see Morrill and Carpenter, 1987, for discussion in relation to grammar): (20) a. A-,A (B-.4C)-■(A--+B)--.A-■C (A-03--■C)-■(B-■A-■C) b. B-&apos;A B A Consider the typed CL-terms in (4). For each of these, the tree of type formulae is a proof in implicational relevance logic. Corresponding to the term-reduction and normal form in (19), there is proof-reduction and a normal form for a proof over the language of types (see e.g. Hindley and Seldin, 1986). There can be proof-contraction rules such as the following: (21) B N M P (B--4C)--*(A-+B)--■A-■C B--+C A-al A (A-03)-■A-0C A-+C N M P B--■C A-413 A Proof-reduction originated with Prawitz (1965) and is now a standard technique in logic. The suggestion of this paper is that if parse trees labelled with categories can be regarded as proofs over the language of categories, then the problem of parsing and derivational equivalence can be treated on the pattern of proof-reduction. Before proceeding to the grammar cases, a couple of remarks are in order. The equivalence addressed by the reductions </context>
</contexts>
<marker>Hindley, Seldin, 1986</marker>
<rawString>Hindley, J. R. and Seldin, J. P. 1986. Introduction to combinators and A-calculus. Cambridge University Press, Cambridge.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Hepple</author>
</authors>
<title>Methods for Parsing Combinatory Grammars and the Spurious Ambiguity Problem.</title>
<date>1987</date>
<tech>Masters Thesis,</tech>
<institution>Centre for Cognitive Science, University of Edinburgh.</institution>
<contexts>
<context position="8192" citStr="Hepple (1987)" startWordPosition="1386" endWordPosition="1387">nary trees; this is given by the Catalan series, which is such that Catalan(n) &gt; 2n-2. As well as it being inefficient to search through derivations which are equivalent, the exponential figure signifies computational intractability. Several suggestions have been made in relation to this problem. Pareschi and Steedman (1987) describe what they call a &apos;lazy chart parser&apos; intended to yield only one of each set of equivalent analyses by adopting a reduce-first parsing strategy, and invoking a special recovery procedure to avoid the backtracking that this strategy would otherwise necessitate. But Hepple (1987) shows that their algorithm is incomplete. Wittenburg (1987) presents an approach in which a combinatory grammar is compiled into one not exhibiting derivational equivalence. Such compilation seeks to avoid the problem of parsing with a grammar exhibiting derivational equivalence by arranging that the grammar used on-line does not have this property. The concern here however is management of parsing when the grammar used on-line does have the problematic property. Karttunen (1986) suggests a strategy in which every potential new edge is tested against the chart to see whether an existing analy</context>
</contexts>
<marker>Hepple, 1987</marker>
<rawString>Hepple, M. 1987. Methods for Parsing Combinatory Grammars and the Spurious Ambiguity Problem. Masters Thesis, Centre for Cognitive Science, University of Edinburgh.</rawString>
</citation>
<citation valid="true">
<authors>
<author>L Karttunen</author>
</authors>
<title>Radical Lexicalism. Report No. CSLI-86-68, Center for the Study of Language and Information,</title>
<date>1986</date>
<booktitle>Paper presented at the Conference on Alternative Conceptions of Phrase Structure,</booktitle>
<location>New York.</location>
<contexts>
<context position="8677" citStr="Karttunen (1986)" startWordPosition="1459" endWordPosition="1460">d invoking a special recovery procedure to avoid the backtracking that this strategy would otherwise necessitate. But Hepple (1987) shows that their algorithm is incomplete. Wittenburg (1987) presents an approach in which a combinatory grammar is compiled into one not exhibiting derivational equivalence. Such compilation seeks to avoid the problem of parsing with a grammar exhibiting derivational equivalence by arranging that the grammar used on-line does not have this property. The concern here however is management of parsing when the grammar used on-line does have the problematic property. Karttunen (1986) suggests a strategy in which every potential new edge is tested against the chart to see whether an existing analysis spanning the same region is equivalent. If one is found, the new analysis is discarded. However, because this check The solution we offer is one in which there ie a notion of normal form derivation, and a set ol contraction rules which reduce derivations to theh normal forms, normal form derivations being those to which no contraction rule can apply. The con. traction rules might be used in a number of ways (e.g. to transform one derivation into another, rather than recompute </context>
</contexts>
<marker>Karttunen, 1986</marker>
<rawString>Karttunen, L. 1986. Radical Lexicalism. Report No. CSLI-86-68, Center for the Study of Language and Information, December, 1986. Paper presented at the Conference on Alternative Conceptions of Phrase Structure, July 1986, New York.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Moortgat</author>
</authors>
<title>Lambek Categorial Grammar and the Autonomy Thesis. INL Working Papers No. 87-03, Instituut voor Nederlandse Lexicologie,</title>
<date>1987</date>
<location>Leiden,</location>
<marker>Moortgat, 1987</marker>
<rawString>Moortgat, M. 1987. Lambek Categorial Grammar and the Autonomy Thesis. INL Working Papers No. 87-03, Instituut voor Nederlandse Lexicologie, Leiden, April, 1987.</rawString>
</citation>
<citation valid="true">
<authors>
<author>G Morrill</author>
</authors>
<title>Extraction and Coordination in Phrase Structure Grammar and Categorial Grammar.</title>
<date>1988</date>
<tech>PhD Thesis,</tech>
<institution>Centre for Cognitive Science, University of Edinburgh.</institution>
<contexts>
<context position="2108" citStr="Morrill, 1988" startWordPosition="323" endWordPosition="324"> grammars using a combinatory logic (as opposed to say, lambda-calculus) semantics. In particular we consider combinatory (categorial) grammars with rules and generalised rules • We thank Mike Reape for criticism and suggestions in relation to this material, and Inge Bethke and Hank Zeevat for reading a late draft. All errors are our own. The work was carried out by the alphabetically first author under ESRC Postgraduate Award C00428722003 and by the second under ESRC Postgraduate Award C00428522008 and an SERC Postdoctoral Fellowship in IT. of the kind of Steedman (1987), and with metarules (Morrill, 1988). Although the problem of derivational equivalence is most apparent in generalised categorial grammars, the problem is likely to recur in many grammars characterising a full complement of constructions. For example, suppose that a grammar is capable of characterising right extraposition of an object&apos;s adjunct to clause-final position. Then sentences such as John met a man yesterday who swims will be generated. But it is probable that the same grammar will assign John met a man who swims a right extraposition derivation in which the relative clause happens to occupy its normal position in the s</context>
<context position="22538" citStr="Morrill (1988)" startWordPosition="4040" endWordPosition="4041">Y/Zr • •/Zm-1 /Wi • • IWn &gt;B1&amp;quot;+&amp;quot;-1 X/Zi•–/Zni_i/Wr -/Wn b. (B&amp;quot; (Bm x y) a) = (B(&apos;+&amp;quot;-1) x (B&amp;quot; y a)) for n &gt; 1; in &gt; 1 It will be seen that (33a) has (27b) as the specia case n = 1, m = 1. Furthermore, if we admit ; combinator Be which is equivalent to the combi nator f, and use this as the semantics for Forwarc Application, we can extend the generalised contrac tion rule (33) to have (27a) as a special case als■ (by allowing the values for m and n to be such tha n &gt; 0; m &gt; 1). It will be seen that again, ever, contraction results in a proper decrement of th score assigned, so that SN holds. In Morrill (1988) it is argued at length that eve] rules like generalised forward composition are no adequate to characterise the full range of extra( tion and coordination phenomena, and that deepe generalisations need to be expressed. In particulai a system is advocated in which more complex rule are derived from the basic rules of application b the use of metarules, like that in (34); these are sim ilar to those of Gazdar (1981), but with slash intei preted as the categorial operator (see also Geact 1972, p485; Moqrtgat, 1987, p18). (34) Right Abstraction Rik: X + Y/Z V/Z (where (ft g x y) a = g x (y a) ) N</context>
</contexts>
<marker>Morrill, 1988</marker>
<rawString>Morrill, G. 1988. Extraction and Coordination in Phrase Structure Grammar and Categorial Grammar. PhD Thesis, Centre for Cognitive Science, University of Edinburgh.</rawString>
</citation>
<citation valid="true">
<authors>
<author>G Morrill</author>
<author>B Carpenter</author>
</authors>
<title>Compositionality, Implicational Logics, and Theories of Grammar.</title>
<date>1987</date>
<tech>Research Paper No. EUCCS/RP-11,</tech>
<institution>Centre for Cognitive Science, University of Edinburgh,</institution>
<location>Edinburgh,</location>
<note>To appear in Linguistics and Philosophy.</note>
<contexts>
<context position="15276" citStr="Morrill and Carpenter, 1987" startWordPosition="2704" endWordPosition="2707"> of a term is unchanged by substitution of a subterm for an occurrence of a subterm with the same interpretation. An example of reduction of a term to its normal form is as follows: - 13 - (19) C I John&apos; (B probably&apos; walks&apos;) I&gt; I (B probably&apos; walks&apos;) John&apos; D B probably&apos; walks&apos; John&apos; D probably&apos; (walks&apos; John&apos;) Returning to emphasise types, observe that they can be regarded as formulae of implicational logic. In fact the type schemes of the basic combinators in (2), together with a modus ponens rule corresponding to the application in (3b), provide an axiomatisation of relevant implication (see Morrill and Carpenter, 1987, for discussion in relation to grammar): (20) a. A-,A (B-.4C)-■(A--+B)--.A-■C (A-03--■C)-■(B-■A-■C) b. B-&apos;A B A Consider the typed CL-terms in (4). For each of these, the tree of type formulae is a proof in implicational relevance logic. Corresponding to the term-reduction and normal form in (19), there is proof-reduction and a normal form for a proof over the language of types (see e.g. Hindley and Seldin, 1986). There can be proof-contraction rules such as the following: (21) B N M P (B--4C)--*(A-+B)--■A-■C B--+C A-al A (A-03)-■A-0C A-+C N M P B--■C A-413 A Proof-reduction originated with P</context>
</contexts>
<marker>Morrill, Carpenter, 1987</marker>
<rawString>Morrill, G. and Carpenter, B. 1987. Compositionality, Implicational Logics, and Theories of Grammar. Research Paper No. EUCCS/RP-11, Centre for Cognitive Science, University of Edinburgh, Edinburgh, June, 1987. To appear in Linguistics and Philosophy.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Pareschi</author>
<author>M J Steedman</author>
</authors>
<title>A Lazy Way to Chart-Parse with Extended Categorial Grammars.</title>
<date>1987</date>
<booktitle>In Proceedings of the 25th Annual Meeting of the Association for Computational Linguistics,</booktitle>
<pages>6--9</pages>
<location>Stanford University, Stanford, Ca.,</location>
<contexts>
<context position="7905" citStr="Pareschi and Steedman (1987)" startWordPosition="1337" endWordPosition="1340">al equivalence, with different derivations assigning the same meaning. In general a sequence Ai/A2+A2/A3+A3/A4+. • +An can be analysed as Al with the same meaning by combining any pair of adjacent elements at each step. Thus there are a number of equivalent derivations equal to the number of n-leaf binary trees; this is given by the Catalan series, which is such that Catalan(n) &gt; 2n-2. As well as it being inefficient to search through derivations which are equivalent, the exponential figure signifies computational intractability. Several suggestions have been made in relation to this problem. Pareschi and Steedman (1987) describe what they call a &apos;lazy chart parser&apos; intended to yield only one of each set of equivalent analyses by adopting a reduce-first parsing strategy, and invoking a special recovery procedure to avoid the backtracking that this strategy would otherwise necessitate. But Hepple (1987) shows that their algorithm is incomplete. Wittenburg (1987) presents an approach in which a combinatory grammar is compiled into one not exhibiting derivational equivalence. Such compilation seeks to avoid the problem of parsing with a grammar exhibiting derivational equivalence by arranging that the grammar us</context>
</contexts>
<marker>Pareschi, Steedman, 1987</marker>
<rawString>Pareschi, R. and Steedman, M. J. 1987. A Lazy Way to Chart-Parse with Extended Categorial Grammars. In Proceedings of the 25th Annual Meeting of the Association for Computational Linguistics, Stanford University, Stanford, Ca., 6-9 July, 1987.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D Prawitz</author>
</authors>
<title>Natural Deduction: A ProofTheoretical Study. Almqvist and Wiksell,</title>
<date>1965</date>
<location>Uppsala.</location>
<contexts>
<context position="15889" citStr="Prawitz (1965)" startWordPosition="2805" endWordPosition="2806">7, for discussion in relation to grammar): (20) a. A-,A (B-.4C)-■(A--+B)--.A-■C (A-03--■C)-■(B-■A-■C) b. B-&apos;A B A Consider the typed CL-terms in (4). For each of these, the tree of type formulae is a proof in implicational relevance logic. Corresponding to the term-reduction and normal form in (19), there is proof-reduction and a normal form for a proof over the language of types (see e.g. Hindley and Seldin, 1986). There can be proof-contraction rules such as the following: (21) B N M P (B--4C)--*(A-+B)--■A-■C B--+C A-al A (A-03)-■A-0C A-+C N M P B--■C A-413 A Proof-reduction originated with Prawitz (1965) and is now a standard technique in logic. The suggestion of this paper is that if parse trees labelled with categories can be regarded as proofs over the language of categories, then the problem of parsing and derivational equivalence can be treated on the pattern of proof-reduction. Before proceeding to the grammar cases, a couple of remarks are in order. The equivalence addressed by the reductions above is not strong (extensional), but what is called weak equivalence. For example the following pairs (whose types have been omitted) are distinct weak normal forms, but are extensionally equiva</context>
</contexts>
<marker>Prawitz, 1965</marker>
<rawString>Prawitz, D. 1965. Natural Deduction: A ProofTheoretical Study. Almqvist and Wiksell, Uppsala.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Steedman</author>
</authors>
<title>Dependency and Coordination in the</title>
<date>1985</date>
<journal>Grammar of Dutch and English. Language,</journal>
<volume>61</volume>
<pages>523--568</pages>
<contexts>
<context position="6696" citStr="Steedman, 1985" startWordPosition="1139" endWordPosition="1140">Xo. The interpretation of a term built by (7b) is given by the functional application of the combinator to the sub-term interpretations in left-to-right order. A verb phrase containing an auxiliary can be derived as in (8) (throughout, VP abbreviates S \NP). The meaning assigned is given by (9a), which is equal to (9b). (5) will see John — — VP/VP VP/NP NP &gt; VP VP (9) a. (f will&apos; (f see&apos; John&apos;)) b. will&apos; (see&apos; John&apos;) Suppose the grammar is augmented with a rule of functional composition (10), as is claimed to be appropriate for analysis of extraction and coordination (Ades and Steedman, 1982; Steedman, 1985). Then for example, the right hand conjunct in (11a) can be analysed as shown in (11b). b. C. requires comparison with every edge spanning the relevant region, checking time increases with the number of such edges. (10) Forward Composition (&gt;B) B: X/Y Y/Z X/Z (where Bxyz=x (y z)) (11) a. Mary [phoned and will see] John b. will see VP/VP VP/NP &gt;B VP/NP Forward Application of (11b) to John will assign meaning (12) which is again equal to (9b), and this is appropriate because will see John is unambiguous. (12) (f (B will&apos; see&apos;) John&apos;) However the grammar now exhibits derivational equivalence, wit</context>
</contexts>
<marker>Steedman, 1985</marker>
<rawString>Steedman, M. 1985. Dependency and Coordination in the Grammar of Dutch and English. Language, 61: 523-568.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Steedman</author>
</authors>
<title>Combinatory Grammars and Parasitic Gaps.</title>
<date>1987</date>
<journal>Natural Language and Linguistic Theory,</journal>
<volume>5</volume>
<pages>403--439</pages>
<contexts>
<context position="2072" citStr="Steedman (1987)" startWordPosition="318" endWordPosition="319">y reference to generalised categorial grammars using a combinatory logic (as opposed to say, lambda-calculus) semantics. In particular we consider combinatory (categorial) grammars with rules and generalised rules • We thank Mike Reape for criticism and suggestions in relation to this material, and Inge Bethke and Hank Zeevat for reading a late draft. All errors are our own. The work was carried out by the alphabetically first author under ESRC Postgraduate Award C00428722003 and by the second under ESRC Postgraduate Award C00428522008 and an SERC Postdoctoral Fellowship in IT. of the kind of Steedman (1987), and with metarules (Morrill, 1988). Although the problem of derivational equivalence is most apparent in generalised categorial grammars, the problem is likely to recur in many grammars characterising a full complement of constructions. For example, suppose that a grammar is capable of characterising right extraposition of an object&apos;s adjunct to clause-final position. Then sentences such as John met a man yesterday who swims will be generated. But it is probable that the same grammar will assign John met a man who swims a right extraposition derivation in which the relative clause happens to</context>
<context position="7905" citStr="Steedman (1987)" startWordPosition="1339" endWordPosition="1340">e, with different derivations assigning the same meaning. In general a sequence Ai/A2+A2/A3+A3/A4+. • +An can be analysed as Al with the same meaning by combining any pair of adjacent elements at each step. Thus there are a number of equivalent derivations equal to the number of n-leaf binary trees; this is given by the Catalan series, which is such that Catalan(n) &gt; 2n-2. As well as it being inefficient to search through derivations which are equivalent, the exponential figure signifies computational intractability. Several suggestions have been made in relation to this problem. Pareschi and Steedman (1987) describe what they call a &apos;lazy chart parser&apos; intended to yield only one of each set of equivalent analyses by adopting a reduce-first parsing strategy, and invoking a special recovery procedure to avoid the backtracking that this strategy would otherwise necessitate. But Hepple (1987) shows that their algorithm is incomplete. Wittenburg (1987) presents an approach in which a combinatory grammar is compiled into one not exhibiting derivational equivalence. Such compilation seeks to avoid the problem of parsing with a grammar exhibiting derivational equivalence by arranging that the grammar us</context>
</contexts>
<marker>Steedman, 1987</marker>
<rawString>Steedman, M. 1987. Combinatory Grammars and Parasitic Gaps. Natural Language and Linguistic Theory, 5: 403-439.</rawString>
</citation>
<citation valid="true">
<authors>
<author>K Wittenburg</author>
</authors>
<title>Predictive Combinators: a Method for Efficient Processing of Combinatory Categorial Grammar.</title>
<date>1987</date>
<booktitle>In Proceedings of the 25th Annual Meeting of the Association for Computational Linguistics,</booktitle>
<pages>6--9</pages>
<location>Stanford University, Stanford, Ca.,</location>
<contexts>
<context position="8252" citStr="Wittenburg (1987)" startWordPosition="1395" endWordPosition="1396">s such that Catalan(n) &gt; 2n-2. As well as it being inefficient to search through derivations which are equivalent, the exponential figure signifies computational intractability. Several suggestions have been made in relation to this problem. Pareschi and Steedman (1987) describe what they call a &apos;lazy chart parser&apos; intended to yield only one of each set of equivalent analyses by adopting a reduce-first parsing strategy, and invoking a special recovery procedure to avoid the backtracking that this strategy would otherwise necessitate. But Hepple (1987) shows that their algorithm is incomplete. Wittenburg (1987) presents an approach in which a combinatory grammar is compiled into one not exhibiting derivational equivalence. Such compilation seeks to avoid the problem of parsing with a grammar exhibiting derivational equivalence by arranging that the grammar used on-line does not have this property. The concern here however is management of parsing when the grammar used on-line does have the problematic property. Karttunen (1986) suggests a strategy in which every potential new edge is tested against the chart to see whether an existing analysis spanning the same region is equivalent. If one is found,</context>
</contexts>
<marker>Wittenburg, 1987</marker>
<rawString>Wittenburg, K. 1987. Predictive Combinators: a Method for Efficient Processing of Combinatory Categorial Grammar. In Proceedings of the 25th Annual Meeting of the Association for Computational Linguistics, Stanford University, Stanford, Ca., 6-9 July, 1987.</rawString>
</citation>
<citation valid="false">
<pages>18</pages>
<marker></marker>
<rawString>- 18 -</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>