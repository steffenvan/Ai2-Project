<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<title confidence="0.987637">
ProFIT: Prolog with Features, Inheritance and Templates
</title>
<author confidence="0.933098">
Gregor Erbach
</author>
<affiliation confidence="0.615788">
Universitat des Saarlandes
Computerlinguistik
</affiliation>
<address confidence="0.672121">
D-66041 Saarbriicken, Germany
</address>
<email confidence="0.757851">
e-mail: erbachecoli.uni-sb.de
URL: http : //col i uni-sb . der erbach/
</email>
<sectionHeader confidence="0.997166" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999229090909091">
ProFIT is an extension of Standard Pro-
log with Features, Inheritance and Tem-
plates. ProFIT allows the programmer
or grammar developer to declare an in-
heritance hierarchy, features and tem-
plates. Sorted feature terms can be used
in ProFIT programs together with Pro-
log terms to provide a clearer descrip-
tion language for linguistic structures.
ProFIT compiles all sorted feature terms
into a Prolog term representation, so
that the built-in Prolog term unification
can be used for the unification of sorted
feature structures, and no special uni-
fication algorithm is needed. ProFIT
programs are compiled into Prolog pro-
grams, so that no meta-interpreter is
needed for their execution. ProFIT thus
provides a direct step from grammars de-
veloped with sorted feature terms to Pro-
log programs usable for practical NLP
systems.
</bodyText>
<sectionHeader confidence="0.999471" genericHeader="keywords">
1 Introduction
</sectionHeader>
<bodyText confidence="0.995969">
There are two key ingredients for building an NLP
system:
</bodyText>
<listItem confidence="0.999908">
• a linguistic description
• a processing model (parser, generator etc.)
</listItem>
<bodyText confidence="0.999886777777778">
In the past decade, there have been diverging
trends in the area of linguistic descriptions and in
the area of processing models. Most large-scale
linguistic descriptions make use of sorted feature
formalisms,1 but implementations of these for-
malisms are in general too slow for building prac-
tically usable NLP systems. Most of the progress
in constructing efficient parsers and generators
has been based on logic grammars that make use
</bodyText>
<footnote confidence="0.969283">
1Sorted feature structures are sometimes referred
to as typed feature structures, e.g. in Carpenter&apos;s
&amp;quot;Logic of Typed Feature Structures.&amp;quot; We follow the
usage in Logic Programming and the recent HPSG
literature.
</footnote>
<bodyText confidence="0.999834142857143">
of ordinary Pfolog terms. We provide a general
tool that brings together these developments by
compiling sorted feature terms into a Prolog term
representation, so that techniques from logic pro-
gramming and logic grammars can be used to pro-
vide efficient processing models for sorted feature
grammars.
In this introductory section, we discuss the ad-
vantages of sorted feature formalisms, and of the
logic grammar paradigm, and show how the two
developments can be combined. The following
sections describe the ProFIT language which pro-
vides sorted feature terms for Prolog, and its im-
plementation.
</bodyText>
<subsectionHeader confidence="0.9875925">
1.1 Grammar Development in Sorted
Feature Formalisms
</subsectionHeader>
<bodyText confidence="0.999151833333333">
Sorted feature formalisms are often used for the
development of large-coverage grammars, because
they are very well suited for a structured descrip-
tion of complex linguistic data. Sorted feature
terms have several advantages over Prolog terms
as a representation langauge.
</bodyText>
<listItem confidence="0.987440454545454">
1. They provide a compact notation. Features
that are not instantiated can be omitted;
there is no need for anonymous variables.
2. Features names are mnemonic, argument po-
sitions are not.
3. Adding a new feature to a sort requires
one change in a declaration, whereas adding
an argument to a Prolog functor requires
changes (mostly insertion of anonymous vari-
ables) to every occurence of the functor.
4. Specification of the subsort relationship is
</listItem>
<bodyText confidence="0.9496342">
more convenient than constructing Prolog
terms which mirror these subsumption rela-
tionships.
Implementations of sorted feature formalisms
such as TDL (Krieger and Schafer, 1994), ALE
(Carpenter, 1993), CUF (DOrre and Dorna, 1993),
TFS (Emele and Zajac, 1990) and others have
been used successfully for the development and
testing of large grammars and lexicons, but they
may be too slow for actual use in applications
</bodyText>
<page confidence="0.994783">
180
</page>
<bodyText confidence="0.99994075">
because they are generally built on top of Pro-
log or LISP, and can therefore not be as efficient
as the built-in unification of Prolog. There are
a few logic programming langauges, such as LIFE
(Ait-Kaci and Lincoln, 1989) or Oz (Smolka et al.,
1995), that provide sorted feature terms, but no
commercial implementations of these languages
with efficient compilers are yet available.
</bodyText>
<sectionHeader confidence="0.655888" genericHeader="introduction">
1.2 Efficient Processing based on Logic
Grammars
</sectionHeader>
<bodyText confidence="0.971121">
Much work on efficient processing algorithms has
been done in the logic grammar framework. This
includes work on
</bodyText>
<listItem confidence="0.999593923076923">
• Compiling grammars into efficient parsers
and generators: compilation of DCGs into
(top-down) Prolog programs, left-corner
parsers (BUP), LR parsers, head-corner
parsers, and semantic-head driven genera-
tors.
• Use of meta-programming for self-monitoring
to ensure generation of unambiguous utter-
ances (Neumann and van Noord, 1992)
• Work in the area of Explanation-Based
Learning (EBL) to learn frequently used
structures (Samuelsson, 1994)
• Tabulation techniques, from the use of well-
formed substring tables to the latest devel-
opments in Earley deduction, and memoing
techniques for logic programming (Neumann,
1994)
• Work based on Constraint Logic Program-
ming (CLP) to provide processing models for
principle-based grammars (Matiasek, 1994)
• Using coroutining (dif, freeze etc.) to provide
more efficient processing models
• Partial deduction techniques to produce more
efficient grammars
• Using Prolog and its indexing facilities to
build up a lexicon database
</listItem>
<bodyText confidence="0.995144571428571">
Since much of this work involves compilation of
grammars into Prolog programs, such programs
can immediately benefit from any improvements
in Prolog compilers (for example the tabulation
provided by XSB Prolog can provide a more effi-
cient implementation of charts) which makes the
grammars more usable for NLP systems.
</bodyText>
<subsectionHeader confidence="0.994565">
1.3 Combining Logic Grammars and
Sorted Feature Formalisms
</subsectionHeader>
<bodyText confidence="0.999503909090909">
It has been noted that first-order Prolog terms
provide the equivalent expressive power as sorted
feature terms (Mellish, 1992). For example,
Carpenter&apos;s typed feature structures (Carpenter,
1992) can easily be represented as Prolog terms, if
the restriction is given up that the sort hierarchy
be a bounded complete partial order.
Such compilation of sorted feature terms into
Prolog terms has been successfully used in the
Core Language Engine (CLE) (Alshawi, 1991) and
in the Advanced Linguistic Engineering Platform
(ALEP), (Alshawi et al., 1991).2 ProFIT ex-
tends the compilation techniques of these systems
through the handling of multi-dimensional inher-
itance (Erbach, 1994), and makes them generally
available for a wide range of applications by trans-
lating programs (or grammars) with sorted feature
terms into Prolog programs.
ProFIT is not a grammar formalism, but rather
extends any grammar formalism in the logic gram-
mar tradition with the expressive power of sorted
feature terms.
</bodyText>
<sectionHeader confidence="0.966471" genericHeader="method">
2 The ProFIT Language
</sectionHeader>
<bodyText confidence="0.996597">
The set of ProFIT programs is a superset of Pro-
log programs. While a Prolog program consists
only of definite clauses (Prolog is an untyped lan-
guage), a ProFIT program consists of datatype
declarations and definite clauses. The clauses of a
ProFIT program can make use of the datatypes
(sorts, features, templates and finite domains)
that are introduced in the declarations. A ProFIT
program consists of:
</bodyText>
<listItem confidence="0.999939">
• Declarations for sorts
• Declarations for features
• Declarations for templates
• Declarations for finite domains
• Definite clauses
</listItem>
<subsectionHeader confidence="0.885173">
2.1 Sort Declarations
</subsectionHeader>
<bodyText confidence="0.964808538461539">
In addition to unsorted Prolog terms, ProFIT al-
lows sorted feature terms, for which the sorts and
features must be declared in advance.
The most general sort is top, and all other sorts
must be subsorts of top. Subsort declarations
have the syntax given in (1). The declaration
states that all Subs are subsorts of Super, and
that all Subi are mutually exclusive.
Super &gt; [Subi, , Subr]. (1)
It is also possible to provide subsorts that are
not mutually exclusive, as in (2), where one sub-
sort may be chosen from each of the &amp;quot;dimensions&amp;quot;
connected by the * operator (Erbach, 1994).
</bodyText>
<equation confidence="0.95438">
Super &gt; *
(2)
[Subk 1, ...,Subk.m]
</equation>
<footnote confidence="0.658679">
Every sort must only be defined once, i.e. it
can appear only once on the left-hand side of the
connective &gt;.
2Similar, but less efficient compilation schemes are
used in Hirsh&apos;s P-PATR (Hirsh, 1986) and Coving-
ton&apos;s GULP system (Covington, 1989).
</footnote>
<page confidence="0.998045">
181
</page>
<bodyText confidence="0.995343636363636">
The sort hierarchy must not contain any cycles,
i.e. there must be no sorts A and B, such that
A 0 B, and A&gt; B &gt; A.
The immediate subsorts of top can be declared
to be extensional. Two terms which are of an
extensional sort are only identical if they .have a
most specific sort (which has no subsort), and if
all features are instantiated to ground terms. If a
sort is not declared as extensional, it is intensional.
Two intensional terms are identical only if they
have been unified.
</bodyText>
<subsectionHeader confidence="0.999349">
2.2 Feature Declarations
</subsectionHeader>
<bodyText confidence="0.9999135">
Unlike unsorted feature formalisms (such as PATR-
ii), where any feature can be added to any struc-
ture, ProFIT follows the notion of appropriate-
ness in Carpenter&apos;s logic of typed feature struc-
tures (Carpenter, 1992), and introduces features
for particular sorts. For each sort, one must de-
clare which features are introduced by it. The
features introduced by a sort are inherited by all
its subsorts, which may also introduce additional
features. A feature must be introduced only at
one most general sort. This makes it possible to
provide a notation in which the sort name can be
omitted since it can be inferred from the use of a
feature that is appropriate for that sort.
This notion of appropriateness is desirable for
structuring linguistic knowledge, as it prevents the
ad-hoc introduction of features, and requires a
careful design of the sort and feature hierarchy.
Appropriateness is also a prerequisite for compila-
tion of feature terms into fixed-arity Prolog terms.
Each feature has a sortal restriction for its
value. If a feature&apos;s value is only restricted to be of
sort top, then the sortal restriction can be omit-
ted. The syntax of feature declarations is given in
</bodyText>
<listItem confidence="0.660537">
(3)-
Sort intro [Featurei : Restri,
• (3)
Feature,-, : Restrn].
</listItem>
<bodyText confidence="0.984856333333333">
The following declaration defines a sort bi-
nary_tree with subsorts leaf and internal_node.
The sort binary tree introduces the feature label
and its subsort adds the features left_daughter and
right_daughier. If a sort has subsorts and intro-
duces features, these are combined in one declara-
tion.
binary_tree &gt; [leaf , int ernal_node]
intro [label] .
internal_node
intro [left_daughter:binary_tree,
right_daughter:binary_tree].
</bodyText>
<subsectionHeader confidence="0.968243">
2.3 Sorted Feature Terms
</subsectionHeader>
<bodyText confidence="0.983056137931034">
On the basis of the declarations, sorted feature
terms can be used in definite clauses in addition to
and in combination with Prolog terms. A Prolog
term can have a feature term as its argument, and
a feature can have a Prolog term as its value. This
avoids potential interface problems between dif-
ferent representations, since terms do not have to
be translated between different languages. As an
example, semantic representations in first-order
terms can be used as feature values, but do not
need to be encoded as feature terms.
Sorted feature terms consist of a specification
of the sort of the term (4), or the specification of
a feature value (5), or a conjunction of terms (6).
A complete BNF of all ProFIT terms is given in
the appendix.
&lt; Sort
Feature ! Value
Term St Term
The following clauses (based on HPSG) state
that a structure is saturated if its sub cat value
is the empty list, and that a structure satisfies
the Head Feature Principle (b.fp) if its head fea-
tures are identical with the head features of its
head daughter.3 Note that these clauses provide
a concise notation because uninstantiated features
can be omitted, and the sorts of structures do not
have to be specified explicitly because they can be
infered from use of the features.
</bodyText>
<equation confidence="0.981563">
saturated( synsem!local!cat!subcat!&lt;elist ).
hfp( synsem!local!cat!head!X
dtrs!head_dtr!synsem!local!cat!head!X ).
</equation>
<bodyText confidence="0.998824">
Note that conjunction also provides the possi-
blity to tag a Prolog term or feature term with a
variable (Var &amp; Term).
</bodyText>
<subsectionHeader confidence="0.995904">
2.4 Feature Search
</subsectionHeader>
<bodyText confidence="0.941307285714286">
In the organisation of linguistic knowledge, feature
structures are often deeply embedded, due to the
need to group together sets of features whose value
can be structure-shared. In the course of grammar
development, it is often necessary to change the
&amp;quot;location&amp;quot; of a feature in order to get the right
structuring of information.
Such a change of the &amp;quot;feature geometry&amp;quot; makes
it necessary to change the path in all references
to a feature. This is often done by introducing
templates whose sole purpose is the abbreviation
of a path to a feature.
ProFIT provides a mechanism to search for
paths to features automatically provided that the
sortal restrictions for the feature values are strong
enough to ensure that there is a unique minimal
path. A path is minimal if it does not contain any
repeated features or sorts.
3These clauses assume appropriate declarations for
the sort elist, and for the features synsem, local,
cat, subcat, head, dtrs and head_dtr.
</bodyText>
<page confidence="0.99325">
182
</page>
<bodyText confidence="0.9985926">
The sort from which to start the feature search
must either be specified explicitly (7) or implicitly
given through the sortal restriction of a feature
value, in which case the sort can be omitted and
the expression (8) can be used.
</bodyText>
<equation confidence="0.496546">
Sort &gt;&gt;&gt; Feature ! Term (7)
&gt;&gt;&gt; Feature ! Term (8)
</equation>
<bodyText confidence="0.911422">
The following clause makes use of feature search
to express the Head Feature Principle (hfp).
</bodyText>
<equation confidence="0.8145575">
hfp( sign&gt;&gt;&gt;head!X &amp;
dtrs!head_dtr! &gt;&gt;&gt;head!X ).
</equation>
<bodyText confidence="0.997392142857143">
While this abbreviation for feature paths is new
for formal description languages, similar abbrevi-
atory conventions are often used in linguistic pub-
lications. They are easily and unambiguously un-
derstood if there is only one unique path to the
feature which is not embedded in another struc-
ture of the same sort.
</bodyText>
<subsectionHeader confidence="0.781046">
2.5 Templates
</subsectionHeader>
<bodyText confidence="0.99394325">
The purpose of templates is to give names to
frequently used structures. In addition to being
an abbreviatory device, the template mechanism
serves three other purposes.
</bodyText>
<listItem confidence="0.9743212">
• Abstraction and interfacing by providing a
fixed name for a value that may change,
• Partial evaluation,
• Functional notation that can make specifica-
tions easier to understand.
</listItem>
<figureCaption confidence="0.81779525">
Templates are defined by expressions of the
form (9), where Name and Value can be arbitrary
ProFIT terms, including variables, and template
calls. There can be several template definitions
with the same name on the left-hand side (rela-
tional templates). Since templates are expanded
at compile time, template definitions must not be
recursive.
</figureCaption>
<equation confidence="0.939362">
Name := Value. (9)
</equation>
<bodyText confidence="0.997115444444444">
Templates are called by using the template
name prefixed with (0 in a ProFIT term.
Abstraction makes it possible to change data
structures by changing their definition only at one
point. Abstraction also ensures that databases
(e.g. lexicons) which make use of these abstrac-
tions can be re-used in &apos;different kinds of appli-
cations where different datastructures represent
these abstractions.
Abstraction through templates is also useful for
defining interfaces between grammars and pro-
cessing modules. If semantic processing must
access the semantic representations of different
grammars, this can be done lithe semantic mod-
ule makes use of a template defined for each gram-
mar that indicates where in the feature structure
the semantic information is located, as in the fol-
lowing example for HPSG.
</bodyText>
<equation confidence="0.984299">
semantics(synsem!local!cont!Sem) := Sem.
</equation>
<bodyText confidence="0.989702727272727">
Partial evaluation is achieved when a structure
(say a principle of a grammar) is represented by
a template that gets expanded at compile time,
and does not have to be called as a goal during
processing.
We show the use of templates for providing
functional notation by a simple example, in which
the expression @first (X) stands for the first ele-
ment of list X, and @rest (X) stands for the tail
of list X, as defined by the following template def-
inition.
</bodyText>
<figure confidence="0.770577">
first( [First I Rest] ) := First.
rest( CFirst Rest] ) := Rest.
</figure>
<figureCaption confidence="0.725102666666667">
The member relation can be defined with the
following clauses, which correspond very closely
to the natural-language statement of the member
relation given as comments. Note that expansion
of the templates yields the usual definition of the
member relation in Prolog.
</figureCaption>
<bodyText confidence="0.989280666666667">
% The first element of a list
% is a member of the list.
member(Ofirst(List),List).
</bodyText>
<equation confidence="0.9598185">
% Element is a member of a list
% if it is a member of the rest of the list
member(Element,List) :-
member(Element,(Drest(List)).
</equation>
<bodyText confidence="0.996125">
The expressive power of an n-place template is
the same as that of an n+1 place fact.
</bodyText>
<subsectionHeader confidence="0.920341">
2.6 Disjunction
</subsectionHeader>
<bodyText confidence="0.9999746875">
Disjunction in the general case cannot be encoded
in a Prolog term representation.4 Since a general
treatment of disjunction would involve too much
computational overhead, we provide disjunctive
terms only as syntactic sugar. Clauses containing
disjunctive terms are compiled to several clauses,
one for each consistent combination of disjuncts.
Disjunctive terms make it possible to state facts
that belong together in one clause, as the follow-
ing formulation of the Semantics Principle (sem_p)
of HPSG, which states that the content value of a
head-adjunct structure is the content value of the
adjunct daughter, and the content value of the
other headed structures (head-complement, head-
marker, and head-filler structure) is the content
value of the head daughter.
</bodyText>
<equation confidence="0.992872222222222">
sem_p( (&lt;head_adj &amp;
&gt;&gt;&gt;cont!X &amp; &gt;&gt;&gt;adj_dtr!&gt;&gt;&gt;cont!X )
Or
&lt;head_comp
or &lt;head_marker
or &lt;head_filler
) &amp;
&gt;&gt;&gt;cont!Y &amp; &gt;&gt;&gt;head_dtr!&gt;&gt;&gt;cont!Y )
) .
</equation>
<bodyText confidence="0.9133535">
For disjunctions of atoms, there exists a Prolog
term representation, which is described below.
</bodyText>
<footnote confidence="0.95899">
4see the complexity analysis by Brew (Brew, 1991).
</footnote>
<page confidence="0.997857">
183
</page>
<subsectionHeader confidence="0.906411">
2.7 Finite Domains
</subsectionHeader>
<bodyText confidence="0.986352">
For domains involving only a finite set of atoms as
possible values, it is possible to provide a Prolog
term representation (due to Colmerauer, and de-
scribed by Mellish (Mellish, 1988)) to encode any
subset of the possible values in one term.
Consider the agreement features person (with
values 1, 2 and 3) and number (with values sg
and pl). For the two features together there
are six possible combinations of values (1Sisg,
2Sisg, nag, 3Sipl). Any subset of
this set of possible values can be encoded as one
Prolog term. The following example shows the
declaration needed for this finite domain, and
some clauses that refer to subsets of the possi-
ble agreement values by making use of the logi-
cal connectives (negation), Si (conjunction), or
(disjunction) .5
</bodyText>
<equation confidence="0.929906625">
agr fin_dom [1,2,3] [sg,p1].
verb (sleeps ,3&amp;sg) .
verb (sleep , (Itsg) ) .
verb (am, l&amp;sg) .
verb ( is , 3&amp;sg) .
verb(are, 2 or pi)..
np( &apos;I &apos; , l&amp;sg).
np (you , 2@agr).
</equation>
<bodyText confidence="0.999980555555556">
This kind of encoding is only applicable to do-
mains which have no coreferences reaching into
them, in the example only the agreement features
as a whole can be coreferent with other agreement
features, but not the values of person or number
in isolation. This kind of encoding is useful to
avoid the creation of choice points for the lexicon
of languages where one inflectional form may cor-
respond to different feature values.
</bodyText>
<subsectionHeader confidence="0.984763">
2.8 Cyclic Terms
</subsectionHeader>
<bodyText confidence="0.997142">
Unlike Prolog, the concrete syntax of ProFIT al-
lows to write down cyclic terms by making use of
conjunction:
</bodyText>
<equation confidence="0.904296">
X &amp; f(X).
</equation>
<bodyText confidence="0.996304142857143">
Cyclic terms constitute no longer a theoretical
or practical problem in logic programming, and al-
most all modern Prolog implementations can per-
form their unification (although they can&apos;t print
them out). Cyclic terms arise naturally in NLP
through unification of non-cyclic terms, e.g., the
Subcategorization Principle and the Spec Princi-
ple of HPSG.
ProFIT supports cyclic terms by being able to
print them out as solutions. In order to do this,
&apos;The syntax for finite domain
terms is Termnomain. However, when atoms from a
finite domains are combined by the conjunction, dis-
junction and negation connectives, the specification
of the domain can be omitted. In the example, the
domain must only be specified for the value 2, which
could otherwise be confused with the integer 2.
the dreaded occur check must be performed. Since
this must be done only when results are printed
out as ProFIT terms, it does not affect the run-
time performance.
</bodyText>
<sectionHeader confidence="0.8970685" genericHeader="method">
3 From ProFIT terms to Prolog
terms
</sectionHeader>
<subsectionHeader confidence="0.999791">
3.1 Compilation of Sorted Feature Terms
</subsectionHeader>
<bodyText confidence="0.999643">
The compilation of sorted feature terms into a
Prolog term representation is based on the follow-
ing principles, which are explained in more detail
in (Mellish, 1988; Mellish, 1992; SchOter, 1993;
Erbach, 1994).
</bodyText>
<listItem confidence="0.998241">
• The Prolog representation of a sort is an in-
stance of the Prolog representation of its su-
persorts.
• Features are represented by arguments. If a
feature is introduced by a subsort, then the
argument is added to the term that further
instantiates its supersort.
• Mutually exclusive sorts have different func-
tors at the same argument position, so that
their unification fails.
</listItem>
<bodyText confidence="0.985112095238095">
We illustrate these principles for compiling
sorted feature terms into Prolog terms with an
example from HPSG. The following declaration
states that the sort sign has two mutually ex-
clusive subsorts lexical and phrasal and intro-
duces four features.
sign &gt; [lexical,phrasal]
intro [phon,
synsem,
qstore,
retrieved].
In the corresponding Prolog term representa-
tion below, the first argument is a variable whose
only purpose is being able to test whether two
terms are coreferent or whether they just happen
to have the same sort and the same values for all
features. In case of extensional sorts (see section
2.1), this variable is omitted. The second argu-
ment can be further instantiated for the subsorts,
and the remaining four arguments correspond to
the four features.
</bodyText>
<equation confidence="0.603184">
$sign(Var,LexPhras,Phon,Synsem,Qstore,Retriev)
</equation>
<bodyText confidence="0.9058924">
The following declaration introduces two sort
hierarchy &amp;quot;dimensions&amp;quot; for subsorts of phrasal,
and one new feature. The corresponding Prolog
term representation instantiates the representa-
tion for the sort sign further, and leaves argument
positions that can be instantiated further by the
subsorts of phrasal, and for the newly introduced
feature daughters.
phrasal &gt; [headed,non_headed] * [decl,int ,rel]
intro [daughters].
</bodyText>
<page confidence="0.996043">
184
</page>
<bodyText confidence="0.698651333333333">
$sign(Var,
$phrasal(Phrasesort,Clausesort,Dtrs),
Phon,
Synsem,
Qstore,
Retrieved)
</bodyText>
<subsectionHeader confidence="0.998152">
3.2 Compilation of Finite Domains
</subsectionHeader>
<bodyText confidence="0.9895167">
The compilation of finite domains into Prolog
terms is performed by the &amp;quot;brute-force&amp;quot; method
described in (Mellish, 1988). A finite domain with
n possible domain elements is represented by a
Prolog term with n 1 arguments. Each domain
element is associated with a pair of adjacent argu-
ments. For example, the agreement domain agr
from section 2.7 with its six elements (lAzsg, 2&amp;sg,
3&amp;sg, 1(41, 2Szpl, 3Szpl) is represented by a Pro-
log term with seven arguments.
</bodyText>
<equation confidence="0.581202">
Sagr(1,A,B,C,D,E,O)
</equation>
<bodyText confidence="0.999982375">
Note that the first and last argument must be
different. In the example, this is achieved by in-
stantiation with different atoms, but an inequal-
ity constraint (Prolog H&apos;s dif) would serve the
same purpose. We assume that the domain el-
ement 18zsg corresponds to the first and second
arguments, Nog to the second and third arguem-
nts, and so on, as illustrated below.
</bodyText>
<equation confidence="0.8201635">
Sagr(1,A,B,C,D,E,O)
lsg 2sg 3sg lpl 2p1 3p1
</equation>
<bodyText confidence="0.97569335">
A domain description is translated into a Pro-
log term by unifying the argument pairs that are
excluded by the description. For example, the
domain description 2 or pl excludes nog and
3&amp;sg, so that the the first and second argument
are unified (1Szsg), as well as the third and fourth
(3&amp;sg).
Sagr(1,1,X,X,D,E,O)
When two such Prolog terms are unified, the
union of their excluded elements is computed by
unificatation, or conversely the intersection of the
elements which are in the domain description.
The unification of two finite domain terms is suc-
cessful as long as they have at least one element
in common. When two terms are unified which
have no element in common, i.e., they exclude all
domain elements, then unification fails because all
arguments become unified with each other, includ-
ing the first and last arguments, which are differ-
ent.
</bodyText>
<sectionHeader confidence="0.994703" genericHeader="method">
4 Implementation
</sectionHeader>
<bodyText confidence="0.993916">
ProFIT has been implemented in Quintus and Sic-
stus Prolog, and should run with any Prolog that
conforms to or extends the proposed ISO Prolog
standard.
All facilities needed for the development of ap-
plication programs, for example the module sys-
tem and declarations (dynamic, multifile etc.) are
supported by ProFIT.
Compilation of a ProFIT file generates two
kinds of files as output.
</bodyText>
<listItem confidence="0.9815962">
1. Declaration files that contain information for
compilation, derived from the declarations.
2. A program file (a Prolog program) that con-
tains the clauses, with all ProFIT terms com-
piled into their Prolog term representation.
</listItem>
<bodyText confidence="0.99981409375">
The program file is compiled on the basis of
the declaration files. If the input and output of
the program (the exported predicates of a mod-
ule) only make use of Prolog terms, and feature
terms are only used for internal purposes, then the
program file is all that is needed. This is for ex-
ample the case with a grammar that uses feature
terms for grammatical description, but whose in-
put and output (e.g. graphemic form and logical
form) are represented as normal Prolog terms.
Declarations and clauses can come in any or-
der in a ProFIT file, so that the declarations can
be written next to the clauses that make use of
them. Declarations, templates and clauses can be
distributed across several files, so that it becomes
possible to modify clauses without having to re-
compile the declarations, or to make changes to
parts of the sort hierarchy without having to re-
compile the entire hierarchy.
Sort checking can be turned off for debug-
ging purposes, and feature search and handling
of cyclic terms can be turned off in order to speed
up the compilation process if they are not needed.
Error handling is currently being improved to
give informative and helpful warnings in case of
undefined sorts, features and templates, or cyclic
sort hierarchies or template definitions.
For the development of ProFIT programs and
grammars, it is necessary to give input and out-
put and debugging information in ProFIT terms,
since the Prolog term representation is not very
readable. ProFIT provides a user interface which
</bodyText>
<listItem confidence="0.986686142857143">
• accepts queries containing ProFIT terms, and
translates them into Prolog queries,
• converts the solutions to the Prolog query
back into ProFIT terms before printing them
out,
• prints out debugging information as ProFIT
terms.
</listItem>
<bodyText confidence="0.997424636363636">
When a solution or debugging information is
printed out, uninstantiated features are omit-
ted, and shared structures are printed only once
and represented by variables on subsequent oc-
curences.
A pretty-printer is provided that produces a
neatly formatted screen output of ProFIT terms,
and is configurable by the user. ProFIT terms can
also be output in IATEX format, and an interface
to the graphical feature editor Fegramed is fore-
seen.
</bodyText>
<page confidence="0.996684">
185
</page>
<bodyText confidence="0.999966818181818">
In order to give a rough idea of the efficiency
gains of a compilation into Prolog terms instead
of using a feature term unification algorithm im-
plemented on top of Prolog, we have compared
the runtimes with ALE and the Eisele-Dorre al-
gorithm for unsorted feature unification for the
following tasks: (i) unification of (unsorted) fea-
ture structures, (ii) unification of inconsistent fea-
ture structures (unification failure), (iii) unifica-
tion of sorts, (iv) lookup of one of 10000 feature
structures (e.g. lexical items), (v) parsing with
an HPSG grammar to provide a mix of the above
tasks.
The timings obtained so far indicate that
ProFIT is 5 to 10 times faster than a system which
implements a unification algorithm on top of Pro-
log, a result which is predicted by the studies of
SchOter (Schoter, 1993) and the experience of the
Core Language Engine.
The ProFIT system and documentation are
available free of charge by anonymous ftp (server:
ftp .coli.uni-sb .de, directory: pub /profit) .
</bodyText>
<sectionHeader confidence="0.999291" genericHeader="method">
5 Conclusion
</sectionHeader>
<bodyText confidence="0.99996672">
ProFIT allows the use of sorted feature terms in
Prolog programs and Logic Grammars without
sacrificing the efficiency of Prolog&apos;s term unifi-
cation. It is very likely that the most efficient
commercial Prolog systems, which provide a ba-
sis for the implementation of NLP systems, will
conform to the proposed ISO standard. Since the
ISO standard includes neither inheritance hierar-
chies nor feature terms (which are indispensible
for the development of large grammars, lexicons
and knowledge bases for NLP systems), a tool
like ProFIT that compiles sorted feature terms
into Prolog terms is useful for the development of
grammars and lexicons that can be used for ap-
plications. ProFIT is not a grammar formalism,
but rather aims to extend current and future for-
malisms and processing models in the logic gram-
mar tradition with the expressive power of sorted
feature terms. Since the output of ProFIT com-
pilation are Prolog programs, all the techniques
developed for the optimisation of logic programs
(partial evaluation, tabulation, indexing, program
transformation techniques etc.) can be applied
straightforwardly to improve the performance of
sorted feature grammars.
</bodyText>
<sectionHeader confidence="0.999206" genericHeader="method">
6 Acknowledgements
</sectionHeader>
<bodyText confidence="0.905226666666667">
This work was supported by
• The Commission of the European Com-
munities through the project LRE-61-061
&amp;quot;Reusable Grammatical Resources&amp;quot;, where it
has been (ab-)used in creative ways to proto-
type extensions for the ALEP formalism such
as set descriptions, linear precedence con-
straints and guarded constraints (Manand-
har, 1994; Manandhar, 1995).
</bodyText>
<listItem confidence="0.860263666666667">
• Deutsche Forschungsgemeinschaft, Special
Research Division 314 &amp;quot;Artificial Intelli-
gence - Knowledge-Based Systems&amp;quot; through
</listItem>
<bodyText confidence="0.7164306">
project N3 &amp;quot;Bidirectional Linguistic Deduc-
tion&amp;quot; (BiLD), where it is used to compile
typed feature grammars into logic grammars,
for which bidirectional NLP algorithms are
developed, and
</bodyText>
<listItem confidence="0.656867">
• Cray Systems (formerly PE-Luxembourg),
</listItem>
<bodyText confidence="0.961961909090909">
with whom we had fruitful interaction con-
cerning the future development of the ALEP
system-.
Some code for handling of finite domains was
adapted from a program by Gertjan van Noord.
Wojciech Skut and Christian Braun were a great
help in testing and improving the system. Thanks
to all the early users and [3-testers for discover-
ing bugs and inconsistencies, and for providing
feedback and encouragement. Special thanks for
service with a smiley :-).
</bodyText>
<sectionHeader confidence="0.987247" genericHeader="method">
References
</sectionHeader>
<bodyText confidence="0.911501333333333">
Hassan Alt-Kaci and Patrick Lincoln. 1989. Life,
a natural language for natural language. T. A.
Informations, 30(1-2):37 - 67.
H. Alshawi, D. J. Arnold, R. Backofen, D. M.
Carter, J. Lindop, K. Netter, J. Tsujii, and
H. Uszkoreit. 1991. Eurotra 6/1: Rule for-
malism and virtual machine design study — Fi-
nal report. Technical report, SRI International,
Cambridge.
</bodyText>
<reference confidence="0.996932227272727">
Hiyan Alshawi, editor. 1991. The Core Language
Engine. MIT Press.
Chris Brew. 1991. Systemic classification and its
efficiency. Computational Linguistics, 17(4):375
- 408.
Bob Carpenter. 1992. The logic of typed feature
structures. Cambridge Tracts in Theoretical
Computer Science. Cambridge University Press,
Cambridge.
Bob Carpenter, 1993. ALE Version 0: User Man-
ual. University of Pittsburgh.
Michael Covington. 1989. GULP 2.0: an exten-
sion of Prolog for unification-based grammar.
Technical Report AI-1989-01, Advanced Com-
putational Methods Center, University of Geor-
gia.
Jochen Dorre and Michael Dorna. 1993. CUF -
A formalism for linguistic knowledge represen-
tation. In Jochen Dorre, editor, Computational
Aspects of Constraint-Based Linguistic Descrip-
tion. Deliverable R1.2.A. DYANA-2 - ESPRIT
Basic Research Project 6852.
</reference>
<page confidence="0.987408">
186
</page>
<reference confidence="0.999798951612903">
Martin Emele and Rerni Zajac, 1990. Typed
unification grammars. In Proceedings of the
13th International Conference on Computa-
tional Linguistics, Helsinki.
Gregor Erbach. 1994. Multi-dimensional inheri-
tance. In H. Trost, editor, Proceedings of KON-
VENS &apos;94, pages 102 - 111, Vienna. Springer.
Susan Beth Hirsh. 1986. P-PATR: A compiler
for unification-based grammars. Master&apos;s the-
sis, Stanford University, Stanford, CA.
Draft ISO Standard for the Prolog language,
ISO/IEC JTC1 SC22 WG17 N110 &amp;quot;Prolog:
Part 1, General core&amp;quot;.
Hans-Ulrich Krieger and Ulrich Schafer.
1994. TD.C—a type description language for
constraint-based grammars. In Proceedings of
the 15th International Conference on Computa-
tional Linguistics, COLING-94, Kyoto, Japan.
Suresh Manandhar. 1994. An attributive logic
of set descriptions and set operations. In 32nd
Annual Meeting of the Association for Compu-
tational Linguistics (ACL), pages 255 -262, Las
Cruces, NM.
Suresh Manandhar. 1995. Deterministic con-
sistency checking of LP constraints. In Sev-
enth Conference of the European Chapter of
the Association for Computational Linguistics
(EA CL), Dublin.
Johannes Matiasek. 1994. Conditional con-
straints in a CLP-based HPSG implementation.
In Harald Trost, editor, KONVENS &apos;94, pages
230 - 239, Vienna.
Christopher S. Mellish. 1988. Implementing sys-
temic classification by unification. Computa-
tional Linguistics, 14(1):40-51.
Christopher S. Mellish. 1992. Term-encodable de-
scription spaces. In D. R. Brough, editor, Logic
Programming: New Frontiers, pages 189 - 207.
Intellect, Oxford.
Gunter Neumann and Gertjan van Noord. 1992.
Self-monitoring with reversible grammars. In
Proceedings of the 14th International Confer-
ence on Computational Linguistics, Nantes, F.
Giinter Neumann. 1994. A Uniform Computa-
tional Model for Natural Language Parsing and
Generation. Ph.D. thesis, Universitat des Saar-
landes, Saabriicken.
Christer Samuelsson. 1994. Fast Natural-
Language Parsing Using Explanation-Based
Learning. Ph.D. thesis, The Royal Institute of
Technology and Stockholm University, Stock-
holm.
Andreas P. Schoter. 1993. Compiling feature
structures into terms: A case study in Prolog.
Technical Report RP-55, University of Edin-
burgh, Centre for Cognitive Science.
Gert Smolka, Martin Henz, and Jorg Wiirtz.
1995. Object-oriented concurrent constraint
programming in Oz. In P. van Hentenryck and
V. Saraswat, editors, Principles and Practice of
Constraint Programming, chapter 2, pages 27--
48. The MIT Press.
</reference>
<sectionHeader confidence="0.490829" genericHeader="method">
Appendix: BNF for ProFIT Terms
</sectionHeader>
<table confidence="0.9389485">
PFT := &lt;Sort Term of a sort Sort
Feature! PFT Feature-Value pair
PFT &amp; PFT Conjunction of terms
PROLOG TERM Any Prolog term
FINDOM Finite Domain term, BNF see below
Template Template call
PFT Quoted term, is not translated
&amp;quot; PFT Double-quoted, main functor not translated
&gt;&gt;&gt;Feature!PFT Search for a feature
Sort&gt;&gt;&gt;Feature!PFT short for &lt;Sort &amp; &gt;&gt;&gt;Feature!PFT
PFT or PFT Disjunction; expands to multiple terms
FINDOM := FINDOM0FiniteDomainName
</table>
<sectionHeader confidence="0.50689" genericHeader="method">
-FINDOM
</sectionHeader>
<reference confidence="0.43881">
I FINDOM &amp; FINDOM
FINDOM or FINDOM
1 Atom
</reference>
<page confidence="0.994276">
187
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.803665">
<title confidence="0.999893">ProFIT: Prolog with Features, Inheritance and Templates</title>
<author confidence="0.998352">Gregor Erbach</author>
<affiliation confidence="0.9419255">Universitat des Saarlandes Computerlinguistik</affiliation>
<address confidence="0.990079">D-66041 Saarbriicken, Germany</address>
<email confidence="0.999268">erbachecoli.uni-sb.de</email>
<web confidence="0.950128">URL: http : //col i uni-sb . der erbach/</web>
<abstract confidence="0.997917652173913">ProFIT is an extension of Standard Prolog with Features, Inheritance and Templates. ProFIT allows the programmer or grammar developer to declare an inheritance hierarchy, features and templates. Sorted feature terms can be used in ProFIT programs together with Prolog terms to provide a clearer description language for linguistic structures. ProFIT compiles all sorted feature terms into a Prolog term representation, so that the built-in Prolog term unification can be used for the unification of sorted feature structures, and no special unification algorithm is needed. ProFIT programs are compiled into Prolog programs, so that no meta-interpreter is needed for their execution. ProFIT thus provides a direct step from grammars developed with sorted feature terms to Prolog programs usable for practical NLP systems.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<title>The Core Language Engine.</title>
<date>1991</date>
<editor>Hiyan Alshawi, editor.</editor>
<publisher>MIT Press.</publisher>
<marker>1991</marker>
<rawString>Hiyan Alshawi, editor. 1991. The Core Language Engine. MIT Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Chris Brew</author>
</authors>
<title>Systemic classification and its efficiency.</title>
<date>1991</date>
<journal>Computational Linguistics,</journal>
<volume>17</volume>
<issue>4</issue>
<pages>408</pages>
<contexts>
<context position="17133" citStr="Brew, 1991" startWordPosition="2737" endWordPosition="2738">g formulation of the Semantics Principle (sem_p) of HPSG, which states that the content value of a head-adjunct structure is the content value of the adjunct daughter, and the content value of the other headed structures (head-complement, headmarker, and head-filler structure) is the content value of the head daughter. sem_p( (&lt;head_adj &amp; &gt;&gt;&gt;cont!X &amp; &gt;&gt;&gt;adj_dtr!&gt;&gt;&gt;cont!X ) Or &lt;head_comp or &lt;head_marker or &lt;head_filler ) &amp; &gt;&gt;&gt;cont!Y &amp; &gt;&gt;&gt;head_dtr!&gt;&gt;&gt;cont!Y ) ) . For disjunctions of atoms, there exists a Prolog term representation, which is described below. 4see the complexity analysis by Brew (Brew, 1991). 183 2.7 Finite Domains For domains involving only a finite set of atoms as possible values, it is possible to provide a Prolog term representation (due to Colmerauer, and described by Mellish (Mellish, 1988)) to encode any subset of the possible values in one term. Consider the agreement features person (with values 1, 2 and 3) and number (with values sg and pl). For the two features together there are six possible combinations of values (1Sisg, 2Sisg, nag, 3Sipl). Any subset of this set of possible values can be encoded as one Prolog term. The following example shows the declaration needed </context>
</contexts>
<marker>Brew, 1991</marker>
<rawString>Chris Brew. 1991. Systemic classification and its efficiency. Computational Linguistics, 17(4):375 - 408.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Bob Carpenter</author>
</authors>
<title>The logic of typed feature structures. Cambridge Tracts in Theoretical Computer Science.</title>
<date>1992</date>
<publisher>Cambridge University Press,</publisher>
<location>Cambridge.</location>
<contexts>
<context position="5729" citStr="Carpenter, 1992" startWordPosition="872" endWordPosition="873">facilities to build up a lexicon database Since much of this work involves compilation of grammars into Prolog programs, such programs can immediately benefit from any improvements in Prolog compilers (for example the tabulation provided by XSB Prolog can provide a more efficient implementation of charts) which makes the grammars more usable for NLP systems. 1.3 Combining Logic Grammars and Sorted Feature Formalisms It has been noted that first-order Prolog terms provide the equivalent expressive power as sorted feature terms (Mellish, 1992). For example, Carpenter&apos;s typed feature structures (Carpenter, 1992) can easily be represented as Prolog terms, if the restriction is given up that the sort hierarchy be a bounded complete partial order. Such compilation of sorted feature terms into Prolog terms has been successfully used in the Core Language Engine (CLE) (Alshawi, 1991) and in the Advanced Linguistic Engineering Platform (ALEP), (Alshawi et al., 1991).2 ProFIT extends the compilation techniques of these systems through the handling of multi-dimensional inheritance (Erbach, 1994), and makes them generally available for a wide range of applications by translating programs (or grammars) with sor</context>
<context position="8702" citStr="Carpenter, 1992" startWordPosition="1370" endWordPosition="1371">&gt; B &gt; A. The immediate subsorts of top can be declared to be extensional. Two terms which are of an extensional sort are only identical if they .have a most specific sort (which has no subsort), and if all features are instantiated to ground terms. If a sort is not declared as extensional, it is intensional. Two intensional terms are identical only if they have been unified. 2.2 Feature Declarations Unlike unsorted feature formalisms (such as PATRii), where any feature can be added to any structure, ProFIT follows the notion of appropriateness in Carpenter&apos;s logic of typed feature structures (Carpenter, 1992), and introduces features for particular sorts. For each sort, one must declare which features are introduced by it. The features introduced by a sort are inherited by all its subsorts, which may also introduce additional features. A feature must be introduced only at one most general sort. This makes it possible to provide a notation in which the sort name can be omitted since it can be inferred from the use of a feature that is appropriate for that sort. This notion of appropriateness is desirable for structuring linguistic knowledge, as it prevents the ad-hoc introduction of features, and r</context>
</contexts>
<marker>Carpenter, 1992</marker>
<rawString>Bob Carpenter. 1992. The logic of typed feature structures. Cambridge Tracts in Theoretical Computer Science. Cambridge University Press, Cambridge.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Bob Carpenter</author>
</authors>
<date>1993</date>
<journal>ALE Version</journal>
<volume>0</volume>
<institution>User Manual. University of Pittsburgh.</institution>
<contexts>
<context position="3417" citStr="Carpenter, 1993" startWordPosition="522" endWordPosition="523">. Features that are not instantiated can be omitted; there is no need for anonymous variables. 2. Features names are mnemonic, argument positions are not. 3. Adding a new feature to a sort requires one change in a declaration, whereas adding an argument to a Prolog functor requires changes (mostly insertion of anonymous variables) to every occurence of the functor. 4. Specification of the subsort relationship is more convenient than constructing Prolog terms which mirror these subsumption relationships. Implementations of sorted feature formalisms such as TDL (Krieger and Schafer, 1994), ALE (Carpenter, 1993), CUF (DOrre and Dorna, 1993), TFS (Emele and Zajac, 1990) and others have been used successfully for the development and testing of large grammars and lexicons, but they may be too slow for actual use in applications 180 because they are generally built on top of Prolog or LISP, and can therefore not be as efficient as the built-in unification of Prolog. There are a few logic programming langauges, such as LIFE (Ait-Kaci and Lincoln, 1989) or Oz (Smolka et al., 1995), that provide sorted feature terms, but no commercial implementations of these languages with efficient compilers are yet avail</context>
</contexts>
<marker>Carpenter, 1993</marker>
<rawString>Bob Carpenter, 1993. ALE Version 0: User Manual. University of Pittsburgh.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Michael Covington</author>
</authors>
<title>GULP 2.0: an extension of Prolog for unification-based grammar.</title>
<date>1989</date>
<tech>Technical Report AI-1989-01,</tech>
<institution>Advanced Computational Methods Center, University of Georgia.</institution>
<contexts>
<context position="7973" citStr="Covington, 1989" startWordPosition="1240" endWordPosition="1241">x given in (1). The declaration states that all Subs are subsorts of Super, and that all Subi are mutually exclusive. Super &gt; [Subi, , Subr]. (1) It is also possible to provide subsorts that are not mutually exclusive, as in (2), where one subsort may be chosen from each of the &amp;quot;dimensions&amp;quot; connected by the * operator (Erbach, 1994). Super &gt; * (2) [Subk 1, ...,Subk.m] Every sort must only be defined once, i.e. it can appear only once on the left-hand side of the connective &gt;. 2Similar, but less efficient compilation schemes are used in Hirsh&apos;s P-PATR (Hirsh, 1986) and Covington&apos;s GULP system (Covington, 1989). 181 The sort hierarchy must not contain any cycles, i.e. there must be no sorts A and B, such that A 0 B, and A&gt; B &gt; A. The immediate subsorts of top can be declared to be extensional. Two terms which are of an extensional sort are only identical if they .have a most specific sort (which has no subsort), and if all features are instantiated to ground terms. If a sort is not declared as extensional, it is intensional. Two intensional terms are identical only if they have been unified. 2.2 Feature Declarations Unlike unsorted feature formalisms (such as PATRii), where any feature can be added </context>
</contexts>
<marker>Covington, 1989</marker>
<rawString>Michael Covington. 1989. GULP 2.0: an extension of Prolog for unification-based grammar. Technical Report AI-1989-01, Advanced Computational Methods Center, University of Georgia.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jochen Dorre</author>
<author>Michael Dorna</author>
</authors>
<title>CUF -A formalism for linguistic knowledge representation.</title>
<date>1993</date>
<booktitle>In Jochen Dorre, editor, Computational Aspects of Constraint-Based Linguistic Description. Deliverable R1.2.A. DYANA-2 - ESPRIT Basic Research Project</booktitle>
<pages>6852</pages>
<marker>Dorre, Dorna, 1993</marker>
<rawString>Jochen Dorre and Michael Dorna. 1993. CUF -A formalism for linguistic knowledge representation. In Jochen Dorre, editor, Computational Aspects of Constraint-Based Linguistic Description. Deliverable R1.2.A. DYANA-2 - ESPRIT Basic Research Project 6852.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Martin Emele</author>
<author>Rerni Zajac</author>
</authors>
<title>Typed unification grammars.</title>
<date>1990</date>
<booktitle>In Proceedings of the 13th International Conference on Computational Linguistics,</booktitle>
<location>Helsinki.</location>
<contexts>
<context position="3475" citStr="Emele and Zajac, 1990" startWordPosition="530" endWordPosition="533"> there is no need for anonymous variables. 2. Features names are mnemonic, argument positions are not. 3. Adding a new feature to a sort requires one change in a declaration, whereas adding an argument to a Prolog functor requires changes (mostly insertion of anonymous variables) to every occurence of the functor. 4. Specification of the subsort relationship is more convenient than constructing Prolog terms which mirror these subsumption relationships. Implementations of sorted feature formalisms such as TDL (Krieger and Schafer, 1994), ALE (Carpenter, 1993), CUF (DOrre and Dorna, 1993), TFS (Emele and Zajac, 1990) and others have been used successfully for the development and testing of large grammars and lexicons, but they may be too slow for actual use in applications 180 because they are generally built on top of Prolog or LISP, and can therefore not be as efficient as the built-in unification of Prolog. There are a few logic programming langauges, such as LIFE (Ait-Kaci and Lincoln, 1989) or Oz (Smolka et al., 1995), that provide sorted feature terms, but no commercial implementations of these languages with efficient compilers are yet available. 1.2 Efficient Processing based on Logic Grammars Muc</context>
</contexts>
<marker>Emele, Zajac, 1990</marker>
<rawString>Martin Emele and Rerni Zajac, 1990. Typed unification grammars. In Proceedings of the 13th International Conference on Computational Linguistics, Helsinki.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Gregor Erbach</author>
</authors>
<title>Multi-dimensional inheritance.</title>
<date>1994</date>
<booktitle>Proceedings of KONVENS &apos;94,</booktitle>
<pages>102--111</pages>
<editor>In H. Trost, editor,</editor>
<publisher>Springer.</publisher>
<location>Vienna.</location>
<contexts>
<context position="6213" citStr="Erbach, 1994" startWordPosition="946" endWordPosition="947">ent expressive power as sorted feature terms (Mellish, 1992). For example, Carpenter&apos;s typed feature structures (Carpenter, 1992) can easily be represented as Prolog terms, if the restriction is given up that the sort hierarchy be a bounded complete partial order. Such compilation of sorted feature terms into Prolog terms has been successfully used in the Core Language Engine (CLE) (Alshawi, 1991) and in the Advanced Linguistic Engineering Platform (ALEP), (Alshawi et al., 1991).2 ProFIT extends the compilation techniques of these systems through the handling of multi-dimensional inheritance (Erbach, 1994), and makes them generally available for a wide range of applications by translating programs (or grammars) with sorted feature terms into Prolog programs. ProFIT is not a grammar formalism, but rather extends any grammar formalism in the logic grammar tradition with the expressive power of sorted feature terms. 2 The ProFIT Language The set of ProFIT programs is a superset of Prolog programs. While a Prolog program consists only of definite clauses (Prolog is an untyped language), a ProFIT program consists of datatype declarations and definite clauses. The clauses of a ProFIT program can make</context>
<context position="7691" citStr="Erbach, 1994" startWordPosition="1192" endWordPosition="1193">te clauses 2.1 Sort Declarations In addition to unsorted Prolog terms, ProFIT allows sorted feature terms, for which the sorts and features must be declared in advance. The most general sort is top, and all other sorts must be subsorts of top. Subsort declarations have the syntax given in (1). The declaration states that all Subs are subsorts of Super, and that all Subi are mutually exclusive. Super &gt; [Subi, , Subr]. (1) It is also possible to provide subsorts that are not mutually exclusive, as in (2), where one subsort may be chosen from each of the &amp;quot;dimensions&amp;quot; connected by the * operator (Erbach, 1994). Super &gt; * (2) [Subk 1, ...,Subk.m] Every sort must only be defined once, i.e. it can appear only once on the left-hand side of the connective &gt;. 2Similar, but less efficient compilation schemes are used in Hirsh&apos;s P-PATR (Hirsh, 1986) and Covington&apos;s GULP system (Covington, 1989). 181 The sort hierarchy must not contain any cycles, i.e. there must be no sorts A and B, such that A 0 B, and A&gt; B &gt; A. The immediate subsorts of top can be declared to be extensional. Two terms which are of an extensional sort are only identical if they .have a most specific sort (which has no subsort), and if all</context>
<context position="19881" citStr="Erbach, 1994" startWordPosition="3206" endWordPosition="3207"> specification of the domain can be omitted. In the example, the domain must only be specified for the value 2, which could otherwise be confused with the integer 2. the dreaded occur check must be performed. Since this must be done only when results are printed out as ProFIT terms, it does not affect the runtime performance. 3 From ProFIT terms to Prolog terms 3.1 Compilation of Sorted Feature Terms The compilation of sorted feature terms into a Prolog term representation is based on the following principles, which are explained in more detail in (Mellish, 1988; Mellish, 1992; SchOter, 1993; Erbach, 1994). • The Prolog representation of a sort is an instance of the Prolog representation of its supersorts. • Features are represented by arguments. If a feature is introduced by a subsort, then the argument is added to the term that further instantiates its supersort. • Mutually exclusive sorts have different functors at the same argument position, so that their unification fails. We illustrate these principles for compiling sorted feature terms into Prolog terms with an example from HPSG. The following declaration states that the sort sign has two mutually exclusive subsorts lexical and phrasal a</context>
</contexts>
<marker>Erbach, 1994</marker>
<rawString>Gregor Erbach. 1994. Multi-dimensional inheritance. In H. Trost, editor, Proceedings of KONVENS &apos;94, pages 102 - 111, Vienna. Springer.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Susan Beth Hirsh</author>
</authors>
<title>P-PATR: A compiler for unification-based grammars. Master&apos;s thesis,</title>
<date>1986</date>
<institution>Stanford University,</institution>
<location>Stanford, CA.</location>
<contexts>
<context position="7927" citStr="Hirsh, 1986" startWordPosition="1233" endWordPosition="1234">f top. Subsort declarations have the syntax given in (1). The declaration states that all Subs are subsorts of Super, and that all Subi are mutually exclusive. Super &gt; [Subi, , Subr]. (1) It is also possible to provide subsorts that are not mutually exclusive, as in (2), where one subsort may be chosen from each of the &amp;quot;dimensions&amp;quot; connected by the * operator (Erbach, 1994). Super &gt; * (2) [Subk 1, ...,Subk.m] Every sort must only be defined once, i.e. it can appear only once on the left-hand side of the connective &gt;. 2Similar, but less efficient compilation schemes are used in Hirsh&apos;s P-PATR (Hirsh, 1986) and Covington&apos;s GULP system (Covington, 1989). 181 The sort hierarchy must not contain any cycles, i.e. there must be no sorts A and B, such that A 0 B, and A&gt; B &gt; A. The immediate subsorts of top can be declared to be extensional. Two terms which are of an extensional sort are only identical if they .have a most specific sort (which has no subsort), and if all features are instantiated to ground terms. If a sort is not declared as extensional, it is intensional. Two intensional terms are identical only if they have been unified. 2.2 Feature Declarations Unlike unsorted feature formalisms (su</context>
</contexts>
<marker>Hirsh, 1986</marker>
<rawString>Susan Beth Hirsh. 1986. P-PATR: A compiler for unification-based grammars. Master&apos;s thesis, Stanford University, Stanford, CA.</rawString>
</citation>
<citation valid="false">
<authors>
<author>Draft ISO</author>
</authors>
<title>Standard for the Prolog language,</title>
<booktitle>ISO/IEC JTC1 SC22 WG17 N110 &amp;quot;Prolog: Part 1, General core&amp;quot;.</booktitle>
<marker>ISO, </marker>
<rawString>Draft ISO Standard for the Prolog language, ISO/IEC JTC1 SC22 WG17 N110 &amp;quot;Prolog: Part 1, General core&amp;quot;.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Hans-Ulrich Krieger</author>
<author>Ulrich Schafer</author>
</authors>
<title>TD.C—a type description language for constraint-based grammars.</title>
<date>1994</date>
<booktitle>In Proceedings of the 15th International Conference on Computational Linguistics, COLING-94,</booktitle>
<location>Kyoto, Japan.</location>
<contexts>
<context position="3394" citStr="Krieger and Schafer, 1994" startWordPosition="517" endWordPosition="520">. They provide a compact notation. Features that are not instantiated can be omitted; there is no need for anonymous variables. 2. Features names are mnemonic, argument positions are not. 3. Adding a new feature to a sort requires one change in a declaration, whereas adding an argument to a Prolog functor requires changes (mostly insertion of anonymous variables) to every occurence of the functor. 4. Specification of the subsort relationship is more convenient than constructing Prolog terms which mirror these subsumption relationships. Implementations of sorted feature formalisms such as TDL (Krieger and Schafer, 1994), ALE (Carpenter, 1993), CUF (DOrre and Dorna, 1993), TFS (Emele and Zajac, 1990) and others have been used successfully for the development and testing of large grammars and lexicons, but they may be too slow for actual use in applications 180 because they are generally built on top of Prolog or LISP, and can therefore not be as efficient as the built-in unification of Prolog. There are a few logic programming langauges, such as LIFE (Ait-Kaci and Lincoln, 1989) or Oz (Smolka et al., 1995), that provide sorted feature terms, but no commercial implementations of these languages with efficient </context>
</contexts>
<marker>Krieger, Schafer, 1994</marker>
<rawString>Hans-Ulrich Krieger and Ulrich Schafer. 1994. TD.C—a type description language for constraint-based grammars. In Proceedings of the 15th International Conference on Computational Linguistics, COLING-94, Kyoto, Japan.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Suresh Manandhar</author>
</authors>
<title>An attributive logic of set descriptions and set operations.</title>
<date>1994</date>
<booktitle>In 32nd Annual Meeting of the Association for Computational Linguistics (ACL),</booktitle>
<pages>255--262</pages>
<location>Las Cruces, NM.</location>
<contexts>
<context position="28705" citStr="Manandhar, 1994" startWordPosition="4622" endWordPosition="4624">ompilation are Prolog programs, all the techniques developed for the optimisation of logic programs (partial evaluation, tabulation, indexing, program transformation techniques etc.) can be applied straightforwardly to improve the performance of sorted feature grammars. 6 Acknowledgements This work was supported by • The Commission of the European Communities through the project LRE-61-061 &amp;quot;Reusable Grammatical Resources&amp;quot;, where it has been (ab-)used in creative ways to prototype extensions for the ALEP formalism such as set descriptions, linear precedence constraints and guarded constraints (Manandhar, 1994; Manandhar, 1995). • Deutsche Forschungsgemeinschaft, Special Research Division 314 &amp;quot;Artificial Intelligence - Knowledge-Based Systems&amp;quot; through project N3 &amp;quot;Bidirectional Linguistic Deduction&amp;quot; (BiLD), where it is used to compile typed feature grammars into logic grammars, for which bidirectional NLP algorithms are developed, and • Cray Systems (formerly PE-Luxembourg), with whom we had fruitful interaction concerning the future development of the ALEP system-. Some code for handling of finite domains was adapted from a program by Gertjan van Noord. Wojciech Skut and Christian Braun were a grea</context>
</contexts>
<marker>Manandhar, 1994</marker>
<rawString>Suresh Manandhar. 1994. An attributive logic of set descriptions and set operations. In 32nd Annual Meeting of the Association for Computational Linguistics (ACL), pages 255 -262, Las Cruces, NM.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Suresh Manandhar</author>
</authors>
<title>Deterministic consistency checking of LP constraints.</title>
<date>1995</date>
<booktitle>In Seventh Conference of the European Chapter of the Association for Computational Linguistics (EA CL),</booktitle>
<location>Dublin.</location>
<contexts>
<context position="28723" citStr="Manandhar, 1995" startWordPosition="4625" endWordPosition="4626">olog programs, all the techniques developed for the optimisation of logic programs (partial evaluation, tabulation, indexing, program transformation techniques etc.) can be applied straightforwardly to improve the performance of sorted feature grammars. 6 Acknowledgements This work was supported by • The Commission of the European Communities through the project LRE-61-061 &amp;quot;Reusable Grammatical Resources&amp;quot;, where it has been (ab-)used in creative ways to prototype extensions for the ALEP formalism such as set descriptions, linear precedence constraints and guarded constraints (Manandhar, 1994; Manandhar, 1995). • Deutsche Forschungsgemeinschaft, Special Research Division 314 &amp;quot;Artificial Intelligence - Knowledge-Based Systems&amp;quot; through project N3 &amp;quot;Bidirectional Linguistic Deduction&amp;quot; (BiLD), where it is used to compile typed feature grammars into logic grammars, for which bidirectional NLP algorithms are developed, and • Cray Systems (formerly PE-Luxembourg), with whom we had fruitful interaction concerning the future development of the ALEP system-. Some code for handling of finite domains was adapted from a program by Gertjan van Noord. Wojciech Skut and Christian Braun were a great help in testing </context>
</contexts>
<marker>Manandhar, 1995</marker>
<rawString>Suresh Manandhar. 1995. Deterministic consistency checking of LP constraints. In Seventh Conference of the European Chapter of the Association for Computational Linguistics (EA CL), Dublin.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Johannes Matiasek</author>
</authors>
<title>Conditional constraints in a CLP-based HPSG implementation.</title>
<date>1994</date>
<booktitle>KONVENS &apos;94,</booktitle>
<pages>230--239</pages>
<editor>In Harald Trost, editor,</editor>
<location>Vienna.</location>
<contexts>
<context position="4931" citStr="Matiasek, 1994" startWordPosition="754" endWordPosition="755">s (BUP), LR parsers, head-corner parsers, and semantic-head driven generators. • Use of meta-programming for self-monitoring to ensure generation of unambiguous utterances (Neumann and van Noord, 1992) • Work in the area of Explanation-Based Learning (EBL) to learn frequently used structures (Samuelsson, 1994) • Tabulation techniques, from the use of wellformed substring tables to the latest developments in Earley deduction, and memoing techniques for logic programming (Neumann, 1994) • Work based on Constraint Logic Programming (CLP) to provide processing models for principle-based grammars (Matiasek, 1994) • Using coroutining (dif, freeze etc.) to provide more efficient processing models • Partial deduction techniques to produce more efficient grammars • Using Prolog and its indexing facilities to build up a lexicon database Since much of this work involves compilation of grammars into Prolog programs, such programs can immediately benefit from any improvements in Prolog compilers (for example the tabulation provided by XSB Prolog can provide a more efficient implementation of charts) which makes the grammars more usable for NLP systems. 1.3 Combining Logic Grammars and Sorted Feature Formalism</context>
</contexts>
<marker>Matiasek, 1994</marker>
<rawString>Johannes Matiasek. 1994. Conditional constraints in a CLP-based HPSG implementation. In Harald Trost, editor, KONVENS &apos;94, pages 230 - 239, Vienna.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Christopher S Mellish</author>
</authors>
<title>Implementing systemic classification by unification.</title>
<date>1988</date>
<journal>Computational Linguistics,</journal>
<pages>14--1</pages>
<contexts>
<context position="17342" citStr="Mellish, 1988" startWordPosition="2772" endWordPosition="2773">ded structures (head-complement, headmarker, and head-filler structure) is the content value of the head daughter. sem_p( (&lt;head_adj &amp; &gt;&gt;&gt;cont!X &amp; &gt;&gt;&gt;adj_dtr!&gt;&gt;&gt;cont!X ) Or &lt;head_comp or &lt;head_marker or &lt;head_filler ) &amp; &gt;&gt;&gt;cont!Y &amp; &gt;&gt;&gt;head_dtr!&gt;&gt;&gt;cont!Y ) ) . For disjunctions of atoms, there exists a Prolog term representation, which is described below. 4see the complexity analysis by Brew (Brew, 1991). 183 2.7 Finite Domains For domains involving only a finite set of atoms as possible values, it is possible to provide a Prolog term representation (due to Colmerauer, and described by Mellish (Mellish, 1988)) to encode any subset of the possible values in one term. Consider the agreement features person (with values 1, 2 and 3) and number (with values sg and pl). For the two features together there are six possible combinations of values (1Sisg, 2Sisg, nag, 3Sipl). Any subset of this set of possible values can be encoded as one Prolog term. The following example shows the declaration needed for this finite domain, and some clauses that refer to subsets of the possible agreement values by making use of the logical connectives (negation), Si (conjunction), or (disjunction) .5 agr fin_dom [1,2,3] [s</context>
<context position="19836" citStr="Mellish, 1988" startWordPosition="3200" endWordPosition="3201">on, disjunction and negation connectives, the specification of the domain can be omitted. In the example, the domain must only be specified for the value 2, which could otherwise be confused with the integer 2. the dreaded occur check must be performed. Since this must be done only when results are printed out as ProFIT terms, it does not affect the runtime performance. 3 From ProFIT terms to Prolog terms 3.1 Compilation of Sorted Feature Terms The compilation of sorted feature terms into a Prolog term representation is based on the following principles, which are explained in more detail in (Mellish, 1988; Mellish, 1992; SchOter, 1993; Erbach, 1994). • The Prolog representation of a sort is an instance of the Prolog representation of its supersorts. • Features are represented by arguments. If a feature is introduced by a subsort, then the argument is added to the term that further instantiates its supersort. • Mutually exclusive sorts have different functors at the same argument position, so that their unification fails. We illustrate these principles for compiling sorted feature terms into Prolog terms with an example from HPSG. The following declaration states that the sort sign has two mutu</context>
<context position="21745" citStr="Mellish, 1988" startWordPosition="3484" endWordPosition="3485">chy &amp;quot;dimensions&amp;quot; for subsorts of phrasal, and one new feature. The corresponding Prolog term representation instantiates the representation for the sort sign further, and leaves argument positions that can be instantiated further by the subsorts of phrasal, and for the newly introduced feature daughters. phrasal &gt; [headed,non_headed] * [decl,int ,rel] intro [daughters]. 184 $sign(Var, $phrasal(Phrasesort,Clausesort,Dtrs), Phon, Synsem, Qstore, Retrieved) 3.2 Compilation of Finite Domains The compilation of finite domains into Prolog terms is performed by the &amp;quot;brute-force&amp;quot; method described in (Mellish, 1988). A finite domain with n possible domain elements is represented by a Prolog term with n 1 arguments. Each domain element is associated with a pair of adjacent arguments. For example, the agreement domain agr from section 2.7 with its six elements (lAzsg, 2&amp;sg, 3&amp;sg, 1(41, 2Szpl, 3Szpl) is represented by a Prolog term with seven arguments. Sagr(1,A,B,C,D,E,O) Note that the first and last argument must be different. In the example, this is achieved by instantiation with different atoms, but an inequality constraint (Prolog H&apos;s dif) would serve the same purpose. We assume that the domain element</context>
</contexts>
<marker>Mellish, 1988</marker>
<rawString>Christopher S. Mellish. 1988. Implementing systemic classification by unification. Computational Linguistics, 14(1):40-51.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Christopher S Mellish</author>
</authors>
<title>Term-encodable description spaces.</title>
<date>1992</date>
<booktitle>Logic Programming: New Frontiers,</booktitle>
<pages>189--207</pages>
<editor>In D. R. Brough, editor,</editor>
<publisher>Intellect,</publisher>
<location>Oxford.</location>
<contexts>
<context position="5660" citStr="Mellish, 1992" startWordPosition="864" endWordPosition="865">to produce more efficient grammars • Using Prolog and its indexing facilities to build up a lexicon database Since much of this work involves compilation of grammars into Prolog programs, such programs can immediately benefit from any improvements in Prolog compilers (for example the tabulation provided by XSB Prolog can provide a more efficient implementation of charts) which makes the grammars more usable for NLP systems. 1.3 Combining Logic Grammars and Sorted Feature Formalisms It has been noted that first-order Prolog terms provide the equivalent expressive power as sorted feature terms (Mellish, 1992). For example, Carpenter&apos;s typed feature structures (Carpenter, 1992) can easily be represented as Prolog terms, if the restriction is given up that the sort hierarchy be a bounded complete partial order. Such compilation of sorted feature terms into Prolog terms has been successfully used in the Core Language Engine (CLE) (Alshawi, 1991) and in the Advanced Linguistic Engineering Platform (ALEP), (Alshawi et al., 1991).2 ProFIT extends the compilation techniques of these systems through the handling of multi-dimensional inheritance (Erbach, 1994), and makes them generally available for a wide</context>
<context position="19851" citStr="Mellish, 1992" startWordPosition="3202" endWordPosition="3203"> and negation connectives, the specification of the domain can be omitted. In the example, the domain must only be specified for the value 2, which could otherwise be confused with the integer 2. the dreaded occur check must be performed. Since this must be done only when results are printed out as ProFIT terms, it does not affect the runtime performance. 3 From ProFIT terms to Prolog terms 3.1 Compilation of Sorted Feature Terms The compilation of sorted feature terms into a Prolog term representation is based on the following principles, which are explained in more detail in (Mellish, 1988; Mellish, 1992; SchOter, 1993; Erbach, 1994). • The Prolog representation of a sort is an instance of the Prolog representation of its supersorts. • Features are represented by arguments. If a feature is introduced by a subsort, then the argument is added to the term that further instantiates its supersort. • Mutually exclusive sorts have different functors at the same argument position, so that their unification fails. We illustrate these principles for compiling sorted feature terms into Prolog terms with an example from HPSG. The following declaration states that the sort sign has two mutually exclusive </context>
</contexts>
<marker>Mellish, 1992</marker>
<rawString>Christopher S. Mellish. 1992. Term-encodable description spaces. In D. R. Brough, editor, Logic Programming: New Frontiers, pages 189 - 207. Intellect, Oxford.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Gunter Neumann</author>
<author>Gertjan van Noord</author>
</authors>
<title>Self-monitoring with reversible grammars.</title>
<date>1992</date>
<booktitle>In Proceedings of the 14th International Conference on Computational Linguistics,</booktitle>
<location>Nantes, F.</location>
<marker>Neumann, van Noord, 1992</marker>
<rawString>Gunter Neumann and Gertjan van Noord. 1992. Self-monitoring with reversible grammars. In Proceedings of the 14th International Conference on Computational Linguistics, Nantes, F.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Giinter Neumann</author>
</authors>
<title>A Uniform Computational Model for Natural Language Parsing and Generation.</title>
<date>1994</date>
<tech>Ph.D. thesis,</tech>
<institution>Universitat des Saarlandes, Saabriicken.</institution>
<contexts>
<context position="4805" citStr="Neumann, 1994" startWordPosition="736" endWordPosition="737">iling grammars into efficient parsers and generators: compilation of DCGs into (top-down) Prolog programs, left-corner parsers (BUP), LR parsers, head-corner parsers, and semantic-head driven generators. • Use of meta-programming for self-monitoring to ensure generation of unambiguous utterances (Neumann and van Noord, 1992) • Work in the area of Explanation-Based Learning (EBL) to learn frequently used structures (Samuelsson, 1994) • Tabulation techniques, from the use of wellformed substring tables to the latest developments in Earley deduction, and memoing techniques for logic programming (Neumann, 1994) • Work based on Constraint Logic Programming (CLP) to provide processing models for principle-based grammars (Matiasek, 1994) • Using coroutining (dif, freeze etc.) to provide more efficient processing models • Partial deduction techniques to produce more efficient grammars • Using Prolog and its indexing facilities to build up a lexicon database Since much of this work involves compilation of grammars into Prolog programs, such programs can immediately benefit from any improvements in Prolog compilers (for example the tabulation provided by XSB Prolog can provide a more efficient implementat</context>
</contexts>
<marker>Neumann, 1994</marker>
<rawString>Giinter Neumann. 1994. A Uniform Computational Model for Natural Language Parsing and Generation. Ph.D. thesis, Universitat des Saarlandes, Saabriicken.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Christer Samuelsson</author>
</authors>
<title>Fast NaturalLanguage Parsing Using Explanation-Based Learning.</title>
<date>1994</date>
<tech>Ph.D. thesis,</tech>
<institution>The Royal Institute of Technology and Stockholm University,</institution>
<location>Stockholm.</location>
<contexts>
<context position="4627" citStr="Samuelsson, 1994" startWordPosition="709" endWordPosition="710">t available. 1.2 Efficient Processing based on Logic Grammars Much work on efficient processing algorithms has been done in the logic grammar framework. This includes work on • Compiling grammars into efficient parsers and generators: compilation of DCGs into (top-down) Prolog programs, left-corner parsers (BUP), LR parsers, head-corner parsers, and semantic-head driven generators. • Use of meta-programming for self-monitoring to ensure generation of unambiguous utterances (Neumann and van Noord, 1992) • Work in the area of Explanation-Based Learning (EBL) to learn frequently used structures (Samuelsson, 1994) • Tabulation techniques, from the use of wellformed substring tables to the latest developments in Earley deduction, and memoing techniques for logic programming (Neumann, 1994) • Work based on Constraint Logic Programming (CLP) to provide processing models for principle-based grammars (Matiasek, 1994) • Using coroutining (dif, freeze etc.) to provide more efficient processing models • Partial deduction techniques to produce more efficient grammars • Using Prolog and its indexing facilities to build up a lexicon database Since much of this work involves compilation of grammars into Prolog pro</context>
</contexts>
<marker>Samuelsson, 1994</marker>
<rawString>Christer Samuelsson. 1994. Fast NaturalLanguage Parsing Using Explanation-Based Learning. Ph.D. thesis, The Royal Institute of Technology and Stockholm University, Stockholm.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Andreas P Schoter</author>
</authors>
<title>Compiling feature structures into terms: A case study in Prolog.</title>
<date>1993</date>
<tech>Technical Report RP-55,</tech>
<institution>University of Edinburgh, Centre for Cognitive Science.</institution>
<contexts>
<context position="26989" citStr="Schoter, 1993" startWordPosition="4359" endWordPosition="4360">runtimes with ALE and the Eisele-Dorre algorithm for unsorted feature unification for the following tasks: (i) unification of (unsorted) feature structures, (ii) unification of inconsistent feature structures (unification failure), (iii) unification of sorts, (iv) lookup of one of 10000 feature structures (e.g. lexical items), (v) parsing with an HPSG grammar to provide a mix of the above tasks. The timings obtained so far indicate that ProFIT is 5 to 10 times faster than a system which implements a unification algorithm on top of Prolog, a result which is predicted by the studies of SchOter (Schoter, 1993) and the experience of the Core Language Engine. The ProFIT system and documentation are available free of charge by anonymous ftp (server: ftp .coli.uni-sb .de, directory: pub /profit) . 5 Conclusion ProFIT allows the use of sorted feature terms in Prolog programs and Logic Grammars without sacrificing the efficiency of Prolog&apos;s term unification. It is very likely that the most efficient commercial Prolog systems, which provide a basis for the implementation of NLP systems, will conform to the proposed ISO standard. Since the ISO standard includes neither inheritance hierarchies nor feature t</context>
</contexts>
<marker>Schoter, 1993</marker>
<rawString>Andreas P. Schoter. 1993. Compiling feature structures into terms: A case study in Prolog. Technical Report RP-55, University of Edinburgh, Centre for Cognitive Science.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Gert Smolka</author>
<author>Martin Henz</author>
<author>Jorg Wiirtz</author>
</authors>
<title>Object-oriented concurrent constraint programming in Oz.</title>
<date>1995</date>
<booktitle>Principles and Practice of Constraint Programming, chapter 2,</booktitle>
<pages>27--48</pages>
<editor>In P. van Hentenryck and V. Saraswat, editors,</editor>
<publisher>The MIT Press.</publisher>
<contexts>
<context position="3889" citStr="Smolka et al., 1995" startWordPosition="603" endWordPosition="606"> mirror these subsumption relationships. Implementations of sorted feature formalisms such as TDL (Krieger and Schafer, 1994), ALE (Carpenter, 1993), CUF (DOrre and Dorna, 1993), TFS (Emele and Zajac, 1990) and others have been used successfully for the development and testing of large grammars and lexicons, but they may be too slow for actual use in applications 180 because they are generally built on top of Prolog or LISP, and can therefore not be as efficient as the built-in unification of Prolog. There are a few logic programming langauges, such as LIFE (Ait-Kaci and Lincoln, 1989) or Oz (Smolka et al., 1995), that provide sorted feature terms, but no commercial implementations of these languages with efficient compilers are yet available. 1.2 Efficient Processing based on Logic Grammars Much work on efficient processing algorithms has been done in the logic grammar framework. This includes work on • Compiling grammars into efficient parsers and generators: compilation of DCGs into (top-down) Prolog programs, left-corner parsers (BUP), LR parsers, head-corner parsers, and semantic-head driven generators. • Use of meta-programming for self-monitoring to ensure generation of unambiguous utterances (</context>
</contexts>
<marker>Smolka, Henz, Wiirtz, 1995</marker>
<rawString>Gert Smolka, Martin Henz, and Jorg Wiirtz. 1995. Object-oriented concurrent constraint programming in Oz. In P. van Hentenryck and V. Saraswat, editors, Principles and Practice of Constraint Programming, chapter 2, pages 27--48. The MIT Press.</rawString>
</citation>
<citation valid="false">
<journal>I FINDOM &amp; FINDOM FINDOM or FINDOM</journal>
<volume>1</volume>
<location>Atom</location>
<marker></marker>
<rawString>I FINDOM &amp; FINDOM FINDOM or FINDOM 1 Atom</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>